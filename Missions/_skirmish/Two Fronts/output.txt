// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41683 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42134 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31775 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31775 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31775 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32238 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42053 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43001 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41962 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41962 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32238 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32238 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32238 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 69073 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31291 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31291 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31291 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31291 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32284 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41962 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31132 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41962 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31132 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41962 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31132 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41962 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31132 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41962 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42053 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41962 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41962 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41962 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41962 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41962 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41962 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41962 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41962 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41962 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41962 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41962 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41962 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31132 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31132 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31132 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31132 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31132 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31132 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31132 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31132 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31132 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31132 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31132 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31132 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32063 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31291 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31775 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31775 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32165 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42053 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41962 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41962 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41962 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41962 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42053 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28640: LD_EXP 39
28644: PUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL_OW 255
28654: ARRAY
28655: IFFALSE 29382
// begin side := GetSide ( veh ) ;
28657: LD_ADDR_VAR 0 4
28661: PUSH
28662: LD_VAR 0 1
28666: PPUSH
28667: CALL_OW 255
28671: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28672: LD_ADDR_VAR 0 6
28676: PUSH
28677: LD_VAR 0 1
28681: PPUSH
28682: CALL_OW 265
28686: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28687: LD_ADDR_VAR 0 7
28691: PUSH
28692: LD_VAR 0 1
28696: PPUSH
28697: CALL_OW 262
28701: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28702: LD_ADDR_VAR 0 8
28706: PUSH
28707: LD_VAR 0 1
28711: PPUSH
28712: CALL_OW 263
28716: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28717: LD_ADDR_VAR 0 9
28721: PUSH
28722: LD_VAR 0 1
28726: PPUSH
28727: CALL_OW 264
28731: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28732: LD_STRING VehicleConstructed [side: 
28734: PUSH
28735: LD_VAR 0 4
28739: STR
28740: PUSH
28741: LD_STRING ; id:
28743: STR
28744: PUSH
28745: LD_VAR 0 1
28749: STR
28750: PUSH
28751: LD_STRING ; components: [
28753: STR
28754: PUSH
28755: LD_VAR 0 6
28759: STR
28760: PUSH
28761: LD_STRING , 
28763: STR
28764: PUSH
28765: LD_VAR 0 7
28769: STR
28770: PUSH
28771: LD_STRING , 
28773: STR
28774: PUSH
28775: LD_VAR 0 8
28779: STR
28780: PUSH
28781: LD_STRING , 
28783: STR
28784: PUSH
28785: LD_VAR 0 9
28789: STR
28790: PUSH
28791: LD_STRING ]]
28793: STR
28794: PPUSH
28795: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28799: LD_VAR 0 1
28803: PPUSH
28804: CALL_OW 264
28808: PUSH
28809: LD_INT 13
28811: PUSH
28812: LD_INT 12
28814: PUSH
28815: LD_INT 14
28817: PUSH
28818: LD_INT 51
28820: PUSH
28821: LD_INT 53
28823: PUSH
28824: LD_INT 52
28826: PUSH
28827: LD_INT 32
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: IN
28839: NOT
28840: IFFALSE 28882
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28842: LD_ADDR_EXP 59
28846: PUSH
28847: LD_EXP 59
28851: PPUSH
28852: LD_VAR 0 4
28856: PPUSH
28857: LD_EXP 59
28861: PUSH
28862: LD_VAR 0 4
28866: ARRAY
28867: PUSH
28868: LD_INT 1
28870: PLUS
28871: PPUSH
28872: LD_VAR 0 1
28876: PPUSH
28877: CALL 31132 0 4
28881: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28882: LD_VAR 0 1
28886: PPUSH
28887: CALL_OW 264
28891: PUSH
28892: LD_INT 31
28894: EQUAL
28895: IFFALSE 28914
// SetTag ( GetDriver ( veh ) , 9 ) ;
28897: LD_VAR 0 1
28901: PPUSH
28902: CALL 31775 0 1
28906: PPUSH
28907: LD_INT 9
28909: PPUSH
28910: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28914: LD_VAR 0 1
28918: PPUSH
28919: CALL_OW 264
28923: PUSH
28924: LD_INT 14
28926: PUSH
28927: LD_INT 53
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: IN
28934: IFFALSE 28971
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28936: LD_ADDR_EXP 42
28940: PUSH
28941: LD_EXP 42
28945: PPUSH
28946: LD_VAR 0 1
28950: PPUSH
28951: CALL_OW 255
28955: PPUSH
28956: LD_INT 2
28958: PPUSH
28959: LD_VAR 0 1
28963: PPUSH
28964: CALL 31132 0 4
28968: ST_TO_ADDR
// exit ;
28969: GO 29382
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 265
28980: PUSH
28981: LD_EXP 66
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: PUSH
28997: LD_VAR 0 1
29001: PPUSH
29002: CALL_OW 262
29006: PUSH
29007: LD_EXP 66
29011: PUSH
29012: LD_VAR 0 4
29016: ARRAY
29017: PUSH
29018: LD_INT 1
29020: ARRAY
29021: IN
29022: AND
29023: PUSH
29024: LD_VAR 0 1
29028: PPUSH
29029: CALL_OW 263
29033: PUSH
29034: LD_EXP 66
29038: PUSH
29039: LD_VAR 0 4
29043: ARRAY
29044: PUSH
29045: LD_INT 1
29047: ARRAY
29048: IN
29049: AND
29050: PUSH
29051: LD_VAR 0 1
29055: PPUSH
29056: CALL_OW 264
29060: PUSH
29061: LD_EXP 66
29065: PUSH
29066: LD_VAR 0 4
29070: ARRAY
29071: PUSH
29072: LD_INT 1
29074: ARRAY
29075: IN
29076: AND
29077: IFFALSE 29121
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29079: LD_ADDR_EXP 67
29083: PUSH
29084: LD_EXP 67
29088: PPUSH
29089: LD_VAR 0 4
29093: PPUSH
29094: LD_EXP 67
29098: PUSH
29099: LD_VAR 0 4
29103: ARRAY
29104: PUSH
29105: LD_INT 1
29107: PLUS
29108: PPUSH
29109: LD_VAR 0 1
29113: PPUSH
29114: CALL 31132 0 4
29118: ST_TO_ADDR
// exit ;
29119: GO 29382
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29121: LD_VAR 0 6
29125: PUSH
29126: LD_EXP 69
29130: PUSH
29131: LD_VAR 0 4
29135: ARRAY
29136: PUSH
29137: LD_INT 1
29139: ARRAY
29140: EQUAL
29141: PUSH
29142: LD_VAR 0 7
29146: PUSH
29147: LD_EXP 69
29151: PUSH
29152: LD_VAR 0 4
29156: ARRAY
29157: PUSH
29158: LD_INT 2
29160: ARRAY
29161: EQUAL
29162: AND
29163: PUSH
29164: LD_VAR 0 8
29168: PUSH
29169: LD_EXP 69
29173: PUSH
29174: LD_VAR 0 4
29178: ARRAY
29179: PUSH
29180: LD_INT 3
29182: ARRAY
29183: EQUAL
29184: AND
29185: PUSH
29186: LD_VAR 0 9
29190: PUSH
29191: LD_EXP 69
29195: PUSH
29196: LD_VAR 0 4
29200: ARRAY
29201: PUSH
29202: LD_INT 4
29204: ARRAY
29205: EQUAL
29206: AND
29207: IFFALSE 29363
// begin tmp := MREG_ToAttack [ side ] ;
29209: LD_ADDR_VAR 0 5
29213: PUSH
29214: LD_EXP 69
29218: PUSH
29219: LD_VAR 0 4
29223: ARRAY
29224: ST_TO_ADDR
// for i = 1 to 4 do
29225: LD_ADDR_VAR 0 3
29229: PUSH
29230: DOUBLE
29231: LD_INT 1
29233: DEC
29234: ST_TO_ADDR
29235: LD_INT 4
29237: PUSH
29238: FOR_TO
29239: IFFALSE 29261
// tmp := Delete ( tmp , 1 ) ;
29241: LD_ADDR_VAR 0 5
29245: PUSH
29246: LD_VAR 0 5
29250: PPUSH
29251: LD_INT 1
29253: PPUSH
29254: CALL_OW 3
29258: ST_TO_ADDR
29259: GO 29238
29261: POP
29262: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29263: LD_ADDR_EXP 69
29267: PUSH
29268: LD_EXP 69
29272: PPUSH
29273: LD_VAR 0 4
29277: PPUSH
29278: LD_VAR 0 5
29282: PPUSH
29283: CALL_OW 1
29287: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29288: LD_ADDR_EXP 71
29292: PUSH
29293: LD_EXP 71
29297: PPUSH
29298: LD_VAR 0 4
29302: PPUSH
29303: LD_EXP 71
29307: PUSH
29308: LD_VAR 0 4
29312: ARRAY
29313: PUSH
29314: LD_INT 1
29316: PLUS
29317: PPUSH
29318: LD_VAR 0 1
29322: PPUSH
29323: CALL 31132 0 4
29327: ST_TO_ADDR
// if tmp = 0 then
29328: LD_VAR 0 5
29332: PUSH
29333: LD_INT 0
29335: EQUAL
29336: IFFALSE 29361
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29338: LD_ADDR_EXP 69
29342: PUSH
29343: LD_EXP 69
29347: PPUSH
29348: LD_VAR 0 4
29352: PPUSH
29353: LD_INT 0
29355: PPUSH
29356: CALL_OW 1
29360: ST_TO_ADDR
// exit ;
29361: GO 29382
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29363: LD_VAR 0 1
29367: PPUSH
29368: CALL_OW 255
29372: PPUSH
29373: LD_VAR 0 1
29377: PPUSH
29378: CALL 25757 0 2
// end ;
29382: PPOPN 9
29384: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29385: LD_EXP 39
29389: PUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: ARRAY
29400: IFFALSE 29632
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29402: LD_STRING ApemanTamed [side: 
29404: PUSH
29405: LD_VAR 0 2
29409: PPUSH
29410: CALL_OW 255
29414: STR
29415: PUSH
29416: LD_STRING ; sci: 
29418: STR
29419: PUSH
29420: LD_VAR 0 2
29424: STR
29425: PUSH
29426: LD_STRING ; ape: 
29428: STR
29429: PUSH
29430: LD_VAR 0 1
29434: STR
29435: PUSH
29436: LD_STRING ]
29438: STR
29439: PPUSH
29440: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29444: LD_INT 11
29446: PPUSH
29447: LD_VAR 0 2
29451: PPUSH
29452: CALL_OW 255
29456: PPUSH
29457: CALL_OW 321
29461: PUSH
29462: LD_INT 2
29464: EQUAL
29465: NOT
29466: PUSH
29467: LD_INT 2
29469: PPUSH
29470: LD_VAR 0 2
29474: PPUSH
29475: CALL_OW 255
29479: PPUSH
29480: CALL_OW 321
29484: PUSH
29485: LD_INT 2
29487: EQUAL
29488: NOT
29489: OR
29490: PUSH
29491: LD_VAR 0 2
29495: PPUSH
29496: CALL_OW 255
29500: PPUSH
29501: LD_INT 171
29503: PPUSH
29504: EMPTY
29505: PPUSH
29506: CALL 12370 0 3
29510: PUSH
29511: LD_INT 0
29513: EQUAL
29514: AND
29515: IFFALSE 29529
// begin SetTag ( ape , 171 ) ;
29517: LD_VAR 0 1
29521: PPUSH
29522: LD_INT 171
29524: PPUSH
29525: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29529: LD_VAR 0 2
29533: PPUSH
29534: CALL_OW 255
29538: PPUSH
29539: LD_INT 30
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PPUSH
29549: CALL 11667 0 2
29553: IFFALSE 29632
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29555: LD_VAR 0 1
29559: PPUSH
29560: LD_VAR 0 2
29564: PPUSH
29565: CALL_OW 255
29569: PPUSH
29570: LD_INT 30
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PPUSH
29580: CALL 11667 0 2
29584: PUSH
29585: LD_INT 1
29587: ARRAY
29588: PPUSH
29589: CALL_OW 250
29593: PPUSH
29594: LD_VAR 0 2
29598: PPUSH
29599: CALL_OW 255
29603: PPUSH
29604: LD_INT 30
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL 11667 0 2
29618: PUSH
29619: LD_INT 1
29621: ARRAY
29622: PPUSH
29623: CALL_OW 251
29627: PPUSH
29628: CALL_OW 111
// end ;
29632: PPOPN 2
29634: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29635: LD_EXP 39
29639: PUSH
29640: LD_VAR 0 1
29644: PPUSH
29645: CALL_OW 255
29649: ARRAY
29650: IFFALSE 29928
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29652: LD_VAR 0 2
29656: PUSH
29657: LD_VAR 0 2
29661: PPUSH
29662: CALL_OW 255
29666: PPUSH
29667: CALL 12080 0 1
29671: IN
29672: IFFALSE 29813
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29674: LD_VAR 0 1
29678: PPUSH
29679: CALL_OW 266
29683: PUSH
29684: LD_INT 0
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: IN
29694: IFFALSE 29724
// begin Wait ( 0 0$0.3 ) ;
29696: LD_INT 10
29698: PPUSH
29699: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29703: LD_VAR 0 2
29707: PPUSH
29708: LD_INT 16
29710: PPUSH
29711: CALL_OW 336
// ComExitBuilding ( un ) ;
29715: LD_VAR 0 2
29719: PPUSH
29720: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29724: LD_VAR 0 1
29728: PPUSH
29729: CALL_OW 266
29733: PUSH
29734: LD_INT 4
29736: PUSH
29737: LD_INT 5
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: IN
29744: IFFALSE 29813
// begin Wait ( 0 0$0.3 ) ;
29746: LD_INT 10
29748: PPUSH
29749: CALL_OW 67
// if GetTag ( un ) = 0 then
29753: LD_VAR 0 2
29757: PPUSH
29758: CALL_OW 110
29762: PUSH
29763: LD_INT 0
29765: EQUAL
29766: IFFALSE 29782
// SetClass ( un , class_apeman_soldier ) else
29768: LD_VAR 0 2
29772: PPUSH
29773: LD_INT 15
29775: PPUSH
29776: CALL_OW 336
29780: GO 29813
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29782: LD_INT 3
29784: PPUSH
29785: LD_VAR 0 2
29789: PPUSH
29790: CALL_OW 255
29794: PPUSH
29795: CALL_OW 321
29799: IFFALSE 29813
// SetClass ( un , class_apeman_kamikaze ) ;
29801: LD_VAR 0 2
29805: PPUSH
29806: LD_INT 17
29808: PPUSH
29809: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29813: LD_VAR 0 1
29817: PPUSH
29818: CALL_OW 266
29822: PUSH
29823: LD_INT 32
29825: EQUAL
29826: IFFALSE 29928
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29828: LD_ADDR_EXP 68
29832: PUSH
29833: LD_EXP 68
29837: PPUSH
29838: LD_VAR 0 1
29842: PPUSH
29843: CALL_OW 255
29847: PPUSH
29848: LD_EXP 68
29852: PUSH
29853: LD_VAR 0 1
29857: PPUSH
29858: CALL_OW 255
29862: ARRAY
29863: PUSH
29864: LD_INT 1
29866: PLUS
29867: PPUSH
29868: LD_VAR 0 1
29872: PPUSH
29873: CALL 31132 0 4
29877: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29878: LD_ADDR_EXP 68
29882: PUSH
29883: LD_EXP 68
29887: PPUSH
29888: LD_VAR 0 1
29892: PPUSH
29893: CALL_OW 255
29897: PPUSH
29898: LD_EXP 68
29902: PUSH
29903: LD_VAR 0 1
29907: PPUSH
29908: CALL_OW 255
29912: ARRAY
29913: PUSH
29914: LD_INT 1
29916: PLUS
29917: PPUSH
29918: LD_VAR 0 2
29922: PPUSH
29923: CALL 31132 0 4
29927: ST_TO_ADDR
// end ; end ;
29928: PPOPN 2
29930: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29931: LD_VAR 0 1
29935: PPUSH
29936: CALL 57219 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29940: LD_VAR 0 1
29944: PUSH
29945: LD_INT 22
29947: PUSH
29948: LD_INT 3
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 23
29957: PUSH
29958: LD_INT 3
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 21
29967: PUSH
29968: LD_INT 1
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: LIST
29979: PPUSH
29980: CALL_OW 69
29984: IN
29985: IFFALSE 30001
// player_loss := player_loss + 1 ;
29987: LD_ADDR_EXP 10
29991: PUSH
29992: LD_EXP 10
29996: PUSH
29997: LD_INT 1
29999: PLUS
30000: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30001: LD_VAR 0 1
30005: PUSH
30006: LD_INT 22
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 21
30018: PUSH
30019: LD_INT 3
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PPUSH
30030: CALL_OW 69
30034: IN
30035: PUSH
30036: LD_EXP 14
30040: NOT
30041: AND
30042: IFFALSE 30105
// begin alfa_north_triggered := true ;
30044: LD_ADDR_EXP 14
30048: PUSH
30049: LD_INT 1
30051: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30052: LD_EXP 5
30056: PPUSH
30057: LD_STRING DS4
30059: PPUSH
30060: CALL_OW 94
// Wait ( 1 1$25 ) ;
30064: LD_INT 2975
30066: PPUSH
30067: CALL_OW 67
// if not isTest then
30071: LD_EXP 1
30075: NOT
30076: IFFALSE 30105
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30078: LD_INT 20
30080: PPUSH
30081: LD_INT 5
30083: PUSH
30084: LD_INT 6
30086: PUSH
30087: LD_INT 7
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: LIST
30094: PUSH
30095: LD_OWVAR 67
30099: ARRAY
30100: PPUSH
30101: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30105: LD_VAR 0 1
30109: PUSH
30110: LD_INT 22
30112: PUSH
30113: LD_INT 4
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 21
30122: PUSH
30123: LD_INT 3
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PPUSH
30134: CALL_OW 69
30138: IN
30139: PUSH
30140: LD_EXP 15
30144: NOT
30145: AND
30146: IFFALSE 30209
// begin alfa_south_triggered := true ;
30148: LD_ADDR_EXP 15
30152: PUSH
30153: LD_INT 1
30155: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30156: LD_EXP 4
30160: PPUSH
30161: LD_STRING DJ3
30163: PPUSH
30164: CALL_OW 94
// Wait ( 0 0$45 ) ;
30168: LD_INT 1575
30170: PPUSH
30171: CALL_OW 67
// if not isTest then
30175: LD_EXP 1
30179: NOT
30180: IFFALSE 30209
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30182: LD_INT 20
30184: PPUSH
30185: LD_INT 5
30187: PUSH
30188: LD_INT 6
30190: PUSH
30191: LD_INT 7
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: LIST
30198: PUSH
30199: LD_OWVAR 67
30203: ARRAY
30204: PPUSH
30205: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30209: LD_VAR 0 1
30213: PPUSH
30214: CALL_OW 266
30218: PUSH
30219: LD_INT 1
30221: EQUAL
30222: PUSH
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 255
30232: PUSH
30233: LD_INT 1
30235: PUSH
30236: LD_INT 4
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: IN
30243: AND
30244: IFFALSE 30253
// RaiseSailEvent ( 104 ) ;
30246: LD_INT 104
30248: PPUSH
30249: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30253: LD_EXP 39
30257: PUSH
30258: LD_VAR 0 1
30262: PPUSH
30263: CALL_OW 255
30267: ARRAY
30268: IFFALSE 30655
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30270: LD_STRING UnitDestroyed [side 
30272: PUSH
30273: LD_VAR 0 1
30277: PPUSH
30278: CALL_OW 255
30282: STR
30283: PUSH
30284: LD_STRING ; id: 
30286: STR
30287: PUSH
30288: LD_VAR 0 1
30292: STR
30293: PUSH
30294: LD_STRING ; type: 
30296: STR
30297: PUSH
30298: LD_VAR 0 1
30302: PPUSH
30303: CALL_OW 247
30307: STR
30308: PUSH
30309: LD_STRING ]
30311: STR
30312: PPUSH
30313: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30317: LD_VAR 0 1
30321: PUSH
30322: LD_VAR 0 1
30326: PPUSH
30327: CALL_OW 255
30331: PPUSH
30332: LD_INT 21
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PPUSH
30342: CALL 11667 0 2
30346: IN
30347: IFFALSE 30503
// begin if MCF_HasClass ( un ) then
30349: LD_VAR 0 1
30353: PPUSH
30354: CALL 14373 0 1
30358: IFFALSE 30503
// case MCF_HasClass ( un ) of 1 :
30360: LD_VAR 0 1
30364: PPUSH
30365: CALL 14373 0 1
30369: PUSH
30370: LD_INT 1
30372: DOUBLE
30373: EQUAL
30374: IFTRUE 30378
30376: GO 30403
30378: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30379: LD_VAR 0 1
30383: PPUSH
30384: CALL_OW 255
30388: PPUSH
30389: LD_STRING ToArm
30391: PPUSH
30392: LD_VAR 0 1
30396: PPUSH
30397: CALL 14546 0 3
30401: GO 30503
30403: LD_INT 2
30405: DOUBLE
30406: EQUAL
30407: IFTRUE 30411
30409: GO 30436
30411: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30412: LD_VAR 0 1
30416: PPUSH
30417: CALL_OW 255
30421: PPUSH
30422: LD_STRING ToDep
30424: PPUSH
30425: LD_VAR 0 1
30429: PPUSH
30430: CALL 14546 0 3
30434: GO 30503
30436: LD_INT 3
30438: DOUBLE
30439: EQUAL
30440: IFTRUE 30444
30442: GO 30469
30444: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30445: LD_VAR 0 1
30449: PPUSH
30450: CALL_OW 255
30454: PPUSH
30455: LD_STRING ToFac
30457: PPUSH
30458: LD_VAR 0 1
30462: PPUSH
30463: CALL 14546 0 3
30467: GO 30503
30469: LD_INT 4
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30502
30477: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30478: LD_VAR 0 1
30482: PPUSH
30483: CALL_OW 255
30487: PPUSH
30488: LD_STRING ToLab
30490: PPUSH
30491: LD_VAR 0 1
30495: PPUSH
30496: CALL 14546 0 3
30500: GO 30503
30502: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30503: LD_VAR 0 1
30507: PUSH
30508: LD_EXP 67
30512: PUSH
30513: LD_VAR 0 1
30517: PPUSH
30518: CALL_OW 255
30522: ARRAY
30523: IN
30524: IFFALSE 30609
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30526: LD_ADDR_EXP 67
30530: PUSH
30531: LD_EXP 67
30535: PPUSH
30536: LD_VAR 0 1
30540: PPUSH
30541: LD_INT 0
30543: PPUSH
30544: CALL 31291 0 3
30548: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30549: LD_VAR 0 1
30553: PPUSH
30554: CALL_OW 255
30558: PPUSH
30559: LD_VAR 0 1
30563: PPUSH
30564: CALL_OW 265
30568: PUSH
30569: LD_VAR 0 1
30573: PPUSH
30574: CALL_OW 262
30578: PUSH
30579: LD_VAR 0 1
30583: PPUSH
30584: CALL_OW 263
30588: PUSH
30589: LD_VAR 0 1
30593: PPUSH
30594: CALL_OW 264
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: PPUSH
30605: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30609: LD_VAR 0 1
30613: PUSH
30614: LD_EXP 71
30618: PUSH
30619: LD_VAR 0 1
30623: PPUSH
30624: CALL_OW 255
30628: ARRAY
30629: IN
30630: IFFALSE 30655
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30632: LD_ADDR_EXP 71
30636: PUSH
30637: LD_EXP 71
30641: PPUSH
30642: LD_VAR 0 1
30646: PPUSH
30647: LD_INT 0
30649: PPUSH
30650: CALL 31291 0 3
30654: ST_TO_ADDR
// end ; end ;
30655: PPOPN 1
30657: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30658: LD_EXP 39
30662: PUSH
30663: LD_VAR 0 2
30667: PPUSH
30668: CALL_OW 255
30672: ARRAY
30673: IFFALSE 30845
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30675: LD_VAR 0 2
30679: PUSH
30680: LD_EXP 68
30684: PUSH
30685: LD_VAR 0 2
30689: PPUSH
30690: CALL_OW 255
30694: ARRAY
30695: IN
30696: PUSH
30697: LD_VAR 0 1
30701: PPUSH
30702: CALL_OW 266
30706: PUSH
30707: LD_INT 32
30709: PUSH
30710: LD_INT 31
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: IN
30717: AND
30718: IFFALSE 30818
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30720: LD_ADDR_EXP 68
30724: PUSH
30725: LD_EXP 68
30729: PPUSH
30730: LD_VAR 0 1
30734: PPUSH
30735: LD_INT 0
30737: PPUSH
30738: CALL 31291 0 3
30742: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30743: LD_ADDR_EXP 68
30747: PUSH
30748: LD_EXP 68
30752: PPUSH
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL 31291 0 3
30765: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30766: LD_EXP 68
30770: PUSH
30771: LD_VAR 0 2
30775: PPUSH
30776: CALL_OW 255
30780: ARRAY
30781: PUSH
30782: LD_STRING 
30784: EQUAL
30785: IFFALSE 30818
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30787: LD_ADDR_EXP 68
30791: PUSH
30792: LD_EXP 68
30796: PPUSH
30797: LD_VAR 0 2
30801: PPUSH
30802: CALL_OW 255
30806: PPUSH
30807: LD_INT 1
30809: PPUSH
30810: LD_INT 0
30812: PPUSH
30813: CALL 31132 0 4
30817: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30818: LD_VAR 0 1
30822: PPUSH
30823: CALL_OW 266
30827: PUSH
30828: LD_INT 36
30830: IN
30831: IFFALSE 30845
// SetTag ( un , 0 ) ;
30833: LD_VAR 0 2
30837: PPUSH
30838: LD_INT 0
30840: PPUSH
30841: CALL_OW 109
// end ;
30845: PPOPN 2
30847: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30848: LD_EXP 39
30852: PUSH
30853: LD_VAR 0 1
30857: PPUSH
30858: CALL_OW 255
30862: ARRAY
30863: IFFALSE 30889
// begin if GetControl ( un ) = control_remote then
30865: LD_VAR 0 1
30869: PPUSH
30870: CALL_OW 263
30874: PUSH
30875: LD_INT 2
30877: EQUAL
30878: IFFALSE 30889
// ComUnlink ( un ) ;
30880: LD_VAR 0 1
30884: PPUSH
30885: CALL_OW 136
// end ;
30889: PPOPN 1
30891: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30892: LD_EXP 39
30896: PUSH
30897: LD_VAR 0 1
30901: PPUSH
30902: CALL_OW 255
30906: ARRAY
30907: IFFALSE 30936
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30909: LD_VAR 0 2
30913: PPUSH
30914: CALL_OW 264
30918: PUSH
30919: LD_INT 31
30921: IN
30922: IFFALSE 30936
// SetTag ( driver , 0 ) ;
30924: LD_VAR 0 1
30928: PPUSH
30929: LD_INT 0
30931: PPUSH
30932: CALL_OW 109
// end ;
30936: PPOPN 4
30938: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30939: LD_INT 0
30941: PPUSH
30942: PPUSH
30943: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30944: LD_ADDR_VAR 0 3
30948: PUSH
30949: LD_VAR 0 1
30953: PPUSH
30954: CALL_OW 269
30958: ST_TO_ADDR
// x := GetX ( building ) ;
30959: LD_ADDR_VAR 0 4
30963: PUSH
30964: LD_VAR 0 1
30968: PPUSH
30969: CALL_OW 250
30973: ST_TO_ADDR
// y := GetY ( building ) ;
30974: LD_ADDR_VAR 0 5
30978: PUSH
30979: LD_VAR 0 1
30983: PPUSH
30984: CALL_OW 251
30988: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30989: LD_ADDR_EXP 43
30993: PUSH
30994: LD_EXP 43
30998: PPUSH
30999: LD_VAR 0 1
31003: PPUSH
31004: CALL_OW 255
31008: PPUSH
31009: LD_VAR 0 3
31013: PPUSH
31014: LD_VAR 0 4
31018: PUSH
31019: LD_VAR 0 5
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PPUSH
31028: CALL 42053 0 4
31032: ST_TO_ADDR
// end ;
31033: PPOPN 5
31035: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31036: LD_VAR 0 1
31040: PUSH
31041: LD_EXP 30
31045: IN
31046: NOT
31047: IFFALSE 31095
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31049: LD_ADDR_EXP 30
31053: PUSH
31054: LD_EXP 30
31058: PPUSH
31059: LD_EXP 30
31063: PUSH
31064: LD_INT 1
31066: PLUS
31067: PPUSH
31068: LD_VAR 0 1
31072: PPUSH
31073: CALL_OW 2
31077: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31078: LD_STRING DestinationUnrechable. [unit: 
31080: PUSH
31081: LD_VAR 0 1
31085: STR
31086: PUSH
31087: LD_STRING ]
31089: STR
31090: PPUSH
31091: CALL 8055 0 1
// end ; end ;
31095: PPOPN 1
31097: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31098: LD_VAR 0 1
31102: PPUSH
31103: LD_VAR 0 2
31107: PPUSH
31108: LD_VAR 0 3
31112: PPUSH
31113: CALL 57317 0 3
// end ;
31117: PPOPN 3
31119: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31120: LD_VAR 0 1
31124: PPUSH
31125: CALL 57325 0 1
// end ; end_of_file
31129: PPOPN 1
31131: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31132: LD_INT 0
31134: PPUSH
31135: PPUSH
31136: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31137: LD_ADDR_VAR 0 7
31141: PUSH
31142: LD_VAR 0 1
31146: PUSH
31147: LD_VAR 0 2
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 3
31157: PPUSH
31158: LD_VAR 0 4
31162: PPUSH
31163: CALL_OW 1
31167: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31168: LD_ADDR_VAR 0 1
31172: PUSH
31173: LD_VAR 0 1
31177: PPUSH
31178: LD_VAR 0 2
31182: PPUSH
31183: LD_VAR 0 7
31187: PPUSH
31188: CALL_OW 1
31192: ST_TO_ADDR
// result := tab ;
31193: LD_ADDR_VAR 0 5
31197: PUSH
31198: LD_VAR 0 1
31202: ST_TO_ADDR
// end ;
31203: LD_VAR 0 5
31207: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31208: LD_INT 0
31210: PPUSH
31211: PPUSH
31212: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31213: LD_ADDR_VAR 0 5
31217: PUSH
31218: LD_VAR 0 1
31222: PUSH
31223: LD_VAR 0 2
31227: PUSH
31228: LD_INT 1
31230: ARRAY
31231: ARRAY
31232: PPUSH
31233: LD_VAR 0 2
31237: PUSH
31238: LD_INT 2
31240: ARRAY
31241: PPUSH
31242: CALL_OW 3
31246: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31247: LD_ADDR_VAR 0 1
31251: PUSH
31252: LD_VAR 0 1
31256: PPUSH
31257: LD_VAR 0 2
31261: PUSH
31262: LD_INT 1
31264: ARRAY
31265: PPUSH
31266: LD_VAR 0 5
31270: PPUSH
31271: CALL_OW 1
31275: ST_TO_ADDR
// result := tab ;
31276: LD_ADDR_VAR 0 3
31280: PUSH
31281: LD_VAR 0 1
31285: ST_TO_ADDR
// end ;
31286: LD_VAR 0 3
31290: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31291: LD_INT 0
31293: PPUSH
31294: PPUSH
31295: PPUSH
31296: PPUSH
// i := 1 ;
31297: LD_ADDR_VAR 0 5
31301: PUSH
31302: LD_INT 1
31304: ST_TO_ADDR
// while ( i <= tab ) do
31305: LD_VAR 0 5
31309: PUSH
31310: LD_VAR 0 1
31314: LESSEQUAL
31315: IFFALSE 31690
// begin if not tab [ i ] then
31317: LD_VAR 0 1
31321: PUSH
31322: LD_VAR 0 5
31326: ARRAY
31327: NOT
31328: IFFALSE 31332
// break ;
31330: GO 31690
// if value in tab then
31332: LD_VAR 0 2
31336: PUSH
31337: LD_VAR 0 1
31341: IN
31342: IFFALSE 31455
// begin if not mode then
31344: LD_VAR 0 3
31348: NOT
31349: IFFALSE 31369
// tab := tab diff value else
31351: LD_ADDR_VAR 0 1
31355: PUSH
31356: LD_VAR 0 1
31360: PUSH
31361: LD_VAR 0 2
31365: DIFF
31366: ST_TO_ADDR
31367: GO 31431
// for j = 1 to tab do
31369: LD_ADDR_VAR 0 6
31373: PUSH
31374: DOUBLE
31375: LD_INT 1
31377: DEC
31378: ST_TO_ADDR
31379: LD_VAR 0 1
31383: PUSH
31384: FOR_TO
31385: IFFALSE 31429
// if tab [ j ] = value then
31387: LD_VAR 0 1
31391: PUSH
31392: LD_VAR 0 6
31396: ARRAY
31397: PUSH
31398: LD_VAR 0 2
31402: EQUAL
31403: IFFALSE 31427
// begin tab := Delete ( tab , j ) ;
31405: LD_ADDR_VAR 0 1
31409: PUSH
31410: LD_VAR 0 1
31414: PPUSH
31415: LD_VAR 0 6
31419: PPUSH
31420: CALL_OW 3
31424: ST_TO_ADDR
// break ;
31425: GO 31429
// end ;
31427: GO 31384
31429: POP
31430: POP
// i := i - 1 ;
31431: LD_ADDR_VAR 0 5
31435: PUSH
31436: LD_VAR 0 5
31440: PUSH
31441: LD_INT 1
31443: MINUS
31444: ST_TO_ADDR
// if mode then
31445: LD_VAR 0 3
31449: IFFALSE 31453
// break ;
31451: GO 31690
// end else
31453: GO 31674
// if tab [ i ] and value in tab [ i ] then
31455: LD_VAR 0 1
31459: PUSH
31460: LD_VAR 0 5
31464: ARRAY
31465: PUSH
31466: LD_VAR 0 2
31470: PUSH
31471: LD_VAR 0 1
31475: PUSH
31476: LD_VAR 0 5
31480: ARRAY
31481: IN
31482: AND
31483: IFFALSE 31674
// begin if not mode then
31485: LD_VAR 0 3
31489: NOT
31490: IFFALSE 31516
// tmp := tab [ i ] diff value else
31492: LD_ADDR_VAR 0 7
31496: PUSH
31497: LD_VAR 0 1
31501: PUSH
31502: LD_VAR 0 5
31506: ARRAY
31507: PUSH
31508: LD_VAR 0 2
31512: DIFF
31513: ST_TO_ADDR
31514: GO 31596
// for j = 1 to tab [ i ] do
31516: LD_ADDR_VAR 0 6
31520: PUSH
31521: DOUBLE
31522: LD_INT 1
31524: DEC
31525: ST_TO_ADDR
31526: LD_VAR 0 1
31530: PUSH
31531: LD_VAR 0 5
31535: ARRAY
31536: PUSH
31537: FOR_TO
31538: IFFALSE 31594
// if value = tab [ i ] [ j ] then
31540: LD_VAR 0 2
31544: PUSH
31545: LD_VAR 0 1
31549: PUSH
31550: LD_VAR 0 5
31554: ARRAY
31555: PUSH
31556: LD_VAR 0 6
31560: ARRAY
31561: EQUAL
31562: IFFALSE 31592
// begin tmp := Delete ( tab [ i ] , j ) ;
31564: LD_ADDR_VAR 0 7
31568: PUSH
31569: LD_VAR 0 1
31573: PUSH
31574: LD_VAR 0 5
31578: ARRAY
31579: PPUSH
31580: LD_VAR 0 6
31584: PPUSH
31585: CALL_OW 3
31589: ST_TO_ADDR
// break ;
31590: GO 31594
// end ;
31592: GO 31537
31594: POP
31595: POP
// if tmp = [ ] then
31596: LD_VAR 0 7
31600: PUSH
31601: EMPTY
31602: EQUAL
31603: IFFALSE 31627
// begin tab := Delete ( tab , i ) ;
31605: LD_ADDR_VAR 0 1
31609: PUSH
31610: LD_VAR 0 1
31614: PPUSH
31615: LD_VAR 0 5
31619: PPUSH
31620: CALL_OW 3
31624: ST_TO_ADDR
// end else
31625: GO 31652
// tab := Replace ( tab , i , tmp ) ;
31627: LD_ADDR_VAR 0 1
31631: PUSH
31632: LD_VAR 0 1
31636: PPUSH
31637: LD_VAR 0 5
31641: PPUSH
31642: LD_VAR 0 7
31646: PPUSH
31647: CALL_OW 1
31651: ST_TO_ADDR
// i := i - 1 ;
31652: LD_ADDR_VAR 0 5
31656: PUSH
31657: LD_VAR 0 5
31661: PUSH
31662: LD_INT 1
31664: MINUS
31665: ST_TO_ADDR
// if mode then
31666: LD_VAR 0 3
31670: IFFALSE 31674
// break ;
31672: GO 31690
// end ; i := i + 1 ;
31674: LD_ADDR_VAR 0 5
31678: PUSH
31679: LD_VAR 0 5
31683: PUSH
31684: LD_INT 1
31686: PLUS
31687: ST_TO_ADDR
// end ;
31688: GO 31305
// result := tab ;
31690: LD_ADDR_VAR 0 4
31694: PUSH
31695: LD_VAR 0 1
31699: ST_TO_ADDR
// end ;
31700: LD_VAR 0 4
31704: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31705: LD_INT 0
31707: PPUSH
31708: PPUSH
// for i = 1 to values do
31709: LD_ADDR_VAR 0 4
31713: PUSH
31714: DOUBLE
31715: LD_INT 1
31717: DEC
31718: ST_TO_ADDR
31719: LD_VAR 0 2
31723: PUSH
31724: FOR_TO
31725: IFFALSE 31758
// tab := Remove ( tab , values [ i ] , false ) ;
31727: LD_ADDR_VAR 0 1
31731: PUSH
31732: LD_VAR 0 1
31736: PPUSH
31737: LD_VAR 0 2
31741: PUSH
31742: LD_VAR 0 4
31746: ARRAY
31747: PPUSH
31748: LD_INT 0
31750: PPUSH
31751: CALL 31291 0 3
31755: ST_TO_ADDR
31756: GO 31724
31758: POP
31759: POP
// result := tab ;
31760: LD_ADDR_VAR 0 3
31764: PUSH
31765: LD_VAR 0 1
31769: ST_TO_ADDR
// end ;
31770: LD_VAR 0 3
31774: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31775: LD_INT 0
31777: PPUSH
31778: PPUSH
31779: PPUSH
// if not GetControl ( veh ) = control_manual then
31780: LD_VAR 0 1
31784: PPUSH
31785: CALL_OW 263
31789: PUSH
31790: LD_INT 1
31792: EQUAL
31793: NOT
31794: IFFALSE 31806
// result := false else
31796: LD_ADDR_VAR 0 2
31800: PUSH
31801: LD_INT 0
31803: ST_TO_ADDR
31804: GO 31951
// if veh in FilterAllUnits ( [ f_empty ] ) then
31806: LD_VAR 0 1
31810: PUSH
31811: LD_INT 58
31813: PUSH
31814: EMPTY
31815: LIST
31816: PPUSH
31817: CALL_OW 69
31821: IN
31822: IFFALSE 31834
// result := false else
31824: LD_ADDR_VAR 0 2
31828: PUSH
31829: LD_INT 0
31831: ST_TO_ADDR
31832: GO 31951
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31834: LD_ADDR_VAR 0 4
31838: PUSH
31839: LD_INT 22
31841: PUSH
31842: LD_VAR 0 1
31846: PPUSH
31847: CALL_OW 255
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 55
31858: PUSH
31859: EMPTY
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PPUSH
31866: CALL_OW 69
31870: ST_TO_ADDR
// if not filter then
31871: LD_VAR 0 4
31875: NOT
31876: IFFALSE 31888
// result := false else
31878: LD_ADDR_VAR 0 2
31882: PUSH
31883: LD_INT 0
31885: ST_TO_ADDR
31886: GO 31951
// for i = 1 to filter do
31888: LD_ADDR_VAR 0 3
31892: PUSH
31893: DOUBLE
31894: LD_INT 1
31896: DEC
31897: ST_TO_ADDR
31898: LD_VAR 0 4
31902: PUSH
31903: FOR_TO
31904: IFFALSE 31949
// if IsDriver ( filter [ i ] ) = veh then
31906: LD_VAR 0 4
31910: PUSH
31911: LD_VAR 0 3
31915: ARRAY
31916: PPUSH
31917: CALL 95567 0 1
31921: PUSH
31922: LD_VAR 0 1
31926: EQUAL
31927: IFFALSE 31947
// begin result := filter [ i ] ;
31929: LD_ADDR_VAR 0 2
31933: PUSH
31934: LD_VAR 0 4
31938: PUSH
31939: LD_VAR 0 3
31943: ARRAY
31944: ST_TO_ADDR
// break ;
31945: GO 31949
// end ;
31947: GO 31903
31949: POP
31950: POP
// end ; end ;
31951: LD_VAR 0 2
31955: RET
// export function Compare ( val1 , val2 ) ; begin
31956: LD_INT 0
31958: PPUSH
// if val1 = val2 then
31959: LD_VAR 0 1
31963: PUSH
31964: LD_VAR 0 2
31968: EQUAL
31969: IFFALSE 31981
// result := true else
31971: LD_ADDR_VAR 0 3
31975: PUSH
31976: LD_INT 1
31978: ST_TO_ADDR
31979: GO 31989
// result := false ;
31981: LD_ADDR_VAR 0 3
31985: PUSH
31986: LD_INT 0
31988: ST_TO_ADDR
// end ;
31989: LD_VAR 0 3
31993: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31994: LD_INT 0
31996: PPUSH
31997: PPUSH
// result := false ;
31998: LD_ADDR_VAR 0 3
32002: PUSH
32003: LD_INT 0
32005: ST_TO_ADDR
// for j = 1 to e2 do
32006: LD_ADDR_VAR 0 4
32010: PUSH
32011: DOUBLE
32012: LD_INT 1
32014: DEC
32015: ST_TO_ADDR
32016: LD_VAR 0 2
32020: PUSH
32021: FOR_TO
32022: IFFALSE 32056
// if Compare ( e1 , e2 [ j ] ) then
32024: LD_VAR 0 1
32028: PPUSH
32029: LD_VAR 0 2
32033: PUSH
32034: LD_VAR 0 4
32038: ARRAY
32039: PPUSH
32040: CALL 31956 0 2
32044: IFFALSE 32054
// result := true ;
32046: LD_ADDR_VAR 0 3
32050: PUSH
32051: LD_INT 1
32053: ST_TO_ADDR
32054: GO 32021
32056: POP
32057: POP
// end ;
32058: LD_VAR 0 3
32062: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32063: LD_INT 0
32065: PPUSH
32066: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32067: LD_VAR 0 1
32071: PPUSH
32072: LD_STRING C
32074: PUSH
32075: LD_VAR 0 2
32079: PUSH
32080: LD_VAR 0 3
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: LD_INT 0
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: LIST
32104: LIST
32105: PUSH
32106: LD_STRING v
32108: PUSH
32109: LD_VAR 0 4
32113: PPUSH
32114: CALL_OW 250
32118: PUSH
32119: LD_VAR 0 4
32123: PPUSH
32124: CALL_OW 251
32128: PUSH
32129: LD_VAR 0 4
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: LD_INT 0
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PPUSH
32156: CALL_OW 446
// end ;
32160: LD_VAR 0 5
32164: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32165: LD_INT 0
32167: PPUSH
32168: PPUSH
32169: PPUSH
// linked := UnitsLinked ( unit ) ;
32170: LD_ADDR_VAR 0 4
32174: PUSH
32175: LD_VAR 0 1
32179: PPUSH
32180: CALL_OW 432
32184: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_VAR 0 1
32194: PPUSH
32195: LD_INT 3
32197: PPUSH
32198: CALL_OW 259
32202: ST_TO_ADDR
// if sk > linked then
32203: LD_VAR 0 3
32207: PUSH
32208: LD_VAR 0 4
32212: GREATER
32213: IFFALSE 32225
// result := true else
32215: LD_ADDR_VAR 0 2
32219: PUSH
32220: LD_INT 1
32222: ST_TO_ADDR
32223: GO 32233
// result := false ;
32225: LD_ADDR_VAR 0 2
32229: PUSH
32230: LD_INT 0
32232: ST_TO_ADDR
// end ;
32233: LD_VAR 0 2
32237: RET
// export function NotTask ( unit ) ; begin
32238: LD_INT 0
32240: PPUSH
// result := true ;
32241: LD_ADDR_VAR 0 2
32245: PUSH
32246: LD_INT 1
32248: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 437
32258: PUSH
32259: LD_VAR 0 1
32263: PPUSH
32264: CALL_OW 314
32268: OR
32269: IFFALSE 32279
// result := false ;
32271: LD_ADDR_VAR 0 2
32275: PUSH
32276: LD_INT 0
32278: ST_TO_ADDR
// end ;
32279: LD_VAR 0 2
32283: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32284: LD_INT 0
32286: PPUSH
32287: PPUSH
32288: PPUSH
32289: PPUSH
32290: PPUSH
// dist := 99999 ;
32291: LD_ADDR_VAR 0 7
32295: PUSH
32296: LD_INT 99999
32298: ST_TO_ADDR
// un := - 1 ;
32299: LD_ADDR_VAR 0 6
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: ST_TO_ADDR
// if units1 and units2 then
32308: LD_VAR 0 1
32312: PUSH
32313: LD_VAR 0 2
32317: AND
32318: IFFALSE 32406
// for i in units1 do
32320: LD_ADDR_VAR 0 4
32324: PUSH
32325: LD_VAR 0 1
32329: PUSH
32330: FOR_IN
32331: IFFALSE 32404
// for j in units2 do
32333: LD_ADDR_VAR 0 5
32337: PUSH
32338: LD_VAR 0 2
32342: PUSH
32343: FOR_IN
32344: IFFALSE 32400
// if GetDistUnits ( i , j ) < dist then
32346: LD_VAR 0 4
32350: PPUSH
32351: LD_VAR 0 5
32355: PPUSH
32356: CALL_OW 296
32360: PUSH
32361: LD_VAR 0 7
32365: LESS
32366: IFFALSE 32398
// begin un := i ;
32368: LD_ADDR_VAR 0 6
32372: PUSH
32373: LD_VAR 0 4
32377: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32378: LD_ADDR_VAR 0 7
32382: PUSH
32383: LD_VAR 0 4
32387: PPUSH
32388: LD_VAR 0 5
32392: PPUSH
32393: CALL_OW 296
32397: ST_TO_ADDR
// end ;
32398: GO 32343
32400: POP
32401: POP
32402: GO 32330
32404: POP
32405: POP
// result := [ un , dist ] ;
32406: LD_ADDR_VAR 0 3
32410: PUSH
32411: LD_VAR 0 6
32415: PUSH
32416: LD_VAR 0 7
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: ST_TO_ADDR
// end ;
32425: LD_VAR 0 3
32429: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32430: LD_INT 0
32432: PPUSH
32433: PPUSH
32434: PPUSH
32435: PPUSH
32436: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32437: LD_VAR 0 1
32441: NOT
32442: PUSH
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 256
32452: PUSH
32453: LD_INT 250
32455: LESS
32456: OR
32457: PUSH
32458: LD_VAR 0 1
32462: PPUSH
32463: CALL_OW 314
32467: PUSH
32468: LD_VAR 0 1
32472: PPUSH
32473: CALL_OW 261
32477: PUSH
32478: LD_INT 20
32480: GREATER
32481: AND
32482: OR
32483: IFFALSE 32487
// exit ;
32485: GO 32861
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32487: LD_VAR 0 1
32491: PPUSH
32492: CALL_OW 261
32496: PUSH
32497: LD_INT 20
32499: LESS
32500: PUSH
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 110
32510: PUSH
32511: LD_INT 21
32513: EQUAL
32514: NOT
32515: AND
32516: IFFALSE 32552
// begin ComStop ( bulldozer ) ;
32518: LD_VAR 0 1
32522: PPUSH
32523: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32527: LD_VAR 0 1
32531: PPUSH
32532: LD_INT 21
32534: PPUSH
32535: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32539: LD_VAR 0 1
32543: PPUSH
32544: CALL 26294 0 1
// exit ;
32548: GO 32861
// end else
32550: GO 32579
// if GetFuel ( bulldozer ) > 20 then
32552: LD_VAR 0 1
32556: PPUSH
32557: CALL_OW 261
32561: PUSH
32562: LD_INT 20
32564: GREATER
32565: IFFALSE 32579
// SetTag ( bulldozer , 0 ) ;
32567: LD_VAR 0 1
32571: PPUSH
32572: LD_INT 0
32574: PPUSH
32575: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32579: LD_ADDR_VAR 0 5
32583: PUSH
32584: LD_VAR 0 2
32588: PPUSH
32589: CALL_OW 353
32593: ST_TO_ADDR
// tmp := [ ] ;
32594: LD_ADDR_VAR 0 6
32598: PUSH
32599: EMPTY
32600: ST_TO_ADDR
// for i = 1 to list do
32601: LD_ADDR_VAR 0 4
32605: PUSH
32606: DOUBLE
32607: LD_INT 1
32609: DEC
32610: ST_TO_ADDR
32611: LD_VAR 0 5
32615: PUSH
32616: FOR_TO
32617: IFFALSE 32715
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32619: LD_VAR 0 5
32623: PUSH
32624: LD_VAR 0 4
32628: ARRAY
32629: PUSH
32630: LD_INT 1
32632: ARRAY
32633: PPUSH
32634: LD_VAR 0 5
32638: PUSH
32639: LD_VAR 0 4
32643: ARRAY
32644: PUSH
32645: LD_INT 2
32647: ARRAY
32648: PPUSH
32649: CALL_OW 554
32653: IFFALSE 32713
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32655: LD_ADDR_VAR 0 6
32659: PUSH
32660: LD_VAR 0 6
32664: PPUSH
32665: LD_VAR 0 6
32669: PUSH
32670: LD_INT 1
32672: PLUS
32673: PPUSH
32674: LD_VAR 0 5
32678: PUSH
32679: LD_VAR 0 4
32683: ARRAY
32684: PUSH
32685: LD_INT 1
32687: ARRAY
32688: PUSH
32689: LD_VAR 0 5
32693: PUSH
32694: LD_VAR 0 4
32698: ARRAY
32699: PUSH
32700: LD_INT 2
32702: ARRAY
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PPUSH
32708: CALL_OW 1
32712: ST_TO_ADDR
// end ;
32713: GO 32616
32715: POP
32716: POP
// ComStop ( bulldozer ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32726: LD_ADDR_VAR 0 7
32730: PUSH
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 250
32740: PUSH
32741: LD_VAR 0 1
32745: PPUSH
32746: CALL_OW 251
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: ST_TO_ADDR
// for i = tmp downto 1 do
32755: LD_ADDR_VAR 0 4
32759: PUSH
32760: DOUBLE
32761: LD_VAR 0 6
32765: INC
32766: ST_TO_ADDR
32767: LD_INT 1
32769: PUSH
32770: FOR_DOWNTO
32771: IFFALSE 32859
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32773: LD_ADDR_VAR 0 7
32777: PUSH
32778: LD_VAR 0 7
32782: PUSH
32783: LD_INT 1
32785: ARRAY
32786: PPUSH
32787: LD_VAR 0 7
32791: PUSH
32792: LD_INT 2
32794: ARRAY
32795: PPUSH
32796: LD_VAR 0 6
32800: PPUSH
32801: CALL 32962 0 3
32805: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: LD_VAR 0 7
32815: PUSH
32816: LD_INT 1
32818: ARRAY
32819: PPUSH
32820: LD_VAR 0 7
32824: PUSH
32825: LD_INT 2
32827: ARRAY
32828: PPUSH
32829: CALL 32866 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32833: LD_ADDR_VAR 0 6
32837: PUSH
32838: LD_VAR 0 6
32842: PPUSH
32843: LD_VAR 0 7
32847: PUSH
32848: LD_INT 3
32850: ARRAY
32851: PPUSH
32852: CALL_OW 3
32856: ST_TO_ADDR
// end ;
32857: GO 32770
32859: POP
32860: POP
// end ;
32861: LD_VAR 0 3
32865: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32866: LD_INT 0
32868: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32869: LD_VAR 0 2
32873: PPUSH
32874: LD_VAR 0 3
32878: PPUSH
32879: CALL_OW 351
32883: PUSH
32884: LD_VAR 0 2
32888: PPUSH
32889: LD_VAR 0 3
32893: PPUSH
32894: CALL_OW 554
32898: AND
32899: PUSH
32900: LD_VAR 0 2
32904: PPUSH
32905: LD_VAR 0 3
32909: PPUSH
32910: CALL_OW 488
32914: AND
32915: PUSH
32916: LD_VAR 0 2
32920: PPUSH
32921: LD_VAR 0 3
32925: PPUSH
32926: CALL_OW 428
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: EQUAL
32935: AND
32936: IFFALSE 32957
// AddComMoveXY ( bulldozer , x , y ) ;
32938: LD_VAR 0 1
32942: PPUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_VAR 0 3
32952: PPUSH
32953: CALL_OW 171
// end ;
32957: LD_VAR 0 4
32961: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32962: LD_INT 0
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
32969: PPUSH
32970: PPUSH
// dist := 99999 ;
32971: LD_ADDR_VAR 0 6
32975: PUSH
32976: LD_INT 99999
32978: ST_TO_ADDR
// for i = 1 to list do
32979: LD_ADDR_VAR 0 5
32983: PUSH
32984: DOUBLE
32985: LD_INT 1
32987: DEC
32988: ST_TO_ADDR
32989: LD_VAR 0 3
32993: PUSH
32994: FOR_TO
32995: IFFALSE 33133
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32997: LD_ADDR_VAR 0 7
33001: PUSH
33002: LD_VAR 0 1
33006: PPUSH
33007: LD_VAR 0 2
33011: PPUSH
33012: LD_VAR 0 3
33016: PUSH
33017: LD_VAR 0 5
33021: ARRAY
33022: PUSH
33023: LD_INT 1
33025: ARRAY
33026: PPUSH
33027: LD_VAR 0 3
33031: PUSH
33032: LD_VAR 0 5
33036: ARRAY
33037: PUSH
33038: LD_INT 2
33040: ARRAY
33041: PPUSH
33042: CALL_OW 298
33046: ST_TO_ADDR
// if d = 0 then
33047: LD_VAR 0 7
33051: PUSH
33052: LD_INT 0
33054: EQUAL
33055: IFFALSE 33059
// continue ;
33057: GO 32994
// if d < dist then
33059: LD_VAR 0 7
33063: PUSH
33064: LD_VAR 0 6
33068: LESS
33069: IFFALSE 33131
// begin _x := list [ i ] [ 1 ] ;
33071: LD_ADDR_VAR 0 8
33075: PUSH
33076: LD_VAR 0 3
33080: PUSH
33081: LD_VAR 0 5
33085: ARRAY
33086: PUSH
33087: LD_INT 1
33089: ARRAY
33090: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33091: LD_ADDR_VAR 0 9
33095: PUSH
33096: LD_VAR 0 3
33100: PUSH
33101: LD_VAR 0 5
33105: ARRAY
33106: PUSH
33107: LD_INT 2
33109: ARRAY
33110: ST_TO_ADDR
// _i := i ;
33111: LD_ADDR_VAR 0 10
33115: PUSH
33116: LD_VAR 0 5
33120: ST_TO_ADDR
// dist := d ;
33121: LD_ADDR_VAR 0 6
33125: PUSH
33126: LD_VAR 0 7
33130: ST_TO_ADDR
// end ; end ;
33131: GO 32994
33133: POP
33134: POP
// result := [ _x , _y , _i , dist ] ;
33135: LD_ADDR_VAR 0 4
33139: PUSH
33140: LD_VAR 0 8
33144: PUSH
33145: LD_VAR 0 9
33149: PUSH
33150: LD_VAR 0 10
33154: PUSH
33155: LD_VAR 0 6
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: ST_TO_ADDR
// end ;
33166: LD_VAR 0 4
33170: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33171: LD_INT 0
33173: PPUSH
33174: PPUSH
33175: PPUSH
33176: PPUSH
33177: PPUSH
// for i = 1 to list do
33178: LD_ADDR_VAR 0 5
33182: PUSH
33183: DOUBLE
33184: LD_INT 1
33186: DEC
33187: ST_TO_ADDR
33188: LD_VAR 0 1
33192: PUSH
33193: FOR_TO
33194: IFFALSE 33508
// begin for j = list downto 2 do
33196: LD_ADDR_VAR 0 6
33200: PUSH
33201: DOUBLE
33202: LD_VAR 0 1
33206: INC
33207: ST_TO_ADDR
33208: LD_INT 2
33210: PUSH
33211: FOR_DOWNTO
33212: IFFALSE 33504
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33214: LD_VAR 0 2
33218: PPUSH
33219: LD_VAR 0 3
33223: PPUSH
33224: LD_VAR 0 1
33228: PUSH
33229: LD_VAR 0 6
33233: ARRAY
33234: PUSH
33235: LD_INT 1
33237: ARRAY
33238: PPUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 2
33252: ARRAY
33253: PPUSH
33254: CALL_OW 298
33258: PUSH
33259: LD_VAR 0 2
33263: PPUSH
33264: LD_VAR 0 3
33268: PPUSH
33269: LD_VAR 0 1
33273: PUSH
33274: LD_VAR 0 6
33278: PUSH
33279: LD_INT 1
33281: MINUS
33282: ARRAY
33283: PUSH
33284: LD_INT 1
33286: ARRAY
33287: PPUSH
33288: LD_VAR 0 1
33292: PUSH
33293: LD_VAR 0 6
33297: PUSH
33298: LD_INT 1
33300: MINUS
33301: ARRAY
33302: PUSH
33303: LD_INT 2
33305: ARRAY
33306: PPUSH
33307: CALL_OW 298
33311: LESS
33312: IFFALSE 33502
// begin _x := list [ j ] [ 1 ] ;
33314: LD_ADDR_VAR 0 7
33318: PUSH
33319: LD_VAR 0 1
33323: PUSH
33324: LD_VAR 0 6
33328: ARRAY
33329: PUSH
33330: LD_INT 1
33332: ARRAY
33333: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33334: LD_ADDR_VAR 0 8
33338: PUSH
33339: LD_VAR 0 1
33343: PUSH
33344: LD_VAR 0 6
33348: ARRAY
33349: PUSH
33350: LD_INT 2
33352: ARRAY
33353: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33354: LD_ADDR_VAR 0 1
33358: PUSH
33359: LD_VAR 0 1
33363: PPUSH
33364: LD_VAR 0 6
33368: PPUSH
33369: LD_INT 1
33371: PPUSH
33372: LD_VAR 0 1
33376: PUSH
33377: LD_VAR 0 6
33381: PUSH
33382: LD_INT 1
33384: MINUS
33385: ARRAY
33386: PUSH
33387: LD_INT 1
33389: ARRAY
33390: PPUSH
33391: CALL 31132 0 4
33395: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33396: LD_ADDR_VAR 0 1
33400: PUSH
33401: LD_VAR 0 1
33405: PPUSH
33406: LD_VAR 0 6
33410: PPUSH
33411: LD_INT 2
33413: PPUSH
33414: LD_VAR 0 1
33418: PUSH
33419: LD_VAR 0 6
33423: PUSH
33424: LD_INT 1
33426: MINUS
33427: ARRAY
33428: PUSH
33429: LD_INT 2
33431: ARRAY
33432: PPUSH
33433: CALL 31132 0 4
33437: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33438: LD_ADDR_VAR 0 1
33442: PUSH
33443: LD_VAR 0 1
33447: PPUSH
33448: LD_VAR 0 6
33452: PUSH
33453: LD_INT 1
33455: MINUS
33456: PPUSH
33457: LD_INT 1
33459: PPUSH
33460: LD_VAR 0 7
33464: PPUSH
33465: CALL 31132 0 4
33469: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33470: LD_ADDR_VAR 0 1
33474: PUSH
33475: LD_VAR 0 1
33479: PPUSH
33480: LD_VAR 0 6
33484: PUSH
33485: LD_INT 1
33487: MINUS
33488: PPUSH
33489: LD_INT 2
33491: PPUSH
33492: LD_VAR 0 8
33496: PPUSH
33497: CALL 31132 0 4
33501: ST_TO_ADDR
// end ; end ;
33502: GO 33211
33504: POP
33505: POP
// end ;
33506: GO 33193
33508: POP
33509: POP
// result := list ;
33510: LD_ADDR_VAR 0 4
33514: PUSH
33515: LD_VAR 0 1
33519: ST_TO_ADDR
// end ;
33520: LD_VAR 0 4
33524: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33525: LD_INT 0
33527: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33528: LD_ADDR_VAR 0 5
33532: PUSH
33533: LD_VAR 0 1
33537: PPUSH
33538: LD_VAR 0 2
33542: PPUSH
33543: CALL_OW 546
33547: PUSH
33548: LD_INT 2
33550: ARRAY
33551: PUSH
33552: LD_VAR 0 3
33556: PPUSH
33557: LD_VAR 0 4
33561: PPUSH
33562: CALL_OW 546
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: MINUS
33571: ST_TO_ADDR
// if result < 0 then
33572: LD_VAR 0 5
33576: PUSH
33577: LD_INT 0
33579: LESS
33580: IFFALSE 33597
// result := result * - 1 ;
33582: LD_ADDR_VAR 0 5
33586: PUSH
33587: LD_VAR 0 5
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: MUL
33596: ST_TO_ADDR
// end ;
33597: LD_VAR 0 5
33601: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33602: LD_INT 0
33604: PPUSH
33605: PPUSH
// area = ListEnvironmentArea ( area ) ;
33606: LD_ADDR_VAR 0 2
33610: PUSH
33611: LD_VAR 0 2
33615: PPUSH
33616: CALL_OW 353
33620: ST_TO_ADDR
// if bulldozer > 0 then
33621: LD_VAR 0 1
33625: PUSH
33626: LD_INT 0
33628: GREATER
33629: IFFALSE 33740
// for i = area downto 1 do
33631: LD_ADDR_VAR 0 4
33635: PUSH
33636: DOUBLE
33637: LD_VAR 0 2
33641: INC
33642: ST_TO_ADDR
33643: LD_INT 1
33645: PUSH
33646: FOR_DOWNTO
33647: IFFALSE 33738
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33649: LD_VAR 0 2
33653: PUSH
33654: LD_VAR 0 4
33658: ARRAY
33659: PUSH
33660: LD_INT 1
33662: ARRAY
33663: PPUSH
33664: LD_VAR 0 2
33668: PUSH
33669: LD_VAR 0 4
33673: ARRAY
33674: PUSH
33675: LD_INT 2
33677: ARRAY
33678: PPUSH
33679: CALL_OW 351
33683: IFFALSE 33736
// if not HasTask ( bulldozer ) then
33685: LD_VAR 0 1
33689: PPUSH
33690: CALL_OW 314
33694: NOT
33695: IFFALSE 33736
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33697: LD_VAR 0 1
33701: PPUSH
33702: LD_VAR 0 2
33706: PUSH
33707: LD_VAR 0 4
33711: ARRAY
33712: PUSH
33713: LD_INT 1
33715: ARRAY
33716: PPUSH
33717: LD_VAR 0 2
33721: PUSH
33722: LD_VAR 0 4
33726: ARRAY
33727: PUSH
33728: LD_INT 2
33730: ARRAY
33731: PPUSH
33732: CALL_OW 171
33736: GO 33646
33738: POP
33739: POP
// end ;
33740: LD_VAR 0 3
33744: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33745: LD_INT 0
33747: PPUSH
33748: PPUSH
33749: PPUSH
33750: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33751: LD_ADDR_VAR 0 6
33755: PUSH
33756: LD_INT 22
33758: PUSH
33759: LD_VAR 0 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 21
33770: PUSH
33771: LD_VAR 0 2
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PPUSH
33784: CALL_OW 69
33788: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33789: LD_ADDR_VAR 0 7
33793: PUSH
33794: LD_VAR 0 3
33798: PPUSH
33799: LD_INT 22
33801: PUSH
33802: LD_VAR 0 1
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 21
33813: PUSH
33814: LD_VAR 0 2
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PPUSH
33827: CALL_OW 70
33831: ST_TO_ADDR
// if tmp and pom then
33832: LD_VAR 0 6
33836: PUSH
33837: LD_VAR 0 7
33841: AND
33842: IFFALSE 33862
// result := tmp diff pom else
33844: LD_ADDR_VAR 0 4
33848: PUSH
33849: LD_VAR 0 6
33853: PUSH
33854: LD_VAR 0 7
33858: DIFF
33859: ST_TO_ADDR
33860: GO 33870
// result := false ;
33862: LD_ADDR_VAR 0 4
33866: PUSH
33867: LD_INT 0
33869: ST_TO_ADDR
// end ;
33870: LD_VAR 0 4
33874: RET
// export function SavePosition ( unit ) ; begin
33875: LD_INT 0
33877: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33878: LD_VAR 0 1
33882: PPUSH
33883: LD_VAR 0 1
33887: PPUSH
33888: CALL_OW 250
33892: PPUSH
33893: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33897: LD_VAR 0 1
33901: PPUSH
33902: LD_VAR 0 1
33906: PPUSH
33907: CALL_OW 251
33911: PPUSH
33912: CALL_OW 232
// end ;
33916: LD_VAR 0 2
33920: RET
// export function GetPosition ( unit ) ; begin
33921: LD_INT 0
33923: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33924: LD_ADDR_VAR 0 2
33928: PUSH
33929: LD_VAR 0 1
33933: PPUSH
33934: CALL_OW 252
33938: PUSH
33939: LD_VAR 0 1
33943: PPUSH
33944: CALL_OW 253
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: ST_TO_ADDR
// end ;
33953: LD_VAR 0 2
33957: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33958: LD_INT 0
33960: PPUSH
// if unit in unreachableList then
33961: LD_VAR 0 1
33965: PUSH
33966: LD_EXP 30
33970: IN
33971: IFFALSE 33989
// unreachableList := unreachableList diff unit ;
33973: LD_ADDR_EXP 30
33977: PUSH
33978: LD_EXP 30
33982: PUSH
33983: LD_VAR 0 1
33987: DIFF
33988: ST_TO_ADDR
// if ValidHex ( x , y ) then
33989: LD_VAR 0 2
33993: PPUSH
33994: LD_VAR 0 3
33998: PPUSH
33999: CALL_OW 488
34003: IFFALSE 34029
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34005: LD_VAR 0 1
34009: PPUSH
34010: LD_VAR 0 2
34014: PPUSH
34015: LD_VAR 0 3
34019: PPUSH
34020: CALL_OW 428
34024: PPUSH
34025: CALL_OW 115
// Wait ( 3 ) ;
34029: LD_INT 3
34031: PPUSH
34032: CALL_OW 67
// if unit in unreachableList then
34036: LD_VAR 0 1
34040: PUSH
34041: LD_EXP 30
34045: IN
34046: IFFALSE 34058
// result := false else
34048: LD_ADDR_VAR 0 4
34052: PUSH
34053: LD_INT 0
34055: ST_TO_ADDR
34056: GO 34066
// result := true ;
34058: LD_ADDR_VAR 0 4
34062: PUSH
34063: LD_INT 1
34065: ST_TO_ADDR
// end ; end_of_file
34066: LD_VAR 0 4
34070: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34071: LD_EXP 31
34075: IFFALSE 34137
34077: GO 34079
34079: DISABLE
34080: LD_INT 0
34082: PPUSH
// begin enable ;
34083: ENABLE
// for i = 1 to mc_crates_list do
34084: LD_ADDR_VAR 0 1
34088: PUSH
34089: DOUBLE
34090: LD_INT 1
34092: DEC
34093: ST_TO_ADDR
34094: LD_EXP 32
34098: PUSH
34099: FOR_TO
34100: IFFALSE 34131
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34102: LD_EXP 32
34106: PUSH
34107: LD_VAR 0 1
34111: ARRAY
34112: PPUSH
34113: LD_INT 5
34115: PPUSH
34116: LD_INT 50
34118: PPUSH
34119: LD_INT 700
34121: PPUSH
34122: LD_INT 20
34124: PPUSH
34125: CALL 24501 0 5
34129: GO 34099
34131: POP
34132: POP
// MC_Game ( ) ;
34133: CALL 34140 0 0
// end ;
34137: PPOPN 1
34139: END
// export function MC_Game ( ) ; var i , side , un ; begin
34140: LD_INT 0
34142: PPUSH
34143: PPUSH
34144: PPUSH
34145: PPUSH
// if not isTest then
34146: LD_EXP 1
34150: NOT
34151: IFFALSE 34171
// MC_Show ( [ #tick , tick ] ) else
34153: LD_STRING #tick
34155: PUSH
34156: LD_OWVAR 1
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PPUSH
34165: CALL 8585 0 1
34169: GO 34180
// MC_Show ( debug_string ) ;
34171: LD_EXP 2
34175: PPUSH
34176: CALL 8585 0 1
// for side = 1 to 8 do
34180: LD_ADDR_VAR 0 3
34184: PUSH
34185: DOUBLE
34186: LD_INT 1
34188: DEC
34189: ST_TO_ADDR
34190: LD_INT 8
34192: PUSH
34193: FOR_TO
34194: IFFALSE 36194
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34196: LD_EXP 39
34200: PUSH
34201: LD_VAR 0 3
34205: ARRAY
34206: PUSH
34207: LD_INT 0
34209: EQUAL
34210: PUSH
34211: LD_VAR 0 3
34215: PPUSH
34216: EMPTY
34217: PPUSH
34218: CALL 11802 0 2
34222: PUSH
34223: LD_INT 0
34225: EQUAL
34226: OR
34227: IFFALSE 34231
// continue ;
34229: GO 34193
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34231: LD_VAR 0 3
34235: PPUSH
34236: LD_VAR 0 3
34240: PPUSH
34241: CALL 25022 0 1
34245: PPUSH
34246: CALL 36201 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34250: LD_EXP 71
34254: PUSH
34255: LD_VAR 0 3
34259: ARRAY
34260: PUSH
34261: LD_INT 1
34263: ARRAY
34264: PUSH
34265: LD_INT 0
34267: GREATER
34268: PUSH
34269: LD_EXP 69
34273: PUSH
34274: LD_VAR 0 3
34278: ARRAY
34279: PUSH
34280: LD_INT 1
34282: ARRAY
34283: PUSH
34284: LD_INT 0
34286: EQUAL
34287: AND
34288: PUSH
34289: LD_VAR 0 3
34293: PPUSH
34294: LD_INT 7
34296: PPUSH
34297: EMPTY
34298: PPUSH
34299: CALL 12370 0 3
34303: NOT
34304: AND
34305: IFFALSE 34342
// begin for i in MREG_Attackers [ side ] do
34307: LD_ADDR_VAR 0 2
34311: PUSH
34312: LD_EXP 71
34316: PUSH
34317: LD_VAR 0 3
34321: ARRAY
34322: PUSH
34323: FOR_IN
34324: IFFALSE 34340
// SetTag ( i , 7 ) ;
34326: LD_VAR 0 2
34330: PPUSH
34331: LD_INT 7
34333: PPUSH
34334: CALL_OW 109
34338: GO 34323
34340: POP
34341: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34342: LD_VAR 0 3
34346: PPUSH
34347: LD_INT 7
34349: PPUSH
34350: EMPTY
34351: PPUSH
34352: CALL 12370 0 3
34356: IFFALSE 34416
// begin if side = 1 then
34358: LD_VAR 0 3
34362: PUSH
34363: LD_INT 1
34365: EQUAL
34366: IFFALSE 34375
// RaiseSailEvent ( 101 ) ;
34368: LD_INT 101
34370: PPUSH
34371: CALL_OW 427
// if side = 4 then
34375: LD_VAR 0 3
34379: PUSH
34380: LD_INT 4
34382: EQUAL
34383: IFFALSE 34392
// RaiseSailEvent ( 102 ) ;
34385: LD_INT 102
34387: PPUSH
34388: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34392: LD_VAR 0 3
34396: PPUSH
34397: LD_VAR 0 3
34401: PPUSH
34402: LD_INT 7
34404: PPUSH
34405: EMPTY
34406: PPUSH
34407: CALL 12370 0 3
34411: PPUSH
34412: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34416: LD_VAR 0 3
34420: PPUSH
34421: CALL 18050 0 1
34425: PUSH
34426: LD_VAR 0 3
34430: PPUSH
34431: CALL 11706 0 1
34435: AND
34436: IFFALSE 34447
// MCL_Start ( side ) ;
34438: LD_VAR 0 3
34442: PPUSH
34443: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34447: LD_ADDR_EXP 35
34451: PUSH
34452: LD_EXP 35
34456: PPUSH
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_VAR 0 3
34466: PPUSH
34467: CALL 19307 0 1
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34477: LD_ADDR_EXP 47
34481: PUSH
34482: LD_EXP 47
34486: PPUSH
34487: LD_VAR 0 3
34491: PPUSH
34492: LD_VAR 0 3
34496: PPUSH
34497: CALL 11120 0 1
34501: PPUSH
34502: CALL_OW 1
34506: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34507: LD_VAR 0 3
34511: PPUSH
34512: LD_INT 21
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PPUSH
34522: CALL 11667 0 2
34526: IFFALSE 34537
// MCV_CheckStatus ( side ) ;
34528: LD_VAR 0 3
34532: PPUSH
34533: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34537: LD_VAR 0 3
34541: PPUSH
34542: LD_EXP 53
34546: PPUSH
34547: CALL 43001 0 2
34551: IFFALSE 34636
// begin for i = MREG_ToChangeClass downto 1 do
34553: LD_ADDR_VAR 0 2
34557: PUSH
34558: DOUBLE
34559: LD_EXP 53
34563: INC
34564: ST_TO_ADDR
34565: LD_INT 1
34567: PUSH
34568: FOR_DOWNTO
34569: IFFALSE 34634
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34571: LD_EXP 53
34575: PUSH
34576: LD_VAR 0 2
34580: ARRAY
34581: PUSH
34582: LD_INT 1
34584: ARRAY
34585: PUSH
34586: LD_VAR 0 3
34590: EQUAL
34591: IFFALSE 34632
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34593: LD_VAR 0 3
34597: PPUSH
34598: LD_EXP 53
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 2
34611: ARRAY
34612: PPUSH
34613: LD_EXP 53
34617: PUSH
34618: LD_VAR 0 2
34622: ARRAY
34623: PUSH
34624: LD_INT 3
34626: ARRAY
34627: PPUSH
34628: CALL 16574 0 3
// end ; end ;
34632: GO 34568
34634: POP
34635: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34636: LD_INT 1
34638: PUSH
34639: LD_EXP 38
34643: PUSH
34644: LD_VAR 0 3
34648: ARRAY
34649: IN
34650: IFFALSE 34661
// begin MCN_TrainApe ( side ) ;
34652: LD_VAR 0 3
34656: PPUSH
34657: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34661: LD_VAR 0 3
34665: PPUSH
34666: LD_INT 30
34668: PUSH
34669: LD_INT 3
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PPUSH
34676: CALL 11667 0 2
34680: IFFALSE 34854
// begin if MCF_Tag ( side , 10 , [ ] ) then
34682: LD_VAR 0 3
34686: PPUSH
34687: LD_INT 10
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL 12370 0 3
34696: IFFALSE 34743
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34698: LD_VAR 0 3
34702: PPUSH
34703: LD_INT 10
34705: PPUSH
34706: EMPTY
34707: PPUSH
34708: CALL 12370 0 3
34712: PPUSH
34713: LD_VAR 0 3
34717: PPUSH
34718: LD_INT 30
34720: PUSH
34721: LD_INT 3
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PPUSH
34728: CALL 11667 0 2
34732: PUSH
34733: LD_INT 1
34735: ARRAY
34736: PPUSH
34737: CALL_OW 168
// end else
34741: GO 34854
// if MREG_ToConstruct [ side ] then
34743: LD_EXP 51
34747: PUSH
34748: LD_VAR 0 3
34752: ARRAY
34753: IFFALSE 34854
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34755: LD_VAR 0 3
34759: PPUSH
34760: LD_VAR 0 3
34764: PPUSH
34765: LD_INT 30
34767: PUSH
34768: LD_INT 3
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PPUSH
34775: CALL 11667 0 2
34779: PUSH
34780: LD_INT 1
34782: ARRAY
34783: PPUSH
34784: LD_EXP 51
34788: PUSH
34789: LD_VAR 0 3
34793: ARRAY
34794: PUSH
34795: LD_INT 1
34797: ARRAY
34798: PUSH
34799: LD_EXP 51
34803: PUSH
34804: LD_VAR 0 3
34808: ARRAY
34809: PUSH
34810: LD_INT 2
34812: ARRAY
34813: PUSH
34814: LD_EXP 51
34818: PUSH
34819: LD_VAR 0 3
34823: ARRAY
34824: PUSH
34825: LD_INT 3
34827: ARRAY
34828: PUSH
34829: LD_EXP 51
34833: PUSH
34834: LD_VAR 0 3
34838: ARRAY
34839: PUSH
34840: LD_INT 4
34842: ARRAY
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: LIST
34848: LIST
34849: PPUSH
34850: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34854: LD_VAR 0 3
34858: PPUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 3
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PPUSH
34869: CALL 11667 0 2
34873: PUSH
34874: LD_VAR 0 3
34878: PPUSH
34879: LD_EXP 43
34883: PPUSH
34884: CALL 43001 0 2
34888: AND
34889: PUSH
34890: LD_INT 22
34892: PUSH
34893: LD_VAR 0 3
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 2
34904: PUSH
34905: LD_INT 30
34907: PUSH
34908: LD_INT 33
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 30
34917: PUSH
34918: LD_INT 32
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 35
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: PPUSH
34945: CALL_OW 69
34949: AND
34950: IFFALSE 34961
// MCV_Turret ( side ) ;
34952: LD_VAR 0 3
34956: PPUSH
34957: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34961: LD_EXP 42
34965: PUSH
34966: LD_VAR 0 3
34970: ARRAY
34971: PUSH
34972: LD_INT 1
34974: GREATER
34975: PUSH
34976: LD_VAR 0 3
34980: PPUSH
34981: CALL 25022 0 1
34985: PUSH
34986: LD_INT 0
34988: EQUAL
34989: AND
34990: IFFALSE 35152
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34992: LD_EXP 42
34996: PUSH
34997: LD_VAR 0 3
35001: ARRAY
35002: PUSH
35003: LD_INT 1
35005: ARRAY
35006: PPUSH
35007: CALL_OW 353
35011: IFFALSE 35049
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35013: LD_EXP 42
35017: PUSH
35018: LD_VAR 0 3
35022: ARRAY
35023: PUSH
35024: LD_INT 2
35026: ARRAY
35027: PPUSH
35028: LD_EXP 42
35032: PUSH
35033: LD_VAR 0 3
35037: ARRAY
35038: PUSH
35039: LD_INT 1
35041: ARRAY
35042: PPUSH
35043: CALL 32430 0 2
35047: GO 35152
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35049: LD_VAR 0 3
35053: PPUSH
35054: LD_INT 30
35056: PUSH
35057: LD_INT 3
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PPUSH
35064: CALL 11667 0 2
35068: IFFALSE 35152
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35070: LD_VAR 0 3
35074: PPUSH
35075: LD_INT 30
35077: PUSH
35078: LD_INT 3
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PPUSH
35085: CALL 11667 0 2
35089: PUSH
35090: LD_INT 1
35092: ARRAY
35093: PPUSH
35094: CALL_OW 461
35098: PUSH
35099: LD_INT 2
35101: EQUAL
35102: IFFALSE 35152
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35104: LD_EXP 42
35108: PUSH
35109: LD_VAR 0 3
35113: ARRAY
35114: PUSH
35115: LD_INT 2
35117: ARRAY
35118: PPUSH
35119: LD_INT 10
35121: PPUSH
35122: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35126: LD_ADDR_EXP 42
35130: PUSH
35131: LD_EXP 42
35135: PPUSH
35136: LD_VAR 0 3
35140: PPUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: PPUSH
35147: CALL_OW 1
35151: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35152: LD_VAR 0 3
35156: PPUSH
35157: LD_INT 33
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PPUSH
35167: CALL 11667 0 2
35171: IFFALSE 35211
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35173: LD_VAR 0 3
35177: PPUSH
35178: LD_VAR 0 3
35182: PPUSH
35183: LD_INT 33
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PPUSH
35193: CALL 11667 0 2
35197: PUSH
35198: LD_INT 1
35200: ARRAY
35201: PPUSH
35202: CALL_OW 248
35206: PPUSH
35207: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35211: LD_EXP 47
35215: PUSH
35216: LD_VAR 0 3
35220: ARRAY
35221: IFFALSE 35234
// begin MCB_Repair ( side ) ;
35223: LD_VAR 0 3
35227: PPUSH
35228: CALL 11407 0 1
// end else
35232: GO 36147
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35234: LD_VAR 0 3
35238: PPUSH
35239: LD_EXP 49
35243: PPUSH
35244: CALL 43001 0 2
35248: PUSH
35249: LD_VAR 0 3
35253: PPUSH
35254: LD_EXP 40
35258: PPUSH
35259: CALL 43001 0 2
35263: AND
35264: IFFALSE 35472
// begin for i = 1 to MREG_ToUpLab do
35266: LD_ADDR_VAR 0 2
35270: PUSH
35271: DOUBLE
35272: LD_INT 1
35274: DEC
35275: ST_TO_ADDR
35276: LD_EXP 49
35280: PUSH
35281: FOR_TO
35282: IFFALSE 35468
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35284: LD_EXP 49
35288: PUSH
35289: LD_VAR 0 2
35293: ARRAY
35294: PUSH
35295: LD_INT 1
35297: ARRAY
35298: PUSH
35299: LD_VAR 0 3
35303: EQUAL
35304: IFFALSE 35466
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35306: LD_EXP 49
35310: PUSH
35311: LD_VAR 0 2
35315: ARRAY
35316: PUSH
35317: LD_INT 2
35319: ARRAY
35320: PUSH
35321: LD_EXP 49
35325: PUSH
35326: LD_VAR 0 2
35330: ARRAY
35331: PUSH
35332: LD_INT 3
35334: ARRAY
35335: AND
35336: IFFALSE 35464
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35338: LD_VAR 0 3
35342: PPUSH
35343: LD_EXP 49
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PUSH
35354: LD_INT 2
35356: ARRAY
35357: PPUSH
35358: LD_EXP 49
35362: PUSH
35363: LD_VAR 0 2
35367: ARRAY
35368: PUSH
35369: LD_INT 3
35371: ARRAY
35372: PPUSH
35373: CALL 8931 0 3
35377: IFFALSE 35464
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35379: LD_ADDR_EXP 49
35383: PUSH
35384: LD_EXP 49
35388: PPUSH
35389: LD_VAR 0 3
35393: PPUSH
35394: LD_EXP 49
35398: PUSH
35399: LD_VAR 0 2
35403: ARRAY
35404: PUSH
35405: LD_INT 2
35407: ARRAY
35408: PPUSH
35409: LD_EXP 49
35413: PUSH
35414: LD_VAR 0 2
35418: ARRAY
35419: PUSH
35420: LD_INT 3
35422: ARRAY
35423: PPUSH
35424: CALL 42053 0 4
35428: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35429: LD_ADDR_EXP 40
35433: PUSH
35434: LD_EXP 40
35438: PPUSH
35439: LD_VAR 0 3
35443: PPUSH
35444: LD_EXP 40
35448: PUSH
35449: LD_INT 1
35451: ARRAY
35452: PUSH
35453: LD_INT 2
35455: ARRAY
35456: PPUSH
35457: EMPTY
35458: PPUSH
35459: CALL 42053 0 4
35463: ST_TO_ADDR
// end ; break ;
35464: GO 35468
// end ;
35466: GO 35281
35468: POP
35469: POP
// end else
35470: GO 36147
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35472: LD_VAR 0 3
35476: PPUSH
35477: LD_EXP 48
35481: PPUSH
35482: CALL 43001 0 2
35486: IFFALSE 35560
// begin for i = 1 to MREG_ToUpdate do
35488: LD_ADDR_VAR 0 2
35492: PUSH
35493: DOUBLE
35494: LD_INT 1
35496: DEC
35497: ST_TO_ADDR
35498: LD_EXP 48
35502: PUSH
35503: FOR_TO
35504: IFFALSE 35556
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35506: LD_EXP 48
35510: PUSH
35511: LD_VAR 0 2
35515: ARRAY
35516: PUSH
35517: LD_INT 1
35519: ARRAY
35520: PUSH
35521: LD_VAR 0 3
35525: EQUAL
35526: IFFALSE 35554
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PUSH
35538: LD_VAR 0 2
35542: ARRAY
35543: PUSH
35544: LD_INT 2
35546: ARRAY
35547: PPUSH
35548: CALL 8767 0 2
// break ;
35552: GO 35556
// end ;
35554: GO 35503
35556: POP
35557: POP
// end else
35558: GO 36147
// if MCF_Get ( side , [ f_constructed ] ) then
35560: LD_VAR 0 3
35564: PPUSH
35565: LD_INT 57
35567: PUSH
35568: EMPTY
35569: LIST
35570: PPUSH
35571: CALL 11667 0 2
35575: IFFALSE 35608
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35577: LD_VAR 0 3
35581: PPUSH
35582: LD_VAR 0 3
35586: PPUSH
35587: LD_INT 57
35589: PUSH
35590: EMPTY
35591: LIST
35592: PPUSH
35593: CALL 11667 0 2
35597: PUSH
35598: LD_INT 1
35600: ARRAY
35601: PPUSH
35602: CALL 11011 0 2
35606: GO 36147
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35608: LD_VAR 0 3
35612: PPUSH
35613: LD_EXP 46
35617: PPUSH
35618: CALL 43001 0 2
35622: PUSH
35623: LD_VAR 0 3
35627: PPUSH
35628: CALL_OW 345
35632: NOT
35633: AND
35634: PUSH
35635: LD_VAR 0 3
35639: PPUSH
35640: CALL 25022 0 1
35644: PUSH
35645: LD_INT 0
35647: EQUAL
35648: AND
35649: IFFALSE 36048
// begin for i = 1 to MREG_ToBuild do
35651: LD_ADDR_VAR 0 2
35655: PUSH
35656: DOUBLE
35657: LD_INT 1
35659: DEC
35660: ST_TO_ADDR
35661: LD_EXP 46
35665: PUSH
35666: FOR_TO
35667: IFFALSE 36044
// if MREG_ToBuild [ i ] [ 1 ] = side then
35669: LD_EXP 46
35673: PUSH
35674: LD_VAR 0 2
35678: ARRAY
35679: PUSH
35680: LD_INT 1
35682: ARRAY
35683: PUSH
35684: LD_VAR 0 3
35688: EQUAL
35689: IFFALSE 36042
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35691: LD_OWVAR 84
35695: PUSH
35696: LD_EXP 46
35700: PUSH
35701: LD_VAR 0 2
35705: ARRAY
35706: PUSH
35707: LD_INT 3
35709: ARRAY
35710: PUSH
35711: LD_INT 1
35713: ARRAY
35714: PPUSH
35715: LD_EXP 46
35719: PUSH
35720: LD_VAR 0 2
35724: ARRAY
35725: PUSH
35726: LD_INT 3
35728: ARRAY
35729: PUSH
35730: LD_INT 2
35732: ARRAY
35733: PPUSH
35734: CALL_OW 351
35738: AND
35739: IFFALSE 35783
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35741: LD_EXP 46
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PUSH
35752: LD_INT 3
35754: ARRAY
35755: PUSH
35756: LD_INT 1
35758: ARRAY
35759: PPUSH
35760: LD_EXP 46
35764: PUSH
35765: LD_VAR 0 2
35769: ARRAY
35770: PUSH
35771: LD_INT 3
35773: ARRAY
35774: PUSH
35775: LD_INT 2
35777: ARRAY
35778: PPUSH
35779: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35783: LD_EXP 46
35787: PUSH
35788: LD_VAR 0 2
35792: ARRAY
35793: PUSH
35794: LD_INT 2
35796: ARRAY
35797: PUSH
35798: LD_INT 0
35800: EQUAL
35801: IFFALSE 35871
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35803: LD_VAR 0 3
35807: PPUSH
35808: LD_EXP 46
35812: PUSH
35813: LD_VAR 0 2
35817: ARRAY
35818: PUSH
35819: LD_INT 3
35821: ARRAY
35822: PUSH
35823: LD_INT 1
35825: ARRAY
35826: PPUSH
35827: LD_EXP 46
35831: PUSH
35832: LD_VAR 0 2
35836: ARRAY
35837: PUSH
35838: LD_INT 3
35840: ARRAY
35841: PUSH
35842: LD_INT 2
35844: ARRAY
35845: PPUSH
35846: LD_EXP 46
35850: PUSH
35851: LD_VAR 0 2
35855: ARRAY
35856: PUSH
35857: LD_INT 3
35859: ARRAY
35860: PUSH
35861: LD_INT 3
35863: ARRAY
35864: PPUSH
35865: CALL 8603 0 4
35869: GO 36040
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35871: LD_EXP 46
35875: PUSH
35876: LD_VAR 0 2
35880: ARRAY
35881: PUSH
35882: LD_INT 2
35884: ARRAY
35885: PUSH
35886: LD_INT 6
35888: EQUAL
35889: IFFALSE 35959
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35891: LD_VAR 0 3
35895: PPUSH
35896: LD_EXP 46
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 3
35909: ARRAY
35910: PUSH
35911: LD_INT 1
35913: ARRAY
35914: PPUSH
35915: LD_EXP 46
35919: PUSH
35920: LD_VAR 0 2
35924: ARRAY
35925: PUSH
35926: LD_INT 3
35928: ARRAY
35929: PUSH
35930: LD_INT 2
35932: ARRAY
35933: PPUSH
35934: LD_EXP 46
35938: PUSH
35939: LD_VAR 0 2
35943: ARRAY
35944: PUSH
35945: LD_INT 3
35947: ARRAY
35948: PUSH
35949: LD_INT 3
35951: ARRAY
35952: PPUSH
35953: CALL 8732 0 4
35957: GO 36040
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35959: LD_VAR 0 3
35963: PPUSH
35964: LD_EXP 46
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PUSH
35975: LD_INT 2
35977: ARRAY
35978: PPUSH
35979: LD_EXP 46
35983: PUSH
35984: LD_VAR 0 2
35988: ARRAY
35989: PUSH
35990: LD_INT 3
35992: ARRAY
35993: PUSH
35994: LD_INT 1
35996: ARRAY
35997: PPUSH
35998: LD_EXP 46
36002: PUSH
36003: LD_VAR 0 2
36007: ARRAY
36008: PUSH
36009: LD_INT 3
36011: ARRAY
36012: PUSH
36013: LD_INT 2
36015: ARRAY
36016: PPUSH
36017: LD_EXP 46
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 3
36030: ARRAY
36031: PUSH
36032: LD_INT 3
36034: ARRAY
36035: PPUSH
36036: CALL 10236 0 5
// break ;
36040: GO 36044
// end ;
36042: GO 35666
36044: POP
36045: POP
// end else
36046: GO 36147
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36048: LD_VAR 0 3
36052: PPUSH
36053: LD_EXP 52
36057: PPUSH
36058: CALL 43001 0 2
36062: PUSH
36063: LD_VAR 0 3
36067: PPUSH
36068: CALL 25022 0 1
36072: PUSH
36073: LD_INT 0
36075: EQUAL
36076: AND
36077: IFFALSE 36147
// begin for i = 1 to MREG_ToDismantle do
36079: LD_ADDR_VAR 0 2
36083: PUSH
36084: DOUBLE
36085: LD_INT 1
36087: DEC
36088: ST_TO_ADDR
36089: LD_EXP 52
36093: PUSH
36094: FOR_TO
36095: IFFALSE 36145
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36097: LD_EXP 52
36101: PUSH
36102: LD_VAR 0 2
36106: ARRAY
36107: PUSH
36108: LD_INT 1
36110: ARRAY
36111: PUSH
36112: LD_VAR 0 3
36116: EQUAL
36117: IFFALSE 36143
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36119: LD_VAR 0 3
36123: PPUSH
36124: LD_EXP 52
36128: PUSH
36129: LD_VAR 0 2
36133: ARRAY
36134: PUSH
36135: LD_INT 2
36137: ARRAY
36138: PPUSH
36139: CALL 10902 0 2
// end ;
36143: GO 36094
36145: POP
36146: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36147: LD_VAR 0 3
36151: PPUSH
36152: LD_INT 30
36154: PUSH
36155: LD_INT 1
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PPUSH
36162: CALL 11667 0 2
36166: PUSH
36167: LD_VAR 0 3
36171: PPUSH
36172: CALL 25022 0 1
36176: PUSH
36177: LD_INT 0
36179: EQUAL
36180: AND
36181: IFFALSE 36192
// MCT_CollectCrates ( side ) ;
36183: LD_VAR 0 3
36187: PPUSH
36188: CALL 23961 0 1
// end ;
36192: GO 34193
36194: POP
36195: POP
// end ;
36196: LD_VAR 0 1
36200: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36201: LD_INT 0
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
36216: PPUSH
36217: PPUSH
// all := MCF_All ( side , [ ] ) ;
36218: LD_ADDR_VAR 0 17
36222: PUSH
36223: LD_VAR 0 1
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11802 0 2
36234: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36235: LD_ADDR_VAR 0 13
36239: PUSH
36240: LD_VAR 0 1
36244: PPUSH
36245: LD_INT 1
36247: PPUSH
36248: EMPTY
36249: PPUSH
36250: CALL 11750 0 3
36254: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36255: LD_ADDR_VAR 0 14
36259: PUSH
36260: LD_VAR 0 1
36264: PPUSH
36265: LD_INT 2
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL 11750 0 3
36274: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36275: LD_ADDR_VAR 0 15
36279: PUSH
36280: LD_VAR 0 1
36284: PPUSH
36285: LD_INT 3
36287: PPUSH
36288: EMPTY
36289: PPUSH
36290: CALL 11750 0 3
36294: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36295: LD_ADDR_VAR 0 16
36299: PUSH
36300: LD_VAR 0 1
36304: PPUSH
36305: LD_INT 4
36307: PPUSH
36308: EMPTY
36309: PPUSH
36310: CALL 11750 0 3
36314: ST_TO_ADDR
// if mech then
36315: LD_VAR 0 15
36319: IFFALSE 36336
// mech := MCF_SortListDesc ( mech ) ;
36321: LD_ADDR_VAR 0 15
36325: PUSH
36326: LD_VAR 0 15
36330: PPUSH
36331: CALL 12916 0 1
36335: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36336: LD_EXP 56
36340: PUSH
36341: LD_VAR 0 1
36345: ARRAY
36346: PUSH
36347: LD_STRING 
36349: EQUAL
36350: NOT
36351: IFFALSE 36407
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36353: LD_EXP 56
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_INT 1
36366: ARRAY
36367: PPUSH
36368: CALL_OW 257
36372: PUSH
36373: LD_INT 1
36375: EQUAL
36376: IFFALSE 36405
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36378: LD_VAR 0 1
36382: PPUSH
36383: LD_STRING ToArm
36385: PPUSH
36386: LD_EXP 56
36390: PUSH
36391: LD_VAR 0 1
36395: ARRAY
36396: PUSH
36397: LD_INT 1
36399: ARRAY
36400: PPUSH
36401: CALL 14546 0 3
// end else
36405: GO 36433
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36407: LD_ADDR_EXP 56
36411: PUSH
36412: LD_EXP 56
36416: PPUSH
36417: LD_VAR 0 1
36421: PPUSH
36422: LD_INT 1
36424: PPUSH
36425: LD_INT 0
36427: PPUSH
36428: CALL 31132 0 4
36432: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36433: LD_EXP 57
36437: PUSH
36438: LD_VAR 0 1
36442: ARRAY
36443: PUSH
36444: LD_STRING 
36446: EQUAL
36447: NOT
36448: IFFALSE 36504
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_INT 1
36463: ARRAY
36464: PPUSH
36465: CALL_OW 257
36469: PUSH
36470: LD_INT 2
36472: EQUAL
36473: IFFALSE 36502
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36475: LD_VAR 0 1
36479: PPUSH
36480: LD_STRING ToDep
36482: PPUSH
36483: LD_EXP 57
36487: PUSH
36488: LD_VAR 0 1
36492: ARRAY
36493: PUSH
36494: LD_INT 1
36496: ARRAY
36497: PPUSH
36498: CALL 14546 0 3
// end else
36502: GO 36530
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36504: LD_ADDR_EXP 57
36508: PUSH
36509: LD_EXP 57
36513: PPUSH
36514: LD_VAR 0 1
36518: PPUSH
36519: LD_INT 1
36521: PPUSH
36522: LD_INT 0
36524: PPUSH
36525: CALL 31132 0 4
36529: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36530: LD_EXP 55
36534: PUSH
36535: LD_VAR 0 1
36539: ARRAY
36540: PUSH
36541: LD_STRING 
36543: EQUAL
36544: NOT
36545: IFFALSE 36601
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36547: LD_EXP 55
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_INT 1
36560: ARRAY
36561: PPUSH
36562: CALL_OW 257
36566: PUSH
36567: LD_INT 3
36569: EQUAL
36570: IFFALSE 36599
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36572: LD_VAR 0 1
36576: PPUSH
36577: LD_STRING ToFac
36579: PPUSH
36580: LD_EXP 55
36584: PUSH
36585: LD_VAR 0 1
36589: ARRAY
36590: PUSH
36591: LD_INT 1
36593: ARRAY
36594: PPUSH
36595: CALL 14546 0 3
// end else
36599: GO 36627
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36601: LD_ADDR_EXP 55
36605: PUSH
36606: LD_EXP 55
36610: PPUSH
36611: LD_VAR 0 1
36615: PPUSH
36616: LD_INT 1
36618: PPUSH
36619: LD_INT 0
36621: PPUSH
36622: CALL 31132 0 4
36626: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36627: LD_EXP 54
36631: PUSH
36632: LD_VAR 0 1
36636: ARRAY
36637: PUSH
36638: LD_STRING 
36640: EQUAL
36641: NOT
36642: IFFALSE 36698
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36644: LD_EXP 54
36648: PUSH
36649: LD_VAR 0 1
36653: ARRAY
36654: PUSH
36655: LD_INT 1
36657: ARRAY
36658: PPUSH
36659: CALL_OW 257
36663: PUSH
36664: LD_INT 4
36666: EQUAL
36667: IFFALSE 36696
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36669: LD_VAR 0 1
36673: PPUSH
36674: LD_STRING ToLab
36676: PPUSH
36677: LD_EXP 54
36681: PUSH
36682: LD_VAR 0 1
36686: ARRAY
36687: PUSH
36688: LD_INT 1
36690: ARRAY
36691: PPUSH
36692: CALL 14546 0 3
// end else
36696: GO 36724
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36698: LD_ADDR_EXP 54
36702: PUSH
36703: LD_EXP 54
36707: PPUSH
36708: LD_VAR 0 1
36712: PPUSH
36713: LD_INT 1
36715: PPUSH
36716: LD_INT 0
36718: PPUSH
36719: CALL 31132 0 4
36723: ST_TO_ADDR
// if mode = 0 then
36724: LD_VAR 0 2
36728: PUSH
36729: LD_INT 0
36731: EQUAL
36732: IFFALSE 38570
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36734: LD_VAR 0 1
36738: PPUSH
36739: LD_INT 30
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PPUSH
36749: CALL 11667 0 2
36753: PUSH
36754: LD_VAR 0 1
36758: PPUSH
36759: LD_INT 21
36761: PUSH
36762: LD_INT 3
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PPUSH
36769: CALL 11667 0 2
36773: PUSH
36774: LD_INT 1
36776: EQUAL
36777: AND
36778: IFFALSE 36843
// begin if all then
36780: LD_VAR 0 17
36784: IFFALSE 36841
// for i in ( all diff eng ) do
36786: LD_ADDR_VAR 0 4
36790: PUSH
36791: LD_VAR 0 17
36795: PUSH
36796: LD_VAR 0 14
36800: DIFF
36801: PUSH
36802: FOR_IN
36803: IFFALSE 36839
// if GetTag ( i ) = 0 then
36805: LD_VAR 0 4
36809: PPUSH
36810: CALL_OW 110
36814: PUSH
36815: LD_INT 0
36817: EQUAL
36818: IFFALSE 36837
// MCH_ChangeClass ( side , i , 2 ) ;
36820: LD_VAR 0 1
36824: PPUSH
36825: LD_VAR 0 4
36829: PPUSH
36830: LD_INT 2
36832: PPUSH
36833: CALL 16574 0 3
36837: GO 36802
36839: POP
36840: POP
// end else
36841: GO 37162
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36843: LD_VAR 0 13
36847: PUSH
36848: LD_EXP 56
36852: PUSH
36853: LD_VAR 0 1
36857: ARRAY
36858: PLUS
36859: PUSH
36860: LD_INT 22
36862: PUSH
36863: LD_VAR 0 1
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 30
36874: PUSH
36875: LD_INT 32
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PPUSH
36886: CALL_OW 69
36890: LESS
36891: IFFALSE 36916
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36893: LD_VAR 0 1
36897: PPUSH
36898: LD_VAR 0 14
36902: PUSH
36903: LD_INT 1
36905: ARRAY
36906: PPUSH
36907: LD_INT 1
36909: PPUSH
36910: CALL 16574 0 3
// end else
36914: GO 37162
// if sci < 6 and MCF_Lab ( side ) then
36916: LD_VAR 0 16
36920: PUSH
36921: LD_INT 6
36923: LESS
36924: PUSH
36925: LD_VAR 0 1
36929: PPUSH
36930: CALL 11706 0 1
36934: AND
36935: IFFALSE 37040
// begin if MREG_ToBunker [ side ] then
36937: LD_EXP 68
36941: PUSH
36942: LD_VAR 0 1
36946: ARRAY
36947: IFFALSE 36973
// tmp := sol diff MREG_ToBunker [ side ] else
36949: LD_ADDR_VAR 0 12
36953: PUSH
36954: LD_VAR 0 13
36958: PUSH
36959: LD_EXP 68
36963: PUSH
36964: LD_VAR 0 1
36968: ARRAY
36969: DIFF
36970: ST_TO_ADDR
36971: GO 36983
// tmp := sol ;
36973: LD_ADDR_VAR 0 12
36977: PUSH
36978: LD_VAR 0 13
36982: ST_TO_ADDR
// if tmp then
36983: LD_VAR 0 12
36987: IFFALSE 37038
// for i in tmp do
36989: LD_ADDR_VAR 0 4
36993: PUSH
36994: LD_VAR 0 12
36998: PUSH
36999: FOR_IN
37000: IFFALSE 37036
// if GetTag ( i ) = 0 then
37002: LD_VAR 0 4
37006: PPUSH
37007: CALL_OW 110
37011: PUSH
37012: LD_INT 0
37014: EQUAL
37015: IFFALSE 37034
// MCH_ChangeClass ( side , i , 4 ) ;
37017: LD_VAR 0 1
37021: PPUSH
37022: LD_VAR 0 4
37026: PPUSH
37027: LD_INT 4
37029: PPUSH
37030: CALL 16574 0 3
37034: GO 36999
37036: POP
37037: POP
// end else
37038: GO 37162
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37040: LD_VAR 0 1
37044: PPUSH
37045: LD_INT 30
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PPUSH
37055: CALL 11667 0 2
37059: IFFALSE 37162
// begin if MREG_ToBunker [ side ] then
37061: LD_EXP 68
37065: PUSH
37066: LD_VAR 0 1
37070: ARRAY
37071: IFFALSE 37097
// tmp := sol diff MREG_ToBunker [ side ] else
37073: LD_ADDR_VAR 0 12
37077: PUSH
37078: LD_VAR 0 13
37082: PUSH
37083: LD_EXP 68
37087: PUSH
37088: LD_VAR 0 1
37092: ARRAY
37093: DIFF
37094: ST_TO_ADDR
37095: GO 37107
// tmp := sol ;
37097: LD_ADDR_VAR 0 12
37101: PUSH
37102: LD_VAR 0 13
37106: ST_TO_ADDR
// if tmp then
37107: LD_VAR 0 12
37111: IFFALSE 37162
// for i in tmp do
37113: LD_ADDR_VAR 0 4
37117: PUSH
37118: LD_VAR 0 12
37122: PUSH
37123: FOR_IN
37124: IFFALSE 37160
// if GetTag ( i ) = 0 then
37126: LD_VAR 0 4
37130: PPUSH
37131: CALL_OW 110
37135: PUSH
37136: LD_INT 0
37138: EQUAL
37139: IFFALSE 37158
// MCH_ChangeClass ( side , i , 2 ) ;
37141: LD_VAR 0 1
37145: PPUSH
37146: LD_VAR 0 4
37150: PPUSH
37151: LD_INT 2
37153: PPUSH
37154: CALL 16574 0 3
37158: GO 37123
37160: POP
37161: POP
// end ; if MCF_Lab ( side ) then
37162: LD_VAR 0 1
37166: PPUSH
37167: CALL 11706 0 1
37171: IFFALSE 37711
// begin if MCL_GetTechList ( side ) then
37173: LD_VAR 0 1
37177: PPUSH
37178: CALL 18050 0 1
37182: IFFALSE 37308
// begin if MREG_ToLab [ side ] then
37184: LD_EXP 54
37188: PUSH
37189: LD_VAR 0 1
37193: ARRAY
37194: IFFALSE 37214
// k := MREG_ToLab [ side ] else
37196: LD_ADDR_VAR 0 8
37200: PUSH
37201: LD_EXP 54
37205: PUSH
37206: LD_VAR 0 1
37210: ARRAY
37211: ST_TO_ADDR
37212: GO 37222
// k := 0 ;
37214: LD_ADDR_VAR 0 8
37218: PUSH
37219: LD_INT 0
37221: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37222: LD_VAR 0 16
37226: PUSH
37227: LD_VAR 0 8
37231: PLUS
37232: PUSH
37233: LD_INT 6
37235: LESSEQUAL
37236: PUSH
37237: LD_VAR 0 17
37241: PUSH
37242: LD_INT 6
37244: GREATER
37245: AND
37246: IFFALSE 37262
// MCH_TrainScientist ( side , 1 ) else
37248: LD_VAR 0 1
37252: PPUSH
37253: LD_INT 1
37255: PPUSH
37256: CALL 16126 0 2
37260: GO 37306
// if all < 6 then
37262: LD_VAR 0 17
37266: PUSH
37267: LD_INT 6
37269: LESS
37270: IFFALSE 37306
// if sci + k < all / 2 then
37272: LD_VAR 0 16
37276: PUSH
37277: LD_VAR 0 8
37281: PLUS
37282: PUSH
37283: LD_VAR 0 17
37287: PUSH
37288: LD_INT 2
37290: DIVREAL
37291: LESS
37292: IFFALSE 37306
// MCH_TrainScientist ( side , 1 ) ;
37294: LD_VAR 0 1
37298: PPUSH
37299: LD_INT 1
37301: PPUSH
37302: CALL 16126 0 2
// end else
37306: GO 37384
// begin if sci > 2 then
37308: LD_VAR 0 16
37312: PUSH
37313: LD_INT 2
37315: GREATER
37316: IFFALSE 37384
// for i = sci downto 2 do
37318: LD_ADDR_VAR 0 4
37322: PUSH
37323: DOUBLE
37324: LD_VAR 0 16
37328: INC
37329: ST_TO_ADDR
37330: LD_INT 2
37332: PUSH
37333: FOR_DOWNTO
37334: IFFALSE 37382
// if GetTag ( sci [ i ] ) = 0 then
37336: LD_VAR 0 16
37340: PUSH
37341: LD_VAR 0 4
37345: ARRAY
37346: PPUSH
37347: CALL_OW 110
37351: PUSH
37352: LD_INT 0
37354: EQUAL
37355: IFFALSE 37380
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37357: LD_VAR 0 1
37361: PPUSH
37362: LD_VAR 0 16
37366: PUSH
37367: LD_VAR 0 4
37371: ARRAY
37372: PPUSH
37373: LD_INT 2
37375: PPUSH
37376: CALL 16574 0 3
37380: GO 37333
37382: POP
37383: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37384: LD_VAR 0 1
37388: PPUSH
37389: CALL 18050 0 1
37393: PUSH
37394: LD_VAR 0 1
37398: PPUSH
37399: CALL 11706 0 1
37403: AND
37404: PUSH
37405: LD_EXP 35
37409: PUSH
37410: LD_VAR 0 1
37414: ARRAY
37415: NOT
37416: AND
37417: IFFALSE 37711
// begin for j = 1 to MCF_Lab ( side ) do
37419: LD_ADDR_VAR 0 5
37423: PUSH
37424: DOUBLE
37425: LD_INT 1
37427: DEC
37428: ST_TO_ADDR
37429: LD_VAR 0 1
37433: PPUSH
37434: CALL 11706 0 1
37438: PUSH
37439: FOR_TO
37440: IFFALSE 37500
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37442: LD_VAR 0 1
37446: PPUSH
37447: CALL 11706 0 1
37451: PUSH
37452: LD_VAR 0 5
37456: ARRAY
37457: PPUSH
37458: CALL_OW 461
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: LD_INT 6
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: IN
37473: IFFALSE 37498
// begin b := MCF_Lab ( side ) [ j ] ;
37475: LD_ADDR_VAR 0 11
37479: PUSH
37480: LD_VAR 0 1
37484: PPUSH
37485: CALL 11706 0 1
37489: PUSH
37490: LD_VAR 0 5
37494: ARRAY
37495: ST_TO_ADDR
// break ;
37496: GO 37500
// end ;
37498: GO 37439
37500: POP
37501: POP
// if MCF_Class ( side , 4 , [ ] ) then
37502: LD_VAR 0 1
37506: PPUSH
37507: LD_INT 4
37509: PPUSH
37510: EMPTY
37511: PPUSH
37512: CALL 11750 0 3
37516: IFFALSE 37711
// for j in MCF_Class ( side , 4 , [ ] ) do
37518: LD_ADDR_VAR 0 5
37522: PUSH
37523: LD_VAR 0 1
37527: PPUSH
37528: LD_INT 4
37530: PPUSH
37531: EMPTY
37532: PPUSH
37533: CALL 11750 0 3
37537: PUSH
37538: FOR_IN
37539: IFFALSE 37709
// begin if GetTag ( j ) = 0 then
37541: LD_VAR 0 5
37545: PPUSH
37546: CALL_OW 110
37550: PUSH
37551: LD_INT 0
37553: EQUAL
37554: IFFALSE 37645
// begin if IsInUnit ( j ) and b then
37556: LD_VAR 0 5
37560: PPUSH
37561: CALL_OW 310
37565: PUSH
37566: LD_VAR 0 11
37570: AND
37571: IFFALSE 37619
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37573: LD_VAR 0 5
37577: PPUSH
37578: CALL_OW 310
37582: PPUSH
37583: CALL_OW 461
37587: PUSH
37588: LD_INT 2
37590: EQUAL
37591: PUSH
37592: LD_VAR 0 5
37596: PPUSH
37597: CALL_OW 310
37601: PUSH
37602: LD_VAR 0 11
37606: NONEQUAL
37607: AND
37608: IFFALSE 37619
// ComExitBuilding ( j ) ;
37610: LD_VAR 0 5
37614: PPUSH
37615: CALL_OW 122
// if not IsInUnit ( j ) then
37619: LD_VAR 0 5
37623: PPUSH
37624: CALL_OW 310
37628: NOT
37629: IFFALSE 37645
// ComEnterUnit ( j , b ) ;
37631: LD_VAR 0 5
37635: PPUSH
37636: LD_VAR 0 11
37640: PPUSH
37641: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37645: LD_INT 1
37647: PPUSH
37648: LD_VAR 0 5
37652: PPUSH
37653: CALL_OW 255
37657: PPUSH
37658: CALL_OW 321
37662: PUSH
37663: LD_INT 2
37665: EQUAL
37666: PUSH
37667: LD_VAR 0 5
37671: PPUSH
37672: CALL_OW 255
37676: PPUSH
37677: CALL 25022 0 1
37681: PUSH
37682: LD_INT 0
37684: EQUAL
37685: AND
37686: IFFALSE 37707
// MCN_Tame ( GetSide ( j ) , j ) ;
37688: LD_VAR 0 5
37692: PPUSH
37693: CALL_OW 255
37697: PPUSH
37698: LD_VAR 0 5
37702: PPUSH
37703: CALL 18569 0 2
// end ;
37707: GO 37538
37709: POP
37710: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37711: LD_VAR 0 1
37715: PPUSH
37716: LD_INT 30
37718: PUSH
37719: LD_INT 3
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PPUSH
37726: CALL 11667 0 2
37730: IFFALSE 37989
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37732: LD_ADDR_VAR 0 11
37736: PUSH
37737: LD_VAR 0 1
37741: PPUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 3
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PPUSH
37752: CALL 11667 0 2
37756: PUSH
37757: LD_INT 1
37759: ARRAY
37760: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37761: LD_ADDR_VAR 0 12
37765: PUSH
37766: LD_VAR 0 1
37770: PPUSH
37771: LD_INT 0
37773: PPUSH
37774: LD_INT 25
37776: PUSH
37777: LD_INT 3
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PPUSH
37784: CALL 12370 0 3
37788: ST_TO_ADDR
// for i = 1 to tmp do
37789: LD_ADDR_VAR 0 4
37793: PUSH
37794: DOUBLE
37795: LD_INT 1
37797: DEC
37798: ST_TO_ADDR
37799: LD_VAR 0 12
37803: PUSH
37804: FOR_TO
37805: IFFALSE 37865
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37807: LD_VAR 0 12
37811: PUSH
37812: LD_VAR 0 4
37816: ARRAY
37817: PPUSH
37818: CALL_OW 310
37822: NOT
37823: PUSH
37824: LD_VAR 0 12
37828: PUSH
37829: LD_VAR 0 4
37833: ARRAY
37834: PPUSH
37835: CALL_OW 314
37839: NOT
37840: AND
37841: IFFALSE 37863
// ComEnterUnit ( tmp [ i ] , b ) ;
37843: LD_VAR 0 12
37847: PUSH
37848: LD_VAR 0 4
37852: ARRAY
37853: PPUSH
37854: LD_VAR 0 11
37858: PPUSH
37859: CALL_OW 120
37863: GO 37804
37865: POP
37866: POP
// if MREG_ToFac [ side ] then
37867: LD_EXP 55
37871: PUSH
37872: LD_VAR 0 1
37876: ARRAY
37877: IFFALSE 37897
// k := MREG_ToFac [ side ] else
37879: LD_ADDR_VAR 0 8
37883: PUSH
37884: LD_EXP 55
37888: PUSH
37889: LD_VAR 0 1
37893: ARRAY
37894: ST_TO_ADDR
37895: GO 37905
// k := 0 ;
37897: LD_ADDR_VAR 0 8
37901: PUSH
37902: LD_INT 0
37904: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37905: LD_VAR 0 15
37909: PUSH
37910: LD_VAR 0 8
37914: PLUS
37915: PUSH
37916: LD_INT 6
37918: LESSEQUAL
37919: PUSH
37920: LD_VAR 0 17
37924: PUSH
37925: LD_INT 6
37927: GREATER
37928: AND
37929: IFFALSE 37945
// MCH_TrainMechanic ( side , 1 ) else
37931: LD_VAR 0 1
37935: PPUSH
37936: LD_INT 1
37938: PPUSH
37939: CALL 15868 0 2
37943: GO 37989
// if all < 6 then
37945: LD_VAR 0 17
37949: PUSH
37950: LD_INT 6
37952: LESS
37953: IFFALSE 37989
// if mech + k < all / 2 then
37955: LD_VAR 0 15
37959: PUSH
37960: LD_VAR 0 8
37964: PLUS
37965: PUSH
37966: LD_VAR 0 17
37970: PUSH
37971: LD_INT 2
37973: DIVREAL
37974: LESS
37975: IFFALSE 37989
// MCH_TrainMechanic ( side , 1 ) ;
37977: LD_VAR 0 1
37981: PPUSH
37982: LD_INT 1
37984: PPUSH
37985: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37989: LD_ADDR_VAR 0 10
37993: PUSH
37994: LD_VAR 0 1
37998: PPUSH
37999: LD_INT 30
38001: PUSH
38002: LD_INT 36
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PPUSH
38009: CALL 11667 0 2
38013: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38014: LD_VAR 0 10
38018: PUSH
38019: LD_VAR 0 15
38023: AND
38024: PUSH
38025: LD_VAR 0 1
38029: PPUSH
38030: LD_INT 3
38032: PPUSH
38033: EMPTY
38034: PPUSH
38035: CALL 11750 0 3
38039: AND
38040: IFFALSE 38198
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38042: LD_VAR 0 1
38046: PPUSH
38047: LD_INT 9
38049: PPUSH
38050: EMPTY
38051: PPUSH
38052: CALL 12370 0 3
38056: PUSH
38057: LD_INT 3
38059: LESS
38060: IFFALSE 38198
// begin if mech < 3 then
38062: LD_VAR 0 15
38066: PUSH
38067: LD_INT 3
38069: LESS
38070: IFFALSE 38084
// k := mech else
38072: LD_ADDR_VAR 0 8
38076: PUSH
38077: LD_VAR 0 15
38081: ST_TO_ADDR
38082: GO 38092
// k := 3 ;
38084: LD_ADDR_VAR 0 8
38088: PUSH
38089: LD_INT 3
38091: ST_TO_ADDR
// for j = 1 to k do
38092: LD_ADDR_VAR 0 5
38096: PUSH
38097: DOUBLE
38098: LD_INT 1
38100: DEC
38101: ST_TO_ADDR
38102: LD_VAR 0 8
38106: PUSH
38107: FOR_TO
38108: IFFALSE 38166
// if GetClass ( mech [ j ] ) = 3 then
38110: LD_VAR 0 15
38114: PUSH
38115: LD_VAR 0 5
38119: ARRAY
38120: PPUSH
38121: CALL_OW 257
38125: PUSH
38126: LD_INT 3
38128: EQUAL
38129: IFFALSE 38164
// begin SetTag ( mech [ j ] , 9 ) ;
38131: LD_VAR 0 15
38135: PUSH
38136: LD_VAR 0 5
38140: ARRAY
38141: PPUSH
38142: LD_INT 9
38144: PPUSH
38145: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38149: LD_VAR 0 15
38153: PUSH
38154: LD_VAR 0 5
38158: ARRAY
38159: PPUSH
38160: CALL_OW 122
// end ;
38164: GO 38107
38166: POP
38167: POP
// if mech < 6 + k then
38168: LD_VAR 0 15
38172: PUSH
38173: LD_INT 6
38175: PUSH
38176: LD_VAR 0 8
38180: PLUS
38181: LESS
38182: IFFALSE 38198
// MCH_TrainMechanic ( side , k ) ;
38184: LD_VAR 0 1
38188: PPUSH
38189: LD_VAR 0 8
38193: PPUSH
38194: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_INT 9
38205: PPUSH
38206: EMPTY
38207: PPUSH
38208: CALL 12370 0 3
38212: IFFALSE 38303
// for j in MCF_Tag ( side , 9 , [ ] ) do
38214: LD_ADDR_VAR 0 5
38218: PUSH
38219: LD_VAR 0 1
38223: PPUSH
38224: LD_INT 9
38226: PPUSH
38227: EMPTY
38228: PPUSH
38229: CALL 12370 0 3
38233: PUSH
38234: FOR_IN
38235: IFFALSE 38301
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38237: LD_VAR 0 5
38241: PPUSH
38242: CALL_OW 310
38246: NOT
38247: PUSH
38248: LD_VAR 0 5
38252: PPUSH
38253: CALL 95567 0 1
38257: NOT
38258: AND
38259: IFFALSE 38299
// if ct then
38261: LD_VAR 0 10
38265: IFFALSE 38287
// ComEnterUnit ( j , ct [ 1 ] ) else
38267: LD_VAR 0 5
38271: PPUSH
38272: LD_VAR 0 10
38276: PUSH
38277: LD_INT 1
38279: ARRAY
38280: PPUSH
38281: CALL_OW 120
38285: GO 38299
// SetTag ( j , 0 ) ;
38287: LD_VAR 0 5
38291: PPUSH
38292: LD_INT 0
38294: PPUSH
38295: CALL_OW 109
38299: GO 38234
38301: POP
38302: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38303: LD_INT 1
38305: PPUSH
38306: LD_VAR 0 1
38310: PPUSH
38311: CALL_OW 321
38315: PUSH
38316: LD_INT 2
38318: EQUAL
38319: PUSH
38320: LD_EXP 35
38324: PUSH
38325: LD_VAR 0 1
38329: ARRAY
38330: NOT
38331: AND
38332: PUSH
38333: LD_VAR 0 1
38337: PPUSH
38338: LD_INT 4
38340: PPUSH
38341: EMPTY
38342: PPUSH
38343: CALL 11750 0 3
38347: AND
38348: IFFALSE 38396
// for j in MCF_Class ( side , 4 , [ ] ) do
38350: LD_ADDR_VAR 0 5
38354: PUSH
38355: LD_VAR 0 1
38359: PPUSH
38360: LD_INT 4
38362: PPUSH
38363: EMPTY
38364: PPUSH
38365: CALL 11750 0 3
38369: PUSH
38370: FOR_IN
38371: IFFALSE 38394
// MCN_Tame ( GetSide ( j ) , j ) ;
38373: LD_VAR 0 5
38377: PPUSH
38378: CALL_OW 255
38382: PPUSH
38383: LD_VAR 0 5
38387: PPUSH
38388: CALL 18569 0 2
38392: GO 38370
38394: POP
38395: POP
// if MREG_DefVeh [ side ] then
38396: LD_EXP 67
38400: PUSH
38401: LD_VAR 0 1
38405: ARRAY
38406: IFFALSE 38570
// begin for i in MREG_DefVeh [ side ] do
38408: LD_ADDR_VAR 0 4
38412: PUSH
38413: LD_EXP 67
38417: PUSH
38418: LD_VAR 0 1
38422: ARRAY
38423: PUSH
38424: FOR_IN
38425: IFFALSE 38478
// begin SetTag ( i , 0 ) ;
38427: LD_VAR 0 4
38431: PPUSH
38432: LD_INT 0
38434: PPUSH
38435: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_EXP 64
38448: PUSH
38449: LD_VAR 0 1
38453: ARRAY
38454: PPUSH
38455: CALL_OW 308
38459: NOT
38460: IFFALSE 38476
// MCV_Parking ( side , i ) ;
38462: LD_VAR 0 1
38466: PPUSH
38467: LD_VAR 0 4
38471: PPUSH
38472: CALL 25757 0 2
// end ;
38476: GO 38424
38478: POP
38479: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38480: LD_VAR 0 1
38484: PPUSH
38485: LD_INT 36
38487: PPUSH
38488: EMPTY
38489: PPUSH
38490: CALL 12370 0 3
38494: IFFALSE 38535
// for i in MCF_Tag ( side , 36 , [ ] ) do
38496: LD_ADDR_VAR 0 4
38500: PUSH
38501: LD_VAR 0 1
38505: PPUSH
38506: LD_INT 36
38508: PPUSH
38509: EMPTY
38510: PPUSH
38511: CALL 12370 0 3
38515: PUSH
38516: FOR_IN
38517: IFFALSE 38533
// SetTag ( i , 0 ) ;
38519: LD_VAR 0 4
38523: PPUSH
38524: LD_INT 0
38526: PPUSH
38527: CALL_OW 109
38531: GO 38516
38533: POP
38534: POP
// if MREG_DefMobActive [ side ] then
38535: LD_EXP 70
38539: PUSH
38540: LD_VAR 0 1
38544: ARRAY
38545: IFFALSE 38570
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38547: LD_ADDR_EXP 70
38551: PUSH
38552: LD_EXP 70
38556: PPUSH
38557: LD_VAR 0 1
38561: PPUSH
38562: LD_INT 0
38564: PPUSH
38565: CALL_OW 1
38569: ST_TO_ADDR
// end ; end ; if mode > 0 then
38570: LD_VAR 0 2
38574: PUSH
38575: LD_INT 0
38577: GREATER
38578: IFFALSE 40473
// begin if tick <= 15 15$00 then
38580: LD_OWVAR 1
38584: PUSH
38585: LD_INT 31500
38587: LESSEQUAL
38588: IFFALSE 38892
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38590: LD_VAR 0 13
38594: PUSH
38595: LD_VAR 0 1
38599: PPUSH
38600: CALL 25022 0 1
38604: PUSH
38605: LD_INT 4
38607: LESS
38608: AND
38609: IFFALSE 38720
// begin for i in sol do
38611: LD_ADDR_VAR 0 4
38615: PUSH
38616: LD_VAR 0 13
38620: PUSH
38621: FOR_IN
38622: IFFALSE 38718
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38624: LD_ADDR_VAR 0 8
38628: PUSH
38629: LD_VAR 0 1
38633: PPUSH
38634: CALL 25022 0 1
38638: PPUSH
38639: LD_VAR 0 4
38643: PPUSH
38644: CALL_OW 74
38648: ST_TO_ADDR
// if IsInUnit ( i ) then
38649: LD_VAR 0 4
38653: PPUSH
38654: CALL_OW 310
38658: IFFALSE 38669
// ComExitBuilding ( i ) ;
38660: LD_VAR 0 4
38664: PPUSH
38665: CALL_OW 122
// if not HasTask ( i ) and k then
38669: LD_VAR 0 4
38673: PPUSH
38674: CALL_OW 314
38678: NOT
38679: PUSH
38680: LD_VAR 0 8
38684: AND
38685: IFFALSE 38716
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38687: LD_VAR 0 4
38691: PPUSH
38692: LD_VAR 0 8
38696: PPUSH
38697: CALL_OW 250
38701: PPUSH
38702: LD_VAR 0 8
38706: PPUSH
38707: CALL_OW 251
38711: PPUSH
38712: CALL_OW 174
// end ;
38716: GO 38621
38718: POP
38719: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38720: LD_VAR 0 1
38724: PPUSH
38725: LD_INT 30
38727: PUSH
38728: LD_INT 5
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PPUSH
38735: CALL 11667 0 2
38739: IFFALSE 38890
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38741: LD_ADDR_VAR 0 11
38745: PUSH
38746: LD_VAR 0 1
38750: PPUSH
38751: LD_INT 30
38753: PUSH
38754: LD_INT 5
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PPUSH
38761: CALL 11667 0 2
38765: PUSH
38766: LD_INT 1
38768: ARRAY
38769: ST_TO_ADDR
// if mech then
38770: LD_VAR 0 15
38774: IFFALSE 38810
// for i in mech do
38776: LD_ADDR_VAR 0 4
38780: PUSH
38781: LD_VAR 0 15
38785: PUSH
38786: FOR_IN
38787: IFFALSE 38808
// MCH_ChangeClass ( side , i , 1 ) ;
38789: LD_VAR 0 1
38793: PPUSH
38794: LD_VAR 0 4
38798: PPUSH
38799: LD_INT 1
38801: PPUSH
38802: CALL 16574 0 3
38806: GO 38786
38808: POP
38809: POP
// if eng > 1 then
38810: LD_VAR 0 14
38814: PUSH
38815: LD_INT 1
38817: GREATER
38818: IFFALSE 38865
// for i = eng downto 2 do
38820: LD_ADDR_VAR 0 4
38824: PUSH
38825: DOUBLE
38826: LD_VAR 0 14
38830: INC
38831: ST_TO_ADDR
38832: LD_INT 2
38834: PUSH
38835: FOR_DOWNTO
38836: IFFALSE 38863
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38838: LD_VAR 0 1
38842: PPUSH
38843: LD_VAR 0 14
38847: PUSH
38848: LD_VAR 0 4
38852: ARRAY
38853: PPUSH
38854: LD_INT 1
38856: PPUSH
38857: CALL 16574 0 3
38861: GO 38835
38863: POP
38864: POP
// if UnitsInside ( b ) then
38865: LD_VAR 0 11
38869: PPUSH
38870: CALL_OW 313
38874: IFFALSE 38890
// ComExitBuilding ( UnitsInside ( b ) ) ;
38876: LD_VAR 0 11
38880: PPUSH
38881: CALL_OW 313
38885: PPUSH
38886: CALL_OW 122
// end ; end else
38890: GO 40473
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38892: LD_VAR 0 1
38896: PPUSH
38897: LD_INT 1
38899: PPUSH
38900: LD_EXP 65
38904: PUSH
38905: LD_VAR 0 1
38909: ARRAY
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PPUSH
38915: CALL 33745 0 3
38919: IFFALSE 39058
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38921: LD_ADDR_VAR 0 12
38925: PUSH
38926: LD_VAR 0 1
38930: PPUSH
38931: LD_INT 21
38933: PUSH
38934: LD_INT 1
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PPUSH
38941: CALL 11667 0 2
38945: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38946: LD_ADDR_VAR 0 11
38950: PUSH
38951: LD_VAR 0 1
38955: PPUSH
38956: LD_INT 30
38958: PUSH
38959: LD_INT 1
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PPUSH
38966: CALL 11667 0 2
38970: ST_TO_ADDR
// if b then
38971: LD_VAR 0 11
38975: IFFALSE 39058
// for i in tmp do
38977: LD_ADDR_VAR 0 4
38981: PUSH
38982: LD_VAR 0 12
38986: PUSH
38987: FOR_IN
38988: IFFALSE 39056
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38990: LD_VAR 0 4
38994: PPUSH
38995: LD_EXP 65
38999: PUSH
39000: LD_VAR 0 1
39004: ARRAY
39005: PUSH
39006: LD_INT 1
39008: ARRAY
39009: PPUSH
39010: CALL_OW 308
39014: NOT
39015: IFFALSE 39054
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39017: LD_VAR 0 4
39021: PPUSH
39022: LD_VAR 0 11
39026: PUSH
39027: LD_INT 1
39029: ARRAY
39030: PPUSH
39031: CALL_OW 250
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 251
39049: PPUSH
39050: CALL_OW 111
39054: GO 38987
39056: POP
39057: POP
// end ; if MREG_DefVeh [ side ] then
39058: LD_EXP 67
39062: PUSH
39063: LD_VAR 0 1
39067: ARRAY
39068: IFFALSE 39636
// begin tmp := [ ] ;
39070: LD_ADDR_VAR 0 12
39074: PUSH
39075: EMPTY
39076: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39077: LD_EXP 70
39081: PUSH
39082: LD_VAR 0 1
39086: ARRAY
39087: PUSH
39088: LD_INT 0
39090: EQUAL
39091: IFFALSE 39231
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39093: LD_ADDR_VAR 0 8
39097: PUSH
39098: LD_VAR 0 1
39102: PPUSH
39103: LD_INT 0
39105: PPUSH
39106: LD_INT 25
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PPUSH
39116: CALL 12370 0 3
39120: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39121: LD_VAR 0 8
39125: PUSH
39126: LD_EXP 67
39130: PUSH
39131: LD_VAR 0 1
39135: ARRAY
39136: GREATER
39137: IFFALSE 39198
// begin for i = 1 to MREG_DefVeh [ side ] do
39139: LD_ADDR_VAR 0 4
39143: PUSH
39144: DOUBLE
39145: LD_INT 1
39147: DEC
39148: ST_TO_ADDR
39149: LD_EXP 67
39153: PUSH
39154: LD_VAR 0 1
39158: ARRAY
39159: PUSH
39160: FOR_TO
39161: IFFALSE 39194
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39163: LD_ADDR_VAR 0 12
39167: PUSH
39168: LD_VAR 0 12
39172: PPUSH
39173: LD_INT 1
39175: PPUSH
39176: LD_VAR 0 8
39180: PUSH
39181: LD_VAR 0 4
39185: ARRAY
39186: PPUSH
39187: CALL_OW 2
39191: ST_TO_ADDR
39192: GO 39160
39194: POP
39195: POP
// end else
39196: GO 39208
// tmp := k ;
39198: LD_ADDR_VAR 0 12
39202: PUSH
39203: LD_VAR 0 8
39207: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39208: LD_ADDR_EXP 70
39212: PUSH
39213: LD_EXP 70
39217: PPUSH
39218: LD_VAR 0 1
39222: PPUSH
39223: LD_INT 1
39225: PPUSH
39226: CALL_OW 1
39230: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39231: LD_ADDR_VAR 0 4
39235: PUSH
39236: LD_EXP 67
39240: PUSH
39241: LD_VAR 0 1
39245: ARRAY
39246: PUSH
39247: FOR_IN
39248: IFFALSE 39634
// begin if not GetDriver ( i ) then
39250: LD_VAR 0 4
39254: PPUSH
39255: CALL 31775 0 1
39259: NOT
39260: IFFALSE 39335
// begin if tmp then
39262: LD_VAR 0 12
39266: IFFALSE 39333
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39268: LD_VAR 0 12
39272: PUSH
39273: LD_INT 1
39275: ARRAY
39276: PPUSH
39277: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39281: LD_VAR 0 12
39285: PUSH
39286: LD_INT 1
39288: ARRAY
39289: PPUSH
39290: LD_VAR 0 4
39294: PPUSH
39295: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39299: LD_VAR 0 12
39303: PUSH
39304: LD_INT 1
39306: ARRAY
39307: PPUSH
39308: LD_INT 36
39310: PPUSH
39311: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39315: LD_ADDR_VAR 0 12
39319: PUSH
39320: LD_VAR 0 12
39324: PPUSH
39325: LD_INT 1
39327: PPUSH
39328: CALL_OW 3
39332: ST_TO_ADDR
// end ; end else
39333: GO 39632
// begin if GetTag ( i ) = 0 then
39335: LD_VAR 0 4
39339: PPUSH
39340: CALL_OW 110
39344: PUSH
39345: LD_INT 0
39347: EQUAL
39348: IFFALSE 39364
// SetTag ( i , 31 ) else
39350: LD_VAR 0 4
39354: PPUSH
39355: LD_INT 31
39357: PPUSH
39358: CALL_OW 109
39362: GO 39632
// if GetTag ( i ) = 31 then
39364: LD_VAR 0 4
39368: PPUSH
39369: CALL_OW 110
39373: PUSH
39374: LD_INT 31
39376: EQUAL
39377: IFFALSE 39632
// begin if GetFuel ( i ) < 20 then
39379: LD_VAR 0 4
39383: PPUSH
39384: CALL_OW 261
39388: PUSH
39389: LD_INT 20
39391: LESS
39392: IFFALSE 39417
// begin SetTag ( i , 21 ) ;
39394: LD_VAR 0 4
39398: PPUSH
39399: LD_INT 21
39401: PPUSH
39402: CALL_OW 109
// MCV_Refuel ( i ) ;
39406: LD_VAR 0 4
39410: PPUSH
39411: CALL 26294 0 1
// continue ;
39415: GO 39247
// end ; if GetLives ( i ) < 700 then
39417: LD_VAR 0 4
39421: PPUSH
39422: CALL_OW 256
39426: PUSH
39427: LD_INT 700
39429: LESS
39430: IFFALSE 39542
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39432: LD_VAR 0 4
39436: PPUSH
39437: LD_EXP 58
39441: PUSH
39442: LD_VAR 0 1
39446: ARRAY
39447: PPUSH
39448: CALL_OW 308
39452: NOT
39453: IFFALSE 39477
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39455: LD_VAR 0 4
39459: PPUSH
39460: LD_EXP 58
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: CALL_OW 113
39475: GO 39540
// if GetDriver ( i ) then
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL 31775 0 1
39486: IFFALSE 39540
// begin k := GetDriver ( i ) ;
39488: LD_ADDR_VAR 0 8
39492: PUSH
39493: LD_VAR 0 4
39497: PPUSH
39498: CALL 31775 0 1
39502: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39503: LD_VAR 0 8
39507: PPUSH
39508: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39512: LD_VAR 0 8
39516: PPUSH
39517: LD_VAR 0 4
39521: PPUSH
39522: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 180
// end ; end else
39540: GO 39632
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39542: LD_ADDR_VAR 0 8
39546: PUSH
39547: LD_VAR 0 1
39551: PPUSH
39552: CALL 25022 0 1
39556: PPUSH
39557: LD_VAR 0 4
39561: PPUSH
39562: CALL_OW 74
39566: ST_TO_ADDR
// if k then
39567: LD_VAR 0 8
39571: IFFALSE 39589
// ComAttackUnit ( i , k ) else
39573: LD_VAR 0 4
39577: PPUSH
39578: LD_VAR 0 8
39582: PPUSH
39583: CALL_OW 115
39587: GO 39632
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39589: LD_VAR 0 4
39593: PPUSH
39594: LD_EXP 58
39598: PUSH
39599: LD_VAR 0 1
39603: ARRAY
39604: PPUSH
39605: CALL_OW 308
39609: NOT
39610: IFFALSE 39632
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39612: LD_VAR 0 4
39616: PPUSH
39617: LD_EXP 58
39621: PUSH
39622: LD_VAR 0 1
39626: ARRAY
39627: PPUSH
39628: CALL_OW 113
// end ; end ; end ; end ;
39632: GO 39247
39634: POP
39635: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39636: LD_VAR 0 1
39640: PPUSH
39641: LD_INT 30
39643: PUSH
39644: LD_INT 5
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PPUSH
39651: CALL 11667 0 2
39655: IFFALSE 40473
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39657: LD_ADDR_VAR 0 11
39661: PUSH
39662: LD_VAR 0 1
39666: PPUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 5
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PPUSH
39677: CALL 11667 0 2
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: ST_TO_ADDR
// if eng > 1 then
39686: LD_VAR 0 14
39690: PUSH
39691: LD_INT 1
39693: GREATER
39694: IFFALSE 39741
// for i = eng downto 2 do
39696: LD_ADDR_VAR 0 4
39700: PUSH
39701: DOUBLE
39702: LD_VAR 0 14
39706: INC
39707: ST_TO_ADDR
39708: LD_INT 2
39710: PUSH
39711: FOR_DOWNTO
39712: IFFALSE 39739
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39714: LD_VAR 0 1
39718: PPUSH
39719: LD_VAR 0 14
39723: PUSH
39724: LD_VAR 0 4
39728: ARRAY
39729: PPUSH
39730: LD_INT 1
39732: PPUSH
39733: CALL 16574 0 3
39737: GO 39711
39739: POP
39740: POP
// if sci > 1 then
39741: LD_VAR 0 16
39745: PUSH
39746: LD_INT 1
39748: GREATER
39749: IFFALSE 39796
// for i = sci downto 2 do
39751: LD_ADDR_VAR 0 4
39755: PUSH
39756: DOUBLE
39757: LD_VAR 0 16
39761: INC
39762: ST_TO_ADDR
39763: LD_INT 2
39765: PUSH
39766: FOR_DOWNTO
39767: IFFALSE 39794
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39769: LD_VAR 0 1
39773: PPUSH
39774: LD_VAR 0 16
39778: PUSH
39779: LD_VAR 0 4
39783: ARRAY
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: CALL 16574 0 3
39792: GO 39766
39794: POP
39795: POP
// if sol then
39796: LD_VAR 0 13
39800: IFFALSE 40473
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39802: LD_VAR 0 13
39806: PUSH
39807: LD_EXP 68
39811: PUSH
39812: LD_VAR 0 1
39816: ARRAY
39817: DIFF
39818: PUSH
39819: LD_INT 22
39821: PUSH
39822: LD_VAR 0 1
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 58
39833: PUSH
39834: EMPTY
39835: LIST
39836: PUSH
39837: LD_INT 2
39839: PUSH
39840: LD_INT 30
39842: PUSH
39843: LD_INT 32
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 30
39852: PUSH
39853: LD_INT 31
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: PPUSH
39870: CALL_OW 69
39874: PUSH
39875: LD_INT 0
39877: EQUAL
39878: AND
39879: IFFALSE 40473
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39881: LD_ADDR_VAR 0 12
39885: PUSH
39886: LD_VAR 0 13
39890: PUSH
39891: LD_EXP 68
39895: PUSH
39896: LD_VAR 0 1
39900: ARRAY
39901: DIFF
39902: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39903: LD_VAR 0 1
39907: PPUSH
39908: LD_INT 30
39910: PUSH
39911: LD_INT 5
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PPUSH
39918: CALL 11667 0 2
39922: PUSH
39923: LD_INT 1
39925: GREATER
39926: IFFALSE 39957
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39928: LD_ADDR_VAR 0 8
39932: PUSH
39933: LD_VAR 0 1
39937: PPUSH
39938: LD_INT 30
39940: PUSH
39941: LD_INT 5
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PPUSH
39948: CALL 11667 0 2
39952: PUSH
39953: LD_INT 2
39955: ARRAY
39956: ST_TO_ADDR
// for j in tmp do
39957: LD_ADDR_VAR 0 5
39961: PUSH
39962: LD_VAR 0 12
39966: PUSH
39967: FOR_IN
39968: IFFALSE 40471
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39970: LD_VAR 0 5
39974: PUSH
39975: LD_VAR 0 11
39979: PPUSH
39980: CALL_OW 313
39984: IN
39985: PUSH
39986: LD_VAR 0 11
39990: PPUSH
39991: CALL_OW 313
39995: PUSH
39996: LD_INT 6
39998: EQUAL
39999: AND
40000: PUSH
40001: LD_VAR 0 8
40005: AND
40006: PUSH
40007: LD_VAR 0 8
40011: PPUSH
40012: CALL_OW 313
40016: PUSH
40017: LD_INT 6
40019: LESS
40020: AND
40021: IFFALSE 40048
// begin ComExitBuilding ( j ) ;
40023: LD_VAR 0 5
40027: PPUSH
40028: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40032: LD_VAR 0 5
40036: PPUSH
40037: LD_VAR 0 8
40041: PPUSH
40042: CALL_OW 180
// continue ;
40046: GO 39967
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40048: LD_VAR 0 5
40052: PPUSH
40053: CALL_OW 314
40057: NOT
40058: PUSH
40059: LD_VAR 0 5
40063: PPUSH
40064: CALL_OW 110
40068: PUSH
40069: LD_INT 0
40071: EQUAL
40072: AND
40073: PUSH
40074: LD_VAR 0 5
40078: PPUSH
40079: CALL_OW 310
40083: NOT
40084: AND
40085: IFFALSE 40191
// begin if k then
40087: LD_VAR 0 8
40091: IFFALSE 40162
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40093: LD_VAR 0 8
40097: PPUSH
40098: CALL_OW 313
40102: PUSH
40103: LD_VAR 0 11
40107: PPUSH
40108: CALL_OW 313
40112: LESS
40113: IFFALSE 40131
// ComEnterUnit ( j , k ) else
40115: LD_VAR 0 5
40119: PPUSH
40120: LD_VAR 0 8
40124: PPUSH
40125: CALL_OW 120
40129: GO 40160
// if UnitsInside ( b ) < 6 then
40131: LD_VAR 0 11
40135: PPUSH
40136: CALL_OW 313
40140: PUSH
40141: LD_INT 6
40143: LESS
40144: IFFALSE 40160
// ComEnterUnit ( j , b ) ;
40146: LD_VAR 0 5
40150: PPUSH
40151: LD_VAR 0 11
40155: PPUSH
40156: CALL_OW 120
// end else
40160: GO 40191
// if UnitsInside ( b ) < 6 then
40162: LD_VAR 0 11
40166: PPUSH
40167: CALL_OW 313
40171: PUSH
40172: LD_INT 6
40174: LESS
40175: IFFALSE 40191
// ComEnterUnit ( j , b ) ;
40177: LD_VAR 0 5
40181: PPUSH
40182: LD_VAR 0 11
40186: PPUSH
40187: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40191: LD_VAR 0 5
40195: PUSH
40196: LD_VAR 0 1
40200: PPUSH
40201: LD_INT 54
40203: PUSH
40204: EMPTY
40205: LIST
40206: PPUSH
40207: CALL 11667 0 2
40211: IN
40212: PUSH
40213: LD_VAR 0 5
40217: PPUSH
40218: CALL_OW 257
40222: PUSH
40223: LD_INT 1
40225: EQUAL
40226: AND
40227: IFFALSE 40469
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40229: LD_EXP 62
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 1
40242: ARRAY
40243: PUSH
40244: LD_INT 12
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 5
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11750 0 3
40277: PUSH
40278: LD_EXP 62
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 1
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_sniper ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 5
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39967
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40309: LD_EXP 62
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 2
40322: ARRAY
40323: PUSH
40324: LD_INT 41
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 8
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11750 0 3
40357: PUSH
40358: LD_EXP 62
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 2
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_mortar ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 8
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39967
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40389: LD_EXP 62
40393: PUSH
40394: LD_VAR 0 1
40398: ARRAY
40399: PUSH
40400: LD_INT 3
40402: ARRAY
40403: PUSH
40404: LD_INT 44
40406: PPUSH
40407: LD_VAR 0 1
40411: PPUSH
40412: CALL_OW 321
40416: PUSH
40417: LD_INT 2
40419: EQUAL
40420: AND
40421: IFFALSE 40469
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40423: LD_VAR 0 1
40427: PPUSH
40428: LD_INT 9
40430: PPUSH
40431: EMPTY
40432: PPUSH
40433: CALL 11750 0 3
40437: PUSH
40438: LD_EXP 62
40442: PUSH
40443: LD_VAR 0 1
40447: ARRAY
40448: PUSH
40449: LD_INT 3
40451: ARRAY
40452: LESS
40453: IFFALSE 40469
// begin SetClass ( j , class_bazooker ) ;
40455: LD_VAR 0 5
40459: PPUSH
40460: LD_INT 9
40462: PPUSH
40463: CALL_OW 336
// continue ;
40467: GO 39967
// end ; end ; end ;
40469: GO 39967
40471: POP
40472: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40473: LD_INT 22
40475: PUSH
40476: LD_VAR 0 1
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 58
40487: PUSH
40488: EMPTY
40489: LIST
40490: PUSH
40491: LD_INT 30
40493: PUSH
40494: LD_INT 32
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 69
40510: IFFALSE 40660
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40512: LD_ADDR_VAR 0 12
40516: PUSH
40517: LD_INT 22
40519: PUSH
40520: LD_VAR 0 1
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 58
40531: PUSH
40532: EMPTY
40533: LIST
40534: PUSH
40535: LD_INT 30
40537: PUSH
40538: LD_INT 32
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: LIST
40549: PPUSH
40550: CALL_OW 69
40554: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40555: LD_ADDR_VAR 0 8
40559: PUSH
40560: LD_VAR 0 13
40564: PUSH
40565: LD_EXP 68
40569: PUSH
40570: LD_VAR 0 1
40574: ARRAY
40575: DIFF
40576: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40577: LD_VAR 0 12
40581: PUSH
40582: LD_INT 1
40584: ARRAY
40585: PPUSH
40586: CALL_OW 461
40590: PUSH
40591: LD_INT 2
40593: EQUAL
40594: PUSH
40595: LD_VAR 0 12
40599: PUSH
40600: LD_INT 1
40602: ARRAY
40603: PUSH
40604: LD_EXP 68
40608: PUSH
40609: LD_VAR 0 1
40613: ARRAY
40614: IN
40615: NOT
40616: AND
40617: PUSH
40618: LD_VAR 0 8
40622: AND
40623: IFFALSE 40660
// begin ComExitBuilding ( k [ 1 ] ) ;
40625: LD_VAR 0 8
40629: PUSH
40630: LD_INT 1
40632: ARRAY
40633: PPUSH
40634: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40638: LD_VAR 0 8
40642: PUSH
40643: LD_INT 1
40645: ARRAY
40646: PPUSH
40647: LD_VAR 0 12
40651: PUSH
40652: LD_INT 1
40654: ARRAY
40655: PPUSH
40656: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40660: LD_EXP 35
40664: PUSH
40665: LD_VAR 0 1
40669: ARRAY
40670: IFFALSE 40818
// begin if MCF_Class ( side , 4 , [ ] ) then
40672: LD_VAR 0 1
40676: PPUSH
40677: LD_INT 4
40679: PPUSH
40680: EMPTY
40681: PPUSH
40682: CALL 11750 0 3
40686: IFFALSE 40816
// for j in MCF_Class ( side , 4 , [ ] ) do
40688: LD_ADDR_VAR 0 5
40692: PUSH
40693: LD_VAR 0 1
40697: PPUSH
40698: LD_INT 4
40700: PPUSH
40701: EMPTY
40702: PPUSH
40703: CALL 11750 0 3
40707: PUSH
40708: FOR_IN
40709: IFFALSE 40814
// begin if not GetTag ( j ) = 4 then
40711: LD_VAR 0 5
40715: PPUSH
40716: CALL_OW 110
40720: PUSH
40721: LD_INT 4
40723: EQUAL
40724: NOT
40725: IFFALSE 40761
// begin SetTag ( j , 4 ) ;
40727: LD_VAR 0 5
40731: PPUSH
40732: LD_INT 4
40734: PPUSH
40735: CALL_OW 109
// if IsInUnit ( j ) then
40739: LD_VAR 0 5
40743: PPUSH
40744: CALL_OW 310
40748: IFFALSE 40759
// ComExitBuilding ( j ) ;
40750: LD_VAR 0 5
40754: PPUSH
40755: CALL_OW 122
// end else
40759: GO 40812
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40761: LD_VAR 0 5
40765: PPUSH
40766: LD_EXP 35
40770: PUSH
40771: LD_VAR 0 1
40775: ARRAY
40776: PUSH
40777: LD_INT 1
40779: ARRAY
40780: PPUSH
40781: CALL 95191 0 2
40785: NOT
40786: IFFALSE 40812
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40788: LD_VAR 0 5
40792: PPUSH
40793: LD_EXP 35
40797: PUSH
40798: LD_VAR 0 1
40802: ARRAY
40803: PUSH
40804: LD_INT 1
40806: ARRAY
40807: PPUSH
40808: CALL 19237 0 2
// end ;
40812: GO 40708
40814: POP
40815: POP
// end else
40816: GO 41050
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40818: LD_VAR 0 1
40822: PPUSH
40823: LD_INT 4
40825: PPUSH
40826: EMPTY
40827: PPUSH
40828: CALL 11750 0 3
40832: PUSH
40833: LD_VAR 0 1
40837: PPUSH
40838: LD_INT 4
40840: PPUSH
40841: EMPTY
40842: PPUSH
40843: CALL 12370 0 3
40847: AND
40848: IFFALSE 41050
// for j in MCF_Class ( side , 4 , [ ] ) do
40850: LD_ADDR_VAR 0 5
40854: PUSH
40855: LD_VAR 0 1
40859: PPUSH
40860: LD_INT 4
40862: PPUSH
40863: EMPTY
40864: PPUSH
40865: CALL 11750 0 3
40869: PUSH
40870: FOR_IN
40871: IFFALSE 41048
// begin if GetTag ( j ) = 4 then
40873: LD_VAR 0 5
40877: PPUSH
40878: CALL_OW 110
40882: PUSH
40883: LD_INT 4
40885: EQUAL
40886: IFFALSE 41046
// begin SetTag ( j , 0 ) ;
40888: LD_VAR 0 5
40892: PPUSH
40893: LD_INT 0
40895: PPUSH
40896: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40900: LD_VAR 0 1
40904: PPUSH
40905: CALL 11706 0 1
40909: PUSH
40910: LD_VAR 0 1
40914: PPUSH
40915: CALL 18050 0 1
40919: NOT
40920: AND
40921: IFFALSE 40946
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40923: LD_VAR 0 5
40927: PPUSH
40928: LD_VAR 0 1
40932: PPUSH
40933: CALL 11706 0 1
40937: PUSH
40938: LD_INT 1
40940: ARRAY
40941: PPUSH
40942: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40946: LD_VAR 0 1
40950: PPUSH
40951: CALL 11706 0 1
40955: NOT
40956: PUSH
40957: LD_VAR 0 1
40961: PPUSH
40962: LD_INT 30
40964: PUSH
40965: LD_INT 1
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PPUSH
40972: CALL 11667 0 2
40976: AND
40977: IFFALSE 41046
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40979: LD_VAR 0 5
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: LD_INT 30
40991: PUSH
40992: LD_INT 1
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PPUSH
40999: CALL 11667 0 2
41003: PUSH
41004: LD_INT 1
41006: ARRAY
41007: PPUSH
41008: CALL_OW 250
41012: PPUSH
41013: LD_VAR 0 1
41017: PPUSH
41018: LD_INT 30
41020: PUSH
41021: LD_INT 1
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: PPUSH
41028: CALL 11667 0 2
41032: PUSH
41033: LD_INT 1
41035: ARRAY
41036: PPUSH
41037: CALL_OW 251
41041: PPUSH
41042: CALL_OW 111
// end ; end ;
41046: GO 40870
41048: POP
41049: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41050: LD_VAR 0 1
41054: PPUSH
41055: LD_INT 3
41057: PPUSH
41058: EMPTY
41059: PPUSH
41060: CALL 11750 0 3
41064: PUSH
41065: LD_EXP 58
41069: PUSH
41070: LD_VAR 0 1
41074: ARRAY
41075: AND
41076: PUSH
41077: LD_VAR 0 1
41081: PPUSH
41082: LD_INT 6
41084: PPUSH
41085: EMPTY
41086: PPUSH
41087: CALL 12370 0 3
41091: AND
41092: IFFALSE 41623
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41094: LD_ADDR_VAR 0 6
41098: PUSH
41099: LD_EXP 58
41103: PUSH
41104: LD_VAR 0 1
41108: ARRAY
41109: PPUSH
41110: LD_INT 0
41112: PPUSH
41113: CALL_OW 517
41117: PUSH
41118: LD_INT 1
41120: ARRAY
41121: PUSH
41122: LD_INT 1
41124: ARRAY
41125: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41126: LD_ADDR_VAR 0 7
41130: PUSH
41131: LD_EXP 58
41135: PUSH
41136: LD_VAR 0 1
41140: ARRAY
41141: PPUSH
41142: LD_INT 0
41144: PPUSH
41145: CALL_OW 517
41149: PUSH
41150: LD_INT 2
41152: ARRAY
41153: PUSH
41154: LD_INT 1
41156: ARRAY
41157: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41158: LD_VAR 0 1
41162: PPUSH
41163: LD_INT 6
41165: PPUSH
41166: EMPTY
41167: PPUSH
41168: CALL 12370 0 3
41172: IFFALSE 41621
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41174: LD_ADDR_VAR 0 8
41178: PUSH
41179: LD_VAR 0 1
41183: PPUSH
41184: LD_INT 6
41186: PPUSH
41187: EMPTY
41188: PPUSH
41189: CALL 12370 0 3
41193: PUSH
41194: FOR_IN
41195: IFFALSE 41226
// if GetLives ( k ) = 1000 then
41197: LD_VAR 0 8
41201: PPUSH
41202: CALL_OW 256
41206: PUSH
41207: LD_INT 1000
41209: EQUAL
41210: IFFALSE 41224
// SetTag ( k , 0 ) ;
41212: LD_VAR 0 8
41216: PPUSH
41217: LD_INT 0
41219: PPUSH
41220: CALL_OW 109
41224: GO 41194
41226: POP
41227: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41228: LD_VAR 0 1
41232: PPUSH
41233: LD_INT 0
41235: PPUSH
41236: LD_INT 25
41238: PUSH
41239: LD_INT 3
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PPUSH
41246: CALL 12370 0 3
41250: IFFALSE 41314
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41252: LD_ADDR_VAR 0 8
41256: PUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: LD_INT 0
41264: PPUSH
41265: LD_INT 25
41267: PUSH
41268: LD_INT 3
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PPUSH
41275: CALL 12370 0 3
41279: PUSH
41280: FOR_IN
41281: IFFALSE 41312
// if GetTag ( k ) = 0 then
41283: LD_VAR 0 8
41287: PPUSH
41288: CALL_OW 110
41292: PUSH
41293: LD_INT 0
41295: EQUAL
41296: IFFALSE 41310
// begin SetTag ( k , 8 ) ;
41298: LD_VAR 0 8
41302: PPUSH
41303: LD_INT 8
41305: PPUSH
41306: CALL_OW 109
// end ;
41310: GO 41280
41312: POP
41313: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41314: LD_VAR 0 1
41318: PPUSH
41319: LD_INT 6
41321: PPUSH
41322: LD_INT 92
41324: PUSH
41325: LD_VAR 0 6
41329: PUSH
41330: LD_VAR 0 7
41334: PUSH
41335: LD_INT 10
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: PPUSH
41344: CALL 12370 0 3
41348: IFFALSE 41472
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41350: LD_ADDR_VAR 0 5
41354: PUSH
41355: LD_VAR 0 4
41359: PPUSH
41360: LD_INT 6
41362: PPUSH
41363: LD_INT 92
41365: PUSH
41366: LD_VAR 0 6
41370: PUSH
41371: LD_VAR 0 7
41375: PUSH
41376: LD_INT 10
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: LIST
41383: LIST
41384: PPUSH
41385: CALL 12370 0 3
41389: PUSH
41390: FOR_IN
41391: IFFALSE 41470
// begin if not HasTask ( j ) and GetDriver ( j ) then
41393: LD_VAR 0 5
41397: PPUSH
41398: CALL_OW 314
41402: NOT
41403: PUSH
41404: LD_VAR 0 5
41408: PPUSH
41409: CALL 31775 0 1
41413: AND
41414: IFFALSE 41468
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41416: LD_VAR 0 5
41420: PPUSH
41421: CALL 31775 0 1
41425: PPUSH
41426: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31775 0 1
41439: PPUSH
41440: LD_VAR 0 5
41444: PPUSH
41445: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41449: LD_VAR 0 5
41453: PPUSH
41454: CALL 31775 0 1
41458: PPUSH
41459: LD_VAR 0 5
41463: PPUSH
41464: CALL_OW 180
// end ; end ;
41468: GO 41390
41470: POP
41471: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41472: LD_VAR 0 1
41476: PPUSH
41477: LD_INT 6
41479: PPUSH
41480: LD_INT 92
41482: PUSH
41483: LD_VAR 0 6
41487: PUSH
41488: LD_VAR 0 7
41492: PUSH
41493: LD_INT 10
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL 12370 0 3
41506: PUSH
41507: LD_VAR 0 1
41511: PPUSH
41512: LD_INT 8
41514: PPUSH
41515: EMPTY
41516: PPUSH
41517: CALL 12370 0 3
41521: AND
41522: IFFALSE 41621
// for j in MCF_Tag ( side , 8 , [ ] ) do
41524: LD_ADDR_VAR 0 5
41528: PUSH
41529: LD_VAR 0 1
41533: PPUSH
41534: LD_INT 8
41536: PPUSH
41537: EMPTY
41538: PPUSH
41539: CALL 12370 0 3
41543: PUSH
41544: FOR_IN
41545: IFFALSE 41619
// begin if IsInUnit ( j ) then
41547: LD_VAR 0 5
41551: PPUSH
41552: CALL_OW 310
41556: IFFALSE 41569
// ComExitBuilding ( j ) else
41558: LD_VAR 0 5
41562: PPUSH
41563: CALL_OW 122
41567: GO 41617
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41569: LD_VAR 0 5
41573: PPUSH
41574: LD_VAR 0 1
41578: PPUSH
41579: LD_INT 6
41581: PPUSH
41582: LD_INT 92
41584: PUSH
41585: LD_VAR 0 6
41589: PUSH
41590: LD_VAR 0 7
41594: PUSH
41595: LD_INT 10
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: PPUSH
41604: CALL 12370 0 3
41608: PUSH
41609: LD_INT 1
41611: ARRAY
41612: PPUSH
41613: CALL_OW 129
// end ;
41617: GO 41544
41619: POP
41620: POP
// end ; end else
41621: GO 41678
// if MCF_Tag ( side , 8 , [ ] ) then
41623: LD_VAR 0 1
41627: PPUSH
41628: LD_INT 8
41630: PPUSH
41631: EMPTY
41632: PPUSH
41633: CALL 12370 0 3
41637: IFFALSE 41678
// for k in MCF_Tag ( side , 8 , [ ] ) do
41639: LD_ADDR_VAR 0 8
41643: PUSH
41644: LD_VAR 0 1
41648: PPUSH
41649: LD_INT 8
41651: PPUSH
41652: EMPTY
41653: PPUSH
41654: CALL 12370 0 3
41658: PUSH
41659: FOR_IN
41660: IFFALSE 41676
// SetTag ( k , 0 ) ;
41662: LD_VAR 0 8
41666: PPUSH
41667: LD_INT 0
41669: PPUSH
41670: CALL_OW 109
41674: GO 41659
41676: POP
41677: POP
// end ; end_of_file
41678: LD_VAR 0 3
41682: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41683: LD_INT 0
41685: PPUSH
// MREG_Game := [ ] ;
41686: LD_ADDR_EXP 33
41690: PUSH
41691: EMPTY
41692: ST_TO_ADDR
// MREG_Crates := [ ] ;
41693: LD_ADDR_EXP 34
41697: PUSH
41698: EMPTY
41699: ST_TO_ADDR
// MREG_Heal := [ ] ;
41700: LD_ADDR_EXP 35
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Tame := [ ] ;
41707: LD_ADDR_EXP 37
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41714: LD_ADDR_EXP 38
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41721: LD_ADDR_EXP 39
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_LabList := [ ] ;
41728: LD_ADDR_EXP 40
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41735: LD_ADDR_EXP 41
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41742: LD_ADDR_EXP 42
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41749: LD_ADDR_EXP 43
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41756: LD_ADDR_EXP 44
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_Status := [ ] ;
41763: LD_ADDR_EXP 45
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41770: LD_ADDR_EXP 46
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41777: LD_ADDR_EXP 47
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41784: LD_ADDR_EXP 48
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41791: LD_ADDR_EXP 49
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41798: LD_ADDR_EXP 50
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41805: LD_ADDR_EXP 51
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41812: LD_ADDR_EXP 52
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41819: LD_ADDR_EXP 53
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41826: LD_ADDR_EXP 54
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41833: LD_ADDR_EXP 55
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41840: LD_ADDR_EXP 56
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41847: LD_ADDR_EXP 57
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41854: LD_ADDR_EXP 61
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41861: LD_ADDR_EXP 62
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Parking := [ ] ;
41868: LD_ADDR_EXP 58
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41875: LD_ADDR_EXP 59
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41882: LD_ADDR_EXP 63
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41889: LD_ADDR_EXP 64
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41896: LD_ADDR_EXP 65
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41903: LD_ADDR_EXP 67
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41910: LD_ADDR_EXP 68
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41917: LD_ADDR_EXP 69
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41924: LD_ADDR_EXP 71
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41931: LD_ADDR_EXP 70
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41938: LD_ADDR_EXP 72
41942: PUSH
41943: LD_INT 300
41945: PUSH
41946: LD_INT 100
41948: PUSH
41949: LD_INT 25
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: LIST
41956: ST_TO_ADDR
// end ;
41957: LD_VAR 0 1
41961: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41962: LD_INT 0
41964: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41965: LD_VAR 0 2
41969: PUSH
41970: LD_VAR 0 3
41974: PUSH
41975: LD_VAR 0 4
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: LD_VAR 0 1
41989: IN
41990: IFFALSE 42004
// result := mreg_list else
41992: LD_ADDR_VAR 0 5
41996: PUSH
41997: LD_VAR 0 1
42001: ST_TO_ADDR
42002: GO 42038
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42004: LD_ADDR_VAR 0 1
42008: PUSH
42009: LD_VAR 0 1
42013: PUSH
42014: LD_VAR 0 2
42018: PUSH
42019: LD_VAR 0 3
42023: PUSH
42024: LD_VAR 0 4
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: LIST
42033: PUSH
42034: EMPTY
42035: LIST
42036: ADD
42037: ST_TO_ADDR
// result := mreg_list ;
42038: LD_ADDR_VAR 0 5
42042: PUSH
42043: LD_VAR 0 1
42047: ST_TO_ADDR
// end ;
42048: LD_VAR 0 5
42052: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42053: LD_INT 0
42055: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42056: LD_VAR 0 2
42060: PUSH
42061: LD_VAR 0 3
42065: PUSH
42066: LD_VAR 0 4
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: LIST
42075: PUSH
42076: LD_VAR 0 1
42080: IN
42081: IFFALSE 42119
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42083: LD_ADDR_VAR 0 5
42087: PUSH
42088: LD_VAR 0 1
42092: PUSH
42093: LD_VAR 0 2
42097: PUSH
42098: LD_VAR 0 3
42102: PUSH
42103: LD_VAR 0 4
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: LIST
42112: PUSH
42113: EMPTY
42114: LIST
42115: DIFF
42116: ST_TO_ADDR
42117: GO 42129
// result := mreg_list ;
42119: LD_ADDR_VAR 0 5
42123: PUSH
42124: LD_VAR 0 1
42128: ST_TO_ADDR
// end ;
42129: LD_VAR 0 5
42133: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42134: LD_INT 0
42136: PPUSH
42137: PPUSH
42138: PPUSH
// for j = 1 to 8 do
42139: LD_ADDR_VAR 0 3
42143: PUSH
42144: DOUBLE
42145: LD_INT 1
42147: DEC
42148: ST_TO_ADDR
42149: LD_INT 8
42151: PUSH
42152: FOR_TO
42153: IFFALSE 42994
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42155: LD_VAR 0 3
42159: PPUSH
42160: LD_INT 51
42162: PUSH
42163: EMPTY
42164: LIST
42165: PPUSH
42166: CALL 11667 0 2
42170: PUSH
42171: LD_OWVAR 2
42175: PUSH
42176: LD_VAR 0 3
42180: EQUAL
42181: NOT
42182: AND
42183: IFFALSE 42201
// MREG_SidesList := MREG_SidesList ^ 1 else
42185: LD_ADDR_EXP 39
42189: PUSH
42190: LD_EXP 39
42194: PUSH
42195: LD_INT 1
42197: ADD
42198: ST_TO_ADDR
42199: GO 42215
// MREG_SidesList := MREG_SidesList ^ 0 ;
42201: LD_ADDR_EXP 39
42205: PUSH
42206: LD_EXP 39
42210: PUSH
42211: LD_INT 0
42213: ADD
42214: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42215: LD_VAR 0 3
42219: PPUSH
42220: LD_INT 2
42222: PUSH
42223: LD_INT 34
42225: PUSH
42226: LD_INT 12
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 34
42235: PUSH
42236: LD_INT 32
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 34
42245: PUSH
42246: LD_INT 51
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: PUSH
42259: EMPTY
42260: LIST
42261: PPUSH
42262: CALL 11968 0 2
42266: IFFALSE 42367
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42268: LD_ADDR_VAR 0 2
42272: PUSH
42273: LD_VAR 0 3
42277: PPUSH
42278: LD_INT 2
42280: PUSH
42281: LD_INT 34
42283: PUSH
42284: LD_INT 12
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 34
42293: PUSH
42294: LD_INT 32
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 34
42303: PUSH
42304: LD_INT 51
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: LIST
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: CALL 11968 0 2
42324: PUSH
42325: FOR_IN
42326: IFFALSE 42365
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42328: LD_ADDR_EXP 41
42332: PUSH
42333: LD_EXP 41
42337: PPUSH
42338: LD_VAR 0 3
42342: PPUSH
42343: LD_VAR 0 2
42347: PPUSH
42348: LD_VAR 0 2
42352: PPUSH
42353: CALL_OW 264
42357: PPUSH
42358: CALL 41962 0 4
42362: ST_TO_ADDR
42363: GO 42325
42365: POP
42366: POP
// if MCF_Class ( j , 4 , [ ] ) then
42367: LD_VAR 0 3
42371: PPUSH
42372: LD_INT 4
42374: PPUSH
42375: EMPTY
42376: PPUSH
42377: CALL 11750 0 3
42381: IFFALSE 42414
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42383: LD_ADDR_EXP 54
42387: PUSH
42388: LD_EXP 54
42392: PUSH
42393: LD_VAR 0 3
42397: PPUSH
42398: LD_INT 4
42400: PPUSH
42401: EMPTY
42402: PPUSH
42403: CALL 11750 0 3
42407: PUSH
42408: EMPTY
42409: LIST
42410: ADD
42411: ST_TO_ADDR
42412: GO 42431
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42414: LD_ADDR_EXP 54
42418: PUSH
42419: LD_EXP 54
42423: PUSH
42424: LD_INT 0
42426: PUSH
42427: EMPTY
42428: LIST
42429: ADD
42430: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42431: LD_VAR 0 3
42435: PPUSH
42436: LD_INT 3
42438: PPUSH
42439: EMPTY
42440: PPUSH
42441: CALL 11750 0 3
42445: IFFALSE 42478
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42447: LD_ADDR_EXP 55
42451: PUSH
42452: LD_EXP 55
42456: PUSH
42457: LD_VAR 0 3
42461: PPUSH
42462: LD_INT 3
42464: PPUSH
42465: EMPTY
42466: PPUSH
42467: CALL 11750 0 3
42471: PUSH
42472: EMPTY
42473: LIST
42474: ADD
42475: ST_TO_ADDR
42476: GO 42495
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42478: LD_ADDR_EXP 55
42482: PUSH
42483: LD_EXP 55
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: EMPTY
42492: LIST
42493: ADD
42494: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42495: LD_VAR 0 3
42499: PPUSH
42500: LD_INT 1
42502: PPUSH
42503: EMPTY
42504: PPUSH
42505: CALL 11750 0 3
42509: IFFALSE 42542
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42511: LD_ADDR_EXP 56
42515: PUSH
42516: LD_EXP 56
42520: PUSH
42521: LD_VAR 0 3
42525: PPUSH
42526: LD_INT 1
42528: PPUSH
42529: EMPTY
42530: PPUSH
42531: CALL 11750 0 3
42535: PUSH
42536: EMPTY
42537: LIST
42538: ADD
42539: ST_TO_ADDR
42540: GO 42559
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42542: LD_ADDR_EXP 56
42546: PUSH
42547: LD_EXP 56
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: ADD
42558: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42559: LD_VAR 0 3
42563: PPUSH
42564: LD_INT 2
42566: PPUSH
42567: EMPTY
42568: PPUSH
42569: CALL 11750 0 3
42573: IFFALSE 42606
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42575: LD_ADDR_EXP 57
42579: PUSH
42580: LD_EXP 57
42584: PUSH
42585: LD_VAR 0 3
42589: PPUSH
42590: LD_INT 2
42592: PPUSH
42593: EMPTY
42594: PPUSH
42595: CALL 11750 0 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: ADD
42603: ST_TO_ADDR
42604: GO 42623
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42606: LD_ADDR_EXP 57
42610: PUSH
42611: LD_EXP 57
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: EMPTY
42620: LIST
42621: ADD
42622: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42623: LD_ADDR_EXP 47
42627: PUSH
42628: LD_EXP 47
42632: PUSH
42633: LD_INT 0
42635: PUSH
42636: EMPTY
42637: LIST
42638: ADD
42639: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42640: LD_ADDR_EXP 35
42644: PUSH
42645: LD_EXP 35
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: EMPTY
42654: LIST
42655: ADD
42656: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42657: LD_ADDR_EXP 37
42661: PUSH
42662: LD_EXP 37
42666: PUSH
42667: LD_INT 0
42669: PUSH
42670: EMPTY
42671: LIST
42672: ADD
42673: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42674: LD_ADDR_EXP 58
42678: PUSH
42679: LD_EXP 58
42683: PUSH
42684: LD_INT 0
42686: PUSH
42687: EMPTY
42688: LIST
42689: ADD
42690: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42691: LD_ADDR_EXP 59
42695: PUSH
42696: LD_EXP 59
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: ADD
42707: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42708: LD_ADDR_EXP 51
42712: PUSH
42713: LD_EXP 51
42717: PUSH
42718: LD_INT 0
42720: PUSH
42721: EMPTY
42722: LIST
42723: ADD
42724: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42725: LD_ADDR_EXP 38
42729: PUSH
42730: LD_EXP 38
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: LD_INT 0
42740: PUSH
42741: LD_INT 0
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: PUSH
42753: EMPTY
42754: LIST
42755: ADD
42756: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42757: LD_ADDR_EXP 60
42761: PUSH
42762: LD_EXP 60
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: EMPTY
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: EMPTY
42777: LIST
42778: ADD
42779: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42780: LD_ADDR_EXP 61
42784: PUSH
42785: LD_EXP 61
42789: PUSH
42790: LD_INT 0
42792: PUSH
42793: EMPTY
42794: LIST
42795: PUSH
42796: EMPTY
42797: LIST
42798: ADD
42799: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42800: LD_ADDR_EXP 42
42804: PUSH
42805: LD_EXP 42
42809: PUSH
42810: LD_INT 0
42812: PUSH
42813: EMPTY
42814: LIST
42815: ADD
42816: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42817: LD_ADDR_EXP 63
42821: PUSH
42822: LD_EXP 63
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: EMPTY
42831: LIST
42832: ADD
42833: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42834: LD_ADDR_EXP 64
42838: PUSH
42839: LD_EXP 64
42843: PUSH
42844: LD_INT 0
42846: PUSH
42847: EMPTY
42848: LIST
42849: ADD
42850: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42851: LD_ADDR_EXP 65
42855: PUSH
42856: LD_EXP 65
42860: PUSH
42861: LD_INT 0
42863: PUSH
42864: EMPTY
42865: LIST
42866: ADD
42867: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42868: LD_ADDR_EXP 66
42872: PUSH
42873: LD_EXP 66
42877: PUSH
42878: LD_INT 0
42880: PUSH
42881: EMPTY
42882: LIST
42883: ADD
42884: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42885: LD_ADDR_EXP 67
42889: PUSH
42890: LD_EXP 67
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: EMPTY
42899: LIST
42900: ADD
42901: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42902: LD_ADDR_EXP 68
42906: PUSH
42907: LD_EXP 68
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: EMPTY
42916: LIST
42917: ADD
42918: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42919: LD_ADDR_EXP 69
42923: PUSH
42924: LD_EXP 69
42928: PUSH
42929: LD_INT 0
42931: PUSH
42932: EMPTY
42933: LIST
42934: ADD
42935: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42936: LD_ADDR_EXP 71
42940: PUSH
42941: LD_EXP 71
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: EMPTY
42950: LIST
42951: ADD
42952: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42953: LD_ADDR_EXP 70
42957: PUSH
42958: LD_EXP 70
42962: PUSH
42963: LD_INT 0
42965: ADD
42966: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42967: LD_ADDR_EXP 62
42971: PUSH
42972: LD_EXP 62
42976: PUSH
42977: LD_INT 0
42979: PUSH
42980: LD_INT 0
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: LIST
42990: ADD
42991: ST_TO_ADDR
// end ;
42992: GO 42152
42994: POP
42995: POP
// end ;
42996: LD_VAR 0 1
43000: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43001: LD_INT 0
43003: PPUSH
43004: PPUSH
43005: PPUSH
// m := false ;
43006: LD_ADDR_VAR 0 5
43010: PUSH
43011: LD_INT 0
43013: ST_TO_ADDR
// for i = 1 to mreg do
43014: LD_ADDR_VAR 0 4
43018: PUSH
43019: DOUBLE
43020: LD_INT 1
43022: DEC
43023: ST_TO_ADDR
43024: LD_VAR 0 2
43028: PUSH
43029: FOR_TO
43030: IFFALSE 43066
// if mreg [ i ] [ 1 ] = side then
43032: LD_VAR 0 2
43036: PUSH
43037: LD_VAR 0 4
43041: ARRAY
43042: PUSH
43043: LD_INT 1
43045: ARRAY
43046: PUSH
43047: LD_VAR 0 1
43051: EQUAL
43052: IFFALSE 43064
// begin m := true ;
43054: LD_ADDR_VAR 0 5
43058: PUSH
43059: LD_INT 1
43061: ST_TO_ADDR
// break ;
43062: GO 43066
// end ;
43064: GO 43029
43066: POP
43067: POP
// result := m ;
43068: LD_ADDR_VAR 0 3
43072: PUSH
43073: LD_VAR 0 5
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43083: LD_INT 0
43085: PPUSH
43086: PPUSH
43087: PPUSH
// m := 0 ;
43088: LD_ADDR_VAR 0 5
43092: PUSH
43093: LD_INT 0
43095: ST_TO_ADDR
// for i = 1 to mreg do
43096: LD_ADDR_VAR 0 4
43100: PUSH
43101: DOUBLE
43102: LD_INT 1
43104: DEC
43105: ST_TO_ADDR
43106: LD_VAR 0 2
43110: PUSH
43111: FOR_TO
43112: IFFALSE 43152
// if mreg [ i ] [ 1 ] = side then
43114: LD_VAR 0 2
43118: PUSH
43119: LD_VAR 0 4
43123: ARRAY
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: PUSH
43129: LD_VAR 0 1
43133: EQUAL
43134: IFFALSE 43150
// begin m := m + 1 ;
43136: LD_ADDR_VAR 0 5
43140: PUSH
43141: LD_VAR 0 5
43145: PUSH
43146: LD_INT 1
43148: PLUS
43149: ST_TO_ADDR
// end ;
43150: GO 43111
43152: POP
43153: POP
// result := m ;
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_VAR 0 5
43163: ST_TO_ADDR
// end ;
43164: LD_VAR 0 3
43168: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43169: LD_INT 0
43171: PPUSH
43172: PPUSH
// result := 0 ;
43173: LD_ADDR_VAR 0 3
43177: PUSH
43178: LD_INT 0
43180: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43181: LD_ADDR_VAR 0 4
43185: PUSH
43186: DOUBLE
43187: LD_INT 1
43189: DEC
43190: ST_TO_ADDR
43191: LD_EXP 53
43195: PUSH
43196: FOR_TO
43197: IFFALSE 43259
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43199: LD_EXP 53
43203: PUSH
43204: LD_VAR 0 4
43208: ARRAY
43209: PUSH
43210: LD_INT 1
43212: ARRAY
43213: PUSH
43214: LD_VAR 0 1
43218: EQUAL
43219: PUSH
43220: LD_EXP 53
43224: PUSH
43225: LD_VAR 0 4
43229: ARRAY
43230: PUSH
43231: LD_INT 2
43233: ARRAY
43234: PUSH
43235: LD_VAR 0 2
43239: EQUAL
43240: AND
43241: IFFALSE 43257
// begin result := result + 1 ;
43243: LD_ADDR_VAR 0 3
43247: PUSH
43248: LD_VAR 0 3
43252: PUSH
43253: LD_INT 1
43255: PLUS
43256: ST_TO_ADDR
// end ;
43257: GO 43196
43259: POP
43260: POP
// end ; end_of_file
43261: LD_VAR 0 3
43265: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
43266: LD_INT 0
43268: PPUSH
// ar_miner := 81 ;
43269: LD_ADDR_EXP 80
43273: PUSH
43274: LD_INT 81
43276: ST_TO_ADDR
// ar_crane := 88 ;
43277: LD_ADDR_EXP 79
43281: PUSH
43282: LD_INT 88
43284: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43285: LD_ADDR_EXP 74
43289: PUSH
43290: LD_INT 89
43292: ST_TO_ADDR
// us_hack := 99 ;
43293: LD_ADDR_EXP 75
43297: PUSH
43298: LD_INT 99
43300: ST_TO_ADDR
// us_artillery := 97 ;
43301: LD_ADDR_EXP 76
43305: PUSH
43306: LD_INT 97
43308: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43309: LD_ADDR_EXP 77
43313: PUSH
43314: LD_INT 91
43316: ST_TO_ADDR
// ar_mortar := 92 ;
43317: LD_ADDR_EXP 78
43321: PUSH
43322: LD_INT 92
43324: ST_TO_ADDR
// ru_radar := 98 ;
43325: LD_ADDR_EXP 73
43329: PUSH
43330: LD_INT 98
43332: ST_TO_ADDR
// tech_Artillery := 80 ;
43333: LD_ADDR_EXP 81
43337: PUSH
43338: LD_INT 80
43340: ST_TO_ADDR
// tech_RadMat := 81 ;
43341: LD_ADDR_EXP 82
43345: PUSH
43346: LD_INT 81
43348: ST_TO_ADDR
// tech_BasicTools := 82 ;
43349: LD_ADDR_EXP 83
43353: PUSH
43354: LD_INT 82
43356: ST_TO_ADDR
// tech_Cargo := 83 ;
43357: LD_ADDR_EXP 84
43361: PUSH
43362: LD_INT 83
43364: ST_TO_ADDR
// tech_Track := 84 ;
43365: LD_ADDR_EXP 85
43369: PUSH
43370: LD_INT 84
43372: ST_TO_ADDR
// tech_Crane := 85 ;
43373: LD_ADDR_EXP 86
43377: PUSH
43378: LD_INT 85
43380: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43381: LD_ADDR_EXP 87
43385: PUSH
43386: LD_INT 86
43388: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43389: LD_ADDR_EXP 88
43393: PUSH
43394: LD_INT 87
43396: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43397: LD_ADDR_EXP 89
43401: PUSH
43402: LD_INT 88
43404: ST_TO_ADDR
// class_mastodont := 31 ;
43405: LD_ADDR_EXP 90
43409: PUSH
43410: LD_INT 31
43412: ST_TO_ADDR
// class_horse := 21 ;
43413: LD_ADDR_EXP 91
43417: PUSH
43418: LD_INT 21
43420: ST_TO_ADDR
// end ;
43421: LD_VAR 0 1
43425: RET
// every 1 do
43426: GO 43428
43428: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43429: CALL 43266 0 0
43433: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43434: LD_INT 0
43436: PPUSH
// if p2 = 100 then
43437: LD_VAR 0 2
43441: PUSH
43442: LD_INT 100
43444: EQUAL
43445: IFFALSE 44448
// begin if not StreamModeActive then
43447: LD_EXP 92
43451: NOT
43452: IFFALSE 43462
// StreamModeActive := true ;
43454: LD_ADDR_EXP 92
43458: PUSH
43459: LD_INT 1
43461: ST_TO_ADDR
// if p3 = 0 then
43462: LD_VAR 0 3
43466: PUSH
43467: LD_INT 0
43469: EQUAL
43470: IFFALSE 43476
// InitStreamMode ;
43472: CALL 44608 0 0
// if p3 = 1 then
43476: LD_VAR 0 3
43480: PUSH
43481: LD_INT 1
43483: EQUAL
43484: IFFALSE 43494
// sRocket := true ;
43486: LD_ADDR_EXP 97
43490: PUSH
43491: LD_INT 1
43493: ST_TO_ADDR
// if p3 = 2 then
43494: LD_VAR 0 3
43498: PUSH
43499: LD_INT 2
43501: EQUAL
43502: IFFALSE 43512
// sSpeed := true ;
43504: LD_ADDR_EXP 96
43508: PUSH
43509: LD_INT 1
43511: ST_TO_ADDR
// if p3 = 3 then
43512: LD_VAR 0 3
43516: PUSH
43517: LD_INT 3
43519: EQUAL
43520: IFFALSE 43530
// sEngine := true ;
43522: LD_ADDR_EXP 98
43526: PUSH
43527: LD_INT 1
43529: ST_TO_ADDR
// if p3 = 4 then
43530: LD_VAR 0 3
43534: PUSH
43535: LD_INT 4
43537: EQUAL
43538: IFFALSE 43548
// sSpec := true ;
43540: LD_ADDR_EXP 95
43544: PUSH
43545: LD_INT 1
43547: ST_TO_ADDR
// if p3 = 5 then
43548: LD_VAR 0 3
43552: PUSH
43553: LD_INT 5
43555: EQUAL
43556: IFFALSE 43566
// sLevel := true ;
43558: LD_ADDR_EXP 99
43562: PUSH
43563: LD_INT 1
43565: ST_TO_ADDR
// if p3 = 6 then
43566: LD_VAR 0 3
43570: PUSH
43571: LD_INT 6
43573: EQUAL
43574: IFFALSE 43584
// sArmoury := true ;
43576: LD_ADDR_EXP 100
43580: PUSH
43581: LD_INT 1
43583: ST_TO_ADDR
// if p3 = 7 then
43584: LD_VAR 0 3
43588: PUSH
43589: LD_INT 7
43591: EQUAL
43592: IFFALSE 43602
// sRadar := true ;
43594: LD_ADDR_EXP 101
43598: PUSH
43599: LD_INT 1
43601: ST_TO_ADDR
// if p3 = 8 then
43602: LD_VAR 0 3
43606: PUSH
43607: LD_INT 8
43609: EQUAL
43610: IFFALSE 43620
// sBunker := true ;
43612: LD_ADDR_EXP 102
43616: PUSH
43617: LD_INT 1
43619: ST_TO_ADDR
// if p3 = 9 then
43620: LD_VAR 0 3
43624: PUSH
43625: LD_INT 9
43627: EQUAL
43628: IFFALSE 43638
// sHack := true ;
43630: LD_ADDR_EXP 103
43634: PUSH
43635: LD_INT 1
43637: ST_TO_ADDR
// if p3 = 10 then
43638: LD_VAR 0 3
43642: PUSH
43643: LD_INT 10
43645: EQUAL
43646: IFFALSE 43656
// sFire := true ;
43648: LD_ADDR_EXP 104
43652: PUSH
43653: LD_INT 1
43655: ST_TO_ADDR
// if p3 = 11 then
43656: LD_VAR 0 3
43660: PUSH
43661: LD_INT 11
43663: EQUAL
43664: IFFALSE 43674
// sRefresh := true ;
43666: LD_ADDR_EXP 105
43670: PUSH
43671: LD_INT 1
43673: ST_TO_ADDR
// if p3 = 12 then
43674: LD_VAR 0 3
43678: PUSH
43679: LD_INT 12
43681: EQUAL
43682: IFFALSE 43692
// sExp := true ;
43684: LD_ADDR_EXP 106
43688: PUSH
43689: LD_INT 1
43691: ST_TO_ADDR
// if p3 = 13 then
43692: LD_VAR 0 3
43696: PUSH
43697: LD_INT 13
43699: EQUAL
43700: IFFALSE 43710
// sDepot := true ;
43702: LD_ADDR_EXP 107
43706: PUSH
43707: LD_INT 1
43709: ST_TO_ADDR
// if p3 = 14 then
43710: LD_VAR 0 3
43714: PUSH
43715: LD_INT 14
43717: EQUAL
43718: IFFALSE 43728
// sFlag := true ;
43720: LD_ADDR_EXP 108
43724: PUSH
43725: LD_INT 1
43727: ST_TO_ADDR
// if p3 = 15 then
43728: LD_VAR 0 3
43732: PUSH
43733: LD_INT 15
43735: EQUAL
43736: IFFALSE 43746
// sKamikadze := true ;
43738: LD_ADDR_EXP 116
43742: PUSH
43743: LD_INT 1
43745: ST_TO_ADDR
// if p3 = 16 then
43746: LD_VAR 0 3
43750: PUSH
43751: LD_INT 16
43753: EQUAL
43754: IFFALSE 43764
// sTroll := true ;
43756: LD_ADDR_EXP 117
43760: PUSH
43761: LD_INT 1
43763: ST_TO_ADDR
// if p3 = 17 then
43764: LD_VAR 0 3
43768: PUSH
43769: LD_INT 17
43771: EQUAL
43772: IFFALSE 43782
// sSlow := true ;
43774: LD_ADDR_EXP 118
43778: PUSH
43779: LD_INT 1
43781: ST_TO_ADDR
// if p3 = 18 then
43782: LD_VAR 0 3
43786: PUSH
43787: LD_INT 18
43789: EQUAL
43790: IFFALSE 43800
// sLack := true ;
43792: LD_ADDR_EXP 119
43796: PUSH
43797: LD_INT 1
43799: ST_TO_ADDR
// if p3 = 19 then
43800: LD_VAR 0 3
43804: PUSH
43805: LD_INT 19
43807: EQUAL
43808: IFFALSE 43818
// sTank := true ;
43810: LD_ADDR_EXP 121
43814: PUSH
43815: LD_INT 1
43817: ST_TO_ADDR
// if p3 = 20 then
43818: LD_VAR 0 3
43822: PUSH
43823: LD_INT 20
43825: EQUAL
43826: IFFALSE 43836
// sRemote := true ;
43828: LD_ADDR_EXP 122
43832: PUSH
43833: LD_INT 1
43835: ST_TO_ADDR
// if p3 = 21 then
43836: LD_VAR 0 3
43840: PUSH
43841: LD_INT 21
43843: EQUAL
43844: IFFALSE 43854
// sPowell := true ;
43846: LD_ADDR_EXP 123
43850: PUSH
43851: LD_INT 1
43853: ST_TO_ADDR
// if p3 = 22 then
43854: LD_VAR 0 3
43858: PUSH
43859: LD_INT 22
43861: EQUAL
43862: IFFALSE 43872
// sTeleport := true ;
43864: LD_ADDR_EXP 126
43868: PUSH
43869: LD_INT 1
43871: ST_TO_ADDR
// if p3 = 23 then
43872: LD_VAR 0 3
43876: PUSH
43877: LD_INT 23
43879: EQUAL
43880: IFFALSE 43890
// sOilTower := true ;
43882: LD_ADDR_EXP 128
43886: PUSH
43887: LD_INT 1
43889: ST_TO_ADDR
// if p3 = 24 then
43890: LD_VAR 0 3
43894: PUSH
43895: LD_INT 24
43897: EQUAL
43898: IFFALSE 43908
// sShovel := true ;
43900: LD_ADDR_EXP 129
43904: PUSH
43905: LD_INT 1
43907: ST_TO_ADDR
// if p3 = 25 then
43908: LD_VAR 0 3
43912: PUSH
43913: LD_INT 25
43915: EQUAL
43916: IFFALSE 43926
// sSheik := true ;
43918: LD_ADDR_EXP 130
43922: PUSH
43923: LD_INT 1
43925: ST_TO_ADDR
// if p3 = 26 then
43926: LD_VAR 0 3
43930: PUSH
43931: LD_INT 26
43933: EQUAL
43934: IFFALSE 43944
// sEarthquake := true ;
43936: LD_ADDR_EXP 132
43940: PUSH
43941: LD_INT 1
43943: ST_TO_ADDR
// if p3 = 27 then
43944: LD_VAR 0 3
43948: PUSH
43949: LD_INT 27
43951: EQUAL
43952: IFFALSE 43962
// sAI := true ;
43954: LD_ADDR_EXP 133
43958: PUSH
43959: LD_INT 1
43961: ST_TO_ADDR
// if p3 = 28 then
43962: LD_VAR 0 3
43966: PUSH
43967: LD_INT 28
43969: EQUAL
43970: IFFALSE 43980
// sCargo := true ;
43972: LD_ADDR_EXP 136
43976: PUSH
43977: LD_INT 1
43979: ST_TO_ADDR
// if p3 = 29 then
43980: LD_VAR 0 3
43984: PUSH
43985: LD_INT 29
43987: EQUAL
43988: IFFALSE 43998
// sDLaser := true ;
43990: LD_ADDR_EXP 137
43994: PUSH
43995: LD_INT 1
43997: ST_TO_ADDR
// if p3 = 30 then
43998: LD_VAR 0 3
44002: PUSH
44003: LD_INT 30
44005: EQUAL
44006: IFFALSE 44016
// sExchange := true ;
44008: LD_ADDR_EXP 138
44012: PUSH
44013: LD_INT 1
44015: ST_TO_ADDR
// if p3 = 31 then
44016: LD_VAR 0 3
44020: PUSH
44021: LD_INT 31
44023: EQUAL
44024: IFFALSE 44034
// sFac := true ;
44026: LD_ADDR_EXP 139
44030: PUSH
44031: LD_INT 1
44033: ST_TO_ADDR
// if p3 = 32 then
44034: LD_VAR 0 3
44038: PUSH
44039: LD_INT 32
44041: EQUAL
44042: IFFALSE 44052
// sPower := true ;
44044: LD_ADDR_EXP 140
44048: PUSH
44049: LD_INT 1
44051: ST_TO_ADDR
// if p3 = 33 then
44052: LD_VAR 0 3
44056: PUSH
44057: LD_INT 33
44059: EQUAL
44060: IFFALSE 44070
// sRandom := true ;
44062: LD_ADDR_EXP 141
44066: PUSH
44067: LD_INT 1
44069: ST_TO_ADDR
// if p3 = 34 then
44070: LD_VAR 0 3
44074: PUSH
44075: LD_INT 34
44077: EQUAL
44078: IFFALSE 44088
// sShield := true ;
44080: LD_ADDR_EXP 142
44084: PUSH
44085: LD_INT 1
44087: ST_TO_ADDR
// if p3 = 35 then
44088: LD_VAR 0 3
44092: PUSH
44093: LD_INT 35
44095: EQUAL
44096: IFFALSE 44106
// sTime := true ;
44098: LD_ADDR_EXP 143
44102: PUSH
44103: LD_INT 1
44105: ST_TO_ADDR
// if p3 = 36 then
44106: LD_VAR 0 3
44110: PUSH
44111: LD_INT 36
44113: EQUAL
44114: IFFALSE 44124
// sTools := true ;
44116: LD_ADDR_EXP 144
44120: PUSH
44121: LD_INT 1
44123: ST_TO_ADDR
// if p3 = 101 then
44124: LD_VAR 0 3
44128: PUSH
44129: LD_INT 101
44131: EQUAL
44132: IFFALSE 44142
// sSold := true ;
44134: LD_ADDR_EXP 109
44138: PUSH
44139: LD_INT 1
44141: ST_TO_ADDR
// if p3 = 102 then
44142: LD_VAR 0 3
44146: PUSH
44147: LD_INT 102
44149: EQUAL
44150: IFFALSE 44160
// sDiff := true ;
44152: LD_ADDR_EXP 110
44156: PUSH
44157: LD_INT 1
44159: ST_TO_ADDR
// if p3 = 103 then
44160: LD_VAR 0 3
44164: PUSH
44165: LD_INT 103
44167: EQUAL
44168: IFFALSE 44178
// sFog := true ;
44170: LD_ADDR_EXP 113
44174: PUSH
44175: LD_INT 1
44177: ST_TO_ADDR
// if p3 = 104 then
44178: LD_VAR 0 3
44182: PUSH
44183: LD_INT 104
44185: EQUAL
44186: IFFALSE 44196
// sReset := true ;
44188: LD_ADDR_EXP 114
44192: PUSH
44193: LD_INT 1
44195: ST_TO_ADDR
// if p3 = 105 then
44196: LD_VAR 0 3
44200: PUSH
44201: LD_INT 105
44203: EQUAL
44204: IFFALSE 44214
// sSun := true ;
44206: LD_ADDR_EXP 115
44210: PUSH
44211: LD_INT 1
44213: ST_TO_ADDR
// if p3 = 106 then
44214: LD_VAR 0 3
44218: PUSH
44219: LD_INT 106
44221: EQUAL
44222: IFFALSE 44232
// sTiger := true ;
44224: LD_ADDR_EXP 111
44228: PUSH
44229: LD_INT 1
44231: ST_TO_ADDR
// if p3 = 107 then
44232: LD_VAR 0 3
44236: PUSH
44237: LD_INT 107
44239: EQUAL
44240: IFFALSE 44250
// sBomb := true ;
44242: LD_ADDR_EXP 112
44246: PUSH
44247: LD_INT 1
44249: ST_TO_ADDR
// if p3 = 108 then
44250: LD_VAR 0 3
44254: PUSH
44255: LD_INT 108
44257: EQUAL
44258: IFFALSE 44268
// sWound := true ;
44260: LD_ADDR_EXP 120
44264: PUSH
44265: LD_INT 1
44267: ST_TO_ADDR
// if p3 = 109 then
44268: LD_VAR 0 3
44272: PUSH
44273: LD_INT 109
44275: EQUAL
44276: IFFALSE 44286
// sBetray := true ;
44278: LD_ADDR_EXP 124
44282: PUSH
44283: LD_INT 1
44285: ST_TO_ADDR
// if p3 = 110 then
44286: LD_VAR 0 3
44290: PUSH
44291: LD_INT 110
44293: EQUAL
44294: IFFALSE 44304
// sContamin := true ;
44296: LD_ADDR_EXP 125
44300: PUSH
44301: LD_INT 1
44303: ST_TO_ADDR
// if p3 = 111 then
44304: LD_VAR 0 3
44308: PUSH
44309: LD_INT 111
44311: EQUAL
44312: IFFALSE 44322
// sOil := true ;
44314: LD_ADDR_EXP 127
44318: PUSH
44319: LD_INT 1
44321: ST_TO_ADDR
// if p3 = 112 then
44322: LD_VAR 0 3
44326: PUSH
44327: LD_INT 112
44329: EQUAL
44330: IFFALSE 44340
// sStu := true ;
44332: LD_ADDR_EXP 131
44336: PUSH
44337: LD_INT 1
44339: ST_TO_ADDR
// if p3 = 113 then
44340: LD_VAR 0 3
44344: PUSH
44345: LD_INT 113
44347: EQUAL
44348: IFFALSE 44358
// sBazooka := true ;
44350: LD_ADDR_EXP 134
44354: PUSH
44355: LD_INT 1
44357: ST_TO_ADDR
// if p3 = 114 then
44358: LD_VAR 0 3
44362: PUSH
44363: LD_INT 114
44365: EQUAL
44366: IFFALSE 44376
// sMortar := true ;
44368: LD_ADDR_EXP 135
44372: PUSH
44373: LD_INT 1
44375: ST_TO_ADDR
// if p3 = 115 then
44376: LD_VAR 0 3
44380: PUSH
44381: LD_INT 115
44383: EQUAL
44384: IFFALSE 44394
// sRanger := true ;
44386: LD_ADDR_EXP 145
44390: PUSH
44391: LD_INT 1
44393: ST_TO_ADDR
// if p3 = 116 then
44394: LD_VAR 0 3
44398: PUSH
44399: LD_INT 116
44401: EQUAL
44402: IFFALSE 44412
// sComputer := true ;
44404: LD_ADDR_EXP 146
44408: PUSH
44409: LD_INT 1
44411: ST_TO_ADDR
// if p3 = 117 then
44412: LD_VAR 0 3
44416: PUSH
44417: LD_INT 117
44419: EQUAL
44420: IFFALSE 44430
// s30 := true ;
44422: LD_ADDR_EXP 147
44426: PUSH
44427: LD_INT 1
44429: ST_TO_ADDR
// if p3 = 118 then
44430: LD_VAR 0 3
44434: PUSH
44435: LD_INT 118
44437: EQUAL
44438: IFFALSE 44448
// s60 := true ;
44440: LD_ADDR_EXP 148
44444: PUSH
44445: LD_INT 1
44447: ST_TO_ADDR
// end ; if p2 = 101 then
44448: LD_VAR 0 2
44452: PUSH
44453: LD_INT 101
44455: EQUAL
44456: IFFALSE 44584
// begin case p3 of 1 :
44458: LD_VAR 0 3
44462: PUSH
44463: LD_INT 1
44465: DOUBLE
44466: EQUAL
44467: IFTRUE 44471
44469: GO 44478
44471: POP
// hHackUnlimitedResources ; 2 :
44472: CALL 56180 0 0
44476: GO 44584
44478: LD_INT 2
44480: DOUBLE
44481: EQUAL
44482: IFTRUE 44486
44484: GO 44493
44486: POP
// hHackSetLevel10 ; 3 :
44487: CALL 56313 0 0
44491: GO 44584
44493: LD_INT 3
44495: DOUBLE
44496: EQUAL
44497: IFTRUE 44501
44499: GO 44508
44501: POP
// hHackSetLevel10YourUnits ; 4 :
44502: CALL 56398 0 0
44506: GO 44584
44508: LD_INT 4
44510: DOUBLE
44511: EQUAL
44512: IFTRUE 44516
44514: GO 44523
44516: POP
// hHackInvincible ; 5 :
44517: CALL 56846 0 0
44521: GO 44584
44523: LD_INT 5
44525: DOUBLE
44526: EQUAL
44527: IFTRUE 44531
44529: GO 44538
44531: POP
// hHackInvisible ; 6 :
44532: CALL 56957 0 0
44536: GO 44584
44538: LD_INT 6
44540: DOUBLE
44541: EQUAL
44542: IFTRUE 44546
44544: GO 44553
44546: POP
// hHackChangeYourSide ; 7 :
44547: CALL 57014 0 0
44551: GO 44584
44553: LD_INT 7
44555: DOUBLE
44556: EQUAL
44557: IFTRUE 44561
44559: GO 44568
44561: POP
// hHackChangeUnitSide ; 8 :
44562: CALL 57056 0 0
44566: GO 44584
44568: LD_INT 8
44570: DOUBLE
44571: EQUAL
44572: IFTRUE 44576
44574: GO 44583
44576: POP
// hHackFog ; end ;
44577: CALL 57157 0 0
44581: GO 44584
44583: POP
// end ; end ;
44584: LD_VAR 0 7
44588: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44589: GO 44591
44591: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44592: LD_STRING initStreamRollete();
44594: PPUSH
44595: CALL_OW 559
// InitStreamMode ;
44599: CALL 44608 0 0
// DefineStreamItems ( ) ;
44603: CALL 45072 0 0
// end ;
44607: END
// function InitStreamMode ; begin
44608: LD_INT 0
44610: PPUSH
// streamModeActive := false ;
44611: LD_ADDR_EXP 92
44615: PUSH
44616: LD_INT 0
44618: ST_TO_ADDR
// normalCounter := 36 ;
44619: LD_ADDR_EXP 93
44623: PUSH
44624: LD_INT 36
44626: ST_TO_ADDR
// hardcoreCounter := 16 ;
44627: LD_ADDR_EXP 94
44631: PUSH
44632: LD_INT 16
44634: ST_TO_ADDR
// sRocket := false ;
44635: LD_ADDR_EXP 97
44639: PUSH
44640: LD_INT 0
44642: ST_TO_ADDR
// sSpeed := false ;
44643: LD_ADDR_EXP 96
44647: PUSH
44648: LD_INT 0
44650: ST_TO_ADDR
// sEngine := false ;
44651: LD_ADDR_EXP 98
44655: PUSH
44656: LD_INT 0
44658: ST_TO_ADDR
// sSpec := false ;
44659: LD_ADDR_EXP 95
44663: PUSH
44664: LD_INT 0
44666: ST_TO_ADDR
// sLevel := false ;
44667: LD_ADDR_EXP 99
44671: PUSH
44672: LD_INT 0
44674: ST_TO_ADDR
// sArmoury := false ;
44675: LD_ADDR_EXP 100
44679: PUSH
44680: LD_INT 0
44682: ST_TO_ADDR
// sRadar := false ;
44683: LD_ADDR_EXP 101
44687: PUSH
44688: LD_INT 0
44690: ST_TO_ADDR
// sBunker := false ;
44691: LD_ADDR_EXP 102
44695: PUSH
44696: LD_INT 0
44698: ST_TO_ADDR
// sHack := false ;
44699: LD_ADDR_EXP 103
44703: PUSH
44704: LD_INT 0
44706: ST_TO_ADDR
// sFire := false ;
44707: LD_ADDR_EXP 104
44711: PUSH
44712: LD_INT 0
44714: ST_TO_ADDR
// sRefresh := false ;
44715: LD_ADDR_EXP 105
44719: PUSH
44720: LD_INT 0
44722: ST_TO_ADDR
// sExp := false ;
44723: LD_ADDR_EXP 106
44727: PUSH
44728: LD_INT 0
44730: ST_TO_ADDR
// sDepot := false ;
44731: LD_ADDR_EXP 107
44735: PUSH
44736: LD_INT 0
44738: ST_TO_ADDR
// sFlag := false ;
44739: LD_ADDR_EXP 108
44743: PUSH
44744: LD_INT 0
44746: ST_TO_ADDR
// sKamikadze := false ;
44747: LD_ADDR_EXP 116
44751: PUSH
44752: LD_INT 0
44754: ST_TO_ADDR
// sTroll := false ;
44755: LD_ADDR_EXP 117
44759: PUSH
44760: LD_INT 0
44762: ST_TO_ADDR
// sSlow := false ;
44763: LD_ADDR_EXP 118
44767: PUSH
44768: LD_INT 0
44770: ST_TO_ADDR
// sLack := false ;
44771: LD_ADDR_EXP 119
44775: PUSH
44776: LD_INT 0
44778: ST_TO_ADDR
// sTank := false ;
44779: LD_ADDR_EXP 121
44783: PUSH
44784: LD_INT 0
44786: ST_TO_ADDR
// sRemote := false ;
44787: LD_ADDR_EXP 122
44791: PUSH
44792: LD_INT 0
44794: ST_TO_ADDR
// sPowell := false ;
44795: LD_ADDR_EXP 123
44799: PUSH
44800: LD_INT 0
44802: ST_TO_ADDR
// sTeleport := false ;
44803: LD_ADDR_EXP 126
44807: PUSH
44808: LD_INT 0
44810: ST_TO_ADDR
// sOilTower := false ;
44811: LD_ADDR_EXP 128
44815: PUSH
44816: LD_INT 0
44818: ST_TO_ADDR
// sShovel := false ;
44819: LD_ADDR_EXP 129
44823: PUSH
44824: LD_INT 0
44826: ST_TO_ADDR
// sSheik := false ;
44827: LD_ADDR_EXP 130
44831: PUSH
44832: LD_INT 0
44834: ST_TO_ADDR
// sEarthquake := false ;
44835: LD_ADDR_EXP 132
44839: PUSH
44840: LD_INT 0
44842: ST_TO_ADDR
// sAI := false ;
44843: LD_ADDR_EXP 133
44847: PUSH
44848: LD_INT 0
44850: ST_TO_ADDR
// sCargo := false ;
44851: LD_ADDR_EXP 136
44855: PUSH
44856: LD_INT 0
44858: ST_TO_ADDR
// sDLaser := false ;
44859: LD_ADDR_EXP 137
44863: PUSH
44864: LD_INT 0
44866: ST_TO_ADDR
// sExchange := false ;
44867: LD_ADDR_EXP 138
44871: PUSH
44872: LD_INT 0
44874: ST_TO_ADDR
// sFac := false ;
44875: LD_ADDR_EXP 139
44879: PUSH
44880: LD_INT 0
44882: ST_TO_ADDR
// sPower := false ;
44883: LD_ADDR_EXP 140
44887: PUSH
44888: LD_INT 0
44890: ST_TO_ADDR
// sRandom := false ;
44891: LD_ADDR_EXP 141
44895: PUSH
44896: LD_INT 0
44898: ST_TO_ADDR
// sShield := false ;
44899: LD_ADDR_EXP 142
44903: PUSH
44904: LD_INT 0
44906: ST_TO_ADDR
// sTime := false ;
44907: LD_ADDR_EXP 143
44911: PUSH
44912: LD_INT 0
44914: ST_TO_ADDR
// sTools := false ;
44915: LD_ADDR_EXP 144
44919: PUSH
44920: LD_INT 0
44922: ST_TO_ADDR
// sSold := false ;
44923: LD_ADDR_EXP 109
44927: PUSH
44928: LD_INT 0
44930: ST_TO_ADDR
// sDiff := false ;
44931: LD_ADDR_EXP 110
44935: PUSH
44936: LD_INT 0
44938: ST_TO_ADDR
// sFog := false ;
44939: LD_ADDR_EXP 113
44943: PUSH
44944: LD_INT 0
44946: ST_TO_ADDR
// sReset := false ;
44947: LD_ADDR_EXP 114
44951: PUSH
44952: LD_INT 0
44954: ST_TO_ADDR
// sSun := false ;
44955: LD_ADDR_EXP 115
44959: PUSH
44960: LD_INT 0
44962: ST_TO_ADDR
// sTiger := false ;
44963: LD_ADDR_EXP 111
44967: PUSH
44968: LD_INT 0
44970: ST_TO_ADDR
// sBomb := false ;
44971: LD_ADDR_EXP 112
44975: PUSH
44976: LD_INT 0
44978: ST_TO_ADDR
// sWound := false ;
44979: LD_ADDR_EXP 120
44983: PUSH
44984: LD_INT 0
44986: ST_TO_ADDR
// sBetray := false ;
44987: LD_ADDR_EXP 124
44991: PUSH
44992: LD_INT 0
44994: ST_TO_ADDR
// sContamin := false ;
44995: LD_ADDR_EXP 125
44999: PUSH
45000: LD_INT 0
45002: ST_TO_ADDR
// sOil := false ;
45003: LD_ADDR_EXP 127
45007: PUSH
45008: LD_INT 0
45010: ST_TO_ADDR
// sStu := false ;
45011: LD_ADDR_EXP 131
45015: PUSH
45016: LD_INT 0
45018: ST_TO_ADDR
// sBazooka := false ;
45019: LD_ADDR_EXP 134
45023: PUSH
45024: LD_INT 0
45026: ST_TO_ADDR
// sMortar := false ;
45027: LD_ADDR_EXP 135
45031: PUSH
45032: LD_INT 0
45034: ST_TO_ADDR
// sRanger := false ;
45035: LD_ADDR_EXP 145
45039: PUSH
45040: LD_INT 0
45042: ST_TO_ADDR
// sComputer := false ;
45043: LD_ADDR_EXP 146
45047: PUSH
45048: LD_INT 0
45050: ST_TO_ADDR
// s30 := false ;
45051: LD_ADDR_EXP 147
45055: PUSH
45056: LD_INT 0
45058: ST_TO_ADDR
// s60 := false ;
45059: LD_ADDR_EXP 148
45063: PUSH
45064: LD_INT 0
45066: ST_TO_ADDR
// end ;
45067: LD_VAR 0 1
45071: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
45072: LD_INT 0
45074: PPUSH
45075: PPUSH
45076: PPUSH
45077: PPUSH
45078: PPUSH
// result := [ ] ;
45079: LD_ADDR_VAR 0 1
45083: PUSH
45084: EMPTY
45085: ST_TO_ADDR
// if campaign_id = 1 then
45086: LD_OWVAR 69
45090: PUSH
45091: LD_INT 1
45093: EQUAL
45094: IFFALSE 48260
// begin case mission_number of 1 :
45096: LD_OWVAR 70
45100: PUSH
45101: LD_INT 1
45103: DOUBLE
45104: EQUAL
45105: IFTRUE 45109
45107: GO 45185
45109: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45110: LD_ADDR_VAR 0 1
45114: PUSH
45115: LD_INT 2
45117: PUSH
45118: LD_INT 4
45120: PUSH
45121: LD_INT 11
45123: PUSH
45124: LD_INT 12
45126: PUSH
45127: LD_INT 15
45129: PUSH
45130: LD_INT 16
45132: PUSH
45133: LD_INT 22
45135: PUSH
45136: LD_INT 23
45138: PUSH
45139: LD_INT 26
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: PUSH
45153: LD_INT 101
45155: PUSH
45156: LD_INT 102
45158: PUSH
45159: LD_INT 106
45161: PUSH
45162: LD_INT 116
45164: PUSH
45165: LD_INT 117
45167: PUSH
45168: LD_INT 118
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: ST_TO_ADDR
45183: GO 48258
45185: LD_INT 2
45187: DOUBLE
45188: EQUAL
45189: IFTRUE 45193
45191: GO 45277
45193: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45194: LD_ADDR_VAR 0 1
45198: PUSH
45199: LD_INT 2
45201: PUSH
45202: LD_INT 4
45204: PUSH
45205: LD_INT 11
45207: PUSH
45208: LD_INT 12
45210: PUSH
45211: LD_INT 15
45213: PUSH
45214: LD_INT 16
45216: PUSH
45217: LD_INT 22
45219: PUSH
45220: LD_INT 23
45222: PUSH
45223: LD_INT 26
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 101
45239: PUSH
45240: LD_INT 102
45242: PUSH
45243: LD_INT 105
45245: PUSH
45246: LD_INT 106
45248: PUSH
45249: LD_INT 108
45251: PUSH
45252: LD_INT 116
45254: PUSH
45255: LD_INT 117
45257: PUSH
45258: LD_INT 118
45260: PUSH
45261: EMPTY
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: ST_TO_ADDR
45275: GO 48258
45277: LD_INT 3
45279: DOUBLE
45280: EQUAL
45281: IFTRUE 45285
45283: GO 45373
45285: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45286: LD_ADDR_VAR 0 1
45290: PUSH
45291: LD_INT 2
45293: PUSH
45294: LD_INT 4
45296: PUSH
45297: LD_INT 5
45299: PUSH
45300: LD_INT 11
45302: PUSH
45303: LD_INT 12
45305: PUSH
45306: LD_INT 15
45308: PUSH
45309: LD_INT 16
45311: PUSH
45312: LD_INT 22
45314: PUSH
45315: LD_INT 26
45317: PUSH
45318: LD_INT 36
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: PUSH
45333: LD_INT 101
45335: PUSH
45336: LD_INT 102
45338: PUSH
45339: LD_INT 105
45341: PUSH
45342: LD_INT 106
45344: PUSH
45345: LD_INT 108
45347: PUSH
45348: LD_INT 116
45350: PUSH
45351: LD_INT 117
45353: PUSH
45354: LD_INT 118
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: ST_TO_ADDR
45371: GO 48258
45373: LD_INT 4
45375: DOUBLE
45376: EQUAL
45377: IFTRUE 45381
45379: GO 45477
45381: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45382: LD_ADDR_VAR 0 1
45386: PUSH
45387: LD_INT 2
45389: PUSH
45390: LD_INT 4
45392: PUSH
45393: LD_INT 5
45395: PUSH
45396: LD_INT 8
45398: PUSH
45399: LD_INT 11
45401: PUSH
45402: LD_INT 12
45404: PUSH
45405: LD_INT 15
45407: PUSH
45408: LD_INT 16
45410: PUSH
45411: LD_INT 22
45413: PUSH
45414: LD_INT 23
45416: PUSH
45417: LD_INT 26
45419: PUSH
45420: LD_INT 36
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: PUSH
45437: LD_INT 101
45439: PUSH
45440: LD_INT 102
45442: PUSH
45443: LD_INT 105
45445: PUSH
45446: LD_INT 106
45448: PUSH
45449: LD_INT 108
45451: PUSH
45452: LD_INT 116
45454: PUSH
45455: LD_INT 117
45457: PUSH
45458: LD_INT 118
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: ST_TO_ADDR
45475: GO 48258
45477: LD_INT 5
45479: DOUBLE
45480: EQUAL
45481: IFTRUE 45485
45483: GO 45597
45485: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45486: LD_ADDR_VAR 0 1
45490: PUSH
45491: LD_INT 2
45493: PUSH
45494: LD_INT 4
45496: PUSH
45497: LD_INT 5
45499: PUSH
45500: LD_INT 6
45502: PUSH
45503: LD_INT 8
45505: PUSH
45506: LD_INT 11
45508: PUSH
45509: LD_INT 12
45511: PUSH
45512: LD_INT 15
45514: PUSH
45515: LD_INT 16
45517: PUSH
45518: LD_INT 22
45520: PUSH
45521: LD_INT 23
45523: PUSH
45524: LD_INT 25
45526: PUSH
45527: LD_INT 26
45529: PUSH
45530: LD_INT 36
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 101
45551: PUSH
45552: LD_INT 102
45554: PUSH
45555: LD_INT 105
45557: PUSH
45558: LD_INT 106
45560: PUSH
45561: LD_INT 108
45563: PUSH
45564: LD_INT 109
45566: PUSH
45567: LD_INT 112
45569: PUSH
45570: LD_INT 116
45572: PUSH
45573: LD_INT 117
45575: PUSH
45576: LD_INT 118
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: ST_TO_ADDR
45595: GO 48258
45597: LD_INT 6
45599: DOUBLE
45600: EQUAL
45601: IFTRUE 45605
45603: GO 45737
45605: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45606: LD_ADDR_VAR 0 1
45610: PUSH
45611: LD_INT 2
45613: PUSH
45614: LD_INT 4
45616: PUSH
45617: LD_INT 5
45619: PUSH
45620: LD_INT 6
45622: PUSH
45623: LD_INT 8
45625: PUSH
45626: LD_INT 11
45628: PUSH
45629: LD_INT 12
45631: PUSH
45632: LD_INT 15
45634: PUSH
45635: LD_INT 16
45637: PUSH
45638: LD_INT 20
45640: PUSH
45641: LD_INT 21
45643: PUSH
45644: LD_INT 22
45646: PUSH
45647: LD_INT 23
45649: PUSH
45650: LD_INT 25
45652: PUSH
45653: LD_INT 26
45655: PUSH
45656: LD_INT 30
45658: PUSH
45659: LD_INT 31
45661: PUSH
45662: LD_INT 32
45664: PUSH
45665: LD_INT 36
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 101
45691: PUSH
45692: LD_INT 102
45694: PUSH
45695: LD_INT 105
45697: PUSH
45698: LD_INT 106
45700: PUSH
45701: LD_INT 108
45703: PUSH
45704: LD_INT 109
45706: PUSH
45707: LD_INT 112
45709: PUSH
45710: LD_INT 116
45712: PUSH
45713: LD_INT 117
45715: PUSH
45716: LD_INT 118
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: LIST
45726: LIST
45727: LIST
45728: LIST
45729: LIST
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: ST_TO_ADDR
45735: GO 48258
45737: LD_INT 7
45739: DOUBLE
45740: EQUAL
45741: IFTRUE 45745
45743: GO 45857
45745: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45746: LD_ADDR_VAR 0 1
45750: PUSH
45751: LD_INT 2
45753: PUSH
45754: LD_INT 4
45756: PUSH
45757: LD_INT 5
45759: PUSH
45760: LD_INT 7
45762: PUSH
45763: LD_INT 11
45765: PUSH
45766: LD_INT 12
45768: PUSH
45769: LD_INT 15
45771: PUSH
45772: LD_INT 16
45774: PUSH
45775: LD_INT 20
45777: PUSH
45778: LD_INT 21
45780: PUSH
45781: LD_INT 22
45783: PUSH
45784: LD_INT 23
45786: PUSH
45787: LD_INT 25
45789: PUSH
45790: LD_INT 26
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 101
45811: PUSH
45812: LD_INT 102
45814: PUSH
45815: LD_INT 103
45817: PUSH
45818: LD_INT 105
45820: PUSH
45821: LD_INT 106
45823: PUSH
45824: LD_INT 108
45826: PUSH
45827: LD_INT 112
45829: PUSH
45830: LD_INT 116
45832: PUSH
45833: LD_INT 117
45835: PUSH
45836: LD_INT 118
45838: PUSH
45839: EMPTY
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: ST_TO_ADDR
45855: GO 48258
45857: LD_INT 8
45859: DOUBLE
45860: EQUAL
45861: IFTRUE 45865
45863: GO 46005
45865: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45866: LD_ADDR_VAR 0 1
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: LD_INT 4
45876: PUSH
45877: LD_INT 5
45879: PUSH
45880: LD_INT 6
45882: PUSH
45883: LD_INT 7
45885: PUSH
45886: LD_INT 8
45888: PUSH
45889: LD_INT 11
45891: PUSH
45892: LD_INT 12
45894: PUSH
45895: LD_INT 15
45897: PUSH
45898: LD_INT 16
45900: PUSH
45901: LD_INT 20
45903: PUSH
45904: LD_INT 21
45906: PUSH
45907: LD_INT 22
45909: PUSH
45910: LD_INT 23
45912: PUSH
45913: LD_INT 25
45915: PUSH
45916: LD_INT 26
45918: PUSH
45919: LD_INT 30
45921: PUSH
45922: LD_INT 31
45924: PUSH
45925: LD_INT 32
45927: PUSH
45928: LD_INT 36
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: LIST
45935: LIST
45936: LIST
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: PUSH
45953: LD_INT 101
45955: PUSH
45956: LD_INT 102
45958: PUSH
45959: LD_INT 103
45961: PUSH
45962: LD_INT 105
45964: PUSH
45965: LD_INT 106
45967: PUSH
45968: LD_INT 108
45970: PUSH
45971: LD_INT 109
45973: PUSH
45974: LD_INT 112
45976: PUSH
45977: LD_INT 116
45979: PUSH
45980: LD_INT 117
45982: PUSH
45983: LD_INT 118
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: PUSH
45999: EMPTY
46000: LIST
46001: LIST
46002: ST_TO_ADDR
46003: GO 48258
46005: LD_INT 9
46007: DOUBLE
46008: EQUAL
46009: IFTRUE 46013
46011: GO 46161
46013: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46014: LD_ADDR_VAR 0 1
46018: PUSH
46019: LD_INT 2
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: LD_INT 5
46027: PUSH
46028: LD_INT 6
46030: PUSH
46031: LD_INT 7
46033: PUSH
46034: LD_INT 8
46036: PUSH
46037: LD_INT 11
46039: PUSH
46040: LD_INT 12
46042: PUSH
46043: LD_INT 15
46045: PUSH
46046: LD_INT 16
46048: PUSH
46049: LD_INT 20
46051: PUSH
46052: LD_INT 21
46054: PUSH
46055: LD_INT 22
46057: PUSH
46058: LD_INT 23
46060: PUSH
46061: LD_INT 25
46063: PUSH
46064: LD_INT 26
46066: PUSH
46067: LD_INT 28
46069: PUSH
46070: LD_INT 30
46072: PUSH
46073: LD_INT 31
46075: PUSH
46076: LD_INT 32
46078: PUSH
46079: LD_INT 36
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: LIST
46100: LIST
46101: LIST
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 101
46107: PUSH
46108: LD_INT 102
46110: PUSH
46111: LD_INT 103
46113: PUSH
46114: LD_INT 105
46116: PUSH
46117: LD_INT 106
46119: PUSH
46120: LD_INT 108
46122: PUSH
46123: LD_INT 109
46125: PUSH
46126: LD_INT 112
46128: PUSH
46129: LD_INT 114
46131: PUSH
46132: LD_INT 116
46134: PUSH
46135: LD_INT 117
46137: PUSH
46138: LD_INT 118
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: ST_TO_ADDR
46159: GO 48258
46161: LD_INT 10
46163: DOUBLE
46164: EQUAL
46165: IFTRUE 46169
46167: GO 46365
46169: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46170: LD_ADDR_VAR 0 1
46174: PUSH
46175: LD_INT 2
46177: PUSH
46178: LD_INT 4
46180: PUSH
46181: LD_INT 5
46183: PUSH
46184: LD_INT 6
46186: PUSH
46187: LD_INT 7
46189: PUSH
46190: LD_INT 8
46192: PUSH
46193: LD_INT 9
46195: PUSH
46196: LD_INT 10
46198: PUSH
46199: LD_INT 11
46201: PUSH
46202: LD_INT 12
46204: PUSH
46205: LD_INT 13
46207: PUSH
46208: LD_INT 14
46210: PUSH
46211: LD_INT 15
46213: PUSH
46214: LD_INT 16
46216: PUSH
46217: LD_INT 17
46219: PUSH
46220: LD_INT 18
46222: PUSH
46223: LD_INT 19
46225: PUSH
46226: LD_INT 20
46228: PUSH
46229: LD_INT 21
46231: PUSH
46232: LD_INT 22
46234: PUSH
46235: LD_INT 23
46237: PUSH
46238: LD_INT 24
46240: PUSH
46241: LD_INT 25
46243: PUSH
46244: LD_INT 26
46246: PUSH
46247: LD_INT 28
46249: PUSH
46250: LD_INT 30
46252: PUSH
46253: LD_INT 31
46255: PUSH
46256: LD_INT 32
46258: PUSH
46259: LD_INT 36
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: LIST
46266: LIST
46267: LIST
46268: LIST
46269: LIST
46270: LIST
46271: LIST
46272: LIST
46273: LIST
46274: LIST
46275: LIST
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: LIST
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 101
46295: PUSH
46296: LD_INT 102
46298: PUSH
46299: LD_INT 103
46301: PUSH
46302: LD_INT 104
46304: PUSH
46305: LD_INT 105
46307: PUSH
46308: LD_INT 106
46310: PUSH
46311: LD_INT 107
46313: PUSH
46314: LD_INT 108
46316: PUSH
46317: LD_INT 109
46319: PUSH
46320: LD_INT 110
46322: PUSH
46323: LD_INT 111
46325: PUSH
46326: LD_INT 112
46328: PUSH
46329: LD_INT 114
46331: PUSH
46332: LD_INT 116
46334: PUSH
46335: LD_INT 117
46337: PUSH
46338: LD_INT 118
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: LIST
46355: LIST
46356: LIST
46357: LIST
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: ST_TO_ADDR
46363: GO 48258
46365: LD_INT 11
46367: DOUBLE
46368: EQUAL
46369: IFTRUE 46373
46371: GO 46577
46373: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46374: LD_ADDR_VAR 0 1
46378: PUSH
46379: LD_INT 2
46381: PUSH
46382: LD_INT 3
46384: PUSH
46385: LD_INT 4
46387: PUSH
46388: LD_INT 5
46390: PUSH
46391: LD_INT 6
46393: PUSH
46394: LD_INT 7
46396: PUSH
46397: LD_INT 8
46399: PUSH
46400: LD_INT 9
46402: PUSH
46403: LD_INT 10
46405: PUSH
46406: LD_INT 11
46408: PUSH
46409: LD_INT 12
46411: PUSH
46412: LD_INT 13
46414: PUSH
46415: LD_INT 14
46417: PUSH
46418: LD_INT 15
46420: PUSH
46421: LD_INT 16
46423: PUSH
46424: LD_INT 17
46426: PUSH
46427: LD_INT 18
46429: PUSH
46430: LD_INT 19
46432: PUSH
46433: LD_INT 20
46435: PUSH
46436: LD_INT 21
46438: PUSH
46439: LD_INT 22
46441: PUSH
46442: LD_INT 23
46444: PUSH
46445: LD_INT 24
46447: PUSH
46448: LD_INT 25
46450: PUSH
46451: LD_INT 26
46453: PUSH
46454: LD_INT 28
46456: PUSH
46457: LD_INT 30
46459: PUSH
46460: LD_INT 31
46462: PUSH
46463: LD_INT 32
46465: PUSH
46466: LD_INT 34
46468: PUSH
46469: LD_INT 36
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: LIST
46476: LIST
46477: LIST
46478: LIST
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: LIST
46488: LIST
46489: LIST
46490: LIST
46491: LIST
46492: LIST
46493: LIST
46494: LIST
46495: LIST
46496: LIST
46497: LIST
46498: LIST
46499: LIST
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: PUSH
46505: LD_INT 101
46507: PUSH
46508: LD_INT 102
46510: PUSH
46511: LD_INT 103
46513: PUSH
46514: LD_INT 104
46516: PUSH
46517: LD_INT 105
46519: PUSH
46520: LD_INT 106
46522: PUSH
46523: LD_INT 107
46525: PUSH
46526: LD_INT 108
46528: PUSH
46529: LD_INT 109
46531: PUSH
46532: LD_INT 110
46534: PUSH
46535: LD_INT 111
46537: PUSH
46538: LD_INT 112
46540: PUSH
46541: LD_INT 114
46543: PUSH
46544: LD_INT 116
46546: PUSH
46547: LD_INT 117
46549: PUSH
46550: LD_INT 118
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: ST_TO_ADDR
46575: GO 48258
46577: LD_INT 12
46579: DOUBLE
46580: EQUAL
46581: IFTRUE 46585
46583: GO 46805
46585: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46586: LD_ADDR_VAR 0 1
46590: PUSH
46591: LD_INT 1
46593: PUSH
46594: LD_INT 2
46596: PUSH
46597: LD_INT 3
46599: PUSH
46600: LD_INT 4
46602: PUSH
46603: LD_INT 5
46605: PUSH
46606: LD_INT 6
46608: PUSH
46609: LD_INT 7
46611: PUSH
46612: LD_INT 8
46614: PUSH
46615: LD_INT 9
46617: PUSH
46618: LD_INT 10
46620: PUSH
46621: LD_INT 11
46623: PUSH
46624: LD_INT 12
46626: PUSH
46627: LD_INT 13
46629: PUSH
46630: LD_INT 14
46632: PUSH
46633: LD_INT 15
46635: PUSH
46636: LD_INT 16
46638: PUSH
46639: LD_INT 17
46641: PUSH
46642: LD_INT 18
46644: PUSH
46645: LD_INT 19
46647: PUSH
46648: LD_INT 20
46650: PUSH
46651: LD_INT 21
46653: PUSH
46654: LD_INT 22
46656: PUSH
46657: LD_INT 23
46659: PUSH
46660: LD_INT 24
46662: PUSH
46663: LD_INT 25
46665: PUSH
46666: LD_INT 26
46668: PUSH
46669: LD_INT 27
46671: PUSH
46672: LD_INT 28
46674: PUSH
46675: LD_INT 30
46677: PUSH
46678: LD_INT 31
46680: PUSH
46681: LD_INT 32
46683: PUSH
46684: LD_INT 33
46686: PUSH
46687: LD_INT 34
46689: PUSH
46690: LD_INT 36
46692: PUSH
46693: EMPTY
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: LIST
46701: LIST
46702: LIST
46703: LIST
46704: LIST
46705: LIST
46706: LIST
46707: LIST
46708: LIST
46709: LIST
46710: LIST
46711: LIST
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: LIST
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 101
46731: PUSH
46732: LD_INT 102
46734: PUSH
46735: LD_INT 103
46737: PUSH
46738: LD_INT 104
46740: PUSH
46741: LD_INT 105
46743: PUSH
46744: LD_INT 106
46746: PUSH
46747: LD_INT 107
46749: PUSH
46750: LD_INT 108
46752: PUSH
46753: LD_INT 109
46755: PUSH
46756: LD_INT 110
46758: PUSH
46759: LD_INT 111
46761: PUSH
46762: LD_INT 112
46764: PUSH
46765: LD_INT 113
46767: PUSH
46768: LD_INT 114
46770: PUSH
46771: LD_INT 116
46773: PUSH
46774: LD_INT 117
46776: PUSH
46777: LD_INT 118
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: ST_TO_ADDR
46803: GO 48258
46805: LD_INT 13
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46813
46811: GO 47021
46813: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46814: LD_ADDR_VAR 0 1
46818: PUSH
46819: LD_INT 1
46821: PUSH
46822: LD_INT 2
46824: PUSH
46825: LD_INT 3
46827: PUSH
46828: LD_INT 4
46830: PUSH
46831: LD_INT 5
46833: PUSH
46834: LD_INT 8
46836: PUSH
46837: LD_INT 9
46839: PUSH
46840: LD_INT 10
46842: PUSH
46843: LD_INT 11
46845: PUSH
46846: LD_INT 12
46848: PUSH
46849: LD_INT 14
46851: PUSH
46852: LD_INT 15
46854: PUSH
46855: LD_INT 16
46857: PUSH
46858: LD_INT 17
46860: PUSH
46861: LD_INT 18
46863: PUSH
46864: LD_INT 19
46866: PUSH
46867: LD_INT 20
46869: PUSH
46870: LD_INT 21
46872: PUSH
46873: LD_INT 22
46875: PUSH
46876: LD_INT 23
46878: PUSH
46879: LD_INT 24
46881: PUSH
46882: LD_INT 25
46884: PUSH
46885: LD_INT 26
46887: PUSH
46888: LD_INT 27
46890: PUSH
46891: LD_INT 28
46893: PUSH
46894: LD_INT 30
46896: PUSH
46897: LD_INT 31
46899: PUSH
46900: LD_INT 32
46902: PUSH
46903: LD_INT 33
46905: PUSH
46906: LD_INT 34
46908: PUSH
46909: LD_INT 36
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: LIST
46942: LIST
46943: LIST
46944: PUSH
46945: LD_INT 101
46947: PUSH
46948: LD_INT 102
46950: PUSH
46951: LD_INT 103
46953: PUSH
46954: LD_INT 104
46956: PUSH
46957: LD_INT 105
46959: PUSH
46960: LD_INT 106
46962: PUSH
46963: LD_INT 107
46965: PUSH
46966: LD_INT 108
46968: PUSH
46969: LD_INT 109
46971: PUSH
46972: LD_INT 110
46974: PUSH
46975: LD_INT 111
46977: PUSH
46978: LD_INT 112
46980: PUSH
46981: LD_INT 113
46983: PUSH
46984: LD_INT 114
46986: PUSH
46987: LD_INT 116
46989: PUSH
46990: LD_INT 117
46992: PUSH
46993: LD_INT 118
46995: PUSH
46996: EMPTY
46997: LIST
46998: LIST
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: LIST
47012: LIST
47013: LIST
47014: PUSH
47015: EMPTY
47016: LIST
47017: LIST
47018: ST_TO_ADDR
47019: GO 48258
47021: LD_INT 14
47023: DOUBLE
47024: EQUAL
47025: IFTRUE 47029
47027: GO 47253
47029: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47030: LD_ADDR_VAR 0 1
47034: PUSH
47035: LD_INT 1
47037: PUSH
47038: LD_INT 2
47040: PUSH
47041: LD_INT 3
47043: PUSH
47044: LD_INT 4
47046: PUSH
47047: LD_INT 5
47049: PUSH
47050: LD_INT 6
47052: PUSH
47053: LD_INT 7
47055: PUSH
47056: LD_INT 8
47058: PUSH
47059: LD_INT 9
47061: PUSH
47062: LD_INT 10
47064: PUSH
47065: LD_INT 11
47067: PUSH
47068: LD_INT 12
47070: PUSH
47071: LD_INT 13
47073: PUSH
47074: LD_INT 14
47076: PUSH
47077: LD_INT 15
47079: PUSH
47080: LD_INT 16
47082: PUSH
47083: LD_INT 17
47085: PUSH
47086: LD_INT 18
47088: PUSH
47089: LD_INT 19
47091: PUSH
47092: LD_INT 20
47094: PUSH
47095: LD_INT 21
47097: PUSH
47098: LD_INT 22
47100: PUSH
47101: LD_INT 23
47103: PUSH
47104: LD_INT 24
47106: PUSH
47107: LD_INT 25
47109: PUSH
47110: LD_INT 26
47112: PUSH
47113: LD_INT 27
47115: PUSH
47116: LD_INT 28
47118: PUSH
47119: LD_INT 29
47121: PUSH
47122: LD_INT 30
47124: PUSH
47125: LD_INT 31
47127: PUSH
47128: LD_INT 32
47130: PUSH
47131: LD_INT 33
47133: PUSH
47134: LD_INT 34
47136: PUSH
47137: LD_INT 36
47139: PUSH
47140: EMPTY
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: LIST
47166: LIST
47167: LIST
47168: LIST
47169: LIST
47170: LIST
47171: LIST
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: PUSH
47177: LD_INT 101
47179: PUSH
47180: LD_INT 102
47182: PUSH
47183: LD_INT 103
47185: PUSH
47186: LD_INT 104
47188: PUSH
47189: LD_INT 105
47191: PUSH
47192: LD_INT 106
47194: PUSH
47195: LD_INT 107
47197: PUSH
47198: LD_INT 108
47200: PUSH
47201: LD_INT 109
47203: PUSH
47204: LD_INT 110
47206: PUSH
47207: LD_INT 111
47209: PUSH
47210: LD_INT 112
47212: PUSH
47213: LD_INT 113
47215: PUSH
47216: LD_INT 114
47218: PUSH
47219: LD_INT 116
47221: PUSH
47222: LD_INT 117
47224: PUSH
47225: LD_INT 118
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: LIST
47243: LIST
47244: LIST
47245: LIST
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: ST_TO_ADDR
47251: GO 48258
47253: LD_INT 15
47255: DOUBLE
47256: EQUAL
47257: IFTRUE 47261
47259: GO 47485
47261: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47262: LD_ADDR_VAR 0 1
47266: PUSH
47267: LD_INT 1
47269: PUSH
47270: LD_INT 2
47272: PUSH
47273: LD_INT 3
47275: PUSH
47276: LD_INT 4
47278: PUSH
47279: LD_INT 5
47281: PUSH
47282: LD_INT 6
47284: PUSH
47285: LD_INT 7
47287: PUSH
47288: LD_INT 8
47290: PUSH
47291: LD_INT 9
47293: PUSH
47294: LD_INT 10
47296: PUSH
47297: LD_INT 11
47299: PUSH
47300: LD_INT 12
47302: PUSH
47303: LD_INT 13
47305: PUSH
47306: LD_INT 14
47308: PUSH
47309: LD_INT 15
47311: PUSH
47312: LD_INT 16
47314: PUSH
47315: LD_INT 17
47317: PUSH
47318: LD_INT 18
47320: PUSH
47321: LD_INT 19
47323: PUSH
47324: LD_INT 20
47326: PUSH
47327: LD_INT 21
47329: PUSH
47330: LD_INT 22
47332: PUSH
47333: LD_INT 23
47335: PUSH
47336: LD_INT 24
47338: PUSH
47339: LD_INT 25
47341: PUSH
47342: LD_INT 26
47344: PUSH
47345: LD_INT 27
47347: PUSH
47348: LD_INT 28
47350: PUSH
47351: LD_INT 29
47353: PUSH
47354: LD_INT 30
47356: PUSH
47357: LD_INT 31
47359: PUSH
47360: LD_INT 32
47362: PUSH
47363: LD_INT 33
47365: PUSH
47366: LD_INT 34
47368: PUSH
47369: LD_INT 36
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: PUSH
47409: LD_INT 101
47411: PUSH
47412: LD_INT 102
47414: PUSH
47415: LD_INT 103
47417: PUSH
47418: LD_INT 104
47420: PUSH
47421: LD_INT 105
47423: PUSH
47424: LD_INT 106
47426: PUSH
47427: LD_INT 107
47429: PUSH
47430: LD_INT 108
47432: PUSH
47433: LD_INT 109
47435: PUSH
47436: LD_INT 110
47438: PUSH
47439: LD_INT 111
47441: PUSH
47442: LD_INT 112
47444: PUSH
47445: LD_INT 113
47447: PUSH
47448: LD_INT 114
47450: PUSH
47451: LD_INT 116
47453: PUSH
47454: LD_INT 117
47456: PUSH
47457: LD_INT 118
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: ST_TO_ADDR
47483: GO 48258
47485: LD_INT 16
47487: DOUBLE
47488: EQUAL
47489: IFTRUE 47493
47491: GO 47629
47493: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47494: LD_ADDR_VAR 0 1
47498: PUSH
47499: LD_INT 2
47501: PUSH
47502: LD_INT 4
47504: PUSH
47505: LD_INT 5
47507: PUSH
47508: LD_INT 7
47510: PUSH
47511: LD_INT 11
47513: PUSH
47514: LD_INT 12
47516: PUSH
47517: LD_INT 15
47519: PUSH
47520: LD_INT 16
47522: PUSH
47523: LD_INT 20
47525: PUSH
47526: LD_INT 21
47528: PUSH
47529: LD_INT 22
47531: PUSH
47532: LD_INT 23
47534: PUSH
47535: LD_INT 25
47537: PUSH
47538: LD_INT 26
47540: PUSH
47541: LD_INT 30
47543: PUSH
47544: LD_INT 31
47546: PUSH
47547: LD_INT 32
47549: PUSH
47550: LD_INT 33
47552: PUSH
47553: LD_INT 34
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: LIST
47570: LIST
47571: LIST
47572: LIST
47573: LIST
47574: LIST
47575: LIST
47576: PUSH
47577: LD_INT 101
47579: PUSH
47580: LD_INT 102
47582: PUSH
47583: LD_INT 103
47585: PUSH
47586: LD_INT 106
47588: PUSH
47589: LD_INT 108
47591: PUSH
47592: LD_INT 112
47594: PUSH
47595: LD_INT 113
47597: PUSH
47598: LD_INT 114
47600: PUSH
47601: LD_INT 116
47603: PUSH
47604: LD_INT 117
47606: PUSH
47607: LD_INT 118
47609: PUSH
47610: EMPTY
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: ST_TO_ADDR
47627: GO 48258
47629: LD_INT 17
47631: DOUBLE
47632: EQUAL
47633: IFTRUE 47637
47635: GO 47861
47637: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47638: LD_ADDR_VAR 0 1
47642: PUSH
47643: LD_INT 1
47645: PUSH
47646: LD_INT 2
47648: PUSH
47649: LD_INT 3
47651: PUSH
47652: LD_INT 4
47654: PUSH
47655: LD_INT 5
47657: PUSH
47658: LD_INT 6
47660: PUSH
47661: LD_INT 7
47663: PUSH
47664: LD_INT 8
47666: PUSH
47667: LD_INT 9
47669: PUSH
47670: LD_INT 10
47672: PUSH
47673: LD_INT 11
47675: PUSH
47676: LD_INT 12
47678: PUSH
47679: LD_INT 13
47681: PUSH
47682: LD_INT 14
47684: PUSH
47685: LD_INT 15
47687: PUSH
47688: LD_INT 16
47690: PUSH
47691: LD_INT 17
47693: PUSH
47694: LD_INT 18
47696: PUSH
47697: LD_INT 19
47699: PUSH
47700: LD_INT 20
47702: PUSH
47703: LD_INT 21
47705: PUSH
47706: LD_INT 22
47708: PUSH
47709: LD_INT 23
47711: PUSH
47712: LD_INT 24
47714: PUSH
47715: LD_INT 25
47717: PUSH
47718: LD_INT 26
47720: PUSH
47721: LD_INT 27
47723: PUSH
47724: LD_INT 28
47726: PUSH
47727: LD_INT 29
47729: PUSH
47730: LD_INT 30
47732: PUSH
47733: LD_INT 31
47735: PUSH
47736: LD_INT 32
47738: PUSH
47739: LD_INT 33
47741: PUSH
47742: LD_INT 34
47744: PUSH
47745: LD_INT 36
47747: PUSH
47748: EMPTY
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: LIST
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: LIST
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: PUSH
47785: LD_INT 101
47787: PUSH
47788: LD_INT 102
47790: PUSH
47791: LD_INT 103
47793: PUSH
47794: LD_INT 104
47796: PUSH
47797: LD_INT 105
47799: PUSH
47800: LD_INT 106
47802: PUSH
47803: LD_INT 107
47805: PUSH
47806: LD_INT 108
47808: PUSH
47809: LD_INT 109
47811: PUSH
47812: LD_INT 110
47814: PUSH
47815: LD_INT 111
47817: PUSH
47818: LD_INT 112
47820: PUSH
47821: LD_INT 113
47823: PUSH
47824: LD_INT 114
47826: PUSH
47827: LD_INT 116
47829: PUSH
47830: LD_INT 117
47832: PUSH
47833: LD_INT 118
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: PUSH
47855: EMPTY
47856: LIST
47857: LIST
47858: ST_TO_ADDR
47859: GO 48258
47861: LD_INT 18
47863: DOUBLE
47864: EQUAL
47865: IFTRUE 47869
47867: GO 48017
47869: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47870: LD_ADDR_VAR 0 1
47874: PUSH
47875: LD_INT 2
47877: PUSH
47878: LD_INT 4
47880: PUSH
47881: LD_INT 5
47883: PUSH
47884: LD_INT 7
47886: PUSH
47887: LD_INT 11
47889: PUSH
47890: LD_INT 12
47892: PUSH
47893: LD_INT 15
47895: PUSH
47896: LD_INT 16
47898: PUSH
47899: LD_INT 20
47901: PUSH
47902: LD_INT 21
47904: PUSH
47905: LD_INT 22
47907: PUSH
47908: LD_INT 23
47910: PUSH
47911: LD_INT 25
47913: PUSH
47914: LD_INT 26
47916: PUSH
47917: LD_INT 30
47919: PUSH
47920: LD_INT 31
47922: PUSH
47923: LD_INT 32
47925: PUSH
47926: LD_INT 33
47928: PUSH
47929: LD_INT 34
47931: PUSH
47932: LD_INT 35
47934: PUSH
47935: LD_INT 36
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: PUSH
47961: LD_INT 101
47963: PUSH
47964: LD_INT 102
47966: PUSH
47967: LD_INT 103
47969: PUSH
47970: LD_INT 106
47972: PUSH
47973: LD_INT 108
47975: PUSH
47976: LD_INT 112
47978: PUSH
47979: LD_INT 113
47981: PUSH
47982: LD_INT 114
47984: PUSH
47985: LD_INT 115
47987: PUSH
47988: LD_INT 116
47990: PUSH
47991: LD_INT 117
47993: PUSH
47994: LD_INT 118
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: PUSH
48011: EMPTY
48012: LIST
48013: LIST
48014: ST_TO_ADDR
48015: GO 48258
48017: LD_INT 19
48019: DOUBLE
48020: EQUAL
48021: IFTRUE 48025
48023: GO 48257
48025: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48026: LD_ADDR_VAR 0 1
48030: PUSH
48031: LD_INT 1
48033: PUSH
48034: LD_INT 2
48036: PUSH
48037: LD_INT 3
48039: PUSH
48040: LD_INT 4
48042: PUSH
48043: LD_INT 5
48045: PUSH
48046: LD_INT 6
48048: PUSH
48049: LD_INT 7
48051: PUSH
48052: LD_INT 8
48054: PUSH
48055: LD_INT 9
48057: PUSH
48058: LD_INT 10
48060: PUSH
48061: LD_INT 11
48063: PUSH
48064: LD_INT 12
48066: PUSH
48067: LD_INT 13
48069: PUSH
48070: LD_INT 14
48072: PUSH
48073: LD_INT 15
48075: PUSH
48076: LD_INT 16
48078: PUSH
48079: LD_INT 17
48081: PUSH
48082: LD_INT 18
48084: PUSH
48085: LD_INT 19
48087: PUSH
48088: LD_INT 20
48090: PUSH
48091: LD_INT 21
48093: PUSH
48094: LD_INT 22
48096: PUSH
48097: LD_INT 23
48099: PUSH
48100: LD_INT 24
48102: PUSH
48103: LD_INT 25
48105: PUSH
48106: LD_INT 26
48108: PUSH
48109: LD_INT 27
48111: PUSH
48112: LD_INT 28
48114: PUSH
48115: LD_INT 29
48117: PUSH
48118: LD_INT 30
48120: PUSH
48121: LD_INT 31
48123: PUSH
48124: LD_INT 32
48126: PUSH
48127: LD_INT 33
48129: PUSH
48130: LD_INT 34
48132: PUSH
48133: LD_INT 35
48135: PUSH
48136: LD_INT 36
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: PUSH
48177: LD_INT 101
48179: PUSH
48180: LD_INT 102
48182: PUSH
48183: LD_INT 103
48185: PUSH
48186: LD_INT 104
48188: PUSH
48189: LD_INT 105
48191: PUSH
48192: LD_INT 106
48194: PUSH
48195: LD_INT 107
48197: PUSH
48198: LD_INT 108
48200: PUSH
48201: LD_INT 109
48203: PUSH
48204: LD_INT 110
48206: PUSH
48207: LD_INT 111
48209: PUSH
48210: LD_INT 112
48212: PUSH
48213: LD_INT 113
48215: PUSH
48216: LD_INT 114
48218: PUSH
48219: LD_INT 115
48221: PUSH
48222: LD_INT 116
48224: PUSH
48225: LD_INT 117
48227: PUSH
48228: LD_INT 118
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: ST_TO_ADDR
48255: GO 48258
48257: POP
// end else
48258: GO 48489
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48260: LD_ADDR_VAR 0 1
48264: PUSH
48265: LD_INT 1
48267: PUSH
48268: LD_INT 2
48270: PUSH
48271: LD_INT 3
48273: PUSH
48274: LD_INT 4
48276: PUSH
48277: LD_INT 5
48279: PUSH
48280: LD_INT 6
48282: PUSH
48283: LD_INT 7
48285: PUSH
48286: LD_INT 8
48288: PUSH
48289: LD_INT 9
48291: PUSH
48292: LD_INT 10
48294: PUSH
48295: LD_INT 11
48297: PUSH
48298: LD_INT 12
48300: PUSH
48301: LD_INT 13
48303: PUSH
48304: LD_INT 14
48306: PUSH
48307: LD_INT 15
48309: PUSH
48310: LD_INT 16
48312: PUSH
48313: LD_INT 17
48315: PUSH
48316: LD_INT 18
48318: PUSH
48319: LD_INT 19
48321: PUSH
48322: LD_INT 20
48324: PUSH
48325: LD_INT 21
48327: PUSH
48328: LD_INT 22
48330: PUSH
48331: LD_INT 23
48333: PUSH
48334: LD_INT 24
48336: PUSH
48337: LD_INT 25
48339: PUSH
48340: LD_INT 26
48342: PUSH
48343: LD_INT 27
48345: PUSH
48346: LD_INT 28
48348: PUSH
48349: LD_INT 29
48351: PUSH
48352: LD_INT 30
48354: PUSH
48355: LD_INT 31
48357: PUSH
48358: LD_INT 32
48360: PUSH
48361: LD_INT 33
48363: PUSH
48364: LD_INT 34
48366: PUSH
48367: LD_INT 35
48369: PUSH
48370: LD_INT 36
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: LIST
48395: LIST
48396: LIST
48397: LIST
48398: LIST
48399: LIST
48400: LIST
48401: LIST
48402: LIST
48403: LIST
48404: LIST
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 101
48413: PUSH
48414: LD_INT 102
48416: PUSH
48417: LD_INT 103
48419: PUSH
48420: LD_INT 104
48422: PUSH
48423: LD_INT 105
48425: PUSH
48426: LD_INT 106
48428: PUSH
48429: LD_INT 107
48431: PUSH
48432: LD_INT 108
48434: PUSH
48435: LD_INT 109
48437: PUSH
48438: LD_INT 110
48440: PUSH
48441: LD_INT 111
48443: PUSH
48444: LD_INT 112
48446: PUSH
48447: LD_INT 113
48449: PUSH
48450: LD_INT 114
48452: PUSH
48453: LD_INT 115
48455: PUSH
48456: LD_INT 116
48458: PUSH
48459: LD_INT 117
48461: PUSH
48462: LD_INT 118
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: LIST
48474: LIST
48475: LIST
48476: LIST
48477: LIST
48478: LIST
48479: LIST
48480: LIST
48481: LIST
48482: LIST
48483: LIST
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: ST_TO_ADDR
// if result then
48489: LD_VAR 0 1
48493: IFFALSE 48782
// begin normal :=  ;
48495: LD_ADDR_VAR 0 3
48499: PUSH
48500: LD_STRING 
48502: ST_TO_ADDR
// hardcore :=  ;
48503: LD_ADDR_VAR 0 4
48507: PUSH
48508: LD_STRING 
48510: ST_TO_ADDR
// for i = 1 to normalCounter do
48511: LD_ADDR_VAR 0 5
48515: PUSH
48516: DOUBLE
48517: LD_INT 1
48519: DEC
48520: ST_TO_ADDR
48521: LD_EXP 93
48525: PUSH
48526: FOR_TO
48527: IFFALSE 48628
// begin tmp := 0 ;
48529: LD_ADDR_VAR 0 2
48533: PUSH
48534: LD_STRING 0
48536: ST_TO_ADDR
// if result [ 1 ] then
48537: LD_VAR 0 1
48541: PUSH
48542: LD_INT 1
48544: ARRAY
48545: IFFALSE 48610
// if result [ 1 ] [ 1 ] = i then
48547: LD_VAR 0 1
48551: PUSH
48552: LD_INT 1
48554: ARRAY
48555: PUSH
48556: LD_INT 1
48558: ARRAY
48559: PUSH
48560: LD_VAR 0 5
48564: EQUAL
48565: IFFALSE 48610
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48567: LD_ADDR_VAR 0 1
48571: PUSH
48572: LD_VAR 0 1
48576: PPUSH
48577: LD_INT 1
48579: PPUSH
48580: LD_VAR 0 1
48584: PUSH
48585: LD_INT 1
48587: ARRAY
48588: PPUSH
48589: LD_INT 1
48591: PPUSH
48592: CALL_OW 3
48596: PPUSH
48597: CALL_OW 1
48601: ST_TO_ADDR
// tmp := 1 ;
48602: LD_ADDR_VAR 0 2
48606: PUSH
48607: LD_STRING 1
48609: ST_TO_ADDR
// end ; normal := normal & tmp ;
48610: LD_ADDR_VAR 0 3
48614: PUSH
48615: LD_VAR 0 3
48619: PUSH
48620: LD_VAR 0 2
48624: STR
48625: ST_TO_ADDR
// end ;
48626: GO 48526
48628: POP
48629: POP
// for i = 1 to hardcoreCounter do
48630: LD_ADDR_VAR 0 5
48634: PUSH
48635: DOUBLE
48636: LD_INT 1
48638: DEC
48639: ST_TO_ADDR
48640: LD_EXP 94
48644: PUSH
48645: FOR_TO
48646: IFFALSE 48751
// begin tmp := 0 ;
48648: LD_ADDR_VAR 0 2
48652: PUSH
48653: LD_STRING 0
48655: ST_TO_ADDR
// if result [ 2 ] then
48656: LD_VAR 0 1
48660: PUSH
48661: LD_INT 2
48663: ARRAY
48664: IFFALSE 48733
// if result [ 2 ] [ 1 ] = 100 + i then
48666: LD_VAR 0 1
48670: PUSH
48671: LD_INT 2
48673: ARRAY
48674: PUSH
48675: LD_INT 1
48677: ARRAY
48678: PUSH
48679: LD_INT 100
48681: PUSH
48682: LD_VAR 0 5
48686: PLUS
48687: EQUAL
48688: IFFALSE 48733
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48690: LD_ADDR_VAR 0 1
48694: PUSH
48695: LD_VAR 0 1
48699: PPUSH
48700: LD_INT 2
48702: PPUSH
48703: LD_VAR 0 1
48707: PUSH
48708: LD_INT 2
48710: ARRAY
48711: PPUSH
48712: LD_INT 1
48714: PPUSH
48715: CALL_OW 3
48719: PPUSH
48720: CALL_OW 1
48724: ST_TO_ADDR
// tmp := 1 ;
48725: LD_ADDR_VAR 0 2
48729: PUSH
48730: LD_STRING 1
48732: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48733: LD_ADDR_VAR 0 4
48737: PUSH
48738: LD_VAR 0 4
48742: PUSH
48743: LD_VAR 0 2
48747: STR
48748: ST_TO_ADDR
// end ;
48749: GO 48645
48751: POP
48752: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48753: LD_STRING getStreamItemsFromMission("
48755: PUSH
48756: LD_VAR 0 3
48760: STR
48761: PUSH
48762: LD_STRING ","
48764: STR
48765: PUSH
48766: LD_VAR 0 4
48770: STR
48771: PUSH
48772: LD_STRING ")
48774: STR
48775: PPUSH
48776: CALL_OW 559
// end else
48780: GO 48789
// ToLua ( getStreamItemsFromMission("","") ) ;
48782: LD_STRING getStreamItemsFromMission("","")
48784: PPUSH
48785: CALL_OW 559
// end ;
48789: LD_VAR 0 1
48793: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48794: LD_EXP 92
48798: PUSH
48799: LD_EXP 97
48803: AND
48804: IFFALSE 48928
48806: GO 48808
48808: DISABLE
48809: LD_INT 0
48811: PPUSH
48812: PPUSH
// begin enable ;
48813: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48814: LD_ADDR_VAR 0 2
48818: PUSH
48819: LD_INT 22
48821: PUSH
48822: LD_OWVAR 2
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PUSH
48831: LD_INT 2
48833: PUSH
48834: LD_INT 34
48836: PUSH
48837: LD_INT 7
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: PUSH
48844: LD_INT 34
48846: PUSH
48847: LD_INT 45
48849: PUSH
48850: EMPTY
48851: LIST
48852: LIST
48853: PUSH
48854: LD_INT 34
48856: PUSH
48857: LD_INT 28
48859: PUSH
48860: EMPTY
48861: LIST
48862: LIST
48863: PUSH
48864: LD_INT 34
48866: PUSH
48867: LD_INT 47
48869: PUSH
48870: EMPTY
48871: LIST
48872: LIST
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: LIST
48878: LIST
48879: LIST
48880: PUSH
48881: EMPTY
48882: LIST
48883: LIST
48884: PPUSH
48885: CALL_OW 69
48889: ST_TO_ADDR
// if not tmp then
48890: LD_VAR 0 2
48894: NOT
48895: IFFALSE 48899
// exit ;
48897: GO 48928
// for i in tmp do
48899: LD_ADDR_VAR 0 1
48903: PUSH
48904: LD_VAR 0 2
48908: PUSH
48909: FOR_IN
48910: IFFALSE 48926
// begin SetLives ( i , 0 ) ;
48912: LD_VAR 0 1
48916: PPUSH
48917: LD_INT 0
48919: PPUSH
48920: CALL_OW 234
// end ;
48924: GO 48909
48926: POP
48927: POP
// end ;
48928: PPOPN 2
48930: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48931: LD_EXP 92
48935: PUSH
48936: LD_EXP 98
48940: AND
48941: IFFALSE 49025
48943: GO 48945
48945: DISABLE
48946: LD_INT 0
48948: PPUSH
48949: PPUSH
// begin enable ;
48950: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48951: LD_ADDR_VAR 0 2
48955: PUSH
48956: LD_INT 22
48958: PUSH
48959: LD_OWVAR 2
48963: PUSH
48964: EMPTY
48965: LIST
48966: LIST
48967: PUSH
48968: LD_INT 32
48970: PUSH
48971: LD_INT 3
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: PPUSH
48982: CALL_OW 69
48986: ST_TO_ADDR
// if not tmp then
48987: LD_VAR 0 2
48991: NOT
48992: IFFALSE 48996
// exit ;
48994: GO 49025
// for i in tmp do
48996: LD_ADDR_VAR 0 1
49000: PUSH
49001: LD_VAR 0 2
49005: PUSH
49006: FOR_IN
49007: IFFALSE 49023
// begin SetLives ( i , 0 ) ;
49009: LD_VAR 0 1
49013: PPUSH
49014: LD_INT 0
49016: PPUSH
49017: CALL_OW 234
// end ;
49021: GO 49006
49023: POP
49024: POP
// end ;
49025: PPOPN 2
49027: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49028: LD_EXP 92
49032: PUSH
49033: LD_EXP 95
49037: AND
49038: IFFALSE 49131
49040: GO 49042
49042: DISABLE
49043: LD_INT 0
49045: PPUSH
// begin enable ;
49046: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49047: LD_ADDR_VAR 0 1
49051: PUSH
49052: LD_INT 22
49054: PUSH
49055: LD_OWVAR 2
49059: PUSH
49060: EMPTY
49061: LIST
49062: LIST
49063: PUSH
49064: LD_INT 2
49066: PUSH
49067: LD_INT 25
49069: PUSH
49070: LD_INT 5
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: PUSH
49077: LD_INT 25
49079: PUSH
49080: LD_INT 9
49082: PUSH
49083: EMPTY
49084: LIST
49085: LIST
49086: PUSH
49087: LD_INT 25
49089: PUSH
49090: LD_INT 8
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: PUSH
49097: EMPTY
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: PUSH
49103: EMPTY
49104: LIST
49105: LIST
49106: PPUSH
49107: CALL_OW 69
49111: PUSH
49112: FOR_IN
49113: IFFALSE 49129
// begin SetClass ( i , 1 ) ;
49115: LD_VAR 0 1
49119: PPUSH
49120: LD_INT 1
49122: PPUSH
49123: CALL_OW 336
// end ;
49127: GO 49112
49129: POP
49130: POP
// end ;
49131: PPOPN 1
49133: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49134: LD_EXP 92
49138: PUSH
49139: LD_EXP 96
49143: AND
49144: PUSH
49145: LD_OWVAR 65
49149: PUSH
49150: LD_INT 7
49152: LESS
49153: AND
49154: IFFALSE 49168
49156: GO 49158
49158: DISABLE
// begin enable ;
49159: ENABLE
// game_speed := 7 ;
49160: LD_ADDR_OWVAR 65
49164: PUSH
49165: LD_INT 7
49167: ST_TO_ADDR
// end ;
49168: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49169: LD_EXP 92
49173: PUSH
49174: LD_EXP 99
49178: AND
49179: IFFALSE 49381
49181: GO 49183
49183: DISABLE
49184: LD_INT 0
49186: PPUSH
49187: PPUSH
49188: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49189: LD_ADDR_VAR 0 3
49193: PUSH
49194: LD_INT 81
49196: PUSH
49197: LD_OWVAR 2
49201: PUSH
49202: EMPTY
49203: LIST
49204: LIST
49205: PUSH
49206: LD_INT 21
49208: PUSH
49209: LD_INT 1
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: PPUSH
49220: CALL_OW 69
49224: ST_TO_ADDR
// if not tmp then
49225: LD_VAR 0 3
49229: NOT
49230: IFFALSE 49234
// exit ;
49232: GO 49381
// if tmp > 5 then
49234: LD_VAR 0 3
49238: PUSH
49239: LD_INT 5
49241: GREATER
49242: IFFALSE 49254
// k := 5 else
49244: LD_ADDR_VAR 0 2
49248: PUSH
49249: LD_INT 5
49251: ST_TO_ADDR
49252: GO 49264
// k := tmp ;
49254: LD_ADDR_VAR 0 2
49258: PUSH
49259: LD_VAR 0 3
49263: ST_TO_ADDR
// for i := 1 to k do
49264: LD_ADDR_VAR 0 1
49268: PUSH
49269: DOUBLE
49270: LD_INT 1
49272: DEC
49273: ST_TO_ADDR
49274: LD_VAR 0 2
49278: PUSH
49279: FOR_TO
49280: IFFALSE 49379
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49282: LD_VAR 0 3
49286: PUSH
49287: LD_VAR 0 1
49291: ARRAY
49292: PPUSH
49293: LD_VAR 0 1
49297: PUSH
49298: LD_INT 4
49300: MOD
49301: PUSH
49302: LD_INT 1
49304: PLUS
49305: PPUSH
49306: CALL_OW 259
49310: PUSH
49311: LD_INT 10
49313: LESS
49314: IFFALSE 49377
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49316: LD_VAR 0 3
49320: PUSH
49321: LD_VAR 0 1
49325: ARRAY
49326: PPUSH
49327: LD_VAR 0 1
49331: PUSH
49332: LD_INT 4
49334: MOD
49335: PUSH
49336: LD_INT 1
49338: PLUS
49339: PPUSH
49340: LD_VAR 0 3
49344: PUSH
49345: LD_VAR 0 1
49349: ARRAY
49350: PPUSH
49351: LD_VAR 0 1
49355: PUSH
49356: LD_INT 4
49358: MOD
49359: PUSH
49360: LD_INT 1
49362: PLUS
49363: PPUSH
49364: CALL_OW 259
49368: PUSH
49369: LD_INT 1
49371: PLUS
49372: PPUSH
49373: CALL_OW 237
49377: GO 49279
49379: POP
49380: POP
// end ;
49381: PPOPN 3
49383: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49384: LD_EXP 92
49388: PUSH
49389: LD_EXP 100
49393: AND
49394: IFFALSE 49414
49396: GO 49398
49398: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49399: LD_INT 4
49401: PPUSH
49402: LD_OWVAR 2
49406: PPUSH
49407: LD_INT 0
49409: PPUSH
49410: CALL_OW 324
49414: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49415: LD_EXP 92
49419: PUSH
49420: LD_EXP 129
49424: AND
49425: IFFALSE 49445
49427: GO 49429
49429: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49430: LD_INT 19
49432: PPUSH
49433: LD_OWVAR 2
49437: PPUSH
49438: LD_INT 0
49440: PPUSH
49441: CALL_OW 324
49445: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49446: LD_EXP 92
49450: PUSH
49451: LD_EXP 101
49455: AND
49456: IFFALSE 49558
49458: GO 49460
49460: DISABLE
49461: LD_INT 0
49463: PPUSH
49464: PPUSH
// begin enable ;
49465: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49466: LD_ADDR_VAR 0 2
49470: PUSH
49471: LD_INT 22
49473: PUSH
49474: LD_OWVAR 2
49478: PUSH
49479: EMPTY
49480: LIST
49481: LIST
49482: PUSH
49483: LD_INT 2
49485: PUSH
49486: LD_INT 34
49488: PUSH
49489: LD_INT 11
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 34
49498: PUSH
49499: LD_INT 30
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: LIST
49510: PUSH
49511: EMPTY
49512: LIST
49513: LIST
49514: PPUSH
49515: CALL_OW 69
49519: ST_TO_ADDR
// if not tmp then
49520: LD_VAR 0 2
49524: NOT
49525: IFFALSE 49529
// exit ;
49527: GO 49558
// for i in tmp do
49529: LD_ADDR_VAR 0 1
49533: PUSH
49534: LD_VAR 0 2
49538: PUSH
49539: FOR_IN
49540: IFFALSE 49556
// begin SetLives ( i , 0 ) ;
49542: LD_VAR 0 1
49546: PPUSH
49547: LD_INT 0
49549: PPUSH
49550: CALL_OW 234
// end ;
49554: GO 49539
49556: POP
49557: POP
// end ;
49558: PPOPN 2
49560: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49561: LD_EXP 92
49565: PUSH
49566: LD_EXP 102
49570: AND
49571: IFFALSE 49591
49573: GO 49575
49575: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49576: LD_INT 32
49578: PPUSH
49579: LD_OWVAR 2
49583: PPUSH
49584: LD_INT 0
49586: PPUSH
49587: CALL_OW 324
49591: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49592: LD_EXP 92
49596: PUSH
49597: LD_EXP 103
49601: AND
49602: IFFALSE 49783
49604: GO 49606
49606: DISABLE
49607: LD_INT 0
49609: PPUSH
49610: PPUSH
49611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49612: LD_ADDR_VAR 0 2
49616: PUSH
49617: LD_INT 22
49619: PUSH
49620: LD_OWVAR 2
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: PUSH
49629: LD_INT 33
49631: PUSH
49632: LD_INT 3
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PUSH
49639: EMPTY
49640: LIST
49641: LIST
49642: PPUSH
49643: CALL_OW 69
49647: ST_TO_ADDR
// if not tmp then
49648: LD_VAR 0 2
49652: NOT
49653: IFFALSE 49657
// exit ;
49655: GO 49783
// side := 0 ;
49657: LD_ADDR_VAR 0 3
49661: PUSH
49662: LD_INT 0
49664: ST_TO_ADDR
// for i := 1 to 8 do
49665: LD_ADDR_VAR 0 1
49669: PUSH
49670: DOUBLE
49671: LD_INT 1
49673: DEC
49674: ST_TO_ADDR
49675: LD_INT 8
49677: PUSH
49678: FOR_TO
49679: IFFALSE 49727
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49681: LD_OWVAR 2
49685: PUSH
49686: LD_VAR 0 1
49690: NONEQUAL
49691: PUSH
49692: LD_OWVAR 2
49696: PPUSH
49697: LD_VAR 0 1
49701: PPUSH
49702: CALL_OW 81
49706: PUSH
49707: LD_INT 2
49709: EQUAL
49710: AND
49711: IFFALSE 49725
// begin side := i ;
49713: LD_ADDR_VAR 0 3
49717: PUSH
49718: LD_VAR 0 1
49722: ST_TO_ADDR
// break ;
49723: GO 49727
// end ;
49725: GO 49678
49727: POP
49728: POP
// if not side then
49729: LD_VAR 0 3
49733: NOT
49734: IFFALSE 49738
// exit ;
49736: GO 49783
// for i := 1 to tmp do
49738: LD_ADDR_VAR 0 1
49742: PUSH
49743: DOUBLE
49744: LD_INT 1
49746: DEC
49747: ST_TO_ADDR
49748: LD_VAR 0 2
49752: PUSH
49753: FOR_TO
49754: IFFALSE 49781
// if Prob ( 60 ) then
49756: LD_INT 60
49758: PPUSH
49759: CALL_OW 13
49763: IFFALSE 49779
// SetSide ( i , side ) ;
49765: LD_VAR 0 1
49769: PPUSH
49770: LD_VAR 0 3
49774: PPUSH
49775: CALL_OW 235
49779: GO 49753
49781: POP
49782: POP
// end ;
49783: PPOPN 3
49785: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49786: LD_EXP 92
49790: PUSH
49791: LD_EXP 105
49795: AND
49796: IFFALSE 49915
49798: GO 49800
49800: DISABLE
49801: LD_INT 0
49803: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49804: LD_ADDR_VAR 0 1
49808: PUSH
49809: LD_INT 22
49811: PUSH
49812: LD_OWVAR 2
49816: PUSH
49817: EMPTY
49818: LIST
49819: LIST
49820: PUSH
49821: LD_INT 21
49823: PUSH
49824: LD_INT 1
49826: PUSH
49827: EMPTY
49828: LIST
49829: LIST
49830: PUSH
49831: LD_INT 3
49833: PUSH
49834: LD_INT 23
49836: PUSH
49837: LD_INT 0
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PUSH
49844: EMPTY
49845: LIST
49846: LIST
49847: PUSH
49848: EMPTY
49849: LIST
49850: LIST
49851: LIST
49852: PPUSH
49853: CALL_OW 69
49857: PUSH
49858: FOR_IN
49859: IFFALSE 49913
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49861: LD_VAR 0 1
49865: PPUSH
49866: CALL_OW 257
49870: PUSH
49871: LD_INT 1
49873: PUSH
49874: LD_INT 2
49876: PUSH
49877: LD_INT 3
49879: PUSH
49880: LD_INT 4
49882: PUSH
49883: EMPTY
49884: LIST
49885: LIST
49886: LIST
49887: LIST
49888: IN
49889: IFFALSE 49911
// SetClass ( un , rand ( 1 , 4 ) ) ;
49891: LD_VAR 0 1
49895: PPUSH
49896: LD_INT 1
49898: PPUSH
49899: LD_INT 4
49901: PPUSH
49902: CALL_OW 12
49906: PPUSH
49907: CALL_OW 336
49911: GO 49858
49913: POP
49914: POP
// end ;
49915: PPOPN 1
49917: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49918: LD_EXP 92
49922: PUSH
49923: LD_EXP 104
49927: AND
49928: IFFALSE 50007
49930: GO 49932
49932: DISABLE
49933: LD_INT 0
49935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49936: LD_ADDR_VAR 0 1
49940: PUSH
49941: LD_INT 22
49943: PUSH
49944: LD_OWVAR 2
49948: PUSH
49949: EMPTY
49950: LIST
49951: LIST
49952: PUSH
49953: LD_INT 21
49955: PUSH
49956: LD_INT 3
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PPUSH
49967: CALL_OW 69
49971: ST_TO_ADDR
// if not tmp then
49972: LD_VAR 0 1
49976: NOT
49977: IFFALSE 49981
// exit ;
49979: GO 50007
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49981: LD_VAR 0 1
49985: PUSH
49986: LD_INT 1
49988: PPUSH
49989: LD_VAR 0 1
49993: PPUSH
49994: CALL_OW 12
49998: ARRAY
49999: PPUSH
50000: LD_INT 100
50002: PPUSH
50003: CALL_OW 234
// end ;
50007: PPOPN 1
50009: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50010: LD_EXP 92
50014: PUSH
50015: LD_EXP 106
50019: AND
50020: IFFALSE 50118
50022: GO 50024
50024: DISABLE
50025: LD_INT 0
50027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50028: LD_ADDR_VAR 0 1
50032: PUSH
50033: LD_INT 22
50035: PUSH
50036: LD_OWVAR 2
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: PUSH
50045: LD_INT 21
50047: PUSH
50048: LD_INT 1
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: PPUSH
50059: CALL_OW 69
50063: ST_TO_ADDR
// if not tmp then
50064: LD_VAR 0 1
50068: NOT
50069: IFFALSE 50073
// exit ;
50071: GO 50118
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50073: LD_VAR 0 1
50077: PUSH
50078: LD_INT 1
50080: PPUSH
50081: LD_VAR 0 1
50085: PPUSH
50086: CALL_OW 12
50090: ARRAY
50091: PPUSH
50092: LD_INT 1
50094: PPUSH
50095: LD_INT 4
50097: PPUSH
50098: CALL_OW 12
50102: PPUSH
50103: LD_INT 3000
50105: PPUSH
50106: LD_INT 9000
50108: PPUSH
50109: CALL_OW 12
50113: PPUSH
50114: CALL_OW 492
// end ;
50118: PPOPN 1
50120: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50121: LD_EXP 92
50125: PUSH
50126: LD_EXP 107
50130: AND
50131: IFFALSE 50151
50133: GO 50135
50135: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50136: LD_INT 1
50138: PPUSH
50139: LD_OWVAR 2
50143: PPUSH
50144: LD_INT 0
50146: PPUSH
50147: CALL_OW 324
50151: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50152: LD_EXP 92
50156: PUSH
50157: LD_EXP 108
50161: AND
50162: IFFALSE 50245
50164: GO 50166
50166: DISABLE
50167: LD_INT 0
50169: PPUSH
50170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50171: LD_ADDR_VAR 0 2
50175: PUSH
50176: LD_INT 22
50178: PUSH
50179: LD_OWVAR 2
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 21
50190: PUSH
50191: LD_INT 3
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PPUSH
50202: CALL_OW 69
50206: ST_TO_ADDR
// if not tmp then
50207: LD_VAR 0 2
50211: NOT
50212: IFFALSE 50216
// exit ;
50214: GO 50245
// for i in tmp do
50216: LD_ADDR_VAR 0 1
50220: PUSH
50221: LD_VAR 0 2
50225: PUSH
50226: FOR_IN
50227: IFFALSE 50243
// SetBLevel ( i , 10 ) ;
50229: LD_VAR 0 1
50233: PPUSH
50234: LD_INT 10
50236: PPUSH
50237: CALL_OW 241
50241: GO 50226
50243: POP
50244: POP
// end ;
50245: PPOPN 2
50247: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50248: LD_EXP 92
50252: PUSH
50253: LD_EXP 109
50257: AND
50258: IFFALSE 50369
50260: GO 50262
50262: DISABLE
50263: LD_INT 0
50265: PPUSH
50266: PPUSH
50267: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50268: LD_ADDR_VAR 0 3
50272: PUSH
50273: LD_INT 22
50275: PUSH
50276: LD_OWVAR 2
50280: PUSH
50281: EMPTY
50282: LIST
50283: LIST
50284: PUSH
50285: LD_INT 25
50287: PUSH
50288: LD_INT 1
50290: PUSH
50291: EMPTY
50292: LIST
50293: LIST
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PPUSH
50299: CALL_OW 69
50303: ST_TO_ADDR
// if not tmp then
50304: LD_VAR 0 3
50308: NOT
50309: IFFALSE 50313
// exit ;
50311: GO 50369
// un := tmp [ rand ( 1 , tmp ) ] ;
50313: LD_ADDR_VAR 0 2
50317: PUSH
50318: LD_VAR 0 3
50322: PUSH
50323: LD_INT 1
50325: PPUSH
50326: LD_VAR 0 3
50330: PPUSH
50331: CALL_OW 12
50335: ARRAY
50336: ST_TO_ADDR
// if Crawls ( un ) then
50337: LD_VAR 0 2
50341: PPUSH
50342: CALL_OW 318
50346: IFFALSE 50357
// ComWalk ( un ) ;
50348: LD_VAR 0 2
50352: PPUSH
50353: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50357: LD_VAR 0 2
50361: PPUSH
50362: LD_INT 5
50364: PPUSH
50365: CALL_OW 336
// end ;
50369: PPOPN 3
50371: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50372: LD_EXP 92
50376: PUSH
50377: LD_EXP 110
50381: AND
50382: PUSH
50383: LD_OWVAR 67
50387: PUSH
50388: LD_INT 4
50390: LESS
50391: AND
50392: IFFALSE 50411
50394: GO 50396
50396: DISABLE
// begin Difficulty := Difficulty + 1 ;
50397: LD_ADDR_OWVAR 67
50401: PUSH
50402: LD_OWVAR 67
50406: PUSH
50407: LD_INT 1
50409: PLUS
50410: ST_TO_ADDR
// end ;
50411: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50412: LD_EXP 92
50416: PUSH
50417: LD_EXP 111
50421: AND
50422: IFFALSE 50525
50424: GO 50426
50426: DISABLE
50427: LD_INT 0
50429: PPUSH
// begin for i := 1 to 5 do
50430: LD_ADDR_VAR 0 1
50434: PUSH
50435: DOUBLE
50436: LD_INT 1
50438: DEC
50439: ST_TO_ADDR
50440: LD_INT 5
50442: PUSH
50443: FOR_TO
50444: IFFALSE 50523
// begin uc_nation := nation_nature ;
50446: LD_ADDR_OWVAR 21
50450: PUSH
50451: LD_INT 0
50453: ST_TO_ADDR
// uc_side := 0 ;
50454: LD_ADDR_OWVAR 20
50458: PUSH
50459: LD_INT 0
50461: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50462: LD_ADDR_OWVAR 29
50466: PUSH
50467: LD_INT 12
50469: PUSH
50470: LD_INT 12
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: ST_TO_ADDR
// hc_agressivity := 20 ;
50477: LD_ADDR_OWVAR 35
50481: PUSH
50482: LD_INT 20
50484: ST_TO_ADDR
// hc_class := class_tiger ;
50485: LD_ADDR_OWVAR 28
50489: PUSH
50490: LD_INT 14
50492: ST_TO_ADDR
// hc_gallery :=  ;
50493: LD_ADDR_OWVAR 33
50497: PUSH
50498: LD_STRING 
50500: ST_TO_ADDR
// hc_name :=  ;
50501: LD_ADDR_OWVAR 26
50505: PUSH
50506: LD_STRING 
50508: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50509: CALL_OW 44
50513: PPUSH
50514: LD_INT 0
50516: PPUSH
50517: CALL_OW 51
// end ;
50521: GO 50443
50523: POP
50524: POP
// end ;
50525: PPOPN 1
50527: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50528: LD_EXP 92
50532: PUSH
50533: LD_EXP 112
50537: AND
50538: IFFALSE 50547
50540: GO 50542
50542: DISABLE
// StreamSibBomb ;
50543: CALL 50548 0 0
50547: END
// export function StreamSibBomb ; var i , x , y ; begin
50548: LD_INT 0
50550: PPUSH
50551: PPUSH
50552: PPUSH
50553: PPUSH
// result := false ;
50554: LD_ADDR_VAR 0 1
50558: PUSH
50559: LD_INT 0
50561: ST_TO_ADDR
// for i := 1 to 16 do
50562: LD_ADDR_VAR 0 2
50566: PUSH
50567: DOUBLE
50568: LD_INT 1
50570: DEC
50571: ST_TO_ADDR
50572: LD_INT 16
50574: PUSH
50575: FOR_TO
50576: IFFALSE 50775
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50578: LD_ADDR_VAR 0 3
50582: PUSH
50583: LD_INT 10
50585: PUSH
50586: LD_INT 20
50588: PUSH
50589: LD_INT 30
50591: PUSH
50592: LD_INT 40
50594: PUSH
50595: LD_INT 50
50597: PUSH
50598: LD_INT 60
50600: PUSH
50601: LD_INT 70
50603: PUSH
50604: LD_INT 80
50606: PUSH
50607: LD_INT 90
50609: PUSH
50610: LD_INT 100
50612: PUSH
50613: LD_INT 110
50615: PUSH
50616: LD_INT 120
50618: PUSH
50619: LD_INT 130
50621: PUSH
50622: LD_INT 140
50624: PUSH
50625: LD_INT 150
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: LIST
50632: LIST
50633: LIST
50634: LIST
50635: LIST
50636: LIST
50637: LIST
50638: LIST
50639: LIST
50640: LIST
50641: LIST
50642: LIST
50643: LIST
50644: PUSH
50645: LD_INT 1
50647: PPUSH
50648: LD_INT 15
50650: PPUSH
50651: CALL_OW 12
50655: ARRAY
50656: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50657: LD_ADDR_VAR 0 4
50661: PUSH
50662: LD_INT 10
50664: PUSH
50665: LD_INT 20
50667: PUSH
50668: LD_INT 30
50670: PUSH
50671: LD_INT 40
50673: PUSH
50674: LD_INT 50
50676: PUSH
50677: LD_INT 60
50679: PUSH
50680: LD_INT 70
50682: PUSH
50683: LD_INT 80
50685: PUSH
50686: LD_INT 90
50688: PUSH
50689: LD_INT 100
50691: PUSH
50692: LD_INT 110
50694: PUSH
50695: LD_INT 120
50697: PUSH
50698: LD_INT 130
50700: PUSH
50701: LD_INT 140
50703: PUSH
50704: LD_INT 150
50706: PUSH
50707: EMPTY
50708: LIST
50709: LIST
50710: LIST
50711: LIST
50712: LIST
50713: LIST
50714: LIST
50715: LIST
50716: LIST
50717: LIST
50718: LIST
50719: LIST
50720: LIST
50721: LIST
50722: LIST
50723: PUSH
50724: LD_INT 1
50726: PPUSH
50727: LD_INT 15
50729: PPUSH
50730: CALL_OW 12
50734: ARRAY
50735: ST_TO_ADDR
// if ValidHex ( x , y ) then
50736: LD_VAR 0 3
50740: PPUSH
50741: LD_VAR 0 4
50745: PPUSH
50746: CALL_OW 488
50750: IFFALSE 50773
// begin result := [ x , y ] ;
50752: LD_ADDR_VAR 0 1
50756: PUSH
50757: LD_VAR 0 3
50761: PUSH
50762: LD_VAR 0 4
50766: PUSH
50767: EMPTY
50768: LIST
50769: LIST
50770: ST_TO_ADDR
// break ;
50771: GO 50775
// end ; end ;
50773: GO 50575
50775: POP
50776: POP
// if result then
50777: LD_VAR 0 1
50781: IFFALSE 50841
// begin ToLua ( playSibBomb() ) ;
50783: LD_STRING playSibBomb()
50785: PPUSH
50786: CALL_OW 559
// wait ( 0 0$14 ) ;
50790: LD_INT 490
50792: PPUSH
50793: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50797: LD_VAR 0 1
50801: PUSH
50802: LD_INT 1
50804: ARRAY
50805: PPUSH
50806: LD_VAR 0 1
50810: PUSH
50811: LD_INT 2
50813: ARRAY
50814: PPUSH
50815: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50819: LD_VAR 0 1
50823: PUSH
50824: LD_INT 1
50826: ARRAY
50827: PPUSH
50828: LD_VAR 0 1
50832: PUSH
50833: LD_INT 2
50835: ARRAY
50836: PPUSH
50837: CALL_OW 429
// end ; end ;
50841: LD_VAR 0 1
50845: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50846: LD_EXP 92
50850: PUSH
50851: LD_EXP 114
50855: AND
50856: IFFALSE 50868
50858: GO 50860
50860: DISABLE
// YouLost (  ) ;
50861: LD_STRING 
50863: PPUSH
50864: CALL_OW 104
50868: END
// every 0 0$1 trigger StreamModeActive and sFog do
50869: LD_EXP 92
50873: PUSH
50874: LD_EXP 113
50878: AND
50879: IFFALSE 50893
50881: GO 50883
50883: DISABLE
// FogOff ( your_side ) ;
50884: LD_OWVAR 2
50888: PPUSH
50889: CALL_OW 344
50893: END
// every 0 0$1 trigger StreamModeActive and sSun do
50894: LD_EXP 92
50898: PUSH
50899: LD_EXP 115
50903: AND
50904: IFFALSE 50932
50906: GO 50908
50908: DISABLE
// begin solar_recharge_percent := 0 ;
50909: LD_ADDR_OWVAR 79
50913: PUSH
50914: LD_INT 0
50916: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50917: LD_INT 10500
50919: PPUSH
50920: CALL_OW 67
// solar_recharge_percent := 100 ;
50924: LD_ADDR_OWVAR 79
50928: PUSH
50929: LD_INT 100
50931: ST_TO_ADDR
// end ;
50932: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50933: LD_EXP 92
50937: PUSH
50938: LD_EXP 116
50942: AND
50943: IFFALSE 51182
50945: GO 50947
50947: DISABLE
50948: LD_INT 0
50950: PPUSH
50951: PPUSH
50952: PPUSH
// begin tmp := [ ] ;
50953: LD_ADDR_VAR 0 3
50957: PUSH
50958: EMPTY
50959: ST_TO_ADDR
// for i := 1 to 6 do
50960: LD_ADDR_VAR 0 1
50964: PUSH
50965: DOUBLE
50966: LD_INT 1
50968: DEC
50969: ST_TO_ADDR
50970: LD_INT 6
50972: PUSH
50973: FOR_TO
50974: IFFALSE 51079
// begin uc_nation := nation_nature ;
50976: LD_ADDR_OWVAR 21
50980: PUSH
50981: LD_INT 0
50983: ST_TO_ADDR
// uc_side := 0 ;
50984: LD_ADDR_OWVAR 20
50988: PUSH
50989: LD_INT 0
50991: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50992: LD_ADDR_OWVAR 29
50996: PUSH
50997: LD_INT 12
50999: PUSH
51000: LD_INT 12
51002: PUSH
51003: EMPTY
51004: LIST
51005: LIST
51006: ST_TO_ADDR
// hc_agressivity := 20 ;
51007: LD_ADDR_OWVAR 35
51011: PUSH
51012: LD_INT 20
51014: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51015: LD_ADDR_OWVAR 28
51019: PUSH
51020: LD_INT 17
51022: ST_TO_ADDR
// hc_gallery :=  ;
51023: LD_ADDR_OWVAR 33
51027: PUSH
51028: LD_STRING 
51030: ST_TO_ADDR
// hc_name :=  ;
51031: LD_ADDR_OWVAR 26
51035: PUSH
51036: LD_STRING 
51038: ST_TO_ADDR
// un := CreateHuman ;
51039: LD_ADDR_VAR 0 2
51043: PUSH
51044: CALL_OW 44
51048: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51049: LD_VAR 0 2
51053: PPUSH
51054: LD_INT 1
51056: PPUSH
51057: CALL_OW 51
// tmp := tmp ^ un ;
51061: LD_ADDR_VAR 0 3
51065: PUSH
51066: LD_VAR 0 3
51070: PUSH
51071: LD_VAR 0 2
51075: ADD
51076: ST_TO_ADDR
// end ;
51077: GO 50973
51079: POP
51080: POP
// repeat wait ( 0 0$1 ) ;
51081: LD_INT 35
51083: PPUSH
51084: CALL_OW 67
// for un in tmp do
51088: LD_ADDR_VAR 0 2
51092: PUSH
51093: LD_VAR 0 3
51097: PUSH
51098: FOR_IN
51099: IFFALSE 51173
// begin if IsDead ( un ) then
51101: LD_VAR 0 2
51105: PPUSH
51106: CALL_OW 301
51110: IFFALSE 51130
// begin tmp := tmp diff un ;
51112: LD_ADDR_VAR 0 3
51116: PUSH
51117: LD_VAR 0 3
51121: PUSH
51122: LD_VAR 0 2
51126: DIFF
51127: ST_TO_ADDR
// continue ;
51128: GO 51098
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51130: LD_VAR 0 2
51134: PPUSH
51135: LD_INT 3
51137: PUSH
51138: LD_INT 22
51140: PUSH
51141: LD_INT 0
51143: PUSH
51144: EMPTY
51145: LIST
51146: LIST
51147: PUSH
51148: EMPTY
51149: LIST
51150: LIST
51151: PPUSH
51152: CALL_OW 69
51156: PPUSH
51157: LD_VAR 0 2
51161: PPUSH
51162: CALL_OW 74
51166: PPUSH
51167: CALL_OW 115
// end ;
51171: GO 51098
51173: POP
51174: POP
// until not tmp ;
51175: LD_VAR 0 3
51179: NOT
51180: IFFALSE 51081
// end ;
51182: PPOPN 3
51184: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51185: LD_EXP 92
51189: PUSH
51190: LD_EXP 117
51194: AND
51195: IFFALSE 51249
51197: GO 51199
51199: DISABLE
// begin ToLua ( displayTroll(); ) ;
51200: LD_STRING displayTroll();
51202: PPUSH
51203: CALL_OW 559
// wait ( 3 3$00 ) ;
51207: LD_INT 6300
51209: PPUSH
51210: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51214: LD_STRING hideTroll();
51216: PPUSH
51217: CALL_OW 559
// wait ( 1 1$00 ) ;
51221: LD_INT 2100
51223: PPUSH
51224: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51228: LD_STRING displayTroll();
51230: PPUSH
51231: CALL_OW 559
// wait ( 1 1$00 ) ;
51235: LD_INT 2100
51237: PPUSH
51238: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51242: LD_STRING hideTroll();
51244: PPUSH
51245: CALL_OW 559
// end ;
51249: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51250: LD_EXP 92
51254: PUSH
51255: LD_EXP 118
51259: AND
51260: IFFALSE 51323
51262: GO 51264
51264: DISABLE
51265: LD_INT 0
51267: PPUSH
// begin p := 0 ;
51268: LD_ADDR_VAR 0 1
51272: PUSH
51273: LD_INT 0
51275: ST_TO_ADDR
// repeat game_speed := 1 ;
51276: LD_ADDR_OWVAR 65
51280: PUSH
51281: LD_INT 1
51283: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51284: LD_INT 35
51286: PPUSH
51287: CALL_OW 67
// p := p + 1 ;
51291: LD_ADDR_VAR 0 1
51295: PUSH
51296: LD_VAR 0 1
51300: PUSH
51301: LD_INT 1
51303: PLUS
51304: ST_TO_ADDR
// until p >= 60 ;
51305: LD_VAR 0 1
51309: PUSH
51310: LD_INT 60
51312: GREATEREQUAL
51313: IFFALSE 51276
// game_speed := 4 ;
51315: LD_ADDR_OWVAR 65
51319: PUSH
51320: LD_INT 4
51322: ST_TO_ADDR
// end ;
51323: PPOPN 1
51325: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51326: LD_EXP 92
51330: PUSH
51331: LD_EXP 119
51335: AND
51336: IFFALSE 51482
51338: GO 51340
51340: DISABLE
51341: LD_INT 0
51343: PPUSH
51344: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51345: LD_ADDR_VAR 0 1
51349: PUSH
51350: LD_INT 22
51352: PUSH
51353: LD_OWVAR 2
51357: PUSH
51358: EMPTY
51359: LIST
51360: LIST
51361: PUSH
51362: LD_INT 2
51364: PUSH
51365: LD_INT 30
51367: PUSH
51368: LD_INT 0
51370: PUSH
51371: EMPTY
51372: LIST
51373: LIST
51374: PUSH
51375: LD_INT 30
51377: PUSH
51378: LD_INT 1
51380: PUSH
51381: EMPTY
51382: LIST
51383: LIST
51384: PUSH
51385: EMPTY
51386: LIST
51387: LIST
51388: LIST
51389: PUSH
51390: EMPTY
51391: LIST
51392: LIST
51393: PPUSH
51394: CALL_OW 69
51398: ST_TO_ADDR
// if not depot then
51399: LD_VAR 0 1
51403: NOT
51404: IFFALSE 51408
// exit ;
51406: GO 51482
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51408: LD_ADDR_VAR 0 2
51412: PUSH
51413: LD_VAR 0 1
51417: PUSH
51418: LD_INT 1
51420: PPUSH
51421: LD_VAR 0 1
51425: PPUSH
51426: CALL_OW 12
51430: ARRAY
51431: PPUSH
51432: CALL_OW 274
51436: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51437: LD_VAR 0 2
51441: PPUSH
51442: LD_INT 1
51444: PPUSH
51445: LD_INT 0
51447: PPUSH
51448: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51452: LD_VAR 0 2
51456: PPUSH
51457: LD_INT 2
51459: PPUSH
51460: LD_INT 0
51462: PPUSH
51463: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51467: LD_VAR 0 2
51471: PPUSH
51472: LD_INT 3
51474: PPUSH
51475: LD_INT 0
51477: PPUSH
51478: CALL_OW 277
// end ;
51482: PPOPN 2
51484: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51485: LD_EXP 92
51489: PUSH
51490: LD_EXP 120
51494: AND
51495: IFFALSE 51592
51497: GO 51499
51499: DISABLE
51500: LD_INT 0
51502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51503: LD_ADDR_VAR 0 1
51507: PUSH
51508: LD_INT 22
51510: PUSH
51511: LD_OWVAR 2
51515: PUSH
51516: EMPTY
51517: LIST
51518: LIST
51519: PUSH
51520: LD_INT 21
51522: PUSH
51523: LD_INT 1
51525: PUSH
51526: EMPTY
51527: LIST
51528: LIST
51529: PUSH
51530: LD_INT 3
51532: PUSH
51533: LD_INT 23
51535: PUSH
51536: LD_INT 0
51538: PUSH
51539: EMPTY
51540: LIST
51541: LIST
51542: PUSH
51543: EMPTY
51544: LIST
51545: LIST
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: LIST
51551: PPUSH
51552: CALL_OW 69
51556: ST_TO_ADDR
// if not tmp then
51557: LD_VAR 0 1
51561: NOT
51562: IFFALSE 51566
// exit ;
51564: GO 51592
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51566: LD_VAR 0 1
51570: PUSH
51571: LD_INT 1
51573: PPUSH
51574: LD_VAR 0 1
51578: PPUSH
51579: CALL_OW 12
51583: ARRAY
51584: PPUSH
51585: LD_INT 200
51587: PPUSH
51588: CALL_OW 234
// end ;
51592: PPOPN 1
51594: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51595: LD_EXP 92
51599: PUSH
51600: LD_EXP 121
51604: AND
51605: IFFALSE 51684
51607: GO 51609
51609: DISABLE
51610: LD_INT 0
51612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51613: LD_ADDR_VAR 0 1
51617: PUSH
51618: LD_INT 22
51620: PUSH
51621: LD_OWVAR 2
51625: PUSH
51626: EMPTY
51627: LIST
51628: LIST
51629: PUSH
51630: LD_INT 21
51632: PUSH
51633: LD_INT 2
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: PUSH
51640: EMPTY
51641: LIST
51642: LIST
51643: PPUSH
51644: CALL_OW 69
51648: ST_TO_ADDR
// if not tmp then
51649: LD_VAR 0 1
51653: NOT
51654: IFFALSE 51658
// exit ;
51656: GO 51684
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51658: LD_VAR 0 1
51662: PUSH
51663: LD_INT 1
51665: PPUSH
51666: LD_VAR 0 1
51670: PPUSH
51671: CALL_OW 12
51675: ARRAY
51676: PPUSH
51677: LD_INT 60
51679: PPUSH
51680: CALL_OW 234
// end ;
51684: PPOPN 1
51686: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51687: LD_EXP 92
51691: PUSH
51692: LD_EXP 122
51696: AND
51697: IFFALSE 51796
51699: GO 51701
51701: DISABLE
51702: LD_INT 0
51704: PPUSH
51705: PPUSH
// begin enable ;
51706: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51707: LD_ADDR_VAR 0 1
51711: PUSH
51712: LD_INT 22
51714: PUSH
51715: LD_OWVAR 2
51719: PUSH
51720: EMPTY
51721: LIST
51722: LIST
51723: PUSH
51724: LD_INT 61
51726: PUSH
51727: EMPTY
51728: LIST
51729: PUSH
51730: LD_INT 33
51732: PUSH
51733: LD_INT 2
51735: PUSH
51736: EMPTY
51737: LIST
51738: LIST
51739: PUSH
51740: EMPTY
51741: LIST
51742: LIST
51743: LIST
51744: PPUSH
51745: CALL_OW 69
51749: ST_TO_ADDR
// if not tmp then
51750: LD_VAR 0 1
51754: NOT
51755: IFFALSE 51759
// exit ;
51757: GO 51796
// for i in tmp do
51759: LD_ADDR_VAR 0 2
51763: PUSH
51764: LD_VAR 0 1
51768: PUSH
51769: FOR_IN
51770: IFFALSE 51794
// if IsControledBy ( i ) then
51772: LD_VAR 0 2
51776: PPUSH
51777: CALL_OW 312
51781: IFFALSE 51792
// ComUnlink ( i ) ;
51783: LD_VAR 0 2
51787: PPUSH
51788: CALL_OW 136
51792: GO 51769
51794: POP
51795: POP
// end ;
51796: PPOPN 2
51798: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51799: LD_EXP 92
51803: PUSH
51804: LD_EXP 123
51808: AND
51809: IFFALSE 51949
51811: GO 51813
51813: DISABLE
51814: LD_INT 0
51816: PPUSH
51817: PPUSH
// begin ToLua ( displayPowell(); ) ;
51818: LD_STRING displayPowell();
51820: PPUSH
51821: CALL_OW 559
// uc_side := 0 ;
51825: LD_ADDR_OWVAR 20
51829: PUSH
51830: LD_INT 0
51832: ST_TO_ADDR
// uc_nation := 2 ;
51833: LD_ADDR_OWVAR 21
51837: PUSH
51838: LD_INT 2
51840: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51841: LD_ADDR_OWVAR 37
51845: PUSH
51846: LD_INT 14
51848: ST_TO_ADDR
// vc_engine := engine_siberite ;
51849: LD_ADDR_OWVAR 39
51853: PUSH
51854: LD_INT 3
51856: ST_TO_ADDR
// vc_control := control_apeman ;
51857: LD_ADDR_OWVAR 38
51861: PUSH
51862: LD_INT 5
51864: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51865: LD_ADDR_OWVAR 40
51869: PUSH
51870: LD_INT 29
51872: ST_TO_ADDR
// un := CreateVehicle ;
51873: LD_ADDR_VAR 0 2
51877: PUSH
51878: CALL_OW 45
51882: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51883: LD_VAR 0 2
51887: PPUSH
51888: LD_INT 1
51890: PPUSH
51891: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51895: LD_INT 35
51897: PPUSH
51898: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51902: LD_VAR 0 2
51906: PPUSH
51907: LD_INT 22
51909: PUSH
51910: LD_OWVAR 2
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: PPUSH
51919: CALL_OW 69
51923: PPUSH
51924: LD_VAR 0 2
51928: PPUSH
51929: CALL_OW 74
51933: PPUSH
51934: CALL_OW 115
// until IsDead ( un ) ;
51938: LD_VAR 0 2
51942: PPUSH
51943: CALL_OW 301
51947: IFFALSE 51895
// end ;
51949: PPOPN 2
51951: END
// every 0 0$1 trigger StreamModeActive and sStu do
51952: LD_EXP 92
51956: PUSH
51957: LD_EXP 131
51961: AND
51962: IFFALSE 51978
51964: GO 51966
51966: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51967: LD_STRING displayStucuk();
51969: PPUSH
51970: CALL_OW 559
// ResetFog ;
51974: CALL_OW 335
// end ;
51978: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51979: LD_EXP 92
51983: PUSH
51984: LD_EXP 124
51988: AND
51989: IFFALSE 52130
51991: GO 51993
51993: DISABLE
51994: LD_INT 0
51996: PPUSH
51997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51998: LD_ADDR_VAR 0 2
52002: PUSH
52003: LD_INT 22
52005: PUSH
52006: LD_OWVAR 2
52010: PUSH
52011: EMPTY
52012: LIST
52013: LIST
52014: PUSH
52015: LD_INT 21
52017: PUSH
52018: LD_INT 1
52020: PUSH
52021: EMPTY
52022: LIST
52023: LIST
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: PPUSH
52029: CALL_OW 69
52033: ST_TO_ADDR
// if not tmp then
52034: LD_VAR 0 2
52038: NOT
52039: IFFALSE 52043
// exit ;
52041: GO 52130
// un := tmp [ rand ( 1 , tmp ) ] ;
52043: LD_ADDR_VAR 0 1
52047: PUSH
52048: LD_VAR 0 2
52052: PUSH
52053: LD_INT 1
52055: PPUSH
52056: LD_VAR 0 2
52060: PPUSH
52061: CALL_OW 12
52065: ARRAY
52066: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52067: LD_VAR 0 1
52071: PPUSH
52072: LD_INT 0
52074: PPUSH
52075: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52079: LD_VAR 0 1
52083: PPUSH
52084: LD_OWVAR 3
52088: PUSH
52089: LD_VAR 0 1
52093: DIFF
52094: PPUSH
52095: LD_VAR 0 1
52099: PPUSH
52100: CALL_OW 74
52104: PPUSH
52105: CALL_OW 115
// wait ( 0 0$20 ) ;
52109: LD_INT 700
52111: PPUSH
52112: CALL_OW 67
// SetSide ( un , your_side ) ;
52116: LD_VAR 0 1
52120: PPUSH
52121: LD_OWVAR 2
52125: PPUSH
52126: CALL_OW 235
// end ;
52130: PPOPN 2
52132: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52133: LD_EXP 92
52137: PUSH
52138: LD_EXP 125
52142: AND
52143: IFFALSE 52249
52145: GO 52147
52147: DISABLE
52148: LD_INT 0
52150: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52151: LD_ADDR_VAR 0 1
52155: PUSH
52156: LD_INT 22
52158: PUSH
52159: LD_OWVAR 2
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: PUSH
52168: LD_INT 2
52170: PUSH
52171: LD_INT 30
52173: PUSH
52174: LD_INT 0
52176: PUSH
52177: EMPTY
52178: LIST
52179: LIST
52180: PUSH
52181: LD_INT 30
52183: PUSH
52184: LD_INT 1
52186: PUSH
52187: EMPTY
52188: LIST
52189: LIST
52190: PUSH
52191: EMPTY
52192: LIST
52193: LIST
52194: LIST
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: PPUSH
52200: CALL_OW 69
52204: ST_TO_ADDR
// if not depot then
52205: LD_VAR 0 1
52209: NOT
52210: IFFALSE 52214
// exit ;
52212: GO 52249
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52214: LD_VAR 0 1
52218: PUSH
52219: LD_INT 1
52221: ARRAY
52222: PPUSH
52223: CALL_OW 250
52227: PPUSH
52228: LD_VAR 0 1
52232: PUSH
52233: LD_INT 1
52235: ARRAY
52236: PPUSH
52237: CALL_OW 251
52241: PPUSH
52242: LD_INT 70
52244: PPUSH
52245: CALL_OW 495
// end ;
52249: PPOPN 1
52251: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52252: LD_EXP 92
52256: PUSH
52257: LD_EXP 126
52261: AND
52262: IFFALSE 52473
52264: GO 52266
52266: DISABLE
52267: LD_INT 0
52269: PPUSH
52270: PPUSH
52271: PPUSH
52272: PPUSH
52273: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52274: LD_ADDR_VAR 0 5
52278: PUSH
52279: LD_INT 22
52281: PUSH
52282: LD_OWVAR 2
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: PUSH
52291: LD_INT 21
52293: PUSH
52294: LD_INT 1
52296: PUSH
52297: EMPTY
52298: LIST
52299: LIST
52300: PUSH
52301: EMPTY
52302: LIST
52303: LIST
52304: PPUSH
52305: CALL_OW 69
52309: ST_TO_ADDR
// if not tmp then
52310: LD_VAR 0 5
52314: NOT
52315: IFFALSE 52319
// exit ;
52317: GO 52473
// for i in tmp do
52319: LD_ADDR_VAR 0 1
52323: PUSH
52324: LD_VAR 0 5
52328: PUSH
52329: FOR_IN
52330: IFFALSE 52471
// begin d := rand ( 0 , 5 ) ;
52332: LD_ADDR_VAR 0 4
52336: PUSH
52337: LD_INT 0
52339: PPUSH
52340: LD_INT 5
52342: PPUSH
52343: CALL_OW 12
52347: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52348: LD_ADDR_VAR 0 2
52352: PUSH
52353: LD_VAR 0 1
52357: PPUSH
52358: CALL_OW 250
52362: PPUSH
52363: LD_VAR 0 4
52367: PPUSH
52368: LD_INT 3
52370: PPUSH
52371: LD_INT 12
52373: PPUSH
52374: CALL_OW 12
52378: PPUSH
52379: CALL_OW 272
52383: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52384: LD_ADDR_VAR 0 3
52388: PUSH
52389: LD_VAR 0 1
52393: PPUSH
52394: CALL_OW 251
52398: PPUSH
52399: LD_VAR 0 4
52403: PPUSH
52404: LD_INT 3
52406: PPUSH
52407: LD_INT 12
52409: PPUSH
52410: CALL_OW 12
52414: PPUSH
52415: CALL_OW 273
52419: ST_TO_ADDR
// if ValidHex ( x , y ) then
52420: LD_VAR 0 2
52424: PPUSH
52425: LD_VAR 0 3
52429: PPUSH
52430: CALL_OW 488
52434: IFFALSE 52469
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52436: LD_VAR 0 1
52440: PPUSH
52441: LD_VAR 0 2
52445: PPUSH
52446: LD_VAR 0 3
52450: PPUSH
52451: LD_INT 3
52453: PPUSH
52454: LD_INT 6
52456: PPUSH
52457: CALL_OW 12
52461: PPUSH
52462: LD_INT 1
52464: PPUSH
52465: CALL_OW 483
// end ;
52469: GO 52329
52471: POP
52472: POP
// end ;
52473: PPOPN 5
52475: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52476: LD_EXP 92
52480: PUSH
52481: LD_EXP 127
52485: AND
52486: IFFALSE 52580
52488: GO 52490
52490: DISABLE
52491: LD_INT 0
52493: PPUSH
52494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52495: LD_ADDR_VAR 0 2
52499: PUSH
52500: LD_INT 22
52502: PUSH
52503: LD_OWVAR 2
52507: PUSH
52508: EMPTY
52509: LIST
52510: LIST
52511: PUSH
52512: LD_INT 32
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: EMPTY
52519: LIST
52520: LIST
52521: PUSH
52522: LD_INT 21
52524: PUSH
52525: LD_INT 2
52527: PUSH
52528: EMPTY
52529: LIST
52530: LIST
52531: PUSH
52532: EMPTY
52533: LIST
52534: LIST
52535: LIST
52536: PPUSH
52537: CALL_OW 69
52541: ST_TO_ADDR
// if not tmp then
52542: LD_VAR 0 2
52546: NOT
52547: IFFALSE 52551
// exit ;
52549: GO 52580
// for i in tmp do
52551: LD_ADDR_VAR 0 1
52555: PUSH
52556: LD_VAR 0 2
52560: PUSH
52561: FOR_IN
52562: IFFALSE 52578
// SetFuel ( i , 0 ) ;
52564: LD_VAR 0 1
52568: PPUSH
52569: LD_INT 0
52571: PPUSH
52572: CALL_OW 240
52576: GO 52561
52578: POP
52579: POP
// end ;
52580: PPOPN 2
52582: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52583: LD_EXP 92
52587: PUSH
52588: LD_EXP 128
52592: AND
52593: IFFALSE 52659
52595: GO 52597
52597: DISABLE
52598: LD_INT 0
52600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52601: LD_ADDR_VAR 0 1
52605: PUSH
52606: LD_INT 22
52608: PUSH
52609: LD_OWVAR 2
52613: PUSH
52614: EMPTY
52615: LIST
52616: LIST
52617: PUSH
52618: LD_INT 30
52620: PUSH
52621: LD_INT 29
52623: PUSH
52624: EMPTY
52625: LIST
52626: LIST
52627: PUSH
52628: EMPTY
52629: LIST
52630: LIST
52631: PPUSH
52632: CALL_OW 69
52636: ST_TO_ADDR
// if not tmp then
52637: LD_VAR 0 1
52641: NOT
52642: IFFALSE 52646
// exit ;
52644: GO 52659
// DestroyUnit ( tmp [ 1 ] ) ;
52646: LD_VAR 0 1
52650: PUSH
52651: LD_INT 1
52653: ARRAY
52654: PPUSH
52655: CALL_OW 65
// end ;
52659: PPOPN 1
52661: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52662: LD_EXP 92
52666: PUSH
52667: LD_EXP 130
52671: AND
52672: IFFALSE 52801
52674: GO 52676
52676: DISABLE
52677: LD_INT 0
52679: PPUSH
// begin uc_side := 0 ;
52680: LD_ADDR_OWVAR 20
52684: PUSH
52685: LD_INT 0
52687: ST_TO_ADDR
// uc_nation := nation_arabian ;
52688: LD_ADDR_OWVAR 21
52692: PUSH
52693: LD_INT 2
52695: ST_TO_ADDR
// hc_gallery :=  ;
52696: LD_ADDR_OWVAR 33
52700: PUSH
52701: LD_STRING 
52703: ST_TO_ADDR
// hc_name :=  ;
52704: LD_ADDR_OWVAR 26
52708: PUSH
52709: LD_STRING 
52711: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52712: LD_INT 1
52714: PPUSH
52715: LD_INT 11
52717: PPUSH
52718: LD_INT 10
52720: PPUSH
52721: CALL_OW 380
// un := CreateHuman ;
52725: LD_ADDR_VAR 0 1
52729: PUSH
52730: CALL_OW 44
52734: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52735: LD_VAR 0 1
52739: PPUSH
52740: LD_INT 1
52742: PPUSH
52743: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52747: LD_INT 35
52749: PPUSH
52750: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52754: LD_VAR 0 1
52758: PPUSH
52759: LD_INT 22
52761: PUSH
52762: LD_OWVAR 2
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: PPUSH
52771: CALL_OW 69
52775: PPUSH
52776: LD_VAR 0 1
52780: PPUSH
52781: CALL_OW 74
52785: PPUSH
52786: CALL_OW 115
// until IsDead ( un ) ;
52790: LD_VAR 0 1
52794: PPUSH
52795: CALL_OW 301
52799: IFFALSE 52747
// end ;
52801: PPOPN 1
52803: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52804: LD_EXP 92
52808: PUSH
52809: LD_EXP 132
52813: AND
52814: IFFALSE 52826
52816: GO 52818
52818: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52819: LD_STRING earthquake(getX(game), 0, 32)
52821: PPUSH
52822: CALL_OW 559
52826: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52827: LD_EXP 92
52831: PUSH
52832: LD_EXP 133
52836: AND
52837: IFFALSE 52928
52839: GO 52841
52841: DISABLE
52842: LD_INT 0
52844: PPUSH
// begin enable ;
52845: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52846: LD_ADDR_VAR 0 1
52850: PUSH
52851: LD_INT 22
52853: PUSH
52854: LD_OWVAR 2
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: PUSH
52863: LD_INT 21
52865: PUSH
52866: LD_INT 2
52868: PUSH
52869: EMPTY
52870: LIST
52871: LIST
52872: PUSH
52873: LD_INT 33
52875: PUSH
52876: LD_INT 3
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: PUSH
52883: EMPTY
52884: LIST
52885: LIST
52886: LIST
52887: PPUSH
52888: CALL_OW 69
52892: ST_TO_ADDR
// if not tmp then
52893: LD_VAR 0 1
52897: NOT
52898: IFFALSE 52902
// exit ;
52900: GO 52928
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52902: LD_VAR 0 1
52906: PUSH
52907: LD_INT 1
52909: PPUSH
52910: LD_VAR 0 1
52914: PPUSH
52915: CALL_OW 12
52919: ARRAY
52920: PPUSH
52921: LD_INT 1
52923: PPUSH
52924: CALL_OW 234
// end ;
52928: PPOPN 1
52930: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52931: LD_EXP 92
52935: PUSH
52936: LD_EXP 134
52940: AND
52941: IFFALSE 53082
52943: GO 52945
52945: DISABLE
52946: LD_INT 0
52948: PPUSH
52949: PPUSH
52950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52951: LD_ADDR_VAR 0 3
52955: PUSH
52956: LD_INT 22
52958: PUSH
52959: LD_OWVAR 2
52963: PUSH
52964: EMPTY
52965: LIST
52966: LIST
52967: PUSH
52968: LD_INT 25
52970: PUSH
52971: LD_INT 1
52973: PUSH
52974: EMPTY
52975: LIST
52976: LIST
52977: PUSH
52978: EMPTY
52979: LIST
52980: LIST
52981: PPUSH
52982: CALL_OW 69
52986: ST_TO_ADDR
// if not tmp then
52987: LD_VAR 0 3
52991: NOT
52992: IFFALSE 52996
// exit ;
52994: GO 53082
// un := tmp [ rand ( 1 , tmp ) ] ;
52996: LD_ADDR_VAR 0 2
53000: PUSH
53001: LD_VAR 0 3
53005: PUSH
53006: LD_INT 1
53008: PPUSH
53009: LD_VAR 0 3
53013: PPUSH
53014: CALL_OW 12
53018: ARRAY
53019: ST_TO_ADDR
// if Crawls ( un ) then
53020: LD_VAR 0 2
53024: PPUSH
53025: CALL_OW 318
53029: IFFALSE 53040
// ComWalk ( un ) ;
53031: LD_VAR 0 2
53035: PPUSH
53036: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53040: LD_VAR 0 2
53044: PPUSH
53045: LD_INT 9
53047: PPUSH
53048: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53052: LD_INT 28
53054: PPUSH
53055: LD_OWVAR 2
53059: PPUSH
53060: LD_INT 2
53062: PPUSH
53063: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53067: LD_INT 29
53069: PPUSH
53070: LD_OWVAR 2
53074: PPUSH
53075: LD_INT 2
53077: PPUSH
53078: CALL_OW 322
// end ;
53082: PPOPN 3
53084: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53085: LD_EXP 92
53089: PUSH
53090: LD_EXP 135
53094: AND
53095: IFFALSE 53206
53097: GO 53099
53099: DISABLE
53100: LD_INT 0
53102: PPUSH
53103: PPUSH
53104: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53105: LD_ADDR_VAR 0 3
53109: PUSH
53110: LD_INT 22
53112: PUSH
53113: LD_OWVAR 2
53117: PUSH
53118: EMPTY
53119: LIST
53120: LIST
53121: PUSH
53122: LD_INT 25
53124: PUSH
53125: LD_INT 1
53127: PUSH
53128: EMPTY
53129: LIST
53130: LIST
53131: PUSH
53132: EMPTY
53133: LIST
53134: LIST
53135: PPUSH
53136: CALL_OW 69
53140: ST_TO_ADDR
// if not tmp then
53141: LD_VAR 0 3
53145: NOT
53146: IFFALSE 53150
// exit ;
53148: GO 53206
// un := tmp [ rand ( 1 , tmp ) ] ;
53150: LD_ADDR_VAR 0 2
53154: PUSH
53155: LD_VAR 0 3
53159: PUSH
53160: LD_INT 1
53162: PPUSH
53163: LD_VAR 0 3
53167: PPUSH
53168: CALL_OW 12
53172: ARRAY
53173: ST_TO_ADDR
// if Crawls ( un ) then
53174: LD_VAR 0 2
53178: PPUSH
53179: CALL_OW 318
53183: IFFALSE 53194
// ComWalk ( un ) ;
53185: LD_VAR 0 2
53189: PPUSH
53190: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53194: LD_VAR 0 2
53198: PPUSH
53199: LD_INT 8
53201: PPUSH
53202: CALL_OW 336
// end ;
53206: PPOPN 3
53208: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53209: LD_EXP 92
53213: PUSH
53214: LD_EXP 136
53218: AND
53219: IFFALSE 53363
53221: GO 53223
53223: DISABLE
53224: LD_INT 0
53226: PPUSH
53227: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53228: LD_ADDR_VAR 0 2
53232: PUSH
53233: LD_INT 22
53235: PUSH
53236: LD_OWVAR 2
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: PUSH
53245: LD_INT 21
53247: PUSH
53248: LD_INT 2
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PUSH
53255: LD_INT 2
53257: PUSH
53258: LD_INT 34
53260: PUSH
53261: LD_INT 12
53263: PUSH
53264: EMPTY
53265: LIST
53266: LIST
53267: PUSH
53268: LD_INT 34
53270: PUSH
53271: LD_INT 51
53273: PUSH
53274: EMPTY
53275: LIST
53276: LIST
53277: PUSH
53278: LD_INT 34
53280: PUSH
53281: LD_INT 32
53283: PUSH
53284: EMPTY
53285: LIST
53286: LIST
53287: PUSH
53288: EMPTY
53289: LIST
53290: LIST
53291: LIST
53292: LIST
53293: PUSH
53294: EMPTY
53295: LIST
53296: LIST
53297: LIST
53298: PPUSH
53299: CALL_OW 69
53303: ST_TO_ADDR
// if not tmp then
53304: LD_VAR 0 2
53308: NOT
53309: IFFALSE 53313
// exit ;
53311: GO 53363
// for i in tmp do
53313: LD_ADDR_VAR 0 1
53317: PUSH
53318: LD_VAR 0 2
53322: PUSH
53323: FOR_IN
53324: IFFALSE 53361
// if GetCargo ( i , mat_artifact ) = 0 then
53326: LD_VAR 0 1
53330: PPUSH
53331: LD_INT 4
53333: PPUSH
53334: CALL_OW 289
53338: PUSH
53339: LD_INT 0
53341: EQUAL
53342: IFFALSE 53359
// SetCargo ( i , mat_siberit , 100 ) ;
53344: LD_VAR 0 1
53348: PPUSH
53349: LD_INT 3
53351: PPUSH
53352: LD_INT 100
53354: PPUSH
53355: CALL_OW 290
53359: GO 53323
53361: POP
53362: POP
// end ;
53363: PPOPN 2
53365: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53366: LD_EXP 92
53370: PUSH
53371: LD_EXP 137
53375: AND
53376: IFFALSE 53559
53378: GO 53380
53380: DISABLE
53381: LD_INT 0
53383: PPUSH
53384: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53385: LD_ADDR_VAR 0 2
53389: PUSH
53390: LD_INT 22
53392: PUSH
53393: LD_OWVAR 2
53397: PUSH
53398: EMPTY
53399: LIST
53400: LIST
53401: PPUSH
53402: CALL_OW 69
53406: ST_TO_ADDR
// if not tmp then
53407: LD_VAR 0 2
53411: NOT
53412: IFFALSE 53416
// exit ;
53414: GO 53559
// for i := 1 to 2 do
53416: LD_ADDR_VAR 0 1
53420: PUSH
53421: DOUBLE
53422: LD_INT 1
53424: DEC
53425: ST_TO_ADDR
53426: LD_INT 2
53428: PUSH
53429: FOR_TO
53430: IFFALSE 53557
// begin uc_side := your_side ;
53432: LD_ADDR_OWVAR 20
53436: PUSH
53437: LD_OWVAR 2
53441: ST_TO_ADDR
// uc_nation := nation_american ;
53442: LD_ADDR_OWVAR 21
53446: PUSH
53447: LD_INT 1
53449: ST_TO_ADDR
// vc_chassis := us_morphling ;
53450: LD_ADDR_OWVAR 37
53454: PUSH
53455: LD_INT 5
53457: ST_TO_ADDR
// vc_engine := engine_siberite ;
53458: LD_ADDR_OWVAR 39
53462: PUSH
53463: LD_INT 3
53465: ST_TO_ADDR
// vc_control := control_computer ;
53466: LD_ADDR_OWVAR 38
53470: PUSH
53471: LD_INT 3
53473: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53474: LD_ADDR_OWVAR 40
53478: PUSH
53479: LD_INT 10
53481: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53482: LD_VAR 0 2
53486: PUSH
53487: LD_INT 1
53489: ARRAY
53490: PPUSH
53491: CALL_OW 310
53495: NOT
53496: IFFALSE 53543
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53498: CALL_OW 45
53502: PPUSH
53503: LD_VAR 0 2
53507: PUSH
53508: LD_INT 1
53510: ARRAY
53511: PPUSH
53512: CALL_OW 250
53516: PPUSH
53517: LD_VAR 0 2
53521: PUSH
53522: LD_INT 1
53524: ARRAY
53525: PPUSH
53526: CALL_OW 251
53530: PPUSH
53531: LD_INT 12
53533: PPUSH
53534: LD_INT 1
53536: PPUSH
53537: CALL_OW 50
53541: GO 53555
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53543: CALL_OW 45
53547: PPUSH
53548: LD_INT 1
53550: PPUSH
53551: CALL_OW 51
// end ;
53555: GO 53429
53557: POP
53558: POP
// end ;
53559: PPOPN 2
53561: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53562: LD_EXP 92
53566: PUSH
53567: LD_EXP 138
53571: AND
53572: IFFALSE 53794
53574: GO 53576
53576: DISABLE
53577: LD_INT 0
53579: PPUSH
53580: PPUSH
53581: PPUSH
53582: PPUSH
53583: PPUSH
53584: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53585: LD_ADDR_VAR 0 6
53589: PUSH
53590: LD_INT 22
53592: PUSH
53593: LD_OWVAR 2
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PUSH
53602: LD_INT 21
53604: PUSH
53605: LD_INT 1
53607: PUSH
53608: EMPTY
53609: LIST
53610: LIST
53611: PUSH
53612: LD_INT 3
53614: PUSH
53615: LD_INT 23
53617: PUSH
53618: LD_INT 0
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: PUSH
53625: EMPTY
53626: LIST
53627: LIST
53628: PUSH
53629: EMPTY
53630: LIST
53631: LIST
53632: LIST
53633: PPUSH
53634: CALL_OW 69
53638: ST_TO_ADDR
// if not tmp then
53639: LD_VAR 0 6
53643: NOT
53644: IFFALSE 53648
// exit ;
53646: GO 53794
// s1 := rand ( 1 , 4 ) ;
53648: LD_ADDR_VAR 0 2
53652: PUSH
53653: LD_INT 1
53655: PPUSH
53656: LD_INT 4
53658: PPUSH
53659: CALL_OW 12
53663: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53664: LD_ADDR_VAR 0 4
53668: PUSH
53669: LD_VAR 0 6
53673: PUSH
53674: LD_INT 1
53676: ARRAY
53677: PPUSH
53678: LD_VAR 0 2
53682: PPUSH
53683: CALL_OW 259
53687: ST_TO_ADDR
// if s1 = 1 then
53688: LD_VAR 0 2
53692: PUSH
53693: LD_INT 1
53695: EQUAL
53696: IFFALSE 53716
// s2 := rand ( 2 , 4 ) else
53698: LD_ADDR_VAR 0 3
53702: PUSH
53703: LD_INT 2
53705: PPUSH
53706: LD_INT 4
53708: PPUSH
53709: CALL_OW 12
53713: ST_TO_ADDR
53714: GO 53724
// s2 := 1 ;
53716: LD_ADDR_VAR 0 3
53720: PUSH
53721: LD_INT 1
53723: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53724: LD_ADDR_VAR 0 5
53728: PUSH
53729: LD_VAR 0 6
53733: PUSH
53734: LD_INT 1
53736: ARRAY
53737: PPUSH
53738: LD_VAR 0 3
53742: PPUSH
53743: CALL_OW 259
53747: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53748: LD_VAR 0 6
53752: PUSH
53753: LD_INT 1
53755: ARRAY
53756: PPUSH
53757: LD_VAR 0 2
53761: PPUSH
53762: LD_VAR 0 5
53766: PPUSH
53767: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53771: LD_VAR 0 6
53775: PUSH
53776: LD_INT 1
53778: ARRAY
53779: PPUSH
53780: LD_VAR 0 3
53784: PPUSH
53785: LD_VAR 0 4
53789: PPUSH
53790: CALL_OW 237
// end ;
53794: PPOPN 6
53796: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53797: LD_EXP 92
53801: PUSH
53802: LD_EXP 139
53806: AND
53807: IFFALSE 53886
53809: GO 53811
53811: DISABLE
53812: LD_INT 0
53814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53815: LD_ADDR_VAR 0 1
53819: PUSH
53820: LD_INT 22
53822: PUSH
53823: LD_OWVAR 2
53827: PUSH
53828: EMPTY
53829: LIST
53830: LIST
53831: PUSH
53832: LD_INT 30
53834: PUSH
53835: LD_INT 3
53837: PUSH
53838: EMPTY
53839: LIST
53840: LIST
53841: PUSH
53842: EMPTY
53843: LIST
53844: LIST
53845: PPUSH
53846: CALL_OW 69
53850: ST_TO_ADDR
// if not tmp then
53851: LD_VAR 0 1
53855: NOT
53856: IFFALSE 53860
// exit ;
53858: GO 53886
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53860: LD_VAR 0 1
53864: PUSH
53865: LD_INT 1
53867: PPUSH
53868: LD_VAR 0 1
53872: PPUSH
53873: CALL_OW 12
53877: ARRAY
53878: PPUSH
53879: LD_INT 1
53881: PPUSH
53882: CALL_OW 234
// end ;
53886: PPOPN 1
53888: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53889: LD_EXP 92
53893: PUSH
53894: LD_EXP 140
53898: AND
53899: IFFALSE 54011
53901: GO 53903
53903: DISABLE
53904: LD_INT 0
53906: PPUSH
53907: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53908: LD_ADDR_VAR 0 2
53912: PUSH
53913: LD_INT 22
53915: PUSH
53916: LD_OWVAR 2
53920: PUSH
53921: EMPTY
53922: LIST
53923: LIST
53924: PUSH
53925: LD_INT 2
53927: PUSH
53928: LD_INT 30
53930: PUSH
53931: LD_INT 27
53933: PUSH
53934: EMPTY
53935: LIST
53936: LIST
53937: PUSH
53938: LD_INT 30
53940: PUSH
53941: LD_INT 26
53943: PUSH
53944: EMPTY
53945: LIST
53946: LIST
53947: PUSH
53948: LD_INT 30
53950: PUSH
53951: LD_INT 28
53953: PUSH
53954: EMPTY
53955: LIST
53956: LIST
53957: PUSH
53958: EMPTY
53959: LIST
53960: LIST
53961: LIST
53962: LIST
53963: PUSH
53964: EMPTY
53965: LIST
53966: LIST
53967: PPUSH
53968: CALL_OW 69
53972: ST_TO_ADDR
// if not tmp then
53973: LD_VAR 0 2
53977: NOT
53978: IFFALSE 53982
// exit ;
53980: GO 54011
// for i in tmp do
53982: LD_ADDR_VAR 0 1
53986: PUSH
53987: LD_VAR 0 2
53991: PUSH
53992: FOR_IN
53993: IFFALSE 54009
// SetLives ( i , 1 ) ;
53995: LD_VAR 0 1
53999: PPUSH
54000: LD_INT 1
54002: PPUSH
54003: CALL_OW 234
54007: GO 53992
54009: POP
54010: POP
// end ;
54011: PPOPN 2
54013: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54014: LD_EXP 92
54018: PUSH
54019: LD_EXP 141
54023: AND
54024: IFFALSE 54311
54026: GO 54028
54028: DISABLE
54029: LD_INT 0
54031: PPUSH
54032: PPUSH
54033: PPUSH
// begin i := rand ( 1 , 7 ) ;
54034: LD_ADDR_VAR 0 1
54038: PUSH
54039: LD_INT 1
54041: PPUSH
54042: LD_INT 7
54044: PPUSH
54045: CALL_OW 12
54049: ST_TO_ADDR
// case i of 1 :
54050: LD_VAR 0 1
54054: PUSH
54055: LD_INT 1
54057: DOUBLE
54058: EQUAL
54059: IFTRUE 54063
54061: GO 54073
54063: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54064: LD_STRING earthquake(getX(game), 0, 32)
54066: PPUSH
54067: CALL_OW 559
54071: GO 54311
54073: LD_INT 2
54075: DOUBLE
54076: EQUAL
54077: IFTRUE 54081
54079: GO 54095
54081: POP
// begin ToLua ( displayStucuk(); ) ;
54082: LD_STRING displayStucuk();
54084: PPUSH
54085: CALL_OW 559
// ResetFog ;
54089: CALL_OW 335
// end ; 3 :
54093: GO 54311
54095: LD_INT 3
54097: DOUBLE
54098: EQUAL
54099: IFTRUE 54103
54101: GO 54207
54103: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54104: LD_ADDR_VAR 0 2
54108: PUSH
54109: LD_INT 22
54111: PUSH
54112: LD_OWVAR 2
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: PUSH
54121: LD_INT 25
54123: PUSH
54124: LD_INT 1
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PPUSH
54135: CALL_OW 69
54139: ST_TO_ADDR
// if not tmp then
54140: LD_VAR 0 2
54144: NOT
54145: IFFALSE 54149
// exit ;
54147: GO 54311
// un := tmp [ rand ( 1 , tmp ) ] ;
54149: LD_ADDR_VAR 0 3
54153: PUSH
54154: LD_VAR 0 2
54158: PUSH
54159: LD_INT 1
54161: PPUSH
54162: LD_VAR 0 2
54166: PPUSH
54167: CALL_OW 12
54171: ARRAY
54172: ST_TO_ADDR
// if Crawls ( un ) then
54173: LD_VAR 0 3
54177: PPUSH
54178: CALL_OW 318
54182: IFFALSE 54193
// ComWalk ( un ) ;
54184: LD_VAR 0 3
54188: PPUSH
54189: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54193: LD_VAR 0 3
54197: PPUSH
54198: LD_INT 8
54200: PPUSH
54201: CALL_OW 336
// end ; 4 :
54205: GO 54311
54207: LD_INT 4
54209: DOUBLE
54210: EQUAL
54211: IFTRUE 54215
54213: GO 54289
54215: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54216: LD_ADDR_VAR 0 2
54220: PUSH
54221: LD_INT 22
54223: PUSH
54224: LD_OWVAR 2
54228: PUSH
54229: EMPTY
54230: LIST
54231: LIST
54232: PUSH
54233: LD_INT 30
54235: PUSH
54236: LD_INT 29
54238: PUSH
54239: EMPTY
54240: LIST
54241: LIST
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: PPUSH
54247: CALL_OW 69
54251: ST_TO_ADDR
// if not tmp then
54252: LD_VAR 0 2
54256: NOT
54257: IFFALSE 54261
// exit ;
54259: GO 54311
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54261: LD_VAR 0 2
54265: PUSH
54266: LD_INT 1
54268: ARRAY
54269: PPUSH
54270: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54274: LD_VAR 0 2
54278: PUSH
54279: LD_INT 1
54281: ARRAY
54282: PPUSH
54283: CALL_OW 65
// end ; 5 .. 7 :
54287: GO 54311
54289: LD_INT 5
54291: DOUBLE
54292: GREATEREQUAL
54293: IFFALSE 54301
54295: LD_INT 7
54297: DOUBLE
54298: LESSEQUAL
54299: IFTRUE 54303
54301: GO 54310
54303: POP
// StreamSibBomb ; end ;
54304: CALL 50548 0 0
54308: GO 54311
54310: POP
// end ;
54311: PPOPN 3
54313: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54314: LD_EXP 92
54318: PUSH
54319: LD_EXP 142
54323: AND
54324: IFFALSE 54480
54326: GO 54328
54328: DISABLE
54329: LD_INT 0
54331: PPUSH
54332: PPUSH
54333: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54334: LD_ADDR_VAR 0 2
54338: PUSH
54339: LD_INT 81
54341: PUSH
54342: LD_OWVAR 2
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: PUSH
54351: LD_INT 2
54353: PUSH
54354: LD_INT 21
54356: PUSH
54357: LD_INT 1
54359: PUSH
54360: EMPTY
54361: LIST
54362: LIST
54363: PUSH
54364: LD_INT 21
54366: PUSH
54367: LD_INT 2
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: LIST
54378: PUSH
54379: EMPTY
54380: LIST
54381: LIST
54382: PPUSH
54383: CALL_OW 69
54387: ST_TO_ADDR
// if not tmp then
54388: LD_VAR 0 2
54392: NOT
54393: IFFALSE 54397
// exit ;
54395: GO 54480
// p := 0 ;
54397: LD_ADDR_VAR 0 3
54401: PUSH
54402: LD_INT 0
54404: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54405: LD_INT 35
54407: PPUSH
54408: CALL_OW 67
// p := p + 1 ;
54412: LD_ADDR_VAR 0 3
54416: PUSH
54417: LD_VAR 0 3
54421: PUSH
54422: LD_INT 1
54424: PLUS
54425: ST_TO_ADDR
// for i in tmp do
54426: LD_ADDR_VAR 0 1
54430: PUSH
54431: LD_VAR 0 2
54435: PUSH
54436: FOR_IN
54437: IFFALSE 54468
// if GetLives ( i ) < 1000 then
54439: LD_VAR 0 1
54443: PPUSH
54444: CALL_OW 256
54448: PUSH
54449: LD_INT 1000
54451: LESS
54452: IFFALSE 54466
// SetLives ( i , 1000 ) ;
54454: LD_VAR 0 1
54458: PPUSH
54459: LD_INT 1000
54461: PPUSH
54462: CALL_OW 234
54466: GO 54436
54468: POP
54469: POP
// until p > 20 ;
54470: LD_VAR 0 3
54474: PUSH
54475: LD_INT 20
54477: GREATER
54478: IFFALSE 54405
// end ;
54480: PPOPN 3
54482: END
// every 0 0$1 trigger StreamModeActive and sTime do
54483: LD_EXP 92
54487: PUSH
54488: LD_EXP 143
54492: AND
54493: IFFALSE 54528
54495: GO 54497
54497: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54498: LD_INT 28
54500: PPUSH
54501: LD_OWVAR 2
54505: PPUSH
54506: LD_INT 2
54508: PPUSH
54509: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54513: LD_INT 30
54515: PPUSH
54516: LD_OWVAR 2
54520: PPUSH
54521: LD_INT 2
54523: PPUSH
54524: CALL_OW 322
// end ;
54528: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54529: LD_EXP 92
54533: PUSH
54534: LD_EXP 144
54538: AND
54539: IFFALSE 54660
54541: GO 54543
54543: DISABLE
54544: LD_INT 0
54546: PPUSH
54547: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54548: LD_ADDR_VAR 0 2
54552: PUSH
54553: LD_INT 22
54555: PUSH
54556: LD_OWVAR 2
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PUSH
54565: LD_INT 21
54567: PUSH
54568: LD_INT 1
54570: PUSH
54571: EMPTY
54572: LIST
54573: LIST
54574: PUSH
54575: LD_INT 3
54577: PUSH
54578: LD_INT 23
54580: PUSH
54581: LD_INT 0
54583: PUSH
54584: EMPTY
54585: LIST
54586: LIST
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: PUSH
54592: EMPTY
54593: LIST
54594: LIST
54595: LIST
54596: PPUSH
54597: CALL_OW 69
54601: ST_TO_ADDR
// if not tmp then
54602: LD_VAR 0 2
54606: NOT
54607: IFFALSE 54611
// exit ;
54609: GO 54660
// for i in tmp do
54611: LD_ADDR_VAR 0 1
54615: PUSH
54616: LD_VAR 0 2
54620: PUSH
54621: FOR_IN
54622: IFFALSE 54658
// begin if Crawls ( i ) then
54624: LD_VAR 0 1
54628: PPUSH
54629: CALL_OW 318
54633: IFFALSE 54644
// ComWalk ( i ) ;
54635: LD_VAR 0 1
54639: PPUSH
54640: CALL_OW 138
// SetClass ( i , 2 ) ;
54644: LD_VAR 0 1
54648: PPUSH
54649: LD_INT 2
54651: PPUSH
54652: CALL_OW 336
// end ;
54656: GO 54621
54658: POP
54659: POP
// end ;
54660: PPOPN 2
54662: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54663: LD_EXP 92
54667: PUSH
54668: LD_EXP 145
54672: AND
54673: IFFALSE 54961
54675: GO 54677
54677: DISABLE
54678: LD_INT 0
54680: PPUSH
54681: PPUSH
54682: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54683: LD_OWVAR 2
54687: PPUSH
54688: LD_INT 9
54690: PPUSH
54691: LD_INT 1
54693: PPUSH
54694: LD_INT 1
54696: PPUSH
54697: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54701: LD_INT 9
54703: PPUSH
54704: LD_OWVAR 2
54708: PPUSH
54709: CALL_OW 343
// uc_side := 9 ;
54713: LD_ADDR_OWVAR 20
54717: PUSH
54718: LD_INT 9
54720: ST_TO_ADDR
// uc_nation := 2 ;
54721: LD_ADDR_OWVAR 21
54725: PUSH
54726: LD_INT 2
54728: ST_TO_ADDR
// hc_name := Dark Warrior ;
54729: LD_ADDR_OWVAR 26
54733: PUSH
54734: LD_STRING Dark Warrior
54736: ST_TO_ADDR
// hc_gallery :=  ;
54737: LD_ADDR_OWVAR 33
54741: PUSH
54742: LD_STRING 
54744: ST_TO_ADDR
// hc_noskilllimit := true ;
54745: LD_ADDR_OWVAR 76
54749: PUSH
54750: LD_INT 1
54752: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54753: LD_ADDR_OWVAR 31
54757: PUSH
54758: LD_INT 30
54760: PUSH
54761: LD_INT 30
54763: PUSH
54764: LD_INT 30
54766: PUSH
54767: LD_INT 30
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: LIST
54774: LIST
54775: ST_TO_ADDR
// un := CreateHuman ;
54776: LD_ADDR_VAR 0 3
54780: PUSH
54781: CALL_OW 44
54785: ST_TO_ADDR
// hc_noskilllimit := false ;
54786: LD_ADDR_OWVAR 76
54790: PUSH
54791: LD_INT 0
54793: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54794: LD_VAR 0 3
54798: PPUSH
54799: LD_INT 1
54801: PPUSH
54802: CALL_OW 51
// ToLua ( playRanger() ) ;
54806: LD_STRING playRanger()
54808: PPUSH
54809: CALL_OW 559
// p := 0 ;
54813: LD_ADDR_VAR 0 2
54817: PUSH
54818: LD_INT 0
54820: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54821: LD_INT 35
54823: PPUSH
54824: CALL_OW 67
// p := p + 1 ;
54828: LD_ADDR_VAR 0 2
54832: PUSH
54833: LD_VAR 0 2
54837: PUSH
54838: LD_INT 1
54840: PLUS
54841: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54842: LD_VAR 0 3
54846: PPUSH
54847: CALL_OW 256
54851: PUSH
54852: LD_INT 1000
54854: LESS
54855: IFFALSE 54869
// SetLives ( un , 1000 ) ;
54857: LD_VAR 0 3
54861: PPUSH
54862: LD_INT 1000
54864: PPUSH
54865: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54869: LD_VAR 0 3
54873: PPUSH
54874: LD_INT 81
54876: PUSH
54877: LD_OWVAR 2
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PUSH
54886: LD_INT 91
54888: PUSH
54889: LD_VAR 0 3
54893: PUSH
54894: LD_INT 30
54896: PUSH
54897: EMPTY
54898: LIST
54899: LIST
54900: LIST
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: PPUSH
54906: CALL_OW 69
54910: PPUSH
54911: LD_VAR 0 3
54915: PPUSH
54916: CALL_OW 74
54920: PPUSH
54921: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
54925: LD_VAR 0 2
54929: PUSH
54930: LD_INT 80
54932: GREATER
54933: PUSH
54934: LD_VAR 0 3
54938: PPUSH
54939: CALL_OW 301
54943: OR
54944: IFFALSE 54821
// if un then
54946: LD_VAR 0 3
54950: IFFALSE 54961
// RemoveUnit ( un ) ;
54952: LD_VAR 0 3
54956: PPUSH
54957: CALL_OW 64
// end ;
54961: PPOPN 3
54963: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
54964: LD_EXP 146
54968: IFFALSE 55084
54970: GO 54972
54972: DISABLE
54973: LD_INT 0
54975: PPUSH
54976: PPUSH
54977: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
54978: LD_ADDR_VAR 0 2
54982: PUSH
54983: LD_INT 81
54985: PUSH
54986: LD_OWVAR 2
54990: PUSH
54991: EMPTY
54992: LIST
54993: LIST
54994: PUSH
54995: LD_INT 21
54997: PUSH
54998: LD_INT 1
55000: PUSH
55001: EMPTY
55002: LIST
55003: LIST
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PPUSH
55009: CALL_OW 69
55013: ST_TO_ADDR
// if not tmp then
55014: LD_VAR 0 2
55018: NOT
55019: IFFALSE 55023
// exit ;
55021: GO 55084
// ToLua ( playComputer() ) ;
55023: LD_STRING playComputer()
55025: PPUSH
55026: CALL_OW 559
// for i in tmp do
55030: LD_ADDR_VAR 0 1
55034: PUSH
55035: LD_VAR 0 2
55039: PUSH
55040: FOR_IN
55041: IFFALSE 55082
// for j := 1 to 4 do
55043: LD_ADDR_VAR 0 3
55047: PUSH
55048: DOUBLE
55049: LD_INT 1
55051: DEC
55052: ST_TO_ADDR
55053: LD_INT 4
55055: PUSH
55056: FOR_TO
55057: IFFALSE 55078
// SetSkill ( i , j , 10 ) ;
55059: LD_VAR 0 1
55063: PPUSH
55064: LD_VAR 0 3
55068: PPUSH
55069: LD_INT 10
55071: PPUSH
55072: CALL_OW 237
55076: GO 55056
55078: POP
55079: POP
55080: GO 55040
55082: POP
55083: POP
// end ;
55084: PPOPN 3
55086: END
// every 0 0$1 trigger s30 do var i , tmp ;
55087: LD_EXP 147
55091: IFFALSE 55160
55093: GO 55095
55095: DISABLE
55096: LD_INT 0
55098: PPUSH
55099: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55100: LD_ADDR_VAR 0 2
55104: PUSH
55105: LD_INT 22
55107: PUSH
55108: LD_OWVAR 2
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PPUSH
55117: CALL_OW 69
55121: ST_TO_ADDR
// if not tmp then
55122: LD_VAR 0 2
55126: NOT
55127: IFFALSE 55131
// exit ;
55129: GO 55160
// for i in tmp do
55131: LD_ADDR_VAR 0 1
55135: PUSH
55136: LD_VAR 0 2
55140: PUSH
55141: FOR_IN
55142: IFFALSE 55158
// SetLives ( i , 300 ) ;
55144: LD_VAR 0 1
55148: PPUSH
55149: LD_INT 300
55151: PPUSH
55152: CALL_OW 234
55156: GO 55141
55158: POP
55159: POP
// end ;
55160: PPOPN 2
55162: END
// every 0 0$1 trigger s60 do var i , tmp ;
55163: LD_EXP 148
55167: IFFALSE 55236
55169: GO 55171
55171: DISABLE
55172: LD_INT 0
55174: PPUSH
55175: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55176: LD_ADDR_VAR 0 2
55180: PUSH
55181: LD_INT 22
55183: PUSH
55184: LD_OWVAR 2
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: PPUSH
55193: CALL_OW 69
55197: ST_TO_ADDR
// if not tmp then
55198: LD_VAR 0 2
55202: NOT
55203: IFFALSE 55207
// exit ;
55205: GO 55236
// for i in tmp do
55207: LD_ADDR_VAR 0 1
55211: PUSH
55212: LD_VAR 0 2
55216: PUSH
55217: FOR_IN
55218: IFFALSE 55234
// SetLives ( i , 600 ) ;
55220: LD_VAR 0 1
55224: PPUSH
55225: LD_INT 600
55227: PPUSH
55228: CALL_OW 234
55232: GO 55217
55234: POP
55235: POP
// end ;
55236: PPOPN 2
55238: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55239: LD_INT 0
55241: PPUSH
// case cmd of 301 :
55242: LD_VAR 0 1
55246: PUSH
55247: LD_INT 301
55249: DOUBLE
55250: EQUAL
55251: IFTRUE 55255
55253: GO 55287
55255: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55256: LD_VAR 0 6
55260: PPUSH
55261: LD_VAR 0 7
55265: PPUSH
55266: LD_VAR 0 8
55270: PPUSH
55271: LD_VAR 0 4
55275: PPUSH
55276: LD_VAR 0 5
55280: PPUSH
55281: CALL 56488 0 5
55285: GO 55408
55287: LD_INT 302
55289: DOUBLE
55290: EQUAL
55291: IFTRUE 55295
55293: GO 55332
55295: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55296: LD_VAR 0 6
55300: PPUSH
55301: LD_VAR 0 7
55305: PPUSH
55306: LD_VAR 0 8
55310: PPUSH
55311: LD_VAR 0 9
55315: PPUSH
55316: LD_VAR 0 4
55320: PPUSH
55321: LD_VAR 0 5
55325: PPUSH
55326: CALL 56579 0 6
55330: GO 55408
55332: LD_INT 303
55334: DOUBLE
55335: EQUAL
55336: IFTRUE 55340
55338: GO 55377
55340: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55341: LD_VAR 0 6
55345: PPUSH
55346: LD_VAR 0 7
55350: PPUSH
55351: LD_VAR 0 8
55355: PPUSH
55356: LD_VAR 0 9
55360: PPUSH
55361: LD_VAR 0 4
55365: PPUSH
55366: LD_VAR 0 5
55370: PPUSH
55371: CALL 55413 0 6
55375: GO 55408
55377: LD_INT 304
55379: DOUBLE
55380: EQUAL
55381: IFTRUE 55385
55383: GO 55407
55385: POP
// hHackTeleport ( unit , x , y ) ; end ;
55386: LD_VAR 0 2
55390: PPUSH
55391: LD_VAR 0 4
55395: PPUSH
55396: LD_VAR 0 5
55400: PPUSH
55401: CALL 57172 0 3
55405: GO 55408
55407: POP
// end ;
55408: LD_VAR 0 12
55412: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55413: LD_INT 0
55415: PPUSH
55416: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55417: LD_VAR 0 1
55421: PUSH
55422: LD_INT 1
55424: LESS
55425: PUSH
55426: LD_VAR 0 1
55430: PUSH
55431: LD_INT 3
55433: GREATER
55434: OR
55435: PUSH
55436: LD_VAR 0 5
55440: PPUSH
55441: LD_VAR 0 6
55445: PPUSH
55446: CALL_OW 428
55450: OR
55451: IFFALSE 55455
// exit ;
55453: GO 56175
// uc_side := your_side ;
55455: LD_ADDR_OWVAR 20
55459: PUSH
55460: LD_OWVAR 2
55464: ST_TO_ADDR
// uc_nation := nation ;
55465: LD_ADDR_OWVAR 21
55469: PUSH
55470: LD_VAR 0 1
55474: ST_TO_ADDR
// bc_level = 1 ;
55475: LD_ADDR_OWVAR 43
55479: PUSH
55480: LD_INT 1
55482: ST_TO_ADDR
// case btype of 1 :
55483: LD_VAR 0 2
55487: PUSH
55488: LD_INT 1
55490: DOUBLE
55491: EQUAL
55492: IFTRUE 55496
55494: GO 55507
55496: POP
// bc_type := b_depot ; 2 :
55497: LD_ADDR_OWVAR 42
55501: PUSH
55502: LD_INT 0
55504: ST_TO_ADDR
55505: GO 56119
55507: LD_INT 2
55509: DOUBLE
55510: EQUAL
55511: IFTRUE 55515
55513: GO 55526
55515: POP
// bc_type := b_warehouse ; 3 :
55516: LD_ADDR_OWVAR 42
55520: PUSH
55521: LD_INT 1
55523: ST_TO_ADDR
55524: GO 56119
55526: LD_INT 3
55528: DOUBLE
55529: EQUAL
55530: IFTRUE 55534
55532: GO 55545
55534: POP
// bc_type := b_lab ; 4 .. 9 :
55535: LD_ADDR_OWVAR 42
55539: PUSH
55540: LD_INT 6
55542: ST_TO_ADDR
55543: GO 56119
55545: LD_INT 4
55547: DOUBLE
55548: GREATEREQUAL
55549: IFFALSE 55557
55551: LD_INT 9
55553: DOUBLE
55554: LESSEQUAL
55555: IFTRUE 55559
55557: GO 55611
55559: POP
// begin bc_type := b_lab_half ;
55560: LD_ADDR_OWVAR 42
55564: PUSH
55565: LD_INT 7
55567: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
55568: LD_ADDR_OWVAR 44
55572: PUSH
55573: LD_INT 10
55575: PUSH
55576: LD_INT 11
55578: PUSH
55579: LD_INT 12
55581: PUSH
55582: LD_INT 15
55584: PUSH
55585: LD_INT 14
55587: PUSH
55588: LD_INT 13
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: LIST
55595: LIST
55596: LIST
55597: LIST
55598: PUSH
55599: LD_VAR 0 2
55603: PUSH
55604: LD_INT 3
55606: MINUS
55607: ARRAY
55608: ST_TO_ADDR
// end ; 10 .. 13 :
55609: GO 56119
55611: LD_INT 10
55613: DOUBLE
55614: GREATEREQUAL
55615: IFFALSE 55623
55617: LD_INT 13
55619: DOUBLE
55620: LESSEQUAL
55621: IFTRUE 55625
55623: GO 55702
55625: POP
// begin bc_type := b_lab_full ;
55626: LD_ADDR_OWVAR 42
55630: PUSH
55631: LD_INT 8
55633: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
55634: LD_ADDR_OWVAR 44
55638: PUSH
55639: LD_INT 10
55641: PUSH
55642: LD_INT 12
55644: PUSH
55645: LD_INT 14
55647: PUSH
55648: LD_INT 13
55650: PUSH
55651: EMPTY
55652: LIST
55653: LIST
55654: LIST
55655: LIST
55656: PUSH
55657: LD_VAR 0 2
55661: PUSH
55662: LD_INT 9
55664: MINUS
55665: ARRAY
55666: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
55667: LD_ADDR_OWVAR 45
55671: PUSH
55672: LD_INT 11
55674: PUSH
55675: LD_INT 15
55677: PUSH
55678: LD_INT 12
55680: PUSH
55681: LD_INT 15
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: LIST
55688: LIST
55689: PUSH
55690: LD_VAR 0 2
55694: PUSH
55695: LD_INT 9
55697: MINUS
55698: ARRAY
55699: ST_TO_ADDR
// end ; 14 :
55700: GO 56119
55702: LD_INT 14
55704: DOUBLE
55705: EQUAL
55706: IFTRUE 55710
55708: GO 55721
55710: POP
// bc_type := b_workshop ; 15 :
55711: LD_ADDR_OWVAR 42
55715: PUSH
55716: LD_INT 2
55718: ST_TO_ADDR
55719: GO 56119
55721: LD_INT 15
55723: DOUBLE
55724: EQUAL
55725: IFTRUE 55729
55727: GO 55740
55729: POP
// bc_type := b_factory ; 16 :
55730: LD_ADDR_OWVAR 42
55734: PUSH
55735: LD_INT 3
55737: ST_TO_ADDR
55738: GO 56119
55740: LD_INT 16
55742: DOUBLE
55743: EQUAL
55744: IFTRUE 55748
55746: GO 55759
55748: POP
// bc_type := b_ext_gun ; 17 :
55749: LD_ADDR_OWVAR 42
55753: PUSH
55754: LD_INT 17
55756: ST_TO_ADDR
55757: GO 56119
55759: LD_INT 17
55761: DOUBLE
55762: EQUAL
55763: IFTRUE 55767
55765: GO 55795
55767: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55768: LD_ADDR_OWVAR 42
55772: PUSH
55773: LD_INT 19
55775: PUSH
55776: LD_INT 23
55778: PUSH
55779: LD_INT 19
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: LIST
55786: PUSH
55787: LD_VAR 0 1
55791: ARRAY
55792: ST_TO_ADDR
55793: GO 56119
55795: LD_INT 18
55797: DOUBLE
55798: EQUAL
55799: IFTRUE 55803
55801: GO 55814
55803: POP
// bc_type := b_ext_radar ; 19 :
55804: LD_ADDR_OWVAR 42
55808: PUSH
55809: LD_INT 20
55811: ST_TO_ADDR
55812: GO 56119
55814: LD_INT 19
55816: DOUBLE
55817: EQUAL
55818: IFTRUE 55822
55820: GO 55833
55822: POP
// bc_type := b_ext_radio ; 20 :
55823: LD_ADDR_OWVAR 42
55827: PUSH
55828: LD_INT 22
55830: ST_TO_ADDR
55831: GO 56119
55833: LD_INT 20
55835: DOUBLE
55836: EQUAL
55837: IFTRUE 55841
55839: GO 55852
55841: POP
// bc_type := b_ext_siberium ; 21 :
55842: LD_ADDR_OWVAR 42
55846: PUSH
55847: LD_INT 21
55849: ST_TO_ADDR
55850: GO 56119
55852: LD_INT 21
55854: DOUBLE
55855: EQUAL
55856: IFTRUE 55860
55858: GO 55871
55860: POP
// bc_type := b_ext_computer ; 22 :
55861: LD_ADDR_OWVAR 42
55865: PUSH
55866: LD_INT 24
55868: ST_TO_ADDR
55869: GO 56119
55871: LD_INT 22
55873: DOUBLE
55874: EQUAL
55875: IFTRUE 55879
55877: GO 55890
55879: POP
// bc_type := b_ext_track ; 23 :
55880: LD_ADDR_OWVAR 42
55884: PUSH
55885: LD_INT 16
55887: ST_TO_ADDR
55888: GO 56119
55890: LD_INT 23
55892: DOUBLE
55893: EQUAL
55894: IFTRUE 55898
55896: GO 55909
55898: POP
// bc_type := b_ext_laser ; 24 :
55899: LD_ADDR_OWVAR 42
55903: PUSH
55904: LD_INT 25
55906: ST_TO_ADDR
55907: GO 56119
55909: LD_INT 24
55911: DOUBLE
55912: EQUAL
55913: IFTRUE 55917
55915: GO 55928
55917: POP
// bc_type := b_control_tower ; 25 :
55918: LD_ADDR_OWVAR 42
55922: PUSH
55923: LD_INT 36
55925: ST_TO_ADDR
55926: GO 56119
55928: LD_INT 25
55930: DOUBLE
55931: EQUAL
55932: IFTRUE 55936
55934: GO 55947
55936: POP
// bc_type := b_breastwork ; 26 :
55937: LD_ADDR_OWVAR 42
55941: PUSH
55942: LD_INT 31
55944: ST_TO_ADDR
55945: GO 56119
55947: LD_INT 26
55949: DOUBLE
55950: EQUAL
55951: IFTRUE 55955
55953: GO 55966
55955: POP
// bc_type := b_bunker ; 27 :
55956: LD_ADDR_OWVAR 42
55960: PUSH
55961: LD_INT 32
55963: ST_TO_ADDR
55964: GO 56119
55966: LD_INT 27
55968: DOUBLE
55969: EQUAL
55970: IFTRUE 55974
55972: GO 55985
55974: POP
// bc_type := b_turret ; 28 :
55975: LD_ADDR_OWVAR 42
55979: PUSH
55980: LD_INT 33
55982: ST_TO_ADDR
55983: GO 56119
55985: LD_INT 28
55987: DOUBLE
55988: EQUAL
55989: IFTRUE 55993
55991: GO 56004
55993: POP
// bc_type := b_armoury ; 29 :
55994: LD_ADDR_OWVAR 42
55998: PUSH
55999: LD_INT 4
56001: ST_TO_ADDR
56002: GO 56119
56004: LD_INT 29
56006: DOUBLE
56007: EQUAL
56008: IFTRUE 56012
56010: GO 56023
56012: POP
// bc_type := b_barracks ; 30 :
56013: LD_ADDR_OWVAR 42
56017: PUSH
56018: LD_INT 5
56020: ST_TO_ADDR
56021: GO 56119
56023: LD_INT 30
56025: DOUBLE
56026: EQUAL
56027: IFTRUE 56031
56029: GO 56042
56031: POP
// bc_type := b_solar_power ; 31 :
56032: LD_ADDR_OWVAR 42
56036: PUSH
56037: LD_INT 27
56039: ST_TO_ADDR
56040: GO 56119
56042: LD_INT 31
56044: DOUBLE
56045: EQUAL
56046: IFTRUE 56050
56048: GO 56061
56050: POP
// bc_type := b_oil_power ; 32 :
56051: LD_ADDR_OWVAR 42
56055: PUSH
56056: LD_INT 26
56058: ST_TO_ADDR
56059: GO 56119
56061: LD_INT 32
56063: DOUBLE
56064: EQUAL
56065: IFTRUE 56069
56067: GO 56080
56069: POP
// bc_type := b_siberite_power ; 33 :
56070: LD_ADDR_OWVAR 42
56074: PUSH
56075: LD_INT 28
56077: ST_TO_ADDR
56078: GO 56119
56080: LD_INT 33
56082: DOUBLE
56083: EQUAL
56084: IFTRUE 56088
56086: GO 56099
56088: POP
// bc_type := b_oil_mine ; 34 :
56089: LD_ADDR_OWVAR 42
56093: PUSH
56094: LD_INT 29
56096: ST_TO_ADDR
56097: GO 56119
56099: LD_INT 34
56101: DOUBLE
56102: EQUAL
56103: IFTRUE 56107
56105: GO 56118
56107: POP
// bc_type := b_siberite_mine ; end ;
56108: LD_ADDR_OWVAR 42
56112: PUSH
56113: LD_INT 30
56115: ST_TO_ADDR
56116: GO 56119
56118: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56119: LD_ADDR_VAR 0 8
56123: PUSH
56124: LD_VAR 0 5
56128: PPUSH
56129: LD_VAR 0 6
56133: PPUSH
56134: LD_VAR 0 3
56138: PPUSH
56139: CALL_OW 47
56143: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56144: LD_OWVAR 42
56148: PUSH
56149: LD_INT 32
56151: PUSH
56152: LD_INT 33
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: IN
56159: IFFALSE 56175
// PlaceWeaponTurret ( b , weapon ) ;
56161: LD_VAR 0 8
56165: PPUSH
56166: LD_VAR 0 4
56170: PPUSH
56171: CALL_OW 431
// end ;
56175: LD_VAR 0 7
56179: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56180: LD_INT 0
56182: PPUSH
56183: PPUSH
56184: PPUSH
56185: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56186: LD_ADDR_VAR 0 4
56190: PUSH
56191: LD_INT 22
56193: PUSH
56194: LD_OWVAR 2
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: PUSH
56203: LD_INT 2
56205: PUSH
56206: LD_INT 30
56208: PUSH
56209: LD_INT 0
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: PUSH
56216: LD_INT 30
56218: PUSH
56219: LD_INT 1
56221: PUSH
56222: EMPTY
56223: LIST
56224: LIST
56225: PUSH
56226: EMPTY
56227: LIST
56228: LIST
56229: LIST
56230: PUSH
56231: EMPTY
56232: LIST
56233: LIST
56234: PPUSH
56235: CALL_OW 69
56239: ST_TO_ADDR
// if not tmp then
56240: LD_VAR 0 4
56244: NOT
56245: IFFALSE 56249
// exit ;
56247: GO 56308
// for i in tmp do
56249: LD_ADDR_VAR 0 2
56253: PUSH
56254: LD_VAR 0 4
56258: PUSH
56259: FOR_IN
56260: IFFALSE 56306
// for j = 1 to 3 do
56262: LD_ADDR_VAR 0 3
56266: PUSH
56267: DOUBLE
56268: LD_INT 1
56270: DEC
56271: ST_TO_ADDR
56272: LD_INT 3
56274: PUSH
56275: FOR_TO
56276: IFFALSE 56302
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56278: LD_VAR 0 2
56282: PPUSH
56283: CALL_OW 274
56287: PPUSH
56288: LD_VAR 0 3
56292: PPUSH
56293: LD_INT 99999
56295: PPUSH
56296: CALL_OW 277
56300: GO 56275
56302: POP
56303: POP
56304: GO 56259
56306: POP
56307: POP
// end ;
56308: LD_VAR 0 1
56312: RET
// export function hHackSetLevel10 ; var i , j ; begin
56313: LD_INT 0
56315: PPUSH
56316: PPUSH
56317: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56318: LD_ADDR_VAR 0 2
56322: PUSH
56323: LD_INT 21
56325: PUSH
56326: LD_INT 1
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PPUSH
56333: CALL_OW 69
56337: PUSH
56338: FOR_IN
56339: IFFALSE 56391
// if IsSelected ( i ) then
56341: LD_VAR 0 2
56345: PPUSH
56346: CALL_OW 306
56350: IFFALSE 56389
// begin for j := 1 to 4 do
56352: LD_ADDR_VAR 0 3
56356: PUSH
56357: DOUBLE
56358: LD_INT 1
56360: DEC
56361: ST_TO_ADDR
56362: LD_INT 4
56364: PUSH
56365: FOR_TO
56366: IFFALSE 56387
// SetSkill ( i , j , 10 ) ;
56368: LD_VAR 0 2
56372: PPUSH
56373: LD_VAR 0 3
56377: PPUSH
56378: LD_INT 10
56380: PPUSH
56381: CALL_OW 237
56385: GO 56365
56387: POP
56388: POP
// end ;
56389: GO 56338
56391: POP
56392: POP
// end ;
56393: LD_VAR 0 1
56397: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56398: LD_INT 0
56400: PPUSH
56401: PPUSH
56402: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56403: LD_ADDR_VAR 0 2
56407: PUSH
56408: LD_INT 22
56410: PUSH
56411: LD_OWVAR 2
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: PUSH
56420: LD_INT 21
56422: PUSH
56423: LD_INT 1
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: PPUSH
56434: CALL_OW 69
56438: PUSH
56439: FOR_IN
56440: IFFALSE 56481
// begin for j := 1 to 4 do
56442: LD_ADDR_VAR 0 3
56446: PUSH
56447: DOUBLE
56448: LD_INT 1
56450: DEC
56451: ST_TO_ADDR
56452: LD_INT 4
56454: PUSH
56455: FOR_TO
56456: IFFALSE 56477
// SetSkill ( i , j , 10 ) ;
56458: LD_VAR 0 2
56462: PPUSH
56463: LD_VAR 0 3
56467: PPUSH
56468: LD_INT 10
56470: PPUSH
56471: CALL_OW 237
56475: GO 56455
56477: POP
56478: POP
// end ;
56479: GO 56439
56481: POP
56482: POP
// end ;
56483: LD_VAR 0 1
56487: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
56488: LD_INT 0
56490: PPUSH
// uc_side := your_side ;
56491: LD_ADDR_OWVAR 20
56495: PUSH
56496: LD_OWVAR 2
56500: ST_TO_ADDR
// uc_nation := nation ;
56501: LD_ADDR_OWVAR 21
56505: PUSH
56506: LD_VAR 0 1
56510: ST_TO_ADDR
// InitHc ;
56511: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
56515: LD_INT 0
56517: PPUSH
56518: LD_VAR 0 2
56522: PPUSH
56523: LD_VAR 0 3
56527: PPUSH
56528: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
56532: LD_VAR 0 4
56536: PPUSH
56537: LD_VAR 0 5
56541: PPUSH
56542: CALL_OW 428
56546: PUSH
56547: LD_INT 0
56549: EQUAL
56550: IFFALSE 56574
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
56552: CALL_OW 44
56556: PPUSH
56557: LD_VAR 0 4
56561: PPUSH
56562: LD_VAR 0 5
56566: PPUSH
56567: LD_INT 1
56569: PPUSH
56570: CALL_OW 48
// end ;
56574: LD_VAR 0 6
56578: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
56579: LD_INT 0
56581: PPUSH
56582: PPUSH
// uc_side := your_side ;
56583: LD_ADDR_OWVAR 20
56587: PUSH
56588: LD_OWVAR 2
56592: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
56593: LD_VAR 0 1
56597: PUSH
56598: LD_INT 1
56600: PUSH
56601: LD_INT 2
56603: PUSH
56604: LD_INT 3
56606: PUSH
56607: LD_INT 4
56609: PUSH
56610: LD_INT 5
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: LIST
56617: LIST
56618: LIST
56619: IN
56620: IFFALSE 56632
// uc_nation := nation_american else
56622: LD_ADDR_OWVAR 21
56626: PUSH
56627: LD_INT 1
56629: ST_TO_ADDR
56630: GO 56675
// if chassis in [ 11 , 12 , 13 , 14 ] then
56632: LD_VAR 0 1
56636: PUSH
56637: LD_INT 11
56639: PUSH
56640: LD_INT 12
56642: PUSH
56643: LD_INT 13
56645: PUSH
56646: LD_INT 14
56648: PUSH
56649: EMPTY
56650: LIST
56651: LIST
56652: LIST
56653: LIST
56654: IN
56655: IFFALSE 56667
// uc_nation := nation_arabian else
56657: LD_ADDR_OWVAR 21
56661: PUSH
56662: LD_INT 2
56664: ST_TO_ADDR
56665: GO 56675
// uc_nation := nation_russian ;
56667: LD_ADDR_OWVAR 21
56671: PUSH
56672: LD_INT 3
56674: ST_TO_ADDR
// vc_chassis := chassis ;
56675: LD_ADDR_OWVAR 37
56679: PUSH
56680: LD_VAR 0 1
56684: ST_TO_ADDR
// vc_engine := engine ;
56685: LD_ADDR_OWVAR 39
56689: PUSH
56690: LD_VAR 0 2
56694: ST_TO_ADDR
// vc_control := control ;
56695: LD_ADDR_OWVAR 38
56699: PUSH
56700: LD_VAR 0 3
56704: ST_TO_ADDR
// vc_weapon := weapon ;
56705: LD_ADDR_OWVAR 40
56709: PUSH
56710: LD_VAR 0 4
56714: ST_TO_ADDR
// un := CreateVehicle ;
56715: LD_ADDR_VAR 0 8
56719: PUSH
56720: CALL_OW 45
56724: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
56725: LD_VAR 0 8
56729: PPUSH
56730: LD_INT 0
56732: PPUSH
56733: LD_INT 5
56735: PPUSH
56736: CALL_OW 12
56740: PPUSH
56741: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56745: LD_VAR 0 8
56749: PPUSH
56750: LD_VAR 0 5
56754: PPUSH
56755: LD_VAR 0 6
56759: PPUSH
56760: LD_INT 1
56762: PPUSH
56763: CALL_OW 48
// end ;
56767: LD_VAR 0 7
56771: RET
// export hInvincible ; every 1 do
56772: GO 56774
56774: DISABLE
// hInvincible := [ ] ;
56775: LD_ADDR_EXP 149
56779: PUSH
56780: EMPTY
56781: ST_TO_ADDR
56782: END
// every 10 do var i ;
56783: GO 56785
56785: DISABLE
56786: LD_INT 0
56788: PPUSH
// begin enable ;
56789: ENABLE
// if not hInvincible then
56790: LD_EXP 149
56794: NOT
56795: IFFALSE 56799
// exit ;
56797: GO 56843
// for i in hInvincible do
56799: LD_ADDR_VAR 0 1
56803: PUSH
56804: LD_EXP 149
56808: PUSH
56809: FOR_IN
56810: IFFALSE 56841
// if GetLives ( i ) < 1000 then
56812: LD_VAR 0 1
56816: PPUSH
56817: CALL_OW 256
56821: PUSH
56822: LD_INT 1000
56824: LESS
56825: IFFALSE 56839
// SetLives ( i , 1000 ) ;
56827: LD_VAR 0 1
56831: PPUSH
56832: LD_INT 1000
56834: PPUSH
56835: CALL_OW 234
56839: GO 56809
56841: POP
56842: POP
// end ;
56843: PPOPN 1
56845: END
// export function hHackInvincible ; var i ; begin
56846: LD_INT 0
56848: PPUSH
56849: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56850: LD_ADDR_VAR 0 2
56854: PUSH
56855: LD_INT 2
56857: PUSH
56858: LD_INT 21
56860: PUSH
56861: LD_INT 1
56863: PUSH
56864: EMPTY
56865: LIST
56866: LIST
56867: PUSH
56868: LD_INT 21
56870: PUSH
56871: LD_INT 2
56873: PUSH
56874: EMPTY
56875: LIST
56876: LIST
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: LIST
56882: PPUSH
56883: CALL_OW 69
56887: PUSH
56888: FOR_IN
56889: IFFALSE 56950
// if IsSelected ( i ) then
56891: LD_VAR 0 2
56895: PPUSH
56896: CALL_OW 306
56900: IFFALSE 56948
// begin if i in hInvincible then
56902: LD_VAR 0 2
56906: PUSH
56907: LD_EXP 149
56911: IN
56912: IFFALSE 56932
// hInvincible := hInvincible diff i else
56914: LD_ADDR_EXP 149
56918: PUSH
56919: LD_EXP 149
56923: PUSH
56924: LD_VAR 0 2
56928: DIFF
56929: ST_TO_ADDR
56930: GO 56948
// hInvincible := hInvincible union i ;
56932: LD_ADDR_EXP 149
56936: PUSH
56937: LD_EXP 149
56941: PUSH
56942: LD_VAR 0 2
56946: UNION
56947: ST_TO_ADDR
// end ;
56948: GO 56888
56950: POP
56951: POP
// end ;
56952: LD_VAR 0 1
56956: RET
// export function hHackInvisible ; var i , j ; begin
56957: LD_INT 0
56959: PPUSH
56960: PPUSH
56961: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56962: LD_ADDR_VAR 0 2
56966: PUSH
56967: LD_INT 21
56969: PUSH
56970: LD_INT 1
56972: PUSH
56973: EMPTY
56974: LIST
56975: LIST
56976: PPUSH
56977: CALL_OW 69
56981: PUSH
56982: FOR_IN
56983: IFFALSE 57007
// if IsSelected ( i ) then
56985: LD_VAR 0 2
56989: PPUSH
56990: CALL_OW 306
56994: IFFALSE 57005
// ComForceInvisible ( i ) ;
56996: LD_VAR 0 2
57000: PPUSH
57001: CALL_OW 496
57005: GO 56982
57007: POP
57008: POP
// end ;
57009: LD_VAR 0 1
57013: RET
// export function hHackChangeYourSide ; begin
57014: LD_INT 0
57016: PPUSH
// if your_side = 8 then
57017: LD_OWVAR 2
57021: PUSH
57022: LD_INT 8
57024: EQUAL
57025: IFFALSE 57037
// your_side := 0 else
57027: LD_ADDR_OWVAR 2
57031: PUSH
57032: LD_INT 0
57034: ST_TO_ADDR
57035: GO 57051
// your_side := your_side + 1 ;
57037: LD_ADDR_OWVAR 2
57041: PUSH
57042: LD_OWVAR 2
57046: PUSH
57047: LD_INT 1
57049: PLUS
57050: ST_TO_ADDR
// end ;
57051: LD_VAR 0 1
57055: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57056: LD_INT 0
57058: PPUSH
57059: PPUSH
57060: PPUSH
// for i in all_units do
57061: LD_ADDR_VAR 0 2
57065: PUSH
57066: LD_OWVAR 3
57070: PUSH
57071: FOR_IN
57072: IFFALSE 57150
// if IsSelected ( i ) then
57074: LD_VAR 0 2
57078: PPUSH
57079: CALL_OW 306
57083: IFFALSE 57148
// begin j := GetSide ( i ) ;
57085: LD_ADDR_VAR 0 3
57089: PUSH
57090: LD_VAR 0 2
57094: PPUSH
57095: CALL_OW 255
57099: ST_TO_ADDR
// if j = 8 then
57100: LD_VAR 0 3
57104: PUSH
57105: LD_INT 8
57107: EQUAL
57108: IFFALSE 57120
// j := 0 else
57110: LD_ADDR_VAR 0 3
57114: PUSH
57115: LD_INT 0
57117: ST_TO_ADDR
57118: GO 57134
// j := j + 1 ;
57120: LD_ADDR_VAR 0 3
57124: PUSH
57125: LD_VAR 0 3
57129: PUSH
57130: LD_INT 1
57132: PLUS
57133: ST_TO_ADDR
// SetSide ( i , j ) ;
57134: LD_VAR 0 2
57138: PPUSH
57139: LD_VAR 0 3
57143: PPUSH
57144: CALL_OW 235
// end ;
57148: GO 57071
57150: POP
57151: POP
// end ;
57152: LD_VAR 0 1
57156: RET
// export function hHackFog ; begin
57157: LD_INT 0
57159: PPUSH
// FogOff ( true ) ;
57160: LD_INT 1
57162: PPUSH
57163: CALL_OW 344
// end ;
57167: LD_VAR 0 1
57171: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57172: LD_INT 0
57174: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57175: LD_VAR 0 1
57179: PPUSH
57180: LD_VAR 0 2
57184: PPUSH
57185: LD_VAR 0 3
57189: PPUSH
57190: LD_INT 1
57192: PPUSH
57193: LD_INT 1
57195: PPUSH
57196: CALL_OW 483
// CenterOnXY ( x , y ) ;
57200: LD_VAR 0 2
57204: PPUSH
57205: LD_VAR 0 3
57209: PPUSH
57210: CALL_OW 84
// end ; end_of_file
57214: LD_VAR 0 4
57218: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
57219: LD_INT 0
57221: PPUSH
57222: PPUSH
57223: PPUSH
57224: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
57225: LD_VAR 0 1
57229: PPUSH
57230: CALL_OW 264
57234: PUSH
57235: LD_EXP 77
57239: EQUAL
57240: IFFALSE 57312
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
57242: LD_INT 68
57244: PPUSH
57245: LD_VAR 0 1
57249: PPUSH
57250: CALL_OW 255
57254: PPUSH
57255: CALL_OW 321
57259: PUSH
57260: LD_INT 2
57262: EQUAL
57263: IFFALSE 57275
// eff := 70 else
57265: LD_ADDR_VAR 0 4
57269: PUSH
57270: LD_INT 70
57272: ST_TO_ADDR
57273: GO 57283
// eff := 30 ;
57275: LD_ADDR_VAR 0 4
57279: PUSH
57280: LD_INT 30
57282: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
57283: LD_VAR 0 1
57287: PPUSH
57288: CALL_OW 250
57292: PPUSH
57293: LD_VAR 0 1
57297: PPUSH
57298: CALL_OW 251
57302: PPUSH
57303: LD_VAR 0 4
57307: PPUSH
57308: CALL_OW 495
// end ; end ;
57312: LD_VAR 0 2
57316: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
57317: LD_INT 0
57319: PPUSH
// end ;
57320: LD_VAR 0 4
57324: RET
// export function SOS_Command ( cmd ) ; begin
57325: LD_INT 0
57327: PPUSH
// end ;
57328: LD_VAR 0 2
57332: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
57333: LD_INT 0
57335: PPUSH
// end ;
57336: LD_VAR 0 6
57340: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
57341: LD_INT 0
57343: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
57344: LD_VAR 0 1
57348: PUSH
57349: LD_INT 250
57351: EQUAL
57352: PUSH
57353: LD_VAR 0 2
57357: PPUSH
57358: CALL_OW 264
57362: PUSH
57363: LD_EXP 80
57367: EQUAL
57368: AND
57369: IFFALSE 57390
// MinerPlaceMine ( unit , x , y ) ;
57371: LD_VAR 0 2
57375: PPUSH
57376: LD_VAR 0 4
57380: PPUSH
57381: LD_VAR 0 5
57385: PPUSH
57386: CALL 59739 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
57390: LD_VAR 0 1
57394: PUSH
57395: LD_INT 251
57397: EQUAL
57398: PUSH
57399: LD_VAR 0 2
57403: PPUSH
57404: CALL_OW 264
57408: PUSH
57409: LD_EXP 80
57413: EQUAL
57414: AND
57415: IFFALSE 57436
// MinerDetonateMine ( unit , x , y ) ;
57417: LD_VAR 0 2
57421: PPUSH
57422: LD_VAR 0 4
57426: PPUSH
57427: LD_VAR 0 5
57431: PPUSH
57432: CALL 60016 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
57436: LD_VAR 0 1
57440: PUSH
57441: LD_INT 252
57443: EQUAL
57444: PUSH
57445: LD_VAR 0 2
57449: PPUSH
57450: CALL_OW 264
57454: PUSH
57455: LD_EXP 80
57459: EQUAL
57460: AND
57461: IFFALSE 57482
// MinerCreateMinefield ( unit , x , y ) ;
57463: LD_VAR 0 2
57467: PPUSH
57468: LD_VAR 0 4
57472: PPUSH
57473: LD_VAR 0 5
57477: PPUSH
57478: CALL 60433 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
57482: LD_VAR 0 1
57486: PUSH
57487: LD_INT 253
57489: EQUAL
57490: PUSH
57491: LD_VAR 0 2
57495: PPUSH
57496: CALL_OW 257
57500: PUSH
57501: LD_INT 5
57503: EQUAL
57504: AND
57505: IFFALSE 57526
// ComBinocular ( unit , x , y ) ;
57507: LD_VAR 0 2
57511: PPUSH
57512: LD_VAR 0 4
57516: PPUSH
57517: LD_VAR 0 5
57521: PPUSH
57522: CALL 60804 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
57526: LD_VAR 0 1
57530: PUSH
57531: LD_INT 254
57533: EQUAL
57534: PUSH
57535: LD_VAR 0 2
57539: PPUSH
57540: CALL_OW 264
57544: PUSH
57545: LD_EXP 75
57549: EQUAL
57550: AND
57551: PUSH
57552: LD_VAR 0 3
57556: PPUSH
57557: CALL_OW 263
57561: PUSH
57562: LD_INT 3
57564: EQUAL
57565: AND
57566: IFFALSE 57582
// HackDestroyVehicle ( unit , selectedUnit ) ;
57568: LD_VAR 0 2
57572: PPUSH
57573: LD_VAR 0 3
57577: PPUSH
57578: CALL 59099 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
57582: LD_VAR 0 1
57586: PUSH
57587: LD_INT 255
57589: EQUAL
57590: PUSH
57591: LD_VAR 0 2
57595: PPUSH
57596: CALL_OW 264
57600: PUSH
57601: LD_INT 14
57603: PUSH
57604: LD_INT 53
57606: PUSH
57607: EMPTY
57608: LIST
57609: LIST
57610: IN
57611: AND
57612: PUSH
57613: LD_VAR 0 4
57617: PPUSH
57618: LD_VAR 0 5
57622: PPUSH
57623: CALL_OW 488
57627: AND
57628: IFFALSE 57652
// CutTreeXYR ( unit , x , y , 12 ) ;
57630: LD_VAR 0 2
57634: PPUSH
57635: LD_VAR 0 4
57639: PPUSH
57640: LD_VAR 0 5
57644: PPUSH
57645: LD_INT 12
57647: PPUSH
57648: CALL 57665 0 4
// end ;
57652: LD_VAR 0 6
57656: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
57657: LD_INT 0
57659: PPUSH
// end ;
57660: LD_VAR 0 4
57664: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
57665: LD_INT 0
57667: PPUSH
57668: PPUSH
57669: PPUSH
57670: PPUSH
57671: PPUSH
57672: PPUSH
57673: PPUSH
57674: PPUSH
57675: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
57676: LD_VAR 0 1
57680: NOT
57681: PUSH
57682: LD_VAR 0 2
57686: PPUSH
57687: LD_VAR 0 3
57691: PPUSH
57692: CALL_OW 488
57696: NOT
57697: OR
57698: PUSH
57699: LD_VAR 0 4
57703: NOT
57704: OR
57705: IFFALSE 57709
// exit ;
57707: GO 58049
// list := [ ] ;
57709: LD_ADDR_VAR 0 13
57713: PUSH
57714: EMPTY
57715: ST_TO_ADDR
// if x - r < 0 then
57716: LD_VAR 0 2
57720: PUSH
57721: LD_VAR 0 4
57725: MINUS
57726: PUSH
57727: LD_INT 0
57729: LESS
57730: IFFALSE 57742
// min_x := 0 else
57732: LD_ADDR_VAR 0 7
57736: PUSH
57737: LD_INT 0
57739: ST_TO_ADDR
57740: GO 57758
// min_x := x - r ;
57742: LD_ADDR_VAR 0 7
57746: PUSH
57747: LD_VAR 0 2
57751: PUSH
57752: LD_VAR 0 4
57756: MINUS
57757: ST_TO_ADDR
// if y - r < 0 then
57758: LD_VAR 0 3
57762: PUSH
57763: LD_VAR 0 4
57767: MINUS
57768: PUSH
57769: LD_INT 0
57771: LESS
57772: IFFALSE 57784
// min_y := 0 else
57774: LD_ADDR_VAR 0 8
57778: PUSH
57779: LD_INT 0
57781: ST_TO_ADDR
57782: GO 57800
// min_y := y - r ;
57784: LD_ADDR_VAR 0 8
57788: PUSH
57789: LD_VAR 0 3
57793: PUSH
57794: LD_VAR 0 4
57798: MINUS
57799: ST_TO_ADDR
// max_x := x + r ;
57800: LD_ADDR_VAR 0 9
57804: PUSH
57805: LD_VAR 0 2
57809: PUSH
57810: LD_VAR 0 4
57814: PLUS
57815: ST_TO_ADDR
// max_y := y + r ;
57816: LD_ADDR_VAR 0 10
57820: PUSH
57821: LD_VAR 0 3
57825: PUSH
57826: LD_VAR 0 4
57830: PLUS
57831: ST_TO_ADDR
// for _x = min_x to max_x do
57832: LD_ADDR_VAR 0 11
57836: PUSH
57837: DOUBLE
57838: LD_VAR 0 7
57842: DEC
57843: ST_TO_ADDR
57844: LD_VAR 0 9
57848: PUSH
57849: FOR_TO
57850: IFFALSE 57967
// for _y = min_y to max_y do
57852: LD_ADDR_VAR 0 12
57856: PUSH
57857: DOUBLE
57858: LD_VAR 0 8
57862: DEC
57863: ST_TO_ADDR
57864: LD_VAR 0 10
57868: PUSH
57869: FOR_TO
57870: IFFALSE 57963
// begin if not ValidHex ( _x , _y ) then
57872: LD_VAR 0 11
57876: PPUSH
57877: LD_VAR 0 12
57881: PPUSH
57882: CALL_OW 488
57886: NOT
57887: IFFALSE 57891
// continue ;
57889: GO 57869
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57891: LD_VAR 0 11
57895: PPUSH
57896: LD_VAR 0 12
57900: PPUSH
57901: CALL_OW 351
57905: PUSH
57906: LD_VAR 0 11
57910: PPUSH
57911: LD_VAR 0 12
57915: PPUSH
57916: CALL_OW 554
57920: AND
57921: IFFALSE 57961
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57923: LD_ADDR_VAR 0 13
57927: PUSH
57928: LD_VAR 0 13
57932: PPUSH
57933: LD_VAR 0 13
57937: PUSH
57938: LD_INT 1
57940: PLUS
57941: PPUSH
57942: LD_VAR 0 11
57946: PUSH
57947: LD_VAR 0 12
57951: PUSH
57952: EMPTY
57953: LIST
57954: LIST
57955: PPUSH
57956: CALL_OW 2
57960: ST_TO_ADDR
// end ;
57961: GO 57869
57963: POP
57964: POP
57965: GO 57849
57967: POP
57968: POP
// if not list then
57969: LD_VAR 0 13
57973: NOT
57974: IFFALSE 57978
// exit ;
57976: GO 58049
// for i in list do
57978: LD_ADDR_VAR 0 6
57982: PUSH
57983: LD_VAR 0 13
57987: PUSH
57988: FOR_IN
57989: IFFALSE 58047
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57991: LD_VAR 0 1
57995: PPUSH
57996: LD_STRING M
57998: PUSH
57999: LD_VAR 0 6
58003: PUSH
58004: LD_INT 1
58006: ARRAY
58007: PUSH
58008: LD_VAR 0 6
58012: PUSH
58013: LD_INT 2
58015: ARRAY
58016: PUSH
58017: LD_INT 0
58019: PUSH
58020: LD_INT 0
58022: PUSH
58023: LD_INT 0
58025: PUSH
58026: LD_INT 0
58028: PUSH
58029: EMPTY
58030: LIST
58031: LIST
58032: LIST
58033: LIST
58034: LIST
58035: LIST
58036: LIST
58037: PUSH
58038: EMPTY
58039: LIST
58040: PPUSH
58041: CALL_OW 447
58045: GO 57988
58047: POP
58048: POP
// end ;
58049: LD_VAR 0 5
58053: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
58054: LD_EXP 152
58058: NOT
58059: IFFALSE 58109
58061: GO 58063
58063: DISABLE
// begin initHack := true ;
58064: LD_ADDR_EXP 152
58068: PUSH
58069: LD_INT 1
58071: ST_TO_ADDR
// hackTanks := [ ] ;
58072: LD_ADDR_EXP 153
58076: PUSH
58077: EMPTY
58078: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
58079: LD_ADDR_EXP 154
58083: PUSH
58084: EMPTY
58085: ST_TO_ADDR
// hackLimit := 3 ;
58086: LD_ADDR_EXP 155
58090: PUSH
58091: LD_INT 3
58093: ST_TO_ADDR
// hackDist := 12 ;
58094: LD_ADDR_EXP 156
58098: PUSH
58099: LD_INT 12
58101: ST_TO_ADDR
// hackCounter := [ ] ;
58102: LD_ADDR_EXP 157
58106: PUSH
58107: EMPTY
58108: ST_TO_ADDR
// end ;
58109: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
58110: LD_EXP 152
58114: PUSH
58115: LD_INT 34
58117: PUSH
58118: LD_EXP 75
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: PPUSH
58127: CALL_OW 69
58131: AND
58132: IFFALSE 58387
58134: GO 58136
58136: DISABLE
58137: LD_INT 0
58139: PPUSH
58140: PPUSH
// begin enable ;
58141: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
58142: LD_ADDR_VAR 0 1
58146: PUSH
58147: LD_INT 34
58149: PUSH
58150: LD_EXP 75
58154: PUSH
58155: EMPTY
58156: LIST
58157: LIST
58158: PPUSH
58159: CALL_OW 69
58163: PUSH
58164: FOR_IN
58165: IFFALSE 58385
// begin if not i in hackTanks then
58167: LD_VAR 0 1
58171: PUSH
58172: LD_EXP 153
58176: IN
58177: NOT
58178: IFFALSE 58261
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
58180: LD_ADDR_EXP 153
58184: PUSH
58185: LD_EXP 153
58189: PPUSH
58190: LD_EXP 153
58194: PUSH
58195: LD_INT 1
58197: PLUS
58198: PPUSH
58199: LD_VAR 0 1
58203: PPUSH
58204: CALL_OW 1
58208: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
58209: LD_ADDR_EXP 154
58213: PUSH
58214: LD_EXP 154
58218: PPUSH
58219: LD_EXP 154
58223: PUSH
58224: LD_INT 1
58226: PLUS
58227: PPUSH
58228: EMPTY
58229: PPUSH
58230: CALL_OW 1
58234: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
58235: LD_ADDR_EXP 157
58239: PUSH
58240: LD_EXP 157
58244: PPUSH
58245: LD_EXP 157
58249: PUSH
58250: LD_INT 1
58252: PLUS
58253: PPUSH
58254: EMPTY
58255: PPUSH
58256: CALL_OW 1
58260: ST_TO_ADDR
// end ; if not IsOk ( i ) then
58261: LD_VAR 0 1
58265: PPUSH
58266: CALL_OW 302
58270: NOT
58271: IFFALSE 58284
// begin HackUnlinkAll ( i ) ;
58273: LD_VAR 0 1
58277: PPUSH
58278: CALL 58390 0 1
// continue ;
58282: GO 58164
// end ; HackCheckCapturedStatus ( i ) ;
58284: LD_VAR 0 1
58288: PPUSH
58289: CALL 58833 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
58293: LD_ADDR_VAR 0 2
58297: PUSH
58298: LD_INT 81
58300: PUSH
58301: LD_VAR 0 1
58305: PPUSH
58306: CALL_OW 255
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: LD_INT 33
58317: PUSH
58318: LD_INT 3
58320: PUSH
58321: EMPTY
58322: LIST
58323: LIST
58324: PUSH
58325: LD_INT 91
58327: PUSH
58328: LD_VAR 0 1
58332: PUSH
58333: LD_EXP 156
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: LIST
58342: PUSH
58343: LD_INT 50
58345: PUSH
58346: EMPTY
58347: LIST
58348: PUSH
58349: EMPTY
58350: LIST
58351: LIST
58352: LIST
58353: LIST
58354: PPUSH
58355: CALL_OW 69
58359: ST_TO_ADDR
// if not tmp then
58360: LD_VAR 0 2
58364: NOT
58365: IFFALSE 58369
// continue ;
58367: GO 58164
// HackLink ( i , tmp ) ;
58369: LD_VAR 0 1
58373: PPUSH
58374: LD_VAR 0 2
58378: PPUSH
58379: CALL 58526 0 2
// end ;
58383: GO 58164
58385: POP
58386: POP
// end ;
58387: PPOPN 2
58389: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
58390: LD_INT 0
58392: PPUSH
58393: PPUSH
58394: PPUSH
// if not hack in hackTanks then
58395: LD_VAR 0 1
58399: PUSH
58400: LD_EXP 153
58404: IN
58405: NOT
58406: IFFALSE 58410
// exit ;
58408: GO 58521
// index := GetElementIndex ( hackTanks , hack ) ;
58410: LD_ADDR_VAR 0 4
58414: PUSH
58415: LD_EXP 153
58419: PPUSH
58420: LD_VAR 0 1
58424: PPUSH
58425: CALL 65995 0 2
58429: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
58430: LD_EXP 154
58434: PUSH
58435: LD_VAR 0 4
58439: ARRAY
58440: IFFALSE 58521
// begin for i in hackTanksCaptured [ index ] do
58442: LD_ADDR_VAR 0 3
58446: PUSH
58447: LD_EXP 154
58451: PUSH
58452: LD_VAR 0 4
58456: ARRAY
58457: PUSH
58458: FOR_IN
58459: IFFALSE 58485
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
58461: LD_VAR 0 3
58465: PUSH
58466: LD_INT 1
58468: ARRAY
58469: PPUSH
58470: LD_VAR 0 3
58474: PUSH
58475: LD_INT 2
58477: ARRAY
58478: PPUSH
58479: CALL_OW 235
58483: GO 58458
58485: POP
58486: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
58487: LD_ADDR_EXP 154
58491: PUSH
58492: LD_EXP 154
58496: PPUSH
58497: LD_VAR 0 4
58501: PPUSH
58502: EMPTY
58503: PPUSH
58504: CALL_OW 1
58508: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
58509: LD_VAR 0 1
58513: PPUSH
58514: LD_INT 0
58516: PPUSH
58517: CALL_OW 505
// end ; end ;
58521: LD_VAR 0 2
58525: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
58526: LD_INT 0
58528: PPUSH
58529: PPUSH
58530: PPUSH
// if not hack in hackTanks or not vehicles then
58531: LD_VAR 0 1
58535: PUSH
58536: LD_EXP 153
58540: IN
58541: NOT
58542: PUSH
58543: LD_VAR 0 2
58547: NOT
58548: OR
58549: IFFALSE 58553
// exit ;
58551: GO 58828
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
58553: LD_ADDR_VAR 0 2
58557: PUSH
58558: LD_VAR 0 1
58562: PPUSH
58563: LD_VAR 0 2
58567: PPUSH
58568: LD_INT 1
58570: PPUSH
58571: LD_INT 1
58573: PPUSH
58574: CALL 66645 0 4
58578: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
58579: LD_ADDR_VAR 0 5
58583: PUSH
58584: LD_EXP 153
58588: PPUSH
58589: LD_VAR 0 1
58593: PPUSH
58594: CALL 65995 0 2
58598: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
58599: LD_EXP 154
58603: PUSH
58604: LD_VAR 0 5
58608: ARRAY
58609: PUSH
58610: LD_EXP 155
58614: LESS
58615: IFFALSE 58804
// begin for i := 1 to vehicles do
58617: LD_ADDR_VAR 0 4
58621: PUSH
58622: DOUBLE
58623: LD_INT 1
58625: DEC
58626: ST_TO_ADDR
58627: LD_VAR 0 2
58631: PUSH
58632: FOR_TO
58633: IFFALSE 58802
// begin if hackTanksCaptured [ index ] = hackLimit then
58635: LD_EXP 154
58639: PUSH
58640: LD_VAR 0 5
58644: ARRAY
58645: PUSH
58646: LD_EXP 155
58650: EQUAL
58651: IFFALSE 58655
// break ;
58653: GO 58802
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
58655: LD_ADDR_EXP 157
58659: PUSH
58660: LD_EXP 157
58664: PPUSH
58665: LD_VAR 0 5
58669: PPUSH
58670: LD_EXP 157
58674: PUSH
58675: LD_VAR 0 5
58679: ARRAY
58680: PUSH
58681: LD_INT 1
58683: PLUS
58684: PPUSH
58685: CALL_OW 1
58689: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
58690: LD_ADDR_EXP 154
58694: PUSH
58695: LD_EXP 154
58699: PPUSH
58700: LD_VAR 0 5
58704: PUSH
58705: LD_EXP 154
58709: PUSH
58710: LD_VAR 0 5
58714: ARRAY
58715: PUSH
58716: LD_INT 1
58718: PLUS
58719: PUSH
58720: EMPTY
58721: LIST
58722: LIST
58723: PPUSH
58724: LD_VAR 0 2
58728: PUSH
58729: LD_VAR 0 4
58733: ARRAY
58734: PUSH
58735: LD_VAR 0 2
58739: PUSH
58740: LD_VAR 0 4
58744: ARRAY
58745: PPUSH
58746: CALL_OW 255
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: PPUSH
58755: CALL 66210 0 3
58759: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58760: LD_VAR 0 2
58764: PUSH
58765: LD_VAR 0 4
58769: ARRAY
58770: PPUSH
58771: LD_VAR 0 1
58775: PPUSH
58776: CALL_OW 255
58780: PPUSH
58781: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58785: LD_VAR 0 2
58789: PUSH
58790: LD_VAR 0 4
58794: ARRAY
58795: PPUSH
58796: CALL_OW 141
// end ;
58800: GO 58632
58802: POP
58803: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58804: LD_VAR 0 1
58808: PPUSH
58809: LD_EXP 154
58813: PUSH
58814: LD_VAR 0 5
58818: ARRAY
58819: PUSH
58820: LD_INT 0
58822: PLUS
58823: PPUSH
58824: CALL_OW 505
// end ;
58828: LD_VAR 0 3
58832: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58833: LD_INT 0
58835: PPUSH
58836: PPUSH
58837: PPUSH
58838: PPUSH
// if not hack in hackTanks then
58839: LD_VAR 0 1
58843: PUSH
58844: LD_EXP 153
58848: IN
58849: NOT
58850: IFFALSE 58854
// exit ;
58852: GO 59094
// index := GetElementIndex ( hackTanks , hack ) ;
58854: LD_ADDR_VAR 0 4
58858: PUSH
58859: LD_EXP 153
58863: PPUSH
58864: LD_VAR 0 1
58868: PPUSH
58869: CALL 65995 0 2
58873: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58874: LD_ADDR_VAR 0 3
58878: PUSH
58879: DOUBLE
58880: LD_EXP 154
58884: PUSH
58885: LD_VAR 0 4
58889: ARRAY
58890: INC
58891: ST_TO_ADDR
58892: LD_INT 1
58894: PUSH
58895: FOR_DOWNTO
58896: IFFALSE 59068
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58898: LD_ADDR_VAR 0 5
58902: PUSH
58903: LD_EXP 154
58907: PUSH
58908: LD_VAR 0 4
58912: ARRAY
58913: PUSH
58914: LD_VAR 0 3
58918: ARRAY
58919: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58920: LD_VAR 0 5
58924: PUSH
58925: LD_INT 1
58927: ARRAY
58928: PPUSH
58929: CALL_OW 302
58933: NOT
58934: PUSH
58935: LD_VAR 0 5
58939: PUSH
58940: LD_INT 1
58942: ARRAY
58943: PPUSH
58944: CALL_OW 255
58948: PUSH
58949: LD_VAR 0 1
58953: PPUSH
58954: CALL_OW 255
58958: NONEQUAL
58959: OR
58960: IFFALSE 59066
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58962: LD_VAR 0 5
58966: PUSH
58967: LD_INT 1
58969: ARRAY
58970: PPUSH
58971: CALL_OW 305
58975: PUSH
58976: LD_VAR 0 5
58980: PUSH
58981: LD_INT 1
58983: ARRAY
58984: PPUSH
58985: CALL_OW 255
58989: PUSH
58990: LD_VAR 0 1
58994: PPUSH
58995: CALL_OW 255
58999: EQUAL
59000: AND
59001: IFFALSE 59025
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
59003: LD_VAR 0 5
59007: PUSH
59008: LD_INT 1
59010: ARRAY
59011: PPUSH
59012: LD_VAR 0 5
59016: PUSH
59017: LD_INT 2
59019: ARRAY
59020: PPUSH
59021: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
59025: LD_ADDR_EXP 154
59029: PUSH
59030: LD_EXP 154
59034: PPUSH
59035: LD_VAR 0 4
59039: PPUSH
59040: LD_EXP 154
59044: PUSH
59045: LD_VAR 0 4
59049: ARRAY
59050: PPUSH
59051: LD_VAR 0 3
59055: PPUSH
59056: CALL_OW 3
59060: PPUSH
59061: CALL_OW 1
59065: ST_TO_ADDR
// end ; end ;
59066: GO 58895
59068: POP
59069: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
59070: LD_VAR 0 1
59074: PPUSH
59075: LD_EXP 154
59079: PUSH
59080: LD_VAR 0 4
59084: ARRAY
59085: PUSH
59086: LD_INT 0
59088: PLUS
59089: PPUSH
59090: CALL_OW 505
// end ;
59094: LD_VAR 0 2
59098: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
59099: LD_INT 0
59101: PPUSH
59102: PPUSH
59103: PPUSH
59104: PPUSH
// if not hack in hackTanks then
59105: LD_VAR 0 1
59109: PUSH
59110: LD_EXP 153
59114: IN
59115: NOT
59116: IFFALSE 59120
// exit ;
59118: GO 59205
// index := GetElementIndex ( hackTanks , hack ) ;
59120: LD_ADDR_VAR 0 5
59124: PUSH
59125: LD_EXP 153
59129: PPUSH
59130: LD_VAR 0 1
59134: PPUSH
59135: CALL 65995 0 2
59139: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
59140: LD_ADDR_VAR 0 4
59144: PUSH
59145: DOUBLE
59146: LD_INT 1
59148: DEC
59149: ST_TO_ADDR
59150: LD_EXP 154
59154: PUSH
59155: LD_VAR 0 5
59159: ARRAY
59160: PUSH
59161: FOR_TO
59162: IFFALSE 59203
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
59164: LD_EXP 154
59168: PUSH
59169: LD_VAR 0 5
59173: ARRAY
59174: PUSH
59175: LD_VAR 0 4
59179: ARRAY
59180: PUSH
59181: LD_INT 1
59183: ARRAY
59184: PUSH
59185: LD_VAR 0 2
59189: EQUAL
59190: IFFALSE 59201
// KillUnit ( vehicle ) ;
59192: LD_VAR 0 2
59196: PPUSH
59197: CALL_OW 66
59201: GO 59161
59203: POP
59204: POP
// end ;
59205: LD_VAR 0 3
59209: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
59210: LD_EXP 158
59214: NOT
59215: IFFALSE 59250
59217: GO 59219
59219: DISABLE
// begin initMiner := true ;
59220: LD_ADDR_EXP 158
59224: PUSH
59225: LD_INT 1
59227: ST_TO_ADDR
// minersList := [ ] ;
59228: LD_ADDR_EXP 159
59232: PUSH
59233: EMPTY
59234: ST_TO_ADDR
// minerMinesList := [ ] ;
59235: LD_ADDR_EXP 160
59239: PUSH
59240: EMPTY
59241: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
59242: LD_ADDR_EXP 161
59246: PUSH
59247: LD_INT 5
59249: ST_TO_ADDR
// end ;
59250: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
59251: LD_EXP 158
59255: PUSH
59256: LD_INT 34
59258: PUSH
59259: LD_EXP 80
59263: PUSH
59264: EMPTY
59265: LIST
59266: LIST
59267: PPUSH
59268: CALL_OW 69
59272: AND
59273: IFFALSE 59736
59275: GO 59277
59277: DISABLE
59278: LD_INT 0
59280: PPUSH
59281: PPUSH
59282: PPUSH
59283: PPUSH
// begin enable ;
59284: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
59285: LD_ADDR_VAR 0 1
59289: PUSH
59290: LD_INT 34
59292: PUSH
59293: LD_EXP 80
59297: PUSH
59298: EMPTY
59299: LIST
59300: LIST
59301: PPUSH
59302: CALL_OW 69
59306: PUSH
59307: FOR_IN
59308: IFFALSE 59380
// begin if not i in minersList then
59310: LD_VAR 0 1
59314: PUSH
59315: LD_EXP 159
59319: IN
59320: NOT
59321: IFFALSE 59378
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
59323: LD_ADDR_EXP 159
59327: PUSH
59328: LD_EXP 159
59332: PPUSH
59333: LD_EXP 159
59337: PUSH
59338: LD_INT 1
59340: PLUS
59341: PPUSH
59342: LD_VAR 0 1
59346: PPUSH
59347: CALL_OW 1
59351: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
59352: LD_ADDR_EXP 160
59356: PUSH
59357: LD_EXP 160
59361: PPUSH
59362: LD_EXP 160
59366: PUSH
59367: LD_INT 1
59369: PLUS
59370: PPUSH
59371: EMPTY
59372: PPUSH
59373: CALL_OW 1
59377: ST_TO_ADDR
// end end ;
59378: GO 59307
59380: POP
59381: POP
// for i := minerMinesList downto 1 do
59382: LD_ADDR_VAR 0 1
59386: PUSH
59387: DOUBLE
59388: LD_EXP 160
59392: INC
59393: ST_TO_ADDR
59394: LD_INT 1
59396: PUSH
59397: FOR_DOWNTO
59398: IFFALSE 59734
// begin if IsLive ( minersList [ i ] ) then
59400: LD_EXP 159
59404: PUSH
59405: LD_VAR 0 1
59409: ARRAY
59410: PPUSH
59411: CALL_OW 300
59415: IFFALSE 59443
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
59417: LD_EXP 159
59421: PUSH
59422: LD_VAR 0 1
59426: ARRAY
59427: PPUSH
59428: LD_EXP 160
59432: PUSH
59433: LD_VAR 0 1
59437: ARRAY
59438: PPUSH
59439: CALL_OW 505
// if not minerMinesList [ i ] then
59443: LD_EXP 160
59447: PUSH
59448: LD_VAR 0 1
59452: ARRAY
59453: NOT
59454: IFFALSE 59458
// continue ;
59456: GO 59397
// for j := minerMinesList [ i ] downto 1 do
59458: LD_ADDR_VAR 0 2
59462: PUSH
59463: DOUBLE
59464: LD_EXP 160
59468: PUSH
59469: LD_VAR 0 1
59473: ARRAY
59474: INC
59475: ST_TO_ADDR
59476: LD_INT 1
59478: PUSH
59479: FOR_DOWNTO
59480: IFFALSE 59730
// begin side := GetSide ( minersList [ i ] ) ;
59482: LD_ADDR_VAR 0 3
59486: PUSH
59487: LD_EXP 159
59491: PUSH
59492: LD_VAR 0 1
59496: ARRAY
59497: PPUSH
59498: CALL_OW 255
59502: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
59503: LD_ADDR_VAR 0 4
59507: PUSH
59508: LD_EXP 160
59512: PUSH
59513: LD_VAR 0 1
59517: ARRAY
59518: PUSH
59519: LD_VAR 0 2
59523: ARRAY
59524: PUSH
59525: LD_INT 1
59527: ARRAY
59528: PPUSH
59529: LD_EXP 160
59533: PUSH
59534: LD_VAR 0 1
59538: ARRAY
59539: PUSH
59540: LD_VAR 0 2
59544: ARRAY
59545: PUSH
59546: LD_INT 2
59548: ARRAY
59549: PPUSH
59550: CALL_OW 428
59554: ST_TO_ADDR
// if not tmp then
59555: LD_VAR 0 4
59559: NOT
59560: IFFALSE 59564
// continue ;
59562: GO 59479
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
59564: LD_VAR 0 4
59568: PUSH
59569: LD_INT 81
59571: PUSH
59572: LD_VAR 0 3
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: PPUSH
59581: CALL_OW 69
59585: IN
59586: PUSH
59587: LD_EXP 160
59591: PUSH
59592: LD_VAR 0 1
59596: ARRAY
59597: PUSH
59598: LD_VAR 0 2
59602: ARRAY
59603: PUSH
59604: LD_INT 1
59606: ARRAY
59607: PPUSH
59608: LD_EXP 160
59612: PUSH
59613: LD_VAR 0 1
59617: ARRAY
59618: PUSH
59619: LD_VAR 0 2
59623: ARRAY
59624: PUSH
59625: LD_INT 2
59627: ARRAY
59628: PPUSH
59629: CALL_OW 458
59633: AND
59634: IFFALSE 59728
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
59636: LD_EXP 160
59640: PUSH
59641: LD_VAR 0 1
59645: ARRAY
59646: PUSH
59647: LD_VAR 0 2
59651: ARRAY
59652: PUSH
59653: LD_INT 1
59655: ARRAY
59656: PPUSH
59657: LD_EXP 160
59661: PUSH
59662: LD_VAR 0 1
59666: ARRAY
59667: PUSH
59668: LD_VAR 0 2
59672: ARRAY
59673: PUSH
59674: LD_INT 2
59676: ARRAY
59677: PPUSH
59678: LD_VAR 0 3
59682: PPUSH
59683: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
59687: LD_ADDR_EXP 160
59691: PUSH
59692: LD_EXP 160
59696: PPUSH
59697: LD_VAR 0 1
59701: PPUSH
59702: LD_EXP 160
59706: PUSH
59707: LD_VAR 0 1
59711: ARRAY
59712: PPUSH
59713: LD_VAR 0 2
59717: PPUSH
59718: CALL_OW 3
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// end ; end ;
59728: GO 59479
59730: POP
59731: POP
// end ;
59732: GO 59397
59734: POP
59735: POP
// end ;
59736: PPOPN 4
59738: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59739: LD_INT 0
59741: PPUSH
59742: PPUSH
// result := false ;
59743: LD_ADDR_VAR 0 4
59747: PUSH
59748: LD_INT 0
59750: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59751: LD_VAR 0 1
59755: PPUSH
59756: CALL_OW 264
59760: PUSH
59761: LD_EXP 80
59765: EQUAL
59766: NOT
59767: IFFALSE 59771
// exit ;
59769: GO 60011
// index := GetElementIndex ( minersList , unit ) ;
59771: LD_ADDR_VAR 0 5
59775: PUSH
59776: LD_EXP 159
59780: PPUSH
59781: LD_VAR 0 1
59785: PPUSH
59786: CALL 65995 0 2
59790: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59791: LD_EXP 160
59795: PUSH
59796: LD_VAR 0 5
59800: ARRAY
59801: PUSH
59802: LD_EXP 161
59806: GREATEREQUAL
59807: IFFALSE 59811
// exit ;
59809: GO 60011
// ComMoveXY ( unit , x , y ) ;
59811: LD_VAR 0 1
59815: PPUSH
59816: LD_VAR 0 2
59820: PPUSH
59821: LD_VAR 0 3
59825: PPUSH
59826: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59830: LD_INT 35
59832: PPUSH
59833: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59837: LD_VAR 0 1
59841: PPUSH
59842: LD_VAR 0 2
59846: PPUSH
59847: LD_VAR 0 3
59851: PPUSH
59852: CALL 96767 0 3
59856: NOT
59857: PUSH
59858: LD_VAR 0 1
59862: PPUSH
59863: CALL_OW 314
59867: AND
59868: IFFALSE 59872
// exit ;
59870: GO 60011
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59872: LD_VAR 0 2
59876: PPUSH
59877: LD_VAR 0 3
59881: PPUSH
59882: CALL_OW 428
59886: PUSH
59887: LD_VAR 0 1
59891: EQUAL
59892: PUSH
59893: LD_VAR 0 1
59897: PPUSH
59898: CALL_OW 314
59902: NOT
59903: AND
59904: IFFALSE 59830
// PlaySoundXY ( x , y , PlantMine ) ;
59906: LD_VAR 0 2
59910: PPUSH
59911: LD_VAR 0 3
59915: PPUSH
59916: LD_STRING PlantMine
59918: PPUSH
59919: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59923: LD_VAR 0 2
59927: PPUSH
59928: LD_VAR 0 3
59932: PPUSH
59933: LD_VAR 0 1
59937: PPUSH
59938: CALL_OW 255
59942: PPUSH
59943: LD_INT 0
59945: PPUSH
59946: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59950: LD_ADDR_EXP 160
59954: PUSH
59955: LD_EXP 160
59959: PPUSH
59960: LD_VAR 0 5
59964: PUSH
59965: LD_EXP 160
59969: PUSH
59970: LD_VAR 0 5
59974: ARRAY
59975: PUSH
59976: LD_INT 1
59978: PLUS
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PPUSH
59984: LD_VAR 0 2
59988: PUSH
59989: LD_VAR 0 3
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: PPUSH
59998: CALL 66210 0 3
60002: ST_TO_ADDR
// result := true ;
60003: LD_ADDR_VAR 0 4
60007: PUSH
60008: LD_INT 1
60010: ST_TO_ADDR
// end ;
60011: LD_VAR 0 4
60015: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
60016: LD_INT 0
60018: PPUSH
60019: PPUSH
60020: PPUSH
// if not unit in minersList then
60021: LD_VAR 0 1
60025: PUSH
60026: LD_EXP 159
60030: IN
60031: NOT
60032: IFFALSE 60036
// exit ;
60034: GO 60428
// index := GetElementIndex ( minersList , unit ) ;
60036: LD_ADDR_VAR 0 6
60040: PUSH
60041: LD_EXP 159
60045: PPUSH
60046: LD_VAR 0 1
60050: PPUSH
60051: CALL 65995 0 2
60055: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
60056: LD_ADDR_VAR 0 5
60060: PUSH
60061: DOUBLE
60062: LD_EXP 160
60066: PUSH
60067: LD_VAR 0 6
60071: ARRAY
60072: INC
60073: ST_TO_ADDR
60074: LD_INT 1
60076: PUSH
60077: FOR_DOWNTO
60078: IFFALSE 60239
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
60080: LD_EXP 160
60084: PUSH
60085: LD_VAR 0 6
60089: ARRAY
60090: PUSH
60091: LD_VAR 0 5
60095: ARRAY
60096: PUSH
60097: LD_INT 1
60099: ARRAY
60100: PUSH
60101: LD_VAR 0 2
60105: EQUAL
60106: PUSH
60107: LD_EXP 160
60111: PUSH
60112: LD_VAR 0 6
60116: ARRAY
60117: PUSH
60118: LD_VAR 0 5
60122: ARRAY
60123: PUSH
60124: LD_INT 2
60126: ARRAY
60127: PUSH
60128: LD_VAR 0 3
60132: EQUAL
60133: AND
60134: IFFALSE 60237
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
60136: LD_EXP 160
60140: PUSH
60141: LD_VAR 0 6
60145: ARRAY
60146: PUSH
60147: LD_VAR 0 5
60151: ARRAY
60152: PUSH
60153: LD_INT 1
60155: ARRAY
60156: PPUSH
60157: LD_EXP 160
60161: PUSH
60162: LD_VAR 0 6
60166: ARRAY
60167: PUSH
60168: LD_VAR 0 5
60172: ARRAY
60173: PUSH
60174: LD_INT 2
60176: ARRAY
60177: PPUSH
60178: LD_VAR 0 1
60182: PPUSH
60183: CALL_OW 255
60187: PPUSH
60188: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
60192: LD_ADDR_EXP 160
60196: PUSH
60197: LD_EXP 160
60201: PPUSH
60202: LD_VAR 0 6
60206: PPUSH
60207: LD_EXP 160
60211: PUSH
60212: LD_VAR 0 6
60216: ARRAY
60217: PPUSH
60218: LD_VAR 0 5
60222: PPUSH
60223: CALL_OW 3
60227: PPUSH
60228: CALL_OW 1
60232: ST_TO_ADDR
// exit ;
60233: POP
60234: POP
60235: GO 60428
// end ; end ;
60237: GO 60077
60239: POP
60240: POP
// for i := minerMinesList [ index ] downto 1 do
60241: LD_ADDR_VAR 0 5
60245: PUSH
60246: DOUBLE
60247: LD_EXP 160
60251: PUSH
60252: LD_VAR 0 6
60256: ARRAY
60257: INC
60258: ST_TO_ADDR
60259: LD_INT 1
60261: PUSH
60262: FOR_DOWNTO
60263: IFFALSE 60426
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
60265: LD_EXP 160
60269: PUSH
60270: LD_VAR 0 6
60274: ARRAY
60275: PUSH
60276: LD_VAR 0 5
60280: ARRAY
60281: PUSH
60282: LD_INT 1
60284: ARRAY
60285: PPUSH
60286: LD_EXP 160
60290: PUSH
60291: LD_VAR 0 6
60295: ARRAY
60296: PUSH
60297: LD_VAR 0 5
60301: ARRAY
60302: PUSH
60303: LD_INT 2
60305: ARRAY
60306: PPUSH
60307: LD_VAR 0 2
60311: PPUSH
60312: LD_VAR 0 3
60316: PPUSH
60317: CALL_OW 298
60321: PUSH
60322: LD_INT 6
60324: LESS
60325: IFFALSE 60424
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
60327: LD_EXP 160
60331: PUSH
60332: LD_VAR 0 6
60336: ARRAY
60337: PUSH
60338: LD_VAR 0 5
60342: ARRAY
60343: PUSH
60344: LD_INT 1
60346: ARRAY
60347: PPUSH
60348: LD_EXP 160
60352: PUSH
60353: LD_VAR 0 6
60357: ARRAY
60358: PUSH
60359: LD_VAR 0 5
60363: ARRAY
60364: PUSH
60365: LD_INT 2
60367: ARRAY
60368: PPUSH
60369: LD_VAR 0 1
60373: PPUSH
60374: CALL_OW 255
60378: PPUSH
60379: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
60383: LD_ADDR_EXP 160
60387: PUSH
60388: LD_EXP 160
60392: PPUSH
60393: LD_VAR 0 6
60397: PPUSH
60398: LD_EXP 160
60402: PUSH
60403: LD_VAR 0 6
60407: ARRAY
60408: PPUSH
60409: LD_VAR 0 5
60413: PPUSH
60414: CALL_OW 3
60418: PPUSH
60419: CALL_OW 1
60423: ST_TO_ADDR
// end ; end ;
60424: GO 60262
60426: POP
60427: POP
// end ;
60428: LD_VAR 0 4
60432: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
60433: LD_INT 0
60435: PPUSH
60436: PPUSH
60437: PPUSH
60438: PPUSH
60439: PPUSH
60440: PPUSH
60441: PPUSH
60442: PPUSH
60443: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
60444: LD_VAR 0 1
60448: PPUSH
60449: CALL_OW 264
60453: PUSH
60454: LD_EXP 80
60458: EQUAL
60459: NOT
60460: PUSH
60461: LD_VAR 0 1
60465: PUSH
60466: LD_EXP 159
60470: IN
60471: NOT
60472: OR
60473: IFFALSE 60477
// exit ;
60475: GO 60799
// index := GetElementIndex ( minersList , unit ) ;
60477: LD_ADDR_VAR 0 6
60481: PUSH
60482: LD_EXP 159
60486: PPUSH
60487: LD_VAR 0 1
60491: PPUSH
60492: CALL 65995 0 2
60496: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
60497: LD_ADDR_VAR 0 8
60501: PUSH
60502: LD_EXP 161
60506: PUSH
60507: LD_EXP 160
60511: PUSH
60512: LD_VAR 0 6
60516: ARRAY
60517: MINUS
60518: ST_TO_ADDR
// if not minesFreeAmount then
60519: LD_VAR 0 8
60523: NOT
60524: IFFALSE 60528
// exit ;
60526: GO 60799
// tmp := [ ] ;
60528: LD_ADDR_VAR 0 7
60532: PUSH
60533: EMPTY
60534: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
60535: LD_ADDR_VAR 0 5
60539: PUSH
60540: DOUBLE
60541: LD_INT 1
60543: DEC
60544: ST_TO_ADDR
60545: LD_VAR 0 8
60549: PUSH
60550: FOR_TO
60551: IFFALSE 60746
// begin _d := rand ( 0 , 5 ) ;
60553: LD_ADDR_VAR 0 11
60557: PUSH
60558: LD_INT 0
60560: PPUSH
60561: LD_INT 5
60563: PPUSH
60564: CALL_OW 12
60568: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
60569: LD_ADDR_VAR 0 12
60573: PUSH
60574: LD_INT 2
60576: PPUSH
60577: LD_INT 6
60579: PPUSH
60580: CALL_OW 12
60584: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
60585: LD_ADDR_VAR 0 9
60589: PUSH
60590: LD_VAR 0 2
60594: PPUSH
60595: LD_VAR 0 11
60599: PPUSH
60600: LD_VAR 0 12
60604: PPUSH
60605: CALL_OW 272
60609: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
60610: LD_ADDR_VAR 0 10
60614: PUSH
60615: LD_VAR 0 3
60619: PPUSH
60620: LD_VAR 0 11
60624: PPUSH
60625: LD_VAR 0 12
60629: PPUSH
60630: CALL_OW 273
60634: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
60635: LD_VAR 0 9
60639: PPUSH
60640: LD_VAR 0 10
60644: PPUSH
60645: CALL_OW 488
60649: PUSH
60650: LD_VAR 0 9
60654: PUSH
60655: LD_VAR 0 10
60659: PUSH
60660: EMPTY
60661: LIST
60662: LIST
60663: PUSH
60664: LD_VAR 0 7
60668: IN
60669: NOT
60670: AND
60671: PUSH
60672: LD_VAR 0 9
60676: PPUSH
60677: LD_VAR 0 10
60681: PPUSH
60682: CALL_OW 458
60686: NOT
60687: AND
60688: IFFALSE 60730
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
60690: LD_ADDR_VAR 0 7
60694: PUSH
60695: LD_VAR 0 7
60699: PPUSH
60700: LD_VAR 0 7
60704: PUSH
60705: LD_INT 1
60707: PLUS
60708: PPUSH
60709: LD_VAR 0 9
60713: PUSH
60714: LD_VAR 0 10
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PPUSH
60723: CALL_OW 1
60727: ST_TO_ADDR
60728: GO 60744
// i := i - 1 ;
60730: LD_ADDR_VAR 0 5
60734: PUSH
60735: LD_VAR 0 5
60739: PUSH
60740: LD_INT 1
60742: MINUS
60743: ST_TO_ADDR
// end ;
60744: GO 60550
60746: POP
60747: POP
// for i in tmp do
60748: LD_ADDR_VAR 0 5
60752: PUSH
60753: LD_VAR 0 7
60757: PUSH
60758: FOR_IN
60759: IFFALSE 60797
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60761: LD_VAR 0 1
60765: PPUSH
60766: LD_VAR 0 5
60770: PUSH
60771: LD_INT 1
60773: ARRAY
60774: PPUSH
60775: LD_VAR 0 5
60779: PUSH
60780: LD_INT 2
60782: ARRAY
60783: PPUSH
60784: CALL 59739 0 3
60788: NOT
60789: IFFALSE 60795
// exit ;
60791: POP
60792: POP
60793: GO 60799
60795: GO 60758
60797: POP
60798: POP
// end ;
60799: LD_VAR 0 4
60803: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60804: LD_INT 0
60806: PPUSH
60807: PPUSH
60808: PPUSH
60809: PPUSH
60810: PPUSH
60811: PPUSH
60812: PPUSH
// if not GetClass ( unit ) = class_sniper then
60813: LD_VAR 0 1
60817: PPUSH
60818: CALL_OW 257
60822: PUSH
60823: LD_INT 5
60825: EQUAL
60826: NOT
60827: IFFALSE 60831
// exit ;
60829: GO 61219
// dist := 8 ;
60831: LD_ADDR_VAR 0 5
60835: PUSH
60836: LD_INT 8
60838: ST_TO_ADDR
// viewRange := 12 ;
60839: LD_ADDR_VAR 0 7
60843: PUSH
60844: LD_INT 12
60846: ST_TO_ADDR
// side := GetSide ( unit ) ;
60847: LD_ADDR_VAR 0 6
60851: PUSH
60852: LD_VAR 0 1
60856: PPUSH
60857: CALL_OW 255
60861: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60862: LD_INT 61
60864: PPUSH
60865: LD_VAR 0 6
60869: PPUSH
60870: CALL_OW 321
60874: PUSH
60875: LD_INT 2
60877: EQUAL
60878: IFFALSE 60888
// viewRange := 16 ;
60880: LD_ADDR_VAR 0 7
60884: PUSH
60885: LD_INT 16
60887: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60888: LD_VAR 0 1
60892: PPUSH
60893: LD_VAR 0 2
60897: PPUSH
60898: LD_VAR 0 3
60902: PPUSH
60903: CALL_OW 297
60907: PUSH
60908: LD_VAR 0 5
60912: GREATER
60913: IFFALSE 60992
// begin ComMoveXY ( unit , x , y ) ;
60915: LD_VAR 0 1
60919: PPUSH
60920: LD_VAR 0 2
60924: PPUSH
60925: LD_VAR 0 3
60929: PPUSH
60930: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60934: LD_INT 35
60936: PPUSH
60937: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60941: LD_VAR 0 1
60945: PPUSH
60946: LD_VAR 0 2
60950: PPUSH
60951: LD_VAR 0 3
60955: PPUSH
60956: CALL 96767 0 3
60960: NOT
60961: IFFALSE 60965
// exit ;
60963: GO 61219
// until GetDistUnitXY ( unit , x , y ) < dist ;
60965: LD_VAR 0 1
60969: PPUSH
60970: LD_VAR 0 2
60974: PPUSH
60975: LD_VAR 0 3
60979: PPUSH
60980: CALL_OW 297
60984: PUSH
60985: LD_VAR 0 5
60989: LESS
60990: IFFALSE 60934
// end ; ComTurnXY ( unit , x , y ) ;
60992: LD_VAR 0 1
60996: PPUSH
60997: LD_VAR 0 2
61001: PPUSH
61002: LD_VAR 0 3
61006: PPUSH
61007: CALL_OW 118
// wait ( 5 ) ;
61011: LD_INT 5
61013: PPUSH
61014: CALL_OW 67
// _d := GetDir ( unit ) ;
61018: LD_ADDR_VAR 0 10
61022: PUSH
61023: LD_VAR 0 1
61027: PPUSH
61028: CALL_OW 254
61032: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
61033: LD_ADDR_VAR 0 8
61037: PUSH
61038: LD_VAR 0 1
61042: PPUSH
61043: CALL_OW 250
61047: PPUSH
61048: LD_VAR 0 10
61052: PPUSH
61053: LD_VAR 0 5
61057: PPUSH
61058: CALL_OW 272
61062: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
61063: LD_ADDR_VAR 0 9
61067: PUSH
61068: LD_VAR 0 1
61072: PPUSH
61073: CALL_OW 251
61077: PPUSH
61078: LD_VAR 0 10
61082: PPUSH
61083: LD_VAR 0 5
61087: PPUSH
61088: CALL_OW 273
61092: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
61093: LD_VAR 0 8
61097: PPUSH
61098: LD_VAR 0 9
61102: PPUSH
61103: CALL_OW 488
61107: NOT
61108: IFFALSE 61112
// exit ;
61110: GO 61219
// ComAnimCustom ( unit , 1 ) ;
61112: LD_VAR 0 1
61116: PPUSH
61117: LD_INT 1
61119: PPUSH
61120: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
61124: LD_VAR 0 8
61128: PPUSH
61129: LD_VAR 0 9
61133: PPUSH
61134: LD_VAR 0 6
61138: PPUSH
61139: LD_VAR 0 7
61143: PPUSH
61144: CALL_OW 330
// repeat wait ( 1 ) ;
61148: LD_INT 1
61150: PPUSH
61151: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
61155: LD_VAR 0 1
61159: PPUSH
61160: CALL_OW 316
61164: PUSH
61165: LD_VAR 0 1
61169: PPUSH
61170: CALL_OW 314
61174: OR
61175: PUSH
61176: LD_VAR 0 1
61180: PPUSH
61181: CALL_OW 302
61185: NOT
61186: OR
61187: PUSH
61188: LD_VAR 0 1
61192: PPUSH
61193: CALL_OW 301
61197: OR
61198: IFFALSE 61148
// RemoveSeeing ( _x , _y , side ) ;
61200: LD_VAR 0 8
61204: PPUSH
61205: LD_VAR 0 9
61209: PPUSH
61210: LD_VAR 0 6
61214: PPUSH
61215: CALL_OW 331
// end ; end_of_file
61219: LD_VAR 0 4
61223: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
61224: LD_INT 0
61226: PPUSH
61227: PPUSH
// if exist_mode then
61228: LD_VAR 0 2
61232: IFFALSE 61257
// unit := CreateCharacter ( prefix & ident ) else
61234: LD_ADDR_VAR 0 5
61238: PUSH
61239: LD_VAR 0 3
61243: PUSH
61244: LD_VAR 0 1
61248: STR
61249: PPUSH
61250: CALL_OW 34
61254: ST_TO_ADDR
61255: GO 61272
// unit := NewCharacter ( ident ) ;
61257: LD_ADDR_VAR 0 5
61261: PUSH
61262: LD_VAR 0 1
61266: PPUSH
61267: CALL_OW 25
61271: ST_TO_ADDR
// result := unit ;
61272: LD_ADDR_VAR 0 4
61276: PUSH
61277: LD_VAR 0 5
61281: ST_TO_ADDR
// end ;
61282: LD_VAR 0 4
61286: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
61287: LD_INT 0
61289: PPUSH
61290: PPUSH
// if not side or not nation then
61291: LD_VAR 0 1
61295: NOT
61296: PUSH
61297: LD_VAR 0 2
61301: NOT
61302: OR
61303: IFFALSE 61307
// exit ;
61305: GO 62075
// case nation of nation_american :
61307: LD_VAR 0 2
61311: PUSH
61312: LD_INT 1
61314: DOUBLE
61315: EQUAL
61316: IFTRUE 61320
61318: GO 61534
61320: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
61321: LD_ADDR_VAR 0 4
61325: PUSH
61326: LD_INT 35
61328: PUSH
61329: LD_INT 45
61331: PUSH
61332: LD_INT 46
61334: PUSH
61335: LD_INT 47
61337: PUSH
61338: LD_INT 82
61340: PUSH
61341: LD_INT 83
61343: PUSH
61344: LD_INT 84
61346: PUSH
61347: LD_INT 85
61349: PUSH
61350: LD_INT 86
61352: PUSH
61353: LD_INT 1
61355: PUSH
61356: LD_INT 2
61358: PUSH
61359: LD_INT 6
61361: PUSH
61362: LD_INT 15
61364: PUSH
61365: LD_INT 16
61367: PUSH
61368: LD_INT 7
61370: PUSH
61371: LD_INT 12
61373: PUSH
61374: LD_INT 13
61376: PUSH
61377: LD_INT 10
61379: PUSH
61380: LD_INT 14
61382: PUSH
61383: LD_INT 20
61385: PUSH
61386: LD_INT 21
61388: PUSH
61389: LD_INT 22
61391: PUSH
61392: LD_INT 25
61394: PUSH
61395: LD_INT 32
61397: PUSH
61398: LD_INT 27
61400: PUSH
61401: LD_INT 36
61403: PUSH
61404: LD_INT 69
61406: PUSH
61407: LD_INT 39
61409: PUSH
61410: LD_INT 34
61412: PUSH
61413: LD_INT 40
61415: PUSH
61416: LD_INT 48
61418: PUSH
61419: LD_INT 49
61421: PUSH
61422: LD_INT 50
61424: PUSH
61425: LD_INT 51
61427: PUSH
61428: LD_INT 52
61430: PUSH
61431: LD_INT 53
61433: PUSH
61434: LD_INT 54
61436: PUSH
61437: LD_INT 55
61439: PUSH
61440: LD_INT 56
61442: PUSH
61443: LD_INT 57
61445: PUSH
61446: LD_INT 58
61448: PUSH
61449: LD_INT 59
61451: PUSH
61452: LD_INT 60
61454: PUSH
61455: LD_INT 61
61457: PUSH
61458: LD_INT 62
61460: PUSH
61461: LD_INT 80
61463: PUSH
61464: LD_INT 82
61466: PUSH
61467: LD_INT 83
61469: PUSH
61470: LD_INT 84
61472: PUSH
61473: LD_INT 85
61475: PUSH
61476: LD_INT 86
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: LIST
61483: LIST
61484: LIST
61485: LIST
61486: LIST
61487: LIST
61488: LIST
61489: LIST
61490: LIST
61491: LIST
61492: LIST
61493: LIST
61494: LIST
61495: LIST
61496: LIST
61497: LIST
61498: LIST
61499: LIST
61500: LIST
61501: LIST
61502: LIST
61503: LIST
61504: LIST
61505: LIST
61506: LIST
61507: LIST
61508: LIST
61509: LIST
61510: LIST
61511: LIST
61512: LIST
61513: LIST
61514: LIST
61515: LIST
61516: LIST
61517: LIST
61518: LIST
61519: LIST
61520: LIST
61521: LIST
61522: LIST
61523: LIST
61524: LIST
61525: LIST
61526: LIST
61527: LIST
61528: LIST
61529: LIST
61530: LIST
61531: ST_TO_ADDR
61532: GO 61999
61534: LD_INT 2
61536: DOUBLE
61537: EQUAL
61538: IFTRUE 61542
61540: GO 61768
61542: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
61543: LD_ADDR_VAR 0 4
61547: PUSH
61548: LD_INT 35
61550: PUSH
61551: LD_INT 45
61553: PUSH
61554: LD_INT 46
61556: PUSH
61557: LD_INT 47
61559: PUSH
61560: LD_INT 82
61562: PUSH
61563: LD_INT 83
61565: PUSH
61566: LD_INT 84
61568: PUSH
61569: LD_INT 85
61571: PUSH
61572: LD_INT 87
61574: PUSH
61575: LD_INT 70
61577: PUSH
61578: LD_INT 1
61580: PUSH
61581: LD_INT 11
61583: PUSH
61584: LD_INT 3
61586: PUSH
61587: LD_INT 4
61589: PUSH
61590: LD_INT 5
61592: PUSH
61593: LD_INT 6
61595: PUSH
61596: LD_INT 15
61598: PUSH
61599: LD_INT 18
61601: PUSH
61602: LD_INT 7
61604: PUSH
61605: LD_INT 17
61607: PUSH
61608: LD_INT 8
61610: PUSH
61611: LD_INT 20
61613: PUSH
61614: LD_INT 21
61616: PUSH
61617: LD_INT 22
61619: PUSH
61620: LD_INT 72
61622: PUSH
61623: LD_INT 26
61625: PUSH
61626: LD_INT 69
61628: PUSH
61629: LD_INT 39
61631: PUSH
61632: LD_INT 40
61634: PUSH
61635: LD_INT 41
61637: PUSH
61638: LD_INT 42
61640: PUSH
61641: LD_INT 43
61643: PUSH
61644: LD_INT 48
61646: PUSH
61647: LD_INT 49
61649: PUSH
61650: LD_INT 50
61652: PUSH
61653: LD_INT 51
61655: PUSH
61656: LD_INT 52
61658: PUSH
61659: LD_INT 53
61661: PUSH
61662: LD_INT 54
61664: PUSH
61665: LD_INT 55
61667: PUSH
61668: LD_INT 56
61670: PUSH
61671: LD_INT 60
61673: PUSH
61674: LD_INT 61
61676: PUSH
61677: LD_INT 62
61679: PUSH
61680: LD_INT 66
61682: PUSH
61683: LD_INT 67
61685: PUSH
61686: LD_INT 68
61688: PUSH
61689: LD_INT 81
61691: PUSH
61692: LD_INT 82
61694: PUSH
61695: LD_INT 83
61697: PUSH
61698: LD_INT 84
61700: PUSH
61701: LD_INT 85
61703: PUSH
61704: LD_INT 87
61706: PUSH
61707: LD_INT 88
61709: PUSH
61710: EMPTY
61711: LIST
61712: LIST
61713: LIST
61714: LIST
61715: LIST
61716: LIST
61717: LIST
61718: LIST
61719: LIST
61720: LIST
61721: LIST
61722: LIST
61723: LIST
61724: LIST
61725: LIST
61726: LIST
61727: LIST
61728: LIST
61729: LIST
61730: LIST
61731: LIST
61732: LIST
61733: LIST
61734: LIST
61735: LIST
61736: LIST
61737: LIST
61738: LIST
61739: LIST
61740: LIST
61741: LIST
61742: LIST
61743: LIST
61744: LIST
61745: LIST
61746: LIST
61747: LIST
61748: LIST
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: LIST
61758: LIST
61759: LIST
61760: LIST
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: ST_TO_ADDR
61766: GO 61999
61768: LD_INT 3
61770: DOUBLE
61771: EQUAL
61772: IFTRUE 61776
61774: GO 61998
61776: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61777: LD_ADDR_VAR 0 4
61781: PUSH
61782: LD_INT 46
61784: PUSH
61785: LD_INT 47
61787: PUSH
61788: LD_INT 1
61790: PUSH
61791: LD_INT 2
61793: PUSH
61794: LD_INT 82
61796: PUSH
61797: LD_INT 83
61799: PUSH
61800: LD_INT 84
61802: PUSH
61803: LD_INT 85
61805: PUSH
61806: LD_INT 86
61808: PUSH
61809: LD_INT 11
61811: PUSH
61812: LD_INT 9
61814: PUSH
61815: LD_INT 20
61817: PUSH
61818: LD_INT 19
61820: PUSH
61821: LD_INT 21
61823: PUSH
61824: LD_INT 24
61826: PUSH
61827: LD_INT 22
61829: PUSH
61830: LD_INT 25
61832: PUSH
61833: LD_INT 28
61835: PUSH
61836: LD_INT 29
61838: PUSH
61839: LD_INT 30
61841: PUSH
61842: LD_INT 31
61844: PUSH
61845: LD_INT 37
61847: PUSH
61848: LD_INT 38
61850: PUSH
61851: LD_INT 32
61853: PUSH
61854: LD_INT 27
61856: PUSH
61857: LD_INT 33
61859: PUSH
61860: LD_INT 69
61862: PUSH
61863: LD_INT 39
61865: PUSH
61866: LD_INT 34
61868: PUSH
61869: LD_INT 40
61871: PUSH
61872: LD_INT 71
61874: PUSH
61875: LD_INT 23
61877: PUSH
61878: LD_INT 44
61880: PUSH
61881: LD_INT 48
61883: PUSH
61884: LD_INT 49
61886: PUSH
61887: LD_INT 50
61889: PUSH
61890: LD_INT 51
61892: PUSH
61893: LD_INT 52
61895: PUSH
61896: LD_INT 53
61898: PUSH
61899: LD_INT 54
61901: PUSH
61902: LD_INT 55
61904: PUSH
61905: LD_INT 56
61907: PUSH
61908: LD_INT 57
61910: PUSH
61911: LD_INT 58
61913: PUSH
61914: LD_INT 59
61916: PUSH
61917: LD_INT 63
61919: PUSH
61920: LD_INT 64
61922: PUSH
61923: LD_INT 65
61925: PUSH
61926: LD_INT 82
61928: PUSH
61929: LD_INT 83
61931: PUSH
61932: LD_INT 84
61934: PUSH
61935: LD_INT 85
61937: PUSH
61938: LD_INT 86
61940: PUSH
61941: EMPTY
61942: LIST
61943: LIST
61944: LIST
61945: LIST
61946: LIST
61947: LIST
61948: LIST
61949: LIST
61950: LIST
61951: LIST
61952: LIST
61953: LIST
61954: LIST
61955: LIST
61956: LIST
61957: LIST
61958: LIST
61959: LIST
61960: LIST
61961: LIST
61962: LIST
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: LIST
61986: LIST
61987: LIST
61988: LIST
61989: LIST
61990: LIST
61991: LIST
61992: LIST
61993: LIST
61994: LIST
61995: ST_TO_ADDR
61996: GO 61999
61998: POP
// if state > - 1 and state < 3 then
61999: LD_VAR 0 3
62003: PUSH
62004: LD_INT 1
62006: NEG
62007: GREATER
62008: PUSH
62009: LD_VAR 0 3
62013: PUSH
62014: LD_INT 3
62016: LESS
62017: AND
62018: IFFALSE 62075
// for i in result do
62020: LD_ADDR_VAR 0 5
62024: PUSH
62025: LD_VAR 0 4
62029: PUSH
62030: FOR_IN
62031: IFFALSE 62073
// if GetTech ( i , side ) <> state then
62033: LD_VAR 0 5
62037: PPUSH
62038: LD_VAR 0 1
62042: PPUSH
62043: CALL_OW 321
62047: PUSH
62048: LD_VAR 0 3
62052: NONEQUAL
62053: IFFALSE 62071
// result := result diff i ;
62055: LD_ADDR_VAR 0 4
62059: PUSH
62060: LD_VAR 0 4
62064: PUSH
62065: LD_VAR 0 5
62069: DIFF
62070: ST_TO_ADDR
62071: GO 62030
62073: POP
62074: POP
// end ;
62075: LD_VAR 0 4
62079: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
62080: LD_INT 0
62082: PPUSH
62083: PPUSH
62084: PPUSH
// result := true ;
62085: LD_ADDR_VAR 0 3
62089: PUSH
62090: LD_INT 1
62092: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
62093: LD_ADDR_VAR 0 5
62097: PUSH
62098: LD_VAR 0 2
62102: PPUSH
62103: CALL_OW 480
62107: ST_TO_ADDR
// if not tmp then
62108: LD_VAR 0 5
62112: NOT
62113: IFFALSE 62117
// exit ;
62115: GO 62166
// for i in tmp do
62117: LD_ADDR_VAR 0 4
62121: PUSH
62122: LD_VAR 0 5
62126: PUSH
62127: FOR_IN
62128: IFFALSE 62164
// if GetTech ( i , side ) <> state_researched then
62130: LD_VAR 0 4
62134: PPUSH
62135: LD_VAR 0 1
62139: PPUSH
62140: CALL_OW 321
62144: PUSH
62145: LD_INT 2
62147: NONEQUAL
62148: IFFALSE 62162
// begin result := false ;
62150: LD_ADDR_VAR 0 3
62154: PUSH
62155: LD_INT 0
62157: ST_TO_ADDR
// exit ;
62158: POP
62159: POP
62160: GO 62166
// end ;
62162: GO 62127
62164: POP
62165: POP
// end ;
62166: LD_VAR 0 3
62170: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
62171: LD_INT 0
62173: PPUSH
62174: PPUSH
62175: PPUSH
62176: PPUSH
62177: PPUSH
62178: PPUSH
62179: PPUSH
62180: PPUSH
62181: PPUSH
62182: PPUSH
62183: PPUSH
62184: PPUSH
62185: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
62186: LD_VAR 0 1
62190: NOT
62191: PUSH
62192: LD_VAR 0 1
62196: PPUSH
62197: CALL_OW 257
62201: PUSH
62202: LD_INT 9
62204: NONEQUAL
62205: OR
62206: IFFALSE 62210
// exit ;
62208: GO 62783
// side := GetSide ( unit ) ;
62210: LD_ADDR_VAR 0 9
62214: PUSH
62215: LD_VAR 0 1
62219: PPUSH
62220: CALL_OW 255
62224: ST_TO_ADDR
// tech_space := tech_spacanom ;
62225: LD_ADDR_VAR 0 12
62229: PUSH
62230: LD_INT 29
62232: ST_TO_ADDR
// tech_time := tech_taurad ;
62233: LD_ADDR_VAR 0 13
62237: PUSH
62238: LD_INT 28
62240: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
62241: LD_ADDR_VAR 0 11
62245: PUSH
62246: LD_VAR 0 1
62250: PPUSH
62251: CALL_OW 310
62255: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
62256: LD_VAR 0 11
62260: PPUSH
62261: CALL_OW 247
62265: PUSH
62266: LD_INT 2
62268: EQUAL
62269: IFFALSE 62273
// exit ;
62271: GO 62783
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62273: LD_ADDR_VAR 0 8
62277: PUSH
62278: LD_INT 81
62280: PUSH
62281: LD_VAR 0 9
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PUSH
62290: LD_INT 3
62292: PUSH
62293: LD_INT 21
62295: PUSH
62296: LD_INT 3
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PUSH
62303: EMPTY
62304: LIST
62305: LIST
62306: PUSH
62307: EMPTY
62308: LIST
62309: LIST
62310: PPUSH
62311: CALL_OW 69
62315: ST_TO_ADDR
// if not tmp then
62316: LD_VAR 0 8
62320: NOT
62321: IFFALSE 62325
// exit ;
62323: GO 62783
// if in_unit then
62325: LD_VAR 0 11
62329: IFFALSE 62353
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
62331: LD_ADDR_VAR 0 10
62335: PUSH
62336: LD_VAR 0 8
62340: PPUSH
62341: LD_VAR 0 11
62345: PPUSH
62346: CALL_OW 74
62350: ST_TO_ADDR
62351: GO 62373
// enemy := NearestUnitToUnit ( tmp , unit ) ;
62353: LD_ADDR_VAR 0 10
62357: PUSH
62358: LD_VAR 0 8
62362: PPUSH
62363: LD_VAR 0 1
62367: PPUSH
62368: CALL_OW 74
62372: ST_TO_ADDR
// if not enemy then
62373: LD_VAR 0 10
62377: NOT
62378: IFFALSE 62382
// exit ;
62380: GO 62783
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
62382: LD_VAR 0 11
62386: PUSH
62387: LD_VAR 0 11
62391: PPUSH
62392: LD_VAR 0 10
62396: PPUSH
62397: CALL_OW 296
62401: PUSH
62402: LD_INT 13
62404: GREATER
62405: AND
62406: PUSH
62407: LD_VAR 0 1
62411: PPUSH
62412: LD_VAR 0 10
62416: PPUSH
62417: CALL_OW 296
62421: PUSH
62422: LD_INT 12
62424: GREATER
62425: OR
62426: IFFALSE 62430
// exit ;
62428: GO 62783
// missile := [ 1 ] ;
62430: LD_ADDR_VAR 0 14
62434: PUSH
62435: LD_INT 1
62437: PUSH
62438: EMPTY
62439: LIST
62440: ST_TO_ADDR
// if Researched ( side , tech_space ) then
62441: LD_VAR 0 9
62445: PPUSH
62446: LD_VAR 0 12
62450: PPUSH
62451: CALL_OW 325
62455: IFFALSE 62484
// missile := Insert ( missile , missile + 1 , 2 ) ;
62457: LD_ADDR_VAR 0 14
62461: PUSH
62462: LD_VAR 0 14
62466: PPUSH
62467: LD_VAR 0 14
62471: PUSH
62472: LD_INT 1
62474: PLUS
62475: PPUSH
62476: LD_INT 2
62478: PPUSH
62479: CALL_OW 2
62483: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
62484: LD_VAR 0 9
62488: PPUSH
62489: LD_VAR 0 13
62493: PPUSH
62494: CALL_OW 325
62498: PUSH
62499: LD_VAR 0 10
62503: PPUSH
62504: CALL_OW 255
62508: PPUSH
62509: LD_VAR 0 13
62513: PPUSH
62514: CALL_OW 325
62518: NOT
62519: AND
62520: IFFALSE 62549
// missile := Insert ( missile , missile + 1 , 3 ) ;
62522: LD_ADDR_VAR 0 14
62526: PUSH
62527: LD_VAR 0 14
62531: PPUSH
62532: LD_VAR 0 14
62536: PUSH
62537: LD_INT 1
62539: PLUS
62540: PPUSH
62541: LD_INT 3
62543: PPUSH
62544: CALL_OW 2
62548: ST_TO_ADDR
// if missile < 2 then
62549: LD_VAR 0 14
62553: PUSH
62554: LD_INT 2
62556: LESS
62557: IFFALSE 62561
// exit ;
62559: GO 62783
// x := GetX ( enemy ) ;
62561: LD_ADDR_VAR 0 4
62565: PUSH
62566: LD_VAR 0 10
62570: PPUSH
62571: CALL_OW 250
62575: ST_TO_ADDR
// y := GetY ( enemy ) ;
62576: LD_ADDR_VAR 0 5
62580: PUSH
62581: LD_VAR 0 10
62585: PPUSH
62586: CALL_OW 251
62590: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
62591: LD_ADDR_VAR 0 6
62595: PUSH
62596: LD_VAR 0 4
62600: PUSH
62601: LD_INT 1
62603: NEG
62604: PPUSH
62605: LD_INT 1
62607: PPUSH
62608: CALL_OW 12
62612: PLUS
62613: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
62614: LD_ADDR_VAR 0 7
62618: PUSH
62619: LD_VAR 0 5
62623: PUSH
62624: LD_INT 1
62626: NEG
62627: PPUSH
62628: LD_INT 1
62630: PPUSH
62631: CALL_OW 12
62635: PLUS
62636: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62637: LD_VAR 0 6
62641: PPUSH
62642: LD_VAR 0 7
62646: PPUSH
62647: CALL_OW 488
62651: NOT
62652: IFFALSE 62674
// begin _x := x ;
62654: LD_ADDR_VAR 0 6
62658: PUSH
62659: LD_VAR 0 4
62663: ST_TO_ADDR
// _y := y ;
62664: LD_ADDR_VAR 0 7
62668: PUSH
62669: LD_VAR 0 5
62673: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
62674: LD_ADDR_VAR 0 3
62678: PUSH
62679: LD_INT 1
62681: PPUSH
62682: LD_VAR 0 14
62686: PPUSH
62687: CALL_OW 12
62691: ST_TO_ADDR
// case i of 1 :
62692: LD_VAR 0 3
62696: PUSH
62697: LD_INT 1
62699: DOUBLE
62700: EQUAL
62701: IFTRUE 62705
62703: GO 62722
62705: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
62706: LD_VAR 0 1
62710: PPUSH
62711: LD_VAR 0 10
62715: PPUSH
62716: CALL_OW 115
62720: GO 62783
62722: LD_INT 2
62724: DOUBLE
62725: EQUAL
62726: IFTRUE 62730
62728: GO 62752
62730: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62731: LD_VAR 0 1
62735: PPUSH
62736: LD_VAR 0 6
62740: PPUSH
62741: LD_VAR 0 7
62745: PPUSH
62746: CALL_OW 153
62750: GO 62783
62752: LD_INT 3
62754: DOUBLE
62755: EQUAL
62756: IFTRUE 62760
62758: GO 62782
62760: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62761: LD_VAR 0 1
62765: PPUSH
62766: LD_VAR 0 6
62770: PPUSH
62771: LD_VAR 0 7
62775: PPUSH
62776: CALL_OW 154
62780: GO 62783
62782: POP
// end ;
62783: LD_VAR 0 2
62787: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62788: LD_INT 0
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
// if not unit or not building then
62796: LD_VAR 0 1
62800: NOT
62801: PUSH
62802: LD_VAR 0 2
62806: NOT
62807: OR
62808: IFFALSE 62812
// exit ;
62810: GO 62970
// x := GetX ( building ) ;
62812: LD_ADDR_VAR 0 5
62816: PUSH
62817: LD_VAR 0 2
62821: PPUSH
62822: CALL_OW 250
62826: ST_TO_ADDR
// y := GetY ( building ) ;
62827: LD_ADDR_VAR 0 6
62831: PUSH
62832: LD_VAR 0 2
62836: PPUSH
62837: CALL_OW 251
62841: ST_TO_ADDR
// for i = 0 to 5 do
62842: LD_ADDR_VAR 0 4
62846: PUSH
62847: DOUBLE
62848: LD_INT 0
62850: DEC
62851: ST_TO_ADDR
62852: LD_INT 5
62854: PUSH
62855: FOR_TO
62856: IFFALSE 62968
// begin _x := ShiftX ( x , i , 3 ) ;
62858: LD_ADDR_VAR 0 7
62862: PUSH
62863: LD_VAR 0 5
62867: PPUSH
62868: LD_VAR 0 4
62872: PPUSH
62873: LD_INT 3
62875: PPUSH
62876: CALL_OW 272
62880: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62881: LD_ADDR_VAR 0 8
62885: PUSH
62886: LD_VAR 0 6
62890: PPUSH
62891: LD_VAR 0 4
62895: PPUSH
62896: LD_INT 3
62898: PPUSH
62899: CALL_OW 273
62903: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62904: LD_VAR 0 7
62908: PPUSH
62909: LD_VAR 0 8
62913: PPUSH
62914: CALL_OW 488
62918: NOT
62919: IFFALSE 62923
// continue ;
62921: GO 62855
// if HexInfo ( _x , _y ) = 0 then
62923: LD_VAR 0 7
62927: PPUSH
62928: LD_VAR 0 8
62932: PPUSH
62933: CALL_OW 428
62937: PUSH
62938: LD_INT 0
62940: EQUAL
62941: IFFALSE 62966
// begin ComMoveXY ( unit , _x , _y ) ;
62943: LD_VAR 0 1
62947: PPUSH
62948: LD_VAR 0 7
62952: PPUSH
62953: LD_VAR 0 8
62957: PPUSH
62958: CALL_OW 111
// exit ;
62962: POP
62963: POP
62964: GO 62970
// end ; end ;
62966: GO 62855
62968: POP
62969: POP
// end ;
62970: LD_VAR 0 3
62974: RET
// export function ScanBase ( side , base_area ) ; begin
62975: LD_INT 0
62977: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62978: LD_ADDR_VAR 0 3
62982: PUSH
62983: LD_VAR 0 2
62987: PPUSH
62988: LD_INT 81
62990: PUSH
62991: LD_VAR 0 1
62995: PUSH
62996: EMPTY
62997: LIST
62998: LIST
62999: PPUSH
63000: CALL_OW 70
63004: ST_TO_ADDR
// end ;
63005: LD_VAR 0 3
63009: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
63010: LD_INT 0
63012: PPUSH
63013: PPUSH
63014: PPUSH
63015: PPUSH
// result := false ;
63016: LD_ADDR_VAR 0 2
63020: PUSH
63021: LD_INT 0
63023: ST_TO_ADDR
// side := GetSide ( unit ) ;
63024: LD_ADDR_VAR 0 3
63028: PUSH
63029: LD_VAR 0 1
63033: PPUSH
63034: CALL_OW 255
63038: ST_TO_ADDR
// nat := GetNation ( unit ) ;
63039: LD_ADDR_VAR 0 4
63043: PUSH
63044: LD_VAR 0 1
63048: PPUSH
63049: CALL_OW 248
63053: ST_TO_ADDR
// case nat of 1 :
63054: LD_VAR 0 4
63058: PUSH
63059: LD_INT 1
63061: DOUBLE
63062: EQUAL
63063: IFTRUE 63067
63065: GO 63078
63067: POP
// tech := tech_lassight ; 2 :
63068: LD_ADDR_VAR 0 5
63072: PUSH
63073: LD_INT 12
63075: ST_TO_ADDR
63076: GO 63117
63078: LD_INT 2
63080: DOUBLE
63081: EQUAL
63082: IFTRUE 63086
63084: GO 63097
63086: POP
// tech := tech_mortar ; 3 :
63087: LD_ADDR_VAR 0 5
63091: PUSH
63092: LD_INT 41
63094: ST_TO_ADDR
63095: GO 63117
63097: LD_INT 3
63099: DOUBLE
63100: EQUAL
63101: IFTRUE 63105
63103: GO 63116
63105: POP
// tech := tech_bazooka ; end ;
63106: LD_ADDR_VAR 0 5
63110: PUSH
63111: LD_INT 44
63113: ST_TO_ADDR
63114: GO 63117
63116: POP
// if Researched ( side , tech ) then
63117: LD_VAR 0 3
63121: PPUSH
63122: LD_VAR 0 5
63126: PPUSH
63127: CALL_OW 325
63131: IFFALSE 63158
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
63133: LD_ADDR_VAR 0 2
63137: PUSH
63138: LD_INT 5
63140: PUSH
63141: LD_INT 8
63143: PUSH
63144: LD_INT 9
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: LIST
63151: PUSH
63152: LD_VAR 0 4
63156: ARRAY
63157: ST_TO_ADDR
// end ;
63158: LD_VAR 0 2
63162: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
63163: LD_INT 0
63165: PPUSH
63166: PPUSH
63167: PPUSH
// if not mines then
63168: LD_VAR 0 2
63172: NOT
63173: IFFALSE 63177
// exit ;
63175: GO 63321
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63177: LD_ADDR_VAR 0 5
63181: PUSH
63182: LD_INT 81
63184: PUSH
63185: LD_VAR 0 1
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: PUSH
63194: LD_INT 3
63196: PUSH
63197: LD_INT 21
63199: PUSH
63200: LD_INT 3
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PPUSH
63215: CALL_OW 69
63219: ST_TO_ADDR
// for i in mines do
63220: LD_ADDR_VAR 0 4
63224: PUSH
63225: LD_VAR 0 2
63229: PUSH
63230: FOR_IN
63231: IFFALSE 63319
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
63233: LD_VAR 0 4
63237: PUSH
63238: LD_INT 1
63240: ARRAY
63241: PPUSH
63242: LD_VAR 0 4
63246: PUSH
63247: LD_INT 2
63249: ARRAY
63250: PPUSH
63251: CALL_OW 458
63255: NOT
63256: IFFALSE 63260
// continue ;
63258: GO 63230
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
63260: LD_VAR 0 4
63264: PUSH
63265: LD_INT 1
63267: ARRAY
63268: PPUSH
63269: LD_VAR 0 4
63273: PUSH
63274: LD_INT 2
63276: ARRAY
63277: PPUSH
63278: CALL_OW 428
63282: PUSH
63283: LD_VAR 0 5
63287: IN
63288: IFFALSE 63317
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
63290: LD_VAR 0 4
63294: PUSH
63295: LD_INT 1
63297: ARRAY
63298: PPUSH
63299: LD_VAR 0 4
63303: PUSH
63304: LD_INT 2
63306: ARRAY
63307: PPUSH
63308: LD_VAR 0 1
63312: PPUSH
63313: CALL_OW 456
// end ;
63317: GO 63230
63319: POP
63320: POP
// end ;
63321: LD_VAR 0 3
63325: RET
// export function Count ( array ) ; var i ; begin
63326: LD_INT 0
63328: PPUSH
63329: PPUSH
// result := 0 ;
63330: LD_ADDR_VAR 0 2
63334: PUSH
63335: LD_INT 0
63337: ST_TO_ADDR
// for i in array do
63338: LD_ADDR_VAR 0 3
63342: PUSH
63343: LD_VAR 0 1
63347: PUSH
63348: FOR_IN
63349: IFFALSE 63373
// if i then
63351: LD_VAR 0 3
63355: IFFALSE 63371
// result := result + 1 ;
63357: LD_ADDR_VAR 0 2
63361: PUSH
63362: LD_VAR 0 2
63366: PUSH
63367: LD_INT 1
63369: PLUS
63370: ST_TO_ADDR
63371: GO 63348
63373: POP
63374: POP
// end ;
63375: LD_VAR 0 2
63379: RET
// export function IsEmpty ( building ) ; begin
63380: LD_INT 0
63382: PPUSH
// if not building then
63383: LD_VAR 0 1
63387: NOT
63388: IFFALSE 63392
// exit ;
63390: GO 63435
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
63392: LD_ADDR_VAR 0 2
63396: PUSH
63397: LD_VAR 0 1
63401: PUSH
63402: LD_INT 22
63404: PUSH
63405: LD_VAR 0 1
63409: PPUSH
63410: CALL_OW 255
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 58
63421: PUSH
63422: EMPTY
63423: LIST
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: PPUSH
63429: CALL_OW 69
63433: IN
63434: ST_TO_ADDR
// end ;
63435: LD_VAR 0 2
63439: RET
// export function IsNotFull ( building ) ; begin
63440: LD_INT 0
63442: PPUSH
// if not building then
63443: LD_VAR 0 1
63447: NOT
63448: IFFALSE 63452
// exit ;
63450: GO 63471
// result := UnitsInside ( building ) < 6 ;
63452: LD_ADDR_VAR 0 2
63456: PUSH
63457: LD_VAR 0 1
63461: PPUSH
63462: CALL_OW 313
63466: PUSH
63467: LD_INT 6
63469: LESS
63470: ST_TO_ADDR
// end ;
63471: LD_VAR 0 2
63475: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
63476: LD_INT 0
63478: PPUSH
63479: PPUSH
63480: PPUSH
63481: PPUSH
// tmp := [ ] ;
63482: LD_ADDR_VAR 0 3
63486: PUSH
63487: EMPTY
63488: ST_TO_ADDR
// list := [ ] ;
63489: LD_ADDR_VAR 0 5
63493: PUSH
63494: EMPTY
63495: ST_TO_ADDR
// for i = 16 to 25 do
63496: LD_ADDR_VAR 0 4
63500: PUSH
63501: DOUBLE
63502: LD_INT 16
63504: DEC
63505: ST_TO_ADDR
63506: LD_INT 25
63508: PUSH
63509: FOR_TO
63510: IFFALSE 63583
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
63512: LD_ADDR_VAR 0 3
63516: PUSH
63517: LD_VAR 0 3
63521: PUSH
63522: LD_INT 22
63524: PUSH
63525: LD_VAR 0 1
63529: PPUSH
63530: CALL_OW 255
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: PUSH
63539: LD_INT 91
63541: PUSH
63542: LD_VAR 0 1
63546: PUSH
63547: LD_INT 6
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 30
63557: PUSH
63558: LD_VAR 0 4
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: EMPTY
63568: LIST
63569: LIST
63570: LIST
63571: PUSH
63572: EMPTY
63573: LIST
63574: PPUSH
63575: CALL_OW 69
63579: ADD
63580: ST_TO_ADDR
63581: GO 63509
63583: POP
63584: POP
// for i = 1 to tmp do
63585: LD_ADDR_VAR 0 4
63589: PUSH
63590: DOUBLE
63591: LD_INT 1
63593: DEC
63594: ST_TO_ADDR
63595: LD_VAR 0 3
63599: PUSH
63600: FOR_TO
63601: IFFALSE 63689
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
63603: LD_ADDR_VAR 0 5
63607: PUSH
63608: LD_VAR 0 5
63612: PUSH
63613: LD_VAR 0 3
63617: PUSH
63618: LD_VAR 0 4
63622: ARRAY
63623: PPUSH
63624: CALL_OW 266
63628: PUSH
63629: LD_VAR 0 3
63633: PUSH
63634: LD_VAR 0 4
63638: ARRAY
63639: PPUSH
63640: CALL_OW 250
63644: PUSH
63645: LD_VAR 0 3
63649: PUSH
63650: LD_VAR 0 4
63654: ARRAY
63655: PPUSH
63656: CALL_OW 251
63660: PUSH
63661: LD_VAR 0 3
63665: PUSH
63666: LD_VAR 0 4
63670: ARRAY
63671: PPUSH
63672: CALL_OW 254
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: PUSH
63683: EMPTY
63684: LIST
63685: ADD
63686: ST_TO_ADDR
63687: GO 63600
63689: POP
63690: POP
// result := list ;
63691: LD_ADDR_VAR 0 2
63695: PUSH
63696: LD_VAR 0 5
63700: ST_TO_ADDR
// end ;
63701: LD_VAR 0 2
63705: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
63706: LD_INT 0
63708: PPUSH
63709: PPUSH
63710: PPUSH
63711: PPUSH
63712: PPUSH
63713: PPUSH
63714: PPUSH
// if not factory then
63715: LD_VAR 0 1
63719: NOT
63720: IFFALSE 63724
// exit ;
63722: GO 64317
// if control = control_apeman then
63724: LD_VAR 0 4
63728: PUSH
63729: LD_INT 5
63731: EQUAL
63732: IFFALSE 63841
// begin tmp := UnitsInside ( factory ) ;
63734: LD_ADDR_VAR 0 8
63738: PUSH
63739: LD_VAR 0 1
63743: PPUSH
63744: CALL_OW 313
63748: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63749: LD_VAR 0 8
63753: PPUSH
63754: LD_INT 25
63756: PUSH
63757: LD_INT 12
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: PPUSH
63764: CALL_OW 72
63768: NOT
63769: IFFALSE 63779
// control := control_manual ;
63771: LD_ADDR_VAR 0 4
63775: PUSH
63776: LD_INT 1
63778: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63779: LD_ADDR_VAR 0 8
63783: PUSH
63784: LD_VAR 0 1
63788: PPUSH
63789: CALL 63476 0 1
63793: ST_TO_ADDR
// if tmp then
63794: LD_VAR 0 8
63798: IFFALSE 63841
// begin for i in tmp do
63800: LD_ADDR_VAR 0 7
63804: PUSH
63805: LD_VAR 0 8
63809: PUSH
63810: FOR_IN
63811: IFFALSE 63839
// if i [ 1 ] = b_ext_radio then
63813: LD_VAR 0 7
63817: PUSH
63818: LD_INT 1
63820: ARRAY
63821: PUSH
63822: LD_INT 22
63824: EQUAL
63825: IFFALSE 63837
// begin control := control_remote ;
63827: LD_ADDR_VAR 0 4
63831: PUSH
63832: LD_INT 2
63834: ST_TO_ADDR
// break ;
63835: GO 63839
// end ;
63837: GO 63810
63839: POP
63840: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63841: LD_VAR 0 1
63845: PPUSH
63846: LD_VAR 0 2
63850: PPUSH
63851: LD_VAR 0 3
63855: PPUSH
63856: LD_VAR 0 4
63860: PPUSH
63861: LD_VAR 0 5
63865: PPUSH
63866: CALL_OW 448
63870: IFFALSE 63905
// begin result := [ chassis , engine , control , weapon ] ;
63872: LD_ADDR_VAR 0 6
63876: PUSH
63877: LD_VAR 0 2
63881: PUSH
63882: LD_VAR 0 3
63886: PUSH
63887: LD_VAR 0 4
63891: PUSH
63892: LD_VAR 0 5
63896: PUSH
63897: EMPTY
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: ST_TO_ADDR
// exit ;
63903: GO 64317
// end ; _chassis := AvailableChassisList ( factory ) ;
63905: LD_ADDR_VAR 0 9
63909: PUSH
63910: LD_VAR 0 1
63914: PPUSH
63915: CALL_OW 475
63919: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63920: LD_ADDR_VAR 0 11
63924: PUSH
63925: LD_VAR 0 1
63929: PPUSH
63930: CALL_OW 476
63934: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63935: LD_ADDR_VAR 0 12
63939: PUSH
63940: LD_VAR 0 1
63944: PPUSH
63945: CALL_OW 477
63949: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63950: LD_ADDR_VAR 0 10
63954: PUSH
63955: LD_VAR 0 1
63959: PPUSH
63960: CALL_OW 478
63964: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63965: LD_VAR 0 9
63969: NOT
63970: PUSH
63971: LD_VAR 0 11
63975: NOT
63976: OR
63977: PUSH
63978: LD_VAR 0 12
63982: NOT
63983: OR
63984: PUSH
63985: LD_VAR 0 10
63989: NOT
63990: OR
63991: IFFALSE 64026
// begin result := [ chassis , engine , control , weapon ] ;
63993: LD_ADDR_VAR 0 6
63997: PUSH
63998: LD_VAR 0 2
64002: PUSH
64003: LD_VAR 0 3
64007: PUSH
64008: LD_VAR 0 4
64012: PUSH
64013: LD_VAR 0 5
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: LIST
64022: LIST
64023: ST_TO_ADDR
// exit ;
64024: GO 64317
// end ; if not chassis in _chassis then
64026: LD_VAR 0 2
64030: PUSH
64031: LD_VAR 0 9
64035: IN
64036: NOT
64037: IFFALSE 64063
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
64039: LD_ADDR_VAR 0 2
64043: PUSH
64044: LD_VAR 0 9
64048: PUSH
64049: LD_INT 1
64051: PPUSH
64052: LD_VAR 0 9
64056: PPUSH
64057: CALL_OW 12
64061: ARRAY
64062: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
64063: LD_VAR 0 2
64067: PPUSH
64068: LD_VAR 0 3
64072: PPUSH
64073: CALL 64322 0 2
64077: NOT
64078: IFFALSE 64137
// repeat engine := _engine [ 1 ] ;
64080: LD_ADDR_VAR 0 3
64084: PUSH
64085: LD_VAR 0 11
64089: PUSH
64090: LD_INT 1
64092: ARRAY
64093: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
64094: LD_ADDR_VAR 0 11
64098: PUSH
64099: LD_VAR 0 11
64103: PPUSH
64104: LD_INT 1
64106: PPUSH
64107: CALL_OW 3
64111: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
64112: LD_VAR 0 2
64116: PPUSH
64117: LD_VAR 0 3
64121: PPUSH
64122: CALL 64322 0 2
64126: PUSH
64127: LD_VAR 0 11
64131: PUSH
64132: EMPTY
64133: EQUAL
64134: OR
64135: IFFALSE 64080
// if not control in _control then
64137: LD_VAR 0 4
64141: PUSH
64142: LD_VAR 0 12
64146: IN
64147: NOT
64148: IFFALSE 64174
// control := _control [ rand ( 1 , _control ) ] ;
64150: LD_ADDR_VAR 0 4
64154: PUSH
64155: LD_VAR 0 12
64159: PUSH
64160: LD_INT 1
64162: PPUSH
64163: LD_VAR 0 12
64167: PPUSH
64168: CALL_OW 12
64172: ARRAY
64173: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
64174: LD_VAR 0 2
64178: PPUSH
64179: LD_VAR 0 5
64183: PPUSH
64184: CALL 64542 0 2
64188: NOT
64189: IFFALSE 64248
// repeat weapon := _weapon [ 1 ] ;
64191: LD_ADDR_VAR 0 5
64195: PUSH
64196: LD_VAR 0 10
64200: PUSH
64201: LD_INT 1
64203: ARRAY
64204: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
64205: LD_ADDR_VAR 0 10
64209: PUSH
64210: LD_VAR 0 10
64214: PPUSH
64215: LD_INT 1
64217: PPUSH
64218: CALL_OW 3
64222: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
64223: LD_VAR 0 2
64227: PPUSH
64228: LD_VAR 0 5
64232: PPUSH
64233: CALL 64542 0 2
64237: PUSH
64238: LD_VAR 0 10
64242: PUSH
64243: EMPTY
64244: EQUAL
64245: OR
64246: IFFALSE 64191
// result := [ ] ;
64248: LD_ADDR_VAR 0 6
64252: PUSH
64253: EMPTY
64254: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
64255: LD_VAR 0 1
64259: PPUSH
64260: LD_VAR 0 2
64264: PPUSH
64265: LD_VAR 0 3
64269: PPUSH
64270: LD_VAR 0 4
64274: PPUSH
64275: LD_VAR 0 5
64279: PPUSH
64280: CALL_OW 448
64284: IFFALSE 64317
// result := [ chassis , engine , control , weapon ] ;
64286: LD_ADDR_VAR 0 6
64290: PUSH
64291: LD_VAR 0 2
64295: PUSH
64296: LD_VAR 0 3
64300: PUSH
64301: LD_VAR 0 4
64305: PUSH
64306: LD_VAR 0 5
64310: PUSH
64311: EMPTY
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: ST_TO_ADDR
// end ;
64317: LD_VAR 0 6
64321: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
64322: LD_INT 0
64324: PPUSH
// if not chassis or not engine then
64325: LD_VAR 0 1
64329: NOT
64330: PUSH
64331: LD_VAR 0 2
64335: NOT
64336: OR
64337: IFFALSE 64341
// exit ;
64339: GO 64537
// case engine of engine_solar :
64341: LD_VAR 0 2
64345: PUSH
64346: LD_INT 2
64348: DOUBLE
64349: EQUAL
64350: IFTRUE 64354
64352: GO 64392
64354: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
64355: LD_ADDR_VAR 0 3
64359: PUSH
64360: LD_INT 11
64362: PUSH
64363: LD_INT 12
64365: PUSH
64366: LD_INT 13
64368: PUSH
64369: LD_INT 14
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: LD_INT 2
64377: PUSH
64378: LD_INT 3
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: LIST
64385: LIST
64386: LIST
64387: LIST
64388: LIST
64389: ST_TO_ADDR
64390: GO 64521
64392: LD_INT 1
64394: DOUBLE
64395: EQUAL
64396: IFTRUE 64400
64398: GO 64462
64400: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
64401: LD_ADDR_VAR 0 3
64405: PUSH
64406: LD_INT 11
64408: PUSH
64409: LD_INT 12
64411: PUSH
64412: LD_INT 13
64414: PUSH
64415: LD_INT 14
64417: PUSH
64418: LD_INT 1
64420: PUSH
64421: LD_INT 2
64423: PUSH
64424: LD_INT 3
64426: PUSH
64427: LD_INT 4
64429: PUSH
64430: LD_INT 5
64432: PUSH
64433: LD_INT 21
64435: PUSH
64436: LD_INT 23
64438: PUSH
64439: LD_INT 22
64441: PUSH
64442: LD_INT 24
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: ST_TO_ADDR
64460: GO 64521
64462: LD_INT 3
64464: DOUBLE
64465: EQUAL
64466: IFTRUE 64470
64468: GO 64520
64470: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64471: LD_ADDR_VAR 0 3
64475: PUSH
64476: LD_INT 13
64478: PUSH
64479: LD_INT 14
64481: PUSH
64482: LD_INT 2
64484: PUSH
64485: LD_INT 3
64487: PUSH
64488: LD_INT 4
64490: PUSH
64491: LD_INT 5
64493: PUSH
64494: LD_INT 21
64496: PUSH
64497: LD_INT 22
64499: PUSH
64500: LD_INT 23
64502: PUSH
64503: LD_INT 24
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: ST_TO_ADDR
64518: GO 64521
64520: POP
// result := ( chassis in result ) ;
64521: LD_ADDR_VAR 0 3
64525: PUSH
64526: LD_VAR 0 1
64530: PUSH
64531: LD_VAR 0 3
64535: IN
64536: ST_TO_ADDR
// end ;
64537: LD_VAR 0 3
64541: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
64542: LD_INT 0
64544: PPUSH
// if not chassis or not weapon then
64545: LD_VAR 0 1
64549: NOT
64550: PUSH
64551: LD_VAR 0 2
64555: NOT
64556: OR
64557: IFFALSE 64561
// exit ;
64559: GO 65623
// case weapon of us_machine_gun :
64561: LD_VAR 0 2
64565: PUSH
64566: LD_INT 2
64568: DOUBLE
64569: EQUAL
64570: IFTRUE 64574
64572: GO 64604
64574: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
64575: LD_ADDR_VAR 0 3
64579: PUSH
64580: LD_INT 1
64582: PUSH
64583: LD_INT 2
64585: PUSH
64586: LD_INT 3
64588: PUSH
64589: LD_INT 4
64591: PUSH
64592: LD_INT 5
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: ST_TO_ADDR
64602: GO 65607
64604: LD_INT 3
64606: DOUBLE
64607: EQUAL
64608: IFTRUE 64612
64610: GO 64642
64612: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
64613: LD_ADDR_VAR 0 3
64617: PUSH
64618: LD_INT 1
64620: PUSH
64621: LD_INT 2
64623: PUSH
64624: LD_INT 3
64626: PUSH
64627: LD_INT 4
64629: PUSH
64630: LD_INT 5
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: LIST
64637: LIST
64638: LIST
64639: ST_TO_ADDR
64640: GO 65607
64642: LD_INT 11
64644: DOUBLE
64645: EQUAL
64646: IFTRUE 64650
64648: GO 64680
64650: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
64651: LD_ADDR_VAR 0 3
64655: PUSH
64656: LD_INT 1
64658: PUSH
64659: LD_INT 2
64661: PUSH
64662: LD_INT 3
64664: PUSH
64665: LD_INT 4
64667: PUSH
64668: LD_INT 5
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: ST_TO_ADDR
64678: GO 65607
64680: LD_INT 4
64682: DOUBLE
64683: EQUAL
64684: IFTRUE 64688
64686: GO 64714
64688: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
64689: LD_ADDR_VAR 0 3
64693: PUSH
64694: LD_INT 2
64696: PUSH
64697: LD_INT 3
64699: PUSH
64700: LD_INT 4
64702: PUSH
64703: LD_INT 5
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: ST_TO_ADDR
64712: GO 65607
64714: LD_INT 5
64716: DOUBLE
64717: EQUAL
64718: IFTRUE 64722
64720: GO 64748
64722: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
64723: LD_ADDR_VAR 0 3
64727: PUSH
64728: LD_INT 2
64730: PUSH
64731: LD_INT 3
64733: PUSH
64734: LD_INT 4
64736: PUSH
64737: LD_INT 5
64739: PUSH
64740: EMPTY
64741: LIST
64742: LIST
64743: LIST
64744: LIST
64745: ST_TO_ADDR
64746: GO 65607
64748: LD_INT 9
64750: DOUBLE
64751: EQUAL
64752: IFTRUE 64756
64754: GO 64782
64756: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64757: LD_ADDR_VAR 0 3
64761: PUSH
64762: LD_INT 2
64764: PUSH
64765: LD_INT 3
64767: PUSH
64768: LD_INT 4
64770: PUSH
64771: LD_INT 5
64773: PUSH
64774: EMPTY
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: ST_TO_ADDR
64780: GO 65607
64782: LD_INT 7
64784: DOUBLE
64785: EQUAL
64786: IFTRUE 64790
64788: GO 64816
64790: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64791: LD_ADDR_VAR 0 3
64795: PUSH
64796: LD_INT 2
64798: PUSH
64799: LD_INT 3
64801: PUSH
64802: LD_INT 4
64804: PUSH
64805: LD_INT 5
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: LIST
64812: LIST
64813: ST_TO_ADDR
64814: GO 65607
64816: LD_INT 12
64818: DOUBLE
64819: EQUAL
64820: IFTRUE 64824
64822: GO 64850
64824: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64825: LD_ADDR_VAR 0 3
64829: PUSH
64830: LD_INT 2
64832: PUSH
64833: LD_INT 3
64835: PUSH
64836: LD_INT 4
64838: PUSH
64839: LD_INT 5
64841: PUSH
64842: EMPTY
64843: LIST
64844: LIST
64845: LIST
64846: LIST
64847: ST_TO_ADDR
64848: GO 65607
64850: LD_INT 13
64852: DOUBLE
64853: EQUAL
64854: IFTRUE 64858
64856: GO 64884
64858: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64859: LD_ADDR_VAR 0 3
64863: PUSH
64864: LD_INT 2
64866: PUSH
64867: LD_INT 3
64869: PUSH
64870: LD_INT 4
64872: PUSH
64873: LD_INT 5
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: LIST
64880: LIST
64881: ST_TO_ADDR
64882: GO 65607
64884: LD_INT 14
64886: DOUBLE
64887: EQUAL
64888: IFTRUE 64892
64890: GO 64910
64892: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64893: LD_ADDR_VAR 0 3
64897: PUSH
64898: LD_INT 4
64900: PUSH
64901: LD_INT 5
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: ST_TO_ADDR
64908: GO 65607
64910: LD_INT 6
64912: DOUBLE
64913: EQUAL
64914: IFTRUE 64918
64916: GO 64936
64918: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64919: LD_ADDR_VAR 0 3
64923: PUSH
64924: LD_INT 4
64926: PUSH
64927: LD_INT 5
64929: PUSH
64930: EMPTY
64931: LIST
64932: LIST
64933: ST_TO_ADDR
64934: GO 65607
64936: LD_INT 10
64938: DOUBLE
64939: EQUAL
64940: IFTRUE 64944
64942: GO 64962
64944: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64945: LD_ADDR_VAR 0 3
64949: PUSH
64950: LD_INT 4
64952: PUSH
64953: LD_INT 5
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: ST_TO_ADDR
64960: GO 65607
64962: LD_INT 22
64964: DOUBLE
64965: EQUAL
64966: IFTRUE 64970
64968: GO 64996
64970: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64971: LD_ADDR_VAR 0 3
64975: PUSH
64976: LD_INT 11
64978: PUSH
64979: LD_INT 12
64981: PUSH
64982: LD_INT 13
64984: PUSH
64985: LD_INT 14
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: ST_TO_ADDR
64994: GO 65607
64996: LD_INT 23
64998: DOUBLE
64999: EQUAL
65000: IFTRUE 65004
65002: GO 65030
65004: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
65005: LD_ADDR_VAR 0 3
65009: PUSH
65010: LD_INT 11
65012: PUSH
65013: LD_INT 12
65015: PUSH
65016: LD_INT 13
65018: PUSH
65019: LD_INT 14
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: ST_TO_ADDR
65028: GO 65607
65030: LD_INT 24
65032: DOUBLE
65033: EQUAL
65034: IFTRUE 65038
65036: GO 65064
65038: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
65039: LD_ADDR_VAR 0 3
65043: PUSH
65044: LD_INT 11
65046: PUSH
65047: LD_INT 12
65049: PUSH
65050: LD_INT 13
65052: PUSH
65053: LD_INT 14
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: LIST
65060: LIST
65061: ST_TO_ADDR
65062: GO 65607
65064: LD_INT 30
65066: DOUBLE
65067: EQUAL
65068: IFTRUE 65072
65070: GO 65098
65072: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
65073: LD_ADDR_VAR 0 3
65077: PUSH
65078: LD_INT 11
65080: PUSH
65081: LD_INT 12
65083: PUSH
65084: LD_INT 13
65086: PUSH
65087: LD_INT 14
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: LIST
65094: LIST
65095: ST_TO_ADDR
65096: GO 65607
65098: LD_INT 25
65100: DOUBLE
65101: EQUAL
65102: IFTRUE 65106
65104: GO 65124
65106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
65107: LD_ADDR_VAR 0 3
65111: PUSH
65112: LD_INT 13
65114: PUSH
65115: LD_INT 14
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: ST_TO_ADDR
65122: GO 65607
65124: LD_INT 27
65126: DOUBLE
65127: EQUAL
65128: IFTRUE 65132
65130: GO 65150
65132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
65133: LD_ADDR_VAR 0 3
65137: PUSH
65138: LD_INT 13
65140: PUSH
65141: LD_INT 14
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: ST_TO_ADDR
65148: GO 65607
65150: LD_EXP 78
65154: DOUBLE
65155: EQUAL
65156: IFTRUE 65160
65158: GO 65186
65160: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
65161: LD_ADDR_VAR 0 3
65165: PUSH
65166: LD_INT 11
65168: PUSH
65169: LD_INT 12
65171: PUSH
65172: LD_INT 13
65174: PUSH
65175: LD_INT 14
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: LIST
65182: LIST
65183: ST_TO_ADDR
65184: GO 65607
65186: LD_INT 28
65188: DOUBLE
65189: EQUAL
65190: IFTRUE 65194
65192: GO 65212
65194: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
65195: LD_ADDR_VAR 0 3
65199: PUSH
65200: LD_INT 13
65202: PUSH
65203: LD_INT 14
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: ST_TO_ADDR
65210: GO 65607
65212: LD_INT 29
65214: DOUBLE
65215: EQUAL
65216: IFTRUE 65220
65218: GO 65238
65220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
65221: LD_ADDR_VAR 0 3
65225: PUSH
65226: LD_INT 13
65228: PUSH
65229: LD_INT 14
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: ST_TO_ADDR
65236: GO 65607
65238: LD_INT 31
65240: DOUBLE
65241: EQUAL
65242: IFTRUE 65246
65244: GO 65264
65246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
65247: LD_ADDR_VAR 0 3
65251: PUSH
65252: LD_INT 13
65254: PUSH
65255: LD_INT 14
65257: PUSH
65258: EMPTY
65259: LIST
65260: LIST
65261: ST_TO_ADDR
65262: GO 65607
65264: LD_INT 26
65266: DOUBLE
65267: EQUAL
65268: IFTRUE 65272
65270: GO 65290
65272: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
65273: LD_ADDR_VAR 0 3
65277: PUSH
65278: LD_INT 13
65280: PUSH
65281: LD_INT 14
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: ST_TO_ADDR
65288: GO 65607
65290: LD_INT 42
65292: DOUBLE
65293: EQUAL
65294: IFTRUE 65298
65296: GO 65324
65298: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
65299: LD_ADDR_VAR 0 3
65303: PUSH
65304: LD_INT 21
65306: PUSH
65307: LD_INT 22
65309: PUSH
65310: LD_INT 23
65312: PUSH
65313: LD_INT 24
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: ST_TO_ADDR
65322: GO 65607
65324: LD_INT 43
65326: DOUBLE
65327: EQUAL
65328: IFTRUE 65332
65330: GO 65358
65332: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
65333: LD_ADDR_VAR 0 3
65337: PUSH
65338: LD_INT 21
65340: PUSH
65341: LD_INT 22
65343: PUSH
65344: LD_INT 23
65346: PUSH
65347: LD_INT 24
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: ST_TO_ADDR
65356: GO 65607
65358: LD_INT 44
65360: DOUBLE
65361: EQUAL
65362: IFTRUE 65366
65364: GO 65392
65366: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
65367: LD_ADDR_VAR 0 3
65371: PUSH
65372: LD_INT 21
65374: PUSH
65375: LD_INT 22
65377: PUSH
65378: LD_INT 23
65380: PUSH
65381: LD_INT 24
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: ST_TO_ADDR
65390: GO 65607
65392: LD_INT 45
65394: DOUBLE
65395: EQUAL
65396: IFTRUE 65400
65398: GO 65426
65400: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
65401: LD_ADDR_VAR 0 3
65405: PUSH
65406: LD_INT 21
65408: PUSH
65409: LD_INT 22
65411: PUSH
65412: LD_INT 23
65414: PUSH
65415: LD_INT 24
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: ST_TO_ADDR
65424: GO 65607
65426: LD_INT 49
65428: DOUBLE
65429: EQUAL
65430: IFTRUE 65434
65432: GO 65460
65434: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
65435: LD_ADDR_VAR 0 3
65439: PUSH
65440: LD_INT 21
65442: PUSH
65443: LD_INT 22
65445: PUSH
65446: LD_INT 23
65448: PUSH
65449: LD_INT 24
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: ST_TO_ADDR
65458: GO 65607
65460: LD_INT 51
65462: DOUBLE
65463: EQUAL
65464: IFTRUE 65468
65466: GO 65494
65468: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
65469: LD_ADDR_VAR 0 3
65473: PUSH
65474: LD_INT 21
65476: PUSH
65477: LD_INT 22
65479: PUSH
65480: LD_INT 23
65482: PUSH
65483: LD_INT 24
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: ST_TO_ADDR
65492: GO 65607
65494: LD_INT 52
65496: DOUBLE
65497: EQUAL
65498: IFTRUE 65502
65500: GO 65528
65502: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
65503: LD_ADDR_VAR 0 3
65507: PUSH
65508: LD_INT 21
65510: PUSH
65511: LD_INT 22
65513: PUSH
65514: LD_INT 23
65516: PUSH
65517: LD_INT 24
65519: PUSH
65520: EMPTY
65521: LIST
65522: LIST
65523: LIST
65524: LIST
65525: ST_TO_ADDR
65526: GO 65607
65528: LD_INT 53
65530: DOUBLE
65531: EQUAL
65532: IFTRUE 65536
65534: GO 65554
65536: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
65537: LD_ADDR_VAR 0 3
65541: PUSH
65542: LD_INT 23
65544: PUSH
65545: LD_INT 24
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: ST_TO_ADDR
65552: GO 65607
65554: LD_INT 46
65556: DOUBLE
65557: EQUAL
65558: IFTRUE 65562
65560: GO 65580
65562: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
65563: LD_ADDR_VAR 0 3
65567: PUSH
65568: LD_INT 23
65570: PUSH
65571: LD_INT 24
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: ST_TO_ADDR
65578: GO 65607
65580: LD_INT 47
65582: DOUBLE
65583: EQUAL
65584: IFTRUE 65588
65586: GO 65606
65588: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
65589: LD_ADDR_VAR 0 3
65593: PUSH
65594: LD_INT 23
65596: PUSH
65597: LD_INT 24
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: ST_TO_ADDR
65604: GO 65607
65606: POP
// result := ( chassis in result ) ;
65607: LD_ADDR_VAR 0 3
65611: PUSH
65612: LD_VAR 0 1
65616: PUSH
65617: LD_VAR 0 3
65621: IN
65622: ST_TO_ADDR
// end ;
65623: LD_VAR 0 3
65627: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
65628: LD_INT 0
65630: PPUSH
65631: PPUSH
65632: PPUSH
65633: PPUSH
65634: PPUSH
65635: PPUSH
65636: PPUSH
// result := array ;
65637: LD_ADDR_VAR 0 5
65641: PUSH
65642: LD_VAR 0 1
65646: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
65647: LD_VAR 0 1
65651: NOT
65652: PUSH
65653: LD_VAR 0 2
65657: NOT
65658: OR
65659: PUSH
65660: LD_VAR 0 3
65664: NOT
65665: OR
65666: PUSH
65667: LD_VAR 0 2
65671: PUSH
65672: LD_VAR 0 1
65676: GREATER
65677: OR
65678: PUSH
65679: LD_VAR 0 3
65683: PUSH
65684: LD_VAR 0 1
65688: GREATER
65689: OR
65690: IFFALSE 65694
// exit ;
65692: GO 65990
// if direction then
65694: LD_VAR 0 4
65698: IFFALSE 65762
// begin d := 1 ;
65700: LD_ADDR_VAR 0 9
65704: PUSH
65705: LD_INT 1
65707: ST_TO_ADDR
// if i_from > i_to then
65708: LD_VAR 0 2
65712: PUSH
65713: LD_VAR 0 3
65717: GREATER
65718: IFFALSE 65744
// length := ( array - i_from ) + i_to else
65720: LD_ADDR_VAR 0 11
65724: PUSH
65725: LD_VAR 0 1
65729: PUSH
65730: LD_VAR 0 2
65734: MINUS
65735: PUSH
65736: LD_VAR 0 3
65740: PLUS
65741: ST_TO_ADDR
65742: GO 65760
// length := i_to - i_from ;
65744: LD_ADDR_VAR 0 11
65748: PUSH
65749: LD_VAR 0 3
65753: PUSH
65754: LD_VAR 0 2
65758: MINUS
65759: ST_TO_ADDR
// end else
65760: GO 65823
// begin d := - 1 ;
65762: LD_ADDR_VAR 0 9
65766: PUSH
65767: LD_INT 1
65769: NEG
65770: ST_TO_ADDR
// if i_from > i_to then
65771: LD_VAR 0 2
65775: PUSH
65776: LD_VAR 0 3
65780: GREATER
65781: IFFALSE 65801
// length := i_from - i_to else
65783: LD_ADDR_VAR 0 11
65787: PUSH
65788: LD_VAR 0 2
65792: PUSH
65793: LD_VAR 0 3
65797: MINUS
65798: ST_TO_ADDR
65799: GO 65823
// length := ( array - i_to ) + i_from ;
65801: LD_ADDR_VAR 0 11
65805: PUSH
65806: LD_VAR 0 1
65810: PUSH
65811: LD_VAR 0 3
65815: MINUS
65816: PUSH
65817: LD_VAR 0 2
65821: PLUS
65822: ST_TO_ADDR
// end ; if not length then
65823: LD_VAR 0 11
65827: NOT
65828: IFFALSE 65832
// exit ;
65830: GO 65990
// tmp := array ;
65832: LD_ADDR_VAR 0 10
65836: PUSH
65837: LD_VAR 0 1
65841: ST_TO_ADDR
// for i = 1 to length do
65842: LD_ADDR_VAR 0 6
65846: PUSH
65847: DOUBLE
65848: LD_INT 1
65850: DEC
65851: ST_TO_ADDR
65852: LD_VAR 0 11
65856: PUSH
65857: FOR_TO
65858: IFFALSE 65978
// begin for j = 1 to array do
65860: LD_ADDR_VAR 0 7
65864: PUSH
65865: DOUBLE
65866: LD_INT 1
65868: DEC
65869: ST_TO_ADDR
65870: LD_VAR 0 1
65874: PUSH
65875: FOR_TO
65876: IFFALSE 65964
// begin k := j + d ;
65878: LD_ADDR_VAR 0 8
65882: PUSH
65883: LD_VAR 0 7
65887: PUSH
65888: LD_VAR 0 9
65892: PLUS
65893: ST_TO_ADDR
// if k > array then
65894: LD_VAR 0 8
65898: PUSH
65899: LD_VAR 0 1
65903: GREATER
65904: IFFALSE 65914
// k := 1 ;
65906: LD_ADDR_VAR 0 8
65910: PUSH
65911: LD_INT 1
65913: ST_TO_ADDR
// if not k then
65914: LD_VAR 0 8
65918: NOT
65919: IFFALSE 65931
// k := array ;
65921: LD_ADDR_VAR 0 8
65925: PUSH
65926: LD_VAR 0 1
65930: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65931: LD_ADDR_VAR 0 10
65935: PUSH
65936: LD_VAR 0 10
65940: PPUSH
65941: LD_VAR 0 8
65945: PPUSH
65946: LD_VAR 0 1
65950: PUSH
65951: LD_VAR 0 7
65955: ARRAY
65956: PPUSH
65957: CALL_OW 1
65961: ST_TO_ADDR
// end ;
65962: GO 65875
65964: POP
65965: POP
// array := tmp ;
65966: LD_ADDR_VAR 0 1
65970: PUSH
65971: LD_VAR 0 10
65975: ST_TO_ADDR
// end ;
65976: GO 65857
65978: POP
65979: POP
// result := array ;
65980: LD_ADDR_VAR 0 5
65984: PUSH
65985: LD_VAR 0 1
65989: ST_TO_ADDR
// end ;
65990: LD_VAR 0 5
65994: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65995: LD_INT 0
65997: PPUSH
65998: PPUSH
// result := 0 ;
65999: LD_ADDR_VAR 0 3
66003: PUSH
66004: LD_INT 0
66006: ST_TO_ADDR
// if not array or not value in array then
66007: LD_VAR 0 1
66011: NOT
66012: PUSH
66013: LD_VAR 0 2
66017: PUSH
66018: LD_VAR 0 1
66022: IN
66023: NOT
66024: OR
66025: IFFALSE 66029
// exit ;
66027: GO 66083
// for i = 1 to array do
66029: LD_ADDR_VAR 0 4
66033: PUSH
66034: DOUBLE
66035: LD_INT 1
66037: DEC
66038: ST_TO_ADDR
66039: LD_VAR 0 1
66043: PUSH
66044: FOR_TO
66045: IFFALSE 66081
// if value = array [ i ] then
66047: LD_VAR 0 2
66051: PUSH
66052: LD_VAR 0 1
66056: PUSH
66057: LD_VAR 0 4
66061: ARRAY
66062: EQUAL
66063: IFFALSE 66079
// begin result := i ;
66065: LD_ADDR_VAR 0 3
66069: PUSH
66070: LD_VAR 0 4
66074: ST_TO_ADDR
// exit ;
66075: POP
66076: POP
66077: GO 66083
// end ;
66079: GO 66044
66081: POP
66082: POP
// end ;
66083: LD_VAR 0 3
66087: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
66088: LD_INT 0
66090: PPUSH
// vc_chassis := chassis ;
66091: LD_ADDR_OWVAR 37
66095: PUSH
66096: LD_VAR 0 1
66100: ST_TO_ADDR
// vc_engine := engine ;
66101: LD_ADDR_OWVAR 39
66105: PUSH
66106: LD_VAR 0 2
66110: ST_TO_ADDR
// vc_control := control ;
66111: LD_ADDR_OWVAR 38
66115: PUSH
66116: LD_VAR 0 3
66120: ST_TO_ADDR
// vc_weapon := weapon ;
66121: LD_ADDR_OWVAR 40
66125: PUSH
66126: LD_VAR 0 4
66130: ST_TO_ADDR
// vc_fuel_battery := fuel ;
66131: LD_ADDR_OWVAR 41
66135: PUSH
66136: LD_VAR 0 5
66140: ST_TO_ADDR
// end ;
66141: LD_VAR 0 6
66145: RET
// export function WantPlant ( unit ) ; var task ; begin
66146: LD_INT 0
66148: PPUSH
66149: PPUSH
// result := false ;
66150: LD_ADDR_VAR 0 2
66154: PUSH
66155: LD_INT 0
66157: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
66158: LD_ADDR_VAR 0 3
66162: PUSH
66163: LD_VAR 0 1
66167: PPUSH
66168: CALL_OW 437
66172: ST_TO_ADDR
// if task then
66173: LD_VAR 0 3
66177: IFFALSE 66205
// if task [ 1 ] [ 1 ] = p then
66179: LD_VAR 0 3
66183: PUSH
66184: LD_INT 1
66186: ARRAY
66187: PUSH
66188: LD_INT 1
66190: ARRAY
66191: PUSH
66192: LD_STRING p
66194: EQUAL
66195: IFFALSE 66205
// result := true ;
66197: LD_ADDR_VAR 0 2
66201: PUSH
66202: LD_INT 1
66204: ST_TO_ADDR
// end ;
66205: LD_VAR 0 2
66209: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
66210: LD_INT 0
66212: PPUSH
66213: PPUSH
66214: PPUSH
66215: PPUSH
// if pos < 1 then
66216: LD_VAR 0 2
66220: PUSH
66221: LD_INT 1
66223: LESS
66224: IFFALSE 66228
// exit ;
66226: GO 66531
// if pos = 1 then
66228: LD_VAR 0 2
66232: PUSH
66233: LD_INT 1
66235: EQUAL
66236: IFFALSE 66269
// result := Replace ( arr , pos [ 1 ] , value ) else
66238: LD_ADDR_VAR 0 4
66242: PUSH
66243: LD_VAR 0 1
66247: PPUSH
66248: LD_VAR 0 2
66252: PUSH
66253: LD_INT 1
66255: ARRAY
66256: PPUSH
66257: LD_VAR 0 3
66261: PPUSH
66262: CALL_OW 1
66266: ST_TO_ADDR
66267: GO 66531
// begin tmp := arr ;
66269: LD_ADDR_VAR 0 6
66273: PUSH
66274: LD_VAR 0 1
66278: ST_TO_ADDR
// s_arr := [ tmp ] ;
66279: LD_ADDR_VAR 0 7
66283: PUSH
66284: LD_VAR 0 6
66288: PUSH
66289: EMPTY
66290: LIST
66291: ST_TO_ADDR
// for i = 1 to pos - 1 do
66292: LD_ADDR_VAR 0 5
66296: PUSH
66297: DOUBLE
66298: LD_INT 1
66300: DEC
66301: ST_TO_ADDR
66302: LD_VAR 0 2
66306: PUSH
66307: LD_INT 1
66309: MINUS
66310: PUSH
66311: FOR_TO
66312: IFFALSE 66357
// begin tmp := tmp [ pos [ i ] ] ;
66314: LD_ADDR_VAR 0 6
66318: PUSH
66319: LD_VAR 0 6
66323: PUSH
66324: LD_VAR 0 2
66328: PUSH
66329: LD_VAR 0 5
66333: ARRAY
66334: ARRAY
66335: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
66336: LD_ADDR_VAR 0 7
66340: PUSH
66341: LD_VAR 0 7
66345: PUSH
66346: LD_VAR 0 6
66350: PUSH
66351: EMPTY
66352: LIST
66353: ADD
66354: ST_TO_ADDR
// end ;
66355: GO 66311
66357: POP
66358: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
66359: LD_ADDR_VAR 0 6
66363: PUSH
66364: LD_VAR 0 6
66368: PPUSH
66369: LD_VAR 0 2
66373: PUSH
66374: LD_VAR 0 2
66378: ARRAY
66379: PPUSH
66380: LD_VAR 0 3
66384: PPUSH
66385: CALL_OW 1
66389: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
66390: LD_ADDR_VAR 0 7
66394: PUSH
66395: LD_VAR 0 7
66399: PPUSH
66400: LD_VAR 0 7
66404: PPUSH
66405: LD_VAR 0 6
66409: PPUSH
66410: CALL_OW 1
66414: ST_TO_ADDR
// for i = s_arr downto 2 do
66415: LD_ADDR_VAR 0 5
66419: PUSH
66420: DOUBLE
66421: LD_VAR 0 7
66425: INC
66426: ST_TO_ADDR
66427: LD_INT 2
66429: PUSH
66430: FOR_DOWNTO
66431: IFFALSE 66515
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
66433: LD_ADDR_VAR 0 6
66437: PUSH
66438: LD_VAR 0 7
66442: PUSH
66443: LD_VAR 0 5
66447: PUSH
66448: LD_INT 1
66450: MINUS
66451: ARRAY
66452: PPUSH
66453: LD_VAR 0 2
66457: PUSH
66458: LD_VAR 0 5
66462: PUSH
66463: LD_INT 1
66465: MINUS
66466: ARRAY
66467: PPUSH
66468: LD_VAR 0 7
66472: PUSH
66473: LD_VAR 0 5
66477: ARRAY
66478: PPUSH
66479: CALL_OW 1
66483: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
66484: LD_ADDR_VAR 0 7
66488: PUSH
66489: LD_VAR 0 7
66493: PPUSH
66494: LD_VAR 0 5
66498: PUSH
66499: LD_INT 1
66501: MINUS
66502: PPUSH
66503: LD_VAR 0 6
66507: PPUSH
66508: CALL_OW 1
66512: ST_TO_ADDR
// end ;
66513: GO 66430
66515: POP
66516: POP
// result := s_arr [ 1 ] ;
66517: LD_ADDR_VAR 0 4
66521: PUSH
66522: LD_VAR 0 7
66526: PUSH
66527: LD_INT 1
66529: ARRAY
66530: ST_TO_ADDR
// end ; end ;
66531: LD_VAR 0 4
66535: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
66536: LD_INT 0
66538: PPUSH
66539: PPUSH
// if not list then
66540: LD_VAR 0 1
66544: NOT
66545: IFFALSE 66549
// exit ;
66547: GO 66640
// i := list [ pos1 ] ;
66549: LD_ADDR_VAR 0 5
66553: PUSH
66554: LD_VAR 0 1
66558: PUSH
66559: LD_VAR 0 2
66563: ARRAY
66564: ST_TO_ADDR
// if not i then
66565: LD_VAR 0 5
66569: NOT
66570: IFFALSE 66574
// exit ;
66572: GO 66640
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
66574: LD_ADDR_VAR 0 1
66578: PUSH
66579: LD_VAR 0 1
66583: PPUSH
66584: LD_VAR 0 2
66588: PPUSH
66589: LD_VAR 0 1
66593: PUSH
66594: LD_VAR 0 3
66598: ARRAY
66599: PPUSH
66600: CALL_OW 1
66604: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
66605: LD_ADDR_VAR 0 1
66609: PUSH
66610: LD_VAR 0 1
66614: PPUSH
66615: LD_VAR 0 3
66619: PPUSH
66620: LD_VAR 0 5
66624: PPUSH
66625: CALL_OW 1
66629: ST_TO_ADDR
// result := list ;
66630: LD_ADDR_VAR 0 4
66634: PUSH
66635: LD_VAR 0 1
66639: ST_TO_ADDR
// end ;
66640: LD_VAR 0 4
66644: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
66645: LD_INT 0
66647: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
66648: LD_ADDR_VAR 0 5
66652: PUSH
66653: LD_VAR 0 1
66657: PPUSH
66658: CALL_OW 250
66662: PPUSH
66663: LD_VAR 0 1
66667: PPUSH
66668: CALL_OW 251
66672: PPUSH
66673: LD_VAR 0 2
66677: PPUSH
66678: LD_VAR 0 3
66682: PPUSH
66683: LD_VAR 0 4
66687: PPUSH
66688: CALL 66698 0 5
66692: ST_TO_ADDR
// end ;
66693: LD_VAR 0 5
66697: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
66698: LD_INT 0
66700: PPUSH
66701: PPUSH
66702: PPUSH
66703: PPUSH
// if not list then
66704: LD_VAR 0 3
66708: NOT
66709: IFFALSE 66713
// exit ;
66711: GO 67101
// result := [ ] ;
66713: LD_ADDR_VAR 0 6
66717: PUSH
66718: EMPTY
66719: ST_TO_ADDR
// for i in list do
66720: LD_ADDR_VAR 0 7
66724: PUSH
66725: LD_VAR 0 3
66729: PUSH
66730: FOR_IN
66731: IFFALSE 66933
// begin tmp := GetDistUnitXY ( i , x , y ) ;
66733: LD_ADDR_VAR 0 9
66737: PUSH
66738: LD_VAR 0 7
66742: PPUSH
66743: LD_VAR 0 1
66747: PPUSH
66748: LD_VAR 0 2
66752: PPUSH
66753: CALL_OW 297
66757: ST_TO_ADDR
// if not result then
66758: LD_VAR 0 6
66762: NOT
66763: IFFALSE 66789
// result := [ [ i , tmp ] ] else
66765: LD_ADDR_VAR 0 6
66769: PUSH
66770: LD_VAR 0 7
66774: PUSH
66775: LD_VAR 0 9
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: EMPTY
66785: LIST
66786: ST_TO_ADDR
66787: GO 66931
// begin if result [ result ] [ 2 ] < tmp then
66789: LD_VAR 0 6
66793: PUSH
66794: LD_VAR 0 6
66798: ARRAY
66799: PUSH
66800: LD_INT 2
66802: ARRAY
66803: PUSH
66804: LD_VAR 0 9
66808: LESS
66809: IFFALSE 66851
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66811: LD_ADDR_VAR 0 6
66815: PUSH
66816: LD_VAR 0 6
66820: PPUSH
66821: LD_VAR 0 6
66825: PUSH
66826: LD_INT 1
66828: PLUS
66829: PPUSH
66830: LD_VAR 0 7
66834: PUSH
66835: LD_VAR 0 9
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PPUSH
66844: CALL_OW 2
66848: ST_TO_ADDR
66849: GO 66931
// for j = 1 to result do
66851: LD_ADDR_VAR 0 8
66855: PUSH
66856: DOUBLE
66857: LD_INT 1
66859: DEC
66860: ST_TO_ADDR
66861: LD_VAR 0 6
66865: PUSH
66866: FOR_TO
66867: IFFALSE 66929
// begin if tmp < result [ j ] [ 2 ] then
66869: LD_VAR 0 9
66873: PUSH
66874: LD_VAR 0 6
66878: PUSH
66879: LD_VAR 0 8
66883: ARRAY
66884: PUSH
66885: LD_INT 2
66887: ARRAY
66888: LESS
66889: IFFALSE 66927
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66891: LD_ADDR_VAR 0 6
66895: PUSH
66896: LD_VAR 0 6
66900: PPUSH
66901: LD_VAR 0 8
66905: PPUSH
66906: LD_VAR 0 7
66910: PUSH
66911: LD_VAR 0 9
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PPUSH
66920: CALL_OW 2
66924: ST_TO_ADDR
// break ;
66925: GO 66929
// end ; end ;
66927: GO 66866
66929: POP
66930: POP
// end ; end ;
66931: GO 66730
66933: POP
66934: POP
// if result and not asc then
66935: LD_VAR 0 6
66939: PUSH
66940: LD_VAR 0 4
66944: NOT
66945: AND
66946: IFFALSE 67021
// begin tmp := result ;
66948: LD_ADDR_VAR 0 9
66952: PUSH
66953: LD_VAR 0 6
66957: ST_TO_ADDR
// for i = tmp downto 1 do
66958: LD_ADDR_VAR 0 7
66962: PUSH
66963: DOUBLE
66964: LD_VAR 0 9
66968: INC
66969: ST_TO_ADDR
66970: LD_INT 1
66972: PUSH
66973: FOR_DOWNTO
66974: IFFALSE 67019
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66976: LD_ADDR_VAR 0 6
66980: PUSH
66981: LD_VAR 0 6
66985: PPUSH
66986: LD_VAR 0 9
66990: PUSH
66991: LD_VAR 0 7
66995: MINUS
66996: PUSH
66997: LD_INT 1
66999: PLUS
67000: PPUSH
67001: LD_VAR 0 9
67005: PUSH
67006: LD_VAR 0 7
67010: ARRAY
67011: PPUSH
67012: CALL_OW 1
67016: ST_TO_ADDR
67017: GO 66973
67019: POP
67020: POP
// end ; tmp := [ ] ;
67021: LD_ADDR_VAR 0 9
67025: PUSH
67026: EMPTY
67027: ST_TO_ADDR
// if mode then
67028: LD_VAR 0 5
67032: IFFALSE 67101
// begin for i = 1 to result do
67034: LD_ADDR_VAR 0 7
67038: PUSH
67039: DOUBLE
67040: LD_INT 1
67042: DEC
67043: ST_TO_ADDR
67044: LD_VAR 0 6
67048: PUSH
67049: FOR_TO
67050: IFFALSE 67089
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
67052: LD_ADDR_VAR 0 9
67056: PUSH
67057: LD_VAR 0 9
67061: PPUSH
67062: LD_VAR 0 7
67066: PPUSH
67067: LD_VAR 0 6
67071: PUSH
67072: LD_VAR 0 7
67076: ARRAY
67077: PUSH
67078: LD_INT 1
67080: ARRAY
67081: PPUSH
67082: CALL_OW 1
67086: ST_TO_ADDR
67087: GO 67049
67089: POP
67090: POP
// result := tmp ;
67091: LD_ADDR_VAR 0 6
67095: PUSH
67096: LD_VAR 0 9
67100: ST_TO_ADDR
// end ; end ;
67101: LD_VAR 0 6
67105: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
67106: LD_INT 0
67108: PPUSH
67109: PPUSH
67110: PPUSH
67111: PPUSH
67112: PPUSH
67113: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
67114: LD_ADDR_VAR 0 5
67118: PUSH
67119: LD_INT 0
67121: PUSH
67122: LD_INT 0
67124: PUSH
67125: LD_INT 0
67127: PUSH
67128: EMPTY
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: ST_TO_ADDR
// if not x or not y then
67136: LD_VAR 0 2
67140: NOT
67141: PUSH
67142: LD_VAR 0 3
67146: NOT
67147: OR
67148: IFFALSE 67152
// exit ;
67150: GO 68804
// if not range then
67152: LD_VAR 0 4
67156: NOT
67157: IFFALSE 67167
// range := 10 ;
67159: LD_ADDR_VAR 0 4
67163: PUSH
67164: LD_INT 10
67166: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67167: LD_ADDR_VAR 0 8
67171: PUSH
67172: LD_INT 81
67174: PUSH
67175: LD_VAR 0 1
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 92
67186: PUSH
67187: LD_VAR 0 2
67191: PUSH
67192: LD_VAR 0 3
67196: PUSH
67197: LD_VAR 0 4
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 3
67210: PUSH
67211: LD_INT 21
67213: PUSH
67214: LD_INT 3
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: EMPTY
67226: LIST
67227: LIST
67228: LIST
67229: PPUSH
67230: CALL_OW 69
67234: ST_TO_ADDR
// if not tmp then
67235: LD_VAR 0 8
67239: NOT
67240: IFFALSE 67244
// exit ;
67242: GO 68804
// for i in tmp do
67244: LD_ADDR_VAR 0 6
67248: PUSH
67249: LD_VAR 0 8
67253: PUSH
67254: FOR_IN
67255: IFFALSE 68779
// begin points := [ 0 , 0 , 0 ] ;
67257: LD_ADDR_VAR 0 9
67261: PUSH
67262: LD_INT 0
67264: PUSH
67265: LD_INT 0
67267: PUSH
67268: LD_INT 0
67270: PUSH
67271: EMPTY
67272: LIST
67273: LIST
67274: LIST
67275: ST_TO_ADDR
// bpoints := 1 ;
67276: LD_ADDR_VAR 0 10
67280: PUSH
67281: LD_INT 1
67283: ST_TO_ADDR
// case GetType ( i ) of unit_human :
67284: LD_VAR 0 6
67288: PPUSH
67289: CALL_OW 247
67293: PUSH
67294: LD_INT 1
67296: DOUBLE
67297: EQUAL
67298: IFTRUE 67302
67300: GO 67880
67302: POP
// begin if GetClass ( i ) = 1 then
67303: LD_VAR 0 6
67307: PPUSH
67308: CALL_OW 257
67312: PUSH
67313: LD_INT 1
67315: EQUAL
67316: IFFALSE 67337
// points := [ 10 , 5 , 3 ] ;
67318: LD_ADDR_VAR 0 9
67322: PUSH
67323: LD_INT 10
67325: PUSH
67326: LD_INT 5
67328: PUSH
67329: LD_INT 3
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: LIST
67336: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
67337: LD_VAR 0 6
67341: PPUSH
67342: CALL_OW 257
67346: PUSH
67347: LD_INT 2
67349: PUSH
67350: LD_INT 3
67352: PUSH
67353: LD_INT 4
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: LIST
67360: IN
67361: IFFALSE 67382
// points := [ 3 , 2 , 1 ] ;
67363: LD_ADDR_VAR 0 9
67367: PUSH
67368: LD_INT 3
67370: PUSH
67371: LD_INT 2
67373: PUSH
67374: LD_INT 1
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: LIST
67381: ST_TO_ADDR
// if GetClass ( i ) = 5 then
67382: LD_VAR 0 6
67386: PPUSH
67387: CALL_OW 257
67391: PUSH
67392: LD_INT 5
67394: EQUAL
67395: IFFALSE 67416
// points := [ 130 , 5 , 2 ] ;
67397: LD_ADDR_VAR 0 9
67401: PUSH
67402: LD_INT 130
67404: PUSH
67405: LD_INT 5
67407: PUSH
67408: LD_INT 2
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: LIST
67415: ST_TO_ADDR
// if GetClass ( i ) = 8 then
67416: LD_VAR 0 6
67420: PPUSH
67421: CALL_OW 257
67425: PUSH
67426: LD_INT 8
67428: EQUAL
67429: IFFALSE 67450
// points := [ 35 , 35 , 30 ] ;
67431: LD_ADDR_VAR 0 9
67435: PUSH
67436: LD_INT 35
67438: PUSH
67439: LD_INT 35
67441: PUSH
67442: LD_INT 30
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: LIST
67449: ST_TO_ADDR
// if GetClass ( i ) = 9 then
67450: LD_VAR 0 6
67454: PPUSH
67455: CALL_OW 257
67459: PUSH
67460: LD_INT 9
67462: EQUAL
67463: IFFALSE 67484
// points := [ 20 , 55 , 40 ] ;
67465: LD_ADDR_VAR 0 9
67469: PUSH
67470: LD_INT 20
67472: PUSH
67473: LD_INT 55
67475: PUSH
67476: LD_INT 40
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: LIST
67483: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
67484: LD_VAR 0 6
67488: PPUSH
67489: CALL_OW 257
67493: PUSH
67494: LD_INT 12
67496: PUSH
67497: LD_INT 16
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: IN
67504: IFFALSE 67525
// points := [ 5 , 3 , 2 ] ;
67506: LD_ADDR_VAR 0 9
67510: PUSH
67511: LD_INT 5
67513: PUSH
67514: LD_INT 3
67516: PUSH
67517: LD_INT 2
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: LIST
67524: ST_TO_ADDR
// if GetClass ( i ) = 17 then
67525: LD_VAR 0 6
67529: PPUSH
67530: CALL_OW 257
67534: PUSH
67535: LD_INT 17
67537: EQUAL
67538: IFFALSE 67559
// points := [ 100 , 50 , 75 ] ;
67540: LD_ADDR_VAR 0 9
67544: PUSH
67545: LD_INT 100
67547: PUSH
67548: LD_INT 50
67550: PUSH
67551: LD_INT 75
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: LIST
67558: ST_TO_ADDR
// if GetClass ( i ) = 15 then
67559: LD_VAR 0 6
67563: PPUSH
67564: CALL_OW 257
67568: PUSH
67569: LD_INT 15
67571: EQUAL
67572: IFFALSE 67593
// points := [ 10 , 5 , 3 ] ;
67574: LD_ADDR_VAR 0 9
67578: PUSH
67579: LD_INT 10
67581: PUSH
67582: LD_INT 5
67584: PUSH
67585: LD_INT 3
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: LIST
67592: ST_TO_ADDR
// if GetClass ( i ) = 14 then
67593: LD_VAR 0 6
67597: PPUSH
67598: CALL_OW 257
67602: PUSH
67603: LD_INT 14
67605: EQUAL
67606: IFFALSE 67627
// points := [ 10 , 0 , 0 ] ;
67608: LD_ADDR_VAR 0 9
67612: PUSH
67613: LD_INT 10
67615: PUSH
67616: LD_INT 0
67618: PUSH
67619: LD_INT 0
67621: PUSH
67622: EMPTY
67623: LIST
67624: LIST
67625: LIST
67626: ST_TO_ADDR
// if GetClass ( i ) = 11 then
67627: LD_VAR 0 6
67631: PPUSH
67632: CALL_OW 257
67636: PUSH
67637: LD_INT 11
67639: EQUAL
67640: IFFALSE 67661
// points := [ 30 , 10 , 5 ] ;
67642: LD_ADDR_VAR 0 9
67646: PUSH
67647: LD_INT 30
67649: PUSH
67650: LD_INT 10
67652: PUSH
67653: LD_INT 5
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: LIST
67660: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
67661: LD_VAR 0 1
67665: PPUSH
67666: LD_INT 5
67668: PPUSH
67669: CALL_OW 321
67673: PUSH
67674: LD_INT 2
67676: EQUAL
67677: IFFALSE 67694
// bpoints := bpoints * 1.8 ;
67679: LD_ADDR_VAR 0 10
67683: PUSH
67684: LD_VAR 0 10
67688: PUSH
67689: LD_REAL  1.80000000000000E+0000
67692: MUL
67693: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
67694: LD_VAR 0 6
67698: PPUSH
67699: CALL_OW 257
67703: PUSH
67704: LD_INT 1
67706: PUSH
67707: LD_INT 2
67709: PUSH
67710: LD_INT 3
67712: PUSH
67713: LD_INT 4
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: IN
67722: PUSH
67723: LD_VAR 0 1
67727: PPUSH
67728: LD_INT 51
67730: PPUSH
67731: CALL_OW 321
67735: PUSH
67736: LD_INT 2
67738: EQUAL
67739: AND
67740: IFFALSE 67757
// bpoints := bpoints * 1.2 ;
67742: LD_ADDR_VAR 0 10
67746: PUSH
67747: LD_VAR 0 10
67751: PUSH
67752: LD_REAL  1.20000000000000E+0000
67755: MUL
67756: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67757: LD_VAR 0 6
67761: PPUSH
67762: CALL_OW 257
67766: PUSH
67767: LD_INT 5
67769: PUSH
67770: LD_INT 7
67772: PUSH
67773: LD_INT 9
67775: PUSH
67776: EMPTY
67777: LIST
67778: LIST
67779: LIST
67780: IN
67781: PUSH
67782: LD_VAR 0 1
67786: PPUSH
67787: LD_INT 52
67789: PPUSH
67790: CALL_OW 321
67794: PUSH
67795: LD_INT 2
67797: EQUAL
67798: AND
67799: IFFALSE 67816
// bpoints := bpoints * 1.5 ;
67801: LD_ADDR_VAR 0 10
67805: PUSH
67806: LD_VAR 0 10
67810: PUSH
67811: LD_REAL  1.50000000000000E+0000
67814: MUL
67815: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67816: LD_VAR 0 1
67820: PPUSH
67821: LD_INT 66
67823: PPUSH
67824: CALL_OW 321
67828: PUSH
67829: LD_INT 2
67831: EQUAL
67832: IFFALSE 67849
// bpoints := bpoints * 1.1 ;
67834: LD_ADDR_VAR 0 10
67838: PUSH
67839: LD_VAR 0 10
67843: PUSH
67844: LD_REAL  1.10000000000000E+0000
67847: MUL
67848: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67849: LD_ADDR_VAR 0 10
67853: PUSH
67854: LD_VAR 0 10
67858: PUSH
67859: LD_VAR 0 6
67863: PPUSH
67864: LD_INT 1
67866: PPUSH
67867: CALL_OW 259
67871: PUSH
67872: LD_REAL  1.15000000000000E+0000
67875: MUL
67876: MUL
67877: ST_TO_ADDR
// end ; unit_vehicle :
67878: GO 68708
67880: LD_INT 2
67882: DOUBLE
67883: EQUAL
67884: IFTRUE 67888
67886: GO 68696
67888: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67889: LD_VAR 0 6
67893: PPUSH
67894: CALL_OW 264
67898: PUSH
67899: LD_INT 2
67901: PUSH
67902: LD_INT 42
67904: PUSH
67905: LD_INT 24
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: LIST
67912: IN
67913: IFFALSE 67934
// points := [ 25 , 5 , 3 ] ;
67915: LD_ADDR_VAR 0 9
67919: PUSH
67920: LD_INT 25
67922: PUSH
67923: LD_INT 5
67925: PUSH
67926: LD_INT 3
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: LIST
67933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67934: LD_VAR 0 6
67938: PPUSH
67939: CALL_OW 264
67943: PUSH
67944: LD_INT 4
67946: PUSH
67947: LD_INT 43
67949: PUSH
67950: LD_INT 25
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: LIST
67957: IN
67958: IFFALSE 67979
// points := [ 40 , 15 , 5 ] ;
67960: LD_ADDR_VAR 0 9
67964: PUSH
67965: LD_INT 40
67967: PUSH
67968: LD_INT 15
67970: PUSH
67971: LD_INT 5
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: LIST
67978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67979: LD_VAR 0 6
67983: PPUSH
67984: CALL_OW 264
67988: PUSH
67989: LD_INT 3
67991: PUSH
67992: LD_INT 23
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: IN
67999: IFFALSE 68020
// points := [ 7 , 25 , 8 ] ;
68001: LD_ADDR_VAR 0 9
68005: PUSH
68006: LD_INT 7
68008: PUSH
68009: LD_INT 25
68011: PUSH
68012: LD_INT 8
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: LIST
68019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
68020: LD_VAR 0 6
68024: PPUSH
68025: CALL_OW 264
68029: PUSH
68030: LD_INT 5
68032: PUSH
68033: LD_INT 27
68035: PUSH
68036: LD_INT 44
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: LIST
68043: IN
68044: IFFALSE 68065
// points := [ 14 , 50 , 16 ] ;
68046: LD_ADDR_VAR 0 9
68050: PUSH
68051: LD_INT 14
68053: PUSH
68054: LD_INT 50
68056: PUSH
68057: LD_INT 16
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: LIST
68064: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
68065: LD_VAR 0 6
68069: PPUSH
68070: CALL_OW 264
68074: PUSH
68075: LD_INT 6
68077: PUSH
68078: LD_INT 46
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: IN
68085: IFFALSE 68106
// points := [ 32 , 120 , 70 ] ;
68087: LD_ADDR_VAR 0 9
68091: PUSH
68092: LD_INT 32
68094: PUSH
68095: LD_INT 120
68097: PUSH
68098: LD_INT 70
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: LIST
68105: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
68106: LD_VAR 0 6
68110: PPUSH
68111: CALL_OW 264
68115: PUSH
68116: LD_INT 7
68118: PUSH
68119: LD_INT 28
68121: PUSH
68122: LD_INT 45
68124: PUSH
68125: LD_EXP 78
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: LIST
68134: LIST
68135: IN
68136: IFFALSE 68157
// points := [ 35 , 20 , 45 ] ;
68138: LD_ADDR_VAR 0 9
68142: PUSH
68143: LD_INT 35
68145: PUSH
68146: LD_INT 20
68148: PUSH
68149: LD_INT 45
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: LIST
68156: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
68157: LD_VAR 0 6
68161: PPUSH
68162: CALL_OW 264
68166: PUSH
68167: LD_INT 47
68169: PUSH
68170: EMPTY
68171: LIST
68172: IN
68173: IFFALSE 68194
// points := [ 67 , 45 , 75 ] ;
68175: LD_ADDR_VAR 0 9
68179: PUSH
68180: LD_INT 67
68182: PUSH
68183: LD_INT 45
68185: PUSH
68186: LD_INT 75
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: LIST
68193: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
68194: LD_VAR 0 6
68198: PPUSH
68199: CALL_OW 264
68203: PUSH
68204: LD_INT 26
68206: PUSH
68207: EMPTY
68208: LIST
68209: IN
68210: IFFALSE 68231
// points := [ 120 , 30 , 80 ] ;
68212: LD_ADDR_VAR 0 9
68216: PUSH
68217: LD_INT 120
68219: PUSH
68220: LD_INT 30
68222: PUSH
68223: LD_INT 80
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: LIST
68230: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
68231: LD_VAR 0 6
68235: PPUSH
68236: CALL_OW 264
68240: PUSH
68241: LD_INT 22
68243: PUSH
68244: EMPTY
68245: LIST
68246: IN
68247: IFFALSE 68268
// points := [ 40 , 1 , 1 ] ;
68249: LD_ADDR_VAR 0 9
68253: PUSH
68254: LD_INT 40
68256: PUSH
68257: LD_INT 1
68259: PUSH
68260: LD_INT 1
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: LIST
68267: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
68268: LD_VAR 0 6
68272: PPUSH
68273: CALL_OW 264
68277: PUSH
68278: LD_INT 29
68280: PUSH
68281: EMPTY
68282: LIST
68283: IN
68284: IFFALSE 68305
// points := [ 70 , 200 , 400 ] ;
68286: LD_ADDR_VAR 0 9
68290: PUSH
68291: LD_INT 70
68293: PUSH
68294: LD_INT 200
68296: PUSH
68297: LD_INT 400
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: LIST
68304: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
68305: LD_VAR 0 6
68309: PPUSH
68310: CALL_OW 264
68314: PUSH
68315: LD_INT 14
68317: PUSH
68318: LD_INT 53
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: IN
68325: IFFALSE 68346
// points := [ 40 , 10 , 20 ] ;
68327: LD_ADDR_VAR 0 9
68331: PUSH
68332: LD_INT 40
68334: PUSH
68335: LD_INT 10
68337: PUSH
68338: LD_INT 20
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: LIST
68345: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
68346: LD_VAR 0 6
68350: PPUSH
68351: CALL_OW 264
68355: PUSH
68356: LD_INT 9
68358: PUSH
68359: EMPTY
68360: LIST
68361: IN
68362: IFFALSE 68383
// points := [ 5 , 70 , 20 ] ;
68364: LD_ADDR_VAR 0 9
68368: PUSH
68369: LD_INT 5
68371: PUSH
68372: LD_INT 70
68374: PUSH
68375: LD_INT 20
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: LIST
68382: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
68383: LD_VAR 0 6
68387: PPUSH
68388: CALL_OW 264
68392: PUSH
68393: LD_INT 10
68395: PUSH
68396: EMPTY
68397: LIST
68398: IN
68399: IFFALSE 68420
// points := [ 35 , 110 , 70 ] ;
68401: LD_ADDR_VAR 0 9
68405: PUSH
68406: LD_INT 35
68408: PUSH
68409: LD_INT 110
68411: PUSH
68412: LD_INT 70
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: LIST
68419: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
68420: LD_VAR 0 6
68424: PPUSH
68425: CALL_OW 265
68429: PUSH
68430: LD_INT 25
68432: EQUAL
68433: IFFALSE 68454
// points := [ 80 , 65 , 100 ] ;
68435: LD_ADDR_VAR 0 9
68439: PUSH
68440: LD_INT 80
68442: PUSH
68443: LD_INT 65
68445: PUSH
68446: LD_INT 100
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: LIST
68453: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
68454: LD_VAR 0 6
68458: PPUSH
68459: CALL_OW 263
68463: PUSH
68464: LD_INT 1
68466: EQUAL
68467: IFFALSE 68502
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
68469: LD_ADDR_VAR 0 10
68473: PUSH
68474: LD_VAR 0 10
68478: PUSH
68479: LD_VAR 0 6
68483: PPUSH
68484: CALL_OW 311
68488: PPUSH
68489: LD_INT 3
68491: PPUSH
68492: CALL_OW 259
68496: PUSH
68497: LD_INT 4
68499: MUL
68500: MUL
68501: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
68502: LD_VAR 0 6
68506: PPUSH
68507: CALL_OW 263
68511: PUSH
68512: LD_INT 2
68514: EQUAL
68515: IFFALSE 68566
// begin j := IsControledBy ( i ) ;
68517: LD_ADDR_VAR 0 7
68521: PUSH
68522: LD_VAR 0 6
68526: PPUSH
68527: CALL_OW 312
68531: ST_TO_ADDR
// if j then
68532: LD_VAR 0 7
68536: IFFALSE 68566
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
68538: LD_ADDR_VAR 0 10
68542: PUSH
68543: LD_VAR 0 10
68547: PUSH
68548: LD_VAR 0 7
68552: PPUSH
68553: LD_INT 3
68555: PPUSH
68556: CALL_OW 259
68560: PUSH
68561: LD_INT 3
68563: MUL
68564: MUL
68565: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
68566: LD_VAR 0 6
68570: PPUSH
68571: CALL_OW 264
68575: PUSH
68576: LD_INT 5
68578: PUSH
68579: LD_INT 6
68581: PUSH
68582: LD_INT 46
68584: PUSH
68585: LD_INT 44
68587: PUSH
68588: LD_INT 47
68590: PUSH
68591: LD_INT 45
68593: PUSH
68594: LD_INT 28
68596: PUSH
68597: LD_INT 7
68599: PUSH
68600: LD_INT 27
68602: PUSH
68603: LD_INT 29
68605: PUSH
68606: EMPTY
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: IN
68618: PUSH
68619: LD_VAR 0 1
68623: PPUSH
68624: LD_INT 52
68626: PPUSH
68627: CALL_OW 321
68631: PUSH
68632: LD_INT 2
68634: EQUAL
68635: AND
68636: IFFALSE 68653
// bpoints := bpoints * 1.2 ;
68638: LD_ADDR_VAR 0 10
68642: PUSH
68643: LD_VAR 0 10
68647: PUSH
68648: LD_REAL  1.20000000000000E+0000
68651: MUL
68652: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
68653: LD_VAR 0 6
68657: PPUSH
68658: CALL_OW 264
68662: PUSH
68663: LD_INT 6
68665: PUSH
68666: LD_INT 46
68668: PUSH
68669: LD_INT 47
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: LIST
68676: IN
68677: IFFALSE 68694
// bpoints := bpoints * 1.2 ;
68679: LD_ADDR_VAR 0 10
68683: PUSH
68684: LD_VAR 0 10
68688: PUSH
68689: LD_REAL  1.20000000000000E+0000
68692: MUL
68693: ST_TO_ADDR
// end ; unit_building :
68694: GO 68708
68696: LD_INT 3
68698: DOUBLE
68699: EQUAL
68700: IFTRUE 68704
68702: GO 68707
68704: POP
// ; end ;
68705: GO 68708
68707: POP
// for j = 1 to 3 do
68708: LD_ADDR_VAR 0 7
68712: PUSH
68713: DOUBLE
68714: LD_INT 1
68716: DEC
68717: ST_TO_ADDR
68718: LD_INT 3
68720: PUSH
68721: FOR_TO
68722: IFFALSE 68775
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
68724: LD_ADDR_VAR 0 5
68728: PUSH
68729: LD_VAR 0 5
68733: PPUSH
68734: LD_VAR 0 7
68738: PPUSH
68739: LD_VAR 0 5
68743: PUSH
68744: LD_VAR 0 7
68748: ARRAY
68749: PUSH
68750: LD_VAR 0 9
68754: PUSH
68755: LD_VAR 0 7
68759: ARRAY
68760: PUSH
68761: LD_VAR 0 10
68765: MUL
68766: PLUS
68767: PPUSH
68768: CALL_OW 1
68772: ST_TO_ADDR
68773: GO 68721
68775: POP
68776: POP
// end ;
68777: GO 67254
68779: POP
68780: POP
// result := Replace ( result , 4 , tmp ) ;
68781: LD_ADDR_VAR 0 5
68785: PUSH
68786: LD_VAR 0 5
68790: PPUSH
68791: LD_INT 4
68793: PPUSH
68794: LD_VAR 0 8
68798: PPUSH
68799: CALL_OW 1
68803: ST_TO_ADDR
// end ;
68804: LD_VAR 0 5
68808: RET
// export function DangerAtRange ( unit , range ) ; begin
68809: LD_INT 0
68811: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68812: LD_ADDR_VAR 0 3
68816: PUSH
68817: LD_VAR 0 1
68821: PPUSH
68822: CALL_OW 255
68826: PPUSH
68827: LD_VAR 0 1
68831: PPUSH
68832: CALL_OW 250
68836: PPUSH
68837: LD_VAR 0 1
68841: PPUSH
68842: CALL_OW 251
68846: PPUSH
68847: LD_VAR 0 2
68851: PPUSH
68852: CALL 67106 0 4
68856: ST_TO_ADDR
// end ;
68857: LD_VAR 0 3
68861: RET
// export function DangerInArea ( side , area ) ; begin
68862: LD_INT 0
68864: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68865: LD_ADDR_VAR 0 3
68869: PUSH
68870: LD_VAR 0 2
68874: PPUSH
68875: LD_INT 81
68877: PUSH
68878: LD_VAR 0 1
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PPUSH
68887: CALL_OW 70
68891: ST_TO_ADDR
// end ;
68892: LD_VAR 0 3
68896: RET
// export function IsExtension ( b ) ; begin
68897: LD_INT 0
68899: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68900: LD_ADDR_VAR 0 2
68904: PUSH
68905: LD_VAR 0 1
68909: PUSH
68910: LD_INT 23
68912: PUSH
68913: LD_INT 20
68915: PUSH
68916: LD_INT 22
68918: PUSH
68919: LD_INT 17
68921: PUSH
68922: LD_INT 24
68924: PUSH
68925: LD_INT 21
68927: PUSH
68928: LD_INT 19
68930: PUSH
68931: LD_INT 16
68933: PUSH
68934: LD_INT 25
68936: PUSH
68937: LD_INT 18
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: IN
68952: ST_TO_ADDR
// end ;
68953: LD_VAR 0 2
68957: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
68958: LD_INT 0
68960: PPUSH
68961: PPUSH
68962: PPUSH
// result := [ ] ;
68963: LD_ADDR_VAR 0 4
68967: PUSH
68968: EMPTY
68969: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68970: LD_ADDR_VAR 0 5
68974: PUSH
68975: LD_VAR 0 2
68979: PPUSH
68980: LD_INT 21
68982: PUSH
68983: LD_INT 3
68985: PUSH
68986: EMPTY
68987: LIST
68988: LIST
68989: PPUSH
68990: CALL_OW 70
68994: ST_TO_ADDR
// if not tmp then
68995: LD_VAR 0 5
68999: NOT
69000: IFFALSE 69004
// exit ;
69002: GO 69068
// if checkLink then
69004: LD_VAR 0 3
69008: IFFALSE 69058
// begin for i in tmp do
69010: LD_ADDR_VAR 0 6
69014: PUSH
69015: LD_VAR 0 5
69019: PUSH
69020: FOR_IN
69021: IFFALSE 69056
// if GetBase ( i ) <> base then
69023: LD_VAR 0 6
69027: PPUSH
69028: CALL_OW 274
69032: PUSH
69033: LD_VAR 0 1
69037: NONEQUAL
69038: IFFALSE 69054
// ComLinkToBase ( base , i ) ;
69040: LD_VAR 0 1
69044: PPUSH
69045: LD_VAR 0 6
69049: PPUSH
69050: CALL_OW 169
69054: GO 69020
69056: POP
69057: POP
// end ; result := tmp ;
69058: LD_ADDR_VAR 0 4
69062: PUSH
69063: LD_VAR 0 5
69067: ST_TO_ADDR
// end ;
69068: LD_VAR 0 4
69072: RET
// export function ComComplete ( units , b ) ; var i ; begin
69073: LD_INT 0
69075: PPUSH
69076: PPUSH
// if not units then
69077: LD_VAR 0 1
69081: NOT
69082: IFFALSE 69086
// exit ;
69084: GO 69176
// for i in units do
69086: LD_ADDR_VAR 0 4
69090: PUSH
69091: LD_VAR 0 1
69095: PUSH
69096: FOR_IN
69097: IFFALSE 69174
// if BuildingStatus ( b ) = bs_build then
69099: LD_VAR 0 2
69103: PPUSH
69104: CALL_OW 461
69108: PUSH
69109: LD_INT 1
69111: EQUAL
69112: IFFALSE 69172
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
69114: LD_VAR 0 4
69118: PPUSH
69119: LD_STRING h
69121: PUSH
69122: LD_VAR 0 2
69126: PPUSH
69127: CALL_OW 250
69131: PUSH
69132: LD_VAR 0 2
69136: PPUSH
69137: CALL_OW 251
69141: PUSH
69142: LD_VAR 0 2
69146: PUSH
69147: LD_INT 0
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: PUSH
69165: EMPTY
69166: LIST
69167: PPUSH
69168: CALL_OW 446
69172: GO 69096
69174: POP
69175: POP
// end ;
69176: LD_VAR 0 3
69180: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
69181: LD_INT 0
69183: PPUSH
69184: PPUSH
69185: PPUSH
69186: PPUSH
69187: PPUSH
69188: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
69189: LD_VAR 0 1
69193: NOT
69194: PUSH
69195: LD_VAR 0 1
69199: PPUSH
69200: CALL_OW 263
69204: PUSH
69205: LD_INT 2
69207: NONEQUAL
69208: OR
69209: IFFALSE 69213
// exit ;
69211: GO 69529
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
69213: LD_ADDR_VAR 0 6
69217: PUSH
69218: LD_INT 22
69220: PUSH
69221: LD_VAR 0 1
69225: PPUSH
69226: CALL_OW 255
69230: PUSH
69231: EMPTY
69232: LIST
69233: LIST
69234: PUSH
69235: LD_INT 2
69237: PUSH
69238: LD_INT 30
69240: PUSH
69241: LD_INT 36
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 34
69250: PUSH
69251: LD_INT 31
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: LIST
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: PPUSH
69267: CALL_OW 69
69271: ST_TO_ADDR
// if not tmp then
69272: LD_VAR 0 6
69276: NOT
69277: IFFALSE 69281
// exit ;
69279: GO 69529
// result := [ ] ;
69281: LD_ADDR_VAR 0 2
69285: PUSH
69286: EMPTY
69287: ST_TO_ADDR
// for i in tmp do
69288: LD_ADDR_VAR 0 3
69292: PUSH
69293: LD_VAR 0 6
69297: PUSH
69298: FOR_IN
69299: IFFALSE 69370
// begin t := UnitsInside ( i ) ;
69301: LD_ADDR_VAR 0 4
69305: PUSH
69306: LD_VAR 0 3
69310: PPUSH
69311: CALL_OW 313
69315: ST_TO_ADDR
// if t then
69316: LD_VAR 0 4
69320: IFFALSE 69368
// for j in t do
69322: LD_ADDR_VAR 0 7
69326: PUSH
69327: LD_VAR 0 4
69331: PUSH
69332: FOR_IN
69333: IFFALSE 69366
// result := Replace ( result , result + 1 , j ) ;
69335: LD_ADDR_VAR 0 2
69339: PUSH
69340: LD_VAR 0 2
69344: PPUSH
69345: LD_VAR 0 2
69349: PUSH
69350: LD_INT 1
69352: PLUS
69353: PPUSH
69354: LD_VAR 0 7
69358: PPUSH
69359: CALL_OW 1
69363: ST_TO_ADDR
69364: GO 69332
69366: POP
69367: POP
// end ;
69368: GO 69298
69370: POP
69371: POP
// if not result then
69372: LD_VAR 0 2
69376: NOT
69377: IFFALSE 69381
// exit ;
69379: GO 69529
// mech := result [ 1 ] ;
69381: LD_ADDR_VAR 0 5
69385: PUSH
69386: LD_VAR 0 2
69390: PUSH
69391: LD_INT 1
69393: ARRAY
69394: ST_TO_ADDR
// if result > 1 then
69395: LD_VAR 0 2
69399: PUSH
69400: LD_INT 1
69402: GREATER
69403: IFFALSE 69515
// begin for i = 2 to result do
69405: LD_ADDR_VAR 0 3
69409: PUSH
69410: DOUBLE
69411: LD_INT 2
69413: DEC
69414: ST_TO_ADDR
69415: LD_VAR 0 2
69419: PUSH
69420: FOR_TO
69421: IFFALSE 69513
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
69423: LD_ADDR_VAR 0 4
69427: PUSH
69428: LD_VAR 0 2
69432: PUSH
69433: LD_VAR 0 3
69437: ARRAY
69438: PPUSH
69439: LD_INT 3
69441: PPUSH
69442: CALL_OW 259
69446: PUSH
69447: LD_VAR 0 2
69451: PUSH
69452: LD_VAR 0 3
69456: ARRAY
69457: PPUSH
69458: CALL_OW 432
69462: MINUS
69463: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
69464: LD_VAR 0 4
69468: PUSH
69469: LD_VAR 0 5
69473: PPUSH
69474: LD_INT 3
69476: PPUSH
69477: CALL_OW 259
69481: PUSH
69482: LD_VAR 0 5
69486: PPUSH
69487: CALL_OW 432
69491: MINUS
69492: GREATEREQUAL
69493: IFFALSE 69511
// mech := result [ i ] ;
69495: LD_ADDR_VAR 0 5
69499: PUSH
69500: LD_VAR 0 2
69504: PUSH
69505: LD_VAR 0 3
69509: ARRAY
69510: ST_TO_ADDR
// end ;
69511: GO 69420
69513: POP
69514: POP
// end ; ComLinkTo ( vehicle , mech ) ;
69515: LD_VAR 0 1
69519: PPUSH
69520: LD_VAR 0 5
69524: PPUSH
69525: CALL_OW 135
// end ;
69529: LD_VAR 0 2
69533: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
69534: LD_INT 0
69536: PPUSH
69537: PPUSH
69538: PPUSH
69539: PPUSH
69540: PPUSH
69541: PPUSH
69542: PPUSH
69543: PPUSH
69544: PPUSH
69545: PPUSH
69546: PPUSH
69547: PPUSH
69548: PPUSH
// result := [ ] ;
69549: LD_ADDR_VAR 0 7
69553: PUSH
69554: EMPTY
69555: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
69556: LD_VAR 0 1
69560: PPUSH
69561: CALL_OW 266
69565: PUSH
69566: LD_INT 0
69568: PUSH
69569: LD_INT 1
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: IN
69576: NOT
69577: IFFALSE 69581
// exit ;
69579: GO 71215
// if name then
69581: LD_VAR 0 3
69585: IFFALSE 69601
// SetBName ( base_dep , name ) ;
69587: LD_VAR 0 1
69591: PPUSH
69592: LD_VAR 0 3
69596: PPUSH
69597: CALL_OW 500
// base := GetBase ( base_dep ) ;
69601: LD_ADDR_VAR 0 15
69605: PUSH
69606: LD_VAR 0 1
69610: PPUSH
69611: CALL_OW 274
69615: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
69616: LD_ADDR_VAR 0 16
69620: PUSH
69621: LD_VAR 0 1
69625: PPUSH
69626: CALL_OW 255
69630: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
69631: LD_ADDR_VAR 0 17
69635: PUSH
69636: LD_VAR 0 1
69640: PPUSH
69641: CALL_OW 248
69645: ST_TO_ADDR
// if sources then
69646: LD_VAR 0 5
69650: IFFALSE 69697
// for i = 1 to 3 do
69652: LD_ADDR_VAR 0 8
69656: PUSH
69657: DOUBLE
69658: LD_INT 1
69660: DEC
69661: ST_TO_ADDR
69662: LD_INT 3
69664: PUSH
69665: FOR_TO
69666: IFFALSE 69695
// AddResourceType ( base , i , sources [ i ] ) ;
69668: LD_VAR 0 15
69672: PPUSH
69673: LD_VAR 0 8
69677: PPUSH
69678: LD_VAR 0 5
69682: PUSH
69683: LD_VAR 0 8
69687: ARRAY
69688: PPUSH
69689: CALL_OW 276
69693: GO 69665
69695: POP
69696: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
69697: LD_ADDR_VAR 0 18
69701: PUSH
69702: LD_VAR 0 15
69706: PPUSH
69707: LD_VAR 0 2
69711: PPUSH
69712: LD_INT 1
69714: PPUSH
69715: CALL 68958 0 3
69719: ST_TO_ADDR
// InitHc ;
69720: CALL_OW 19
// InitUc ;
69724: CALL_OW 18
// uc_side := side ;
69728: LD_ADDR_OWVAR 20
69732: PUSH
69733: LD_VAR 0 16
69737: ST_TO_ADDR
// uc_nation := nation ;
69738: LD_ADDR_OWVAR 21
69742: PUSH
69743: LD_VAR 0 17
69747: ST_TO_ADDR
// if buildings then
69748: LD_VAR 0 18
69752: IFFALSE 71074
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
69754: LD_ADDR_VAR 0 19
69758: PUSH
69759: LD_VAR 0 18
69763: PPUSH
69764: LD_INT 2
69766: PUSH
69767: LD_INT 30
69769: PUSH
69770: LD_INT 29
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 30
69779: PUSH
69780: LD_INT 30
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: LIST
69791: PPUSH
69792: CALL_OW 72
69796: ST_TO_ADDR
// if tmp then
69797: LD_VAR 0 19
69801: IFFALSE 69849
// for i in tmp do
69803: LD_ADDR_VAR 0 8
69807: PUSH
69808: LD_VAR 0 19
69812: PUSH
69813: FOR_IN
69814: IFFALSE 69847
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69816: LD_VAR 0 8
69820: PPUSH
69821: CALL_OW 250
69825: PPUSH
69826: LD_VAR 0 8
69830: PPUSH
69831: CALL_OW 251
69835: PPUSH
69836: LD_VAR 0 16
69840: PPUSH
69841: CALL_OW 441
69845: GO 69813
69847: POP
69848: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69849: LD_VAR 0 18
69853: PPUSH
69854: LD_INT 2
69856: PUSH
69857: LD_INT 30
69859: PUSH
69860: LD_INT 32
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 30
69869: PUSH
69870: LD_INT 33
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: LIST
69881: PPUSH
69882: CALL_OW 72
69886: IFFALSE 69974
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69888: LD_ADDR_VAR 0 8
69892: PUSH
69893: LD_VAR 0 18
69897: PPUSH
69898: LD_INT 2
69900: PUSH
69901: LD_INT 30
69903: PUSH
69904: LD_INT 32
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 30
69913: PUSH
69914: LD_INT 33
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: LIST
69925: PPUSH
69926: CALL_OW 72
69930: PUSH
69931: FOR_IN
69932: IFFALSE 69972
// begin if not GetBWeapon ( i ) then
69934: LD_VAR 0 8
69938: PPUSH
69939: CALL_OW 269
69943: NOT
69944: IFFALSE 69970
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69946: LD_VAR 0 8
69950: PPUSH
69951: LD_VAR 0 8
69955: PPUSH
69956: LD_VAR 0 2
69960: PPUSH
69961: CALL 71220 0 2
69965: PPUSH
69966: CALL_OW 431
// end ;
69970: GO 69931
69972: POP
69973: POP
// end ; for i = 1 to personel do
69974: LD_ADDR_VAR 0 8
69978: PUSH
69979: DOUBLE
69980: LD_INT 1
69982: DEC
69983: ST_TO_ADDR
69984: LD_VAR 0 6
69988: PUSH
69989: FOR_TO
69990: IFFALSE 71054
// begin if i > 4 then
69992: LD_VAR 0 8
69996: PUSH
69997: LD_INT 4
69999: GREATER
70000: IFFALSE 70004
// break ;
70002: GO 71054
// case i of 1 :
70004: LD_VAR 0 8
70008: PUSH
70009: LD_INT 1
70011: DOUBLE
70012: EQUAL
70013: IFTRUE 70017
70015: GO 70097
70017: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
70018: LD_ADDR_VAR 0 12
70022: PUSH
70023: LD_VAR 0 18
70027: PPUSH
70028: LD_INT 22
70030: PUSH
70031: LD_VAR 0 16
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 58
70042: PUSH
70043: EMPTY
70044: LIST
70045: PUSH
70046: LD_INT 2
70048: PUSH
70049: LD_INT 30
70051: PUSH
70052: LD_INT 32
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 30
70061: PUSH
70062: LD_INT 4
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PUSH
70069: LD_INT 30
70071: PUSH
70072: LD_INT 5
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: LIST
70089: PPUSH
70090: CALL_OW 72
70094: ST_TO_ADDR
70095: GO 70319
70097: LD_INT 2
70099: DOUBLE
70100: EQUAL
70101: IFTRUE 70105
70103: GO 70167
70105: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
70106: LD_ADDR_VAR 0 12
70110: PUSH
70111: LD_VAR 0 18
70115: PPUSH
70116: LD_INT 22
70118: PUSH
70119: LD_VAR 0 16
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 2
70130: PUSH
70131: LD_INT 30
70133: PUSH
70134: LD_INT 0
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 30
70143: PUSH
70144: LD_INT 1
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: LIST
70155: PUSH
70156: EMPTY
70157: LIST
70158: LIST
70159: PPUSH
70160: CALL_OW 72
70164: ST_TO_ADDR
70165: GO 70319
70167: LD_INT 3
70169: DOUBLE
70170: EQUAL
70171: IFTRUE 70175
70173: GO 70237
70175: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
70176: LD_ADDR_VAR 0 12
70180: PUSH
70181: LD_VAR 0 18
70185: PPUSH
70186: LD_INT 22
70188: PUSH
70189: LD_VAR 0 16
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 2
70200: PUSH
70201: LD_INT 30
70203: PUSH
70204: LD_INT 2
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 30
70213: PUSH
70214: LD_INT 3
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: LIST
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PPUSH
70230: CALL_OW 72
70234: ST_TO_ADDR
70235: GO 70319
70237: LD_INT 4
70239: DOUBLE
70240: EQUAL
70241: IFTRUE 70245
70243: GO 70318
70245: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
70246: LD_ADDR_VAR 0 12
70250: PUSH
70251: LD_VAR 0 18
70255: PPUSH
70256: LD_INT 22
70258: PUSH
70259: LD_VAR 0 16
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: LD_INT 2
70270: PUSH
70271: LD_INT 30
70273: PUSH
70274: LD_INT 6
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 30
70283: PUSH
70284: LD_INT 7
70286: PUSH
70287: EMPTY
70288: LIST
70289: LIST
70290: PUSH
70291: LD_INT 30
70293: PUSH
70294: LD_INT 8
70296: PUSH
70297: EMPTY
70298: LIST
70299: LIST
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: PPUSH
70311: CALL_OW 72
70315: ST_TO_ADDR
70316: GO 70319
70318: POP
// if i = 1 then
70319: LD_VAR 0 8
70323: PUSH
70324: LD_INT 1
70326: EQUAL
70327: IFFALSE 70438
// begin tmp := [ ] ;
70329: LD_ADDR_VAR 0 19
70333: PUSH
70334: EMPTY
70335: ST_TO_ADDR
// for j in f do
70336: LD_ADDR_VAR 0 9
70340: PUSH
70341: LD_VAR 0 12
70345: PUSH
70346: FOR_IN
70347: IFFALSE 70420
// if GetBType ( j ) = b_bunker then
70349: LD_VAR 0 9
70353: PPUSH
70354: CALL_OW 266
70358: PUSH
70359: LD_INT 32
70361: EQUAL
70362: IFFALSE 70389
// tmp := Insert ( tmp , 1 , j ) else
70364: LD_ADDR_VAR 0 19
70368: PUSH
70369: LD_VAR 0 19
70373: PPUSH
70374: LD_INT 1
70376: PPUSH
70377: LD_VAR 0 9
70381: PPUSH
70382: CALL_OW 2
70386: ST_TO_ADDR
70387: GO 70418
// tmp := Insert ( tmp , tmp + 1 , j ) ;
70389: LD_ADDR_VAR 0 19
70393: PUSH
70394: LD_VAR 0 19
70398: PPUSH
70399: LD_VAR 0 19
70403: PUSH
70404: LD_INT 1
70406: PLUS
70407: PPUSH
70408: LD_VAR 0 9
70412: PPUSH
70413: CALL_OW 2
70417: ST_TO_ADDR
70418: GO 70346
70420: POP
70421: POP
// if tmp then
70422: LD_VAR 0 19
70426: IFFALSE 70438
// f := tmp ;
70428: LD_ADDR_VAR 0 12
70432: PUSH
70433: LD_VAR 0 19
70437: ST_TO_ADDR
// end ; x := personel [ i ] ;
70438: LD_ADDR_VAR 0 13
70442: PUSH
70443: LD_VAR 0 6
70447: PUSH
70448: LD_VAR 0 8
70452: ARRAY
70453: ST_TO_ADDR
// if x = - 1 then
70454: LD_VAR 0 13
70458: PUSH
70459: LD_INT 1
70461: NEG
70462: EQUAL
70463: IFFALSE 70672
// begin for j in f do
70465: LD_ADDR_VAR 0 9
70469: PUSH
70470: LD_VAR 0 12
70474: PUSH
70475: FOR_IN
70476: IFFALSE 70668
// repeat InitHc ;
70478: CALL_OW 19
// if GetBType ( j ) = b_barracks then
70482: LD_VAR 0 9
70486: PPUSH
70487: CALL_OW 266
70491: PUSH
70492: LD_INT 5
70494: EQUAL
70495: IFFALSE 70565
// begin if UnitsInside ( j ) < 3 then
70497: LD_VAR 0 9
70501: PPUSH
70502: CALL_OW 313
70506: PUSH
70507: LD_INT 3
70509: LESS
70510: IFFALSE 70546
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70512: LD_INT 0
70514: PPUSH
70515: LD_INT 5
70517: PUSH
70518: LD_INT 8
70520: PUSH
70521: LD_INT 9
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: LIST
70528: PUSH
70529: LD_VAR 0 17
70533: ARRAY
70534: PPUSH
70535: LD_VAR 0 4
70539: PPUSH
70540: CALL_OW 380
70544: GO 70563
// PrepareHuman ( false , i , skill ) ;
70546: LD_INT 0
70548: PPUSH
70549: LD_VAR 0 8
70553: PPUSH
70554: LD_VAR 0 4
70558: PPUSH
70559: CALL_OW 380
// end else
70563: GO 70582
// PrepareHuman ( false , i , skill ) ;
70565: LD_INT 0
70567: PPUSH
70568: LD_VAR 0 8
70572: PPUSH
70573: LD_VAR 0 4
70577: PPUSH
70578: CALL_OW 380
// un := CreateHuman ;
70582: LD_ADDR_VAR 0 14
70586: PUSH
70587: CALL_OW 44
70591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70592: LD_ADDR_VAR 0 7
70596: PUSH
70597: LD_VAR 0 7
70601: PPUSH
70602: LD_INT 1
70604: PPUSH
70605: LD_VAR 0 14
70609: PPUSH
70610: CALL_OW 2
70614: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
70615: LD_VAR 0 14
70619: PPUSH
70620: LD_VAR 0 9
70624: PPUSH
70625: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
70629: LD_VAR 0 9
70633: PPUSH
70634: CALL_OW 313
70638: PUSH
70639: LD_INT 6
70641: EQUAL
70642: PUSH
70643: LD_VAR 0 9
70647: PPUSH
70648: CALL_OW 266
70652: PUSH
70653: LD_INT 32
70655: PUSH
70656: LD_INT 31
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: IN
70663: OR
70664: IFFALSE 70478
70666: GO 70475
70668: POP
70669: POP
// end else
70670: GO 71052
// for j = 1 to x do
70672: LD_ADDR_VAR 0 9
70676: PUSH
70677: DOUBLE
70678: LD_INT 1
70680: DEC
70681: ST_TO_ADDR
70682: LD_VAR 0 13
70686: PUSH
70687: FOR_TO
70688: IFFALSE 71050
// begin InitHc ;
70690: CALL_OW 19
// if not f then
70694: LD_VAR 0 12
70698: NOT
70699: IFFALSE 70788
// begin PrepareHuman ( false , i , skill ) ;
70701: LD_INT 0
70703: PPUSH
70704: LD_VAR 0 8
70708: PPUSH
70709: LD_VAR 0 4
70713: PPUSH
70714: CALL_OW 380
// un := CreateHuman ;
70718: LD_ADDR_VAR 0 14
70722: PUSH
70723: CALL_OW 44
70727: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70728: LD_ADDR_VAR 0 7
70732: PUSH
70733: LD_VAR 0 7
70737: PPUSH
70738: LD_INT 1
70740: PPUSH
70741: LD_VAR 0 14
70745: PPUSH
70746: CALL_OW 2
70750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70751: LD_VAR 0 14
70755: PPUSH
70756: LD_VAR 0 1
70760: PPUSH
70761: CALL_OW 250
70765: PPUSH
70766: LD_VAR 0 1
70770: PPUSH
70771: CALL_OW 251
70775: PPUSH
70776: LD_INT 10
70778: PPUSH
70779: LD_INT 0
70781: PPUSH
70782: CALL_OW 50
// continue ;
70786: GO 70687
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70788: LD_VAR 0 12
70792: PUSH
70793: LD_INT 1
70795: ARRAY
70796: PPUSH
70797: CALL_OW 313
70801: PUSH
70802: LD_VAR 0 12
70806: PUSH
70807: LD_INT 1
70809: ARRAY
70810: PPUSH
70811: CALL_OW 266
70815: PUSH
70816: LD_INT 32
70818: PUSH
70819: LD_INT 31
70821: PUSH
70822: EMPTY
70823: LIST
70824: LIST
70825: IN
70826: AND
70827: PUSH
70828: LD_VAR 0 12
70832: PUSH
70833: LD_INT 1
70835: ARRAY
70836: PPUSH
70837: CALL_OW 313
70841: PUSH
70842: LD_INT 6
70844: EQUAL
70845: OR
70846: IFFALSE 70866
// f := Delete ( f , 1 ) ;
70848: LD_ADDR_VAR 0 12
70852: PUSH
70853: LD_VAR 0 12
70857: PPUSH
70858: LD_INT 1
70860: PPUSH
70861: CALL_OW 3
70865: ST_TO_ADDR
// if not f then
70866: LD_VAR 0 12
70870: NOT
70871: IFFALSE 70889
// begin x := x + 2 ;
70873: LD_ADDR_VAR 0 13
70877: PUSH
70878: LD_VAR 0 13
70882: PUSH
70883: LD_INT 2
70885: PLUS
70886: ST_TO_ADDR
// continue ;
70887: GO 70687
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70889: LD_VAR 0 12
70893: PUSH
70894: LD_INT 1
70896: ARRAY
70897: PPUSH
70898: CALL_OW 266
70902: PUSH
70903: LD_INT 5
70905: EQUAL
70906: IFFALSE 70980
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70908: LD_VAR 0 12
70912: PUSH
70913: LD_INT 1
70915: ARRAY
70916: PPUSH
70917: CALL_OW 313
70921: PUSH
70922: LD_INT 3
70924: LESS
70925: IFFALSE 70961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70927: LD_INT 0
70929: PPUSH
70930: LD_INT 5
70932: PUSH
70933: LD_INT 8
70935: PUSH
70936: LD_INT 9
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: LIST
70943: PUSH
70944: LD_VAR 0 17
70948: ARRAY
70949: PPUSH
70950: LD_VAR 0 4
70954: PPUSH
70955: CALL_OW 380
70959: GO 70978
// PrepareHuman ( false , i , skill ) ;
70961: LD_INT 0
70963: PPUSH
70964: LD_VAR 0 8
70968: PPUSH
70969: LD_VAR 0 4
70973: PPUSH
70974: CALL_OW 380
// end else
70978: GO 70997
// PrepareHuman ( false , i , skill ) ;
70980: LD_INT 0
70982: PPUSH
70983: LD_VAR 0 8
70987: PPUSH
70988: LD_VAR 0 4
70992: PPUSH
70993: CALL_OW 380
// un := CreateHuman ;
70997: LD_ADDR_VAR 0 14
71001: PUSH
71002: CALL_OW 44
71006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
71007: LD_ADDR_VAR 0 7
71011: PUSH
71012: LD_VAR 0 7
71016: PPUSH
71017: LD_INT 1
71019: PPUSH
71020: LD_VAR 0 14
71024: PPUSH
71025: CALL_OW 2
71029: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
71030: LD_VAR 0 14
71034: PPUSH
71035: LD_VAR 0 12
71039: PUSH
71040: LD_INT 1
71042: ARRAY
71043: PPUSH
71044: CALL_OW 52
// end ;
71048: GO 70687
71050: POP
71051: POP
// end ;
71052: GO 69989
71054: POP
71055: POP
// result := result ^ buildings ;
71056: LD_ADDR_VAR 0 7
71060: PUSH
71061: LD_VAR 0 7
71065: PUSH
71066: LD_VAR 0 18
71070: ADD
71071: ST_TO_ADDR
// end else
71072: GO 71215
// begin for i = 1 to personel do
71074: LD_ADDR_VAR 0 8
71078: PUSH
71079: DOUBLE
71080: LD_INT 1
71082: DEC
71083: ST_TO_ADDR
71084: LD_VAR 0 6
71088: PUSH
71089: FOR_TO
71090: IFFALSE 71213
// begin if i > 4 then
71092: LD_VAR 0 8
71096: PUSH
71097: LD_INT 4
71099: GREATER
71100: IFFALSE 71104
// break ;
71102: GO 71213
// x := personel [ i ] ;
71104: LD_ADDR_VAR 0 13
71108: PUSH
71109: LD_VAR 0 6
71113: PUSH
71114: LD_VAR 0 8
71118: ARRAY
71119: ST_TO_ADDR
// if x = - 1 then
71120: LD_VAR 0 13
71124: PUSH
71125: LD_INT 1
71127: NEG
71128: EQUAL
71129: IFFALSE 71133
// continue ;
71131: GO 71089
// PrepareHuman ( false , i , skill ) ;
71133: LD_INT 0
71135: PPUSH
71136: LD_VAR 0 8
71140: PPUSH
71141: LD_VAR 0 4
71145: PPUSH
71146: CALL_OW 380
// un := CreateHuman ;
71150: LD_ADDR_VAR 0 14
71154: PUSH
71155: CALL_OW 44
71159: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
71160: LD_VAR 0 14
71164: PPUSH
71165: LD_VAR 0 1
71169: PPUSH
71170: CALL_OW 250
71174: PPUSH
71175: LD_VAR 0 1
71179: PPUSH
71180: CALL_OW 251
71184: PPUSH
71185: LD_INT 10
71187: PPUSH
71188: LD_INT 0
71190: PPUSH
71191: CALL_OW 50
// result := result ^ un ;
71195: LD_ADDR_VAR 0 7
71199: PUSH
71200: LD_VAR 0 7
71204: PUSH
71205: LD_VAR 0 14
71209: ADD
71210: ST_TO_ADDR
// end ;
71211: GO 71089
71213: POP
71214: POP
// end ; end ;
71215: LD_VAR 0 7
71219: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
71220: LD_INT 0
71222: PPUSH
71223: PPUSH
71224: PPUSH
71225: PPUSH
71226: PPUSH
71227: PPUSH
71228: PPUSH
71229: PPUSH
71230: PPUSH
71231: PPUSH
71232: PPUSH
71233: PPUSH
71234: PPUSH
71235: PPUSH
71236: PPUSH
71237: PPUSH
// result := false ;
71238: LD_ADDR_VAR 0 3
71242: PUSH
71243: LD_INT 0
71245: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
71246: LD_VAR 0 1
71250: NOT
71251: PUSH
71252: LD_VAR 0 1
71256: PPUSH
71257: CALL_OW 266
71261: PUSH
71262: LD_INT 32
71264: PUSH
71265: LD_INT 33
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: IN
71272: NOT
71273: OR
71274: IFFALSE 71278
// exit ;
71276: GO 72387
// nat := GetNation ( tower ) ;
71278: LD_ADDR_VAR 0 12
71282: PUSH
71283: LD_VAR 0 1
71287: PPUSH
71288: CALL_OW 248
71292: ST_TO_ADDR
// side := GetSide ( tower ) ;
71293: LD_ADDR_VAR 0 16
71297: PUSH
71298: LD_VAR 0 1
71302: PPUSH
71303: CALL_OW 255
71307: ST_TO_ADDR
// x := GetX ( tower ) ;
71308: LD_ADDR_VAR 0 10
71312: PUSH
71313: LD_VAR 0 1
71317: PPUSH
71318: CALL_OW 250
71322: ST_TO_ADDR
// y := GetY ( tower ) ;
71323: LD_ADDR_VAR 0 11
71327: PUSH
71328: LD_VAR 0 1
71332: PPUSH
71333: CALL_OW 251
71337: ST_TO_ADDR
// if not x or not y then
71338: LD_VAR 0 10
71342: NOT
71343: PUSH
71344: LD_VAR 0 11
71348: NOT
71349: OR
71350: IFFALSE 71354
// exit ;
71352: GO 72387
// weapon := 0 ;
71354: LD_ADDR_VAR 0 18
71358: PUSH
71359: LD_INT 0
71361: ST_TO_ADDR
// fac_list := [ ] ;
71362: LD_ADDR_VAR 0 17
71366: PUSH
71367: EMPTY
71368: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
71369: LD_ADDR_VAR 0 6
71373: PUSH
71374: LD_VAR 0 1
71378: PPUSH
71379: CALL_OW 274
71383: PPUSH
71384: LD_VAR 0 2
71388: PPUSH
71389: LD_INT 0
71391: PPUSH
71392: CALL 68958 0 3
71396: PPUSH
71397: LD_INT 30
71399: PUSH
71400: LD_INT 3
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PPUSH
71407: CALL_OW 72
71411: ST_TO_ADDR
// if not factories then
71412: LD_VAR 0 6
71416: NOT
71417: IFFALSE 71421
// exit ;
71419: GO 72387
// for i in factories do
71421: LD_ADDR_VAR 0 8
71425: PUSH
71426: LD_VAR 0 6
71430: PUSH
71431: FOR_IN
71432: IFFALSE 71457
// fac_list := fac_list union AvailableWeaponList ( i ) ;
71434: LD_ADDR_VAR 0 17
71438: PUSH
71439: LD_VAR 0 17
71443: PUSH
71444: LD_VAR 0 8
71448: PPUSH
71449: CALL_OW 478
71453: UNION
71454: ST_TO_ADDR
71455: GO 71431
71457: POP
71458: POP
// if not fac_list then
71459: LD_VAR 0 17
71463: NOT
71464: IFFALSE 71468
// exit ;
71466: GO 72387
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
71468: LD_ADDR_VAR 0 5
71472: PUSH
71473: LD_INT 4
71475: PUSH
71476: LD_INT 5
71478: PUSH
71479: LD_INT 9
71481: PUSH
71482: LD_INT 10
71484: PUSH
71485: LD_INT 6
71487: PUSH
71488: LD_INT 7
71490: PUSH
71491: LD_INT 11
71493: PUSH
71494: EMPTY
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 27
71505: PUSH
71506: LD_INT 28
71508: PUSH
71509: LD_INT 26
71511: PUSH
71512: LD_INT 30
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 43
71523: PUSH
71524: LD_INT 44
71526: PUSH
71527: LD_INT 46
71529: PUSH
71530: LD_INT 45
71532: PUSH
71533: LD_INT 47
71535: PUSH
71536: LD_INT 49
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: LIST
71551: PUSH
71552: LD_VAR 0 12
71556: ARRAY
71557: ST_TO_ADDR
// list := list isect fac_list ;
71558: LD_ADDR_VAR 0 5
71562: PUSH
71563: LD_VAR 0 5
71567: PUSH
71568: LD_VAR 0 17
71572: ISECT
71573: ST_TO_ADDR
// if not list then
71574: LD_VAR 0 5
71578: NOT
71579: IFFALSE 71583
// exit ;
71581: GO 72387
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
71583: LD_VAR 0 12
71587: PUSH
71588: LD_INT 3
71590: EQUAL
71591: PUSH
71592: LD_INT 49
71594: PUSH
71595: LD_VAR 0 5
71599: IN
71600: AND
71601: PUSH
71602: LD_INT 31
71604: PPUSH
71605: LD_VAR 0 16
71609: PPUSH
71610: CALL_OW 321
71614: PUSH
71615: LD_INT 2
71617: EQUAL
71618: AND
71619: IFFALSE 71679
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
71621: LD_INT 22
71623: PUSH
71624: LD_VAR 0 16
71628: PUSH
71629: EMPTY
71630: LIST
71631: LIST
71632: PUSH
71633: LD_INT 35
71635: PUSH
71636: LD_INT 49
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PUSH
71643: LD_INT 91
71645: PUSH
71646: LD_VAR 0 1
71650: PUSH
71651: LD_INT 10
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: LIST
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: LIST
71663: PPUSH
71664: CALL_OW 69
71668: NOT
71669: IFFALSE 71679
// weapon := ru_time_lapser ;
71671: LD_ADDR_VAR 0 18
71675: PUSH
71676: LD_INT 49
71678: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
71679: LD_VAR 0 12
71683: PUSH
71684: LD_INT 1
71686: PUSH
71687: LD_INT 2
71689: PUSH
71690: EMPTY
71691: LIST
71692: LIST
71693: IN
71694: PUSH
71695: LD_INT 11
71697: PUSH
71698: LD_VAR 0 5
71702: IN
71703: PUSH
71704: LD_INT 30
71706: PUSH
71707: LD_VAR 0 5
71711: IN
71712: OR
71713: AND
71714: PUSH
71715: LD_INT 6
71717: PPUSH
71718: LD_VAR 0 16
71722: PPUSH
71723: CALL_OW 321
71727: PUSH
71728: LD_INT 2
71730: EQUAL
71731: AND
71732: IFFALSE 71897
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71734: LD_INT 22
71736: PUSH
71737: LD_VAR 0 16
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: PUSH
71746: LD_INT 2
71748: PUSH
71749: LD_INT 35
71751: PUSH
71752: LD_INT 11
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 35
71761: PUSH
71762: LD_INT 30
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 91
71776: PUSH
71777: LD_VAR 0 1
71781: PUSH
71782: LD_INT 18
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: LIST
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: LIST
71794: PPUSH
71795: CALL_OW 69
71799: NOT
71800: PUSH
71801: LD_INT 22
71803: PUSH
71804: LD_VAR 0 16
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 2
71815: PUSH
71816: LD_INT 30
71818: PUSH
71819: LD_INT 32
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 30
71828: PUSH
71829: LD_INT 33
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 91
71843: PUSH
71844: LD_VAR 0 1
71848: PUSH
71849: LD_INT 12
71851: PUSH
71852: EMPTY
71853: LIST
71854: LIST
71855: LIST
71856: PUSH
71857: EMPTY
71858: LIST
71859: LIST
71860: LIST
71861: PUSH
71862: EMPTY
71863: LIST
71864: PPUSH
71865: CALL_OW 69
71869: PUSH
71870: LD_INT 2
71872: GREATER
71873: AND
71874: IFFALSE 71897
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71876: LD_ADDR_VAR 0 18
71880: PUSH
71881: LD_INT 11
71883: PUSH
71884: LD_INT 30
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_VAR 0 12
71895: ARRAY
71896: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71897: LD_VAR 0 18
71901: NOT
71902: PUSH
71903: LD_INT 40
71905: PPUSH
71906: LD_VAR 0 16
71910: PPUSH
71911: CALL_OW 321
71915: PUSH
71916: LD_INT 2
71918: EQUAL
71919: AND
71920: PUSH
71921: LD_INT 7
71923: PUSH
71924: LD_VAR 0 5
71928: IN
71929: PUSH
71930: LD_INT 28
71932: PUSH
71933: LD_VAR 0 5
71937: IN
71938: OR
71939: PUSH
71940: LD_INT 45
71942: PUSH
71943: LD_VAR 0 5
71947: IN
71948: OR
71949: AND
71950: IFFALSE 72204
// begin hex := GetHexInfo ( x , y ) ;
71952: LD_ADDR_VAR 0 4
71956: PUSH
71957: LD_VAR 0 10
71961: PPUSH
71962: LD_VAR 0 11
71966: PPUSH
71967: CALL_OW 546
71971: ST_TO_ADDR
// if hex [ 1 ] then
71972: LD_VAR 0 4
71976: PUSH
71977: LD_INT 1
71979: ARRAY
71980: IFFALSE 71984
// exit ;
71982: GO 72387
// height := hex [ 2 ] ;
71984: LD_ADDR_VAR 0 15
71988: PUSH
71989: LD_VAR 0 4
71993: PUSH
71994: LD_INT 2
71996: ARRAY
71997: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71998: LD_ADDR_VAR 0 14
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 2
72008: PUSH
72009: LD_INT 3
72011: PUSH
72012: LD_INT 5
72014: PUSH
72015: EMPTY
72016: LIST
72017: LIST
72018: LIST
72019: LIST
72020: ST_TO_ADDR
// for i in tmp do
72021: LD_ADDR_VAR 0 8
72025: PUSH
72026: LD_VAR 0 14
72030: PUSH
72031: FOR_IN
72032: IFFALSE 72202
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
72034: LD_ADDR_VAR 0 9
72038: PUSH
72039: LD_VAR 0 10
72043: PPUSH
72044: LD_VAR 0 8
72048: PPUSH
72049: LD_INT 5
72051: PPUSH
72052: CALL_OW 272
72056: PUSH
72057: LD_VAR 0 11
72061: PPUSH
72062: LD_VAR 0 8
72066: PPUSH
72067: LD_INT 5
72069: PPUSH
72070: CALL_OW 273
72074: PUSH
72075: EMPTY
72076: LIST
72077: LIST
72078: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
72079: LD_VAR 0 9
72083: PUSH
72084: LD_INT 1
72086: ARRAY
72087: PPUSH
72088: LD_VAR 0 9
72092: PUSH
72093: LD_INT 2
72095: ARRAY
72096: PPUSH
72097: CALL_OW 488
72101: IFFALSE 72200
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
72103: LD_ADDR_VAR 0 4
72107: PUSH
72108: LD_VAR 0 9
72112: PUSH
72113: LD_INT 1
72115: ARRAY
72116: PPUSH
72117: LD_VAR 0 9
72121: PUSH
72122: LD_INT 2
72124: ARRAY
72125: PPUSH
72126: CALL_OW 546
72130: ST_TO_ADDR
// if hex [ 1 ] then
72131: LD_VAR 0 4
72135: PUSH
72136: LD_INT 1
72138: ARRAY
72139: IFFALSE 72143
// continue ;
72141: GO 72031
// h := hex [ 2 ] ;
72143: LD_ADDR_VAR 0 13
72147: PUSH
72148: LD_VAR 0 4
72152: PUSH
72153: LD_INT 2
72155: ARRAY
72156: ST_TO_ADDR
// if h + 7 < height then
72157: LD_VAR 0 13
72161: PUSH
72162: LD_INT 7
72164: PLUS
72165: PUSH
72166: LD_VAR 0 15
72170: LESS
72171: IFFALSE 72200
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
72173: LD_ADDR_VAR 0 18
72177: PUSH
72178: LD_INT 7
72180: PUSH
72181: LD_INT 28
72183: PUSH
72184: LD_INT 45
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: LIST
72191: PUSH
72192: LD_VAR 0 12
72196: ARRAY
72197: ST_TO_ADDR
// break ;
72198: GO 72202
// end ; end ; end ;
72200: GO 72031
72202: POP
72203: POP
// end ; if not weapon then
72204: LD_VAR 0 18
72208: NOT
72209: IFFALSE 72269
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
72211: LD_ADDR_VAR 0 5
72215: PUSH
72216: LD_VAR 0 5
72220: PUSH
72221: LD_INT 11
72223: PUSH
72224: LD_INT 30
72226: PUSH
72227: LD_INT 49
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: LIST
72234: DIFF
72235: ST_TO_ADDR
// if not list then
72236: LD_VAR 0 5
72240: NOT
72241: IFFALSE 72245
// exit ;
72243: GO 72387
// weapon := list [ rand ( 1 , list ) ] ;
72245: LD_ADDR_VAR 0 18
72249: PUSH
72250: LD_VAR 0 5
72254: PUSH
72255: LD_INT 1
72257: PPUSH
72258: LD_VAR 0 5
72262: PPUSH
72263: CALL_OW 12
72267: ARRAY
72268: ST_TO_ADDR
// end ; if weapon then
72269: LD_VAR 0 18
72273: IFFALSE 72387
// begin tmp := CostOfWeapon ( weapon ) ;
72275: LD_ADDR_VAR 0 14
72279: PUSH
72280: LD_VAR 0 18
72284: PPUSH
72285: CALL_OW 451
72289: ST_TO_ADDR
// j := GetBase ( tower ) ;
72290: LD_ADDR_VAR 0 9
72294: PUSH
72295: LD_VAR 0 1
72299: PPUSH
72300: CALL_OW 274
72304: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
72305: LD_VAR 0 9
72309: PPUSH
72310: LD_INT 1
72312: PPUSH
72313: CALL_OW 275
72317: PUSH
72318: LD_VAR 0 14
72322: PUSH
72323: LD_INT 1
72325: ARRAY
72326: GREATEREQUAL
72327: PUSH
72328: LD_VAR 0 9
72332: PPUSH
72333: LD_INT 2
72335: PPUSH
72336: CALL_OW 275
72340: PUSH
72341: LD_VAR 0 14
72345: PUSH
72346: LD_INT 2
72348: ARRAY
72349: GREATEREQUAL
72350: AND
72351: PUSH
72352: LD_VAR 0 9
72356: PPUSH
72357: LD_INT 3
72359: PPUSH
72360: CALL_OW 275
72364: PUSH
72365: LD_VAR 0 14
72369: PUSH
72370: LD_INT 3
72372: ARRAY
72373: GREATEREQUAL
72374: AND
72375: IFFALSE 72387
// result := weapon ;
72377: LD_ADDR_VAR 0 3
72381: PUSH
72382: LD_VAR 0 18
72386: ST_TO_ADDR
// end ; end ;
72387: LD_VAR 0 3
72391: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
72392: LD_INT 0
72394: PPUSH
72395: PPUSH
// result := true ;
72396: LD_ADDR_VAR 0 3
72400: PUSH
72401: LD_INT 1
72403: ST_TO_ADDR
// if array1 = array2 then
72404: LD_VAR 0 1
72408: PUSH
72409: LD_VAR 0 2
72413: EQUAL
72414: IFFALSE 72474
// begin for i = 1 to array1 do
72416: LD_ADDR_VAR 0 4
72420: PUSH
72421: DOUBLE
72422: LD_INT 1
72424: DEC
72425: ST_TO_ADDR
72426: LD_VAR 0 1
72430: PUSH
72431: FOR_TO
72432: IFFALSE 72470
// if array1 [ i ] <> array2 [ i ] then
72434: LD_VAR 0 1
72438: PUSH
72439: LD_VAR 0 4
72443: ARRAY
72444: PUSH
72445: LD_VAR 0 2
72449: PUSH
72450: LD_VAR 0 4
72454: ARRAY
72455: NONEQUAL
72456: IFFALSE 72468
// begin result := false ;
72458: LD_ADDR_VAR 0 3
72462: PUSH
72463: LD_INT 0
72465: ST_TO_ADDR
// break ;
72466: GO 72470
// end ;
72468: GO 72431
72470: POP
72471: POP
// end else
72472: GO 72482
// result := false ;
72474: LD_ADDR_VAR 0 3
72478: PUSH
72479: LD_INT 0
72481: ST_TO_ADDR
// end ;
72482: LD_VAR 0 3
72486: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
72487: LD_INT 0
72489: PPUSH
72490: PPUSH
// if not array1 or not array2 then
72491: LD_VAR 0 1
72495: NOT
72496: PUSH
72497: LD_VAR 0 2
72501: NOT
72502: OR
72503: IFFALSE 72507
// exit ;
72505: GO 72571
// result := true ;
72507: LD_ADDR_VAR 0 3
72511: PUSH
72512: LD_INT 1
72514: ST_TO_ADDR
// for i = 1 to array1 do
72515: LD_ADDR_VAR 0 4
72519: PUSH
72520: DOUBLE
72521: LD_INT 1
72523: DEC
72524: ST_TO_ADDR
72525: LD_VAR 0 1
72529: PUSH
72530: FOR_TO
72531: IFFALSE 72569
// if array1 [ i ] <> array2 [ i ] then
72533: LD_VAR 0 1
72537: PUSH
72538: LD_VAR 0 4
72542: ARRAY
72543: PUSH
72544: LD_VAR 0 2
72548: PUSH
72549: LD_VAR 0 4
72553: ARRAY
72554: NONEQUAL
72555: IFFALSE 72567
// begin result := false ;
72557: LD_ADDR_VAR 0 3
72561: PUSH
72562: LD_INT 0
72564: ST_TO_ADDR
// break ;
72565: GO 72569
// end ;
72567: GO 72530
72569: POP
72570: POP
// end ;
72571: LD_VAR 0 3
72575: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
72576: LD_INT 0
72578: PPUSH
72579: PPUSH
72580: PPUSH
// pom := GetBase ( fac ) ;
72581: LD_ADDR_VAR 0 5
72585: PUSH
72586: LD_VAR 0 1
72590: PPUSH
72591: CALL_OW 274
72595: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
72596: LD_ADDR_VAR 0 4
72600: PUSH
72601: LD_VAR 0 2
72605: PUSH
72606: LD_INT 1
72608: ARRAY
72609: PPUSH
72610: LD_VAR 0 2
72614: PUSH
72615: LD_INT 2
72617: ARRAY
72618: PPUSH
72619: LD_VAR 0 2
72623: PUSH
72624: LD_INT 3
72626: ARRAY
72627: PPUSH
72628: LD_VAR 0 2
72632: PUSH
72633: LD_INT 4
72635: ARRAY
72636: PPUSH
72637: CALL_OW 449
72641: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72642: LD_ADDR_VAR 0 3
72646: PUSH
72647: LD_VAR 0 5
72651: PPUSH
72652: LD_INT 1
72654: PPUSH
72655: CALL_OW 275
72659: PUSH
72660: LD_VAR 0 4
72664: PUSH
72665: LD_INT 1
72667: ARRAY
72668: GREATEREQUAL
72669: PUSH
72670: LD_VAR 0 5
72674: PPUSH
72675: LD_INT 2
72677: PPUSH
72678: CALL_OW 275
72682: PUSH
72683: LD_VAR 0 4
72687: PUSH
72688: LD_INT 2
72690: ARRAY
72691: GREATEREQUAL
72692: AND
72693: PUSH
72694: LD_VAR 0 5
72698: PPUSH
72699: LD_INT 3
72701: PPUSH
72702: CALL_OW 275
72706: PUSH
72707: LD_VAR 0 4
72711: PUSH
72712: LD_INT 3
72714: ARRAY
72715: GREATEREQUAL
72716: AND
72717: ST_TO_ADDR
// end ;
72718: LD_VAR 0 3
72722: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
72723: LD_INT 0
72725: PPUSH
72726: PPUSH
72727: PPUSH
72728: PPUSH
// pom := GetBase ( building ) ;
72729: LD_ADDR_VAR 0 3
72733: PUSH
72734: LD_VAR 0 1
72738: PPUSH
72739: CALL_OW 274
72743: ST_TO_ADDR
// if not pom then
72744: LD_VAR 0 3
72748: NOT
72749: IFFALSE 72753
// exit ;
72751: GO 72923
// btype := GetBType ( building ) ;
72753: LD_ADDR_VAR 0 5
72757: PUSH
72758: LD_VAR 0 1
72762: PPUSH
72763: CALL_OW 266
72767: ST_TO_ADDR
// if btype = b_armoury then
72768: LD_VAR 0 5
72772: PUSH
72773: LD_INT 4
72775: EQUAL
72776: IFFALSE 72786
// btype := b_barracks ;
72778: LD_ADDR_VAR 0 5
72782: PUSH
72783: LD_INT 5
72785: ST_TO_ADDR
// if btype = b_depot then
72786: LD_VAR 0 5
72790: PUSH
72791: LD_INT 0
72793: EQUAL
72794: IFFALSE 72804
// btype := b_warehouse ;
72796: LD_ADDR_VAR 0 5
72800: PUSH
72801: LD_INT 1
72803: ST_TO_ADDR
// if btype = b_workshop then
72804: LD_VAR 0 5
72808: PUSH
72809: LD_INT 2
72811: EQUAL
72812: IFFALSE 72822
// btype := b_factory ;
72814: LD_ADDR_VAR 0 5
72818: PUSH
72819: LD_INT 3
72821: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72822: LD_ADDR_VAR 0 4
72826: PUSH
72827: LD_VAR 0 5
72831: PPUSH
72832: LD_VAR 0 1
72836: PPUSH
72837: CALL_OW 248
72841: PPUSH
72842: CALL_OW 450
72846: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72847: LD_ADDR_VAR 0 2
72851: PUSH
72852: LD_VAR 0 3
72856: PPUSH
72857: LD_INT 1
72859: PPUSH
72860: CALL_OW 275
72864: PUSH
72865: LD_VAR 0 4
72869: PUSH
72870: LD_INT 1
72872: ARRAY
72873: GREATEREQUAL
72874: PUSH
72875: LD_VAR 0 3
72879: PPUSH
72880: LD_INT 2
72882: PPUSH
72883: CALL_OW 275
72887: PUSH
72888: LD_VAR 0 4
72892: PUSH
72893: LD_INT 2
72895: ARRAY
72896: GREATEREQUAL
72897: AND
72898: PUSH
72899: LD_VAR 0 3
72903: PPUSH
72904: LD_INT 3
72906: PPUSH
72907: CALL_OW 275
72911: PUSH
72912: LD_VAR 0 4
72916: PUSH
72917: LD_INT 3
72919: ARRAY
72920: GREATEREQUAL
72921: AND
72922: ST_TO_ADDR
// end ;
72923: LD_VAR 0 2
72927: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72928: LD_INT 0
72930: PPUSH
72931: PPUSH
72932: PPUSH
// pom := GetBase ( building ) ;
72933: LD_ADDR_VAR 0 4
72937: PUSH
72938: LD_VAR 0 1
72942: PPUSH
72943: CALL_OW 274
72947: ST_TO_ADDR
// if not pom then
72948: LD_VAR 0 4
72952: NOT
72953: IFFALSE 72957
// exit ;
72955: GO 73058
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72957: LD_ADDR_VAR 0 5
72961: PUSH
72962: LD_VAR 0 2
72966: PPUSH
72967: LD_VAR 0 1
72971: PPUSH
72972: CALL_OW 248
72976: PPUSH
72977: CALL_OW 450
72981: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72982: LD_ADDR_VAR 0 3
72986: PUSH
72987: LD_VAR 0 4
72991: PPUSH
72992: LD_INT 1
72994: PPUSH
72995: CALL_OW 275
72999: PUSH
73000: LD_VAR 0 5
73004: PUSH
73005: LD_INT 1
73007: ARRAY
73008: GREATEREQUAL
73009: PUSH
73010: LD_VAR 0 4
73014: PPUSH
73015: LD_INT 2
73017: PPUSH
73018: CALL_OW 275
73022: PUSH
73023: LD_VAR 0 5
73027: PUSH
73028: LD_INT 2
73030: ARRAY
73031: GREATEREQUAL
73032: AND
73033: PUSH
73034: LD_VAR 0 4
73038: PPUSH
73039: LD_INT 3
73041: PPUSH
73042: CALL_OW 275
73046: PUSH
73047: LD_VAR 0 5
73051: PUSH
73052: LD_INT 3
73054: ARRAY
73055: GREATEREQUAL
73056: AND
73057: ST_TO_ADDR
// end ;
73058: LD_VAR 0 3
73062: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
73063: LD_INT 0
73065: PPUSH
73066: PPUSH
73067: PPUSH
73068: PPUSH
73069: PPUSH
73070: PPUSH
73071: PPUSH
73072: PPUSH
73073: PPUSH
73074: PPUSH
73075: PPUSH
// result := false ;
73076: LD_ADDR_VAR 0 8
73080: PUSH
73081: LD_INT 0
73083: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
73084: LD_VAR 0 5
73088: NOT
73089: PUSH
73090: LD_VAR 0 1
73094: NOT
73095: OR
73096: PUSH
73097: LD_VAR 0 2
73101: NOT
73102: OR
73103: PUSH
73104: LD_VAR 0 3
73108: NOT
73109: OR
73110: IFFALSE 73114
// exit ;
73112: GO 73928
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
73114: LD_ADDR_VAR 0 14
73118: PUSH
73119: LD_VAR 0 1
73123: PPUSH
73124: LD_VAR 0 2
73128: PPUSH
73129: LD_VAR 0 3
73133: PPUSH
73134: LD_VAR 0 4
73138: PPUSH
73139: LD_VAR 0 5
73143: PUSH
73144: LD_INT 1
73146: ARRAY
73147: PPUSH
73148: CALL_OW 248
73152: PPUSH
73153: LD_INT 0
73155: PPUSH
73156: CALL 75165 0 6
73160: ST_TO_ADDR
// if not hexes then
73161: LD_VAR 0 14
73165: NOT
73166: IFFALSE 73170
// exit ;
73168: GO 73928
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73170: LD_ADDR_VAR 0 17
73174: PUSH
73175: LD_VAR 0 5
73179: PPUSH
73180: LD_INT 22
73182: PUSH
73183: LD_VAR 0 13
73187: PPUSH
73188: CALL_OW 255
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 2
73199: PUSH
73200: LD_INT 30
73202: PUSH
73203: LD_INT 0
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PUSH
73210: LD_INT 30
73212: PUSH
73213: LD_INT 1
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: LIST
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: PPUSH
73229: CALL_OW 72
73233: ST_TO_ADDR
// for i = 1 to hexes do
73234: LD_ADDR_VAR 0 9
73238: PUSH
73239: DOUBLE
73240: LD_INT 1
73242: DEC
73243: ST_TO_ADDR
73244: LD_VAR 0 14
73248: PUSH
73249: FOR_TO
73250: IFFALSE 73926
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
73252: LD_ADDR_VAR 0 13
73256: PUSH
73257: LD_VAR 0 14
73261: PUSH
73262: LD_VAR 0 9
73266: ARRAY
73267: PUSH
73268: LD_INT 1
73270: ARRAY
73271: PPUSH
73272: LD_VAR 0 14
73276: PUSH
73277: LD_VAR 0 9
73281: ARRAY
73282: PUSH
73283: LD_INT 2
73285: ARRAY
73286: PPUSH
73287: CALL_OW 428
73291: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
73292: LD_VAR 0 14
73296: PUSH
73297: LD_VAR 0 9
73301: ARRAY
73302: PUSH
73303: LD_INT 1
73305: ARRAY
73306: PPUSH
73307: LD_VAR 0 14
73311: PUSH
73312: LD_VAR 0 9
73316: ARRAY
73317: PUSH
73318: LD_INT 2
73320: ARRAY
73321: PPUSH
73322: CALL_OW 351
73326: PUSH
73327: LD_VAR 0 14
73331: PUSH
73332: LD_VAR 0 9
73336: ARRAY
73337: PUSH
73338: LD_INT 1
73340: ARRAY
73341: PPUSH
73342: LD_VAR 0 14
73346: PUSH
73347: LD_VAR 0 9
73351: ARRAY
73352: PUSH
73353: LD_INT 2
73355: ARRAY
73356: PPUSH
73357: CALL_OW 488
73361: NOT
73362: OR
73363: PUSH
73364: LD_VAR 0 13
73368: PPUSH
73369: CALL_OW 247
73373: PUSH
73374: LD_INT 3
73376: EQUAL
73377: OR
73378: IFFALSE 73384
// exit ;
73380: POP
73381: POP
73382: GO 73928
// if not tmp then
73384: LD_VAR 0 13
73388: NOT
73389: IFFALSE 73393
// continue ;
73391: GO 73249
// result := true ;
73393: LD_ADDR_VAR 0 8
73397: PUSH
73398: LD_INT 1
73400: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
73401: LD_VAR 0 6
73405: PUSH
73406: LD_VAR 0 13
73410: PPUSH
73411: CALL_OW 247
73415: PUSH
73416: LD_INT 2
73418: EQUAL
73419: AND
73420: PUSH
73421: LD_VAR 0 13
73425: PPUSH
73426: CALL_OW 263
73430: PUSH
73431: LD_INT 1
73433: EQUAL
73434: AND
73435: IFFALSE 73599
// begin if IsDrivenBy ( tmp ) then
73437: LD_VAR 0 13
73441: PPUSH
73442: CALL_OW 311
73446: IFFALSE 73450
// continue ;
73448: GO 73249
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
73450: LD_VAR 0 6
73454: PPUSH
73455: LD_INT 3
73457: PUSH
73458: LD_INT 60
73460: PUSH
73461: EMPTY
73462: LIST
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 3
73470: PUSH
73471: LD_INT 55
73473: PUSH
73474: EMPTY
73475: LIST
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: PPUSH
73485: CALL_OW 72
73489: IFFALSE 73597
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
73491: LD_ADDR_VAR 0 18
73495: PUSH
73496: LD_VAR 0 6
73500: PPUSH
73501: LD_INT 3
73503: PUSH
73504: LD_INT 60
73506: PUSH
73507: EMPTY
73508: LIST
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 3
73516: PUSH
73517: LD_INT 55
73519: PUSH
73520: EMPTY
73521: LIST
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: EMPTY
73528: LIST
73529: LIST
73530: PPUSH
73531: CALL_OW 72
73535: PUSH
73536: LD_INT 1
73538: ARRAY
73539: ST_TO_ADDR
// if IsInUnit ( driver ) then
73540: LD_VAR 0 18
73544: PPUSH
73545: CALL_OW 310
73549: IFFALSE 73560
// ComExit ( driver ) ;
73551: LD_VAR 0 18
73555: PPUSH
73556: CALL 98349 0 1
// AddComEnterUnit ( driver , tmp ) ;
73560: LD_VAR 0 18
73564: PPUSH
73565: LD_VAR 0 13
73569: PPUSH
73570: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
73574: LD_VAR 0 18
73578: PPUSH
73579: LD_VAR 0 7
73583: PPUSH
73584: CALL_OW 173
// AddComExitVehicle ( driver ) ;
73588: LD_VAR 0 18
73592: PPUSH
73593: CALL_OW 181
// end ; continue ;
73597: GO 73249
// end ; if not cleaners or not tmp in cleaners then
73599: LD_VAR 0 6
73603: NOT
73604: PUSH
73605: LD_VAR 0 13
73609: PUSH
73610: LD_VAR 0 6
73614: IN
73615: NOT
73616: OR
73617: IFFALSE 73924
// begin if dep then
73619: LD_VAR 0 17
73623: IFFALSE 73759
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
73625: LD_ADDR_VAR 0 16
73629: PUSH
73630: LD_VAR 0 17
73634: PUSH
73635: LD_INT 1
73637: ARRAY
73638: PPUSH
73639: CALL_OW 250
73643: PPUSH
73644: LD_VAR 0 17
73648: PUSH
73649: LD_INT 1
73651: ARRAY
73652: PPUSH
73653: CALL_OW 254
73657: PPUSH
73658: LD_INT 5
73660: PPUSH
73661: CALL_OW 272
73665: PUSH
73666: LD_VAR 0 17
73670: PUSH
73671: LD_INT 1
73673: ARRAY
73674: PPUSH
73675: CALL_OW 251
73679: PPUSH
73680: LD_VAR 0 17
73684: PUSH
73685: LD_INT 1
73687: ARRAY
73688: PPUSH
73689: CALL_OW 254
73693: PPUSH
73694: LD_INT 5
73696: PPUSH
73697: CALL_OW 273
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
73706: LD_VAR 0 16
73710: PUSH
73711: LD_INT 1
73713: ARRAY
73714: PPUSH
73715: LD_VAR 0 16
73719: PUSH
73720: LD_INT 2
73722: ARRAY
73723: PPUSH
73724: CALL_OW 488
73728: IFFALSE 73759
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73730: LD_VAR 0 13
73734: PPUSH
73735: LD_VAR 0 16
73739: PUSH
73740: LD_INT 1
73742: ARRAY
73743: PPUSH
73744: LD_VAR 0 16
73748: PUSH
73749: LD_INT 2
73751: ARRAY
73752: PPUSH
73753: CALL_OW 111
// continue ;
73757: GO 73249
// end ; end ; r := GetDir ( tmp ) ;
73759: LD_ADDR_VAR 0 15
73763: PUSH
73764: LD_VAR 0 13
73768: PPUSH
73769: CALL_OW 254
73773: ST_TO_ADDR
// if r = 5 then
73774: LD_VAR 0 15
73778: PUSH
73779: LD_INT 5
73781: EQUAL
73782: IFFALSE 73792
// r := 0 ;
73784: LD_ADDR_VAR 0 15
73788: PUSH
73789: LD_INT 0
73791: ST_TO_ADDR
// for j = r to 5 do
73792: LD_ADDR_VAR 0 10
73796: PUSH
73797: DOUBLE
73798: LD_VAR 0 15
73802: DEC
73803: ST_TO_ADDR
73804: LD_INT 5
73806: PUSH
73807: FOR_TO
73808: IFFALSE 73922
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73810: LD_ADDR_VAR 0 11
73814: PUSH
73815: LD_VAR 0 13
73819: PPUSH
73820: CALL_OW 250
73824: PPUSH
73825: LD_VAR 0 10
73829: PPUSH
73830: LD_INT 2
73832: PPUSH
73833: CALL_OW 272
73837: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73838: LD_ADDR_VAR 0 12
73842: PUSH
73843: LD_VAR 0 13
73847: PPUSH
73848: CALL_OW 251
73852: PPUSH
73853: LD_VAR 0 10
73857: PPUSH
73858: LD_INT 2
73860: PPUSH
73861: CALL_OW 273
73865: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73866: LD_VAR 0 11
73870: PPUSH
73871: LD_VAR 0 12
73875: PPUSH
73876: CALL_OW 488
73880: PUSH
73881: LD_VAR 0 11
73885: PPUSH
73886: LD_VAR 0 12
73890: PPUSH
73891: CALL_OW 428
73895: NOT
73896: AND
73897: IFFALSE 73920
// begin ComMoveXY ( tmp , _x , _y ) ;
73899: LD_VAR 0 13
73903: PPUSH
73904: LD_VAR 0 11
73908: PPUSH
73909: LD_VAR 0 12
73913: PPUSH
73914: CALL_OW 111
// break ;
73918: GO 73922
// end ; end ;
73920: GO 73807
73922: POP
73923: POP
// end ; end ;
73924: GO 73249
73926: POP
73927: POP
// end ;
73928: LD_VAR 0 8
73932: RET
// export function BuildingTechInvented ( side , btype ) ; begin
73933: LD_INT 0
73935: PPUSH
// result := true ;
73936: LD_ADDR_VAR 0 3
73940: PUSH
73941: LD_INT 1
73943: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
73944: LD_VAR 0 2
73948: PUSH
73949: LD_INT 24
73951: DOUBLE
73952: EQUAL
73953: IFTRUE 73963
73955: LD_INT 33
73957: DOUBLE
73958: EQUAL
73959: IFTRUE 73963
73961: GO 73988
73963: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
73964: LD_ADDR_VAR 0 3
73968: PUSH
73969: LD_INT 32
73971: PPUSH
73972: LD_VAR 0 1
73976: PPUSH
73977: CALL_OW 321
73981: PUSH
73982: LD_INT 2
73984: EQUAL
73985: ST_TO_ADDR
73986: GO 74308
73988: LD_INT 20
73990: DOUBLE
73991: EQUAL
73992: IFTRUE 73996
73994: GO 74021
73996: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
73997: LD_ADDR_VAR 0 3
74001: PUSH
74002: LD_INT 6
74004: PPUSH
74005: LD_VAR 0 1
74009: PPUSH
74010: CALL_OW 321
74014: PUSH
74015: LD_INT 2
74017: EQUAL
74018: ST_TO_ADDR
74019: GO 74308
74021: LD_INT 22
74023: DOUBLE
74024: EQUAL
74025: IFTRUE 74035
74027: LD_INT 36
74029: DOUBLE
74030: EQUAL
74031: IFTRUE 74035
74033: GO 74060
74035: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
74036: LD_ADDR_VAR 0 3
74040: PUSH
74041: LD_INT 15
74043: PPUSH
74044: LD_VAR 0 1
74048: PPUSH
74049: CALL_OW 321
74053: PUSH
74054: LD_INT 2
74056: EQUAL
74057: ST_TO_ADDR
74058: GO 74308
74060: LD_INT 30
74062: DOUBLE
74063: EQUAL
74064: IFTRUE 74068
74066: GO 74093
74068: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
74069: LD_ADDR_VAR 0 3
74073: PUSH
74074: LD_INT 20
74076: PPUSH
74077: LD_VAR 0 1
74081: PPUSH
74082: CALL_OW 321
74086: PUSH
74087: LD_INT 2
74089: EQUAL
74090: ST_TO_ADDR
74091: GO 74308
74093: LD_INT 28
74095: DOUBLE
74096: EQUAL
74097: IFTRUE 74107
74099: LD_INT 21
74101: DOUBLE
74102: EQUAL
74103: IFTRUE 74107
74105: GO 74132
74107: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
74108: LD_ADDR_VAR 0 3
74112: PUSH
74113: LD_INT 21
74115: PPUSH
74116: LD_VAR 0 1
74120: PPUSH
74121: CALL_OW 321
74125: PUSH
74126: LD_INT 2
74128: EQUAL
74129: ST_TO_ADDR
74130: GO 74308
74132: LD_INT 16
74134: DOUBLE
74135: EQUAL
74136: IFTRUE 74140
74138: GO 74167
74140: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
74141: LD_ADDR_VAR 0 3
74145: PUSH
74146: LD_EXP 85
74150: PPUSH
74151: LD_VAR 0 1
74155: PPUSH
74156: CALL_OW 321
74160: PUSH
74161: LD_INT 2
74163: EQUAL
74164: ST_TO_ADDR
74165: GO 74308
74167: LD_INT 19
74169: DOUBLE
74170: EQUAL
74171: IFTRUE 74181
74173: LD_INT 23
74175: DOUBLE
74176: EQUAL
74177: IFTRUE 74181
74179: GO 74208
74181: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
74182: LD_ADDR_VAR 0 3
74186: PUSH
74187: LD_EXP 84
74191: PPUSH
74192: LD_VAR 0 1
74196: PPUSH
74197: CALL_OW 321
74201: PUSH
74202: LD_INT 2
74204: EQUAL
74205: ST_TO_ADDR
74206: GO 74308
74208: LD_INT 17
74210: DOUBLE
74211: EQUAL
74212: IFTRUE 74216
74214: GO 74241
74216: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
74217: LD_ADDR_VAR 0 3
74221: PUSH
74222: LD_INT 39
74224: PPUSH
74225: LD_VAR 0 1
74229: PPUSH
74230: CALL_OW 321
74234: PUSH
74235: LD_INT 2
74237: EQUAL
74238: ST_TO_ADDR
74239: GO 74308
74241: LD_INT 18
74243: DOUBLE
74244: EQUAL
74245: IFTRUE 74249
74247: GO 74274
74249: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
74250: LD_ADDR_VAR 0 3
74254: PUSH
74255: LD_INT 40
74257: PPUSH
74258: LD_VAR 0 1
74262: PPUSH
74263: CALL_OW 321
74267: PUSH
74268: LD_INT 2
74270: EQUAL
74271: ST_TO_ADDR
74272: GO 74308
74274: LD_INT 27
74276: DOUBLE
74277: EQUAL
74278: IFTRUE 74282
74280: GO 74307
74282: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
74283: LD_ADDR_VAR 0 3
74287: PUSH
74288: LD_INT 35
74290: PPUSH
74291: LD_VAR 0 1
74295: PPUSH
74296: CALL_OW 321
74300: PUSH
74301: LD_INT 2
74303: EQUAL
74304: ST_TO_ADDR
74305: GO 74308
74307: POP
// end ;
74308: LD_VAR 0 3
74312: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
74313: LD_INT 0
74315: PPUSH
74316: PPUSH
74317: PPUSH
74318: PPUSH
74319: PPUSH
74320: PPUSH
74321: PPUSH
74322: PPUSH
74323: PPUSH
74324: PPUSH
74325: PPUSH
// result := false ;
74326: LD_ADDR_VAR 0 6
74330: PUSH
74331: LD_INT 0
74333: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
74334: LD_VAR 0 1
74338: NOT
74339: PUSH
74340: LD_VAR 0 1
74344: PPUSH
74345: CALL_OW 266
74349: PUSH
74350: LD_INT 0
74352: PUSH
74353: LD_INT 1
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: IN
74360: NOT
74361: OR
74362: PUSH
74363: LD_VAR 0 2
74367: NOT
74368: OR
74369: PUSH
74370: LD_VAR 0 5
74374: PUSH
74375: LD_INT 0
74377: PUSH
74378: LD_INT 1
74380: PUSH
74381: LD_INT 2
74383: PUSH
74384: LD_INT 3
74386: PUSH
74387: LD_INT 4
74389: PUSH
74390: LD_INT 5
74392: PUSH
74393: EMPTY
74394: LIST
74395: LIST
74396: LIST
74397: LIST
74398: LIST
74399: LIST
74400: IN
74401: NOT
74402: OR
74403: PUSH
74404: LD_VAR 0 3
74408: PPUSH
74409: LD_VAR 0 4
74413: PPUSH
74414: CALL_OW 488
74418: NOT
74419: OR
74420: IFFALSE 74424
// exit ;
74422: GO 75160
// side := GetSide ( depot ) ;
74424: LD_ADDR_VAR 0 9
74428: PUSH
74429: LD_VAR 0 1
74433: PPUSH
74434: CALL_OW 255
74438: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
74439: LD_VAR 0 9
74443: PPUSH
74444: LD_VAR 0 2
74448: PPUSH
74449: CALL 73933 0 2
74453: NOT
74454: IFFALSE 74458
// exit ;
74456: GO 75160
// pom := GetBase ( depot ) ;
74458: LD_ADDR_VAR 0 10
74462: PUSH
74463: LD_VAR 0 1
74467: PPUSH
74468: CALL_OW 274
74472: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
74473: LD_ADDR_VAR 0 11
74477: PUSH
74478: LD_VAR 0 2
74482: PPUSH
74483: LD_VAR 0 1
74487: PPUSH
74488: CALL_OW 248
74492: PPUSH
74493: CALL_OW 450
74497: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
74498: LD_VAR 0 10
74502: PPUSH
74503: LD_INT 1
74505: PPUSH
74506: CALL_OW 275
74510: PUSH
74511: LD_VAR 0 11
74515: PUSH
74516: LD_INT 1
74518: ARRAY
74519: GREATEREQUAL
74520: PUSH
74521: LD_VAR 0 10
74525: PPUSH
74526: LD_INT 2
74528: PPUSH
74529: CALL_OW 275
74533: PUSH
74534: LD_VAR 0 11
74538: PUSH
74539: LD_INT 2
74541: ARRAY
74542: GREATEREQUAL
74543: AND
74544: PUSH
74545: LD_VAR 0 10
74549: PPUSH
74550: LD_INT 3
74552: PPUSH
74553: CALL_OW 275
74557: PUSH
74558: LD_VAR 0 11
74562: PUSH
74563: LD_INT 3
74565: ARRAY
74566: GREATEREQUAL
74567: AND
74568: NOT
74569: IFFALSE 74573
// exit ;
74571: GO 75160
// if GetBType ( depot ) = b_depot then
74573: LD_VAR 0 1
74577: PPUSH
74578: CALL_OW 266
74582: PUSH
74583: LD_INT 0
74585: EQUAL
74586: IFFALSE 74598
// dist := 28 else
74588: LD_ADDR_VAR 0 14
74592: PUSH
74593: LD_INT 28
74595: ST_TO_ADDR
74596: GO 74606
// dist := 36 ;
74598: LD_ADDR_VAR 0 14
74602: PUSH
74603: LD_INT 36
74605: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
74606: LD_VAR 0 1
74610: PPUSH
74611: LD_VAR 0 3
74615: PPUSH
74616: LD_VAR 0 4
74620: PPUSH
74621: CALL_OW 297
74625: PUSH
74626: LD_VAR 0 14
74630: GREATER
74631: IFFALSE 74635
// exit ;
74633: GO 75160
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
74635: LD_ADDR_VAR 0 12
74639: PUSH
74640: LD_VAR 0 2
74644: PPUSH
74645: LD_VAR 0 3
74649: PPUSH
74650: LD_VAR 0 4
74654: PPUSH
74655: LD_VAR 0 5
74659: PPUSH
74660: LD_VAR 0 1
74664: PPUSH
74665: CALL_OW 248
74669: PPUSH
74670: LD_INT 0
74672: PPUSH
74673: CALL 75165 0 6
74677: ST_TO_ADDR
// if not hexes then
74678: LD_VAR 0 12
74682: NOT
74683: IFFALSE 74687
// exit ;
74685: GO 75160
// hex := GetHexInfo ( x , y ) ;
74687: LD_ADDR_VAR 0 15
74691: PUSH
74692: LD_VAR 0 3
74696: PPUSH
74697: LD_VAR 0 4
74701: PPUSH
74702: CALL_OW 546
74706: ST_TO_ADDR
// if hex [ 1 ] then
74707: LD_VAR 0 15
74711: PUSH
74712: LD_INT 1
74714: ARRAY
74715: IFFALSE 74719
// exit ;
74717: GO 75160
// height := hex [ 2 ] ;
74719: LD_ADDR_VAR 0 13
74723: PUSH
74724: LD_VAR 0 15
74728: PUSH
74729: LD_INT 2
74731: ARRAY
74732: ST_TO_ADDR
// for i = 1 to hexes do
74733: LD_ADDR_VAR 0 7
74737: PUSH
74738: DOUBLE
74739: LD_INT 1
74741: DEC
74742: ST_TO_ADDR
74743: LD_VAR 0 12
74747: PUSH
74748: FOR_TO
74749: IFFALSE 75079
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
74751: LD_VAR 0 12
74755: PUSH
74756: LD_VAR 0 7
74760: ARRAY
74761: PUSH
74762: LD_INT 1
74764: ARRAY
74765: PPUSH
74766: LD_VAR 0 12
74770: PUSH
74771: LD_VAR 0 7
74775: ARRAY
74776: PUSH
74777: LD_INT 2
74779: ARRAY
74780: PPUSH
74781: CALL_OW 488
74785: NOT
74786: PUSH
74787: LD_VAR 0 12
74791: PUSH
74792: LD_VAR 0 7
74796: ARRAY
74797: PUSH
74798: LD_INT 1
74800: ARRAY
74801: PPUSH
74802: LD_VAR 0 12
74806: PUSH
74807: LD_VAR 0 7
74811: ARRAY
74812: PUSH
74813: LD_INT 2
74815: ARRAY
74816: PPUSH
74817: CALL_OW 428
74821: PUSH
74822: LD_INT 0
74824: GREATER
74825: OR
74826: PUSH
74827: LD_VAR 0 12
74831: PUSH
74832: LD_VAR 0 7
74836: ARRAY
74837: PUSH
74838: LD_INT 1
74840: ARRAY
74841: PPUSH
74842: LD_VAR 0 12
74846: PUSH
74847: LD_VAR 0 7
74851: ARRAY
74852: PUSH
74853: LD_INT 2
74855: ARRAY
74856: PPUSH
74857: CALL_OW 351
74861: OR
74862: IFFALSE 74868
// exit ;
74864: POP
74865: POP
74866: GO 75160
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74868: LD_ADDR_VAR 0 8
74872: PUSH
74873: LD_VAR 0 12
74877: PUSH
74878: LD_VAR 0 7
74882: ARRAY
74883: PUSH
74884: LD_INT 1
74886: ARRAY
74887: PPUSH
74888: LD_VAR 0 12
74892: PUSH
74893: LD_VAR 0 7
74897: ARRAY
74898: PUSH
74899: LD_INT 2
74901: ARRAY
74902: PPUSH
74903: CALL_OW 546
74907: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
74908: LD_VAR 0 8
74912: PUSH
74913: LD_INT 1
74915: ARRAY
74916: PUSH
74917: LD_VAR 0 8
74921: PUSH
74922: LD_INT 2
74924: ARRAY
74925: PUSH
74926: LD_VAR 0 13
74930: PUSH
74931: LD_INT 2
74933: PLUS
74934: GREATER
74935: OR
74936: PUSH
74937: LD_VAR 0 8
74941: PUSH
74942: LD_INT 2
74944: ARRAY
74945: PUSH
74946: LD_VAR 0 13
74950: PUSH
74951: LD_INT 2
74953: MINUS
74954: LESS
74955: OR
74956: PUSH
74957: LD_VAR 0 8
74961: PUSH
74962: LD_INT 3
74964: ARRAY
74965: PUSH
74966: LD_INT 0
74968: PUSH
74969: LD_INT 8
74971: PUSH
74972: LD_INT 9
74974: PUSH
74975: LD_INT 10
74977: PUSH
74978: LD_INT 11
74980: PUSH
74981: LD_INT 12
74983: PUSH
74984: LD_INT 13
74986: PUSH
74987: LD_INT 16
74989: PUSH
74990: LD_INT 17
74992: PUSH
74993: LD_INT 18
74995: PUSH
74996: LD_INT 19
74998: PUSH
74999: LD_INT 20
75001: PUSH
75002: LD_INT 21
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: IN
75020: NOT
75021: OR
75022: PUSH
75023: LD_VAR 0 8
75027: PUSH
75028: LD_INT 5
75030: ARRAY
75031: NOT
75032: OR
75033: PUSH
75034: LD_VAR 0 8
75038: PUSH
75039: LD_INT 6
75041: ARRAY
75042: PUSH
75043: LD_INT 1
75045: PUSH
75046: LD_INT 2
75048: PUSH
75049: LD_INT 7
75051: PUSH
75052: LD_INT 9
75054: PUSH
75055: LD_INT 10
75057: PUSH
75058: LD_INT 11
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: IN
75069: NOT
75070: OR
75071: IFFALSE 75077
// exit ;
75073: POP
75074: POP
75075: GO 75160
// end ;
75077: GO 74748
75079: POP
75080: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75081: LD_VAR 0 9
75085: PPUSH
75086: LD_VAR 0 3
75090: PPUSH
75091: LD_VAR 0 4
75095: PPUSH
75096: LD_INT 20
75098: PPUSH
75099: CALL 67106 0 4
75103: PUSH
75104: LD_INT 4
75106: ARRAY
75107: IFFALSE 75111
// exit ;
75109: GO 75160
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
75111: LD_VAR 0 2
75115: PUSH
75116: LD_INT 29
75118: PUSH
75119: LD_INT 30
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: IN
75126: PUSH
75127: LD_VAR 0 3
75131: PPUSH
75132: LD_VAR 0 4
75136: PPUSH
75137: LD_VAR 0 9
75141: PPUSH
75142: CALL_OW 440
75146: NOT
75147: AND
75148: IFFALSE 75152
// exit ;
75150: GO 75160
// result := true ;
75152: LD_ADDR_VAR 0 6
75156: PUSH
75157: LD_INT 1
75159: ST_TO_ADDR
// end ;
75160: LD_VAR 0 6
75164: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
75165: LD_INT 0
75167: PPUSH
75168: PPUSH
75169: PPUSH
75170: PPUSH
75171: PPUSH
75172: PPUSH
75173: PPUSH
75174: PPUSH
75175: PPUSH
75176: PPUSH
75177: PPUSH
75178: PPUSH
75179: PPUSH
75180: PPUSH
75181: PPUSH
75182: PPUSH
75183: PPUSH
75184: PPUSH
75185: PPUSH
75186: PPUSH
75187: PPUSH
75188: PPUSH
75189: PPUSH
75190: PPUSH
75191: PPUSH
75192: PPUSH
75193: PPUSH
75194: PPUSH
75195: PPUSH
75196: PPUSH
75197: PPUSH
75198: PPUSH
75199: PPUSH
75200: PPUSH
75201: PPUSH
75202: PPUSH
75203: PPUSH
75204: PPUSH
75205: PPUSH
75206: PPUSH
75207: PPUSH
75208: PPUSH
75209: PPUSH
75210: PPUSH
75211: PPUSH
75212: PPUSH
75213: PPUSH
75214: PPUSH
75215: PPUSH
75216: PPUSH
75217: PPUSH
75218: PPUSH
75219: PPUSH
75220: PPUSH
75221: PPUSH
75222: PPUSH
75223: PPUSH
75224: PPUSH
// result = [ ] ;
75225: LD_ADDR_VAR 0 7
75229: PUSH
75230: EMPTY
75231: ST_TO_ADDR
// temp_list = [ ] ;
75232: LD_ADDR_VAR 0 9
75236: PUSH
75237: EMPTY
75238: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
75239: LD_VAR 0 4
75243: PUSH
75244: LD_INT 0
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: LD_INT 2
75252: PUSH
75253: LD_INT 3
75255: PUSH
75256: LD_INT 4
75258: PUSH
75259: LD_INT 5
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: IN
75270: NOT
75271: PUSH
75272: LD_VAR 0 1
75276: PUSH
75277: LD_INT 0
75279: PUSH
75280: LD_INT 1
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: IN
75287: PUSH
75288: LD_VAR 0 5
75292: PUSH
75293: LD_INT 1
75295: PUSH
75296: LD_INT 2
75298: PUSH
75299: LD_INT 3
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: LIST
75306: IN
75307: NOT
75308: AND
75309: OR
75310: IFFALSE 75314
// exit ;
75312: GO 93705
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
75314: LD_VAR 0 1
75318: PUSH
75319: LD_INT 6
75321: PUSH
75322: LD_INT 7
75324: PUSH
75325: LD_INT 8
75327: PUSH
75328: LD_INT 13
75330: PUSH
75331: LD_INT 12
75333: PUSH
75334: LD_INT 15
75336: PUSH
75337: LD_INT 11
75339: PUSH
75340: LD_INT 14
75342: PUSH
75343: LD_INT 10
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: IN
75357: IFFALSE 75367
// btype = b_lab ;
75359: LD_ADDR_VAR 0 1
75363: PUSH
75364: LD_INT 6
75366: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
75367: LD_VAR 0 6
75371: PUSH
75372: LD_INT 0
75374: PUSH
75375: LD_INT 1
75377: PUSH
75378: LD_INT 2
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: LIST
75385: IN
75386: NOT
75387: PUSH
75388: LD_VAR 0 1
75392: PUSH
75393: LD_INT 0
75395: PUSH
75396: LD_INT 1
75398: PUSH
75399: LD_INT 2
75401: PUSH
75402: LD_INT 3
75404: PUSH
75405: LD_INT 6
75407: PUSH
75408: LD_INT 36
75410: PUSH
75411: LD_INT 4
75413: PUSH
75414: LD_INT 5
75416: PUSH
75417: LD_INT 31
75419: PUSH
75420: LD_INT 32
75422: PUSH
75423: LD_INT 33
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: LIST
75430: LIST
75431: LIST
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: LIST
75437: LIST
75438: IN
75439: NOT
75440: PUSH
75441: LD_VAR 0 6
75445: PUSH
75446: LD_INT 1
75448: EQUAL
75449: AND
75450: OR
75451: PUSH
75452: LD_VAR 0 1
75456: PUSH
75457: LD_INT 2
75459: PUSH
75460: LD_INT 3
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: IN
75467: NOT
75468: PUSH
75469: LD_VAR 0 6
75473: PUSH
75474: LD_INT 2
75476: EQUAL
75477: AND
75478: OR
75479: IFFALSE 75489
// mode = 0 ;
75481: LD_ADDR_VAR 0 6
75485: PUSH
75486: LD_INT 0
75488: ST_TO_ADDR
// case mode of 0 :
75489: LD_VAR 0 6
75493: PUSH
75494: LD_INT 0
75496: DOUBLE
75497: EQUAL
75498: IFTRUE 75502
75500: GO 86955
75502: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75503: LD_ADDR_VAR 0 11
75507: PUSH
75508: LD_INT 0
75510: PUSH
75511: LD_INT 0
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 0
75520: PUSH
75521: LD_INT 1
75523: NEG
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: PUSH
75532: LD_INT 0
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 1
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 0
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: EMPTY
75556: LIST
75557: LIST
75558: PUSH
75559: LD_INT 1
75561: NEG
75562: PUSH
75563: LD_INT 0
75565: PUSH
75566: EMPTY
75567: LIST
75568: LIST
75569: PUSH
75570: LD_INT 1
75572: NEG
75573: PUSH
75574: LD_INT 1
75576: NEG
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 1
75584: NEG
75585: PUSH
75586: LD_INT 2
75588: NEG
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 0
75596: PUSH
75597: LD_INT 2
75599: NEG
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 1
75607: PUSH
75608: LD_INT 1
75610: NEG
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 1
75618: PUSH
75619: LD_INT 2
75621: PUSH
75622: EMPTY
75623: LIST
75624: LIST
75625: PUSH
75626: LD_INT 0
75628: PUSH
75629: LD_INT 2
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 1
75638: NEG
75639: PUSH
75640: LD_INT 1
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: PUSH
75647: LD_INT 1
75649: PUSH
75650: LD_INT 3
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: LD_INT 0
75659: PUSH
75660: LD_INT 3
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: PUSH
75667: LD_INT 1
75669: NEG
75670: PUSH
75671: LD_INT 2
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: LIST
75682: LIST
75683: LIST
75684: LIST
75685: LIST
75686: LIST
75687: LIST
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75696: LD_ADDR_VAR 0 12
75700: PUSH
75701: LD_INT 0
75703: PUSH
75704: LD_INT 0
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 0
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: LD_INT 1
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: LD_INT 1
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: LD_INT 0
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 1
75765: NEG
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: LD_INT 1
75780: NEG
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 2
75788: PUSH
75789: LD_INT 0
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 2
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: LD_INT 1
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 2
75819: NEG
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 2
75830: NEG
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 2
75842: NEG
75843: PUSH
75844: LD_INT 1
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 3
75853: NEG
75854: PUSH
75855: LD_INT 0
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 3
75864: NEG
75865: PUSH
75866: LD_INT 1
75868: NEG
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: LIST
75885: LIST
75886: LIST
75887: LIST
75888: LIST
75889: LIST
75890: LIST
75891: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75892: LD_ADDR_VAR 0 13
75896: PUSH
75897: LD_INT 0
75899: PUSH
75900: LD_INT 0
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 0
75909: PUSH
75910: LD_INT 1
75912: NEG
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PUSH
75918: LD_INT 1
75920: PUSH
75921: LD_INT 0
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: PUSH
75928: LD_INT 1
75930: PUSH
75931: LD_INT 1
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: LD_INT 1
75943: PUSH
75944: EMPTY
75945: LIST
75946: LIST
75947: PUSH
75948: LD_INT 1
75950: NEG
75951: PUSH
75952: LD_INT 0
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 1
75961: NEG
75962: PUSH
75963: LD_INT 1
75965: NEG
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: LD_INT 1
75973: NEG
75974: PUSH
75975: LD_INT 2
75977: NEG
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 2
75985: PUSH
75986: LD_INT 1
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 2
75995: PUSH
75996: LD_INT 2
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 1
76005: PUSH
76006: LD_INT 2
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 2
76015: NEG
76016: PUSH
76017: LD_INT 1
76019: NEG
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 2
76027: NEG
76028: PUSH
76029: LD_INT 2
76031: NEG
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 2
76039: NEG
76040: PUSH
76041: LD_INT 3
76043: NEG
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 3
76051: NEG
76052: PUSH
76053: LD_INT 2
76055: NEG
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: LD_INT 3
76063: NEG
76064: PUSH
76065: LD_INT 3
76067: NEG
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76091: LD_ADDR_VAR 0 14
76095: PUSH
76096: LD_INT 0
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: LD_INT 1
76111: NEG
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 1
76119: PUSH
76120: LD_INT 0
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: PUSH
76127: LD_INT 1
76129: PUSH
76130: LD_INT 1
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: LD_INT 0
76139: PUSH
76140: LD_INT 1
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 1
76149: NEG
76150: PUSH
76151: LD_INT 0
76153: PUSH
76154: EMPTY
76155: LIST
76156: LIST
76157: PUSH
76158: LD_INT 1
76160: NEG
76161: PUSH
76162: LD_INT 1
76164: NEG
76165: PUSH
76166: EMPTY
76167: LIST
76168: LIST
76169: PUSH
76170: LD_INT 1
76172: NEG
76173: PUSH
76174: LD_INT 2
76176: NEG
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 0
76184: PUSH
76185: LD_INT 2
76187: NEG
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 1
76195: PUSH
76196: LD_INT 1
76198: NEG
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 1
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: PUSH
76214: LD_INT 0
76216: PUSH
76217: LD_INT 2
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: PUSH
76224: LD_INT 1
76226: NEG
76227: PUSH
76228: LD_INT 1
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PUSH
76235: LD_INT 1
76237: NEG
76238: PUSH
76239: LD_INT 3
76241: NEG
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: PUSH
76247: LD_INT 0
76249: PUSH
76250: LD_INT 3
76252: NEG
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PUSH
76258: LD_INT 1
76260: PUSH
76261: LD_INT 2
76263: NEG
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: LIST
76273: LIST
76274: LIST
76275: LIST
76276: LIST
76277: LIST
76278: LIST
76279: LIST
76280: LIST
76281: LIST
76282: LIST
76283: LIST
76284: LIST
76285: LIST
76286: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76287: LD_ADDR_VAR 0 15
76291: PUSH
76292: LD_INT 0
76294: PUSH
76295: LD_INT 0
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 0
76304: PUSH
76305: LD_INT 1
76307: NEG
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 1
76315: PUSH
76316: LD_INT 0
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: LD_INT 1
76325: PUSH
76326: LD_INT 1
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: LD_INT 1
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: NEG
76346: PUSH
76347: LD_INT 0
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 1
76356: NEG
76357: PUSH
76358: LD_INT 1
76360: NEG
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 1
76368: PUSH
76369: LD_INT 1
76371: NEG
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 2
76379: PUSH
76380: LD_INT 0
76382: PUSH
76383: EMPTY
76384: LIST
76385: LIST
76386: PUSH
76387: LD_INT 2
76389: PUSH
76390: LD_INT 1
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 1
76399: NEG
76400: PUSH
76401: LD_INT 1
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: LD_INT 2
76410: NEG
76411: PUSH
76412: LD_INT 0
76414: PUSH
76415: EMPTY
76416: LIST
76417: LIST
76418: PUSH
76419: LD_INT 2
76421: NEG
76422: PUSH
76423: LD_INT 1
76425: NEG
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: LD_INT 2
76433: PUSH
76434: LD_INT 1
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 3
76444: PUSH
76445: LD_INT 0
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PUSH
76452: LD_INT 3
76454: PUSH
76455: LD_INT 1
76457: PUSH
76458: EMPTY
76459: LIST
76460: LIST
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: LIST
76466: LIST
76467: LIST
76468: LIST
76469: LIST
76470: LIST
76471: LIST
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: LIST
76477: LIST
76478: LIST
76479: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76480: LD_ADDR_VAR 0 16
76484: PUSH
76485: LD_INT 0
76487: PUSH
76488: LD_INT 0
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PUSH
76495: LD_INT 0
76497: PUSH
76498: LD_INT 1
76500: NEG
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 1
76508: PUSH
76509: LD_INT 0
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: LD_INT 1
76518: PUSH
76519: LD_INT 1
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 0
76528: PUSH
76529: LD_INT 1
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: PUSH
76536: LD_INT 1
76538: NEG
76539: PUSH
76540: LD_INT 0
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 1
76549: NEG
76550: PUSH
76551: LD_INT 1
76553: NEG
76554: PUSH
76555: EMPTY
76556: LIST
76557: LIST
76558: PUSH
76559: LD_INT 1
76561: NEG
76562: PUSH
76563: LD_INT 2
76565: NEG
76566: PUSH
76567: EMPTY
76568: LIST
76569: LIST
76570: PUSH
76571: LD_INT 2
76573: PUSH
76574: LD_INT 1
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 2
76583: PUSH
76584: LD_INT 2
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 1
76593: PUSH
76594: LD_INT 2
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: LD_INT 2
76603: NEG
76604: PUSH
76605: LD_INT 1
76607: NEG
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 2
76615: NEG
76616: PUSH
76617: LD_INT 2
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 3
76627: PUSH
76628: LD_INT 2
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 3
76637: PUSH
76638: LD_INT 3
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 2
76647: PUSH
76648: LD_INT 3
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76673: LD_ADDR_VAR 0 17
76677: PUSH
76678: LD_INT 0
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: LD_INT 1
76693: NEG
76694: PUSH
76695: EMPTY
76696: LIST
76697: LIST
76698: PUSH
76699: LD_INT 1
76701: PUSH
76702: LD_INT 0
76704: PUSH
76705: EMPTY
76706: LIST
76707: LIST
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: LD_INT 1
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 0
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: PUSH
76729: LD_INT 1
76731: NEG
76732: PUSH
76733: LD_INT 0
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_INT 1
76742: NEG
76743: PUSH
76744: LD_INT 1
76746: NEG
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 1
76754: NEG
76755: PUSH
76756: LD_INT 2
76758: NEG
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PUSH
76764: LD_INT 0
76766: PUSH
76767: LD_INT 2
76769: NEG
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 1
76777: PUSH
76778: LD_INT 1
76780: NEG
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 2
76788: PUSH
76789: LD_INT 0
76791: PUSH
76792: EMPTY
76793: LIST
76794: LIST
76795: PUSH
76796: LD_INT 2
76798: PUSH
76799: LD_INT 1
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: LD_INT 2
76808: PUSH
76809: LD_INT 2
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: LD_INT 2
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 0
76828: PUSH
76829: LD_INT 2
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 1
76838: NEG
76839: PUSH
76840: LD_INT 1
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 2
76849: NEG
76850: PUSH
76851: LD_INT 0
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 2
76860: NEG
76861: PUSH
76862: LD_INT 1
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 2
76872: NEG
76873: PUSH
76874: LD_INT 2
76876: NEG
76877: PUSH
76878: EMPTY
76879: LIST
76880: LIST
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: LIST
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76903: LD_ADDR_VAR 0 18
76907: PUSH
76908: LD_INT 0
76910: PUSH
76911: LD_INT 0
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 0
76920: PUSH
76921: LD_INT 1
76923: NEG
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 1
76931: PUSH
76932: LD_INT 0
76934: PUSH
76935: EMPTY
76936: LIST
76937: LIST
76938: PUSH
76939: LD_INT 1
76941: PUSH
76942: LD_INT 1
76944: PUSH
76945: EMPTY
76946: LIST
76947: LIST
76948: PUSH
76949: LD_INT 0
76951: PUSH
76952: LD_INT 1
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 1
76961: NEG
76962: PUSH
76963: LD_INT 0
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: LD_INT 1
76972: NEG
76973: PUSH
76974: LD_INT 1
76976: NEG
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 1
76984: NEG
76985: PUSH
76986: LD_INT 2
76988: NEG
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: LD_INT 0
76996: PUSH
76997: LD_INT 2
76999: NEG
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 1
77007: PUSH
77008: LD_INT 1
77010: NEG
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 2
77018: PUSH
77019: LD_INT 0
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 2
77028: PUSH
77029: LD_INT 1
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 2
77038: PUSH
77039: LD_INT 2
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: LD_INT 2
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 0
77058: PUSH
77059: LD_INT 2
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 1
77068: NEG
77069: PUSH
77070: LD_INT 1
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 2
77079: NEG
77080: PUSH
77081: LD_INT 0
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 2
77090: NEG
77091: PUSH
77092: LD_INT 1
77094: NEG
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 2
77102: NEG
77103: PUSH
77104: LD_INT 2
77106: NEG
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: LIST
77116: LIST
77117: LIST
77118: LIST
77119: LIST
77120: LIST
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77133: LD_ADDR_VAR 0 19
77137: PUSH
77138: LD_INT 0
77140: PUSH
77141: LD_INT 0
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 0
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 1
77161: PUSH
77162: LD_INT 0
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: LD_INT 1
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 1
77191: NEG
77192: PUSH
77193: LD_INT 0
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 1
77202: NEG
77203: PUSH
77204: LD_INT 1
77206: NEG
77207: PUSH
77208: EMPTY
77209: LIST
77210: LIST
77211: PUSH
77212: LD_INT 1
77214: NEG
77215: PUSH
77216: LD_INT 2
77218: NEG
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 0
77226: PUSH
77227: LD_INT 2
77229: NEG
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 1
77237: PUSH
77238: LD_INT 1
77240: NEG
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 2
77248: PUSH
77249: LD_INT 0
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 2
77258: PUSH
77259: LD_INT 1
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 2
77268: PUSH
77269: LD_INT 2
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 0
77288: PUSH
77289: LD_INT 2
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 1
77298: NEG
77299: PUSH
77300: LD_INT 1
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: PUSH
77307: LD_INT 2
77309: NEG
77310: PUSH
77311: LD_INT 0
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 2
77320: NEG
77321: PUSH
77322: LD_INT 1
77324: NEG
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 2
77332: NEG
77333: PUSH
77334: LD_INT 2
77336: NEG
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: LIST
77348: LIST
77349: LIST
77350: LIST
77351: LIST
77352: LIST
77353: LIST
77354: LIST
77355: LIST
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77363: LD_ADDR_VAR 0 20
77367: PUSH
77368: LD_INT 0
77370: PUSH
77371: LD_INT 0
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: PUSH
77378: LD_INT 0
77380: PUSH
77381: LD_INT 1
77383: NEG
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: LD_INT 1
77391: PUSH
77392: LD_INT 0
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: LD_INT 1
77401: PUSH
77402: LD_INT 1
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 0
77411: PUSH
77412: LD_INT 1
77414: PUSH
77415: EMPTY
77416: LIST
77417: LIST
77418: PUSH
77419: LD_INT 1
77421: NEG
77422: PUSH
77423: LD_INT 0
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 1
77432: NEG
77433: PUSH
77434: LD_INT 1
77436: NEG
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 1
77444: NEG
77445: PUSH
77446: LD_INT 2
77448: NEG
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 0
77456: PUSH
77457: LD_INT 2
77459: NEG
77460: PUSH
77461: EMPTY
77462: LIST
77463: LIST
77464: PUSH
77465: LD_INT 1
77467: PUSH
77468: LD_INT 1
77470: NEG
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: PUSH
77476: LD_INT 2
77478: PUSH
77479: LD_INT 0
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: PUSH
77486: LD_INT 2
77488: PUSH
77489: LD_INT 1
77491: PUSH
77492: EMPTY
77493: LIST
77494: LIST
77495: PUSH
77496: LD_INT 2
77498: PUSH
77499: LD_INT 2
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 1
77508: PUSH
77509: LD_INT 2
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 0
77518: PUSH
77519: LD_INT 2
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 1
77528: NEG
77529: PUSH
77530: LD_INT 1
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 2
77539: NEG
77540: PUSH
77541: LD_INT 0
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 2
77550: NEG
77551: PUSH
77552: LD_INT 1
77554: NEG
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: PUSH
77560: LD_INT 2
77562: NEG
77563: PUSH
77564: LD_INT 2
77566: NEG
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77593: LD_ADDR_VAR 0 21
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: LD_INT 0
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: LD_INT 1
77613: NEG
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: PUSH
77619: LD_INT 1
77621: PUSH
77622: LD_INT 0
77624: PUSH
77625: EMPTY
77626: LIST
77627: LIST
77628: PUSH
77629: LD_INT 1
77631: PUSH
77632: LD_INT 1
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: LD_INT 1
77644: PUSH
77645: EMPTY
77646: LIST
77647: LIST
77648: PUSH
77649: LD_INT 1
77651: NEG
77652: PUSH
77653: LD_INT 0
77655: PUSH
77656: EMPTY
77657: LIST
77658: LIST
77659: PUSH
77660: LD_INT 1
77662: NEG
77663: PUSH
77664: LD_INT 1
77666: NEG
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: LD_INT 1
77674: NEG
77675: PUSH
77676: LD_INT 2
77678: NEG
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 0
77686: PUSH
77687: LD_INT 2
77689: NEG
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: LD_INT 1
77697: PUSH
77698: LD_INT 1
77700: NEG
77701: PUSH
77702: EMPTY
77703: LIST
77704: LIST
77705: PUSH
77706: LD_INT 2
77708: PUSH
77709: LD_INT 0
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 2
77718: PUSH
77719: LD_INT 1
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 2
77728: PUSH
77729: LD_INT 2
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: LD_INT 1
77738: PUSH
77739: LD_INT 2
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 0
77748: PUSH
77749: LD_INT 2
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 1
77758: NEG
77759: PUSH
77760: LD_INT 1
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 2
77769: NEG
77770: PUSH
77771: LD_INT 0
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: PUSH
77778: LD_INT 2
77780: NEG
77781: PUSH
77782: LD_INT 1
77784: NEG
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 2
77792: NEG
77793: PUSH
77794: LD_INT 2
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: LIST
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77823: LD_ADDR_VAR 0 22
77827: PUSH
77828: LD_INT 0
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 0
77840: PUSH
77841: LD_INT 1
77843: NEG
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 1
77851: PUSH
77852: LD_INT 0
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 1
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 0
77871: PUSH
77872: LD_INT 1
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 1
77881: NEG
77882: PUSH
77883: LD_INT 0
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 1
77904: NEG
77905: PUSH
77906: LD_INT 2
77908: NEG
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 0
77916: PUSH
77917: LD_INT 2
77919: NEG
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 1
77927: PUSH
77928: LD_INT 1
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 2
77938: PUSH
77939: LD_INT 0
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: LD_INT 2
77948: PUSH
77949: LD_INT 1
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: LD_INT 2
77958: PUSH
77959: LD_INT 2
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: LD_INT 2
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 0
77978: PUSH
77979: LD_INT 2
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 1
77988: NEG
77989: PUSH
77990: LD_INT 1
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 2
77999: NEG
78000: PUSH
78001: LD_INT 0
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 2
78010: NEG
78011: PUSH
78012: LD_INT 1
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: LD_INT 2
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: LIST
78039: LIST
78040: LIST
78041: LIST
78042: LIST
78043: LIST
78044: LIST
78045: LIST
78046: LIST
78047: LIST
78048: LIST
78049: LIST
78050: LIST
78051: LIST
78052: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78053: LD_ADDR_VAR 0 23
78057: PUSH
78058: LD_INT 0
78060: PUSH
78061: LD_INT 0
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 0
78070: PUSH
78071: LD_INT 1
78073: NEG
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 1
78081: PUSH
78082: LD_INT 0
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 1
78091: PUSH
78092: LD_INT 1
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 0
78101: PUSH
78102: LD_INT 1
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: LD_INT 1
78111: NEG
78112: PUSH
78113: LD_INT 0
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 1
78122: NEG
78123: PUSH
78124: LD_INT 1
78126: NEG
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 1
78134: NEG
78135: PUSH
78136: LD_INT 2
78138: NEG
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: PUSH
78144: LD_INT 0
78146: PUSH
78147: LD_INT 2
78149: NEG
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 1
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 2
78168: PUSH
78169: LD_INT 0
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: LD_INT 1
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 2
78188: PUSH
78189: LD_INT 2
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: LD_INT 2
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 0
78208: PUSH
78209: LD_INT 2
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: LD_INT 1
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 2
78229: NEG
78230: PUSH
78231: LD_INT 0
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 2
78240: NEG
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 2
78252: NEG
78253: PUSH
78254: LD_INT 2
78256: NEG
78257: PUSH
78258: EMPTY
78259: LIST
78260: LIST
78261: PUSH
78262: LD_INT 2
78264: NEG
78265: PUSH
78266: LD_INT 3
78268: NEG
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: LD_INT 1
78276: NEG
78277: PUSH
78278: LD_INT 3
78280: NEG
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 1
78288: PUSH
78289: LD_INT 2
78291: NEG
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 2
78299: PUSH
78300: LD_INT 1
78302: NEG
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: LIST
78317: LIST
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: LIST
78323: LIST
78324: LIST
78325: LIST
78326: LIST
78327: LIST
78328: LIST
78329: LIST
78330: LIST
78331: LIST
78332: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
78333: LD_ADDR_VAR 0 24
78337: PUSH
78338: LD_INT 0
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 0
78350: PUSH
78351: LD_INT 1
78353: NEG
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: PUSH
78359: LD_INT 1
78361: PUSH
78362: LD_INT 0
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 1
78371: PUSH
78372: LD_INT 1
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 0
78381: PUSH
78382: LD_INT 1
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: PUSH
78389: LD_INT 1
78391: NEG
78392: PUSH
78393: LD_INT 0
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 1
78402: NEG
78403: PUSH
78404: LD_INT 1
78406: NEG
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 1
78414: NEG
78415: PUSH
78416: LD_INT 2
78418: NEG
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: LD_INT 2
78429: NEG
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 1
78437: PUSH
78438: LD_INT 1
78440: NEG
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 2
78448: PUSH
78449: LD_INT 0
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 2
78458: PUSH
78459: LD_INT 1
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 2
78468: PUSH
78469: LD_INT 2
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 1
78478: PUSH
78479: LD_INT 2
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 1
78498: NEG
78499: PUSH
78500: LD_INT 1
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 2
78509: NEG
78510: PUSH
78511: LD_INT 0
78513: PUSH
78514: EMPTY
78515: LIST
78516: LIST
78517: PUSH
78518: LD_INT 2
78520: NEG
78521: PUSH
78522: LD_INT 1
78524: NEG
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 2
78532: NEG
78533: PUSH
78534: LD_INT 2
78536: NEG
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 1
78544: PUSH
78545: LD_INT 2
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 2
78555: PUSH
78556: LD_INT 1
78558: NEG
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 3
78566: PUSH
78567: LD_INT 1
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 3
78576: PUSH
78577: LD_INT 2
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
78609: LD_ADDR_VAR 0 25
78613: PUSH
78614: LD_INT 0
78616: PUSH
78617: LD_INT 0
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: LD_INT 1
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: LD_INT 0
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: LD_INT 1
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 0
78657: PUSH
78658: LD_INT 1
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 1
78667: NEG
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PUSH
78676: LD_INT 1
78678: NEG
78679: PUSH
78680: LD_INT 1
78682: NEG
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 1
78690: NEG
78691: PUSH
78692: LD_INT 2
78694: NEG
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 0
78702: PUSH
78703: LD_INT 2
78705: NEG
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 1
78713: PUSH
78714: LD_INT 1
78716: NEG
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 2
78724: PUSH
78725: LD_INT 0
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 2
78734: PUSH
78735: LD_INT 1
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: LD_INT 2
78744: PUSH
78745: LD_INT 2
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: LD_INT 2
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: LD_INT 0
78764: PUSH
78765: LD_INT 2
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 1
78774: NEG
78775: PUSH
78776: LD_INT 1
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 2
78785: NEG
78786: PUSH
78787: LD_INT 0
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 2
78796: NEG
78797: PUSH
78798: LD_INT 1
78800: NEG
78801: PUSH
78802: EMPTY
78803: LIST
78804: LIST
78805: PUSH
78806: LD_INT 2
78808: NEG
78809: PUSH
78810: LD_INT 2
78812: NEG
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: LD_INT 3
78820: PUSH
78821: LD_INT 1
78823: PUSH
78824: EMPTY
78825: LIST
78826: LIST
78827: PUSH
78828: LD_INT 3
78830: PUSH
78831: LD_INT 2
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 2
78840: PUSH
78841: LD_INT 3
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 3
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: LIST
78881: LIST
78882: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78883: LD_ADDR_VAR 0 26
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: LD_INT 0
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 0
78900: PUSH
78901: LD_INT 1
78903: NEG
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 1
78911: PUSH
78912: LD_INT 0
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 1
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 0
78931: PUSH
78932: LD_INT 1
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 1
78941: NEG
78942: PUSH
78943: LD_INT 0
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 1
78952: NEG
78953: PUSH
78954: LD_INT 1
78956: NEG
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 1
78964: NEG
78965: PUSH
78966: LD_INT 2
78968: NEG
78969: PUSH
78970: EMPTY
78971: LIST
78972: LIST
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: LD_INT 2
78979: NEG
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: LD_INT 1
78990: NEG
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 2
78998: PUSH
78999: LD_INT 0
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 2
79008: PUSH
79009: LD_INT 1
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 2
79018: PUSH
79019: LD_INT 2
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 1
79028: PUSH
79029: LD_INT 2
79031: PUSH
79032: EMPTY
79033: LIST
79034: LIST
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: LD_INT 2
79041: PUSH
79042: EMPTY
79043: LIST
79044: LIST
79045: PUSH
79046: LD_INT 1
79048: NEG
79049: PUSH
79050: LD_INT 1
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 2
79059: NEG
79060: PUSH
79061: LD_INT 0
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 2
79070: NEG
79071: PUSH
79072: LD_INT 1
79074: NEG
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 2
79082: NEG
79083: PUSH
79084: LD_INT 2
79086: NEG
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 2
79094: PUSH
79095: LD_INT 3
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 1
79104: PUSH
79105: LD_INT 3
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 1
79114: NEG
79115: PUSH
79116: LD_INT 2
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 2
79125: NEG
79126: PUSH
79127: LD_INT 1
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79159: LD_ADDR_VAR 0 27
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: LD_INT 0
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 1
79187: PUSH
79188: LD_INT 0
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 1
79197: PUSH
79198: LD_INT 1
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 0
79207: PUSH
79208: LD_INT 1
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: LD_INT 0
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 1
79228: NEG
79229: PUSH
79230: LD_INT 1
79232: NEG
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 1
79240: NEG
79241: PUSH
79242: LD_INT 2
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 0
79252: PUSH
79253: LD_INT 2
79255: NEG
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: PUSH
79261: LD_INT 1
79263: PUSH
79264: LD_INT 1
79266: NEG
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 2
79274: PUSH
79275: LD_INT 0
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 2
79284: PUSH
79285: LD_INT 1
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 2
79294: PUSH
79295: LD_INT 2
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 1
79304: PUSH
79305: LD_INT 2
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 0
79314: PUSH
79315: LD_INT 2
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 1
79324: NEG
79325: PUSH
79326: LD_INT 1
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 2
79335: NEG
79336: PUSH
79337: LD_INT 0
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 2
79346: NEG
79347: PUSH
79348: LD_INT 1
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 2
79358: NEG
79359: PUSH
79360: LD_INT 2
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 1
79370: NEG
79371: PUSH
79372: LD_INT 2
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 2
79381: NEG
79382: PUSH
79383: LD_INT 1
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 3
79392: NEG
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 3
79404: NEG
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: EMPTY
79411: LIST
79412: LIST
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79439: LD_ADDR_VAR 0 28
79443: PUSH
79444: LD_INT 0
79446: PUSH
79447: LD_INT 0
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 0
79456: PUSH
79457: LD_INT 1
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: PUSH
79468: LD_INT 0
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 1
79477: PUSH
79478: LD_INT 1
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 0
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 1
79497: NEG
79498: PUSH
79499: LD_INT 0
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 1
79508: NEG
79509: PUSH
79510: LD_INT 1
79512: NEG
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 1
79520: NEG
79521: PUSH
79522: LD_INT 2
79524: NEG
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 0
79532: PUSH
79533: LD_INT 2
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 1
79543: PUSH
79544: LD_INT 1
79546: NEG
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 2
79554: PUSH
79555: LD_INT 0
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 2
79564: PUSH
79565: LD_INT 1
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 2
79574: PUSH
79575: LD_INT 2
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: PUSH
79585: LD_INT 2
79587: PUSH
79588: EMPTY
79589: LIST
79590: LIST
79591: PUSH
79592: LD_INT 0
79594: PUSH
79595: LD_INT 2
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 1
79604: NEG
79605: PUSH
79606: LD_INT 1
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 2
79615: NEG
79616: PUSH
79617: LD_INT 0
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 2
79626: NEG
79627: PUSH
79628: LD_INT 1
79630: NEG
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 2
79638: NEG
79639: PUSH
79640: LD_INT 2
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 2
79650: NEG
79651: PUSH
79652: LD_INT 3
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 1
79662: NEG
79663: PUSH
79664: LD_INT 3
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 3
79674: NEG
79675: PUSH
79676: LD_INT 1
79678: NEG
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 3
79686: NEG
79687: PUSH
79688: LD_INT 2
79690: NEG
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79721: LD_ADDR_VAR 0 29
79725: PUSH
79726: LD_INT 0
79728: PUSH
79729: LD_INT 0
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 0
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 1
79749: PUSH
79750: LD_INT 0
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 1
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 0
79769: PUSH
79770: LD_INT 1
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: LD_INT 1
79779: NEG
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 1
79790: NEG
79791: PUSH
79792: LD_INT 1
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 1
79802: NEG
79803: PUSH
79804: LD_INT 2
79806: NEG
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 2
79817: NEG
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: LD_INT 1
79828: NEG
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 2
79836: PUSH
79837: LD_INT 0
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: PUSH
79844: LD_INT 2
79846: PUSH
79847: LD_INT 1
79849: PUSH
79850: EMPTY
79851: LIST
79852: LIST
79853: PUSH
79854: LD_INT 1
79856: PUSH
79857: LD_INT 2
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 0
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 1
79876: NEG
79877: PUSH
79878: LD_INT 1
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 2
79887: NEG
79888: PUSH
79889: LD_INT 1
79891: NEG
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 2
79899: NEG
79900: PUSH
79901: LD_INT 2
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 2
79911: NEG
79912: PUSH
79913: LD_INT 3
79915: NEG
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 2
79923: PUSH
79924: LD_INT 1
79926: NEG
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 3
79934: PUSH
79935: LD_INT 1
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: LD_INT 1
79944: PUSH
79945: LD_INT 3
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 1
79954: NEG
79955: PUSH
79956: LD_INT 2
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 3
79965: NEG
79966: PUSH
79967: LD_INT 2
79969: NEG
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: LIST
79987: LIST
79988: LIST
79989: LIST
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: LIST
79997: LIST
79998: LIST
79999: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80000: LD_ADDR_VAR 0 30
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: LD_INT 0
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: LD_INT 1
80020: NEG
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 0
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 1
80038: PUSH
80039: LD_INT 1
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 0
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 1
80058: NEG
80059: PUSH
80060: LD_INT 0
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 1
80069: NEG
80070: PUSH
80071: LD_INT 1
80073: NEG
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 1
80081: NEG
80082: PUSH
80083: LD_INT 2
80085: NEG
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 0
80093: PUSH
80094: LD_INT 2
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 1
80104: PUSH
80105: LD_INT 1
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 2
80115: PUSH
80116: LD_INT 0
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PUSH
80123: LD_INT 2
80125: PUSH
80126: LD_INT 1
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: LD_INT 2
80135: PUSH
80136: LD_INT 2
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 1
80145: PUSH
80146: LD_INT 2
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 1
80155: NEG
80156: PUSH
80157: LD_INT 1
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 2
80166: NEG
80167: PUSH
80168: LD_INT 0
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 2
80177: NEG
80178: PUSH
80179: LD_INT 1
80181: NEG
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: LD_INT 3
80193: NEG
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: PUSH
80199: LD_INT 1
80201: PUSH
80202: LD_INT 2
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 3
80212: PUSH
80213: LD_INT 2
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 2
80222: PUSH
80223: LD_INT 3
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 2
80232: NEG
80233: PUSH
80234: LD_INT 1
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 3
80243: NEG
80244: PUSH
80245: LD_INT 1
80247: NEG
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80278: LD_ADDR_VAR 0 31
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: LD_INT 0
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 0
80295: PUSH
80296: LD_INT 1
80298: NEG
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 1
80306: PUSH
80307: LD_INT 0
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 1
80316: PUSH
80317: LD_INT 1
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 0
80326: PUSH
80327: LD_INT 1
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: LD_INT 1
80336: NEG
80337: PUSH
80338: LD_INT 0
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 1
80347: NEG
80348: PUSH
80349: LD_INT 1
80351: NEG
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: NEG
80360: PUSH
80361: LD_INT 2
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 1
80371: PUSH
80372: LD_INT 1
80374: NEG
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 2
80382: PUSH
80383: LD_INT 0
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 2
80392: PUSH
80393: LD_INT 1
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: PUSH
80400: LD_INT 2
80402: PUSH
80403: LD_INT 2
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: LD_INT 2
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 0
80422: PUSH
80423: LD_INT 2
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 1
80432: NEG
80433: PUSH
80434: LD_INT 1
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PUSH
80441: LD_INT 2
80443: NEG
80444: PUSH
80445: LD_INT 1
80447: NEG
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 2
80455: NEG
80456: PUSH
80457: LD_INT 2
80459: NEG
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 2
80467: NEG
80468: PUSH
80469: LD_INT 3
80471: NEG
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 2
80479: PUSH
80480: LD_INT 1
80482: NEG
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: LD_INT 1
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 1
80500: PUSH
80501: LD_INT 3
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 1
80510: NEG
80511: PUSH
80512: LD_INT 2
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 3
80521: NEG
80522: PUSH
80523: LD_INT 2
80525: NEG
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: LIST
80554: LIST
80555: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80556: LD_ADDR_VAR 0 32
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: LD_INT 0
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: LD_INT 1
80576: NEG
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: PUSH
80582: LD_INT 1
80584: PUSH
80585: LD_INT 0
80587: PUSH
80588: EMPTY
80589: LIST
80590: LIST
80591: PUSH
80592: LD_INT 1
80594: PUSH
80595: LD_INT 1
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: LD_INT 1
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: NEG
80615: PUSH
80616: LD_INT 0
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 1
80625: NEG
80626: PUSH
80627: LD_INT 1
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 2
80641: NEG
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: LD_INT 2
80652: NEG
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: PUSH
80661: LD_INT 1
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 2
80671: PUSH
80672: LD_INT 1
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 2
80681: PUSH
80682: LD_INT 2
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 1
80691: PUSH
80692: LD_INT 2
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 0
80701: PUSH
80702: LD_INT 2
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 1
80711: NEG
80712: PUSH
80713: LD_INT 1
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 2
80722: NEG
80723: PUSH
80724: LD_INT 0
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 2
80733: NEG
80734: PUSH
80735: LD_INT 1
80737: NEG
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 1
80745: NEG
80746: PUSH
80747: LD_INT 3
80749: NEG
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 1
80757: PUSH
80758: LD_INT 2
80760: NEG
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 3
80768: PUSH
80769: LD_INT 2
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 2
80778: PUSH
80779: LD_INT 3
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 2
80788: NEG
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 3
80799: NEG
80800: PUSH
80801: LD_INT 1
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80834: LD_ADDR_VAR 0 33
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 0
80851: PUSH
80852: LD_INT 1
80854: NEG
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: LD_INT 1
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: EMPTY
80867: LIST
80868: LIST
80869: PUSH
80870: LD_INT 1
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 0
80882: PUSH
80883: LD_INT 1
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: LD_INT 1
80892: NEG
80893: PUSH
80894: LD_INT 0
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 1
80903: NEG
80904: PUSH
80905: LD_INT 1
80907: NEG
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 1
80915: NEG
80916: PUSH
80917: LD_INT 2
80919: NEG
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 1
80927: PUSH
80928: LD_INT 1
80930: NEG
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 2
80938: PUSH
80939: LD_INT 0
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 2
80948: PUSH
80949: LD_INT 1
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 1
80958: PUSH
80959: LD_INT 2
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 0
80968: PUSH
80969: LD_INT 2
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: NEG
80979: PUSH
80980: LD_INT 1
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 2
80989: NEG
80990: PUSH
80991: LD_INT 0
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PUSH
80998: LD_INT 2
81000: NEG
81001: PUSH
81002: LD_INT 1
81004: NEG
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: NEG
81013: PUSH
81014: LD_INT 2
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 2
81024: NEG
81025: PUSH
81026: LD_INT 3
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 2
81036: PUSH
81037: LD_INT 1
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 3
81047: PUSH
81048: LD_INT 1
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 1
81057: PUSH
81058: LD_INT 3
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 1
81067: NEG
81068: PUSH
81069: LD_INT 2
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 3
81078: NEG
81079: PUSH
81080: LD_INT 2
81082: NEG
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: LIST
81097: LIST
81098: LIST
81099: LIST
81100: LIST
81101: LIST
81102: LIST
81103: LIST
81104: LIST
81105: LIST
81106: LIST
81107: LIST
81108: LIST
81109: LIST
81110: LIST
81111: LIST
81112: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81113: LD_ADDR_VAR 0 34
81117: PUSH
81118: LD_INT 0
81120: PUSH
81121: LD_INT 0
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 0
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 1
81141: PUSH
81142: LD_INT 0
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 1
81151: PUSH
81152: LD_INT 1
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 0
81161: PUSH
81162: LD_INT 1
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 1
81171: NEG
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 1
81182: NEG
81183: PUSH
81184: LD_INT 1
81186: NEG
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 1
81194: NEG
81195: PUSH
81196: LD_INT 2
81198: NEG
81199: PUSH
81200: EMPTY
81201: LIST
81202: LIST
81203: PUSH
81204: LD_INT 0
81206: PUSH
81207: LD_INT 2
81209: NEG
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 2
81228: PUSH
81229: LD_INT 1
81231: PUSH
81232: EMPTY
81233: LIST
81234: LIST
81235: PUSH
81236: LD_INT 2
81238: PUSH
81239: LD_INT 2
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 1
81248: PUSH
81249: LD_INT 2
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: LD_INT 1
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 2
81269: NEG
81270: PUSH
81271: LD_INT 0
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 2
81280: NEG
81281: PUSH
81282: LD_INT 1
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 2
81292: NEG
81293: PUSH
81294: LD_INT 2
81296: NEG
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: LD_INT 1
81304: NEG
81305: PUSH
81306: LD_INT 3
81308: NEG
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 1
81316: PUSH
81317: LD_INT 2
81319: NEG
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 3
81327: PUSH
81328: LD_INT 2
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 2
81337: PUSH
81338: LD_INT 3
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 2
81347: NEG
81348: PUSH
81349: LD_INT 1
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 3
81358: NEG
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: LIST
81392: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
81393: LD_ADDR_VAR 0 35
81397: PUSH
81398: LD_INT 0
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 0
81410: PUSH
81411: LD_INT 1
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 1
81421: PUSH
81422: LD_INT 0
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 1
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 0
81441: PUSH
81442: LD_INT 1
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 1
81451: NEG
81452: PUSH
81453: LD_INT 0
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 1
81462: NEG
81463: PUSH
81464: LD_INT 1
81466: NEG
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 2
81474: PUSH
81475: LD_INT 1
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: PUSH
81482: LD_INT 2
81484: NEG
81485: PUSH
81486: LD_INT 1
81488: NEG
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81505: LD_ADDR_VAR 0 36
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 0
81522: PUSH
81523: LD_INT 1
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: LD_INT 0
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: LD_INT 1
81543: PUSH
81544: LD_INT 1
81546: PUSH
81547: EMPTY
81548: LIST
81549: LIST
81550: PUSH
81551: LD_INT 0
81553: PUSH
81554: LD_INT 1
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 1
81563: NEG
81564: PUSH
81565: LD_INT 0
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 1
81574: NEG
81575: PUSH
81576: LD_INT 1
81578: NEG
81579: PUSH
81580: EMPTY
81581: LIST
81582: LIST
81583: PUSH
81584: LD_INT 1
81586: NEG
81587: PUSH
81588: LD_INT 2
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 1
81598: PUSH
81599: LD_INT 2
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81617: LD_ADDR_VAR 0 37
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: LD_INT 0
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 0
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 1
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: LD_INT 0
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: LD_INT 1
81690: NEG
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 1
81698: PUSH
81699: LD_INT 1
81701: NEG
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 1
81709: NEG
81710: PUSH
81711: LD_INT 1
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
81729: LD_ADDR_VAR 0 38
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: LD_INT 0
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 0
81746: PUSH
81747: LD_INT 1
81749: NEG
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 1
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 1
81767: PUSH
81768: LD_INT 1
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 0
81777: PUSH
81778: LD_INT 1
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: NEG
81788: PUSH
81789: LD_INT 0
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 1
81798: NEG
81799: PUSH
81800: LD_INT 1
81802: NEG
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 2
81810: PUSH
81811: LD_INT 1
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 2
81820: NEG
81821: PUSH
81822: LD_INT 1
81824: NEG
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81841: LD_ADDR_VAR 0 39
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: EMPTY
81853: LIST
81854: LIST
81855: PUSH
81856: LD_INT 0
81858: PUSH
81859: LD_INT 1
81861: NEG
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 1
81869: PUSH
81870: LD_INT 0
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 1
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 0
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 1
81899: NEG
81900: PUSH
81901: LD_INT 0
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 1
81910: NEG
81911: PUSH
81912: LD_INT 1
81914: NEG
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: LD_INT 2
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 1
81934: PUSH
81935: LD_INT 2
81937: PUSH
81938: EMPTY
81939: LIST
81940: LIST
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81953: LD_ADDR_VAR 0 40
81957: PUSH
81958: LD_INT 0
81960: PUSH
81961: LD_INT 0
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: LD_INT 1
81973: NEG
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 1
81981: PUSH
81982: LD_INT 0
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 1
81991: PUSH
81992: LD_INT 1
81994: PUSH
81995: EMPTY
81996: LIST
81997: LIST
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: LD_INT 1
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 1
82011: NEG
82012: PUSH
82013: LD_INT 0
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 1
82022: NEG
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 1
82034: PUSH
82035: LD_INT 1
82037: NEG
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 1
82045: NEG
82046: PUSH
82047: LD_INT 1
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82065: LD_ADDR_VAR 0 41
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 0
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 0
82082: PUSH
82083: LD_INT 1
82085: NEG
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: LD_INT 0
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: LD_INT 1
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 0
82113: PUSH
82114: LD_INT 1
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: LD_INT 0
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 1
82134: NEG
82135: PUSH
82136: LD_INT 1
82138: NEG
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 1
82146: NEG
82147: PUSH
82148: LD_INT 2
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 1
82158: PUSH
82159: LD_INT 1
82161: NEG
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 2
82169: PUSH
82170: LD_INT 0
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 2
82179: PUSH
82180: LD_INT 1
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 2
82189: PUSH
82190: LD_INT 2
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 1
82199: PUSH
82200: LD_INT 2
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 1
82209: NEG
82210: PUSH
82211: LD_INT 1
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 2
82220: NEG
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 2
82231: NEG
82232: PUSH
82233: LD_INT 1
82235: NEG
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 2
82243: NEG
82244: PUSH
82245: LD_INT 2
82247: NEG
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 2
82255: NEG
82256: PUSH
82257: LD_INT 3
82259: NEG
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 2
82267: PUSH
82268: LD_INT 1
82270: NEG
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 3
82278: PUSH
82279: LD_INT 0
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 3
82288: PUSH
82289: LD_INT 1
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 3
82298: PUSH
82299: LD_INT 2
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 3
82308: PUSH
82309: LD_INT 3
82311: PUSH
82312: EMPTY
82313: LIST
82314: LIST
82315: PUSH
82316: LD_INT 2
82318: PUSH
82319: LD_INT 3
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 2
82328: NEG
82329: PUSH
82330: LD_INT 1
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 3
82339: NEG
82340: PUSH
82341: LD_INT 0
82343: PUSH
82344: EMPTY
82345: LIST
82346: LIST
82347: PUSH
82348: LD_INT 3
82350: NEG
82351: PUSH
82352: LD_INT 1
82354: NEG
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PUSH
82360: LD_INT 3
82362: NEG
82363: PUSH
82364: LD_INT 2
82366: NEG
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 3
82374: NEG
82375: PUSH
82376: LD_INT 3
82378: NEG
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82415: LD_ADDR_VAR 0 42
82419: PUSH
82420: LD_INT 0
82422: PUSH
82423: LD_INT 0
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 0
82432: PUSH
82433: LD_INT 1
82435: NEG
82436: PUSH
82437: EMPTY
82438: LIST
82439: LIST
82440: PUSH
82441: LD_INT 1
82443: PUSH
82444: LD_INT 0
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 1
82453: PUSH
82454: LD_INT 1
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PUSH
82461: LD_INT 0
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: EMPTY
82468: LIST
82469: LIST
82470: PUSH
82471: LD_INT 1
82473: NEG
82474: PUSH
82475: LD_INT 0
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 1
82484: NEG
82485: PUSH
82486: LD_INT 1
82488: NEG
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 1
82496: NEG
82497: PUSH
82498: LD_INT 2
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 0
82508: PUSH
82509: LD_INT 2
82511: NEG
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 1
82519: PUSH
82520: LD_INT 1
82522: NEG
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 2
82530: PUSH
82531: LD_INT 1
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 2
82540: PUSH
82541: LD_INT 2
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 1
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 0
82560: PUSH
82561: LD_INT 2
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 1
82570: NEG
82571: PUSH
82572: LD_INT 1
82574: PUSH
82575: EMPTY
82576: LIST
82577: LIST
82578: PUSH
82579: LD_INT 2
82581: NEG
82582: PUSH
82583: LD_INT 1
82585: NEG
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 2
82593: NEG
82594: PUSH
82595: LD_INT 2
82597: NEG
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 2
82605: NEG
82606: PUSH
82607: LD_INT 3
82609: NEG
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: NEG
82618: PUSH
82619: LD_INT 3
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 0
82629: PUSH
82630: LD_INT 3
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: PUSH
82641: LD_INT 2
82643: NEG
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 3
82651: PUSH
82652: LD_INT 2
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 3
82661: PUSH
82662: LD_INT 3
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 2
82671: PUSH
82672: LD_INT 3
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 1
82681: PUSH
82682: LD_INT 3
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 0
82691: PUSH
82692: LD_INT 3
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 1
82701: NEG
82702: PUSH
82703: LD_INT 2
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 3
82712: NEG
82713: PUSH
82714: LD_INT 2
82716: NEG
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 3
82724: NEG
82725: PUSH
82726: LD_INT 3
82728: NEG
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: LIST
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82765: LD_ADDR_VAR 0 43
82769: PUSH
82770: LD_INT 0
82772: PUSH
82773: LD_INT 0
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 0
82782: PUSH
82783: LD_INT 1
82785: NEG
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 1
82793: PUSH
82794: LD_INT 0
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 1
82803: PUSH
82804: LD_INT 1
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 1
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: NEG
82824: PUSH
82825: LD_INT 0
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: NEG
82835: PUSH
82836: LD_INT 1
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 1
82846: NEG
82847: PUSH
82848: LD_INT 2
82850: NEG
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 0
82858: PUSH
82859: LD_INT 2
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 1
82869: PUSH
82870: LD_INT 1
82872: NEG
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 2
82880: PUSH
82881: LD_INT 0
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 2
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 1
82900: PUSH
82901: LD_INT 2
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 0
82910: PUSH
82911: LD_INT 2
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 1
82920: NEG
82921: PUSH
82922: LD_INT 1
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 2
82931: NEG
82932: PUSH
82933: LD_INT 0
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 2
82942: NEG
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 1
82954: NEG
82955: PUSH
82956: LD_INT 3
82958: NEG
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 0
82966: PUSH
82967: LD_INT 3
82969: NEG
82970: PUSH
82971: EMPTY
82972: LIST
82973: LIST
82974: PUSH
82975: LD_INT 1
82977: PUSH
82978: LD_INT 2
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 2
82988: PUSH
82989: LD_INT 1
82991: NEG
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 3
82999: PUSH
83000: LD_INT 0
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 3
83009: PUSH
83010: LD_INT 1
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 1
83019: PUSH
83020: LD_INT 3
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 0
83029: PUSH
83030: LD_INT 3
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: PUSH
83037: LD_INT 1
83039: NEG
83040: PUSH
83041: LD_INT 2
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 2
83050: NEG
83051: PUSH
83052: LD_INT 1
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 3
83061: NEG
83062: PUSH
83063: LD_INT 0
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 3
83072: NEG
83073: PUSH
83074: LD_INT 1
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83113: LD_ADDR_VAR 0 44
83117: PUSH
83118: LD_INT 0
83120: PUSH
83121: LD_INT 0
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: LD_INT 1
83133: NEG
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 1
83141: PUSH
83142: LD_INT 0
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: PUSH
83152: LD_INT 1
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PUSH
83159: LD_INT 0
83161: PUSH
83162: LD_INT 1
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: LD_INT 0
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 1
83182: NEG
83183: PUSH
83184: LD_INT 1
83186: NEG
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 1
83194: NEG
83195: PUSH
83196: LD_INT 2
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 1
83206: PUSH
83207: LD_INT 1
83209: NEG
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 2
83217: PUSH
83218: LD_INT 0
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 2
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 2
83237: PUSH
83238: LD_INT 2
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 1
83247: PUSH
83248: LD_INT 2
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 1
83257: NEG
83258: PUSH
83259: LD_INT 1
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 2
83268: NEG
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 2
83279: NEG
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: PUSH
83289: LD_INT 2
83291: NEG
83292: PUSH
83293: LD_INT 2
83295: NEG
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 2
83303: NEG
83304: PUSH
83305: LD_INT 3
83307: NEG
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 2
83315: PUSH
83316: LD_INT 1
83318: NEG
83319: PUSH
83320: EMPTY
83321: LIST
83322: LIST
83323: PUSH
83324: LD_INT 3
83326: PUSH
83327: LD_INT 0
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 3
83336: PUSH
83337: LD_INT 1
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 3
83346: PUSH
83347: LD_INT 2
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 3
83356: PUSH
83357: LD_INT 3
83359: PUSH
83360: EMPTY
83361: LIST
83362: LIST
83363: PUSH
83364: LD_INT 2
83366: PUSH
83367: LD_INT 3
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 2
83376: NEG
83377: PUSH
83378: LD_INT 1
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 3
83387: NEG
83388: PUSH
83389: LD_INT 0
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 3
83398: NEG
83399: PUSH
83400: LD_INT 1
83402: NEG
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 3
83410: NEG
83411: PUSH
83412: LD_INT 2
83414: NEG
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 3
83422: NEG
83423: PUSH
83424: LD_INT 3
83426: NEG
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: LIST
83450: LIST
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: LIST
83460: LIST
83461: LIST
83462: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83463: LD_ADDR_VAR 0 45
83467: PUSH
83468: LD_INT 0
83470: PUSH
83471: LD_INT 0
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 0
83480: PUSH
83481: LD_INT 1
83483: NEG
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: PUSH
83492: LD_INT 0
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 1
83501: PUSH
83502: LD_INT 1
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 0
83511: PUSH
83512: LD_INT 1
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 1
83521: NEG
83522: PUSH
83523: LD_INT 0
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 1
83532: NEG
83533: PUSH
83534: LD_INT 1
83536: NEG
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: NEG
83545: PUSH
83546: LD_INT 2
83548: NEG
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PUSH
83554: LD_INT 0
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 1
83567: PUSH
83568: LD_INT 1
83570: NEG
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: LD_INT 2
83578: PUSH
83579: LD_INT 1
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 2
83588: PUSH
83589: LD_INT 2
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 1
83598: PUSH
83599: LD_INT 2
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: LD_INT 0
83608: PUSH
83609: LD_INT 2
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: LD_INT 1
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: LD_INT 2
83629: NEG
83630: PUSH
83631: LD_INT 1
83633: NEG
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 2
83641: NEG
83642: PUSH
83643: LD_INT 2
83645: NEG
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 2
83653: NEG
83654: PUSH
83655: LD_INT 3
83657: NEG
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: LD_INT 1
83665: NEG
83666: PUSH
83667: LD_INT 3
83669: NEG
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 0
83677: PUSH
83678: LD_INT 3
83680: NEG
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 1
83688: PUSH
83689: LD_INT 2
83691: NEG
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 3
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 3
83709: PUSH
83710: LD_INT 3
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 2
83719: PUSH
83720: LD_INT 3
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: PUSH
83727: LD_INT 1
83729: PUSH
83730: LD_INT 3
83732: PUSH
83733: EMPTY
83734: LIST
83735: LIST
83736: PUSH
83737: LD_INT 0
83739: PUSH
83740: LD_INT 3
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: LD_INT 1
83749: NEG
83750: PUSH
83751: LD_INT 2
83753: PUSH
83754: EMPTY
83755: LIST
83756: LIST
83757: PUSH
83758: LD_INT 3
83760: NEG
83761: PUSH
83762: LD_INT 2
83764: NEG
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 3
83772: NEG
83773: PUSH
83774: LD_INT 3
83776: NEG
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83813: LD_ADDR_VAR 0 46
83817: PUSH
83818: LD_INT 0
83820: PUSH
83821: LD_INT 0
83823: PUSH
83824: EMPTY
83825: LIST
83826: LIST
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: LD_INT 1
83833: NEG
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: PUSH
83839: LD_INT 1
83841: PUSH
83842: LD_INT 0
83844: PUSH
83845: EMPTY
83846: LIST
83847: LIST
83848: PUSH
83849: LD_INT 1
83851: PUSH
83852: LD_INT 1
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: LD_INT 1
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 1
83871: NEG
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 1
83882: NEG
83883: PUSH
83884: LD_INT 1
83886: NEG
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 1
83894: NEG
83895: PUSH
83896: LD_INT 2
83898: NEG
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 0
83906: PUSH
83907: LD_INT 2
83909: NEG
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 1
83917: PUSH
83918: LD_INT 1
83920: NEG
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 2
83928: PUSH
83929: LD_INT 0
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 2
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: LD_INT 2
83951: PUSH
83952: EMPTY
83953: LIST
83954: LIST
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: LD_INT 2
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 1
83968: NEG
83969: PUSH
83970: LD_INT 1
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: PUSH
83977: LD_INT 2
83979: NEG
83980: PUSH
83981: LD_INT 0
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: PUSH
83988: LD_INT 2
83990: NEG
83991: PUSH
83992: LD_INT 1
83994: NEG
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 1
84002: NEG
84003: PUSH
84004: LD_INT 3
84006: NEG
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 0
84014: PUSH
84015: LD_INT 3
84017: NEG
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PUSH
84023: LD_INT 1
84025: PUSH
84026: LD_INT 2
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 2
84036: PUSH
84037: LD_INT 1
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 3
84047: PUSH
84048: LD_INT 0
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 3
84057: PUSH
84058: LD_INT 1
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 1
84067: PUSH
84068: LD_INT 3
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 0
84077: PUSH
84078: LD_INT 3
84080: PUSH
84081: EMPTY
84082: LIST
84083: LIST
84084: PUSH
84085: LD_INT 1
84087: NEG
84088: PUSH
84089: LD_INT 2
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 2
84098: NEG
84099: PUSH
84100: LD_INT 1
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 3
84109: NEG
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 3
84120: NEG
84121: PUSH
84122: LD_INT 1
84124: NEG
84125: PUSH
84126: EMPTY
84127: LIST
84128: LIST
84129: PUSH
84130: EMPTY
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84161: LD_ADDR_VAR 0 47
84165: PUSH
84166: LD_INT 0
84168: PUSH
84169: LD_INT 0
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 0
84178: PUSH
84179: LD_INT 1
84181: NEG
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: LD_INT 0
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 1
84199: PUSH
84200: LD_INT 1
84202: PUSH
84203: EMPTY
84204: LIST
84205: LIST
84206: PUSH
84207: LD_INT 0
84209: PUSH
84210: LD_INT 1
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: PUSH
84217: LD_INT 1
84219: NEG
84220: PUSH
84221: LD_INT 0
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 1
84230: NEG
84231: PUSH
84232: LD_INT 1
84234: NEG
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 1
84242: NEG
84243: PUSH
84244: LD_INT 2
84246: NEG
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 0
84254: PUSH
84255: LD_INT 2
84257: NEG
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: LD_INT 1
84268: NEG
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: LD_INT 2
84276: NEG
84277: PUSH
84278: LD_INT 1
84280: NEG
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 2
84288: NEG
84289: PUSH
84290: LD_INT 2
84292: NEG
84293: PUSH
84294: EMPTY
84295: LIST
84296: LIST
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
84312: LD_ADDR_VAR 0 48
84316: PUSH
84317: LD_INT 0
84319: PUSH
84320: LD_INT 0
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 0
84329: PUSH
84330: LD_INT 1
84332: NEG
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 1
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 1
84350: PUSH
84351: LD_INT 1
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 0
84360: PUSH
84361: LD_INT 1
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 1
84370: NEG
84371: PUSH
84372: LD_INT 0
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 1
84381: NEG
84382: PUSH
84383: LD_INT 1
84385: NEG
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 1
84393: NEG
84394: PUSH
84395: LD_INT 2
84397: NEG
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 0
84405: PUSH
84406: LD_INT 2
84408: NEG
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 1
84416: PUSH
84417: LD_INT 1
84419: NEG
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 2
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 2
84437: PUSH
84438: LD_INT 1
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
84459: LD_ADDR_VAR 0 49
84463: PUSH
84464: LD_INT 0
84466: PUSH
84467: LD_INT 0
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 0
84476: PUSH
84477: LD_INT 1
84479: NEG
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: LD_INT 0
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 1
84497: PUSH
84498: LD_INT 1
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 0
84507: PUSH
84508: LD_INT 1
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: LD_INT 0
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 1
84528: NEG
84529: PUSH
84530: LD_INT 1
84532: NEG
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 2
84551: PUSH
84552: LD_INT 0
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 2
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 2
84571: PUSH
84572: LD_INT 2
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 1
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
84603: LD_ADDR_VAR 0 50
84607: PUSH
84608: LD_INT 0
84610: PUSH
84611: LD_INT 0
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 0
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 1
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: PUSH
84642: LD_INT 1
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 0
84651: PUSH
84652: LD_INT 1
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: LD_INT 1
84672: NEG
84673: PUSH
84674: LD_INT 1
84676: NEG
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: LD_INT 1
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 2
84694: PUSH
84695: LD_INT 2
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 1
84704: PUSH
84705: LD_INT 2
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: LD_INT 0
84714: PUSH
84715: LD_INT 2
84717: PUSH
84718: EMPTY
84719: LIST
84720: LIST
84721: PUSH
84722: LD_INT 1
84724: NEG
84725: PUSH
84726: LD_INT 1
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
84747: LD_ADDR_VAR 0 51
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 0
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 0
84764: PUSH
84765: LD_INT 1
84767: NEG
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 1
84775: PUSH
84776: LD_INT 0
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 1
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 0
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 1
84805: NEG
84806: PUSH
84807: LD_INT 0
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: LD_INT 1
84820: NEG
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: LD_INT 2
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 0
84838: PUSH
84839: LD_INT 2
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 1
84848: NEG
84849: PUSH
84850: LD_INT 1
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: LD_INT 2
84859: NEG
84860: PUSH
84861: LD_INT 0
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 2
84870: NEG
84871: PUSH
84872: LD_INT 1
84874: NEG
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84894: LD_ADDR_VAR 0 52
84898: PUSH
84899: LD_INT 0
84901: PUSH
84902: LD_INT 0
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: LD_INT 1
84914: NEG
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 1
84922: PUSH
84923: LD_INT 0
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: LD_INT 1
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 0
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 1
84952: NEG
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 1
84963: NEG
84964: PUSH
84965: LD_INT 1
84967: NEG
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: PUSH
84973: LD_INT 1
84975: NEG
84976: PUSH
84977: LD_INT 2
84979: NEG
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 1
84987: NEG
84988: PUSH
84989: LD_INT 1
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 2
84998: NEG
84999: PUSH
85000: LD_INT 0
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 2
85009: NEG
85010: PUSH
85011: LD_INT 1
85013: NEG
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 2
85021: NEG
85022: PUSH
85023: LD_INT 2
85025: NEG
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: LIST
85043: LIST
85044: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85045: LD_ADDR_VAR 0 53
85049: PUSH
85050: LD_INT 0
85052: PUSH
85053: LD_INT 0
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: LD_INT 0
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: LD_INT 0
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 1
85083: PUSH
85084: LD_INT 1
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 0
85093: PUSH
85094: LD_INT 1
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 1
85103: NEG
85104: PUSH
85105: LD_INT 0
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 1
85114: NEG
85115: PUSH
85116: LD_INT 1
85118: NEG
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 1
85126: NEG
85127: PUSH
85128: LD_INT 2
85130: NEG
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 0
85138: PUSH
85139: LD_INT 2
85141: NEG
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: PUSH
85150: LD_INT 1
85152: NEG
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 2
85160: PUSH
85161: LD_INT 0
85163: PUSH
85164: EMPTY
85165: LIST
85166: LIST
85167: PUSH
85168: LD_INT 2
85170: PUSH
85171: LD_INT 1
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: PUSH
85178: LD_INT 2
85180: PUSH
85181: LD_INT 2
85183: PUSH
85184: EMPTY
85185: LIST
85186: LIST
85187: PUSH
85188: LD_INT 1
85190: PUSH
85191: LD_INT 2
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 0
85200: PUSH
85201: LD_INT 2
85203: PUSH
85204: EMPTY
85205: LIST
85206: LIST
85207: PUSH
85208: LD_INT 1
85210: NEG
85211: PUSH
85212: LD_INT 1
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 2
85221: NEG
85222: PUSH
85223: LD_INT 0
85225: PUSH
85226: EMPTY
85227: LIST
85228: LIST
85229: PUSH
85230: LD_INT 2
85232: NEG
85233: PUSH
85234: LD_INT 1
85236: NEG
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 2
85244: NEG
85245: PUSH
85246: LD_INT 2
85248: NEG
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: LIST
85260: LIST
85261: LIST
85262: LIST
85263: LIST
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: LIST
85273: LIST
85274: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85275: LD_ADDR_VAR 0 54
85279: PUSH
85280: LD_INT 0
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 0
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 1
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 0
85323: PUSH
85324: LD_INT 1
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: LD_INT 0
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: NEG
85357: PUSH
85358: LD_INT 2
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 0
85368: PUSH
85369: LD_INT 2
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 1
85379: PUSH
85380: LD_INT 1
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 2
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 2
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: PUSH
85411: LD_INT 2
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: PUSH
85421: LD_INT 2
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 0
85430: PUSH
85431: LD_INT 2
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 1
85440: NEG
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 2
85451: NEG
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 2
85462: NEG
85463: PUSH
85464: LD_INT 1
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 2
85474: NEG
85475: PUSH
85476: LD_INT 2
85478: NEG
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85505: LD_ADDR_VAR 0 55
85509: PUSH
85510: LD_INT 0
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 0
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 1
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 1
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 0
85553: PUSH
85554: LD_INT 1
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 1
85563: NEG
85564: PUSH
85565: LD_INT 0
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: PUSH
85572: LD_INT 1
85574: NEG
85575: PUSH
85576: LD_INT 1
85578: NEG
85579: PUSH
85580: EMPTY
85581: LIST
85582: LIST
85583: PUSH
85584: LD_INT 1
85586: NEG
85587: PUSH
85588: LD_INT 2
85590: NEG
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PUSH
85596: LD_INT 0
85598: PUSH
85599: LD_INT 2
85601: NEG
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 1
85609: PUSH
85610: LD_INT 1
85612: NEG
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 2
85620: PUSH
85621: LD_INT 0
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 2
85630: PUSH
85631: LD_INT 1
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 2
85640: PUSH
85641: LD_INT 2
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 1
85650: PUSH
85651: LD_INT 2
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 0
85660: PUSH
85661: LD_INT 2
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 1
85670: NEG
85671: PUSH
85672: LD_INT 1
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PUSH
85679: LD_INT 2
85681: NEG
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 2
85692: NEG
85693: PUSH
85694: LD_INT 1
85696: NEG
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: PUSH
85702: LD_INT 2
85704: NEG
85705: PUSH
85706: LD_INT 2
85708: NEG
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85735: LD_ADDR_VAR 0 56
85739: PUSH
85740: LD_INT 0
85742: PUSH
85743: LD_INT 0
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 0
85752: PUSH
85753: LD_INT 1
85755: NEG
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: LD_INT 1
85763: PUSH
85764: LD_INT 0
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: PUSH
85771: LD_INT 1
85773: PUSH
85774: LD_INT 1
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 0
85783: PUSH
85784: LD_INT 1
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 1
85793: NEG
85794: PUSH
85795: LD_INT 0
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 1
85804: NEG
85805: PUSH
85806: LD_INT 1
85808: NEG
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 1
85816: NEG
85817: PUSH
85818: LD_INT 2
85820: NEG
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: LD_INT 0
85828: PUSH
85829: LD_INT 2
85831: NEG
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: PUSH
85837: LD_INT 1
85839: PUSH
85840: LD_INT 1
85842: NEG
85843: PUSH
85844: EMPTY
85845: LIST
85846: LIST
85847: PUSH
85848: LD_INT 2
85850: PUSH
85851: LD_INT 0
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 2
85860: PUSH
85861: LD_INT 1
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 2
85870: PUSH
85871: LD_INT 2
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 1
85880: PUSH
85881: LD_INT 2
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 0
85890: PUSH
85891: LD_INT 2
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 1
85900: NEG
85901: PUSH
85902: LD_INT 1
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 2
85911: NEG
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 2
85922: NEG
85923: PUSH
85924: LD_INT 1
85926: NEG
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: PUSH
85932: LD_INT 2
85934: NEG
85935: PUSH
85936: LD_INT 2
85938: NEG
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85965: LD_ADDR_VAR 0 57
85969: PUSH
85970: LD_INT 0
85972: PUSH
85973: LD_INT 0
85975: PUSH
85976: EMPTY
85977: LIST
85978: LIST
85979: PUSH
85980: LD_INT 0
85982: PUSH
85983: LD_INT 1
85985: NEG
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: LD_INT 1
85993: PUSH
85994: LD_INT 0
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 1
86003: PUSH
86004: LD_INT 1
86006: PUSH
86007: EMPTY
86008: LIST
86009: LIST
86010: PUSH
86011: LD_INT 0
86013: PUSH
86014: LD_INT 1
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: LD_INT 0
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 1
86034: NEG
86035: PUSH
86036: LD_INT 1
86038: NEG
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: LD_INT 2
86050: NEG
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 0
86058: PUSH
86059: LD_INT 2
86061: NEG
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PUSH
86067: LD_INT 1
86069: PUSH
86070: LD_INT 1
86072: NEG
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 2
86080: PUSH
86081: LD_INT 0
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: LD_INT 1
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: LD_INT 2
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: PUSH
86108: LD_INT 1
86110: PUSH
86111: LD_INT 2
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 0
86120: PUSH
86121: LD_INT 2
86123: PUSH
86124: EMPTY
86125: LIST
86126: LIST
86127: PUSH
86128: LD_INT 1
86130: NEG
86131: PUSH
86132: LD_INT 1
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 2
86141: NEG
86142: PUSH
86143: LD_INT 0
86145: PUSH
86146: EMPTY
86147: LIST
86148: LIST
86149: PUSH
86150: LD_INT 2
86152: NEG
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 2
86164: NEG
86165: PUSH
86166: LD_INT 2
86168: NEG
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: LIST
86194: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86195: LD_ADDR_VAR 0 58
86199: PUSH
86200: LD_INT 0
86202: PUSH
86203: LD_INT 0
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: PUSH
86210: LD_INT 0
86212: PUSH
86213: LD_INT 1
86215: NEG
86216: PUSH
86217: EMPTY
86218: LIST
86219: LIST
86220: PUSH
86221: LD_INT 1
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 1
86233: PUSH
86234: LD_INT 1
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 0
86243: PUSH
86244: LD_INT 1
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: LD_INT 1
86253: NEG
86254: PUSH
86255: LD_INT 0
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: PUSH
86262: LD_INT 1
86264: NEG
86265: PUSH
86266: LD_INT 1
86268: NEG
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 1
86276: NEG
86277: PUSH
86278: LD_INT 2
86280: NEG
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: PUSH
86286: LD_INT 0
86288: PUSH
86289: LD_INT 2
86291: NEG
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 1
86299: PUSH
86300: LD_INT 1
86302: NEG
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 2
86310: PUSH
86311: LD_INT 0
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 2
86320: PUSH
86321: LD_INT 1
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 2
86330: PUSH
86331: LD_INT 2
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 1
86340: PUSH
86341: LD_INT 2
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 0
86350: PUSH
86351: LD_INT 2
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 1
86360: NEG
86361: PUSH
86362: LD_INT 1
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 2
86371: NEG
86372: PUSH
86373: LD_INT 0
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 2
86382: NEG
86383: PUSH
86384: LD_INT 1
86386: NEG
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_INT 2
86394: NEG
86395: PUSH
86396: LD_INT 2
86398: NEG
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86425: LD_ADDR_VAR 0 59
86429: PUSH
86430: LD_INT 0
86432: PUSH
86433: LD_INT 0
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 0
86442: PUSH
86443: LD_INT 1
86445: NEG
86446: PUSH
86447: EMPTY
86448: LIST
86449: LIST
86450: PUSH
86451: LD_INT 1
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 1
86463: PUSH
86464: LD_INT 1
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 0
86473: PUSH
86474: LD_INT 1
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 1
86483: NEG
86484: PUSH
86485: LD_INT 0
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 1
86494: NEG
86495: PUSH
86496: LD_INT 1
86498: NEG
86499: PUSH
86500: EMPTY
86501: LIST
86502: LIST
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86513: LD_ADDR_VAR 0 60
86517: PUSH
86518: LD_INT 0
86520: PUSH
86521: LD_INT 0
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 0
86530: PUSH
86531: LD_INT 1
86533: NEG
86534: PUSH
86535: EMPTY
86536: LIST
86537: LIST
86538: PUSH
86539: LD_INT 1
86541: PUSH
86542: LD_INT 0
86544: PUSH
86545: EMPTY
86546: LIST
86547: LIST
86548: PUSH
86549: LD_INT 1
86551: PUSH
86552: LD_INT 1
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 0
86561: PUSH
86562: LD_INT 1
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: NEG
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 1
86582: NEG
86583: PUSH
86584: LD_INT 1
86586: NEG
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: LIST
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86601: LD_ADDR_VAR 0 61
86605: PUSH
86606: LD_INT 0
86608: PUSH
86609: LD_INT 0
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: LD_INT 1
86621: NEG
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: LD_INT 1
86629: PUSH
86630: LD_INT 0
86632: PUSH
86633: EMPTY
86634: LIST
86635: LIST
86636: PUSH
86637: LD_INT 1
86639: PUSH
86640: LD_INT 1
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 0
86649: PUSH
86650: LD_INT 1
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PUSH
86657: LD_INT 1
86659: NEG
86660: PUSH
86661: LD_INT 0
86663: PUSH
86664: EMPTY
86665: LIST
86666: LIST
86667: PUSH
86668: LD_INT 1
86670: NEG
86671: PUSH
86672: LD_INT 1
86674: NEG
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86689: LD_ADDR_VAR 0 62
86693: PUSH
86694: LD_INT 0
86696: PUSH
86697: LD_INT 0
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 0
86706: PUSH
86707: LD_INT 1
86709: NEG
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 1
86717: PUSH
86718: LD_INT 0
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PUSH
86725: LD_INT 1
86727: PUSH
86728: LD_INT 1
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 0
86737: PUSH
86738: LD_INT 1
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 1
86747: NEG
86748: PUSH
86749: LD_INT 0
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: LD_INT 1
86762: NEG
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86777: LD_ADDR_VAR 0 63
86781: PUSH
86782: LD_INT 0
86784: PUSH
86785: LD_INT 0
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: LD_INT 0
86794: PUSH
86795: LD_INT 1
86797: NEG
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 1
86805: PUSH
86806: LD_INT 0
86808: PUSH
86809: EMPTY
86810: LIST
86811: LIST
86812: PUSH
86813: LD_INT 1
86815: PUSH
86816: LD_INT 1
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 0
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PUSH
86833: LD_INT 1
86835: NEG
86836: PUSH
86837: LD_INT 0
86839: PUSH
86840: EMPTY
86841: LIST
86842: LIST
86843: PUSH
86844: LD_INT 1
86846: NEG
86847: PUSH
86848: LD_INT 1
86850: NEG
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86865: LD_ADDR_VAR 0 64
86869: PUSH
86870: LD_INT 0
86872: PUSH
86873: LD_INT 0
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: LD_INT 0
86882: PUSH
86883: LD_INT 1
86885: NEG
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 1
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 1
86903: PUSH
86904: LD_INT 1
86906: PUSH
86907: EMPTY
86908: LIST
86909: LIST
86910: PUSH
86911: LD_INT 0
86913: PUSH
86914: LD_INT 1
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: PUSH
86921: LD_INT 1
86923: NEG
86924: PUSH
86925: LD_INT 0
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 1
86934: NEG
86935: PUSH
86936: LD_INT 1
86938: NEG
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: ST_TO_ADDR
// end ; 1 :
86953: GO 92850
86955: LD_INT 1
86957: DOUBLE
86958: EQUAL
86959: IFTRUE 86963
86961: GO 89586
86963: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86964: LD_ADDR_VAR 0 11
86968: PUSH
86969: LD_INT 1
86971: NEG
86972: PUSH
86973: LD_INT 3
86975: NEG
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 0
86983: PUSH
86984: LD_INT 3
86986: NEG
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_INT 1
86994: PUSH
86995: LD_INT 2
86997: NEG
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: LIST
87007: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87008: LD_ADDR_VAR 0 12
87012: PUSH
87013: LD_INT 2
87015: PUSH
87016: LD_INT 1
87018: NEG
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 3
87026: PUSH
87027: LD_INT 0
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 3
87036: PUSH
87037: LD_INT 1
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: LIST
87048: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
87049: LD_ADDR_VAR 0 13
87053: PUSH
87054: LD_INT 3
87056: PUSH
87057: LD_INT 2
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_INT 3
87066: PUSH
87067: LD_INT 3
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PUSH
87074: LD_INT 2
87076: PUSH
87077: LD_INT 3
87079: PUSH
87080: EMPTY
87081: LIST
87082: LIST
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: LIST
87088: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
87089: LD_ADDR_VAR 0 14
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: LD_INT 3
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 0
87106: PUSH
87107: LD_INT 3
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 1
87116: NEG
87117: PUSH
87118: LD_INT 2
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: LIST
87129: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87130: LD_ADDR_VAR 0 15
87134: PUSH
87135: LD_INT 2
87137: NEG
87138: PUSH
87139: LD_INT 1
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 3
87148: NEG
87149: PUSH
87150: LD_INT 0
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PUSH
87157: LD_INT 3
87159: NEG
87160: PUSH
87161: LD_INT 1
87163: NEG
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87174: LD_ADDR_VAR 0 16
87178: PUSH
87179: LD_INT 2
87181: NEG
87182: PUSH
87183: LD_INT 3
87185: NEG
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PUSH
87191: LD_INT 3
87193: NEG
87194: PUSH
87195: LD_INT 2
87197: NEG
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 3
87205: NEG
87206: PUSH
87207: LD_INT 3
87209: NEG
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: LIST
87219: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
87220: LD_ADDR_VAR 0 17
87224: PUSH
87225: LD_INT 1
87227: NEG
87228: PUSH
87229: LD_INT 3
87231: NEG
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: LD_INT 0
87239: PUSH
87240: LD_INT 3
87242: NEG
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: PUSH
87248: LD_INT 1
87250: PUSH
87251: LD_INT 2
87253: NEG
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: LIST
87263: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87264: LD_ADDR_VAR 0 18
87268: PUSH
87269: LD_INT 2
87271: PUSH
87272: LD_INT 1
87274: NEG
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 3
87282: PUSH
87283: LD_INT 0
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 3
87292: PUSH
87293: LD_INT 1
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: LIST
87304: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
87305: LD_ADDR_VAR 0 19
87309: PUSH
87310: LD_INT 3
87312: PUSH
87313: LD_INT 2
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 3
87322: PUSH
87323: LD_INT 3
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: LD_INT 3
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: LIST
87344: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
87345: LD_ADDR_VAR 0 20
87349: PUSH
87350: LD_INT 1
87352: PUSH
87353: LD_INT 3
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 0
87362: PUSH
87363: LD_INT 3
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: NEG
87373: PUSH
87374: LD_INT 2
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: LIST
87385: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87386: LD_ADDR_VAR 0 21
87390: PUSH
87391: LD_INT 2
87393: NEG
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 3
87404: NEG
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 3
87415: NEG
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: LIST
87429: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87430: LD_ADDR_VAR 0 22
87434: PUSH
87435: LD_INT 2
87437: NEG
87438: PUSH
87439: LD_INT 3
87441: NEG
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: LD_INT 3
87449: NEG
87450: PUSH
87451: LD_INT 2
87453: NEG
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: LD_INT 3
87461: NEG
87462: PUSH
87463: LD_INT 3
87465: NEG
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: LIST
87475: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
87476: LD_ADDR_VAR 0 23
87480: PUSH
87481: LD_INT 0
87483: PUSH
87484: LD_INT 3
87486: NEG
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: NEG
87495: PUSH
87496: LD_INT 4
87498: NEG
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: LD_INT 3
87509: NEG
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: LIST
87519: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
87520: LD_ADDR_VAR 0 24
87524: PUSH
87525: LD_INT 3
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 3
87537: PUSH
87538: LD_INT 1
87540: NEG
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 4
87548: PUSH
87549: LD_INT 1
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: LIST
87560: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
87561: LD_ADDR_VAR 0 25
87565: PUSH
87566: LD_INT 3
87568: PUSH
87569: LD_INT 3
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 4
87578: PUSH
87579: LD_INT 3
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 3
87588: PUSH
87589: LD_INT 4
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: EMPTY
87597: LIST
87598: LIST
87599: LIST
87600: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
87601: LD_ADDR_VAR 0 26
87605: PUSH
87606: LD_INT 0
87608: PUSH
87609: LD_INT 3
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: PUSH
87616: LD_INT 1
87618: PUSH
87619: LD_INT 4
87621: PUSH
87622: EMPTY
87623: LIST
87624: LIST
87625: PUSH
87626: LD_INT 1
87628: NEG
87629: PUSH
87630: LD_INT 3
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: EMPTY
87638: LIST
87639: LIST
87640: LIST
87641: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
87642: LD_ADDR_VAR 0 27
87646: PUSH
87647: LD_INT 3
87649: NEG
87650: PUSH
87651: LD_INT 0
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 3
87660: NEG
87661: PUSH
87662: LD_INT 1
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 4
87671: NEG
87672: PUSH
87673: LD_INT 1
87675: NEG
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: LIST
87685: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
87686: LD_ADDR_VAR 0 28
87690: PUSH
87691: LD_INT 3
87693: NEG
87694: PUSH
87695: LD_INT 3
87697: NEG
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 3
87705: NEG
87706: PUSH
87707: LD_INT 4
87709: NEG
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 4
87717: NEG
87718: PUSH
87719: LD_INT 3
87721: NEG
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: LIST
87731: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
87732: LD_ADDR_VAR 0 29
87736: PUSH
87737: LD_INT 1
87739: NEG
87740: PUSH
87741: LD_INT 3
87743: NEG
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: LD_INT 3
87754: NEG
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 1
87762: PUSH
87763: LD_INT 2
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 1
87773: NEG
87774: PUSH
87775: LD_INT 4
87777: NEG
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 0
87785: PUSH
87786: LD_INT 4
87788: NEG
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 1
87796: PUSH
87797: LD_INT 3
87799: NEG
87800: PUSH
87801: EMPTY
87802: LIST
87803: LIST
87804: PUSH
87805: LD_INT 1
87807: NEG
87808: PUSH
87809: LD_INT 5
87811: NEG
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 0
87819: PUSH
87820: LD_INT 5
87822: NEG
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 1
87830: PUSH
87831: LD_INT 4
87833: NEG
87834: PUSH
87835: EMPTY
87836: LIST
87837: LIST
87838: PUSH
87839: LD_INT 1
87841: NEG
87842: PUSH
87843: LD_INT 6
87845: NEG
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 0
87853: PUSH
87854: LD_INT 6
87856: NEG
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 1
87864: PUSH
87865: LD_INT 5
87867: NEG
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: LIST
87885: LIST
87886: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
87887: LD_ADDR_VAR 0 30
87891: PUSH
87892: LD_INT 2
87894: PUSH
87895: LD_INT 1
87897: NEG
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PUSH
87903: LD_INT 3
87905: PUSH
87906: LD_INT 0
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 3
87915: PUSH
87916: LD_INT 1
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 3
87925: PUSH
87926: LD_INT 1
87928: NEG
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 4
87936: PUSH
87937: LD_INT 0
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 4
87946: PUSH
87947: LD_INT 1
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 4
87956: PUSH
87957: LD_INT 1
87959: NEG
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: LD_INT 5
87967: PUSH
87968: LD_INT 0
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 5
87977: PUSH
87978: LD_INT 1
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 5
87987: PUSH
87988: LD_INT 1
87990: NEG
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: PUSH
87996: LD_INT 6
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: EMPTY
88003: LIST
88004: LIST
88005: PUSH
88006: LD_INT 6
88008: PUSH
88009: LD_INT 1
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
88030: LD_ADDR_VAR 0 31
88034: PUSH
88035: LD_INT 3
88037: PUSH
88038: LD_INT 2
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 3
88047: PUSH
88048: LD_INT 3
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 2
88057: PUSH
88058: LD_INT 3
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: LD_INT 4
88067: PUSH
88068: LD_INT 3
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 4
88077: PUSH
88078: LD_INT 4
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 3
88087: PUSH
88088: LD_INT 4
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 5
88097: PUSH
88098: LD_INT 4
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 5
88107: PUSH
88108: LD_INT 5
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 4
88117: PUSH
88118: LD_INT 5
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 6
88127: PUSH
88128: LD_INT 5
88130: PUSH
88131: EMPTY
88132: LIST
88133: LIST
88134: PUSH
88135: LD_INT 6
88137: PUSH
88138: LD_INT 6
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 5
88147: PUSH
88148: LD_INT 6
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
88169: LD_ADDR_VAR 0 32
88173: PUSH
88174: LD_INT 1
88176: PUSH
88177: LD_INT 3
88179: PUSH
88180: EMPTY
88181: LIST
88182: LIST
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: LD_INT 3
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: PUSH
88194: LD_INT 1
88196: NEG
88197: PUSH
88198: LD_INT 2
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 1
88207: PUSH
88208: LD_INT 4
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 4
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: LD_INT 3
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 1
88238: PUSH
88239: LD_INT 5
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 0
88248: PUSH
88249: LD_INT 5
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 1
88258: NEG
88259: PUSH
88260: LD_INT 4
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 1
88269: PUSH
88270: LD_INT 6
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 0
88279: PUSH
88280: LD_INT 6
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: PUSH
88287: LD_INT 1
88289: NEG
88290: PUSH
88291: LD_INT 5
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
88312: LD_ADDR_VAR 0 33
88316: PUSH
88317: LD_INT 2
88319: NEG
88320: PUSH
88321: LD_INT 1
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 3
88330: NEG
88331: PUSH
88332: LD_INT 0
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 3
88341: NEG
88342: PUSH
88343: LD_INT 1
88345: NEG
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 3
88353: NEG
88354: PUSH
88355: LD_INT 1
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 4
88364: NEG
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: EMPTY
88370: LIST
88371: LIST
88372: PUSH
88373: LD_INT 4
88375: NEG
88376: PUSH
88377: LD_INT 1
88379: NEG
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 4
88387: NEG
88388: PUSH
88389: LD_INT 1
88391: PUSH
88392: EMPTY
88393: LIST
88394: LIST
88395: PUSH
88396: LD_INT 5
88398: NEG
88399: PUSH
88400: LD_INT 0
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PUSH
88407: LD_INT 5
88409: NEG
88410: PUSH
88411: LD_INT 1
88413: NEG
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 5
88421: NEG
88422: PUSH
88423: LD_INT 1
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 6
88432: NEG
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 6
88443: NEG
88444: PUSH
88445: LD_INT 1
88447: NEG
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
88467: LD_ADDR_VAR 0 34
88471: PUSH
88472: LD_INT 2
88474: NEG
88475: PUSH
88476: LD_INT 3
88478: NEG
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: PUSH
88484: LD_INT 3
88486: NEG
88487: PUSH
88488: LD_INT 2
88490: NEG
88491: PUSH
88492: EMPTY
88493: LIST
88494: LIST
88495: PUSH
88496: LD_INT 3
88498: NEG
88499: PUSH
88500: LD_INT 3
88502: NEG
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 3
88510: NEG
88511: PUSH
88512: LD_INT 4
88514: NEG
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 4
88522: NEG
88523: PUSH
88524: LD_INT 3
88526: NEG
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 4
88534: NEG
88535: PUSH
88536: LD_INT 4
88538: NEG
88539: PUSH
88540: EMPTY
88541: LIST
88542: LIST
88543: PUSH
88544: LD_INT 4
88546: NEG
88547: PUSH
88548: LD_INT 5
88550: NEG
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 5
88558: NEG
88559: PUSH
88560: LD_INT 4
88562: NEG
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 5
88570: NEG
88571: PUSH
88572: LD_INT 5
88574: NEG
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 5
88582: NEG
88583: PUSH
88584: LD_INT 6
88586: NEG
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 6
88594: NEG
88595: PUSH
88596: LD_INT 5
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 6
88606: NEG
88607: PUSH
88608: LD_INT 6
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
88630: LD_ADDR_VAR 0 41
88634: PUSH
88635: LD_INT 0
88637: PUSH
88638: LD_INT 2
88640: NEG
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: PUSH
88646: LD_INT 1
88648: NEG
88649: PUSH
88650: LD_INT 3
88652: NEG
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 1
88660: PUSH
88661: LD_INT 2
88663: NEG
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: LIST
88673: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
88674: LD_ADDR_VAR 0 42
88678: PUSH
88679: LD_INT 2
88681: PUSH
88682: LD_INT 0
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 2
88691: PUSH
88692: LD_INT 1
88694: NEG
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 3
88702: PUSH
88703: LD_INT 1
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: LIST
88714: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
88715: LD_ADDR_VAR 0 43
88719: PUSH
88720: LD_INT 2
88722: PUSH
88723: LD_INT 2
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 3
88732: PUSH
88733: LD_INT 2
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 2
88742: PUSH
88743: LD_INT 3
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: LIST
88754: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
88755: LD_ADDR_VAR 0 44
88759: PUSH
88760: LD_INT 0
88762: PUSH
88763: LD_INT 2
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 1
88772: PUSH
88773: LD_INT 3
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 1
88782: NEG
88783: PUSH
88784: LD_INT 2
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: LIST
88795: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88796: LD_ADDR_VAR 0 45
88800: PUSH
88801: LD_INT 2
88803: NEG
88804: PUSH
88805: LD_INT 0
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 2
88814: NEG
88815: PUSH
88816: LD_INT 1
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 3
88825: NEG
88826: PUSH
88827: LD_INT 1
88829: NEG
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: LIST
88839: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
88840: LD_ADDR_VAR 0 46
88844: PUSH
88845: LD_INT 2
88847: NEG
88848: PUSH
88849: LD_INT 2
88851: NEG
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: PUSH
88857: LD_INT 2
88859: NEG
88860: PUSH
88861: LD_INT 3
88863: NEG
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 3
88871: NEG
88872: PUSH
88873: LD_INT 2
88875: NEG
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: LIST
88885: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
88886: LD_ADDR_VAR 0 47
88890: PUSH
88891: LD_INT 2
88893: NEG
88894: PUSH
88895: LD_INT 3
88897: NEG
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 1
88905: NEG
88906: PUSH
88907: LD_INT 3
88909: NEG
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88919: LD_ADDR_VAR 0 48
88923: PUSH
88924: LD_INT 1
88926: PUSH
88927: LD_INT 2
88929: NEG
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 2
88937: PUSH
88938: LD_INT 1
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
88950: LD_ADDR_VAR 0 49
88954: PUSH
88955: LD_INT 3
88957: PUSH
88958: LD_INT 1
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: PUSH
88965: LD_INT 3
88967: PUSH
88968: LD_INT 2
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
88979: LD_ADDR_VAR 0 50
88983: PUSH
88984: LD_INT 2
88986: PUSH
88987: LD_INT 3
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: PUSH
88994: LD_INT 1
88996: PUSH
88997: LD_INT 3
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
89008: LD_ADDR_VAR 0 51
89012: PUSH
89013: LD_INT 1
89015: NEG
89016: PUSH
89017: LD_INT 2
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 2
89026: NEG
89027: PUSH
89028: LD_INT 1
89030: PUSH
89031: EMPTY
89032: LIST
89033: LIST
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89039: LD_ADDR_VAR 0 52
89043: PUSH
89044: LD_INT 3
89046: NEG
89047: PUSH
89048: LD_INT 1
89050: NEG
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 3
89058: NEG
89059: PUSH
89060: LD_INT 2
89062: NEG
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89072: LD_ADDR_VAR 0 53
89076: PUSH
89077: LD_INT 1
89079: NEG
89080: PUSH
89081: LD_INT 3
89083: NEG
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 0
89091: PUSH
89092: LD_INT 3
89094: NEG
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 1
89102: PUSH
89103: LD_INT 2
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: LIST
89115: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89116: LD_ADDR_VAR 0 54
89120: PUSH
89121: LD_INT 2
89123: PUSH
89124: LD_INT 1
89126: NEG
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 3
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 3
89144: PUSH
89145: LD_INT 1
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: LIST
89156: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89157: LD_ADDR_VAR 0 55
89161: PUSH
89162: LD_INT 3
89164: PUSH
89165: LD_INT 2
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 3
89174: PUSH
89175: LD_INT 3
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 2
89184: PUSH
89185: LD_INT 3
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: EMPTY
89193: LIST
89194: LIST
89195: LIST
89196: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89197: LD_ADDR_VAR 0 56
89201: PUSH
89202: LD_INT 1
89204: PUSH
89205: LD_INT 3
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 0
89214: PUSH
89215: LD_INT 3
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: NEG
89225: PUSH
89226: LD_INT 2
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: LIST
89237: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89238: LD_ADDR_VAR 0 57
89242: PUSH
89243: LD_INT 2
89245: NEG
89246: PUSH
89247: LD_INT 1
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 3
89256: NEG
89257: PUSH
89258: LD_INT 0
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: LD_INT 3
89267: NEG
89268: PUSH
89269: LD_INT 1
89271: NEG
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: EMPTY
89278: LIST
89279: LIST
89280: LIST
89281: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89282: LD_ADDR_VAR 0 58
89286: PUSH
89287: LD_INT 2
89289: NEG
89290: PUSH
89291: LD_INT 3
89293: NEG
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 3
89301: NEG
89302: PUSH
89303: LD_INT 2
89305: NEG
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 3
89313: NEG
89314: PUSH
89315: LD_INT 3
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: LIST
89327: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
89328: LD_ADDR_VAR 0 59
89332: PUSH
89333: LD_INT 1
89335: NEG
89336: PUSH
89337: LD_INT 2
89339: NEG
89340: PUSH
89341: EMPTY
89342: LIST
89343: LIST
89344: PUSH
89345: LD_INT 0
89347: PUSH
89348: LD_INT 2
89350: NEG
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: LD_INT 1
89358: PUSH
89359: LD_INT 1
89361: NEG
89362: PUSH
89363: EMPTY
89364: LIST
89365: LIST
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: LIST
89371: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89372: LD_ADDR_VAR 0 60
89376: PUSH
89377: LD_INT 1
89379: PUSH
89380: LD_INT 1
89382: NEG
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 2
89390: PUSH
89391: LD_INT 0
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: LD_INT 2
89400: PUSH
89401: LD_INT 1
89403: PUSH
89404: EMPTY
89405: LIST
89406: LIST
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: LIST
89412: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89413: LD_ADDR_VAR 0 61
89417: PUSH
89418: LD_INT 2
89420: PUSH
89421: LD_INT 1
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 2
89430: PUSH
89431: LD_INT 2
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 1
89440: PUSH
89441: LD_INT 2
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: LIST
89452: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89453: LD_ADDR_VAR 0 62
89457: PUSH
89458: LD_INT 1
89460: PUSH
89461: LD_INT 2
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: LD_INT 2
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: NEG
89481: PUSH
89482: LD_INT 1
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: EMPTY
89490: LIST
89491: LIST
89492: LIST
89493: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89494: LD_ADDR_VAR 0 63
89498: PUSH
89499: LD_INT 1
89501: NEG
89502: PUSH
89503: LD_INT 1
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 1
89527: NEG
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: LIST
89537: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89538: LD_ADDR_VAR 0 64
89542: PUSH
89543: LD_INT 1
89545: NEG
89546: PUSH
89547: LD_INT 2
89549: NEG
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: PUSH
89555: LD_INT 2
89557: NEG
89558: PUSH
89559: LD_INT 1
89561: NEG
89562: PUSH
89563: EMPTY
89564: LIST
89565: LIST
89566: PUSH
89567: LD_INT 2
89569: NEG
89570: PUSH
89571: LD_INT 2
89573: NEG
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: LIST
89583: ST_TO_ADDR
// end ; 2 :
89584: GO 92850
89586: LD_INT 2
89588: DOUBLE
89589: EQUAL
89590: IFTRUE 89594
89592: GO 92849
89594: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
89595: LD_ADDR_VAR 0 29
89599: PUSH
89600: LD_INT 4
89602: PUSH
89603: LD_INT 0
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 4
89612: PUSH
89613: LD_INT 1
89615: NEG
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 5
89623: PUSH
89624: LD_INT 0
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 5
89633: PUSH
89634: LD_INT 1
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 4
89643: PUSH
89644: LD_INT 1
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 3
89653: PUSH
89654: LD_INT 0
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 3
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 3
89674: PUSH
89675: LD_INT 2
89677: NEG
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: PUSH
89683: LD_INT 5
89685: PUSH
89686: LD_INT 2
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: LD_INT 3
89695: PUSH
89696: LD_INT 3
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 3
89705: PUSH
89706: LD_INT 2
89708: PUSH
89709: EMPTY
89710: LIST
89711: LIST
89712: PUSH
89713: LD_INT 4
89715: PUSH
89716: LD_INT 3
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 4
89725: PUSH
89726: LD_INT 4
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: LD_INT 3
89735: PUSH
89736: LD_INT 4
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 2
89745: PUSH
89746: LD_INT 3
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 2
89755: PUSH
89756: LD_INT 2
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 4
89765: PUSH
89766: LD_INT 2
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 2
89775: PUSH
89776: LD_INT 4
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: LD_INT 4
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 0
89795: PUSH
89796: LD_INT 3
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: LD_INT 1
89805: PUSH
89806: LD_INT 4
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 1
89815: PUSH
89816: LD_INT 5
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 0
89825: PUSH
89826: LD_INT 5
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: NEG
89836: PUSH
89837: LD_INT 4
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 1
89846: NEG
89847: PUSH
89848: LD_INT 3
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 2
89857: PUSH
89858: LD_INT 5
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 2
89867: NEG
89868: PUSH
89869: LD_INT 3
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 3
89878: NEG
89879: PUSH
89880: LD_INT 0
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 3
89889: NEG
89890: PUSH
89891: LD_INT 1
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 2
89901: NEG
89902: PUSH
89903: LD_INT 0
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 2
89912: NEG
89913: PUSH
89914: LD_INT 1
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PUSH
89921: LD_INT 3
89923: NEG
89924: PUSH
89925: LD_INT 1
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 4
89934: NEG
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 4
89945: NEG
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 4
89957: NEG
89958: PUSH
89959: LD_INT 2
89961: NEG
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 2
89969: NEG
89970: PUSH
89971: LD_INT 2
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 4
89980: NEG
89981: PUSH
89982: LD_INT 4
89984: NEG
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 4
89992: NEG
89993: PUSH
89994: LD_INT 5
89996: NEG
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: PUSH
90002: LD_INT 3
90004: NEG
90005: PUSH
90006: LD_INT 4
90008: NEG
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 3
90016: NEG
90017: PUSH
90018: LD_INT 3
90020: NEG
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 4
90028: NEG
90029: PUSH
90030: LD_INT 3
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 5
90040: NEG
90041: PUSH
90042: LD_INT 4
90044: NEG
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: PUSH
90050: LD_INT 5
90052: NEG
90053: PUSH
90054: LD_INT 5
90056: NEG
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 3
90064: NEG
90065: PUSH
90066: LD_INT 5
90068: NEG
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 5
90076: NEG
90077: PUSH
90078: LD_INT 3
90080: NEG
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
90133: LD_ADDR_VAR 0 30
90137: PUSH
90138: LD_INT 4
90140: PUSH
90141: LD_INT 4
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 4
90150: PUSH
90151: LD_INT 3
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: PUSH
90158: LD_INT 5
90160: PUSH
90161: LD_INT 4
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 5
90170: PUSH
90171: LD_INT 5
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 4
90180: PUSH
90181: LD_INT 5
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 3
90190: PUSH
90191: LD_INT 4
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 3
90200: PUSH
90201: LD_INT 3
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 5
90210: PUSH
90211: LD_INT 3
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 3
90220: PUSH
90221: LD_INT 5
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 0
90230: PUSH
90231: LD_INT 3
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 0
90240: PUSH
90241: LD_INT 2
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 1
90250: PUSH
90251: LD_INT 3
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 1
90260: PUSH
90261: LD_INT 4
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 0
90270: PUSH
90271: LD_INT 4
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 1
90280: NEG
90281: PUSH
90282: LD_INT 3
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 1
90291: NEG
90292: PUSH
90293: LD_INT 2
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: LD_INT 2
90302: PUSH
90303: LD_INT 4
90305: PUSH
90306: EMPTY
90307: LIST
90308: LIST
90309: PUSH
90310: LD_INT 2
90312: NEG
90313: PUSH
90314: LD_INT 2
90316: PUSH
90317: EMPTY
90318: LIST
90319: LIST
90320: PUSH
90321: LD_INT 4
90323: NEG
90324: PUSH
90325: LD_INT 0
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 4
90334: NEG
90335: PUSH
90336: LD_INT 1
90338: NEG
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 3
90346: NEG
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 3
90357: NEG
90358: PUSH
90359: LD_INT 1
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 4
90368: NEG
90369: PUSH
90370: LD_INT 1
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 5
90379: NEG
90380: PUSH
90381: LD_INT 0
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 5
90390: NEG
90391: PUSH
90392: LD_INT 1
90394: NEG
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 5
90402: NEG
90403: PUSH
90404: LD_INT 2
90406: NEG
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 3
90414: NEG
90415: PUSH
90416: LD_INT 2
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: LD_INT 3
90425: NEG
90426: PUSH
90427: LD_INT 3
90429: NEG
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 3
90437: NEG
90438: PUSH
90439: LD_INT 4
90441: NEG
90442: PUSH
90443: EMPTY
90444: LIST
90445: LIST
90446: PUSH
90447: LD_INT 2
90449: NEG
90450: PUSH
90451: LD_INT 3
90453: NEG
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 2
90461: NEG
90462: PUSH
90463: LD_INT 2
90465: NEG
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: PUSH
90471: LD_INT 3
90473: NEG
90474: PUSH
90475: LD_INT 2
90477: NEG
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 4
90485: NEG
90486: PUSH
90487: LD_INT 3
90489: NEG
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 4
90497: NEG
90498: PUSH
90499: LD_INT 4
90501: NEG
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 2
90509: NEG
90510: PUSH
90511: LD_INT 4
90513: NEG
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 4
90521: NEG
90522: PUSH
90523: LD_INT 2
90525: NEG
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 0
90533: PUSH
90534: LD_INT 4
90536: NEG
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 0
90544: PUSH
90545: LD_INT 5
90547: NEG
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 1
90555: PUSH
90556: LD_INT 4
90558: NEG
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 1
90566: PUSH
90567: LD_INT 3
90569: NEG
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 3
90580: NEG
90581: PUSH
90582: EMPTY
90583: LIST
90584: LIST
90585: PUSH
90586: LD_INT 1
90588: NEG
90589: PUSH
90590: LD_INT 4
90592: NEG
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 1
90600: NEG
90601: PUSH
90602: LD_INT 5
90604: NEG
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: PUSH
90610: LD_INT 2
90612: PUSH
90613: LD_INT 3
90615: NEG
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 2
90623: NEG
90624: PUSH
90625: LD_INT 5
90627: NEG
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
90680: LD_ADDR_VAR 0 31
90684: PUSH
90685: LD_INT 0
90687: PUSH
90688: LD_INT 4
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 0
90697: PUSH
90698: LD_INT 3
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 1
90707: PUSH
90708: LD_INT 4
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 1
90717: PUSH
90718: LD_INT 5
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: LD_INT 0
90727: PUSH
90728: LD_INT 5
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: LD_INT 1
90737: NEG
90738: PUSH
90739: LD_INT 4
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 1
90748: NEG
90749: PUSH
90750: LD_INT 3
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: LD_INT 2
90759: PUSH
90760: LD_INT 5
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 2
90769: NEG
90770: PUSH
90771: LD_INT 3
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 3
90780: NEG
90781: PUSH
90782: LD_INT 0
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 3
90791: NEG
90792: PUSH
90793: LD_INT 1
90795: NEG
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 2
90803: NEG
90804: PUSH
90805: LD_INT 0
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 2
90814: NEG
90815: PUSH
90816: LD_INT 1
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 3
90825: NEG
90826: PUSH
90827: LD_INT 1
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 4
90836: NEG
90837: PUSH
90838: LD_INT 0
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 4
90847: NEG
90848: PUSH
90849: LD_INT 1
90851: NEG
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 4
90859: NEG
90860: PUSH
90861: LD_INT 2
90863: NEG
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 2
90871: NEG
90872: PUSH
90873: LD_INT 2
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PUSH
90880: LD_INT 4
90882: NEG
90883: PUSH
90884: LD_INT 4
90886: NEG
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 4
90894: NEG
90895: PUSH
90896: LD_INT 5
90898: NEG
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PUSH
90904: LD_INT 3
90906: NEG
90907: PUSH
90908: LD_INT 4
90910: NEG
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PUSH
90916: LD_INT 3
90918: NEG
90919: PUSH
90920: LD_INT 3
90922: NEG
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 4
90930: NEG
90931: PUSH
90932: LD_INT 3
90934: NEG
90935: PUSH
90936: EMPTY
90937: LIST
90938: LIST
90939: PUSH
90940: LD_INT 5
90942: NEG
90943: PUSH
90944: LD_INT 4
90946: NEG
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 5
90954: NEG
90955: PUSH
90956: LD_INT 5
90958: NEG
90959: PUSH
90960: EMPTY
90961: LIST
90962: LIST
90963: PUSH
90964: LD_INT 3
90966: NEG
90967: PUSH
90968: LD_INT 5
90970: NEG
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 5
90978: NEG
90979: PUSH
90980: LD_INT 3
90982: NEG
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 0
90990: PUSH
90991: LD_INT 3
90993: NEG
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 0
91001: PUSH
91002: LD_INT 4
91004: NEG
91005: PUSH
91006: EMPTY
91007: LIST
91008: LIST
91009: PUSH
91010: LD_INT 1
91012: PUSH
91013: LD_INT 3
91015: NEG
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: PUSH
91021: LD_INT 1
91023: PUSH
91024: LD_INT 2
91026: NEG
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 0
91034: PUSH
91035: LD_INT 2
91037: NEG
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 1
91045: NEG
91046: PUSH
91047: LD_INT 3
91049: NEG
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 1
91057: NEG
91058: PUSH
91059: LD_INT 4
91061: NEG
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: PUSH
91067: LD_INT 2
91069: PUSH
91070: LD_INT 2
91072: NEG
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 2
91080: NEG
91081: PUSH
91082: LD_INT 4
91084: NEG
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 4
91092: PUSH
91093: LD_INT 0
91095: PUSH
91096: EMPTY
91097: LIST
91098: LIST
91099: PUSH
91100: LD_INT 4
91102: PUSH
91103: LD_INT 1
91105: NEG
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 5
91113: PUSH
91114: LD_INT 0
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 5
91123: PUSH
91124: LD_INT 1
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 4
91133: PUSH
91134: LD_INT 1
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 3
91143: PUSH
91144: LD_INT 0
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: LD_INT 3
91153: PUSH
91154: LD_INT 1
91156: NEG
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: PUSH
91162: LD_INT 3
91164: PUSH
91165: LD_INT 2
91167: NEG
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 5
91175: PUSH
91176: LD_INT 2
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
91230: LD_ADDR_VAR 0 32
91234: PUSH
91235: LD_INT 4
91237: NEG
91238: PUSH
91239: LD_INT 0
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: LD_INT 4
91248: NEG
91249: PUSH
91250: LD_INT 1
91252: NEG
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: LD_INT 3
91260: NEG
91261: PUSH
91262: LD_INT 0
91264: PUSH
91265: EMPTY
91266: LIST
91267: LIST
91268: PUSH
91269: LD_INT 3
91271: NEG
91272: PUSH
91273: LD_INT 1
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PUSH
91280: LD_INT 4
91282: NEG
91283: PUSH
91284: LD_INT 1
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: LD_INT 5
91293: NEG
91294: PUSH
91295: LD_INT 0
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 5
91304: NEG
91305: PUSH
91306: LD_INT 1
91308: NEG
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 5
91316: NEG
91317: PUSH
91318: LD_INT 2
91320: NEG
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 3
91328: NEG
91329: PUSH
91330: LD_INT 2
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 3
91339: NEG
91340: PUSH
91341: LD_INT 3
91343: NEG
91344: PUSH
91345: EMPTY
91346: LIST
91347: LIST
91348: PUSH
91349: LD_INT 3
91351: NEG
91352: PUSH
91353: LD_INT 4
91355: NEG
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 2
91363: NEG
91364: PUSH
91365: LD_INT 3
91367: NEG
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: LD_INT 2
91375: NEG
91376: PUSH
91377: LD_INT 2
91379: NEG
91380: PUSH
91381: EMPTY
91382: LIST
91383: LIST
91384: PUSH
91385: LD_INT 3
91387: NEG
91388: PUSH
91389: LD_INT 2
91391: NEG
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 4
91399: NEG
91400: PUSH
91401: LD_INT 3
91403: NEG
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 4
91411: NEG
91412: PUSH
91413: LD_INT 4
91415: NEG
91416: PUSH
91417: EMPTY
91418: LIST
91419: LIST
91420: PUSH
91421: LD_INT 2
91423: NEG
91424: PUSH
91425: LD_INT 4
91427: NEG
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PUSH
91433: LD_INT 4
91435: NEG
91436: PUSH
91437: LD_INT 2
91439: NEG
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 0
91447: PUSH
91448: LD_INT 4
91450: NEG
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 0
91458: PUSH
91459: LD_INT 5
91461: NEG
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: PUSH
91467: LD_INT 1
91469: PUSH
91470: LD_INT 4
91472: NEG
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 1
91480: PUSH
91481: LD_INT 3
91483: NEG
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 0
91491: PUSH
91492: LD_INT 3
91494: NEG
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 1
91502: NEG
91503: PUSH
91504: LD_INT 4
91506: NEG
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 1
91514: NEG
91515: PUSH
91516: LD_INT 5
91518: NEG
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 2
91526: PUSH
91527: LD_INT 3
91529: NEG
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 2
91537: NEG
91538: PUSH
91539: LD_INT 5
91541: NEG
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 3
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 3
91559: PUSH
91560: LD_INT 1
91562: NEG
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: PUSH
91568: LD_INT 4
91570: PUSH
91571: LD_INT 0
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: LD_INT 4
91580: PUSH
91581: LD_INT 1
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 3
91590: PUSH
91591: LD_INT 1
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: LD_INT 2
91600: PUSH
91601: LD_INT 0
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: LD_INT 2
91610: PUSH
91611: LD_INT 1
91613: NEG
91614: PUSH
91615: EMPTY
91616: LIST
91617: LIST
91618: PUSH
91619: LD_INT 2
91621: PUSH
91622: LD_INT 2
91624: NEG
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 4
91632: PUSH
91633: LD_INT 2
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 4
91642: PUSH
91643: LD_INT 4
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 4
91652: PUSH
91653: LD_INT 3
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 5
91662: PUSH
91663: LD_INT 4
91665: PUSH
91666: EMPTY
91667: LIST
91668: LIST
91669: PUSH
91670: LD_INT 5
91672: PUSH
91673: LD_INT 5
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: PUSH
91680: LD_INT 4
91682: PUSH
91683: LD_INT 5
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 3
91692: PUSH
91693: LD_INT 4
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 3
91702: PUSH
91703: LD_INT 3
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 5
91712: PUSH
91713: LD_INT 3
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: PUSH
91720: LD_INT 3
91722: PUSH
91723: LD_INT 5
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
91777: LD_ADDR_VAR 0 33
91781: PUSH
91782: LD_INT 4
91784: NEG
91785: PUSH
91786: LD_INT 4
91788: NEG
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 4
91796: NEG
91797: PUSH
91798: LD_INT 5
91800: NEG
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 3
91808: NEG
91809: PUSH
91810: LD_INT 4
91812: NEG
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 3
91820: NEG
91821: PUSH
91822: LD_INT 3
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 4
91832: NEG
91833: PUSH
91834: LD_INT 3
91836: NEG
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 5
91844: NEG
91845: PUSH
91846: LD_INT 4
91848: NEG
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: PUSH
91854: LD_INT 5
91856: NEG
91857: PUSH
91858: LD_INT 5
91860: NEG
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 3
91868: NEG
91869: PUSH
91870: LD_INT 5
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 5
91880: NEG
91881: PUSH
91882: LD_INT 3
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 0
91892: PUSH
91893: LD_INT 3
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 0
91903: PUSH
91904: LD_INT 4
91906: NEG
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: LD_INT 1
91914: PUSH
91915: LD_INT 3
91917: NEG
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: LD_INT 1
91925: PUSH
91926: LD_INT 2
91928: NEG
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: LD_INT 2
91939: NEG
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 1
91947: NEG
91948: PUSH
91949: LD_INT 3
91951: NEG
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: PUSH
91957: LD_INT 1
91959: NEG
91960: PUSH
91961: LD_INT 4
91963: NEG
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 2
91971: PUSH
91972: LD_INT 2
91974: NEG
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: PUSH
91980: LD_INT 2
91982: NEG
91983: PUSH
91984: LD_INT 4
91986: NEG
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 4
91994: PUSH
91995: LD_INT 0
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 4
92004: PUSH
92005: LD_INT 1
92007: NEG
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: LD_INT 5
92015: PUSH
92016: LD_INT 0
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 5
92025: PUSH
92026: LD_INT 1
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 4
92035: PUSH
92036: LD_INT 1
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: PUSH
92043: LD_INT 3
92045: PUSH
92046: LD_INT 0
92048: PUSH
92049: EMPTY
92050: LIST
92051: LIST
92052: PUSH
92053: LD_INT 3
92055: PUSH
92056: LD_INT 1
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 3
92066: PUSH
92067: LD_INT 2
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 5
92077: PUSH
92078: LD_INT 2
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 3
92087: PUSH
92088: LD_INT 3
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: LD_INT 3
92097: PUSH
92098: LD_INT 2
92100: PUSH
92101: EMPTY
92102: LIST
92103: LIST
92104: PUSH
92105: LD_INT 4
92107: PUSH
92108: LD_INT 3
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: PUSH
92115: LD_INT 4
92117: PUSH
92118: LD_INT 4
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 3
92127: PUSH
92128: LD_INT 4
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 2
92137: PUSH
92138: LD_INT 3
92140: PUSH
92141: EMPTY
92142: LIST
92143: LIST
92144: PUSH
92145: LD_INT 2
92147: PUSH
92148: LD_INT 2
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: PUSH
92155: LD_INT 4
92157: PUSH
92158: LD_INT 2
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 2
92167: PUSH
92168: LD_INT 4
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 0
92177: PUSH
92178: LD_INT 4
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: LD_INT 0
92187: PUSH
92188: LD_INT 3
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PUSH
92195: LD_INT 1
92197: PUSH
92198: LD_INT 4
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 1
92207: PUSH
92208: LD_INT 5
92210: PUSH
92211: EMPTY
92212: LIST
92213: LIST
92214: PUSH
92215: LD_INT 0
92217: PUSH
92218: LD_INT 5
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 1
92227: NEG
92228: PUSH
92229: LD_INT 4
92231: PUSH
92232: EMPTY
92233: LIST
92234: LIST
92235: PUSH
92236: LD_INT 1
92238: NEG
92239: PUSH
92240: LD_INT 3
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 2
92249: PUSH
92250: LD_INT 5
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: LD_INT 2
92259: NEG
92260: PUSH
92261: LD_INT 3
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: EMPTY
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
92315: LD_ADDR_VAR 0 34
92319: PUSH
92320: LD_INT 0
92322: PUSH
92323: LD_INT 4
92325: NEG
92326: PUSH
92327: EMPTY
92328: LIST
92329: LIST
92330: PUSH
92331: LD_INT 0
92333: PUSH
92334: LD_INT 5
92336: NEG
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 1
92344: PUSH
92345: LD_INT 4
92347: NEG
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 1
92355: PUSH
92356: LD_INT 3
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 0
92366: PUSH
92367: LD_INT 3
92369: NEG
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PUSH
92375: LD_INT 1
92377: NEG
92378: PUSH
92379: LD_INT 4
92381: NEG
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 1
92389: NEG
92390: PUSH
92391: LD_INT 5
92393: NEG
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PUSH
92399: LD_INT 2
92401: PUSH
92402: LD_INT 3
92404: NEG
92405: PUSH
92406: EMPTY
92407: LIST
92408: LIST
92409: PUSH
92410: LD_INT 2
92412: NEG
92413: PUSH
92414: LD_INT 5
92416: NEG
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 3
92424: PUSH
92425: LD_INT 0
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 3
92434: PUSH
92435: LD_INT 1
92437: NEG
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 4
92445: PUSH
92446: LD_INT 0
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 4
92455: PUSH
92456: LD_INT 1
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 3
92465: PUSH
92466: LD_INT 1
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: PUSH
92473: LD_INT 2
92475: PUSH
92476: LD_INT 0
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 2
92485: PUSH
92486: LD_INT 1
92488: NEG
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 2
92496: PUSH
92497: LD_INT 2
92499: NEG
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 4
92507: PUSH
92508: LD_INT 2
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: PUSH
92515: LD_INT 4
92517: PUSH
92518: LD_INT 4
92520: PUSH
92521: EMPTY
92522: LIST
92523: LIST
92524: PUSH
92525: LD_INT 4
92527: PUSH
92528: LD_INT 3
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 5
92537: PUSH
92538: LD_INT 4
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: PUSH
92545: LD_INT 5
92547: PUSH
92548: LD_INT 5
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 4
92557: PUSH
92558: LD_INT 5
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 3
92567: PUSH
92568: LD_INT 4
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: LD_INT 3
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 5
92587: PUSH
92588: LD_INT 3
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 3
92597: PUSH
92598: LD_INT 5
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 0
92607: PUSH
92608: LD_INT 3
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 0
92617: PUSH
92618: LD_INT 2
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 1
92627: PUSH
92628: LD_INT 3
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: LD_INT 1
92637: PUSH
92638: LD_INT 4
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 0
92647: PUSH
92648: LD_INT 4
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: LD_INT 1
92657: NEG
92658: PUSH
92659: LD_INT 3
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: PUSH
92666: LD_INT 1
92668: NEG
92669: PUSH
92670: LD_INT 2
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: LD_INT 2
92679: PUSH
92680: LD_INT 4
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 2
92689: NEG
92690: PUSH
92691: LD_INT 2
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 4
92700: NEG
92701: PUSH
92702: LD_INT 0
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 4
92711: NEG
92712: PUSH
92713: LD_INT 1
92715: NEG
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 3
92723: NEG
92724: PUSH
92725: LD_INT 0
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 3
92734: NEG
92735: PUSH
92736: LD_INT 1
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 4
92745: NEG
92746: PUSH
92747: LD_INT 1
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 5
92756: NEG
92757: PUSH
92758: LD_INT 0
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 5
92767: NEG
92768: PUSH
92769: LD_INT 1
92771: NEG
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 5
92779: NEG
92780: PUSH
92781: LD_INT 2
92783: NEG
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 3
92791: NEG
92792: PUSH
92793: LD_INT 2
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: ST_TO_ADDR
// end ; end ;
92847: GO 92850
92849: POP
// case btype of b_depot , b_warehouse :
92850: LD_VAR 0 1
92854: PUSH
92855: LD_INT 0
92857: DOUBLE
92858: EQUAL
92859: IFTRUE 92869
92861: LD_INT 1
92863: DOUBLE
92864: EQUAL
92865: IFTRUE 92869
92867: GO 93070
92869: POP
// case nation of nation_american :
92870: LD_VAR 0 5
92874: PUSH
92875: LD_INT 1
92877: DOUBLE
92878: EQUAL
92879: IFTRUE 92883
92881: GO 92939
92883: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
92884: LD_ADDR_VAR 0 9
92888: PUSH
92889: LD_VAR 0 11
92893: PUSH
92894: LD_VAR 0 12
92898: PUSH
92899: LD_VAR 0 13
92903: PUSH
92904: LD_VAR 0 14
92908: PUSH
92909: LD_VAR 0 15
92913: PUSH
92914: LD_VAR 0 16
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: PUSH
92927: LD_VAR 0 4
92931: PUSH
92932: LD_INT 1
92934: PLUS
92935: ARRAY
92936: ST_TO_ADDR
92937: GO 93068
92939: LD_INT 2
92941: DOUBLE
92942: EQUAL
92943: IFTRUE 92947
92945: GO 93003
92947: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
92948: LD_ADDR_VAR 0 9
92952: PUSH
92953: LD_VAR 0 17
92957: PUSH
92958: LD_VAR 0 18
92962: PUSH
92963: LD_VAR 0 19
92967: PUSH
92968: LD_VAR 0 20
92972: PUSH
92973: LD_VAR 0 21
92977: PUSH
92978: LD_VAR 0 22
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: PUSH
92991: LD_VAR 0 4
92995: PUSH
92996: LD_INT 1
92998: PLUS
92999: ARRAY
93000: ST_TO_ADDR
93001: GO 93068
93003: LD_INT 3
93005: DOUBLE
93006: EQUAL
93007: IFTRUE 93011
93009: GO 93067
93011: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
93012: LD_ADDR_VAR 0 9
93016: PUSH
93017: LD_VAR 0 23
93021: PUSH
93022: LD_VAR 0 24
93026: PUSH
93027: LD_VAR 0 25
93031: PUSH
93032: LD_VAR 0 26
93036: PUSH
93037: LD_VAR 0 27
93041: PUSH
93042: LD_VAR 0 28
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: LIST
93051: LIST
93052: LIST
93053: LIST
93054: PUSH
93055: LD_VAR 0 4
93059: PUSH
93060: LD_INT 1
93062: PLUS
93063: ARRAY
93064: ST_TO_ADDR
93065: GO 93068
93067: POP
93068: GO 93623
93070: LD_INT 2
93072: DOUBLE
93073: EQUAL
93074: IFTRUE 93084
93076: LD_INT 3
93078: DOUBLE
93079: EQUAL
93080: IFTRUE 93084
93082: GO 93140
93084: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
93085: LD_ADDR_VAR 0 9
93089: PUSH
93090: LD_VAR 0 29
93094: PUSH
93095: LD_VAR 0 30
93099: PUSH
93100: LD_VAR 0 31
93104: PUSH
93105: LD_VAR 0 32
93109: PUSH
93110: LD_VAR 0 33
93114: PUSH
93115: LD_VAR 0 34
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: PUSH
93128: LD_VAR 0 4
93132: PUSH
93133: LD_INT 1
93135: PLUS
93136: ARRAY
93137: ST_TO_ADDR
93138: GO 93623
93140: LD_INT 16
93142: DOUBLE
93143: EQUAL
93144: IFTRUE 93202
93146: LD_INT 17
93148: DOUBLE
93149: EQUAL
93150: IFTRUE 93202
93152: LD_INT 18
93154: DOUBLE
93155: EQUAL
93156: IFTRUE 93202
93158: LD_INT 19
93160: DOUBLE
93161: EQUAL
93162: IFTRUE 93202
93164: LD_INT 22
93166: DOUBLE
93167: EQUAL
93168: IFTRUE 93202
93170: LD_INT 20
93172: DOUBLE
93173: EQUAL
93174: IFTRUE 93202
93176: LD_INT 21
93178: DOUBLE
93179: EQUAL
93180: IFTRUE 93202
93182: LD_INT 23
93184: DOUBLE
93185: EQUAL
93186: IFTRUE 93202
93188: LD_INT 24
93190: DOUBLE
93191: EQUAL
93192: IFTRUE 93202
93194: LD_INT 25
93196: DOUBLE
93197: EQUAL
93198: IFTRUE 93202
93200: GO 93258
93202: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
93203: LD_ADDR_VAR 0 9
93207: PUSH
93208: LD_VAR 0 35
93212: PUSH
93213: LD_VAR 0 36
93217: PUSH
93218: LD_VAR 0 37
93222: PUSH
93223: LD_VAR 0 38
93227: PUSH
93228: LD_VAR 0 39
93232: PUSH
93233: LD_VAR 0 40
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: PUSH
93246: LD_VAR 0 4
93250: PUSH
93251: LD_INT 1
93253: PLUS
93254: ARRAY
93255: ST_TO_ADDR
93256: GO 93623
93258: LD_INT 6
93260: DOUBLE
93261: EQUAL
93262: IFTRUE 93314
93264: LD_INT 7
93266: DOUBLE
93267: EQUAL
93268: IFTRUE 93314
93270: LD_INT 8
93272: DOUBLE
93273: EQUAL
93274: IFTRUE 93314
93276: LD_INT 13
93278: DOUBLE
93279: EQUAL
93280: IFTRUE 93314
93282: LD_INT 12
93284: DOUBLE
93285: EQUAL
93286: IFTRUE 93314
93288: LD_INT 15
93290: DOUBLE
93291: EQUAL
93292: IFTRUE 93314
93294: LD_INT 11
93296: DOUBLE
93297: EQUAL
93298: IFTRUE 93314
93300: LD_INT 14
93302: DOUBLE
93303: EQUAL
93304: IFTRUE 93314
93306: LD_INT 10
93308: DOUBLE
93309: EQUAL
93310: IFTRUE 93314
93312: GO 93370
93314: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
93315: LD_ADDR_VAR 0 9
93319: PUSH
93320: LD_VAR 0 41
93324: PUSH
93325: LD_VAR 0 42
93329: PUSH
93330: LD_VAR 0 43
93334: PUSH
93335: LD_VAR 0 44
93339: PUSH
93340: LD_VAR 0 45
93344: PUSH
93345: LD_VAR 0 46
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: PUSH
93358: LD_VAR 0 4
93362: PUSH
93363: LD_INT 1
93365: PLUS
93366: ARRAY
93367: ST_TO_ADDR
93368: GO 93623
93370: LD_INT 36
93372: DOUBLE
93373: EQUAL
93374: IFTRUE 93378
93376: GO 93434
93378: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
93379: LD_ADDR_VAR 0 9
93383: PUSH
93384: LD_VAR 0 47
93388: PUSH
93389: LD_VAR 0 48
93393: PUSH
93394: LD_VAR 0 49
93398: PUSH
93399: LD_VAR 0 50
93403: PUSH
93404: LD_VAR 0 51
93408: PUSH
93409: LD_VAR 0 52
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: PUSH
93422: LD_VAR 0 4
93426: PUSH
93427: LD_INT 1
93429: PLUS
93430: ARRAY
93431: ST_TO_ADDR
93432: GO 93623
93434: LD_INT 4
93436: DOUBLE
93437: EQUAL
93438: IFTRUE 93460
93440: LD_INT 5
93442: DOUBLE
93443: EQUAL
93444: IFTRUE 93460
93446: LD_INT 34
93448: DOUBLE
93449: EQUAL
93450: IFTRUE 93460
93452: LD_INT 37
93454: DOUBLE
93455: EQUAL
93456: IFTRUE 93460
93458: GO 93516
93460: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
93461: LD_ADDR_VAR 0 9
93465: PUSH
93466: LD_VAR 0 53
93470: PUSH
93471: LD_VAR 0 54
93475: PUSH
93476: LD_VAR 0 55
93480: PUSH
93481: LD_VAR 0 56
93485: PUSH
93486: LD_VAR 0 57
93490: PUSH
93491: LD_VAR 0 58
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: PUSH
93504: LD_VAR 0 4
93508: PUSH
93509: LD_INT 1
93511: PLUS
93512: ARRAY
93513: ST_TO_ADDR
93514: GO 93623
93516: LD_INT 31
93518: DOUBLE
93519: EQUAL
93520: IFTRUE 93566
93522: LD_INT 32
93524: DOUBLE
93525: EQUAL
93526: IFTRUE 93566
93528: LD_INT 33
93530: DOUBLE
93531: EQUAL
93532: IFTRUE 93566
93534: LD_INT 27
93536: DOUBLE
93537: EQUAL
93538: IFTRUE 93566
93540: LD_INT 26
93542: DOUBLE
93543: EQUAL
93544: IFTRUE 93566
93546: LD_INT 28
93548: DOUBLE
93549: EQUAL
93550: IFTRUE 93566
93552: LD_INT 29
93554: DOUBLE
93555: EQUAL
93556: IFTRUE 93566
93558: LD_INT 30
93560: DOUBLE
93561: EQUAL
93562: IFTRUE 93566
93564: GO 93622
93566: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
93567: LD_ADDR_VAR 0 9
93571: PUSH
93572: LD_VAR 0 59
93576: PUSH
93577: LD_VAR 0 60
93581: PUSH
93582: LD_VAR 0 61
93586: PUSH
93587: LD_VAR 0 62
93591: PUSH
93592: LD_VAR 0 63
93596: PUSH
93597: LD_VAR 0 64
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: PUSH
93610: LD_VAR 0 4
93614: PUSH
93615: LD_INT 1
93617: PLUS
93618: ARRAY
93619: ST_TO_ADDR
93620: GO 93623
93622: POP
// temp_list2 = [ ] ;
93623: LD_ADDR_VAR 0 10
93627: PUSH
93628: EMPTY
93629: ST_TO_ADDR
// for i in temp_list do
93630: LD_ADDR_VAR 0 8
93634: PUSH
93635: LD_VAR 0 9
93639: PUSH
93640: FOR_IN
93641: IFFALSE 93693
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
93643: LD_ADDR_VAR 0 10
93647: PUSH
93648: LD_VAR 0 10
93652: PUSH
93653: LD_VAR 0 8
93657: PUSH
93658: LD_INT 1
93660: ARRAY
93661: PUSH
93662: LD_VAR 0 2
93666: PLUS
93667: PUSH
93668: LD_VAR 0 8
93672: PUSH
93673: LD_INT 2
93675: ARRAY
93676: PUSH
93677: LD_VAR 0 3
93681: PLUS
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: PUSH
93687: EMPTY
93688: LIST
93689: ADD
93690: ST_TO_ADDR
93691: GO 93640
93693: POP
93694: POP
// result = temp_list2 ;
93695: LD_ADDR_VAR 0 7
93699: PUSH
93700: LD_VAR 0 10
93704: ST_TO_ADDR
// end ;
93705: LD_VAR 0 7
93709: RET
// export function EnemyInRange ( unit , dist ) ; begin
93710: LD_INT 0
93712: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
93713: LD_ADDR_VAR 0 3
93717: PUSH
93718: LD_VAR 0 1
93722: PPUSH
93723: CALL_OW 255
93727: PPUSH
93728: LD_VAR 0 1
93732: PPUSH
93733: CALL_OW 250
93737: PPUSH
93738: LD_VAR 0 1
93742: PPUSH
93743: CALL_OW 251
93747: PPUSH
93748: LD_VAR 0 2
93752: PPUSH
93753: CALL 67106 0 4
93757: PUSH
93758: LD_INT 4
93760: ARRAY
93761: ST_TO_ADDR
// end ;
93762: LD_VAR 0 3
93766: RET
// export function PlayerSeeMe ( unit ) ; begin
93767: LD_INT 0
93769: PPUSH
// result := See ( your_side , unit ) ;
93770: LD_ADDR_VAR 0 2
93774: PUSH
93775: LD_OWVAR 2
93779: PPUSH
93780: LD_VAR 0 1
93784: PPUSH
93785: CALL_OW 292
93789: ST_TO_ADDR
// end ;
93790: LD_VAR 0 2
93794: RET
// export function ReverseDir ( unit ) ; begin
93795: LD_INT 0
93797: PPUSH
// if not unit then
93798: LD_VAR 0 1
93802: NOT
93803: IFFALSE 93807
// exit ;
93805: GO 93830
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
93807: LD_ADDR_VAR 0 2
93811: PUSH
93812: LD_VAR 0 1
93816: PPUSH
93817: CALL_OW 254
93821: PUSH
93822: LD_INT 3
93824: PLUS
93825: PUSH
93826: LD_INT 6
93828: MOD
93829: ST_TO_ADDR
// end ;
93830: LD_VAR 0 2
93834: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
93835: LD_INT 0
93837: PPUSH
93838: PPUSH
93839: PPUSH
93840: PPUSH
93841: PPUSH
// if not hexes then
93842: LD_VAR 0 2
93846: NOT
93847: IFFALSE 93851
// exit ;
93849: GO 93999
// dist := 9999 ;
93851: LD_ADDR_VAR 0 5
93855: PUSH
93856: LD_INT 9999
93858: ST_TO_ADDR
// for i = 1 to hexes do
93859: LD_ADDR_VAR 0 4
93863: PUSH
93864: DOUBLE
93865: LD_INT 1
93867: DEC
93868: ST_TO_ADDR
93869: LD_VAR 0 2
93873: PUSH
93874: FOR_TO
93875: IFFALSE 93987
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
93877: LD_VAR 0 1
93881: PPUSH
93882: LD_VAR 0 2
93886: PUSH
93887: LD_VAR 0 4
93891: ARRAY
93892: PUSH
93893: LD_INT 1
93895: ARRAY
93896: PPUSH
93897: LD_VAR 0 2
93901: PUSH
93902: LD_VAR 0 4
93906: ARRAY
93907: PUSH
93908: LD_INT 2
93910: ARRAY
93911: PPUSH
93912: CALL_OW 297
93916: PUSH
93917: LD_VAR 0 5
93921: LESS
93922: IFFALSE 93985
// begin hex := hexes [ i ] ;
93924: LD_ADDR_VAR 0 7
93928: PUSH
93929: LD_VAR 0 2
93933: PUSH
93934: LD_VAR 0 4
93938: ARRAY
93939: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
93940: LD_ADDR_VAR 0 5
93944: PUSH
93945: LD_VAR 0 1
93949: PPUSH
93950: LD_VAR 0 2
93954: PUSH
93955: LD_VAR 0 4
93959: ARRAY
93960: PUSH
93961: LD_INT 1
93963: ARRAY
93964: PPUSH
93965: LD_VAR 0 2
93969: PUSH
93970: LD_VAR 0 4
93974: ARRAY
93975: PUSH
93976: LD_INT 2
93978: ARRAY
93979: PPUSH
93980: CALL_OW 297
93984: ST_TO_ADDR
// end ; end ;
93985: GO 93874
93987: POP
93988: POP
// result := hex ;
93989: LD_ADDR_VAR 0 3
93993: PUSH
93994: LD_VAR 0 7
93998: ST_TO_ADDR
// end ;
93999: LD_VAR 0 3
94003: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
94004: LD_INT 0
94006: PPUSH
94007: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
94008: LD_VAR 0 1
94012: NOT
94013: PUSH
94014: LD_VAR 0 1
94018: PUSH
94019: LD_INT 21
94021: PUSH
94022: LD_INT 2
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 23
94031: PUSH
94032: LD_INT 2
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PPUSH
94043: CALL_OW 69
94047: IN
94048: NOT
94049: OR
94050: IFFALSE 94054
// exit ;
94052: GO 94101
// for i = 1 to 3 do
94054: LD_ADDR_VAR 0 3
94058: PUSH
94059: DOUBLE
94060: LD_INT 1
94062: DEC
94063: ST_TO_ADDR
94064: LD_INT 3
94066: PUSH
94067: FOR_TO
94068: IFFALSE 94099
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
94070: LD_VAR 0 1
94074: PPUSH
94075: CALL_OW 250
94079: PPUSH
94080: LD_VAR 0 1
94084: PPUSH
94085: CALL_OW 251
94089: PPUSH
94090: LD_INT 1
94092: PPUSH
94093: CALL_OW 453
94097: GO 94067
94099: POP
94100: POP
// end ;
94101: LD_VAR 0 2
94105: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
94106: LD_INT 0
94108: PPUSH
94109: PPUSH
94110: PPUSH
94111: PPUSH
94112: PPUSH
94113: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
94114: LD_VAR 0 1
94118: NOT
94119: PUSH
94120: LD_VAR 0 2
94124: NOT
94125: OR
94126: PUSH
94127: LD_VAR 0 1
94131: PPUSH
94132: CALL_OW 314
94136: OR
94137: IFFALSE 94141
// exit ;
94139: GO 94582
// x := GetX ( enemy_unit ) ;
94141: LD_ADDR_VAR 0 7
94145: PUSH
94146: LD_VAR 0 2
94150: PPUSH
94151: CALL_OW 250
94155: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
94156: LD_ADDR_VAR 0 8
94160: PUSH
94161: LD_VAR 0 2
94165: PPUSH
94166: CALL_OW 251
94170: ST_TO_ADDR
// if not x or not y then
94171: LD_VAR 0 7
94175: NOT
94176: PUSH
94177: LD_VAR 0 8
94181: NOT
94182: OR
94183: IFFALSE 94187
// exit ;
94185: GO 94582
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
94187: LD_ADDR_VAR 0 6
94191: PUSH
94192: LD_VAR 0 7
94196: PPUSH
94197: LD_INT 0
94199: PPUSH
94200: LD_INT 4
94202: PPUSH
94203: CALL_OW 272
94207: PUSH
94208: LD_VAR 0 8
94212: PPUSH
94213: LD_INT 0
94215: PPUSH
94216: LD_INT 4
94218: PPUSH
94219: CALL_OW 273
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_VAR 0 7
94232: PPUSH
94233: LD_INT 1
94235: PPUSH
94236: LD_INT 4
94238: PPUSH
94239: CALL_OW 272
94243: PUSH
94244: LD_VAR 0 8
94248: PPUSH
94249: LD_INT 1
94251: PPUSH
94252: LD_INT 4
94254: PPUSH
94255: CALL_OW 273
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_VAR 0 7
94268: PPUSH
94269: LD_INT 2
94271: PPUSH
94272: LD_INT 4
94274: PPUSH
94275: CALL_OW 272
94279: PUSH
94280: LD_VAR 0 8
94284: PPUSH
94285: LD_INT 2
94287: PPUSH
94288: LD_INT 4
94290: PPUSH
94291: CALL_OW 273
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_VAR 0 7
94304: PPUSH
94305: LD_INT 3
94307: PPUSH
94308: LD_INT 4
94310: PPUSH
94311: CALL_OW 272
94315: PUSH
94316: LD_VAR 0 8
94320: PPUSH
94321: LD_INT 3
94323: PPUSH
94324: LD_INT 4
94326: PPUSH
94327: CALL_OW 273
94331: PUSH
94332: EMPTY
94333: LIST
94334: LIST
94335: PUSH
94336: LD_VAR 0 7
94340: PPUSH
94341: LD_INT 4
94343: PPUSH
94344: LD_INT 4
94346: PPUSH
94347: CALL_OW 272
94351: PUSH
94352: LD_VAR 0 8
94356: PPUSH
94357: LD_INT 4
94359: PPUSH
94360: LD_INT 4
94362: PPUSH
94363: CALL_OW 273
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_VAR 0 7
94376: PPUSH
94377: LD_INT 5
94379: PPUSH
94380: LD_INT 4
94382: PPUSH
94383: CALL_OW 272
94387: PUSH
94388: LD_VAR 0 8
94392: PPUSH
94393: LD_INT 5
94395: PPUSH
94396: LD_INT 4
94398: PPUSH
94399: CALL_OW 273
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: ST_TO_ADDR
// for i = tmp downto 1 do
94416: LD_ADDR_VAR 0 4
94420: PUSH
94421: DOUBLE
94422: LD_VAR 0 6
94426: INC
94427: ST_TO_ADDR
94428: LD_INT 1
94430: PUSH
94431: FOR_DOWNTO
94432: IFFALSE 94533
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
94434: LD_VAR 0 6
94438: PUSH
94439: LD_VAR 0 4
94443: ARRAY
94444: PUSH
94445: LD_INT 1
94447: ARRAY
94448: PPUSH
94449: LD_VAR 0 6
94453: PUSH
94454: LD_VAR 0 4
94458: ARRAY
94459: PUSH
94460: LD_INT 2
94462: ARRAY
94463: PPUSH
94464: CALL_OW 488
94468: NOT
94469: PUSH
94470: LD_VAR 0 6
94474: PUSH
94475: LD_VAR 0 4
94479: ARRAY
94480: PUSH
94481: LD_INT 1
94483: ARRAY
94484: PPUSH
94485: LD_VAR 0 6
94489: PUSH
94490: LD_VAR 0 4
94494: ARRAY
94495: PUSH
94496: LD_INT 2
94498: ARRAY
94499: PPUSH
94500: CALL_OW 428
94504: PUSH
94505: LD_INT 0
94507: NONEQUAL
94508: OR
94509: IFFALSE 94531
// tmp := Delete ( tmp , i ) ;
94511: LD_ADDR_VAR 0 6
94515: PUSH
94516: LD_VAR 0 6
94520: PPUSH
94521: LD_VAR 0 4
94525: PPUSH
94526: CALL_OW 3
94530: ST_TO_ADDR
94531: GO 94431
94533: POP
94534: POP
// j := GetClosestHex ( unit , tmp ) ;
94535: LD_ADDR_VAR 0 5
94539: PUSH
94540: LD_VAR 0 1
94544: PPUSH
94545: LD_VAR 0 6
94549: PPUSH
94550: CALL 93835 0 2
94554: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
94555: LD_VAR 0 1
94559: PPUSH
94560: LD_VAR 0 5
94564: PUSH
94565: LD_INT 1
94567: ARRAY
94568: PPUSH
94569: LD_VAR 0 5
94573: PUSH
94574: LD_INT 2
94576: ARRAY
94577: PPUSH
94578: CALL_OW 111
// end ;
94582: LD_VAR 0 3
94586: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
94587: LD_INT 0
94589: PPUSH
94590: PPUSH
94591: PPUSH
// uc_side = 0 ;
94592: LD_ADDR_OWVAR 20
94596: PUSH
94597: LD_INT 0
94599: ST_TO_ADDR
// uc_nation = 0 ;
94600: LD_ADDR_OWVAR 21
94604: PUSH
94605: LD_INT 0
94607: ST_TO_ADDR
// InitHc_All ( ) ;
94608: CALL_OW 584
// InitVc ;
94612: CALL_OW 20
// if mastodonts then
94616: LD_VAR 0 6
94620: IFFALSE 94687
// for i = 1 to mastodonts do
94622: LD_ADDR_VAR 0 11
94626: PUSH
94627: DOUBLE
94628: LD_INT 1
94630: DEC
94631: ST_TO_ADDR
94632: LD_VAR 0 6
94636: PUSH
94637: FOR_TO
94638: IFFALSE 94685
// begin vc_chassis := 31 ;
94640: LD_ADDR_OWVAR 37
94644: PUSH
94645: LD_INT 31
94647: ST_TO_ADDR
// vc_control := control_rider ;
94648: LD_ADDR_OWVAR 38
94652: PUSH
94653: LD_INT 4
94655: ST_TO_ADDR
// animal := CreateVehicle ;
94656: LD_ADDR_VAR 0 12
94660: PUSH
94661: CALL_OW 45
94665: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94666: LD_VAR 0 12
94670: PPUSH
94671: LD_VAR 0 8
94675: PPUSH
94676: LD_INT 0
94678: PPUSH
94679: CALL 96875 0 3
// end ;
94683: GO 94637
94685: POP
94686: POP
// if horses then
94687: LD_VAR 0 5
94691: IFFALSE 94758
// for i = 1 to horses do
94693: LD_ADDR_VAR 0 11
94697: PUSH
94698: DOUBLE
94699: LD_INT 1
94701: DEC
94702: ST_TO_ADDR
94703: LD_VAR 0 5
94707: PUSH
94708: FOR_TO
94709: IFFALSE 94756
// begin hc_class := 21 ;
94711: LD_ADDR_OWVAR 28
94715: PUSH
94716: LD_INT 21
94718: ST_TO_ADDR
// hc_gallery :=  ;
94719: LD_ADDR_OWVAR 33
94723: PUSH
94724: LD_STRING 
94726: ST_TO_ADDR
// animal := CreateHuman ;
94727: LD_ADDR_VAR 0 12
94731: PUSH
94732: CALL_OW 44
94736: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94737: LD_VAR 0 12
94741: PPUSH
94742: LD_VAR 0 8
94746: PPUSH
94747: LD_INT 0
94749: PPUSH
94750: CALL 96875 0 3
// end ;
94754: GO 94708
94756: POP
94757: POP
// if birds then
94758: LD_VAR 0 1
94762: IFFALSE 94829
// for i = 1 to birds do
94764: LD_ADDR_VAR 0 11
94768: PUSH
94769: DOUBLE
94770: LD_INT 1
94772: DEC
94773: ST_TO_ADDR
94774: LD_VAR 0 1
94778: PUSH
94779: FOR_TO
94780: IFFALSE 94827
// begin hc_class = 18 ;
94782: LD_ADDR_OWVAR 28
94786: PUSH
94787: LD_INT 18
94789: ST_TO_ADDR
// hc_gallery =  ;
94790: LD_ADDR_OWVAR 33
94794: PUSH
94795: LD_STRING 
94797: ST_TO_ADDR
// animal := CreateHuman ;
94798: LD_ADDR_VAR 0 12
94802: PUSH
94803: CALL_OW 44
94807: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94808: LD_VAR 0 12
94812: PPUSH
94813: LD_VAR 0 8
94817: PPUSH
94818: LD_INT 0
94820: PPUSH
94821: CALL 96875 0 3
// end ;
94825: GO 94779
94827: POP
94828: POP
// if tigers then
94829: LD_VAR 0 2
94833: IFFALSE 94917
// for i = 1 to tigers do
94835: LD_ADDR_VAR 0 11
94839: PUSH
94840: DOUBLE
94841: LD_INT 1
94843: DEC
94844: ST_TO_ADDR
94845: LD_VAR 0 2
94849: PUSH
94850: FOR_TO
94851: IFFALSE 94915
// begin hc_class = class_tiger ;
94853: LD_ADDR_OWVAR 28
94857: PUSH
94858: LD_INT 14
94860: ST_TO_ADDR
// hc_gallery =  ;
94861: LD_ADDR_OWVAR 33
94865: PUSH
94866: LD_STRING 
94868: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
94869: LD_ADDR_OWVAR 35
94873: PUSH
94874: LD_INT 7
94876: NEG
94877: PPUSH
94878: LD_INT 7
94880: PPUSH
94881: CALL_OW 12
94885: ST_TO_ADDR
// animal := CreateHuman ;
94886: LD_ADDR_VAR 0 12
94890: PUSH
94891: CALL_OW 44
94895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94896: LD_VAR 0 12
94900: PPUSH
94901: LD_VAR 0 8
94905: PPUSH
94906: LD_INT 0
94908: PPUSH
94909: CALL 96875 0 3
// end ;
94913: GO 94850
94915: POP
94916: POP
// if apemans then
94917: LD_VAR 0 3
94921: IFFALSE 95044
// for i = 1 to apemans do
94923: LD_ADDR_VAR 0 11
94927: PUSH
94928: DOUBLE
94929: LD_INT 1
94931: DEC
94932: ST_TO_ADDR
94933: LD_VAR 0 3
94937: PUSH
94938: FOR_TO
94939: IFFALSE 95042
// begin hc_class = class_apeman ;
94941: LD_ADDR_OWVAR 28
94945: PUSH
94946: LD_INT 12
94948: ST_TO_ADDR
// hc_gallery =  ;
94949: LD_ADDR_OWVAR 33
94953: PUSH
94954: LD_STRING 
94956: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
94957: LD_ADDR_OWVAR 35
94961: PUSH
94962: LD_INT 2
94964: NEG
94965: PPUSH
94966: LD_INT 2
94968: PPUSH
94969: CALL_OW 12
94973: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
94974: LD_ADDR_OWVAR 31
94978: PUSH
94979: LD_INT 1
94981: PPUSH
94982: LD_INT 3
94984: PPUSH
94985: CALL_OW 12
94989: PUSH
94990: LD_INT 1
94992: PPUSH
94993: LD_INT 3
94995: PPUSH
94996: CALL_OW 12
95000: PUSH
95001: LD_INT 0
95003: PUSH
95004: LD_INT 0
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: ST_TO_ADDR
// animal := CreateHuman ;
95013: LD_ADDR_VAR 0 12
95017: PUSH
95018: CALL_OW 44
95022: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95023: LD_VAR 0 12
95027: PPUSH
95028: LD_VAR 0 8
95032: PPUSH
95033: LD_INT 0
95035: PPUSH
95036: CALL 96875 0 3
// end ;
95040: GO 94938
95042: POP
95043: POP
// if enchidnas then
95044: LD_VAR 0 4
95048: IFFALSE 95115
// for i = 1 to enchidnas do
95050: LD_ADDR_VAR 0 11
95054: PUSH
95055: DOUBLE
95056: LD_INT 1
95058: DEC
95059: ST_TO_ADDR
95060: LD_VAR 0 4
95064: PUSH
95065: FOR_TO
95066: IFFALSE 95113
// begin hc_class = 13 ;
95068: LD_ADDR_OWVAR 28
95072: PUSH
95073: LD_INT 13
95075: ST_TO_ADDR
// hc_gallery =  ;
95076: LD_ADDR_OWVAR 33
95080: PUSH
95081: LD_STRING 
95083: ST_TO_ADDR
// animal := CreateHuman ;
95084: LD_ADDR_VAR 0 12
95088: PUSH
95089: CALL_OW 44
95093: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
95094: LD_VAR 0 12
95098: PPUSH
95099: LD_VAR 0 8
95103: PPUSH
95104: LD_INT 0
95106: PPUSH
95107: CALL 96875 0 3
// end ;
95111: GO 95065
95113: POP
95114: POP
// if fishes then
95115: LD_VAR 0 7
95119: IFFALSE 95186
// for i = 1 to fishes do
95121: LD_ADDR_VAR 0 11
95125: PUSH
95126: DOUBLE
95127: LD_INT 1
95129: DEC
95130: ST_TO_ADDR
95131: LD_VAR 0 7
95135: PUSH
95136: FOR_TO
95137: IFFALSE 95184
// begin hc_class = 20 ;
95139: LD_ADDR_OWVAR 28
95143: PUSH
95144: LD_INT 20
95146: ST_TO_ADDR
// hc_gallery =  ;
95147: LD_ADDR_OWVAR 33
95151: PUSH
95152: LD_STRING 
95154: ST_TO_ADDR
// animal := CreateHuman ;
95155: LD_ADDR_VAR 0 12
95159: PUSH
95160: CALL_OW 44
95164: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
95165: LD_VAR 0 12
95169: PPUSH
95170: LD_VAR 0 9
95174: PPUSH
95175: LD_INT 0
95177: PPUSH
95178: CALL 96875 0 3
// end ;
95182: GO 95136
95184: POP
95185: POP
// end ;
95186: LD_VAR 0 10
95190: RET
// export function WantHeal ( sci , unit ) ; begin
95191: LD_INT 0
95193: PPUSH
// if GetTaskList ( sci ) > 0 then
95194: LD_VAR 0 1
95198: PPUSH
95199: CALL_OW 437
95203: PUSH
95204: LD_INT 0
95206: GREATER
95207: IFFALSE 95277
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
95209: LD_VAR 0 1
95213: PPUSH
95214: CALL_OW 437
95218: PUSH
95219: LD_INT 1
95221: ARRAY
95222: PUSH
95223: LD_INT 1
95225: ARRAY
95226: PUSH
95227: LD_STRING l
95229: EQUAL
95230: PUSH
95231: LD_VAR 0 1
95235: PPUSH
95236: CALL_OW 437
95240: PUSH
95241: LD_INT 1
95243: ARRAY
95244: PUSH
95245: LD_INT 4
95247: ARRAY
95248: PUSH
95249: LD_VAR 0 2
95253: EQUAL
95254: AND
95255: IFFALSE 95267
// result := true else
95257: LD_ADDR_VAR 0 3
95261: PUSH
95262: LD_INT 1
95264: ST_TO_ADDR
95265: GO 95275
// result := false ;
95267: LD_ADDR_VAR 0 3
95271: PUSH
95272: LD_INT 0
95274: ST_TO_ADDR
// end else
95275: GO 95285
// result := false ;
95277: LD_ADDR_VAR 0 3
95281: PUSH
95282: LD_INT 0
95284: ST_TO_ADDR
// end ;
95285: LD_VAR 0 3
95289: RET
// export function HealTarget ( sci ) ; begin
95290: LD_INT 0
95292: PPUSH
// if not sci then
95293: LD_VAR 0 1
95297: NOT
95298: IFFALSE 95302
// exit ;
95300: GO 95367
// result := 0 ;
95302: LD_ADDR_VAR 0 2
95306: PUSH
95307: LD_INT 0
95309: ST_TO_ADDR
// if GetTaskList ( sci ) then
95310: LD_VAR 0 1
95314: PPUSH
95315: CALL_OW 437
95319: IFFALSE 95367
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
95321: LD_VAR 0 1
95325: PPUSH
95326: CALL_OW 437
95330: PUSH
95331: LD_INT 1
95333: ARRAY
95334: PUSH
95335: LD_INT 1
95337: ARRAY
95338: PUSH
95339: LD_STRING l
95341: EQUAL
95342: IFFALSE 95367
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
95344: LD_ADDR_VAR 0 2
95348: PUSH
95349: LD_VAR 0 1
95353: PPUSH
95354: CALL_OW 437
95358: PUSH
95359: LD_INT 1
95361: ARRAY
95362: PUSH
95363: LD_INT 4
95365: ARRAY
95366: ST_TO_ADDR
// end ;
95367: LD_VAR 0 2
95371: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
95372: LD_INT 0
95374: PPUSH
95375: PPUSH
95376: PPUSH
95377: PPUSH
// if not base_units then
95378: LD_VAR 0 1
95382: NOT
95383: IFFALSE 95387
// exit ;
95385: GO 95474
// result := false ;
95387: LD_ADDR_VAR 0 2
95391: PUSH
95392: LD_INT 0
95394: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
95395: LD_ADDR_VAR 0 5
95399: PUSH
95400: LD_VAR 0 1
95404: PPUSH
95405: LD_INT 21
95407: PUSH
95408: LD_INT 3
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PPUSH
95415: CALL_OW 72
95419: ST_TO_ADDR
// if not tmp then
95420: LD_VAR 0 5
95424: NOT
95425: IFFALSE 95429
// exit ;
95427: GO 95474
// for i in tmp do
95429: LD_ADDR_VAR 0 3
95433: PUSH
95434: LD_VAR 0 5
95438: PUSH
95439: FOR_IN
95440: IFFALSE 95472
// begin result := EnemyInRange ( i , 22 ) ;
95442: LD_ADDR_VAR 0 2
95446: PUSH
95447: LD_VAR 0 3
95451: PPUSH
95452: LD_INT 22
95454: PPUSH
95455: CALL 93710 0 2
95459: ST_TO_ADDR
// if result then
95460: LD_VAR 0 2
95464: IFFALSE 95470
// exit ;
95466: POP
95467: POP
95468: GO 95474
// end ;
95470: GO 95439
95472: POP
95473: POP
// end ;
95474: LD_VAR 0 2
95478: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
95479: LD_INT 0
95481: PPUSH
95482: PPUSH
// if not units then
95483: LD_VAR 0 1
95487: NOT
95488: IFFALSE 95492
// exit ;
95490: GO 95562
// result := [ ] ;
95492: LD_ADDR_VAR 0 3
95496: PUSH
95497: EMPTY
95498: ST_TO_ADDR
// for i in units do
95499: LD_ADDR_VAR 0 4
95503: PUSH
95504: LD_VAR 0 1
95508: PUSH
95509: FOR_IN
95510: IFFALSE 95560
// if GetTag ( i ) = tag then
95512: LD_VAR 0 4
95516: PPUSH
95517: CALL_OW 110
95521: PUSH
95522: LD_VAR 0 2
95526: EQUAL
95527: IFFALSE 95558
// result := Replace ( result , result + 1 , i ) ;
95529: LD_ADDR_VAR 0 3
95533: PUSH
95534: LD_VAR 0 3
95538: PPUSH
95539: LD_VAR 0 3
95543: PUSH
95544: LD_INT 1
95546: PLUS
95547: PPUSH
95548: LD_VAR 0 4
95552: PPUSH
95553: CALL_OW 1
95557: ST_TO_ADDR
95558: GO 95509
95560: POP
95561: POP
// end ;
95562: LD_VAR 0 3
95566: RET
// export function IsDriver ( un ) ; begin
95567: LD_INT 0
95569: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
95570: LD_ADDR_VAR 0 2
95574: PUSH
95575: LD_VAR 0 1
95579: PUSH
95580: LD_INT 55
95582: PUSH
95583: EMPTY
95584: LIST
95585: PPUSH
95586: CALL_OW 69
95590: IN
95591: ST_TO_ADDR
// end ;
95592: LD_VAR 0 2
95596: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
95597: LD_INT 0
95599: PPUSH
95600: PPUSH
// list := [ ] ;
95601: LD_ADDR_VAR 0 5
95605: PUSH
95606: EMPTY
95607: ST_TO_ADDR
// case d of 0 :
95608: LD_VAR 0 3
95612: PUSH
95613: LD_INT 0
95615: DOUBLE
95616: EQUAL
95617: IFTRUE 95621
95619: GO 95754
95621: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
95622: LD_ADDR_VAR 0 5
95626: PUSH
95627: LD_VAR 0 1
95631: PUSH
95632: LD_INT 4
95634: MINUS
95635: PUSH
95636: LD_VAR 0 2
95640: PUSH
95641: LD_INT 4
95643: MINUS
95644: PUSH
95645: LD_INT 2
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: LIST
95652: PUSH
95653: LD_VAR 0 1
95657: PUSH
95658: LD_INT 3
95660: MINUS
95661: PUSH
95662: LD_VAR 0 2
95666: PUSH
95667: LD_INT 1
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: LIST
95674: PUSH
95675: LD_VAR 0 1
95679: PUSH
95680: LD_INT 4
95682: PLUS
95683: PUSH
95684: LD_VAR 0 2
95688: PUSH
95689: LD_INT 4
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: LIST
95696: PUSH
95697: LD_VAR 0 1
95701: PUSH
95702: LD_INT 3
95704: PLUS
95705: PUSH
95706: LD_VAR 0 2
95710: PUSH
95711: LD_INT 3
95713: PLUS
95714: PUSH
95715: LD_INT 5
95717: PUSH
95718: EMPTY
95719: LIST
95720: LIST
95721: LIST
95722: PUSH
95723: LD_VAR 0 1
95727: PUSH
95728: LD_VAR 0 2
95732: PUSH
95733: LD_INT 4
95735: PLUS
95736: PUSH
95737: LD_INT 0
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: LIST
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: ST_TO_ADDR
// end ; 1 :
95752: GO 96452
95754: LD_INT 1
95756: DOUBLE
95757: EQUAL
95758: IFTRUE 95762
95760: GO 95895
95762: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
95763: LD_ADDR_VAR 0 5
95767: PUSH
95768: LD_VAR 0 1
95772: PUSH
95773: LD_VAR 0 2
95777: PUSH
95778: LD_INT 4
95780: MINUS
95781: PUSH
95782: LD_INT 3
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: LIST
95789: PUSH
95790: LD_VAR 0 1
95794: PUSH
95795: LD_INT 3
95797: MINUS
95798: PUSH
95799: LD_VAR 0 2
95803: PUSH
95804: LD_INT 3
95806: MINUS
95807: PUSH
95808: LD_INT 2
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: LIST
95815: PUSH
95816: LD_VAR 0 1
95820: PUSH
95821: LD_INT 4
95823: MINUS
95824: PUSH
95825: LD_VAR 0 2
95829: PUSH
95830: LD_INT 1
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: LIST
95837: PUSH
95838: LD_VAR 0 1
95842: PUSH
95843: LD_VAR 0 2
95847: PUSH
95848: LD_INT 3
95850: PLUS
95851: PUSH
95852: LD_INT 0
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: LIST
95859: PUSH
95860: LD_VAR 0 1
95864: PUSH
95865: LD_INT 4
95867: PLUS
95868: PUSH
95869: LD_VAR 0 2
95873: PUSH
95874: LD_INT 4
95876: PLUS
95877: PUSH
95878: LD_INT 5
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: LIST
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: ST_TO_ADDR
// end ; 2 :
95893: GO 96452
95895: LD_INT 2
95897: DOUBLE
95898: EQUAL
95899: IFTRUE 95903
95901: GO 96032
95903: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
95904: LD_ADDR_VAR 0 5
95908: PUSH
95909: LD_VAR 0 1
95913: PUSH
95914: LD_VAR 0 2
95918: PUSH
95919: LD_INT 3
95921: MINUS
95922: PUSH
95923: LD_INT 3
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: LIST
95930: PUSH
95931: LD_VAR 0 1
95935: PUSH
95936: LD_INT 4
95938: PLUS
95939: PUSH
95940: LD_VAR 0 2
95944: PUSH
95945: LD_INT 4
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: LIST
95952: PUSH
95953: LD_VAR 0 1
95957: PUSH
95958: LD_VAR 0 2
95962: PUSH
95963: LD_INT 4
95965: PLUS
95966: PUSH
95967: LD_INT 0
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: LIST
95974: PUSH
95975: LD_VAR 0 1
95979: PUSH
95980: LD_INT 3
95982: MINUS
95983: PUSH
95984: LD_VAR 0 2
95988: PUSH
95989: LD_INT 1
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: LIST
95996: PUSH
95997: LD_VAR 0 1
96001: PUSH
96002: LD_INT 4
96004: MINUS
96005: PUSH
96006: LD_VAR 0 2
96010: PUSH
96011: LD_INT 4
96013: MINUS
96014: PUSH
96015: LD_INT 2
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: LIST
96022: PUSH
96023: EMPTY
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: ST_TO_ADDR
// end ; 3 :
96030: GO 96452
96032: LD_INT 3
96034: DOUBLE
96035: EQUAL
96036: IFTRUE 96040
96038: GO 96173
96040: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
96041: LD_ADDR_VAR 0 5
96045: PUSH
96046: LD_VAR 0 1
96050: PUSH
96051: LD_INT 3
96053: PLUS
96054: PUSH
96055: LD_VAR 0 2
96059: PUSH
96060: LD_INT 4
96062: PUSH
96063: EMPTY
96064: LIST
96065: LIST
96066: LIST
96067: PUSH
96068: LD_VAR 0 1
96072: PUSH
96073: LD_INT 4
96075: PLUS
96076: PUSH
96077: LD_VAR 0 2
96081: PUSH
96082: LD_INT 4
96084: PLUS
96085: PUSH
96086: LD_INT 5
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: LIST
96093: PUSH
96094: LD_VAR 0 1
96098: PUSH
96099: LD_INT 4
96101: MINUS
96102: PUSH
96103: LD_VAR 0 2
96107: PUSH
96108: LD_INT 1
96110: PUSH
96111: EMPTY
96112: LIST
96113: LIST
96114: LIST
96115: PUSH
96116: LD_VAR 0 1
96120: PUSH
96121: LD_VAR 0 2
96125: PUSH
96126: LD_INT 4
96128: MINUS
96129: PUSH
96130: LD_INT 3
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: LIST
96137: PUSH
96138: LD_VAR 0 1
96142: PUSH
96143: LD_INT 3
96145: MINUS
96146: PUSH
96147: LD_VAR 0 2
96151: PUSH
96152: LD_INT 3
96154: MINUS
96155: PUSH
96156: LD_INT 2
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: LIST
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: ST_TO_ADDR
// end ; 4 :
96171: GO 96452
96173: LD_INT 4
96175: DOUBLE
96176: EQUAL
96177: IFTRUE 96181
96179: GO 96314
96181: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
96182: LD_ADDR_VAR 0 5
96186: PUSH
96187: LD_VAR 0 1
96191: PUSH
96192: LD_VAR 0 2
96196: PUSH
96197: LD_INT 4
96199: PLUS
96200: PUSH
96201: LD_INT 0
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: LIST
96208: PUSH
96209: LD_VAR 0 1
96213: PUSH
96214: LD_INT 3
96216: PLUS
96217: PUSH
96218: LD_VAR 0 2
96222: PUSH
96223: LD_INT 3
96225: PLUS
96226: PUSH
96227: LD_INT 5
96229: PUSH
96230: EMPTY
96231: LIST
96232: LIST
96233: LIST
96234: PUSH
96235: LD_VAR 0 1
96239: PUSH
96240: LD_INT 4
96242: PLUS
96243: PUSH
96244: LD_VAR 0 2
96248: PUSH
96249: LD_INT 4
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: LIST
96256: PUSH
96257: LD_VAR 0 1
96261: PUSH
96262: LD_VAR 0 2
96266: PUSH
96267: LD_INT 3
96269: MINUS
96270: PUSH
96271: LD_INT 3
96273: PUSH
96274: EMPTY
96275: LIST
96276: LIST
96277: LIST
96278: PUSH
96279: LD_VAR 0 1
96283: PUSH
96284: LD_INT 4
96286: MINUS
96287: PUSH
96288: LD_VAR 0 2
96292: PUSH
96293: LD_INT 4
96295: MINUS
96296: PUSH
96297: LD_INT 2
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: LIST
96304: PUSH
96305: EMPTY
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: ST_TO_ADDR
// end ; 5 :
96312: GO 96452
96314: LD_INT 5
96316: DOUBLE
96317: EQUAL
96318: IFTRUE 96322
96320: GO 96451
96322: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
96323: LD_ADDR_VAR 0 5
96327: PUSH
96328: LD_VAR 0 1
96332: PUSH
96333: LD_INT 4
96335: MINUS
96336: PUSH
96337: LD_VAR 0 2
96341: PUSH
96342: LD_INT 1
96344: PUSH
96345: EMPTY
96346: LIST
96347: LIST
96348: LIST
96349: PUSH
96350: LD_VAR 0 1
96354: PUSH
96355: LD_VAR 0 2
96359: PUSH
96360: LD_INT 4
96362: MINUS
96363: PUSH
96364: LD_INT 3
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: LIST
96371: PUSH
96372: LD_VAR 0 1
96376: PUSH
96377: LD_INT 4
96379: PLUS
96380: PUSH
96381: LD_VAR 0 2
96385: PUSH
96386: LD_INT 4
96388: PLUS
96389: PUSH
96390: LD_INT 5
96392: PUSH
96393: EMPTY
96394: LIST
96395: LIST
96396: LIST
96397: PUSH
96398: LD_VAR 0 1
96402: PUSH
96403: LD_INT 3
96405: PLUS
96406: PUSH
96407: LD_VAR 0 2
96411: PUSH
96412: LD_INT 4
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: LIST
96419: PUSH
96420: LD_VAR 0 1
96424: PUSH
96425: LD_VAR 0 2
96429: PUSH
96430: LD_INT 3
96432: PLUS
96433: PUSH
96434: LD_INT 0
96436: PUSH
96437: EMPTY
96438: LIST
96439: LIST
96440: LIST
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: ST_TO_ADDR
// end ; end ;
96449: GO 96452
96451: POP
// result := list ;
96452: LD_ADDR_VAR 0 4
96456: PUSH
96457: LD_VAR 0 5
96461: ST_TO_ADDR
// end ;
96462: LD_VAR 0 4
96466: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
96467: LD_INT 0
96469: PPUSH
96470: PPUSH
96471: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
96472: LD_VAR 0 1
96476: NOT
96477: PUSH
96478: LD_VAR 0 2
96482: PUSH
96483: LD_INT 1
96485: PUSH
96486: LD_INT 2
96488: PUSH
96489: LD_INT 3
96491: PUSH
96492: LD_INT 4
96494: PUSH
96495: EMPTY
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: IN
96501: NOT
96502: OR
96503: IFFALSE 96507
// exit ;
96505: GO 96599
// tmp := [ ] ;
96507: LD_ADDR_VAR 0 5
96511: PUSH
96512: EMPTY
96513: ST_TO_ADDR
// for i in units do
96514: LD_ADDR_VAR 0 4
96518: PUSH
96519: LD_VAR 0 1
96523: PUSH
96524: FOR_IN
96525: IFFALSE 96568
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
96527: LD_ADDR_VAR 0 5
96531: PUSH
96532: LD_VAR 0 5
96536: PPUSH
96537: LD_VAR 0 5
96541: PUSH
96542: LD_INT 1
96544: PLUS
96545: PPUSH
96546: LD_VAR 0 4
96550: PPUSH
96551: LD_VAR 0 2
96555: PPUSH
96556: CALL_OW 259
96560: PPUSH
96561: CALL_OW 2
96565: ST_TO_ADDR
96566: GO 96524
96568: POP
96569: POP
// if not tmp then
96570: LD_VAR 0 5
96574: NOT
96575: IFFALSE 96579
// exit ;
96577: GO 96599
// result := SortListByListDesc ( units , tmp ) ;
96579: LD_ADDR_VAR 0 3
96583: PUSH
96584: LD_VAR 0 1
96588: PPUSH
96589: LD_VAR 0 5
96593: PPUSH
96594: CALL_OW 77
96598: ST_TO_ADDR
// end ;
96599: LD_VAR 0 3
96603: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
96604: LD_INT 0
96606: PPUSH
96607: PPUSH
96608: PPUSH
// result := false ;
96609: LD_ADDR_VAR 0 3
96613: PUSH
96614: LD_INT 0
96616: ST_TO_ADDR
// x := GetX ( building ) ;
96617: LD_ADDR_VAR 0 4
96621: PUSH
96622: LD_VAR 0 2
96626: PPUSH
96627: CALL_OW 250
96631: ST_TO_ADDR
// y := GetY ( building ) ;
96632: LD_ADDR_VAR 0 5
96636: PUSH
96637: LD_VAR 0 2
96641: PPUSH
96642: CALL_OW 251
96646: ST_TO_ADDR
// if not building or not x or not y then
96647: LD_VAR 0 2
96651: NOT
96652: PUSH
96653: LD_VAR 0 4
96657: NOT
96658: OR
96659: PUSH
96660: LD_VAR 0 5
96664: NOT
96665: OR
96666: IFFALSE 96670
// exit ;
96668: GO 96762
// if GetTaskList ( unit ) then
96670: LD_VAR 0 1
96674: PPUSH
96675: CALL_OW 437
96679: IFFALSE 96762
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96681: LD_STRING e
96683: PUSH
96684: LD_VAR 0 1
96688: PPUSH
96689: CALL_OW 437
96693: PUSH
96694: LD_INT 1
96696: ARRAY
96697: PUSH
96698: LD_INT 1
96700: ARRAY
96701: EQUAL
96702: PUSH
96703: LD_VAR 0 4
96707: PUSH
96708: LD_VAR 0 1
96712: PPUSH
96713: CALL_OW 437
96717: PUSH
96718: LD_INT 1
96720: ARRAY
96721: PUSH
96722: LD_INT 2
96724: ARRAY
96725: EQUAL
96726: AND
96727: PUSH
96728: LD_VAR 0 5
96732: PUSH
96733: LD_VAR 0 1
96737: PPUSH
96738: CALL_OW 437
96742: PUSH
96743: LD_INT 1
96745: ARRAY
96746: PUSH
96747: LD_INT 3
96749: ARRAY
96750: EQUAL
96751: AND
96752: IFFALSE 96762
// result := true end ;
96754: LD_ADDR_VAR 0 3
96758: PUSH
96759: LD_INT 1
96761: ST_TO_ADDR
// end ;
96762: LD_VAR 0 3
96766: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
96767: LD_INT 0
96769: PPUSH
// result := false ;
96770: LD_ADDR_VAR 0 4
96774: PUSH
96775: LD_INT 0
96777: ST_TO_ADDR
// if GetTaskList ( unit ) then
96778: LD_VAR 0 1
96782: PPUSH
96783: CALL_OW 437
96787: IFFALSE 96870
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
96789: LD_STRING M
96791: PUSH
96792: LD_VAR 0 1
96796: PPUSH
96797: CALL_OW 437
96801: PUSH
96802: LD_INT 1
96804: ARRAY
96805: PUSH
96806: LD_INT 1
96808: ARRAY
96809: EQUAL
96810: PUSH
96811: LD_VAR 0 2
96815: PUSH
96816: LD_VAR 0 1
96820: PPUSH
96821: CALL_OW 437
96825: PUSH
96826: LD_INT 1
96828: ARRAY
96829: PUSH
96830: LD_INT 2
96832: ARRAY
96833: EQUAL
96834: AND
96835: PUSH
96836: LD_VAR 0 3
96840: PUSH
96841: LD_VAR 0 1
96845: PPUSH
96846: CALL_OW 437
96850: PUSH
96851: LD_INT 1
96853: ARRAY
96854: PUSH
96855: LD_INT 3
96857: ARRAY
96858: EQUAL
96859: AND
96860: IFFALSE 96870
// result := true ;
96862: LD_ADDR_VAR 0 4
96866: PUSH
96867: LD_INT 1
96869: ST_TO_ADDR
// end ; end ;
96870: LD_VAR 0 4
96874: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
96875: LD_INT 0
96877: PPUSH
96878: PPUSH
96879: PPUSH
96880: PPUSH
// if not unit or not area then
96881: LD_VAR 0 1
96885: NOT
96886: PUSH
96887: LD_VAR 0 2
96891: NOT
96892: OR
96893: IFFALSE 96897
// exit ;
96895: GO 97061
// tmp := AreaToList ( area , i ) ;
96897: LD_ADDR_VAR 0 6
96901: PUSH
96902: LD_VAR 0 2
96906: PPUSH
96907: LD_VAR 0 5
96911: PPUSH
96912: CALL_OW 517
96916: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
96917: LD_ADDR_VAR 0 5
96921: PUSH
96922: DOUBLE
96923: LD_INT 1
96925: DEC
96926: ST_TO_ADDR
96927: LD_VAR 0 6
96931: PUSH
96932: LD_INT 1
96934: ARRAY
96935: PUSH
96936: FOR_TO
96937: IFFALSE 97059
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
96939: LD_ADDR_VAR 0 7
96943: PUSH
96944: LD_VAR 0 6
96948: PUSH
96949: LD_INT 1
96951: ARRAY
96952: PUSH
96953: LD_VAR 0 5
96957: ARRAY
96958: PUSH
96959: LD_VAR 0 6
96963: PUSH
96964: LD_INT 2
96966: ARRAY
96967: PUSH
96968: LD_VAR 0 5
96972: ARRAY
96973: PUSH
96974: EMPTY
96975: LIST
96976: LIST
96977: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
96978: LD_VAR 0 7
96982: PUSH
96983: LD_INT 1
96985: ARRAY
96986: PPUSH
96987: LD_VAR 0 7
96991: PUSH
96992: LD_INT 2
96994: ARRAY
96995: PPUSH
96996: CALL_OW 428
97000: PUSH
97001: LD_INT 0
97003: EQUAL
97004: IFFALSE 97057
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
97006: LD_VAR 0 1
97010: PPUSH
97011: LD_VAR 0 7
97015: PUSH
97016: LD_INT 1
97018: ARRAY
97019: PPUSH
97020: LD_VAR 0 7
97024: PUSH
97025: LD_INT 2
97027: ARRAY
97028: PPUSH
97029: LD_VAR 0 3
97033: PPUSH
97034: CALL_OW 48
// result := IsPlaced ( unit ) ;
97038: LD_ADDR_VAR 0 4
97042: PUSH
97043: LD_VAR 0 1
97047: PPUSH
97048: CALL_OW 305
97052: ST_TO_ADDR
// exit ;
97053: POP
97054: POP
97055: GO 97061
// end ; end ;
97057: GO 96936
97059: POP
97060: POP
// end ;
97061: LD_VAR 0 4
97065: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
97066: LD_INT 0
97068: PPUSH
97069: PPUSH
97070: PPUSH
// if not side or side > 8 then
97071: LD_VAR 0 1
97075: NOT
97076: PUSH
97077: LD_VAR 0 1
97081: PUSH
97082: LD_INT 8
97084: GREATER
97085: OR
97086: IFFALSE 97090
// exit ;
97088: GO 97277
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
97090: LD_ADDR_VAR 0 4
97094: PUSH
97095: LD_INT 22
97097: PUSH
97098: LD_VAR 0 1
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 21
97109: PUSH
97110: LD_INT 3
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: PPUSH
97121: CALL_OW 69
97125: ST_TO_ADDR
// if not tmp then
97126: LD_VAR 0 4
97130: NOT
97131: IFFALSE 97135
// exit ;
97133: GO 97277
// enable_addtolog := true ;
97135: LD_ADDR_OWVAR 81
97139: PUSH
97140: LD_INT 1
97142: ST_TO_ADDR
// AddToLog ( [ ) ;
97143: LD_STRING [
97145: PPUSH
97146: CALL_OW 561
// for i in tmp do
97150: LD_ADDR_VAR 0 3
97154: PUSH
97155: LD_VAR 0 4
97159: PUSH
97160: FOR_IN
97161: IFFALSE 97268
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
97163: LD_STRING [
97165: PUSH
97166: LD_VAR 0 3
97170: PPUSH
97171: CALL_OW 266
97175: STR
97176: PUSH
97177: LD_STRING , 
97179: STR
97180: PUSH
97181: LD_VAR 0 3
97185: PPUSH
97186: CALL_OW 250
97190: STR
97191: PUSH
97192: LD_STRING , 
97194: STR
97195: PUSH
97196: LD_VAR 0 3
97200: PPUSH
97201: CALL_OW 251
97205: STR
97206: PUSH
97207: LD_STRING , 
97209: STR
97210: PUSH
97211: LD_VAR 0 3
97215: PPUSH
97216: CALL_OW 254
97220: STR
97221: PUSH
97222: LD_STRING , 
97224: STR
97225: PUSH
97226: LD_VAR 0 3
97230: PPUSH
97231: LD_INT 1
97233: PPUSH
97234: CALL_OW 268
97238: STR
97239: PUSH
97240: LD_STRING , 
97242: STR
97243: PUSH
97244: LD_VAR 0 3
97248: PPUSH
97249: LD_INT 2
97251: PPUSH
97252: CALL_OW 268
97256: STR
97257: PUSH
97258: LD_STRING ],
97260: STR
97261: PPUSH
97262: CALL_OW 561
// end ;
97266: GO 97160
97268: POP
97269: POP
// AddToLog ( ]; ) ;
97270: LD_STRING ];
97272: PPUSH
97273: CALL_OW 561
// end ;
97277: LD_VAR 0 2
97281: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
97282: LD_INT 0
97284: PPUSH
97285: PPUSH
97286: PPUSH
97287: PPUSH
97288: PPUSH
// if not area or not rate or not max then
97289: LD_VAR 0 1
97293: NOT
97294: PUSH
97295: LD_VAR 0 2
97299: NOT
97300: OR
97301: PUSH
97302: LD_VAR 0 4
97306: NOT
97307: OR
97308: IFFALSE 97312
// exit ;
97310: GO 97504
// while 1 do
97312: LD_INT 1
97314: IFFALSE 97504
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
97316: LD_ADDR_VAR 0 9
97320: PUSH
97321: LD_VAR 0 1
97325: PPUSH
97326: LD_INT 1
97328: PPUSH
97329: CALL_OW 287
97333: PUSH
97334: LD_INT 10
97336: MUL
97337: ST_TO_ADDR
// r := rate / 10 ;
97338: LD_ADDR_VAR 0 7
97342: PUSH
97343: LD_VAR 0 2
97347: PUSH
97348: LD_INT 10
97350: DIVREAL
97351: ST_TO_ADDR
// time := 1 1$00 ;
97352: LD_ADDR_VAR 0 8
97356: PUSH
97357: LD_INT 2100
97359: ST_TO_ADDR
// if amount < min then
97360: LD_VAR 0 9
97364: PUSH
97365: LD_VAR 0 3
97369: LESS
97370: IFFALSE 97388
// r := r * 2 else
97372: LD_ADDR_VAR 0 7
97376: PUSH
97377: LD_VAR 0 7
97381: PUSH
97382: LD_INT 2
97384: MUL
97385: ST_TO_ADDR
97386: GO 97414
// if amount > max then
97388: LD_VAR 0 9
97392: PUSH
97393: LD_VAR 0 4
97397: GREATER
97398: IFFALSE 97414
// r := r / 2 ;
97400: LD_ADDR_VAR 0 7
97404: PUSH
97405: LD_VAR 0 7
97409: PUSH
97410: LD_INT 2
97412: DIVREAL
97413: ST_TO_ADDR
// time := time / r ;
97414: LD_ADDR_VAR 0 8
97418: PUSH
97419: LD_VAR 0 8
97423: PUSH
97424: LD_VAR 0 7
97428: DIVREAL
97429: ST_TO_ADDR
// if time < 0 then
97430: LD_VAR 0 8
97434: PUSH
97435: LD_INT 0
97437: LESS
97438: IFFALSE 97455
// time := time * - 1 ;
97440: LD_ADDR_VAR 0 8
97444: PUSH
97445: LD_VAR 0 8
97449: PUSH
97450: LD_INT 1
97452: NEG
97453: MUL
97454: ST_TO_ADDR
// wait ( time ) ;
97455: LD_VAR 0 8
97459: PPUSH
97460: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
97464: LD_INT 35
97466: PPUSH
97467: LD_INT 875
97469: PPUSH
97470: CALL_OW 12
97474: PPUSH
97475: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
97479: LD_INT 1
97481: PPUSH
97482: LD_INT 5
97484: PPUSH
97485: CALL_OW 12
97489: PPUSH
97490: LD_VAR 0 1
97494: PPUSH
97495: LD_INT 1
97497: PPUSH
97498: CALL_OW 55
// end ;
97502: GO 97312
// end ;
97504: LD_VAR 0 5
97508: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
97509: LD_INT 0
97511: PPUSH
97512: PPUSH
97513: PPUSH
97514: PPUSH
97515: PPUSH
97516: PPUSH
97517: PPUSH
97518: PPUSH
// if not turrets or not factories then
97519: LD_VAR 0 1
97523: NOT
97524: PUSH
97525: LD_VAR 0 2
97529: NOT
97530: OR
97531: IFFALSE 97535
// exit ;
97533: GO 97842
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
97535: LD_ADDR_VAR 0 10
97539: PUSH
97540: LD_INT 5
97542: PUSH
97543: LD_INT 6
97545: PUSH
97546: EMPTY
97547: LIST
97548: LIST
97549: PUSH
97550: LD_INT 2
97552: PUSH
97553: LD_INT 4
97555: PUSH
97556: EMPTY
97557: LIST
97558: LIST
97559: PUSH
97560: LD_INT 3
97562: PUSH
97563: LD_INT 5
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 24
97577: PUSH
97578: LD_INT 25
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: PUSH
97585: LD_INT 23
97587: PUSH
97588: LD_INT 27
97590: PUSH
97591: EMPTY
97592: LIST
97593: LIST
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: LD_INT 42
97601: PUSH
97602: LD_INT 43
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: PUSH
97609: LD_INT 44
97611: PUSH
97612: LD_INT 46
97614: PUSH
97615: EMPTY
97616: LIST
97617: LIST
97618: PUSH
97619: LD_INT 45
97621: PUSH
97622: LD_INT 47
97624: PUSH
97625: EMPTY
97626: LIST
97627: LIST
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: LIST
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: LIST
97638: ST_TO_ADDR
// result := [ ] ;
97639: LD_ADDR_VAR 0 3
97643: PUSH
97644: EMPTY
97645: ST_TO_ADDR
// for i in turrets do
97646: LD_ADDR_VAR 0 4
97650: PUSH
97651: LD_VAR 0 1
97655: PUSH
97656: FOR_IN
97657: IFFALSE 97840
// begin nat := GetNation ( i ) ;
97659: LD_ADDR_VAR 0 7
97663: PUSH
97664: LD_VAR 0 4
97668: PPUSH
97669: CALL_OW 248
97673: ST_TO_ADDR
// weapon := 0 ;
97674: LD_ADDR_VAR 0 8
97678: PUSH
97679: LD_INT 0
97681: ST_TO_ADDR
// if not nat then
97682: LD_VAR 0 7
97686: NOT
97687: IFFALSE 97691
// continue ;
97689: GO 97656
// for j in list [ nat ] do
97691: LD_ADDR_VAR 0 5
97695: PUSH
97696: LD_VAR 0 10
97700: PUSH
97701: LD_VAR 0 7
97705: ARRAY
97706: PUSH
97707: FOR_IN
97708: IFFALSE 97749
// if GetBWeapon ( i ) = j [ 1 ] then
97710: LD_VAR 0 4
97714: PPUSH
97715: CALL_OW 269
97719: PUSH
97720: LD_VAR 0 5
97724: PUSH
97725: LD_INT 1
97727: ARRAY
97728: EQUAL
97729: IFFALSE 97747
// begin weapon := j [ 2 ] ;
97731: LD_ADDR_VAR 0 8
97735: PUSH
97736: LD_VAR 0 5
97740: PUSH
97741: LD_INT 2
97743: ARRAY
97744: ST_TO_ADDR
// break ;
97745: GO 97749
// end ;
97747: GO 97707
97749: POP
97750: POP
// if not weapon then
97751: LD_VAR 0 8
97755: NOT
97756: IFFALSE 97760
// continue ;
97758: GO 97656
// for k in factories do
97760: LD_ADDR_VAR 0 6
97764: PUSH
97765: LD_VAR 0 2
97769: PUSH
97770: FOR_IN
97771: IFFALSE 97836
// begin weapons := AvailableWeaponList ( k ) ;
97773: LD_ADDR_VAR 0 9
97777: PUSH
97778: LD_VAR 0 6
97782: PPUSH
97783: CALL_OW 478
97787: ST_TO_ADDR
// if not weapons then
97788: LD_VAR 0 9
97792: NOT
97793: IFFALSE 97797
// continue ;
97795: GO 97770
// if weapon in weapons then
97797: LD_VAR 0 8
97801: PUSH
97802: LD_VAR 0 9
97806: IN
97807: IFFALSE 97834
// begin result := [ i , weapon ] ;
97809: LD_ADDR_VAR 0 3
97813: PUSH
97814: LD_VAR 0 4
97818: PUSH
97819: LD_VAR 0 8
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: ST_TO_ADDR
// exit ;
97828: POP
97829: POP
97830: POP
97831: POP
97832: GO 97842
// end ; end ;
97834: GO 97770
97836: POP
97837: POP
// end ;
97838: GO 97656
97840: POP
97841: POP
// end ;
97842: LD_VAR 0 3
97846: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
97847: LD_INT 0
97849: PPUSH
// if not side or side > 8 then
97850: LD_VAR 0 3
97854: NOT
97855: PUSH
97856: LD_VAR 0 3
97860: PUSH
97861: LD_INT 8
97863: GREATER
97864: OR
97865: IFFALSE 97869
// exit ;
97867: GO 97928
// if not range then
97869: LD_VAR 0 4
97873: NOT
97874: IFFALSE 97885
// range := - 12 ;
97876: LD_ADDR_VAR 0 4
97880: PUSH
97881: LD_INT 12
97883: NEG
97884: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
97885: LD_VAR 0 1
97889: PPUSH
97890: LD_VAR 0 2
97894: PPUSH
97895: LD_VAR 0 3
97899: PPUSH
97900: LD_VAR 0 4
97904: PPUSH
97905: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
97909: LD_VAR 0 1
97913: PPUSH
97914: LD_VAR 0 2
97918: PPUSH
97919: LD_VAR 0 3
97923: PPUSH
97924: CALL_OW 331
// end ;
97928: LD_VAR 0 5
97932: RET
// export function Video ( mode ) ; begin
97933: LD_INT 0
97935: PPUSH
// ingame_video = mode ;
97936: LD_ADDR_OWVAR 52
97940: PUSH
97941: LD_VAR 0 1
97945: ST_TO_ADDR
// interface_hidden = mode ;
97946: LD_ADDR_OWVAR 54
97950: PUSH
97951: LD_VAR 0 1
97955: ST_TO_ADDR
// end ;
97956: LD_VAR 0 2
97960: RET
// export function Join ( array , element ) ; begin
97961: LD_INT 0
97963: PPUSH
// result := Replace ( array , array + 1 , element ) ;
97964: LD_ADDR_VAR 0 3
97968: PUSH
97969: LD_VAR 0 1
97973: PPUSH
97974: LD_VAR 0 1
97978: PUSH
97979: LD_INT 1
97981: PLUS
97982: PPUSH
97983: LD_VAR 0 2
97987: PPUSH
97988: CALL_OW 1
97992: ST_TO_ADDR
// end ;
97993: LD_VAR 0 3
97997: RET
// export function JoinUnion ( array , element ) ; begin
97998: LD_INT 0
98000: PPUSH
// result := array union element ;
98001: LD_ADDR_VAR 0 3
98005: PUSH
98006: LD_VAR 0 1
98010: PUSH
98011: LD_VAR 0 2
98015: UNION
98016: ST_TO_ADDR
// end ;
98017: LD_VAR 0 3
98021: RET
// export function GetBehemoths ( side ) ; begin
98022: LD_INT 0
98024: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
98025: LD_ADDR_VAR 0 2
98029: PUSH
98030: LD_INT 22
98032: PUSH
98033: LD_VAR 0 1
98037: PUSH
98038: EMPTY
98039: LIST
98040: LIST
98041: PUSH
98042: LD_INT 31
98044: PUSH
98045: LD_INT 25
98047: PUSH
98048: EMPTY
98049: LIST
98050: LIST
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PPUSH
98056: CALL_OW 69
98060: ST_TO_ADDR
// end ;
98061: LD_VAR 0 2
98065: RET
// export function Shuffle ( array ) ; var i , index ; begin
98066: LD_INT 0
98068: PPUSH
98069: PPUSH
98070: PPUSH
// result := [ ] ;
98071: LD_ADDR_VAR 0 2
98075: PUSH
98076: EMPTY
98077: ST_TO_ADDR
// if not array then
98078: LD_VAR 0 1
98082: NOT
98083: IFFALSE 98087
// exit ;
98085: GO 98186
// Randomize ;
98087: CALL_OW 10
// for i = array downto 1 do
98091: LD_ADDR_VAR 0 3
98095: PUSH
98096: DOUBLE
98097: LD_VAR 0 1
98101: INC
98102: ST_TO_ADDR
98103: LD_INT 1
98105: PUSH
98106: FOR_DOWNTO
98107: IFFALSE 98184
// begin index := rand ( 1 , array ) ;
98109: LD_ADDR_VAR 0 4
98113: PUSH
98114: LD_INT 1
98116: PPUSH
98117: LD_VAR 0 1
98121: PPUSH
98122: CALL_OW 12
98126: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
98127: LD_ADDR_VAR 0 2
98131: PUSH
98132: LD_VAR 0 2
98136: PPUSH
98137: LD_VAR 0 2
98141: PUSH
98142: LD_INT 1
98144: PLUS
98145: PPUSH
98146: LD_VAR 0 1
98150: PUSH
98151: LD_VAR 0 4
98155: ARRAY
98156: PPUSH
98157: CALL_OW 2
98161: ST_TO_ADDR
// array := Delete ( array , index ) ;
98162: LD_ADDR_VAR 0 1
98166: PUSH
98167: LD_VAR 0 1
98171: PPUSH
98172: LD_VAR 0 4
98176: PPUSH
98177: CALL_OW 3
98181: ST_TO_ADDR
// end ;
98182: GO 98106
98184: POP
98185: POP
// end ;
98186: LD_VAR 0 2
98190: RET
// export function GetBaseMaterials ( base ) ; begin
98191: LD_INT 0
98193: PPUSH
// result := [ 0 , 0 , 0 ] ;
98194: LD_ADDR_VAR 0 2
98198: PUSH
98199: LD_INT 0
98201: PUSH
98202: LD_INT 0
98204: PUSH
98205: LD_INT 0
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: LIST
98212: ST_TO_ADDR
// if not base then
98213: LD_VAR 0 1
98217: NOT
98218: IFFALSE 98222
// exit ;
98220: GO 98271
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
98222: LD_ADDR_VAR 0 2
98226: PUSH
98227: LD_VAR 0 1
98231: PPUSH
98232: LD_INT 1
98234: PPUSH
98235: CALL_OW 275
98239: PUSH
98240: LD_VAR 0 1
98244: PPUSH
98245: LD_INT 2
98247: PPUSH
98248: CALL_OW 275
98252: PUSH
98253: LD_VAR 0 1
98257: PPUSH
98258: LD_INT 3
98260: PPUSH
98261: CALL_OW 275
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: LIST
98270: ST_TO_ADDR
// end ;
98271: LD_VAR 0 2
98275: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
98276: LD_INT 0
98278: PPUSH
98279: PPUSH
// result := array ;
98280: LD_ADDR_VAR 0 3
98284: PUSH
98285: LD_VAR 0 1
98289: ST_TO_ADDR
// if size > 0 then
98290: LD_VAR 0 2
98294: PUSH
98295: LD_INT 0
98297: GREATER
98298: IFFALSE 98344
// for i := array downto size do
98300: LD_ADDR_VAR 0 4
98304: PUSH
98305: DOUBLE
98306: LD_VAR 0 1
98310: INC
98311: ST_TO_ADDR
98312: LD_VAR 0 2
98316: PUSH
98317: FOR_DOWNTO
98318: IFFALSE 98342
// result := Delete ( result , result ) ;
98320: LD_ADDR_VAR 0 3
98324: PUSH
98325: LD_VAR 0 3
98329: PPUSH
98330: LD_VAR 0 3
98334: PPUSH
98335: CALL_OW 3
98339: ST_TO_ADDR
98340: GO 98317
98342: POP
98343: POP
// end ;
98344: LD_VAR 0 3
98348: RET
// export function ComExit ( unit ) ; var tmp ; begin
98349: LD_INT 0
98351: PPUSH
98352: PPUSH
// if not IsInUnit ( unit ) then
98353: LD_VAR 0 1
98357: PPUSH
98358: CALL_OW 310
98362: NOT
98363: IFFALSE 98367
// exit ;
98365: GO 98427
// tmp := IsInUnit ( unit ) ;
98367: LD_ADDR_VAR 0 3
98371: PUSH
98372: LD_VAR 0 1
98376: PPUSH
98377: CALL_OW 310
98381: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
98382: LD_VAR 0 3
98386: PPUSH
98387: CALL_OW 247
98391: PUSH
98392: LD_INT 2
98394: EQUAL
98395: IFFALSE 98408
// ComExitVehicle ( unit ) else
98397: LD_VAR 0 1
98401: PPUSH
98402: CALL_OW 121
98406: GO 98417
// ComExitBuilding ( unit ) ;
98408: LD_VAR 0 1
98412: PPUSH
98413: CALL_OW 122
// result := tmp ;
98417: LD_ADDR_VAR 0 2
98421: PUSH
98422: LD_VAR 0 3
98426: ST_TO_ADDR
// end ;
98427: LD_VAR 0 2
98431: RET
// export function ComExitAll ( units ) ; var i ; begin
98432: LD_INT 0
98434: PPUSH
98435: PPUSH
// if not units then
98436: LD_VAR 0 1
98440: NOT
98441: IFFALSE 98445
// exit ;
98443: GO 98471
// for i in units do
98445: LD_ADDR_VAR 0 3
98449: PUSH
98450: LD_VAR 0 1
98454: PUSH
98455: FOR_IN
98456: IFFALSE 98469
// ComExit ( i ) ;
98458: LD_VAR 0 3
98462: PPUSH
98463: CALL 98349 0 1
98467: GO 98455
98469: POP
98470: POP
// end ;
98471: LD_VAR 0 2
98475: RET
// export function ResetHc ; begin
98476: LD_INT 0
98478: PPUSH
// InitHc ;
98479: CALL_OW 19
// hc_importance := 0 ;
98483: LD_ADDR_OWVAR 32
98487: PUSH
98488: LD_INT 0
98490: ST_TO_ADDR
// end ;
98491: LD_VAR 0 1
98495: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
98496: LD_INT 0
98498: PPUSH
98499: PPUSH
98500: PPUSH
// _x := ( x1 + x2 ) div 2 ;
98501: LD_ADDR_VAR 0 6
98505: PUSH
98506: LD_VAR 0 1
98510: PUSH
98511: LD_VAR 0 3
98515: PLUS
98516: PUSH
98517: LD_INT 2
98519: DIV
98520: ST_TO_ADDR
// if _x < 0 then
98521: LD_VAR 0 6
98525: PUSH
98526: LD_INT 0
98528: LESS
98529: IFFALSE 98546
// _x := _x * - 1 ;
98531: LD_ADDR_VAR 0 6
98535: PUSH
98536: LD_VAR 0 6
98540: PUSH
98541: LD_INT 1
98543: NEG
98544: MUL
98545: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
98546: LD_ADDR_VAR 0 7
98550: PUSH
98551: LD_VAR 0 2
98555: PUSH
98556: LD_VAR 0 4
98560: PLUS
98561: PUSH
98562: LD_INT 2
98564: DIV
98565: ST_TO_ADDR
// if _y < 0 then
98566: LD_VAR 0 7
98570: PUSH
98571: LD_INT 0
98573: LESS
98574: IFFALSE 98591
// _y := _y * - 1 ;
98576: LD_ADDR_VAR 0 7
98580: PUSH
98581: LD_VAR 0 7
98585: PUSH
98586: LD_INT 1
98588: NEG
98589: MUL
98590: ST_TO_ADDR
// result := [ _x , _y ] ;
98591: LD_ADDR_VAR 0 5
98595: PUSH
98596: LD_VAR 0 6
98600: PUSH
98601: LD_VAR 0 7
98605: PUSH
98606: EMPTY
98607: LIST
98608: LIST
98609: ST_TO_ADDR
// end ;
98610: LD_VAR 0 5
98614: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
98615: LD_INT 0
98617: PPUSH
98618: PPUSH
98619: PPUSH
98620: PPUSH
// task := GetTaskList ( unit ) ;
98621: LD_ADDR_VAR 0 7
98625: PUSH
98626: LD_VAR 0 1
98630: PPUSH
98631: CALL_OW 437
98635: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
98636: LD_VAR 0 7
98640: NOT
98641: PUSH
98642: LD_VAR 0 1
98646: PPUSH
98647: LD_VAR 0 2
98651: PPUSH
98652: CALL_OW 308
98656: NOT
98657: AND
98658: IFFALSE 98662
// exit ;
98660: GO 98780
// if IsInArea ( unit , area ) then
98662: LD_VAR 0 1
98666: PPUSH
98667: LD_VAR 0 2
98671: PPUSH
98672: CALL_OW 308
98676: IFFALSE 98694
// begin ComMoveToArea ( unit , goAway ) ;
98678: LD_VAR 0 1
98682: PPUSH
98683: LD_VAR 0 3
98687: PPUSH
98688: CALL_OW 113
// exit ;
98692: GO 98780
// end ; if task [ 1 ] [ 1 ] <> M then
98694: LD_VAR 0 7
98698: PUSH
98699: LD_INT 1
98701: ARRAY
98702: PUSH
98703: LD_INT 1
98705: ARRAY
98706: PUSH
98707: LD_STRING M
98709: NONEQUAL
98710: IFFALSE 98714
// exit ;
98712: GO 98780
// x := task [ 1 ] [ 2 ] ;
98714: LD_ADDR_VAR 0 5
98718: PUSH
98719: LD_VAR 0 7
98723: PUSH
98724: LD_INT 1
98726: ARRAY
98727: PUSH
98728: LD_INT 2
98730: ARRAY
98731: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
98732: LD_ADDR_VAR 0 6
98736: PUSH
98737: LD_VAR 0 7
98741: PUSH
98742: LD_INT 1
98744: ARRAY
98745: PUSH
98746: LD_INT 3
98748: ARRAY
98749: ST_TO_ADDR
// if InArea ( x , y , area ) then
98750: LD_VAR 0 5
98754: PPUSH
98755: LD_VAR 0 6
98759: PPUSH
98760: LD_VAR 0 2
98764: PPUSH
98765: CALL_OW 309
98769: IFFALSE 98780
// ComStop ( unit ) ;
98771: LD_VAR 0 1
98775: PPUSH
98776: CALL_OW 141
// end ;
98780: LD_VAR 0 4
98784: RET
// export function Abs ( value ) ; begin
98785: LD_INT 0
98787: PPUSH
// result := value ;
98788: LD_ADDR_VAR 0 2
98792: PUSH
98793: LD_VAR 0 1
98797: ST_TO_ADDR
// if value < 0 then
98798: LD_VAR 0 1
98802: PUSH
98803: LD_INT 0
98805: LESS
98806: IFFALSE 98823
// result := value * - 1 ;
98808: LD_ADDR_VAR 0 2
98812: PUSH
98813: LD_VAR 0 1
98817: PUSH
98818: LD_INT 1
98820: NEG
98821: MUL
98822: ST_TO_ADDR
// end ;
98823: LD_VAR 0 2
98827: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
98828: LD_INT 0
98830: PPUSH
98831: PPUSH
98832: PPUSH
98833: PPUSH
98834: PPUSH
98835: PPUSH
98836: PPUSH
98837: PPUSH
// if not unit or not building then
98838: LD_VAR 0 1
98842: NOT
98843: PUSH
98844: LD_VAR 0 2
98848: NOT
98849: OR
98850: IFFALSE 98854
// exit ;
98852: GO 99080
// x := GetX ( building ) ;
98854: LD_ADDR_VAR 0 4
98858: PUSH
98859: LD_VAR 0 2
98863: PPUSH
98864: CALL_OW 250
98868: ST_TO_ADDR
// y := GetY ( building ) ;
98869: LD_ADDR_VAR 0 6
98873: PUSH
98874: LD_VAR 0 2
98878: PPUSH
98879: CALL_OW 251
98883: ST_TO_ADDR
// d := GetDir ( building ) ;
98884: LD_ADDR_VAR 0 8
98888: PUSH
98889: LD_VAR 0 2
98893: PPUSH
98894: CALL_OW 254
98898: ST_TO_ADDR
// r := 4 ;
98899: LD_ADDR_VAR 0 9
98903: PUSH
98904: LD_INT 4
98906: ST_TO_ADDR
// for i := 1 to 5 do
98907: LD_ADDR_VAR 0 10
98911: PUSH
98912: DOUBLE
98913: LD_INT 1
98915: DEC
98916: ST_TO_ADDR
98917: LD_INT 5
98919: PUSH
98920: FOR_TO
98921: IFFALSE 99078
// begin _x := ShiftX ( x , d , r + i ) ;
98923: LD_ADDR_VAR 0 5
98927: PUSH
98928: LD_VAR 0 4
98932: PPUSH
98933: LD_VAR 0 8
98937: PPUSH
98938: LD_VAR 0 9
98942: PUSH
98943: LD_VAR 0 10
98947: PLUS
98948: PPUSH
98949: CALL_OW 272
98953: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
98954: LD_ADDR_VAR 0 7
98958: PUSH
98959: LD_VAR 0 6
98963: PPUSH
98964: LD_VAR 0 8
98968: PPUSH
98969: LD_VAR 0 9
98973: PUSH
98974: LD_VAR 0 10
98978: PLUS
98979: PPUSH
98980: CALL_OW 273
98984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
98985: LD_VAR 0 5
98989: PPUSH
98990: LD_VAR 0 7
98994: PPUSH
98995: CALL_OW 488
98999: PUSH
99000: LD_VAR 0 5
99004: PPUSH
99005: LD_VAR 0 7
99009: PPUSH
99010: CALL_OW 428
99014: PPUSH
99015: CALL_OW 247
99019: PUSH
99020: LD_INT 3
99022: PUSH
99023: LD_INT 2
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: IN
99030: NOT
99031: AND
99032: IFFALSE 99076
// begin ComMoveXY ( unit , _x , _y ) ;
99034: LD_VAR 0 1
99038: PPUSH
99039: LD_VAR 0 5
99043: PPUSH
99044: LD_VAR 0 7
99048: PPUSH
99049: CALL_OW 111
// result := [ _x , _y ] ;
99053: LD_ADDR_VAR 0 3
99057: PUSH
99058: LD_VAR 0 5
99062: PUSH
99063: LD_VAR 0 7
99067: PUSH
99068: EMPTY
99069: LIST
99070: LIST
99071: ST_TO_ADDR
// exit ;
99072: POP
99073: POP
99074: GO 99080
// end ; end ;
99076: GO 98920
99078: POP
99079: POP
// end ;
99080: LD_VAR 0 3
99084: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
99085: LD_INT 0
99087: PPUSH
99088: PPUSH
99089: PPUSH
// result := 0 ;
99090: LD_ADDR_VAR 0 3
99094: PUSH
99095: LD_INT 0
99097: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
99098: LD_VAR 0 1
99102: PUSH
99103: LD_INT 0
99105: LESS
99106: PUSH
99107: LD_VAR 0 1
99111: PUSH
99112: LD_INT 8
99114: GREATER
99115: OR
99116: PUSH
99117: LD_VAR 0 2
99121: PUSH
99122: LD_INT 0
99124: LESS
99125: OR
99126: PUSH
99127: LD_VAR 0 2
99131: PUSH
99132: LD_INT 8
99134: GREATER
99135: OR
99136: IFFALSE 99140
// exit ;
99138: GO 99215
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
99140: LD_ADDR_VAR 0 4
99144: PUSH
99145: LD_INT 22
99147: PUSH
99148: LD_VAR 0 2
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: PPUSH
99157: CALL_OW 69
99161: PUSH
99162: FOR_IN
99163: IFFALSE 99213
// begin un := UnitShoot ( i ) ;
99165: LD_ADDR_VAR 0 5
99169: PUSH
99170: LD_VAR 0 4
99174: PPUSH
99175: CALL_OW 504
99179: ST_TO_ADDR
// if GetSide ( un ) = side1 then
99180: LD_VAR 0 5
99184: PPUSH
99185: CALL_OW 255
99189: PUSH
99190: LD_VAR 0 1
99194: EQUAL
99195: IFFALSE 99211
// begin result := un ;
99197: LD_ADDR_VAR 0 3
99201: PUSH
99202: LD_VAR 0 5
99206: ST_TO_ADDR
// exit ;
99207: POP
99208: POP
99209: GO 99215
// end ; end ;
99211: GO 99162
99213: POP
99214: POP
// end ;
99215: LD_VAR 0 3
99219: RET
// export function GetCargoBay ( units ) ; begin
99220: LD_INT 0
99222: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
99223: LD_ADDR_VAR 0 2
99227: PUSH
99228: LD_VAR 0 1
99232: PPUSH
99233: LD_INT 2
99235: PUSH
99236: LD_INT 34
99238: PUSH
99239: LD_INT 12
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: LD_INT 34
99248: PUSH
99249: LD_INT 51
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: PUSH
99256: LD_INT 34
99258: PUSH
99259: LD_INT 32
99261: PUSH
99262: EMPTY
99263: LIST
99264: LIST
99265: PUSH
99266: LD_INT 34
99268: PUSH
99269: LD_EXP 74
99273: PUSH
99274: EMPTY
99275: LIST
99276: LIST
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: PPUSH
99285: CALL_OW 72
99289: ST_TO_ADDR
// end ;
99290: LD_VAR 0 2
99294: RET
// export function Negate ( value ) ; begin
99295: LD_INT 0
99297: PPUSH
// result := not value ;
99298: LD_ADDR_VAR 0 2
99302: PUSH
99303: LD_VAR 0 1
99307: NOT
99308: ST_TO_ADDR
// end ;
99309: LD_VAR 0 2
99313: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
99314: LD_INT 0
99316: PPUSH
// if x1 = x2 then
99317: LD_VAR 0 1
99321: PUSH
99322: LD_VAR 0 3
99326: EQUAL
99327: IFFALSE 99361
// begin if y1 > y2 then
99329: LD_VAR 0 2
99333: PUSH
99334: LD_VAR 0 4
99338: GREATER
99339: IFFALSE 99351
// result := 0 else
99341: LD_ADDR_VAR 0 5
99345: PUSH
99346: LD_INT 0
99348: ST_TO_ADDR
99349: GO 99359
// result := 3 ;
99351: LD_ADDR_VAR 0 5
99355: PUSH
99356: LD_INT 3
99358: ST_TO_ADDR
// exit ;
99359: GO 99447
// end ; if y1 = y2 then
99361: LD_VAR 0 2
99365: PUSH
99366: LD_VAR 0 4
99370: EQUAL
99371: IFFALSE 99405
// begin if x1 > x2 then
99373: LD_VAR 0 1
99377: PUSH
99378: LD_VAR 0 3
99382: GREATER
99383: IFFALSE 99395
// result := 1 else
99385: LD_ADDR_VAR 0 5
99389: PUSH
99390: LD_INT 1
99392: ST_TO_ADDR
99393: GO 99403
// result := 4 ;
99395: LD_ADDR_VAR 0 5
99399: PUSH
99400: LD_INT 4
99402: ST_TO_ADDR
// exit ;
99403: GO 99447
// end ; if x1 > x2 and y1 > y2 then
99405: LD_VAR 0 1
99409: PUSH
99410: LD_VAR 0 3
99414: GREATER
99415: PUSH
99416: LD_VAR 0 2
99420: PUSH
99421: LD_VAR 0 4
99425: GREATER
99426: AND
99427: IFFALSE 99439
// result := 2 else
99429: LD_ADDR_VAR 0 5
99433: PUSH
99434: LD_INT 2
99436: ST_TO_ADDR
99437: GO 99447
// result := 5 ;
99439: LD_ADDR_VAR 0 5
99443: PUSH
99444: LD_INT 5
99446: ST_TO_ADDR
// end ;
99447: LD_VAR 0 5
99451: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
99452: LD_INT 0
99454: PPUSH
99455: PPUSH
// if not driver or not IsInUnit ( driver ) then
99456: LD_VAR 0 1
99460: NOT
99461: PUSH
99462: LD_VAR 0 1
99466: PPUSH
99467: CALL_OW 310
99471: NOT
99472: OR
99473: IFFALSE 99477
// exit ;
99475: GO 99567
// vehicle := IsInUnit ( driver ) ;
99477: LD_ADDR_VAR 0 3
99481: PUSH
99482: LD_VAR 0 1
99486: PPUSH
99487: CALL_OW 310
99491: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
99492: LD_VAR 0 1
99496: PPUSH
99497: LD_STRING \
99499: PUSH
99500: LD_INT 0
99502: PUSH
99503: LD_INT 0
99505: PUSH
99506: LD_INT 0
99508: PUSH
99509: LD_INT 0
99511: PUSH
99512: LD_INT 0
99514: PUSH
99515: LD_INT 0
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: PUSH
99527: LD_STRING E
99529: PUSH
99530: LD_INT 0
99532: PUSH
99533: LD_INT 0
99535: PUSH
99536: LD_VAR 0 3
99540: PUSH
99541: LD_INT 0
99543: PUSH
99544: LD_INT 0
99546: PUSH
99547: LD_INT 0
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: PUSH
99559: EMPTY
99560: LIST
99561: LIST
99562: PPUSH
99563: CALL_OW 446
// end ;
99567: LD_VAR 0 2
99571: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
99572: LD_INT 0
99574: PPUSH
99575: PPUSH
// if not driver or not IsInUnit ( driver ) then
99576: LD_VAR 0 1
99580: NOT
99581: PUSH
99582: LD_VAR 0 1
99586: PPUSH
99587: CALL_OW 310
99591: NOT
99592: OR
99593: IFFALSE 99597
// exit ;
99595: GO 99687
// vehicle := IsInUnit ( driver ) ;
99597: LD_ADDR_VAR 0 3
99601: PUSH
99602: LD_VAR 0 1
99606: PPUSH
99607: CALL_OW 310
99611: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
99612: LD_VAR 0 1
99616: PPUSH
99617: LD_STRING \
99619: PUSH
99620: LD_INT 0
99622: PUSH
99623: LD_INT 0
99625: PUSH
99626: LD_INT 0
99628: PUSH
99629: LD_INT 0
99631: PUSH
99632: LD_INT 0
99634: PUSH
99635: LD_INT 0
99637: PUSH
99638: EMPTY
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: PUSH
99647: LD_STRING E
99649: PUSH
99650: LD_INT 0
99652: PUSH
99653: LD_INT 0
99655: PUSH
99656: LD_VAR 0 3
99660: PUSH
99661: LD_INT 0
99663: PUSH
99664: LD_INT 0
99666: PUSH
99667: LD_INT 0
99669: PUSH
99670: EMPTY
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: PPUSH
99683: CALL_OW 447
// end ;
99687: LD_VAR 0 2
99691: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
99692: LD_INT 0
99694: PPUSH
99695: PPUSH
99696: PPUSH
// tmp := [ ] ;
99697: LD_ADDR_VAR 0 5
99701: PUSH
99702: EMPTY
99703: ST_TO_ADDR
// for i in units do
99704: LD_ADDR_VAR 0 4
99708: PUSH
99709: LD_VAR 0 1
99713: PUSH
99714: FOR_IN
99715: IFFALSE 99753
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
99717: LD_ADDR_VAR 0 5
99721: PUSH
99722: LD_VAR 0 5
99726: PPUSH
99727: LD_VAR 0 5
99731: PUSH
99732: LD_INT 1
99734: PLUS
99735: PPUSH
99736: LD_VAR 0 4
99740: PPUSH
99741: CALL_OW 256
99745: PPUSH
99746: CALL_OW 2
99750: ST_TO_ADDR
99751: GO 99714
99753: POP
99754: POP
// if not tmp then
99755: LD_VAR 0 5
99759: NOT
99760: IFFALSE 99764
// exit ;
99762: GO 99812
// if asc then
99764: LD_VAR 0 2
99768: IFFALSE 99792
// result := SortListByListAsc ( units , tmp ) else
99770: LD_ADDR_VAR 0 3
99774: PUSH
99775: LD_VAR 0 1
99779: PPUSH
99780: LD_VAR 0 5
99784: PPUSH
99785: CALL_OW 76
99789: ST_TO_ADDR
99790: GO 99812
// result := SortListByListDesc ( units , tmp ) ;
99792: LD_ADDR_VAR 0 3
99796: PUSH
99797: LD_VAR 0 1
99801: PPUSH
99802: LD_VAR 0 5
99806: PPUSH
99807: CALL_OW 77
99811: ST_TO_ADDR
// end ;
99812: LD_VAR 0 3
99816: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
99817: LD_INT 0
99819: PPUSH
99820: PPUSH
// task := GetTaskList ( mech ) ;
99821: LD_ADDR_VAR 0 4
99825: PUSH
99826: LD_VAR 0 1
99830: PPUSH
99831: CALL_OW 437
99835: ST_TO_ADDR
// if not task then
99836: LD_VAR 0 4
99840: NOT
99841: IFFALSE 99845
// exit ;
99843: GO 99887
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
99845: LD_ADDR_VAR 0 3
99849: PUSH
99850: LD_VAR 0 4
99854: PUSH
99855: LD_INT 1
99857: ARRAY
99858: PUSH
99859: LD_INT 1
99861: ARRAY
99862: PUSH
99863: LD_STRING r
99865: EQUAL
99866: PUSH
99867: LD_VAR 0 4
99871: PUSH
99872: LD_INT 1
99874: ARRAY
99875: PUSH
99876: LD_INT 4
99878: ARRAY
99879: PUSH
99880: LD_VAR 0 2
99884: EQUAL
99885: AND
99886: ST_TO_ADDR
// end ;
99887: LD_VAR 0 3
99891: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
99892: LD_INT 0
99894: PPUSH
// SetDir ( unit , d ) ;
99895: LD_VAR 0 1
99899: PPUSH
99900: LD_VAR 0 4
99904: PPUSH
99905: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
99909: LD_VAR 0 1
99913: PPUSH
99914: LD_VAR 0 2
99918: PPUSH
99919: LD_VAR 0 3
99923: PPUSH
99924: LD_VAR 0 5
99928: PPUSH
99929: CALL_OW 48
// end ;
99933: LD_VAR 0 6
99937: RET
// export function ToNaturalNumber ( number ) ; begin
99938: LD_INT 0
99940: PPUSH
// result := number div 1 ;
99941: LD_ADDR_VAR 0 2
99945: PUSH
99946: LD_VAR 0 1
99950: PUSH
99951: LD_INT 1
99953: DIV
99954: ST_TO_ADDR
// if number < 0 then
99955: LD_VAR 0 1
99959: PUSH
99960: LD_INT 0
99962: LESS
99963: IFFALSE 99973
// result := 0 ;
99965: LD_ADDR_VAR 0 2
99969: PUSH
99970: LD_INT 0
99972: ST_TO_ADDR
// end ;
99973: LD_VAR 0 2
99977: RET
// export function SortByClass ( units , class ) ; var un ; begin
99978: LD_INT 0
99980: PPUSH
99981: PPUSH
// if not units or not class then
99982: LD_VAR 0 1
99986: NOT
99987: PUSH
99988: LD_VAR 0 2
99992: NOT
99993: OR
99994: IFFALSE 99998
// exit ;
99996: GO 100093
// result := [ ] ;
99998: LD_ADDR_VAR 0 3
100002: PUSH
100003: EMPTY
100004: ST_TO_ADDR
// for un in units do
100005: LD_ADDR_VAR 0 4
100009: PUSH
100010: LD_VAR 0 1
100014: PUSH
100015: FOR_IN
100016: IFFALSE 100091
// if GetClass ( un ) = class then
100018: LD_VAR 0 4
100022: PPUSH
100023: CALL_OW 257
100027: PUSH
100028: LD_VAR 0 2
100032: EQUAL
100033: IFFALSE 100060
// result := Insert ( result , 1 , un ) else
100035: LD_ADDR_VAR 0 3
100039: PUSH
100040: LD_VAR 0 3
100044: PPUSH
100045: LD_INT 1
100047: PPUSH
100048: LD_VAR 0 4
100052: PPUSH
100053: CALL_OW 2
100057: ST_TO_ADDR
100058: GO 100089
// result := Replace ( result , result + 1 , un ) ;
100060: LD_ADDR_VAR 0 3
100064: PUSH
100065: LD_VAR 0 3
100069: PPUSH
100070: LD_VAR 0 3
100074: PUSH
100075: LD_INT 1
100077: PLUS
100078: PPUSH
100079: LD_VAR 0 4
100083: PPUSH
100084: CALL_OW 1
100088: ST_TO_ADDR
100089: GO 100015
100091: POP
100092: POP
// end ;
100093: LD_VAR 0 3
100097: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
100098: LD_INT 0
100100: PPUSH
100101: PPUSH
100102: PPUSH
100103: PPUSH
100104: PPUSH
100105: PPUSH
100106: PPUSH
// result := [ ] ;
100107: LD_ADDR_VAR 0 4
100111: PUSH
100112: EMPTY
100113: ST_TO_ADDR
// if x - r < 0 then
100114: LD_VAR 0 1
100118: PUSH
100119: LD_VAR 0 3
100123: MINUS
100124: PUSH
100125: LD_INT 0
100127: LESS
100128: IFFALSE 100140
// min_x := 0 else
100130: LD_ADDR_VAR 0 8
100134: PUSH
100135: LD_INT 0
100137: ST_TO_ADDR
100138: GO 100156
// min_x := x - r ;
100140: LD_ADDR_VAR 0 8
100144: PUSH
100145: LD_VAR 0 1
100149: PUSH
100150: LD_VAR 0 3
100154: MINUS
100155: ST_TO_ADDR
// if y - r < 0 then
100156: LD_VAR 0 2
100160: PUSH
100161: LD_VAR 0 3
100165: MINUS
100166: PUSH
100167: LD_INT 0
100169: LESS
100170: IFFALSE 100182
// min_y := 0 else
100172: LD_ADDR_VAR 0 7
100176: PUSH
100177: LD_INT 0
100179: ST_TO_ADDR
100180: GO 100198
// min_y := y - r ;
100182: LD_ADDR_VAR 0 7
100186: PUSH
100187: LD_VAR 0 2
100191: PUSH
100192: LD_VAR 0 3
100196: MINUS
100197: ST_TO_ADDR
// max_x := x + r ;
100198: LD_ADDR_VAR 0 9
100202: PUSH
100203: LD_VAR 0 1
100207: PUSH
100208: LD_VAR 0 3
100212: PLUS
100213: ST_TO_ADDR
// max_y := y + r ;
100214: LD_ADDR_VAR 0 10
100218: PUSH
100219: LD_VAR 0 2
100223: PUSH
100224: LD_VAR 0 3
100228: PLUS
100229: ST_TO_ADDR
// for _x = min_x to max_x do
100230: LD_ADDR_VAR 0 5
100234: PUSH
100235: DOUBLE
100236: LD_VAR 0 8
100240: DEC
100241: ST_TO_ADDR
100242: LD_VAR 0 9
100246: PUSH
100247: FOR_TO
100248: IFFALSE 100349
// for _y = min_y to max_y do
100250: LD_ADDR_VAR 0 6
100254: PUSH
100255: DOUBLE
100256: LD_VAR 0 7
100260: DEC
100261: ST_TO_ADDR
100262: LD_VAR 0 10
100266: PUSH
100267: FOR_TO
100268: IFFALSE 100345
// begin if not ValidHex ( _x , _y ) then
100270: LD_VAR 0 5
100274: PPUSH
100275: LD_VAR 0 6
100279: PPUSH
100280: CALL_OW 488
100284: NOT
100285: IFFALSE 100289
// continue ;
100287: GO 100267
// if GetResourceTypeXY ( _x , _y ) then
100289: LD_VAR 0 5
100293: PPUSH
100294: LD_VAR 0 6
100298: PPUSH
100299: CALL_OW 283
100303: IFFALSE 100343
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
100305: LD_ADDR_VAR 0 4
100309: PUSH
100310: LD_VAR 0 4
100314: PPUSH
100315: LD_VAR 0 4
100319: PUSH
100320: LD_INT 1
100322: PLUS
100323: PPUSH
100324: LD_VAR 0 5
100328: PUSH
100329: LD_VAR 0 6
100333: PUSH
100334: EMPTY
100335: LIST
100336: LIST
100337: PPUSH
100338: CALL_OW 1
100342: ST_TO_ADDR
// end ;
100343: GO 100267
100345: POP
100346: POP
100347: GO 100247
100349: POP
100350: POP
// end ;
100351: LD_VAR 0 4
100355: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
100356: LD_INT 0
100358: PPUSH
100359: PPUSH
100360: PPUSH
100361: PPUSH
100362: PPUSH
100363: PPUSH
// if not units then
100364: LD_VAR 0 1
100368: NOT
100369: IFFALSE 100373
// exit ;
100371: GO 100774
// result := UnitFilter ( units , [ f_ok ] ) ;
100373: LD_ADDR_VAR 0 3
100377: PUSH
100378: LD_VAR 0 1
100382: PPUSH
100383: LD_INT 50
100385: PUSH
100386: EMPTY
100387: LIST
100388: PPUSH
100389: CALL_OW 72
100393: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
100394: LD_ADDR_VAR 0 7
100398: PUSH
100399: LD_VAR 0 1
100403: PUSH
100404: LD_INT 1
100406: ARRAY
100407: PPUSH
100408: CALL_OW 255
100412: ST_TO_ADDR
// if not result then
100413: LD_VAR 0 3
100417: NOT
100418: IFFALSE 100422
// exit ;
100420: GO 100774
// for i in result do
100422: LD_ADDR_VAR 0 4
100426: PUSH
100427: LD_VAR 0 3
100431: PUSH
100432: FOR_IN
100433: IFFALSE 100772
// begin tag := GetTag ( i ) + 1 ;
100435: LD_ADDR_VAR 0 8
100439: PUSH
100440: LD_VAR 0 4
100444: PPUSH
100445: CALL_OW 110
100449: PUSH
100450: LD_INT 1
100452: PLUS
100453: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
100454: LD_ADDR_VAR 0 6
100458: PUSH
100459: LD_VAR 0 4
100463: PPUSH
100464: CALL_OW 250
100468: PPUSH
100469: LD_VAR 0 4
100473: PPUSH
100474: CALL_OW 251
100478: PPUSH
100479: LD_INT 6
100481: PPUSH
100482: CALL 100098 0 3
100486: ST_TO_ADDR
// if cr then
100487: LD_VAR 0 6
100491: IFFALSE 100530
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
100493: LD_VAR 0 4
100497: PPUSH
100498: LD_VAR 0 6
100502: PUSH
100503: LD_INT 1
100505: ARRAY
100506: PUSH
100507: LD_INT 1
100509: ARRAY
100510: PPUSH
100511: LD_VAR 0 6
100515: PUSH
100516: LD_INT 1
100518: ARRAY
100519: PUSH
100520: LD_INT 2
100522: ARRAY
100523: PPUSH
100524: CALL_OW 116
100528: GO 100770
// if path > tag then
100530: LD_VAR 0 2
100534: PUSH
100535: LD_VAR 0 8
100539: GREATER
100540: IFFALSE 100718
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
100542: LD_ADDR_VAR 0 5
100546: PUSH
100547: LD_INT 81
100549: PUSH
100550: LD_VAR 0 7
100554: PUSH
100555: EMPTY
100556: LIST
100557: LIST
100558: PUSH
100559: LD_INT 91
100561: PUSH
100562: LD_VAR 0 4
100566: PUSH
100567: LD_INT 12
100569: PUSH
100570: EMPTY
100571: LIST
100572: LIST
100573: LIST
100574: PUSH
100575: EMPTY
100576: LIST
100577: LIST
100578: PPUSH
100579: CALL_OW 69
100583: ST_TO_ADDR
// if enemy then
100584: LD_VAR 0 5
100588: IFFALSE 100616
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
100590: LD_VAR 0 4
100594: PPUSH
100595: LD_VAR 0 5
100599: PPUSH
100600: LD_VAR 0 4
100604: PPUSH
100605: CALL_OW 74
100609: PPUSH
100610: CALL_OW 115
100614: GO 100716
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
100616: LD_VAR 0 4
100620: PPUSH
100621: LD_VAR 0 2
100625: PUSH
100626: LD_VAR 0 8
100630: ARRAY
100631: PUSH
100632: LD_INT 1
100634: ARRAY
100635: PPUSH
100636: LD_VAR 0 2
100640: PUSH
100641: LD_VAR 0 8
100645: ARRAY
100646: PUSH
100647: LD_INT 2
100649: ARRAY
100650: PPUSH
100651: CALL_OW 297
100655: PUSH
100656: LD_INT 6
100658: GREATER
100659: IFFALSE 100702
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
100661: LD_VAR 0 4
100665: PPUSH
100666: LD_VAR 0 2
100670: PUSH
100671: LD_VAR 0 8
100675: ARRAY
100676: PUSH
100677: LD_INT 1
100679: ARRAY
100680: PPUSH
100681: LD_VAR 0 2
100685: PUSH
100686: LD_VAR 0 8
100690: ARRAY
100691: PUSH
100692: LD_INT 2
100694: ARRAY
100695: PPUSH
100696: CALL_OW 114
100700: GO 100716
// SetTag ( i , tag ) ;
100702: LD_VAR 0 4
100706: PPUSH
100707: LD_VAR 0 8
100711: PPUSH
100712: CALL_OW 109
// end else
100716: GO 100770
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
100718: LD_ADDR_VAR 0 5
100722: PUSH
100723: LD_INT 81
100725: PUSH
100726: LD_VAR 0 7
100730: PUSH
100731: EMPTY
100732: LIST
100733: LIST
100734: PPUSH
100735: CALL_OW 69
100739: ST_TO_ADDR
// if enemy then
100740: LD_VAR 0 5
100744: IFFALSE 100770
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
100746: LD_VAR 0 4
100750: PPUSH
100751: LD_VAR 0 5
100755: PPUSH
100756: LD_VAR 0 4
100760: PPUSH
100761: CALL_OW 74
100765: PPUSH
100766: CALL_OW 115
// end ; end ;
100770: GO 100432
100772: POP
100773: POP
// end ; end_of_file
100774: LD_VAR 0 3
100778: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
100779: LD_VAR 0 1
100783: PUSH
100784: LD_INT 200
100786: DOUBLE
100787: GREATEREQUAL
100788: IFFALSE 100796
100790: LD_INT 299
100792: DOUBLE
100793: LESSEQUAL
100794: IFTRUE 100798
100796: GO 100830
100798: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
100799: LD_VAR 0 1
100803: PPUSH
100804: LD_VAR 0 2
100808: PPUSH
100809: LD_VAR 0 3
100813: PPUSH
100814: LD_VAR 0 4
100818: PPUSH
100819: LD_VAR 0 5
100823: PPUSH
100824: CALL 57341 0 5
100828: GO 100907
100830: LD_INT 300
100832: DOUBLE
100833: GREATEREQUAL
100834: IFFALSE 100842
100836: LD_INT 399
100838: DOUBLE
100839: LESSEQUAL
100840: IFTRUE 100844
100842: GO 100906
100844: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
100845: LD_VAR 0 1
100849: PPUSH
100850: LD_VAR 0 2
100854: PPUSH
100855: LD_VAR 0 3
100859: PPUSH
100860: LD_VAR 0 4
100864: PPUSH
100865: LD_VAR 0 5
100869: PPUSH
100870: LD_VAR 0 6
100874: PPUSH
100875: LD_VAR 0 7
100879: PPUSH
100880: LD_VAR 0 8
100884: PPUSH
100885: LD_VAR 0 9
100889: PPUSH
100890: LD_VAR 0 10
100894: PPUSH
100895: LD_VAR 0 11
100899: PPUSH
100900: CALL 55239 0 11
100904: GO 100907
100906: POP
// end ;
100907: PPOPN 11
100909: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
100910: LD_VAR 0 1
100914: PPUSH
100915: LD_VAR 0 2
100919: PPUSH
100920: LD_VAR 0 3
100924: PPUSH
100925: LD_VAR 0 4
100929: PPUSH
100930: LD_VAR 0 5
100934: PPUSH
100935: CALL 57333 0 5
// end ; end_of_file
100939: PPOPN 5
100941: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
100942: LD_VAR 0 1
100946: PPUSH
100947: LD_VAR 0 2
100951: PPUSH
100952: LD_VAR 0 3
100956: PPUSH
100957: LD_VAR 0 4
100961: PPUSH
100962: LD_VAR 0 5
100966: PPUSH
100967: LD_VAR 0 6
100971: PPUSH
100972: CALL 43434 0 6
// end ;
100976: PPOPN 6
100978: END
