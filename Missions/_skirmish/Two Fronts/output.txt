// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7695 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4864 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41681 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42132 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21435 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21371 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18364 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21271 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22285 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21512 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21305 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21338 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18143 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22193 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20450 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21025 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21025 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20822 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20486 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20662 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19946 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20560 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21061 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21801 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21371 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18364 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21271 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21512 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18143 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22193 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20450 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21025 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21025 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20822 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20486 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20662 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19946 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20560 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21061 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21801 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19946 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11651 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22019 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11651 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22019 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11651 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22019 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11651 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22019 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7914 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7914 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7914 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7914 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7914 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18364 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4861
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4859
// begin PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4785: LD_EXP 22
4789: PUSH
4790: LD_INT 1
4792: ARRAY
4793: PPUSH
4794: LD_INT 18
4796: PPUSH
4797: LD_INT 0
4799: PPUSH
4800: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4804: LD_EXP 22
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 107
4815: PPUSH
4816: LD_INT 88
4818: PPUSH
4819: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4823: LD_EXP 22
4827: PUSH
4828: LD_INT 1
4830: ARRAY
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4839: LD_ADDR_EXP 22
4843: PUSH
4844: LD_EXP 22
4848: PPUSH
4849: LD_INT 1
4851: PPUSH
4852: CALL_OW 3
4856: ST_TO_ADDR
// end ;
4857: GO 4782
4859: POP
4860: POP
// end ;
4861: PPOPN 1
4863: END
// export function Dialog ; var i ; begin
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
// if not isTest then
4868: LD_EXP 1
4872: NOT
4873: IFFALSE 4895
// case query ( task ) of 1 :
4875: LD_STRING task
4877: PPUSH
4878: CALL_OW 97
4882: PUSH
4883: LD_INT 1
4885: DOUBLE
4886: EQUAL
4887: IFTRUE 4891
4889: GO 4894
4891: POP
// ; end ;
4892: GO 4895
4894: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4895: LD_INT 105
4897: PPUSH
4898: LD_INT 84
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 30
4906: NEG
4907: PPUSH
4908: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4912: LD_INT 105
4914: PPUSH
4915: LD_INT 84
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: CALL_OW 331
// InGameOn ;
4925: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4929: LD_INT 128
4931: PPUSH
4932: LD_INT 64
4934: PPUSH
4935: CALL_OW 86
// if isTest then
4939: LD_EXP 1
4943: IFFALSE 4953
// dialogue_skipped := true ;
4945: LD_ADDR_OWVAR 59
4949: PUSH
4950: LD_INT 1
4952: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4965: LD_EXP 24
4969: PPUSH
4970: LD_STRING DR2
4972: PPUSH
4973: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4977: LD_EXP 24
4981: PPUSH
4982: LD_STRING DR3
4984: PPUSH
4985: CALL_OW 94
// InGameOff ;
4989: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4993: LD_STRING C1
4995: PPUSH
4996: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5000: LD_INT 35
5002: PPUSH
5003: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5007: LD_INT 9
5009: PPUSH
5010: LD_INT 22
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 70
5024: IFFALSE 5000
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 9
5033: PPUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 6
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 70
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5066
// SetSide ( i , 3 ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 3
5059: PPUSH
5060: CALL_OW 235
5064: GO 5049
5066: POP
5067: POP
// if not isTest then
5068: LD_EXP 1
5072: NOT
5073: IFFALSE 5095
// case query ( support ) of 1 :
5075: LD_STRING support
5077: PPUSH
5078: CALL_OW 97
5082: PUSH
5083: LD_INT 1
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5094
5091: POP
// ; end ;
5092: GO 5095
5094: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 12
5100: PPUSH
5101: LD_INT 2
5103: PPUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 0
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 468
// if player_com = stolypin then
5141: LD_EXP 23
5145: PUSH
5146: LD_EXP 21
5150: EQUAL
5151: IFFALSE 5180
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5153: LD_INT 18
5155: PPUSH
5156: LD_INT 3
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_OWVAR 67
5174: ARRAY
5175: PPUSH
5176: CALL 6592 0 2
// end ;
5180: LD_VAR 0 1
5184: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5185: LD_EXP 11
5189: PUSH
5190: LD_OWVAR 1
5194: PUSH
5195: LD_INT 31500
5197: LESS
5198: AND
5199: IFFALSE 5367
// case query ( call1 ) of 1 :
5201: LD_STRING call1
5203: PPUSH
5204: CALL_OW 97
5208: PUSH
5209: LD_INT 1
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5355
5217: POP
// begin callUsed := true ;
5218: LD_ADDR_EXP 3
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 12
5231: PPUSH
5232: LD_INT 1
5234: PPUSH
5235: LD_INT 1
5237: PPUSH
5238: CALL_OW 468
// call := false ;
5242: LD_ADDR_EXP 11
5246: PUSH
5247: LD_INT 0
5249: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5250: LD_EXP 24
5254: PPUSH
5255: LD_STRING DR6
5257: PPUSH
5258: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5262: LD_INT 6300
5264: PPUSH
5265: LD_INT 8400
5267: PPUSH
5268: CALL_OW 12
5272: PPUSH
5273: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5277: LD_INT 18
5279: PUSH
5280: LD_INT 19
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 1
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: CALL_OW 12
5297: ARRAY
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: PPUSH
5310: CALL 6592 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5314: LD_INT 25200
5316: PPUSH
5317: LD_INT 35700
5319: PPUSH
5320: CALL_OW 12
5324: PPUSH
5325: CALL_OW 67
// call := true ;
5329: LD_ADDR_EXP 11
5333: PUSH
5334: LD_INT 1
5336: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 12
5342: PPUSH
5343: LD_INT 2
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 468
// end ; 2 :
5353: GO 5367
5355: LD_INT 2
5357: DOUBLE
5358: EQUAL
5359: IFTRUE 5363
5361: GO 5366
5363: POP
// ; end ;
5364: GO 5367
5366: POP
// if call and tick >= 15 15$00 then
5367: LD_EXP 11
5371: PUSH
5372: LD_OWVAR 1
5376: PUSH
5377: LD_INT 31500
5379: GREATEREQUAL
5380: AND
5381: IFFALSE 5820
// case query ( call2 ) of 1 :
5383: LD_STRING call2
5385: PPUSH
5386: CALL_OW 97
5390: PUSH
5391: LD_INT 1
5393: DOUBLE
5394: EQUAL
5395: IFTRUE 5399
5397: GO 5641
5399: POP
// begin callUsed := true ;
5400: LD_ADDR_EXP 3
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// call := false ;
5408: LD_ADDR_EXP 11
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5416: LD_INT 1
5418: PPUSH
5419: LD_INT 21
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL 11651 0 2
5433: PUSH
5434: LD_INT 4
5436: PPUSH
5437: LD_INT 21
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PPUSH
5447: CALL 11651 0 2
5451: AND
5452: IFFALSE 5500
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5454: LD_INT 18
5456: PUSH
5457: LD_INT 19
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 1
5466: PPUSH
5467: LD_INT 2
5469: PPUSH
5470: CALL_OW 12
5474: ARRAY
5475: PPUSH
5476: LD_INT 5
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PPUSH
5496: CALL 6353 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5500: LD_INT 1
5502: PPUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PPUSH
5513: CALL 11651 0 2
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5550
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5523: LD_INT 19
5525: PPUSH
5526: LD_INT 5
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: CALL 6353 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5550: LD_INT 4
5552: PPUSH
5553: LD_INT 21
5555: PUSH
5556: LD_INT 3
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 11651 0 2
5567: PUSH
5568: LD_INT 0
5570: EQUAL
5571: IFFALSE 5600
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5573: LD_INT 18
5575: PPUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 4
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_OWVAR 67
5594: ARRAY
5595: PPUSH
5596: CALL 6353 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5600: LD_INT 10500
5602: PPUSH
5603: LD_INT 23100
5605: PPUSH
5606: CALL_OW 12
5610: PPUSH
5611: CALL_OW 67
// call := true ;
5615: LD_ADDR_EXP 11
5619: PUSH
5620: LD_INT 1
5622: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_INT 12
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: LD_INT 1
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5820
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5808
5649: POP
// begin callUsed := true ;
5650: LD_ADDR_EXP 3
5654: PUSH
5655: LD_INT 1
5657: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 1
5669: PPUSH
5670: CALL_OW 468
// call := false ;
5674: LD_ADDR_EXP 11
5678: PUSH
5679: LD_INT 0
5681: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5682: LD_EXP 24
5686: PPUSH
5687: LD_STRING DR6
5689: PPUSH
5690: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5694: LD_INT 6300
5696: PPUSH
5697: LD_INT 8400
5699: PPUSH
5700: CALL_OW 12
5704: PPUSH
5705: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5709: LD_INT 18
5711: PUSH
5712: LD_INT 19
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 1
5721: PPUSH
5722: LD_INT 2
5724: PPUSH
5725: CALL_OW 12
5729: ARRAY
5730: PPUSH
5731: LD_INT 3
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 2
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_OWVAR 67
5749: ARRAY
5750: PUSH
5751: LD_INT 0
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 12
5761: MINUS
5762: PPUSH
5763: CALL 6592 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5767: LD_INT 35700
5769: PPUSH
5770: LD_INT 44100
5772: PPUSH
5773: CALL_OW 12
5777: PPUSH
5778: CALL_OW 67
// call := true ;
5782: LD_ADDR_EXP 11
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 12
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 468
// end ; 3 :
5806: GO 5820
5808: LD_INT 3
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5819
5816: POP
// ; end ;
5817: GO 5820
5819: POP
// end ;
5820: PPOPN 4
5822: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_INT 0
5854: EQUAL
5855: PUSH
5856: LD_INT 22
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 21
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: AND
5889: IFFALSE 6193
5891: GO 5893
5893: DISABLE
// begin DialogueOn ;
5894: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5898: LD_EXP 24
5902: PPUSH
5903: LD_STRING DR7
5905: PPUSH
5906: CALL_OW 94
// case player_com of Gorki :
5910: LD_EXP 23
5914: PUSH
5915: LD_EXP 20
5919: DOUBLE
5920: EQUAL
5921: IFTRUE 5925
5923: GO 5935
5925: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5926: LD_STRING ACH_GORKI
5928: PPUSH
5929: CALL_OW 543
5933: GO 5996
5935: LD_EXP 21
5939: DOUBLE
5940: EQUAL
5941: IFTRUE 5945
5943: GO 5955
5945: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5946: LD_STRING ACH_STOLYP
5948: PPUSH
5949: CALL_OW 543
5953: GO 5996
5955: LD_EXP 19
5959: DOUBLE
5960: EQUAL
5961: IFTRUE 5965
5963: GO 5975
5965: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5966: LD_STRING ACH_DAVIDOV
5968: PPUSH
5969: CALL_OW 543
5973: GO 5996
5975: LD_EXP 18
5979: DOUBLE
5980: EQUAL
5981: IFTRUE 5985
5983: GO 5995
5985: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5986: LD_STRING ACH_GLADKOV
5988: PPUSH
5989: CALL_OW 543
5993: GO 5996
5995: POP
// if not callUsed then
5996: LD_EXP 3
6000: NOT
6001: IFFALSE 6010
// SetAchievement ( ACH_NOSUPP ) ;
6003: LD_STRING ACH_NOSUPP
6005: PPUSH
6006: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6010: LD_OWVAR 1
6014: PUSH
6015: LD_INT 116550
6017: PUSH
6018: LD_INT 95550
6020: PUSH
6021: LD_INT 89250
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_OWVAR 67
6033: ARRAY
6034: LESS
6035: IFFALSE 6049
// AddMedal ( med1 , 1 ) else
6037: LD_STRING med1
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med1 , - 1 ) ;
6049: LD_STRING med1
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6060: LD_INT 81
6062: PUSH
6063: LD_INT 3
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 21
6072: PUSH
6073: LD_INT 3
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PUSH
6089: LD_INT 0
6091: EQUAL
6092: IFFALSE 6106
// AddMedal ( med3 , 1 ) else
6094: LD_STRING med3
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 101
6104: GO 6117
// AddMedal ( med3 , - 1 ) ;
6106: LD_STRING med3
6108: PPUSH
6109: LD_INT 1
6111: NEG
6112: PPUSH
6113: CALL_OW 101
// if player_loss = 0 then
6117: LD_EXP 10
6121: PUSH
6122: LD_INT 0
6124: EQUAL
6125: IFFALSE 6139
// AddMedal ( med2 , 1 ) else
6127: LD_STRING med2
6129: PPUSH
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 101
6137: GO 6182
// if player_loss > 0 and player_loss < 3 then
6139: LD_EXP 10
6143: PUSH
6144: LD_INT 0
6146: GREATER
6147: PUSH
6148: LD_EXP 10
6152: PUSH
6153: LD_INT 3
6155: LESS
6156: AND
6157: IFFALSE 6171
// AddMedal ( med2 , 2 ) else
6159: LD_STRING med2
6161: PPUSH
6162: LD_INT 2
6164: PPUSH
6165: CALL_OW 101
6169: GO 6182
// AddMedal ( med2 , - 1 ) ;
6171: LD_STRING med2
6173: PPUSH
6174: LD_INT 1
6176: NEG
6177: PPUSH
6178: CALL_OW 101
// GiveMedals ( MAIN ) ;
6182: LD_STRING MAIN
6184: PPUSH
6185: CALL_OW 102
// YouWin ;
6189: CALL_OW 103
// end ;
6193: END
// every 0 0$01 trigger IsDead ( player_com ) do
6194: LD_EXP 23
6198: PPUSH
6199: CALL_OW 301
6203: IFFALSE 6270
6205: GO 6207
6207: DISABLE
// begin if IsLive ( Houten ) then
6208: LD_EXP 4
6212: PPUSH
6213: CALL_OW 300
6217: IFFALSE 6233
// SayRadio ( Houten , DJ5 ) else
6219: LD_EXP 4
6223: PPUSH
6224: LD_STRING DJ5
6226: PPUSH
6227: CALL_OW 94
6231: GO 6256
// if IsLive ( Brown ) then
6233: LD_EXP 5
6237: PPUSH
6238: CALL_OW 300
6242: IFFALSE 6256
// SayRadio ( Brown , DS5 ) ;
6244: LD_EXP 5
6248: PPUSH
6249: LD_STRING DS5
6251: PPUSH
6252: CALL_OW 94
// Wait ( 0 0$01 ) ;
6256: LD_INT 35
6258: PPUSH
6259: CALL_OW 67
// YouLost ( dead ) ;
6263: LD_STRING dead
6265: PPUSH
6266: CALL_OW 104
// end ;
6270: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 301
6278: PUSH
6279: LD_EXP 1
6283: NOT
6284: AND
6285: IFFALSE 6352
6287: GO 6289
6289: DISABLE
// begin if IsLive ( Brown ) then
6290: LD_EXP 5
6294: PPUSH
6295: CALL_OW 300
6299: IFFALSE 6315
// SayRadio ( Brown , DS5 ) else
6301: LD_EXP 5
6305: PPUSH
6306: LD_STRING DS5
6308: PPUSH
6309: CALL_OW 94
6313: GO 6338
// if IsLive ( Houten ) then
6315: LD_EXP 4
6319: PPUSH
6320: CALL_OW 300
6324: IFFALSE 6338
// SayRadio ( Houten , DJ5 ) ;
6326: LD_EXP 4
6330: PPUSH
6331: LD_STRING DJ5
6333: PPUSH
6334: CALL_OW 94
// Wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// YouLost ( depot ) ;
6345: LD_STRING depot
6347: PPUSH
6348: CALL_OW 104
// end ;
6352: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
// for i = 1 to n do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6577
// begin uc_side := 6 ;
6376: LD_ADDR_OWVAR 20
6380: PUSH
6381: LD_INT 6
6383: ST_TO_ADDR
// uc_nation := 3 ;
6384: LD_ADDR_OWVAR 21
6388: PUSH
6389: LD_INT 3
6391: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6392: LD_ADDR_OWVAR 37
6396: PUSH
6397: LD_INT 23
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: ST_TO_ADDR
// vc_control := control_computer ;
6419: LD_ADDR_OWVAR 38
6423: PUSH
6424: LD_INT 3
6426: ST_TO_ADDR
// vc_engine := engine_siberite ;
6427: LD_ADDR_OWVAR 39
6431: PUSH
6432: LD_INT 3
6434: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6435: LD_ADDR_OWVAR 40
6439: PUSH
6440: LD_INT 43
6442: PUSH
6443: LD_INT 44
6445: PUSH
6446: LD_INT 44
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: CALL_OW 12
6464: ARRAY
6465: ST_TO_ADDR
// un := CreateVehicle ;
6466: LD_ADDR_VAR 0 5
6470: PUSH
6471: CALL_OW 45
6475: ST_TO_ADDR
// case area of east_arr :
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 18
6483: DOUBLE
6484: EQUAL
6485: IFTRUE 6489
6487: GO 6524
6489: POP
// begin PlaceUnitArea ( un , area , false ) ;
6490: LD_VAR 0 5
6494: PPUSH
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_INT 0
6502: PPUSH
6503: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6507: LD_VAR 0 5
6511: PPUSH
6512: LD_INT 79
6514: PPUSH
6515: LD_INT 33
6517: PPUSH
6518: CALL_OW 111
// end ; south_arr :
6522: GO 6568
6524: LD_INT 19
6526: DOUBLE
6527: EQUAL
6528: IFTRUE 6532
6530: GO 6567
6532: POP
// begin PlaceUnitArea ( un , area , false ) ;
6533: LD_VAR 0 5
6537: PPUSH
6538: LD_VAR 0 1
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_INT 131
6557: PPUSH
6558: LD_INT 148
6560: PPUSH
6561: CALL_OW 111
// end ; end ;
6565: GO 6568
6567: POP
// Wait ( 0 0$02 ) ;
6568: LD_INT 70
6570: PPUSH
6571: CALL_OW 67
// end ;
6575: GO 6373
6577: POP
6578: POP
// pink_attack := true ;
6579: LD_ADDR_EXP 12
6583: PUSH
6584: LD_INT 1
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 3
6591: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// for i = 1 to n do
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: DOUBLE
6603: LD_INT 1
6605: DEC
6606: ST_TO_ADDR
6607: LD_VAR 0 2
6611: PUSH
6612: FOR_TO
6613: IFFALSE 6839
// begin uc_side := 6 ;
6615: LD_ADDR_OWVAR 20
6619: PUSH
6620: LD_INT 6
6622: ST_TO_ADDR
// uc_nation := 3 ;
6623: LD_ADDR_OWVAR 21
6627: PUSH
6628: LD_INT 3
6630: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6631: LD_INT 0
6633: PPUSH
6634: LD_INT 3
6636: PPUSH
6637: LD_INT 4
6639: PPUSH
6640: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6644: LD_ADDR_OWVAR 37
6648: PUSH
6649: LD_INT 22
6651: ST_TO_ADDR
// vc_control := control_manual ;
6652: LD_ADDR_OWVAR 38
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// vc_engine := engine_combustion ;
6660: LD_ADDR_OWVAR 39
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6668: LD_ADDR_OWVAR 40
6672: PUSH
6673: LD_INT 51
6675: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6676: LD_ADDR_OWVAR 41
6680: PUSH
6681: LD_INT 50
6683: ST_TO_ADDR
// un := CreateVehicle ;
6684: LD_ADDR_VAR 0 5
6688: PUSH
6689: CALL_OW 45
6693: ST_TO_ADDR
// case area of east_arr :
6694: LD_VAR 0 1
6698: PUSH
6699: LD_INT 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6722
6707: POP
// SetDir ( un , 4 ) ; south_arr :
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: CALL_OW 233
6720: GO 6746
6722: LD_INT 19
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6745
6730: POP
// SetDir ( un , 5 ) ; end ;
6731: LD_VAR 0 5
6735: PPUSH
6736: LD_INT 5
6738: PPUSH
6739: CALL_OW 233
6743: GO 6746
6745: POP
// PlaceUnitArea ( un , area , false ) ;
6746: LD_VAR 0 5
6750: PPUSH
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6763: CALL_OW 44
6767: PPUSH
6768: LD_VAR 0 5
6772: PPUSH
6773: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6777: LD_VAR 0 5
6781: PPUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 100
6787: PPUSH
6788: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6792: LD_VAR 0 5
6796: PPUSH
6797: LD_INT 106
6799: PPUSH
6800: LD_INT 88
6802: PPUSH
6803: CALL_OW 111
// AddComUnload ( un ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 173
// Wait ( 0 0$02 ) ;
6830: LD_INT 70
6832: PPUSH
6833: CALL_OW 67
// end ;
6837: GO 6612
6839: POP
6840: POP
// Wait ( 0 0$05 ) ;
6841: LD_INT 175
6843: PPUSH
6844: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6848: LD_INT 6
6850: PPUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 51
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL 11651 0 2
6865: IFFALSE 7053
// begin wait ( 0 0$01 ) ;
6867: LD_INT 35
6869: PPUSH
6870: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6874: LD_ADDR_VAR 0 4
6878: PUSH
6879: LD_INT 6
6881: PPUSH
6882: LD_INT 34
6884: PUSH
6885: LD_INT 51
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL 11651 0 2
6896: PUSH
6897: FOR_IN
6898: IFFALSE 7049
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6900: LD_VAR 0 4
6904: PPUSH
6905: LD_INT 9
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 4
6917: PPUSH
6918: CALL 31773 0 1
6922: PPUSH
6923: CALL_OW 258
6927: PUSH
6928: LD_INT 1
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 9
6937: AND
6938: IFFALSE 6965
// begin Say ( GetDriver ( i ) , Dtran ) ;
6940: LD_VAR 0 4
6944: PPUSH
6945: CALL 31773 0 1
6949: PPUSH
6950: LD_STRING Dtran
6952: PPUSH
6953: CALL_OW 88
// dialog_trans := false ;
6957: LD_ADDR_EXP 9
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6965: LD_VAR 0 4
6969: PPUSH
6970: CALL_OW 316
6974: IFFALSE 6990
// ComMoveToArea ( i , area ) ;
6976: LD_VAR 0 4
6980: PPUSH
6981: LD_VAR 0 1
6985: PPUSH
6986: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6990: LD_VAR 0 4
6994: PPUSH
6995: LD_VAR 0 1
6999: PPUSH
7000: CALL_OW 308
7004: PUSH
7005: LD_VAR 0 4
7009: PPUSH
7010: LD_INT 1
7012: PPUSH
7013: CALL_OW 289
7017: PUSH
7018: LD_INT 0
7020: EQUAL
7021: AND
7022: IFFALSE 7047
// begin RemoveUnit ( GetDriver ( i ) ) ;
7024: LD_VAR 0 4
7028: PPUSH
7029: CALL 31773 0 1
7033: PPUSH
7034: CALL_OW 64
// RemoveUnit ( i ) ;
7038: LD_VAR 0 4
7042: PPUSH
7043: CALL_OW 64
// end ; end ;
7047: GO 6897
7049: POP
7050: POP
// end ;
7051: GO 6848
// end ;
7053: LD_VAR 0 3
7057: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7058: LD_INT 0
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
// if isTest then
7064: LD_EXP 1
7068: IFFALSE 7072
// exit ;
7070: GO 7517
// for i = 1 to n do
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: DOUBLE
7078: LD_INT 1
7080: DEC
7081: ST_TO_ADDR
7082: LD_VAR 0 2
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7376
// begin uc_side := 8 ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_INT 8
7097: ST_TO_ADDR
// uc_nation := 1 ;
7098: LD_ADDR_OWVAR 21
7102: PUSH
7103: LD_INT 1
7105: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7106: LD_ADDR_VAR 0 6
7110: PUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: LD_INT 4
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 1
7127: PPUSH
7128: LD_OWVAR 67
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// vc_chassis := ch ;
7139: LD_ADDR_OWVAR 37
7143: PUSH
7144: LD_VAR 0 6
7148: ST_TO_ADDR
// vc_control := control_computer ;
7149: LD_ADDR_OWVAR 38
7153: PUSH
7154: LD_INT 3
7156: ST_TO_ADDR
// vc_engine := engine_combustion ;
7157: LD_ADDR_OWVAR 39
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7165: LD_OWVAR 1
7169: PUSH
7170: LD_INT 42000
7172: PUSH
7173: LD_INT 33600
7175: PUSH
7176: LD_INT 29400
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_OWVAR 67
7188: ARRAY
7189: LESS
7190: IFFALSE 7221
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7192: LD_ADDR_OWVAR 40
7196: PUSH
7197: LD_INT 3
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 1
7209: PPUSH
7210: LD_INT 2
7212: PPUSH
7213: CALL_OW 12
7217: ARRAY
7218: ST_TO_ADDR
7219: GO 7317
// if ch = us_medium_tracked then
7221: LD_VAR 0 6
7225: PUSH
7226: LD_INT 3
7228: EQUAL
7229: IFFALSE 7276
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7231: LD_ADDR_OWVAR 40
7235: PUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 4
7241: PUSH
7242: LD_INT 5
7244: PUSH
7245: LD_INT 7
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_OWVAR 67
7258: PPUSH
7259: LD_OWVAR 67
7263: PUSH
7264: LD_INT 1
7266: PLUS
7267: PPUSH
7268: CALL_OW 12
7272: ARRAY
7273: ST_TO_ADDR
7274: GO 7317
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7276: LD_ADDR_OWVAR 40
7280: PUSH
7281: LD_INT 5
7283: PUSH
7284: LD_INT 6
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 7
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_OWVAR 67
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PPUSH
7311: CALL_OW 12
7315: ARRAY
7316: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7317: LD_ADDR_OWVAR 41
7321: PUSH
7322: LD_INT 70
7324: ST_TO_ADDR
// un := CreateVehicle ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: CALL_OW 45
7334: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7335: LD_VAR 0 5
7339: PPUSH
7340: LD_VAR 0 1
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7352: LD_VAR 0 5
7356: PPUSH
7357: LD_INT 65
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL_OW 111
// Wait ( 0 0$02 ) ;
7367: LD_INT 70
7369: PPUSH
7370: CALL_OW 67
// end ;
7374: GO 7087
7376: POP
7377: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7378: LD_INT 90
7380: PUSH
7381: LD_INT 80
7383: PUSH
7384: LD_INT 70
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: PUSH
7392: LD_OWVAR 67
7396: ARRAY
7397: PPUSH
7398: CALL_OW 13
7402: IFFALSE 7509
// begin uc_side := 8 ;
7404: LD_ADDR_OWVAR 20
7408: PUSH
7409: LD_INT 8
7411: ST_TO_ADDR
// uc_nation := 1 ;
7412: LD_ADDR_OWVAR 21
7416: PUSH
7417: LD_INT 1
7419: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7420: LD_ADDR_OWVAR 37
7424: PUSH
7425: LD_INT 4
7427: ST_TO_ADDR
// vc_control := control_computer ;
7428: LD_ADDR_OWVAR 38
7432: PUSH
7433: LD_INT 3
7435: ST_TO_ADDR
// vc_engine := engine_combustion ;
7436: LD_ADDR_OWVAR 39
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7444: LD_ADDR_OWVAR 40
7448: PUSH
7449: LD_INT 14
7451: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7452: LD_ADDR_OWVAR 41
7456: PUSH
7457: LD_INT 70
7459: ST_TO_ADDR
// un := CreateVehicle ;
7460: LD_ADDR_VAR 0 5
7464: PUSH
7465: CALL_OW 45
7469: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7470: LD_VAR 0 5
7474: PPUSH
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7487: LD_VAR 0 5
7491: PPUSH
7492: LD_INT 65
7494: PPUSH
7495: LD_INT 9
7497: PPUSH
7498: CALL_OW 111
// Wait ( 0 0$02 ) ;
7502: LD_INT 70
7504: PPUSH
7505: CALL_OW 67
// end ; alfa_support := true ;
7509: LD_ADDR_EXP 13
7513: PUSH
7514: LD_INT 1
7516: ST_TO_ADDR
// end ;
7517: LD_VAR 0 3
7521: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7522: LD_OWVAR 1
7526: PUSH
7527: LD_INT 25200
7529: PUSH
7530: LD_INT 23100
7532: PUSH
7533: LD_INT 21000
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_OWVAR 67
7545: ARRAY
7546: GREATER
7547: IFFALSE 7692
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 3
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: LD_INT 5
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7580: LD_INT 1050
7582: PPUSH
7583: LD_INT 4200
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7595: LD_INT 20
7597: PPUSH
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL 7058 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7607: LD_INT 22
7609: PUSH
7610: LD_INT 8
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: IFFALSE 7635
// SayRadio ( Popov , DR5 ) ;
7623: LD_EXP 24
7627: PPUSH
7628: LD_STRING DR5
7630: PPUSH
7631: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7635: LD_INT 8400
7637: PPUSH
7638: LD_INT 12600
7640: PPUSH
7641: CALL_OW 12
7645: PPUSH
7646: CALL_OW 67
// n := n + 1 ;
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 1
7659: PUSH
7660: LD_INT 1
7662: PLUS
7663: ST_TO_ADDR
// if n > 9 then
7664: LD_VAR 0 1
7668: PUSH
7669: LD_INT 9
7671: GREATER
7672: IFFALSE 7682
// n := 9 ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 9
7681: ST_TO_ADDR
// until tick >= 120 120$00 ;
7682: LD_OWVAR 1
7686: PUSH
7687: LD_INT 252000
7689: GREATEREQUAL
7690: IFFALSE 7580
// end ; end_of_file
7692: PPOPN 1
7694: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7695: LD_INT 0
7697: PPUSH
// enable_addtolog := isTest ;
7698: LD_ADDR_OWVAR 81
7702: PUSH
7703: LD_EXP 1
7707: ST_TO_ADDR
// lines_break_limit := 5 ;
7708: LD_ADDR_EXP 26
7712: PUSH
7713: LD_INT 5
7715: ST_TO_ADDR
// lines_break_type := --- ;
7716: LD_ADDR_EXP 27
7720: PUSH
7721: LD_STRING ---
7723: ST_TO_ADDR
// lines_counter := 0 ;
7724: LD_ADDR_EXP 25
7728: PUSH
7729: LD_INT 0
7731: ST_TO_ADDR
// show_line_index := true ;
7732: LD_ADDR_EXP 28
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// tick_log := true ;
7740: LD_ADDR_EXP 29
7744: PUSH
7745: LD_INT 1
7747: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7748: LD_STRING ----------SAND OF SIBERIA LOG----------
7750: PPUSH
7751: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7755: LD_STRING Map Name: 
7757: PUSH
7758: LD_OWVAR 68
7762: STR
7763: PPUSH
7764: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7768: LD_STRING Map Number: 
7770: PUSH
7771: LD_OWVAR 70
7775: STR
7776: PPUSH
7777: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7781: LD_STRING Difficulty: 
7783: PUSH
7784: LD_OWVAR 67
7788: STR
7789: PPUSH
7790: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7794: LD_STRING ---------------------------------------
7796: PPUSH
7797: CALL_OW 561
// end ;
7801: LD_VAR 0 1
7805: RET
// function Log ( text ) ; begin
7806: LD_INT 0
7808: PPUSH
// if show_line_index then
7809: LD_EXP 28
7813: IFFALSE 7825
// result := lines_counter ;
7815: LD_ADDR_VAR 0 2
7819: PUSH
7820: LD_EXP 25
7824: ST_TO_ADDR
// if tick_log then
7825: LD_EXP 29
7829: IFFALSE 7855
// result := result &  T:  & tick &   ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_VAR 0 2
7840: PUSH
7841: LD_STRING  T: 
7843: STR
7844: PUSH
7845: LD_OWVAR 1
7849: STR
7850: PUSH
7851: LD_STRING  
7853: STR
7854: ST_TO_ADDR
// AddToLog ( result & text ) ;
7855: LD_VAR 0 2
7859: PUSH
7860: LD_VAR 0 1
7864: STR
7865: PPUSH
7866: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7870: LD_ADDR_EXP 25
7874: PUSH
7875: LD_EXP 25
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7884: LD_EXP 25
7888: PUSH
7889: LD_EXP 26
7893: MOD
7894: PUSH
7895: LD_INT 0
7897: EQUAL
7898: IFFALSE 7909
// AddToLog ( lines_break_type ) ;
7900: LD_EXP 27
7904: PPUSH
7905: CALL_OW 561
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogHuman ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7917: LD_STRING Human Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; class: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 257
7954: STR
7955: PUSH
7956: LD_STRING ; 
7958: STR
7959: PPUSH
7960: CALL 7806 0 1
// end ;
7964: LD_VAR 0 2
7968: RET
// export function LogVeh ( id ) ; begin
7969: LD_INT 0
7971: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7972: LD_STRING Vehicle Created. id: 
7974: PUSH
7975: LD_VAR 0 1
7979: STR
7980: PUSH
7981: LD_STRING ; side: 
7983: STR
7984: PUSH
7985: LD_VAR 0 1
7989: PPUSH
7990: CALL_OW 255
7994: STR
7995: PUSH
7996: LD_STRING ; nation: 
7998: STR
7999: PUSH
8000: LD_VAR 0 1
8004: PPUSH
8005: CALL_OW 248
8009: STR
8010: PUSH
8011: LD_STRING ; weapon: 
8013: STR
8014: PUSH
8015: LD_VAR 0 1
8019: PPUSH
8020: CALL_OW 264
8024: STR
8025: PUSH
8026: LD_STRING ; 
8028: STR
8029: PPUSH
8030: CALL 7806 0 1
// end ;
8034: LD_VAR 0 2
8038: RET
// export function LogEvent ( event ) ; begin
8039: LD_INT 0
8041: PPUSH
// Log ( Event Executed. id:  & event ) ;
8042: LD_STRING Event Executed. id: 
8044: PUSH
8045: LD_VAR 0 1
8049: STR
8050: PPUSH
8051: CALL 7806 0 1
// end ; end_of_file
8055: LD_VAR 0 2
8059: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
8068: PPUSH
8069: PPUSH
// if unit then
8070: LD_VAR 0 1
8074: IFFALSE 8474
// begin if mode = 0 then
8076: LD_VAR 0 3
8080: PUSH
8081: LD_INT 0
8083: EQUAL
8084: IFFALSE 8232
// begin if coords then
8086: LD_VAR 0 2
8090: IFFALSE 8230
// while ( coords > 1 ) do
8092: LD_VAR 0 2
8096: PUSH
8097: LD_INT 1
8099: GREATER
8100: IFFALSE 8230
// if not HasTask ( unit ) then
8102: LD_VAR 0 1
8106: PPUSH
8107: CALL_OW 314
8111: NOT
8112: IFFALSE 8228
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_VAR 0 2
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PPUSH
8137: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 250
8157: PUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: EQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 251
8177: PUSH
8178: LD_VAR 0 2
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: EQUAL
8187: AND
8188: IFFALSE 8141
// for i = 1 to 2 do
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_INT 2
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8226
// coords := Delete ( coords , 1 ) ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_VAR 0 2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 3
8223: ST_TO_ADDR
8224: GO 8203
8226: POP
8227: POP
// end ;
8228: GO 8092
// end else
8230: GO 8474
// begin if coords then
8232: LD_VAR 0 2
8236: IFFALSE 8474
// begin x := GetX ( unit ) ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 250
8252: ST_TO_ADDR
// y := GetY ( unit ) ;
8253: LD_ADDR_VAR 0 7
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 251
8267: ST_TO_ADDR
// while ( coords > 1 ) do
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8474
// begin Wait ( 0 0$0.3 ) ;
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 250
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 251
8314: PPUSH
8315: LD_INT 14
8317: PPUSH
8318: CALL 22821 0 4
8322: IFFALSE 8353
// begin ComMoveXY ( unit , x , y ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: LD_VAR 0 6
8333: PPUSH
8334: LD_VAR 0 7
8338: PPUSH
8339: CALL_OW 111
// result := false ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_INT 0
8350: ST_TO_ADDR
// end else
8351: GO 8392
// if not HasTask ( unit ) then
8353: LD_VAR 0 1
8357: PPUSH
8358: CALL_OW 314
8362: NOT
8363: IFFALSE 8392
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8365: LD_VAR 0 1
8369: PPUSH
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 1
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 2
8386: ARRAY
8387: PPUSH
8388: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8392: LD_VAR 0 1
8396: PPUSH
8397: CALL_OW 250
8401: PUSH
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: EQUAL
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 251
8421: PUSH
8422: LD_VAR 0 2
8426: PUSH
8427: LD_INT 2
8429: ARRAY
8430: EQUAL
8431: AND
8432: IFFALSE 8472
// for i = 1 to 2 do
8434: LD_ADDR_VAR 0 5
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_INT 2
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8470
// coords := Delete ( coords , 1 ) ;
8450: LD_ADDR_VAR 0 2
8454: PUSH
8455: LD_VAR 0 2
8459: PPUSH
8460: LD_INT 1
8462: PPUSH
8463: CALL_OW 3
8467: ST_TO_ADDR
8468: GO 8447
8470: POP
8471: POP
// end ;
8472: GO 8268
// end ; end ; end ; result := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// end ;
8482: LD_VAR 0 4
8486: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
// if not units then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8564
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8501: LD_ADDR_VAR 0 5
8505: PUSH
8506: LD_INT 81
8508: PUSH
8509: LD_VAR 0 1
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// for i in units do
8523: LD_ADDR_VAR 0 4
8527: PUSH
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_IN
8534: IFFALSE 8562
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8536: LD_VAR 0 4
8540: PPUSH
8541: LD_VAR 0 5
8545: PPUSH
8546: LD_VAR 0 4
8550: PPUSH
8551: CALL_OW 74
8555: PPUSH
8556: CALL_OW 115
// end ;
8560: GO 8533
8562: POP
8563: POP
// end ;
8564: LD_VAR 0 3
8568: RET
// export function MC_Show ( string ) ; begin
8569: LD_INT 0
8571: PPUSH
// display_strings := string ;
8572: LD_ADDR_OWVAR 47
8576: PUSH
8577: LD_VAR 0 1
8581: ST_TO_ADDR
// end ; end_of_file
8582: LD_VAR 0 2
8586: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8587: LD_INT 0
8589: PPUSH
8590: PPUSH
8591: PPUSH
8592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8593: LD_ADDR_VAR 0 8
8597: PUSH
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 2
8605: PPUSH
8606: EMPTY
8607: PPUSH
8608: CALL 11734 0 3
8612: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8613: LD_VAR 0 8
8617: PUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 428
8632: PUSH
8633: LD_INT 0
8635: EQUAL
8636: AND
8637: IFFALSE 8711
// for i = 1 to plist do
8639: LD_ADDR_VAR 0 6
8643: PUSH
8644: DOUBLE
8645: LD_INT 1
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 8
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8709
// if NotTask ( plist [ i ] ) then
8657: LD_VAR 0 8
8661: PUSH
8662: LD_VAR 0 6
8666: ARRAY
8667: PPUSH
8668: CALL 32236 0 1
8672: IFFALSE 8707
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8674: LD_VAR 0 8
8678: PUSH
8679: LD_VAR 0 6
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: LD_VAR 0 3
8697: PPUSH
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 145
// end ;
8707: GO 8654
8709: POP
8710: POP
// end ;
8711: LD_VAR 0 5
8715: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8716: LD_INT 0
8718: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8719: LD_VAR 0 1
8723: PPUSH
8724: LD_INT 6
8726: PPUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: LD_VAR 0 4
8741: PPUSH
8742: CALL 10220 0 5
// end ;
8746: LD_VAR 0 5
8750: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8751: LD_INT 0
8753: PPUSH
8754: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8755: LD_ADDR_VAR 0 4
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_VAR 0 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 0
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 1
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: PPUSH
8807: CALL_OW 69
8811: PPUSH
8812: LD_VAR 0 2
8816: PPUSH
8817: CALL_OW 250
8821: PPUSH
8822: LD_VAR 0 2
8826: PPUSH
8827: CALL_OW 251
8831: PPUSH
8832: CALL_OW 73
8836: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8837: LD_VAR 0 4
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: CALL 10509 0 2
8851: IFFALSE 8910
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8853: LD_VAR 0 1
8857: PPUSH
8858: LD_INT 30
8860: PUSH
8861: LD_VAR 0 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: PPUSH
8870: CALL 11651 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8883: LD_ADDR_EXP 48
8887: PUSH
8888: LD_EXP 48
8892: PPUSH
8893: LD_VAR 0 1
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: EMPTY
8904: PPUSH
8905: CALL 42051 0 4
8909: ST_TO_ADDR
// end ; end ;
8910: LD_VAR 0 3
8914: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// result := false ;
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: LD_INT 0
8930: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8931: LD_VAR 0 1
8935: PPUSH
8936: LD_EXP 40
8940: PPUSH
8941: CALL 42999 0 2
8945: IFFALSE 9158
// for i = 1 to MREG_LabList do
8947: LD_ADDR_VAR 0 5
8951: PUSH
8952: DOUBLE
8953: LD_INT 1
8955: DEC
8956: ST_TO_ADDR
8957: LD_EXP 40
8961: PUSH
8962: FOR_TO
8963: IFFALSE 9156
// begin if MREG_LabList [ i ] [ 1 ] = side then
8965: LD_EXP 40
8969: PUSH
8970: LD_VAR 0 5
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PUSH
8980: LD_VAR 0 1
8984: EQUAL
8985: IFFALSE 9154
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8987: LD_ADDR_VAR 0 7
8991: PUSH
8992: LD_EXP 40
8996: PUSH
8997: LD_VAR 0 5
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9007: LD_ADDR_VAR 0 9
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_VAR 0 1
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 0
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 30
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PUSH
9056: EMPTY
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PPUSH
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 250
9073: PPUSH
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 251
9083: PPUSH
9084: CALL_OW 73
9088: ST_TO_ADDR
// if dep then
9089: LD_VAR 0 9
9093: IFFALSE 9152
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9095: LD_VAR 0 9
9099: PPUSH
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 3
9109: PPUSH
9110: CALL 10625 0 3
9114: IFFALSE 9152
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9116: LD_VAR 0 7
9120: PPUSH
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9130: LD_VAR 0 7
9134: PPUSH
9135: LD_VAR 0 3
9139: PPUSH
9140: CALL_OW 207
// result := true ;
9144: LD_ADDR_VAR 0 4
9148: PUSH
9149: LD_INT 1
9151: ST_TO_ADDR
// end ; end ; break ;
9152: GO 9156
// end ; end ;
9154: GO 8962
9156: POP
9157: POP
// end ;
9158: LD_VAR 0 4
9162: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9168: LD_ADDR_VAR 0 7
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: LD_VAR 0 3
9182: PPUSH
9183: LD_VAR 0 4
9187: PPUSH
9188: CALL 9350 0 3
9192: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9193: LD_ADDR_EXP 46
9197: PUSH
9198: LD_EXP 46
9202: PPUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: LD_VAR 0 2
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 4
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41960 0 4
9235: ST_TO_ADDR
// if ext_list then
9236: LD_VAR 0 5
9240: IFFALSE 9345
// for i = 1 to ext_list do
9242: LD_ADDR_VAR 0 8
9246: PUSH
9247: DOUBLE
9248: LD_INT 1
9250: DEC
9251: ST_TO_ADDR
9252: LD_VAR 0 5
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9343
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9260: LD_ADDR_EXP 46
9264: PUSH
9265: LD_EXP 46
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_VAR 0 5
9279: PUSH
9280: LD_VAR 0 8
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 7
9290: PUSH
9291: LD_VAR 0 8
9295: ARRAY
9296: PUSH
9297: LD_INT 1
9299: ARRAY
9300: PUSH
9301: LD_VAR 0 7
9305: PUSH
9306: LD_VAR 0 8
9310: ARRAY
9311: PUSH
9312: LD_INT 2
9314: ARRAY
9315: PUSH
9316: LD_VAR 0 7
9320: PUSH
9321: LD_VAR 0 8
9325: ARRAY
9326: PUSH
9327: LD_INT 3
9329: ARRAY
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL 41960 0 4
9340: ST_TO_ADDR
9341: GO 9257
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 6
9349: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9350: LD_INT 0
9352: PPUSH
9353: PPUSH
// list := [ ] ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: EMPTY
9360: ST_TO_ADDR
// case d of 0 :
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 0
9368: DOUBLE
9369: EQUAL
9370: IFTRUE 9374
9372: GO 9507
9374: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 4
9387: MINUS
9388: PUSH
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 4
9396: MINUS
9397: PUSH
9398: LD_INT 2
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 3
9413: MINUS
9414: PUSH
9415: LD_VAR 0 2
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 4
9435: PLUS
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 4
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 3
9457: PLUS
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: PLUS
9467: PUSH
9468: LD_INT 5
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: ST_TO_ADDR
// end ; 1 :
9505: GO 10205
9507: LD_INT 1
9509: DOUBLE
9510: EQUAL
9511: IFTRUE 9515
9513: GO 9648
9515: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9516: LD_ADDR_VAR 0 5
9520: PUSH
9521: LD_VAR 0 1
9525: PUSH
9526: LD_VAR 0 2
9530: PUSH
9531: LD_INT 4
9533: MINUS
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: PUSH
9543: LD_VAR 0 1
9547: PUSH
9548: LD_INT 3
9550: MINUS
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: LD_INT 3
9559: MINUS
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 4
9576: MINUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 1
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 4
9629: PLUS
9630: PUSH
9631: LD_INT 5
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: ST_TO_ADDR
// end ; 2 :
9646: GO 10205
9648: LD_INT 2
9650: DOUBLE
9651: EQUAL
9652: IFTRUE 9656
9654: GO 9785
9656: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: MINUS
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: PUSH
9684: LD_VAR 0 1
9688: PUSH
9689: LD_INT 4
9691: PLUS
9692: PUSH
9693: LD_VAR 0 2
9697: PUSH
9698: LD_INT 4
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 4
9718: PLUS
9719: PUSH
9720: LD_INT 0
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_VAR 0 1
9732: PUSH
9733: LD_INT 3
9735: MINUS
9736: PUSH
9737: LD_VAR 0 2
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 4
9757: MINUS
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: LD_INT 4
9766: MINUS
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: ST_TO_ADDR
// end ; 3 :
9783: GO 10205
9785: LD_INT 3
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9926
9793: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9794: LD_ADDR_VAR 0 5
9798: PUSH
9799: LD_VAR 0 1
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: LD_INT 4
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: PUSH
9821: LD_VAR 0 1
9825: PUSH
9826: LD_INT 4
9828: PLUS
9829: PUSH
9830: LD_VAR 0 2
9834: PUSH
9835: LD_INT 4
9837: PLUS
9838: PUSH
9839: LD_INT 5
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_INT 4
9854: MINUS
9855: PUSH
9856: LD_VAR 0 2
9860: PUSH
9861: LD_INT 1
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: LD_INT 4
9881: MINUS
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: MINUS
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 3
9907: MINUS
9908: PUSH
9909: LD_INT 2
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
// end ; 4 :
9924: GO 10205
9926: LD_INT 4
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10067
9934: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9935: LD_ADDR_VAR 0 5
9939: PUSH
9940: LD_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 4
9952: PLUS
9953: PUSH
9954: LD_INT 0
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: PUSH
9962: LD_VAR 0 1
9966: PUSH
9967: LD_INT 3
9969: PLUS
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 3
9978: PLUS
9979: PUSH
9980: LD_INT 5
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_INT 3
9995: PLUS
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: LD_INT 4
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 3
10022: MINUS
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_VAR 0 1
10036: PUSH
10037: LD_INT 4
10039: MINUS
10040: PUSH
10041: LD_VAR 0 2
10045: PUSH
10046: LD_INT 4
10048: MINUS
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: ST_TO_ADDR
// end ; 5 :
10065: GO 10205
10067: LD_INT 5
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10204
10075: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10076: LD_ADDR_VAR 0 5
10080: PUSH
10081: LD_VAR 0 1
10085: PUSH
10086: LD_INT 4
10088: MINUS
10089: PUSH
10090: LD_VAR 0 2
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_VAR 0 1
10107: PUSH
10108: LD_VAR 0 2
10112: PUSH
10113: LD_INT 4
10115: MINUS
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_VAR 0 1
10129: PUSH
10130: LD_INT 4
10132: PLUS
10133: PUSH
10134: LD_VAR 0 2
10138: PUSH
10139: LD_INT 4
10141: PLUS
10142: PUSH
10143: LD_INT 5
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: PUSH
10151: LD_VAR 0 1
10155: PUSH
10156: LD_INT 3
10158: PLUS
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_INT 4
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 1
10177: PUSH
10178: LD_VAR 0 2
10182: PUSH
10183: LD_INT 3
10185: PLUS
10186: PUSH
10187: LD_INT 0
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: ST_TO_ADDR
// end ; end ;
10202: GO 10205
10204: POP
// result := list ;
10205: LD_ADDR_VAR 0 4
10209: PUSH
10210: LD_VAR 0 5
10214: ST_TO_ADDR
// end ;
10215: LD_VAR 0 4
10219: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10227: LD_ADDR_VAR 0 10
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: LD_INT 2
10239: PPUSH
10240: EMPTY
10241: PPUSH
10242: CALL 11734 0 3
10246: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10247: LD_ADDR_VAR 0 9
10251: PUSH
10252: LD_INT 22
10254: PUSH
10255: LD_VAR 0 1
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_INT 30
10269: PUSH
10270: LD_INT 0
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 30
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PPUSH
10304: LD_VAR 0 3
10308: PPUSH
10309: LD_VAR 0 4
10313: PPUSH
10314: CALL_OW 73
10318: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10319: LD_ADDR_VAR 0 8
10323: PUSH
10324: LD_VAR 0 9
10328: PPUSH
10329: LD_VAR 0 2
10333: PPUSH
10334: CALL 10509 0 2
10338: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10339: LD_VAR 0 10
10343: PUSH
10344: LD_VAR 0 8
10348: AND
10349: PUSH
10350: LD_VAR 0 9
10354: PPUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_VAR 0 4
10364: PPUSH
10365: CALL_OW 297
10369: PUSH
10370: LD_INT 26
10372: LESSEQUAL
10373: AND
10374: PUSH
10375: LD_VAR 0 3
10379: PPUSH
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 428
10389: PUSH
10390: LD_INT 0
10392: EQUAL
10393: AND
10394: IFFALSE 10504
// for i = 1 to plist do
10396: LD_ADDR_VAR 0 7
10400: PUSH
10401: DOUBLE
10402: LD_INT 1
10404: DEC
10405: ST_TO_ADDR
10406: LD_VAR 0 10
10410: PUSH
10411: FOR_TO
10412: IFFALSE 10502
// if IsInUnit ( plist [ i ] ) then
10414: LD_VAR 0 10
10418: PUSH
10419: LD_VAR 0 7
10423: ARRAY
10424: PPUSH
10425: CALL_OW 310
10429: IFFALSE 10448
// ComExitBuilding ( plist [ i ] ) else
10431: LD_VAR 0 10
10435: PUSH
10436: LD_VAR 0 7
10440: ARRAY
10441: PPUSH
10442: CALL_OW 122
10446: GO 10500
// if NotTask ( plist [ i ] ) then
10448: LD_VAR 0 10
10452: PUSH
10453: LD_VAR 0 7
10457: ARRAY
10458: PPUSH
10459: CALL 32236 0 1
10463: IFFALSE 10500
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10465: LD_VAR 0 10
10469: PUSH
10470: LD_VAR 0 7
10474: ARRAY
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL_OW 145
// end ;
10500: GO 10411
10502: POP
10503: POP
// end ;
10504: LD_VAR 0 6
10508: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10509: LD_INT 0
10511: PPUSH
10512: PPUSH
10513: PPUSH
// pom := GetBase ( bdepot ) ;
10514: LD_ADDR_VAR 0 4
10518: PUSH
10519: LD_VAR 0 1
10523: PPUSH
10524: CALL_OW 274
10528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10529: LD_ADDR_VAR 0 5
10533: PUSH
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 248
10548: PPUSH
10549: CALL_OW 450
10553: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: CALL_OW 275
10566: PUSH
10567: LD_VAR 0 5
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: GREATEREQUAL
10576: PUSH
10577: LD_VAR 0 4
10581: PPUSH
10582: LD_INT 3
10584: PPUSH
10585: CALL_OW 275
10589: PUSH
10590: LD_VAR 0 5
10594: PUSH
10595: LD_INT 3
10597: ARRAY
10598: GREATEREQUAL
10599: AND
10600: IFFALSE 10612
// result := true else
10602: LD_ADDR_VAR 0 3
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
10610: GO 10620
// result := false ;
10612: LD_ADDR_VAR 0 3
10616: PUSH
10617: LD_INT 0
10619: ST_TO_ADDR
// end ;
10620: LD_VAR 0 3
10624: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
10629: PPUSH
10630: PPUSH
10631: PPUSH
// pom := GetBase ( bdepot ) ;
10632: LD_ADDR_VAR 0 5
10636: PUSH
10637: LD_VAR 0 1
10641: PPUSH
10642: CALL_OW 274
10646: ST_TO_ADDR
// cost := [ ] ;
10647: LD_ADDR_VAR 0 8
10651: PUSH
10652: EMPTY
10653: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 248
10673: PPUSH
10674: CALL_OW 450
10678: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10679: LD_ADDR_VAR 0 7
10683: PUSH
10684: LD_VAR 0 3
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 248
10698: PPUSH
10699: CALL_OW 450
10703: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10704: LD_ADDR_VAR 0 8
10708: PUSH
10709: LD_VAR 0 8
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: LD_VAR 0 6
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PUSH
10726: LD_VAR 0 7
10730: PUSH
10731: LD_INT 1
10733: ARRAY
10734: PLUS
10735: PPUSH
10736: CALL_OW 1
10740: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: LD_VAR 0 8
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_VAR 0 6
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PUSH
10763: LD_VAR 0 7
10767: PUSH
10768: LD_INT 2
10770: ARRAY
10771: PLUS
10772: PPUSH
10773: CALL_OW 1
10777: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10778: LD_ADDR_VAR 0 8
10782: PUSH
10783: LD_VAR 0 8
10787: PPUSH
10788: LD_INT 3
10790: PPUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_INT 3
10798: ARRAY
10799: PUSH
10800: LD_VAR 0 7
10804: PUSH
10805: LD_INT 3
10807: ARRAY
10808: PLUS
10809: PPUSH
10810: CALL_OW 1
10814: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10815: LD_VAR 0 5
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 275
10827: PUSH
10828: LD_VAR 0 8
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: GREATEREQUAL
10837: PUSH
10838: LD_VAR 0 5
10842: PPUSH
10843: LD_INT 3
10845: PPUSH
10846: CALL_OW 275
10850: PUSH
10851: LD_VAR 0 8
10855: PUSH
10856: LD_INT 3
10858: ARRAY
10859: GREATEREQUAL
10860: AND
10861: IFFALSE 10873
// result := true else
10863: LD_ADDR_VAR 0 4
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
10871: GO 10881
// result := false ;
10873: LD_ADDR_VAR 0 4
10877: PUSH
10878: LD_INT 0
10880: ST_TO_ADDR
// end ;
10881: LD_VAR 0 4
10885: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10886: LD_INT 0
10888: PPUSH
10889: PPUSH
10890: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 2
10903: PPUSH
10904: EMPTY
10905: PPUSH
10906: CALL 11734 0 3
10910: ST_TO_ADDR
// if unit and plist then
10911: LD_VAR 0 2
10915: PUSH
10916: LD_VAR 0 5
10920: AND
10921: IFFALSE 10982
// for i = 1 to plist do
10923: LD_ADDR_VAR 0 4
10927: PUSH
10928: DOUBLE
10929: LD_INT 1
10931: DEC
10932: ST_TO_ADDR
10933: LD_VAR 0 5
10937: PUSH
10938: FOR_TO
10939: IFFALSE 10980
// if NotTask ( plist [ i ] ) then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_VAR 0 4
10950: ARRAY
10951: PPUSH
10952: CALL 32236 0 1
10956: IFFALSE 10978
// ComDismantle ( plist [ i ] , unit ) ;
10958: LD_VAR 0 5
10962: PUSH
10963: LD_VAR 0 4
10967: ARRAY
10968: PPUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 167
10978: GO 10938
10980: POP
10981: POP
// result := true ;
10982: LD_ADDR_VAR 0 3
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// end ;
10990: LD_VAR 0 3
10994: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10995: LD_INT 0
10997: PPUSH
10998: PPUSH
10999: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11000: LD_ADDR_VAR 0 5
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: LD_INT 2
11012: PPUSH
11013: EMPTY
11014: PPUSH
11015: CALL 11734 0 3
11019: ST_TO_ADDR
// if unit and plist then
11020: LD_VAR 0 2
11024: PUSH
11025: LD_VAR 0 5
11029: AND
11030: IFFALSE 11091
// for i = 1 to plist do
11032: LD_ADDR_VAR 0 4
11036: PUSH
11037: DOUBLE
11038: LD_INT 1
11040: DEC
11041: ST_TO_ADDR
11042: LD_VAR 0 5
11046: PUSH
11047: FOR_TO
11048: IFFALSE 11089
// if NotTask ( plist [ i ] ) then
11050: LD_VAR 0 5
11054: PUSH
11055: LD_VAR 0 4
11059: ARRAY
11060: PPUSH
11061: CALL 32236 0 1
11065: IFFALSE 11087
// ComComplete ( plist [ i ] , unit ) ;
11067: LD_VAR 0 5
11071: PUSH
11072: LD_VAR 0 4
11076: ARRAY
11077: PPUSH
11078: LD_VAR 0 2
11082: PPUSH
11083: CALL 71350 0 2
11087: GO 11047
11089: POP
11090: POP
// result := true ;
11091: LD_ADDR_VAR 0 3
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// end ;
11099: LD_VAR 0 3
11103: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11104: LD_INT 0
11106: PPUSH
11107: PPUSH
11108: PPUSH
11109: PPUSH
11110: PPUSH
11111: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11112: LD_ADDR_VAR 0 5
11116: PUSH
11117: LD_INT 22
11119: PUSH
11120: LD_VAR 0 1
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 21
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 3
11141: PUSH
11142: LD_INT 57
11144: PUSH
11145: EMPTY
11146: LIST
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 24
11157: PUSH
11158: LD_INT 1000
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: PPUSH
11175: CALL_OW 69
11179: ST_TO_ADDR
// r := [ ] ;
11180: LD_ADDR_VAR 0 6
11184: PUSH
11185: EMPTY
11186: ST_TO_ADDR
// if not tmp then
11187: LD_VAR 0 5
11191: NOT
11192: IFFALSE 11198
// exit else
11194: GO 11386
11196: GO 11366
// begin r := [ tmp [ 1 ] ] ;
11198: LD_ADDR_VAR 0 6
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: LD_INT 1
11210: ARRAY
11211: PUSH
11212: EMPTY
11213: LIST
11214: ST_TO_ADDR
// for i = 2 to tmp do
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: DOUBLE
11221: LD_INT 2
11223: DEC
11224: ST_TO_ADDR
11225: LD_VAR 0 5
11229: PUSH
11230: FOR_TO
11231: IFFALSE 11364
// begin m := false ;
11233: LD_ADDR_VAR 0 7
11237: PUSH
11238: LD_INT 0
11240: ST_TO_ADDR
// for j = 1 to r do
11241: LD_ADDR_VAR 0 4
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_VAR 0 6
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11331
// if GetLives ( tmp [ i ] ) < r [ j ] then
11259: LD_VAR 0 5
11263: PUSH
11264: LD_VAR 0 3
11268: ARRAY
11269: PPUSH
11270: CALL_OW 256
11274: PUSH
11275: LD_VAR 0 6
11279: PUSH
11280: LD_VAR 0 4
11284: ARRAY
11285: LESS
11286: IFFALSE 11329
// begin r := Insert ( r , j , tmp [ i ] ) ;
11288: LD_ADDR_VAR 0 6
11292: PUSH
11293: LD_VAR 0 6
11297: PPUSH
11298: LD_VAR 0 4
11302: PPUSH
11303: LD_VAR 0 5
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: CALL_OW 2
11318: ST_TO_ADDR
// m := true ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// break ;
11327: GO 11331
// end ;
11329: GO 11256
11331: POP
11332: POP
// if not m then
11333: LD_VAR 0 7
11337: NOT
11338: IFFALSE 11362
// r := r ^ tmp [ i ] ;
11340: LD_ADDR_VAR 0 6
11344: PUSH
11345: LD_VAR 0 6
11349: PUSH
11350: LD_VAR 0 5
11354: PUSH
11355: LD_VAR 0 3
11359: ARRAY
11360: ADD
11361: ST_TO_ADDR
// end ;
11362: GO 11230
11364: POP
11365: POP
// end ; if r then
11366: LD_VAR 0 6
11370: IFFALSE 11384
// result := r else
11372: LD_ADDR_VAR 0 2
11376: PUSH
11377: LD_VAR 0 6
11381: ST_TO_ADDR
11382: GO 11386
// exit ;
11384: GO 11386
// end ;
11386: LD_VAR 0 2
11390: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11391: LD_INT 0
11393: PPUSH
11394: PPUSH
11395: PPUSH
11396: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11397: LD_ADDR_VAR 0 5
11401: PUSH
11402: LD_INT 22
11404: PUSH
11405: LD_VAR 0 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: LD_INT 25
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 25
11429: PUSH
11430: LD_INT 16
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 34
11439: PUSH
11440: LD_INT 13
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 34
11449: PUSH
11450: LD_INT 52
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 24
11466: PUSH
11467: LD_INT 650
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: ST_TO_ADDR
// p := 1 ;
11484: LD_ADDR_VAR 0 4
11488: PUSH
11489: LD_INT 1
11491: ST_TO_ADDR
// for i = 1 to repairs do
11492: LD_ADDR_VAR 0 3
11496: PUSH
11497: DOUBLE
11498: LD_INT 1
11500: DEC
11501: ST_TO_ADDR
11502: LD_VAR 0 5
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// begin if IsInUnit ( repairs [ i ] ) then
11510: LD_VAR 0 5
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: PPUSH
11521: CALL_OW 310
11525: IFFALSE 11544
// ComExitBuilding ( repairs [ i ] ) else
11527: LD_VAR 0 5
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: PPUSH
11538: CALL_OW 122
11542: GO 11642
// if not HasTask ( repairs [ i ] ) then
11544: LD_VAR 0 5
11548: PUSH
11549: LD_VAR 0 3
11553: ARRAY
11554: PPUSH
11555: CALL_OW 314
11559: NOT
11560: IFFALSE 11642
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11562: LD_VAR 0 5
11566: PUSH
11567: LD_VAR 0 3
11571: ARRAY
11572: PPUSH
11573: LD_EXP 47
11577: PUSH
11578: LD_VAR 0 1
11582: ARRAY
11583: PUSH
11584: LD_VAR 0 4
11588: ARRAY
11589: PPUSH
11590: CALL_OW 130
// if i mod 3 = 0 then
11594: LD_VAR 0 3
11598: PUSH
11599: LD_INT 3
11601: MOD
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11622
// p := p + 1 ;
11608: LD_ADDR_VAR 0 4
11612: PUSH
11613: LD_VAR 0 4
11617: PUSH
11618: LD_INT 1
11620: PLUS
11621: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11622: LD_EXP 47
11626: PUSH
11627: LD_VAR 0 1
11631: ARRAY
11632: PUSH
11633: LD_VAR 0 4
11637: LESS
11638: IFFALSE 11642
// break ;
11640: GO 11644
// end ; end ;
11642: GO 11507
11644: POP
11645: POP
// end ; end_of_file
11646: LD_VAR 0 2
11650: RET
// export function MCF_Get ( side , filter ) ; begin
11651: LD_INT 0
11653: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_INT 22
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PPUSH
11680: CALL_OW 69
11684: ST_TO_ADDR
// end ;
11685: LD_VAR 0 3
11689: RET
// export function MCF_Lab ( side ) ; begin
11690: LD_INT 0
11692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11693: LD_ADDR_VAR 0 2
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: LD_INT 30
11712: PUSH
11713: LD_INT 8
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 69
11728: ST_TO_ADDR
// end ;
11729: LD_VAR 0 2
11733: RET
// export function MCF_Class ( side , class , filter ) ; begin
11734: LD_INT 0
11736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_INT 22
11744: PUSH
11745: LD_VAR 0 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 25
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 4
11785: RET
// export function MCF_All ( side , filter ) ; begin
11786: LD_INT 0
11788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 25
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 25
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 4
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: ST_TO_ADDR
// end ;
11871: LD_VAR 0 3
11875: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11876: LD_INT 0
11878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11879: LD_ADDR_VAR 0 4
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 92
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_INT 1
11906: ARRAY
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: LD_INT 2
11915: ARRAY
11916: PUSH
11917: LD_VAR 0 2
11921: PUSH
11922: LD_INT 3
11924: ARRAY
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: PUSH
11932: LD_VAR 0 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// end ;
11947: LD_VAR 0 4
11951: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11952: LD_INT 0
11954: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11955: LD_ADDR_VAR 0 3
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_VAR 0 1
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 21
11974: PUSH
11975: LD_INT 2
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 3
12001: RET
// export function MCF_Cargo ( side ) ; begin
12002: LD_INT 0
12004: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_INT 2
12017: PUSH
12018: LD_INT 34
12020: PUSH
12021: LD_INT 12
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 34
12030: PUSH
12031: LD_INT 32
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 34
12040: PUSH
12041: LD_INT 51
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PPUSH
12054: CALL 11952 0 2
12058: ST_TO_ADDR
// end ;
12059: LD_VAR 0 2
12063: RET
// export function MCF_Ape ( side ) ; begin
12064: LD_INT 0
12066: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_VAR 0 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 2
12086: PUSH
12087: LD_INT 25
12089: PUSH
12090: LD_INT 12
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 15
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 25
12109: PUSH
12110: LD_INT 16
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 17
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// end ;
12143: LD_VAR 0 2
12147: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
12153: PPUSH
// result := [ ] ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: EMPTY
12160: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL 12064 0 1
12175: ST_TO_ADDR
// case type of 0 , normal :
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12195
12187: LD_STRING normal
12189: DOUBLE
12190: EQUAL
12191: IFTRUE 12195
12193: GO 12206
12195: POP
// cl := class_apeman ; 1 , soldier :
12196: LD_ADDR_VAR 0 5
12200: PUSH
12201: LD_INT 12
12203: ST_TO_ADDR
12204: GO 12282
12206: LD_INT 1
12208: DOUBLE
12209: EQUAL
12210: IFTRUE 12220
12212: LD_STRING soldier
12214: DOUBLE
12215: EQUAL
12216: IFTRUE 12220
12218: GO 12231
12220: POP
// cl := class_apeman_soldier ; 2 , engineer :
12221: LD_ADDR_VAR 0 5
12225: PUSH
12226: LD_INT 15
12228: ST_TO_ADDR
12229: GO 12282
12231: LD_INT 2
12233: DOUBLE
12234: EQUAL
12235: IFTRUE 12245
12237: LD_STRING engineer
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12256
12245: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12246: LD_ADDR_VAR 0 5
12250: PUSH
12251: LD_INT 16
12253: ST_TO_ADDR
12254: GO 12282
12256: LD_INT 3
12258: DOUBLE
12259: EQUAL
12260: IFTRUE 12270
12262: LD_STRING kamikaze
12264: DOUBLE
12265: EQUAL
12266: IFTRUE 12270
12268: GO 12281
12270: POP
// cl := class_apeman_kamikaze ; end ;
12271: LD_ADDR_VAR 0 5
12275: PUSH
12276: LD_INT 17
12278: ST_TO_ADDR
12279: GO 12282
12281: POP
// for i = 1 to tmp do
12282: LD_ADDR_VAR 0 6
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 4
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12347
// if GetClass ( tmp [ i ] ) = cl then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_VAR 0 6
12309: ARRAY
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_VAR 0 5
12320: EQUAL
12321: IFFALSE 12345
// result := result ^ tmp [ i ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 3
12332: PUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_VAR 0 6
12342: ARRAY
12343: ADD
12344: ST_TO_ADDR
12345: GO 12297
12347: POP
12348: POP
// end ;
12349: LD_VAR 0 3
12353: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12354: LD_INT 0
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12360: LD_ADDR_VAR 0 5
12364: PUSH
12365: LD_INT 22
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: ST_TO_ADDR
// r := [ ] ;
12391: LD_ADDR_VAR 0 6
12395: PUSH
12396: EMPTY
12397: ST_TO_ADDR
// if tmp then
12398: LD_VAR 0 5
12402: IFFALSE 12471
// for i = 1 to tmp do
12404: LD_ADDR_VAR 0 7
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_VAR 0 5
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12469
// if GetTag ( tmp [ i ] ) = tag then
12422: LD_VAR 0 5
12426: PUSH
12427: LD_VAR 0 7
12431: ARRAY
12432: PPUSH
12433: CALL_OW 110
12437: PUSH
12438: LD_VAR 0 2
12442: EQUAL
12443: IFFALSE 12467
// r := r ^ tmp [ i ] ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 6
12454: PUSH
12455: LD_VAR 0 5
12459: PUSH
12460: LD_VAR 0 7
12464: ARRAY
12465: ADD
12466: ST_TO_ADDR
12467: GO 12419
12469: POP
12470: POP
// result := r ;
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: LD_VAR 0 6
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 4
12485: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
// tmp := plist ;
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 2
12500: ST_TO_ADDR
// if tmp then
12501: LD_VAR 0 5
12505: IFFALSE 12582
// begin for i = 1 to tmp do
12507: LD_ADDR_VAR 0 6
12511: PUSH
12512: DOUBLE
12513: LD_INT 1
12515: DEC
12516: ST_TO_ADDR
12517: LD_VAR 0 5
12521: PUSH
12522: FOR_TO
12523: IFFALSE 12570
// if GetTag ( tmp [ i ] ) <> tag then
12525: LD_VAR 0 5
12529: PUSH
12530: LD_VAR 0 6
12534: ARRAY
12535: PPUSH
12536: CALL_OW 110
12540: PUSH
12541: LD_VAR 0 3
12545: NONEQUAL
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , tag ) ;
12548: LD_VAR 0 5
12552: PUSH
12553: LD_VAR 0 6
12557: ARRAY
12558: PPUSH
12559: LD_VAR 0 3
12563: PPUSH
12564: CALL_OW 109
12568: GO 12522
12570: POP
12571: POP
// result := true ;
12572: LD_ADDR_VAR 0 4
12576: PUSH
12577: LD_INT 1
12579: ST_TO_ADDR
// end else
12580: GO 12590
// result := false ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 0
12589: ST_TO_ADDR
// end ;
12590: LD_VAR 0 4
12594: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12595: LD_INT 0
12597: PPUSH
12598: PPUSH
12599: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_VAR 0 2
12614: PPUSH
12615: EMPTY
12616: PPUSH
12617: CALL 12354 0 3
12621: ST_TO_ADDR
// if tmp then
12622: LD_VAR 0 4
12626: IFFALSE 12678
// begin for i = 1 to tmp do
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: DOUBLE
12634: LD_INT 1
12636: DEC
12637: ST_TO_ADDR
12638: LD_VAR 0 4
12642: PUSH
12643: FOR_TO
12644: IFFALSE 12666
// SetTag ( tmp [ i ] , 0 ) ;
12646: LD_VAR 0 4
12650: PUSH
12651: LD_VAR 0 5
12655: ARRAY
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 109
12664: GO 12643
12666: POP
12667: POP
// result := true ;
12668: LD_ADDR_VAR 0 3
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end else
12676: GO 12686
// result := false ;
12678: LD_ADDR_VAR 0 3
12682: PUSH
12683: LD_INT 0
12685: ST_TO_ADDR
// end ;
12686: LD_VAR 0 3
12690: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12691: LD_INT 0
12693: PPUSH
12694: PPUSH
12695: PPUSH
12696: PPUSH
12697: PPUSH
// sort_list := [ ] ;
12698: LD_ADDR_VAR 0 5
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// for i = 1 to list do
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: DOUBLE
12711: LD_INT 1
12713: DEC
12714: ST_TO_ADDR
12715: LD_VAR 0 1
12719: PUSH
12720: FOR_TO
12721: IFFALSE 12883
// begin if i = 1 then
12723: LD_VAR 0 3
12727: PUSH
12728: LD_INT 1
12730: EQUAL
12731: IFFALSE 12757
// sort_list := sort_list ^ list [ i ] else
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PUSH
12743: LD_VAR 0 1
12747: PUSH
12748: LD_VAR 0 3
12752: ARRAY
12753: ADD
12754: ST_TO_ADDR
12755: GO 12881
// begin for j = 1 to sort_list do
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: DOUBLE
12763: LD_INT 1
12765: DEC
12766: ST_TO_ADDR
12767: LD_VAR 0 5
12771: PUSH
12772: FOR_TO
12773: IFFALSE 12850
// begin add := false ;
12775: LD_ADDR_VAR 0 6
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12783: LD_VAR 0 1
12787: PUSH
12788: LD_VAR 0 3
12792: ARRAY
12793: PUSH
12794: LD_VAR 0 5
12798: PUSH
12799: LD_VAR 0 4
12803: ARRAY
12804: LESS
12805: IFFALSE 12848
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12807: LD_ADDR_VAR 0 5
12811: PUSH
12812: LD_VAR 0 5
12816: PPUSH
12817: LD_VAR 0 4
12821: PPUSH
12822: LD_VAR 0 1
12826: PUSH
12827: LD_VAR 0 3
12831: ARRAY
12832: PPUSH
12833: CALL_OW 2
12837: ST_TO_ADDR
// add := true ;
12838: LD_ADDR_VAR 0 6
12842: PUSH
12843: LD_INT 1
12845: ST_TO_ADDR
// break ;
12846: GO 12850
// end ; end ;
12848: GO 12772
12850: POP
12851: POP
// if not add then
12852: LD_VAR 0 6
12856: NOT
12857: IFFALSE 12881
// sort_list := sort_list ^ list [ i ] ;
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_VAR 0 5
12868: PUSH
12869: LD_VAR 0 1
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: ADD
12880: ST_TO_ADDR
// end ; end ;
12881: GO 12720
12883: POP
12884: POP
// result := sort_list ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_VAR 0 5
12894: ST_TO_ADDR
// end ;
12895: LD_VAR 0 2
12899: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// sort_list := [ ] ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// for i = 1 to list do
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: DOUBLE
12920: LD_INT 1
12922: DEC
12923: ST_TO_ADDR
12924: LD_VAR 0 1
12928: PUSH
12929: FOR_TO
12930: IFFALSE 13092
// begin if i = 1 then
12932: LD_VAR 0 3
12936: PUSH
12937: LD_INT 1
12939: EQUAL
12940: IFFALSE 12966
// sort_list := sort_list ^ list [ i ] else
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: LD_VAR 0 5
12951: PUSH
12952: LD_VAR 0 1
12956: PUSH
12957: LD_VAR 0 3
12961: ARRAY
12962: ADD
12963: ST_TO_ADDR
12964: GO 13090
// begin for j = 1 to sort_list do
12966: LD_ADDR_VAR 0 4
12970: PUSH
12971: DOUBLE
12972: LD_INT 1
12974: DEC
12975: ST_TO_ADDR
12976: LD_VAR 0 5
12980: PUSH
12981: FOR_TO
12982: IFFALSE 13059
// begin add := false ;
12984: LD_ADDR_VAR 0 6
12988: PUSH
12989: LD_INT 0
12991: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_VAR 0 3
13001: ARRAY
13002: PUSH
13003: LD_VAR 0 5
13007: PUSH
13008: LD_VAR 0 4
13012: ARRAY
13013: GREATER
13014: IFFALSE 13057
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13016: LD_ADDR_VAR 0 5
13020: PUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: LD_VAR 0 4
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_VAR 0 3
13040: ARRAY
13041: PPUSH
13042: CALL_OW 2
13046: ST_TO_ADDR
// add := true ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// break ;
13055: GO 13059
// end ; end ;
13057: GO 12981
13059: POP
13060: POP
// if not add then
13061: LD_VAR 0 6
13065: NOT
13066: IFFALSE 13090
// sort_list := sort_list ^ list [ i ] ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_VAR 0 5
13077: PUSH
13078: LD_VAR 0 1
13082: PUSH
13083: LD_VAR 0 3
13087: ARRAY
13088: ADD
13089: ST_TO_ADDR
// end ; end ;
13090: GO 12929
13092: POP
13093: POP
// result := sort_list ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 5
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 2
13108: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: LESS
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
13427: PPUSH
// tmp := [ ] ;
13428: LD_ADDR_VAR 0 8
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// r := [ ] ;
13435: LD_ADDR_VAR 0 7
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// add := false ;
13442: LD_ADDR_VAR 0 9
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// if plist then
13450: LD_VAR 0 2
13454: IFFALSE 13530
// begin for i = 1 to plist do
13456: LD_ADDR_VAR 0 5
13460: PUSH
13461: DOUBLE
13462: LD_INT 1
13464: DEC
13465: ST_TO_ADDR
13466: LD_VAR 0 2
13470: PUSH
13471: FOR_TO
13472: IFFALSE 13526
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13474: LD_ADDR_VAR 0 8
13478: PUSH
13479: LD_VAR 0 8
13483: PUSH
13484: LD_VAR 0 2
13488: PUSH
13489: LD_VAR 0 5
13493: ARRAY
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ARRAY
13505: PPUSH
13506: LD_VAR 0 3
13510: PPUSH
13511: CALL_OW 259
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: ADD
13523: ST_TO_ADDR
// end ;
13524: GO 13471
13526: POP
13527: POP
// end else
13528: GO 13538
// result := false ;
13530: LD_ADDR_VAR 0 4
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// if tmp then
13538: LD_VAR 0 8
13542: IFFALSE 13716
// begin r := r ^ [ tmp [ 1 ] ] ;
13544: LD_ADDR_VAR 0 7
13548: PUSH
13549: LD_VAR 0 7
13553: PUSH
13554: LD_VAR 0 8
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PUSH
13563: EMPTY
13564: LIST
13565: ADD
13566: ST_TO_ADDR
// for i = 2 to tmp do
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: DOUBLE
13573: LD_INT 2
13575: DEC
13576: ST_TO_ADDR
13577: LD_VAR 0 8
13581: PUSH
13582: FOR_TO
13583: IFFALSE 13714
// begin for j = 1 to r do
13585: LD_ADDR_VAR 0 6
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 7
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13678
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13603: LD_VAR 0 8
13607: PUSH
13608: LD_VAR 0 5
13612: ARRAY
13613: PUSH
13614: LD_INT 2
13616: ARRAY
13617: PUSH
13618: LD_VAR 0 7
13622: PUSH
13623: LD_VAR 0 6
13627: ARRAY
13628: PUSH
13629: LD_INT 2
13631: ARRAY
13632: GREATER
13633: IFFALSE 13676
// begin r := Insert ( r , j , tmp [ i ] ) ;
13635: LD_ADDR_VAR 0 7
13639: PUSH
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 8
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 2
13665: ST_TO_ADDR
// add := true ;
13666: LD_ADDR_VAR 0 9
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// break ;
13674: GO 13678
// end ; end ;
13676: GO 13600
13678: POP
13679: POP
// if not add then
13680: LD_VAR 0 9
13684: NOT
13685: IFFALSE 13712
// r := r ^ [ tmp [ i ] ] ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_VAR 0 7
13696: PUSH
13697: LD_VAR 0 8
13701: PUSH
13702: LD_VAR 0 5
13706: ARRAY
13707: PUSH
13708: EMPTY
13709: LIST
13710: ADD
13711: ST_TO_ADDR
// end ;
13712: GO 13582
13714: POP
13715: POP
// end ; result := r ;
13716: LD_ADDR_VAR 0 4
13720: PUSH
13721: LD_VAR 0 7
13725: ST_TO_ADDR
// end ;
13726: LD_VAR 0 4
13730: RET
// export function MCF_Clear ( side ) ; var i ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
// for i = 1 to 100 do
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: DOUBLE
13741: LD_INT 1
13743: DEC
13744: ST_TO_ADDR
13745: LD_INT 100
13747: PUSH
13748: FOR_TO
13749: IFFALSE 13785
// if MCF_Tag ( side , i , [ ] ) then
13751: LD_VAR 0 1
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: EMPTY
13762: PPUSH
13763: CALL 12354 0 3
13767: IFFALSE 13783
// MCF_ClearTag ( side , i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL 12595 0 2
13783: GO 13748
13785: POP
13786: POP
// result := true ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 1
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
// for i = 1 to plist do
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: DOUBLE
13811: LD_INT 1
13813: DEC
13814: ST_TO_ADDR
13815: LD_VAR 0 1
13819: PUSH
13820: FOR_TO
13821: IFFALSE 13870
// if MCF_HasClass ( plist [ i ] ) = n then
13823: LD_VAR 0 1
13827: PUSH
13828: LD_VAR 0 4
13832: ARRAY
13833: PPUSH
13834: CALL 14357 0 1
13838: PUSH
13839: LD_VAR 0 2
13843: EQUAL
13844: IFFALSE 13868
// tmp := tmp ^ plist [ i ] ;
13846: LD_ADDR_VAR 0 5
13850: PUSH
13851: LD_VAR 0 5
13855: PUSH
13856: LD_VAR 0 1
13860: PUSH
13861: LD_VAR 0 4
13865: ARRAY
13866: ADD
13867: ST_TO_ADDR
13868: GO 13820
13870: POP
13871: POP
// result := tmp ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_VAR 0 5
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 3
13886: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
13891: PPUSH
// if mreg = ToArm then
13892: LD_VAR 0 2
13896: PUSH
13897: LD_STRING ToArm
13899: EQUAL
13900: IFFALSE 14005
// begin tmp := MREG_ToArm [ side ] ;
13902: LD_ADDR_VAR 0 6
13906: PUSH
13907: LD_EXP 56
13911: PUSH
13912: LD_VAR 0 1
13916: ARRAY
13917: ST_TO_ADDR
// if tmp = 0 then
13918: LD_VAR 0 6
13922: PUSH
13923: LD_INT 0
13925: EQUAL
13926: IFFALSE 13932
// exit else
13928: GO 14352
13930: GO 14005
// begin for i = MREG_ToArm [ side ] downto n do
13932: LD_ADDR_VAR 0 5
13936: PUSH
13937: DOUBLE
13938: LD_EXP 56
13942: PUSH
13943: LD_VAR 0 1
13947: ARRAY
13948: INC
13949: ST_TO_ADDR
13950: LD_VAR 0 3
13954: PUSH
13955: FOR_DOWNTO
13956: IFFALSE 13978
// tmp := Delete ( tmp , 1 ) ;
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: LD_INT 1
13970: PPUSH
13971: CALL_OW 3
13975: ST_TO_ADDR
13976: GO 13955
13978: POP
13979: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13980: LD_ADDR_EXP 56
13984: PUSH
13985: LD_EXP 56
13989: PPUSH
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 6
13999: PPUSH
14000: CALL_OW 1
14004: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14005: LD_VAR 0 2
14009: PUSH
14010: LD_STRING ToDep
14012: EQUAL
14013: IFFALSE 14118
// begin tmp := MREG_ToDep [ side ] ;
14015: LD_ADDR_VAR 0 6
14019: PUSH
14020: LD_EXP 57
14024: PUSH
14025: LD_VAR 0 1
14029: ARRAY
14030: ST_TO_ADDR
// if tmp = 0 then
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 0
14038: EQUAL
14039: IFFALSE 14045
// exit else
14041: GO 14352
14043: GO 14118
// begin for i = MREG_ToDep [ side ] downto n do
14045: LD_ADDR_VAR 0 5
14049: PUSH
14050: DOUBLE
14051: LD_EXP 57
14055: PUSH
14056: LD_VAR 0 1
14060: ARRAY
14061: INC
14062: ST_TO_ADDR
14063: LD_VAR 0 3
14067: PUSH
14068: FOR_DOWNTO
14069: IFFALSE 14091
// tmp := Delete ( tmp , 1 ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 3
14088: ST_TO_ADDR
14089: GO 14068
14091: POP
14092: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14093: LD_ADDR_EXP 57
14097: PUSH
14098: LD_EXP 57
14102: PPUSH
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 6
14112: PPUSH
14113: CALL_OW 1
14117: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14118: LD_VAR 0 2
14122: PUSH
14123: LD_STRING ToFac
14125: EQUAL
14126: IFFALSE 14231
// begin tmp := MREG_ToFac [ side ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_EXP 55
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: ST_TO_ADDR
// if tmp = 0 then
14144: LD_VAR 0 6
14148: PUSH
14149: LD_INT 0
14151: EQUAL
14152: IFFALSE 14158
// exit else
14154: GO 14352
14156: GO 14231
// begin for i = MREG_ToFac [ side ] downto n do
14158: LD_ADDR_VAR 0 5
14162: PUSH
14163: DOUBLE
14164: LD_EXP 55
14168: PUSH
14169: LD_VAR 0 1
14173: ARRAY
14174: INC
14175: ST_TO_ADDR
14176: LD_VAR 0 3
14180: PUSH
14181: FOR_DOWNTO
14182: IFFALSE 14204
// tmp := Delete ( tmp , 1 ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 6
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 3
14201: ST_TO_ADDR
14202: GO 14181
14204: POP
14205: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14206: LD_ADDR_EXP 55
14210: PUSH
14211: LD_EXP 55
14215: PPUSH
14216: LD_VAR 0 1
14220: PPUSH
14221: LD_VAR 0 6
14225: PPUSH
14226: CALL_OW 1
14230: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14231: LD_VAR 0 2
14235: PUSH
14236: LD_STRING ToLab
14238: EQUAL
14239: IFFALSE 14344
// begin tmp := MREG_ToLab [ side ] ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_EXP 54
14250: PUSH
14251: LD_VAR 0 1
14255: ARRAY
14256: ST_TO_ADDR
// if tmp = 0 then
14257: LD_VAR 0 6
14261: PUSH
14262: LD_INT 0
14264: EQUAL
14265: IFFALSE 14271
// exit else
14267: GO 14352
14269: GO 14344
// begin for i = MREG_ToLab [ side ] downto n do
14271: LD_ADDR_VAR 0 5
14275: PUSH
14276: DOUBLE
14277: LD_EXP 54
14281: PUSH
14282: LD_VAR 0 1
14286: ARRAY
14287: INC
14288: ST_TO_ADDR
14289: LD_VAR 0 3
14293: PUSH
14294: FOR_DOWNTO
14295: IFFALSE 14317
// tmp := Delete ( tmp , 1 ) ;
14297: LD_ADDR_VAR 0 6
14301: PUSH
14302: LD_VAR 0 6
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 3
14314: ST_TO_ADDR
14315: GO 14294
14317: POP
14318: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14319: LD_ADDR_EXP 54
14323: PUSH
14324: LD_EXP 54
14328: PPUSH
14329: LD_VAR 0 1
14333: PPUSH
14334: LD_VAR 0 6
14338: PPUSH
14339: CALL_OW 1
14343: ST_TO_ADDR
// end ; end ; result := true ;
14344: LD_ADDR_VAR 0 4
14348: PUSH
14349: LD_INT 1
14351: ST_TO_ADDR
// end ;
14352: LD_VAR 0 4
14356: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
// side := GetSide ( unit ) ;
14362: LD_ADDR_VAR 0 4
14366: PUSH
14367: LD_VAR 0 1
14371: PPUSH
14372: CALL_OW 255
14376: ST_TO_ADDR
// tmp := 0 ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14385: LD_VAR 0 1
14389: PUSH
14390: LD_EXP 56
14394: PUSH
14395: LD_VAR 0 4
14399: ARRAY
14400: IN
14401: IFFALSE 14411
// tmp := 1 ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14411: LD_VAR 0 1
14415: PUSH
14416: LD_EXP 57
14420: PUSH
14421: LD_VAR 0 4
14425: ARRAY
14426: IN
14427: IFFALSE 14437
// tmp := 2 ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_INT 2
14436: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14437: LD_VAR 0 1
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: LD_VAR 0 4
14451: ARRAY
14452: IN
14453: IFFALSE 14463
// tmp := 3 ;
14455: LD_ADDR_VAR 0 3
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_EXP 54
14472: PUSH
14473: LD_VAR 0 4
14477: ARRAY
14478: IN
14479: IFFALSE 14489
// tmp := 4 ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: LD_INT 4
14488: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 68
14498: PUSH
14499: LD_VAR 0 4
14503: ARRAY
14504: IN
14505: IFFALSE 14515
// tmp := 5 ;
14507: LD_ADDR_VAR 0 3
14511: PUSH
14512: LD_INT 5
14514: ST_TO_ADDR
// result := tmp ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 3
14524: ST_TO_ADDR
// end ;
14525: LD_VAR 0 2
14529: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
// if mreg = ToArm then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_STRING ToArm
14541: EQUAL
14542: IFFALSE 14631
// for i = MREG_ToArm [ side ] downto 1 do
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: DOUBLE
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: INC
14561: ST_TO_ADDR
14562: LD_INT 1
14564: PUSH
14565: FOR_DOWNTO
14566: IFFALSE 14629
// if MREG_ToArm [ side ] [ i ] = unit then
14568: LD_EXP 56
14572: PUSH
14573: LD_VAR 0 1
14577: ARRAY
14578: PUSH
14579: LD_VAR 0 5
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: EQUAL
14590: IFFALSE 14627
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14592: LD_ADDR_EXP 56
14596: PUSH
14597: LD_EXP 56
14601: PPUSH
14602: LD_EXP 56
14606: PUSH
14607: LD_VAR 0 1
14611: ARRAY
14612: PUSH
14613: LD_VAR 0 5
14617: ARRAY
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 31289 0 3
14626: ST_TO_ADDR
// end ;
14627: GO 14565
14629: POP
14630: POP
// if mreg = ToDep then
14631: LD_VAR 0 2
14635: PUSH
14636: LD_STRING ToDep
14638: EQUAL
14639: IFFALSE 14728
// for i = MREG_ToDep [ side ] downto 1 do
14641: LD_ADDR_VAR 0 5
14645: PUSH
14646: DOUBLE
14647: LD_EXP 57
14651: PUSH
14652: LD_VAR 0 1
14656: ARRAY
14657: INC
14658: ST_TO_ADDR
14659: LD_INT 1
14661: PUSH
14662: FOR_DOWNTO
14663: IFFALSE 14726
// if MREG_ToDep [ side ] [ i ] = unit then
14665: LD_EXP 57
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PUSH
14676: LD_VAR 0 5
14680: ARRAY
14681: PUSH
14682: LD_VAR 0 3
14686: EQUAL
14687: IFFALSE 14724
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14689: LD_ADDR_EXP 57
14693: PUSH
14694: LD_EXP 57
14698: PPUSH
14699: LD_EXP 57
14703: PUSH
14704: LD_VAR 0 1
14708: ARRAY
14709: PUSH
14710: LD_VAR 0 5
14714: ARRAY
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: CALL 31289 0 3
14723: ST_TO_ADDR
// end ;
14724: GO 14662
14726: POP
14727: POP
// if mreg = ToFac then
14728: LD_VAR 0 2
14732: PUSH
14733: LD_STRING ToFac
14735: EQUAL
14736: IFFALSE 14825
// for i = MREG_ToFac [ side ] downto 1 do
14738: LD_ADDR_VAR 0 5
14742: PUSH
14743: DOUBLE
14744: LD_EXP 55
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: INC
14755: ST_TO_ADDR
14756: LD_INT 1
14758: PUSH
14759: FOR_DOWNTO
14760: IFFALSE 14823
// if MREG_ToFac [ side ] [ i ] = unit then
14762: LD_EXP 55
14766: PUSH
14767: LD_VAR 0 1
14771: ARRAY
14772: PUSH
14773: LD_VAR 0 5
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 3
14783: EQUAL
14784: IFFALSE 14821
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14786: LD_ADDR_EXP 55
14790: PUSH
14791: LD_EXP 55
14795: PPUSH
14796: LD_EXP 55
14800: PUSH
14801: LD_VAR 0 1
14805: ARRAY
14806: PUSH
14807: LD_VAR 0 5
14811: ARRAY
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL 31289 0 3
14820: ST_TO_ADDR
// end ;
14821: GO 14759
14823: POP
14824: POP
// if mreg = ToLab then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_STRING ToLab
14832: EQUAL
14833: IFFALSE 14922
// for i = MREG_ToLab [ side ] downto 1 do
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: DOUBLE
14841: LD_EXP 54
14845: PUSH
14846: LD_VAR 0 1
14850: ARRAY
14851: INC
14852: ST_TO_ADDR
14853: LD_INT 1
14855: PUSH
14856: FOR_DOWNTO
14857: IFFALSE 14920
// if MREG_ToLab [ side ] [ i ] = unit then
14859: LD_EXP 54
14863: PUSH
14864: LD_VAR 0 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 5
14874: ARRAY
14875: PUSH
14876: LD_VAR 0 3
14880: EQUAL
14881: IFFALSE 14918
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14883: LD_ADDR_EXP 54
14887: PUSH
14888: LD_EXP 54
14892: PPUSH
14893: LD_EXP 54
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PUSH
14904: LD_VAR 0 5
14908: ARRAY
14909: PPUSH
14910: LD_INT 1
14912: PPUSH
14913: CALL 31289 0 3
14917: ST_TO_ADDR
// end ;
14918: GO 14856
14920: POP
14921: POP
// end ;
14922: LD_VAR 0 4
14926: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// result := false ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: DOUBLE
14945: LD_INT 1
14947: DEC
14948: ST_TO_ADDR
14949: LD_EXP 46
14953: PUSH
14954: FOR_TO
14955: IFFALSE 15019
// if MREG_ToBuild [ i ] [ 1 ] = side then
14957: LD_EXP 46
14961: PUSH
14962: LD_VAR 0 3
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_VAR 0 1
14976: EQUAL
14977: IFFALSE 15017
// begin if MREG_ToBuild [ i ] [ 1 ] then
14979: LD_EXP 46
14983: PUSH
14984: LD_VAR 0 3
14988: ARRAY
14989: PUSH
14990: LD_INT 1
14992: ARRAY
14993: IFFALSE 15017
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14995: LD_ADDR_VAR 0 2
14999: PUSH
15000: LD_EXP 46
15004: PUSH
15005: LD_VAR 0 3
15009: ARRAY
15010: PUSH
15011: LD_INT 1
15013: ARRAY
15014: ST_TO_ADDR
// break ;
15015: GO 15019
// end ; end ;
15017: GO 14954
15019: POP
15020: POP
// for i = 1 to MREG_ToRepair do
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: DOUBLE
15027: LD_INT 1
15029: DEC
15030: ST_TO_ADDR
15031: LD_EXP 47
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15101
// if MREG_ToRepair [ i ] [ 1 ] = side then
15039: LD_EXP 47
15043: PUSH
15044: LD_VAR 0 3
15048: ARRAY
15049: PUSH
15050: LD_INT 1
15052: ARRAY
15053: PUSH
15054: LD_VAR 0 1
15058: EQUAL
15059: IFFALSE 15099
// begin if MREG_ToRepair [ i ] [ 1 ] then
15061: LD_EXP 47
15065: PUSH
15066: LD_VAR 0 3
15070: ARRAY
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: IFFALSE 15099
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15077: LD_ADDR_VAR 0 2
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: LD_VAR 0 3
15091: ARRAY
15092: PUSH
15093: LD_INT 1
15095: ARRAY
15096: ST_TO_ADDR
// break ;
15097: GO 15101
// end ; end ;
15099: GO 15036
15101: POP
15102: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_INT 57
15110: PUSH
15111: EMPTY
15112: LIST
15113: PPUSH
15114: CALL 11651 0 2
15118: IFFALSE 15145
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 57
15132: PUSH
15133: EMPTY
15134: LIST
15135: PPUSH
15136: CALL 11651 0 2
15140: PUSH
15141: LD_INT 1
15143: ARRAY
15144: ST_TO_ADDR
// end ;
15145: LD_VAR 0 2
15149: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL 11651 0 2
15181: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15182: LD_ADDR_VAR 0 7
15186: PUSH
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 81
15194: PUSH
15195: LD_VAR 0 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL 11651 0 2
15208: ST_TO_ADDR
// if not enemy then
15209: LD_VAR 0 7
15213: NOT
15214: IFFALSE 15226
// result := false else
15216: LD_ADDR_VAR 0 3
15220: PUSH
15221: LD_INT 0
15223: ST_TO_ADDR
15224: GO 15280
// begin scan := NearestUnit ( b , enemy ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 6
15235: PPUSH
15236: LD_VAR 0 7
15240: PPUSH
15241: CALL 32282 0 2
15245: ST_TO_ADDR
// if scan [ 2 ] < dist then
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 2
15259: LESS
15260: IFFALSE 15272
// result := true else
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
15270: GO 15280
// result := false ;
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 0
15279: ST_TO_ADDR
// end ; end ;
15280: LD_VAR 0 3
15284: RET
// export function MCF_Info ( ) ; begin
15285: LD_INT 0
15287: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15288: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15290: PUSH
15291: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15293: ADD
15294: PUSH
15295: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15297: ADD
15298: PUSH
15299: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15301: ADD
15302: PUSH
15303: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15305: ADD
15306: PUSH
15307: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15325: ADD
15326: PPUSH
15327: CALL 8569 0 1
// end ; end_of_file
15331: LD_VAR 0 1
15335: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 2
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11651 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13800 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 13420 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 1
15529: PPUSH
15530: CALL 41960 0 4
15534: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 56
15539: PUSH
15540: LD_EXP 56
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 56
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 31130 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 3
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11651 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13800 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 13420 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 2
15787: PPUSH
15788: CALL 41960 0 4
15792: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 57
15797: PUSH
15798: LD_EXP 57
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 57
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 31130 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 25
15893: PUSH
15894: LD_INT 4
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL 11651 0 2
15911: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15912: LD_ADDR_VAR 0 5
15916: PUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: LD_INT 0
15924: PPUSH
15925: CALL 13800 0 2
15929: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_VAR 0 5
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 13420 0 3
15952: ST_TO_ADDR
// if n > sk then
15953: LD_VAR 0 2
15957: PUSH
15958: LD_VAR 0 6
15962: GREATER
15963: IFFALSE 15975
// n := sk ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_VAR 0 6
15974: ST_TO_ADDR
// for i = 1 to n do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 2
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16103
// if ( sk [ i ] [ 1 ] ) <> 0 then
15993: LD_VAR 0 6
15997: PUSH
15998: LD_VAR 0 4
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PUSH
16008: LD_INT 0
16010: NONEQUAL
16011: IFFALSE 16101
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16013: LD_ADDR_EXP 53
16017: PUSH
16018: LD_EXP 53
16022: PPUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 6
16032: PUSH
16033: LD_VAR 0 4
16037: ARRAY
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_INT 3
16045: PPUSH
16046: CALL 41960 0 4
16050: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16051: LD_ADDR_EXP 55
16055: PUSH
16056: LD_EXP 55
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: LD_EXP 55
16070: PUSH
16071: LD_VAR 0 1
16075: ARRAY
16076: PUSH
16077: LD_INT 1
16079: PLUS
16080: PPUSH
16081: LD_VAR 0 6
16085: PUSH
16086: LD_VAR 0 4
16090: ARRAY
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL 31130 0 4
16100: ST_TO_ADDR
// end ;
16101: GO 15990
16103: POP
16104: POP
// end ;
16105: LD_VAR 0 3
16109: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16116: LD_ADDR_VAR 0 5
16120: PUSH
16121: LD_VAR 0 1
16125: PPUSH
16126: LD_INT 2
16128: PUSH
16129: LD_INT 25
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL 11651 0 2
16158: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: LD_VAR 0 5
16168: PPUSH
16169: LD_INT 0
16171: PPUSH
16172: CALL 13800 0 2
16176: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16177: LD_ADDR_VAR 0 6
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 13420 0 3
16199: ST_TO_ADDR
// if n > sk then
16200: LD_VAR 0 2
16204: PUSH
16205: LD_VAR 0 6
16209: GREATER
16210: IFFALSE 16222
// n := sk ;
16212: LD_ADDR_VAR 0 2
16216: PUSH
16217: LD_VAR 0 6
16221: ST_TO_ADDR
// for i = 1 to n do
16222: LD_ADDR_VAR 0 4
16226: PUSH
16227: DOUBLE
16228: LD_INT 1
16230: DEC
16231: ST_TO_ADDR
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_TO
16238: IFFALSE 16350
// if ( sk [ i ] [ 1 ] ) <> 0 then
16240: LD_VAR 0 6
16244: PUSH
16245: LD_VAR 0 4
16249: ARRAY
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: PUSH
16255: LD_INT 0
16257: NONEQUAL
16258: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 4
16284: ARRAY
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: PPUSH
16290: LD_INT 4
16292: PPUSH
16293: CALL 41960 0 4
16297: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16298: LD_ADDR_EXP 54
16302: PUSH
16303: LD_EXP 54
16307: PPUSH
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_EXP 54
16317: PUSH
16318: LD_VAR 0 1
16322: ARRAY
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: LD_VAR 0 6
16332: PUSH
16333: LD_VAR 0 4
16337: ARRAY
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 31130 0 4
16347: ST_TO_ADDR
// end ;
16348: GO 16237
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 3
16356: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 25
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 25
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 25
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL 11651 0 2
16427: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16428: LD_ADDR_VAR 0 6
16432: PUSH
16433: LD_VAR 0 6
16437: PPUSH
16438: LD_INT 0
16440: PPUSH
16441: CALL 13800 0 2
16445: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16446: LD_ADDR_VAR 0 7
16450: PUSH
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_VAR 0 6
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL 13420 0 3
16468: ST_TO_ADDR
// if n > sk then
16469: LD_VAR 0 2
16473: PUSH
16474: LD_VAR 0 7
16478: GREATER
16479: IFFALSE 16491
// n := sk ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 7
16490: ST_TO_ADDR
// for i = 1 to n do
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: DOUBLE
16497: LD_INT 1
16499: DEC
16500: ST_TO_ADDR
16501: LD_VAR 0 2
16505: PUSH
16506: FOR_TO
16507: IFFALSE 16551
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_EXP 53
16518: PPUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_VAR 0 7
16528: PUSH
16529: LD_VAR 0 5
16533: ARRAY
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 3
16543: PPUSH
16544: CALL 41960 0 4
16548: ST_TO_ADDR
// end ;
16549: GO 16506
16551: POP
16552: POP
// end ;
16553: LD_VAR 0 4
16557: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16558: LD_INT 0
16560: PPUSH
16561: PPUSH
16562: PPUSH
// b := false ;
16563: LD_ADDR_VAR 0 6
16567: PUSH
16568: LD_INT 0
16570: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: LD_INT 9
16581: PUSH
16582: LD_INT 5
16584: PUSH
16585: LD_INT 8
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: IN
16594: IFFALSE 16682
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16596: LD_VAR 0 1
16600: PPUSH
16601: LD_INT 2
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL 11651 0 2
16633: IFFALSE 16682
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 30
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL 11651 0 2
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: ST_TO_ADDR
// if class = class_engineer then
16682: LD_VAR 0 3
16686: PUSH
16687: LD_INT 2
16689: EQUAL
16690: IFFALSE 16778
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16692: LD_VAR 0 1
16696: PPUSH
16697: LD_INT 2
16699: PUSH
16700: LD_INT 30
16702: PUSH
16703: LD_INT 0
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 30
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL 11651 0 2
16729: IFFALSE 16778
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16731: LD_ADDR_VAR 0 6
16735: PUSH
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 30
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL 11651 0 2
16773: PUSH
16774: LD_INT 1
16776: ARRAY
16777: ST_TO_ADDR
// if class = class_mechanic then
16778: LD_VAR 0 3
16782: PUSH
16783: LD_INT 3
16785: EQUAL
16786: IFFALSE 16856
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 30
16795: PUSH
16796: LD_INT 3
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PPUSH
16803: CALL 11651 0 2
16807: IFFALSE 16856
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16809: LD_ADDR_VAR 0 6
16813: PUSH
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_INT 2
16821: PUSH
16822: LD_INT 30
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 30
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PPUSH
16847: CALL 11651 0 2
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: ST_TO_ADDR
// if class = class_scientistic then
16856: LD_VAR 0 3
16860: PUSH
16861: LD_INT 4
16863: EQUAL
16864: IFFALSE 16974
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16866: LD_VAR 0 1
16870: PPUSH
16871: LD_INT 2
16873: PUSH
16874: LD_INT 30
16876: PUSH
16877: LD_INT 6
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PUSH
16884: LD_INT 30
16886: PUSH
16887: LD_INT 7
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 30
16896: PUSH
16897: LD_INT 8
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PPUSH
16910: CALL 11651 0 2
16914: IFFALSE 16974
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16916: LD_ADDR_VAR 0 6
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: LD_INT 2
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 6
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 30
16941: PUSH
16942: LD_INT 7
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 30
16951: PUSH
16952: LD_INT 8
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL 11651 0 2
16969: PUSH
16970: LD_INT 1
16972: ARRAY
16973: ST_TO_ADDR
// if GetClass ( unit ) = class then
16974: LD_VAR 0 2
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_VAR 0 3
16988: EQUAL
16989: IFFALSE 17023
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16991: LD_ADDR_EXP 53
16995: PUSH
16996: LD_EXP 53
17000: PPUSH
17001: LD_VAR 0 1
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: LD_VAR 0 3
17015: PPUSH
17016: CALL 42051 0 4
17020: ST_TO_ADDR
// end else
17021: GO 17116
// if b then
17023: LD_VAR 0 6
17027: IFFALSE 17108
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17029: LD_VAR 0 2
17033: PPUSH
17034: CALL_OW 310
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: CALL_OW 310
17048: PUSH
17049: LD_VAR 0 6
17053: NONEQUAL
17054: AND
17055: IFFALSE 17066
// ComExitBuilding ( unit ) ;
17057: LD_VAR 0 2
17061: PPUSH
17062: CALL_OW 122
// if not IsInUnit ( unit ) then
17066: LD_VAR 0 2
17070: PPUSH
17071: CALL_OW 310
17075: NOT
17076: IFFALSE 17092
// ComEnterUnit ( unit , b ) ;
17078: LD_VAR 0 2
17082: PPUSH
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_VAR 0 3
17101: PPUSH
17102: CALL_OW 183
// end else
17106: GO 17116
// result := false ;
17108: LD_ADDR_VAR 0 4
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// end ; end_of_file
17116: LD_VAR 0 4
17120: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17121: LD_INT 0
17123: PPUSH
17124: PPUSH
17125: PPUSH
17126: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17127: LD_ADDR_VAR 0 5
17131: PUSH
17132: LD_INT 35
17134: PUSH
17135: LD_INT 45
17137: PUSH
17138: LD_INT 46
17140: PUSH
17141: LD_INT 47
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 48
17152: PUSH
17153: LD_INT 49
17155: PUSH
17156: LD_INT 50
17158: PUSH
17159: LD_INT 20
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// if MCF_Lab ( side ) then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL 11690 0 1
17183: IFFALSE 17422
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL 11690 0 1
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: CALL_OW 461
17203: PUSH
17204: LD_INT 2
17206: EQUAL
17207: IFFALSE 17346
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17209: LD_VAR 0 1
17213: PPUSH
17214: CALL 11690 0 1
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PPUSH
17223: LD_VAR 0 2
17227: PPUSH
17228: CALL 17518 0 2
17232: IFFALSE 17259
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11690 0 1
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 124
17257: GO 17346
// if MCF_Lab ( side ) > 1 then
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11690 0 1
17268: PUSH
17269: LD_INT 1
17271: GREATER
17272: IFFALSE 17346
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17274: LD_VAR 0 1
17278: PPUSH
17279: CALL 11690 0 1
17283: PUSH
17284: LD_INT 2
17286: ARRAY
17287: PPUSH
17288: CALL_OW 461
17292: PUSH
17293: LD_INT 2
17295: EQUAL
17296: IFFALSE 17346
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17298: LD_VAR 0 1
17302: PPUSH
17303: CALL 11690 0 1
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_VAR 0 2
17316: PPUSH
17317: CALL 17518 0 2
17321: IFFALSE 17346
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17323: LD_VAR 0 1
17327: PPUSH
17328: CALL 11690 0 1
17332: PUSH
17333: LD_INT 2
17335: ARRAY
17336: PPUSH
17337: LD_VAR 0 2
17341: PPUSH
17342: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 4
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: LIST
17367: LIST
17368: IN
17369: IFFALSE 17422
// begin for lab in MCF_Lab ( side ) do
17371: LD_ADDR_VAR 0 6
17375: PUSH
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 11690 0 1
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17420
// if BuildingStatus ( lab ) = bs_need_ape then
17389: LD_VAR 0 6
17393: PPUSH
17394: CALL_OW 461
17398: PUSH
17399: LD_INT 10
17401: EQUAL
17402: IFFALSE 17418
// MCL_ResTame ( side , lab ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL 17643 0 2
17418: GO 17386
17420: POP
17421: POP
// end ; end ; end ;
17422: LD_VAR 0 3
17426: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17427: LD_INT 0
17429: PPUSH
17430: PPUSH
// tmp := [ ] ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// if not lab then
17438: LD_VAR 0 1
17442: NOT
17443: IFFALSE 17455
// result := false else
17445: LD_ADDR_VAR 0 2
17449: PUSH
17450: LD_INT 0
17452: ST_TO_ADDR
17453: GO 17513
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17455: LD_ADDR_VAR 0 3
17459: PUSH
17460: LD_VAR 0 3
17464: PUSH
17465: LD_VAR 0 1
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 268
17477: ADD
17478: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_VAR 0 3
17488: PUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: LD_INT 2
17496: PPUSH
17497: CALL_OW 268
17501: ADD
17502: ST_TO_ADDR
// result := tmp ;
17503: LD_ADDR_VAR 0 2
17507: PUSH
17508: LD_VAR 0 3
17512: ST_TO_ADDR
// end ; end ;
17513: LD_VAR 0 2
17517: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 35
17530: PUSH
17531: LD_INT 45
17533: PUSH
17534: LD_INT 46
17536: PUSH
17537: LD_INT 47
17539: PUSH
17540: LD_INT 1
17542: PUSH
17543: LD_INT 2
17545: PUSH
17546: LD_INT 48
17548: PUSH
17549: LD_INT 49
17551: PUSH
17552: LD_INT 50
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: ST_TO_ADDR
// if lab then
17570: LD_VAR 0 1
17574: IFFALSE 17630
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17576: LD_VAR 0 2
17580: PUSH
17581: LD_VAR 0 5
17585: IN
17586: PUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: CALL_OW 481
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: CALL 17427 0 1
17606: IN
17607: OR
17608: IFFALSE 17620
// result := true else
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
17618: GO 17628
// result := false ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 0
17627: ST_TO_ADDR
// end else
17628: GO 17638
// result := false ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_INT 0
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 3
17642: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17643: LD_INT 0
17645: PPUSH
17646: PPUSH
17647: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17648: LD_ADDR_VAR 0 4
17652: PUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_INT 171
17660: PPUSH
17661: EMPTY
17662: PPUSH
17663: CALL 12354 0 3
17667: ST_TO_ADDR
// if not ape then
17668: LD_VAR 0 4
17672: NOT
17673: IFFALSE 17705
// if MCF_Ape ( side ) then
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 12064 0 1
17684: IFFALSE 17705
// ape := MCF_Ape ( side ) [ 1 ] ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12064 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: ST_TO_ADDR
// if ape then
17705: LD_VAR 0 4
17709: IFFALSE 17760
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17711: LD_VAR 0 4
17715: PUSH
17716: LD_INT 1
17718: ARRAY
17719: PPUSH
17720: CALL_OW 310
17724: PUSH
17725: LD_VAR 0 4
17729: PUSH
17730: LD_INT 1
17732: ARRAY
17733: PPUSH
17734: CALL_OW 310
17738: PUSH
17739: LD_VAR 0 2
17743: NONEQUAL
17744: AND
17745: IFFALSE 17760
// ComExitBuilding ( ape [ 1 ] ) ;
17747: LD_VAR 0 4
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 122
// if not lab then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17771
// exit else
17767: GO 17919
17769: GO 17879
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 4
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL 12354 0 3
17793: PUSH
17794: LD_INT 0
17796: EQUAL
17797: PUSH
17798: LD_VAR 0 2
17802: PPUSH
17803: CALL_OW 313
17807: PUSH
17808: LD_INT 6
17810: EQUAL
17811: AND
17812: IFFALSE 17879
// begin tmp := UnitsInside ( lab ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 313
17828: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17829: LD_VAR 0 5
17833: PUSH
17834: LD_VAR 0 5
17838: ARRAY
17839: PPUSH
17840: LD_INT 16
17842: PPUSH
17843: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17847: LD_VAR 0 5
17851: PUSH
17852: LD_VAR 0 5
17856: ARRAY
17857: PPUSH
17858: CALL_OW 310
17862: IFFALSE 17879
// ComExitBuilding ( tmp [ tmp ] ) ;
17864: LD_VAR 0 5
17868: PUSH
17869: LD_VAR 0 5
17873: ARRAY
17874: PPUSH
17875: CALL_OW 122
// end ; if ape then
17879: LD_VAR 0 4
17883: IFFALSE 17919
// if not IsInUnit ( ape [ 1 ] ) then
17885: LD_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: ARRAY
17893: PPUSH
17894: CALL_OW 310
17898: NOT
17899: IFFALSE 17919
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: LD_VAR 0 2
17914: PPUSH
17915: CALL_OW 120
// end ;
17919: LD_VAR 0 3
17923: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17924: LD_INT 0
17926: PPUSH
17927: PPUSH
17928: PPUSH
// result := false ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: LD_INT 0
17936: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PPUSH
17947: CALL 18034 0 1
17951: ST_TO_ADDR
// if techs then
17952: LD_VAR 0 3
17956: IFFALSE 17986
// if techs [ 2 ] then
17958: LD_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: ARRAY
17966: IFFALSE 17978
// result := true else
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ST_TO_ADDR
17976: GO 17986
// result := false ;
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 2
17990: RET
// export function MCL_Start ( side ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// if MCL_GetTechList ( side ) then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL 18034 0 1
18004: IFFALSE 18029
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18034 0 1
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL 17121 0 2
// end ;
18029: LD_VAR 0 2
18033: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18034: LD_INT 0
18036: PPUSH
18037: PPUSH
18038: PPUSH
// if MREG_ToRes then
18039: LD_EXP 50
18043: IFFALSE 18128
// for i = 1 to MREG_ToRes do
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_EXP 50
18059: PUSH
18060: FOR_TO
18061: IFFALSE 18126
// if MREG_ToRes [ i ] [ 1 ] = side then
18063: LD_EXP 50
18067: PUSH
18068: LD_VAR 0 3
18072: ARRAY
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PUSH
18078: LD_VAR 0 1
18082: EQUAL
18083: IFFALSE 18124
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18085: LD_ADDR_VAR 0 4
18089: PUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: LD_VAR 0 4
18099: PUSH
18100: LD_INT 1
18102: PLUS
18103: PPUSH
18104: LD_EXP 50
18108: PUSH
18109: LD_VAR 0 3
18113: ARRAY
18114: PUSH
18115: LD_INT 2
18117: ARRAY
18118: PPUSH
18119: CALL_OW 1
18123: ST_TO_ADDR
// end ;
18124: GO 18060
18126: POP
18127: POP
// result := techs ;
18128: LD_ADDR_VAR 0 2
18132: PUSH
18133: LD_VAR 0 4
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18143: LD_INT 0
18145: PPUSH
18146: PPUSH
// for i = 1 to tech_list do
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: DOUBLE
18153: LD_INT 1
18155: DEC
18156: ST_TO_ADDR
18157: LD_VAR 0 2
18161: PUSH
18162: FOR_TO
18163: IFFALSE 18217
// if not tech_list [ i ] = 20 then
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 4
18174: ARRAY
18175: PUSH
18176: LD_INT 20
18178: EQUAL
18179: NOT
18180: IFFALSE 18215
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: LD_VAR 0 2
18201: PUSH
18202: LD_VAR 0 4
18206: ARRAY
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL 41960 0 4
18214: ST_TO_ADDR
18215: GO 18162
18217: POP
18218: POP
// result := true ;
18219: LD_ADDR_VAR 0 3
18223: PUSH
18224: LD_INT 1
18226: ST_TO_ADDR
// end ;
18227: LD_VAR 0 3
18231: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// for i = MREG_ToRes downto 1 do
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: DOUBLE
18242: LD_EXP 50
18246: INC
18247: ST_TO_ADDR
18248: LD_INT 1
18250: PUSH
18251: FOR_DOWNTO
18252: IFFALSE 18298
// if MREG_ToRes [ i ] [ 1 ] = side then
18254: LD_EXP 50
18258: PUSH
18259: LD_VAR 0 3
18263: ARRAY
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_VAR 0 1
18273: EQUAL
18274: IFFALSE 18296
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18276: LD_ADDR_EXP 50
18280: PUSH
18281: LD_EXP 50
18285: PPUSH
18286: LD_VAR 0 3
18290: PPUSH
18291: CALL_OW 3
18295: ST_TO_ADDR
18296: GO 18251
18298: POP
18299: POP
// result := true ;
18300: LD_ADDR_VAR 0 2
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// end ;
18308: LD_VAR 0 2
18312: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18313: LD_INT 0
18315: PPUSH
// result := GetTechProgress ( side , tech ) ;
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 326
18335: ST_TO_ADDR
// end ;
18336: LD_VAR 0 3
18340: RET
// export function MCL_Require ( tech ) ; begin
18341: LD_INT 0
18343: PPUSH
// result := GetTechTechsReq ( tech ) ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL_OW 480
18358: ST_TO_ADDR
// end ; end_of_file
18359: LD_VAR 0 2
18363: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
18368: PPUSH
// uc_side := 0 ;
18369: LD_ADDR_OWVAR 20
18373: PUSH
18374: LD_INT 0
18376: ST_TO_ADDR
// uc_nation := 0 ;
18377: LD_ADDR_OWVAR 21
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// for i = 1 to n do
18385: LD_ADDR_VAR 0 5
18389: PUSH
18390: DOUBLE
18391: LD_INT 1
18393: DEC
18394: ST_TO_ADDR
18395: LD_VAR 0 2
18399: PUSH
18400: FOR_TO
18401: IFFALSE 18546
// begin hc_importance := 0 ;
18403: LD_ADDR_OWVAR 32
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// hc_gallery :=  ;
18411: LD_ADDR_OWVAR 33
18415: PUSH
18416: LD_STRING 
18418: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18419: LD_ADDR_OWVAR 35
18423: PUSH
18424: LD_VAR 0 3
18428: PUSH
18429: LD_INT 20
18431: MINUS
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_INT 20
18440: PLUS
18441: PPUSH
18442: CALL_OW 12
18446: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18447: LD_ADDR_OWVAR 31
18451: PUSH
18452: LD_INT 0
18454: PPUSH
18455: LD_INT 2
18457: PPUSH
18458: CALL_OW 12
18462: PUSH
18463: LD_INT 0
18465: PUSH
18466: LD_INT 0
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18478: LD_ADDR_OWVAR 30
18482: PUSH
18483: LD_INT 0
18485: PUSH
18486: LD_INT 0
18488: PUSH
18489: LD_INT 0
18491: PUSH
18492: LD_INT 0
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// hc_name :=  ;
18501: LD_ADDR_OWVAR 26
18505: PUSH
18506: LD_STRING 
18508: ST_TO_ADDR
// hc_class := class_apeman ;
18509: LD_ADDR_OWVAR 28
18513: PUSH
18514: LD_INT 12
18516: ST_TO_ADDR
// ape := CreateHuman ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: CALL_OW 44
18526: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18527: LD_VAR 0 6
18531: PPUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: LD_INT 0
18539: PPUSH
18540: CALL_OW 49
// end ;
18544: GO 18400
18546: POP
18547: POP
// end ;
18548: LD_VAR 0 4
18552: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18553: LD_INT 0
18555: PPUSH
18556: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 12064 0 1
18566: PUSH
18567: LD_EXP 37
18571: PUSH
18572: LD_VAR 0 1
18576: ARRAY
18577: GREATEREQUAL
18578: IFFALSE 18755
// begin if GetTag ( unit ) = 17 then
18580: LD_VAR 0 2
18584: PPUSH
18585: CALL_OW 110
18589: PUSH
18590: LD_INT 17
18592: EQUAL
18593: IFFALSE 18753
// begin SetTag ( unit , 0 ) ;
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_INT 0
18602: PPUSH
18603: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL 11690 0 1
18616: PUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL 18034 0 1
18626: NOT
18627: AND
18628: IFFALSE 18653
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18630: LD_VAR 0 2
18634: PPUSH
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 11690 0 1
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18653: LD_VAR 0 1
18657: PPUSH
18658: CALL 11690 0 1
18662: NOT
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 30
18671: PUSH
18672: LD_INT 1
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL 11651 0 2
18683: AND
18684: IFFALSE 18753
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18686: LD_VAR 0 2
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL 11651 0 2
18710: PUSH
18711: LD_INT 1
18713: ARRAY
18714: PPUSH
18715: CALL_OW 250
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 11651 0 2
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: CALL_OW 251
18748: PPUSH
18749: CALL_OW 111
// end ; end else
18753: GO 18939
// if GetClass ( unit ) <> 4 then
18755: LD_VAR 0 2
18759: PPUSH
18760: CALL_OW 257
18764: PUSH
18765: LD_INT 4
18767: NONEQUAL
18768: IFFALSE 18774
// exit else
18770: GO 18939
18772: GO 18939
// if GetTag ( unit ) = 0 then
18774: LD_VAR 0 2
18778: PPUSH
18779: CALL_OW 110
18783: PUSH
18784: LD_INT 0
18786: EQUAL
18787: IFFALSE 18803
// SetTag ( unit , 17 ) else
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 17
18796: PPUSH
18797: CALL_OW 109
18801: GO 18939
// begin if IsInUnit ( unit ) then
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18823
// ComExitBuilding ( unit ) ;
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 122
// Wait ( 1 ) ;
18823: LD_INT 1
18825: PPUSH
18826: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18830: LD_ADDR_VAR 0 4
18834: PUSH
18835: LD_INT 22
18837: PUSH
18838: LD_INT 0
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 25
18847: PUSH
18848: LD_INT 12
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PPUSH
18859: CALL_OW 69
18863: PPUSH
18864: LD_VAR 0 2
18868: PPUSH
18869: CALL_OW 74
18873: ST_TO_ADDR
// if not ape then
18874: LD_VAR 0 4
18878: NOT
18879: IFFALSE 18885
// exit else
18881: GO 18939
18883: GO 18894
// ComHold ( ape ) ;
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 140
// if not HasTask ( unit ) then
18894: LD_VAR 0 2
18898: PPUSH
18899: CALL_OW 314
18903: NOT
18904: IFFALSE 18937
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18906: LD_VAR 0 2
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: CALL_OW 250
18920: PPUSH
18921: LD_VAR 0 4
18925: PPUSH
18926: CALL_OW 251
18930: PPUSH
18931: CALL_OW 131
18935: GO 18939
// exit ;
18937: GO 18939
// end ; end ;
18939: LD_VAR 0 3
18943: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18944: LD_INT 0
18946: PPUSH
18947: PPUSH
18948: PPUSH
18949: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18950: LD_ADDR_VAR 0 4
18954: PUSH
18955: LD_EXP 38
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18966: LD_ADDR_VAR 0 5
18970: PUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: LD_STRING normal
18978: PPUSH
18979: CALL 12148 0 2
18983: ST_TO_ADDR
// if apes then
18984: LD_VAR 0 5
18988: IFFALSE 19216
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18990: LD_INT 2
18992: PPUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 321
19002: PUSH
19003: LD_INT 2
19005: EQUAL
19006: PUSH
19007: LD_VAR 0 4
19011: PUSH
19012: LD_INT 2
19014: ARRAY
19015: PUSH
19016: LD_INT 1
19018: EQUAL
19019: AND
19020: PUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: LD_STRING engineer
19028: PPUSH
19029: CALL 12148 0 2
19033: PUSH
19034: LD_INT 3
19036: LESS
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 1
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11651 0 2
19058: AND
19059: IFFALSE 19113
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 1
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11651 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end else
19111: GO 19216
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19113: LD_INT 11
19115: PPUSH
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 321
19125: PUSH
19126: LD_INT 2
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: LD_INT 1
19137: ARRAY
19138: PUSH
19139: LD_INT 1
19141: EQUAL
19142: AND
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_INT 30
19151: PUSH
19152: LD_INT 5
19154: PUSH
19155: EMPTY
19156: LIST
19157: LIST
19158: PPUSH
19159: CALL 11651 0 2
19163: AND
19164: IFFALSE 19216
// begin for i in apes do
19166: LD_ADDR_VAR 0 3
19170: PUSH
19171: LD_VAR 0 5
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19214
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 5
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11651 0 2
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: CALL_OW 120
// end ;
19212: GO 19176
19214: POP
19215: POP
// end ; end ; end ; end_of_file
19216: LD_VAR 0 2
19220: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 257
19234: PUSH
19235: LD_INT 4
19237: EQUAL
19238: NOT
19239: PUSH
19240: LD_VAR 0 2
19244: NOT
19245: OR
19246: IFFALSE 19252
// exit else
19248: GO 19286
19250: GO 19286
// if not GetTag ( unit ) = 4 then
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 110
19261: PUSH
19262: LD_INT 4
19264: EQUAL
19265: NOT
19266: IFFALSE 19272
// exit else
19268: GO 19286
19270: GO 19286
// ComHeal ( unit , target ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL_OW 128
// end ;
19286: LD_VAR 0 3
19290: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19291: LD_INT 0
19293: PPUSH
19294: PPUSH
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
19299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19300: LD_ADDR_VAR 0 5
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_VAR 0 1
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 1
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 55
19332: PUSH
19333: EMPTY
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 3
19342: PUSH
19343: LD_INT 54
19345: PUSH
19346: EMPTY
19347: LIST
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 3
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 1000
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_INT 30
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 11651 0 2
19406: ST_TO_ADDR
// r := [ ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: EMPTY
19413: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19414: LD_VAR 0 1
19418: PPUSH
19419: LD_INT 5
19421: PPUSH
19422: EMPTY
19423: PPUSH
19424: CALL 12354 0 3
19428: IFFALSE 19484
// for j in MCF_Tag ( side , 5 , [ ] ) do
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: LD_INT 5
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL 12354 0 3
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19482
// if GetLives ( j ) = 1000 then
19453: LD_VAR 0 4
19457: PPUSH
19458: CALL_OW 256
19462: PUSH
19463: LD_INT 1000
19465: EQUAL
19466: IFFALSE 19480
// SetTag ( j , 0 ) ;
19468: LD_VAR 0 4
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL_OW 109
19480: GO 19450
19482: POP
19483: POP
// if tmp then
19484: LD_VAR 0 5
19488: IFFALSE 19817
// begin r := [ tmp [ 1 ] ] ;
19490: LD_ADDR_VAR 0 6
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_INT 1
19502: ARRAY
19503: PUSH
19504: EMPTY
19505: LIST
19506: ST_TO_ADDR
// for i = 2 to tmp do
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: DOUBLE
19513: LD_INT 2
19515: DEC
19516: ST_TO_ADDR
19517: LD_VAR 0 5
19521: PUSH
19522: FOR_TO
19523: IFFALSE 19815
// begin m := false ;
19525: LD_ADDR_VAR 0 7
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// if d then
19533: LD_VAR 0 8
19537: IFFALSE 19692
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19539: LD_VAR 0 5
19543: PUSH
19544: LD_VAR 0 3
19548: ARRAY
19549: PPUSH
19550: CALL_OW 256
19554: PUSH
19555: LD_INT 650
19557: LESS
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: PPUSH
19570: LD_VAR 0 8
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: CALL_OW 250
19583: PPUSH
19584: LD_VAR 0 8
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: CALL_OW 251
19597: PPUSH
19598: CALL_OW 297
19602: PUSH
19603: LD_INT 10
19605: GREATER
19606: AND
19607: IFFALSE 19692
// begin if not GetTag ( tmp [ i ] ) = 5 then
19609: LD_VAR 0 5
19613: PUSH
19614: LD_VAR 0 3
19618: ARRAY
19619: PPUSH
19620: CALL_OW 110
19624: PUSH
19625: LD_INT 5
19627: EQUAL
19628: NOT
19629: IFFALSE 19649
// SetTag ( tmp [ i ] , 5 ) ;
19631: LD_VAR 0 5
19635: PUSH
19636: LD_VAR 0 3
19640: ARRAY
19641: PPUSH
19642: LD_INT 5
19644: PPUSH
19645: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: LD_VAR 0 8
19664: PUSH
19665: LD_INT 1
19667: ARRAY
19668: PPUSH
19669: CALL_OW 250
19673: PPUSH
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 1
19681: ARRAY
19682: PPUSH
19683: CALL_OW 251
19687: PPUSH
19688: CALL_OW 111
// end ; for j = 1 to r do
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_VAR 0 6
19706: PUSH
19707: FOR_TO
19708: IFFALSE 19782
// if GetLives ( tmp [ i ] ) < r [ j ] then
19710: LD_VAR 0 5
19714: PUSH
19715: LD_VAR 0 3
19719: ARRAY
19720: PPUSH
19721: CALL_OW 256
19725: PUSH
19726: LD_VAR 0 6
19730: PUSH
19731: LD_VAR 0 4
19735: ARRAY
19736: LESS
19737: IFFALSE 19780
// begin r := Insert ( r , j , tmp [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 6
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 5
19758: PUSH
19759: LD_VAR 0 3
19763: ARRAY
19764: PPUSH
19765: CALL_OW 2
19769: ST_TO_ADDR
// m := true ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// break ;
19778: GO 19782
// end ;
19780: GO 19707
19782: POP
19783: POP
// if not m then
19784: LD_VAR 0 7
19788: NOT
19789: IFFALSE 19813
// r := r ^ tmp [ i ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_VAR 0 6
19800: PUSH
19801: LD_VAR 0 5
19805: PUSH
19806: LD_VAR 0 3
19810: ARRAY
19811: ADD
19812: ST_TO_ADDR
// end ;
19813: GO 19522
19815: POP
19816: POP
// end ; result := r end ; end_of_file
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: LD_VAR 0 6
19826: ST_TO_ADDR
19827: LD_VAR 0 2
19831: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19832: LD_INT 0
19834: PPUSH
19835: PPUSH
19836: PPUSH
// pom := GetBase ( bdepot ) ;
19837: LD_ADDR_VAR 0 3
19841: PUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: CALL_OW 274
19851: ST_TO_ADDR
// sor := [ ] ;
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: EMPTY
19858: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 4
19868: PUSH
19869: LD_VAR 0 3
19873: PPUSH
19874: LD_INT 1
19876: PPUSH
19877: CALL_OW 275
19881: ADD
19882: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_VAR 0 4
19892: PUSH
19893: LD_VAR 0 3
19897: PPUSH
19898: LD_INT 2
19900: PPUSH
19901: CALL_OW 275
19905: ADD
19906: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19907: LD_ADDR_VAR 0 4
19911: PUSH
19912: LD_VAR 0 4
19916: PUSH
19917: LD_VAR 0 3
19921: PPUSH
19922: LD_INT 3
19924: PPUSH
19925: CALL_OW 275
19929: ADD
19930: ST_TO_ADDR
// result := sor ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_VAR 0 4
19940: ST_TO_ADDR
// end ;
19941: LD_VAR 0 2
19945: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19946: LD_INT 0
19948: PPUSH
19949: PPUSH
// while ( coord_list ) do
19950: LD_VAR 0 3
19954: IFFALSE 20128
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19956: LD_ADDR_EXP 46
19960: PUSH
19961: LD_EXP 46
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_VAR 0 3
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 3
20001: ARRAY
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PPUSH
20008: CALL 41960 0 4
20012: ST_TO_ADDR
// if weapon_list then
20013: LD_VAR 0 4
20017: IFFALSE 20088
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20019: LD_ADDR_EXP 43
20023: PUSH
20024: LD_EXP 43
20028: PPUSH
20029: LD_VAR 0 1
20033: PPUSH
20034: LD_VAR 0 4
20038: PUSH
20039: LD_INT 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 3
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_VAR 0 3
20056: PUSH
20057: LD_INT 2
20059: ARRAY
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL 41960 0 4
20069: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20070: LD_ADDR_VAR 0 4
20074: PUSH
20075: LD_VAR 0 4
20079: PPUSH
20080: LD_INT 1
20082: PPUSH
20083: CALL_OW 3
20087: ST_TO_ADDR
// end ; for i = 1 to 3 do
20088: LD_ADDR_VAR 0 6
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20124
// coord_list := Delete ( coord_list , 1 ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_VAR 0 3
20113: PPUSH
20114: LD_INT 1
20116: PPUSH
20117: CALL_OW 3
20121: ST_TO_ADDR
20122: GO 20101
20124: POP
20125: POP
// end ;
20126: GO 19950
// result := true ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// end ;
20136: LD_VAR 0 5
20140: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20141: LD_INT 0
20143: PPUSH
20144: PPUSH
// if not weapon_list then
20145: LD_VAR 0 3
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20269
// while ( coord_list ) do
20154: LD_VAR 0 2
20158: IFFALSE 20269
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20160: LD_ADDR_EXP 43
20164: PUSH
20165: LD_EXP 43
20169: PPUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 1
20182: ARRAY
20183: PPUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: PUSH
20193: LD_VAR 0 2
20197: PUSH
20198: LD_INT 2
20200: ARRAY
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL 41960 0 4
20210: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_VAR 0 3
20220: PPUSH
20221: LD_INT 1
20223: PPUSH
20224: CALL_OW 3
20228: ST_TO_ADDR
// for i = 1 to 2 do
20229: LD_ADDR_VAR 0 5
20233: PUSH
20234: DOUBLE
20235: LD_INT 1
20237: DEC
20238: ST_TO_ADDR
20239: LD_INT 2
20241: PUSH
20242: FOR_TO
20243: IFFALSE 20265
// coord_list := Delete ( coord_list , 1 ) ;
20245: LD_ADDR_VAR 0 2
20249: PUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: LD_INT 1
20257: PPUSH
20258: CALL_OW 3
20262: ST_TO_ADDR
20263: GO 20242
20265: POP
20266: POP
// end ;
20267: GO 20154
// end ;
20269: LD_VAR 0 4
20273: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// while ( coord_list ) do
20278: LD_VAR 0 2
20282: IFFALSE 20437
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: PPUSH
20293: LD_VAR 0 2
20297: PUSH
20298: LD_INT 2
20300: ARRAY
20301: PPUSH
20302: CALL_OW 428
20306: IFFALSE 20397
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 2
20321: PUSH
20322: LD_INT 2
20324: ARRAY
20325: PPUSH
20326: CALL_OW 428
20330: PPUSH
20331: CALL_OW 266
20335: PUSH
20336: LD_INT 31
20338: PUSH
20339: LD_INT 32
20341: PUSH
20342: LD_INT 33
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: LIST
20349: IN
20350: IFFALSE 20397
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20352: LD_ADDR_EXP 52
20356: PUSH
20357: LD_EXP 52
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: LD_VAR 0 2
20371: PUSH
20372: LD_INT 1
20374: ARRAY
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 2
20383: ARRAY
20384: PPUSH
20385: CALL_OW 428
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL 41960 0 4
20396: ST_TO_ADDR
// for i = 1 to 3 do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_INT 3
20409: PUSH
20410: FOR_TO
20411: IFFALSE 20433
// coord_list := Delete ( coord_list , 1 ) ;
20413: LD_ADDR_VAR 0 2
20417: PUSH
20418: LD_VAR 0 2
20422: PPUSH
20423: LD_INT 1
20425: PPUSH
20426: CALL_OW 3
20430: ST_TO_ADDR
20431: GO 20410
20433: POP
20434: POP
// end ;
20435: GO 20278
// result := true ;
20437: LD_ADDR_VAR 0 3
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 3
20449: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20450: LD_INT 0
20452: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20453: LD_ADDR_EXP 46
20457: PUSH
20458: LD_EXP 46
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_INT 0
20470: PPUSH
20471: LD_VAR 0 2
20475: PPUSH
20476: CALL 41960 0 4
20480: ST_TO_ADDR
// end ;
20481: LD_VAR 0 3
20485: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20486: LD_INT 0
20488: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20489: LD_ADDR_EXP 46
20493: PUSH
20494: LD_EXP 46
20498: PPUSH
20499: LD_VAR 0 1
20503: PPUSH
20504: LD_INT 6
20506: PPUSH
20507: LD_VAR 0 2
20511: PPUSH
20512: CALL 41960 0 4
20516: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20517: LD_ADDR_EXP 49
20521: PUSH
20522: LD_EXP 49
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 3
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL 41960 0 4
20554: ST_TO_ADDR
// end ;
20555: LD_VAR 0 4
20559: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// if ext_list > 5 then
20564: LD_VAR 0 3
20568: PUSH
20569: LD_INT 5
20571: GREATER
20572: IFFALSE 20616
// for i = 6 to ext_list do
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: DOUBLE
20580: LD_INT 6
20582: DEC
20583: ST_TO_ADDR
20584: LD_VAR 0 3
20588: PUSH
20589: FOR_TO
20590: IFFALSE 20614
// ext_list := Delete ( ext_list , ext_list ) ;
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: CALL_OW 3
20611: ST_TO_ADDR
20612: GO 20589
20614: POP
20615: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 3
20652: PPUSH
20653: CALL 9163 0 5
// end ;
20657: LD_VAR 0 4
20661: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
// p := 1 ;
20667: LD_ADDR_VAR 0 6
20671: PUSH
20672: LD_INT 1
20674: ST_TO_ADDR
// if type_list = [ ] then
20675: LD_VAR 0 3
20679: PUSH
20680: EMPTY
20681: EQUAL
20682: IFFALSE 20692
// type_list := b_oil_power ;
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 26
20691: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20692: LD_ADDR_VAR 0 5
20696: PUSH
20697: DOUBLE
20698: LD_INT 1
20700: DEC
20701: ST_TO_ADDR
20702: LD_VAR 0 2
20706: PUSH
20707: LD_INT 3
20709: DIVREAL
20710: PUSH
20711: FOR_TO
20712: IFFALSE 20815
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20714: LD_ADDR_EXP 46
20718: PUSH
20719: LD_EXP 46
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_VAR 0 3
20733: PUSH
20734: LD_INT 1
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 12
20746: ARRAY
20747: PPUSH
20748: LD_VAR 0 2
20752: PUSH
20753: LD_VAR 0 6
20757: ARRAY
20758: PUSH
20759: LD_VAR 0 2
20763: PUSH
20764: LD_VAR 0 6
20768: PUSH
20769: LD_INT 1
20771: PLUS
20772: ARRAY
20773: PUSH
20774: LD_VAR 0 2
20778: PUSH
20779: LD_VAR 0 6
20783: PUSH
20784: LD_INT 2
20786: PLUS
20787: ARRAY
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 41960 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_VAR 0 6
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20711
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 4
20821: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
// if not MREG_Deposit [ side ] then
20828: LD_EXP 61
20832: PUSH
20833: LD_VAR 0 1
20837: ARRAY
20838: NOT
20839: IFFALSE 20843
// exit ;
20841: GO 21020
// p := 1 ;
20843: LD_ADDR_VAR 0 4
20847: PUSH
20848: LD_INT 1
20850: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20851: LD_ADDR_VAR 0 3
20855: PUSH
20856: DOUBLE
20857: LD_INT 1
20859: DEC
20860: ST_TO_ADDR
20861: LD_EXP 61
20865: PUSH
20866: LD_VAR 0 1
20870: ARRAY
20871: PUSH
20872: LD_INT 3
20874: DIVREAL
20875: PUSH
20876: FOR_TO
20877: IFFALSE 21018
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20879: LD_EXP 61
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: PUSH
20895: LD_INT 2
20897: PLUS
20898: ARRAY
20899: PUSH
20900: LD_INT 2
20902: EQUAL
20903: IFFALSE 20915
// b := b_oil_mine else
20905: LD_ADDR_VAR 0 5
20909: PUSH
20910: LD_INT 29
20912: ST_TO_ADDR
20913: GO 20923
// b := b_siberite_mine ;
20915: LD_ADDR_VAR 0 5
20919: PUSH
20920: LD_INT 30
20922: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: LD_EXP 61
20947: PUSH
20948: LD_VAR 0 1
20952: ARRAY
20953: PUSH
20954: LD_VAR 0 4
20958: ARRAY
20959: PUSH
20960: LD_EXP 61
20964: PUSH
20965: LD_VAR 0 1
20969: ARRAY
20970: PUSH
20971: LD_VAR 0 4
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: ARRAY
20980: PUSH
20981: LD_INT 0
20983: PPUSH
20984: LD_INT 5
20986: PPUSH
20987: CALL_OW 12
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL 41960 0 4
21001: ST_TO_ADDR
// p := p + 3 ;
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: LD_VAR 0 4
21011: PUSH
21012: LD_INT 3
21014: PLUS
21015: ST_TO_ADDR
// end ;
21016: GO 20876
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 2
21024: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21025: LD_INT 0
21027: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21028: LD_ADDR_EXP 46
21032: PUSH
21033: LD_EXP 46
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 4
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: CALL 41960 0 4
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21061: LD_INT 0
21063: PPUSH
// case nation of 1 , us :
21064: LD_VAR 0 2
21068: PUSH
21069: LD_INT 1
21071: DOUBLE
21072: EQUAL
21073: IFTRUE 21083
21075: LD_STRING us
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21114
21083: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21084: LD_ADDR_EXP 46
21088: PUSH
21089: LD_EXP 46
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: LD_INT 36
21101: PPUSH
21102: LD_VAR 0 3
21106: PPUSH
21107: CALL 41960 0 4
21111: ST_TO_ADDR
21112: GO 21165
21114: LD_INT 2
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21128
21120: LD_STRING ar
21122: DOUBLE
21123: EQUAL
21124: IFTRUE 21128
21126: GO 21164
21128: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21129: LD_ADDR_EXP 46
21133: PUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 14
21141: PUSH
21142: LD_INT 2
21144: PUSH
21145: LD_INT 1
21147: PUSH
21148: LD_INT 31
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL 21170 0 2
21161: ST_TO_ADDR
21162: GO 21165
21164: POP
// end ;
21165: LD_VAR 0 4
21169: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21170: LD_INT 0
21172: PPUSH
21173: PPUSH
// for i = 1 to list do
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: DOUBLE
21180: LD_INT 1
21182: DEC
21183: ST_TO_ADDR
21184: LD_VAR 0 2
21188: PUSH
21189: FOR_TO
21190: IFFALSE 21240
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21192: LD_ADDR_EXP 51
21196: PUSH
21197: LD_EXP 51
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_EXP 51
21211: PUSH
21212: LD_VAR 0 1
21216: ARRAY
21217: PUSH
21218: LD_INT 1
21220: PLUS
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_VAR 0 4
21231: ARRAY
21232: PPUSH
21233: CALL 31130 0 4
21237: ST_TO_ADDR
21238: GO 21189
21240: POP
21241: POP
// end ;
21242: LD_VAR 0 3
21246: RET
// export function MCS_GetVehicleList ( side ) ; begin
21247: LD_INT 0
21249: PPUSH
// result := MREG_ToConstruct [ side ] ;
21250: LD_ADDR_VAR 0 2
21254: PUSH
21255: LD_EXP 51
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: ST_TO_ADDR
// end ;
21266: LD_VAR 0 2
21270: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21271: LD_INT 0
21273: PPUSH
21274: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21275: LD_ADDR_EXP 58
21279: PUSH
21280: LD_EXP 58
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: LD_VAR 0 2
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// end ;
21300: LD_VAR 0 3
21304: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21305: LD_INT 0
21307: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21308: LD_ADDR_EXP 37
21312: PUSH
21313: LD_EXP 37
21317: PPUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// end ;
21333: LD_VAR 0 3
21337: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21338: LD_INT 0
21340: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21341: LD_ADDR_EXP 38
21345: PUSH
21346: LD_EXP 38
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 3
21370: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21374: LD_ADDR_EXP 60
21378: PUSH
21379: LD_EXP 60
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL 31130 0 4
21401: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21402: LD_ADDR_EXP 60
21406: PUSH
21407: LD_EXP 60
21411: PPUSH
21412: LD_VAR 0 1
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: LD_VAR 0 3
21424: PPUSH
21425: CALL 31130 0 4
21429: ST_TO_ADDR
// end ;
21430: LD_VAR 0 4
21434: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21435: LD_INT 0
21437: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21438: LD_ADDR_EXP 72
21442: PUSH
21443: LD_EXP 72
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21461: LD_ADDR_EXP 72
21465: PUSH
21466: LD_EXP 72
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: LD_VAR 0 2
21478: PPUSH
21479: CALL_OW 1
21483: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21484: LD_ADDR_EXP 72
21488: PUSH
21489: LD_EXP 72
21493: PPUSH
21494: LD_INT 3
21496: PPUSH
21497: LD_VAR 0 3
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// end ;
21507: LD_VAR 0 4
21511: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
// if not side or not list then
21517: LD_VAR 0 1
21521: NOT
21522: PUSH
21523: LD_VAR 0 2
21527: NOT
21528: OR
21529: IFFALSE 21533
// exit ;
21531: GO 21701
// SetTech ( 20 , side , state_researched ) ;
21533: LD_INT 20
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_INT 2
21543: PPUSH
21544: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21548: LD_ADDR_EXP 61
21552: PUSH
21553: LD_EXP 61
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: CALL_OW 2
21572: ST_TO_ADDR
// p := 1 ;
21573: LD_ADDR_VAR 0 5
21577: PUSH
21578: LD_INT 1
21580: ST_TO_ADDR
// for i = 1 to list / 3 do
21581: LD_ADDR_VAR 0 4
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_VAR 0 2
21595: PUSH
21596: LD_INT 3
21598: DIVREAL
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21699
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21603: LD_VAR 0 2
21607: PUSH
21608: LD_VAR 0 5
21612: ARRAY
21613: PPUSH
21614: LD_VAR 0 2
21618: PUSH
21619: LD_VAR 0 5
21623: PUSH
21624: LD_INT 1
21626: PLUS
21627: ARRAY
21628: PPUSH
21629: LD_VAR 0 2
21633: PUSH
21634: LD_VAR 0 5
21638: PUSH
21639: LD_INT 2
21641: PLUS
21642: ARRAY
21643: PPUSH
21644: CALL 22403 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21648: LD_VAR 0 2
21652: PUSH
21653: LD_VAR 0 5
21657: ARRAY
21658: PPUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 5
21668: PUSH
21669: LD_INT 1
21671: PLUS
21672: ARRAY
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL_OW 441
// p := p + 3 ;
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: PLUS
21696: ST_TO_ADDR
// end ;
21697: GO 21600
21699: POP
21700: POP
// end ;
21701: LD_VAR 0 3
21705: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
// if nat = nation_arabian then
21710: LD_VAR 0 2
21714: PUSH
21715: LD_INT 2
21717: EQUAL
21718: IFFALSE 21724
// exit else
21720: GO 21796
21722: GO 21782
// if nat = nation_american then
21724: LD_VAR 0 2
21728: PUSH
21729: LD_INT 1
21731: EQUAL
21732: IFFALSE 21759
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21734: LD_ADDR_VAR 0 4
21738: PUSH
21739: LD_INT 4
21741: PUSH
21742: LD_INT 3
21744: PUSH
21745: LD_INT 1
21747: PUSH
21748: LD_INT 8
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
21757: GO 21782
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21759: LD_ADDR_VAR 0 4
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 48
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21782: LD_VAR 0 1
21786: PPUSH
21787: LD_VAR 0 4
21791: PPUSH
21792: CALL 21170 0 2
// end ;
21796: LD_VAR 0 3
21800: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21801: LD_INT 0
21803: PPUSH
21804: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21805: LD_ADDR_EXP 63
21809: PUSH
21810: LD_EXP 63
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: LD_INT 1
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: CALL 31130 0 4
21832: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21833: LD_ADDR_EXP 64
21837: PUSH
21838: LD_EXP 64
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: LD_INT 1
21850: PPUSH
21851: LD_VAR 0 2
21855: PPUSH
21856: CALL 31130 0 4
21860: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21861: LD_ADDR_EXP 65
21865: PUSH
21866: LD_EXP 65
21870: PPUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_VAR 0 3
21883: PPUSH
21884: CALL 31130 0 4
21888: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21889: LD_ADDR_EXP 66
21893: PUSH
21894: LD_EXP 66
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_INT 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL 31130 0 4
21916: ST_TO_ADDR
// while squad do
21917: LD_VAR 0 5
21921: IFFALSE 22014
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_VAR 0 5
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PUSH
21937: LD_VAR 0 5
21941: PUSH
21942: LD_INT 2
21944: ARRAY
21945: PUSH
21946: LD_VAR 0 5
21950: PUSH
21951: LD_INT 3
21953: ARRAY
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: PPUSH
21970: CALL 21170 0 2
// for i = 1 to 4 do
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: DOUBLE
21980: LD_INT 1
21982: DEC
21983: ST_TO_ADDR
21984: LD_INT 4
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22010
// squad := Delete ( squad , 1 ) ;
21990: LD_ADDR_VAR 0 5
21994: PUSH
21995: LD_VAR 0 5
21999: PPUSH
22000: LD_INT 1
22002: PPUSH
22003: CALL_OW 3
22007: ST_TO_ADDR
22008: GO 21987
22010: POP
22011: POP
// end ;
22012: GO 21917
// end ;
22014: LD_VAR 0 6
22018: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22019: LD_INT 0
22021: PPUSH
22022: PPUSH
// for i = 1 to squad do
22023: LD_ADDR_VAR 0 4
22027: PUSH
22028: DOUBLE
22029: LD_INT 1
22031: DEC
22032: ST_TO_ADDR
22033: LD_VAR 0 2
22037: PUSH
22038: FOR_TO
22039: IFFALSE 22089
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22041: LD_ADDR_EXP 69
22045: PUSH
22046: LD_EXP 69
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_EXP 69
22060: PUSH
22061: LD_VAR 0 1
22065: ARRAY
22066: PUSH
22067: LD_INT 1
22069: PLUS
22070: PPUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 4
22080: ARRAY
22081: PPUSH
22082: CALL 31130 0 4
22086: ST_TO_ADDR
22087: GO 22038
22089: POP
22090: POP
// while squad do
22091: LD_VAR 0 2
22095: IFFALSE 22188
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22097: LD_VAR 0 1
22101: PPUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: PUSH
22111: LD_VAR 0 2
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PUSH
22120: LD_VAR 0 2
22124: PUSH
22125: LD_INT 3
22127: ARRAY
22128: PUSH
22129: LD_VAR 0 2
22133: PUSH
22134: LD_INT 4
22136: ARRAY
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL 21170 0 2
// for i = 1 to 4 do
22148: LD_ADDR_VAR 0 4
22152: PUSH
22153: DOUBLE
22154: LD_INT 1
22156: DEC
22157: ST_TO_ADDR
22158: LD_INT 4
22160: PUSH
22161: FOR_TO
22162: IFFALSE 22184
// squad := Delete ( squad , 1 ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_INT 1
22176: PPUSH
22177: CALL_OW 3
22181: ST_TO_ADDR
22182: GO 22161
22184: POP
22185: POP
// end ;
22186: GO 22091
// end ;
22188: LD_VAR 0 3
22192: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22193: LD_INT 0
22195: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22196: LD_ADDR_EXP 62
22200: PUSH
22201: LD_EXP 62
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 2
22218: PPUSH
22219: CALL 31130 0 4
22223: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22224: LD_ADDR_EXP 62
22228: PUSH
22229: LD_EXP 62
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: LD_VAR 0 3
22246: PPUSH
22247: CALL 31130 0 4
22251: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22252: LD_ADDR_EXP 62
22256: PUSH
22257: LD_EXP 62
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: LD_INT 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: CALL 31130 0 4
22279: ST_TO_ADDR
// end ; end_of_file
22280: LD_VAR 0 5
22284: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22285: LD_INT 0
22287: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22288: LD_ADDR_EXP 42
22292: PUSH
22293: LD_EXP 42
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_INT 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: CALL 31130 0 4
22315: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL 11786 0 2
22327: PUSH
22328: LD_INT 1
22330: ARRAY
22331: PPUSH
22332: CALL_OW 248
22336: PUSH
22337: LD_INT 1
22339: EQUAL
22340: IFFALSE 22371
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: PUSH
22356: LD_INT 14
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL 21170 0 2
22369: GO 22398
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 24
22378: PUSH
22379: LD_INT 1
22381: PUSH
22382: LD_INT 1
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: PPUSH
22394: CALL 21170 0 2
// end ;
22398: LD_VAR 0 3
22402: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22403: LD_INT 0
22405: PPUSH
// CreateDepositXY ( x , y , t ) ;
22406: LD_VAR 0 1
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: LD_VAR 0 3
22420: PPUSH
22421: CALL_OW 62
// end ;
22425: LD_VAR 0 4
22429: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22430: LD_INT 0
22432: PPUSH
22433: PPUSH
// c := 1 ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 1
22441: ST_TO_ADDR
// case color of red :
22442: LD_VAR 0 3
22446: PUSH
22447: LD_STRING red
22449: DOUBLE
22450: EQUAL
22451: IFTRUE 22455
22453: GO 22466
22455: POP
// c = 1 ; dark-green :
22456: LD_ADDR_VAR 0 5
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
22464: GO 22752
22466: LD_STRING dark-green
22468: DOUBLE
22469: EQUAL
22470: IFTRUE 22474
22472: GO 22485
22474: POP
// c = 2 ; purple :
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
22483: GO 22752
22485: LD_STRING purple
22487: DOUBLE
22488: EQUAL
22489: IFTRUE 22493
22491: GO 22504
22493: POP
// c = 3 ; aqua :
22494: LD_ADDR_VAR 0 5
22498: PUSH
22499: LD_INT 3
22501: ST_TO_ADDR
22502: GO 22752
22504: LD_STRING aqua
22506: DOUBLE
22507: EQUAL
22508: IFTRUE 22512
22510: GO 22523
22512: POP
// c = 4 ; grey :
22513: LD_ADDR_VAR 0 5
22517: PUSH
22518: LD_INT 4
22520: ST_TO_ADDR
22521: GO 22752
22523: LD_STRING grey
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22542
22531: POP
// c = 5 ; lime :
22532: LD_ADDR_VAR 0 5
22536: PUSH
22537: LD_INT 5
22539: ST_TO_ADDR
22540: GO 22752
22542: LD_STRING lime
22544: DOUBLE
22545: EQUAL
22546: IFTRUE 22550
22548: GO 22561
22550: POP
// c = 6 ; tan :
22551: LD_ADDR_VAR 0 5
22555: PUSH
22556: LD_INT 6
22558: ST_TO_ADDR
22559: GO 22752
22561: LD_STRING tan
22563: DOUBLE
22564: EQUAL
22565: IFTRUE 22569
22567: GO 22580
22569: POP
// c = 7 ; pink :
22570: LD_ADDR_VAR 0 5
22574: PUSH
22575: LD_INT 7
22577: ST_TO_ADDR
22578: GO 22752
22580: LD_STRING pink
22582: DOUBLE
22583: EQUAL
22584: IFTRUE 22588
22586: GO 22599
22588: POP
// c = 8 ; green :
22589: LD_ADDR_VAR 0 5
22593: PUSH
22594: LD_INT 8
22596: ST_TO_ADDR
22597: GO 22752
22599: LD_STRING green
22601: DOUBLE
22602: EQUAL
22603: IFTRUE 22607
22605: GO 22618
22607: POP
// c = 9 ; blue :
22608: LD_ADDR_VAR 0 5
22612: PUSH
22613: LD_INT 9
22615: ST_TO_ADDR
22616: GO 22752
22618: LD_STRING blue
22620: DOUBLE
22621: EQUAL
22622: IFTRUE 22626
22624: GO 22637
22626: POP
// c = 10 ; yellow :
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_INT 10
22634: ST_TO_ADDR
22635: GO 22752
22637: LD_STRING yellow
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22656
22645: POP
// c = 11 ; brown :
22646: LD_ADDR_VAR 0 5
22650: PUSH
22651: LD_INT 11
22653: ST_TO_ADDR
22654: GO 22752
22656: LD_STRING brown
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22675
22664: POP
// c = 12 ; black :
22665: LD_ADDR_VAR 0 5
22669: PUSH
22670: LD_INT 12
22672: ST_TO_ADDR
22673: GO 22752
22675: LD_STRING black
22677: DOUBLE
22678: EQUAL
22679: IFTRUE 22683
22681: GO 22694
22683: POP
// c = 13 ; aqua2 :
22684: LD_ADDR_VAR 0 5
22688: PUSH
22689: LD_INT 13
22691: ST_TO_ADDR
22692: GO 22752
22694: LD_STRING aqua2
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22713
22702: POP
// c = 14 ; orange :
22703: LD_ADDR_VAR 0 5
22707: PUSH
22708: LD_INT 14
22710: ST_TO_ADDR
22711: GO 22752
22713: LD_STRING orange
22715: DOUBLE
22716: EQUAL
22717: IFTRUE 22721
22719: GO 22732
22721: POP
// c = 15 ; white :
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 15
22729: ST_TO_ADDR
22730: GO 22752
22732: LD_STRING white
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22751
22740: POP
// c = 16 ; end ;
22741: LD_ADDR_VAR 0 5
22745: PUSH
22746: LD_INT 16
22748: ST_TO_ADDR
22749: GO 22752
22751: POP
// if HexInfo ( x , y ) = 0 then
22752: LD_VAR 0 1
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: CALL_OW 428
22766: PUSH
22767: LD_INT 0
22769: EQUAL
22770: IFFALSE 22794
// PlaceEnvironment ( x , y , 58 , c ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: LD_INT 58
22784: PPUSH
22785: LD_VAR 0 5
22789: PPUSH
22790: CALL_OW 349
// end ;
22794: LD_VAR 0 4
22798: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22799: LD_INT 0
22801: PPUSH
// RemoveEnvironment ( x , y ) ;
22802: LD_VAR 0 1
22806: PPUSH
22807: LD_VAR 0 2
22811: PPUSH
22812: CALL_OW 347
// end ;
22816: LD_VAR 0 3
22820: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22821: LD_INT 0
22823: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22824: LD_ADDR_VAR 0 5
22828: PUSH
22829: LD_INT 81
22831: PUSH
22832: LD_VAR 0 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 92
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: LD_VAR 0 3
22853: PUSH
22854: LD_VAR 0 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PPUSH
22869: CALL_OW 69
22873: ST_TO_ADDR
// end ;
22874: LD_VAR 0 5
22878: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22879: LD_INT 0
22881: PPUSH
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22886: LD_VAR 0 1
22890: PPUSH
22891: LD_INT 81
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 255
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PPUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 74
22922: PPUSH
22923: CALL_OW 119
// dir := GetDir ( un ) ;
22927: LD_ADDR_VAR 0 4
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: CALL_OW 254
22941: ST_TO_ADDR
// dir := dir - 3 ;
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: LD_VAR 0 4
22951: PUSH
22952: LD_INT 3
22954: MINUS
22955: ST_TO_ADDR
// if dir < 0 then
22956: LD_VAR 0 4
22960: PUSH
22961: LD_INT 0
22963: LESS
22964: IFFALSE 22980
// dir := dir + 6 ;
22966: LD_ADDR_VAR 0 4
22970: PUSH
22971: LD_VAR 0 4
22975: PUSH
22976: LD_INT 6
22978: PLUS
22979: ST_TO_ADDR
// while true do
22980: LD_INT 1
22982: IFFALSE 23479
// begin coord_dist := 3 ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 3
22991: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: LD_VAR 0 3
23016: PPUSH
23017: CALL_OW 272
23021: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23022: LD_ADDR_VAR 0 6
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 251
23036: PPUSH
23037: LD_VAR 0 4
23041: PPUSH
23042: LD_VAR 0 3
23046: PPUSH
23047: CALL_OW 273
23051: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23052: LD_VAR 0 1
23056: PPUSH
23057: CALL_OW 255
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: CALL_OW 250
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 251
23081: PPUSH
23082: LD_INT 14
23084: PPUSH
23085: CALL 22821 0 4
23089: PUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: LD_VAR 0 6
23099: PPUSH
23100: CALL_OW 351
23104: OR
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 488
23120: PUSH
23121: LD_INT 0
23123: EQUAL
23124: OR
23125: PUSH
23126: LD_VAR 0 5
23130: PPUSH
23131: LD_VAR 0 6
23135: PPUSH
23136: CALL_OW 546
23140: PUSH
23141: LD_INT 1
23143: EQUAL
23144: OR
23145: PUSH
23146: LD_VAR 0 5
23150: PPUSH
23151: LD_VAR 0 6
23155: PPUSH
23156: CALL_OW 428
23160: PUSH
23161: LD_INT 0
23163: NONEQUAL
23164: OR
23165: IFFALSE 23393
// begin repeat begin Wait ( 0 0$0.3 ) ;
23167: LD_INT 10
23169: PPUSH
23170: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: LD_VAR 0 3
23183: PUSH
23184: LD_INT 1
23186: PLUS
23187: ST_TO_ADDR
// dir := dir + 1 ;
23188: LD_ADDR_VAR 0 4
23192: PUSH
23193: LD_VAR 0 4
23197: PUSH
23198: LD_INT 1
23200: PLUS
23201: ST_TO_ADDR
// if dir > 5 then
23202: LD_VAR 0 4
23206: PUSH
23207: LD_INT 5
23209: GREATER
23210: IFFALSE 23220
// dir = 0 ;
23212: LD_ADDR_VAR 0 4
23216: PUSH
23217: LD_INT 0
23219: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23220: LD_ADDR_VAR 0 5
23224: PUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: CALL_OW 250
23234: PPUSH
23235: LD_VAR 0 4
23239: PPUSH
23240: LD_VAR 0 3
23244: PPUSH
23245: CALL_OW 272
23249: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23250: LD_ADDR_VAR 0 6
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 251
23264: PPUSH
23265: LD_VAR 0 4
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: CALL_OW 273
23279: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 255
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: CALL_OW 250
23299: PPUSH
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 251
23309: PPUSH
23310: LD_INT 14
23312: PPUSH
23313: CALL 22821 0 4
23317: NOT
23318: PUSH
23319: LD_VAR 0 5
23323: PPUSH
23324: LD_VAR 0 6
23328: PPUSH
23329: CALL_OW 351
23333: NOT
23334: AND
23335: PUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 488
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 546
23366: PUSH
23367: LD_INT 0
23369: EQUAL
23370: AND
23371: PUSH
23372: LD_VAR 0 5
23376: PPUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 428
23386: PUSH
23387: LD_INT 0
23389: EQUAL
23390: AND
23391: IFFALSE 23167
// end ; ComMoveXY ( un , x , y ) ;
23393: LD_VAR 0 1
23397: PPUSH
23398: LD_VAR 0 5
23402: PPUSH
23403: LD_VAR 0 6
23407: PPUSH
23408: CALL_OW 111
// Wait ( 0 0$1 ) ;
23412: LD_INT 35
23414: PPUSH
23415: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23419: LD_VAR 0 1
23423: PPUSH
23424: LD_INT 81
23426: PUSH
23427: LD_VAR 0 1
23431: PPUSH
23432: CALL_OW 255
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_VAR 0 1
23450: PPUSH
23451: CALL_OW 74
23455: PPUSH
23456: CALL_OW 296
23460: PUSH
23461: LD_INT 14
23463: GREATEREQUAL
23464: IFFALSE 23477
// begin ComStop ( un ) ;
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 141
// break ;
23475: GO 23479
// end ; end ;
23477: GO 22980
// end ;
23479: LD_VAR 0 2
23483: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// x := GetX ( unit ) ;
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 250
23508: ST_TO_ADDR
// y := GetY ( unit ) ;
23509: LD_ADDR_VAR 0 4
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 251
23523: ST_TO_ADDR
// i := 0 ;
23524: LD_ADDR_VAR 0 8
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 81
23539: PUSH
23540: LD_VAR 0 1
23544: PPUSH
23545: CALL_OW 255
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 69
23558: PPUSH
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 74
23568: PPUSH
23569: CALL_OW 119
// dir := GetDir ( unit ) ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: CALL_OW 254
23587: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23588: LD_ADDR_VAR 0 9
23592: PUSH
23593: LD_INT 0
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 12
23603: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23604: LD_INT 10
23606: PPUSH
23607: CALL_OW 67
// if mode then
23611: LD_VAR 0 9
23615: IFFALSE 23633
// dir := dir + 1 else
23617: LD_ADDR_VAR 0 7
23621: PUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_INT 1
23629: PLUS
23630: ST_TO_ADDR
23631: GO 23647
// dir := dir - 1 ;
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: MINUS
23646: ST_TO_ADDR
// if ( dir < 0 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 0
23654: LESS
23655: IFFALSE 23665
// dir := 5 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 5
23664: ST_TO_ADDR
// if ( dir > 5 ) then
23665: LD_VAR 0 7
23669: PUSH
23670: LD_INT 5
23672: GREATER
23673: IFFALSE 23683
// dir := 0 ;
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: LD_INT 0
23682: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23683: LD_ADDR_VAR 0 5
23687: PUSH
23688: LD_VAR 0 3
23692: PPUSH
23693: LD_VAR 0 7
23697: PPUSH
23698: LD_INT 4
23700: PPUSH
23701: CALL_OW 272
23705: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23706: LD_ADDR_VAR 0 6
23710: PUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: LD_VAR 0 7
23720: PPUSH
23721: LD_INT 4
23723: PPUSH
23724: CALL_OW 273
23728: ST_TO_ADDR
// i := i + 1 ;
23729: LD_ADDR_VAR 0 8
23733: PUSH
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 1
23741: PLUS
23742: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23743: LD_VAR 0 1
23747: PPUSH
23748: CALL_OW 255
23752: PPUSH
23753: LD_VAR 0 5
23757: PPUSH
23758: LD_VAR 0 6
23762: PPUSH
23763: LD_INT 14
23765: PPUSH
23766: CALL 22821 0 4
23770: PUSH
23771: LD_INT 0
23773: EQUAL
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_VAR 0 6
23784: PPUSH
23785: CALL_OW 546
23789: PUSH
23790: LD_INT 0
23792: EQUAL
23793: AND
23794: PUSH
23795: LD_VAR 0 5
23799: PPUSH
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 428
23809: PUSH
23810: LD_INT 0
23812: EQUAL
23813: AND
23814: IFFALSE 23818
// break ;
23816: GO 23828
// end until i > 4 ;
23818: LD_VAR 0 8
23822: PUSH
23823: LD_INT 4
23825: GREATER
23826: IFFALSE 23604
// if x2 and y2 then
23828: LD_VAR 0 5
23832: PUSH
23833: LD_VAR 0 6
23837: AND
23838: IFFALSE 23861
// result := [ x2 , y2 ] else
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 5
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: ST_TO_ADDR
23859: GO 23890
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 250
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: CALL_OW 251
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// end ;
23890: LD_VAR 0 2
23894: RET
// export function MCT_Hex ( x , y ) ; begin
23895: LD_INT 0
23897: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL_OW 546
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 428
23932: PUSH
23933: EMPTY
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 3
23944: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23960: LD_ADDR_VAR 0 10
23964: PUSH
23965: LD_EXP 60
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PUSH
23976: LD_INT 1
23978: ARRAY
23979: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: LD_EXP 60
23989: PUSH
23990: LD_VAR 0 1
23994: ARRAY
23995: PUSH
23996: LD_INT 2
23998: ARRAY
23999: ST_TO_ADDR
// collectors := [ ] ;
24000: LD_ADDR_VAR 0 12
24004: PUSH
24005: EMPTY
24006: ST_TO_ADDR
// is_cargo := false ;
24007: LD_ADDR_VAR 0 13
24011: PUSH
24012: LD_INT 0
24014: ST_TO_ADDR
// if isTest then
24015: LD_EXP 1
24019: IFFALSE 24025
// TimerStart ( ) ;
24021: CALL_OW 548
// if MCF_Cargo ( side ) then
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL 12002 0 1
24034: IFFALSE 24061
// begin collectors := MCF_Cargo ( side ) ;
24036: LD_ADDR_VAR 0 12
24040: PUSH
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12002 0 1
24050: ST_TO_ADDR
// is_cargo := true ;
24051: LD_ADDR_VAR 0 13
24055: PUSH
24056: LD_INT 1
24058: ST_TO_ADDR
// end else
24059: GO 24210
// begin if MCF_ApeSpec ( side , engineer ) then
24061: LD_VAR 0 1
24065: PPUSH
24066: LD_STRING engineer
24068: PPUSH
24069: CALL 12148 0 2
24073: IFFALSE 24093
// collectors := MCF_ApeSpec ( side , engineer ) ;
24075: LD_ADDR_VAR 0 12
24079: PUSH
24080: LD_VAR 0 1
24084: PPUSH
24085: LD_STRING engineer
24087: PPUSH
24088: CALL 12148 0 2
24092: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24093: LD_VAR 0 1
24097: PPUSH
24098: LD_INT 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL 11734 0 3
24107: IFFALSE 24210
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL 11734 0 3
24128: ST_TO_ADDR
// if z > 5 then
24129: LD_VAR 0 7
24133: PUSH
24134: LD_INT 5
24136: GREATER
24137: IFFALSE 24149
// t1 := 5 else
24139: LD_ADDR_VAR 0 8
24143: PUSH
24144: LD_INT 5
24146: ST_TO_ADDR
24147: GO 24159
// t1 := z ;
24149: LD_ADDR_VAR 0 8
24153: PUSH
24154: LD_VAR 0 7
24158: ST_TO_ADDR
// for t2 = 1 to t1 do
24159: LD_ADDR_VAR 0 9
24163: PUSH
24164: DOUBLE
24165: LD_INT 1
24167: DEC
24168: ST_TO_ADDR
24169: LD_VAR 0 8
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24208
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24177: LD_ADDR_VAR 0 12
24181: PUSH
24182: LD_VAR 0 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: LD_VAR 0 7
24194: PUSH
24195: LD_VAR 0 9
24199: ARRAY
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
24206: GO 24174
24208: POP
24209: POP
// end ; end ; if not mode then
24210: LD_VAR 0 10
24214: NOT
24215: IFFALSE 24221
// exit else
24217: GO 24480
24219: GO 24480
// begin if collectors then
24221: LD_VAR 0 12
24225: IFFALSE 24480
// for i in areas do
24227: LD_ADDR_VAR 0 3
24231: PUSH
24232: LD_VAR 0 11
24236: PUSH
24237: FOR_IN
24238: IFFALSE 24478
// if GetListOfCratesInArea ( i ) then
24240: LD_VAR 0 3
24244: PPUSH
24245: CALL_OW 435
24249: IFFALSE 24476
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24251: LD_ADDR_VAR 0 5
24255: PUSH
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24270: LD_ADDR_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: PPUSH
24280: CALL_OW 435
24284: PUSH
24285: LD_INT 2
24287: ARRAY
24288: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24289: LD_VAR 0 13
24293: PUSH
24294: LD_VAR 0 12
24298: PUSH
24299: LD_INT 1
24301: ARRAY
24302: PPUSH
24303: CALL_OW 110
24307: PUSH
24308: LD_INT 0
24310: EQUAL
24311: AND
24312: IFFALSE 24374
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24314: LD_VAR 0 12
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 314
24327: NOT
24328: PUSH
24329: LD_VAR 0 12
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: CALL_OW 110
24342: PUSH
24343: LD_INT 0
24345: EQUAL
24346: AND
24347: IFFALSE 24372
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24349: LD_VAR 0 12
24353: PUSH
24354: LD_INT 1
24356: ARRAY
24357: PPUSH
24358: LD_VAR 0 5
24362: PPUSH
24363: LD_VAR 0 6
24367: PPUSH
24368: CALL_OW 117
// end ; end else
24372: GO 24460
// begin for j = 1 to collectors do
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: DOUBLE
24380: LD_INT 1
24382: DEC
24383: ST_TO_ADDR
24384: LD_VAR 0 12
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24458
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24392: LD_VAR 0 12
24396: PUSH
24397: LD_VAR 0 4
24401: ARRAY
24402: PPUSH
24403: CALL_OW 314
24407: NOT
24408: PUSH
24409: LD_VAR 0 12
24413: PUSH
24414: LD_VAR 0 4
24418: ARRAY
24419: PPUSH
24420: CALL_OW 110
24424: PUSH
24425: LD_INT 0
24427: EQUAL
24428: AND
24429: IFFALSE 24456
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24431: LD_VAR 0 12
24435: PUSH
24436: LD_VAR 0 4
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 5
24446: PPUSH
24447: LD_VAR 0 6
24451: PPUSH
24452: CALL 24851 0 3
// end ;
24456: GO 24389
24458: POP
24459: POP
// end ; if isTest then
24460: LD_EXP 1
24464: IFFALSE 24476
// begin debug_time := TimerEnd ( ) ;
24466: LD_ADDR_VAR 0 14
24470: PUSH
24471: CALL_OW 549
24475: ST_TO_ADDR
// end ; end ;
24476: GO 24237
24478: POP
24479: POP
// end ; end ;
24480: LD_VAR 0 2
24484: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24485: LD_INT 0
24487: PPUSH
24488: PPUSH
24489: PPUSH
24490: PPUSH
24491: PPUSH
24492: PPUSH
// if not area then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24504
// exit else
24500: GO 24766
24502: GO 24766
// if tick mod interval = 0 and Prob ( percent ) then
24504: LD_OWVAR 1
24508: PUSH
24509: LD_VAR 0 4
24513: MOD
24514: PUSH
24515: LD_INT 0
24517: EQUAL
24518: PUSH
24519: LD_VAR 0 3
24523: PPUSH
24524: CALL_OW 13
24528: AND
24529: IFFALSE 24766
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24531: LD_VAR 0 1
24535: PPUSH
24536: CALL_OW 435
24540: PUSH
24541: LD_VAR 0 5
24545: LESS
24546: PUSH
24547: LD_VAR 0 5
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: OR
24556: IFFALSE 24766
// begin Randomize ;
24558: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24562: LD_ADDR_VAR 0 7
24566: PUSH
24567: LD_INT 1
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 12
24579: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24580: LD_ADDR_VAR 0 9
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 517
24597: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24598: LD_ADDR_VAR 0 8
24602: PUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PUSH
24611: LD_INT 1
24613: ARRAY
24614: PPUSH
24615: CALL_OW 12
24619: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24620: LD_VAR 0 9
24624: PUSH
24625: LD_INT 1
24627: ARRAY
24628: PUSH
24629: LD_VAR 0 8
24633: ARRAY
24634: PPUSH
24635: LD_VAR 0 9
24639: PUSH
24640: LD_INT 2
24642: ARRAY
24643: PUSH
24644: LD_VAR 0 8
24648: ARRAY
24649: PPUSH
24650: CALL_OW 428
24654: PUSH
24655: LD_INT 0
24657: GREATER
24658: PUSH
24659: LD_VAR 0 9
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PUSH
24668: LD_VAR 0 8
24672: ARRAY
24673: PPUSH
24674: LD_VAR 0 9
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PUSH
24683: LD_VAR 0 8
24687: ARRAY
24688: PPUSH
24689: CALL_OW 284
24693: PUSH
24694: LD_INT 0
24696: GREATER
24697: AND
24698: IFFALSE 24724
// c := Rand ( 1 , tmp [ 1 ] ) ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 1
24707: PPUSH
24708: LD_VAR 0 9
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: CALL_OW 12
24721: ST_TO_ADDR
24722: GO 24620
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24724: LD_VAR 0 7
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PUSH
24738: LD_VAR 0 8
24742: ARRAY
24743: PPUSH
24744: LD_VAR 0 9
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PUSH
24753: LD_VAR 0 8
24757: ARRAY
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 54
// end ; end ; end ;
24766: LD_VAR 0 6
24770: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24771: LD_INT 0
24773: PPUSH
24774: PPUSH
// if not MREG_Crates then
24775: LD_EXP 34
24779: NOT
24780: IFFALSE 24784
// exit ;
24782: GO 24846
// for i = MREG_Crates downto 1 do
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: DOUBLE
24790: LD_EXP 34
24794: INC
24795: ST_TO_ADDR
24796: LD_INT 1
24798: PUSH
24799: FOR_DOWNTO
24800: IFFALSE 24844
// if MREG_Crates [ i ] [ 3 ] = 0 then
24802: LD_EXP 34
24806: PUSH
24807: LD_VAR 0 2
24811: ARRAY
24812: PUSH
24813: LD_INT 3
24815: ARRAY
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24842
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24822: LD_ADDR_EXP 34
24826: PUSH
24827: LD_EXP 34
24831: PPUSH
24832: LD_VAR 0 2
24836: PPUSH
24837: CALL_OW 3
24841: ST_TO_ADDR
24842: GO 24799
24844: POP
24845: POP
// end ;
24846: LD_VAR 0 1
24850: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not unit then
24857: LD_VAR 0 1
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25001
// if HasTask ( unit ) or not CanCarry ( unit ) then
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 314
24875: PUSH
24876: LD_VAR 0 1
24880: PPUSH
24881: CALL_OW 280
24885: NOT
24886: OR
24887: IFFALSE 24891
// exit ;
24889: GO 25001
// side := GetSide ( unit ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: CALL_OW 255
24905: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24906: LD_ADDR_VAR 0 7
24910: PUSH
24911: LD_VAR 0 6
24915: PPUSH
24916: LD_INT 30
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PPUSH
24926: CALL 11651 0 2
24930: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24931: LD_VAR 0 1
24935: PPUSH
24936: CALL_OW 281
24940: PUSH
24941: LD_VAR 0 7
24945: NOT
24946: OR
24947: IFFALSE 24953
// exit else
24949: GO 25001
24951: GO 25001
// if GetResourceAmountXY ( x , y ) then
24953: LD_VAR 0 2
24957: PPUSH
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 284
24967: IFFALSE 24999
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_VAR 0 2
24978: PPUSH
24979: LD_VAR 0 3
24983: PPUSH
24984: LD_VAR 0 7
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: CALL 32061 0 4
// end else
24997: GO 25001
// exit ;
24999: GO 25001
// end ;
25001: LD_VAR 0 4
25005: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25006: LD_INT 0
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
// result := [ ] ;
25013: LD_ADDR_VAR 0 2
25017: PUSH
25018: EMPTY
25019: ST_TO_ADDR
// p := 1 ;
25020: LD_ADDR_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_EXP 63
25042: PUSH
25043: LD_VAR 0 1
25047: ARRAY
25048: PUSH
25049: LD_INT 1
25051: ARRAY
25052: PUSH
25053: LD_INT 2
25055: DIVREAL
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25182
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25060: LD_ADDR_VAR 0 5
25064: PUSH
25065: LD_INT 81
25067: PUSH
25068: LD_VAR 0 1
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 92
25079: PUSH
25080: LD_EXP 63
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PUSH
25095: LD_VAR 0 4
25099: ARRAY
25100: PUSH
25101: LD_EXP 63
25105: PUSH
25106: LD_VAR 0 1
25110: ARRAY
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_INT 1
25123: PLUS
25124: ARRAY
25125: PUSH
25126: LD_INT 12
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: ST_TO_ADDR
// if tmp then
25144: LD_VAR 0 5
25148: IFFALSE 25166
// result := result union tmp ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_VAR 0 5
25164: UNION
25165: ST_TO_ADDR
// p := p + 2 ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 2
25178: PLUS
25179: ST_TO_ADDR
// end ;
25180: GO 25057
25182: POP
25183: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25184: LD_EXP 64
25188: PUSH
25189: LD_VAR 0 1
25193: ARRAY
25194: PPUSH
25195: LD_INT 81
25197: PUSH
25198: LD_VAR 0 1
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PPUSH
25207: CALL_OW 70
25211: IFFALSE 25252
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25213: LD_ADDR_VAR 0 2
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_EXP 64
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_INT 81
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PPUSH
25246: CALL_OW 70
25250: UNION
25251: ST_TO_ADDR
// end ; end_of_file
25252: LD_VAR 0 2
25256: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
// pom := GetBase ( fac ) ;
25262: LD_ADDR_VAR 0 5
25266: PUSH
25267: LD_VAR 0 1
25271: PPUSH
25272: CALL_OW 274
25276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25277: LD_ADDR_VAR 0 4
25281: PUSH
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: LD_VAR 0 2
25295: PUSH
25296: LD_INT 2
25298: ARRAY
25299: PPUSH
25300: LD_VAR 0 2
25304: PUSH
25305: LD_INT 3
25307: ARRAY
25308: PPUSH
25309: LD_VAR 0 2
25313: PUSH
25314: LD_INT 4
25316: ARRAY
25317: PPUSH
25318: CALL_OW 449
25322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25323: LD_ADDR_VAR 0 3
25327: PUSH
25328: LD_VAR 0 5
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: CALL_OW 275
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: GREATEREQUAL
25350: PUSH
25351: LD_VAR 0 5
25355: PPUSH
25356: LD_INT 2
25358: PPUSH
25359: CALL_OW 275
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_INT 2
25371: ARRAY
25372: GREATEREQUAL
25373: AND
25374: PUSH
25375: LD_VAR 0 5
25379: PPUSH
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 275
25387: PUSH
25388: LD_VAR 0 4
25392: PUSH
25393: LD_INT 3
25395: ARRAY
25396: GREATEREQUAL
25397: AND
25398: ST_TO_ADDR
// end ;
25399: LD_VAR 0 3
25403: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25404: LD_INT 0
25406: PPUSH
25407: PPUSH
25408: PPUSH
// result := false ;
25409: LD_ADDR_VAR 0 3
25413: PUSH
25414: LD_INT 0
25416: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25417: LD_ADDR_VAR 0 4
25421: PUSH
25422: LD_EXP 51
25426: PUSH
25427: LD_VAR 0 1
25431: ARRAY
25432: ST_TO_ADDR
// if tmp then
25433: LD_VAR 0 4
25437: IFFALSE 25491
// for i = 1 to tmp do
25439: LD_ADDR_VAR 0 5
25443: PUSH
25444: DOUBLE
25445: LD_INT 1
25447: DEC
25448: ST_TO_ADDR
25449: LD_VAR 0 4
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25489
// if component = tmp [ i ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 4
25466: PUSH
25467: LD_VAR 0 5
25471: ARRAY
25472: EQUAL
25473: IFFALSE 25487
// begin result := true ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_INT 1
25482: ST_TO_ADDR
// exit ;
25483: POP
25484: POP
25485: GO 25491
// end ;
25487: GO 25454
25489: POP
25490: POP
// end ;
25491: LD_VAR 0 3
25495: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25496: LD_INT 0
25498: PPUSH
25499: PPUSH
25500: PPUSH
// result := false ;
25501: LD_ADDR_VAR 0 4
25505: PUSH
25506: LD_INT 0
25508: ST_TO_ADDR
// if fac then
25509: LD_VAR 0 2
25513: IFFALSE 25736
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25515: LD_VAR 0 2
25519: PPUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL 25257 0 2
25529: PUSH
25530: LD_VAR 0 2
25534: PPUSH
25535: CALL_OW 461
25539: PUSH
25540: LD_INT 2
25542: EQUAL
25543: AND
25544: PUSH
25545: LD_VAR 0 2
25549: PPUSH
25550: LD_VAR 0 3
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 3
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: LD_VAR 0 3
25572: PUSH
25573: LD_INT 3
25575: ARRAY
25576: PPUSH
25577: LD_VAR 0 3
25581: PUSH
25582: LD_INT 4
25584: ARRAY
25585: PPUSH
25586: CALL_OW 448
25590: AND
25591: IFFALSE 25736
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25593: LD_VAR 0 2
25597: PPUSH
25598: LD_VAR 0 3
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 3
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_INT 3
25623: ARRAY
25624: PPUSH
25625: LD_VAR 0 3
25629: PUSH
25630: LD_INT 4
25632: ARRAY
25633: PPUSH
25634: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_EXP 51
25647: PUSH
25648: LD_VAR 0 1
25652: ARRAY
25653: ST_TO_ADDR
// for i = 4 downto 1 do
25654: LD_ADDR_VAR 0 5
25658: PUSH
25659: DOUBLE
25660: LD_INT 4
25662: INC
25663: ST_TO_ADDR
25664: LD_INT 1
25666: PUSH
25667: FOR_DOWNTO
25668: IFFALSE 25701
// tab := Remove ( tab , list [ i ] , true ) ;
25670: LD_ADDR_VAR 0 6
25674: PUSH
25675: LD_VAR 0 6
25679: PPUSH
25680: LD_VAR 0 3
25684: PUSH
25685: LD_VAR 0 5
25689: ARRAY
25690: PPUSH
25691: LD_INT 1
25693: PPUSH
25694: CALL 31289 0 3
25698: ST_TO_ADDR
25699: GO 25667
25701: POP
25702: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25703: LD_ADDR_EXP 51
25707: PUSH
25708: LD_EXP 51
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_VAR 0 6
25722: PPUSH
25723: CALL_OW 1
25727: ST_TO_ADDR
// result := true ;
25728: LD_ADDR_VAR 0 4
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// end ; end ; end ;
25736: LD_VAR 0 4
25740: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25741: LD_INT 0
25743: PPUSH
25744: PPUSH
// if not veh then
25745: LD_VAR 0 2
25749: NOT
25750: IFFALSE 25754
// exit ;
25752: GO 25928
// if MREG_Parking [ side ] then
25754: LD_EXP 58
25758: PUSH
25759: LD_VAR 0 1
25763: ARRAY
25764: IFFALSE 25928
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25766: LD_VAR 0 2
25770: PPUSH
25771: LD_EXP 58
25775: PUSH
25776: LD_VAR 0 1
25780: ARRAY
25781: PPUSH
25782: CALL_OW 308
25786: NOT
25787: IFFALSE 25928
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_EXP 58
25798: PUSH
25799: LD_VAR 0 1
25803: ARRAY
25804: PPUSH
25805: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25809: LD_VAR 0 2
25813: PPUSH
25814: CALL_OW 263
25818: PUSH
25819: LD_INT 1
25821: EQUAL
25822: IFFALSE 25928
// begin i := GetDriver ( veh ) ;
25824: LD_ADDR_VAR 0 4
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: CALL 31773 0 1
25838: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25846: LD_VAR 0 2
25850: PPUSH
25851: LD_EXP 58
25855: PUSH
25856: LD_VAR 0 1
25860: ARRAY
25861: PPUSH
25862: CALL_OW 308
25866: PUSH
25867: LD_VAR 0 2
25871: PPUSH
25872: CALL_OW 301
25876: OR
25877: IFFALSE 25839
// ComExitVehicle ( i ) ;
25879: LD_VAR 0 4
25883: PPUSH
25884: CALL_OW 121
// Wait ( 1 ) ;
25888: LD_INT 1
25890: PPUSH
25891: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL 11651 0 2
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PPUSH
25924: CALL_OW 180
// end ; end ; end ;
25928: LD_VAR 0 3
25932: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
25937: PPUSH
25938: PPUSH
25939: PPUSH
25940: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25941: LD_VAR 0 1
25945: PPUSH
25946: LD_INT 30
25948: PUSH
25949: LD_INT 3
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL 11651 0 2
25960: IFFALSE 26144
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25962: LD_VAR 0 1
25966: PPUSH
25967: LD_INT 30
25969: PUSH
25970: LD_INT 3
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL 11651 0 2
25981: PUSH
25982: LD_INT 1
25984: ARRAY
25985: PPUSH
25986: CALL_OW 461
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 26144
// begin for i = 1 to MREG_TurretWeapon do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_EXP 43
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26142
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26014: LD_EXP 43
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 1
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 1
26033: EQUAL
26034: IFFALSE 26140
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_EXP 43
26045: PUSH
26046: LD_VAR 0 3
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26056: LD_ADDR_VAR 0 6
26060: PUSH
26061: LD_EXP 43
26065: PUSH
26066: LD_VAR 0 3
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26080: LD_ADDR_VAR 0 7
26084: PUSH
26085: LD_EXP 43
26089: PUSH
26090: LD_VAR 0 3
26094: ARRAY
26095: PUSH
26096: LD_INT 3
26098: ARRAY
26099: PUSH
26100: LD_INT 2
26102: ARRAY
26103: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26104: LD_ADDR_VAR 0 4
26108: PUSH
26109: LD_VAR 0 6
26113: PPUSH
26114: LD_VAR 0 7
26118: PPUSH
26119: CALL_OW 428
26123: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26124: LD_VAR 0 4
26128: PPUSH
26129: LD_VAR 0 5
26133: PPUSH
26134: CALL_OW 148
// break ;
26138: GO 26142
// end ;
26140: GO 26011
26142: POP
26143: POP
// end ; end ;
26144: LD_VAR 0 2
26148: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26149: LD_INT 0
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_INT 32
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL 11651 0 2
26179: ST_TO_ADDR
// if not tmp then
26180: LD_VAR 0 4
26184: NOT
26185: IFFALSE 26191
// exit else
26187: GO 26273
26189: GO 26273
// begin for i = 1 to tmp do
26191: LD_ADDR_VAR 0 3
26195: PUSH
26196: DOUBLE
26197: LD_INT 1
26199: DEC
26200: ST_TO_ADDR
26201: LD_VAR 0 4
26205: PUSH
26206: FOR_TO
26207: IFFALSE 26271
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26209: LD_VAR 0 4
26213: PUSH
26214: LD_VAR 0 3
26218: ARRAY
26219: PPUSH
26220: CALL_OW 261
26224: PUSH
26225: LD_INT 20
26227: LESS
26228: PUSH
26229: LD_VAR 0 4
26233: PUSH
26234: LD_VAR 0 3
26238: ARRAY
26239: PPUSH
26240: CALL_OW 110
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: AND
26249: IFFALSE 26269
// begin SetTag ( tmp [ i ] , 21 ) ;
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 3
26260: ARRAY
26261: PPUSH
26262: LD_INT 21
26264: PPUSH
26265: CALL_OW 109
// end ;
26269: GO 26206
26271: POP
26272: POP
// end ; end ;
26273: LD_VAR 0 2
26277: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26278: LD_INT 0
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
26284: PPUSH
// if not unit then
26285: LD_VAR 0 1
26289: NOT
26290: IFFALSE 26294
// exit ;
26292: GO 26482
// side := GetSide ( unit ) ;
26294: LD_ADDR_VAR 0 3
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 255
26308: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26309: LD_ADDR_VAR 0 5
26313: PUSH
26314: LD_VAR 0 3
26318: PPUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 3
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 30
26344: PUSH
26345: LD_INT 29
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL 11651 0 2
26362: ST_TO_ADDR
// if not b then
26363: LD_VAR 0 5
26367: NOT
26368: IFFALSE 26372
// exit ;
26370: GO 26482
// if GetTag ( unit ) = 21 then
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 110
26381: PUSH
26382: LD_INT 21
26384: EQUAL
26385: IFFALSE 26482
// begin c := NearestUnitToUnit ( b , unit ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_VAR 0 5
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 74
26406: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26407: LD_VAR 0 1
26411: PPUSH
26412: LD_VAR 0 6
26416: PPUSH
26417: CALL_OW 250
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: CALL_OW 251
26431: PPUSH
26432: CALL_OW 297
26436: PUSH
26437: LD_INT 6
26439: GREATER
26440: IFFALSE 26458
// ComMoveUnit ( unit , c ) else
26442: LD_VAR 0 1
26446: PPUSH
26447: LD_VAR 0 6
26451: PPUSH
26452: CALL_OW 112
26456: GO 26482
// begin SetFuel ( unit , 100 ) ;
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_INT 100
26465: PPUSH
26466: CALL_OW 240
// SetTag ( unit , 0 ) ;
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 0
26477: PPUSH
26478: CALL_OW 109
// end ; end ; end ;
26482: LD_VAR 0 2
26486: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26487: LD_INT 0
26489: PPUSH
26490: PPUSH
26491: PPUSH
26492: PPUSH
26493: PPUSH
26494: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26495: LD_ADDR_VAR 0 7
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 33
26507: PUSH
26508: LD_INT 2
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 61
26520: PUSH
26521: EMPTY
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PPUSH
26532: CALL 11651 0 2
26536: ST_TO_ADDR
// if not vehs then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26831
// if nation = 1 then
26546: LD_VAR 0 2
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26724
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26556: LD_VAR 0 1
26560: PPUSH
26561: LD_INT 30
26563: PUSH
26564: LD_INT 36
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PPUSH
26571: CALL 11651 0 2
26575: NOT
26576: IFFALSE 26582
// exit else
26578: GO 26831
26580: GO 26722
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26582: LD_ADDR_VAR 0 5
26586: PUSH
26587: LD_VAR 0 1
26591: PPUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 36
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PPUSH
26602: CALL 11651 0 2
26606: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26607: LD_ADDR_VAR 0 6
26611: PUSH
26612: LD_VAR 0 5
26616: PUSH
26617: LD_INT 1
26619: ARRAY
26620: PPUSH
26621: CALL_OW 313
26625: ST_TO_ADDR
// for i = vehs downto 1 do
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: DOUBLE
26632: LD_VAR 0 7
26636: INC
26637: ST_TO_ADDR
26638: LD_INT 1
26640: PUSH
26641: FOR_DOWNTO
26642: IFFALSE 26720
// begin if not IsControledBy ( vehs [ i ] ) then
26644: LD_VAR 0 7
26648: PUSH
26649: LD_VAR 0 4
26653: ARRAY
26654: PPUSH
26655: CALL_OW 312
26659: NOT
26660: IFFALSE 26718
// begin tmp := MCV_RemoteDriver ( oper ) ;
26662: LD_ADDR_VAR 0 8
26666: PUSH
26667: LD_VAR 0 6
26671: PPUSH
26672: CALL 26836 0 1
26676: ST_TO_ADDR
// if not tmp then
26677: LD_VAR 0 8
26681: NOT
26682: IFFALSE 26690
// exit else
26684: POP
26685: POP
26686: GO 26831
26688: GO 26718
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26690: LD_VAR 0 7
26694: PUSH
26695: LD_VAR 0 4
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: CALL_OW 135
// end ; end ;
26718: GO 26641
26720: POP
26721: POP
// end ; end else
26722: GO 26831
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_INT 34
26731: PUSH
26732: LD_INT 31
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL 11651 0 2
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 26831
26748: GO 26831
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 1
26759: PPUSH
26760: LD_INT 34
26762: PUSH
26763: LD_INT 31
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PPUSH
26770: CALL 11651 0 2
26774: ST_TO_ADDR
// oper := [ ] ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: EMPTY
26781: ST_TO_ADDR
// for i = 1 to ct do
26782: LD_ADDR_VAR 0 4
26786: PUSH
26787: DOUBLE
26788: LD_INT 1
26790: DEC
26791: ST_TO_ADDR
26792: LD_VAR 0 5
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26829
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26800: LD_ADDR_VAR 0 6
26804: PUSH
26805: LD_VAR 0 6
26809: PUSH
26810: LD_VAR 0 5
26814: PUSH
26815: LD_VAR 0 4
26819: ARRAY
26820: PPUSH
26821: CALL 31773 0 1
26825: ADD
26826: ST_TO_ADDR
26827: GO 26797
26829: POP
26830: POP
// end ; end ; end ;
26831: LD_VAR 0 3
26835: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
// if not drivers then
26844: LD_VAR 0 1
26848: NOT
26849: IFFALSE 26855
// exit else
26851: GO 27135
26853: GO 27135
// begin linked := [ ] ;
26855: LD_ADDR_VAR 0 5
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// for i = 1 to drivers do
26862: LD_ADDR_VAR 0 3
26866: PUSH
26867: DOUBLE
26868: LD_INT 1
26870: DEC
26871: ST_TO_ADDR
26872: LD_VAR 0 1
26876: PUSH
26877: FOR_TO
26878: IFFALSE 27123
// begin if CanControl ( drivers [ i ] ) then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_VAR 0 3
26889: ARRAY
26890: PPUSH
26891: CALL 32163 0 1
26895: IFFALSE 27121
// if i > 1 then
26897: LD_VAR 0 3
26901: PUSH
26902: LD_INT 1
26904: GREATER
26905: IFFALSE 27082
// begin m := false ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26915: LD_ADDR_VAR 0 7
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_VAR 0 3
26929: ARRAY
26930: PPUSH
26931: CALL_OW 432
26935: ST_TO_ADDR
// for j = 1 to linked do
26936: LD_ADDR_VAR 0 4
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_VAR 0 5
26950: PUSH
26951: FOR_TO
26952: IFFALSE 27026
// begin if l < linked [ j ] [ 2 ] then
26954: LD_VAR 0 7
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: LD_VAR 0 4
26968: ARRAY
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: LESS
26974: IFFALSE 27024
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: LD_VAR 0 1
26993: PUSH
26994: LD_VAR 0 3
26998: ARRAY
26999: PUSH
27000: LD_VAR 0 7
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 2
27013: ST_TO_ADDR
// m := true ;
27014: LD_ADDR_VAR 0 6
27018: PUSH
27019: LD_INT 1
27021: ST_TO_ADDR
// break ;
27022: GO 27026
// end ; end ;
27024: GO 26951
27026: POP
27027: POP
// if not m then
27028: LD_VAR 0 6
27032: NOT
27033: IFFALSE 27080
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27035: LD_ADDR_VAR 0 5
27039: PUSH
27040: LD_VAR 0 5
27044: PUSH
27045: LD_VAR 0 1
27049: PUSH
27050: LD_VAR 0 3
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: ARRAY
27066: PPUSH
27067: CALL_OW 432
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: EMPTY
27077: LIST
27078: ADD
27079: ST_TO_ADDR
// end else
27080: GO 27121
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27082: LD_ADDR_VAR 0 5
27086: PUSH
27087: LD_VAR 0 1
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: PUSH
27098: LD_VAR 0 1
27102: PUSH
27103: LD_VAR 0 3
27107: ARRAY
27108: PPUSH
27109: CALL_OW 432
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: ST_TO_ADDR
// end ;
27121: GO 26877
27123: POP
27124: POP
// result := linked ;
27125: LD_ADDR_VAR 0 2
27129: PUSH
27130: LD_VAR 0 5
27134: ST_TO_ADDR
// end ; end ;
27135: LD_VAR 0 2
27139: RET
// export function MCV_ToRepair ( unit ) ; begin
27140: LD_INT 0
27142: PPUSH
// if not unit then
27143: LD_VAR 0 1
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27183
// SetTag ( unit , 6 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 6
27159: PPUSH
27160: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27164: LD_VAR 0 1
27168: PPUSH
27169: CALL_OW 255
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL 25741 0 2
// end ;
27183: LD_VAR 0 2
27187: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27192: LD_VAR 0 1
27196: PPUSH
27197: LD_INT 6
27199: PPUSH
27200: EMPTY
27201: PPUSH
27202: CALL 12354 0 3
27206: IFFALSE 27299
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: DOUBLE
27214: LD_VAR 0 1
27218: PPUSH
27219: LD_INT 6
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 12354 0 3
27228: INC
27229: ST_TO_ADDR
27230: LD_INT 1
27232: PUSH
27233: FOR_DOWNTO
27234: IFFALSE 27297
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27236: LD_VAR 0 1
27240: PPUSH
27241: LD_INT 6
27243: PPUSH
27244: EMPTY
27245: PPUSH
27246: CALL 12354 0 3
27250: PUSH
27251: LD_VAR 0 3
27255: ARRAY
27256: PPUSH
27257: CALL_OW 256
27261: PUSH
27262: LD_INT 1000
27264: EQUAL
27265: IFFALSE 27295
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 6
27274: PPUSH
27275: EMPTY
27276: PPUSH
27277: CALL 12354 0 3
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 0
27290: PPUSH
27291: CALL_OW 109
27295: GO 27233
27297: POP
27298: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27299: LD_VAR 0 1
27303: PPUSH
27304: LD_INT 10
27306: PPUSH
27307: EMPTY
27308: PPUSH
27309: CALL 12354 0 3
27313: IFFALSE 27430
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: DOUBLE
27321: LD_VAR 0 1
27325: PPUSH
27326: LD_INT 10
27328: PPUSH
27329: EMPTY
27330: PPUSH
27331: CALL 12354 0 3
27335: INC
27336: ST_TO_ADDR
27337: LD_INT 1
27339: PUSH
27340: FOR_DOWNTO
27341: IFFALSE 27428
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27343: LD_VAR 0 1
27347: PPUSH
27348: LD_INT 10
27350: PPUSH
27351: EMPTY
27352: PPUSH
27353: CALL 12354 0 3
27357: PUSH
27358: LD_VAR 0 3
27362: ARRAY
27363: PPUSH
27364: CALL_OW 302
27368: NOT
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: LD_INT 10
27377: PPUSH
27378: EMPTY
27379: PPUSH
27380: CALL 12354 0 3
27384: PUSH
27385: LD_VAR 0 3
27389: ARRAY
27390: PPUSH
27391: CALL_OW 301
27395: OR
27396: IFFALSE 27426
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27398: LD_VAR 0 1
27402: PPUSH
27403: LD_INT 10
27405: PPUSH
27406: EMPTY
27407: PPUSH
27408: CALL 12354 0 3
27412: PUSH
27413: LD_VAR 0 3
27417: ARRAY
27418: PPUSH
27419: LD_INT 0
27421: PPUSH
27422: CALL_OW 109
27426: GO 27340
27428: POP
27429: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27430: LD_ADDR_VAR 0 3
27434: PUSH
27435: LD_VAR 0 1
27439: PPUSH
27440: EMPTY
27441: PPUSH
27442: CALL 11952 0 2
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 7
27454: PPUSH
27455: EMPTY
27456: PPUSH
27457: CALL 12354 0 3
27461: DIFF
27462: PUSH
27463: FOR_IN
27464: IFFALSE 27508
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27466: LD_VAR 0 3
27470: PPUSH
27471: CALL_OW 256
27475: PUSH
27476: LD_INT 650
27478: LESS
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 110
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: NOT
27494: AND
27495: IFFALSE 27506
// MCV_ToRepair ( i ) ;
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL 27140 0 1
27506: GO 27463
27508: POP
27509: POP
// end ; end_of_file end_of_file
27510: LD_VAR 0 2
27514: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27515: LD_STRING SAILEvent [
27517: PUSH
27518: LD_VAR 0 1
27522: STR
27523: PUSH
27524: LD_STRING ]
27526: STR
27527: PPUSH
27528: CALL 8039 0 1
// if event = 101 and dialog_north then
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 101
27539: EQUAL
27540: PUSH
27541: LD_EXP 6
27545: AND
27546: IFFALSE 27610
// begin dialog_north := false ;
27548: LD_ADDR_EXP 6
27552: PUSH
27553: LD_INT 0
27555: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27556: LD_EXP 5
27560: PPUSH
27561: LD_STRING DS1
27563: PUSH
27564: LD_STRING DS2
27566: PUSH
27567: LD_STRING DS3
27569: PUSH
27570: LD_STRING DS6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PPUSH
27582: LD_INT 4
27584: PPUSH
27585: CALL_OW 12
27589: ARRAY
27590: PPUSH
27591: CALL_OW 94
// Wait ( 4 4$00 ) ;
27595: LD_INT 8400
27597: PPUSH
27598: CALL_OW 67
// dialog_north := true ;
27602: LD_ADDR_EXP 6
27606: PUSH
27607: LD_INT 1
27609: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27610: LD_VAR 0 1
27614: PUSH
27615: LD_INT 102
27617: EQUAL
27618: PUSH
27619: LD_EXP 7
27623: AND
27624: IFFALSE 27684
// begin dialog_south := false ;
27626: LD_ADDR_EXP 7
27630: PUSH
27631: LD_INT 0
27633: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27634: LD_EXP 4
27638: PPUSH
27639: LD_STRING DJ1
27641: PUSH
27642: LD_STRING DJ4
27644: PUSH
27645: LD_STRING DJ6
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PPUSH
27656: LD_INT 3
27658: PPUSH
27659: CALL_OW 12
27663: ARRAY
27664: PPUSH
27665: CALL_OW 94
// Wait ( 4 4$00 ) ;
27669: LD_INT 8400
27671: PPUSH
27672: CALL_OW 67
// dialog_south := true ;
27676: LD_ADDR_EXP 7
27680: PUSH
27681: LD_INT 1
27683: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27684: LD_VAR 0 1
27688: PUSH
27689: LD_INT 104
27691: EQUAL
27692: PUSH
27693: LD_EXP 8
27697: AND
27698: IFFALSE 27720
// begin dialog_popov := false ;
27700: LD_ADDR_EXP 8
27704: PUSH
27705: LD_INT 0
27707: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27708: LD_EXP 24
27712: PPUSH
27713: LD_STRING DR4
27715: PPUSH
27716: CALL_OW 94
// end ; end ;
27720: PPOPN 1
27722: END
// on BuildingStarted ( b , unit ) do var side , i ;
27723: LD_INT 0
27725: PPUSH
27726: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27727: LD_EXP 39
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ARRAY
27742: IFFALSE 27920
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27744: LD_STRING BuildingStarted [side: 
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: CALL_OW 255
27756: STR
27757: PUSH
27758: LD_STRING ; btype: 
27760: STR
27761: PUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 266
27771: STR
27772: PUSH
27773: LD_STRING ; unit: 
27775: STR
27776: PUSH
27777: LD_VAR 0 2
27781: STR
27782: PUSH
27783: LD_STRING ]
27785: STR
27786: PPUSH
27787: CALL 8039 0 1
// side := GetSide ( b ) ;
27791: LD_ADDR_VAR 0 3
27795: PUSH
27796: LD_VAR 0 1
27800: PPUSH
27801: CALL_OW 255
27805: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 21
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PPUSH
27821: CALL 11651 0 2
27825: PUSH
27826: LD_INT 1
27828: EQUAL
27829: IFFALSE 27920
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27831: LD_ADDR_VAR 0 4
27835: PUSH
27836: LD_VAR 0 3
27840: PPUSH
27841: LD_INT 21
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PPUSH
27851: CALL 11651 0 2
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: EMPTY
27865: PPUSH
27866: CALL 11734 0 3
27870: DIFF
27871: PUSH
27872: FOR_IN
27873: IFFALSE 27918
// if not HasTask ( i ) then
27875: LD_VAR 0 4
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: IFFALSE 27916
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27887: LD_VAR 0 4
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 250
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 251
27911: PPUSH
27912: CALL_OW 111
27916: GO 27872
27918: POP
27919: POP
// end ;
27920: PPOPN 4
27922: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27923: LD_EXP 39
27927: PUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 255
27937: ARRAY
27938: IFFALSE 28307
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27940: LD_STRING BuildingComplete [side: 
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 255
27952: STR
27953: PUSH
27954: LD_STRING ; btype: 
27956: STR
27957: PUSH
27958: LD_VAR 0 1
27962: PPUSH
27963: CALL_OW 266
27967: STR
27968: PUSH
27969: LD_STRING ]
27971: STR
27972: PPUSH
27973: CALL 8039 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27977: LD_ADDR_EXP 46
27981: PUSH
27982: LD_EXP 46
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 255
27996: PPUSH
27997: LD_VAR 0 1
28001: PPUSH
28002: CALL_OW 266
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 250
28016: PUSH
28017: LD_VAR 0 1
28021: PPUSH
28022: CALL_OW 251
28026: PUSH
28027: LD_VAR 0 1
28031: PPUSH
28032: CALL_OW 254
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL 42051 0 4
28046: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 266
28056: PUSH
28057: LD_INT 6
28059: EQUAL
28060: IFFALSE 28094
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28062: LD_ADDR_EXP 40
28066: PUSH
28067: LD_EXP 40
28071: PPUSH
28072: LD_VAR 0 1
28076: PPUSH
28077: CALL_OW 255
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: EMPTY
28088: PPUSH
28089: CALL 41960 0 4
28093: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 266
28103: PUSH
28104: LD_INT 0
28106: EQUAL
28107: IFFALSE 28217
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28109: LD_ADDR_EXP 48
28113: PUSH
28114: LD_EXP 48
28118: PPUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 255
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: EMPTY
28133: PPUSH
28134: CALL 41960 0 4
28138: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 274
28148: PPUSH
28149: LD_INT 1
28151: PPUSH
28152: LD_EXP 72
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: CALL_OW 274
28174: PPUSH
28175: LD_INT 2
28177: PPUSH
28178: LD_EXP 72
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28191: LD_VAR 0 1
28195: PPUSH
28196: CALL_OW 274
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 72
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PPUSH
28213: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 266
28226: PUSH
28227: LD_INT 2
28229: EQUAL
28230: IFFALSE 28262
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28232: LD_ADDR_EXP 48
28236: PUSH
28237: LD_EXP 48
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: CALL_OW 255
28251: PPUSH
28252: LD_INT 2
28254: PPUSH
28255: EMPTY
28256: PPUSH
28257: CALL 41960 0 4
28261: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 4
28274: EQUAL
28275: IFFALSE 28307
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28277: LD_ADDR_EXP 48
28281: PUSH
28282: LD_EXP 48
28286: PPUSH
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_INT 4
28299: PPUSH
28300: EMPTY
28301: PPUSH
28302: CALL 41960 0 4
28306: ST_TO_ADDR
// end ;
28307: PPOPN 1
28309: END
// on ResearchComplete ( tech , lab ) do var i ;
28310: LD_INT 0
28312: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28313: LD_EXP 39
28317: PUSH
28318: LD_VAR 0 2
28322: PPUSH
28323: CALL_OW 255
28327: ARRAY
28328: IFFALSE 28612
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28330: LD_STRING ResearchComplete [side: 
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: CALL_OW 255
28347: STR
28348: PUSH
28349: LD_STRING ; tech:
28351: STR
28352: PUSH
28353: LD_VAR 0 1
28357: STR
28358: PUSH
28359: LD_STRING ]
28361: STR
28362: PPUSH
28363: CALL 8039 0 1
// for i = 1 to MREG_ToRes do
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: DOUBLE
28373: LD_INT 1
28375: DEC
28376: ST_TO_ADDR
28377: LD_EXP 50
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28470
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28385: LD_EXP 50
28389: PUSH
28390: LD_VAR 0 3
28394: ARRAY
28395: PUSH
28396: LD_INT 1
28398: ARRAY
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: EQUAL
28410: PUSH
28411: LD_EXP 50
28415: PUSH
28416: LD_VAR 0 3
28420: ARRAY
28421: PUSH
28422: LD_INT 2
28424: ARRAY
28425: PUSH
28426: LD_VAR 0 1
28430: EQUAL
28431: AND
28432: IFFALSE 28468
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28434: LD_ADDR_EXP 50
28438: PUSH
28439: LD_EXP 50
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: PPUSH
28454: LD_VAR 0 1
28458: PPUSH
28459: EMPTY
28460: PPUSH
28461: CALL 42051 0 4
28465: ST_TO_ADDR
// break ;
28466: GO 28470
// end ;
28468: GO 28382
28470: POP
28471: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28472: LD_VAR 0 1
28476: PUSH
28477: LD_INT 2
28479: PUSH
28480: LD_INT 11
28482: PUSH
28483: LD_INT 4
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: IN
28495: IFFALSE 28612
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28497: LD_ADDR_VAR 0 3
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: CALL_OW 255
28511: PPUSH
28512: LD_INT 16
28514: PPUSH
28515: LD_INT 25
28517: PUSH
28518: LD_INT 4
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL 12354 0 3
28529: ST_TO_ADDR
// if i then
28530: LD_VAR 0 3
28534: IFFALSE 28552
// SetTag ( i [ 1 ] , 0 ) ;
28536: LD_VAR 0 3
28540: PUSH
28541: LD_INT 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 0
28547: PPUSH
28548: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28552: LD_ADDR_VAR 0 3
28556: PUSH
28557: LD_VAR 0 2
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: LD_INT 171
28569: PPUSH
28570: EMPTY
28571: PPUSH
28572: CALL 12354 0 3
28576: ST_TO_ADDR
// if i then
28577: LD_VAR 0 3
28581: IFFALSE 28612
// begin SetTag ( i [ 1 ] , 0 ) ;
28583: LD_VAR 0 3
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_INT 0
28594: PPUSH
28595: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: CALL_OW 122
// end ; end ; end ;
28612: PPOPN 3
28614: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28615: LD_INT 0
28617: PPUSH
28618: PPUSH
28619: PPUSH
28620: PPUSH
28621: PPUSH
28622: PPUSH
28623: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28624: LD_VAR 0 1
28628: PPUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: CALL 59183 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28638: LD_EXP 39
28642: PUSH
28643: LD_VAR 0 2
28647: PPUSH
28648: CALL_OW 255
28652: ARRAY
28653: IFFALSE 29380
// begin side := GetSide ( veh ) ;
28655: LD_ADDR_VAR 0 4
28659: PUSH
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 255
28669: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 265
28684: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28685: LD_ADDR_VAR 0 7
28689: PUSH
28690: LD_VAR 0 1
28694: PPUSH
28695: CALL_OW 262
28699: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28700: LD_ADDR_VAR 0 8
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 263
28714: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 1
28724: PPUSH
28725: CALL_OW 264
28729: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28730: LD_STRING VehicleConstructed [side: 
28732: PUSH
28733: LD_VAR 0 4
28737: STR
28738: PUSH
28739: LD_STRING ; id:
28741: STR
28742: PUSH
28743: LD_VAR 0 1
28747: STR
28748: PUSH
28749: LD_STRING ; components: [
28751: STR
28752: PUSH
28753: LD_VAR 0 6
28757: STR
28758: PUSH
28759: LD_STRING , 
28761: STR
28762: PUSH
28763: LD_VAR 0 7
28767: STR
28768: PUSH
28769: LD_STRING , 
28771: STR
28772: PUSH
28773: LD_VAR 0 8
28777: STR
28778: PUSH
28779: LD_STRING , 
28781: STR
28782: PUSH
28783: LD_VAR 0 9
28787: STR
28788: PUSH
28789: LD_STRING ]]
28791: STR
28792: PPUSH
28793: CALL 8039 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_INT 13
28809: PUSH
28810: LD_INT 12
28812: PUSH
28813: LD_INT 14
28815: PUSH
28816: LD_INT 51
28818: PUSH
28819: LD_INT 53
28821: PUSH
28822: LD_INT 52
28824: PUSH
28825: LD_INT 32
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: IN
28837: NOT
28838: IFFALSE 28880
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28840: LD_ADDR_EXP 59
28844: PUSH
28845: LD_EXP 59
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: LD_EXP 59
28859: PUSH
28860: LD_VAR 0 4
28864: ARRAY
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 1
28874: PPUSH
28875: CALL 31130 0 4
28879: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 264
28889: PUSH
28890: LD_INT 31
28892: EQUAL
28893: IFFALSE 28912
// SetTag ( GetDriver ( veh ) , 9 ) ;
28895: LD_VAR 0 1
28899: PPUSH
28900: CALL 31773 0 1
28904: PPUSH
28905: LD_INT 9
28907: PPUSH
28908: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28912: LD_VAR 0 1
28916: PPUSH
28917: CALL_OW 264
28921: PUSH
28922: LD_INT 14
28924: PUSH
28925: LD_INT 53
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: IN
28932: IFFALSE 28969
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28934: LD_ADDR_EXP 42
28938: PUSH
28939: LD_EXP 42
28943: PPUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 255
28953: PPUSH
28954: LD_INT 2
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: CALL 31130 0 4
28966: ST_TO_ADDR
// exit ;
28967: GO 29380
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28969: LD_VAR 0 1
28973: PPUSH
28974: CALL_OW 265
28978: PUSH
28979: LD_EXP 66
28983: PUSH
28984: LD_VAR 0 4
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IN
28994: PUSH
28995: LD_VAR 0 1
28999: PPUSH
29000: CALL_OW 262
29004: PUSH
29005: LD_EXP 66
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: IN
29020: AND
29021: PUSH
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 263
29031: PUSH
29032: LD_EXP 66
29036: PUSH
29037: LD_VAR 0 4
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: IN
29047: AND
29048: PUSH
29049: LD_VAR 0 1
29053: PPUSH
29054: CALL_OW 264
29058: PUSH
29059: LD_EXP 66
29063: PUSH
29064: LD_VAR 0 4
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: IN
29074: AND
29075: IFFALSE 29119
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29077: LD_ADDR_EXP 67
29081: PUSH
29082: LD_EXP 67
29086: PPUSH
29087: LD_VAR 0 4
29091: PPUSH
29092: LD_EXP 67
29096: PUSH
29097: LD_VAR 0 4
29101: ARRAY
29102: PUSH
29103: LD_INT 1
29105: PLUS
29106: PPUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL 31130 0 4
29116: ST_TO_ADDR
// exit ;
29117: GO 29380
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29119: LD_VAR 0 6
29123: PUSH
29124: LD_EXP 69
29128: PUSH
29129: LD_VAR 0 4
29133: ARRAY
29134: PUSH
29135: LD_INT 1
29137: ARRAY
29138: EQUAL
29139: PUSH
29140: LD_VAR 0 7
29144: PUSH
29145: LD_EXP 69
29149: PUSH
29150: LD_VAR 0 4
29154: ARRAY
29155: PUSH
29156: LD_INT 2
29158: ARRAY
29159: EQUAL
29160: AND
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_EXP 69
29171: PUSH
29172: LD_VAR 0 4
29176: ARRAY
29177: PUSH
29178: LD_INT 3
29180: ARRAY
29181: EQUAL
29182: AND
29183: PUSH
29184: LD_VAR 0 9
29188: PUSH
29189: LD_EXP 69
29193: PUSH
29194: LD_VAR 0 4
29198: ARRAY
29199: PUSH
29200: LD_INT 4
29202: ARRAY
29203: EQUAL
29204: AND
29205: IFFALSE 29361
// begin tmp := MREG_ToAttack [ side ] ;
29207: LD_ADDR_VAR 0 5
29211: PUSH
29212: LD_EXP 69
29216: PUSH
29217: LD_VAR 0 4
29221: ARRAY
29222: ST_TO_ADDR
// for i = 1 to 4 do
29223: LD_ADDR_VAR 0 3
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_INT 4
29235: PUSH
29236: FOR_TO
29237: IFFALSE 29259
// tmp := Delete ( tmp , 1 ) ;
29239: LD_ADDR_VAR 0 5
29243: PUSH
29244: LD_VAR 0 5
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 3
29256: ST_TO_ADDR
29257: GO 29236
29259: POP
29260: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29261: LD_ADDR_EXP 69
29265: PUSH
29266: LD_EXP 69
29270: PPUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_VAR 0 5
29280: PPUSH
29281: CALL_OW 1
29285: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29286: LD_ADDR_EXP 71
29290: PUSH
29291: LD_EXP 71
29295: PPUSH
29296: LD_VAR 0 4
29300: PPUSH
29301: LD_EXP 71
29305: PUSH
29306: LD_VAR 0 4
29310: ARRAY
29311: PUSH
29312: LD_INT 1
29314: PLUS
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL 31130 0 4
29325: ST_TO_ADDR
// if tmp = 0 then
29326: LD_VAR 0 5
29330: PUSH
29331: LD_INT 0
29333: EQUAL
29334: IFFALSE 29359
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29336: LD_ADDR_EXP 69
29340: PUSH
29341: LD_EXP 69
29345: PPUSH
29346: LD_VAR 0 4
29350: PPUSH
29351: LD_INT 0
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// exit ;
29359: GO 29380
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29361: LD_VAR 0 1
29365: PPUSH
29366: CALL_OW 255
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL 25741 0 2
// end ; end ;
29380: PPOPN 9
29382: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29383: LD_EXP 39
29387: PUSH
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 255
29397: ARRAY
29398: IFFALSE 29630
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29400: LD_STRING ApemanTamed [side: 
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: STR
29413: PUSH
29414: LD_STRING ; sci: 
29416: STR
29417: PUSH
29418: LD_VAR 0 2
29422: STR
29423: PUSH
29424: LD_STRING ; ape: 
29426: STR
29427: PUSH
29428: LD_VAR 0 1
29432: STR
29433: PUSH
29434: LD_STRING ]
29436: STR
29437: PPUSH
29438: CALL 8039 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29442: LD_INT 11
29444: PPUSH
29445: LD_VAR 0 2
29449: PPUSH
29450: CALL_OW 255
29454: PPUSH
29455: CALL_OW 321
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: NOT
29464: PUSH
29465: LD_INT 2
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: CALL_OW 255
29477: PPUSH
29478: CALL_OW 321
29482: PUSH
29483: LD_INT 2
29485: EQUAL
29486: NOT
29487: OR
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: CALL_OW 255
29498: PPUSH
29499: LD_INT 171
29501: PPUSH
29502: EMPTY
29503: PPUSH
29504: CALL 12354 0 3
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: AND
29513: IFFALSE 29527
// begin SetTag ( ape , 171 ) ;
29515: LD_VAR 0 1
29519: PPUSH
29520: LD_INT 171
29522: PPUSH
29523: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29527: LD_VAR 0 2
29531: PPUSH
29532: CALL_OW 255
29536: PPUSH
29537: LD_INT 30
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL 11651 0 2
29551: IFFALSE 29630
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29553: LD_VAR 0 1
29557: PPUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: CALL_OW 255
29567: PPUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL 11651 0 2
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: CALL_OW 250
29591: PPUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 255
29601: PPUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL 11651 0 2
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: CALL_OW 251
29625: PPUSH
29626: CALL_OW 111
// end ;
29630: PPOPN 2
29632: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29633: LD_EXP 39
29637: PUSH
29638: LD_VAR 0 1
29642: PPUSH
29643: CALL_OW 255
29647: ARRAY
29648: IFFALSE 29926
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29650: LD_VAR 0 2
29654: PUSH
29655: LD_VAR 0 2
29659: PPUSH
29660: CALL_OW 255
29664: PPUSH
29665: CALL 12064 0 1
29669: IN
29670: IFFALSE 29811
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29672: LD_VAR 0 1
29676: PPUSH
29677: CALL_OW 266
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: IFFALSE 29722
// begin Wait ( 0 0$0.3 ) ;
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 16
29708: PPUSH
29709: CALL_OW 336
// ComExitBuilding ( un ) ;
29713: LD_VAR 0 2
29717: PPUSH
29718: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 266
29731: PUSH
29732: LD_INT 4
29734: PUSH
29735: LD_INT 5
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: IN
29742: IFFALSE 29811
// begin Wait ( 0 0$0.3 ) ;
29744: LD_INT 10
29746: PPUSH
29747: CALL_OW 67
// if GetTag ( un ) = 0 then
29751: LD_VAR 0 2
29755: PPUSH
29756: CALL_OW 110
29760: PUSH
29761: LD_INT 0
29763: EQUAL
29764: IFFALSE 29780
// SetClass ( un , class_apeman_soldier ) else
29766: LD_VAR 0 2
29770: PPUSH
29771: LD_INT 15
29773: PPUSH
29774: CALL_OW 336
29778: GO 29811
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29780: LD_INT 3
29782: PPUSH
29783: LD_VAR 0 2
29787: PPUSH
29788: CALL_OW 255
29792: PPUSH
29793: CALL_OW 321
29797: IFFALSE 29811
// SetClass ( un , class_apeman_kamikaze ) ;
29799: LD_VAR 0 2
29803: PPUSH
29804: LD_INT 17
29806: PPUSH
29807: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 266
29820: PUSH
29821: LD_INT 32
29823: EQUAL
29824: IFFALSE 29926
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29826: LD_ADDR_EXP 68
29830: PUSH
29831: LD_EXP 68
29835: PPUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: CALL_OW 255
29845: PPUSH
29846: LD_EXP 68
29850: PUSH
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL_OW 255
29860: ARRAY
29861: PUSH
29862: LD_INT 1
29864: PLUS
29865: PPUSH
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL 31130 0 4
29875: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29876: LD_ADDR_EXP 68
29880: PUSH
29881: LD_EXP 68
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 255
29895: PPUSH
29896: LD_EXP 68
29900: PUSH
29901: LD_VAR 0 1
29905: PPUSH
29906: CALL_OW 255
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: PLUS
29915: PPUSH
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL 31130 0 4
29925: ST_TO_ADDR
// end ; end ;
29926: PPOPN 2
29928: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL 59063 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29938: LD_VAR 0 1
29942: PUSH
29943: LD_INT 22
29945: PUSH
29946: LD_INT 3
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 23
29955: PUSH
29956: LD_INT 3
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 21
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: PPUSH
29978: CALL_OW 69
29982: IN
29983: IFFALSE 29999
// player_loss := player_loss + 1 ;
29985: LD_ADDR_EXP 10
29989: PUSH
29990: LD_EXP 10
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 22
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 21
30016: PUSH
30017: LD_INT 3
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 69
30032: IN
30033: PUSH
30034: LD_EXP 14
30038: NOT
30039: AND
30040: IFFALSE 30103
// begin alfa_north_triggered := true ;
30042: LD_ADDR_EXP 14
30046: PUSH
30047: LD_INT 1
30049: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30050: LD_EXP 5
30054: PPUSH
30055: LD_STRING DS4
30057: PPUSH
30058: CALL_OW 94
// Wait ( 1 1$25 ) ;
30062: LD_INT 2975
30064: PPUSH
30065: CALL_OW 67
// if not isTest then
30069: LD_EXP 1
30073: NOT
30074: IFFALSE 30103
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30076: LD_INT 20
30078: PPUSH
30079: LD_INT 5
30081: PUSH
30082: LD_INT 6
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PUSH
30093: LD_OWVAR 67
30097: ARRAY
30098: PPUSH
30099: CALL 7058 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30103: LD_VAR 0 1
30107: PUSH
30108: LD_INT 22
30110: PUSH
30111: LD_INT 4
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 21
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PPUSH
30132: CALL_OW 69
30136: IN
30137: PUSH
30138: LD_EXP 15
30142: NOT
30143: AND
30144: IFFALSE 30207
// begin alfa_south_triggered := true ;
30146: LD_ADDR_EXP 15
30150: PUSH
30151: LD_INT 1
30153: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30154: LD_EXP 4
30158: PPUSH
30159: LD_STRING DJ3
30161: PPUSH
30162: CALL_OW 94
// Wait ( 0 0$45 ) ;
30166: LD_INT 1575
30168: PPUSH
30169: CALL_OW 67
// if not isTest then
30173: LD_EXP 1
30177: NOT
30178: IFFALSE 30207
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30180: LD_INT 20
30182: PPUSH
30183: LD_INT 5
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: LD_INT 7
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: LIST
30196: PUSH
30197: LD_OWVAR 67
30201: ARRAY
30202: PPUSH
30203: CALL 7058 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 266
30216: PUSH
30217: LD_INT 1
30219: EQUAL
30220: PUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 255
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 4
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: IN
30241: AND
30242: IFFALSE 30251
// RaiseSailEvent ( 104 ) ;
30244: LD_INT 104
30246: PPUSH
30247: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30251: LD_EXP 39
30255: PUSH
30256: LD_VAR 0 1
30260: PPUSH
30261: CALL_OW 255
30265: ARRAY
30266: IFFALSE 30653
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30268: LD_STRING UnitDestroyed [side 
30270: PUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL_OW 255
30280: STR
30281: PUSH
30282: LD_STRING ; id: 
30284: STR
30285: PUSH
30286: LD_VAR 0 1
30290: STR
30291: PUSH
30292: LD_STRING ; type: 
30294: STR
30295: PUSH
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 247
30305: STR
30306: PUSH
30307: LD_STRING ]
30309: STR
30310: PPUSH
30311: CALL 8039 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: CALL_OW 255
30329: PPUSH
30330: LD_INT 21
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL 11651 0 2
30344: IN
30345: IFFALSE 30501
// begin if MCF_HasClass ( un ) then
30347: LD_VAR 0 1
30351: PPUSH
30352: CALL 14357 0 1
30356: IFFALSE 30501
// case MCF_HasClass ( un ) of 1 :
30358: LD_VAR 0 1
30362: PPUSH
30363: CALL 14357 0 1
30367: PUSH
30368: LD_INT 1
30370: DOUBLE
30371: EQUAL
30372: IFTRUE 30376
30374: GO 30401
30376: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 255
30386: PPUSH
30387: LD_STRING ToArm
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL 14530 0 3
30399: GO 30501
30401: LD_INT 2
30403: DOUBLE
30404: EQUAL
30405: IFTRUE 30409
30407: GO 30434
30409: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30410: LD_VAR 0 1
30414: PPUSH
30415: CALL_OW 255
30419: PPUSH
30420: LD_STRING ToDep
30422: PPUSH
30423: LD_VAR 0 1
30427: PPUSH
30428: CALL 14530 0 3
30432: GO 30501
30434: LD_INT 3
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30467
30442: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30443: LD_VAR 0 1
30447: PPUSH
30448: CALL_OW 255
30452: PPUSH
30453: LD_STRING ToFac
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: CALL 14530 0 3
30465: GO 30501
30467: LD_INT 4
30469: DOUBLE
30470: EQUAL
30471: IFTRUE 30475
30473: GO 30500
30475: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30476: LD_VAR 0 1
30480: PPUSH
30481: CALL_OW 255
30485: PPUSH
30486: LD_STRING ToLab
30488: PPUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL 14530 0 3
30498: GO 30501
30500: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30501: LD_VAR 0 1
30505: PUSH
30506: LD_EXP 67
30510: PUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 255
30520: ARRAY
30521: IN
30522: IFFALSE 30607
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30524: LD_ADDR_EXP 67
30528: PUSH
30529: LD_EXP 67
30533: PPUSH
30534: LD_VAR 0 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 31289 0 3
30546: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 255
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: CALL_OW 265
30566: PUSH
30567: LD_VAR 0 1
30571: PPUSH
30572: CALL_OW 262
30576: PUSH
30577: LD_VAR 0 1
30581: PPUSH
30582: CALL_OW 263
30586: PUSH
30587: LD_VAR 0 1
30591: PPUSH
30592: CALL_OW 264
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PPUSH
30603: CALL 21170 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30607: LD_VAR 0 1
30611: PUSH
30612: LD_EXP 71
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 255
30626: ARRAY
30627: IN
30628: IFFALSE 30653
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30630: LD_ADDR_EXP 71
30634: PUSH
30635: LD_EXP 71
30639: PPUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: LD_INT 0
30647: PPUSH
30648: CALL 31289 0 3
30652: ST_TO_ADDR
// end ; end ;
30653: PPOPN 1
30655: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30656: LD_EXP 39
30660: PUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL_OW 255
30670: ARRAY
30671: IFFALSE 30843
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30673: LD_VAR 0 2
30677: PUSH
30678: LD_EXP 68
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 255
30692: ARRAY
30693: IN
30694: PUSH
30695: LD_VAR 0 1
30699: PPUSH
30700: CALL_OW 266
30704: PUSH
30705: LD_INT 32
30707: PUSH
30708: LD_INT 31
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: IN
30715: AND
30716: IFFALSE 30816
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30718: LD_ADDR_EXP 68
30722: PUSH
30723: LD_EXP 68
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: LD_INT 0
30735: PPUSH
30736: CALL 31289 0 3
30740: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30741: LD_ADDR_EXP 68
30745: PUSH
30746: LD_EXP 68
30750: PPUSH
30751: LD_VAR 0 2
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL 31289 0 3
30763: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30764: LD_EXP 68
30768: PUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: CALL_OW 255
30778: ARRAY
30779: PUSH
30780: LD_STRING 
30782: EQUAL
30783: IFFALSE 30816
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30785: LD_ADDR_EXP 68
30789: PUSH
30790: LD_EXP 68
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: CALL_OW 255
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL 31130 0 4
30815: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30816: LD_VAR 0 1
30820: PPUSH
30821: CALL_OW 266
30825: PUSH
30826: LD_INT 36
30828: IN
30829: IFFALSE 30843
// SetTag ( un , 0 ) ;
30831: LD_VAR 0 2
30835: PPUSH
30836: LD_INT 0
30838: PPUSH
30839: CALL_OW 109
// end ;
30843: PPOPN 2
30845: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30846: LD_EXP 39
30850: PUSH
30851: LD_VAR 0 1
30855: PPUSH
30856: CALL_OW 255
30860: ARRAY
30861: IFFALSE 30887
// begin if GetControl ( un ) = control_remote then
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 263
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: IFFALSE 30887
// ComUnlink ( un ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 136
// end ;
30887: PPOPN 1
30889: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30890: LD_EXP 39
30894: PUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 255
30904: ARRAY
30905: IFFALSE 30934
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30907: LD_VAR 0 2
30911: PPUSH
30912: CALL_OW 264
30916: PUSH
30917: LD_INT 31
30919: IN
30920: IFFALSE 30934
// SetTag ( driver , 0 ) ;
30922: LD_VAR 0 1
30926: PPUSH
30927: LD_INT 0
30929: PPUSH
30930: CALL_OW 109
// end ;
30934: PPOPN 4
30936: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 269
30956: ST_TO_ADDR
// x := GetX ( building ) ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_VAR 0 1
30966: PPUSH
30967: CALL_OW 250
30971: ST_TO_ADDR
// y := GetY ( building ) ;
30972: LD_ADDR_VAR 0 5
30976: PUSH
30977: LD_VAR 0 1
30981: PPUSH
30982: CALL_OW 251
30986: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30987: LD_ADDR_EXP 43
30991: PUSH
30992: LD_EXP 43
30996: PPUSH
30997: LD_VAR 0 1
31001: PPUSH
31002: CALL_OW 255
31006: PPUSH
31007: LD_VAR 0 3
31011: PPUSH
31012: LD_VAR 0 4
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PPUSH
31026: CALL 42051 0 4
31030: ST_TO_ADDR
// end ;
31031: PPOPN 5
31033: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 30
31043: IN
31044: NOT
31045: IFFALSE 31093
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31047: LD_ADDR_EXP 30
31051: PUSH
31052: LD_EXP 30
31056: PPUSH
31057: LD_EXP 30
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 1
31070: PPUSH
31071: CALL_OW 2
31075: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31076: LD_STRING DestinationUnrechable. [unit: 
31078: PUSH
31079: LD_VAR 0 1
31083: STR
31084: PUSH
31085: LD_STRING ]
31087: STR
31088: PPUSH
31089: CALL 8039 0 1
// end ; end ;
31093: PPOPN 1
31095: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL 59159 0 3
// end ;
31115: PPOPN 3
31117: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL 59167 0 1
// end ; end_of_file
31127: PPOPN 1
31129: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
31134: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31135: LD_ADDR_VAR 0 7
31139: PUSH
31140: LD_VAR 0 1
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PPUSH
31151: LD_VAR 0 3
31155: PPUSH
31156: LD_VAR 0 4
31160: PPUSH
31161: CALL_OW 1
31165: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31166: LD_ADDR_VAR 0 1
31170: PUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: LD_VAR 0 2
31180: PPUSH
31181: LD_VAR 0 7
31185: PPUSH
31186: CALL_OW 1
31190: ST_TO_ADDR
// result := tab ;
31191: LD_ADDR_VAR 0 5
31195: PUSH
31196: LD_VAR 0 1
31200: ST_TO_ADDR
// end ;
31201: LD_VAR 0 5
31205: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31206: LD_INT 0
31208: PPUSH
31209: PPUSH
31210: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31211: LD_ADDR_VAR 0 5
31215: PUSH
31216: LD_VAR 0 1
31220: PUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: ARRAY
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_INT 2
31238: ARRAY
31239: PPUSH
31240: CALL_OW 3
31244: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31245: LD_ADDR_VAR 0 1
31249: PUSH
31250: LD_VAR 0 1
31254: PPUSH
31255: LD_VAR 0 2
31259: PUSH
31260: LD_INT 1
31262: ARRAY
31263: PPUSH
31264: LD_VAR 0 5
31268: PPUSH
31269: CALL_OW 1
31273: ST_TO_ADDR
// result := tab ;
31274: LD_ADDR_VAR 0 3
31278: PUSH
31279: LD_VAR 0 1
31283: ST_TO_ADDR
// end ;
31284: LD_VAR 0 3
31288: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31289: LD_INT 0
31291: PPUSH
31292: PPUSH
31293: PPUSH
31294: PPUSH
// i := 1 ;
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// while ( i <= tab ) do
31303: LD_VAR 0 5
31307: PUSH
31308: LD_VAR 0 1
31312: LESSEQUAL
31313: IFFALSE 31688
// begin if not tab [ i ] then
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: NOT
31326: IFFALSE 31330
// break ;
31328: GO 31688
// if value in tab then
31330: LD_VAR 0 2
31334: PUSH
31335: LD_VAR 0 1
31339: IN
31340: IFFALSE 31453
// begin if not mode then
31342: LD_VAR 0 3
31346: NOT
31347: IFFALSE 31367
// tab := tab diff value else
31349: LD_ADDR_VAR 0 1
31353: PUSH
31354: LD_VAR 0 1
31358: PUSH
31359: LD_VAR 0 2
31363: DIFF
31364: ST_TO_ADDR
31365: GO 31429
// for j = 1 to tab do
31367: LD_ADDR_VAR 0 6
31371: PUSH
31372: DOUBLE
31373: LD_INT 1
31375: DEC
31376: ST_TO_ADDR
31377: LD_VAR 0 1
31381: PUSH
31382: FOR_TO
31383: IFFALSE 31427
// if tab [ j ] = value then
31385: LD_VAR 0 1
31389: PUSH
31390: LD_VAR 0 6
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 2
31400: EQUAL
31401: IFFALSE 31425
// begin tab := Delete ( tab , j ) ;
31403: LD_ADDR_VAR 0 1
31407: PUSH
31408: LD_VAR 0 1
31412: PPUSH
31413: LD_VAR 0 6
31417: PPUSH
31418: CALL_OW 3
31422: ST_TO_ADDR
// break ;
31423: GO 31427
// end ;
31425: GO 31382
31427: POP
31428: POP
// i := i - 1 ;
31429: LD_ADDR_VAR 0 5
31433: PUSH
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 1
31441: MINUS
31442: ST_TO_ADDR
// if mode then
31443: LD_VAR 0 3
31447: IFFALSE 31451
// break ;
31449: GO 31688
// end else
31451: GO 31672
// if tab [ i ] and value in tab [ i ] then
31453: LD_VAR 0 1
31457: PUSH
31458: LD_VAR 0 5
31462: ARRAY
31463: PUSH
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: IN
31480: AND
31481: IFFALSE 31672
// begin if not mode then
31483: LD_VAR 0 3
31487: NOT
31488: IFFALSE 31514
// tmp := tab [ i ] diff value else
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: LD_VAR 0 1
31499: PUSH
31500: LD_VAR 0 5
31504: ARRAY
31505: PUSH
31506: LD_VAR 0 2
31510: DIFF
31511: ST_TO_ADDR
31512: GO 31594
// for j = 1 to tab [ i ] do
31514: LD_ADDR_VAR 0 6
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 1
31528: PUSH
31529: LD_VAR 0 5
31533: ARRAY
31534: PUSH
31535: FOR_TO
31536: IFFALSE 31592
// if value = tab [ i ] [ j ] then
31538: LD_VAR 0 2
31542: PUSH
31543: LD_VAR 0 1
31547: PUSH
31548: LD_VAR 0 5
31552: ARRAY
31553: PUSH
31554: LD_VAR 0 6
31558: ARRAY
31559: EQUAL
31560: IFFALSE 31590
// begin tmp := Delete ( tab [ i ] , j ) ;
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: LD_VAR 0 1
31571: PUSH
31572: LD_VAR 0 5
31576: ARRAY
31577: PPUSH
31578: LD_VAR 0 6
31582: PPUSH
31583: CALL_OW 3
31587: ST_TO_ADDR
// break ;
31588: GO 31592
// end ;
31590: GO 31535
31592: POP
31593: POP
// if tmp = [ ] then
31594: LD_VAR 0 7
31598: PUSH
31599: EMPTY
31600: EQUAL
31601: IFFALSE 31625
// begin tab := Delete ( tab , i ) ;
31603: LD_ADDR_VAR 0 1
31607: PUSH
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: CALL_OW 3
31622: ST_TO_ADDR
// end else
31623: GO 31650
// tab := Replace ( tab , i , tmp ) ;
31625: LD_ADDR_VAR 0 1
31629: PUSH
31630: LD_VAR 0 1
31634: PPUSH
31635: LD_VAR 0 5
31639: PPUSH
31640: LD_VAR 0 7
31644: PPUSH
31645: CALL_OW 1
31649: ST_TO_ADDR
// i := i - 1 ;
31650: LD_ADDR_VAR 0 5
31654: PUSH
31655: LD_VAR 0 5
31659: PUSH
31660: LD_INT 1
31662: MINUS
31663: ST_TO_ADDR
// if mode then
31664: LD_VAR 0 3
31668: IFFALSE 31672
// break ;
31670: GO 31688
// end ; i := i + 1 ;
31672: LD_ADDR_VAR 0 5
31676: PUSH
31677: LD_VAR 0 5
31681: PUSH
31682: LD_INT 1
31684: PLUS
31685: ST_TO_ADDR
// end ;
31686: GO 31303
// result := tab ;
31688: LD_ADDR_VAR 0 4
31692: PUSH
31693: LD_VAR 0 1
31697: ST_TO_ADDR
// end ;
31698: LD_VAR 0 4
31702: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31703: LD_INT 0
31705: PPUSH
31706: PPUSH
// for i = 1 to values do
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: DOUBLE
31713: LD_INT 1
31715: DEC
31716: ST_TO_ADDR
31717: LD_VAR 0 2
31721: PUSH
31722: FOR_TO
31723: IFFALSE 31756
// tab := Remove ( tab , values [ i ] , false ) ;
31725: LD_ADDR_VAR 0 1
31729: PUSH
31730: LD_VAR 0 1
31734: PPUSH
31735: LD_VAR 0 2
31739: PUSH
31740: LD_VAR 0 4
31744: ARRAY
31745: PPUSH
31746: LD_INT 0
31748: PPUSH
31749: CALL 31289 0 3
31753: ST_TO_ADDR
31754: GO 31722
31756: POP
31757: POP
// result := tab ;
31758: LD_ADDR_VAR 0 3
31762: PUSH
31763: LD_VAR 0 1
31767: ST_TO_ADDR
// end ;
31768: LD_VAR 0 3
31772: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31773: LD_INT 0
31775: PPUSH
31776: PPUSH
31777: PPUSH
// if not GetControl ( veh ) = control_manual then
31778: LD_VAR 0 1
31782: PPUSH
31783: CALL_OW 263
31787: PUSH
31788: LD_INT 1
31790: EQUAL
31791: NOT
31792: IFFALSE 31804
// result := false else
31794: LD_ADDR_VAR 0 2
31798: PUSH
31799: LD_INT 0
31801: ST_TO_ADDR
31802: GO 31949
// if veh in FilterAllUnits ( [ f_empty ] ) then
31804: LD_VAR 0 1
31808: PUSH
31809: LD_INT 58
31811: PUSH
31812: EMPTY
31813: LIST
31814: PPUSH
31815: CALL_OW 69
31819: IN
31820: IFFALSE 31832
// result := false else
31822: LD_ADDR_VAR 0 2
31826: PUSH
31827: LD_INT 0
31829: ST_TO_ADDR
31830: GO 31949
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31832: LD_ADDR_VAR 0 4
31836: PUSH
31837: LD_INT 22
31839: PUSH
31840: LD_VAR 0 1
31844: PPUSH
31845: CALL_OW 255
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 55
31856: PUSH
31857: EMPTY
31858: LIST
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 69
31868: ST_TO_ADDR
// if not filter then
31869: LD_VAR 0 4
31873: NOT
31874: IFFALSE 31886
// result := false else
31876: LD_ADDR_VAR 0 2
31880: PUSH
31881: LD_INT 0
31883: ST_TO_ADDR
31884: GO 31949
// for i = 1 to filter do
31886: LD_ADDR_VAR 0 3
31890: PUSH
31891: DOUBLE
31892: LD_INT 1
31894: DEC
31895: ST_TO_ADDR
31896: LD_VAR 0 4
31900: PUSH
31901: FOR_TO
31902: IFFALSE 31947
// if IsDriver ( filter [ i ] ) = veh then
31904: LD_VAR 0 4
31908: PUSH
31909: LD_VAR 0 3
31913: ARRAY
31914: PPUSH
31915: CALL 98436 0 1
31919: PUSH
31920: LD_VAR 0 1
31924: EQUAL
31925: IFFALSE 31945
// begin result := filter [ i ] ;
31927: LD_ADDR_VAR 0 2
31931: PUSH
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 3
31941: ARRAY
31942: ST_TO_ADDR
// break ;
31943: GO 31947
// end ;
31945: GO 31901
31947: POP
31948: POP
// end ; end ;
31949: LD_VAR 0 2
31953: RET
// export function Compare ( val1 , val2 ) ; begin
31954: LD_INT 0
31956: PPUSH
// if val1 = val2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 31979
// result := true else
31969: LD_ADDR_VAR 0 3
31973: PUSH
31974: LD_INT 1
31976: ST_TO_ADDR
31977: GO 31987
// result := false ;
31979: LD_ADDR_VAR 0 3
31983: PUSH
31984: LD_INT 0
31986: ST_TO_ADDR
// end ;
31987: LD_VAR 0 3
31991: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31992: LD_INT 0
31994: PPUSH
31995: PPUSH
// result := false ;
31996: LD_ADDR_VAR 0 3
32000: PUSH
32001: LD_INT 0
32003: ST_TO_ADDR
// for j = 1 to e2 do
32004: LD_ADDR_VAR 0 4
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_VAR 0 2
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32054
// if Compare ( e1 , e2 [ j ] ) then
32022: LD_VAR 0 1
32026: PPUSH
32027: LD_VAR 0 2
32031: PUSH
32032: LD_VAR 0 4
32036: ARRAY
32037: PPUSH
32038: CALL 31954 0 2
32042: IFFALSE 32052
// result := true ;
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_INT 1
32051: ST_TO_ADDR
32052: GO 32019
32054: POP
32055: POP
// end ;
32056: LD_VAR 0 3
32060: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32061: LD_INT 0
32063: PPUSH
32064: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_STRING C
32072: PUSH
32073: LD_VAR 0 2
32077: PUSH
32078: LD_VAR 0 3
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: PUSH
32104: LD_STRING v
32106: PUSH
32107: LD_VAR 0 4
32111: PPUSH
32112: CALL_OW 250
32116: PUSH
32117: LD_VAR 0 4
32121: PPUSH
32122: CALL_OW 251
32126: PUSH
32127: LD_VAR 0 4
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 0
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: CALL_OW 446
// end ;
32158: LD_VAR 0 5
32162: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
// linked := UnitsLinked ( unit ) ;
32168: LD_ADDR_VAR 0 4
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 432
32182: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32183: LD_ADDR_VAR 0 3
32187: PUSH
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_INT 3
32195: PPUSH
32196: CALL_OW 259
32200: ST_TO_ADDR
// if sk > linked then
32201: LD_VAR 0 3
32205: PUSH
32206: LD_VAR 0 4
32210: GREATER
32211: IFFALSE 32223
// result := true else
32213: LD_ADDR_VAR 0 2
32217: PUSH
32218: LD_INT 1
32220: ST_TO_ADDR
32221: GO 32231
// result := false ;
32223: LD_ADDR_VAR 0 2
32227: PUSH
32228: LD_INT 0
32230: ST_TO_ADDR
// end ;
32231: LD_VAR 0 2
32235: RET
// export function NotTask ( unit ) ; begin
32236: LD_INT 0
32238: PPUSH
// result := true ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32247: LD_VAR 0 1
32251: PPUSH
32252: CALL_OW 437
32256: PUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: CALL_OW 314
32266: OR
32267: IFFALSE 32277
// result := false ;
32269: LD_ADDR_VAR 0 2
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// end ;
32277: LD_VAR 0 2
32281: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32282: LD_INT 0
32284: PPUSH
32285: PPUSH
32286: PPUSH
32287: PPUSH
32288: PPUSH
// dist := 99999 ;
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_INT 99999
32296: ST_TO_ADDR
// un := - 1 ;
32297: LD_ADDR_VAR 0 6
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: ST_TO_ADDR
// if units1 and units2 then
32306: LD_VAR 0 1
32310: PUSH
32311: LD_VAR 0 2
32315: AND
32316: IFFALSE 32404
// for i in units1 do
32318: LD_ADDR_VAR 0 4
32322: PUSH
32323: LD_VAR 0 1
32327: PUSH
32328: FOR_IN
32329: IFFALSE 32402
// for j in units2 do
32331: LD_ADDR_VAR 0 5
32335: PUSH
32336: LD_VAR 0 2
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32398
// if GetDistUnits ( i , j ) < dist then
32344: LD_VAR 0 4
32348: PPUSH
32349: LD_VAR 0 5
32353: PPUSH
32354: CALL_OW 296
32358: PUSH
32359: LD_VAR 0 7
32363: LESS
32364: IFFALSE 32396
// begin un := i ;
32366: LD_ADDR_VAR 0 6
32370: PUSH
32371: LD_VAR 0 4
32375: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32376: LD_ADDR_VAR 0 7
32380: PUSH
32381: LD_VAR 0 4
32385: PPUSH
32386: LD_VAR 0 5
32390: PPUSH
32391: CALL_OW 296
32395: ST_TO_ADDR
// end ;
32396: GO 32341
32398: POP
32399: POP
32400: GO 32328
32402: POP
32403: POP
// result := [ un , dist ] ;
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_VAR 0 6
32413: PUSH
32414: LD_VAR 0 7
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: ST_TO_ADDR
// end ;
32423: LD_VAR 0 3
32427: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32428: LD_INT 0
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32435: LD_VAR 0 1
32439: NOT
32440: PUSH
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 256
32450: PUSH
32451: LD_INT 250
32453: LESS
32454: OR
32455: PUSH
32456: LD_VAR 0 1
32460: PPUSH
32461: CALL_OW 314
32465: PUSH
32466: LD_VAR 0 1
32470: PPUSH
32471: CALL_OW 261
32475: PUSH
32476: LD_INT 20
32478: GREATER
32479: AND
32480: OR
32481: IFFALSE 32485
// exit ;
32483: GO 32859
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 261
32494: PUSH
32495: LD_INT 20
32497: LESS
32498: PUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 21
32511: EQUAL
32512: NOT
32513: AND
32514: IFFALSE 32550
// begin ComStop ( bulldozer ) ;
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32525: LD_VAR 0 1
32529: PPUSH
32530: LD_INT 21
32532: PPUSH
32533: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32537: LD_VAR 0 1
32541: PPUSH
32542: CALL 26278 0 1
// exit ;
32546: GO 32859
// end else
32548: GO 32577
// if GetFuel ( bulldozer ) > 20 then
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: IFFALSE 32577
// SetTag ( bulldozer , 0 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 0
32572: PPUSH
32573: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_VAR 0 2
32586: PPUSH
32587: CALL_OW 353
32591: ST_TO_ADDR
// tmp := [ ] ;
32592: LD_ADDR_VAR 0 6
32596: PUSH
32597: EMPTY
32598: ST_TO_ADDR
// for i = 1 to list do
32599: LD_ADDR_VAR 0 4
32603: PUSH
32604: DOUBLE
32605: LD_INT 1
32607: DEC
32608: ST_TO_ADDR
32609: LD_VAR 0 5
32613: PUSH
32614: FOR_TO
32615: IFFALSE 32713
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32617: LD_VAR 0 5
32621: PUSH
32622: LD_VAR 0 4
32626: ARRAY
32627: PUSH
32628: LD_INT 1
32630: ARRAY
32631: PPUSH
32632: LD_VAR 0 5
32636: PUSH
32637: LD_VAR 0 4
32641: ARRAY
32642: PUSH
32643: LD_INT 2
32645: ARRAY
32646: PPUSH
32647: CALL_OW 554
32651: IFFALSE 32711
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32653: LD_ADDR_VAR 0 6
32657: PUSH
32658: LD_VAR 0 6
32662: PPUSH
32663: LD_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PPUSH
32672: LD_VAR 0 5
32676: PUSH
32677: LD_VAR 0 4
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 5
32691: PUSH
32692: LD_VAR 0 4
32696: ARRAY
32697: PUSH
32698: LD_INT 2
32700: ARRAY
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 1
32710: ST_TO_ADDR
// end ;
32711: GO 32614
32713: POP
32714: POP
// ComStop ( bulldozer ) ;
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32724: LD_ADDR_VAR 0 7
32728: PUSH
32729: LD_VAR 0 1
32733: PPUSH
32734: CALL_OW 250
32738: PUSH
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 251
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: ST_TO_ADDR
// for i = tmp downto 1 do
32753: LD_ADDR_VAR 0 4
32757: PUSH
32758: DOUBLE
32759: LD_VAR 0 6
32763: INC
32764: ST_TO_ADDR
32765: LD_INT 1
32767: PUSH
32768: FOR_DOWNTO
32769: IFFALSE 32857
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32771: LD_ADDR_VAR 0 7
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 2
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 6
32798: PPUSH
32799: CALL 32960 0 3
32803: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32804: LD_VAR 0 1
32808: PPUSH
32809: LD_VAR 0 7
32813: PUSH
32814: LD_INT 1
32816: ARRAY
32817: PPUSH
32818: LD_VAR 0 7
32822: PUSH
32823: LD_INT 2
32825: ARRAY
32826: PPUSH
32827: CALL 32864 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32831: LD_ADDR_VAR 0 6
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_VAR 0 7
32845: PUSH
32846: LD_INT 3
32848: ARRAY
32849: PPUSH
32850: CALL_OW 3
32854: ST_TO_ADDR
// end ;
32855: GO 32768
32857: POP
32858: POP
// end ;
32859: LD_VAR 0 3
32863: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32864: LD_INT 0
32866: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32867: LD_VAR 0 2
32871: PPUSH
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 351
32881: PUSH
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 554
32896: AND
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 488
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 428
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: EQUAL
32933: AND
32934: IFFALSE 32955
// AddComMoveXY ( bulldozer , x , y ) ;
32936: LD_VAR 0 1
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 171
// end ;
32955: LD_VAR 0 4
32959: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32960: LD_INT 0
32962: PPUSH
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
// dist := 99999 ;
32969: LD_ADDR_VAR 0 6
32973: PUSH
32974: LD_INT 99999
32976: ST_TO_ADDR
// for i = 1 to list do
32977: LD_ADDR_VAR 0 5
32981: PUSH
32982: DOUBLE
32983: LD_INT 1
32985: DEC
32986: ST_TO_ADDR
32987: LD_VAR 0 3
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33131
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32995: LD_ADDR_VAR 0 7
32999: PUSH
33000: LD_VAR 0 1
33004: PPUSH
33005: LD_VAR 0 2
33009: PPUSH
33010: LD_VAR 0 3
33014: PUSH
33015: LD_VAR 0 5
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PPUSH
33025: LD_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: ARRAY
33035: PUSH
33036: LD_INT 2
33038: ARRAY
33039: PPUSH
33040: CALL_OW 298
33044: ST_TO_ADDR
// if d = 0 then
33045: LD_VAR 0 7
33049: PUSH
33050: LD_INT 0
33052: EQUAL
33053: IFFALSE 33057
// continue ;
33055: GO 32992
// if d < dist then
33057: LD_VAR 0 7
33061: PUSH
33062: LD_VAR 0 6
33066: LESS
33067: IFFALSE 33129
// begin _x := list [ i ] [ 1 ] ;
33069: LD_ADDR_VAR 0 8
33073: PUSH
33074: LD_VAR 0 3
33078: PUSH
33079: LD_VAR 0 5
33083: ARRAY
33084: PUSH
33085: LD_INT 1
33087: ARRAY
33088: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33089: LD_ADDR_VAR 0 9
33093: PUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 2
33107: ARRAY
33108: ST_TO_ADDR
// _i := i ;
33109: LD_ADDR_VAR 0 10
33113: PUSH
33114: LD_VAR 0 5
33118: ST_TO_ADDR
// dist := d ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_VAR 0 7
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32992
33131: POP
33132: POP
// result := [ _x , _y , _i , dist ] ;
33133: LD_ADDR_VAR 0 4
33137: PUSH
33138: LD_VAR 0 8
33142: PUSH
33143: LD_VAR 0 9
33147: PUSH
33148: LD_VAR 0 10
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: ST_TO_ADDR
// end ;
33164: LD_VAR 0 4
33168: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
// for i = 1 to list do
33176: LD_ADDR_VAR 0 5
33180: PUSH
33181: DOUBLE
33182: LD_INT 1
33184: DEC
33185: ST_TO_ADDR
33186: LD_VAR 0 1
33190: PUSH
33191: FOR_TO
33192: IFFALSE 33506
// begin for j = list downto 2 do
33194: LD_ADDR_VAR 0 6
33198: PUSH
33199: DOUBLE
33200: LD_VAR 0 1
33204: INC
33205: ST_TO_ADDR
33206: LD_INT 2
33208: PUSH
33209: FOR_DOWNTO
33210: IFFALSE 33502
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33212: LD_VAR 0 2
33216: PPUSH
33217: LD_VAR 0 3
33221: PPUSH
33222: LD_VAR 0 1
33226: PUSH
33227: LD_VAR 0 6
33231: ARRAY
33232: PUSH
33233: LD_INT 1
33235: ARRAY
33236: PPUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_VAR 0 6
33246: ARRAY
33247: PUSH
33248: LD_INT 2
33250: ARRAY
33251: PPUSH
33252: CALL_OW 298
33256: PUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_INT 1
33279: MINUS
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PPUSH
33286: LD_VAR 0 1
33290: PUSH
33291: LD_VAR 0 6
33295: PUSH
33296: LD_INT 1
33298: MINUS
33299: ARRAY
33300: PUSH
33301: LD_INT 2
33303: ARRAY
33304: PPUSH
33305: CALL_OW 298
33309: LESS
33310: IFFALSE 33500
// begin _x := list [ j ] [ 1 ] ;
33312: LD_ADDR_VAR 0 7
33316: PUSH
33317: LD_VAR 0 1
33321: PUSH
33322: LD_VAR 0 6
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33332: LD_ADDR_VAR 0 8
33336: PUSH
33337: LD_VAR 0 1
33341: PUSH
33342: LD_VAR 0 6
33346: ARRAY
33347: PUSH
33348: LD_INT 2
33350: ARRAY
33351: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_VAR 0 1
33361: PPUSH
33362: LD_VAR 0 6
33366: PPUSH
33367: LD_INT 1
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: CALL 31130 0 4
33393: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_VAR 0 1
33403: PPUSH
33404: LD_VAR 0 6
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 1
33416: PUSH
33417: LD_VAR 0 6
33421: PUSH
33422: LD_INT 1
33424: MINUS
33425: ARRAY
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: CALL 31130 0 4
33435: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PUSH
33451: LD_INT 1
33453: MINUS
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: LD_VAR 0 7
33462: PPUSH
33463: CALL 31130 0 4
33467: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33468: LD_ADDR_VAR 0 1
33472: PUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 6
33482: PUSH
33483: LD_INT 1
33485: MINUS
33486: PPUSH
33487: LD_INT 2
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: CALL 31130 0 4
33499: ST_TO_ADDR
// end ; end ;
33500: GO 33209
33502: POP
33503: POP
// end ;
33504: GO 33191
33506: POP
33507: POP
// result := list ;
33508: LD_ADDR_VAR 0 4
33512: PUSH
33513: LD_VAR 0 1
33517: ST_TO_ADDR
// end ;
33518: LD_VAR 0 4
33522: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33523: LD_INT 0
33525: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33526: LD_ADDR_VAR 0 5
33530: PUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: LD_VAR 0 2
33540: PPUSH
33541: CALL_OW 546
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PUSH
33550: LD_VAR 0 3
33554: PPUSH
33555: LD_VAR 0 4
33559: PPUSH
33560: CALL_OW 546
33564: PUSH
33565: LD_INT 2
33567: ARRAY
33568: MINUS
33569: ST_TO_ADDR
// if result < 0 then
33570: LD_VAR 0 5
33574: PUSH
33575: LD_INT 0
33577: LESS
33578: IFFALSE 33595
// result := result * - 1 ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_VAR 0 5
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: MUL
33594: ST_TO_ADDR
// end ;
33595: LD_VAR 0 5
33599: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
// area = ListEnvironmentArea ( area ) ;
33604: LD_ADDR_VAR 0 2
33608: PUSH
33609: LD_VAR 0 2
33613: PPUSH
33614: CALL_OW 353
33618: ST_TO_ADDR
// if bulldozer > 0 then
33619: LD_VAR 0 1
33623: PUSH
33624: LD_INT 0
33626: GREATER
33627: IFFALSE 33738
// for i = area downto 1 do
33629: LD_ADDR_VAR 0 4
33633: PUSH
33634: DOUBLE
33635: LD_VAR 0 2
33639: INC
33640: ST_TO_ADDR
33641: LD_INT 1
33643: PUSH
33644: FOR_DOWNTO
33645: IFFALSE 33736
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33647: LD_VAR 0 2
33651: PUSH
33652: LD_VAR 0 4
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_VAR 0 2
33666: PUSH
33667: LD_VAR 0 4
33671: ARRAY
33672: PUSH
33673: LD_INT 2
33675: ARRAY
33676: PPUSH
33677: CALL_OW 351
33681: IFFALSE 33734
// if not HasTask ( bulldozer ) then
33683: LD_VAR 0 1
33687: PPUSH
33688: CALL_OW 314
33692: NOT
33693: IFFALSE 33734
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33695: LD_VAR 0 1
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_VAR 0 4
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PPUSH
33715: LD_VAR 0 2
33719: PUSH
33720: LD_VAR 0 4
33724: ARRAY
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: PPUSH
33730: CALL_OW 171
33734: GO 33644
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 3
33742: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33749: LD_ADDR_VAR 0 6
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_VAR 0 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 21
33768: PUSH
33769: LD_VAR 0 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PPUSH
33782: CALL_OW 69
33786: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33787: LD_ADDR_VAR 0 7
33791: PUSH
33792: LD_VAR 0 3
33796: PPUSH
33797: LD_INT 22
33799: PUSH
33800: LD_VAR 0 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 21
33811: PUSH
33812: LD_VAR 0 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PPUSH
33825: CALL_OW 70
33829: ST_TO_ADDR
// if tmp and pom then
33830: LD_VAR 0 6
33834: PUSH
33835: LD_VAR 0 7
33839: AND
33840: IFFALSE 33860
// result := tmp diff pom else
33842: LD_ADDR_VAR 0 4
33846: PUSH
33847: LD_VAR 0 6
33851: PUSH
33852: LD_VAR 0 7
33856: DIFF
33857: ST_TO_ADDR
33858: GO 33868
// result := false ;
33860: LD_ADDR_VAR 0 4
33864: PUSH
33865: LD_INT 0
33867: ST_TO_ADDR
// end ;
33868: LD_VAR 0 4
33872: RET
// export function SavePosition ( unit ) ; begin
33873: LD_INT 0
33875: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: LD_VAR 0 1
33885: PPUSH
33886: CALL_OW 250
33890: PPUSH
33891: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 251
33909: PPUSH
33910: CALL_OW 232
// end ;
33914: LD_VAR 0 2
33918: RET
// export function GetPosition ( unit ) ; begin
33919: LD_INT 0
33921: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33922: LD_ADDR_VAR 0 2
33926: PUSH
33927: LD_VAR 0 1
33931: PPUSH
33932: CALL_OW 252
33936: PUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL_OW 253
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: ST_TO_ADDR
// end ;
33951: LD_VAR 0 2
33955: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33956: LD_INT 0
33958: PPUSH
// if unit in unreachableList then
33959: LD_VAR 0 1
33963: PUSH
33964: LD_EXP 30
33968: IN
33969: IFFALSE 33987
// unreachableList := unreachableList diff unit ;
33971: LD_ADDR_EXP 30
33975: PUSH
33976: LD_EXP 30
33980: PUSH
33981: LD_VAR 0 1
33985: DIFF
33986: ST_TO_ADDR
// if ValidHex ( x , y ) then
33987: LD_VAR 0 2
33991: PPUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: CALL_OW 488
34001: IFFALSE 34027
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_VAR 0 2
34012: PPUSH
34013: LD_VAR 0 3
34017: PPUSH
34018: CALL_OW 428
34022: PPUSH
34023: CALL_OW 115
// Wait ( 3 ) ;
34027: LD_INT 3
34029: PPUSH
34030: CALL_OW 67
// if unit in unreachableList then
34034: LD_VAR 0 1
34038: PUSH
34039: LD_EXP 30
34043: IN
34044: IFFALSE 34056
// result := false else
34046: LD_ADDR_VAR 0 4
34050: PUSH
34051: LD_INT 0
34053: ST_TO_ADDR
34054: GO 34064
// result := true ;
34056: LD_ADDR_VAR 0 4
34060: PUSH
34061: LD_INT 1
34063: ST_TO_ADDR
// end ; end_of_file
34064: LD_VAR 0 4
34068: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34069: LD_EXP 31
34073: IFFALSE 34135
34075: GO 34077
34077: DISABLE
34078: LD_INT 0
34080: PPUSH
// begin enable ;
34081: ENABLE
// for i = 1 to mc_crates_list do
34082: LD_ADDR_VAR 0 1
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 32
34096: PUSH
34097: FOR_TO
34098: IFFALSE 34129
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34100: LD_EXP 32
34104: PUSH
34105: LD_VAR 0 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 5
34113: PPUSH
34114: LD_INT 50
34116: PPUSH
34117: LD_INT 700
34119: PPUSH
34120: LD_INT 20
34122: PPUSH
34123: CALL 24485 0 5
34127: GO 34097
34129: POP
34130: POP
// MC_Game ( ) ;
34131: CALL 34138 0 0
// end ;
34135: PPOPN 1
34137: END
// export function MC_Game ( ) ; var i , side , un ; begin
34138: LD_INT 0
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not isTest then
34144: LD_EXP 1
34148: NOT
34149: IFFALSE 34169
// MC_Show ( [ #tick , tick ] ) else
34151: LD_STRING #tick
34153: PUSH
34154: LD_OWVAR 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PPUSH
34163: CALL 8569 0 1
34167: GO 34178
// MC_Show ( debug_string ) ;
34169: LD_EXP 2
34173: PPUSH
34174: CALL 8569 0 1
// for side = 1 to 8 do
34178: LD_ADDR_VAR 0 3
34182: PUSH
34183: DOUBLE
34184: LD_INT 1
34186: DEC
34187: ST_TO_ADDR
34188: LD_INT 8
34190: PUSH
34191: FOR_TO
34192: IFFALSE 36192
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34194: LD_EXP 39
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PUSH
34205: LD_INT 0
34207: EQUAL
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: EMPTY
34215: PPUSH
34216: CALL 11786 0 2
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: OR
34225: IFFALSE 34229
// continue ;
34227: GO 34191
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34229: LD_VAR 0 3
34233: PPUSH
34234: LD_VAR 0 3
34238: PPUSH
34239: CALL 25006 0 1
34243: PPUSH
34244: CALL 36199 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34248: LD_EXP 71
34252: PUSH
34253: LD_VAR 0 3
34257: ARRAY
34258: PUSH
34259: LD_INT 1
34261: ARRAY
34262: PUSH
34263: LD_INT 0
34265: GREATER
34266: PUSH
34267: LD_EXP 69
34271: PUSH
34272: LD_VAR 0 3
34276: ARRAY
34277: PUSH
34278: LD_INT 1
34280: ARRAY
34281: PUSH
34282: LD_INT 0
34284: EQUAL
34285: AND
34286: PUSH
34287: LD_VAR 0 3
34291: PPUSH
34292: LD_INT 7
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL 12354 0 3
34301: NOT
34302: AND
34303: IFFALSE 34340
// begin for i in MREG_Attackers [ side ] do
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_EXP 71
34314: PUSH
34315: LD_VAR 0 3
34319: ARRAY
34320: PUSH
34321: FOR_IN
34322: IFFALSE 34338
// SetTag ( i , 7 ) ;
34324: LD_VAR 0 2
34328: PPUSH
34329: LD_INT 7
34331: PPUSH
34332: CALL_OW 109
34336: GO 34321
34338: POP
34339: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34340: LD_VAR 0 3
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: EMPTY
34349: PPUSH
34350: CALL 12354 0 3
34354: IFFALSE 34414
// begin if side = 1 then
34356: LD_VAR 0 3
34360: PUSH
34361: LD_INT 1
34363: EQUAL
34364: IFFALSE 34373
// RaiseSailEvent ( 101 ) ;
34366: LD_INT 101
34368: PPUSH
34369: CALL_OW 427
// if side = 4 then
34373: LD_VAR 0 3
34377: PUSH
34378: LD_INT 4
34380: EQUAL
34381: IFFALSE 34390
// RaiseSailEvent ( 102 ) ;
34383: LD_INT 102
34385: PPUSH
34386: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: LD_INT 7
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL 12354 0 3
34409: PPUSH
34410: CALL 8487 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 18034 0 1
34423: PUSH
34424: LD_VAR 0 3
34428: PPUSH
34429: CALL 11690 0 1
34433: AND
34434: IFFALSE 34445
// MCL_Start ( side ) ;
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 17991 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34445: LD_ADDR_EXP 35
34449: PUSH
34450: LD_EXP 35
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL 19291 0 1
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34475: LD_ADDR_EXP 47
34479: PUSH
34480: LD_EXP 47
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL 11104 0 1
34499: PPUSH
34500: CALL_OW 1
34504: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34505: LD_VAR 0 3
34509: PPUSH
34510: LD_INT 21
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PPUSH
34520: CALL 11651 0 2
34524: IFFALSE 34535
// MCV_CheckStatus ( side ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL 27188 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 53
34544: PPUSH
34545: CALL 42999 0 2
34549: IFFALSE 34634
// begin for i = MREG_ToChangeClass downto 1 do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_EXP 53
34561: INC
34562: ST_TO_ADDR
34563: LD_INT 1
34565: PUSH
34566: FOR_DOWNTO
34567: IFFALSE 34632
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34569: LD_EXP 53
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 1
34582: ARRAY
34583: PUSH
34584: LD_VAR 0 3
34588: EQUAL
34589: IFFALSE 34630
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34591: LD_VAR 0 3
34595: PPUSH
34596: LD_EXP 53
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_INT 2
34609: ARRAY
34610: PPUSH
34611: LD_EXP 53
34615: PUSH
34616: LD_VAR 0 2
34620: ARRAY
34621: PUSH
34622: LD_INT 3
34624: ARRAY
34625: PPUSH
34626: CALL 16558 0 3
// end ; end ;
34630: GO 34566
34632: POP
34633: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34634: LD_INT 1
34636: PUSH
34637: LD_EXP 38
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: IN
34648: IFFALSE 34659
// begin MCN_TrainApe ( side ) ;
34650: LD_VAR 0 3
34654: PPUSH
34655: CALL 18944 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34659: LD_VAR 0 3
34663: PPUSH
34664: LD_INT 30
34666: PUSH
34667: LD_INT 3
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PPUSH
34674: CALL 11651 0 2
34678: IFFALSE 34852
// begin if MCF_Tag ( side , 10 , [ ] ) then
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 10
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL 12354 0 3
34694: IFFALSE 34741
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12354 0 3
34710: PPUSH
34711: LD_VAR 0 3
34715: PPUSH
34716: LD_INT 30
34718: PUSH
34719: LD_INT 3
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PPUSH
34726: CALL 11651 0 2
34730: PUSH
34731: LD_INT 1
34733: ARRAY
34734: PPUSH
34735: CALL_OW 168
// end else
34739: GO 34852
// if MREG_ToConstruct [ side ] then
34741: LD_EXP 51
34745: PUSH
34746: LD_VAR 0 3
34750: ARRAY
34751: IFFALSE 34852
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_VAR 0 3
34762: PPUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 3
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PPUSH
34773: CALL 11651 0 2
34777: PUSH
34778: LD_INT 1
34780: ARRAY
34781: PPUSH
34782: LD_EXP 51
34786: PUSH
34787: LD_VAR 0 3
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_EXP 51
34801: PUSH
34802: LD_VAR 0 3
34806: ARRAY
34807: PUSH
34808: LD_INT 2
34810: ARRAY
34811: PUSH
34812: LD_EXP 51
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 3
34825: ARRAY
34826: PUSH
34827: LD_EXP 51
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 4
34840: ARRAY
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL 25496 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34852: LD_VAR 0 3
34856: PPUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL 11651 0 2
34871: PUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_EXP 43
34881: PPUSH
34882: CALL 42999 0 2
34886: AND
34887: PUSH
34888: LD_INT 22
34890: PUSH
34891: LD_VAR 0 3
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 33
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 32
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 35
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL_OW 69
34947: AND
34948: IFFALSE 34959
// MCV_Turret ( side ) ;
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 25933 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34959: LD_EXP 42
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: GREATER
34973: PUSH
34974: LD_VAR 0 3
34978: PPUSH
34979: CALL 25006 0 1
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: AND
34988: IFFALSE 35150
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34990: LD_EXP 42
34994: PUSH
34995: LD_VAR 0 3
34999: ARRAY
35000: PUSH
35001: LD_INT 1
35003: ARRAY
35004: PPUSH
35005: CALL_OW 353
35009: IFFALSE 35047
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35011: LD_EXP 42
35015: PUSH
35016: LD_VAR 0 3
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: PPUSH
35026: LD_EXP 42
35030: PUSH
35031: LD_VAR 0 3
35035: ARRAY
35036: PUSH
35037: LD_INT 1
35039: ARRAY
35040: PPUSH
35041: CALL 32428 0 2
35045: GO 35150
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PPUSH
35062: CALL 11651 0 2
35066: IFFALSE 35150
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35068: LD_VAR 0 3
35072: PPUSH
35073: LD_INT 30
35075: PUSH
35076: LD_INT 3
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PPUSH
35083: CALL 11651 0 2
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 2
35099: EQUAL
35100: IFFALSE 35150
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35102: LD_EXP 42
35106: PUSH
35107: LD_VAR 0 3
35111: ARRAY
35112: PUSH
35113: LD_INT 2
35115: ARRAY
35116: PPUSH
35117: LD_INT 10
35119: PPUSH
35120: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35124: LD_ADDR_EXP 42
35128: PUSH
35129: LD_EXP 42
35133: PPUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PPUSH
35165: CALL 11651 0 2
35169: IFFALSE 35209
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PPUSH
35191: CALL 11651 0 2
35195: PUSH
35196: LD_INT 1
35198: ARRAY
35199: PPUSH
35200: CALL_OW 248
35204: PPUSH
35205: CALL 26487 0 2
// if MREG_ToRepair [ side ] then
35209: LD_EXP 47
35213: PUSH
35214: LD_VAR 0 3
35218: ARRAY
35219: IFFALSE 35232
// begin MCB_Repair ( side ) ;
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL 11391 0 1
// end else
35230: GO 36145
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35232: LD_VAR 0 3
35236: PPUSH
35237: LD_EXP 49
35241: PPUSH
35242: CALL 42999 0 2
35246: PUSH
35247: LD_VAR 0 3
35251: PPUSH
35252: LD_EXP 40
35256: PPUSH
35257: CALL 42999 0 2
35261: AND
35262: IFFALSE 35470
// begin for i = 1 to MREG_ToUpLab do
35264: LD_ADDR_VAR 0 2
35268: PUSH
35269: DOUBLE
35270: LD_INT 1
35272: DEC
35273: ST_TO_ADDR
35274: LD_EXP 49
35278: PUSH
35279: FOR_TO
35280: IFFALSE 35466
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35282: LD_EXP 49
35286: PUSH
35287: LD_VAR 0 2
35291: ARRAY
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PUSH
35297: LD_VAR 0 3
35301: EQUAL
35302: IFFALSE 35464
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35304: LD_EXP 49
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PUSH
35319: LD_EXP 49
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: PUSH
35330: LD_INT 3
35332: ARRAY
35333: AND
35334: IFFALSE 35462
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: LD_EXP 49
35345: PUSH
35346: LD_VAR 0 2
35350: ARRAY
35351: PUSH
35352: LD_INT 2
35354: ARRAY
35355: PPUSH
35356: LD_EXP 49
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 3
35369: ARRAY
35370: PPUSH
35371: CALL 8915 0 3
35375: IFFALSE 35462
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35377: LD_ADDR_EXP 49
35381: PUSH
35382: LD_EXP 49
35386: PPUSH
35387: LD_VAR 0 3
35391: PPUSH
35392: LD_EXP 49
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: PUSH
35403: LD_INT 2
35405: ARRAY
35406: PPUSH
35407: LD_EXP 49
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 3
35420: ARRAY
35421: PPUSH
35422: CALL 42051 0 4
35426: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35427: LD_ADDR_EXP 40
35431: PUSH
35432: LD_EXP 40
35436: PPUSH
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_EXP 40
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL 42051 0 4
35461: ST_TO_ADDR
// end ; break ;
35462: GO 35466
// end ;
35464: GO 35279
35466: POP
35467: POP
// end else
35468: GO 36145
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: LD_EXP 48
35479: PPUSH
35480: CALL 42999 0 2
35484: IFFALSE 35558
// begin for i = 1 to MREG_ToUpdate do
35486: LD_ADDR_VAR 0 2
35490: PUSH
35491: DOUBLE
35492: LD_INT 1
35494: DEC
35495: ST_TO_ADDR
35496: LD_EXP 48
35500: PUSH
35501: FOR_TO
35502: IFFALSE 35554
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35504: LD_EXP 48
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PUSH
35519: LD_VAR 0 3
35523: EQUAL
35524: IFFALSE 35552
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_EXP 48
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_INT 2
35544: ARRAY
35545: PPUSH
35546: CALL 8751 0 2
// break ;
35550: GO 35554
// end ;
35552: GO 35501
35554: POP
35555: POP
// end else
35556: GO 36145
// if MCF_Get ( side , [ f_constructed ] ) then
35558: LD_VAR 0 3
35562: PPUSH
35563: LD_INT 57
35565: PUSH
35566: EMPTY
35567: LIST
35568: PPUSH
35569: CALL 11651 0 2
35573: IFFALSE 35606
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_INT 57
35587: PUSH
35588: EMPTY
35589: LIST
35590: PPUSH
35591: CALL 11651 0 2
35595: PUSH
35596: LD_INT 1
35598: ARRAY
35599: PPUSH
35600: CALL 10995 0 2
35604: GO 36145
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_EXP 46
35615: PPUSH
35616: CALL 42999 0 2
35620: PUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 345
35630: NOT
35631: AND
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL 25006 0 1
35642: PUSH
35643: LD_INT 0
35645: EQUAL
35646: AND
35647: IFFALSE 36046
// begin for i = 1 to MREG_ToBuild do
35649: LD_ADDR_VAR 0 2
35653: PUSH
35654: DOUBLE
35655: LD_INT 1
35657: DEC
35658: ST_TO_ADDR
35659: LD_EXP 46
35663: PUSH
35664: FOR_TO
35665: IFFALSE 36042
// if MREG_ToBuild [ i ] [ 1 ] = side then
35667: LD_EXP 46
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 1
35680: ARRAY
35681: PUSH
35682: LD_VAR 0 3
35686: EQUAL
35687: IFFALSE 36040
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35689: LD_OWVAR 84
35693: PUSH
35694: LD_EXP 46
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 3
35707: ARRAY
35708: PUSH
35709: LD_INT 1
35711: ARRAY
35712: PPUSH
35713: LD_EXP 46
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PUSH
35728: LD_INT 2
35730: ARRAY
35731: PPUSH
35732: CALL_OW 351
35736: AND
35737: IFFALSE 35781
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35739: LD_EXP 46
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 46
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL 22799 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35781: LD_EXP 46
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 2
35794: ARRAY
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: IFFALSE 35869
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35801: LD_VAR 0 3
35805: PPUSH
35806: LD_EXP 46
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PUSH
35821: LD_INT 1
35823: ARRAY
35824: PPUSH
35825: LD_EXP 46
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 3
35838: ARRAY
35839: PUSH
35840: LD_INT 2
35842: ARRAY
35843: PPUSH
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 3
35857: ARRAY
35858: PUSH
35859: LD_INT 3
35861: ARRAY
35862: PPUSH
35863: CALL 8587 0 4
35867: GO 36038
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PUSH
35884: LD_INT 6
35886: EQUAL
35887: IFFALSE 35957
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35889: LD_VAR 0 3
35893: PPUSH
35894: LD_EXP 46
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 3
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PPUSH
35913: LD_EXP 46
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 3
35926: ARRAY
35927: PUSH
35928: LD_INT 2
35930: ARRAY
35931: PPUSH
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL 8716 0 4
35955: GO 36038
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35957: LD_VAR 0 3
35961: PPUSH
35962: LD_EXP 46
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 46
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PPUSH
35996: LD_EXP 46
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 2
36013: ARRAY
36014: PPUSH
36015: LD_EXP 46
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 3
36028: ARRAY
36029: PUSH
36030: LD_INT 3
36032: ARRAY
36033: PPUSH
36034: CALL 10220 0 5
// break ;
36038: GO 36042
// end ;
36040: GO 35664
36042: POP
36043: POP
// end else
36044: GO 36145
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36046: LD_VAR 0 3
36050: PPUSH
36051: LD_EXP 52
36055: PPUSH
36056: CALL 42999 0 2
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL 25006 0 1
36070: PUSH
36071: LD_INT 0
36073: EQUAL
36074: AND
36075: IFFALSE 36145
// begin for i = 1 to MREG_ToDismantle do
36077: LD_ADDR_VAR 0 2
36081: PUSH
36082: DOUBLE
36083: LD_INT 1
36085: DEC
36086: ST_TO_ADDR
36087: LD_EXP 52
36091: PUSH
36092: FOR_TO
36093: IFFALSE 36143
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36095: LD_EXP 52
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PUSH
36106: LD_INT 1
36108: ARRAY
36109: PUSH
36110: LD_VAR 0 3
36114: EQUAL
36115: IFFALSE 36141
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36117: LD_VAR 0 3
36121: PPUSH
36122: LD_EXP 52
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: CALL 10886 0 2
// end ;
36141: GO 36092
36143: POP
36144: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36145: LD_VAR 0 3
36149: PPUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PPUSH
36160: CALL 11651 0 2
36164: PUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL 25006 0 1
36174: PUSH
36175: LD_INT 0
36177: EQUAL
36178: AND
36179: IFFALSE 36190
// MCT_CollectCrates ( side ) ;
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 23945 0 1
// end ;
36190: GO 34191
36192: POP
36193: POP
// end ;
36194: LD_VAR 0 1
36198: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36199: LD_INT 0
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
// all := MCF_All ( side , [ ] ) ;
36216: LD_ADDR_VAR 0 17
36220: PUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL 11786 0 2
36232: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36233: LD_ADDR_VAR 0 13
36237: PUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_INT 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL 11734 0 3
36252: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36253: LD_ADDR_VAR 0 14
36257: PUSH
36258: LD_VAR 0 1
36262: PPUSH
36263: LD_INT 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL 11734 0 3
36272: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36273: LD_ADDR_VAR 0 15
36277: PUSH
36278: LD_VAR 0 1
36282: PPUSH
36283: LD_INT 3
36285: PPUSH
36286: EMPTY
36287: PPUSH
36288: CALL 11734 0 3
36292: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36293: LD_ADDR_VAR 0 16
36297: PUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_INT 4
36305: PPUSH
36306: EMPTY
36307: PPUSH
36308: CALL 11734 0 3
36312: ST_TO_ADDR
// if mech then
36313: LD_VAR 0 15
36317: IFFALSE 36334
// mech := MCF_SortListDesc ( mech ) ;
36319: LD_ADDR_VAR 0 15
36323: PUSH
36324: LD_VAR 0 15
36328: PPUSH
36329: CALL 12900 0 1
36333: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36334: LD_EXP 56
36338: PUSH
36339: LD_VAR 0 1
36343: ARRAY
36344: PUSH
36345: LD_STRING 
36347: EQUAL
36348: NOT
36349: IFFALSE 36405
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36351: LD_EXP 56
36355: PUSH
36356: LD_VAR 0 1
36360: ARRAY
36361: PUSH
36362: LD_INT 1
36364: ARRAY
36365: PPUSH
36366: CALL_OW 257
36370: PUSH
36371: LD_INT 1
36373: EQUAL
36374: IFFALSE 36403
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36376: LD_VAR 0 1
36380: PPUSH
36381: LD_STRING ToArm
36383: PPUSH
36384: LD_EXP 56
36388: PUSH
36389: LD_VAR 0 1
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL 14530 0 3
// end else
36403: GO 36431
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36405: LD_ADDR_EXP 56
36409: PUSH
36410: LD_EXP 56
36414: PPUSH
36415: LD_VAR 0 1
36419: PPUSH
36420: LD_INT 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL 31130 0 4
36430: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36431: LD_EXP 57
36435: PUSH
36436: LD_VAR 0 1
36440: ARRAY
36441: PUSH
36442: LD_STRING 
36444: EQUAL
36445: NOT
36446: IFFALSE 36502
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36448: LD_EXP 57
36452: PUSH
36453: LD_VAR 0 1
36457: ARRAY
36458: PUSH
36459: LD_INT 1
36461: ARRAY
36462: PPUSH
36463: CALL_OW 257
36467: PUSH
36468: LD_INT 2
36470: EQUAL
36471: IFFALSE 36500
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36473: LD_VAR 0 1
36477: PPUSH
36478: LD_STRING ToDep
36480: PPUSH
36481: LD_EXP 57
36485: PUSH
36486: LD_VAR 0 1
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: CALL 14530 0 3
// end else
36500: GO 36528
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36502: LD_ADDR_EXP 57
36506: PUSH
36507: LD_EXP 57
36511: PPUSH
36512: LD_VAR 0 1
36516: PPUSH
36517: LD_INT 1
36519: PPUSH
36520: LD_INT 0
36522: PPUSH
36523: CALL 31130 0 4
36527: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36528: LD_EXP 55
36532: PUSH
36533: LD_VAR 0 1
36537: ARRAY
36538: PUSH
36539: LD_STRING 
36541: EQUAL
36542: NOT
36543: IFFALSE 36599
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36545: LD_EXP 55
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: EQUAL
36568: IFFALSE 36597
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: LD_STRING ToFac
36577: PPUSH
36578: LD_EXP 55
36582: PUSH
36583: LD_VAR 0 1
36587: ARRAY
36588: PUSH
36589: LD_INT 1
36591: ARRAY
36592: PPUSH
36593: CALL 14530 0 3
// end else
36597: GO 36625
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36599: LD_ADDR_EXP 55
36603: PUSH
36604: LD_EXP 55
36608: PPUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: LD_INT 0
36619: PPUSH
36620: CALL 31130 0 4
36624: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36625: LD_EXP 54
36629: PUSH
36630: LD_VAR 0 1
36634: ARRAY
36635: PUSH
36636: LD_STRING 
36638: EQUAL
36639: NOT
36640: IFFALSE 36696
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36642: LD_EXP 54
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL_OW 257
36661: PUSH
36662: LD_INT 4
36664: EQUAL
36665: IFFALSE 36694
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36667: LD_VAR 0 1
36671: PPUSH
36672: LD_STRING ToLab
36674: PPUSH
36675: LD_EXP 54
36679: PUSH
36680: LD_VAR 0 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: CALL 14530 0 3
// end else
36694: GO 36722
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36696: LD_ADDR_EXP 54
36700: PUSH
36701: LD_EXP 54
36705: PPUSH
36706: LD_VAR 0 1
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: LD_INT 0
36716: PPUSH
36717: CALL 31130 0 4
36721: ST_TO_ADDR
// if mode = 0 then
36722: LD_VAR 0 2
36726: PUSH
36727: LD_INT 0
36729: EQUAL
36730: IFFALSE 38568
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36732: LD_VAR 0 1
36736: PPUSH
36737: LD_INT 30
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL 11651 0 2
36751: PUSH
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 21
36759: PUSH
36760: LD_INT 3
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PPUSH
36767: CALL 11651 0 2
36771: PUSH
36772: LD_INT 1
36774: EQUAL
36775: AND
36776: IFFALSE 36841
// begin if all then
36778: LD_VAR 0 17
36782: IFFALSE 36839
// for i in ( all diff eng ) do
36784: LD_ADDR_VAR 0 4
36788: PUSH
36789: LD_VAR 0 17
36793: PUSH
36794: LD_VAR 0 14
36798: DIFF
36799: PUSH
36800: FOR_IN
36801: IFFALSE 36837
// if GetTag ( i ) = 0 then
36803: LD_VAR 0 4
36807: PPUSH
36808: CALL_OW 110
36812: PUSH
36813: LD_INT 0
36815: EQUAL
36816: IFFALSE 36835
// MCH_ChangeClass ( side , i , 2 ) ;
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 2
36830: PPUSH
36831: CALL 16558 0 3
36835: GO 36800
36837: POP
36838: POP
// end else
36839: GO 37160
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36841: LD_VAR 0 13
36845: PUSH
36846: LD_EXP 56
36850: PUSH
36851: LD_VAR 0 1
36855: ARRAY
36856: PLUS
36857: PUSH
36858: LD_INT 22
36860: PUSH
36861: LD_VAR 0 1
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 32
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 69
36888: LESS
36889: IFFALSE 36914
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_VAR 0 14
36900: PUSH
36901: LD_INT 1
36903: ARRAY
36904: PPUSH
36905: LD_INT 1
36907: PPUSH
36908: CALL 16558 0 3
// end else
36912: GO 37160
// if sci < 6 and MCF_Lab ( side ) then
36914: LD_VAR 0 16
36918: PUSH
36919: LD_INT 6
36921: LESS
36922: PUSH
36923: LD_VAR 0 1
36927: PPUSH
36928: CALL 11690 0 1
36932: AND
36933: IFFALSE 37038
// begin if MREG_ToBunker [ side ] then
36935: LD_EXP 68
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: IFFALSE 36971
// tmp := sol diff MREG_ToBunker [ side ] else
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: PUSH
36957: LD_EXP 68
36961: PUSH
36962: LD_VAR 0 1
36966: ARRAY
36967: DIFF
36968: ST_TO_ADDR
36969: GO 36981
// tmp := sol ;
36971: LD_ADDR_VAR 0 12
36975: PUSH
36976: LD_VAR 0 13
36980: ST_TO_ADDR
// if tmp then
36981: LD_VAR 0 12
36985: IFFALSE 37036
// for i in tmp do
36987: LD_ADDR_VAR 0 4
36991: PUSH
36992: LD_VAR 0 12
36996: PUSH
36997: FOR_IN
36998: IFFALSE 37034
// if GetTag ( i ) = 0 then
37000: LD_VAR 0 4
37004: PPUSH
37005: CALL_OW 110
37009: PUSH
37010: LD_INT 0
37012: EQUAL
37013: IFFALSE 37032
// MCH_ChangeClass ( side , i , 4 ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: LD_INT 4
37027: PPUSH
37028: CALL 16558 0 3
37032: GO 36997
37034: POP
37035: POP
// end else
37036: GO 37160
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37038: LD_VAR 0 1
37042: PPUSH
37043: LD_INT 30
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL 11651 0 2
37057: IFFALSE 37160
// begin if MREG_ToBunker [ side ] then
37059: LD_EXP 68
37063: PUSH
37064: LD_VAR 0 1
37068: ARRAY
37069: IFFALSE 37095
// tmp := sol diff MREG_ToBunker [ side ] else
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: PUSH
37081: LD_EXP 68
37085: PUSH
37086: LD_VAR 0 1
37090: ARRAY
37091: DIFF
37092: ST_TO_ADDR
37093: GO 37105
// tmp := sol ;
37095: LD_ADDR_VAR 0 12
37099: PUSH
37100: LD_VAR 0 13
37104: ST_TO_ADDR
// if tmp then
37105: LD_VAR 0 12
37109: IFFALSE 37160
// for i in tmp do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 12
37120: PUSH
37121: FOR_IN
37122: IFFALSE 37158
// if GetTag ( i ) = 0 then
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL_OW 110
37133: PUSH
37134: LD_INT 0
37136: EQUAL
37137: IFFALSE 37156
// MCH_ChangeClass ( side , i , 2 ) ;
37139: LD_VAR 0 1
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: LD_INT 2
37151: PPUSH
37152: CALL 16558 0 3
37156: GO 37121
37158: POP
37159: POP
// end ; if MCF_Lab ( side ) then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL 11690 0 1
37169: IFFALSE 37709
// begin if MCL_GetTechList ( side ) then
37171: LD_VAR 0 1
37175: PPUSH
37176: CALL 18034 0 1
37180: IFFALSE 37306
// begin if MREG_ToLab [ side ] then
37182: LD_EXP 54
37186: PUSH
37187: LD_VAR 0 1
37191: ARRAY
37192: IFFALSE 37212
// k := MREG_ToLab [ side ] else
37194: LD_ADDR_VAR 0 8
37198: PUSH
37199: LD_EXP 54
37203: PUSH
37204: LD_VAR 0 1
37208: ARRAY
37209: ST_TO_ADDR
37210: GO 37220
// k := 0 ;
37212: LD_ADDR_VAR 0 8
37216: PUSH
37217: LD_INT 0
37219: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37220: LD_VAR 0 16
37224: PUSH
37225: LD_VAR 0 8
37229: PLUS
37230: PUSH
37231: LD_INT 6
37233: LESSEQUAL
37234: PUSH
37235: LD_VAR 0 17
37239: PUSH
37240: LD_INT 6
37242: GREATER
37243: AND
37244: IFFALSE 37260
// MCH_TrainScientist ( side , 1 ) else
37246: LD_VAR 0 1
37250: PPUSH
37251: LD_INT 1
37253: PPUSH
37254: CALL 16110 0 2
37258: GO 37304
// if all < 6 then
37260: LD_VAR 0 17
37264: PUSH
37265: LD_INT 6
37267: LESS
37268: IFFALSE 37304
// if sci + k < all / 2 then
37270: LD_VAR 0 16
37274: PUSH
37275: LD_VAR 0 8
37279: PLUS
37280: PUSH
37281: LD_VAR 0 17
37285: PUSH
37286: LD_INT 2
37288: DIVREAL
37289: LESS
37290: IFFALSE 37304
// MCH_TrainScientist ( side , 1 ) ;
37292: LD_VAR 0 1
37296: PPUSH
37297: LD_INT 1
37299: PPUSH
37300: CALL 16110 0 2
// end else
37304: GO 37382
// begin if sci > 2 then
37306: LD_VAR 0 16
37310: PUSH
37311: LD_INT 2
37313: GREATER
37314: IFFALSE 37382
// for i = sci downto 2 do
37316: LD_ADDR_VAR 0 4
37320: PUSH
37321: DOUBLE
37322: LD_VAR 0 16
37326: INC
37327: ST_TO_ADDR
37328: LD_INT 2
37330: PUSH
37331: FOR_DOWNTO
37332: IFFALSE 37380
// if GetTag ( sci [ i ] ) = 0 then
37334: LD_VAR 0 16
37338: PUSH
37339: LD_VAR 0 4
37343: ARRAY
37344: PPUSH
37345: CALL_OW 110
37349: PUSH
37350: LD_INT 0
37352: EQUAL
37353: IFFALSE 37378
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_VAR 0 16
37364: PUSH
37365: LD_VAR 0 4
37369: ARRAY
37370: PPUSH
37371: LD_INT 2
37373: PPUSH
37374: CALL 16558 0 3
37378: GO 37331
37380: POP
37381: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37382: LD_VAR 0 1
37386: PPUSH
37387: CALL 18034 0 1
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL 11690 0 1
37401: AND
37402: PUSH
37403: LD_EXP 35
37407: PUSH
37408: LD_VAR 0 1
37412: ARRAY
37413: NOT
37414: AND
37415: IFFALSE 37709
// begin for j = 1 to MCF_Lab ( side ) do
37417: LD_ADDR_VAR 0 5
37421: PUSH
37422: DOUBLE
37423: LD_INT 1
37425: DEC
37426: ST_TO_ADDR
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 11690 0 1
37436: PUSH
37437: FOR_TO
37438: IFFALSE 37498
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37440: LD_VAR 0 1
37444: PPUSH
37445: CALL 11690 0 1
37449: PUSH
37450: LD_VAR 0 5
37454: ARRAY
37455: PPUSH
37456: CALL_OW 461
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 6
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: IN
37471: IFFALSE 37496
// begin b := MCF_Lab ( side ) [ j ] ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: CALL 11690 0 1
37487: PUSH
37488: LD_VAR 0 5
37492: ARRAY
37493: ST_TO_ADDR
// break ;
37494: GO 37498
// end ;
37496: GO 37437
37498: POP
37499: POP
// if MCF_Class ( side , 4 , [ ] ) then
37500: LD_VAR 0 1
37504: PPUSH
37505: LD_INT 4
37507: PPUSH
37508: EMPTY
37509: PPUSH
37510: CALL 11734 0 3
37514: IFFALSE 37709
// for j in MCF_Class ( side , 4 , [ ] ) do
37516: LD_ADDR_VAR 0 5
37520: PUSH
37521: LD_VAR 0 1
37525: PPUSH
37526: LD_INT 4
37528: PPUSH
37529: EMPTY
37530: PPUSH
37531: CALL 11734 0 3
37535: PUSH
37536: FOR_IN
37537: IFFALSE 37707
// begin if GetTag ( j ) = 0 then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 110
37548: PUSH
37549: LD_INT 0
37551: EQUAL
37552: IFFALSE 37643
// begin if IsInUnit ( j ) and b then
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 310
37563: PUSH
37564: LD_VAR 0 11
37568: AND
37569: IFFALSE 37617
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37571: LD_VAR 0 5
37575: PPUSH
37576: CALL_OW 310
37580: PPUSH
37581: CALL_OW 461
37585: PUSH
37586: LD_INT 2
37588: EQUAL
37589: PUSH
37590: LD_VAR 0 5
37594: PPUSH
37595: CALL_OW 310
37599: PUSH
37600: LD_VAR 0 11
37604: NONEQUAL
37605: AND
37606: IFFALSE 37617
// ComExitBuilding ( j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 122
// if not IsInUnit ( j ) then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: NOT
37627: IFFALSE 37643
// ComEnterUnit ( j , b ) ;
37629: LD_VAR 0 5
37633: PPUSH
37634: LD_VAR 0 11
37638: PPUSH
37639: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37643: LD_INT 1
37645: PPUSH
37646: LD_VAR 0 5
37650: PPUSH
37651: CALL_OW 255
37655: PPUSH
37656: CALL_OW 321
37660: PUSH
37661: LD_INT 2
37663: EQUAL
37664: PUSH
37665: LD_VAR 0 5
37669: PPUSH
37670: CALL_OW 255
37674: PPUSH
37675: CALL 25006 0 1
37679: PUSH
37680: LD_INT 0
37682: EQUAL
37683: AND
37684: IFFALSE 37705
// MCN_Tame ( GetSide ( j ) , j ) ;
37686: LD_VAR 0 5
37690: PPUSH
37691: CALL_OW 255
37695: PPUSH
37696: LD_VAR 0 5
37700: PPUSH
37701: CALL 18553 0 2
// end ;
37705: GO 37536
37707: POP
37708: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37709: LD_VAR 0 1
37713: PPUSH
37714: LD_INT 30
37716: PUSH
37717: LD_INT 3
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PPUSH
37724: CALL 11651 0 2
37728: IFFALSE 37987
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37730: LD_ADDR_VAR 0 11
37734: PUSH
37735: LD_VAR 0 1
37739: PPUSH
37740: LD_INT 30
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PPUSH
37750: CALL 11651 0 2
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37759: LD_ADDR_VAR 0 12
37763: PUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: LD_INT 0
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 3
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL 12354 0 3
37786: ST_TO_ADDR
// for i = 1 to tmp do
37787: LD_ADDR_VAR 0 4
37791: PUSH
37792: DOUBLE
37793: LD_INT 1
37795: DEC
37796: ST_TO_ADDR
37797: LD_VAR 0 12
37801: PUSH
37802: FOR_TO
37803: IFFALSE 37863
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37805: LD_VAR 0 12
37809: PUSH
37810: LD_VAR 0 4
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: NOT
37821: PUSH
37822: LD_VAR 0 12
37826: PUSH
37827: LD_VAR 0 4
37831: ARRAY
37832: PPUSH
37833: CALL_OW 314
37837: NOT
37838: AND
37839: IFFALSE 37861
// ComEnterUnit ( tmp [ i ] , b ) ;
37841: LD_VAR 0 12
37845: PUSH
37846: LD_VAR 0 4
37850: ARRAY
37851: PPUSH
37852: LD_VAR 0 11
37856: PPUSH
37857: CALL_OW 120
37861: GO 37802
37863: POP
37864: POP
// if MREG_ToFac [ side ] then
37865: LD_EXP 55
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: IFFALSE 37895
// k := MREG_ToFac [ side ] else
37877: LD_ADDR_VAR 0 8
37881: PUSH
37882: LD_EXP 55
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: ST_TO_ADDR
37893: GO 37903
// k := 0 ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_INT 0
37902: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37903: LD_VAR 0 15
37907: PUSH
37908: LD_VAR 0 8
37912: PLUS
37913: PUSH
37914: LD_INT 6
37916: LESSEQUAL
37917: PUSH
37918: LD_VAR 0 17
37922: PUSH
37923: LD_INT 6
37925: GREATER
37926: AND
37927: IFFALSE 37943
// MCH_TrainMechanic ( side , 1 ) else
37929: LD_VAR 0 1
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL 15852 0 2
37941: GO 37987
// if all < 6 then
37943: LD_VAR 0 17
37947: PUSH
37948: LD_INT 6
37950: LESS
37951: IFFALSE 37987
// if mech + k < all / 2 then
37953: LD_VAR 0 15
37957: PUSH
37958: LD_VAR 0 8
37962: PLUS
37963: PUSH
37964: LD_VAR 0 17
37968: PUSH
37969: LD_INT 2
37971: DIVREAL
37972: LESS
37973: IFFALSE 37987
// MCH_TrainMechanic ( side , 1 ) ;
37975: LD_VAR 0 1
37979: PPUSH
37980: LD_INT 1
37982: PPUSH
37983: CALL 15852 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37987: LD_ADDR_VAR 0 10
37991: PUSH
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 30
37999: PUSH
38000: LD_INT 36
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL 11651 0 2
38011: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38012: LD_VAR 0 10
38016: PUSH
38017: LD_VAR 0 15
38021: AND
38022: PUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 3
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL 11734 0 3
38037: AND
38038: IFFALSE 38196
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38040: LD_VAR 0 1
38044: PPUSH
38045: LD_INT 9
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL 12354 0 3
38054: PUSH
38055: LD_INT 3
38057: LESS
38058: IFFALSE 38196
// begin if mech < 3 then
38060: LD_VAR 0 15
38064: PUSH
38065: LD_INT 3
38067: LESS
38068: IFFALSE 38082
// k := mech else
38070: LD_ADDR_VAR 0 8
38074: PUSH
38075: LD_VAR 0 15
38079: ST_TO_ADDR
38080: GO 38090
// k := 3 ;
38082: LD_ADDR_VAR 0 8
38086: PUSH
38087: LD_INT 3
38089: ST_TO_ADDR
// for j = 1 to k do
38090: LD_ADDR_VAR 0 5
38094: PUSH
38095: DOUBLE
38096: LD_INT 1
38098: DEC
38099: ST_TO_ADDR
38100: LD_VAR 0 8
38104: PUSH
38105: FOR_TO
38106: IFFALSE 38164
// if GetClass ( mech [ j ] ) = 3 then
38108: LD_VAR 0 15
38112: PUSH
38113: LD_VAR 0 5
38117: ARRAY
38118: PPUSH
38119: CALL_OW 257
38123: PUSH
38124: LD_INT 3
38126: EQUAL
38127: IFFALSE 38162
// begin SetTag ( mech [ j ] , 9 ) ;
38129: LD_VAR 0 15
38133: PUSH
38134: LD_VAR 0 5
38138: ARRAY
38139: PPUSH
38140: LD_INT 9
38142: PPUSH
38143: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38147: LD_VAR 0 15
38151: PUSH
38152: LD_VAR 0 5
38156: ARRAY
38157: PPUSH
38158: CALL_OW 122
// end ;
38162: GO 38105
38164: POP
38165: POP
// if mech < 6 + k then
38166: LD_VAR 0 15
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_VAR 0 8
38178: PLUS
38179: LESS
38180: IFFALSE 38196
// MCH_TrainMechanic ( side , k ) ;
38182: LD_VAR 0 1
38186: PPUSH
38187: LD_VAR 0 8
38191: PPUSH
38192: CALL 15852 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38196: LD_VAR 0 1
38200: PPUSH
38201: LD_INT 9
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL 12354 0 3
38210: IFFALSE 38301
// for j in MCF_Tag ( side , 9 , [ ] ) do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_VAR 0 1
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL 12354 0 3
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38299
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38235: LD_VAR 0 5
38239: PPUSH
38240: CALL_OW 310
38244: NOT
38245: PUSH
38246: LD_VAR 0 5
38250: PPUSH
38251: CALL 98436 0 1
38255: NOT
38256: AND
38257: IFFALSE 38297
// if ct then
38259: LD_VAR 0 10
38263: IFFALSE 38285
// ComEnterUnit ( j , ct [ 1 ] ) else
38265: LD_VAR 0 5
38269: PPUSH
38270: LD_VAR 0 10
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: PPUSH
38279: CALL_OW 120
38283: GO 38297
// SetTag ( j , 0 ) ;
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_INT 0
38292: PPUSH
38293: CALL_OW 109
38297: GO 38232
38299: POP
38300: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38301: LD_INT 1
38303: PPUSH
38304: LD_VAR 0 1
38308: PPUSH
38309: CALL_OW 321
38313: PUSH
38314: LD_INT 2
38316: EQUAL
38317: PUSH
38318: LD_EXP 35
38322: PUSH
38323: LD_VAR 0 1
38327: ARRAY
38328: NOT
38329: AND
38330: PUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: LD_INT 4
38338: PPUSH
38339: EMPTY
38340: PPUSH
38341: CALL 11734 0 3
38345: AND
38346: IFFALSE 38394
// for j in MCF_Class ( side , 4 , [ ] ) do
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: LD_INT 4
38360: PPUSH
38361: EMPTY
38362: PPUSH
38363: CALL 11734 0 3
38367: PUSH
38368: FOR_IN
38369: IFFALSE 38392
// MCN_Tame ( GetSide ( j ) , j ) ;
38371: LD_VAR 0 5
38375: PPUSH
38376: CALL_OW 255
38380: PPUSH
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL 18553 0 2
38390: GO 38368
38392: POP
38393: POP
// if MREG_DefVeh [ side ] then
38394: LD_EXP 67
38398: PUSH
38399: LD_VAR 0 1
38403: ARRAY
38404: IFFALSE 38568
// begin for i in MREG_DefVeh [ side ] do
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 67
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: PUSH
38422: FOR_IN
38423: IFFALSE 38476
// begin SetTag ( i , 0 ) ;
38425: LD_VAR 0 4
38429: PPUSH
38430: LD_INT 0
38432: PPUSH
38433: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38437: LD_VAR 0 4
38441: PPUSH
38442: LD_EXP 64
38446: PUSH
38447: LD_VAR 0 1
38451: ARRAY
38452: PPUSH
38453: CALL_OW 308
38457: NOT
38458: IFFALSE 38474
// MCV_Parking ( side , i ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: CALL 25741 0 2
// end ;
38474: GO 38422
38476: POP
38477: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38478: LD_VAR 0 1
38482: PPUSH
38483: LD_INT 36
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL 12354 0 3
38492: IFFALSE 38533
// for i in MCF_Tag ( side , 36 , [ ] ) do
38494: LD_ADDR_VAR 0 4
38498: PUSH
38499: LD_VAR 0 1
38503: PPUSH
38504: LD_INT 36
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL 12354 0 3
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38531
// SetTag ( i , 0 ) ;
38517: LD_VAR 0 4
38521: PPUSH
38522: LD_INT 0
38524: PPUSH
38525: CALL_OW 109
38529: GO 38514
38531: POP
38532: POP
// if MREG_DefMobActive [ side ] then
38533: LD_EXP 70
38537: PUSH
38538: LD_VAR 0 1
38542: ARRAY
38543: IFFALSE 38568
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38545: LD_ADDR_EXP 70
38549: PUSH
38550: LD_EXP 70
38554: PPUSH
38555: LD_VAR 0 1
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// end ; end ; if mode > 0 then
38568: LD_VAR 0 2
38572: PUSH
38573: LD_INT 0
38575: GREATER
38576: IFFALSE 40471
// begin if tick <= 15 15$00 then
38578: LD_OWVAR 1
38582: PUSH
38583: LD_INT 31500
38585: LESSEQUAL
38586: IFFALSE 38890
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38588: LD_VAR 0 13
38592: PUSH
38593: LD_VAR 0 1
38597: PPUSH
38598: CALL 25006 0 1
38602: PUSH
38603: LD_INT 4
38605: LESS
38606: AND
38607: IFFALSE 38718
// begin for i in sol do
38609: LD_ADDR_VAR 0 4
38613: PUSH
38614: LD_VAR 0 13
38618: PUSH
38619: FOR_IN
38620: IFFALSE 38716
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38622: LD_ADDR_VAR 0 8
38626: PUSH
38627: LD_VAR 0 1
38631: PPUSH
38632: CALL 25006 0 1
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: CALL_OW 74
38646: ST_TO_ADDR
// if IsInUnit ( i ) then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 310
38656: IFFALSE 38667
// ComExitBuilding ( i ) ;
38658: LD_VAR 0 4
38662: PPUSH
38663: CALL_OW 122
// if not HasTask ( i ) and k then
38667: LD_VAR 0 4
38671: PPUSH
38672: CALL_OW 314
38676: NOT
38677: PUSH
38678: LD_VAR 0 8
38682: AND
38683: IFFALSE 38714
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38685: LD_VAR 0 4
38689: PPUSH
38690: LD_VAR 0 8
38694: PPUSH
38695: CALL_OW 250
38699: PPUSH
38700: LD_VAR 0 8
38704: PPUSH
38705: CALL_OW 251
38709: PPUSH
38710: CALL_OW 174
// end ;
38714: GO 38619
38716: POP
38717: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38718: LD_VAR 0 1
38722: PPUSH
38723: LD_INT 30
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PPUSH
38733: CALL 11651 0 2
38737: IFFALSE 38888
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38739: LD_ADDR_VAR 0 11
38743: PUSH
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 30
38751: PUSH
38752: LD_INT 5
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL 11651 0 2
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: ST_TO_ADDR
// if mech then
38768: LD_VAR 0 15
38772: IFFALSE 38808
// for i in mech do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 15
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38806
// MCH_ChangeClass ( side , i , 1 ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: CALL 16558 0 3
38804: GO 38784
38806: POP
38807: POP
// if eng > 1 then
38808: LD_VAR 0 14
38812: PUSH
38813: LD_INT 1
38815: GREATER
38816: IFFALSE 38863
// for i = eng downto 2 do
38818: LD_ADDR_VAR 0 4
38822: PUSH
38823: DOUBLE
38824: LD_VAR 0 14
38828: INC
38829: ST_TO_ADDR
38830: LD_INT 2
38832: PUSH
38833: FOR_DOWNTO
38834: IFFALSE 38861
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 14
38845: PUSH
38846: LD_VAR 0 4
38850: ARRAY
38851: PPUSH
38852: LD_INT 1
38854: PPUSH
38855: CALL 16558 0 3
38859: GO 38833
38861: POP
38862: POP
// if UnitsInside ( b ) then
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: IFFALSE 38888
// ComExitBuilding ( UnitsInside ( b ) ) ;
38874: LD_VAR 0 11
38878: PPUSH
38879: CALL_OW 313
38883: PPUSH
38884: CALL_OW 122
// end ; end else
38888: GO 40471
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38890: LD_VAR 0 1
38894: PPUSH
38895: LD_INT 1
38897: PPUSH
38898: LD_EXP 65
38902: PUSH
38903: LD_VAR 0 1
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: PPUSH
38913: CALL 33743 0 3
38917: IFFALSE 39056
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38919: LD_ADDR_VAR 0 12
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: LD_INT 21
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL 11651 0 2
38943: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38944: LD_ADDR_VAR 0 11
38948: PUSH
38949: LD_VAR 0 1
38953: PPUSH
38954: LD_INT 30
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL 11651 0 2
38968: ST_TO_ADDR
// if b then
38969: LD_VAR 0 11
38973: IFFALSE 39056
// for i in tmp do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 12
38984: PUSH
38985: FOR_IN
38986: IFFALSE 39054
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38988: LD_VAR 0 4
38992: PPUSH
38993: LD_EXP 65
38997: PUSH
38998: LD_VAR 0 1
39002: ARRAY
39003: PUSH
39004: LD_INT 1
39006: ARRAY
39007: PPUSH
39008: CALL_OW 308
39012: NOT
39013: IFFALSE 39052
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39015: LD_VAR 0 4
39019: PPUSH
39020: LD_VAR 0 11
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 250
39033: PPUSH
39034: LD_VAR 0 11
39038: PUSH
39039: LD_INT 1
39041: ARRAY
39042: PPUSH
39043: CALL_OW 251
39047: PPUSH
39048: CALL_OW 111
39052: GO 38985
39054: POP
39055: POP
// end ; if MREG_DefVeh [ side ] then
39056: LD_EXP 67
39060: PUSH
39061: LD_VAR 0 1
39065: ARRAY
39066: IFFALSE 39634
// begin tmp := [ ] ;
39068: LD_ADDR_VAR 0 12
39072: PUSH
39073: EMPTY
39074: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39075: LD_EXP 70
39079: PUSH
39080: LD_VAR 0 1
39084: ARRAY
39085: PUSH
39086: LD_INT 0
39088: EQUAL
39089: IFFALSE 39229
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39091: LD_ADDR_VAR 0 8
39095: PUSH
39096: LD_VAR 0 1
39100: PPUSH
39101: LD_INT 0
39103: PPUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 3
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL 12354 0 3
39118: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39119: LD_VAR 0 8
39123: PUSH
39124: LD_EXP 67
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: GREATER
39135: IFFALSE 39196
// begin for i = 1 to MREG_DefVeh [ side ] do
39137: LD_ADDR_VAR 0 4
39141: PUSH
39142: DOUBLE
39143: LD_INT 1
39145: DEC
39146: ST_TO_ADDR
39147: LD_EXP 67
39151: PUSH
39152: LD_VAR 0 1
39156: ARRAY
39157: PUSH
39158: FOR_TO
39159: IFFALSE 39192
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39161: LD_ADDR_VAR 0 12
39165: PUSH
39166: LD_VAR 0 12
39170: PPUSH
39171: LD_INT 1
39173: PPUSH
39174: LD_VAR 0 8
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PPUSH
39185: CALL_OW 2
39189: ST_TO_ADDR
39190: GO 39158
39192: POP
39193: POP
// end else
39194: GO 39206
// tmp := k ;
39196: LD_ADDR_VAR 0 12
39200: PUSH
39201: LD_VAR 0 8
39205: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39206: LD_ADDR_EXP 70
39210: PUSH
39211: LD_EXP 70
39215: PPUSH
39216: LD_VAR 0 1
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39229: LD_ADDR_VAR 0 4
39233: PUSH
39234: LD_EXP 67
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: PUSH
39245: FOR_IN
39246: IFFALSE 39632
// begin if not GetDriver ( i ) then
39248: LD_VAR 0 4
39252: PPUSH
39253: CALL 31773 0 1
39257: NOT
39258: IFFALSE 39333
// begin if tmp then
39260: LD_VAR 0 12
39264: IFFALSE 39331
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39266: LD_VAR 0 12
39270: PUSH
39271: LD_INT 1
39273: ARRAY
39274: PPUSH
39275: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39279: LD_VAR 0 12
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: LD_VAR 0 4
39292: PPUSH
39293: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39297: LD_VAR 0 12
39301: PUSH
39302: LD_INT 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 36
39308: PPUSH
39309: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39313: LD_ADDR_VAR 0 12
39317: PUSH
39318: LD_VAR 0 12
39322: PPUSH
39323: LD_INT 1
39325: PPUSH
39326: CALL_OW 3
39330: ST_TO_ADDR
// end ; end else
39331: GO 39630
// begin if GetTag ( i ) = 0 then
39333: LD_VAR 0 4
39337: PPUSH
39338: CALL_OW 110
39342: PUSH
39343: LD_INT 0
39345: EQUAL
39346: IFFALSE 39362
// SetTag ( i , 31 ) else
39348: LD_VAR 0 4
39352: PPUSH
39353: LD_INT 31
39355: PPUSH
39356: CALL_OW 109
39360: GO 39630
// if GetTag ( i ) = 31 then
39362: LD_VAR 0 4
39366: PPUSH
39367: CALL_OW 110
39371: PUSH
39372: LD_INT 31
39374: EQUAL
39375: IFFALSE 39630
// begin if GetFuel ( i ) < 20 then
39377: LD_VAR 0 4
39381: PPUSH
39382: CALL_OW 261
39386: PUSH
39387: LD_INT 20
39389: LESS
39390: IFFALSE 39415
// begin SetTag ( i , 21 ) ;
39392: LD_VAR 0 4
39396: PPUSH
39397: LD_INT 21
39399: PPUSH
39400: CALL_OW 109
// MCV_Refuel ( i ) ;
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL 26278 0 1
// continue ;
39413: GO 39245
// end ; if GetLives ( i ) < 700 then
39415: LD_VAR 0 4
39419: PPUSH
39420: CALL_OW 256
39424: PUSH
39425: LD_INT 700
39427: LESS
39428: IFFALSE 39540
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39430: LD_VAR 0 4
39434: PPUSH
39435: LD_EXP 58
39439: PUSH
39440: LD_VAR 0 1
39444: ARRAY
39445: PPUSH
39446: CALL_OW 308
39450: NOT
39451: IFFALSE 39475
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39453: LD_VAR 0 4
39457: PPUSH
39458: LD_EXP 58
39462: PUSH
39463: LD_VAR 0 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 113
39473: GO 39538
// if GetDriver ( i ) then
39475: LD_VAR 0 4
39479: PPUSH
39480: CALL 31773 0 1
39484: IFFALSE 39538
// begin k := GetDriver ( i ) ;
39486: LD_ADDR_VAR 0 8
39490: PUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31773 0 1
39500: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39501: LD_VAR 0 8
39505: PPUSH
39506: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39510: LD_VAR 0 8
39514: PPUSH
39515: LD_VAR 0 4
39519: PPUSH
39520: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39524: LD_VAR 0 8
39528: PPUSH
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL_OW 180
// end ; end else
39538: GO 39630
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39540: LD_ADDR_VAR 0 8
39544: PUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: CALL 25006 0 1
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: CALL_OW 74
39564: ST_TO_ADDR
// if k then
39565: LD_VAR 0 8
39569: IFFALSE 39587
// ComAttackUnit ( i , k ) else
39571: LD_VAR 0 4
39575: PPUSH
39576: LD_VAR 0 8
39580: PPUSH
39581: CALL_OW 115
39585: GO 39630
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_EXP 58
39596: PUSH
39597: LD_VAR 0 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 308
39607: NOT
39608: IFFALSE 39630
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39610: LD_VAR 0 4
39614: PPUSH
39615: LD_EXP 58
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: CALL_OW 113
// end ; end ; end ; end ;
39630: GO 39245
39632: POP
39633: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_INT 30
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PPUSH
39649: CALL 11651 0 2
39653: IFFALSE 40471
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39655: LD_ADDR_VAR 0 11
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: LD_INT 30
39667: PUSH
39668: LD_INT 5
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PPUSH
39675: CALL 11651 0 2
39679: PUSH
39680: LD_INT 1
39682: ARRAY
39683: ST_TO_ADDR
// if eng > 1 then
39684: LD_VAR 0 14
39688: PUSH
39689: LD_INT 1
39691: GREATER
39692: IFFALSE 39739
// for i = eng downto 2 do
39694: LD_ADDR_VAR 0 4
39698: PUSH
39699: DOUBLE
39700: LD_VAR 0 14
39704: INC
39705: ST_TO_ADDR
39706: LD_INT 2
39708: PUSH
39709: FOR_DOWNTO
39710: IFFALSE 39737
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39712: LD_VAR 0 1
39716: PPUSH
39717: LD_VAR 0 14
39721: PUSH
39722: LD_VAR 0 4
39726: ARRAY
39727: PPUSH
39728: LD_INT 1
39730: PPUSH
39731: CALL 16558 0 3
39735: GO 39709
39737: POP
39738: POP
// if sci > 1 then
39739: LD_VAR 0 16
39743: PUSH
39744: LD_INT 1
39746: GREATER
39747: IFFALSE 39794
// for i = sci downto 2 do
39749: LD_ADDR_VAR 0 4
39753: PUSH
39754: DOUBLE
39755: LD_VAR 0 16
39759: INC
39760: ST_TO_ADDR
39761: LD_INT 2
39763: PUSH
39764: FOR_DOWNTO
39765: IFFALSE 39792
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39767: LD_VAR 0 1
39771: PPUSH
39772: LD_VAR 0 16
39776: PUSH
39777: LD_VAR 0 4
39781: ARRAY
39782: PPUSH
39783: LD_INT 1
39785: PPUSH
39786: CALL 16558 0 3
39790: GO 39764
39792: POP
39793: POP
// if sol then
39794: LD_VAR 0 13
39798: IFFALSE 40471
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39800: LD_VAR 0 13
39804: PUSH
39805: LD_EXP 68
39809: PUSH
39810: LD_VAR 0 1
39814: ARRAY
39815: DIFF
39816: PUSH
39817: LD_INT 22
39819: PUSH
39820: LD_VAR 0 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 58
39831: PUSH
39832: EMPTY
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 32
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 31
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: PUSH
39873: LD_INT 0
39875: EQUAL
39876: AND
39877: IFFALSE 40471
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39879: LD_ADDR_VAR 0 12
39883: PUSH
39884: LD_VAR 0 13
39888: PUSH
39889: LD_EXP 68
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: DIFF
39900: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39901: LD_VAR 0 1
39905: PPUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PPUSH
39916: CALL 11651 0 2
39920: PUSH
39921: LD_INT 1
39923: GREATER
39924: IFFALSE 39955
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39926: LD_ADDR_VAR 0 8
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 30
39938: PUSH
39939: LD_INT 5
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL 11651 0 2
39950: PUSH
39951: LD_INT 2
39953: ARRAY
39954: ST_TO_ADDR
// for j in tmp do
39955: LD_ADDR_VAR 0 5
39959: PUSH
39960: LD_VAR 0 12
39964: PUSH
39965: FOR_IN
39966: IFFALSE 40469
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39968: LD_VAR 0 5
39972: PUSH
39973: LD_VAR 0 11
39977: PPUSH
39978: CALL_OW 313
39982: IN
39983: PUSH
39984: LD_VAR 0 11
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: EQUAL
39997: AND
39998: PUSH
39999: LD_VAR 0 8
40003: AND
40004: PUSH
40005: LD_VAR 0 8
40009: PPUSH
40010: CALL_OW 313
40014: PUSH
40015: LD_INT 6
40017: LESS
40018: AND
40019: IFFALSE 40046
// begin ComExitBuilding ( j ) ;
40021: LD_VAR 0 5
40025: PPUSH
40026: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40030: LD_VAR 0 5
40034: PPUSH
40035: LD_VAR 0 8
40039: PPUSH
40040: CALL_OW 180
// continue ;
40044: GO 39965
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40046: LD_VAR 0 5
40050: PPUSH
40051: CALL_OW 314
40055: NOT
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: CALL_OW 110
40066: PUSH
40067: LD_INT 0
40069: EQUAL
40070: AND
40071: PUSH
40072: LD_VAR 0 5
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: AND
40083: IFFALSE 40189
// begin if k then
40085: LD_VAR 0 8
40089: IFFALSE 40160
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40091: LD_VAR 0 8
40095: PPUSH
40096: CALL_OW 313
40100: PUSH
40101: LD_VAR 0 11
40105: PPUSH
40106: CALL_OW 313
40110: LESS
40111: IFFALSE 40129
// ComEnterUnit ( j , k ) else
40113: LD_VAR 0 5
40117: PPUSH
40118: LD_VAR 0 8
40122: PPUSH
40123: CALL_OW 120
40127: GO 40158
// if UnitsInside ( b ) < 6 then
40129: LD_VAR 0 11
40133: PPUSH
40134: CALL_OW 313
40138: PUSH
40139: LD_INT 6
40141: LESS
40142: IFFALSE 40158
// ComEnterUnit ( j , b ) ;
40144: LD_VAR 0 5
40148: PPUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 120
// end else
40158: GO 40189
// if UnitsInside ( b ) < 6 then
40160: LD_VAR 0 11
40164: PPUSH
40165: CALL_OW 313
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: IFFALSE 40189
// ComEnterUnit ( j , b ) ;
40175: LD_VAR 0 5
40179: PPUSH
40180: LD_VAR 0 11
40184: PPUSH
40185: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40189: LD_VAR 0 5
40193: PUSH
40194: LD_VAR 0 1
40198: PPUSH
40199: LD_INT 54
40201: PUSH
40202: EMPTY
40203: LIST
40204: PPUSH
40205: CALL 11651 0 2
40209: IN
40210: PUSH
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 257
40220: PUSH
40221: LD_INT 1
40223: EQUAL
40224: AND
40225: IFFALSE 40467
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40227: LD_EXP 62
40231: PUSH
40232: LD_VAR 0 1
40236: ARRAY
40237: PUSH
40238: LD_INT 1
40240: ARRAY
40241: PUSH
40242: LD_INT 12
40244: PPUSH
40245: LD_VAR 0 1
40249: PPUSH
40250: CALL_OW 321
40254: PUSH
40255: LD_INT 2
40257: EQUAL
40258: AND
40259: IFFALSE 40307
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40261: LD_VAR 0 1
40265: PPUSH
40266: LD_INT 5
40268: PPUSH
40269: EMPTY
40270: PPUSH
40271: CALL 11734 0 3
40275: PUSH
40276: LD_EXP 62
40280: PUSH
40281: LD_VAR 0 1
40285: ARRAY
40286: PUSH
40287: LD_INT 1
40289: ARRAY
40290: LESS
40291: IFFALSE 40307
// begin SetClass ( j , class_sniper ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: LD_INT 5
40300: PPUSH
40301: CALL_OW 336
// continue ;
40305: GO 39965
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40307: LD_EXP 62
40311: PUSH
40312: LD_VAR 0 1
40316: ARRAY
40317: PUSH
40318: LD_INT 2
40320: ARRAY
40321: PUSH
40322: LD_INT 41
40324: PPUSH
40325: LD_VAR 0 1
40329: PPUSH
40330: CALL_OW 321
40334: PUSH
40335: LD_INT 2
40337: EQUAL
40338: AND
40339: IFFALSE 40387
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40341: LD_VAR 0 1
40345: PPUSH
40346: LD_INT 8
40348: PPUSH
40349: EMPTY
40350: PPUSH
40351: CALL 11734 0 3
40355: PUSH
40356: LD_EXP 62
40360: PUSH
40361: LD_VAR 0 1
40365: ARRAY
40366: PUSH
40367: LD_INT 2
40369: ARRAY
40370: LESS
40371: IFFALSE 40387
// begin SetClass ( j , class_mortar ) ;
40373: LD_VAR 0 5
40377: PPUSH
40378: LD_INT 8
40380: PPUSH
40381: CALL_OW 336
// continue ;
40385: GO 39965
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40387: LD_EXP 62
40391: PUSH
40392: LD_VAR 0 1
40396: ARRAY
40397: PUSH
40398: LD_INT 3
40400: ARRAY
40401: PUSH
40402: LD_INT 44
40404: PPUSH
40405: LD_VAR 0 1
40409: PPUSH
40410: CALL_OW 321
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: AND
40419: IFFALSE 40467
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40421: LD_VAR 0 1
40425: PPUSH
40426: LD_INT 9
40428: PPUSH
40429: EMPTY
40430: PPUSH
40431: CALL 11734 0 3
40435: PUSH
40436: LD_EXP 62
40440: PUSH
40441: LD_VAR 0 1
40445: ARRAY
40446: PUSH
40447: LD_INT 3
40449: ARRAY
40450: LESS
40451: IFFALSE 40467
// begin SetClass ( j , class_bazooker ) ;
40453: LD_VAR 0 5
40457: PPUSH
40458: LD_INT 9
40460: PPUSH
40461: CALL_OW 336
// continue ;
40465: GO 39965
// end ; end ; end ;
40467: GO 39965
40469: POP
40470: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40471: LD_INT 22
40473: PUSH
40474: LD_VAR 0 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 58
40485: PUSH
40486: EMPTY
40487: LIST
40488: PUSH
40489: LD_INT 30
40491: PUSH
40492: LD_INT 32
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: PPUSH
40504: CALL_OW 69
40508: IFFALSE 40658
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40510: LD_ADDR_VAR 0 12
40514: PUSH
40515: LD_INT 22
40517: PUSH
40518: LD_VAR 0 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 58
40529: PUSH
40530: EMPTY
40531: LIST
40532: PUSH
40533: LD_INT 30
40535: PUSH
40536: LD_INT 32
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: PPUSH
40548: CALL_OW 69
40552: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40553: LD_ADDR_VAR 0 8
40557: PUSH
40558: LD_VAR 0 13
40562: PUSH
40563: LD_EXP 68
40567: PUSH
40568: LD_VAR 0 1
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40575: LD_VAR 0 12
40579: PUSH
40580: LD_INT 1
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 2
40591: EQUAL
40592: PUSH
40593: LD_VAR 0 12
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_EXP 68
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: IN
40613: NOT
40614: AND
40615: PUSH
40616: LD_VAR 0 8
40620: AND
40621: IFFALSE 40658
// begin ComExitBuilding ( k [ 1 ] ) ;
40623: LD_VAR 0 8
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: PPUSH
40632: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40636: LD_VAR 0 8
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_VAR 0 12
40649: PUSH
40650: LD_INT 1
40652: ARRAY
40653: PPUSH
40654: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40658: LD_EXP 35
40662: PUSH
40663: LD_VAR 0 1
40667: ARRAY
40668: IFFALSE 40816
// begin if MCF_Class ( side , 4 , [ ] ) then
40670: LD_VAR 0 1
40674: PPUSH
40675: LD_INT 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL 11734 0 3
40684: IFFALSE 40814
// for j in MCF_Class ( side , 4 , [ ] ) do
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_VAR 0 1
40695: PPUSH
40696: LD_INT 4
40698: PPUSH
40699: EMPTY
40700: PPUSH
40701: CALL 11734 0 3
40705: PUSH
40706: FOR_IN
40707: IFFALSE 40812
// begin if not GetTag ( j ) = 4 then
40709: LD_VAR 0 5
40713: PPUSH
40714: CALL_OW 110
40718: PUSH
40719: LD_INT 4
40721: EQUAL
40722: NOT
40723: IFFALSE 40759
// begin SetTag ( j , 4 ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 4
40732: PPUSH
40733: CALL_OW 109
// if IsInUnit ( j ) then
40737: LD_VAR 0 5
40741: PPUSH
40742: CALL_OW 310
40746: IFFALSE 40757
// ComExitBuilding ( j ) ;
40748: LD_VAR 0 5
40752: PPUSH
40753: CALL_OW 122
// end else
40757: GO 40810
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40759: LD_VAR 0 5
40763: PPUSH
40764: LD_EXP 35
40768: PUSH
40769: LD_VAR 0 1
40773: ARRAY
40774: PUSH
40775: LD_INT 1
40777: ARRAY
40778: PPUSH
40779: CALL 98113 0 2
40783: NOT
40784: IFFALSE 40810
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_EXP 35
40795: PUSH
40796: LD_VAR 0 1
40800: ARRAY
40801: PUSH
40802: LD_INT 1
40804: ARRAY
40805: PPUSH
40806: CALL 19221 0 2
// end ;
40810: GO 40706
40812: POP
40813: POP
// end else
40814: GO 41048
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40816: LD_VAR 0 1
40820: PPUSH
40821: LD_INT 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL 11734 0 3
40830: PUSH
40831: LD_VAR 0 1
40835: PPUSH
40836: LD_INT 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL 12354 0 3
40845: AND
40846: IFFALSE 41048
// for j in MCF_Class ( side , 4 , [ ] ) do
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11734 0 3
40867: PUSH
40868: FOR_IN
40869: IFFALSE 41046
// begin if GetTag ( j ) = 4 then
40871: LD_VAR 0 5
40875: PPUSH
40876: CALL_OW 110
40880: PUSH
40881: LD_INT 4
40883: EQUAL
40884: IFFALSE 41044
// begin SetTag ( j , 0 ) ;
40886: LD_VAR 0 5
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40898: LD_VAR 0 1
40902: PPUSH
40903: CALL 11690 0 1
40907: PUSH
40908: LD_VAR 0 1
40912: PPUSH
40913: CALL 18034 0 1
40917: NOT
40918: AND
40919: IFFALSE 40944
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40921: LD_VAR 0 5
40925: PPUSH
40926: LD_VAR 0 1
40930: PPUSH
40931: CALL 11690 0 1
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: PPUSH
40940: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40944: LD_VAR 0 1
40948: PPUSH
40949: CALL 11690 0 1
40953: NOT
40954: PUSH
40955: LD_VAR 0 1
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL 11651 0 2
40974: AND
40975: IFFALSE 41044
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40977: LD_VAR 0 5
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 30
40989: PUSH
40990: LD_INT 1
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PPUSH
40997: CALL 11651 0 2
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 250
41010: PPUSH
41011: LD_VAR 0 1
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL 11651 0 2
41030: PUSH
41031: LD_INT 1
41033: ARRAY
41034: PPUSH
41035: CALL_OW 251
41039: PPUSH
41040: CALL_OW 111
// end ; end ;
41044: GO 40868
41046: POP
41047: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41048: LD_VAR 0 1
41052: PPUSH
41053: LD_INT 3
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL 11734 0 3
41062: PUSH
41063: LD_EXP 58
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: AND
41074: PUSH
41075: LD_VAR 0 1
41079: PPUSH
41080: LD_INT 6
41082: PPUSH
41083: EMPTY
41084: PPUSH
41085: CALL 12354 0 3
41089: AND
41090: IFFALSE 41621
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41092: LD_ADDR_VAR 0 6
41096: PUSH
41097: LD_EXP 58
41101: PUSH
41102: LD_VAR 0 1
41106: ARRAY
41107: PPUSH
41108: LD_INT 0
41110: PPUSH
41111: CALL_OW 517
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 1
41122: ARRAY
41123: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41124: LD_ADDR_VAR 0 7
41128: PUSH
41129: LD_EXP 58
41133: PUSH
41134: LD_VAR 0 1
41138: ARRAY
41139: PPUSH
41140: LD_INT 0
41142: PPUSH
41143: CALL_OW 517
41147: PUSH
41148: LD_INT 2
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 6
41163: PPUSH
41164: EMPTY
41165: PPUSH
41166: CALL 12354 0 3
41170: IFFALSE 41619
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 1
41181: PPUSH
41182: LD_INT 6
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL 12354 0 3
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41224
// if GetLives ( k ) = 1000 then
41195: LD_VAR 0 8
41199: PPUSH
41200: CALL_OW 256
41204: PUSH
41205: LD_INT 1000
41207: EQUAL
41208: IFFALSE 41222
// SetTag ( k , 0 ) ;
41210: LD_VAR 0 8
41214: PPUSH
41215: LD_INT 0
41217: PPUSH
41218: CALL_OW 109
41222: GO 41192
41224: POP
41225: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: LD_INT 25
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PPUSH
41244: CALL 12354 0 3
41248: IFFALSE 41312
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41250: LD_ADDR_VAR 0 8
41254: PUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: LD_INT 0
41262: PPUSH
41263: LD_INT 25
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: CALL 12354 0 3
41277: PUSH
41278: FOR_IN
41279: IFFALSE 41310
// if GetTag ( k ) = 0 then
41281: LD_VAR 0 8
41285: PPUSH
41286: CALL_OW 110
41290: PUSH
41291: LD_INT 0
41293: EQUAL
41294: IFFALSE 41308
// begin SetTag ( k , 8 ) ;
41296: LD_VAR 0 8
41300: PPUSH
41301: LD_INT 8
41303: PPUSH
41304: CALL_OW 109
// end ;
41308: GO 41278
41310: POP
41311: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41312: LD_VAR 0 1
41316: PPUSH
41317: LD_INT 6
41319: PPUSH
41320: LD_INT 92
41322: PUSH
41323: LD_VAR 0 6
41327: PUSH
41328: LD_VAR 0 7
41332: PUSH
41333: LD_INT 10
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL 12354 0 3
41346: IFFALSE 41470
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_VAR 0 4
41357: PPUSH
41358: LD_INT 6
41360: PPUSH
41361: LD_INT 92
41363: PUSH
41364: LD_VAR 0 6
41368: PUSH
41369: LD_VAR 0 7
41373: PUSH
41374: LD_INT 10
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 12354 0 3
41387: PUSH
41388: FOR_IN
41389: IFFALSE 41468
// begin if not HasTask ( j ) and GetDriver ( j ) then
41391: LD_VAR 0 5
41395: PPUSH
41396: CALL_OW 314
41400: NOT
41401: PUSH
41402: LD_VAR 0 5
41406: PPUSH
41407: CALL 31773 0 1
41411: AND
41412: IFFALSE 41466
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41414: LD_VAR 0 5
41418: PPUSH
41419: CALL 31773 0 1
41423: PPUSH
41424: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41428: LD_VAR 0 5
41432: PPUSH
41433: CALL 31773 0 1
41437: PPUSH
41438: LD_VAR 0 5
41442: PPUSH
41443: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41447: LD_VAR 0 5
41451: PPUSH
41452: CALL 31773 0 1
41456: PPUSH
41457: LD_VAR 0 5
41461: PPUSH
41462: CALL_OW 180
// end ; end ;
41466: GO 41388
41468: POP
41469: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41470: LD_VAR 0 1
41474: PPUSH
41475: LD_INT 6
41477: PPUSH
41478: LD_INT 92
41480: PUSH
41481: LD_VAR 0 6
41485: PUSH
41486: LD_VAR 0 7
41490: PUSH
41491: LD_INT 10
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL 12354 0 3
41504: PUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 8
41512: PPUSH
41513: EMPTY
41514: PPUSH
41515: CALL 12354 0 3
41519: AND
41520: IFFALSE 41619
// for j in MCF_Tag ( side , 8 , [ ] ) do
41522: LD_ADDR_VAR 0 5
41526: PUSH
41527: LD_VAR 0 1
41531: PPUSH
41532: LD_INT 8
41534: PPUSH
41535: EMPTY
41536: PPUSH
41537: CALL 12354 0 3
41541: PUSH
41542: FOR_IN
41543: IFFALSE 41617
// begin if IsInUnit ( j ) then
41545: LD_VAR 0 5
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41567
// ComExitBuilding ( j ) else
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 122
41565: GO 41615
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41567: LD_VAR 0 5
41571: PPUSH
41572: LD_VAR 0 1
41576: PPUSH
41577: LD_INT 6
41579: PPUSH
41580: LD_INT 92
41582: PUSH
41583: LD_VAR 0 6
41587: PUSH
41588: LD_VAR 0 7
41592: PUSH
41593: LD_INT 10
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: PPUSH
41602: CALL 12354 0 3
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: CALL_OW 129
// end ;
41615: GO 41542
41617: POP
41618: POP
// end ; end else
41619: GO 41676
// if MCF_Tag ( side , 8 , [ ] ) then
41621: LD_VAR 0 1
41625: PPUSH
41626: LD_INT 8
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL 12354 0 3
41635: IFFALSE 41676
// for k in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 8
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12354 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41674
// SetTag ( k , 0 ) ;
41660: LD_VAR 0 8
41664: PPUSH
41665: LD_INT 0
41667: PPUSH
41668: CALL_OW 109
41672: GO 41657
41674: POP
41675: POP
// end ; end_of_file
41676: LD_VAR 0 3
41680: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41681: LD_INT 0
41683: PPUSH
// MREG_Game := [ ] ;
41684: LD_ADDR_EXP 33
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_Crates := [ ] ;
41691: LD_ADDR_EXP 34
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_Heal := [ ] ;
41698: LD_ADDR_EXP 35
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_Tame := [ ] ;
41705: LD_ADDR_EXP 37
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41712: LD_ADDR_EXP 38
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41719: LD_ADDR_EXP 39
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_LabList := [ ] ;
41726: LD_ADDR_EXP 40
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41733: LD_ADDR_EXP 41
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41740: LD_ADDR_EXP 42
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41747: LD_ADDR_EXP 43
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41754: LD_ADDR_EXP 44
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_Status := [ ] ;
41761: LD_ADDR_EXP 45
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41768: LD_ADDR_EXP 46
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41775: LD_ADDR_EXP 47
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41782: LD_ADDR_EXP 48
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41789: LD_ADDR_EXP 49
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41796: LD_ADDR_EXP 50
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41803: LD_ADDR_EXP 51
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41810: LD_ADDR_EXP 52
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41817: LD_ADDR_EXP 53
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41824: LD_ADDR_EXP 54
41828: PUSH
41829: EMPTY
41830: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41831: LD_ADDR_EXP 55
41835: PUSH
41836: EMPTY
41837: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41838: LD_ADDR_EXP 56
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41845: LD_ADDR_EXP 57
41849: PUSH
41850: EMPTY
41851: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41852: LD_ADDR_EXP 61
41856: PUSH
41857: EMPTY
41858: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41859: LD_ADDR_EXP 62
41863: PUSH
41864: EMPTY
41865: ST_TO_ADDR
// MREG_Parking := [ ] ;
41866: LD_ADDR_EXP 58
41870: PUSH
41871: EMPTY
41872: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41873: LD_ADDR_EXP 59
41877: PUSH
41878: EMPTY
41879: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41880: LD_ADDR_EXP 63
41884: PUSH
41885: EMPTY
41886: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41887: LD_ADDR_EXP 64
41891: PUSH
41892: EMPTY
41893: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41894: LD_ADDR_EXP 65
41898: PUSH
41899: EMPTY
41900: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41901: LD_ADDR_EXP 67
41905: PUSH
41906: EMPTY
41907: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41908: LD_ADDR_EXP 68
41912: PUSH
41913: EMPTY
41914: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41915: LD_ADDR_EXP 69
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41922: LD_ADDR_EXP 71
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41929: LD_ADDR_EXP 70
41933: PUSH
41934: EMPTY
41935: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41936: LD_ADDR_EXP 72
41940: PUSH
41941: LD_INT 300
41943: PUSH
41944: LD_INT 100
41946: PUSH
41947: LD_INT 25
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 1
41959: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41960: LD_INT 0
41962: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41963: LD_VAR 0 2
41967: PUSH
41968: LD_VAR 0 3
41972: PUSH
41973: LD_VAR 0 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: LIST
41982: PUSH
41983: LD_VAR 0 1
41987: IN
41988: IFFALSE 42002
// result := mreg_list else
41990: LD_ADDR_VAR 0 5
41994: PUSH
41995: LD_VAR 0 1
41999: ST_TO_ADDR
42000: GO 42036
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42002: LD_ADDR_VAR 0 1
42006: PUSH
42007: LD_VAR 0 1
42011: PUSH
42012: LD_VAR 0 2
42016: PUSH
42017: LD_VAR 0 3
42021: PUSH
42022: LD_VAR 0 4
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: ADD
42035: ST_TO_ADDR
// result := mreg_list ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_VAR 0 1
42045: ST_TO_ADDR
// end ;
42046: LD_VAR 0 5
42050: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42051: LD_INT 0
42053: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42054: LD_VAR 0 2
42058: PUSH
42059: LD_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PUSH
42074: LD_VAR 0 1
42078: IN
42079: IFFALSE 42117
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_VAR 0 1
42090: PUSH
42091: LD_VAR 0 2
42095: PUSH
42096: LD_VAR 0 3
42100: PUSH
42101: LD_VAR 0 4
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: DIFF
42114: ST_TO_ADDR
42115: GO 42127
// result := mreg_list ;
42117: LD_ADDR_VAR 0 5
42121: PUSH
42122: LD_VAR 0 1
42126: ST_TO_ADDR
// end ;
42127: LD_VAR 0 5
42131: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42132: LD_INT 0
42134: PPUSH
42135: PPUSH
42136: PPUSH
// for j = 1 to 8 do
42137: LD_ADDR_VAR 0 3
42141: PUSH
42142: DOUBLE
42143: LD_INT 1
42145: DEC
42146: ST_TO_ADDR
42147: LD_INT 8
42149: PUSH
42150: FOR_TO
42151: IFFALSE 42992
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42153: LD_VAR 0 3
42157: PPUSH
42158: LD_INT 51
42160: PUSH
42161: EMPTY
42162: LIST
42163: PPUSH
42164: CALL 11651 0 2
42168: PUSH
42169: LD_OWVAR 2
42173: PUSH
42174: LD_VAR 0 3
42178: EQUAL
42179: NOT
42180: AND
42181: IFFALSE 42199
// MREG_SidesList := MREG_SidesList ^ 1 else
42183: LD_ADDR_EXP 39
42187: PUSH
42188: LD_EXP 39
42192: PUSH
42193: LD_INT 1
42195: ADD
42196: ST_TO_ADDR
42197: GO 42213
// MREG_SidesList := MREG_SidesList ^ 0 ;
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 0
42211: ADD
42212: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42213: LD_VAR 0 3
42217: PPUSH
42218: LD_INT 2
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 34
42233: PUSH
42234: LD_INT 32
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 34
42243: PUSH
42244: LD_INT 51
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11952 0 2
42264: IFFALSE 42365
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42266: LD_ADDR_VAR 0 2
42270: PUSH
42271: LD_VAR 0 3
42275: PPUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 34
42281: PUSH
42282: LD_INT 12
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 34
42291: PUSH
42292: LD_INT 32
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 34
42301: PUSH
42302: LD_INT 51
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: CALL 11952 0 2
42322: PUSH
42323: FOR_IN
42324: IFFALSE 42363
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42326: LD_ADDR_EXP 41
42330: PUSH
42331: LD_EXP 41
42335: PPUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_VAR 0 2
42345: PPUSH
42346: LD_VAR 0 2
42350: PPUSH
42351: CALL_OW 264
42355: PPUSH
42356: CALL 41960 0 4
42360: ST_TO_ADDR
42361: GO 42323
42363: POP
42364: POP
// if MCF_Class ( j , 4 , [ ] ) then
42365: LD_VAR 0 3
42369: PPUSH
42370: LD_INT 4
42372: PPUSH
42373: EMPTY
42374: PPUSH
42375: CALL 11734 0 3
42379: IFFALSE 42412
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42381: LD_ADDR_EXP 54
42385: PUSH
42386: LD_EXP 54
42390: PUSH
42391: LD_VAR 0 3
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: EMPTY
42400: PPUSH
42401: CALL 11734 0 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: ADD
42409: ST_TO_ADDR
42410: GO 42429
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42412: LD_ADDR_EXP 54
42416: PUSH
42417: LD_EXP 54
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: ADD
42428: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42429: LD_VAR 0 3
42433: PPUSH
42434: LD_INT 3
42436: PPUSH
42437: EMPTY
42438: PPUSH
42439: CALL 11734 0 3
42443: IFFALSE 42476
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42445: LD_ADDR_EXP 55
42449: PUSH
42450: LD_EXP 55
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_INT 3
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL 11734 0 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: ADD
42473: ST_TO_ADDR
42474: GO 42493
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42476: LD_ADDR_EXP 55
42480: PUSH
42481: LD_EXP 55
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: ADD
42492: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42493: LD_VAR 0 3
42497: PPUSH
42498: LD_INT 1
42500: PPUSH
42501: EMPTY
42502: PPUSH
42503: CALL 11734 0 3
42507: IFFALSE 42540
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42509: LD_ADDR_EXP 56
42513: PUSH
42514: LD_EXP 56
42518: PUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_INT 1
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 11734 0 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: ADD
42537: ST_TO_ADDR
42538: GO 42557
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42540: LD_ADDR_EXP 56
42544: PUSH
42545: LD_EXP 56
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: ADD
42556: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_INT 2
42564: PPUSH
42565: EMPTY
42566: PPUSH
42567: CALL 11734 0 3
42571: IFFALSE 42604
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42573: LD_ADDR_EXP 57
42577: PUSH
42578: LD_EXP 57
42582: PUSH
42583: LD_VAR 0 3
42587: PPUSH
42588: LD_INT 2
42590: PPUSH
42591: EMPTY
42592: PPUSH
42593: CALL 11734 0 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: ADD
42601: ST_TO_ADDR
42602: GO 42621
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42604: LD_ADDR_EXP 57
42608: PUSH
42609: LD_EXP 57
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: EMPTY
42618: LIST
42619: ADD
42620: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42621: LD_ADDR_EXP 47
42625: PUSH
42626: LD_EXP 47
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: ADD
42637: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42638: LD_ADDR_EXP 35
42642: PUSH
42643: LD_EXP 35
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: ADD
42654: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42655: LD_ADDR_EXP 37
42659: PUSH
42660: LD_EXP 37
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42672: LD_ADDR_EXP 58
42676: PUSH
42677: LD_EXP 58
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: EMPTY
42686: LIST
42687: ADD
42688: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42689: LD_ADDR_EXP 59
42693: PUSH
42694: LD_EXP 59
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: ADD
42705: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42706: LD_ADDR_EXP 51
42710: PUSH
42711: LD_EXP 51
42715: PUSH
42716: LD_INT 0
42718: PUSH
42719: EMPTY
42720: LIST
42721: ADD
42722: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42723: LD_ADDR_EXP 38
42727: PUSH
42728: LD_EXP 38
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: LD_INT 0
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42755: LD_ADDR_EXP 60
42759: PUSH
42760: LD_EXP 60
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: ADD
42777: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42778: LD_ADDR_EXP 61
42782: PUSH
42783: LD_EXP 61
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: EMPTY
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42798: LD_ADDR_EXP 42
42802: PUSH
42803: LD_EXP 42
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42815: LD_ADDR_EXP 63
42819: PUSH
42820: LD_EXP 63
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42832: LD_ADDR_EXP 64
42836: PUSH
42837: LD_EXP 64
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: ADD
42848: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42849: LD_ADDR_EXP 65
42853: PUSH
42854: LD_EXP 65
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: ADD
42865: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42866: LD_ADDR_EXP 66
42870: PUSH
42871: LD_EXP 66
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42883: LD_ADDR_EXP 67
42887: PUSH
42888: LD_EXP 67
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: ADD
42899: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42900: LD_ADDR_EXP 68
42904: PUSH
42905: LD_EXP 68
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: ADD
42916: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42917: LD_ADDR_EXP 69
42921: PUSH
42922: LD_EXP 69
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: EMPTY
42931: LIST
42932: ADD
42933: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42934: LD_ADDR_EXP 71
42938: PUSH
42939: LD_EXP 71
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42951: LD_ADDR_EXP 70
42955: PUSH
42956: LD_EXP 70
42960: PUSH
42961: LD_INT 0
42963: ADD
42964: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42965: LD_ADDR_EXP 62
42969: PUSH
42970: LD_EXP 62
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ADD
42989: ST_TO_ADDR
// end ;
42990: GO 42150
42992: POP
42993: POP
// end ;
42994: LD_VAR 0 1
42998: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42999: LD_INT 0
43001: PPUSH
43002: PPUSH
43003: PPUSH
// m := false ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_INT 0
43011: ST_TO_ADDR
// for i = 1 to mreg do
43012: LD_ADDR_VAR 0 4
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 2
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43064
// if mreg [ i ] [ 1 ] = side then
43030: LD_VAR 0 2
43034: PUSH
43035: LD_VAR 0 4
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_VAR 0 1
43049: EQUAL
43050: IFFALSE 43062
// begin m := true ;
43052: LD_ADDR_VAR 0 5
43056: PUSH
43057: LD_INT 1
43059: ST_TO_ADDR
// break ;
43060: GO 43064
// end ;
43062: GO 43027
43064: POP
43065: POP
// result := m ;
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// m := 0 ;
43086: LD_ADDR_VAR 0 5
43090: PUSH
43091: LD_INT 0
43093: ST_TO_ADDR
// for i = 1 to mreg do
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_VAR 0 2
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43150
// if mreg [ i ] [ 1 ] = side then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_VAR 0 4
43121: ARRAY
43122: PUSH
43123: LD_INT 1
43125: ARRAY
43126: PUSH
43127: LD_VAR 0 1
43131: EQUAL
43132: IFFALSE 43148
// begin m := m + 1 ;
43134: LD_ADDR_VAR 0 5
43138: PUSH
43139: LD_VAR 0 5
43143: PUSH
43144: LD_INT 1
43146: PLUS
43147: ST_TO_ADDR
// end ;
43148: GO 43109
43150: POP
43151: POP
// result := m ;
43152: LD_ADDR_VAR 0 3
43156: PUSH
43157: LD_VAR 0 5
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
// result := 0 ;
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: LD_INT 0
43178: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43179: LD_ADDR_VAR 0 4
43183: PUSH
43184: DOUBLE
43185: LD_INT 1
43187: DEC
43188: ST_TO_ADDR
43189: LD_EXP 53
43193: PUSH
43194: FOR_TO
43195: IFFALSE 43257
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43197: LD_EXP 53
43201: PUSH
43202: LD_VAR 0 4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PUSH
43212: LD_VAR 0 1
43216: EQUAL
43217: PUSH
43218: LD_EXP 53
43222: PUSH
43223: LD_VAR 0 4
43227: ARRAY
43228: PUSH
43229: LD_INT 2
43231: ARRAY
43232: PUSH
43233: LD_VAR 0 2
43237: EQUAL
43238: AND
43239: IFFALSE 43255
// begin result := result + 1 ;
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 3
43250: PUSH
43251: LD_INT 1
43253: PLUS
43254: ST_TO_ADDR
// end ;
43255: GO 43194
43257: POP
43258: POP
// end ; end_of_file end_of_file
43259: LD_VAR 0 3
43263: RET
// every 0 0$1 do
43264: GO 43266
43266: DISABLE
// begin enable ;
43267: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43268: LD_STRING updateTimer(
43270: PUSH
43271: LD_OWVAR 1
43275: STR
43276: PUSH
43277: LD_STRING );
43279: STR
43280: PPUSH
43281: CALL_OW 559
// end ;
43285: END
// export function SOS_MapStart ( ) ; begin
43286: LD_INT 0
43288: PPUSH
// if streamModeActive then
43289: LD_EXP 74
43293: IFFALSE 43302
// DefineStreamItems ( true ) ;
43295: LD_INT 1
43297: PPUSH
43298: CALL 45106 0 1
// UpdateLuaVariables ( ) ;
43302: CALL 43319 0 0
// UpdateFactoryWaypoints ( ) ;
43306: CALL 57967 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43310: CALL 58224 0 0
// end ;
43314: LD_VAR 0 1
43318: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
43319: LD_INT 0
43321: PPUSH
// if not globalGameSaveCounter then
43322: LD_EXP 73
43326: NOT
43327: IFFALSE 43338
// ToLua ( setGameSaveCounter(0) ) else
43329: LD_STRING setGameSaveCounter(0)
43331: PPUSH
43332: CALL_OW 559
43336: GO 43370
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
43338: LD_ADDR_EXP 73
43342: PUSH
43343: LD_EXP 73
43347: PPUSH
43348: CALL 102181 0 1
43352: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
43353: LD_STRING setGameSaveCounter(
43355: PUSH
43356: LD_EXP 73
43360: STR
43361: PUSH
43362: LD_STRING )
43364: STR
43365: PPUSH
43366: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
43370: LD_STRING setGameDifficulty(
43372: PUSH
43373: LD_OWVAR 67
43377: STR
43378: PUSH
43379: LD_STRING )
43381: STR
43382: PPUSH
43383: CALL_OW 559
// end ;
43387: LD_VAR 0 1
43391: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43392: LD_INT 0
43394: PPUSH
// if p2 = stream_mode then
43395: LD_VAR 0 2
43399: PUSH
43400: LD_INT 100
43402: EQUAL
43403: IFFALSE 44406
// begin if not StreamModeActive then
43405: LD_EXP 74
43409: NOT
43410: IFFALSE 43420
// StreamModeActive := true ;
43412: LD_ADDR_EXP 74
43416: PUSH
43417: LD_INT 1
43419: ST_TO_ADDR
// if p3 = 0 then
43420: LD_VAR 0 3
43424: PUSH
43425: LD_INT 0
43427: EQUAL
43428: IFFALSE 43434
// InitStreamMode ;
43430: CALL 44642 0 0
// if p3 = 1 then
43434: LD_VAR 0 3
43438: PUSH
43439: LD_INT 1
43441: EQUAL
43442: IFFALSE 43452
// sRocket := true ;
43444: LD_ADDR_EXP 79
43448: PUSH
43449: LD_INT 1
43451: ST_TO_ADDR
// if p3 = 2 then
43452: LD_VAR 0 3
43456: PUSH
43457: LD_INT 2
43459: EQUAL
43460: IFFALSE 43470
// sSpeed := true ;
43462: LD_ADDR_EXP 78
43466: PUSH
43467: LD_INT 1
43469: ST_TO_ADDR
// if p3 = 3 then
43470: LD_VAR 0 3
43474: PUSH
43475: LD_INT 3
43477: EQUAL
43478: IFFALSE 43488
// sEngine := true ;
43480: LD_ADDR_EXP 80
43484: PUSH
43485: LD_INT 1
43487: ST_TO_ADDR
// if p3 = 4 then
43488: LD_VAR 0 3
43492: PUSH
43493: LD_INT 4
43495: EQUAL
43496: IFFALSE 43506
// sSpec := true ;
43498: LD_ADDR_EXP 77
43502: PUSH
43503: LD_INT 1
43505: ST_TO_ADDR
// if p3 = 5 then
43506: LD_VAR 0 3
43510: PUSH
43511: LD_INT 5
43513: EQUAL
43514: IFFALSE 43524
// sLevel := true ;
43516: LD_ADDR_EXP 81
43520: PUSH
43521: LD_INT 1
43523: ST_TO_ADDR
// if p3 = 6 then
43524: LD_VAR 0 3
43528: PUSH
43529: LD_INT 6
43531: EQUAL
43532: IFFALSE 43542
// sArmoury := true ;
43534: LD_ADDR_EXP 82
43538: PUSH
43539: LD_INT 1
43541: ST_TO_ADDR
// if p3 = 7 then
43542: LD_VAR 0 3
43546: PUSH
43547: LD_INT 7
43549: EQUAL
43550: IFFALSE 43560
// sRadar := true ;
43552: LD_ADDR_EXP 83
43556: PUSH
43557: LD_INT 1
43559: ST_TO_ADDR
// if p3 = 8 then
43560: LD_VAR 0 3
43564: PUSH
43565: LD_INT 8
43567: EQUAL
43568: IFFALSE 43578
// sBunker := true ;
43570: LD_ADDR_EXP 84
43574: PUSH
43575: LD_INT 1
43577: ST_TO_ADDR
// if p3 = 9 then
43578: LD_VAR 0 3
43582: PUSH
43583: LD_INT 9
43585: EQUAL
43586: IFFALSE 43596
// sHack := true ;
43588: LD_ADDR_EXP 85
43592: PUSH
43593: LD_INT 1
43595: ST_TO_ADDR
// if p3 = 10 then
43596: LD_VAR 0 3
43600: PUSH
43601: LD_INT 10
43603: EQUAL
43604: IFFALSE 43614
// sFire := true ;
43606: LD_ADDR_EXP 86
43610: PUSH
43611: LD_INT 1
43613: ST_TO_ADDR
// if p3 = 11 then
43614: LD_VAR 0 3
43618: PUSH
43619: LD_INT 11
43621: EQUAL
43622: IFFALSE 43632
// sRefresh := true ;
43624: LD_ADDR_EXP 87
43628: PUSH
43629: LD_INT 1
43631: ST_TO_ADDR
// if p3 = 12 then
43632: LD_VAR 0 3
43636: PUSH
43637: LD_INT 12
43639: EQUAL
43640: IFFALSE 43650
// sExp := true ;
43642: LD_ADDR_EXP 88
43646: PUSH
43647: LD_INT 1
43649: ST_TO_ADDR
// if p3 = 13 then
43650: LD_VAR 0 3
43654: PUSH
43655: LD_INT 13
43657: EQUAL
43658: IFFALSE 43668
// sDepot := true ;
43660: LD_ADDR_EXP 89
43664: PUSH
43665: LD_INT 1
43667: ST_TO_ADDR
// if p3 = 14 then
43668: LD_VAR 0 3
43672: PUSH
43673: LD_INT 14
43675: EQUAL
43676: IFFALSE 43686
// sFlag := true ;
43678: LD_ADDR_EXP 90
43682: PUSH
43683: LD_INT 1
43685: ST_TO_ADDR
// if p3 = 15 then
43686: LD_VAR 0 3
43690: PUSH
43691: LD_INT 15
43693: EQUAL
43694: IFFALSE 43704
// sKamikadze := true ;
43696: LD_ADDR_EXP 98
43700: PUSH
43701: LD_INT 1
43703: ST_TO_ADDR
// if p3 = 16 then
43704: LD_VAR 0 3
43708: PUSH
43709: LD_INT 16
43711: EQUAL
43712: IFFALSE 43722
// sTroll := true ;
43714: LD_ADDR_EXP 99
43718: PUSH
43719: LD_INT 1
43721: ST_TO_ADDR
// if p3 = 17 then
43722: LD_VAR 0 3
43726: PUSH
43727: LD_INT 17
43729: EQUAL
43730: IFFALSE 43740
// sSlow := true ;
43732: LD_ADDR_EXP 100
43736: PUSH
43737: LD_INT 1
43739: ST_TO_ADDR
// if p3 = 18 then
43740: LD_VAR 0 3
43744: PUSH
43745: LD_INT 18
43747: EQUAL
43748: IFFALSE 43758
// sLack := true ;
43750: LD_ADDR_EXP 101
43754: PUSH
43755: LD_INT 1
43757: ST_TO_ADDR
// if p3 = 19 then
43758: LD_VAR 0 3
43762: PUSH
43763: LD_INT 19
43765: EQUAL
43766: IFFALSE 43776
// sTank := true ;
43768: LD_ADDR_EXP 103
43772: PUSH
43773: LD_INT 1
43775: ST_TO_ADDR
// if p3 = 20 then
43776: LD_VAR 0 3
43780: PUSH
43781: LD_INT 20
43783: EQUAL
43784: IFFALSE 43794
// sRemote := true ;
43786: LD_ADDR_EXP 104
43790: PUSH
43791: LD_INT 1
43793: ST_TO_ADDR
// if p3 = 21 then
43794: LD_VAR 0 3
43798: PUSH
43799: LD_INT 21
43801: EQUAL
43802: IFFALSE 43812
// sPowell := true ;
43804: LD_ADDR_EXP 105
43808: PUSH
43809: LD_INT 1
43811: ST_TO_ADDR
// if p3 = 22 then
43812: LD_VAR 0 3
43816: PUSH
43817: LD_INT 22
43819: EQUAL
43820: IFFALSE 43830
// sTeleport := true ;
43822: LD_ADDR_EXP 108
43826: PUSH
43827: LD_INT 1
43829: ST_TO_ADDR
// if p3 = 23 then
43830: LD_VAR 0 3
43834: PUSH
43835: LD_INT 23
43837: EQUAL
43838: IFFALSE 43848
// sOilTower := true ;
43840: LD_ADDR_EXP 110
43844: PUSH
43845: LD_INT 1
43847: ST_TO_ADDR
// if p3 = 24 then
43848: LD_VAR 0 3
43852: PUSH
43853: LD_INT 24
43855: EQUAL
43856: IFFALSE 43866
// sShovel := true ;
43858: LD_ADDR_EXP 111
43862: PUSH
43863: LD_INT 1
43865: ST_TO_ADDR
// if p3 = 25 then
43866: LD_VAR 0 3
43870: PUSH
43871: LD_INT 25
43873: EQUAL
43874: IFFALSE 43884
// sSheik := true ;
43876: LD_ADDR_EXP 112
43880: PUSH
43881: LD_INT 1
43883: ST_TO_ADDR
// if p3 = 26 then
43884: LD_VAR 0 3
43888: PUSH
43889: LD_INT 26
43891: EQUAL
43892: IFFALSE 43902
// sEarthquake := true ;
43894: LD_ADDR_EXP 114
43898: PUSH
43899: LD_INT 1
43901: ST_TO_ADDR
// if p3 = 27 then
43902: LD_VAR 0 3
43906: PUSH
43907: LD_INT 27
43909: EQUAL
43910: IFFALSE 43920
// sAI := true ;
43912: LD_ADDR_EXP 115
43916: PUSH
43917: LD_INT 1
43919: ST_TO_ADDR
// if p3 = 28 then
43920: LD_VAR 0 3
43924: PUSH
43925: LD_INT 28
43927: EQUAL
43928: IFFALSE 43938
// sCargo := true ;
43930: LD_ADDR_EXP 118
43934: PUSH
43935: LD_INT 1
43937: ST_TO_ADDR
// if p3 = 29 then
43938: LD_VAR 0 3
43942: PUSH
43943: LD_INT 29
43945: EQUAL
43946: IFFALSE 43956
// sDLaser := true ;
43948: LD_ADDR_EXP 119
43952: PUSH
43953: LD_INT 1
43955: ST_TO_ADDR
// if p3 = 30 then
43956: LD_VAR 0 3
43960: PUSH
43961: LD_INT 30
43963: EQUAL
43964: IFFALSE 43974
// sExchange := true ;
43966: LD_ADDR_EXP 120
43970: PUSH
43971: LD_INT 1
43973: ST_TO_ADDR
// if p3 = 31 then
43974: LD_VAR 0 3
43978: PUSH
43979: LD_INT 31
43981: EQUAL
43982: IFFALSE 43992
// sFac := true ;
43984: LD_ADDR_EXP 121
43988: PUSH
43989: LD_INT 1
43991: ST_TO_ADDR
// if p3 = 32 then
43992: LD_VAR 0 3
43996: PUSH
43997: LD_INT 32
43999: EQUAL
44000: IFFALSE 44010
// sPower := true ;
44002: LD_ADDR_EXP 122
44006: PUSH
44007: LD_INT 1
44009: ST_TO_ADDR
// if p3 = 33 then
44010: LD_VAR 0 3
44014: PUSH
44015: LD_INT 33
44017: EQUAL
44018: IFFALSE 44028
// sRandom := true ;
44020: LD_ADDR_EXP 123
44024: PUSH
44025: LD_INT 1
44027: ST_TO_ADDR
// if p3 = 34 then
44028: LD_VAR 0 3
44032: PUSH
44033: LD_INT 34
44035: EQUAL
44036: IFFALSE 44046
// sShield := true ;
44038: LD_ADDR_EXP 124
44042: PUSH
44043: LD_INT 1
44045: ST_TO_ADDR
// if p3 = 35 then
44046: LD_VAR 0 3
44050: PUSH
44051: LD_INT 35
44053: EQUAL
44054: IFFALSE 44064
// sTime := true ;
44056: LD_ADDR_EXP 125
44060: PUSH
44061: LD_INT 1
44063: ST_TO_ADDR
// if p3 = 36 then
44064: LD_VAR 0 3
44068: PUSH
44069: LD_INT 36
44071: EQUAL
44072: IFFALSE 44082
// sTools := true ;
44074: LD_ADDR_EXP 126
44078: PUSH
44079: LD_INT 1
44081: ST_TO_ADDR
// if p3 = 101 then
44082: LD_VAR 0 3
44086: PUSH
44087: LD_INT 101
44089: EQUAL
44090: IFFALSE 44100
// sSold := true ;
44092: LD_ADDR_EXP 91
44096: PUSH
44097: LD_INT 1
44099: ST_TO_ADDR
// if p3 = 102 then
44100: LD_VAR 0 3
44104: PUSH
44105: LD_INT 102
44107: EQUAL
44108: IFFALSE 44118
// sDiff := true ;
44110: LD_ADDR_EXP 92
44114: PUSH
44115: LD_INT 1
44117: ST_TO_ADDR
// if p3 = 103 then
44118: LD_VAR 0 3
44122: PUSH
44123: LD_INT 103
44125: EQUAL
44126: IFFALSE 44136
// sFog := true ;
44128: LD_ADDR_EXP 95
44132: PUSH
44133: LD_INT 1
44135: ST_TO_ADDR
// if p3 = 104 then
44136: LD_VAR 0 3
44140: PUSH
44141: LD_INT 104
44143: EQUAL
44144: IFFALSE 44154
// sReset := true ;
44146: LD_ADDR_EXP 96
44150: PUSH
44151: LD_INT 1
44153: ST_TO_ADDR
// if p3 = 105 then
44154: LD_VAR 0 3
44158: PUSH
44159: LD_INT 105
44161: EQUAL
44162: IFFALSE 44172
// sSun := true ;
44164: LD_ADDR_EXP 97
44168: PUSH
44169: LD_INT 1
44171: ST_TO_ADDR
// if p3 = 106 then
44172: LD_VAR 0 3
44176: PUSH
44177: LD_INT 106
44179: EQUAL
44180: IFFALSE 44190
// sTiger := true ;
44182: LD_ADDR_EXP 93
44186: PUSH
44187: LD_INT 1
44189: ST_TO_ADDR
// if p3 = 107 then
44190: LD_VAR 0 3
44194: PUSH
44195: LD_INT 107
44197: EQUAL
44198: IFFALSE 44208
// sBomb := true ;
44200: LD_ADDR_EXP 94
44204: PUSH
44205: LD_INT 1
44207: ST_TO_ADDR
// if p3 = 108 then
44208: LD_VAR 0 3
44212: PUSH
44213: LD_INT 108
44215: EQUAL
44216: IFFALSE 44226
// sWound := true ;
44218: LD_ADDR_EXP 102
44222: PUSH
44223: LD_INT 1
44225: ST_TO_ADDR
// if p3 = 109 then
44226: LD_VAR 0 3
44230: PUSH
44231: LD_INT 109
44233: EQUAL
44234: IFFALSE 44244
// sBetray := true ;
44236: LD_ADDR_EXP 106
44240: PUSH
44241: LD_INT 1
44243: ST_TO_ADDR
// if p3 = 110 then
44244: LD_VAR 0 3
44248: PUSH
44249: LD_INT 110
44251: EQUAL
44252: IFFALSE 44262
// sContamin := true ;
44254: LD_ADDR_EXP 107
44258: PUSH
44259: LD_INT 1
44261: ST_TO_ADDR
// if p3 = 111 then
44262: LD_VAR 0 3
44266: PUSH
44267: LD_INT 111
44269: EQUAL
44270: IFFALSE 44280
// sOil := true ;
44272: LD_ADDR_EXP 109
44276: PUSH
44277: LD_INT 1
44279: ST_TO_ADDR
// if p3 = 112 then
44280: LD_VAR 0 3
44284: PUSH
44285: LD_INT 112
44287: EQUAL
44288: IFFALSE 44298
// sStu := true ;
44290: LD_ADDR_EXP 113
44294: PUSH
44295: LD_INT 1
44297: ST_TO_ADDR
// if p3 = 113 then
44298: LD_VAR 0 3
44302: PUSH
44303: LD_INT 113
44305: EQUAL
44306: IFFALSE 44316
// sBazooka := true ;
44308: LD_ADDR_EXP 116
44312: PUSH
44313: LD_INT 1
44315: ST_TO_ADDR
// if p3 = 114 then
44316: LD_VAR 0 3
44320: PUSH
44321: LD_INT 114
44323: EQUAL
44324: IFFALSE 44334
// sMortar := true ;
44326: LD_ADDR_EXP 117
44330: PUSH
44331: LD_INT 1
44333: ST_TO_ADDR
// if p3 = 115 then
44334: LD_VAR 0 3
44338: PUSH
44339: LD_INT 115
44341: EQUAL
44342: IFFALSE 44352
// sRanger := true ;
44344: LD_ADDR_EXP 127
44348: PUSH
44349: LD_INT 1
44351: ST_TO_ADDR
// if p3 = 116 then
44352: LD_VAR 0 3
44356: PUSH
44357: LD_INT 116
44359: EQUAL
44360: IFFALSE 44370
// sComputer := true ;
44362: LD_ADDR_EXP 128
44366: PUSH
44367: LD_INT 1
44369: ST_TO_ADDR
// if p3 = 117 then
44370: LD_VAR 0 3
44374: PUSH
44375: LD_INT 117
44377: EQUAL
44378: IFFALSE 44388
// s30 := true ;
44380: LD_ADDR_EXP 129
44384: PUSH
44385: LD_INT 1
44387: ST_TO_ADDR
// if p3 = 118 then
44388: LD_VAR 0 3
44392: PUSH
44393: LD_INT 118
44395: EQUAL
44396: IFFALSE 44406
// s60 := true ;
44398: LD_ADDR_EXP 130
44402: PUSH
44403: LD_INT 1
44405: ST_TO_ADDR
// end ; if p2 = hack_mode then
44406: LD_VAR 0 2
44410: PUSH
44411: LD_INT 101
44413: EQUAL
44414: IFFALSE 44542
// begin case p3 of 1 :
44416: LD_VAR 0 3
44420: PUSH
44421: LD_INT 1
44423: DOUBLE
44424: EQUAL
44425: IFTRUE 44429
44427: GO 44436
44429: POP
// hHackUnlimitedResources ; 2 :
44430: CALL 56713 0 0
44434: GO 44542
44436: LD_INT 2
44438: DOUBLE
44439: EQUAL
44440: IFTRUE 44444
44442: GO 44451
44444: POP
// hHackSetLevel10 ; 3 :
44445: CALL 56846 0 0
44449: GO 44542
44451: LD_INT 3
44453: DOUBLE
44454: EQUAL
44455: IFTRUE 44459
44457: GO 44466
44459: POP
// hHackSetLevel10YourUnits ; 4 :
44460: CALL 56931 0 0
44464: GO 44542
44466: LD_INT 4
44468: DOUBLE
44469: EQUAL
44470: IFTRUE 44474
44472: GO 44481
44474: POP
// hHackInvincible ; 5 :
44475: CALL 57379 0 0
44479: GO 44542
44481: LD_INT 5
44483: DOUBLE
44484: EQUAL
44485: IFTRUE 44489
44487: GO 44496
44489: POP
// hHackInvisible ; 6 :
44490: CALL 57490 0 0
44494: GO 44542
44496: LD_INT 6
44498: DOUBLE
44499: EQUAL
44500: IFTRUE 44504
44502: GO 44511
44504: POP
// hHackChangeYourSide ; 7 :
44505: CALL 57547 0 0
44509: GO 44542
44511: LD_INT 7
44513: DOUBLE
44514: EQUAL
44515: IFTRUE 44519
44517: GO 44526
44519: POP
// hHackChangeUnitSide ; 8 :
44520: CALL 57589 0 0
44524: GO 44542
44526: LD_INT 8
44528: DOUBLE
44529: EQUAL
44530: IFTRUE 44534
44532: GO 44541
44534: POP
// hHackFog ; end ;
44535: CALL 57690 0 0
44539: GO 44542
44541: POP
// end ; if p2 = game_save_mode then
44542: LD_VAR 0 2
44546: PUSH
44547: LD_INT 102
44549: EQUAL
44550: IFFALSE 44615
// begin if p3 = 1 then
44552: LD_VAR 0 3
44556: PUSH
44557: LD_INT 1
44559: EQUAL
44560: IFFALSE 44572
// globalGameSaveCounter := p4 ;
44562: LD_ADDR_EXP 73
44566: PUSH
44567: LD_VAR 0 4
44571: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
44572: LD_VAR 0 3
44576: PUSH
44577: LD_INT 2
44579: EQUAL
44580: PUSH
44581: LD_EXP 73
44585: AND
44586: IFFALSE 44605
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
44588: LD_STRING setGameSaveCounter(
44590: PUSH
44591: LD_EXP 73
44595: STR
44596: PUSH
44597: LD_STRING )
44599: STR
44600: PPUSH
44601: CALL_OW 559
// display_strings := globalGameSaveCounter ;
44605: LD_ADDR_OWVAR 47
44609: PUSH
44610: LD_EXP 73
44614: ST_TO_ADDR
// end ; end ;
44615: LD_VAR 0 7
44619: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44620: GO 44622
44622: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44623: LD_STRING initStreamRollete();
44625: PPUSH
44626: CALL_OW 559
// InitStreamMode ;
44630: CALL 44642 0 0
// DefineStreamItems ( false ) ;
44634: LD_INT 0
44636: PPUSH
44637: CALL 45106 0 1
// end ;
44641: END
// function InitStreamMode ; begin
44642: LD_INT 0
44644: PPUSH
// streamModeActive := false ;
44645: LD_ADDR_EXP 74
44649: PUSH
44650: LD_INT 0
44652: ST_TO_ADDR
// normalCounter := 36 ;
44653: LD_ADDR_EXP 75
44657: PUSH
44658: LD_INT 36
44660: ST_TO_ADDR
// hardcoreCounter := 18 ;
44661: LD_ADDR_EXP 76
44665: PUSH
44666: LD_INT 18
44668: ST_TO_ADDR
// sRocket := false ;
44669: LD_ADDR_EXP 79
44673: PUSH
44674: LD_INT 0
44676: ST_TO_ADDR
// sSpeed := false ;
44677: LD_ADDR_EXP 78
44681: PUSH
44682: LD_INT 0
44684: ST_TO_ADDR
// sEngine := false ;
44685: LD_ADDR_EXP 80
44689: PUSH
44690: LD_INT 0
44692: ST_TO_ADDR
// sSpec := false ;
44693: LD_ADDR_EXP 77
44697: PUSH
44698: LD_INT 0
44700: ST_TO_ADDR
// sLevel := false ;
44701: LD_ADDR_EXP 81
44705: PUSH
44706: LD_INT 0
44708: ST_TO_ADDR
// sArmoury := false ;
44709: LD_ADDR_EXP 82
44713: PUSH
44714: LD_INT 0
44716: ST_TO_ADDR
// sRadar := false ;
44717: LD_ADDR_EXP 83
44721: PUSH
44722: LD_INT 0
44724: ST_TO_ADDR
// sBunker := false ;
44725: LD_ADDR_EXP 84
44729: PUSH
44730: LD_INT 0
44732: ST_TO_ADDR
// sHack := false ;
44733: LD_ADDR_EXP 85
44737: PUSH
44738: LD_INT 0
44740: ST_TO_ADDR
// sFire := false ;
44741: LD_ADDR_EXP 86
44745: PUSH
44746: LD_INT 0
44748: ST_TO_ADDR
// sRefresh := false ;
44749: LD_ADDR_EXP 87
44753: PUSH
44754: LD_INT 0
44756: ST_TO_ADDR
// sExp := false ;
44757: LD_ADDR_EXP 88
44761: PUSH
44762: LD_INT 0
44764: ST_TO_ADDR
// sDepot := false ;
44765: LD_ADDR_EXP 89
44769: PUSH
44770: LD_INT 0
44772: ST_TO_ADDR
// sFlag := false ;
44773: LD_ADDR_EXP 90
44777: PUSH
44778: LD_INT 0
44780: ST_TO_ADDR
// sKamikadze := false ;
44781: LD_ADDR_EXP 98
44785: PUSH
44786: LD_INT 0
44788: ST_TO_ADDR
// sTroll := false ;
44789: LD_ADDR_EXP 99
44793: PUSH
44794: LD_INT 0
44796: ST_TO_ADDR
// sSlow := false ;
44797: LD_ADDR_EXP 100
44801: PUSH
44802: LD_INT 0
44804: ST_TO_ADDR
// sLack := false ;
44805: LD_ADDR_EXP 101
44809: PUSH
44810: LD_INT 0
44812: ST_TO_ADDR
// sTank := false ;
44813: LD_ADDR_EXP 103
44817: PUSH
44818: LD_INT 0
44820: ST_TO_ADDR
// sRemote := false ;
44821: LD_ADDR_EXP 104
44825: PUSH
44826: LD_INT 0
44828: ST_TO_ADDR
// sPowell := false ;
44829: LD_ADDR_EXP 105
44833: PUSH
44834: LD_INT 0
44836: ST_TO_ADDR
// sTeleport := false ;
44837: LD_ADDR_EXP 108
44841: PUSH
44842: LD_INT 0
44844: ST_TO_ADDR
// sOilTower := false ;
44845: LD_ADDR_EXP 110
44849: PUSH
44850: LD_INT 0
44852: ST_TO_ADDR
// sShovel := false ;
44853: LD_ADDR_EXP 111
44857: PUSH
44858: LD_INT 0
44860: ST_TO_ADDR
// sSheik := false ;
44861: LD_ADDR_EXP 112
44865: PUSH
44866: LD_INT 0
44868: ST_TO_ADDR
// sEarthquake := false ;
44869: LD_ADDR_EXP 114
44873: PUSH
44874: LD_INT 0
44876: ST_TO_ADDR
// sAI := false ;
44877: LD_ADDR_EXP 115
44881: PUSH
44882: LD_INT 0
44884: ST_TO_ADDR
// sCargo := false ;
44885: LD_ADDR_EXP 118
44889: PUSH
44890: LD_INT 0
44892: ST_TO_ADDR
// sDLaser := false ;
44893: LD_ADDR_EXP 119
44897: PUSH
44898: LD_INT 0
44900: ST_TO_ADDR
// sExchange := false ;
44901: LD_ADDR_EXP 120
44905: PUSH
44906: LD_INT 0
44908: ST_TO_ADDR
// sFac := false ;
44909: LD_ADDR_EXP 121
44913: PUSH
44914: LD_INT 0
44916: ST_TO_ADDR
// sPower := false ;
44917: LD_ADDR_EXP 122
44921: PUSH
44922: LD_INT 0
44924: ST_TO_ADDR
// sRandom := false ;
44925: LD_ADDR_EXP 123
44929: PUSH
44930: LD_INT 0
44932: ST_TO_ADDR
// sShield := false ;
44933: LD_ADDR_EXP 124
44937: PUSH
44938: LD_INT 0
44940: ST_TO_ADDR
// sTime := false ;
44941: LD_ADDR_EXP 125
44945: PUSH
44946: LD_INT 0
44948: ST_TO_ADDR
// sTools := false ;
44949: LD_ADDR_EXP 126
44953: PUSH
44954: LD_INT 0
44956: ST_TO_ADDR
// sSold := false ;
44957: LD_ADDR_EXP 91
44961: PUSH
44962: LD_INT 0
44964: ST_TO_ADDR
// sDiff := false ;
44965: LD_ADDR_EXP 92
44969: PUSH
44970: LD_INT 0
44972: ST_TO_ADDR
// sFog := false ;
44973: LD_ADDR_EXP 95
44977: PUSH
44978: LD_INT 0
44980: ST_TO_ADDR
// sReset := false ;
44981: LD_ADDR_EXP 96
44985: PUSH
44986: LD_INT 0
44988: ST_TO_ADDR
// sSun := false ;
44989: LD_ADDR_EXP 97
44993: PUSH
44994: LD_INT 0
44996: ST_TO_ADDR
// sTiger := false ;
44997: LD_ADDR_EXP 93
45001: PUSH
45002: LD_INT 0
45004: ST_TO_ADDR
// sBomb := false ;
45005: LD_ADDR_EXP 94
45009: PUSH
45010: LD_INT 0
45012: ST_TO_ADDR
// sWound := false ;
45013: LD_ADDR_EXP 102
45017: PUSH
45018: LD_INT 0
45020: ST_TO_ADDR
// sBetray := false ;
45021: LD_ADDR_EXP 106
45025: PUSH
45026: LD_INT 0
45028: ST_TO_ADDR
// sContamin := false ;
45029: LD_ADDR_EXP 107
45033: PUSH
45034: LD_INT 0
45036: ST_TO_ADDR
// sOil := false ;
45037: LD_ADDR_EXP 109
45041: PUSH
45042: LD_INT 0
45044: ST_TO_ADDR
// sStu := false ;
45045: LD_ADDR_EXP 113
45049: PUSH
45050: LD_INT 0
45052: ST_TO_ADDR
// sBazooka := false ;
45053: LD_ADDR_EXP 116
45057: PUSH
45058: LD_INT 0
45060: ST_TO_ADDR
// sMortar := false ;
45061: LD_ADDR_EXP 117
45065: PUSH
45066: LD_INT 0
45068: ST_TO_ADDR
// sRanger := false ;
45069: LD_ADDR_EXP 127
45073: PUSH
45074: LD_INT 0
45076: ST_TO_ADDR
// sComputer := false ;
45077: LD_ADDR_EXP 128
45081: PUSH
45082: LD_INT 0
45084: ST_TO_ADDR
// s30 := false ;
45085: LD_ADDR_EXP 129
45089: PUSH
45090: LD_INT 0
45092: ST_TO_ADDR
// s60 := false ;
45093: LD_ADDR_EXP 130
45097: PUSH
45098: LD_INT 0
45100: ST_TO_ADDR
// end ;
45101: LD_VAR 0 1
45105: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45106: LD_INT 0
45108: PPUSH
45109: PPUSH
45110: PPUSH
45111: PPUSH
45112: PPUSH
45113: PPUSH
45114: PPUSH
// result := [ ] ;
45115: LD_ADDR_VAR 0 2
45119: PUSH
45120: EMPTY
45121: ST_TO_ADDR
// if campaign_id = 1 then
45122: LD_OWVAR 69
45126: PUSH
45127: LD_INT 1
45129: EQUAL
45130: IFFALSE 48296
// begin case mission_number of 1 :
45132: LD_OWVAR 70
45136: PUSH
45137: LD_INT 1
45139: DOUBLE
45140: EQUAL
45141: IFTRUE 45145
45143: GO 45221
45145: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45146: LD_ADDR_VAR 0 2
45150: PUSH
45151: LD_INT 2
45153: PUSH
45154: LD_INT 4
45156: PUSH
45157: LD_INT 11
45159: PUSH
45160: LD_INT 12
45162: PUSH
45163: LD_INT 15
45165: PUSH
45166: LD_INT 16
45168: PUSH
45169: LD_INT 22
45171: PUSH
45172: LD_INT 23
45174: PUSH
45175: LD_INT 26
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 101
45191: PUSH
45192: LD_INT 102
45194: PUSH
45195: LD_INT 106
45197: PUSH
45198: LD_INT 116
45200: PUSH
45201: LD_INT 117
45203: PUSH
45204: LD_INT 118
45206: PUSH
45207: EMPTY
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: ST_TO_ADDR
45219: GO 48294
45221: LD_INT 2
45223: DOUBLE
45224: EQUAL
45225: IFTRUE 45229
45227: GO 45313
45229: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45230: LD_ADDR_VAR 0 2
45234: PUSH
45235: LD_INT 2
45237: PUSH
45238: LD_INT 4
45240: PUSH
45241: LD_INT 11
45243: PUSH
45244: LD_INT 12
45246: PUSH
45247: LD_INT 15
45249: PUSH
45250: LD_INT 16
45252: PUSH
45253: LD_INT 22
45255: PUSH
45256: LD_INT 23
45258: PUSH
45259: LD_INT 26
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: PUSH
45273: LD_INT 101
45275: PUSH
45276: LD_INT 102
45278: PUSH
45279: LD_INT 105
45281: PUSH
45282: LD_INT 106
45284: PUSH
45285: LD_INT 108
45287: PUSH
45288: LD_INT 116
45290: PUSH
45291: LD_INT 117
45293: PUSH
45294: LD_INT 118
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: LIST
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: ST_TO_ADDR
45311: GO 48294
45313: LD_INT 3
45315: DOUBLE
45316: EQUAL
45317: IFTRUE 45321
45319: GO 45409
45321: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45322: LD_ADDR_VAR 0 2
45326: PUSH
45327: LD_INT 2
45329: PUSH
45330: LD_INT 4
45332: PUSH
45333: LD_INT 5
45335: PUSH
45336: LD_INT 11
45338: PUSH
45339: LD_INT 12
45341: PUSH
45342: LD_INT 15
45344: PUSH
45345: LD_INT 16
45347: PUSH
45348: LD_INT 22
45350: PUSH
45351: LD_INT 26
45353: PUSH
45354: LD_INT 36
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 101
45371: PUSH
45372: LD_INT 102
45374: PUSH
45375: LD_INT 105
45377: PUSH
45378: LD_INT 106
45380: PUSH
45381: LD_INT 108
45383: PUSH
45384: LD_INT 116
45386: PUSH
45387: LD_INT 117
45389: PUSH
45390: LD_INT 118
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: ST_TO_ADDR
45407: GO 48294
45409: LD_INT 4
45411: DOUBLE
45412: EQUAL
45413: IFTRUE 45417
45415: GO 45513
45417: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45418: LD_ADDR_VAR 0 2
45422: PUSH
45423: LD_INT 2
45425: PUSH
45426: LD_INT 4
45428: PUSH
45429: LD_INT 5
45431: PUSH
45432: LD_INT 8
45434: PUSH
45435: LD_INT 11
45437: PUSH
45438: LD_INT 12
45440: PUSH
45441: LD_INT 15
45443: PUSH
45444: LD_INT 16
45446: PUSH
45447: LD_INT 22
45449: PUSH
45450: LD_INT 23
45452: PUSH
45453: LD_INT 26
45455: PUSH
45456: LD_INT 36
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 101
45475: PUSH
45476: LD_INT 102
45478: PUSH
45479: LD_INT 105
45481: PUSH
45482: LD_INT 106
45484: PUSH
45485: LD_INT 108
45487: PUSH
45488: LD_INT 116
45490: PUSH
45491: LD_INT 117
45493: PUSH
45494: LD_INT 118
45496: PUSH
45497: EMPTY
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: LIST
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: ST_TO_ADDR
45511: GO 48294
45513: LD_INT 5
45515: DOUBLE
45516: EQUAL
45517: IFTRUE 45521
45519: GO 45633
45521: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45522: LD_ADDR_VAR 0 2
45526: PUSH
45527: LD_INT 2
45529: PUSH
45530: LD_INT 4
45532: PUSH
45533: LD_INT 5
45535: PUSH
45536: LD_INT 6
45538: PUSH
45539: LD_INT 8
45541: PUSH
45542: LD_INT 11
45544: PUSH
45545: LD_INT 12
45547: PUSH
45548: LD_INT 15
45550: PUSH
45551: LD_INT 16
45553: PUSH
45554: LD_INT 22
45556: PUSH
45557: LD_INT 23
45559: PUSH
45560: LD_INT 25
45562: PUSH
45563: LD_INT 26
45565: PUSH
45566: LD_INT 36
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 101
45587: PUSH
45588: LD_INT 102
45590: PUSH
45591: LD_INT 105
45593: PUSH
45594: LD_INT 106
45596: PUSH
45597: LD_INT 108
45599: PUSH
45600: LD_INT 109
45602: PUSH
45603: LD_INT 112
45605: PUSH
45606: LD_INT 116
45608: PUSH
45609: LD_INT 117
45611: PUSH
45612: LD_INT 118
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: ST_TO_ADDR
45631: GO 48294
45633: LD_INT 6
45635: DOUBLE
45636: EQUAL
45637: IFTRUE 45641
45639: GO 45773
45641: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45642: LD_ADDR_VAR 0 2
45646: PUSH
45647: LD_INT 2
45649: PUSH
45650: LD_INT 4
45652: PUSH
45653: LD_INT 5
45655: PUSH
45656: LD_INT 6
45658: PUSH
45659: LD_INT 8
45661: PUSH
45662: LD_INT 11
45664: PUSH
45665: LD_INT 12
45667: PUSH
45668: LD_INT 15
45670: PUSH
45671: LD_INT 16
45673: PUSH
45674: LD_INT 20
45676: PUSH
45677: LD_INT 21
45679: PUSH
45680: LD_INT 22
45682: PUSH
45683: LD_INT 23
45685: PUSH
45686: LD_INT 25
45688: PUSH
45689: LD_INT 26
45691: PUSH
45692: LD_INT 30
45694: PUSH
45695: LD_INT 31
45697: PUSH
45698: LD_INT 32
45700: PUSH
45701: LD_INT 36
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: LIST
45716: LIST
45717: LIST
45718: LIST
45719: LIST
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 101
45727: PUSH
45728: LD_INT 102
45730: PUSH
45731: LD_INT 105
45733: PUSH
45734: LD_INT 106
45736: PUSH
45737: LD_INT 108
45739: PUSH
45740: LD_INT 109
45742: PUSH
45743: LD_INT 112
45745: PUSH
45746: LD_INT 116
45748: PUSH
45749: LD_INT 117
45751: PUSH
45752: LD_INT 118
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: ST_TO_ADDR
45771: GO 48294
45773: LD_INT 7
45775: DOUBLE
45776: EQUAL
45777: IFTRUE 45781
45779: GO 45893
45781: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45782: LD_ADDR_VAR 0 2
45786: PUSH
45787: LD_INT 2
45789: PUSH
45790: LD_INT 4
45792: PUSH
45793: LD_INT 5
45795: PUSH
45796: LD_INT 7
45798: PUSH
45799: LD_INT 11
45801: PUSH
45802: LD_INT 12
45804: PUSH
45805: LD_INT 15
45807: PUSH
45808: LD_INT 16
45810: PUSH
45811: LD_INT 20
45813: PUSH
45814: LD_INT 21
45816: PUSH
45817: LD_INT 22
45819: PUSH
45820: LD_INT 23
45822: PUSH
45823: LD_INT 25
45825: PUSH
45826: LD_INT 26
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: PUSH
45845: LD_INT 101
45847: PUSH
45848: LD_INT 102
45850: PUSH
45851: LD_INT 103
45853: PUSH
45854: LD_INT 105
45856: PUSH
45857: LD_INT 106
45859: PUSH
45860: LD_INT 108
45862: PUSH
45863: LD_INT 112
45865: PUSH
45866: LD_INT 116
45868: PUSH
45869: LD_INT 117
45871: PUSH
45872: LD_INT 118
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: ST_TO_ADDR
45891: GO 48294
45893: LD_INT 8
45895: DOUBLE
45896: EQUAL
45897: IFTRUE 45901
45899: GO 46041
45901: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45902: LD_ADDR_VAR 0 2
45906: PUSH
45907: LD_INT 2
45909: PUSH
45910: LD_INT 4
45912: PUSH
45913: LD_INT 5
45915: PUSH
45916: LD_INT 6
45918: PUSH
45919: LD_INT 7
45921: PUSH
45922: LD_INT 8
45924: PUSH
45925: LD_INT 11
45927: PUSH
45928: LD_INT 12
45930: PUSH
45931: LD_INT 15
45933: PUSH
45934: LD_INT 16
45936: PUSH
45937: LD_INT 20
45939: PUSH
45940: LD_INT 21
45942: PUSH
45943: LD_INT 22
45945: PUSH
45946: LD_INT 23
45948: PUSH
45949: LD_INT 25
45951: PUSH
45952: LD_INT 26
45954: PUSH
45955: LD_INT 30
45957: PUSH
45958: LD_INT 31
45960: PUSH
45961: LD_INT 32
45963: PUSH
45964: LD_INT 36
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 101
45991: PUSH
45992: LD_INT 102
45994: PUSH
45995: LD_INT 103
45997: PUSH
45998: LD_INT 105
46000: PUSH
46001: LD_INT 106
46003: PUSH
46004: LD_INT 108
46006: PUSH
46007: LD_INT 109
46009: PUSH
46010: LD_INT 112
46012: PUSH
46013: LD_INT 116
46015: PUSH
46016: LD_INT 117
46018: PUSH
46019: LD_INT 118
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: ST_TO_ADDR
46039: GO 48294
46041: LD_INT 9
46043: DOUBLE
46044: EQUAL
46045: IFTRUE 46049
46047: GO 46197
46049: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46050: LD_ADDR_VAR 0 2
46054: PUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 4
46060: PUSH
46061: LD_INT 5
46063: PUSH
46064: LD_INT 6
46066: PUSH
46067: LD_INT 7
46069: PUSH
46070: LD_INT 8
46072: PUSH
46073: LD_INT 11
46075: PUSH
46076: LD_INT 12
46078: PUSH
46079: LD_INT 15
46081: PUSH
46082: LD_INT 16
46084: PUSH
46085: LD_INT 20
46087: PUSH
46088: LD_INT 21
46090: PUSH
46091: LD_INT 22
46093: PUSH
46094: LD_INT 23
46096: PUSH
46097: LD_INT 25
46099: PUSH
46100: LD_INT 26
46102: PUSH
46103: LD_INT 28
46105: PUSH
46106: LD_INT 30
46108: PUSH
46109: LD_INT 31
46111: PUSH
46112: LD_INT 32
46114: PUSH
46115: LD_INT 36
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: PUSH
46141: LD_INT 101
46143: PUSH
46144: LD_INT 102
46146: PUSH
46147: LD_INT 103
46149: PUSH
46150: LD_INT 105
46152: PUSH
46153: LD_INT 106
46155: PUSH
46156: LD_INT 108
46158: PUSH
46159: LD_INT 109
46161: PUSH
46162: LD_INT 112
46164: PUSH
46165: LD_INT 114
46167: PUSH
46168: LD_INT 116
46170: PUSH
46171: LD_INT 117
46173: PUSH
46174: LD_INT 118
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: PUSH
46191: EMPTY
46192: LIST
46193: LIST
46194: ST_TO_ADDR
46195: GO 48294
46197: LD_INT 10
46199: DOUBLE
46200: EQUAL
46201: IFTRUE 46205
46203: GO 46401
46205: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46206: LD_ADDR_VAR 0 2
46210: PUSH
46211: LD_INT 2
46213: PUSH
46214: LD_INT 4
46216: PUSH
46217: LD_INT 5
46219: PUSH
46220: LD_INT 6
46222: PUSH
46223: LD_INT 7
46225: PUSH
46226: LD_INT 8
46228: PUSH
46229: LD_INT 9
46231: PUSH
46232: LD_INT 10
46234: PUSH
46235: LD_INT 11
46237: PUSH
46238: LD_INT 12
46240: PUSH
46241: LD_INT 13
46243: PUSH
46244: LD_INT 14
46246: PUSH
46247: LD_INT 15
46249: PUSH
46250: LD_INT 16
46252: PUSH
46253: LD_INT 17
46255: PUSH
46256: LD_INT 18
46258: PUSH
46259: LD_INT 19
46261: PUSH
46262: LD_INT 20
46264: PUSH
46265: LD_INT 21
46267: PUSH
46268: LD_INT 22
46270: PUSH
46271: LD_INT 23
46273: PUSH
46274: LD_INT 24
46276: PUSH
46277: LD_INT 25
46279: PUSH
46280: LD_INT 26
46282: PUSH
46283: LD_INT 28
46285: PUSH
46286: LD_INT 30
46288: PUSH
46289: LD_INT 31
46291: PUSH
46292: LD_INT 32
46294: PUSH
46295: LD_INT 36
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 101
46331: PUSH
46332: LD_INT 102
46334: PUSH
46335: LD_INT 103
46337: PUSH
46338: LD_INT 104
46340: PUSH
46341: LD_INT 105
46343: PUSH
46344: LD_INT 106
46346: PUSH
46347: LD_INT 107
46349: PUSH
46350: LD_INT 108
46352: PUSH
46353: LD_INT 109
46355: PUSH
46356: LD_INT 110
46358: PUSH
46359: LD_INT 111
46361: PUSH
46362: LD_INT 112
46364: PUSH
46365: LD_INT 114
46367: PUSH
46368: LD_INT 116
46370: PUSH
46371: LD_INT 117
46373: PUSH
46374: LD_INT 118
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: ST_TO_ADDR
46399: GO 48294
46401: LD_INT 11
46403: DOUBLE
46404: EQUAL
46405: IFTRUE 46409
46407: GO 46613
46409: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46410: LD_ADDR_VAR 0 2
46414: PUSH
46415: LD_INT 2
46417: PUSH
46418: LD_INT 3
46420: PUSH
46421: LD_INT 4
46423: PUSH
46424: LD_INT 5
46426: PUSH
46427: LD_INT 6
46429: PUSH
46430: LD_INT 7
46432: PUSH
46433: LD_INT 8
46435: PUSH
46436: LD_INT 9
46438: PUSH
46439: LD_INT 10
46441: PUSH
46442: LD_INT 11
46444: PUSH
46445: LD_INT 12
46447: PUSH
46448: LD_INT 13
46450: PUSH
46451: LD_INT 14
46453: PUSH
46454: LD_INT 15
46456: PUSH
46457: LD_INT 16
46459: PUSH
46460: LD_INT 17
46462: PUSH
46463: LD_INT 18
46465: PUSH
46466: LD_INT 19
46468: PUSH
46469: LD_INT 20
46471: PUSH
46472: LD_INT 21
46474: PUSH
46475: LD_INT 22
46477: PUSH
46478: LD_INT 23
46480: PUSH
46481: LD_INT 24
46483: PUSH
46484: LD_INT 25
46486: PUSH
46487: LD_INT 26
46489: PUSH
46490: LD_INT 28
46492: PUSH
46493: LD_INT 30
46495: PUSH
46496: LD_INT 31
46498: PUSH
46499: LD_INT 32
46501: PUSH
46502: LD_INT 34
46504: PUSH
46505: LD_INT 36
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 101
46543: PUSH
46544: LD_INT 102
46546: PUSH
46547: LD_INT 103
46549: PUSH
46550: LD_INT 104
46552: PUSH
46553: LD_INT 105
46555: PUSH
46556: LD_INT 106
46558: PUSH
46559: LD_INT 107
46561: PUSH
46562: LD_INT 108
46564: PUSH
46565: LD_INT 109
46567: PUSH
46568: LD_INT 110
46570: PUSH
46571: LD_INT 111
46573: PUSH
46574: LD_INT 112
46576: PUSH
46577: LD_INT 114
46579: PUSH
46580: LD_INT 116
46582: PUSH
46583: LD_INT 117
46585: PUSH
46586: LD_INT 118
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: PUSH
46607: EMPTY
46608: LIST
46609: LIST
46610: ST_TO_ADDR
46611: GO 48294
46613: LD_INT 12
46615: DOUBLE
46616: EQUAL
46617: IFTRUE 46621
46619: GO 46841
46621: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46622: LD_ADDR_VAR 0 2
46626: PUSH
46627: LD_INT 1
46629: PUSH
46630: LD_INT 2
46632: PUSH
46633: LD_INT 3
46635: PUSH
46636: LD_INT 4
46638: PUSH
46639: LD_INT 5
46641: PUSH
46642: LD_INT 6
46644: PUSH
46645: LD_INT 7
46647: PUSH
46648: LD_INT 8
46650: PUSH
46651: LD_INT 9
46653: PUSH
46654: LD_INT 10
46656: PUSH
46657: LD_INT 11
46659: PUSH
46660: LD_INT 12
46662: PUSH
46663: LD_INT 13
46665: PUSH
46666: LD_INT 14
46668: PUSH
46669: LD_INT 15
46671: PUSH
46672: LD_INT 16
46674: PUSH
46675: LD_INT 17
46677: PUSH
46678: LD_INT 18
46680: PUSH
46681: LD_INT 19
46683: PUSH
46684: LD_INT 20
46686: PUSH
46687: LD_INT 21
46689: PUSH
46690: LD_INT 22
46692: PUSH
46693: LD_INT 23
46695: PUSH
46696: LD_INT 24
46698: PUSH
46699: LD_INT 25
46701: PUSH
46702: LD_INT 26
46704: PUSH
46705: LD_INT 27
46707: PUSH
46708: LD_INT 28
46710: PUSH
46711: LD_INT 30
46713: PUSH
46714: LD_INT 31
46716: PUSH
46717: LD_INT 32
46719: PUSH
46720: LD_INT 33
46722: PUSH
46723: LD_INT 34
46725: PUSH
46726: LD_INT 36
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: PUSH
46765: LD_INT 101
46767: PUSH
46768: LD_INT 102
46770: PUSH
46771: LD_INT 103
46773: PUSH
46774: LD_INT 104
46776: PUSH
46777: LD_INT 105
46779: PUSH
46780: LD_INT 106
46782: PUSH
46783: LD_INT 107
46785: PUSH
46786: LD_INT 108
46788: PUSH
46789: LD_INT 109
46791: PUSH
46792: LD_INT 110
46794: PUSH
46795: LD_INT 111
46797: PUSH
46798: LD_INT 112
46800: PUSH
46801: LD_INT 113
46803: PUSH
46804: LD_INT 114
46806: PUSH
46807: LD_INT 116
46809: PUSH
46810: LD_INT 117
46812: PUSH
46813: LD_INT 118
46815: PUSH
46816: EMPTY
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: ST_TO_ADDR
46839: GO 48294
46841: LD_INT 13
46843: DOUBLE
46844: EQUAL
46845: IFTRUE 46849
46847: GO 47057
46849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46850: LD_ADDR_VAR 0 2
46854: PUSH
46855: LD_INT 1
46857: PUSH
46858: LD_INT 2
46860: PUSH
46861: LD_INT 3
46863: PUSH
46864: LD_INT 4
46866: PUSH
46867: LD_INT 5
46869: PUSH
46870: LD_INT 8
46872: PUSH
46873: LD_INT 9
46875: PUSH
46876: LD_INT 10
46878: PUSH
46879: LD_INT 11
46881: PUSH
46882: LD_INT 12
46884: PUSH
46885: LD_INT 14
46887: PUSH
46888: LD_INT 15
46890: PUSH
46891: LD_INT 16
46893: PUSH
46894: LD_INT 17
46896: PUSH
46897: LD_INT 18
46899: PUSH
46900: LD_INT 19
46902: PUSH
46903: LD_INT 20
46905: PUSH
46906: LD_INT 21
46908: PUSH
46909: LD_INT 22
46911: PUSH
46912: LD_INT 23
46914: PUSH
46915: LD_INT 24
46917: PUSH
46918: LD_INT 25
46920: PUSH
46921: LD_INT 26
46923: PUSH
46924: LD_INT 27
46926: PUSH
46927: LD_INT 28
46929: PUSH
46930: LD_INT 30
46932: PUSH
46933: LD_INT 31
46935: PUSH
46936: LD_INT 32
46938: PUSH
46939: LD_INT 33
46941: PUSH
46942: LD_INT 34
46944: PUSH
46945: LD_INT 36
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: PUSH
46981: LD_INT 101
46983: PUSH
46984: LD_INT 102
46986: PUSH
46987: LD_INT 103
46989: PUSH
46990: LD_INT 104
46992: PUSH
46993: LD_INT 105
46995: PUSH
46996: LD_INT 106
46998: PUSH
46999: LD_INT 107
47001: PUSH
47002: LD_INT 108
47004: PUSH
47005: LD_INT 109
47007: PUSH
47008: LD_INT 110
47010: PUSH
47011: LD_INT 111
47013: PUSH
47014: LD_INT 112
47016: PUSH
47017: LD_INT 113
47019: PUSH
47020: LD_INT 114
47022: PUSH
47023: LD_INT 116
47025: PUSH
47026: LD_INT 117
47028: PUSH
47029: LD_INT 118
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: ST_TO_ADDR
47055: GO 48294
47057: LD_INT 14
47059: DOUBLE
47060: EQUAL
47061: IFTRUE 47065
47063: GO 47289
47065: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47066: LD_ADDR_VAR 0 2
47070: PUSH
47071: LD_INT 1
47073: PUSH
47074: LD_INT 2
47076: PUSH
47077: LD_INT 3
47079: PUSH
47080: LD_INT 4
47082: PUSH
47083: LD_INT 5
47085: PUSH
47086: LD_INT 6
47088: PUSH
47089: LD_INT 7
47091: PUSH
47092: LD_INT 8
47094: PUSH
47095: LD_INT 9
47097: PUSH
47098: LD_INT 10
47100: PUSH
47101: LD_INT 11
47103: PUSH
47104: LD_INT 12
47106: PUSH
47107: LD_INT 13
47109: PUSH
47110: LD_INT 14
47112: PUSH
47113: LD_INT 15
47115: PUSH
47116: LD_INT 16
47118: PUSH
47119: LD_INT 17
47121: PUSH
47122: LD_INT 18
47124: PUSH
47125: LD_INT 19
47127: PUSH
47128: LD_INT 20
47130: PUSH
47131: LD_INT 21
47133: PUSH
47134: LD_INT 22
47136: PUSH
47137: LD_INT 23
47139: PUSH
47140: LD_INT 24
47142: PUSH
47143: LD_INT 25
47145: PUSH
47146: LD_INT 26
47148: PUSH
47149: LD_INT 27
47151: PUSH
47152: LD_INT 28
47154: PUSH
47155: LD_INT 29
47157: PUSH
47158: LD_INT 30
47160: PUSH
47161: LD_INT 31
47163: PUSH
47164: LD_INT 32
47166: PUSH
47167: LD_INT 33
47169: PUSH
47170: LD_INT 34
47172: PUSH
47173: LD_INT 36
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: PUSH
47213: LD_INT 101
47215: PUSH
47216: LD_INT 102
47218: PUSH
47219: LD_INT 103
47221: PUSH
47222: LD_INT 104
47224: PUSH
47225: LD_INT 105
47227: PUSH
47228: LD_INT 106
47230: PUSH
47231: LD_INT 107
47233: PUSH
47234: LD_INT 108
47236: PUSH
47237: LD_INT 109
47239: PUSH
47240: LD_INT 110
47242: PUSH
47243: LD_INT 111
47245: PUSH
47246: LD_INT 112
47248: PUSH
47249: LD_INT 113
47251: PUSH
47252: LD_INT 114
47254: PUSH
47255: LD_INT 116
47257: PUSH
47258: LD_INT 117
47260: PUSH
47261: LD_INT 118
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: PUSH
47283: EMPTY
47284: LIST
47285: LIST
47286: ST_TO_ADDR
47287: GO 48294
47289: LD_INT 15
47291: DOUBLE
47292: EQUAL
47293: IFTRUE 47297
47295: GO 47521
47297: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47298: LD_ADDR_VAR 0 2
47302: PUSH
47303: LD_INT 1
47305: PUSH
47306: LD_INT 2
47308: PUSH
47309: LD_INT 3
47311: PUSH
47312: LD_INT 4
47314: PUSH
47315: LD_INT 5
47317: PUSH
47318: LD_INT 6
47320: PUSH
47321: LD_INT 7
47323: PUSH
47324: LD_INT 8
47326: PUSH
47327: LD_INT 9
47329: PUSH
47330: LD_INT 10
47332: PUSH
47333: LD_INT 11
47335: PUSH
47336: LD_INT 12
47338: PUSH
47339: LD_INT 13
47341: PUSH
47342: LD_INT 14
47344: PUSH
47345: LD_INT 15
47347: PUSH
47348: LD_INT 16
47350: PUSH
47351: LD_INT 17
47353: PUSH
47354: LD_INT 18
47356: PUSH
47357: LD_INT 19
47359: PUSH
47360: LD_INT 20
47362: PUSH
47363: LD_INT 21
47365: PUSH
47366: LD_INT 22
47368: PUSH
47369: LD_INT 23
47371: PUSH
47372: LD_INT 24
47374: PUSH
47375: LD_INT 25
47377: PUSH
47378: LD_INT 26
47380: PUSH
47381: LD_INT 27
47383: PUSH
47384: LD_INT 28
47386: PUSH
47387: LD_INT 29
47389: PUSH
47390: LD_INT 30
47392: PUSH
47393: LD_INT 31
47395: PUSH
47396: LD_INT 32
47398: PUSH
47399: LD_INT 33
47401: PUSH
47402: LD_INT 34
47404: PUSH
47405: LD_INT 36
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: PUSH
47445: LD_INT 101
47447: PUSH
47448: LD_INT 102
47450: PUSH
47451: LD_INT 103
47453: PUSH
47454: LD_INT 104
47456: PUSH
47457: LD_INT 105
47459: PUSH
47460: LD_INT 106
47462: PUSH
47463: LD_INT 107
47465: PUSH
47466: LD_INT 108
47468: PUSH
47469: LD_INT 109
47471: PUSH
47472: LD_INT 110
47474: PUSH
47475: LD_INT 111
47477: PUSH
47478: LD_INT 112
47480: PUSH
47481: LD_INT 113
47483: PUSH
47484: LD_INT 114
47486: PUSH
47487: LD_INT 116
47489: PUSH
47490: LD_INT 117
47492: PUSH
47493: LD_INT 118
47495: PUSH
47496: EMPTY
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: ST_TO_ADDR
47519: GO 48294
47521: LD_INT 16
47523: DOUBLE
47524: EQUAL
47525: IFTRUE 47529
47527: GO 47665
47529: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47530: LD_ADDR_VAR 0 2
47534: PUSH
47535: LD_INT 2
47537: PUSH
47538: LD_INT 4
47540: PUSH
47541: LD_INT 5
47543: PUSH
47544: LD_INT 7
47546: PUSH
47547: LD_INT 11
47549: PUSH
47550: LD_INT 12
47552: PUSH
47553: LD_INT 15
47555: PUSH
47556: LD_INT 16
47558: PUSH
47559: LD_INT 20
47561: PUSH
47562: LD_INT 21
47564: PUSH
47565: LD_INT 22
47567: PUSH
47568: LD_INT 23
47570: PUSH
47571: LD_INT 25
47573: PUSH
47574: LD_INT 26
47576: PUSH
47577: LD_INT 30
47579: PUSH
47580: LD_INT 31
47582: PUSH
47583: LD_INT 32
47585: PUSH
47586: LD_INT 33
47588: PUSH
47589: LD_INT 34
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 101
47615: PUSH
47616: LD_INT 102
47618: PUSH
47619: LD_INT 103
47621: PUSH
47622: LD_INT 106
47624: PUSH
47625: LD_INT 108
47627: PUSH
47628: LD_INT 112
47630: PUSH
47631: LD_INT 113
47633: PUSH
47634: LD_INT 114
47636: PUSH
47637: LD_INT 116
47639: PUSH
47640: LD_INT 117
47642: PUSH
47643: LD_INT 118
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: ST_TO_ADDR
47663: GO 48294
47665: LD_INT 17
47667: DOUBLE
47668: EQUAL
47669: IFTRUE 47673
47671: GO 47897
47673: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47674: LD_ADDR_VAR 0 2
47678: PUSH
47679: LD_INT 1
47681: PUSH
47682: LD_INT 2
47684: PUSH
47685: LD_INT 3
47687: PUSH
47688: LD_INT 4
47690: PUSH
47691: LD_INT 5
47693: PUSH
47694: LD_INT 6
47696: PUSH
47697: LD_INT 7
47699: PUSH
47700: LD_INT 8
47702: PUSH
47703: LD_INT 9
47705: PUSH
47706: LD_INT 10
47708: PUSH
47709: LD_INT 11
47711: PUSH
47712: LD_INT 12
47714: PUSH
47715: LD_INT 13
47717: PUSH
47718: LD_INT 14
47720: PUSH
47721: LD_INT 15
47723: PUSH
47724: LD_INT 16
47726: PUSH
47727: LD_INT 17
47729: PUSH
47730: LD_INT 18
47732: PUSH
47733: LD_INT 19
47735: PUSH
47736: LD_INT 20
47738: PUSH
47739: LD_INT 21
47741: PUSH
47742: LD_INT 22
47744: PUSH
47745: LD_INT 23
47747: PUSH
47748: LD_INT 24
47750: PUSH
47751: LD_INT 25
47753: PUSH
47754: LD_INT 26
47756: PUSH
47757: LD_INT 27
47759: PUSH
47760: LD_INT 28
47762: PUSH
47763: LD_INT 29
47765: PUSH
47766: LD_INT 30
47768: PUSH
47769: LD_INT 31
47771: PUSH
47772: LD_INT 32
47774: PUSH
47775: LD_INT 33
47777: PUSH
47778: LD_INT 34
47780: PUSH
47781: LD_INT 36
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: PUSH
47821: LD_INT 101
47823: PUSH
47824: LD_INT 102
47826: PUSH
47827: LD_INT 103
47829: PUSH
47830: LD_INT 104
47832: PUSH
47833: LD_INT 105
47835: PUSH
47836: LD_INT 106
47838: PUSH
47839: LD_INT 107
47841: PUSH
47842: LD_INT 108
47844: PUSH
47845: LD_INT 109
47847: PUSH
47848: LD_INT 110
47850: PUSH
47851: LD_INT 111
47853: PUSH
47854: LD_INT 112
47856: PUSH
47857: LD_INT 113
47859: PUSH
47860: LD_INT 114
47862: PUSH
47863: LD_INT 116
47865: PUSH
47866: LD_INT 117
47868: PUSH
47869: LD_INT 118
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: ST_TO_ADDR
47895: GO 48294
47897: LD_INT 18
47899: DOUBLE
47900: EQUAL
47901: IFTRUE 47905
47903: GO 48053
47905: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47906: LD_ADDR_VAR 0 2
47910: PUSH
47911: LD_INT 2
47913: PUSH
47914: LD_INT 4
47916: PUSH
47917: LD_INT 5
47919: PUSH
47920: LD_INT 7
47922: PUSH
47923: LD_INT 11
47925: PUSH
47926: LD_INT 12
47928: PUSH
47929: LD_INT 15
47931: PUSH
47932: LD_INT 16
47934: PUSH
47935: LD_INT 20
47937: PUSH
47938: LD_INT 21
47940: PUSH
47941: LD_INT 22
47943: PUSH
47944: LD_INT 23
47946: PUSH
47947: LD_INT 25
47949: PUSH
47950: LD_INT 26
47952: PUSH
47953: LD_INT 30
47955: PUSH
47956: LD_INT 31
47958: PUSH
47959: LD_INT 32
47961: PUSH
47962: LD_INT 33
47964: PUSH
47965: LD_INT 34
47967: PUSH
47968: LD_INT 35
47970: PUSH
47971: LD_INT 36
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 101
47999: PUSH
48000: LD_INT 102
48002: PUSH
48003: LD_INT 103
48005: PUSH
48006: LD_INT 106
48008: PUSH
48009: LD_INT 108
48011: PUSH
48012: LD_INT 112
48014: PUSH
48015: LD_INT 113
48017: PUSH
48018: LD_INT 114
48020: PUSH
48021: LD_INT 115
48023: PUSH
48024: LD_INT 116
48026: PUSH
48027: LD_INT 117
48029: PUSH
48030: LD_INT 118
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: ST_TO_ADDR
48051: GO 48294
48053: LD_INT 19
48055: DOUBLE
48056: EQUAL
48057: IFTRUE 48061
48059: GO 48293
48061: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48062: LD_ADDR_VAR 0 2
48066: PUSH
48067: LD_INT 1
48069: PUSH
48070: LD_INT 2
48072: PUSH
48073: LD_INT 3
48075: PUSH
48076: LD_INT 4
48078: PUSH
48079: LD_INT 5
48081: PUSH
48082: LD_INT 6
48084: PUSH
48085: LD_INT 7
48087: PUSH
48088: LD_INT 8
48090: PUSH
48091: LD_INT 9
48093: PUSH
48094: LD_INT 10
48096: PUSH
48097: LD_INT 11
48099: PUSH
48100: LD_INT 12
48102: PUSH
48103: LD_INT 13
48105: PUSH
48106: LD_INT 14
48108: PUSH
48109: LD_INT 15
48111: PUSH
48112: LD_INT 16
48114: PUSH
48115: LD_INT 17
48117: PUSH
48118: LD_INT 18
48120: PUSH
48121: LD_INT 19
48123: PUSH
48124: LD_INT 20
48126: PUSH
48127: LD_INT 21
48129: PUSH
48130: LD_INT 22
48132: PUSH
48133: LD_INT 23
48135: PUSH
48136: LD_INT 24
48138: PUSH
48139: LD_INT 25
48141: PUSH
48142: LD_INT 26
48144: PUSH
48145: LD_INT 27
48147: PUSH
48148: LD_INT 28
48150: PUSH
48151: LD_INT 29
48153: PUSH
48154: LD_INT 30
48156: PUSH
48157: LD_INT 31
48159: PUSH
48160: LD_INT 32
48162: PUSH
48163: LD_INT 33
48165: PUSH
48166: LD_INT 34
48168: PUSH
48169: LD_INT 35
48171: PUSH
48172: LD_INT 36
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 101
48215: PUSH
48216: LD_INT 102
48218: PUSH
48219: LD_INT 103
48221: PUSH
48222: LD_INT 104
48224: PUSH
48225: LD_INT 105
48227: PUSH
48228: LD_INT 106
48230: PUSH
48231: LD_INT 107
48233: PUSH
48234: LD_INT 108
48236: PUSH
48237: LD_INT 109
48239: PUSH
48240: LD_INT 110
48242: PUSH
48243: LD_INT 111
48245: PUSH
48246: LD_INT 112
48248: PUSH
48249: LD_INT 113
48251: PUSH
48252: LD_INT 114
48254: PUSH
48255: LD_INT 115
48257: PUSH
48258: LD_INT 116
48260: PUSH
48261: LD_INT 117
48263: PUSH
48264: LD_INT 118
48266: PUSH
48267: EMPTY
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: PUSH
48287: EMPTY
48288: LIST
48289: LIST
48290: ST_TO_ADDR
48291: GO 48294
48293: POP
// end else
48294: GO 48525
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48296: LD_ADDR_VAR 0 2
48300: PUSH
48301: LD_INT 1
48303: PUSH
48304: LD_INT 2
48306: PUSH
48307: LD_INT 3
48309: PUSH
48310: LD_INT 4
48312: PUSH
48313: LD_INT 5
48315: PUSH
48316: LD_INT 6
48318: PUSH
48319: LD_INT 7
48321: PUSH
48322: LD_INT 8
48324: PUSH
48325: LD_INT 9
48327: PUSH
48328: LD_INT 10
48330: PUSH
48331: LD_INT 11
48333: PUSH
48334: LD_INT 12
48336: PUSH
48337: LD_INT 13
48339: PUSH
48340: LD_INT 14
48342: PUSH
48343: LD_INT 15
48345: PUSH
48346: LD_INT 16
48348: PUSH
48349: LD_INT 17
48351: PUSH
48352: LD_INT 18
48354: PUSH
48355: LD_INT 19
48357: PUSH
48358: LD_INT 20
48360: PUSH
48361: LD_INT 21
48363: PUSH
48364: LD_INT 22
48366: PUSH
48367: LD_INT 23
48369: PUSH
48370: LD_INT 24
48372: PUSH
48373: LD_INT 25
48375: PUSH
48376: LD_INT 26
48378: PUSH
48379: LD_INT 27
48381: PUSH
48382: LD_INT 28
48384: PUSH
48385: LD_INT 29
48387: PUSH
48388: LD_INT 30
48390: PUSH
48391: LD_INT 31
48393: PUSH
48394: LD_INT 32
48396: PUSH
48397: LD_INT 33
48399: PUSH
48400: LD_INT 34
48402: PUSH
48403: LD_INT 35
48405: PUSH
48406: LD_INT 36
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: LIST
48446: PUSH
48447: LD_INT 101
48449: PUSH
48450: LD_INT 102
48452: PUSH
48453: LD_INT 103
48455: PUSH
48456: LD_INT 104
48458: PUSH
48459: LD_INT 105
48461: PUSH
48462: LD_INT 106
48464: PUSH
48465: LD_INT 107
48467: PUSH
48468: LD_INT 108
48470: PUSH
48471: LD_INT 109
48473: PUSH
48474: LD_INT 110
48476: PUSH
48477: LD_INT 111
48479: PUSH
48480: LD_INT 112
48482: PUSH
48483: LD_INT 113
48485: PUSH
48486: LD_INT 114
48488: PUSH
48489: LD_INT 115
48491: PUSH
48492: LD_INT 116
48494: PUSH
48495: LD_INT 117
48497: PUSH
48498: LD_INT 118
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: LIST
48507: LIST
48508: LIST
48509: LIST
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: LIST
48516: LIST
48517: LIST
48518: LIST
48519: LIST
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: ST_TO_ADDR
// if result then
48525: LD_VAR 0 2
48529: IFFALSE 49315
// begin normal :=  ;
48531: LD_ADDR_VAR 0 5
48535: PUSH
48536: LD_STRING 
48538: ST_TO_ADDR
// hardcore :=  ;
48539: LD_ADDR_VAR 0 6
48543: PUSH
48544: LD_STRING 
48546: ST_TO_ADDR
// active :=  ;
48547: LD_ADDR_VAR 0 7
48551: PUSH
48552: LD_STRING 
48554: ST_TO_ADDR
// for i = 1 to normalCounter do
48555: LD_ADDR_VAR 0 8
48559: PUSH
48560: DOUBLE
48561: LD_INT 1
48563: DEC
48564: ST_TO_ADDR
48565: LD_EXP 75
48569: PUSH
48570: FOR_TO
48571: IFFALSE 48672
// begin tmp := 0 ;
48573: LD_ADDR_VAR 0 3
48577: PUSH
48578: LD_STRING 0
48580: ST_TO_ADDR
// if result [ 1 ] then
48581: LD_VAR 0 2
48585: PUSH
48586: LD_INT 1
48588: ARRAY
48589: IFFALSE 48654
// if result [ 1 ] [ 1 ] = i then
48591: LD_VAR 0 2
48595: PUSH
48596: LD_INT 1
48598: ARRAY
48599: PUSH
48600: LD_INT 1
48602: ARRAY
48603: PUSH
48604: LD_VAR 0 8
48608: EQUAL
48609: IFFALSE 48654
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48611: LD_ADDR_VAR 0 2
48615: PUSH
48616: LD_VAR 0 2
48620: PPUSH
48621: LD_INT 1
48623: PPUSH
48624: LD_VAR 0 2
48628: PUSH
48629: LD_INT 1
48631: ARRAY
48632: PPUSH
48633: LD_INT 1
48635: PPUSH
48636: CALL_OW 3
48640: PPUSH
48641: CALL_OW 1
48645: ST_TO_ADDR
// tmp := 1 ;
48646: LD_ADDR_VAR 0 3
48650: PUSH
48651: LD_STRING 1
48653: ST_TO_ADDR
// end ; normal := normal & tmp ;
48654: LD_ADDR_VAR 0 5
48658: PUSH
48659: LD_VAR 0 5
48663: PUSH
48664: LD_VAR 0 3
48668: STR
48669: ST_TO_ADDR
// end ;
48670: GO 48570
48672: POP
48673: POP
// for i = 1 to hardcoreCounter do
48674: LD_ADDR_VAR 0 8
48678: PUSH
48679: DOUBLE
48680: LD_INT 1
48682: DEC
48683: ST_TO_ADDR
48684: LD_EXP 76
48688: PUSH
48689: FOR_TO
48690: IFFALSE 48795
// begin tmp := 0 ;
48692: LD_ADDR_VAR 0 3
48696: PUSH
48697: LD_STRING 0
48699: ST_TO_ADDR
// if result [ 2 ] then
48700: LD_VAR 0 2
48704: PUSH
48705: LD_INT 2
48707: ARRAY
48708: IFFALSE 48777
// if result [ 2 ] [ 1 ] = 100 + i then
48710: LD_VAR 0 2
48714: PUSH
48715: LD_INT 2
48717: ARRAY
48718: PUSH
48719: LD_INT 1
48721: ARRAY
48722: PUSH
48723: LD_INT 100
48725: PUSH
48726: LD_VAR 0 8
48730: PLUS
48731: EQUAL
48732: IFFALSE 48777
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48734: LD_ADDR_VAR 0 2
48738: PUSH
48739: LD_VAR 0 2
48743: PPUSH
48744: LD_INT 2
48746: PPUSH
48747: LD_VAR 0 2
48751: PUSH
48752: LD_INT 2
48754: ARRAY
48755: PPUSH
48756: LD_INT 1
48758: PPUSH
48759: CALL_OW 3
48763: PPUSH
48764: CALL_OW 1
48768: ST_TO_ADDR
// tmp := 1 ;
48769: LD_ADDR_VAR 0 3
48773: PUSH
48774: LD_STRING 1
48776: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48777: LD_ADDR_VAR 0 6
48781: PUSH
48782: LD_VAR 0 6
48786: PUSH
48787: LD_VAR 0 3
48791: STR
48792: ST_TO_ADDR
// end ;
48793: GO 48689
48795: POP
48796: POP
// if isGameLoad then
48797: LD_VAR 0 1
48801: IFFALSE 49276
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48803: LD_ADDR_VAR 0 4
48807: PUSH
48808: LD_EXP 79
48812: PUSH
48813: LD_EXP 78
48817: PUSH
48818: LD_EXP 80
48822: PUSH
48823: LD_EXP 77
48827: PUSH
48828: LD_EXP 81
48832: PUSH
48833: LD_EXP 82
48837: PUSH
48838: LD_EXP 83
48842: PUSH
48843: LD_EXP 84
48847: PUSH
48848: LD_EXP 85
48852: PUSH
48853: LD_EXP 86
48857: PUSH
48858: LD_EXP 87
48862: PUSH
48863: LD_EXP 88
48867: PUSH
48868: LD_EXP 89
48872: PUSH
48873: LD_EXP 90
48877: PUSH
48878: LD_EXP 98
48882: PUSH
48883: LD_EXP 99
48887: PUSH
48888: LD_EXP 100
48892: PUSH
48893: LD_EXP 101
48897: PUSH
48898: LD_EXP 103
48902: PUSH
48903: LD_EXP 104
48907: PUSH
48908: LD_EXP 105
48912: PUSH
48913: LD_EXP 108
48917: PUSH
48918: LD_EXP 110
48922: PUSH
48923: LD_EXP 111
48927: PUSH
48928: LD_EXP 112
48932: PUSH
48933: LD_EXP 114
48937: PUSH
48938: LD_EXP 115
48942: PUSH
48943: LD_EXP 118
48947: PUSH
48948: LD_EXP 119
48952: PUSH
48953: LD_EXP 120
48957: PUSH
48958: LD_EXP 121
48962: PUSH
48963: LD_EXP 122
48967: PUSH
48968: LD_EXP 123
48972: PUSH
48973: LD_EXP 124
48977: PUSH
48978: LD_EXP 125
48982: PUSH
48983: LD_EXP 126
48987: PUSH
48988: LD_EXP 91
48992: PUSH
48993: LD_EXP 92
48997: PUSH
48998: LD_EXP 95
49002: PUSH
49003: LD_EXP 96
49007: PUSH
49008: LD_EXP 97
49012: PUSH
49013: LD_EXP 93
49017: PUSH
49018: LD_EXP 94
49022: PUSH
49023: LD_EXP 102
49027: PUSH
49028: LD_EXP 106
49032: PUSH
49033: LD_EXP 107
49037: PUSH
49038: LD_EXP 109
49042: PUSH
49043: LD_EXP 113
49047: PUSH
49048: LD_EXP 116
49052: PUSH
49053: LD_EXP 117
49057: PUSH
49058: LD_EXP 127
49062: PUSH
49063: LD_EXP 128
49067: PUSH
49068: LD_EXP 129
49072: PUSH
49073: LD_EXP 130
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: ST_TO_ADDR
// tmp :=  ;
49134: LD_ADDR_VAR 0 3
49138: PUSH
49139: LD_STRING 
49141: ST_TO_ADDR
// for i = 1 to normalCounter do
49142: LD_ADDR_VAR 0 8
49146: PUSH
49147: DOUBLE
49148: LD_INT 1
49150: DEC
49151: ST_TO_ADDR
49152: LD_EXP 75
49156: PUSH
49157: FOR_TO
49158: IFFALSE 49194
// begin if flags [ i ] then
49160: LD_VAR 0 4
49164: PUSH
49165: LD_VAR 0 8
49169: ARRAY
49170: IFFALSE 49192
// tmp := tmp & i & ; ;
49172: LD_ADDR_VAR 0 3
49176: PUSH
49177: LD_VAR 0 3
49181: PUSH
49182: LD_VAR 0 8
49186: STR
49187: PUSH
49188: LD_STRING ;
49190: STR
49191: ST_TO_ADDR
// end ;
49192: GO 49157
49194: POP
49195: POP
// for i = 1 to hardcoreCounter do
49196: LD_ADDR_VAR 0 8
49200: PUSH
49201: DOUBLE
49202: LD_INT 1
49204: DEC
49205: ST_TO_ADDR
49206: LD_EXP 76
49210: PUSH
49211: FOR_TO
49212: IFFALSE 49258
// begin if flags [ normalCounter + i ] then
49214: LD_VAR 0 4
49218: PUSH
49219: LD_EXP 75
49223: PUSH
49224: LD_VAR 0 8
49228: PLUS
49229: ARRAY
49230: IFFALSE 49256
// tmp := tmp & ( 100 + i ) & ; ;
49232: LD_ADDR_VAR 0 3
49236: PUSH
49237: LD_VAR 0 3
49241: PUSH
49242: LD_INT 100
49244: PUSH
49245: LD_VAR 0 8
49249: PLUS
49250: STR
49251: PUSH
49252: LD_STRING ;
49254: STR
49255: ST_TO_ADDR
// end ;
49256: GO 49211
49258: POP
49259: POP
// if tmp then
49260: LD_VAR 0 3
49264: IFFALSE 49276
// active := tmp ;
49266: LD_ADDR_VAR 0 7
49270: PUSH
49271: LD_VAR 0 3
49275: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49276: LD_STRING getStreamItemsFromMission("
49278: PUSH
49279: LD_VAR 0 5
49283: STR
49284: PUSH
49285: LD_STRING ","
49287: STR
49288: PUSH
49289: LD_VAR 0 6
49293: STR
49294: PUSH
49295: LD_STRING ","
49297: STR
49298: PUSH
49299: LD_VAR 0 7
49303: STR
49304: PUSH
49305: LD_STRING ")
49307: STR
49308: PPUSH
49309: CALL_OW 559
// end else
49313: GO 49322
// ToLua ( getStreamItemsFromMission("","","") ) ;
49315: LD_STRING getStreamItemsFromMission("","","")
49317: PPUSH
49318: CALL_OW 559
// end ;
49322: LD_VAR 0 2
49326: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49327: LD_EXP 74
49331: PUSH
49332: LD_EXP 79
49336: AND
49337: IFFALSE 49461
49339: GO 49341
49341: DISABLE
49342: LD_INT 0
49344: PPUSH
49345: PPUSH
// begin enable ;
49346: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49347: LD_ADDR_VAR 0 2
49351: PUSH
49352: LD_INT 22
49354: PUSH
49355: LD_OWVAR 2
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: PUSH
49364: LD_INT 2
49366: PUSH
49367: LD_INT 34
49369: PUSH
49370: LD_INT 7
49372: PUSH
49373: EMPTY
49374: LIST
49375: LIST
49376: PUSH
49377: LD_INT 34
49379: PUSH
49380: LD_INT 45
49382: PUSH
49383: EMPTY
49384: LIST
49385: LIST
49386: PUSH
49387: LD_INT 34
49389: PUSH
49390: LD_INT 28
49392: PUSH
49393: EMPTY
49394: LIST
49395: LIST
49396: PUSH
49397: LD_INT 34
49399: PUSH
49400: LD_INT 47
49402: PUSH
49403: EMPTY
49404: LIST
49405: LIST
49406: PUSH
49407: EMPTY
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: LIST
49413: PUSH
49414: EMPTY
49415: LIST
49416: LIST
49417: PPUSH
49418: CALL_OW 69
49422: ST_TO_ADDR
// if not tmp then
49423: LD_VAR 0 2
49427: NOT
49428: IFFALSE 49432
// exit ;
49430: GO 49461
// for i in tmp do
49432: LD_ADDR_VAR 0 1
49436: PUSH
49437: LD_VAR 0 2
49441: PUSH
49442: FOR_IN
49443: IFFALSE 49459
// begin SetLives ( i , 0 ) ;
49445: LD_VAR 0 1
49449: PPUSH
49450: LD_INT 0
49452: PPUSH
49453: CALL_OW 234
// end ;
49457: GO 49442
49459: POP
49460: POP
// end ;
49461: PPOPN 2
49463: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49464: LD_EXP 74
49468: PUSH
49469: LD_EXP 80
49473: AND
49474: IFFALSE 49558
49476: GO 49478
49478: DISABLE
49479: LD_INT 0
49481: PPUSH
49482: PPUSH
// begin enable ;
49483: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49484: LD_ADDR_VAR 0 2
49488: PUSH
49489: LD_INT 22
49491: PUSH
49492: LD_OWVAR 2
49496: PUSH
49497: EMPTY
49498: LIST
49499: LIST
49500: PUSH
49501: LD_INT 32
49503: PUSH
49504: LD_INT 3
49506: PUSH
49507: EMPTY
49508: LIST
49509: LIST
49510: PUSH
49511: EMPTY
49512: LIST
49513: LIST
49514: PPUSH
49515: CALL_OW 69
49519: ST_TO_ADDR
// if not tmp then
49520: LD_VAR 0 2
49524: NOT
49525: IFFALSE 49529
// exit ;
49527: GO 49558
// for i in tmp do
49529: LD_ADDR_VAR 0 1
49533: PUSH
49534: LD_VAR 0 2
49538: PUSH
49539: FOR_IN
49540: IFFALSE 49556
// begin SetLives ( i , 0 ) ;
49542: LD_VAR 0 1
49546: PPUSH
49547: LD_INT 0
49549: PPUSH
49550: CALL_OW 234
// end ;
49554: GO 49539
49556: POP
49557: POP
// end ;
49558: PPOPN 2
49560: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49561: LD_EXP 74
49565: PUSH
49566: LD_EXP 77
49570: AND
49571: IFFALSE 49664
49573: GO 49575
49575: DISABLE
49576: LD_INT 0
49578: PPUSH
// begin enable ;
49579: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49580: LD_ADDR_VAR 0 1
49584: PUSH
49585: LD_INT 22
49587: PUSH
49588: LD_OWVAR 2
49592: PUSH
49593: EMPTY
49594: LIST
49595: LIST
49596: PUSH
49597: LD_INT 2
49599: PUSH
49600: LD_INT 25
49602: PUSH
49603: LD_INT 5
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: PUSH
49610: LD_INT 25
49612: PUSH
49613: LD_INT 9
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PUSH
49620: LD_INT 25
49622: PUSH
49623: LD_INT 8
49625: PUSH
49626: EMPTY
49627: LIST
49628: LIST
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: PUSH
49636: EMPTY
49637: LIST
49638: LIST
49639: PPUSH
49640: CALL_OW 69
49644: PUSH
49645: FOR_IN
49646: IFFALSE 49662
// begin SetClass ( i , 1 ) ;
49648: LD_VAR 0 1
49652: PPUSH
49653: LD_INT 1
49655: PPUSH
49656: CALL_OW 336
// end ;
49660: GO 49645
49662: POP
49663: POP
// end ;
49664: PPOPN 1
49666: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49667: LD_EXP 74
49671: PUSH
49672: LD_EXP 78
49676: AND
49677: PUSH
49678: LD_OWVAR 65
49682: PUSH
49683: LD_INT 7
49685: LESS
49686: AND
49687: IFFALSE 49701
49689: GO 49691
49691: DISABLE
// begin enable ;
49692: ENABLE
// game_speed := 7 ;
49693: LD_ADDR_OWVAR 65
49697: PUSH
49698: LD_INT 7
49700: ST_TO_ADDR
// end ;
49701: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49702: LD_EXP 74
49706: PUSH
49707: LD_EXP 81
49711: AND
49712: IFFALSE 49914
49714: GO 49716
49716: DISABLE
49717: LD_INT 0
49719: PPUSH
49720: PPUSH
49721: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49722: LD_ADDR_VAR 0 3
49726: PUSH
49727: LD_INT 81
49729: PUSH
49730: LD_OWVAR 2
49734: PUSH
49735: EMPTY
49736: LIST
49737: LIST
49738: PUSH
49739: LD_INT 21
49741: PUSH
49742: LD_INT 1
49744: PUSH
49745: EMPTY
49746: LIST
49747: LIST
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PPUSH
49753: CALL_OW 69
49757: ST_TO_ADDR
// if not tmp then
49758: LD_VAR 0 3
49762: NOT
49763: IFFALSE 49767
// exit ;
49765: GO 49914
// if tmp > 5 then
49767: LD_VAR 0 3
49771: PUSH
49772: LD_INT 5
49774: GREATER
49775: IFFALSE 49787
// k := 5 else
49777: LD_ADDR_VAR 0 2
49781: PUSH
49782: LD_INT 5
49784: ST_TO_ADDR
49785: GO 49797
// k := tmp ;
49787: LD_ADDR_VAR 0 2
49791: PUSH
49792: LD_VAR 0 3
49796: ST_TO_ADDR
// for i := 1 to k do
49797: LD_ADDR_VAR 0 1
49801: PUSH
49802: DOUBLE
49803: LD_INT 1
49805: DEC
49806: ST_TO_ADDR
49807: LD_VAR 0 2
49811: PUSH
49812: FOR_TO
49813: IFFALSE 49912
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49815: LD_VAR 0 3
49819: PUSH
49820: LD_VAR 0 1
49824: ARRAY
49825: PPUSH
49826: LD_VAR 0 1
49830: PUSH
49831: LD_INT 4
49833: MOD
49834: PUSH
49835: LD_INT 1
49837: PLUS
49838: PPUSH
49839: CALL_OW 259
49843: PUSH
49844: LD_INT 10
49846: LESS
49847: IFFALSE 49910
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49849: LD_VAR 0 3
49853: PUSH
49854: LD_VAR 0 1
49858: ARRAY
49859: PPUSH
49860: LD_VAR 0 1
49864: PUSH
49865: LD_INT 4
49867: MOD
49868: PUSH
49869: LD_INT 1
49871: PLUS
49872: PPUSH
49873: LD_VAR 0 3
49877: PUSH
49878: LD_VAR 0 1
49882: ARRAY
49883: PPUSH
49884: LD_VAR 0 1
49888: PUSH
49889: LD_INT 4
49891: MOD
49892: PUSH
49893: LD_INT 1
49895: PLUS
49896: PPUSH
49897: CALL_OW 259
49901: PUSH
49902: LD_INT 1
49904: PLUS
49905: PPUSH
49906: CALL_OW 237
49910: GO 49812
49912: POP
49913: POP
// end ;
49914: PPOPN 3
49916: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49917: LD_EXP 74
49921: PUSH
49922: LD_EXP 82
49926: AND
49927: IFFALSE 49947
49929: GO 49931
49931: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49932: LD_INT 4
49934: PPUSH
49935: LD_OWVAR 2
49939: PPUSH
49940: LD_INT 0
49942: PPUSH
49943: CALL_OW 324
49947: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49948: LD_EXP 74
49952: PUSH
49953: LD_EXP 111
49957: AND
49958: IFFALSE 49978
49960: GO 49962
49962: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49963: LD_INT 19
49965: PPUSH
49966: LD_OWVAR 2
49970: PPUSH
49971: LD_INT 0
49973: PPUSH
49974: CALL_OW 324
49978: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49979: LD_EXP 74
49983: PUSH
49984: LD_EXP 83
49988: AND
49989: IFFALSE 50091
49991: GO 49993
49993: DISABLE
49994: LD_INT 0
49996: PPUSH
49997: PPUSH
// begin enable ;
49998: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49999: LD_ADDR_VAR 0 2
50003: PUSH
50004: LD_INT 22
50006: PUSH
50007: LD_OWVAR 2
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: PUSH
50016: LD_INT 2
50018: PUSH
50019: LD_INT 34
50021: PUSH
50022: LD_INT 11
50024: PUSH
50025: EMPTY
50026: LIST
50027: LIST
50028: PUSH
50029: LD_INT 34
50031: PUSH
50032: LD_INT 30
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: LIST
50043: PUSH
50044: EMPTY
50045: LIST
50046: LIST
50047: PPUSH
50048: CALL_OW 69
50052: ST_TO_ADDR
// if not tmp then
50053: LD_VAR 0 2
50057: NOT
50058: IFFALSE 50062
// exit ;
50060: GO 50091
// for i in tmp do
50062: LD_ADDR_VAR 0 1
50066: PUSH
50067: LD_VAR 0 2
50071: PUSH
50072: FOR_IN
50073: IFFALSE 50089
// begin SetLives ( i , 0 ) ;
50075: LD_VAR 0 1
50079: PPUSH
50080: LD_INT 0
50082: PPUSH
50083: CALL_OW 234
// end ;
50087: GO 50072
50089: POP
50090: POP
// end ;
50091: PPOPN 2
50093: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50094: LD_EXP 74
50098: PUSH
50099: LD_EXP 84
50103: AND
50104: IFFALSE 50124
50106: GO 50108
50108: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50109: LD_INT 32
50111: PPUSH
50112: LD_OWVAR 2
50116: PPUSH
50117: LD_INT 0
50119: PPUSH
50120: CALL_OW 324
50124: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50125: LD_EXP 74
50129: PUSH
50130: LD_EXP 85
50134: AND
50135: IFFALSE 50316
50137: GO 50139
50139: DISABLE
50140: LD_INT 0
50142: PPUSH
50143: PPUSH
50144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50145: LD_ADDR_VAR 0 2
50149: PUSH
50150: LD_INT 22
50152: PUSH
50153: LD_OWVAR 2
50157: PUSH
50158: EMPTY
50159: LIST
50160: LIST
50161: PUSH
50162: LD_INT 33
50164: PUSH
50165: LD_INT 3
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PUSH
50172: EMPTY
50173: LIST
50174: LIST
50175: PPUSH
50176: CALL_OW 69
50180: ST_TO_ADDR
// if not tmp then
50181: LD_VAR 0 2
50185: NOT
50186: IFFALSE 50190
// exit ;
50188: GO 50316
// side := 0 ;
50190: LD_ADDR_VAR 0 3
50194: PUSH
50195: LD_INT 0
50197: ST_TO_ADDR
// for i := 1 to 8 do
50198: LD_ADDR_VAR 0 1
50202: PUSH
50203: DOUBLE
50204: LD_INT 1
50206: DEC
50207: ST_TO_ADDR
50208: LD_INT 8
50210: PUSH
50211: FOR_TO
50212: IFFALSE 50260
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50214: LD_OWVAR 2
50218: PUSH
50219: LD_VAR 0 1
50223: NONEQUAL
50224: PUSH
50225: LD_OWVAR 2
50229: PPUSH
50230: LD_VAR 0 1
50234: PPUSH
50235: CALL_OW 81
50239: PUSH
50240: LD_INT 2
50242: EQUAL
50243: AND
50244: IFFALSE 50258
// begin side := i ;
50246: LD_ADDR_VAR 0 3
50250: PUSH
50251: LD_VAR 0 1
50255: ST_TO_ADDR
// break ;
50256: GO 50260
// end ;
50258: GO 50211
50260: POP
50261: POP
// if not side then
50262: LD_VAR 0 3
50266: NOT
50267: IFFALSE 50271
// exit ;
50269: GO 50316
// for i := 1 to tmp do
50271: LD_ADDR_VAR 0 1
50275: PUSH
50276: DOUBLE
50277: LD_INT 1
50279: DEC
50280: ST_TO_ADDR
50281: LD_VAR 0 2
50285: PUSH
50286: FOR_TO
50287: IFFALSE 50314
// if Prob ( 60 ) then
50289: LD_INT 60
50291: PPUSH
50292: CALL_OW 13
50296: IFFALSE 50312
// SetSide ( i , side ) ;
50298: LD_VAR 0 1
50302: PPUSH
50303: LD_VAR 0 3
50307: PPUSH
50308: CALL_OW 235
50312: GO 50286
50314: POP
50315: POP
// end ;
50316: PPOPN 3
50318: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50319: LD_EXP 74
50323: PUSH
50324: LD_EXP 87
50328: AND
50329: IFFALSE 50448
50331: GO 50333
50333: DISABLE
50334: LD_INT 0
50336: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50337: LD_ADDR_VAR 0 1
50341: PUSH
50342: LD_INT 22
50344: PUSH
50345: LD_OWVAR 2
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: PUSH
50354: LD_INT 21
50356: PUSH
50357: LD_INT 1
50359: PUSH
50360: EMPTY
50361: LIST
50362: LIST
50363: PUSH
50364: LD_INT 3
50366: PUSH
50367: LD_INT 23
50369: PUSH
50370: LD_INT 0
50372: PUSH
50373: EMPTY
50374: LIST
50375: LIST
50376: PUSH
50377: EMPTY
50378: LIST
50379: LIST
50380: PUSH
50381: EMPTY
50382: LIST
50383: LIST
50384: LIST
50385: PPUSH
50386: CALL_OW 69
50390: PUSH
50391: FOR_IN
50392: IFFALSE 50446
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50394: LD_VAR 0 1
50398: PPUSH
50399: CALL_OW 257
50403: PUSH
50404: LD_INT 1
50406: PUSH
50407: LD_INT 2
50409: PUSH
50410: LD_INT 3
50412: PUSH
50413: LD_INT 4
50415: PUSH
50416: EMPTY
50417: LIST
50418: LIST
50419: LIST
50420: LIST
50421: IN
50422: IFFALSE 50444
// SetClass ( un , rand ( 1 , 4 ) ) ;
50424: LD_VAR 0 1
50428: PPUSH
50429: LD_INT 1
50431: PPUSH
50432: LD_INT 4
50434: PPUSH
50435: CALL_OW 12
50439: PPUSH
50440: CALL_OW 336
50444: GO 50391
50446: POP
50447: POP
// end ;
50448: PPOPN 1
50450: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50451: LD_EXP 74
50455: PUSH
50456: LD_EXP 86
50460: AND
50461: IFFALSE 50540
50463: GO 50465
50465: DISABLE
50466: LD_INT 0
50468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50469: LD_ADDR_VAR 0 1
50473: PUSH
50474: LD_INT 22
50476: PUSH
50477: LD_OWVAR 2
50481: PUSH
50482: EMPTY
50483: LIST
50484: LIST
50485: PUSH
50486: LD_INT 21
50488: PUSH
50489: LD_INT 3
50491: PUSH
50492: EMPTY
50493: LIST
50494: LIST
50495: PUSH
50496: EMPTY
50497: LIST
50498: LIST
50499: PPUSH
50500: CALL_OW 69
50504: ST_TO_ADDR
// if not tmp then
50505: LD_VAR 0 1
50509: NOT
50510: IFFALSE 50514
// exit ;
50512: GO 50540
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50514: LD_VAR 0 1
50518: PUSH
50519: LD_INT 1
50521: PPUSH
50522: LD_VAR 0 1
50526: PPUSH
50527: CALL_OW 12
50531: ARRAY
50532: PPUSH
50533: LD_INT 100
50535: PPUSH
50536: CALL_OW 234
// end ;
50540: PPOPN 1
50542: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50543: LD_EXP 74
50547: PUSH
50548: LD_EXP 88
50552: AND
50553: IFFALSE 50651
50555: GO 50557
50557: DISABLE
50558: LD_INT 0
50560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50561: LD_ADDR_VAR 0 1
50565: PUSH
50566: LD_INT 22
50568: PUSH
50569: LD_OWVAR 2
50573: PUSH
50574: EMPTY
50575: LIST
50576: LIST
50577: PUSH
50578: LD_INT 21
50580: PUSH
50581: LD_INT 1
50583: PUSH
50584: EMPTY
50585: LIST
50586: LIST
50587: PUSH
50588: EMPTY
50589: LIST
50590: LIST
50591: PPUSH
50592: CALL_OW 69
50596: ST_TO_ADDR
// if not tmp then
50597: LD_VAR 0 1
50601: NOT
50602: IFFALSE 50606
// exit ;
50604: GO 50651
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50606: LD_VAR 0 1
50610: PUSH
50611: LD_INT 1
50613: PPUSH
50614: LD_VAR 0 1
50618: PPUSH
50619: CALL_OW 12
50623: ARRAY
50624: PPUSH
50625: LD_INT 1
50627: PPUSH
50628: LD_INT 4
50630: PPUSH
50631: CALL_OW 12
50635: PPUSH
50636: LD_INT 3000
50638: PPUSH
50639: LD_INT 9000
50641: PPUSH
50642: CALL_OW 12
50646: PPUSH
50647: CALL_OW 492
// end ;
50651: PPOPN 1
50653: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50654: LD_EXP 74
50658: PUSH
50659: LD_EXP 89
50663: AND
50664: IFFALSE 50684
50666: GO 50668
50668: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50669: LD_INT 1
50671: PPUSH
50672: LD_OWVAR 2
50676: PPUSH
50677: LD_INT 0
50679: PPUSH
50680: CALL_OW 324
50684: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50685: LD_EXP 74
50689: PUSH
50690: LD_EXP 90
50694: AND
50695: IFFALSE 50778
50697: GO 50699
50699: DISABLE
50700: LD_INT 0
50702: PPUSH
50703: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50704: LD_ADDR_VAR 0 2
50708: PUSH
50709: LD_INT 22
50711: PUSH
50712: LD_OWVAR 2
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: LD_INT 21
50723: PUSH
50724: LD_INT 3
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: PPUSH
50735: CALL_OW 69
50739: ST_TO_ADDR
// if not tmp then
50740: LD_VAR 0 2
50744: NOT
50745: IFFALSE 50749
// exit ;
50747: GO 50778
// for i in tmp do
50749: LD_ADDR_VAR 0 1
50753: PUSH
50754: LD_VAR 0 2
50758: PUSH
50759: FOR_IN
50760: IFFALSE 50776
// SetBLevel ( i , 10 ) ;
50762: LD_VAR 0 1
50766: PPUSH
50767: LD_INT 10
50769: PPUSH
50770: CALL_OW 241
50774: GO 50759
50776: POP
50777: POP
// end ;
50778: PPOPN 2
50780: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50781: LD_EXP 74
50785: PUSH
50786: LD_EXP 91
50790: AND
50791: IFFALSE 50902
50793: GO 50795
50795: DISABLE
50796: LD_INT 0
50798: PPUSH
50799: PPUSH
50800: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50801: LD_ADDR_VAR 0 3
50805: PUSH
50806: LD_INT 22
50808: PUSH
50809: LD_OWVAR 2
50813: PUSH
50814: EMPTY
50815: LIST
50816: LIST
50817: PUSH
50818: LD_INT 25
50820: PUSH
50821: LD_INT 1
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PUSH
50828: EMPTY
50829: LIST
50830: LIST
50831: PPUSH
50832: CALL_OW 69
50836: ST_TO_ADDR
// if not tmp then
50837: LD_VAR 0 3
50841: NOT
50842: IFFALSE 50846
// exit ;
50844: GO 50902
// un := tmp [ rand ( 1 , tmp ) ] ;
50846: LD_ADDR_VAR 0 2
50850: PUSH
50851: LD_VAR 0 3
50855: PUSH
50856: LD_INT 1
50858: PPUSH
50859: LD_VAR 0 3
50863: PPUSH
50864: CALL_OW 12
50868: ARRAY
50869: ST_TO_ADDR
// if Crawls ( un ) then
50870: LD_VAR 0 2
50874: PPUSH
50875: CALL_OW 318
50879: IFFALSE 50890
// ComWalk ( un ) ;
50881: LD_VAR 0 2
50885: PPUSH
50886: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50890: LD_VAR 0 2
50894: PPUSH
50895: LD_INT 5
50897: PPUSH
50898: CALL_OW 336
// end ;
50902: PPOPN 3
50904: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50905: LD_EXP 74
50909: PUSH
50910: LD_EXP 92
50914: AND
50915: PUSH
50916: LD_OWVAR 67
50920: PUSH
50921: LD_INT 4
50923: LESS
50924: AND
50925: IFFALSE 50944
50927: GO 50929
50929: DISABLE
// begin Difficulty := Difficulty + 1 ;
50930: LD_ADDR_OWVAR 67
50934: PUSH
50935: LD_OWVAR 67
50939: PUSH
50940: LD_INT 1
50942: PLUS
50943: ST_TO_ADDR
// end ;
50944: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50945: LD_EXP 74
50949: PUSH
50950: LD_EXP 93
50954: AND
50955: IFFALSE 51058
50957: GO 50959
50959: DISABLE
50960: LD_INT 0
50962: PPUSH
// begin for i := 1 to 5 do
50963: LD_ADDR_VAR 0 1
50967: PUSH
50968: DOUBLE
50969: LD_INT 1
50971: DEC
50972: ST_TO_ADDR
50973: LD_INT 5
50975: PUSH
50976: FOR_TO
50977: IFFALSE 51056
// begin uc_nation := nation_nature ;
50979: LD_ADDR_OWVAR 21
50983: PUSH
50984: LD_INT 0
50986: ST_TO_ADDR
// uc_side := 0 ;
50987: LD_ADDR_OWVAR 20
50991: PUSH
50992: LD_INT 0
50994: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50995: LD_ADDR_OWVAR 29
50999: PUSH
51000: LD_INT 12
51002: PUSH
51003: LD_INT 12
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: ST_TO_ADDR
// hc_agressivity := 20 ;
51010: LD_ADDR_OWVAR 35
51014: PUSH
51015: LD_INT 20
51017: ST_TO_ADDR
// hc_class := class_tiger ;
51018: LD_ADDR_OWVAR 28
51022: PUSH
51023: LD_INT 14
51025: ST_TO_ADDR
// hc_gallery :=  ;
51026: LD_ADDR_OWVAR 33
51030: PUSH
51031: LD_STRING 
51033: ST_TO_ADDR
// hc_name :=  ;
51034: LD_ADDR_OWVAR 26
51038: PUSH
51039: LD_STRING 
51041: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51042: CALL_OW 44
51046: PPUSH
51047: LD_INT 0
51049: PPUSH
51050: CALL_OW 51
// end ;
51054: GO 50976
51056: POP
51057: POP
// end ;
51058: PPOPN 1
51060: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51061: LD_EXP 74
51065: PUSH
51066: LD_EXP 94
51070: AND
51071: IFFALSE 51080
51073: GO 51075
51075: DISABLE
// StreamSibBomb ;
51076: CALL 51081 0 0
51080: END
// export function StreamSibBomb ; var i , x , y ; begin
51081: LD_INT 0
51083: PPUSH
51084: PPUSH
51085: PPUSH
51086: PPUSH
// result := false ;
51087: LD_ADDR_VAR 0 1
51091: PUSH
51092: LD_INT 0
51094: ST_TO_ADDR
// for i := 1 to 16 do
51095: LD_ADDR_VAR 0 2
51099: PUSH
51100: DOUBLE
51101: LD_INT 1
51103: DEC
51104: ST_TO_ADDR
51105: LD_INT 16
51107: PUSH
51108: FOR_TO
51109: IFFALSE 51308
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51111: LD_ADDR_VAR 0 3
51115: PUSH
51116: LD_INT 10
51118: PUSH
51119: LD_INT 20
51121: PUSH
51122: LD_INT 30
51124: PUSH
51125: LD_INT 40
51127: PUSH
51128: LD_INT 50
51130: PUSH
51131: LD_INT 60
51133: PUSH
51134: LD_INT 70
51136: PUSH
51137: LD_INT 80
51139: PUSH
51140: LD_INT 90
51142: PUSH
51143: LD_INT 100
51145: PUSH
51146: LD_INT 110
51148: PUSH
51149: LD_INT 120
51151: PUSH
51152: LD_INT 130
51154: PUSH
51155: LD_INT 140
51157: PUSH
51158: LD_INT 150
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: PUSH
51178: LD_INT 1
51180: PPUSH
51181: LD_INT 15
51183: PPUSH
51184: CALL_OW 12
51188: ARRAY
51189: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51190: LD_ADDR_VAR 0 4
51194: PUSH
51195: LD_INT 10
51197: PUSH
51198: LD_INT 20
51200: PUSH
51201: LD_INT 30
51203: PUSH
51204: LD_INT 40
51206: PUSH
51207: LD_INT 50
51209: PUSH
51210: LD_INT 60
51212: PUSH
51213: LD_INT 70
51215: PUSH
51216: LD_INT 80
51218: PUSH
51219: LD_INT 90
51221: PUSH
51222: LD_INT 100
51224: PUSH
51225: LD_INT 110
51227: PUSH
51228: LD_INT 120
51230: PUSH
51231: LD_INT 130
51233: PUSH
51234: LD_INT 140
51236: PUSH
51237: LD_INT 150
51239: PUSH
51240: EMPTY
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: LIST
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: PUSH
51257: LD_INT 1
51259: PPUSH
51260: LD_INT 15
51262: PPUSH
51263: CALL_OW 12
51267: ARRAY
51268: ST_TO_ADDR
// if ValidHex ( x , y ) then
51269: LD_VAR 0 3
51273: PPUSH
51274: LD_VAR 0 4
51278: PPUSH
51279: CALL_OW 488
51283: IFFALSE 51306
// begin result := [ x , y ] ;
51285: LD_ADDR_VAR 0 1
51289: PUSH
51290: LD_VAR 0 3
51294: PUSH
51295: LD_VAR 0 4
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: ST_TO_ADDR
// break ;
51304: GO 51308
// end ; end ;
51306: GO 51108
51308: POP
51309: POP
// if result then
51310: LD_VAR 0 1
51314: IFFALSE 51374
// begin ToLua ( playSibBomb() ) ;
51316: LD_STRING playSibBomb()
51318: PPUSH
51319: CALL_OW 559
// wait ( 0 0$14 ) ;
51323: LD_INT 490
51325: PPUSH
51326: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51330: LD_VAR 0 1
51334: PUSH
51335: LD_INT 1
51337: ARRAY
51338: PPUSH
51339: LD_VAR 0 1
51343: PUSH
51344: LD_INT 2
51346: ARRAY
51347: PPUSH
51348: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51352: LD_VAR 0 1
51356: PUSH
51357: LD_INT 1
51359: ARRAY
51360: PPUSH
51361: LD_VAR 0 1
51365: PUSH
51366: LD_INT 2
51368: ARRAY
51369: PPUSH
51370: CALL_OW 429
// end ; end ;
51374: LD_VAR 0 1
51378: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51379: LD_EXP 74
51383: PUSH
51384: LD_EXP 96
51388: AND
51389: IFFALSE 51401
51391: GO 51393
51393: DISABLE
// YouLost (  ) ;
51394: LD_STRING 
51396: PPUSH
51397: CALL_OW 104
51401: END
// every 0 0$1 trigger StreamModeActive and sFog do
51402: LD_EXP 74
51406: PUSH
51407: LD_EXP 95
51411: AND
51412: IFFALSE 51426
51414: GO 51416
51416: DISABLE
// FogOff ( your_side ) ;
51417: LD_OWVAR 2
51421: PPUSH
51422: CALL_OW 344
51426: END
// every 0 0$1 trigger StreamModeActive and sSun do
51427: LD_EXP 74
51431: PUSH
51432: LD_EXP 97
51436: AND
51437: IFFALSE 51465
51439: GO 51441
51441: DISABLE
// begin solar_recharge_percent := 0 ;
51442: LD_ADDR_OWVAR 79
51446: PUSH
51447: LD_INT 0
51449: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51450: LD_INT 10500
51452: PPUSH
51453: CALL_OW 67
// solar_recharge_percent := 100 ;
51457: LD_ADDR_OWVAR 79
51461: PUSH
51462: LD_INT 100
51464: ST_TO_ADDR
// end ;
51465: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51466: LD_EXP 74
51470: PUSH
51471: LD_EXP 98
51475: AND
51476: IFFALSE 51715
51478: GO 51480
51480: DISABLE
51481: LD_INT 0
51483: PPUSH
51484: PPUSH
51485: PPUSH
// begin tmp := [ ] ;
51486: LD_ADDR_VAR 0 3
51490: PUSH
51491: EMPTY
51492: ST_TO_ADDR
// for i := 1 to 6 do
51493: LD_ADDR_VAR 0 1
51497: PUSH
51498: DOUBLE
51499: LD_INT 1
51501: DEC
51502: ST_TO_ADDR
51503: LD_INT 6
51505: PUSH
51506: FOR_TO
51507: IFFALSE 51612
// begin uc_nation := nation_nature ;
51509: LD_ADDR_OWVAR 21
51513: PUSH
51514: LD_INT 0
51516: ST_TO_ADDR
// uc_side := 0 ;
51517: LD_ADDR_OWVAR 20
51521: PUSH
51522: LD_INT 0
51524: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51525: LD_ADDR_OWVAR 29
51529: PUSH
51530: LD_INT 12
51532: PUSH
51533: LD_INT 12
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: ST_TO_ADDR
// hc_agressivity := 20 ;
51540: LD_ADDR_OWVAR 35
51544: PUSH
51545: LD_INT 20
51547: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51548: LD_ADDR_OWVAR 28
51552: PUSH
51553: LD_INT 17
51555: ST_TO_ADDR
// hc_gallery :=  ;
51556: LD_ADDR_OWVAR 33
51560: PUSH
51561: LD_STRING 
51563: ST_TO_ADDR
// hc_name :=  ;
51564: LD_ADDR_OWVAR 26
51568: PUSH
51569: LD_STRING 
51571: ST_TO_ADDR
// un := CreateHuman ;
51572: LD_ADDR_VAR 0 2
51576: PUSH
51577: CALL_OW 44
51581: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51582: LD_VAR 0 2
51586: PPUSH
51587: LD_INT 1
51589: PPUSH
51590: CALL_OW 51
// tmp := tmp ^ un ;
51594: LD_ADDR_VAR 0 3
51598: PUSH
51599: LD_VAR 0 3
51603: PUSH
51604: LD_VAR 0 2
51608: ADD
51609: ST_TO_ADDR
// end ;
51610: GO 51506
51612: POP
51613: POP
// repeat wait ( 0 0$1 ) ;
51614: LD_INT 35
51616: PPUSH
51617: CALL_OW 67
// for un in tmp do
51621: LD_ADDR_VAR 0 2
51625: PUSH
51626: LD_VAR 0 3
51630: PUSH
51631: FOR_IN
51632: IFFALSE 51706
// begin if IsDead ( un ) then
51634: LD_VAR 0 2
51638: PPUSH
51639: CALL_OW 301
51643: IFFALSE 51663
// begin tmp := tmp diff un ;
51645: LD_ADDR_VAR 0 3
51649: PUSH
51650: LD_VAR 0 3
51654: PUSH
51655: LD_VAR 0 2
51659: DIFF
51660: ST_TO_ADDR
// continue ;
51661: GO 51631
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51663: LD_VAR 0 2
51667: PPUSH
51668: LD_INT 3
51670: PUSH
51671: LD_INT 22
51673: PUSH
51674: LD_INT 0
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: PPUSH
51685: CALL_OW 69
51689: PPUSH
51690: LD_VAR 0 2
51694: PPUSH
51695: CALL_OW 74
51699: PPUSH
51700: CALL_OW 115
// end ;
51704: GO 51631
51706: POP
51707: POP
// until not tmp ;
51708: LD_VAR 0 3
51712: NOT
51713: IFFALSE 51614
// end ;
51715: PPOPN 3
51717: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51718: LD_EXP 74
51722: PUSH
51723: LD_EXP 99
51727: AND
51728: IFFALSE 51782
51730: GO 51732
51732: DISABLE
// begin ToLua ( displayTroll(); ) ;
51733: LD_STRING displayTroll();
51735: PPUSH
51736: CALL_OW 559
// wait ( 3 3$00 ) ;
51740: LD_INT 6300
51742: PPUSH
51743: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51747: LD_STRING hideTroll();
51749: PPUSH
51750: CALL_OW 559
// wait ( 1 1$00 ) ;
51754: LD_INT 2100
51756: PPUSH
51757: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51761: LD_STRING displayTroll();
51763: PPUSH
51764: CALL_OW 559
// wait ( 1 1$00 ) ;
51768: LD_INT 2100
51770: PPUSH
51771: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51775: LD_STRING hideTroll();
51777: PPUSH
51778: CALL_OW 559
// end ;
51782: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51783: LD_EXP 74
51787: PUSH
51788: LD_EXP 100
51792: AND
51793: IFFALSE 51856
51795: GO 51797
51797: DISABLE
51798: LD_INT 0
51800: PPUSH
// begin p := 0 ;
51801: LD_ADDR_VAR 0 1
51805: PUSH
51806: LD_INT 0
51808: ST_TO_ADDR
// repeat game_speed := 1 ;
51809: LD_ADDR_OWVAR 65
51813: PUSH
51814: LD_INT 1
51816: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51817: LD_INT 35
51819: PPUSH
51820: CALL_OW 67
// p := p + 1 ;
51824: LD_ADDR_VAR 0 1
51828: PUSH
51829: LD_VAR 0 1
51833: PUSH
51834: LD_INT 1
51836: PLUS
51837: ST_TO_ADDR
// until p >= 60 ;
51838: LD_VAR 0 1
51842: PUSH
51843: LD_INT 60
51845: GREATEREQUAL
51846: IFFALSE 51809
// game_speed := 4 ;
51848: LD_ADDR_OWVAR 65
51852: PUSH
51853: LD_INT 4
51855: ST_TO_ADDR
// end ;
51856: PPOPN 1
51858: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51859: LD_EXP 74
51863: PUSH
51864: LD_EXP 101
51868: AND
51869: IFFALSE 52015
51871: GO 51873
51873: DISABLE
51874: LD_INT 0
51876: PPUSH
51877: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51878: LD_ADDR_VAR 0 1
51882: PUSH
51883: LD_INT 22
51885: PUSH
51886: LD_OWVAR 2
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: PUSH
51895: LD_INT 2
51897: PUSH
51898: LD_INT 30
51900: PUSH
51901: LD_INT 0
51903: PUSH
51904: EMPTY
51905: LIST
51906: LIST
51907: PUSH
51908: LD_INT 30
51910: PUSH
51911: LD_INT 1
51913: PUSH
51914: EMPTY
51915: LIST
51916: LIST
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: LIST
51922: PUSH
51923: EMPTY
51924: LIST
51925: LIST
51926: PPUSH
51927: CALL_OW 69
51931: ST_TO_ADDR
// if not depot then
51932: LD_VAR 0 1
51936: NOT
51937: IFFALSE 51941
// exit ;
51939: GO 52015
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51941: LD_ADDR_VAR 0 2
51945: PUSH
51946: LD_VAR 0 1
51950: PUSH
51951: LD_INT 1
51953: PPUSH
51954: LD_VAR 0 1
51958: PPUSH
51959: CALL_OW 12
51963: ARRAY
51964: PPUSH
51965: CALL_OW 274
51969: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51970: LD_VAR 0 2
51974: PPUSH
51975: LD_INT 1
51977: PPUSH
51978: LD_INT 0
51980: PPUSH
51981: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51985: LD_VAR 0 2
51989: PPUSH
51990: LD_INT 2
51992: PPUSH
51993: LD_INT 0
51995: PPUSH
51996: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
52000: LD_VAR 0 2
52004: PPUSH
52005: LD_INT 3
52007: PPUSH
52008: LD_INT 0
52010: PPUSH
52011: CALL_OW 277
// end ;
52015: PPOPN 2
52017: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52018: LD_EXP 74
52022: PUSH
52023: LD_EXP 102
52027: AND
52028: IFFALSE 52125
52030: GO 52032
52032: DISABLE
52033: LD_INT 0
52035: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52036: LD_ADDR_VAR 0 1
52040: PUSH
52041: LD_INT 22
52043: PUSH
52044: LD_OWVAR 2
52048: PUSH
52049: EMPTY
52050: LIST
52051: LIST
52052: PUSH
52053: LD_INT 21
52055: PUSH
52056: LD_INT 1
52058: PUSH
52059: EMPTY
52060: LIST
52061: LIST
52062: PUSH
52063: LD_INT 3
52065: PUSH
52066: LD_INT 23
52068: PUSH
52069: LD_INT 0
52071: PUSH
52072: EMPTY
52073: LIST
52074: LIST
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PUSH
52080: EMPTY
52081: LIST
52082: LIST
52083: LIST
52084: PPUSH
52085: CALL_OW 69
52089: ST_TO_ADDR
// if not tmp then
52090: LD_VAR 0 1
52094: NOT
52095: IFFALSE 52099
// exit ;
52097: GO 52125
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52099: LD_VAR 0 1
52103: PUSH
52104: LD_INT 1
52106: PPUSH
52107: LD_VAR 0 1
52111: PPUSH
52112: CALL_OW 12
52116: ARRAY
52117: PPUSH
52118: LD_INT 200
52120: PPUSH
52121: CALL_OW 234
// end ;
52125: PPOPN 1
52127: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52128: LD_EXP 74
52132: PUSH
52133: LD_EXP 103
52137: AND
52138: IFFALSE 52217
52140: GO 52142
52142: DISABLE
52143: LD_INT 0
52145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52146: LD_ADDR_VAR 0 1
52150: PUSH
52151: LD_INT 22
52153: PUSH
52154: LD_OWVAR 2
52158: PUSH
52159: EMPTY
52160: LIST
52161: LIST
52162: PUSH
52163: LD_INT 21
52165: PUSH
52166: LD_INT 2
52168: PUSH
52169: EMPTY
52170: LIST
52171: LIST
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: PPUSH
52177: CALL_OW 69
52181: ST_TO_ADDR
// if not tmp then
52182: LD_VAR 0 1
52186: NOT
52187: IFFALSE 52191
// exit ;
52189: GO 52217
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52191: LD_VAR 0 1
52195: PUSH
52196: LD_INT 1
52198: PPUSH
52199: LD_VAR 0 1
52203: PPUSH
52204: CALL_OW 12
52208: ARRAY
52209: PPUSH
52210: LD_INT 60
52212: PPUSH
52213: CALL_OW 234
// end ;
52217: PPOPN 1
52219: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52220: LD_EXP 74
52224: PUSH
52225: LD_EXP 104
52229: AND
52230: IFFALSE 52329
52232: GO 52234
52234: DISABLE
52235: LD_INT 0
52237: PPUSH
52238: PPUSH
// begin enable ;
52239: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52240: LD_ADDR_VAR 0 1
52244: PUSH
52245: LD_INT 22
52247: PUSH
52248: LD_OWVAR 2
52252: PUSH
52253: EMPTY
52254: LIST
52255: LIST
52256: PUSH
52257: LD_INT 61
52259: PUSH
52260: EMPTY
52261: LIST
52262: PUSH
52263: LD_INT 33
52265: PUSH
52266: LD_INT 2
52268: PUSH
52269: EMPTY
52270: LIST
52271: LIST
52272: PUSH
52273: EMPTY
52274: LIST
52275: LIST
52276: LIST
52277: PPUSH
52278: CALL_OW 69
52282: ST_TO_ADDR
// if not tmp then
52283: LD_VAR 0 1
52287: NOT
52288: IFFALSE 52292
// exit ;
52290: GO 52329
// for i in tmp do
52292: LD_ADDR_VAR 0 2
52296: PUSH
52297: LD_VAR 0 1
52301: PUSH
52302: FOR_IN
52303: IFFALSE 52327
// if IsControledBy ( i ) then
52305: LD_VAR 0 2
52309: PPUSH
52310: CALL_OW 312
52314: IFFALSE 52325
// ComUnlink ( i ) ;
52316: LD_VAR 0 2
52320: PPUSH
52321: CALL_OW 136
52325: GO 52302
52327: POP
52328: POP
// end ;
52329: PPOPN 2
52331: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52332: LD_EXP 74
52336: PUSH
52337: LD_EXP 105
52341: AND
52342: IFFALSE 52482
52344: GO 52346
52346: DISABLE
52347: LD_INT 0
52349: PPUSH
52350: PPUSH
// begin ToLua ( displayPowell(); ) ;
52351: LD_STRING displayPowell();
52353: PPUSH
52354: CALL_OW 559
// uc_side := 0 ;
52358: LD_ADDR_OWVAR 20
52362: PUSH
52363: LD_INT 0
52365: ST_TO_ADDR
// uc_nation := 2 ;
52366: LD_ADDR_OWVAR 21
52370: PUSH
52371: LD_INT 2
52373: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52374: LD_ADDR_OWVAR 37
52378: PUSH
52379: LD_INT 14
52381: ST_TO_ADDR
// vc_engine := engine_siberite ;
52382: LD_ADDR_OWVAR 39
52386: PUSH
52387: LD_INT 3
52389: ST_TO_ADDR
// vc_control := control_apeman ;
52390: LD_ADDR_OWVAR 38
52394: PUSH
52395: LD_INT 5
52397: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52398: LD_ADDR_OWVAR 40
52402: PUSH
52403: LD_INT 29
52405: ST_TO_ADDR
// un := CreateVehicle ;
52406: LD_ADDR_VAR 0 2
52410: PUSH
52411: CALL_OW 45
52415: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52416: LD_VAR 0 2
52420: PPUSH
52421: LD_INT 1
52423: PPUSH
52424: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52428: LD_INT 35
52430: PPUSH
52431: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52435: LD_VAR 0 2
52439: PPUSH
52440: LD_INT 22
52442: PUSH
52443: LD_OWVAR 2
52447: PUSH
52448: EMPTY
52449: LIST
52450: LIST
52451: PPUSH
52452: CALL_OW 69
52456: PPUSH
52457: LD_VAR 0 2
52461: PPUSH
52462: CALL_OW 74
52466: PPUSH
52467: CALL_OW 115
// until IsDead ( un ) ;
52471: LD_VAR 0 2
52475: PPUSH
52476: CALL_OW 301
52480: IFFALSE 52428
// end ;
52482: PPOPN 2
52484: END
// every 0 0$1 trigger StreamModeActive and sStu do
52485: LD_EXP 74
52489: PUSH
52490: LD_EXP 113
52494: AND
52495: IFFALSE 52511
52497: GO 52499
52499: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52500: LD_STRING displayStucuk();
52502: PPUSH
52503: CALL_OW 559
// ResetFog ;
52507: CALL_OW 335
// end ;
52511: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52512: LD_EXP 74
52516: PUSH
52517: LD_EXP 106
52521: AND
52522: IFFALSE 52663
52524: GO 52526
52526: DISABLE
52527: LD_INT 0
52529: PPUSH
52530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52531: LD_ADDR_VAR 0 2
52535: PUSH
52536: LD_INT 22
52538: PUSH
52539: LD_OWVAR 2
52543: PUSH
52544: EMPTY
52545: LIST
52546: LIST
52547: PUSH
52548: LD_INT 21
52550: PUSH
52551: LD_INT 1
52553: PUSH
52554: EMPTY
52555: LIST
52556: LIST
52557: PUSH
52558: EMPTY
52559: LIST
52560: LIST
52561: PPUSH
52562: CALL_OW 69
52566: ST_TO_ADDR
// if not tmp then
52567: LD_VAR 0 2
52571: NOT
52572: IFFALSE 52576
// exit ;
52574: GO 52663
// un := tmp [ rand ( 1 , tmp ) ] ;
52576: LD_ADDR_VAR 0 1
52580: PUSH
52581: LD_VAR 0 2
52585: PUSH
52586: LD_INT 1
52588: PPUSH
52589: LD_VAR 0 2
52593: PPUSH
52594: CALL_OW 12
52598: ARRAY
52599: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52600: LD_VAR 0 1
52604: PPUSH
52605: LD_INT 0
52607: PPUSH
52608: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52612: LD_VAR 0 1
52616: PPUSH
52617: LD_OWVAR 3
52621: PUSH
52622: LD_VAR 0 1
52626: DIFF
52627: PPUSH
52628: LD_VAR 0 1
52632: PPUSH
52633: CALL_OW 74
52637: PPUSH
52638: CALL_OW 115
// wait ( 0 0$20 ) ;
52642: LD_INT 700
52644: PPUSH
52645: CALL_OW 67
// SetSide ( un , your_side ) ;
52649: LD_VAR 0 1
52653: PPUSH
52654: LD_OWVAR 2
52658: PPUSH
52659: CALL_OW 235
// end ;
52663: PPOPN 2
52665: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52666: LD_EXP 74
52670: PUSH
52671: LD_EXP 107
52675: AND
52676: IFFALSE 52782
52678: GO 52680
52680: DISABLE
52681: LD_INT 0
52683: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52684: LD_ADDR_VAR 0 1
52688: PUSH
52689: LD_INT 22
52691: PUSH
52692: LD_OWVAR 2
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: PUSH
52701: LD_INT 2
52703: PUSH
52704: LD_INT 30
52706: PUSH
52707: LD_INT 0
52709: PUSH
52710: EMPTY
52711: LIST
52712: LIST
52713: PUSH
52714: LD_INT 30
52716: PUSH
52717: LD_INT 1
52719: PUSH
52720: EMPTY
52721: LIST
52722: LIST
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: LIST
52728: PUSH
52729: EMPTY
52730: LIST
52731: LIST
52732: PPUSH
52733: CALL_OW 69
52737: ST_TO_ADDR
// if not depot then
52738: LD_VAR 0 1
52742: NOT
52743: IFFALSE 52747
// exit ;
52745: GO 52782
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52747: LD_VAR 0 1
52751: PUSH
52752: LD_INT 1
52754: ARRAY
52755: PPUSH
52756: CALL_OW 250
52760: PPUSH
52761: LD_VAR 0 1
52765: PUSH
52766: LD_INT 1
52768: ARRAY
52769: PPUSH
52770: CALL_OW 251
52774: PPUSH
52775: LD_INT 70
52777: PPUSH
52778: CALL_OW 495
// end ;
52782: PPOPN 1
52784: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52785: LD_EXP 74
52789: PUSH
52790: LD_EXP 108
52794: AND
52795: IFFALSE 53006
52797: GO 52799
52799: DISABLE
52800: LD_INT 0
52802: PPUSH
52803: PPUSH
52804: PPUSH
52805: PPUSH
52806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52807: LD_ADDR_VAR 0 5
52811: PUSH
52812: LD_INT 22
52814: PUSH
52815: LD_OWVAR 2
52819: PUSH
52820: EMPTY
52821: LIST
52822: LIST
52823: PUSH
52824: LD_INT 21
52826: PUSH
52827: LD_INT 1
52829: PUSH
52830: EMPTY
52831: LIST
52832: LIST
52833: PUSH
52834: EMPTY
52835: LIST
52836: LIST
52837: PPUSH
52838: CALL_OW 69
52842: ST_TO_ADDR
// if not tmp then
52843: LD_VAR 0 5
52847: NOT
52848: IFFALSE 52852
// exit ;
52850: GO 53006
// for i in tmp do
52852: LD_ADDR_VAR 0 1
52856: PUSH
52857: LD_VAR 0 5
52861: PUSH
52862: FOR_IN
52863: IFFALSE 53004
// begin d := rand ( 0 , 5 ) ;
52865: LD_ADDR_VAR 0 4
52869: PUSH
52870: LD_INT 0
52872: PPUSH
52873: LD_INT 5
52875: PPUSH
52876: CALL_OW 12
52880: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52881: LD_ADDR_VAR 0 2
52885: PUSH
52886: LD_VAR 0 1
52890: PPUSH
52891: CALL_OW 250
52895: PPUSH
52896: LD_VAR 0 4
52900: PPUSH
52901: LD_INT 3
52903: PPUSH
52904: LD_INT 12
52906: PPUSH
52907: CALL_OW 12
52911: PPUSH
52912: CALL_OW 272
52916: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52917: LD_ADDR_VAR 0 3
52921: PUSH
52922: LD_VAR 0 1
52926: PPUSH
52927: CALL_OW 251
52931: PPUSH
52932: LD_VAR 0 4
52936: PPUSH
52937: LD_INT 3
52939: PPUSH
52940: LD_INT 12
52942: PPUSH
52943: CALL_OW 12
52947: PPUSH
52948: CALL_OW 273
52952: ST_TO_ADDR
// if ValidHex ( x , y ) then
52953: LD_VAR 0 2
52957: PPUSH
52958: LD_VAR 0 3
52962: PPUSH
52963: CALL_OW 488
52967: IFFALSE 53002
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52969: LD_VAR 0 1
52973: PPUSH
52974: LD_VAR 0 2
52978: PPUSH
52979: LD_VAR 0 3
52983: PPUSH
52984: LD_INT 3
52986: PPUSH
52987: LD_INT 6
52989: PPUSH
52990: CALL_OW 12
52994: PPUSH
52995: LD_INT 1
52997: PPUSH
52998: CALL_OW 483
// end ;
53002: GO 52862
53004: POP
53005: POP
// end ;
53006: PPOPN 5
53008: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53009: LD_EXP 74
53013: PUSH
53014: LD_EXP 109
53018: AND
53019: IFFALSE 53113
53021: GO 53023
53023: DISABLE
53024: LD_INT 0
53026: PPUSH
53027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53028: LD_ADDR_VAR 0 2
53032: PUSH
53033: LD_INT 22
53035: PUSH
53036: LD_OWVAR 2
53040: PUSH
53041: EMPTY
53042: LIST
53043: LIST
53044: PUSH
53045: LD_INT 32
53047: PUSH
53048: LD_INT 1
53050: PUSH
53051: EMPTY
53052: LIST
53053: LIST
53054: PUSH
53055: LD_INT 21
53057: PUSH
53058: LD_INT 2
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: LIST
53069: PPUSH
53070: CALL_OW 69
53074: ST_TO_ADDR
// if not tmp then
53075: LD_VAR 0 2
53079: NOT
53080: IFFALSE 53084
// exit ;
53082: GO 53113
// for i in tmp do
53084: LD_ADDR_VAR 0 1
53088: PUSH
53089: LD_VAR 0 2
53093: PUSH
53094: FOR_IN
53095: IFFALSE 53111
// SetFuel ( i , 0 ) ;
53097: LD_VAR 0 1
53101: PPUSH
53102: LD_INT 0
53104: PPUSH
53105: CALL_OW 240
53109: GO 53094
53111: POP
53112: POP
// end ;
53113: PPOPN 2
53115: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53116: LD_EXP 74
53120: PUSH
53121: LD_EXP 110
53125: AND
53126: IFFALSE 53192
53128: GO 53130
53130: DISABLE
53131: LD_INT 0
53133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53134: LD_ADDR_VAR 0 1
53138: PUSH
53139: LD_INT 22
53141: PUSH
53142: LD_OWVAR 2
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: LD_INT 30
53153: PUSH
53154: LD_INT 29
53156: PUSH
53157: EMPTY
53158: LIST
53159: LIST
53160: PUSH
53161: EMPTY
53162: LIST
53163: LIST
53164: PPUSH
53165: CALL_OW 69
53169: ST_TO_ADDR
// if not tmp then
53170: LD_VAR 0 1
53174: NOT
53175: IFFALSE 53179
// exit ;
53177: GO 53192
// DestroyUnit ( tmp [ 1 ] ) ;
53179: LD_VAR 0 1
53183: PUSH
53184: LD_INT 1
53186: ARRAY
53187: PPUSH
53188: CALL_OW 65
// end ;
53192: PPOPN 1
53194: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53195: LD_EXP 74
53199: PUSH
53200: LD_EXP 112
53204: AND
53205: IFFALSE 53334
53207: GO 53209
53209: DISABLE
53210: LD_INT 0
53212: PPUSH
// begin uc_side := 0 ;
53213: LD_ADDR_OWVAR 20
53217: PUSH
53218: LD_INT 0
53220: ST_TO_ADDR
// uc_nation := nation_arabian ;
53221: LD_ADDR_OWVAR 21
53225: PUSH
53226: LD_INT 2
53228: ST_TO_ADDR
// hc_gallery :=  ;
53229: LD_ADDR_OWVAR 33
53233: PUSH
53234: LD_STRING 
53236: ST_TO_ADDR
// hc_name :=  ;
53237: LD_ADDR_OWVAR 26
53241: PUSH
53242: LD_STRING 
53244: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53245: LD_INT 1
53247: PPUSH
53248: LD_INT 11
53250: PPUSH
53251: LD_INT 10
53253: PPUSH
53254: CALL_OW 380
// un := CreateHuman ;
53258: LD_ADDR_VAR 0 1
53262: PUSH
53263: CALL_OW 44
53267: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53268: LD_VAR 0 1
53272: PPUSH
53273: LD_INT 1
53275: PPUSH
53276: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53280: LD_INT 35
53282: PPUSH
53283: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53287: LD_VAR 0 1
53291: PPUSH
53292: LD_INT 22
53294: PUSH
53295: LD_OWVAR 2
53299: PUSH
53300: EMPTY
53301: LIST
53302: LIST
53303: PPUSH
53304: CALL_OW 69
53308: PPUSH
53309: LD_VAR 0 1
53313: PPUSH
53314: CALL_OW 74
53318: PPUSH
53319: CALL_OW 115
// until IsDead ( un ) ;
53323: LD_VAR 0 1
53327: PPUSH
53328: CALL_OW 301
53332: IFFALSE 53280
// end ;
53334: PPOPN 1
53336: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53337: LD_EXP 74
53341: PUSH
53342: LD_EXP 114
53346: AND
53347: IFFALSE 53359
53349: GO 53351
53351: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53352: LD_STRING earthquake(getX(game), 0, 32)
53354: PPUSH
53355: CALL_OW 559
53359: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53360: LD_EXP 74
53364: PUSH
53365: LD_EXP 115
53369: AND
53370: IFFALSE 53461
53372: GO 53374
53374: DISABLE
53375: LD_INT 0
53377: PPUSH
// begin enable ;
53378: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53379: LD_ADDR_VAR 0 1
53383: PUSH
53384: LD_INT 22
53386: PUSH
53387: LD_OWVAR 2
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: PUSH
53396: LD_INT 21
53398: PUSH
53399: LD_INT 2
53401: PUSH
53402: EMPTY
53403: LIST
53404: LIST
53405: PUSH
53406: LD_INT 33
53408: PUSH
53409: LD_INT 3
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: PUSH
53416: EMPTY
53417: LIST
53418: LIST
53419: LIST
53420: PPUSH
53421: CALL_OW 69
53425: ST_TO_ADDR
// if not tmp then
53426: LD_VAR 0 1
53430: NOT
53431: IFFALSE 53435
// exit ;
53433: GO 53461
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53435: LD_VAR 0 1
53439: PUSH
53440: LD_INT 1
53442: PPUSH
53443: LD_VAR 0 1
53447: PPUSH
53448: CALL_OW 12
53452: ARRAY
53453: PPUSH
53454: LD_INT 1
53456: PPUSH
53457: CALL_OW 234
// end ;
53461: PPOPN 1
53463: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53464: LD_EXP 74
53468: PUSH
53469: LD_EXP 116
53473: AND
53474: IFFALSE 53615
53476: GO 53478
53478: DISABLE
53479: LD_INT 0
53481: PPUSH
53482: PPUSH
53483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53484: LD_ADDR_VAR 0 3
53488: PUSH
53489: LD_INT 22
53491: PUSH
53492: LD_OWVAR 2
53496: PUSH
53497: EMPTY
53498: LIST
53499: LIST
53500: PUSH
53501: LD_INT 25
53503: PUSH
53504: LD_INT 1
53506: PUSH
53507: EMPTY
53508: LIST
53509: LIST
53510: PUSH
53511: EMPTY
53512: LIST
53513: LIST
53514: PPUSH
53515: CALL_OW 69
53519: ST_TO_ADDR
// if not tmp then
53520: LD_VAR 0 3
53524: NOT
53525: IFFALSE 53529
// exit ;
53527: GO 53615
// un := tmp [ rand ( 1 , tmp ) ] ;
53529: LD_ADDR_VAR 0 2
53533: PUSH
53534: LD_VAR 0 3
53538: PUSH
53539: LD_INT 1
53541: PPUSH
53542: LD_VAR 0 3
53546: PPUSH
53547: CALL_OW 12
53551: ARRAY
53552: ST_TO_ADDR
// if Crawls ( un ) then
53553: LD_VAR 0 2
53557: PPUSH
53558: CALL_OW 318
53562: IFFALSE 53573
// ComWalk ( un ) ;
53564: LD_VAR 0 2
53568: PPUSH
53569: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53573: LD_VAR 0 2
53577: PPUSH
53578: LD_INT 9
53580: PPUSH
53581: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53585: LD_INT 28
53587: PPUSH
53588: LD_OWVAR 2
53592: PPUSH
53593: LD_INT 2
53595: PPUSH
53596: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53600: LD_INT 29
53602: PPUSH
53603: LD_OWVAR 2
53607: PPUSH
53608: LD_INT 2
53610: PPUSH
53611: CALL_OW 322
// end ;
53615: PPOPN 3
53617: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53618: LD_EXP 74
53622: PUSH
53623: LD_EXP 117
53627: AND
53628: IFFALSE 53739
53630: GO 53632
53632: DISABLE
53633: LD_INT 0
53635: PPUSH
53636: PPUSH
53637: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53638: LD_ADDR_VAR 0 3
53642: PUSH
53643: LD_INT 22
53645: PUSH
53646: LD_OWVAR 2
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: PUSH
53655: LD_INT 25
53657: PUSH
53658: LD_INT 1
53660: PUSH
53661: EMPTY
53662: LIST
53663: LIST
53664: PUSH
53665: EMPTY
53666: LIST
53667: LIST
53668: PPUSH
53669: CALL_OW 69
53673: ST_TO_ADDR
// if not tmp then
53674: LD_VAR 0 3
53678: NOT
53679: IFFALSE 53683
// exit ;
53681: GO 53739
// un := tmp [ rand ( 1 , tmp ) ] ;
53683: LD_ADDR_VAR 0 2
53687: PUSH
53688: LD_VAR 0 3
53692: PUSH
53693: LD_INT 1
53695: PPUSH
53696: LD_VAR 0 3
53700: PPUSH
53701: CALL_OW 12
53705: ARRAY
53706: ST_TO_ADDR
// if Crawls ( un ) then
53707: LD_VAR 0 2
53711: PPUSH
53712: CALL_OW 318
53716: IFFALSE 53727
// ComWalk ( un ) ;
53718: LD_VAR 0 2
53722: PPUSH
53723: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53727: LD_VAR 0 2
53731: PPUSH
53732: LD_INT 8
53734: PPUSH
53735: CALL_OW 336
// end ;
53739: PPOPN 3
53741: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53742: LD_EXP 74
53746: PUSH
53747: LD_EXP 118
53751: AND
53752: IFFALSE 53896
53754: GO 53756
53756: DISABLE
53757: LD_INT 0
53759: PPUSH
53760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53761: LD_ADDR_VAR 0 2
53765: PUSH
53766: LD_INT 22
53768: PUSH
53769: LD_OWVAR 2
53773: PUSH
53774: EMPTY
53775: LIST
53776: LIST
53777: PUSH
53778: LD_INT 21
53780: PUSH
53781: LD_INT 2
53783: PUSH
53784: EMPTY
53785: LIST
53786: LIST
53787: PUSH
53788: LD_INT 2
53790: PUSH
53791: LD_INT 34
53793: PUSH
53794: LD_INT 12
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 34
53803: PUSH
53804: LD_INT 51
53806: PUSH
53807: EMPTY
53808: LIST
53809: LIST
53810: PUSH
53811: LD_INT 34
53813: PUSH
53814: LD_INT 32
53816: PUSH
53817: EMPTY
53818: LIST
53819: LIST
53820: PUSH
53821: EMPTY
53822: LIST
53823: LIST
53824: LIST
53825: LIST
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: LIST
53831: PPUSH
53832: CALL_OW 69
53836: ST_TO_ADDR
// if not tmp then
53837: LD_VAR 0 2
53841: NOT
53842: IFFALSE 53846
// exit ;
53844: GO 53896
// for i in tmp do
53846: LD_ADDR_VAR 0 1
53850: PUSH
53851: LD_VAR 0 2
53855: PUSH
53856: FOR_IN
53857: IFFALSE 53894
// if GetCargo ( i , mat_artifact ) = 0 then
53859: LD_VAR 0 1
53863: PPUSH
53864: LD_INT 4
53866: PPUSH
53867: CALL_OW 289
53871: PUSH
53872: LD_INT 0
53874: EQUAL
53875: IFFALSE 53892
// SetCargo ( i , mat_siberit , 100 ) ;
53877: LD_VAR 0 1
53881: PPUSH
53882: LD_INT 3
53884: PPUSH
53885: LD_INT 100
53887: PPUSH
53888: CALL_OW 290
53892: GO 53856
53894: POP
53895: POP
// end ;
53896: PPOPN 2
53898: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53899: LD_EXP 74
53903: PUSH
53904: LD_EXP 119
53908: AND
53909: IFFALSE 54092
53911: GO 53913
53913: DISABLE
53914: LD_INT 0
53916: PPUSH
53917: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53918: LD_ADDR_VAR 0 2
53922: PUSH
53923: LD_INT 22
53925: PUSH
53926: LD_OWVAR 2
53930: PUSH
53931: EMPTY
53932: LIST
53933: LIST
53934: PPUSH
53935: CALL_OW 69
53939: ST_TO_ADDR
// if not tmp then
53940: LD_VAR 0 2
53944: NOT
53945: IFFALSE 53949
// exit ;
53947: GO 54092
// for i := 1 to 2 do
53949: LD_ADDR_VAR 0 1
53953: PUSH
53954: DOUBLE
53955: LD_INT 1
53957: DEC
53958: ST_TO_ADDR
53959: LD_INT 2
53961: PUSH
53962: FOR_TO
53963: IFFALSE 54090
// begin uc_side := your_side ;
53965: LD_ADDR_OWVAR 20
53969: PUSH
53970: LD_OWVAR 2
53974: ST_TO_ADDR
// uc_nation := nation_american ;
53975: LD_ADDR_OWVAR 21
53979: PUSH
53980: LD_INT 1
53982: ST_TO_ADDR
// vc_chassis := us_morphling ;
53983: LD_ADDR_OWVAR 37
53987: PUSH
53988: LD_INT 5
53990: ST_TO_ADDR
// vc_engine := engine_siberite ;
53991: LD_ADDR_OWVAR 39
53995: PUSH
53996: LD_INT 3
53998: ST_TO_ADDR
// vc_control := control_computer ;
53999: LD_ADDR_OWVAR 38
54003: PUSH
54004: LD_INT 3
54006: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54007: LD_ADDR_OWVAR 40
54011: PUSH
54012: LD_INT 10
54014: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54015: LD_VAR 0 2
54019: PUSH
54020: LD_INT 1
54022: ARRAY
54023: PPUSH
54024: CALL_OW 310
54028: NOT
54029: IFFALSE 54076
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54031: CALL_OW 45
54035: PPUSH
54036: LD_VAR 0 2
54040: PUSH
54041: LD_INT 1
54043: ARRAY
54044: PPUSH
54045: CALL_OW 250
54049: PPUSH
54050: LD_VAR 0 2
54054: PUSH
54055: LD_INT 1
54057: ARRAY
54058: PPUSH
54059: CALL_OW 251
54063: PPUSH
54064: LD_INT 12
54066: PPUSH
54067: LD_INT 1
54069: PPUSH
54070: CALL_OW 50
54074: GO 54088
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54076: CALL_OW 45
54080: PPUSH
54081: LD_INT 1
54083: PPUSH
54084: CALL_OW 51
// end ;
54088: GO 53962
54090: POP
54091: POP
// end ;
54092: PPOPN 2
54094: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54095: LD_EXP 74
54099: PUSH
54100: LD_EXP 120
54104: AND
54105: IFFALSE 54327
54107: GO 54109
54109: DISABLE
54110: LD_INT 0
54112: PPUSH
54113: PPUSH
54114: PPUSH
54115: PPUSH
54116: PPUSH
54117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54118: LD_ADDR_VAR 0 6
54122: PUSH
54123: LD_INT 22
54125: PUSH
54126: LD_OWVAR 2
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PUSH
54135: LD_INT 21
54137: PUSH
54138: LD_INT 1
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: PUSH
54145: LD_INT 3
54147: PUSH
54148: LD_INT 23
54150: PUSH
54151: LD_INT 0
54153: PUSH
54154: EMPTY
54155: LIST
54156: LIST
54157: PUSH
54158: EMPTY
54159: LIST
54160: LIST
54161: PUSH
54162: EMPTY
54163: LIST
54164: LIST
54165: LIST
54166: PPUSH
54167: CALL_OW 69
54171: ST_TO_ADDR
// if not tmp then
54172: LD_VAR 0 6
54176: NOT
54177: IFFALSE 54181
// exit ;
54179: GO 54327
// s1 := rand ( 1 , 4 ) ;
54181: LD_ADDR_VAR 0 2
54185: PUSH
54186: LD_INT 1
54188: PPUSH
54189: LD_INT 4
54191: PPUSH
54192: CALL_OW 12
54196: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54197: LD_ADDR_VAR 0 4
54201: PUSH
54202: LD_VAR 0 6
54206: PUSH
54207: LD_INT 1
54209: ARRAY
54210: PPUSH
54211: LD_VAR 0 2
54215: PPUSH
54216: CALL_OW 259
54220: ST_TO_ADDR
// if s1 = 1 then
54221: LD_VAR 0 2
54225: PUSH
54226: LD_INT 1
54228: EQUAL
54229: IFFALSE 54249
// s2 := rand ( 2 , 4 ) else
54231: LD_ADDR_VAR 0 3
54235: PUSH
54236: LD_INT 2
54238: PPUSH
54239: LD_INT 4
54241: PPUSH
54242: CALL_OW 12
54246: ST_TO_ADDR
54247: GO 54257
// s2 := 1 ;
54249: LD_ADDR_VAR 0 3
54253: PUSH
54254: LD_INT 1
54256: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54257: LD_ADDR_VAR 0 5
54261: PUSH
54262: LD_VAR 0 6
54266: PUSH
54267: LD_INT 1
54269: ARRAY
54270: PPUSH
54271: LD_VAR 0 3
54275: PPUSH
54276: CALL_OW 259
54280: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54281: LD_VAR 0 6
54285: PUSH
54286: LD_INT 1
54288: ARRAY
54289: PPUSH
54290: LD_VAR 0 2
54294: PPUSH
54295: LD_VAR 0 5
54299: PPUSH
54300: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54304: LD_VAR 0 6
54308: PUSH
54309: LD_INT 1
54311: ARRAY
54312: PPUSH
54313: LD_VAR 0 3
54317: PPUSH
54318: LD_VAR 0 4
54322: PPUSH
54323: CALL_OW 237
// end ;
54327: PPOPN 6
54329: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54330: LD_EXP 74
54334: PUSH
54335: LD_EXP 121
54339: AND
54340: IFFALSE 54419
54342: GO 54344
54344: DISABLE
54345: LD_INT 0
54347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54348: LD_ADDR_VAR 0 1
54352: PUSH
54353: LD_INT 22
54355: PUSH
54356: LD_OWVAR 2
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: PUSH
54365: LD_INT 30
54367: PUSH
54368: LD_INT 3
54370: PUSH
54371: EMPTY
54372: LIST
54373: LIST
54374: PUSH
54375: EMPTY
54376: LIST
54377: LIST
54378: PPUSH
54379: CALL_OW 69
54383: ST_TO_ADDR
// if not tmp then
54384: LD_VAR 0 1
54388: NOT
54389: IFFALSE 54393
// exit ;
54391: GO 54419
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54393: LD_VAR 0 1
54397: PUSH
54398: LD_INT 1
54400: PPUSH
54401: LD_VAR 0 1
54405: PPUSH
54406: CALL_OW 12
54410: ARRAY
54411: PPUSH
54412: LD_INT 1
54414: PPUSH
54415: CALL_OW 234
// end ;
54419: PPOPN 1
54421: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54422: LD_EXP 74
54426: PUSH
54427: LD_EXP 122
54431: AND
54432: IFFALSE 54544
54434: GO 54436
54436: DISABLE
54437: LD_INT 0
54439: PPUSH
54440: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54441: LD_ADDR_VAR 0 2
54445: PUSH
54446: LD_INT 22
54448: PUSH
54449: LD_OWVAR 2
54453: PUSH
54454: EMPTY
54455: LIST
54456: LIST
54457: PUSH
54458: LD_INT 2
54460: PUSH
54461: LD_INT 30
54463: PUSH
54464: LD_INT 27
54466: PUSH
54467: EMPTY
54468: LIST
54469: LIST
54470: PUSH
54471: LD_INT 30
54473: PUSH
54474: LD_INT 26
54476: PUSH
54477: EMPTY
54478: LIST
54479: LIST
54480: PUSH
54481: LD_INT 30
54483: PUSH
54484: LD_INT 28
54486: PUSH
54487: EMPTY
54488: LIST
54489: LIST
54490: PUSH
54491: EMPTY
54492: LIST
54493: LIST
54494: LIST
54495: LIST
54496: PUSH
54497: EMPTY
54498: LIST
54499: LIST
54500: PPUSH
54501: CALL_OW 69
54505: ST_TO_ADDR
// if not tmp then
54506: LD_VAR 0 2
54510: NOT
54511: IFFALSE 54515
// exit ;
54513: GO 54544
// for i in tmp do
54515: LD_ADDR_VAR 0 1
54519: PUSH
54520: LD_VAR 0 2
54524: PUSH
54525: FOR_IN
54526: IFFALSE 54542
// SetLives ( i , 1 ) ;
54528: LD_VAR 0 1
54532: PPUSH
54533: LD_INT 1
54535: PPUSH
54536: CALL_OW 234
54540: GO 54525
54542: POP
54543: POP
// end ;
54544: PPOPN 2
54546: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54547: LD_EXP 74
54551: PUSH
54552: LD_EXP 123
54556: AND
54557: IFFALSE 54844
54559: GO 54561
54561: DISABLE
54562: LD_INT 0
54564: PPUSH
54565: PPUSH
54566: PPUSH
// begin i := rand ( 1 , 7 ) ;
54567: LD_ADDR_VAR 0 1
54571: PUSH
54572: LD_INT 1
54574: PPUSH
54575: LD_INT 7
54577: PPUSH
54578: CALL_OW 12
54582: ST_TO_ADDR
// case i of 1 :
54583: LD_VAR 0 1
54587: PUSH
54588: LD_INT 1
54590: DOUBLE
54591: EQUAL
54592: IFTRUE 54596
54594: GO 54606
54596: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54597: LD_STRING earthquake(getX(game), 0, 32)
54599: PPUSH
54600: CALL_OW 559
54604: GO 54844
54606: LD_INT 2
54608: DOUBLE
54609: EQUAL
54610: IFTRUE 54614
54612: GO 54628
54614: POP
// begin ToLua ( displayStucuk(); ) ;
54615: LD_STRING displayStucuk();
54617: PPUSH
54618: CALL_OW 559
// ResetFog ;
54622: CALL_OW 335
// end ; 3 :
54626: GO 54844
54628: LD_INT 3
54630: DOUBLE
54631: EQUAL
54632: IFTRUE 54636
54634: GO 54740
54636: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54637: LD_ADDR_VAR 0 2
54641: PUSH
54642: LD_INT 22
54644: PUSH
54645: LD_OWVAR 2
54649: PUSH
54650: EMPTY
54651: LIST
54652: LIST
54653: PUSH
54654: LD_INT 25
54656: PUSH
54657: LD_INT 1
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: PUSH
54664: EMPTY
54665: LIST
54666: LIST
54667: PPUSH
54668: CALL_OW 69
54672: ST_TO_ADDR
// if not tmp then
54673: LD_VAR 0 2
54677: NOT
54678: IFFALSE 54682
// exit ;
54680: GO 54844
// un := tmp [ rand ( 1 , tmp ) ] ;
54682: LD_ADDR_VAR 0 3
54686: PUSH
54687: LD_VAR 0 2
54691: PUSH
54692: LD_INT 1
54694: PPUSH
54695: LD_VAR 0 2
54699: PPUSH
54700: CALL_OW 12
54704: ARRAY
54705: ST_TO_ADDR
// if Crawls ( un ) then
54706: LD_VAR 0 3
54710: PPUSH
54711: CALL_OW 318
54715: IFFALSE 54726
// ComWalk ( un ) ;
54717: LD_VAR 0 3
54721: PPUSH
54722: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54726: LD_VAR 0 3
54730: PPUSH
54731: LD_INT 8
54733: PPUSH
54734: CALL_OW 336
// end ; 4 :
54738: GO 54844
54740: LD_INT 4
54742: DOUBLE
54743: EQUAL
54744: IFTRUE 54748
54746: GO 54822
54748: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54749: LD_ADDR_VAR 0 2
54753: PUSH
54754: LD_INT 22
54756: PUSH
54757: LD_OWVAR 2
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: PUSH
54766: LD_INT 30
54768: PUSH
54769: LD_INT 29
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: PPUSH
54780: CALL_OW 69
54784: ST_TO_ADDR
// if not tmp then
54785: LD_VAR 0 2
54789: NOT
54790: IFFALSE 54794
// exit ;
54792: GO 54844
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54794: LD_VAR 0 2
54798: PUSH
54799: LD_INT 1
54801: ARRAY
54802: PPUSH
54803: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54807: LD_VAR 0 2
54811: PUSH
54812: LD_INT 1
54814: ARRAY
54815: PPUSH
54816: CALL_OW 65
// end ; 5 .. 7 :
54820: GO 54844
54822: LD_INT 5
54824: DOUBLE
54825: GREATEREQUAL
54826: IFFALSE 54834
54828: LD_INT 7
54830: DOUBLE
54831: LESSEQUAL
54832: IFTRUE 54836
54834: GO 54843
54836: POP
// StreamSibBomb ; end ;
54837: CALL 51081 0 0
54841: GO 54844
54843: POP
// end ;
54844: PPOPN 3
54846: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54847: LD_EXP 74
54851: PUSH
54852: LD_EXP 124
54856: AND
54857: IFFALSE 55013
54859: GO 54861
54861: DISABLE
54862: LD_INT 0
54864: PPUSH
54865: PPUSH
54866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54867: LD_ADDR_VAR 0 2
54871: PUSH
54872: LD_INT 81
54874: PUSH
54875: LD_OWVAR 2
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: PUSH
54884: LD_INT 2
54886: PUSH
54887: LD_INT 21
54889: PUSH
54890: LD_INT 1
54892: PUSH
54893: EMPTY
54894: LIST
54895: LIST
54896: PUSH
54897: LD_INT 21
54899: PUSH
54900: LD_INT 2
54902: PUSH
54903: EMPTY
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: LIST
54911: PUSH
54912: EMPTY
54913: LIST
54914: LIST
54915: PPUSH
54916: CALL_OW 69
54920: ST_TO_ADDR
// if not tmp then
54921: LD_VAR 0 2
54925: NOT
54926: IFFALSE 54930
// exit ;
54928: GO 55013
// p := 0 ;
54930: LD_ADDR_VAR 0 3
54934: PUSH
54935: LD_INT 0
54937: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54938: LD_INT 35
54940: PPUSH
54941: CALL_OW 67
// p := p + 1 ;
54945: LD_ADDR_VAR 0 3
54949: PUSH
54950: LD_VAR 0 3
54954: PUSH
54955: LD_INT 1
54957: PLUS
54958: ST_TO_ADDR
// for i in tmp do
54959: LD_ADDR_VAR 0 1
54963: PUSH
54964: LD_VAR 0 2
54968: PUSH
54969: FOR_IN
54970: IFFALSE 55001
// if GetLives ( i ) < 1000 then
54972: LD_VAR 0 1
54976: PPUSH
54977: CALL_OW 256
54981: PUSH
54982: LD_INT 1000
54984: LESS
54985: IFFALSE 54999
// SetLives ( i , 1000 ) ;
54987: LD_VAR 0 1
54991: PPUSH
54992: LD_INT 1000
54994: PPUSH
54995: CALL_OW 234
54999: GO 54969
55001: POP
55002: POP
// until p > 20 ;
55003: LD_VAR 0 3
55007: PUSH
55008: LD_INT 20
55010: GREATER
55011: IFFALSE 54938
// end ;
55013: PPOPN 3
55015: END
// every 0 0$1 trigger StreamModeActive and sTime do
55016: LD_EXP 74
55020: PUSH
55021: LD_EXP 125
55025: AND
55026: IFFALSE 55061
55028: GO 55030
55030: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55031: LD_INT 28
55033: PPUSH
55034: LD_OWVAR 2
55038: PPUSH
55039: LD_INT 2
55041: PPUSH
55042: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55046: LD_INT 30
55048: PPUSH
55049: LD_OWVAR 2
55053: PPUSH
55054: LD_INT 2
55056: PPUSH
55057: CALL_OW 322
// end ;
55061: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55062: LD_EXP 74
55066: PUSH
55067: LD_EXP 126
55071: AND
55072: IFFALSE 55193
55074: GO 55076
55076: DISABLE
55077: LD_INT 0
55079: PPUSH
55080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55081: LD_ADDR_VAR 0 2
55085: PUSH
55086: LD_INT 22
55088: PUSH
55089: LD_OWVAR 2
55093: PUSH
55094: EMPTY
55095: LIST
55096: LIST
55097: PUSH
55098: LD_INT 21
55100: PUSH
55101: LD_INT 1
55103: PUSH
55104: EMPTY
55105: LIST
55106: LIST
55107: PUSH
55108: LD_INT 3
55110: PUSH
55111: LD_INT 23
55113: PUSH
55114: LD_INT 0
55116: PUSH
55117: EMPTY
55118: LIST
55119: LIST
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: PUSH
55125: EMPTY
55126: LIST
55127: LIST
55128: LIST
55129: PPUSH
55130: CALL_OW 69
55134: ST_TO_ADDR
// if not tmp then
55135: LD_VAR 0 2
55139: NOT
55140: IFFALSE 55144
// exit ;
55142: GO 55193
// for i in tmp do
55144: LD_ADDR_VAR 0 1
55148: PUSH
55149: LD_VAR 0 2
55153: PUSH
55154: FOR_IN
55155: IFFALSE 55191
// begin if Crawls ( i ) then
55157: LD_VAR 0 1
55161: PPUSH
55162: CALL_OW 318
55166: IFFALSE 55177
// ComWalk ( i ) ;
55168: LD_VAR 0 1
55172: PPUSH
55173: CALL_OW 138
// SetClass ( i , 2 ) ;
55177: LD_VAR 0 1
55181: PPUSH
55182: LD_INT 2
55184: PPUSH
55185: CALL_OW 336
// end ;
55189: GO 55154
55191: POP
55192: POP
// end ;
55193: PPOPN 2
55195: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55196: LD_EXP 74
55200: PUSH
55201: LD_EXP 127
55205: AND
55206: IFFALSE 55494
55208: GO 55210
55210: DISABLE
55211: LD_INT 0
55213: PPUSH
55214: PPUSH
55215: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55216: LD_OWVAR 2
55220: PPUSH
55221: LD_INT 9
55223: PPUSH
55224: LD_INT 1
55226: PPUSH
55227: LD_INT 1
55229: PPUSH
55230: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55234: LD_INT 9
55236: PPUSH
55237: LD_OWVAR 2
55241: PPUSH
55242: CALL_OW 343
// uc_side := 9 ;
55246: LD_ADDR_OWVAR 20
55250: PUSH
55251: LD_INT 9
55253: ST_TO_ADDR
// uc_nation := 2 ;
55254: LD_ADDR_OWVAR 21
55258: PUSH
55259: LD_INT 2
55261: ST_TO_ADDR
// hc_name := Dark Warrior ;
55262: LD_ADDR_OWVAR 26
55266: PUSH
55267: LD_STRING Dark Warrior
55269: ST_TO_ADDR
// hc_gallery :=  ;
55270: LD_ADDR_OWVAR 33
55274: PUSH
55275: LD_STRING 
55277: ST_TO_ADDR
// hc_noskilllimit := true ;
55278: LD_ADDR_OWVAR 76
55282: PUSH
55283: LD_INT 1
55285: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55286: LD_ADDR_OWVAR 31
55290: PUSH
55291: LD_INT 30
55293: PUSH
55294: LD_INT 30
55296: PUSH
55297: LD_INT 30
55299: PUSH
55300: LD_INT 30
55302: PUSH
55303: EMPTY
55304: LIST
55305: LIST
55306: LIST
55307: LIST
55308: ST_TO_ADDR
// un := CreateHuman ;
55309: LD_ADDR_VAR 0 3
55313: PUSH
55314: CALL_OW 44
55318: ST_TO_ADDR
// hc_noskilllimit := false ;
55319: LD_ADDR_OWVAR 76
55323: PUSH
55324: LD_INT 0
55326: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55327: LD_VAR 0 3
55331: PPUSH
55332: LD_INT 1
55334: PPUSH
55335: CALL_OW 51
// ToLua ( playRanger() ) ;
55339: LD_STRING playRanger()
55341: PPUSH
55342: CALL_OW 559
// p := 0 ;
55346: LD_ADDR_VAR 0 2
55350: PUSH
55351: LD_INT 0
55353: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55354: LD_INT 35
55356: PPUSH
55357: CALL_OW 67
// p := p + 1 ;
55361: LD_ADDR_VAR 0 2
55365: PUSH
55366: LD_VAR 0 2
55370: PUSH
55371: LD_INT 1
55373: PLUS
55374: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55375: LD_VAR 0 3
55379: PPUSH
55380: CALL_OW 256
55384: PUSH
55385: LD_INT 1000
55387: LESS
55388: IFFALSE 55402
// SetLives ( un , 1000 ) ;
55390: LD_VAR 0 3
55394: PPUSH
55395: LD_INT 1000
55397: PPUSH
55398: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55402: LD_VAR 0 3
55406: PPUSH
55407: LD_INT 81
55409: PUSH
55410: LD_OWVAR 2
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: PUSH
55419: LD_INT 91
55421: PUSH
55422: LD_VAR 0 3
55426: PUSH
55427: LD_INT 30
55429: PUSH
55430: EMPTY
55431: LIST
55432: LIST
55433: LIST
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: PPUSH
55439: CALL_OW 69
55443: PPUSH
55444: LD_VAR 0 3
55448: PPUSH
55449: CALL_OW 74
55453: PPUSH
55454: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55458: LD_VAR 0 2
55462: PUSH
55463: LD_INT 80
55465: GREATER
55466: PUSH
55467: LD_VAR 0 3
55471: PPUSH
55472: CALL_OW 301
55476: OR
55477: IFFALSE 55354
// if un then
55479: LD_VAR 0 3
55483: IFFALSE 55494
// RemoveUnit ( un ) ;
55485: LD_VAR 0 3
55489: PPUSH
55490: CALL_OW 64
// end ;
55494: PPOPN 3
55496: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55497: LD_EXP 128
55501: IFFALSE 55617
55503: GO 55505
55505: DISABLE
55506: LD_INT 0
55508: PPUSH
55509: PPUSH
55510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55511: LD_ADDR_VAR 0 2
55515: PUSH
55516: LD_INT 81
55518: PUSH
55519: LD_OWVAR 2
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: PUSH
55528: LD_INT 21
55530: PUSH
55531: LD_INT 1
55533: PUSH
55534: EMPTY
55535: LIST
55536: LIST
55537: PUSH
55538: EMPTY
55539: LIST
55540: LIST
55541: PPUSH
55542: CALL_OW 69
55546: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55547: LD_STRING playComputer()
55549: PPUSH
55550: CALL_OW 559
// if not tmp then
55554: LD_VAR 0 2
55558: NOT
55559: IFFALSE 55563
// exit ;
55561: GO 55617
// for i in tmp do
55563: LD_ADDR_VAR 0 1
55567: PUSH
55568: LD_VAR 0 2
55572: PUSH
55573: FOR_IN
55574: IFFALSE 55615
// for j := 1 to 4 do
55576: LD_ADDR_VAR 0 3
55580: PUSH
55581: DOUBLE
55582: LD_INT 1
55584: DEC
55585: ST_TO_ADDR
55586: LD_INT 4
55588: PUSH
55589: FOR_TO
55590: IFFALSE 55611
// SetSkill ( i , j , 10 ) ;
55592: LD_VAR 0 1
55596: PPUSH
55597: LD_VAR 0 3
55601: PPUSH
55602: LD_INT 10
55604: PPUSH
55605: CALL_OW 237
55609: GO 55589
55611: POP
55612: POP
55613: GO 55573
55615: POP
55616: POP
// end ;
55617: PPOPN 3
55619: END
// every 0 0$1 trigger s30 do var i , tmp ;
55620: LD_EXP 129
55624: IFFALSE 55693
55626: GO 55628
55628: DISABLE
55629: LD_INT 0
55631: PPUSH
55632: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55633: LD_ADDR_VAR 0 2
55637: PUSH
55638: LD_INT 22
55640: PUSH
55641: LD_OWVAR 2
55645: PUSH
55646: EMPTY
55647: LIST
55648: LIST
55649: PPUSH
55650: CALL_OW 69
55654: ST_TO_ADDR
// if not tmp then
55655: LD_VAR 0 2
55659: NOT
55660: IFFALSE 55664
// exit ;
55662: GO 55693
// for i in tmp do
55664: LD_ADDR_VAR 0 1
55668: PUSH
55669: LD_VAR 0 2
55673: PUSH
55674: FOR_IN
55675: IFFALSE 55691
// SetLives ( i , 300 ) ;
55677: LD_VAR 0 1
55681: PPUSH
55682: LD_INT 300
55684: PPUSH
55685: CALL_OW 234
55689: GO 55674
55691: POP
55692: POP
// end ;
55693: PPOPN 2
55695: END
// every 0 0$1 trigger s60 do var i , tmp ;
55696: LD_EXP 130
55700: IFFALSE 55769
55702: GO 55704
55704: DISABLE
55705: LD_INT 0
55707: PPUSH
55708: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55709: LD_ADDR_VAR 0 2
55713: PUSH
55714: LD_INT 22
55716: PUSH
55717: LD_OWVAR 2
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: PPUSH
55726: CALL_OW 69
55730: ST_TO_ADDR
// if not tmp then
55731: LD_VAR 0 2
55735: NOT
55736: IFFALSE 55740
// exit ;
55738: GO 55769
// for i in tmp do
55740: LD_ADDR_VAR 0 1
55744: PUSH
55745: LD_VAR 0 2
55749: PUSH
55750: FOR_IN
55751: IFFALSE 55767
// SetLives ( i , 600 ) ;
55753: LD_VAR 0 1
55757: PPUSH
55758: LD_INT 600
55760: PPUSH
55761: CALL_OW 234
55765: GO 55750
55767: POP
55768: POP
// end ;
55769: PPOPN 2
55771: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55772: LD_INT 0
55774: PPUSH
// case cmd of 301 :
55775: LD_VAR 0 1
55779: PUSH
55780: LD_INT 301
55782: DOUBLE
55783: EQUAL
55784: IFTRUE 55788
55786: GO 55820
55788: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55789: LD_VAR 0 6
55793: PPUSH
55794: LD_VAR 0 7
55798: PPUSH
55799: LD_VAR 0 8
55803: PPUSH
55804: LD_VAR 0 4
55808: PPUSH
55809: LD_VAR 0 5
55813: PPUSH
55814: CALL 57021 0 5
55818: GO 55941
55820: LD_INT 302
55822: DOUBLE
55823: EQUAL
55824: IFTRUE 55828
55826: GO 55865
55828: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55829: LD_VAR 0 6
55833: PPUSH
55834: LD_VAR 0 7
55838: PPUSH
55839: LD_VAR 0 8
55843: PPUSH
55844: LD_VAR 0 9
55848: PPUSH
55849: LD_VAR 0 4
55853: PPUSH
55854: LD_VAR 0 5
55858: PPUSH
55859: CALL 57112 0 6
55863: GO 55941
55865: LD_INT 303
55867: DOUBLE
55868: EQUAL
55869: IFTRUE 55873
55871: GO 55910
55873: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55874: LD_VAR 0 6
55878: PPUSH
55879: LD_VAR 0 7
55883: PPUSH
55884: LD_VAR 0 8
55888: PPUSH
55889: LD_VAR 0 9
55893: PPUSH
55894: LD_VAR 0 4
55898: PPUSH
55899: LD_VAR 0 5
55903: PPUSH
55904: CALL 55946 0 6
55908: GO 55941
55910: LD_INT 304
55912: DOUBLE
55913: EQUAL
55914: IFTRUE 55918
55916: GO 55940
55918: POP
// hHackTeleport ( unit , x , y ) ; end ;
55919: LD_VAR 0 2
55923: PPUSH
55924: LD_VAR 0 4
55928: PPUSH
55929: LD_VAR 0 5
55933: PPUSH
55934: CALL 57705 0 3
55938: GO 55941
55940: POP
// end ;
55941: LD_VAR 0 12
55945: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55946: LD_INT 0
55948: PPUSH
55949: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55950: LD_VAR 0 1
55954: PUSH
55955: LD_INT 1
55957: LESS
55958: PUSH
55959: LD_VAR 0 1
55963: PUSH
55964: LD_INT 3
55966: GREATER
55967: OR
55968: PUSH
55969: LD_VAR 0 5
55973: PPUSH
55974: LD_VAR 0 6
55978: PPUSH
55979: CALL_OW 428
55983: OR
55984: IFFALSE 55988
// exit ;
55986: GO 56708
// uc_side := your_side ;
55988: LD_ADDR_OWVAR 20
55992: PUSH
55993: LD_OWVAR 2
55997: ST_TO_ADDR
// uc_nation := nation ;
55998: LD_ADDR_OWVAR 21
56002: PUSH
56003: LD_VAR 0 1
56007: ST_TO_ADDR
// bc_level = 1 ;
56008: LD_ADDR_OWVAR 43
56012: PUSH
56013: LD_INT 1
56015: ST_TO_ADDR
// case btype of 1 :
56016: LD_VAR 0 2
56020: PUSH
56021: LD_INT 1
56023: DOUBLE
56024: EQUAL
56025: IFTRUE 56029
56027: GO 56040
56029: POP
// bc_type := b_depot ; 2 :
56030: LD_ADDR_OWVAR 42
56034: PUSH
56035: LD_INT 0
56037: ST_TO_ADDR
56038: GO 56652
56040: LD_INT 2
56042: DOUBLE
56043: EQUAL
56044: IFTRUE 56048
56046: GO 56059
56048: POP
// bc_type := b_warehouse ; 3 :
56049: LD_ADDR_OWVAR 42
56053: PUSH
56054: LD_INT 1
56056: ST_TO_ADDR
56057: GO 56652
56059: LD_INT 3
56061: DOUBLE
56062: EQUAL
56063: IFTRUE 56067
56065: GO 56078
56067: POP
// bc_type := b_lab ; 4 .. 9 :
56068: LD_ADDR_OWVAR 42
56072: PUSH
56073: LD_INT 6
56075: ST_TO_ADDR
56076: GO 56652
56078: LD_INT 4
56080: DOUBLE
56081: GREATEREQUAL
56082: IFFALSE 56090
56084: LD_INT 9
56086: DOUBLE
56087: LESSEQUAL
56088: IFTRUE 56092
56090: GO 56144
56092: POP
// begin bc_type := b_lab_half ;
56093: LD_ADDR_OWVAR 42
56097: PUSH
56098: LD_INT 7
56100: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56101: LD_ADDR_OWVAR 44
56105: PUSH
56106: LD_INT 10
56108: PUSH
56109: LD_INT 11
56111: PUSH
56112: LD_INT 12
56114: PUSH
56115: LD_INT 15
56117: PUSH
56118: LD_INT 14
56120: PUSH
56121: LD_INT 13
56123: PUSH
56124: EMPTY
56125: LIST
56126: LIST
56127: LIST
56128: LIST
56129: LIST
56130: LIST
56131: PUSH
56132: LD_VAR 0 2
56136: PUSH
56137: LD_INT 3
56139: MINUS
56140: ARRAY
56141: ST_TO_ADDR
// end ; 10 .. 13 :
56142: GO 56652
56144: LD_INT 10
56146: DOUBLE
56147: GREATEREQUAL
56148: IFFALSE 56156
56150: LD_INT 13
56152: DOUBLE
56153: LESSEQUAL
56154: IFTRUE 56158
56156: GO 56235
56158: POP
// begin bc_type := b_lab_full ;
56159: LD_ADDR_OWVAR 42
56163: PUSH
56164: LD_INT 8
56166: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56167: LD_ADDR_OWVAR 44
56171: PUSH
56172: LD_INT 10
56174: PUSH
56175: LD_INT 12
56177: PUSH
56178: LD_INT 14
56180: PUSH
56181: LD_INT 13
56183: PUSH
56184: EMPTY
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: PUSH
56190: LD_VAR 0 2
56194: PUSH
56195: LD_INT 9
56197: MINUS
56198: ARRAY
56199: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56200: LD_ADDR_OWVAR 45
56204: PUSH
56205: LD_INT 11
56207: PUSH
56208: LD_INT 15
56210: PUSH
56211: LD_INT 12
56213: PUSH
56214: LD_INT 15
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: LIST
56221: LIST
56222: PUSH
56223: LD_VAR 0 2
56227: PUSH
56228: LD_INT 9
56230: MINUS
56231: ARRAY
56232: ST_TO_ADDR
// end ; 14 :
56233: GO 56652
56235: LD_INT 14
56237: DOUBLE
56238: EQUAL
56239: IFTRUE 56243
56241: GO 56254
56243: POP
// bc_type := b_workshop ; 15 :
56244: LD_ADDR_OWVAR 42
56248: PUSH
56249: LD_INT 2
56251: ST_TO_ADDR
56252: GO 56652
56254: LD_INT 15
56256: DOUBLE
56257: EQUAL
56258: IFTRUE 56262
56260: GO 56273
56262: POP
// bc_type := b_factory ; 16 :
56263: LD_ADDR_OWVAR 42
56267: PUSH
56268: LD_INT 3
56270: ST_TO_ADDR
56271: GO 56652
56273: LD_INT 16
56275: DOUBLE
56276: EQUAL
56277: IFTRUE 56281
56279: GO 56292
56281: POP
// bc_type := b_ext_gun ; 17 :
56282: LD_ADDR_OWVAR 42
56286: PUSH
56287: LD_INT 17
56289: ST_TO_ADDR
56290: GO 56652
56292: LD_INT 17
56294: DOUBLE
56295: EQUAL
56296: IFTRUE 56300
56298: GO 56328
56300: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56301: LD_ADDR_OWVAR 42
56305: PUSH
56306: LD_INT 19
56308: PUSH
56309: LD_INT 23
56311: PUSH
56312: LD_INT 19
56314: PUSH
56315: EMPTY
56316: LIST
56317: LIST
56318: LIST
56319: PUSH
56320: LD_VAR 0 1
56324: ARRAY
56325: ST_TO_ADDR
56326: GO 56652
56328: LD_INT 18
56330: DOUBLE
56331: EQUAL
56332: IFTRUE 56336
56334: GO 56347
56336: POP
// bc_type := b_ext_radar ; 19 :
56337: LD_ADDR_OWVAR 42
56341: PUSH
56342: LD_INT 20
56344: ST_TO_ADDR
56345: GO 56652
56347: LD_INT 19
56349: DOUBLE
56350: EQUAL
56351: IFTRUE 56355
56353: GO 56366
56355: POP
// bc_type := b_ext_radio ; 20 :
56356: LD_ADDR_OWVAR 42
56360: PUSH
56361: LD_INT 22
56363: ST_TO_ADDR
56364: GO 56652
56366: LD_INT 20
56368: DOUBLE
56369: EQUAL
56370: IFTRUE 56374
56372: GO 56385
56374: POP
// bc_type := b_ext_siberium ; 21 :
56375: LD_ADDR_OWVAR 42
56379: PUSH
56380: LD_INT 21
56382: ST_TO_ADDR
56383: GO 56652
56385: LD_INT 21
56387: DOUBLE
56388: EQUAL
56389: IFTRUE 56393
56391: GO 56404
56393: POP
// bc_type := b_ext_computer ; 22 :
56394: LD_ADDR_OWVAR 42
56398: PUSH
56399: LD_INT 24
56401: ST_TO_ADDR
56402: GO 56652
56404: LD_INT 22
56406: DOUBLE
56407: EQUAL
56408: IFTRUE 56412
56410: GO 56423
56412: POP
// bc_type := b_ext_track ; 23 :
56413: LD_ADDR_OWVAR 42
56417: PUSH
56418: LD_INT 16
56420: ST_TO_ADDR
56421: GO 56652
56423: LD_INT 23
56425: DOUBLE
56426: EQUAL
56427: IFTRUE 56431
56429: GO 56442
56431: POP
// bc_type := b_ext_laser ; 24 :
56432: LD_ADDR_OWVAR 42
56436: PUSH
56437: LD_INT 25
56439: ST_TO_ADDR
56440: GO 56652
56442: LD_INT 24
56444: DOUBLE
56445: EQUAL
56446: IFTRUE 56450
56448: GO 56461
56450: POP
// bc_type := b_control_tower ; 25 :
56451: LD_ADDR_OWVAR 42
56455: PUSH
56456: LD_INT 36
56458: ST_TO_ADDR
56459: GO 56652
56461: LD_INT 25
56463: DOUBLE
56464: EQUAL
56465: IFTRUE 56469
56467: GO 56480
56469: POP
// bc_type := b_breastwork ; 26 :
56470: LD_ADDR_OWVAR 42
56474: PUSH
56475: LD_INT 31
56477: ST_TO_ADDR
56478: GO 56652
56480: LD_INT 26
56482: DOUBLE
56483: EQUAL
56484: IFTRUE 56488
56486: GO 56499
56488: POP
// bc_type := b_bunker ; 27 :
56489: LD_ADDR_OWVAR 42
56493: PUSH
56494: LD_INT 32
56496: ST_TO_ADDR
56497: GO 56652
56499: LD_INT 27
56501: DOUBLE
56502: EQUAL
56503: IFTRUE 56507
56505: GO 56518
56507: POP
// bc_type := b_turret ; 28 :
56508: LD_ADDR_OWVAR 42
56512: PUSH
56513: LD_INT 33
56515: ST_TO_ADDR
56516: GO 56652
56518: LD_INT 28
56520: DOUBLE
56521: EQUAL
56522: IFTRUE 56526
56524: GO 56537
56526: POP
// bc_type := b_armoury ; 29 :
56527: LD_ADDR_OWVAR 42
56531: PUSH
56532: LD_INT 4
56534: ST_TO_ADDR
56535: GO 56652
56537: LD_INT 29
56539: DOUBLE
56540: EQUAL
56541: IFTRUE 56545
56543: GO 56556
56545: POP
// bc_type := b_barracks ; 30 :
56546: LD_ADDR_OWVAR 42
56550: PUSH
56551: LD_INT 5
56553: ST_TO_ADDR
56554: GO 56652
56556: LD_INT 30
56558: DOUBLE
56559: EQUAL
56560: IFTRUE 56564
56562: GO 56575
56564: POP
// bc_type := b_solar_power ; 31 :
56565: LD_ADDR_OWVAR 42
56569: PUSH
56570: LD_INT 27
56572: ST_TO_ADDR
56573: GO 56652
56575: LD_INT 31
56577: DOUBLE
56578: EQUAL
56579: IFTRUE 56583
56581: GO 56594
56583: POP
// bc_type := b_oil_power ; 32 :
56584: LD_ADDR_OWVAR 42
56588: PUSH
56589: LD_INT 26
56591: ST_TO_ADDR
56592: GO 56652
56594: LD_INT 32
56596: DOUBLE
56597: EQUAL
56598: IFTRUE 56602
56600: GO 56613
56602: POP
// bc_type := b_siberite_power ; 33 :
56603: LD_ADDR_OWVAR 42
56607: PUSH
56608: LD_INT 28
56610: ST_TO_ADDR
56611: GO 56652
56613: LD_INT 33
56615: DOUBLE
56616: EQUAL
56617: IFTRUE 56621
56619: GO 56632
56621: POP
// bc_type := b_oil_mine ; 34 :
56622: LD_ADDR_OWVAR 42
56626: PUSH
56627: LD_INT 29
56629: ST_TO_ADDR
56630: GO 56652
56632: LD_INT 34
56634: DOUBLE
56635: EQUAL
56636: IFTRUE 56640
56638: GO 56651
56640: POP
// bc_type := b_siberite_mine ; end ;
56641: LD_ADDR_OWVAR 42
56645: PUSH
56646: LD_INT 30
56648: ST_TO_ADDR
56649: GO 56652
56651: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56652: LD_ADDR_VAR 0 8
56656: PUSH
56657: LD_VAR 0 5
56661: PPUSH
56662: LD_VAR 0 6
56666: PPUSH
56667: LD_VAR 0 3
56671: PPUSH
56672: CALL_OW 47
56676: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56677: LD_OWVAR 42
56681: PUSH
56682: LD_INT 32
56684: PUSH
56685: LD_INT 33
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: IN
56692: IFFALSE 56708
// PlaceWeaponTurret ( b , weapon ) ;
56694: LD_VAR 0 8
56698: PPUSH
56699: LD_VAR 0 4
56703: PPUSH
56704: CALL_OW 431
// end ;
56708: LD_VAR 0 7
56712: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56713: LD_INT 0
56715: PPUSH
56716: PPUSH
56717: PPUSH
56718: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56719: LD_ADDR_VAR 0 4
56723: PUSH
56724: LD_INT 22
56726: PUSH
56727: LD_OWVAR 2
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: PUSH
56736: LD_INT 2
56738: PUSH
56739: LD_INT 30
56741: PUSH
56742: LD_INT 0
56744: PUSH
56745: EMPTY
56746: LIST
56747: LIST
56748: PUSH
56749: LD_INT 30
56751: PUSH
56752: LD_INT 1
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: PUSH
56759: EMPTY
56760: LIST
56761: LIST
56762: LIST
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: PPUSH
56768: CALL_OW 69
56772: ST_TO_ADDR
// if not tmp then
56773: LD_VAR 0 4
56777: NOT
56778: IFFALSE 56782
// exit ;
56780: GO 56841
// for i in tmp do
56782: LD_ADDR_VAR 0 2
56786: PUSH
56787: LD_VAR 0 4
56791: PUSH
56792: FOR_IN
56793: IFFALSE 56839
// for j = 1 to 3 do
56795: LD_ADDR_VAR 0 3
56799: PUSH
56800: DOUBLE
56801: LD_INT 1
56803: DEC
56804: ST_TO_ADDR
56805: LD_INT 3
56807: PUSH
56808: FOR_TO
56809: IFFALSE 56835
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56811: LD_VAR 0 2
56815: PPUSH
56816: CALL_OW 274
56820: PPUSH
56821: LD_VAR 0 3
56825: PPUSH
56826: LD_INT 99999
56828: PPUSH
56829: CALL_OW 277
56833: GO 56808
56835: POP
56836: POP
56837: GO 56792
56839: POP
56840: POP
// end ;
56841: LD_VAR 0 1
56845: RET
// export function hHackSetLevel10 ; var i , j ; begin
56846: LD_INT 0
56848: PPUSH
56849: PPUSH
56850: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56851: LD_ADDR_VAR 0 2
56855: PUSH
56856: LD_INT 21
56858: PUSH
56859: LD_INT 1
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: PPUSH
56866: CALL_OW 69
56870: PUSH
56871: FOR_IN
56872: IFFALSE 56924
// if IsSelected ( i ) then
56874: LD_VAR 0 2
56878: PPUSH
56879: CALL_OW 306
56883: IFFALSE 56922
// begin for j := 1 to 4 do
56885: LD_ADDR_VAR 0 3
56889: PUSH
56890: DOUBLE
56891: LD_INT 1
56893: DEC
56894: ST_TO_ADDR
56895: LD_INT 4
56897: PUSH
56898: FOR_TO
56899: IFFALSE 56920
// SetSkill ( i , j , 10 ) ;
56901: LD_VAR 0 2
56905: PPUSH
56906: LD_VAR 0 3
56910: PPUSH
56911: LD_INT 10
56913: PPUSH
56914: CALL_OW 237
56918: GO 56898
56920: POP
56921: POP
// end ;
56922: GO 56871
56924: POP
56925: POP
// end ;
56926: LD_VAR 0 1
56930: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56931: LD_INT 0
56933: PPUSH
56934: PPUSH
56935: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56936: LD_ADDR_VAR 0 2
56940: PUSH
56941: LD_INT 22
56943: PUSH
56944: LD_OWVAR 2
56948: PUSH
56949: EMPTY
56950: LIST
56951: LIST
56952: PUSH
56953: LD_INT 21
56955: PUSH
56956: LD_INT 1
56958: PUSH
56959: EMPTY
56960: LIST
56961: LIST
56962: PUSH
56963: EMPTY
56964: LIST
56965: LIST
56966: PPUSH
56967: CALL_OW 69
56971: PUSH
56972: FOR_IN
56973: IFFALSE 57014
// begin for j := 1 to 4 do
56975: LD_ADDR_VAR 0 3
56979: PUSH
56980: DOUBLE
56981: LD_INT 1
56983: DEC
56984: ST_TO_ADDR
56985: LD_INT 4
56987: PUSH
56988: FOR_TO
56989: IFFALSE 57010
// SetSkill ( i , j , 10 ) ;
56991: LD_VAR 0 2
56995: PPUSH
56996: LD_VAR 0 3
57000: PPUSH
57001: LD_INT 10
57003: PPUSH
57004: CALL_OW 237
57008: GO 56988
57010: POP
57011: POP
// end ;
57012: GO 56972
57014: POP
57015: POP
// end ;
57016: LD_VAR 0 1
57020: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57021: LD_INT 0
57023: PPUSH
// uc_side := your_side ;
57024: LD_ADDR_OWVAR 20
57028: PUSH
57029: LD_OWVAR 2
57033: ST_TO_ADDR
// uc_nation := nation ;
57034: LD_ADDR_OWVAR 21
57038: PUSH
57039: LD_VAR 0 1
57043: ST_TO_ADDR
// InitHc ;
57044: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57048: LD_INT 0
57050: PPUSH
57051: LD_VAR 0 2
57055: PPUSH
57056: LD_VAR 0 3
57060: PPUSH
57061: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57065: LD_VAR 0 4
57069: PPUSH
57070: LD_VAR 0 5
57074: PPUSH
57075: CALL_OW 428
57079: PUSH
57080: LD_INT 0
57082: EQUAL
57083: IFFALSE 57107
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57085: CALL_OW 44
57089: PPUSH
57090: LD_VAR 0 4
57094: PPUSH
57095: LD_VAR 0 5
57099: PPUSH
57100: LD_INT 1
57102: PPUSH
57103: CALL_OW 48
// end ;
57107: LD_VAR 0 6
57111: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57112: LD_INT 0
57114: PPUSH
57115: PPUSH
// uc_side := your_side ;
57116: LD_ADDR_OWVAR 20
57120: PUSH
57121: LD_OWVAR 2
57125: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57126: LD_VAR 0 1
57130: PUSH
57131: LD_INT 1
57133: PUSH
57134: LD_INT 2
57136: PUSH
57137: LD_INT 3
57139: PUSH
57140: LD_INT 4
57142: PUSH
57143: LD_INT 5
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: LIST
57150: LIST
57151: LIST
57152: IN
57153: IFFALSE 57165
// uc_nation := nation_american else
57155: LD_ADDR_OWVAR 21
57159: PUSH
57160: LD_INT 1
57162: ST_TO_ADDR
57163: GO 57208
// if chassis in [ 11 , 12 , 13 , 14 ] then
57165: LD_VAR 0 1
57169: PUSH
57170: LD_INT 11
57172: PUSH
57173: LD_INT 12
57175: PUSH
57176: LD_INT 13
57178: PUSH
57179: LD_INT 14
57181: PUSH
57182: EMPTY
57183: LIST
57184: LIST
57185: LIST
57186: LIST
57187: IN
57188: IFFALSE 57200
// uc_nation := nation_arabian else
57190: LD_ADDR_OWVAR 21
57194: PUSH
57195: LD_INT 2
57197: ST_TO_ADDR
57198: GO 57208
// uc_nation := nation_russian ;
57200: LD_ADDR_OWVAR 21
57204: PUSH
57205: LD_INT 3
57207: ST_TO_ADDR
// vc_chassis := chassis ;
57208: LD_ADDR_OWVAR 37
57212: PUSH
57213: LD_VAR 0 1
57217: ST_TO_ADDR
// vc_engine := engine ;
57218: LD_ADDR_OWVAR 39
57222: PUSH
57223: LD_VAR 0 2
57227: ST_TO_ADDR
// vc_control := control ;
57228: LD_ADDR_OWVAR 38
57232: PUSH
57233: LD_VAR 0 3
57237: ST_TO_ADDR
// vc_weapon := weapon ;
57238: LD_ADDR_OWVAR 40
57242: PUSH
57243: LD_VAR 0 4
57247: ST_TO_ADDR
// un := CreateVehicle ;
57248: LD_ADDR_VAR 0 8
57252: PUSH
57253: CALL_OW 45
57257: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57258: LD_VAR 0 8
57262: PPUSH
57263: LD_INT 0
57265: PPUSH
57266: LD_INT 5
57268: PPUSH
57269: CALL_OW 12
57273: PPUSH
57274: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57278: LD_VAR 0 8
57282: PPUSH
57283: LD_VAR 0 5
57287: PPUSH
57288: LD_VAR 0 6
57292: PPUSH
57293: LD_INT 1
57295: PPUSH
57296: CALL_OW 48
// end ;
57300: LD_VAR 0 7
57304: RET
// export hInvincible ; every 1 do
57305: GO 57307
57307: DISABLE
// hInvincible := [ ] ;
57308: LD_ADDR_EXP 131
57312: PUSH
57313: EMPTY
57314: ST_TO_ADDR
57315: END
// every 10 do var i ;
57316: GO 57318
57318: DISABLE
57319: LD_INT 0
57321: PPUSH
// begin enable ;
57322: ENABLE
// if not hInvincible then
57323: LD_EXP 131
57327: NOT
57328: IFFALSE 57332
// exit ;
57330: GO 57376
// for i in hInvincible do
57332: LD_ADDR_VAR 0 1
57336: PUSH
57337: LD_EXP 131
57341: PUSH
57342: FOR_IN
57343: IFFALSE 57374
// if GetLives ( i ) < 1000 then
57345: LD_VAR 0 1
57349: PPUSH
57350: CALL_OW 256
57354: PUSH
57355: LD_INT 1000
57357: LESS
57358: IFFALSE 57372
// SetLives ( i , 1000 ) ;
57360: LD_VAR 0 1
57364: PPUSH
57365: LD_INT 1000
57367: PPUSH
57368: CALL_OW 234
57372: GO 57342
57374: POP
57375: POP
// end ;
57376: PPOPN 1
57378: END
// export function hHackInvincible ; var i ; begin
57379: LD_INT 0
57381: PPUSH
57382: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57383: LD_ADDR_VAR 0 2
57387: PUSH
57388: LD_INT 2
57390: PUSH
57391: LD_INT 21
57393: PUSH
57394: LD_INT 1
57396: PUSH
57397: EMPTY
57398: LIST
57399: LIST
57400: PUSH
57401: LD_INT 21
57403: PUSH
57404: LD_INT 2
57406: PUSH
57407: EMPTY
57408: LIST
57409: LIST
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: LIST
57415: PPUSH
57416: CALL_OW 69
57420: PUSH
57421: FOR_IN
57422: IFFALSE 57483
// if IsSelected ( i ) then
57424: LD_VAR 0 2
57428: PPUSH
57429: CALL_OW 306
57433: IFFALSE 57481
// begin if i in hInvincible then
57435: LD_VAR 0 2
57439: PUSH
57440: LD_EXP 131
57444: IN
57445: IFFALSE 57465
// hInvincible := hInvincible diff i else
57447: LD_ADDR_EXP 131
57451: PUSH
57452: LD_EXP 131
57456: PUSH
57457: LD_VAR 0 2
57461: DIFF
57462: ST_TO_ADDR
57463: GO 57481
// hInvincible := hInvincible union i ;
57465: LD_ADDR_EXP 131
57469: PUSH
57470: LD_EXP 131
57474: PUSH
57475: LD_VAR 0 2
57479: UNION
57480: ST_TO_ADDR
// end ;
57481: GO 57421
57483: POP
57484: POP
// end ;
57485: LD_VAR 0 1
57489: RET
// export function hHackInvisible ; var i , j ; begin
57490: LD_INT 0
57492: PPUSH
57493: PPUSH
57494: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57495: LD_ADDR_VAR 0 2
57499: PUSH
57500: LD_INT 21
57502: PUSH
57503: LD_INT 1
57505: PUSH
57506: EMPTY
57507: LIST
57508: LIST
57509: PPUSH
57510: CALL_OW 69
57514: PUSH
57515: FOR_IN
57516: IFFALSE 57540
// if IsSelected ( i ) then
57518: LD_VAR 0 2
57522: PPUSH
57523: CALL_OW 306
57527: IFFALSE 57538
// ComForceInvisible ( i ) ;
57529: LD_VAR 0 2
57533: PPUSH
57534: CALL_OW 496
57538: GO 57515
57540: POP
57541: POP
// end ;
57542: LD_VAR 0 1
57546: RET
// export function hHackChangeYourSide ; begin
57547: LD_INT 0
57549: PPUSH
// if your_side = 8 then
57550: LD_OWVAR 2
57554: PUSH
57555: LD_INT 8
57557: EQUAL
57558: IFFALSE 57570
// your_side := 0 else
57560: LD_ADDR_OWVAR 2
57564: PUSH
57565: LD_INT 0
57567: ST_TO_ADDR
57568: GO 57584
// your_side := your_side + 1 ;
57570: LD_ADDR_OWVAR 2
57574: PUSH
57575: LD_OWVAR 2
57579: PUSH
57580: LD_INT 1
57582: PLUS
57583: ST_TO_ADDR
// end ;
57584: LD_VAR 0 1
57588: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57589: LD_INT 0
57591: PPUSH
57592: PPUSH
57593: PPUSH
// for i in all_units do
57594: LD_ADDR_VAR 0 2
57598: PUSH
57599: LD_OWVAR 3
57603: PUSH
57604: FOR_IN
57605: IFFALSE 57683
// if IsSelected ( i ) then
57607: LD_VAR 0 2
57611: PPUSH
57612: CALL_OW 306
57616: IFFALSE 57681
// begin j := GetSide ( i ) ;
57618: LD_ADDR_VAR 0 3
57622: PUSH
57623: LD_VAR 0 2
57627: PPUSH
57628: CALL_OW 255
57632: ST_TO_ADDR
// if j = 8 then
57633: LD_VAR 0 3
57637: PUSH
57638: LD_INT 8
57640: EQUAL
57641: IFFALSE 57653
// j := 0 else
57643: LD_ADDR_VAR 0 3
57647: PUSH
57648: LD_INT 0
57650: ST_TO_ADDR
57651: GO 57667
// j := j + 1 ;
57653: LD_ADDR_VAR 0 3
57657: PUSH
57658: LD_VAR 0 3
57662: PUSH
57663: LD_INT 1
57665: PLUS
57666: ST_TO_ADDR
// SetSide ( i , j ) ;
57667: LD_VAR 0 2
57671: PPUSH
57672: LD_VAR 0 3
57676: PPUSH
57677: CALL_OW 235
// end ;
57681: GO 57604
57683: POP
57684: POP
// end ;
57685: LD_VAR 0 1
57689: RET
// export function hHackFog ; begin
57690: LD_INT 0
57692: PPUSH
// FogOff ( true ) ;
57693: LD_INT 1
57695: PPUSH
57696: CALL_OW 344
// end ;
57700: LD_VAR 0 1
57704: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57705: LD_INT 0
57707: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57708: LD_VAR 0 1
57712: PPUSH
57713: LD_VAR 0 2
57717: PPUSH
57718: LD_VAR 0 3
57722: PPUSH
57723: LD_INT 1
57725: PPUSH
57726: LD_INT 1
57728: PPUSH
57729: CALL_OW 483
// CenterOnXY ( x , y ) ;
57733: LD_VAR 0 2
57737: PPUSH
57738: LD_VAR 0 3
57742: PPUSH
57743: CALL_OW 84
// end ;
57747: LD_VAR 0 4
57751: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57752: LD_INT 0
57754: PPUSH
57755: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57756: LD_VAR 0 1
57760: NOT
57761: PUSH
57762: LD_VAR 0 2
57766: PPUSH
57767: LD_VAR 0 3
57771: PPUSH
57772: CALL_OW 488
57776: NOT
57777: OR
57778: PUSH
57779: LD_VAR 0 1
57783: PPUSH
57784: CALL_OW 266
57788: PUSH
57789: LD_INT 3
57791: NONEQUAL
57792: PUSH
57793: LD_VAR 0 1
57797: PPUSH
57798: CALL_OW 247
57802: PUSH
57803: LD_INT 1
57805: EQUAL
57806: NOT
57807: AND
57808: OR
57809: IFFALSE 57813
// exit ;
57811: GO 57962
// if GetType ( factory ) = unit_human then
57813: LD_VAR 0 1
57817: PPUSH
57818: CALL_OW 247
57822: PUSH
57823: LD_INT 1
57825: EQUAL
57826: IFFALSE 57843
// factory := IsInUnit ( factory ) ;
57828: LD_ADDR_VAR 0 1
57832: PUSH
57833: LD_VAR 0 1
57837: PPUSH
57838: CALL_OW 310
57842: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57843: LD_VAR 0 1
57847: PPUSH
57848: CALL_OW 266
57852: PUSH
57853: LD_INT 3
57855: NONEQUAL
57856: IFFALSE 57860
// exit ;
57858: GO 57962
// if HexInfo ( x , y ) = factory then
57860: LD_VAR 0 2
57864: PPUSH
57865: LD_VAR 0 3
57869: PPUSH
57870: CALL_OW 428
57874: PUSH
57875: LD_VAR 0 1
57879: EQUAL
57880: IFFALSE 57907
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57882: LD_ADDR_EXP 132
57886: PUSH
57887: LD_EXP 132
57891: PPUSH
57892: LD_VAR 0 1
57896: PPUSH
57897: LD_INT 0
57899: PPUSH
57900: CALL_OW 1
57904: ST_TO_ADDR
57905: GO 57958
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57907: LD_ADDR_EXP 132
57911: PUSH
57912: LD_EXP 132
57916: PPUSH
57917: LD_VAR 0 1
57921: PPUSH
57922: LD_VAR 0 1
57926: PPUSH
57927: CALL_OW 255
57931: PUSH
57932: LD_VAR 0 1
57936: PUSH
57937: LD_VAR 0 2
57941: PUSH
57942: LD_VAR 0 3
57946: PUSH
57947: EMPTY
57948: LIST
57949: LIST
57950: LIST
57951: LIST
57952: PPUSH
57953: CALL_OW 1
57957: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57958: CALL 57967 0 0
// end ;
57962: LD_VAR 0 4
57966: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57967: LD_INT 0
57969: PPUSH
57970: PPUSH
57971: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57972: LD_STRING resetFactoryWaypoint();
57974: PPUSH
57975: CALL_OW 559
// if factoryWaypoints then
57979: LD_EXP 132
57983: IFFALSE 58109
// begin list := PrepareArray ( factoryWaypoints ) ;
57985: LD_ADDR_VAR 0 3
57989: PUSH
57990: LD_EXP 132
57994: PPUSH
57995: CALL 104578 0 1
57999: ST_TO_ADDR
// for i := 1 to list do
58000: LD_ADDR_VAR 0 2
58004: PUSH
58005: DOUBLE
58006: LD_INT 1
58008: DEC
58009: ST_TO_ADDR
58010: LD_VAR 0 3
58014: PUSH
58015: FOR_TO
58016: IFFALSE 58107
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58018: LD_STRING setFactoryWaypointXY(
58020: PUSH
58021: LD_VAR 0 3
58025: PUSH
58026: LD_VAR 0 2
58030: ARRAY
58031: PUSH
58032: LD_INT 1
58034: ARRAY
58035: STR
58036: PUSH
58037: LD_STRING ,
58039: STR
58040: PUSH
58041: LD_VAR 0 3
58045: PUSH
58046: LD_VAR 0 2
58050: ARRAY
58051: PUSH
58052: LD_INT 2
58054: ARRAY
58055: STR
58056: PUSH
58057: LD_STRING ,
58059: STR
58060: PUSH
58061: LD_VAR 0 3
58065: PUSH
58066: LD_VAR 0 2
58070: ARRAY
58071: PUSH
58072: LD_INT 3
58074: ARRAY
58075: STR
58076: PUSH
58077: LD_STRING ,
58079: STR
58080: PUSH
58081: LD_VAR 0 3
58085: PUSH
58086: LD_VAR 0 2
58090: ARRAY
58091: PUSH
58092: LD_INT 4
58094: ARRAY
58095: STR
58096: PUSH
58097: LD_STRING )
58099: STR
58100: PPUSH
58101: CALL_OW 559
58105: GO 58015
58107: POP
58108: POP
// end ; end ;
58109: LD_VAR 0 1
58113: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
58114: LD_INT 0
58116: PPUSH
// if HexInfo ( x , y ) = warehouse then
58117: LD_VAR 0 2
58121: PPUSH
58122: LD_VAR 0 3
58126: PPUSH
58127: CALL_OW 428
58131: PUSH
58132: LD_VAR 0 1
58136: EQUAL
58137: IFFALSE 58164
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58139: LD_ADDR_EXP 133
58143: PUSH
58144: LD_EXP 133
58148: PPUSH
58149: LD_VAR 0 1
58153: PPUSH
58154: LD_INT 0
58156: PPUSH
58157: CALL_OW 1
58161: ST_TO_ADDR
58162: GO 58215
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58164: LD_ADDR_EXP 133
58168: PUSH
58169: LD_EXP 133
58173: PPUSH
58174: LD_VAR 0 1
58178: PPUSH
58179: LD_VAR 0 1
58183: PPUSH
58184: CALL_OW 255
58188: PUSH
58189: LD_VAR 0 1
58193: PUSH
58194: LD_VAR 0 2
58198: PUSH
58199: LD_VAR 0 3
58203: PUSH
58204: EMPTY
58205: LIST
58206: LIST
58207: LIST
58208: LIST
58209: PPUSH
58210: CALL_OW 1
58214: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58215: CALL 58224 0 0
// end ;
58219: LD_VAR 0 4
58223: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58224: LD_INT 0
58226: PPUSH
58227: PPUSH
58228: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58229: LD_STRING resetWarehouseGatheringPoints();
58231: PPUSH
58232: CALL_OW 559
// if warehouseGatheringPoints then
58236: LD_EXP 133
58240: IFFALSE 58366
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58242: LD_ADDR_VAR 0 3
58246: PUSH
58247: LD_EXP 133
58251: PPUSH
58252: CALL 104578 0 1
58256: ST_TO_ADDR
// for i := 1 to list do
58257: LD_ADDR_VAR 0 2
58261: PUSH
58262: DOUBLE
58263: LD_INT 1
58265: DEC
58266: ST_TO_ADDR
58267: LD_VAR 0 3
58271: PUSH
58272: FOR_TO
58273: IFFALSE 58364
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58275: LD_STRING setWarehouseGatheringPointXY(
58277: PUSH
58278: LD_VAR 0 3
58282: PUSH
58283: LD_VAR 0 2
58287: ARRAY
58288: PUSH
58289: LD_INT 1
58291: ARRAY
58292: STR
58293: PUSH
58294: LD_STRING ,
58296: STR
58297: PUSH
58298: LD_VAR 0 3
58302: PUSH
58303: LD_VAR 0 2
58307: ARRAY
58308: PUSH
58309: LD_INT 2
58311: ARRAY
58312: STR
58313: PUSH
58314: LD_STRING ,
58316: STR
58317: PUSH
58318: LD_VAR 0 3
58322: PUSH
58323: LD_VAR 0 2
58327: ARRAY
58328: PUSH
58329: LD_INT 3
58331: ARRAY
58332: STR
58333: PUSH
58334: LD_STRING ,
58336: STR
58337: PUSH
58338: LD_VAR 0 3
58342: PUSH
58343: LD_VAR 0 2
58347: ARRAY
58348: PUSH
58349: LD_INT 4
58351: ARRAY
58352: STR
58353: PUSH
58354: LD_STRING )
58356: STR
58357: PPUSH
58358: CALL_OW 559
58362: GO 58272
58364: POP
58365: POP
// end ; end ;
58366: LD_VAR 0 1
58370: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58371: LD_EXP 133
58375: IFFALSE 59060
58377: GO 58379
58379: DISABLE
58380: LD_INT 0
58382: PPUSH
58383: PPUSH
58384: PPUSH
58385: PPUSH
58386: PPUSH
58387: PPUSH
58388: PPUSH
58389: PPUSH
58390: PPUSH
// begin enable ;
58391: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58392: LD_ADDR_VAR 0 3
58396: PUSH
58397: LD_EXP 133
58401: PPUSH
58402: CALL 104578 0 1
58406: ST_TO_ADDR
// if not list then
58407: LD_VAR 0 3
58411: NOT
58412: IFFALSE 58416
// exit ;
58414: GO 59060
// for i := 1 to list do
58416: LD_ADDR_VAR 0 1
58420: PUSH
58421: DOUBLE
58422: LD_INT 1
58424: DEC
58425: ST_TO_ADDR
58426: LD_VAR 0 3
58430: PUSH
58431: FOR_TO
58432: IFFALSE 59058
// begin depot := list [ i ] [ 2 ] ;
58434: LD_ADDR_VAR 0 8
58438: PUSH
58439: LD_VAR 0 3
58443: PUSH
58444: LD_VAR 0 1
58448: ARRAY
58449: PUSH
58450: LD_INT 2
58452: ARRAY
58453: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58454: LD_ADDR_VAR 0 5
58458: PUSH
58459: LD_VAR 0 3
58463: PUSH
58464: LD_VAR 0 1
58468: ARRAY
58469: PUSH
58470: LD_INT 1
58472: ARRAY
58473: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58474: LD_VAR 0 8
58478: PPUSH
58479: CALL_OW 301
58483: PUSH
58484: LD_VAR 0 5
58488: PUSH
58489: LD_VAR 0 8
58493: PPUSH
58494: CALL_OW 255
58498: NONEQUAL
58499: OR
58500: IFFALSE 58529
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58502: LD_ADDR_EXP 133
58506: PUSH
58507: LD_EXP 133
58511: PPUSH
58512: LD_VAR 0 8
58516: PPUSH
58517: LD_INT 0
58519: PPUSH
58520: CALL_OW 1
58524: ST_TO_ADDR
// exit ;
58525: POP
58526: POP
58527: GO 59060
// end ; x := list [ i ] [ 3 ] ;
58529: LD_ADDR_VAR 0 6
58533: PUSH
58534: LD_VAR 0 3
58538: PUSH
58539: LD_VAR 0 1
58543: ARRAY
58544: PUSH
58545: LD_INT 3
58547: ARRAY
58548: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58549: LD_ADDR_VAR 0 7
58553: PUSH
58554: LD_VAR 0 3
58558: PUSH
58559: LD_VAR 0 1
58563: ARRAY
58564: PUSH
58565: LD_INT 4
58567: ARRAY
58568: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58569: LD_ADDR_VAR 0 9
58573: PUSH
58574: LD_VAR 0 6
58578: PPUSH
58579: LD_VAR 0 7
58583: PPUSH
58584: LD_INT 16
58586: PPUSH
58587: CALL 103166 0 3
58591: ST_TO_ADDR
// if not cratesNearbyPoint then
58592: LD_VAR 0 9
58596: NOT
58597: IFFALSE 58603
// exit ;
58599: POP
58600: POP
58601: GO 59060
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58603: LD_ADDR_VAR 0 4
58607: PUSH
58608: LD_INT 22
58610: PUSH
58611: LD_VAR 0 5
58615: PUSH
58616: EMPTY
58617: LIST
58618: LIST
58619: PUSH
58620: LD_INT 3
58622: PUSH
58623: LD_INT 60
58625: PUSH
58626: EMPTY
58627: LIST
58628: PUSH
58629: EMPTY
58630: LIST
58631: LIST
58632: PUSH
58633: LD_INT 91
58635: PUSH
58636: LD_VAR 0 8
58640: PUSH
58641: LD_INT 6
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: LIST
58648: PUSH
58649: LD_INT 2
58651: PUSH
58652: LD_INT 25
58654: PUSH
58655: LD_INT 2
58657: PUSH
58658: EMPTY
58659: LIST
58660: LIST
58661: PUSH
58662: LD_INT 25
58664: PUSH
58665: LD_INT 16
58667: PUSH
58668: EMPTY
58669: LIST
58670: LIST
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: LIST
58676: PUSH
58677: EMPTY
58678: LIST
58679: LIST
58680: LIST
58681: LIST
58682: PPUSH
58683: CALL_OW 69
58687: PUSH
58688: LD_VAR 0 8
58692: PPUSH
58693: CALL_OW 313
58697: PPUSH
58698: LD_INT 3
58700: PUSH
58701: LD_INT 60
58703: PUSH
58704: EMPTY
58705: LIST
58706: PUSH
58707: EMPTY
58708: LIST
58709: LIST
58710: PUSH
58711: LD_INT 2
58713: PUSH
58714: LD_INT 25
58716: PUSH
58717: LD_INT 2
58719: PUSH
58720: EMPTY
58721: LIST
58722: LIST
58723: PUSH
58724: LD_INT 25
58726: PUSH
58727: LD_INT 16
58729: PUSH
58730: EMPTY
58731: LIST
58732: LIST
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: LIST
58738: PUSH
58739: EMPTY
58740: LIST
58741: LIST
58742: PPUSH
58743: CALL_OW 72
58747: UNION
58748: ST_TO_ADDR
// if tmp then
58749: LD_VAR 0 4
58753: IFFALSE 58833
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58755: LD_ADDR_VAR 0 4
58759: PUSH
58760: LD_VAR 0 4
58764: PPUSH
58765: LD_INT 3
58767: PPUSH
58768: CALL 101135 0 2
58772: ST_TO_ADDR
// for j in tmp do
58773: LD_ADDR_VAR 0 2
58777: PUSH
58778: LD_VAR 0 4
58782: PUSH
58783: FOR_IN
58784: IFFALSE 58827
// begin if IsInUnit ( j ) then
58786: LD_VAR 0 2
58790: PPUSH
58791: CALL_OW 310
58795: IFFALSE 58806
// ComExit ( j ) ;
58797: LD_VAR 0 2
58801: PPUSH
58802: CALL 101218 0 1
// AddComCollect ( j , x , y ) ;
58806: LD_VAR 0 2
58810: PPUSH
58811: LD_VAR 0 6
58815: PPUSH
58816: LD_VAR 0 7
58820: PPUSH
58821: CALL_OW 177
// end ;
58825: GO 58783
58827: POP
58828: POP
// exit ;
58829: POP
58830: POP
58831: GO 59060
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58833: LD_ADDR_VAR 0 4
58837: PUSH
58838: LD_INT 22
58840: PUSH
58841: LD_VAR 0 5
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: PUSH
58850: LD_INT 91
58852: PUSH
58853: LD_VAR 0 8
58857: PUSH
58858: LD_INT 8
58860: PUSH
58861: EMPTY
58862: LIST
58863: LIST
58864: LIST
58865: PUSH
58866: LD_INT 2
58868: PUSH
58869: LD_INT 34
58871: PUSH
58872: LD_INT 12
58874: PUSH
58875: EMPTY
58876: LIST
58877: LIST
58878: PUSH
58879: LD_INT 34
58881: PUSH
58882: LD_INT 51
58884: PUSH
58885: EMPTY
58886: LIST
58887: LIST
58888: PUSH
58889: LD_INT 34
58891: PUSH
58892: LD_INT 32
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PUSH
58899: LD_INT 34
58901: PUSH
58902: LD_INT 89
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: LIST
58913: LIST
58914: LIST
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: LIST
58920: PPUSH
58921: CALL_OW 69
58925: ST_TO_ADDR
// if tmp then
58926: LD_VAR 0 4
58930: IFFALSE 59056
// begin for j in tmp do
58932: LD_ADDR_VAR 0 2
58936: PUSH
58937: LD_VAR 0 4
58941: PUSH
58942: FOR_IN
58943: IFFALSE 59054
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58945: LD_VAR 0 2
58949: PPUSH
58950: CALL_OW 262
58954: PUSH
58955: LD_INT 3
58957: EQUAL
58958: PUSH
58959: LD_VAR 0 2
58963: PPUSH
58964: CALL_OW 261
58968: PUSH
58969: LD_INT 20
58971: GREATER
58972: OR
58973: PUSH
58974: LD_VAR 0 2
58978: PPUSH
58979: CALL_OW 314
58983: NOT
58984: AND
58985: PUSH
58986: LD_VAR 0 2
58990: PPUSH
58991: CALL_OW 263
58995: PUSH
58996: LD_INT 1
58998: NONEQUAL
58999: PUSH
59000: LD_VAR 0 2
59004: PPUSH
59005: CALL_OW 311
59009: OR
59010: AND
59011: IFFALSE 59052
// begin ComCollect ( j , x , y ) ;
59013: LD_VAR 0 2
59017: PPUSH
59018: LD_VAR 0 6
59022: PPUSH
59023: LD_VAR 0 7
59027: PPUSH
59028: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
59032: LD_VAR 0 2
59036: PPUSH
59037: LD_VAR 0 8
59041: PPUSH
59042: CALL_OW 172
// exit ;
59046: POP
59047: POP
59048: POP
59049: POP
59050: GO 59060
// end ;
59052: GO 58942
59054: POP
59055: POP
// end ; end ;
59056: GO 58431
59058: POP
59059: POP
// end ; end_of_file
59060: PPOPN 9
59062: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59063: LD_INT 0
59065: PPUSH
59066: PPUSH
59067: PPUSH
59068: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59069: LD_VAR 0 1
59073: PPUSH
59074: CALL_OW 264
59078: PUSH
59079: LD_INT 91
59081: EQUAL
59082: IFFALSE 59154
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59084: LD_INT 68
59086: PPUSH
59087: LD_VAR 0 1
59091: PPUSH
59092: CALL_OW 255
59096: PPUSH
59097: CALL_OW 321
59101: PUSH
59102: LD_INT 2
59104: EQUAL
59105: IFFALSE 59117
// eff := 70 else
59107: LD_ADDR_VAR 0 4
59111: PUSH
59112: LD_INT 70
59114: ST_TO_ADDR
59115: GO 59125
// eff := 30 ;
59117: LD_ADDR_VAR 0 4
59121: PUSH
59122: LD_INT 30
59124: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59125: LD_VAR 0 1
59129: PPUSH
59130: CALL_OW 250
59134: PPUSH
59135: LD_VAR 0 1
59139: PPUSH
59140: CALL_OW 251
59144: PPUSH
59145: LD_VAR 0 4
59149: PPUSH
59150: CALL_OW 495
// end ; end ;
59154: LD_VAR 0 2
59158: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59159: LD_INT 0
59161: PPUSH
// end ;
59162: LD_VAR 0 4
59166: RET
// export function SOS_Command ( cmd ) ; begin
59167: LD_INT 0
59169: PPUSH
// end ;
59170: LD_VAR 0 2
59174: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59175: LD_INT 0
59177: PPUSH
// end ;
59178: LD_VAR 0 6
59182: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59183: LD_INT 0
59185: PPUSH
59186: PPUSH
// if not vehicle or not factory then
59187: LD_VAR 0 1
59191: NOT
59192: PUSH
59193: LD_VAR 0 2
59197: NOT
59198: OR
59199: IFFALSE 59203
// exit ;
59201: GO 59434
// if factoryWaypoints >= factory then
59203: LD_EXP 132
59207: PUSH
59208: LD_VAR 0 2
59212: GREATEREQUAL
59213: IFFALSE 59434
// if factoryWaypoints [ factory ] then
59215: LD_EXP 132
59219: PUSH
59220: LD_VAR 0 2
59224: ARRAY
59225: IFFALSE 59434
// begin if GetControl ( vehicle ) = control_manual then
59227: LD_VAR 0 1
59231: PPUSH
59232: CALL_OW 263
59236: PUSH
59237: LD_INT 1
59239: EQUAL
59240: IFFALSE 59321
// begin driver := IsDrivenBy ( vehicle ) ;
59242: LD_ADDR_VAR 0 4
59246: PUSH
59247: LD_VAR 0 1
59251: PPUSH
59252: CALL_OW 311
59256: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59257: LD_VAR 0 4
59261: PPUSH
59262: LD_EXP 132
59266: PUSH
59267: LD_VAR 0 2
59271: ARRAY
59272: PUSH
59273: LD_INT 3
59275: ARRAY
59276: PPUSH
59277: LD_EXP 132
59281: PUSH
59282: LD_VAR 0 2
59286: ARRAY
59287: PUSH
59288: LD_INT 4
59290: ARRAY
59291: PPUSH
59292: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59296: LD_VAR 0 4
59300: PPUSH
59301: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59305: LD_VAR 0 4
59309: PPUSH
59310: LD_VAR 0 2
59314: PPUSH
59315: CALL_OW 180
// end else
59319: GO 59434
// if GetControl ( vehicle ) = control_remote then
59321: LD_VAR 0 1
59325: PPUSH
59326: CALL_OW 263
59330: PUSH
59331: LD_INT 2
59333: EQUAL
59334: IFFALSE 59395
// begin wait ( 0 0$2 ) ;
59336: LD_INT 70
59338: PPUSH
59339: CALL_OW 67
// if Connect ( vehicle ) then
59343: LD_VAR 0 1
59347: PPUSH
59348: CALL 71458 0 1
59352: IFFALSE 59393
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59354: LD_VAR 0 1
59358: PPUSH
59359: LD_EXP 132
59363: PUSH
59364: LD_VAR 0 2
59368: ARRAY
59369: PUSH
59370: LD_INT 3
59372: ARRAY
59373: PPUSH
59374: LD_EXP 132
59378: PUSH
59379: LD_VAR 0 2
59383: ARRAY
59384: PUSH
59385: LD_INT 4
59387: ARRAY
59388: PPUSH
59389: CALL_OW 171
// end else
59393: GO 59434
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59395: LD_VAR 0 1
59399: PPUSH
59400: LD_EXP 132
59404: PUSH
59405: LD_VAR 0 2
59409: ARRAY
59410: PUSH
59411: LD_INT 3
59413: ARRAY
59414: PPUSH
59415: LD_EXP 132
59419: PUSH
59420: LD_VAR 0 2
59424: ARRAY
59425: PUSH
59426: LD_INT 4
59428: ARRAY
59429: PPUSH
59430: CALL_OW 171
// end ; end ;
59434: LD_VAR 0 3
59438: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59439: LD_INT 0
59441: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59442: LD_VAR 0 1
59446: PUSH
59447: LD_INT 250
59449: EQUAL
59450: PUSH
59451: LD_VAR 0 2
59455: PPUSH
59456: CALL_OW 264
59460: PUSH
59461: LD_INT 81
59463: EQUAL
59464: AND
59465: IFFALSE 59486
// MinerPlaceMine ( unit , x , y ) ;
59467: LD_VAR 0 2
59471: PPUSH
59472: LD_VAR 0 4
59476: PPUSH
59477: LD_VAR 0 5
59481: PPUSH
59482: CALL 61871 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59486: LD_VAR 0 1
59490: PUSH
59491: LD_INT 251
59493: EQUAL
59494: PUSH
59495: LD_VAR 0 2
59499: PPUSH
59500: CALL_OW 264
59504: PUSH
59505: LD_INT 81
59507: EQUAL
59508: AND
59509: IFFALSE 59530
// MinerDetonateMine ( unit , x , y ) ;
59511: LD_VAR 0 2
59515: PPUSH
59516: LD_VAR 0 4
59520: PPUSH
59521: LD_VAR 0 5
59525: PPUSH
59526: CALL 62146 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59530: LD_VAR 0 1
59534: PUSH
59535: LD_INT 252
59537: EQUAL
59538: PUSH
59539: LD_VAR 0 2
59543: PPUSH
59544: CALL_OW 264
59548: PUSH
59549: LD_INT 81
59551: EQUAL
59552: AND
59553: IFFALSE 59574
// MinerCreateMinefield ( unit , x , y ) ;
59555: LD_VAR 0 2
59559: PPUSH
59560: LD_VAR 0 4
59564: PPUSH
59565: LD_VAR 0 5
59569: PPUSH
59570: CALL 62563 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59574: LD_VAR 0 1
59578: PUSH
59579: LD_INT 253
59581: EQUAL
59582: PUSH
59583: LD_VAR 0 2
59587: PPUSH
59588: CALL_OW 257
59592: PUSH
59593: LD_INT 5
59595: EQUAL
59596: AND
59597: IFFALSE 59618
// ComBinocular ( unit , x , y ) ;
59599: LD_VAR 0 2
59603: PPUSH
59604: LD_VAR 0 4
59608: PPUSH
59609: LD_VAR 0 5
59613: PPUSH
59614: CALL 62932 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59618: LD_VAR 0 1
59622: PUSH
59623: LD_INT 254
59625: EQUAL
59626: PUSH
59627: LD_VAR 0 2
59631: PPUSH
59632: CALL_OW 264
59636: PUSH
59637: LD_INT 99
59639: EQUAL
59640: AND
59641: PUSH
59642: LD_VAR 0 3
59646: PPUSH
59647: CALL_OW 263
59651: PUSH
59652: LD_INT 3
59654: EQUAL
59655: AND
59656: IFFALSE 59672
// HackDestroyVehicle ( unit , selectedUnit ) ;
59658: LD_VAR 0 2
59662: PPUSH
59663: LD_VAR 0 3
59667: PPUSH
59668: CALL 61235 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59672: LD_VAR 0 1
59676: PUSH
59677: LD_INT 255
59679: EQUAL
59680: PUSH
59681: LD_VAR 0 2
59685: PPUSH
59686: CALL_OW 264
59690: PUSH
59691: LD_INT 14
59693: PUSH
59694: LD_INT 53
59696: PUSH
59697: EMPTY
59698: LIST
59699: LIST
59700: IN
59701: AND
59702: PUSH
59703: LD_VAR 0 4
59707: PPUSH
59708: LD_VAR 0 5
59712: PPUSH
59713: CALL_OW 488
59717: AND
59718: IFFALSE 59742
// CutTreeXYR ( unit , x , y , 12 ) ;
59720: LD_VAR 0 2
59724: PPUSH
59725: LD_VAR 0 4
59729: PPUSH
59730: LD_VAR 0 5
59734: PPUSH
59735: LD_INT 12
59737: PPUSH
59738: CALL 59805 0 4
// if cmd = 256 then
59742: LD_VAR 0 1
59746: PUSH
59747: LD_INT 256
59749: EQUAL
59750: IFFALSE 59771
// SetFactoryWaypoint ( unit , x , y ) ;
59752: LD_VAR 0 2
59756: PPUSH
59757: LD_VAR 0 4
59761: PPUSH
59762: LD_VAR 0 5
59766: PPUSH
59767: CALL 57752 0 3
// if cmd = 257 then
59771: LD_VAR 0 1
59775: PUSH
59776: LD_INT 257
59778: EQUAL
59779: IFFALSE 59800
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59781: LD_VAR 0 2
59785: PPUSH
59786: LD_VAR 0 4
59790: PPUSH
59791: LD_VAR 0 5
59795: PPUSH
59796: CALL 58114 0 3
// end ;
59800: LD_VAR 0 6
59804: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59805: LD_INT 0
59807: PPUSH
59808: PPUSH
59809: PPUSH
59810: PPUSH
59811: PPUSH
59812: PPUSH
59813: PPUSH
59814: PPUSH
59815: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59816: LD_VAR 0 1
59820: NOT
59821: PUSH
59822: LD_VAR 0 2
59826: PPUSH
59827: LD_VAR 0 3
59831: PPUSH
59832: CALL_OW 488
59836: NOT
59837: OR
59838: PUSH
59839: LD_VAR 0 4
59843: NOT
59844: OR
59845: IFFALSE 59849
// exit ;
59847: GO 60189
// list := [ ] ;
59849: LD_ADDR_VAR 0 13
59853: PUSH
59854: EMPTY
59855: ST_TO_ADDR
// if x - r < 0 then
59856: LD_VAR 0 2
59860: PUSH
59861: LD_VAR 0 4
59865: MINUS
59866: PUSH
59867: LD_INT 0
59869: LESS
59870: IFFALSE 59882
// min_x := 0 else
59872: LD_ADDR_VAR 0 7
59876: PUSH
59877: LD_INT 0
59879: ST_TO_ADDR
59880: GO 59898
// min_x := x - r ;
59882: LD_ADDR_VAR 0 7
59886: PUSH
59887: LD_VAR 0 2
59891: PUSH
59892: LD_VAR 0 4
59896: MINUS
59897: ST_TO_ADDR
// if y - r < 0 then
59898: LD_VAR 0 3
59902: PUSH
59903: LD_VAR 0 4
59907: MINUS
59908: PUSH
59909: LD_INT 0
59911: LESS
59912: IFFALSE 59924
// min_y := 0 else
59914: LD_ADDR_VAR 0 8
59918: PUSH
59919: LD_INT 0
59921: ST_TO_ADDR
59922: GO 59940
// min_y := y - r ;
59924: LD_ADDR_VAR 0 8
59928: PUSH
59929: LD_VAR 0 3
59933: PUSH
59934: LD_VAR 0 4
59938: MINUS
59939: ST_TO_ADDR
// max_x := x + r ;
59940: LD_ADDR_VAR 0 9
59944: PUSH
59945: LD_VAR 0 2
59949: PUSH
59950: LD_VAR 0 4
59954: PLUS
59955: ST_TO_ADDR
// max_y := y + r ;
59956: LD_ADDR_VAR 0 10
59960: PUSH
59961: LD_VAR 0 3
59965: PUSH
59966: LD_VAR 0 4
59970: PLUS
59971: ST_TO_ADDR
// for _x = min_x to max_x do
59972: LD_ADDR_VAR 0 11
59976: PUSH
59977: DOUBLE
59978: LD_VAR 0 7
59982: DEC
59983: ST_TO_ADDR
59984: LD_VAR 0 9
59988: PUSH
59989: FOR_TO
59990: IFFALSE 60107
// for _y = min_y to max_y do
59992: LD_ADDR_VAR 0 12
59996: PUSH
59997: DOUBLE
59998: LD_VAR 0 8
60002: DEC
60003: ST_TO_ADDR
60004: LD_VAR 0 10
60008: PUSH
60009: FOR_TO
60010: IFFALSE 60103
// begin if not ValidHex ( _x , _y ) then
60012: LD_VAR 0 11
60016: PPUSH
60017: LD_VAR 0 12
60021: PPUSH
60022: CALL_OW 488
60026: NOT
60027: IFFALSE 60031
// continue ;
60029: GO 60009
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60031: LD_VAR 0 11
60035: PPUSH
60036: LD_VAR 0 12
60040: PPUSH
60041: CALL_OW 351
60045: PUSH
60046: LD_VAR 0 11
60050: PPUSH
60051: LD_VAR 0 12
60055: PPUSH
60056: CALL_OW 554
60060: AND
60061: IFFALSE 60101
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60063: LD_ADDR_VAR 0 13
60067: PUSH
60068: LD_VAR 0 13
60072: PPUSH
60073: LD_VAR 0 13
60077: PUSH
60078: LD_INT 1
60080: PLUS
60081: PPUSH
60082: LD_VAR 0 11
60086: PUSH
60087: LD_VAR 0 12
60091: PUSH
60092: EMPTY
60093: LIST
60094: LIST
60095: PPUSH
60096: CALL_OW 2
60100: ST_TO_ADDR
// end ;
60101: GO 60009
60103: POP
60104: POP
60105: GO 59989
60107: POP
60108: POP
// if not list then
60109: LD_VAR 0 13
60113: NOT
60114: IFFALSE 60118
// exit ;
60116: GO 60189
// for i in list do
60118: LD_ADDR_VAR 0 6
60122: PUSH
60123: LD_VAR 0 13
60127: PUSH
60128: FOR_IN
60129: IFFALSE 60187
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60131: LD_VAR 0 1
60135: PPUSH
60136: LD_STRING M
60138: PUSH
60139: LD_VAR 0 6
60143: PUSH
60144: LD_INT 1
60146: ARRAY
60147: PUSH
60148: LD_VAR 0 6
60152: PUSH
60153: LD_INT 2
60155: ARRAY
60156: PUSH
60157: LD_INT 0
60159: PUSH
60160: LD_INT 0
60162: PUSH
60163: LD_INT 0
60165: PUSH
60166: LD_INT 0
60168: PUSH
60169: EMPTY
60170: LIST
60171: LIST
60172: LIST
60173: LIST
60174: LIST
60175: LIST
60176: LIST
60177: PUSH
60178: EMPTY
60179: LIST
60180: PPUSH
60181: CALL_OW 447
60185: GO 60128
60187: POP
60188: POP
// end ;
60189: LD_VAR 0 5
60193: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60194: LD_EXP 135
60198: NOT
60199: IFFALSE 60249
60201: GO 60203
60203: DISABLE
// begin initHack := true ;
60204: LD_ADDR_EXP 135
60208: PUSH
60209: LD_INT 1
60211: ST_TO_ADDR
// hackTanks := [ ] ;
60212: LD_ADDR_EXP 136
60216: PUSH
60217: EMPTY
60218: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60219: LD_ADDR_EXP 137
60223: PUSH
60224: EMPTY
60225: ST_TO_ADDR
// hackLimit := 3 ;
60226: LD_ADDR_EXP 138
60230: PUSH
60231: LD_INT 3
60233: ST_TO_ADDR
// hackDist := 12 ;
60234: LD_ADDR_EXP 139
60238: PUSH
60239: LD_INT 12
60241: ST_TO_ADDR
// hackCounter := [ ] ;
60242: LD_ADDR_EXP 140
60246: PUSH
60247: EMPTY
60248: ST_TO_ADDR
// end ;
60249: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60250: LD_EXP 135
60254: PUSH
60255: LD_INT 34
60257: PUSH
60258: LD_INT 99
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: PPUSH
60265: CALL_OW 69
60269: AND
60270: IFFALSE 60523
60272: GO 60274
60274: DISABLE
60275: LD_INT 0
60277: PPUSH
60278: PPUSH
// begin enable ;
60279: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60280: LD_ADDR_VAR 0 1
60284: PUSH
60285: LD_INT 34
60287: PUSH
60288: LD_INT 99
60290: PUSH
60291: EMPTY
60292: LIST
60293: LIST
60294: PPUSH
60295: CALL_OW 69
60299: PUSH
60300: FOR_IN
60301: IFFALSE 60521
// begin if not i in hackTanks then
60303: LD_VAR 0 1
60307: PUSH
60308: LD_EXP 136
60312: IN
60313: NOT
60314: IFFALSE 60397
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60316: LD_ADDR_EXP 136
60320: PUSH
60321: LD_EXP 136
60325: PPUSH
60326: LD_EXP 136
60330: PUSH
60331: LD_INT 1
60333: PLUS
60334: PPUSH
60335: LD_VAR 0 1
60339: PPUSH
60340: CALL_OW 1
60344: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60345: LD_ADDR_EXP 137
60349: PUSH
60350: LD_EXP 137
60354: PPUSH
60355: LD_EXP 137
60359: PUSH
60360: LD_INT 1
60362: PLUS
60363: PPUSH
60364: EMPTY
60365: PPUSH
60366: CALL_OW 1
60370: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60371: LD_ADDR_EXP 140
60375: PUSH
60376: LD_EXP 140
60380: PPUSH
60381: LD_EXP 140
60385: PUSH
60386: LD_INT 1
60388: PLUS
60389: PPUSH
60390: EMPTY
60391: PPUSH
60392: CALL_OW 1
60396: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60397: LD_VAR 0 1
60401: PPUSH
60402: CALL_OW 302
60406: NOT
60407: IFFALSE 60420
// begin HackUnlinkAll ( i ) ;
60409: LD_VAR 0 1
60413: PPUSH
60414: CALL 60526 0 1
// continue ;
60418: GO 60300
// end ; HackCheckCapturedStatus ( i ) ;
60420: LD_VAR 0 1
60424: PPUSH
60425: CALL 60969 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60429: LD_ADDR_VAR 0 2
60433: PUSH
60434: LD_INT 81
60436: PUSH
60437: LD_VAR 0 1
60441: PPUSH
60442: CALL_OW 255
60446: PUSH
60447: EMPTY
60448: LIST
60449: LIST
60450: PUSH
60451: LD_INT 33
60453: PUSH
60454: LD_INT 3
60456: PUSH
60457: EMPTY
60458: LIST
60459: LIST
60460: PUSH
60461: LD_INT 91
60463: PUSH
60464: LD_VAR 0 1
60468: PUSH
60469: LD_EXP 139
60473: PUSH
60474: EMPTY
60475: LIST
60476: LIST
60477: LIST
60478: PUSH
60479: LD_INT 50
60481: PUSH
60482: EMPTY
60483: LIST
60484: PUSH
60485: EMPTY
60486: LIST
60487: LIST
60488: LIST
60489: LIST
60490: PPUSH
60491: CALL_OW 69
60495: ST_TO_ADDR
// if not tmp then
60496: LD_VAR 0 2
60500: NOT
60501: IFFALSE 60505
// continue ;
60503: GO 60300
// HackLink ( i , tmp ) ;
60505: LD_VAR 0 1
60509: PPUSH
60510: LD_VAR 0 2
60514: PPUSH
60515: CALL 60662 0 2
// end ;
60519: GO 60300
60521: POP
60522: POP
// end ;
60523: PPOPN 2
60525: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60526: LD_INT 0
60528: PPUSH
60529: PPUSH
60530: PPUSH
// if not hack in hackTanks then
60531: LD_VAR 0 1
60535: PUSH
60536: LD_EXP 136
60540: IN
60541: NOT
60542: IFFALSE 60546
// exit ;
60544: GO 60657
// index := GetElementIndex ( hackTanks , hack ) ;
60546: LD_ADDR_VAR 0 4
60550: PUSH
60551: LD_EXP 136
60555: PPUSH
60556: LD_VAR 0 1
60560: PPUSH
60561: CALL 68274 0 2
60565: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60566: LD_EXP 137
60570: PUSH
60571: LD_VAR 0 4
60575: ARRAY
60576: IFFALSE 60657
// begin for i in hackTanksCaptured [ index ] do
60578: LD_ADDR_VAR 0 3
60582: PUSH
60583: LD_EXP 137
60587: PUSH
60588: LD_VAR 0 4
60592: ARRAY
60593: PUSH
60594: FOR_IN
60595: IFFALSE 60621
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60597: LD_VAR 0 3
60601: PUSH
60602: LD_INT 1
60604: ARRAY
60605: PPUSH
60606: LD_VAR 0 3
60610: PUSH
60611: LD_INT 2
60613: ARRAY
60614: PPUSH
60615: CALL_OW 235
60619: GO 60594
60621: POP
60622: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60623: LD_ADDR_EXP 137
60627: PUSH
60628: LD_EXP 137
60632: PPUSH
60633: LD_VAR 0 4
60637: PPUSH
60638: EMPTY
60639: PPUSH
60640: CALL_OW 1
60644: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60645: LD_VAR 0 1
60649: PPUSH
60650: LD_INT 0
60652: PPUSH
60653: CALL_OW 505
// end ; end ;
60657: LD_VAR 0 2
60661: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60662: LD_INT 0
60664: PPUSH
60665: PPUSH
60666: PPUSH
// if not hack in hackTanks or not vehicles then
60667: LD_VAR 0 1
60671: PUSH
60672: LD_EXP 136
60676: IN
60677: NOT
60678: PUSH
60679: LD_VAR 0 2
60683: NOT
60684: OR
60685: IFFALSE 60689
// exit ;
60687: GO 60964
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60689: LD_ADDR_VAR 0 2
60693: PUSH
60694: LD_VAR 0 1
60698: PPUSH
60699: LD_VAR 0 2
60703: PPUSH
60704: LD_INT 1
60706: PPUSH
60707: LD_INT 1
60709: PPUSH
60710: CALL 68924 0 4
60714: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60715: LD_ADDR_VAR 0 5
60719: PUSH
60720: LD_EXP 136
60724: PPUSH
60725: LD_VAR 0 1
60729: PPUSH
60730: CALL 68274 0 2
60734: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60735: LD_EXP 137
60739: PUSH
60740: LD_VAR 0 5
60744: ARRAY
60745: PUSH
60746: LD_EXP 138
60750: LESS
60751: IFFALSE 60940
// begin for i := 1 to vehicles do
60753: LD_ADDR_VAR 0 4
60757: PUSH
60758: DOUBLE
60759: LD_INT 1
60761: DEC
60762: ST_TO_ADDR
60763: LD_VAR 0 2
60767: PUSH
60768: FOR_TO
60769: IFFALSE 60938
// begin if hackTanksCaptured [ index ] = hackLimit then
60771: LD_EXP 137
60775: PUSH
60776: LD_VAR 0 5
60780: ARRAY
60781: PUSH
60782: LD_EXP 138
60786: EQUAL
60787: IFFALSE 60791
// break ;
60789: GO 60938
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60791: LD_ADDR_EXP 140
60795: PUSH
60796: LD_EXP 140
60800: PPUSH
60801: LD_VAR 0 5
60805: PPUSH
60806: LD_EXP 140
60810: PUSH
60811: LD_VAR 0 5
60815: ARRAY
60816: PUSH
60817: LD_INT 1
60819: PLUS
60820: PPUSH
60821: CALL_OW 1
60825: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60826: LD_ADDR_EXP 137
60830: PUSH
60831: LD_EXP 137
60835: PPUSH
60836: LD_VAR 0 5
60840: PUSH
60841: LD_EXP 137
60845: PUSH
60846: LD_VAR 0 5
60850: ARRAY
60851: PUSH
60852: LD_INT 1
60854: PLUS
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: PPUSH
60860: LD_VAR 0 2
60864: PUSH
60865: LD_VAR 0 4
60869: ARRAY
60870: PUSH
60871: LD_VAR 0 2
60875: PUSH
60876: LD_VAR 0 4
60880: ARRAY
60881: PPUSH
60882: CALL_OW 255
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: PPUSH
60891: CALL 68489 0 3
60895: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60896: LD_VAR 0 2
60900: PUSH
60901: LD_VAR 0 4
60905: ARRAY
60906: PPUSH
60907: LD_VAR 0 1
60911: PPUSH
60912: CALL_OW 255
60916: PPUSH
60917: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60921: LD_VAR 0 2
60925: PUSH
60926: LD_VAR 0 4
60930: ARRAY
60931: PPUSH
60932: CALL_OW 141
// end ;
60936: GO 60768
60938: POP
60939: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60940: LD_VAR 0 1
60944: PPUSH
60945: LD_EXP 137
60949: PUSH
60950: LD_VAR 0 5
60954: ARRAY
60955: PUSH
60956: LD_INT 0
60958: PLUS
60959: PPUSH
60960: CALL_OW 505
// end ;
60964: LD_VAR 0 3
60968: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60969: LD_INT 0
60971: PPUSH
60972: PPUSH
60973: PPUSH
60974: PPUSH
// if not hack in hackTanks then
60975: LD_VAR 0 1
60979: PUSH
60980: LD_EXP 136
60984: IN
60985: NOT
60986: IFFALSE 60990
// exit ;
60988: GO 61230
// index := GetElementIndex ( hackTanks , hack ) ;
60990: LD_ADDR_VAR 0 4
60994: PUSH
60995: LD_EXP 136
60999: PPUSH
61000: LD_VAR 0 1
61004: PPUSH
61005: CALL 68274 0 2
61009: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61010: LD_ADDR_VAR 0 3
61014: PUSH
61015: DOUBLE
61016: LD_EXP 137
61020: PUSH
61021: LD_VAR 0 4
61025: ARRAY
61026: INC
61027: ST_TO_ADDR
61028: LD_INT 1
61030: PUSH
61031: FOR_DOWNTO
61032: IFFALSE 61204
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61034: LD_ADDR_VAR 0 5
61038: PUSH
61039: LD_EXP 137
61043: PUSH
61044: LD_VAR 0 4
61048: ARRAY
61049: PUSH
61050: LD_VAR 0 3
61054: ARRAY
61055: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61056: LD_VAR 0 5
61060: PUSH
61061: LD_INT 1
61063: ARRAY
61064: PPUSH
61065: CALL_OW 302
61069: NOT
61070: PUSH
61071: LD_VAR 0 5
61075: PUSH
61076: LD_INT 1
61078: ARRAY
61079: PPUSH
61080: CALL_OW 255
61084: PUSH
61085: LD_VAR 0 1
61089: PPUSH
61090: CALL_OW 255
61094: NONEQUAL
61095: OR
61096: IFFALSE 61202
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61098: LD_VAR 0 5
61102: PUSH
61103: LD_INT 1
61105: ARRAY
61106: PPUSH
61107: CALL_OW 305
61111: PUSH
61112: LD_VAR 0 5
61116: PUSH
61117: LD_INT 1
61119: ARRAY
61120: PPUSH
61121: CALL_OW 255
61125: PUSH
61126: LD_VAR 0 1
61130: PPUSH
61131: CALL_OW 255
61135: EQUAL
61136: AND
61137: IFFALSE 61161
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61139: LD_VAR 0 5
61143: PUSH
61144: LD_INT 1
61146: ARRAY
61147: PPUSH
61148: LD_VAR 0 5
61152: PUSH
61153: LD_INT 2
61155: ARRAY
61156: PPUSH
61157: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61161: LD_ADDR_EXP 137
61165: PUSH
61166: LD_EXP 137
61170: PPUSH
61171: LD_VAR 0 4
61175: PPUSH
61176: LD_EXP 137
61180: PUSH
61181: LD_VAR 0 4
61185: ARRAY
61186: PPUSH
61187: LD_VAR 0 3
61191: PPUSH
61192: CALL_OW 3
61196: PPUSH
61197: CALL_OW 1
61201: ST_TO_ADDR
// end ; end ;
61202: GO 61031
61204: POP
61205: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61206: LD_VAR 0 1
61210: PPUSH
61211: LD_EXP 137
61215: PUSH
61216: LD_VAR 0 4
61220: ARRAY
61221: PUSH
61222: LD_INT 0
61224: PLUS
61225: PPUSH
61226: CALL_OW 505
// end ;
61230: LD_VAR 0 2
61234: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61235: LD_INT 0
61237: PPUSH
61238: PPUSH
61239: PPUSH
61240: PPUSH
// if not hack in hackTanks then
61241: LD_VAR 0 1
61245: PUSH
61246: LD_EXP 136
61250: IN
61251: NOT
61252: IFFALSE 61256
// exit ;
61254: GO 61341
// index := GetElementIndex ( hackTanks , hack ) ;
61256: LD_ADDR_VAR 0 5
61260: PUSH
61261: LD_EXP 136
61265: PPUSH
61266: LD_VAR 0 1
61270: PPUSH
61271: CALL 68274 0 2
61275: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61276: LD_ADDR_VAR 0 4
61280: PUSH
61281: DOUBLE
61282: LD_INT 1
61284: DEC
61285: ST_TO_ADDR
61286: LD_EXP 137
61290: PUSH
61291: LD_VAR 0 5
61295: ARRAY
61296: PUSH
61297: FOR_TO
61298: IFFALSE 61339
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61300: LD_EXP 137
61304: PUSH
61305: LD_VAR 0 5
61309: ARRAY
61310: PUSH
61311: LD_VAR 0 4
61315: ARRAY
61316: PUSH
61317: LD_INT 1
61319: ARRAY
61320: PUSH
61321: LD_VAR 0 2
61325: EQUAL
61326: IFFALSE 61337
// KillUnit ( vehicle ) ;
61328: LD_VAR 0 2
61332: PPUSH
61333: CALL_OW 66
61337: GO 61297
61339: POP
61340: POP
// end ;
61341: LD_VAR 0 3
61345: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61346: LD_EXP 141
61350: NOT
61351: IFFALSE 61386
61353: GO 61355
61355: DISABLE
// begin initMiner := true ;
61356: LD_ADDR_EXP 141
61360: PUSH
61361: LD_INT 1
61363: ST_TO_ADDR
// minersList := [ ] ;
61364: LD_ADDR_EXP 142
61368: PUSH
61369: EMPTY
61370: ST_TO_ADDR
// minerMinesList := [ ] ;
61371: LD_ADDR_EXP 143
61375: PUSH
61376: EMPTY
61377: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61378: LD_ADDR_EXP 144
61382: PUSH
61383: LD_INT 5
61385: ST_TO_ADDR
// end ;
61386: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61387: LD_EXP 141
61391: PUSH
61392: LD_INT 34
61394: PUSH
61395: LD_INT 81
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: PPUSH
61402: CALL_OW 69
61406: AND
61407: IFFALSE 61868
61409: GO 61411
61411: DISABLE
61412: LD_INT 0
61414: PPUSH
61415: PPUSH
61416: PPUSH
61417: PPUSH
// begin enable ;
61418: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61419: LD_ADDR_VAR 0 1
61423: PUSH
61424: LD_INT 34
61426: PUSH
61427: LD_INT 81
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PPUSH
61434: CALL_OW 69
61438: PUSH
61439: FOR_IN
61440: IFFALSE 61512
// begin if not i in minersList then
61442: LD_VAR 0 1
61446: PUSH
61447: LD_EXP 142
61451: IN
61452: NOT
61453: IFFALSE 61510
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61455: LD_ADDR_EXP 142
61459: PUSH
61460: LD_EXP 142
61464: PPUSH
61465: LD_EXP 142
61469: PUSH
61470: LD_INT 1
61472: PLUS
61473: PPUSH
61474: LD_VAR 0 1
61478: PPUSH
61479: CALL_OW 1
61483: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61484: LD_ADDR_EXP 143
61488: PUSH
61489: LD_EXP 143
61493: PPUSH
61494: LD_EXP 143
61498: PUSH
61499: LD_INT 1
61501: PLUS
61502: PPUSH
61503: EMPTY
61504: PPUSH
61505: CALL_OW 1
61509: ST_TO_ADDR
// end end ;
61510: GO 61439
61512: POP
61513: POP
// for i := minerMinesList downto 1 do
61514: LD_ADDR_VAR 0 1
61518: PUSH
61519: DOUBLE
61520: LD_EXP 143
61524: INC
61525: ST_TO_ADDR
61526: LD_INT 1
61528: PUSH
61529: FOR_DOWNTO
61530: IFFALSE 61866
// begin if IsLive ( minersList [ i ] ) then
61532: LD_EXP 142
61536: PUSH
61537: LD_VAR 0 1
61541: ARRAY
61542: PPUSH
61543: CALL_OW 300
61547: IFFALSE 61575
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61549: LD_EXP 142
61553: PUSH
61554: LD_VAR 0 1
61558: ARRAY
61559: PPUSH
61560: LD_EXP 143
61564: PUSH
61565: LD_VAR 0 1
61569: ARRAY
61570: PPUSH
61571: CALL_OW 505
// if not minerMinesList [ i ] then
61575: LD_EXP 143
61579: PUSH
61580: LD_VAR 0 1
61584: ARRAY
61585: NOT
61586: IFFALSE 61590
// continue ;
61588: GO 61529
// for j := minerMinesList [ i ] downto 1 do
61590: LD_ADDR_VAR 0 2
61594: PUSH
61595: DOUBLE
61596: LD_EXP 143
61600: PUSH
61601: LD_VAR 0 1
61605: ARRAY
61606: INC
61607: ST_TO_ADDR
61608: LD_INT 1
61610: PUSH
61611: FOR_DOWNTO
61612: IFFALSE 61862
// begin side := GetSide ( minersList [ i ] ) ;
61614: LD_ADDR_VAR 0 3
61618: PUSH
61619: LD_EXP 142
61623: PUSH
61624: LD_VAR 0 1
61628: ARRAY
61629: PPUSH
61630: CALL_OW 255
61634: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61635: LD_ADDR_VAR 0 4
61639: PUSH
61640: LD_EXP 143
61644: PUSH
61645: LD_VAR 0 1
61649: ARRAY
61650: PUSH
61651: LD_VAR 0 2
61655: ARRAY
61656: PUSH
61657: LD_INT 1
61659: ARRAY
61660: PPUSH
61661: LD_EXP 143
61665: PUSH
61666: LD_VAR 0 1
61670: ARRAY
61671: PUSH
61672: LD_VAR 0 2
61676: ARRAY
61677: PUSH
61678: LD_INT 2
61680: ARRAY
61681: PPUSH
61682: CALL_OW 428
61686: ST_TO_ADDR
// if not tmp then
61687: LD_VAR 0 4
61691: NOT
61692: IFFALSE 61696
// continue ;
61694: GO 61611
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61696: LD_VAR 0 4
61700: PUSH
61701: LD_INT 81
61703: PUSH
61704: LD_VAR 0 3
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PPUSH
61713: CALL_OW 69
61717: IN
61718: PUSH
61719: LD_EXP 143
61723: PUSH
61724: LD_VAR 0 1
61728: ARRAY
61729: PUSH
61730: LD_VAR 0 2
61734: ARRAY
61735: PUSH
61736: LD_INT 1
61738: ARRAY
61739: PPUSH
61740: LD_EXP 143
61744: PUSH
61745: LD_VAR 0 1
61749: ARRAY
61750: PUSH
61751: LD_VAR 0 2
61755: ARRAY
61756: PUSH
61757: LD_INT 2
61759: ARRAY
61760: PPUSH
61761: CALL_OW 458
61765: AND
61766: IFFALSE 61860
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61768: LD_EXP 143
61772: PUSH
61773: LD_VAR 0 1
61777: ARRAY
61778: PUSH
61779: LD_VAR 0 2
61783: ARRAY
61784: PUSH
61785: LD_INT 1
61787: ARRAY
61788: PPUSH
61789: LD_EXP 143
61793: PUSH
61794: LD_VAR 0 1
61798: ARRAY
61799: PUSH
61800: LD_VAR 0 2
61804: ARRAY
61805: PUSH
61806: LD_INT 2
61808: ARRAY
61809: PPUSH
61810: LD_VAR 0 3
61814: PPUSH
61815: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61819: LD_ADDR_EXP 143
61823: PUSH
61824: LD_EXP 143
61828: PPUSH
61829: LD_VAR 0 1
61833: PPUSH
61834: LD_EXP 143
61838: PUSH
61839: LD_VAR 0 1
61843: ARRAY
61844: PPUSH
61845: LD_VAR 0 2
61849: PPUSH
61850: CALL_OW 3
61854: PPUSH
61855: CALL_OW 1
61859: ST_TO_ADDR
// end ; end ;
61860: GO 61611
61862: POP
61863: POP
// end ;
61864: GO 61529
61866: POP
61867: POP
// end ;
61868: PPOPN 4
61870: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61871: LD_INT 0
61873: PPUSH
61874: PPUSH
// result := false ;
61875: LD_ADDR_VAR 0 4
61879: PUSH
61880: LD_INT 0
61882: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61883: LD_VAR 0 1
61887: PPUSH
61888: CALL_OW 264
61892: PUSH
61893: LD_INT 81
61895: EQUAL
61896: NOT
61897: IFFALSE 61901
// exit ;
61899: GO 62141
// index := GetElementIndex ( minersList , unit ) ;
61901: LD_ADDR_VAR 0 5
61905: PUSH
61906: LD_EXP 142
61910: PPUSH
61911: LD_VAR 0 1
61915: PPUSH
61916: CALL 68274 0 2
61920: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61921: LD_EXP 143
61925: PUSH
61926: LD_VAR 0 5
61930: ARRAY
61931: PUSH
61932: LD_EXP 144
61936: GREATEREQUAL
61937: IFFALSE 61941
// exit ;
61939: GO 62141
// ComMoveXY ( unit , x , y ) ;
61941: LD_VAR 0 1
61945: PPUSH
61946: LD_VAR 0 2
61950: PPUSH
61951: LD_VAR 0 3
61955: PPUSH
61956: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61960: LD_INT 35
61962: PPUSH
61963: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61967: LD_VAR 0 1
61971: PPUSH
61972: LD_VAR 0 2
61976: PPUSH
61977: LD_VAR 0 3
61981: PPUSH
61982: CALL 99629 0 3
61986: NOT
61987: PUSH
61988: LD_VAR 0 1
61992: PPUSH
61993: CALL_OW 314
61997: AND
61998: IFFALSE 62002
// exit ;
62000: GO 62141
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
62002: LD_VAR 0 2
62006: PPUSH
62007: LD_VAR 0 3
62011: PPUSH
62012: CALL_OW 428
62016: PUSH
62017: LD_VAR 0 1
62021: EQUAL
62022: PUSH
62023: LD_VAR 0 1
62027: PPUSH
62028: CALL_OW 314
62032: NOT
62033: AND
62034: IFFALSE 61960
// PlaySoundXY ( x , y , PlantMine ) ;
62036: LD_VAR 0 2
62040: PPUSH
62041: LD_VAR 0 3
62045: PPUSH
62046: LD_STRING PlantMine
62048: PPUSH
62049: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62053: LD_VAR 0 2
62057: PPUSH
62058: LD_VAR 0 3
62062: PPUSH
62063: LD_VAR 0 1
62067: PPUSH
62068: CALL_OW 255
62072: PPUSH
62073: LD_INT 0
62075: PPUSH
62076: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62080: LD_ADDR_EXP 143
62084: PUSH
62085: LD_EXP 143
62089: PPUSH
62090: LD_VAR 0 5
62094: PUSH
62095: LD_EXP 143
62099: PUSH
62100: LD_VAR 0 5
62104: ARRAY
62105: PUSH
62106: LD_INT 1
62108: PLUS
62109: PUSH
62110: EMPTY
62111: LIST
62112: LIST
62113: PPUSH
62114: LD_VAR 0 2
62118: PUSH
62119: LD_VAR 0 3
62123: PUSH
62124: EMPTY
62125: LIST
62126: LIST
62127: PPUSH
62128: CALL 68489 0 3
62132: ST_TO_ADDR
// result := true ;
62133: LD_ADDR_VAR 0 4
62137: PUSH
62138: LD_INT 1
62140: ST_TO_ADDR
// end ;
62141: LD_VAR 0 4
62145: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62146: LD_INT 0
62148: PPUSH
62149: PPUSH
62150: PPUSH
// if not unit in minersList then
62151: LD_VAR 0 1
62155: PUSH
62156: LD_EXP 142
62160: IN
62161: NOT
62162: IFFALSE 62166
// exit ;
62164: GO 62558
// index := GetElementIndex ( minersList , unit ) ;
62166: LD_ADDR_VAR 0 6
62170: PUSH
62171: LD_EXP 142
62175: PPUSH
62176: LD_VAR 0 1
62180: PPUSH
62181: CALL 68274 0 2
62185: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62186: LD_ADDR_VAR 0 5
62190: PUSH
62191: DOUBLE
62192: LD_EXP 143
62196: PUSH
62197: LD_VAR 0 6
62201: ARRAY
62202: INC
62203: ST_TO_ADDR
62204: LD_INT 1
62206: PUSH
62207: FOR_DOWNTO
62208: IFFALSE 62369
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62210: LD_EXP 143
62214: PUSH
62215: LD_VAR 0 6
62219: ARRAY
62220: PUSH
62221: LD_VAR 0 5
62225: ARRAY
62226: PUSH
62227: LD_INT 1
62229: ARRAY
62230: PUSH
62231: LD_VAR 0 2
62235: EQUAL
62236: PUSH
62237: LD_EXP 143
62241: PUSH
62242: LD_VAR 0 6
62246: ARRAY
62247: PUSH
62248: LD_VAR 0 5
62252: ARRAY
62253: PUSH
62254: LD_INT 2
62256: ARRAY
62257: PUSH
62258: LD_VAR 0 3
62262: EQUAL
62263: AND
62264: IFFALSE 62367
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62266: LD_EXP 143
62270: PUSH
62271: LD_VAR 0 6
62275: ARRAY
62276: PUSH
62277: LD_VAR 0 5
62281: ARRAY
62282: PUSH
62283: LD_INT 1
62285: ARRAY
62286: PPUSH
62287: LD_EXP 143
62291: PUSH
62292: LD_VAR 0 6
62296: ARRAY
62297: PUSH
62298: LD_VAR 0 5
62302: ARRAY
62303: PUSH
62304: LD_INT 2
62306: ARRAY
62307: PPUSH
62308: LD_VAR 0 1
62312: PPUSH
62313: CALL_OW 255
62317: PPUSH
62318: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62322: LD_ADDR_EXP 143
62326: PUSH
62327: LD_EXP 143
62331: PPUSH
62332: LD_VAR 0 6
62336: PPUSH
62337: LD_EXP 143
62341: PUSH
62342: LD_VAR 0 6
62346: ARRAY
62347: PPUSH
62348: LD_VAR 0 5
62352: PPUSH
62353: CALL_OW 3
62357: PPUSH
62358: CALL_OW 1
62362: ST_TO_ADDR
// exit ;
62363: POP
62364: POP
62365: GO 62558
// end ; end ;
62367: GO 62207
62369: POP
62370: POP
// for i := minerMinesList [ index ] downto 1 do
62371: LD_ADDR_VAR 0 5
62375: PUSH
62376: DOUBLE
62377: LD_EXP 143
62381: PUSH
62382: LD_VAR 0 6
62386: ARRAY
62387: INC
62388: ST_TO_ADDR
62389: LD_INT 1
62391: PUSH
62392: FOR_DOWNTO
62393: IFFALSE 62556
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62395: LD_EXP 143
62399: PUSH
62400: LD_VAR 0 6
62404: ARRAY
62405: PUSH
62406: LD_VAR 0 5
62410: ARRAY
62411: PUSH
62412: LD_INT 1
62414: ARRAY
62415: PPUSH
62416: LD_EXP 143
62420: PUSH
62421: LD_VAR 0 6
62425: ARRAY
62426: PUSH
62427: LD_VAR 0 5
62431: ARRAY
62432: PUSH
62433: LD_INT 2
62435: ARRAY
62436: PPUSH
62437: LD_VAR 0 2
62441: PPUSH
62442: LD_VAR 0 3
62446: PPUSH
62447: CALL_OW 298
62451: PUSH
62452: LD_INT 6
62454: LESS
62455: IFFALSE 62554
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62457: LD_EXP 143
62461: PUSH
62462: LD_VAR 0 6
62466: ARRAY
62467: PUSH
62468: LD_VAR 0 5
62472: ARRAY
62473: PUSH
62474: LD_INT 1
62476: ARRAY
62477: PPUSH
62478: LD_EXP 143
62482: PUSH
62483: LD_VAR 0 6
62487: ARRAY
62488: PUSH
62489: LD_VAR 0 5
62493: ARRAY
62494: PUSH
62495: LD_INT 2
62497: ARRAY
62498: PPUSH
62499: LD_VAR 0 1
62503: PPUSH
62504: CALL_OW 255
62508: PPUSH
62509: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62513: LD_ADDR_EXP 143
62517: PUSH
62518: LD_EXP 143
62522: PPUSH
62523: LD_VAR 0 6
62527: PPUSH
62528: LD_EXP 143
62532: PUSH
62533: LD_VAR 0 6
62537: ARRAY
62538: PPUSH
62539: LD_VAR 0 5
62543: PPUSH
62544: CALL_OW 3
62548: PPUSH
62549: CALL_OW 1
62553: ST_TO_ADDR
// end ; end ;
62554: GO 62392
62556: POP
62557: POP
// end ;
62558: LD_VAR 0 4
62562: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62563: LD_INT 0
62565: PPUSH
62566: PPUSH
62567: PPUSH
62568: PPUSH
62569: PPUSH
62570: PPUSH
62571: PPUSH
62572: PPUSH
62573: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62574: LD_VAR 0 1
62578: PPUSH
62579: CALL_OW 264
62583: PUSH
62584: LD_INT 81
62586: EQUAL
62587: NOT
62588: PUSH
62589: LD_VAR 0 1
62593: PUSH
62594: LD_EXP 142
62598: IN
62599: NOT
62600: OR
62601: IFFALSE 62605
// exit ;
62603: GO 62927
// index := GetElementIndex ( minersList , unit ) ;
62605: LD_ADDR_VAR 0 6
62609: PUSH
62610: LD_EXP 142
62614: PPUSH
62615: LD_VAR 0 1
62619: PPUSH
62620: CALL 68274 0 2
62624: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62625: LD_ADDR_VAR 0 8
62629: PUSH
62630: LD_EXP 144
62634: PUSH
62635: LD_EXP 143
62639: PUSH
62640: LD_VAR 0 6
62644: ARRAY
62645: MINUS
62646: ST_TO_ADDR
// if not minesFreeAmount then
62647: LD_VAR 0 8
62651: NOT
62652: IFFALSE 62656
// exit ;
62654: GO 62927
// tmp := [ ] ;
62656: LD_ADDR_VAR 0 7
62660: PUSH
62661: EMPTY
62662: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62663: LD_ADDR_VAR 0 5
62667: PUSH
62668: DOUBLE
62669: LD_INT 1
62671: DEC
62672: ST_TO_ADDR
62673: LD_VAR 0 8
62677: PUSH
62678: FOR_TO
62679: IFFALSE 62874
// begin _d := rand ( 0 , 5 ) ;
62681: LD_ADDR_VAR 0 11
62685: PUSH
62686: LD_INT 0
62688: PPUSH
62689: LD_INT 5
62691: PPUSH
62692: CALL_OW 12
62696: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62697: LD_ADDR_VAR 0 12
62701: PUSH
62702: LD_INT 2
62704: PPUSH
62705: LD_INT 6
62707: PPUSH
62708: CALL_OW 12
62712: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62713: LD_ADDR_VAR 0 9
62717: PUSH
62718: LD_VAR 0 2
62722: PPUSH
62723: LD_VAR 0 11
62727: PPUSH
62728: LD_VAR 0 12
62732: PPUSH
62733: CALL_OW 272
62737: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62738: LD_ADDR_VAR 0 10
62742: PUSH
62743: LD_VAR 0 3
62747: PPUSH
62748: LD_VAR 0 11
62752: PPUSH
62753: LD_VAR 0 12
62757: PPUSH
62758: CALL_OW 273
62762: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62763: LD_VAR 0 9
62767: PPUSH
62768: LD_VAR 0 10
62772: PPUSH
62773: CALL_OW 488
62777: PUSH
62778: LD_VAR 0 9
62782: PUSH
62783: LD_VAR 0 10
62787: PUSH
62788: EMPTY
62789: LIST
62790: LIST
62791: PUSH
62792: LD_VAR 0 7
62796: IN
62797: NOT
62798: AND
62799: PUSH
62800: LD_VAR 0 9
62804: PPUSH
62805: LD_VAR 0 10
62809: PPUSH
62810: CALL_OW 458
62814: NOT
62815: AND
62816: IFFALSE 62858
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62818: LD_ADDR_VAR 0 7
62822: PUSH
62823: LD_VAR 0 7
62827: PPUSH
62828: LD_VAR 0 7
62832: PUSH
62833: LD_INT 1
62835: PLUS
62836: PPUSH
62837: LD_VAR 0 9
62841: PUSH
62842: LD_VAR 0 10
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PPUSH
62851: CALL_OW 1
62855: ST_TO_ADDR
62856: GO 62872
// i := i - 1 ;
62858: LD_ADDR_VAR 0 5
62862: PUSH
62863: LD_VAR 0 5
62867: PUSH
62868: LD_INT 1
62870: MINUS
62871: ST_TO_ADDR
// end ;
62872: GO 62678
62874: POP
62875: POP
// for i in tmp do
62876: LD_ADDR_VAR 0 5
62880: PUSH
62881: LD_VAR 0 7
62885: PUSH
62886: FOR_IN
62887: IFFALSE 62925
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62889: LD_VAR 0 1
62893: PPUSH
62894: LD_VAR 0 5
62898: PUSH
62899: LD_INT 1
62901: ARRAY
62902: PPUSH
62903: LD_VAR 0 5
62907: PUSH
62908: LD_INT 2
62910: ARRAY
62911: PPUSH
62912: CALL 61871 0 3
62916: NOT
62917: IFFALSE 62923
// exit ;
62919: POP
62920: POP
62921: GO 62927
62923: GO 62886
62925: POP
62926: POP
// end ;
62927: LD_VAR 0 4
62931: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62932: LD_INT 0
62934: PPUSH
62935: PPUSH
62936: PPUSH
62937: PPUSH
62938: PPUSH
62939: PPUSH
62940: PPUSH
// if not GetClass ( unit ) = class_sniper then
62941: LD_VAR 0 1
62945: PPUSH
62946: CALL_OW 257
62950: PUSH
62951: LD_INT 5
62953: EQUAL
62954: NOT
62955: IFFALSE 62959
// exit ;
62957: GO 63347
// dist := 8 ;
62959: LD_ADDR_VAR 0 5
62963: PUSH
62964: LD_INT 8
62966: ST_TO_ADDR
// viewRange := 12 ;
62967: LD_ADDR_VAR 0 7
62971: PUSH
62972: LD_INT 12
62974: ST_TO_ADDR
// side := GetSide ( unit ) ;
62975: LD_ADDR_VAR 0 6
62979: PUSH
62980: LD_VAR 0 1
62984: PPUSH
62985: CALL_OW 255
62989: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62990: LD_INT 61
62992: PPUSH
62993: LD_VAR 0 6
62997: PPUSH
62998: CALL_OW 321
63002: PUSH
63003: LD_INT 2
63005: EQUAL
63006: IFFALSE 63016
// viewRange := 16 ;
63008: LD_ADDR_VAR 0 7
63012: PUSH
63013: LD_INT 16
63015: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63016: LD_VAR 0 1
63020: PPUSH
63021: LD_VAR 0 2
63025: PPUSH
63026: LD_VAR 0 3
63030: PPUSH
63031: CALL_OW 297
63035: PUSH
63036: LD_VAR 0 5
63040: GREATER
63041: IFFALSE 63120
// begin ComMoveXY ( unit , x , y ) ;
63043: LD_VAR 0 1
63047: PPUSH
63048: LD_VAR 0 2
63052: PPUSH
63053: LD_VAR 0 3
63057: PPUSH
63058: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63062: LD_INT 35
63064: PPUSH
63065: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63069: LD_VAR 0 1
63073: PPUSH
63074: LD_VAR 0 2
63078: PPUSH
63079: LD_VAR 0 3
63083: PPUSH
63084: CALL 99629 0 3
63088: NOT
63089: IFFALSE 63093
// exit ;
63091: GO 63347
// until GetDistUnitXY ( unit , x , y ) < dist ;
63093: LD_VAR 0 1
63097: PPUSH
63098: LD_VAR 0 2
63102: PPUSH
63103: LD_VAR 0 3
63107: PPUSH
63108: CALL_OW 297
63112: PUSH
63113: LD_VAR 0 5
63117: LESS
63118: IFFALSE 63062
// end ; ComTurnXY ( unit , x , y ) ;
63120: LD_VAR 0 1
63124: PPUSH
63125: LD_VAR 0 2
63129: PPUSH
63130: LD_VAR 0 3
63134: PPUSH
63135: CALL_OW 118
// wait ( 5 ) ;
63139: LD_INT 5
63141: PPUSH
63142: CALL_OW 67
// _d := GetDir ( unit ) ;
63146: LD_ADDR_VAR 0 10
63150: PUSH
63151: LD_VAR 0 1
63155: PPUSH
63156: CALL_OW 254
63160: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63161: LD_ADDR_VAR 0 8
63165: PUSH
63166: LD_VAR 0 1
63170: PPUSH
63171: CALL_OW 250
63175: PPUSH
63176: LD_VAR 0 10
63180: PPUSH
63181: LD_VAR 0 5
63185: PPUSH
63186: CALL_OW 272
63190: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63191: LD_ADDR_VAR 0 9
63195: PUSH
63196: LD_VAR 0 1
63200: PPUSH
63201: CALL_OW 251
63205: PPUSH
63206: LD_VAR 0 10
63210: PPUSH
63211: LD_VAR 0 5
63215: PPUSH
63216: CALL_OW 273
63220: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63221: LD_VAR 0 8
63225: PPUSH
63226: LD_VAR 0 9
63230: PPUSH
63231: CALL_OW 488
63235: NOT
63236: IFFALSE 63240
// exit ;
63238: GO 63347
// ComAnimCustom ( unit , 1 ) ;
63240: LD_VAR 0 1
63244: PPUSH
63245: LD_INT 1
63247: PPUSH
63248: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63252: LD_VAR 0 8
63256: PPUSH
63257: LD_VAR 0 9
63261: PPUSH
63262: LD_VAR 0 6
63266: PPUSH
63267: LD_VAR 0 7
63271: PPUSH
63272: CALL_OW 330
// repeat wait ( 1 ) ;
63276: LD_INT 1
63278: PPUSH
63279: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63283: LD_VAR 0 1
63287: PPUSH
63288: CALL_OW 316
63292: PUSH
63293: LD_VAR 0 1
63297: PPUSH
63298: CALL_OW 314
63302: OR
63303: PUSH
63304: LD_VAR 0 1
63308: PPUSH
63309: CALL_OW 302
63313: NOT
63314: OR
63315: PUSH
63316: LD_VAR 0 1
63320: PPUSH
63321: CALL_OW 301
63325: OR
63326: IFFALSE 63276
// RemoveSeeing ( _x , _y , side ) ;
63328: LD_VAR 0 8
63332: PPUSH
63333: LD_VAR 0 9
63337: PPUSH
63338: LD_VAR 0 6
63342: PPUSH
63343: CALL_OW 331
// end ; end_of_file
63347: LD_VAR 0 4
63351: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63352: LD_INT 0
63354: PPUSH
63355: PPUSH
// if exist_mode then
63356: LD_VAR 0 2
63360: IFFALSE 63385
// unit := CreateCharacter ( prefix & ident ) else
63362: LD_ADDR_VAR 0 5
63366: PUSH
63367: LD_VAR 0 3
63371: PUSH
63372: LD_VAR 0 1
63376: STR
63377: PPUSH
63378: CALL_OW 34
63382: ST_TO_ADDR
63383: GO 63400
// unit := NewCharacter ( ident ) ;
63385: LD_ADDR_VAR 0 5
63389: PUSH
63390: LD_VAR 0 1
63394: PPUSH
63395: CALL_OW 25
63399: ST_TO_ADDR
// result := unit ;
63400: LD_ADDR_VAR 0 4
63404: PUSH
63405: LD_VAR 0 5
63409: ST_TO_ADDR
// end ;
63410: LD_VAR 0 4
63414: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63415: LD_INT 0
63417: PPUSH
63418: PPUSH
// if not side or not nation then
63419: LD_VAR 0 1
63423: NOT
63424: PUSH
63425: LD_VAR 0 2
63429: NOT
63430: OR
63431: IFFALSE 63435
// exit ;
63433: GO 64203
// case nation of nation_american :
63435: LD_VAR 0 2
63439: PUSH
63440: LD_INT 1
63442: DOUBLE
63443: EQUAL
63444: IFTRUE 63448
63446: GO 63662
63448: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63449: LD_ADDR_VAR 0 4
63453: PUSH
63454: LD_INT 35
63456: PUSH
63457: LD_INT 45
63459: PUSH
63460: LD_INT 46
63462: PUSH
63463: LD_INT 47
63465: PUSH
63466: LD_INT 82
63468: PUSH
63469: LD_INT 83
63471: PUSH
63472: LD_INT 84
63474: PUSH
63475: LD_INT 85
63477: PUSH
63478: LD_INT 86
63480: PUSH
63481: LD_INT 1
63483: PUSH
63484: LD_INT 2
63486: PUSH
63487: LD_INT 6
63489: PUSH
63490: LD_INT 15
63492: PUSH
63493: LD_INT 16
63495: PUSH
63496: LD_INT 7
63498: PUSH
63499: LD_INT 12
63501: PUSH
63502: LD_INT 13
63504: PUSH
63505: LD_INT 10
63507: PUSH
63508: LD_INT 14
63510: PUSH
63511: LD_INT 20
63513: PUSH
63514: LD_INT 21
63516: PUSH
63517: LD_INT 22
63519: PUSH
63520: LD_INT 25
63522: PUSH
63523: LD_INT 32
63525: PUSH
63526: LD_INT 27
63528: PUSH
63529: LD_INT 36
63531: PUSH
63532: LD_INT 69
63534: PUSH
63535: LD_INT 39
63537: PUSH
63538: LD_INT 34
63540: PUSH
63541: LD_INT 40
63543: PUSH
63544: LD_INT 48
63546: PUSH
63547: LD_INT 49
63549: PUSH
63550: LD_INT 50
63552: PUSH
63553: LD_INT 51
63555: PUSH
63556: LD_INT 52
63558: PUSH
63559: LD_INT 53
63561: PUSH
63562: LD_INT 54
63564: PUSH
63565: LD_INT 55
63567: PUSH
63568: LD_INT 56
63570: PUSH
63571: LD_INT 57
63573: PUSH
63574: LD_INT 58
63576: PUSH
63577: LD_INT 59
63579: PUSH
63580: LD_INT 60
63582: PUSH
63583: LD_INT 61
63585: PUSH
63586: LD_INT 62
63588: PUSH
63589: LD_INT 80
63591: PUSH
63592: LD_INT 82
63594: PUSH
63595: LD_INT 83
63597: PUSH
63598: LD_INT 84
63600: PUSH
63601: LD_INT 85
63603: PUSH
63604: LD_INT 86
63606: PUSH
63607: EMPTY
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: ST_TO_ADDR
63660: GO 64127
63662: LD_INT 2
63664: DOUBLE
63665: EQUAL
63666: IFTRUE 63670
63668: GO 63896
63670: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
63671: LD_ADDR_VAR 0 4
63675: PUSH
63676: LD_INT 35
63678: PUSH
63679: LD_INT 45
63681: PUSH
63682: LD_INT 46
63684: PUSH
63685: LD_INT 47
63687: PUSH
63688: LD_INT 82
63690: PUSH
63691: LD_INT 83
63693: PUSH
63694: LD_INT 84
63696: PUSH
63697: LD_INT 85
63699: PUSH
63700: LD_INT 87
63702: PUSH
63703: LD_INT 70
63705: PUSH
63706: LD_INT 1
63708: PUSH
63709: LD_INT 11
63711: PUSH
63712: LD_INT 3
63714: PUSH
63715: LD_INT 4
63717: PUSH
63718: LD_INT 5
63720: PUSH
63721: LD_INT 6
63723: PUSH
63724: LD_INT 15
63726: PUSH
63727: LD_INT 18
63729: PUSH
63730: LD_INT 7
63732: PUSH
63733: LD_INT 17
63735: PUSH
63736: LD_INT 8
63738: PUSH
63739: LD_INT 20
63741: PUSH
63742: LD_INT 21
63744: PUSH
63745: LD_INT 22
63747: PUSH
63748: LD_INT 72
63750: PUSH
63751: LD_INT 26
63753: PUSH
63754: LD_INT 69
63756: PUSH
63757: LD_INT 39
63759: PUSH
63760: LD_INT 40
63762: PUSH
63763: LD_INT 41
63765: PUSH
63766: LD_INT 42
63768: PUSH
63769: LD_INT 43
63771: PUSH
63772: LD_INT 48
63774: PUSH
63775: LD_INT 49
63777: PUSH
63778: LD_INT 50
63780: PUSH
63781: LD_INT 51
63783: PUSH
63784: LD_INT 52
63786: PUSH
63787: LD_INT 53
63789: PUSH
63790: LD_INT 54
63792: PUSH
63793: LD_INT 55
63795: PUSH
63796: LD_INT 56
63798: PUSH
63799: LD_INT 60
63801: PUSH
63802: LD_INT 61
63804: PUSH
63805: LD_INT 62
63807: PUSH
63808: LD_INT 66
63810: PUSH
63811: LD_INT 67
63813: PUSH
63814: LD_INT 68
63816: PUSH
63817: LD_INT 81
63819: PUSH
63820: LD_INT 82
63822: PUSH
63823: LD_INT 83
63825: PUSH
63826: LD_INT 84
63828: PUSH
63829: LD_INT 85
63831: PUSH
63832: LD_INT 87
63834: PUSH
63835: LD_INT 88
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: LIST
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: ST_TO_ADDR
63894: GO 64127
63896: LD_INT 3
63898: DOUBLE
63899: EQUAL
63900: IFTRUE 63904
63902: GO 64126
63904: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
63905: LD_ADDR_VAR 0 4
63909: PUSH
63910: LD_INT 46
63912: PUSH
63913: LD_INT 47
63915: PUSH
63916: LD_INT 1
63918: PUSH
63919: LD_INT 2
63921: PUSH
63922: LD_INT 82
63924: PUSH
63925: LD_INT 83
63927: PUSH
63928: LD_INT 84
63930: PUSH
63931: LD_INT 85
63933: PUSH
63934: LD_INT 86
63936: PUSH
63937: LD_INT 11
63939: PUSH
63940: LD_INT 9
63942: PUSH
63943: LD_INT 20
63945: PUSH
63946: LD_INT 19
63948: PUSH
63949: LD_INT 21
63951: PUSH
63952: LD_INT 24
63954: PUSH
63955: LD_INT 22
63957: PUSH
63958: LD_INT 25
63960: PUSH
63961: LD_INT 28
63963: PUSH
63964: LD_INT 29
63966: PUSH
63967: LD_INT 30
63969: PUSH
63970: LD_INT 31
63972: PUSH
63973: LD_INT 37
63975: PUSH
63976: LD_INT 38
63978: PUSH
63979: LD_INT 32
63981: PUSH
63982: LD_INT 27
63984: PUSH
63985: LD_INT 33
63987: PUSH
63988: LD_INT 69
63990: PUSH
63991: LD_INT 39
63993: PUSH
63994: LD_INT 34
63996: PUSH
63997: LD_INT 40
63999: PUSH
64000: LD_INT 71
64002: PUSH
64003: LD_INT 23
64005: PUSH
64006: LD_INT 44
64008: PUSH
64009: LD_INT 48
64011: PUSH
64012: LD_INT 49
64014: PUSH
64015: LD_INT 50
64017: PUSH
64018: LD_INT 51
64020: PUSH
64021: LD_INT 52
64023: PUSH
64024: LD_INT 53
64026: PUSH
64027: LD_INT 54
64029: PUSH
64030: LD_INT 55
64032: PUSH
64033: LD_INT 56
64035: PUSH
64036: LD_INT 57
64038: PUSH
64039: LD_INT 58
64041: PUSH
64042: LD_INT 59
64044: PUSH
64045: LD_INT 63
64047: PUSH
64048: LD_INT 64
64050: PUSH
64051: LD_INT 65
64053: PUSH
64054: LD_INT 82
64056: PUSH
64057: LD_INT 83
64059: PUSH
64060: LD_INT 84
64062: PUSH
64063: LD_INT 85
64065: PUSH
64066: LD_INT 86
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: ST_TO_ADDR
64124: GO 64127
64126: POP
// if state > - 1 and state < 3 then
64127: LD_VAR 0 3
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: GREATER
64136: PUSH
64137: LD_VAR 0 3
64141: PUSH
64142: LD_INT 3
64144: LESS
64145: AND
64146: IFFALSE 64203
// for i in result do
64148: LD_ADDR_VAR 0 5
64152: PUSH
64153: LD_VAR 0 4
64157: PUSH
64158: FOR_IN
64159: IFFALSE 64201
// if GetTech ( i , side ) <> state then
64161: LD_VAR 0 5
64165: PPUSH
64166: LD_VAR 0 1
64170: PPUSH
64171: CALL_OW 321
64175: PUSH
64176: LD_VAR 0 3
64180: NONEQUAL
64181: IFFALSE 64199
// result := result diff i ;
64183: LD_ADDR_VAR 0 4
64187: PUSH
64188: LD_VAR 0 4
64192: PUSH
64193: LD_VAR 0 5
64197: DIFF
64198: ST_TO_ADDR
64199: GO 64158
64201: POP
64202: POP
// end ;
64203: LD_VAR 0 4
64207: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64208: LD_INT 0
64210: PPUSH
64211: PPUSH
64212: PPUSH
// result := true ;
64213: LD_ADDR_VAR 0 3
64217: PUSH
64218: LD_INT 1
64220: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64221: LD_ADDR_VAR 0 5
64225: PUSH
64226: LD_VAR 0 2
64230: PPUSH
64231: CALL_OW 480
64235: ST_TO_ADDR
// if not tmp then
64236: LD_VAR 0 5
64240: NOT
64241: IFFALSE 64245
// exit ;
64243: GO 64294
// for i in tmp do
64245: LD_ADDR_VAR 0 4
64249: PUSH
64250: LD_VAR 0 5
64254: PUSH
64255: FOR_IN
64256: IFFALSE 64292
// if GetTech ( i , side ) <> state_researched then
64258: LD_VAR 0 4
64262: PPUSH
64263: LD_VAR 0 1
64267: PPUSH
64268: CALL_OW 321
64272: PUSH
64273: LD_INT 2
64275: NONEQUAL
64276: IFFALSE 64290
// begin result := false ;
64278: LD_ADDR_VAR 0 3
64282: PUSH
64283: LD_INT 0
64285: ST_TO_ADDR
// exit ;
64286: POP
64287: POP
64288: GO 64294
// end ;
64290: GO 64255
64292: POP
64293: POP
// end ;
64294: LD_VAR 0 3
64298: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64299: LD_INT 0
64301: PPUSH
64302: PPUSH
64303: PPUSH
64304: PPUSH
64305: PPUSH
64306: PPUSH
64307: PPUSH
64308: PPUSH
64309: PPUSH
64310: PPUSH
64311: PPUSH
64312: PPUSH
64313: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64314: LD_VAR 0 1
64318: NOT
64319: PUSH
64320: LD_VAR 0 1
64324: PPUSH
64325: CALL_OW 257
64329: PUSH
64330: LD_INT 9
64332: NONEQUAL
64333: OR
64334: IFFALSE 64338
// exit ;
64336: GO 64911
// side := GetSide ( unit ) ;
64338: LD_ADDR_VAR 0 9
64342: PUSH
64343: LD_VAR 0 1
64347: PPUSH
64348: CALL_OW 255
64352: ST_TO_ADDR
// tech_space := tech_spacanom ;
64353: LD_ADDR_VAR 0 12
64357: PUSH
64358: LD_INT 29
64360: ST_TO_ADDR
// tech_time := tech_taurad ;
64361: LD_ADDR_VAR 0 13
64365: PUSH
64366: LD_INT 28
64368: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64369: LD_ADDR_VAR 0 11
64373: PUSH
64374: LD_VAR 0 1
64378: PPUSH
64379: CALL_OW 310
64383: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64384: LD_VAR 0 11
64388: PPUSH
64389: CALL_OW 247
64393: PUSH
64394: LD_INT 2
64396: EQUAL
64397: IFFALSE 64401
// exit ;
64399: GO 64911
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64401: LD_ADDR_VAR 0 8
64405: PUSH
64406: LD_INT 81
64408: PUSH
64409: LD_VAR 0 9
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 3
64420: PUSH
64421: LD_INT 21
64423: PUSH
64424: LD_INT 3
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PPUSH
64439: CALL_OW 69
64443: ST_TO_ADDR
// if not tmp then
64444: LD_VAR 0 8
64448: NOT
64449: IFFALSE 64453
// exit ;
64451: GO 64911
// if in_unit then
64453: LD_VAR 0 11
64457: IFFALSE 64481
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64459: LD_ADDR_VAR 0 10
64463: PUSH
64464: LD_VAR 0 8
64468: PPUSH
64469: LD_VAR 0 11
64473: PPUSH
64474: CALL_OW 74
64478: ST_TO_ADDR
64479: GO 64501
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64481: LD_ADDR_VAR 0 10
64485: PUSH
64486: LD_VAR 0 8
64490: PPUSH
64491: LD_VAR 0 1
64495: PPUSH
64496: CALL_OW 74
64500: ST_TO_ADDR
// if not enemy then
64501: LD_VAR 0 10
64505: NOT
64506: IFFALSE 64510
// exit ;
64508: GO 64911
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64510: LD_VAR 0 11
64514: PUSH
64515: LD_VAR 0 11
64519: PPUSH
64520: LD_VAR 0 10
64524: PPUSH
64525: CALL_OW 296
64529: PUSH
64530: LD_INT 13
64532: GREATER
64533: AND
64534: PUSH
64535: LD_VAR 0 1
64539: PPUSH
64540: LD_VAR 0 10
64544: PPUSH
64545: CALL_OW 296
64549: PUSH
64550: LD_INT 12
64552: GREATER
64553: OR
64554: IFFALSE 64558
// exit ;
64556: GO 64911
// missile := [ 1 ] ;
64558: LD_ADDR_VAR 0 14
64562: PUSH
64563: LD_INT 1
64565: PUSH
64566: EMPTY
64567: LIST
64568: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64569: LD_VAR 0 9
64573: PPUSH
64574: LD_VAR 0 12
64578: PPUSH
64579: CALL_OW 325
64583: IFFALSE 64612
// missile := Replace ( missile , missile + 1 , 2 ) ;
64585: LD_ADDR_VAR 0 14
64589: PUSH
64590: LD_VAR 0 14
64594: PPUSH
64595: LD_VAR 0 14
64599: PUSH
64600: LD_INT 1
64602: PLUS
64603: PPUSH
64604: LD_INT 2
64606: PPUSH
64607: CALL_OW 1
64611: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64612: LD_VAR 0 9
64616: PPUSH
64617: LD_VAR 0 13
64621: PPUSH
64622: CALL_OW 325
64626: PUSH
64627: LD_VAR 0 10
64631: PPUSH
64632: CALL_OW 255
64636: PPUSH
64637: LD_VAR 0 13
64641: PPUSH
64642: CALL_OW 325
64646: NOT
64647: AND
64648: IFFALSE 64677
// missile := Replace ( missile , missile + 1 , 3 ) ;
64650: LD_ADDR_VAR 0 14
64654: PUSH
64655: LD_VAR 0 14
64659: PPUSH
64660: LD_VAR 0 14
64664: PUSH
64665: LD_INT 1
64667: PLUS
64668: PPUSH
64669: LD_INT 3
64671: PPUSH
64672: CALL_OW 1
64676: ST_TO_ADDR
// if missile < 2 then
64677: LD_VAR 0 14
64681: PUSH
64682: LD_INT 2
64684: LESS
64685: IFFALSE 64689
// exit ;
64687: GO 64911
// x := GetX ( enemy ) ;
64689: LD_ADDR_VAR 0 4
64693: PUSH
64694: LD_VAR 0 10
64698: PPUSH
64699: CALL_OW 250
64703: ST_TO_ADDR
// y := GetY ( enemy ) ;
64704: LD_ADDR_VAR 0 5
64708: PUSH
64709: LD_VAR 0 10
64713: PPUSH
64714: CALL_OW 251
64718: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64719: LD_ADDR_VAR 0 6
64723: PUSH
64724: LD_VAR 0 4
64728: PUSH
64729: LD_INT 1
64731: NEG
64732: PPUSH
64733: LD_INT 1
64735: PPUSH
64736: CALL_OW 12
64740: PLUS
64741: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64742: LD_ADDR_VAR 0 7
64746: PUSH
64747: LD_VAR 0 5
64751: PUSH
64752: LD_INT 1
64754: NEG
64755: PPUSH
64756: LD_INT 1
64758: PPUSH
64759: CALL_OW 12
64763: PLUS
64764: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64765: LD_VAR 0 6
64769: PPUSH
64770: LD_VAR 0 7
64774: PPUSH
64775: CALL_OW 488
64779: NOT
64780: IFFALSE 64802
// begin _x := x ;
64782: LD_ADDR_VAR 0 6
64786: PUSH
64787: LD_VAR 0 4
64791: ST_TO_ADDR
// _y := y ;
64792: LD_ADDR_VAR 0 7
64796: PUSH
64797: LD_VAR 0 5
64801: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64802: LD_ADDR_VAR 0 3
64806: PUSH
64807: LD_INT 1
64809: PPUSH
64810: LD_VAR 0 14
64814: PPUSH
64815: CALL_OW 12
64819: ST_TO_ADDR
// case i of 1 :
64820: LD_VAR 0 3
64824: PUSH
64825: LD_INT 1
64827: DOUBLE
64828: EQUAL
64829: IFTRUE 64833
64831: GO 64850
64833: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64834: LD_VAR 0 1
64838: PPUSH
64839: LD_VAR 0 10
64843: PPUSH
64844: CALL_OW 115
64848: GO 64911
64850: LD_INT 2
64852: DOUBLE
64853: EQUAL
64854: IFTRUE 64858
64856: GO 64880
64858: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64859: LD_VAR 0 1
64863: PPUSH
64864: LD_VAR 0 6
64868: PPUSH
64869: LD_VAR 0 7
64873: PPUSH
64874: CALL_OW 153
64878: GO 64911
64880: LD_INT 3
64882: DOUBLE
64883: EQUAL
64884: IFTRUE 64888
64886: GO 64910
64888: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64889: LD_VAR 0 1
64893: PPUSH
64894: LD_VAR 0 6
64898: PPUSH
64899: LD_VAR 0 7
64903: PPUSH
64904: CALL_OW 154
64908: GO 64911
64910: POP
// end ;
64911: LD_VAR 0 2
64915: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64916: LD_INT 0
64918: PPUSH
64919: PPUSH
64920: PPUSH
64921: PPUSH
64922: PPUSH
64923: PPUSH
// if not unit or not building then
64924: LD_VAR 0 1
64928: NOT
64929: PUSH
64930: LD_VAR 0 2
64934: NOT
64935: OR
64936: IFFALSE 64940
// exit ;
64938: GO 65098
// x := GetX ( building ) ;
64940: LD_ADDR_VAR 0 5
64944: PUSH
64945: LD_VAR 0 2
64949: PPUSH
64950: CALL_OW 250
64954: ST_TO_ADDR
// y := GetY ( building ) ;
64955: LD_ADDR_VAR 0 6
64959: PUSH
64960: LD_VAR 0 2
64964: PPUSH
64965: CALL_OW 251
64969: ST_TO_ADDR
// for i = 0 to 5 do
64970: LD_ADDR_VAR 0 4
64974: PUSH
64975: DOUBLE
64976: LD_INT 0
64978: DEC
64979: ST_TO_ADDR
64980: LD_INT 5
64982: PUSH
64983: FOR_TO
64984: IFFALSE 65096
// begin _x := ShiftX ( x , i , 3 ) ;
64986: LD_ADDR_VAR 0 7
64990: PUSH
64991: LD_VAR 0 5
64995: PPUSH
64996: LD_VAR 0 4
65000: PPUSH
65001: LD_INT 3
65003: PPUSH
65004: CALL_OW 272
65008: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65009: LD_ADDR_VAR 0 8
65013: PUSH
65014: LD_VAR 0 6
65018: PPUSH
65019: LD_VAR 0 4
65023: PPUSH
65024: LD_INT 3
65026: PPUSH
65027: CALL_OW 273
65031: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65032: LD_VAR 0 7
65036: PPUSH
65037: LD_VAR 0 8
65041: PPUSH
65042: CALL_OW 488
65046: NOT
65047: IFFALSE 65051
// continue ;
65049: GO 64983
// if HexInfo ( _x , _y ) = 0 then
65051: LD_VAR 0 7
65055: PPUSH
65056: LD_VAR 0 8
65060: PPUSH
65061: CALL_OW 428
65065: PUSH
65066: LD_INT 0
65068: EQUAL
65069: IFFALSE 65094
// begin ComMoveXY ( unit , _x , _y ) ;
65071: LD_VAR 0 1
65075: PPUSH
65076: LD_VAR 0 7
65080: PPUSH
65081: LD_VAR 0 8
65085: PPUSH
65086: CALL_OW 111
// exit ;
65090: POP
65091: POP
65092: GO 65098
// end ; end ;
65094: GO 64983
65096: POP
65097: POP
// end ;
65098: LD_VAR 0 3
65102: RET
// export function ScanBase ( side , base_area ) ; begin
65103: LD_INT 0
65105: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65106: LD_ADDR_VAR 0 3
65110: PUSH
65111: LD_VAR 0 2
65115: PPUSH
65116: LD_INT 81
65118: PUSH
65119: LD_VAR 0 1
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PPUSH
65128: CALL_OW 70
65132: ST_TO_ADDR
// end ;
65133: LD_VAR 0 3
65137: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65138: LD_INT 0
65140: PPUSH
65141: PPUSH
65142: PPUSH
65143: PPUSH
// result := false ;
65144: LD_ADDR_VAR 0 2
65148: PUSH
65149: LD_INT 0
65151: ST_TO_ADDR
// side := GetSide ( unit ) ;
65152: LD_ADDR_VAR 0 3
65156: PUSH
65157: LD_VAR 0 1
65161: PPUSH
65162: CALL_OW 255
65166: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65167: LD_ADDR_VAR 0 4
65171: PUSH
65172: LD_VAR 0 1
65176: PPUSH
65177: CALL_OW 248
65181: ST_TO_ADDR
// case nat of 1 :
65182: LD_VAR 0 4
65186: PUSH
65187: LD_INT 1
65189: DOUBLE
65190: EQUAL
65191: IFTRUE 65195
65193: GO 65206
65195: POP
// tech := tech_lassight ; 2 :
65196: LD_ADDR_VAR 0 5
65200: PUSH
65201: LD_INT 12
65203: ST_TO_ADDR
65204: GO 65245
65206: LD_INT 2
65208: DOUBLE
65209: EQUAL
65210: IFTRUE 65214
65212: GO 65225
65214: POP
// tech := tech_mortar ; 3 :
65215: LD_ADDR_VAR 0 5
65219: PUSH
65220: LD_INT 41
65222: ST_TO_ADDR
65223: GO 65245
65225: LD_INT 3
65227: DOUBLE
65228: EQUAL
65229: IFTRUE 65233
65231: GO 65244
65233: POP
// tech := tech_bazooka ; end ;
65234: LD_ADDR_VAR 0 5
65238: PUSH
65239: LD_INT 44
65241: ST_TO_ADDR
65242: GO 65245
65244: POP
// if Researched ( side , tech ) then
65245: LD_VAR 0 3
65249: PPUSH
65250: LD_VAR 0 5
65254: PPUSH
65255: CALL_OW 325
65259: IFFALSE 65286
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65261: LD_ADDR_VAR 0 2
65265: PUSH
65266: LD_INT 5
65268: PUSH
65269: LD_INT 8
65271: PUSH
65272: LD_INT 9
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: LIST
65279: PUSH
65280: LD_VAR 0 4
65284: ARRAY
65285: ST_TO_ADDR
// end ;
65286: LD_VAR 0 2
65290: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65291: LD_INT 0
65293: PPUSH
65294: PPUSH
65295: PPUSH
// if not mines then
65296: LD_VAR 0 2
65300: NOT
65301: IFFALSE 65305
// exit ;
65303: GO 65449
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65305: LD_ADDR_VAR 0 5
65309: PUSH
65310: LD_INT 81
65312: PUSH
65313: LD_VAR 0 1
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 3
65324: PUSH
65325: LD_INT 21
65327: PUSH
65328: LD_INT 3
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: PUSH
65339: EMPTY
65340: LIST
65341: LIST
65342: PPUSH
65343: CALL_OW 69
65347: ST_TO_ADDR
// for i in mines do
65348: LD_ADDR_VAR 0 4
65352: PUSH
65353: LD_VAR 0 2
65357: PUSH
65358: FOR_IN
65359: IFFALSE 65447
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65361: LD_VAR 0 4
65365: PUSH
65366: LD_INT 1
65368: ARRAY
65369: PPUSH
65370: LD_VAR 0 4
65374: PUSH
65375: LD_INT 2
65377: ARRAY
65378: PPUSH
65379: CALL_OW 458
65383: NOT
65384: IFFALSE 65388
// continue ;
65386: GO 65358
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65388: LD_VAR 0 4
65392: PUSH
65393: LD_INT 1
65395: ARRAY
65396: PPUSH
65397: LD_VAR 0 4
65401: PUSH
65402: LD_INT 2
65404: ARRAY
65405: PPUSH
65406: CALL_OW 428
65410: PUSH
65411: LD_VAR 0 5
65415: IN
65416: IFFALSE 65445
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65418: LD_VAR 0 4
65422: PUSH
65423: LD_INT 1
65425: ARRAY
65426: PPUSH
65427: LD_VAR 0 4
65431: PUSH
65432: LD_INT 2
65434: ARRAY
65435: PPUSH
65436: LD_VAR 0 1
65440: PPUSH
65441: CALL_OW 456
// end ;
65445: GO 65358
65447: POP
65448: POP
// end ;
65449: LD_VAR 0 3
65453: RET
// export function Count ( array ) ; var i ; begin
65454: LD_INT 0
65456: PPUSH
65457: PPUSH
// result := 0 ;
65458: LD_ADDR_VAR 0 2
65462: PUSH
65463: LD_INT 0
65465: ST_TO_ADDR
// for i in array do
65466: LD_ADDR_VAR 0 3
65470: PUSH
65471: LD_VAR 0 1
65475: PUSH
65476: FOR_IN
65477: IFFALSE 65501
// if i then
65479: LD_VAR 0 3
65483: IFFALSE 65499
// result := result + 1 ;
65485: LD_ADDR_VAR 0 2
65489: PUSH
65490: LD_VAR 0 2
65494: PUSH
65495: LD_INT 1
65497: PLUS
65498: ST_TO_ADDR
65499: GO 65476
65501: POP
65502: POP
// end ;
65503: LD_VAR 0 2
65507: RET
// export function IsEmpty ( building ) ; begin
65508: LD_INT 0
65510: PPUSH
// if not building then
65511: LD_VAR 0 1
65515: NOT
65516: IFFALSE 65520
// exit ;
65518: GO 65563
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65520: LD_ADDR_VAR 0 2
65524: PUSH
65525: LD_VAR 0 1
65529: PUSH
65530: LD_INT 22
65532: PUSH
65533: LD_VAR 0 1
65537: PPUSH
65538: CALL_OW 255
65542: PUSH
65543: EMPTY
65544: LIST
65545: LIST
65546: PUSH
65547: LD_INT 58
65549: PUSH
65550: EMPTY
65551: LIST
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PPUSH
65557: CALL_OW 69
65561: IN
65562: ST_TO_ADDR
// end ;
65563: LD_VAR 0 2
65567: RET
// export function IsNotFull ( building ) ; var places ; begin
65568: LD_INT 0
65570: PPUSH
65571: PPUSH
// if not building then
65572: LD_VAR 0 1
65576: NOT
65577: IFFALSE 65581
// exit ;
65579: GO 65752
// result := false ;
65581: LD_ADDR_VAR 0 2
65585: PUSH
65586: LD_INT 0
65588: ST_TO_ADDR
// places := 0 ;
65589: LD_ADDR_VAR 0 3
65593: PUSH
65594: LD_INT 0
65596: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
65597: LD_VAR 0 1
65601: PPUSH
65602: CALL_OW 266
65606: PUSH
65607: LD_INT 0
65609: DOUBLE
65610: EQUAL
65611: IFTRUE 65669
65613: LD_INT 1
65615: DOUBLE
65616: EQUAL
65617: IFTRUE 65669
65619: LD_INT 6
65621: DOUBLE
65622: EQUAL
65623: IFTRUE 65669
65625: LD_INT 7
65627: DOUBLE
65628: EQUAL
65629: IFTRUE 65669
65631: LD_INT 8
65633: DOUBLE
65634: EQUAL
65635: IFTRUE 65669
65637: LD_INT 4
65639: DOUBLE
65640: EQUAL
65641: IFTRUE 65669
65643: LD_INT 5
65645: DOUBLE
65646: EQUAL
65647: IFTRUE 65669
65649: LD_INT 2
65651: DOUBLE
65652: EQUAL
65653: IFTRUE 65669
65655: LD_INT 3
65657: DOUBLE
65658: EQUAL
65659: IFTRUE 65669
65661: LD_INT 35
65663: DOUBLE
65664: EQUAL
65665: IFTRUE 65669
65667: GO 65680
65669: POP
// places := 6 ; b_bunker , b_breastwork :
65670: LD_ADDR_VAR 0 3
65674: PUSH
65675: LD_INT 6
65677: ST_TO_ADDR
65678: GO 65725
65680: LD_INT 32
65682: DOUBLE
65683: EQUAL
65684: IFTRUE 65694
65686: LD_INT 31
65688: DOUBLE
65689: EQUAL
65690: IFTRUE 65694
65692: GO 65705
65694: POP
// places := 1 ; b_control_tower :
65695: LD_ADDR_VAR 0 3
65699: PUSH
65700: LD_INT 1
65702: ST_TO_ADDR
65703: GO 65725
65705: LD_INT 36
65707: DOUBLE
65708: EQUAL
65709: IFTRUE 65713
65711: GO 65724
65713: POP
// places := 3 ; end ;
65714: LD_ADDR_VAR 0 3
65718: PUSH
65719: LD_INT 3
65721: ST_TO_ADDR
65722: GO 65725
65724: POP
// if places then
65725: LD_VAR 0 3
65729: IFFALSE 65752
// result := UnitsInside ( building ) < places ;
65731: LD_ADDR_VAR 0 2
65735: PUSH
65736: LD_VAR 0 1
65740: PPUSH
65741: CALL_OW 313
65745: PUSH
65746: LD_VAR 0 3
65750: LESS
65751: ST_TO_ADDR
// end ;
65752: LD_VAR 0 2
65756: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65757: LD_INT 0
65759: PPUSH
65760: PPUSH
65761: PPUSH
65762: PPUSH
// tmp := [ ] ;
65763: LD_ADDR_VAR 0 3
65767: PUSH
65768: EMPTY
65769: ST_TO_ADDR
// list := [ ] ;
65770: LD_ADDR_VAR 0 5
65774: PUSH
65775: EMPTY
65776: ST_TO_ADDR
// for i = 16 to 25 do
65777: LD_ADDR_VAR 0 4
65781: PUSH
65782: DOUBLE
65783: LD_INT 16
65785: DEC
65786: ST_TO_ADDR
65787: LD_INT 25
65789: PUSH
65790: FOR_TO
65791: IFFALSE 65864
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65793: LD_ADDR_VAR 0 3
65797: PUSH
65798: LD_VAR 0 3
65802: PUSH
65803: LD_INT 22
65805: PUSH
65806: LD_VAR 0 1
65810: PPUSH
65811: CALL_OW 255
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: LD_INT 91
65822: PUSH
65823: LD_VAR 0 1
65827: PUSH
65828: LD_INT 6
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 30
65838: PUSH
65839: LD_VAR 0 4
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: LIST
65852: PUSH
65853: EMPTY
65854: LIST
65855: PPUSH
65856: CALL_OW 69
65860: ADD
65861: ST_TO_ADDR
65862: GO 65790
65864: POP
65865: POP
// for i = 1 to tmp do
65866: LD_ADDR_VAR 0 4
65870: PUSH
65871: DOUBLE
65872: LD_INT 1
65874: DEC
65875: ST_TO_ADDR
65876: LD_VAR 0 3
65880: PUSH
65881: FOR_TO
65882: IFFALSE 65970
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65884: LD_ADDR_VAR 0 5
65888: PUSH
65889: LD_VAR 0 5
65893: PUSH
65894: LD_VAR 0 3
65898: PUSH
65899: LD_VAR 0 4
65903: ARRAY
65904: PPUSH
65905: CALL_OW 266
65909: PUSH
65910: LD_VAR 0 3
65914: PUSH
65915: LD_VAR 0 4
65919: ARRAY
65920: PPUSH
65921: CALL_OW 250
65925: PUSH
65926: LD_VAR 0 3
65930: PUSH
65931: LD_VAR 0 4
65935: ARRAY
65936: PPUSH
65937: CALL_OW 251
65941: PUSH
65942: LD_VAR 0 3
65946: PUSH
65947: LD_VAR 0 4
65951: ARRAY
65952: PPUSH
65953: CALL_OW 254
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: PUSH
65964: EMPTY
65965: LIST
65966: ADD
65967: ST_TO_ADDR
65968: GO 65881
65970: POP
65971: POP
// result := list ;
65972: LD_ADDR_VAR 0 2
65976: PUSH
65977: LD_VAR 0 5
65981: ST_TO_ADDR
// end ;
65982: LD_VAR 0 2
65986: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65987: LD_INT 0
65989: PPUSH
65990: PPUSH
65991: PPUSH
65992: PPUSH
65993: PPUSH
65994: PPUSH
65995: PPUSH
// if not factory then
65996: LD_VAR 0 1
66000: NOT
66001: IFFALSE 66005
// exit ;
66003: GO 66598
// if control = control_apeman then
66005: LD_VAR 0 4
66009: PUSH
66010: LD_INT 5
66012: EQUAL
66013: IFFALSE 66122
// begin tmp := UnitsInside ( factory ) ;
66015: LD_ADDR_VAR 0 8
66019: PUSH
66020: LD_VAR 0 1
66024: PPUSH
66025: CALL_OW 313
66029: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66030: LD_VAR 0 8
66034: PPUSH
66035: LD_INT 25
66037: PUSH
66038: LD_INT 12
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PPUSH
66045: CALL_OW 72
66049: NOT
66050: IFFALSE 66060
// control := control_manual ;
66052: LD_ADDR_VAR 0 4
66056: PUSH
66057: LD_INT 1
66059: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66060: LD_ADDR_VAR 0 8
66064: PUSH
66065: LD_VAR 0 1
66069: PPUSH
66070: CALL 65757 0 1
66074: ST_TO_ADDR
// if tmp then
66075: LD_VAR 0 8
66079: IFFALSE 66122
// begin for i in tmp do
66081: LD_ADDR_VAR 0 7
66085: PUSH
66086: LD_VAR 0 8
66090: PUSH
66091: FOR_IN
66092: IFFALSE 66120
// if i [ 1 ] = b_ext_radio then
66094: LD_VAR 0 7
66098: PUSH
66099: LD_INT 1
66101: ARRAY
66102: PUSH
66103: LD_INT 22
66105: EQUAL
66106: IFFALSE 66118
// begin control := control_remote ;
66108: LD_ADDR_VAR 0 4
66112: PUSH
66113: LD_INT 2
66115: ST_TO_ADDR
// break ;
66116: GO 66120
// end ;
66118: GO 66091
66120: POP
66121: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66122: LD_VAR 0 1
66126: PPUSH
66127: LD_VAR 0 2
66131: PPUSH
66132: LD_VAR 0 3
66136: PPUSH
66137: LD_VAR 0 4
66141: PPUSH
66142: LD_VAR 0 5
66146: PPUSH
66147: CALL_OW 448
66151: IFFALSE 66186
// begin result := [ chassis , engine , control , weapon ] ;
66153: LD_ADDR_VAR 0 6
66157: PUSH
66158: LD_VAR 0 2
66162: PUSH
66163: LD_VAR 0 3
66167: PUSH
66168: LD_VAR 0 4
66172: PUSH
66173: LD_VAR 0 5
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: ST_TO_ADDR
// exit ;
66184: GO 66598
// end ; _chassis := AvailableChassisList ( factory ) ;
66186: LD_ADDR_VAR 0 9
66190: PUSH
66191: LD_VAR 0 1
66195: PPUSH
66196: CALL_OW 475
66200: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66201: LD_ADDR_VAR 0 11
66205: PUSH
66206: LD_VAR 0 1
66210: PPUSH
66211: CALL_OW 476
66215: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66216: LD_ADDR_VAR 0 12
66220: PUSH
66221: LD_VAR 0 1
66225: PPUSH
66226: CALL_OW 477
66230: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66231: LD_ADDR_VAR 0 10
66235: PUSH
66236: LD_VAR 0 1
66240: PPUSH
66241: CALL_OW 478
66245: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66246: LD_VAR 0 9
66250: NOT
66251: PUSH
66252: LD_VAR 0 11
66256: NOT
66257: OR
66258: PUSH
66259: LD_VAR 0 12
66263: NOT
66264: OR
66265: PUSH
66266: LD_VAR 0 10
66270: NOT
66271: OR
66272: IFFALSE 66307
// begin result := [ chassis , engine , control , weapon ] ;
66274: LD_ADDR_VAR 0 6
66278: PUSH
66279: LD_VAR 0 2
66283: PUSH
66284: LD_VAR 0 3
66288: PUSH
66289: LD_VAR 0 4
66293: PUSH
66294: LD_VAR 0 5
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: LIST
66303: LIST
66304: ST_TO_ADDR
// exit ;
66305: GO 66598
// end ; if not chassis in _chassis then
66307: LD_VAR 0 2
66311: PUSH
66312: LD_VAR 0 9
66316: IN
66317: NOT
66318: IFFALSE 66344
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66320: LD_ADDR_VAR 0 2
66324: PUSH
66325: LD_VAR 0 9
66329: PUSH
66330: LD_INT 1
66332: PPUSH
66333: LD_VAR 0 9
66337: PPUSH
66338: CALL_OW 12
66342: ARRAY
66343: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66344: LD_VAR 0 2
66348: PPUSH
66349: LD_VAR 0 3
66353: PPUSH
66354: CALL 66603 0 2
66358: NOT
66359: IFFALSE 66418
// repeat engine := _engine [ 1 ] ;
66361: LD_ADDR_VAR 0 3
66365: PUSH
66366: LD_VAR 0 11
66370: PUSH
66371: LD_INT 1
66373: ARRAY
66374: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66375: LD_ADDR_VAR 0 11
66379: PUSH
66380: LD_VAR 0 11
66384: PPUSH
66385: LD_INT 1
66387: PPUSH
66388: CALL_OW 3
66392: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66393: LD_VAR 0 2
66397: PPUSH
66398: LD_VAR 0 3
66402: PPUSH
66403: CALL 66603 0 2
66407: PUSH
66408: LD_VAR 0 11
66412: PUSH
66413: EMPTY
66414: EQUAL
66415: OR
66416: IFFALSE 66361
// if not control in _control then
66418: LD_VAR 0 4
66422: PUSH
66423: LD_VAR 0 12
66427: IN
66428: NOT
66429: IFFALSE 66455
// control := _control [ rand ( 1 , _control ) ] ;
66431: LD_ADDR_VAR 0 4
66435: PUSH
66436: LD_VAR 0 12
66440: PUSH
66441: LD_INT 1
66443: PPUSH
66444: LD_VAR 0 12
66448: PPUSH
66449: CALL_OW 12
66453: ARRAY
66454: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66455: LD_VAR 0 2
66459: PPUSH
66460: LD_VAR 0 5
66464: PPUSH
66465: CALL 66823 0 2
66469: NOT
66470: IFFALSE 66529
// repeat weapon := _weapon [ 1 ] ;
66472: LD_ADDR_VAR 0 5
66476: PUSH
66477: LD_VAR 0 10
66481: PUSH
66482: LD_INT 1
66484: ARRAY
66485: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66486: LD_ADDR_VAR 0 10
66490: PUSH
66491: LD_VAR 0 10
66495: PPUSH
66496: LD_INT 1
66498: PPUSH
66499: CALL_OW 3
66503: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66504: LD_VAR 0 2
66508: PPUSH
66509: LD_VAR 0 5
66513: PPUSH
66514: CALL 66823 0 2
66518: PUSH
66519: LD_VAR 0 10
66523: PUSH
66524: EMPTY
66525: EQUAL
66526: OR
66527: IFFALSE 66472
// result := [ ] ;
66529: LD_ADDR_VAR 0 6
66533: PUSH
66534: EMPTY
66535: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66536: LD_VAR 0 1
66540: PPUSH
66541: LD_VAR 0 2
66545: PPUSH
66546: LD_VAR 0 3
66550: PPUSH
66551: LD_VAR 0 4
66555: PPUSH
66556: LD_VAR 0 5
66560: PPUSH
66561: CALL_OW 448
66565: IFFALSE 66598
// result := [ chassis , engine , control , weapon ] ;
66567: LD_ADDR_VAR 0 6
66571: PUSH
66572: LD_VAR 0 2
66576: PUSH
66577: LD_VAR 0 3
66581: PUSH
66582: LD_VAR 0 4
66586: PUSH
66587: LD_VAR 0 5
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: ST_TO_ADDR
// end ;
66598: LD_VAR 0 6
66602: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66603: LD_INT 0
66605: PPUSH
// if not chassis or not engine then
66606: LD_VAR 0 1
66610: NOT
66611: PUSH
66612: LD_VAR 0 2
66616: NOT
66617: OR
66618: IFFALSE 66622
// exit ;
66620: GO 66818
// case engine of engine_solar :
66622: LD_VAR 0 2
66626: PUSH
66627: LD_INT 2
66629: DOUBLE
66630: EQUAL
66631: IFTRUE 66635
66633: GO 66673
66635: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66636: LD_ADDR_VAR 0 3
66640: PUSH
66641: LD_INT 11
66643: PUSH
66644: LD_INT 12
66646: PUSH
66647: LD_INT 13
66649: PUSH
66650: LD_INT 14
66652: PUSH
66653: LD_INT 1
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: LD_INT 3
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: LIST
66666: LIST
66667: LIST
66668: LIST
66669: LIST
66670: ST_TO_ADDR
66671: GO 66802
66673: LD_INT 1
66675: DOUBLE
66676: EQUAL
66677: IFTRUE 66681
66679: GO 66743
66681: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66682: LD_ADDR_VAR 0 3
66686: PUSH
66687: LD_INT 11
66689: PUSH
66690: LD_INT 12
66692: PUSH
66693: LD_INT 13
66695: PUSH
66696: LD_INT 14
66698: PUSH
66699: LD_INT 1
66701: PUSH
66702: LD_INT 2
66704: PUSH
66705: LD_INT 3
66707: PUSH
66708: LD_INT 4
66710: PUSH
66711: LD_INT 5
66713: PUSH
66714: LD_INT 21
66716: PUSH
66717: LD_INT 23
66719: PUSH
66720: LD_INT 22
66722: PUSH
66723: LD_INT 24
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: LIST
66736: LIST
66737: LIST
66738: LIST
66739: LIST
66740: ST_TO_ADDR
66741: GO 66802
66743: LD_INT 3
66745: DOUBLE
66746: EQUAL
66747: IFTRUE 66751
66749: GO 66801
66751: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66752: LD_ADDR_VAR 0 3
66756: PUSH
66757: LD_INT 13
66759: PUSH
66760: LD_INT 14
66762: PUSH
66763: LD_INT 2
66765: PUSH
66766: LD_INT 3
66768: PUSH
66769: LD_INT 4
66771: PUSH
66772: LD_INT 5
66774: PUSH
66775: LD_INT 21
66777: PUSH
66778: LD_INT 22
66780: PUSH
66781: LD_INT 23
66783: PUSH
66784: LD_INT 24
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: LIST
66794: LIST
66795: LIST
66796: LIST
66797: LIST
66798: ST_TO_ADDR
66799: GO 66802
66801: POP
// result := ( chassis in result ) ;
66802: LD_ADDR_VAR 0 3
66806: PUSH
66807: LD_VAR 0 1
66811: PUSH
66812: LD_VAR 0 3
66816: IN
66817: ST_TO_ADDR
// end ;
66818: LD_VAR 0 3
66822: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66823: LD_INT 0
66825: PPUSH
// if not chassis or not weapon then
66826: LD_VAR 0 1
66830: NOT
66831: PUSH
66832: LD_VAR 0 2
66836: NOT
66837: OR
66838: IFFALSE 66842
// exit ;
66840: GO 67902
// case weapon of us_machine_gun :
66842: LD_VAR 0 2
66846: PUSH
66847: LD_INT 2
66849: DOUBLE
66850: EQUAL
66851: IFTRUE 66855
66853: GO 66885
66855: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66856: LD_ADDR_VAR 0 3
66860: PUSH
66861: LD_INT 1
66863: PUSH
66864: LD_INT 2
66866: PUSH
66867: LD_INT 3
66869: PUSH
66870: LD_INT 4
66872: PUSH
66873: LD_INT 5
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: ST_TO_ADDR
66883: GO 67886
66885: LD_INT 3
66887: DOUBLE
66888: EQUAL
66889: IFTRUE 66893
66891: GO 66923
66893: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66894: LD_ADDR_VAR 0 3
66898: PUSH
66899: LD_INT 1
66901: PUSH
66902: LD_INT 2
66904: PUSH
66905: LD_INT 3
66907: PUSH
66908: LD_INT 4
66910: PUSH
66911: LD_INT 5
66913: PUSH
66914: EMPTY
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: ST_TO_ADDR
66921: GO 67886
66923: LD_INT 11
66925: DOUBLE
66926: EQUAL
66927: IFTRUE 66931
66929: GO 66961
66931: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66932: LD_ADDR_VAR 0 3
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: LD_INT 2
66942: PUSH
66943: LD_INT 3
66945: PUSH
66946: LD_INT 4
66948: PUSH
66949: LD_INT 5
66951: PUSH
66952: EMPTY
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: ST_TO_ADDR
66959: GO 67886
66961: LD_INT 4
66963: DOUBLE
66964: EQUAL
66965: IFTRUE 66969
66967: GO 66995
66969: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66970: LD_ADDR_VAR 0 3
66974: PUSH
66975: LD_INT 2
66977: PUSH
66978: LD_INT 3
66980: PUSH
66981: LD_INT 4
66983: PUSH
66984: LD_INT 5
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: ST_TO_ADDR
66993: GO 67886
66995: LD_INT 5
66997: DOUBLE
66998: EQUAL
66999: IFTRUE 67003
67001: GO 67029
67003: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
67004: LD_ADDR_VAR 0 3
67008: PUSH
67009: LD_INT 2
67011: PUSH
67012: LD_INT 3
67014: PUSH
67015: LD_INT 4
67017: PUSH
67018: LD_INT 5
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: ST_TO_ADDR
67027: GO 67886
67029: LD_INT 9
67031: DOUBLE
67032: EQUAL
67033: IFTRUE 67037
67035: GO 67063
67037: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67038: LD_ADDR_VAR 0 3
67042: PUSH
67043: LD_INT 2
67045: PUSH
67046: LD_INT 3
67048: PUSH
67049: LD_INT 4
67051: PUSH
67052: LD_INT 5
67054: PUSH
67055: EMPTY
67056: LIST
67057: LIST
67058: LIST
67059: LIST
67060: ST_TO_ADDR
67061: GO 67886
67063: LD_INT 7
67065: DOUBLE
67066: EQUAL
67067: IFTRUE 67071
67069: GO 67097
67071: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67072: LD_ADDR_VAR 0 3
67076: PUSH
67077: LD_INT 2
67079: PUSH
67080: LD_INT 3
67082: PUSH
67083: LD_INT 4
67085: PUSH
67086: LD_INT 5
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: LIST
67093: LIST
67094: ST_TO_ADDR
67095: GO 67886
67097: LD_INT 12
67099: DOUBLE
67100: EQUAL
67101: IFTRUE 67105
67103: GO 67131
67105: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67106: LD_ADDR_VAR 0 3
67110: PUSH
67111: LD_INT 2
67113: PUSH
67114: LD_INT 3
67116: PUSH
67117: LD_INT 4
67119: PUSH
67120: LD_INT 5
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: LIST
67127: LIST
67128: ST_TO_ADDR
67129: GO 67886
67131: LD_INT 13
67133: DOUBLE
67134: EQUAL
67135: IFTRUE 67139
67137: GO 67165
67139: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67140: LD_ADDR_VAR 0 3
67144: PUSH
67145: LD_INT 2
67147: PUSH
67148: LD_INT 3
67150: PUSH
67151: LD_INT 4
67153: PUSH
67154: LD_INT 5
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: LIST
67161: LIST
67162: ST_TO_ADDR
67163: GO 67886
67165: LD_INT 14
67167: DOUBLE
67168: EQUAL
67169: IFTRUE 67173
67171: GO 67191
67173: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67174: LD_ADDR_VAR 0 3
67178: PUSH
67179: LD_INT 4
67181: PUSH
67182: LD_INT 5
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: ST_TO_ADDR
67189: GO 67886
67191: LD_INT 6
67193: DOUBLE
67194: EQUAL
67195: IFTRUE 67199
67197: GO 67217
67199: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67200: LD_ADDR_VAR 0 3
67204: PUSH
67205: LD_INT 4
67207: PUSH
67208: LD_INT 5
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: ST_TO_ADDR
67215: GO 67886
67217: LD_INT 10
67219: DOUBLE
67220: EQUAL
67221: IFTRUE 67225
67223: GO 67243
67225: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67226: LD_ADDR_VAR 0 3
67230: PUSH
67231: LD_INT 4
67233: PUSH
67234: LD_INT 5
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: ST_TO_ADDR
67241: GO 67886
67243: LD_INT 22
67245: DOUBLE
67246: EQUAL
67247: IFTRUE 67251
67249: GO 67277
67251: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67252: LD_ADDR_VAR 0 3
67256: PUSH
67257: LD_INT 11
67259: PUSH
67260: LD_INT 12
67262: PUSH
67263: LD_INT 13
67265: PUSH
67266: LD_INT 14
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: ST_TO_ADDR
67275: GO 67886
67277: LD_INT 23
67279: DOUBLE
67280: EQUAL
67281: IFTRUE 67285
67283: GO 67311
67285: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67286: LD_ADDR_VAR 0 3
67290: PUSH
67291: LD_INT 11
67293: PUSH
67294: LD_INT 12
67296: PUSH
67297: LD_INT 13
67299: PUSH
67300: LD_INT 14
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: ST_TO_ADDR
67309: GO 67886
67311: LD_INT 24
67313: DOUBLE
67314: EQUAL
67315: IFTRUE 67319
67317: GO 67345
67319: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67320: LD_ADDR_VAR 0 3
67324: PUSH
67325: LD_INT 11
67327: PUSH
67328: LD_INT 12
67330: PUSH
67331: LD_INT 13
67333: PUSH
67334: LD_INT 14
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: ST_TO_ADDR
67343: GO 67886
67345: LD_INT 30
67347: DOUBLE
67348: EQUAL
67349: IFTRUE 67353
67351: GO 67379
67353: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67354: LD_ADDR_VAR 0 3
67358: PUSH
67359: LD_INT 11
67361: PUSH
67362: LD_INT 12
67364: PUSH
67365: LD_INT 13
67367: PUSH
67368: LD_INT 14
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: ST_TO_ADDR
67377: GO 67886
67379: LD_INT 25
67381: DOUBLE
67382: EQUAL
67383: IFTRUE 67387
67385: GO 67405
67387: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67388: LD_ADDR_VAR 0 3
67392: PUSH
67393: LD_INT 13
67395: PUSH
67396: LD_INT 14
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: ST_TO_ADDR
67403: GO 67886
67405: LD_INT 27
67407: DOUBLE
67408: EQUAL
67409: IFTRUE 67413
67411: GO 67431
67413: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67414: LD_ADDR_VAR 0 3
67418: PUSH
67419: LD_INT 13
67421: PUSH
67422: LD_INT 14
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: ST_TO_ADDR
67429: GO 67886
67431: LD_INT 92
67433: DOUBLE
67434: EQUAL
67435: IFTRUE 67439
67437: GO 67465
67439: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67440: LD_ADDR_VAR 0 3
67444: PUSH
67445: LD_INT 11
67447: PUSH
67448: LD_INT 12
67450: PUSH
67451: LD_INT 13
67453: PUSH
67454: LD_INT 14
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: ST_TO_ADDR
67463: GO 67886
67465: LD_INT 28
67467: DOUBLE
67468: EQUAL
67469: IFTRUE 67473
67471: GO 67491
67473: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67474: LD_ADDR_VAR 0 3
67478: PUSH
67479: LD_INT 13
67481: PUSH
67482: LD_INT 14
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: ST_TO_ADDR
67489: GO 67886
67491: LD_INT 29
67493: DOUBLE
67494: EQUAL
67495: IFTRUE 67499
67497: GO 67517
67499: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67500: LD_ADDR_VAR 0 3
67504: PUSH
67505: LD_INT 13
67507: PUSH
67508: LD_INT 14
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: ST_TO_ADDR
67515: GO 67886
67517: LD_INT 31
67519: DOUBLE
67520: EQUAL
67521: IFTRUE 67525
67523: GO 67543
67525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67526: LD_ADDR_VAR 0 3
67530: PUSH
67531: LD_INT 13
67533: PUSH
67534: LD_INT 14
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: ST_TO_ADDR
67541: GO 67886
67543: LD_INT 26
67545: DOUBLE
67546: EQUAL
67547: IFTRUE 67551
67549: GO 67569
67551: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67552: LD_ADDR_VAR 0 3
67556: PUSH
67557: LD_INT 13
67559: PUSH
67560: LD_INT 14
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: ST_TO_ADDR
67567: GO 67886
67569: LD_INT 42
67571: DOUBLE
67572: EQUAL
67573: IFTRUE 67577
67575: GO 67603
67577: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67578: LD_ADDR_VAR 0 3
67582: PUSH
67583: LD_INT 21
67585: PUSH
67586: LD_INT 22
67588: PUSH
67589: LD_INT 23
67591: PUSH
67592: LD_INT 24
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: ST_TO_ADDR
67601: GO 67886
67603: LD_INT 43
67605: DOUBLE
67606: EQUAL
67607: IFTRUE 67611
67609: GO 67637
67611: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67612: LD_ADDR_VAR 0 3
67616: PUSH
67617: LD_INT 21
67619: PUSH
67620: LD_INT 22
67622: PUSH
67623: LD_INT 23
67625: PUSH
67626: LD_INT 24
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: ST_TO_ADDR
67635: GO 67886
67637: LD_INT 44
67639: DOUBLE
67640: EQUAL
67641: IFTRUE 67645
67643: GO 67671
67645: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67646: LD_ADDR_VAR 0 3
67650: PUSH
67651: LD_INT 21
67653: PUSH
67654: LD_INT 22
67656: PUSH
67657: LD_INT 23
67659: PUSH
67660: LD_INT 24
67662: PUSH
67663: EMPTY
67664: LIST
67665: LIST
67666: LIST
67667: LIST
67668: ST_TO_ADDR
67669: GO 67886
67671: LD_INT 45
67673: DOUBLE
67674: EQUAL
67675: IFTRUE 67679
67677: GO 67705
67679: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67680: LD_ADDR_VAR 0 3
67684: PUSH
67685: LD_INT 21
67687: PUSH
67688: LD_INT 22
67690: PUSH
67691: LD_INT 23
67693: PUSH
67694: LD_INT 24
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: ST_TO_ADDR
67703: GO 67886
67705: LD_INT 49
67707: DOUBLE
67708: EQUAL
67709: IFTRUE 67713
67711: GO 67739
67713: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67714: LD_ADDR_VAR 0 3
67718: PUSH
67719: LD_INT 21
67721: PUSH
67722: LD_INT 22
67724: PUSH
67725: LD_INT 23
67727: PUSH
67728: LD_INT 24
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: ST_TO_ADDR
67737: GO 67886
67739: LD_INT 51
67741: DOUBLE
67742: EQUAL
67743: IFTRUE 67747
67745: GO 67773
67747: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67748: LD_ADDR_VAR 0 3
67752: PUSH
67753: LD_INT 21
67755: PUSH
67756: LD_INT 22
67758: PUSH
67759: LD_INT 23
67761: PUSH
67762: LD_INT 24
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: ST_TO_ADDR
67771: GO 67886
67773: LD_INT 52
67775: DOUBLE
67776: EQUAL
67777: IFTRUE 67781
67779: GO 67807
67781: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67782: LD_ADDR_VAR 0 3
67786: PUSH
67787: LD_INT 21
67789: PUSH
67790: LD_INT 22
67792: PUSH
67793: LD_INT 23
67795: PUSH
67796: LD_INT 24
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: LIST
67803: LIST
67804: ST_TO_ADDR
67805: GO 67886
67807: LD_INT 53
67809: DOUBLE
67810: EQUAL
67811: IFTRUE 67815
67813: GO 67833
67815: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67816: LD_ADDR_VAR 0 3
67820: PUSH
67821: LD_INT 23
67823: PUSH
67824: LD_INT 24
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: ST_TO_ADDR
67831: GO 67886
67833: LD_INT 46
67835: DOUBLE
67836: EQUAL
67837: IFTRUE 67841
67839: GO 67859
67841: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67842: LD_ADDR_VAR 0 3
67846: PUSH
67847: LD_INT 23
67849: PUSH
67850: LD_INT 24
67852: PUSH
67853: EMPTY
67854: LIST
67855: LIST
67856: ST_TO_ADDR
67857: GO 67886
67859: LD_INT 47
67861: DOUBLE
67862: EQUAL
67863: IFTRUE 67867
67865: GO 67885
67867: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67868: LD_ADDR_VAR 0 3
67872: PUSH
67873: LD_INT 23
67875: PUSH
67876: LD_INT 24
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: ST_TO_ADDR
67883: GO 67886
67885: POP
// result := ( chassis in result ) ;
67886: LD_ADDR_VAR 0 3
67890: PUSH
67891: LD_VAR 0 1
67895: PUSH
67896: LD_VAR 0 3
67900: IN
67901: ST_TO_ADDR
// end ;
67902: LD_VAR 0 3
67906: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67907: LD_INT 0
67909: PPUSH
67910: PPUSH
67911: PPUSH
67912: PPUSH
67913: PPUSH
67914: PPUSH
67915: PPUSH
// result := array ;
67916: LD_ADDR_VAR 0 5
67920: PUSH
67921: LD_VAR 0 1
67925: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67926: LD_VAR 0 1
67930: NOT
67931: PUSH
67932: LD_VAR 0 2
67936: NOT
67937: OR
67938: PUSH
67939: LD_VAR 0 3
67943: NOT
67944: OR
67945: PUSH
67946: LD_VAR 0 2
67950: PUSH
67951: LD_VAR 0 1
67955: GREATER
67956: OR
67957: PUSH
67958: LD_VAR 0 3
67962: PUSH
67963: LD_VAR 0 1
67967: GREATER
67968: OR
67969: IFFALSE 67973
// exit ;
67971: GO 68269
// if direction then
67973: LD_VAR 0 4
67977: IFFALSE 68041
// begin d := 1 ;
67979: LD_ADDR_VAR 0 9
67983: PUSH
67984: LD_INT 1
67986: ST_TO_ADDR
// if i_from > i_to then
67987: LD_VAR 0 2
67991: PUSH
67992: LD_VAR 0 3
67996: GREATER
67997: IFFALSE 68023
// length := ( array - i_from ) + i_to else
67999: LD_ADDR_VAR 0 11
68003: PUSH
68004: LD_VAR 0 1
68008: PUSH
68009: LD_VAR 0 2
68013: MINUS
68014: PUSH
68015: LD_VAR 0 3
68019: PLUS
68020: ST_TO_ADDR
68021: GO 68039
// length := i_to - i_from ;
68023: LD_ADDR_VAR 0 11
68027: PUSH
68028: LD_VAR 0 3
68032: PUSH
68033: LD_VAR 0 2
68037: MINUS
68038: ST_TO_ADDR
// end else
68039: GO 68102
// begin d := - 1 ;
68041: LD_ADDR_VAR 0 9
68045: PUSH
68046: LD_INT 1
68048: NEG
68049: ST_TO_ADDR
// if i_from > i_to then
68050: LD_VAR 0 2
68054: PUSH
68055: LD_VAR 0 3
68059: GREATER
68060: IFFALSE 68080
// length := i_from - i_to else
68062: LD_ADDR_VAR 0 11
68066: PUSH
68067: LD_VAR 0 2
68071: PUSH
68072: LD_VAR 0 3
68076: MINUS
68077: ST_TO_ADDR
68078: GO 68102
// length := ( array - i_to ) + i_from ;
68080: LD_ADDR_VAR 0 11
68084: PUSH
68085: LD_VAR 0 1
68089: PUSH
68090: LD_VAR 0 3
68094: MINUS
68095: PUSH
68096: LD_VAR 0 2
68100: PLUS
68101: ST_TO_ADDR
// end ; if not length then
68102: LD_VAR 0 11
68106: NOT
68107: IFFALSE 68111
// exit ;
68109: GO 68269
// tmp := array ;
68111: LD_ADDR_VAR 0 10
68115: PUSH
68116: LD_VAR 0 1
68120: ST_TO_ADDR
// for i = 1 to length do
68121: LD_ADDR_VAR 0 6
68125: PUSH
68126: DOUBLE
68127: LD_INT 1
68129: DEC
68130: ST_TO_ADDR
68131: LD_VAR 0 11
68135: PUSH
68136: FOR_TO
68137: IFFALSE 68257
// begin for j = 1 to array do
68139: LD_ADDR_VAR 0 7
68143: PUSH
68144: DOUBLE
68145: LD_INT 1
68147: DEC
68148: ST_TO_ADDR
68149: LD_VAR 0 1
68153: PUSH
68154: FOR_TO
68155: IFFALSE 68243
// begin k := j + d ;
68157: LD_ADDR_VAR 0 8
68161: PUSH
68162: LD_VAR 0 7
68166: PUSH
68167: LD_VAR 0 9
68171: PLUS
68172: ST_TO_ADDR
// if k > array then
68173: LD_VAR 0 8
68177: PUSH
68178: LD_VAR 0 1
68182: GREATER
68183: IFFALSE 68193
// k := 1 ;
68185: LD_ADDR_VAR 0 8
68189: PUSH
68190: LD_INT 1
68192: ST_TO_ADDR
// if not k then
68193: LD_VAR 0 8
68197: NOT
68198: IFFALSE 68210
// k := array ;
68200: LD_ADDR_VAR 0 8
68204: PUSH
68205: LD_VAR 0 1
68209: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68210: LD_ADDR_VAR 0 10
68214: PUSH
68215: LD_VAR 0 10
68219: PPUSH
68220: LD_VAR 0 8
68224: PPUSH
68225: LD_VAR 0 1
68229: PUSH
68230: LD_VAR 0 7
68234: ARRAY
68235: PPUSH
68236: CALL_OW 1
68240: ST_TO_ADDR
// end ;
68241: GO 68154
68243: POP
68244: POP
// array := tmp ;
68245: LD_ADDR_VAR 0 1
68249: PUSH
68250: LD_VAR 0 10
68254: ST_TO_ADDR
// end ;
68255: GO 68136
68257: POP
68258: POP
// result := array ;
68259: LD_ADDR_VAR 0 5
68263: PUSH
68264: LD_VAR 0 1
68268: ST_TO_ADDR
// end ;
68269: LD_VAR 0 5
68273: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68274: LD_INT 0
68276: PPUSH
68277: PPUSH
// result := 0 ;
68278: LD_ADDR_VAR 0 3
68282: PUSH
68283: LD_INT 0
68285: ST_TO_ADDR
// if not array or not value in array then
68286: LD_VAR 0 1
68290: NOT
68291: PUSH
68292: LD_VAR 0 2
68296: PUSH
68297: LD_VAR 0 1
68301: IN
68302: NOT
68303: OR
68304: IFFALSE 68308
// exit ;
68306: GO 68362
// for i = 1 to array do
68308: LD_ADDR_VAR 0 4
68312: PUSH
68313: DOUBLE
68314: LD_INT 1
68316: DEC
68317: ST_TO_ADDR
68318: LD_VAR 0 1
68322: PUSH
68323: FOR_TO
68324: IFFALSE 68360
// if value = array [ i ] then
68326: LD_VAR 0 2
68330: PUSH
68331: LD_VAR 0 1
68335: PUSH
68336: LD_VAR 0 4
68340: ARRAY
68341: EQUAL
68342: IFFALSE 68358
// begin result := i ;
68344: LD_ADDR_VAR 0 3
68348: PUSH
68349: LD_VAR 0 4
68353: ST_TO_ADDR
// exit ;
68354: POP
68355: POP
68356: GO 68362
// end ;
68358: GO 68323
68360: POP
68361: POP
// end ;
68362: LD_VAR 0 3
68366: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68367: LD_INT 0
68369: PPUSH
// vc_chassis := chassis ;
68370: LD_ADDR_OWVAR 37
68374: PUSH
68375: LD_VAR 0 1
68379: ST_TO_ADDR
// vc_engine := engine ;
68380: LD_ADDR_OWVAR 39
68384: PUSH
68385: LD_VAR 0 2
68389: ST_TO_ADDR
// vc_control := control ;
68390: LD_ADDR_OWVAR 38
68394: PUSH
68395: LD_VAR 0 3
68399: ST_TO_ADDR
// vc_weapon := weapon ;
68400: LD_ADDR_OWVAR 40
68404: PUSH
68405: LD_VAR 0 4
68409: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68410: LD_ADDR_OWVAR 41
68414: PUSH
68415: LD_VAR 0 5
68419: ST_TO_ADDR
// end ;
68420: LD_VAR 0 6
68424: RET
// export function WantPlant ( unit ) ; var task ; begin
68425: LD_INT 0
68427: PPUSH
68428: PPUSH
// result := false ;
68429: LD_ADDR_VAR 0 2
68433: PUSH
68434: LD_INT 0
68436: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68437: LD_ADDR_VAR 0 3
68441: PUSH
68442: LD_VAR 0 1
68446: PPUSH
68447: CALL_OW 437
68451: ST_TO_ADDR
// if task then
68452: LD_VAR 0 3
68456: IFFALSE 68484
// if task [ 1 ] [ 1 ] = p then
68458: LD_VAR 0 3
68462: PUSH
68463: LD_INT 1
68465: ARRAY
68466: PUSH
68467: LD_INT 1
68469: ARRAY
68470: PUSH
68471: LD_STRING p
68473: EQUAL
68474: IFFALSE 68484
// result := true ;
68476: LD_ADDR_VAR 0 2
68480: PUSH
68481: LD_INT 1
68483: ST_TO_ADDR
// end ;
68484: LD_VAR 0 2
68488: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68489: LD_INT 0
68491: PPUSH
68492: PPUSH
68493: PPUSH
68494: PPUSH
// if pos < 1 then
68495: LD_VAR 0 2
68499: PUSH
68500: LD_INT 1
68502: LESS
68503: IFFALSE 68507
// exit ;
68505: GO 68810
// if pos = 1 then
68507: LD_VAR 0 2
68511: PUSH
68512: LD_INT 1
68514: EQUAL
68515: IFFALSE 68548
// result := Replace ( arr , pos [ 1 ] , value ) else
68517: LD_ADDR_VAR 0 4
68521: PUSH
68522: LD_VAR 0 1
68526: PPUSH
68527: LD_VAR 0 2
68531: PUSH
68532: LD_INT 1
68534: ARRAY
68535: PPUSH
68536: LD_VAR 0 3
68540: PPUSH
68541: CALL_OW 1
68545: ST_TO_ADDR
68546: GO 68810
// begin tmp := arr ;
68548: LD_ADDR_VAR 0 6
68552: PUSH
68553: LD_VAR 0 1
68557: ST_TO_ADDR
// s_arr := [ tmp ] ;
68558: LD_ADDR_VAR 0 7
68562: PUSH
68563: LD_VAR 0 6
68567: PUSH
68568: EMPTY
68569: LIST
68570: ST_TO_ADDR
// for i = 1 to pos - 1 do
68571: LD_ADDR_VAR 0 5
68575: PUSH
68576: DOUBLE
68577: LD_INT 1
68579: DEC
68580: ST_TO_ADDR
68581: LD_VAR 0 2
68585: PUSH
68586: LD_INT 1
68588: MINUS
68589: PUSH
68590: FOR_TO
68591: IFFALSE 68636
// begin tmp := tmp [ pos [ i ] ] ;
68593: LD_ADDR_VAR 0 6
68597: PUSH
68598: LD_VAR 0 6
68602: PUSH
68603: LD_VAR 0 2
68607: PUSH
68608: LD_VAR 0 5
68612: ARRAY
68613: ARRAY
68614: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68615: LD_ADDR_VAR 0 7
68619: PUSH
68620: LD_VAR 0 7
68624: PUSH
68625: LD_VAR 0 6
68629: PUSH
68630: EMPTY
68631: LIST
68632: ADD
68633: ST_TO_ADDR
// end ;
68634: GO 68590
68636: POP
68637: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68638: LD_ADDR_VAR 0 6
68642: PUSH
68643: LD_VAR 0 6
68647: PPUSH
68648: LD_VAR 0 2
68652: PUSH
68653: LD_VAR 0 2
68657: ARRAY
68658: PPUSH
68659: LD_VAR 0 3
68663: PPUSH
68664: CALL_OW 1
68668: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68669: LD_ADDR_VAR 0 7
68673: PUSH
68674: LD_VAR 0 7
68678: PPUSH
68679: LD_VAR 0 7
68683: PPUSH
68684: LD_VAR 0 6
68688: PPUSH
68689: CALL_OW 1
68693: ST_TO_ADDR
// for i = s_arr downto 2 do
68694: LD_ADDR_VAR 0 5
68698: PUSH
68699: DOUBLE
68700: LD_VAR 0 7
68704: INC
68705: ST_TO_ADDR
68706: LD_INT 2
68708: PUSH
68709: FOR_DOWNTO
68710: IFFALSE 68794
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68712: LD_ADDR_VAR 0 6
68716: PUSH
68717: LD_VAR 0 7
68721: PUSH
68722: LD_VAR 0 5
68726: PUSH
68727: LD_INT 1
68729: MINUS
68730: ARRAY
68731: PPUSH
68732: LD_VAR 0 2
68736: PUSH
68737: LD_VAR 0 5
68741: PUSH
68742: LD_INT 1
68744: MINUS
68745: ARRAY
68746: PPUSH
68747: LD_VAR 0 7
68751: PUSH
68752: LD_VAR 0 5
68756: ARRAY
68757: PPUSH
68758: CALL_OW 1
68762: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68763: LD_ADDR_VAR 0 7
68767: PUSH
68768: LD_VAR 0 7
68772: PPUSH
68773: LD_VAR 0 5
68777: PUSH
68778: LD_INT 1
68780: MINUS
68781: PPUSH
68782: LD_VAR 0 6
68786: PPUSH
68787: CALL_OW 1
68791: ST_TO_ADDR
// end ;
68792: GO 68709
68794: POP
68795: POP
// result := s_arr [ 1 ] ;
68796: LD_ADDR_VAR 0 4
68800: PUSH
68801: LD_VAR 0 7
68805: PUSH
68806: LD_INT 1
68808: ARRAY
68809: ST_TO_ADDR
// end ; end ;
68810: LD_VAR 0 4
68814: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68815: LD_INT 0
68817: PPUSH
68818: PPUSH
// if not list then
68819: LD_VAR 0 1
68823: NOT
68824: IFFALSE 68828
// exit ;
68826: GO 68919
// i := list [ pos1 ] ;
68828: LD_ADDR_VAR 0 5
68832: PUSH
68833: LD_VAR 0 1
68837: PUSH
68838: LD_VAR 0 2
68842: ARRAY
68843: ST_TO_ADDR
// if not i then
68844: LD_VAR 0 5
68848: NOT
68849: IFFALSE 68853
// exit ;
68851: GO 68919
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68853: LD_ADDR_VAR 0 1
68857: PUSH
68858: LD_VAR 0 1
68862: PPUSH
68863: LD_VAR 0 2
68867: PPUSH
68868: LD_VAR 0 1
68872: PUSH
68873: LD_VAR 0 3
68877: ARRAY
68878: PPUSH
68879: CALL_OW 1
68883: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68884: LD_ADDR_VAR 0 1
68888: PUSH
68889: LD_VAR 0 1
68893: PPUSH
68894: LD_VAR 0 3
68898: PPUSH
68899: LD_VAR 0 5
68903: PPUSH
68904: CALL_OW 1
68908: ST_TO_ADDR
// result := list ;
68909: LD_ADDR_VAR 0 4
68913: PUSH
68914: LD_VAR 0 1
68918: ST_TO_ADDR
// end ;
68919: LD_VAR 0 4
68923: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68924: LD_INT 0
68926: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68927: LD_ADDR_VAR 0 5
68931: PUSH
68932: LD_VAR 0 1
68936: PPUSH
68937: CALL_OW 250
68941: PPUSH
68942: LD_VAR 0 1
68946: PPUSH
68947: CALL_OW 251
68951: PPUSH
68952: LD_VAR 0 2
68956: PPUSH
68957: LD_VAR 0 3
68961: PPUSH
68962: LD_VAR 0 4
68966: PPUSH
68967: CALL 68977 0 5
68971: ST_TO_ADDR
// end ;
68972: LD_VAR 0 5
68976: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68977: LD_INT 0
68979: PPUSH
68980: PPUSH
68981: PPUSH
68982: PPUSH
// if not list then
68983: LD_VAR 0 3
68987: NOT
68988: IFFALSE 68992
// exit ;
68990: GO 69380
// result := [ ] ;
68992: LD_ADDR_VAR 0 6
68996: PUSH
68997: EMPTY
68998: ST_TO_ADDR
// for i in list do
68999: LD_ADDR_VAR 0 7
69003: PUSH
69004: LD_VAR 0 3
69008: PUSH
69009: FOR_IN
69010: IFFALSE 69212
// begin tmp := GetDistUnitXY ( i , x , y ) ;
69012: LD_ADDR_VAR 0 9
69016: PUSH
69017: LD_VAR 0 7
69021: PPUSH
69022: LD_VAR 0 1
69026: PPUSH
69027: LD_VAR 0 2
69031: PPUSH
69032: CALL_OW 297
69036: ST_TO_ADDR
// if not result then
69037: LD_VAR 0 6
69041: NOT
69042: IFFALSE 69068
// result := [ [ i , tmp ] ] else
69044: LD_ADDR_VAR 0 6
69048: PUSH
69049: LD_VAR 0 7
69053: PUSH
69054: LD_VAR 0 9
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: EMPTY
69064: LIST
69065: ST_TO_ADDR
69066: GO 69210
// begin if result [ result ] [ 2 ] < tmp then
69068: LD_VAR 0 6
69072: PUSH
69073: LD_VAR 0 6
69077: ARRAY
69078: PUSH
69079: LD_INT 2
69081: ARRAY
69082: PUSH
69083: LD_VAR 0 9
69087: LESS
69088: IFFALSE 69130
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69090: LD_ADDR_VAR 0 6
69094: PUSH
69095: LD_VAR 0 6
69099: PPUSH
69100: LD_VAR 0 6
69104: PUSH
69105: LD_INT 1
69107: PLUS
69108: PPUSH
69109: LD_VAR 0 7
69113: PUSH
69114: LD_VAR 0 9
69118: PUSH
69119: EMPTY
69120: LIST
69121: LIST
69122: PPUSH
69123: CALL_OW 2
69127: ST_TO_ADDR
69128: GO 69210
// for j = 1 to result do
69130: LD_ADDR_VAR 0 8
69134: PUSH
69135: DOUBLE
69136: LD_INT 1
69138: DEC
69139: ST_TO_ADDR
69140: LD_VAR 0 6
69144: PUSH
69145: FOR_TO
69146: IFFALSE 69208
// begin if tmp < result [ j ] [ 2 ] then
69148: LD_VAR 0 9
69152: PUSH
69153: LD_VAR 0 6
69157: PUSH
69158: LD_VAR 0 8
69162: ARRAY
69163: PUSH
69164: LD_INT 2
69166: ARRAY
69167: LESS
69168: IFFALSE 69206
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69170: LD_ADDR_VAR 0 6
69174: PUSH
69175: LD_VAR 0 6
69179: PPUSH
69180: LD_VAR 0 8
69184: PPUSH
69185: LD_VAR 0 7
69189: PUSH
69190: LD_VAR 0 9
69194: PUSH
69195: EMPTY
69196: LIST
69197: LIST
69198: PPUSH
69199: CALL_OW 2
69203: ST_TO_ADDR
// break ;
69204: GO 69208
// end ; end ;
69206: GO 69145
69208: POP
69209: POP
// end ; end ;
69210: GO 69009
69212: POP
69213: POP
// if result and not asc then
69214: LD_VAR 0 6
69218: PUSH
69219: LD_VAR 0 4
69223: NOT
69224: AND
69225: IFFALSE 69300
// begin tmp := result ;
69227: LD_ADDR_VAR 0 9
69231: PUSH
69232: LD_VAR 0 6
69236: ST_TO_ADDR
// for i = tmp downto 1 do
69237: LD_ADDR_VAR 0 7
69241: PUSH
69242: DOUBLE
69243: LD_VAR 0 9
69247: INC
69248: ST_TO_ADDR
69249: LD_INT 1
69251: PUSH
69252: FOR_DOWNTO
69253: IFFALSE 69298
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69255: LD_ADDR_VAR 0 6
69259: PUSH
69260: LD_VAR 0 6
69264: PPUSH
69265: LD_VAR 0 9
69269: PUSH
69270: LD_VAR 0 7
69274: MINUS
69275: PUSH
69276: LD_INT 1
69278: PLUS
69279: PPUSH
69280: LD_VAR 0 9
69284: PUSH
69285: LD_VAR 0 7
69289: ARRAY
69290: PPUSH
69291: CALL_OW 1
69295: ST_TO_ADDR
69296: GO 69252
69298: POP
69299: POP
// end ; tmp := [ ] ;
69300: LD_ADDR_VAR 0 9
69304: PUSH
69305: EMPTY
69306: ST_TO_ADDR
// if mode then
69307: LD_VAR 0 5
69311: IFFALSE 69380
// begin for i = 1 to result do
69313: LD_ADDR_VAR 0 7
69317: PUSH
69318: DOUBLE
69319: LD_INT 1
69321: DEC
69322: ST_TO_ADDR
69323: LD_VAR 0 6
69327: PUSH
69328: FOR_TO
69329: IFFALSE 69368
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69331: LD_ADDR_VAR 0 9
69335: PUSH
69336: LD_VAR 0 9
69340: PPUSH
69341: LD_VAR 0 7
69345: PPUSH
69346: LD_VAR 0 6
69350: PUSH
69351: LD_VAR 0 7
69355: ARRAY
69356: PUSH
69357: LD_INT 1
69359: ARRAY
69360: PPUSH
69361: CALL_OW 1
69365: ST_TO_ADDR
69366: GO 69328
69368: POP
69369: POP
// result := tmp ;
69370: LD_ADDR_VAR 0 6
69374: PUSH
69375: LD_VAR 0 9
69379: ST_TO_ADDR
// end ; end ;
69380: LD_VAR 0 6
69384: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69385: LD_INT 0
69387: PPUSH
69388: PPUSH
69389: PPUSH
69390: PPUSH
69391: PPUSH
69392: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69393: LD_ADDR_VAR 0 5
69397: PUSH
69398: LD_INT 0
69400: PUSH
69401: LD_INT 0
69403: PUSH
69404: LD_INT 0
69406: PUSH
69407: EMPTY
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: ST_TO_ADDR
// if not x or not y then
69415: LD_VAR 0 2
69419: NOT
69420: PUSH
69421: LD_VAR 0 3
69425: NOT
69426: OR
69427: IFFALSE 69431
// exit ;
69429: GO 71081
// if not range then
69431: LD_VAR 0 4
69435: NOT
69436: IFFALSE 69446
// range := 10 ;
69438: LD_ADDR_VAR 0 4
69442: PUSH
69443: LD_INT 10
69445: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69446: LD_ADDR_VAR 0 8
69450: PUSH
69451: LD_INT 81
69453: PUSH
69454: LD_VAR 0 1
69458: PUSH
69459: EMPTY
69460: LIST
69461: LIST
69462: PUSH
69463: LD_INT 92
69465: PUSH
69466: LD_VAR 0 2
69470: PUSH
69471: LD_VAR 0 3
69475: PUSH
69476: LD_VAR 0 4
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 3
69489: PUSH
69490: LD_INT 21
69492: PUSH
69493: LD_INT 3
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: LIST
69508: PPUSH
69509: CALL_OW 69
69513: ST_TO_ADDR
// if not tmp then
69514: LD_VAR 0 8
69518: NOT
69519: IFFALSE 69523
// exit ;
69521: GO 71081
// for i in tmp do
69523: LD_ADDR_VAR 0 6
69527: PUSH
69528: LD_VAR 0 8
69532: PUSH
69533: FOR_IN
69534: IFFALSE 71056
// begin points := [ 0 , 0 , 0 ] ;
69536: LD_ADDR_VAR 0 9
69540: PUSH
69541: LD_INT 0
69543: PUSH
69544: LD_INT 0
69546: PUSH
69547: LD_INT 0
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: LIST
69554: ST_TO_ADDR
// bpoints := 1 ;
69555: LD_ADDR_VAR 0 10
69559: PUSH
69560: LD_INT 1
69562: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69563: LD_VAR 0 6
69567: PPUSH
69568: CALL_OW 247
69572: PUSH
69573: LD_INT 1
69575: DOUBLE
69576: EQUAL
69577: IFTRUE 69581
69579: GO 70159
69581: POP
// begin if GetClass ( i ) = 1 then
69582: LD_VAR 0 6
69586: PPUSH
69587: CALL_OW 257
69591: PUSH
69592: LD_INT 1
69594: EQUAL
69595: IFFALSE 69616
// points := [ 10 , 5 , 3 ] ;
69597: LD_ADDR_VAR 0 9
69601: PUSH
69602: LD_INT 10
69604: PUSH
69605: LD_INT 5
69607: PUSH
69608: LD_INT 3
69610: PUSH
69611: EMPTY
69612: LIST
69613: LIST
69614: LIST
69615: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69616: LD_VAR 0 6
69620: PPUSH
69621: CALL_OW 257
69625: PUSH
69626: LD_INT 2
69628: PUSH
69629: LD_INT 3
69631: PUSH
69632: LD_INT 4
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: LIST
69639: IN
69640: IFFALSE 69661
// points := [ 3 , 2 , 1 ] ;
69642: LD_ADDR_VAR 0 9
69646: PUSH
69647: LD_INT 3
69649: PUSH
69650: LD_INT 2
69652: PUSH
69653: LD_INT 1
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: LIST
69660: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69661: LD_VAR 0 6
69665: PPUSH
69666: CALL_OW 257
69670: PUSH
69671: LD_INT 5
69673: EQUAL
69674: IFFALSE 69695
// points := [ 130 , 5 , 2 ] ;
69676: LD_ADDR_VAR 0 9
69680: PUSH
69681: LD_INT 130
69683: PUSH
69684: LD_INT 5
69686: PUSH
69687: LD_INT 2
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: LIST
69694: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69695: LD_VAR 0 6
69699: PPUSH
69700: CALL_OW 257
69704: PUSH
69705: LD_INT 8
69707: EQUAL
69708: IFFALSE 69729
// points := [ 35 , 35 , 30 ] ;
69710: LD_ADDR_VAR 0 9
69714: PUSH
69715: LD_INT 35
69717: PUSH
69718: LD_INT 35
69720: PUSH
69721: LD_INT 30
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: LIST
69728: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69729: LD_VAR 0 6
69733: PPUSH
69734: CALL_OW 257
69738: PUSH
69739: LD_INT 9
69741: EQUAL
69742: IFFALSE 69763
// points := [ 20 , 55 , 40 ] ;
69744: LD_ADDR_VAR 0 9
69748: PUSH
69749: LD_INT 20
69751: PUSH
69752: LD_INT 55
69754: PUSH
69755: LD_INT 40
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: LIST
69762: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69763: LD_VAR 0 6
69767: PPUSH
69768: CALL_OW 257
69772: PUSH
69773: LD_INT 12
69775: PUSH
69776: LD_INT 16
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: IN
69783: IFFALSE 69804
// points := [ 5 , 3 , 2 ] ;
69785: LD_ADDR_VAR 0 9
69789: PUSH
69790: LD_INT 5
69792: PUSH
69793: LD_INT 3
69795: PUSH
69796: LD_INT 2
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: LIST
69803: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69804: LD_VAR 0 6
69808: PPUSH
69809: CALL_OW 257
69813: PUSH
69814: LD_INT 17
69816: EQUAL
69817: IFFALSE 69838
// points := [ 100 , 50 , 75 ] ;
69819: LD_ADDR_VAR 0 9
69823: PUSH
69824: LD_INT 100
69826: PUSH
69827: LD_INT 50
69829: PUSH
69830: LD_INT 75
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: LIST
69837: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69838: LD_VAR 0 6
69842: PPUSH
69843: CALL_OW 257
69847: PUSH
69848: LD_INT 15
69850: EQUAL
69851: IFFALSE 69872
// points := [ 10 , 5 , 3 ] ;
69853: LD_ADDR_VAR 0 9
69857: PUSH
69858: LD_INT 10
69860: PUSH
69861: LD_INT 5
69863: PUSH
69864: LD_INT 3
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: LIST
69871: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69872: LD_VAR 0 6
69876: PPUSH
69877: CALL_OW 257
69881: PUSH
69882: LD_INT 14
69884: EQUAL
69885: IFFALSE 69906
// points := [ 10 , 0 , 0 ] ;
69887: LD_ADDR_VAR 0 9
69891: PUSH
69892: LD_INT 10
69894: PUSH
69895: LD_INT 0
69897: PUSH
69898: LD_INT 0
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: LIST
69905: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69906: LD_VAR 0 6
69910: PPUSH
69911: CALL_OW 257
69915: PUSH
69916: LD_INT 11
69918: EQUAL
69919: IFFALSE 69940
// points := [ 30 , 10 , 5 ] ;
69921: LD_ADDR_VAR 0 9
69925: PUSH
69926: LD_INT 30
69928: PUSH
69929: LD_INT 10
69931: PUSH
69932: LD_INT 5
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: LIST
69939: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69940: LD_VAR 0 1
69944: PPUSH
69945: LD_INT 5
69947: PPUSH
69948: CALL_OW 321
69952: PUSH
69953: LD_INT 2
69955: EQUAL
69956: IFFALSE 69973
// bpoints := bpoints * 1.8 ;
69958: LD_ADDR_VAR 0 10
69962: PUSH
69963: LD_VAR 0 10
69967: PUSH
69968: LD_REAL  1.80000000000000E+0000
69971: MUL
69972: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69973: LD_VAR 0 6
69977: PPUSH
69978: CALL_OW 257
69982: PUSH
69983: LD_INT 1
69985: PUSH
69986: LD_INT 2
69988: PUSH
69989: LD_INT 3
69991: PUSH
69992: LD_INT 4
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: LIST
69999: LIST
70000: IN
70001: PUSH
70002: LD_VAR 0 1
70006: PPUSH
70007: LD_INT 51
70009: PPUSH
70010: CALL_OW 321
70014: PUSH
70015: LD_INT 2
70017: EQUAL
70018: AND
70019: IFFALSE 70036
// bpoints := bpoints * 1.2 ;
70021: LD_ADDR_VAR 0 10
70025: PUSH
70026: LD_VAR 0 10
70030: PUSH
70031: LD_REAL  1.20000000000000E+0000
70034: MUL
70035: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
70036: LD_VAR 0 6
70040: PPUSH
70041: CALL_OW 257
70045: PUSH
70046: LD_INT 5
70048: PUSH
70049: LD_INT 7
70051: PUSH
70052: LD_INT 9
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: LIST
70059: IN
70060: PUSH
70061: LD_VAR 0 1
70065: PPUSH
70066: LD_INT 52
70068: PPUSH
70069: CALL_OW 321
70073: PUSH
70074: LD_INT 2
70076: EQUAL
70077: AND
70078: IFFALSE 70095
// bpoints := bpoints * 1.5 ;
70080: LD_ADDR_VAR 0 10
70084: PUSH
70085: LD_VAR 0 10
70089: PUSH
70090: LD_REAL  1.50000000000000E+0000
70093: MUL
70094: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70095: LD_VAR 0 1
70099: PPUSH
70100: LD_INT 66
70102: PPUSH
70103: CALL_OW 321
70107: PUSH
70108: LD_INT 2
70110: EQUAL
70111: IFFALSE 70128
// bpoints := bpoints * 1.1 ;
70113: LD_ADDR_VAR 0 10
70117: PUSH
70118: LD_VAR 0 10
70122: PUSH
70123: LD_REAL  1.10000000000000E+0000
70126: MUL
70127: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70128: LD_ADDR_VAR 0 10
70132: PUSH
70133: LD_VAR 0 10
70137: PUSH
70138: LD_VAR 0 6
70142: PPUSH
70143: LD_INT 1
70145: PPUSH
70146: CALL_OW 259
70150: PUSH
70151: LD_REAL  1.15000000000000E+0000
70154: MUL
70155: MUL
70156: ST_TO_ADDR
// end ; unit_vehicle :
70157: GO 70985
70159: LD_INT 2
70161: DOUBLE
70162: EQUAL
70163: IFTRUE 70167
70165: GO 70973
70167: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70168: LD_VAR 0 6
70172: PPUSH
70173: CALL_OW 264
70177: PUSH
70178: LD_INT 2
70180: PUSH
70181: LD_INT 42
70183: PUSH
70184: LD_INT 24
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: LIST
70191: IN
70192: IFFALSE 70213
// points := [ 25 , 5 , 3 ] ;
70194: LD_ADDR_VAR 0 9
70198: PUSH
70199: LD_INT 25
70201: PUSH
70202: LD_INT 5
70204: PUSH
70205: LD_INT 3
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: LIST
70212: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70213: LD_VAR 0 6
70217: PPUSH
70218: CALL_OW 264
70222: PUSH
70223: LD_INT 4
70225: PUSH
70226: LD_INT 43
70228: PUSH
70229: LD_INT 25
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: LIST
70236: IN
70237: IFFALSE 70258
// points := [ 40 , 15 , 5 ] ;
70239: LD_ADDR_VAR 0 9
70243: PUSH
70244: LD_INT 40
70246: PUSH
70247: LD_INT 15
70249: PUSH
70250: LD_INT 5
70252: PUSH
70253: EMPTY
70254: LIST
70255: LIST
70256: LIST
70257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70258: LD_VAR 0 6
70262: PPUSH
70263: CALL_OW 264
70267: PUSH
70268: LD_INT 3
70270: PUSH
70271: LD_INT 23
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: IN
70278: IFFALSE 70299
// points := [ 7 , 25 , 8 ] ;
70280: LD_ADDR_VAR 0 9
70284: PUSH
70285: LD_INT 7
70287: PUSH
70288: LD_INT 25
70290: PUSH
70291: LD_INT 8
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: LIST
70298: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70299: LD_VAR 0 6
70303: PPUSH
70304: CALL_OW 264
70308: PUSH
70309: LD_INT 5
70311: PUSH
70312: LD_INT 27
70314: PUSH
70315: LD_INT 44
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: LIST
70322: IN
70323: IFFALSE 70344
// points := [ 14 , 50 , 16 ] ;
70325: LD_ADDR_VAR 0 9
70329: PUSH
70330: LD_INT 14
70332: PUSH
70333: LD_INT 50
70335: PUSH
70336: LD_INT 16
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: LIST
70343: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70344: LD_VAR 0 6
70348: PPUSH
70349: CALL_OW 264
70353: PUSH
70354: LD_INT 6
70356: PUSH
70357: LD_INT 46
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: IN
70364: IFFALSE 70385
// points := [ 32 , 120 , 70 ] ;
70366: LD_ADDR_VAR 0 9
70370: PUSH
70371: LD_INT 32
70373: PUSH
70374: LD_INT 120
70376: PUSH
70377: LD_INT 70
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: LIST
70384: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
70385: LD_VAR 0 6
70389: PPUSH
70390: CALL_OW 264
70394: PUSH
70395: LD_INT 7
70397: PUSH
70398: LD_INT 28
70400: PUSH
70401: LD_INT 45
70403: PUSH
70404: LD_INT 92
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: LIST
70411: LIST
70412: IN
70413: IFFALSE 70434
// points := [ 35 , 20 , 45 ] ;
70415: LD_ADDR_VAR 0 9
70419: PUSH
70420: LD_INT 35
70422: PUSH
70423: LD_INT 20
70425: PUSH
70426: LD_INT 45
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: LIST
70433: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70434: LD_VAR 0 6
70438: PPUSH
70439: CALL_OW 264
70443: PUSH
70444: LD_INT 47
70446: PUSH
70447: EMPTY
70448: LIST
70449: IN
70450: IFFALSE 70471
// points := [ 67 , 45 , 75 ] ;
70452: LD_ADDR_VAR 0 9
70456: PUSH
70457: LD_INT 67
70459: PUSH
70460: LD_INT 45
70462: PUSH
70463: LD_INT 75
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: LIST
70470: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70471: LD_VAR 0 6
70475: PPUSH
70476: CALL_OW 264
70480: PUSH
70481: LD_INT 26
70483: PUSH
70484: EMPTY
70485: LIST
70486: IN
70487: IFFALSE 70508
// points := [ 120 , 30 , 80 ] ;
70489: LD_ADDR_VAR 0 9
70493: PUSH
70494: LD_INT 120
70496: PUSH
70497: LD_INT 30
70499: PUSH
70500: LD_INT 80
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: LIST
70507: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70508: LD_VAR 0 6
70512: PPUSH
70513: CALL_OW 264
70517: PUSH
70518: LD_INT 22
70520: PUSH
70521: EMPTY
70522: LIST
70523: IN
70524: IFFALSE 70545
// points := [ 40 , 1 , 1 ] ;
70526: LD_ADDR_VAR 0 9
70530: PUSH
70531: LD_INT 40
70533: PUSH
70534: LD_INT 1
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: LIST
70544: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70545: LD_VAR 0 6
70549: PPUSH
70550: CALL_OW 264
70554: PUSH
70555: LD_INT 29
70557: PUSH
70558: EMPTY
70559: LIST
70560: IN
70561: IFFALSE 70582
// points := [ 70 , 200 , 400 ] ;
70563: LD_ADDR_VAR 0 9
70567: PUSH
70568: LD_INT 70
70570: PUSH
70571: LD_INT 200
70573: PUSH
70574: LD_INT 400
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: LIST
70581: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70582: LD_VAR 0 6
70586: PPUSH
70587: CALL_OW 264
70591: PUSH
70592: LD_INT 14
70594: PUSH
70595: LD_INT 53
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: IN
70602: IFFALSE 70623
// points := [ 40 , 10 , 20 ] ;
70604: LD_ADDR_VAR 0 9
70608: PUSH
70609: LD_INT 40
70611: PUSH
70612: LD_INT 10
70614: PUSH
70615: LD_INT 20
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: LIST
70622: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70623: LD_VAR 0 6
70627: PPUSH
70628: CALL_OW 264
70632: PUSH
70633: LD_INT 9
70635: PUSH
70636: EMPTY
70637: LIST
70638: IN
70639: IFFALSE 70660
// points := [ 5 , 70 , 20 ] ;
70641: LD_ADDR_VAR 0 9
70645: PUSH
70646: LD_INT 5
70648: PUSH
70649: LD_INT 70
70651: PUSH
70652: LD_INT 20
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: LIST
70659: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70660: LD_VAR 0 6
70664: PPUSH
70665: CALL_OW 264
70669: PUSH
70670: LD_INT 10
70672: PUSH
70673: EMPTY
70674: LIST
70675: IN
70676: IFFALSE 70697
// points := [ 35 , 110 , 70 ] ;
70678: LD_ADDR_VAR 0 9
70682: PUSH
70683: LD_INT 35
70685: PUSH
70686: LD_INT 110
70688: PUSH
70689: LD_INT 70
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: LIST
70696: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70697: LD_VAR 0 6
70701: PPUSH
70702: CALL_OW 265
70706: PUSH
70707: LD_INT 25
70709: EQUAL
70710: IFFALSE 70731
// points := [ 80 , 65 , 100 ] ;
70712: LD_ADDR_VAR 0 9
70716: PUSH
70717: LD_INT 80
70719: PUSH
70720: LD_INT 65
70722: PUSH
70723: LD_INT 100
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: LIST
70730: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70731: LD_VAR 0 6
70735: PPUSH
70736: CALL_OW 263
70740: PUSH
70741: LD_INT 1
70743: EQUAL
70744: IFFALSE 70779
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70746: LD_ADDR_VAR 0 10
70750: PUSH
70751: LD_VAR 0 10
70755: PUSH
70756: LD_VAR 0 6
70760: PPUSH
70761: CALL_OW 311
70765: PPUSH
70766: LD_INT 3
70768: PPUSH
70769: CALL_OW 259
70773: PUSH
70774: LD_INT 4
70776: MUL
70777: MUL
70778: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70779: LD_VAR 0 6
70783: PPUSH
70784: CALL_OW 263
70788: PUSH
70789: LD_INT 2
70791: EQUAL
70792: IFFALSE 70843
// begin j := IsControledBy ( i ) ;
70794: LD_ADDR_VAR 0 7
70798: PUSH
70799: LD_VAR 0 6
70803: PPUSH
70804: CALL_OW 312
70808: ST_TO_ADDR
// if j then
70809: LD_VAR 0 7
70813: IFFALSE 70843
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70815: LD_ADDR_VAR 0 10
70819: PUSH
70820: LD_VAR 0 10
70824: PUSH
70825: LD_VAR 0 7
70829: PPUSH
70830: LD_INT 3
70832: PPUSH
70833: CALL_OW 259
70837: PUSH
70838: LD_INT 3
70840: MUL
70841: MUL
70842: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70843: LD_VAR 0 6
70847: PPUSH
70848: CALL_OW 264
70852: PUSH
70853: LD_INT 5
70855: PUSH
70856: LD_INT 6
70858: PUSH
70859: LD_INT 46
70861: PUSH
70862: LD_INT 44
70864: PUSH
70865: LD_INT 47
70867: PUSH
70868: LD_INT 45
70870: PUSH
70871: LD_INT 28
70873: PUSH
70874: LD_INT 7
70876: PUSH
70877: LD_INT 27
70879: PUSH
70880: LD_INT 29
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: IN
70895: PUSH
70896: LD_VAR 0 1
70900: PPUSH
70901: LD_INT 52
70903: PPUSH
70904: CALL_OW 321
70908: PUSH
70909: LD_INT 2
70911: EQUAL
70912: AND
70913: IFFALSE 70930
// bpoints := bpoints * 1.2 ;
70915: LD_ADDR_VAR 0 10
70919: PUSH
70920: LD_VAR 0 10
70924: PUSH
70925: LD_REAL  1.20000000000000E+0000
70928: MUL
70929: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70930: LD_VAR 0 6
70934: PPUSH
70935: CALL_OW 264
70939: PUSH
70940: LD_INT 6
70942: PUSH
70943: LD_INT 46
70945: PUSH
70946: LD_INT 47
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: LIST
70953: IN
70954: IFFALSE 70971
// bpoints := bpoints * 1.2 ;
70956: LD_ADDR_VAR 0 10
70960: PUSH
70961: LD_VAR 0 10
70965: PUSH
70966: LD_REAL  1.20000000000000E+0000
70969: MUL
70970: ST_TO_ADDR
// end ; unit_building :
70971: GO 70985
70973: LD_INT 3
70975: DOUBLE
70976: EQUAL
70977: IFTRUE 70981
70979: GO 70984
70981: POP
// ; end ;
70982: GO 70985
70984: POP
// for j = 1 to 3 do
70985: LD_ADDR_VAR 0 7
70989: PUSH
70990: DOUBLE
70991: LD_INT 1
70993: DEC
70994: ST_TO_ADDR
70995: LD_INT 3
70997: PUSH
70998: FOR_TO
70999: IFFALSE 71052
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
71001: LD_ADDR_VAR 0 5
71005: PUSH
71006: LD_VAR 0 5
71010: PPUSH
71011: LD_VAR 0 7
71015: PPUSH
71016: LD_VAR 0 5
71020: PUSH
71021: LD_VAR 0 7
71025: ARRAY
71026: PUSH
71027: LD_VAR 0 9
71031: PUSH
71032: LD_VAR 0 7
71036: ARRAY
71037: PUSH
71038: LD_VAR 0 10
71042: MUL
71043: PLUS
71044: PPUSH
71045: CALL_OW 1
71049: ST_TO_ADDR
71050: GO 70998
71052: POP
71053: POP
// end ;
71054: GO 69533
71056: POP
71057: POP
// result := Replace ( result , 4 , tmp ) ;
71058: LD_ADDR_VAR 0 5
71062: PUSH
71063: LD_VAR 0 5
71067: PPUSH
71068: LD_INT 4
71070: PPUSH
71071: LD_VAR 0 8
71075: PPUSH
71076: CALL_OW 1
71080: ST_TO_ADDR
// end ;
71081: LD_VAR 0 5
71085: RET
// export function DangerAtRange ( unit , range ) ; begin
71086: LD_INT 0
71088: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71089: LD_ADDR_VAR 0 3
71093: PUSH
71094: LD_VAR 0 1
71098: PPUSH
71099: CALL_OW 255
71103: PPUSH
71104: LD_VAR 0 1
71108: PPUSH
71109: CALL_OW 250
71113: PPUSH
71114: LD_VAR 0 1
71118: PPUSH
71119: CALL_OW 251
71123: PPUSH
71124: LD_VAR 0 2
71128: PPUSH
71129: CALL 69385 0 4
71133: ST_TO_ADDR
// end ;
71134: LD_VAR 0 3
71138: RET
// export function DangerInArea ( side , area ) ; begin
71139: LD_INT 0
71141: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71142: LD_ADDR_VAR 0 3
71146: PUSH
71147: LD_VAR 0 2
71151: PPUSH
71152: LD_INT 81
71154: PUSH
71155: LD_VAR 0 1
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PPUSH
71164: CALL_OW 70
71168: ST_TO_ADDR
// end ;
71169: LD_VAR 0 3
71173: RET
// export function IsExtension ( b ) ; begin
71174: LD_INT 0
71176: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71177: LD_ADDR_VAR 0 2
71181: PUSH
71182: LD_VAR 0 1
71186: PUSH
71187: LD_INT 23
71189: PUSH
71190: LD_INT 20
71192: PUSH
71193: LD_INT 22
71195: PUSH
71196: LD_INT 17
71198: PUSH
71199: LD_INT 24
71201: PUSH
71202: LD_INT 21
71204: PUSH
71205: LD_INT 19
71207: PUSH
71208: LD_INT 16
71210: PUSH
71211: LD_INT 25
71213: PUSH
71214: LD_INT 18
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: LIST
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: IN
71229: ST_TO_ADDR
// end ;
71230: LD_VAR 0 2
71234: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71235: LD_INT 0
71237: PPUSH
71238: PPUSH
71239: PPUSH
// result := [ ] ;
71240: LD_ADDR_VAR 0 4
71244: PUSH
71245: EMPTY
71246: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71247: LD_ADDR_VAR 0 5
71251: PUSH
71252: LD_VAR 0 2
71256: PPUSH
71257: LD_INT 21
71259: PUSH
71260: LD_INT 3
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PPUSH
71267: CALL_OW 70
71271: ST_TO_ADDR
// if not tmp then
71272: LD_VAR 0 5
71276: NOT
71277: IFFALSE 71281
// exit ;
71279: GO 71345
// if checkLink then
71281: LD_VAR 0 3
71285: IFFALSE 71335
// begin for i in tmp do
71287: LD_ADDR_VAR 0 6
71291: PUSH
71292: LD_VAR 0 5
71296: PUSH
71297: FOR_IN
71298: IFFALSE 71333
// if GetBase ( i ) <> base then
71300: LD_VAR 0 6
71304: PPUSH
71305: CALL_OW 274
71309: PUSH
71310: LD_VAR 0 1
71314: NONEQUAL
71315: IFFALSE 71331
// ComLinkToBase ( base , i ) ;
71317: LD_VAR 0 1
71321: PPUSH
71322: LD_VAR 0 6
71326: PPUSH
71327: CALL_OW 169
71331: GO 71297
71333: POP
71334: POP
// end ; result := tmp ;
71335: LD_ADDR_VAR 0 4
71339: PUSH
71340: LD_VAR 0 5
71344: ST_TO_ADDR
// end ;
71345: LD_VAR 0 4
71349: RET
// export function ComComplete ( units , b ) ; var i ; begin
71350: LD_INT 0
71352: PPUSH
71353: PPUSH
// if not units then
71354: LD_VAR 0 1
71358: NOT
71359: IFFALSE 71363
// exit ;
71361: GO 71453
// for i in units do
71363: LD_ADDR_VAR 0 4
71367: PUSH
71368: LD_VAR 0 1
71372: PUSH
71373: FOR_IN
71374: IFFALSE 71451
// if BuildingStatus ( b ) = bs_build then
71376: LD_VAR 0 2
71380: PPUSH
71381: CALL_OW 461
71385: PUSH
71386: LD_INT 1
71388: EQUAL
71389: IFFALSE 71449
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71391: LD_VAR 0 4
71395: PPUSH
71396: LD_STRING h
71398: PUSH
71399: LD_VAR 0 2
71403: PPUSH
71404: CALL_OW 250
71408: PUSH
71409: LD_VAR 0 2
71413: PPUSH
71414: CALL_OW 251
71418: PUSH
71419: LD_VAR 0 2
71423: PUSH
71424: LD_INT 0
71426: PUSH
71427: LD_INT 0
71429: PUSH
71430: LD_INT 0
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: LIST
71441: PUSH
71442: EMPTY
71443: LIST
71444: PPUSH
71445: CALL_OW 446
71449: GO 71373
71451: POP
71452: POP
// end ;
71453: LD_VAR 0 3
71457: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71458: LD_INT 0
71460: PPUSH
71461: PPUSH
71462: PPUSH
71463: PPUSH
71464: PPUSH
71465: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
71466: LD_VAR 0 1
71470: NOT
71471: PUSH
71472: LD_VAR 0 1
71476: PPUSH
71477: CALL_OW 263
71481: PUSH
71482: LD_INT 2
71484: NONEQUAL
71485: OR
71486: IFFALSE 71490
// exit ;
71488: GO 71806
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71490: LD_ADDR_VAR 0 6
71494: PUSH
71495: LD_INT 22
71497: PUSH
71498: LD_VAR 0 1
71502: PPUSH
71503: CALL_OW 255
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 2
71514: PUSH
71515: LD_INT 30
71517: PUSH
71518: LD_INT 36
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PUSH
71525: LD_INT 34
71527: PUSH
71528: LD_INT 31
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: LIST
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: PPUSH
71544: CALL_OW 69
71548: ST_TO_ADDR
// if not tmp then
71549: LD_VAR 0 6
71553: NOT
71554: IFFALSE 71558
// exit ;
71556: GO 71806
// result := [ ] ;
71558: LD_ADDR_VAR 0 2
71562: PUSH
71563: EMPTY
71564: ST_TO_ADDR
// for i in tmp do
71565: LD_ADDR_VAR 0 3
71569: PUSH
71570: LD_VAR 0 6
71574: PUSH
71575: FOR_IN
71576: IFFALSE 71647
// begin t := UnitsInside ( i ) ;
71578: LD_ADDR_VAR 0 4
71582: PUSH
71583: LD_VAR 0 3
71587: PPUSH
71588: CALL_OW 313
71592: ST_TO_ADDR
// if t then
71593: LD_VAR 0 4
71597: IFFALSE 71645
// for j in t do
71599: LD_ADDR_VAR 0 7
71603: PUSH
71604: LD_VAR 0 4
71608: PUSH
71609: FOR_IN
71610: IFFALSE 71643
// result := Replace ( result , result + 1 , j ) ;
71612: LD_ADDR_VAR 0 2
71616: PUSH
71617: LD_VAR 0 2
71621: PPUSH
71622: LD_VAR 0 2
71626: PUSH
71627: LD_INT 1
71629: PLUS
71630: PPUSH
71631: LD_VAR 0 7
71635: PPUSH
71636: CALL_OW 1
71640: ST_TO_ADDR
71641: GO 71609
71643: POP
71644: POP
// end ;
71645: GO 71575
71647: POP
71648: POP
// if not result then
71649: LD_VAR 0 2
71653: NOT
71654: IFFALSE 71658
// exit ;
71656: GO 71806
// mech := result [ 1 ] ;
71658: LD_ADDR_VAR 0 5
71662: PUSH
71663: LD_VAR 0 2
71667: PUSH
71668: LD_INT 1
71670: ARRAY
71671: ST_TO_ADDR
// if result > 1 then
71672: LD_VAR 0 2
71676: PUSH
71677: LD_INT 1
71679: GREATER
71680: IFFALSE 71792
// begin for i = 2 to result do
71682: LD_ADDR_VAR 0 3
71686: PUSH
71687: DOUBLE
71688: LD_INT 2
71690: DEC
71691: ST_TO_ADDR
71692: LD_VAR 0 2
71696: PUSH
71697: FOR_TO
71698: IFFALSE 71790
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71700: LD_ADDR_VAR 0 4
71704: PUSH
71705: LD_VAR 0 2
71709: PUSH
71710: LD_VAR 0 3
71714: ARRAY
71715: PPUSH
71716: LD_INT 3
71718: PPUSH
71719: CALL_OW 259
71723: PUSH
71724: LD_VAR 0 2
71728: PUSH
71729: LD_VAR 0 3
71733: ARRAY
71734: PPUSH
71735: CALL_OW 432
71739: MINUS
71740: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71741: LD_VAR 0 4
71745: PUSH
71746: LD_VAR 0 5
71750: PPUSH
71751: LD_INT 3
71753: PPUSH
71754: CALL_OW 259
71758: PUSH
71759: LD_VAR 0 5
71763: PPUSH
71764: CALL_OW 432
71768: MINUS
71769: GREATEREQUAL
71770: IFFALSE 71788
// mech := result [ i ] ;
71772: LD_ADDR_VAR 0 5
71776: PUSH
71777: LD_VAR 0 2
71781: PUSH
71782: LD_VAR 0 3
71786: ARRAY
71787: ST_TO_ADDR
// end ;
71788: GO 71697
71790: POP
71791: POP
// end ; ComLinkTo ( vehicle , mech ) ;
71792: LD_VAR 0 1
71796: PPUSH
71797: LD_VAR 0 5
71801: PPUSH
71802: CALL_OW 135
// end ;
71806: LD_VAR 0 2
71810: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71811: LD_INT 0
71813: PPUSH
71814: PPUSH
71815: PPUSH
71816: PPUSH
71817: PPUSH
71818: PPUSH
71819: PPUSH
71820: PPUSH
71821: PPUSH
71822: PPUSH
71823: PPUSH
71824: PPUSH
71825: PPUSH
// result := [ ] ;
71826: LD_ADDR_VAR 0 7
71830: PUSH
71831: EMPTY
71832: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71833: LD_VAR 0 1
71837: PPUSH
71838: CALL_OW 266
71842: PUSH
71843: LD_INT 0
71845: PUSH
71846: LD_INT 1
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: IN
71853: NOT
71854: IFFALSE 71858
// exit ;
71856: GO 73492
// if name then
71858: LD_VAR 0 3
71862: IFFALSE 71878
// SetBName ( base_dep , name ) ;
71864: LD_VAR 0 1
71868: PPUSH
71869: LD_VAR 0 3
71873: PPUSH
71874: CALL_OW 500
// base := GetBase ( base_dep ) ;
71878: LD_ADDR_VAR 0 15
71882: PUSH
71883: LD_VAR 0 1
71887: PPUSH
71888: CALL_OW 274
71892: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71893: LD_ADDR_VAR 0 16
71897: PUSH
71898: LD_VAR 0 1
71902: PPUSH
71903: CALL_OW 255
71907: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71908: LD_ADDR_VAR 0 17
71912: PUSH
71913: LD_VAR 0 1
71917: PPUSH
71918: CALL_OW 248
71922: ST_TO_ADDR
// if sources then
71923: LD_VAR 0 5
71927: IFFALSE 71974
// for i = 1 to 3 do
71929: LD_ADDR_VAR 0 8
71933: PUSH
71934: DOUBLE
71935: LD_INT 1
71937: DEC
71938: ST_TO_ADDR
71939: LD_INT 3
71941: PUSH
71942: FOR_TO
71943: IFFALSE 71972
// AddResourceType ( base , i , sources [ i ] ) ;
71945: LD_VAR 0 15
71949: PPUSH
71950: LD_VAR 0 8
71954: PPUSH
71955: LD_VAR 0 5
71959: PUSH
71960: LD_VAR 0 8
71964: ARRAY
71965: PPUSH
71966: CALL_OW 276
71970: GO 71942
71972: POP
71973: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
71974: LD_ADDR_VAR 0 18
71978: PUSH
71979: LD_VAR 0 15
71983: PPUSH
71984: LD_VAR 0 2
71988: PPUSH
71989: LD_INT 1
71991: PPUSH
71992: CALL 71235 0 3
71996: ST_TO_ADDR
// InitHc ;
71997: CALL_OW 19
// InitUc ;
72001: CALL_OW 18
// uc_side := side ;
72005: LD_ADDR_OWVAR 20
72009: PUSH
72010: LD_VAR 0 16
72014: ST_TO_ADDR
// uc_nation := nation ;
72015: LD_ADDR_OWVAR 21
72019: PUSH
72020: LD_VAR 0 17
72024: ST_TO_ADDR
// if buildings then
72025: LD_VAR 0 18
72029: IFFALSE 73351
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
72031: LD_ADDR_VAR 0 19
72035: PUSH
72036: LD_VAR 0 18
72040: PPUSH
72041: LD_INT 2
72043: PUSH
72044: LD_INT 30
72046: PUSH
72047: LD_INT 29
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 30
72056: PUSH
72057: LD_INT 30
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: PPUSH
72069: CALL_OW 72
72073: ST_TO_ADDR
// if tmp then
72074: LD_VAR 0 19
72078: IFFALSE 72126
// for i in tmp do
72080: LD_ADDR_VAR 0 8
72084: PUSH
72085: LD_VAR 0 19
72089: PUSH
72090: FOR_IN
72091: IFFALSE 72124
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
72093: LD_VAR 0 8
72097: PPUSH
72098: CALL_OW 250
72102: PPUSH
72103: LD_VAR 0 8
72107: PPUSH
72108: CALL_OW 251
72112: PPUSH
72113: LD_VAR 0 16
72117: PPUSH
72118: CALL_OW 441
72122: GO 72090
72124: POP
72125: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72126: LD_VAR 0 18
72130: PPUSH
72131: LD_INT 2
72133: PUSH
72134: LD_INT 30
72136: PUSH
72137: LD_INT 32
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PUSH
72144: LD_INT 30
72146: PUSH
72147: LD_INT 33
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: LIST
72158: PPUSH
72159: CALL_OW 72
72163: IFFALSE 72251
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72165: LD_ADDR_VAR 0 8
72169: PUSH
72170: LD_VAR 0 18
72174: PPUSH
72175: LD_INT 2
72177: PUSH
72178: LD_INT 30
72180: PUSH
72181: LD_INT 32
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: PUSH
72188: LD_INT 30
72190: PUSH
72191: LD_INT 33
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: LIST
72202: PPUSH
72203: CALL_OW 72
72207: PUSH
72208: FOR_IN
72209: IFFALSE 72249
// begin if not GetBWeapon ( i ) then
72211: LD_VAR 0 8
72215: PPUSH
72216: CALL_OW 269
72220: NOT
72221: IFFALSE 72247
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72223: LD_VAR 0 8
72227: PPUSH
72228: LD_VAR 0 8
72232: PPUSH
72233: LD_VAR 0 2
72237: PPUSH
72238: CALL 73497 0 2
72242: PPUSH
72243: CALL_OW 431
// end ;
72247: GO 72208
72249: POP
72250: POP
// end ; for i = 1 to personel do
72251: LD_ADDR_VAR 0 8
72255: PUSH
72256: DOUBLE
72257: LD_INT 1
72259: DEC
72260: ST_TO_ADDR
72261: LD_VAR 0 6
72265: PUSH
72266: FOR_TO
72267: IFFALSE 73331
// begin if i > 4 then
72269: LD_VAR 0 8
72273: PUSH
72274: LD_INT 4
72276: GREATER
72277: IFFALSE 72281
// break ;
72279: GO 73331
// case i of 1 :
72281: LD_VAR 0 8
72285: PUSH
72286: LD_INT 1
72288: DOUBLE
72289: EQUAL
72290: IFTRUE 72294
72292: GO 72374
72294: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72295: LD_ADDR_VAR 0 12
72299: PUSH
72300: LD_VAR 0 18
72304: PPUSH
72305: LD_INT 22
72307: PUSH
72308: LD_VAR 0 16
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 58
72319: PUSH
72320: EMPTY
72321: LIST
72322: PUSH
72323: LD_INT 2
72325: PUSH
72326: LD_INT 30
72328: PUSH
72329: LD_INT 32
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 30
72338: PUSH
72339: LD_INT 4
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 30
72348: PUSH
72349: LD_INT 5
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: LIST
72360: LIST
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: LIST
72366: PPUSH
72367: CALL_OW 72
72371: ST_TO_ADDR
72372: GO 72596
72374: LD_INT 2
72376: DOUBLE
72377: EQUAL
72378: IFTRUE 72382
72380: GO 72444
72382: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72383: LD_ADDR_VAR 0 12
72387: PUSH
72388: LD_VAR 0 18
72392: PPUSH
72393: LD_INT 22
72395: PUSH
72396: LD_VAR 0 16
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 2
72407: PUSH
72408: LD_INT 30
72410: PUSH
72411: LD_INT 0
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 30
72420: PUSH
72421: LD_INT 1
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: LIST
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PPUSH
72437: CALL_OW 72
72441: ST_TO_ADDR
72442: GO 72596
72444: LD_INT 3
72446: DOUBLE
72447: EQUAL
72448: IFTRUE 72452
72450: GO 72514
72452: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72453: LD_ADDR_VAR 0 12
72457: PUSH
72458: LD_VAR 0 18
72462: PPUSH
72463: LD_INT 22
72465: PUSH
72466: LD_VAR 0 16
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PUSH
72475: LD_INT 2
72477: PUSH
72478: LD_INT 30
72480: PUSH
72481: LD_INT 2
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 30
72490: PUSH
72491: LD_INT 3
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: LIST
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PPUSH
72507: CALL_OW 72
72511: ST_TO_ADDR
72512: GO 72596
72514: LD_INT 4
72516: DOUBLE
72517: EQUAL
72518: IFTRUE 72522
72520: GO 72595
72522: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72523: LD_ADDR_VAR 0 12
72527: PUSH
72528: LD_VAR 0 18
72532: PPUSH
72533: LD_INT 22
72535: PUSH
72536: LD_VAR 0 16
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 2
72547: PUSH
72548: LD_INT 30
72550: PUSH
72551: LD_INT 6
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 30
72560: PUSH
72561: LD_INT 7
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 30
72570: PUSH
72571: LD_INT 8
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: LIST
72582: LIST
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PPUSH
72588: CALL_OW 72
72592: ST_TO_ADDR
72593: GO 72596
72595: POP
// if i = 1 then
72596: LD_VAR 0 8
72600: PUSH
72601: LD_INT 1
72603: EQUAL
72604: IFFALSE 72715
// begin tmp := [ ] ;
72606: LD_ADDR_VAR 0 19
72610: PUSH
72611: EMPTY
72612: ST_TO_ADDR
// for j in f do
72613: LD_ADDR_VAR 0 9
72617: PUSH
72618: LD_VAR 0 12
72622: PUSH
72623: FOR_IN
72624: IFFALSE 72697
// if GetBType ( j ) = b_bunker then
72626: LD_VAR 0 9
72630: PPUSH
72631: CALL_OW 266
72635: PUSH
72636: LD_INT 32
72638: EQUAL
72639: IFFALSE 72666
// tmp := Insert ( tmp , 1 , j ) else
72641: LD_ADDR_VAR 0 19
72645: PUSH
72646: LD_VAR 0 19
72650: PPUSH
72651: LD_INT 1
72653: PPUSH
72654: LD_VAR 0 9
72658: PPUSH
72659: CALL_OW 2
72663: ST_TO_ADDR
72664: GO 72695
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72666: LD_ADDR_VAR 0 19
72670: PUSH
72671: LD_VAR 0 19
72675: PPUSH
72676: LD_VAR 0 19
72680: PUSH
72681: LD_INT 1
72683: PLUS
72684: PPUSH
72685: LD_VAR 0 9
72689: PPUSH
72690: CALL_OW 2
72694: ST_TO_ADDR
72695: GO 72623
72697: POP
72698: POP
// if tmp then
72699: LD_VAR 0 19
72703: IFFALSE 72715
// f := tmp ;
72705: LD_ADDR_VAR 0 12
72709: PUSH
72710: LD_VAR 0 19
72714: ST_TO_ADDR
// end ; x := personel [ i ] ;
72715: LD_ADDR_VAR 0 13
72719: PUSH
72720: LD_VAR 0 6
72724: PUSH
72725: LD_VAR 0 8
72729: ARRAY
72730: ST_TO_ADDR
// if x = - 1 then
72731: LD_VAR 0 13
72735: PUSH
72736: LD_INT 1
72738: NEG
72739: EQUAL
72740: IFFALSE 72949
// begin for j in f do
72742: LD_ADDR_VAR 0 9
72746: PUSH
72747: LD_VAR 0 12
72751: PUSH
72752: FOR_IN
72753: IFFALSE 72945
// repeat InitHc ;
72755: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72759: LD_VAR 0 9
72763: PPUSH
72764: CALL_OW 266
72768: PUSH
72769: LD_INT 5
72771: EQUAL
72772: IFFALSE 72842
// begin if UnitsInside ( j ) < 3 then
72774: LD_VAR 0 9
72778: PPUSH
72779: CALL_OW 313
72783: PUSH
72784: LD_INT 3
72786: LESS
72787: IFFALSE 72823
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72789: LD_INT 0
72791: PPUSH
72792: LD_INT 5
72794: PUSH
72795: LD_INT 8
72797: PUSH
72798: LD_INT 9
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: LIST
72805: PUSH
72806: LD_VAR 0 17
72810: ARRAY
72811: PPUSH
72812: LD_VAR 0 4
72816: PPUSH
72817: CALL_OW 380
72821: GO 72840
// PrepareHuman ( false , i , skill ) ;
72823: LD_INT 0
72825: PPUSH
72826: LD_VAR 0 8
72830: PPUSH
72831: LD_VAR 0 4
72835: PPUSH
72836: CALL_OW 380
// end else
72840: GO 72859
// PrepareHuman ( false , i , skill ) ;
72842: LD_INT 0
72844: PPUSH
72845: LD_VAR 0 8
72849: PPUSH
72850: LD_VAR 0 4
72854: PPUSH
72855: CALL_OW 380
// un := CreateHuman ;
72859: LD_ADDR_VAR 0 14
72863: PUSH
72864: CALL_OW 44
72868: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72869: LD_ADDR_VAR 0 7
72873: PUSH
72874: LD_VAR 0 7
72878: PPUSH
72879: LD_INT 1
72881: PPUSH
72882: LD_VAR 0 14
72886: PPUSH
72887: CALL_OW 2
72891: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72892: LD_VAR 0 14
72896: PPUSH
72897: LD_VAR 0 9
72901: PPUSH
72902: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72906: LD_VAR 0 9
72910: PPUSH
72911: CALL_OW 313
72915: PUSH
72916: LD_INT 6
72918: EQUAL
72919: PUSH
72920: LD_VAR 0 9
72924: PPUSH
72925: CALL_OW 266
72929: PUSH
72930: LD_INT 32
72932: PUSH
72933: LD_INT 31
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: IN
72940: OR
72941: IFFALSE 72755
72943: GO 72752
72945: POP
72946: POP
// end else
72947: GO 73329
// for j = 1 to x do
72949: LD_ADDR_VAR 0 9
72953: PUSH
72954: DOUBLE
72955: LD_INT 1
72957: DEC
72958: ST_TO_ADDR
72959: LD_VAR 0 13
72963: PUSH
72964: FOR_TO
72965: IFFALSE 73327
// begin InitHc ;
72967: CALL_OW 19
// if not f then
72971: LD_VAR 0 12
72975: NOT
72976: IFFALSE 73065
// begin PrepareHuman ( false , i , skill ) ;
72978: LD_INT 0
72980: PPUSH
72981: LD_VAR 0 8
72985: PPUSH
72986: LD_VAR 0 4
72990: PPUSH
72991: CALL_OW 380
// un := CreateHuman ;
72995: LD_ADDR_VAR 0 14
72999: PUSH
73000: CALL_OW 44
73004: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73005: LD_ADDR_VAR 0 7
73009: PUSH
73010: LD_VAR 0 7
73014: PPUSH
73015: LD_INT 1
73017: PPUSH
73018: LD_VAR 0 14
73022: PPUSH
73023: CALL_OW 2
73027: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73028: LD_VAR 0 14
73032: PPUSH
73033: LD_VAR 0 1
73037: PPUSH
73038: CALL_OW 250
73042: PPUSH
73043: LD_VAR 0 1
73047: PPUSH
73048: CALL_OW 251
73052: PPUSH
73053: LD_INT 10
73055: PPUSH
73056: LD_INT 0
73058: PPUSH
73059: CALL_OW 50
// continue ;
73063: GO 72964
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
73065: LD_VAR 0 12
73069: PUSH
73070: LD_INT 1
73072: ARRAY
73073: PPUSH
73074: CALL_OW 313
73078: PUSH
73079: LD_VAR 0 12
73083: PUSH
73084: LD_INT 1
73086: ARRAY
73087: PPUSH
73088: CALL_OW 266
73092: PUSH
73093: LD_INT 32
73095: PUSH
73096: LD_INT 31
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: IN
73103: AND
73104: PUSH
73105: LD_VAR 0 12
73109: PUSH
73110: LD_INT 1
73112: ARRAY
73113: PPUSH
73114: CALL_OW 313
73118: PUSH
73119: LD_INT 6
73121: EQUAL
73122: OR
73123: IFFALSE 73143
// f := Delete ( f , 1 ) ;
73125: LD_ADDR_VAR 0 12
73129: PUSH
73130: LD_VAR 0 12
73134: PPUSH
73135: LD_INT 1
73137: PPUSH
73138: CALL_OW 3
73142: ST_TO_ADDR
// if not f then
73143: LD_VAR 0 12
73147: NOT
73148: IFFALSE 73166
// begin x := x + 2 ;
73150: LD_ADDR_VAR 0 13
73154: PUSH
73155: LD_VAR 0 13
73159: PUSH
73160: LD_INT 2
73162: PLUS
73163: ST_TO_ADDR
// continue ;
73164: GO 72964
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73166: LD_VAR 0 12
73170: PUSH
73171: LD_INT 1
73173: ARRAY
73174: PPUSH
73175: CALL_OW 266
73179: PUSH
73180: LD_INT 5
73182: EQUAL
73183: IFFALSE 73257
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73185: LD_VAR 0 12
73189: PUSH
73190: LD_INT 1
73192: ARRAY
73193: PPUSH
73194: CALL_OW 313
73198: PUSH
73199: LD_INT 3
73201: LESS
73202: IFFALSE 73238
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73204: LD_INT 0
73206: PPUSH
73207: LD_INT 5
73209: PUSH
73210: LD_INT 8
73212: PUSH
73213: LD_INT 9
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: LIST
73220: PUSH
73221: LD_VAR 0 17
73225: ARRAY
73226: PPUSH
73227: LD_VAR 0 4
73231: PPUSH
73232: CALL_OW 380
73236: GO 73255
// PrepareHuman ( false , i , skill ) ;
73238: LD_INT 0
73240: PPUSH
73241: LD_VAR 0 8
73245: PPUSH
73246: LD_VAR 0 4
73250: PPUSH
73251: CALL_OW 380
// end else
73255: GO 73274
// PrepareHuman ( false , i , skill ) ;
73257: LD_INT 0
73259: PPUSH
73260: LD_VAR 0 8
73264: PPUSH
73265: LD_VAR 0 4
73269: PPUSH
73270: CALL_OW 380
// un := CreateHuman ;
73274: LD_ADDR_VAR 0 14
73278: PUSH
73279: CALL_OW 44
73283: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73284: LD_ADDR_VAR 0 7
73288: PUSH
73289: LD_VAR 0 7
73293: PPUSH
73294: LD_INT 1
73296: PPUSH
73297: LD_VAR 0 14
73301: PPUSH
73302: CALL_OW 2
73306: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73307: LD_VAR 0 14
73311: PPUSH
73312: LD_VAR 0 12
73316: PUSH
73317: LD_INT 1
73319: ARRAY
73320: PPUSH
73321: CALL_OW 52
// end ;
73325: GO 72964
73327: POP
73328: POP
// end ;
73329: GO 72266
73331: POP
73332: POP
// result := result ^ buildings ;
73333: LD_ADDR_VAR 0 7
73337: PUSH
73338: LD_VAR 0 7
73342: PUSH
73343: LD_VAR 0 18
73347: ADD
73348: ST_TO_ADDR
// end else
73349: GO 73492
// begin for i = 1 to personel do
73351: LD_ADDR_VAR 0 8
73355: PUSH
73356: DOUBLE
73357: LD_INT 1
73359: DEC
73360: ST_TO_ADDR
73361: LD_VAR 0 6
73365: PUSH
73366: FOR_TO
73367: IFFALSE 73490
// begin if i > 4 then
73369: LD_VAR 0 8
73373: PUSH
73374: LD_INT 4
73376: GREATER
73377: IFFALSE 73381
// break ;
73379: GO 73490
// x := personel [ i ] ;
73381: LD_ADDR_VAR 0 13
73385: PUSH
73386: LD_VAR 0 6
73390: PUSH
73391: LD_VAR 0 8
73395: ARRAY
73396: ST_TO_ADDR
// if x = - 1 then
73397: LD_VAR 0 13
73401: PUSH
73402: LD_INT 1
73404: NEG
73405: EQUAL
73406: IFFALSE 73410
// continue ;
73408: GO 73366
// PrepareHuman ( false , i , skill ) ;
73410: LD_INT 0
73412: PPUSH
73413: LD_VAR 0 8
73417: PPUSH
73418: LD_VAR 0 4
73422: PPUSH
73423: CALL_OW 380
// un := CreateHuman ;
73427: LD_ADDR_VAR 0 14
73431: PUSH
73432: CALL_OW 44
73436: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73437: LD_VAR 0 14
73441: PPUSH
73442: LD_VAR 0 1
73446: PPUSH
73447: CALL_OW 250
73451: PPUSH
73452: LD_VAR 0 1
73456: PPUSH
73457: CALL_OW 251
73461: PPUSH
73462: LD_INT 10
73464: PPUSH
73465: LD_INT 0
73467: PPUSH
73468: CALL_OW 50
// result := result ^ un ;
73472: LD_ADDR_VAR 0 7
73476: PUSH
73477: LD_VAR 0 7
73481: PUSH
73482: LD_VAR 0 14
73486: ADD
73487: ST_TO_ADDR
// end ;
73488: GO 73366
73490: POP
73491: POP
// end ; end ;
73492: LD_VAR 0 7
73496: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73497: LD_INT 0
73499: PPUSH
73500: PPUSH
73501: PPUSH
73502: PPUSH
73503: PPUSH
73504: PPUSH
73505: PPUSH
73506: PPUSH
73507: PPUSH
73508: PPUSH
73509: PPUSH
73510: PPUSH
73511: PPUSH
73512: PPUSH
73513: PPUSH
73514: PPUSH
// result := false ;
73515: LD_ADDR_VAR 0 3
73519: PUSH
73520: LD_INT 0
73522: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73523: LD_VAR 0 1
73527: NOT
73528: PUSH
73529: LD_VAR 0 1
73533: PPUSH
73534: CALL_OW 266
73538: PUSH
73539: LD_INT 32
73541: PUSH
73542: LD_INT 33
73544: PUSH
73545: EMPTY
73546: LIST
73547: LIST
73548: IN
73549: NOT
73550: OR
73551: IFFALSE 73555
// exit ;
73553: GO 74664
// nat := GetNation ( tower ) ;
73555: LD_ADDR_VAR 0 12
73559: PUSH
73560: LD_VAR 0 1
73564: PPUSH
73565: CALL_OW 248
73569: ST_TO_ADDR
// side := GetSide ( tower ) ;
73570: LD_ADDR_VAR 0 16
73574: PUSH
73575: LD_VAR 0 1
73579: PPUSH
73580: CALL_OW 255
73584: ST_TO_ADDR
// x := GetX ( tower ) ;
73585: LD_ADDR_VAR 0 10
73589: PUSH
73590: LD_VAR 0 1
73594: PPUSH
73595: CALL_OW 250
73599: ST_TO_ADDR
// y := GetY ( tower ) ;
73600: LD_ADDR_VAR 0 11
73604: PUSH
73605: LD_VAR 0 1
73609: PPUSH
73610: CALL_OW 251
73614: ST_TO_ADDR
// if not x or not y then
73615: LD_VAR 0 10
73619: NOT
73620: PUSH
73621: LD_VAR 0 11
73625: NOT
73626: OR
73627: IFFALSE 73631
// exit ;
73629: GO 74664
// weapon := 0 ;
73631: LD_ADDR_VAR 0 18
73635: PUSH
73636: LD_INT 0
73638: ST_TO_ADDR
// fac_list := [ ] ;
73639: LD_ADDR_VAR 0 17
73643: PUSH
73644: EMPTY
73645: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
73646: LD_ADDR_VAR 0 6
73650: PUSH
73651: LD_VAR 0 1
73655: PPUSH
73656: CALL_OW 274
73660: PPUSH
73661: LD_VAR 0 2
73665: PPUSH
73666: LD_INT 0
73668: PPUSH
73669: CALL 71235 0 3
73673: PPUSH
73674: LD_INT 30
73676: PUSH
73677: LD_INT 3
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PPUSH
73684: CALL_OW 72
73688: ST_TO_ADDR
// if not factories then
73689: LD_VAR 0 6
73693: NOT
73694: IFFALSE 73698
// exit ;
73696: GO 74664
// for i in factories do
73698: LD_ADDR_VAR 0 8
73702: PUSH
73703: LD_VAR 0 6
73707: PUSH
73708: FOR_IN
73709: IFFALSE 73734
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73711: LD_ADDR_VAR 0 17
73715: PUSH
73716: LD_VAR 0 17
73720: PUSH
73721: LD_VAR 0 8
73725: PPUSH
73726: CALL_OW 478
73730: UNION
73731: ST_TO_ADDR
73732: GO 73708
73734: POP
73735: POP
// if not fac_list then
73736: LD_VAR 0 17
73740: NOT
73741: IFFALSE 73745
// exit ;
73743: GO 74664
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73745: LD_ADDR_VAR 0 5
73749: PUSH
73750: LD_INT 4
73752: PUSH
73753: LD_INT 5
73755: PUSH
73756: LD_INT 9
73758: PUSH
73759: LD_INT 10
73761: PUSH
73762: LD_INT 6
73764: PUSH
73765: LD_INT 7
73767: PUSH
73768: LD_INT 11
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: LIST
73775: LIST
73776: LIST
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 27
73782: PUSH
73783: LD_INT 28
73785: PUSH
73786: LD_INT 26
73788: PUSH
73789: LD_INT 30
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 43
73800: PUSH
73801: LD_INT 44
73803: PUSH
73804: LD_INT 46
73806: PUSH
73807: LD_INT 45
73809: PUSH
73810: LD_INT 47
73812: PUSH
73813: LD_INT 49
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: LIST
73828: PUSH
73829: LD_VAR 0 12
73833: ARRAY
73834: ST_TO_ADDR
// list := list isect fac_list ;
73835: LD_ADDR_VAR 0 5
73839: PUSH
73840: LD_VAR 0 5
73844: PUSH
73845: LD_VAR 0 17
73849: ISECT
73850: ST_TO_ADDR
// if not list then
73851: LD_VAR 0 5
73855: NOT
73856: IFFALSE 73860
// exit ;
73858: GO 74664
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73860: LD_VAR 0 12
73864: PUSH
73865: LD_INT 3
73867: EQUAL
73868: PUSH
73869: LD_INT 49
73871: PUSH
73872: LD_VAR 0 5
73876: IN
73877: AND
73878: PUSH
73879: LD_INT 31
73881: PPUSH
73882: LD_VAR 0 16
73886: PPUSH
73887: CALL_OW 321
73891: PUSH
73892: LD_INT 2
73894: EQUAL
73895: AND
73896: IFFALSE 73956
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73898: LD_INT 22
73900: PUSH
73901: LD_VAR 0 16
73905: PUSH
73906: EMPTY
73907: LIST
73908: LIST
73909: PUSH
73910: LD_INT 35
73912: PUSH
73913: LD_INT 49
73915: PUSH
73916: EMPTY
73917: LIST
73918: LIST
73919: PUSH
73920: LD_INT 91
73922: PUSH
73923: LD_VAR 0 1
73927: PUSH
73928: LD_INT 10
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: LIST
73940: PPUSH
73941: CALL_OW 69
73945: NOT
73946: IFFALSE 73956
// weapon := ru_time_lapser ;
73948: LD_ADDR_VAR 0 18
73952: PUSH
73953: LD_INT 49
73955: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73956: LD_VAR 0 12
73960: PUSH
73961: LD_INT 1
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: IN
73971: PUSH
73972: LD_INT 11
73974: PUSH
73975: LD_VAR 0 5
73979: IN
73980: PUSH
73981: LD_INT 30
73983: PUSH
73984: LD_VAR 0 5
73988: IN
73989: OR
73990: AND
73991: PUSH
73992: LD_INT 6
73994: PPUSH
73995: LD_VAR 0 16
73999: PPUSH
74000: CALL_OW 321
74004: PUSH
74005: LD_INT 2
74007: EQUAL
74008: AND
74009: IFFALSE 74174
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
74011: LD_INT 22
74013: PUSH
74014: LD_VAR 0 16
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 2
74025: PUSH
74026: LD_INT 35
74028: PUSH
74029: LD_INT 11
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 35
74038: PUSH
74039: LD_INT 30
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 91
74053: PUSH
74054: LD_VAR 0 1
74058: PUSH
74059: LD_INT 18
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: LIST
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: LIST
74071: PPUSH
74072: CALL_OW 69
74076: NOT
74077: PUSH
74078: LD_INT 22
74080: PUSH
74081: LD_VAR 0 16
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 2
74092: PUSH
74093: LD_INT 30
74095: PUSH
74096: LD_INT 32
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 30
74105: PUSH
74106: LD_INT 33
74108: PUSH
74109: EMPTY
74110: LIST
74111: LIST
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: LIST
74117: PUSH
74118: LD_INT 91
74120: PUSH
74121: LD_VAR 0 1
74125: PUSH
74126: LD_INT 12
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: LIST
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: LIST
74138: PUSH
74139: EMPTY
74140: LIST
74141: PPUSH
74142: CALL_OW 69
74146: PUSH
74147: LD_INT 2
74149: GREATER
74150: AND
74151: IFFALSE 74174
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74153: LD_ADDR_VAR 0 18
74157: PUSH
74158: LD_INT 11
74160: PUSH
74161: LD_INT 30
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_VAR 0 12
74172: ARRAY
74173: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74174: LD_VAR 0 18
74178: NOT
74179: PUSH
74180: LD_INT 40
74182: PPUSH
74183: LD_VAR 0 16
74187: PPUSH
74188: CALL_OW 321
74192: PUSH
74193: LD_INT 2
74195: EQUAL
74196: AND
74197: PUSH
74198: LD_INT 7
74200: PUSH
74201: LD_VAR 0 5
74205: IN
74206: PUSH
74207: LD_INT 28
74209: PUSH
74210: LD_VAR 0 5
74214: IN
74215: OR
74216: PUSH
74217: LD_INT 45
74219: PUSH
74220: LD_VAR 0 5
74224: IN
74225: OR
74226: AND
74227: IFFALSE 74481
// begin hex := GetHexInfo ( x , y ) ;
74229: LD_ADDR_VAR 0 4
74233: PUSH
74234: LD_VAR 0 10
74238: PPUSH
74239: LD_VAR 0 11
74243: PPUSH
74244: CALL_OW 546
74248: ST_TO_ADDR
// if hex [ 1 ] then
74249: LD_VAR 0 4
74253: PUSH
74254: LD_INT 1
74256: ARRAY
74257: IFFALSE 74261
// exit ;
74259: GO 74664
// height := hex [ 2 ] ;
74261: LD_ADDR_VAR 0 15
74265: PUSH
74266: LD_VAR 0 4
74270: PUSH
74271: LD_INT 2
74273: ARRAY
74274: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74275: LD_ADDR_VAR 0 14
74279: PUSH
74280: LD_INT 0
74282: PUSH
74283: LD_INT 2
74285: PUSH
74286: LD_INT 3
74288: PUSH
74289: LD_INT 5
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: ST_TO_ADDR
// for i in tmp do
74298: LD_ADDR_VAR 0 8
74302: PUSH
74303: LD_VAR 0 14
74307: PUSH
74308: FOR_IN
74309: IFFALSE 74479
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74311: LD_ADDR_VAR 0 9
74315: PUSH
74316: LD_VAR 0 10
74320: PPUSH
74321: LD_VAR 0 8
74325: PPUSH
74326: LD_INT 5
74328: PPUSH
74329: CALL_OW 272
74333: PUSH
74334: LD_VAR 0 11
74338: PPUSH
74339: LD_VAR 0 8
74343: PPUSH
74344: LD_INT 5
74346: PPUSH
74347: CALL_OW 273
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74356: LD_VAR 0 9
74360: PUSH
74361: LD_INT 1
74363: ARRAY
74364: PPUSH
74365: LD_VAR 0 9
74369: PUSH
74370: LD_INT 2
74372: ARRAY
74373: PPUSH
74374: CALL_OW 488
74378: IFFALSE 74477
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74380: LD_ADDR_VAR 0 4
74384: PUSH
74385: LD_VAR 0 9
74389: PUSH
74390: LD_INT 1
74392: ARRAY
74393: PPUSH
74394: LD_VAR 0 9
74398: PUSH
74399: LD_INT 2
74401: ARRAY
74402: PPUSH
74403: CALL_OW 546
74407: ST_TO_ADDR
// if hex [ 1 ] then
74408: LD_VAR 0 4
74412: PUSH
74413: LD_INT 1
74415: ARRAY
74416: IFFALSE 74420
// continue ;
74418: GO 74308
// h := hex [ 2 ] ;
74420: LD_ADDR_VAR 0 13
74424: PUSH
74425: LD_VAR 0 4
74429: PUSH
74430: LD_INT 2
74432: ARRAY
74433: ST_TO_ADDR
// if h + 7 < height then
74434: LD_VAR 0 13
74438: PUSH
74439: LD_INT 7
74441: PLUS
74442: PUSH
74443: LD_VAR 0 15
74447: LESS
74448: IFFALSE 74477
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74450: LD_ADDR_VAR 0 18
74454: PUSH
74455: LD_INT 7
74457: PUSH
74458: LD_INT 28
74460: PUSH
74461: LD_INT 45
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: LIST
74468: PUSH
74469: LD_VAR 0 12
74473: ARRAY
74474: ST_TO_ADDR
// break ;
74475: GO 74479
// end ; end ; end ;
74477: GO 74308
74479: POP
74480: POP
// end ; if not weapon then
74481: LD_VAR 0 18
74485: NOT
74486: IFFALSE 74546
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74488: LD_ADDR_VAR 0 5
74492: PUSH
74493: LD_VAR 0 5
74497: PUSH
74498: LD_INT 11
74500: PUSH
74501: LD_INT 30
74503: PUSH
74504: LD_INT 49
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: LIST
74511: DIFF
74512: ST_TO_ADDR
// if not list then
74513: LD_VAR 0 5
74517: NOT
74518: IFFALSE 74522
// exit ;
74520: GO 74664
// weapon := list [ rand ( 1 , list ) ] ;
74522: LD_ADDR_VAR 0 18
74526: PUSH
74527: LD_VAR 0 5
74531: PUSH
74532: LD_INT 1
74534: PPUSH
74535: LD_VAR 0 5
74539: PPUSH
74540: CALL_OW 12
74544: ARRAY
74545: ST_TO_ADDR
// end ; if weapon then
74546: LD_VAR 0 18
74550: IFFALSE 74664
// begin tmp := CostOfWeapon ( weapon ) ;
74552: LD_ADDR_VAR 0 14
74556: PUSH
74557: LD_VAR 0 18
74561: PPUSH
74562: CALL_OW 451
74566: ST_TO_ADDR
// j := GetBase ( tower ) ;
74567: LD_ADDR_VAR 0 9
74571: PUSH
74572: LD_VAR 0 1
74576: PPUSH
74577: CALL_OW 274
74581: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74582: LD_VAR 0 9
74586: PPUSH
74587: LD_INT 1
74589: PPUSH
74590: CALL_OW 275
74594: PUSH
74595: LD_VAR 0 14
74599: PUSH
74600: LD_INT 1
74602: ARRAY
74603: GREATEREQUAL
74604: PUSH
74605: LD_VAR 0 9
74609: PPUSH
74610: LD_INT 2
74612: PPUSH
74613: CALL_OW 275
74617: PUSH
74618: LD_VAR 0 14
74622: PUSH
74623: LD_INT 2
74625: ARRAY
74626: GREATEREQUAL
74627: AND
74628: PUSH
74629: LD_VAR 0 9
74633: PPUSH
74634: LD_INT 3
74636: PPUSH
74637: CALL_OW 275
74641: PUSH
74642: LD_VAR 0 14
74646: PUSH
74647: LD_INT 3
74649: ARRAY
74650: GREATEREQUAL
74651: AND
74652: IFFALSE 74664
// result := weapon ;
74654: LD_ADDR_VAR 0 3
74658: PUSH
74659: LD_VAR 0 18
74663: ST_TO_ADDR
// end ; end ;
74664: LD_VAR 0 3
74668: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74669: LD_INT 0
74671: PPUSH
74672: PPUSH
// result := true ;
74673: LD_ADDR_VAR 0 3
74677: PUSH
74678: LD_INT 1
74680: ST_TO_ADDR
// if array1 = array2 then
74681: LD_VAR 0 1
74685: PUSH
74686: LD_VAR 0 2
74690: EQUAL
74691: IFFALSE 74751
// begin for i = 1 to array1 do
74693: LD_ADDR_VAR 0 4
74697: PUSH
74698: DOUBLE
74699: LD_INT 1
74701: DEC
74702: ST_TO_ADDR
74703: LD_VAR 0 1
74707: PUSH
74708: FOR_TO
74709: IFFALSE 74747
// if array1 [ i ] <> array2 [ i ] then
74711: LD_VAR 0 1
74715: PUSH
74716: LD_VAR 0 4
74720: ARRAY
74721: PUSH
74722: LD_VAR 0 2
74726: PUSH
74727: LD_VAR 0 4
74731: ARRAY
74732: NONEQUAL
74733: IFFALSE 74745
// begin result := false ;
74735: LD_ADDR_VAR 0 3
74739: PUSH
74740: LD_INT 0
74742: ST_TO_ADDR
// break ;
74743: GO 74747
// end ;
74745: GO 74708
74747: POP
74748: POP
// end else
74749: GO 74759
// result := false ;
74751: LD_ADDR_VAR 0 3
74755: PUSH
74756: LD_INT 0
74758: ST_TO_ADDR
// end ;
74759: LD_VAR 0 3
74763: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
74764: LD_INT 0
74766: PPUSH
74767: PPUSH
// if not array1 or not array2 then
74768: LD_VAR 0 1
74772: NOT
74773: PUSH
74774: LD_VAR 0 2
74778: NOT
74779: OR
74780: IFFALSE 74784
// exit ;
74782: GO 74848
// result := true ;
74784: LD_ADDR_VAR 0 3
74788: PUSH
74789: LD_INT 1
74791: ST_TO_ADDR
// for i = 1 to array1 do
74792: LD_ADDR_VAR 0 4
74796: PUSH
74797: DOUBLE
74798: LD_INT 1
74800: DEC
74801: ST_TO_ADDR
74802: LD_VAR 0 1
74806: PUSH
74807: FOR_TO
74808: IFFALSE 74846
// if array1 [ i ] <> array2 [ i ] then
74810: LD_VAR 0 1
74814: PUSH
74815: LD_VAR 0 4
74819: ARRAY
74820: PUSH
74821: LD_VAR 0 2
74825: PUSH
74826: LD_VAR 0 4
74830: ARRAY
74831: NONEQUAL
74832: IFFALSE 74844
// begin result := false ;
74834: LD_ADDR_VAR 0 3
74838: PUSH
74839: LD_INT 0
74841: ST_TO_ADDR
// break ;
74842: GO 74846
// end ;
74844: GO 74807
74846: POP
74847: POP
// end ;
74848: LD_VAR 0 3
74852: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74853: LD_INT 0
74855: PPUSH
74856: PPUSH
74857: PPUSH
// pom := GetBase ( fac ) ;
74858: LD_ADDR_VAR 0 5
74862: PUSH
74863: LD_VAR 0 1
74867: PPUSH
74868: CALL_OW 274
74872: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74873: LD_ADDR_VAR 0 4
74877: PUSH
74878: LD_VAR 0 2
74882: PUSH
74883: LD_INT 1
74885: ARRAY
74886: PPUSH
74887: LD_VAR 0 2
74891: PUSH
74892: LD_INT 2
74894: ARRAY
74895: PPUSH
74896: LD_VAR 0 2
74900: PUSH
74901: LD_INT 3
74903: ARRAY
74904: PPUSH
74905: LD_VAR 0 2
74909: PUSH
74910: LD_INT 4
74912: ARRAY
74913: PPUSH
74914: CALL_OW 449
74918: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74919: LD_ADDR_VAR 0 3
74923: PUSH
74924: LD_VAR 0 5
74928: PPUSH
74929: LD_INT 1
74931: PPUSH
74932: CALL_OW 275
74936: PUSH
74937: LD_VAR 0 4
74941: PUSH
74942: LD_INT 1
74944: ARRAY
74945: GREATEREQUAL
74946: PUSH
74947: LD_VAR 0 5
74951: PPUSH
74952: LD_INT 2
74954: PPUSH
74955: CALL_OW 275
74959: PUSH
74960: LD_VAR 0 4
74964: PUSH
74965: LD_INT 2
74967: ARRAY
74968: GREATEREQUAL
74969: AND
74970: PUSH
74971: LD_VAR 0 5
74975: PPUSH
74976: LD_INT 3
74978: PPUSH
74979: CALL_OW 275
74983: PUSH
74984: LD_VAR 0 4
74988: PUSH
74989: LD_INT 3
74991: ARRAY
74992: GREATEREQUAL
74993: AND
74994: ST_TO_ADDR
// end ;
74995: LD_VAR 0 3
74999: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
75000: LD_INT 0
75002: PPUSH
75003: PPUSH
75004: PPUSH
75005: PPUSH
// pom := GetBase ( building ) ;
75006: LD_ADDR_VAR 0 3
75010: PUSH
75011: LD_VAR 0 1
75015: PPUSH
75016: CALL_OW 274
75020: ST_TO_ADDR
// if not pom then
75021: LD_VAR 0 3
75025: NOT
75026: IFFALSE 75030
// exit ;
75028: GO 75200
// btype := GetBType ( building ) ;
75030: LD_ADDR_VAR 0 5
75034: PUSH
75035: LD_VAR 0 1
75039: PPUSH
75040: CALL_OW 266
75044: ST_TO_ADDR
// if btype = b_armoury then
75045: LD_VAR 0 5
75049: PUSH
75050: LD_INT 4
75052: EQUAL
75053: IFFALSE 75063
// btype := b_barracks ;
75055: LD_ADDR_VAR 0 5
75059: PUSH
75060: LD_INT 5
75062: ST_TO_ADDR
// if btype = b_depot then
75063: LD_VAR 0 5
75067: PUSH
75068: LD_INT 0
75070: EQUAL
75071: IFFALSE 75081
// btype := b_warehouse ;
75073: LD_ADDR_VAR 0 5
75077: PUSH
75078: LD_INT 1
75080: ST_TO_ADDR
// if btype = b_workshop then
75081: LD_VAR 0 5
75085: PUSH
75086: LD_INT 2
75088: EQUAL
75089: IFFALSE 75099
// btype := b_factory ;
75091: LD_ADDR_VAR 0 5
75095: PUSH
75096: LD_INT 3
75098: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75099: LD_ADDR_VAR 0 4
75103: PUSH
75104: LD_VAR 0 5
75108: PPUSH
75109: LD_VAR 0 1
75113: PPUSH
75114: CALL_OW 248
75118: PPUSH
75119: CALL_OW 450
75123: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75124: LD_ADDR_VAR 0 2
75128: PUSH
75129: LD_VAR 0 3
75133: PPUSH
75134: LD_INT 1
75136: PPUSH
75137: CALL_OW 275
75141: PUSH
75142: LD_VAR 0 4
75146: PUSH
75147: LD_INT 1
75149: ARRAY
75150: GREATEREQUAL
75151: PUSH
75152: LD_VAR 0 3
75156: PPUSH
75157: LD_INT 2
75159: PPUSH
75160: CALL_OW 275
75164: PUSH
75165: LD_VAR 0 4
75169: PUSH
75170: LD_INT 2
75172: ARRAY
75173: GREATEREQUAL
75174: AND
75175: PUSH
75176: LD_VAR 0 3
75180: PPUSH
75181: LD_INT 3
75183: PPUSH
75184: CALL_OW 275
75188: PUSH
75189: LD_VAR 0 4
75193: PUSH
75194: LD_INT 3
75196: ARRAY
75197: GREATEREQUAL
75198: AND
75199: ST_TO_ADDR
// end ;
75200: LD_VAR 0 2
75204: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75205: LD_INT 0
75207: PPUSH
75208: PPUSH
75209: PPUSH
// pom := GetBase ( building ) ;
75210: LD_ADDR_VAR 0 4
75214: PUSH
75215: LD_VAR 0 1
75219: PPUSH
75220: CALL_OW 274
75224: ST_TO_ADDR
// if not pom then
75225: LD_VAR 0 4
75229: NOT
75230: IFFALSE 75234
// exit ;
75232: GO 75335
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75234: LD_ADDR_VAR 0 5
75238: PUSH
75239: LD_VAR 0 2
75243: PPUSH
75244: LD_VAR 0 1
75248: PPUSH
75249: CALL_OW 248
75253: PPUSH
75254: CALL_OW 450
75258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75259: LD_ADDR_VAR 0 3
75263: PUSH
75264: LD_VAR 0 4
75268: PPUSH
75269: LD_INT 1
75271: PPUSH
75272: CALL_OW 275
75276: PUSH
75277: LD_VAR 0 5
75281: PUSH
75282: LD_INT 1
75284: ARRAY
75285: GREATEREQUAL
75286: PUSH
75287: LD_VAR 0 4
75291: PPUSH
75292: LD_INT 2
75294: PPUSH
75295: CALL_OW 275
75299: PUSH
75300: LD_VAR 0 5
75304: PUSH
75305: LD_INT 2
75307: ARRAY
75308: GREATEREQUAL
75309: AND
75310: PUSH
75311: LD_VAR 0 4
75315: PPUSH
75316: LD_INT 3
75318: PPUSH
75319: CALL_OW 275
75323: PUSH
75324: LD_VAR 0 5
75328: PUSH
75329: LD_INT 3
75331: ARRAY
75332: GREATEREQUAL
75333: AND
75334: ST_TO_ADDR
// end ;
75335: LD_VAR 0 3
75339: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75340: LD_INT 0
75342: PPUSH
75343: PPUSH
75344: PPUSH
75345: PPUSH
75346: PPUSH
75347: PPUSH
75348: PPUSH
75349: PPUSH
75350: PPUSH
75351: PPUSH
75352: PPUSH
// result := false ;
75353: LD_ADDR_VAR 0 8
75357: PUSH
75358: LD_INT 0
75360: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
75361: LD_VAR 0 5
75365: NOT
75366: PUSH
75367: LD_VAR 0 1
75371: NOT
75372: OR
75373: PUSH
75374: LD_VAR 0 2
75378: NOT
75379: OR
75380: PUSH
75381: LD_VAR 0 3
75385: NOT
75386: OR
75387: IFFALSE 75391
// exit ;
75389: GO 76205
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
75391: LD_ADDR_VAR 0 14
75395: PUSH
75396: LD_VAR 0 1
75400: PPUSH
75401: LD_VAR 0 2
75405: PPUSH
75406: LD_VAR 0 3
75410: PPUSH
75411: LD_VAR 0 4
75415: PPUSH
75416: LD_VAR 0 5
75420: PUSH
75421: LD_INT 1
75423: ARRAY
75424: PPUSH
75425: CALL_OW 248
75429: PPUSH
75430: LD_INT 0
75432: PPUSH
75433: CALL 77438 0 6
75437: ST_TO_ADDR
// if not hexes then
75438: LD_VAR 0 14
75442: NOT
75443: IFFALSE 75447
// exit ;
75445: GO 76205
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75447: LD_ADDR_VAR 0 17
75451: PUSH
75452: LD_VAR 0 5
75456: PPUSH
75457: LD_INT 22
75459: PUSH
75460: LD_VAR 0 13
75464: PPUSH
75465: CALL_OW 255
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 2
75476: PUSH
75477: LD_INT 30
75479: PUSH
75480: LD_INT 0
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: PUSH
75487: LD_INT 30
75489: PUSH
75490: LD_INT 1
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: LIST
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PPUSH
75506: CALL_OW 72
75510: ST_TO_ADDR
// for i = 1 to hexes do
75511: LD_ADDR_VAR 0 9
75515: PUSH
75516: DOUBLE
75517: LD_INT 1
75519: DEC
75520: ST_TO_ADDR
75521: LD_VAR 0 14
75525: PUSH
75526: FOR_TO
75527: IFFALSE 76203
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75529: LD_ADDR_VAR 0 13
75533: PUSH
75534: LD_VAR 0 14
75538: PUSH
75539: LD_VAR 0 9
75543: ARRAY
75544: PUSH
75545: LD_INT 1
75547: ARRAY
75548: PPUSH
75549: LD_VAR 0 14
75553: PUSH
75554: LD_VAR 0 9
75558: ARRAY
75559: PUSH
75560: LD_INT 2
75562: ARRAY
75563: PPUSH
75564: CALL_OW 428
75568: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75569: LD_VAR 0 14
75573: PUSH
75574: LD_VAR 0 9
75578: ARRAY
75579: PUSH
75580: LD_INT 1
75582: ARRAY
75583: PPUSH
75584: LD_VAR 0 14
75588: PUSH
75589: LD_VAR 0 9
75593: ARRAY
75594: PUSH
75595: LD_INT 2
75597: ARRAY
75598: PPUSH
75599: CALL_OW 351
75603: PUSH
75604: LD_VAR 0 14
75608: PUSH
75609: LD_VAR 0 9
75613: ARRAY
75614: PUSH
75615: LD_INT 1
75617: ARRAY
75618: PPUSH
75619: LD_VAR 0 14
75623: PUSH
75624: LD_VAR 0 9
75628: ARRAY
75629: PUSH
75630: LD_INT 2
75632: ARRAY
75633: PPUSH
75634: CALL_OW 488
75638: NOT
75639: OR
75640: PUSH
75641: LD_VAR 0 13
75645: PPUSH
75646: CALL_OW 247
75650: PUSH
75651: LD_INT 3
75653: EQUAL
75654: OR
75655: IFFALSE 75661
// exit ;
75657: POP
75658: POP
75659: GO 76205
// if not tmp then
75661: LD_VAR 0 13
75665: NOT
75666: IFFALSE 75670
// continue ;
75668: GO 75526
// result := true ;
75670: LD_ADDR_VAR 0 8
75674: PUSH
75675: LD_INT 1
75677: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
75678: LD_VAR 0 6
75682: PUSH
75683: LD_VAR 0 13
75687: PPUSH
75688: CALL_OW 247
75692: PUSH
75693: LD_INT 2
75695: EQUAL
75696: AND
75697: PUSH
75698: LD_VAR 0 13
75702: PPUSH
75703: CALL_OW 263
75707: PUSH
75708: LD_INT 1
75710: EQUAL
75711: AND
75712: IFFALSE 75876
// begin if IsDrivenBy ( tmp ) then
75714: LD_VAR 0 13
75718: PPUSH
75719: CALL_OW 311
75723: IFFALSE 75727
// continue ;
75725: GO 75526
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
75727: LD_VAR 0 6
75731: PPUSH
75732: LD_INT 3
75734: PUSH
75735: LD_INT 60
75737: PUSH
75738: EMPTY
75739: LIST
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 3
75747: PUSH
75748: LD_INT 55
75750: PUSH
75751: EMPTY
75752: LIST
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PPUSH
75762: CALL_OW 72
75766: IFFALSE 75874
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
75768: LD_ADDR_VAR 0 18
75772: PUSH
75773: LD_VAR 0 6
75777: PPUSH
75778: LD_INT 3
75780: PUSH
75781: LD_INT 60
75783: PUSH
75784: EMPTY
75785: LIST
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 3
75793: PUSH
75794: LD_INT 55
75796: PUSH
75797: EMPTY
75798: LIST
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PPUSH
75808: CALL_OW 72
75812: PUSH
75813: LD_INT 1
75815: ARRAY
75816: ST_TO_ADDR
// if IsInUnit ( driver ) then
75817: LD_VAR 0 18
75821: PPUSH
75822: CALL_OW 310
75826: IFFALSE 75837
// ComExit ( driver ) ;
75828: LD_VAR 0 18
75832: PPUSH
75833: CALL 101218 0 1
// AddComEnterUnit ( driver , tmp ) ;
75837: LD_VAR 0 18
75841: PPUSH
75842: LD_VAR 0 13
75846: PPUSH
75847: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
75851: LD_VAR 0 18
75855: PPUSH
75856: LD_VAR 0 7
75860: PPUSH
75861: CALL_OW 173
// AddComExitVehicle ( driver ) ;
75865: LD_VAR 0 18
75869: PPUSH
75870: CALL_OW 181
// end ; continue ;
75874: GO 75526
// end ; if not cleaners or not tmp in cleaners then
75876: LD_VAR 0 6
75880: NOT
75881: PUSH
75882: LD_VAR 0 13
75886: PUSH
75887: LD_VAR 0 6
75891: IN
75892: NOT
75893: OR
75894: IFFALSE 76201
// begin if dep then
75896: LD_VAR 0 17
75900: IFFALSE 76036
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75902: LD_ADDR_VAR 0 16
75906: PUSH
75907: LD_VAR 0 17
75911: PUSH
75912: LD_INT 1
75914: ARRAY
75915: PPUSH
75916: CALL_OW 250
75920: PPUSH
75921: LD_VAR 0 17
75925: PUSH
75926: LD_INT 1
75928: ARRAY
75929: PPUSH
75930: CALL_OW 254
75934: PPUSH
75935: LD_INT 5
75937: PPUSH
75938: CALL_OW 272
75942: PUSH
75943: LD_VAR 0 17
75947: PUSH
75948: LD_INT 1
75950: ARRAY
75951: PPUSH
75952: CALL_OW 251
75956: PPUSH
75957: LD_VAR 0 17
75961: PUSH
75962: LD_INT 1
75964: ARRAY
75965: PPUSH
75966: CALL_OW 254
75970: PPUSH
75971: LD_INT 5
75973: PPUSH
75974: CALL_OW 273
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75983: LD_VAR 0 16
75987: PUSH
75988: LD_INT 1
75990: ARRAY
75991: PPUSH
75992: LD_VAR 0 16
75996: PUSH
75997: LD_INT 2
75999: ARRAY
76000: PPUSH
76001: CALL_OW 488
76005: IFFALSE 76036
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76007: LD_VAR 0 13
76011: PPUSH
76012: LD_VAR 0 16
76016: PUSH
76017: LD_INT 1
76019: ARRAY
76020: PPUSH
76021: LD_VAR 0 16
76025: PUSH
76026: LD_INT 2
76028: ARRAY
76029: PPUSH
76030: CALL_OW 111
// continue ;
76034: GO 75526
// end ; end ; r := GetDir ( tmp ) ;
76036: LD_ADDR_VAR 0 15
76040: PUSH
76041: LD_VAR 0 13
76045: PPUSH
76046: CALL_OW 254
76050: ST_TO_ADDR
// if r = 5 then
76051: LD_VAR 0 15
76055: PUSH
76056: LD_INT 5
76058: EQUAL
76059: IFFALSE 76069
// r := 0 ;
76061: LD_ADDR_VAR 0 15
76065: PUSH
76066: LD_INT 0
76068: ST_TO_ADDR
// for j = r to 5 do
76069: LD_ADDR_VAR 0 10
76073: PUSH
76074: DOUBLE
76075: LD_VAR 0 15
76079: DEC
76080: ST_TO_ADDR
76081: LD_INT 5
76083: PUSH
76084: FOR_TO
76085: IFFALSE 76199
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76087: LD_ADDR_VAR 0 11
76091: PUSH
76092: LD_VAR 0 13
76096: PPUSH
76097: CALL_OW 250
76101: PPUSH
76102: LD_VAR 0 10
76106: PPUSH
76107: LD_INT 2
76109: PPUSH
76110: CALL_OW 272
76114: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76115: LD_ADDR_VAR 0 12
76119: PUSH
76120: LD_VAR 0 13
76124: PPUSH
76125: CALL_OW 251
76129: PPUSH
76130: LD_VAR 0 10
76134: PPUSH
76135: LD_INT 2
76137: PPUSH
76138: CALL_OW 273
76142: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76143: LD_VAR 0 11
76147: PPUSH
76148: LD_VAR 0 12
76152: PPUSH
76153: CALL_OW 488
76157: PUSH
76158: LD_VAR 0 11
76162: PPUSH
76163: LD_VAR 0 12
76167: PPUSH
76168: CALL_OW 428
76172: NOT
76173: AND
76174: IFFALSE 76197
// begin ComMoveXY ( tmp , _x , _y ) ;
76176: LD_VAR 0 13
76180: PPUSH
76181: LD_VAR 0 11
76185: PPUSH
76186: LD_VAR 0 12
76190: PPUSH
76191: CALL_OW 111
// break ;
76195: GO 76199
// end ; end ;
76197: GO 76084
76199: POP
76200: POP
// end ; end ;
76201: GO 75526
76203: POP
76204: POP
// end ;
76205: LD_VAR 0 8
76209: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76210: LD_INT 0
76212: PPUSH
// result := true ;
76213: LD_ADDR_VAR 0 3
76217: PUSH
76218: LD_INT 1
76220: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76221: LD_VAR 0 2
76225: PUSH
76226: LD_INT 24
76228: DOUBLE
76229: EQUAL
76230: IFTRUE 76240
76232: LD_INT 33
76234: DOUBLE
76235: EQUAL
76236: IFTRUE 76240
76238: GO 76265
76240: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76241: LD_ADDR_VAR 0 3
76245: PUSH
76246: LD_INT 32
76248: PPUSH
76249: LD_VAR 0 1
76253: PPUSH
76254: CALL_OW 321
76258: PUSH
76259: LD_INT 2
76261: EQUAL
76262: ST_TO_ADDR
76263: GO 76581
76265: LD_INT 20
76267: DOUBLE
76268: EQUAL
76269: IFTRUE 76273
76271: GO 76298
76273: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76274: LD_ADDR_VAR 0 3
76278: PUSH
76279: LD_INT 6
76281: PPUSH
76282: LD_VAR 0 1
76286: PPUSH
76287: CALL_OW 321
76291: PUSH
76292: LD_INT 2
76294: EQUAL
76295: ST_TO_ADDR
76296: GO 76581
76298: LD_INT 22
76300: DOUBLE
76301: EQUAL
76302: IFTRUE 76312
76304: LD_INT 36
76306: DOUBLE
76307: EQUAL
76308: IFTRUE 76312
76310: GO 76337
76312: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76313: LD_ADDR_VAR 0 3
76317: PUSH
76318: LD_INT 15
76320: PPUSH
76321: LD_VAR 0 1
76325: PPUSH
76326: CALL_OW 321
76330: PUSH
76331: LD_INT 2
76333: EQUAL
76334: ST_TO_ADDR
76335: GO 76581
76337: LD_INT 30
76339: DOUBLE
76340: EQUAL
76341: IFTRUE 76345
76343: GO 76370
76345: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76346: LD_ADDR_VAR 0 3
76350: PUSH
76351: LD_INT 20
76353: PPUSH
76354: LD_VAR 0 1
76358: PPUSH
76359: CALL_OW 321
76363: PUSH
76364: LD_INT 2
76366: EQUAL
76367: ST_TO_ADDR
76368: GO 76581
76370: LD_INT 28
76372: DOUBLE
76373: EQUAL
76374: IFTRUE 76384
76376: LD_INT 21
76378: DOUBLE
76379: EQUAL
76380: IFTRUE 76384
76382: GO 76409
76384: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
76385: LD_ADDR_VAR 0 3
76389: PUSH
76390: LD_INT 21
76392: PPUSH
76393: LD_VAR 0 1
76397: PPUSH
76398: CALL_OW 321
76402: PUSH
76403: LD_INT 2
76405: EQUAL
76406: ST_TO_ADDR
76407: GO 76581
76409: LD_INT 16
76411: DOUBLE
76412: EQUAL
76413: IFTRUE 76417
76415: GO 76442
76417: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
76418: LD_ADDR_VAR 0 3
76422: PUSH
76423: LD_INT 84
76425: PPUSH
76426: LD_VAR 0 1
76430: PPUSH
76431: CALL_OW 321
76435: PUSH
76436: LD_INT 2
76438: EQUAL
76439: ST_TO_ADDR
76440: GO 76581
76442: LD_INT 19
76444: DOUBLE
76445: EQUAL
76446: IFTRUE 76456
76448: LD_INT 23
76450: DOUBLE
76451: EQUAL
76452: IFTRUE 76456
76454: GO 76481
76456: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
76457: LD_ADDR_VAR 0 3
76461: PUSH
76462: LD_INT 83
76464: PPUSH
76465: LD_VAR 0 1
76469: PPUSH
76470: CALL_OW 321
76474: PUSH
76475: LD_INT 2
76477: EQUAL
76478: ST_TO_ADDR
76479: GO 76581
76481: LD_INT 17
76483: DOUBLE
76484: EQUAL
76485: IFTRUE 76489
76487: GO 76514
76489: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
76490: LD_ADDR_VAR 0 3
76494: PUSH
76495: LD_INT 39
76497: PPUSH
76498: LD_VAR 0 1
76502: PPUSH
76503: CALL_OW 321
76507: PUSH
76508: LD_INT 2
76510: EQUAL
76511: ST_TO_ADDR
76512: GO 76581
76514: LD_INT 18
76516: DOUBLE
76517: EQUAL
76518: IFTRUE 76522
76520: GO 76547
76522: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
76523: LD_ADDR_VAR 0 3
76527: PUSH
76528: LD_INT 40
76530: PPUSH
76531: LD_VAR 0 1
76535: PPUSH
76536: CALL_OW 321
76540: PUSH
76541: LD_INT 2
76543: EQUAL
76544: ST_TO_ADDR
76545: GO 76581
76547: LD_INT 27
76549: DOUBLE
76550: EQUAL
76551: IFTRUE 76555
76553: GO 76580
76555: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
76556: LD_ADDR_VAR 0 3
76560: PUSH
76561: LD_INT 35
76563: PPUSH
76564: LD_VAR 0 1
76568: PPUSH
76569: CALL_OW 321
76573: PUSH
76574: LD_INT 2
76576: EQUAL
76577: ST_TO_ADDR
76578: GO 76581
76580: POP
// end ;
76581: LD_VAR 0 3
76585: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
76586: LD_INT 0
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
76592: PPUSH
76593: PPUSH
76594: PPUSH
76595: PPUSH
76596: PPUSH
76597: PPUSH
76598: PPUSH
// result := false ;
76599: LD_ADDR_VAR 0 6
76603: PUSH
76604: LD_INT 0
76606: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76607: LD_VAR 0 1
76611: NOT
76612: PUSH
76613: LD_VAR 0 1
76617: PPUSH
76618: CALL_OW 266
76622: PUSH
76623: LD_INT 0
76625: PUSH
76626: LD_INT 1
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: IN
76633: NOT
76634: OR
76635: PUSH
76636: LD_VAR 0 2
76640: NOT
76641: OR
76642: PUSH
76643: LD_VAR 0 5
76647: PUSH
76648: LD_INT 0
76650: PUSH
76651: LD_INT 1
76653: PUSH
76654: LD_INT 2
76656: PUSH
76657: LD_INT 3
76659: PUSH
76660: LD_INT 4
76662: PUSH
76663: LD_INT 5
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: IN
76674: NOT
76675: OR
76676: PUSH
76677: LD_VAR 0 3
76681: PPUSH
76682: LD_VAR 0 4
76686: PPUSH
76687: CALL_OW 488
76691: NOT
76692: OR
76693: IFFALSE 76697
// exit ;
76695: GO 77433
// side := GetSide ( depot ) ;
76697: LD_ADDR_VAR 0 9
76701: PUSH
76702: LD_VAR 0 1
76706: PPUSH
76707: CALL_OW 255
76711: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
76712: LD_VAR 0 9
76716: PPUSH
76717: LD_VAR 0 2
76721: PPUSH
76722: CALL 76210 0 2
76726: NOT
76727: IFFALSE 76731
// exit ;
76729: GO 77433
// pom := GetBase ( depot ) ;
76731: LD_ADDR_VAR 0 10
76735: PUSH
76736: LD_VAR 0 1
76740: PPUSH
76741: CALL_OW 274
76745: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
76746: LD_ADDR_VAR 0 11
76750: PUSH
76751: LD_VAR 0 2
76755: PPUSH
76756: LD_VAR 0 1
76760: PPUSH
76761: CALL_OW 248
76765: PPUSH
76766: CALL_OW 450
76770: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76771: LD_VAR 0 10
76775: PPUSH
76776: LD_INT 1
76778: PPUSH
76779: CALL_OW 275
76783: PUSH
76784: LD_VAR 0 11
76788: PUSH
76789: LD_INT 1
76791: ARRAY
76792: GREATEREQUAL
76793: PUSH
76794: LD_VAR 0 10
76798: PPUSH
76799: LD_INT 2
76801: PPUSH
76802: CALL_OW 275
76806: PUSH
76807: LD_VAR 0 11
76811: PUSH
76812: LD_INT 2
76814: ARRAY
76815: GREATEREQUAL
76816: AND
76817: PUSH
76818: LD_VAR 0 10
76822: PPUSH
76823: LD_INT 3
76825: PPUSH
76826: CALL_OW 275
76830: PUSH
76831: LD_VAR 0 11
76835: PUSH
76836: LD_INT 3
76838: ARRAY
76839: GREATEREQUAL
76840: AND
76841: NOT
76842: IFFALSE 76846
// exit ;
76844: GO 77433
// if GetBType ( depot ) = b_depot then
76846: LD_VAR 0 1
76850: PPUSH
76851: CALL_OW 266
76855: PUSH
76856: LD_INT 0
76858: EQUAL
76859: IFFALSE 76871
// dist := 28 else
76861: LD_ADDR_VAR 0 14
76865: PUSH
76866: LD_INT 28
76868: ST_TO_ADDR
76869: GO 76879
// dist := 36 ;
76871: LD_ADDR_VAR 0 14
76875: PUSH
76876: LD_INT 36
76878: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
76879: LD_VAR 0 1
76883: PPUSH
76884: LD_VAR 0 3
76888: PPUSH
76889: LD_VAR 0 4
76893: PPUSH
76894: CALL_OW 297
76898: PUSH
76899: LD_VAR 0 14
76903: GREATER
76904: IFFALSE 76908
// exit ;
76906: GO 77433
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
76908: LD_ADDR_VAR 0 12
76912: PUSH
76913: LD_VAR 0 2
76917: PPUSH
76918: LD_VAR 0 3
76922: PPUSH
76923: LD_VAR 0 4
76927: PPUSH
76928: LD_VAR 0 5
76932: PPUSH
76933: LD_VAR 0 1
76937: PPUSH
76938: CALL_OW 248
76942: PPUSH
76943: LD_INT 0
76945: PPUSH
76946: CALL 77438 0 6
76950: ST_TO_ADDR
// if not hexes then
76951: LD_VAR 0 12
76955: NOT
76956: IFFALSE 76960
// exit ;
76958: GO 77433
// hex := GetHexInfo ( x , y ) ;
76960: LD_ADDR_VAR 0 15
76964: PUSH
76965: LD_VAR 0 3
76969: PPUSH
76970: LD_VAR 0 4
76974: PPUSH
76975: CALL_OW 546
76979: ST_TO_ADDR
// if hex [ 1 ] then
76980: LD_VAR 0 15
76984: PUSH
76985: LD_INT 1
76987: ARRAY
76988: IFFALSE 76992
// exit ;
76990: GO 77433
// height := hex [ 2 ] ;
76992: LD_ADDR_VAR 0 13
76996: PUSH
76997: LD_VAR 0 15
77001: PUSH
77002: LD_INT 2
77004: ARRAY
77005: ST_TO_ADDR
// for i = 1 to hexes do
77006: LD_ADDR_VAR 0 7
77010: PUSH
77011: DOUBLE
77012: LD_INT 1
77014: DEC
77015: ST_TO_ADDR
77016: LD_VAR 0 12
77020: PUSH
77021: FOR_TO
77022: IFFALSE 77352
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77024: LD_VAR 0 12
77028: PUSH
77029: LD_VAR 0 7
77033: ARRAY
77034: PUSH
77035: LD_INT 1
77037: ARRAY
77038: PPUSH
77039: LD_VAR 0 12
77043: PUSH
77044: LD_VAR 0 7
77048: ARRAY
77049: PUSH
77050: LD_INT 2
77052: ARRAY
77053: PPUSH
77054: CALL_OW 488
77058: NOT
77059: PUSH
77060: LD_VAR 0 12
77064: PUSH
77065: LD_VAR 0 7
77069: ARRAY
77070: PUSH
77071: LD_INT 1
77073: ARRAY
77074: PPUSH
77075: LD_VAR 0 12
77079: PUSH
77080: LD_VAR 0 7
77084: ARRAY
77085: PUSH
77086: LD_INT 2
77088: ARRAY
77089: PPUSH
77090: CALL_OW 428
77094: PUSH
77095: LD_INT 0
77097: GREATER
77098: OR
77099: PUSH
77100: LD_VAR 0 12
77104: PUSH
77105: LD_VAR 0 7
77109: ARRAY
77110: PUSH
77111: LD_INT 1
77113: ARRAY
77114: PPUSH
77115: LD_VAR 0 12
77119: PUSH
77120: LD_VAR 0 7
77124: ARRAY
77125: PUSH
77126: LD_INT 2
77128: ARRAY
77129: PPUSH
77130: CALL_OW 351
77134: OR
77135: IFFALSE 77141
// exit ;
77137: POP
77138: POP
77139: GO 77433
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77141: LD_ADDR_VAR 0 8
77145: PUSH
77146: LD_VAR 0 12
77150: PUSH
77151: LD_VAR 0 7
77155: ARRAY
77156: PUSH
77157: LD_INT 1
77159: ARRAY
77160: PPUSH
77161: LD_VAR 0 12
77165: PUSH
77166: LD_VAR 0 7
77170: ARRAY
77171: PUSH
77172: LD_INT 2
77174: ARRAY
77175: PPUSH
77176: CALL_OW 546
77180: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77181: LD_VAR 0 8
77185: PUSH
77186: LD_INT 1
77188: ARRAY
77189: PUSH
77190: LD_VAR 0 8
77194: PUSH
77195: LD_INT 2
77197: ARRAY
77198: PUSH
77199: LD_VAR 0 13
77203: PUSH
77204: LD_INT 2
77206: PLUS
77207: GREATER
77208: OR
77209: PUSH
77210: LD_VAR 0 8
77214: PUSH
77215: LD_INT 2
77217: ARRAY
77218: PUSH
77219: LD_VAR 0 13
77223: PUSH
77224: LD_INT 2
77226: MINUS
77227: LESS
77228: OR
77229: PUSH
77230: LD_VAR 0 8
77234: PUSH
77235: LD_INT 3
77237: ARRAY
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: LD_INT 8
77244: PUSH
77245: LD_INT 9
77247: PUSH
77248: LD_INT 10
77250: PUSH
77251: LD_INT 11
77253: PUSH
77254: LD_INT 12
77256: PUSH
77257: LD_INT 13
77259: PUSH
77260: LD_INT 16
77262: PUSH
77263: LD_INT 17
77265: PUSH
77266: LD_INT 18
77268: PUSH
77269: LD_INT 19
77271: PUSH
77272: LD_INT 20
77274: PUSH
77275: LD_INT 21
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: IN
77293: NOT
77294: OR
77295: PUSH
77296: LD_VAR 0 8
77300: PUSH
77301: LD_INT 5
77303: ARRAY
77304: NOT
77305: OR
77306: PUSH
77307: LD_VAR 0 8
77311: PUSH
77312: LD_INT 6
77314: ARRAY
77315: PUSH
77316: LD_INT 1
77318: PUSH
77319: LD_INT 2
77321: PUSH
77322: LD_INT 7
77324: PUSH
77325: LD_INT 9
77327: PUSH
77328: LD_INT 10
77330: PUSH
77331: LD_INT 11
77333: PUSH
77334: EMPTY
77335: LIST
77336: LIST
77337: LIST
77338: LIST
77339: LIST
77340: LIST
77341: IN
77342: NOT
77343: OR
77344: IFFALSE 77350
// exit ;
77346: POP
77347: POP
77348: GO 77433
// end ;
77350: GO 77021
77352: POP
77353: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77354: LD_VAR 0 9
77358: PPUSH
77359: LD_VAR 0 3
77363: PPUSH
77364: LD_VAR 0 4
77368: PPUSH
77369: LD_INT 20
77371: PPUSH
77372: CALL 69385 0 4
77376: PUSH
77377: LD_INT 4
77379: ARRAY
77380: IFFALSE 77384
// exit ;
77382: GO 77433
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77384: LD_VAR 0 2
77388: PUSH
77389: LD_INT 29
77391: PUSH
77392: LD_INT 30
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: IN
77399: PUSH
77400: LD_VAR 0 3
77404: PPUSH
77405: LD_VAR 0 4
77409: PPUSH
77410: LD_VAR 0 9
77414: PPUSH
77415: CALL_OW 440
77419: NOT
77420: AND
77421: IFFALSE 77425
// exit ;
77423: GO 77433
// result := true ;
77425: LD_ADDR_VAR 0 6
77429: PUSH
77430: LD_INT 1
77432: ST_TO_ADDR
// end ;
77433: LD_VAR 0 6
77437: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
77438: LD_INT 0
77440: PPUSH
77441: PPUSH
77442: PPUSH
77443: PPUSH
77444: PPUSH
77445: PPUSH
77446: PPUSH
77447: PPUSH
77448: PPUSH
77449: PPUSH
77450: PPUSH
77451: PPUSH
77452: PPUSH
77453: PPUSH
77454: PPUSH
77455: PPUSH
77456: PPUSH
77457: PPUSH
77458: PPUSH
77459: PPUSH
77460: PPUSH
77461: PPUSH
77462: PPUSH
77463: PPUSH
77464: PPUSH
77465: PPUSH
77466: PPUSH
77467: PPUSH
77468: PPUSH
77469: PPUSH
77470: PPUSH
77471: PPUSH
77472: PPUSH
77473: PPUSH
77474: PPUSH
77475: PPUSH
77476: PPUSH
77477: PPUSH
77478: PPUSH
77479: PPUSH
77480: PPUSH
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
77486: PPUSH
77487: PPUSH
77488: PPUSH
77489: PPUSH
77490: PPUSH
77491: PPUSH
77492: PPUSH
77493: PPUSH
77494: PPUSH
77495: PPUSH
77496: PPUSH
77497: PPUSH
// result = [ ] ;
77498: LD_ADDR_VAR 0 7
77502: PUSH
77503: EMPTY
77504: ST_TO_ADDR
// temp_list = [ ] ;
77505: LD_ADDR_VAR 0 9
77509: PUSH
77510: EMPTY
77511: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77512: LD_VAR 0 4
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: LD_INT 1
77522: PUSH
77523: LD_INT 2
77525: PUSH
77526: LD_INT 3
77528: PUSH
77529: LD_INT 4
77531: PUSH
77532: LD_INT 5
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: LIST
77539: LIST
77540: LIST
77541: LIST
77542: IN
77543: NOT
77544: PUSH
77545: LD_VAR 0 1
77549: PUSH
77550: LD_INT 0
77552: PUSH
77553: LD_INT 1
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: IN
77560: PUSH
77561: LD_VAR 0 5
77565: PUSH
77566: LD_INT 1
77568: PUSH
77569: LD_INT 2
77571: PUSH
77572: LD_INT 3
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: LIST
77579: IN
77580: NOT
77581: AND
77582: OR
77583: IFFALSE 77587
// exit ;
77585: GO 95978
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77587: LD_VAR 0 1
77591: PUSH
77592: LD_INT 6
77594: PUSH
77595: LD_INT 7
77597: PUSH
77598: LD_INT 8
77600: PUSH
77601: LD_INT 13
77603: PUSH
77604: LD_INT 12
77606: PUSH
77607: LD_INT 15
77609: PUSH
77610: LD_INT 11
77612: PUSH
77613: LD_INT 14
77615: PUSH
77616: LD_INT 10
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: IN
77630: IFFALSE 77640
// btype = b_lab ;
77632: LD_ADDR_VAR 0 1
77636: PUSH
77637: LD_INT 6
77639: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77640: LD_VAR 0 6
77644: PUSH
77645: LD_INT 0
77647: PUSH
77648: LD_INT 1
77650: PUSH
77651: LD_INT 2
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: LIST
77658: IN
77659: NOT
77660: PUSH
77661: LD_VAR 0 1
77665: PUSH
77666: LD_INT 0
77668: PUSH
77669: LD_INT 1
77671: PUSH
77672: LD_INT 2
77674: PUSH
77675: LD_INT 3
77677: PUSH
77678: LD_INT 6
77680: PUSH
77681: LD_INT 36
77683: PUSH
77684: LD_INT 4
77686: PUSH
77687: LD_INT 5
77689: PUSH
77690: LD_INT 31
77692: PUSH
77693: LD_INT 32
77695: PUSH
77696: LD_INT 33
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: IN
77712: NOT
77713: PUSH
77714: LD_VAR 0 6
77718: PUSH
77719: LD_INT 1
77721: EQUAL
77722: AND
77723: OR
77724: PUSH
77725: LD_VAR 0 1
77729: PUSH
77730: LD_INT 2
77732: PUSH
77733: LD_INT 3
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: IN
77740: NOT
77741: PUSH
77742: LD_VAR 0 6
77746: PUSH
77747: LD_INT 2
77749: EQUAL
77750: AND
77751: OR
77752: IFFALSE 77762
// mode = 0 ;
77754: LD_ADDR_VAR 0 6
77758: PUSH
77759: LD_INT 0
77761: ST_TO_ADDR
// case mode of 0 :
77762: LD_VAR 0 6
77766: PUSH
77767: LD_INT 0
77769: DOUBLE
77770: EQUAL
77771: IFTRUE 77775
77773: GO 89228
77775: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77776: LD_ADDR_VAR 0 11
77780: PUSH
77781: LD_INT 0
77783: PUSH
77784: LD_INT 0
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 0
77793: PUSH
77794: LD_INT 1
77796: NEG
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 1
77804: PUSH
77805: LD_INT 0
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 1
77814: PUSH
77815: LD_INT 1
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 0
77824: PUSH
77825: LD_INT 1
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: PUSH
77832: LD_INT 1
77834: NEG
77835: PUSH
77836: LD_INT 0
77838: PUSH
77839: EMPTY
77840: LIST
77841: LIST
77842: PUSH
77843: LD_INT 1
77845: NEG
77846: PUSH
77847: LD_INT 1
77849: NEG
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 1
77857: NEG
77858: PUSH
77859: LD_INT 2
77861: NEG
77862: PUSH
77863: EMPTY
77864: LIST
77865: LIST
77866: PUSH
77867: LD_INT 0
77869: PUSH
77870: LD_INT 2
77872: NEG
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PUSH
77878: LD_INT 1
77880: PUSH
77881: LD_INT 1
77883: NEG
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 1
77891: PUSH
77892: LD_INT 2
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 0
77901: PUSH
77902: LD_INT 2
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 1
77911: NEG
77912: PUSH
77913: LD_INT 1
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: PUSH
77920: LD_INT 1
77922: PUSH
77923: LD_INT 3
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 0
77932: PUSH
77933: LD_INT 3
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 1
77942: NEG
77943: PUSH
77944: LD_INT 2
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: EMPTY
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: LIST
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77969: LD_ADDR_VAR 0 12
77973: PUSH
77974: LD_INT 0
77976: PUSH
77977: LD_INT 0
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 0
77986: PUSH
77987: LD_INT 1
77989: NEG
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: PUSH
77995: LD_INT 1
77997: PUSH
77998: LD_INT 0
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 1
78007: PUSH
78008: LD_INT 1
78010: PUSH
78011: EMPTY
78012: LIST
78013: LIST
78014: PUSH
78015: LD_INT 0
78017: PUSH
78018: LD_INT 1
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: PUSH
78025: LD_INT 1
78027: NEG
78028: PUSH
78029: LD_INT 0
78031: PUSH
78032: EMPTY
78033: LIST
78034: LIST
78035: PUSH
78036: LD_INT 1
78038: NEG
78039: PUSH
78040: LD_INT 1
78042: NEG
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 1
78050: PUSH
78051: LD_INT 1
78053: NEG
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 2
78061: PUSH
78062: LD_INT 0
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 2
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 1
78081: NEG
78082: PUSH
78083: LD_INT 1
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 2
78092: NEG
78093: PUSH
78094: LD_INT 0
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 2
78103: NEG
78104: PUSH
78105: LD_INT 1
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 2
78115: NEG
78116: PUSH
78117: LD_INT 1
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: LD_INT 3
78126: NEG
78127: PUSH
78128: LD_INT 0
78130: PUSH
78131: EMPTY
78132: LIST
78133: LIST
78134: PUSH
78135: LD_INT 3
78137: NEG
78138: PUSH
78139: LD_INT 1
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78165: LD_ADDR_VAR 0 13
78169: PUSH
78170: LD_INT 0
78172: PUSH
78173: LD_INT 0
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 0
78182: PUSH
78183: LD_INT 1
78185: NEG
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 1
78193: PUSH
78194: LD_INT 0
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 1
78203: PUSH
78204: LD_INT 1
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 0
78213: PUSH
78214: LD_INT 1
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: PUSH
78221: LD_INT 1
78223: NEG
78224: PUSH
78225: LD_INT 0
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PUSH
78232: LD_INT 1
78234: NEG
78235: PUSH
78236: LD_INT 1
78238: NEG
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 1
78246: NEG
78247: PUSH
78248: LD_INT 2
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 2
78258: PUSH
78259: LD_INT 1
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 2
78268: PUSH
78269: LD_INT 2
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 1
78278: PUSH
78279: LD_INT 2
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 2
78288: NEG
78289: PUSH
78290: LD_INT 1
78292: NEG
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 2
78300: NEG
78301: PUSH
78302: LD_INT 2
78304: NEG
78305: PUSH
78306: EMPTY
78307: LIST
78308: LIST
78309: PUSH
78310: LD_INT 2
78312: NEG
78313: PUSH
78314: LD_INT 3
78316: NEG
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 3
78324: NEG
78325: PUSH
78326: LD_INT 2
78328: NEG
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 3
78336: NEG
78337: PUSH
78338: LD_INT 3
78340: NEG
78341: PUSH
78342: EMPTY
78343: LIST
78344: LIST
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78364: LD_ADDR_VAR 0 14
78368: PUSH
78369: LD_INT 0
78371: PUSH
78372: LD_INT 0
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 0
78381: PUSH
78382: LD_INT 1
78384: NEG
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 1
78392: PUSH
78393: LD_INT 0
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 1
78402: PUSH
78403: LD_INT 1
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 0
78412: PUSH
78413: LD_INT 1
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 1
78422: NEG
78423: PUSH
78424: LD_INT 0
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 1
78433: NEG
78434: PUSH
78435: LD_INT 1
78437: NEG
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: PUSH
78443: LD_INT 1
78445: NEG
78446: PUSH
78447: LD_INT 2
78449: NEG
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: LD_INT 2
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: PUSH
78469: LD_INT 1
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 1
78479: PUSH
78480: LD_INT 2
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 0
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: LD_INT 1
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: LD_INT 1
78510: NEG
78511: PUSH
78512: LD_INT 3
78514: NEG
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 0
78522: PUSH
78523: LD_INT 3
78525: NEG
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 1
78533: PUSH
78534: LD_INT 2
78536: NEG
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78560: LD_ADDR_VAR 0 15
78564: PUSH
78565: LD_INT 0
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 0
78577: PUSH
78578: LD_INT 1
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: LD_INT 0
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 1
78598: PUSH
78599: LD_INT 1
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 0
78608: PUSH
78609: LD_INT 1
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: LD_INT 0
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 1
78629: NEG
78630: PUSH
78631: LD_INT 1
78633: NEG
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 1
78641: PUSH
78642: LD_INT 1
78644: NEG
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 2
78652: PUSH
78653: LD_INT 0
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 2
78662: PUSH
78663: LD_INT 1
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: PUSH
78674: LD_INT 1
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 2
78683: NEG
78684: PUSH
78685: LD_INT 0
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 2
78694: NEG
78695: PUSH
78696: LD_INT 1
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 2
78706: PUSH
78707: LD_INT 1
78709: NEG
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 3
78717: PUSH
78718: LD_INT 0
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 3
78727: PUSH
78728: LD_INT 1
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78753: LD_ADDR_VAR 0 16
78757: PUSH
78758: LD_INT 0
78760: PUSH
78761: LD_INT 0
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 0
78770: PUSH
78771: LD_INT 1
78773: NEG
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 1
78781: PUSH
78782: LD_INT 0
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: PUSH
78789: LD_INT 1
78791: PUSH
78792: LD_INT 1
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 0
78801: PUSH
78802: LD_INT 1
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 1
78811: NEG
78812: PUSH
78813: LD_INT 0
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 1
78822: NEG
78823: PUSH
78824: LD_INT 1
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 1
78834: NEG
78835: PUSH
78836: LD_INT 2
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 2
78846: PUSH
78847: LD_INT 1
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 2
78856: PUSH
78857: LD_INT 2
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 1
78866: PUSH
78867: LD_INT 2
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 2
78876: NEG
78877: PUSH
78878: LD_INT 1
78880: NEG
78881: PUSH
78882: EMPTY
78883: LIST
78884: LIST
78885: PUSH
78886: LD_INT 2
78888: NEG
78889: PUSH
78890: LD_INT 2
78892: NEG
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 3
78900: PUSH
78901: LD_INT 2
78903: PUSH
78904: EMPTY
78905: LIST
78906: LIST
78907: PUSH
78908: LD_INT 3
78910: PUSH
78911: LD_INT 3
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 2
78920: PUSH
78921: LD_INT 3
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: LIST
78941: LIST
78942: LIST
78943: LIST
78944: LIST
78945: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78946: LD_ADDR_VAR 0 17
78950: PUSH
78951: LD_INT 0
78953: PUSH
78954: LD_INT 0
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: LD_INT 0
78963: PUSH
78964: LD_INT 1
78966: NEG
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 1
78974: PUSH
78975: LD_INT 0
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 1
78984: PUSH
78985: LD_INT 1
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: PUSH
78992: LD_INT 0
78994: PUSH
78995: LD_INT 1
78997: PUSH
78998: EMPTY
78999: LIST
79000: LIST
79001: PUSH
79002: LD_INT 1
79004: NEG
79005: PUSH
79006: LD_INT 0
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 1
79015: NEG
79016: PUSH
79017: LD_INT 1
79019: NEG
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: LD_INT 1
79027: NEG
79028: PUSH
79029: LD_INT 2
79031: NEG
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 0
79039: PUSH
79040: LD_INT 2
79042: NEG
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: LD_INT 1
79053: NEG
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 2
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 2
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 2
79081: PUSH
79082: LD_INT 2
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 1
79091: PUSH
79092: LD_INT 2
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 0
79101: PUSH
79102: LD_INT 2
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 1
79111: NEG
79112: PUSH
79113: LD_INT 1
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 2
79122: NEG
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 2
79133: NEG
79134: PUSH
79135: LD_INT 1
79137: NEG
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: LD_INT 2
79145: NEG
79146: PUSH
79147: LD_INT 2
79149: NEG
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79176: LD_ADDR_VAR 0 18
79180: PUSH
79181: LD_INT 0
79183: PUSH
79184: LD_INT 0
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: LD_INT 1
79196: NEG
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PUSH
79202: LD_INT 1
79204: PUSH
79205: LD_INT 0
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PUSH
79212: LD_INT 1
79214: PUSH
79215: LD_INT 1
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 0
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 1
79234: NEG
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 1
79245: NEG
79246: PUSH
79247: LD_INT 1
79249: NEG
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 1
79257: NEG
79258: PUSH
79259: LD_INT 2
79261: NEG
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 0
79269: PUSH
79270: LD_INT 2
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: PUSH
79281: LD_INT 1
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 2
79291: PUSH
79292: LD_INT 0
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 2
79301: PUSH
79302: LD_INT 1
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 2
79311: PUSH
79312: LD_INT 2
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 1
79321: PUSH
79322: LD_INT 2
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 0
79331: PUSH
79332: LD_INT 2
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: LD_INT 1
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 2
79352: NEG
79353: PUSH
79354: LD_INT 0
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 2
79363: NEG
79364: PUSH
79365: LD_INT 1
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 2
79375: NEG
79376: PUSH
79377: LD_INT 2
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79406: LD_ADDR_VAR 0 19
79410: PUSH
79411: LD_INT 0
79413: PUSH
79414: LD_INT 0
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 0
79423: PUSH
79424: LD_INT 1
79426: NEG
79427: PUSH
79428: EMPTY
79429: LIST
79430: LIST
79431: PUSH
79432: LD_INT 1
79434: PUSH
79435: LD_INT 0
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: PUSH
79442: LD_INT 1
79444: PUSH
79445: LD_INT 1
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: LD_INT 1
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: LD_INT 1
79464: NEG
79465: PUSH
79466: LD_INT 0
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 1
79475: NEG
79476: PUSH
79477: LD_INT 1
79479: NEG
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 1
79487: NEG
79488: PUSH
79489: LD_INT 2
79491: NEG
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 0
79499: PUSH
79500: LD_INT 2
79502: NEG
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 1
79510: PUSH
79511: LD_INT 1
79513: NEG
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 2
79521: PUSH
79522: LD_INT 0
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 2
79531: PUSH
79532: LD_INT 1
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 2
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 1
79551: PUSH
79552: LD_INT 2
79554: PUSH
79555: EMPTY
79556: LIST
79557: LIST
79558: PUSH
79559: LD_INT 0
79561: PUSH
79562: LD_INT 2
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 1
79571: NEG
79572: PUSH
79573: LD_INT 1
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 2
79582: NEG
79583: PUSH
79584: LD_INT 0
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 2
79593: NEG
79594: PUSH
79595: LD_INT 1
79597: NEG
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 2
79605: NEG
79606: PUSH
79607: LD_INT 2
79609: NEG
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79636: LD_ADDR_VAR 0 20
79640: PUSH
79641: LD_INT 0
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: LD_INT 1
79656: NEG
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: LD_INT 1
79664: PUSH
79665: LD_INT 0
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 1
79674: PUSH
79675: LD_INT 1
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: LD_INT 1
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 1
79694: NEG
79695: PUSH
79696: LD_INT 0
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 1
79705: NEG
79706: PUSH
79707: LD_INT 1
79709: NEG
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: PUSH
79715: LD_INT 1
79717: NEG
79718: PUSH
79719: LD_INT 2
79721: NEG
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: PUSH
79727: LD_INT 0
79729: PUSH
79730: LD_INT 2
79732: NEG
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 1
79740: PUSH
79741: LD_INT 1
79743: NEG
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 2
79751: PUSH
79752: LD_INT 0
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 2
79761: PUSH
79762: LD_INT 1
79764: PUSH
79765: EMPTY
79766: LIST
79767: LIST
79768: PUSH
79769: LD_INT 2
79771: PUSH
79772: LD_INT 2
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: PUSH
79779: LD_INT 1
79781: PUSH
79782: LD_INT 2
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 0
79791: PUSH
79792: LD_INT 2
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: LD_INT 1
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: LD_INT 2
79812: NEG
79813: PUSH
79814: LD_INT 0
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: PUSH
79821: LD_INT 2
79823: NEG
79824: PUSH
79825: LD_INT 1
79827: NEG
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 2
79835: NEG
79836: PUSH
79837: LD_INT 2
79839: NEG
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79866: LD_ADDR_VAR 0 21
79870: PUSH
79871: LD_INT 0
79873: PUSH
79874: LD_INT 0
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 0
79883: PUSH
79884: LD_INT 1
79886: NEG
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PUSH
79892: LD_INT 1
79894: PUSH
79895: LD_INT 0
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 1
79904: PUSH
79905: LD_INT 1
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 1
79924: NEG
79925: PUSH
79926: LD_INT 0
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 1
79935: NEG
79936: PUSH
79937: LD_INT 1
79939: NEG
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 1
79947: NEG
79948: PUSH
79949: LD_INT 2
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 0
79959: PUSH
79960: LD_INT 2
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: PUSH
79971: LD_INT 1
79973: NEG
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 2
79981: PUSH
79982: LD_INT 0
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 2
79991: PUSH
79992: LD_INT 1
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 2
80001: PUSH
80002: LD_INT 2
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: LD_INT 1
80011: PUSH
80012: LD_INT 2
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 0
80021: PUSH
80022: LD_INT 2
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 1
80031: NEG
80032: PUSH
80033: LD_INT 1
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 2
80042: NEG
80043: PUSH
80044: LD_INT 0
80046: PUSH
80047: EMPTY
80048: LIST
80049: LIST
80050: PUSH
80051: LD_INT 2
80053: NEG
80054: PUSH
80055: LD_INT 1
80057: NEG
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 2
80065: NEG
80066: PUSH
80067: LD_INT 2
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80096: LD_ADDR_VAR 0 22
80100: PUSH
80101: LD_INT 0
80103: PUSH
80104: LD_INT 0
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 0
80113: PUSH
80114: LD_INT 1
80116: NEG
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PUSH
80122: LD_INT 1
80124: PUSH
80125: LD_INT 0
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: PUSH
80132: LD_INT 1
80134: PUSH
80135: LD_INT 1
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: LD_INT 1
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 1
80154: NEG
80155: PUSH
80156: LD_INT 0
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 1
80165: NEG
80166: PUSH
80167: LD_INT 1
80169: NEG
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 1
80177: NEG
80178: PUSH
80179: LD_INT 2
80181: NEG
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: LD_INT 2
80192: NEG
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 1
80200: PUSH
80201: LD_INT 1
80203: NEG
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 2
80211: PUSH
80212: LD_INT 0
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 2
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 2
80231: PUSH
80232: LD_INT 2
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 1
80241: PUSH
80242: LD_INT 2
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 0
80251: PUSH
80252: LD_INT 2
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 1
80261: NEG
80262: PUSH
80263: LD_INT 1
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: LD_INT 0
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 2
80283: NEG
80284: PUSH
80285: LD_INT 1
80287: NEG
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 2
80295: NEG
80296: PUSH
80297: LD_INT 2
80299: NEG
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: LIST
80322: LIST
80323: LIST
80324: LIST
80325: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80326: LD_ADDR_VAR 0 23
80330: PUSH
80331: LD_INT 0
80333: PUSH
80334: LD_INT 0
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: LD_INT 1
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 1
80354: PUSH
80355: LD_INT 0
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 1
80364: PUSH
80365: LD_INT 1
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: EMPTY
80379: LIST
80380: LIST
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 1
80395: NEG
80396: PUSH
80397: LD_INT 1
80399: NEG
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 1
80407: NEG
80408: PUSH
80409: LD_INT 2
80411: NEG
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: LD_INT 2
80422: NEG
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: PUSH
80431: LD_INT 1
80433: NEG
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 2
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 2
80451: PUSH
80452: LD_INT 1
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 2
80461: PUSH
80462: LD_INT 2
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: LD_INT 2
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 0
80481: PUSH
80482: LD_INT 2
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 1
80491: NEG
80492: PUSH
80493: LD_INT 1
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: LD_INT 2
80502: NEG
80503: PUSH
80504: LD_INT 0
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: LD_INT 2
80513: NEG
80514: PUSH
80515: LD_INT 1
80517: NEG
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 2
80525: NEG
80526: PUSH
80527: LD_INT 2
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 2
80537: NEG
80538: PUSH
80539: LD_INT 3
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 1
80549: NEG
80550: PUSH
80551: LD_INT 3
80553: NEG
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 1
80561: PUSH
80562: LD_INT 2
80564: NEG
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 2
80572: PUSH
80573: LD_INT 1
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80606: LD_ADDR_VAR 0 24
80610: PUSH
80611: LD_INT 0
80613: PUSH
80614: LD_INT 0
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 0
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: PUSH
80635: LD_INT 0
80637: PUSH
80638: EMPTY
80639: LIST
80640: LIST
80641: PUSH
80642: LD_INT 1
80644: PUSH
80645: LD_INT 1
80647: PUSH
80648: EMPTY
80649: LIST
80650: LIST
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: LD_INT 1
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: LD_INT 0
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: LD_INT 1
80679: NEG
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: NEG
80688: PUSH
80689: LD_INT 2
80691: NEG
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 0
80699: PUSH
80700: LD_INT 2
80702: NEG
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: PUSH
80708: LD_INT 1
80710: PUSH
80711: LD_INT 1
80713: NEG
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 2
80721: PUSH
80722: LD_INT 0
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 2
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: PUSH
80742: LD_INT 2
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: PUSH
80749: LD_INT 1
80751: PUSH
80752: LD_INT 2
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 0
80761: PUSH
80762: LD_INT 2
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 1
80771: NEG
80772: PUSH
80773: LD_INT 1
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 2
80782: NEG
80783: PUSH
80784: LD_INT 0
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: LD_INT 2
80793: NEG
80794: PUSH
80795: LD_INT 1
80797: NEG
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 2
80805: NEG
80806: PUSH
80807: LD_INT 2
80809: NEG
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 1
80817: PUSH
80818: LD_INT 2
80820: NEG
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 2
80828: PUSH
80829: LD_INT 1
80831: NEG
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PUSH
80837: LD_INT 3
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 3
80849: PUSH
80850: LD_INT 2
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80882: LD_ADDR_VAR 0 25
80886: PUSH
80887: LD_INT 0
80889: PUSH
80890: LD_INT 0
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 0
80899: PUSH
80900: LD_INT 1
80902: NEG
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 1
80910: PUSH
80911: LD_INT 0
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: LD_INT 1
80920: PUSH
80921: LD_INT 1
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 0
80930: PUSH
80931: LD_INT 1
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PUSH
80938: LD_INT 1
80940: NEG
80941: PUSH
80942: LD_INT 0
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 1
80951: NEG
80952: PUSH
80953: LD_INT 1
80955: NEG
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: LD_INT 2
80967: NEG
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 0
80975: PUSH
80976: LD_INT 2
80978: NEG
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: LD_INT 1
80989: NEG
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 2
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 2
81007: PUSH
81008: LD_INT 1
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 2
81017: PUSH
81018: LD_INT 2
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 1
81027: PUSH
81028: LD_INT 2
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 0
81037: PUSH
81038: LD_INT 2
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 1
81047: NEG
81048: PUSH
81049: LD_INT 1
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 2
81058: NEG
81059: PUSH
81060: LD_INT 0
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 2
81069: NEG
81070: PUSH
81071: LD_INT 1
81073: NEG
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 2
81081: NEG
81082: PUSH
81083: LD_INT 2
81085: NEG
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 3
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 3
81103: PUSH
81104: LD_INT 2
81106: PUSH
81107: EMPTY
81108: LIST
81109: LIST
81110: PUSH
81111: LD_INT 2
81113: PUSH
81114: LD_INT 3
81116: PUSH
81117: EMPTY
81118: LIST
81119: LIST
81120: PUSH
81121: LD_INT 1
81123: PUSH
81124: LD_INT 3
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81156: LD_ADDR_VAR 0 26
81160: PUSH
81161: LD_INT 0
81163: PUSH
81164: LD_INT 0
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: LD_INT 1
81176: NEG
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 1
81184: PUSH
81185: LD_INT 0
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 1
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 0
81204: PUSH
81205: LD_INT 1
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 1
81225: NEG
81226: PUSH
81227: LD_INT 1
81229: NEG
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 1
81237: NEG
81238: PUSH
81239: LD_INT 2
81241: NEG
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 0
81249: PUSH
81250: LD_INT 2
81252: NEG
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PUSH
81258: LD_INT 1
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 2
81271: PUSH
81272: LD_INT 0
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 2
81281: PUSH
81282: LD_INT 1
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: LD_INT 2
81291: PUSH
81292: LD_INT 2
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: PUSH
81299: LD_INT 1
81301: PUSH
81302: LD_INT 2
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 0
81311: PUSH
81312: LD_INT 2
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: LD_INT 1
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 2
81332: NEG
81333: PUSH
81334: LD_INT 0
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: LD_INT 2
81343: NEG
81344: PUSH
81345: LD_INT 1
81347: NEG
81348: PUSH
81349: EMPTY
81350: LIST
81351: LIST
81352: PUSH
81353: LD_INT 2
81355: NEG
81356: PUSH
81357: LD_INT 2
81359: NEG
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 2
81367: PUSH
81368: LD_INT 3
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: PUSH
81375: LD_INT 1
81377: PUSH
81378: LD_INT 3
81380: PUSH
81381: EMPTY
81382: LIST
81383: LIST
81384: PUSH
81385: LD_INT 1
81387: NEG
81388: PUSH
81389: LD_INT 2
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 2
81398: NEG
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: LIST
81427: LIST
81428: LIST
81429: LIST
81430: LIST
81431: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81432: LD_ADDR_VAR 0 27
81436: PUSH
81437: LD_INT 0
81439: PUSH
81440: LD_INT 0
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 0
81449: PUSH
81450: LD_INT 1
81452: NEG
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: PUSH
81458: LD_INT 1
81460: PUSH
81461: LD_INT 0
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 1
81470: PUSH
81471: LD_INT 1
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 0
81480: PUSH
81481: LD_INT 1
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 1
81490: NEG
81491: PUSH
81492: LD_INT 0
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: NEG
81502: PUSH
81503: LD_INT 1
81505: NEG
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 1
81513: NEG
81514: PUSH
81515: LD_INT 2
81517: NEG
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: PUSH
81523: LD_INT 0
81525: PUSH
81526: LD_INT 2
81528: NEG
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: LD_INT 1
81539: NEG
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 2
81547: PUSH
81548: LD_INT 0
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 2
81557: PUSH
81558: LD_INT 1
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 2
81567: PUSH
81568: LD_INT 2
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: PUSH
81578: LD_INT 2
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 0
81587: PUSH
81588: LD_INT 2
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 1
81597: NEG
81598: PUSH
81599: LD_INT 1
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 2
81608: NEG
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 2
81619: NEG
81620: PUSH
81621: LD_INT 1
81623: NEG
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 2
81631: NEG
81632: PUSH
81633: LD_INT 2
81635: NEG
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 1
81643: NEG
81644: PUSH
81645: LD_INT 2
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: LD_INT 2
81654: NEG
81655: PUSH
81656: LD_INT 1
81658: PUSH
81659: EMPTY
81660: LIST
81661: LIST
81662: PUSH
81663: LD_INT 3
81665: NEG
81666: PUSH
81667: LD_INT 1
81669: NEG
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 3
81677: NEG
81678: PUSH
81679: LD_INT 2
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81712: LD_ADDR_VAR 0 28
81716: PUSH
81717: LD_INT 0
81719: PUSH
81720: LD_INT 0
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 0
81729: PUSH
81730: LD_INT 1
81732: NEG
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 1
81740: PUSH
81741: LD_INT 0
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 1
81750: PUSH
81751: LD_INT 1
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: LD_INT 1
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 1
81770: NEG
81771: PUSH
81772: LD_INT 0
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 1
81781: NEG
81782: PUSH
81783: LD_INT 1
81785: NEG
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: LD_INT 2
81797: NEG
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 0
81805: PUSH
81806: LD_INT 2
81808: NEG
81809: PUSH
81810: EMPTY
81811: LIST
81812: LIST
81813: PUSH
81814: LD_INT 1
81816: PUSH
81817: LD_INT 1
81819: NEG
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 2
81827: PUSH
81828: LD_INT 0
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: LD_INT 1
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 2
81847: PUSH
81848: LD_INT 2
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 1
81857: PUSH
81858: LD_INT 2
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: LD_INT 2
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: LD_INT 1
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 2
81888: NEG
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 2
81899: NEG
81900: PUSH
81901: LD_INT 1
81903: NEG
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 2
81911: NEG
81912: PUSH
81913: LD_INT 2
81915: NEG
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 2
81923: NEG
81924: PUSH
81925: LD_INT 3
81927: NEG
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 1
81935: NEG
81936: PUSH
81937: LD_INT 3
81939: NEG
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 3
81947: NEG
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 3
81959: NEG
81960: PUSH
81961: LD_INT 2
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81994: LD_ADDR_VAR 0 29
81998: PUSH
81999: LD_INT 0
82001: PUSH
82002: LD_INT 0
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 0
82011: PUSH
82012: LD_INT 1
82014: NEG
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 1
82022: PUSH
82023: LD_INT 0
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 1
82032: PUSH
82033: LD_INT 1
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 0
82042: PUSH
82043: LD_INT 1
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 1
82052: NEG
82053: PUSH
82054: LD_INT 0
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 1
82063: NEG
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: LD_INT 2
82079: NEG
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 0
82087: PUSH
82088: LD_INT 2
82090: NEG
82091: PUSH
82092: EMPTY
82093: LIST
82094: LIST
82095: PUSH
82096: LD_INT 1
82098: PUSH
82099: LD_INT 1
82101: NEG
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 2
82109: PUSH
82110: LD_INT 0
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_INT 2
82119: PUSH
82120: LD_INT 1
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 1
82129: PUSH
82130: LD_INT 2
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 0
82139: PUSH
82140: LD_INT 2
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 1
82149: NEG
82150: PUSH
82151: LD_INT 1
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 2
82160: NEG
82161: PUSH
82162: LD_INT 1
82164: NEG
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 2
82172: NEG
82173: PUSH
82174: LD_INT 2
82176: NEG
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 2
82184: NEG
82185: PUSH
82186: LD_INT 3
82188: NEG
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 2
82196: PUSH
82197: LD_INT 1
82199: NEG
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 3
82207: PUSH
82208: LD_INT 1
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 1
82217: PUSH
82218: LD_INT 3
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 1
82227: NEG
82228: PUSH
82229: LD_INT 2
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 3
82238: NEG
82239: PUSH
82240: LD_INT 2
82242: NEG
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82273: LD_ADDR_VAR 0 30
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 0
82290: PUSH
82291: LD_INT 1
82293: NEG
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 1
82301: PUSH
82302: LD_INT 0
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 1
82311: PUSH
82312: LD_INT 1
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 0
82321: PUSH
82322: LD_INT 1
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 1
82331: NEG
82332: PUSH
82333: LD_INT 0
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 1
82342: NEG
82343: PUSH
82344: LD_INT 1
82346: NEG
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 1
82354: NEG
82355: PUSH
82356: LD_INT 2
82358: NEG
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 0
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: LD_INT 1
82380: NEG
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 2
82388: PUSH
82389: LD_INT 0
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: PUSH
82396: LD_INT 2
82398: PUSH
82399: LD_INT 1
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 2
82408: PUSH
82409: LD_INT 2
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 1
82418: PUSH
82419: LD_INT 2
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 1
82428: NEG
82429: PUSH
82430: LD_INT 1
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 2
82439: NEG
82440: PUSH
82441: LD_INT 0
82443: PUSH
82444: EMPTY
82445: LIST
82446: LIST
82447: PUSH
82448: LD_INT 2
82450: NEG
82451: PUSH
82452: LD_INT 1
82454: NEG
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 1
82462: NEG
82463: PUSH
82464: LD_INT 3
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 1
82474: PUSH
82475: LD_INT 2
82477: NEG
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PUSH
82483: LD_INT 3
82485: PUSH
82486: LD_INT 2
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 2
82495: PUSH
82496: LD_INT 3
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 2
82505: NEG
82506: PUSH
82507: LD_INT 1
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 3
82516: NEG
82517: PUSH
82518: LD_INT 1
82520: NEG
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82551: LD_ADDR_VAR 0 31
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: LD_INT 0
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 0
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 1
82579: PUSH
82580: LD_INT 0
82582: PUSH
82583: EMPTY
82584: LIST
82585: LIST
82586: PUSH
82587: LD_INT 1
82589: PUSH
82590: LD_INT 1
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 0
82599: PUSH
82600: LD_INT 1
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: NEG
82610: PUSH
82611: LD_INT 0
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 1
82620: NEG
82621: PUSH
82622: LD_INT 1
82624: NEG
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 1
82632: NEG
82633: PUSH
82634: LD_INT 2
82636: NEG
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 1
82644: PUSH
82645: LD_INT 1
82647: NEG
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 2
82655: PUSH
82656: LD_INT 0
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 2
82665: PUSH
82666: LD_INT 1
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 2
82675: PUSH
82676: LD_INT 2
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 1
82685: PUSH
82686: LD_INT 2
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: LD_INT 2
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 1
82705: NEG
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 2
82716: NEG
82717: PUSH
82718: LD_INT 1
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 2
82728: NEG
82729: PUSH
82730: LD_INT 2
82732: NEG
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 2
82740: NEG
82741: PUSH
82742: LD_INT 3
82744: NEG
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 2
82752: PUSH
82753: LD_INT 1
82755: NEG
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 3
82763: PUSH
82764: LD_INT 1
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: LD_INT 3
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: NEG
82784: PUSH
82785: LD_INT 2
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 3
82794: NEG
82795: PUSH
82796: LD_INT 2
82798: NEG
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82829: LD_ADDR_VAR 0 32
82833: PUSH
82834: LD_INT 0
82836: PUSH
82837: LD_INT 0
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 0
82846: PUSH
82847: LD_INT 1
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 1
82857: PUSH
82858: LD_INT 0
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: LD_INT 1
82867: PUSH
82868: LD_INT 1
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: LD_INT 0
82877: PUSH
82878: LD_INT 1
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 1
82887: NEG
82888: PUSH
82889: LD_INT 0
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 1
82898: NEG
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: LD_INT 2
82914: NEG
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 0
82922: PUSH
82923: LD_INT 2
82925: NEG
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: PUSH
82931: LD_INT 1
82933: PUSH
82934: LD_INT 1
82936: NEG
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 2
82944: PUSH
82945: LD_INT 1
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 2
82954: PUSH
82955: LD_INT 2
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 1
82964: PUSH
82965: LD_INT 2
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: LD_INT 0
82974: PUSH
82975: LD_INT 2
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: PUSH
82982: LD_INT 1
82984: NEG
82985: PUSH
82986: LD_INT 1
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 2
82995: NEG
82996: PUSH
82997: LD_INT 0
82999: PUSH
83000: EMPTY
83001: LIST
83002: LIST
83003: PUSH
83004: LD_INT 2
83006: NEG
83007: PUSH
83008: LD_INT 1
83010: NEG
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: PUSH
83016: LD_INT 1
83018: NEG
83019: PUSH
83020: LD_INT 3
83022: NEG
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: LD_INT 1
83030: PUSH
83031: LD_INT 2
83033: NEG
83034: PUSH
83035: EMPTY
83036: LIST
83037: LIST
83038: PUSH
83039: LD_INT 3
83041: PUSH
83042: LD_INT 2
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: LD_INT 3
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 2
83061: NEG
83062: PUSH
83063: LD_INT 1
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 3
83072: NEG
83073: PUSH
83074: LD_INT 1
83076: NEG
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83107: LD_ADDR_VAR 0 33
83111: PUSH
83112: LD_INT 0
83114: PUSH
83115: LD_INT 0
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: LD_INT 1
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 1
83135: PUSH
83136: LD_INT 0
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 1
83145: PUSH
83146: LD_INT 1
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 0
83155: PUSH
83156: LD_INT 1
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 1
83165: NEG
83166: PUSH
83167: LD_INT 0
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 1
83176: NEG
83177: PUSH
83178: LD_INT 1
83180: NEG
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PUSH
83186: LD_INT 1
83188: NEG
83189: PUSH
83190: LD_INT 2
83192: NEG
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 1
83200: PUSH
83201: LD_INT 1
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 2
83211: PUSH
83212: LD_INT 0
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 2
83221: PUSH
83222: LD_INT 1
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 1
83231: PUSH
83232: LD_INT 2
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 0
83241: PUSH
83242: LD_INT 2
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: NEG
83252: PUSH
83253: LD_INT 1
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 2
83262: NEG
83263: PUSH
83264: LD_INT 0
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 2
83273: NEG
83274: PUSH
83275: LD_INT 1
83277: NEG
83278: PUSH
83279: EMPTY
83280: LIST
83281: LIST
83282: PUSH
83283: LD_INT 2
83285: NEG
83286: PUSH
83287: LD_INT 2
83289: NEG
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 2
83297: NEG
83298: PUSH
83299: LD_INT 3
83301: NEG
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 2
83309: PUSH
83310: LD_INT 1
83312: NEG
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 3
83320: PUSH
83321: LD_INT 1
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 1
83330: PUSH
83331: LD_INT 3
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 1
83340: NEG
83341: PUSH
83342: LD_INT 2
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 3
83351: NEG
83352: PUSH
83353: LD_INT 2
83355: NEG
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83386: LD_ADDR_VAR 0 34
83390: PUSH
83391: LD_INT 0
83393: PUSH
83394: LD_INT 0
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: LD_INT 1
83406: NEG
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 1
83414: PUSH
83415: LD_INT 0
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 1
83424: PUSH
83425: LD_INT 1
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 0
83434: PUSH
83435: LD_INT 1
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 1
83444: NEG
83445: PUSH
83446: LD_INT 0
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 1
83455: NEG
83456: PUSH
83457: LD_INT 1
83459: NEG
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: LD_INT 2
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 0
83479: PUSH
83480: LD_INT 2
83482: NEG
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: PUSH
83488: LD_INT 1
83490: PUSH
83491: LD_INT 1
83493: NEG
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 2
83501: PUSH
83502: LD_INT 1
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 2
83511: PUSH
83512: LD_INT 2
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 1
83521: PUSH
83522: LD_INT 2
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 1
83531: NEG
83532: PUSH
83533: LD_INT 1
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: LD_INT 2
83542: NEG
83543: PUSH
83544: LD_INT 0
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 2
83553: NEG
83554: PUSH
83555: LD_INT 1
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: NEG
83566: PUSH
83567: LD_INT 2
83569: NEG
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 1
83577: NEG
83578: PUSH
83579: LD_INT 3
83581: NEG
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: PUSH
83587: LD_INT 1
83589: PUSH
83590: LD_INT 2
83592: NEG
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 3
83600: PUSH
83601: LD_INT 2
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 2
83610: PUSH
83611: LD_INT 3
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 2
83620: NEG
83621: PUSH
83622: LD_INT 1
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: PUSH
83629: LD_INT 3
83631: NEG
83632: PUSH
83633: LD_INT 1
83635: NEG
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83666: LD_ADDR_VAR 0 35
83670: PUSH
83671: LD_INT 0
83673: PUSH
83674: LD_INT 0
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 0
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PUSH
83692: LD_INT 1
83694: PUSH
83695: LD_INT 0
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 1
83704: PUSH
83705: LD_INT 1
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 0
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 1
83724: NEG
83725: PUSH
83726: LD_INT 0
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: PUSH
83733: LD_INT 1
83735: NEG
83736: PUSH
83737: LD_INT 1
83739: NEG
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 2
83747: PUSH
83748: LD_INT 1
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 2
83757: NEG
83758: PUSH
83759: LD_INT 1
83761: NEG
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: LIST
83773: LIST
83774: LIST
83775: LIST
83776: LIST
83777: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83778: LD_ADDR_VAR 0 36
83782: PUSH
83783: LD_INT 0
83785: PUSH
83786: LD_INT 0
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 0
83795: PUSH
83796: LD_INT 1
83798: NEG
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: LD_INT 1
83806: PUSH
83807: LD_INT 0
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 1
83819: PUSH
83820: EMPTY
83821: LIST
83822: LIST
83823: PUSH
83824: LD_INT 0
83826: PUSH
83827: LD_INT 1
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 1
83836: NEG
83837: PUSH
83838: LD_INT 0
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 1
83847: NEG
83848: PUSH
83849: LD_INT 1
83851: NEG
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: LD_INT 1
83859: NEG
83860: PUSH
83861: LD_INT 2
83863: NEG
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: LD_INT 2
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83890: LD_ADDR_VAR 0 37
83894: PUSH
83895: LD_INT 0
83897: PUSH
83898: LD_INT 0
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: LD_INT 0
83907: PUSH
83908: LD_INT 1
83910: NEG
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 1
83918: PUSH
83919: LD_INT 0
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 1
83928: PUSH
83929: LD_INT 1
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: PUSH
83946: LD_INT 1
83948: NEG
83949: PUSH
83950: LD_INT 0
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 1
83959: NEG
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 1
83971: PUSH
83972: LD_INT 1
83974: NEG
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 1
83982: NEG
83983: PUSH
83984: LD_INT 1
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84002: LD_ADDR_VAR 0 38
84006: PUSH
84007: LD_INT 0
84009: PUSH
84010: LD_INT 0
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 0
84019: PUSH
84020: LD_INT 1
84022: NEG
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 1
84030: PUSH
84031: LD_INT 0
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 1
84040: PUSH
84041: LD_INT 1
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 0
84050: PUSH
84051: LD_INT 1
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 1
84060: NEG
84061: PUSH
84062: LD_INT 0
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: PUSH
84069: LD_INT 1
84071: NEG
84072: PUSH
84073: LD_INT 1
84075: NEG
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 2
84083: PUSH
84084: LD_INT 1
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 2
84093: NEG
84094: PUSH
84095: LD_INT 1
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84114: LD_ADDR_VAR 0 39
84118: PUSH
84119: LD_INT 0
84121: PUSH
84122: LD_INT 0
84124: PUSH
84125: EMPTY
84126: LIST
84127: LIST
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: LD_INT 1
84134: NEG
84135: PUSH
84136: EMPTY
84137: LIST
84138: LIST
84139: PUSH
84140: LD_INT 1
84142: PUSH
84143: LD_INT 0
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: PUSH
84153: LD_INT 1
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: LD_INT 1
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 1
84172: NEG
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 1
84183: NEG
84184: PUSH
84185: LD_INT 1
84187: NEG
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 1
84195: NEG
84196: PUSH
84197: LD_INT 2
84199: NEG
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 1
84207: PUSH
84208: LD_INT 2
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84226: LD_ADDR_VAR 0 40
84230: PUSH
84231: LD_INT 0
84233: PUSH
84234: LD_INT 0
84236: PUSH
84237: EMPTY
84238: LIST
84239: LIST
84240: PUSH
84241: LD_INT 0
84243: PUSH
84244: LD_INT 1
84246: NEG
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: PUSH
84252: LD_INT 1
84254: PUSH
84255: LD_INT 0
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: PUSH
84265: LD_INT 1
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 0
84274: PUSH
84275: LD_INT 1
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 1
84284: NEG
84285: PUSH
84286: LD_INT 0
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PUSH
84293: LD_INT 1
84295: NEG
84296: PUSH
84297: LD_INT 1
84299: NEG
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: PUSH
84305: LD_INT 1
84307: PUSH
84308: LD_INT 1
84310: NEG
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: LD_INT 1
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84338: LD_ADDR_VAR 0 41
84342: PUSH
84343: LD_INT 0
84345: PUSH
84346: LD_INT 0
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: PUSH
84353: LD_INT 0
84355: PUSH
84356: LD_INT 1
84358: NEG
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 1
84366: PUSH
84367: LD_INT 0
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: LD_INT 1
84376: PUSH
84377: LD_INT 1
84379: PUSH
84380: EMPTY
84381: LIST
84382: LIST
84383: PUSH
84384: LD_INT 0
84386: PUSH
84387: LD_INT 1
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 1
84396: NEG
84397: PUSH
84398: LD_INT 0
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 1
84407: NEG
84408: PUSH
84409: LD_INT 1
84411: NEG
84412: PUSH
84413: EMPTY
84414: LIST
84415: LIST
84416: PUSH
84417: LD_INT 1
84419: NEG
84420: PUSH
84421: LD_INT 2
84423: NEG
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 1
84431: PUSH
84432: LD_INT 1
84434: NEG
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: PUSH
84440: LD_INT 2
84442: PUSH
84443: LD_INT 0
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: PUSH
84450: LD_INT 2
84452: PUSH
84453: LD_INT 1
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 2
84462: PUSH
84463: LD_INT 2
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 1
84472: PUSH
84473: LD_INT 2
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: NEG
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 2
84493: NEG
84494: PUSH
84495: LD_INT 0
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 2
84504: NEG
84505: PUSH
84506: LD_INT 1
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 2
84516: NEG
84517: PUSH
84518: LD_INT 2
84520: NEG
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: LD_INT 2
84528: NEG
84529: PUSH
84530: LD_INT 3
84532: NEG
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 2
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 3
84551: PUSH
84552: LD_INT 0
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 3
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 3
84571: PUSH
84572: LD_INT 2
84574: PUSH
84575: EMPTY
84576: LIST
84577: LIST
84578: PUSH
84579: LD_INT 3
84581: PUSH
84582: LD_INT 3
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: PUSH
84589: LD_INT 2
84591: PUSH
84592: LD_INT 3
84594: PUSH
84595: EMPTY
84596: LIST
84597: LIST
84598: PUSH
84599: LD_INT 2
84601: NEG
84602: PUSH
84603: LD_INT 1
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 3
84612: NEG
84613: PUSH
84614: LD_INT 0
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 3
84623: NEG
84624: PUSH
84625: LD_INT 1
84627: NEG
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 3
84635: NEG
84636: PUSH
84637: LD_INT 2
84639: NEG
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 3
84647: NEG
84648: PUSH
84649: LD_INT 3
84651: NEG
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84688: LD_ADDR_VAR 0 42
84692: PUSH
84693: LD_INT 0
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 0
84705: PUSH
84706: LD_INT 1
84708: NEG
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 1
84716: PUSH
84717: LD_INT 0
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 1
84726: PUSH
84727: LD_INT 1
84729: PUSH
84730: EMPTY
84731: LIST
84732: LIST
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: LD_INT 1
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 1
84746: NEG
84747: PUSH
84748: LD_INT 0
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: LD_INT 1
84761: NEG
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 1
84769: NEG
84770: PUSH
84771: LD_INT 2
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 0
84781: PUSH
84782: LD_INT 2
84784: NEG
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 1
84792: PUSH
84793: LD_INT 1
84795: NEG
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 2
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 2
84813: PUSH
84814: LD_INT 2
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 0
84833: PUSH
84834: LD_INT 2
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PUSH
84841: LD_INT 1
84843: NEG
84844: PUSH
84845: LD_INT 1
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 2
84854: NEG
84855: PUSH
84856: LD_INT 1
84858: NEG
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 2
84866: NEG
84867: PUSH
84868: LD_INT 2
84870: NEG
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: PUSH
84876: LD_INT 2
84878: NEG
84879: PUSH
84880: LD_INT 3
84882: NEG
84883: PUSH
84884: EMPTY
84885: LIST
84886: LIST
84887: PUSH
84888: LD_INT 1
84890: NEG
84891: PUSH
84892: LD_INT 3
84894: NEG
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 0
84902: PUSH
84903: LD_INT 3
84905: NEG
84906: PUSH
84907: EMPTY
84908: LIST
84909: LIST
84910: PUSH
84911: LD_INT 1
84913: PUSH
84914: LD_INT 2
84916: NEG
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 3
84924: PUSH
84925: LD_INT 2
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: PUSH
84932: LD_INT 3
84934: PUSH
84935: LD_INT 3
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PUSH
84942: LD_INT 2
84944: PUSH
84945: LD_INT 3
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: PUSH
84952: LD_INT 1
84954: PUSH
84955: LD_INT 3
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 0
84964: PUSH
84965: LD_INT 3
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 1
84974: NEG
84975: PUSH
84976: LD_INT 2
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 3
84985: NEG
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 3
84997: NEG
84998: PUSH
84999: LD_INT 3
85001: NEG
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: LIST
85033: LIST
85034: LIST
85035: LIST
85036: LIST
85037: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85038: LD_ADDR_VAR 0 43
85042: PUSH
85043: LD_INT 0
85045: PUSH
85046: LD_INT 0
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 0
85055: PUSH
85056: LD_INT 1
85058: NEG
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 1
85066: PUSH
85067: LD_INT 0
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 1
85076: PUSH
85077: LD_INT 1
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: LD_INT 0
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: NEG
85097: PUSH
85098: LD_INT 0
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PUSH
85105: LD_INT 1
85107: NEG
85108: PUSH
85109: LD_INT 1
85111: NEG
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 1
85119: NEG
85120: PUSH
85121: LD_INT 2
85123: NEG
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 0
85131: PUSH
85132: LD_INT 2
85134: NEG
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: LD_INT 1
85145: NEG
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 2
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 2
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 1
85173: PUSH
85174: LD_INT 2
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 0
85183: PUSH
85184: LD_INT 2
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 1
85193: NEG
85194: PUSH
85195: LD_INT 1
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PUSH
85202: LD_INT 2
85204: NEG
85205: PUSH
85206: LD_INT 0
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 2
85215: NEG
85216: PUSH
85217: LD_INT 1
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: LD_INT 3
85231: NEG
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 0
85239: PUSH
85240: LD_INT 3
85242: NEG
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: LD_INT 1
85250: PUSH
85251: LD_INT 2
85253: NEG
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 2
85261: PUSH
85262: LD_INT 1
85264: NEG
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: LD_INT 3
85272: PUSH
85273: LD_INT 0
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: PUSH
85280: LD_INT 3
85282: PUSH
85283: LD_INT 1
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 1
85292: PUSH
85293: LD_INT 3
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 0
85302: PUSH
85303: LD_INT 3
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 1
85312: NEG
85313: PUSH
85314: LD_INT 2
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 2
85323: NEG
85324: PUSH
85325: LD_INT 1
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 3
85334: NEG
85335: PUSH
85336: LD_INT 0
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 3
85345: NEG
85346: PUSH
85347: LD_INT 1
85349: NEG
85350: PUSH
85351: EMPTY
85352: LIST
85353: LIST
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85386: LD_ADDR_VAR 0 44
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: LD_INT 1
85406: NEG
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 1
85424: PUSH
85425: LD_INT 1
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 0
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: NEG
85445: PUSH
85446: LD_INT 0
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 1
85455: NEG
85456: PUSH
85457: LD_INT 1
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: LD_INT 1
85467: NEG
85468: PUSH
85469: LD_INT 2
85471: NEG
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 1
85479: PUSH
85480: LD_INT 1
85482: NEG
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PUSH
85488: LD_INT 2
85490: PUSH
85491: LD_INT 0
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: PUSH
85498: LD_INT 2
85500: PUSH
85501: LD_INT 1
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: PUSH
85508: LD_INT 2
85510: PUSH
85511: LD_INT 2
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 1
85520: PUSH
85521: LD_INT 2
85523: PUSH
85524: EMPTY
85525: LIST
85526: LIST
85527: PUSH
85528: LD_INT 1
85530: NEG
85531: PUSH
85532: LD_INT 1
85534: PUSH
85535: EMPTY
85536: LIST
85537: LIST
85538: PUSH
85539: LD_INT 2
85541: NEG
85542: PUSH
85543: LD_INT 0
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 2
85552: NEG
85553: PUSH
85554: LD_INT 1
85556: NEG
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 2
85564: NEG
85565: PUSH
85566: LD_INT 2
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 2
85576: NEG
85577: PUSH
85578: LD_INT 3
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 2
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 3
85599: PUSH
85600: LD_INT 0
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 3
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 3
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 3
85629: PUSH
85630: LD_INT 3
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 2
85639: PUSH
85640: LD_INT 3
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 2
85649: NEG
85650: PUSH
85651: LD_INT 1
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 3
85660: NEG
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 3
85671: NEG
85672: PUSH
85673: LD_INT 1
85675: NEG
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 3
85683: NEG
85684: PUSH
85685: LD_INT 2
85687: NEG
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 3
85695: NEG
85696: PUSH
85697: LD_INT 3
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85736: LD_ADDR_VAR 0 45
85740: PUSH
85741: LD_INT 0
85743: PUSH
85744: LD_INT 0
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 0
85753: PUSH
85754: LD_INT 1
85756: NEG
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 1
85764: PUSH
85765: LD_INT 0
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 1
85774: PUSH
85775: LD_INT 1
85777: PUSH
85778: EMPTY
85779: LIST
85780: LIST
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: LD_INT 1
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: LD_INT 0
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 1
85805: NEG
85806: PUSH
85807: LD_INT 1
85809: NEG
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: LD_INT 2
85821: NEG
85822: PUSH
85823: EMPTY
85824: LIST
85825: LIST
85826: PUSH
85827: LD_INT 0
85829: PUSH
85830: LD_INT 2
85832: NEG
85833: PUSH
85834: EMPTY
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 1
85840: PUSH
85841: LD_INT 1
85843: NEG
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: PUSH
85849: LD_INT 2
85851: PUSH
85852: LD_INT 1
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 2
85861: PUSH
85862: LD_INT 2
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: PUSH
85869: LD_INT 1
85871: PUSH
85872: LD_INT 2
85874: PUSH
85875: EMPTY
85876: LIST
85877: LIST
85878: PUSH
85879: LD_INT 0
85881: PUSH
85882: LD_INT 2
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 1
85891: NEG
85892: PUSH
85893: LD_INT 1
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 2
85902: NEG
85903: PUSH
85904: LD_INT 1
85906: NEG
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 2
85914: NEG
85915: PUSH
85916: LD_INT 2
85918: NEG
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: LD_INT 2
85926: NEG
85927: PUSH
85928: LD_INT 3
85930: NEG
85931: PUSH
85932: EMPTY
85933: LIST
85934: LIST
85935: PUSH
85936: LD_INT 1
85938: NEG
85939: PUSH
85940: LD_INT 3
85942: NEG
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: LD_INT 0
85950: PUSH
85951: LD_INT 3
85953: NEG
85954: PUSH
85955: EMPTY
85956: LIST
85957: LIST
85958: PUSH
85959: LD_INT 1
85961: PUSH
85962: LD_INT 2
85964: NEG
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 3
85972: PUSH
85973: LD_INT 2
85975: PUSH
85976: EMPTY
85977: LIST
85978: LIST
85979: PUSH
85980: LD_INT 3
85982: PUSH
85983: LD_INT 3
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 2
85992: PUSH
85993: LD_INT 3
85995: PUSH
85996: EMPTY
85997: LIST
85998: LIST
85999: PUSH
86000: LD_INT 1
86002: PUSH
86003: LD_INT 3
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 0
86012: PUSH
86013: LD_INT 3
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 1
86022: NEG
86023: PUSH
86024: LD_INT 2
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 3
86033: NEG
86034: PUSH
86035: LD_INT 2
86037: NEG
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 3
86045: NEG
86046: PUSH
86047: LD_INT 3
86049: NEG
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: LIST
86083: LIST
86084: LIST
86085: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86086: LD_ADDR_VAR 0 46
86090: PUSH
86091: LD_INT 0
86093: PUSH
86094: LD_INT 0
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PUSH
86101: LD_INT 0
86103: PUSH
86104: LD_INT 1
86106: NEG
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PUSH
86112: LD_INT 1
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 1
86124: PUSH
86125: LD_INT 1
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: LD_INT 0
86134: PUSH
86135: LD_INT 1
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 1
86144: NEG
86145: PUSH
86146: LD_INT 0
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 1
86155: NEG
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 1
86167: NEG
86168: PUSH
86169: LD_INT 2
86171: NEG
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 0
86179: PUSH
86180: LD_INT 2
86182: NEG
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: PUSH
86191: LD_INT 1
86193: NEG
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: LD_INT 2
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 2
86211: PUSH
86212: LD_INT 1
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 1
86221: PUSH
86222: LD_INT 2
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 0
86231: PUSH
86232: LD_INT 2
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 1
86241: NEG
86242: PUSH
86243: LD_INT 1
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 2
86252: NEG
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 2
86263: NEG
86264: PUSH
86265: LD_INT 1
86267: NEG
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: LD_INT 3
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: LD_INT 3
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 1
86298: PUSH
86299: LD_INT 2
86301: NEG
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 2
86309: PUSH
86310: LD_INT 1
86312: NEG
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 3
86320: PUSH
86321: LD_INT 0
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 3
86330: PUSH
86331: LD_INT 1
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 1
86340: PUSH
86341: LD_INT 3
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 0
86350: PUSH
86351: LD_INT 3
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 1
86360: NEG
86361: PUSH
86362: LD_INT 2
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: LD_INT 2
86371: NEG
86372: PUSH
86373: LD_INT 1
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 3
86382: NEG
86383: PUSH
86384: LD_INT 0
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 3
86393: NEG
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: PUSH
86403: EMPTY
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86434: LD_ADDR_VAR 0 47
86438: PUSH
86439: LD_INT 0
86441: PUSH
86442: LD_INT 0
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 0
86451: PUSH
86452: LD_INT 1
86454: NEG
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PUSH
86460: LD_INT 1
86462: PUSH
86463: LD_INT 0
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: PUSH
86470: LD_INT 1
86472: PUSH
86473: LD_INT 1
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: LD_INT 1
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 1
86492: NEG
86493: PUSH
86494: LD_INT 0
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 1
86503: NEG
86504: PUSH
86505: LD_INT 1
86507: NEG
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: LD_INT 2
86519: NEG
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PUSH
86525: LD_INT 0
86527: PUSH
86528: LD_INT 2
86530: NEG
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 1
86538: PUSH
86539: LD_INT 1
86541: NEG
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 2
86549: NEG
86550: PUSH
86551: LD_INT 1
86553: NEG
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 2
86561: NEG
86562: PUSH
86563: LD_INT 2
86565: NEG
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86585: LD_ADDR_VAR 0 48
86589: PUSH
86590: LD_INT 0
86592: PUSH
86593: LD_INT 0
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 0
86602: PUSH
86603: LD_INT 1
86605: NEG
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: PUSH
86614: LD_INT 0
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 1
86623: PUSH
86624: LD_INT 1
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 0
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PUSH
86641: LD_INT 1
86643: NEG
86644: PUSH
86645: LD_INT 0
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 1
86654: NEG
86655: PUSH
86656: LD_INT 1
86658: NEG
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: LD_INT 1
86666: NEG
86667: PUSH
86668: LD_INT 2
86670: NEG
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: PUSH
86676: LD_INT 0
86678: PUSH
86679: LD_INT 2
86681: NEG
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 1
86689: PUSH
86690: LD_INT 1
86692: NEG
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 2
86700: PUSH
86701: LD_INT 0
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: PUSH
86711: LD_INT 1
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: LIST
86727: LIST
86728: LIST
86729: LIST
86730: LIST
86731: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86732: LD_ADDR_VAR 0 49
86736: PUSH
86737: LD_INT 0
86739: PUSH
86740: LD_INT 0
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: LD_INT 1
86752: NEG
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 1
86760: PUSH
86761: LD_INT 0
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 1
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: EMPTY
86785: LIST
86786: LIST
86787: PUSH
86788: LD_INT 1
86790: NEG
86791: PUSH
86792: LD_INT 0
86794: PUSH
86795: EMPTY
86796: LIST
86797: LIST
86798: PUSH
86799: LD_INT 1
86801: NEG
86802: PUSH
86803: LD_INT 1
86805: NEG
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 1
86813: PUSH
86814: LD_INT 1
86816: NEG
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: PUSH
86822: LD_INT 2
86824: PUSH
86825: LD_INT 0
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 2
86834: PUSH
86835: LD_INT 1
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: PUSH
86842: LD_INT 2
86844: PUSH
86845: LD_INT 2
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: LD_INT 2
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: PUSH
86862: EMPTY
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86876: LD_ADDR_VAR 0 50
86880: PUSH
86881: LD_INT 0
86883: PUSH
86884: LD_INT 0
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 0
86893: PUSH
86894: LD_INT 1
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 1
86904: PUSH
86905: LD_INT 0
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 1
86914: PUSH
86915: LD_INT 1
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 0
86924: PUSH
86925: LD_INT 1
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 1
86934: NEG
86935: PUSH
86936: LD_INT 0
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 1
86945: NEG
86946: PUSH
86947: LD_INT 1
86949: NEG
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 2
86957: PUSH
86958: LD_INT 1
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 2
86967: PUSH
86968: LD_INT 2
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 1
86977: PUSH
86978: LD_INT 2
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 0
86987: PUSH
86988: LD_INT 2
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 1
86997: NEG
86998: PUSH
86999: LD_INT 1
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87020: LD_ADDR_VAR 0 51
87024: PUSH
87025: LD_INT 0
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 1
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 0
87068: PUSH
87069: LD_INT 1
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 1
87078: NEG
87079: PUSH
87080: LD_INT 0
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: NEG
87090: PUSH
87091: LD_INT 1
87093: NEG
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 1
87101: PUSH
87102: LD_INT 2
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 0
87111: PUSH
87112: LD_INT 2
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 1
87121: NEG
87122: PUSH
87123: LD_INT 1
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 2
87132: NEG
87133: PUSH
87134: LD_INT 0
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 2
87143: NEG
87144: PUSH
87145: LD_INT 1
87147: NEG
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87167: LD_ADDR_VAR 0 52
87171: PUSH
87172: LD_INT 0
87174: PUSH
87175: LD_INT 0
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 0
87184: PUSH
87185: LD_INT 1
87187: NEG
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 1
87195: PUSH
87196: LD_INT 0
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 1
87205: PUSH
87206: LD_INT 1
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: PUSH
87213: LD_INT 0
87215: PUSH
87216: LD_INT 1
87218: PUSH
87219: EMPTY
87220: LIST
87221: LIST
87222: PUSH
87223: LD_INT 1
87225: NEG
87226: PUSH
87227: LD_INT 0
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: LD_INT 1
87240: NEG
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 1
87248: NEG
87249: PUSH
87250: LD_INT 2
87252: NEG
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PUSH
87258: LD_INT 1
87260: NEG
87261: PUSH
87262: LD_INT 1
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 2
87271: NEG
87272: PUSH
87273: LD_INT 0
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 2
87282: NEG
87283: PUSH
87284: LD_INT 1
87286: NEG
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 2
87294: NEG
87295: PUSH
87296: LD_INT 2
87298: NEG
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87318: LD_ADDR_VAR 0 53
87322: PUSH
87323: LD_INT 0
87325: PUSH
87326: LD_INT 0
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 0
87335: PUSH
87336: LD_INT 1
87338: NEG
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 1
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: LD_INT 1
87356: PUSH
87357: LD_INT 1
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: PUSH
87364: LD_INT 0
87366: PUSH
87367: LD_INT 1
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 1
87376: NEG
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: EMPTY
87382: LIST
87383: LIST
87384: PUSH
87385: LD_INT 1
87387: NEG
87388: PUSH
87389: LD_INT 1
87391: NEG
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: PUSH
87397: LD_INT 1
87399: NEG
87400: PUSH
87401: LD_INT 2
87403: NEG
87404: PUSH
87405: EMPTY
87406: LIST
87407: LIST
87408: PUSH
87409: LD_INT 0
87411: PUSH
87412: LD_INT 2
87414: NEG
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 1
87422: PUSH
87423: LD_INT 1
87425: NEG
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 2
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 2
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 2
87453: PUSH
87454: LD_INT 2
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 1
87463: PUSH
87464: LD_INT 2
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 0
87473: PUSH
87474: LD_INT 2
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 1
87483: NEG
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 2
87494: NEG
87495: PUSH
87496: LD_INT 0
87498: PUSH
87499: EMPTY
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 2
87505: NEG
87506: PUSH
87507: LD_INT 1
87509: NEG
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 2
87517: NEG
87518: PUSH
87519: LD_INT 2
87521: NEG
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87548: LD_ADDR_VAR 0 54
87552: PUSH
87553: LD_INT 0
87555: PUSH
87556: LD_INT 0
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: LD_INT 0
87565: PUSH
87566: LD_INT 1
87568: NEG
87569: PUSH
87570: EMPTY
87571: LIST
87572: LIST
87573: PUSH
87574: LD_INT 1
87576: PUSH
87577: LD_INT 0
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: PUSH
87584: LD_INT 1
87586: PUSH
87587: LD_INT 1
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: LD_INT 1
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 1
87606: NEG
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 1
87617: NEG
87618: PUSH
87619: LD_INT 1
87621: NEG
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 1
87629: NEG
87630: PUSH
87631: LD_INT 2
87633: NEG
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 0
87641: PUSH
87642: LD_INT 2
87644: NEG
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 1
87652: PUSH
87653: LD_INT 1
87655: NEG
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 2
87663: PUSH
87664: LD_INT 0
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 2
87673: PUSH
87674: LD_INT 1
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 2
87683: PUSH
87684: LD_INT 2
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 1
87693: PUSH
87694: LD_INT 2
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 0
87703: PUSH
87704: LD_INT 2
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: LD_INT 1
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 2
87724: NEG
87725: PUSH
87726: LD_INT 0
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: PUSH
87733: LD_INT 2
87735: NEG
87736: PUSH
87737: LD_INT 1
87739: NEG
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 2
87747: NEG
87748: PUSH
87749: LD_INT 2
87751: NEG
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87778: LD_ADDR_VAR 0 55
87782: PUSH
87783: LD_INT 0
87785: PUSH
87786: LD_INT 0
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: LD_INT 1
87798: NEG
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: LD_INT 1
87806: PUSH
87807: LD_INT 0
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: PUSH
87817: LD_INT 1
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 0
87826: PUSH
87827: LD_INT 1
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: NEG
87837: PUSH
87838: LD_INT 0
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 1
87847: NEG
87848: PUSH
87849: LD_INT 1
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 1
87859: NEG
87860: PUSH
87861: LD_INT 2
87863: NEG
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PUSH
87869: LD_INT 0
87871: PUSH
87872: LD_INT 2
87874: NEG
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: PUSH
87880: LD_INT 1
87882: PUSH
87883: LD_INT 1
87885: NEG
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 2
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 2
87903: PUSH
87904: LD_INT 1
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 2
87913: PUSH
87914: LD_INT 2
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 1
87923: PUSH
87924: LD_INT 2
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: PUSH
87931: LD_INT 0
87933: PUSH
87934: LD_INT 2
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 1
87943: NEG
87944: PUSH
87945: LD_INT 1
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 2
87954: NEG
87955: PUSH
87956: LD_INT 0
87958: PUSH
87959: EMPTY
87960: LIST
87961: LIST
87962: PUSH
87963: LD_INT 2
87965: NEG
87966: PUSH
87967: LD_INT 1
87969: NEG
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 2
87977: NEG
87978: PUSH
87979: LD_INT 2
87981: NEG
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88008: LD_ADDR_VAR 0 56
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 0
88025: PUSH
88026: LD_INT 1
88028: NEG
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 1
88036: PUSH
88037: LD_INT 0
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 1
88046: PUSH
88047: LD_INT 1
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 0
88056: PUSH
88057: LD_INT 1
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 1
88066: NEG
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 1
88077: NEG
88078: PUSH
88079: LD_INT 1
88081: NEG
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: PUSH
88087: LD_INT 1
88089: NEG
88090: PUSH
88091: LD_INT 2
88093: NEG
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 0
88101: PUSH
88102: LD_INT 2
88104: NEG
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 1
88112: PUSH
88113: LD_INT 1
88115: NEG
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: PUSH
88121: LD_INT 2
88123: PUSH
88124: LD_INT 0
88126: PUSH
88127: EMPTY
88128: LIST
88129: LIST
88130: PUSH
88131: LD_INT 2
88133: PUSH
88134: LD_INT 1
88136: PUSH
88137: EMPTY
88138: LIST
88139: LIST
88140: PUSH
88141: LD_INT 2
88143: PUSH
88144: LD_INT 2
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: LD_INT 1
88153: PUSH
88154: LD_INT 2
88156: PUSH
88157: EMPTY
88158: LIST
88159: LIST
88160: PUSH
88161: LD_INT 0
88163: PUSH
88164: LD_INT 2
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: LD_INT 1
88177: PUSH
88178: EMPTY
88179: LIST
88180: LIST
88181: PUSH
88182: LD_INT 2
88184: NEG
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 2
88195: NEG
88196: PUSH
88197: LD_INT 1
88199: NEG
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 2
88207: NEG
88208: PUSH
88209: LD_INT 2
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: LIST
88236: LIST
88237: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88238: LD_ADDR_VAR 0 57
88242: PUSH
88243: LD_INT 0
88245: PUSH
88246: LD_INT 0
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 0
88255: PUSH
88256: LD_INT 1
88258: NEG
88259: PUSH
88260: EMPTY
88261: LIST
88262: LIST
88263: PUSH
88264: LD_INT 1
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: LD_INT 1
88276: PUSH
88277: LD_INT 1
88279: PUSH
88280: EMPTY
88281: LIST
88282: LIST
88283: PUSH
88284: LD_INT 0
88286: PUSH
88287: LD_INT 1
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PUSH
88294: LD_INT 1
88296: NEG
88297: PUSH
88298: LD_INT 0
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: PUSH
88305: LD_INT 1
88307: NEG
88308: PUSH
88309: LD_INT 1
88311: NEG
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: PUSH
88317: LD_INT 1
88319: NEG
88320: PUSH
88321: LD_INT 2
88323: NEG
88324: PUSH
88325: EMPTY
88326: LIST
88327: LIST
88328: PUSH
88329: LD_INT 0
88331: PUSH
88332: LD_INT 2
88334: NEG
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 1
88342: PUSH
88343: LD_INT 1
88345: NEG
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 2
88353: PUSH
88354: LD_INT 0
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: LD_INT 2
88363: PUSH
88364: LD_INT 1
88366: PUSH
88367: EMPTY
88368: LIST
88369: LIST
88370: PUSH
88371: LD_INT 2
88373: PUSH
88374: LD_INT 2
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: LD_INT 1
88383: PUSH
88384: LD_INT 2
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PUSH
88391: LD_INT 0
88393: PUSH
88394: LD_INT 2
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 1
88403: NEG
88404: PUSH
88405: LD_INT 1
88407: PUSH
88408: EMPTY
88409: LIST
88410: LIST
88411: PUSH
88412: LD_INT 2
88414: NEG
88415: PUSH
88416: LD_INT 0
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 2
88425: NEG
88426: PUSH
88427: LD_INT 1
88429: NEG
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 2
88437: NEG
88438: PUSH
88439: LD_INT 2
88441: NEG
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88468: LD_ADDR_VAR 0 58
88472: PUSH
88473: LD_INT 0
88475: PUSH
88476: LD_INT 0
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 0
88485: PUSH
88486: LD_INT 1
88488: NEG
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 1
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 1
88506: PUSH
88507: LD_INT 1
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 0
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 1
88526: NEG
88527: PUSH
88528: LD_INT 0
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 1
88537: NEG
88538: PUSH
88539: LD_INT 1
88541: NEG
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PUSH
88547: LD_INT 1
88549: NEG
88550: PUSH
88551: LD_INT 2
88553: NEG
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PUSH
88559: LD_INT 0
88561: PUSH
88562: LD_INT 2
88564: NEG
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: PUSH
88573: LD_INT 1
88575: NEG
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 2
88583: PUSH
88584: LD_INT 0
88586: PUSH
88587: EMPTY
88588: LIST
88589: LIST
88590: PUSH
88591: LD_INT 2
88593: PUSH
88594: LD_INT 1
88596: PUSH
88597: EMPTY
88598: LIST
88599: LIST
88600: PUSH
88601: LD_INT 2
88603: PUSH
88604: LD_INT 2
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 1
88613: PUSH
88614: LD_INT 2
88616: PUSH
88617: EMPTY
88618: LIST
88619: LIST
88620: PUSH
88621: LD_INT 0
88623: PUSH
88624: LD_INT 2
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: LD_INT 1
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: PUSH
88642: LD_INT 2
88644: NEG
88645: PUSH
88646: LD_INT 0
88648: PUSH
88649: EMPTY
88650: LIST
88651: LIST
88652: PUSH
88653: LD_INT 2
88655: NEG
88656: PUSH
88657: LD_INT 1
88659: NEG
88660: PUSH
88661: EMPTY
88662: LIST
88663: LIST
88664: PUSH
88665: LD_INT 2
88667: NEG
88668: PUSH
88669: LD_INT 2
88671: NEG
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88698: LD_ADDR_VAR 0 59
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: LD_INT 0
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 0
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 1
88726: PUSH
88727: LD_INT 0
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 1
88736: PUSH
88737: LD_INT 1
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: LD_INT 1
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 1
88756: NEG
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 1
88767: NEG
88768: PUSH
88769: LD_INT 1
88771: NEG
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88786: LD_ADDR_VAR 0 60
88790: PUSH
88791: LD_INT 0
88793: PUSH
88794: LD_INT 0
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: PUSH
88801: LD_INT 0
88803: PUSH
88804: LD_INT 1
88806: NEG
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 1
88814: PUSH
88815: LD_INT 0
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 1
88824: PUSH
88825: LD_INT 1
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PUSH
88832: LD_INT 0
88834: PUSH
88835: LD_INT 1
88837: PUSH
88838: EMPTY
88839: LIST
88840: LIST
88841: PUSH
88842: LD_INT 1
88844: NEG
88845: PUSH
88846: LD_INT 0
88848: PUSH
88849: EMPTY
88850: LIST
88851: LIST
88852: PUSH
88853: LD_INT 1
88855: NEG
88856: PUSH
88857: LD_INT 1
88859: NEG
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88874: LD_ADDR_VAR 0 61
88878: PUSH
88879: LD_INT 0
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 0
88891: PUSH
88892: LD_INT 1
88894: NEG
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: PUSH
88903: LD_INT 0
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: LD_INT 1
88912: PUSH
88913: LD_INT 1
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 0
88922: PUSH
88923: LD_INT 1
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 1
88932: NEG
88933: PUSH
88934: LD_INT 0
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 1
88943: NEG
88944: PUSH
88945: LD_INT 1
88947: NEG
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: LIST
88959: LIST
88960: LIST
88961: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88962: LD_ADDR_VAR 0 62
88966: PUSH
88967: LD_INT 0
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: LD_INT 0
88979: PUSH
88980: LD_INT 1
88982: NEG
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 1
88990: PUSH
88991: LD_INT 0
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: LD_INT 1
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: LD_INT 1
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: NEG
89021: PUSH
89022: LD_INT 0
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: NEG
89032: PUSH
89033: LD_INT 1
89035: NEG
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: LIST
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89050: LD_ADDR_VAR 0 63
89054: PUSH
89055: LD_INT 0
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 0
89067: PUSH
89068: LD_INT 1
89070: NEG
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: LD_INT 1
89078: PUSH
89079: LD_INT 0
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: PUSH
89086: LD_INT 1
89088: PUSH
89089: LD_INT 1
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: PUSH
89096: LD_INT 0
89098: PUSH
89099: LD_INT 1
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 1
89108: NEG
89109: PUSH
89110: LD_INT 0
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: NEG
89120: PUSH
89121: LD_INT 1
89123: NEG
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89138: LD_ADDR_VAR 0 64
89142: PUSH
89143: LD_INT 0
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 0
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 1
89166: PUSH
89167: LD_INT 0
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: PUSH
89174: LD_INT 1
89176: PUSH
89177: LD_INT 1
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: LD_INT 0
89186: PUSH
89187: LD_INT 1
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 1
89196: NEG
89197: PUSH
89198: LD_INT 0
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: PUSH
89205: LD_INT 1
89207: NEG
89208: PUSH
89209: LD_INT 1
89211: NEG
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: ST_TO_ADDR
// end ; 1 :
89226: GO 95123
89228: LD_INT 1
89230: DOUBLE
89231: EQUAL
89232: IFTRUE 89236
89234: GO 91859
89236: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89237: LD_ADDR_VAR 0 11
89241: PUSH
89242: LD_INT 1
89244: NEG
89245: PUSH
89246: LD_INT 3
89248: NEG
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 0
89256: PUSH
89257: LD_INT 3
89259: NEG
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: LD_INT 1
89267: PUSH
89268: LD_INT 2
89270: NEG
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: LIST
89280: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89281: LD_ADDR_VAR 0 12
89285: PUSH
89286: LD_INT 2
89288: PUSH
89289: LD_INT 1
89291: NEG
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 3
89299: PUSH
89300: LD_INT 0
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 3
89309: PUSH
89310: LD_INT 1
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: LIST
89321: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89322: LD_ADDR_VAR 0 13
89326: PUSH
89327: LD_INT 3
89329: PUSH
89330: LD_INT 2
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: LD_INT 3
89339: PUSH
89340: LD_INT 3
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 2
89349: PUSH
89350: LD_INT 3
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: LIST
89361: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89362: LD_ADDR_VAR 0 14
89366: PUSH
89367: LD_INT 1
89369: PUSH
89370: LD_INT 3
89372: PUSH
89373: EMPTY
89374: LIST
89375: LIST
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: LD_INT 3
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 1
89389: NEG
89390: PUSH
89391: LD_INT 2
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: LIST
89402: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89403: LD_ADDR_VAR 0 15
89407: PUSH
89408: LD_INT 2
89410: NEG
89411: PUSH
89412: LD_INT 1
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 3
89421: NEG
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 3
89432: NEG
89433: PUSH
89434: LD_INT 1
89436: NEG
89437: PUSH
89438: EMPTY
89439: LIST
89440: LIST
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: LIST
89446: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89447: LD_ADDR_VAR 0 16
89451: PUSH
89452: LD_INT 2
89454: NEG
89455: PUSH
89456: LD_INT 3
89458: NEG
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 3
89466: NEG
89467: PUSH
89468: LD_INT 2
89470: NEG
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PUSH
89476: LD_INT 3
89478: NEG
89479: PUSH
89480: LD_INT 3
89482: NEG
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: LIST
89492: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89493: LD_ADDR_VAR 0 17
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: LD_INT 3
89504: NEG
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 0
89512: PUSH
89513: LD_INT 3
89515: NEG
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: LD_INT 2
89526: NEG
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: LIST
89536: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89537: LD_ADDR_VAR 0 18
89541: PUSH
89542: LD_INT 2
89544: PUSH
89545: LD_INT 1
89547: NEG
89548: PUSH
89549: EMPTY
89550: LIST
89551: LIST
89552: PUSH
89553: LD_INT 3
89555: PUSH
89556: LD_INT 0
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 3
89565: PUSH
89566: LD_INT 1
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: LIST
89577: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89578: LD_ADDR_VAR 0 19
89582: PUSH
89583: LD_INT 3
89585: PUSH
89586: LD_INT 2
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 3
89595: PUSH
89596: LD_INT 3
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 2
89605: PUSH
89606: LD_INT 3
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: LIST
89617: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89618: LD_ADDR_VAR 0 20
89622: PUSH
89623: LD_INT 1
89625: PUSH
89626: LD_INT 3
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 0
89635: PUSH
89636: LD_INT 3
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 1
89645: NEG
89646: PUSH
89647: LD_INT 2
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: LIST
89658: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89659: LD_ADDR_VAR 0 21
89663: PUSH
89664: LD_INT 2
89666: NEG
89667: PUSH
89668: LD_INT 1
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: LD_INT 3
89677: NEG
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 3
89688: NEG
89689: PUSH
89690: LD_INT 1
89692: NEG
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: LIST
89702: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89703: LD_ADDR_VAR 0 22
89707: PUSH
89708: LD_INT 2
89710: NEG
89711: PUSH
89712: LD_INT 3
89714: NEG
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 3
89722: NEG
89723: PUSH
89724: LD_INT 2
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 3
89734: NEG
89735: PUSH
89736: LD_INT 3
89738: NEG
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: LIST
89748: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89749: LD_ADDR_VAR 0 23
89753: PUSH
89754: LD_INT 0
89756: PUSH
89757: LD_INT 3
89759: NEG
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: LD_INT 4
89771: NEG
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 1
89779: PUSH
89780: LD_INT 3
89782: NEG
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: LIST
89792: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89793: LD_ADDR_VAR 0 24
89797: PUSH
89798: LD_INT 3
89800: PUSH
89801: LD_INT 0
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 3
89810: PUSH
89811: LD_INT 1
89813: NEG
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 4
89821: PUSH
89822: LD_INT 1
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: LIST
89833: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89834: LD_ADDR_VAR 0 25
89838: PUSH
89839: LD_INT 3
89841: PUSH
89842: LD_INT 3
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 4
89851: PUSH
89852: LD_INT 3
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 3
89861: PUSH
89862: LD_INT 4
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: EMPTY
89870: LIST
89871: LIST
89872: LIST
89873: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89874: LD_ADDR_VAR 0 26
89878: PUSH
89879: LD_INT 0
89881: PUSH
89882: LD_INT 3
89884: PUSH
89885: EMPTY
89886: LIST
89887: LIST
89888: PUSH
89889: LD_INT 1
89891: PUSH
89892: LD_INT 4
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 1
89901: NEG
89902: PUSH
89903: LD_INT 3
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: LIST
89914: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89915: LD_ADDR_VAR 0 27
89919: PUSH
89920: LD_INT 3
89922: NEG
89923: PUSH
89924: LD_INT 0
89926: PUSH
89927: EMPTY
89928: LIST
89929: LIST
89930: PUSH
89931: LD_INT 3
89933: NEG
89934: PUSH
89935: LD_INT 1
89937: PUSH
89938: EMPTY
89939: LIST
89940: LIST
89941: PUSH
89942: LD_INT 4
89944: NEG
89945: PUSH
89946: LD_INT 1
89948: NEG
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: LIST
89958: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89959: LD_ADDR_VAR 0 28
89963: PUSH
89964: LD_INT 3
89966: NEG
89967: PUSH
89968: LD_INT 3
89970: NEG
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 3
89978: NEG
89979: PUSH
89980: LD_INT 4
89982: NEG
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: LD_INT 4
89990: NEG
89991: PUSH
89992: LD_INT 3
89994: NEG
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: LIST
90004: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90005: LD_ADDR_VAR 0 29
90009: PUSH
90010: LD_INT 1
90012: NEG
90013: PUSH
90014: LD_INT 3
90016: NEG
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 0
90024: PUSH
90025: LD_INT 3
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 1
90035: PUSH
90036: LD_INT 2
90038: NEG
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: LD_INT 4
90050: NEG
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 0
90058: PUSH
90059: LD_INT 4
90061: NEG
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 1
90069: PUSH
90070: LD_INT 3
90072: NEG
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 1
90080: NEG
90081: PUSH
90082: LD_INT 5
90084: NEG
90085: PUSH
90086: EMPTY
90087: LIST
90088: LIST
90089: PUSH
90090: LD_INT 0
90092: PUSH
90093: LD_INT 5
90095: NEG
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 1
90103: PUSH
90104: LD_INT 4
90106: NEG
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 1
90114: NEG
90115: PUSH
90116: LD_INT 6
90118: NEG
90119: PUSH
90120: EMPTY
90121: LIST
90122: LIST
90123: PUSH
90124: LD_INT 0
90126: PUSH
90127: LD_INT 6
90129: NEG
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 1
90137: PUSH
90138: LD_INT 5
90140: NEG
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90160: LD_ADDR_VAR 0 30
90164: PUSH
90165: LD_INT 2
90167: PUSH
90168: LD_INT 1
90170: NEG
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: LD_INT 3
90178: PUSH
90179: LD_INT 0
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PUSH
90186: LD_INT 3
90188: PUSH
90189: LD_INT 1
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 3
90198: PUSH
90199: LD_INT 1
90201: NEG
90202: PUSH
90203: EMPTY
90204: LIST
90205: LIST
90206: PUSH
90207: LD_INT 4
90209: PUSH
90210: LD_INT 0
90212: PUSH
90213: EMPTY
90214: LIST
90215: LIST
90216: PUSH
90217: LD_INT 4
90219: PUSH
90220: LD_INT 1
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: LD_INT 4
90229: PUSH
90230: LD_INT 1
90232: NEG
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 5
90240: PUSH
90241: LD_INT 0
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 5
90250: PUSH
90251: LD_INT 1
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 5
90260: PUSH
90261: LD_INT 1
90263: NEG
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 6
90271: PUSH
90272: LD_INT 0
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 6
90281: PUSH
90282: LD_INT 1
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90303: LD_ADDR_VAR 0 31
90307: PUSH
90308: LD_INT 3
90310: PUSH
90311: LD_INT 2
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 3
90320: PUSH
90321: LD_INT 3
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: LD_INT 2
90330: PUSH
90331: LD_INT 3
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 4
90340: PUSH
90341: LD_INT 3
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 4
90350: PUSH
90351: LD_INT 4
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: PUSH
90358: LD_INT 3
90360: PUSH
90361: LD_INT 4
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 5
90370: PUSH
90371: LD_INT 4
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: LD_INT 5
90380: PUSH
90381: LD_INT 5
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 4
90390: PUSH
90391: LD_INT 5
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: PUSH
90398: LD_INT 6
90400: PUSH
90401: LD_INT 5
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 6
90410: PUSH
90411: LD_INT 6
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 5
90420: PUSH
90421: LD_INT 6
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90442: LD_ADDR_VAR 0 32
90446: PUSH
90447: LD_INT 1
90449: PUSH
90450: LD_INT 3
90452: PUSH
90453: EMPTY
90454: LIST
90455: LIST
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: LD_INT 3
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: LD_INT 2
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 1
90480: PUSH
90481: LD_INT 4
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: PUSH
90488: LD_INT 0
90490: PUSH
90491: LD_INT 4
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 1
90500: NEG
90501: PUSH
90502: LD_INT 3
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 1
90511: PUSH
90512: LD_INT 5
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 0
90521: PUSH
90522: LD_INT 5
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 1
90531: NEG
90532: PUSH
90533: LD_INT 4
90535: PUSH
90536: EMPTY
90537: LIST
90538: LIST
90539: PUSH
90540: LD_INT 1
90542: PUSH
90543: LD_INT 6
90545: PUSH
90546: EMPTY
90547: LIST
90548: LIST
90549: PUSH
90550: LD_INT 0
90552: PUSH
90553: LD_INT 6
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: LD_INT 1
90562: NEG
90563: PUSH
90564: LD_INT 5
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90585: LD_ADDR_VAR 0 33
90589: PUSH
90590: LD_INT 2
90592: NEG
90593: PUSH
90594: LD_INT 1
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 3
90603: NEG
90604: PUSH
90605: LD_INT 0
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 3
90614: NEG
90615: PUSH
90616: LD_INT 1
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 3
90626: NEG
90627: PUSH
90628: LD_INT 1
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: LD_INT 4
90637: NEG
90638: PUSH
90639: LD_INT 0
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: LD_INT 4
90648: NEG
90649: PUSH
90650: LD_INT 1
90652: NEG
90653: PUSH
90654: EMPTY
90655: LIST
90656: LIST
90657: PUSH
90658: LD_INT 4
90660: NEG
90661: PUSH
90662: LD_INT 1
90664: PUSH
90665: EMPTY
90666: LIST
90667: LIST
90668: PUSH
90669: LD_INT 5
90671: NEG
90672: PUSH
90673: LD_INT 0
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: PUSH
90680: LD_INT 5
90682: NEG
90683: PUSH
90684: LD_INT 1
90686: NEG
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 5
90694: NEG
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 6
90705: NEG
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 6
90716: NEG
90717: PUSH
90718: LD_INT 1
90720: NEG
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: LIST
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90740: LD_ADDR_VAR 0 34
90744: PUSH
90745: LD_INT 2
90747: NEG
90748: PUSH
90749: LD_INT 3
90751: NEG
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: LD_INT 3
90759: NEG
90760: PUSH
90761: LD_INT 2
90763: NEG
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 3
90771: NEG
90772: PUSH
90773: LD_INT 3
90775: NEG
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 3
90783: NEG
90784: PUSH
90785: LD_INT 4
90787: NEG
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: LD_INT 4
90795: NEG
90796: PUSH
90797: LD_INT 3
90799: NEG
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PUSH
90805: LD_INT 4
90807: NEG
90808: PUSH
90809: LD_INT 4
90811: NEG
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: PUSH
90817: LD_INT 4
90819: NEG
90820: PUSH
90821: LD_INT 5
90823: NEG
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 5
90831: NEG
90832: PUSH
90833: LD_INT 4
90835: NEG
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: PUSH
90841: LD_INT 5
90843: NEG
90844: PUSH
90845: LD_INT 5
90847: NEG
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 5
90855: NEG
90856: PUSH
90857: LD_INT 6
90859: NEG
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 6
90867: NEG
90868: PUSH
90869: LD_INT 5
90871: NEG
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: PUSH
90877: LD_INT 6
90879: NEG
90880: PUSH
90881: LD_INT 6
90883: NEG
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: LIST
90902: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90903: LD_ADDR_VAR 0 41
90907: PUSH
90908: LD_INT 0
90910: PUSH
90911: LD_INT 2
90913: NEG
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: LD_INT 3
90925: NEG
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 1
90933: PUSH
90934: LD_INT 2
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: LIST
90946: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90947: LD_ADDR_VAR 0 42
90951: PUSH
90952: LD_INT 2
90954: PUSH
90955: LD_INT 0
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 2
90964: PUSH
90965: LD_INT 1
90967: NEG
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: LD_INT 3
90975: PUSH
90976: LD_INT 1
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: LIST
90987: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90988: LD_ADDR_VAR 0 43
90992: PUSH
90993: LD_INT 2
90995: PUSH
90996: LD_INT 2
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: PUSH
91003: LD_INT 3
91005: PUSH
91006: LD_INT 2
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: PUSH
91013: LD_INT 2
91015: PUSH
91016: LD_INT 3
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: EMPTY
91024: LIST
91025: LIST
91026: LIST
91027: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91028: LD_ADDR_VAR 0 44
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: LD_INT 2
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 1
91045: PUSH
91046: LD_INT 3
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 1
91055: NEG
91056: PUSH
91057: LD_INT 2
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: LIST
91068: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91069: LD_ADDR_VAR 0 45
91073: PUSH
91074: LD_INT 2
91076: NEG
91077: PUSH
91078: LD_INT 0
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: LD_INT 2
91087: NEG
91088: PUSH
91089: LD_INT 1
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 3
91098: NEG
91099: PUSH
91100: LD_INT 1
91102: NEG
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: LIST
91112: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91113: LD_ADDR_VAR 0 46
91117: PUSH
91118: LD_INT 2
91120: NEG
91121: PUSH
91122: LD_INT 2
91124: NEG
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: LD_INT 2
91132: NEG
91133: PUSH
91134: LD_INT 3
91136: NEG
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 3
91144: NEG
91145: PUSH
91146: LD_INT 2
91148: NEG
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: LIST
91158: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91159: LD_ADDR_VAR 0 47
91163: PUSH
91164: LD_INT 2
91166: NEG
91167: PUSH
91168: LD_INT 3
91170: NEG
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 1
91178: NEG
91179: PUSH
91180: LD_INT 3
91182: NEG
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91192: LD_ADDR_VAR 0 48
91196: PUSH
91197: LD_INT 1
91199: PUSH
91200: LD_INT 2
91202: NEG
91203: PUSH
91204: EMPTY
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 2
91210: PUSH
91211: LD_INT 1
91213: NEG
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91223: LD_ADDR_VAR 0 49
91227: PUSH
91228: LD_INT 3
91230: PUSH
91231: LD_INT 1
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: PUSH
91238: LD_INT 3
91240: PUSH
91241: LD_INT 2
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91252: LD_ADDR_VAR 0 50
91256: PUSH
91257: LD_INT 2
91259: PUSH
91260: LD_INT 3
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 1
91269: PUSH
91270: LD_INT 3
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91281: LD_ADDR_VAR 0 51
91285: PUSH
91286: LD_INT 1
91288: NEG
91289: PUSH
91290: LD_INT 2
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 2
91299: NEG
91300: PUSH
91301: LD_INT 1
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91312: LD_ADDR_VAR 0 52
91316: PUSH
91317: LD_INT 3
91319: NEG
91320: PUSH
91321: LD_INT 1
91323: NEG
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 3
91331: NEG
91332: PUSH
91333: LD_INT 2
91335: NEG
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91345: LD_ADDR_VAR 0 53
91349: PUSH
91350: LD_INT 1
91352: NEG
91353: PUSH
91354: LD_INT 3
91356: NEG
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: PUSH
91362: LD_INT 0
91364: PUSH
91365: LD_INT 3
91367: NEG
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: LD_INT 1
91375: PUSH
91376: LD_INT 2
91378: NEG
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: LIST
91388: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91389: LD_ADDR_VAR 0 54
91393: PUSH
91394: LD_INT 2
91396: PUSH
91397: LD_INT 1
91399: NEG
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 3
91407: PUSH
91408: LD_INT 0
91410: PUSH
91411: EMPTY
91412: LIST
91413: LIST
91414: PUSH
91415: LD_INT 3
91417: PUSH
91418: LD_INT 1
91420: PUSH
91421: EMPTY
91422: LIST
91423: LIST
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: LIST
91429: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91430: LD_ADDR_VAR 0 55
91434: PUSH
91435: LD_INT 3
91437: PUSH
91438: LD_INT 2
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 3
91447: PUSH
91448: LD_INT 3
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PUSH
91455: LD_INT 2
91457: PUSH
91458: LD_INT 3
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: LIST
91469: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91470: LD_ADDR_VAR 0 56
91474: PUSH
91475: LD_INT 1
91477: PUSH
91478: LD_INT 3
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 0
91487: PUSH
91488: LD_INT 3
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 1
91497: NEG
91498: PUSH
91499: LD_INT 2
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: LIST
91510: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91511: LD_ADDR_VAR 0 57
91515: PUSH
91516: LD_INT 2
91518: NEG
91519: PUSH
91520: LD_INT 1
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 3
91529: NEG
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: PUSH
91538: LD_INT 3
91540: NEG
91541: PUSH
91542: LD_INT 1
91544: NEG
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: LIST
91554: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91555: LD_ADDR_VAR 0 58
91559: PUSH
91560: LD_INT 2
91562: NEG
91563: PUSH
91564: LD_INT 3
91566: NEG
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 3
91574: NEG
91575: PUSH
91576: LD_INT 2
91578: NEG
91579: PUSH
91580: EMPTY
91581: LIST
91582: LIST
91583: PUSH
91584: LD_INT 3
91586: NEG
91587: PUSH
91588: LD_INT 3
91590: NEG
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: LIST
91600: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91601: LD_ADDR_VAR 0 59
91605: PUSH
91606: LD_INT 1
91608: NEG
91609: PUSH
91610: LD_INT 2
91612: NEG
91613: PUSH
91614: EMPTY
91615: LIST
91616: LIST
91617: PUSH
91618: LD_INT 0
91620: PUSH
91621: LD_INT 2
91623: NEG
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: PUSH
91629: LD_INT 1
91631: PUSH
91632: LD_INT 1
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: LIST
91644: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91645: LD_ADDR_VAR 0 60
91649: PUSH
91650: LD_INT 1
91652: PUSH
91653: LD_INT 1
91655: NEG
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 2
91663: PUSH
91664: LD_INT 0
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: LD_INT 2
91673: PUSH
91674: LD_INT 1
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: LIST
91685: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91686: LD_ADDR_VAR 0 61
91690: PUSH
91691: LD_INT 2
91693: PUSH
91694: LD_INT 1
91696: PUSH
91697: EMPTY
91698: LIST
91699: LIST
91700: PUSH
91701: LD_INT 2
91703: PUSH
91704: LD_INT 2
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: PUSH
91711: LD_INT 1
91713: PUSH
91714: LD_INT 2
91716: PUSH
91717: EMPTY
91718: LIST
91719: LIST
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: LIST
91725: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91726: LD_ADDR_VAR 0 62
91730: PUSH
91731: LD_INT 1
91733: PUSH
91734: LD_INT 2
91736: PUSH
91737: EMPTY
91738: LIST
91739: LIST
91740: PUSH
91741: LD_INT 0
91743: PUSH
91744: LD_INT 2
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 1
91753: NEG
91754: PUSH
91755: LD_INT 1
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: LIST
91766: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91767: LD_ADDR_VAR 0 63
91771: PUSH
91772: LD_INT 1
91774: NEG
91775: PUSH
91776: LD_INT 1
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 2
91785: NEG
91786: PUSH
91787: LD_INT 0
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 2
91796: NEG
91797: PUSH
91798: LD_INT 1
91800: NEG
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: LIST
91810: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91811: LD_ADDR_VAR 0 64
91815: PUSH
91816: LD_INT 1
91818: NEG
91819: PUSH
91820: LD_INT 2
91822: NEG
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: PUSH
91828: LD_INT 2
91830: NEG
91831: PUSH
91832: LD_INT 1
91834: NEG
91835: PUSH
91836: EMPTY
91837: LIST
91838: LIST
91839: PUSH
91840: LD_INT 2
91842: NEG
91843: PUSH
91844: LD_INT 2
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: LIST
91856: ST_TO_ADDR
// end ; 2 :
91857: GO 95123
91859: LD_INT 2
91861: DOUBLE
91862: EQUAL
91863: IFTRUE 91867
91865: GO 95122
91867: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91868: LD_ADDR_VAR 0 29
91872: PUSH
91873: LD_INT 4
91875: PUSH
91876: LD_INT 0
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: LD_INT 4
91885: PUSH
91886: LD_INT 1
91888: NEG
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: PUSH
91894: LD_INT 5
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 5
91906: PUSH
91907: LD_INT 1
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: PUSH
91914: LD_INT 4
91916: PUSH
91917: LD_INT 1
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: PUSH
91924: LD_INT 3
91926: PUSH
91927: LD_INT 0
91929: PUSH
91930: EMPTY
91931: LIST
91932: LIST
91933: PUSH
91934: LD_INT 3
91936: PUSH
91937: LD_INT 1
91939: NEG
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 3
91947: PUSH
91948: LD_INT 2
91950: NEG
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 5
91958: PUSH
91959: LD_INT 2
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PUSH
91966: LD_INT 3
91968: PUSH
91969: LD_INT 3
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 3
91978: PUSH
91979: LD_INT 2
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: LD_INT 4
91988: PUSH
91989: LD_INT 3
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 4
91998: PUSH
91999: LD_INT 4
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 3
92008: PUSH
92009: LD_INT 4
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 2
92018: PUSH
92019: LD_INT 3
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 2
92028: PUSH
92029: LD_INT 2
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 4
92038: PUSH
92039: LD_INT 2
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: PUSH
92046: LD_INT 2
92048: PUSH
92049: LD_INT 4
92051: PUSH
92052: EMPTY
92053: LIST
92054: LIST
92055: PUSH
92056: LD_INT 0
92058: PUSH
92059: LD_INT 4
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 0
92068: PUSH
92069: LD_INT 3
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 1
92078: PUSH
92079: LD_INT 4
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 1
92088: PUSH
92089: LD_INT 5
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 0
92098: PUSH
92099: LD_INT 5
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: NEG
92109: PUSH
92110: LD_INT 4
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 1
92119: NEG
92120: PUSH
92121: LD_INT 3
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 2
92130: PUSH
92131: LD_INT 5
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 2
92140: NEG
92141: PUSH
92142: LD_INT 3
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 3
92151: NEG
92152: PUSH
92153: LD_INT 0
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: PUSH
92160: LD_INT 3
92162: NEG
92163: PUSH
92164: LD_INT 1
92166: NEG
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 2
92174: NEG
92175: PUSH
92176: LD_INT 0
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: LD_INT 2
92185: NEG
92186: PUSH
92187: LD_INT 1
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 3
92196: NEG
92197: PUSH
92198: LD_INT 1
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 4
92207: NEG
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: LD_INT 4
92218: NEG
92219: PUSH
92220: LD_INT 1
92222: NEG
92223: PUSH
92224: EMPTY
92225: LIST
92226: LIST
92227: PUSH
92228: LD_INT 4
92230: NEG
92231: PUSH
92232: LD_INT 2
92234: NEG
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 2
92242: NEG
92243: PUSH
92244: LD_INT 2
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 4
92253: NEG
92254: PUSH
92255: LD_INT 4
92257: NEG
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 4
92265: NEG
92266: PUSH
92267: LD_INT 5
92269: NEG
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PUSH
92275: LD_INT 3
92277: NEG
92278: PUSH
92279: LD_INT 4
92281: NEG
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 3
92289: NEG
92290: PUSH
92291: LD_INT 3
92293: NEG
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 4
92301: NEG
92302: PUSH
92303: LD_INT 3
92305: NEG
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 5
92313: NEG
92314: PUSH
92315: LD_INT 4
92317: NEG
92318: PUSH
92319: EMPTY
92320: LIST
92321: LIST
92322: PUSH
92323: LD_INT 5
92325: NEG
92326: PUSH
92327: LD_INT 5
92329: NEG
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: LD_INT 3
92337: NEG
92338: PUSH
92339: LD_INT 5
92341: NEG
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 5
92349: NEG
92350: PUSH
92351: LD_INT 3
92353: NEG
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: LIST
92401: LIST
92402: LIST
92403: LIST
92404: LIST
92405: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92406: LD_ADDR_VAR 0 30
92410: PUSH
92411: LD_INT 4
92413: PUSH
92414: LD_INT 4
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 4
92423: PUSH
92424: LD_INT 3
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 5
92433: PUSH
92434: LD_INT 4
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 5
92443: PUSH
92444: LD_INT 5
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 4
92453: PUSH
92454: LD_INT 5
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 3
92463: PUSH
92464: LD_INT 4
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 3
92473: PUSH
92474: LD_INT 3
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 5
92483: PUSH
92484: LD_INT 3
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 3
92493: PUSH
92494: LD_INT 5
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 0
92503: PUSH
92504: LD_INT 3
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 0
92513: PUSH
92514: LD_INT 2
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: LD_INT 1
92523: PUSH
92524: LD_INT 3
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 1
92533: PUSH
92534: LD_INT 4
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: PUSH
92541: LD_INT 0
92543: PUSH
92544: LD_INT 4
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 1
92553: NEG
92554: PUSH
92555: LD_INT 3
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 1
92564: NEG
92565: PUSH
92566: LD_INT 2
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: LD_INT 2
92575: PUSH
92576: LD_INT 4
92578: PUSH
92579: EMPTY
92580: LIST
92581: LIST
92582: PUSH
92583: LD_INT 2
92585: NEG
92586: PUSH
92587: LD_INT 2
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 4
92596: NEG
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 4
92607: NEG
92608: PUSH
92609: LD_INT 1
92611: NEG
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: LD_INT 3
92619: NEG
92620: PUSH
92621: LD_INT 0
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: LD_INT 3
92630: NEG
92631: PUSH
92632: LD_INT 1
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: PUSH
92639: LD_INT 4
92641: NEG
92642: PUSH
92643: LD_INT 1
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 5
92652: NEG
92653: PUSH
92654: LD_INT 0
92656: PUSH
92657: EMPTY
92658: LIST
92659: LIST
92660: PUSH
92661: LD_INT 5
92663: NEG
92664: PUSH
92665: LD_INT 1
92667: NEG
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: PUSH
92673: LD_INT 5
92675: NEG
92676: PUSH
92677: LD_INT 2
92679: NEG
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 3
92687: NEG
92688: PUSH
92689: LD_INT 2
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: PUSH
92696: LD_INT 3
92698: NEG
92699: PUSH
92700: LD_INT 3
92702: NEG
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 3
92710: NEG
92711: PUSH
92712: LD_INT 4
92714: NEG
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 2
92722: NEG
92723: PUSH
92724: LD_INT 3
92726: NEG
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 2
92734: NEG
92735: PUSH
92736: LD_INT 2
92738: NEG
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 3
92746: NEG
92747: PUSH
92748: LD_INT 2
92750: NEG
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 4
92758: NEG
92759: PUSH
92760: LD_INT 3
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 4
92770: NEG
92771: PUSH
92772: LD_INT 4
92774: NEG
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 2
92782: NEG
92783: PUSH
92784: LD_INT 4
92786: NEG
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 4
92794: NEG
92795: PUSH
92796: LD_INT 2
92798: NEG
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: LD_INT 0
92806: PUSH
92807: LD_INT 4
92809: NEG
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 0
92817: PUSH
92818: LD_INT 5
92820: NEG
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 1
92828: PUSH
92829: LD_INT 4
92831: NEG
92832: PUSH
92833: EMPTY
92834: LIST
92835: LIST
92836: PUSH
92837: LD_INT 1
92839: PUSH
92840: LD_INT 3
92842: NEG
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 0
92850: PUSH
92851: LD_INT 3
92853: NEG
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 1
92861: NEG
92862: PUSH
92863: LD_INT 4
92865: NEG
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 1
92873: NEG
92874: PUSH
92875: LD_INT 5
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 2
92885: PUSH
92886: LD_INT 3
92888: NEG
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 2
92896: NEG
92897: PUSH
92898: LD_INT 5
92900: NEG
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: LIST
92948: LIST
92949: LIST
92950: LIST
92951: LIST
92952: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92953: LD_ADDR_VAR 0 31
92957: PUSH
92958: LD_INT 0
92960: PUSH
92961: LD_INT 4
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 0
92970: PUSH
92971: LD_INT 3
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 1
92980: PUSH
92981: LD_INT 4
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 1
92990: PUSH
92991: LD_INT 5
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 0
93000: PUSH
93001: LD_INT 5
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 1
93010: NEG
93011: PUSH
93012: LD_INT 4
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 1
93021: NEG
93022: PUSH
93023: LD_INT 3
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 2
93032: PUSH
93033: LD_INT 5
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 2
93042: NEG
93043: PUSH
93044: LD_INT 3
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 3
93053: NEG
93054: PUSH
93055: LD_INT 0
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 3
93064: NEG
93065: PUSH
93066: LD_INT 1
93068: NEG
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 2
93076: NEG
93077: PUSH
93078: LD_INT 0
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PUSH
93085: LD_INT 2
93087: NEG
93088: PUSH
93089: LD_INT 1
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 3
93098: NEG
93099: PUSH
93100: LD_INT 1
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: PUSH
93107: LD_INT 4
93109: NEG
93110: PUSH
93111: LD_INT 0
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: LD_INT 4
93120: NEG
93121: PUSH
93122: LD_INT 1
93124: NEG
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: PUSH
93130: LD_INT 4
93132: NEG
93133: PUSH
93134: LD_INT 2
93136: NEG
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 2
93144: NEG
93145: PUSH
93146: LD_INT 2
93148: PUSH
93149: EMPTY
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 4
93155: NEG
93156: PUSH
93157: LD_INT 4
93159: NEG
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: LD_INT 5
93171: NEG
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: LD_INT 3
93179: NEG
93180: PUSH
93181: LD_INT 4
93183: NEG
93184: PUSH
93185: EMPTY
93186: LIST
93187: LIST
93188: PUSH
93189: LD_INT 3
93191: NEG
93192: PUSH
93193: LD_INT 3
93195: NEG
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: LD_INT 4
93203: NEG
93204: PUSH
93205: LD_INT 3
93207: NEG
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 5
93215: NEG
93216: PUSH
93217: LD_INT 4
93219: NEG
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PUSH
93225: LD_INT 5
93227: NEG
93228: PUSH
93229: LD_INT 5
93231: NEG
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: LD_INT 3
93239: NEG
93240: PUSH
93241: LD_INT 5
93243: NEG
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 5
93251: NEG
93252: PUSH
93253: LD_INT 3
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 0
93263: PUSH
93264: LD_INT 3
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 0
93274: PUSH
93275: LD_INT 4
93277: NEG
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 1
93285: PUSH
93286: LD_INT 3
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 1
93296: PUSH
93297: LD_INT 2
93299: NEG
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 0
93307: PUSH
93308: LD_INT 2
93310: NEG
93311: PUSH
93312: EMPTY
93313: LIST
93314: LIST
93315: PUSH
93316: LD_INT 1
93318: NEG
93319: PUSH
93320: LD_INT 3
93322: NEG
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 1
93330: NEG
93331: PUSH
93332: LD_INT 4
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 2
93342: PUSH
93343: LD_INT 2
93345: NEG
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 2
93353: NEG
93354: PUSH
93355: LD_INT 4
93357: NEG
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 4
93365: PUSH
93366: LD_INT 0
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: PUSH
93373: LD_INT 4
93375: PUSH
93376: LD_INT 1
93378: NEG
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: LD_INT 5
93386: PUSH
93387: LD_INT 0
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PUSH
93394: LD_INT 5
93396: PUSH
93397: LD_INT 1
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: LD_INT 4
93406: PUSH
93407: LD_INT 1
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 3
93416: PUSH
93417: LD_INT 0
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 3
93426: PUSH
93427: LD_INT 1
93429: NEG
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 3
93437: PUSH
93438: LD_INT 2
93440: NEG
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: PUSH
93446: LD_INT 5
93448: PUSH
93449: LD_INT 2
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93503: LD_ADDR_VAR 0 32
93507: PUSH
93508: LD_INT 4
93510: NEG
93511: PUSH
93512: LD_INT 0
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: PUSH
93519: LD_INT 4
93521: NEG
93522: PUSH
93523: LD_INT 1
93525: NEG
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 3
93533: NEG
93534: PUSH
93535: LD_INT 0
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 3
93544: NEG
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 4
93555: NEG
93556: PUSH
93557: LD_INT 1
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 5
93566: NEG
93567: PUSH
93568: LD_INT 0
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 5
93577: NEG
93578: PUSH
93579: LD_INT 1
93581: NEG
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 5
93589: NEG
93590: PUSH
93591: LD_INT 2
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 3
93601: NEG
93602: PUSH
93603: LD_INT 2
93605: PUSH
93606: EMPTY
93607: LIST
93608: LIST
93609: PUSH
93610: LD_INT 3
93612: NEG
93613: PUSH
93614: LD_INT 3
93616: NEG
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 3
93624: NEG
93625: PUSH
93626: LD_INT 4
93628: NEG
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: PUSH
93634: LD_INT 2
93636: NEG
93637: PUSH
93638: LD_INT 3
93640: NEG
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: LD_INT 2
93648: NEG
93649: PUSH
93650: LD_INT 2
93652: NEG
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: LD_INT 3
93660: NEG
93661: PUSH
93662: LD_INT 2
93664: NEG
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: LD_INT 4
93672: NEG
93673: PUSH
93674: LD_INT 3
93676: NEG
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PUSH
93682: LD_INT 4
93684: NEG
93685: PUSH
93686: LD_INT 4
93688: NEG
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 2
93696: NEG
93697: PUSH
93698: LD_INT 4
93700: NEG
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 4
93708: NEG
93709: PUSH
93710: LD_INT 2
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 0
93720: PUSH
93721: LD_INT 4
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: LD_INT 0
93731: PUSH
93732: LD_INT 5
93734: NEG
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 1
93742: PUSH
93743: LD_INT 4
93745: NEG
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 1
93753: PUSH
93754: LD_INT 3
93756: NEG
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 0
93764: PUSH
93765: LD_INT 3
93767: NEG
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 1
93775: NEG
93776: PUSH
93777: LD_INT 4
93779: NEG
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 1
93787: NEG
93788: PUSH
93789: LD_INT 5
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 2
93799: PUSH
93800: LD_INT 3
93802: NEG
93803: PUSH
93804: EMPTY
93805: LIST
93806: LIST
93807: PUSH
93808: LD_INT 2
93810: NEG
93811: PUSH
93812: LD_INT 5
93814: NEG
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 3
93822: PUSH
93823: LD_INT 0
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 3
93832: PUSH
93833: LD_INT 1
93835: NEG
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: PUSH
93841: LD_INT 4
93843: PUSH
93844: LD_INT 0
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: LD_INT 4
93853: PUSH
93854: LD_INT 1
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 3
93863: PUSH
93864: LD_INT 1
93866: PUSH
93867: EMPTY
93868: LIST
93869: LIST
93870: PUSH
93871: LD_INT 2
93873: PUSH
93874: LD_INT 0
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 2
93883: PUSH
93884: LD_INT 1
93886: NEG
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: LD_INT 2
93894: PUSH
93895: LD_INT 2
93897: NEG
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 4
93905: PUSH
93906: LD_INT 2
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_INT 4
93915: PUSH
93916: LD_INT 4
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: PUSH
93923: LD_INT 4
93925: PUSH
93926: LD_INT 3
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 5
93935: PUSH
93936: LD_INT 4
93938: PUSH
93939: EMPTY
93940: LIST
93941: LIST
93942: PUSH
93943: LD_INT 5
93945: PUSH
93946: LD_INT 5
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 4
93955: PUSH
93956: LD_INT 5
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 3
93965: PUSH
93966: LD_INT 4
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: LD_INT 3
93975: PUSH
93976: LD_INT 3
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: LD_INT 5
93985: PUSH
93986: LD_INT 3
93988: PUSH
93989: EMPTY
93990: LIST
93991: LIST
93992: PUSH
93993: LD_INT 3
93995: PUSH
93996: LD_INT 5
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94050: LD_ADDR_VAR 0 33
94054: PUSH
94055: LD_INT 4
94057: NEG
94058: PUSH
94059: LD_INT 4
94061: NEG
94062: PUSH
94063: EMPTY
94064: LIST
94065: LIST
94066: PUSH
94067: LD_INT 4
94069: NEG
94070: PUSH
94071: LD_INT 5
94073: NEG
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 3
94081: NEG
94082: PUSH
94083: LD_INT 4
94085: NEG
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 3
94093: NEG
94094: PUSH
94095: LD_INT 3
94097: NEG
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 4
94105: NEG
94106: PUSH
94107: LD_INT 3
94109: NEG
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 5
94117: NEG
94118: PUSH
94119: LD_INT 4
94121: NEG
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: PUSH
94127: LD_INT 5
94129: NEG
94130: PUSH
94131: LD_INT 5
94133: NEG
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 3
94141: NEG
94142: PUSH
94143: LD_INT 5
94145: NEG
94146: PUSH
94147: EMPTY
94148: LIST
94149: LIST
94150: PUSH
94151: LD_INT 5
94153: NEG
94154: PUSH
94155: LD_INT 3
94157: NEG
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 0
94165: PUSH
94166: LD_INT 3
94168: NEG
94169: PUSH
94170: EMPTY
94171: LIST
94172: LIST
94173: PUSH
94174: LD_INT 0
94176: PUSH
94177: LD_INT 4
94179: NEG
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 1
94187: PUSH
94188: LD_INT 3
94190: NEG
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: PUSH
94196: LD_INT 1
94198: PUSH
94199: LD_INT 2
94201: NEG
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PUSH
94207: LD_INT 0
94209: PUSH
94210: LD_INT 2
94212: NEG
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 1
94220: NEG
94221: PUSH
94222: LD_INT 3
94224: NEG
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 1
94232: NEG
94233: PUSH
94234: LD_INT 4
94236: NEG
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 2
94244: PUSH
94245: LD_INT 2
94247: NEG
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 2
94255: NEG
94256: PUSH
94257: LD_INT 4
94259: NEG
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 4
94267: PUSH
94268: LD_INT 0
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: PUSH
94275: LD_INT 4
94277: PUSH
94278: LD_INT 1
94280: NEG
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: PUSH
94286: LD_INT 5
94288: PUSH
94289: LD_INT 0
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 5
94298: PUSH
94299: LD_INT 1
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 4
94308: PUSH
94309: LD_INT 1
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: LD_INT 3
94318: PUSH
94319: LD_INT 0
94321: PUSH
94322: EMPTY
94323: LIST
94324: LIST
94325: PUSH
94326: LD_INT 3
94328: PUSH
94329: LD_INT 1
94331: NEG
94332: PUSH
94333: EMPTY
94334: LIST
94335: LIST
94336: PUSH
94337: LD_INT 3
94339: PUSH
94340: LD_INT 2
94342: NEG
94343: PUSH
94344: EMPTY
94345: LIST
94346: LIST
94347: PUSH
94348: LD_INT 5
94350: PUSH
94351: LD_INT 2
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: LD_INT 3
94360: PUSH
94361: LD_INT 3
94363: PUSH
94364: EMPTY
94365: LIST
94366: LIST
94367: PUSH
94368: LD_INT 3
94370: PUSH
94371: LD_INT 2
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 4
94380: PUSH
94381: LD_INT 3
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: LD_INT 4
94390: PUSH
94391: LD_INT 4
94393: PUSH
94394: EMPTY
94395: LIST
94396: LIST
94397: PUSH
94398: LD_INT 3
94400: PUSH
94401: LD_INT 4
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: PUSH
94408: LD_INT 2
94410: PUSH
94411: LD_INT 3
94413: PUSH
94414: EMPTY
94415: LIST
94416: LIST
94417: PUSH
94418: LD_INT 2
94420: PUSH
94421: LD_INT 2
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: PUSH
94428: LD_INT 4
94430: PUSH
94431: LD_INT 2
94433: PUSH
94434: EMPTY
94435: LIST
94436: LIST
94437: PUSH
94438: LD_INT 2
94440: PUSH
94441: LD_INT 4
94443: PUSH
94444: EMPTY
94445: LIST
94446: LIST
94447: PUSH
94448: LD_INT 0
94450: PUSH
94451: LD_INT 4
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: PUSH
94458: LD_INT 0
94460: PUSH
94461: LD_INT 3
94463: PUSH
94464: EMPTY
94465: LIST
94466: LIST
94467: PUSH
94468: LD_INT 1
94470: PUSH
94471: LD_INT 4
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 1
94480: PUSH
94481: LD_INT 5
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 0
94490: PUSH
94491: LD_INT 5
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 1
94500: NEG
94501: PUSH
94502: LD_INT 4
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 1
94511: NEG
94512: PUSH
94513: LD_INT 3
94515: PUSH
94516: EMPTY
94517: LIST
94518: LIST
94519: PUSH
94520: LD_INT 2
94522: PUSH
94523: LD_INT 5
94525: PUSH
94526: EMPTY
94527: LIST
94528: LIST
94529: PUSH
94530: LD_INT 2
94532: NEG
94533: PUSH
94534: LD_INT 3
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94588: LD_ADDR_VAR 0 34
94592: PUSH
94593: LD_INT 0
94595: PUSH
94596: LD_INT 4
94598: NEG
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 0
94606: PUSH
94607: LD_INT 5
94609: NEG
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: LD_INT 1
94617: PUSH
94618: LD_INT 4
94620: NEG
94621: PUSH
94622: EMPTY
94623: LIST
94624: LIST
94625: PUSH
94626: LD_INT 1
94628: PUSH
94629: LD_INT 3
94631: NEG
94632: PUSH
94633: EMPTY
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 0
94639: PUSH
94640: LD_INT 3
94642: NEG
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 1
94650: NEG
94651: PUSH
94652: LD_INT 4
94654: NEG
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: PUSH
94660: LD_INT 1
94662: NEG
94663: PUSH
94664: LD_INT 5
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 2
94674: PUSH
94675: LD_INT 3
94677: NEG
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: PUSH
94683: LD_INT 2
94685: NEG
94686: PUSH
94687: LD_INT 5
94689: NEG
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 3
94697: PUSH
94698: LD_INT 0
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 3
94707: PUSH
94708: LD_INT 1
94710: NEG
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 4
94718: PUSH
94719: LD_INT 0
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 4
94728: PUSH
94729: LD_INT 1
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: PUSH
94736: LD_INT 3
94738: PUSH
94739: LD_INT 1
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: LD_INT 2
94748: PUSH
94749: LD_INT 0
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 2
94758: PUSH
94759: LD_INT 1
94761: NEG
94762: PUSH
94763: EMPTY
94764: LIST
94765: LIST
94766: PUSH
94767: LD_INT 2
94769: PUSH
94770: LD_INT 2
94772: NEG
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 4
94780: PUSH
94781: LD_INT 2
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: PUSH
94788: LD_INT 4
94790: PUSH
94791: LD_INT 4
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 4
94800: PUSH
94801: LD_INT 3
94803: PUSH
94804: EMPTY
94805: LIST
94806: LIST
94807: PUSH
94808: LD_INT 5
94810: PUSH
94811: LD_INT 4
94813: PUSH
94814: EMPTY
94815: LIST
94816: LIST
94817: PUSH
94818: LD_INT 5
94820: PUSH
94821: LD_INT 5
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 4
94830: PUSH
94831: LD_INT 5
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: PUSH
94838: LD_INT 3
94840: PUSH
94841: LD_INT 4
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 3
94850: PUSH
94851: LD_INT 3
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 5
94860: PUSH
94861: LD_INT 3
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: PUSH
94868: LD_INT 3
94870: PUSH
94871: LD_INT 5
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: PUSH
94878: LD_INT 0
94880: PUSH
94881: LD_INT 3
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 0
94890: PUSH
94891: LD_INT 2
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: PUSH
94898: LD_INT 1
94900: PUSH
94901: LD_INT 3
94903: PUSH
94904: EMPTY
94905: LIST
94906: LIST
94907: PUSH
94908: LD_INT 1
94910: PUSH
94911: LD_INT 4
94913: PUSH
94914: EMPTY
94915: LIST
94916: LIST
94917: PUSH
94918: LD_INT 0
94920: PUSH
94921: LD_INT 4
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 1
94930: NEG
94931: PUSH
94932: LD_INT 3
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 1
94941: NEG
94942: PUSH
94943: LD_INT 2
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 2
94952: PUSH
94953: LD_INT 4
94955: PUSH
94956: EMPTY
94957: LIST
94958: LIST
94959: PUSH
94960: LD_INT 2
94962: NEG
94963: PUSH
94964: LD_INT 2
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 4
94973: NEG
94974: PUSH
94975: LD_INT 0
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 4
94984: NEG
94985: PUSH
94986: LD_INT 1
94988: NEG
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 3
94996: NEG
94997: PUSH
94998: LD_INT 0
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 3
95007: NEG
95008: PUSH
95009: LD_INT 1
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 4
95018: NEG
95019: PUSH
95020: LD_INT 1
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 5
95029: NEG
95030: PUSH
95031: LD_INT 0
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 5
95040: NEG
95041: PUSH
95042: LD_INT 1
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 5
95052: NEG
95053: PUSH
95054: LD_INT 2
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 3
95064: NEG
95065: PUSH
95066: LD_INT 2
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: ST_TO_ADDR
// end ; end ;
95120: GO 95123
95122: POP
// case btype of b_depot , b_warehouse :
95123: LD_VAR 0 1
95127: PUSH
95128: LD_INT 0
95130: DOUBLE
95131: EQUAL
95132: IFTRUE 95142
95134: LD_INT 1
95136: DOUBLE
95137: EQUAL
95138: IFTRUE 95142
95140: GO 95343
95142: POP
// case nation of nation_american :
95143: LD_VAR 0 5
95147: PUSH
95148: LD_INT 1
95150: DOUBLE
95151: EQUAL
95152: IFTRUE 95156
95154: GO 95212
95156: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95157: LD_ADDR_VAR 0 9
95161: PUSH
95162: LD_VAR 0 11
95166: PUSH
95167: LD_VAR 0 12
95171: PUSH
95172: LD_VAR 0 13
95176: PUSH
95177: LD_VAR 0 14
95181: PUSH
95182: LD_VAR 0 15
95186: PUSH
95187: LD_VAR 0 16
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: PUSH
95200: LD_VAR 0 4
95204: PUSH
95205: LD_INT 1
95207: PLUS
95208: ARRAY
95209: ST_TO_ADDR
95210: GO 95341
95212: LD_INT 2
95214: DOUBLE
95215: EQUAL
95216: IFTRUE 95220
95218: GO 95276
95220: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95221: LD_ADDR_VAR 0 9
95225: PUSH
95226: LD_VAR 0 17
95230: PUSH
95231: LD_VAR 0 18
95235: PUSH
95236: LD_VAR 0 19
95240: PUSH
95241: LD_VAR 0 20
95245: PUSH
95246: LD_VAR 0 21
95250: PUSH
95251: LD_VAR 0 22
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: PUSH
95264: LD_VAR 0 4
95268: PUSH
95269: LD_INT 1
95271: PLUS
95272: ARRAY
95273: ST_TO_ADDR
95274: GO 95341
95276: LD_INT 3
95278: DOUBLE
95279: EQUAL
95280: IFTRUE 95284
95282: GO 95340
95284: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95285: LD_ADDR_VAR 0 9
95289: PUSH
95290: LD_VAR 0 23
95294: PUSH
95295: LD_VAR 0 24
95299: PUSH
95300: LD_VAR 0 25
95304: PUSH
95305: LD_VAR 0 26
95309: PUSH
95310: LD_VAR 0 27
95314: PUSH
95315: LD_VAR 0 28
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: PUSH
95328: LD_VAR 0 4
95332: PUSH
95333: LD_INT 1
95335: PLUS
95336: ARRAY
95337: ST_TO_ADDR
95338: GO 95341
95340: POP
95341: GO 95896
95343: LD_INT 2
95345: DOUBLE
95346: EQUAL
95347: IFTRUE 95357
95349: LD_INT 3
95351: DOUBLE
95352: EQUAL
95353: IFTRUE 95357
95355: GO 95413
95357: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95358: LD_ADDR_VAR 0 9
95362: PUSH
95363: LD_VAR 0 29
95367: PUSH
95368: LD_VAR 0 30
95372: PUSH
95373: LD_VAR 0 31
95377: PUSH
95378: LD_VAR 0 32
95382: PUSH
95383: LD_VAR 0 33
95387: PUSH
95388: LD_VAR 0 34
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: PUSH
95401: LD_VAR 0 4
95405: PUSH
95406: LD_INT 1
95408: PLUS
95409: ARRAY
95410: ST_TO_ADDR
95411: GO 95896
95413: LD_INT 16
95415: DOUBLE
95416: EQUAL
95417: IFTRUE 95475
95419: LD_INT 17
95421: DOUBLE
95422: EQUAL
95423: IFTRUE 95475
95425: LD_INT 18
95427: DOUBLE
95428: EQUAL
95429: IFTRUE 95475
95431: LD_INT 19
95433: DOUBLE
95434: EQUAL
95435: IFTRUE 95475
95437: LD_INT 22
95439: DOUBLE
95440: EQUAL
95441: IFTRUE 95475
95443: LD_INT 20
95445: DOUBLE
95446: EQUAL
95447: IFTRUE 95475
95449: LD_INT 21
95451: DOUBLE
95452: EQUAL
95453: IFTRUE 95475
95455: LD_INT 23
95457: DOUBLE
95458: EQUAL
95459: IFTRUE 95475
95461: LD_INT 24
95463: DOUBLE
95464: EQUAL
95465: IFTRUE 95475
95467: LD_INT 25
95469: DOUBLE
95470: EQUAL
95471: IFTRUE 95475
95473: GO 95531
95475: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95476: LD_ADDR_VAR 0 9
95480: PUSH
95481: LD_VAR 0 35
95485: PUSH
95486: LD_VAR 0 36
95490: PUSH
95491: LD_VAR 0 37
95495: PUSH
95496: LD_VAR 0 38
95500: PUSH
95501: LD_VAR 0 39
95505: PUSH
95506: LD_VAR 0 40
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: PUSH
95519: LD_VAR 0 4
95523: PUSH
95524: LD_INT 1
95526: PLUS
95527: ARRAY
95528: ST_TO_ADDR
95529: GO 95896
95531: LD_INT 6
95533: DOUBLE
95534: EQUAL
95535: IFTRUE 95587
95537: LD_INT 7
95539: DOUBLE
95540: EQUAL
95541: IFTRUE 95587
95543: LD_INT 8
95545: DOUBLE
95546: EQUAL
95547: IFTRUE 95587
95549: LD_INT 13
95551: DOUBLE
95552: EQUAL
95553: IFTRUE 95587
95555: LD_INT 12
95557: DOUBLE
95558: EQUAL
95559: IFTRUE 95587
95561: LD_INT 15
95563: DOUBLE
95564: EQUAL
95565: IFTRUE 95587
95567: LD_INT 11
95569: DOUBLE
95570: EQUAL
95571: IFTRUE 95587
95573: LD_INT 14
95575: DOUBLE
95576: EQUAL
95577: IFTRUE 95587
95579: LD_INT 10
95581: DOUBLE
95582: EQUAL
95583: IFTRUE 95587
95585: GO 95643
95587: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
95588: LD_ADDR_VAR 0 9
95592: PUSH
95593: LD_VAR 0 41
95597: PUSH
95598: LD_VAR 0 42
95602: PUSH
95603: LD_VAR 0 43
95607: PUSH
95608: LD_VAR 0 44
95612: PUSH
95613: LD_VAR 0 45
95617: PUSH
95618: LD_VAR 0 46
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: PUSH
95631: LD_VAR 0 4
95635: PUSH
95636: LD_INT 1
95638: PLUS
95639: ARRAY
95640: ST_TO_ADDR
95641: GO 95896
95643: LD_INT 36
95645: DOUBLE
95646: EQUAL
95647: IFTRUE 95651
95649: GO 95707
95651: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95652: LD_ADDR_VAR 0 9
95656: PUSH
95657: LD_VAR 0 47
95661: PUSH
95662: LD_VAR 0 48
95666: PUSH
95667: LD_VAR 0 49
95671: PUSH
95672: LD_VAR 0 50
95676: PUSH
95677: LD_VAR 0 51
95681: PUSH
95682: LD_VAR 0 52
95686: PUSH
95687: EMPTY
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: PUSH
95695: LD_VAR 0 4
95699: PUSH
95700: LD_INT 1
95702: PLUS
95703: ARRAY
95704: ST_TO_ADDR
95705: GO 95896
95707: LD_INT 4
95709: DOUBLE
95710: EQUAL
95711: IFTRUE 95733
95713: LD_INT 5
95715: DOUBLE
95716: EQUAL
95717: IFTRUE 95733
95719: LD_INT 34
95721: DOUBLE
95722: EQUAL
95723: IFTRUE 95733
95725: LD_INT 37
95727: DOUBLE
95728: EQUAL
95729: IFTRUE 95733
95731: GO 95789
95733: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95734: LD_ADDR_VAR 0 9
95738: PUSH
95739: LD_VAR 0 53
95743: PUSH
95744: LD_VAR 0 54
95748: PUSH
95749: LD_VAR 0 55
95753: PUSH
95754: LD_VAR 0 56
95758: PUSH
95759: LD_VAR 0 57
95763: PUSH
95764: LD_VAR 0 58
95768: PUSH
95769: EMPTY
95770: LIST
95771: LIST
95772: LIST
95773: LIST
95774: LIST
95775: LIST
95776: PUSH
95777: LD_VAR 0 4
95781: PUSH
95782: LD_INT 1
95784: PLUS
95785: ARRAY
95786: ST_TO_ADDR
95787: GO 95896
95789: LD_INT 31
95791: DOUBLE
95792: EQUAL
95793: IFTRUE 95839
95795: LD_INT 32
95797: DOUBLE
95798: EQUAL
95799: IFTRUE 95839
95801: LD_INT 33
95803: DOUBLE
95804: EQUAL
95805: IFTRUE 95839
95807: LD_INT 27
95809: DOUBLE
95810: EQUAL
95811: IFTRUE 95839
95813: LD_INT 26
95815: DOUBLE
95816: EQUAL
95817: IFTRUE 95839
95819: LD_INT 28
95821: DOUBLE
95822: EQUAL
95823: IFTRUE 95839
95825: LD_INT 29
95827: DOUBLE
95828: EQUAL
95829: IFTRUE 95839
95831: LD_INT 30
95833: DOUBLE
95834: EQUAL
95835: IFTRUE 95839
95837: GO 95895
95839: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
95840: LD_ADDR_VAR 0 9
95844: PUSH
95845: LD_VAR 0 59
95849: PUSH
95850: LD_VAR 0 60
95854: PUSH
95855: LD_VAR 0 61
95859: PUSH
95860: LD_VAR 0 62
95864: PUSH
95865: LD_VAR 0 63
95869: PUSH
95870: LD_VAR 0 64
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: PUSH
95883: LD_VAR 0 4
95887: PUSH
95888: LD_INT 1
95890: PLUS
95891: ARRAY
95892: ST_TO_ADDR
95893: GO 95896
95895: POP
// temp_list2 = [ ] ;
95896: LD_ADDR_VAR 0 10
95900: PUSH
95901: EMPTY
95902: ST_TO_ADDR
// for i in temp_list do
95903: LD_ADDR_VAR 0 8
95907: PUSH
95908: LD_VAR 0 9
95912: PUSH
95913: FOR_IN
95914: IFFALSE 95966
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95916: LD_ADDR_VAR 0 10
95920: PUSH
95921: LD_VAR 0 10
95925: PUSH
95926: LD_VAR 0 8
95930: PUSH
95931: LD_INT 1
95933: ARRAY
95934: PUSH
95935: LD_VAR 0 2
95939: PLUS
95940: PUSH
95941: LD_VAR 0 8
95945: PUSH
95946: LD_INT 2
95948: ARRAY
95949: PUSH
95950: LD_VAR 0 3
95954: PLUS
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: EMPTY
95961: LIST
95962: ADD
95963: ST_TO_ADDR
95964: GO 95913
95966: POP
95967: POP
// result = temp_list2 ;
95968: LD_ADDR_VAR 0 7
95972: PUSH
95973: LD_VAR 0 10
95977: ST_TO_ADDR
// end ;
95978: LD_VAR 0 7
95982: RET
// export function EnemyInRange ( unit , dist ) ; begin
95983: LD_INT 0
95985: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95986: LD_ADDR_VAR 0 3
95990: PUSH
95991: LD_VAR 0 1
95995: PPUSH
95996: CALL_OW 255
96000: PPUSH
96001: LD_VAR 0 1
96005: PPUSH
96006: CALL_OW 250
96010: PPUSH
96011: LD_VAR 0 1
96015: PPUSH
96016: CALL_OW 251
96020: PPUSH
96021: LD_VAR 0 2
96025: PPUSH
96026: CALL 69385 0 4
96030: PUSH
96031: LD_INT 4
96033: ARRAY
96034: ST_TO_ADDR
// end ;
96035: LD_VAR 0 3
96039: RET
// export function PlayerSeeMe ( unit ) ; begin
96040: LD_INT 0
96042: PPUSH
// result := See ( your_side , unit ) ;
96043: LD_ADDR_VAR 0 2
96047: PUSH
96048: LD_OWVAR 2
96052: PPUSH
96053: LD_VAR 0 1
96057: PPUSH
96058: CALL_OW 292
96062: ST_TO_ADDR
// end ;
96063: LD_VAR 0 2
96067: RET
// export function ReverseDir ( unit ) ; begin
96068: LD_INT 0
96070: PPUSH
// if not unit then
96071: LD_VAR 0 1
96075: NOT
96076: IFFALSE 96080
// exit ;
96078: GO 96103
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96080: LD_ADDR_VAR 0 2
96084: PUSH
96085: LD_VAR 0 1
96089: PPUSH
96090: CALL_OW 254
96094: PUSH
96095: LD_INT 3
96097: PLUS
96098: PUSH
96099: LD_INT 6
96101: MOD
96102: ST_TO_ADDR
// end ;
96103: LD_VAR 0 2
96107: RET
// export function ReverseArray ( array ) ; var i ; begin
96108: LD_INT 0
96110: PPUSH
96111: PPUSH
// if not array then
96112: LD_VAR 0 1
96116: NOT
96117: IFFALSE 96121
// exit ;
96119: GO 96176
// result := [ ] ;
96121: LD_ADDR_VAR 0 2
96125: PUSH
96126: EMPTY
96127: ST_TO_ADDR
// for i := array downto 1 do
96128: LD_ADDR_VAR 0 3
96132: PUSH
96133: DOUBLE
96134: LD_VAR 0 1
96138: INC
96139: ST_TO_ADDR
96140: LD_INT 1
96142: PUSH
96143: FOR_DOWNTO
96144: IFFALSE 96174
// result := Join ( result , array [ i ] ) ;
96146: LD_ADDR_VAR 0 2
96150: PUSH
96151: LD_VAR 0 2
96155: PPUSH
96156: LD_VAR 0 1
96160: PUSH
96161: LD_VAR 0 3
96165: ARRAY
96166: PPUSH
96167: CALL 100820 0 2
96171: ST_TO_ADDR
96172: GO 96143
96174: POP
96175: POP
// end ;
96176: LD_VAR 0 2
96180: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
96181: LD_INT 0
96183: PPUSH
96184: PPUSH
96185: PPUSH
96186: PPUSH
96187: PPUSH
96188: PPUSH
// if not unit or not hexes then
96189: LD_VAR 0 1
96193: NOT
96194: PUSH
96195: LD_VAR 0 2
96199: NOT
96200: OR
96201: IFFALSE 96205
// exit ;
96203: GO 96328
// dist := 9999 ;
96205: LD_ADDR_VAR 0 5
96209: PUSH
96210: LD_INT 9999
96212: ST_TO_ADDR
// for i = 1 to hexes do
96213: LD_ADDR_VAR 0 4
96217: PUSH
96218: DOUBLE
96219: LD_INT 1
96221: DEC
96222: ST_TO_ADDR
96223: LD_VAR 0 2
96227: PUSH
96228: FOR_TO
96229: IFFALSE 96316
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96231: LD_ADDR_VAR 0 6
96235: PUSH
96236: LD_VAR 0 1
96240: PPUSH
96241: LD_VAR 0 2
96245: PUSH
96246: LD_VAR 0 4
96250: ARRAY
96251: PUSH
96252: LD_INT 1
96254: ARRAY
96255: PPUSH
96256: LD_VAR 0 2
96260: PUSH
96261: LD_VAR 0 4
96265: ARRAY
96266: PUSH
96267: LD_INT 2
96269: ARRAY
96270: PPUSH
96271: CALL_OW 297
96275: ST_TO_ADDR
// if tdist < dist then
96276: LD_VAR 0 6
96280: PUSH
96281: LD_VAR 0 5
96285: LESS
96286: IFFALSE 96314
// begin hex := hexes [ i ] ;
96288: LD_ADDR_VAR 0 8
96292: PUSH
96293: LD_VAR 0 2
96297: PUSH
96298: LD_VAR 0 4
96302: ARRAY
96303: ST_TO_ADDR
// dist := tdist ;
96304: LD_ADDR_VAR 0 5
96308: PUSH
96309: LD_VAR 0 6
96313: ST_TO_ADDR
// end ; end ;
96314: GO 96228
96316: POP
96317: POP
// result := hex ;
96318: LD_ADDR_VAR 0 3
96322: PUSH
96323: LD_VAR 0 8
96327: ST_TO_ADDR
// end ;
96328: LD_VAR 0 3
96332: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96333: LD_INT 0
96335: PPUSH
96336: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96337: LD_VAR 0 1
96341: NOT
96342: PUSH
96343: LD_VAR 0 1
96347: PUSH
96348: LD_INT 21
96350: PUSH
96351: LD_INT 2
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PUSH
96358: LD_INT 23
96360: PUSH
96361: LD_INT 2
96363: PUSH
96364: EMPTY
96365: LIST
96366: LIST
96367: PUSH
96368: EMPTY
96369: LIST
96370: LIST
96371: PPUSH
96372: CALL_OW 69
96376: IN
96377: NOT
96378: OR
96379: IFFALSE 96383
// exit ;
96381: GO 96430
// for i = 1 to 3 do
96383: LD_ADDR_VAR 0 3
96387: PUSH
96388: DOUBLE
96389: LD_INT 1
96391: DEC
96392: ST_TO_ADDR
96393: LD_INT 3
96395: PUSH
96396: FOR_TO
96397: IFFALSE 96428
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96399: LD_VAR 0 1
96403: PPUSH
96404: CALL_OW 250
96408: PPUSH
96409: LD_VAR 0 1
96413: PPUSH
96414: CALL_OW 251
96418: PPUSH
96419: LD_INT 1
96421: PPUSH
96422: CALL_OW 453
96426: GO 96396
96428: POP
96429: POP
// end ;
96430: LD_VAR 0 2
96434: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96435: LD_INT 0
96437: PPUSH
96438: PPUSH
96439: PPUSH
96440: PPUSH
96441: PPUSH
96442: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96443: LD_VAR 0 1
96447: NOT
96448: PUSH
96449: LD_VAR 0 2
96453: NOT
96454: OR
96455: PUSH
96456: LD_VAR 0 1
96460: PPUSH
96461: CALL_OW 314
96465: OR
96466: IFFALSE 96470
// exit ;
96468: GO 96937
// if GetLives ( i ) < 250 then
96470: LD_VAR 0 4
96474: PPUSH
96475: CALL_OW 256
96479: PUSH
96480: LD_INT 250
96482: LESS
96483: IFFALSE 96496
// begin ComAutodestruct ( i ) ;
96485: LD_VAR 0 4
96489: PPUSH
96490: CALL 96333 0 1
// exit ;
96494: GO 96937
// end ; x := GetX ( enemy_unit ) ;
96496: LD_ADDR_VAR 0 7
96500: PUSH
96501: LD_VAR 0 2
96505: PPUSH
96506: CALL_OW 250
96510: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96511: LD_ADDR_VAR 0 8
96515: PUSH
96516: LD_VAR 0 2
96520: PPUSH
96521: CALL_OW 251
96525: ST_TO_ADDR
// if not x or not y then
96526: LD_VAR 0 7
96530: NOT
96531: PUSH
96532: LD_VAR 0 8
96536: NOT
96537: OR
96538: IFFALSE 96542
// exit ;
96540: GO 96937
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96542: LD_ADDR_VAR 0 6
96546: PUSH
96547: LD_VAR 0 7
96551: PPUSH
96552: LD_INT 0
96554: PPUSH
96555: LD_INT 4
96557: PPUSH
96558: CALL_OW 272
96562: PUSH
96563: LD_VAR 0 8
96567: PPUSH
96568: LD_INT 0
96570: PPUSH
96571: LD_INT 4
96573: PPUSH
96574: CALL_OW 273
96578: PUSH
96579: EMPTY
96580: LIST
96581: LIST
96582: PUSH
96583: LD_VAR 0 7
96587: PPUSH
96588: LD_INT 1
96590: PPUSH
96591: LD_INT 4
96593: PPUSH
96594: CALL_OW 272
96598: PUSH
96599: LD_VAR 0 8
96603: PPUSH
96604: LD_INT 1
96606: PPUSH
96607: LD_INT 4
96609: PPUSH
96610: CALL_OW 273
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: PUSH
96619: LD_VAR 0 7
96623: PPUSH
96624: LD_INT 2
96626: PPUSH
96627: LD_INT 4
96629: PPUSH
96630: CALL_OW 272
96634: PUSH
96635: LD_VAR 0 8
96639: PPUSH
96640: LD_INT 2
96642: PPUSH
96643: LD_INT 4
96645: PPUSH
96646: CALL_OW 273
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_VAR 0 7
96659: PPUSH
96660: LD_INT 3
96662: PPUSH
96663: LD_INT 4
96665: PPUSH
96666: CALL_OW 272
96670: PUSH
96671: LD_VAR 0 8
96675: PPUSH
96676: LD_INT 3
96678: PPUSH
96679: LD_INT 4
96681: PPUSH
96682: CALL_OW 273
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_VAR 0 7
96695: PPUSH
96696: LD_INT 4
96698: PPUSH
96699: LD_INT 4
96701: PPUSH
96702: CALL_OW 272
96706: PUSH
96707: LD_VAR 0 8
96711: PPUSH
96712: LD_INT 4
96714: PPUSH
96715: LD_INT 4
96717: PPUSH
96718: CALL_OW 273
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_VAR 0 7
96731: PPUSH
96732: LD_INT 5
96734: PPUSH
96735: LD_INT 4
96737: PPUSH
96738: CALL_OW 272
96742: PUSH
96743: LD_VAR 0 8
96747: PPUSH
96748: LD_INT 5
96750: PPUSH
96751: LD_INT 4
96753: PPUSH
96754: CALL_OW 273
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: PUSH
96763: EMPTY
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: ST_TO_ADDR
// for i = tmp downto 1 do
96771: LD_ADDR_VAR 0 4
96775: PUSH
96776: DOUBLE
96777: LD_VAR 0 6
96781: INC
96782: ST_TO_ADDR
96783: LD_INT 1
96785: PUSH
96786: FOR_DOWNTO
96787: IFFALSE 96888
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96789: LD_VAR 0 6
96793: PUSH
96794: LD_VAR 0 4
96798: ARRAY
96799: PUSH
96800: LD_INT 1
96802: ARRAY
96803: PPUSH
96804: LD_VAR 0 6
96808: PUSH
96809: LD_VAR 0 4
96813: ARRAY
96814: PUSH
96815: LD_INT 2
96817: ARRAY
96818: PPUSH
96819: CALL_OW 488
96823: NOT
96824: PUSH
96825: LD_VAR 0 6
96829: PUSH
96830: LD_VAR 0 4
96834: ARRAY
96835: PUSH
96836: LD_INT 1
96838: ARRAY
96839: PPUSH
96840: LD_VAR 0 6
96844: PUSH
96845: LD_VAR 0 4
96849: ARRAY
96850: PUSH
96851: LD_INT 2
96853: ARRAY
96854: PPUSH
96855: CALL_OW 428
96859: PUSH
96860: LD_INT 0
96862: NONEQUAL
96863: OR
96864: IFFALSE 96886
// tmp := Delete ( tmp , i ) ;
96866: LD_ADDR_VAR 0 6
96870: PUSH
96871: LD_VAR 0 6
96875: PPUSH
96876: LD_VAR 0 4
96880: PPUSH
96881: CALL_OW 3
96885: ST_TO_ADDR
96886: GO 96786
96888: POP
96889: POP
// j := GetClosestHex ( unit , tmp ) ;
96890: LD_ADDR_VAR 0 5
96894: PUSH
96895: LD_VAR 0 1
96899: PPUSH
96900: LD_VAR 0 6
96904: PPUSH
96905: CALL 96181 0 2
96909: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96910: LD_VAR 0 1
96914: PPUSH
96915: LD_VAR 0 5
96919: PUSH
96920: LD_INT 1
96922: ARRAY
96923: PPUSH
96924: LD_VAR 0 5
96928: PUSH
96929: LD_INT 2
96931: ARRAY
96932: PPUSH
96933: CALL_OW 111
// end ;
96937: LD_VAR 0 3
96941: RET
// export function PrepareApemanSoldier ( ) ; begin
96942: LD_INT 0
96944: PPUSH
// uc_nation := 0 ;
96945: LD_ADDR_OWVAR 21
96949: PUSH
96950: LD_INT 0
96952: ST_TO_ADDR
// hc_sex := sex_male ;
96953: LD_ADDR_OWVAR 27
96957: PUSH
96958: LD_INT 1
96960: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
96961: LD_ADDR_OWVAR 28
96965: PUSH
96966: LD_INT 15
96968: ST_TO_ADDR
// hc_gallery :=  ;
96969: LD_ADDR_OWVAR 33
96973: PUSH
96974: LD_STRING 
96976: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96977: LD_ADDR_OWVAR 31
96981: PUSH
96982: LD_INT 0
96984: PPUSH
96985: LD_INT 3
96987: PPUSH
96988: CALL_OW 12
96992: PUSH
96993: LD_INT 0
96995: PPUSH
96996: LD_INT 3
96998: PPUSH
96999: CALL_OW 12
97003: PUSH
97004: LD_INT 0
97006: PUSH
97007: LD_INT 0
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: ST_TO_ADDR
// end ;
97016: LD_VAR 0 1
97020: RET
// export function PrepareApemanEngineer ( ) ; begin
97021: LD_INT 0
97023: PPUSH
// uc_nation := 0 ;
97024: LD_ADDR_OWVAR 21
97028: PUSH
97029: LD_INT 0
97031: ST_TO_ADDR
// hc_sex := sex_male ;
97032: LD_ADDR_OWVAR 27
97036: PUSH
97037: LD_INT 1
97039: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
97040: LD_ADDR_OWVAR 28
97044: PUSH
97045: LD_INT 16
97047: ST_TO_ADDR
// hc_gallery :=  ;
97048: LD_ADDR_OWVAR 33
97052: PUSH
97053: LD_STRING 
97055: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97056: LD_ADDR_OWVAR 31
97060: PUSH
97061: LD_INT 0
97063: PPUSH
97064: LD_INT 3
97066: PPUSH
97067: CALL_OW 12
97071: PUSH
97072: LD_INT 0
97074: PPUSH
97075: LD_INT 3
97077: PPUSH
97078: CALL_OW 12
97082: PUSH
97083: LD_INT 0
97085: PUSH
97086: LD_INT 0
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: ST_TO_ADDR
// end ;
97095: LD_VAR 0 1
97099: RET
// export function PrepareApeman ( agressivity ) ; begin
97100: LD_INT 0
97102: PPUSH
// uc_side := 0 ;
97103: LD_ADDR_OWVAR 20
97107: PUSH
97108: LD_INT 0
97110: ST_TO_ADDR
// uc_nation := 0 ;
97111: LD_ADDR_OWVAR 21
97115: PUSH
97116: LD_INT 0
97118: ST_TO_ADDR
// hc_sex := sex_male ;
97119: LD_ADDR_OWVAR 27
97123: PUSH
97124: LD_INT 1
97126: ST_TO_ADDR
// hc_class := class_apeman ;
97127: LD_ADDR_OWVAR 28
97131: PUSH
97132: LD_INT 12
97134: ST_TO_ADDR
// hc_gallery :=  ;
97135: LD_ADDR_OWVAR 33
97139: PUSH
97140: LD_STRING 
97142: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97143: LD_ADDR_OWVAR 35
97147: PUSH
97148: LD_VAR 0 1
97152: NEG
97153: PPUSH
97154: LD_VAR 0 1
97158: PPUSH
97159: CALL_OW 12
97163: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97164: LD_ADDR_OWVAR 31
97168: PUSH
97169: LD_INT 0
97171: PPUSH
97172: LD_INT 3
97174: PPUSH
97175: CALL_OW 12
97179: PUSH
97180: LD_INT 0
97182: PPUSH
97183: LD_INT 3
97185: PPUSH
97186: CALL_OW 12
97190: PUSH
97191: LD_INT 0
97193: PUSH
97194: LD_INT 0
97196: PUSH
97197: EMPTY
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: ST_TO_ADDR
// end ;
97203: LD_VAR 0 2
97207: RET
// export function PrepareTiger ( agressivity ) ; begin
97208: LD_INT 0
97210: PPUSH
// uc_side := 0 ;
97211: LD_ADDR_OWVAR 20
97215: PUSH
97216: LD_INT 0
97218: ST_TO_ADDR
// uc_nation := 0 ;
97219: LD_ADDR_OWVAR 21
97223: PUSH
97224: LD_INT 0
97226: ST_TO_ADDR
// hc_class := class_tiger ;
97227: LD_ADDR_OWVAR 28
97231: PUSH
97232: LD_INT 14
97234: ST_TO_ADDR
// hc_gallery :=  ;
97235: LD_ADDR_OWVAR 33
97239: PUSH
97240: LD_STRING 
97242: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97243: LD_ADDR_OWVAR 35
97247: PUSH
97248: LD_VAR 0 1
97252: NEG
97253: PPUSH
97254: LD_VAR 0 1
97258: PPUSH
97259: CALL_OW 12
97263: ST_TO_ADDR
// end ;
97264: LD_VAR 0 2
97268: RET
// export function PrepareEnchidna ( ) ; begin
97269: LD_INT 0
97271: PPUSH
// uc_side := 0 ;
97272: LD_ADDR_OWVAR 20
97276: PUSH
97277: LD_INT 0
97279: ST_TO_ADDR
// uc_nation := 0 ;
97280: LD_ADDR_OWVAR 21
97284: PUSH
97285: LD_INT 0
97287: ST_TO_ADDR
// hc_class := class_baggie ;
97288: LD_ADDR_OWVAR 28
97292: PUSH
97293: LD_INT 13
97295: ST_TO_ADDR
// hc_gallery :=  ;
97296: LD_ADDR_OWVAR 33
97300: PUSH
97301: LD_STRING 
97303: ST_TO_ADDR
// end ;
97304: LD_VAR 0 1
97308: RET
// export function PrepareFrog ( ) ; begin
97309: LD_INT 0
97311: PPUSH
// uc_side := 0 ;
97312: LD_ADDR_OWVAR 20
97316: PUSH
97317: LD_INT 0
97319: ST_TO_ADDR
// uc_nation := 0 ;
97320: LD_ADDR_OWVAR 21
97324: PUSH
97325: LD_INT 0
97327: ST_TO_ADDR
// hc_class := class_frog ;
97328: LD_ADDR_OWVAR 28
97332: PUSH
97333: LD_INT 19
97335: ST_TO_ADDR
// hc_gallery :=  ;
97336: LD_ADDR_OWVAR 33
97340: PUSH
97341: LD_STRING 
97343: ST_TO_ADDR
// end ;
97344: LD_VAR 0 1
97348: RET
// export function PrepareFish ( ) ; begin
97349: LD_INT 0
97351: PPUSH
// uc_side := 0 ;
97352: LD_ADDR_OWVAR 20
97356: PUSH
97357: LD_INT 0
97359: ST_TO_ADDR
// uc_nation := 0 ;
97360: LD_ADDR_OWVAR 21
97364: PUSH
97365: LD_INT 0
97367: ST_TO_ADDR
// hc_class := class_fish ;
97368: LD_ADDR_OWVAR 28
97372: PUSH
97373: LD_INT 20
97375: ST_TO_ADDR
// hc_gallery :=  ;
97376: LD_ADDR_OWVAR 33
97380: PUSH
97381: LD_STRING 
97383: ST_TO_ADDR
// end ;
97384: LD_VAR 0 1
97388: RET
// export function PrepareBird ( ) ; begin
97389: LD_INT 0
97391: PPUSH
// uc_side := 0 ;
97392: LD_ADDR_OWVAR 20
97396: PUSH
97397: LD_INT 0
97399: ST_TO_ADDR
// uc_nation := 0 ;
97400: LD_ADDR_OWVAR 21
97404: PUSH
97405: LD_INT 0
97407: ST_TO_ADDR
// hc_class := class_phororhacos ;
97408: LD_ADDR_OWVAR 28
97412: PUSH
97413: LD_INT 18
97415: ST_TO_ADDR
// hc_gallery :=  ;
97416: LD_ADDR_OWVAR 33
97420: PUSH
97421: LD_STRING 
97423: ST_TO_ADDR
// end ;
97424: LD_VAR 0 1
97428: RET
// export function PrepareHorse ( ) ; begin
97429: LD_INT 0
97431: PPUSH
// uc_side := 0 ;
97432: LD_ADDR_OWVAR 20
97436: PUSH
97437: LD_INT 0
97439: ST_TO_ADDR
// uc_nation := 0 ;
97440: LD_ADDR_OWVAR 21
97444: PUSH
97445: LD_INT 0
97447: ST_TO_ADDR
// hc_class := class_horse ;
97448: LD_ADDR_OWVAR 28
97452: PUSH
97453: LD_INT 21
97455: ST_TO_ADDR
// hc_gallery :=  ;
97456: LD_ADDR_OWVAR 33
97460: PUSH
97461: LD_STRING 
97463: ST_TO_ADDR
// end ;
97464: LD_VAR 0 1
97468: RET
// export function PrepareMastodont ( ) ; begin
97469: LD_INT 0
97471: PPUSH
// uc_side := 0 ;
97472: LD_ADDR_OWVAR 20
97476: PUSH
97477: LD_INT 0
97479: ST_TO_ADDR
// uc_nation := 0 ;
97480: LD_ADDR_OWVAR 21
97484: PUSH
97485: LD_INT 0
97487: ST_TO_ADDR
// vc_chassis := class_mastodont ;
97488: LD_ADDR_OWVAR 37
97492: PUSH
97493: LD_INT 31
97495: ST_TO_ADDR
// vc_control := control_rider ;
97496: LD_ADDR_OWVAR 38
97500: PUSH
97501: LD_INT 4
97503: ST_TO_ADDR
// end ;
97504: LD_VAR 0 1
97508: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97509: LD_INT 0
97511: PPUSH
97512: PPUSH
97513: PPUSH
// uc_side = 0 ;
97514: LD_ADDR_OWVAR 20
97518: PUSH
97519: LD_INT 0
97521: ST_TO_ADDR
// uc_nation = 0 ;
97522: LD_ADDR_OWVAR 21
97526: PUSH
97527: LD_INT 0
97529: ST_TO_ADDR
// InitHc_All ( ) ;
97530: CALL_OW 584
// InitVc ;
97534: CALL_OW 20
// if mastodonts then
97538: LD_VAR 0 6
97542: IFFALSE 97609
// for i = 1 to mastodonts do
97544: LD_ADDR_VAR 0 11
97548: PUSH
97549: DOUBLE
97550: LD_INT 1
97552: DEC
97553: ST_TO_ADDR
97554: LD_VAR 0 6
97558: PUSH
97559: FOR_TO
97560: IFFALSE 97607
// begin vc_chassis := 31 ;
97562: LD_ADDR_OWVAR 37
97566: PUSH
97567: LD_INT 31
97569: ST_TO_ADDR
// vc_control := control_rider ;
97570: LD_ADDR_OWVAR 38
97574: PUSH
97575: LD_INT 4
97577: ST_TO_ADDR
// animal := CreateVehicle ;
97578: LD_ADDR_VAR 0 12
97582: PUSH
97583: CALL_OW 45
97587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97588: LD_VAR 0 12
97592: PPUSH
97593: LD_VAR 0 8
97597: PPUSH
97598: LD_INT 0
97600: PPUSH
97601: CALL 99737 0 3
// end ;
97605: GO 97559
97607: POP
97608: POP
// if horses then
97609: LD_VAR 0 5
97613: IFFALSE 97680
// for i = 1 to horses do
97615: LD_ADDR_VAR 0 11
97619: PUSH
97620: DOUBLE
97621: LD_INT 1
97623: DEC
97624: ST_TO_ADDR
97625: LD_VAR 0 5
97629: PUSH
97630: FOR_TO
97631: IFFALSE 97678
// begin hc_class := 21 ;
97633: LD_ADDR_OWVAR 28
97637: PUSH
97638: LD_INT 21
97640: ST_TO_ADDR
// hc_gallery :=  ;
97641: LD_ADDR_OWVAR 33
97645: PUSH
97646: LD_STRING 
97648: ST_TO_ADDR
// animal := CreateHuman ;
97649: LD_ADDR_VAR 0 12
97653: PUSH
97654: CALL_OW 44
97658: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97659: LD_VAR 0 12
97663: PPUSH
97664: LD_VAR 0 8
97668: PPUSH
97669: LD_INT 0
97671: PPUSH
97672: CALL 99737 0 3
// end ;
97676: GO 97630
97678: POP
97679: POP
// if birds then
97680: LD_VAR 0 1
97684: IFFALSE 97751
// for i = 1 to birds do
97686: LD_ADDR_VAR 0 11
97690: PUSH
97691: DOUBLE
97692: LD_INT 1
97694: DEC
97695: ST_TO_ADDR
97696: LD_VAR 0 1
97700: PUSH
97701: FOR_TO
97702: IFFALSE 97749
// begin hc_class = 18 ;
97704: LD_ADDR_OWVAR 28
97708: PUSH
97709: LD_INT 18
97711: ST_TO_ADDR
// hc_gallery =  ;
97712: LD_ADDR_OWVAR 33
97716: PUSH
97717: LD_STRING 
97719: ST_TO_ADDR
// animal := CreateHuman ;
97720: LD_ADDR_VAR 0 12
97724: PUSH
97725: CALL_OW 44
97729: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97730: LD_VAR 0 12
97734: PPUSH
97735: LD_VAR 0 8
97739: PPUSH
97740: LD_INT 0
97742: PPUSH
97743: CALL 99737 0 3
// end ;
97747: GO 97701
97749: POP
97750: POP
// if tigers then
97751: LD_VAR 0 2
97755: IFFALSE 97839
// for i = 1 to tigers do
97757: LD_ADDR_VAR 0 11
97761: PUSH
97762: DOUBLE
97763: LD_INT 1
97765: DEC
97766: ST_TO_ADDR
97767: LD_VAR 0 2
97771: PUSH
97772: FOR_TO
97773: IFFALSE 97837
// begin hc_class = class_tiger ;
97775: LD_ADDR_OWVAR 28
97779: PUSH
97780: LD_INT 14
97782: ST_TO_ADDR
// hc_gallery =  ;
97783: LD_ADDR_OWVAR 33
97787: PUSH
97788: LD_STRING 
97790: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97791: LD_ADDR_OWVAR 35
97795: PUSH
97796: LD_INT 7
97798: NEG
97799: PPUSH
97800: LD_INT 7
97802: PPUSH
97803: CALL_OW 12
97807: ST_TO_ADDR
// animal := CreateHuman ;
97808: LD_ADDR_VAR 0 12
97812: PUSH
97813: CALL_OW 44
97817: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97818: LD_VAR 0 12
97822: PPUSH
97823: LD_VAR 0 8
97827: PPUSH
97828: LD_INT 0
97830: PPUSH
97831: CALL 99737 0 3
// end ;
97835: GO 97772
97837: POP
97838: POP
// if apemans then
97839: LD_VAR 0 3
97843: IFFALSE 97966
// for i = 1 to apemans do
97845: LD_ADDR_VAR 0 11
97849: PUSH
97850: DOUBLE
97851: LD_INT 1
97853: DEC
97854: ST_TO_ADDR
97855: LD_VAR 0 3
97859: PUSH
97860: FOR_TO
97861: IFFALSE 97964
// begin hc_class = class_apeman ;
97863: LD_ADDR_OWVAR 28
97867: PUSH
97868: LD_INT 12
97870: ST_TO_ADDR
// hc_gallery =  ;
97871: LD_ADDR_OWVAR 33
97875: PUSH
97876: LD_STRING 
97878: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
97879: LD_ADDR_OWVAR 35
97883: PUSH
97884: LD_INT 2
97886: NEG
97887: PPUSH
97888: LD_INT 2
97890: PPUSH
97891: CALL_OW 12
97895: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97896: LD_ADDR_OWVAR 31
97900: PUSH
97901: LD_INT 1
97903: PPUSH
97904: LD_INT 3
97906: PPUSH
97907: CALL_OW 12
97911: PUSH
97912: LD_INT 1
97914: PPUSH
97915: LD_INT 3
97917: PPUSH
97918: CALL_OW 12
97922: PUSH
97923: LD_INT 0
97925: PUSH
97926: LD_INT 0
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: ST_TO_ADDR
// animal := CreateHuman ;
97935: LD_ADDR_VAR 0 12
97939: PUSH
97940: CALL_OW 44
97944: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97945: LD_VAR 0 12
97949: PPUSH
97950: LD_VAR 0 8
97954: PPUSH
97955: LD_INT 0
97957: PPUSH
97958: CALL 99737 0 3
// end ;
97962: GO 97860
97964: POP
97965: POP
// if enchidnas then
97966: LD_VAR 0 4
97970: IFFALSE 98037
// for i = 1 to enchidnas do
97972: LD_ADDR_VAR 0 11
97976: PUSH
97977: DOUBLE
97978: LD_INT 1
97980: DEC
97981: ST_TO_ADDR
97982: LD_VAR 0 4
97986: PUSH
97987: FOR_TO
97988: IFFALSE 98035
// begin hc_class = 13 ;
97990: LD_ADDR_OWVAR 28
97994: PUSH
97995: LD_INT 13
97997: ST_TO_ADDR
// hc_gallery =  ;
97998: LD_ADDR_OWVAR 33
98002: PUSH
98003: LD_STRING 
98005: ST_TO_ADDR
// animal := CreateHuman ;
98006: LD_ADDR_VAR 0 12
98010: PUSH
98011: CALL_OW 44
98015: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98016: LD_VAR 0 12
98020: PPUSH
98021: LD_VAR 0 8
98025: PPUSH
98026: LD_INT 0
98028: PPUSH
98029: CALL 99737 0 3
// end ;
98033: GO 97987
98035: POP
98036: POP
// if fishes then
98037: LD_VAR 0 7
98041: IFFALSE 98108
// for i = 1 to fishes do
98043: LD_ADDR_VAR 0 11
98047: PUSH
98048: DOUBLE
98049: LD_INT 1
98051: DEC
98052: ST_TO_ADDR
98053: LD_VAR 0 7
98057: PUSH
98058: FOR_TO
98059: IFFALSE 98106
// begin hc_class = 20 ;
98061: LD_ADDR_OWVAR 28
98065: PUSH
98066: LD_INT 20
98068: ST_TO_ADDR
// hc_gallery =  ;
98069: LD_ADDR_OWVAR 33
98073: PUSH
98074: LD_STRING 
98076: ST_TO_ADDR
// animal := CreateHuman ;
98077: LD_ADDR_VAR 0 12
98081: PUSH
98082: CALL_OW 44
98086: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98087: LD_VAR 0 12
98091: PPUSH
98092: LD_VAR 0 9
98096: PPUSH
98097: LD_INT 0
98099: PPUSH
98100: CALL 99737 0 3
// end ;
98104: GO 98058
98106: POP
98107: POP
// end ;
98108: LD_VAR 0 10
98112: RET
// export function WantHeal ( sci , unit ) ; begin
98113: LD_INT 0
98115: PPUSH
// if GetTaskList ( sci ) > 0 then
98116: LD_VAR 0 1
98120: PPUSH
98121: CALL_OW 437
98125: PUSH
98126: LD_INT 0
98128: GREATER
98129: IFFALSE 98199
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98131: LD_VAR 0 1
98135: PPUSH
98136: CALL_OW 437
98140: PUSH
98141: LD_INT 1
98143: ARRAY
98144: PUSH
98145: LD_INT 1
98147: ARRAY
98148: PUSH
98149: LD_STRING l
98151: EQUAL
98152: PUSH
98153: LD_VAR 0 1
98157: PPUSH
98158: CALL_OW 437
98162: PUSH
98163: LD_INT 1
98165: ARRAY
98166: PUSH
98167: LD_INT 4
98169: ARRAY
98170: PUSH
98171: LD_VAR 0 2
98175: EQUAL
98176: AND
98177: IFFALSE 98189
// result := true else
98179: LD_ADDR_VAR 0 3
98183: PUSH
98184: LD_INT 1
98186: ST_TO_ADDR
98187: GO 98197
// result := false ;
98189: LD_ADDR_VAR 0 3
98193: PUSH
98194: LD_INT 0
98196: ST_TO_ADDR
// end else
98197: GO 98207
// result := false ;
98199: LD_ADDR_VAR 0 3
98203: PUSH
98204: LD_INT 0
98206: ST_TO_ADDR
// end ;
98207: LD_VAR 0 3
98211: RET
// export function HealTarget ( sci ) ; begin
98212: LD_INT 0
98214: PPUSH
// if not sci then
98215: LD_VAR 0 1
98219: NOT
98220: IFFALSE 98224
// exit ;
98222: GO 98289
// result := 0 ;
98224: LD_ADDR_VAR 0 2
98228: PUSH
98229: LD_INT 0
98231: ST_TO_ADDR
// if GetTaskList ( sci ) then
98232: LD_VAR 0 1
98236: PPUSH
98237: CALL_OW 437
98241: IFFALSE 98289
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98243: LD_VAR 0 1
98247: PPUSH
98248: CALL_OW 437
98252: PUSH
98253: LD_INT 1
98255: ARRAY
98256: PUSH
98257: LD_INT 1
98259: ARRAY
98260: PUSH
98261: LD_STRING l
98263: EQUAL
98264: IFFALSE 98289
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98266: LD_ADDR_VAR 0 2
98270: PUSH
98271: LD_VAR 0 1
98275: PPUSH
98276: CALL_OW 437
98280: PUSH
98281: LD_INT 1
98283: ARRAY
98284: PUSH
98285: LD_INT 4
98287: ARRAY
98288: ST_TO_ADDR
// end ;
98289: LD_VAR 0 2
98293: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98294: LD_INT 0
98296: PPUSH
98297: PPUSH
98298: PPUSH
98299: PPUSH
// if not base_units then
98300: LD_VAR 0 1
98304: NOT
98305: IFFALSE 98309
// exit ;
98307: GO 98396
// result := false ;
98309: LD_ADDR_VAR 0 2
98313: PUSH
98314: LD_INT 0
98316: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98317: LD_ADDR_VAR 0 5
98321: PUSH
98322: LD_VAR 0 1
98326: PPUSH
98327: LD_INT 21
98329: PUSH
98330: LD_INT 3
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: PPUSH
98337: CALL_OW 72
98341: ST_TO_ADDR
// if not tmp then
98342: LD_VAR 0 5
98346: NOT
98347: IFFALSE 98351
// exit ;
98349: GO 98396
// for i in tmp do
98351: LD_ADDR_VAR 0 3
98355: PUSH
98356: LD_VAR 0 5
98360: PUSH
98361: FOR_IN
98362: IFFALSE 98394
// begin result := EnemyInRange ( i , 22 ) ;
98364: LD_ADDR_VAR 0 2
98368: PUSH
98369: LD_VAR 0 3
98373: PPUSH
98374: LD_INT 22
98376: PPUSH
98377: CALL 95983 0 2
98381: ST_TO_ADDR
// if result then
98382: LD_VAR 0 2
98386: IFFALSE 98392
// exit ;
98388: POP
98389: POP
98390: GO 98396
// end ;
98392: GO 98361
98394: POP
98395: POP
// end ;
98396: LD_VAR 0 2
98400: RET
// export function FilterByTag ( units , tag ) ; begin
98401: LD_INT 0
98403: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
98404: LD_ADDR_VAR 0 3
98408: PUSH
98409: LD_VAR 0 1
98413: PPUSH
98414: LD_INT 120
98416: PUSH
98417: LD_VAR 0 2
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: PPUSH
98426: CALL_OW 72
98430: ST_TO_ADDR
// end ;
98431: LD_VAR 0 3
98435: RET
// export function IsDriver ( un ) ; begin
98436: LD_INT 0
98438: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98439: LD_ADDR_VAR 0 2
98443: PUSH
98444: LD_VAR 0 1
98448: PUSH
98449: LD_INT 55
98451: PUSH
98452: EMPTY
98453: LIST
98454: PPUSH
98455: CALL_OW 69
98459: IN
98460: ST_TO_ADDR
// end ;
98461: LD_VAR 0 2
98465: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98466: LD_INT 0
98468: PPUSH
98469: PPUSH
// list := [ ] ;
98470: LD_ADDR_VAR 0 5
98474: PUSH
98475: EMPTY
98476: ST_TO_ADDR
// case d of 0 :
98477: LD_VAR 0 3
98481: PUSH
98482: LD_INT 0
98484: DOUBLE
98485: EQUAL
98486: IFTRUE 98490
98488: GO 98623
98490: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98491: LD_ADDR_VAR 0 5
98495: PUSH
98496: LD_VAR 0 1
98500: PUSH
98501: LD_INT 4
98503: MINUS
98504: PUSH
98505: LD_VAR 0 2
98509: PUSH
98510: LD_INT 4
98512: MINUS
98513: PUSH
98514: LD_INT 2
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: LIST
98521: PUSH
98522: LD_VAR 0 1
98526: PUSH
98527: LD_INT 3
98529: MINUS
98530: PUSH
98531: LD_VAR 0 2
98535: PUSH
98536: LD_INT 1
98538: PUSH
98539: EMPTY
98540: LIST
98541: LIST
98542: LIST
98543: PUSH
98544: LD_VAR 0 1
98548: PUSH
98549: LD_INT 4
98551: PLUS
98552: PUSH
98553: LD_VAR 0 2
98557: PUSH
98558: LD_INT 4
98560: PUSH
98561: EMPTY
98562: LIST
98563: LIST
98564: LIST
98565: PUSH
98566: LD_VAR 0 1
98570: PUSH
98571: LD_INT 3
98573: PLUS
98574: PUSH
98575: LD_VAR 0 2
98579: PUSH
98580: LD_INT 3
98582: PLUS
98583: PUSH
98584: LD_INT 5
98586: PUSH
98587: EMPTY
98588: LIST
98589: LIST
98590: LIST
98591: PUSH
98592: LD_VAR 0 1
98596: PUSH
98597: LD_VAR 0 2
98601: PUSH
98602: LD_INT 4
98604: PLUS
98605: PUSH
98606: LD_INT 0
98608: PUSH
98609: EMPTY
98610: LIST
98611: LIST
98612: LIST
98613: PUSH
98614: EMPTY
98615: LIST
98616: LIST
98617: LIST
98618: LIST
98619: LIST
98620: ST_TO_ADDR
// end ; 1 :
98621: GO 99321
98623: LD_INT 1
98625: DOUBLE
98626: EQUAL
98627: IFTRUE 98631
98629: GO 98764
98631: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98632: LD_ADDR_VAR 0 5
98636: PUSH
98637: LD_VAR 0 1
98641: PUSH
98642: LD_VAR 0 2
98646: PUSH
98647: LD_INT 4
98649: MINUS
98650: PUSH
98651: LD_INT 3
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: LIST
98658: PUSH
98659: LD_VAR 0 1
98663: PUSH
98664: LD_INT 3
98666: MINUS
98667: PUSH
98668: LD_VAR 0 2
98672: PUSH
98673: LD_INT 3
98675: MINUS
98676: PUSH
98677: LD_INT 2
98679: PUSH
98680: EMPTY
98681: LIST
98682: LIST
98683: LIST
98684: PUSH
98685: LD_VAR 0 1
98689: PUSH
98690: LD_INT 4
98692: MINUS
98693: PUSH
98694: LD_VAR 0 2
98698: PUSH
98699: LD_INT 1
98701: PUSH
98702: EMPTY
98703: LIST
98704: LIST
98705: LIST
98706: PUSH
98707: LD_VAR 0 1
98711: PUSH
98712: LD_VAR 0 2
98716: PUSH
98717: LD_INT 3
98719: PLUS
98720: PUSH
98721: LD_INT 0
98723: PUSH
98724: EMPTY
98725: LIST
98726: LIST
98727: LIST
98728: PUSH
98729: LD_VAR 0 1
98733: PUSH
98734: LD_INT 4
98736: PLUS
98737: PUSH
98738: LD_VAR 0 2
98742: PUSH
98743: LD_INT 4
98745: PLUS
98746: PUSH
98747: LD_INT 5
98749: PUSH
98750: EMPTY
98751: LIST
98752: LIST
98753: LIST
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: ST_TO_ADDR
// end ; 2 :
98762: GO 99321
98764: LD_INT 2
98766: DOUBLE
98767: EQUAL
98768: IFTRUE 98772
98770: GO 98901
98772: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98773: LD_ADDR_VAR 0 5
98777: PUSH
98778: LD_VAR 0 1
98782: PUSH
98783: LD_VAR 0 2
98787: PUSH
98788: LD_INT 3
98790: MINUS
98791: PUSH
98792: LD_INT 3
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: LIST
98799: PUSH
98800: LD_VAR 0 1
98804: PUSH
98805: LD_INT 4
98807: PLUS
98808: PUSH
98809: LD_VAR 0 2
98813: PUSH
98814: LD_INT 4
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: LIST
98821: PUSH
98822: LD_VAR 0 1
98826: PUSH
98827: LD_VAR 0 2
98831: PUSH
98832: LD_INT 4
98834: PLUS
98835: PUSH
98836: LD_INT 0
98838: PUSH
98839: EMPTY
98840: LIST
98841: LIST
98842: LIST
98843: PUSH
98844: LD_VAR 0 1
98848: PUSH
98849: LD_INT 3
98851: MINUS
98852: PUSH
98853: LD_VAR 0 2
98857: PUSH
98858: LD_INT 1
98860: PUSH
98861: EMPTY
98862: LIST
98863: LIST
98864: LIST
98865: PUSH
98866: LD_VAR 0 1
98870: PUSH
98871: LD_INT 4
98873: MINUS
98874: PUSH
98875: LD_VAR 0 2
98879: PUSH
98880: LD_INT 4
98882: MINUS
98883: PUSH
98884: LD_INT 2
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: LIST
98891: PUSH
98892: EMPTY
98893: LIST
98894: LIST
98895: LIST
98896: LIST
98897: LIST
98898: ST_TO_ADDR
// end ; 3 :
98899: GO 99321
98901: LD_INT 3
98903: DOUBLE
98904: EQUAL
98905: IFTRUE 98909
98907: GO 99042
98909: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
98910: LD_ADDR_VAR 0 5
98914: PUSH
98915: LD_VAR 0 1
98919: PUSH
98920: LD_INT 3
98922: PLUS
98923: PUSH
98924: LD_VAR 0 2
98928: PUSH
98929: LD_INT 4
98931: PUSH
98932: EMPTY
98933: LIST
98934: LIST
98935: LIST
98936: PUSH
98937: LD_VAR 0 1
98941: PUSH
98942: LD_INT 4
98944: PLUS
98945: PUSH
98946: LD_VAR 0 2
98950: PUSH
98951: LD_INT 4
98953: PLUS
98954: PUSH
98955: LD_INT 5
98957: PUSH
98958: EMPTY
98959: LIST
98960: LIST
98961: LIST
98962: PUSH
98963: LD_VAR 0 1
98967: PUSH
98968: LD_INT 4
98970: MINUS
98971: PUSH
98972: LD_VAR 0 2
98976: PUSH
98977: LD_INT 1
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: LIST
98984: PUSH
98985: LD_VAR 0 1
98989: PUSH
98990: LD_VAR 0 2
98994: PUSH
98995: LD_INT 4
98997: MINUS
98998: PUSH
98999: LD_INT 3
99001: PUSH
99002: EMPTY
99003: LIST
99004: LIST
99005: LIST
99006: PUSH
99007: LD_VAR 0 1
99011: PUSH
99012: LD_INT 3
99014: MINUS
99015: PUSH
99016: LD_VAR 0 2
99020: PUSH
99021: LD_INT 3
99023: MINUS
99024: PUSH
99025: LD_INT 2
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: LIST
99032: PUSH
99033: EMPTY
99034: LIST
99035: LIST
99036: LIST
99037: LIST
99038: LIST
99039: ST_TO_ADDR
// end ; 4 :
99040: GO 99321
99042: LD_INT 4
99044: DOUBLE
99045: EQUAL
99046: IFTRUE 99050
99048: GO 99183
99050: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99051: LD_ADDR_VAR 0 5
99055: PUSH
99056: LD_VAR 0 1
99060: PUSH
99061: LD_VAR 0 2
99065: PUSH
99066: LD_INT 4
99068: PLUS
99069: PUSH
99070: LD_INT 0
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: LIST
99077: PUSH
99078: LD_VAR 0 1
99082: PUSH
99083: LD_INT 3
99085: PLUS
99086: PUSH
99087: LD_VAR 0 2
99091: PUSH
99092: LD_INT 3
99094: PLUS
99095: PUSH
99096: LD_INT 5
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: LIST
99103: PUSH
99104: LD_VAR 0 1
99108: PUSH
99109: LD_INT 4
99111: PLUS
99112: PUSH
99113: LD_VAR 0 2
99117: PUSH
99118: LD_INT 4
99120: PUSH
99121: EMPTY
99122: LIST
99123: LIST
99124: LIST
99125: PUSH
99126: LD_VAR 0 1
99130: PUSH
99131: LD_VAR 0 2
99135: PUSH
99136: LD_INT 3
99138: MINUS
99139: PUSH
99140: LD_INT 3
99142: PUSH
99143: EMPTY
99144: LIST
99145: LIST
99146: LIST
99147: PUSH
99148: LD_VAR 0 1
99152: PUSH
99153: LD_INT 4
99155: MINUS
99156: PUSH
99157: LD_VAR 0 2
99161: PUSH
99162: LD_INT 4
99164: MINUS
99165: PUSH
99166: LD_INT 2
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: ST_TO_ADDR
// end ; 5 :
99181: GO 99321
99183: LD_INT 5
99185: DOUBLE
99186: EQUAL
99187: IFTRUE 99191
99189: GO 99320
99191: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99192: LD_ADDR_VAR 0 5
99196: PUSH
99197: LD_VAR 0 1
99201: PUSH
99202: LD_INT 4
99204: MINUS
99205: PUSH
99206: LD_VAR 0 2
99210: PUSH
99211: LD_INT 1
99213: PUSH
99214: EMPTY
99215: LIST
99216: LIST
99217: LIST
99218: PUSH
99219: LD_VAR 0 1
99223: PUSH
99224: LD_VAR 0 2
99228: PUSH
99229: LD_INT 4
99231: MINUS
99232: PUSH
99233: LD_INT 3
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: LIST
99240: PUSH
99241: LD_VAR 0 1
99245: PUSH
99246: LD_INT 4
99248: PLUS
99249: PUSH
99250: LD_VAR 0 2
99254: PUSH
99255: LD_INT 4
99257: PLUS
99258: PUSH
99259: LD_INT 5
99261: PUSH
99262: EMPTY
99263: LIST
99264: LIST
99265: LIST
99266: PUSH
99267: LD_VAR 0 1
99271: PUSH
99272: LD_INT 3
99274: PLUS
99275: PUSH
99276: LD_VAR 0 2
99280: PUSH
99281: LD_INT 4
99283: PUSH
99284: EMPTY
99285: LIST
99286: LIST
99287: LIST
99288: PUSH
99289: LD_VAR 0 1
99293: PUSH
99294: LD_VAR 0 2
99298: PUSH
99299: LD_INT 3
99301: PLUS
99302: PUSH
99303: LD_INT 0
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: LIST
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: ST_TO_ADDR
// end ; end ;
99318: GO 99321
99320: POP
// result := list ;
99321: LD_ADDR_VAR 0 4
99325: PUSH
99326: LD_VAR 0 5
99330: ST_TO_ADDR
// end ;
99331: LD_VAR 0 4
99335: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99336: LD_INT 0
99338: PPUSH
99339: PPUSH
99340: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99341: LD_VAR 0 1
99345: NOT
99346: PUSH
99347: LD_VAR 0 2
99351: PUSH
99352: LD_INT 1
99354: PUSH
99355: LD_INT 2
99357: PUSH
99358: LD_INT 3
99360: PUSH
99361: LD_INT 4
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: IN
99370: NOT
99371: OR
99372: IFFALSE 99376
// exit ;
99374: GO 99459
// tmp := [ ] ;
99376: LD_ADDR_VAR 0 5
99380: PUSH
99381: EMPTY
99382: ST_TO_ADDR
// for i in units do
99383: LD_ADDR_VAR 0 4
99387: PUSH
99388: LD_VAR 0 1
99392: PUSH
99393: FOR_IN
99394: IFFALSE 99428
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
99396: LD_ADDR_VAR 0 5
99400: PUSH
99401: LD_VAR 0 5
99405: PPUSH
99406: LD_VAR 0 4
99410: PPUSH
99411: LD_VAR 0 2
99415: PPUSH
99416: CALL_OW 259
99420: PPUSH
99421: CALL 100820 0 2
99425: ST_TO_ADDR
99426: GO 99393
99428: POP
99429: POP
// if not tmp then
99430: LD_VAR 0 5
99434: NOT
99435: IFFALSE 99439
// exit ;
99437: GO 99459
// result := SortListByListDesc ( units , tmp ) ;
99439: LD_ADDR_VAR 0 3
99443: PUSH
99444: LD_VAR 0 1
99448: PPUSH
99449: LD_VAR 0 5
99453: PPUSH
99454: CALL_OW 77
99458: ST_TO_ADDR
// end ;
99459: LD_VAR 0 3
99463: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99464: LD_INT 0
99466: PPUSH
99467: PPUSH
99468: PPUSH
// result := false ;
99469: LD_ADDR_VAR 0 3
99473: PUSH
99474: LD_INT 0
99476: ST_TO_ADDR
// if not building then
99477: LD_VAR 0 2
99481: NOT
99482: IFFALSE 99486
// exit ;
99484: GO 99624
// x := GetX ( building ) ;
99486: LD_ADDR_VAR 0 4
99490: PUSH
99491: LD_VAR 0 2
99495: PPUSH
99496: CALL_OW 250
99500: ST_TO_ADDR
// y := GetY ( building ) ;
99501: LD_ADDR_VAR 0 5
99505: PUSH
99506: LD_VAR 0 2
99510: PPUSH
99511: CALL_OW 251
99515: ST_TO_ADDR
// if not x or not y then
99516: LD_VAR 0 4
99520: NOT
99521: PUSH
99522: LD_VAR 0 5
99526: NOT
99527: OR
99528: IFFALSE 99532
// exit ;
99530: GO 99624
// if GetTaskList ( unit ) then
99532: LD_VAR 0 1
99536: PPUSH
99537: CALL_OW 437
99541: IFFALSE 99624
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99543: LD_STRING e
99545: PUSH
99546: LD_VAR 0 1
99550: PPUSH
99551: CALL_OW 437
99555: PUSH
99556: LD_INT 1
99558: ARRAY
99559: PUSH
99560: LD_INT 1
99562: ARRAY
99563: EQUAL
99564: PUSH
99565: LD_VAR 0 4
99569: PUSH
99570: LD_VAR 0 1
99574: PPUSH
99575: CALL_OW 437
99579: PUSH
99580: LD_INT 1
99582: ARRAY
99583: PUSH
99584: LD_INT 2
99586: ARRAY
99587: EQUAL
99588: AND
99589: PUSH
99590: LD_VAR 0 5
99594: PUSH
99595: LD_VAR 0 1
99599: PPUSH
99600: CALL_OW 437
99604: PUSH
99605: LD_INT 1
99607: ARRAY
99608: PUSH
99609: LD_INT 3
99611: ARRAY
99612: EQUAL
99613: AND
99614: IFFALSE 99624
// result := true end ;
99616: LD_ADDR_VAR 0 3
99620: PUSH
99621: LD_INT 1
99623: ST_TO_ADDR
// end ;
99624: LD_VAR 0 3
99628: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99629: LD_INT 0
99631: PPUSH
// result := false ;
99632: LD_ADDR_VAR 0 4
99636: PUSH
99637: LD_INT 0
99639: ST_TO_ADDR
// if GetTaskList ( unit ) then
99640: LD_VAR 0 1
99644: PPUSH
99645: CALL_OW 437
99649: IFFALSE 99732
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99651: LD_STRING M
99653: PUSH
99654: LD_VAR 0 1
99658: PPUSH
99659: CALL_OW 437
99663: PUSH
99664: LD_INT 1
99666: ARRAY
99667: PUSH
99668: LD_INT 1
99670: ARRAY
99671: EQUAL
99672: PUSH
99673: LD_VAR 0 2
99677: PUSH
99678: LD_VAR 0 1
99682: PPUSH
99683: CALL_OW 437
99687: PUSH
99688: LD_INT 1
99690: ARRAY
99691: PUSH
99692: LD_INT 2
99694: ARRAY
99695: EQUAL
99696: AND
99697: PUSH
99698: LD_VAR 0 3
99702: PUSH
99703: LD_VAR 0 1
99707: PPUSH
99708: CALL_OW 437
99712: PUSH
99713: LD_INT 1
99715: ARRAY
99716: PUSH
99717: LD_INT 3
99719: ARRAY
99720: EQUAL
99721: AND
99722: IFFALSE 99732
// result := true ;
99724: LD_ADDR_VAR 0 4
99728: PUSH
99729: LD_INT 1
99731: ST_TO_ADDR
// end ; end ;
99732: LD_VAR 0 4
99736: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99737: LD_INT 0
99739: PPUSH
99740: PPUSH
99741: PPUSH
99742: PPUSH
// if not unit or not area then
99743: LD_VAR 0 1
99747: NOT
99748: PUSH
99749: LD_VAR 0 2
99753: NOT
99754: OR
99755: IFFALSE 99759
// exit ;
99757: GO 99923
// tmp := AreaToList ( area , i ) ;
99759: LD_ADDR_VAR 0 6
99763: PUSH
99764: LD_VAR 0 2
99768: PPUSH
99769: LD_VAR 0 5
99773: PPUSH
99774: CALL_OW 517
99778: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99779: LD_ADDR_VAR 0 5
99783: PUSH
99784: DOUBLE
99785: LD_INT 1
99787: DEC
99788: ST_TO_ADDR
99789: LD_VAR 0 6
99793: PUSH
99794: LD_INT 1
99796: ARRAY
99797: PUSH
99798: FOR_TO
99799: IFFALSE 99921
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99801: LD_ADDR_VAR 0 7
99805: PUSH
99806: LD_VAR 0 6
99810: PUSH
99811: LD_INT 1
99813: ARRAY
99814: PUSH
99815: LD_VAR 0 5
99819: ARRAY
99820: PUSH
99821: LD_VAR 0 6
99825: PUSH
99826: LD_INT 2
99828: ARRAY
99829: PUSH
99830: LD_VAR 0 5
99834: ARRAY
99835: PUSH
99836: EMPTY
99837: LIST
99838: LIST
99839: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99840: LD_VAR 0 7
99844: PUSH
99845: LD_INT 1
99847: ARRAY
99848: PPUSH
99849: LD_VAR 0 7
99853: PUSH
99854: LD_INT 2
99856: ARRAY
99857: PPUSH
99858: CALL_OW 428
99862: PUSH
99863: LD_INT 0
99865: EQUAL
99866: IFFALSE 99919
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99868: LD_VAR 0 1
99872: PPUSH
99873: LD_VAR 0 7
99877: PUSH
99878: LD_INT 1
99880: ARRAY
99881: PPUSH
99882: LD_VAR 0 7
99886: PUSH
99887: LD_INT 2
99889: ARRAY
99890: PPUSH
99891: LD_VAR 0 3
99895: PPUSH
99896: CALL_OW 48
// result := IsPlaced ( unit ) ;
99900: LD_ADDR_VAR 0 4
99904: PUSH
99905: LD_VAR 0 1
99909: PPUSH
99910: CALL_OW 305
99914: ST_TO_ADDR
// exit ;
99915: POP
99916: POP
99917: GO 99923
// end ; end ;
99919: GO 99798
99921: POP
99922: POP
// end ;
99923: LD_VAR 0 4
99927: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99928: LD_INT 0
99930: PPUSH
99931: PPUSH
99932: PPUSH
// if not side or side > 8 then
99933: LD_VAR 0 1
99937: NOT
99938: PUSH
99939: LD_VAR 0 1
99943: PUSH
99944: LD_INT 8
99946: GREATER
99947: OR
99948: IFFALSE 99952
// exit ;
99950: GO 100139
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99952: LD_ADDR_VAR 0 4
99956: PUSH
99957: LD_INT 22
99959: PUSH
99960: LD_VAR 0 1
99964: PUSH
99965: EMPTY
99966: LIST
99967: LIST
99968: PUSH
99969: LD_INT 21
99971: PUSH
99972: LD_INT 3
99974: PUSH
99975: EMPTY
99976: LIST
99977: LIST
99978: PUSH
99979: EMPTY
99980: LIST
99981: LIST
99982: PPUSH
99983: CALL_OW 69
99987: ST_TO_ADDR
// if not tmp then
99988: LD_VAR 0 4
99992: NOT
99993: IFFALSE 99997
// exit ;
99995: GO 100139
// enable_addtolog := true ;
99997: LD_ADDR_OWVAR 81
100001: PUSH
100002: LD_INT 1
100004: ST_TO_ADDR
// AddToLog ( [ ) ;
100005: LD_STRING [
100007: PPUSH
100008: CALL_OW 561
// for i in tmp do
100012: LD_ADDR_VAR 0 3
100016: PUSH
100017: LD_VAR 0 4
100021: PUSH
100022: FOR_IN
100023: IFFALSE 100130
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100025: LD_STRING [
100027: PUSH
100028: LD_VAR 0 3
100032: PPUSH
100033: CALL_OW 266
100037: STR
100038: PUSH
100039: LD_STRING , 
100041: STR
100042: PUSH
100043: LD_VAR 0 3
100047: PPUSH
100048: CALL_OW 250
100052: STR
100053: PUSH
100054: LD_STRING , 
100056: STR
100057: PUSH
100058: LD_VAR 0 3
100062: PPUSH
100063: CALL_OW 251
100067: STR
100068: PUSH
100069: LD_STRING , 
100071: STR
100072: PUSH
100073: LD_VAR 0 3
100077: PPUSH
100078: CALL_OW 254
100082: STR
100083: PUSH
100084: LD_STRING , 
100086: STR
100087: PUSH
100088: LD_VAR 0 3
100092: PPUSH
100093: LD_INT 1
100095: PPUSH
100096: CALL_OW 268
100100: STR
100101: PUSH
100102: LD_STRING , 
100104: STR
100105: PUSH
100106: LD_VAR 0 3
100110: PPUSH
100111: LD_INT 2
100113: PPUSH
100114: CALL_OW 268
100118: STR
100119: PUSH
100120: LD_STRING ],
100122: STR
100123: PPUSH
100124: CALL_OW 561
// end ;
100128: GO 100022
100130: POP
100131: POP
// AddToLog ( ]; ) ;
100132: LD_STRING ];
100134: PPUSH
100135: CALL_OW 561
// end ;
100139: LD_VAR 0 2
100143: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100144: LD_INT 0
100146: PPUSH
100147: PPUSH
100148: PPUSH
100149: PPUSH
100150: PPUSH
// if not area or not rate or not max then
100151: LD_VAR 0 1
100155: NOT
100156: PUSH
100157: LD_VAR 0 2
100161: NOT
100162: OR
100163: PUSH
100164: LD_VAR 0 4
100168: NOT
100169: OR
100170: IFFALSE 100174
// exit ;
100172: GO 100363
// while 1 do
100174: LD_INT 1
100176: IFFALSE 100363
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100178: LD_ADDR_VAR 0 9
100182: PUSH
100183: LD_VAR 0 1
100187: PPUSH
100188: LD_INT 1
100190: PPUSH
100191: CALL_OW 287
100195: PUSH
100196: LD_INT 10
100198: MUL
100199: ST_TO_ADDR
// r := rate / 10 ;
100200: LD_ADDR_VAR 0 7
100204: PUSH
100205: LD_VAR 0 2
100209: PUSH
100210: LD_INT 10
100212: DIVREAL
100213: ST_TO_ADDR
// time := 1 1$00 ;
100214: LD_ADDR_VAR 0 8
100218: PUSH
100219: LD_INT 2100
100221: ST_TO_ADDR
// if amount < min then
100222: LD_VAR 0 9
100226: PUSH
100227: LD_VAR 0 3
100231: LESS
100232: IFFALSE 100250
// r := r * 2 else
100234: LD_ADDR_VAR 0 7
100238: PUSH
100239: LD_VAR 0 7
100243: PUSH
100244: LD_INT 2
100246: MUL
100247: ST_TO_ADDR
100248: GO 100276
// if amount > max then
100250: LD_VAR 0 9
100254: PUSH
100255: LD_VAR 0 4
100259: GREATER
100260: IFFALSE 100276
// r := r / 2 ;
100262: LD_ADDR_VAR 0 7
100266: PUSH
100267: LD_VAR 0 7
100271: PUSH
100272: LD_INT 2
100274: DIVREAL
100275: ST_TO_ADDR
// time := time / r ;
100276: LD_ADDR_VAR 0 8
100280: PUSH
100281: LD_VAR 0 8
100285: PUSH
100286: LD_VAR 0 7
100290: DIVREAL
100291: ST_TO_ADDR
// if time < 0 then
100292: LD_VAR 0 8
100296: PUSH
100297: LD_INT 0
100299: LESS
100300: IFFALSE 100317
// time := time * - 1 ;
100302: LD_ADDR_VAR 0 8
100306: PUSH
100307: LD_VAR 0 8
100311: PUSH
100312: LD_INT 1
100314: NEG
100315: MUL
100316: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100317: LD_VAR 0 8
100321: PUSH
100322: LD_INT 35
100324: PPUSH
100325: LD_INT 875
100327: PPUSH
100328: CALL_OW 12
100332: PLUS
100333: PPUSH
100334: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100338: LD_INT 1
100340: PPUSH
100341: LD_INT 5
100343: PPUSH
100344: CALL_OW 12
100348: PPUSH
100349: LD_VAR 0 1
100353: PPUSH
100354: LD_INT 1
100356: PPUSH
100357: CALL_OW 55
// end ;
100361: GO 100174
// end ;
100363: LD_VAR 0 5
100367: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100368: LD_INT 0
100370: PPUSH
100371: PPUSH
100372: PPUSH
100373: PPUSH
100374: PPUSH
100375: PPUSH
100376: PPUSH
100377: PPUSH
// if not turrets or not factories then
100378: LD_VAR 0 1
100382: NOT
100383: PUSH
100384: LD_VAR 0 2
100388: NOT
100389: OR
100390: IFFALSE 100394
// exit ;
100392: GO 100701
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100394: LD_ADDR_VAR 0 10
100398: PUSH
100399: LD_INT 5
100401: PUSH
100402: LD_INT 6
100404: PUSH
100405: EMPTY
100406: LIST
100407: LIST
100408: PUSH
100409: LD_INT 2
100411: PUSH
100412: LD_INT 4
100414: PUSH
100415: EMPTY
100416: LIST
100417: LIST
100418: PUSH
100419: LD_INT 3
100421: PUSH
100422: LD_INT 5
100424: PUSH
100425: EMPTY
100426: LIST
100427: LIST
100428: PUSH
100429: EMPTY
100430: LIST
100431: LIST
100432: LIST
100433: PUSH
100434: LD_INT 24
100436: PUSH
100437: LD_INT 25
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PUSH
100444: LD_INT 23
100446: PUSH
100447: LD_INT 27
100449: PUSH
100450: EMPTY
100451: LIST
100452: LIST
100453: PUSH
100454: EMPTY
100455: LIST
100456: LIST
100457: PUSH
100458: LD_INT 42
100460: PUSH
100461: LD_INT 43
100463: PUSH
100464: EMPTY
100465: LIST
100466: LIST
100467: PUSH
100468: LD_INT 44
100470: PUSH
100471: LD_INT 46
100473: PUSH
100474: EMPTY
100475: LIST
100476: LIST
100477: PUSH
100478: LD_INT 45
100480: PUSH
100481: LD_INT 47
100483: PUSH
100484: EMPTY
100485: LIST
100486: LIST
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: LIST
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: LIST
100497: ST_TO_ADDR
// result := [ ] ;
100498: LD_ADDR_VAR 0 3
100502: PUSH
100503: EMPTY
100504: ST_TO_ADDR
// for i in turrets do
100505: LD_ADDR_VAR 0 4
100509: PUSH
100510: LD_VAR 0 1
100514: PUSH
100515: FOR_IN
100516: IFFALSE 100699
// begin nat := GetNation ( i ) ;
100518: LD_ADDR_VAR 0 7
100522: PUSH
100523: LD_VAR 0 4
100527: PPUSH
100528: CALL_OW 248
100532: ST_TO_ADDR
// weapon := 0 ;
100533: LD_ADDR_VAR 0 8
100537: PUSH
100538: LD_INT 0
100540: ST_TO_ADDR
// if not nat then
100541: LD_VAR 0 7
100545: NOT
100546: IFFALSE 100550
// continue ;
100548: GO 100515
// for j in list [ nat ] do
100550: LD_ADDR_VAR 0 5
100554: PUSH
100555: LD_VAR 0 10
100559: PUSH
100560: LD_VAR 0 7
100564: ARRAY
100565: PUSH
100566: FOR_IN
100567: IFFALSE 100608
// if GetBWeapon ( i ) = j [ 1 ] then
100569: LD_VAR 0 4
100573: PPUSH
100574: CALL_OW 269
100578: PUSH
100579: LD_VAR 0 5
100583: PUSH
100584: LD_INT 1
100586: ARRAY
100587: EQUAL
100588: IFFALSE 100606
// begin weapon := j [ 2 ] ;
100590: LD_ADDR_VAR 0 8
100594: PUSH
100595: LD_VAR 0 5
100599: PUSH
100600: LD_INT 2
100602: ARRAY
100603: ST_TO_ADDR
// break ;
100604: GO 100608
// end ;
100606: GO 100566
100608: POP
100609: POP
// if not weapon then
100610: LD_VAR 0 8
100614: NOT
100615: IFFALSE 100619
// continue ;
100617: GO 100515
// for k in factories do
100619: LD_ADDR_VAR 0 6
100623: PUSH
100624: LD_VAR 0 2
100628: PUSH
100629: FOR_IN
100630: IFFALSE 100695
// begin weapons := AvailableWeaponList ( k ) ;
100632: LD_ADDR_VAR 0 9
100636: PUSH
100637: LD_VAR 0 6
100641: PPUSH
100642: CALL_OW 478
100646: ST_TO_ADDR
// if not weapons then
100647: LD_VAR 0 9
100651: NOT
100652: IFFALSE 100656
// continue ;
100654: GO 100629
// if weapon in weapons then
100656: LD_VAR 0 8
100660: PUSH
100661: LD_VAR 0 9
100665: IN
100666: IFFALSE 100693
// begin result := [ i , weapon ] ;
100668: LD_ADDR_VAR 0 3
100672: PUSH
100673: LD_VAR 0 4
100677: PUSH
100678: LD_VAR 0 8
100682: PUSH
100683: EMPTY
100684: LIST
100685: LIST
100686: ST_TO_ADDR
// exit ;
100687: POP
100688: POP
100689: POP
100690: POP
100691: GO 100701
// end ; end ;
100693: GO 100629
100695: POP
100696: POP
// end ;
100697: GO 100515
100699: POP
100700: POP
// end ;
100701: LD_VAR 0 3
100705: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100706: LD_INT 0
100708: PPUSH
// if not side or side > 8 then
100709: LD_VAR 0 3
100713: NOT
100714: PUSH
100715: LD_VAR 0 3
100719: PUSH
100720: LD_INT 8
100722: GREATER
100723: OR
100724: IFFALSE 100728
// exit ;
100726: GO 100787
// if not range then
100728: LD_VAR 0 4
100732: NOT
100733: IFFALSE 100744
// range := - 12 ;
100735: LD_ADDR_VAR 0 4
100739: PUSH
100740: LD_INT 12
100742: NEG
100743: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100744: LD_VAR 0 1
100748: PPUSH
100749: LD_VAR 0 2
100753: PPUSH
100754: LD_VAR 0 3
100758: PPUSH
100759: LD_VAR 0 4
100763: PPUSH
100764: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100768: LD_VAR 0 1
100772: PPUSH
100773: LD_VAR 0 2
100777: PPUSH
100778: LD_VAR 0 3
100782: PPUSH
100783: CALL_OW 331
// end ;
100787: LD_VAR 0 5
100791: RET
// export function Video ( mode ) ; begin
100792: LD_INT 0
100794: PPUSH
// ingame_video = mode ;
100795: LD_ADDR_OWVAR 52
100799: PUSH
100800: LD_VAR 0 1
100804: ST_TO_ADDR
// interface_hidden = mode ;
100805: LD_ADDR_OWVAR 54
100809: PUSH
100810: LD_VAR 0 1
100814: ST_TO_ADDR
// end ;
100815: LD_VAR 0 2
100819: RET
// export function Join ( array , element ) ; begin
100820: LD_INT 0
100822: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100823: LD_ADDR_VAR 0 3
100827: PUSH
100828: LD_VAR 0 1
100832: PPUSH
100833: LD_VAR 0 1
100837: PUSH
100838: LD_INT 1
100840: PLUS
100841: PPUSH
100842: LD_VAR 0 2
100846: PPUSH
100847: CALL_OW 1
100851: ST_TO_ADDR
// end ;
100852: LD_VAR 0 3
100856: RET
// export function JoinUnion ( array , element ) ; begin
100857: LD_INT 0
100859: PPUSH
// result := array union element ;
100860: LD_ADDR_VAR 0 3
100864: PUSH
100865: LD_VAR 0 1
100869: PUSH
100870: LD_VAR 0 2
100874: UNION
100875: ST_TO_ADDR
// end ;
100876: LD_VAR 0 3
100880: RET
// export function GetBehemoths ( side ) ; begin
100881: LD_INT 0
100883: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
100884: LD_ADDR_VAR 0 2
100888: PUSH
100889: LD_INT 22
100891: PUSH
100892: LD_VAR 0 1
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PUSH
100901: LD_INT 31
100903: PUSH
100904: LD_INT 25
100906: PUSH
100907: EMPTY
100908: LIST
100909: LIST
100910: PUSH
100911: EMPTY
100912: LIST
100913: LIST
100914: PPUSH
100915: CALL_OW 69
100919: ST_TO_ADDR
// end ;
100920: LD_VAR 0 2
100924: RET
// export function Shuffle ( array ) ; var i , index ; begin
100925: LD_INT 0
100927: PPUSH
100928: PPUSH
100929: PPUSH
// result := [ ] ;
100930: LD_ADDR_VAR 0 2
100934: PUSH
100935: EMPTY
100936: ST_TO_ADDR
// if not array then
100937: LD_VAR 0 1
100941: NOT
100942: IFFALSE 100946
// exit ;
100944: GO 101045
// Randomize ;
100946: CALL_OW 10
// for i = array downto 1 do
100950: LD_ADDR_VAR 0 3
100954: PUSH
100955: DOUBLE
100956: LD_VAR 0 1
100960: INC
100961: ST_TO_ADDR
100962: LD_INT 1
100964: PUSH
100965: FOR_DOWNTO
100966: IFFALSE 101043
// begin index := rand ( 1 , array ) ;
100968: LD_ADDR_VAR 0 4
100972: PUSH
100973: LD_INT 1
100975: PPUSH
100976: LD_VAR 0 1
100980: PPUSH
100981: CALL_OW 12
100985: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
100986: LD_ADDR_VAR 0 2
100990: PUSH
100991: LD_VAR 0 2
100995: PPUSH
100996: LD_VAR 0 2
101000: PUSH
101001: LD_INT 1
101003: PLUS
101004: PPUSH
101005: LD_VAR 0 1
101009: PUSH
101010: LD_VAR 0 4
101014: ARRAY
101015: PPUSH
101016: CALL_OW 2
101020: ST_TO_ADDR
// array := Delete ( array , index ) ;
101021: LD_ADDR_VAR 0 1
101025: PUSH
101026: LD_VAR 0 1
101030: PPUSH
101031: LD_VAR 0 4
101035: PPUSH
101036: CALL_OW 3
101040: ST_TO_ADDR
// end ;
101041: GO 100965
101043: POP
101044: POP
// end ;
101045: LD_VAR 0 2
101049: RET
// export function GetBaseMaterials ( base ) ; begin
101050: LD_INT 0
101052: PPUSH
// result := [ 0 , 0 , 0 ] ;
101053: LD_ADDR_VAR 0 2
101057: PUSH
101058: LD_INT 0
101060: PUSH
101061: LD_INT 0
101063: PUSH
101064: LD_INT 0
101066: PUSH
101067: EMPTY
101068: LIST
101069: LIST
101070: LIST
101071: ST_TO_ADDR
// if not base then
101072: LD_VAR 0 1
101076: NOT
101077: IFFALSE 101081
// exit ;
101079: GO 101130
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101081: LD_ADDR_VAR 0 2
101085: PUSH
101086: LD_VAR 0 1
101090: PPUSH
101091: LD_INT 1
101093: PPUSH
101094: CALL_OW 275
101098: PUSH
101099: LD_VAR 0 1
101103: PPUSH
101104: LD_INT 2
101106: PPUSH
101107: CALL_OW 275
101111: PUSH
101112: LD_VAR 0 1
101116: PPUSH
101117: LD_INT 3
101119: PPUSH
101120: CALL_OW 275
101124: PUSH
101125: EMPTY
101126: LIST
101127: LIST
101128: LIST
101129: ST_TO_ADDR
// end ;
101130: LD_VAR 0 2
101134: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101135: LD_INT 0
101137: PPUSH
101138: PPUSH
// result := array ;
101139: LD_ADDR_VAR 0 3
101143: PUSH
101144: LD_VAR 0 1
101148: ST_TO_ADDR
// if size >= result then
101149: LD_VAR 0 2
101153: PUSH
101154: LD_VAR 0 3
101158: GREATEREQUAL
101159: IFFALSE 101163
// exit ;
101161: GO 101213
// if size then
101163: LD_VAR 0 2
101167: IFFALSE 101213
// for i := array downto size do
101169: LD_ADDR_VAR 0 4
101173: PUSH
101174: DOUBLE
101175: LD_VAR 0 1
101179: INC
101180: ST_TO_ADDR
101181: LD_VAR 0 2
101185: PUSH
101186: FOR_DOWNTO
101187: IFFALSE 101211
// result := Delete ( result , result ) ;
101189: LD_ADDR_VAR 0 3
101193: PUSH
101194: LD_VAR 0 3
101198: PPUSH
101199: LD_VAR 0 3
101203: PPUSH
101204: CALL_OW 3
101208: ST_TO_ADDR
101209: GO 101186
101211: POP
101212: POP
// end ;
101213: LD_VAR 0 3
101217: RET
// export function ComExit ( unit ) ; var tmp ; begin
101218: LD_INT 0
101220: PPUSH
101221: PPUSH
// if not IsInUnit ( unit ) then
101222: LD_VAR 0 1
101226: PPUSH
101227: CALL_OW 310
101231: NOT
101232: IFFALSE 101236
// exit ;
101234: GO 101296
// tmp := IsInUnit ( unit ) ;
101236: LD_ADDR_VAR 0 3
101240: PUSH
101241: LD_VAR 0 1
101245: PPUSH
101246: CALL_OW 310
101250: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101251: LD_VAR 0 3
101255: PPUSH
101256: CALL_OW 247
101260: PUSH
101261: LD_INT 2
101263: EQUAL
101264: IFFALSE 101277
// ComExitVehicle ( unit ) else
101266: LD_VAR 0 1
101270: PPUSH
101271: CALL_OW 121
101275: GO 101286
// ComExitBuilding ( unit ) ;
101277: LD_VAR 0 1
101281: PPUSH
101282: CALL_OW 122
// result := tmp ;
101286: LD_ADDR_VAR 0 2
101290: PUSH
101291: LD_VAR 0 3
101295: ST_TO_ADDR
// end ;
101296: LD_VAR 0 2
101300: RET
// export function ComExitAll ( units ) ; var i ; begin
101301: LD_INT 0
101303: PPUSH
101304: PPUSH
// if not units then
101305: LD_VAR 0 1
101309: NOT
101310: IFFALSE 101314
// exit ;
101312: GO 101340
// for i in units do
101314: LD_ADDR_VAR 0 3
101318: PUSH
101319: LD_VAR 0 1
101323: PUSH
101324: FOR_IN
101325: IFFALSE 101338
// ComExit ( i ) ;
101327: LD_VAR 0 3
101331: PPUSH
101332: CALL 101218 0 1
101336: GO 101324
101338: POP
101339: POP
// end ;
101340: LD_VAR 0 2
101344: RET
// export function ResetHc ; begin
101345: LD_INT 0
101347: PPUSH
// InitHc ;
101348: CALL_OW 19
// hc_importance := 0 ;
101352: LD_ADDR_OWVAR 32
101356: PUSH
101357: LD_INT 0
101359: ST_TO_ADDR
// end ;
101360: LD_VAR 0 1
101364: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101365: LD_INT 0
101367: PPUSH
101368: PPUSH
101369: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101370: LD_ADDR_VAR 0 6
101374: PUSH
101375: LD_VAR 0 1
101379: PUSH
101380: LD_VAR 0 3
101384: PLUS
101385: PUSH
101386: LD_INT 2
101388: DIV
101389: ST_TO_ADDR
// if _x < 0 then
101390: LD_VAR 0 6
101394: PUSH
101395: LD_INT 0
101397: LESS
101398: IFFALSE 101415
// _x := _x * - 1 ;
101400: LD_ADDR_VAR 0 6
101404: PUSH
101405: LD_VAR 0 6
101409: PUSH
101410: LD_INT 1
101412: NEG
101413: MUL
101414: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101415: LD_ADDR_VAR 0 7
101419: PUSH
101420: LD_VAR 0 2
101424: PUSH
101425: LD_VAR 0 4
101429: PLUS
101430: PUSH
101431: LD_INT 2
101433: DIV
101434: ST_TO_ADDR
// if _y < 0 then
101435: LD_VAR 0 7
101439: PUSH
101440: LD_INT 0
101442: LESS
101443: IFFALSE 101460
// _y := _y * - 1 ;
101445: LD_ADDR_VAR 0 7
101449: PUSH
101450: LD_VAR 0 7
101454: PUSH
101455: LD_INT 1
101457: NEG
101458: MUL
101459: ST_TO_ADDR
// result := [ _x , _y ] ;
101460: LD_ADDR_VAR 0 5
101464: PUSH
101465: LD_VAR 0 6
101469: PUSH
101470: LD_VAR 0 7
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: ST_TO_ADDR
// end ;
101479: LD_VAR 0 5
101483: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101484: LD_INT 0
101486: PPUSH
101487: PPUSH
101488: PPUSH
101489: PPUSH
// task := GetTaskList ( unit ) ;
101490: LD_ADDR_VAR 0 7
101494: PUSH
101495: LD_VAR 0 1
101499: PPUSH
101500: CALL_OW 437
101504: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101505: LD_VAR 0 7
101509: NOT
101510: PUSH
101511: LD_VAR 0 1
101515: PPUSH
101516: LD_VAR 0 2
101520: PPUSH
101521: CALL_OW 308
101525: NOT
101526: AND
101527: IFFALSE 101531
// exit ;
101529: GO 101649
// if IsInArea ( unit , area ) then
101531: LD_VAR 0 1
101535: PPUSH
101536: LD_VAR 0 2
101540: PPUSH
101541: CALL_OW 308
101545: IFFALSE 101563
// begin ComMoveToArea ( unit , goAway ) ;
101547: LD_VAR 0 1
101551: PPUSH
101552: LD_VAR 0 3
101556: PPUSH
101557: CALL_OW 113
// exit ;
101561: GO 101649
// end ; if task [ 1 ] [ 1 ] <> M then
101563: LD_VAR 0 7
101567: PUSH
101568: LD_INT 1
101570: ARRAY
101571: PUSH
101572: LD_INT 1
101574: ARRAY
101575: PUSH
101576: LD_STRING M
101578: NONEQUAL
101579: IFFALSE 101583
// exit ;
101581: GO 101649
// x := task [ 1 ] [ 2 ] ;
101583: LD_ADDR_VAR 0 5
101587: PUSH
101588: LD_VAR 0 7
101592: PUSH
101593: LD_INT 1
101595: ARRAY
101596: PUSH
101597: LD_INT 2
101599: ARRAY
101600: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101601: LD_ADDR_VAR 0 6
101605: PUSH
101606: LD_VAR 0 7
101610: PUSH
101611: LD_INT 1
101613: ARRAY
101614: PUSH
101615: LD_INT 3
101617: ARRAY
101618: ST_TO_ADDR
// if InArea ( x , y , area ) then
101619: LD_VAR 0 5
101623: PPUSH
101624: LD_VAR 0 6
101628: PPUSH
101629: LD_VAR 0 2
101633: PPUSH
101634: CALL_OW 309
101638: IFFALSE 101649
// ComStop ( unit ) ;
101640: LD_VAR 0 1
101644: PPUSH
101645: CALL_OW 141
// end ;
101649: LD_VAR 0 4
101653: RET
// export function Abs ( value ) ; begin
101654: LD_INT 0
101656: PPUSH
// result := value ;
101657: LD_ADDR_VAR 0 2
101661: PUSH
101662: LD_VAR 0 1
101666: ST_TO_ADDR
// if value < 0 then
101667: LD_VAR 0 1
101671: PUSH
101672: LD_INT 0
101674: LESS
101675: IFFALSE 101692
// result := value * - 1 ;
101677: LD_ADDR_VAR 0 2
101681: PUSH
101682: LD_VAR 0 1
101686: PUSH
101687: LD_INT 1
101689: NEG
101690: MUL
101691: ST_TO_ADDR
// end ;
101692: LD_VAR 0 2
101696: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101697: LD_INT 0
101699: PPUSH
101700: PPUSH
101701: PPUSH
101702: PPUSH
101703: PPUSH
101704: PPUSH
101705: PPUSH
101706: PPUSH
// if not unit or not building then
101707: LD_VAR 0 1
101711: NOT
101712: PUSH
101713: LD_VAR 0 2
101717: NOT
101718: OR
101719: IFFALSE 101723
// exit ;
101721: GO 101949
// x := GetX ( building ) ;
101723: LD_ADDR_VAR 0 4
101727: PUSH
101728: LD_VAR 0 2
101732: PPUSH
101733: CALL_OW 250
101737: ST_TO_ADDR
// y := GetY ( building ) ;
101738: LD_ADDR_VAR 0 6
101742: PUSH
101743: LD_VAR 0 2
101747: PPUSH
101748: CALL_OW 251
101752: ST_TO_ADDR
// d := GetDir ( building ) ;
101753: LD_ADDR_VAR 0 8
101757: PUSH
101758: LD_VAR 0 2
101762: PPUSH
101763: CALL_OW 254
101767: ST_TO_ADDR
// r := 4 ;
101768: LD_ADDR_VAR 0 9
101772: PUSH
101773: LD_INT 4
101775: ST_TO_ADDR
// for i := 1 to 5 do
101776: LD_ADDR_VAR 0 10
101780: PUSH
101781: DOUBLE
101782: LD_INT 1
101784: DEC
101785: ST_TO_ADDR
101786: LD_INT 5
101788: PUSH
101789: FOR_TO
101790: IFFALSE 101947
// begin _x := ShiftX ( x , d , r + i ) ;
101792: LD_ADDR_VAR 0 5
101796: PUSH
101797: LD_VAR 0 4
101801: PPUSH
101802: LD_VAR 0 8
101806: PPUSH
101807: LD_VAR 0 9
101811: PUSH
101812: LD_VAR 0 10
101816: PLUS
101817: PPUSH
101818: CALL_OW 272
101822: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
101823: LD_ADDR_VAR 0 7
101827: PUSH
101828: LD_VAR 0 6
101832: PPUSH
101833: LD_VAR 0 8
101837: PPUSH
101838: LD_VAR 0 9
101842: PUSH
101843: LD_VAR 0 10
101847: PLUS
101848: PPUSH
101849: CALL_OW 273
101853: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
101854: LD_VAR 0 5
101858: PPUSH
101859: LD_VAR 0 7
101863: PPUSH
101864: CALL_OW 488
101868: PUSH
101869: LD_VAR 0 5
101873: PPUSH
101874: LD_VAR 0 7
101878: PPUSH
101879: CALL_OW 428
101883: PPUSH
101884: CALL_OW 247
101888: PUSH
101889: LD_INT 3
101891: PUSH
101892: LD_INT 2
101894: PUSH
101895: EMPTY
101896: LIST
101897: LIST
101898: IN
101899: NOT
101900: AND
101901: IFFALSE 101945
// begin ComMoveXY ( unit , _x , _y ) ;
101903: LD_VAR 0 1
101907: PPUSH
101908: LD_VAR 0 5
101912: PPUSH
101913: LD_VAR 0 7
101917: PPUSH
101918: CALL_OW 111
// result := [ _x , _y ] ;
101922: LD_ADDR_VAR 0 3
101926: PUSH
101927: LD_VAR 0 5
101931: PUSH
101932: LD_VAR 0 7
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: ST_TO_ADDR
// exit ;
101941: POP
101942: POP
101943: GO 101949
// end ; end ;
101945: GO 101789
101947: POP
101948: POP
// end ;
101949: LD_VAR 0 3
101953: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
101954: LD_INT 0
101956: PPUSH
101957: PPUSH
101958: PPUSH
// result := 0 ;
101959: LD_ADDR_VAR 0 3
101963: PUSH
101964: LD_INT 0
101966: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
101967: LD_VAR 0 1
101971: PUSH
101972: LD_INT 0
101974: LESS
101975: PUSH
101976: LD_VAR 0 1
101980: PUSH
101981: LD_INT 8
101983: GREATER
101984: OR
101985: PUSH
101986: LD_VAR 0 2
101990: PUSH
101991: LD_INT 0
101993: LESS
101994: OR
101995: PUSH
101996: LD_VAR 0 2
102000: PUSH
102001: LD_INT 8
102003: GREATER
102004: OR
102005: IFFALSE 102009
// exit ;
102007: GO 102084
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
102009: LD_ADDR_VAR 0 4
102013: PUSH
102014: LD_INT 22
102016: PUSH
102017: LD_VAR 0 2
102021: PUSH
102022: EMPTY
102023: LIST
102024: LIST
102025: PPUSH
102026: CALL_OW 69
102030: PUSH
102031: FOR_IN
102032: IFFALSE 102082
// begin un := UnitShoot ( i ) ;
102034: LD_ADDR_VAR 0 5
102038: PUSH
102039: LD_VAR 0 4
102043: PPUSH
102044: CALL_OW 504
102048: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102049: LD_VAR 0 5
102053: PPUSH
102054: CALL_OW 255
102058: PUSH
102059: LD_VAR 0 1
102063: EQUAL
102064: IFFALSE 102080
// begin result := un ;
102066: LD_ADDR_VAR 0 3
102070: PUSH
102071: LD_VAR 0 5
102075: ST_TO_ADDR
// exit ;
102076: POP
102077: POP
102078: GO 102084
// end ; end ;
102080: GO 102031
102082: POP
102083: POP
// end ;
102084: LD_VAR 0 3
102088: RET
// export function GetCargoBay ( units ) ; begin
102089: LD_INT 0
102091: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
102092: LD_ADDR_VAR 0 2
102096: PUSH
102097: LD_VAR 0 1
102101: PPUSH
102102: LD_INT 2
102104: PUSH
102105: LD_INT 34
102107: PUSH
102108: LD_INT 12
102110: PUSH
102111: EMPTY
102112: LIST
102113: LIST
102114: PUSH
102115: LD_INT 34
102117: PUSH
102118: LD_INT 51
102120: PUSH
102121: EMPTY
102122: LIST
102123: LIST
102124: PUSH
102125: LD_INT 34
102127: PUSH
102128: LD_INT 32
102130: PUSH
102131: EMPTY
102132: LIST
102133: LIST
102134: PUSH
102135: LD_INT 34
102137: PUSH
102138: LD_INT 89
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: PUSH
102145: EMPTY
102146: LIST
102147: LIST
102148: LIST
102149: LIST
102150: LIST
102151: PPUSH
102152: CALL_OW 72
102156: ST_TO_ADDR
// end ;
102157: LD_VAR 0 2
102161: RET
// export function Negate ( value ) ; begin
102162: LD_INT 0
102164: PPUSH
// result := not value ;
102165: LD_ADDR_VAR 0 2
102169: PUSH
102170: LD_VAR 0 1
102174: NOT
102175: ST_TO_ADDR
// end ;
102176: LD_VAR 0 2
102180: RET
// export function Inc ( value ) ; begin
102181: LD_INT 0
102183: PPUSH
// result := value + 1 ;
102184: LD_ADDR_VAR 0 2
102188: PUSH
102189: LD_VAR 0 1
102193: PUSH
102194: LD_INT 1
102196: PLUS
102197: ST_TO_ADDR
// end ;
102198: LD_VAR 0 2
102202: RET
// export function Dec ( value ) ; begin
102203: LD_INT 0
102205: PPUSH
// result := value - 1 ;
102206: LD_ADDR_VAR 0 2
102210: PUSH
102211: LD_VAR 0 1
102215: PUSH
102216: LD_INT 1
102218: MINUS
102219: ST_TO_ADDR
// end ;
102220: LD_VAR 0 2
102224: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
102225: LD_INT 0
102227: PPUSH
102228: PPUSH
102229: PPUSH
102230: PPUSH
102231: PPUSH
102232: PPUSH
102233: PPUSH
102234: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102235: LD_VAR 0 1
102239: PPUSH
102240: LD_VAR 0 2
102244: PPUSH
102245: CALL_OW 488
102249: NOT
102250: PUSH
102251: LD_VAR 0 3
102255: PPUSH
102256: LD_VAR 0 4
102260: PPUSH
102261: CALL_OW 488
102265: NOT
102266: OR
102267: IFFALSE 102280
// begin result := - 1 ;
102269: LD_ADDR_VAR 0 5
102273: PUSH
102274: LD_INT 1
102276: NEG
102277: ST_TO_ADDR
// exit ;
102278: GO 102515
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102280: LD_ADDR_VAR 0 12
102284: PUSH
102285: LD_VAR 0 1
102289: PPUSH
102290: LD_VAR 0 2
102294: PPUSH
102295: LD_VAR 0 3
102299: PPUSH
102300: LD_VAR 0 4
102304: PPUSH
102305: CALL 101365 0 4
102309: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102310: LD_ADDR_VAR 0 11
102314: PUSH
102315: LD_VAR 0 1
102319: PPUSH
102320: LD_VAR 0 2
102324: PPUSH
102325: LD_VAR 0 12
102329: PUSH
102330: LD_INT 1
102332: ARRAY
102333: PPUSH
102334: LD_VAR 0 12
102338: PUSH
102339: LD_INT 2
102341: ARRAY
102342: PPUSH
102343: CALL_OW 298
102347: ST_TO_ADDR
// distance := 9999 ;
102348: LD_ADDR_VAR 0 10
102352: PUSH
102353: LD_INT 9999
102355: ST_TO_ADDR
// for i := 0 to 5 do
102356: LD_ADDR_VAR 0 6
102360: PUSH
102361: DOUBLE
102362: LD_INT 0
102364: DEC
102365: ST_TO_ADDR
102366: LD_INT 5
102368: PUSH
102369: FOR_TO
102370: IFFALSE 102513
// begin _x := ShiftX ( x1 , i , centerDist ) ;
102372: LD_ADDR_VAR 0 7
102376: PUSH
102377: LD_VAR 0 1
102381: PPUSH
102382: LD_VAR 0 6
102386: PPUSH
102387: LD_VAR 0 11
102391: PPUSH
102392: CALL_OW 272
102396: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
102397: LD_ADDR_VAR 0 8
102401: PUSH
102402: LD_VAR 0 2
102406: PPUSH
102407: LD_VAR 0 6
102411: PPUSH
102412: LD_VAR 0 11
102416: PPUSH
102417: CALL_OW 273
102421: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102422: LD_VAR 0 7
102426: PPUSH
102427: LD_VAR 0 8
102431: PPUSH
102432: CALL_OW 488
102436: NOT
102437: IFFALSE 102441
// continue ;
102439: GO 102369
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
102441: LD_ADDR_VAR 0 9
102445: PUSH
102446: LD_VAR 0 12
102450: PUSH
102451: LD_INT 1
102453: ARRAY
102454: PPUSH
102455: LD_VAR 0 12
102459: PUSH
102460: LD_INT 2
102462: ARRAY
102463: PPUSH
102464: LD_VAR 0 7
102468: PPUSH
102469: LD_VAR 0 8
102473: PPUSH
102474: CALL_OW 298
102478: ST_TO_ADDR
// if tmp < distance then
102479: LD_VAR 0 9
102483: PUSH
102484: LD_VAR 0 10
102488: LESS
102489: IFFALSE 102511
// begin result := i ;
102491: LD_ADDR_VAR 0 5
102495: PUSH
102496: LD_VAR 0 6
102500: ST_TO_ADDR
// distance := tmp ;
102501: LD_ADDR_VAR 0 10
102505: PUSH
102506: LD_VAR 0 9
102510: ST_TO_ADDR
// end ; end ;
102511: GO 102369
102513: POP
102514: POP
// end ;
102515: LD_VAR 0 5
102519: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102520: LD_INT 0
102522: PPUSH
102523: PPUSH
// if not driver or not IsInUnit ( driver ) then
102524: LD_VAR 0 1
102528: NOT
102529: PUSH
102530: LD_VAR 0 1
102534: PPUSH
102535: CALL_OW 310
102539: NOT
102540: OR
102541: IFFALSE 102545
// exit ;
102543: GO 102635
// vehicle := IsInUnit ( driver ) ;
102545: LD_ADDR_VAR 0 3
102549: PUSH
102550: LD_VAR 0 1
102554: PPUSH
102555: CALL_OW 310
102559: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102560: LD_VAR 0 1
102564: PPUSH
102565: LD_STRING \
102567: PUSH
102568: LD_INT 0
102570: PUSH
102571: LD_INT 0
102573: PUSH
102574: LD_INT 0
102576: PUSH
102577: LD_INT 0
102579: PUSH
102580: LD_INT 0
102582: PUSH
102583: LD_INT 0
102585: PUSH
102586: EMPTY
102587: LIST
102588: LIST
102589: LIST
102590: LIST
102591: LIST
102592: LIST
102593: LIST
102594: PUSH
102595: LD_STRING E
102597: PUSH
102598: LD_INT 0
102600: PUSH
102601: LD_INT 0
102603: PUSH
102604: LD_VAR 0 3
102608: PUSH
102609: LD_INT 0
102611: PUSH
102612: LD_INT 0
102614: PUSH
102615: LD_INT 0
102617: PUSH
102618: EMPTY
102619: LIST
102620: LIST
102621: LIST
102622: LIST
102623: LIST
102624: LIST
102625: LIST
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: PPUSH
102631: CALL_OW 446
// end ;
102635: LD_VAR 0 2
102639: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102640: LD_INT 0
102642: PPUSH
102643: PPUSH
// if not driver or not IsInUnit ( driver ) then
102644: LD_VAR 0 1
102648: NOT
102649: PUSH
102650: LD_VAR 0 1
102654: PPUSH
102655: CALL_OW 310
102659: NOT
102660: OR
102661: IFFALSE 102665
// exit ;
102663: GO 102755
// vehicle := IsInUnit ( driver ) ;
102665: LD_ADDR_VAR 0 3
102669: PUSH
102670: LD_VAR 0 1
102674: PPUSH
102675: CALL_OW 310
102679: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102680: LD_VAR 0 1
102684: PPUSH
102685: LD_STRING \
102687: PUSH
102688: LD_INT 0
102690: PUSH
102691: LD_INT 0
102693: PUSH
102694: LD_INT 0
102696: PUSH
102697: LD_INT 0
102699: PUSH
102700: LD_INT 0
102702: PUSH
102703: LD_INT 0
102705: PUSH
102706: EMPTY
102707: LIST
102708: LIST
102709: LIST
102710: LIST
102711: LIST
102712: LIST
102713: LIST
102714: PUSH
102715: LD_STRING E
102717: PUSH
102718: LD_INT 0
102720: PUSH
102721: LD_INT 0
102723: PUSH
102724: LD_VAR 0 3
102728: PUSH
102729: LD_INT 0
102731: PUSH
102732: LD_INT 0
102734: PUSH
102735: LD_INT 0
102737: PUSH
102738: EMPTY
102739: LIST
102740: LIST
102741: LIST
102742: LIST
102743: LIST
102744: LIST
102745: LIST
102746: PUSH
102747: EMPTY
102748: LIST
102749: LIST
102750: PPUSH
102751: CALL_OW 447
// end ;
102755: LD_VAR 0 2
102759: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
102760: LD_INT 0
102762: PPUSH
102763: PPUSH
102764: PPUSH
// tmp := [ ] ;
102765: LD_ADDR_VAR 0 5
102769: PUSH
102770: EMPTY
102771: ST_TO_ADDR
// for i in units do
102772: LD_ADDR_VAR 0 4
102776: PUSH
102777: LD_VAR 0 1
102781: PUSH
102782: FOR_IN
102783: IFFALSE 102821
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
102785: LD_ADDR_VAR 0 5
102789: PUSH
102790: LD_VAR 0 5
102794: PPUSH
102795: LD_VAR 0 5
102799: PUSH
102800: LD_INT 1
102802: PLUS
102803: PPUSH
102804: LD_VAR 0 4
102808: PPUSH
102809: CALL_OW 256
102813: PPUSH
102814: CALL_OW 2
102818: ST_TO_ADDR
102819: GO 102782
102821: POP
102822: POP
// if not tmp then
102823: LD_VAR 0 5
102827: NOT
102828: IFFALSE 102832
// exit ;
102830: GO 102880
// if asc then
102832: LD_VAR 0 2
102836: IFFALSE 102860
// result := SortListByListAsc ( units , tmp ) else
102838: LD_ADDR_VAR 0 3
102842: PUSH
102843: LD_VAR 0 1
102847: PPUSH
102848: LD_VAR 0 5
102852: PPUSH
102853: CALL_OW 76
102857: ST_TO_ADDR
102858: GO 102880
// result := SortListByListDesc ( units , tmp ) ;
102860: LD_ADDR_VAR 0 3
102864: PUSH
102865: LD_VAR 0 1
102869: PPUSH
102870: LD_VAR 0 5
102874: PPUSH
102875: CALL_OW 77
102879: ST_TO_ADDR
// end ;
102880: LD_VAR 0 3
102884: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
102885: LD_INT 0
102887: PPUSH
102888: PPUSH
// task := GetTaskList ( mech ) ;
102889: LD_ADDR_VAR 0 4
102893: PUSH
102894: LD_VAR 0 1
102898: PPUSH
102899: CALL_OW 437
102903: ST_TO_ADDR
// if not task then
102904: LD_VAR 0 4
102908: NOT
102909: IFFALSE 102913
// exit ;
102911: GO 102955
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
102913: LD_ADDR_VAR 0 3
102917: PUSH
102918: LD_VAR 0 4
102922: PUSH
102923: LD_INT 1
102925: ARRAY
102926: PUSH
102927: LD_INT 1
102929: ARRAY
102930: PUSH
102931: LD_STRING r
102933: EQUAL
102934: PUSH
102935: LD_VAR 0 4
102939: PUSH
102940: LD_INT 1
102942: ARRAY
102943: PUSH
102944: LD_INT 4
102946: ARRAY
102947: PUSH
102948: LD_VAR 0 2
102952: EQUAL
102953: AND
102954: ST_TO_ADDR
// end ;
102955: LD_VAR 0 3
102959: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
102960: LD_INT 0
102962: PPUSH
// SetDir ( unit , d ) ;
102963: LD_VAR 0 1
102967: PPUSH
102968: LD_VAR 0 4
102972: PPUSH
102973: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
102977: LD_VAR 0 1
102981: PPUSH
102982: LD_VAR 0 2
102986: PPUSH
102987: LD_VAR 0 3
102991: PPUSH
102992: LD_VAR 0 5
102996: PPUSH
102997: CALL_OW 48
// end ;
103001: LD_VAR 0 6
103005: RET
// export function ToNaturalNumber ( number ) ; begin
103006: LD_INT 0
103008: PPUSH
// result := number div 1 ;
103009: LD_ADDR_VAR 0 2
103013: PUSH
103014: LD_VAR 0 1
103018: PUSH
103019: LD_INT 1
103021: DIV
103022: ST_TO_ADDR
// if number < 0 then
103023: LD_VAR 0 1
103027: PUSH
103028: LD_INT 0
103030: LESS
103031: IFFALSE 103041
// result := 0 ;
103033: LD_ADDR_VAR 0 2
103037: PUSH
103038: LD_INT 0
103040: ST_TO_ADDR
// end ;
103041: LD_VAR 0 2
103045: RET
// export function SortByClass ( units , class ) ; var un ; begin
103046: LD_INT 0
103048: PPUSH
103049: PPUSH
// if not units or not class then
103050: LD_VAR 0 1
103054: NOT
103055: PUSH
103056: LD_VAR 0 2
103060: NOT
103061: OR
103062: IFFALSE 103066
// exit ;
103064: GO 103161
// result := [ ] ;
103066: LD_ADDR_VAR 0 3
103070: PUSH
103071: EMPTY
103072: ST_TO_ADDR
// for un in units do
103073: LD_ADDR_VAR 0 4
103077: PUSH
103078: LD_VAR 0 1
103082: PUSH
103083: FOR_IN
103084: IFFALSE 103159
// if GetClass ( un ) = class then
103086: LD_VAR 0 4
103090: PPUSH
103091: CALL_OW 257
103095: PUSH
103096: LD_VAR 0 2
103100: EQUAL
103101: IFFALSE 103128
// result := Insert ( result , 1 , un ) else
103103: LD_ADDR_VAR 0 3
103107: PUSH
103108: LD_VAR 0 3
103112: PPUSH
103113: LD_INT 1
103115: PPUSH
103116: LD_VAR 0 4
103120: PPUSH
103121: CALL_OW 2
103125: ST_TO_ADDR
103126: GO 103157
// result := Replace ( result , result + 1 , un ) ;
103128: LD_ADDR_VAR 0 3
103132: PUSH
103133: LD_VAR 0 3
103137: PPUSH
103138: LD_VAR 0 3
103142: PUSH
103143: LD_INT 1
103145: PLUS
103146: PPUSH
103147: LD_VAR 0 4
103151: PPUSH
103152: CALL_OW 1
103156: ST_TO_ADDR
103157: GO 103083
103159: POP
103160: POP
// end ;
103161: LD_VAR 0 3
103165: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
103166: LD_INT 0
103168: PPUSH
103169: PPUSH
103170: PPUSH
103171: PPUSH
103172: PPUSH
103173: PPUSH
103174: PPUSH
// result := [ ] ;
103175: LD_ADDR_VAR 0 4
103179: PUSH
103180: EMPTY
103181: ST_TO_ADDR
// if x - r < 0 then
103182: LD_VAR 0 1
103186: PUSH
103187: LD_VAR 0 3
103191: MINUS
103192: PUSH
103193: LD_INT 0
103195: LESS
103196: IFFALSE 103208
// min_x := 0 else
103198: LD_ADDR_VAR 0 8
103202: PUSH
103203: LD_INT 0
103205: ST_TO_ADDR
103206: GO 103224
// min_x := x - r ;
103208: LD_ADDR_VAR 0 8
103212: PUSH
103213: LD_VAR 0 1
103217: PUSH
103218: LD_VAR 0 3
103222: MINUS
103223: ST_TO_ADDR
// if y - r < 0 then
103224: LD_VAR 0 2
103228: PUSH
103229: LD_VAR 0 3
103233: MINUS
103234: PUSH
103235: LD_INT 0
103237: LESS
103238: IFFALSE 103250
// min_y := 0 else
103240: LD_ADDR_VAR 0 7
103244: PUSH
103245: LD_INT 0
103247: ST_TO_ADDR
103248: GO 103266
// min_y := y - r ;
103250: LD_ADDR_VAR 0 7
103254: PUSH
103255: LD_VAR 0 2
103259: PUSH
103260: LD_VAR 0 3
103264: MINUS
103265: ST_TO_ADDR
// max_x := x + r ;
103266: LD_ADDR_VAR 0 9
103270: PUSH
103271: LD_VAR 0 1
103275: PUSH
103276: LD_VAR 0 3
103280: PLUS
103281: ST_TO_ADDR
// max_y := y + r ;
103282: LD_ADDR_VAR 0 10
103286: PUSH
103287: LD_VAR 0 2
103291: PUSH
103292: LD_VAR 0 3
103296: PLUS
103297: ST_TO_ADDR
// for _x = min_x to max_x do
103298: LD_ADDR_VAR 0 5
103302: PUSH
103303: DOUBLE
103304: LD_VAR 0 8
103308: DEC
103309: ST_TO_ADDR
103310: LD_VAR 0 9
103314: PUSH
103315: FOR_TO
103316: IFFALSE 103417
// for _y = min_y to max_y do
103318: LD_ADDR_VAR 0 6
103322: PUSH
103323: DOUBLE
103324: LD_VAR 0 7
103328: DEC
103329: ST_TO_ADDR
103330: LD_VAR 0 10
103334: PUSH
103335: FOR_TO
103336: IFFALSE 103413
// begin if not ValidHex ( _x , _y ) then
103338: LD_VAR 0 5
103342: PPUSH
103343: LD_VAR 0 6
103347: PPUSH
103348: CALL_OW 488
103352: NOT
103353: IFFALSE 103357
// continue ;
103355: GO 103335
// if GetResourceTypeXY ( _x , _y ) then
103357: LD_VAR 0 5
103361: PPUSH
103362: LD_VAR 0 6
103366: PPUSH
103367: CALL_OW 283
103371: IFFALSE 103411
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
103373: LD_ADDR_VAR 0 4
103377: PUSH
103378: LD_VAR 0 4
103382: PPUSH
103383: LD_VAR 0 4
103387: PUSH
103388: LD_INT 1
103390: PLUS
103391: PPUSH
103392: LD_VAR 0 5
103396: PUSH
103397: LD_VAR 0 6
103401: PUSH
103402: EMPTY
103403: LIST
103404: LIST
103405: PPUSH
103406: CALL_OW 1
103410: ST_TO_ADDR
// end ;
103411: GO 103335
103413: POP
103414: POP
103415: GO 103315
103417: POP
103418: POP
// end ;
103419: LD_VAR 0 4
103423: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
103424: LD_INT 0
103426: PPUSH
103427: PPUSH
103428: PPUSH
103429: PPUSH
103430: PPUSH
103431: PPUSH
103432: PPUSH
103433: PPUSH
// if not units then
103434: LD_VAR 0 1
103438: NOT
103439: IFFALSE 103443
// exit ;
103441: GO 103967
// result := UnitFilter ( units , [ f_ok ] ) ;
103443: LD_ADDR_VAR 0 3
103447: PUSH
103448: LD_VAR 0 1
103452: PPUSH
103453: LD_INT 50
103455: PUSH
103456: EMPTY
103457: LIST
103458: PPUSH
103459: CALL_OW 72
103463: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
103464: LD_ADDR_VAR 0 8
103468: PUSH
103469: LD_VAR 0 1
103473: PUSH
103474: LD_INT 1
103476: ARRAY
103477: PPUSH
103478: CALL_OW 255
103482: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
103483: LD_ADDR_VAR 0 10
103487: PUSH
103488: LD_INT 29
103490: PUSH
103491: LD_INT 91
103493: PUSH
103494: LD_INT 49
103496: PUSH
103497: EMPTY
103498: LIST
103499: LIST
103500: LIST
103501: ST_TO_ADDR
// if not result then
103502: LD_VAR 0 3
103506: NOT
103507: IFFALSE 103511
// exit ;
103509: GO 103967
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
103511: LD_ADDR_VAR 0 5
103515: PUSH
103516: LD_INT 81
103518: PUSH
103519: LD_VAR 0 8
103523: PUSH
103524: EMPTY
103525: LIST
103526: LIST
103527: PPUSH
103528: CALL_OW 69
103532: ST_TO_ADDR
// for i in result do
103533: LD_ADDR_VAR 0 4
103537: PUSH
103538: LD_VAR 0 3
103542: PUSH
103543: FOR_IN
103544: IFFALSE 103965
// begin tag := GetTag ( i ) + 1 ;
103546: LD_ADDR_VAR 0 9
103550: PUSH
103551: LD_VAR 0 4
103555: PPUSH
103556: CALL_OW 110
103560: PUSH
103561: LD_INT 1
103563: PLUS
103564: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
103565: LD_ADDR_VAR 0 7
103569: PUSH
103570: LD_VAR 0 4
103574: PPUSH
103575: CALL_OW 250
103579: PPUSH
103580: LD_VAR 0 4
103584: PPUSH
103585: CALL_OW 251
103589: PPUSH
103590: LD_INT 6
103592: PPUSH
103593: CALL 103166 0 3
103597: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
103598: LD_VAR 0 4
103602: PPUSH
103603: CALL_OW 247
103607: PUSH
103608: LD_INT 2
103610: EQUAL
103611: PUSH
103612: LD_VAR 0 7
103616: AND
103617: PUSH
103618: LD_VAR 0 4
103622: PPUSH
103623: CALL_OW 264
103627: PUSH
103628: LD_VAR 0 10
103632: IN
103633: NOT
103634: AND
103635: IFFALSE 103674
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
103637: LD_VAR 0 4
103641: PPUSH
103642: LD_VAR 0 7
103646: PUSH
103647: LD_INT 1
103649: ARRAY
103650: PUSH
103651: LD_INT 1
103653: ARRAY
103654: PPUSH
103655: LD_VAR 0 7
103659: PUSH
103660: LD_INT 1
103662: ARRAY
103663: PUSH
103664: LD_INT 2
103666: ARRAY
103667: PPUSH
103668: CALL_OW 116
103672: GO 103963
// if path > tag then
103674: LD_VAR 0 2
103678: PUSH
103679: LD_VAR 0 9
103683: GREATER
103684: IFFALSE 103892
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
103686: LD_ADDR_VAR 0 6
103690: PUSH
103691: LD_VAR 0 5
103695: PPUSH
103696: LD_INT 91
103698: PUSH
103699: LD_VAR 0 4
103703: PUSH
103704: LD_INT 8
103706: PUSH
103707: EMPTY
103708: LIST
103709: LIST
103710: LIST
103711: PPUSH
103712: CALL_OW 72
103716: ST_TO_ADDR
// if nearEnemy then
103717: LD_VAR 0 6
103721: IFFALSE 103790
// begin if GetWeapon ( i ) = ru_time_lapser then
103723: LD_VAR 0 4
103727: PPUSH
103728: CALL_OW 264
103732: PUSH
103733: LD_INT 49
103735: EQUAL
103736: IFFALSE 103764
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
103738: LD_VAR 0 4
103742: PPUSH
103743: LD_VAR 0 6
103747: PPUSH
103748: LD_VAR 0 4
103752: PPUSH
103753: CALL_OW 74
103757: PPUSH
103758: CALL_OW 112
103762: GO 103788
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
103764: LD_VAR 0 4
103768: PPUSH
103769: LD_VAR 0 6
103773: PPUSH
103774: LD_VAR 0 4
103778: PPUSH
103779: CALL_OW 74
103783: PPUSH
103784: CALL_OW 115
// end else
103788: GO 103890
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
103790: LD_VAR 0 4
103794: PPUSH
103795: LD_VAR 0 2
103799: PUSH
103800: LD_VAR 0 9
103804: ARRAY
103805: PUSH
103806: LD_INT 1
103808: ARRAY
103809: PPUSH
103810: LD_VAR 0 2
103814: PUSH
103815: LD_VAR 0 9
103819: ARRAY
103820: PUSH
103821: LD_INT 2
103823: ARRAY
103824: PPUSH
103825: CALL_OW 297
103829: PUSH
103830: LD_INT 6
103832: GREATER
103833: IFFALSE 103876
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
103835: LD_VAR 0 4
103839: PPUSH
103840: LD_VAR 0 2
103844: PUSH
103845: LD_VAR 0 9
103849: ARRAY
103850: PUSH
103851: LD_INT 1
103853: ARRAY
103854: PPUSH
103855: LD_VAR 0 2
103859: PUSH
103860: LD_VAR 0 9
103864: ARRAY
103865: PUSH
103866: LD_INT 2
103868: ARRAY
103869: PPUSH
103870: CALL_OW 114
103874: GO 103890
// SetTag ( i , tag ) ;
103876: LD_VAR 0 4
103880: PPUSH
103881: LD_VAR 0 9
103885: PPUSH
103886: CALL_OW 109
// end else
103890: GO 103963
// if enemy then
103892: LD_VAR 0 5
103896: IFFALSE 103963
// begin if GetWeapon ( i ) = ru_time_lapser then
103898: LD_VAR 0 4
103902: PPUSH
103903: CALL_OW 264
103907: PUSH
103908: LD_INT 49
103910: EQUAL
103911: IFFALSE 103939
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103913: LD_VAR 0 4
103917: PPUSH
103918: LD_VAR 0 5
103922: PPUSH
103923: LD_VAR 0 4
103927: PPUSH
103928: CALL_OW 74
103932: PPUSH
103933: CALL_OW 112
103937: GO 103963
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
103939: LD_VAR 0 4
103943: PPUSH
103944: LD_VAR 0 5
103948: PPUSH
103949: LD_VAR 0 4
103953: PPUSH
103954: CALL_OW 74
103958: PPUSH
103959: CALL_OW 115
// end ; end ;
103963: GO 103543
103965: POP
103966: POP
// end ;
103967: LD_VAR 0 3
103971: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
103972: LD_INT 0
103974: PPUSH
103975: PPUSH
103976: PPUSH
// if not unit or IsInUnit ( unit ) then
103977: LD_VAR 0 1
103981: NOT
103982: PUSH
103983: LD_VAR 0 1
103987: PPUSH
103988: CALL_OW 310
103992: OR
103993: IFFALSE 103997
// exit ;
103995: GO 104088
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
103997: LD_ADDR_VAR 0 4
104001: PUSH
104002: LD_VAR 0 1
104006: PPUSH
104007: CALL_OW 250
104011: PPUSH
104012: LD_VAR 0 2
104016: PPUSH
104017: LD_INT 1
104019: PPUSH
104020: CALL_OW 272
104024: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
104025: LD_ADDR_VAR 0 5
104029: PUSH
104030: LD_VAR 0 1
104034: PPUSH
104035: CALL_OW 251
104039: PPUSH
104040: LD_VAR 0 2
104044: PPUSH
104045: LD_INT 1
104047: PPUSH
104048: CALL_OW 273
104052: ST_TO_ADDR
// if ValidHex ( x , y ) then
104053: LD_VAR 0 4
104057: PPUSH
104058: LD_VAR 0 5
104062: PPUSH
104063: CALL_OW 488
104067: IFFALSE 104088
// ComTurnXY ( unit , x , y ) ;
104069: LD_VAR 0 1
104073: PPUSH
104074: LD_VAR 0 4
104078: PPUSH
104079: LD_VAR 0 5
104083: PPUSH
104084: CALL_OW 118
// end ;
104088: LD_VAR 0 3
104092: RET
// export function SeeUnits ( side , units ) ; var i ; begin
104093: LD_INT 0
104095: PPUSH
104096: PPUSH
// result := false ;
104097: LD_ADDR_VAR 0 3
104101: PUSH
104102: LD_INT 0
104104: ST_TO_ADDR
// if not units then
104105: LD_VAR 0 2
104109: NOT
104110: IFFALSE 104114
// exit ;
104112: GO 104159
// for i in units do
104114: LD_ADDR_VAR 0 4
104118: PUSH
104119: LD_VAR 0 2
104123: PUSH
104124: FOR_IN
104125: IFFALSE 104157
// if See ( side , i ) then
104127: LD_VAR 0 1
104131: PPUSH
104132: LD_VAR 0 4
104136: PPUSH
104137: CALL_OW 292
104141: IFFALSE 104155
// begin result := true ;
104143: LD_ADDR_VAR 0 3
104147: PUSH
104148: LD_INT 1
104150: ST_TO_ADDR
// exit ;
104151: POP
104152: POP
104153: GO 104159
// end ;
104155: GO 104124
104157: POP
104158: POP
// end ;
104159: LD_VAR 0 3
104163: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
104164: LD_INT 0
104166: PPUSH
104167: PPUSH
104168: PPUSH
104169: PPUSH
// if not unit or not points then
104170: LD_VAR 0 1
104174: NOT
104175: PUSH
104176: LD_VAR 0 2
104180: NOT
104181: OR
104182: IFFALSE 104186
// exit ;
104184: GO 104276
// dist := 99999 ;
104186: LD_ADDR_VAR 0 5
104190: PUSH
104191: LD_INT 99999
104193: ST_TO_ADDR
// for i in points do
104194: LD_ADDR_VAR 0 4
104198: PUSH
104199: LD_VAR 0 2
104203: PUSH
104204: FOR_IN
104205: IFFALSE 104274
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
104207: LD_ADDR_VAR 0 6
104211: PUSH
104212: LD_VAR 0 1
104216: PPUSH
104217: LD_VAR 0 4
104221: PUSH
104222: LD_INT 1
104224: ARRAY
104225: PPUSH
104226: LD_VAR 0 4
104230: PUSH
104231: LD_INT 2
104233: ARRAY
104234: PPUSH
104235: CALL_OW 297
104239: ST_TO_ADDR
// if tmpDist < dist then
104240: LD_VAR 0 6
104244: PUSH
104245: LD_VAR 0 5
104249: LESS
104250: IFFALSE 104272
// begin result := i ;
104252: LD_ADDR_VAR 0 3
104256: PUSH
104257: LD_VAR 0 4
104261: ST_TO_ADDR
// dist := tmpDist ;
104262: LD_ADDR_VAR 0 5
104266: PUSH
104267: LD_VAR 0 6
104271: ST_TO_ADDR
// end ; end ;
104272: GO 104204
104274: POP
104275: POP
// end ;
104276: LD_VAR 0 3
104280: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104281: LD_INT 0
104283: PPUSH
// uc_side := side ;
104284: LD_ADDR_OWVAR 20
104288: PUSH
104289: LD_VAR 0 1
104293: ST_TO_ADDR
// uc_nation := 3 ;
104294: LD_ADDR_OWVAR 21
104298: PUSH
104299: LD_INT 3
104301: ST_TO_ADDR
// vc_chassis := 25 ;
104302: LD_ADDR_OWVAR 37
104306: PUSH
104307: LD_INT 25
104309: ST_TO_ADDR
// vc_engine := engine_siberite ;
104310: LD_ADDR_OWVAR 39
104314: PUSH
104315: LD_INT 3
104317: ST_TO_ADDR
// vc_control := control_computer ;
104318: LD_ADDR_OWVAR 38
104322: PUSH
104323: LD_INT 3
104325: ST_TO_ADDR
// vc_weapon := 59 ;
104326: LD_ADDR_OWVAR 40
104330: PUSH
104331: LD_INT 59
104333: ST_TO_ADDR
// result := CreateVehicle ;
104334: LD_ADDR_VAR 0 5
104338: PUSH
104339: CALL_OW 45
104343: ST_TO_ADDR
// SetDir ( result , d ) ;
104344: LD_VAR 0 5
104348: PPUSH
104349: LD_VAR 0 4
104353: PPUSH
104354: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
104358: LD_VAR 0 5
104362: PPUSH
104363: LD_VAR 0 2
104367: PPUSH
104368: LD_VAR 0 3
104372: PPUSH
104373: LD_INT 0
104375: PPUSH
104376: CALL_OW 48
// end ;
104380: LD_VAR 0 5
104384: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
104385: LD_INT 0
104387: PPUSH
104388: PPUSH
104389: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
104390: LD_ADDR_VAR 0 2
104394: PUSH
104395: LD_INT 0
104397: PUSH
104398: LD_INT 0
104400: PUSH
104401: LD_INT 0
104403: PUSH
104404: LD_INT 0
104406: PUSH
104407: EMPTY
104408: LIST
104409: LIST
104410: LIST
104411: LIST
104412: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
104413: LD_VAR 0 1
104417: NOT
104418: PUSH
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 264
104428: PUSH
104429: LD_INT 12
104431: PUSH
104432: LD_INT 51
104434: PUSH
104435: LD_INT 32
104437: PUSH
104438: LD_INT 89
104440: PUSH
104441: EMPTY
104442: LIST
104443: LIST
104444: LIST
104445: LIST
104446: IN
104447: NOT
104448: OR
104449: IFFALSE 104453
// exit ;
104451: GO 104551
// for i := 1 to 3 do
104453: LD_ADDR_VAR 0 3
104457: PUSH
104458: DOUBLE
104459: LD_INT 1
104461: DEC
104462: ST_TO_ADDR
104463: LD_INT 3
104465: PUSH
104466: FOR_TO
104467: IFFALSE 104549
// begin tmp := GetCargo ( cargo , i ) ;
104469: LD_ADDR_VAR 0 4
104473: PUSH
104474: LD_VAR 0 1
104478: PPUSH
104479: LD_VAR 0 3
104483: PPUSH
104484: CALL_OW 289
104488: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
104489: LD_ADDR_VAR 0 2
104493: PUSH
104494: LD_VAR 0 2
104498: PPUSH
104499: LD_VAR 0 3
104503: PPUSH
104504: LD_VAR 0 4
104508: PPUSH
104509: CALL_OW 1
104513: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
104514: LD_ADDR_VAR 0 2
104518: PUSH
104519: LD_VAR 0 2
104523: PPUSH
104524: LD_INT 4
104526: PPUSH
104527: LD_VAR 0 2
104531: PUSH
104532: LD_INT 4
104534: ARRAY
104535: PUSH
104536: LD_VAR 0 4
104540: PLUS
104541: PPUSH
104542: CALL_OW 1
104546: ST_TO_ADDR
// end ;
104547: GO 104466
104549: POP
104550: POP
// end ;
104551: LD_VAR 0 2
104555: RET
// export function Length ( array ) ; begin
104556: LD_INT 0
104558: PPUSH
// result := array + 0 ;
104559: LD_ADDR_VAR 0 2
104563: PUSH
104564: LD_VAR 0 1
104568: PUSH
104569: LD_INT 0
104571: PLUS
104572: ST_TO_ADDR
// end ;
104573: LD_VAR 0 2
104577: RET
// export function PrepareArray ( array ) ; begin
104578: LD_INT 0
104580: PPUSH
// result := array diff 0 ;
104581: LD_ADDR_VAR 0 2
104585: PUSH
104586: LD_VAR 0 1
104590: PUSH
104591: LD_INT 0
104593: DIFF
104594: ST_TO_ADDR
// if not result [ 1 ] then
104595: LD_VAR 0 2
104599: PUSH
104600: LD_INT 1
104602: ARRAY
104603: NOT
104604: IFFALSE 104624
// result := Delete ( result , 1 ) ;
104606: LD_ADDR_VAR 0 2
104610: PUSH
104611: LD_VAR 0 2
104615: PPUSH
104616: LD_INT 1
104618: PPUSH
104619: CALL_OW 3
104623: ST_TO_ADDR
// end ;
104624: LD_VAR 0 2
104628: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
104629: LD_INT 0
104631: PPUSH
104632: PPUSH
104633: PPUSH
104634: PPUSH
// sibRocketRange := 25 ;
104635: LD_ADDR_VAR 0 6
104639: PUSH
104640: LD_INT 25
104642: ST_TO_ADDR
// result := false ;
104643: LD_ADDR_VAR 0 4
104647: PUSH
104648: LD_INT 0
104650: ST_TO_ADDR
// for i := 0 to 5 do
104651: LD_ADDR_VAR 0 5
104655: PUSH
104656: DOUBLE
104657: LD_INT 0
104659: DEC
104660: ST_TO_ADDR
104661: LD_INT 5
104663: PUSH
104664: FOR_TO
104665: IFFALSE 104732
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
104667: LD_VAR 0 1
104671: PPUSH
104672: LD_VAR 0 5
104676: PPUSH
104677: LD_VAR 0 6
104681: PPUSH
104682: CALL_OW 272
104686: PPUSH
104687: LD_VAR 0 2
104691: PPUSH
104692: LD_VAR 0 5
104696: PPUSH
104697: LD_VAR 0 6
104701: PPUSH
104702: CALL_OW 273
104706: PPUSH
104707: LD_VAR 0 3
104711: PPUSH
104712: CALL_OW 309
104716: IFFALSE 104730
// begin result := true ;
104718: LD_ADDR_VAR 0 4
104722: PUSH
104723: LD_INT 1
104725: ST_TO_ADDR
// exit ;
104726: POP
104727: POP
104728: GO 104734
// end ;
104730: GO 104664
104732: POP
104733: POP
// end ;
104734: LD_VAR 0 4
104738: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
104739: LD_INT 0
104741: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
104742: LD_VAR 0 1
104746: PPUSH
104747: LD_VAR 0 2
104751: PPUSH
104752: LD_INT 0
104754: PPUSH
104755: LD_INT 0
104757: PPUSH
104758: LD_INT 1
104760: PPUSH
104761: LD_INT 0
104763: PPUSH
104764: CALL_OW 587
// end ; end_of_file
104768: LD_VAR 0 3
104772: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
104773: LD_VAR 0 1
104777: PUSH
104778: LD_INT 200
104780: DOUBLE
104781: GREATEREQUAL
104782: IFFALSE 104790
104784: LD_INT 299
104786: DOUBLE
104787: LESSEQUAL
104788: IFTRUE 104792
104790: GO 104824
104792: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
104793: LD_VAR 0 1
104797: PPUSH
104798: LD_VAR 0 2
104802: PPUSH
104803: LD_VAR 0 3
104807: PPUSH
104808: LD_VAR 0 4
104812: PPUSH
104813: LD_VAR 0 5
104817: PPUSH
104818: CALL 59439 0 5
104822: GO 104901
104824: LD_INT 300
104826: DOUBLE
104827: GREATEREQUAL
104828: IFFALSE 104836
104830: LD_INT 399
104832: DOUBLE
104833: LESSEQUAL
104834: IFTRUE 104838
104836: GO 104900
104838: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
104839: LD_VAR 0 1
104843: PPUSH
104844: LD_VAR 0 2
104848: PPUSH
104849: LD_VAR 0 3
104853: PPUSH
104854: LD_VAR 0 4
104858: PPUSH
104859: LD_VAR 0 5
104863: PPUSH
104864: LD_VAR 0 6
104868: PPUSH
104869: LD_VAR 0 7
104873: PPUSH
104874: LD_VAR 0 8
104878: PPUSH
104879: LD_VAR 0 9
104883: PPUSH
104884: LD_VAR 0 10
104888: PPUSH
104889: LD_VAR 0 11
104893: PPUSH
104894: CALL 55772 0 11
104898: GO 104901
104900: POP
// end ;
104901: PPOPN 11
104903: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
104904: LD_VAR 0 1
104908: PPUSH
104909: LD_VAR 0 2
104913: PPUSH
104914: LD_VAR 0 3
104918: PPUSH
104919: LD_VAR 0 4
104923: PPUSH
104924: LD_VAR 0 5
104928: PPUSH
104929: CALL 59175 0 5
// end ; end_of_file
104933: PPOPN 5
104935: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
104936: LD_VAR 0 1
104940: PPUSH
104941: LD_VAR 0 2
104945: PPUSH
104946: LD_VAR 0 3
104950: PPUSH
104951: LD_VAR 0 4
104955: PPUSH
104956: LD_VAR 0 5
104960: PPUSH
104961: LD_VAR 0 6
104965: PPUSH
104966: CALL 43392 0 6
// end ;
104970: PPOPN 6
104972: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
104973: LD_INT 0
104975: PPUSH
// begin if not units then
104976: LD_VAR 0 1
104980: NOT
104981: IFFALSE 104985
// exit ;
104983: GO 104985
// end ;
104985: PPOPN 7
104987: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
104988: CALL 43286 0 0
// end ;
104992: PPOPN 1
104994: END
