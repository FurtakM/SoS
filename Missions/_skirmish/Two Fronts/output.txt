// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7695 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4864 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41681 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42132 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21435 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21371 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18364 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21271 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22285 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21512 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21305 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21338 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18143 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22193 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20450 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21025 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21025 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20822 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20486 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20662 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19946 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20560 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21061 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21801 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21371 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18364 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21271 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21512 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18143 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22193 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20450 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21025 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21025 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20822 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20486 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20662 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19946 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20560 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21061 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21801 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19946 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11651 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22019 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11651 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22019 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11651 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22019 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11651 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22019 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7914 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7914 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7914 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7914 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7914 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18364 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4861
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4859
// begin PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4785: LD_EXP 22
4789: PUSH
4790: LD_INT 1
4792: ARRAY
4793: PPUSH
4794: LD_INT 18
4796: PPUSH
4797: LD_INT 0
4799: PPUSH
4800: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4804: LD_EXP 22
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 107
4815: PPUSH
4816: LD_INT 88
4818: PPUSH
4819: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4823: LD_EXP 22
4827: PUSH
4828: LD_INT 1
4830: ARRAY
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4839: LD_ADDR_EXP 22
4843: PUSH
4844: LD_EXP 22
4848: PPUSH
4849: LD_INT 1
4851: PPUSH
4852: CALL_OW 3
4856: ST_TO_ADDR
// end ;
4857: GO 4782
4859: POP
4860: POP
// end ;
4861: PPOPN 1
4863: END
// export function Dialog ; var i ; begin
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
// if not isTest then
4868: LD_EXP 1
4872: NOT
4873: IFFALSE 4895
// case query ( task ) of 1 :
4875: LD_STRING task
4877: PPUSH
4878: CALL_OW 97
4882: PUSH
4883: LD_INT 1
4885: DOUBLE
4886: EQUAL
4887: IFTRUE 4891
4889: GO 4894
4891: POP
// ; end ;
4892: GO 4895
4894: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4895: LD_INT 105
4897: PPUSH
4898: LD_INT 84
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 30
4906: NEG
4907: PPUSH
4908: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4912: LD_INT 105
4914: PPUSH
4915: LD_INT 84
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: CALL_OW 331
// InGameOn ;
4925: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4929: LD_INT 128
4931: PPUSH
4932: LD_INT 64
4934: PPUSH
4935: CALL_OW 86
// if isTest then
4939: LD_EXP 1
4943: IFFALSE 4953
// dialogue_skipped := true ;
4945: LD_ADDR_OWVAR 59
4949: PUSH
4950: LD_INT 1
4952: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4965: LD_EXP 24
4969: PPUSH
4970: LD_STRING DR2
4972: PPUSH
4973: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4977: LD_EXP 24
4981: PPUSH
4982: LD_STRING DR3
4984: PPUSH
4985: CALL_OW 94
// InGameOff ;
4989: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4993: LD_STRING C1
4995: PPUSH
4996: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5000: LD_INT 35
5002: PPUSH
5003: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5007: LD_INT 9
5009: PPUSH
5010: LD_INT 22
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 70
5024: IFFALSE 5000
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 9
5033: PPUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 6
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 70
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5066
// SetSide ( i , 3 ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 3
5059: PPUSH
5060: CALL_OW 235
5064: GO 5049
5066: POP
5067: POP
// if not isTest then
5068: LD_EXP 1
5072: NOT
5073: IFFALSE 5095
// case query ( support ) of 1 :
5075: LD_STRING support
5077: PPUSH
5078: CALL_OW 97
5082: PUSH
5083: LD_INT 1
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5094
5091: POP
// ; end ;
5092: GO 5095
5094: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 12
5100: PPUSH
5101: LD_INT 2
5103: PPUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 0
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 468
// if player_com = stolypin then
5141: LD_EXP 23
5145: PUSH
5146: LD_EXP 21
5150: EQUAL
5151: IFFALSE 5180
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5153: LD_INT 18
5155: PPUSH
5156: LD_INT 3
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_OWVAR 67
5174: ARRAY
5175: PPUSH
5176: CALL 6592 0 2
// end ;
5180: LD_VAR 0 1
5184: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5185: LD_EXP 11
5189: PUSH
5190: LD_OWVAR 1
5194: PUSH
5195: LD_INT 31500
5197: LESS
5198: AND
5199: IFFALSE 5367
// case query ( call1 ) of 1 :
5201: LD_STRING call1
5203: PPUSH
5204: CALL_OW 97
5208: PUSH
5209: LD_INT 1
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5355
5217: POP
// begin callUsed := true ;
5218: LD_ADDR_EXP 3
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 12
5231: PPUSH
5232: LD_INT 1
5234: PPUSH
5235: LD_INT 1
5237: PPUSH
5238: CALL_OW 468
// call := false ;
5242: LD_ADDR_EXP 11
5246: PUSH
5247: LD_INT 0
5249: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5250: LD_EXP 24
5254: PPUSH
5255: LD_STRING DR6
5257: PPUSH
5258: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5262: LD_INT 6300
5264: PPUSH
5265: LD_INT 8400
5267: PPUSH
5268: CALL_OW 12
5272: PPUSH
5273: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5277: LD_INT 18
5279: PUSH
5280: LD_INT 19
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 1
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: CALL_OW 12
5297: ARRAY
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: PPUSH
5310: CALL 6592 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5314: LD_INT 25200
5316: PPUSH
5317: LD_INT 35700
5319: PPUSH
5320: CALL_OW 12
5324: PPUSH
5325: CALL_OW 67
// call := true ;
5329: LD_ADDR_EXP 11
5333: PUSH
5334: LD_INT 1
5336: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 12
5342: PPUSH
5343: LD_INT 2
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 468
// end ; 2 :
5353: GO 5367
5355: LD_INT 2
5357: DOUBLE
5358: EQUAL
5359: IFTRUE 5363
5361: GO 5366
5363: POP
// ; end ;
5364: GO 5367
5366: POP
// if call and tick >= 15 15$00 then
5367: LD_EXP 11
5371: PUSH
5372: LD_OWVAR 1
5376: PUSH
5377: LD_INT 31500
5379: GREATEREQUAL
5380: AND
5381: IFFALSE 5820
// case query ( call2 ) of 1 :
5383: LD_STRING call2
5385: PPUSH
5386: CALL_OW 97
5390: PUSH
5391: LD_INT 1
5393: DOUBLE
5394: EQUAL
5395: IFTRUE 5399
5397: GO 5641
5399: POP
// begin callUsed := true ;
5400: LD_ADDR_EXP 3
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// call := false ;
5408: LD_ADDR_EXP 11
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5416: LD_INT 1
5418: PPUSH
5419: LD_INT 21
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL 11651 0 2
5433: PUSH
5434: LD_INT 4
5436: PPUSH
5437: LD_INT 21
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PPUSH
5447: CALL 11651 0 2
5451: AND
5452: IFFALSE 5500
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5454: LD_INT 18
5456: PUSH
5457: LD_INT 19
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 1
5466: PPUSH
5467: LD_INT 2
5469: PPUSH
5470: CALL_OW 12
5474: ARRAY
5475: PPUSH
5476: LD_INT 5
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PPUSH
5496: CALL 6353 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5500: LD_INT 1
5502: PPUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PPUSH
5513: CALL 11651 0 2
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5550
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5523: LD_INT 19
5525: PPUSH
5526: LD_INT 5
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: CALL 6353 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5550: LD_INT 4
5552: PPUSH
5553: LD_INT 21
5555: PUSH
5556: LD_INT 3
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 11651 0 2
5567: PUSH
5568: LD_INT 0
5570: EQUAL
5571: IFFALSE 5600
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5573: LD_INT 18
5575: PPUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 4
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_OWVAR 67
5594: ARRAY
5595: PPUSH
5596: CALL 6353 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5600: LD_INT 10500
5602: PPUSH
5603: LD_INT 23100
5605: PPUSH
5606: CALL_OW 12
5610: PPUSH
5611: CALL_OW 67
// call := true ;
5615: LD_ADDR_EXP 11
5619: PUSH
5620: LD_INT 1
5622: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_INT 12
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: LD_INT 1
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5820
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5808
5649: POP
// begin callUsed := true ;
5650: LD_ADDR_EXP 3
5654: PUSH
5655: LD_INT 1
5657: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 1
5669: PPUSH
5670: CALL_OW 468
// call := false ;
5674: LD_ADDR_EXP 11
5678: PUSH
5679: LD_INT 0
5681: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5682: LD_EXP 24
5686: PPUSH
5687: LD_STRING DR6
5689: PPUSH
5690: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5694: LD_INT 6300
5696: PPUSH
5697: LD_INT 8400
5699: PPUSH
5700: CALL_OW 12
5704: PPUSH
5705: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5709: LD_INT 18
5711: PUSH
5712: LD_INT 19
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 1
5721: PPUSH
5722: LD_INT 2
5724: PPUSH
5725: CALL_OW 12
5729: ARRAY
5730: PPUSH
5731: LD_INT 3
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 2
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_OWVAR 67
5749: ARRAY
5750: PUSH
5751: LD_INT 0
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 12
5761: MINUS
5762: PPUSH
5763: CALL 6592 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5767: LD_INT 35700
5769: PPUSH
5770: LD_INT 44100
5772: PPUSH
5773: CALL_OW 12
5777: PPUSH
5778: CALL_OW 67
// call := true ;
5782: LD_ADDR_EXP 11
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 12
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 468
// end ; 3 :
5806: GO 5820
5808: LD_INT 3
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5819
5816: POP
// ; end ;
5817: GO 5820
5819: POP
// end ;
5820: PPOPN 4
5822: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_INT 0
5854: EQUAL
5855: PUSH
5856: LD_INT 22
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 21
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: AND
5889: IFFALSE 6193
5891: GO 5893
5893: DISABLE
// begin DialogueOn ;
5894: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5898: LD_EXP 24
5902: PPUSH
5903: LD_STRING DR7
5905: PPUSH
5906: CALL_OW 94
// case player_com of Gorki :
5910: LD_EXP 23
5914: PUSH
5915: LD_EXP 20
5919: DOUBLE
5920: EQUAL
5921: IFTRUE 5925
5923: GO 5935
5925: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5926: LD_STRING ACH_GORKI
5928: PPUSH
5929: CALL_OW 543
5933: GO 5996
5935: LD_EXP 21
5939: DOUBLE
5940: EQUAL
5941: IFTRUE 5945
5943: GO 5955
5945: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5946: LD_STRING ACH_STOLYP
5948: PPUSH
5949: CALL_OW 543
5953: GO 5996
5955: LD_EXP 19
5959: DOUBLE
5960: EQUAL
5961: IFTRUE 5965
5963: GO 5975
5965: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5966: LD_STRING ACH_DAVIDOV
5968: PPUSH
5969: CALL_OW 543
5973: GO 5996
5975: LD_EXP 18
5979: DOUBLE
5980: EQUAL
5981: IFTRUE 5985
5983: GO 5995
5985: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5986: LD_STRING ACH_GLADKOV
5988: PPUSH
5989: CALL_OW 543
5993: GO 5996
5995: POP
// if not callUsed then
5996: LD_EXP 3
6000: NOT
6001: IFFALSE 6010
// SetAchievement ( ACH_NOSUPP ) ;
6003: LD_STRING ACH_NOSUPP
6005: PPUSH
6006: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6010: LD_OWVAR 1
6014: PUSH
6015: LD_INT 116550
6017: PUSH
6018: LD_INT 95550
6020: PUSH
6021: LD_INT 89250
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_OWVAR 67
6033: ARRAY
6034: LESS
6035: IFFALSE 6049
// AddMedal ( med1 , 1 ) else
6037: LD_STRING med1
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med1 , - 1 ) ;
6049: LD_STRING med1
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6060: LD_INT 81
6062: PUSH
6063: LD_INT 3
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 21
6072: PUSH
6073: LD_INT 3
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PUSH
6089: LD_INT 0
6091: EQUAL
6092: IFFALSE 6106
// AddMedal ( med3 , 1 ) else
6094: LD_STRING med3
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 101
6104: GO 6117
// AddMedal ( med3 , - 1 ) ;
6106: LD_STRING med3
6108: PPUSH
6109: LD_INT 1
6111: NEG
6112: PPUSH
6113: CALL_OW 101
// if player_loss = 0 then
6117: LD_EXP 10
6121: PUSH
6122: LD_INT 0
6124: EQUAL
6125: IFFALSE 6139
// AddMedal ( med2 , 1 ) else
6127: LD_STRING med2
6129: PPUSH
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 101
6137: GO 6182
// if player_loss > 0 and player_loss < 3 then
6139: LD_EXP 10
6143: PUSH
6144: LD_INT 0
6146: GREATER
6147: PUSH
6148: LD_EXP 10
6152: PUSH
6153: LD_INT 3
6155: LESS
6156: AND
6157: IFFALSE 6171
// AddMedal ( med2 , 2 ) else
6159: LD_STRING med2
6161: PPUSH
6162: LD_INT 2
6164: PPUSH
6165: CALL_OW 101
6169: GO 6182
// AddMedal ( med2 , - 1 ) ;
6171: LD_STRING med2
6173: PPUSH
6174: LD_INT 1
6176: NEG
6177: PPUSH
6178: CALL_OW 101
// GiveMedals ( MAIN ) ;
6182: LD_STRING MAIN
6184: PPUSH
6185: CALL_OW 102
// YouWin ;
6189: CALL_OW 103
// end ;
6193: END
// every 0 0$01 trigger IsDead ( player_com ) do
6194: LD_EXP 23
6198: PPUSH
6199: CALL_OW 301
6203: IFFALSE 6270
6205: GO 6207
6207: DISABLE
// begin if IsLive ( Houten ) then
6208: LD_EXP 4
6212: PPUSH
6213: CALL_OW 300
6217: IFFALSE 6233
// SayRadio ( Houten , DJ5 ) else
6219: LD_EXP 4
6223: PPUSH
6224: LD_STRING DJ5
6226: PPUSH
6227: CALL_OW 94
6231: GO 6256
// if IsLive ( Brown ) then
6233: LD_EXP 5
6237: PPUSH
6238: CALL_OW 300
6242: IFFALSE 6256
// SayRadio ( Brown , DS5 ) ;
6244: LD_EXP 5
6248: PPUSH
6249: LD_STRING DS5
6251: PPUSH
6252: CALL_OW 94
// Wait ( 0 0$01 ) ;
6256: LD_INT 35
6258: PPUSH
6259: CALL_OW 67
// YouLost ( dead ) ;
6263: LD_STRING dead
6265: PPUSH
6266: CALL_OW 104
// end ;
6270: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 301
6278: PUSH
6279: LD_EXP 1
6283: NOT
6284: AND
6285: IFFALSE 6352
6287: GO 6289
6289: DISABLE
// begin if IsLive ( Brown ) then
6290: LD_EXP 5
6294: PPUSH
6295: CALL_OW 300
6299: IFFALSE 6315
// SayRadio ( Brown , DS5 ) else
6301: LD_EXP 5
6305: PPUSH
6306: LD_STRING DS5
6308: PPUSH
6309: CALL_OW 94
6313: GO 6338
// if IsLive ( Houten ) then
6315: LD_EXP 4
6319: PPUSH
6320: CALL_OW 300
6324: IFFALSE 6338
// SayRadio ( Houten , DJ5 ) ;
6326: LD_EXP 4
6330: PPUSH
6331: LD_STRING DJ5
6333: PPUSH
6334: CALL_OW 94
// Wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// YouLost ( depot ) ;
6345: LD_STRING depot
6347: PPUSH
6348: CALL_OW 104
// end ;
6352: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
// for i = 1 to n do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6577
// begin uc_side := 6 ;
6376: LD_ADDR_OWVAR 20
6380: PUSH
6381: LD_INT 6
6383: ST_TO_ADDR
// uc_nation := 3 ;
6384: LD_ADDR_OWVAR 21
6388: PUSH
6389: LD_INT 3
6391: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6392: LD_ADDR_OWVAR 37
6396: PUSH
6397: LD_INT 23
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: ST_TO_ADDR
// vc_control := control_computer ;
6419: LD_ADDR_OWVAR 38
6423: PUSH
6424: LD_INT 3
6426: ST_TO_ADDR
// vc_engine := engine_siberite ;
6427: LD_ADDR_OWVAR 39
6431: PUSH
6432: LD_INT 3
6434: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6435: LD_ADDR_OWVAR 40
6439: PUSH
6440: LD_INT 43
6442: PUSH
6443: LD_INT 44
6445: PUSH
6446: LD_INT 44
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: CALL_OW 12
6464: ARRAY
6465: ST_TO_ADDR
// un := CreateVehicle ;
6466: LD_ADDR_VAR 0 5
6470: PUSH
6471: CALL_OW 45
6475: ST_TO_ADDR
// case area of east_arr :
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 18
6483: DOUBLE
6484: EQUAL
6485: IFTRUE 6489
6487: GO 6524
6489: POP
// begin PlaceUnitArea ( un , area , false ) ;
6490: LD_VAR 0 5
6494: PPUSH
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_INT 0
6502: PPUSH
6503: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6507: LD_VAR 0 5
6511: PPUSH
6512: LD_INT 79
6514: PPUSH
6515: LD_INT 33
6517: PPUSH
6518: CALL_OW 111
// end ; south_arr :
6522: GO 6568
6524: LD_INT 19
6526: DOUBLE
6527: EQUAL
6528: IFTRUE 6532
6530: GO 6567
6532: POP
// begin PlaceUnitArea ( un , area , false ) ;
6533: LD_VAR 0 5
6537: PPUSH
6538: LD_VAR 0 1
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_INT 131
6557: PPUSH
6558: LD_INT 148
6560: PPUSH
6561: CALL_OW 111
// end ; end ;
6565: GO 6568
6567: POP
// Wait ( 0 0$02 ) ;
6568: LD_INT 70
6570: PPUSH
6571: CALL_OW 67
// end ;
6575: GO 6373
6577: POP
6578: POP
// pink_attack := true ;
6579: LD_ADDR_EXP 12
6583: PUSH
6584: LD_INT 1
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 3
6591: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// for i = 1 to n do
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: DOUBLE
6603: LD_INT 1
6605: DEC
6606: ST_TO_ADDR
6607: LD_VAR 0 2
6611: PUSH
6612: FOR_TO
6613: IFFALSE 6839
// begin uc_side := 6 ;
6615: LD_ADDR_OWVAR 20
6619: PUSH
6620: LD_INT 6
6622: ST_TO_ADDR
// uc_nation := 3 ;
6623: LD_ADDR_OWVAR 21
6627: PUSH
6628: LD_INT 3
6630: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6631: LD_INT 0
6633: PPUSH
6634: LD_INT 3
6636: PPUSH
6637: LD_INT 4
6639: PPUSH
6640: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6644: LD_ADDR_OWVAR 37
6648: PUSH
6649: LD_INT 22
6651: ST_TO_ADDR
// vc_control := control_manual ;
6652: LD_ADDR_OWVAR 38
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// vc_engine := engine_combustion ;
6660: LD_ADDR_OWVAR 39
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6668: LD_ADDR_OWVAR 40
6672: PUSH
6673: LD_INT 51
6675: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6676: LD_ADDR_OWVAR 41
6680: PUSH
6681: LD_INT 50
6683: ST_TO_ADDR
// un := CreateVehicle ;
6684: LD_ADDR_VAR 0 5
6688: PUSH
6689: CALL_OW 45
6693: ST_TO_ADDR
// case area of east_arr :
6694: LD_VAR 0 1
6698: PUSH
6699: LD_INT 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6722
6707: POP
// SetDir ( un , 4 ) ; south_arr :
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: CALL_OW 233
6720: GO 6746
6722: LD_INT 19
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6745
6730: POP
// SetDir ( un , 5 ) ; end ;
6731: LD_VAR 0 5
6735: PPUSH
6736: LD_INT 5
6738: PPUSH
6739: CALL_OW 233
6743: GO 6746
6745: POP
// PlaceUnitArea ( un , area , false ) ;
6746: LD_VAR 0 5
6750: PPUSH
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6763: CALL_OW 44
6767: PPUSH
6768: LD_VAR 0 5
6772: PPUSH
6773: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6777: LD_VAR 0 5
6781: PPUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 100
6787: PPUSH
6788: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6792: LD_VAR 0 5
6796: PPUSH
6797: LD_INT 106
6799: PPUSH
6800: LD_INT 88
6802: PPUSH
6803: CALL_OW 111
// AddComUnload ( un ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 173
// Wait ( 0 0$02 ) ;
6830: LD_INT 70
6832: PPUSH
6833: CALL_OW 67
// end ;
6837: GO 6612
6839: POP
6840: POP
// Wait ( 0 0$05 ) ;
6841: LD_INT 175
6843: PPUSH
6844: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6848: LD_INT 6
6850: PPUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 51
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL 11651 0 2
6865: IFFALSE 7053
// begin wait ( 0 0$01 ) ;
6867: LD_INT 35
6869: PPUSH
6870: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6874: LD_ADDR_VAR 0 4
6878: PUSH
6879: LD_INT 6
6881: PPUSH
6882: LD_INT 34
6884: PUSH
6885: LD_INT 51
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL 11651 0 2
6896: PUSH
6897: FOR_IN
6898: IFFALSE 7049
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6900: LD_VAR 0 4
6904: PPUSH
6905: LD_INT 9
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 4
6917: PPUSH
6918: CALL 31773 0 1
6922: PPUSH
6923: CALL_OW 258
6927: PUSH
6928: LD_INT 1
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 9
6937: AND
6938: IFFALSE 6965
// begin Say ( GetDriver ( i ) , Dtran ) ;
6940: LD_VAR 0 4
6944: PPUSH
6945: CALL 31773 0 1
6949: PPUSH
6950: LD_STRING Dtran
6952: PPUSH
6953: CALL_OW 88
// dialog_trans := false ;
6957: LD_ADDR_EXP 9
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6965: LD_VAR 0 4
6969: PPUSH
6970: CALL_OW 316
6974: IFFALSE 6990
// ComMoveToArea ( i , area ) ;
6976: LD_VAR 0 4
6980: PPUSH
6981: LD_VAR 0 1
6985: PPUSH
6986: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6990: LD_VAR 0 4
6994: PPUSH
6995: LD_VAR 0 1
6999: PPUSH
7000: CALL_OW 308
7004: PUSH
7005: LD_VAR 0 4
7009: PPUSH
7010: LD_INT 1
7012: PPUSH
7013: CALL_OW 289
7017: PUSH
7018: LD_INT 0
7020: EQUAL
7021: AND
7022: IFFALSE 7047
// begin RemoveUnit ( GetDriver ( i ) ) ;
7024: LD_VAR 0 4
7028: PPUSH
7029: CALL 31773 0 1
7033: PPUSH
7034: CALL_OW 64
// RemoveUnit ( i ) ;
7038: LD_VAR 0 4
7042: PPUSH
7043: CALL_OW 64
// end ; end ;
7047: GO 6897
7049: POP
7050: POP
// end ;
7051: GO 6848
// end ;
7053: LD_VAR 0 3
7057: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7058: LD_INT 0
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
// if isTest then
7064: LD_EXP 1
7068: IFFALSE 7072
// exit ;
7070: GO 7517
// for i = 1 to n do
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: DOUBLE
7078: LD_INT 1
7080: DEC
7081: ST_TO_ADDR
7082: LD_VAR 0 2
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7376
// begin uc_side := 8 ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_INT 8
7097: ST_TO_ADDR
// uc_nation := 1 ;
7098: LD_ADDR_OWVAR 21
7102: PUSH
7103: LD_INT 1
7105: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7106: LD_ADDR_VAR 0 6
7110: PUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: LD_INT 4
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 1
7127: PPUSH
7128: LD_OWVAR 67
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// vc_chassis := ch ;
7139: LD_ADDR_OWVAR 37
7143: PUSH
7144: LD_VAR 0 6
7148: ST_TO_ADDR
// vc_control := control_computer ;
7149: LD_ADDR_OWVAR 38
7153: PUSH
7154: LD_INT 3
7156: ST_TO_ADDR
// vc_engine := engine_combustion ;
7157: LD_ADDR_OWVAR 39
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7165: LD_OWVAR 1
7169: PUSH
7170: LD_INT 42000
7172: PUSH
7173: LD_INT 33600
7175: PUSH
7176: LD_INT 29400
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_OWVAR 67
7188: ARRAY
7189: LESS
7190: IFFALSE 7221
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7192: LD_ADDR_OWVAR 40
7196: PUSH
7197: LD_INT 3
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 1
7209: PPUSH
7210: LD_INT 2
7212: PPUSH
7213: CALL_OW 12
7217: ARRAY
7218: ST_TO_ADDR
7219: GO 7317
// if ch = us_medium_tracked then
7221: LD_VAR 0 6
7225: PUSH
7226: LD_INT 3
7228: EQUAL
7229: IFFALSE 7276
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7231: LD_ADDR_OWVAR 40
7235: PUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 4
7241: PUSH
7242: LD_INT 5
7244: PUSH
7245: LD_INT 7
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_OWVAR 67
7258: PPUSH
7259: LD_OWVAR 67
7263: PUSH
7264: LD_INT 1
7266: PLUS
7267: PPUSH
7268: CALL_OW 12
7272: ARRAY
7273: ST_TO_ADDR
7274: GO 7317
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7276: LD_ADDR_OWVAR 40
7280: PUSH
7281: LD_INT 5
7283: PUSH
7284: LD_INT 6
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 7
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_OWVAR 67
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PPUSH
7311: CALL_OW 12
7315: ARRAY
7316: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7317: LD_ADDR_OWVAR 41
7321: PUSH
7322: LD_INT 70
7324: ST_TO_ADDR
// un := CreateVehicle ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: CALL_OW 45
7334: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7335: LD_VAR 0 5
7339: PPUSH
7340: LD_VAR 0 1
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7352: LD_VAR 0 5
7356: PPUSH
7357: LD_INT 65
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL_OW 111
// Wait ( 0 0$02 ) ;
7367: LD_INT 70
7369: PPUSH
7370: CALL_OW 67
// end ;
7374: GO 7087
7376: POP
7377: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7378: LD_INT 90
7380: PUSH
7381: LD_INT 80
7383: PUSH
7384: LD_INT 70
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: PUSH
7392: LD_OWVAR 67
7396: ARRAY
7397: PPUSH
7398: CALL_OW 13
7402: IFFALSE 7509
// begin uc_side := 8 ;
7404: LD_ADDR_OWVAR 20
7408: PUSH
7409: LD_INT 8
7411: ST_TO_ADDR
// uc_nation := 1 ;
7412: LD_ADDR_OWVAR 21
7416: PUSH
7417: LD_INT 1
7419: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7420: LD_ADDR_OWVAR 37
7424: PUSH
7425: LD_INT 4
7427: ST_TO_ADDR
// vc_control := control_computer ;
7428: LD_ADDR_OWVAR 38
7432: PUSH
7433: LD_INT 3
7435: ST_TO_ADDR
// vc_engine := engine_combustion ;
7436: LD_ADDR_OWVAR 39
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7444: LD_ADDR_OWVAR 40
7448: PUSH
7449: LD_INT 14
7451: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7452: LD_ADDR_OWVAR 41
7456: PUSH
7457: LD_INT 70
7459: ST_TO_ADDR
// un := CreateVehicle ;
7460: LD_ADDR_VAR 0 5
7464: PUSH
7465: CALL_OW 45
7469: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7470: LD_VAR 0 5
7474: PPUSH
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7487: LD_VAR 0 5
7491: PPUSH
7492: LD_INT 65
7494: PPUSH
7495: LD_INT 9
7497: PPUSH
7498: CALL_OW 111
// Wait ( 0 0$02 ) ;
7502: LD_INT 70
7504: PPUSH
7505: CALL_OW 67
// end ; alfa_support := true ;
7509: LD_ADDR_EXP 13
7513: PUSH
7514: LD_INT 1
7516: ST_TO_ADDR
// end ;
7517: LD_VAR 0 3
7521: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7522: LD_OWVAR 1
7526: PUSH
7527: LD_INT 25200
7529: PUSH
7530: LD_INT 23100
7532: PUSH
7533: LD_INT 21000
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_OWVAR 67
7545: ARRAY
7546: GREATER
7547: IFFALSE 7692
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 3
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: LD_INT 5
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7580: LD_INT 1050
7582: PPUSH
7583: LD_INT 4200
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7595: LD_INT 20
7597: PPUSH
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL 7058 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7607: LD_INT 22
7609: PUSH
7610: LD_INT 8
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: IFFALSE 7635
// SayRadio ( Popov , DR5 ) ;
7623: LD_EXP 24
7627: PPUSH
7628: LD_STRING DR5
7630: PPUSH
7631: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7635: LD_INT 8400
7637: PPUSH
7638: LD_INT 12600
7640: PPUSH
7641: CALL_OW 12
7645: PPUSH
7646: CALL_OW 67
// n := n + 1 ;
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 1
7659: PUSH
7660: LD_INT 1
7662: PLUS
7663: ST_TO_ADDR
// if n > 9 then
7664: LD_VAR 0 1
7668: PUSH
7669: LD_INT 9
7671: GREATER
7672: IFFALSE 7682
// n := 9 ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 9
7681: ST_TO_ADDR
// until tick >= 120 120$00 ;
7682: LD_OWVAR 1
7686: PUSH
7687: LD_INT 252000
7689: GREATEREQUAL
7690: IFFALSE 7580
// end ; end_of_file
7692: PPOPN 1
7694: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7695: LD_INT 0
7697: PPUSH
// enable_addtolog := isTest ;
7698: LD_ADDR_OWVAR 81
7702: PUSH
7703: LD_EXP 1
7707: ST_TO_ADDR
// lines_break_limit := 5 ;
7708: LD_ADDR_EXP 26
7712: PUSH
7713: LD_INT 5
7715: ST_TO_ADDR
// lines_break_type := --- ;
7716: LD_ADDR_EXP 27
7720: PUSH
7721: LD_STRING ---
7723: ST_TO_ADDR
// lines_counter := 0 ;
7724: LD_ADDR_EXP 25
7728: PUSH
7729: LD_INT 0
7731: ST_TO_ADDR
// show_line_index := true ;
7732: LD_ADDR_EXP 28
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// tick_log := true ;
7740: LD_ADDR_EXP 29
7744: PUSH
7745: LD_INT 1
7747: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7748: LD_STRING ----------SAND OF SIBERIA LOG----------
7750: PPUSH
7751: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7755: LD_STRING Map Name: 
7757: PUSH
7758: LD_OWVAR 68
7762: STR
7763: PPUSH
7764: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7768: LD_STRING Map Number: 
7770: PUSH
7771: LD_OWVAR 70
7775: STR
7776: PPUSH
7777: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7781: LD_STRING Difficulty: 
7783: PUSH
7784: LD_OWVAR 67
7788: STR
7789: PPUSH
7790: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7794: LD_STRING ---------------------------------------
7796: PPUSH
7797: CALL_OW 561
// end ;
7801: LD_VAR 0 1
7805: RET
// function Log ( text ) ; begin
7806: LD_INT 0
7808: PPUSH
// if show_line_index then
7809: LD_EXP 28
7813: IFFALSE 7825
// result := lines_counter ;
7815: LD_ADDR_VAR 0 2
7819: PUSH
7820: LD_EXP 25
7824: ST_TO_ADDR
// if tick_log then
7825: LD_EXP 29
7829: IFFALSE 7855
// result := result &  T:  & tick &   ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_VAR 0 2
7840: PUSH
7841: LD_STRING  T: 
7843: STR
7844: PUSH
7845: LD_OWVAR 1
7849: STR
7850: PUSH
7851: LD_STRING  
7853: STR
7854: ST_TO_ADDR
// AddToLog ( result & text ) ;
7855: LD_VAR 0 2
7859: PUSH
7860: LD_VAR 0 1
7864: STR
7865: PPUSH
7866: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7870: LD_ADDR_EXP 25
7874: PUSH
7875: LD_EXP 25
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7884: LD_EXP 25
7888: PUSH
7889: LD_EXP 26
7893: MOD
7894: PUSH
7895: LD_INT 0
7897: EQUAL
7898: IFFALSE 7909
// AddToLog ( lines_break_type ) ;
7900: LD_EXP 27
7904: PPUSH
7905: CALL_OW 561
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogHuman ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7917: LD_STRING Human Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; class: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 257
7954: STR
7955: PUSH
7956: LD_STRING ; 
7958: STR
7959: PPUSH
7960: CALL 7806 0 1
// end ;
7964: LD_VAR 0 2
7968: RET
// export function LogVeh ( id ) ; begin
7969: LD_INT 0
7971: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7972: LD_STRING Vehicle Created. id: 
7974: PUSH
7975: LD_VAR 0 1
7979: STR
7980: PUSH
7981: LD_STRING ; side: 
7983: STR
7984: PUSH
7985: LD_VAR 0 1
7989: PPUSH
7990: CALL_OW 255
7994: STR
7995: PUSH
7996: LD_STRING ; nation: 
7998: STR
7999: PUSH
8000: LD_VAR 0 1
8004: PPUSH
8005: CALL_OW 248
8009: STR
8010: PUSH
8011: LD_STRING ; weapon: 
8013: STR
8014: PUSH
8015: LD_VAR 0 1
8019: PPUSH
8020: CALL_OW 264
8024: STR
8025: PUSH
8026: LD_STRING ; 
8028: STR
8029: PPUSH
8030: CALL 7806 0 1
// end ;
8034: LD_VAR 0 2
8038: RET
// export function LogEvent ( event ) ; begin
8039: LD_INT 0
8041: PPUSH
// Log ( Event Executed. id:  & event ) ;
8042: LD_STRING Event Executed. id: 
8044: PUSH
8045: LD_VAR 0 1
8049: STR
8050: PPUSH
8051: CALL 7806 0 1
// end ; end_of_file
8055: LD_VAR 0 2
8059: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
8068: PPUSH
8069: PPUSH
// if unit then
8070: LD_VAR 0 1
8074: IFFALSE 8474
// begin if mode = 0 then
8076: LD_VAR 0 3
8080: PUSH
8081: LD_INT 0
8083: EQUAL
8084: IFFALSE 8232
// begin if coords then
8086: LD_VAR 0 2
8090: IFFALSE 8230
// while ( coords > 1 ) do
8092: LD_VAR 0 2
8096: PUSH
8097: LD_INT 1
8099: GREATER
8100: IFFALSE 8230
// if not HasTask ( unit ) then
8102: LD_VAR 0 1
8106: PPUSH
8107: CALL_OW 314
8111: NOT
8112: IFFALSE 8228
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_VAR 0 2
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PPUSH
8137: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 250
8157: PUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: EQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 251
8177: PUSH
8178: LD_VAR 0 2
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: EQUAL
8187: AND
8188: IFFALSE 8141
// for i = 1 to 2 do
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_INT 2
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8226
// coords := Delete ( coords , 1 ) ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_VAR 0 2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 3
8223: ST_TO_ADDR
8224: GO 8203
8226: POP
8227: POP
// end ;
8228: GO 8092
// end else
8230: GO 8474
// begin if coords then
8232: LD_VAR 0 2
8236: IFFALSE 8474
// begin x := GetX ( unit ) ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 250
8252: ST_TO_ADDR
// y := GetY ( unit ) ;
8253: LD_ADDR_VAR 0 7
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 251
8267: ST_TO_ADDR
// while ( coords > 1 ) do
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8474
// begin Wait ( 0 0$0.3 ) ;
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 250
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 251
8314: PPUSH
8315: LD_INT 14
8317: PPUSH
8318: CALL 22821 0 4
8322: IFFALSE 8353
// begin ComMoveXY ( unit , x , y ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: LD_VAR 0 6
8333: PPUSH
8334: LD_VAR 0 7
8338: PPUSH
8339: CALL_OW 111
// result := false ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_INT 0
8350: ST_TO_ADDR
// end else
8351: GO 8392
// if not HasTask ( unit ) then
8353: LD_VAR 0 1
8357: PPUSH
8358: CALL_OW 314
8362: NOT
8363: IFFALSE 8392
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8365: LD_VAR 0 1
8369: PPUSH
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 1
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 2
8386: ARRAY
8387: PPUSH
8388: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8392: LD_VAR 0 1
8396: PPUSH
8397: CALL_OW 250
8401: PUSH
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: EQUAL
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 251
8421: PUSH
8422: LD_VAR 0 2
8426: PUSH
8427: LD_INT 2
8429: ARRAY
8430: EQUAL
8431: AND
8432: IFFALSE 8472
// for i = 1 to 2 do
8434: LD_ADDR_VAR 0 5
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_INT 2
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8470
// coords := Delete ( coords , 1 ) ;
8450: LD_ADDR_VAR 0 2
8454: PUSH
8455: LD_VAR 0 2
8459: PPUSH
8460: LD_INT 1
8462: PPUSH
8463: CALL_OW 3
8467: ST_TO_ADDR
8468: GO 8447
8470: POP
8471: POP
// end ;
8472: GO 8268
// end ; end ; end ; result := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// end ;
8482: LD_VAR 0 4
8486: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
// if not units then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8564
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8501: LD_ADDR_VAR 0 5
8505: PUSH
8506: LD_INT 81
8508: PUSH
8509: LD_VAR 0 1
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// for i in units do
8523: LD_ADDR_VAR 0 4
8527: PUSH
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_IN
8534: IFFALSE 8562
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8536: LD_VAR 0 4
8540: PPUSH
8541: LD_VAR 0 5
8545: PPUSH
8546: LD_VAR 0 4
8550: PPUSH
8551: CALL_OW 74
8555: PPUSH
8556: CALL_OW 115
// end ;
8560: GO 8533
8562: POP
8563: POP
// end ;
8564: LD_VAR 0 3
8568: RET
// export function MC_Show ( string ) ; begin
8569: LD_INT 0
8571: PPUSH
// display_strings := string ;
8572: LD_ADDR_OWVAR 47
8576: PUSH
8577: LD_VAR 0 1
8581: ST_TO_ADDR
// end ; end_of_file
8582: LD_VAR 0 2
8586: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8587: LD_INT 0
8589: PPUSH
8590: PPUSH
8591: PPUSH
8592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8593: LD_ADDR_VAR 0 8
8597: PUSH
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 2
8605: PPUSH
8606: EMPTY
8607: PPUSH
8608: CALL 11734 0 3
8612: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8613: LD_VAR 0 8
8617: PUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 428
8632: PUSH
8633: LD_INT 0
8635: EQUAL
8636: AND
8637: IFFALSE 8711
// for i = 1 to plist do
8639: LD_ADDR_VAR 0 6
8643: PUSH
8644: DOUBLE
8645: LD_INT 1
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 8
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8709
// if NotTask ( plist [ i ] ) then
8657: LD_VAR 0 8
8661: PUSH
8662: LD_VAR 0 6
8666: ARRAY
8667: PPUSH
8668: CALL 32236 0 1
8672: IFFALSE 8707
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8674: LD_VAR 0 8
8678: PUSH
8679: LD_VAR 0 6
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: LD_VAR 0 3
8697: PPUSH
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 145
// end ;
8707: GO 8654
8709: POP
8710: POP
// end ;
8711: LD_VAR 0 5
8715: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8716: LD_INT 0
8718: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8719: LD_VAR 0 1
8723: PPUSH
8724: LD_INT 6
8726: PPUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: LD_VAR 0 4
8741: PPUSH
8742: CALL 10220 0 5
// end ;
8746: LD_VAR 0 5
8750: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8751: LD_INT 0
8753: PPUSH
8754: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8755: LD_ADDR_VAR 0 4
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_VAR 0 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 0
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 1
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: PPUSH
8807: CALL_OW 69
8811: PPUSH
8812: LD_VAR 0 2
8816: PPUSH
8817: CALL_OW 250
8821: PPUSH
8822: LD_VAR 0 2
8826: PPUSH
8827: CALL_OW 251
8831: PPUSH
8832: CALL_OW 73
8836: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8837: LD_VAR 0 4
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: CALL 10509 0 2
8851: IFFALSE 8910
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8853: LD_VAR 0 1
8857: PPUSH
8858: LD_INT 30
8860: PUSH
8861: LD_VAR 0 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: PPUSH
8870: CALL 11651 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8883: LD_ADDR_EXP 48
8887: PUSH
8888: LD_EXP 48
8892: PPUSH
8893: LD_VAR 0 1
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: EMPTY
8904: PPUSH
8905: CALL 42051 0 4
8909: ST_TO_ADDR
// end ; end ;
8910: LD_VAR 0 3
8914: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// result := false ;
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: LD_INT 0
8930: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8931: LD_VAR 0 1
8935: PPUSH
8936: LD_EXP 40
8940: PPUSH
8941: CALL 42999 0 2
8945: IFFALSE 9158
// for i = 1 to MREG_LabList do
8947: LD_ADDR_VAR 0 5
8951: PUSH
8952: DOUBLE
8953: LD_INT 1
8955: DEC
8956: ST_TO_ADDR
8957: LD_EXP 40
8961: PUSH
8962: FOR_TO
8963: IFFALSE 9156
// begin if MREG_LabList [ i ] [ 1 ] = side then
8965: LD_EXP 40
8969: PUSH
8970: LD_VAR 0 5
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PUSH
8980: LD_VAR 0 1
8984: EQUAL
8985: IFFALSE 9154
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8987: LD_ADDR_VAR 0 7
8991: PUSH
8992: LD_EXP 40
8996: PUSH
8997: LD_VAR 0 5
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9007: LD_ADDR_VAR 0 9
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_VAR 0 1
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 0
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 30
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PUSH
9056: EMPTY
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PPUSH
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 250
9073: PPUSH
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 251
9083: PPUSH
9084: CALL_OW 73
9088: ST_TO_ADDR
// if dep then
9089: LD_VAR 0 9
9093: IFFALSE 9152
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9095: LD_VAR 0 9
9099: PPUSH
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 3
9109: PPUSH
9110: CALL 10625 0 3
9114: IFFALSE 9152
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9116: LD_VAR 0 7
9120: PPUSH
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9130: LD_VAR 0 7
9134: PPUSH
9135: LD_VAR 0 3
9139: PPUSH
9140: CALL_OW 207
// result := true ;
9144: LD_ADDR_VAR 0 4
9148: PUSH
9149: LD_INT 1
9151: ST_TO_ADDR
// end ; end ; break ;
9152: GO 9156
// end ; end ;
9154: GO 8962
9156: POP
9157: POP
// end ;
9158: LD_VAR 0 4
9162: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9168: LD_ADDR_VAR 0 7
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: LD_VAR 0 3
9182: PPUSH
9183: LD_VAR 0 4
9187: PPUSH
9188: CALL 9350 0 3
9192: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9193: LD_ADDR_EXP 46
9197: PUSH
9198: LD_EXP 46
9202: PPUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: LD_VAR 0 2
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 4
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41960 0 4
9235: ST_TO_ADDR
// if ext_list then
9236: LD_VAR 0 5
9240: IFFALSE 9345
// for i = 1 to ext_list do
9242: LD_ADDR_VAR 0 8
9246: PUSH
9247: DOUBLE
9248: LD_INT 1
9250: DEC
9251: ST_TO_ADDR
9252: LD_VAR 0 5
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9343
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9260: LD_ADDR_EXP 46
9264: PUSH
9265: LD_EXP 46
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_VAR 0 5
9279: PUSH
9280: LD_VAR 0 8
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 7
9290: PUSH
9291: LD_VAR 0 8
9295: ARRAY
9296: PUSH
9297: LD_INT 1
9299: ARRAY
9300: PUSH
9301: LD_VAR 0 7
9305: PUSH
9306: LD_VAR 0 8
9310: ARRAY
9311: PUSH
9312: LD_INT 2
9314: ARRAY
9315: PUSH
9316: LD_VAR 0 7
9320: PUSH
9321: LD_VAR 0 8
9325: ARRAY
9326: PUSH
9327: LD_INT 3
9329: ARRAY
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL 41960 0 4
9340: ST_TO_ADDR
9341: GO 9257
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 6
9349: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9350: LD_INT 0
9352: PPUSH
9353: PPUSH
// list := [ ] ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: EMPTY
9360: ST_TO_ADDR
// case d of 0 :
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 0
9368: DOUBLE
9369: EQUAL
9370: IFTRUE 9374
9372: GO 9507
9374: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 4
9387: MINUS
9388: PUSH
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 4
9396: MINUS
9397: PUSH
9398: LD_INT 2
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 3
9413: MINUS
9414: PUSH
9415: LD_VAR 0 2
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 4
9435: PLUS
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 4
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 3
9457: PLUS
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: PLUS
9467: PUSH
9468: LD_INT 5
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: ST_TO_ADDR
// end ; 1 :
9505: GO 10205
9507: LD_INT 1
9509: DOUBLE
9510: EQUAL
9511: IFTRUE 9515
9513: GO 9648
9515: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9516: LD_ADDR_VAR 0 5
9520: PUSH
9521: LD_VAR 0 1
9525: PUSH
9526: LD_VAR 0 2
9530: PUSH
9531: LD_INT 4
9533: MINUS
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: PUSH
9543: LD_VAR 0 1
9547: PUSH
9548: LD_INT 3
9550: MINUS
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: LD_INT 3
9559: MINUS
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 4
9576: MINUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 1
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 4
9629: PLUS
9630: PUSH
9631: LD_INT 5
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: ST_TO_ADDR
// end ; 2 :
9646: GO 10205
9648: LD_INT 2
9650: DOUBLE
9651: EQUAL
9652: IFTRUE 9656
9654: GO 9785
9656: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: MINUS
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: PUSH
9684: LD_VAR 0 1
9688: PUSH
9689: LD_INT 4
9691: PLUS
9692: PUSH
9693: LD_VAR 0 2
9697: PUSH
9698: LD_INT 4
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 4
9718: PLUS
9719: PUSH
9720: LD_INT 0
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_VAR 0 1
9732: PUSH
9733: LD_INT 3
9735: MINUS
9736: PUSH
9737: LD_VAR 0 2
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 4
9757: MINUS
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: LD_INT 4
9766: MINUS
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: ST_TO_ADDR
// end ; 3 :
9783: GO 10205
9785: LD_INT 3
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9926
9793: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9794: LD_ADDR_VAR 0 5
9798: PUSH
9799: LD_VAR 0 1
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: LD_INT 4
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: PUSH
9821: LD_VAR 0 1
9825: PUSH
9826: LD_INT 4
9828: PLUS
9829: PUSH
9830: LD_VAR 0 2
9834: PUSH
9835: LD_INT 4
9837: PLUS
9838: PUSH
9839: LD_INT 5
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_INT 4
9854: MINUS
9855: PUSH
9856: LD_VAR 0 2
9860: PUSH
9861: LD_INT 1
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: LD_INT 4
9881: MINUS
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: MINUS
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 3
9907: MINUS
9908: PUSH
9909: LD_INT 2
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
// end ; 4 :
9924: GO 10205
9926: LD_INT 4
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10067
9934: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9935: LD_ADDR_VAR 0 5
9939: PUSH
9940: LD_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 4
9952: PLUS
9953: PUSH
9954: LD_INT 0
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: PUSH
9962: LD_VAR 0 1
9966: PUSH
9967: LD_INT 3
9969: PLUS
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 3
9978: PLUS
9979: PUSH
9980: LD_INT 5
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_INT 3
9995: PLUS
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: LD_INT 4
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 3
10022: MINUS
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_VAR 0 1
10036: PUSH
10037: LD_INT 4
10039: MINUS
10040: PUSH
10041: LD_VAR 0 2
10045: PUSH
10046: LD_INT 4
10048: MINUS
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: ST_TO_ADDR
// end ; 5 :
10065: GO 10205
10067: LD_INT 5
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10204
10075: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10076: LD_ADDR_VAR 0 5
10080: PUSH
10081: LD_VAR 0 1
10085: PUSH
10086: LD_INT 4
10088: MINUS
10089: PUSH
10090: LD_VAR 0 2
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_VAR 0 1
10107: PUSH
10108: LD_VAR 0 2
10112: PUSH
10113: LD_INT 4
10115: MINUS
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_VAR 0 1
10129: PUSH
10130: LD_INT 4
10132: PLUS
10133: PUSH
10134: LD_VAR 0 2
10138: PUSH
10139: LD_INT 4
10141: PLUS
10142: PUSH
10143: LD_INT 5
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: PUSH
10151: LD_VAR 0 1
10155: PUSH
10156: LD_INT 3
10158: PLUS
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_INT 4
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 1
10177: PUSH
10178: LD_VAR 0 2
10182: PUSH
10183: LD_INT 3
10185: PLUS
10186: PUSH
10187: LD_INT 0
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: ST_TO_ADDR
// end ; end ;
10202: GO 10205
10204: POP
// result := list ;
10205: LD_ADDR_VAR 0 4
10209: PUSH
10210: LD_VAR 0 5
10214: ST_TO_ADDR
// end ;
10215: LD_VAR 0 4
10219: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10227: LD_ADDR_VAR 0 10
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: LD_INT 2
10239: PPUSH
10240: EMPTY
10241: PPUSH
10242: CALL 11734 0 3
10246: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10247: LD_ADDR_VAR 0 9
10251: PUSH
10252: LD_INT 22
10254: PUSH
10255: LD_VAR 0 1
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_INT 30
10269: PUSH
10270: LD_INT 0
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 30
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PPUSH
10304: LD_VAR 0 3
10308: PPUSH
10309: LD_VAR 0 4
10313: PPUSH
10314: CALL_OW 73
10318: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10319: LD_ADDR_VAR 0 8
10323: PUSH
10324: LD_VAR 0 9
10328: PPUSH
10329: LD_VAR 0 2
10333: PPUSH
10334: CALL 10509 0 2
10338: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10339: LD_VAR 0 10
10343: PUSH
10344: LD_VAR 0 8
10348: AND
10349: PUSH
10350: LD_VAR 0 9
10354: PPUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_VAR 0 4
10364: PPUSH
10365: CALL_OW 297
10369: PUSH
10370: LD_INT 26
10372: LESSEQUAL
10373: AND
10374: PUSH
10375: LD_VAR 0 3
10379: PPUSH
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 428
10389: PUSH
10390: LD_INT 0
10392: EQUAL
10393: AND
10394: IFFALSE 10504
// for i = 1 to plist do
10396: LD_ADDR_VAR 0 7
10400: PUSH
10401: DOUBLE
10402: LD_INT 1
10404: DEC
10405: ST_TO_ADDR
10406: LD_VAR 0 10
10410: PUSH
10411: FOR_TO
10412: IFFALSE 10502
// if IsInUnit ( plist [ i ] ) then
10414: LD_VAR 0 10
10418: PUSH
10419: LD_VAR 0 7
10423: ARRAY
10424: PPUSH
10425: CALL_OW 310
10429: IFFALSE 10448
// ComExitBuilding ( plist [ i ] ) else
10431: LD_VAR 0 10
10435: PUSH
10436: LD_VAR 0 7
10440: ARRAY
10441: PPUSH
10442: CALL_OW 122
10446: GO 10500
// if NotTask ( plist [ i ] ) then
10448: LD_VAR 0 10
10452: PUSH
10453: LD_VAR 0 7
10457: ARRAY
10458: PPUSH
10459: CALL 32236 0 1
10463: IFFALSE 10500
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10465: LD_VAR 0 10
10469: PUSH
10470: LD_VAR 0 7
10474: ARRAY
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL_OW 145
// end ;
10500: GO 10411
10502: POP
10503: POP
// end ;
10504: LD_VAR 0 6
10508: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10509: LD_INT 0
10511: PPUSH
10512: PPUSH
10513: PPUSH
// pom := GetBase ( bdepot ) ;
10514: LD_ADDR_VAR 0 4
10518: PUSH
10519: LD_VAR 0 1
10523: PPUSH
10524: CALL_OW 274
10528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10529: LD_ADDR_VAR 0 5
10533: PUSH
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 248
10548: PPUSH
10549: CALL_OW 450
10553: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: CALL_OW 275
10566: PUSH
10567: LD_VAR 0 5
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: GREATEREQUAL
10576: PUSH
10577: LD_VAR 0 4
10581: PPUSH
10582: LD_INT 3
10584: PPUSH
10585: CALL_OW 275
10589: PUSH
10590: LD_VAR 0 5
10594: PUSH
10595: LD_INT 3
10597: ARRAY
10598: GREATEREQUAL
10599: AND
10600: IFFALSE 10612
// result := true else
10602: LD_ADDR_VAR 0 3
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
10610: GO 10620
// result := false ;
10612: LD_ADDR_VAR 0 3
10616: PUSH
10617: LD_INT 0
10619: ST_TO_ADDR
// end ;
10620: LD_VAR 0 3
10624: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
10629: PPUSH
10630: PPUSH
10631: PPUSH
// pom := GetBase ( bdepot ) ;
10632: LD_ADDR_VAR 0 5
10636: PUSH
10637: LD_VAR 0 1
10641: PPUSH
10642: CALL_OW 274
10646: ST_TO_ADDR
// cost := [ ] ;
10647: LD_ADDR_VAR 0 8
10651: PUSH
10652: EMPTY
10653: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 248
10673: PPUSH
10674: CALL_OW 450
10678: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10679: LD_ADDR_VAR 0 7
10683: PUSH
10684: LD_VAR 0 3
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 248
10698: PPUSH
10699: CALL_OW 450
10703: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10704: LD_ADDR_VAR 0 8
10708: PUSH
10709: LD_VAR 0 8
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: LD_VAR 0 6
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PUSH
10726: LD_VAR 0 7
10730: PUSH
10731: LD_INT 1
10733: ARRAY
10734: PLUS
10735: PPUSH
10736: CALL_OW 1
10740: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: LD_VAR 0 8
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_VAR 0 6
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PUSH
10763: LD_VAR 0 7
10767: PUSH
10768: LD_INT 2
10770: ARRAY
10771: PLUS
10772: PPUSH
10773: CALL_OW 1
10777: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10778: LD_ADDR_VAR 0 8
10782: PUSH
10783: LD_VAR 0 8
10787: PPUSH
10788: LD_INT 3
10790: PPUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_INT 3
10798: ARRAY
10799: PUSH
10800: LD_VAR 0 7
10804: PUSH
10805: LD_INT 3
10807: ARRAY
10808: PLUS
10809: PPUSH
10810: CALL_OW 1
10814: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10815: LD_VAR 0 5
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 275
10827: PUSH
10828: LD_VAR 0 8
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: GREATEREQUAL
10837: PUSH
10838: LD_VAR 0 5
10842: PPUSH
10843: LD_INT 3
10845: PPUSH
10846: CALL_OW 275
10850: PUSH
10851: LD_VAR 0 8
10855: PUSH
10856: LD_INT 3
10858: ARRAY
10859: GREATEREQUAL
10860: AND
10861: IFFALSE 10873
// result := true else
10863: LD_ADDR_VAR 0 4
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
10871: GO 10881
// result := false ;
10873: LD_ADDR_VAR 0 4
10877: PUSH
10878: LD_INT 0
10880: ST_TO_ADDR
// end ;
10881: LD_VAR 0 4
10885: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10886: LD_INT 0
10888: PPUSH
10889: PPUSH
10890: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 2
10903: PPUSH
10904: EMPTY
10905: PPUSH
10906: CALL 11734 0 3
10910: ST_TO_ADDR
// if unit and plist then
10911: LD_VAR 0 2
10915: PUSH
10916: LD_VAR 0 5
10920: AND
10921: IFFALSE 10982
// for i = 1 to plist do
10923: LD_ADDR_VAR 0 4
10927: PUSH
10928: DOUBLE
10929: LD_INT 1
10931: DEC
10932: ST_TO_ADDR
10933: LD_VAR 0 5
10937: PUSH
10938: FOR_TO
10939: IFFALSE 10980
// if NotTask ( plist [ i ] ) then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_VAR 0 4
10950: ARRAY
10951: PPUSH
10952: CALL 32236 0 1
10956: IFFALSE 10978
// ComDismantle ( plist [ i ] , unit ) ;
10958: LD_VAR 0 5
10962: PUSH
10963: LD_VAR 0 4
10967: ARRAY
10968: PPUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 167
10978: GO 10938
10980: POP
10981: POP
// result := true ;
10982: LD_ADDR_VAR 0 3
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// end ;
10990: LD_VAR 0 3
10994: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10995: LD_INT 0
10997: PPUSH
10998: PPUSH
10999: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11000: LD_ADDR_VAR 0 5
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: LD_INT 2
11012: PPUSH
11013: EMPTY
11014: PPUSH
11015: CALL 11734 0 3
11019: ST_TO_ADDR
// if unit and plist then
11020: LD_VAR 0 2
11024: PUSH
11025: LD_VAR 0 5
11029: AND
11030: IFFALSE 11091
// for i = 1 to plist do
11032: LD_ADDR_VAR 0 4
11036: PUSH
11037: DOUBLE
11038: LD_INT 1
11040: DEC
11041: ST_TO_ADDR
11042: LD_VAR 0 5
11046: PUSH
11047: FOR_TO
11048: IFFALSE 11089
// if NotTask ( plist [ i ] ) then
11050: LD_VAR 0 5
11054: PUSH
11055: LD_VAR 0 4
11059: ARRAY
11060: PPUSH
11061: CALL 32236 0 1
11065: IFFALSE 11087
// ComComplete ( plist [ i ] , unit ) ;
11067: LD_VAR 0 5
11071: PUSH
11072: LD_VAR 0 4
11076: ARRAY
11077: PPUSH
11078: LD_VAR 0 2
11082: PPUSH
11083: CALL 71345 0 2
11087: GO 11047
11089: POP
11090: POP
// result := true ;
11091: LD_ADDR_VAR 0 3
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// end ;
11099: LD_VAR 0 3
11103: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11104: LD_INT 0
11106: PPUSH
11107: PPUSH
11108: PPUSH
11109: PPUSH
11110: PPUSH
11111: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11112: LD_ADDR_VAR 0 5
11116: PUSH
11117: LD_INT 22
11119: PUSH
11120: LD_VAR 0 1
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 21
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 3
11141: PUSH
11142: LD_INT 57
11144: PUSH
11145: EMPTY
11146: LIST
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 24
11157: PUSH
11158: LD_INT 1000
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: PPUSH
11175: CALL_OW 69
11179: ST_TO_ADDR
// r := [ ] ;
11180: LD_ADDR_VAR 0 6
11184: PUSH
11185: EMPTY
11186: ST_TO_ADDR
// if not tmp then
11187: LD_VAR 0 5
11191: NOT
11192: IFFALSE 11198
// exit else
11194: GO 11386
11196: GO 11366
// begin r := [ tmp [ 1 ] ] ;
11198: LD_ADDR_VAR 0 6
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: LD_INT 1
11210: ARRAY
11211: PUSH
11212: EMPTY
11213: LIST
11214: ST_TO_ADDR
// for i = 2 to tmp do
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: DOUBLE
11221: LD_INT 2
11223: DEC
11224: ST_TO_ADDR
11225: LD_VAR 0 5
11229: PUSH
11230: FOR_TO
11231: IFFALSE 11364
// begin m := false ;
11233: LD_ADDR_VAR 0 7
11237: PUSH
11238: LD_INT 0
11240: ST_TO_ADDR
// for j = 1 to r do
11241: LD_ADDR_VAR 0 4
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_VAR 0 6
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11331
// if GetLives ( tmp [ i ] ) < r [ j ] then
11259: LD_VAR 0 5
11263: PUSH
11264: LD_VAR 0 3
11268: ARRAY
11269: PPUSH
11270: CALL_OW 256
11274: PUSH
11275: LD_VAR 0 6
11279: PUSH
11280: LD_VAR 0 4
11284: ARRAY
11285: LESS
11286: IFFALSE 11329
// begin r := Insert ( r , j , tmp [ i ] ) ;
11288: LD_ADDR_VAR 0 6
11292: PUSH
11293: LD_VAR 0 6
11297: PPUSH
11298: LD_VAR 0 4
11302: PPUSH
11303: LD_VAR 0 5
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: CALL_OW 2
11318: ST_TO_ADDR
// m := true ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// break ;
11327: GO 11331
// end ;
11329: GO 11256
11331: POP
11332: POP
// if not m then
11333: LD_VAR 0 7
11337: NOT
11338: IFFALSE 11362
// r := r ^ tmp [ i ] ;
11340: LD_ADDR_VAR 0 6
11344: PUSH
11345: LD_VAR 0 6
11349: PUSH
11350: LD_VAR 0 5
11354: PUSH
11355: LD_VAR 0 3
11359: ARRAY
11360: ADD
11361: ST_TO_ADDR
// end ;
11362: GO 11230
11364: POP
11365: POP
// end ; if r then
11366: LD_VAR 0 6
11370: IFFALSE 11384
// result := r else
11372: LD_ADDR_VAR 0 2
11376: PUSH
11377: LD_VAR 0 6
11381: ST_TO_ADDR
11382: GO 11386
// exit ;
11384: GO 11386
// end ;
11386: LD_VAR 0 2
11390: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11391: LD_INT 0
11393: PPUSH
11394: PPUSH
11395: PPUSH
11396: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11397: LD_ADDR_VAR 0 5
11401: PUSH
11402: LD_INT 22
11404: PUSH
11405: LD_VAR 0 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: LD_INT 25
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 25
11429: PUSH
11430: LD_INT 16
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 34
11439: PUSH
11440: LD_INT 13
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 34
11449: PUSH
11450: LD_INT 52
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 24
11466: PUSH
11467: LD_INT 650
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: ST_TO_ADDR
// p := 1 ;
11484: LD_ADDR_VAR 0 4
11488: PUSH
11489: LD_INT 1
11491: ST_TO_ADDR
// for i = 1 to repairs do
11492: LD_ADDR_VAR 0 3
11496: PUSH
11497: DOUBLE
11498: LD_INT 1
11500: DEC
11501: ST_TO_ADDR
11502: LD_VAR 0 5
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// begin if IsInUnit ( repairs [ i ] ) then
11510: LD_VAR 0 5
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: PPUSH
11521: CALL_OW 310
11525: IFFALSE 11544
// ComExitBuilding ( repairs [ i ] ) else
11527: LD_VAR 0 5
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: PPUSH
11538: CALL_OW 122
11542: GO 11642
// if not HasTask ( repairs [ i ] ) then
11544: LD_VAR 0 5
11548: PUSH
11549: LD_VAR 0 3
11553: ARRAY
11554: PPUSH
11555: CALL_OW 314
11559: NOT
11560: IFFALSE 11642
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11562: LD_VAR 0 5
11566: PUSH
11567: LD_VAR 0 3
11571: ARRAY
11572: PPUSH
11573: LD_EXP 47
11577: PUSH
11578: LD_VAR 0 1
11582: ARRAY
11583: PUSH
11584: LD_VAR 0 4
11588: ARRAY
11589: PPUSH
11590: CALL_OW 130
// if i mod 3 = 0 then
11594: LD_VAR 0 3
11598: PUSH
11599: LD_INT 3
11601: MOD
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11622
// p := p + 1 ;
11608: LD_ADDR_VAR 0 4
11612: PUSH
11613: LD_VAR 0 4
11617: PUSH
11618: LD_INT 1
11620: PLUS
11621: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11622: LD_EXP 47
11626: PUSH
11627: LD_VAR 0 1
11631: ARRAY
11632: PUSH
11633: LD_VAR 0 4
11637: LESS
11638: IFFALSE 11642
// break ;
11640: GO 11644
// end ; end ;
11642: GO 11507
11644: POP
11645: POP
// end ; end_of_file
11646: LD_VAR 0 2
11650: RET
// export function MCF_Get ( side , filter ) ; begin
11651: LD_INT 0
11653: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_INT 22
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PPUSH
11680: CALL_OW 69
11684: ST_TO_ADDR
// end ;
11685: LD_VAR 0 3
11689: RET
// export function MCF_Lab ( side ) ; begin
11690: LD_INT 0
11692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11693: LD_ADDR_VAR 0 2
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: LD_INT 30
11712: PUSH
11713: LD_INT 8
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 69
11728: ST_TO_ADDR
// end ;
11729: LD_VAR 0 2
11733: RET
// export function MCF_Class ( side , class , filter ) ; begin
11734: LD_INT 0
11736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_INT 22
11744: PUSH
11745: LD_VAR 0 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 25
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 4
11785: RET
// export function MCF_All ( side , filter ) ; begin
11786: LD_INT 0
11788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 25
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 25
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 4
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: ST_TO_ADDR
// end ;
11871: LD_VAR 0 3
11875: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11876: LD_INT 0
11878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11879: LD_ADDR_VAR 0 4
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 92
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_INT 1
11906: ARRAY
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: LD_INT 2
11915: ARRAY
11916: PUSH
11917: LD_VAR 0 2
11921: PUSH
11922: LD_INT 3
11924: ARRAY
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: PUSH
11932: LD_VAR 0 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// end ;
11947: LD_VAR 0 4
11951: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11952: LD_INT 0
11954: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11955: LD_ADDR_VAR 0 3
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_VAR 0 1
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 21
11974: PUSH
11975: LD_INT 2
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 3
12001: RET
// export function MCF_Cargo ( side ) ; begin
12002: LD_INT 0
12004: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_INT 2
12017: PUSH
12018: LD_INT 34
12020: PUSH
12021: LD_INT 12
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 34
12030: PUSH
12031: LD_INT 32
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 34
12040: PUSH
12041: LD_INT 51
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PPUSH
12054: CALL 11952 0 2
12058: ST_TO_ADDR
// end ;
12059: LD_VAR 0 2
12063: RET
// export function MCF_Ape ( side ) ; begin
12064: LD_INT 0
12066: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_VAR 0 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 2
12086: PUSH
12087: LD_INT 25
12089: PUSH
12090: LD_INT 12
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 15
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 25
12109: PUSH
12110: LD_INT 16
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 17
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// end ;
12143: LD_VAR 0 2
12147: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
12153: PPUSH
// result := [ ] ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: EMPTY
12160: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL 12064 0 1
12175: ST_TO_ADDR
// case type of 0 , normal :
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12195
12187: LD_STRING normal
12189: DOUBLE
12190: EQUAL
12191: IFTRUE 12195
12193: GO 12206
12195: POP
// cl := class_apeman ; 1 , soldier :
12196: LD_ADDR_VAR 0 5
12200: PUSH
12201: LD_INT 12
12203: ST_TO_ADDR
12204: GO 12282
12206: LD_INT 1
12208: DOUBLE
12209: EQUAL
12210: IFTRUE 12220
12212: LD_STRING soldier
12214: DOUBLE
12215: EQUAL
12216: IFTRUE 12220
12218: GO 12231
12220: POP
// cl := class_apeman_soldier ; 2 , engineer :
12221: LD_ADDR_VAR 0 5
12225: PUSH
12226: LD_INT 15
12228: ST_TO_ADDR
12229: GO 12282
12231: LD_INT 2
12233: DOUBLE
12234: EQUAL
12235: IFTRUE 12245
12237: LD_STRING engineer
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12256
12245: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12246: LD_ADDR_VAR 0 5
12250: PUSH
12251: LD_INT 16
12253: ST_TO_ADDR
12254: GO 12282
12256: LD_INT 3
12258: DOUBLE
12259: EQUAL
12260: IFTRUE 12270
12262: LD_STRING kamikaze
12264: DOUBLE
12265: EQUAL
12266: IFTRUE 12270
12268: GO 12281
12270: POP
// cl := class_apeman_kamikaze ; end ;
12271: LD_ADDR_VAR 0 5
12275: PUSH
12276: LD_INT 17
12278: ST_TO_ADDR
12279: GO 12282
12281: POP
// for i = 1 to tmp do
12282: LD_ADDR_VAR 0 6
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 4
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12347
// if GetClass ( tmp [ i ] ) = cl then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_VAR 0 6
12309: ARRAY
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_VAR 0 5
12320: EQUAL
12321: IFFALSE 12345
// result := result ^ tmp [ i ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 3
12332: PUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_VAR 0 6
12342: ARRAY
12343: ADD
12344: ST_TO_ADDR
12345: GO 12297
12347: POP
12348: POP
// end ;
12349: LD_VAR 0 3
12353: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12354: LD_INT 0
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12360: LD_ADDR_VAR 0 5
12364: PUSH
12365: LD_INT 22
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: ST_TO_ADDR
// r := [ ] ;
12391: LD_ADDR_VAR 0 6
12395: PUSH
12396: EMPTY
12397: ST_TO_ADDR
// if tmp then
12398: LD_VAR 0 5
12402: IFFALSE 12471
// for i = 1 to tmp do
12404: LD_ADDR_VAR 0 7
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_VAR 0 5
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12469
// if GetTag ( tmp [ i ] ) = tag then
12422: LD_VAR 0 5
12426: PUSH
12427: LD_VAR 0 7
12431: ARRAY
12432: PPUSH
12433: CALL_OW 110
12437: PUSH
12438: LD_VAR 0 2
12442: EQUAL
12443: IFFALSE 12467
// r := r ^ tmp [ i ] ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 6
12454: PUSH
12455: LD_VAR 0 5
12459: PUSH
12460: LD_VAR 0 7
12464: ARRAY
12465: ADD
12466: ST_TO_ADDR
12467: GO 12419
12469: POP
12470: POP
// result := r ;
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: LD_VAR 0 6
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 4
12485: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
// tmp := plist ;
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 2
12500: ST_TO_ADDR
// if tmp then
12501: LD_VAR 0 5
12505: IFFALSE 12582
// begin for i = 1 to tmp do
12507: LD_ADDR_VAR 0 6
12511: PUSH
12512: DOUBLE
12513: LD_INT 1
12515: DEC
12516: ST_TO_ADDR
12517: LD_VAR 0 5
12521: PUSH
12522: FOR_TO
12523: IFFALSE 12570
// if GetTag ( tmp [ i ] ) <> tag then
12525: LD_VAR 0 5
12529: PUSH
12530: LD_VAR 0 6
12534: ARRAY
12535: PPUSH
12536: CALL_OW 110
12540: PUSH
12541: LD_VAR 0 3
12545: NONEQUAL
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , tag ) ;
12548: LD_VAR 0 5
12552: PUSH
12553: LD_VAR 0 6
12557: ARRAY
12558: PPUSH
12559: LD_VAR 0 3
12563: PPUSH
12564: CALL_OW 109
12568: GO 12522
12570: POP
12571: POP
// result := true ;
12572: LD_ADDR_VAR 0 4
12576: PUSH
12577: LD_INT 1
12579: ST_TO_ADDR
// end else
12580: GO 12590
// result := false ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 0
12589: ST_TO_ADDR
// end ;
12590: LD_VAR 0 4
12594: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12595: LD_INT 0
12597: PPUSH
12598: PPUSH
12599: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_VAR 0 2
12614: PPUSH
12615: EMPTY
12616: PPUSH
12617: CALL 12354 0 3
12621: ST_TO_ADDR
// if tmp then
12622: LD_VAR 0 4
12626: IFFALSE 12678
// begin for i = 1 to tmp do
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: DOUBLE
12634: LD_INT 1
12636: DEC
12637: ST_TO_ADDR
12638: LD_VAR 0 4
12642: PUSH
12643: FOR_TO
12644: IFFALSE 12666
// SetTag ( tmp [ i ] , 0 ) ;
12646: LD_VAR 0 4
12650: PUSH
12651: LD_VAR 0 5
12655: ARRAY
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 109
12664: GO 12643
12666: POP
12667: POP
// result := true ;
12668: LD_ADDR_VAR 0 3
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end else
12676: GO 12686
// result := false ;
12678: LD_ADDR_VAR 0 3
12682: PUSH
12683: LD_INT 0
12685: ST_TO_ADDR
// end ;
12686: LD_VAR 0 3
12690: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12691: LD_INT 0
12693: PPUSH
12694: PPUSH
12695: PPUSH
12696: PPUSH
12697: PPUSH
// sort_list := [ ] ;
12698: LD_ADDR_VAR 0 5
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// for i = 1 to list do
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: DOUBLE
12711: LD_INT 1
12713: DEC
12714: ST_TO_ADDR
12715: LD_VAR 0 1
12719: PUSH
12720: FOR_TO
12721: IFFALSE 12883
// begin if i = 1 then
12723: LD_VAR 0 3
12727: PUSH
12728: LD_INT 1
12730: EQUAL
12731: IFFALSE 12757
// sort_list := sort_list ^ list [ i ] else
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PUSH
12743: LD_VAR 0 1
12747: PUSH
12748: LD_VAR 0 3
12752: ARRAY
12753: ADD
12754: ST_TO_ADDR
12755: GO 12881
// begin for j = 1 to sort_list do
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: DOUBLE
12763: LD_INT 1
12765: DEC
12766: ST_TO_ADDR
12767: LD_VAR 0 5
12771: PUSH
12772: FOR_TO
12773: IFFALSE 12850
// begin add := false ;
12775: LD_ADDR_VAR 0 6
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12783: LD_VAR 0 1
12787: PUSH
12788: LD_VAR 0 3
12792: ARRAY
12793: PUSH
12794: LD_VAR 0 5
12798: PUSH
12799: LD_VAR 0 4
12803: ARRAY
12804: LESS
12805: IFFALSE 12848
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12807: LD_ADDR_VAR 0 5
12811: PUSH
12812: LD_VAR 0 5
12816: PPUSH
12817: LD_VAR 0 4
12821: PPUSH
12822: LD_VAR 0 1
12826: PUSH
12827: LD_VAR 0 3
12831: ARRAY
12832: PPUSH
12833: CALL_OW 2
12837: ST_TO_ADDR
// add := true ;
12838: LD_ADDR_VAR 0 6
12842: PUSH
12843: LD_INT 1
12845: ST_TO_ADDR
// break ;
12846: GO 12850
// end ; end ;
12848: GO 12772
12850: POP
12851: POP
// if not add then
12852: LD_VAR 0 6
12856: NOT
12857: IFFALSE 12881
// sort_list := sort_list ^ list [ i ] ;
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_VAR 0 5
12868: PUSH
12869: LD_VAR 0 1
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: ADD
12880: ST_TO_ADDR
// end ; end ;
12881: GO 12720
12883: POP
12884: POP
// result := sort_list ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_VAR 0 5
12894: ST_TO_ADDR
// end ;
12895: LD_VAR 0 2
12899: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// sort_list := [ ] ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// for i = 1 to list do
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: DOUBLE
12920: LD_INT 1
12922: DEC
12923: ST_TO_ADDR
12924: LD_VAR 0 1
12928: PUSH
12929: FOR_TO
12930: IFFALSE 13092
// begin if i = 1 then
12932: LD_VAR 0 3
12936: PUSH
12937: LD_INT 1
12939: EQUAL
12940: IFFALSE 12966
// sort_list := sort_list ^ list [ i ] else
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: LD_VAR 0 5
12951: PUSH
12952: LD_VAR 0 1
12956: PUSH
12957: LD_VAR 0 3
12961: ARRAY
12962: ADD
12963: ST_TO_ADDR
12964: GO 13090
// begin for j = 1 to sort_list do
12966: LD_ADDR_VAR 0 4
12970: PUSH
12971: DOUBLE
12972: LD_INT 1
12974: DEC
12975: ST_TO_ADDR
12976: LD_VAR 0 5
12980: PUSH
12981: FOR_TO
12982: IFFALSE 13059
// begin add := false ;
12984: LD_ADDR_VAR 0 6
12988: PUSH
12989: LD_INT 0
12991: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_VAR 0 3
13001: ARRAY
13002: PUSH
13003: LD_VAR 0 5
13007: PUSH
13008: LD_VAR 0 4
13012: ARRAY
13013: GREATER
13014: IFFALSE 13057
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13016: LD_ADDR_VAR 0 5
13020: PUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: LD_VAR 0 4
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_VAR 0 3
13040: ARRAY
13041: PPUSH
13042: CALL_OW 2
13046: ST_TO_ADDR
// add := true ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// break ;
13055: GO 13059
// end ; end ;
13057: GO 12981
13059: POP
13060: POP
// if not add then
13061: LD_VAR 0 6
13065: NOT
13066: IFFALSE 13090
// sort_list := sort_list ^ list [ i ] ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_VAR 0 5
13077: PUSH
13078: LD_VAR 0 1
13082: PUSH
13083: LD_VAR 0 3
13087: ARRAY
13088: ADD
13089: ST_TO_ADDR
// end ; end ;
13090: GO 12929
13092: POP
13093: POP
// result := sort_list ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 5
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 2
13108: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: LESS
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
13427: PPUSH
// tmp := [ ] ;
13428: LD_ADDR_VAR 0 8
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// r := [ ] ;
13435: LD_ADDR_VAR 0 7
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// add := false ;
13442: LD_ADDR_VAR 0 9
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// if plist then
13450: LD_VAR 0 2
13454: IFFALSE 13530
// begin for i = 1 to plist do
13456: LD_ADDR_VAR 0 5
13460: PUSH
13461: DOUBLE
13462: LD_INT 1
13464: DEC
13465: ST_TO_ADDR
13466: LD_VAR 0 2
13470: PUSH
13471: FOR_TO
13472: IFFALSE 13526
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13474: LD_ADDR_VAR 0 8
13478: PUSH
13479: LD_VAR 0 8
13483: PUSH
13484: LD_VAR 0 2
13488: PUSH
13489: LD_VAR 0 5
13493: ARRAY
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ARRAY
13505: PPUSH
13506: LD_VAR 0 3
13510: PPUSH
13511: CALL_OW 259
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: ADD
13523: ST_TO_ADDR
// end ;
13524: GO 13471
13526: POP
13527: POP
// end else
13528: GO 13538
// result := false ;
13530: LD_ADDR_VAR 0 4
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// if tmp then
13538: LD_VAR 0 8
13542: IFFALSE 13716
// begin r := r ^ [ tmp [ 1 ] ] ;
13544: LD_ADDR_VAR 0 7
13548: PUSH
13549: LD_VAR 0 7
13553: PUSH
13554: LD_VAR 0 8
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PUSH
13563: EMPTY
13564: LIST
13565: ADD
13566: ST_TO_ADDR
// for i = 2 to tmp do
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: DOUBLE
13573: LD_INT 2
13575: DEC
13576: ST_TO_ADDR
13577: LD_VAR 0 8
13581: PUSH
13582: FOR_TO
13583: IFFALSE 13714
// begin for j = 1 to r do
13585: LD_ADDR_VAR 0 6
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 7
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13678
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13603: LD_VAR 0 8
13607: PUSH
13608: LD_VAR 0 5
13612: ARRAY
13613: PUSH
13614: LD_INT 2
13616: ARRAY
13617: PUSH
13618: LD_VAR 0 7
13622: PUSH
13623: LD_VAR 0 6
13627: ARRAY
13628: PUSH
13629: LD_INT 2
13631: ARRAY
13632: GREATER
13633: IFFALSE 13676
// begin r := Insert ( r , j , tmp [ i ] ) ;
13635: LD_ADDR_VAR 0 7
13639: PUSH
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 8
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 2
13665: ST_TO_ADDR
// add := true ;
13666: LD_ADDR_VAR 0 9
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// break ;
13674: GO 13678
// end ; end ;
13676: GO 13600
13678: POP
13679: POP
// if not add then
13680: LD_VAR 0 9
13684: NOT
13685: IFFALSE 13712
// r := r ^ [ tmp [ i ] ] ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_VAR 0 7
13696: PUSH
13697: LD_VAR 0 8
13701: PUSH
13702: LD_VAR 0 5
13706: ARRAY
13707: PUSH
13708: EMPTY
13709: LIST
13710: ADD
13711: ST_TO_ADDR
// end ;
13712: GO 13582
13714: POP
13715: POP
// end ; result := r ;
13716: LD_ADDR_VAR 0 4
13720: PUSH
13721: LD_VAR 0 7
13725: ST_TO_ADDR
// end ;
13726: LD_VAR 0 4
13730: RET
// export function MCF_Clear ( side ) ; var i ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
// for i = 1 to 100 do
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: DOUBLE
13741: LD_INT 1
13743: DEC
13744: ST_TO_ADDR
13745: LD_INT 100
13747: PUSH
13748: FOR_TO
13749: IFFALSE 13785
// if MCF_Tag ( side , i , [ ] ) then
13751: LD_VAR 0 1
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: EMPTY
13762: PPUSH
13763: CALL 12354 0 3
13767: IFFALSE 13783
// MCF_ClearTag ( side , i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL 12595 0 2
13783: GO 13748
13785: POP
13786: POP
// result := true ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 1
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
// for i = 1 to plist do
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: DOUBLE
13811: LD_INT 1
13813: DEC
13814: ST_TO_ADDR
13815: LD_VAR 0 1
13819: PUSH
13820: FOR_TO
13821: IFFALSE 13870
// if MCF_HasClass ( plist [ i ] ) = n then
13823: LD_VAR 0 1
13827: PUSH
13828: LD_VAR 0 4
13832: ARRAY
13833: PPUSH
13834: CALL 14357 0 1
13838: PUSH
13839: LD_VAR 0 2
13843: EQUAL
13844: IFFALSE 13868
// tmp := tmp ^ plist [ i ] ;
13846: LD_ADDR_VAR 0 5
13850: PUSH
13851: LD_VAR 0 5
13855: PUSH
13856: LD_VAR 0 1
13860: PUSH
13861: LD_VAR 0 4
13865: ARRAY
13866: ADD
13867: ST_TO_ADDR
13868: GO 13820
13870: POP
13871: POP
// result := tmp ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_VAR 0 5
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 3
13886: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
13891: PPUSH
// if mreg = ToArm then
13892: LD_VAR 0 2
13896: PUSH
13897: LD_STRING ToArm
13899: EQUAL
13900: IFFALSE 14005
// begin tmp := MREG_ToArm [ side ] ;
13902: LD_ADDR_VAR 0 6
13906: PUSH
13907: LD_EXP 56
13911: PUSH
13912: LD_VAR 0 1
13916: ARRAY
13917: ST_TO_ADDR
// if tmp = 0 then
13918: LD_VAR 0 6
13922: PUSH
13923: LD_INT 0
13925: EQUAL
13926: IFFALSE 13932
// exit else
13928: GO 14352
13930: GO 14005
// begin for i = MREG_ToArm [ side ] downto n do
13932: LD_ADDR_VAR 0 5
13936: PUSH
13937: DOUBLE
13938: LD_EXP 56
13942: PUSH
13943: LD_VAR 0 1
13947: ARRAY
13948: INC
13949: ST_TO_ADDR
13950: LD_VAR 0 3
13954: PUSH
13955: FOR_DOWNTO
13956: IFFALSE 13978
// tmp := Delete ( tmp , 1 ) ;
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: LD_INT 1
13970: PPUSH
13971: CALL_OW 3
13975: ST_TO_ADDR
13976: GO 13955
13978: POP
13979: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13980: LD_ADDR_EXP 56
13984: PUSH
13985: LD_EXP 56
13989: PPUSH
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 6
13999: PPUSH
14000: CALL_OW 1
14004: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14005: LD_VAR 0 2
14009: PUSH
14010: LD_STRING ToDep
14012: EQUAL
14013: IFFALSE 14118
// begin tmp := MREG_ToDep [ side ] ;
14015: LD_ADDR_VAR 0 6
14019: PUSH
14020: LD_EXP 57
14024: PUSH
14025: LD_VAR 0 1
14029: ARRAY
14030: ST_TO_ADDR
// if tmp = 0 then
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 0
14038: EQUAL
14039: IFFALSE 14045
// exit else
14041: GO 14352
14043: GO 14118
// begin for i = MREG_ToDep [ side ] downto n do
14045: LD_ADDR_VAR 0 5
14049: PUSH
14050: DOUBLE
14051: LD_EXP 57
14055: PUSH
14056: LD_VAR 0 1
14060: ARRAY
14061: INC
14062: ST_TO_ADDR
14063: LD_VAR 0 3
14067: PUSH
14068: FOR_DOWNTO
14069: IFFALSE 14091
// tmp := Delete ( tmp , 1 ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 3
14088: ST_TO_ADDR
14089: GO 14068
14091: POP
14092: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14093: LD_ADDR_EXP 57
14097: PUSH
14098: LD_EXP 57
14102: PPUSH
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 6
14112: PPUSH
14113: CALL_OW 1
14117: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14118: LD_VAR 0 2
14122: PUSH
14123: LD_STRING ToFac
14125: EQUAL
14126: IFFALSE 14231
// begin tmp := MREG_ToFac [ side ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_EXP 55
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: ST_TO_ADDR
// if tmp = 0 then
14144: LD_VAR 0 6
14148: PUSH
14149: LD_INT 0
14151: EQUAL
14152: IFFALSE 14158
// exit else
14154: GO 14352
14156: GO 14231
// begin for i = MREG_ToFac [ side ] downto n do
14158: LD_ADDR_VAR 0 5
14162: PUSH
14163: DOUBLE
14164: LD_EXP 55
14168: PUSH
14169: LD_VAR 0 1
14173: ARRAY
14174: INC
14175: ST_TO_ADDR
14176: LD_VAR 0 3
14180: PUSH
14181: FOR_DOWNTO
14182: IFFALSE 14204
// tmp := Delete ( tmp , 1 ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 6
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 3
14201: ST_TO_ADDR
14202: GO 14181
14204: POP
14205: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14206: LD_ADDR_EXP 55
14210: PUSH
14211: LD_EXP 55
14215: PPUSH
14216: LD_VAR 0 1
14220: PPUSH
14221: LD_VAR 0 6
14225: PPUSH
14226: CALL_OW 1
14230: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14231: LD_VAR 0 2
14235: PUSH
14236: LD_STRING ToLab
14238: EQUAL
14239: IFFALSE 14344
// begin tmp := MREG_ToLab [ side ] ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_EXP 54
14250: PUSH
14251: LD_VAR 0 1
14255: ARRAY
14256: ST_TO_ADDR
// if tmp = 0 then
14257: LD_VAR 0 6
14261: PUSH
14262: LD_INT 0
14264: EQUAL
14265: IFFALSE 14271
// exit else
14267: GO 14352
14269: GO 14344
// begin for i = MREG_ToLab [ side ] downto n do
14271: LD_ADDR_VAR 0 5
14275: PUSH
14276: DOUBLE
14277: LD_EXP 54
14281: PUSH
14282: LD_VAR 0 1
14286: ARRAY
14287: INC
14288: ST_TO_ADDR
14289: LD_VAR 0 3
14293: PUSH
14294: FOR_DOWNTO
14295: IFFALSE 14317
// tmp := Delete ( tmp , 1 ) ;
14297: LD_ADDR_VAR 0 6
14301: PUSH
14302: LD_VAR 0 6
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 3
14314: ST_TO_ADDR
14315: GO 14294
14317: POP
14318: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14319: LD_ADDR_EXP 54
14323: PUSH
14324: LD_EXP 54
14328: PPUSH
14329: LD_VAR 0 1
14333: PPUSH
14334: LD_VAR 0 6
14338: PPUSH
14339: CALL_OW 1
14343: ST_TO_ADDR
// end ; end ; result := true ;
14344: LD_ADDR_VAR 0 4
14348: PUSH
14349: LD_INT 1
14351: ST_TO_ADDR
// end ;
14352: LD_VAR 0 4
14356: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
// side := GetSide ( unit ) ;
14362: LD_ADDR_VAR 0 4
14366: PUSH
14367: LD_VAR 0 1
14371: PPUSH
14372: CALL_OW 255
14376: ST_TO_ADDR
// tmp := 0 ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14385: LD_VAR 0 1
14389: PUSH
14390: LD_EXP 56
14394: PUSH
14395: LD_VAR 0 4
14399: ARRAY
14400: IN
14401: IFFALSE 14411
// tmp := 1 ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14411: LD_VAR 0 1
14415: PUSH
14416: LD_EXP 57
14420: PUSH
14421: LD_VAR 0 4
14425: ARRAY
14426: IN
14427: IFFALSE 14437
// tmp := 2 ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_INT 2
14436: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14437: LD_VAR 0 1
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: LD_VAR 0 4
14451: ARRAY
14452: IN
14453: IFFALSE 14463
// tmp := 3 ;
14455: LD_ADDR_VAR 0 3
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_EXP 54
14472: PUSH
14473: LD_VAR 0 4
14477: ARRAY
14478: IN
14479: IFFALSE 14489
// tmp := 4 ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: LD_INT 4
14488: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 68
14498: PUSH
14499: LD_VAR 0 4
14503: ARRAY
14504: IN
14505: IFFALSE 14515
// tmp := 5 ;
14507: LD_ADDR_VAR 0 3
14511: PUSH
14512: LD_INT 5
14514: ST_TO_ADDR
// result := tmp ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 3
14524: ST_TO_ADDR
// end ;
14525: LD_VAR 0 2
14529: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
// if mreg = ToArm then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_STRING ToArm
14541: EQUAL
14542: IFFALSE 14631
// for i = MREG_ToArm [ side ] downto 1 do
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: DOUBLE
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: INC
14561: ST_TO_ADDR
14562: LD_INT 1
14564: PUSH
14565: FOR_DOWNTO
14566: IFFALSE 14629
// if MREG_ToArm [ side ] [ i ] = unit then
14568: LD_EXP 56
14572: PUSH
14573: LD_VAR 0 1
14577: ARRAY
14578: PUSH
14579: LD_VAR 0 5
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: EQUAL
14590: IFFALSE 14627
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14592: LD_ADDR_EXP 56
14596: PUSH
14597: LD_EXP 56
14601: PPUSH
14602: LD_EXP 56
14606: PUSH
14607: LD_VAR 0 1
14611: ARRAY
14612: PUSH
14613: LD_VAR 0 5
14617: ARRAY
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 31289 0 3
14626: ST_TO_ADDR
// end ;
14627: GO 14565
14629: POP
14630: POP
// if mreg = ToDep then
14631: LD_VAR 0 2
14635: PUSH
14636: LD_STRING ToDep
14638: EQUAL
14639: IFFALSE 14728
// for i = MREG_ToDep [ side ] downto 1 do
14641: LD_ADDR_VAR 0 5
14645: PUSH
14646: DOUBLE
14647: LD_EXP 57
14651: PUSH
14652: LD_VAR 0 1
14656: ARRAY
14657: INC
14658: ST_TO_ADDR
14659: LD_INT 1
14661: PUSH
14662: FOR_DOWNTO
14663: IFFALSE 14726
// if MREG_ToDep [ side ] [ i ] = unit then
14665: LD_EXP 57
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PUSH
14676: LD_VAR 0 5
14680: ARRAY
14681: PUSH
14682: LD_VAR 0 3
14686: EQUAL
14687: IFFALSE 14724
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14689: LD_ADDR_EXP 57
14693: PUSH
14694: LD_EXP 57
14698: PPUSH
14699: LD_EXP 57
14703: PUSH
14704: LD_VAR 0 1
14708: ARRAY
14709: PUSH
14710: LD_VAR 0 5
14714: ARRAY
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: CALL 31289 0 3
14723: ST_TO_ADDR
// end ;
14724: GO 14662
14726: POP
14727: POP
// if mreg = ToFac then
14728: LD_VAR 0 2
14732: PUSH
14733: LD_STRING ToFac
14735: EQUAL
14736: IFFALSE 14825
// for i = MREG_ToFac [ side ] downto 1 do
14738: LD_ADDR_VAR 0 5
14742: PUSH
14743: DOUBLE
14744: LD_EXP 55
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: INC
14755: ST_TO_ADDR
14756: LD_INT 1
14758: PUSH
14759: FOR_DOWNTO
14760: IFFALSE 14823
// if MREG_ToFac [ side ] [ i ] = unit then
14762: LD_EXP 55
14766: PUSH
14767: LD_VAR 0 1
14771: ARRAY
14772: PUSH
14773: LD_VAR 0 5
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 3
14783: EQUAL
14784: IFFALSE 14821
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14786: LD_ADDR_EXP 55
14790: PUSH
14791: LD_EXP 55
14795: PPUSH
14796: LD_EXP 55
14800: PUSH
14801: LD_VAR 0 1
14805: ARRAY
14806: PUSH
14807: LD_VAR 0 5
14811: ARRAY
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL 31289 0 3
14820: ST_TO_ADDR
// end ;
14821: GO 14759
14823: POP
14824: POP
// if mreg = ToLab then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_STRING ToLab
14832: EQUAL
14833: IFFALSE 14922
// for i = MREG_ToLab [ side ] downto 1 do
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: DOUBLE
14841: LD_EXP 54
14845: PUSH
14846: LD_VAR 0 1
14850: ARRAY
14851: INC
14852: ST_TO_ADDR
14853: LD_INT 1
14855: PUSH
14856: FOR_DOWNTO
14857: IFFALSE 14920
// if MREG_ToLab [ side ] [ i ] = unit then
14859: LD_EXP 54
14863: PUSH
14864: LD_VAR 0 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 5
14874: ARRAY
14875: PUSH
14876: LD_VAR 0 3
14880: EQUAL
14881: IFFALSE 14918
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14883: LD_ADDR_EXP 54
14887: PUSH
14888: LD_EXP 54
14892: PPUSH
14893: LD_EXP 54
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PUSH
14904: LD_VAR 0 5
14908: ARRAY
14909: PPUSH
14910: LD_INT 1
14912: PPUSH
14913: CALL 31289 0 3
14917: ST_TO_ADDR
// end ;
14918: GO 14856
14920: POP
14921: POP
// end ;
14922: LD_VAR 0 4
14926: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// result := false ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: DOUBLE
14945: LD_INT 1
14947: DEC
14948: ST_TO_ADDR
14949: LD_EXP 46
14953: PUSH
14954: FOR_TO
14955: IFFALSE 15019
// if MREG_ToBuild [ i ] [ 1 ] = side then
14957: LD_EXP 46
14961: PUSH
14962: LD_VAR 0 3
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_VAR 0 1
14976: EQUAL
14977: IFFALSE 15017
// begin if MREG_ToBuild [ i ] [ 1 ] then
14979: LD_EXP 46
14983: PUSH
14984: LD_VAR 0 3
14988: ARRAY
14989: PUSH
14990: LD_INT 1
14992: ARRAY
14993: IFFALSE 15017
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14995: LD_ADDR_VAR 0 2
14999: PUSH
15000: LD_EXP 46
15004: PUSH
15005: LD_VAR 0 3
15009: ARRAY
15010: PUSH
15011: LD_INT 1
15013: ARRAY
15014: ST_TO_ADDR
// break ;
15015: GO 15019
// end ; end ;
15017: GO 14954
15019: POP
15020: POP
// for i = 1 to MREG_ToRepair do
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: DOUBLE
15027: LD_INT 1
15029: DEC
15030: ST_TO_ADDR
15031: LD_EXP 47
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15101
// if MREG_ToRepair [ i ] [ 1 ] = side then
15039: LD_EXP 47
15043: PUSH
15044: LD_VAR 0 3
15048: ARRAY
15049: PUSH
15050: LD_INT 1
15052: ARRAY
15053: PUSH
15054: LD_VAR 0 1
15058: EQUAL
15059: IFFALSE 15099
// begin if MREG_ToRepair [ i ] [ 1 ] then
15061: LD_EXP 47
15065: PUSH
15066: LD_VAR 0 3
15070: ARRAY
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: IFFALSE 15099
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15077: LD_ADDR_VAR 0 2
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: LD_VAR 0 3
15091: ARRAY
15092: PUSH
15093: LD_INT 1
15095: ARRAY
15096: ST_TO_ADDR
// break ;
15097: GO 15101
// end ; end ;
15099: GO 15036
15101: POP
15102: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_INT 57
15110: PUSH
15111: EMPTY
15112: LIST
15113: PPUSH
15114: CALL 11651 0 2
15118: IFFALSE 15145
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 57
15132: PUSH
15133: EMPTY
15134: LIST
15135: PPUSH
15136: CALL 11651 0 2
15140: PUSH
15141: LD_INT 1
15143: ARRAY
15144: ST_TO_ADDR
// end ;
15145: LD_VAR 0 2
15149: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL 11651 0 2
15181: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15182: LD_ADDR_VAR 0 7
15186: PUSH
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 81
15194: PUSH
15195: LD_VAR 0 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL 11651 0 2
15208: ST_TO_ADDR
// if not enemy then
15209: LD_VAR 0 7
15213: NOT
15214: IFFALSE 15226
// result := false else
15216: LD_ADDR_VAR 0 3
15220: PUSH
15221: LD_INT 0
15223: ST_TO_ADDR
15224: GO 15280
// begin scan := NearestUnit ( b , enemy ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 6
15235: PPUSH
15236: LD_VAR 0 7
15240: PPUSH
15241: CALL 32282 0 2
15245: ST_TO_ADDR
// if scan [ 2 ] < dist then
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 2
15259: LESS
15260: IFFALSE 15272
// result := true else
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
15270: GO 15280
// result := false ;
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 0
15279: ST_TO_ADDR
// end ; end ;
15280: LD_VAR 0 3
15284: RET
// export function MCF_Info ( ) ; begin
15285: LD_INT 0
15287: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15288: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15290: PUSH
15291: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15293: ADD
15294: PUSH
15295: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15297: ADD
15298: PUSH
15299: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15301: ADD
15302: PUSH
15303: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15305: ADD
15306: PUSH
15307: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15325: ADD
15326: PPUSH
15327: CALL 8569 0 1
// end ; end_of_file
15331: LD_VAR 0 1
15335: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 2
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11651 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13800 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 13420 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 1
15529: PPUSH
15530: CALL 41960 0 4
15534: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 56
15539: PUSH
15540: LD_EXP 56
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 56
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 31130 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 3
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11651 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13800 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 13420 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 2
15787: PPUSH
15788: CALL 41960 0 4
15792: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 57
15797: PUSH
15798: LD_EXP 57
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 57
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 31130 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 25
15893: PUSH
15894: LD_INT 4
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL 11651 0 2
15911: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15912: LD_ADDR_VAR 0 5
15916: PUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: LD_INT 0
15924: PPUSH
15925: CALL 13800 0 2
15929: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_VAR 0 5
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 13420 0 3
15952: ST_TO_ADDR
// if n > sk then
15953: LD_VAR 0 2
15957: PUSH
15958: LD_VAR 0 6
15962: GREATER
15963: IFFALSE 15975
// n := sk ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_VAR 0 6
15974: ST_TO_ADDR
// for i = 1 to n do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 2
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16103
// if ( sk [ i ] [ 1 ] ) <> 0 then
15993: LD_VAR 0 6
15997: PUSH
15998: LD_VAR 0 4
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PUSH
16008: LD_INT 0
16010: NONEQUAL
16011: IFFALSE 16101
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16013: LD_ADDR_EXP 53
16017: PUSH
16018: LD_EXP 53
16022: PPUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 6
16032: PUSH
16033: LD_VAR 0 4
16037: ARRAY
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_INT 3
16045: PPUSH
16046: CALL 41960 0 4
16050: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16051: LD_ADDR_EXP 55
16055: PUSH
16056: LD_EXP 55
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: LD_EXP 55
16070: PUSH
16071: LD_VAR 0 1
16075: ARRAY
16076: PUSH
16077: LD_INT 1
16079: PLUS
16080: PPUSH
16081: LD_VAR 0 6
16085: PUSH
16086: LD_VAR 0 4
16090: ARRAY
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL 31130 0 4
16100: ST_TO_ADDR
// end ;
16101: GO 15990
16103: POP
16104: POP
// end ;
16105: LD_VAR 0 3
16109: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16116: LD_ADDR_VAR 0 5
16120: PUSH
16121: LD_VAR 0 1
16125: PPUSH
16126: LD_INT 2
16128: PUSH
16129: LD_INT 25
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL 11651 0 2
16158: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: LD_VAR 0 5
16168: PPUSH
16169: LD_INT 0
16171: PPUSH
16172: CALL 13800 0 2
16176: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16177: LD_ADDR_VAR 0 6
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 13420 0 3
16199: ST_TO_ADDR
// if n > sk then
16200: LD_VAR 0 2
16204: PUSH
16205: LD_VAR 0 6
16209: GREATER
16210: IFFALSE 16222
// n := sk ;
16212: LD_ADDR_VAR 0 2
16216: PUSH
16217: LD_VAR 0 6
16221: ST_TO_ADDR
// for i = 1 to n do
16222: LD_ADDR_VAR 0 4
16226: PUSH
16227: DOUBLE
16228: LD_INT 1
16230: DEC
16231: ST_TO_ADDR
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_TO
16238: IFFALSE 16350
// if ( sk [ i ] [ 1 ] ) <> 0 then
16240: LD_VAR 0 6
16244: PUSH
16245: LD_VAR 0 4
16249: ARRAY
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: PUSH
16255: LD_INT 0
16257: NONEQUAL
16258: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 4
16284: ARRAY
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: PPUSH
16290: LD_INT 4
16292: PPUSH
16293: CALL 41960 0 4
16297: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16298: LD_ADDR_EXP 54
16302: PUSH
16303: LD_EXP 54
16307: PPUSH
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_EXP 54
16317: PUSH
16318: LD_VAR 0 1
16322: ARRAY
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: LD_VAR 0 6
16332: PUSH
16333: LD_VAR 0 4
16337: ARRAY
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 31130 0 4
16347: ST_TO_ADDR
// end ;
16348: GO 16237
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 3
16356: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 25
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 25
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 25
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL 11651 0 2
16427: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16428: LD_ADDR_VAR 0 6
16432: PUSH
16433: LD_VAR 0 6
16437: PPUSH
16438: LD_INT 0
16440: PPUSH
16441: CALL 13800 0 2
16445: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16446: LD_ADDR_VAR 0 7
16450: PUSH
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_VAR 0 6
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL 13420 0 3
16468: ST_TO_ADDR
// if n > sk then
16469: LD_VAR 0 2
16473: PUSH
16474: LD_VAR 0 7
16478: GREATER
16479: IFFALSE 16491
// n := sk ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 7
16490: ST_TO_ADDR
// for i = 1 to n do
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: DOUBLE
16497: LD_INT 1
16499: DEC
16500: ST_TO_ADDR
16501: LD_VAR 0 2
16505: PUSH
16506: FOR_TO
16507: IFFALSE 16551
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_EXP 53
16518: PPUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_VAR 0 7
16528: PUSH
16529: LD_VAR 0 5
16533: ARRAY
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 3
16543: PPUSH
16544: CALL 41960 0 4
16548: ST_TO_ADDR
// end ;
16549: GO 16506
16551: POP
16552: POP
// end ;
16553: LD_VAR 0 4
16557: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16558: LD_INT 0
16560: PPUSH
16561: PPUSH
16562: PPUSH
// b := false ;
16563: LD_ADDR_VAR 0 6
16567: PUSH
16568: LD_INT 0
16570: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: LD_INT 9
16581: PUSH
16582: LD_INT 5
16584: PUSH
16585: LD_INT 8
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: IN
16594: IFFALSE 16682
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16596: LD_VAR 0 1
16600: PPUSH
16601: LD_INT 2
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL 11651 0 2
16633: IFFALSE 16682
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 30
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL 11651 0 2
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: ST_TO_ADDR
// if class = class_engineer then
16682: LD_VAR 0 3
16686: PUSH
16687: LD_INT 2
16689: EQUAL
16690: IFFALSE 16778
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16692: LD_VAR 0 1
16696: PPUSH
16697: LD_INT 2
16699: PUSH
16700: LD_INT 30
16702: PUSH
16703: LD_INT 0
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 30
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL 11651 0 2
16729: IFFALSE 16778
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16731: LD_ADDR_VAR 0 6
16735: PUSH
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 30
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL 11651 0 2
16773: PUSH
16774: LD_INT 1
16776: ARRAY
16777: ST_TO_ADDR
// if class = class_mechanic then
16778: LD_VAR 0 3
16782: PUSH
16783: LD_INT 3
16785: EQUAL
16786: IFFALSE 16856
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 30
16795: PUSH
16796: LD_INT 3
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PPUSH
16803: CALL 11651 0 2
16807: IFFALSE 16856
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16809: LD_ADDR_VAR 0 6
16813: PUSH
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_INT 2
16821: PUSH
16822: LD_INT 30
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 30
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PPUSH
16847: CALL 11651 0 2
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: ST_TO_ADDR
// if class = class_scientistic then
16856: LD_VAR 0 3
16860: PUSH
16861: LD_INT 4
16863: EQUAL
16864: IFFALSE 16974
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16866: LD_VAR 0 1
16870: PPUSH
16871: LD_INT 2
16873: PUSH
16874: LD_INT 30
16876: PUSH
16877: LD_INT 6
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PUSH
16884: LD_INT 30
16886: PUSH
16887: LD_INT 7
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 30
16896: PUSH
16897: LD_INT 8
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PPUSH
16910: CALL 11651 0 2
16914: IFFALSE 16974
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16916: LD_ADDR_VAR 0 6
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: LD_INT 2
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 6
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 30
16941: PUSH
16942: LD_INT 7
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 30
16951: PUSH
16952: LD_INT 8
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL 11651 0 2
16969: PUSH
16970: LD_INT 1
16972: ARRAY
16973: ST_TO_ADDR
// if GetClass ( unit ) = class then
16974: LD_VAR 0 2
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_VAR 0 3
16988: EQUAL
16989: IFFALSE 17023
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16991: LD_ADDR_EXP 53
16995: PUSH
16996: LD_EXP 53
17000: PPUSH
17001: LD_VAR 0 1
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: LD_VAR 0 3
17015: PPUSH
17016: CALL 42051 0 4
17020: ST_TO_ADDR
// end else
17021: GO 17116
// if b then
17023: LD_VAR 0 6
17027: IFFALSE 17108
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17029: LD_VAR 0 2
17033: PPUSH
17034: CALL_OW 310
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: CALL_OW 310
17048: PUSH
17049: LD_VAR 0 6
17053: NONEQUAL
17054: AND
17055: IFFALSE 17066
// ComExitBuilding ( unit ) ;
17057: LD_VAR 0 2
17061: PPUSH
17062: CALL_OW 122
// if not IsInUnit ( unit ) then
17066: LD_VAR 0 2
17070: PPUSH
17071: CALL_OW 310
17075: NOT
17076: IFFALSE 17092
// ComEnterUnit ( unit , b ) ;
17078: LD_VAR 0 2
17082: PPUSH
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_VAR 0 3
17101: PPUSH
17102: CALL_OW 183
// end else
17106: GO 17116
// result := false ;
17108: LD_ADDR_VAR 0 4
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// end ; end_of_file
17116: LD_VAR 0 4
17120: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17121: LD_INT 0
17123: PPUSH
17124: PPUSH
17125: PPUSH
17126: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17127: LD_ADDR_VAR 0 5
17131: PUSH
17132: LD_INT 35
17134: PUSH
17135: LD_INT 45
17137: PUSH
17138: LD_INT 46
17140: PUSH
17141: LD_INT 47
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 48
17152: PUSH
17153: LD_INT 49
17155: PUSH
17156: LD_INT 50
17158: PUSH
17159: LD_INT 20
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// if MCF_Lab ( side ) then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL 11690 0 1
17183: IFFALSE 17422
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL 11690 0 1
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: CALL_OW 461
17203: PUSH
17204: LD_INT 2
17206: EQUAL
17207: IFFALSE 17346
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17209: LD_VAR 0 1
17213: PPUSH
17214: CALL 11690 0 1
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PPUSH
17223: LD_VAR 0 2
17227: PPUSH
17228: CALL 17518 0 2
17232: IFFALSE 17259
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11690 0 1
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 124
17257: GO 17346
// if MCF_Lab ( side ) > 1 then
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11690 0 1
17268: PUSH
17269: LD_INT 1
17271: GREATER
17272: IFFALSE 17346
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17274: LD_VAR 0 1
17278: PPUSH
17279: CALL 11690 0 1
17283: PUSH
17284: LD_INT 2
17286: ARRAY
17287: PPUSH
17288: CALL_OW 461
17292: PUSH
17293: LD_INT 2
17295: EQUAL
17296: IFFALSE 17346
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17298: LD_VAR 0 1
17302: PPUSH
17303: CALL 11690 0 1
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_VAR 0 2
17316: PPUSH
17317: CALL 17518 0 2
17321: IFFALSE 17346
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17323: LD_VAR 0 1
17327: PPUSH
17328: CALL 11690 0 1
17332: PUSH
17333: LD_INT 2
17335: ARRAY
17336: PPUSH
17337: LD_VAR 0 2
17341: PPUSH
17342: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 4
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: LIST
17367: LIST
17368: IN
17369: IFFALSE 17422
// begin for lab in MCF_Lab ( side ) do
17371: LD_ADDR_VAR 0 6
17375: PUSH
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 11690 0 1
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17420
// if BuildingStatus ( lab ) = bs_need_ape then
17389: LD_VAR 0 6
17393: PPUSH
17394: CALL_OW 461
17398: PUSH
17399: LD_INT 10
17401: EQUAL
17402: IFFALSE 17418
// MCL_ResTame ( side , lab ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL 17643 0 2
17418: GO 17386
17420: POP
17421: POP
// end ; end ; end ;
17422: LD_VAR 0 3
17426: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17427: LD_INT 0
17429: PPUSH
17430: PPUSH
// tmp := [ ] ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// if not lab then
17438: LD_VAR 0 1
17442: NOT
17443: IFFALSE 17455
// result := false else
17445: LD_ADDR_VAR 0 2
17449: PUSH
17450: LD_INT 0
17452: ST_TO_ADDR
17453: GO 17513
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17455: LD_ADDR_VAR 0 3
17459: PUSH
17460: LD_VAR 0 3
17464: PUSH
17465: LD_VAR 0 1
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 268
17477: ADD
17478: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_VAR 0 3
17488: PUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: LD_INT 2
17496: PPUSH
17497: CALL_OW 268
17501: ADD
17502: ST_TO_ADDR
// result := tmp ;
17503: LD_ADDR_VAR 0 2
17507: PUSH
17508: LD_VAR 0 3
17512: ST_TO_ADDR
// end ; end ;
17513: LD_VAR 0 2
17517: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 35
17530: PUSH
17531: LD_INT 45
17533: PUSH
17534: LD_INT 46
17536: PUSH
17537: LD_INT 47
17539: PUSH
17540: LD_INT 1
17542: PUSH
17543: LD_INT 2
17545: PUSH
17546: LD_INT 48
17548: PUSH
17549: LD_INT 49
17551: PUSH
17552: LD_INT 50
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: ST_TO_ADDR
// if lab then
17570: LD_VAR 0 1
17574: IFFALSE 17630
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17576: LD_VAR 0 2
17580: PUSH
17581: LD_VAR 0 5
17585: IN
17586: PUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: CALL_OW 481
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: CALL 17427 0 1
17606: IN
17607: OR
17608: IFFALSE 17620
// result := true else
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
17618: GO 17628
// result := false ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 0
17627: ST_TO_ADDR
// end else
17628: GO 17638
// result := false ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_INT 0
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 3
17642: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17643: LD_INT 0
17645: PPUSH
17646: PPUSH
17647: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17648: LD_ADDR_VAR 0 4
17652: PUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_INT 171
17660: PPUSH
17661: EMPTY
17662: PPUSH
17663: CALL 12354 0 3
17667: ST_TO_ADDR
// if not ape then
17668: LD_VAR 0 4
17672: NOT
17673: IFFALSE 17705
// if MCF_Ape ( side ) then
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 12064 0 1
17684: IFFALSE 17705
// ape := MCF_Ape ( side ) [ 1 ] ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12064 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: ST_TO_ADDR
// if ape then
17705: LD_VAR 0 4
17709: IFFALSE 17760
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17711: LD_VAR 0 4
17715: PUSH
17716: LD_INT 1
17718: ARRAY
17719: PPUSH
17720: CALL_OW 310
17724: PUSH
17725: LD_VAR 0 4
17729: PUSH
17730: LD_INT 1
17732: ARRAY
17733: PPUSH
17734: CALL_OW 310
17738: PUSH
17739: LD_VAR 0 2
17743: NONEQUAL
17744: AND
17745: IFFALSE 17760
// ComExitBuilding ( ape [ 1 ] ) ;
17747: LD_VAR 0 4
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 122
// if not lab then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17771
// exit else
17767: GO 17919
17769: GO 17879
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 4
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL 12354 0 3
17793: PUSH
17794: LD_INT 0
17796: EQUAL
17797: PUSH
17798: LD_VAR 0 2
17802: PPUSH
17803: CALL_OW 313
17807: PUSH
17808: LD_INT 6
17810: EQUAL
17811: AND
17812: IFFALSE 17879
// begin tmp := UnitsInside ( lab ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 313
17828: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17829: LD_VAR 0 5
17833: PUSH
17834: LD_VAR 0 5
17838: ARRAY
17839: PPUSH
17840: LD_INT 16
17842: PPUSH
17843: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17847: LD_VAR 0 5
17851: PUSH
17852: LD_VAR 0 5
17856: ARRAY
17857: PPUSH
17858: CALL_OW 310
17862: IFFALSE 17879
// ComExitBuilding ( tmp [ tmp ] ) ;
17864: LD_VAR 0 5
17868: PUSH
17869: LD_VAR 0 5
17873: ARRAY
17874: PPUSH
17875: CALL_OW 122
// end ; if ape then
17879: LD_VAR 0 4
17883: IFFALSE 17919
// if not IsInUnit ( ape [ 1 ] ) then
17885: LD_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: ARRAY
17893: PPUSH
17894: CALL_OW 310
17898: NOT
17899: IFFALSE 17919
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: LD_VAR 0 2
17914: PPUSH
17915: CALL_OW 120
// end ;
17919: LD_VAR 0 3
17923: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17924: LD_INT 0
17926: PPUSH
17927: PPUSH
17928: PPUSH
// result := false ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: LD_INT 0
17936: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PPUSH
17947: CALL 18034 0 1
17951: ST_TO_ADDR
// if techs then
17952: LD_VAR 0 3
17956: IFFALSE 17986
// if techs [ 2 ] then
17958: LD_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: ARRAY
17966: IFFALSE 17978
// result := true else
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ST_TO_ADDR
17976: GO 17986
// result := false ;
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 2
17990: RET
// export function MCL_Start ( side ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// if MCL_GetTechList ( side ) then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL 18034 0 1
18004: IFFALSE 18029
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18034 0 1
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL 17121 0 2
// end ;
18029: LD_VAR 0 2
18033: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18034: LD_INT 0
18036: PPUSH
18037: PPUSH
18038: PPUSH
// if MREG_ToRes then
18039: LD_EXP 50
18043: IFFALSE 18128
// for i = 1 to MREG_ToRes do
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_EXP 50
18059: PUSH
18060: FOR_TO
18061: IFFALSE 18126
// if MREG_ToRes [ i ] [ 1 ] = side then
18063: LD_EXP 50
18067: PUSH
18068: LD_VAR 0 3
18072: ARRAY
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PUSH
18078: LD_VAR 0 1
18082: EQUAL
18083: IFFALSE 18124
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18085: LD_ADDR_VAR 0 4
18089: PUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: LD_VAR 0 4
18099: PUSH
18100: LD_INT 1
18102: PLUS
18103: PPUSH
18104: LD_EXP 50
18108: PUSH
18109: LD_VAR 0 3
18113: ARRAY
18114: PUSH
18115: LD_INT 2
18117: ARRAY
18118: PPUSH
18119: CALL_OW 1
18123: ST_TO_ADDR
// end ;
18124: GO 18060
18126: POP
18127: POP
// result := techs ;
18128: LD_ADDR_VAR 0 2
18132: PUSH
18133: LD_VAR 0 4
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18143: LD_INT 0
18145: PPUSH
18146: PPUSH
// for i = 1 to tech_list do
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: DOUBLE
18153: LD_INT 1
18155: DEC
18156: ST_TO_ADDR
18157: LD_VAR 0 2
18161: PUSH
18162: FOR_TO
18163: IFFALSE 18217
// if not tech_list [ i ] = 20 then
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 4
18174: ARRAY
18175: PUSH
18176: LD_INT 20
18178: EQUAL
18179: NOT
18180: IFFALSE 18215
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: LD_VAR 0 2
18201: PUSH
18202: LD_VAR 0 4
18206: ARRAY
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL 41960 0 4
18214: ST_TO_ADDR
18215: GO 18162
18217: POP
18218: POP
// result := true ;
18219: LD_ADDR_VAR 0 3
18223: PUSH
18224: LD_INT 1
18226: ST_TO_ADDR
// end ;
18227: LD_VAR 0 3
18231: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// for i = MREG_ToRes downto 1 do
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: DOUBLE
18242: LD_EXP 50
18246: INC
18247: ST_TO_ADDR
18248: LD_INT 1
18250: PUSH
18251: FOR_DOWNTO
18252: IFFALSE 18298
// if MREG_ToRes [ i ] [ 1 ] = side then
18254: LD_EXP 50
18258: PUSH
18259: LD_VAR 0 3
18263: ARRAY
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_VAR 0 1
18273: EQUAL
18274: IFFALSE 18296
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18276: LD_ADDR_EXP 50
18280: PUSH
18281: LD_EXP 50
18285: PPUSH
18286: LD_VAR 0 3
18290: PPUSH
18291: CALL_OW 3
18295: ST_TO_ADDR
18296: GO 18251
18298: POP
18299: POP
// result := true ;
18300: LD_ADDR_VAR 0 2
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// end ;
18308: LD_VAR 0 2
18312: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18313: LD_INT 0
18315: PPUSH
// result := GetTechProgress ( side , tech ) ;
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 326
18335: ST_TO_ADDR
// end ;
18336: LD_VAR 0 3
18340: RET
// export function MCL_Require ( tech ) ; begin
18341: LD_INT 0
18343: PPUSH
// result := GetTechTechsReq ( tech ) ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL_OW 480
18358: ST_TO_ADDR
// end ; end_of_file
18359: LD_VAR 0 2
18363: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
18368: PPUSH
// uc_side := 0 ;
18369: LD_ADDR_OWVAR 20
18373: PUSH
18374: LD_INT 0
18376: ST_TO_ADDR
// uc_nation := 0 ;
18377: LD_ADDR_OWVAR 21
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// for i = 1 to n do
18385: LD_ADDR_VAR 0 5
18389: PUSH
18390: DOUBLE
18391: LD_INT 1
18393: DEC
18394: ST_TO_ADDR
18395: LD_VAR 0 2
18399: PUSH
18400: FOR_TO
18401: IFFALSE 18546
// begin hc_importance := 0 ;
18403: LD_ADDR_OWVAR 32
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// hc_gallery :=  ;
18411: LD_ADDR_OWVAR 33
18415: PUSH
18416: LD_STRING 
18418: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18419: LD_ADDR_OWVAR 35
18423: PUSH
18424: LD_VAR 0 3
18428: PUSH
18429: LD_INT 20
18431: MINUS
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_INT 20
18440: PLUS
18441: PPUSH
18442: CALL_OW 12
18446: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18447: LD_ADDR_OWVAR 31
18451: PUSH
18452: LD_INT 0
18454: PPUSH
18455: LD_INT 2
18457: PPUSH
18458: CALL_OW 12
18462: PUSH
18463: LD_INT 0
18465: PUSH
18466: LD_INT 0
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18478: LD_ADDR_OWVAR 30
18482: PUSH
18483: LD_INT 0
18485: PUSH
18486: LD_INT 0
18488: PUSH
18489: LD_INT 0
18491: PUSH
18492: LD_INT 0
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// hc_name :=  ;
18501: LD_ADDR_OWVAR 26
18505: PUSH
18506: LD_STRING 
18508: ST_TO_ADDR
// hc_class := class_apeman ;
18509: LD_ADDR_OWVAR 28
18513: PUSH
18514: LD_INT 12
18516: ST_TO_ADDR
// ape := CreateHuman ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: CALL_OW 44
18526: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18527: LD_VAR 0 6
18531: PPUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: LD_INT 0
18539: PPUSH
18540: CALL_OW 49
// end ;
18544: GO 18400
18546: POP
18547: POP
// end ;
18548: LD_VAR 0 4
18552: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18553: LD_INT 0
18555: PPUSH
18556: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 12064 0 1
18566: PUSH
18567: LD_EXP 37
18571: PUSH
18572: LD_VAR 0 1
18576: ARRAY
18577: GREATEREQUAL
18578: IFFALSE 18755
// begin if GetTag ( unit ) = 17 then
18580: LD_VAR 0 2
18584: PPUSH
18585: CALL_OW 110
18589: PUSH
18590: LD_INT 17
18592: EQUAL
18593: IFFALSE 18753
// begin SetTag ( unit , 0 ) ;
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_INT 0
18602: PPUSH
18603: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL 11690 0 1
18616: PUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL 18034 0 1
18626: NOT
18627: AND
18628: IFFALSE 18653
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18630: LD_VAR 0 2
18634: PPUSH
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 11690 0 1
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18653: LD_VAR 0 1
18657: PPUSH
18658: CALL 11690 0 1
18662: NOT
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 30
18671: PUSH
18672: LD_INT 1
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL 11651 0 2
18683: AND
18684: IFFALSE 18753
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18686: LD_VAR 0 2
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL 11651 0 2
18710: PUSH
18711: LD_INT 1
18713: ARRAY
18714: PPUSH
18715: CALL_OW 250
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 11651 0 2
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: CALL_OW 251
18748: PPUSH
18749: CALL_OW 111
// end ; end else
18753: GO 18939
// if GetClass ( unit ) <> 4 then
18755: LD_VAR 0 2
18759: PPUSH
18760: CALL_OW 257
18764: PUSH
18765: LD_INT 4
18767: NONEQUAL
18768: IFFALSE 18774
// exit else
18770: GO 18939
18772: GO 18939
// if GetTag ( unit ) = 0 then
18774: LD_VAR 0 2
18778: PPUSH
18779: CALL_OW 110
18783: PUSH
18784: LD_INT 0
18786: EQUAL
18787: IFFALSE 18803
// SetTag ( unit , 17 ) else
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 17
18796: PPUSH
18797: CALL_OW 109
18801: GO 18939
// begin if IsInUnit ( unit ) then
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18823
// ComExitBuilding ( unit ) ;
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 122
// Wait ( 1 ) ;
18823: LD_INT 1
18825: PPUSH
18826: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18830: LD_ADDR_VAR 0 4
18834: PUSH
18835: LD_INT 22
18837: PUSH
18838: LD_INT 0
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 25
18847: PUSH
18848: LD_INT 12
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PPUSH
18859: CALL_OW 69
18863: PPUSH
18864: LD_VAR 0 2
18868: PPUSH
18869: CALL_OW 74
18873: ST_TO_ADDR
// if not ape then
18874: LD_VAR 0 4
18878: NOT
18879: IFFALSE 18885
// exit else
18881: GO 18939
18883: GO 18894
// ComHold ( ape ) ;
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 140
// if not HasTask ( unit ) then
18894: LD_VAR 0 2
18898: PPUSH
18899: CALL_OW 314
18903: NOT
18904: IFFALSE 18937
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18906: LD_VAR 0 2
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: CALL_OW 250
18920: PPUSH
18921: LD_VAR 0 4
18925: PPUSH
18926: CALL_OW 251
18930: PPUSH
18931: CALL_OW 131
18935: GO 18939
// exit ;
18937: GO 18939
// end ; end ;
18939: LD_VAR 0 3
18943: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18944: LD_INT 0
18946: PPUSH
18947: PPUSH
18948: PPUSH
18949: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18950: LD_ADDR_VAR 0 4
18954: PUSH
18955: LD_EXP 38
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18966: LD_ADDR_VAR 0 5
18970: PUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: LD_STRING normal
18978: PPUSH
18979: CALL 12148 0 2
18983: ST_TO_ADDR
// if apes then
18984: LD_VAR 0 5
18988: IFFALSE 19216
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18990: LD_INT 2
18992: PPUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 321
19002: PUSH
19003: LD_INT 2
19005: EQUAL
19006: PUSH
19007: LD_VAR 0 4
19011: PUSH
19012: LD_INT 2
19014: ARRAY
19015: PUSH
19016: LD_INT 1
19018: EQUAL
19019: AND
19020: PUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: LD_STRING engineer
19028: PPUSH
19029: CALL 12148 0 2
19033: PUSH
19034: LD_INT 3
19036: LESS
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 1
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11651 0 2
19058: AND
19059: IFFALSE 19113
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 1
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11651 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end else
19111: GO 19216
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19113: LD_INT 11
19115: PPUSH
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 321
19125: PUSH
19126: LD_INT 2
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: LD_INT 1
19137: ARRAY
19138: PUSH
19139: LD_INT 1
19141: EQUAL
19142: AND
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_INT 30
19151: PUSH
19152: LD_INT 5
19154: PUSH
19155: EMPTY
19156: LIST
19157: LIST
19158: PPUSH
19159: CALL 11651 0 2
19163: AND
19164: IFFALSE 19216
// begin for i in apes do
19166: LD_ADDR_VAR 0 3
19170: PUSH
19171: LD_VAR 0 5
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19214
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 5
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11651 0 2
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: CALL_OW 120
// end ;
19212: GO 19176
19214: POP
19215: POP
// end ; end ; end ; end_of_file
19216: LD_VAR 0 2
19220: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 257
19234: PUSH
19235: LD_INT 4
19237: EQUAL
19238: NOT
19239: PUSH
19240: LD_VAR 0 2
19244: NOT
19245: OR
19246: IFFALSE 19252
// exit else
19248: GO 19286
19250: GO 19286
// if not GetTag ( unit ) = 4 then
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 110
19261: PUSH
19262: LD_INT 4
19264: EQUAL
19265: NOT
19266: IFFALSE 19272
// exit else
19268: GO 19286
19270: GO 19286
// ComHeal ( unit , target ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL_OW 128
// end ;
19286: LD_VAR 0 3
19290: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19291: LD_INT 0
19293: PPUSH
19294: PPUSH
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
19299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19300: LD_ADDR_VAR 0 5
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_VAR 0 1
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 1
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 55
19332: PUSH
19333: EMPTY
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 3
19342: PUSH
19343: LD_INT 54
19345: PUSH
19346: EMPTY
19347: LIST
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 3
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 1000
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_INT 30
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 11651 0 2
19406: ST_TO_ADDR
// r := [ ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: EMPTY
19413: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19414: LD_VAR 0 1
19418: PPUSH
19419: LD_INT 5
19421: PPUSH
19422: EMPTY
19423: PPUSH
19424: CALL 12354 0 3
19428: IFFALSE 19484
// for j in MCF_Tag ( side , 5 , [ ] ) do
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: LD_INT 5
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL 12354 0 3
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19482
// if GetLives ( j ) = 1000 then
19453: LD_VAR 0 4
19457: PPUSH
19458: CALL_OW 256
19462: PUSH
19463: LD_INT 1000
19465: EQUAL
19466: IFFALSE 19480
// SetTag ( j , 0 ) ;
19468: LD_VAR 0 4
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL_OW 109
19480: GO 19450
19482: POP
19483: POP
// if tmp then
19484: LD_VAR 0 5
19488: IFFALSE 19817
// begin r := [ tmp [ 1 ] ] ;
19490: LD_ADDR_VAR 0 6
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_INT 1
19502: ARRAY
19503: PUSH
19504: EMPTY
19505: LIST
19506: ST_TO_ADDR
// for i = 2 to tmp do
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: DOUBLE
19513: LD_INT 2
19515: DEC
19516: ST_TO_ADDR
19517: LD_VAR 0 5
19521: PUSH
19522: FOR_TO
19523: IFFALSE 19815
// begin m := false ;
19525: LD_ADDR_VAR 0 7
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// if d then
19533: LD_VAR 0 8
19537: IFFALSE 19692
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19539: LD_VAR 0 5
19543: PUSH
19544: LD_VAR 0 3
19548: ARRAY
19549: PPUSH
19550: CALL_OW 256
19554: PUSH
19555: LD_INT 650
19557: LESS
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: PPUSH
19570: LD_VAR 0 8
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: CALL_OW 250
19583: PPUSH
19584: LD_VAR 0 8
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: CALL_OW 251
19597: PPUSH
19598: CALL_OW 297
19602: PUSH
19603: LD_INT 10
19605: GREATER
19606: AND
19607: IFFALSE 19692
// begin if not GetTag ( tmp [ i ] ) = 5 then
19609: LD_VAR 0 5
19613: PUSH
19614: LD_VAR 0 3
19618: ARRAY
19619: PPUSH
19620: CALL_OW 110
19624: PUSH
19625: LD_INT 5
19627: EQUAL
19628: NOT
19629: IFFALSE 19649
// SetTag ( tmp [ i ] , 5 ) ;
19631: LD_VAR 0 5
19635: PUSH
19636: LD_VAR 0 3
19640: ARRAY
19641: PPUSH
19642: LD_INT 5
19644: PPUSH
19645: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: LD_VAR 0 8
19664: PUSH
19665: LD_INT 1
19667: ARRAY
19668: PPUSH
19669: CALL_OW 250
19673: PPUSH
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 1
19681: ARRAY
19682: PPUSH
19683: CALL_OW 251
19687: PPUSH
19688: CALL_OW 111
// end ; for j = 1 to r do
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_VAR 0 6
19706: PUSH
19707: FOR_TO
19708: IFFALSE 19782
// if GetLives ( tmp [ i ] ) < r [ j ] then
19710: LD_VAR 0 5
19714: PUSH
19715: LD_VAR 0 3
19719: ARRAY
19720: PPUSH
19721: CALL_OW 256
19725: PUSH
19726: LD_VAR 0 6
19730: PUSH
19731: LD_VAR 0 4
19735: ARRAY
19736: LESS
19737: IFFALSE 19780
// begin r := Insert ( r , j , tmp [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 6
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 5
19758: PUSH
19759: LD_VAR 0 3
19763: ARRAY
19764: PPUSH
19765: CALL_OW 2
19769: ST_TO_ADDR
// m := true ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// break ;
19778: GO 19782
// end ;
19780: GO 19707
19782: POP
19783: POP
// if not m then
19784: LD_VAR 0 7
19788: NOT
19789: IFFALSE 19813
// r := r ^ tmp [ i ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_VAR 0 6
19800: PUSH
19801: LD_VAR 0 5
19805: PUSH
19806: LD_VAR 0 3
19810: ARRAY
19811: ADD
19812: ST_TO_ADDR
// end ;
19813: GO 19522
19815: POP
19816: POP
// end ; result := r end ; end_of_file
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: LD_VAR 0 6
19826: ST_TO_ADDR
19827: LD_VAR 0 2
19831: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19832: LD_INT 0
19834: PPUSH
19835: PPUSH
19836: PPUSH
// pom := GetBase ( bdepot ) ;
19837: LD_ADDR_VAR 0 3
19841: PUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: CALL_OW 274
19851: ST_TO_ADDR
// sor := [ ] ;
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: EMPTY
19858: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 4
19868: PUSH
19869: LD_VAR 0 3
19873: PPUSH
19874: LD_INT 1
19876: PPUSH
19877: CALL_OW 275
19881: ADD
19882: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_VAR 0 4
19892: PUSH
19893: LD_VAR 0 3
19897: PPUSH
19898: LD_INT 2
19900: PPUSH
19901: CALL_OW 275
19905: ADD
19906: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19907: LD_ADDR_VAR 0 4
19911: PUSH
19912: LD_VAR 0 4
19916: PUSH
19917: LD_VAR 0 3
19921: PPUSH
19922: LD_INT 3
19924: PPUSH
19925: CALL_OW 275
19929: ADD
19930: ST_TO_ADDR
// result := sor ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_VAR 0 4
19940: ST_TO_ADDR
// end ;
19941: LD_VAR 0 2
19945: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19946: LD_INT 0
19948: PPUSH
19949: PPUSH
// while ( coord_list ) do
19950: LD_VAR 0 3
19954: IFFALSE 20128
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19956: LD_ADDR_EXP 46
19960: PUSH
19961: LD_EXP 46
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_VAR 0 3
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 3
20001: ARRAY
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PPUSH
20008: CALL 41960 0 4
20012: ST_TO_ADDR
// if weapon_list then
20013: LD_VAR 0 4
20017: IFFALSE 20088
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20019: LD_ADDR_EXP 43
20023: PUSH
20024: LD_EXP 43
20028: PPUSH
20029: LD_VAR 0 1
20033: PPUSH
20034: LD_VAR 0 4
20038: PUSH
20039: LD_INT 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 3
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_VAR 0 3
20056: PUSH
20057: LD_INT 2
20059: ARRAY
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL 41960 0 4
20069: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20070: LD_ADDR_VAR 0 4
20074: PUSH
20075: LD_VAR 0 4
20079: PPUSH
20080: LD_INT 1
20082: PPUSH
20083: CALL_OW 3
20087: ST_TO_ADDR
// end ; for i = 1 to 3 do
20088: LD_ADDR_VAR 0 6
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20124
// coord_list := Delete ( coord_list , 1 ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_VAR 0 3
20113: PPUSH
20114: LD_INT 1
20116: PPUSH
20117: CALL_OW 3
20121: ST_TO_ADDR
20122: GO 20101
20124: POP
20125: POP
// end ;
20126: GO 19950
// result := true ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// end ;
20136: LD_VAR 0 5
20140: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20141: LD_INT 0
20143: PPUSH
20144: PPUSH
// if not weapon_list then
20145: LD_VAR 0 3
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20269
// while ( coord_list ) do
20154: LD_VAR 0 2
20158: IFFALSE 20269
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20160: LD_ADDR_EXP 43
20164: PUSH
20165: LD_EXP 43
20169: PPUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 1
20182: ARRAY
20183: PPUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: PUSH
20193: LD_VAR 0 2
20197: PUSH
20198: LD_INT 2
20200: ARRAY
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL 41960 0 4
20210: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_VAR 0 3
20220: PPUSH
20221: LD_INT 1
20223: PPUSH
20224: CALL_OW 3
20228: ST_TO_ADDR
// for i = 1 to 2 do
20229: LD_ADDR_VAR 0 5
20233: PUSH
20234: DOUBLE
20235: LD_INT 1
20237: DEC
20238: ST_TO_ADDR
20239: LD_INT 2
20241: PUSH
20242: FOR_TO
20243: IFFALSE 20265
// coord_list := Delete ( coord_list , 1 ) ;
20245: LD_ADDR_VAR 0 2
20249: PUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: LD_INT 1
20257: PPUSH
20258: CALL_OW 3
20262: ST_TO_ADDR
20263: GO 20242
20265: POP
20266: POP
// end ;
20267: GO 20154
// end ;
20269: LD_VAR 0 4
20273: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// while ( coord_list ) do
20278: LD_VAR 0 2
20282: IFFALSE 20437
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: PPUSH
20293: LD_VAR 0 2
20297: PUSH
20298: LD_INT 2
20300: ARRAY
20301: PPUSH
20302: CALL_OW 428
20306: IFFALSE 20397
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 2
20321: PUSH
20322: LD_INT 2
20324: ARRAY
20325: PPUSH
20326: CALL_OW 428
20330: PPUSH
20331: CALL_OW 266
20335: PUSH
20336: LD_INT 31
20338: PUSH
20339: LD_INT 32
20341: PUSH
20342: LD_INT 33
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: LIST
20349: IN
20350: IFFALSE 20397
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20352: LD_ADDR_EXP 52
20356: PUSH
20357: LD_EXP 52
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: LD_VAR 0 2
20371: PUSH
20372: LD_INT 1
20374: ARRAY
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 2
20383: ARRAY
20384: PPUSH
20385: CALL_OW 428
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL 41960 0 4
20396: ST_TO_ADDR
// for i = 1 to 3 do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_INT 3
20409: PUSH
20410: FOR_TO
20411: IFFALSE 20433
// coord_list := Delete ( coord_list , 1 ) ;
20413: LD_ADDR_VAR 0 2
20417: PUSH
20418: LD_VAR 0 2
20422: PPUSH
20423: LD_INT 1
20425: PPUSH
20426: CALL_OW 3
20430: ST_TO_ADDR
20431: GO 20410
20433: POP
20434: POP
// end ;
20435: GO 20278
// result := true ;
20437: LD_ADDR_VAR 0 3
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 3
20449: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20450: LD_INT 0
20452: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20453: LD_ADDR_EXP 46
20457: PUSH
20458: LD_EXP 46
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_INT 0
20470: PPUSH
20471: LD_VAR 0 2
20475: PPUSH
20476: CALL 41960 0 4
20480: ST_TO_ADDR
// end ;
20481: LD_VAR 0 3
20485: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20486: LD_INT 0
20488: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20489: LD_ADDR_EXP 46
20493: PUSH
20494: LD_EXP 46
20498: PPUSH
20499: LD_VAR 0 1
20503: PPUSH
20504: LD_INT 6
20506: PPUSH
20507: LD_VAR 0 2
20511: PPUSH
20512: CALL 41960 0 4
20516: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20517: LD_ADDR_EXP 49
20521: PUSH
20522: LD_EXP 49
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 3
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL 41960 0 4
20554: ST_TO_ADDR
// end ;
20555: LD_VAR 0 4
20559: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// if ext_list > 5 then
20564: LD_VAR 0 3
20568: PUSH
20569: LD_INT 5
20571: GREATER
20572: IFFALSE 20616
// for i = 6 to ext_list do
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: DOUBLE
20580: LD_INT 6
20582: DEC
20583: ST_TO_ADDR
20584: LD_VAR 0 3
20588: PUSH
20589: FOR_TO
20590: IFFALSE 20614
// ext_list := Delete ( ext_list , ext_list ) ;
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: CALL_OW 3
20611: ST_TO_ADDR
20612: GO 20589
20614: POP
20615: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 3
20652: PPUSH
20653: CALL 9163 0 5
// end ;
20657: LD_VAR 0 4
20661: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
// p := 1 ;
20667: LD_ADDR_VAR 0 6
20671: PUSH
20672: LD_INT 1
20674: ST_TO_ADDR
// if type_list = [ ] then
20675: LD_VAR 0 3
20679: PUSH
20680: EMPTY
20681: EQUAL
20682: IFFALSE 20692
// type_list := b_oil_power ;
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 26
20691: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20692: LD_ADDR_VAR 0 5
20696: PUSH
20697: DOUBLE
20698: LD_INT 1
20700: DEC
20701: ST_TO_ADDR
20702: LD_VAR 0 2
20706: PUSH
20707: LD_INT 3
20709: DIVREAL
20710: PUSH
20711: FOR_TO
20712: IFFALSE 20815
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20714: LD_ADDR_EXP 46
20718: PUSH
20719: LD_EXP 46
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_VAR 0 3
20733: PUSH
20734: LD_INT 1
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 12
20746: ARRAY
20747: PPUSH
20748: LD_VAR 0 2
20752: PUSH
20753: LD_VAR 0 6
20757: ARRAY
20758: PUSH
20759: LD_VAR 0 2
20763: PUSH
20764: LD_VAR 0 6
20768: PUSH
20769: LD_INT 1
20771: PLUS
20772: ARRAY
20773: PUSH
20774: LD_VAR 0 2
20778: PUSH
20779: LD_VAR 0 6
20783: PUSH
20784: LD_INT 2
20786: PLUS
20787: ARRAY
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 41960 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_VAR 0 6
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20711
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 4
20821: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
// if not MREG_Deposit [ side ] then
20828: LD_EXP 61
20832: PUSH
20833: LD_VAR 0 1
20837: ARRAY
20838: NOT
20839: IFFALSE 20843
// exit ;
20841: GO 21020
// p := 1 ;
20843: LD_ADDR_VAR 0 4
20847: PUSH
20848: LD_INT 1
20850: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20851: LD_ADDR_VAR 0 3
20855: PUSH
20856: DOUBLE
20857: LD_INT 1
20859: DEC
20860: ST_TO_ADDR
20861: LD_EXP 61
20865: PUSH
20866: LD_VAR 0 1
20870: ARRAY
20871: PUSH
20872: LD_INT 3
20874: DIVREAL
20875: PUSH
20876: FOR_TO
20877: IFFALSE 21018
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20879: LD_EXP 61
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: PUSH
20895: LD_INT 2
20897: PLUS
20898: ARRAY
20899: PUSH
20900: LD_INT 2
20902: EQUAL
20903: IFFALSE 20915
// b := b_oil_mine else
20905: LD_ADDR_VAR 0 5
20909: PUSH
20910: LD_INT 29
20912: ST_TO_ADDR
20913: GO 20923
// b := b_siberite_mine ;
20915: LD_ADDR_VAR 0 5
20919: PUSH
20920: LD_INT 30
20922: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: LD_EXP 61
20947: PUSH
20948: LD_VAR 0 1
20952: ARRAY
20953: PUSH
20954: LD_VAR 0 4
20958: ARRAY
20959: PUSH
20960: LD_EXP 61
20964: PUSH
20965: LD_VAR 0 1
20969: ARRAY
20970: PUSH
20971: LD_VAR 0 4
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: ARRAY
20980: PUSH
20981: LD_INT 0
20983: PPUSH
20984: LD_INT 5
20986: PPUSH
20987: CALL_OW 12
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL 41960 0 4
21001: ST_TO_ADDR
// p := p + 3 ;
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: LD_VAR 0 4
21011: PUSH
21012: LD_INT 3
21014: PLUS
21015: ST_TO_ADDR
// end ;
21016: GO 20876
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 2
21024: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21025: LD_INT 0
21027: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21028: LD_ADDR_EXP 46
21032: PUSH
21033: LD_EXP 46
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 4
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: CALL 41960 0 4
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21061: LD_INT 0
21063: PPUSH
// case nation of 1 , us :
21064: LD_VAR 0 2
21068: PUSH
21069: LD_INT 1
21071: DOUBLE
21072: EQUAL
21073: IFTRUE 21083
21075: LD_STRING us
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21114
21083: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21084: LD_ADDR_EXP 46
21088: PUSH
21089: LD_EXP 46
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: LD_INT 36
21101: PPUSH
21102: LD_VAR 0 3
21106: PPUSH
21107: CALL 41960 0 4
21111: ST_TO_ADDR
21112: GO 21165
21114: LD_INT 2
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21128
21120: LD_STRING ar
21122: DOUBLE
21123: EQUAL
21124: IFTRUE 21128
21126: GO 21164
21128: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21129: LD_ADDR_EXP 46
21133: PUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 14
21141: PUSH
21142: LD_INT 2
21144: PUSH
21145: LD_INT 1
21147: PUSH
21148: LD_INT 31
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL 21170 0 2
21161: ST_TO_ADDR
21162: GO 21165
21164: POP
// end ;
21165: LD_VAR 0 4
21169: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21170: LD_INT 0
21172: PPUSH
21173: PPUSH
// for i = 1 to list do
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: DOUBLE
21180: LD_INT 1
21182: DEC
21183: ST_TO_ADDR
21184: LD_VAR 0 2
21188: PUSH
21189: FOR_TO
21190: IFFALSE 21240
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21192: LD_ADDR_EXP 51
21196: PUSH
21197: LD_EXP 51
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_EXP 51
21211: PUSH
21212: LD_VAR 0 1
21216: ARRAY
21217: PUSH
21218: LD_INT 1
21220: PLUS
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_VAR 0 4
21231: ARRAY
21232: PPUSH
21233: CALL 31130 0 4
21237: ST_TO_ADDR
21238: GO 21189
21240: POP
21241: POP
// end ;
21242: LD_VAR 0 3
21246: RET
// export function MCS_GetVehicleList ( side ) ; begin
21247: LD_INT 0
21249: PPUSH
// result := MREG_ToConstruct [ side ] ;
21250: LD_ADDR_VAR 0 2
21254: PUSH
21255: LD_EXP 51
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: ST_TO_ADDR
// end ;
21266: LD_VAR 0 2
21270: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21271: LD_INT 0
21273: PPUSH
21274: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21275: LD_ADDR_EXP 58
21279: PUSH
21280: LD_EXP 58
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: LD_VAR 0 2
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// end ;
21300: LD_VAR 0 3
21304: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21305: LD_INT 0
21307: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21308: LD_ADDR_EXP 37
21312: PUSH
21313: LD_EXP 37
21317: PPUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// end ;
21333: LD_VAR 0 3
21337: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21338: LD_INT 0
21340: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21341: LD_ADDR_EXP 38
21345: PUSH
21346: LD_EXP 38
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 3
21370: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21374: LD_ADDR_EXP 60
21378: PUSH
21379: LD_EXP 60
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL 31130 0 4
21401: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21402: LD_ADDR_EXP 60
21406: PUSH
21407: LD_EXP 60
21411: PPUSH
21412: LD_VAR 0 1
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: LD_VAR 0 3
21424: PPUSH
21425: CALL 31130 0 4
21429: ST_TO_ADDR
// end ;
21430: LD_VAR 0 4
21434: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21435: LD_INT 0
21437: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21438: LD_ADDR_EXP 72
21442: PUSH
21443: LD_EXP 72
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21461: LD_ADDR_EXP 72
21465: PUSH
21466: LD_EXP 72
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: LD_VAR 0 2
21478: PPUSH
21479: CALL_OW 1
21483: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21484: LD_ADDR_EXP 72
21488: PUSH
21489: LD_EXP 72
21493: PPUSH
21494: LD_INT 3
21496: PPUSH
21497: LD_VAR 0 3
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// end ;
21507: LD_VAR 0 4
21511: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
// if not side or not list then
21517: LD_VAR 0 1
21521: NOT
21522: PUSH
21523: LD_VAR 0 2
21527: NOT
21528: OR
21529: IFFALSE 21533
// exit ;
21531: GO 21701
// SetTech ( 20 , side , state_researched ) ;
21533: LD_INT 20
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_INT 2
21543: PPUSH
21544: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21548: LD_ADDR_EXP 61
21552: PUSH
21553: LD_EXP 61
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: CALL_OW 2
21572: ST_TO_ADDR
// p := 1 ;
21573: LD_ADDR_VAR 0 5
21577: PUSH
21578: LD_INT 1
21580: ST_TO_ADDR
// for i = 1 to list / 3 do
21581: LD_ADDR_VAR 0 4
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_VAR 0 2
21595: PUSH
21596: LD_INT 3
21598: DIVREAL
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21699
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21603: LD_VAR 0 2
21607: PUSH
21608: LD_VAR 0 5
21612: ARRAY
21613: PPUSH
21614: LD_VAR 0 2
21618: PUSH
21619: LD_VAR 0 5
21623: PUSH
21624: LD_INT 1
21626: PLUS
21627: ARRAY
21628: PPUSH
21629: LD_VAR 0 2
21633: PUSH
21634: LD_VAR 0 5
21638: PUSH
21639: LD_INT 2
21641: PLUS
21642: ARRAY
21643: PPUSH
21644: CALL 22403 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21648: LD_VAR 0 2
21652: PUSH
21653: LD_VAR 0 5
21657: ARRAY
21658: PPUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 5
21668: PUSH
21669: LD_INT 1
21671: PLUS
21672: ARRAY
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL_OW 441
// p := p + 3 ;
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: PLUS
21696: ST_TO_ADDR
// end ;
21697: GO 21600
21699: POP
21700: POP
// end ;
21701: LD_VAR 0 3
21705: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
// if nat = nation_arabian then
21710: LD_VAR 0 2
21714: PUSH
21715: LD_INT 2
21717: EQUAL
21718: IFFALSE 21724
// exit else
21720: GO 21796
21722: GO 21782
// if nat = nation_american then
21724: LD_VAR 0 2
21728: PUSH
21729: LD_INT 1
21731: EQUAL
21732: IFFALSE 21759
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21734: LD_ADDR_VAR 0 4
21738: PUSH
21739: LD_INT 4
21741: PUSH
21742: LD_INT 3
21744: PUSH
21745: LD_INT 1
21747: PUSH
21748: LD_INT 8
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
21757: GO 21782
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21759: LD_ADDR_VAR 0 4
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 48
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21782: LD_VAR 0 1
21786: PPUSH
21787: LD_VAR 0 4
21791: PPUSH
21792: CALL 21170 0 2
// end ;
21796: LD_VAR 0 3
21800: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21801: LD_INT 0
21803: PPUSH
21804: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21805: LD_ADDR_EXP 63
21809: PUSH
21810: LD_EXP 63
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: LD_INT 1
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: CALL 31130 0 4
21832: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21833: LD_ADDR_EXP 64
21837: PUSH
21838: LD_EXP 64
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: LD_INT 1
21850: PPUSH
21851: LD_VAR 0 2
21855: PPUSH
21856: CALL 31130 0 4
21860: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21861: LD_ADDR_EXP 65
21865: PUSH
21866: LD_EXP 65
21870: PPUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_VAR 0 3
21883: PPUSH
21884: CALL 31130 0 4
21888: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21889: LD_ADDR_EXP 66
21893: PUSH
21894: LD_EXP 66
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_INT 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL 31130 0 4
21916: ST_TO_ADDR
// while squad do
21917: LD_VAR 0 5
21921: IFFALSE 22014
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_VAR 0 5
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PUSH
21937: LD_VAR 0 5
21941: PUSH
21942: LD_INT 2
21944: ARRAY
21945: PUSH
21946: LD_VAR 0 5
21950: PUSH
21951: LD_INT 3
21953: ARRAY
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: PPUSH
21970: CALL 21170 0 2
// for i = 1 to 4 do
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: DOUBLE
21980: LD_INT 1
21982: DEC
21983: ST_TO_ADDR
21984: LD_INT 4
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22010
// squad := Delete ( squad , 1 ) ;
21990: LD_ADDR_VAR 0 5
21994: PUSH
21995: LD_VAR 0 5
21999: PPUSH
22000: LD_INT 1
22002: PPUSH
22003: CALL_OW 3
22007: ST_TO_ADDR
22008: GO 21987
22010: POP
22011: POP
// end ;
22012: GO 21917
// end ;
22014: LD_VAR 0 6
22018: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22019: LD_INT 0
22021: PPUSH
22022: PPUSH
// for i = 1 to squad do
22023: LD_ADDR_VAR 0 4
22027: PUSH
22028: DOUBLE
22029: LD_INT 1
22031: DEC
22032: ST_TO_ADDR
22033: LD_VAR 0 2
22037: PUSH
22038: FOR_TO
22039: IFFALSE 22089
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22041: LD_ADDR_EXP 69
22045: PUSH
22046: LD_EXP 69
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_EXP 69
22060: PUSH
22061: LD_VAR 0 1
22065: ARRAY
22066: PUSH
22067: LD_INT 1
22069: PLUS
22070: PPUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 4
22080: ARRAY
22081: PPUSH
22082: CALL 31130 0 4
22086: ST_TO_ADDR
22087: GO 22038
22089: POP
22090: POP
// while squad do
22091: LD_VAR 0 2
22095: IFFALSE 22188
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22097: LD_VAR 0 1
22101: PPUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: PUSH
22111: LD_VAR 0 2
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PUSH
22120: LD_VAR 0 2
22124: PUSH
22125: LD_INT 3
22127: ARRAY
22128: PUSH
22129: LD_VAR 0 2
22133: PUSH
22134: LD_INT 4
22136: ARRAY
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL 21170 0 2
// for i = 1 to 4 do
22148: LD_ADDR_VAR 0 4
22152: PUSH
22153: DOUBLE
22154: LD_INT 1
22156: DEC
22157: ST_TO_ADDR
22158: LD_INT 4
22160: PUSH
22161: FOR_TO
22162: IFFALSE 22184
// squad := Delete ( squad , 1 ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_INT 1
22176: PPUSH
22177: CALL_OW 3
22181: ST_TO_ADDR
22182: GO 22161
22184: POP
22185: POP
// end ;
22186: GO 22091
// end ;
22188: LD_VAR 0 3
22192: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22193: LD_INT 0
22195: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22196: LD_ADDR_EXP 62
22200: PUSH
22201: LD_EXP 62
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 2
22218: PPUSH
22219: CALL 31130 0 4
22223: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22224: LD_ADDR_EXP 62
22228: PUSH
22229: LD_EXP 62
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: LD_VAR 0 3
22246: PPUSH
22247: CALL 31130 0 4
22251: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22252: LD_ADDR_EXP 62
22256: PUSH
22257: LD_EXP 62
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: LD_INT 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: CALL 31130 0 4
22279: ST_TO_ADDR
// end ; end_of_file
22280: LD_VAR 0 5
22284: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22285: LD_INT 0
22287: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22288: LD_ADDR_EXP 42
22292: PUSH
22293: LD_EXP 42
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_INT 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: CALL 31130 0 4
22315: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL 11786 0 2
22327: PUSH
22328: LD_INT 1
22330: ARRAY
22331: PPUSH
22332: CALL_OW 248
22336: PUSH
22337: LD_INT 1
22339: EQUAL
22340: IFFALSE 22371
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: PUSH
22356: LD_INT 14
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL 21170 0 2
22369: GO 22398
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 24
22378: PUSH
22379: LD_INT 1
22381: PUSH
22382: LD_INT 1
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: PPUSH
22394: CALL 21170 0 2
// end ;
22398: LD_VAR 0 3
22402: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22403: LD_INT 0
22405: PPUSH
// CreateDepositXY ( x , y , t ) ;
22406: LD_VAR 0 1
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: LD_VAR 0 3
22420: PPUSH
22421: CALL_OW 62
// end ;
22425: LD_VAR 0 4
22429: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22430: LD_INT 0
22432: PPUSH
22433: PPUSH
// c := 1 ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 1
22441: ST_TO_ADDR
// case color of red :
22442: LD_VAR 0 3
22446: PUSH
22447: LD_STRING red
22449: DOUBLE
22450: EQUAL
22451: IFTRUE 22455
22453: GO 22466
22455: POP
// c = 1 ; dark-green :
22456: LD_ADDR_VAR 0 5
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
22464: GO 22752
22466: LD_STRING dark-green
22468: DOUBLE
22469: EQUAL
22470: IFTRUE 22474
22472: GO 22485
22474: POP
// c = 2 ; purple :
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
22483: GO 22752
22485: LD_STRING purple
22487: DOUBLE
22488: EQUAL
22489: IFTRUE 22493
22491: GO 22504
22493: POP
// c = 3 ; aqua :
22494: LD_ADDR_VAR 0 5
22498: PUSH
22499: LD_INT 3
22501: ST_TO_ADDR
22502: GO 22752
22504: LD_STRING aqua
22506: DOUBLE
22507: EQUAL
22508: IFTRUE 22512
22510: GO 22523
22512: POP
// c = 4 ; grey :
22513: LD_ADDR_VAR 0 5
22517: PUSH
22518: LD_INT 4
22520: ST_TO_ADDR
22521: GO 22752
22523: LD_STRING grey
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22542
22531: POP
// c = 5 ; lime :
22532: LD_ADDR_VAR 0 5
22536: PUSH
22537: LD_INT 5
22539: ST_TO_ADDR
22540: GO 22752
22542: LD_STRING lime
22544: DOUBLE
22545: EQUAL
22546: IFTRUE 22550
22548: GO 22561
22550: POP
// c = 6 ; tan :
22551: LD_ADDR_VAR 0 5
22555: PUSH
22556: LD_INT 6
22558: ST_TO_ADDR
22559: GO 22752
22561: LD_STRING tan
22563: DOUBLE
22564: EQUAL
22565: IFTRUE 22569
22567: GO 22580
22569: POP
// c = 7 ; pink :
22570: LD_ADDR_VAR 0 5
22574: PUSH
22575: LD_INT 7
22577: ST_TO_ADDR
22578: GO 22752
22580: LD_STRING pink
22582: DOUBLE
22583: EQUAL
22584: IFTRUE 22588
22586: GO 22599
22588: POP
// c = 8 ; green :
22589: LD_ADDR_VAR 0 5
22593: PUSH
22594: LD_INT 8
22596: ST_TO_ADDR
22597: GO 22752
22599: LD_STRING green
22601: DOUBLE
22602: EQUAL
22603: IFTRUE 22607
22605: GO 22618
22607: POP
// c = 9 ; blue :
22608: LD_ADDR_VAR 0 5
22612: PUSH
22613: LD_INT 9
22615: ST_TO_ADDR
22616: GO 22752
22618: LD_STRING blue
22620: DOUBLE
22621: EQUAL
22622: IFTRUE 22626
22624: GO 22637
22626: POP
// c = 10 ; yellow :
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_INT 10
22634: ST_TO_ADDR
22635: GO 22752
22637: LD_STRING yellow
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22656
22645: POP
// c = 11 ; brown :
22646: LD_ADDR_VAR 0 5
22650: PUSH
22651: LD_INT 11
22653: ST_TO_ADDR
22654: GO 22752
22656: LD_STRING brown
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22675
22664: POP
// c = 12 ; black :
22665: LD_ADDR_VAR 0 5
22669: PUSH
22670: LD_INT 12
22672: ST_TO_ADDR
22673: GO 22752
22675: LD_STRING black
22677: DOUBLE
22678: EQUAL
22679: IFTRUE 22683
22681: GO 22694
22683: POP
// c = 13 ; aqua2 :
22684: LD_ADDR_VAR 0 5
22688: PUSH
22689: LD_INT 13
22691: ST_TO_ADDR
22692: GO 22752
22694: LD_STRING aqua2
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22713
22702: POP
// c = 14 ; orange :
22703: LD_ADDR_VAR 0 5
22707: PUSH
22708: LD_INT 14
22710: ST_TO_ADDR
22711: GO 22752
22713: LD_STRING orange
22715: DOUBLE
22716: EQUAL
22717: IFTRUE 22721
22719: GO 22732
22721: POP
// c = 15 ; white :
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 15
22729: ST_TO_ADDR
22730: GO 22752
22732: LD_STRING white
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22751
22740: POP
// c = 16 ; end ;
22741: LD_ADDR_VAR 0 5
22745: PUSH
22746: LD_INT 16
22748: ST_TO_ADDR
22749: GO 22752
22751: POP
// if HexInfo ( x , y ) = 0 then
22752: LD_VAR 0 1
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: CALL_OW 428
22766: PUSH
22767: LD_INT 0
22769: EQUAL
22770: IFFALSE 22794
// PlaceEnvironment ( x , y , 58 , c ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: LD_INT 58
22784: PPUSH
22785: LD_VAR 0 5
22789: PPUSH
22790: CALL_OW 349
// end ;
22794: LD_VAR 0 4
22798: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22799: LD_INT 0
22801: PPUSH
// RemoveEnvironment ( x , y ) ;
22802: LD_VAR 0 1
22806: PPUSH
22807: LD_VAR 0 2
22811: PPUSH
22812: CALL_OW 347
// end ;
22816: LD_VAR 0 3
22820: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22821: LD_INT 0
22823: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22824: LD_ADDR_VAR 0 5
22828: PUSH
22829: LD_INT 81
22831: PUSH
22832: LD_VAR 0 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 92
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: LD_VAR 0 3
22853: PUSH
22854: LD_VAR 0 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PPUSH
22869: CALL_OW 69
22873: ST_TO_ADDR
// end ;
22874: LD_VAR 0 5
22878: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22879: LD_INT 0
22881: PPUSH
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22886: LD_VAR 0 1
22890: PPUSH
22891: LD_INT 81
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 255
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PPUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 74
22922: PPUSH
22923: CALL_OW 119
// dir := GetDir ( un ) ;
22927: LD_ADDR_VAR 0 4
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: CALL_OW 254
22941: ST_TO_ADDR
// dir := dir - 3 ;
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: LD_VAR 0 4
22951: PUSH
22952: LD_INT 3
22954: MINUS
22955: ST_TO_ADDR
// if dir < 0 then
22956: LD_VAR 0 4
22960: PUSH
22961: LD_INT 0
22963: LESS
22964: IFFALSE 22980
// dir := dir + 6 ;
22966: LD_ADDR_VAR 0 4
22970: PUSH
22971: LD_VAR 0 4
22975: PUSH
22976: LD_INT 6
22978: PLUS
22979: ST_TO_ADDR
// while true do
22980: LD_INT 1
22982: IFFALSE 23479
// begin coord_dist := 3 ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 3
22991: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: LD_VAR 0 3
23016: PPUSH
23017: CALL_OW 272
23021: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23022: LD_ADDR_VAR 0 6
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 251
23036: PPUSH
23037: LD_VAR 0 4
23041: PPUSH
23042: LD_VAR 0 3
23046: PPUSH
23047: CALL_OW 273
23051: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23052: LD_VAR 0 1
23056: PPUSH
23057: CALL_OW 255
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: CALL_OW 250
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 251
23081: PPUSH
23082: LD_INT 14
23084: PPUSH
23085: CALL 22821 0 4
23089: PUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: LD_VAR 0 6
23099: PPUSH
23100: CALL_OW 351
23104: OR
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 488
23120: PUSH
23121: LD_INT 0
23123: EQUAL
23124: OR
23125: PUSH
23126: LD_VAR 0 5
23130: PPUSH
23131: LD_VAR 0 6
23135: PPUSH
23136: CALL_OW 546
23140: PUSH
23141: LD_INT 1
23143: EQUAL
23144: OR
23145: PUSH
23146: LD_VAR 0 5
23150: PPUSH
23151: LD_VAR 0 6
23155: PPUSH
23156: CALL_OW 428
23160: PUSH
23161: LD_INT 0
23163: NONEQUAL
23164: OR
23165: IFFALSE 23393
// begin repeat begin Wait ( 0 0$0.3 ) ;
23167: LD_INT 10
23169: PPUSH
23170: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: LD_VAR 0 3
23183: PUSH
23184: LD_INT 1
23186: PLUS
23187: ST_TO_ADDR
// dir := dir + 1 ;
23188: LD_ADDR_VAR 0 4
23192: PUSH
23193: LD_VAR 0 4
23197: PUSH
23198: LD_INT 1
23200: PLUS
23201: ST_TO_ADDR
// if dir > 5 then
23202: LD_VAR 0 4
23206: PUSH
23207: LD_INT 5
23209: GREATER
23210: IFFALSE 23220
// dir = 0 ;
23212: LD_ADDR_VAR 0 4
23216: PUSH
23217: LD_INT 0
23219: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23220: LD_ADDR_VAR 0 5
23224: PUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: CALL_OW 250
23234: PPUSH
23235: LD_VAR 0 4
23239: PPUSH
23240: LD_VAR 0 3
23244: PPUSH
23245: CALL_OW 272
23249: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23250: LD_ADDR_VAR 0 6
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 251
23264: PPUSH
23265: LD_VAR 0 4
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: CALL_OW 273
23279: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 255
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: CALL_OW 250
23299: PPUSH
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 251
23309: PPUSH
23310: LD_INT 14
23312: PPUSH
23313: CALL 22821 0 4
23317: NOT
23318: PUSH
23319: LD_VAR 0 5
23323: PPUSH
23324: LD_VAR 0 6
23328: PPUSH
23329: CALL_OW 351
23333: NOT
23334: AND
23335: PUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 488
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 546
23366: PUSH
23367: LD_INT 0
23369: EQUAL
23370: AND
23371: PUSH
23372: LD_VAR 0 5
23376: PPUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 428
23386: PUSH
23387: LD_INT 0
23389: EQUAL
23390: AND
23391: IFFALSE 23167
// end ; ComMoveXY ( un , x , y ) ;
23393: LD_VAR 0 1
23397: PPUSH
23398: LD_VAR 0 5
23402: PPUSH
23403: LD_VAR 0 6
23407: PPUSH
23408: CALL_OW 111
// Wait ( 0 0$1 ) ;
23412: LD_INT 35
23414: PPUSH
23415: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23419: LD_VAR 0 1
23423: PPUSH
23424: LD_INT 81
23426: PUSH
23427: LD_VAR 0 1
23431: PPUSH
23432: CALL_OW 255
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_VAR 0 1
23450: PPUSH
23451: CALL_OW 74
23455: PPUSH
23456: CALL_OW 296
23460: PUSH
23461: LD_INT 14
23463: GREATEREQUAL
23464: IFFALSE 23477
// begin ComStop ( un ) ;
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 141
// break ;
23475: GO 23479
// end ; end ;
23477: GO 22980
// end ;
23479: LD_VAR 0 2
23483: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// x := GetX ( unit ) ;
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 250
23508: ST_TO_ADDR
// y := GetY ( unit ) ;
23509: LD_ADDR_VAR 0 4
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 251
23523: ST_TO_ADDR
// i := 0 ;
23524: LD_ADDR_VAR 0 8
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 81
23539: PUSH
23540: LD_VAR 0 1
23544: PPUSH
23545: CALL_OW 255
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 69
23558: PPUSH
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 74
23568: PPUSH
23569: CALL_OW 119
// dir := GetDir ( unit ) ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: CALL_OW 254
23587: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23588: LD_ADDR_VAR 0 9
23592: PUSH
23593: LD_INT 0
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 12
23603: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23604: LD_INT 10
23606: PPUSH
23607: CALL_OW 67
// if mode then
23611: LD_VAR 0 9
23615: IFFALSE 23633
// dir := dir + 1 else
23617: LD_ADDR_VAR 0 7
23621: PUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_INT 1
23629: PLUS
23630: ST_TO_ADDR
23631: GO 23647
// dir := dir - 1 ;
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: MINUS
23646: ST_TO_ADDR
// if ( dir < 0 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 0
23654: LESS
23655: IFFALSE 23665
// dir := 5 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 5
23664: ST_TO_ADDR
// if ( dir > 5 ) then
23665: LD_VAR 0 7
23669: PUSH
23670: LD_INT 5
23672: GREATER
23673: IFFALSE 23683
// dir := 0 ;
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: LD_INT 0
23682: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23683: LD_ADDR_VAR 0 5
23687: PUSH
23688: LD_VAR 0 3
23692: PPUSH
23693: LD_VAR 0 7
23697: PPUSH
23698: LD_INT 4
23700: PPUSH
23701: CALL_OW 272
23705: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23706: LD_ADDR_VAR 0 6
23710: PUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: LD_VAR 0 7
23720: PPUSH
23721: LD_INT 4
23723: PPUSH
23724: CALL_OW 273
23728: ST_TO_ADDR
// i := i + 1 ;
23729: LD_ADDR_VAR 0 8
23733: PUSH
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 1
23741: PLUS
23742: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23743: LD_VAR 0 1
23747: PPUSH
23748: CALL_OW 255
23752: PPUSH
23753: LD_VAR 0 5
23757: PPUSH
23758: LD_VAR 0 6
23762: PPUSH
23763: LD_INT 14
23765: PPUSH
23766: CALL 22821 0 4
23770: PUSH
23771: LD_INT 0
23773: EQUAL
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_VAR 0 6
23784: PPUSH
23785: CALL_OW 546
23789: PUSH
23790: LD_INT 0
23792: EQUAL
23793: AND
23794: PUSH
23795: LD_VAR 0 5
23799: PPUSH
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 428
23809: PUSH
23810: LD_INT 0
23812: EQUAL
23813: AND
23814: IFFALSE 23818
// break ;
23816: GO 23828
// end until i > 4 ;
23818: LD_VAR 0 8
23822: PUSH
23823: LD_INT 4
23825: GREATER
23826: IFFALSE 23604
// if x2 and y2 then
23828: LD_VAR 0 5
23832: PUSH
23833: LD_VAR 0 6
23837: AND
23838: IFFALSE 23861
// result := [ x2 , y2 ] else
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 5
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: ST_TO_ADDR
23859: GO 23890
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 250
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: CALL_OW 251
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// end ;
23890: LD_VAR 0 2
23894: RET
// export function MCT_Hex ( x , y ) ; begin
23895: LD_INT 0
23897: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL_OW 546
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 428
23932: PUSH
23933: EMPTY
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 3
23944: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23960: LD_ADDR_VAR 0 10
23964: PUSH
23965: LD_EXP 60
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PUSH
23976: LD_INT 1
23978: ARRAY
23979: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: LD_EXP 60
23989: PUSH
23990: LD_VAR 0 1
23994: ARRAY
23995: PUSH
23996: LD_INT 2
23998: ARRAY
23999: ST_TO_ADDR
// collectors := [ ] ;
24000: LD_ADDR_VAR 0 12
24004: PUSH
24005: EMPTY
24006: ST_TO_ADDR
// is_cargo := false ;
24007: LD_ADDR_VAR 0 13
24011: PUSH
24012: LD_INT 0
24014: ST_TO_ADDR
// if isTest then
24015: LD_EXP 1
24019: IFFALSE 24025
// TimerStart ( ) ;
24021: CALL_OW 548
// if MCF_Cargo ( side ) then
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL 12002 0 1
24034: IFFALSE 24061
// begin collectors := MCF_Cargo ( side ) ;
24036: LD_ADDR_VAR 0 12
24040: PUSH
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12002 0 1
24050: ST_TO_ADDR
// is_cargo := true ;
24051: LD_ADDR_VAR 0 13
24055: PUSH
24056: LD_INT 1
24058: ST_TO_ADDR
// end else
24059: GO 24210
// begin if MCF_ApeSpec ( side , engineer ) then
24061: LD_VAR 0 1
24065: PPUSH
24066: LD_STRING engineer
24068: PPUSH
24069: CALL 12148 0 2
24073: IFFALSE 24093
// collectors := MCF_ApeSpec ( side , engineer ) ;
24075: LD_ADDR_VAR 0 12
24079: PUSH
24080: LD_VAR 0 1
24084: PPUSH
24085: LD_STRING engineer
24087: PPUSH
24088: CALL 12148 0 2
24092: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24093: LD_VAR 0 1
24097: PPUSH
24098: LD_INT 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL 11734 0 3
24107: IFFALSE 24210
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL 11734 0 3
24128: ST_TO_ADDR
// if z > 5 then
24129: LD_VAR 0 7
24133: PUSH
24134: LD_INT 5
24136: GREATER
24137: IFFALSE 24149
// t1 := 5 else
24139: LD_ADDR_VAR 0 8
24143: PUSH
24144: LD_INT 5
24146: ST_TO_ADDR
24147: GO 24159
// t1 := z ;
24149: LD_ADDR_VAR 0 8
24153: PUSH
24154: LD_VAR 0 7
24158: ST_TO_ADDR
// for t2 = 1 to t1 do
24159: LD_ADDR_VAR 0 9
24163: PUSH
24164: DOUBLE
24165: LD_INT 1
24167: DEC
24168: ST_TO_ADDR
24169: LD_VAR 0 8
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24208
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24177: LD_ADDR_VAR 0 12
24181: PUSH
24182: LD_VAR 0 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: LD_VAR 0 7
24194: PUSH
24195: LD_VAR 0 9
24199: ARRAY
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
24206: GO 24174
24208: POP
24209: POP
// end ; end ; if not mode then
24210: LD_VAR 0 10
24214: NOT
24215: IFFALSE 24221
// exit else
24217: GO 24480
24219: GO 24480
// begin if collectors then
24221: LD_VAR 0 12
24225: IFFALSE 24480
// for i in areas do
24227: LD_ADDR_VAR 0 3
24231: PUSH
24232: LD_VAR 0 11
24236: PUSH
24237: FOR_IN
24238: IFFALSE 24478
// if GetListOfCratesInArea ( i ) then
24240: LD_VAR 0 3
24244: PPUSH
24245: CALL_OW 435
24249: IFFALSE 24476
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24251: LD_ADDR_VAR 0 5
24255: PUSH
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24270: LD_ADDR_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: PPUSH
24280: CALL_OW 435
24284: PUSH
24285: LD_INT 2
24287: ARRAY
24288: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24289: LD_VAR 0 13
24293: PUSH
24294: LD_VAR 0 12
24298: PUSH
24299: LD_INT 1
24301: ARRAY
24302: PPUSH
24303: CALL_OW 110
24307: PUSH
24308: LD_INT 0
24310: EQUAL
24311: AND
24312: IFFALSE 24374
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24314: LD_VAR 0 12
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 314
24327: NOT
24328: PUSH
24329: LD_VAR 0 12
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: CALL_OW 110
24342: PUSH
24343: LD_INT 0
24345: EQUAL
24346: AND
24347: IFFALSE 24372
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24349: LD_VAR 0 12
24353: PUSH
24354: LD_INT 1
24356: ARRAY
24357: PPUSH
24358: LD_VAR 0 5
24362: PPUSH
24363: LD_VAR 0 6
24367: PPUSH
24368: CALL_OW 117
// end ; end else
24372: GO 24460
// begin for j = 1 to collectors do
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: DOUBLE
24380: LD_INT 1
24382: DEC
24383: ST_TO_ADDR
24384: LD_VAR 0 12
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24458
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24392: LD_VAR 0 12
24396: PUSH
24397: LD_VAR 0 4
24401: ARRAY
24402: PPUSH
24403: CALL_OW 314
24407: NOT
24408: PUSH
24409: LD_VAR 0 12
24413: PUSH
24414: LD_VAR 0 4
24418: ARRAY
24419: PPUSH
24420: CALL_OW 110
24424: PUSH
24425: LD_INT 0
24427: EQUAL
24428: AND
24429: IFFALSE 24456
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24431: LD_VAR 0 12
24435: PUSH
24436: LD_VAR 0 4
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 5
24446: PPUSH
24447: LD_VAR 0 6
24451: PPUSH
24452: CALL 24851 0 3
// end ;
24456: GO 24389
24458: POP
24459: POP
// end ; if isTest then
24460: LD_EXP 1
24464: IFFALSE 24476
// begin debug_time := TimerEnd ( ) ;
24466: LD_ADDR_VAR 0 14
24470: PUSH
24471: CALL_OW 549
24475: ST_TO_ADDR
// end ; end ;
24476: GO 24237
24478: POP
24479: POP
// end ; end ;
24480: LD_VAR 0 2
24484: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24485: LD_INT 0
24487: PPUSH
24488: PPUSH
24489: PPUSH
24490: PPUSH
24491: PPUSH
24492: PPUSH
// if not area then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24504
// exit else
24500: GO 24766
24502: GO 24766
// if tick mod interval = 0 and Prob ( percent ) then
24504: LD_OWVAR 1
24508: PUSH
24509: LD_VAR 0 4
24513: MOD
24514: PUSH
24515: LD_INT 0
24517: EQUAL
24518: PUSH
24519: LD_VAR 0 3
24523: PPUSH
24524: CALL_OW 13
24528: AND
24529: IFFALSE 24766
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24531: LD_VAR 0 1
24535: PPUSH
24536: CALL_OW 435
24540: PUSH
24541: LD_VAR 0 5
24545: LESS
24546: PUSH
24547: LD_VAR 0 5
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: OR
24556: IFFALSE 24766
// begin Randomize ;
24558: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24562: LD_ADDR_VAR 0 7
24566: PUSH
24567: LD_INT 1
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 12
24579: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24580: LD_ADDR_VAR 0 9
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 517
24597: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24598: LD_ADDR_VAR 0 8
24602: PUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PUSH
24611: LD_INT 1
24613: ARRAY
24614: PPUSH
24615: CALL_OW 12
24619: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24620: LD_VAR 0 9
24624: PUSH
24625: LD_INT 1
24627: ARRAY
24628: PUSH
24629: LD_VAR 0 8
24633: ARRAY
24634: PPUSH
24635: LD_VAR 0 9
24639: PUSH
24640: LD_INT 2
24642: ARRAY
24643: PUSH
24644: LD_VAR 0 8
24648: ARRAY
24649: PPUSH
24650: CALL_OW 428
24654: PUSH
24655: LD_INT 0
24657: GREATER
24658: PUSH
24659: LD_VAR 0 9
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PUSH
24668: LD_VAR 0 8
24672: ARRAY
24673: PPUSH
24674: LD_VAR 0 9
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PUSH
24683: LD_VAR 0 8
24687: ARRAY
24688: PPUSH
24689: CALL_OW 284
24693: PUSH
24694: LD_INT 0
24696: GREATER
24697: AND
24698: IFFALSE 24724
// c := Rand ( 1 , tmp [ 1 ] ) ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 1
24707: PPUSH
24708: LD_VAR 0 9
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: CALL_OW 12
24721: ST_TO_ADDR
24722: GO 24620
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24724: LD_VAR 0 7
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PUSH
24738: LD_VAR 0 8
24742: ARRAY
24743: PPUSH
24744: LD_VAR 0 9
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PUSH
24753: LD_VAR 0 8
24757: ARRAY
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 54
// end ; end ; end ;
24766: LD_VAR 0 6
24770: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24771: LD_INT 0
24773: PPUSH
24774: PPUSH
// if not MREG_Crates then
24775: LD_EXP 34
24779: NOT
24780: IFFALSE 24784
// exit ;
24782: GO 24846
// for i = MREG_Crates downto 1 do
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: DOUBLE
24790: LD_EXP 34
24794: INC
24795: ST_TO_ADDR
24796: LD_INT 1
24798: PUSH
24799: FOR_DOWNTO
24800: IFFALSE 24844
// if MREG_Crates [ i ] [ 3 ] = 0 then
24802: LD_EXP 34
24806: PUSH
24807: LD_VAR 0 2
24811: ARRAY
24812: PUSH
24813: LD_INT 3
24815: ARRAY
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24842
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24822: LD_ADDR_EXP 34
24826: PUSH
24827: LD_EXP 34
24831: PPUSH
24832: LD_VAR 0 2
24836: PPUSH
24837: CALL_OW 3
24841: ST_TO_ADDR
24842: GO 24799
24844: POP
24845: POP
// end ;
24846: LD_VAR 0 1
24850: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not unit then
24857: LD_VAR 0 1
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25001
// if HasTask ( unit ) or not CanCarry ( unit ) then
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 314
24875: PUSH
24876: LD_VAR 0 1
24880: PPUSH
24881: CALL_OW 280
24885: NOT
24886: OR
24887: IFFALSE 24891
// exit ;
24889: GO 25001
// side := GetSide ( unit ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: CALL_OW 255
24905: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24906: LD_ADDR_VAR 0 7
24910: PUSH
24911: LD_VAR 0 6
24915: PPUSH
24916: LD_INT 30
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PPUSH
24926: CALL 11651 0 2
24930: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24931: LD_VAR 0 1
24935: PPUSH
24936: CALL_OW 281
24940: PUSH
24941: LD_VAR 0 7
24945: NOT
24946: OR
24947: IFFALSE 24953
// exit else
24949: GO 25001
24951: GO 25001
// if GetResourceAmountXY ( x , y ) then
24953: LD_VAR 0 2
24957: PPUSH
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 284
24967: IFFALSE 24999
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_VAR 0 2
24978: PPUSH
24979: LD_VAR 0 3
24983: PPUSH
24984: LD_VAR 0 7
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: CALL 32061 0 4
// end else
24997: GO 25001
// exit ;
24999: GO 25001
// end ;
25001: LD_VAR 0 4
25005: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25006: LD_INT 0
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
// result := [ ] ;
25013: LD_ADDR_VAR 0 2
25017: PUSH
25018: EMPTY
25019: ST_TO_ADDR
// p := 1 ;
25020: LD_ADDR_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_EXP 63
25042: PUSH
25043: LD_VAR 0 1
25047: ARRAY
25048: PUSH
25049: LD_INT 1
25051: ARRAY
25052: PUSH
25053: LD_INT 2
25055: DIVREAL
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25182
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25060: LD_ADDR_VAR 0 5
25064: PUSH
25065: LD_INT 81
25067: PUSH
25068: LD_VAR 0 1
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 92
25079: PUSH
25080: LD_EXP 63
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PUSH
25095: LD_VAR 0 4
25099: ARRAY
25100: PUSH
25101: LD_EXP 63
25105: PUSH
25106: LD_VAR 0 1
25110: ARRAY
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_INT 1
25123: PLUS
25124: ARRAY
25125: PUSH
25126: LD_INT 12
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: ST_TO_ADDR
// if tmp then
25144: LD_VAR 0 5
25148: IFFALSE 25166
// result := result union tmp ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_VAR 0 5
25164: UNION
25165: ST_TO_ADDR
// p := p + 2 ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 2
25178: PLUS
25179: ST_TO_ADDR
// end ;
25180: GO 25057
25182: POP
25183: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25184: LD_EXP 64
25188: PUSH
25189: LD_VAR 0 1
25193: ARRAY
25194: PPUSH
25195: LD_INT 81
25197: PUSH
25198: LD_VAR 0 1
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PPUSH
25207: CALL_OW 70
25211: IFFALSE 25252
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25213: LD_ADDR_VAR 0 2
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_EXP 64
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_INT 81
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PPUSH
25246: CALL_OW 70
25250: UNION
25251: ST_TO_ADDR
// end ; end_of_file
25252: LD_VAR 0 2
25256: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
// pom := GetBase ( fac ) ;
25262: LD_ADDR_VAR 0 5
25266: PUSH
25267: LD_VAR 0 1
25271: PPUSH
25272: CALL_OW 274
25276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25277: LD_ADDR_VAR 0 4
25281: PUSH
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: LD_VAR 0 2
25295: PUSH
25296: LD_INT 2
25298: ARRAY
25299: PPUSH
25300: LD_VAR 0 2
25304: PUSH
25305: LD_INT 3
25307: ARRAY
25308: PPUSH
25309: LD_VAR 0 2
25313: PUSH
25314: LD_INT 4
25316: ARRAY
25317: PPUSH
25318: CALL_OW 449
25322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25323: LD_ADDR_VAR 0 3
25327: PUSH
25328: LD_VAR 0 5
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: CALL_OW 275
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: GREATEREQUAL
25350: PUSH
25351: LD_VAR 0 5
25355: PPUSH
25356: LD_INT 2
25358: PPUSH
25359: CALL_OW 275
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_INT 2
25371: ARRAY
25372: GREATEREQUAL
25373: AND
25374: PUSH
25375: LD_VAR 0 5
25379: PPUSH
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 275
25387: PUSH
25388: LD_VAR 0 4
25392: PUSH
25393: LD_INT 3
25395: ARRAY
25396: GREATEREQUAL
25397: AND
25398: ST_TO_ADDR
// end ;
25399: LD_VAR 0 3
25403: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25404: LD_INT 0
25406: PPUSH
25407: PPUSH
25408: PPUSH
// result := false ;
25409: LD_ADDR_VAR 0 3
25413: PUSH
25414: LD_INT 0
25416: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25417: LD_ADDR_VAR 0 4
25421: PUSH
25422: LD_EXP 51
25426: PUSH
25427: LD_VAR 0 1
25431: ARRAY
25432: ST_TO_ADDR
// if tmp then
25433: LD_VAR 0 4
25437: IFFALSE 25491
// for i = 1 to tmp do
25439: LD_ADDR_VAR 0 5
25443: PUSH
25444: DOUBLE
25445: LD_INT 1
25447: DEC
25448: ST_TO_ADDR
25449: LD_VAR 0 4
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25489
// if component = tmp [ i ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 4
25466: PUSH
25467: LD_VAR 0 5
25471: ARRAY
25472: EQUAL
25473: IFFALSE 25487
// begin result := true ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_INT 1
25482: ST_TO_ADDR
// exit ;
25483: POP
25484: POP
25485: GO 25491
// end ;
25487: GO 25454
25489: POP
25490: POP
// end ;
25491: LD_VAR 0 3
25495: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25496: LD_INT 0
25498: PPUSH
25499: PPUSH
25500: PPUSH
// result := false ;
25501: LD_ADDR_VAR 0 4
25505: PUSH
25506: LD_INT 0
25508: ST_TO_ADDR
// if fac then
25509: LD_VAR 0 2
25513: IFFALSE 25736
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25515: LD_VAR 0 2
25519: PPUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL 25257 0 2
25529: PUSH
25530: LD_VAR 0 2
25534: PPUSH
25535: CALL_OW 461
25539: PUSH
25540: LD_INT 2
25542: EQUAL
25543: AND
25544: PUSH
25545: LD_VAR 0 2
25549: PPUSH
25550: LD_VAR 0 3
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 3
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: LD_VAR 0 3
25572: PUSH
25573: LD_INT 3
25575: ARRAY
25576: PPUSH
25577: LD_VAR 0 3
25581: PUSH
25582: LD_INT 4
25584: ARRAY
25585: PPUSH
25586: CALL_OW 448
25590: AND
25591: IFFALSE 25736
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25593: LD_VAR 0 2
25597: PPUSH
25598: LD_VAR 0 3
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 3
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_INT 3
25623: ARRAY
25624: PPUSH
25625: LD_VAR 0 3
25629: PUSH
25630: LD_INT 4
25632: ARRAY
25633: PPUSH
25634: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_EXP 51
25647: PUSH
25648: LD_VAR 0 1
25652: ARRAY
25653: ST_TO_ADDR
// for i = 4 downto 1 do
25654: LD_ADDR_VAR 0 5
25658: PUSH
25659: DOUBLE
25660: LD_INT 4
25662: INC
25663: ST_TO_ADDR
25664: LD_INT 1
25666: PUSH
25667: FOR_DOWNTO
25668: IFFALSE 25701
// tab := Remove ( tab , list [ i ] , true ) ;
25670: LD_ADDR_VAR 0 6
25674: PUSH
25675: LD_VAR 0 6
25679: PPUSH
25680: LD_VAR 0 3
25684: PUSH
25685: LD_VAR 0 5
25689: ARRAY
25690: PPUSH
25691: LD_INT 1
25693: PPUSH
25694: CALL 31289 0 3
25698: ST_TO_ADDR
25699: GO 25667
25701: POP
25702: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25703: LD_ADDR_EXP 51
25707: PUSH
25708: LD_EXP 51
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_VAR 0 6
25722: PPUSH
25723: CALL_OW 1
25727: ST_TO_ADDR
// result := true ;
25728: LD_ADDR_VAR 0 4
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// end ; end ; end ;
25736: LD_VAR 0 4
25740: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25741: LD_INT 0
25743: PPUSH
25744: PPUSH
// if not veh then
25745: LD_VAR 0 2
25749: NOT
25750: IFFALSE 25754
// exit ;
25752: GO 25928
// if MREG_Parking [ side ] then
25754: LD_EXP 58
25758: PUSH
25759: LD_VAR 0 1
25763: ARRAY
25764: IFFALSE 25928
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25766: LD_VAR 0 2
25770: PPUSH
25771: LD_EXP 58
25775: PUSH
25776: LD_VAR 0 1
25780: ARRAY
25781: PPUSH
25782: CALL_OW 308
25786: NOT
25787: IFFALSE 25928
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_EXP 58
25798: PUSH
25799: LD_VAR 0 1
25803: ARRAY
25804: PPUSH
25805: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25809: LD_VAR 0 2
25813: PPUSH
25814: CALL_OW 263
25818: PUSH
25819: LD_INT 1
25821: EQUAL
25822: IFFALSE 25928
// begin i := GetDriver ( veh ) ;
25824: LD_ADDR_VAR 0 4
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: CALL 31773 0 1
25838: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25846: LD_VAR 0 2
25850: PPUSH
25851: LD_EXP 58
25855: PUSH
25856: LD_VAR 0 1
25860: ARRAY
25861: PPUSH
25862: CALL_OW 308
25866: PUSH
25867: LD_VAR 0 2
25871: PPUSH
25872: CALL_OW 301
25876: OR
25877: IFFALSE 25839
// ComExitVehicle ( i ) ;
25879: LD_VAR 0 4
25883: PPUSH
25884: CALL_OW 121
// Wait ( 1 ) ;
25888: LD_INT 1
25890: PPUSH
25891: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL 11651 0 2
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PPUSH
25924: CALL_OW 180
// end ; end ; end ;
25928: LD_VAR 0 3
25932: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
25937: PPUSH
25938: PPUSH
25939: PPUSH
25940: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25941: LD_VAR 0 1
25945: PPUSH
25946: LD_INT 30
25948: PUSH
25949: LD_INT 3
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL 11651 0 2
25960: IFFALSE 26144
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25962: LD_VAR 0 1
25966: PPUSH
25967: LD_INT 30
25969: PUSH
25970: LD_INT 3
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL 11651 0 2
25981: PUSH
25982: LD_INT 1
25984: ARRAY
25985: PPUSH
25986: CALL_OW 461
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 26144
// begin for i = 1 to MREG_TurretWeapon do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_EXP 43
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26142
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26014: LD_EXP 43
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 1
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 1
26033: EQUAL
26034: IFFALSE 26140
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_EXP 43
26045: PUSH
26046: LD_VAR 0 3
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26056: LD_ADDR_VAR 0 6
26060: PUSH
26061: LD_EXP 43
26065: PUSH
26066: LD_VAR 0 3
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26080: LD_ADDR_VAR 0 7
26084: PUSH
26085: LD_EXP 43
26089: PUSH
26090: LD_VAR 0 3
26094: ARRAY
26095: PUSH
26096: LD_INT 3
26098: ARRAY
26099: PUSH
26100: LD_INT 2
26102: ARRAY
26103: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26104: LD_ADDR_VAR 0 4
26108: PUSH
26109: LD_VAR 0 6
26113: PPUSH
26114: LD_VAR 0 7
26118: PPUSH
26119: CALL_OW 428
26123: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26124: LD_VAR 0 4
26128: PPUSH
26129: LD_VAR 0 5
26133: PPUSH
26134: CALL_OW 148
// break ;
26138: GO 26142
// end ;
26140: GO 26011
26142: POP
26143: POP
// end ; end ;
26144: LD_VAR 0 2
26148: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26149: LD_INT 0
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_INT 32
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL 11651 0 2
26179: ST_TO_ADDR
// if not tmp then
26180: LD_VAR 0 4
26184: NOT
26185: IFFALSE 26191
// exit else
26187: GO 26273
26189: GO 26273
// begin for i = 1 to tmp do
26191: LD_ADDR_VAR 0 3
26195: PUSH
26196: DOUBLE
26197: LD_INT 1
26199: DEC
26200: ST_TO_ADDR
26201: LD_VAR 0 4
26205: PUSH
26206: FOR_TO
26207: IFFALSE 26271
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26209: LD_VAR 0 4
26213: PUSH
26214: LD_VAR 0 3
26218: ARRAY
26219: PPUSH
26220: CALL_OW 261
26224: PUSH
26225: LD_INT 20
26227: LESS
26228: PUSH
26229: LD_VAR 0 4
26233: PUSH
26234: LD_VAR 0 3
26238: ARRAY
26239: PPUSH
26240: CALL_OW 110
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: AND
26249: IFFALSE 26269
// begin SetTag ( tmp [ i ] , 21 ) ;
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 3
26260: ARRAY
26261: PPUSH
26262: LD_INT 21
26264: PPUSH
26265: CALL_OW 109
// end ;
26269: GO 26206
26271: POP
26272: POP
// end ; end ;
26273: LD_VAR 0 2
26277: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26278: LD_INT 0
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
26284: PPUSH
// if not unit then
26285: LD_VAR 0 1
26289: NOT
26290: IFFALSE 26294
// exit ;
26292: GO 26482
// side := GetSide ( unit ) ;
26294: LD_ADDR_VAR 0 3
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 255
26308: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26309: LD_ADDR_VAR 0 5
26313: PUSH
26314: LD_VAR 0 3
26318: PPUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 3
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 30
26344: PUSH
26345: LD_INT 29
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL 11651 0 2
26362: ST_TO_ADDR
// if not b then
26363: LD_VAR 0 5
26367: NOT
26368: IFFALSE 26372
// exit ;
26370: GO 26482
// if GetTag ( unit ) = 21 then
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 110
26381: PUSH
26382: LD_INT 21
26384: EQUAL
26385: IFFALSE 26482
// begin c := NearestUnitToUnit ( b , unit ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_VAR 0 5
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 74
26406: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26407: LD_VAR 0 1
26411: PPUSH
26412: LD_VAR 0 6
26416: PPUSH
26417: CALL_OW 250
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: CALL_OW 251
26431: PPUSH
26432: CALL_OW 297
26436: PUSH
26437: LD_INT 6
26439: GREATER
26440: IFFALSE 26458
// ComMoveUnit ( unit , c ) else
26442: LD_VAR 0 1
26446: PPUSH
26447: LD_VAR 0 6
26451: PPUSH
26452: CALL_OW 112
26456: GO 26482
// begin SetFuel ( unit , 100 ) ;
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_INT 100
26465: PPUSH
26466: CALL_OW 240
// SetTag ( unit , 0 ) ;
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 0
26477: PPUSH
26478: CALL_OW 109
// end ; end ; end ;
26482: LD_VAR 0 2
26486: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26487: LD_INT 0
26489: PPUSH
26490: PPUSH
26491: PPUSH
26492: PPUSH
26493: PPUSH
26494: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26495: LD_ADDR_VAR 0 7
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 33
26507: PUSH
26508: LD_INT 2
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 61
26520: PUSH
26521: EMPTY
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PPUSH
26532: CALL 11651 0 2
26536: ST_TO_ADDR
// if not vehs then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26831
// if nation = 1 then
26546: LD_VAR 0 2
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26724
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26556: LD_VAR 0 1
26560: PPUSH
26561: LD_INT 30
26563: PUSH
26564: LD_INT 36
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PPUSH
26571: CALL 11651 0 2
26575: NOT
26576: IFFALSE 26582
// exit else
26578: GO 26831
26580: GO 26722
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26582: LD_ADDR_VAR 0 5
26586: PUSH
26587: LD_VAR 0 1
26591: PPUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 36
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PPUSH
26602: CALL 11651 0 2
26606: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26607: LD_ADDR_VAR 0 6
26611: PUSH
26612: LD_VAR 0 5
26616: PUSH
26617: LD_INT 1
26619: ARRAY
26620: PPUSH
26621: CALL_OW 313
26625: ST_TO_ADDR
// for i = vehs downto 1 do
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: DOUBLE
26632: LD_VAR 0 7
26636: INC
26637: ST_TO_ADDR
26638: LD_INT 1
26640: PUSH
26641: FOR_DOWNTO
26642: IFFALSE 26720
// begin if not IsControledBy ( vehs [ i ] ) then
26644: LD_VAR 0 7
26648: PUSH
26649: LD_VAR 0 4
26653: ARRAY
26654: PPUSH
26655: CALL_OW 312
26659: NOT
26660: IFFALSE 26718
// begin tmp := MCV_RemoteDriver ( oper ) ;
26662: LD_ADDR_VAR 0 8
26666: PUSH
26667: LD_VAR 0 6
26671: PPUSH
26672: CALL 26836 0 1
26676: ST_TO_ADDR
// if not tmp then
26677: LD_VAR 0 8
26681: NOT
26682: IFFALSE 26690
// exit else
26684: POP
26685: POP
26686: GO 26831
26688: GO 26718
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26690: LD_VAR 0 7
26694: PUSH
26695: LD_VAR 0 4
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: CALL_OW 135
// end ; end ;
26718: GO 26641
26720: POP
26721: POP
// end ; end else
26722: GO 26831
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_INT 34
26731: PUSH
26732: LD_INT 31
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL 11651 0 2
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 26831
26748: GO 26831
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 1
26759: PPUSH
26760: LD_INT 34
26762: PUSH
26763: LD_INT 31
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PPUSH
26770: CALL 11651 0 2
26774: ST_TO_ADDR
// oper := [ ] ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: EMPTY
26781: ST_TO_ADDR
// for i = 1 to ct do
26782: LD_ADDR_VAR 0 4
26786: PUSH
26787: DOUBLE
26788: LD_INT 1
26790: DEC
26791: ST_TO_ADDR
26792: LD_VAR 0 5
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26829
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26800: LD_ADDR_VAR 0 6
26804: PUSH
26805: LD_VAR 0 6
26809: PUSH
26810: LD_VAR 0 5
26814: PUSH
26815: LD_VAR 0 4
26819: ARRAY
26820: PPUSH
26821: CALL 31773 0 1
26825: ADD
26826: ST_TO_ADDR
26827: GO 26797
26829: POP
26830: POP
// end ; end ; end ;
26831: LD_VAR 0 3
26835: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
// if not drivers then
26844: LD_VAR 0 1
26848: NOT
26849: IFFALSE 26855
// exit else
26851: GO 27135
26853: GO 27135
// begin linked := [ ] ;
26855: LD_ADDR_VAR 0 5
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// for i = 1 to drivers do
26862: LD_ADDR_VAR 0 3
26866: PUSH
26867: DOUBLE
26868: LD_INT 1
26870: DEC
26871: ST_TO_ADDR
26872: LD_VAR 0 1
26876: PUSH
26877: FOR_TO
26878: IFFALSE 27123
// begin if CanControl ( drivers [ i ] ) then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_VAR 0 3
26889: ARRAY
26890: PPUSH
26891: CALL 32163 0 1
26895: IFFALSE 27121
// if i > 1 then
26897: LD_VAR 0 3
26901: PUSH
26902: LD_INT 1
26904: GREATER
26905: IFFALSE 27082
// begin m := false ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26915: LD_ADDR_VAR 0 7
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_VAR 0 3
26929: ARRAY
26930: PPUSH
26931: CALL_OW 432
26935: ST_TO_ADDR
// for j = 1 to linked do
26936: LD_ADDR_VAR 0 4
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_VAR 0 5
26950: PUSH
26951: FOR_TO
26952: IFFALSE 27026
// begin if l < linked [ j ] [ 2 ] then
26954: LD_VAR 0 7
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: LD_VAR 0 4
26968: ARRAY
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: LESS
26974: IFFALSE 27024
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: LD_VAR 0 1
26993: PUSH
26994: LD_VAR 0 3
26998: ARRAY
26999: PUSH
27000: LD_VAR 0 7
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 2
27013: ST_TO_ADDR
// m := true ;
27014: LD_ADDR_VAR 0 6
27018: PUSH
27019: LD_INT 1
27021: ST_TO_ADDR
// break ;
27022: GO 27026
// end ; end ;
27024: GO 26951
27026: POP
27027: POP
// if not m then
27028: LD_VAR 0 6
27032: NOT
27033: IFFALSE 27080
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27035: LD_ADDR_VAR 0 5
27039: PUSH
27040: LD_VAR 0 5
27044: PUSH
27045: LD_VAR 0 1
27049: PUSH
27050: LD_VAR 0 3
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: ARRAY
27066: PPUSH
27067: CALL_OW 432
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: EMPTY
27077: LIST
27078: ADD
27079: ST_TO_ADDR
// end else
27080: GO 27121
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27082: LD_ADDR_VAR 0 5
27086: PUSH
27087: LD_VAR 0 1
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: PUSH
27098: LD_VAR 0 1
27102: PUSH
27103: LD_VAR 0 3
27107: ARRAY
27108: PPUSH
27109: CALL_OW 432
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: ST_TO_ADDR
// end ;
27121: GO 26877
27123: POP
27124: POP
// result := linked ;
27125: LD_ADDR_VAR 0 2
27129: PUSH
27130: LD_VAR 0 5
27134: ST_TO_ADDR
// end ; end ;
27135: LD_VAR 0 2
27139: RET
// export function MCV_ToRepair ( unit ) ; begin
27140: LD_INT 0
27142: PPUSH
// if not unit then
27143: LD_VAR 0 1
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27183
// SetTag ( unit , 6 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 6
27159: PPUSH
27160: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27164: LD_VAR 0 1
27168: PPUSH
27169: CALL_OW 255
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL 25741 0 2
// end ;
27183: LD_VAR 0 2
27187: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27192: LD_VAR 0 1
27196: PPUSH
27197: LD_INT 6
27199: PPUSH
27200: EMPTY
27201: PPUSH
27202: CALL 12354 0 3
27206: IFFALSE 27299
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: DOUBLE
27214: LD_VAR 0 1
27218: PPUSH
27219: LD_INT 6
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 12354 0 3
27228: INC
27229: ST_TO_ADDR
27230: LD_INT 1
27232: PUSH
27233: FOR_DOWNTO
27234: IFFALSE 27297
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27236: LD_VAR 0 1
27240: PPUSH
27241: LD_INT 6
27243: PPUSH
27244: EMPTY
27245: PPUSH
27246: CALL 12354 0 3
27250: PUSH
27251: LD_VAR 0 3
27255: ARRAY
27256: PPUSH
27257: CALL_OW 256
27261: PUSH
27262: LD_INT 1000
27264: EQUAL
27265: IFFALSE 27295
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 6
27274: PPUSH
27275: EMPTY
27276: PPUSH
27277: CALL 12354 0 3
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 0
27290: PPUSH
27291: CALL_OW 109
27295: GO 27233
27297: POP
27298: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27299: LD_VAR 0 1
27303: PPUSH
27304: LD_INT 10
27306: PPUSH
27307: EMPTY
27308: PPUSH
27309: CALL 12354 0 3
27313: IFFALSE 27430
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: DOUBLE
27321: LD_VAR 0 1
27325: PPUSH
27326: LD_INT 10
27328: PPUSH
27329: EMPTY
27330: PPUSH
27331: CALL 12354 0 3
27335: INC
27336: ST_TO_ADDR
27337: LD_INT 1
27339: PUSH
27340: FOR_DOWNTO
27341: IFFALSE 27428
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27343: LD_VAR 0 1
27347: PPUSH
27348: LD_INT 10
27350: PPUSH
27351: EMPTY
27352: PPUSH
27353: CALL 12354 0 3
27357: PUSH
27358: LD_VAR 0 3
27362: ARRAY
27363: PPUSH
27364: CALL_OW 302
27368: NOT
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: LD_INT 10
27377: PPUSH
27378: EMPTY
27379: PPUSH
27380: CALL 12354 0 3
27384: PUSH
27385: LD_VAR 0 3
27389: ARRAY
27390: PPUSH
27391: CALL_OW 301
27395: OR
27396: IFFALSE 27426
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27398: LD_VAR 0 1
27402: PPUSH
27403: LD_INT 10
27405: PPUSH
27406: EMPTY
27407: PPUSH
27408: CALL 12354 0 3
27412: PUSH
27413: LD_VAR 0 3
27417: ARRAY
27418: PPUSH
27419: LD_INT 0
27421: PPUSH
27422: CALL_OW 109
27426: GO 27340
27428: POP
27429: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27430: LD_ADDR_VAR 0 3
27434: PUSH
27435: LD_VAR 0 1
27439: PPUSH
27440: EMPTY
27441: PPUSH
27442: CALL 11952 0 2
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 7
27454: PPUSH
27455: EMPTY
27456: PPUSH
27457: CALL 12354 0 3
27461: DIFF
27462: PUSH
27463: FOR_IN
27464: IFFALSE 27508
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27466: LD_VAR 0 3
27470: PPUSH
27471: CALL_OW 256
27475: PUSH
27476: LD_INT 650
27478: LESS
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 110
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: NOT
27494: AND
27495: IFFALSE 27506
// MCV_ToRepair ( i ) ;
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL 27140 0 1
27506: GO 27463
27508: POP
27509: POP
// end ; end_of_file end_of_file
27510: LD_VAR 0 2
27514: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27515: LD_STRING SAILEvent [
27517: PUSH
27518: LD_VAR 0 1
27522: STR
27523: PUSH
27524: LD_STRING ]
27526: STR
27527: PPUSH
27528: CALL 8039 0 1
// if event = 101 and dialog_north then
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 101
27539: EQUAL
27540: PUSH
27541: LD_EXP 6
27545: AND
27546: IFFALSE 27610
// begin dialog_north := false ;
27548: LD_ADDR_EXP 6
27552: PUSH
27553: LD_INT 0
27555: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27556: LD_EXP 5
27560: PPUSH
27561: LD_STRING DS1
27563: PUSH
27564: LD_STRING DS2
27566: PUSH
27567: LD_STRING DS3
27569: PUSH
27570: LD_STRING DS6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PPUSH
27582: LD_INT 4
27584: PPUSH
27585: CALL_OW 12
27589: ARRAY
27590: PPUSH
27591: CALL_OW 94
// Wait ( 4 4$00 ) ;
27595: LD_INT 8400
27597: PPUSH
27598: CALL_OW 67
// dialog_north := true ;
27602: LD_ADDR_EXP 6
27606: PUSH
27607: LD_INT 1
27609: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27610: LD_VAR 0 1
27614: PUSH
27615: LD_INT 102
27617: EQUAL
27618: PUSH
27619: LD_EXP 7
27623: AND
27624: IFFALSE 27684
// begin dialog_south := false ;
27626: LD_ADDR_EXP 7
27630: PUSH
27631: LD_INT 0
27633: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27634: LD_EXP 4
27638: PPUSH
27639: LD_STRING DJ1
27641: PUSH
27642: LD_STRING DJ4
27644: PUSH
27645: LD_STRING DJ6
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PPUSH
27656: LD_INT 3
27658: PPUSH
27659: CALL_OW 12
27663: ARRAY
27664: PPUSH
27665: CALL_OW 94
// Wait ( 4 4$00 ) ;
27669: LD_INT 8400
27671: PPUSH
27672: CALL_OW 67
// dialog_south := true ;
27676: LD_ADDR_EXP 7
27680: PUSH
27681: LD_INT 1
27683: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27684: LD_VAR 0 1
27688: PUSH
27689: LD_INT 104
27691: EQUAL
27692: PUSH
27693: LD_EXP 8
27697: AND
27698: IFFALSE 27720
// begin dialog_popov := false ;
27700: LD_ADDR_EXP 8
27704: PUSH
27705: LD_INT 0
27707: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27708: LD_EXP 24
27712: PPUSH
27713: LD_STRING DR4
27715: PPUSH
27716: CALL_OW 94
// end ; end ;
27720: PPOPN 1
27722: END
// on BuildingStarted ( b , unit ) do var side , i ;
27723: LD_INT 0
27725: PPUSH
27726: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27727: LD_EXP 39
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ARRAY
27742: IFFALSE 27920
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27744: LD_STRING BuildingStarted [side: 
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: CALL_OW 255
27756: STR
27757: PUSH
27758: LD_STRING ; btype: 
27760: STR
27761: PUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 266
27771: STR
27772: PUSH
27773: LD_STRING ; unit: 
27775: STR
27776: PUSH
27777: LD_VAR 0 2
27781: STR
27782: PUSH
27783: LD_STRING ]
27785: STR
27786: PPUSH
27787: CALL 8039 0 1
// side := GetSide ( b ) ;
27791: LD_ADDR_VAR 0 3
27795: PUSH
27796: LD_VAR 0 1
27800: PPUSH
27801: CALL_OW 255
27805: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 21
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PPUSH
27821: CALL 11651 0 2
27825: PUSH
27826: LD_INT 1
27828: EQUAL
27829: IFFALSE 27920
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27831: LD_ADDR_VAR 0 4
27835: PUSH
27836: LD_VAR 0 3
27840: PPUSH
27841: LD_INT 21
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PPUSH
27851: CALL 11651 0 2
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: EMPTY
27865: PPUSH
27866: CALL 11734 0 3
27870: DIFF
27871: PUSH
27872: FOR_IN
27873: IFFALSE 27918
// if not HasTask ( i ) then
27875: LD_VAR 0 4
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: IFFALSE 27916
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27887: LD_VAR 0 4
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 250
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 251
27911: PPUSH
27912: CALL_OW 111
27916: GO 27872
27918: POP
27919: POP
// end ;
27920: PPOPN 4
27922: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27923: LD_EXP 39
27927: PUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 255
27937: ARRAY
27938: IFFALSE 28307
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27940: LD_STRING BuildingComplete [side: 
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 255
27952: STR
27953: PUSH
27954: LD_STRING ; btype: 
27956: STR
27957: PUSH
27958: LD_VAR 0 1
27962: PPUSH
27963: CALL_OW 266
27967: STR
27968: PUSH
27969: LD_STRING ]
27971: STR
27972: PPUSH
27973: CALL 8039 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27977: LD_ADDR_EXP 46
27981: PUSH
27982: LD_EXP 46
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 255
27996: PPUSH
27997: LD_VAR 0 1
28001: PPUSH
28002: CALL_OW 266
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 250
28016: PUSH
28017: LD_VAR 0 1
28021: PPUSH
28022: CALL_OW 251
28026: PUSH
28027: LD_VAR 0 1
28031: PPUSH
28032: CALL_OW 254
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL 42051 0 4
28046: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 266
28056: PUSH
28057: LD_INT 6
28059: EQUAL
28060: IFFALSE 28094
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28062: LD_ADDR_EXP 40
28066: PUSH
28067: LD_EXP 40
28071: PPUSH
28072: LD_VAR 0 1
28076: PPUSH
28077: CALL_OW 255
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: EMPTY
28088: PPUSH
28089: CALL 41960 0 4
28093: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 266
28103: PUSH
28104: LD_INT 0
28106: EQUAL
28107: IFFALSE 28217
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28109: LD_ADDR_EXP 48
28113: PUSH
28114: LD_EXP 48
28118: PPUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 255
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: EMPTY
28133: PPUSH
28134: CALL 41960 0 4
28138: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 274
28148: PPUSH
28149: LD_INT 1
28151: PPUSH
28152: LD_EXP 72
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: CALL_OW 274
28174: PPUSH
28175: LD_INT 2
28177: PPUSH
28178: LD_EXP 72
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28191: LD_VAR 0 1
28195: PPUSH
28196: CALL_OW 274
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 72
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PPUSH
28213: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 266
28226: PUSH
28227: LD_INT 2
28229: EQUAL
28230: IFFALSE 28262
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28232: LD_ADDR_EXP 48
28236: PUSH
28237: LD_EXP 48
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: CALL_OW 255
28251: PPUSH
28252: LD_INT 2
28254: PPUSH
28255: EMPTY
28256: PPUSH
28257: CALL 41960 0 4
28261: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 4
28274: EQUAL
28275: IFFALSE 28307
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28277: LD_ADDR_EXP 48
28281: PUSH
28282: LD_EXP 48
28286: PPUSH
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_INT 4
28299: PPUSH
28300: EMPTY
28301: PPUSH
28302: CALL 41960 0 4
28306: ST_TO_ADDR
// end ;
28307: PPOPN 1
28309: END
// on ResearchComplete ( tech , lab ) do var i ;
28310: LD_INT 0
28312: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28313: LD_EXP 39
28317: PUSH
28318: LD_VAR 0 2
28322: PPUSH
28323: CALL_OW 255
28327: ARRAY
28328: IFFALSE 28612
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28330: LD_STRING ResearchComplete [side: 
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: CALL_OW 255
28347: STR
28348: PUSH
28349: LD_STRING ; tech:
28351: STR
28352: PUSH
28353: LD_VAR 0 1
28357: STR
28358: PUSH
28359: LD_STRING ]
28361: STR
28362: PPUSH
28363: CALL 8039 0 1
// for i = 1 to MREG_ToRes do
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: DOUBLE
28373: LD_INT 1
28375: DEC
28376: ST_TO_ADDR
28377: LD_EXP 50
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28470
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28385: LD_EXP 50
28389: PUSH
28390: LD_VAR 0 3
28394: ARRAY
28395: PUSH
28396: LD_INT 1
28398: ARRAY
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: EQUAL
28410: PUSH
28411: LD_EXP 50
28415: PUSH
28416: LD_VAR 0 3
28420: ARRAY
28421: PUSH
28422: LD_INT 2
28424: ARRAY
28425: PUSH
28426: LD_VAR 0 1
28430: EQUAL
28431: AND
28432: IFFALSE 28468
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28434: LD_ADDR_EXP 50
28438: PUSH
28439: LD_EXP 50
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: PPUSH
28454: LD_VAR 0 1
28458: PPUSH
28459: EMPTY
28460: PPUSH
28461: CALL 42051 0 4
28465: ST_TO_ADDR
// break ;
28466: GO 28470
// end ;
28468: GO 28382
28470: POP
28471: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28472: LD_VAR 0 1
28476: PUSH
28477: LD_INT 2
28479: PUSH
28480: LD_INT 11
28482: PUSH
28483: LD_INT 4
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: IN
28495: IFFALSE 28612
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28497: LD_ADDR_VAR 0 3
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: CALL_OW 255
28511: PPUSH
28512: LD_INT 16
28514: PPUSH
28515: LD_INT 25
28517: PUSH
28518: LD_INT 4
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL 12354 0 3
28529: ST_TO_ADDR
// if i then
28530: LD_VAR 0 3
28534: IFFALSE 28552
// SetTag ( i [ 1 ] , 0 ) ;
28536: LD_VAR 0 3
28540: PUSH
28541: LD_INT 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 0
28547: PPUSH
28548: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28552: LD_ADDR_VAR 0 3
28556: PUSH
28557: LD_VAR 0 2
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: LD_INT 171
28569: PPUSH
28570: EMPTY
28571: PPUSH
28572: CALL 12354 0 3
28576: ST_TO_ADDR
// if i then
28577: LD_VAR 0 3
28581: IFFALSE 28612
// begin SetTag ( i [ 1 ] , 0 ) ;
28583: LD_VAR 0 3
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_INT 0
28594: PPUSH
28595: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: CALL_OW 122
// end ; end ; end ;
28612: PPOPN 3
28614: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28615: LD_INT 0
28617: PPUSH
28618: PPUSH
28619: PPUSH
28620: PPUSH
28621: PPUSH
28622: PPUSH
28623: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28624: LD_VAR 0 1
28628: PPUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: CALL 59178 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28638: LD_EXP 39
28642: PUSH
28643: LD_VAR 0 2
28647: PPUSH
28648: CALL_OW 255
28652: ARRAY
28653: IFFALSE 29380
// begin side := GetSide ( veh ) ;
28655: LD_ADDR_VAR 0 4
28659: PUSH
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 255
28669: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 265
28684: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28685: LD_ADDR_VAR 0 7
28689: PUSH
28690: LD_VAR 0 1
28694: PPUSH
28695: CALL_OW 262
28699: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28700: LD_ADDR_VAR 0 8
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 263
28714: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 1
28724: PPUSH
28725: CALL_OW 264
28729: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28730: LD_STRING VehicleConstructed [side: 
28732: PUSH
28733: LD_VAR 0 4
28737: STR
28738: PUSH
28739: LD_STRING ; id:
28741: STR
28742: PUSH
28743: LD_VAR 0 1
28747: STR
28748: PUSH
28749: LD_STRING ; components: [
28751: STR
28752: PUSH
28753: LD_VAR 0 6
28757: STR
28758: PUSH
28759: LD_STRING , 
28761: STR
28762: PUSH
28763: LD_VAR 0 7
28767: STR
28768: PUSH
28769: LD_STRING , 
28771: STR
28772: PUSH
28773: LD_VAR 0 8
28777: STR
28778: PUSH
28779: LD_STRING , 
28781: STR
28782: PUSH
28783: LD_VAR 0 9
28787: STR
28788: PUSH
28789: LD_STRING ]]
28791: STR
28792: PPUSH
28793: CALL 8039 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_INT 13
28809: PUSH
28810: LD_INT 12
28812: PUSH
28813: LD_INT 14
28815: PUSH
28816: LD_INT 51
28818: PUSH
28819: LD_INT 53
28821: PUSH
28822: LD_INT 52
28824: PUSH
28825: LD_INT 32
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: IN
28837: NOT
28838: IFFALSE 28880
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28840: LD_ADDR_EXP 59
28844: PUSH
28845: LD_EXP 59
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: LD_EXP 59
28859: PUSH
28860: LD_VAR 0 4
28864: ARRAY
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 1
28874: PPUSH
28875: CALL 31130 0 4
28879: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 264
28889: PUSH
28890: LD_INT 31
28892: EQUAL
28893: IFFALSE 28912
// SetTag ( GetDriver ( veh ) , 9 ) ;
28895: LD_VAR 0 1
28899: PPUSH
28900: CALL 31773 0 1
28904: PPUSH
28905: LD_INT 9
28907: PPUSH
28908: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28912: LD_VAR 0 1
28916: PPUSH
28917: CALL_OW 264
28921: PUSH
28922: LD_INT 14
28924: PUSH
28925: LD_INT 53
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: IN
28932: IFFALSE 28969
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28934: LD_ADDR_EXP 42
28938: PUSH
28939: LD_EXP 42
28943: PPUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 255
28953: PPUSH
28954: LD_INT 2
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: CALL 31130 0 4
28966: ST_TO_ADDR
// exit ;
28967: GO 29380
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28969: LD_VAR 0 1
28973: PPUSH
28974: CALL_OW 265
28978: PUSH
28979: LD_EXP 66
28983: PUSH
28984: LD_VAR 0 4
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IN
28994: PUSH
28995: LD_VAR 0 1
28999: PPUSH
29000: CALL_OW 262
29004: PUSH
29005: LD_EXP 66
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: IN
29020: AND
29021: PUSH
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 263
29031: PUSH
29032: LD_EXP 66
29036: PUSH
29037: LD_VAR 0 4
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: IN
29047: AND
29048: PUSH
29049: LD_VAR 0 1
29053: PPUSH
29054: CALL_OW 264
29058: PUSH
29059: LD_EXP 66
29063: PUSH
29064: LD_VAR 0 4
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: IN
29074: AND
29075: IFFALSE 29119
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29077: LD_ADDR_EXP 67
29081: PUSH
29082: LD_EXP 67
29086: PPUSH
29087: LD_VAR 0 4
29091: PPUSH
29092: LD_EXP 67
29096: PUSH
29097: LD_VAR 0 4
29101: ARRAY
29102: PUSH
29103: LD_INT 1
29105: PLUS
29106: PPUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL 31130 0 4
29116: ST_TO_ADDR
// exit ;
29117: GO 29380
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29119: LD_VAR 0 6
29123: PUSH
29124: LD_EXP 69
29128: PUSH
29129: LD_VAR 0 4
29133: ARRAY
29134: PUSH
29135: LD_INT 1
29137: ARRAY
29138: EQUAL
29139: PUSH
29140: LD_VAR 0 7
29144: PUSH
29145: LD_EXP 69
29149: PUSH
29150: LD_VAR 0 4
29154: ARRAY
29155: PUSH
29156: LD_INT 2
29158: ARRAY
29159: EQUAL
29160: AND
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_EXP 69
29171: PUSH
29172: LD_VAR 0 4
29176: ARRAY
29177: PUSH
29178: LD_INT 3
29180: ARRAY
29181: EQUAL
29182: AND
29183: PUSH
29184: LD_VAR 0 9
29188: PUSH
29189: LD_EXP 69
29193: PUSH
29194: LD_VAR 0 4
29198: ARRAY
29199: PUSH
29200: LD_INT 4
29202: ARRAY
29203: EQUAL
29204: AND
29205: IFFALSE 29361
// begin tmp := MREG_ToAttack [ side ] ;
29207: LD_ADDR_VAR 0 5
29211: PUSH
29212: LD_EXP 69
29216: PUSH
29217: LD_VAR 0 4
29221: ARRAY
29222: ST_TO_ADDR
// for i = 1 to 4 do
29223: LD_ADDR_VAR 0 3
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_INT 4
29235: PUSH
29236: FOR_TO
29237: IFFALSE 29259
// tmp := Delete ( tmp , 1 ) ;
29239: LD_ADDR_VAR 0 5
29243: PUSH
29244: LD_VAR 0 5
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 3
29256: ST_TO_ADDR
29257: GO 29236
29259: POP
29260: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29261: LD_ADDR_EXP 69
29265: PUSH
29266: LD_EXP 69
29270: PPUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_VAR 0 5
29280: PPUSH
29281: CALL_OW 1
29285: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29286: LD_ADDR_EXP 71
29290: PUSH
29291: LD_EXP 71
29295: PPUSH
29296: LD_VAR 0 4
29300: PPUSH
29301: LD_EXP 71
29305: PUSH
29306: LD_VAR 0 4
29310: ARRAY
29311: PUSH
29312: LD_INT 1
29314: PLUS
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL 31130 0 4
29325: ST_TO_ADDR
// if tmp = 0 then
29326: LD_VAR 0 5
29330: PUSH
29331: LD_INT 0
29333: EQUAL
29334: IFFALSE 29359
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29336: LD_ADDR_EXP 69
29340: PUSH
29341: LD_EXP 69
29345: PPUSH
29346: LD_VAR 0 4
29350: PPUSH
29351: LD_INT 0
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// exit ;
29359: GO 29380
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29361: LD_VAR 0 1
29365: PPUSH
29366: CALL_OW 255
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL 25741 0 2
// end ; end ;
29380: PPOPN 9
29382: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29383: LD_EXP 39
29387: PUSH
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 255
29397: ARRAY
29398: IFFALSE 29630
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29400: LD_STRING ApemanTamed [side: 
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: STR
29413: PUSH
29414: LD_STRING ; sci: 
29416: STR
29417: PUSH
29418: LD_VAR 0 2
29422: STR
29423: PUSH
29424: LD_STRING ; ape: 
29426: STR
29427: PUSH
29428: LD_VAR 0 1
29432: STR
29433: PUSH
29434: LD_STRING ]
29436: STR
29437: PPUSH
29438: CALL 8039 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29442: LD_INT 11
29444: PPUSH
29445: LD_VAR 0 2
29449: PPUSH
29450: CALL_OW 255
29454: PPUSH
29455: CALL_OW 321
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: NOT
29464: PUSH
29465: LD_INT 2
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: CALL_OW 255
29477: PPUSH
29478: CALL_OW 321
29482: PUSH
29483: LD_INT 2
29485: EQUAL
29486: NOT
29487: OR
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: CALL_OW 255
29498: PPUSH
29499: LD_INT 171
29501: PPUSH
29502: EMPTY
29503: PPUSH
29504: CALL 12354 0 3
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: AND
29513: IFFALSE 29527
// begin SetTag ( ape , 171 ) ;
29515: LD_VAR 0 1
29519: PPUSH
29520: LD_INT 171
29522: PPUSH
29523: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29527: LD_VAR 0 2
29531: PPUSH
29532: CALL_OW 255
29536: PPUSH
29537: LD_INT 30
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL 11651 0 2
29551: IFFALSE 29630
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29553: LD_VAR 0 1
29557: PPUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: CALL_OW 255
29567: PPUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL 11651 0 2
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: CALL_OW 250
29591: PPUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 255
29601: PPUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL 11651 0 2
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: CALL_OW 251
29625: PPUSH
29626: CALL_OW 111
// end ;
29630: PPOPN 2
29632: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29633: LD_EXP 39
29637: PUSH
29638: LD_VAR 0 1
29642: PPUSH
29643: CALL_OW 255
29647: ARRAY
29648: IFFALSE 29926
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29650: LD_VAR 0 2
29654: PUSH
29655: LD_VAR 0 2
29659: PPUSH
29660: CALL_OW 255
29664: PPUSH
29665: CALL 12064 0 1
29669: IN
29670: IFFALSE 29811
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29672: LD_VAR 0 1
29676: PPUSH
29677: CALL_OW 266
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: IFFALSE 29722
// begin Wait ( 0 0$0.3 ) ;
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 16
29708: PPUSH
29709: CALL_OW 336
// ComExitBuilding ( un ) ;
29713: LD_VAR 0 2
29717: PPUSH
29718: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 266
29731: PUSH
29732: LD_INT 4
29734: PUSH
29735: LD_INT 5
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: IN
29742: IFFALSE 29811
// begin Wait ( 0 0$0.3 ) ;
29744: LD_INT 10
29746: PPUSH
29747: CALL_OW 67
// if GetTag ( un ) = 0 then
29751: LD_VAR 0 2
29755: PPUSH
29756: CALL_OW 110
29760: PUSH
29761: LD_INT 0
29763: EQUAL
29764: IFFALSE 29780
// SetClass ( un , class_apeman_soldier ) else
29766: LD_VAR 0 2
29770: PPUSH
29771: LD_INT 15
29773: PPUSH
29774: CALL_OW 336
29778: GO 29811
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29780: LD_INT 3
29782: PPUSH
29783: LD_VAR 0 2
29787: PPUSH
29788: CALL_OW 255
29792: PPUSH
29793: CALL_OW 321
29797: IFFALSE 29811
// SetClass ( un , class_apeman_kamikaze ) ;
29799: LD_VAR 0 2
29803: PPUSH
29804: LD_INT 17
29806: PPUSH
29807: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 266
29820: PUSH
29821: LD_INT 32
29823: EQUAL
29824: IFFALSE 29926
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29826: LD_ADDR_EXP 68
29830: PUSH
29831: LD_EXP 68
29835: PPUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: CALL_OW 255
29845: PPUSH
29846: LD_EXP 68
29850: PUSH
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL_OW 255
29860: ARRAY
29861: PUSH
29862: LD_INT 1
29864: PLUS
29865: PPUSH
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL 31130 0 4
29875: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29876: LD_ADDR_EXP 68
29880: PUSH
29881: LD_EXP 68
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 255
29895: PPUSH
29896: LD_EXP 68
29900: PUSH
29901: LD_VAR 0 1
29905: PPUSH
29906: CALL_OW 255
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: PLUS
29915: PPUSH
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL 31130 0 4
29925: ST_TO_ADDR
// end ; end ;
29926: PPOPN 2
29928: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL 59058 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29938: LD_VAR 0 1
29942: PUSH
29943: LD_INT 22
29945: PUSH
29946: LD_INT 3
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 23
29955: PUSH
29956: LD_INT 3
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 21
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: PPUSH
29978: CALL_OW 69
29982: IN
29983: IFFALSE 29999
// player_loss := player_loss + 1 ;
29985: LD_ADDR_EXP 10
29989: PUSH
29990: LD_EXP 10
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 22
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 21
30016: PUSH
30017: LD_INT 3
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 69
30032: IN
30033: PUSH
30034: LD_EXP 14
30038: NOT
30039: AND
30040: IFFALSE 30103
// begin alfa_north_triggered := true ;
30042: LD_ADDR_EXP 14
30046: PUSH
30047: LD_INT 1
30049: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30050: LD_EXP 5
30054: PPUSH
30055: LD_STRING DS4
30057: PPUSH
30058: CALL_OW 94
// Wait ( 1 1$25 ) ;
30062: LD_INT 2975
30064: PPUSH
30065: CALL_OW 67
// if not isTest then
30069: LD_EXP 1
30073: NOT
30074: IFFALSE 30103
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30076: LD_INT 20
30078: PPUSH
30079: LD_INT 5
30081: PUSH
30082: LD_INT 6
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PUSH
30093: LD_OWVAR 67
30097: ARRAY
30098: PPUSH
30099: CALL 7058 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30103: LD_VAR 0 1
30107: PUSH
30108: LD_INT 22
30110: PUSH
30111: LD_INT 4
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 21
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PPUSH
30132: CALL_OW 69
30136: IN
30137: PUSH
30138: LD_EXP 15
30142: NOT
30143: AND
30144: IFFALSE 30207
// begin alfa_south_triggered := true ;
30146: LD_ADDR_EXP 15
30150: PUSH
30151: LD_INT 1
30153: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30154: LD_EXP 4
30158: PPUSH
30159: LD_STRING DJ3
30161: PPUSH
30162: CALL_OW 94
// Wait ( 0 0$45 ) ;
30166: LD_INT 1575
30168: PPUSH
30169: CALL_OW 67
// if not isTest then
30173: LD_EXP 1
30177: NOT
30178: IFFALSE 30207
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30180: LD_INT 20
30182: PPUSH
30183: LD_INT 5
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: LD_INT 7
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: LIST
30196: PUSH
30197: LD_OWVAR 67
30201: ARRAY
30202: PPUSH
30203: CALL 7058 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 266
30216: PUSH
30217: LD_INT 1
30219: EQUAL
30220: PUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 255
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 4
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: IN
30241: AND
30242: IFFALSE 30251
// RaiseSailEvent ( 104 ) ;
30244: LD_INT 104
30246: PPUSH
30247: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30251: LD_EXP 39
30255: PUSH
30256: LD_VAR 0 1
30260: PPUSH
30261: CALL_OW 255
30265: ARRAY
30266: IFFALSE 30653
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30268: LD_STRING UnitDestroyed [side 
30270: PUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL_OW 255
30280: STR
30281: PUSH
30282: LD_STRING ; id: 
30284: STR
30285: PUSH
30286: LD_VAR 0 1
30290: STR
30291: PUSH
30292: LD_STRING ; type: 
30294: STR
30295: PUSH
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 247
30305: STR
30306: PUSH
30307: LD_STRING ]
30309: STR
30310: PPUSH
30311: CALL 8039 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: CALL_OW 255
30329: PPUSH
30330: LD_INT 21
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL 11651 0 2
30344: IN
30345: IFFALSE 30501
// begin if MCF_HasClass ( un ) then
30347: LD_VAR 0 1
30351: PPUSH
30352: CALL 14357 0 1
30356: IFFALSE 30501
// case MCF_HasClass ( un ) of 1 :
30358: LD_VAR 0 1
30362: PPUSH
30363: CALL 14357 0 1
30367: PUSH
30368: LD_INT 1
30370: DOUBLE
30371: EQUAL
30372: IFTRUE 30376
30374: GO 30401
30376: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 255
30386: PPUSH
30387: LD_STRING ToArm
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL 14530 0 3
30399: GO 30501
30401: LD_INT 2
30403: DOUBLE
30404: EQUAL
30405: IFTRUE 30409
30407: GO 30434
30409: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30410: LD_VAR 0 1
30414: PPUSH
30415: CALL_OW 255
30419: PPUSH
30420: LD_STRING ToDep
30422: PPUSH
30423: LD_VAR 0 1
30427: PPUSH
30428: CALL 14530 0 3
30432: GO 30501
30434: LD_INT 3
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30467
30442: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30443: LD_VAR 0 1
30447: PPUSH
30448: CALL_OW 255
30452: PPUSH
30453: LD_STRING ToFac
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: CALL 14530 0 3
30465: GO 30501
30467: LD_INT 4
30469: DOUBLE
30470: EQUAL
30471: IFTRUE 30475
30473: GO 30500
30475: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30476: LD_VAR 0 1
30480: PPUSH
30481: CALL_OW 255
30485: PPUSH
30486: LD_STRING ToLab
30488: PPUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL 14530 0 3
30498: GO 30501
30500: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30501: LD_VAR 0 1
30505: PUSH
30506: LD_EXP 67
30510: PUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 255
30520: ARRAY
30521: IN
30522: IFFALSE 30607
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30524: LD_ADDR_EXP 67
30528: PUSH
30529: LD_EXP 67
30533: PPUSH
30534: LD_VAR 0 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 31289 0 3
30546: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 255
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: CALL_OW 265
30566: PUSH
30567: LD_VAR 0 1
30571: PPUSH
30572: CALL_OW 262
30576: PUSH
30577: LD_VAR 0 1
30581: PPUSH
30582: CALL_OW 263
30586: PUSH
30587: LD_VAR 0 1
30591: PPUSH
30592: CALL_OW 264
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PPUSH
30603: CALL 21170 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30607: LD_VAR 0 1
30611: PUSH
30612: LD_EXP 71
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 255
30626: ARRAY
30627: IN
30628: IFFALSE 30653
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30630: LD_ADDR_EXP 71
30634: PUSH
30635: LD_EXP 71
30639: PPUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: LD_INT 0
30647: PPUSH
30648: CALL 31289 0 3
30652: ST_TO_ADDR
// end ; end ;
30653: PPOPN 1
30655: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30656: LD_EXP 39
30660: PUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL_OW 255
30670: ARRAY
30671: IFFALSE 30843
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30673: LD_VAR 0 2
30677: PUSH
30678: LD_EXP 68
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 255
30692: ARRAY
30693: IN
30694: PUSH
30695: LD_VAR 0 1
30699: PPUSH
30700: CALL_OW 266
30704: PUSH
30705: LD_INT 32
30707: PUSH
30708: LD_INT 31
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: IN
30715: AND
30716: IFFALSE 30816
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30718: LD_ADDR_EXP 68
30722: PUSH
30723: LD_EXP 68
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: LD_INT 0
30735: PPUSH
30736: CALL 31289 0 3
30740: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30741: LD_ADDR_EXP 68
30745: PUSH
30746: LD_EXP 68
30750: PPUSH
30751: LD_VAR 0 2
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL 31289 0 3
30763: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30764: LD_EXP 68
30768: PUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: CALL_OW 255
30778: ARRAY
30779: PUSH
30780: LD_STRING 
30782: EQUAL
30783: IFFALSE 30816
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30785: LD_ADDR_EXP 68
30789: PUSH
30790: LD_EXP 68
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: CALL_OW 255
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL 31130 0 4
30815: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30816: LD_VAR 0 1
30820: PPUSH
30821: CALL_OW 266
30825: PUSH
30826: LD_INT 36
30828: IN
30829: IFFALSE 30843
// SetTag ( un , 0 ) ;
30831: LD_VAR 0 2
30835: PPUSH
30836: LD_INT 0
30838: PPUSH
30839: CALL_OW 109
// end ;
30843: PPOPN 2
30845: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30846: LD_EXP 39
30850: PUSH
30851: LD_VAR 0 1
30855: PPUSH
30856: CALL_OW 255
30860: ARRAY
30861: IFFALSE 30887
// begin if GetControl ( un ) = control_remote then
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 263
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: IFFALSE 30887
// ComUnlink ( un ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 136
// end ;
30887: PPOPN 1
30889: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30890: LD_EXP 39
30894: PUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 255
30904: ARRAY
30905: IFFALSE 30934
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30907: LD_VAR 0 2
30911: PPUSH
30912: CALL_OW 264
30916: PUSH
30917: LD_INT 31
30919: IN
30920: IFFALSE 30934
// SetTag ( driver , 0 ) ;
30922: LD_VAR 0 1
30926: PPUSH
30927: LD_INT 0
30929: PPUSH
30930: CALL_OW 109
// end ;
30934: PPOPN 4
30936: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 269
30956: ST_TO_ADDR
// x := GetX ( building ) ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_VAR 0 1
30966: PPUSH
30967: CALL_OW 250
30971: ST_TO_ADDR
// y := GetY ( building ) ;
30972: LD_ADDR_VAR 0 5
30976: PUSH
30977: LD_VAR 0 1
30981: PPUSH
30982: CALL_OW 251
30986: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30987: LD_ADDR_EXP 43
30991: PUSH
30992: LD_EXP 43
30996: PPUSH
30997: LD_VAR 0 1
31001: PPUSH
31002: CALL_OW 255
31006: PPUSH
31007: LD_VAR 0 3
31011: PPUSH
31012: LD_VAR 0 4
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PPUSH
31026: CALL 42051 0 4
31030: ST_TO_ADDR
// end ;
31031: PPOPN 5
31033: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 30
31043: IN
31044: NOT
31045: IFFALSE 31093
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31047: LD_ADDR_EXP 30
31051: PUSH
31052: LD_EXP 30
31056: PPUSH
31057: LD_EXP 30
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 1
31070: PPUSH
31071: CALL_OW 2
31075: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31076: LD_STRING DestinationUnrechable. [unit: 
31078: PUSH
31079: LD_VAR 0 1
31083: STR
31084: PUSH
31085: LD_STRING ]
31087: STR
31088: PPUSH
31089: CALL 8039 0 1
// end ; end ;
31093: PPOPN 1
31095: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL 59154 0 3
// end ;
31115: PPOPN 3
31117: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL 59162 0 1
// end ; end_of_file
31127: PPOPN 1
31129: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
31134: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31135: LD_ADDR_VAR 0 7
31139: PUSH
31140: LD_VAR 0 1
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PPUSH
31151: LD_VAR 0 3
31155: PPUSH
31156: LD_VAR 0 4
31160: PPUSH
31161: CALL_OW 1
31165: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31166: LD_ADDR_VAR 0 1
31170: PUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: LD_VAR 0 2
31180: PPUSH
31181: LD_VAR 0 7
31185: PPUSH
31186: CALL_OW 1
31190: ST_TO_ADDR
// result := tab ;
31191: LD_ADDR_VAR 0 5
31195: PUSH
31196: LD_VAR 0 1
31200: ST_TO_ADDR
// end ;
31201: LD_VAR 0 5
31205: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31206: LD_INT 0
31208: PPUSH
31209: PPUSH
31210: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31211: LD_ADDR_VAR 0 5
31215: PUSH
31216: LD_VAR 0 1
31220: PUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: ARRAY
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_INT 2
31238: ARRAY
31239: PPUSH
31240: CALL_OW 3
31244: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31245: LD_ADDR_VAR 0 1
31249: PUSH
31250: LD_VAR 0 1
31254: PPUSH
31255: LD_VAR 0 2
31259: PUSH
31260: LD_INT 1
31262: ARRAY
31263: PPUSH
31264: LD_VAR 0 5
31268: PPUSH
31269: CALL_OW 1
31273: ST_TO_ADDR
// result := tab ;
31274: LD_ADDR_VAR 0 3
31278: PUSH
31279: LD_VAR 0 1
31283: ST_TO_ADDR
// end ;
31284: LD_VAR 0 3
31288: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31289: LD_INT 0
31291: PPUSH
31292: PPUSH
31293: PPUSH
31294: PPUSH
// i := 1 ;
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// while ( i <= tab ) do
31303: LD_VAR 0 5
31307: PUSH
31308: LD_VAR 0 1
31312: LESSEQUAL
31313: IFFALSE 31688
// begin if not tab [ i ] then
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: NOT
31326: IFFALSE 31330
// break ;
31328: GO 31688
// if value in tab then
31330: LD_VAR 0 2
31334: PUSH
31335: LD_VAR 0 1
31339: IN
31340: IFFALSE 31453
// begin if not mode then
31342: LD_VAR 0 3
31346: NOT
31347: IFFALSE 31367
// tab := tab diff value else
31349: LD_ADDR_VAR 0 1
31353: PUSH
31354: LD_VAR 0 1
31358: PUSH
31359: LD_VAR 0 2
31363: DIFF
31364: ST_TO_ADDR
31365: GO 31429
// for j = 1 to tab do
31367: LD_ADDR_VAR 0 6
31371: PUSH
31372: DOUBLE
31373: LD_INT 1
31375: DEC
31376: ST_TO_ADDR
31377: LD_VAR 0 1
31381: PUSH
31382: FOR_TO
31383: IFFALSE 31427
// if tab [ j ] = value then
31385: LD_VAR 0 1
31389: PUSH
31390: LD_VAR 0 6
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 2
31400: EQUAL
31401: IFFALSE 31425
// begin tab := Delete ( tab , j ) ;
31403: LD_ADDR_VAR 0 1
31407: PUSH
31408: LD_VAR 0 1
31412: PPUSH
31413: LD_VAR 0 6
31417: PPUSH
31418: CALL_OW 3
31422: ST_TO_ADDR
// break ;
31423: GO 31427
// end ;
31425: GO 31382
31427: POP
31428: POP
// i := i - 1 ;
31429: LD_ADDR_VAR 0 5
31433: PUSH
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 1
31441: MINUS
31442: ST_TO_ADDR
// if mode then
31443: LD_VAR 0 3
31447: IFFALSE 31451
// break ;
31449: GO 31688
// end else
31451: GO 31672
// if tab [ i ] and value in tab [ i ] then
31453: LD_VAR 0 1
31457: PUSH
31458: LD_VAR 0 5
31462: ARRAY
31463: PUSH
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: IN
31480: AND
31481: IFFALSE 31672
// begin if not mode then
31483: LD_VAR 0 3
31487: NOT
31488: IFFALSE 31514
// tmp := tab [ i ] diff value else
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: LD_VAR 0 1
31499: PUSH
31500: LD_VAR 0 5
31504: ARRAY
31505: PUSH
31506: LD_VAR 0 2
31510: DIFF
31511: ST_TO_ADDR
31512: GO 31594
// for j = 1 to tab [ i ] do
31514: LD_ADDR_VAR 0 6
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 1
31528: PUSH
31529: LD_VAR 0 5
31533: ARRAY
31534: PUSH
31535: FOR_TO
31536: IFFALSE 31592
// if value = tab [ i ] [ j ] then
31538: LD_VAR 0 2
31542: PUSH
31543: LD_VAR 0 1
31547: PUSH
31548: LD_VAR 0 5
31552: ARRAY
31553: PUSH
31554: LD_VAR 0 6
31558: ARRAY
31559: EQUAL
31560: IFFALSE 31590
// begin tmp := Delete ( tab [ i ] , j ) ;
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: LD_VAR 0 1
31571: PUSH
31572: LD_VAR 0 5
31576: ARRAY
31577: PPUSH
31578: LD_VAR 0 6
31582: PPUSH
31583: CALL_OW 3
31587: ST_TO_ADDR
// break ;
31588: GO 31592
// end ;
31590: GO 31535
31592: POP
31593: POP
// if tmp = [ ] then
31594: LD_VAR 0 7
31598: PUSH
31599: EMPTY
31600: EQUAL
31601: IFFALSE 31625
// begin tab := Delete ( tab , i ) ;
31603: LD_ADDR_VAR 0 1
31607: PUSH
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: CALL_OW 3
31622: ST_TO_ADDR
// end else
31623: GO 31650
// tab := Replace ( tab , i , tmp ) ;
31625: LD_ADDR_VAR 0 1
31629: PUSH
31630: LD_VAR 0 1
31634: PPUSH
31635: LD_VAR 0 5
31639: PPUSH
31640: LD_VAR 0 7
31644: PPUSH
31645: CALL_OW 1
31649: ST_TO_ADDR
// i := i - 1 ;
31650: LD_ADDR_VAR 0 5
31654: PUSH
31655: LD_VAR 0 5
31659: PUSH
31660: LD_INT 1
31662: MINUS
31663: ST_TO_ADDR
// if mode then
31664: LD_VAR 0 3
31668: IFFALSE 31672
// break ;
31670: GO 31688
// end ; i := i + 1 ;
31672: LD_ADDR_VAR 0 5
31676: PUSH
31677: LD_VAR 0 5
31681: PUSH
31682: LD_INT 1
31684: PLUS
31685: ST_TO_ADDR
// end ;
31686: GO 31303
// result := tab ;
31688: LD_ADDR_VAR 0 4
31692: PUSH
31693: LD_VAR 0 1
31697: ST_TO_ADDR
// end ;
31698: LD_VAR 0 4
31702: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31703: LD_INT 0
31705: PPUSH
31706: PPUSH
// for i = 1 to values do
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: DOUBLE
31713: LD_INT 1
31715: DEC
31716: ST_TO_ADDR
31717: LD_VAR 0 2
31721: PUSH
31722: FOR_TO
31723: IFFALSE 31756
// tab := Remove ( tab , values [ i ] , false ) ;
31725: LD_ADDR_VAR 0 1
31729: PUSH
31730: LD_VAR 0 1
31734: PPUSH
31735: LD_VAR 0 2
31739: PUSH
31740: LD_VAR 0 4
31744: ARRAY
31745: PPUSH
31746: LD_INT 0
31748: PPUSH
31749: CALL 31289 0 3
31753: ST_TO_ADDR
31754: GO 31722
31756: POP
31757: POP
// result := tab ;
31758: LD_ADDR_VAR 0 3
31762: PUSH
31763: LD_VAR 0 1
31767: ST_TO_ADDR
// end ;
31768: LD_VAR 0 3
31772: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31773: LD_INT 0
31775: PPUSH
31776: PPUSH
31777: PPUSH
// if not GetControl ( veh ) = control_manual then
31778: LD_VAR 0 1
31782: PPUSH
31783: CALL_OW 263
31787: PUSH
31788: LD_INT 1
31790: EQUAL
31791: NOT
31792: IFFALSE 31804
// result := false else
31794: LD_ADDR_VAR 0 2
31798: PUSH
31799: LD_INT 0
31801: ST_TO_ADDR
31802: GO 31949
// if veh in FilterAllUnits ( [ f_empty ] ) then
31804: LD_VAR 0 1
31808: PUSH
31809: LD_INT 58
31811: PUSH
31812: EMPTY
31813: LIST
31814: PPUSH
31815: CALL_OW 69
31819: IN
31820: IFFALSE 31832
// result := false else
31822: LD_ADDR_VAR 0 2
31826: PUSH
31827: LD_INT 0
31829: ST_TO_ADDR
31830: GO 31949
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31832: LD_ADDR_VAR 0 4
31836: PUSH
31837: LD_INT 22
31839: PUSH
31840: LD_VAR 0 1
31844: PPUSH
31845: CALL_OW 255
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 55
31856: PUSH
31857: EMPTY
31858: LIST
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 69
31868: ST_TO_ADDR
// if not filter then
31869: LD_VAR 0 4
31873: NOT
31874: IFFALSE 31886
// result := false else
31876: LD_ADDR_VAR 0 2
31880: PUSH
31881: LD_INT 0
31883: ST_TO_ADDR
31884: GO 31949
// for i = 1 to filter do
31886: LD_ADDR_VAR 0 3
31890: PUSH
31891: DOUBLE
31892: LD_INT 1
31894: DEC
31895: ST_TO_ADDR
31896: LD_VAR 0 4
31900: PUSH
31901: FOR_TO
31902: IFFALSE 31947
// if IsDriver ( filter [ i ] ) = veh then
31904: LD_VAR 0 4
31908: PUSH
31909: LD_VAR 0 3
31913: ARRAY
31914: PPUSH
31915: CALL 98431 0 1
31919: PUSH
31920: LD_VAR 0 1
31924: EQUAL
31925: IFFALSE 31945
// begin result := filter [ i ] ;
31927: LD_ADDR_VAR 0 2
31931: PUSH
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 3
31941: ARRAY
31942: ST_TO_ADDR
// break ;
31943: GO 31947
// end ;
31945: GO 31901
31947: POP
31948: POP
// end ; end ;
31949: LD_VAR 0 2
31953: RET
// export function Compare ( val1 , val2 ) ; begin
31954: LD_INT 0
31956: PPUSH
// if val1 = val2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 31979
// result := true else
31969: LD_ADDR_VAR 0 3
31973: PUSH
31974: LD_INT 1
31976: ST_TO_ADDR
31977: GO 31987
// result := false ;
31979: LD_ADDR_VAR 0 3
31983: PUSH
31984: LD_INT 0
31986: ST_TO_ADDR
// end ;
31987: LD_VAR 0 3
31991: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31992: LD_INT 0
31994: PPUSH
31995: PPUSH
// result := false ;
31996: LD_ADDR_VAR 0 3
32000: PUSH
32001: LD_INT 0
32003: ST_TO_ADDR
// for j = 1 to e2 do
32004: LD_ADDR_VAR 0 4
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_VAR 0 2
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32054
// if Compare ( e1 , e2 [ j ] ) then
32022: LD_VAR 0 1
32026: PPUSH
32027: LD_VAR 0 2
32031: PUSH
32032: LD_VAR 0 4
32036: ARRAY
32037: PPUSH
32038: CALL 31954 0 2
32042: IFFALSE 32052
// result := true ;
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_INT 1
32051: ST_TO_ADDR
32052: GO 32019
32054: POP
32055: POP
// end ;
32056: LD_VAR 0 3
32060: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32061: LD_INT 0
32063: PPUSH
32064: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_STRING C
32072: PUSH
32073: LD_VAR 0 2
32077: PUSH
32078: LD_VAR 0 3
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: PUSH
32104: LD_STRING v
32106: PUSH
32107: LD_VAR 0 4
32111: PPUSH
32112: CALL_OW 250
32116: PUSH
32117: LD_VAR 0 4
32121: PPUSH
32122: CALL_OW 251
32126: PUSH
32127: LD_VAR 0 4
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 0
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: CALL_OW 446
// end ;
32158: LD_VAR 0 5
32162: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
// linked := UnitsLinked ( unit ) ;
32168: LD_ADDR_VAR 0 4
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 432
32182: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32183: LD_ADDR_VAR 0 3
32187: PUSH
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_INT 3
32195: PPUSH
32196: CALL_OW 259
32200: ST_TO_ADDR
// if sk > linked then
32201: LD_VAR 0 3
32205: PUSH
32206: LD_VAR 0 4
32210: GREATER
32211: IFFALSE 32223
// result := true else
32213: LD_ADDR_VAR 0 2
32217: PUSH
32218: LD_INT 1
32220: ST_TO_ADDR
32221: GO 32231
// result := false ;
32223: LD_ADDR_VAR 0 2
32227: PUSH
32228: LD_INT 0
32230: ST_TO_ADDR
// end ;
32231: LD_VAR 0 2
32235: RET
// export function NotTask ( unit ) ; begin
32236: LD_INT 0
32238: PPUSH
// result := true ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32247: LD_VAR 0 1
32251: PPUSH
32252: CALL_OW 437
32256: PUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: CALL_OW 314
32266: OR
32267: IFFALSE 32277
// result := false ;
32269: LD_ADDR_VAR 0 2
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// end ;
32277: LD_VAR 0 2
32281: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32282: LD_INT 0
32284: PPUSH
32285: PPUSH
32286: PPUSH
32287: PPUSH
32288: PPUSH
// dist := 99999 ;
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_INT 99999
32296: ST_TO_ADDR
// un := - 1 ;
32297: LD_ADDR_VAR 0 6
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: ST_TO_ADDR
// if units1 and units2 then
32306: LD_VAR 0 1
32310: PUSH
32311: LD_VAR 0 2
32315: AND
32316: IFFALSE 32404
// for i in units1 do
32318: LD_ADDR_VAR 0 4
32322: PUSH
32323: LD_VAR 0 1
32327: PUSH
32328: FOR_IN
32329: IFFALSE 32402
// for j in units2 do
32331: LD_ADDR_VAR 0 5
32335: PUSH
32336: LD_VAR 0 2
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32398
// if GetDistUnits ( i , j ) < dist then
32344: LD_VAR 0 4
32348: PPUSH
32349: LD_VAR 0 5
32353: PPUSH
32354: CALL_OW 296
32358: PUSH
32359: LD_VAR 0 7
32363: LESS
32364: IFFALSE 32396
// begin un := i ;
32366: LD_ADDR_VAR 0 6
32370: PUSH
32371: LD_VAR 0 4
32375: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32376: LD_ADDR_VAR 0 7
32380: PUSH
32381: LD_VAR 0 4
32385: PPUSH
32386: LD_VAR 0 5
32390: PPUSH
32391: CALL_OW 296
32395: ST_TO_ADDR
// end ;
32396: GO 32341
32398: POP
32399: POP
32400: GO 32328
32402: POP
32403: POP
// result := [ un , dist ] ;
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_VAR 0 6
32413: PUSH
32414: LD_VAR 0 7
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: ST_TO_ADDR
// end ;
32423: LD_VAR 0 3
32427: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32428: LD_INT 0
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32435: LD_VAR 0 1
32439: NOT
32440: PUSH
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 256
32450: PUSH
32451: LD_INT 250
32453: LESS
32454: OR
32455: PUSH
32456: LD_VAR 0 1
32460: PPUSH
32461: CALL_OW 314
32465: PUSH
32466: LD_VAR 0 1
32470: PPUSH
32471: CALL_OW 261
32475: PUSH
32476: LD_INT 20
32478: GREATER
32479: AND
32480: OR
32481: IFFALSE 32485
// exit ;
32483: GO 32859
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 261
32494: PUSH
32495: LD_INT 20
32497: LESS
32498: PUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 21
32511: EQUAL
32512: NOT
32513: AND
32514: IFFALSE 32550
// begin ComStop ( bulldozer ) ;
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32525: LD_VAR 0 1
32529: PPUSH
32530: LD_INT 21
32532: PPUSH
32533: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32537: LD_VAR 0 1
32541: PPUSH
32542: CALL 26278 0 1
// exit ;
32546: GO 32859
// end else
32548: GO 32577
// if GetFuel ( bulldozer ) > 20 then
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: IFFALSE 32577
// SetTag ( bulldozer , 0 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 0
32572: PPUSH
32573: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_VAR 0 2
32586: PPUSH
32587: CALL_OW 353
32591: ST_TO_ADDR
// tmp := [ ] ;
32592: LD_ADDR_VAR 0 6
32596: PUSH
32597: EMPTY
32598: ST_TO_ADDR
// for i = 1 to list do
32599: LD_ADDR_VAR 0 4
32603: PUSH
32604: DOUBLE
32605: LD_INT 1
32607: DEC
32608: ST_TO_ADDR
32609: LD_VAR 0 5
32613: PUSH
32614: FOR_TO
32615: IFFALSE 32713
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32617: LD_VAR 0 5
32621: PUSH
32622: LD_VAR 0 4
32626: ARRAY
32627: PUSH
32628: LD_INT 1
32630: ARRAY
32631: PPUSH
32632: LD_VAR 0 5
32636: PUSH
32637: LD_VAR 0 4
32641: ARRAY
32642: PUSH
32643: LD_INT 2
32645: ARRAY
32646: PPUSH
32647: CALL_OW 554
32651: IFFALSE 32711
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32653: LD_ADDR_VAR 0 6
32657: PUSH
32658: LD_VAR 0 6
32662: PPUSH
32663: LD_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PPUSH
32672: LD_VAR 0 5
32676: PUSH
32677: LD_VAR 0 4
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 5
32691: PUSH
32692: LD_VAR 0 4
32696: ARRAY
32697: PUSH
32698: LD_INT 2
32700: ARRAY
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 1
32710: ST_TO_ADDR
// end ;
32711: GO 32614
32713: POP
32714: POP
// ComStop ( bulldozer ) ;
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32724: LD_ADDR_VAR 0 7
32728: PUSH
32729: LD_VAR 0 1
32733: PPUSH
32734: CALL_OW 250
32738: PUSH
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 251
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: ST_TO_ADDR
// for i = tmp downto 1 do
32753: LD_ADDR_VAR 0 4
32757: PUSH
32758: DOUBLE
32759: LD_VAR 0 6
32763: INC
32764: ST_TO_ADDR
32765: LD_INT 1
32767: PUSH
32768: FOR_DOWNTO
32769: IFFALSE 32857
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32771: LD_ADDR_VAR 0 7
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 2
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 6
32798: PPUSH
32799: CALL 32960 0 3
32803: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32804: LD_VAR 0 1
32808: PPUSH
32809: LD_VAR 0 7
32813: PUSH
32814: LD_INT 1
32816: ARRAY
32817: PPUSH
32818: LD_VAR 0 7
32822: PUSH
32823: LD_INT 2
32825: ARRAY
32826: PPUSH
32827: CALL 32864 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32831: LD_ADDR_VAR 0 6
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_VAR 0 7
32845: PUSH
32846: LD_INT 3
32848: ARRAY
32849: PPUSH
32850: CALL_OW 3
32854: ST_TO_ADDR
// end ;
32855: GO 32768
32857: POP
32858: POP
// end ;
32859: LD_VAR 0 3
32863: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32864: LD_INT 0
32866: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32867: LD_VAR 0 2
32871: PPUSH
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 351
32881: PUSH
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 554
32896: AND
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 488
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 428
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: EQUAL
32933: AND
32934: IFFALSE 32955
// AddComMoveXY ( bulldozer , x , y ) ;
32936: LD_VAR 0 1
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 171
// end ;
32955: LD_VAR 0 4
32959: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32960: LD_INT 0
32962: PPUSH
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
// dist := 99999 ;
32969: LD_ADDR_VAR 0 6
32973: PUSH
32974: LD_INT 99999
32976: ST_TO_ADDR
// for i = 1 to list do
32977: LD_ADDR_VAR 0 5
32981: PUSH
32982: DOUBLE
32983: LD_INT 1
32985: DEC
32986: ST_TO_ADDR
32987: LD_VAR 0 3
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33131
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32995: LD_ADDR_VAR 0 7
32999: PUSH
33000: LD_VAR 0 1
33004: PPUSH
33005: LD_VAR 0 2
33009: PPUSH
33010: LD_VAR 0 3
33014: PUSH
33015: LD_VAR 0 5
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PPUSH
33025: LD_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: ARRAY
33035: PUSH
33036: LD_INT 2
33038: ARRAY
33039: PPUSH
33040: CALL_OW 298
33044: ST_TO_ADDR
// if d = 0 then
33045: LD_VAR 0 7
33049: PUSH
33050: LD_INT 0
33052: EQUAL
33053: IFFALSE 33057
// continue ;
33055: GO 32992
// if d < dist then
33057: LD_VAR 0 7
33061: PUSH
33062: LD_VAR 0 6
33066: LESS
33067: IFFALSE 33129
// begin _x := list [ i ] [ 1 ] ;
33069: LD_ADDR_VAR 0 8
33073: PUSH
33074: LD_VAR 0 3
33078: PUSH
33079: LD_VAR 0 5
33083: ARRAY
33084: PUSH
33085: LD_INT 1
33087: ARRAY
33088: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33089: LD_ADDR_VAR 0 9
33093: PUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 2
33107: ARRAY
33108: ST_TO_ADDR
// _i := i ;
33109: LD_ADDR_VAR 0 10
33113: PUSH
33114: LD_VAR 0 5
33118: ST_TO_ADDR
// dist := d ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_VAR 0 7
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32992
33131: POP
33132: POP
// result := [ _x , _y , _i , dist ] ;
33133: LD_ADDR_VAR 0 4
33137: PUSH
33138: LD_VAR 0 8
33142: PUSH
33143: LD_VAR 0 9
33147: PUSH
33148: LD_VAR 0 10
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: ST_TO_ADDR
// end ;
33164: LD_VAR 0 4
33168: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
// for i = 1 to list do
33176: LD_ADDR_VAR 0 5
33180: PUSH
33181: DOUBLE
33182: LD_INT 1
33184: DEC
33185: ST_TO_ADDR
33186: LD_VAR 0 1
33190: PUSH
33191: FOR_TO
33192: IFFALSE 33506
// begin for j = list downto 2 do
33194: LD_ADDR_VAR 0 6
33198: PUSH
33199: DOUBLE
33200: LD_VAR 0 1
33204: INC
33205: ST_TO_ADDR
33206: LD_INT 2
33208: PUSH
33209: FOR_DOWNTO
33210: IFFALSE 33502
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33212: LD_VAR 0 2
33216: PPUSH
33217: LD_VAR 0 3
33221: PPUSH
33222: LD_VAR 0 1
33226: PUSH
33227: LD_VAR 0 6
33231: ARRAY
33232: PUSH
33233: LD_INT 1
33235: ARRAY
33236: PPUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_VAR 0 6
33246: ARRAY
33247: PUSH
33248: LD_INT 2
33250: ARRAY
33251: PPUSH
33252: CALL_OW 298
33256: PUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_INT 1
33279: MINUS
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PPUSH
33286: LD_VAR 0 1
33290: PUSH
33291: LD_VAR 0 6
33295: PUSH
33296: LD_INT 1
33298: MINUS
33299: ARRAY
33300: PUSH
33301: LD_INT 2
33303: ARRAY
33304: PPUSH
33305: CALL_OW 298
33309: LESS
33310: IFFALSE 33500
// begin _x := list [ j ] [ 1 ] ;
33312: LD_ADDR_VAR 0 7
33316: PUSH
33317: LD_VAR 0 1
33321: PUSH
33322: LD_VAR 0 6
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33332: LD_ADDR_VAR 0 8
33336: PUSH
33337: LD_VAR 0 1
33341: PUSH
33342: LD_VAR 0 6
33346: ARRAY
33347: PUSH
33348: LD_INT 2
33350: ARRAY
33351: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_VAR 0 1
33361: PPUSH
33362: LD_VAR 0 6
33366: PPUSH
33367: LD_INT 1
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: CALL 31130 0 4
33393: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_VAR 0 1
33403: PPUSH
33404: LD_VAR 0 6
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 1
33416: PUSH
33417: LD_VAR 0 6
33421: PUSH
33422: LD_INT 1
33424: MINUS
33425: ARRAY
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: CALL 31130 0 4
33435: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PUSH
33451: LD_INT 1
33453: MINUS
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: LD_VAR 0 7
33462: PPUSH
33463: CALL 31130 0 4
33467: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33468: LD_ADDR_VAR 0 1
33472: PUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 6
33482: PUSH
33483: LD_INT 1
33485: MINUS
33486: PPUSH
33487: LD_INT 2
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: CALL 31130 0 4
33499: ST_TO_ADDR
// end ; end ;
33500: GO 33209
33502: POP
33503: POP
// end ;
33504: GO 33191
33506: POP
33507: POP
// result := list ;
33508: LD_ADDR_VAR 0 4
33512: PUSH
33513: LD_VAR 0 1
33517: ST_TO_ADDR
// end ;
33518: LD_VAR 0 4
33522: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33523: LD_INT 0
33525: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33526: LD_ADDR_VAR 0 5
33530: PUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: LD_VAR 0 2
33540: PPUSH
33541: CALL_OW 546
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PUSH
33550: LD_VAR 0 3
33554: PPUSH
33555: LD_VAR 0 4
33559: PPUSH
33560: CALL_OW 546
33564: PUSH
33565: LD_INT 2
33567: ARRAY
33568: MINUS
33569: ST_TO_ADDR
// if result < 0 then
33570: LD_VAR 0 5
33574: PUSH
33575: LD_INT 0
33577: LESS
33578: IFFALSE 33595
// result := result * - 1 ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_VAR 0 5
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: MUL
33594: ST_TO_ADDR
// end ;
33595: LD_VAR 0 5
33599: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
// area = ListEnvironmentArea ( area ) ;
33604: LD_ADDR_VAR 0 2
33608: PUSH
33609: LD_VAR 0 2
33613: PPUSH
33614: CALL_OW 353
33618: ST_TO_ADDR
// if bulldozer > 0 then
33619: LD_VAR 0 1
33623: PUSH
33624: LD_INT 0
33626: GREATER
33627: IFFALSE 33738
// for i = area downto 1 do
33629: LD_ADDR_VAR 0 4
33633: PUSH
33634: DOUBLE
33635: LD_VAR 0 2
33639: INC
33640: ST_TO_ADDR
33641: LD_INT 1
33643: PUSH
33644: FOR_DOWNTO
33645: IFFALSE 33736
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33647: LD_VAR 0 2
33651: PUSH
33652: LD_VAR 0 4
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_VAR 0 2
33666: PUSH
33667: LD_VAR 0 4
33671: ARRAY
33672: PUSH
33673: LD_INT 2
33675: ARRAY
33676: PPUSH
33677: CALL_OW 351
33681: IFFALSE 33734
// if not HasTask ( bulldozer ) then
33683: LD_VAR 0 1
33687: PPUSH
33688: CALL_OW 314
33692: NOT
33693: IFFALSE 33734
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33695: LD_VAR 0 1
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_VAR 0 4
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PPUSH
33715: LD_VAR 0 2
33719: PUSH
33720: LD_VAR 0 4
33724: ARRAY
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: PPUSH
33730: CALL_OW 171
33734: GO 33644
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 3
33742: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33749: LD_ADDR_VAR 0 6
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_VAR 0 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 21
33768: PUSH
33769: LD_VAR 0 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PPUSH
33782: CALL_OW 69
33786: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33787: LD_ADDR_VAR 0 7
33791: PUSH
33792: LD_VAR 0 3
33796: PPUSH
33797: LD_INT 22
33799: PUSH
33800: LD_VAR 0 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 21
33811: PUSH
33812: LD_VAR 0 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PPUSH
33825: CALL_OW 70
33829: ST_TO_ADDR
// if tmp and pom then
33830: LD_VAR 0 6
33834: PUSH
33835: LD_VAR 0 7
33839: AND
33840: IFFALSE 33860
// result := tmp diff pom else
33842: LD_ADDR_VAR 0 4
33846: PUSH
33847: LD_VAR 0 6
33851: PUSH
33852: LD_VAR 0 7
33856: DIFF
33857: ST_TO_ADDR
33858: GO 33868
// result := false ;
33860: LD_ADDR_VAR 0 4
33864: PUSH
33865: LD_INT 0
33867: ST_TO_ADDR
// end ;
33868: LD_VAR 0 4
33872: RET
// export function SavePosition ( unit ) ; begin
33873: LD_INT 0
33875: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: LD_VAR 0 1
33885: PPUSH
33886: CALL_OW 250
33890: PPUSH
33891: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 251
33909: PPUSH
33910: CALL_OW 232
// end ;
33914: LD_VAR 0 2
33918: RET
// export function GetPosition ( unit ) ; begin
33919: LD_INT 0
33921: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33922: LD_ADDR_VAR 0 2
33926: PUSH
33927: LD_VAR 0 1
33931: PPUSH
33932: CALL_OW 252
33936: PUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL_OW 253
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: ST_TO_ADDR
// end ;
33951: LD_VAR 0 2
33955: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33956: LD_INT 0
33958: PPUSH
// if unit in unreachableList then
33959: LD_VAR 0 1
33963: PUSH
33964: LD_EXP 30
33968: IN
33969: IFFALSE 33987
// unreachableList := unreachableList diff unit ;
33971: LD_ADDR_EXP 30
33975: PUSH
33976: LD_EXP 30
33980: PUSH
33981: LD_VAR 0 1
33985: DIFF
33986: ST_TO_ADDR
// if ValidHex ( x , y ) then
33987: LD_VAR 0 2
33991: PPUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: CALL_OW 488
34001: IFFALSE 34027
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_VAR 0 2
34012: PPUSH
34013: LD_VAR 0 3
34017: PPUSH
34018: CALL_OW 428
34022: PPUSH
34023: CALL_OW 115
// Wait ( 3 ) ;
34027: LD_INT 3
34029: PPUSH
34030: CALL_OW 67
// if unit in unreachableList then
34034: LD_VAR 0 1
34038: PUSH
34039: LD_EXP 30
34043: IN
34044: IFFALSE 34056
// result := false else
34046: LD_ADDR_VAR 0 4
34050: PUSH
34051: LD_INT 0
34053: ST_TO_ADDR
34054: GO 34064
// result := true ;
34056: LD_ADDR_VAR 0 4
34060: PUSH
34061: LD_INT 1
34063: ST_TO_ADDR
// end ; end_of_file
34064: LD_VAR 0 4
34068: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34069: LD_EXP 31
34073: IFFALSE 34135
34075: GO 34077
34077: DISABLE
34078: LD_INT 0
34080: PPUSH
// begin enable ;
34081: ENABLE
// for i = 1 to mc_crates_list do
34082: LD_ADDR_VAR 0 1
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 32
34096: PUSH
34097: FOR_TO
34098: IFFALSE 34129
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34100: LD_EXP 32
34104: PUSH
34105: LD_VAR 0 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 5
34113: PPUSH
34114: LD_INT 50
34116: PPUSH
34117: LD_INT 700
34119: PPUSH
34120: LD_INT 20
34122: PPUSH
34123: CALL 24485 0 5
34127: GO 34097
34129: POP
34130: POP
// MC_Game ( ) ;
34131: CALL 34138 0 0
// end ;
34135: PPOPN 1
34137: END
// export function MC_Game ( ) ; var i , side , un ; begin
34138: LD_INT 0
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not isTest then
34144: LD_EXP 1
34148: NOT
34149: IFFALSE 34169
// MC_Show ( [ #tick , tick ] ) else
34151: LD_STRING #tick
34153: PUSH
34154: LD_OWVAR 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PPUSH
34163: CALL 8569 0 1
34167: GO 34178
// MC_Show ( debug_string ) ;
34169: LD_EXP 2
34173: PPUSH
34174: CALL 8569 0 1
// for side = 1 to 8 do
34178: LD_ADDR_VAR 0 3
34182: PUSH
34183: DOUBLE
34184: LD_INT 1
34186: DEC
34187: ST_TO_ADDR
34188: LD_INT 8
34190: PUSH
34191: FOR_TO
34192: IFFALSE 36192
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34194: LD_EXP 39
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PUSH
34205: LD_INT 0
34207: EQUAL
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: EMPTY
34215: PPUSH
34216: CALL 11786 0 2
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: OR
34225: IFFALSE 34229
// continue ;
34227: GO 34191
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34229: LD_VAR 0 3
34233: PPUSH
34234: LD_VAR 0 3
34238: PPUSH
34239: CALL 25006 0 1
34243: PPUSH
34244: CALL 36199 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34248: LD_EXP 71
34252: PUSH
34253: LD_VAR 0 3
34257: ARRAY
34258: PUSH
34259: LD_INT 1
34261: ARRAY
34262: PUSH
34263: LD_INT 0
34265: GREATER
34266: PUSH
34267: LD_EXP 69
34271: PUSH
34272: LD_VAR 0 3
34276: ARRAY
34277: PUSH
34278: LD_INT 1
34280: ARRAY
34281: PUSH
34282: LD_INT 0
34284: EQUAL
34285: AND
34286: PUSH
34287: LD_VAR 0 3
34291: PPUSH
34292: LD_INT 7
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL 12354 0 3
34301: NOT
34302: AND
34303: IFFALSE 34340
// begin for i in MREG_Attackers [ side ] do
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_EXP 71
34314: PUSH
34315: LD_VAR 0 3
34319: ARRAY
34320: PUSH
34321: FOR_IN
34322: IFFALSE 34338
// SetTag ( i , 7 ) ;
34324: LD_VAR 0 2
34328: PPUSH
34329: LD_INT 7
34331: PPUSH
34332: CALL_OW 109
34336: GO 34321
34338: POP
34339: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34340: LD_VAR 0 3
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: EMPTY
34349: PPUSH
34350: CALL 12354 0 3
34354: IFFALSE 34414
// begin if side = 1 then
34356: LD_VAR 0 3
34360: PUSH
34361: LD_INT 1
34363: EQUAL
34364: IFFALSE 34373
// RaiseSailEvent ( 101 ) ;
34366: LD_INT 101
34368: PPUSH
34369: CALL_OW 427
// if side = 4 then
34373: LD_VAR 0 3
34377: PUSH
34378: LD_INT 4
34380: EQUAL
34381: IFFALSE 34390
// RaiseSailEvent ( 102 ) ;
34383: LD_INT 102
34385: PPUSH
34386: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: LD_INT 7
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL 12354 0 3
34409: PPUSH
34410: CALL 8487 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 18034 0 1
34423: PUSH
34424: LD_VAR 0 3
34428: PPUSH
34429: CALL 11690 0 1
34433: AND
34434: IFFALSE 34445
// MCL_Start ( side ) ;
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 17991 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34445: LD_ADDR_EXP 35
34449: PUSH
34450: LD_EXP 35
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL 19291 0 1
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34475: LD_ADDR_EXP 47
34479: PUSH
34480: LD_EXP 47
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL 11104 0 1
34499: PPUSH
34500: CALL_OW 1
34504: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34505: LD_VAR 0 3
34509: PPUSH
34510: LD_INT 21
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PPUSH
34520: CALL 11651 0 2
34524: IFFALSE 34535
// MCV_CheckStatus ( side ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL 27188 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 53
34544: PPUSH
34545: CALL 42999 0 2
34549: IFFALSE 34634
// begin for i = MREG_ToChangeClass downto 1 do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_EXP 53
34561: INC
34562: ST_TO_ADDR
34563: LD_INT 1
34565: PUSH
34566: FOR_DOWNTO
34567: IFFALSE 34632
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34569: LD_EXP 53
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 1
34582: ARRAY
34583: PUSH
34584: LD_VAR 0 3
34588: EQUAL
34589: IFFALSE 34630
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34591: LD_VAR 0 3
34595: PPUSH
34596: LD_EXP 53
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_INT 2
34609: ARRAY
34610: PPUSH
34611: LD_EXP 53
34615: PUSH
34616: LD_VAR 0 2
34620: ARRAY
34621: PUSH
34622: LD_INT 3
34624: ARRAY
34625: PPUSH
34626: CALL 16558 0 3
// end ; end ;
34630: GO 34566
34632: POP
34633: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34634: LD_INT 1
34636: PUSH
34637: LD_EXP 38
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: IN
34648: IFFALSE 34659
// begin MCN_TrainApe ( side ) ;
34650: LD_VAR 0 3
34654: PPUSH
34655: CALL 18944 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34659: LD_VAR 0 3
34663: PPUSH
34664: LD_INT 30
34666: PUSH
34667: LD_INT 3
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PPUSH
34674: CALL 11651 0 2
34678: IFFALSE 34852
// begin if MCF_Tag ( side , 10 , [ ] ) then
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 10
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL 12354 0 3
34694: IFFALSE 34741
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12354 0 3
34710: PPUSH
34711: LD_VAR 0 3
34715: PPUSH
34716: LD_INT 30
34718: PUSH
34719: LD_INT 3
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PPUSH
34726: CALL 11651 0 2
34730: PUSH
34731: LD_INT 1
34733: ARRAY
34734: PPUSH
34735: CALL_OW 168
// end else
34739: GO 34852
// if MREG_ToConstruct [ side ] then
34741: LD_EXP 51
34745: PUSH
34746: LD_VAR 0 3
34750: ARRAY
34751: IFFALSE 34852
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_VAR 0 3
34762: PPUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 3
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PPUSH
34773: CALL 11651 0 2
34777: PUSH
34778: LD_INT 1
34780: ARRAY
34781: PPUSH
34782: LD_EXP 51
34786: PUSH
34787: LD_VAR 0 3
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_EXP 51
34801: PUSH
34802: LD_VAR 0 3
34806: ARRAY
34807: PUSH
34808: LD_INT 2
34810: ARRAY
34811: PUSH
34812: LD_EXP 51
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 3
34825: ARRAY
34826: PUSH
34827: LD_EXP 51
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 4
34840: ARRAY
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL 25496 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34852: LD_VAR 0 3
34856: PPUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL 11651 0 2
34871: PUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_EXP 43
34881: PPUSH
34882: CALL 42999 0 2
34886: AND
34887: PUSH
34888: LD_INT 22
34890: PUSH
34891: LD_VAR 0 3
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 33
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 32
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 35
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL_OW 69
34947: AND
34948: IFFALSE 34959
// MCV_Turret ( side ) ;
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 25933 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34959: LD_EXP 42
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: GREATER
34973: PUSH
34974: LD_VAR 0 3
34978: PPUSH
34979: CALL 25006 0 1
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: AND
34988: IFFALSE 35150
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34990: LD_EXP 42
34994: PUSH
34995: LD_VAR 0 3
34999: ARRAY
35000: PUSH
35001: LD_INT 1
35003: ARRAY
35004: PPUSH
35005: CALL_OW 353
35009: IFFALSE 35047
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35011: LD_EXP 42
35015: PUSH
35016: LD_VAR 0 3
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: PPUSH
35026: LD_EXP 42
35030: PUSH
35031: LD_VAR 0 3
35035: ARRAY
35036: PUSH
35037: LD_INT 1
35039: ARRAY
35040: PPUSH
35041: CALL 32428 0 2
35045: GO 35150
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PPUSH
35062: CALL 11651 0 2
35066: IFFALSE 35150
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35068: LD_VAR 0 3
35072: PPUSH
35073: LD_INT 30
35075: PUSH
35076: LD_INT 3
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PPUSH
35083: CALL 11651 0 2
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 2
35099: EQUAL
35100: IFFALSE 35150
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35102: LD_EXP 42
35106: PUSH
35107: LD_VAR 0 3
35111: ARRAY
35112: PUSH
35113: LD_INT 2
35115: ARRAY
35116: PPUSH
35117: LD_INT 10
35119: PPUSH
35120: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35124: LD_ADDR_EXP 42
35128: PUSH
35129: LD_EXP 42
35133: PPUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PPUSH
35165: CALL 11651 0 2
35169: IFFALSE 35209
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PPUSH
35191: CALL 11651 0 2
35195: PUSH
35196: LD_INT 1
35198: ARRAY
35199: PPUSH
35200: CALL_OW 248
35204: PPUSH
35205: CALL 26487 0 2
// if MREG_ToRepair [ side ] then
35209: LD_EXP 47
35213: PUSH
35214: LD_VAR 0 3
35218: ARRAY
35219: IFFALSE 35232
// begin MCB_Repair ( side ) ;
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL 11391 0 1
// end else
35230: GO 36145
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35232: LD_VAR 0 3
35236: PPUSH
35237: LD_EXP 49
35241: PPUSH
35242: CALL 42999 0 2
35246: PUSH
35247: LD_VAR 0 3
35251: PPUSH
35252: LD_EXP 40
35256: PPUSH
35257: CALL 42999 0 2
35261: AND
35262: IFFALSE 35470
// begin for i = 1 to MREG_ToUpLab do
35264: LD_ADDR_VAR 0 2
35268: PUSH
35269: DOUBLE
35270: LD_INT 1
35272: DEC
35273: ST_TO_ADDR
35274: LD_EXP 49
35278: PUSH
35279: FOR_TO
35280: IFFALSE 35466
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35282: LD_EXP 49
35286: PUSH
35287: LD_VAR 0 2
35291: ARRAY
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PUSH
35297: LD_VAR 0 3
35301: EQUAL
35302: IFFALSE 35464
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35304: LD_EXP 49
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PUSH
35319: LD_EXP 49
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: PUSH
35330: LD_INT 3
35332: ARRAY
35333: AND
35334: IFFALSE 35462
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: LD_EXP 49
35345: PUSH
35346: LD_VAR 0 2
35350: ARRAY
35351: PUSH
35352: LD_INT 2
35354: ARRAY
35355: PPUSH
35356: LD_EXP 49
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 3
35369: ARRAY
35370: PPUSH
35371: CALL 8915 0 3
35375: IFFALSE 35462
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35377: LD_ADDR_EXP 49
35381: PUSH
35382: LD_EXP 49
35386: PPUSH
35387: LD_VAR 0 3
35391: PPUSH
35392: LD_EXP 49
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: PUSH
35403: LD_INT 2
35405: ARRAY
35406: PPUSH
35407: LD_EXP 49
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 3
35420: ARRAY
35421: PPUSH
35422: CALL 42051 0 4
35426: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35427: LD_ADDR_EXP 40
35431: PUSH
35432: LD_EXP 40
35436: PPUSH
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_EXP 40
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL 42051 0 4
35461: ST_TO_ADDR
// end ; break ;
35462: GO 35466
// end ;
35464: GO 35279
35466: POP
35467: POP
// end else
35468: GO 36145
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: LD_EXP 48
35479: PPUSH
35480: CALL 42999 0 2
35484: IFFALSE 35558
// begin for i = 1 to MREG_ToUpdate do
35486: LD_ADDR_VAR 0 2
35490: PUSH
35491: DOUBLE
35492: LD_INT 1
35494: DEC
35495: ST_TO_ADDR
35496: LD_EXP 48
35500: PUSH
35501: FOR_TO
35502: IFFALSE 35554
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35504: LD_EXP 48
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PUSH
35519: LD_VAR 0 3
35523: EQUAL
35524: IFFALSE 35552
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_EXP 48
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_INT 2
35544: ARRAY
35545: PPUSH
35546: CALL 8751 0 2
// break ;
35550: GO 35554
// end ;
35552: GO 35501
35554: POP
35555: POP
// end else
35556: GO 36145
// if MCF_Get ( side , [ f_constructed ] ) then
35558: LD_VAR 0 3
35562: PPUSH
35563: LD_INT 57
35565: PUSH
35566: EMPTY
35567: LIST
35568: PPUSH
35569: CALL 11651 0 2
35573: IFFALSE 35606
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_INT 57
35587: PUSH
35588: EMPTY
35589: LIST
35590: PPUSH
35591: CALL 11651 0 2
35595: PUSH
35596: LD_INT 1
35598: ARRAY
35599: PPUSH
35600: CALL 10995 0 2
35604: GO 36145
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_EXP 46
35615: PPUSH
35616: CALL 42999 0 2
35620: PUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 345
35630: NOT
35631: AND
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL 25006 0 1
35642: PUSH
35643: LD_INT 0
35645: EQUAL
35646: AND
35647: IFFALSE 36046
// begin for i = 1 to MREG_ToBuild do
35649: LD_ADDR_VAR 0 2
35653: PUSH
35654: DOUBLE
35655: LD_INT 1
35657: DEC
35658: ST_TO_ADDR
35659: LD_EXP 46
35663: PUSH
35664: FOR_TO
35665: IFFALSE 36042
// if MREG_ToBuild [ i ] [ 1 ] = side then
35667: LD_EXP 46
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 1
35680: ARRAY
35681: PUSH
35682: LD_VAR 0 3
35686: EQUAL
35687: IFFALSE 36040
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35689: LD_OWVAR 84
35693: PUSH
35694: LD_EXP 46
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 3
35707: ARRAY
35708: PUSH
35709: LD_INT 1
35711: ARRAY
35712: PPUSH
35713: LD_EXP 46
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PUSH
35728: LD_INT 2
35730: ARRAY
35731: PPUSH
35732: CALL_OW 351
35736: AND
35737: IFFALSE 35781
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35739: LD_EXP 46
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 46
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL 22799 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35781: LD_EXP 46
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 2
35794: ARRAY
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: IFFALSE 35869
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35801: LD_VAR 0 3
35805: PPUSH
35806: LD_EXP 46
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PUSH
35821: LD_INT 1
35823: ARRAY
35824: PPUSH
35825: LD_EXP 46
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 3
35838: ARRAY
35839: PUSH
35840: LD_INT 2
35842: ARRAY
35843: PPUSH
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 3
35857: ARRAY
35858: PUSH
35859: LD_INT 3
35861: ARRAY
35862: PPUSH
35863: CALL 8587 0 4
35867: GO 36038
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PUSH
35884: LD_INT 6
35886: EQUAL
35887: IFFALSE 35957
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35889: LD_VAR 0 3
35893: PPUSH
35894: LD_EXP 46
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 3
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PPUSH
35913: LD_EXP 46
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 3
35926: ARRAY
35927: PUSH
35928: LD_INT 2
35930: ARRAY
35931: PPUSH
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL 8716 0 4
35955: GO 36038
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35957: LD_VAR 0 3
35961: PPUSH
35962: LD_EXP 46
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 46
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PPUSH
35996: LD_EXP 46
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 2
36013: ARRAY
36014: PPUSH
36015: LD_EXP 46
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 3
36028: ARRAY
36029: PUSH
36030: LD_INT 3
36032: ARRAY
36033: PPUSH
36034: CALL 10220 0 5
// break ;
36038: GO 36042
// end ;
36040: GO 35664
36042: POP
36043: POP
// end else
36044: GO 36145
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36046: LD_VAR 0 3
36050: PPUSH
36051: LD_EXP 52
36055: PPUSH
36056: CALL 42999 0 2
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL 25006 0 1
36070: PUSH
36071: LD_INT 0
36073: EQUAL
36074: AND
36075: IFFALSE 36145
// begin for i = 1 to MREG_ToDismantle do
36077: LD_ADDR_VAR 0 2
36081: PUSH
36082: DOUBLE
36083: LD_INT 1
36085: DEC
36086: ST_TO_ADDR
36087: LD_EXP 52
36091: PUSH
36092: FOR_TO
36093: IFFALSE 36143
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36095: LD_EXP 52
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PUSH
36106: LD_INT 1
36108: ARRAY
36109: PUSH
36110: LD_VAR 0 3
36114: EQUAL
36115: IFFALSE 36141
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36117: LD_VAR 0 3
36121: PPUSH
36122: LD_EXP 52
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: CALL 10886 0 2
// end ;
36141: GO 36092
36143: POP
36144: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36145: LD_VAR 0 3
36149: PPUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PPUSH
36160: CALL 11651 0 2
36164: PUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL 25006 0 1
36174: PUSH
36175: LD_INT 0
36177: EQUAL
36178: AND
36179: IFFALSE 36190
// MCT_CollectCrates ( side ) ;
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 23945 0 1
// end ;
36190: GO 34191
36192: POP
36193: POP
// end ;
36194: LD_VAR 0 1
36198: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36199: LD_INT 0
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
// all := MCF_All ( side , [ ] ) ;
36216: LD_ADDR_VAR 0 17
36220: PUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL 11786 0 2
36232: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36233: LD_ADDR_VAR 0 13
36237: PUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_INT 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL 11734 0 3
36252: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36253: LD_ADDR_VAR 0 14
36257: PUSH
36258: LD_VAR 0 1
36262: PPUSH
36263: LD_INT 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL 11734 0 3
36272: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36273: LD_ADDR_VAR 0 15
36277: PUSH
36278: LD_VAR 0 1
36282: PPUSH
36283: LD_INT 3
36285: PPUSH
36286: EMPTY
36287: PPUSH
36288: CALL 11734 0 3
36292: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36293: LD_ADDR_VAR 0 16
36297: PUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_INT 4
36305: PPUSH
36306: EMPTY
36307: PPUSH
36308: CALL 11734 0 3
36312: ST_TO_ADDR
// if mech then
36313: LD_VAR 0 15
36317: IFFALSE 36334
// mech := MCF_SortListDesc ( mech ) ;
36319: LD_ADDR_VAR 0 15
36323: PUSH
36324: LD_VAR 0 15
36328: PPUSH
36329: CALL 12900 0 1
36333: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36334: LD_EXP 56
36338: PUSH
36339: LD_VAR 0 1
36343: ARRAY
36344: PUSH
36345: LD_STRING 
36347: EQUAL
36348: NOT
36349: IFFALSE 36405
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36351: LD_EXP 56
36355: PUSH
36356: LD_VAR 0 1
36360: ARRAY
36361: PUSH
36362: LD_INT 1
36364: ARRAY
36365: PPUSH
36366: CALL_OW 257
36370: PUSH
36371: LD_INT 1
36373: EQUAL
36374: IFFALSE 36403
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36376: LD_VAR 0 1
36380: PPUSH
36381: LD_STRING ToArm
36383: PPUSH
36384: LD_EXP 56
36388: PUSH
36389: LD_VAR 0 1
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL 14530 0 3
// end else
36403: GO 36431
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36405: LD_ADDR_EXP 56
36409: PUSH
36410: LD_EXP 56
36414: PPUSH
36415: LD_VAR 0 1
36419: PPUSH
36420: LD_INT 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL 31130 0 4
36430: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36431: LD_EXP 57
36435: PUSH
36436: LD_VAR 0 1
36440: ARRAY
36441: PUSH
36442: LD_STRING 
36444: EQUAL
36445: NOT
36446: IFFALSE 36502
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36448: LD_EXP 57
36452: PUSH
36453: LD_VAR 0 1
36457: ARRAY
36458: PUSH
36459: LD_INT 1
36461: ARRAY
36462: PPUSH
36463: CALL_OW 257
36467: PUSH
36468: LD_INT 2
36470: EQUAL
36471: IFFALSE 36500
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36473: LD_VAR 0 1
36477: PPUSH
36478: LD_STRING ToDep
36480: PPUSH
36481: LD_EXP 57
36485: PUSH
36486: LD_VAR 0 1
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: CALL 14530 0 3
// end else
36500: GO 36528
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36502: LD_ADDR_EXP 57
36506: PUSH
36507: LD_EXP 57
36511: PPUSH
36512: LD_VAR 0 1
36516: PPUSH
36517: LD_INT 1
36519: PPUSH
36520: LD_INT 0
36522: PPUSH
36523: CALL 31130 0 4
36527: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36528: LD_EXP 55
36532: PUSH
36533: LD_VAR 0 1
36537: ARRAY
36538: PUSH
36539: LD_STRING 
36541: EQUAL
36542: NOT
36543: IFFALSE 36599
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36545: LD_EXP 55
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: EQUAL
36568: IFFALSE 36597
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: LD_STRING ToFac
36577: PPUSH
36578: LD_EXP 55
36582: PUSH
36583: LD_VAR 0 1
36587: ARRAY
36588: PUSH
36589: LD_INT 1
36591: ARRAY
36592: PPUSH
36593: CALL 14530 0 3
// end else
36597: GO 36625
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36599: LD_ADDR_EXP 55
36603: PUSH
36604: LD_EXP 55
36608: PPUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: LD_INT 0
36619: PPUSH
36620: CALL 31130 0 4
36624: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36625: LD_EXP 54
36629: PUSH
36630: LD_VAR 0 1
36634: ARRAY
36635: PUSH
36636: LD_STRING 
36638: EQUAL
36639: NOT
36640: IFFALSE 36696
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36642: LD_EXP 54
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL_OW 257
36661: PUSH
36662: LD_INT 4
36664: EQUAL
36665: IFFALSE 36694
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36667: LD_VAR 0 1
36671: PPUSH
36672: LD_STRING ToLab
36674: PPUSH
36675: LD_EXP 54
36679: PUSH
36680: LD_VAR 0 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: CALL 14530 0 3
// end else
36694: GO 36722
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36696: LD_ADDR_EXP 54
36700: PUSH
36701: LD_EXP 54
36705: PPUSH
36706: LD_VAR 0 1
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: LD_INT 0
36716: PPUSH
36717: CALL 31130 0 4
36721: ST_TO_ADDR
// if mode = 0 then
36722: LD_VAR 0 2
36726: PUSH
36727: LD_INT 0
36729: EQUAL
36730: IFFALSE 38568
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36732: LD_VAR 0 1
36736: PPUSH
36737: LD_INT 30
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL 11651 0 2
36751: PUSH
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 21
36759: PUSH
36760: LD_INT 3
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PPUSH
36767: CALL 11651 0 2
36771: PUSH
36772: LD_INT 1
36774: EQUAL
36775: AND
36776: IFFALSE 36841
// begin if all then
36778: LD_VAR 0 17
36782: IFFALSE 36839
// for i in ( all diff eng ) do
36784: LD_ADDR_VAR 0 4
36788: PUSH
36789: LD_VAR 0 17
36793: PUSH
36794: LD_VAR 0 14
36798: DIFF
36799: PUSH
36800: FOR_IN
36801: IFFALSE 36837
// if GetTag ( i ) = 0 then
36803: LD_VAR 0 4
36807: PPUSH
36808: CALL_OW 110
36812: PUSH
36813: LD_INT 0
36815: EQUAL
36816: IFFALSE 36835
// MCH_ChangeClass ( side , i , 2 ) ;
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 2
36830: PPUSH
36831: CALL 16558 0 3
36835: GO 36800
36837: POP
36838: POP
// end else
36839: GO 37160
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36841: LD_VAR 0 13
36845: PUSH
36846: LD_EXP 56
36850: PUSH
36851: LD_VAR 0 1
36855: ARRAY
36856: PLUS
36857: PUSH
36858: LD_INT 22
36860: PUSH
36861: LD_VAR 0 1
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 32
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 69
36888: LESS
36889: IFFALSE 36914
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_VAR 0 14
36900: PUSH
36901: LD_INT 1
36903: ARRAY
36904: PPUSH
36905: LD_INT 1
36907: PPUSH
36908: CALL 16558 0 3
// end else
36912: GO 37160
// if sci < 6 and MCF_Lab ( side ) then
36914: LD_VAR 0 16
36918: PUSH
36919: LD_INT 6
36921: LESS
36922: PUSH
36923: LD_VAR 0 1
36927: PPUSH
36928: CALL 11690 0 1
36932: AND
36933: IFFALSE 37038
// begin if MREG_ToBunker [ side ] then
36935: LD_EXP 68
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: IFFALSE 36971
// tmp := sol diff MREG_ToBunker [ side ] else
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: PUSH
36957: LD_EXP 68
36961: PUSH
36962: LD_VAR 0 1
36966: ARRAY
36967: DIFF
36968: ST_TO_ADDR
36969: GO 36981
// tmp := sol ;
36971: LD_ADDR_VAR 0 12
36975: PUSH
36976: LD_VAR 0 13
36980: ST_TO_ADDR
// if tmp then
36981: LD_VAR 0 12
36985: IFFALSE 37036
// for i in tmp do
36987: LD_ADDR_VAR 0 4
36991: PUSH
36992: LD_VAR 0 12
36996: PUSH
36997: FOR_IN
36998: IFFALSE 37034
// if GetTag ( i ) = 0 then
37000: LD_VAR 0 4
37004: PPUSH
37005: CALL_OW 110
37009: PUSH
37010: LD_INT 0
37012: EQUAL
37013: IFFALSE 37032
// MCH_ChangeClass ( side , i , 4 ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: LD_INT 4
37027: PPUSH
37028: CALL 16558 0 3
37032: GO 36997
37034: POP
37035: POP
// end else
37036: GO 37160
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37038: LD_VAR 0 1
37042: PPUSH
37043: LD_INT 30
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL 11651 0 2
37057: IFFALSE 37160
// begin if MREG_ToBunker [ side ] then
37059: LD_EXP 68
37063: PUSH
37064: LD_VAR 0 1
37068: ARRAY
37069: IFFALSE 37095
// tmp := sol diff MREG_ToBunker [ side ] else
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: PUSH
37081: LD_EXP 68
37085: PUSH
37086: LD_VAR 0 1
37090: ARRAY
37091: DIFF
37092: ST_TO_ADDR
37093: GO 37105
// tmp := sol ;
37095: LD_ADDR_VAR 0 12
37099: PUSH
37100: LD_VAR 0 13
37104: ST_TO_ADDR
// if tmp then
37105: LD_VAR 0 12
37109: IFFALSE 37160
// for i in tmp do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 12
37120: PUSH
37121: FOR_IN
37122: IFFALSE 37158
// if GetTag ( i ) = 0 then
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL_OW 110
37133: PUSH
37134: LD_INT 0
37136: EQUAL
37137: IFFALSE 37156
// MCH_ChangeClass ( side , i , 2 ) ;
37139: LD_VAR 0 1
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: LD_INT 2
37151: PPUSH
37152: CALL 16558 0 3
37156: GO 37121
37158: POP
37159: POP
// end ; if MCF_Lab ( side ) then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL 11690 0 1
37169: IFFALSE 37709
// begin if MCL_GetTechList ( side ) then
37171: LD_VAR 0 1
37175: PPUSH
37176: CALL 18034 0 1
37180: IFFALSE 37306
// begin if MREG_ToLab [ side ] then
37182: LD_EXP 54
37186: PUSH
37187: LD_VAR 0 1
37191: ARRAY
37192: IFFALSE 37212
// k := MREG_ToLab [ side ] else
37194: LD_ADDR_VAR 0 8
37198: PUSH
37199: LD_EXP 54
37203: PUSH
37204: LD_VAR 0 1
37208: ARRAY
37209: ST_TO_ADDR
37210: GO 37220
// k := 0 ;
37212: LD_ADDR_VAR 0 8
37216: PUSH
37217: LD_INT 0
37219: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37220: LD_VAR 0 16
37224: PUSH
37225: LD_VAR 0 8
37229: PLUS
37230: PUSH
37231: LD_INT 6
37233: LESSEQUAL
37234: PUSH
37235: LD_VAR 0 17
37239: PUSH
37240: LD_INT 6
37242: GREATER
37243: AND
37244: IFFALSE 37260
// MCH_TrainScientist ( side , 1 ) else
37246: LD_VAR 0 1
37250: PPUSH
37251: LD_INT 1
37253: PPUSH
37254: CALL 16110 0 2
37258: GO 37304
// if all < 6 then
37260: LD_VAR 0 17
37264: PUSH
37265: LD_INT 6
37267: LESS
37268: IFFALSE 37304
// if sci + k < all / 2 then
37270: LD_VAR 0 16
37274: PUSH
37275: LD_VAR 0 8
37279: PLUS
37280: PUSH
37281: LD_VAR 0 17
37285: PUSH
37286: LD_INT 2
37288: DIVREAL
37289: LESS
37290: IFFALSE 37304
// MCH_TrainScientist ( side , 1 ) ;
37292: LD_VAR 0 1
37296: PPUSH
37297: LD_INT 1
37299: PPUSH
37300: CALL 16110 0 2
// end else
37304: GO 37382
// begin if sci > 2 then
37306: LD_VAR 0 16
37310: PUSH
37311: LD_INT 2
37313: GREATER
37314: IFFALSE 37382
// for i = sci downto 2 do
37316: LD_ADDR_VAR 0 4
37320: PUSH
37321: DOUBLE
37322: LD_VAR 0 16
37326: INC
37327: ST_TO_ADDR
37328: LD_INT 2
37330: PUSH
37331: FOR_DOWNTO
37332: IFFALSE 37380
// if GetTag ( sci [ i ] ) = 0 then
37334: LD_VAR 0 16
37338: PUSH
37339: LD_VAR 0 4
37343: ARRAY
37344: PPUSH
37345: CALL_OW 110
37349: PUSH
37350: LD_INT 0
37352: EQUAL
37353: IFFALSE 37378
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_VAR 0 16
37364: PUSH
37365: LD_VAR 0 4
37369: ARRAY
37370: PPUSH
37371: LD_INT 2
37373: PPUSH
37374: CALL 16558 0 3
37378: GO 37331
37380: POP
37381: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37382: LD_VAR 0 1
37386: PPUSH
37387: CALL 18034 0 1
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL 11690 0 1
37401: AND
37402: PUSH
37403: LD_EXP 35
37407: PUSH
37408: LD_VAR 0 1
37412: ARRAY
37413: NOT
37414: AND
37415: IFFALSE 37709
// begin for j = 1 to MCF_Lab ( side ) do
37417: LD_ADDR_VAR 0 5
37421: PUSH
37422: DOUBLE
37423: LD_INT 1
37425: DEC
37426: ST_TO_ADDR
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 11690 0 1
37436: PUSH
37437: FOR_TO
37438: IFFALSE 37498
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37440: LD_VAR 0 1
37444: PPUSH
37445: CALL 11690 0 1
37449: PUSH
37450: LD_VAR 0 5
37454: ARRAY
37455: PPUSH
37456: CALL_OW 461
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 6
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: IN
37471: IFFALSE 37496
// begin b := MCF_Lab ( side ) [ j ] ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: CALL 11690 0 1
37487: PUSH
37488: LD_VAR 0 5
37492: ARRAY
37493: ST_TO_ADDR
// break ;
37494: GO 37498
// end ;
37496: GO 37437
37498: POP
37499: POP
// if MCF_Class ( side , 4 , [ ] ) then
37500: LD_VAR 0 1
37504: PPUSH
37505: LD_INT 4
37507: PPUSH
37508: EMPTY
37509: PPUSH
37510: CALL 11734 0 3
37514: IFFALSE 37709
// for j in MCF_Class ( side , 4 , [ ] ) do
37516: LD_ADDR_VAR 0 5
37520: PUSH
37521: LD_VAR 0 1
37525: PPUSH
37526: LD_INT 4
37528: PPUSH
37529: EMPTY
37530: PPUSH
37531: CALL 11734 0 3
37535: PUSH
37536: FOR_IN
37537: IFFALSE 37707
// begin if GetTag ( j ) = 0 then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 110
37548: PUSH
37549: LD_INT 0
37551: EQUAL
37552: IFFALSE 37643
// begin if IsInUnit ( j ) and b then
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 310
37563: PUSH
37564: LD_VAR 0 11
37568: AND
37569: IFFALSE 37617
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37571: LD_VAR 0 5
37575: PPUSH
37576: CALL_OW 310
37580: PPUSH
37581: CALL_OW 461
37585: PUSH
37586: LD_INT 2
37588: EQUAL
37589: PUSH
37590: LD_VAR 0 5
37594: PPUSH
37595: CALL_OW 310
37599: PUSH
37600: LD_VAR 0 11
37604: NONEQUAL
37605: AND
37606: IFFALSE 37617
// ComExitBuilding ( j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 122
// if not IsInUnit ( j ) then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: NOT
37627: IFFALSE 37643
// ComEnterUnit ( j , b ) ;
37629: LD_VAR 0 5
37633: PPUSH
37634: LD_VAR 0 11
37638: PPUSH
37639: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37643: LD_INT 1
37645: PPUSH
37646: LD_VAR 0 5
37650: PPUSH
37651: CALL_OW 255
37655: PPUSH
37656: CALL_OW 321
37660: PUSH
37661: LD_INT 2
37663: EQUAL
37664: PUSH
37665: LD_VAR 0 5
37669: PPUSH
37670: CALL_OW 255
37674: PPUSH
37675: CALL 25006 0 1
37679: PUSH
37680: LD_INT 0
37682: EQUAL
37683: AND
37684: IFFALSE 37705
// MCN_Tame ( GetSide ( j ) , j ) ;
37686: LD_VAR 0 5
37690: PPUSH
37691: CALL_OW 255
37695: PPUSH
37696: LD_VAR 0 5
37700: PPUSH
37701: CALL 18553 0 2
// end ;
37705: GO 37536
37707: POP
37708: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37709: LD_VAR 0 1
37713: PPUSH
37714: LD_INT 30
37716: PUSH
37717: LD_INT 3
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PPUSH
37724: CALL 11651 0 2
37728: IFFALSE 37987
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37730: LD_ADDR_VAR 0 11
37734: PUSH
37735: LD_VAR 0 1
37739: PPUSH
37740: LD_INT 30
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PPUSH
37750: CALL 11651 0 2
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37759: LD_ADDR_VAR 0 12
37763: PUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: LD_INT 0
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 3
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL 12354 0 3
37786: ST_TO_ADDR
// for i = 1 to tmp do
37787: LD_ADDR_VAR 0 4
37791: PUSH
37792: DOUBLE
37793: LD_INT 1
37795: DEC
37796: ST_TO_ADDR
37797: LD_VAR 0 12
37801: PUSH
37802: FOR_TO
37803: IFFALSE 37863
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37805: LD_VAR 0 12
37809: PUSH
37810: LD_VAR 0 4
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: NOT
37821: PUSH
37822: LD_VAR 0 12
37826: PUSH
37827: LD_VAR 0 4
37831: ARRAY
37832: PPUSH
37833: CALL_OW 314
37837: NOT
37838: AND
37839: IFFALSE 37861
// ComEnterUnit ( tmp [ i ] , b ) ;
37841: LD_VAR 0 12
37845: PUSH
37846: LD_VAR 0 4
37850: ARRAY
37851: PPUSH
37852: LD_VAR 0 11
37856: PPUSH
37857: CALL_OW 120
37861: GO 37802
37863: POP
37864: POP
// if MREG_ToFac [ side ] then
37865: LD_EXP 55
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: IFFALSE 37895
// k := MREG_ToFac [ side ] else
37877: LD_ADDR_VAR 0 8
37881: PUSH
37882: LD_EXP 55
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: ST_TO_ADDR
37893: GO 37903
// k := 0 ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_INT 0
37902: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37903: LD_VAR 0 15
37907: PUSH
37908: LD_VAR 0 8
37912: PLUS
37913: PUSH
37914: LD_INT 6
37916: LESSEQUAL
37917: PUSH
37918: LD_VAR 0 17
37922: PUSH
37923: LD_INT 6
37925: GREATER
37926: AND
37927: IFFALSE 37943
// MCH_TrainMechanic ( side , 1 ) else
37929: LD_VAR 0 1
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL 15852 0 2
37941: GO 37987
// if all < 6 then
37943: LD_VAR 0 17
37947: PUSH
37948: LD_INT 6
37950: LESS
37951: IFFALSE 37987
// if mech + k < all / 2 then
37953: LD_VAR 0 15
37957: PUSH
37958: LD_VAR 0 8
37962: PLUS
37963: PUSH
37964: LD_VAR 0 17
37968: PUSH
37969: LD_INT 2
37971: DIVREAL
37972: LESS
37973: IFFALSE 37987
// MCH_TrainMechanic ( side , 1 ) ;
37975: LD_VAR 0 1
37979: PPUSH
37980: LD_INT 1
37982: PPUSH
37983: CALL 15852 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37987: LD_ADDR_VAR 0 10
37991: PUSH
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 30
37999: PUSH
38000: LD_INT 36
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL 11651 0 2
38011: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38012: LD_VAR 0 10
38016: PUSH
38017: LD_VAR 0 15
38021: AND
38022: PUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 3
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL 11734 0 3
38037: AND
38038: IFFALSE 38196
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38040: LD_VAR 0 1
38044: PPUSH
38045: LD_INT 9
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL 12354 0 3
38054: PUSH
38055: LD_INT 3
38057: LESS
38058: IFFALSE 38196
// begin if mech < 3 then
38060: LD_VAR 0 15
38064: PUSH
38065: LD_INT 3
38067: LESS
38068: IFFALSE 38082
// k := mech else
38070: LD_ADDR_VAR 0 8
38074: PUSH
38075: LD_VAR 0 15
38079: ST_TO_ADDR
38080: GO 38090
// k := 3 ;
38082: LD_ADDR_VAR 0 8
38086: PUSH
38087: LD_INT 3
38089: ST_TO_ADDR
// for j = 1 to k do
38090: LD_ADDR_VAR 0 5
38094: PUSH
38095: DOUBLE
38096: LD_INT 1
38098: DEC
38099: ST_TO_ADDR
38100: LD_VAR 0 8
38104: PUSH
38105: FOR_TO
38106: IFFALSE 38164
// if GetClass ( mech [ j ] ) = 3 then
38108: LD_VAR 0 15
38112: PUSH
38113: LD_VAR 0 5
38117: ARRAY
38118: PPUSH
38119: CALL_OW 257
38123: PUSH
38124: LD_INT 3
38126: EQUAL
38127: IFFALSE 38162
// begin SetTag ( mech [ j ] , 9 ) ;
38129: LD_VAR 0 15
38133: PUSH
38134: LD_VAR 0 5
38138: ARRAY
38139: PPUSH
38140: LD_INT 9
38142: PPUSH
38143: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38147: LD_VAR 0 15
38151: PUSH
38152: LD_VAR 0 5
38156: ARRAY
38157: PPUSH
38158: CALL_OW 122
// end ;
38162: GO 38105
38164: POP
38165: POP
// if mech < 6 + k then
38166: LD_VAR 0 15
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_VAR 0 8
38178: PLUS
38179: LESS
38180: IFFALSE 38196
// MCH_TrainMechanic ( side , k ) ;
38182: LD_VAR 0 1
38186: PPUSH
38187: LD_VAR 0 8
38191: PPUSH
38192: CALL 15852 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38196: LD_VAR 0 1
38200: PPUSH
38201: LD_INT 9
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL 12354 0 3
38210: IFFALSE 38301
// for j in MCF_Tag ( side , 9 , [ ] ) do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_VAR 0 1
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL 12354 0 3
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38299
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38235: LD_VAR 0 5
38239: PPUSH
38240: CALL_OW 310
38244: NOT
38245: PUSH
38246: LD_VAR 0 5
38250: PPUSH
38251: CALL 98431 0 1
38255: NOT
38256: AND
38257: IFFALSE 38297
// if ct then
38259: LD_VAR 0 10
38263: IFFALSE 38285
// ComEnterUnit ( j , ct [ 1 ] ) else
38265: LD_VAR 0 5
38269: PPUSH
38270: LD_VAR 0 10
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: PPUSH
38279: CALL_OW 120
38283: GO 38297
// SetTag ( j , 0 ) ;
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_INT 0
38292: PPUSH
38293: CALL_OW 109
38297: GO 38232
38299: POP
38300: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38301: LD_INT 1
38303: PPUSH
38304: LD_VAR 0 1
38308: PPUSH
38309: CALL_OW 321
38313: PUSH
38314: LD_INT 2
38316: EQUAL
38317: PUSH
38318: LD_EXP 35
38322: PUSH
38323: LD_VAR 0 1
38327: ARRAY
38328: NOT
38329: AND
38330: PUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: LD_INT 4
38338: PPUSH
38339: EMPTY
38340: PPUSH
38341: CALL 11734 0 3
38345: AND
38346: IFFALSE 38394
// for j in MCF_Class ( side , 4 , [ ] ) do
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: LD_INT 4
38360: PPUSH
38361: EMPTY
38362: PPUSH
38363: CALL 11734 0 3
38367: PUSH
38368: FOR_IN
38369: IFFALSE 38392
// MCN_Tame ( GetSide ( j ) , j ) ;
38371: LD_VAR 0 5
38375: PPUSH
38376: CALL_OW 255
38380: PPUSH
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL 18553 0 2
38390: GO 38368
38392: POP
38393: POP
// if MREG_DefVeh [ side ] then
38394: LD_EXP 67
38398: PUSH
38399: LD_VAR 0 1
38403: ARRAY
38404: IFFALSE 38568
// begin for i in MREG_DefVeh [ side ] do
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 67
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: PUSH
38422: FOR_IN
38423: IFFALSE 38476
// begin SetTag ( i , 0 ) ;
38425: LD_VAR 0 4
38429: PPUSH
38430: LD_INT 0
38432: PPUSH
38433: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38437: LD_VAR 0 4
38441: PPUSH
38442: LD_EXP 64
38446: PUSH
38447: LD_VAR 0 1
38451: ARRAY
38452: PPUSH
38453: CALL_OW 308
38457: NOT
38458: IFFALSE 38474
// MCV_Parking ( side , i ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: CALL 25741 0 2
// end ;
38474: GO 38422
38476: POP
38477: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38478: LD_VAR 0 1
38482: PPUSH
38483: LD_INT 36
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL 12354 0 3
38492: IFFALSE 38533
// for i in MCF_Tag ( side , 36 , [ ] ) do
38494: LD_ADDR_VAR 0 4
38498: PUSH
38499: LD_VAR 0 1
38503: PPUSH
38504: LD_INT 36
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL 12354 0 3
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38531
// SetTag ( i , 0 ) ;
38517: LD_VAR 0 4
38521: PPUSH
38522: LD_INT 0
38524: PPUSH
38525: CALL_OW 109
38529: GO 38514
38531: POP
38532: POP
// if MREG_DefMobActive [ side ] then
38533: LD_EXP 70
38537: PUSH
38538: LD_VAR 0 1
38542: ARRAY
38543: IFFALSE 38568
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38545: LD_ADDR_EXP 70
38549: PUSH
38550: LD_EXP 70
38554: PPUSH
38555: LD_VAR 0 1
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// end ; end ; if mode > 0 then
38568: LD_VAR 0 2
38572: PUSH
38573: LD_INT 0
38575: GREATER
38576: IFFALSE 40471
// begin if tick <= 15 15$00 then
38578: LD_OWVAR 1
38582: PUSH
38583: LD_INT 31500
38585: LESSEQUAL
38586: IFFALSE 38890
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38588: LD_VAR 0 13
38592: PUSH
38593: LD_VAR 0 1
38597: PPUSH
38598: CALL 25006 0 1
38602: PUSH
38603: LD_INT 4
38605: LESS
38606: AND
38607: IFFALSE 38718
// begin for i in sol do
38609: LD_ADDR_VAR 0 4
38613: PUSH
38614: LD_VAR 0 13
38618: PUSH
38619: FOR_IN
38620: IFFALSE 38716
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38622: LD_ADDR_VAR 0 8
38626: PUSH
38627: LD_VAR 0 1
38631: PPUSH
38632: CALL 25006 0 1
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: CALL_OW 74
38646: ST_TO_ADDR
// if IsInUnit ( i ) then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 310
38656: IFFALSE 38667
// ComExitBuilding ( i ) ;
38658: LD_VAR 0 4
38662: PPUSH
38663: CALL_OW 122
// if not HasTask ( i ) and k then
38667: LD_VAR 0 4
38671: PPUSH
38672: CALL_OW 314
38676: NOT
38677: PUSH
38678: LD_VAR 0 8
38682: AND
38683: IFFALSE 38714
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38685: LD_VAR 0 4
38689: PPUSH
38690: LD_VAR 0 8
38694: PPUSH
38695: CALL_OW 250
38699: PPUSH
38700: LD_VAR 0 8
38704: PPUSH
38705: CALL_OW 251
38709: PPUSH
38710: CALL_OW 174
// end ;
38714: GO 38619
38716: POP
38717: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38718: LD_VAR 0 1
38722: PPUSH
38723: LD_INT 30
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PPUSH
38733: CALL 11651 0 2
38737: IFFALSE 38888
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38739: LD_ADDR_VAR 0 11
38743: PUSH
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 30
38751: PUSH
38752: LD_INT 5
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL 11651 0 2
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: ST_TO_ADDR
// if mech then
38768: LD_VAR 0 15
38772: IFFALSE 38808
// for i in mech do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 15
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38806
// MCH_ChangeClass ( side , i , 1 ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: CALL 16558 0 3
38804: GO 38784
38806: POP
38807: POP
// if eng > 1 then
38808: LD_VAR 0 14
38812: PUSH
38813: LD_INT 1
38815: GREATER
38816: IFFALSE 38863
// for i = eng downto 2 do
38818: LD_ADDR_VAR 0 4
38822: PUSH
38823: DOUBLE
38824: LD_VAR 0 14
38828: INC
38829: ST_TO_ADDR
38830: LD_INT 2
38832: PUSH
38833: FOR_DOWNTO
38834: IFFALSE 38861
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 14
38845: PUSH
38846: LD_VAR 0 4
38850: ARRAY
38851: PPUSH
38852: LD_INT 1
38854: PPUSH
38855: CALL 16558 0 3
38859: GO 38833
38861: POP
38862: POP
// if UnitsInside ( b ) then
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: IFFALSE 38888
// ComExitBuilding ( UnitsInside ( b ) ) ;
38874: LD_VAR 0 11
38878: PPUSH
38879: CALL_OW 313
38883: PPUSH
38884: CALL_OW 122
// end ; end else
38888: GO 40471
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38890: LD_VAR 0 1
38894: PPUSH
38895: LD_INT 1
38897: PPUSH
38898: LD_EXP 65
38902: PUSH
38903: LD_VAR 0 1
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: PPUSH
38913: CALL 33743 0 3
38917: IFFALSE 39056
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38919: LD_ADDR_VAR 0 12
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: LD_INT 21
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL 11651 0 2
38943: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38944: LD_ADDR_VAR 0 11
38948: PUSH
38949: LD_VAR 0 1
38953: PPUSH
38954: LD_INT 30
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL 11651 0 2
38968: ST_TO_ADDR
// if b then
38969: LD_VAR 0 11
38973: IFFALSE 39056
// for i in tmp do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 12
38984: PUSH
38985: FOR_IN
38986: IFFALSE 39054
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38988: LD_VAR 0 4
38992: PPUSH
38993: LD_EXP 65
38997: PUSH
38998: LD_VAR 0 1
39002: ARRAY
39003: PUSH
39004: LD_INT 1
39006: ARRAY
39007: PPUSH
39008: CALL_OW 308
39012: NOT
39013: IFFALSE 39052
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39015: LD_VAR 0 4
39019: PPUSH
39020: LD_VAR 0 11
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 250
39033: PPUSH
39034: LD_VAR 0 11
39038: PUSH
39039: LD_INT 1
39041: ARRAY
39042: PPUSH
39043: CALL_OW 251
39047: PPUSH
39048: CALL_OW 111
39052: GO 38985
39054: POP
39055: POP
// end ; if MREG_DefVeh [ side ] then
39056: LD_EXP 67
39060: PUSH
39061: LD_VAR 0 1
39065: ARRAY
39066: IFFALSE 39634
// begin tmp := [ ] ;
39068: LD_ADDR_VAR 0 12
39072: PUSH
39073: EMPTY
39074: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39075: LD_EXP 70
39079: PUSH
39080: LD_VAR 0 1
39084: ARRAY
39085: PUSH
39086: LD_INT 0
39088: EQUAL
39089: IFFALSE 39229
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39091: LD_ADDR_VAR 0 8
39095: PUSH
39096: LD_VAR 0 1
39100: PPUSH
39101: LD_INT 0
39103: PPUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 3
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL 12354 0 3
39118: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39119: LD_VAR 0 8
39123: PUSH
39124: LD_EXP 67
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: GREATER
39135: IFFALSE 39196
// begin for i = 1 to MREG_DefVeh [ side ] do
39137: LD_ADDR_VAR 0 4
39141: PUSH
39142: DOUBLE
39143: LD_INT 1
39145: DEC
39146: ST_TO_ADDR
39147: LD_EXP 67
39151: PUSH
39152: LD_VAR 0 1
39156: ARRAY
39157: PUSH
39158: FOR_TO
39159: IFFALSE 39192
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39161: LD_ADDR_VAR 0 12
39165: PUSH
39166: LD_VAR 0 12
39170: PPUSH
39171: LD_INT 1
39173: PPUSH
39174: LD_VAR 0 8
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PPUSH
39185: CALL_OW 2
39189: ST_TO_ADDR
39190: GO 39158
39192: POP
39193: POP
// end else
39194: GO 39206
// tmp := k ;
39196: LD_ADDR_VAR 0 12
39200: PUSH
39201: LD_VAR 0 8
39205: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39206: LD_ADDR_EXP 70
39210: PUSH
39211: LD_EXP 70
39215: PPUSH
39216: LD_VAR 0 1
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39229: LD_ADDR_VAR 0 4
39233: PUSH
39234: LD_EXP 67
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: PUSH
39245: FOR_IN
39246: IFFALSE 39632
// begin if not GetDriver ( i ) then
39248: LD_VAR 0 4
39252: PPUSH
39253: CALL 31773 0 1
39257: NOT
39258: IFFALSE 39333
// begin if tmp then
39260: LD_VAR 0 12
39264: IFFALSE 39331
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39266: LD_VAR 0 12
39270: PUSH
39271: LD_INT 1
39273: ARRAY
39274: PPUSH
39275: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39279: LD_VAR 0 12
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: LD_VAR 0 4
39292: PPUSH
39293: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39297: LD_VAR 0 12
39301: PUSH
39302: LD_INT 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 36
39308: PPUSH
39309: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39313: LD_ADDR_VAR 0 12
39317: PUSH
39318: LD_VAR 0 12
39322: PPUSH
39323: LD_INT 1
39325: PPUSH
39326: CALL_OW 3
39330: ST_TO_ADDR
// end ; end else
39331: GO 39630
// begin if GetTag ( i ) = 0 then
39333: LD_VAR 0 4
39337: PPUSH
39338: CALL_OW 110
39342: PUSH
39343: LD_INT 0
39345: EQUAL
39346: IFFALSE 39362
// SetTag ( i , 31 ) else
39348: LD_VAR 0 4
39352: PPUSH
39353: LD_INT 31
39355: PPUSH
39356: CALL_OW 109
39360: GO 39630
// if GetTag ( i ) = 31 then
39362: LD_VAR 0 4
39366: PPUSH
39367: CALL_OW 110
39371: PUSH
39372: LD_INT 31
39374: EQUAL
39375: IFFALSE 39630
// begin if GetFuel ( i ) < 20 then
39377: LD_VAR 0 4
39381: PPUSH
39382: CALL_OW 261
39386: PUSH
39387: LD_INT 20
39389: LESS
39390: IFFALSE 39415
// begin SetTag ( i , 21 ) ;
39392: LD_VAR 0 4
39396: PPUSH
39397: LD_INT 21
39399: PPUSH
39400: CALL_OW 109
// MCV_Refuel ( i ) ;
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL 26278 0 1
// continue ;
39413: GO 39245
// end ; if GetLives ( i ) < 700 then
39415: LD_VAR 0 4
39419: PPUSH
39420: CALL_OW 256
39424: PUSH
39425: LD_INT 700
39427: LESS
39428: IFFALSE 39540
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39430: LD_VAR 0 4
39434: PPUSH
39435: LD_EXP 58
39439: PUSH
39440: LD_VAR 0 1
39444: ARRAY
39445: PPUSH
39446: CALL_OW 308
39450: NOT
39451: IFFALSE 39475
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39453: LD_VAR 0 4
39457: PPUSH
39458: LD_EXP 58
39462: PUSH
39463: LD_VAR 0 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 113
39473: GO 39538
// if GetDriver ( i ) then
39475: LD_VAR 0 4
39479: PPUSH
39480: CALL 31773 0 1
39484: IFFALSE 39538
// begin k := GetDriver ( i ) ;
39486: LD_ADDR_VAR 0 8
39490: PUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31773 0 1
39500: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39501: LD_VAR 0 8
39505: PPUSH
39506: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39510: LD_VAR 0 8
39514: PPUSH
39515: LD_VAR 0 4
39519: PPUSH
39520: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39524: LD_VAR 0 8
39528: PPUSH
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL_OW 180
// end ; end else
39538: GO 39630
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39540: LD_ADDR_VAR 0 8
39544: PUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: CALL 25006 0 1
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: CALL_OW 74
39564: ST_TO_ADDR
// if k then
39565: LD_VAR 0 8
39569: IFFALSE 39587
// ComAttackUnit ( i , k ) else
39571: LD_VAR 0 4
39575: PPUSH
39576: LD_VAR 0 8
39580: PPUSH
39581: CALL_OW 115
39585: GO 39630
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_EXP 58
39596: PUSH
39597: LD_VAR 0 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 308
39607: NOT
39608: IFFALSE 39630
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39610: LD_VAR 0 4
39614: PPUSH
39615: LD_EXP 58
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: CALL_OW 113
// end ; end ; end ; end ;
39630: GO 39245
39632: POP
39633: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_INT 30
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PPUSH
39649: CALL 11651 0 2
39653: IFFALSE 40471
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39655: LD_ADDR_VAR 0 11
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: LD_INT 30
39667: PUSH
39668: LD_INT 5
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PPUSH
39675: CALL 11651 0 2
39679: PUSH
39680: LD_INT 1
39682: ARRAY
39683: ST_TO_ADDR
// if eng > 1 then
39684: LD_VAR 0 14
39688: PUSH
39689: LD_INT 1
39691: GREATER
39692: IFFALSE 39739
// for i = eng downto 2 do
39694: LD_ADDR_VAR 0 4
39698: PUSH
39699: DOUBLE
39700: LD_VAR 0 14
39704: INC
39705: ST_TO_ADDR
39706: LD_INT 2
39708: PUSH
39709: FOR_DOWNTO
39710: IFFALSE 39737
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39712: LD_VAR 0 1
39716: PPUSH
39717: LD_VAR 0 14
39721: PUSH
39722: LD_VAR 0 4
39726: ARRAY
39727: PPUSH
39728: LD_INT 1
39730: PPUSH
39731: CALL 16558 0 3
39735: GO 39709
39737: POP
39738: POP
// if sci > 1 then
39739: LD_VAR 0 16
39743: PUSH
39744: LD_INT 1
39746: GREATER
39747: IFFALSE 39794
// for i = sci downto 2 do
39749: LD_ADDR_VAR 0 4
39753: PUSH
39754: DOUBLE
39755: LD_VAR 0 16
39759: INC
39760: ST_TO_ADDR
39761: LD_INT 2
39763: PUSH
39764: FOR_DOWNTO
39765: IFFALSE 39792
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39767: LD_VAR 0 1
39771: PPUSH
39772: LD_VAR 0 16
39776: PUSH
39777: LD_VAR 0 4
39781: ARRAY
39782: PPUSH
39783: LD_INT 1
39785: PPUSH
39786: CALL 16558 0 3
39790: GO 39764
39792: POP
39793: POP
// if sol then
39794: LD_VAR 0 13
39798: IFFALSE 40471
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39800: LD_VAR 0 13
39804: PUSH
39805: LD_EXP 68
39809: PUSH
39810: LD_VAR 0 1
39814: ARRAY
39815: DIFF
39816: PUSH
39817: LD_INT 22
39819: PUSH
39820: LD_VAR 0 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 58
39831: PUSH
39832: EMPTY
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 32
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 31
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: PUSH
39873: LD_INT 0
39875: EQUAL
39876: AND
39877: IFFALSE 40471
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39879: LD_ADDR_VAR 0 12
39883: PUSH
39884: LD_VAR 0 13
39888: PUSH
39889: LD_EXP 68
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: DIFF
39900: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39901: LD_VAR 0 1
39905: PPUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PPUSH
39916: CALL 11651 0 2
39920: PUSH
39921: LD_INT 1
39923: GREATER
39924: IFFALSE 39955
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39926: LD_ADDR_VAR 0 8
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 30
39938: PUSH
39939: LD_INT 5
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL 11651 0 2
39950: PUSH
39951: LD_INT 2
39953: ARRAY
39954: ST_TO_ADDR
// for j in tmp do
39955: LD_ADDR_VAR 0 5
39959: PUSH
39960: LD_VAR 0 12
39964: PUSH
39965: FOR_IN
39966: IFFALSE 40469
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39968: LD_VAR 0 5
39972: PUSH
39973: LD_VAR 0 11
39977: PPUSH
39978: CALL_OW 313
39982: IN
39983: PUSH
39984: LD_VAR 0 11
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: EQUAL
39997: AND
39998: PUSH
39999: LD_VAR 0 8
40003: AND
40004: PUSH
40005: LD_VAR 0 8
40009: PPUSH
40010: CALL_OW 313
40014: PUSH
40015: LD_INT 6
40017: LESS
40018: AND
40019: IFFALSE 40046
// begin ComExitBuilding ( j ) ;
40021: LD_VAR 0 5
40025: PPUSH
40026: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40030: LD_VAR 0 5
40034: PPUSH
40035: LD_VAR 0 8
40039: PPUSH
40040: CALL_OW 180
// continue ;
40044: GO 39965
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40046: LD_VAR 0 5
40050: PPUSH
40051: CALL_OW 314
40055: NOT
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: CALL_OW 110
40066: PUSH
40067: LD_INT 0
40069: EQUAL
40070: AND
40071: PUSH
40072: LD_VAR 0 5
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: AND
40083: IFFALSE 40189
// begin if k then
40085: LD_VAR 0 8
40089: IFFALSE 40160
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40091: LD_VAR 0 8
40095: PPUSH
40096: CALL_OW 313
40100: PUSH
40101: LD_VAR 0 11
40105: PPUSH
40106: CALL_OW 313
40110: LESS
40111: IFFALSE 40129
// ComEnterUnit ( j , k ) else
40113: LD_VAR 0 5
40117: PPUSH
40118: LD_VAR 0 8
40122: PPUSH
40123: CALL_OW 120
40127: GO 40158
// if UnitsInside ( b ) < 6 then
40129: LD_VAR 0 11
40133: PPUSH
40134: CALL_OW 313
40138: PUSH
40139: LD_INT 6
40141: LESS
40142: IFFALSE 40158
// ComEnterUnit ( j , b ) ;
40144: LD_VAR 0 5
40148: PPUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 120
// end else
40158: GO 40189
// if UnitsInside ( b ) < 6 then
40160: LD_VAR 0 11
40164: PPUSH
40165: CALL_OW 313
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: IFFALSE 40189
// ComEnterUnit ( j , b ) ;
40175: LD_VAR 0 5
40179: PPUSH
40180: LD_VAR 0 11
40184: PPUSH
40185: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40189: LD_VAR 0 5
40193: PUSH
40194: LD_VAR 0 1
40198: PPUSH
40199: LD_INT 54
40201: PUSH
40202: EMPTY
40203: LIST
40204: PPUSH
40205: CALL 11651 0 2
40209: IN
40210: PUSH
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 257
40220: PUSH
40221: LD_INT 1
40223: EQUAL
40224: AND
40225: IFFALSE 40467
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40227: LD_EXP 62
40231: PUSH
40232: LD_VAR 0 1
40236: ARRAY
40237: PUSH
40238: LD_INT 1
40240: ARRAY
40241: PUSH
40242: LD_INT 12
40244: PPUSH
40245: LD_VAR 0 1
40249: PPUSH
40250: CALL_OW 321
40254: PUSH
40255: LD_INT 2
40257: EQUAL
40258: AND
40259: IFFALSE 40307
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40261: LD_VAR 0 1
40265: PPUSH
40266: LD_INT 5
40268: PPUSH
40269: EMPTY
40270: PPUSH
40271: CALL 11734 0 3
40275: PUSH
40276: LD_EXP 62
40280: PUSH
40281: LD_VAR 0 1
40285: ARRAY
40286: PUSH
40287: LD_INT 1
40289: ARRAY
40290: LESS
40291: IFFALSE 40307
// begin SetClass ( j , class_sniper ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: LD_INT 5
40300: PPUSH
40301: CALL_OW 336
// continue ;
40305: GO 39965
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40307: LD_EXP 62
40311: PUSH
40312: LD_VAR 0 1
40316: ARRAY
40317: PUSH
40318: LD_INT 2
40320: ARRAY
40321: PUSH
40322: LD_INT 41
40324: PPUSH
40325: LD_VAR 0 1
40329: PPUSH
40330: CALL_OW 321
40334: PUSH
40335: LD_INT 2
40337: EQUAL
40338: AND
40339: IFFALSE 40387
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40341: LD_VAR 0 1
40345: PPUSH
40346: LD_INT 8
40348: PPUSH
40349: EMPTY
40350: PPUSH
40351: CALL 11734 0 3
40355: PUSH
40356: LD_EXP 62
40360: PUSH
40361: LD_VAR 0 1
40365: ARRAY
40366: PUSH
40367: LD_INT 2
40369: ARRAY
40370: LESS
40371: IFFALSE 40387
// begin SetClass ( j , class_mortar ) ;
40373: LD_VAR 0 5
40377: PPUSH
40378: LD_INT 8
40380: PPUSH
40381: CALL_OW 336
// continue ;
40385: GO 39965
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40387: LD_EXP 62
40391: PUSH
40392: LD_VAR 0 1
40396: ARRAY
40397: PUSH
40398: LD_INT 3
40400: ARRAY
40401: PUSH
40402: LD_INT 44
40404: PPUSH
40405: LD_VAR 0 1
40409: PPUSH
40410: CALL_OW 321
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: AND
40419: IFFALSE 40467
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40421: LD_VAR 0 1
40425: PPUSH
40426: LD_INT 9
40428: PPUSH
40429: EMPTY
40430: PPUSH
40431: CALL 11734 0 3
40435: PUSH
40436: LD_EXP 62
40440: PUSH
40441: LD_VAR 0 1
40445: ARRAY
40446: PUSH
40447: LD_INT 3
40449: ARRAY
40450: LESS
40451: IFFALSE 40467
// begin SetClass ( j , class_bazooker ) ;
40453: LD_VAR 0 5
40457: PPUSH
40458: LD_INT 9
40460: PPUSH
40461: CALL_OW 336
// continue ;
40465: GO 39965
// end ; end ; end ;
40467: GO 39965
40469: POP
40470: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40471: LD_INT 22
40473: PUSH
40474: LD_VAR 0 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 58
40485: PUSH
40486: EMPTY
40487: LIST
40488: PUSH
40489: LD_INT 30
40491: PUSH
40492: LD_INT 32
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: PPUSH
40504: CALL_OW 69
40508: IFFALSE 40658
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40510: LD_ADDR_VAR 0 12
40514: PUSH
40515: LD_INT 22
40517: PUSH
40518: LD_VAR 0 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 58
40529: PUSH
40530: EMPTY
40531: LIST
40532: PUSH
40533: LD_INT 30
40535: PUSH
40536: LD_INT 32
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: PPUSH
40548: CALL_OW 69
40552: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40553: LD_ADDR_VAR 0 8
40557: PUSH
40558: LD_VAR 0 13
40562: PUSH
40563: LD_EXP 68
40567: PUSH
40568: LD_VAR 0 1
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40575: LD_VAR 0 12
40579: PUSH
40580: LD_INT 1
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 2
40591: EQUAL
40592: PUSH
40593: LD_VAR 0 12
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_EXP 68
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: IN
40613: NOT
40614: AND
40615: PUSH
40616: LD_VAR 0 8
40620: AND
40621: IFFALSE 40658
// begin ComExitBuilding ( k [ 1 ] ) ;
40623: LD_VAR 0 8
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: PPUSH
40632: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40636: LD_VAR 0 8
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_VAR 0 12
40649: PUSH
40650: LD_INT 1
40652: ARRAY
40653: PPUSH
40654: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40658: LD_EXP 35
40662: PUSH
40663: LD_VAR 0 1
40667: ARRAY
40668: IFFALSE 40816
// begin if MCF_Class ( side , 4 , [ ] ) then
40670: LD_VAR 0 1
40674: PPUSH
40675: LD_INT 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL 11734 0 3
40684: IFFALSE 40814
// for j in MCF_Class ( side , 4 , [ ] ) do
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_VAR 0 1
40695: PPUSH
40696: LD_INT 4
40698: PPUSH
40699: EMPTY
40700: PPUSH
40701: CALL 11734 0 3
40705: PUSH
40706: FOR_IN
40707: IFFALSE 40812
// begin if not GetTag ( j ) = 4 then
40709: LD_VAR 0 5
40713: PPUSH
40714: CALL_OW 110
40718: PUSH
40719: LD_INT 4
40721: EQUAL
40722: NOT
40723: IFFALSE 40759
// begin SetTag ( j , 4 ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 4
40732: PPUSH
40733: CALL_OW 109
// if IsInUnit ( j ) then
40737: LD_VAR 0 5
40741: PPUSH
40742: CALL_OW 310
40746: IFFALSE 40757
// ComExitBuilding ( j ) ;
40748: LD_VAR 0 5
40752: PPUSH
40753: CALL_OW 122
// end else
40757: GO 40810
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40759: LD_VAR 0 5
40763: PPUSH
40764: LD_EXP 35
40768: PUSH
40769: LD_VAR 0 1
40773: ARRAY
40774: PUSH
40775: LD_INT 1
40777: ARRAY
40778: PPUSH
40779: CALL 98108 0 2
40783: NOT
40784: IFFALSE 40810
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_EXP 35
40795: PUSH
40796: LD_VAR 0 1
40800: ARRAY
40801: PUSH
40802: LD_INT 1
40804: ARRAY
40805: PPUSH
40806: CALL 19221 0 2
// end ;
40810: GO 40706
40812: POP
40813: POP
// end else
40814: GO 41048
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40816: LD_VAR 0 1
40820: PPUSH
40821: LD_INT 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL 11734 0 3
40830: PUSH
40831: LD_VAR 0 1
40835: PPUSH
40836: LD_INT 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL 12354 0 3
40845: AND
40846: IFFALSE 41048
// for j in MCF_Class ( side , 4 , [ ] ) do
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11734 0 3
40867: PUSH
40868: FOR_IN
40869: IFFALSE 41046
// begin if GetTag ( j ) = 4 then
40871: LD_VAR 0 5
40875: PPUSH
40876: CALL_OW 110
40880: PUSH
40881: LD_INT 4
40883: EQUAL
40884: IFFALSE 41044
// begin SetTag ( j , 0 ) ;
40886: LD_VAR 0 5
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40898: LD_VAR 0 1
40902: PPUSH
40903: CALL 11690 0 1
40907: PUSH
40908: LD_VAR 0 1
40912: PPUSH
40913: CALL 18034 0 1
40917: NOT
40918: AND
40919: IFFALSE 40944
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40921: LD_VAR 0 5
40925: PPUSH
40926: LD_VAR 0 1
40930: PPUSH
40931: CALL 11690 0 1
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: PPUSH
40940: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40944: LD_VAR 0 1
40948: PPUSH
40949: CALL 11690 0 1
40953: NOT
40954: PUSH
40955: LD_VAR 0 1
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL 11651 0 2
40974: AND
40975: IFFALSE 41044
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40977: LD_VAR 0 5
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 30
40989: PUSH
40990: LD_INT 1
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PPUSH
40997: CALL 11651 0 2
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 250
41010: PPUSH
41011: LD_VAR 0 1
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL 11651 0 2
41030: PUSH
41031: LD_INT 1
41033: ARRAY
41034: PPUSH
41035: CALL_OW 251
41039: PPUSH
41040: CALL_OW 111
// end ; end ;
41044: GO 40868
41046: POP
41047: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41048: LD_VAR 0 1
41052: PPUSH
41053: LD_INT 3
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL 11734 0 3
41062: PUSH
41063: LD_EXP 58
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: AND
41074: PUSH
41075: LD_VAR 0 1
41079: PPUSH
41080: LD_INT 6
41082: PPUSH
41083: EMPTY
41084: PPUSH
41085: CALL 12354 0 3
41089: AND
41090: IFFALSE 41621
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41092: LD_ADDR_VAR 0 6
41096: PUSH
41097: LD_EXP 58
41101: PUSH
41102: LD_VAR 0 1
41106: ARRAY
41107: PPUSH
41108: LD_INT 0
41110: PPUSH
41111: CALL_OW 517
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 1
41122: ARRAY
41123: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41124: LD_ADDR_VAR 0 7
41128: PUSH
41129: LD_EXP 58
41133: PUSH
41134: LD_VAR 0 1
41138: ARRAY
41139: PPUSH
41140: LD_INT 0
41142: PPUSH
41143: CALL_OW 517
41147: PUSH
41148: LD_INT 2
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 6
41163: PPUSH
41164: EMPTY
41165: PPUSH
41166: CALL 12354 0 3
41170: IFFALSE 41619
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 1
41181: PPUSH
41182: LD_INT 6
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL 12354 0 3
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41224
// if GetLives ( k ) = 1000 then
41195: LD_VAR 0 8
41199: PPUSH
41200: CALL_OW 256
41204: PUSH
41205: LD_INT 1000
41207: EQUAL
41208: IFFALSE 41222
// SetTag ( k , 0 ) ;
41210: LD_VAR 0 8
41214: PPUSH
41215: LD_INT 0
41217: PPUSH
41218: CALL_OW 109
41222: GO 41192
41224: POP
41225: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: LD_INT 25
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PPUSH
41244: CALL 12354 0 3
41248: IFFALSE 41312
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41250: LD_ADDR_VAR 0 8
41254: PUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: LD_INT 0
41262: PPUSH
41263: LD_INT 25
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: CALL 12354 0 3
41277: PUSH
41278: FOR_IN
41279: IFFALSE 41310
// if GetTag ( k ) = 0 then
41281: LD_VAR 0 8
41285: PPUSH
41286: CALL_OW 110
41290: PUSH
41291: LD_INT 0
41293: EQUAL
41294: IFFALSE 41308
// begin SetTag ( k , 8 ) ;
41296: LD_VAR 0 8
41300: PPUSH
41301: LD_INT 8
41303: PPUSH
41304: CALL_OW 109
// end ;
41308: GO 41278
41310: POP
41311: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41312: LD_VAR 0 1
41316: PPUSH
41317: LD_INT 6
41319: PPUSH
41320: LD_INT 92
41322: PUSH
41323: LD_VAR 0 6
41327: PUSH
41328: LD_VAR 0 7
41332: PUSH
41333: LD_INT 10
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL 12354 0 3
41346: IFFALSE 41470
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_VAR 0 4
41357: PPUSH
41358: LD_INT 6
41360: PPUSH
41361: LD_INT 92
41363: PUSH
41364: LD_VAR 0 6
41368: PUSH
41369: LD_VAR 0 7
41373: PUSH
41374: LD_INT 10
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 12354 0 3
41387: PUSH
41388: FOR_IN
41389: IFFALSE 41468
// begin if not HasTask ( j ) and GetDriver ( j ) then
41391: LD_VAR 0 5
41395: PPUSH
41396: CALL_OW 314
41400: NOT
41401: PUSH
41402: LD_VAR 0 5
41406: PPUSH
41407: CALL 31773 0 1
41411: AND
41412: IFFALSE 41466
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41414: LD_VAR 0 5
41418: PPUSH
41419: CALL 31773 0 1
41423: PPUSH
41424: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41428: LD_VAR 0 5
41432: PPUSH
41433: CALL 31773 0 1
41437: PPUSH
41438: LD_VAR 0 5
41442: PPUSH
41443: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41447: LD_VAR 0 5
41451: PPUSH
41452: CALL 31773 0 1
41456: PPUSH
41457: LD_VAR 0 5
41461: PPUSH
41462: CALL_OW 180
// end ; end ;
41466: GO 41388
41468: POP
41469: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41470: LD_VAR 0 1
41474: PPUSH
41475: LD_INT 6
41477: PPUSH
41478: LD_INT 92
41480: PUSH
41481: LD_VAR 0 6
41485: PUSH
41486: LD_VAR 0 7
41490: PUSH
41491: LD_INT 10
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL 12354 0 3
41504: PUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 8
41512: PPUSH
41513: EMPTY
41514: PPUSH
41515: CALL 12354 0 3
41519: AND
41520: IFFALSE 41619
// for j in MCF_Tag ( side , 8 , [ ] ) do
41522: LD_ADDR_VAR 0 5
41526: PUSH
41527: LD_VAR 0 1
41531: PPUSH
41532: LD_INT 8
41534: PPUSH
41535: EMPTY
41536: PPUSH
41537: CALL 12354 0 3
41541: PUSH
41542: FOR_IN
41543: IFFALSE 41617
// begin if IsInUnit ( j ) then
41545: LD_VAR 0 5
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41567
// ComExitBuilding ( j ) else
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 122
41565: GO 41615
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41567: LD_VAR 0 5
41571: PPUSH
41572: LD_VAR 0 1
41576: PPUSH
41577: LD_INT 6
41579: PPUSH
41580: LD_INT 92
41582: PUSH
41583: LD_VAR 0 6
41587: PUSH
41588: LD_VAR 0 7
41592: PUSH
41593: LD_INT 10
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: PPUSH
41602: CALL 12354 0 3
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: CALL_OW 129
// end ;
41615: GO 41542
41617: POP
41618: POP
// end ; end else
41619: GO 41676
// if MCF_Tag ( side , 8 , [ ] ) then
41621: LD_VAR 0 1
41625: PPUSH
41626: LD_INT 8
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL 12354 0 3
41635: IFFALSE 41676
// for k in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 8
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12354 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41674
// SetTag ( k , 0 ) ;
41660: LD_VAR 0 8
41664: PPUSH
41665: LD_INT 0
41667: PPUSH
41668: CALL_OW 109
41672: GO 41657
41674: POP
41675: POP
// end ; end_of_file
41676: LD_VAR 0 3
41680: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41681: LD_INT 0
41683: PPUSH
// MREG_Game := [ ] ;
41684: LD_ADDR_EXP 33
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_Crates := [ ] ;
41691: LD_ADDR_EXP 34
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_Heal := [ ] ;
41698: LD_ADDR_EXP 35
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_Tame := [ ] ;
41705: LD_ADDR_EXP 37
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41712: LD_ADDR_EXP 38
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41719: LD_ADDR_EXP 39
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_LabList := [ ] ;
41726: LD_ADDR_EXP 40
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41733: LD_ADDR_EXP 41
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41740: LD_ADDR_EXP 42
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41747: LD_ADDR_EXP 43
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41754: LD_ADDR_EXP 44
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_Status := [ ] ;
41761: LD_ADDR_EXP 45
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41768: LD_ADDR_EXP 46
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41775: LD_ADDR_EXP 47
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41782: LD_ADDR_EXP 48
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41789: LD_ADDR_EXP 49
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41796: LD_ADDR_EXP 50
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41803: LD_ADDR_EXP 51
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41810: LD_ADDR_EXP 52
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41817: LD_ADDR_EXP 53
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41824: LD_ADDR_EXP 54
41828: PUSH
41829: EMPTY
41830: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41831: LD_ADDR_EXP 55
41835: PUSH
41836: EMPTY
41837: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41838: LD_ADDR_EXP 56
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41845: LD_ADDR_EXP 57
41849: PUSH
41850: EMPTY
41851: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41852: LD_ADDR_EXP 61
41856: PUSH
41857: EMPTY
41858: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41859: LD_ADDR_EXP 62
41863: PUSH
41864: EMPTY
41865: ST_TO_ADDR
// MREG_Parking := [ ] ;
41866: LD_ADDR_EXP 58
41870: PUSH
41871: EMPTY
41872: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41873: LD_ADDR_EXP 59
41877: PUSH
41878: EMPTY
41879: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41880: LD_ADDR_EXP 63
41884: PUSH
41885: EMPTY
41886: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41887: LD_ADDR_EXP 64
41891: PUSH
41892: EMPTY
41893: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41894: LD_ADDR_EXP 65
41898: PUSH
41899: EMPTY
41900: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41901: LD_ADDR_EXP 67
41905: PUSH
41906: EMPTY
41907: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41908: LD_ADDR_EXP 68
41912: PUSH
41913: EMPTY
41914: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41915: LD_ADDR_EXP 69
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41922: LD_ADDR_EXP 71
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41929: LD_ADDR_EXP 70
41933: PUSH
41934: EMPTY
41935: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41936: LD_ADDR_EXP 72
41940: PUSH
41941: LD_INT 300
41943: PUSH
41944: LD_INT 100
41946: PUSH
41947: LD_INT 25
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 1
41959: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41960: LD_INT 0
41962: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41963: LD_VAR 0 2
41967: PUSH
41968: LD_VAR 0 3
41972: PUSH
41973: LD_VAR 0 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: LIST
41982: PUSH
41983: LD_VAR 0 1
41987: IN
41988: IFFALSE 42002
// result := mreg_list else
41990: LD_ADDR_VAR 0 5
41994: PUSH
41995: LD_VAR 0 1
41999: ST_TO_ADDR
42000: GO 42036
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42002: LD_ADDR_VAR 0 1
42006: PUSH
42007: LD_VAR 0 1
42011: PUSH
42012: LD_VAR 0 2
42016: PUSH
42017: LD_VAR 0 3
42021: PUSH
42022: LD_VAR 0 4
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: ADD
42035: ST_TO_ADDR
// result := mreg_list ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_VAR 0 1
42045: ST_TO_ADDR
// end ;
42046: LD_VAR 0 5
42050: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42051: LD_INT 0
42053: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42054: LD_VAR 0 2
42058: PUSH
42059: LD_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PUSH
42074: LD_VAR 0 1
42078: IN
42079: IFFALSE 42117
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_VAR 0 1
42090: PUSH
42091: LD_VAR 0 2
42095: PUSH
42096: LD_VAR 0 3
42100: PUSH
42101: LD_VAR 0 4
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: DIFF
42114: ST_TO_ADDR
42115: GO 42127
// result := mreg_list ;
42117: LD_ADDR_VAR 0 5
42121: PUSH
42122: LD_VAR 0 1
42126: ST_TO_ADDR
// end ;
42127: LD_VAR 0 5
42131: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42132: LD_INT 0
42134: PPUSH
42135: PPUSH
42136: PPUSH
// for j = 1 to 8 do
42137: LD_ADDR_VAR 0 3
42141: PUSH
42142: DOUBLE
42143: LD_INT 1
42145: DEC
42146: ST_TO_ADDR
42147: LD_INT 8
42149: PUSH
42150: FOR_TO
42151: IFFALSE 42992
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42153: LD_VAR 0 3
42157: PPUSH
42158: LD_INT 51
42160: PUSH
42161: EMPTY
42162: LIST
42163: PPUSH
42164: CALL 11651 0 2
42168: PUSH
42169: LD_OWVAR 2
42173: PUSH
42174: LD_VAR 0 3
42178: EQUAL
42179: NOT
42180: AND
42181: IFFALSE 42199
// MREG_SidesList := MREG_SidesList ^ 1 else
42183: LD_ADDR_EXP 39
42187: PUSH
42188: LD_EXP 39
42192: PUSH
42193: LD_INT 1
42195: ADD
42196: ST_TO_ADDR
42197: GO 42213
// MREG_SidesList := MREG_SidesList ^ 0 ;
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 0
42211: ADD
42212: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42213: LD_VAR 0 3
42217: PPUSH
42218: LD_INT 2
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 34
42233: PUSH
42234: LD_INT 32
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 34
42243: PUSH
42244: LD_INT 51
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11952 0 2
42264: IFFALSE 42365
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42266: LD_ADDR_VAR 0 2
42270: PUSH
42271: LD_VAR 0 3
42275: PPUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 34
42281: PUSH
42282: LD_INT 12
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 34
42291: PUSH
42292: LD_INT 32
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 34
42301: PUSH
42302: LD_INT 51
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: CALL 11952 0 2
42322: PUSH
42323: FOR_IN
42324: IFFALSE 42363
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42326: LD_ADDR_EXP 41
42330: PUSH
42331: LD_EXP 41
42335: PPUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_VAR 0 2
42345: PPUSH
42346: LD_VAR 0 2
42350: PPUSH
42351: CALL_OW 264
42355: PPUSH
42356: CALL 41960 0 4
42360: ST_TO_ADDR
42361: GO 42323
42363: POP
42364: POP
// if MCF_Class ( j , 4 , [ ] ) then
42365: LD_VAR 0 3
42369: PPUSH
42370: LD_INT 4
42372: PPUSH
42373: EMPTY
42374: PPUSH
42375: CALL 11734 0 3
42379: IFFALSE 42412
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42381: LD_ADDR_EXP 54
42385: PUSH
42386: LD_EXP 54
42390: PUSH
42391: LD_VAR 0 3
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: EMPTY
42400: PPUSH
42401: CALL 11734 0 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: ADD
42409: ST_TO_ADDR
42410: GO 42429
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42412: LD_ADDR_EXP 54
42416: PUSH
42417: LD_EXP 54
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: ADD
42428: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42429: LD_VAR 0 3
42433: PPUSH
42434: LD_INT 3
42436: PPUSH
42437: EMPTY
42438: PPUSH
42439: CALL 11734 0 3
42443: IFFALSE 42476
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42445: LD_ADDR_EXP 55
42449: PUSH
42450: LD_EXP 55
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_INT 3
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL 11734 0 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: ADD
42473: ST_TO_ADDR
42474: GO 42493
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42476: LD_ADDR_EXP 55
42480: PUSH
42481: LD_EXP 55
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: ADD
42492: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42493: LD_VAR 0 3
42497: PPUSH
42498: LD_INT 1
42500: PPUSH
42501: EMPTY
42502: PPUSH
42503: CALL 11734 0 3
42507: IFFALSE 42540
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42509: LD_ADDR_EXP 56
42513: PUSH
42514: LD_EXP 56
42518: PUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_INT 1
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 11734 0 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: ADD
42537: ST_TO_ADDR
42538: GO 42557
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42540: LD_ADDR_EXP 56
42544: PUSH
42545: LD_EXP 56
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: ADD
42556: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_INT 2
42564: PPUSH
42565: EMPTY
42566: PPUSH
42567: CALL 11734 0 3
42571: IFFALSE 42604
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42573: LD_ADDR_EXP 57
42577: PUSH
42578: LD_EXP 57
42582: PUSH
42583: LD_VAR 0 3
42587: PPUSH
42588: LD_INT 2
42590: PPUSH
42591: EMPTY
42592: PPUSH
42593: CALL 11734 0 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: ADD
42601: ST_TO_ADDR
42602: GO 42621
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42604: LD_ADDR_EXP 57
42608: PUSH
42609: LD_EXP 57
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: EMPTY
42618: LIST
42619: ADD
42620: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42621: LD_ADDR_EXP 47
42625: PUSH
42626: LD_EXP 47
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: ADD
42637: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42638: LD_ADDR_EXP 35
42642: PUSH
42643: LD_EXP 35
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: ADD
42654: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42655: LD_ADDR_EXP 37
42659: PUSH
42660: LD_EXP 37
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42672: LD_ADDR_EXP 58
42676: PUSH
42677: LD_EXP 58
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: EMPTY
42686: LIST
42687: ADD
42688: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42689: LD_ADDR_EXP 59
42693: PUSH
42694: LD_EXP 59
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: ADD
42705: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42706: LD_ADDR_EXP 51
42710: PUSH
42711: LD_EXP 51
42715: PUSH
42716: LD_INT 0
42718: PUSH
42719: EMPTY
42720: LIST
42721: ADD
42722: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42723: LD_ADDR_EXP 38
42727: PUSH
42728: LD_EXP 38
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: LD_INT 0
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42755: LD_ADDR_EXP 60
42759: PUSH
42760: LD_EXP 60
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: ADD
42777: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42778: LD_ADDR_EXP 61
42782: PUSH
42783: LD_EXP 61
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: EMPTY
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42798: LD_ADDR_EXP 42
42802: PUSH
42803: LD_EXP 42
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42815: LD_ADDR_EXP 63
42819: PUSH
42820: LD_EXP 63
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42832: LD_ADDR_EXP 64
42836: PUSH
42837: LD_EXP 64
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: ADD
42848: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42849: LD_ADDR_EXP 65
42853: PUSH
42854: LD_EXP 65
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: ADD
42865: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42866: LD_ADDR_EXP 66
42870: PUSH
42871: LD_EXP 66
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42883: LD_ADDR_EXP 67
42887: PUSH
42888: LD_EXP 67
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: ADD
42899: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42900: LD_ADDR_EXP 68
42904: PUSH
42905: LD_EXP 68
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: ADD
42916: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42917: LD_ADDR_EXP 69
42921: PUSH
42922: LD_EXP 69
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: EMPTY
42931: LIST
42932: ADD
42933: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42934: LD_ADDR_EXP 71
42938: PUSH
42939: LD_EXP 71
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42951: LD_ADDR_EXP 70
42955: PUSH
42956: LD_EXP 70
42960: PUSH
42961: LD_INT 0
42963: ADD
42964: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42965: LD_ADDR_EXP 62
42969: PUSH
42970: LD_EXP 62
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ADD
42989: ST_TO_ADDR
// end ;
42990: GO 42150
42992: POP
42993: POP
// end ;
42994: LD_VAR 0 1
42998: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42999: LD_INT 0
43001: PPUSH
43002: PPUSH
43003: PPUSH
// m := false ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_INT 0
43011: ST_TO_ADDR
// for i = 1 to mreg do
43012: LD_ADDR_VAR 0 4
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 2
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43064
// if mreg [ i ] [ 1 ] = side then
43030: LD_VAR 0 2
43034: PUSH
43035: LD_VAR 0 4
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_VAR 0 1
43049: EQUAL
43050: IFFALSE 43062
// begin m := true ;
43052: LD_ADDR_VAR 0 5
43056: PUSH
43057: LD_INT 1
43059: ST_TO_ADDR
// break ;
43060: GO 43064
// end ;
43062: GO 43027
43064: POP
43065: POP
// result := m ;
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// m := 0 ;
43086: LD_ADDR_VAR 0 5
43090: PUSH
43091: LD_INT 0
43093: ST_TO_ADDR
// for i = 1 to mreg do
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_VAR 0 2
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43150
// if mreg [ i ] [ 1 ] = side then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_VAR 0 4
43121: ARRAY
43122: PUSH
43123: LD_INT 1
43125: ARRAY
43126: PUSH
43127: LD_VAR 0 1
43131: EQUAL
43132: IFFALSE 43148
// begin m := m + 1 ;
43134: LD_ADDR_VAR 0 5
43138: PUSH
43139: LD_VAR 0 5
43143: PUSH
43144: LD_INT 1
43146: PLUS
43147: ST_TO_ADDR
// end ;
43148: GO 43109
43150: POP
43151: POP
// result := m ;
43152: LD_ADDR_VAR 0 3
43156: PUSH
43157: LD_VAR 0 5
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
// result := 0 ;
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: LD_INT 0
43178: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43179: LD_ADDR_VAR 0 4
43183: PUSH
43184: DOUBLE
43185: LD_INT 1
43187: DEC
43188: ST_TO_ADDR
43189: LD_EXP 53
43193: PUSH
43194: FOR_TO
43195: IFFALSE 43257
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43197: LD_EXP 53
43201: PUSH
43202: LD_VAR 0 4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PUSH
43212: LD_VAR 0 1
43216: EQUAL
43217: PUSH
43218: LD_EXP 53
43222: PUSH
43223: LD_VAR 0 4
43227: ARRAY
43228: PUSH
43229: LD_INT 2
43231: ARRAY
43232: PUSH
43233: LD_VAR 0 2
43237: EQUAL
43238: AND
43239: IFFALSE 43255
// begin result := result + 1 ;
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 3
43250: PUSH
43251: LD_INT 1
43253: PLUS
43254: ST_TO_ADDR
// end ;
43255: GO 43194
43257: POP
43258: POP
// end ; end_of_file end_of_file
43259: LD_VAR 0 3
43263: RET
// export globalGameSaveCounter ; every 0 0$1 do
43264: GO 43266
43266: DISABLE
// begin enable ;
43267: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43268: LD_STRING updateTimer(
43270: PUSH
43271: LD_OWVAR 1
43275: STR
43276: PUSH
43277: LD_STRING );
43279: STR
43280: PPUSH
43281: CALL_OW 559
// end ;
43285: END
// every 0 0$1 do
43286: GO 43288
43288: DISABLE
// begin globalGameSaveCounter := 0 ;
43289: LD_ADDR_EXP 73
43293: PUSH
43294: LD_INT 0
43296: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
43297: LD_STRING setGameSaveCounter(0)
43299: PPUSH
43300: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
43304: LD_STRING initStreamRollete();
43306: PPUSH
43307: CALL_OW 559
// InitStreamMode ;
43311: CALL 44637 0 0
// DefineStreamItems ( false ) ;
43315: LD_INT 0
43317: PPUSH
43318: CALL 45101 0 1
// end ;
43322: END
// export function SOS_MapStart ( ) ; begin
43323: LD_INT 0
43325: PPUSH
// if streamModeActive then
43326: LD_EXP 74
43330: IFFALSE 43339
// DefineStreamItems ( true ) ;
43332: LD_INT 1
43334: PPUSH
43335: CALL 45101 0 1
// UpdateLuaVariables ( ) ;
43339: CALL 43356 0 0
// UpdateFactoryWaypoints ( ) ;
43343: CALL 57962 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43347: CALL 58219 0 0
// end ;
43351: LD_VAR 0 1
43355: RET
// function UpdateLuaVariables ( ) ; begin
43356: LD_INT 0
43358: PPUSH
// if globalGameSaveCounter then
43359: LD_EXP 73
43363: IFFALSE 43397
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
43365: LD_ADDR_EXP 73
43369: PUSH
43370: LD_EXP 73
43374: PPUSH
43375: CALL 102176 0 1
43379: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
43380: LD_STRING setGameSaveCounter(
43382: PUSH
43383: LD_EXP 73
43387: STR
43388: PUSH
43389: LD_STRING )
43391: STR
43392: PPUSH
43393: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
43397: LD_STRING setGameDifficulty(
43399: PUSH
43400: LD_OWVAR 67
43404: STR
43405: PUSH
43406: LD_STRING )
43408: STR
43409: PPUSH
43410: CALL_OW 559
// end ;
43414: LD_VAR 0 1
43418: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43419: LD_INT 0
43421: PPUSH
// if p2 = stream_mode then
43422: LD_VAR 0 2
43426: PUSH
43427: LD_INT 100
43429: EQUAL
43430: IFFALSE 44433
// begin if not StreamModeActive then
43432: LD_EXP 74
43436: NOT
43437: IFFALSE 43447
// StreamModeActive := true ;
43439: LD_ADDR_EXP 74
43443: PUSH
43444: LD_INT 1
43446: ST_TO_ADDR
// if p3 = 0 then
43447: LD_VAR 0 3
43451: PUSH
43452: LD_INT 0
43454: EQUAL
43455: IFFALSE 43461
// InitStreamMode ;
43457: CALL 44637 0 0
// if p3 = 1 then
43461: LD_VAR 0 3
43465: PUSH
43466: LD_INT 1
43468: EQUAL
43469: IFFALSE 43479
// sRocket := true ;
43471: LD_ADDR_EXP 79
43475: PUSH
43476: LD_INT 1
43478: ST_TO_ADDR
// if p3 = 2 then
43479: LD_VAR 0 3
43483: PUSH
43484: LD_INT 2
43486: EQUAL
43487: IFFALSE 43497
// sSpeed := true ;
43489: LD_ADDR_EXP 78
43493: PUSH
43494: LD_INT 1
43496: ST_TO_ADDR
// if p3 = 3 then
43497: LD_VAR 0 3
43501: PUSH
43502: LD_INT 3
43504: EQUAL
43505: IFFALSE 43515
// sEngine := true ;
43507: LD_ADDR_EXP 80
43511: PUSH
43512: LD_INT 1
43514: ST_TO_ADDR
// if p3 = 4 then
43515: LD_VAR 0 3
43519: PUSH
43520: LD_INT 4
43522: EQUAL
43523: IFFALSE 43533
// sSpec := true ;
43525: LD_ADDR_EXP 77
43529: PUSH
43530: LD_INT 1
43532: ST_TO_ADDR
// if p3 = 5 then
43533: LD_VAR 0 3
43537: PUSH
43538: LD_INT 5
43540: EQUAL
43541: IFFALSE 43551
// sLevel := true ;
43543: LD_ADDR_EXP 81
43547: PUSH
43548: LD_INT 1
43550: ST_TO_ADDR
// if p3 = 6 then
43551: LD_VAR 0 3
43555: PUSH
43556: LD_INT 6
43558: EQUAL
43559: IFFALSE 43569
// sArmoury := true ;
43561: LD_ADDR_EXP 82
43565: PUSH
43566: LD_INT 1
43568: ST_TO_ADDR
// if p3 = 7 then
43569: LD_VAR 0 3
43573: PUSH
43574: LD_INT 7
43576: EQUAL
43577: IFFALSE 43587
// sRadar := true ;
43579: LD_ADDR_EXP 83
43583: PUSH
43584: LD_INT 1
43586: ST_TO_ADDR
// if p3 = 8 then
43587: LD_VAR 0 3
43591: PUSH
43592: LD_INT 8
43594: EQUAL
43595: IFFALSE 43605
// sBunker := true ;
43597: LD_ADDR_EXP 84
43601: PUSH
43602: LD_INT 1
43604: ST_TO_ADDR
// if p3 = 9 then
43605: LD_VAR 0 3
43609: PUSH
43610: LD_INT 9
43612: EQUAL
43613: IFFALSE 43623
// sHack := true ;
43615: LD_ADDR_EXP 85
43619: PUSH
43620: LD_INT 1
43622: ST_TO_ADDR
// if p3 = 10 then
43623: LD_VAR 0 3
43627: PUSH
43628: LD_INT 10
43630: EQUAL
43631: IFFALSE 43641
// sFire := true ;
43633: LD_ADDR_EXP 86
43637: PUSH
43638: LD_INT 1
43640: ST_TO_ADDR
// if p3 = 11 then
43641: LD_VAR 0 3
43645: PUSH
43646: LD_INT 11
43648: EQUAL
43649: IFFALSE 43659
// sRefresh := true ;
43651: LD_ADDR_EXP 87
43655: PUSH
43656: LD_INT 1
43658: ST_TO_ADDR
// if p3 = 12 then
43659: LD_VAR 0 3
43663: PUSH
43664: LD_INT 12
43666: EQUAL
43667: IFFALSE 43677
// sExp := true ;
43669: LD_ADDR_EXP 88
43673: PUSH
43674: LD_INT 1
43676: ST_TO_ADDR
// if p3 = 13 then
43677: LD_VAR 0 3
43681: PUSH
43682: LD_INT 13
43684: EQUAL
43685: IFFALSE 43695
// sDepot := true ;
43687: LD_ADDR_EXP 89
43691: PUSH
43692: LD_INT 1
43694: ST_TO_ADDR
// if p3 = 14 then
43695: LD_VAR 0 3
43699: PUSH
43700: LD_INT 14
43702: EQUAL
43703: IFFALSE 43713
// sFlag := true ;
43705: LD_ADDR_EXP 90
43709: PUSH
43710: LD_INT 1
43712: ST_TO_ADDR
// if p3 = 15 then
43713: LD_VAR 0 3
43717: PUSH
43718: LD_INT 15
43720: EQUAL
43721: IFFALSE 43731
// sKamikadze := true ;
43723: LD_ADDR_EXP 98
43727: PUSH
43728: LD_INT 1
43730: ST_TO_ADDR
// if p3 = 16 then
43731: LD_VAR 0 3
43735: PUSH
43736: LD_INT 16
43738: EQUAL
43739: IFFALSE 43749
// sTroll := true ;
43741: LD_ADDR_EXP 99
43745: PUSH
43746: LD_INT 1
43748: ST_TO_ADDR
// if p3 = 17 then
43749: LD_VAR 0 3
43753: PUSH
43754: LD_INT 17
43756: EQUAL
43757: IFFALSE 43767
// sSlow := true ;
43759: LD_ADDR_EXP 100
43763: PUSH
43764: LD_INT 1
43766: ST_TO_ADDR
// if p3 = 18 then
43767: LD_VAR 0 3
43771: PUSH
43772: LD_INT 18
43774: EQUAL
43775: IFFALSE 43785
// sLack := true ;
43777: LD_ADDR_EXP 101
43781: PUSH
43782: LD_INT 1
43784: ST_TO_ADDR
// if p3 = 19 then
43785: LD_VAR 0 3
43789: PUSH
43790: LD_INT 19
43792: EQUAL
43793: IFFALSE 43803
// sTank := true ;
43795: LD_ADDR_EXP 103
43799: PUSH
43800: LD_INT 1
43802: ST_TO_ADDR
// if p3 = 20 then
43803: LD_VAR 0 3
43807: PUSH
43808: LD_INT 20
43810: EQUAL
43811: IFFALSE 43821
// sRemote := true ;
43813: LD_ADDR_EXP 104
43817: PUSH
43818: LD_INT 1
43820: ST_TO_ADDR
// if p3 = 21 then
43821: LD_VAR 0 3
43825: PUSH
43826: LD_INT 21
43828: EQUAL
43829: IFFALSE 43839
// sPowell := true ;
43831: LD_ADDR_EXP 105
43835: PUSH
43836: LD_INT 1
43838: ST_TO_ADDR
// if p3 = 22 then
43839: LD_VAR 0 3
43843: PUSH
43844: LD_INT 22
43846: EQUAL
43847: IFFALSE 43857
// sTeleport := true ;
43849: LD_ADDR_EXP 108
43853: PUSH
43854: LD_INT 1
43856: ST_TO_ADDR
// if p3 = 23 then
43857: LD_VAR 0 3
43861: PUSH
43862: LD_INT 23
43864: EQUAL
43865: IFFALSE 43875
// sOilTower := true ;
43867: LD_ADDR_EXP 110
43871: PUSH
43872: LD_INT 1
43874: ST_TO_ADDR
// if p3 = 24 then
43875: LD_VAR 0 3
43879: PUSH
43880: LD_INT 24
43882: EQUAL
43883: IFFALSE 43893
// sShovel := true ;
43885: LD_ADDR_EXP 111
43889: PUSH
43890: LD_INT 1
43892: ST_TO_ADDR
// if p3 = 25 then
43893: LD_VAR 0 3
43897: PUSH
43898: LD_INT 25
43900: EQUAL
43901: IFFALSE 43911
// sSheik := true ;
43903: LD_ADDR_EXP 112
43907: PUSH
43908: LD_INT 1
43910: ST_TO_ADDR
// if p3 = 26 then
43911: LD_VAR 0 3
43915: PUSH
43916: LD_INT 26
43918: EQUAL
43919: IFFALSE 43929
// sEarthquake := true ;
43921: LD_ADDR_EXP 114
43925: PUSH
43926: LD_INT 1
43928: ST_TO_ADDR
// if p3 = 27 then
43929: LD_VAR 0 3
43933: PUSH
43934: LD_INT 27
43936: EQUAL
43937: IFFALSE 43947
// sAI := true ;
43939: LD_ADDR_EXP 115
43943: PUSH
43944: LD_INT 1
43946: ST_TO_ADDR
// if p3 = 28 then
43947: LD_VAR 0 3
43951: PUSH
43952: LD_INT 28
43954: EQUAL
43955: IFFALSE 43965
// sCargo := true ;
43957: LD_ADDR_EXP 118
43961: PUSH
43962: LD_INT 1
43964: ST_TO_ADDR
// if p3 = 29 then
43965: LD_VAR 0 3
43969: PUSH
43970: LD_INT 29
43972: EQUAL
43973: IFFALSE 43983
// sDLaser := true ;
43975: LD_ADDR_EXP 119
43979: PUSH
43980: LD_INT 1
43982: ST_TO_ADDR
// if p3 = 30 then
43983: LD_VAR 0 3
43987: PUSH
43988: LD_INT 30
43990: EQUAL
43991: IFFALSE 44001
// sExchange := true ;
43993: LD_ADDR_EXP 120
43997: PUSH
43998: LD_INT 1
44000: ST_TO_ADDR
// if p3 = 31 then
44001: LD_VAR 0 3
44005: PUSH
44006: LD_INT 31
44008: EQUAL
44009: IFFALSE 44019
// sFac := true ;
44011: LD_ADDR_EXP 121
44015: PUSH
44016: LD_INT 1
44018: ST_TO_ADDR
// if p3 = 32 then
44019: LD_VAR 0 3
44023: PUSH
44024: LD_INT 32
44026: EQUAL
44027: IFFALSE 44037
// sPower := true ;
44029: LD_ADDR_EXP 122
44033: PUSH
44034: LD_INT 1
44036: ST_TO_ADDR
// if p3 = 33 then
44037: LD_VAR 0 3
44041: PUSH
44042: LD_INT 33
44044: EQUAL
44045: IFFALSE 44055
// sRandom := true ;
44047: LD_ADDR_EXP 123
44051: PUSH
44052: LD_INT 1
44054: ST_TO_ADDR
// if p3 = 34 then
44055: LD_VAR 0 3
44059: PUSH
44060: LD_INT 34
44062: EQUAL
44063: IFFALSE 44073
// sShield := true ;
44065: LD_ADDR_EXP 124
44069: PUSH
44070: LD_INT 1
44072: ST_TO_ADDR
// if p3 = 35 then
44073: LD_VAR 0 3
44077: PUSH
44078: LD_INT 35
44080: EQUAL
44081: IFFALSE 44091
// sTime := true ;
44083: LD_ADDR_EXP 125
44087: PUSH
44088: LD_INT 1
44090: ST_TO_ADDR
// if p3 = 36 then
44091: LD_VAR 0 3
44095: PUSH
44096: LD_INT 36
44098: EQUAL
44099: IFFALSE 44109
// sTools := true ;
44101: LD_ADDR_EXP 126
44105: PUSH
44106: LD_INT 1
44108: ST_TO_ADDR
// if p3 = 101 then
44109: LD_VAR 0 3
44113: PUSH
44114: LD_INT 101
44116: EQUAL
44117: IFFALSE 44127
// sSold := true ;
44119: LD_ADDR_EXP 91
44123: PUSH
44124: LD_INT 1
44126: ST_TO_ADDR
// if p3 = 102 then
44127: LD_VAR 0 3
44131: PUSH
44132: LD_INT 102
44134: EQUAL
44135: IFFALSE 44145
// sDiff := true ;
44137: LD_ADDR_EXP 92
44141: PUSH
44142: LD_INT 1
44144: ST_TO_ADDR
// if p3 = 103 then
44145: LD_VAR 0 3
44149: PUSH
44150: LD_INT 103
44152: EQUAL
44153: IFFALSE 44163
// sFog := true ;
44155: LD_ADDR_EXP 95
44159: PUSH
44160: LD_INT 1
44162: ST_TO_ADDR
// if p3 = 104 then
44163: LD_VAR 0 3
44167: PUSH
44168: LD_INT 104
44170: EQUAL
44171: IFFALSE 44181
// sReset := true ;
44173: LD_ADDR_EXP 96
44177: PUSH
44178: LD_INT 1
44180: ST_TO_ADDR
// if p3 = 105 then
44181: LD_VAR 0 3
44185: PUSH
44186: LD_INT 105
44188: EQUAL
44189: IFFALSE 44199
// sSun := true ;
44191: LD_ADDR_EXP 97
44195: PUSH
44196: LD_INT 1
44198: ST_TO_ADDR
// if p3 = 106 then
44199: LD_VAR 0 3
44203: PUSH
44204: LD_INT 106
44206: EQUAL
44207: IFFALSE 44217
// sTiger := true ;
44209: LD_ADDR_EXP 93
44213: PUSH
44214: LD_INT 1
44216: ST_TO_ADDR
// if p3 = 107 then
44217: LD_VAR 0 3
44221: PUSH
44222: LD_INT 107
44224: EQUAL
44225: IFFALSE 44235
// sBomb := true ;
44227: LD_ADDR_EXP 94
44231: PUSH
44232: LD_INT 1
44234: ST_TO_ADDR
// if p3 = 108 then
44235: LD_VAR 0 3
44239: PUSH
44240: LD_INT 108
44242: EQUAL
44243: IFFALSE 44253
// sWound := true ;
44245: LD_ADDR_EXP 102
44249: PUSH
44250: LD_INT 1
44252: ST_TO_ADDR
// if p3 = 109 then
44253: LD_VAR 0 3
44257: PUSH
44258: LD_INT 109
44260: EQUAL
44261: IFFALSE 44271
// sBetray := true ;
44263: LD_ADDR_EXP 106
44267: PUSH
44268: LD_INT 1
44270: ST_TO_ADDR
// if p3 = 110 then
44271: LD_VAR 0 3
44275: PUSH
44276: LD_INT 110
44278: EQUAL
44279: IFFALSE 44289
// sContamin := true ;
44281: LD_ADDR_EXP 107
44285: PUSH
44286: LD_INT 1
44288: ST_TO_ADDR
// if p3 = 111 then
44289: LD_VAR 0 3
44293: PUSH
44294: LD_INT 111
44296: EQUAL
44297: IFFALSE 44307
// sOil := true ;
44299: LD_ADDR_EXP 109
44303: PUSH
44304: LD_INT 1
44306: ST_TO_ADDR
// if p3 = 112 then
44307: LD_VAR 0 3
44311: PUSH
44312: LD_INT 112
44314: EQUAL
44315: IFFALSE 44325
// sStu := true ;
44317: LD_ADDR_EXP 113
44321: PUSH
44322: LD_INT 1
44324: ST_TO_ADDR
// if p3 = 113 then
44325: LD_VAR 0 3
44329: PUSH
44330: LD_INT 113
44332: EQUAL
44333: IFFALSE 44343
// sBazooka := true ;
44335: LD_ADDR_EXP 116
44339: PUSH
44340: LD_INT 1
44342: ST_TO_ADDR
// if p3 = 114 then
44343: LD_VAR 0 3
44347: PUSH
44348: LD_INT 114
44350: EQUAL
44351: IFFALSE 44361
// sMortar := true ;
44353: LD_ADDR_EXP 117
44357: PUSH
44358: LD_INT 1
44360: ST_TO_ADDR
// if p3 = 115 then
44361: LD_VAR 0 3
44365: PUSH
44366: LD_INT 115
44368: EQUAL
44369: IFFALSE 44379
// sRanger := true ;
44371: LD_ADDR_EXP 127
44375: PUSH
44376: LD_INT 1
44378: ST_TO_ADDR
// if p3 = 116 then
44379: LD_VAR 0 3
44383: PUSH
44384: LD_INT 116
44386: EQUAL
44387: IFFALSE 44397
// sComputer := true ;
44389: LD_ADDR_EXP 128
44393: PUSH
44394: LD_INT 1
44396: ST_TO_ADDR
// if p3 = 117 then
44397: LD_VAR 0 3
44401: PUSH
44402: LD_INT 117
44404: EQUAL
44405: IFFALSE 44415
// s30 := true ;
44407: LD_ADDR_EXP 129
44411: PUSH
44412: LD_INT 1
44414: ST_TO_ADDR
// if p3 = 118 then
44415: LD_VAR 0 3
44419: PUSH
44420: LD_INT 118
44422: EQUAL
44423: IFFALSE 44433
// s60 := true ;
44425: LD_ADDR_EXP 130
44429: PUSH
44430: LD_INT 1
44432: ST_TO_ADDR
// end ; if p2 = hack_mode then
44433: LD_VAR 0 2
44437: PUSH
44438: LD_INT 101
44440: EQUAL
44441: IFFALSE 44569
// begin case p3 of 1 :
44443: LD_VAR 0 3
44447: PUSH
44448: LD_INT 1
44450: DOUBLE
44451: EQUAL
44452: IFTRUE 44456
44454: GO 44463
44456: POP
// hHackUnlimitedResources ; 2 :
44457: CALL 56708 0 0
44461: GO 44569
44463: LD_INT 2
44465: DOUBLE
44466: EQUAL
44467: IFTRUE 44471
44469: GO 44478
44471: POP
// hHackSetLevel10 ; 3 :
44472: CALL 56841 0 0
44476: GO 44569
44478: LD_INT 3
44480: DOUBLE
44481: EQUAL
44482: IFTRUE 44486
44484: GO 44493
44486: POP
// hHackSetLevel10YourUnits ; 4 :
44487: CALL 56926 0 0
44491: GO 44569
44493: LD_INT 4
44495: DOUBLE
44496: EQUAL
44497: IFTRUE 44501
44499: GO 44508
44501: POP
// hHackInvincible ; 5 :
44502: CALL 57374 0 0
44506: GO 44569
44508: LD_INT 5
44510: DOUBLE
44511: EQUAL
44512: IFTRUE 44516
44514: GO 44523
44516: POP
// hHackInvisible ; 6 :
44517: CALL 57485 0 0
44521: GO 44569
44523: LD_INT 6
44525: DOUBLE
44526: EQUAL
44527: IFTRUE 44531
44529: GO 44538
44531: POP
// hHackChangeYourSide ; 7 :
44532: CALL 57542 0 0
44536: GO 44569
44538: LD_INT 7
44540: DOUBLE
44541: EQUAL
44542: IFTRUE 44546
44544: GO 44553
44546: POP
// hHackChangeUnitSide ; 8 :
44547: CALL 57584 0 0
44551: GO 44569
44553: LD_INT 8
44555: DOUBLE
44556: EQUAL
44557: IFTRUE 44561
44559: GO 44568
44561: POP
// hHackFog ; end ;
44562: CALL 57685 0 0
44566: GO 44569
44568: POP
// end ; if p2 = game_save_mode then
44569: LD_VAR 0 2
44573: PUSH
44574: LD_INT 102
44576: EQUAL
44577: IFFALSE 44632
// begin if p3 = 1 then
44579: LD_VAR 0 3
44583: PUSH
44584: LD_INT 1
44586: EQUAL
44587: IFFALSE 44599
// globalGameSaveCounter := p4 ;
44589: LD_ADDR_EXP 73
44593: PUSH
44594: LD_VAR 0 4
44598: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
44599: LD_VAR 0 3
44603: PUSH
44604: LD_INT 2
44606: EQUAL
44607: PUSH
44608: LD_EXP 73
44612: AND
44613: IFFALSE 44632
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
44615: LD_STRING setGameSaveCounter(
44617: PUSH
44618: LD_EXP 73
44622: STR
44623: PUSH
44624: LD_STRING )
44626: STR
44627: PPUSH
44628: CALL_OW 559
// end ; end ;
44632: LD_VAR 0 7
44636: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
44637: LD_INT 0
44639: PPUSH
// streamModeActive := false ;
44640: LD_ADDR_EXP 74
44644: PUSH
44645: LD_INT 0
44647: ST_TO_ADDR
// normalCounter := 36 ;
44648: LD_ADDR_EXP 75
44652: PUSH
44653: LD_INT 36
44655: ST_TO_ADDR
// hardcoreCounter := 18 ;
44656: LD_ADDR_EXP 76
44660: PUSH
44661: LD_INT 18
44663: ST_TO_ADDR
// sRocket := false ;
44664: LD_ADDR_EXP 79
44668: PUSH
44669: LD_INT 0
44671: ST_TO_ADDR
// sSpeed := false ;
44672: LD_ADDR_EXP 78
44676: PUSH
44677: LD_INT 0
44679: ST_TO_ADDR
// sEngine := false ;
44680: LD_ADDR_EXP 80
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sSpec := false ;
44688: LD_ADDR_EXP 77
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sLevel := false ;
44696: LD_ADDR_EXP 81
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sArmoury := false ;
44704: LD_ADDR_EXP 82
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sRadar := false ;
44712: LD_ADDR_EXP 83
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sBunker := false ;
44720: LD_ADDR_EXP 84
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sHack := false ;
44728: LD_ADDR_EXP 85
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sFire := false ;
44736: LD_ADDR_EXP 86
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sRefresh := false ;
44744: LD_ADDR_EXP 87
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sExp := false ;
44752: LD_ADDR_EXP 88
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sDepot := false ;
44760: LD_ADDR_EXP 89
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sFlag := false ;
44768: LD_ADDR_EXP 90
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sKamikadze := false ;
44776: LD_ADDR_EXP 98
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sTroll := false ;
44784: LD_ADDR_EXP 99
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sSlow := false ;
44792: LD_ADDR_EXP 100
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sLack := false ;
44800: LD_ADDR_EXP 101
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sTank := false ;
44808: LD_ADDR_EXP 103
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sRemote := false ;
44816: LD_ADDR_EXP 104
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sPowell := false ;
44824: LD_ADDR_EXP 105
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sTeleport := false ;
44832: LD_ADDR_EXP 108
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sOilTower := false ;
44840: LD_ADDR_EXP 110
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sShovel := false ;
44848: LD_ADDR_EXP 111
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sSheik := false ;
44856: LD_ADDR_EXP 112
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sEarthquake := false ;
44864: LD_ADDR_EXP 114
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// sAI := false ;
44872: LD_ADDR_EXP 115
44876: PUSH
44877: LD_INT 0
44879: ST_TO_ADDR
// sCargo := false ;
44880: LD_ADDR_EXP 118
44884: PUSH
44885: LD_INT 0
44887: ST_TO_ADDR
// sDLaser := false ;
44888: LD_ADDR_EXP 119
44892: PUSH
44893: LD_INT 0
44895: ST_TO_ADDR
// sExchange := false ;
44896: LD_ADDR_EXP 120
44900: PUSH
44901: LD_INT 0
44903: ST_TO_ADDR
// sFac := false ;
44904: LD_ADDR_EXP 121
44908: PUSH
44909: LD_INT 0
44911: ST_TO_ADDR
// sPower := false ;
44912: LD_ADDR_EXP 122
44916: PUSH
44917: LD_INT 0
44919: ST_TO_ADDR
// sRandom := false ;
44920: LD_ADDR_EXP 123
44924: PUSH
44925: LD_INT 0
44927: ST_TO_ADDR
// sShield := false ;
44928: LD_ADDR_EXP 124
44932: PUSH
44933: LD_INT 0
44935: ST_TO_ADDR
// sTime := false ;
44936: LD_ADDR_EXP 125
44940: PUSH
44941: LD_INT 0
44943: ST_TO_ADDR
// sTools := false ;
44944: LD_ADDR_EXP 126
44948: PUSH
44949: LD_INT 0
44951: ST_TO_ADDR
// sSold := false ;
44952: LD_ADDR_EXP 91
44956: PUSH
44957: LD_INT 0
44959: ST_TO_ADDR
// sDiff := false ;
44960: LD_ADDR_EXP 92
44964: PUSH
44965: LD_INT 0
44967: ST_TO_ADDR
// sFog := false ;
44968: LD_ADDR_EXP 95
44972: PUSH
44973: LD_INT 0
44975: ST_TO_ADDR
// sReset := false ;
44976: LD_ADDR_EXP 96
44980: PUSH
44981: LD_INT 0
44983: ST_TO_ADDR
// sSun := false ;
44984: LD_ADDR_EXP 97
44988: PUSH
44989: LD_INT 0
44991: ST_TO_ADDR
// sTiger := false ;
44992: LD_ADDR_EXP 93
44996: PUSH
44997: LD_INT 0
44999: ST_TO_ADDR
// sBomb := false ;
45000: LD_ADDR_EXP 94
45004: PUSH
45005: LD_INT 0
45007: ST_TO_ADDR
// sWound := false ;
45008: LD_ADDR_EXP 102
45012: PUSH
45013: LD_INT 0
45015: ST_TO_ADDR
// sBetray := false ;
45016: LD_ADDR_EXP 106
45020: PUSH
45021: LD_INT 0
45023: ST_TO_ADDR
// sContamin := false ;
45024: LD_ADDR_EXP 107
45028: PUSH
45029: LD_INT 0
45031: ST_TO_ADDR
// sOil := false ;
45032: LD_ADDR_EXP 109
45036: PUSH
45037: LD_INT 0
45039: ST_TO_ADDR
// sStu := false ;
45040: LD_ADDR_EXP 113
45044: PUSH
45045: LD_INT 0
45047: ST_TO_ADDR
// sBazooka := false ;
45048: LD_ADDR_EXP 116
45052: PUSH
45053: LD_INT 0
45055: ST_TO_ADDR
// sMortar := false ;
45056: LD_ADDR_EXP 117
45060: PUSH
45061: LD_INT 0
45063: ST_TO_ADDR
// sRanger := false ;
45064: LD_ADDR_EXP 127
45068: PUSH
45069: LD_INT 0
45071: ST_TO_ADDR
// sComputer := false ;
45072: LD_ADDR_EXP 128
45076: PUSH
45077: LD_INT 0
45079: ST_TO_ADDR
// s30 := false ;
45080: LD_ADDR_EXP 129
45084: PUSH
45085: LD_INT 0
45087: ST_TO_ADDR
// s60 := false ;
45088: LD_ADDR_EXP 130
45092: PUSH
45093: LD_INT 0
45095: ST_TO_ADDR
// end ;
45096: LD_VAR 0 1
45100: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45101: LD_INT 0
45103: PPUSH
45104: PPUSH
45105: PPUSH
45106: PPUSH
45107: PPUSH
45108: PPUSH
45109: PPUSH
// result := [ ] ;
45110: LD_ADDR_VAR 0 2
45114: PUSH
45115: EMPTY
45116: ST_TO_ADDR
// if campaign_id = 1 then
45117: LD_OWVAR 69
45121: PUSH
45122: LD_INT 1
45124: EQUAL
45125: IFFALSE 48291
// begin case mission_number of 1 :
45127: LD_OWVAR 70
45131: PUSH
45132: LD_INT 1
45134: DOUBLE
45135: EQUAL
45136: IFTRUE 45140
45138: GO 45216
45140: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45141: LD_ADDR_VAR 0 2
45145: PUSH
45146: LD_INT 2
45148: PUSH
45149: LD_INT 4
45151: PUSH
45152: LD_INT 11
45154: PUSH
45155: LD_INT 12
45157: PUSH
45158: LD_INT 15
45160: PUSH
45161: LD_INT 16
45163: PUSH
45164: LD_INT 22
45166: PUSH
45167: LD_INT 23
45169: PUSH
45170: LD_INT 26
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 101
45186: PUSH
45187: LD_INT 102
45189: PUSH
45190: LD_INT 106
45192: PUSH
45193: LD_INT 116
45195: PUSH
45196: LD_INT 117
45198: PUSH
45199: LD_INT 118
45201: PUSH
45202: EMPTY
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: ST_TO_ADDR
45214: GO 48289
45216: LD_INT 2
45218: DOUBLE
45219: EQUAL
45220: IFTRUE 45224
45222: GO 45308
45224: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45225: LD_ADDR_VAR 0 2
45229: PUSH
45230: LD_INT 2
45232: PUSH
45233: LD_INT 4
45235: PUSH
45236: LD_INT 11
45238: PUSH
45239: LD_INT 12
45241: PUSH
45242: LD_INT 15
45244: PUSH
45245: LD_INT 16
45247: PUSH
45248: LD_INT 22
45250: PUSH
45251: LD_INT 23
45253: PUSH
45254: LD_INT 26
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 101
45270: PUSH
45271: LD_INT 102
45273: PUSH
45274: LD_INT 105
45276: PUSH
45277: LD_INT 106
45279: PUSH
45280: LD_INT 108
45282: PUSH
45283: LD_INT 116
45285: PUSH
45286: LD_INT 117
45288: PUSH
45289: LD_INT 118
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: ST_TO_ADDR
45306: GO 48289
45308: LD_INT 3
45310: DOUBLE
45311: EQUAL
45312: IFTRUE 45316
45314: GO 45404
45316: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45317: LD_ADDR_VAR 0 2
45321: PUSH
45322: LD_INT 2
45324: PUSH
45325: LD_INT 4
45327: PUSH
45328: LD_INT 5
45330: PUSH
45331: LD_INT 11
45333: PUSH
45334: LD_INT 12
45336: PUSH
45337: LD_INT 15
45339: PUSH
45340: LD_INT 16
45342: PUSH
45343: LD_INT 22
45345: PUSH
45346: LD_INT 26
45348: PUSH
45349: LD_INT 36
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: PUSH
45364: LD_INT 101
45366: PUSH
45367: LD_INT 102
45369: PUSH
45370: LD_INT 105
45372: PUSH
45373: LD_INT 106
45375: PUSH
45376: LD_INT 108
45378: PUSH
45379: LD_INT 116
45381: PUSH
45382: LD_INT 117
45384: PUSH
45385: LD_INT 118
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: ST_TO_ADDR
45402: GO 48289
45404: LD_INT 4
45406: DOUBLE
45407: EQUAL
45408: IFTRUE 45412
45410: GO 45508
45412: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45413: LD_ADDR_VAR 0 2
45417: PUSH
45418: LD_INT 2
45420: PUSH
45421: LD_INT 4
45423: PUSH
45424: LD_INT 5
45426: PUSH
45427: LD_INT 8
45429: PUSH
45430: LD_INT 11
45432: PUSH
45433: LD_INT 12
45435: PUSH
45436: LD_INT 15
45438: PUSH
45439: LD_INT 16
45441: PUSH
45442: LD_INT 22
45444: PUSH
45445: LD_INT 23
45447: PUSH
45448: LD_INT 26
45450: PUSH
45451: LD_INT 36
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 101
45470: PUSH
45471: LD_INT 102
45473: PUSH
45474: LD_INT 105
45476: PUSH
45477: LD_INT 106
45479: PUSH
45480: LD_INT 108
45482: PUSH
45483: LD_INT 116
45485: PUSH
45486: LD_INT 117
45488: PUSH
45489: LD_INT 118
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: ST_TO_ADDR
45506: GO 48289
45508: LD_INT 5
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45516
45514: GO 45628
45516: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45517: LD_ADDR_VAR 0 2
45521: PUSH
45522: LD_INT 2
45524: PUSH
45525: LD_INT 4
45527: PUSH
45528: LD_INT 5
45530: PUSH
45531: LD_INT 6
45533: PUSH
45534: LD_INT 8
45536: PUSH
45537: LD_INT 11
45539: PUSH
45540: LD_INT 12
45542: PUSH
45543: LD_INT 15
45545: PUSH
45546: LD_INT 16
45548: PUSH
45549: LD_INT 22
45551: PUSH
45552: LD_INT 23
45554: PUSH
45555: LD_INT 25
45557: PUSH
45558: LD_INT 26
45560: PUSH
45561: LD_INT 36
45563: PUSH
45564: EMPTY
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: PUSH
45580: LD_INT 101
45582: PUSH
45583: LD_INT 102
45585: PUSH
45586: LD_INT 105
45588: PUSH
45589: LD_INT 106
45591: PUSH
45592: LD_INT 108
45594: PUSH
45595: LD_INT 109
45597: PUSH
45598: LD_INT 112
45600: PUSH
45601: LD_INT 116
45603: PUSH
45604: LD_INT 117
45606: PUSH
45607: LD_INT 118
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: ST_TO_ADDR
45626: GO 48289
45628: LD_INT 6
45630: DOUBLE
45631: EQUAL
45632: IFTRUE 45636
45634: GO 45768
45636: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45637: LD_ADDR_VAR 0 2
45641: PUSH
45642: LD_INT 2
45644: PUSH
45645: LD_INT 4
45647: PUSH
45648: LD_INT 5
45650: PUSH
45651: LD_INT 6
45653: PUSH
45654: LD_INT 8
45656: PUSH
45657: LD_INT 11
45659: PUSH
45660: LD_INT 12
45662: PUSH
45663: LD_INT 15
45665: PUSH
45666: LD_INT 16
45668: PUSH
45669: LD_INT 20
45671: PUSH
45672: LD_INT 21
45674: PUSH
45675: LD_INT 22
45677: PUSH
45678: LD_INT 23
45680: PUSH
45681: LD_INT 25
45683: PUSH
45684: LD_INT 26
45686: PUSH
45687: LD_INT 30
45689: PUSH
45690: LD_INT 31
45692: PUSH
45693: LD_INT 32
45695: PUSH
45696: LD_INT 36
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: LIST
45716: LIST
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 101
45722: PUSH
45723: LD_INT 102
45725: PUSH
45726: LD_INT 105
45728: PUSH
45729: LD_INT 106
45731: PUSH
45732: LD_INT 108
45734: PUSH
45735: LD_INT 109
45737: PUSH
45738: LD_INT 112
45740: PUSH
45741: LD_INT 116
45743: PUSH
45744: LD_INT 117
45746: PUSH
45747: LD_INT 118
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: ST_TO_ADDR
45766: GO 48289
45768: LD_INT 7
45770: DOUBLE
45771: EQUAL
45772: IFTRUE 45776
45774: GO 45888
45776: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45777: LD_ADDR_VAR 0 2
45781: PUSH
45782: LD_INT 2
45784: PUSH
45785: LD_INT 4
45787: PUSH
45788: LD_INT 5
45790: PUSH
45791: LD_INT 7
45793: PUSH
45794: LD_INT 11
45796: PUSH
45797: LD_INT 12
45799: PUSH
45800: LD_INT 15
45802: PUSH
45803: LD_INT 16
45805: PUSH
45806: LD_INT 20
45808: PUSH
45809: LD_INT 21
45811: PUSH
45812: LD_INT 22
45814: PUSH
45815: LD_INT 23
45817: PUSH
45818: LD_INT 25
45820: PUSH
45821: LD_INT 26
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: PUSH
45840: LD_INT 101
45842: PUSH
45843: LD_INT 102
45845: PUSH
45846: LD_INT 103
45848: PUSH
45849: LD_INT 105
45851: PUSH
45852: LD_INT 106
45854: PUSH
45855: LD_INT 108
45857: PUSH
45858: LD_INT 112
45860: PUSH
45861: LD_INT 116
45863: PUSH
45864: LD_INT 117
45866: PUSH
45867: LD_INT 118
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: ST_TO_ADDR
45886: GO 48289
45888: LD_INT 8
45890: DOUBLE
45891: EQUAL
45892: IFTRUE 45896
45894: GO 46036
45896: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45897: LD_ADDR_VAR 0 2
45901: PUSH
45902: LD_INT 2
45904: PUSH
45905: LD_INT 4
45907: PUSH
45908: LD_INT 5
45910: PUSH
45911: LD_INT 6
45913: PUSH
45914: LD_INT 7
45916: PUSH
45917: LD_INT 8
45919: PUSH
45920: LD_INT 11
45922: PUSH
45923: LD_INT 12
45925: PUSH
45926: LD_INT 15
45928: PUSH
45929: LD_INT 16
45931: PUSH
45932: LD_INT 20
45934: PUSH
45935: LD_INT 21
45937: PUSH
45938: LD_INT 22
45940: PUSH
45941: LD_INT 23
45943: PUSH
45944: LD_INT 25
45946: PUSH
45947: LD_INT 26
45949: PUSH
45950: LD_INT 30
45952: PUSH
45953: LD_INT 31
45955: PUSH
45956: LD_INT 32
45958: PUSH
45959: LD_INT 36
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: PUSH
45984: LD_INT 101
45986: PUSH
45987: LD_INT 102
45989: PUSH
45990: LD_INT 103
45992: PUSH
45993: LD_INT 105
45995: PUSH
45996: LD_INT 106
45998: PUSH
45999: LD_INT 108
46001: PUSH
46002: LD_INT 109
46004: PUSH
46005: LD_INT 112
46007: PUSH
46008: LD_INT 116
46010: PUSH
46011: LD_INT 117
46013: PUSH
46014: LD_INT 118
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: ST_TO_ADDR
46034: GO 48289
46036: LD_INT 9
46038: DOUBLE
46039: EQUAL
46040: IFTRUE 46044
46042: GO 46192
46044: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46045: LD_ADDR_VAR 0 2
46049: PUSH
46050: LD_INT 2
46052: PUSH
46053: LD_INT 4
46055: PUSH
46056: LD_INT 5
46058: PUSH
46059: LD_INT 6
46061: PUSH
46062: LD_INT 7
46064: PUSH
46065: LD_INT 8
46067: PUSH
46068: LD_INT 11
46070: PUSH
46071: LD_INT 12
46073: PUSH
46074: LD_INT 15
46076: PUSH
46077: LD_INT 16
46079: PUSH
46080: LD_INT 20
46082: PUSH
46083: LD_INT 21
46085: PUSH
46086: LD_INT 22
46088: PUSH
46089: LD_INT 23
46091: PUSH
46092: LD_INT 25
46094: PUSH
46095: LD_INT 26
46097: PUSH
46098: LD_INT 28
46100: PUSH
46101: LD_INT 30
46103: PUSH
46104: LD_INT 31
46106: PUSH
46107: LD_INT 32
46109: PUSH
46110: LD_INT 36
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 101
46138: PUSH
46139: LD_INT 102
46141: PUSH
46142: LD_INT 103
46144: PUSH
46145: LD_INT 105
46147: PUSH
46148: LD_INT 106
46150: PUSH
46151: LD_INT 108
46153: PUSH
46154: LD_INT 109
46156: PUSH
46157: LD_INT 112
46159: PUSH
46160: LD_INT 114
46162: PUSH
46163: LD_INT 116
46165: PUSH
46166: LD_INT 117
46168: PUSH
46169: LD_INT 118
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: ST_TO_ADDR
46190: GO 48289
46192: LD_INT 10
46194: DOUBLE
46195: EQUAL
46196: IFTRUE 46200
46198: GO 46396
46200: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46201: LD_ADDR_VAR 0 2
46205: PUSH
46206: LD_INT 2
46208: PUSH
46209: LD_INT 4
46211: PUSH
46212: LD_INT 5
46214: PUSH
46215: LD_INT 6
46217: PUSH
46218: LD_INT 7
46220: PUSH
46221: LD_INT 8
46223: PUSH
46224: LD_INT 9
46226: PUSH
46227: LD_INT 10
46229: PUSH
46230: LD_INT 11
46232: PUSH
46233: LD_INT 12
46235: PUSH
46236: LD_INT 13
46238: PUSH
46239: LD_INT 14
46241: PUSH
46242: LD_INT 15
46244: PUSH
46245: LD_INT 16
46247: PUSH
46248: LD_INT 17
46250: PUSH
46251: LD_INT 18
46253: PUSH
46254: LD_INT 19
46256: PUSH
46257: LD_INT 20
46259: PUSH
46260: LD_INT 21
46262: PUSH
46263: LD_INT 22
46265: PUSH
46266: LD_INT 23
46268: PUSH
46269: LD_INT 24
46271: PUSH
46272: LD_INT 25
46274: PUSH
46275: LD_INT 26
46277: PUSH
46278: LD_INT 28
46280: PUSH
46281: LD_INT 30
46283: PUSH
46284: LD_INT 31
46286: PUSH
46287: LD_INT 32
46289: PUSH
46290: LD_INT 36
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: LIST
46300: LIST
46301: LIST
46302: LIST
46303: LIST
46304: LIST
46305: LIST
46306: LIST
46307: LIST
46308: LIST
46309: LIST
46310: LIST
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 101
46326: PUSH
46327: LD_INT 102
46329: PUSH
46330: LD_INT 103
46332: PUSH
46333: LD_INT 104
46335: PUSH
46336: LD_INT 105
46338: PUSH
46339: LD_INT 106
46341: PUSH
46342: LD_INT 107
46344: PUSH
46345: LD_INT 108
46347: PUSH
46348: LD_INT 109
46350: PUSH
46351: LD_INT 110
46353: PUSH
46354: LD_INT 111
46356: PUSH
46357: LD_INT 112
46359: PUSH
46360: LD_INT 114
46362: PUSH
46363: LD_INT 116
46365: PUSH
46366: LD_INT 117
46368: PUSH
46369: LD_INT 118
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: ST_TO_ADDR
46394: GO 48289
46396: LD_INT 11
46398: DOUBLE
46399: EQUAL
46400: IFTRUE 46404
46402: GO 46608
46404: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46405: LD_ADDR_VAR 0 2
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: LD_INT 3
46415: PUSH
46416: LD_INT 4
46418: PUSH
46419: LD_INT 5
46421: PUSH
46422: LD_INT 6
46424: PUSH
46425: LD_INT 7
46427: PUSH
46428: LD_INT 8
46430: PUSH
46431: LD_INT 9
46433: PUSH
46434: LD_INT 10
46436: PUSH
46437: LD_INT 11
46439: PUSH
46440: LD_INT 12
46442: PUSH
46443: LD_INT 13
46445: PUSH
46446: LD_INT 14
46448: PUSH
46449: LD_INT 15
46451: PUSH
46452: LD_INT 16
46454: PUSH
46455: LD_INT 17
46457: PUSH
46458: LD_INT 18
46460: PUSH
46461: LD_INT 19
46463: PUSH
46464: LD_INT 20
46466: PUSH
46467: LD_INT 21
46469: PUSH
46470: LD_INT 22
46472: PUSH
46473: LD_INT 23
46475: PUSH
46476: LD_INT 24
46478: PUSH
46479: LD_INT 25
46481: PUSH
46482: LD_INT 26
46484: PUSH
46485: LD_INT 28
46487: PUSH
46488: LD_INT 30
46490: PUSH
46491: LD_INT 31
46493: PUSH
46494: LD_INT 32
46496: PUSH
46497: LD_INT 34
46499: PUSH
46500: LD_INT 36
46502: PUSH
46503: EMPTY
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: PUSH
46536: LD_INT 101
46538: PUSH
46539: LD_INT 102
46541: PUSH
46542: LD_INT 103
46544: PUSH
46545: LD_INT 104
46547: PUSH
46548: LD_INT 105
46550: PUSH
46551: LD_INT 106
46553: PUSH
46554: LD_INT 107
46556: PUSH
46557: LD_INT 108
46559: PUSH
46560: LD_INT 109
46562: PUSH
46563: LD_INT 110
46565: PUSH
46566: LD_INT 111
46568: PUSH
46569: LD_INT 112
46571: PUSH
46572: LD_INT 114
46574: PUSH
46575: LD_INT 116
46577: PUSH
46578: LD_INT 117
46580: PUSH
46581: LD_INT 118
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: ST_TO_ADDR
46606: GO 48289
46608: LD_INT 12
46610: DOUBLE
46611: EQUAL
46612: IFTRUE 46616
46614: GO 46836
46616: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46617: LD_ADDR_VAR 0 2
46621: PUSH
46622: LD_INT 1
46624: PUSH
46625: LD_INT 2
46627: PUSH
46628: LD_INT 3
46630: PUSH
46631: LD_INT 4
46633: PUSH
46634: LD_INT 5
46636: PUSH
46637: LD_INT 6
46639: PUSH
46640: LD_INT 7
46642: PUSH
46643: LD_INT 8
46645: PUSH
46646: LD_INT 9
46648: PUSH
46649: LD_INT 10
46651: PUSH
46652: LD_INT 11
46654: PUSH
46655: LD_INT 12
46657: PUSH
46658: LD_INT 13
46660: PUSH
46661: LD_INT 14
46663: PUSH
46664: LD_INT 15
46666: PUSH
46667: LD_INT 16
46669: PUSH
46670: LD_INT 17
46672: PUSH
46673: LD_INT 18
46675: PUSH
46676: LD_INT 19
46678: PUSH
46679: LD_INT 20
46681: PUSH
46682: LD_INT 21
46684: PUSH
46685: LD_INT 22
46687: PUSH
46688: LD_INT 23
46690: PUSH
46691: LD_INT 24
46693: PUSH
46694: LD_INT 25
46696: PUSH
46697: LD_INT 26
46699: PUSH
46700: LD_INT 27
46702: PUSH
46703: LD_INT 28
46705: PUSH
46706: LD_INT 30
46708: PUSH
46709: LD_INT 31
46711: PUSH
46712: LD_INT 32
46714: PUSH
46715: LD_INT 33
46717: PUSH
46718: LD_INT 34
46720: PUSH
46721: LD_INT 36
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: PUSH
46760: LD_INT 101
46762: PUSH
46763: LD_INT 102
46765: PUSH
46766: LD_INT 103
46768: PUSH
46769: LD_INT 104
46771: PUSH
46772: LD_INT 105
46774: PUSH
46775: LD_INT 106
46777: PUSH
46778: LD_INT 107
46780: PUSH
46781: LD_INT 108
46783: PUSH
46784: LD_INT 109
46786: PUSH
46787: LD_INT 110
46789: PUSH
46790: LD_INT 111
46792: PUSH
46793: LD_INT 112
46795: PUSH
46796: LD_INT 113
46798: PUSH
46799: LD_INT 114
46801: PUSH
46802: LD_INT 116
46804: PUSH
46805: LD_INT 117
46807: PUSH
46808: LD_INT 118
46810: PUSH
46811: EMPTY
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: ST_TO_ADDR
46834: GO 48289
46836: LD_INT 13
46838: DOUBLE
46839: EQUAL
46840: IFTRUE 46844
46842: GO 47052
46844: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46845: LD_ADDR_VAR 0 2
46849: PUSH
46850: LD_INT 1
46852: PUSH
46853: LD_INT 2
46855: PUSH
46856: LD_INT 3
46858: PUSH
46859: LD_INT 4
46861: PUSH
46862: LD_INT 5
46864: PUSH
46865: LD_INT 8
46867: PUSH
46868: LD_INT 9
46870: PUSH
46871: LD_INT 10
46873: PUSH
46874: LD_INT 11
46876: PUSH
46877: LD_INT 12
46879: PUSH
46880: LD_INT 14
46882: PUSH
46883: LD_INT 15
46885: PUSH
46886: LD_INT 16
46888: PUSH
46889: LD_INT 17
46891: PUSH
46892: LD_INT 18
46894: PUSH
46895: LD_INT 19
46897: PUSH
46898: LD_INT 20
46900: PUSH
46901: LD_INT 21
46903: PUSH
46904: LD_INT 22
46906: PUSH
46907: LD_INT 23
46909: PUSH
46910: LD_INT 24
46912: PUSH
46913: LD_INT 25
46915: PUSH
46916: LD_INT 26
46918: PUSH
46919: LD_INT 27
46921: PUSH
46922: LD_INT 28
46924: PUSH
46925: LD_INT 30
46927: PUSH
46928: LD_INT 31
46930: PUSH
46931: LD_INT 32
46933: PUSH
46934: LD_INT 33
46936: PUSH
46937: LD_INT 34
46939: PUSH
46940: LD_INT 36
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 101
46978: PUSH
46979: LD_INT 102
46981: PUSH
46982: LD_INT 103
46984: PUSH
46985: LD_INT 104
46987: PUSH
46988: LD_INT 105
46990: PUSH
46991: LD_INT 106
46993: PUSH
46994: LD_INT 107
46996: PUSH
46997: LD_INT 108
46999: PUSH
47000: LD_INT 109
47002: PUSH
47003: LD_INT 110
47005: PUSH
47006: LD_INT 111
47008: PUSH
47009: LD_INT 112
47011: PUSH
47012: LD_INT 113
47014: PUSH
47015: LD_INT 114
47017: PUSH
47018: LD_INT 116
47020: PUSH
47021: LD_INT 117
47023: PUSH
47024: LD_INT 118
47026: PUSH
47027: EMPTY
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: ST_TO_ADDR
47050: GO 48289
47052: LD_INT 14
47054: DOUBLE
47055: EQUAL
47056: IFTRUE 47060
47058: GO 47284
47060: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47061: LD_ADDR_VAR 0 2
47065: PUSH
47066: LD_INT 1
47068: PUSH
47069: LD_INT 2
47071: PUSH
47072: LD_INT 3
47074: PUSH
47075: LD_INT 4
47077: PUSH
47078: LD_INT 5
47080: PUSH
47081: LD_INT 6
47083: PUSH
47084: LD_INT 7
47086: PUSH
47087: LD_INT 8
47089: PUSH
47090: LD_INT 9
47092: PUSH
47093: LD_INT 10
47095: PUSH
47096: LD_INT 11
47098: PUSH
47099: LD_INT 12
47101: PUSH
47102: LD_INT 13
47104: PUSH
47105: LD_INT 14
47107: PUSH
47108: LD_INT 15
47110: PUSH
47111: LD_INT 16
47113: PUSH
47114: LD_INT 17
47116: PUSH
47117: LD_INT 18
47119: PUSH
47120: LD_INT 19
47122: PUSH
47123: LD_INT 20
47125: PUSH
47126: LD_INT 21
47128: PUSH
47129: LD_INT 22
47131: PUSH
47132: LD_INT 23
47134: PUSH
47135: LD_INT 24
47137: PUSH
47138: LD_INT 25
47140: PUSH
47141: LD_INT 26
47143: PUSH
47144: LD_INT 27
47146: PUSH
47147: LD_INT 28
47149: PUSH
47150: LD_INT 29
47152: PUSH
47153: LD_INT 30
47155: PUSH
47156: LD_INT 31
47158: PUSH
47159: LD_INT 32
47161: PUSH
47162: LD_INT 33
47164: PUSH
47165: LD_INT 34
47167: PUSH
47168: LD_INT 36
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 101
47210: PUSH
47211: LD_INT 102
47213: PUSH
47214: LD_INT 103
47216: PUSH
47217: LD_INT 104
47219: PUSH
47220: LD_INT 105
47222: PUSH
47223: LD_INT 106
47225: PUSH
47226: LD_INT 107
47228: PUSH
47229: LD_INT 108
47231: PUSH
47232: LD_INT 109
47234: PUSH
47235: LD_INT 110
47237: PUSH
47238: LD_INT 111
47240: PUSH
47241: LD_INT 112
47243: PUSH
47244: LD_INT 113
47246: PUSH
47247: LD_INT 114
47249: PUSH
47250: LD_INT 116
47252: PUSH
47253: LD_INT 117
47255: PUSH
47256: LD_INT 118
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: ST_TO_ADDR
47282: GO 48289
47284: LD_INT 15
47286: DOUBLE
47287: EQUAL
47288: IFTRUE 47292
47290: GO 47516
47292: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47293: LD_ADDR_VAR 0 2
47297: PUSH
47298: LD_INT 1
47300: PUSH
47301: LD_INT 2
47303: PUSH
47304: LD_INT 3
47306: PUSH
47307: LD_INT 4
47309: PUSH
47310: LD_INT 5
47312: PUSH
47313: LD_INT 6
47315: PUSH
47316: LD_INT 7
47318: PUSH
47319: LD_INT 8
47321: PUSH
47322: LD_INT 9
47324: PUSH
47325: LD_INT 10
47327: PUSH
47328: LD_INT 11
47330: PUSH
47331: LD_INT 12
47333: PUSH
47334: LD_INT 13
47336: PUSH
47337: LD_INT 14
47339: PUSH
47340: LD_INT 15
47342: PUSH
47343: LD_INT 16
47345: PUSH
47346: LD_INT 17
47348: PUSH
47349: LD_INT 18
47351: PUSH
47352: LD_INT 19
47354: PUSH
47355: LD_INT 20
47357: PUSH
47358: LD_INT 21
47360: PUSH
47361: LD_INT 22
47363: PUSH
47364: LD_INT 23
47366: PUSH
47367: LD_INT 24
47369: PUSH
47370: LD_INT 25
47372: PUSH
47373: LD_INT 26
47375: PUSH
47376: LD_INT 27
47378: PUSH
47379: LD_INT 28
47381: PUSH
47382: LD_INT 29
47384: PUSH
47385: LD_INT 30
47387: PUSH
47388: LD_INT 31
47390: PUSH
47391: LD_INT 32
47393: PUSH
47394: LD_INT 33
47396: PUSH
47397: LD_INT 34
47399: PUSH
47400: LD_INT 36
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: LIST
47414: LIST
47415: LIST
47416: LIST
47417: LIST
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 101
47442: PUSH
47443: LD_INT 102
47445: PUSH
47446: LD_INT 103
47448: PUSH
47449: LD_INT 104
47451: PUSH
47452: LD_INT 105
47454: PUSH
47455: LD_INT 106
47457: PUSH
47458: LD_INT 107
47460: PUSH
47461: LD_INT 108
47463: PUSH
47464: LD_INT 109
47466: PUSH
47467: LD_INT 110
47469: PUSH
47470: LD_INT 111
47472: PUSH
47473: LD_INT 112
47475: PUSH
47476: LD_INT 113
47478: PUSH
47479: LD_INT 114
47481: PUSH
47482: LD_INT 116
47484: PUSH
47485: LD_INT 117
47487: PUSH
47488: LD_INT 118
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: ST_TO_ADDR
47514: GO 48289
47516: LD_INT 16
47518: DOUBLE
47519: EQUAL
47520: IFTRUE 47524
47522: GO 47660
47524: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47525: LD_ADDR_VAR 0 2
47529: PUSH
47530: LD_INT 2
47532: PUSH
47533: LD_INT 4
47535: PUSH
47536: LD_INT 5
47538: PUSH
47539: LD_INT 7
47541: PUSH
47542: LD_INT 11
47544: PUSH
47545: LD_INT 12
47547: PUSH
47548: LD_INT 15
47550: PUSH
47551: LD_INT 16
47553: PUSH
47554: LD_INT 20
47556: PUSH
47557: LD_INT 21
47559: PUSH
47560: LD_INT 22
47562: PUSH
47563: LD_INT 23
47565: PUSH
47566: LD_INT 25
47568: PUSH
47569: LD_INT 26
47571: PUSH
47572: LD_INT 30
47574: PUSH
47575: LD_INT 31
47577: PUSH
47578: LD_INT 32
47580: PUSH
47581: LD_INT 33
47583: PUSH
47584: LD_INT 34
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: PUSH
47608: LD_INT 101
47610: PUSH
47611: LD_INT 102
47613: PUSH
47614: LD_INT 103
47616: PUSH
47617: LD_INT 106
47619: PUSH
47620: LD_INT 108
47622: PUSH
47623: LD_INT 112
47625: PUSH
47626: LD_INT 113
47628: PUSH
47629: LD_INT 114
47631: PUSH
47632: LD_INT 116
47634: PUSH
47635: LD_INT 117
47637: PUSH
47638: LD_INT 118
47640: PUSH
47641: EMPTY
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: ST_TO_ADDR
47658: GO 48289
47660: LD_INT 17
47662: DOUBLE
47663: EQUAL
47664: IFTRUE 47668
47666: GO 47892
47668: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47669: LD_ADDR_VAR 0 2
47673: PUSH
47674: LD_INT 1
47676: PUSH
47677: LD_INT 2
47679: PUSH
47680: LD_INT 3
47682: PUSH
47683: LD_INT 4
47685: PUSH
47686: LD_INT 5
47688: PUSH
47689: LD_INT 6
47691: PUSH
47692: LD_INT 7
47694: PUSH
47695: LD_INT 8
47697: PUSH
47698: LD_INT 9
47700: PUSH
47701: LD_INT 10
47703: PUSH
47704: LD_INT 11
47706: PUSH
47707: LD_INT 12
47709: PUSH
47710: LD_INT 13
47712: PUSH
47713: LD_INT 14
47715: PUSH
47716: LD_INT 15
47718: PUSH
47719: LD_INT 16
47721: PUSH
47722: LD_INT 17
47724: PUSH
47725: LD_INT 18
47727: PUSH
47728: LD_INT 19
47730: PUSH
47731: LD_INT 20
47733: PUSH
47734: LD_INT 21
47736: PUSH
47737: LD_INT 22
47739: PUSH
47740: LD_INT 23
47742: PUSH
47743: LD_INT 24
47745: PUSH
47746: LD_INT 25
47748: PUSH
47749: LD_INT 26
47751: PUSH
47752: LD_INT 27
47754: PUSH
47755: LD_INT 28
47757: PUSH
47758: LD_INT 29
47760: PUSH
47761: LD_INT 30
47763: PUSH
47764: LD_INT 31
47766: PUSH
47767: LD_INT 32
47769: PUSH
47770: LD_INT 33
47772: PUSH
47773: LD_INT 34
47775: PUSH
47776: LD_INT 36
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: LIST
47792: LIST
47793: LIST
47794: LIST
47795: LIST
47796: LIST
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 101
47818: PUSH
47819: LD_INT 102
47821: PUSH
47822: LD_INT 103
47824: PUSH
47825: LD_INT 104
47827: PUSH
47828: LD_INT 105
47830: PUSH
47831: LD_INT 106
47833: PUSH
47834: LD_INT 107
47836: PUSH
47837: LD_INT 108
47839: PUSH
47840: LD_INT 109
47842: PUSH
47843: LD_INT 110
47845: PUSH
47846: LD_INT 111
47848: PUSH
47849: LD_INT 112
47851: PUSH
47852: LD_INT 113
47854: PUSH
47855: LD_INT 114
47857: PUSH
47858: LD_INT 116
47860: PUSH
47861: LD_INT 117
47863: PUSH
47864: LD_INT 118
47866: PUSH
47867: EMPTY
47868: LIST
47869: LIST
47870: LIST
47871: LIST
47872: LIST
47873: LIST
47874: LIST
47875: LIST
47876: LIST
47877: LIST
47878: LIST
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: ST_TO_ADDR
47890: GO 48289
47892: LD_INT 18
47894: DOUBLE
47895: EQUAL
47896: IFTRUE 47900
47898: GO 48048
47900: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47901: LD_ADDR_VAR 0 2
47905: PUSH
47906: LD_INT 2
47908: PUSH
47909: LD_INT 4
47911: PUSH
47912: LD_INT 5
47914: PUSH
47915: LD_INT 7
47917: PUSH
47918: LD_INT 11
47920: PUSH
47921: LD_INT 12
47923: PUSH
47924: LD_INT 15
47926: PUSH
47927: LD_INT 16
47929: PUSH
47930: LD_INT 20
47932: PUSH
47933: LD_INT 21
47935: PUSH
47936: LD_INT 22
47938: PUSH
47939: LD_INT 23
47941: PUSH
47942: LD_INT 25
47944: PUSH
47945: LD_INT 26
47947: PUSH
47948: LD_INT 30
47950: PUSH
47951: LD_INT 31
47953: PUSH
47954: LD_INT 32
47956: PUSH
47957: LD_INT 33
47959: PUSH
47960: LD_INT 34
47962: PUSH
47963: LD_INT 35
47965: PUSH
47966: LD_INT 36
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 101
47994: PUSH
47995: LD_INT 102
47997: PUSH
47998: LD_INT 103
48000: PUSH
48001: LD_INT 106
48003: PUSH
48004: LD_INT 108
48006: PUSH
48007: LD_INT 112
48009: PUSH
48010: LD_INT 113
48012: PUSH
48013: LD_INT 114
48015: PUSH
48016: LD_INT 115
48018: PUSH
48019: LD_INT 116
48021: PUSH
48022: LD_INT 117
48024: PUSH
48025: LD_INT 118
48027: PUSH
48028: EMPTY
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: ST_TO_ADDR
48046: GO 48289
48048: LD_INT 19
48050: DOUBLE
48051: EQUAL
48052: IFTRUE 48056
48054: GO 48288
48056: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48057: LD_ADDR_VAR 0 2
48061: PUSH
48062: LD_INT 1
48064: PUSH
48065: LD_INT 2
48067: PUSH
48068: LD_INT 3
48070: PUSH
48071: LD_INT 4
48073: PUSH
48074: LD_INT 5
48076: PUSH
48077: LD_INT 6
48079: PUSH
48080: LD_INT 7
48082: PUSH
48083: LD_INT 8
48085: PUSH
48086: LD_INT 9
48088: PUSH
48089: LD_INT 10
48091: PUSH
48092: LD_INT 11
48094: PUSH
48095: LD_INT 12
48097: PUSH
48098: LD_INT 13
48100: PUSH
48101: LD_INT 14
48103: PUSH
48104: LD_INT 15
48106: PUSH
48107: LD_INT 16
48109: PUSH
48110: LD_INT 17
48112: PUSH
48113: LD_INT 18
48115: PUSH
48116: LD_INT 19
48118: PUSH
48119: LD_INT 20
48121: PUSH
48122: LD_INT 21
48124: PUSH
48125: LD_INT 22
48127: PUSH
48128: LD_INT 23
48130: PUSH
48131: LD_INT 24
48133: PUSH
48134: LD_INT 25
48136: PUSH
48137: LD_INT 26
48139: PUSH
48140: LD_INT 27
48142: PUSH
48143: LD_INT 28
48145: PUSH
48146: LD_INT 29
48148: PUSH
48149: LD_INT 30
48151: PUSH
48152: LD_INT 31
48154: PUSH
48155: LD_INT 32
48157: PUSH
48158: LD_INT 33
48160: PUSH
48161: LD_INT 34
48163: PUSH
48164: LD_INT 35
48166: PUSH
48167: LD_INT 36
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: LIST
48181: LIST
48182: LIST
48183: LIST
48184: LIST
48185: LIST
48186: LIST
48187: LIST
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 101
48210: PUSH
48211: LD_INT 102
48213: PUSH
48214: LD_INT 103
48216: PUSH
48217: LD_INT 104
48219: PUSH
48220: LD_INT 105
48222: PUSH
48223: LD_INT 106
48225: PUSH
48226: LD_INT 107
48228: PUSH
48229: LD_INT 108
48231: PUSH
48232: LD_INT 109
48234: PUSH
48235: LD_INT 110
48237: PUSH
48238: LD_INT 111
48240: PUSH
48241: LD_INT 112
48243: PUSH
48244: LD_INT 113
48246: PUSH
48247: LD_INT 114
48249: PUSH
48250: LD_INT 115
48252: PUSH
48253: LD_INT 116
48255: PUSH
48256: LD_INT 117
48258: PUSH
48259: LD_INT 118
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: PUSH
48282: EMPTY
48283: LIST
48284: LIST
48285: ST_TO_ADDR
48286: GO 48289
48288: POP
// end else
48289: GO 48520
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48291: LD_ADDR_VAR 0 2
48295: PUSH
48296: LD_INT 1
48298: PUSH
48299: LD_INT 2
48301: PUSH
48302: LD_INT 3
48304: PUSH
48305: LD_INT 4
48307: PUSH
48308: LD_INT 5
48310: PUSH
48311: LD_INT 6
48313: PUSH
48314: LD_INT 7
48316: PUSH
48317: LD_INT 8
48319: PUSH
48320: LD_INT 9
48322: PUSH
48323: LD_INT 10
48325: PUSH
48326: LD_INT 11
48328: PUSH
48329: LD_INT 12
48331: PUSH
48332: LD_INT 13
48334: PUSH
48335: LD_INT 14
48337: PUSH
48338: LD_INT 15
48340: PUSH
48341: LD_INT 16
48343: PUSH
48344: LD_INT 17
48346: PUSH
48347: LD_INT 18
48349: PUSH
48350: LD_INT 19
48352: PUSH
48353: LD_INT 20
48355: PUSH
48356: LD_INT 21
48358: PUSH
48359: LD_INT 22
48361: PUSH
48362: LD_INT 23
48364: PUSH
48365: LD_INT 24
48367: PUSH
48368: LD_INT 25
48370: PUSH
48371: LD_INT 26
48373: PUSH
48374: LD_INT 27
48376: PUSH
48377: LD_INT 28
48379: PUSH
48380: LD_INT 29
48382: PUSH
48383: LD_INT 30
48385: PUSH
48386: LD_INT 31
48388: PUSH
48389: LD_INT 32
48391: PUSH
48392: LD_INT 33
48394: PUSH
48395: LD_INT 34
48397: PUSH
48398: LD_INT 35
48400: PUSH
48401: LD_INT 36
48403: PUSH
48404: EMPTY
48405: LIST
48406: LIST
48407: LIST
48408: LIST
48409: LIST
48410: LIST
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: LIST
48419: LIST
48420: LIST
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: PUSH
48442: LD_INT 101
48444: PUSH
48445: LD_INT 102
48447: PUSH
48448: LD_INT 103
48450: PUSH
48451: LD_INT 104
48453: PUSH
48454: LD_INT 105
48456: PUSH
48457: LD_INT 106
48459: PUSH
48460: LD_INT 107
48462: PUSH
48463: LD_INT 108
48465: PUSH
48466: LD_INT 109
48468: PUSH
48469: LD_INT 110
48471: PUSH
48472: LD_INT 111
48474: PUSH
48475: LD_INT 112
48477: PUSH
48478: LD_INT 113
48480: PUSH
48481: LD_INT 114
48483: PUSH
48484: LD_INT 115
48486: PUSH
48487: LD_INT 116
48489: PUSH
48490: LD_INT 117
48492: PUSH
48493: LD_INT 118
48495: PUSH
48496: EMPTY
48497: LIST
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: LIST
48507: LIST
48508: LIST
48509: LIST
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: PUSH
48516: EMPTY
48517: LIST
48518: LIST
48519: ST_TO_ADDR
// if result then
48520: LD_VAR 0 2
48524: IFFALSE 49310
// begin normal :=  ;
48526: LD_ADDR_VAR 0 5
48530: PUSH
48531: LD_STRING 
48533: ST_TO_ADDR
// hardcore :=  ;
48534: LD_ADDR_VAR 0 6
48538: PUSH
48539: LD_STRING 
48541: ST_TO_ADDR
// active :=  ;
48542: LD_ADDR_VAR 0 7
48546: PUSH
48547: LD_STRING 
48549: ST_TO_ADDR
// for i = 1 to normalCounter do
48550: LD_ADDR_VAR 0 8
48554: PUSH
48555: DOUBLE
48556: LD_INT 1
48558: DEC
48559: ST_TO_ADDR
48560: LD_EXP 75
48564: PUSH
48565: FOR_TO
48566: IFFALSE 48667
// begin tmp := 0 ;
48568: LD_ADDR_VAR 0 3
48572: PUSH
48573: LD_STRING 0
48575: ST_TO_ADDR
// if result [ 1 ] then
48576: LD_VAR 0 2
48580: PUSH
48581: LD_INT 1
48583: ARRAY
48584: IFFALSE 48649
// if result [ 1 ] [ 1 ] = i then
48586: LD_VAR 0 2
48590: PUSH
48591: LD_INT 1
48593: ARRAY
48594: PUSH
48595: LD_INT 1
48597: ARRAY
48598: PUSH
48599: LD_VAR 0 8
48603: EQUAL
48604: IFFALSE 48649
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48606: LD_ADDR_VAR 0 2
48610: PUSH
48611: LD_VAR 0 2
48615: PPUSH
48616: LD_INT 1
48618: PPUSH
48619: LD_VAR 0 2
48623: PUSH
48624: LD_INT 1
48626: ARRAY
48627: PPUSH
48628: LD_INT 1
48630: PPUSH
48631: CALL_OW 3
48635: PPUSH
48636: CALL_OW 1
48640: ST_TO_ADDR
// tmp := 1 ;
48641: LD_ADDR_VAR 0 3
48645: PUSH
48646: LD_STRING 1
48648: ST_TO_ADDR
// end ; normal := normal & tmp ;
48649: LD_ADDR_VAR 0 5
48653: PUSH
48654: LD_VAR 0 5
48658: PUSH
48659: LD_VAR 0 3
48663: STR
48664: ST_TO_ADDR
// end ;
48665: GO 48565
48667: POP
48668: POP
// for i = 1 to hardcoreCounter do
48669: LD_ADDR_VAR 0 8
48673: PUSH
48674: DOUBLE
48675: LD_INT 1
48677: DEC
48678: ST_TO_ADDR
48679: LD_EXP 76
48683: PUSH
48684: FOR_TO
48685: IFFALSE 48790
// begin tmp := 0 ;
48687: LD_ADDR_VAR 0 3
48691: PUSH
48692: LD_STRING 0
48694: ST_TO_ADDR
// if result [ 2 ] then
48695: LD_VAR 0 2
48699: PUSH
48700: LD_INT 2
48702: ARRAY
48703: IFFALSE 48772
// if result [ 2 ] [ 1 ] = 100 + i then
48705: LD_VAR 0 2
48709: PUSH
48710: LD_INT 2
48712: ARRAY
48713: PUSH
48714: LD_INT 1
48716: ARRAY
48717: PUSH
48718: LD_INT 100
48720: PUSH
48721: LD_VAR 0 8
48725: PLUS
48726: EQUAL
48727: IFFALSE 48772
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48729: LD_ADDR_VAR 0 2
48733: PUSH
48734: LD_VAR 0 2
48738: PPUSH
48739: LD_INT 2
48741: PPUSH
48742: LD_VAR 0 2
48746: PUSH
48747: LD_INT 2
48749: ARRAY
48750: PPUSH
48751: LD_INT 1
48753: PPUSH
48754: CALL_OW 3
48758: PPUSH
48759: CALL_OW 1
48763: ST_TO_ADDR
// tmp := 1 ;
48764: LD_ADDR_VAR 0 3
48768: PUSH
48769: LD_STRING 1
48771: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48772: LD_ADDR_VAR 0 6
48776: PUSH
48777: LD_VAR 0 6
48781: PUSH
48782: LD_VAR 0 3
48786: STR
48787: ST_TO_ADDR
// end ;
48788: GO 48684
48790: POP
48791: POP
// if isGameLoad then
48792: LD_VAR 0 1
48796: IFFALSE 49271
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48798: LD_ADDR_VAR 0 4
48802: PUSH
48803: LD_EXP 79
48807: PUSH
48808: LD_EXP 78
48812: PUSH
48813: LD_EXP 80
48817: PUSH
48818: LD_EXP 77
48822: PUSH
48823: LD_EXP 81
48827: PUSH
48828: LD_EXP 82
48832: PUSH
48833: LD_EXP 83
48837: PUSH
48838: LD_EXP 84
48842: PUSH
48843: LD_EXP 85
48847: PUSH
48848: LD_EXP 86
48852: PUSH
48853: LD_EXP 87
48857: PUSH
48858: LD_EXP 88
48862: PUSH
48863: LD_EXP 89
48867: PUSH
48868: LD_EXP 90
48872: PUSH
48873: LD_EXP 98
48877: PUSH
48878: LD_EXP 99
48882: PUSH
48883: LD_EXP 100
48887: PUSH
48888: LD_EXP 101
48892: PUSH
48893: LD_EXP 103
48897: PUSH
48898: LD_EXP 104
48902: PUSH
48903: LD_EXP 105
48907: PUSH
48908: LD_EXP 108
48912: PUSH
48913: LD_EXP 110
48917: PUSH
48918: LD_EXP 111
48922: PUSH
48923: LD_EXP 112
48927: PUSH
48928: LD_EXP 114
48932: PUSH
48933: LD_EXP 115
48937: PUSH
48938: LD_EXP 118
48942: PUSH
48943: LD_EXP 119
48947: PUSH
48948: LD_EXP 120
48952: PUSH
48953: LD_EXP 121
48957: PUSH
48958: LD_EXP 122
48962: PUSH
48963: LD_EXP 123
48967: PUSH
48968: LD_EXP 124
48972: PUSH
48973: LD_EXP 125
48977: PUSH
48978: LD_EXP 126
48982: PUSH
48983: LD_EXP 91
48987: PUSH
48988: LD_EXP 92
48992: PUSH
48993: LD_EXP 95
48997: PUSH
48998: LD_EXP 96
49002: PUSH
49003: LD_EXP 97
49007: PUSH
49008: LD_EXP 93
49012: PUSH
49013: LD_EXP 94
49017: PUSH
49018: LD_EXP 102
49022: PUSH
49023: LD_EXP 106
49027: PUSH
49028: LD_EXP 107
49032: PUSH
49033: LD_EXP 109
49037: PUSH
49038: LD_EXP 113
49042: PUSH
49043: LD_EXP 116
49047: PUSH
49048: LD_EXP 117
49052: PUSH
49053: LD_EXP 127
49057: PUSH
49058: LD_EXP 128
49062: PUSH
49063: LD_EXP 129
49067: PUSH
49068: LD_EXP 130
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: ST_TO_ADDR
// tmp :=  ;
49129: LD_ADDR_VAR 0 3
49133: PUSH
49134: LD_STRING 
49136: ST_TO_ADDR
// for i = 1 to normalCounter do
49137: LD_ADDR_VAR 0 8
49141: PUSH
49142: DOUBLE
49143: LD_INT 1
49145: DEC
49146: ST_TO_ADDR
49147: LD_EXP 75
49151: PUSH
49152: FOR_TO
49153: IFFALSE 49189
// begin if flags [ i ] then
49155: LD_VAR 0 4
49159: PUSH
49160: LD_VAR 0 8
49164: ARRAY
49165: IFFALSE 49187
// tmp := tmp & i & ; ;
49167: LD_ADDR_VAR 0 3
49171: PUSH
49172: LD_VAR 0 3
49176: PUSH
49177: LD_VAR 0 8
49181: STR
49182: PUSH
49183: LD_STRING ;
49185: STR
49186: ST_TO_ADDR
// end ;
49187: GO 49152
49189: POP
49190: POP
// for i = 1 to hardcoreCounter do
49191: LD_ADDR_VAR 0 8
49195: PUSH
49196: DOUBLE
49197: LD_INT 1
49199: DEC
49200: ST_TO_ADDR
49201: LD_EXP 76
49205: PUSH
49206: FOR_TO
49207: IFFALSE 49253
// begin if flags [ normalCounter + i ] then
49209: LD_VAR 0 4
49213: PUSH
49214: LD_EXP 75
49218: PUSH
49219: LD_VAR 0 8
49223: PLUS
49224: ARRAY
49225: IFFALSE 49251
// tmp := tmp & ( 100 + i ) & ; ;
49227: LD_ADDR_VAR 0 3
49231: PUSH
49232: LD_VAR 0 3
49236: PUSH
49237: LD_INT 100
49239: PUSH
49240: LD_VAR 0 8
49244: PLUS
49245: STR
49246: PUSH
49247: LD_STRING ;
49249: STR
49250: ST_TO_ADDR
// end ;
49251: GO 49206
49253: POP
49254: POP
// if tmp then
49255: LD_VAR 0 3
49259: IFFALSE 49271
// active := tmp ;
49261: LD_ADDR_VAR 0 7
49265: PUSH
49266: LD_VAR 0 3
49270: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49271: LD_STRING getStreamItemsFromMission("
49273: PUSH
49274: LD_VAR 0 5
49278: STR
49279: PUSH
49280: LD_STRING ","
49282: STR
49283: PUSH
49284: LD_VAR 0 6
49288: STR
49289: PUSH
49290: LD_STRING ","
49292: STR
49293: PUSH
49294: LD_VAR 0 7
49298: STR
49299: PUSH
49300: LD_STRING ")
49302: STR
49303: PPUSH
49304: CALL_OW 559
// end else
49308: GO 49317
// ToLua ( getStreamItemsFromMission("","","") ) ;
49310: LD_STRING getStreamItemsFromMission("","","")
49312: PPUSH
49313: CALL_OW 559
// end ;
49317: LD_VAR 0 2
49321: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49322: LD_EXP 74
49326: PUSH
49327: LD_EXP 79
49331: AND
49332: IFFALSE 49456
49334: GO 49336
49336: DISABLE
49337: LD_INT 0
49339: PPUSH
49340: PPUSH
// begin enable ;
49341: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49342: LD_ADDR_VAR 0 2
49346: PUSH
49347: LD_INT 22
49349: PUSH
49350: LD_OWVAR 2
49354: PUSH
49355: EMPTY
49356: LIST
49357: LIST
49358: PUSH
49359: LD_INT 2
49361: PUSH
49362: LD_INT 34
49364: PUSH
49365: LD_INT 7
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PUSH
49372: LD_INT 34
49374: PUSH
49375: LD_INT 45
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 34
49384: PUSH
49385: LD_INT 28
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 34
49394: PUSH
49395: LD_INT 47
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PPUSH
49413: CALL_OW 69
49417: ST_TO_ADDR
// if not tmp then
49418: LD_VAR 0 2
49422: NOT
49423: IFFALSE 49427
// exit ;
49425: GO 49456
// for i in tmp do
49427: LD_ADDR_VAR 0 1
49431: PUSH
49432: LD_VAR 0 2
49436: PUSH
49437: FOR_IN
49438: IFFALSE 49454
// begin SetLives ( i , 0 ) ;
49440: LD_VAR 0 1
49444: PPUSH
49445: LD_INT 0
49447: PPUSH
49448: CALL_OW 234
// end ;
49452: GO 49437
49454: POP
49455: POP
// end ;
49456: PPOPN 2
49458: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49459: LD_EXP 74
49463: PUSH
49464: LD_EXP 80
49468: AND
49469: IFFALSE 49553
49471: GO 49473
49473: DISABLE
49474: LD_INT 0
49476: PPUSH
49477: PPUSH
// begin enable ;
49478: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49479: LD_ADDR_VAR 0 2
49483: PUSH
49484: LD_INT 22
49486: PUSH
49487: LD_OWVAR 2
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 32
49498: PUSH
49499: LD_INT 3
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: PPUSH
49510: CALL_OW 69
49514: ST_TO_ADDR
// if not tmp then
49515: LD_VAR 0 2
49519: NOT
49520: IFFALSE 49524
// exit ;
49522: GO 49553
// for i in tmp do
49524: LD_ADDR_VAR 0 1
49528: PUSH
49529: LD_VAR 0 2
49533: PUSH
49534: FOR_IN
49535: IFFALSE 49551
// begin SetLives ( i , 0 ) ;
49537: LD_VAR 0 1
49541: PPUSH
49542: LD_INT 0
49544: PPUSH
49545: CALL_OW 234
// end ;
49549: GO 49534
49551: POP
49552: POP
// end ;
49553: PPOPN 2
49555: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49556: LD_EXP 74
49560: PUSH
49561: LD_EXP 77
49565: AND
49566: IFFALSE 49659
49568: GO 49570
49570: DISABLE
49571: LD_INT 0
49573: PPUSH
// begin enable ;
49574: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49575: LD_ADDR_VAR 0 1
49579: PUSH
49580: LD_INT 22
49582: PUSH
49583: LD_OWVAR 2
49587: PUSH
49588: EMPTY
49589: LIST
49590: LIST
49591: PUSH
49592: LD_INT 2
49594: PUSH
49595: LD_INT 25
49597: PUSH
49598: LD_INT 5
49600: PUSH
49601: EMPTY
49602: LIST
49603: LIST
49604: PUSH
49605: LD_INT 25
49607: PUSH
49608: LD_INT 9
49610: PUSH
49611: EMPTY
49612: LIST
49613: LIST
49614: PUSH
49615: LD_INT 25
49617: PUSH
49618: LD_INT 8
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: PUSH
49631: EMPTY
49632: LIST
49633: LIST
49634: PPUSH
49635: CALL_OW 69
49639: PUSH
49640: FOR_IN
49641: IFFALSE 49657
// begin SetClass ( i , 1 ) ;
49643: LD_VAR 0 1
49647: PPUSH
49648: LD_INT 1
49650: PPUSH
49651: CALL_OW 336
// end ;
49655: GO 49640
49657: POP
49658: POP
// end ;
49659: PPOPN 1
49661: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49662: LD_EXP 74
49666: PUSH
49667: LD_EXP 78
49671: AND
49672: PUSH
49673: LD_OWVAR 65
49677: PUSH
49678: LD_INT 7
49680: LESS
49681: AND
49682: IFFALSE 49696
49684: GO 49686
49686: DISABLE
// begin enable ;
49687: ENABLE
// game_speed := 7 ;
49688: LD_ADDR_OWVAR 65
49692: PUSH
49693: LD_INT 7
49695: ST_TO_ADDR
// end ;
49696: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49697: LD_EXP 74
49701: PUSH
49702: LD_EXP 81
49706: AND
49707: IFFALSE 49909
49709: GO 49711
49711: DISABLE
49712: LD_INT 0
49714: PPUSH
49715: PPUSH
49716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49717: LD_ADDR_VAR 0 3
49721: PUSH
49722: LD_INT 81
49724: PUSH
49725: LD_OWVAR 2
49729: PUSH
49730: EMPTY
49731: LIST
49732: LIST
49733: PUSH
49734: LD_INT 21
49736: PUSH
49737: LD_INT 1
49739: PUSH
49740: EMPTY
49741: LIST
49742: LIST
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: CALL_OW 69
49752: ST_TO_ADDR
// if not tmp then
49753: LD_VAR 0 3
49757: NOT
49758: IFFALSE 49762
// exit ;
49760: GO 49909
// if tmp > 5 then
49762: LD_VAR 0 3
49766: PUSH
49767: LD_INT 5
49769: GREATER
49770: IFFALSE 49782
// k := 5 else
49772: LD_ADDR_VAR 0 2
49776: PUSH
49777: LD_INT 5
49779: ST_TO_ADDR
49780: GO 49792
// k := tmp ;
49782: LD_ADDR_VAR 0 2
49786: PUSH
49787: LD_VAR 0 3
49791: ST_TO_ADDR
// for i := 1 to k do
49792: LD_ADDR_VAR 0 1
49796: PUSH
49797: DOUBLE
49798: LD_INT 1
49800: DEC
49801: ST_TO_ADDR
49802: LD_VAR 0 2
49806: PUSH
49807: FOR_TO
49808: IFFALSE 49907
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49810: LD_VAR 0 3
49814: PUSH
49815: LD_VAR 0 1
49819: ARRAY
49820: PPUSH
49821: LD_VAR 0 1
49825: PUSH
49826: LD_INT 4
49828: MOD
49829: PUSH
49830: LD_INT 1
49832: PLUS
49833: PPUSH
49834: CALL_OW 259
49838: PUSH
49839: LD_INT 10
49841: LESS
49842: IFFALSE 49905
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49844: LD_VAR 0 3
49848: PUSH
49849: LD_VAR 0 1
49853: ARRAY
49854: PPUSH
49855: LD_VAR 0 1
49859: PUSH
49860: LD_INT 4
49862: MOD
49863: PUSH
49864: LD_INT 1
49866: PLUS
49867: PPUSH
49868: LD_VAR 0 3
49872: PUSH
49873: LD_VAR 0 1
49877: ARRAY
49878: PPUSH
49879: LD_VAR 0 1
49883: PUSH
49884: LD_INT 4
49886: MOD
49887: PUSH
49888: LD_INT 1
49890: PLUS
49891: PPUSH
49892: CALL_OW 259
49896: PUSH
49897: LD_INT 1
49899: PLUS
49900: PPUSH
49901: CALL_OW 237
49905: GO 49807
49907: POP
49908: POP
// end ;
49909: PPOPN 3
49911: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49912: LD_EXP 74
49916: PUSH
49917: LD_EXP 82
49921: AND
49922: IFFALSE 49942
49924: GO 49926
49926: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49927: LD_INT 4
49929: PPUSH
49930: LD_OWVAR 2
49934: PPUSH
49935: LD_INT 0
49937: PPUSH
49938: CALL_OW 324
49942: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49943: LD_EXP 74
49947: PUSH
49948: LD_EXP 111
49952: AND
49953: IFFALSE 49973
49955: GO 49957
49957: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49958: LD_INT 19
49960: PPUSH
49961: LD_OWVAR 2
49965: PPUSH
49966: LD_INT 0
49968: PPUSH
49969: CALL_OW 324
49973: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49974: LD_EXP 74
49978: PUSH
49979: LD_EXP 83
49983: AND
49984: IFFALSE 50086
49986: GO 49988
49988: DISABLE
49989: LD_INT 0
49991: PPUSH
49992: PPUSH
// begin enable ;
49993: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49994: LD_ADDR_VAR 0 2
49998: PUSH
49999: LD_INT 22
50001: PUSH
50002: LD_OWVAR 2
50006: PUSH
50007: EMPTY
50008: LIST
50009: LIST
50010: PUSH
50011: LD_INT 2
50013: PUSH
50014: LD_INT 34
50016: PUSH
50017: LD_INT 11
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: PUSH
50024: LD_INT 34
50026: PUSH
50027: LD_INT 30
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: LIST
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PPUSH
50043: CALL_OW 69
50047: ST_TO_ADDR
// if not tmp then
50048: LD_VAR 0 2
50052: NOT
50053: IFFALSE 50057
// exit ;
50055: GO 50086
// for i in tmp do
50057: LD_ADDR_VAR 0 1
50061: PUSH
50062: LD_VAR 0 2
50066: PUSH
50067: FOR_IN
50068: IFFALSE 50084
// begin SetLives ( i , 0 ) ;
50070: LD_VAR 0 1
50074: PPUSH
50075: LD_INT 0
50077: PPUSH
50078: CALL_OW 234
// end ;
50082: GO 50067
50084: POP
50085: POP
// end ;
50086: PPOPN 2
50088: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50089: LD_EXP 74
50093: PUSH
50094: LD_EXP 84
50098: AND
50099: IFFALSE 50119
50101: GO 50103
50103: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50104: LD_INT 32
50106: PPUSH
50107: LD_OWVAR 2
50111: PPUSH
50112: LD_INT 0
50114: PPUSH
50115: CALL_OW 324
50119: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50120: LD_EXP 74
50124: PUSH
50125: LD_EXP 85
50129: AND
50130: IFFALSE 50311
50132: GO 50134
50134: DISABLE
50135: LD_INT 0
50137: PPUSH
50138: PPUSH
50139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50140: LD_ADDR_VAR 0 2
50144: PUSH
50145: LD_INT 22
50147: PUSH
50148: LD_OWVAR 2
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PUSH
50157: LD_INT 33
50159: PUSH
50160: LD_INT 3
50162: PUSH
50163: EMPTY
50164: LIST
50165: LIST
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PPUSH
50171: CALL_OW 69
50175: ST_TO_ADDR
// if not tmp then
50176: LD_VAR 0 2
50180: NOT
50181: IFFALSE 50185
// exit ;
50183: GO 50311
// side := 0 ;
50185: LD_ADDR_VAR 0 3
50189: PUSH
50190: LD_INT 0
50192: ST_TO_ADDR
// for i := 1 to 8 do
50193: LD_ADDR_VAR 0 1
50197: PUSH
50198: DOUBLE
50199: LD_INT 1
50201: DEC
50202: ST_TO_ADDR
50203: LD_INT 8
50205: PUSH
50206: FOR_TO
50207: IFFALSE 50255
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50209: LD_OWVAR 2
50213: PUSH
50214: LD_VAR 0 1
50218: NONEQUAL
50219: PUSH
50220: LD_OWVAR 2
50224: PPUSH
50225: LD_VAR 0 1
50229: PPUSH
50230: CALL_OW 81
50234: PUSH
50235: LD_INT 2
50237: EQUAL
50238: AND
50239: IFFALSE 50253
// begin side := i ;
50241: LD_ADDR_VAR 0 3
50245: PUSH
50246: LD_VAR 0 1
50250: ST_TO_ADDR
// break ;
50251: GO 50255
// end ;
50253: GO 50206
50255: POP
50256: POP
// if not side then
50257: LD_VAR 0 3
50261: NOT
50262: IFFALSE 50266
// exit ;
50264: GO 50311
// for i := 1 to tmp do
50266: LD_ADDR_VAR 0 1
50270: PUSH
50271: DOUBLE
50272: LD_INT 1
50274: DEC
50275: ST_TO_ADDR
50276: LD_VAR 0 2
50280: PUSH
50281: FOR_TO
50282: IFFALSE 50309
// if Prob ( 60 ) then
50284: LD_INT 60
50286: PPUSH
50287: CALL_OW 13
50291: IFFALSE 50307
// SetSide ( i , side ) ;
50293: LD_VAR 0 1
50297: PPUSH
50298: LD_VAR 0 3
50302: PPUSH
50303: CALL_OW 235
50307: GO 50281
50309: POP
50310: POP
// end ;
50311: PPOPN 3
50313: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50314: LD_EXP 74
50318: PUSH
50319: LD_EXP 87
50323: AND
50324: IFFALSE 50443
50326: GO 50328
50328: DISABLE
50329: LD_INT 0
50331: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50332: LD_ADDR_VAR 0 1
50336: PUSH
50337: LD_INT 22
50339: PUSH
50340: LD_OWVAR 2
50344: PUSH
50345: EMPTY
50346: LIST
50347: LIST
50348: PUSH
50349: LD_INT 21
50351: PUSH
50352: LD_INT 1
50354: PUSH
50355: EMPTY
50356: LIST
50357: LIST
50358: PUSH
50359: LD_INT 3
50361: PUSH
50362: LD_INT 23
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: LIST
50380: PPUSH
50381: CALL_OW 69
50385: PUSH
50386: FOR_IN
50387: IFFALSE 50441
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50389: LD_VAR 0 1
50393: PPUSH
50394: CALL_OW 257
50398: PUSH
50399: LD_INT 1
50401: PUSH
50402: LD_INT 2
50404: PUSH
50405: LD_INT 3
50407: PUSH
50408: LD_INT 4
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: LIST
50415: LIST
50416: IN
50417: IFFALSE 50439
// SetClass ( un , rand ( 1 , 4 ) ) ;
50419: LD_VAR 0 1
50423: PPUSH
50424: LD_INT 1
50426: PPUSH
50427: LD_INT 4
50429: PPUSH
50430: CALL_OW 12
50434: PPUSH
50435: CALL_OW 336
50439: GO 50386
50441: POP
50442: POP
// end ;
50443: PPOPN 1
50445: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50446: LD_EXP 74
50450: PUSH
50451: LD_EXP 86
50455: AND
50456: IFFALSE 50535
50458: GO 50460
50460: DISABLE
50461: LD_INT 0
50463: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50464: LD_ADDR_VAR 0 1
50468: PUSH
50469: LD_INT 22
50471: PUSH
50472: LD_OWVAR 2
50476: PUSH
50477: EMPTY
50478: LIST
50479: LIST
50480: PUSH
50481: LD_INT 21
50483: PUSH
50484: LD_INT 3
50486: PUSH
50487: EMPTY
50488: LIST
50489: LIST
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: PPUSH
50495: CALL_OW 69
50499: ST_TO_ADDR
// if not tmp then
50500: LD_VAR 0 1
50504: NOT
50505: IFFALSE 50509
// exit ;
50507: GO 50535
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50509: LD_VAR 0 1
50513: PUSH
50514: LD_INT 1
50516: PPUSH
50517: LD_VAR 0 1
50521: PPUSH
50522: CALL_OW 12
50526: ARRAY
50527: PPUSH
50528: LD_INT 100
50530: PPUSH
50531: CALL_OW 234
// end ;
50535: PPOPN 1
50537: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50538: LD_EXP 74
50542: PUSH
50543: LD_EXP 88
50547: AND
50548: IFFALSE 50646
50550: GO 50552
50552: DISABLE
50553: LD_INT 0
50555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50556: LD_ADDR_VAR 0 1
50560: PUSH
50561: LD_INT 22
50563: PUSH
50564: LD_OWVAR 2
50568: PUSH
50569: EMPTY
50570: LIST
50571: LIST
50572: PUSH
50573: LD_INT 21
50575: PUSH
50576: LD_INT 1
50578: PUSH
50579: EMPTY
50580: LIST
50581: LIST
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: PPUSH
50587: CALL_OW 69
50591: ST_TO_ADDR
// if not tmp then
50592: LD_VAR 0 1
50596: NOT
50597: IFFALSE 50601
// exit ;
50599: GO 50646
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50601: LD_VAR 0 1
50605: PUSH
50606: LD_INT 1
50608: PPUSH
50609: LD_VAR 0 1
50613: PPUSH
50614: CALL_OW 12
50618: ARRAY
50619: PPUSH
50620: LD_INT 1
50622: PPUSH
50623: LD_INT 4
50625: PPUSH
50626: CALL_OW 12
50630: PPUSH
50631: LD_INT 3000
50633: PPUSH
50634: LD_INT 9000
50636: PPUSH
50637: CALL_OW 12
50641: PPUSH
50642: CALL_OW 492
// end ;
50646: PPOPN 1
50648: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50649: LD_EXP 74
50653: PUSH
50654: LD_EXP 89
50658: AND
50659: IFFALSE 50679
50661: GO 50663
50663: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50664: LD_INT 1
50666: PPUSH
50667: LD_OWVAR 2
50671: PPUSH
50672: LD_INT 0
50674: PPUSH
50675: CALL_OW 324
50679: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50680: LD_EXP 74
50684: PUSH
50685: LD_EXP 90
50689: AND
50690: IFFALSE 50773
50692: GO 50694
50694: DISABLE
50695: LD_INT 0
50697: PPUSH
50698: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50699: LD_ADDR_VAR 0 2
50703: PUSH
50704: LD_INT 22
50706: PUSH
50707: LD_OWVAR 2
50711: PUSH
50712: EMPTY
50713: LIST
50714: LIST
50715: PUSH
50716: LD_INT 21
50718: PUSH
50719: LD_INT 3
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: PUSH
50726: EMPTY
50727: LIST
50728: LIST
50729: PPUSH
50730: CALL_OW 69
50734: ST_TO_ADDR
// if not tmp then
50735: LD_VAR 0 2
50739: NOT
50740: IFFALSE 50744
// exit ;
50742: GO 50773
// for i in tmp do
50744: LD_ADDR_VAR 0 1
50748: PUSH
50749: LD_VAR 0 2
50753: PUSH
50754: FOR_IN
50755: IFFALSE 50771
// SetBLevel ( i , 10 ) ;
50757: LD_VAR 0 1
50761: PPUSH
50762: LD_INT 10
50764: PPUSH
50765: CALL_OW 241
50769: GO 50754
50771: POP
50772: POP
// end ;
50773: PPOPN 2
50775: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50776: LD_EXP 74
50780: PUSH
50781: LD_EXP 91
50785: AND
50786: IFFALSE 50897
50788: GO 50790
50790: DISABLE
50791: LD_INT 0
50793: PPUSH
50794: PPUSH
50795: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50796: LD_ADDR_VAR 0 3
50800: PUSH
50801: LD_INT 22
50803: PUSH
50804: LD_OWVAR 2
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: PUSH
50813: LD_INT 25
50815: PUSH
50816: LD_INT 1
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: PPUSH
50827: CALL_OW 69
50831: ST_TO_ADDR
// if not tmp then
50832: LD_VAR 0 3
50836: NOT
50837: IFFALSE 50841
// exit ;
50839: GO 50897
// un := tmp [ rand ( 1 , tmp ) ] ;
50841: LD_ADDR_VAR 0 2
50845: PUSH
50846: LD_VAR 0 3
50850: PUSH
50851: LD_INT 1
50853: PPUSH
50854: LD_VAR 0 3
50858: PPUSH
50859: CALL_OW 12
50863: ARRAY
50864: ST_TO_ADDR
// if Crawls ( un ) then
50865: LD_VAR 0 2
50869: PPUSH
50870: CALL_OW 318
50874: IFFALSE 50885
// ComWalk ( un ) ;
50876: LD_VAR 0 2
50880: PPUSH
50881: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50885: LD_VAR 0 2
50889: PPUSH
50890: LD_INT 5
50892: PPUSH
50893: CALL_OW 336
// end ;
50897: PPOPN 3
50899: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50900: LD_EXP 74
50904: PUSH
50905: LD_EXP 92
50909: AND
50910: PUSH
50911: LD_OWVAR 67
50915: PUSH
50916: LD_INT 4
50918: LESS
50919: AND
50920: IFFALSE 50939
50922: GO 50924
50924: DISABLE
// begin Difficulty := Difficulty + 1 ;
50925: LD_ADDR_OWVAR 67
50929: PUSH
50930: LD_OWVAR 67
50934: PUSH
50935: LD_INT 1
50937: PLUS
50938: ST_TO_ADDR
// end ;
50939: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50940: LD_EXP 74
50944: PUSH
50945: LD_EXP 93
50949: AND
50950: IFFALSE 51053
50952: GO 50954
50954: DISABLE
50955: LD_INT 0
50957: PPUSH
// begin for i := 1 to 5 do
50958: LD_ADDR_VAR 0 1
50962: PUSH
50963: DOUBLE
50964: LD_INT 1
50966: DEC
50967: ST_TO_ADDR
50968: LD_INT 5
50970: PUSH
50971: FOR_TO
50972: IFFALSE 51051
// begin uc_nation := nation_nature ;
50974: LD_ADDR_OWVAR 21
50978: PUSH
50979: LD_INT 0
50981: ST_TO_ADDR
// uc_side := 0 ;
50982: LD_ADDR_OWVAR 20
50986: PUSH
50987: LD_INT 0
50989: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50990: LD_ADDR_OWVAR 29
50994: PUSH
50995: LD_INT 12
50997: PUSH
50998: LD_INT 12
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: ST_TO_ADDR
// hc_agressivity := 20 ;
51005: LD_ADDR_OWVAR 35
51009: PUSH
51010: LD_INT 20
51012: ST_TO_ADDR
// hc_class := class_tiger ;
51013: LD_ADDR_OWVAR 28
51017: PUSH
51018: LD_INT 14
51020: ST_TO_ADDR
// hc_gallery :=  ;
51021: LD_ADDR_OWVAR 33
51025: PUSH
51026: LD_STRING 
51028: ST_TO_ADDR
// hc_name :=  ;
51029: LD_ADDR_OWVAR 26
51033: PUSH
51034: LD_STRING 
51036: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51037: CALL_OW 44
51041: PPUSH
51042: LD_INT 0
51044: PPUSH
51045: CALL_OW 51
// end ;
51049: GO 50971
51051: POP
51052: POP
// end ;
51053: PPOPN 1
51055: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51056: LD_EXP 74
51060: PUSH
51061: LD_EXP 94
51065: AND
51066: IFFALSE 51075
51068: GO 51070
51070: DISABLE
// StreamSibBomb ;
51071: CALL 51076 0 0
51075: END
// export function StreamSibBomb ; var i , x , y ; begin
51076: LD_INT 0
51078: PPUSH
51079: PPUSH
51080: PPUSH
51081: PPUSH
// result := false ;
51082: LD_ADDR_VAR 0 1
51086: PUSH
51087: LD_INT 0
51089: ST_TO_ADDR
// for i := 1 to 16 do
51090: LD_ADDR_VAR 0 2
51094: PUSH
51095: DOUBLE
51096: LD_INT 1
51098: DEC
51099: ST_TO_ADDR
51100: LD_INT 16
51102: PUSH
51103: FOR_TO
51104: IFFALSE 51303
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51106: LD_ADDR_VAR 0 3
51110: PUSH
51111: LD_INT 10
51113: PUSH
51114: LD_INT 20
51116: PUSH
51117: LD_INT 30
51119: PUSH
51120: LD_INT 40
51122: PUSH
51123: LD_INT 50
51125: PUSH
51126: LD_INT 60
51128: PUSH
51129: LD_INT 70
51131: PUSH
51132: LD_INT 80
51134: PUSH
51135: LD_INT 90
51137: PUSH
51138: LD_INT 100
51140: PUSH
51141: LD_INT 110
51143: PUSH
51144: LD_INT 120
51146: PUSH
51147: LD_INT 130
51149: PUSH
51150: LD_INT 140
51152: PUSH
51153: LD_INT 150
51155: PUSH
51156: EMPTY
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: PUSH
51173: LD_INT 1
51175: PPUSH
51176: LD_INT 15
51178: PPUSH
51179: CALL_OW 12
51183: ARRAY
51184: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51185: LD_ADDR_VAR 0 4
51189: PUSH
51190: LD_INT 10
51192: PUSH
51193: LD_INT 20
51195: PUSH
51196: LD_INT 30
51198: PUSH
51199: LD_INT 40
51201: PUSH
51202: LD_INT 50
51204: PUSH
51205: LD_INT 60
51207: PUSH
51208: LD_INT 70
51210: PUSH
51211: LD_INT 80
51213: PUSH
51214: LD_INT 90
51216: PUSH
51217: LD_INT 100
51219: PUSH
51220: LD_INT 110
51222: PUSH
51223: LD_INT 120
51225: PUSH
51226: LD_INT 130
51228: PUSH
51229: LD_INT 140
51231: PUSH
51232: LD_INT 150
51234: PUSH
51235: EMPTY
51236: LIST
51237: LIST
51238: LIST
51239: LIST
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: LIST
51248: LIST
51249: LIST
51250: LIST
51251: PUSH
51252: LD_INT 1
51254: PPUSH
51255: LD_INT 15
51257: PPUSH
51258: CALL_OW 12
51262: ARRAY
51263: ST_TO_ADDR
// if ValidHex ( x , y ) then
51264: LD_VAR 0 3
51268: PPUSH
51269: LD_VAR 0 4
51273: PPUSH
51274: CALL_OW 488
51278: IFFALSE 51301
// begin result := [ x , y ] ;
51280: LD_ADDR_VAR 0 1
51284: PUSH
51285: LD_VAR 0 3
51289: PUSH
51290: LD_VAR 0 4
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: ST_TO_ADDR
// break ;
51299: GO 51303
// end ; end ;
51301: GO 51103
51303: POP
51304: POP
// if result then
51305: LD_VAR 0 1
51309: IFFALSE 51369
// begin ToLua ( playSibBomb() ) ;
51311: LD_STRING playSibBomb()
51313: PPUSH
51314: CALL_OW 559
// wait ( 0 0$14 ) ;
51318: LD_INT 490
51320: PPUSH
51321: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51325: LD_VAR 0 1
51329: PUSH
51330: LD_INT 1
51332: ARRAY
51333: PPUSH
51334: LD_VAR 0 1
51338: PUSH
51339: LD_INT 2
51341: ARRAY
51342: PPUSH
51343: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51347: LD_VAR 0 1
51351: PUSH
51352: LD_INT 1
51354: ARRAY
51355: PPUSH
51356: LD_VAR 0 1
51360: PUSH
51361: LD_INT 2
51363: ARRAY
51364: PPUSH
51365: CALL_OW 429
// end ; end ;
51369: LD_VAR 0 1
51373: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51374: LD_EXP 74
51378: PUSH
51379: LD_EXP 96
51383: AND
51384: IFFALSE 51396
51386: GO 51388
51388: DISABLE
// YouLost (  ) ;
51389: LD_STRING 
51391: PPUSH
51392: CALL_OW 104
51396: END
// every 0 0$1 trigger StreamModeActive and sFog do
51397: LD_EXP 74
51401: PUSH
51402: LD_EXP 95
51406: AND
51407: IFFALSE 51421
51409: GO 51411
51411: DISABLE
// FogOff ( your_side ) ;
51412: LD_OWVAR 2
51416: PPUSH
51417: CALL_OW 344
51421: END
// every 0 0$1 trigger StreamModeActive and sSun do
51422: LD_EXP 74
51426: PUSH
51427: LD_EXP 97
51431: AND
51432: IFFALSE 51460
51434: GO 51436
51436: DISABLE
// begin solar_recharge_percent := 0 ;
51437: LD_ADDR_OWVAR 79
51441: PUSH
51442: LD_INT 0
51444: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51445: LD_INT 10500
51447: PPUSH
51448: CALL_OW 67
// solar_recharge_percent := 100 ;
51452: LD_ADDR_OWVAR 79
51456: PUSH
51457: LD_INT 100
51459: ST_TO_ADDR
// end ;
51460: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51461: LD_EXP 74
51465: PUSH
51466: LD_EXP 98
51470: AND
51471: IFFALSE 51710
51473: GO 51475
51475: DISABLE
51476: LD_INT 0
51478: PPUSH
51479: PPUSH
51480: PPUSH
// begin tmp := [ ] ;
51481: LD_ADDR_VAR 0 3
51485: PUSH
51486: EMPTY
51487: ST_TO_ADDR
// for i := 1 to 6 do
51488: LD_ADDR_VAR 0 1
51492: PUSH
51493: DOUBLE
51494: LD_INT 1
51496: DEC
51497: ST_TO_ADDR
51498: LD_INT 6
51500: PUSH
51501: FOR_TO
51502: IFFALSE 51607
// begin uc_nation := nation_nature ;
51504: LD_ADDR_OWVAR 21
51508: PUSH
51509: LD_INT 0
51511: ST_TO_ADDR
// uc_side := 0 ;
51512: LD_ADDR_OWVAR 20
51516: PUSH
51517: LD_INT 0
51519: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51520: LD_ADDR_OWVAR 29
51524: PUSH
51525: LD_INT 12
51527: PUSH
51528: LD_INT 12
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: ST_TO_ADDR
// hc_agressivity := 20 ;
51535: LD_ADDR_OWVAR 35
51539: PUSH
51540: LD_INT 20
51542: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51543: LD_ADDR_OWVAR 28
51547: PUSH
51548: LD_INT 17
51550: ST_TO_ADDR
// hc_gallery :=  ;
51551: LD_ADDR_OWVAR 33
51555: PUSH
51556: LD_STRING 
51558: ST_TO_ADDR
// hc_name :=  ;
51559: LD_ADDR_OWVAR 26
51563: PUSH
51564: LD_STRING 
51566: ST_TO_ADDR
// un := CreateHuman ;
51567: LD_ADDR_VAR 0 2
51571: PUSH
51572: CALL_OW 44
51576: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51577: LD_VAR 0 2
51581: PPUSH
51582: LD_INT 1
51584: PPUSH
51585: CALL_OW 51
// tmp := tmp ^ un ;
51589: LD_ADDR_VAR 0 3
51593: PUSH
51594: LD_VAR 0 3
51598: PUSH
51599: LD_VAR 0 2
51603: ADD
51604: ST_TO_ADDR
// end ;
51605: GO 51501
51607: POP
51608: POP
// repeat wait ( 0 0$1 ) ;
51609: LD_INT 35
51611: PPUSH
51612: CALL_OW 67
// for un in tmp do
51616: LD_ADDR_VAR 0 2
51620: PUSH
51621: LD_VAR 0 3
51625: PUSH
51626: FOR_IN
51627: IFFALSE 51701
// begin if IsDead ( un ) then
51629: LD_VAR 0 2
51633: PPUSH
51634: CALL_OW 301
51638: IFFALSE 51658
// begin tmp := tmp diff un ;
51640: LD_ADDR_VAR 0 3
51644: PUSH
51645: LD_VAR 0 3
51649: PUSH
51650: LD_VAR 0 2
51654: DIFF
51655: ST_TO_ADDR
// continue ;
51656: GO 51626
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51658: LD_VAR 0 2
51662: PPUSH
51663: LD_INT 3
51665: PUSH
51666: LD_INT 22
51668: PUSH
51669: LD_INT 0
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PPUSH
51680: CALL_OW 69
51684: PPUSH
51685: LD_VAR 0 2
51689: PPUSH
51690: CALL_OW 74
51694: PPUSH
51695: CALL_OW 115
// end ;
51699: GO 51626
51701: POP
51702: POP
// until not tmp ;
51703: LD_VAR 0 3
51707: NOT
51708: IFFALSE 51609
// end ;
51710: PPOPN 3
51712: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51713: LD_EXP 74
51717: PUSH
51718: LD_EXP 99
51722: AND
51723: IFFALSE 51777
51725: GO 51727
51727: DISABLE
// begin ToLua ( displayTroll(); ) ;
51728: LD_STRING displayTroll();
51730: PPUSH
51731: CALL_OW 559
// wait ( 3 3$00 ) ;
51735: LD_INT 6300
51737: PPUSH
51738: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51742: LD_STRING hideTroll();
51744: PPUSH
51745: CALL_OW 559
// wait ( 1 1$00 ) ;
51749: LD_INT 2100
51751: PPUSH
51752: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51756: LD_STRING displayTroll();
51758: PPUSH
51759: CALL_OW 559
// wait ( 1 1$00 ) ;
51763: LD_INT 2100
51765: PPUSH
51766: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51770: LD_STRING hideTroll();
51772: PPUSH
51773: CALL_OW 559
// end ;
51777: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51778: LD_EXP 74
51782: PUSH
51783: LD_EXP 100
51787: AND
51788: IFFALSE 51851
51790: GO 51792
51792: DISABLE
51793: LD_INT 0
51795: PPUSH
// begin p := 0 ;
51796: LD_ADDR_VAR 0 1
51800: PUSH
51801: LD_INT 0
51803: ST_TO_ADDR
// repeat game_speed := 1 ;
51804: LD_ADDR_OWVAR 65
51808: PUSH
51809: LD_INT 1
51811: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51812: LD_INT 35
51814: PPUSH
51815: CALL_OW 67
// p := p + 1 ;
51819: LD_ADDR_VAR 0 1
51823: PUSH
51824: LD_VAR 0 1
51828: PUSH
51829: LD_INT 1
51831: PLUS
51832: ST_TO_ADDR
// until p >= 60 ;
51833: LD_VAR 0 1
51837: PUSH
51838: LD_INT 60
51840: GREATEREQUAL
51841: IFFALSE 51804
// game_speed := 4 ;
51843: LD_ADDR_OWVAR 65
51847: PUSH
51848: LD_INT 4
51850: ST_TO_ADDR
// end ;
51851: PPOPN 1
51853: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51854: LD_EXP 74
51858: PUSH
51859: LD_EXP 101
51863: AND
51864: IFFALSE 52010
51866: GO 51868
51868: DISABLE
51869: LD_INT 0
51871: PPUSH
51872: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51873: LD_ADDR_VAR 0 1
51877: PUSH
51878: LD_INT 22
51880: PUSH
51881: LD_OWVAR 2
51885: PUSH
51886: EMPTY
51887: LIST
51888: LIST
51889: PUSH
51890: LD_INT 2
51892: PUSH
51893: LD_INT 30
51895: PUSH
51896: LD_INT 0
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: PUSH
51903: LD_INT 30
51905: PUSH
51906: LD_INT 1
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: LIST
51917: PUSH
51918: EMPTY
51919: LIST
51920: LIST
51921: PPUSH
51922: CALL_OW 69
51926: ST_TO_ADDR
// if not depot then
51927: LD_VAR 0 1
51931: NOT
51932: IFFALSE 51936
// exit ;
51934: GO 52010
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51936: LD_ADDR_VAR 0 2
51940: PUSH
51941: LD_VAR 0 1
51945: PUSH
51946: LD_INT 1
51948: PPUSH
51949: LD_VAR 0 1
51953: PPUSH
51954: CALL_OW 12
51958: ARRAY
51959: PPUSH
51960: CALL_OW 274
51964: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51965: LD_VAR 0 2
51969: PPUSH
51970: LD_INT 1
51972: PPUSH
51973: LD_INT 0
51975: PPUSH
51976: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51980: LD_VAR 0 2
51984: PPUSH
51985: LD_INT 2
51987: PPUSH
51988: LD_INT 0
51990: PPUSH
51991: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51995: LD_VAR 0 2
51999: PPUSH
52000: LD_INT 3
52002: PPUSH
52003: LD_INT 0
52005: PPUSH
52006: CALL_OW 277
// end ;
52010: PPOPN 2
52012: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52013: LD_EXP 74
52017: PUSH
52018: LD_EXP 102
52022: AND
52023: IFFALSE 52120
52025: GO 52027
52027: DISABLE
52028: LD_INT 0
52030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52031: LD_ADDR_VAR 0 1
52035: PUSH
52036: LD_INT 22
52038: PUSH
52039: LD_OWVAR 2
52043: PUSH
52044: EMPTY
52045: LIST
52046: LIST
52047: PUSH
52048: LD_INT 21
52050: PUSH
52051: LD_INT 1
52053: PUSH
52054: EMPTY
52055: LIST
52056: LIST
52057: PUSH
52058: LD_INT 3
52060: PUSH
52061: LD_INT 23
52063: PUSH
52064: LD_INT 0
52066: PUSH
52067: EMPTY
52068: LIST
52069: LIST
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: PUSH
52075: EMPTY
52076: LIST
52077: LIST
52078: LIST
52079: PPUSH
52080: CALL_OW 69
52084: ST_TO_ADDR
// if not tmp then
52085: LD_VAR 0 1
52089: NOT
52090: IFFALSE 52094
// exit ;
52092: GO 52120
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52094: LD_VAR 0 1
52098: PUSH
52099: LD_INT 1
52101: PPUSH
52102: LD_VAR 0 1
52106: PPUSH
52107: CALL_OW 12
52111: ARRAY
52112: PPUSH
52113: LD_INT 200
52115: PPUSH
52116: CALL_OW 234
// end ;
52120: PPOPN 1
52122: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52123: LD_EXP 74
52127: PUSH
52128: LD_EXP 103
52132: AND
52133: IFFALSE 52212
52135: GO 52137
52137: DISABLE
52138: LD_INT 0
52140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52141: LD_ADDR_VAR 0 1
52145: PUSH
52146: LD_INT 22
52148: PUSH
52149: LD_OWVAR 2
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: PUSH
52158: LD_INT 21
52160: PUSH
52161: LD_INT 2
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: PUSH
52168: EMPTY
52169: LIST
52170: LIST
52171: PPUSH
52172: CALL_OW 69
52176: ST_TO_ADDR
// if not tmp then
52177: LD_VAR 0 1
52181: NOT
52182: IFFALSE 52186
// exit ;
52184: GO 52212
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52186: LD_VAR 0 1
52190: PUSH
52191: LD_INT 1
52193: PPUSH
52194: LD_VAR 0 1
52198: PPUSH
52199: CALL_OW 12
52203: ARRAY
52204: PPUSH
52205: LD_INT 60
52207: PPUSH
52208: CALL_OW 234
// end ;
52212: PPOPN 1
52214: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52215: LD_EXP 74
52219: PUSH
52220: LD_EXP 104
52224: AND
52225: IFFALSE 52324
52227: GO 52229
52229: DISABLE
52230: LD_INT 0
52232: PPUSH
52233: PPUSH
// begin enable ;
52234: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52235: LD_ADDR_VAR 0 1
52239: PUSH
52240: LD_INT 22
52242: PUSH
52243: LD_OWVAR 2
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: PUSH
52252: LD_INT 61
52254: PUSH
52255: EMPTY
52256: LIST
52257: PUSH
52258: LD_INT 33
52260: PUSH
52261: LD_INT 2
52263: PUSH
52264: EMPTY
52265: LIST
52266: LIST
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: LIST
52272: PPUSH
52273: CALL_OW 69
52277: ST_TO_ADDR
// if not tmp then
52278: LD_VAR 0 1
52282: NOT
52283: IFFALSE 52287
// exit ;
52285: GO 52324
// for i in tmp do
52287: LD_ADDR_VAR 0 2
52291: PUSH
52292: LD_VAR 0 1
52296: PUSH
52297: FOR_IN
52298: IFFALSE 52322
// if IsControledBy ( i ) then
52300: LD_VAR 0 2
52304: PPUSH
52305: CALL_OW 312
52309: IFFALSE 52320
// ComUnlink ( i ) ;
52311: LD_VAR 0 2
52315: PPUSH
52316: CALL_OW 136
52320: GO 52297
52322: POP
52323: POP
// end ;
52324: PPOPN 2
52326: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52327: LD_EXP 74
52331: PUSH
52332: LD_EXP 105
52336: AND
52337: IFFALSE 52477
52339: GO 52341
52341: DISABLE
52342: LD_INT 0
52344: PPUSH
52345: PPUSH
// begin ToLua ( displayPowell(); ) ;
52346: LD_STRING displayPowell();
52348: PPUSH
52349: CALL_OW 559
// uc_side := 0 ;
52353: LD_ADDR_OWVAR 20
52357: PUSH
52358: LD_INT 0
52360: ST_TO_ADDR
// uc_nation := 2 ;
52361: LD_ADDR_OWVAR 21
52365: PUSH
52366: LD_INT 2
52368: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52369: LD_ADDR_OWVAR 37
52373: PUSH
52374: LD_INT 14
52376: ST_TO_ADDR
// vc_engine := engine_siberite ;
52377: LD_ADDR_OWVAR 39
52381: PUSH
52382: LD_INT 3
52384: ST_TO_ADDR
// vc_control := control_apeman ;
52385: LD_ADDR_OWVAR 38
52389: PUSH
52390: LD_INT 5
52392: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52393: LD_ADDR_OWVAR 40
52397: PUSH
52398: LD_INT 29
52400: ST_TO_ADDR
// un := CreateVehicle ;
52401: LD_ADDR_VAR 0 2
52405: PUSH
52406: CALL_OW 45
52410: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52411: LD_VAR 0 2
52415: PPUSH
52416: LD_INT 1
52418: PPUSH
52419: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52423: LD_INT 35
52425: PPUSH
52426: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52430: LD_VAR 0 2
52434: PPUSH
52435: LD_INT 22
52437: PUSH
52438: LD_OWVAR 2
52442: PUSH
52443: EMPTY
52444: LIST
52445: LIST
52446: PPUSH
52447: CALL_OW 69
52451: PPUSH
52452: LD_VAR 0 2
52456: PPUSH
52457: CALL_OW 74
52461: PPUSH
52462: CALL_OW 115
// until IsDead ( un ) ;
52466: LD_VAR 0 2
52470: PPUSH
52471: CALL_OW 301
52475: IFFALSE 52423
// end ;
52477: PPOPN 2
52479: END
// every 0 0$1 trigger StreamModeActive and sStu do
52480: LD_EXP 74
52484: PUSH
52485: LD_EXP 113
52489: AND
52490: IFFALSE 52506
52492: GO 52494
52494: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52495: LD_STRING displayStucuk();
52497: PPUSH
52498: CALL_OW 559
// ResetFog ;
52502: CALL_OW 335
// end ;
52506: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52507: LD_EXP 74
52511: PUSH
52512: LD_EXP 106
52516: AND
52517: IFFALSE 52658
52519: GO 52521
52521: DISABLE
52522: LD_INT 0
52524: PPUSH
52525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52526: LD_ADDR_VAR 0 2
52530: PUSH
52531: LD_INT 22
52533: PUSH
52534: LD_OWVAR 2
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: PUSH
52543: LD_INT 21
52545: PUSH
52546: LD_INT 1
52548: PUSH
52549: EMPTY
52550: LIST
52551: LIST
52552: PUSH
52553: EMPTY
52554: LIST
52555: LIST
52556: PPUSH
52557: CALL_OW 69
52561: ST_TO_ADDR
// if not tmp then
52562: LD_VAR 0 2
52566: NOT
52567: IFFALSE 52571
// exit ;
52569: GO 52658
// un := tmp [ rand ( 1 , tmp ) ] ;
52571: LD_ADDR_VAR 0 1
52575: PUSH
52576: LD_VAR 0 2
52580: PUSH
52581: LD_INT 1
52583: PPUSH
52584: LD_VAR 0 2
52588: PPUSH
52589: CALL_OW 12
52593: ARRAY
52594: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52595: LD_VAR 0 1
52599: PPUSH
52600: LD_INT 0
52602: PPUSH
52603: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52607: LD_VAR 0 1
52611: PPUSH
52612: LD_OWVAR 3
52616: PUSH
52617: LD_VAR 0 1
52621: DIFF
52622: PPUSH
52623: LD_VAR 0 1
52627: PPUSH
52628: CALL_OW 74
52632: PPUSH
52633: CALL_OW 115
// wait ( 0 0$20 ) ;
52637: LD_INT 700
52639: PPUSH
52640: CALL_OW 67
// SetSide ( un , your_side ) ;
52644: LD_VAR 0 1
52648: PPUSH
52649: LD_OWVAR 2
52653: PPUSH
52654: CALL_OW 235
// end ;
52658: PPOPN 2
52660: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52661: LD_EXP 74
52665: PUSH
52666: LD_EXP 107
52670: AND
52671: IFFALSE 52777
52673: GO 52675
52675: DISABLE
52676: LD_INT 0
52678: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52679: LD_ADDR_VAR 0 1
52683: PUSH
52684: LD_INT 22
52686: PUSH
52687: LD_OWVAR 2
52691: PUSH
52692: EMPTY
52693: LIST
52694: LIST
52695: PUSH
52696: LD_INT 2
52698: PUSH
52699: LD_INT 30
52701: PUSH
52702: LD_INT 0
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PUSH
52709: LD_INT 30
52711: PUSH
52712: LD_INT 1
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: LIST
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PPUSH
52728: CALL_OW 69
52732: ST_TO_ADDR
// if not depot then
52733: LD_VAR 0 1
52737: NOT
52738: IFFALSE 52742
// exit ;
52740: GO 52777
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52742: LD_VAR 0 1
52746: PUSH
52747: LD_INT 1
52749: ARRAY
52750: PPUSH
52751: CALL_OW 250
52755: PPUSH
52756: LD_VAR 0 1
52760: PUSH
52761: LD_INT 1
52763: ARRAY
52764: PPUSH
52765: CALL_OW 251
52769: PPUSH
52770: LD_INT 70
52772: PPUSH
52773: CALL_OW 495
// end ;
52777: PPOPN 1
52779: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52780: LD_EXP 74
52784: PUSH
52785: LD_EXP 108
52789: AND
52790: IFFALSE 53001
52792: GO 52794
52794: DISABLE
52795: LD_INT 0
52797: PPUSH
52798: PPUSH
52799: PPUSH
52800: PPUSH
52801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52802: LD_ADDR_VAR 0 5
52806: PUSH
52807: LD_INT 22
52809: PUSH
52810: LD_OWVAR 2
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: LD_INT 21
52821: PUSH
52822: LD_INT 1
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PPUSH
52833: CALL_OW 69
52837: ST_TO_ADDR
// if not tmp then
52838: LD_VAR 0 5
52842: NOT
52843: IFFALSE 52847
// exit ;
52845: GO 53001
// for i in tmp do
52847: LD_ADDR_VAR 0 1
52851: PUSH
52852: LD_VAR 0 5
52856: PUSH
52857: FOR_IN
52858: IFFALSE 52999
// begin d := rand ( 0 , 5 ) ;
52860: LD_ADDR_VAR 0 4
52864: PUSH
52865: LD_INT 0
52867: PPUSH
52868: LD_INT 5
52870: PPUSH
52871: CALL_OW 12
52875: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52876: LD_ADDR_VAR 0 2
52880: PUSH
52881: LD_VAR 0 1
52885: PPUSH
52886: CALL_OW 250
52890: PPUSH
52891: LD_VAR 0 4
52895: PPUSH
52896: LD_INT 3
52898: PPUSH
52899: LD_INT 12
52901: PPUSH
52902: CALL_OW 12
52906: PPUSH
52907: CALL_OW 272
52911: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_VAR 0 1
52921: PPUSH
52922: CALL_OW 251
52926: PPUSH
52927: LD_VAR 0 4
52931: PPUSH
52932: LD_INT 3
52934: PPUSH
52935: LD_INT 12
52937: PPUSH
52938: CALL_OW 12
52942: PPUSH
52943: CALL_OW 273
52947: ST_TO_ADDR
// if ValidHex ( x , y ) then
52948: LD_VAR 0 2
52952: PPUSH
52953: LD_VAR 0 3
52957: PPUSH
52958: CALL_OW 488
52962: IFFALSE 52997
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52964: LD_VAR 0 1
52968: PPUSH
52969: LD_VAR 0 2
52973: PPUSH
52974: LD_VAR 0 3
52978: PPUSH
52979: LD_INT 3
52981: PPUSH
52982: LD_INT 6
52984: PPUSH
52985: CALL_OW 12
52989: PPUSH
52990: LD_INT 1
52992: PPUSH
52993: CALL_OW 483
// end ;
52997: GO 52857
52999: POP
53000: POP
// end ;
53001: PPOPN 5
53003: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53004: LD_EXP 74
53008: PUSH
53009: LD_EXP 109
53013: AND
53014: IFFALSE 53108
53016: GO 53018
53018: DISABLE
53019: LD_INT 0
53021: PPUSH
53022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53023: LD_ADDR_VAR 0 2
53027: PUSH
53028: LD_INT 22
53030: PUSH
53031: LD_OWVAR 2
53035: PUSH
53036: EMPTY
53037: LIST
53038: LIST
53039: PUSH
53040: LD_INT 32
53042: PUSH
53043: LD_INT 1
53045: PUSH
53046: EMPTY
53047: LIST
53048: LIST
53049: PUSH
53050: LD_INT 21
53052: PUSH
53053: LD_INT 2
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: PUSH
53060: EMPTY
53061: LIST
53062: LIST
53063: LIST
53064: PPUSH
53065: CALL_OW 69
53069: ST_TO_ADDR
// if not tmp then
53070: LD_VAR 0 2
53074: NOT
53075: IFFALSE 53079
// exit ;
53077: GO 53108
// for i in tmp do
53079: LD_ADDR_VAR 0 1
53083: PUSH
53084: LD_VAR 0 2
53088: PUSH
53089: FOR_IN
53090: IFFALSE 53106
// SetFuel ( i , 0 ) ;
53092: LD_VAR 0 1
53096: PPUSH
53097: LD_INT 0
53099: PPUSH
53100: CALL_OW 240
53104: GO 53089
53106: POP
53107: POP
// end ;
53108: PPOPN 2
53110: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53111: LD_EXP 74
53115: PUSH
53116: LD_EXP 110
53120: AND
53121: IFFALSE 53187
53123: GO 53125
53125: DISABLE
53126: LD_INT 0
53128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53129: LD_ADDR_VAR 0 1
53133: PUSH
53134: LD_INT 22
53136: PUSH
53137: LD_OWVAR 2
53141: PUSH
53142: EMPTY
53143: LIST
53144: LIST
53145: PUSH
53146: LD_INT 30
53148: PUSH
53149: LD_INT 29
53151: PUSH
53152: EMPTY
53153: LIST
53154: LIST
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: PPUSH
53160: CALL_OW 69
53164: ST_TO_ADDR
// if not tmp then
53165: LD_VAR 0 1
53169: NOT
53170: IFFALSE 53174
// exit ;
53172: GO 53187
// DestroyUnit ( tmp [ 1 ] ) ;
53174: LD_VAR 0 1
53178: PUSH
53179: LD_INT 1
53181: ARRAY
53182: PPUSH
53183: CALL_OW 65
// end ;
53187: PPOPN 1
53189: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53190: LD_EXP 74
53194: PUSH
53195: LD_EXP 112
53199: AND
53200: IFFALSE 53329
53202: GO 53204
53204: DISABLE
53205: LD_INT 0
53207: PPUSH
// begin uc_side := 0 ;
53208: LD_ADDR_OWVAR 20
53212: PUSH
53213: LD_INT 0
53215: ST_TO_ADDR
// uc_nation := nation_arabian ;
53216: LD_ADDR_OWVAR 21
53220: PUSH
53221: LD_INT 2
53223: ST_TO_ADDR
// hc_gallery :=  ;
53224: LD_ADDR_OWVAR 33
53228: PUSH
53229: LD_STRING 
53231: ST_TO_ADDR
// hc_name :=  ;
53232: LD_ADDR_OWVAR 26
53236: PUSH
53237: LD_STRING 
53239: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53240: LD_INT 1
53242: PPUSH
53243: LD_INT 11
53245: PPUSH
53246: LD_INT 10
53248: PPUSH
53249: CALL_OW 380
// un := CreateHuman ;
53253: LD_ADDR_VAR 0 1
53257: PUSH
53258: CALL_OW 44
53262: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53263: LD_VAR 0 1
53267: PPUSH
53268: LD_INT 1
53270: PPUSH
53271: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53275: LD_INT 35
53277: PPUSH
53278: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53282: LD_VAR 0 1
53286: PPUSH
53287: LD_INT 22
53289: PUSH
53290: LD_OWVAR 2
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: PPUSH
53299: CALL_OW 69
53303: PPUSH
53304: LD_VAR 0 1
53308: PPUSH
53309: CALL_OW 74
53313: PPUSH
53314: CALL_OW 115
// until IsDead ( un ) ;
53318: LD_VAR 0 1
53322: PPUSH
53323: CALL_OW 301
53327: IFFALSE 53275
// end ;
53329: PPOPN 1
53331: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53332: LD_EXP 74
53336: PUSH
53337: LD_EXP 114
53341: AND
53342: IFFALSE 53354
53344: GO 53346
53346: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53347: LD_STRING earthquake(getX(game), 0, 32)
53349: PPUSH
53350: CALL_OW 559
53354: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53355: LD_EXP 74
53359: PUSH
53360: LD_EXP 115
53364: AND
53365: IFFALSE 53456
53367: GO 53369
53369: DISABLE
53370: LD_INT 0
53372: PPUSH
// begin enable ;
53373: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53374: LD_ADDR_VAR 0 1
53378: PUSH
53379: LD_INT 22
53381: PUSH
53382: LD_OWVAR 2
53386: PUSH
53387: EMPTY
53388: LIST
53389: LIST
53390: PUSH
53391: LD_INT 21
53393: PUSH
53394: LD_INT 2
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: PUSH
53401: LD_INT 33
53403: PUSH
53404: LD_INT 3
53406: PUSH
53407: EMPTY
53408: LIST
53409: LIST
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: LIST
53415: PPUSH
53416: CALL_OW 69
53420: ST_TO_ADDR
// if not tmp then
53421: LD_VAR 0 1
53425: NOT
53426: IFFALSE 53430
// exit ;
53428: GO 53456
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53430: LD_VAR 0 1
53434: PUSH
53435: LD_INT 1
53437: PPUSH
53438: LD_VAR 0 1
53442: PPUSH
53443: CALL_OW 12
53447: ARRAY
53448: PPUSH
53449: LD_INT 1
53451: PPUSH
53452: CALL_OW 234
// end ;
53456: PPOPN 1
53458: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53459: LD_EXP 74
53463: PUSH
53464: LD_EXP 116
53468: AND
53469: IFFALSE 53610
53471: GO 53473
53473: DISABLE
53474: LD_INT 0
53476: PPUSH
53477: PPUSH
53478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53479: LD_ADDR_VAR 0 3
53483: PUSH
53484: LD_INT 22
53486: PUSH
53487: LD_OWVAR 2
53491: PUSH
53492: EMPTY
53493: LIST
53494: LIST
53495: PUSH
53496: LD_INT 25
53498: PUSH
53499: LD_INT 1
53501: PUSH
53502: EMPTY
53503: LIST
53504: LIST
53505: PUSH
53506: EMPTY
53507: LIST
53508: LIST
53509: PPUSH
53510: CALL_OW 69
53514: ST_TO_ADDR
// if not tmp then
53515: LD_VAR 0 3
53519: NOT
53520: IFFALSE 53524
// exit ;
53522: GO 53610
// un := tmp [ rand ( 1 , tmp ) ] ;
53524: LD_ADDR_VAR 0 2
53528: PUSH
53529: LD_VAR 0 3
53533: PUSH
53534: LD_INT 1
53536: PPUSH
53537: LD_VAR 0 3
53541: PPUSH
53542: CALL_OW 12
53546: ARRAY
53547: ST_TO_ADDR
// if Crawls ( un ) then
53548: LD_VAR 0 2
53552: PPUSH
53553: CALL_OW 318
53557: IFFALSE 53568
// ComWalk ( un ) ;
53559: LD_VAR 0 2
53563: PPUSH
53564: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53568: LD_VAR 0 2
53572: PPUSH
53573: LD_INT 9
53575: PPUSH
53576: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53580: LD_INT 28
53582: PPUSH
53583: LD_OWVAR 2
53587: PPUSH
53588: LD_INT 2
53590: PPUSH
53591: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53595: LD_INT 29
53597: PPUSH
53598: LD_OWVAR 2
53602: PPUSH
53603: LD_INT 2
53605: PPUSH
53606: CALL_OW 322
// end ;
53610: PPOPN 3
53612: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53613: LD_EXP 74
53617: PUSH
53618: LD_EXP 117
53622: AND
53623: IFFALSE 53734
53625: GO 53627
53627: DISABLE
53628: LD_INT 0
53630: PPUSH
53631: PPUSH
53632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53633: LD_ADDR_VAR 0 3
53637: PUSH
53638: LD_INT 22
53640: PUSH
53641: LD_OWVAR 2
53645: PUSH
53646: EMPTY
53647: LIST
53648: LIST
53649: PUSH
53650: LD_INT 25
53652: PUSH
53653: LD_INT 1
53655: PUSH
53656: EMPTY
53657: LIST
53658: LIST
53659: PUSH
53660: EMPTY
53661: LIST
53662: LIST
53663: PPUSH
53664: CALL_OW 69
53668: ST_TO_ADDR
// if not tmp then
53669: LD_VAR 0 3
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53734
// un := tmp [ rand ( 1 , tmp ) ] ;
53678: LD_ADDR_VAR 0 2
53682: PUSH
53683: LD_VAR 0 3
53687: PUSH
53688: LD_INT 1
53690: PPUSH
53691: LD_VAR 0 3
53695: PPUSH
53696: CALL_OW 12
53700: ARRAY
53701: ST_TO_ADDR
// if Crawls ( un ) then
53702: LD_VAR 0 2
53706: PPUSH
53707: CALL_OW 318
53711: IFFALSE 53722
// ComWalk ( un ) ;
53713: LD_VAR 0 2
53717: PPUSH
53718: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53722: LD_VAR 0 2
53726: PPUSH
53727: LD_INT 8
53729: PPUSH
53730: CALL_OW 336
// end ;
53734: PPOPN 3
53736: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53737: LD_EXP 74
53741: PUSH
53742: LD_EXP 118
53746: AND
53747: IFFALSE 53891
53749: GO 53751
53751: DISABLE
53752: LD_INT 0
53754: PPUSH
53755: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53756: LD_ADDR_VAR 0 2
53760: PUSH
53761: LD_INT 22
53763: PUSH
53764: LD_OWVAR 2
53768: PUSH
53769: EMPTY
53770: LIST
53771: LIST
53772: PUSH
53773: LD_INT 21
53775: PUSH
53776: LD_INT 2
53778: PUSH
53779: EMPTY
53780: LIST
53781: LIST
53782: PUSH
53783: LD_INT 2
53785: PUSH
53786: LD_INT 34
53788: PUSH
53789: LD_INT 12
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PUSH
53796: LD_INT 34
53798: PUSH
53799: LD_INT 51
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: PUSH
53806: LD_INT 34
53808: PUSH
53809: LD_INT 32
53811: PUSH
53812: EMPTY
53813: LIST
53814: LIST
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: LIST
53820: LIST
53821: PUSH
53822: EMPTY
53823: LIST
53824: LIST
53825: LIST
53826: PPUSH
53827: CALL_OW 69
53831: ST_TO_ADDR
// if not tmp then
53832: LD_VAR 0 2
53836: NOT
53837: IFFALSE 53841
// exit ;
53839: GO 53891
// for i in tmp do
53841: LD_ADDR_VAR 0 1
53845: PUSH
53846: LD_VAR 0 2
53850: PUSH
53851: FOR_IN
53852: IFFALSE 53889
// if GetCargo ( i , mat_artifact ) = 0 then
53854: LD_VAR 0 1
53858: PPUSH
53859: LD_INT 4
53861: PPUSH
53862: CALL_OW 289
53866: PUSH
53867: LD_INT 0
53869: EQUAL
53870: IFFALSE 53887
// SetCargo ( i , mat_siberit , 100 ) ;
53872: LD_VAR 0 1
53876: PPUSH
53877: LD_INT 3
53879: PPUSH
53880: LD_INT 100
53882: PPUSH
53883: CALL_OW 290
53887: GO 53851
53889: POP
53890: POP
// end ;
53891: PPOPN 2
53893: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53894: LD_EXP 74
53898: PUSH
53899: LD_EXP 119
53903: AND
53904: IFFALSE 54087
53906: GO 53908
53908: DISABLE
53909: LD_INT 0
53911: PPUSH
53912: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53913: LD_ADDR_VAR 0 2
53917: PUSH
53918: LD_INT 22
53920: PUSH
53921: LD_OWVAR 2
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: PPUSH
53930: CALL_OW 69
53934: ST_TO_ADDR
// if not tmp then
53935: LD_VAR 0 2
53939: NOT
53940: IFFALSE 53944
// exit ;
53942: GO 54087
// for i := 1 to 2 do
53944: LD_ADDR_VAR 0 1
53948: PUSH
53949: DOUBLE
53950: LD_INT 1
53952: DEC
53953: ST_TO_ADDR
53954: LD_INT 2
53956: PUSH
53957: FOR_TO
53958: IFFALSE 54085
// begin uc_side := your_side ;
53960: LD_ADDR_OWVAR 20
53964: PUSH
53965: LD_OWVAR 2
53969: ST_TO_ADDR
// uc_nation := nation_american ;
53970: LD_ADDR_OWVAR 21
53974: PUSH
53975: LD_INT 1
53977: ST_TO_ADDR
// vc_chassis := us_morphling ;
53978: LD_ADDR_OWVAR 37
53982: PUSH
53983: LD_INT 5
53985: ST_TO_ADDR
// vc_engine := engine_siberite ;
53986: LD_ADDR_OWVAR 39
53990: PUSH
53991: LD_INT 3
53993: ST_TO_ADDR
// vc_control := control_computer ;
53994: LD_ADDR_OWVAR 38
53998: PUSH
53999: LD_INT 3
54001: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54002: LD_ADDR_OWVAR 40
54006: PUSH
54007: LD_INT 10
54009: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54010: LD_VAR 0 2
54014: PUSH
54015: LD_INT 1
54017: ARRAY
54018: PPUSH
54019: CALL_OW 310
54023: NOT
54024: IFFALSE 54071
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54026: CALL_OW 45
54030: PPUSH
54031: LD_VAR 0 2
54035: PUSH
54036: LD_INT 1
54038: ARRAY
54039: PPUSH
54040: CALL_OW 250
54044: PPUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: PPUSH
54054: CALL_OW 251
54058: PPUSH
54059: LD_INT 12
54061: PPUSH
54062: LD_INT 1
54064: PPUSH
54065: CALL_OW 50
54069: GO 54083
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54071: CALL_OW 45
54075: PPUSH
54076: LD_INT 1
54078: PPUSH
54079: CALL_OW 51
// end ;
54083: GO 53957
54085: POP
54086: POP
// end ;
54087: PPOPN 2
54089: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54090: LD_EXP 74
54094: PUSH
54095: LD_EXP 120
54099: AND
54100: IFFALSE 54322
54102: GO 54104
54104: DISABLE
54105: LD_INT 0
54107: PPUSH
54108: PPUSH
54109: PPUSH
54110: PPUSH
54111: PPUSH
54112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54113: LD_ADDR_VAR 0 6
54117: PUSH
54118: LD_INT 22
54120: PUSH
54121: LD_OWVAR 2
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PUSH
54130: LD_INT 21
54132: PUSH
54133: LD_INT 1
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: LD_INT 3
54142: PUSH
54143: LD_INT 23
54145: PUSH
54146: LD_INT 0
54148: PUSH
54149: EMPTY
54150: LIST
54151: LIST
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: LIST
54161: PPUSH
54162: CALL_OW 69
54166: ST_TO_ADDR
// if not tmp then
54167: LD_VAR 0 6
54171: NOT
54172: IFFALSE 54176
// exit ;
54174: GO 54322
// s1 := rand ( 1 , 4 ) ;
54176: LD_ADDR_VAR 0 2
54180: PUSH
54181: LD_INT 1
54183: PPUSH
54184: LD_INT 4
54186: PPUSH
54187: CALL_OW 12
54191: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54192: LD_ADDR_VAR 0 4
54196: PUSH
54197: LD_VAR 0 6
54201: PUSH
54202: LD_INT 1
54204: ARRAY
54205: PPUSH
54206: LD_VAR 0 2
54210: PPUSH
54211: CALL_OW 259
54215: ST_TO_ADDR
// if s1 = 1 then
54216: LD_VAR 0 2
54220: PUSH
54221: LD_INT 1
54223: EQUAL
54224: IFFALSE 54244
// s2 := rand ( 2 , 4 ) else
54226: LD_ADDR_VAR 0 3
54230: PUSH
54231: LD_INT 2
54233: PPUSH
54234: LD_INT 4
54236: PPUSH
54237: CALL_OW 12
54241: ST_TO_ADDR
54242: GO 54252
// s2 := 1 ;
54244: LD_ADDR_VAR 0 3
54248: PUSH
54249: LD_INT 1
54251: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54252: LD_ADDR_VAR 0 5
54256: PUSH
54257: LD_VAR 0 6
54261: PUSH
54262: LD_INT 1
54264: ARRAY
54265: PPUSH
54266: LD_VAR 0 3
54270: PPUSH
54271: CALL_OW 259
54275: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54276: LD_VAR 0 6
54280: PUSH
54281: LD_INT 1
54283: ARRAY
54284: PPUSH
54285: LD_VAR 0 2
54289: PPUSH
54290: LD_VAR 0 5
54294: PPUSH
54295: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54299: LD_VAR 0 6
54303: PUSH
54304: LD_INT 1
54306: ARRAY
54307: PPUSH
54308: LD_VAR 0 3
54312: PPUSH
54313: LD_VAR 0 4
54317: PPUSH
54318: CALL_OW 237
// end ;
54322: PPOPN 6
54324: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54325: LD_EXP 74
54329: PUSH
54330: LD_EXP 121
54334: AND
54335: IFFALSE 54414
54337: GO 54339
54339: DISABLE
54340: LD_INT 0
54342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54343: LD_ADDR_VAR 0 1
54347: PUSH
54348: LD_INT 22
54350: PUSH
54351: LD_OWVAR 2
54355: PUSH
54356: EMPTY
54357: LIST
54358: LIST
54359: PUSH
54360: LD_INT 30
54362: PUSH
54363: LD_INT 3
54365: PUSH
54366: EMPTY
54367: LIST
54368: LIST
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PPUSH
54374: CALL_OW 69
54378: ST_TO_ADDR
// if not tmp then
54379: LD_VAR 0 1
54383: NOT
54384: IFFALSE 54388
// exit ;
54386: GO 54414
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54388: LD_VAR 0 1
54392: PUSH
54393: LD_INT 1
54395: PPUSH
54396: LD_VAR 0 1
54400: PPUSH
54401: CALL_OW 12
54405: ARRAY
54406: PPUSH
54407: LD_INT 1
54409: PPUSH
54410: CALL_OW 234
// end ;
54414: PPOPN 1
54416: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54417: LD_EXP 74
54421: PUSH
54422: LD_EXP 122
54426: AND
54427: IFFALSE 54539
54429: GO 54431
54431: DISABLE
54432: LD_INT 0
54434: PPUSH
54435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54436: LD_ADDR_VAR 0 2
54440: PUSH
54441: LD_INT 22
54443: PUSH
54444: LD_OWVAR 2
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PUSH
54453: LD_INT 2
54455: PUSH
54456: LD_INT 30
54458: PUSH
54459: LD_INT 27
54461: PUSH
54462: EMPTY
54463: LIST
54464: LIST
54465: PUSH
54466: LD_INT 30
54468: PUSH
54469: LD_INT 26
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: PUSH
54476: LD_INT 30
54478: PUSH
54479: LD_INT 28
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: EMPTY
54487: LIST
54488: LIST
54489: LIST
54490: LIST
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PPUSH
54496: CALL_OW 69
54500: ST_TO_ADDR
// if not tmp then
54501: LD_VAR 0 2
54505: NOT
54506: IFFALSE 54510
// exit ;
54508: GO 54539
// for i in tmp do
54510: LD_ADDR_VAR 0 1
54514: PUSH
54515: LD_VAR 0 2
54519: PUSH
54520: FOR_IN
54521: IFFALSE 54537
// SetLives ( i , 1 ) ;
54523: LD_VAR 0 1
54527: PPUSH
54528: LD_INT 1
54530: PPUSH
54531: CALL_OW 234
54535: GO 54520
54537: POP
54538: POP
// end ;
54539: PPOPN 2
54541: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54542: LD_EXP 74
54546: PUSH
54547: LD_EXP 123
54551: AND
54552: IFFALSE 54839
54554: GO 54556
54556: DISABLE
54557: LD_INT 0
54559: PPUSH
54560: PPUSH
54561: PPUSH
// begin i := rand ( 1 , 7 ) ;
54562: LD_ADDR_VAR 0 1
54566: PUSH
54567: LD_INT 1
54569: PPUSH
54570: LD_INT 7
54572: PPUSH
54573: CALL_OW 12
54577: ST_TO_ADDR
// case i of 1 :
54578: LD_VAR 0 1
54582: PUSH
54583: LD_INT 1
54585: DOUBLE
54586: EQUAL
54587: IFTRUE 54591
54589: GO 54601
54591: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54592: LD_STRING earthquake(getX(game), 0, 32)
54594: PPUSH
54595: CALL_OW 559
54599: GO 54839
54601: LD_INT 2
54603: DOUBLE
54604: EQUAL
54605: IFTRUE 54609
54607: GO 54623
54609: POP
// begin ToLua ( displayStucuk(); ) ;
54610: LD_STRING displayStucuk();
54612: PPUSH
54613: CALL_OW 559
// ResetFog ;
54617: CALL_OW 335
// end ; 3 :
54621: GO 54839
54623: LD_INT 3
54625: DOUBLE
54626: EQUAL
54627: IFTRUE 54631
54629: GO 54735
54631: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54632: LD_ADDR_VAR 0 2
54636: PUSH
54637: LD_INT 22
54639: PUSH
54640: LD_OWVAR 2
54644: PUSH
54645: EMPTY
54646: LIST
54647: LIST
54648: PUSH
54649: LD_INT 25
54651: PUSH
54652: LD_INT 1
54654: PUSH
54655: EMPTY
54656: LIST
54657: LIST
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: PPUSH
54663: CALL_OW 69
54667: ST_TO_ADDR
// if not tmp then
54668: LD_VAR 0 2
54672: NOT
54673: IFFALSE 54677
// exit ;
54675: GO 54839
// un := tmp [ rand ( 1 , tmp ) ] ;
54677: LD_ADDR_VAR 0 3
54681: PUSH
54682: LD_VAR 0 2
54686: PUSH
54687: LD_INT 1
54689: PPUSH
54690: LD_VAR 0 2
54694: PPUSH
54695: CALL_OW 12
54699: ARRAY
54700: ST_TO_ADDR
// if Crawls ( un ) then
54701: LD_VAR 0 3
54705: PPUSH
54706: CALL_OW 318
54710: IFFALSE 54721
// ComWalk ( un ) ;
54712: LD_VAR 0 3
54716: PPUSH
54717: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54721: LD_VAR 0 3
54725: PPUSH
54726: LD_INT 8
54728: PPUSH
54729: CALL_OW 336
// end ; 4 :
54733: GO 54839
54735: LD_INT 4
54737: DOUBLE
54738: EQUAL
54739: IFTRUE 54743
54741: GO 54817
54743: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54744: LD_ADDR_VAR 0 2
54748: PUSH
54749: LD_INT 22
54751: PUSH
54752: LD_OWVAR 2
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: PUSH
54761: LD_INT 30
54763: PUSH
54764: LD_INT 29
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PPUSH
54775: CALL_OW 69
54779: ST_TO_ADDR
// if not tmp then
54780: LD_VAR 0 2
54784: NOT
54785: IFFALSE 54789
// exit ;
54787: GO 54839
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54789: LD_VAR 0 2
54793: PUSH
54794: LD_INT 1
54796: ARRAY
54797: PPUSH
54798: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54802: LD_VAR 0 2
54806: PUSH
54807: LD_INT 1
54809: ARRAY
54810: PPUSH
54811: CALL_OW 65
// end ; 5 .. 7 :
54815: GO 54839
54817: LD_INT 5
54819: DOUBLE
54820: GREATEREQUAL
54821: IFFALSE 54829
54823: LD_INT 7
54825: DOUBLE
54826: LESSEQUAL
54827: IFTRUE 54831
54829: GO 54838
54831: POP
// StreamSibBomb ; end ;
54832: CALL 51076 0 0
54836: GO 54839
54838: POP
// end ;
54839: PPOPN 3
54841: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54842: LD_EXP 74
54846: PUSH
54847: LD_EXP 124
54851: AND
54852: IFFALSE 55008
54854: GO 54856
54856: DISABLE
54857: LD_INT 0
54859: PPUSH
54860: PPUSH
54861: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54862: LD_ADDR_VAR 0 2
54866: PUSH
54867: LD_INT 81
54869: PUSH
54870: LD_OWVAR 2
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: PUSH
54879: LD_INT 2
54881: PUSH
54882: LD_INT 21
54884: PUSH
54885: LD_INT 1
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: PUSH
54892: LD_INT 21
54894: PUSH
54895: LD_INT 2
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: LIST
54906: PUSH
54907: EMPTY
54908: LIST
54909: LIST
54910: PPUSH
54911: CALL_OW 69
54915: ST_TO_ADDR
// if not tmp then
54916: LD_VAR 0 2
54920: NOT
54921: IFFALSE 54925
// exit ;
54923: GO 55008
// p := 0 ;
54925: LD_ADDR_VAR 0 3
54929: PUSH
54930: LD_INT 0
54932: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54933: LD_INT 35
54935: PPUSH
54936: CALL_OW 67
// p := p + 1 ;
54940: LD_ADDR_VAR 0 3
54944: PUSH
54945: LD_VAR 0 3
54949: PUSH
54950: LD_INT 1
54952: PLUS
54953: ST_TO_ADDR
// for i in tmp do
54954: LD_ADDR_VAR 0 1
54958: PUSH
54959: LD_VAR 0 2
54963: PUSH
54964: FOR_IN
54965: IFFALSE 54996
// if GetLives ( i ) < 1000 then
54967: LD_VAR 0 1
54971: PPUSH
54972: CALL_OW 256
54976: PUSH
54977: LD_INT 1000
54979: LESS
54980: IFFALSE 54994
// SetLives ( i , 1000 ) ;
54982: LD_VAR 0 1
54986: PPUSH
54987: LD_INT 1000
54989: PPUSH
54990: CALL_OW 234
54994: GO 54964
54996: POP
54997: POP
// until p > 20 ;
54998: LD_VAR 0 3
55002: PUSH
55003: LD_INT 20
55005: GREATER
55006: IFFALSE 54933
// end ;
55008: PPOPN 3
55010: END
// every 0 0$1 trigger StreamModeActive and sTime do
55011: LD_EXP 74
55015: PUSH
55016: LD_EXP 125
55020: AND
55021: IFFALSE 55056
55023: GO 55025
55025: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55026: LD_INT 28
55028: PPUSH
55029: LD_OWVAR 2
55033: PPUSH
55034: LD_INT 2
55036: PPUSH
55037: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55041: LD_INT 30
55043: PPUSH
55044: LD_OWVAR 2
55048: PPUSH
55049: LD_INT 2
55051: PPUSH
55052: CALL_OW 322
// end ;
55056: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55057: LD_EXP 74
55061: PUSH
55062: LD_EXP 126
55066: AND
55067: IFFALSE 55188
55069: GO 55071
55071: DISABLE
55072: LD_INT 0
55074: PPUSH
55075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55076: LD_ADDR_VAR 0 2
55080: PUSH
55081: LD_INT 22
55083: PUSH
55084: LD_OWVAR 2
55088: PUSH
55089: EMPTY
55090: LIST
55091: LIST
55092: PUSH
55093: LD_INT 21
55095: PUSH
55096: LD_INT 1
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: PUSH
55103: LD_INT 3
55105: PUSH
55106: LD_INT 23
55108: PUSH
55109: LD_INT 0
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: PPUSH
55125: CALL_OW 69
55129: ST_TO_ADDR
// if not tmp then
55130: LD_VAR 0 2
55134: NOT
55135: IFFALSE 55139
// exit ;
55137: GO 55188
// for i in tmp do
55139: LD_ADDR_VAR 0 1
55143: PUSH
55144: LD_VAR 0 2
55148: PUSH
55149: FOR_IN
55150: IFFALSE 55186
// begin if Crawls ( i ) then
55152: LD_VAR 0 1
55156: PPUSH
55157: CALL_OW 318
55161: IFFALSE 55172
// ComWalk ( i ) ;
55163: LD_VAR 0 1
55167: PPUSH
55168: CALL_OW 138
// SetClass ( i , 2 ) ;
55172: LD_VAR 0 1
55176: PPUSH
55177: LD_INT 2
55179: PPUSH
55180: CALL_OW 336
// end ;
55184: GO 55149
55186: POP
55187: POP
// end ;
55188: PPOPN 2
55190: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55191: LD_EXP 74
55195: PUSH
55196: LD_EXP 127
55200: AND
55201: IFFALSE 55489
55203: GO 55205
55205: DISABLE
55206: LD_INT 0
55208: PPUSH
55209: PPUSH
55210: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55211: LD_OWVAR 2
55215: PPUSH
55216: LD_INT 9
55218: PPUSH
55219: LD_INT 1
55221: PPUSH
55222: LD_INT 1
55224: PPUSH
55225: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55229: LD_INT 9
55231: PPUSH
55232: LD_OWVAR 2
55236: PPUSH
55237: CALL_OW 343
// uc_side := 9 ;
55241: LD_ADDR_OWVAR 20
55245: PUSH
55246: LD_INT 9
55248: ST_TO_ADDR
// uc_nation := 2 ;
55249: LD_ADDR_OWVAR 21
55253: PUSH
55254: LD_INT 2
55256: ST_TO_ADDR
// hc_name := Dark Warrior ;
55257: LD_ADDR_OWVAR 26
55261: PUSH
55262: LD_STRING Dark Warrior
55264: ST_TO_ADDR
// hc_gallery :=  ;
55265: LD_ADDR_OWVAR 33
55269: PUSH
55270: LD_STRING 
55272: ST_TO_ADDR
// hc_noskilllimit := true ;
55273: LD_ADDR_OWVAR 76
55277: PUSH
55278: LD_INT 1
55280: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55281: LD_ADDR_OWVAR 31
55285: PUSH
55286: LD_INT 30
55288: PUSH
55289: LD_INT 30
55291: PUSH
55292: LD_INT 30
55294: PUSH
55295: LD_INT 30
55297: PUSH
55298: EMPTY
55299: LIST
55300: LIST
55301: LIST
55302: LIST
55303: ST_TO_ADDR
// un := CreateHuman ;
55304: LD_ADDR_VAR 0 3
55308: PUSH
55309: CALL_OW 44
55313: ST_TO_ADDR
// hc_noskilllimit := false ;
55314: LD_ADDR_OWVAR 76
55318: PUSH
55319: LD_INT 0
55321: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55322: LD_VAR 0 3
55326: PPUSH
55327: LD_INT 1
55329: PPUSH
55330: CALL_OW 51
// ToLua ( playRanger() ) ;
55334: LD_STRING playRanger()
55336: PPUSH
55337: CALL_OW 559
// p := 0 ;
55341: LD_ADDR_VAR 0 2
55345: PUSH
55346: LD_INT 0
55348: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55349: LD_INT 35
55351: PPUSH
55352: CALL_OW 67
// p := p + 1 ;
55356: LD_ADDR_VAR 0 2
55360: PUSH
55361: LD_VAR 0 2
55365: PUSH
55366: LD_INT 1
55368: PLUS
55369: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55370: LD_VAR 0 3
55374: PPUSH
55375: CALL_OW 256
55379: PUSH
55380: LD_INT 1000
55382: LESS
55383: IFFALSE 55397
// SetLives ( un , 1000 ) ;
55385: LD_VAR 0 3
55389: PPUSH
55390: LD_INT 1000
55392: PPUSH
55393: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55397: LD_VAR 0 3
55401: PPUSH
55402: LD_INT 81
55404: PUSH
55405: LD_OWVAR 2
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: PUSH
55414: LD_INT 91
55416: PUSH
55417: LD_VAR 0 3
55421: PUSH
55422: LD_INT 30
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: LIST
55429: PUSH
55430: EMPTY
55431: LIST
55432: LIST
55433: PPUSH
55434: CALL_OW 69
55438: PPUSH
55439: LD_VAR 0 3
55443: PPUSH
55444: CALL_OW 74
55448: PPUSH
55449: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55453: LD_VAR 0 2
55457: PUSH
55458: LD_INT 80
55460: GREATER
55461: PUSH
55462: LD_VAR 0 3
55466: PPUSH
55467: CALL_OW 301
55471: OR
55472: IFFALSE 55349
// if un then
55474: LD_VAR 0 3
55478: IFFALSE 55489
// RemoveUnit ( un ) ;
55480: LD_VAR 0 3
55484: PPUSH
55485: CALL_OW 64
// end ;
55489: PPOPN 3
55491: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55492: LD_EXP 128
55496: IFFALSE 55612
55498: GO 55500
55500: DISABLE
55501: LD_INT 0
55503: PPUSH
55504: PPUSH
55505: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55506: LD_ADDR_VAR 0 2
55510: PUSH
55511: LD_INT 81
55513: PUSH
55514: LD_OWVAR 2
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: PUSH
55523: LD_INT 21
55525: PUSH
55526: LD_INT 1
55528: PUSH
55529: EMPTY
55530: LIST
55531: LIST
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: PPUSH
55537: CALL_OW 69
55541: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55542: LD_STRING playComputer()
55544: PPUSH
55545: CALL_OW 559
// if not tmp then
55549: LD_VAR 0 2
55553: NOT
55554: IFFALSE 55558
// exit ;
55556: GO 55612
// for i in tmp do
55558: LD_ADDR_VAR 0 1
55562: PUSH
55563: LD_VAR 0 2
55567: PUSH
55568: FOR_IN
55569: IFFALSE 55610
// for j := 1 to 4 do
55571: LD_ADDR_VAR 0 3
55575: PUSH
55576: DOUBLE
55577: LD_INT 1
55579: DEC
55580: ST_TO_ADDR
55581: LD_INT 4
55583: PUSH
55584: FOR_TO
55585: IFFALSE 55606
// SetSkill ( i , j , 10 ) ;
55587: LD_VAR 0 1
55591: PPUSH
55592: LD_VAR 0 3
55596: PPUSH
55597: LD_INT 10
55599: PPUSH
55600: CALL_OW 237
55604: GO 55584
55606: POP
55607: POP
55608: GO 55568
55610: POP
55611: POP
// end ;
55612: PPOPN 3
55614: END
// every 0 0$1 trigger s30 do var i , tmp ;
55615: LD_EXP 129
55619: IFFALSE 55688
55621: GO 55623
55623: DISABLE
55624: LD_INT 0
55626: PPUSH
55627: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55628: LD_ADDR_VAR 0 2
55632: PUSH
55633: LD_INT 22
55635: PUSH
55636: LD_OWVAR 2
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: PPUSH
55645: CALL_OW 69
55649: ST_TO_ADDR
// if not tmp then
55650: LD_VAR 0 2
55654: NOT
55655: IFFALSE 55659
// exit ;
55657: GO 55688
// for i in tmp do
55659: LD_ADDR_VAR 0 1
55663: PUSH
55664: LD_VAR 0 2
55668: PUSH
55669: FOR_IN
55670: IFFALSE 55686
// SetLives ( i , 300 ) ;
55672: LD_VAR 0 1
55676: PPUSH
55677: LD_INT 300
55679: PPUSH
55680: CALL_OW 234
55684: GO 55669
55686: POP
55687: POP
// end ;
55688: PPOPN 2
55690: END
// every 0 0$1 trigger s60 do var i , tmp ;
55691: LD_EXP 130
55695: IFFALSE 55764
55697: GO 55699
55699: DISABLE
55700: LD_INT 0
55702: PPUSH
55703: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55704: LD_ADDR_VAR 0 2
55708: PUSH
55709: LD_INT 22
55711: PUSH
55712: LD_OWVAR 2
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: PPUSH
55721: CALL_OW 69
55725: ST_TO_ADDR
// if not tmp then
55726: LD_VAR 0 2
55730: NOT
55731: IFFALSE 55735
// exit ;
55733: GO 55764
// for i in tmp do
55735: LD_ADDR_VAR 0 1
55739: PUSH
55740: LD_VAR 0 2
55744: PUSH
55745: FOR_IN
55746: IFFALSE 55762
// SetLives ( i , 600 ) ;
55748: LD_VAR 0 1
55752: PPUSH
55753: LD_INT 600
55755: PPUSH
55756: CALL_OW 234
55760: GO 55745
55762: POP
55763: POP
// end ;
55764: PPOPN 2
55766: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55767: LD_INT 0
55769: PPUSH
// case cmd of 301 :
55770: LD_VAR 0 1
55774: PUSH
55775: LD_INT 301
55777: DOUBLE
55778: EQUAL
55779: IFTRUE 55783
55781: GO 55815
55783: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55784: LD_VAR 0 6
55788: PPUSH
55789: LD_VAR 0 7
55793: PPUSH
55794: LD_VAR 0 8
55798: PPUSH
55799: LD_VAR 0 4
55803: PPUSH
55804: LD_VAR 0 5
55808: PPUSH
55809: CALL 57016 0 5
55813: GO 55936
55815: LD_INT 302
55817: DOUBLE
55818: EQUAL
55819: IFTRUE 55823
55821: GO 55860
55823: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55824: LD_VAR 0 6
55828: PPUSH
55829: LD_VAR 0 7
55833: PPUSH
55834: LD_VAR 0 8
55838: PPUSH
55839: LD_VAR 0 9
55843: PPUSH
55844: LD_VAR 0 4
55848: PPUSH
55849: LD_VAR 0 5
55853: PPUSH
55854: CALL 57107 0 6
55858: GO 55936
55860: LD_INT 303
55862: DOUBLE
55863: EQUAL
55864: IFTRUE 55868
55866: GO 55905
55868: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55869: LD_VAR 0 6
55873: PPUSH
55874: LD_VAR 0 7
55878: PPUSH
55879: LD_VAR 0 8
55883: PPUSH
55884: LD_VAR 0 9
55888: PPUSH
55889: LD_VAR 0 4
55893: PPUSH
55894: LD_VAR 0 5
55898: PPUSH
55899: CALL 55941 0 6
55903: GO 55936
55905: LD_INT 304
55907: DOUBLE
55908: EQUAL
55909: IFTRUE 55913
55911: GO 55935
55913: POP
// hHackTeleport ( unit , x , y ) ; end ;
55914: LD_VAR 0 2
55918: PPUSH
55919: LD_VAR 0 4
55923: PPUSH
55924: LD_VAR 0 5
55928: PPUSH
55929: CALL 57700 0 3
55933: GO 55936
55935: POP
// end ;
55936: LD_VAR 0 12
55940: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55941: LD_INT 0
55943: PPUSH
55944: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55945: LD_VAR 0 1
55949: PUSH
55950: LD_INT 1
55952: LESS
55953: PUSH
55954: LD_VAR 0 1
55958: PUSH
55959: LD_INT 3
55961: GREATER
55962: OR
55963: PUSH
55964: LD_VAR 0 5
55968: PPUSH
55969: LD_VAR 0 6
55973: PPUSH
55974: CALL_OW 428
55978: OR
55979: IFFALSE 55983
// exit ;
55981: GO 56703
// uc_side := your_side ;
55983: LD_ADDR_OWVAR 20
55987: PUSH
55988: LD_OWVAR 2
55992: ST_TO_ADDR
// uc_nation := nation ;
55993: LD_ADDR_OWVAR 21
55997: PUSH
55998: LD_VAR 0 1
56002: ST_TO_ADDR
// bc_level = 1 ;
56003: LD_ADDR_OWVAR 43
56007: PUSH
56008: LD_INT 1
56010: ST_TO_ADDR
// case btype of 1 :
56011: LD_VAR 0 2
56015: PUSH
56016: LD_INT 1
56018: DOUBLE
56019: EQUAL
56020: IFTRUE 56024
56022: GO 56035
56024: POP
// bc_type := b_depot ; 2 :
56025: LD_ADDR_OWVAR 42
56029: PUSH
56030: LD_INT 0
56032: ST_TO_ADDR
56033: GO 56647
56035: LD_INT 2
56037: DOUBLE
56038: EQUAL
56039: IFTRUE 56043
56041: GO 56054
56043: POP
// bc_type := b_warehouse ; 3 :
56044: LD_ADDR_OWVAR 42
56048: PUSH
56049: LD_INT 1
56051: ST_TO_ADDR
56052: GO 56647
56054: LD_INT 3
56056: DOUBLE
56057: EQUAL
56058: IFTRUE 56062
56060: GO 56073
56062: POP
// bc_type := b_lab ; 4 .. 9 :
56063: LD_ADDR_OWVAR 42
56067: PUSH
56068: LD_INT 6
56070: ST_TO_ADDR
56071: GO 56647
56073: LD_INT 4
56075: DOUBLE
56076: GREATEREQUAL
56077: IFFALSE 56085
56079: LD_INT 9
56081: DOUBLE
56082: LESSEQUAL
56083: IFTRUE 56087
56085: GO 56139
56087: POP
// begin bc_type := b_lab_half ;
56088: LD_ADDR_OWVAR 42
56092: PUSH
56093: LD_INT 7
56095: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56096: LD_ADDR_OWVAR 44
56100: PUSH
56101: LD_INT 10
56103: PUSH
56104: LD_INT 11
56106: PUSH
56107: LD_INT 12
56109: PUSH
56110: LD_INT 15
56112: PUSH
56113: LD_INT 14
56115: PUSH
56116: LD_INT 13
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: LIST
56123: LIST
56124: LIST
56125: LIST
56126: PUSH
56127: LD_VAR 0 2
56131: PUSH
56132: LD_INT 3
56134: MINUS
56135: ARRAY
56136: ST_TO_ADDR
// end ; 10 .. 13 :
56137: GO 56647
56139: LD_INT 10
56141: DOUBLE
56142: GREATEREQUAL
56143: IFFALSE 56151
56145: LD_INT 13
56147: DOUBLE
56148: LESSEQUAL
56149: IFTRUE 56153
56151: GO 56230
56153: POP
// begin bc_type := b_lab_full ;
56154: LD_ADDR_OWVAR 42
56158: PUSH
56159: LD_INT 8
56161: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56162: LD_ADDR_OWVAR 44
56166: PUSH
56167: LD_INT 10
56169: PUSH
56170: LD_INT 12
56172: PUSH
56173: LD_INT 14
56175: PUSH
56176: LD_INT 13
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: LIST
56183: LIST
56184: PUSH
56185: LD_VAR 0 2
56189: PUSH
56190: LD_INT 9
56192: MINUS
56193: ARRAY
56194: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56195: LD_ADDR_OWVAR 45
56199: PUSH
56200: LD_INT 11
56202: PUSH
56203: LD_INT 15
56205: PUSH
56206: LD_INT 12
56208: PUSH
56209: LD_INT 15
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: PUSH
56218: LD_VAR 0 2
56222: PUSH
56223: LD_INT 9
56225: MINUS
56226: ARRAY
56227: ST_TO_ADDR
// end ; 14 :
56228: GO 56647
56230: LD_INT 14
56232: DOUBLE
56233: EQUAL
56234: IFTRUE 56238
56236: GO 56249
56238: POP
// bc_type := b_workshop ; 15 :
56239: LD_ADDR_OWVAR 42
56243: PUSH
56244: LD_INT 2
56246: ST_TO_ADDR
56247: GO 56647
56249: LD_INT 15
56251: DOUBLE
56252: EQUAL
56253: IFTRUE 56257
56255: GO 56268
56257: POP
// bc_type := b_factory ; 16 :
56258: LD_ADDR_OWVAR 42
56262: PUSH
56263: LD_INT 3
56265: ST_TO_ADDR
56266: GO 56647
56268: LD_INT 16
56270: DOUBLE
56271: EQUAL
56272: IFTRUE 56276
56274: GO 56287
56276: POP
// bc_type := b_ext_gun ; 17 :
56277: LD_ADDR_OWVAR 42
56281: PUSH
56282: LD_INT 17
56284: ST_TO_ADDR
56285: GO 56647
56287: LD_INT 17
56289: DOUBLE
56290: EQUAL
56291: IFTRUE 56295
56293: GO 56323
56295: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56296: LD_ADDR_OWVAR 42
56300: PUSH
56301: LD_INT 19
56303: PUSH
56304: LD_INT 23
56306: PUSH
56307: LD_INT 19
56309: PUSH
56310: EMPTY
56311: LIST
56312: LIST
56313: LIST
56314: PUSH
56315: LD_VAR 0 1
56319: ARRAY
56320: ST_TO_ADDR
56321: GO 56647
56323: LD_INT 18
56325: DOUBLE
56326: EQUAL
56327: IFTRUE 56331
56329: GO 56342
56331: POP
// bc_type := b_ext_radar ; 19 :
56332: LD_ADDR_OWVAR 42
56336: PUSH
56337: LD_INT 20
56339: ST_TO_ADDR
56340: GO 56647
56342: LD_INT 19
56344: DOUBLE
56345: EQUAL
56346: IFTRUE 56350
56348: GO 56361
56350: POP
// bc_type := b_ext_radio ; 20 :
56351: LD_ADDR_OWVAR 42
56355: PUSH
56356: LD_INT 22
56358: ST_TO_ADDR
56359: GO 56647
56361: LD_INT 20
56363: DOUBLE
56364: EQUAL
56365: IFTRUE 56369
56367: GO 56380
56369: POP
// bc_type := b_ext_siberium ; 21 :
56370: LD_ADDR_OWVAR 42
56374: PUSH
56375: LD_INT 21
56377: ST_TO_ADDR
56378: GO 56647
56380: LD_INT 21
56382: DOUBLE
56383: EQUAL
56384: IFTRUE 56388
56386: GO 56399
56388: POP
// bc_type := b_ext_computer ; 22 :
56389: LD_ADDR_OWVAR 42
56393: PUSH
56394: LD_INT 24
56396: ST_TO_ADDR
56397: GO 56647
56399: LD_INT 22
56401: DOUBLE
56402: EQUAL
56403: IFTRUE 56407
56405: GO 56418
56407: POP
// bc_type := b_ext_track ; 23 :
56408: LD_ADDR_OWVAR 42
56412: PUSH
56413: LD_INT 16
56415: ST_TO_ADDR
56416: GO 56647
56418: LD_INT 23
56420: DOUBLE
56421: EQUAL
56422: IFTRUE 56426
56424: GO 56437
56426: POP
// bc_type := b_ext_laser ; 24 :
56427: LD_ADDR_OWVAR 42
56431: PUSH
56432: LD_INT 25
56434: ST_TO_ADDR
56435: GO 56647
56437: LD_INT 24
56439: DOUBLE
56440: EQUAL
56441: IFTRUE 56445
56443: GO 56456
56445: POP
// bc_type := b_control_tower ; 25 :
56446: LD_ADDR_OWVAR 42
56450: PUSH
56451: LD_INT 36
56453: ST_TO_ADDR
56454: GO 56647
56456: LD_INT 25
56458: DOUBLE
56459: EQUAL
56460: IFTRUE 56464
56462: GO 56475
56464: POP
// bc_type := b_breastwork ; 26 :
56465: LD_ADDR_OWVAR 42
56469: PUSH
56470: LD_INT 31
56472: ST_TO_ADDR
56473: GO 56647
56475: LD_INT 26
56477: DOUBLE
56478: EQUAL
56479: IFTRUE 56483
56481: GO 56494
56483: POP
// bc_type := b_bunker ; 27 :
56484: LD_ADDR_OWVAR 42
56488: PUSH
56489: LD_INT 32
56491: ST_TO_ADDR
56492: GO 56647
56494: LD_INT 27
56496: DOUBLE
56497: EQUAL
56498: IFTRUE 56502
56500: GO 56513
56502: POP
// bc_type := b_turret ; 28 :
56503: LD_ADDR_OWVAR 42
56507: PUSH
56508: LD_INT 33
56510: ST_TO_ADDR
56511: GO 56647
56513: LD_INT 28
56515: DOUBLE
56516: EQUAL
56517: IFTRUE 56521
56519: GO 56532
56521: POP
// bc_type := b_armoury ; 29 :
56522: LD_ADDR_OWVAR 42
56526: PUSH
56527: LD_INT 4
56529: ST_TO_ADDR
56530: GO 56647
56532: LD_INT 29
56534: DOUBLE
56535: EQUAL
56536: IFTRUE 56540
56538: GO 56551
56540: POP
// bc_type := b_barracks ; 30 :
56541: LD_ADDR_OWVAR 42
56545: PUSH
56546: LD_INT 5
56548: ST_TO_ADDR
56549: GO 56647
56551: LD_INT 30
56553: DOUBLE
56554: EQUAL
56555: IFTRUE 56559
56557: GO 56570
56559: POP
// bc_type := b_solar_power ; 31 :
56560: LD_ADDR_OWVAR 42
56564: PUSH
56565: LD_INT 27
56567: ST_TO_ADDR
56568: GO 56647
56570: LD_INT 31
56572: DOUBLE
56573: EQUAL
56574: IFTRUE 56578
56576: GO 56589
56578: POP
// bc_type := b_oil_power ; 32 :
56579: LD_ADDR_OWVAR 42
56583: PUSH
56584: LD_INT 26
56586: ST_TO_ADDR
56587: GO 56647
56589: LD_INT 32
56591: DOUBLE
56592: EQUAL
56593: IFTRUE 56597
56595: GO 56608
56597: POP
// bc_type := b_siberite_power ; 33 :
56598: LD_ADDR_OWVAR 42
56602: PUSH
56603: LD_INT 28
56605: ST_TO_ADDR
56606: GO 56647
56608: LD_INT 33
56610: DOUBLE
56611: EQUAL
56612: IFTRUE 56616
56614: GO 56627
56616: POP
// bc_type := b_oil_mine ; 34 :
56617: LD_ADDR_OWVAR 42
56621: PUSH
56622: LD_INT 29
56624: ST_TO_ADDR
56625: GO 56647
56627: LD_INT 34
56629: DOUBLE
56630: EQUAL
56631: IFTRUE 56635
56633: GO 56646
56635: POP
// bc_type := b_siberite_mine ; end ;
56636: LD_ADDR_OWVAR 42
56640: PUSH
56641: LD_INT 30
56643: ST_TO_ADDR
56644: GO 56647
56646: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56647: LD_ADDR_VAR 0 8
56651: PUSH
56652: LD_VAR 0 5
56656: PPUSH
56657: LD_VAR 0 6
56661: PPUSH
56662: LD_VAR 0 3
56666: PPUSH
56667: CALL_OW 47
56671: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56672: LD_OWVAR 42
56676: PUSH
56677: LD_INT 32
56679: PUSH
56680: LD_INT 33
56682: PUSH
56683: EMPTY
56684: LIST
56685: LIST
56686: IN
56687: IFFALSE 56703
// PlaceWeaponTurret ( b , weapon ) ;
56689: LD_VAR 0 8
56693: PPUSH
56694: LD_VAR 0 4
56698: PPUSH
56699: CALL_OW 431
// end ;
56703: LD_VAR 0 7
56707: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56708: LD_INT 0
56710: PPUSH
56711: PPUSH
56712: PPUSH
56713: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56714: LD_ADDR_VAR 0 4
56718: PUSH
56719: LD_INT 22
56721: PUSH
56722: LD_OWVAR 2
56726: PUSH
56727: EMPTY
56728: LIST
56729: LIST
56730: PUSH
56731: LD_INT 2
56733: PUSH
56734: LD_INT 30
56736: PUSH
56737: LD_INT 0
56739: PUSH
56740: EMPTY
56741: LIST
56742: LIST
56743: PUSH
56744: LD_INT 30
56746: PUSH
56747: LD_INT 1
56749: PUSH
56750: EMPTY
56751: LIST
56752: LIST
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: LIST
56758: PUSH
56759: EMPTY
56760: LIST
56761: LIST
56762: PPUSH
56763: CALL_OW 69
56767: ST_TO_ADDR
// if not tmp then
56768: LD_VAR 0 4
56772: NOT
56773: IFFALSE 56777
// exit ;
56775: GO 56836
// for i in tmp do
56777: LD_ADDR_VAR 0 2
56781: PUSH
56782: LD_VAR 0 4
56786: PUSH
56787: FOR_IN
56788: IFFALSE 56834
// for j = 1 to 3 do
56790: LD_ADDR_VAR 0 3
56794: PUSH
56795: DOUBLE
56796: LD_INT 1
56798: DEC
56799: ST_TO_ADDR
56800: LD_INT 3
56802: PUSH
56803: FOR_TO
56804: IFFALSE 56830
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56806: LD_VAR 0 2
56810: PPUSH
56811: CALL_OW 274
56815: PPUSH
56816: LD_VAR 0 3
56820: PPUSH
56821: LD_INT 99999
56823: PPUSH
56824: CALL_OW 277
56828: GO 56803
56830: POP
56831: POP
56832: GO 56787
56834: POP
56835: POP
// end ;
56836: LD_VAR 0 1
56840: RET
// export function hHackSetLevel10 ; var i , j ; begin
56841: LD_INT 0
56843: PPUSH
56844: PPUSH
56845: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56846: LD_ADDR_VAR 0 2
56850: PUSH
56851: LD_INT 21
56853: PUSH
56854: LD_INT 1
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: PPUSH
56861: CALL_OW 69
56865: PUSH
56866: FOR_IN
56867: IFFALSE 56919
// if IsSelected ( i ) then
56869: LD_VAR 0 2
56873: PPUSH
56874: CALL_OW 306
56878: IFFALSE 56917
// begin for j := 1 to 4 do
56880: LD_ADDR_VAR 0 3
56884: PUSH
56885: DOUBLE
56886: LD_INT 1
56888: DEC
56889: ST_TO_ADDR
56890: LD_INT 4
56892: PUSH
56893: FOR_TO
56894: IFFALSE 56915
// SetSkill ( i , j , 10 ) ;
56896: LD_VAR 0 2
56900: PPUSH
56901: LD_VAR 0 3
56905: PPUSH
56906: LD_INT 10
56908: PPUSH
56909: CALL_OW 237
56913: GO 56893
56915: POP
56916: POP
// end ;
56917: GO 56866
56919: POP
56920: POP
// end ;
56921: LD_VAR 0 1
56925: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56926: LD_INT 0
56928: PPUSH
56929: PPUSH
56930: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56931: LD_ADDR_VAR 0 2
56935: PUSH
56936: LD_INT 22
56938: PUSH
56939: LD_OWVAR 2
56943: PUSH
56944: EMPTY
56945: LIST
56946: LIST
56947: PUSH
56948: LD_INT 21
56950: PUSH
56951: LD_INT 1
56953: PUSH
56954: EMPTY
56955: LIST
56956: LIST
56957: PUSH
56958: EMPTY
56959: LIST
56960: LIST
56961: PPUSH
56962: CALL_OW 69
56966: PUSH
56967: FOR_IN
56968: IFFALSE 57009
// begin for j := 1 to 4 do
56970: LD_ADDR_VAR 0 3
56974: PUSH
56975: DOUBLE
56976: LD_INT 1
56978: DEC
56979: ST_TO_ADDR
56980: LD_INT 4
56982: PUSH
56983: FOR_TO
56984: IFFALSE 57005
// SetSkill ( i , j , 10 ) ;
56986: LD_VAR 0 2
56990: PPUSH
56991: LD_VAR 0 3
56995: PPUSH
56996: LD_INT 10
56998: PPUSH
56999: CALL_OW 237
57003: GO 56983
57005: POP
57006: POP
// end ;
57007: GO 56967
57009: POP
57010: POP
// end ;
57011: LD_VAR 0 1
57015: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57016: LD_INT 0
57018: PPUSH
// uc_side := your_side ;
57019: LD_ADDR_OWVAR 20
57023: PUSH
57024: LD_OWVAR 2
57028: ST_TO_ADDR
// uc_nation := nation ;
57029: LD_ADDR_OWVAR 21
57033: PUSH
57034: LD_VAR 0 1
57038: ST_TO_ADDR
// InitHc ;
57039: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57043: LD_INT 0
57045: PPUSH
57046: LD_VAR 0 2
57050: PPUSH
57051: LD_VAR 0 3
57055: PPUSH
57056: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57060: LD_VAR 0 4
57064: PPUSH
57065: LD_VAR 0 5
57069: PPUSH
57070: CALL_OW 428
57074: PUSH
57075: LD_INT 0
57077: EQUAL
57078: IFFALSE 57102
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57080: CALL_OW 44
57084: PPUSH
57085: LD_VAR 0 4
57089: PPUSH
57090: LD_VAR 0 5
57094: PPUSH
57095: LD_INT 1
57097: PPUSH
57098: CALL_OW 48
// end ;
57102: LD_VAR 0 6
57106: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57107: LD_INT 0
57109: PPUSH
57110: PPUSH
// uc_side := your_side ;
57111: LD_ADDR_OWVAR 20
57115: PUSH
57116: LD_OWVAR 2
57120: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57121: LD_VAR 0 1
57125: PUSH
57126: LD_INT 1
57128: PUSH
57129: LD_INT 2
57131: PUSH
57132: LD_INT 3
57134: PUSH
57135: LD_INT 4
57137: PUSH
57138: LD_INT 5
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: LIST
57145: LIST
57146: LIST
57147: IN
57148: IFFALSE 57160
// uc_nation := nation_american else
57150: LD_ADDR_OWVAR 21
57154: PUSH
57155: LD_INT 1
57157: ST_TO_ADDR
57158: GO 57203
// if chassis in [ 11 , 12 , 13 , 14 ] then
57160: LD_VAR 0 1
57164: PUSH
57165: LD_INT 11
57167: PUSH
57168: LD_INT 12
57170: PUSH
57171: LD_INT 13
57173: PUSH
57174: LD_INT 14
57176: PUSH
57177: EMPTY
57178: LIST
57179: LIST
57180: LIST
57181: LIST
57182: IN
57183: IFFALSE 57195
// uc_nation := nation_arabian else
57185: LD_ADDR_OWVAR 21
57189: PUSH
57190: LD_INT 2
57192: ST_TO_ADDR
57193: GO 57203
// uc_nation := nation_russian ;
57195: LD_ADDR_OWVAR 21
57199: PUSH
57200: LD_INT 3
57202: ST_TO_ADDR
// vc_chassis := chassis ;
57203: LD_ADDR_OWVAR 37
57207: PUSH
57208: LD_VAR 0 1
57212: ST_TO_ADDR
// vc_engine := engine ;
57213: LD_ADDR_OWVAR 39
57217: PUSH
57218: LD_VAR 0 2
57222: ST_TO_ADDR
// vc_control := control ;
57223: LD_ADDR_OWVAR 38
57227: PUSH
57228: LD_VAR 0 3
57232: ST_TO_ADDR
// vc_weapon := weapon ;
57233: LD_ADDR_OWVAR 40
57237: PUSH
57238: LD_VAR 0 4
57242: ST_TO_ADDR
// un := CreateVehicle ;
57243: LD_ADDR_VAR 0 8
57247: PUSH
57248: CALL_OW 45
57252: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57253: LD_VAR 0 8
57257: PPUSH
57258: LD_INT 0
57260: PPUSH
57261: LD_INT 5
57263: PPUSH
57264: CALL_OW 12
57268: PPUSH
57269: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57273: LD_VAR 0 8
57277: PPUSH
57278: LD_VAR 0 5
57282: PPUSH
57283: LD_VAR 0 6
57287: PPUSH
57288: LD_INT 1
57290: PPUSH
57291: CALL_OW 48
// end ;
57295: LD_VAR 0 7
57299: RET
// export hInvincible ; every 1 do
57300: GO 57302
57302: DISABLE
// hInvincible := [ ] ;
57303: LD_ADDR_EXP 131
57307: PUSH
57308: EMPTY
57309: ST_TO_ADDR
57310: END
// every 10 do var i ;
57311: GO 57313
57313: DISABLE
57314: LD_INT 0
57316: PPUSH
// begin enable ;
57317: ENABLE
// if not hInvincible then
57318: LD_EXP 131
57322: NOT
57323: IFFALSE 57327
// exit ;
57325: GO 57371
// for i in hInvincible do
57327: LD_ADDR_VAR 0 1
57331: PUSH
57332: LD_EXP 131
57336: PUSH
57337: FOR_IN
57338: IFFALSE 57369
// if GetLives ( i ) < 1000 then
57340: LD_VAR 0 1
57344: PPUSH
57345: CALL_OW 256
57349: PUSH
57350: LD_INT 1000
57352: LESS
57353: IFFALSE 57367
// SetLives ( i , 1000 ) ;
57355: LD_VAR 0 1
57359: PPUSH
57360: LD_INT 1000
57362: PPUSH
57363: CALL_OW 234
57367: GO 57337
57369: POP
57370: POP
// end ;
57371: PPOPN 1
57373: END
// export function hHackInvincible ; var i ; begin
57374: LD_INT 0
57376: PPUSH
57377: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57378: LD_ADDR_VAR 0 2
57382: PUSH
57383: LD_INT 2
57385: PUSH
57386: LD_INT 21
57388: PUSH
57389: LD_INT 1
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PUSH
57396: LD_INT 21
57398: PUSH
57399: LD_INT 2
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: PUSH
57406: EMPTY
57407: LIST
57408: LIST
57409: LIST
57410: PPUSH
57411: CALL_OW 69
57415: PUSH
57416: FOR_IN
57417: IFFALSE 57478
// if IsSelected ( i ) then
57419: LD_VAR 0 2
57423: PPUSH
57424: CALL_OW 306
57428: IFFALSE 57476
// begin if i in hInvincible then
57430: LD_VAR 0 2
57434: PUSH
57435: LD_EXP 131
57439: IN
57440: IFFALSE 57460
// hInvincible := hInvincible diff i else
57442: LD_ADDR_EXP 131
57446: PUSH
57447: LD_EXP 131
57451: PUSH
57452: LD_VAR 0 2
57456: DIFF
57457: ST_TO_ADDR
57458: GO 57476
// hInvincible := hInvincible union i ;
57460: LD_ADDR_EXP 131
57464: PUSH
57465: LD_EXP 131
57469: PUSH
57470: LD_VAR 0 2
57474: UNION
57475: ST_TO_ADDR
// end ;
57476: GO 57416
57478: POP
57479: POP
// end ;
57480: LD_VAR 0 1
57484: RET
// export function hHackInvisible ; var i , j ; begin
57485: LD_INT 0
57487: PPUSH
57488: PPUSH
57489: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57490: LD_ADDR_VAR 0 2
57494: PUSH
57495: LD_INT 21
57497: PUSH
57498: LD_INT 1
57500: PUSH
57501: EMPTY
57502: LIST
57503: LIST
57504: PPUSH
57505: CALL_OW 69
57509: PUSH
57510: FOR_IN
57511: IFFALSE 57535
// if IsSelected ( i ) then
57513: LD_VAR 0 2
57517: PPUSH
57518: CALL_OW 306
57522: IFFALSE 57533
// ComForceInvisible ( i ) ;
57524: LD_VAR 0 2
57528: PPUSH
57529: CALL_OW 496
57533: GO 57510
57535: POP
57536: POP
// end ;
57537: LD_VAR 0 1
57541: RET
// export function hHackChangeYourSide ; begin
57542: LD_INT 0
57544: PPUSH
// if your_side = 8 then
57545: LD_OWVAR 2
57549: PUSH
57550: LD_INT 8
57552: EQUAL
57553: IFFALSE 57565
// your_side := 0 else
57555: LD_ADDR_OWVAR 2
57559: PUSH
57560: LD_INT 0
57562: ST_TO_ADDR
57563: GO 57579
// your_side := your_side + 1 ;
57565: LD_ADDR_OWVAR 2
57569: PUSH
57570: LD_OWVAR 2
57574: PUSH
57575: LD_INT 1
57577: PLUS
57578: ST_TO_ADDR
// end ;
57579: LD_VAR 0 1
57583: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57584: LD_INT 0
57586: PPUSH
57587: PPUSH
57588: PPUSH
// for i in all_units do
57589: LD_ADDR_VAR 0 2
57593: PUSH
57594: LD_OWVAR 3
57598: PUSH
57599: FOR_IN
57600: IFFALSE 57678
// if IsSelected ( i ) then
57602: LD_VAR 0 2
57606: PPUSH
57607: CALL_OW 306
57611: IFFALSE 57676
// begin j := GetSide ( i ) ;
57613: LD_ADDR_VAR 0 3
57617: PUSH
57618: LD_VAR 0 2
57622: PPUSH
57623: CALL_OW 255
57627: ST_TO_ADDR
// if j = 8 then
57628: LD_VAR 0 3
57632: PUSH
57633: LD_INT 8
57635: EQUAL
57636: IFFALSE 57648
// j := 0 else
57638: LD_ADDR_VAR 0 3
57642: PUSH
57643: LD_INT 0
57645: ST_TO_ADDR
57646: GO 57662
// j := j + 1 ;
57648: LD_ADDR_VAR 0 3
57652: PUSH
57653: LD_VAR 0 3
57657: PUSH
57658: LD_INT 1
57660: PLUS
57661: ST_TO_ADDR
// SetSide ( i , j ) ;
57662: LD_VAR 0 2
57666: PPUSH
57667: LD_VAR 0 3
57671: PPUSH
57672: CALL_OW 235
// end ;
57676: GO 57599
57678: POP
57679: POP
// end ;
57680: LD_VAR 0 1
57684: RET
// export function hHackFog ; begin
57685: LD_INT 0
57687: PPUSH
// FogOff ( true ) ;
57688: LD_INT 1
57690: PPUSH
57691: CALL_OW 344
// end ;
57695: LD_VAR 0 1
57699: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57700: LD_INT 0
57702: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57703: LD_VAR 0 1
57707: PPUSH
57708: LD_VAR 0 2
57712: PPUSH
57713: LD_VAR 0 3
57717: PPUSH
57718: LD_INT 1
57720: PPUSH
57721: LD_INT 1
57723: PPUSH
57724: CALL_OW 483
// CenterOnXY ( x , y ) ;
57728: LD_VAR 0 2
57732: PPUSH
57733: LD_VAR 0 3
57737: PPUSH
57738: CALL_OW 84
// end ;
57742: LD_VAR 0 4
57746: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57747: LD_INT 0
57749: PPUSH
57750: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57751: LD_VAR 0 1
57755: NOT
57756: PUSH
57757: LD_VAR 0 2
57761: PPUSH
57762: LD_VAR 0 3
57766: PPUSH
57767: CALL_OW 488
57771: NOT
57772: OR
57773: PUSH
57774: LD_VAR 0 1
57778: PPUSH
57779: CALL_OW 266
57783: PUSH
57784: LD_INT 3
57786: NONEQUAL
57787: PUSH
57788: LD_VAR 0 1
57792: PPUSH
57793: CALL_OW 247
57797: PUSH
57798: LD_INT 1
57800: EQUAL
57801: NOT
57802: AND
57803: OR
57804: IFFALSE 57808
// exit ;
57806: GO 57957
// if GetType ( factory ) = unit_human then
57808: LD_VAR 0 1
57812: PPUSH
57813: CALL_OW 247
57817: PUSH
57818: LD_INT 1
57820: EQUAL
57821: IFFALSE 57838
// factory := IsInUnit ( factory ) ;
57823: LD_ADDR_VAR 0 1
57827: PUSH
57828: LD_VAR 0 1
57832: PPUSH
57833: CALL_OW 310
57837: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57838: LD_VAR 0 1
57842: PPUSH
57843: CALL_OW 266
57847: PUSH
57848: LD_INT 3
57850: NONEQUAL
57851: IFFALSE 57855
// exit ;
57853: GO 57957
// if HexInfo ( x , y ) = factory then
57855: LD_VAR 0 2
57859: PPUSH
57860: LD_VAR 0 3
57864: PPUSH
57865: CALL_OW 428
57869: PUSH
57870: LD_VAR 0 1
57874: EQUAL
57875: IFFALSE 57902
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57877: LD_ADDR_EXP 132
57881: PUSH
57882: LD_EXP 132
57886: PPUSH
57887: LD_VAR 0 1
57891: PPUSH
57892: LD_INT 0
57894: PPUSH
57895: CALL_OW 1
57899: ST_TO_ADDR
57900: GO 57953
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57902: LD_ADDR_EXP 132
57906: PUSH
57907: LD_EXP 132
57911: PPUSH
57912: LD_VAR 0 1
57916: PPUSH
57917: LD_VAR 0 1
57921: PPUSH
57922: CALL_OW 255
57926: PUSH
57927: LD_VAR 0 1
57931: PUSH
57932: LD_VAR 0 2
57936: PUSH
57937: LD_VAR 0 3
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: LIST
57946: LIST
57947: PPUSH
57948: CALL_OW 1
57952: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57953: CALL 57962 0 0
// end ;
57957: LD_VAR 0 4
57961: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57962: LD_INT 0
57964: PPUSH
57965: PPUSH
57966: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57967: LD_STRING resetFactoryWaypoint();
57969: PPUSH
57970: CALL_OW 559
// if factoryWaypoints then
57974: LD_EXP 132
57978: IFFALSE 58104
// begin list := PrepareArray ( factoryWaypoints ) ;
57980: LD_ADDR_VAR 0 3
57984: PUSH
57985: LD_EXP 132
57989: PPUSH
57990: CALL 104573 0 1
57994: ST_TO_ADDR
// for i := 1 to list do
57995: LD_ADDR_VAR 0 2
57999: PUSH
58000: DOUBLE
58001: LD_INT 1
58003: DEC
58004: ST_TO_ADDR
58005: LD_VAR 0 3
58009: PUSH
58010: FOR_TO
58011: IFFALSE 58102
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58013: LD_STRING setFactoryWaypointXY(
58015: PUSH
58016: LD_VAR 0 3
58020: PUSH
58021: LD_VAR 0 2
58025: ARRAY
58026: PUSH
58027: LD_INT 1
58029: ARRAY
58030: STR
58031: PUSH
58032: LD_STRING ,
58034: STR
58035: PUSH
58036: LD_VAR 0 3
58040: PUSH
58041: LD_VAR 0 2
58045: ARRAY
58046: PUSH
58047: LD_INT 2
58049: ARRAY
58050: STR
58051: PUSH
58052: LD_STRING ,
58054: STR
58055: PUSH
58056: LD_VAR 0 3
58060: PUSH
58061: LD_VAR 0 2
58065: ARRAY
58066: PUSH
58067: LD_INT 3
58069: ARRAY
58070: STR
58071: PUSH
58072: LD_STRING ,
58074: STR
58075: PUSH
58076: LD_VAR 0 3
58080: PUSH
58081: LD_VAR 0 2
58085: ARRAY
58086: PUSH
58087: LD_INT 4
58089: ARRAY
58090: STR
58091: PUSH
58092: LD_STRING )
58094: STR
58095: PPUSH
58096: CALL_OW 559
58100: GO 58010
58102: POP
58103: POP
// end ; end ;
58104: LD_VAR 0 1
58108: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
58109: LD_INT 0
58111: PPUSH
// if HexInfo ( x , y ) = warehouse then
58112: LD_VAR 0 2
58116: PPUSH
58117: LD_VAR 0 3
58121: PPUSH
58122: CALL_OW 428
58126: PUSH
58127: LD_VAR 0 1
58131: EQUAL
58132: IFFALSE 58159
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58134: LD_ADDR_EXP 133
58138: PUSH
58139: LD_EXP 133
58143: PPUSH
58144: LD_VAR 0 1
58148: PPUSH
58149: LD_INT 0
58151: PPUSH
58152: CALL_OW 1
58156: ST_TO_ADDR
58157: GO 58210
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58159: LD_ADDR_EXP 133
58163: PUSH
58164: LD_EXP 133
58168: PPUSH
58169: LD_VAR 0 1
58173: PPUSH
58174: LD_VAR 0 1
58178: PPUSH
58179: CALL_OW 255
58183: PUSH
58184: LD_VAR 0 1
58188: PUSH
58189: LD_VAR 0 2
58193: PUSH
58194: LD_VAR 0 3
58198: PUSH
58199: EMPTY
58200: LIST
58201: LIST
58202: LIST
58203: LIST
58204: PPUSH
58205: CALL_OW 1
58209: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58210: CALL 58219 0 0
// end ;
58214: LD_VAR 0 4
58218: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58219: LD_INT 0
58221: PPUSH
58222: PPUSH
58223: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58224: LD_STRING resetWarehouseGatheringPoints();
58226: PPUSH
58227: CALL_OW 559
// if warehouseGatheringPoints then
58231: LD_EXP 133
58235: IFFALSE 58361
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58237: LD_ADDR_VAR 0 3
58241: PUSH
58242: LD_EXP 133
58246: PPUSH
58247: CALL 104573 0 1
58251: ST_TO_ADDR
// for i := 1 to list do
58252: LD_ADDR_VAR 0 2
58256: PUSH
58257: DOUBLE
58258: LD_INT 1
58260: DEC
58261: ST_TO_ADDR
58262: LD_VAR 0 3
58266: PUSH
58267: FOR_TO
58268: IFFALSE 58359
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58270: LD_STRING setWarehouseGatheringPointXY(
58272: PUSH
58273: LD_VAR 0 3
58277: PUSH
58278: LD_VAR 0 2
58282: ARRAY
58283: PUSH
58284: LD_INT 1
58286: ARRAY
58287: STR
58288: PUSH
58289: LD_STRING ,
58291: STR
58292: PUSH
58293: LD_VAR 0 3
58297: PUSH
58298: LD_VAR 0 2
58302: ARRAY
58303: PUSH
58304: LD_INT 2
58306: ARRAY
58307: STR
58308: PUSH
58309: LD_STRING ,
58311: STR
58312: PUSH
58313: LD_VAR 0 3
58317: PUSH
58318: LD_VAR 0 2
58322: ARRAY
58323: PUSH
58324: LD_INT 3
58326: ARRAY
58327: STR
58328: PUSH
58329: LD_STRING ,
58331: STR
58332: PUSH
58333: LD_VAR 0 3
58337: PUSH
58338: LD_VAR 0 2
58342: ARRAY
58343: PUSH
58344: LD_INT 4
58346: ARRAY
58347: STR
58348: PUSH
58349: LD_STRING )
58351: STR
58352: PPUSH
58353: CALL_OW 559
58357: GO 58267
58359: POP
58360: POP
// end ; end ;
58361: LD_VAR 0 1
58365: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58366: LD_EXP 133
58370: IFFALSE 59055
58372: GO 58374
58374: DISABLE
58375: LD_INT 0
58377: PPUSH
58378: PPUSH
58379: PPUSH
58380: PPUSH
58381: PPUSH
58382: PPUSH
58383: PPUSH
58384: PPUSH
58385: PPUSH
// begin enable ;
58386: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58387: LD_ADDR_VAR 0 3
58391: PUSH
58392: LD_EXP 133
58396: PPUSH
58397: CALL 104573 0 1
58401: ST_TO_ADDR
// if not list then
58402: LD_VAR 0 3
58406: NOT
58407: IFFALSE 58411
// exit ;
58409: GO 59055
// for i := 1 to list do
58411: LD_ADDR_VAR 0 1
58415: PUSH
58416: DOUBLE
58417: LD_INT 1
58419: DEC
58420: ST_TO_ADDR
58421: LD_VAR 0 3
58425: PUSH
58426: FOR_TO
58427: IFFALSE 59053
// begin depot := list [ i ] [ 2 ] ;
58429: LD_ADDR_VAR 0 8
58433: PUSH
58434: LD_VAR 0 3
58438: PUSH
58439: LD_VAR 0 1
58443: ARRAY
58444: PUSH
58445: LD_INT 2
58447: ARRAY
58448: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58449: LD_ADDR_VAR 0 5
58453: PUSH
58454: LD_VAR 0 3
58458: PUSH
58459: LD_VAR 0 1
58463: ARRAY
58464: PUSH
58465: LD_INT 1
58467: ARRAY
58468: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58469: LD_VAR 0 8
58473: PPUSH
58474: CALL_OW 301
58478: PUSH
58479: LD_VAR 0 5
58483: PUSH
58484: LD_VAR 0 8
58488: PPUSH
58489: CALL_OW 255
58493: NONEQUAL
58494: OR
58495: IFFALSE 58524
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58497: LD_ADDR_EXP 133
58501: PUSH
58502: LD_EXP 133
58506: PPUSH
58507: LD_VAR 0 8
58511: PPUSH
58512: LD_INT 0
58514: PPUSH
58515: CALL_OW 1
58519: ST_TO_ADDR
// exit ;
58520: POP
58521: POP
58522: GO 59055
// end ; x := list [ i ] [ 3 ] ;
58524: LD_ADDR_VAR 0 6
58528: PUSH
58529: LD_VAR 0 3
58533: PUSH
58534: LD_VAR 0 1
58538: ARRAY
58539: PUSH
58540: LD_INT 3
58542: ARRAY
58543: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58544: LD_ADDR_VAR 0 7
58548: PUSH
58549: LD_VAR 0 3
58553: PUSH
58554: LD_VAR 0 1
58558: ARRAY
58559: PUSH
58560: LD_INT 4
58562: ARRAY
58563: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58564: LD_ADDR_VAR 0 9
58568: PUSH
58569: LD_VAR 0 6
58573: PPUSH
58574: LD_VAR 0 7
58578: PPUSH
58579: LD_INT 16
58581: PPUSH
58582: CALL 103161 0 3
58586: ST_TO_ADDR
// if not cratesNearbyPoint then
58587: LD_VAR 0 9
58591: NOT
58592: IFFALSE 58598
// exit ;
58594: POP
58595: POP
58596: GO 59055
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58598: LD_ADDR_VAR 0 4
58602: PUSH
58603: LD_INT 22
58605: PUSH
58606: LD_VAR 0 5
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: PUSH
58615: LD_INT 3
58617: PUSH
58618: LD_INT 60
58620: PUSH
58621: EMPTY
58622: LIST
58623: PUSH
58624: EMPTY
58625: LIST
58626: LIST
58627: PUSH
58628: LD_INT 91
58630: PUSH
58631: LD_VAR 0 8
58635: PUSH
58636: LD_INT 6
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: LIST
58643: PUSH
58644: LD_INT 2
58646: PUSH
58647: LD_INT 25
58649: PUSH
58650: LD_INT 2
58652: PUSH
58653: EMPTY
58654: LIST
58655: LIST
58656: PUSH
58657: LD_INT 25
58659: PUSH
58660: LD_INT 16
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: LIST
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: LIST
58676: LIST
58677: PPUSH
58678: CALL_OW 69
58682: PUSH
58683: LD_VAR 0 8
58687: PPUSH
58688: CALL_OW 313
58692: PPUSH
58693: LD_INT 3
58695: PUSH
58696: LD_INT 60
58698: PUSH
58699: EMPTY
58700: LIST
58701: PUSH
58702: EMPTY
58703: LIST
58704: LIST
58705: PUSH
58706: LD_INT 2
58708: PUSH
58709: LD_INT 25
58711: PUSH
58712: LD_INT 2
58714: PUSH
58715: EMPTY
58716: LIST
58717: LIST
58718: PUSH
58719: LD_INT 25
58721: PUSH
58722: LD_INT 16
58724: PUSH
58725: EMPTY
58726: LIST
58727: LIST
58728: PUSH
58729: EMPTY
58730: LIST
58731: LIST
58732: LIST
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PPUSH
58738: CALL_OW 72
58742: UNION
58743: ST_TO_ADDR
// if tmp then
58744: LD_VAR 0 4
58748: IFFALSE 58828
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58750: LD_ADDR_VAR 0 4
58754: PUSH
58755: LD_VAR 0 4
58759: PPUSH
58760: LD_INT 3
58762: PPUSH
58763: CALL 101130 0 2
58767: ST_TO_ADDR
// for j in tmp do
58768: LD_ADDR_VAR 0 2
58772: PUSH
58773: LD_VAR 0 4
58777: PUSH
58778: FOR_IN
58779: IFFALSE 58822
// begin if IsInUnit ( j ) then
58781: LD_VAR 0 2
58785: PPUSH
58786: CALL_OW 310
58790: IFFALSE 58801
// ComExit ( j ) ;
58792: LD_VAR 0 2
58796: PPUSH
58797: CALL 101213 0 1
// AddComCollect ( j , x , y ) ;
58801: LD_VAR 0 2
58805: PPUSH
58806: LD_VAR 0 6
58810: PPUSH
58811: LD_VAR 0 7
58815: PPUSH
58816: CALL_OW 177
// end ;
58820: GO 58778
58822: POP
58823: POP
// exit ;
58824: POP
58825: POP
58826: GO 59055
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58828: LD_ADDR_VAR 0 4
58832: PUSH
58833: LD_INT 22
58835: PUSH
58836: LD_VAR 0 5
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: PUSH
58845: LD_INT 91
58847: PUSH
58848: LD_VAR 0 8
58852: PUSH
58853: LD_INT 8
58855: PUSH
58856: EMPTY
58857: LIST
58858: LIST
58859: LIST
58860: PUSH
58861: LD_INT 2
58863: PUSH
58864: LD_INT 34
58866: PUSH
58867: LD_INT 12
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: PUSH
58874: LD_INT 34
58876: PUSH
58877: LD_INT 51
58879: PUSH
58880: EMPTY
58881: LIST
58882: LIST
58883: PUSH
58884: LD_INT 34
58886: PUSH
58887: LD_INT 32
58889: PUSH
58890: EMPTY
58891: LIST
58892: LIST
58893: PUSH
58894: LD_INT 34
58896: PUSH
58897: LD_INT 89
58899: PUSH
58900: EMPTY
58901: LIST
58902: LIST
58903: PUSH
58904: EMPTY
58905: LIST
58906: LIST
58907: LIST
58908: LIST
58909: LIST
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: LIST
58915: PPUSH
58916: CALL_OW 69
58920: ST_TO_ADDR
// if tmp then
58921: LD_VAR 0 4
58925: IFFALSE 59051
// begin for j in tmp do
58927: LD_ADDR_VAR 0 2
58931: PUSH
58932: LD_VAR 0 4
58936: PUSH
58937: FOR_IN
58938: IFFALSE 59049
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58940: LD_VAR 0 2
58944: PPUSH
58945: CALL_OW 262
58949: PUSH
58950: LD_INT 3
58952: EQUAL
58953: PUSH
58954: LD_VAR 0 2
58958: PPUSH
58959: CALL_OW 261
58963: PUSH
58964: LD_INT 20
58966: GREATER
58967: OR
58968: PUSH
58969: LD_VAR 0 2
58973: PPUSH
58974: CALL_OW 314
58978: NOT
58979: AND
58980: PUSH
58981: LD_VAR 0 2
58985: PPUSH
58986: CALL_OW 263
58990: PUSH
58991: LD_INT 1
58993: NONEQUAL
58994: PUSH
58995: LD_VAR 0 2
58999: PPUSH
59000: CALL_OW 311
59004: OR
59005: AND
59006: IFFALSE 59047
// begin ComCollect ( j , x , y ) ;
59008: LD_VAR 0 2
59012: PPUSH
59013: LD_VAR 0 6
59017: PPUSH
59018: LD_VAR 0 7
59022: PPUSH
59023: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
59027: LD_VAR 0 2
59031: PPUSH
59032: LD_VAR 0 8
59036: PPUSH
59037: CALL_OW 172
// exit ;
59041: POP
59042: POP
59043: POP
59044: POP
59045: GO 59055
// end ;
59047: GO 58937
59049: POP
59050: POP
// end ; end ;
59051: GO 58426
59053: POP
59054: POP
// end ; end_of_file
59055: PPOPN 9
59057: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59058: LD_INT 0
59060: PPUSH
59061: PPUSH
59062: PPUSH
59063: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59064: LD_VAR 0 1
59068: PPUSH
59069: CALL_OW 264
59073: PUSH
59074: LD_INT 91
59076: EQUAL
59077: IFFALSE 59149
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59079: LD_INT 68
59081: PPUSH
59082: LD_VAR 0 1
59086: PPUSH
59087: CALL_OW 255
59091: PPUSH
59092: CALL_OW 321
59096: PUSH
59097: LD_INT 2
59099: EQUAL
59100: IFFALSE 59112
// eff := 70 else
59102: LD_ADDR_VAR 0 4
59106: PUSH
59107: LD_INT 70
59109: ST_TO_ADDR
59110: GO 59120
// eff := 30 ;
59112: LD_ADDR_VAR 0 4
59116: PUSH
59117: LD_INT 30
59119: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59120: LD_VAR 0 1
59124: PPUSH
59125: CALL_OW 250
59129: PPUSH
59130: LD_VAR 0 1
59134: PPUSH
59135: CALL_OW 251
59139: PPUSH
59140: LD_VAR 0 4
59144: PPUSH
59145: CALL_OW 495
// end ; end ;
59149: LD_VAR 0 2
59153: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59154: LD_INT 0
59156: PPUSH
// end ;
59157: LD_VAR 0 4
59161: RET
// export function SOS_Command ( cmd ) ; begin
59162: LD_INT 0
59164: PPUSH
// end ;
59165: LD_VAR 0 2
59169: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59170: LD_INT 0
59172: PPUSH
// end ;
59173: LD_VAR 0 6
59177: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59178: LD_INT 0
59180: PPUSH
59181: PPUSH
// if not vehicle or not factory then
59182: LD_VAR 0 1
59186: NOT
59187: PUSH
59188: LD_VAR 0 2
59192: NOT
59193: OR
59194: IFFALSE 59198
// exit ;
59196: GO 59429
// if factoryWaypoints >= factory then
59198: LD_EXP 132
59202: PUSH
59203: LD_VAR 0 2
59207: GREATEREQUAL
59208: IFFALSE 59429
// if factoryWaypoints [ factory ] then
59210: LD_EXP 132
59214: PUSH
59215: LD_VAR 0 2
59219: ARRAY
59220: IFFALSE 59429
// begin if GetControl ( vehicle ) = control_manual then
59222: LD_VAR 0 1
59226: PPUSH
59227: CALL_OW 263
59231: PUSH
59232: LD_INT 1
59234: EQUAL
59235: IFFALSE 59316
// begin driver := IsDrivenBy ( vehicle ) ;
59237: LD_ADDR_VAR 0 4
59241: PUSH
59242: LD_VAR 0 1
59246: PPUSH
59247: CALL_OW 311
59251: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59252: LD_VAR 0 4
59256: PPUSH
59257: LD_EXP 132
59261: PUSH
59262: LD_VAR 0 2
59266: ARRAY
59267: PUSH
59268: LD_INT 3
59270: ARRAY
59271: PPUSH
59272: LD_EXP 132
59276: PUSH
59277: LD_VAR 0 2
59281: ARRAY
59282: PUSH
59283: LD_INT 4
59285: ARRAY
59286: PPUSH
59287: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59291: LD_VAR 0 4
59295: PPUSH
59296: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59300: LD_VAR 0 4
59304: PPUSH
59305: LD_VAR 0 2
59309: PPUSH
59310: CALL_OW 180
// end else
59314: GO 59429
// if GetControl ( vehicle ) = control_remote then
59316: LD_VAR 0 1
59320: PPUSH
59321: CALL_OW 263
59325: PUSH
59326: LD_INT 2
59328: EQUAL
59329: IFFALSE 59390
// begin wait ( 0 0$2 ) ;
59331: LD_INT 70
59333: PPUSH
59334: CALL_OW 67
// if Connect ( vehicle ) then
59338: LD_VAR 0 1
59342: PPUSH
59343: CALL 71453 0 1
59347: IFFALSE 59388
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59349: LD_VAR 0 1
59353: PPUSH
59354: LD_EXP 132
59358: PUSH
59359: LD_VAR 0 2
59363: ARRAY
59364: PUSH
59365: LD_INT 3
59367: ARRAY
59368: PPUSH
59369: LD_EXP 132
59373: PUSH
59374: LD_VAR 0 2
59378: ARRAY
59379: PUSH
59380: LD_INT 4
59382: ARRAY
59383: PPUSH
59384: CALL_OW 171
// end else
59388: GO 59429
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59390: LD_VAR 0 1
59394: PPUSH
59395: LD_EXP 132
59399: PUSH
59400: LD_VAR 0 2
59404: ARRAY
59405: PUSH
59406: LD_INT 3
59408: ARRAY
59409: PPUSH
59410: LD_EXP 132
59414: PUSH
59415: LD_VAR 0 2
59419: ARRAY
59420: PUSH
59421: LD_INT 4
59423: ARRAY
59424: PPUSH
59425: CALL_OW 171
// end ; end ;
59429: LD_VAR 0 3
59433: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59434: LD_INT 0
59436: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59437: LD_VAR 0 1
59441: PUSH
59442: LD_INT 250
59444: EQUAL
59445: PUSH
59446: LD_VAR 0 2
59450: PPUSH
59451: CALL_OW 264
59455: PUSH
59456: LD_INT 81
59458: EQUAL
59459: AND
59460: IFFALSE 59481
// MinerPlaceMine ( unit , x , y ) ;
59462: LD_VAR 0 2
59466: PPUSH
59467: LD_VAR 0 4
59471: PPUSH
59472: LD_VAR 0 5
59476: PPUSH
59477: CALL 61866 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59481: LD_VAR 0 1
59485: PUSH
59486: LD_INT 251
59488: EQUAL
59489: PUSH
59490: LD_VAR 0 2
59494: PPUSH
59495: CALL_OW 264
59499: PUSH
59500: LD_INT 81
59502: EQUAL
59503: AND
59504: IFFALSE 59525
// MinerDetonateMine ( unit , x , y ) ;
59506: LD_VAR 0 2
59510: PPUSH
59511: LD_VAR 0 4
59515: PPUSH
59516: LD_VAR 0 5
59520: PPUSH
59521: CALL 62141 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59525: LD_VAR 0 1
59529: PUSH
59530: LD_INT 252
59532: EQUAL
59533: PUSH
59534: LD_VAR 0 2
59538: PPUSH
59539: CALL_OW 264
59543: PUSH
59544: LD_INT 81
59546: EQUAL
59547: AND
59548: IFFALSE 59569
// MinerCreateMinefield ( unit , x , y ) ;
59550: LD_VAR 0 2
59554: PPUSH
59555: LD_VAR 0 4
59559: PPUSH
59560: LD_VAR 0 5
59564: PPUSH
59565: CALL 62558 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59569: LD_VAR 0 1
59573: PUSH
59574: LD_INT 253
59576: EQUAL
59577: PUSH
59578: LD_VAR 0 2
59582: PPUSH
59583: CALL_OW 257
59587: PUSH
59588: LD_INT 5
59590: EQUAL
59591: AND
59592: IFFALSE 59613
// ComBinocular ( unit , x , y ) ;
59594: LD_VAR 0 2
59598: PPUSH
59599: LD_VAR 0 4
59603: PPUSH
59604: LD_VAR 0 5
59608: PPUSH
59609: CALL 62927 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59613: LD_VAR 0 1
59617: PUSH
59618: LD_INT 254
59620: EQUAL
59621: PUSH
59622: LD_VAR 0 2
59626: PPUSH
59627: CALL_OW 264
59631: PUSH
59632: LD_INT 99
59634: EQUAL
59635: AND
59636: PUSH
59637: LD_VAR 0 3
59641: PPUSH
59642: CALL_OW 263
59646: PUSH
59647: LD_INT 3
59649: EQUAL
59650: AND
59651: IFFALSE 59667
// HackDestroyVehicle ( unit , selectedUnit ) ;
59653: LD_VAR 0 2
59657: PPUSH
59658: LD_VAR 0 3
59662: PPUSH
59663: CALL 61230 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59667: LD_VAR 0 1
59671: PUSH
59672: LD_INT 255
59674: EQUAL
59675: PUSH
59676: LD_VAR 0 2
59680: PPUSH
59681: CALL_OW 264
59685: PUSH
59686: LD_INT 14
59688: PUSH
59689: LD_INT 53
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: IN
59696: AND
59697: PUSH
59698: LD_VAR 0 4
59702: PPUSH
59703: LD_VAR 0 5
59707: PPUSH
59708: CALL_OW 488
59712: AND
59713: IFFALSE 59737
// CutTreeXYR ( unit , x , y , 12 ) ;
59715: LD_VAR 0 2
59719: PPUSH
59720: LD_VAR 0 4
59724: PPUSH
59725: LD_VAR 0 5
59729: PPUSH
59730: LD_INT 12
59732: PPUSH
59733: CALL 59800 0 4
// if cmd = 256 then
59737: LD_VAR 0 1
59741: PUSH
59742: LD_INT 256
59744: EQUAL
59745: IFFALSE 59766
// SetFactoryWaypoint ( unit , x , y ) ;
59747: LD_VAR 0 2
59751: PPUSH
59752: LD_VAR 0 4
59756: PPUSH
59757: LD_VAR 0 5
59761: PPUSH
59762: CALL 57747 0 3
// if cmd = 257 then
59766: LD_VAR 0 1
59770: PUSH
59771: LD_INT 257
59773: EQUAL
59774: IFFALSE 59795
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59776: LD_VAR 0 2
59780: PPUSH
59781: LD_VAR 0 4
59785: PPUSH
59786: LD_VAR 0 5
59790: PPUSH
59791: CALL 58109 0 3
// end ;
59795: LD_VAR 0 6
59799: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59800: LD_INT 0
59802: PPUSH
59803: PPUSH
59804: PPUSH
59805: PPUSH
59806: PPUSH
59807: PPUSH
59808: PPUSH
59809: PPUSH
59810: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59811: LD_VAR 0 1
59815: NOT
59816: PUSH
59817: LD_VAR 0 2
59821: PPUSH
59822: LD_VAR 0 3
59826: PPUSH
59827: CALL_OW 488
59831: NOT
59832: OR
59833: PUSH
59834: LD_VAR 0 4
59838: NOT
59839: OR
59840: IFFALSE 59844
// exit ;
59842: GO 60184
// list := [ ] ;
59844: LD_ADDR_VAR 0 13
59848: PUSH
59849: EMPTY
59850: ST_TO_ADDR
// if x - r < 0 then
59851: LD_VAR 0 2
59855: PUSH
59856: LD_VAR 0 4
59860: MINUS
59861: PUSH
59862: LD_INT 0
59864: LESS
59865: IFFALSE 59877
// min_x := 0 else
59867: LD_ADDR_VAR 0 7
59871: PUSH
59872: LD_INT 0
59874: ST_TO_ADDR
59875: GO 59893
// min_x := x - r ;
59877: LD_ADDR_VAR 0 7
59881: PUSH
59882: LD_VAR 0 2
59886: PUSH
59887: LD_VAR 0 4
59891: MINUS
59892: ST_TO_ADDR
// if y - r < 0 then
59893: LD_VAR 0 3
59897: PUSH
59898: LD_VAR 0 4
59902: MINUS
59903: PUSH
59904: LD_INT 0
59906: LESS
59907: IFFALSE 59919
// min_y := 0 else
59909: LD_ADDR_VAR 0 8
59913: PUSH
59914: LD_INT 0
59916: ST_TO_ADDR
59917: GO 59935
// min_y := y - r ;
59919: LD_ADDR_VAR 0 8
59923: PUSH
59924: LD_VAR 0 3
59928: PUSH
59929: LD_VAR 0 4
59933: MINUS
59934: ST_TO_ADDR
// max_x := x + r ;
59935: LD_ADDR_VAR 0 9
59939: PUSH
59940: LD_VAR 0 2
59944: PUSH
59945: LD_VAR 0 4
59949: PLUS
59950: ST_TO_ADDR
// max_y := y + r ;
59951: LD_ADDR_VAR 0 10
59955: PUSH
59956: LD_VAR 0 3
59960: PUSH
59961: LD_VAR 0 4
59965: PLUS
59966: ST_TO_ADDR
// for _x = min_x to max_x do
59967: LD_ADDR_VAR 0 11
59971: PUSH
59972: DOUBLE
59973: LD_VAR 0 7
59977: DEC
59978: ST_TO_ADDR
59979: LD_VAR 0 9
59983: PUSH
59984: FOR_TO
59985: IFFALSE 60102
// for _y = min_y to max_y do
59987: LD_ADDR_VAR 0 12
59991: PUSH
59992: DOUBLE
59993: LD_VAR 0 8
59997: DEC
59998: ST_TO_ADDR
59999: LD_VAR 0 10
60003: PUSH
60004: FOR_TO
60005: IFFALSE 60098
// begin if not ValidHex ( _x , _y ) then
60007: LD_VAR 0 11
60011: PPUSH
60012: LD_VAR 0 12
60016: PPUSH
60017: CALL_OW 488
60021: NOT
60022: IFFALSE 60026
// continue ;
60024: GO 60004
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60026: LD_VAR 0 11
60030: PPUSH
60031: LD_VAR 0 12
60035: PPUSH
60036: CALL_OW 351
60040: PUSH
60041: LD_VAR 0 11
60045: PPUSH
60046: LD_VAR 0 12
60050: PPUSH
60051: CALL_OW 554
60055: AND
60056: IFFALSE 60096
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60058: LD_ADDR_VAR 0 13
60062: PUSH
60063: LD_VAR 0 13
60067: PPUSH
60068: LD_VAR 0 13
60072: PUSH
60073: LD_INT 1
60075: PLUS
60076: PPUSH
60077: LD_VAR 0 11
60081: PUSH
60082: LD_VAR 0 12
60086: PUSH
60087: EMPTY
60088: LIST
60089: LIST
60090: PPUSH
60091: CALL_OW 2
60095: ST_TO_ADDR
// end ;
60096: GO 60004
60098: POP
60099: POP
60100: GO 59984
60102: POP
60103: POP
// if not list then
60104: LD_VAR 0 13
60108: NOT
60109: IFFALSE 60113
// exit ;
60111: GO 60184
// for i in list do
60113: LD_ADDR_VAR 0 6
60117: PUSH
60118: LD_VAR 0 13
60122: PUSH
60123: FOR_IN
60124: IFFALSE 60182
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60126: LD_VAR 0 1
60130: PPUSH
60131: LD_STRING M
60133: PUSH
60134: LD_VAR 0 6
60138: PUSH
60139: LD_INT 1
60141: ARRAY
60142: PUSH
60143: LD_VAR 0 6
60147: PUSH
60148: LD_INT 2
60150: ARRAY
60151: PUSH
60152: LD_INT 0
60154: PUSH
60155: LD_INT 0
60157: PUSH
60158: LD_INT 0
60160: PUSH
60161: LD_INT 0
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: LIST
60168: LIST
60169: LIST
60170: LIST
60171: LIST
60172: PUSH
60173: EMPTY
60174: LIST
60175: PPUSH
60176: CALL_OW 447
60180: GO 60123
60182: POP
60183: POP
// end ;
60184: LD_VAR 0 5
60188: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60189: LD_EXP 135
60193: NOT
60194: IFFALSE 60244
60196: GO 60198
60198: DISABLE
// begin initHack := true ;
60199: LD_ADDR_EXP 135
60203: PUSH
60204: LD_INT 1
60206: ST_TO_ADDR
// hackTanks := [ ] ;
60207: LD_ADDR_EXP 136
60211: PUSH
60212: EMPTY
60213: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60214: LD_ADDR_EXP 137
60218: PUSH
60219: EMPTY
60220: ST_TO_ADDR
// hackLimit := 3 ;
60221: LD_ADDR_EXP 138
60225: PUSH
60226: LD_INT 3
60228: ST_TO_ADDR
// hackDist := 12 ;
60229: LD_ADDR_EXP 139
60233: PUSH
60234: LD_INT 12
60236: ST_TO_ADDR
// hackCounter := [ ] ;
60237: LD_ADDR_EXP 140
60241: PUSH
60242: EMPTY
60243: ST_TO_ADDR
// end ;
60244: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60245: LD_EXP 135
60249: PUSH
60250: LD_INT 34
60252: PUSH
60253: LD_INT 99
60255: PUSH
60256: EMPTY
60257: LIST
60258: LIST
60259: PPUSH
60260: CALL_OW 69
60264: AND
60265: IFFALSE 60518
60267: GO 60269
60269: DISABLE
60270: LD_INT 0
60272: PPUSH
60273: PPUSH
// begin enable ;
60274: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60275: LD_ADDR_VAR 0 1
60279: PUSH
60280: LD_INT 34
60282: PUSH
60283: LD_INT 99
60285: PUSH
60286: EMPTY
60287: LIST
60288: LIST
60289: PPUSH
60290: CALL_OW 69
60294: PUSH
60295: FOR_IN
60296: IFFALSE 60516
// begin if not i in hackTanks then
60298: LD_VAR 0 1
60302: PUSH
60303: LD_EXP 136
60307: IN
60308: NOT
60309: IFFALSE 60392
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60311: LD_ADDR_EXP 136
60315: PUSH
60316: LD_EXP 136
60320: PPUSH
60321: LD_EXP 136
60325: PUSH
60326: LD_INT 1
60328: PLUS
60329: PPUSH
60330: LD_VAR 0 1
60334: PPUSH
60335: CALL_OW 1
60339: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60340: LD_ADDR_EXP 137
60344: PUSH
60345: LD_EXP 137
60349: PPUSH
60350: LD_EXP 137
60354: PUSH
60355: LD_INT 1
60357: PLUS
60358: PPUSH
60359: EMPTY
60360: PPUSH
60361: CALL_OW 1
60365: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60366: LD_ADDR_EXP 140
60370: PUSH
60371: LD_EXP 140
60375: PPUSH
60376: LD_EXP 140
60380: PUSH
60381: LD_INT 1
60383: PLUS
60384: PPUSH
60385: EMPTY
60386: PPUSH
60387: CALL_OW 1
60391: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60392: LD_VAR 0 1
60396: PPUSH
60397: CALL_OW 302
60401: NOT
60402: IFFALSE 60415
// begin HackUnlinkAll ( i ) ;
60404: LD_VAR 0 1
60408: PPUSH
60409: CALL 60521 0 1
// continue ;
60413: GO 60295
// end ; HackCheckCapturedStatus ( i ) ;
60415: LD_VAR 0 1
60419: PPUSH
60420: CALL 60964 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60424: LD_ADDR_VAR 0 2
60428: PUSH
60429: LD_INT 81
60431: PUSH
60432: LD_VAR 0 1
60436: PPUSH
60437: CALL_OW 255
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: PUSH
60446: LD_INT 33
60448: PUSH
60449: LD_INT 3
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: LD_INT 91
60458: PUSH
60459: LD_VAR 0 1
60463: PUSH
60464: LD_EXP 139
60468: PUSH
60469: EMPTY
60470: LIST
60471: LIST
60472: LIST
60473: PUSH
60474: LD_INT 50
60476: PUSH
60477: EMPTY
60478: LIST
60479: PUSH
60480: EMPTY
60481: LIST
60482: LIST
60483: LIST
60484: LIST
60485: PPUSH
60486: CALL_OW 69
60490: ST_TO_ADDR
// if not tmp then
60491: LD_VAR 0 2
60495: NOT
60496: IFFALSE 60500
// continue ;
60498: GO 60295
// HackLink ( i , tmp ) ;
60500: LD_VAR 0 1
60504: PPUSH
60505: LD_VAR 0 2
60509: PPUSH
60510: CALL 60657 0 2
// end ;
60514: GO 60295
60516: POP
60517: POP
// end ;
60518: PPOPN 2
60520: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60521: LD_INT 0
60523: PPUSH
60524: PPUSH
60525: PPUSH
// if not hack in hackTanks then
60526: LD_VAR 0 1
60530: PUSH
60531: LD_EXP 136
60535: IN
60536: NOT
60537: IFFALSE 60541
// exit ;
60539: GO 60652
// index := GetElementIndex ( hackTanks , hack ) ;
60541: LD_ADDR_VAR 0 4
60545: PUSH
60546: LD_EXP 136
60550: PPUSH
60551: LD_VAR 0 1
60555: PPUSH
60556: CALL 68269 0 2
60560: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60561: LD_EXP 137
60565: PUSH
60566: LD_VAR 0 4
60570: ARRAY
60571: IFFALSE 60652
// begin for i in hackTanksCaptured [ index ] do
60573: LD_ADDR_VAR 0 3
60577: PUSH
60578: LD_EXP 137
60582: PUSH
60583: LD_VAR 0 4
60587: ARRAY
60588: PUSH
60589: FOR_IN
60590: IFFALSE 60616
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60592: LD_VAR 0 3
60596: PUSH
60597: LD_INT 1
60599: ARRAY
60600: PPUSH
60601: LD_VAR 0 3
60605: PUSH
60606: LD_INT 2
60608: ARRAY
60609: PPUSH
60610: CALL_OW 235
60614: GO 60589
60616: POP
60617: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60618: LD_ADDR_EXP 137
60622: PUSH
60623: LD_EXP 137
60627: PPUSH
60628: LD_VAR 0 4
60632: PPUSH
60633: EMPTY
60634: PPUSH
60635: CALL_OW 1
60639: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60640: LD_VAR 0 1
60644: PPUSH
60645: LD_INT 0
60647: PPUSH
60648: CALL_OW 505
// end ; end ;
60652: LD_VAR 0 2
60656: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60657: LD_INT 0
60659: PPUSH
60660: PPUSH
60661: PPUSH
// if not hack in hackTanks or not vehicles then
60662: LD_VAR 0 1
60666: PUSH
60667: LD_EXP 136
60671: IN
60672: NOT
60673: PUSH
60674: LD_VAR 0 2
60678: NOT
60679: OR
60680: IFFALSE 60684
// exit ;
60682: GO 60959
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60684: LD_ADDR_VAR 0 2
60688: PUSH
60689: LD_VAR 0 1
60693: PPUSH
60694: LD_VAR 0 2
60698: PPUSH
60699: LD_INT 1
60701: PPUSH
60702: LD_INT 1
60704: PPUSH
60705: CALL 68919 0 4
60709: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60710: LD_ADDR_VAR 0 5
60714: PUSH
60715: LD_EXP 136
60719: PPUSH
60720: LD_VAR 0 1
60724: PPUSH
60725: CALL 68269 0 2
60729: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60730: LD_EXP 137
60734: PUSH
60735: LD_VAR 0 5
60739: ARRAY
60740: PUSH
60741: LD_EXP 138
60745: LESS
60746: IFFALSE 60935
// begin for i := 1 to vehicles do
60748: LD_ADDR_VAR 0 4
60752: PUSH
60753: DOUBLE
60754: LD_INT 1
60756: DEC
60757: ST_TO_ADDR
60758: LD_VAR 0 2
60762: PUSH
60763: FOR_TO
60764: IFFALSE 60933
// begin if hackTanksCaptured [ index ] = hackLimit then
60766: LD_EXP 137
60770: PUSH
60771: LD_VAR 0 5
60775: ARRAY
60776: PUSH
60777: LD_EXP 138
60781: EQUAL
60782: IFFALSE 60786
// break ;
60784: GO 60933
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60786: LD_ADDR_EXP 140
60790: PUSH
60791: LD_EXP 140
60795: PPUSH
60796: LD_VAR 0 5
60800: PPUSH
60801: LD_EXP 140
60805: PUSH
60806: LD_VAR 0 5
60810: ARRAY
60811: PUSH
60812: LD_INT 1
60814: PLUS
60815: PPUSH
60816: CALL_OW 1
60820: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60821: LD_ADDR_EXP 137
60825: PUSH
60826: LD_EXP 137
60830: PPUSH
60831: LD_VAR 0 5
60835: PUSH
60836: LD_EXP 137
60840: PUSH
60841: LD_VAR 0 5
60845: ARRAY
60846: PUSH
60847: LD_INT 1
60849: PLUS
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: PPUSH
60855: LD_VAR 0 2
60859: PUSH
60860: LD_VAR 0 4
60864: ARRAY
60865: PUSH
60866: LD_VAR 0 2
60870: PUSH
60871: LD_VAR 0 4
60875: ARRAY
60876: PPUSH
60877: CALL_OW 255
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PPUSH
60886: CALL 68484 0 3
60890: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60891: LD_VAR 0 2
60895: PUSH
60896: LD_VAR 0 4
60900: ARRAY
60901: PPUSH
60902: LD_VAR 0 1
60906: PPUSH
60907: CALL_OW 255
60911: PPUSH
60912: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60916: LD_VAR 0 2
60920: PUSH
60921: LD_VAR 0 4
60925: ARRAY
60926: PPUSH
60927: CALL_OW 141
// end ;
60931: GO 60763
60933: POP
60934: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60935: LD_VAR 0 1
60939: PPUSH
60940: LD_EXP 137
60944: PUSH
60945: LD_VAR 0 5
60949: ARRAY
60950: PUSH
60951: LD_INT 0
60953: PLUS
60954: PPUSH
60955: CALL_OW 505
// end ;
60959: LD_VAR 0 3
60963: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60964: LD_INT 0
60966: PPUSH
60967: PPUSH
60968: PPUSH
60969: PPUSH
// if not hack in hackTanks then
60970: LD_VAR 0 1
60974: PUSH
60975: LD_EXP 136
60979: IN
60980: NOT
60981: IFFALSE 60985
// exit ;
60983: GO 61225
// index := GetElementIndex ( hackTanks , hack ) ;
60985: LD_ADDR_VAR 0 4
60989: PUSH
60990: LD_EXP 136
60994: PPUSH
60995: LD_VAR 0 1
60999: PPUSH
61000: CALL 68269 0 2
61004: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61005: LD_ADDR_VAR 0 3
61009: PUSH
61010: DOUBLE
61011: LD_EXP 137
61015: PUSH
61016: LD_VAR 0 4
61020: ARRAY
61021: INC
61022: ST_TO_ADDR
61023: LD_INT 1
61025: PUSH
61026: FOR_DOWNTO
61027: IFFALSE 61199
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61029: LD_ADDR_VAR 0 5
61033: PUSH
61034: LD_EXP 137
61038: PUSH
61039: LD_VAR 0 4
61043: ARRAY
61044: PUSH
61045: LD_VAR 0 3
61049: ARRAY
61050: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61051: LD_VAR 0 5
61055: PUSH
61056: LD_INT 1
61058: ARRAY
61059: PPUSH
61060: CALL_OW 302
61064: NOT
61065: PUSH
61066: LD_VAR 0 5
61070: PUSH
61071: LD_INT 1
61073: ARRAY
61074: PPUSH
61075: CALL_OW 255
61079: PUSH
61080: LD_VAR 0 1
61084: PPUSH
61085: CALL_OW 255
61089: NONEQUAL
61090: OR
61091: IFFALSE 61197
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61093: LD_VAR 0 5
61097: PUSH
61098: LD_INT 1
61100: ARRAY
61101: PPUSH
61102: CALL_OW 305
61106: PUSH
61107: LD_VAR 0 5
61111: PUSH
61112: LD_INT 1
61114: ARRAY
61115: PPUSH
61116: CALL_OW 255
61120: PUSH
61121: LD_VAR 0 1
61125: PPUSH
61126: CALL_OW 255
61130: EQUAL
61131: AND
61132: IFFALSE 61156
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61134: LD_VAR 0 5
61138: PUSH
61139: LD_INT 1
61141: ARRAY
61142: PPUSH
61143: LD_VAR 0 5
61147: PUSH
61148: LD_INT 2
61150: ARRAY
61151: PPUSH
61152: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61156: LD_ADDR_EXP 137
61160: PUSH
61161: LD_EXP 137
61165: PPUSH
61166: LD_VAR 0 4
61170: PPUSH
61171: LD_EXP 137
61175: PUSH
61176: LD_VAR 0 4
61180: ARRAY
61181: PPUSH
61182: LD_VAR 0 3
61186: PPUSH
61187: CALL_OW 3
61191: PPUSH
61192: CALL_OW 1
61196: ST_TO_ADDR
// end ; end ;
61197: GO 61026
61199: POP
61200: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61201: LD_VAR 0 1
61205: PPUSH
61206: LD_EXP 137
61210: PUSH
61211: LD_VAR 0 4
61215: ARRAY
61216: PUSH
61217: LD_INT 0
61219: PLUS
61220: PPUSH
61221: CALL_OW 505
// end ;
61225: LD_VAR 0 2
61229: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61230: LD_INT 0
61232: PPUSH
61233: PPUSH
61234: PPUSH
61235: PPUSH
// if not hack in hackTanks then
61236: LD_VAR 0 1
61240: PUSH
61241: LD_EXP 136
61245: IN
61246: NOT
61247: IFFALSE 61251
// exit ;
61249: GO 61336
// index := GetElementIndex ( hackTanks , hack ) ;
61251: LD_ADDR_VAR 0 5
61255: PUSH
61256: LD_EXP 136
61260: PPUSH
61261: LD_VAR 0 1
61265: PPUSH
61266: CALL 68269 0 2
61270: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61271: LD_ADDR_VAR 0 4
61275: PUSH
61276: DOUBLE
61277: LD_INT 1
61279: DEC
61280: ST_TO_ADDR
61281: LD_EXP 137
61285: PUSH
61286: LD_VAR 0 5
61290: ARRAY
61291: PUSH
61292: FOR_TO
61293: IFFALSE 61334
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61295: LD_EXP 137
61299: PUSH
61300: LD_VAR 0 5
61304: ARRAY
61305: PUSH
61306: LD_VAR 0 4
61310: ARRAY
61311: PUSH
61312: LD_INT 1
61314: ARRAY
61315: PUSH
61316: LD_VAR 0 2
61320: EQUAL
61321: IFFALSE 61332
// KillUnit ( vehicle ) ;
61323: LD_VAR 0 2
61327: PPUSH
61328: CALL_OW 66
61332: GO 61292
61334: POP
61335: POP
// end ;
61336: LD_VAR 0 3
61340: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61341: LD_EXP 141
61345: NOT
61346: IFFALSE 61381
61348: GO 61350
61350: DISABLE
// begin initMiner := true ;
61351: LD_ADDR_EXP 141
61355: PUSH
61356: LD_INT 1
61358: ST_TO_ADDR
// minersList := [ ] ;
61359: LD_ADDR_EXP 142
61363: PUSH
61364: EMPTY
61365: ST_TO_ADDR
// minerMinesList := [ ] ;
61366: LD_ADDR_EXP 143
61370: PUSH
61371: EMPTY
61372: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61373: LD_ADDR_EXP 144
61377: PUSH
61378: LD_INT 5
61380: ST_TO_ADDR
// end ;
61381: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61382: LD_EXP 141
61386: PUSH
61387: LD_INT 34
61389: PUSH
61390: LD_INT 81
61392: PUSH
61393: EMPTY
61394: LIST
61395: LIST
61396: PPUSH
61397: CALL_OW 69
61401: AND
61402: IFFALSE 61863
61404: GO 61406
61406: DISABLE
61407: LD_INT 0
61409: PPUSH
61410: PPUSH
61411: PPUSH
61412: PPUSH
// begin enable ;
61413: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61414: LD_ADDR_VAR 0 1
61418: PUSH
61419: LD_INT 34
61421: PUSH
61422: LD_INT 81
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PPUSH
61429: CALL_OW 69
61433: PUSH
61434: FOR_IN
61435: IFFALSE 61507
// begin if not i in minersList then
61437: LD_VAR 0 1
61441: PUSH
61442: LD_EXP 142
61446: IN
61447: NOT
61448: IFFALSE 61505
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61450: LD_ADDR_EXP 142
61454: PUSH
61455: LD_EXP 142
61459: PPUSH
61460: LD_EXP 142
61464: PUSH
61465: LD_INT 1
61467: PLUS
61468: PPUSH
61469: LD_VAR 0 1
61473: PPUSH
61474: CALL_OW 1
61478: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61479: LD_ADDR_EXP 143
61483: PUSH
61484: LD_EXP 143
61488: PPUSH
61489: LD_EXP 143
61493: PUSH
61494: LD_INT 1
61496: PLUS
61497: PPUSH
61498: EMPTY
61499: PPUSH
61500: CALL_OW 1
61504: ST_TO_ADDR
// end end ;
61505: GO 61434
61507: POP
61508: POP
// for i := minerMinesList downto 1 do
61509: LD_ADDR_VAR 0 1
61513: PUSH
61514: DOUBLE
61515: LD_EXP 143
61519: INC
61520: ST_TO_ADDR
61521: LD_INT 1
61523: PUSH
61524: FOR_DOWNTO
61525: IFFALSE 61861
// begin if IsLive ( minersList [ i ] ) then
61527: LD_EXP 142
61531: PUSH
61532: LD_VAR 0 1
61536: ARRAY
61537: PPUSH
61538: CALL_OW 300
61542: IFFALSE 61570
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61544: LD_EXP 142
61548: PUSH
61549: LD_VAR 0 1
61553: ARRAY
61554: PPUSH
61555: LD_EXP 143
61559: PUSH
61560: LD_VAR 0 1
61564: ARRAY
61565: PPUSH
61566: CALL_OW 505
// if not minerMinesList [ i ] then
61570: LD_EXP 143
61574: PUSH
61575: LD_VAR 0 1
61579: ARRAY
61580: NOT
61581: IFFALSE 61585
// continue ;
61583: GO 61524
// for j := minerMinesList [ i ] downto 1 do
61585: LD_ADDR_VAR 0 2
61589: PUSH
61590: DOUBLE
61591: LD_EXP 143
61595: PUSH
61596: LD_VAR 0 1
61600: ARRAY
61601: INC
61602: ST_TO_ADDR
61603: LD_INT 1
61605: PUSH
61606: FOR_DOWNTO
61607: IFFALSE 61857
// begin side := GetSide ( minersList [ i ] ) ;
61609: LD_ADDR_VAR 0 3
61613: PUSH
61614: LD_EXP 142
61618: PUSH
61619: LD_VAR 0 1
61623: ARRAY
61624: PPUSH
61625: CALL_OW 255
61629: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61630: LD_ADDR_VAR 0 4
61634: PUSH
61635: LD_EXP 143
61639: PUSH
61640: LD_VAR 0 1
61644: ARRAY
61645: PUSH
61646: LD_VAR 0 2
61650: ARRAY
61651: PUSH
61652: LD_INT 1
61654: ARRAY
61655: PPUSH
61656: LD_EXP 143
61660: PUSH
61661: LD_VAR 0 1
61665: ARRAY
61666: PUSH
61667: LD_VAR 0 2
61671: ARRAY
61672: PUSH
61673: LD_INT 2
61675: ARRAY
61676: PPUSH
61677: CALL_OW 428
61681: ST_TO_ADDR
// if not tmp then
61682: LD_VAR 0 4
61686: NOT
61687: IFFALSE 61691
// continue ;
61689: GO 61606
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61691: LD_VAR 0 4
61695: PUSH
61696: LD_INT 81
61698: PUSH
61699: LD_VAR 0 3
61703: PUSH
61704: EMPTY
61705: LIST
61706: LIST
61707: PPUSH
61708: CALL_OW 69
61712: IN
61713: PUSH
61714: LD_EXP 143
61718: PUSH
61719: LD_VAR 0 1
61723: ARRAY
61724: PUSH
61725: LD_VAR 0 2
61729: ARRAY
61730: PUSH
61731: LD_INT 1
61733: ARRAY
61734: PPUSH
61735: LD_EXP 143
61739: PUSH
61740: LD_VAR 0 1
61744: ARRAY
61745: PUSH
61746: LD_VAR 0 2
61750: ARRAY
61751: PUSH
61752: LD_INT 2
61754: ARRAY
61755: PPUSH
61756: CALL_OW 458
61760: AND
61761: IFFALSE 61855
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61763: LD_EXP 143
61767: PUSH
61768: LD_VAR 0 1
61772: ARRAY
61773: PUSH
61774: LD_VAR 0 2
61778: ARRAY
61779: PUSH
61780: LD_INT 1
61782: ARRAY
61783: PPUSH
61784: LD_EXP 143
61788: PUSH
61789: LD_VAR 0 1
61793: ARRAY
61794: PUSH
61795: LD_VAR 0 2
61799: ARRAY
61800: PUSH
61801: LD_INT 2
61803: ARRAY
61804: PPUSH
61805: LD_VAR 0 3
61809: PPUSH
61810: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61814: LD_ADDR_EXP 143
61818: PUSH
61819: LD_EXP 143
61823: PPUSH
61824: LD_VAR 0 1
61828: PPUSH
61829: LD_EXP 143
61833: PUSH
61834: LD_VAR 0 1
61838: ARRAY
61839: PPUSH
61840: LD_VAR 0 2
61844: PPUSH
61845: CALL_OW 3
61849: PPUSH
61850: CALL_OW 1
61854: ST_TO_ADDR
// end ; end ;
61855: GO 61606
61857: POP
61858: POP
// end ;
61859: GO 61524
61861: POP
61862: POP
// end ;
61863: PPOPN 4
61865: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61866: LD_INT 0
61868: PPUSH
61869: PPUSH
// result := false ;
61870: LD_ADDR_VAR 0 4
61874: PUSH
61875: LD_INT 0
61877: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61878: LD_VAR 0 1
61882: PPUSH
61883: CALL_OW 264
61887: PUSH
61888: LD_INT 81
61890: EQUAL
61891: NOT
61892: IFFALSE 61896
// exit ;
61894: GO 62136
// index := GetElementIndex ( minersList , unit ) ;
61896: LD_ADDR_VAR 0 5
61900: PUSH
61901: LD_EXP 142
61905: PPUSH
61906: LD_VAR 0 1
61910: PPUSH
61911: CALL 68269 0 2
61915: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61916: LD_EXP 143
61920: PUSH
61921: LD_VAR 0 5
61925: ARRAY
61926: PUSH
61927: LD_EXP 144
61931: GREATEREQUAL
61932: IFFALSE 61936
// exit ;
61934: GO 62136
// ComMoveXY ( unit , x , y ) ;
61936: LD_VAR 0 1
61940: PPUSH
61941: LD_VAR 0 2
61945: PPUSH
61946: LD_VAR 0 3
61950: PPUSH
61951: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61955: LD_INT 35
61957: PPUSH
61958: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61962: LD_VAR 0 1
61966: PPUSH
61967: LD_VAR 0 2
61971: PPUSH
61972: LD_VAR 0 3
61976: PPUSH
61977: CALL 99624 0 3
61981: NOT
61982: PUSH
61983: LD_VAR 0 1
61987: PPUSH
61988: CALL_OW 314
61992: AND
61993: IFFALSE 61997
// exit ;
61995: GO 62136
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61997: LD_VAR 0 2
62001: PPUSH
62002: LD_VAR 0 3
62006: PPUSH
62007: CALL_OW 428
62011: PUSH
62012: LD_VAR 0 1
62016: EQUAL
62017: PUSH
62018: LD_VAR 0 1
62022: PPUSH
62023: CALL_OW 314
62027: NOT
62028: AND
62029: IFFALSE 61955
// PlaySoundXY ( x , y , PlantMine ) ;
62031: LD_VAR 0 2
62035: PPUSH
62036: LD_VAR 0 3
62040: PPUSH
62041: LD_STRING PlantMine
62043: PPUSH
62044: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62048: LD_VAR 0 2
62052: PPUSH
62053: LD_VAR 0 3
62057: PPUSH
62058: LD_VAR 0 1
62062: PPUSH
62063: CALL_OW 255
62067: PPUSH
62068: LD_INT 0
62070: PPUSH
62071: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62075: LD_ADDR_EXP 143
62079: PUSH
62080: LD_EXP 143
62084: PPUSH
62085: LD_VAR 0 5
62089: PUSH
62090: LD_EXP 143
62094: PUSH
62095: LD_VAR 0 5
62099: ARRAY
62100: PUSH
62101: LD_INT 1
62103: PLUS
62104: PUSH
62105: EMPTY
62106: LIST
62107: LIST
62108: PPUSH
62109: LD_VAR 0 2
62113: PUSH
62114: LD_VAR 0 3
62118: PUSH
62119: EMPTY
62120: LIST
62121: LIST
62122: PPUSH
62123: CALL 68484 0 3
62127: ST_TO_ADDR
// result := true ;
62128: LD_ADDR_VAR 0 4
62132: PUSH
62133: LD_INT 1
62135: ST_TO_ADDR
// end ;
62136: LD_VAR 0 4
62140: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62141: LD_INT 0
62143: PPUSH
62144: PPUSH
62145: PPUSH
// if not unit in minersList then
62146: LD_VAR 0 1
62150: PUSH
62151: LD_EXP 142
62155: IN
62156: NOT
62157: IFFALSE 62161
// exit ;
62159: GO 62553
// index := GetElementIndex ( minersList , unit ) ;
62161: LD_ADDR_VAR 0 6
62165: PUSH
62166: LD_EXP 142
62170: PPUSH
62171: LD_VAR 0 1
62175: PPUSH
62176: CALL 68269 0 2
62180: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62181: LD_ADDR_VAR 0 5
62185: PUSH
62186: DOUBLE
62187: LD_EXP 143
62191: PUSH
62192: LD_VAR 0 6
62196: ARRAY
62197: INC
62198: ST_TO_ADDR
62199: LD_INT 1
62201: PUSH
62202: FOR_DOWNTO
62203: IFFALSE 62364
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62205: LD_EXP 143
62209: PUSH
62210: LD_VAR 0 6
62214: ARRAY
62215: PUSH
62216: LD_VAR 0 5
62220: ARRAY
62221: PUSH
62222: LD_INT 1
62224: ARRAY
62225: PUSH
62226: LD_VAR 0 2
62230: EQUAL
62231: PUSH
62232: LD_EXP 143
62236: PUSH
62237: LD_VAR 0 6
62241: ARRAY
62242: PUSH
62243: LD_VAR 0 5
62247: ARRAY
62248: PUSH
62249: LD_INT 2
62251: ARRAY
62252: PUSH
62253: LD_VAR 0 3
62257: EQUAL
62258: AND
62259: IFFALSE 62362
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62261: LD_EXP 143
62265: PUSH
62266: LD_VAR 0 6
62270: ARRAY
62271: PUSH
62272: LD_VAR 0 5
62276: ARRAY
62277: PUSH
62278: LD_INT 1
62280: ARRAY
62281: PPUSH
62282: LD_EXP 143
62286: PUSH
62287: LD_VAR 0 6
62291: ARRAY
62292: PUSH
62293: LD_VAR 0 5
62297: ARRAY
62298: PUSH
62299: LD_INT 2
62301: ARRAY
62302: PPUSH
62303: LD_VAR 0 1
62307: PPUSH
62308: CALL_OW 255
62312: PPUSH
62313: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62317: LD_ADDR_EXP 143
62321: PUSH
62322: LD_EXP 143
62326: PPUSH
62327: LD_VAR 0 6
62331: PPUSH
62332: LD_EXP 143
62336: PUSH
62337: LD_VAR 0 6
62341: ARRAY
62342: PPUSH
62343: LD_VAR 0 5
62347: PPUSH
62348: CALL_OW 3
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// exit ;
62358: POP
62359: POP
62360: GO 62553
// end ; end ;
62362: GO 62202
62364: POP
62365: POP
// for i := minerMinesList [ index ] downto 1 do
62366: LD_ADDR_VAR 0 5
62370: PUSH
62371: DOUBLE
62372: LD_EXP 143
62376: PUSH
62377: LD_VAR 0 6
62381: ARRAY
62382: INC
62383: ST_TO_ADDR
62384: LD_INT 1
62386: PUSH
62387: FOR_DOWNTO
62388: IFFALSE 62551
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62390: LD_EXP 143
62394: PUSH
62395: LD_VAR 0 6
62399: ARRAY
62400: PUSH
62401: LD_VAR 0 5
62405: ARRAY
62406: PUSH
62407: LD_INT 1
62409: ARRAY
62410: PPUSH
62411: LD_EXP 143
62415: PUSH
62416: LD_VAR 0 6
62420: ARRAY
62421: PUSH
62422: LD_VAR 0 5
62426: ARRAY
62427: PUSH
62428: LD_INT 2
62430: ARRAY
62431: PPUSH
62432: LD_VAR 0 2
62436: PPUSH
62437: LD_VAR 0 3
62441: PPUSH
62442: CALL_OW 298
62446: PUSH
62447: LD_INT 6
62449: LESS
62450: IFFALSE 62549
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62452: LD_EXP 143
62456: PUSH
62457: LD_VAR 0 6
62461: ARRAY
62462: PUSH
62463: LD_VAR 0 5
62467: ARRAY
62468: PUSH
62469: LD_INT 1
62471: ARRAY
62472: PPUSH
62473: LD_EXP 143
62477: PUSH
62478: LD_VAR 0 6
62482: ARRAY
62483: PUSH
62484: LD_VAR 0 5
62488: ARRAY
62489: PUSH
62490: LD_INT 2
62492: ARRAY
62493: PPUSH
62494: LD_VAR 0 1
62498: PPUSH
62499: CALL_OW 255
62503: PPUSH
62504: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62508: LD_ADDR_EXP 143
62512: PUSH
62513: LD_EXP 143
62517: PPUSH
62518: LD_VAR 0 6
62522: PPUSH
62523: LD_EXP 143
62527: PUSH
62528: LD_VAR 0 6
62532: ARRAY
62533: PPUSH
62534: LD_VAR 0 5
62538: PPUSH
62539: CALL_OW 3
62543: PPUSH
62544: CALL_OW 1
62548: ST_TO_ADDR
// end ; end ;
62549: GO 62387
62551: POP
62552: POP
// end ;
62553: LD_VAR 0 4
62557: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62558: LD_INT 0
62560: PPUSH
62561: PPUSH
62562: PPUSH
62563: PPUSH
62564: PPUSH
62565: PPUSH
62566: PPUSH
62567: PPUSH
62568: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62569: LD_VAR 0 1
62573: PPUSH
62574: CALL_OW 264
62578: PUSH
62579: LD_INT 81
62581: EQUAL
62582: NOT
62583: PUSH
62584: LD_VAR 0 1
62588: PUSH
62589: LD_EXP 142
62593: IN
62594: NOT
62595: OR
62596: IFFALSE 62600
// exit ;
62598: GO 62922
// index := GetElementIndex ( minersList , unit ) ;
62600: LD_ADDR_VAR 0 6
62604: PUSH
62605: LD_EXP 142
62609: PPUSH
62610: LD_VAR 0 1
62614: PPUSH
62615: CALL 68269 0 2
62619: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62620: LD_ADDR_VAR 0 8
62624: PUSH
62625: LD_EXP 144
62629: PUSH
62630: LD_EXP 143
62634: PUSH
62635: LD_VAR 0 6
62639: ARRAY
62640: MINUS
62641: ST_TO_ADDR
// if not minesFreeAmount then
62642: LD_VAR 0 8
62646: NOT
62647: IFFALSE 62651
// exit ;
62649: GO 62922
// tmp := [ ] ;
62651: LD_ADDR_VAR 0 7
62655: PUSH
62656: EMPTY
62657: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62658: LD_ADDR_VAR 0 5
62662: PUSH
62663: DOUBLE
62664: LD_INT 1
62666: DEC
62667: ST_TO_ADDR
62668: LD_VAR 0 8
62672: PUSH
62673: FOR_TO
62674: IFFALSE 62869
// begin _d := rand ( 0 , 5 ) ;
62676: LD_ADDR_VAR 0 11
62680: PUSH
62681: LD_INT 0
62683: PPUSH
62684: LD_INT 5
62686: PPUSH
62687: CALL_OW 12
62691: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62692: LD_ADDR_VAR 0 12
62696: PUSH
62697: LD_INT 2
62699: PPUSH
62700: LD_INT 6
62702: PPUSH
62703: CALL_OW 12
62707: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62708: LD_ADDR_VAR 0 9
62712: PUSH
62713: LD_VAR 0 2
62717: PPUSH
62718: LD_VAR 0 11
62722: PPUSH
62723: LD_VAR 0 12
62727: PPUSH
62728: CALL_OW 272
62732: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62733: LD_ADDR_VAR 0 10
62737: PUSH
62738: LD_VAR 0 3
62742: PPUSH
62743: LD_VAR 0 11
62747: PPUSH
62748: LD_VAR 0 12
62752: PPUSH
62753: CALL_OW 273
62757: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62758: LD_VAR 0 9
62762: PPUSH
62763: LD_VAR 0 10
62767: PPUSH
62768: CALL_OW 488
62772: PUSH
62773: LD_VAR 0 9
62777: PUSH
62778: LD_VAR 0 10
62782: PUSH
62783: EMPTY
62784: LIST
62785: LIST
62786: PUSH
62787: LD_VAR 0 7
62791: IN
62792: NOT
62793: AND
62794: PUSH
62795: LD_VAR 0 9
62799: PPUSH
62800: LD_VAR 0 10
62804: PPUSH
62805: CALL_OW 458
62809: NOT
62810: AND
62811: IFFALSE 62853
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62813: LD_ADDR_VAR 0 7
62817: PUSH
62818: LD_VAR 0 7
62822: PPUSH
62823: LD_VAR 0 7
62827: PUSH
62828: LD_INT 1
62830: PLUS
62831: PPUSH
62832: LD_VAR 0 9
62836: PUSH
62837: LD_VAR 0 10
62841: PUSH
62842: EMPTY
62843: LIST
62844: LIST
62845: PPUSH
62846: CALL_OW 1
62850: ST_TO_ADDR
62851: GO 62867
// i := i - 1 ;
62853: LD_ADDR_VAR 0 5
62857: PUSH
62858: LD_VAR 0 5
62862: PUSH
62863: LD_INT 1
62865: MINUS
62866: ST_TO_ADDR
// end ;
62867: GO 62673
62869: POP
62870: POP
// for i in tmp do
62871: LD_ADDR_VAR 0 5
62875: PUSH
62876: LD_VAR 0 7
62880: PUSH
62881: FOR_IN
62882: IFFALSE 62920
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62884: LD_VAR 0 1
62888: PPUSH
62889: LD_VAR 0 5
62893: PUSH
62894: LD_INT 1
62896: ARRAY
62897: PPUSH
62898: LD_VAR 0 5
62902: PUSH
62903: LD_INT 2
62905: ARRAY
62906: PPUSH
62907: CALL 61866 0 3
62911: NOT
62912: IFFALSE 62918
// exit ;
62914: POP
62915: POP
62916: GO 62922
62918: GO 62881
62920: POP
62921: POP
// end ;
62922: LD_VAR 0 4
62926: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62927: LD_INT 0
62929: PPUSH
62930: PPUSH
62931: PPUSH
62932: PPUSH
62933: PPUSH
62934: PPUSH
62935: PPUSH
// if not GetClass ( unit ) = class_sniper then
62936: LD_VAR 0 1
62940: PPUSH
62941: CALL_OW 257
62945: PUSH
62946: LD_INT 5
62948: EQUAL
62949: NOT
62950: IFFALSE 62954
// exit ;
62952: GO 63342
// dist := 8 ;
62954: LD_ADDR_VAR 0 5
62958: PUSH
62959: LD_INT 8
62961: ST_TO_ADDR
// viewRange := 12 ;
62962: LD_ADDR_VAR 0 7
62966: PUSH
62967: LD_INT 12
62969: ST_TO_ADDR
// side := GetSide ( unit ) ;
62970: LD_ADDR_VAR 0 6
62974: PUSH
62975: LD_VAR 0 1
62979: PPUSH
62980: CALL_OW 255
62984: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62985: LD_INT 61
62987: PPUSH
62988: LD_VAR 0 6
62992: PPUSH
62993: CALL_OW 321
62997: PUSH
62998: LD_INT 2
63000: EQUAL
63001: IFFALSE 63011
// viewRange := 16 ;
63003: LD_ADDR_VAR 0 7
63007: PUSH
63008: LD_INT 16
63010: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63011: LD_VAR 0 1
63015: PPUSH
63016: LD_VAR 0 2
63020: PPUSH
63021: LD_VAR 0 3
63025: PPUSH
63026: CALL_OW 297
63030: PUSH
63031: LD_VAR 0 5
63035: GREATER
63036: IFFALSE 63115
// begin ComMoveXY ( unit , x , y ) ;
63038: LD_VAR 0 1
63042: PPUSH
63043: LD_VAR 0 2
63047: PPUSH
63048: LD_VAR 0 3
63052: PPUSH
63053: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63057: LD_INT 35
63059: PPUSH
63060: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63064: LD_VAR 0 1
63068: PPUSH
63069: LD_VAR 0 2
63073: PPUSH
63074: LD_VAR 0 3
63078: PPUSH
63079: CALL 99624 0 3
63083: NOT
63084: IFFALSE 63088
// exit ;
63086: GO 63342
// until GetDistUnitXY ( unit , x , y ) < dist ;
63088: LD_VAR 0 1
63092: PPUSH
63093: LD_VAR 0 2
63097: PPUSH
63098: LD_VAR 0 3
63102: PPUSH
63103: CALL_OW 297
63107: PUSH
63108: LD_VAR 0 5
63112: LESS
63113: IFFALSE 63057
// end ; ComTurnXY ( unit , x , y ) ;
63115: LD_VAR 0 1
63119: PPUSH
63120: LD_VAR 0 2
63124: PPUSH
63125: LD_VAR 0 3
63129: PPUSH
63130: CALL_OW 118
// wait ( 5 ) ;
63134: LD_INT 5
63136: PPUSH
63137: CALL_OW 67
// _d := GetDir ( unit ) ;
63141: LD_ADDR_VAR 0 10
63145: PUSH
63146: LD_VAR 0 1
63150: PPUSH
63151: CALL_OW 254
63155: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63156: LD_ADDR_VAR 0 8
63160: PUSH
63161: LD_VAR 0 1
63165: PPUSH
63166: CALL_OW 250
63170: PPUSH
63171: LD_VAR 0 10
63175: PPUSH
63176: LD_VAR 0 5
63180: PPUSH
63181: CALL_OW 272
63185: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63186: LD_ADDR_VAR 0 9
63190: PUSH
63191: LD_VAR 0 1
63195: PPUSH
63196: CALL_OW 251
63200: PPUSH
63201: LD_VAR 0 10
63205: PPUSH
63206: LD_VAR 0 5
63210: PPUSH
63211: CALL_OW 273
63215: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63216: LD_VAR 0 8
63220: PPUSH
63221: LD_VAR 0 9
63225: PPUSH
63226: CALL_OW 488
63230: NOT
63231: IFFALSE 63235
// exit ;
63233: GO 63342
// ComAnimCustom ( unit , 1 ) ;
63235: LD_VAR 0 1
63239: PPUSH
63240: LD_INT 1
63242: PPUSH
63243: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63247: LD_VAR 0 8
63251: PPUSH
63252: LD_VAR 0 9
63256: PPUSH
63257: LD_VAR 0 6
63261: PPUSH
63262: LD_VAR 0 7
63266: PPUSH
63267: CALL_OW 330
// repeat wait ( 1 ) ;
63271: LD_INT 1
63273: PPUSH
63274: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63278: LD_VAR 0 1
63282: PPUSH
63283: CALL_OW 316
63287: PUSH
63288: LD_VAR 0 1
63292: PPUSH
63293: CALL_OW 314
63297: OR
63298: PUSH
63299: LD_VAR 0 1
63303: PPUSH
63304: CALL_OW 302
63308: NOT
63309: OR
63310: PUSH
63311: LD_VAR 0 1
63315: PPUSH
63316: CALL_OW 301
63320: OR
63321: IFFALSE 63271
// RemoveSeeing ( _x , _y , side ) ;
63323: LD_VAR 0 8
63327: PPUSH
63328: LD_VAR 0 9
63332: PPUSH
63333: LD_VAR 0 6
63337: PPUSH
63338: CALL_OW 331
// end ; end_of_file
63342: LD_VAR 0 4
63346: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63347: LD_INT 0
63349: PPUSH
63350: PPUSH
// if exist_mode then
63351: LD_VAR 0 2
63355: IFFALSE 63380
// unit := CreateCharacter ( prefix & ident ) else
63357: LD_ADDR_VAR 0 5
63361: PUSH
63362: LD_VAR 0 3
63366: PUSH
63367: LD_VAR 0 1
63371: STR
63372: PPUSH
63373: CALL_OW 34
63377: ST_TO_ADDR
63378: GO 63395
// unit := NewCharacter ( ident ) ;
63380: LD_ADDR_VAR 0 5
63384: PUSH
63385: LD_VAR 0 1
63389: PPUSH
63390: CALL_OW 25
63394: ST_TO_ADDR
// result := unit ;
63395: LD_ADDR_VAR 0 4
63399: PUSH
63400: LD_VAR 0 5
63404: ST_TO_ADDR
// end ;
63405: LD_VAR 0 4
63409: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63410: LD_INT 0
63412: PPUSH
63413: PPUSH
// if not side or not nation then
63414: LD_VAR 0 1
63418: NOT
63419: PUSH
63420: LD_VAR 0 2
63424: NOT
63425: OR
63426: IFFALSE 63430
// exit ;
63428: GO 64198
// case nation of nation_american :
63430: LD_VAR 0 2
63434: PUSH
63435: LD_INT 1
63437: DOUBLE
63438: EQUAL
63439: IFTRUE 63443
63441: GO 63657
63443: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63444: LD_ADDR_VAR 0 4
63448: PUSH
63449: LD_INT 35
63451: PUSH
63452: LD_INT 45
63454: PUSH
63455: LD_INT 46
63457: PUSH
63458: LD_INT 47
63460: PUSH
63461: LD_INT 82
63463: PUSH
63464: LD_INT 83
63466: PUSH
63467: LD_INT 84
63469: PUSH
63470: LD_INT 85
63472: PUSH
63473: LD_INT 86
63475: PUSH
63476: LD_INT 1
63478: PUSH
63479: LD_INT 2
63481: PUSH
63482: LD_INT 6
63484: PUSH
63485: LD_INT 15
63487: PUSH
63488: LD_INT 16
63490: PUSH
63491: LD_INT 7
63493: PUSH
63494: LD_INT 12
63496: PUSH
63497: LD_INT 13
63499: PUSH
63500: LD_INT 10
63502: PUSH
63503: LD_INT 14
63505: PUSH
63506: LD_INT 20
63508: PUSH
63509: LD_INT 21
63511: PUSH
63512: LD_INT 22
63514: PUSH
63515: LD_INT 25
63517: PUSH
63518: LD_INT 32
63520: PUSH
63521: LD_INT 27
63523: PUSH
63524: LD_INT 36
63526: PUSH
63527: LD_INT 69
63529: PUSH
63530: LD_INT 39
63532: PUSH
63533: LD_INT 34
63535: PUSH
63536: LD_INT 40
63538: PUSH
63539: LD_INT 48
63541: PUSH
63542: LD_INT 49
63544: PUSH
63545: LD_INT 50
63547: PUSH
63548: LD_INT 51
63550: PUSH
63551: LD_INT 52
63553: PUSH
63554: LD_INT 53
63556: PUSH
63557: LD_INT 54
63559: PUSH
63560: LD_INT 55
63562: PUSH
63563: LD_INT 56
63565: PUSH
63566: LD_INT 57
63568: PUSH
63569: LD_INT 58
63571: PUSH
63572: LD_INT 59
63574: PUSH
63575: LD_INT 60
63577: PUSH
63578: LD_INT 61
63580: PUSH
63581: LD_INT 62
63583: PUSH
63584: LD_INT 80
63586: PUSH
63587: LD_INT 82
63589: PUSH
63590: LD_INT 83
63592: PUSH
63593: LD_INT 84
63595: PUSH
63596: LD_INT 85
63598: PUSH
63599: LD_INT 86
63601: PUSH
63602: EMPTY
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: LIST
63616: LIST
63617: LIST
63618: LIST
63619: LIST
63620: LIST
63621: LIST
63622: LIST
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: LIST
63628: LIST
63629: LIST
63630: LIST
63631: LIST
63632: LIST
63633: LIST
63634: LIST
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: ST_TO_ADDR
63655: GO 64122
63657: LD_INT 2
63659: DOUBLE
63660: EQUAL
63661: IFTRUE 63665
63663: GO 63891
63665: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
63666: LD_ADDR_VAR 0 4
63670: PUSH
63671: LD_INT 35
63673: PUSH
63674: LD_INT 45
63676: PUSH
63677: LD_INT 46
63679: PUSH
63680: LD_INT 47
63682: PUSH
63683: LD_INT 82
63685: PUSH
63686: LD_INT 83
63688: PUSH
63689: LD_INT 84
63691: PUSH
63692: LD_INT 85
63694: PUSH
63695: LD_INT 87
63697: PUSH
63698: LD_INT 70
63700: PUSH
63701: LD_INT 1
63703: PUSH
63704: LD_INT 11
63706: PUSH
63707: LD_INT 3
63709: PUSH
63710: LD_INT 4
63712: PUSH
63713: LD_INT 5
63715: PUSH
63716: LD_INT 6
63718: PUSH
63719: LD_INT 15
63721: PUSH
63722: LD_INT 18
63724: PUSH
63725: LD_INT 7
63727: PUSH
63728: LD_INT 17
63730: PUSH
63731: LD_INT 8
63733: PUSH
63734: LD_INT 20
63736: PUSH
63737: LD_INT 21
63739: PUSH
63740: LD_INT 22
63742: PUSH
63743: LD_INT 72
63745: PUSH
63746: LD_INT 26
63748: PUSH
63749: LD_INT 69
63751: PUSH
63752: LD_INT 39
63754: PUSH
63755: LD_INT 40
63757: PUSH
63758: LD_INT 41
63760: PUSH
63761: LD_INT 42
63763: PUSH
63764: LD_INT 43
63766: PUSH
63767: LD_INT 48
63769: PUSH
63770: LD_INT 49
63772: PUSH
63773: LD_INT 50
63775: PUSH
63776: LD_INT 51
63778: PUSH
63779: LD_INT 52
63781: PUSH
63782: LD_INT 53
63784: PUSH
63785: LD_INT 54
63787: PUSH
63788: LD_INT 55
63790: PUSH
63791: LD_INT 56
63793: PUSH
63794: LD_INT 60
63796: PUSH
63797: LD_INT 61
63799: PUSH
63800: LD_INT 62
63802: PUSH
63803: LD_INT 66
63805: PUSH
63806: LD_INT 67
63808: PUSH
63809: LD_INT 68
63811: PUSH
63812: LD_INT 81
63814: PUSH
63815: LD_INT 82
63817: PUSH
63818: LD_INT 83
63820: PUSH
63821: LD_INT 84
63823: PUSH
63824: LD_INT 85
63826: PUSH
63827: LD_INT 87
63829: PUSH
63830: LD_INT 88
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: LIST
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: LIST
63860: LIST
63861: LIST
63862: LIST
63863: LIST
63864: LIST
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: LIST
63872: LIST
63873: LIST
63874: LIST
63875: LIST
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: LIST
63886: LIST
63887: LIST
63888: ST_TO_ADDR
63889: GO 64122
63891: LD_INT 3
63893: DOUBLE
63894: EQUAL
63895: IFTRUE 63899
63897: GO 64121
63899: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
63900: LD_ADDR_VAR 0 4
63904: PUSH
63905: LD_INT 46
63907: PUSH
63908: LD_INT 47
63910: PUSH
63911: LD_INT 1
63913: PUSH
63914: LD_INT 2
63916: PUSH
63917: LD_INT 82
63919: PUSH
63920: LD_INT 83
63922: PUSH
63923: LD_INT 84
63925: PUSH
63926: LD_INT 85
63928: PUSH
63929: LD_INT 86
63931: PUSH
63932: LD_INT 11
63934: PUSH
63935: LD_INT 9
63937: PUSH
63938: LD_INT 20
63940: PUSH
63941: LD_INT 19
63943: PUSH
63944: LD_INT 21
63946: PUSH
63947: LD_INT 24
63949: PUSH
63950: LD_INT 22
63952: PUSH
63953: LD_INT 25
63955: PUSH
63956: LD_INT 28
63958: PUSH
63959: LD_INT 29
63961: PUSH
63962: LD_INT 30
63964: PUSH
63965: LD_INT 31
63967: PUSH
63968: LD_INT 37
63970: PUSH
63971: LD_INT 38
63973: PUSH
63974: LD_INT 32
63976: PUSH
63977: LD_INT 27
63979: PUSH
63980: LD_INT 33
63982: PUSH
63983: LD_INT 69
63985: PUSH
63986: LD_INT 39
63988: PUSH
63989: LD_INT 34
63991: PUSH
63992: LD_INT 40
63994: PUSH
63995: LD_INT 71
63997: PUSH
63998: LD_INT 23
64000: PUSH
64001: LD_INT 44
64003: PUSH
64004: LD_INT 48
64006: PUSH
64007: LD_INT 49
64009: PUSH
64010: LD_INT 50
64012: PUSH
64013: LD_INT 51
64015: PUSH
64016: LD_INT 52
64018: PUSH
64019: LD_INT 53
64021: PUSH
64022: LD_INT 54
64024: PUSH
64025: LD_INT 55
64027: PUSH
64028: LD_INT 56
64030: PUSH
64031: LD_INT 57
64033: PUSH
64034: LD_INT 58
64036: PUSH
64037: LD_INT 59
64039: PUSH
64040: LD_INT 63
64042: PUSH
64043: LD_INT 64
64045: PUSH
64046: LD_INT 65
64048: PUSH
64049: LD_INT 82
64051: PUSH
64052: LD_INT 83
64054: PUSH
64055: LD_INT 84
64057: PUSH
64058: LD_INT 85
64060: PUSH
64061: LD_INT 86
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: LIST
64080: LIST
64081: LIST
64082: LIST
64083: LIST
64084: LIST
64085: LIST
64086: LIST
64087: LIST
64088: LIST
64089: LIST
64090: LIST
64091: LIST
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: LIST
64108: LIST
64109: LIST
64110: LIST
64111: LIST
64112: LIST
64113: LIST
64114: LIST
64115: LIST
64116: LIST
64117: LIST
64118: ST_TO_ADDR
64119: GO 64122
64121: POP
// if state > - 1 and state < 3 then
64122: LD_VAR 0 3
64126: PUSH
64127: LD_INT 1
64129: NEG
64130: GREATER
64131: PUSH
64132: LD_VAR 0 3
64136: PUSH
64137: LD_INT 3
64139: LESS
64140: AND
64141: IFFALSE 64198
// for i in result do
64143: LD_ADDR_VAR 0 5
64147: PUSH
64148: LD_VAR 0 4
64152: PUSH
64153: FOR_IN
64154: IFFALSE 64196
// if GetTech ( i , side ) <> state then
64156: LD_VAR 0 5
64160: PPUSH
64161: LD_VAR 0 1
64165: PPUSH
64166: CALL_OW 321
64170: PUSH
64171: LD_VAR 0 3
64175: NONEQUAL
64176: IFFALSE 64194
// result := result diff i ;
64178: LD_ADDR_VAR 0 4
64182: PUSH
64183: LD_VAR 0 4
64187: PUSH
64188: LD_VAR 0 5
64192: DIFF
64193: ST_TO_ADDR
64194: GO 64153
64196: POP
64197: POP
// end ;
64198: LD_VAR 0 4
64202: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64203: LD_INT 0
64205: PPUSH
64206: PPUSH
64207: PPUSH
// result := true ;
64208: LD_ADDR_VAR 0 3
64212: PUSH
64213: LD_INT 1
64215: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64216: LD_ADDR_VAR 0 5
64220: PUSH
64221: LD_VAR 0 2
64225: PPUSH
64226: CALL_OW 480
64230: ST_TO_ADDR
// if not tmp then
64231: LD_VAR 0 5
64235: NOT
64236: IFFALSE 64240
// exit ;
64238: GO 64289
// for i in tmp do
64240: LD_ADDR_VAR 0 4
64244: PUSH
64245: LD_VAR 0 5
64249: PUSH
64250: FOR_IN
64251: IFFALSE 64287
// if GetTech ( i , side ) <> state_researched then
64253: LD_VAR 0 4
64257: PPUSH
64258: LD_VAR 0 1
64262: PPUSH
64263: CALL_OW 321
64267: PUSH
64268: LD_INT 2
64270: NONEQUAL
64271: IFFALSE 64285
// begin result := false ;
64273: LD_ADDR_VAR 0 3
64277: PUSH
64278: LD_INT 0
64280: ST_TO_ADDR
// exit ;
64281: POP
64282: POP
64283: GO 64289
// end ;
64285: GO 64250
64287: POP
64288: POP
// end ;
64289: LD_VAR 0 3
64293: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64294: LD_INT 0
64296: PPUSH
64297: PPUSH
64298: PPUSH
64299: PPUSH
64300: PPUSH
64301: PPUSH
64302: PPUSH
64303: PPUSH
64304: PPUSH
64305: PPUSH
64306: PPUSH
64307: PPUSH
64308: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64309: LD_VAR 0 1
64313: NOT
64314: PUSH
64315: LD_VAR 0 1
64319: PPUSH
64320: CALL_OW 257
64324: PUSH
64325: LD_INT 9
64327: NONEQUAL
64328: OR
64329: IFFALSE 64333
// exit ;
64331: GO 64906
// side := GetSide ( unit ) ;
64333: LD_ADDR_VAR 0 9
64337: PUSH
64338: LD_VAR 0 1
64342: PPUSH
64343: CALL_OW 255
64347: ST_TO_ADDR
// tech_space := tech_spacanom ;
64348: LD_ADDR_VAR 0 12
64352: PUSH
64353: LD_INT 29
64355: ST_TO_ADDR
// tech_time := tech_taurad ;
64356: LD_ADDR_VAR 0 13
64360: PUSH
64361: LD_INT 28
64363: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64364: LD_ADDR_VAR 0 11
64368: PUSH
64369: LD_VAR 0 1
64373: PPUSH
64374: CALL_OW 310
64378: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64379: LD_VAR 0 11
64383: PPUSH
64384: CALL_OW 247
64388: PUSH
64389: LD_INT 2
64391: EQUAL
64392: IFFALSE 64396
// exit ;
64394: GO 64906
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64396: LD_ADDR_VAR 0 8
64400: PUSH
64401: LD_INT 81
64403: PUSH
64404: LD_VAR 0 9
64408: PUSH
64409: EMPTY
64410: LIST
64411: LIST
64412: PUSH
64413: LD_INT 3
64415: PUSH
64416: LD_INT 21
64418: PUSH
64419: LD_INT 3
64421: PUSH
64422: EMPTY
64423: LIST
64424: LIST
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PPUSH
64434: CALL_OW 69
64438: ST_TO_ADDR
// if not tmp then
64439: LD_VAR 0 8
64443: NOT
64444: IFFALSE 64448
// exit ;
64446: GO 64906
// if in_unit then
64448: LD_VAR 0 11
64452: IFFALSE 64476
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64454: LD_ADDR_VAR 0 10
64458: PUSH
64459: LD_VAR 0 8
64463: PPUSH
64464: LD_VAR 0 11
64468: PPUSH
64469: CALL_OW 74
64473: ST_TO_ADDR
64474: GO 64496
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64476: LD_ADDR_VAR 0 10
64480: PUSH
64481: LD_VAR 0 8
64485: PPUSH
64486: LD_VAR 0 1
64490: PPUSH
64491: CALL_OW 74
64495: ST_TO_ADDR
// if not enemy then
64496: LD_VAR 0 10
64500: NOT
64501: IFFALSE 64505
// exit ;
64503: GO 64906
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64505: LD_VAR 0 11
64509: PUSH
64510: LD_VAR 0 11
64514: PPUSH
64515: LD_VAR 0 10
64519: PPUSH
64520: CALL_OW 296
64524: PUSH
64525: LD_INT 13
64527: GREATER
64528: AND
64529: PUSH
64530: LD_VAR 0 1
64534: PPUSH
64535: LD_VAR 0 10
64539: PPUSH
64540: CALL_OW 296
64544: PUSH
64545: LD_INT 12
64547: GREATER
64548: OR
64549: IFFALSE 64553
// exit ;
64551: GO 64906
// missile := [ 1 ] ;
64553: LD_ADDR_VAR 0 14
64557: PUSH
64558: LD_INT 1
64560: PUSH
64561: EMPTY
64562: LIST
64563: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64564: LD_VAR 0 9
64568: PPUSH
64569: LD_VAR 0 12
64573: PPUSH
64574: CALL_OW 325
64578: IFFALSE 64607
// missile := Replace ( missile , missile + 1 , 2 ) ;
64580: LD_ADDR_VAR 0 14
64584: PUSH
64585: LD_VAR 0 14
64589: PPUSH
64590: LD_VAR 0 14
64594: PUSH
64595: LD_INT 1
64597: PLUS
64598: PPUSH
64599: LD_INT 2
64601: PPUSH
64602: CALL_OW 1
64606: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64607: LD_VAR 0 9
64611: PPUSH
64612: LD_VAR 0 13
64616: PPUSH
64617: CALL_OW 325
64621: PUSH
64622: LD_VAR 0 10
64626: PPUSH
64627: CALL_OW 255
64631: PPUSH
64632: LD_VAR 0 13
64636: PPUSH
64637: CALL_OW 325
64641: NOT
64642: AND
64643: IFFALSE 64672
// missile := Replace ( missile , missile + 1 , 3 ) ;
64645: LD_ADDR_VAR 0 14
64649: PUSH
64650: LD_VAR 0 14
64654: PPUSH
64655: LD_VAR 0 14
64659: PUSH
64660: LD_INT 1
64662: PLUS
64663: PPUSH
64664: LD_INT 3
64666: PPUSH
64667: CALL_OW 1
64671: ST_TO_ADDR
// if missile < 2 then
64672: LD_VAR 0 14
64676: PUSH
64677: LD_INT 2
64679: LESS
64680: IFFALSE 64684
// exit ;
64682: GO 64906
// x := GetX ( enemy ) ;
64684: LD_ADDR_VAR 0 4
64688: PUSH
64689: LD_VAR 0 10
64693: PPUSH
64694: CALL_OW 250
64698: ST_TO_ADDR
// y := GetY ( enemy ) ;
64699: LD_ADDR_VAR 0 5
64703: PUSH
64704: LD_VAR 0 10
64708: PPUSH
64709: CALL_OW 251
64713: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64714: LD_ADDR_VAR 0 6
64718: PUSH
64719: LD_VAR 0 4
64723: PUSH
64724: LD_INT 1
64726: NEG
64727: PPUSH
64728: LD_INT 1
64730: PPUSH
64731: CALL_OW 12
64735: PLUS
64736: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64737: LD_ADDR_VAR 0 7
64741: PUSH
64742: LD_VAR 0 5
64746: PUSH
64747: LD_INT 1
64749: NEG
64750: PPUSH
64751: LD_INT 1
64753: PPUSH
64754: CALL_OW 12
64758: PLUS
64759: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64760: LD_VAR 0 6
64764: PPUSH
64765: LD_VAR 0 7
64769: PPUSH
64770: CALL_OW 488
64774: NOT
64775: IFFALSE 64797
// begin _x := x ;
64777: LD_ADDR_VAR 0 6
64781: PUSH
64782: LD_VAR 0 4
64786: ST_TO_ADDR
// _y := y ;
64787: LD_ADDR_VAR 0 7
64791: PUSH
64792: LD_VAR 0 5
64796: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64797: LD_ADDR_VAR 0 3
64801: PUSH
64802: LD_INT 1
64804: PPUSH
64805: LD_VAR 0 14
64809: PPUSH
64810: CALL_OW 12
64814: ST_TO_ADDR
// case i of 1 :
64815: LD_VAR 0 3
64819: PUSH
64820: LD_INT 1
64822: DOUBLE
64823: EQUAL
64824: IFTRUE 64828
64826: GO 64845
64828: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64829: LD_VAR 0 1
64833: PPUSH
64834: LD_VAR 0 10
64838: PPUSH
64839: CALL_OW 115
64843: GO 64906
64845: LD_INT 2
64847: DOUBLE
64848: EQUAL
64849: IFTRUE 64853
64851: GO 64875
64853: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64854: LD_VAR 0 1
64858: PPUSH
64859: LD_VAR 0 6
64863: PPUSH
64864: LD_VAR 0 7
64868: PPUSH
64869: CALL_OW 153
64873: GO 64906
64875: LD_INT 3
64877: DOUBLE
64878: EQUAL
64879: IFTRUE 64883
64881: GO 64905
64883: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64884: LD_VAR 0 1
64888: PPUSH
64889: LD_VAR 0 6
64893: PPUSH
64894: LD_VAR 0 7
64898: PPUSH
64899: CALL_OW 154
64903: GO 64906
64905: POP
// end ;
64906: LD_VAR 0 2
64910: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64911: LD_INT 0
64913: PPUSH
64914: PPUSH
64915: PPUSH
64916: PPUSH
64917: PPUSH
64918: PPUSH
// if not unit or not building then
64919: LD_VAR 0 1
64923: NOT
64924: PUSH
64925: LD_VAR 0 2
64929: NOT
64930: OR
64931: IFFALSE 64935
// exit ;
64933: GO 65093
// x := GetX ( building ) ;
64935: LD_ADDR_VAR 0 5
64939: PUSH
64940: LD_VAR 0 2
64944: PPUSH
64945: CALL_OW 250
64949: ST_TO_ADDR
// y := GetY ( building ) ;
64950: LD_ADDR_VAR 0 6
64954: PUSH
64955: LD_VAR 0 2
64959: PPUSH
64960: CALL_OW 251
64964: ST_TO_ADDR
// for i = 0 to 5 do
64965: LD_ADDR_VAR 0 4
64969: PUSH
64970: DOUBLE
64971: LD_INT 0
64973: DEC
64974: ST_TO_ADDR
64975: LD_INT 5
64977: PUSH
64978: FOR_TO
64979: IFFALSE 65091
// begin _x := ShiftX ( x , i , 3 ) ;
64981: LD_ADDR_VAR 0 7
64985: PUSH
64986: LD_VAR 0 5
64990: PPUSH
64991: LD_VAR 0 4
64995: PPUSH
64996: LD_INT 3
64998: PPUSH
64999: CALL_OW 272
65003: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65004: LD_ADDR_VAR 0 8
65008: PUSH
65009: LD_VAR 0 6
65013: PPUSH
65014: LD_VAR 0 4
65018: PPUSH
65019: LD_INT 3
65021: PPUSH
65022: CALL_OW 273
65026: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65027: LD_VAR 0 7
65031: PPUSH
65032: LD_VAR 0 8
65036: PPUSH
65037: CALL_OW 488
65041: NOT
65042: IFFALSE 65046
// continue ;
65044: GO 64978
// if HexInfo ( _x , _y ) = 0 then
65046: LD_VAR 0 7
65050: PPUSH
65051: LD_VAR 0 8
65055: PPUSH
65056: CALL_OW 428
65060: PUSH
65061: LD_INT 0
65063: EQUAL
65064: IFFALSE 65089
// begin ComMoveXY ( unit , _x , _y ) ;
65066: LD_VAR 0 1
65070: PPUSH
65071: LD_VAR 0 7
65075: PPUSH
65076: LD_VAR 0 8
65080: PPUSH
65081: CALL_OW 111
// exit ;
65085: POP
65086: POP
65087: GO 65093
// end ; end ;
65089: GO 64978
65091: POP
65092: POP
// end ;
65093: LD_VAR 0 3
65097: RET
// export function ScanBase ( side , base_area ) ; begin
65098: LD_INT 0
65100: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65101: LD_ADDR_VAR 0 3
65105: PUSH
65106: LD_VAR 0 2
65110: PPUSH
65111: LD_INT 81
65113: PUSH
65114: LD_VAR 0 1
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: PPUSH
65123: CALL_OW 70
65127: ST_TO_ADDR
// end ;
65128: LD_VAR 0 3
65132: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65133: LD_INT 0
65135: PPUSH
65136: PPUSH
65137: PPUSH
65138: PPUSH
// result := false ;
65139: LD_ADDR_VAR 0 2
65143: PUSH
65144: LD_INT 0
65146: ST_TO_ADDR
// side := GetSide ( unit ) ;
65147: LD_ADDR_VAR 0 3
65151: PUSH
65152: LD_VAR 0 1
65156: PPUSH
65157: CALL_OW 255
65161: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65162: LD_ADDR_VAR 0 4
65166: PUSH
65167: LD_VAR 0 1
65171: PPUSH
65172: CALL_OW 248
65176: ST_TO_ADDR
// case nat of 1 :
65177: LD_VAR 0 4
65181: PUSH
65182: LD_INT 1
65184: DOUBLE
65185: EQUAL
65186: IFTRUE 65190
65188: GO 65201
65190: POP
// tech := tech_lassight ; 2 :
65191: LD_ADDR_VAR 0 5
65195: PUSH
65196: LD_INT 12
65198: ST_TO_ADDR
65199: GO 65240
65201: LD_INT 2
65203: DOUBLE
65204: EQUAL
65205: IFTRUE 65209
65207: GO 65220
65209: POP
// tech := tech_mortar ; 3 :
65210: LD_ADDR_VAR 0 5
65214: PUSH
65215: LD_INT 41
65217: ST_TO_ADDR
65218: GO 65240
65220: LD_INT 3
65222: DOUBLE
65223: EQUAL
65224: IFTRUE 65228
65226: GO 65239
65228: POP
// tech := tech_bazooka ; end ;
65229: LD_ADDR_VAR 0 5
65233: PUSH
65234: LD_INT 44
65236: ST_TO_ADDR
65237: GO 65240
65239: POP
// if Researched ( side , tech ) then
65240: LD_VAR 0 3
65244: PPUSH
65245: LD_VAR 0 5
65249: PPUSH
65250: CALL_OW 325
65254: IFFALSE 65281
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65256: LD_ADDR_VAR 0 2
65260: PUSH
65261: LD_INT 5
65263: PUSH
65264: LD_INT 8
65266: PUSH
65267: LD_INT 9
65269: PUSH
65270: EMPTY
65271: LIST
65272: LIST
65273: LIST
65274: PUSH
65275: LD_VAR 0 4
65279: ARRAY
65280: ST_TO_ADDR
// end ;
65281: LD_VAR 0 2
65285: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65286: LD_INT 0
65288: PPUSH
65289: PPUSH
65290: PPUSH
// if not mines then
65291: LD_VAR 0 2
65295: NOT
65296: IFFALSE 65300
// exit ;
65298: GO 65444
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65300: LD_ADDR_VAR 0 5
65304: PUSH
65305: LD_INT 81
65307: PUSH
65308: LD_VAR 0 1
65312: PUSH
65313: EMPTY
65314: LIST
65315: LIST
65316: PUSH
65317: LD_INT 3
65319: PUSH
65320: LD_INT 21
65322: PUSH
65323: LD_INT 3
65325: PUSH
65326: EMPTY
65327: LIST
65328: LIST
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PPUSH
65338: CALL_OW 69
65342: ST_TO_ADDR
// for i in mines do
65343: LD_ADDR_VAR 0 4
65347: PUSH
65348: LD_VAR 0 2
65352: PUSH
65353: FOR_IN
65354: IFFALSE 65442
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65356: LD_VAR 0 4
65360: PUSH
65361: LD_INT 1
65363: ARRAY
65364: PPUSH
65365: LD_VAR 0 4
65369: PUSH
65370: LD_INT 2
65372: ARRAY
65373: PPUSH
65374: CALL_OW 458
65378: NOT
65379: IFFALSE 65383
// continue ;
65381: GO 65353
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65383: LD_VAR 0 4
65387: PUSH
65388: LD_INT 1
65390: ARRAY
65391: PPUSH
65392: LD_VAR 0 4
65396: PUSH
65397: LD_INT 2
65399: ARRAY
65400: PPUSH
65401: CALL_OW 428
65405: PUSH
65406: LD_VAR 0 5
65410: IN
65411: IFFALSE 65440
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65413: LD_VAR 0 4
65417: PUSH
65418: LD_INT 1
65420: ARRAY
65421: PPUSH
65422: LD_VAR 0 4
65426: PUSH
65427: LD_INT 2
65429: ARRAY
65430: PPUSH
65431: LD_VAR 0 1
65435: PPUSH
65436: CALL_OW 456
// end ;
65440: GO 65353
65442: POP
65443: POP
// end ;
65444: LD_VAR 0 3
65448: RET
// export function Count ( array ) ; var i ; begin
65449: LD_INT 0
65451: PPUSH
65452: PPUSH
// result := 0 ;
65453: LD_ADDR_VAR 0 2
65457: PUSH
65458: LD_INT 0
65460: ST_TO_ADDR
// for i in array do
65461: LD_ADDR_VAR 0 3
65465: PUSH
65466: LD_VAR 0 1
65470: PUSH
65471: FOR_IN
65472: IFFALSE 65496
// if i then
65474: LD_VAR 0 3
65478: IFFALSE 65494
// result := result + 1 ;
65480: LD_ADDR_VAR 0 2
65484: PUSH
65485: LD_VAR 0 2
65489: PUSH
65490: LD_INT 1
65492: PLUS
65493: ST_TO_ADDR
65494: GO 65471
65496: POP
65497: POP
// end ;
65498: LD_VAR 0 2
65502: RET
// export function IsEmpty ( building ) ; begin
65503: LD_INT 0
65505: PPUSH
// if not building then
65506: LD_VAR 0 1
65510: NOT
65511: IFFALSE 65515
// exit ;
65513: GO 65558
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65515: LD_ADDR_VAR 0 2
65519: PUSH
65520: LD_VAR 0 1
65524: PUSH
65525: LD_INT 22
65527: PUSH
65528: LD_VAR 0 1
65532: PPUSH
65533: CALL_OW 255
65537: PUSH
65538: EMPTY
65539: LIST
65540: LIST
65541: PUSH
65542: LD_INT 58
65544: PUSH
65545: EMPTY
65546: LIST
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PPUSH
65552: CALL_OW 69
65556: IN
65557: ST_TO_ADDR
// end ;
65558: LD_VAR 0 2
65562: RET
// export function IsNotFull ( building ) ; var places ; begin
65563: LD_INT 0
65565: PPUSH
65566: PPUSH
// if not building then
65567: LD_VAR 0 1
65571: NOT
65572: IFFALSE 65576
// exit ;
65574: GO 65747
// result := false ;
65576: LD_ADDR_VAR 0 2
65580: PUSH
65581: LD_INT 0
65583: ST_TO_ADDR
// places := 0 ;
65584: LD_ADDR_VAR 0 3
65588: PUSH
65589: LD_INT 0
65591: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
65592: LD_VAR 0 1
65596: PPUSH
65597: CALL_OW 266
65601: PUSH
65602: LD_INT 0
65604: DOUBLE
65605: EQUAL
65606: IFTRUE 65664
65608: LD_INT 1
65610: DOUBLE
65611: EQUAL
65612: IFTRUE 65664
65614: LD_INT 6
65616: DOUBLE
65617: EQUAL
65618: IFTRUE 65664
65620: LD_INT 7
65622: DOUBLE
65623: EQUAL
65624: IFTRUE 65664
65626: LD_INT 8
65628: DOUBLE
65629: EQUAL
65630: IFTRUE 65664
65632: LD_INT 4
65634: DOUBLE
65635: EQUAL
65636: IFTRUE 65664
65638: LD_INT 5
65640: DOUBLE
65641: EQUAL
65642: IFTRUE 65664
65644: LD_INT 2
65646: DOUBLE
65647: EQUAL
65648: IFTRUE 65664
65650: LD_INT 3
65652: DOUBLE
65653: EQUAL
65654: IFTRUE 65664
65656: LD_INT 35
65658: DOUBLE
65659: EQUAL
65660: IFTRUE 65664
65662: GO 65675
65664: POP
// places := 6 ; b_bunker , b_breastwork :
65665: LD_ADDR_VAR 0 3
65669: PUSH
65670: LD_INT 6
65672: ST_TO_ADDR
65673: GO 65720
65675: LD_INT 32
65677: DOUBLE
65678: EQUAL
65679: IFTRUE 65689
65681: LD_INT 31
65683: DOUBLE
65684: EQUAL
65685: IFTRUE 65689
65687: GO 65700
65689: POP
// places := 1 ; b_control_tower :
65690: LD_ADDR_VAR 0 3
65694: PUSH
65695: LD_INT 1
65697: ST_TO_ADDR
65698: GO 65720
65700: LD_INT 36
65702: DOUBLE
65703: EQUAL
65704: IFTRUE 65708
65706: GO 65719
65708: POP
// places := 3 ; end ;
65709: LD_ADDR_VAR 0 3
65713: PUSH
65714: LD_INT 3
65716: ST_TO_ADDR
65717: GO 65720
65719: POP
// if places then
65720: LD_VAR 0 3
65724: IFFALSE 65747
// result := UnitsInside ( building ) < places ;
65726: LD_ADDR_VAR 0 2
65730: PUSH
65731: LD_VAR 0 1
65735: PPUSH
65736: CALL_OW 313
65740: PUSH
65741: LD_VAR 0 3
65745: LESS
65746: ST_TO_ADDR
// end ;
65747: LD_VAR 0 2
65751: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65752: LD_INT 0
65754: PPUSH
65755: PPUSH
65756: PPUSH
65757: PPUSH
// tmp := [ ] ;
65758: LD_ADDR_VAR 0 3
65762: PUSH
65763: EMPTY
65764: ST_TO_ADDR
// list := [ ] ;
65765: LD_ADDR_VAR 0 5
65769: PUSH
65770: EMPTY
65771: ST_TO_ADDR
// for i = 16 to 25 do
65772: LD_ADDR_VAR 0 4
65776: PUSH
65777: DOUBLE
65778: LD_INT 16
65780: DEC
65781: ST_TO_ADDR
65782: LD_INT 25
65784: PUSH
65785: FOR_TO
65786: IFFALSE 65859
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65788: LD_ADDR_VAR 0 3
65792: PUSH
65793: LD_VAR 0 3
65797: PUSH
65798: LD_INT 22
65800: PUSH
65801: LD_VAR 0 1
65805: PPUSH
65806: CALL_OW 255
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 91
65817: PUSH
65818: LD_VAR 0 1
65822: PUSH
65823: LD_INT 6
65825: PUSH
65826: EMPTY
65827: LIST
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 30
65833: PUSH
65834: LD_VAR 0 4
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: LIST
65847: PUSH
65848: EMPTY
65849: LIST
65850: PPUSH
65851: CALL_OW 69
65855: ADD
65856: ST_TO_ADDR
65857: GO 65785
65859: POP
65860: POP
// for i = 1 to tmp do
65861: LD_ADDR_VAR 0 4
65865: PUSH
65866: DOUBLE
65867: LD_INT 1
65869: DEC
65870: ST_TO_ADDR
65871: LD_VAR 0 3
65875: PUSH
65876: FOR_TO
65877: IFFALSE 65965
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65879: LD_ADDR_VAR 0 5
65883: PUSH
65884: LD_VAR 0 5
65888: PUSH
65889: LD_VAR 0 3
65893: PUSH
65894: LD_VAR 0 4
65898: ARRAY
65899: PPUSH
65900: CALL_OW 266
65904: PUSH
65905: LD_VAR 0 3
65909: PUSH
65910: LD_VAR 0 4
65914: ARRAY
65915: PPUSH
65916: CALL_OW 250
65920: PUSH
65921: LD_VAR 0 3
65925: PUSH
65926: LD_VAR 0 4
65930: ARRAY
65931: PPUSH
65932: CALL_OW 251
65936: PUSH
65937: LD_VAR 0 3
65941: PUSH
65942: LD_VAR 0 4
65946: ARRAY
65947: PPUSH
65948: CALL_OW 254
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: PUSH
65959: EMPTY
65960: LIST
65961: ADD
65962: ST_TO_ADDR
65963: GO 65876
65965: POP
65966: POP
// result := list ;
65967: LD_ADDR_VAR 0 2
65971: PUSH
65972: LD_VAR 0 5
65976: ST_TO_ADDR
// end ;
65977: LD_VAR 0 2
65981: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65982: LD_INT 0
65984: PPUSH
65985: PPUSH
65986: PPUSH
65987: PPUSH
65988: PPUSH
65989: PPUSH
65990: PPUSH
// if not factory then
65991: LD_VAR 0 1
65995: NOT
65996: IFFALSE 66000
// exit ;
65998: GO 66593
// if control = control_apeman then
66000: LD_VAR 0 4
66004: PUSH
66005: LD_INT 5
66007: EQUAL
66008: IFFALSE 66117
// begin tmp := UnitsInside ( factory ) ;
66010: LD_ADDR_VAR 0 8
66014: PUSH
66015: LD_VAR 0 1
66019: PPUSH
66020: CALL_OW 313
66024: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66025: LD_VAR 0 8
66029: PPUSH
66030: LD_INT 25
66032: PUSH
66033: LD_INT 12
66035: PUSH
66036: EMPTY
66037: LIST
66038: LIST
66039: PPUSH
66040: CALL_OW 72
66044: NOT
66045: IFFALSE 66055
// control := control_manual ;
66047: LD_ADDR_VAR 0 4
66051: PUSH
66052: LD_INT 1
66054: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66055: LD_ADDR_VAR 0 8
66059: PUSH
66060: LD_VAR 0 1
66064: PPUSH
66065: CALL 65752 0 1
66069: ST_TO_ADDR
// if tmp then
66070: LD_VAR 0 8
66074: IFFALSE 66117
// begin for i in tmp do
66076: LD_ADDR_VAR 0 7
66080: PUSH
66081: LD_VAR 0 8
66085: PUSH
66086: FOR_IN
66087: IFFALSE 66115
// if i [ 1 ] = b_ext_radio then
66089: LD_VAR 0 7
66093: PUSH
66094: LD_INT 1
66096: ARRAY
66097: PUSH
66098: LD_INT 22
66100: EQUAL
66101: IFFALSE 66113
// begin control := control_remote ;
66103: LD_ADDR_VAR 0 4
66107: PUSH
66108: LD_INT 2
66110: ST_TO_ADDR
// break ;
66111: GO 66115
// end ;
66113: GO 66086
66115: POP
66116: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66117: LD_VAR 0 1
66121: PPUSH
66122: LD_VAR 0 2
66126: PPUSH
66127: LD_VAR 0 3
66131: PPUSH
66132: LD_VAR 0 4
66136: PPUSH
66137: LD_VAR 0 5
66141: PPUSH
66142: CALL_OW 448
66146: IFFALSE 66181
// begin result := [ chassis , engine , control , weapon ] ;
66148: LD_ADDR_VAR 0 6
66152: PUSH
66153: LD_VAR 0 2
66157: PUSH
66158: LD_VAR 0 3
66162: PUSH
66163: LD_VAR 0 4
66167: PUSH
66168: LD_VAR 0 5
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: ST_TO_ADDR
// exit ;
66179: GO 66593
// end ; _chassis := AvailableChassisList ( factory ) ;
66181: LD_ADDR_VAR 0 9
66185: PUSH
66186: LD_VAR 0 1
66190: PPUSH
66191: CALL_OW 475
66195: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66196: LD_ADDR_VAR 0 11
66200: PUSH
66201: LD_VAR 0 1
66205: PPUSH
66206: CALL_OW 476
66210: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66211: LD_ADDR_VAR 0 12
66215: PUSH
66216: LD_VAR 0 1
66220: PPUSH
66221: CALL_OW 477
66225: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66226: LD_ADDR_VAR 0 10
66230: PUSH
66231: LD_VAR 0 1
66235: PPUSH
66236: CALL_OW 478
66240: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66241: LD_VAR 0 9
66245: NOT
66246: PUSH
66247: LD_VAR 0 11
66251: NOT
66252: OR
66253: PUSH
66254: LD_VAR 0 12
66258: NOT
66259: OR
66260: PUSH
66261: LD_VAR 0 10
66265: NOT
66266: OR
66267: IFFALSE 66302
// begin result := [ chassis , engine , control , weapon ] ;
66269: LD_ADDR_VAR 0 6
66273: PUSH
66274: LD_VAR 0 2
66278: PUSH
66279: LD_VAR 0 3
66283: PUSH
66284: LD_VAR 0 4
66288: PUSH
66289: LD_VAR 0 5
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: ST_TO_ADDR
// exit ;
66300: GO 66593
// end ; if not chassis in _chassis then
66302: LD_VAR 0 2
66306: PUSH
66307: LD_VAR 0 9
66311: IN
66312: NOT
66313: IFFALSE 66339
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66315: LD_ADDR_VAR 0 2
66319: PUSH
66320: LD_VAR 0 9
66324: PUSH
66325: LD_INT 1
66327: PPUSH
66328: LD_VAR 0 9
66332: PPUSH
66333: CALL_OW 12
66337: ARRAY
66338: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66339: LD_VAR 0 2
66343: PPUSH
66344: LD_VAR 0 3
66348: PPUSH
66349: CALL 66598 0 2
66353: NOT
66354: IFFALSE 66413
// repeat engine := _engine [ 1 ] ;
66356: LD_ADDR_VAR 0 3
66360: PUSH
66361: LD_VAR 0 11
66365: PUSH
66366: LD_INT 1
66368: ARRAY
66369: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66370: LD_ADDR_VAR 0 11
66374: PUSH
66375: LD_VAR 0 11
66379: PPUSH
66380: LD_INT 1
66382: PPUSH
66383: CALL_OW 3
66387: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66388: LD_VAR 0 2
66392: PPUSH
66393: LD_VAR 0 3
66397: PPUSH
66398: CALL 66598 0 2
66402: PUSH
66403: LD_VAR 0 11
66407: PUSH
66408: EMPTY
66409: EQUAL
66410: OR
66411: IFFALSE 66356
// if not control in _control then
66413: LD_VAR 0 4
66417: PUSH
66418: LD_VAR 0 12
66422: IN
66423: NOT
66424: IFFALSE 66450
// control := _control [ rand ( 1 , _control ) ] ;
66426: LD_ADDR_VAR 0 4
66430: PUSH
66431: LD_VAR 0 12
66435: PUSH
66436: LD_INT 1
66438: PPUSH
66439: LD_VAR 0 12
66443: PPUSH
66444: CALL_OW 12
66448: ARRAY
66449: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66450: LD_VAR 0 2
66454: PPUSH
66455: LD_VAR 0 5
66459: PPUSH
66460: CALL 66818 0 2
66464: NOT
66465: IFFALSE 66524
// repeat weapon := _weapon [ 1 ] ;
66467: LD_ADDR_VAR 0 5
66471: PUSH
66472: LD_VAR 0 10
66476: PUSH
66477: LD_INT 1
66479: ARRAY
66480: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66481: LD_ADDR_VAR 0 10
66485: PUSH
66486: LD_VAR 0 10
66490: PPUSH
66491: LD_INT 1
66493: PPUSH
66494: CALL_OW 3
66498: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66499: LD_VAR 0 2
66503: PPUSH
66504: LD_VAR 0 5
66508: PPUSH
66509: CALL 66818 0 2
66513: PUSH
66514: LD_VAR 0 10
66518: PUSH
66519: EMPTY
66520: EQUAL
66521: OR
66522: IFFALSE 66467
// result := [ ] ;
66524: LD_ADDR_VAR 0 6
66528: PUSH
66529: EMPTY
66530: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66531: LD_VAR 0 1
66535: PPUSH
66536: LD_VAR 0 2
66540: PPUSH
66541: LD_VAR 0 3
66545: PPUSH
66546: LD_VAR 0 4
66550: PPUSH
66551: LD_VAR 0 5
66555: PPUSH
66556: CALL_OW 448
66560: IFFALSE 66593
// result := [ chassis , engine , control , weapon ] ;
66562: LD_ADDR_VAR 0 6
66566: PUSH
66567: LD_VAR 0 2
66571: PUSH
66572: LD_VAR 0 3
66576: PUSH
66577: LD_VAR 0 4
66581: PUSH
66582: LD_VAR 0 5
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: LIST
66591: LIST
66592: ST_TO_ADDR
// end ;
66593: LD_VAR 0 6
66597: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66598: LD_INT 0
66600: PPUSH
// if not chassis or not engine then
66601: LD_VAR 0 1
66605: NOT
66606: PUSH
66607: LD_VAR 0 2
66611: NOT
66612: OR
66613: IFFALSE 66617
// exit ;
66615: GO 66813
// case engine of engine_solar :
66617: LD_VAR 0 2
66621: PUSH
66622: LD_INT 2
66624: DOUBLE
66625: EQUAL
66626: IFTRUE 66630
66628: GO 66668
66630: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66631: LD_ADDR_VAR 0 3
66635: PUSH
66636: LD_INT 11
66638: PUSH
66639: LD_INT 12
66641: PUSH
66642: LD_INT 13
66644: PUSH
66645: LD_INT 14
66647: PUSH
66648: LD_INT 1
66650: PUSH
66651: LD_INT 2
66653: PUSH
66654: LD_INT 3
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: LIST
66665: ST_TO_ADDR
66666: GO 66797
66668: LD_INT 1
66670: DOUBLE
66671: EQUAL
66672: IFTRUE 66676
66674: GO 66738
66676: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66677: LD_ADDR_VAR 0 3
66681: PUSH
66682: LD_INT 11
66684: PUSH
66685: LD_INT 12
66687: PUSH
66688: LD_INT 13
66690: PUSH
66691: LD_INT 14
66693: PUSH
66694: LD_INT 1
66696: PUSH
66697: LD_INT 2
66699: PUSH
66700: LD_INT 3
66702: PUSH
66703: LD_INT 4
66705: PUSH
66706: LD_INT 5
66708: PUSH
66709: LD_INT 21
66711: PUSH
66712: LD_INT 23
66714: PUSH
66715: LD_INT 22
66717: PUSH
66718: LD_INT 24
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: LIST
66733: LIST
66734: LIST
66735: ST_TO_ADDR
66736: GO 66797
66738: LD_INT 3
66740: DOUBLE
66741: EQUAL
66742: IFTRUE 66746
66744: GO 66796
66746: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66747: LD_ADDR_VAR 0 3
66751: PUSH
66752: LD_INT 13
66754: PUSH
66755: LD_INT 14
66757: PUSH
66758: LD_INT 2
66760: PUSH
66761: LD_INT 3
66763: PUSH
66764: LD_INT 4
66766: PUSH
66767: LD_INT 5
66769: PUSH
66770: LD_INT 21
66772: PUSH
66773: LD_INT 22
66775: PUSH
66776: LD_INT 23
66778: PUSH
66779: LD_INT 24
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: LIST
66791: LIST
66792: LIST
66793: ST_TO_ADDR
66794: GO 66797
66796: POP
// result := ( chassis in result ) ;
66797: LD_ADDR_VAR 0 3
66801: PUSH
66802: LD_VAR 0 1
66806: PUSH
66807: LD_VAR 0 3
66811: IN
66812: ST_TO_ADDR
// end ;
66813: LD_VAR 0 3
66817: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66818: LD_INT 0
66820: PPUSH
// if not chassis or not weapon then
66821: LD_VAR 0 1
66825: NOT
66826: PUSH
66827: LD_VAR 0 2
66831: NOT
66832: OR
66833: IFFALSE 66837
// exit ;
66835: GO 67897
// case weapon of us_machine_gun :
66837: LD_VAR 0 2
66841: PUSH
66842: LD_INT 2
66844: DOUBLE
66845: EQUAL
66846: IFTRUE 66850
66848: GO 66880
66850: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66851: LD_ADDR_VAR 0 3
66855: PUSH
66856: LD_INT 1
66858: PUSH
66859: LD_INT 2
66861: PUSH
66862: LD_INT 3
66864: PUSH
66865: LD_INT 4
66867: PUSH
66868: LD_INT 5
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: LIST
66877: ST_TO_ADDR
66878: GO 67881
66880: LD_INT 3
66882: DOUBLE
66883: EQUAL
66884: IFTRUE 66888
66886: GO 66918
66888: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66889: LD_ADDR_VAR 0 3
66893: PUSH
66894: LD_INT 1
66896: PUSH
66897: LD_INT 2
66899: PUSH
66900: LD_INT 3
66902: PUSH
66903: LD_INT 4
66905: PUSH
66906: LD_INT 5
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: ST_TO_ADDR
66916: GO 67881
66918: LD_INT 11
66920: DOUBLE
66921: EQUAL
66922: IFTRUE 66926
66924: GO 66956
66926: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66927: LD_ADDR_VAR 0 3
66931: PUSH
66932: LD_INT 1
66934: PUSH
66935: LD_INT 2
66937: PUSH
66938: LD_INT 3
66940: PUSH
66941: LD_INT 4
66943: PUSH
66944: LD_INT 5
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: ST_TO_ADDR
66954: GO 67881
66956: LD_INT 4
66958: DOUBLE
66959: EQUAL
66960: IFTRUE 66964
66962: GO 66990
66964: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66965: LD_ADDR_VAR 0 3
66969: PUSH
66970: LD_INT 2
66972: PUSH
66973: LD_INT 3
66975: PUSH
66976: LD_INT 4
66978: PUSH
66979: LD_INT 5
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: LIST
66986: LIST
66987: ST_TO_ADDR
66988: GO 67881
66990: LD_INT 5
66992: DOUBLE
66993: EQUAL
66994: IFTRUE 66998
66996: GO 67024
66998: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66999: LD_ADDR_VAR 0 3
67003: PUSH
67004: LD_INT 2
67006: PUSH
67007: LD_INT 3
67009: PUSH
67010: LD_INT 4
67012: PUSH
67013: LD_INT 5
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: ST_TO_ADDR
67022: GO 67881
67024: LD_INT 9
67026: DOUBLE
67027: EQUAL
67028: IFTRUE 67032
67030: GO 67058
67032: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67033: LD_ADDR_VAR 0 3
67037: PUSH
67038: LD_INT 2
67040: PUSH
67041: LD_INT 3
67043: PUSH
67044: LD_INT 4
67046: PUSH
67047: LD_INT 5
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: LIST
67054: LIST
67055: ST_TO_ADDR
67056: GO 67881
67058: LD_INT 7
67060: DOUBLE
67061: EQUAL
67062: IFTRUE 67066
67064: GO 67092
67066: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67067: LD_ADDR_VAR 0 3
67071: PUSH
67072: LD_INT 2
67074: PUSH
67075: LD_INT 3
67077: PUSH
67078: LD_INT 4
67080: PUSH
67081: LD_INT 5
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: ST_TO_ADDR
67090: GO 67881
67092: LD_INT 12
67094: DOUBLE
67095: EQUAL
67096: IFTRUE 67100
67098: GO 67126
67100: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67101: LD_ADDR_VAR 0 3
67105: PUSH
67106: LD_INT 2
67108: PUSH
67109: LD_INT 3
67111: PUSH
67112: LD_INT 4
67114: PUSH
67115: LD_INT 5
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: LIST
67122: LIST
67123: ST_TO_ADDR
67124: GO 67881
67126: LD_INT 13
67128: DOUBLE
67129: EQUAL
67130: IFTRUE 67134
67132: GO 67160
67134: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67135: LD_ADDR_VAR 0 3
67139: PUSH
67140: LD_INT 2
67142: PUSH
67143: LD_INT 3
67145: PUSH
67146: LD_INT 4
67148: PUSH
67149: LD_INT 5
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: ST_TO_ADDR
67158: GO 67881
67160: LD_INT 14
67162: DOUBLE
67163: EQUAL
67164: IFTRUE 67168
67166: GO 67186
67168: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67169: LD_ADDR_VAR 0 3
67173: PUSH
67174: LD_INT 4
67176: PUSH
67177: LD_INT 5
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: ST_TO_ADDR
67184: GO 67881
67186: LD_INT 6
67188: DOUBLE
67189: EQUAL
67190: IFTRUE 67194
67192: GO 67212
67194: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67195: LD_ADDR_VAR 0 3
67199: PUSH
67200: LD_INT 4
67202: PUSH
67203: LD_INT 5
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: ST_TO_ADDR
67210: GO 67881
67212: LD_INT 10
67214: DOUBLE
67215: EQUAL
67216: IFTRUE 67220
67218: GO 67238
67220: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67221: LD_ADDR_VAR 0 3
67225: PUSH
67226: LD_INT 4
67228: PUSH
67229: LD_INT 5
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: ST_TO_ADDR
67236: GO 67881
67238: LD_INT 22
67240: DOUBLE
67241: EQUAL
67242: IFTRUE 67246
67244: GO 67272
67246: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67247: LD_ADDR_VAR 0 3
67251: PUSH
67252: LD_INT 11
67254: PUSH
67255: LD_INT 12
67257: PUSH
67258: LD_INT 13
67260: PUSH
67261: LD_INT 14
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: ST_TO_ADDR
67270: GO 67881
67272: LD_INT 23
67274: DOUBLE
67275: EQUAL
67276: IFTRUE 67280
67278: GO 67306
67280: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67281: LD_ADDR_VAR 0 3
67285: PUSH
67286: LD_INT 11
67288: PUSH
67289: LD_INT 12
67291: PUSH
67292: LD_INT 13
67294: PUSH
67295: LD_INT 14
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: ST_TO_ADDR
67304: GO 67881
67306: LD_INT 24
67308: DOUBLE
67309: EQUAL
67310: IFTRUE 67314
67312: GO 67340
67314: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67315: LD_ADDR_VAR 0 3
67319: PUSH
67320: LD_INT 11
67322: PUSH
67323: LD_INT 12
67325: PUSH
67326: LD_INT 13
67328: PUSH
67329: LD_INT 14
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: ST_TO_ADDR
67338: GO 67881
67340: LD_INT 30
67342: DOUBLE
67343: EQUAL
67344: IFTRUE 67348
67346: GO 67374
67348: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67349: LD_ADDR_VAR 0 3
67353: PUSH
67354: LD_INT 11
67356: PUSH
67357: LD_INT 12
67359: PUSH
67360: LD_INT 13
67362: PUSH
67363: LD_INT 14
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: ST_TO_ADDR
67372: GO 67881
67374: LD_INT 25
67376: DOUBLE
67377: EQUAL
67378: IFTRUE 67382
67380: GO 67400
67382: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67383: LD_ADDR_VAR 0 3
67387: PUSH
67388: LD_INT 13
67390: PUSH
67391: LD_INT 14
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: ST_TO_ADDR
67398: GO 67881
67400: LD_INT 27
67402: DOUBLE
67403: EQUAL
67404: IFTRUE 67408
67406: GO 67426
67408: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67409: LD_ADDR_VAR 0 3
67413: PUSH
67414: LD_INT 13
67416: PUSH
67417: LD_INT 14
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: ST_TO_ADDR
67424: GO 67881
67426: LD_INT 92
67428: DOUBLE
67429: EQUAL
67430: IFTRUE 67434
67432: GO 67460
67434: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67435: LD_ADDR_VAR 0 3
67439: PUSH
67440: LD_INT 11
67442: PUSH
67443: LD_INT 12
67445: PUSH
67446: LD_INT 13
67448: PUSH
67449: LD_INT 14
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: ST_TO_ADDR
67458: GO 67881
67460: LD_INT 28
67462: DOUBLE
67463: EQUAL
67464: IFTRUE 67468
67466: GO 67486
67468: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67469: LD_ADDR_VAR 0 3
67473: PUSH
67474: LD_INT 13
67476: PUSH
67477: LD_INT 14
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: ST_TO_ADDR
67484: GO 67881
67486: LD_INT 29
67488: DOUBLE
67489: EQUAL
67490: IFTRUE 67494
67492: GO 67512
67494: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67495: LD_ADDR_VAR 0 3
67499: PUSH
67500: LD_INT 13
67502: PUSH
67503: LD_INT 14
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: ST_TO_ADDR
67510: GO 67881
67512: LD_INT 31
67514: DOUBLE
67515: EQUAL
67516: IFTRUE 67520
67518: GO 67538
67520: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67521: LD_ADDR_VAR 0 3
67525: PUSH
67526: LD_INT 13
67528: PUSH
67529: LD_INT 14
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: ST_TO_ADDR
67536: GO 67881
67538: LD_INT 26
67540: DOUBLE
67541: EQUAL
67542: IFTRUE 67546
67544: GO 67564
67546: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67547: LD_ADDR_VAR 0 3
67551: PUSH
67552: LD_INT 13
67554: PUSH
67555: LD_INT 14
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: ST_TO_ADDR
67562: GO 67881
67564: LD_INT 42
67566: DOUBLE
67567: EQUAL
67568: IFTRUE 67572
67570: GO 67598
67572: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67573: LD_ADDR_VAR 0 3
67577: PUSH
67578: LD_INT 21
67580: PUSH
67581: LD_INT 22
67583: PUSH
67584: LD_INT 23
67586: PUSH
67587: LD_INT 24
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: ST_TO_ADDR
67596: GO 67881
67598: LD_INT 43
67600: DOUBLE
67601: EQUAL
67602: IFTRUE 67606
67604: GO 67632
67606: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67607: LD_ADDR_VAR 0 3
67611: PUSH
67612: LD_INT 21
67614: PUSH
67615: LD_INT 22
67617: PUSH
67618: LD_INT 23
67620: PUSH
67621: LD_INT 24
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: LIST
67628: LIST
67629: ST_TO_ADDR
67630: GO 67881
67632: LD_INT 44
67634: DOUBLE
67635: EQUAL
67636: IFTRUE 67640
67638: GO 67666
67640: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67641: LD_ADDR_VAR 0 3
67645: PUSH
67646: LD_INT 21
67648: PUSH
67649: LD_INT 22
67651: PUSH
67652: LD_INT 23
67654: PUSH
67655: LD_INT 24
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: LIST
67662: LIST
67663: ST_TO_ADDR
67664: GO 67881
67666: LD_INT 45
67668: DOUBLE
67669: EQUAL
67670: IFTRUE 67674
67672: GO 67700
67674: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67675: LD_ADDR_VAR 0 3
67679: PUSH
67680: LD_INT 21
67682: PUSH
67683: LD_INT 22
67685: PUSH
67686: LD_INT 23
67688: PUSH
67689: LD_INT 24
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: ST_TO_ADDR
67698: GO 67881
67700: LD_INT 49
67702: DOUBLE
67703: EQUAL
67704: IFTRUE 67708
67706: GO 67734
67708: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67709: LD_ADDR_VAR 0 3
67713: PUSH
67714: LD_INT 21
67716: PUSH
67717: LD_INT 22
67719: PUSH
67720: LD_INT 23
67722: PUSH
67723: LD_INT 24
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: ST_TO_ADDR
67732: GO 67881
67734: LD_INT 51
67736: DOUBLE
67737: EQUAL
67738: IFTRUE 67742
67740: GO 67768
67742: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67743: LD_ADDR_VAR 0 3
67747: PUSH
67748: LD_INT 21
67750: PUSH
67751: LD_INT 22
67753: PUSH
67754: LD_INT 23
67756: PUSH
67757: LD_INT 24
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: ST_TO_ADDR
67766: GO 67881
67768: LD_INT 52
67770: DOUBLE
67771: EQUAL
67772: IFTRUE 67776
67774: GO 67802
67776: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67777: LD_ADDR_VAR 0 3
67781: PUSH
67782: LD_INT 21
67784: PUSH
67785: LD_INT 22
67787: PUSH
67788: LD_INT 23
67790: PUSH
67791: LD_INT 24
67793: PUSH
67794: EMPTY
67795: LIST
67796: LIST
67797: LIST
67798: LIST
67799: ST_TO_ADDR
67800: GO 67881
67802: LD_INT 53
67804: DOUBLE
67805: EQUAL
67806: IFTRUE 67810
67808: GO 67828
67810: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67811: LD_ADDR_VAR 0 3
67815: PUSH
67816: LD_INT 23
67818: PUSH
67819: LD_INT 24
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: ST_TO_ADDR
67826: GO 67881
67828: LD_INT 46
67830: DOUBLE
67831: EQUAL
67832: IFTRUE 67836
67834: GO 67854
67836: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67837: LD_ADDR_VAR 0 3
67841: PUSH
67842: LD_INT 23
67844: PUSH
67845: LD_INT 24
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: ST_TO_ADDR
67852: GO 67881
67854: LD_INT 47
67856: DOUBLE
67857: EQUAL
67858: IFTRUE 67862
67860: GO 67880
67862: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67863: LD_ADDR_VAR 0 3
67867: PUSH
67868: LD_INT 23
67870: PUSH
67871: LD_INT 24
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: ST_TO_ADDR
67878: GO 67881
67880: POP
// result := ( chassis in result ) ;
67881: LD_ADDR_VAR 0 3
67885: PUSH
67886: LD_VAR 0 1
67890: PUSH
67891: LD_VAR 0 3
67895: IN
67896: ST_TO_ADDR
// end ;
67897: LD_VAR 0 3
67901: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67902: LD_INT 0
67904: PPUSH
67905: PPUSH
67906: PPUSH
67907: PPUSH
67908: PPUSH
67909: PPUSH
67910: PPUSH
// result := array ;
67911: LD_ADDR_VAR 0 5
67915: PUSH
67916: LD_VAR 0 1
67920: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67921: LD_VAR 0 1
67925: NOT
67926: PUSH
67927: LD_VAR 0 2
67931: NOT
67932: OR
67933: PUSH
67934: LD_VAR 0 3
67938: NOT
67939: OR
67940: PUSH
67941: LD_VAR 0 2
67945: PUSH
67946: LD_VAR 0 1
67950: GREATER
67951: OR
67952: PUSH
67953: LD_VAR 0 3
67957: PUSH
67958: LD_VAR 0 1
67962: GREATER
67963: OR
67964: IFFALSE 67968
// exit ;
67966: GO 68264
// if direction then
67968: LD_VAR 0 4
67972: IFFALSE 68036
// begin d := 1 ;
67974: LD_ADDR_VAR 0 9
67978: PUSH
67979: LD_INT 1
67981: ST_TO_ADDR
// if i_from > i_to then
67982: LD_VAR 0 2
67986: PUSH
67987: LD_VAR 0 3
67991: GREATER
67992: IFFALSE 68018
// length := ( array - i_from ) + i_to else
67994: LD_ADDR_VAR 0 11
67998: PUSH
67999: LD_VAR 0 1
68003: PUSH
68004: LD_VAR 0 2
68008: MINUS
68009: PUSH
68010: LD_VAR 0 3
68014: PLUS
68015: ST_TO_ADDR
68016: GO 68034
// length := i_to - i_from ;
68018: LD_ADDR_VAR 0 11
68022: PUSH
68023: LD_VAR 0 3
68027: PUSH
68028: LD_VAR 0 2
68032: MINUS
68033: ST_TO_ADDR
// end else
68034: GO 68097
// begin d := - 1 ;
68036: LD_ADDR_VAR 0 9
68040: PUSH
68041: LD_INT 1
68043: NEG
68044: ST_TO_ADDR
// if i_from > i_to then
68045: LD_VAR 0 2
68049: PUSH
68050: LD_VAR 0 3
68054: GREATER
68055: IFFALSE 68075
// length := i_from - i_to else
68057: LD_ADDR_VAR 0 11
68061: PUSH
68062: LD_VAR 0 2
68066: PUSH
68067: LD_VAR 0 3
68071: MINUS
68072: ST_TO_ADDR
68073: GO 68097
// length := ( array - i_to ) + i_from ;
68075: LD_ADDR_VAR 0 11
68079: PUSH
68080: LD_VAR 0 1
68084: PUSH
68085: LD_VAR 0 3
68089: MINUS
68090: PUSH
68091: LD_VAR 0 2
68095: PLUS
68096: ST_TO_ADDR
// end ; if not length then
68097: LD_VAR 0 11
68101: NOT
68102: IFFALSE 68106
// exit ;
68104: GO 68264
// tmp := array ;
68106: LD_ADDR_VAR 0 10
68110: PUSH
68111: LD_VAR 0 1
68115: ST_TO_ADDR
// for i = 1 to length do
68116: LD_ADDR_VAR 0 6
68120: PUSH
68121: DOUBLE
68122: LD_INT 1
68124: DEC
68125: ST_TO_ADDR
68126: LD_VAR 0 11
68130: PUSH
68131: FOR_TO
68132: IFFALSE 68252
// begin for j = 1 to array do
68134: LD_ADDR_VAR 0 7
68138: PUSH
68139: DOUBLE
68140: LD_INT 1
68142: DEC
68143: ST_TO_ADDR
68144: LD_VAR 0 1
68148: PUSH
68149: FOR_TO
68150: IFFALSE 68238
// begin k := j + d ;
68152: LD_ADDR_VAR 0 8
68156: PUSH
68157: LD_VAR 0 7
68161: PUSH
68162: LD_VAR 0 9
68166: PLUS
68167: ST_TO_ADDR
// if k > array then
68168: LD_VAR 0 8
68172: PUSH
68173: LD_VAR 0 1
68177: GREATER
68178: IFFALSE 68188
// k := 1 ;
68180: LD_ADDR_VAR 0 8
68184: PUSH
68185: LD_INT 1
68187: ST_TO_ADDR
// if not k then
68188: LD_VAR 0 8
68192: NOT
68193: IFFALSE 68205
// k := array ;
68195: LD_ADDR_VAR 0 8
68199: PUSH
68200: LD_VAR 0 1
68204: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68205: LD_ADDR_VAR 0 10
68209: PUSH
68210: LD_VAR 0 10
68214: PPUSH
68215: LD_VAR 0 8
68219: PPUSH
68220: LD_VAR 0 1
68224: PUSH
68225: LD_VAR 0 7
68229: ARRAY
68230: PPUSH
68231: CALL_OW 1
68235: ST_TO_ADDR
// end ;
68236: GO 68149
68238: POP
68239: POP
// array := tmp ;
68240: LD_ADDR_VAR 0 1
68244: PUSH
68245: LD_VAR 0 10
68249: ST_TO_ADDR
// end ;
68250: GO 68131
68252: POP
68253: POP
// result := array ;
68254: LD_ADDR_VAR 0 5
68258: PUSH
68259: LD_VAR 0 1
68263: ST_TO_ADDR
// end ;
68264: LD_VAR 0 5
68268: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68269: LD_INT 0
68271: PPUSH
68272: PPUSH
// result := 0 ;
68273: LD_ADDR_VAR 0 3
68277: PUSH
68278: LD_INT 0
68280: ST_TO_ADDR
// if not array or not value in array then
68281: LD_VAR 0 1
68285: NOT
68286: PUSH
68287: LD_VAR 0 2
68291: PUSH
68292: LD_VAR 0 1
68296: IN
68297: NOT
68298: OR
68299: IFFALSE 68303
// exit ;
68301: GO 68357
// for i = 1 to array do
68303: LD_ADDR_VAR 0 4
68307: PUSH
68308: DOUBLE
68309: LD_INT 1
68311: DEC
68312: ST_TO_ADDR
68313: LD_VAR 0 1
68317: PUSH
68318: FOR_TO
68319: IFFALSE 68355
// if value = array [ i ] then
68321: LD_VAR 0 2
68325: PUSH
68326: LD_VAR 0 1
68330: PUSH
68331: LD_VAR 0 4
68335: ARRAY
68336: EQUAL
68337: IFFALSE 68353
// begin result := i ;
68339: LD_ADDR_VAR 0 3
68343: PUSH
68344: LD_VAR 0 4
68348: ST_TO_ADDR
// exit ;
68349: POP
68350: POP
68351: GO 68357
// end ;
68353: GO 68318
68355: POP
68356: POP
// end ;
68357: LD_VAR 0 3
68361: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68362: LD_INT 0
68364: PPUSH
// vc_chassis := chassis ;
68365: LD_ADDR_OWVAR 37
68369: PUSH
68370: LD_VAR 0 1
68374: ST_TO_ADDR
// vc_engine := engine ;
68375: LD_ADDR_OWVAR 39
68379: PUSH
68380: LD_VAR 0 2
68384: ST_TO_ADDR
// vc_control := control ;
68385: LD_ADDR_OWVAR 38
68389: PUSH
68390: LD_VAR 0 3
68394: ST_TO_ADDR
// vc_weapon := weapon ;
68395: LD_ADDR_OWVAR 40
68399: PUSH
68400: LD_VAR 0 4
68404: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68405: LD_ADDR_OWVAR 41
68409: PUSH
68410: LD_VAR 0 5
68414: ST_TO_ADDR
// end ;
68415: LD_VAR 0 6
68419: RET
// export function WantPlant ( unit ) ; var task ; begin
68420: LD_INT 0
68422: PPUSH
68423: PPUSH
// result := false ;
68424: LD_ADDR_VAR 0 2
68428: PUSH
68429: LD_INT 0
68431: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68432: LD_ADDR_VAR 0 3
68436: PUSH
68437: LD_VAR 0 1
68441: PPUSH
68442: CALL_OW 437
68446: ST_TO_ADDR
// if task then
68447: LD_VAR 0 3
68451: IFFALSE 68479
// if task [ 1 ] [ 1 ] = p then
68453: LD_VAR 0 3
68457: PUSH
68458: LD_INT 1
68460: ARRAY
68461: PUSH
68462: LD_INT 1
68464: ARRAY
68465: PUSH
68466: LD_STRING p
68468: EQUAL
68469: IFFALSE 68479
// result := true ;
68471: LD_ADDR_VAR 0 2
68475: PUSH
68476: LD_INT 1
68478: ST_TO_ADDR
// end ;
68479: LD_VAR 0 2
68483: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68484: LD_INT 0
68486: PPUSH
68487: PPUSH
68488: PPUSH
68489: PPUSH
// if pos < 1 then
68490: LD_VAR 0 2
68494: PUSH
68495: LD_INT 1
68497: LESS
68498: IFFALSE 68502
// exit ;
68500: GO 68805
// if pos = 1 then
68502: LD_VAR 0 2
68506: PUSH
68507: LD_INT 1
68509: EQUAL
68510: IFFALSE 68543
// result := Replace ( arr , pos [ 1 ] , value ) else
68512: LD_ADDR_VAR 0 4
68516: PUSH
68517: LD_VAR 0 1
68521: PPUSH
68522: LD_VAR 0 2
68526: PUSH
68527: LD_INT 1
68529: ARRAY
68530: PPUSH
68531: LD_VAR 0 3
68535: PPUSH
68536: CALL_OW 1
68540: ST_TO_ADDR
68541: GO 68805
// begin tmp := arr ;
68543: LD_ADDR_VAR 0 6
68547: PUSH
68548: LD_VAR 0 1
68552: ST_TO_ADDR
// s_arr := [ tmp ] ;
68553: LD_ADDR_VAR 0 7
68557: PUSH
68558: LD_VAR 0 6
68562: PUSH
68563: EMPTY
68564: LIST
68565: ST_TO_ADDR
// for i = 1 to pos - 1 do
68566: LD_ADDR_VAR 0 5
68570: PUSH
68571: DOUBLE
68572: LD_INT 1
68574: DEC
68575: ST_TO_ADDR
68576: LD_VAR 0 2
68580: PUSH
68581: LD_INT 1
68583: MINUS
68584: PUSH
68585: FOR_TO
68586: IFFALSE 68631
// begin tmp := tmp [ pos [ i ] ] ;
68588: LD_ADDR_VAR 0 6
68592: PUSH
68593: LD_VAR 0 6
68597: PUSH
68598: LD_VAR 0 2
68602: PUSH
68603: LD_VAR 0 5
68607: ARRAY
68608: ARRAY
68609: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68610: LD_ADDR_VAR 0 7
68614: PUSH
68615: LD_VAR 0 7
68619: PUSH
68620: LD_VAR 0 6
68624: PUSH
68625: EMPTY
68626: LIST
68627: ADD
68628: ST_TO_ADDR
// end ;
68629: GO 68585
68631: POP
68632: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68633: LD_ADDR_VAR 0 6
68637: PUSH
68638: LD_VAR 0 6
68642: PPUSH
68643: LD_VAR 0 2
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PPUSH
68654: LD_VAR 0 3
68658: PPUSH
68659: CALL_OW 1
68663: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68664: LD_ADDR_VAR 0 7
68668: PUSH
68669: LD_VAR 0 7
68673: PPUSH
68674: LD_VAR 0 7
68678: PPUSH
68679: LD_VAR 0 6
68683: PPUSH
68684: CALL_OW 1
68688: ST_TO_ADDR
// for i = s_arr downto 2 do
68689: LD_ADDR_VAR 0 5
68693: PUSH
68694: DOUBLE
68695: LD_VAR 0 7
68699: INC
68700: ST_TO_ADDR
68701: LD_INT 2
68703: PUSH
68704: FOR_DOWNTO
68705: IFFALSE 68789
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68707: LD_ADDR_VAR 0 6
68711: PUSH
68712: LD_VAR 0 7
68716: PUSH
68717: LD_VAR 0 5
68721: PUSH
68722: LD_INT 1
68724: MINUS
68725: ARRAY
68726: PPUSH
68727: LD_VAR 0 2
68731: PUSH
68732: LD_VAR 0 5
68736: PUSH
68737: LD_INT 1
68739: MINUS
68740: ARRAY
68741: PPUSH
68742: LD_VAR 0 7
68746: PUSH
68747: LD_VAR 0 5
68751: ARRAY
68752: PPUSH
68753: CALL_OW 1
68757: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68758: LD_ADDR_VAR 0 7
68762: PUSH
68763: LD_VAR 0 7
68767: PPUSH
68768: LD_VAR 0 5
68772: PUSH
68773: LD_INT 1
68775: MINUS
68776: PPUSH
68777: LD_VAR 0 6
68781: PPUSH
68782: CALL_OW 1
68786: ST_TO_ADDR
// end ;
68787: GO 68704
68789: POP
68790: POP
// result := s_arr [ 1 ] ;
68791: LD_ADDR_VAR 0 4
68795: PUSH
68796: LD_VAR 0 7
68800: PUSH
68801: LD_INT 1
68803: ARRAY
68804: ST_TO_ADDR
// end ; end ;
68805: LD_VAR 0 4
68809: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68810: LD_INT 0
68812: PPUSH
68813: PPUSH
// if not list then
68814: LD_VAR 0 1
68818: NOT
68819: IFFALSE 68823
// exit ;
68821: GO 68914
// i := list [ pos1 ] ;
68823: LD_ADDR_VAR 0 5
68827: PUSH
68828: LD_VAR 0 1
68832: PUSH
68833: LD_VAR 0 2
68837: ARRAY
68838: ST_TO_ADDR
// if not i then
68839: LD_VAR 0 5
68843: NOT
68844: IFFALSE 68848
// exit ;
68846: GO 68914
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68848: LD_ADDR_VAR 0 1
68852: PUSH
68853: LD_VAR 0 1
68857: PPUSH
68858: LD_VAR 0 2
68862: PPUSH
68863: LD_VAR 0 1
68867: PUSH
68868: LD_VAR 0 3
68872: ARRAY
68873: PPUSH
68874: CALL_OW 1
68878: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68879: LD_ADDR_VAR 0 1
68883: PUSH
68884: LD_VAR 0 1
68888: PPUSH
68889: LD_VAR 0 3
68893: PPUSH
68894: LD_VAR 0 5
68898: PPUSH
68899: CALL_OW 1
68903: ST_TO_ADDR
// result := list ;
68904: LD_ADDR_VAR 0 4
68908: PUSH
68909: LD_VAR 0 1
68913: ST_TO_ADDR
// end ;
68914: LD_VAR 0 4
68918: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68919: LD_INT 0
68921: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68922: LD_ADDR_VAR 0 5
68926: PUSH
68927: LD_VAR 0 1
68931: PPUSH
68932: CALL_OW 250
68936: PPUSH
68937: LD_VAR 0 1
68941: PPUSH
68942: CALL_OW 251
68946: PPUSH
68947: LD_VAR 0 2
68951: PPUSH
68952: LD_VAR 0 3
68956: PPUSH
68957: LD_VAR 0 4
68961: PPUSH
68962: CALL 68972 0 5
68966: ST_TO_ADDR
// end ;
68967: LD_VAR 0 5
68971: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68972: LD_INT 0
68974: PPUSH
68975: PPUSH
68976: PPUSH
68977: PPUSH
// if not list then
68978: LD_VAR 0 3
68982: NOT
68983: IFFALSE 68987
// exit ;
68985: GO 69375
// result := [ ] ;
68987: LD_ADDR_VAR 0 6
68991: PUSH
68992: EMPTY
68993: ST_TO_ADDR
// for i in list do
68994: LD_ADDR_VAR 0 7
68998: PUSH
68999: LD_VAR 0 3
69003: PUSH
69004: FOR_IN
69005: IFFALSE 69207
// begin tmp := GetDistUnitXY ( i , x , y ) ;
69007: LD_ADDR_VAR 0 9
69011: PUSH
69012: LD_VAR 0 7
69016: PPUSH
69017: LD_VAR 0 1
69021: PPUSH
69022: LD_VAR 0 2
69026: PPUSH
69027: CALL_OW 297
69031: ST_TO_ADDR
// if not result then
69032: LD_VAR 0 6
69036: NOT
69037: IFFALSE 69063
// result := [ [ i , tmp ] ] else
69039: LD_ADDR_VAR 0 6
69043: PUSH
69044: LD_VAR 0 7
69048: PUSH
69049: LD_VAR 0 9
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PUSH
69058: EMPTY
69059: LIST
69060: ST_TO_ADDR
69061: GO 69205
// begin if result [ result ] [ 2 ] < tmp then
69063: LD_VAR 0 6
69067: PUSH
69068: LD_VAR 0 6
69072: ARRAY
69073: PUSH
69074: LD_INT 2
69076: ARRAY
69077: PUSH
69078: LD_VAR 0 9
69082: LESS
69083: IFFALSE 69125
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69085: LD_ADDR_VAR 0 6
69089: PUSH
69090: LD_VAR 0 6
69094: PPUSH
69095: LD_VAR 0 6
69099: PUSH
69100: LD_INT 1
69102: PLUS
69103: PPUSH
69104: LD_VAR 0 7
69108: PUSH
69109: LD_VAR 0 9
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PPUSH
69118: CALL_OW 2
69122: ST_TO_ADDR
69123: GO 69205
// for j = 1 to result do
69125: LD_ADDR_VAR 0 8
69129: PUSH
69130: DOUBLE
69131: LD_INT 1
69133: DEC
69134: ST_TO_ADDR
69135: LD_VAR 0 6
69139: PUSH
69140: FOR_TO
69141: IFFALSE 69203
// begin if tmp < result [ j ] [ 2 ] then
69143: LD_VAR 0 9
69147: PUSH
69148: LD_VAR 0 6
69152: PUSH
69153: LD_VAR 0 8
69157: ARRAY
69158: PUSH
69159: LD_INT 2
69161: ARRAY
69162: LESS
69163: IFFALSE 69201
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69165: LD_ADDR_VAR 0 6
69169: PUSH
69170: LD_VAR 0 6
69174: PPUSH
69175: LD_VAR 0 8
69179: PPUSH
69180: LD_VAR 0 7
69184: PUSH
69185: LD_VAR 0 9
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PPUSH
69194: CALL_OW 2
69198: ST_TO_ADDR
// break ;
69199: GO 69203
// end ; end ;
69201: GO 69140
69203: POP
69204: POP
// end ; end ;
69205: GO 69004
69207: POP
69208: POP
// if result and not asc then
69209: LD_VAR 0 6
69213: PUSH
69214: LD_VAR 0 4
69218: NOT
69219: AND
69220: IFFALSE 69295
// begin tmp := result ;
69222: LD_ADDR_VAR 0 9
69226: PUSH
69227: LD_VAR 0 6
69231: ST_TO_ADDR
// for i = tmp downto 1 do
69232: LD_ADDR_VAR 0 7
69236: PUSH
69237: DOUBLE
69238: LD_VAR 0 9
69242: INC
69243: ST_TO_ADDR
69244: LD_INT 1
69246: PUSH
69247: FOR_DOWNTO
69248: IFFALSE 69293
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69250: LD_ADDR_VAR 0 6
69254: PUSH
69255: LD_VAR 0 6
69259: PPUSH
69260: LD_VAR 0 9
69264: PUSH
69265: LD_VAR 0 7
69269: MINUS
69270: PUSH
69271: LD_INT 1
69273: PLUS
69274: PPUSH
69275: LD_VAR 0 9
69279: PUSH
69280: LD_VAR 0 7
69284: ARRAY
69285: PPUSH
69286: CALL_OW 1
69290: ST_TO_ADDR
69291: GO 69247
69293: POP
69294: POP
// end ; tmp := [ ] ;
69295: LD_ADDR_VAR 0 9
69299: PUSH
69300: EMPTY
69301: ST_TO_ADDR
// if mode then
69302: LD_VAR 0 5
69306: IFFALSE 69375
// begin for i = 1 to result do
69308: LD_ADDR_VAR 0 7
69312: PUSH
69313: DOUBLE
69314: LD_INT 1
69316: DEC
69317: ST_TO_ADDR
69318: LD_VAR 0 6
69322: PUSH
69323: FOR_TO
69324: IFFALSE 69363
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69326: LD_ADDR_VAR 0 9
69330: PUSH
69331: LD_VAR 0 9
69335: PPUSH
69336: LD_VAR 0 7
69340: PPUSH
69341: LD_VAR 0 6
69345: PUSH
69346: LD_VAR 0 7
69350: ARRAY
69351: PUSH
69352: LD_INT 1
69354: ARRAY
69355: PPUSH
69356: CALL_OW 1
69360: ST_TO_ADDR
69361: GO 69323
69363: POP
69364: POP
// result := tmp ;
69365: LD_ADDR_VAR 0 6
69369: PUSH
69370: LD_VAR 0 9
69374: ST_TO_ADDR
// end ; end ;
69375: LD_VAR 0 6
69379: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69380: LD_INT 0
69382: PPUSH
69383: PPUSH
69384: PPUSH
69385: PPUSH
69386: PPUSH
69387: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69388: LD_ADDR_VAR 0 5
69392: PUSH
69393: LD_INT 0
69395: PUSH
69396: LD_INT 0
69398: PUSH
69399: LD_INT 0
69401: PUSH
69402: EMPTY
69403: PUSH
69404: EMPTY
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: ST_TO_ADDR
// if not x or not y then
69410: LD_VAR 0 2
69414: NOT
69415: PUSH
69416: LD_VAR 0 3
69420: NOT
69421: OR
69422: IFFALSE 69426
// exit ;
69424: GO 71076
// if not range then
69426: LD_VAR 0 4
69430: NOT
69431: IFFALSE 69441
// range := 10 ;
69433: LD_ADDR_VAR 0 4
69437: PUSH
69438: LD_INT 10
69440: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69441: LD_ADDR_VAR 0 8
69445: PUSH
69446: LD_INT 81
69448: PUSH
69449: LD_VAR 0 1
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 92
69460: PUSH
69461: LD_VAR 0 2
69465: PUSH
69466: LD_VAR 0 3
69470: PUSH
69471: LD_VAR 0 4
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: LIST
69480: LIST
69481: PUSH
69482: LD_INT 3
69484: PUSH
69485: LD_INT 21
69487: PUSH
69488: LD_INT 3
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: EMPTY
69496: LIST
69497: LIST
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: LIST
69503: PPUSH
69504: CALL_OW 69
69508: ST_TO_ADDR
// if not tmp then
69509: LD_VAR 0 8
69513: NOT
69514: IFFALSE 69518
// exit ;
69516: GO 71076
// for i in tmp do
69518: LD_ADDR_VAR 0 6
69522: PUSH
69523: LD_VAR 0 8
69527: PUSH
69528: FOR_IN
69529: IFFALSE 71051
// begin points := [ 0 , 0 , 0 ] ;
69531: LD_ADDR_VAR 0 9
69535: PUSH
69536: LD_INT 0
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: LD_INT 0
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: LIST
69549: ST_TO_ADDR
// bpoints := 1 ;
69550: LD_ADDR_VAR 0 10
69554: PUSH
69555: LD_INT 1
69557: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69558: LD_VAR 0 6
69562: PPUSH
69563: CALL_OW 247
69567: PUSH
69568: LD_INT 1
69570: DOUBLE
69571: EQUAL
69572: IFTRUE 69576
69574: GO 70154
69576: POP
// begin if GetClass ( i ) = 1 then
69577: LD_VAR 0 6
69581: PPUSH
69582: CALL_OW 257
69586: PUSH
69587: LD_INT 1
69589: EQUAL
69590: IFFALSE 69611
// points := [ 10 , 5 , 3 ] ;
69592: LD_ADDR_VAR 0 9
69596: PUSH
69597: LD_INT 10
69599: PUSH
69600: LD_INT 5
69602: PUSH
69603: LD_INT 3
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: LIST
69610: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69611: LD_VAR 0 6
69615: PPUSH
69616: CALL_OW 257
69620: PUSH
69621: LD_INT 2
69623: PUSH
69624: LD_INT 3
69626: PUSH
69627: LD_INT 4
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: LIST
69634: IN
69635: IFFALSE 69656
// points := [ 3 , 2 , 1 ] ;
69637: LD_ADDR_VAR 0 9
69641: PUSH
69642: LD_INT 3
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: LIST
69655: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69656: LD_VAR 0 6
69660: PPUSH
69661: CALL_OW 257
69665: PUSH
69666: LD_INT 5
69668: EQUAL
69669: IFFALSE 69690
// points := [ 130 , 5 , 2 ] ;
69671: LD_ADDR_VAR 0 9
69675: PUSH
69676: LD_INT 130
69678: PUSH
69679: LD_INT 5
69681: PUSH
69682: LD_INT 2
69684: PUSH
69685: EMPTY
69686: LIST
69687: LIST
69688: LIST
69689: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69690: LD_VAR 0 6
69694: PPUSH
69695: CALL_OW 257
69699: PUSH
69700: LD_INT 8
69702: EQUAL
69703: IFFALSE 69724
// points := [ 35 , 35 , 30 ] ;
69705: LD_ADDR_VAR 0 9
69709: PUSH
69710: LD_INT 35
69712: PUSH
69713: LD_INT 35
69715: PUSH
69716: LD_INT 30
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: LIST
69723: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69724: LD_VAR 0 6
69728: PPUSH
69729: CALL_OW 257
69733: PUSH
69734: LD_INT 9
69736: EQUAL
69737: IFFALSE 69758
// points := [ 20 , 55 , 40 ] ;
69739: LD_ADDR_VAR 0 9
69743: PUSH
69744: LD_INT 20
69746: PUSH
69747: LD_INT 55
69749: PUSH
69750: LD_INT 40
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: LIST
69757: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69758: LD_VAR 0 6
69762: PPUSH
69763: CALL_OW 257
69767: PUSH
69768: LD_INT 12
69770: PUSH
69771: LD_INT 16
69773: PUSH
69774: EMPTY
69775: LIST
69776: LIST
69777: IN
69778: IFFALSE 69799
// points := [ 5 , 3 , 2 ] ;
69780: LD_ADDR_VAR 0 9
69784: PUSH
69785: LD_INT 5
69787: PUSH
69788: LD_INT 3
69790: PUSH
69791: LD_INT 2
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: LIST
69798: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69799: LD_VAR 0 6
69803: PPUSH
69804: CALL_OW 257
69808: PUSH
69809: LD_INT 17
69811: EQUAL
69812: IFFALSE 69833
// points := [ 100 , 50 , 75 ] ;
69814: LD_ADDR_VAR 0 9
69818: PUSH
69819: LD_INT 100
69821: PUSH
69822: LD_INT 50
69824: PUSH
69825: LD_INT 75
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: LIST
69832: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69833: LD_VAR 0 6
69837: PPUSH
69838: CALL_OW 257
69842: PUSH
69843: LD_INT 15
69845: EQUAL
69846: IFFALSE 69867
// points := [ 10 , 5 , 3 ] ;
69848: LD_ADDR_VAR 0 9
69852: PUSH
69853: LD_INT 10
69855: PUSH
69856: LD_INT 5
69858: PUSH
69859: LD_INT 3
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: LIST
69866: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69867: LD_VAR 0 6
69871: PPUSH
69872: CALL_OW 257
69876: PUSH
69877: LD_INT 14
69879: EQUAL
69880: IFFALSE 69901
// points := [ 10 , 0 , 0 ] ;
69882: LD_ADDR_VAR 0 9
69886: PUSH
69887: LD_INT 10
69889: PUSH
69890: LD_INT 0
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: LIST
69900: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69901: LD_VAR 0 6
69905: PPUSH
69906: CALL_OW 257
69910: PUSH
69911: LD_INT 11
69913: EQUAL
69914: IFFALSE 69935
// points := [ 30 , 10 , 5 ] ;
69916: LD_ADDR_VAR 0 9
69920: PUSH
69921: LD_INT 30
69923: PUSH
69924: LD_INT 10
69926: PUSH
69927: LD_INT 5
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: LIST
69934: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69935: LD_VAR 0 1
69939: PPUSH
69940: LD_INT 5
69942: PPUSH
69943: CALL_OW 321
69947: PUSH
69948: LD_INT 2
69950: EQUAL
69951: IFFALSE 69968
// bpoints := bpoints * 1.8 ;
69953: LD_ADDR_VAR 0 10
69957: PUSH
69958: LD_VAR 0 10
69962: PUSH
69963: LD_REAL  1.80000000000000E+0000
69966: MUL
69967: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69968: LD_VAR 0 6
69972: PPUSH
69973: CALL_OW 257
69977: PUSH
69978: LD_INT 1
69980: PUSH
69981: LD_INT 2
69983: PUSH
69984: LD_INT 3
69986: PUSH
69987: LD_INT 4
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: IN
69996: PUSH
69997: LD_VAR 0 1
70001: PPUSH
70002: LD_INT 51
70004: PPUSH
70005: CALL_OW 321
70009: PUSH
70010: LD_INT 2
70012: EQUAL
70013: AND
70014: IFFALSE 70031
// bpoints := bpoints * 1.2 ;
70016: LD_ADDR_VAR 0 10
70020: PUSH
70021: LD_VAR 0 10
70025: PUSH
70026: LD_REAL  1.20000000000000E+0000
70029: MUL
70030: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
70031: LD_VAR 0 6
70035: PPUSH
70036: CALL_OW 257
70040: PUSH
70041: LD_INT 5
70043: PUSH
70044: LD_INT 7
70046: PUSH
70047: LD_INT 9
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: LIST
70054: IN
70055: PUSH
70056: LD_VAR 0 1
70060: PPUSH
70061: LD_INT 52
70063: PPUSH
70064: CALL_OW 321
70068: PUSH
70069: LD_INT 2
70071: EQUAL
70072: AND
70073: IFFALSE 70090
// bpoints := bpoints * 1.5 ;
70075: LD_ADDR_VAR 0 10
70079: PUSH
70080: LD_VAR 0 10
70084: PUSH
70085: LD_REAL  1.50000000000000E+0000
70088: MUL
70089: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70090: LD_VAR 0 1
70094: PPUSH
70095: LD_INT 66
70097: PPUSH
70098: CALL_OW 321
70102: PUSH
70103: LD_INT 2
70105: EQUAL
70106: IFFALSE 70123
// bpoints := bpoints * 1.1 ;
70108: LD_ADDR_VAR 0 10
70112: PUSH
70113: LD_VAR 0 10
70117: PUSH
70118: LD_REAL  1.10000000000000E+0000
70121: MUL
70122: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70123: LD_ADDR_VAR 0 10
70127: PUSH
70128: LD_VAR 0 10
70132: PUSH
70133: LD_VAR 0 6
70137: PPUSH
70138: LD_INT 1
70140: PPUSH
70141: CALL_OW 259
70145: PUSH
70146: LD_REAL  1.15000000000000E+0000
70149: MUL
70150: MUL
70151: ST_TO_ADDR
// end ; unit_vehicle :
70152: GO 70980
70154: LD_INT 2
70156: DOUBLE
70157: EQUAL
70158: IFTRUE 70162
70160: GO 70968
70162: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70163: LD_VAR 0 6
70167: PPUSH
70168: CALL_OW 264
70172: PUSH
70173: LD_INT 2
70175: PUSH
70176: LD_INT 42
70178: PUSH
70179: LD_INT 24
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: LIST
70186: IN
70187: IFFALSE 70208
// points := [ 25 , 5 , 3 ] ;
70189: LD_ADDR_VAR 0 9
70193: PUSH
70194: LD_INT 25
70196: PUSH
70197: LD_INT 5
70199: PUSH
70200: LD_INT 3
70202: PUSH
70203: EMPTY
70204: LIST
70205: LIST
70206: LIST
70207: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70208: LD_VAR 0 6
70212: PPUSH
70213: CALL_OW 264
70217: PUSH
70218: LD_INT 4
70220: PUSH
70221: LD_INT 43
70223: PUSH
70224: LD_INT 25
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: LIST
70231: IN
70232: IFFALSE 70253
// points := [ 40 , 15 , 5 ] ;
70234: LD_ADDR_VAR 0 9
70238: PUSH
70239: LD_INT 40
70241: PUSH
70242: LD_INT 15
70244: PUSH
70245: LD_INT 5
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: LIST
70252: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70253: LD_VAR 0 6
70257: PPUSH
70258: CALL_OW 264
70262: PUSH
70263: LD_INT 3
70265: PUSH
70266: LD_INT 23
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: IN
70273: IFFALSE 70294
// points := [ 7 , 25 , 8 ] ;
70275: LD_ADDR_VAR 0 9
70279: PUSH
70280: LD_INT 7
70282: PUSH
70283: LD_INT 25
70285: PUSH
70286: LD_INT 8
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: LIST
70293: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70294: LD_VAR 0 6
70298: PPUSH
70299: CALL_OW 264
70303: PUSH
70304: LD_INT 5
70306: PUSH
70307: LD_INT 27
70309: PUSH
70310: LD_INT 44
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: LIST
70317: IN
70318: IFFALSE 70339
// points := [ 14 , 50 , 16 ] ;
70320: LD_ADDR_VAR 0 9
70324: PUSH
70325: LD_INT 14
70327: PUSH
70328: LD_INT 50
70330: PUSH
70331: LD_INT 16
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: LIST
70338: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70339: LD_VAR 0 6
70343: PPUSH
70344: CALL_OW 264
70348: PUSH
70349: LD_INT 6
70351: PUSH
70352: LD_INT 46
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: IN
70359: IFFALSE 70380
// points := [ 32 , 120 , 70 ] ;
70361: LD_ADDR_VAR 0 9
70365: PUSH
70366: LD_INT 32
70368: PUSH
70369: LD_INT 120
70371: PUSH
70372: LD_INT 70
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: LIST
70379: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
70380: LD_VAR 0 6
70384: PPUSH
70385: CALL_OW 264
70389: PUSH
70390: LD_INT 7
70392: PUSH
70393: LD_INT 28
70395: PUSH
70396: LD_INT 45
70398: PUSH
70399: LD_INT 92
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: LIST
70406: LIST
70407: IN
70408: IFFALSE 70429
// points := [ 35 , 20 , 45 ] ;
70410: LD_ADDR_VAR 0 9
70414: PUSH
70415: LD_INT 35
70417: PUSH
70418: LD_INT 20
70420: PUSH
70421: LD_INT 45
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: LIST
70428: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70429: LD_VAR 0 6
70433: PPUSH
70434: CALL_OW 264
70438: PUSH
70439: LD_INT 47
70441: PUSH
70442: EMPTY
70443: LIST
70444: IN
70445: IFFALSE 70466
// points := [ 67 , 45 , 75 ] ;
70447: LD_ADDR_VAR 0 9
70451: PUSH
70452: LD_INT 67
70454: PUSH
70455: LD_INT 45
70457: PUSH
70458: LD_INT 75
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: LIST
70465: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70466: LD_VAR 0 6
70470: PPUSH
70471: CALL_OW 264
70475: PUSH
70476: LD_INT 26
70478: PUSH
70479: EMPTY
70480: LIST
70481: IN
70482: IFFALSE 70503
// points := [ 120 , 30 , 80 ] ;
70484: LD_ADDR_VAR 0 9
70488: PUSH
70489: LD_INT 120
70491: PUSH
70492: LD_INT 30
70494: PUSH
70495: LD_INT 80
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: LIST
70502: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70503: LD_VAR 0 6
70507: PPUSH
70508: CALL_OW 264
70512: PUSH
70513: LD_INT 22
70515: PUSH
70516: EMPTY
70517: LIST
70518: IN
70519: IFFALSE 70540
// points := [ 40 , 1 , 1 ] ;
70521: LD_ADDR_VAR 0 9
70525: PUSH
70526: LD_INT 40
70528: PUSH
70529: LD_INT 1
70531: PUSH
70532: LD_INT 1
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: LIST
70539: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70540: LD_VAR 0 6
70544: PPUSH
70545: CALL_OW 264
70549: PUSH
70550: LD_INT 29
70552: PUSH
70553: EMPTY
70554: LIST
70555: IN
70556: IFFALSE 70577
// points := [ 70 , 200 , 400 ] ;
70558: LD_ADDR_VAR 0 9
70562: PUSH
70563: LD_INT 70
70565: PUSH
70566: LD_INT 200
70568: PUSH
70569: LD_INT 400
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: LIST
70576: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70577: LD_VAR 0 6
70581: PPUSH
70582: CALL_OW 264
70586: PUSH
70587: LD_INT 14
70589: PUSH
70590: LD_INT 53
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: IN
70597: IFFALSE 70618
// points := [ 40 , 10 , 20 ] ;
70599: LD_ADDR_VAR 0 9
70603: PUSH
70604: LD_INT 40
70606: PUSH
70607: LD_INT 10
70609: PUSH
70610: LD_INT 20
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: LIST
70617: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70618: LD_VAR 0 6
70622: PPUSH
70623: CALL_OW 264
70627: PUSH
70628: LD_INT 9
70630: PUSH
70631: EMPTY
70632: LIST
70633: IN
70634: IFFALSE 70655
// points := [ 5 , 70 , 20 ] ;
70636: LD_ADDR_VAR 0 9
70640: PUSH
70641: LD_INT 5
70643: PUSH
70644: LD_INT 70
70646: PUSH
70647: LD_INT 20
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: LIST
70654: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70655: LD_VAR 0 6
70659: PPUSH
70660: CALL_OW 264
70664: PUSH
70665: LD_INT 10
70667: PUSH
70668: EMPTY
70669: LIST
70670: IN
70671: IFFALSE 70692
// points := [ 35 , 110 , 70 ] ;
70673: LD_ADDR_VAR 0 9
70677: PUSH
70678: LD_INT 35
70680: PUSH
70681: LD_INT 110
70683: PUSH
70684: LD_INT 70
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: LIST
70691: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70692: LD_VAR 0 6
70696: PPUSH
70697: CALL_OW 265
70701: PUSH
70702: LD_INT 25
70704: EQUAL
70705: IFFALSE 70726
// points := [ 80 , 65 , 100 ] ;
70707: LD_ADDR_VAR 0 9
70711: PUSH
70712: LD_INT 80
70714: PUSH
70715: LD_INT 65
70717: PUSH
70718: LD_INT 100
70720: PUSH
70721: EMPTY
70722: LIST
70723: LIST
70724: LIST
70725: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70726: LD_VAR 0 6
70730: PPUSH
70731: CALL_OW 263
70735: PUSH
70736: LD_INT 1
70738: EQUAL
70739: IFFALSE 70774
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70741: LD_ADDR_VAR 0 10
70745: PUSH
70746: LD_VAR 0 10
70750: PUSH
70751: LD_VAR 0 6
70755: PPUSH
70756: CALL_OW 311
70760: PPUSH
70761: LD_INT 3
70763: PPUSH
70764: CALL_OW 259
70768: PUSH
70769: LD_INT 4
70771: MUL
70772: MUL
70773: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70774: LD_VAR 0 6
70778: PPUSH
70779: CALL_OW 263
70783: PUSH
70784: LD_INT 2
70786: EQUAL
70787: IFFALSE 70838
// begin j := IsControledBy ( i ) ;
70789: LD_ADDR_VAR 0 7
70793: PUSH
70794: LD_VAR 0 6
70798: PPUSH
70799: CALL_OW 312
70803: ST_TO_ADDR
// if j then
70804: LD_VAR 0 7
70808: IFFALSE 70838
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70810: LD_ADDR_VAR 0 10
70814: PUSH
70815: LD_VAR 0 10
70819: PUSH
70820: LD_VAR 0 7
70824: PPUSH
70825: LD_INT 3
70827: PPUSH
70828: CALL_OW 259
70832: PUSH
70833: LD_INT 3
70835: MUL
70836: MUL
70837: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70838: LD_VAR 0 6
70842: PPUSH
70843: CALL_OW 264
70847: PUSH
70848: LD_INT 5
70850: PUSH
70851: LD_INT 6
70853: PUSH
70854: LD_INT 46
70856: PUSH
70857: LD_INT 44
70859: PUSH
70860: LD_INT 47
70862: PUSH
70863: LD_INT 45
70865: PUSH
70866: LD_INT 28
70868: PUSH
70869: LD_INT 7
70871: PUSH
70872: LD_INT 27
70874: PUSH
70875: LD_INT 29
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: IN
70890: PUSH
70891: LD_VAR 0 1
70895: PPUSH
70896: LD_INT 52
70898: PPUSH
70899: CALL_OW 321
70903: PUSH
70904: LD_INT 2
70906: EQUAL
70907: AND
70908: IFFALSE 70925
// bpoints := bpoints * 1.2 ;
70910: LD_ADDR_VAR 0 10
70914: PUSH
70915: LD_VAR 0 10
70919: PUSH
70920: LD_REAL  1.20000000000000E+0000
70923: MUL
70924: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70925: LD_VAR 0 6
70929: PPUSH
70930: CALL_OW 264
70934: PUSH
70935: LD_INT 6
70937: PUSH
70938: LD_INT 46
70940: PUSH
70941: LD_INT 47
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: LIST
70948: IN
70949: IFFALSE 70966
// bpoints := bpoints * 1.2 ;
70951: LD_ADDR_VAR 0 10
70955: PUSH
70956: LD_VAR 0 10
70960: PUSH
70961: LD_REAL  1.20000000000000E+0000
70964: MUL
70965: ST_TO_ADDR
// end ; unit_building :
70966: GO 70980
70968: LD_INT 3
70970: DOUBLE
70971: EQUAL
70972: IFTRUE 70976
70974: GO 70979
70976: POP
// ; end ;
70977: GO 70980
70979: POP
// for j = 1 to 3 do
70980: LD_ADDR_VAR 0 7
70984: PUSH
70985: DOUBLE
70986: LD_INT 1
70988: DEC
70989: ST_TO_ADDR
70990: LD_INT 3
70992: PUSH
70993: FOR_TO
70994: IFFALSE 71047
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70996: LD_ADDR_VAR 0 5
71000: PUSH
71001: LD_VAR 0 5
71005: PPUSH
71006: LD_VAR 0 7
71010: PPUSH
71011: LD_VAR 0 5
71015: PUSH
71016: LD_VAR 0 7
71020: ARRAY
71021: PUSH
71022: LD_VAR 0 9
71026: PUSH
71027: LD_VAR 0 7
71031: ARRAY
71032: PUSH
71033: LD_VAR 0 10
71037: MUL
71038: PLUS
71039: PPUSH
71040: CALL_OW 1
71044: ST_TO_ADDR
71045: GO 70993
71047: POP
71048: POP
// end ;
71049: GO 69528
71051: POP
71052: POP
// result := Replace ( result , 4 , tmp ) ;
71053: LD_ADDR_VAR 0 5
71057: PUSH
71058: LD_VAR 0 5
71062: PPUSH
71063: LD_INT 4
71065: PPUSH
71066: LD_VAR 0 8
71070: PPUSH
71071: CALL_OW 1
71075: ST_TO_ADDR
// end ;
71076: LD_VAR 0 5
71080: RET
// export function DangerAtRange ( unit , range ) ; begin
71081: LD_INT 0
71083: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71084: LD_ADDR_VAR 0 3
71088: PUSH
71089: LD_VAR 0 1
71093: PPUSH
71094: CALL_OW 255
71098: PPUSH
71099: LD_VAR 0 1
71103: PPUSH
71104: CALL_OW 250
71108: PPUSH
71109: LD_VAR 0 1
71113: PPUSH
71114: CALL_OW 251
71118: PPUSH
71119: LD_VAR 0 2
71123: PPUSH
71124: CALL 69380 0 4
71128: ST_TO_ADDR
// end ;
71129: LD_VAR 0 3
71133: RET
// export function DangerInArea ( side , area ) ; begin
71134: LD_INT 0
71136: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71137: LD_ADDR_VAR 0 3
71141: PUSH
71142: LD_VAR 0 2
71146: PPUSH
71147: LD_INT 81
71149: PUSH
71150: LD_VAR 0 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PPUSH
71159: CALL_OW 70
71163: ST_TO_ADDR
// end ;
71164: LD_VAR 0 3
71168: RET
// export function IsExtension ( b ) ; begin
71169: LD_INT 0
71171: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71172: LD_ADDR_VAR 0 2
71176: PUSH
71177: LD_VAR 0 1
71181: PUSH
71182: LD_INT 23
71184: PUSH
71185: LD_INT 20
71187: PUSH
71188: LD_INT 22
71190: PUSH
71191: LD_INT 17
71193: PUSH
71194: LD_INT 24
71196: PUSH
71197: LD_INT 21
71199: PUSH
71200: LD_INT 19
71202: PUSH
71203: LD_INT 16
71205: PUSH
71206: LD_INT 25
71208: PUSH
71209: LD_INT 18
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: LIST
71220: LIST
71221: LIST
71222: LIST
71223: IN
71224: ST_TO_ADDR
// end ;
71225: LD_VAR 0 2
71229: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71230: LD_INT 0
71232: PPUSH
71233: PPUSH
71234: PPUSH
// result := [ ] ;
71235: LD_ADDR_VAR 0 4
71239: PUSH
71240: EMPTY
71241: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71242: LD_ADDR_VAR 0 5
71246: PUSH
71247: LD_VAR 0 2
71251: PPUSH
71252: LD_INT 21
71254: PUSH
71255: LD_INT 3
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PPUSH
71262: CALL_OW 70
71266: ST_TO_ADDR
// if not tmp then
71267: LD_VAR 0 5
71271: NOT
71272: IFFALSE 71276
// exit ;
71274: GO 71340
// if checkLink then
71276: LD_VAR 0 3
71280: IFFALSE 71330
// begin for i in tmp do
71282: LD_ADDR_VAR 0 6
71286: PUSH
71287: LD_VAR 0 5
71291: PUSH
71292: FOR_IN
71293: IFFALSE 71328
// if GetBase ( i ) <> base then
71295: LD_VAR 0 6
71299: PPUSH
71300: CALL_OW 274
71304: PUSH
71305: LD_VAR 0 1
71309: NONEQUAL
71310: IFFALSE 71326
// ComLinkToBase ( base , i ) ;
71312: LD_VAR 0 1
71316: PPUSH
71317: LD_VAR 0 6
71321: PPUSH
71322: CALL_OW 169
71326: GO 71292
71328: POP
71329: POP
// end ; result := tmp ;
71330: LD_ADDR_VAR 0 4
71334: PUSH
71335: LD_VAR 0 5
71339: ST_TO_ADDR
// end ;
71340: LD_VAR 0 4
71344: RET
// export function ComComplete ( units , b ) ; var i ; begin
71345: LD_INT 0
71347: PPUSH
71348: PPUSH
// if not units then
71349: LD_VAR 0 1
71353: NOT
71354: IFFALSE 71358
// exit ;
71356: GO 71448
// for i in units do
71358: LD_ADDR_VAR 0 4
71362: PUSH
71363: LD_VAR 0 1
71367: PUSH
71368: FOR_IN
71369: IFFALSE 71446
// if BuildingStatus ( b ) = bs_build then
71371: LD_VAR 0 2
71375: PPUSH
71376: CALL_OW 461
71380: PUSH
71381: LD_INT 1
71383: EQUAL
71384: IFFALSE 71444
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71386: LD_VAR 0 4
71390: PPUSH
71391: LD_STRING h
71393: PUSH
71394: LD_VAR 0 2
71398: PPUSH
71399: CALL_OW 250
71403: PUSH
71404: LD_VAR 0 2
71408: PPUSH
71409: CALL_OW 251
71413: PUSH
71414: LD_VAR 0 2
71418: PUSH
71419: LD_INT 0
71421: PUSH
71422: LD_INT 0
71424: PUSH
71425: LD_INT 0
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: PUSH
71437: EMPTY
71438: LIST
71439: PPUSH
71440: CALL_OW 446
71444: GO 71368
71446: POP
71447: POP
// end ;
71448: LD_VAR 0 3
71452: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71453: LD_INT 0
71455: PPUSH
71456: PPUSH
71457: PPUSH
71458: PPUSH
71459: PPUSH
71460: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
71461: LD_VAR 0 1
71465: NOT
71466: PUSH
71467: LD_VAR 0 1
71471: PPUSH
71472: CALL_OW 263
71476: PUSH
71477: LD_INT 2
71479: NONEQUAL
71480: OR
71481: IFFALSE 71485
// exit ;
71483: GO 71801
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71485: LD_ADDR_VAR 0 6
71489: PUSH
71490: LD_INT 22
71492: PUSH
71493: LD_VAR 0 1
71497: PPUSH
71498: CALL_OW 255
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: PUSH
71510: LD_INT 30
71512: PUSH
71513: LD_INT 36
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 34
71522: PUSH
71523: LD_INT 31
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: LIST
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PPUSH
71539: CALL_OW 69
71543: ST_TO_ADDR
// if not tmp then
71544: LD_VAR 0 6
71548: NOT
71549: IFFALSE 71553
// exit ;
71551: GO 71801
// result := [ ] ;
71553: LD_ADDR_VAR 0 2
71557: PUSH
71558: EMPTY
71559: ST_TO_ADDR
// for i in tmp do
71560: LD_ADDR_VAR 0 3
71564: PUSH
71565: LD_VAR 0 6
71569: PUSH
71570: FOR_IN
71571: IFFALSE 71642
// begin t := UnitsInside ( i ) ;
71573: LD_ADDR_VAR 0 4
71577: PUSH
71578: LD_VAR 0 3
71582: PPUSH
71583: CALL_OW 313
71587: ST_TO_ADDR
// if t then
71588: LD_VAR 0 4
71592: IFFALSE 71640
// for j in t do
71594: LD_ADDR_VAR 0 7
71598: PUSH
71599: LD_VAR 0 4
71603: PUSH
71604: FOR_IN
71605: IFFALSE 71638
// result := Replace ( result , result + 1 , j ) ;
71607: LD_ADDR_VAR 0 2
71611: PUSH
71612: LD_VAR 0 2
71616: PPUSH
71617: LD_VAR 0 2
71621: PUSH
71622: LD_INT 1
71624: PLUS
71625: PPUSH
71626: LD_VAR 0 7
71630: PPUSH
71631: CALL_OW 1
71635: ST_TO_ADDR
71636: GO 71604
71638: POP
71639: POP
// end ;
71640: GO 71570
71642: POP
71643: POP
// if not result then
71644: LD_VAR 0 2
71648: NOT
71649: IFFALSE 71653
// exit ;
71651: GO 71801
// mech := result [ 1 ] ;
71653: LD_ADDR_VAR 0 5
71657: PUSH
71658: LD_VAR 0 2
71662: PUSH
71663: LD_INT 1
71665: ARRAY
71666: ST_TO_ADDR
// if result > 1 then
71667: LD_VAR 0 2
71671: PUSH
71672: LD_INT 1
71674: GREATER
71675: IFFALSE 71787
// begin for i = 2 to result do
71677: LD_ADDR_VAR 0 3
71681: PUSH
71682: DOUBLE
71683: LD_INT 2
71685: DEC
71686: ST_TO_ADDR
71687: LD_VAR 0 2
71691: PUSH
71692: FOR_TO
71693: IFFALSE 71785
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71695: LD_ADDR_VAR 0 4
71699: PUSH
71700: LD_VAR 0 2
71704: PUSH
71705: LD_VAR 0 3
71709: ARRAY
71710: PPUSH
71711: LD_INT 3
71713: PPUSH
71714: CALL_OW 259
71718: PUSH
71719: LD_VAR 0 2
71723: PUSH
71724: LD_VAR 0 3
71728: ARRAY
71729: PPUSH
71730: CALL_OW 432
71734: MINUS
71735: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71736: LD_VAR 0 4
71740: PUSH
71741: LD_VAR 0 5
71745: PPUSH
71746: LD_INT 3
71748: PPUSH
71749: CALL_OW 259
71753: PUSH
71754: LD_VAR 0 5
71758: PPUSH
71759: CALL_OW 432
71763: MINUS
71764: GREATEREQUAL
71765: IFFALSE 71783
// mech := result [ i ] ;
71767: LD_ADDR_VAR 0 5
71771: PUSH
71772: LD_VAR 0 2
71776: PUSH
71777: LD_VAR 0 3
71781: ARRAY
71782: ST_TO_ADDR
// end ;
71783: GO 71692
71785: POP
71786: POP
// end ; ComLinkTo ( vehicle , mech ) ;
71787: LD_VAR 0 1
71791: PPUSH
71792: LD_VAR 0 5
71796: PPUSH
71797: CALL_OW 135
// end ;
71801: LD_VAR 0 2
71805: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71806: LD_INT 0
71808: PPUSH
71809: PPUSH
71810: PPUSH
71811: PPUSH
71812: PPUSH
71813: PPUSH
71814: PPUSH
71815: PPUSH
71816: PPUSH
71817: PPUSH
71818: PPUSH
71819: PPUSH
71820: PPUSH
// result := [ ] ;
71821: LD_ADDR_VAR 0 7
71825: PUSH
71826: EMPTY
71827: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71828: LD_VAR 0 1
71832: PPUSH
71833: CALL_OW 266
71837: PUSH
71838: LD_INT 0
71840: PUSH
71841: LD_INT 1
71843: PUSH
71844: EMPTY
71845: LIST
71846: LIST
71847: IN
71848: NOT
71849: IFFALSE 71853
// exit ;
71851: GO 73487
// if name then
71853: LD_VAR 0 3
71857: IFFALSE 71873
// SetBName ( base_dep , name ) ;
71859: LD_VAR 0 1
71863: PPUSH
71864: LD_VAR 0 3
71868: PPUSH
71869: CALL_OW 500
// base := GetBase ( base_dep ) ;
71873: LD_ADDR_VAR 0 15
71877: PUSH
71878: LD_VAR 0 1
71882: PPUSH
71883: CALL_OW 274
71887: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71888: LD_ADDR_VAR 0 16
71892: PUSH
71893: LD_VAR 0 1
71897: PPUSH
71898: CALL_OW 255
71902: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71903: LD_ADDR_VAR 0 17
71907: PUSH
71908: LD_VAR 0 1
71912: PPUSH
71913: CALL_OW 248
71917: ST_TO_ADDR
// if sources then
71918: LD_VAR 0 5
71922: IFFALSE 71969
// for i = 1 to 3 do
71924: LD_ADDR_VAR 0 8
71928: PUSH
71929: DOUBLE
71930: LD_INT 1
71932: DEC
71933: ST_TO_ADDR
71934: LD_INT 3
71936: PUSH
71937: FOR_TO
71938: IFFALSE 71967
// AddResourceType ( base , i , sources [ i ] ) ;
71940: LD_VAR 0 15
71944: PPUSH
71945: LD_VAR 0 8
71949: PPUSH
71950: LD_VAR 0 5
71954: PUSH
71955: LD_VAR 0 8
71959: ARRAY
71960: PPUSH
71961: CALL_OW 276
71965: GO 71937
71967: POP
71968: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
71969: LD_ADDR_VAR 0 18
71973: PUSH
71974: LD_VAR 0 15
71978: PPUSH
71979: LD_VAR 0 2
71983: PPUSH
71984: LD_INT 1
71986: PPUSH
71987: CALL 71230 0 3
71991: ST_TO_ADDR
// InitHc ;
71992: CALL_OW 19
// InitUc ;
71996: CALL_OW 18
// uc_side := side ;
72000: LD_ADDR_OWVAR 20
72004: PUSH
72005: LD_VAR 0 16
72009: ST_TO_ADDR
// uc_nation := nation ;
72010: LD_ADDR_OWVAR 21
72014: PUSH
72015: LD_VAR 0 17
72019: ST_TO_ADDR
// if buildings then
72020: LD_VAR 0 18
72024: IFFALSE 73346
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
72026: LD_ADDR_VAR 0 19
72030: PUSH
72031: LD_VAR 0 18
72035: PPUSH
72036: LD_INT 2
72038: PUSH
72039: LD_INT 30
72041: PUSH
72042: LD_INT 29
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 30
72051: PUSH
72052: LD_INT 30
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: LIST
72063: PPUSH
72064: CALL_OW 72
72068: ST_TO_ADDR
// if tmp then
72069: LD_VAR 0 19
72073: IFFALSE 72121
// for i in tmp do
72075: LD_ADDR_VAR 0 8
72079: PUSH
72080: LD_VAR 0 19
72084: PUSH
72085: FOR_IN
72086: IFFALSE 72119
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
72088: LD_VAR 0 8
72092: PPUSH
72093: CALL_OW 250
72097: PPUSH
72098: LD_VAR 0 8
72102: PPUSH
72103: CALL_OW 251
72107: PPUSH
72108: LD_VAR 0 16
72112: PPUSH
72113: CALL_OW 441
72117: GO 72085
72119: POP
72120: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72121: LD_VAR 0 18
72125: PPUSH
72126: LD_INT 2
72128: PUSH
72129: LD_INT 30
72131: PUSH
72132: LD_INT 32
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 30
72141: PUSH
72142: LD_INT 33
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: LIST
72153: PPUSH
72154: CALL_OW 72
72158: IFFALSE 72246
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72160: LD_ADDR_VAR 0 8
72164: PUSH
72165: LD_VAR 0 18
72169: PPUSH
72170: LD_INT 2
72172: PUSH
72173: LD_INT 30
72175: PUSH
72176: LD_INT 32
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 30
72185: PUSH
72186: LD_INT 33
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: LIST
72197: PPUSH
72198: CALL_OW 72
72202: PUSH
72203: FOR_IN
72204: IFFALSE 72244
// begin if not GetBWeapon ( i ) then
72206: LD_VAR 0 8
72210: PPUSH
72211: CALL_OW 269
72215: NOT
72216: IFFALSE 72242
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72218: LD_VAR 0 8
72222: PPUSH
72223: LD_VAR 0 8
72227: PPUSH
72228: LD_VAR 0 2
72232: PPUSH
72233: CALL 73492 0 2
72237: PPUSH
72238: CALL_OW 431
// end ;
72242: GO 72203
72244: POP
72245: POP
// end ; for i = 1 to personel do
72246: LD_ADDR_VAR 0 8
72250: PUSH
72251: DOUBLE
72252: LD_INT 1
72254: DEC
72255: ST_TO_ADDR
72256: LD_VAR 0 6
72260: PUSH
72261: FOR_TO
72262: IFFALSE 73326
// begin if i > 4 then
72264: LD_VAR 0 8
72268: PUSH
72269: LD_INT 4
72271: GREATER
72272: IFFALSE 72276
// break ;
72274: GO 73326
// case i of 1 :
72276: LD_VAR 0 8
72280: PUSH
72281: LD_INT 1
72283: DOUBLE
72284: EQUAL
72285: IFTRUE 72289
72287: GO 72369
72289: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72290: LD_ADDR_VAR 0 12
72294: PUSH
72295: LD_VAR 0 18
72299: PPUSH
72300: LD_INT 22
72302: PUSH
72303: LD_VAR 0 16
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 58
72314: PUSH
72315: EMPTY
72316: LIST
72317: PUSH
72318: LD_INT 2
72320: PUSH
72321: LD_INT 30
72323: PUSH
72324: LD_INT 32
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 30
72333: PUSH
72334: LD_INT 4
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 30
72343: PUSH
72344: LD_INT 5
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: EMPTY
72352: LIST
72353: LIST
72354: LIST
72355: LIST
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: LIST
72361: PPUSH
72362: CALL_OW 72
72366: ST_TO_ADDR
72367: GO 72591
72369: LD_INT 2
72371: DOUBLE
72372: EQUAL
72373: IFTRUE 72377
72375: GO 72439
72377: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72378: LD_ADDR_VAR 0 12
72382: PUSH
72383: LD_VAR 0 18
72387: PPUSH
72388: LD_INT 22
72390: PUSH
72391: LD_VAR 0 16
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PUSH
72400: LD_INT 2
72402: PUSH
72403: LD_INT 30
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 30
72415: PUSH
72416: LD_INT 1
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: LIST
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PPUSH
72432: CALL_OW 72
72436: ST_TO_ADDR
72437: GO 72591
72439: LD_INT 3
72441: DOUBLE
72442: EQUAL
72443: IFTRUE 72447
72445: GO 72509
72447: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72448: LD_ADDR_VAR 0 12
72452: PUSH
72453: LD_VAR 0 18
72457: PPUSH
72458: LD_INT 22
72460: PUSH
72461: LD_VAR 0 16
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 2
72472: PUSH
72473: LD_INT 30
72475: PUSH
72476: LD_INT 2
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 30
72485: PUSH
72486: LD_INT 3
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: LIST
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PPUSH
72502: CALL_OW 72
72506: ST_TO_ADDR
72507: GO 72591
72509: LD_INT 4
72511: DOUBLE
72512: EQUAL
72513: IFTRUE 72517
72515: GO 72590
72517: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72518: LD_ADDR_VAR 0 12
72522: PUSH
72523: LD_VAR 0 18
72527: PPUSH
72528: LD_INT 22
72530: PUSH
72531: LD_VAR 0 16
72535: PUSH
72536: EMPTY
72537: LIST
72538: LIST
72539: PUSH
72540: LD_INT 2
72542: PUSH
72543: LD_INT 30
72545: PUSH
72546: LD_INT 6
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 30
72555: PUSH
72556: LD_INT 7
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 30
72565: PUSH
72566: LD_INT 8
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: LIST
72577: LIST
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PPUSH
72583: CALL_OW 72
72587: ST_TO_ADDR
72588: GO 72591
72590: POP
// if i = 1 then
72591: LD_VAR 0 8
72595: PUSH
72596: LD_INT 1
72598: EQUAL
72599: IFFALSE 72710
// begin tmp := [ ] ;
72601: LD_ADDR_VAR 0 19
72605: PUSH
72606: EMPTY
72607: ST_TO_ADDR
// for j in f do
72608: LD_ADDR_VAR 0 9
72612: PUSH
72613: LD_VAR 0 12
72617: PUSH
72618: FOR_IN
72619: IFFALSE 72692
// if GetBType ( j ) = b_bunker then
72621: LD_VAR 0 9
72625: PPUSH
72626: CALL_OW 266
72630: PUSH
72631: LD_INT 32
72633: EQUAL
72634: IFFALSE 72661
// tmp := Insert ( tmp , 1 , j ) else
72636: LD_ADDR_VAR 0 19
72640: PUSH
72641: LD_VAR 0 19
72645: PPUSH
72646: LD_INT 1
72648: PPUSH
72649: LD_VAR 0 9
72653: PPUSH
72654: CALL_OW 2
72658: ST_TO_ADDR
72659: GO 72690
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72661: LD_ADDR_VAR 0 19
72665: PUSH
72666: LD_VAR 0 19
72670: PPUSH
72671: LD_VAR 0 19
72675: PUSH
72676: LD_INT 1
72678: PLUS
72679: PPUSH
72680: LD_VAR 0 9
72684: PPUSH
72685: CALL_OW 2
72689: ST_TO_ADDR
72690: GO 72618
72692: POP
72693: POP
// if tmp then
72694: LD_VAR 0 19
72698: IFFALSE 72710
// f := tmp ;
72700: LD_ADDR_VAR 0 12
72704: PUSH
72705: LD_VAR 0 19
72709: ST_TO_ADDR
// end ; x := personel [ i ] ;
72710: LD_ADDR_VAR 0 13
72714: PUSH
72715: LD_VAR 0 6
72719: PUSH
72720: LD_VAR 0 8
72724: ARRAY
72725: ST_TO_ADDR
// if x = - 1 then
72726: LD_VAR 0 13
72730: PUSH
72731: LD_INT 1
72733: NEG
72734: EQUAL
72735: IFFALSE 72944
// begin for j in f do
72737: LD_ADDR_VAR 0 9
72741: PUSH
72742: LD_VAR 0 12
72746: PUSH
72747: FOR_IN
72748: IFFALSE 72940
// repeat InitHc ;
72750: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72754: LD_VAR 0 9
72758: PPUSH
72759: CALL_OW 266
72763: PUSH
72764: LD_INT 5
72766: EQUAL
72767: IFFALSE 72837
// begin if UnitsInside ( j ) < 3 then
72769: LD_VAR 0 9
72773: PPUSH
72774: CALL_OW 313
72778: PUSH
72779: LD_INT 3
72781: LESS
72782: IFFALSE 72818
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72784: LD_INT 0
72786: PPUSH
72787: LD_INT 5
72789: PUSH
72790: LD_INT 8
72792: PUSH
72793: LD_INT 9
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: LIST
72800: PUSH
72801: LD_VAR 0 17
72805: ARRAY
72806: PPUSH
72807: LD_VAR 0 4
72811: PPUSH
72812: CALL_OW 380
72816: GO 72835
// PrepareHuman ( false , i , skill ) ;
72818: LD_INT 0
72820: PPUSH
72821: LD_VAR 0 8
72825: PPUSH
72826: LD_VAR 0 4
72830: PPUSH
72831: CALL_OW 380
// end else
72835: GO 72854
// PrepareHuman ( false , i , skill ) ;
72837: LD_INT 0
72839: PPUSH
72840: LD_VAR 0 8
72844: PPUSH
72845: LD_VAR 0 4
72849: PPUSH
72850: CALL_OW 380
// un := CreateHuman ;
72854: LD_ADDR_VAR 0 14
72858: PUSH
72859: CALL_OW 44
72863: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72864: LD_ADDR_VAR 0 7
72868: PUSH
72869: LD_VAR 0 7
72873: PPUSH
72874: LD_INT 1
72876: PPUSH
72877: LD_VAR 0 14
72881: PPUSH
72882: CALL_OW 2
72886: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72887: LD_VAR 0 14
72891: PPUSH
72892: LD_VAR 0 9
72896: PPUSH
72897: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72901: LD_VAR 0 9
72905: PPUSH
72906: CALL_OW 313
72910: PUSH
72911: LD_INT 6
72913: EQUAL
72914: PUSH
72915: LD_VAR 0 9
72919: PPUSH
72920: CALL_OW 266
72924: PUSH
72925: LD_INT 32
72927: PUSH
72928: LD_INT 31
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: IN
72935: OR
72936: IFFALSE 72750
72938: GO 72747
72940: POP
72941: POP
// end else
72942: GO 73324
// for j = 1 to x do
72944: LD_ADDR_VAR 0 9
72948: PUSH
72949: DOUBLE
72950: LD_INT 1
72952: DEC
72953: ST_TO_ADDR
72954: LD_VAR 0 13
72958: PUSH
72959: FOR_TO
72960: IFFALSE 73322
// begin InitHc ;
72962: CALL_OW 19
// if not f then
72966: LD_VAR 0 12
72970: NOT
72971: IFFALSE 73060
// begin PrepareHuman ( false , i , skill ) ;
72973: LD_INT 0
72975: PPUSH
72976: LD_VAR 0 8
72980: PPUSH
72981: LD_VAR 0 4
72985: PPUSH
72986: CALL_OW 380
// un := CreateHuman ;
72990: LD_ADDR_VAR 0 14
72994: PUSH
72995: CALL_OW 44
72999: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73000: LD_ADDR_VAR 0 7
73004: PUSH
73005: LD_VAR 0 7
73009: PPUSH
73010: LD_INT 1
73012: PPUSH
73013: LD_VAR 0 14
73017: PPUSH
73018: CALL_OW 2
73022: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73023: LD_VAR 0 14
73027: PPUSH
73028: LD_VAR 0 1
73032: PPUSH
73033: CALL_OW 250
73037: PPUSH
73038: LD_VAR 0 1
73042: PPUSH
73043: CALL_OW 251
73047: PPUSH
73048: LD_INT 10
73050: PPUSH
73051: LD_INT 0
73053: PPUSH
73054: CALL_OW 50
// continue ;
73058: GO 72959
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
73060: LD_VAR 0 12
73064: PUSH
73065: LD_INT 1
73067: ARRAY
73068: PPUSH
73069: CALL_OW 313
73073: PUSH
73074: LD_VAR 0 12
73078: PUSH
73079: LD_INT 1
73081: ARRAY
73082: PPUSH
73083: CALL_OW 266
73087: PUSH
73088: LD_INT 32
73090: PUSH
73091: LD_INT 31
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: IN
73098: AND
73099: PUSH
73100: LD_VAR 0 12
73104: PUSH
73105: LD_INT 1
73107: ARRAY
73108: PPUSH
73109: CALL_OW 313
73113: PUSH
73114: LD_INT 6
73116: EQUAL
73117: OR
73118: IFFALSE 73138
// f := Delete ( f , 1 ) ;
73120: LD_ADDR_VAR 0 12
73124: PUSH
73125: LD_VAR 0 12
73129: PPUSH
73130: LD_INT 1
73132: PPUSH
73133: CALL_OW 3
73137: ST_TO_ADDR
// if not f then
73138: LD_VAR 0 12
73142: NOT
73143: IFFALSE 73161
// begin x := x + 2 ;
73145: LD_ADDR_VAR 0 13
73149: PUSH
73150: LD_VAR 0 13
73154: PUSH
73155: LD_INT 2
73157: PLUS
73158: ST_TO_ADDR
// continue ;
73159: GO 72959
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73161: LD_VAR 0 12
73165: PUSH
73166: LD_INT 1
73168: ARRAY
73169: PPUSH
73170: CALL_OW 266
73174: PUSH
73175: LD_INT 5
73177: EQUAL
73178: IFFALSE 73252
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73180: LD_VAR 0 12
73184: PUSH
73185: LD_INT 1
73187: ARRAY
73188: PPUSH
73189: CALL_OW 313
73193: PUSH
73194: LD_INT 3
73196: LESS
73197: IFFALSE 73233
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73199: LD_INT 0
73201: PPUSH
73202: LD_INT 5
73204: PUSH
73205: LD_INT 8
73207: PUSH
73208: LD_INT 9
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: LIST
73215: PUSH
73216: LD_VAR 0 17
73220: ARRAY
73221: PPUSH
73222: LD_VAR 0 4
73226: PPUSH
73227: CALL_OW 380
73231: GO 73250
// PrepareHuman ( false , i , skill ) ;
73233: LD_INT 0
73235: PPUSH
73236: LD_VAR 0 8
73240: PPUSH
73241: LD_VAR 0 4
73245: PPUSH
73246: CALL_OW 380
// end else
73250: GO 73269
// PrepareHuman ( false , i , skill ) ;
73252: LD_INT 0
73254: PPUSH
73255: LD_VAR 0 8
73259: PPUSH
73260: LD_VAR 0 4
73264: PPUSH
73265: CALL_OW 380
// un := CreateHuman ;
73269: LD_ADDR_VAR 0 14
73273: PUSH
73274: CALL_OW 44
73278: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73279: LD_ADDR_VAR 0 7
73283: PUSH
73284: LD_VAR 0 7
73288: PPUSH
73289: LD_INT 1
73291: PPUSH
73292: LD_VAR 0 14
73296: PPUSH
73297: CALL_OW 2
73301: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73302: LD_VAR 0 14
73306: PPUSH
73307: LD_VAR 0 12
73311: PUSH
73312: LD_INT 1
73314: ARRAY
73315: PPUSH
73316: CALL_OW 52
// end ;
73320: GO 72959
73322: POP
73323: POP
// end ;
73324: GO 72261
73326: POP
73327: POP
// result := result ^ buildings ;
73328: LD_ADDR_VAR 0 7
73332: PUSH
73333: LD_VAR 0 7
73337: PUSH
73338: LD_VAR 0 18
73342: ADD
73343: ST_TO_ADDR
// end else
73344: GO 73487
// begin for i = 1 to personel do
73346: LD_ADDR_VAR 0 8
73350: PUSH
73351: DOUBLE
73352: LD_INT 1
73354: DEC
73355: ST_TO_ADDR
73356: LD_VAR 0 6
73360: PUSH
73361: FOR_TO
73362: IFFALSE 73485
// begin if i > 4 then
73364: LD_VAR 0 8
73368: PUSH
73369: LD_INT 4
73371: GREATER
73372: IFFALSE 73376
// break ;
73374: GO 73485
// x := personel [ i ] ;
73376: LD_ADDR_VAR 0 13
73380: PUSH
73381: LD_VAR 0 6
73385: PUSH
73386: LD_VAR 0 8
73390: ARRAY
73391: ST_TO_ADDR
// if x = - 1 then
73392: LD_VAR 0 13
73396: PUSH
73397: LD_INT 1
73399: NEG
73400: EQUAL
73401: IFFALSE 73405
// continue ;
73403: GO 73361
// PrepareHuman ( false , i , skill ) ;
73405: LD_INT 0
73407: PPUSH
73408: LD_VAR 0 8
73412: PPUSH
73413: LD_VAR 0 4
73417: PPUSH
73418: CALL_OW 380
// un := CreateHuman ;
73422: LD_ADDR_VAR 0 14
73426: PUSH
73427: CALL_OW 44
73431: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73432: LD_VAR 0 14
73436: PPUSH
73437: LD_VAR 0 1
73441: PPUSH
73442: CALL_OW 250
73446: PPUSH
73447: LD_VAR 0 1
73451: PPUSH
73452: CALL_OW 251
73456: PPUSH
73457: LD_INT 10
73459: PPUSH
73460: LD_INT 0
73462: PPUSH
73463: CALL_OW 50
// result := result ^ un ;
73467: LD_ADDR_VAR 0 7
73471: PUSH
73472: LD_VAR 0 7
73476: PUSH
73477: LD_VAR 0 14
73481: ADD
73482: ST_TO_ADDR
// end ;
73483: GO 73361
73485: POP
73486: POP
// end ; end ;
73487: LD_VAR 0 7
73491: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73492: LD_INT 0
73494: PPUSH
73495: PPUSH
73496: PPUSH
73497: PPUSH
73498: PPUSH
73499: PPUSH
73500: PPUSH
73501: PPUSH
73502: PPUSH
73503: PPUSH
73504: PPUSH
73505: PPUSH
73506: PPUSH
73507: PPUSH
73508: PPUSH
73509: PPUSH
// result := false ;
73510: LD_ADDR_VAR 0 3
73514: PUSH
73515: LD_INT 0
73517: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73518: LD_VAR 0 1
73522: NOT
73523: PUSH
73524: LD_VAR 0 1
73528: PPUSH
73529: CALL_OW 266
73533: PUSH
73534: LD_INT 32
73536: PUSH
73537: LD_INT 33
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: IN
73544: NOT
73545: OR
73546: IFFALSE 73550
// exit ;
73548: GO 74659
// nat := GetNation ( tower ) ;
73550: LD_ADDR_VAR 0 12
73554: PUSH
73555: LD_VAR 0 1
73559: PPUSH
73560: CALL_OW 248
73564: ST_TO_ADDR
// side := GetSide ( tower ) ;
73565: LD_ADDR_VAR 0 16
73569: PUSH
73570: LD_VAR 0 1
73574: PPUSH
73575: CALL_OW 255
73579: ST_TO_ADDR
// x := GetX ( tower ) ;
73580: LD_ADDR_VAR 0 10
73584: PUSH
73585: LD_VAR 0 1
73589: PPUSH
73590: CALL_OW 250
73594: ST_TO_ADDR
// y := GetY ( tower ) ;
73595: LD_ADDR_VAR 0 11
73599: PUSH
73600: LD_VAR 0 1
73604: PPUSH
73605: CALL_OW 251
73609: ST_TO_ADDR
// if not x or not y then
73610: LD_VAR 0 10
73614: NOT
73615: PUSH
73616: LD_VAR 0 11
73620: NOT
73621: OR
73622: IFFALSE 73626
// exit ;
73624: GO 74659
// weapon := 0 ;
73626: LD_ADDR_VAR 0 18
73630: PUSH
73631: LD_INT 0
73633: ST_TO_ADDR
// fac_list := [ ] ;
73634: LD_ADDR_VAR 0 17
73638: PUSH
73639: EMPTY
73640: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
73641: LD_ADDR_VAR 0 6
73645: PUSH
73646: LD_VAR 0 1
73650: PPUSH
73651: CALL_OW 274
73655: PPUSH
73656: LD_VAR 0 2
73660: PPUSH
73661: LD_INT 0
73663: PPUSH
73664: CALL 71230 0 3
73668: PPUSH
73669: LD_INT 30
73671: PUSH
73672: LD_INT 3
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PPUSH
73679: CALL_OW 72
73683: ST_TO_ADDR
// if not factories then
73684: LD_VAR 0 6
73688: NOT
73689: IFFALSE 73693
// exit ;
73691: GO 74659
// for i in factories do
73693: LD_ADDR_VAR 0 8
73697: PUSH
73698: LD_VAR 0 6
73702: PUSH
73703: FOR_IN
73704: IFFALSE 73729
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73706: LD_ADDR_VAR 0 17
73710: PUSH
73711: LD_VAR 0 17
73715: PUSH
73716: LD_VAR 0 8
73720: PPUSH
73721: CALL_OW 478
73725: UNION
73726: ST_TO_ADDR
73727: GO 73703
73729: POP
73730: POP
// if not fac_list then
73731: LD_VAR 0 17
73735: NOT
73736: IFFALSE 73740
// exit ;
73738: GO 74659
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73740: LD_ADDR_VAR 0 5
73744: PUSH
73745: LD_INT 4
73747: PUSH
73748: LD_INT 5
73750: PUSH
73751: LD_INT 9
73753: PUSH
73754: LD_INT 10
73756: PUSH
73757: LD_INT 6
73759: PUSH
73760: LD_INT 7
73762: PUSH
73763: LD_INT 11
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: LIST
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 27
73777: PUSH
73778: LD_INT 28
73780: PUSH
73781: LD_INT 26
73783: PUSH
73784: LD_INT 30
73786: PUSH
73787: EMPTY
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 43
73795: PUSH
73796: LD_INT 44
73798: PUSH
73799: LD_INT 46
73801: PUSH
73802: LD_INT 45
73804: PUSH
73805: LD_INT 47
73807: PUSH
73808: LD_INT 49
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: PUSH
73819: EMPTY
73820: LIST
73821: LIST
73822: LIST
73823: PUSH
73824: LD_VAR 0 12
73828: ARRAY
73829: ST_TO_ADDR
// list := list isect fac_list ;
73830: LD_ADDR_VAR 0 5
73834: PUSH
73835: LD_VAR 0 5
73839: PUSH
73840: LD_VAR 0 17
73844: ISECT
73845: ST_TO_ADDR
// if not list then
73846: LD_VAR 0 5
73850: NOT
73851: IFFALSE 73855
// exit ;
73853: GO 74659
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73855: LD_VAR 0 12
73859: PUSH
73860: LD_INT 3
73862: EQUAL
73863: PUSH
73864: LD_INT 49
73866: PUSH
73867: LD_VAR 0 5
73871: IN
73872: AND
73873: PUSH
73874: LD_INT 31
73876: PPUSH
73877: LD_VAR 0 16
73881: PPUSH
73882: CALL_OW 321
73886: PUSH
73887: LD_INT 2
73889: EQUAL
73890: AND
73891: IFFALSE 73951
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73893: LD_INT 22
73895: PUSH
73896: LD_VAR 0 16
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 35
73907: PUSH
73908: LD_INT 49
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 91
73917: PUSH
73918: LD_VAR 0 1
73922: PUSH
73923: LD_INT 10
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: LIST
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: PPUSH
73936: CALL_OW 69
73940: NOT
73941: IFFALSE 73951
// weapon := ru_time_lapser ;
73943: LD_ADDR_VAR 0 18
73947: PUSH
73948: LD_INT 49
73950: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73951: LD_VAR 0 12
73955: PUSH
73956: LD_INT 1
73958: PUSH
73959: LD_INT 2
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: IN
73966: PUSH
73967: LD_INT 11
73969: PUSH
73970: LD_VAR 0 5
73974: IN
73975: PUSH
73976: LD_INT 30
73978: PUSH
73979: LD_VAR 0 5
73983: IN
73984: OR
73985: AND
73986: PUSH
73987: LD_INT 6
73989: PPUSH
73990: LD_VAR 0 16
73994: PPUSH
73995: CALL_OW 321
73999: PUSH
74000: LD_INT 2
74002: EQUAL
74003: AND
74004: IFFALSE 74169
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
74006: LD_INT 22
74008: PUSH
74009: LD_VAR 0 16
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: LD_INT 2
74020: PUSH
74021: LD_INT 35
74023: PUSH
74024: LD_INT 11
74026: PUSH
74027: EMPTY
74028: LIST
74029: LIST
74030: PUSH
74031: LD_INT 35
74033: PUSH
74034: LD_INT 30
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 91
74048: PUSH
74049: LD_VAR 0 1
74053: PUSH
74054: LD_INT 18
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: LIST
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: LIST
74066: PPUSH
74067: CALL_OW 69
74071: NOT
74072: PUSH
74073: LD_INT 22
74075: PUSH
74076: LD_VAR 0 16
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 2
74087: PUSH
74088: LD_INT 30
74090: PUSH
74091: LD_INT 32
74093: PUSH
74094: EMPTY
74095: LIST
74096: LIST
74097: PUSH
74098: LD_INT 30
74100: PUSH
74101: LD_INT 33
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: LIST
74112: PUSH
74113: LD_INT 91
74115: PUSH
74116: LD_VAR 0 1
74120: PUSH
74121: LD_INT 12
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: LIST
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: LIST
74133: PUSH
74134: EMPTY
74135: LIST
74136: PPUSH
74137: CALL_OW 69
74141: PUSH
74142: LD_INT 2
74144: GREATER
74145: AND
74146: IFFALSE 74169
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74148: LD_ADDR_VAR 0 18
74152: PUSH
74153: LD_INT 11
74155: PUSH
74156: LD_INT 30
74158: PUSH
74159: EMPTY
74160: LIST
74161: LIST
74162: PUSH
74163: LD_VAR 0 12
74167: ARRAY
74168: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74169: LD_VAR 0 18
74173: NOT
74174: PUSH
74175: LD_INT 40
74177: PPUSH
74178: LD_VAR 0 16
74182: PPUSH
74183: CALL_OW 321
74187: PUSH
74188: LD_INT 2
74190: EQUAL
74191: AND
74192: PUSH
74193: LD_INT 7
74195: PUSH
74196: LD_VAR 0 5
74200: IN
74201: PUSH
74202: LD_INT 28
74204: PUSH
74205: LD_VAR 0 5
74209: IN
74210: OR
74211: PUSH
74212: LD_INT 45
74214: PUSH
74215: LD_VAR 0 5
74219: IN
74220: OR
74221: AND
74222: IFFALSE 74476
// begin hex := GetHexInfo ( x , y ) ;
74224: LD_ADDR_VAR 0 4
74228: PUSH
74229: LD_VAR 0 10
74233: PPUSH
74234: LD_VAR 0 11
74238: PPUSH
74239: CALL_OW 546
74243: ST_TO_ADDR
// if hex [ 1 ] then
74244: LD_VAR 0 4
74248: PUSH
74249: LD_INT 1
74251: ARRAY
74252: IFFALSE 74256
// exit ;
74254: GO 74659
// height := hex [ 2 ] ;
74256: LD_ADDR_VAR 0 15
74260: PUSH
74261: LD_VAR 0 4
74265: PUSH
74266: LD_INT 2
74268: ARRAY
74269: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74270: LD_ADDR_VAR 0 14
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: LD_INT 2
74280: PUSH
74281: LD_INT 3
74283: PUSH
74284: LD_INT 5
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: ST_TO_ADDR
// for i in tmp do
74293: LD_ADDR_VAR 0 8
74297: PUSH
74298: LD_VAR 0 14
74302: PUSH
74303: FOR_IN
74304: IFFALSE 74474
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74306: LD_ADDR_VAR 0 9
74310: PUSH
74311: LD_VAR 0 10
74315: PPUSH
74316: LD_VAR 0 8
74320: PPUSH
74321: LD_INT 5
74323: PPUSH
74324: CALL_OW 272
74328: PUSH
74329: LD_VAR 0 11
74333: PPUSH
74334: LD_VAR 0 8
74338: PPUSH
74339: LD_INT 5
74341: PPUSH
74342: CALL_OW 273
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74351: LD_VAR 0 9
74355: PUSH
74356: LD_INT 1
74358: ARRAY
74359: PPUSH
74360: LD_VAR 0 9
74364: PUSH
74365: LD_INT 2
74367: ARRAY
74368: PPUSH
74369: CALL_OW 488
74373: IFFALSE 74472
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74375: LD_ADDR_VAR 0 4
74379: PUSH
74380: LD_VAR 0 9
74384: PUSH
74385: LD_INT 1
74387: ARRAY
74388: PPUSH
74389: LD_VAR 0 9
74393: PUSH
74394: LD_INT 2
74396: ARRAY
74397: PPUSH
74398: CALL_OW 546
74402: ST_TO_ADDR
// if hex [ 1 ] then
74403: LD_VAR 0 4
74407: PUSH
74408: LD_INT 1
74410: ARRAY
74411: IFFALSE 74415
// continue ;
74413: GO 74303
// h := hex [ 2 ] ;
74415: LD_ADDR_VAR 0 13
74419: PUSH
74420: LD_VAR 0 4
74424: PUSH
74425: LD_INT 2
74427: ARRAY
74428: ST_TO_ADDR
// if h + 7 < height then
74429: LD_VAR 0 13
74433: PUSH
74434: LD_INT 7
74436: PLUS
74437: PUSH
74438: LD_VAR 0 15
74442: LESS
74443: IFFALSE 74472
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74445: LD_ADDR_VAR 0 18
74449: PUSH
74450: LD_INT 7
74452: PUSH
74453: LD_INT 28
74455: PUSH
74456: LD_INT 45
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: LIST
74463: PUSH
74464: LD_VAR 0 12
74468: ARRAY
74469: ST_TO_ADDR
// break ;
74470: GO 74474
// end ; end ; end ;
74472: GO 74303
74474: POP
74475: POP
// end ; if not weapon then
74476: LD_VAR 0 18
74480: NOT
74481: IFFALSE 74541
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74483: LD_ADDR_VAR 0 5
74487: PUSH
74488: LD_VAR 0 5
74492: PUSH
74493: LD_INT 11
74495: PUSH
74496: LD_INT 30
74498: PUSH
74499: LD_INT 49
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: LIST
74506: DIFF
74507: ST_TO_ADDR
// if not list then
74508: LD_VAR 0 5
74512: NOT
74513: IFFALSE 74517
// exit ;
74515: GO 74659
// weapon := list [ rand ( 1 , list ) ] ;
74517: LD_ADDR_VAR 0 18
74521: PUSH
74522: LD_VAR 0 5
74526: PUSH
74527: LD_INT 1
74529: PPUSH
74530: LD_VAR 0 5
74534: PPUSH
74535: CALL_OW 12
74539: ARRAY
74540: ST_TO_ADDR
// end ; if weapon then
74541: LD_VAR 0 18
74545: IFFALSE 74659
// begin tmp := CostOfWeapon ( weapon ) ;
74547: LD_ADDR_VAR 0 14
74551: PUSH
74552: LD_VAR 0 18
74556: PPUSH
74557: CALL_OW 451
74561: ST_TO_ADDR
// j := GetBase ( tower ) ;
74562: LD_ADDR_VAR 0 9
74566: PUSH
74567: LD_VAR 0 1
74571: PPUSH
74572: CALL_OW 274
74576: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74577: LD_VAR 0 9
74581: PPUSH
74582: LD_INT 1
74584: PPUSH
74585: CALL_OW 275
74589: PUSH
74590: LD_VAR 0 14
74594: PUSH
74595: LD_INT 1
74597: ARRAY
74598: GREATEREQUAL
74599: PUSH
74600: LD_VAR 0 9
74604: PPUSH
74605: LD_INT 2
74607: PPUSH
74608: CALL_OW 275
74612: PUSH
74613: LD_VAR 0 14
74617: PUSH
74618: LD_INT 2
74620: ARRAY
74621: GREATEREQUAL
74622: AND
74623: PUSH
74624: LD_VAR 0 9
74628: PPUSH
74629: LD_INT 3
74631: PPUSH
74632: CALL_OW 275
74636: PUSH
74637: LD_VAR 0 14
74641: PUSH
74642: LD_INT 3
74644: ARRAY
74645: GREATEREQUAL
74646: AND
74647: IFFALSE 74659
// result := weapon ;
74649: LD_ADDR_VAR 0 3
74653: PUSH
74654: LD_VAR 0 18
74658: ST_TO_ADDR
// end ; end ;
74659: LD_VAR 0 3
74663: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74664: LD_INT 0
74666: PPUSH
74667: PPUSH
// result := true ;
74668: LD_ADDR_VAR 0 3
74672: PUSH
74673: LD_INT 1
74675: ST_TO_ADDR
// if array1 = array2 then
74676: LD_VAR 0 1
74680: PUSH
74681: LD_VAR 0 2
74685: EQUAL
74686: IFFALSE 74746
// begin for i = 1 to array1 do
74688: LD_ADDR_VAR 0 4
74692: PUSH
74693: DOUBLE
74694: LD_INT 1
74696: DEC
74697: ST_TO_ADDR
74698: LD_VAR 0 1
74702: PUSH
74703: FOR_TO
74704: IFFALSE 74742
// if array1 [ i ] <> array2 [ i ] then
74706: LD_VAR 0 1
74710: PUSH
74711: LD_VAR 0 4
74715: ARRAY
74716: PUSH
74717: LD_VAR 0 2
74721: PUSH
74722: LD_VAR 0 4
74726: ARRAY
74727: NONEQUAL
74728: IFFALSE 74740
// begin result := false ;
74730: LD_ADDR_VAR 0 3
74734: PUSH
74735: LD_INT 0
74737: ST_TO_ADDR
// break ;
74738: GO 74742
// end ;
74740: GO 74703
74742: POP
74743: POP
// end else
74744: GO 74754
// result := false ;
74746: LD_ADDR_VAR 0 3
74750: PUSH
74751: LD_INT 0
74753: ST_TO_ADDR
// end ;
74754: LD_VAR 0 3
74758: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
74759: LD_INT 0
74761: PPUSH
74762: PPUSH
// if not array1 or not array2 then
74763: LD_VAR 0 1
74767: NOT
74768: PUSH
74769: LD_VAR 0 2
74773: NOT
74774: OR
74775: IFFALSE 74779
// exit ;
74777: GO 74843
// result := true ;
74779: LD_ADDR_VAR 0 3
74783: PUSH
74784: LD_INT 1
74786: ST_TO_ADDR
// for i = 1 to array1 do
74787: LD_ADDR_VAR 0 4
74791: PUSH
74792: DOUBLE
74793: LD_INT 1
74795: DEC
74796: ST_TO_ADDR
74797: LD_VAR 0 1
74801: PUSH
74802: FOR_TO
74803: IFFALSE 74841
// if array1 [ i ] <> array2 [ i ] then
74805: LD_VAR 0 1
74809: PUSH
74810: LD_VAR 0 4
74814: ARRAY
74815: PUSH
74816: LD_VAR 0 2
74820: PUSH
74821: LD_VAR 0 4
74825: ARRAY
74826: NONEQUAL
74827: IFFALSE 74839
// begin result := false ;
74829: LD_ADDR_VAR 0 3
74833: PUSH
74834: LD_INT 0
74836: ST_TO_ADDR
// break ;
74837: GO 74841
// end ;
74839: GO 74802
74841: POP
74842: POP
// end ;
74843: LD_VAR 0 3
74847: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74848: LD_INT 0
74850: PPUSH
74851: PPUSH
74852: PPUSH
// pom := GetBase ( fac ) ;
74853: LD_ADDR_VAR 0 5
74857: PUSH
74858: LD_VAR 0 1
74862: PPUSH
74863: CALL_OW 274
74867: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74868: LD_ADDR_VAR 0 4
74872: PUSH
74873: LD_VAR 0 2
74877: PUSH
74878: LD_INT 1
74880: ARRAY
74881: PPUSH
74882: LD_VAR 0 2
74886: PUSH
74887: LD_INT 2
74889: ARRAY
74890: PPUSH
74891: LD_VAR 0 2
74895: PUSH
74896: LD_INT 3
74898: ARRAY
74899: PPUSH
74900: LD_VAR 0 2
74904: PUSH
74905: LD_INT 4
74907: ARRAY
74908: PPUSH
74909: CALL_OW 449
74913: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74914: LD_ADDR_VAR 0 3
74918: PUSH
74919: LD_VAR 0 5
74923: PPUSH
74924: LD_INT 1
74926: PPUSH
74927: CALL_OW 275
74931: PUSH
74932: LD_VAR 0 4
74936: PUSH
74937: LD_INT 1
74939: ARRAY
74940: GREATEREQUAL
74941: PUSH
74942: LD_VAR 0 5
74946: PPUSH
74947: LD_INT 2
74949: PPUSH
74950: CALL_OW 275
74954: PUSH
74955: LD_VAR 0 4
74959: PUSH
74960: LD_INT 2
74962: ARRAY
74963: GREATEREQUAL
74964: AND
74965: PUSH
74966: LD_VAR 0 5
74970: PPUSH
74971: LD_INT 3
74973: PPUSH
74974: CALL_OW 275
74978: PUSH
74979: LD_VAR 0 4
74983: PUSH
74984: LD_INT 3
74986: ARRAY
74987: GREATEREQUAL
74988: AND
74989: ST_TO_ADDR
// end ;
74990: LD_VAR 0 3
74994: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74995: LD_INT 0
74997: PPUSH
74998: PPUSH
74999: PPUSH
75000: PPUSH
// pom := GetBase ( building ) ;
75001: LD_ADDR_VAR 0 3
75005: PUSH
75006: LD_VAR 0 1
75010: PPUSH
75011: CALL_OW 274
75015: ST_TO_ADDR
// if not pom then
75016: LD_VAR 0 3
75020: NOT
75021: IFFALSE 75025
// exit ;
75023: GO 75195
// btype := GetBType ( building ) ;
75025: LD_ADDR_VAR 0 5
75029: PUSH
75030: LD_VAR 0 1
75034: PPUSH
75035: CALL_OW 266
75039: ST_TO_ADDR
// if btype = b_armoury then
75040: LD_VAR 0 5
75044: PUSH
75045: LD_INT 4
75047: EQUAL
75048: IFFALSE 75058
// btype := b_barracks ;
75050: LD_ADDR_VAR 0 5
75054: PUSH
75055: LD_INT 5
75057: ST_TO_ADDR
// if btype = b_depot then
75058: LD_VAR 0 5
75062: PUSH
75063: LD_INT 0
75065: EQUAL
75066: IFFALSE 75076
// btype := b_warehouse ;
75068: LD_ADDR_VAR 0 5
75072: PUSH
75073: LD_INT 1
75075: ST_TO_ADDR
// if btype = b_workshop then
75076: LD_VAR 0 5
75080: PUSH
75081: LD_INT 2
75083: EQUAL
75084: IFFALSE 75094
// btype := b_factory ;
75086: LD_ADDR_VAR 0 5
75090: PUSH
75091: LD_INT 3
75093: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75094: LD_ADDR_VAR 0 4
75098: PUSH
75099: LD_VAR 0 5
75103: PPUSH
75104: LD_VAR 0 1
75108: PPUSH
75109: CALL_OW 248
75113: PPUSH
75114: CALL_OW 450
75118: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75119: LD_ADDR_VAR 0 2
75123: PUSH
75124: LD_VAR 0 3
75128: PPUSH
75129: LD_INT 1
75131: PPUSH
75132: CALL_OW 275
75136: PUSH
75137: LD_VAR 0 4
75141: PUSH
75142: LD_INT 1
75144: ARRAY
75145: GREATEREQUAL
75146: PUSH
75147: LD_VAR 0 3
75151: PPUSH
75152: LD_INT 2
75154: PPUSH
75155: CALL_OW 275
75159: PUSH
75160: LD_VAR 0 4
75164: PUSH
75165: LD_INT 2
75167: ARRAY
75168: GREATEREQUAL
75169: AND
75170: PUSH
75171: LD_VAR 0 3
75175: PPUSH
75176: LD_INT 3
75178: PPUSH
75179: CALL_OW 275
75183: PUSH
75184: LD_VAR 0 4
75188: PUSH
75189: LD_INT 3
75191: ARRAY
75192: GREATEREQUAL
75193: AND
75194: ST_TO_ADDR
// end ;
75195: LD_VAR 0 2
75199: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75200: LD_INT 0
75202: PPUSH
75203: PPUSH
75204: PPUSH
// pom := GetBase ( building ) ;
75205: LD_ADDR_VAR 0 4
75209: PUSH
75210: LD_VAR 0 1
75214: PPUSH
75215: CALL_OW 274
75219: ST_TO_ADDR
// if not pom then
75220: LD_VAR 0 4
75224: NOT
75225: IFFALSE 75229
// exit ;
75227: GO 75330
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75229: LD_ADDR_VAR 0 5
75233: PUSH
75234: LD_VAR 0 2
75238: PPUSH
75239: LD_VAR 0 1
75243: PPUSH
75244: CALL_OW 248
75248: PPUSH
75249: CALL_OW 450
75253: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75254: LD_ADDR_VAR 0 3
75258: PUSH
75259: LD_VAR 0 4
75263: PPUSH
75264: LD_INT 1
75266: PPUSH
75267: CALL_OW 275
75271: PUSH
75272: LD_VAR 0 5
75276: PUSH
75277: LD_INT 1
75279: ARRAY
75280: GREATEREQUAL
75281: PUSH
75282: LD_VAR 0 4
75286: PPUSH
75287: LD_INT 2
75289: PPUSH
75290: CALL_OW 275
75294: PUSH
75295: LD_VAR 0 5
75299: PUSH
75300: LD_INT 2
75302: ARRAY
75303: GREATEREQUAL
75304: AND
75305: PUSH
75306: LD_VAR 0 4
75310: PPUSH
75311: LD_INT 3
75313: PPUSH
75314: CALL_OW 275
75318: PUSH
75319: LD_VAR 0 5
75323: PUSH
75324: LD_INT 3
75326: ARRAY
75327: GREATEREQUAL
75328: AND
75329: ST_TO_ADDR
// end ;
75330: LD_VAR 0 3
75334: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75335: LD_INT 0
75337: PPUSH
75338: PPUSH
75339: PPUSH
75340: PPUSH
75341: PPUSH
75342: PPUSH
75343: PPUSH
75344: PPUSH
75345: PPUSH
75346: PPUSH
75347: PPUSH
// result := false ;
75348: LD_ADDR_VAR 0 8
75352: PUSH
75353: LD_INT 0
75355: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
75356: LD_VAR 0 5
75360: NOT
75361: PUSH
75362: LD_VAR 0 1
75366: NOT
75367: OR
75368: PUSH
75369: LD_VAR 0 2
75373: NOT
75374: OR
75375: PUSH
75376: LD_VAR 0 3
75380: NOT
75381: OR
75382: IFFALSE 75386
// exit ;
75384: GO 76200
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
75386: LD_ADDR_VAR 0 14
75390: PUSH
75391: LD_VAR 0 1
75395: PPUSH
75396: LD_VAR 0 2
75400: PPUSH
75401: LD_VAR 0 3
75405: PPUSH
75406: LD_VAR 0 4
75410: PPUSH
75411: LD_VAR 0 5
75415: PUSH
75416: LD_INT 1
75418: ARRAY
75419: PPUSH
75420: CALL_OW 248
75424: PPUSH
75425: LD_INT 0
75427: PPUSH
75428: CALL 77433 0 6
75432: ST_TO_ADDR
// if not hexes then
75433: LD_VAR 0 14
75437: NOT
75438: IFFALSE 75442
// exit ;
75440: GO 76200
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75442: LD_ADDR_VAR 0 17
75446: PUSH
75447: LD_VAR 0 5
75451: PPUSH
75452: LD_INT 22
75454: PUSH
75455: LD_VAR 0 13
75459: PPUSH
75460: CALL_OW 255
75464: PUSH
75465: EMPTY
75466: LIST
75467: LIST
75468: PUSH
75469: LD_INT 2
75471: PUSH
75472: LD_INT 30
75474: PUSH
75475: LD_INT 0
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PUSH
75482: LD_INT 30
75484: PUSH
75485: LD_INT 1
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: LIST
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: PPUSH
75501: CALL_OW 72
75505: ST_TO_ADDR
// for i = 1 to hexes do
75506: LD_ADDR_VAR 0 9
75510: PUSH
75511: DOUBLE
75512: LD_INT 1
75514: DEC
75515: ST_TO_ADDR
75516: LD_VAR 0 14
75520: PUSH
75521: FOR_TO
75522: IFFALSE 76198
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75524: LD_ADDR_VAR 0 13
75528: PUSH
75529: LD_VAR 0 14
75533: PUSH
75534: LD_VAR 0 9
75538: ARRAY
75539: PUSH
75540: LD_INT 1
75542: ARRAY
75543: PPUSH
75544: LD_VAR 0 14
75548: PUSH
75549: LD_VAR 0 9
75553: ARRAY
75554: PUSH
75555: LD_INT 2
75557: ARRAY
75558: PPUSH
75559: CALL_OW 428
75563: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75564: LD_VAR 0 14
75568: PUSH
75569: LD_VAR 0 9
75573: ARRAY
75574: PUSH
75575: LD_INT 1
75577: ARRAY
75578: PPUSH
75579: LD_VAR 0 14
75583: PUSH
75584: LD_VAR 0 9
75588: ARRAY
75589: PUSH
75590: LD_INT 2
75592: ARRAY
75593: PPUSH
75594: CALL_OW 351
75598: PUSH
75599: LD_VAR 0 14
75603: PUSH
75604: LD_VAR 0 9
75608: ARRAY
75609: PUSH
75610: LD_INT 1
75612: ARRAY
75613: PPUSH
75614: LD_VAR 0 14
75618: PUSH
75619: LD_VAR 0 9
75623: ARRAY
75624: PUSH
75625: LD_INT 2
75627: ARRAY
75628: PPUSH
75629: CALL_OW 488
75633: NOT
75634: OR
75635: PUSH
75636: LD_VAR 0 13
75640: PPUSH
75641: CALL_OW 247
75645: PUSH
75646: LD_INT 3
75648: EQUAL
75649: OR
75650: IFFALSE 75656
// exit ;
75652: POP
75653: POP
75654: GO 76200
// if not tmp then
75656: LD_VAR 0 13
75660: NOT
75661: IFFALSE 75665
// continue ;
75663: GO 75521
// result := true ;
75665: LD_ADDR_VAR 0 8
75669: PUSH
75670: LD_INT 1
75672: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
75673: LD_VAR 0 6
75677: PUSH
75678: LD_VAR 0 13
75682: PPUSH
75683: CALL_OW 247
75687: PUSH
75688: LD_INT 2
75690: EQUAL
75691: AND
75692: PUSH
75693: LD_VAR 0 13
75697: PPUSH
75698: CALL_OW 263
75702: PUSH
75703: LD_INT 1
75705: EQUAL
75706: AND
75707: IFFALSE 75871
// begin if IsDrivenBy ( tmp ) then
75709: LD_VAR 0 13
75713: PPUSH
75714: CALL_OW 311
75718: IFFALSE 75722
// continue ;
75720: GO 75521
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
75722: LD_VAR 0 6
75726: PPUSH
75727: LD_INT 3
75729: PUSH
75730: LD_INT 60
75732: PUSH
75733: EMPTY
75734: LIST
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 3
75742: PUSH
75743: LD_INT 55
75745: PUSH
75746: EMPTY
75747: LIST
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PPUSH
75757: CALL_OW 72
75761: IFFALSE 75869
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
75763: LD_ADDR_VAR 0 18
75767: PUSH
75768: LD_VAR 0 6
75772: PPUSH
75773: LD_INT 3
75775: PUSH
75776: LD_INT 60
75778: PUSH
75779: EMPTY
75780: LIST
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 3
75788: PUSH
75789: LD_INT 55
75791: PUSH
75792: EMPTY
75793: LIST
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PPUSH
75803: CALL_OW 72
75807: PUSH
75808: LD_INT 1
75810: ARRAY
75811: ST_TO_ADDR
// if IsInUnit ( driver ) then
75812: LD_VAR 0 18
75816: PPUSH
75817: CALL_OW 310
75821: IFFALSE 75832
// ComExit ( driver ) ;
75823: LD_VAR 0 18
75827: PPUSH
75828: CALL 101213 0 1
// AddComEnterUnit ( driver , tmp ) ;
75832: LD_VAR 0 18
75836: PPUSH
75837: LD_VAR 0 13
75841: PPUSH
75842: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
75846: LD_VAR 0 18
75850: PPUSH
75851: LD_VAR 0 7
75855: PPUSH
75856: CALL_OW 173
// AddComExitVehicle ( driver ) ;
75860: LD_VAR 0 18
75864: PPUSH
75865: CALL_OW 181
// end ; continue ;
75869: GO 75521
// end ; if not cleaners or not tmp in cleaners then
75871: LD_VAR 0 6
75875: NOT
75876: PUSH
75877: LD_VAR 0 13
75881: PUSH
75882: LD_VAR 0 6
75886: IN
75887: NOT
75888: OR
75889: IFFALSE 76196
// begin if dep then
75891: LD_VAR 0 17
75895: IFFALSE 76031
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75897: LD_ADDR_VAR 0 16
75901: PUSH
75902: LD_VAR 0 17
75906: PUSH
75907: LD_INT 1
75909: ARRAY
75910: PPUSH
75911: CALL_OW 250
75915: PPUSH
75916: LD_VAR 0 17
75920: PUSH
75921: LD_INT 1
75923: ARRAY
75924: PPUSH
75925: CALL_OW 254
75929: PPUSH
75930: LD_INT 5
75932: PPUSH
75933: CALL_OW 272
75937: PUSH
75938: LD_VAR 0 17
75942: PUSH
75943: LD_INT 1
75945: ARRAY
75946: PPUSH
75947: CALL_OW 251
75951: PPUSH
75952: LD_VAR 0 17
75956: PUSH
75957: LD_INT 1
75959: ARRAY
75960: PPUSH
75961: CALL_OW 254
75965: PPUSH
75966: LD_INT 5
75968: PPUSH
75969: CALL_OW 273
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75978: LD_VAR 0 16
75982: PUSH
75983: LD_INT 1
75985: ARRAY
75986: PPUSH
75987: LD_VAR 0 16
75991: PUSH
75992: LD_INT 2
75994: ARRAY
75995: PPUSH
75996: CALL_OW 488
76000: IFFALSE 76031
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76002: LD_VAR 0 13
76006: PPUSH
76007: LD_VAR 0 16
76011: PUSH
76012: LD_INT 1
76014: ARRAY
76015: PPUSH
76016: LD_VAR 0 16
76020: PUSH
76021: LD_INT 2
76023: ARRAY
76024: PPUSH
76025: CALL_OW 111
// continue ;
76029: GO 75521
// end ; end ; r := GetDir ( tmp ) ;
76031: LD_ADDR_VAR 0 15
76035: PUSH
76036: LD_VAR 0 13
76040: PPUSH
76041: CALL_OW 254
76045: ST_TO_ADDR
// if r = 5 then
76046: LD_VAR 0 15
76050: PUSH
76051: LD_INT 5
76053: EQUAL
76054: IFFALSE 76064
// r := 0 ;
76056: LD_ADDR_VAR 0 15
76060: PUSH
76061: LD_INT 0
76063: ST_TO_ADDR
// for j = r to 5 do
76064: LD_ADDR_VAR 0 10
76068: PUSH
76069: DOUBLE
76070: LD_VAR 0 15
76074: DEC
76075: ST_TO_ADDR
76076: LD_INT 5
76078: PUSH
76079: FOR_TO
76080: IFFALSE 76194
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76082: LD_ADDR_VAR 0 11
76086: PUSH
76087: LD_VAR 0 13
76091: PPUSH
76092: CALL_OW 250
76096: PPUSH
76097: LD_VAR 0 10
76101: PPUSH
76102: LD_INT 2
76104: PPUSH
76105: CALL_OW 272
76109: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76110: LD_ADDR_VAR 0 12
76114: PUSH
76115: LD_VAR 0 13
76119: PPUSH
76120: CALL_OW 251
76124: PPUSH
76125: LD_VAR 0 10
76129: PPUSH
76130: LD_INT 2
76132: PPUSH
76133: CALL_OW 273
76137: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76138: LD_VAR 0 11
76142: PPUSH
76143: LD_VAR 0 12
76147: PPUSH
76148: CALL_OW 488
76152: PUSH
76153: LD_VAR 0 11
76157: PPUSH
76158: LD_VAR 0 12
76162: PPUSH
76163: CALL_OW 428
76167: NOT
76168: AND
76169: IFFALSE 76192
// begin ComMoveXY ( tmp , _x , _y ) ;
76171: LD_VAR 0 13
76175: PPUSH
76176: LD_VAR 0 11
76180: PPUSH
76181: LD_VAR 0 12
76185: PPUSH
76186: CALL_OW 111
// break ;
76190: GO 76194
// end ; end ;
76192: GO 76079
76194: POP
76195: POP
// end ; end ;
76196: GO 75521
76198: POP
76199: POP
// end ;
76200: LD_VAR 0 8
76204: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76205: LD_INT 0
76207: PPUSH
// result := true ;
76208: LD_ADDR_VAR 0 3
76212: PUSH
76213: LD_INT 1
76215: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76216: LD_VAR 0 2
76220: PUSH
76221: LD_INT 24
76223: DOUBLE
76224: EQUAL
76225: IFTRUE 76235
76227: LD_INT 33
76229: DOUBLE
76230: EQUAL
76231: IFTRUE 76235
76233: GO 76260
76235: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76236: LD_ADDR_VAR 0 3
76240: PUSH
76241: LD_INT 32
76243: PPUSH
76244: LD_VAR 0 1
76248: PPUSH
76249: CALL_OW 321
76253: PUSH
76254: LD_INT 2
76256: EQUAL
76257: ST_TO_ADDR
76258: GO 76576
76260: LD_INT 20
76262: DOUBLE
76263: EQUAL
76264: IFTRUE 76268
76266: GO 76293
76268: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76269: LD_ADDR_VAR 0 3
76273: PUSH
76274: LD_INT 6
76276: PPUSH
76277: LD_VAR 0 1
76281: PPUSH
76282: CALL_OW 321
76286: PUSH
76287: LD_INT 2
76289: EQUAL
76290: ST_TO_ADDR
76291: GO 76576
76293: LD_INT 22
76295: DOUBLE
76296: EQUAL
76297: IFTRUE 76307
76299: LD_INT 36
76301: DOUBLE
76302: EQUAL
76303: IFTRUE 76307
76305: GO 76332
76307: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76308: LD_ADDR_VAR 0 3
76312: PUSH
76313: LD_INT 15
76315: PPUSH
76316: LD_VAR 0 1
76320: PPUSH
76321: CALL_OW 321
76325: PUSH
76326: LD_INT 2
76328: EQUAL
76329: ST_TO_ADDR
76330: GO 76576
76332: LD_INT 30
76334: DOUBLE
76335: EQUAL
76336: IFTRUE 76340
76338: GO 76365
76340: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76341: LD_ADDR_VAR 0 3
76345: PUSH
76346: LD_INT 20
76348: PPUSH
76349: LD_VAR 0 1
76353: PPUSH
76354: CALL_OW 321
76358: PUSH
76359: LD_INT 2
76361: EQUAL
76362: ST_TO_ADDR
76363: GO 76576
76365: LD_INT 28
76367: DOUBLE
76368: EQUAL
76369: IFTRUE 76379
76371: LD_INT 21
76373: DOUBLE
76374: EQUAL
76375: IFTRUE 76379
76377: GO 76404
76379: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
76380: LD_ADDR_VAR 0 3
76384: PUSH
76385: LD_INT 21
76387: PPUSH
76388: LD_VAR 0 1
76392: PPUSH
76393: CALL_OW 321
76397: PUSH
76398: LD_INT 2
76400: EQUAL
76401: ST_TO_ADDR
76402: GO 76576
76404: LD_INT 16
76406: DOUBLE
76407: EQUAL
76408: IFTRUE 76412
76410: GO 76437
76412: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
76413: LD_ADDR_VAR 0 3
76417: PUSH
76418: LD_INT 84
76420: PPUSH
76421: LD_VAR 0 1
76425: PPUSH
76426: CALL_OW 321
76430: PUSH
76431: LD_INT 2
76433: EQUAL
76434: ST_TO_ADDR
76435: GO 76576
76437: LD_INT 19
76439: DOUBLE
76440: EQUAL
76441: IFTRUE 76451
76443: LD_INT 23
76445: DOUBLE
76446: EQUAL
76447: IFTRUE 76451
76449: GO 76476
76451: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
76452: LD_ADDR_VAR 0 3
76456: PUSH
76457: LD_INT 83
76459: PPUSH
76460: LD_VAR 0 1
76464: PPUSH
76465: CALL_OW 321
76469: PUSH
76470: LD_INT 2
76472: EQUAL
76473: ST_TO_ADDR
76474: GO 76576
76476: LD_INT 17
76478: DOUBLE
76479: EQUAL
76480: IFTRUE 76484
76482: GO 76509
76484: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
76485: LD_ADDR_VAR 0 3
76489: PUSH
76490: LD_INT 39
76492: PPUSH
76493: LD_VAR 0 1
76497: PPUSH
76498: CALL_OW 321
76502: PUSH
76503: LD_INT 2
76505: EQUAL
76506: ST_TO_ADDR
76507: GO 76576
76509: LD_INT 18
76511: DOUBLE
76512: EQUAL
76513: IFTRUE 76517
76515: GO 76542
76517: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
76518: LD_ADDR_VAR 0 3
76522: PUSH
76523: LD_INT 40
76525: PPUSH
76526: LD_VAR 0 1
76530: PPUSH
76531: CALL_OW 321
76535: PUSH
76536: LD_INT 2
76538: EQUAL
76539: ST_TO_ADDR
76540: GO 76576
76542: LD_INT 27
76544: DOUBLE
76545: EQUAL
76546: IFTRUE 76550
76548: GO 76575
76550: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
76551: LD_ADDR_VAR 0 3
76555: PUSH
76556: LD_INT 35
76558: PPUSH
76559: LD_VAR 0 1
76563: PPUSH
76564: CALL_OW 321
76568: PUSH
76569: LD_INT 2
76571: EQUAL
76572: ST_TO_ADDR
76573: GO 76576
76575: POP
// end ;
76576: LD_VAR 0 3
76580: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
76581: LD_INT 0
76583: PPUSH
76584: PPUSH
76585: PPUSH
76586: PPUSH
76587: PPUSH
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
76592: PPUSH
76593: PPUSH
// result := false ;
76594: LD_ADDR_VAR 0 6
76598: PUSH
76599: LD_INT 0
76601: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76602: LD_VAR 0 1
76606: NOT
76607: PUSH
76608: LD_VAR 0 1
76612: PPUSH
76613: CALL_OW 266
76617: PUSH
76618: LD_INT 0
76620: PUSH
76621: LD_INT 1
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: IN
76628: NOT
76629: OR
76630: PUSH
76631: LD_VAR 0 2
76635: NOT
76636: OR
76637: PUSH
76638: LD_VAR 0 5
76642: PUSH
76643: LD_INT 0
76645: PUSH
76646: LD_INT 1
76648: PUSH
76649: LD_INT 2
76651: PUSH
76652: LD_INT 3
76654: PUSH
76655: LD_INT 4
76657: PUSH
76658: LD_INT 5
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: IN
76669: NOT
76670: OR
76671: PUSH
76672: LD_VAR 0 3
76676: PPUSH
76677: LD_VAR 0 4
76681: PPUSH
76682: CALL_OW 488
76686: NOT
76687: OR
76688: IFFALSE 76692
// exit ;
76690: GO 77428
// side := GetSide ( depot ) ;
76692: LD_ADDR_VAR 0 9
76696: PUSH
76697: LD_VAR 0 1
76701: PPUSH
76702: CALL_OW 255
76706: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
76707: LD_VAR 0 9
76711: PPUSH
76712: LD_VAR 0 2
76716: PPUSH
76717: CALL 76205 0 2
76721: NOT
76722: IFFALSE 76726
// exit ;
76724: GO 77428
// pom := GetBase ( depot ) ;
76726: LD_ADDR_VAR 0 10
76730: PUSH
76731: LD_VAR 0 1
76735: PPUSH
76736: CALL_OW 274
76740: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
76741: LD_ADDR_VAR 0 11
76745: PUSH
76746: LD_VAR 0 2
76750: PPUSH
76751: LD_VAR 0 1
76755: PPUSH
76756: CALL_OW 248
76760: PPUSH
76761: CALL_OW 450
76765: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76766: LD_VAR 0 10
76770: PPUSH
76771: LD_INT 1
76773: PPUSH
76774: CALL_OW 275
76778: PUSH
76779: LD_VAR 0 11
76783: PUSH
76784: LD_INT 1
76786: ARRAY
76787: GREATEREQUAL
76788: PUSH
76789: LD_VAR 0 10
76793: PPUSH
76794: LD_INT 2
76796: PPUSH
76797: CALL_OW 275
76801: PUSH
76802: LD_VAR 0 11
76806: PUSH
76807: LD_INT 2
76809: ARRAY
76810: GREATEREQUAL
76811: AND
76812: PUSH
76813: LD_VAR 0 10
76817: PPUSH
76818: LD_INT 3
76820: PPUSH
76821: CALL_OW 275
76825: PUSH
76826: LD_VAR 0 11
76830: PUSH
76831: LD_INT 3
76833: ARRAY
76834: GREATEREQUAL
76835: AND
76836: NOT
76837: IFFALSE 76841
// exit ;
76839: GO 77428
// if GetBType ( depot ) = b_depot then
76841: LD_VAR 0 1
76845: PPUSH
76846: CALL_OW 266
76850: PUSH
76851: LD_INT 0
76853: EQUAL
76854: IFFALSE 76866
// dist := 28 else
76856: LD_ADDR_VAR 0 14
76860: PUSH
76861: LD_INT 28
76863: ST_TO_ADDR
76864: GO 76874
// dist := 36 ;
76866: LD_ADDR_VAR 0 14
76870: PUSH
76871: LD_INT 36
76873: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
76874: LD_VAR 0 1
76878: PPUSH
76879: LD_VAR 0 3
76883: PPUSH
76884: LD_VAR 0 4
76888: PPUSH
76889: CALL_OW 297
76893: PUSH
76894: LD_VAR 0 14
76898: GREATER
76899: IFFALSE 76903
// exit ;
76901: GO 77428
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
76903: LD_ADDR_VAR 0 12
76907: PUSH
76908: LD_VAR 0 2
76912: PPUSH
76913: LD_VAR 0 3
76917: PPUSH
76918: LD_VAR 0 4
76922: PPUSH
76923: LD_VAR 0 5
76927: PPUSH
76928: LD_VAR 0 1
76932: PPUSH
76933: CALL_OW 248
76937: PPUSH
76938: LD_INT 0
76940: PPUSH
76941: CALL 77433 0 6
76945: ST_TO_ADDR
// if not hexes then
76946: LD_VAR 0 12
76950: NOT
76951: IFFALSE 76955
// exit ;
76953: GO 77428
// hex := GetHexInfo ( x , y ) ;
76955: LD_ADDR_VAR 0 15
76959: PUSH
76960: LD_VAR 0 3
76964: PPUSH
76965: LD_VAR 0 4
76969: PPUSH
76970: CALL_OW 546
76974: ST_TO_ADDR
// if hex [ 1 ] then
76975: LD_VAR 0 15
76979: PUSH
76980: LD_INT 1
76982: ARRAY
76983: IFFALSE 76987
// exit ;
76985: GO 77428
// height := hex [ 2 ] ;
76987: LD_ADDR_VAR 0 13
76991: PUSH
76992: LD_VAR 0 15
76996: PUSH
76997: LD_INT 2
76999: ARRAY
77000: ST_TO_ADDR
// for i = 1 to hexes do
77001: LD_ADDR_VAR 0 7
77005: PUSH
77006: DOUBLE
77007: LD_INT 1
77009: DEC
77010: ST_TO_ADDR
77011: LD_VAR 0 12
77015: PUSH
77016: FOR_TO
77017: IFFALSE 77347
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77019: LD_VAR 0 12
77023: PUSH
77024: LD_VAR 0 7
77028: ARRAY
77029: PUSH
77030: LD_INT 1
77032: ARRAY
77033: PPUSH
77034: LD_VAR 0 12
77038: PUSH
77039: LD_VAR 0 7
77043: ARRAY
77044: PUSH
77045: LD_INT 2
77047: ARRAY
77048: PPUSH
77049: CALL_OW 488
77053: NOT
77054: PUSH
77055: LD_VAR 0 12
77059: PUSH
77060: LD_VAR 0 7
77064: ARRAY
77065: PUSH
77066: LD_INT 1
77068: ARRAY
77069: PPUSH
77070: LD_VAR 0 12
77074: PUSH
77075: LD_VAR 0 7
77079: ARRAY
77080: PUSH
77081: LD_INT 2
77083: ARRAY
77084: PPUSH
77085: CALL_OW 428
77089: PUSH
77090: LD_INT 0
77092: GREATER
77093: OR
77094: PUSH
77095: LD_VAR 0 12
77099: PUSH
77100: LD_VAR 0 7
77104: ARRAY
77105: PUSH
77106: LD_INT 1
77108: ARRAY
77109: PPUSH
77110: LD_VAR 0 12
77114: PUSH
77115: LD_VAR 0 7
77119: ARRAY
77120: PUSH
77121: LD_INT 2
77123: ARRAY
77124: PPUSH
77125: CALL_OW 351
77129: OR
77130: IFFALSE 77136
// exit ;
77132: POP
77133: POP
77134: GO 77428
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77136: LD_ADDR_VAR 0 8
77140: PUSH
77141: LD_VAR 0 12
77145: PUSH
77146: LD_VAR 0 7
77150: ARRAY
77151: PUSH
77152: LD_INT 1
77154: ARRAY
77155: PPUSH
77156: LD_VAR 0 12
77160: PUSH
77161: LD_VAR 0 7
77165: ARRAY
77166: PUSH
77167: LD_INT 2
77169: ARRAY
77170: PPUSH
77171: CALL_OW 546
77175: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77176: LD_VAR 0 8
77180: PUSH
77181: LD_INT 1
77183: ARRAY
77184: PUSH
77185: LD_VAR 0 8
77189: PUSH
77190: LD_INT 2
77192: ARRAY
77193: PUSH
77194: LD_VAR 0 13
77198: PUSH
77199: LD_INT 2
77201: PLUS
77202: GREATER
77203: OR
77204: PUSH
77205: LD_VAR 0 8
77209: PUSH
77210: LD_INT 2
77212: ARRAY
77213: PUSH
77214: LD_VAR 0 13
77218: PUSH
77219: LD_INT 2
77221: MINUS
77222: LESS
77223: OR
77224: PUSH
77225: LD_VAR 0 8
77229: PUSH
77230: LD_INT 3
77232: ARRAY
77233: PUSH
77234: LD_INT 0
77236: PUSH
77237: LD_INT 8
77239: PUSH
77240: LD_INT 9
77242: PUSH
77243: LD_INT 10
77245: PUSH
77246: LD_INT 11
77248: PUSH
77249: LD_INT 12
77251: PUSH
77252: LD_INT 13
77254: PUSH
77255: LD_INT 16
77257: PUSH
77258: LD_INT 17
77260: PUSH
77261: LD_INT 18
77263: PUSH
77264: LD_INT 19
77266: PUSH
77267: LD_INT 20
77269: PUSH
77270: LD_INT 21
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: IN
77288: NOT
77289: OR
77290: PUSH
77291: LD_VAR 0 8
77295: PUSH
77296: LD_INT 5
77298: ARRAY
77299: NOT
77300: OR
77301: PUSH
77302: LD_VAR 0 8
77306: PUSH
77307: LD_INT 6
77309: ARRAY
77310: PUSH
77311: LD_INT 1
77313: PUSH
77314: LD_INT 2
77316: PUSH
77317: LD_INT 7
77319: PUSH
77320: LD_INT 9
77322: PUSH
77323: LD_INT 10
77325: PUSH
77326: LD_INT 11
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: LIST
77333: LIST
77334: LIST
77335: LIST
77336: IN
77337: NOT
77338: OR
77339: IFFALSE 77345
// exit ;
77341: POP
77342: POP
77343: GO 77428
// end ;
77345: GO 77016
77347: POP
77348: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77349: LD_VAR 0 9
77353: PPUSH
77354: LD_VAR 0 3
77358: PPUSH
77359: LD_VAR 0 4
77363: PPUSH
77364: LD_INT 20
77366: PPUSH
77367: CALL 69380 0 4
77371: PUSH
77372: LD_INT 4
77374: ARRAY
77375: IFFALSE 77379
// exit ;
77377: GO 77428
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77379: LD_VAR 0 2
77383: PUSH
77384: LD_INT 29
77386: PUSH
77387: LD_INT 30
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: IN
77394: PUSH
77395: LD_VAR 0 3
77399: PPUSH
77400: LD_VAR 0 4
77404: PPUSH
77405: LD_VAR 0 9
77409: PPUSH
77410: CALL_OW 440
77414: NOT
77415: AND
77416: IFFALSE 77420
// exit ;
77418: GO 77428
// result := true ;
77420: LD_ADDR_VAR 0 6
77424: PUSH
77425: LD_INT 1
77427: ST_TO_ADDR
// end ;
77428: LD_VAR 0 6
77432: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
77433: LD_INT 0
77435: PPUSH
77436: PPUSH
77437: PPUSH
77438: PPUSH
77439: PPUSH
77440: PPUSH
77441: PPUSH
77442: PPUSH
77443: PPUSH
77444: PPUSH
77445: PPUSH
77446: PPUSH
77447: PPUSH
77448: PPUSH
77449: PPUSH
77450: PPUSH
77451: PPUSH
77452: PPUSH
77453: PPUSH
77454: PPUSH
77455: PPUSH
77456: PPUSH
77457: PPUSH
77458: PPUSH
77459: PPUSH
77460: PPUSH
77461: PPUSH
77462: PPUSH
77463: PPUSH
77464: PPUSH
77465: PPUSH
77466: PPUSH
77467: PPUSH
77468: PPUSH
77469: PPUSH
77470: PPUSH
77471: PPUSH
77472: PPUSH
77473: PPUSH
77474: PPUSH
77475: PPUSH
77476: PPUSH
77477: PPUSH
77478: PPUSH
77479: PPUSH
77480: PPUSH
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
77486: PPUSH
77487: PPUSH
77488: PPUSH
77489: PPUSH
77490: PPUSH
77491: PPUSH
77492: PPUSH
// result = [ ] ;
77493: LD_ADDR_VAR 0 7
77497: PUSH
77498: EMPTY
77499: ST_TO_ADDR
// temp_list = [ ] ;
77500: LD_ADDR_VAR 0 9
77504: PUSH
77505: EMPTY
77506: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77507: LD_VAR 0 4
77511: PUSH
77512: LD_INT 0
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: LD_INT 2
77520: PUSH
77521: LD_INT 3
77523: PUSH
77524: LD_INT 4
77526: PUSH
77527: LD_INT 5
77529: PUSH
77530: EMPTY
77531: LIST
77532: LIST
77533: LIST
77534: LIST
77535: LIST
77536: LIST
77537: IN
77538: NOT
77539: PUSH
77540: LD_VAR 0 1
77544: PUSH
77545: LD_INT 0
77547: PUSH
77548: LD_INT 1
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: IN
77555: PUSH
77556: LD_VAR 0 5
77560: PUSH
77561: LD_INT 1
77563: PUSH
77564: LD_INT 2
77566: PUSH
77567: LD_INT 3
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: LIST
77574: IN
77575: NOT
77576: AND
77577: OR
77578: IFFALSE 77582
// exit ;
77580: GO 95973
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77582: LD_VAR 0 1
77586: PUSH
77587: LD_INT 6
77589: PUSH
77590: LD_INT 7
77592: PUSH
77593: LD_INT 8
77595: PUSH
77596: LD_INT 13
77598: PUSH
77599: LD_INT 12
77601: PUSH
77602: LD_INT 15
77604: PUSH
77605: LD_INT 11
77607: PUSH
77608: LD_INT 14
77610: PUSH
77611: LD_INT 10
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: IN
77625: IFFALSE 77635
// btype = b_lab ;
77627: LD_ADDR_VAR 0 1
77631: PUSH
77632: LD_INT 6
77634: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77635: LD_VAR 0 6
77639: PUSH
77640: LD_INT 0
77642: PUSH
77643: LD_INT 1
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: LIST
77653: IN
77654: NOT
77655: PUSH
77656: LD_VAR 0 1
77660: PUSH
77661: LD_INT 0
77663: PUSH
77664: LD_INT 1
77666: PUSH
77667: LD_INT 2
77669: PUSH
77670: LD_INT 3
77672: PUSH
77673: LD_INT 6
77675: PUSH
77676: LD_INT 36
77678: PUSH
77679: LD_INT 4
77681: PUSH
77682: LD_INT 5
77684: PUSH
77685: LD_INT 31
77687: PUSH
77688: LD_INT 32
77690: PUSH
77691: LD_INT 33
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: IN
77707: NOT
77708: PUSH
77709: LD_VAR 0 6
77713: PUSH
77714: LD_INT 1
77716: EQUAL
77717: AND
77718: OR
77719: PUSH
77720: LD_VAR 0 1
77724: PUSH
77725: LD_INT 2
77727: PUSH
77728: LD_INT 3
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: IN
77735: NOT
77736: PUSH
77737: LD_VAR 0 6
77741: PUSH
77742: LD_INT 2
77744: EQUAL
77745: AND
77746: OR
77747: IFFALSE 77757
// mode = 0 ;
77749: LD_ADDR_VAR 0 6
77753: PUSH
77754: LD_INT 0
77756: ST_TO_ADDR
// case mode of 0 :
77757: LD_VAR 0 6
77761: PUSH
77762: LD_INT 0
77764: DOUBLE
77765: EQUAL
77766: IFTRUE 77770
77768: GO 89223
77770: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77771: LD_ADDR_VAR 0 11
77775: PUSH
77776: LD_INT 0
77778: PUSH
77779: LD_INT 0
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 0
77788: PUSH
77789: LD_INT 1
77791: NEG
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 1
77799: PUSH
77800: LD_INT 0
77802: PUSH
77803: EMPTY
77804: LIST
77805: LIST
77806: PUSH
77807: LD_INT 1
77809: PUSH
77810: LD_INT 1
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 0
77819: PUSH
77820: LD_INT 1
77822: PUSH
77823: EMPTY
77824: LIST
77825: LIST
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: LD_INT 0
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 1
77840: NEG
77841: PUSH
77842: LD_INT 1
77844: NEG
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 1
77852: NEG
77853: PUSH
77854: LD_INT 2
77856: NEG
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 0
77864: PUSH
77865: LD_INT 2
77867: NEG
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 1
77875: PUSH
77876: LD_INT 1
77878: NEG
77879: PUSH
77880: EMPTY
77881: LIST
77882: LIST
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: LD_INT 2
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: LD_INT 2
77899: PUSH
77900: EMPTY
77901: LIST
77902: LIST
77903: PUSH
77904: LD_INT 1
77906: NEG
77907: PUSH
77908: LD_INT 1
77910: PUSH
77911: EMPTY
77912: LIST
77913: LIST
77914: PUSH
77915: LD_INT 1
77917: PUSH
77918: LD_INT 3
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 0
77927: PUSH
77928: LD_INT 3
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: LD_INT 1
77937: NEG
77938: PUSH
77939: LD_INT 2
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: LIST
77950: LIST
77951: LIST
77952: LIST
77953: LIST
77954: LIST
77955: LIST
77956: LIST
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77964: LD_ADDR_VAR 0 12
77968: PUSH
77969: LD_INT 0
77971: PUSH
77972: LD_INT 0
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 0
77981: PUSH
77982: LD_INT 1
77984: NEG
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 1
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: LD_INT 1
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 0
78012: PUSH
78013: LD_INT 1
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 1
78022: NEG
78023: PUSH
78024: LD_INT 0
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 1
78033: NEG
78034: PUSH
78035: LD_INT 1
78037: NEG
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: PUSH
78043: LD_INT 1
78045: PUSH
78046: LD_INT 1
78048: NEG
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: LD_INT 2
78056: PUSH
78057: LD_INT 0
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: LD_INT 2
78066: PUSH
78067: LD_INT 1
78069: PUSH
78070: EMPTY
78071: LIST
78072: LIST
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: LD_INT 1
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: LD_INT 2
78087: NEG
78088: PUSH
78089: LD_INT 0
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 2
78098: NEG
78099: PUSH
78100: LD_INT 1
78102: NEG
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 2
78110: NEG
78111: PUSH
78112: LD_INT 1
78114: PUSH
78115: EMPTY
78116: LIST
78117: LIST
78118: PUSH
78119: LD_INT 3
78121: NEG
78122: PUSH
78123: LD_INT 0
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 3
78132: NEG
78133: PUSH
78134: LD_INT 1
78136: NEG
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78160: LD_ADDR_VAR 0 13
78164: PUSH
78165: LD_INT 0
78167: PUSH
78168: LD_INT 0
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 0
78177: PUSH
78178: LD_INT 1
78180: NEG
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PUSH
78186: LD_INT 1
78188: PUSH
78189: LD_INT 0
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: LD_INT 1
78198: PUSH
78199: LD_INT 1
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 0
78208: PUSH
78209: LD_INT 1
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: LD_INT 0
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 1
78229: NEG
78230: PUSH
78231: LD_INT 1
78233: NEG
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: LD_INT 2
78245: NEG
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 2
78253: PUSH
78254: LD_INT 1
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 2
78263: PUSH
78264: LD_INT 2
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 1
78273: PUSH
78274: LD_INT 2
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 2
78283: NEG
78284: PUSH
78285: LD_INT 1
78287: NEG
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 2
78295: NEG
78296: PUSH
78297: LD_INT 2
78299: NEG
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 2
78307: NEG
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 3
78319: NEG
78320: PUSH
78321: LD_INT 2
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 3
78331: NEG
78332: PUSH
78333: LD_INT 3
78335: NEG
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: LIST
78356: LIST
78357: LIST
78358: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78359: LD_ADDR_VAR 0 14
78363: PUSH
78364: LD_INT 0
78366: PUSH
78367: LD_INT 0
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 0
78376: PUSH
78377: LD_INT 1
78379: NEG
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 1
78387: PUSH
78388: LD_INT 0
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 1
78397: PUSH
78398: LD_INT 1
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 0
78407: PUSH
78408: LD_INT 1
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: PUSH
78415: LD_INT 1
78417: NEG
78418: PUSH
78419: LD_INT 0
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: LD_INT 1
78428: NEG
78429: PUSH
78430: LD_INT 1
78432: NEG
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: LD_INT 1
78440: NEG
78441: PUSH
78442: LD_INT 2
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 0
78452: PUSH
78453: LD_INT 2
78455: NEG
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 1
78463: PUSH
78464: LD_INT 1
78466: NEG
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 1
78474: PUSH
78475: LD_INT 2
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 0
78484: PUSH
78485: LD_INT 2
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 1
78494: NEG
78495: PUSH
78496: LD_INT 1
78498: PUSH
78499: EMPTY
78500: LIST
78501: LIST
78502: PUSH
78503: LD_INT 1
78505: NEG
78506: PUSH
78507: LD_INT 3
78509: NEG
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 0
78517: PUSH
78518: LD_INT 3
78520: NEG
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 1
78528: PUSH
78529: LD_INT 2
78531: NEG
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78555: LD_ADDR_VAR 0 15
78559: PUSH
78560: LD_INT 0
78562: PUSH
78563: LD_INT 0
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: LD_INT 0
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 1
78583: PUSH
78584: LD_INT 0
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: PUSH
78591: LD_INT 1
78593: PUSH
78594: LD_INT 1
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 0
78603: PUSH
78604: LD_INT 1
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PUSH
78611: LD_INT 1
78613: NEG
78614: PUSH
78615: LD_INT 0
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 1
78624: NEG
78625: PUSH
78626: LD_INT 1
78628: NEG
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 1
78636: PUSH
78637: LD_INT 1
78639: NEG
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 2
78647: PUSH
78648: LD_INT 0
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 2
78657: PUSH
78658: LD_INT 1
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 1
78667: NEG
78668: PUSH
78669: LD_INT 1
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PUSH
78676: LD_INT 2
78678: NEG
78679: PUSH
78680: LD_INT 0
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 2
78689: NEG
78690: PUSH
78691: LD_INT 1
78693: NEG
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 2
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 3
78712: PUSH
78713: LD_INT 0
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 3
78722: PUSH
78723: LD_INT 1
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: LIST
78734: LIST
78735: LIST
78736: LIST
78737: LIST
78738: LIST
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78748: LD_ADDR_VAR 0 16
78752: PUSH
78753: LD_INT 0
78755: PUSH
78756: LD_INT 0
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 0
78765: PUSH
78766: LD_INT 1
78768: NEG
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: LD_INT 0
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 1
78786: PUSH
78787: LD_INT 1
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 0
78796: PUSH
78797: LD_INT 1
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 1
78806: NEG
78807: PUSH
78808: LD_INT 0
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 1
78817: NEG
78818: PUSH
78819: LD_INT 1
78821: NEG
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 1
78829: NEG
78830: PUSH
78831: LD_INT 2
78833: NEG
78834: PUSH
78835: EMPTY
78836: LIST
78837: LIST
78838: PUSH
78839: LD_INT 2
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: EMPTY
78846: LIST
78847: LIST
78848: PUSH
78849: LD_INT 2
78851: PUSH
78852: LD_INT 2
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 1
78861: PUSH
78862: LD_INT 2
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: PUSH
78869: LD_INT 2
78871: NEG
78872: PUSH
78873: LD_INT 1
78875: NEG
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 2
78883: NEG
78884: PUSH
78885: LD_INT 2
78887: NEG
78888: PUSH
78889: EMPTY
78890: LIST
78891: LIST
78892: PUSH
78893: LD_INT 3
78895: PUSH
78896: LD_INT 2
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 3
78905: PUSH
78906: LD_INT 3
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 2
78915: PUSH
78916: LD_INT 3
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: LIST
78927: LIST
78928: LIST
78929: LIST
78930: LIST
78931: LIST
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: LIST
78940: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78941: LD_ADDR_VAR 0 17
78945: PUSH
78946: LD_INT 0
78948: PUSH
78949: LD_INT 0
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 0
78958: PUSH
78959: LD_INT 1
78961: NEG
78962: PUSH
78963: EMPTY
78964: LIST
78965: LIST
78966: PUSH
78967: LD_INT 1
78969: PUSH
78970: LD_INT 0
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: LD_INT 1
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 0
78989: PUSH
78990: LD_INT 1
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 1
78999: NEG
79000: PUSH
79001: LD_INT 0
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 1
79010: NEG
79011: PUSH
79012: LD_INT 1
79014: NEG
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 1
79022: NEG
79023: PUSH
79024: LD_INT 2
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 0
79034: PUSH
79035: LD_INT 2
79037: NEG
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: LD_INT 1
79048: NEG
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 2
79056: PUSH
79057: LD_INT 0
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 2
79066: PUSH
79067: LD_INT 1
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 2
79076: PUSH
79077: LD_INT 2
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 1
79086: PUSH
79087: LD_INT 2
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 0
79096: PUSH
79097: LD_INT 2
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: PUSH
79104: LD_INT 1
79106: NEG
79107: PUSH
79108: LD_INT 1
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 2
79117: NEG
79118: PUSH
79119: LD_INT 0
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 2
79128: NEG
79129: PUSH
79130: LD_INT 1
79132: NEG
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: LD_INT 2
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: LIST
79169: LIST
79170: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79171: LD_ADDR_VAR 0 18
79175: PUSH
79176: LD_INT 0
79178: PUSH
79179: LD_INT 0
79181: PUSH
79182: EMPTY
79183: LIST
79184: LIST
79185: PUSH
79186: LD_INT 0
79188: PUSH
79189: LD_INT 1
79191: NEG
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 1
79199: PUSH
79200: LD_INT 0
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 1
79209: PUSH
79210: LD_INT 1
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 0
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 1
79229: NEG
79230: PUSH
79231: LD_INT 0
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 1
79240: NEG
79241: PUSH
79242: LD_INT 1
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 1
79252: NEG
79253: PUSH
79254: LD_INT 2
79256: NEG
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 0
79264: PUSH
79265: LD_INT 2
79267: NEG
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 1
79275: PUSH
79276: LD_INT 1
79278: NEG
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 2
79286: PUSH
79287: LD_INT 0
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 2
79296: PUSH
79297: LD_INT 1
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: PUSH
79304: LD_INT 2
79306: PUSH
79307: LD_INT 2
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 1
79316: PUSH
79317: LD_INT 2
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 0
79326: PUSH
79327: LD_INT 2
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 1
79336: NEG
79337: PUSH
79338: LD_INT 1
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 2
79347: NEG
79348: PUSH
79349: LD_INT 0
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 2
79358: NEG
79359: PUSH
79360: LD_INT 1
79362: NEG
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 2
79370: NEG
79371: PUSH
79372: LD_INT 2
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79401: LD_ADDR_VAR 0 19
79405: PUSH
79406: LD_INT 0
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: PUSH
79416: LD_INT 0
79418: PUSH
79419: LD_INT 1
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 1
79429: PUSH
79430: LD_INT 0
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 1
79439: PUSH
79440: LD_INT 1
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 0
79449: PUSH
79450: LD_INT 1
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 1
79459: NEG
79460: PUSH
79461: LD_INT 0
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 1
79470: NEG
79471: PUSH
79472: LD_INT 1
79474: NEG
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 1
79482: NEG
79483: PUSH
79484: LD_INT 2
79486: NEG
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 0
79494: PUSH
79495: LD_INT 2
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 1
79505: PUSH
79506: LD_INT 1
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 2
79516: PUSH
79517: LD_INT 0
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: LD_INT 2
79526: PUSH
79527: LD_INT 1
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: LD_INT 2
79536: PUSH
79537: LD_INT 2
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 1
79546: PUSH
79547: LD_INT 2
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 0
79556: PUSH
79557: LD_INT 2
79559: PUSH
79560: EMPTY
79561: LIST
79562: LIST
79563: PUSH
79564: LD_INT 1
79566: NEG
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 2
79577: NEG
79578: PUSH
79579: LD_INT 0
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 2
79588: NEG
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 2
79600: NEG
79601: PUSH
79602: LD_INT 2
79604: NEG
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79631: LD_ADDR_VAR 0 20
79635: PUSH
79636: LD_INT 0
79638: PUSH
79639: LD_INT 0
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 0
79648: PUSH
79649: LD_INT 1
79651: NEG
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 1
79659: PUSH
79660: LD_INT 0
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 1
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 0
79679: PUSH
79680: LD_INT 1
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 1
79689: NEG
79690: PUSH
79691: LD_INT 0
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 1
79700: NEG
79701: PUSH
79702: LD_INT 1
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 1
79712: NEG
79713: PUSH
79714: LD_INT 2
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 0
79724: PUSH
79725: LD_INT 2
79727: NEG
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 1
79735: PUSH
79736: LD_INT 1
79738: NEG
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: PUSH
79744: LD_INT 2
79746: PUSH
79747: LD_INT 0
79749: PUSH
79750: EMPTY
79751: LIST
79752: LIST
79753: PUSH
79754: LD_INT 2
79756: PUSH
79757: LD_INT 1
79759: PUSH
79760: EMPTY
79761: LIST
79762: LIST
79763: PUSH
79764: LD_INT 2
79766: PUSH
79767: LD_INT 2
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 1
79776: PUSH
79777: LD_INT 2
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 0
79786: PUSH
79787: LD_INT 2
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: LD_INT 1
79796: NEG
79797: PUSH
79798: LD_INT 1
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: PUSH
79805: LD_INT 2
79807: NEG
79808: PUSH
79809: LD_INT 0
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: PUSH
79816: LD_INT 2
79818: NEG
79819: PUSH
79820: LD_INT 1
79822: NEG
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 2
79830: NEG
79831: PUSH
79832: LD_INT 2
79834: NEG
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79861: LD_ADDR_VAR 0 21
79865: PUSH
79866: LD_INT 0
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: EMPTY
79873: LIST
79874: LIST
79875: PUSH
79876: LD_INT 0
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: EMPTY
79884: LIST
79885: LIST
79886: PUSH
79887: LD_INT 1
79889: PUSH
79890: LD_INT 0
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: PUSH
79897: LD_INT 1
79899: PUSH
79900: LD_INT 1
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 0
79909: PUSH
79910: LD_INT 1
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 1
79919: NEG
79920: PUSH
79921: LD_INT 0
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 1
79930: NEG
79931: PUSH
79932: LD_INT 1
79934: NEG
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 1
79942: NEG
79943: PUSH
79944: LD_INT 2
79946: NEG
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: LD_INT 0
79954: PUSH
79955: LD_INT 2
79957: NEG
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 1
79965: PUSH
79966: LD_INT 1
79968: NEG
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 2
79976: PUSH
79977: LD_INT 0
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 2
79986: PUSH
79987: LD_INT 1
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: LD_INT 2
79996: PUSH
79997: LD_INT 2
79999: PUSH
80000: EMPTY
80001: LIST
80002: LIST
80003: PUSH
80004: LD_INT 1
80006: PUSH
80007: LD_INT 2
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: LD_INT 2
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 1
80026: NEG
80027: PUSH
80028: LD_INT 1
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 2
80037: NEG
80038: PUSH
80039: LD_INT 0
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 2
80048: NEG
80049: PUSH
80050: LD_INT 1
80052: NEG
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 2
80060: NEG
80061: PUSH
80062: LD_INT 2
80064: NEG
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80091: LD_ADDR_VAR 0 22
80095: PUSH
80096: LD_INT 0
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 0
80108: PUSH
80109: LD_INT 1
80111: NEG
80112: PUSH
80113: EMPTY
80114: LIST
80115: LIST
80116: PUSH
80117: LD_INT 1
80119: PUSH
80120: LD_INT 0
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 1
80129: PUSH
80130: LD_INT 1
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 0
80139: PUSH
80140: LD_INT 1
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 1
80149: NEG
80150: PUSH
80151: LD_INT 0
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: NEG
80161: PUSH
80162: LD_INT 1
80164: NEG
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 1
80172: NEG
80173: PUSH
80174: LD_INT 2
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 0
80184: PUSH
80185: LD_INT 2
80187: NEG
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 1
80195: PUSH
80196: LD_INT 1
80198: NEG
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 2
80206: PUSH
80207: LD_INT 0
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 2
80216: PUSH
80217: LD_INT 1
80219: PUSH
80220: EMPTY
80221: LIST
80222: LIST
80223: PUSH
80224: LD_INT 2
80226: PUSH
80227: LD_INT 2
80229: PUSH
80230: EMPTY
80231: LIST
80232: LIST
80233: PUSH
80234: LD_INT 1
80236: PUSH
80237: LD_INT 2
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 0
80246: PUSH
80247: LD_INT 2
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 1
80256: NEG
80257: PUSH
80258: LD_INT 1
80260: PUSH
80261: EMPTY
80262: LIST
80263: LIST
80264: PUSH
80265: LD_INT 2
80267: NEG
80268: PUSH
80269: LD_INT 0
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 2
80278: NEG
80279: PUSH
80280: LD_INT 1
80282: NEG
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 2
80290: NEG
80291: PUSH
80292: LD_INT 2
80294: NEG
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: LIST
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80321: LD_ADDR_VAR 0 23
80325: PUSH
80326: LD_INT 0
80328: PUSH
80329: LD_INT 0
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 0
80338: PUSH
80339: LD_INT 1
80341: NEG
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 1
80349: PUSH
80350: LD_INT 0
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: PUSH
80360: LD_INT 1
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 0
80369: PUSH
80370: LD_INT 1
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 1
80379: NEG
80380: PUSH
80381: LD_INT 0
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PUSH
80388: LD_INT 1
80390: NEG
80391: PUSH
80392: LD_INT 1
80394: NEG
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: PUSH
80400: LD_INT 1
80402: NEG
80403: PUSH
80404: LD_INT 2
80406: NEG
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 0
80414: PUSH
80415: LD_INT 2
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 1
80425: PUSH
80426: LD_INT 1
80428: NEG
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 2
80436: PUSH
80437: LD_INT 0
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: LD_INT 2
80446: PUSH
80447: LD_INT 1
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: PUSH
80454: LD_INT 2
80456: PUSH
80457: LD_INT 2
80459: PUSH
80460: EMPTY
80461: LIST
80462: LIST
80463: PUSH
80464: LD_INT 1
80466: PUSH
80467: LD_INT 2
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 0
80476: PUSH
80477: LD_INT 2
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: NEG
80487: PUSH
80488: LD_INT 1
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 2
80497: NEG
80498: PUSH
80499: LD_INT 0
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 2
80508: NEG
80509: PUSH
80510: LD_INT 1
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 2
80520: NEG
80521: PUSH
80522: LD_INT 2
80524: NEG
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 2
80532: NEG
80533: PUSH
80534: LD_INT 3
80536: NEG
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: LD_INT 3
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 1
80556: PUSH
80557: LD_INT 2
80559: NEG
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 2
80567: PUSH
80568: LD_INT 1
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80601: LD_ADDR_VAR 0 24
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: LD_INT 0
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 0
80618: PUSH
80619: LD_INT 1
80621: NEG
80622: PUSH
80623: EMPTY
80624: LIST
80625: LIST
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: LD_INT 0
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 1
80639: PUSH
80640: LD_INT 1
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 0
80649: PUSH
80650: LD_INT 1
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 1
80659: NEG
80660: PUSH
80661: LD_INT 0
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 1
80670: NEG
80671: PUSH
80672: LD_INT 1
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 1
80682: NEG
80683: PUSH
80684: LD_INT 2
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 0
80694: PUSH
80695: LD_INT 2
80697: NEG
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 1
80705: PUSH
80706: LD_INT 1
80708: NEG
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 2
80716: PUSH
80717: LD_INT 0
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 2
80726: PUSH
80727: LD_INT 1
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 2
80736: PUSH
80737: LD_INT 2
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 1
80746: PUSH
80747: LD_INT 2
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 0
80756: PUSH
80757: LD_INT 2
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 1
80766: NEG
80767: PUSH
80768: LD_INT 1
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 2
80777: NEG
80778: PUSH
80779: LD_INT 0
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 2
80788: NEG
80789: PUSH
80790: LD_INT 1
80792: NEG
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 2
80800: NEG
80801: PUSH
80802: LD_INT 2
80804: NEG
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: LD_INT 2
80815: NEG
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: PUSH
80821: LD_INT 2
80823: PUSH
80824: LD_INT 1
80826: NEG
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 3
80834: PUSH
80835: LD_INT 1
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 3
80844: PUSH
80845: LD_INT 2
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80877: LD_ADDR_VAR 0 25
80881: PUSH
80882: LD_INT 0
80884: PUSH
80885: LD_INT 0
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 0
80894: PUSH
80895: LD_INT 1
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 1
80905: PUSH
80906: LD_INT 0
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 1
80915: PUSH
80916: LD_INT 1
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 0
80925: PUSH
80926: LD_INT 1
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 1
80935: NEG
80936: PUSH
80937: LD_INT 0
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 1
80946: NEG
80947: PUSH
80948: LD_INT 1
80950: NEG
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 1
80958: NEG
80959: PUSH
80960: LD_INT 2
80962: NEG
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 0
80970: PUSH
80971: LD_INT 2
80973: NEG
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: LD_INT 1
80984: NEG
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 2
80992: PUSH
80993: LD_INT 0
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 2
81002: PUSH
81003: LD_INT 1
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 2
81012: PUSH
81013: LD_INT 2
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 1
81022: PUSH
81023: LD_INT 2
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: LD_INT 2
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 1
81042: NEG
81043: PUSH
81044: LD_INT 1
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 2
81053: NEG
81054: PUSH
81055: LD_INT 0
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 2
81064: NEG
81065: PUSH
81066: LD_INT 1
81068: NEG
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: LD_INT 2
81076: NEG
81077: PUSH
81078: LD_INT 2
81080: NEG
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 3
81088: PUSH
81089: LD_INT 1
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 3
81098: PUSH
81099: LD_INT 2
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 2
81108: PUSH
81109: LD_INT 3
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 1
81118: PUSH
81119: LD_INT 3
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: EMPTY
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81151: LD_ADDR_VAR 0 26
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: LD_INT 0
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 0
81168: PUSH
81169: LD_INT 1
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 1
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 1
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 0
81199: PUSH
81200: LD_INT 1
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 1
81209: NEG
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: LD_INT 1
81220: NEG
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 1
81232: NEG
81233: PUSH
81234: LD_INT 2
81236: NEG
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 0
81244: PUSH
81245: LD_INT 2
81247: NEG
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 1
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 2
81266: PUSH
81267: LD_INT 0
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 2
81276: PUSH
81277: LD_INT 1
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 2
81286: PUSH
81287: LD_INT 2
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 1
81296: PUSH
81297: LD_INT 2
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 0
81306: PUSH
81307: LD_INT 2
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 1
81316: NEG
81317: PUSH
81318: LD_INT 1
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 2
81327: NEG
81328: PUSH
81329: LD_INT 0
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: NEG
81339: PUSH
81340: LD_INT 1
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 2
81350: NEG
81351: PUSH
81352: LD_INT 2
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 2
81362: PUSH
81363: LD_INT 3
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 1
81372: PUSH
81373: LD_INT 3
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 1
81382: NEG
81383: PUSH
81384: LD_INT 2
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 2
81393: NEG
81394: PUSH
81395: LD_INT 1
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: LIST
81424: LIST
81425: LIST
81426: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81427: LD_ADDR_VAR 0 27
81431: PUSH
81432: LD_INT 0
81434: PUSH
81435: LD_INT 0
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: LD_INT 1
81447: NEG
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 1
81455: PUSH
81456: LD_INT 0
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: LD_INT 1
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: LD_INT 1
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 1
81485: NEG
81486: PUSH
81487: LD_INT 0
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: LD_INT 1
81496: NEG
81497: PUSH
81498: LD_INT 1
81500: NEG
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 1
81508: NEG
81509: PUSH
81510: LD_INT 2
81512: NEG
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 0
81520: PUSH
81521: LD_INT 2
81523: NEG
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 1
81531: PUSH
81532: LD_INT 1
81534: NEG
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 2
81542: PUSH
81543: LD_INT 0
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 2
81552: PUSH
81553: LD_INT 1
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 2
81562: PUSH
81563: LD_INT 2
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 1
81572: PUSH
81573: LD_INT 2
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 0
81582: PUSH
81583: LD_INT 2
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 1
81592: NEG
81593: PUSH
81594: LD_INT 1
81596: PUSH
81597: EMPTY
81598: LIST
81599: LIST
81600: PUSH
81601: LD_INT 2
81603: NEG
81604: PUSH
81605: LD_INT 0
81607: PUSH
81608: EMPTY
81609: LIST
81610: LIST
81611: PUSH
81612: LD_INT 2
81614: NEG
81615: PUSH
81616: LD_INT 1
81618: NEG
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 2
81626: NEG
81627: PUSH
81628: LD_INT 2
81630: NEG
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 1
81638: NEG
81639: PUSH
81640: LD_INT 2
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 2
81649: NEG
81650: PUSH
81651: LD_INT 1
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 3
81660: NEG
81661: PUSH
81662: LD_INT 1
81664: NEG
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 3
81672: NEG
81673: PUSH
81674: LD_INT 2
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81707: LD_ADDR_VAR 0 28
81711: PUSH
81712: LD_INT 0
81714: PUSH
81715: LD_INT 0
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 0
81724: PUSH
81725: LD_INT 1
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 1
81735: PUSH
81736: LD_INT 0
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PUSH
81743: LD_INT 1
81745: PUSH
81746: LD_INT 1
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 0
81755: PUSH
81756: LD_INT 1
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 1
81765: NEG
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: PUSH
81774: LD_INT 1
81776: NEG
81777: PUSH
81778: LD_INT 1
81780: NEG
81781: PUSH
81782: EMPTY
81783: LIST
81784: LIST
81785: PUSH
81786: LD_INT 1
81788: NEG
81789: PUSH
81790: LD_INT 2
81792: NEG
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: PUSH
81798: LD_INT 0
81800: PUSH
81801: LD_INT 2
81803: NEG
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 2
81822: PUSH
81823: LD_INT 0
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 2
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 2
81842: PUSH
81843: LD_INT 2
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 1
81852: PUSH
81853: LD_INT 2
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 0
81862: PUSH
81863: LD_INT 2
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 1
81872: NEG
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: PUSH
81881: LD_INT 2
81883: NEG
81884: PUSH
81885: LD_INT 0
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 2
81894: NEG
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 2
81906: NEG
81907: PUSH
81908: LD_INT 2
81910: NEG
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 2
81918: NEG
81919: PUSH
81920: LD_INT 3
81922: NEG
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 1
81930: NEG
81931: PUSH
81932: LD_INT 3
81934: NEG
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 3
81942: NEG
81943: PUSH
81944: LD_INT 1
81946: NEG
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 3
81954: NEG
81955: PUSH
81956: LD_INT 2
81958: NEG
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81989: LD_ADDR_VAR 0 29
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 0
82006: PUSH
82007: LD_INT 1
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: LD_INT 0
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: LD_INT 1
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 0
82037: PUSH
82038: LD_INT 1
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: PUSH
82045: LD_INT 1
82047: NEG
82048: PUSH
82049: LD_INT 0
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 1
82058: NEG
82059: PUSH
82060: LD_INT 1
82062: NEG
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 1
82070: NEG
82071: PUSH
82072: LD_INT 2
82074: NEG
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 0
82082: PUSH
82083: LD_INT 2
82085: NEG
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: LD_INT 1
82096: NEG
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 2
82104: PUSH
82105: LD_INT 0
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 2
82114: PUSH
82115: LD_INT 1
82117: PUSH
82118: EMPTY
82119: LIST
82120: LIST
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: LD_INT 2
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: LD_INT 2
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 1
82144: NEG
82145: PUSH
82146: LD_INT 1
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: NEG
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 2
82179: NEG
82180: PUSH
82181: LD_INT 3
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 2
82191: PUSH
82192: LD_INT 1
82194: NEG
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 3
82202: PUSH
82203: LD_INT 1
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 1
82212: PUSH
82213: LD_INT 3
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: LD_INT 2
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 3
82233: NEG
82234: PUSH
82235: LD_INT 2
82237: NEG
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82268: LD_ADDR_VAR 0 30
82272: PUSH
82273: LD_INT 0
82275: PUSH
82276: LD_INT 0
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: LD_INT 1
82288: NEG
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 1
82296: PUSH
82297: LD_INT 0
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 1
82306: PUSH
82307: LD_INT 1
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: LD_INT 1
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 1
82326: NEG
82327: PUSH
82328: LD_INT 0
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: LD_INT 1
82337: NEG
82338: PUSH
82339: LD_INT 1
82341: NEG
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 1
82349: NEG
82350: PUSH
82351: LD_INT 2
82353: NEG
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 0
82361: PUSH
82362: LD_INT 2
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 1
82372: PUSH
82373: LD_INT 1
82375: NEG
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 2
82383: PUSH
82384: LD_INT 0
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 2
82393: PUSH
82394: LD_INT 1
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 2
82403: PUSH
82404: LD_INT 2
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PUSH
82411: LD_INT 1
82413: PUSH
82414: LD_INT 2
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 1
82423: NEG
82424: PUSH
82425: LD_INT 1
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 2
82434: NEG
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 2
82445: NEG
82446: PUSH
82447: LD_INT 1
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 1
82457: NEG
82458: PUSH
82459: LD_INT 3
82461: NEG
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 1
82469: PUSH
82470: LD_INT 2
82472: NEG
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 3
82480: PUSH
82481: LD_INT 2
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 2
82490: PUSH
82491: LD_INT 3
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 2
82500: NEG
82501: PUSH
82502: LD_INT 1
82504: PUSH
82505: EMPTY
82506: LIST
82507: LIST
82508: PUSH
82509: LD_INT 3
82511: NEG
82512: PUSH
82513: LD_INT 1
82515: NEG
82516: PUSH
82517: EMPTY
82518: LIST
82519: LIST
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: LIST
82525: LIST
82526: LIST
82527: LIST
82528: LIST
82529: LIST
82530: LIST
82531: LIST
82532: LIST
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82546: LD_ADDR_VAR 0 31
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: LD_INT 0
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 0
82563: PUSH
82564: LD_INT 1
82566: NEG
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 1
82574: PUSH
82575: LD_INT 0
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: LD_INT 1
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 0
82594: PUSH
82595: LD_INT 1
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 1
82604: NEG
82605: PUSH
82606: LD_INT 0
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 1
82615: NEG
82616: PUSH
82617: LD_INT 1
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 1
82627: NEG
82628: PUSH
82629: LD_INT 2
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 1
82639: PUSH
82640: LD_INT 1
82642: NEG
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 2
82650: PUSH
82651: LD_INT 0
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 2
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 2
82670: PUSH
82671: LD_INT 2
82673: PUSH
82674: EMPTY
82675: LIST
82676: LIST
82677: PUSH
82678: LD_INT 1
82680: PUSH
82681: LD_INT 2
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 0
82690: PUSH
82691: LD_INT 2
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: PUSH
82698: LD_INT 1
82700: NEG
82701: PUSH
82702: LD_INT 1
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 2
82711: NEG
82712: PUSH
82713: LD_INT 1
82715: NEG
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 2
82723: NEG
82724: PUSH
82725: LD_INT 2
82727: NEG
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 2
82735: NEG
82736: PUSH
82737: LD_INT 3
82739: NEG
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 2
82747: PUSH
82748: LD_INT 1
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 3
82758: PUSH
82759: LD_INT 1
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 1
82768: PUSH
82769: LD_INT 3
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 1
82778: NEG
82779: PUSH
82780: LD_INT 2
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 3
82789: NEG
82790: PUSH
82791: LD_INT 2
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: LIST
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82824: LD_ADDR_VAR 0 32
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: LD_INT 0
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 0
82841: PUSH
82842: LD_INT 1
82844: NEG
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 1
82852: PUSH
82853: LD_INT 0
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 1
82862: PUSH
82863: LD_INT 1
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 0
82872: PUSH
82873: LD_INT 1
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 1
82882: NEG
82883: PUSH
82884: LD_INT 0
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 1
82893: NEG
82894: PUSH
82895: LD_INT 1
82897: NEG
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 1
82905: NEG
82906: PUSH
82907: LD_INT 2
82909: NEG
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: LD_INT 2
82920: NEG
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 1
82928: PUSH
82929: LD_INT 1
82931: NEG
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: LD_INT 1
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 2
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 1
82959: PUSH
82960: LD_INT 2
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 0
82969: PUSH
82970: LD_INT 2
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 1
82979: NEG
82980: PUSH
82981: LD_INT 1
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 2
82990: NEG
82991: PUSH
82992: LD_INT 0
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 2
83001: NEG
83002: PUSH
83003: LD_INT 1
83005: NEG
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 1
83013: NEG
83014: PUSH
83015: LD_INT 3
83017: NEG
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 1
83025: PUSH
83026: LD_INT 2
83028: NEG
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 3
83036: PUSH
83037: LD_INT 2
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: LD_INT 3
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 2
83056: NEG
83057: PUSH
83058: LD_INT 1
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 3
83067: NEG
83068: PUSH
83069: LD_INT 1
83071: NEG
83072: PUSH
83073: EMPTY
83074: LIST
83075: LIST
83076: PUSH
83077: EMPTY
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83102: LD_ADDR_VAR 0 33
83106: PUSH
83107: LD_INT 0
83109: PUSH
83110: LD_INT 0
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 0
83119: PUSH
83120: LD_INT 1
83122: NEG
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 1
83130: PUSH
83131: LD_INT 0
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: LD_INT 1
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 0
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 1
83160: NEG
83161: PUSH
83162: LD_INT 0
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: LD_INT 1
83175: NEG
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: LD_INT 1
83183: NEG
83184: PUSH
83185: LD_INT 2
83187: NEG
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 1
83195: PUSH
83196: LD_INT 1
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 2
83206: PUSH
83207: LD_INT 0
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 2
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 1
83226: PUSH
83227: LD_INT 2
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: LD_INT 2
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 1
83246: NEG
83247: PUSH
83248: LD_INT 1
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 2
83257: NEG
83258: PUSH
83259: LD_INT 0
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: PUSH
83266: LD_INT 2
83268: NEG
83269: PUSH
83270: LD_INT 1
83272: NEG
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 2
83280: NEG
83281: PUSH
83282: LD_INT 2
83284: NEG
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 2
83292: NEG
83293: PUSH
83294: LD_INT 3
83296: NEG
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 2
83304: PUSH
83305: LD_INT 1
83307: NEG
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 3
83315: PUSH
83316: LD_INT 1
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 1
83325: PUSH
83326: LD_INT 3
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: LD_INT 2
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 3
83346: NEG
83347: PUSH
83348: LD_INT 2
83350: NEG
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83381: LD_ADDR_VAR 0 34
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: LD_INT 0
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 0
83398: PUSH
83399: LD_INT 1
83401: NEG
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 1
83409: PUSH
83410: LD_INT 0
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 1
83419: PUSH
83420: LD_INT 1
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 0
83429: PUSH
83430: LD_INT 1
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 1
83439: NEG
83440: PUSH
83441: LD_INT 0
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 1
83450: NEG
83451: PUSH
83452: LD_INT 1
83454: NEG
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 1
83462: NEG
83463: PUSH
83464: LD_INT 2
83466: NEG
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 0
83474: PUSH
83475: LD_INT 2
83477: NEG
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: PUSH
83483: LD_INT 1
83485: PUSH
83486: LD_INT 1
83488: NEG
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 2
83496: PUSH
83497: LD_INT 1
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 2
83506: PUSH
83507: LD_INT 2
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 1
83516: PUSH
83517: LD_INT 2
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: PUSH
83524: LD_INT 1
83526: NEG
83527: PUSH
83528: LD_INT 1
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 2
83537: NEG
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 2
83548: NEG
83549: PUSH
83550: LD_INT 1
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 2
83560: NEG
83561: PUSH
83562: LD_INT 2
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 1
83572: NEG
83573: PUSH
83574: LD_INT 3
83576: NEG
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 1
83584: PUSH
83585: LD_INT 2
83587: NEG
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 3
83595: PUSH
83596: LD_INT 2
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 2
83605: PUSH
83606: LD_INT 3
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 2
83615: NEG
83616: PUSH
83617: LD_INT 1
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 3
83626: NEG
83627: PUSH
83628: LD_INT 1
83630: NEG
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83661: LD_ADDR_VAR 0 35
83665: PUSH
83666: LD_INT 0
83668: PUSH
83669: LD_INT 0
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 0
83678: PUSH
83679: LD_INT 1
83681: NEG
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 1
83689: PUSH
83690: LD_INT 0
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 1
83699: PUSH
83700: LD_INT 1
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 0
83709: PUSH
83710: LD_INT 1
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 1
83719: NEG
83720: PUSH
83721: LD_INT 0
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: LD_INT 1
83734: NEG
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: PUSH
83740: LD_INT 2
83742: PUSH
83743: LD_INT 1
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_INT 2
83752: NEG
83753: PUSH
83754: LD_INT 1
83756: NEG
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: LIST
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: LIST
83772: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83773: LD_ADDR_VAR 0 36
83777: PUSH
83778: LD_INT 0
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 0
83790: PUSH
83791: LD_INT 1
83793: NEG
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 1
83801: PUSH
83802: LD_INT 0
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 1
83811: PUSH
83812: LD_INT 1
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 0
83821: PUSH
83822: LD_INT 1
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: PUSH
83829: LD_INT 1
83831: NEG
83832: PUSH
83833: LD_INT 0
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 1
83842: NEG
83843: PUSH
83844: LD_INT 1
83846: NEG
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 1
83854: NEG
83855: PUSH
83856: LD_INT 2
83858: NEG
83859: PUSH
83860: EMPTY
83861: LIST
83862: LIST
83863: PUSH
83864: LD_INT 1
83866: PUSH
83867: LD_INT 2
83869: PUSH
83870: EMPTY
83871: LIST
83872: LIST
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83885: LD_ADDR_VAR 0 37
83889: PUSH
83890: LD_INT 0
83892: PUSH
83893: LD_INT 0
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 0
83902: PUSH
83903: LD_INT 1
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: PUSH
83914: LD_INT 0
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 1
83923: PUSH
83924: LD_INT 1
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 0
83933: PUSH
83934: LD_INT 1
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 1
83943: NEG
83944: PUSH
83945: LD_INT 0
83947: PUSH
83948: EMPTY
83949: LIST
83950: LIST
83951: PUSH
83952: LD_INT 1
83954: NEG
83955: PUSH
83956: LD_INT 1
83958: NEG
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 1
83966: PUSH
83967: LD_INT 1
83969: NEG
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83997: LD_ADDR_VAR 0 38
84001: PUSH
84002: LD_INT 0
84004: PUSH
84005: LD_INT 0
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 0
84014: PUSH
84015: LD_INT 1
84017: NEG
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PUSH
84023: LD_INT 1
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 1
84035: PUSH
84036: LD_INT 1
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 0
84045: PUSH
84046: LD_INT 1
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: PUSH
84053: LD_INT 1
84055: NEG
84056: PUSH
84057: LD_INT 0
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 1
84066: NEG
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 2
84078: PUSH
84079: LD_INT 1
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 2
84088: NEG
84089: PUSH
84090: LD_INT 1
84092: NEG
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84109: LD_ADDR_VAR 0 39
84113: PUSH
84114: LD_INT 0
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 0
84126: PUSH
84127: LD_INT 1
84129: NEG
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 1
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: LD_INT 1
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: LD_INT 0
84157: PUSH
84158: LD_INT 1
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 1
84167: NEG
84168: PUSH
84169: LD_INT 0
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 1
84178: NEG
84179: PUSH
84180: LD_INT 1
84182: NEG
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 1
84190: NEG
84191: PUSH
84192: LD_INT 2
84194: NEG
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 1
84202: PUSH
84203: LD_INT 2
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84221: LD_ADDR_VAR 0 40
84225: PUSH
84226: LD_INT 0
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 0
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 1
84249: PUSH
84250: LD_INT 0
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 1
84259: PUSH
84260: LD_INT 1
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 0
84269: PUSH
84270: LD_INT 1
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: PUSH
84277: LD_INT 1
84279: NEG
84280: PUSH
84281: LD_INT 0
84283: PUSH
84284: EMPTY
84285: LIST
84286: LIST
84287: PUSH
84288: LD_INT 1
84290: NEG
84291: PUSH
84292: LD_INT 1
84294: NEG
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: PUSH
84300: LD_INT 1
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: PUSH
84311: LD_INT 1
84313: NEG
84314: PUSH
84315: LD_INT 1
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84333: LD_ADDR_VAR 0 41
84337: PUSH
84338: LD_INT 0
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 0
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 1
84361: PUSH
84362: LD_INT 0
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: LD_INT 1
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 0
84381: PUSH
84382: LD_INT 1
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PUSH
84389: LD_INT 1
84391: NEG
84392: PUSH
84393: LD_INT 0
84395: PUSH
84396: EMPTY
84397: LIST
84398: LIST
84399: PUSH
84400: LD_INT 1
84402: NEG
84403: PUSH
84404: LD_INT 1
84406: NEG
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: LD_INT 1
84414: NEG
84415: PUSH
84416: LD_INT 2
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 1
84426: PUSH
84427: LD_INT 1
84429: NEG
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 2
84437: PUSH
84438: LD_INT 0
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 2
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 2
84457: PUSH
84458: LD_INT 2
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 1
84467: PUSH
84468: LD_INT 2
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 1
84477: NEG
84478: PUSH
84479: LD_INT 1
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PUSH
84486: LD_INT 2
84488: NEG
84489: PUSH
84490: LD_INT 0
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PUSH
84497: LD_INT 2
84499: NEG
84500: PUSH
84501: LD_INT 1
84503: NEG
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 2
84511: NEG
84512: PUSH
84513: LD_INT 2
84515: NEG
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 2
84523: NEG
84524: PUSH
84525: LD_INT 3
84527: NEG
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 2
84535: PUSH
84536: LD_INT 1
84538: NEG
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 3
84546: PUSH
84547: LD_INT 0
84549: PUSH
84550: EMPTY
84551: LIST
84552: LIST
84553: PUSH
84554: LD_INT 3
84556: PUSH
84557: LD_INT 1
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_INT 3
84566: PUSH
84567: LD_INT 2
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 3
84576: PUSH
84577: LD_INT 3
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 2
84586: PUSH
84587: LD_INT 3
84589: PUSH
84590: EMPTY
84591: LIST
84592: LIST
84593: PUSH
84594: LD_INT 2
84596: NEG
84597: PUSH
84598: LD_INT 1
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 3
84607: NEG
84608: PUSH
84609: LD_INT 0
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 3
84618: NEG
84619: PUSH
84620: LD_INT 1
84622: NEG
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 3
84630: NEG
84631: PUSH
84632: LD_INT 2
84634: NEG
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 3
84642: NEG
84643: PUSH
84644: LD_INT 3
84646: NEG
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84683: LD_ADDR_VAR 0 42
84687: PUSH
84688: LD_INT 0
84690: PUSH
84691: LD_INT 0
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 0
84700: PUSH
84701: LD_INT 1
84703: NEG
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: LD_INT 1
84711: PUSH
84712: LD_INT 0
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: PUSH
84719: LD_INT 1
84721: PUSH
84722: LD_INT 1
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 0
84731: PUSH
84732: LD_INT 1
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: LD_INT 1
84741: NEG
84742: PUSH
84743: LD_INT 0
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: PUSH
84750: LD_INT 1
84752: NEG
84753: PUSH
84754: LD_INT 1
84756: NEG
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 1
84764: NEG
84765: PUSH
84766: LD_INT 2
84768: NEG
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 0
84776: PUSH
84777: LD_INT 2
84779: NEG
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 1
84787: PUSH
84788: LD_INT 1
84790: NEG
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 2
84798: PUSH
84799: LD_INT 1
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 2
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 2
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 0
84828: PUSH
84829: LD_INT 2
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: NEG
84839: PUSH
84840: LD_INT 1
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 2
84849: NEG
84850: PUSH
84851: LD_INT 1
84853: NEG
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 2
84861: NEG
84862: PUSH
84863: LD_INT 2
84865: NEG
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 2
84873: NEG
84874: PUSH
84875: LD_INT 3
84877: NEG
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 1
84885: NEG
84886: PUSH
84887: LD_INT 3
84889: NEG
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 3
84900: NEG
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 1
84908: PUSH
84909: LD_INT 2
84911: NEG
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 3
84919: PUSH
84920: LD_INT 2
84922: PUSH
84923: EMPTY
84924: LIST
84925: LIST
84926: PUSH
84927: LD_INT 3
84929: PUSH
84930: LD_INT 3
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 2
84939: PUSH
84940: LD_INT 3
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: PUSH
84947: LD_INT 1
84949: PUSH
84950: LD_INT 3
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 0
84959: PUSH
84960: LD_INT 3
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 1
84969: NEG
84970: PUSH
84971: LD_INT 2
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: PUSH
84978: LD_INT 3
84980: NEG
84981: PUSH
84982: LD_INT 2
84984: NEG
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 3
84992: NEG
84993: PUSH
84994: LD_INT 3
84996: NEG
84997: PUSH
84998: EMPTY
84999: LIST
85000: LIST
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: LIST
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: LIST
85030: LIST
85031: LIST
85032: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85033: LD_ADDR_VAR 0 43
85037: PUSH
85038: LD_INT 0
85040: PUSH
85041: LD_INT 0
85043: PUSH
85044: EMPTY
85045: LIST
85046: LIST
85047: PUSH
85048: LD_INT 0
85050: PUSH
85051: LD_INT 1
85053: NEG
85054: PUSH
85055: EMPTY
85056: LIST
85057: LIST
85058: PUSH
85059: LD_INT 1
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: PUSH
85069: LD_INT 1
85071: PUSH
85072: LD_INT 1
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 0
85081: PUSH
85082: LD_INT 1
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_INT 1
85091: NEG
85092: PUSH
85093: LD_INT 0
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 1
85102: NEG
85103: PUSH
85104: LD_INT 1
85106: NEG
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 1
85114: NEG
85115: PUSH
85116: LD_INT 2
85118: NEG
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 0
85126: PUSH
85127: LD_INT 2
85129: NEG
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: PUSH
85135: LD_INT 1
85137: PUSH
85138: LD_INT 1
85140: NEG
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 2
85148: PUSH
85149: LD_INT 0
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 2
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 1
85168: PUSH
85169: LD_INT 2
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 0
85178: PUSH
85179: LD_INT 2
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 1
85188: NEG
85189: PUSH
85190: LD_INT 1
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_INT 2
85199: NEG
85200: PUSH
85201: LD_INT 0
85203: PUSH
85204: EMPTY
85205: LIST
85206: LIST
85207: PUSH
85208: LD_INT 2
85210: NEG
85211: PUSH
85212: LD_INT 1
85214: NEG
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: PUSH
85220: LD_INT 1
85222: NEG
85223: PUSH
85224: LD_INT 3
85226: NEG
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: LD_INT 3
85237: NEG
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 1
85245: PUSH
85246: LD_INT 2
85248: NEG
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: PUSH
85254: LD_INT 2
85256: PUSH
85257: LD_INT 1
85259: NEG
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 3
85267: PUSH
85268: LD_INT 0
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 3
85277: PUSH
85278: LD_INT 1
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: LD_INT 1
85287: PUSH
85288: LD_INT 3
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 0
85297: PUSH
85298: LD_INT 3
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: PUSH
85305: LD_INT 1
85307: NEG
85308: PUSH
85309: LD_INT 2
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 2
85318: NEG
85319: PUSH
85320: LD_INT 1
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 3
85329: NEG
85330: PUSH
85331: LD_INT 0
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 3
85340: NEG
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: LIST
85363: LIST
85364: LIST
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85381: LD_ADDR_VAR 0 44
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 0
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 0
85398: PUSH
85399: LD_INT 1
85401: NEG
85402: PUSH
85403: EMPTY
85404: LIST
85405: LIST
85406: PUSH
85407: LD_INT 1
85409: PUSH
85410: LD_INT 0
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: PUSH
85417: LD_INT 1
85419: PUSH
85420: LD_INT 1
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 0
85429: PUSH
85430: LD_INT 1
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_INT 1
85439: NEG
85440: PUSH
85441: LD_INT 0
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: LD_INT 1
85450: NEG
85451: PUSH
85452: LD_INT 1
85454: NEG
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 1
85462: NEG
85463: PUSH
85464: LD_INT 2
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 1
85474: PUSH
85475: LD_INT 1
85477: NEG
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 2
85485: PUSH
85486: LD_INT 0
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 2
85495: PUSH
85496: LD_INT 1
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 2
85505: PUSH
85506: LD_INT 2
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 1
85515: PUSH
85516: LD_INT 2
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: LD_INT 1
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 2
85536: NEG
85537: PUSH
85538: LD_INT 0
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 2
85547: NEG
85548: PUSH
85549: LD_INT 1
85551: NEG
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: PUSH
85557: LD_INT 2
85559: NEG
85560: PUSH
85561: LD_INT 2
85563: NEG
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 2
85571: NEG
85572: PUSH
85573: LD_INT 3
85575: NEG
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 2
85583: PUSH
85584: LD_INT 1
85586: NEG
85587: PUSH
85588: EMPTY
85589: LIST
85590: LIST
85591: PUSH
85592: LD_INT 3
85594: PUSH
85595: LD_INT 0
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 3
85604: PUSH
85605: LD_INT 1
85607: PUSH
85608: EMPTY
85609: LIST
85610: LIST
85611: PUSH
85612: LD_INT 3
85614: PUSH
85615: LD_INT 2
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 3
85624: PUSH
85625: LD_INT 3
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: LD_INT 3
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 2
85644: NEG
85645: PUSH
85646: LD_INT 1
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 3
85655: NEG
85656: PUSH
85657: LD_INT 0
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 3
85666: NEG
85667: PUSH
85668: LD_INT 1
85670: NEG
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: LD_INT 3
85678: NEG
85679: PUSH
85680: LD_INT 2
85682: NEG
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 3
85690: NEG
85691: PUSH
85692: LD_INT 3
85694: NEG
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85731: LD_ADDR_VAR 0 45
85735: PUSH
85736: LD_INT 0
85738: PUSH
85739: LD_INT 0
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 0
85748: PUSH
85749: LD_INT 1
85751: NEG
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PUSH
85757: LD_INT 1
85759: PUSH
85760: LD_INT 0
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 1
85769: PUSH
85770: LD_INT 1
85772: PUSH
85773: EMPTY
85774: LIST
85775: LIST
85776: PUSH
85777: LD_INT 0
85779: PUSH
85780: LD_INT 1
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PUSH
85787: LD_INT 1
85789: NEG
85790: PUSH
85791: LD_INT 0
85793: PUSH
85794: EMPTY
85795: LIST
85796: LIST
85797: PUSH
85798: LD_INT 1
85800: NEG
85801: PUSH
85802: LD_INT 1
85804: NEG
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 1
85812: NEG
85813: PUSH
85814: LD_INT 2
85816: NEG
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 0
85824: PUSH
85825: LD_INT 2
85827: NEG
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: PUSH
85836: LD_INT 1
85838: NEG
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 2
85846: PUSH
85847: LD_INT 1
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 2
85856: PUSH
85857: LD_INT 2
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 1
85866: PUSH
85867: LD_INT 2
85869: PUSH
85870: EMPTY
85871: LIST
85872: LIST
85873: PUSH
85874: LD_INT 0
85876: PUSH
85877: LD_INT 2
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 1
85886: NEG
85887: PUSH
85888: LD_INT 1
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: PUSH
85895: LD_INT 2
85897: NEG
85898: PUSH
85899: LD_INT 1
85901: NEG
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 2
85909: NEG
85910: PUSH
85911: LD_INT 2
85913: NEG
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: LD_INT 2
85921: NEG
85922: PUSH
85923: LD_INT 3
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: NEG
85934: PUSH
85935: LD_INT 3
85937: NEG
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: PUSH
85943: LD_INT 0
85945: PUSH
85946: LD_INT 3
85948: NEG
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: LD_INT 2
85959: NEG
85960: PUSH
85961: EMPTY
85962: LIST
85963: LIST
85964: PUSH
85965: LD_INT 3
85967: PUSH
85968: LD_INT 2
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 3
85977: PUSH
85978: LD_INT 3
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: LD_INT 2
85987: PUSH
85988: LD_INT 3
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: PUSH
85995: LD_INT 1
85997: PUSH
85998: LD_INT 3
86000: PUSH
86001: EMPTY
86002: LIST
86003: LIST
86004: PUSH
86005: LD_INT 0
86007: PUSH
86008: LD_INT 3
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 1
86017: NEG
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 3
86028: NEG
86029: PUSH
86030: LD_INT 2
86032: NEG
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 3
86040: NEG
86041: PUSH
86042: LD_INT 3
86044: NEG
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: LIST
86080: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86081: LD_ADDR_VAR 0 46
86085: PUSH
86086: LD_INT 0
86088: PUSH
86089: LD_INT 0
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: LD_INT 0
86098: PUSH
86099: LD_INT 1
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 1
86109: PUSH
86110: LD_INT 0
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 1
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 0
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 1
86139: NEG
86140: PUSH
86141: LD_INT 0
86143: PUSH
86144: EMPTY
86145: LIST
86146: LIST
86147: PUSH
86148: LD_INT 1
86150: NEG
86151: PUSH
86152: LD_INT 1
86154: NEG
86155: PUSH
86156: EMPTY
86157: LIST
86158: LIST
86159: PUSH
86160: LD_INT 1
86162: NEG
86163: PUSH
86164: LD_INT 2
86166: NEG
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 0
86174: PUSH
86175: LD_INT 2
86177: NEG
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: LD_INT 1
86185: PUSH
86186: LD_INT 1
86188: NEG
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 2
86196: PUSH
86197: LD_INT 0
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 2
86206: PUSH
86207: LD_INT 1
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 1
86216: PUSH
86217: LD_INT 2
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 0
86226: PUSH
86227: LD_INT 2
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: LD_INT 1
86236: NEG
86237: PUSH
86238: LD_INT 1
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 2
86247: NEG
86248: PUSH
86249: LD_INT 0
86251: PUSH
86252: EMPTY
86253: LIST
86254: LIST
86255: PUSH
86256: LD_INT 2
86258: NEG
86259: PUSH
86260: LD_INT 1
86262: NEG
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 1
86270: NEG
86271: PUSH
86272: LD_INT 3
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 0
86282: PUSH
86283: LD_INT 3
86285: NEG
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 1
86293: PUSH
86294: LD_INT 2
86296: NEG
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 2
86304: PUSH
86305: LD_INT 1
86307: NEG
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: PUSH
86313: LD_INT 3
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 3
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: EMPTY
86330: LIST
86331: LIST
86332: PUSH
86333: LD_INT 1
86335: PUSH
86336: LD_INT 3
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 0
86345: PUSH
86346: LD_INT 3
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 1
86355: NEG
86356: PUSH
86357: LD_INT 2
86359: PUSH
86360: EMPTY
86361: LIST
86362: LIST
86363: PUSH
86364: LD_INT 2
86366: NEG
86367: PUSH
86368: LD_INT 1
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 3
86377: NEG
86378: PUSH
86379: LD_INT 0
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 3
86388: NEG
86389: PUSH
86390: LD_INT 1
86392: NEG
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86429: LD_ADDR_VAR 0 47
86433: PUSH
86434: LD_INT 0
86436: PUSH
86437: LD_INT 0
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: PUSH
86444: LD_INT 0
86446: PUSH
86447: LD_INT 1
86449: NEG
86450: PUSH
86451: EMPTY
86452: LIST
86453: LIST
86454: PUSH
86455: LD_INT 1
86457: PUSH
86458: LD_INT 0
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 1
86467: PUSH
86468: LD_INT 1
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 0
86477: PUSH
86478: LD_INT 1
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 1
86487: NEG
86488: PUSH
86489: LD_INT 0
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PUSH
86496: LD_INT 1
86498: NEG
86499: PUSH
86500: LD_INT 1
86502: NEG
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 1
86510: NEG
86511: PUSH
86512: LD_INT 2
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 0
86522: PUSH
86523: LD_INT 2
86525: NEG
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 1
86533: PUSH
86534: LD_INT 1
86536: NEG
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 2
86544: NEG
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 2
86556: NEG
86557: PUSH
86558: LD_INT 2
86560: NEG
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86580: LD_ADDR_VAR 0 48
86584: PUSH
86585: LD_INT 0
86587: PUSH
86588: LD_INT 0
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: LD_INT 0
86597: PUSH
86598: LD_INT 1
86600: NEG
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 1
86608: PUSH
86609: LD_INT 0
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 1
86618: PUSH
86619: LD_INT 1
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 0
86628: PUSH
86629: LD_INT 1
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: LD_INT 1
86638: NEG
86639: PUSH
86640: LD_INT 0
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 1
86649: NEG
86650: PUSH
86651: LD_INT 1
86653: NEG
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 1
86661: NEG
86662: PUSH
86663: LD_INT 2
86665: NEG
86666: PUSH
86667: EMPTY
86668: LIST
86669: LIST
86670: PUSH
86671: LD_INT 0
86673: PUSH
86674: LD_INT 2
86676: NEG
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 1
86684: PUSH
86685: LD_INT 1
86687: NEG
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 2
86695: PUSH
86696: LD_INT 0
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 2
86705: PUSH
86706: LD_INT 1
86708: PUSH
86709: EMPTY
86710: LIST
86711: LIST
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: LIST
86726: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86727: LD_ADDR_VAR 0 49
86731: PUSH
86732: LD_INT 0
86734: PUSH
86735: LD_INT 0
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 0
86744: PUSH
86745: LD_INT 1
86747: NEG
86748: PUSH
86749: EMPTY
86750: LIST
86751: LIST
86752: PUSH
86753: LD_INT 1
86755: PUSH
86756: LD_INT 0
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 1
86765: PUSH
86766: LD_INT 1
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PUSH
86773: LD_INT 0
86775: PUSH
86776: LD_INT 1
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 1
86785: NEG
86786: PUSH
86787: LD_INT 0
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: PUSH
86794: LD_INT 1
86796: NEG
86797: PUSH
86798: LD_INT 1
86800: NEG
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 1
86808: PUSH
86809: LD_INT 1
86811: NEG
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: LD_INT 0
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 2
86829: PUSH
86830: LD_INT 1
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 2
86839: PUSH
86840: LD_INT 2
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: PUSH
86850: LD_INT 2
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86871: LD_ADDR_VAR 0 50
86875: PUSH
86876: LD_INT 0
86878: PUSH
86879: LD_INT 0
86881: PUSH
86882: EMPTY
86883: LIST
86884: LIST
86885: PUSH
86886: LD_INT 0
86888: PUSH
86889: LD_INT 1
86891: NEG
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 1
86899: PUSH
86900: LD_INT 0
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 1
86909: PUSH
86910: LD_INT 1
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 0
86919: PUSH
86920: LD_INT 1
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 1
86929: NEG
86930: PUSH
86931: LD_INT 0
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 1
86940: NEG
86941: PUSH
86942: LD_INT 1
86944: NEG
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 2
86952: PUSH
86953: LD_INT 1
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 2
86962: PUSH
86963: LD_INT 2
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: PUSH
86973: LD_INT 2
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 0
86982: PUSH
86983: LD_INT 2
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 1
86992: NEG
86993: PUSH
86994: LD_INT 1
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87015: LD_ADDR_VAR 0 51
87019: PUSH
87020: LD_INT 0
87022: PUSH
87023: LD_INT 0
87025: PUSH
87026: EMPTY
87027: LIST
87028: LIST
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: LD_INT 1
87035: NEG
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 1
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 1
87053: PUSH
87054: LD_INT 1
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: PUSH
87061: LD_INT 0
87063: PUSH
87064: LD_INT 1
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 1
87073: NEG
87074: PUSH
87075: LD_INT 0
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 1
87084: NEG
87085: PUSH
87086: LD_INT 1
87088: NEG
87089: PUSH
87090: EMPTY
87091: LIST
87092: LIST
87093: PUSH
87094: LD_INT 1
87096: PUSH
87097: LD_INT 2
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 0
87106: PUSH
87107: LD_INT 2
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 1
87116: NEG
87117: PUSH
87118: LD_INT 1
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 2
87127: NEG
87128: PUSH
87129: LD_INT 0
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 2
87138: NEG
87139: PUSH
87140: LD_INT 1
87142: NEG
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87162: LD_ADDR_VAR 0 52
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: LD_INT 0
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 0
87179: PUSH
87180: LD_INT 1
87182: NEG
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 1
87190: PUSH
87191: LD_INT 0
87193: PUSH
87194: EMPTY
87195: LIST
87196: LIST
87197: PUSH
87198: LD_INT 1
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: LD_INT 0
87210: PUSH
87211: LD_INT 1
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 1
87220: NEG
87221: PUSH
87222: LD_INT 0
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 1
87231: NEG
87232: PUSH
87233: LD_INT 1
87235: NEG
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 1
87243: NEG
87244: PUSH
87245: LD_INT 2
87247: NEG
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: PUSH
87253: LD_INT 1
87255: NEG
87256: PUSH
87257: LD_INT 1
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 2
87266: NEG
87267: PUSH
87268: LD_INT 0
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 2
87277: NEG
87278: PUSH
87279: LD_INT 1
87281: NEG
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 2
87289: NEG
87290: PUSH
87291: LD_INT 2
87293: NEG
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: LIST
87303: LIST
87304: LIST
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87313: LD_ADDR_VAR 0 53
87317: PUSH
87318: LD_INT 0
87320: PUSH
87321: LD_INT 0
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 0
87330: PUSH
87331: LD_INT 1
87333: NEG
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 1
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 1
87351: PUSH
87352: LD_INT 1
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: PUSH
87359: LD_INT 0
87361: PUSH
87362: LD_INT 1
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 1
87371: NEG
87372: PUSH
87373: LD_INT 0
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 1
87382: NEG
87383: PUSH
87384: LD_INT 1
87386: NEG
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 1
87394: NEG
87395: PUSH
87396: LD_INT 2
87398: NEG
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: PUSH
87404: LD_INT 0
87406: PUSH
87407: LD_INT 2
87409: NEG
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 1
87417: PUSH
87418: LD_INT 1
87420: NEG
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 2
87428: PUSH
87429: LD_INT 0
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 2
87438: PUSH
87439: LD_INT 1
87441: PUSH
87442: EMPTY
87443: LIST
87444: LIST
87445: PUSH
87446: LD_INT 2
87448: PUSH
87449: LD_INT 2
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 1
87458: PUSH
87459: LD_INT 2
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PUSH
87466: LD_INT 0
87468: PUSH
87469: LD_INT 2
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: LD_INT 1
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: LD_INT 2
87489: NEG
87490: PUSH
87491: LD_INT 0
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 2
87500: NEG
87501: PUSH
87502: LD_INT 1
87504: NEG
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PUSH
87510: LD_INT 2
87512: NEG
87513: PUSH
87514: LD_INT 2
87516: NEG
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: LIST
87541: LIST
87542: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87543: LD_ADDR_VAR 0 54
87547: PUSH
87548: LD_INT 0
87550: PUSH
87551: LD_INT 0
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: LD_INT 0
87560: PUSH
87561: LD_INT 1
87563: NEG
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 1
87571: PUSH
87572: LD_INT 0
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 1
87581: PUSH
87582: LD_INT 1
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 0
87591: PUSH
87592: LD_INT 1
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 1
87601: NEG
87602: PUSH
87603: LD_INT 0
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: PUSH
87610: LD_INT 1
87612: NEG
87613: PUSH
87614: LD_INT 1
87616: NEG
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PUSH
87622: LD_INT 1
87624: NEG
87625: PUSH
87626: LD_INT 2
87628: NEG
87629: PUSH
87630: EMPTY
87631: LIST
87632: LIST
87633: PUSH
87634: LD_INT 0
87636: PUSH
87637: LD_INT 2
87639: NEG
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 1
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 2
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PUSH
87666: LD_INT 2
87668: PUSH
87669: LD_INT 1
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: LD_INT 2
87678: PUSH
87679: LD_INT 2
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 1
87688: PUSH
87689: LD_INT 2
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 0
87698: PUSH
87699: LD_INT 2
87701: PUSH
87702: EMPTY
87703: LIST
87704: LIST
87705: PUSH
87706: LD_INT 1
87708: NEG
87709: PUSH
87710: LD_INT 1
87712: PUSH
87713: EMPTY
87714: LIST
87715: LIST
87716: PUSH
87717: LD_INT 2
87719: NEG
87720: PUSH
87721: LD_INT 0
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: PUSH
87728: LD_INT 2
87730: NEG
87731: PUSH
87732: LD_INT 1
87734: NEG
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 2
87742: NEG
87743: PUSH
87744: LD_INT 2
87746: NEG
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87773: LD_ADDR_VAR 0 55
87777: PUSH
87778: LD_INT 0
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 0
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: LD_INT 1
87801: PUSH
87802: LD_INT 0
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PUSH
87809: LD_INT 1
87811: PUSH
87812: LD_INT 1
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 0
87821: PUSH
87822: LD_INT 1
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 1
87831: NEG
87832: PUSH
87833: LD_INT 0
87835: PUSH
87836: EMPTY
87837: LIST
87838: LIST
87839: PUSH
87840: LD_INT 1
87842: NEG
87843: PUSH
87844: LD_INT 1
87846: NEG
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 1
87854: NEG
87855: PUSH
87856: LD_INT 2
87858: NEG
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: LD_INT 2
87869: NEG
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 1
87877: PUSH
87878: LD_INT 1
87880: NEG
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: PUSH
87889: LD_INT 0
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 2
87898: PUSH
87899: LD_INT 1
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 2
87908: PUSH
87909: LD_INT 2
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 1
87918: PUSH
87919: LD_INT 2
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 0
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 1
87938: NEG
87939: PUSH
87940: LD_INT 1
87942: PUSH
87943: EMPTY
87944: LIST
87945: LIST
87946: PUSH
87947: LD_INT 2
87949: NEG
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 2
87960: NEG
87961: PUSH
87962: LD_INT 1
87964: NEG
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: PUSH
87970: LD_INT 2
87972: NEG
87973: PUSH
87974: LD_INT 2
87976: NEG
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: EMPTY
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88003: LD_ADDR_VAR 0 56
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 0
88020: PUSH
88021: LD_INT 1
88023: NEG
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 1
88031: PUSH
88032: LD_INT 0
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: LD_INT 1
88041: PUSH
88042: LD_INT 1
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 0
88051: PUSH
88052: LD_INT 1
88054: PUSH
88055: EMPTY
88056: LIST
88057: LIST
88058: PUSH
88059: LD_INT 1
88061: NEG
88062: PUSH
88063: LD_INT 0
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 1
88072: NEG
88073: PUSH
88074: LD_INT 1
88076: NEG
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: LD_INT 2
88088: NEG
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 0
88096: PUSH
88097: LD_INT 2
88099: NEG
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: PUSH
88108: LD_INT 1
88110: NEG
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 2
88118: PUSH
88119: LD_INT 0
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 2
88128: PUSH
88129: LD_INT 1
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 2
88138: PUSH
88139: LD_INT 2
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: LD_INT 1
88148: PUSH
88149: LD_INT 2
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 0
88158: PUSH
88159: LD_INT 2
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: PUSH
88166: LD_INT 1
88168: NEG
88169: PUSH
88170: LD_INT 1
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: LD_INT 2
88179: NEG
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 2
88190: NEG
88191: PUSH
88192: LD_INT 1
88194: NEG
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: PUSH
88200: LD_INT 2
88202: NEG
88203: PUSH
88204: LD_INT 2
88206: NEG
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88233: LD_ADDR_VAR 0 57
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 0
88250: PUSH
88251: LD_INT 1
88253: NEG
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 1
88261: PUSH
88262: LD_INT 0
88264: PUSH
88265: EMPTY
88266: LIST
88267: LIST
88268: PUSH
88269: LD_INT 1
88271: PUSH
88272: LD_INT 1
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 0
88281: PUSH
88282: LD_INT 1
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PUSH
88289: LD_INT 1
88291: NEG
88292: PUSH
88293: LD_INT 0
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 1
88302: NEG
88303: PUSH
88304: LD_INT 1
88306: NEG
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 1
88314: NEG
88315: PUSH
88316: LD_INT 2
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 0
88326: PUSH
88327: LD_INT 2
88329: NEG
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: PUSH
88335: LD_INT 1
88337: PUSH
88338: LD_INT 1
88340: NEG
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 2
88348: PUSH
88349: LD_INT 0
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 2
88358: PUSH
88359: LD_INT 1
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 2
88368: PUSH
88369: LD_INT 2
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 1
88378: PUSH
88379: LD_INT 2
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 0
88388: PUSH
88389: LD_INT 2
88391: PUSH
88392: EMPTY
88393: LIST
88394: LIST
88395: PUSH
88396: LD_INT 1
88398: NEG
88399: PUSH
88400: LD_INT 1
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: PUSH
88407: LD_INT 2
88409: NEG
88410: PUSH
88411: LD_INT 0
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 2
88420: NEG
88421: PUSH
88422: LD_INT 1
88424: NEG
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 2
88432: NEG
88433: PUSH
88434: LD_INT 2
88436: NEG
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88463: LD_ADDR_VAR 0 58
88467: PUSH
88468: LD_INT 0
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 0
88480: PUSH
88481: LD_INT 1
88483: NEG
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 1
88491: PUSH
88492: LD_INT 0
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 1
88501: PUSH
88502: LD_INT 1
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: LD_INT 1
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 1
88521: NEG
88522: PUSH
88523: LD_INT 0
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 1
88532: NEG
88533: PUSH
88534: LD_INT 1
88536: NEG
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 1
88544: NEG
88545: PUSH
88546: LD_INT 2
88548: NEG
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 0
88556: PUSH
88557: LD_INT 2
88559: NEG
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 1
88567: PUSH
88568: LD_INT 1
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 2
88578: PUSH
88579: LD_INT 0
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 2
88588: PUSH
88589: LD_INT 1
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 2
88598: PUSH
88599: LD_INT 2
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 1
88608: PUSH
88609: LD_INT 2
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 0
88618: PUSH
88619: LD_INT 2
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: LD_INT 1
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 2
88639: NEG
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: EMPTY
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 2
88650: NEG
88651: PUSH
88652: LD_INT 1
88654: NEG
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 2
88662: NEG
88663: PUSH
88664: LD_INT 2
88666: NEG
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88693: LD_ADDR_VAR 0 59
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 0
88710: PUSH
88711: LD_INT 1
88713: NEG
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 1
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 0
88741: PUSH
88742: LD_INT 1
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 1
88751: NEG
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 1
88762: NEG
88763: PUSH
88764: LD_INT 1
88766: NEG
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88781: LD_ADDR_VAR 0 60
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 0
88798: PUSH
88799: LD_INT 1
88801: NEG
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 1
88809: PUSH
88810: LD_INT 0
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 1
88819: PUSH
88820: LD_INT 1
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: LD_INT 1
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 1
88839: NEG
88840: PUSH
88841: LD_INT 0
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 1
88850: NEG
88851: PUSH
88852: LD_INT 1
88854: NEG
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88869: LD_ADDR_VAR 0 61
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: LD_INT 0
88879: PUSH
88880: EMPTY
88881: LIST
88882: LIST
88883: PUSH
88884: LD_INT 0
88886: PUSH
88887: LD_INT 1
88889: NEG
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 1
88897: PUSH
88898: LD_INT 0
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 1
88907: PUSH
88908: LD_INT 1
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: LD_INT 1
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 1
88927: NEG
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 1
88938: NEG
88939: PUSH
88940: LD_INT 1
88942: NEG
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88957: LD_ADDR_VAR 0 62
88961: PUSH
88962: LD_INT 0
88964: PUSH
88965: LD_INT 0
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 0
88974: PUSH
88975: LD_INT 1
88977: NEG
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 1
88985: PUSH
88986: LD_INT 0
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: PUSH
88996: LD_INT 1
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 0
89005: PUSH
89006: LD_INT 1
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 1
89015: NEG
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 1
89026: NEG
89027: PUSH
89028: LD_INT 1
89030: NEG
89031: PUSH
89032: EMPTY
89033: LIST
89034: LIST
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: LIST
89042: LIST
89043: LIST
89044: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89045: LD_ADDR_VAR 0 63
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 0
89062: PUSH
89063: LD_INT 1
89065: NEG
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 1
89073: PUSH
89074: LD_INT 0
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 1
89083: PUSH
89084: LD_INT 1
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 0
89093: PUSH
89094: LD_INT 1
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 1
89103: NEG
89104: PUSH
89105: LD_INT 0
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 1
89114: NEG
89115: PUSH
89116: LD_INT 1
89118: NEG
89119: PUSH
89120: EMPTY
89121: LIST
89122: LIST
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89133: LD_ADDR_VAR 0 64
89137: PUSH
89138: LD_INT 0
89140: PUSH
89141: LD_INT 0
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 0
89150: PUSH
89151: LD_INT 1
89153: NEG
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: LD_INT 0
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 0
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: PUSH
89189: LD_INT 1
89191: NEG
89192: PUSH
89193: LD_INT 0
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 1
89202: NEG
89203: PUSH
89204: LD_INT 1
89206: NEG
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: EMPTY
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: ST_TO_ADDR
// end ; 1 :
89221: GO 95118
89223: LD_INT 1
89225: DOUBLE
89226: EQUAL
89227: IFTRUE 89231
89229: GO 91854
89231: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89232: LD_ADDR_VAR 0 11
89236: PUSH
89237: LD_INT 1
89239: NEG
89240: PUSH
89241: LD_INT 3
89243: NEG
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: PUSH
89249: LD_INT 0
89251: PUSH
89252: LD_INT 3
89254: NEG
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 1
89262: PUSH
89263: LD_INT 2
89265: NEG
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: LIST
89275: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89276: LD_ADDR_VAR 0 12
89280: PUSH
89281: LD_INT 2
89283: PUSH
89284: LD_INT 1
89286: NEG
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: LD_INT 3
89294: PUSH
89295: LD_INT 0
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 3
89304: PUSH
89305: LD_INT 1
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: LIST
89316: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89317: LD_ADDR_VAR 0 13
89321: PUSH
89322: LD_INT 3
89324: PUSH
89325: LD_INT 2
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 3
89334: PUSH
89335: LD_INT 3
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 2
89344: PUSH
89345: LD_INT 3
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: LIST
89356: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89357: LD_ADDR_VAR 0 14
89361: PUSH
89362: LD_INT 1
89364: PUSH
89365: LD_INT 3
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 0
89374: PUSH
89375: LD_INT 3
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 1
89384: NEG
89385: PUSH
89386: LD_INT 2
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: EMPTY
89394: LIST
89395: LIST
89396: LIST
89397: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89398: LD_ADDR_VAR 0 15
89402: PUSH
89403: LD_INT 2
89405: NEG
89406: PUSH
89407: LD_INT 1
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: PUSH
89414: LD_INT 3
89416: NEG
89417: PUSH
89418: LD_INT 0
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: LD_INT 3
89427: NEG
89428: PUSH
89429: LD_INT 1
89431: NEG
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: LIST
89441: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89442: LD_ADDR_VAR 0 16
89446: PUSH
89447: LD_INT 2
89449: NEG
89450: PUSH
89451: LD_INT 3
89453: NEG
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 3
89461: NEG
89462: PUSH
89463: LD_INT 2
89465: NEG
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 3
89473: NEG
89474: PUSH
89475: LD_INT 3
89477: NEG
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: LIST
89487: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89488: LD_ADDR_VAR 0 17
89492: PUSH
89493: LD_INT 1
89495: NEG
89496: PUSH
89497: LD_INT 3
89499: NEG
89500: PUSH
89501: EMPTY
89502: LIST
89503: LIST
89504: PUSH
89505: LD_INT 0
89507: PUSH
89508: LD_INT 3
89510: NEG
89511: PUSH
89512: EMPTY
89513: LIST
89514: LIST
89515: PUSH
89516: LD_INT 1
89518: PUSH
89519: LD_INT 2
89521: NEG
89522: PUSH
89523: EMPTY
89524: LIST
89525: LIST
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: LIST
89531: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89532: LD_ADDR_VAR 0 18
89536: PUSH
89537: LD_INT 2
89539: PUSH
89540: LD_INT 1
89542: NEG
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: LD_INT 3
89550: PUSH
89551: LD_INT 0
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 3
89560: PUSH
89561: LD_INT 1
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: LIST
89572: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89573: LD_ADDR_VAR 0 19
89577: PUSH
89578: LD_INT 3
89580: PUSH
89581: LD_INT 2
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 3
89590: PUSH
89591: LD_INT 3
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 2
89600: PUSH
89601: LD_INT 3
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: LIST
89612: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89613: LD_ADDR_VAR 0 20
89617: PUSH
89618: LD_INT 1
89620: PUSH
89621: LD_INT 3
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 0
89630: PUSH
89631: LD_INT 3
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 1
89640: NEG
89641: PUSH
89642: LD_INT 2
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: LIST
89653: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89654: LD_ADDR_VAR 0 21
89658: PUSH
89659: LD_INT 2
89661: NEG
89662: PUSH
89663: LD_INT 1
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 3
89672: NEG
89673: PUSH
89674: LD_INT 0
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 3
89683: NEG
89684: PUSH
89685: LD_INT 1
89687: NEG
89688: PUSH
89689: EMPTY
89690: LIST
89691: LIST
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: LIST
89697: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89698: LD_ADDR_VAR 0 22
89702: PUSH
89703: LD_INT 2
89705: NEG
89706: PUSH
89707: LD_INT 3
89709: NEG
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 3
89717: NEG
89718: PUSH
89719: LD_INT 2
89721: NEG
89722: PUSH
89723: EMPTY
89724: LIST
89725: LIST
89726: PUSH
89727: LD_INT 3
89729: NEG
89730: PUSH
89731: LD_INT 3
89733: NEG
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: LIST
89743: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89744: LD_ADDR_VAR 0 23
89748: PUSH
89749: LD_INT 0
89751: PUSH
89752: LD_INT 3
89754: NEG
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 1
89762: NEG
89763: PUSH
89764: LD_INT 4
89766: NEG
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: LD_INT 3
89777: NEG
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: EMPTY
89784: LIST
89785: LIST
89786: LIST
89787: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89788: LD_ADDR_VAR 0 24
89792: PUSH
89793: LD_INT 3
89795: PUSH
89796: LD_INT 0
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: LD_INT 3
89805: PUSH
89806: LD_INT 1
89808: NEG
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: LD_INT 4
89816: PUSH
89817: LD_INT 1
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: EMPTY
89825: LIST
89826: LIST
89827: LIST
89828: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89829: LD_ADDR_VAR 0 25
89833: PUSH
89834: LD_INT 3
89836: PUSH
89837: LD_INT 3
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 4
89846: PUSH
89847: LD_INT 3
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 3
89856: PUSH
89857: LD_INT 4
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: EMPTY
89865: LIST
89866: LIST
89867: LIST
89868: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89869: LD_ADDR_VAR 0 26
89873: PUSH
89874: LD_INT 0
89876: PUSH
89877: LD_INT 3
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: LD_INT 1
89886: PUSH
89887: LD_INT 4
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 1
89896: NEG
89897: PUSH
89898: LD_INT 3
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: LIST
89909: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89910: LD_ADDR_VAR 0 27
89914: PUSH
89915: LD_INT 3
89917: NEG
89918: PUSH
89919: LD_INT 0
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 3
89928: NEG
89929: PUSH
89930: LD_INT 1
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 4
89939: NEG
89940: PUSH
89941: LD_INT 1
89943: NEG
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: LIST
89953: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89954: LD_ADDR_VAR 0 28
89958: PUSH
89959: LD_INT 3
89961: NEG
89962: PUSH
89963: LD_INT 3
89965: NEG
89966: PUSH
89967: EMPTY
89968: LIST
89969: LIST
89970: PUSH
89971: LD_INT 3
89973: NEG
89974: PUSH
89975: LD_INT 4
89977: NEG
89978: PUSH
89979: EMPTY
89980: LIST
89981: LIST
89982: PUSH
89983: LD_INT 4
89985: NEG
89986: PUSH
89987: LD_INT 3
89989: NEG
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: LIST
89999: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90000: LD_ADDR_VAR 0 29
90004: PUSH
90005: LD_INT 1
90007: NEG
90008: PUSH
90009: LD_INT 3
90011: NEG
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 0
90019: PUSH
90020: LD_INT 3
90022: NEG
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: LD_INT 1
90030: PUSH
90031: LD_INT 2
90033: NEG
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: PUSH
90039: LD_INT 1
90041: NEG
90042: PUSH
90043: LD_INT 4
90045: NEG
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 0
90053: PUSH
90054: LD_INT 4
90056: NEG
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: LD_INT 3
90067: NEG
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 1
90075: NEG
90076: PUSH
90077: LD_INT 5
90079: NEG
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: PUSH
90085: LD_INT 0
90087: PUSH
90088: LD_INT 5
90090: NEG
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 1
90098: PUSH
90099: LD_INT 4
90101: NEG
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: PUSH
90107: LD_INT 1
90109: NEG
90110: PUSH
90111: LD_INT 6
90113: NEG
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 0
90121: PUSH
90122: LD_INT 6
90124: NEG
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 1
90132: PUSH
90133: LD_INT 5
90135: NEG
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90155: LD_ADDR_VAR 0 30
90159: PUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 1
90165: NEG
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 3
90173: PUSH
90174: LD_INT 0
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 3
90183: PUSH
90184: LD_INT 1
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 3
90193: PUSH
90194: LD_INT 1
90196: NEG
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 4
90204: PUSH
90205: LD_INT 0
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 4
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 4
90224: PUSH
90225: LD_INT 1
90227: NEG
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 5
90235: PUSH
90236: LD_INT 0
90238: PUSH
90239: EMPTY
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 5
90245: PUSH
90246: LD_INT 1
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PUSH
90253: LD_INT 5
90255: PUSH
90256: LD_INT 1
90258: NEG
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 6
90266: PUSH
90267: LD_INT 0
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 6
90276: PUSH
90277: LD_INT 1
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: EMPTY
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90298: LD_ADDR_VAR 0 31
90302: PUSH
90303: LD_INT 3
90305: PUSH
90306: LD_INT 2
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 3
90315: PUSH
90316: LD_INT 3
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 2
90325: PUSH
90326: LD_INT 3
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 4
90335: PUSH
90336: LD_INT 3
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 4
90345: PUSH
90346: LD_INT 4
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PUSH
90353: LD_INT 3
90355: PUSH
90356: LD_INT 4
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 5
90365: PUSH
90366: LD_INT 4
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 5
90375: PUSH
90376: LD_INT 5
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PUSH
90383: LD_INT 4
90385: PUSH
90386: LD_INT 5
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 6
90395: PUSH
90396: LD_INT 5
90398: PUSH
90399: EMPTY
90400: LIST
90401: LIST
90402: PUSH
90403: LD_INT 6
90405: PUSH
90406: LD_INT 6
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 5
90415: PUSH
90416: LD_INT 6
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90437: LD_ADDR_VAR 0 32
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: LD_INT 3
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 0
90454: PUSH
90455: LD_INT 3
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 1
90464: NEG
90465: PUSH
90466: LD_INT 2
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 1
90475: PUSH
90476: LD_INT 4
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 0
90485: PUSH
90486: LD_INT 4
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 1
90495: NEG
90496: PUSH
90497: LD_INT 3
90499: PUSH
90500: EMPTY
90501: LIST
90502: LIST
90503: PUSH
90504: LD_INT 1
90506: PUSH
90507: LD_INT 5
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 0
90516: PUSH
90517: LD_INT 5
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 1
90526: NEG
90527: PUSH
90528: LD_INT 4
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: LD_INT 1
90537: PUSH
90538: LD_INT 6
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: PUSH
90545: LD_INT 0
90547: PUSH
90548: LD_INT 6
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: PUSH
90555: LD_INT 1
90557: NEG
90558: PUSH
90559: LD_INT 5
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90580: LD_ADDR_VAR 0 33
90584: PUSH
90585: LD_INT 2
90587: NEG
90588: PUSH
90589: LD_INT 1
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 3
90598: NEG
90599: PUSH
90600: LD_INT 0
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 3
90609: NEG
90610: PUSH
90611: LD_INT 1
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 3
90621: NEG
90622: PUSH
90623: LD_INT 1
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 4
90632: NEG
90633: PUSH
90634: LD_INT 0
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 4
90643: NEG
90644: PUSH
90645: LD_INT 1
90647: NEG
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 4
90655: NEG
90656: PUSH
90657: LD_INT 1
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 5
90666: NEG
90667: PUSH
90668: LD_INT 0
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 5
90677: NEG
90678: PUSH
90679: LD_INT 1
90681: NEG
90682: PUSH
90683: EMPTY
90684: LIST
90685: LIST
90686: PUSH
90687: LD_INT 5
90689: NEG
90690: PUSH
90691: LD_INT 1
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 6
90700: NEG
90701: PUSH
90702: LD_INT 0
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: LD_INT 6
90711: NEG
90712: PUSH
90713: LD_INT 1
90715: NEG
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90735: LD_ADDR_VAR 0 34
90739: PUSH
90740: LD_INT 2
90742: NEG
90743: PUSH
90744: LD_INT 3
90746: NEG
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: PUSH
90752: LD_INT 3
90754: NEG
90755: PUSH
90756: LD_INT 2
90758: NEG
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 3
90766: NEG
90767: PUSH
90768: LD_INT 3
90770: NEG
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 3
90778: NEG
90779: PUSH
90780: LD_INT 4
90782: NEG
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: PUSH
90788: LD_INT 4
90790: NEG
90791: PUSH
90792: LD_INT 3
90794: NEG
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 4
90802: NEG
90803: PUSH
90804: LD_INT 4
90806: NEG
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 4
90814: NEG
90815: PUSH
90816: LD_INT 5
90818: NEG
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 5
90826: NEG
90827: PUSH
90828: LD_INT 4
90830: NEG
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 5
90838: NEG
90839: PUSH
90840: LD_INT 5
90842: NEG
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 5
90850: NEG
90851: PUSH
90852: LD_INT 6
90854: NEG
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 6
90862: NEG
90863: PUSH
90864: LD_INT 5
90866: NEG
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 6
90874: NEG
90875: PUSH
90876: LD_INT 6
90878: NEG
90879: PUSH
90880: EMPTY
90881: LIST
90882: LIST
90883: PUSH
90884: EMPTY
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90898: LD_ADDR_VAR 0 41
90902: PUSH
90903: LD_INT 0
90905: PUSH
90906: LD_INT 2
90908: NEG
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 1
90916: NEG
90917: PUSH
90918: LD_INT 3
90920: NEG
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: LD_INT 2
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: LIST
90941: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90942: LD_ADDR_VAR 0 42
90946: PUSH
90947: LD_INT 2
90949: PUSH
90950: LD_INT 0
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 2
90959: PUSH
90960: LD_INT 1
90962: NEG
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: LD_INT 3
90970: PUSH
90971: LD_INT 1
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: LIST
90982: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90983: LD_ADDR_VAR 0 43
90987: PUSH
90988: LD_INT 2
90990: PUSH
90991: LD_INT 2
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 3
91000: PUSH
91001: LD_INT 2
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 2
91010: PUSH
91011: LD_INT 3
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: LIST
91022: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91023: LD_ADDR_VAR 0 44
91027: PUSH
91028: LD_INT 0
91030: PUSH
91031: LD_INT 2
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 1
91040: PUSH
91041: LD_INT 3
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 1
91050: NEG
91051: PUSH
91052: LD_INT 2
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: LIST
91063: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91064: LD_ADDR_VAR 0 45
91068: PUSH
91069: LD_INT 2
91071: NEG
91072: PUSH
91073: LD_INT 0
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PUSH
91080: LD_INT 2
91082: NEG
91083: PUSH
91084: LD_INT 1
91086: PUSH
91087: EMPTY
91088: LIST
91089: LIST
91090: PUSH
91091: LD_INT 3
91093: NEG
91094: PUSH
91095: LD_INT 1
91097: NEG
91098: PUSH
91099: EMPTY
91100: LIST
91101: LIST
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: LIST
91107: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91108: LD_ADDR_VAR 0 46
91112: PUSH
91113: LD_INT 2
91115: NEG
91116: PUSH
91117: LD_INT 2
91119: NEG
91120: PUSH
91121: EMPTY
91122: LIST
91123: LIST
91124: PUSH
91125: LD_INT 2
91127: NEG
91128: PUSH
91129: LD_INT 3
91131: NEG
91132: PUSH
91133: EMPTY
91134: LIST
91135: LIST
91136: PUSH
91137: LD_INT 3
91139: NEG
91140: PUSH
91141: LD_INT 2
91143: NEG
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: LIST
91153: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91154: LD_ADDR_VAR 0 47
91158: PUSH
91159: LD_INT 2
91161: NEG
91162: PUSH
91163: LD_INT 3
91165: NEG
91166: PUSH
91167: EMPTY
91168: LIST
91169: LIST
91170: PUSH
91171: LD_INT 1
91173: NEG
91174: PUSH
91175: LD_INT 3
91177: NEG
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91187: LD_ADDR_VAR 0 48
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: LD_INT 2
91197: NEG
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PUSH
91203: LD_INT 2
91205: PUSH
91206: LD_INT 1
91208: NEG
91209: PUSH
91210: EMPTY
91211: LIST
91212: LIST
91213: PUSH
91214: EMPTY
91215: LIST
91216: LIST
91217: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91218: LD_ADDR_VAR 0 49
91222: PUSH
91223: LD_INT 3
91225: PUSH
91226: LD_INT 1
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 3
91235: PUSH
91236: LD_INT 2
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91247: LD_ADDR_VAR 0 50
91251: PUSH
91252: LD_INT 2
91254: PUSH
91255: LD_INT 3
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 1
91264: PUSH
91265: LD_INT 3
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91276: LD_ADDR_VAR 0 51
91280: PUSH
91281: LD_INT 1
91283: NEG
91284: PUSH
91285: LD_INT 2
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 2
91294: NEG
91295: PUSH
91296: LD_INT 1
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91307: LD_ADDR_VAR 0 52
91311: PUSH
91312: LD_INT 3
91314: NEG
91315: PUSH
91316: LD_INT 1
91318: NEG
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 3
91326: NEG
91327: PUSH
91328: LD_INT 2
91330: NEG
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91340: LD_ADDR_VAR 0 53
91344: PUSH
91345: LD_INT 1
91347: NEG
91348: PUSH
91349: LD_INT 3
91351: NEG
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 0
91359: PUSH
91360: LD_INT 3
91362: NEG
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: PUSH
91371: LD_INT 2
91373: NEG
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: LIST
91383: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91384: LD_ADDR_VAR 0 54
91388: PUSH
91389: LD_INT 2
91391: PUSH
91392: LD_INT 1
91394: NEG
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: LD_INT 3
91402: PUSH
91403: LD_INT 0
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 3
91412: PUSH
91413: LD_INT 1
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: PUSH
91420: EMPTY
91421: LIST
91422: LIST
91423: LIST
91424: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91425: LD_ADDR_VAR 0 55
91429: PUSH
91430: LD_INT 3
91432: PUSH
91433: LD_INT 2
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 3
91442: PUSH
91443: LD_INT 3
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 2
91452: PUSH
91453: LD_INT 3
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: LIST
91464: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91465: LD_ADDR_VAR 0 56
91469: PUSH
91470: LD_INT 1
91472: PUSH
91473: LD_INT 3
91475: PUSH
91476: EMPTY
91477: LIST
91478: LIST
91479: PUSH
91480: LD_INT 0
91482: PUSH
91483: LD_INT 3
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 1
91492: NEG
91493: PUSH
91494: LD_INT 2
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: LIST
91505: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91506: LD_ADDR_VAR 0 57
91510: PUSH
91511: LD_INT 2
91513: NEG
91514: PUSH
91515: LD_INT 1
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: LD_INT 3
91524: NEG
91525: PUSH
91526: LD_INT 0
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 3
91535: NEG
91536: PUSH
91537: LD_INT 1
91539: NEG
91540: PUSH
91541: EMPTY
91542: LIST
91543: LIST
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: LIST
91549: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91550: LD_ADDR_VAR 0 58
91554: PUSH
91555: LD_INT 2
91557: NEG
91558: PUSH
91559: LD_INT 3
91561: NEG
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 3
91569: NEG
91570: PUSH
91571: LD_INT 2
91573: NEG
91574: PUSH
91575: EMPTY
91576: LIST
91577: LIST
91578: PUSH
91579: LD_INT 3
91581: NEG
91582: PUSH
91583: LD_INT 3
91585: NEG
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: LIST
91595: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91596: LD_ADDR_VAR 0 59
91600: PUSH
91601: LD_INT 1
91603: NEG
91604: PUSH
91605: LD_INT 2
91607: NEG
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 0
91615: PUSH
91616: LD_INT 2
91618: NEG
91619: PUSH
91620: EMPTY
91621: LIST
91622: LIST
91623: PUSH
91624: LD_INT 1
91626: PUSH
91627: LD_INT 1
91629: NEG
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: PUSH
91635: EMPTY
91636: LIST
91637: LIST
91638: LIST
91639: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91640: LD_ADDR_VAR 0 60
91644: PUSH
91645: LD_INT 1
91647: PUSH
91648: LD_INT 1
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: LD_INT 2
91658: PUSH
91659: LD_INT 0
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: LD_INT 1
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: EMPTY
91677: LIST
91678: LIST
91679: LIST
91680: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91681: LD_ADDR_VAR 0 61
91685: PUSH
91686: LD_INT 2
91688: PUSH
91689: LD_INT 1
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 2
91698: PUSH
91699: LD_INT 2
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 1
91708: PUSH
91709: LD_INT 2
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: LIST
91720: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91721: LD_ADDR_VAR 0 62
91725: PUSH
91726: LD_INT 1
91728: PUSH
91729: LD_INT 2
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 0
91738: PUSH
91739: LD_INT 2
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 1
91748: NEG
91749: PUSH
91750: LD_INT 1
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: LIST
91761: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91762: LD_ADDR_VAR 0 63
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: LD_INT 1
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 2
91780: NEG
91781: PUSH
91782: LD_INT 0
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 2
91791: NEG
91792: PUSH
91793: LD_INT 1
91795: NEG
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: LIST
91805: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91806: LD_ADDR_VAR 0 64
91810: PUSH
91811: LD_INT 1
91813: NEG
91814: PUSH
91815: LD_INT 2
91817: NEG
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 2
91825: NEG
91826: PUSH
91827: LD_INT 1
91829: NEG
91830: PUSH
91831: EMPTY
91832: LIST
91833: LIST
91834: PUSH
91835: LD_INT 2
91837: NEG
91838: PUSH
91839: LD_INT 2
91841: NEG
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: LIST
91851: ST_TO_ADDR
// end ; 2 :
91852: GO 95118
91854: LD_INT 2
91856: DOUBLE
91857: EQUAL
91858: IFTRUE 91862
91860: GO 95117
91862: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91863: LD_ADDR_VAR 0 29
91867: PUSH
91868: LD_INT 4
91870: PUSH
91871: LD_INT 0
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 4
91880: PUSH
91881: LD_INT 1
91883: NEG
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: LD_INT 5
91891: PUSH
91892: LD_INT 0
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PUSH
91899: LD_INT 5
91901: PUSH
91902: LD_INT 1
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 4
91911: PUSH
91912: LD_INT 1
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: PUSH
91919: LD_INT 3
91921: PUSH
91922: LD_INT 0
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 3
91931: PUSH
91932: LD_INT 1
91934: NEG
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PUSH
91940: LD_INT 3
91942: PUSH
91943: LD_INT 2
91945: NEG
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 5
91953: PUSH
91954: LD_INT 2
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: LD_INT 3
91963: PUSH
91964: LD_INT 3
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: PUSH
91971: LD_INT 3
91973: PUSH
91974: LD_INT 2
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 4
91983: PUSH
91984: LD_INT 3
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 4
91993: PUSH
91994: LD_INT 4
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: LD_INT 3
92003: PUSH
92004: LD_INT 4
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: PUSH
92011: LD_INT 2
92013: PUSH
92014: LD_INT 3
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 2
92023: PUSH
92024: LD_INT 2
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 4
92033: PUSH
92034: LD_INT 2
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 2
92043: PUSH
92044: LD_INT 4
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 0
92053: PUSH
92054: LD_INT 4
92056: PUSH
92057: EMPTY
92058: LIST
92059: LIST
92060: PUSH
92061: LD_INT 0
92063: PUSH
92064: LD_INT 3
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: PUSH
92071: LD_INT 1
92073: PUSH
92074: LD_INT 4
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: PUSH
92081: LD_INT 1
92083: PUSH
92084: LD_INT 5
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: LD_INT 0
92093: PUSH
92094: LD_INT 5
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 1
92103: NEG
92104: PUSH
92105: LD_INT 4
92107: PUSH
92108: EMPTY
92109: LIST
92110: LIST
92111: PUSH
92112: LD_INT 1
92114: NEG
92115: PUSH
92116: LD_INT 3
92118: PUSH
92119: EMPTY
92120: LIST
92121: LIST
92122: PUSH
92123: LD_INT 2
92125: PUSH
92126: LD_INT 5
92128: PUSH
92129: EMPTY
92130: LIST
92131: LIST
92132: PUSH
92133: LD_INT 2
92135: NEG
92136: PUSH
92137: LD_INT 3
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 3
92146: NEG
92147: PUSH
92148: LD_INT 0
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: PUSH
92155: LD_INT 3
92157: NEG
92158: PUSH
92159: LD_INT 1
92161: NEG
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: LD_INT 2
92169: NEG
92170: PUSH
92171: LD_INT 0
92173: PUSH
92174: EMPTY
92175: LIST
92176: LIST
92177: PUSH
92178: LD_INT 2
92180: NEG
92181: PUSH
92182: LD_INT 1
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: PUSH
92189: LD_INT 3
92191: NEG
92192: PUSH
92193: LD_INT 1
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: LD_INT 4
92202: NEG
92203: PUSH
92204: LD_INT 0
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PUSH
92211: LD_INT 4
92213: NEG
92214: PUSH
92215: LD_INT 1
92217: NEG
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 4
92225: NEG
92226: PUSH
92227: LD_INT 2
92229: NEG
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 2
92237: NEG
92238: PUSH
92239: LD_INT 2
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 4
92248: NEG
92249: PUSH
92250: LD_INT 4
92252: NEG
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 4
92260: NEG
92261: PUSH
92262: LD_INT 5
92264: NEG
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PUSH
92270: LD_INT 3
92272: NEG
92273: PUSH
92274: LD_INT 4
92276: NEG
92277: PUSH
92278: EMPTY
92279: LIST
92280: LIST
92281: PUSH
92282: LD_INT 3
92284: NEG
92285: PUSH
92286: LD_INT 3
92288: NEG
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 4
92296: NEG
92297: PUSH
92298: LD_INT 3
92300: NEG
92301: PUSH
92302: EMPTY
92303: LIST
92304: LIST
92305: PUSH
92306: LD_INT 5
92308: NEG
92309: PUSH
92310: LD_INT 4
92312: NEG
92313: PUSH
92314: EMPTY
92315: LIST
92316: LIST
92317: PUSH
92318: LD_INT 5
92320: NEG
92321: PUSH
92322: LD_INT 5
92324: NEG
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 3
92332: NEG
92333: PUSH
92334: LD_INT 5
92336: NEG
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 5
92344: NEG
92345: PUSH
92346: LD_INT 3
92348: NEG
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: LIST
92391: LIST
92392: LIST
92393: LIST
92394: LIST
92395: LIST
92396: LIST
92397: LIST
92398: LIST
92399: LIST
92400: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92401: LD_ADDR_VAR 0 30
92405: PUSH
92406: LD_INT 4
92408: PUSH
92409: LD_INT 4
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 4
92418: PUSH
92419: LD_INT 3
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 5
92428: PUSH
92429: LD_INT 4
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 5
92438: PUSH
92439: LD_INT 5
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: LD_INT 4
92448: PUSH
92449: LD_INT 5
92451: PUSH
92452: EMPTY
92453: LIST
92454: LIST
92455: PUSH
92456: LD_INT 3
92458: PUSH
92459: LD_INT 4
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: LD_INT 3
92468: PUSH
92469: LD_INT 3
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 5
92478: PUSH
92479: LD_INT 3
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 3
92488: PUSH
92489: LD_INT 5
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 0
92498: PUSH
92499: LD_INT 3
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: LD_INT 0
92508: PUSH
92509: LD_INT 2
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 1
92518: PUSH
92519: LD_INT 3
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: LD_INT 1
92528: PUSH
92529: LD_INT 4
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: PUSH
92536: LD_INT 0
92538: PUSH
92539: LD_INT 4
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 1
92548: NEG
92549: PUSH
92550: LD_INT 3
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: LD_INT 1
92559: NEG
92560: PUSH
92561: LD_INT 2
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 2
92570: PUSH
92571: LD_INT 4
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 2
92580: NEG
92581: PUSH
92582: LD_INT 2
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PUSH
92589: LD_INT 4
92591: NEG
92592: PUSH
92593: LD_INT 0
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PUSH
92600: LD_INT 4
92602: NEG
92603: PUSH
92604: LD_INT 1
92606: NEG
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: LD_INT 3
92614: NEG
92615: PUSH
92616: LD_INT 0
92618: PUSH
92619: EMPTY
92620: LIST
92621: LIST
92622: PUSH
92623: LD_INT 3
92625: NEG
92626: PUSH
92627: LD_INT 1
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 4
92636: NEG
92637: PUSH
92638: LD_INT 1
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: PUSH
92645: LD_INT 5
92647: NEG
92648: PUSH
92649: LD_INT 0
92651: PUSH
92652: EMPTY
92653: LIST
92654: LIST
92655: PUSH
92656: LD_INT 5
92658: NEG
92659: PUSH
92660: LD_INT 1
92662: NEG
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: PUSH
92668: LD_INT 5
92670: NEG
92671: PUSH
92672: LD_INT 2
92674: NEG
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 3
92682: NEG
92683: PUSH
92684: LD_INT 2
92686: PUSH
92687: EMPTY
92688: LIST
92689: LIST
92690: PUSH
92691: LD_INT 3
92693: NEG
92694: PUSH
92695: LD_INT 3
92697: NEG
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 3
92705: NEG
92706: PUSH
92707: LD_INT 4
92709: NEG
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 2
92717: NEG
92718: PUSH
92719: LD_INT 3
92721: NEG
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PUSH
92727: LD_INT 2
92729: NEG
92730: PUSH
92731: LD_INT 2
92733: NEG
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 3
92741: NEG
92742: PUSH
92743: LD_INT 2
92745: NEG
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 4
92753: NEG
92754: PUSH
92755: LD_INT 3
92757: NEG
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 4
92765: NEG
92766: PUSH
92767: LD_INT 4
92769: NEG
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 2
92777: NEG
92778: PUSH
92779: LD_INT 4
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 4
92789: NEG
92790: PUSH
92791: LD_INT 2
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 0
92801: PUSH
92802: LD_INT 4
92804: NEG
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: LD_INT 0
92812: PUSH
92813: LD_INT 5
92815: NEG
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: PUSH
92821: LD_INT 1
92823: PUSH
92824: LD_INT 4
92826: NEG
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: PUSH
92832: LD_INT 1
92834: PUSH
92835: LD_INT 3
92837: NEG
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 0
92845: PUSH
92846: LD_INT 3
92848: NEG
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 1
92856: NEG
92857: PUSH
92858: LD_INT 4
92860: NEG
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 1
92868: NEG
92869: PUSH
92870: LD_INT 5
92872: NEG
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 2
92880: PUSH
92881: LD_INT 3
92883: NEG
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 2
92891: NEG
92892: PUSH
92893: LD_INT 5
92895: NEG
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: LIST
92935: LIST
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: LIST
92944: LIST
92945: LIST
92946: LIST
92947: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92948: LD_ADDR_VAR 0 31
92952: PUSH
92953: LD_INT 0
92955: PUSH
92956: LD_INT 4
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 0
92965: PUSH
92966: LD_INT 3
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 1
92975: PUSH
92976: LD_INT 4
92978: PUSH
92979: EMPTY
92980: LIST
92981: LIST
92982: PUSH
92983: LD_INT 1
92985: PUSH
92986: LD_INT 5
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: PUSH
92993: LD_INT 0
92995: PUSH
92996: LD_INT 5
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 1
93005: NEG
93006: PUSH
93007: LD_INT 4
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: PUSH
93014: LD_INT 1
93016: NEG
93017: PUSH
93018: LD_INT 3
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 2
93027: PUSH
93028: LD_INT 5
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 2
93037: NEG
93038: PUSH
93039: LD_INT 3
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 3
93048: NEG
93049: PUSH
93050: LD_INT 0
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: PUSH
93057: LD_INT 3
93059: NEG
93060: PUSH
93061: LD_INT 1
93063: NEG
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 2
93071: NEG
93072: PUSH
93073: LD_INT 0
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: LD_INT 2
93082: NEG
93083: PUSH
93084: LD_INT 1
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 3
93093: NEG
93094: PUSH
93095: LD_INT 1
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 4
93104: NEG
93105: PUSH
93106: LD_INT 0
93108: PUSH
93109: EMPTY
93110: LIST
93111: LIST
93112: PUSH
93113: LD_INT 4
93115: NEG
93116: PUSH
93117: LD_INT 1
93119: NEG
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 4
93127: NEG
93128: PUSH
93129: LD_INT 2
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 2
93139: NEG
93140: PUSH
93141: LD_INT 2
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 4
93150: NEG
93151: PUSH
93152: LD_INT 4
93154: NEG
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 4
93162: NEG
93163: PUSH
93164: LD_INT 5
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: LD_INT 3
93174: NEG
93175: PUSH
93176: LD_INT 4
93178: NEG
93179: PUSH
93180: EMPTY
93181: LIST
93182: LIST
93183: PUSH
93184: LD_INT 3
93186: NEG
93187: PUSH
93188: LD_INT 3
93190: NEG
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 4
93198: NEG
93199: PUSH
93200: LD_INT 3
93202: NEG
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: PUSH
93208: LD_INT 5
93210: NEG
93211: PUSH
93212: LD_INT 4
93214: NEG
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 5
93222: NEG
93223: PUSH
93224: LD_INT 5
93226: NEG
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PUSH
93232: LD_INT 3
93234: NEG
93235: PUSH
93236: LD_INT 5
93238: NEG
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 5
93246: NEG
93247: PUSH
93248: LD_INT 3
93250: NEG
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 0
93258: PUSH
93259: LD_INT 3
93261: NEG
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: PUSH
93267: LD_INT 0
93269: PUSH
93270: LD_INT 4
93272: NEG
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 1
93280: PUSH
93281: LD_INT 3
93283: NEG
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 1
93291: PUSH
93292: LD_INT 2
93294: NEG
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: PUSH
93300: LD_INT 0
93302: PUSH
93303: LD_INT 2
93305: NEG
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: LD_INT 1
93313: NEG
93314: PUSH
93315: LD_INT 3
93317: NEG
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: LD_INT 1
93325: NEG
93326: PUSH
93327: LD_INT 4
93329: NEG
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: PUSH
93335: LD_INT 2
93337: PUSH
93338: LD_INT 2
93340: NEG
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: PUSH
93346: LD_INT 2
93348: NEG
93349: PUSH
93350: LD_INT 4
93352: NEG
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 4
93360: PUSH
93361: LD_INT 0
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 4
93370: PUSH
93371: LD_INT 1
93373: NEG
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: PUSH
93379: LD_INT 5
93381: PUSH
93382: LD_INT 0
93384: PUSH
93385: EMPTY
93386: LIST
93387: LIST
93388: PUSH
93389: LD_INT 5
93391: PUSH
93392: LD_INT 1
93394: PUSH
93395: EMPTY
93396: LIST
93397: LIST
93398: PUSH
93399: LD_INT 4
93401: PUSH
93402: LD_INT 1
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 3
93411: PUSH
93412: LD_INT 0
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: LD_INT 3
93421: PUSH
93422: LD_INT 1
93424: NEG
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 3
93432: PUSH
93433: LD_INT 2
93435: NEG
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 5
93443: PUSH
93444: LD_INT 2
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: PUSH
93451: EMPTY
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: LIST
93464: LIST
93465: LIST
93466: LIST
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93498: LD_ADDR_VAR 0 32
93502: PUSH
93503: LD_INT 4
93505: NEG
93506: PUSH
93507: LD_INT 0
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: LD_INT 4
93516: NEG
93517: PUSH
93518: LD_INT 1
93520: NEG
93521: PUSH
93522: EMPTY
93523: LIST
93524: LIST
93525: PUSH
93526: LD_INT 3
93528: NEG
93529: PUSH
93530: LD_INT 0
93532: PUSH
93533: EMPTY
93534: LIST
93535: LIST
93536: PUSH
93537: LD_INT 3
93539: NEG
93540: PUSH
93541: LD_INT 1
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 4
93550: NEG
93551: PUSH
93552: LD_INT 1
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: PUSH
93559: LD_INT 5
93561: NEG
93562: PUSH
93563: LD_INT 0
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PUSH
93570: LD_INT 5
93572: NEG
93573: PUSH
93574: LD_INT 1
93576: NEG
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: PUSH
93582: LD_INT 5
93584: NEG
93585: PUSH
93586: LD_INT 2
93588: NEG
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 3
93596: NEG
93597: PUSH
93598: LD_INT 2
93600: PUSH
93601: EMPTY
93602: LIST
93603: LIST
93604: PUSH
93605: LD_INT 3
93607: NEG
93608: PUSH
93609: LD_INT 3
93611: NEG
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: PUSH
93617: LD_INT 3
93619: NEG
93620: PUSH
93621: LD_INT 4
93623: NEG
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 2
93631: NEG
93632: PUSH
93633: LD_INT 3
93635: NEG
93636: PUSH
93637: EMPTY
93638: LIST
93639: LIST
93640: PUSH
93641: LD_INT 2
93643: NEG
93644: PUSH
93645: LD_INT 2
93647: NEG
93648: PUSH
93649: EMPTY
93650: LIST
93651: LIST
93652: PUSH
93653: LD_INT 3
93655: NEG
93656: PUSH
93657: LD_INT 2
93659: NEG
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 4
93667: NEG
93668: PUSH
93669: LD_INT 3
93671: NEG
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PUSH
93677: LD_INT 4
93679: NEG
93680: PUSH
93681: LD_INT 4
93683: NEG
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 2
93691: NEG
93692: PUSH
93693: LD_INT 4
93695: NEG
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 4
93703: NEG
93704: PUSH
93705: LD_INT 2
93707: NEG
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: PUSH
93713: LD_INT 0
93715: PUSH
93716: LD_INT 4
93718: NEG
93719: PUSH
93720: EMPTY
93721: LIST
93722: LIST
93723: PUSH
93724: LD_INT 0
93726: PUSH
93727: LD_INT 5
93729: NEG
93730: PUSH
93731: EMPTY
93732: LIST
93733: LIST
93734: PUSH
93735: LD_INT 1
93737: PUSH
93738: LD_INT 4
93740: NEG
93741: PUSH
93742: EMPTY
93743: LIST
93744: LIST
93745: PUSH
93746: LD_INT 1
93748: PUSH
93749: LD_INT 3
93751: NEG
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: LD_INT 0
93759: PUSH
93760: LD_INT 3
93762: NEG
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: PUSH
93768: LD_INT 1
93770: NEG
93771: PUSH
93772: LD_INT 4
93774: NEG
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PUSH
93780: LD_INT 1
93782: NEG
93783: PUSH
93784: LD_INT 5
93786: NEG
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 2
93794: PUSH
93795: LD_INT 3
93797: NEG
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 2
93805: NEG
93806: PUSH
93807: LD_INT 5
93809: NEG
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 3
93817: PUSH
93818: LD_INT 0
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 3
93827: PUSH
93828: LD_INT 1
93830: NEG
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: LD_INT 4
93838: PUSH
93839: LD_INT 0
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 4
93848: PUSH
93849: LD_INT 1
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 3
93858: PUSH
93859: LD_INT 1
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 2
93868: PUSH
93869: LD_INT 0
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: LD_INT 2
93878: PUSH
93879: LD_INT 1
93881: NEG
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: PUSH
93887: LD_INT 2
93889: PUSH
93890: LD_INT 2
93892: NEG
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: LD_INT 4
93900: PUSH
93901: LD_INT 2
93903: PUSH
93904: EMPTY
93905: LIST
93906: LIST
93907: PUSH
93908: LD_INT 4
93910: PUSH
93911: LD_INT 4
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 4
93920: PUSH
93921: LD_INT 3
93923: PUSH
93924: EMPTY
93925: LIST
93926: LIST
93927: PUSH
93928: LD_INT 5
93930: PUSH
93931: LD_INT 4
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 5
93940: PUSH
93941: LD_INT 5
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: LD_INT 4
93950: PUSH
93951: LD_INT 5
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: LD_INT 3
93960: PUSH
93961: LD_INT 4
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: PUSH
93968: LD_INT 3
93970: PUSH
93971: LD_INT 3
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 5
93980: PUSH
93981: LD_INT 3
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 3
93990: PUSH
93991: LD_INT 5
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94045: LD_ADDR_VAR 0 33
94049: PUSH
94050: LD_INT 4
94052: NEG
94053: PUSH
94054: LD_INT 4
94056: NEG
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 4
94064: NEG
94065: PUSH
94066: LD_INT 5
94068: NEG
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 3
94076: NEG
94077: PUSH
94078: LD_INT 4
94080: NEG
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: LD_INT 3
94088: NEG
94089: PUSH
94090: LD_INT 3
94092: NEG
94093: PUSH
94094: EMPTY
94095: LIST
94096: LIST
94097: PUSH
94098: LD_INT 4
94100: NEG
94101: PUSH
94102: LD_INT 3
94104: NEG
94105: PUSH
94106: EMPTY
94107: LIST
94108: LIST
94109: PUSH
94110: LD_INT 5
94112: NEG
94113: PUSH
94114: LD_INT 4
94116: NEG
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 5
94124: NEG
94125: PUSH
94126: LD_INT 5
94128: NEG
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PUSH
94134: LD_INT 3
94136: NEG
94137: PUSH
94138: LD_INT 5
94140: NEG
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 5
94148: NEG
94149: PUSH
94150: LD_INT 3
94152: NEG
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 0
94160: PUSH
94161: LD_INT 3
94163: NEG
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 0
94171: PUSH
94172: LD_INT 4
94174: NEG
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: PUSH
94180: LD_INT 1
94182: PUSH
94183: LD_INT 3
94185: NEG
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 1
94193: PUSH
94194: LD_INT 2
94196: NEG
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: PUSH
94202: LD_INT 0
94204: PUSH
94205: LD_INT 2
94207: NEG
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 1
94215: NEG
94216: PUSH
94217: LD_INT 3
94219: NEG
94220: PUSH
94221: EMPTY
94222: LIST
94223: LIST
94224: PUSH
94225: LD_INT 1
94227: NEG
94228: PUSH
94229: LD_INT 4
94231: NEG
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: PUSH
94237: LD_INT 2
94239: PUSH
94240: LD_INT 2
94242: NEG
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 2
94250: NEG
94251: PUSH
94252: LD_INT 4
94254: NEG
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: PUSH
94260: LD_INT 4
94262: PUSH
94263: LD_INT 0
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: LD_INT 4
94272: PUSH
94273: LD_INT 1
94275: NEG
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 5
94283: PUSH
94284: LD_INT 0
94286: PUSH
94287: EMPTY
94288: LIST
94289: LIST
94290: PUSH
94291: LD_INT 5
94293: PUSH
94294: LD_INT 1
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: PUSH
94301: LD_INT 4
94303: PUSH
94304: LD_INT 1
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: PUSH
94311: LD_INT 3
94313: PUSH
94314: LD_INT 0
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 3
94323: PUSH
94324: LD_INT 1
94326: NEG
94327: PUSH
94328: EMPTY
94329: LIST
94330: LIST
94331: PUSH
94332: LD_INT 3
94334: PUSH
94335: LD_INT 2
94337: NEG
94338: PUSH
94339: EMPTY
94340: LIST
94341: LIST
94342: PUSH
94343: LD_INT 5
94345: PUSH
94346: LD_INT 2
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 3
94355: PUSH
94356: LD_INT 3
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 3
94365: PUSH
94366: LD_INT 2
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 4
94375: PUSH
94376: LD_INT 3
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 4
94385: PUSH
94386: LD_INT 4
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: LD_INT 3
94395: PUSH
94396: LD_INT 4
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: PUSH
94403: LD_INT 2
94405: PUSH
94406: LD_INT 3
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 2
94415: PUSH
94416: LD_INT 2
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: PUSH
94423: LD_INT 4
94425: PUSH
94426: LD_INT 2
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: LD_INT 2
94435: PUSH
94436: LD_INT 4
94438: PUSH
94439: EMPTY
94440: LIST
94441: LIST
94442: PUSH
94443: LD_INT 0
94445: PUSH
94446: LD_INT 4
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: PUSH
94453: LD_INT 0
94455: PUSH
94456: LD_INT 3
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: PUSH
94463: LD_INT 1
94465: PUSH
94466: LD_INT 4
94468: PUSH
94469: EMPTY
94470: LIST
94471: LIST
94472: PUSH
94473: LD_INT 1
94475: PUSH
94476: LD_INT 5
94478: PUSH
94479: EMPTY
94480: LIST
94481: LIST
94482: PUSH
94483: LD_INT 0
94485: PUSH
94486: LD_INT 5
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 1
94495: NEG
94496: PUSH
94497: LD_INT 4
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PUSH
94504: LD_INT 1
94506: NEG
94507: PUSH
94508: LD_INT 3
94510: PUSH
94511: EMPTY
94512: LIST
94513: LIST
94514: PUSH
94515: LD_INT 2
94517: PUSH
94518: LD_INT 5
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 2
94527: NEG
94528: PUSH
94529: LD_INT 3
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: EMPTY
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94583: LD_ADDR_VAR 0 34
94587: PUSH
94588: LD_INT 0
94590: PUSH
94591: LD_INT 4
94593: NEG
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: PUSH
94599: LD_INT 0
94601: PUSH
94602: LD_INT 5
94604: NEG
94605: PUSH
94606: EMPTY
94607: LIST
94608: LIST
94609: PUSH
94610: LD_INT 1
94612: PUSH
94613: LD_INT 4
94615: NEG
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: PUSH
94621: LD_INT 1
94623: PUSH
94624: LD_INT 3
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 0
94634: PUSH
94635: LD_INT 3
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 1
94645: NEG
94646: PUSH
94647: LD_INT 4
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 1
94657: NEG
94658: PUSH
94659: LD_INT 5
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 2
94669: PUSH
94670: LD_INT 3
94672: NEG
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: LD_INT 2
94680: NEG
94681: PUSH
94682: LD_INT 5
94684: NEG
94685: PUSH
94686: EMPTY
94687: LIST
94688: LIST
94689: PUSH
94690: LD_INT 3
94692: PUSH
94693: LD_INT 0
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: LD_INT 3
94702: PUSH
94703: LD_INT 1
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 4
94713: PUSH
94714: LD_INT 0
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 4
94723: PUSH
94724: LD_INT 1
94726: PUSH
94727: EMPTY
94728: LIST
94729: LIST
94730: PUSH
94731: LD_INT 3
94733: PUSH
94734: LD_INT 1
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 2
94743: PUSH
94744: LD_INT 0
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 2
94753: PUSH
94754: LD_INT 1
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 2
94764: PUSH
94765: LD_INT 2
94767: NEG
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: PUSH
94773: LD_INT 4
94775: PUSH
94776: LD_INT 2
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: LD_INT 4
94788: PUSH
94789: EMPTY
94790: LIST
94791: LIST
94792: PUSH
94793: LD_INT 4
94795: PUSH
94796: LD_INT 3
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PUSH
94803: LD_INT 5
94805: PUSH
94806: LD_INT 4
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: LD_INT 5
94815: PUSH
94816: LD_INT 5
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 4
94825: PUSH
94826: LD_INT 5
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 3
94835: PUSH
94836: LD_INT 4
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: PUSH
94843: LD_INT 3
94845: PUSH
94846: LD_INT 3
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: PUSH
94853: LD_INT 5
94855: PUSH
94856: LD_INT 3
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: PUSH
94863: LD_INT 3
94865: PUSH
94866: LD_INT 5
94868: PUSH
94869: EMPTY
94870: LIST
94871: LIST
94872: PUSH
94873: LD_INT 0
94875: PUSH
94876: LD_INT 3
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: LD_INT 0
94885: PUSH
94886: LD_INT 2
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 1
94895: PUSH
94896: LD_INT 3
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PUSH
94903: LD_INT 1
94905: PUSH
94906: LD_INT 4
94908: PUSH
94909: EMPTY
94910: LIST
94911: LIST
94912: PUSH
94913: LD_INT 0
94915: PUSH
94916: LD_INT 4
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: PUSH
94923: LD_INT 1
94925: NEG
94926: PUSH
94927: LD_INT 3
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 1
94936: NEG
94937: PUSH
94938: LD_INT 2
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 2
94947: PUSH
94948: LD_INT 4
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 2
94957: NEG
94958: PUSH
94959: LD_INT 2
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 4
94968: NEG
94969: PUSH
94970: LD_INT 0
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 4
94979: NEG
94980: PUSH
94981: LD_INT 1
94983: NEG
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: LD_INT 3
94991: NEG
94992: PUSH
94993: LD_INT 0
94995: PUSH
94996: EMPTY
94997: LIST
94998: LIST
94999: PUSH
95000: LD_INT 3
95002: NEG
95003: PUSH
95004: LD_INT 1
95006: PUSH
95007: EMPTY
95008: LIST
95009: LIST
95010: PUSH
95011: LD_INT 4
95013: NEG
95014: PUSH
95015: LD_INT 1
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 5
95024: NEG
95025: PUSH
95026: LD_INT 0
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 5
95035: NEG
95036: PUSH
95037: LD_INT 1
95039: NEG
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: LD_INT 5
95047: NEG
95048: PUSH
95049: LD_INT 2
95051: NEG
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 3
95059: NEG
95060: PUSH
95061: LD_INT 2
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: ST_TO_ADDR
// end ; end ;
95115: GO 95118
95117: POP
// case btype of b_depot , b_warehouse :
95118: LD_VAR 0 1
95122: PUSH
95123: LD_INT 0
95125: DOUBLE
95126: EQUAL
95127: IFTRUE 95137
95129: LD_INT 1
95131: DOUBLE
95132: EQUAL
95133: IFTRUE 95137
95135: GO 95338
95137: POP
// case nation of nation_american :
95138: LD_VAR 0 5
95142: PUSH
95143: LD_INT 1
95145: DOUBLE
95146: EQUAL
95147: IFTRUE 95151
95149: GO 95207
95151: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95152: LD_ADDR_VAR 0 9
95156: PUSH
95157: LD_VAR 0 11
95161: PUSH
95162: LD_VAR 0 12
95166: PUSH
95167: LD_VAR 0 13
95171: PUSH
95172: LD_VAR 0 14
95176: PUSH
95177: LD_VAR 0 15
95181: PUSH
95182: LD_VAR 0 16
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: PUSH
95195: LD_VAR 0 4
95199: PUSH
95200: LD_INT 1
95202: PLUS
95203: ARRAY
95204: ST_TO_ADDR
95205: GO 95336
95207: LD_INT 2
95209: DOUBLE
95210: EQUAL
95211: IFTRUE 95215
95213: GO 95271
95215: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95216: LD_ADDR_VAR 0 9
95220: PUSH
95221: LD_VAR 0 17
95225: PUSH
95226: LD_VAR 0 18
95230: PUSH
95231: LD_VAR 0 19
95235: PUSH
95236: LD_VAR 0 20
95240: PUSH
95241: LD_VAR 0 21
95245: PUSH
95246: LD_VAR 0 22
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: PUSH
95259: LD_VAR 0 4
95263: PUSH
95264: LD_INT 1
95266: PLUS
95267: ARRAY
95268: ST_TO_ADDR
95269: GO 95336
95271: LD_INT 3
95273: DOUBLE
95274: EQUAL
95275: IFTRUE 95279
95277: GO 95335
95279: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95280: LD_ADDR_VAR 0 9
95284: PUSH
95285: LD_VAR 0 23
95289: PUSH
95290: LD_VAR 0 24
95294: PUSH
95295: LD_VAR 0 25
95299: PUSH
95300: LD_VAR 0 26
95304: PUSH
95305: LD_VAR 0 27
95309: PUSH
95310: LD_VAR 0 28
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: PUSH
95323: LD_VAR 0 4
95327: PUSH
95328: LD_INT 1
95330: PLUS
95331: ARRAY
95332: ST_TO_ADDR
95333: GO 95336
95335: POP
95336: GO 95891
95338: LD_INT 2
95340: DOUBLE
95341: EQUAL
95342: IFTRUE 95352
95344: LD_INT 3
95346: DOUBLE
95347: EQUAL
95348: IFTRUE 95352
95350: GO 95408
95352: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95353: LD_ADDR_VAR 0 9
95357: PUSH
95358: LD_VAR 0 29
95362: PUSH
95363: LD_VAR 0 30
95367: PUSH
95368: LD_VAR 0 31
95372: PUSH
95373: LD_VAR 0 32
95377: PUSH
95378: LD_VAR 0 33
95382: PUSH
95383: LD_VAR 0 34
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: PUSH
95396: LD_VAR 0 4
95400: PUSH
95401: LD_INT 1
95403: PLUS
95404: ARRAY
95405: ST_TO_ADDR
95406: GO 95891
95408: LD_INT 16
95410: DOUBLE
95411: EQUAL
95412: IFTRUE 95470
95414: LD_INT 17
95416: DOUBLE
95417: EQUAL
95418: IFTRUE 95470
95420: LD_INT 18
95422: DOUBLE
95423: EQUAL
95424: IFTRUE 95470
95426: LD_INT 19
95428: DOUBLE
95429: EQUAL
95430: IFTRUE 95470
95432: LD_INT 22
95434: DOUBLE
95435: EQUAL
95436: IFTRUE 95470
95438: LD_INT 20
95440: DOUBLE
95441: EQUAL
95442: IFTRUE 95470
95444: LD_INT 21
95446: DOUBLE
95447: EQUAL
95448: IFTRUE 95470
95450: LD_INT 23
95452: DOUBLE
95453: EQUAL
95454: IFTRUE 95470
95456: LD_INT 24
95458: DOUBLE
95459: EQUAL
95460: IFTRUE 95470
95462: LD_INT 25
95464: DOUBLE
95465: EQUAL
95466: IFTRUE 95470
95468: GO 95526
95470: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95471: LD_ADDR_VAR 0 9
95475: PUSH
95476: LD_VAR 0 35
95480: PUSH
95481: LD_VAR 0 36
95485: PUSH
95486: LD_VAR 0 37
95490: PUSH
95491: LD_VAR 0 38
95495: PUSH
95496: LD_VAR 0 39
95500: PUSH
95501: LD_VAR 0 40
95505: PUSH
95506: EMPTY
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: PUSH
95514: LD_VAR 0 4
95518: PUSH
95519: LD_INT 1
95521: PLUS
95522: ARRAY
95523: ST_TO_ADDR
95524: GO 95891
95526: LD_INT 6
95528: DOUBLE
95529: EQUAL
95530: IFTRUE 95582
95532: LD_INT 7
95534: DOUBLE
95535: EQUAL
95536: IFTRUE 95582
95538: LD_INT 8
95540: DOUBLE
95541: EQUAL
95542: IFTRUE 95582
95544: LD_INT 13
95546: DOUBLE
95547: EQUAL
95548: IFTRUE 95582
95550: LD_INT 12
95552: DOUBLE
95553: EQUAL
95554: IFTRUE 95582
95556: LD_INT 15
95558: DOUBLE
95559: EQUAL
95560: IFTRUE 95582
95562: LD_INT 11
95564: DOUBLE
95565: EQUAL
95566: IFTRUE 95582
95568: LD_INT 14
95570: DOUBLE
95571: EQUAL
95572: IFTRUE 95582
95574: LD_INT 10
95576: DOUBLE
95577: EQUAL
95578: IFTRUE 95582
95580: GO 95638
95582: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
95583: LD_ADDR_VAR 0 9
95587: PUSH
95588: LD_VAR 0 41
95592: PUSH
95593: LD_VAR 0 42
95597: PUSH
95598: LD_VAR 0 43
95602: PUSH
95603: LD_VAR 0 44
95607: PUSH
95608: LD_VAR 0 45
95612: PUSH
95613: LD_VAR 0 46
95617: PUSH
95618: EMPTY
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: PUSH
95626: LD_VAR 0 4
95630: PUSH
95631: LD_INT 1
95633: PLUS
95634: ARRAY
95635: ST_TO_ADDR
95636: GO 95891
95638: LD_INT 36
95640: DOUBLE
95641: EQUAL
95642: IFTRUE 95646
95644: GO 95702
95646: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95647: LD_ADDR_VAR 0 9
95651: PUSH
95652: LD_VAR 0 47
95656: PUSH
95657: LD_VAR 0 48
95661: PUSH
95662: LD_VAR 0 49
95666: PUSH
95667: LD_VAR 0 50
95671: PUSH
95672: LD_VAR 0 51
95676: PUSH
95677: LD_VAR 0 52
95681: PUSH
95682: EMPTY
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: PUSH
95690: LD_VAR 0 4
95694: PUSH
95695: LD_INT 1
95697: PLUS
95698: ARRAY
95699: ST_TO_ADDR
95700: GO 95891
95702: LD_INT 4
95704: DOUBLE
95705: EQUAL
95706: IFTRUE 95728
95708: LD_INT 5
95710: DOUBLE
95711: EQUAL
95712: IFTRUE 95728
95714: LD_INT 34
95716: DOUBLE
95717: EQUAL
95718: IFTRUE 95728
95720: LD_INT 37
95722: DOUBLE
95723: EQUAL
95724: IFTRUE 95728
95726: GO 95784
95728: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95729: LD_ADDR_VAR 0 9
95733: PUSH
95734: LD_VAR 0 53
95738: PUSH
95739: LD_VAR 0 54
95743: PUSH
95744: LD_VAR 0 55
95748: PUSH
95749: LD_VAR 0 56
95753: PUSH
95754: LD_VAR 0 57
95758: PUSH
95759: LD_VAR 0 58
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: PUSH
95772: LD_VAR 0 4
95776: PUSH
95777: LD_INT 1
95779: PLUS
95780: ARRAY
95781: ST_TO_ADDR
95782: GO 95891
95784: LD_INT 31
95786: DOUBLE
95787: EQUAL
95788: IFTRUE 95834
95790: LD_INT 32
95792: DOUBLE
95793: EQUAL
95794: IFTRUE 95834
95796: LD_INT 33
95798: DOUBLE
95799: EQUAL
95800: IFTRUE 95834
95802: LD_INT 27
95804: DOUBLE
95805: EQUAL
95806: IFTRUE 95834
95808: LD_INT 26
95810: DOUBLE
95811: EQUAL
95812: IFTRUE 95834
95814: LD_INT 28
95816: DOUBLE
95817: EQUAL
95818: IFTRUE 95834
95820: LD_INT 29
95822: DOUBLE
95823: EQUAL
95824: IFTRUE 95834
95826: LD_INT 30
95828: DOUBLE
95829: EQUAL
95830: IFTRUE 95834
95832: GO 95890
95834: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
95835: LD_ADDR_VAR 0 9
95839: PUSH
95840: LD_VAR 0 59
95844: PUSH
95845: LD_VAR 0 60
95849: PUSH
95850: LD_VAR 0 61
95854: PUSH
95855: LD_VAR 0 62
95859: PUSH
95860: LD_VAR 0 63
95864: PUSH
95865: LD_VAR 0 64
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: PUSH
95878: LD_VAR 0 4
95882: PUSH
95883: LD_INT 1
95885: PLUS
95886: ARRAY
95887: ST_TO_ADDR
95888: GO 95891
95890: POP
// temp_list2 = [ ] ;
95891: LD_ADDR_VAR 0 10
95895: PUSH
95896: EMPTY
95897: ST_TO_ADDR
// for i in temp_list do
95898: LD_ADDR_VAR 0 8
95902: PUSH
95903: LD_VAR 0 9
95907: PUSH
95908: FOR_IN
95909: IFFALSE 95961
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95911: LD_ADDR_VAR 0 10
95915: PUSH
95916: LD_VAR 0 10
95920: PUSH
95921: LD_VAR 0 8
95925: PUSH
95926: LD_INT 1
95928: ARRAY
95929: PUSH
95930: LD_VAR 0 2
95934: PLUS
95935: PUSH
95936: LD_VAR 0 8
95940: PUSH
95941: LD_INT 2
95943: ARRAY
95944: PUSH
95945: LD_VAR 0 3
95949: PLUS
95950: PUSH
95951: EMPTY
95952: LIST
95953: LIST
95954: PUSH
95955: EMPTY
95956: LIST
95957: ADD
95958: ST_TO_ADDR
95959: GO 95908
95961: POP
95962: POP
// result = temp_list2 ;
95963: LD_ADDR_VAR 0 7
95967: PUSH
95968: LD_VAR 0 10
95972: ST_TO_ADDR
// end ;
95973: LD_VAR 0 7
95977: RET
// export function EnemyInRange ( unit , dist ) ; begin
95978: LD_INT 0
95980: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95981: LD_ADDR_VAR 0 3
95985: PUSH
95986: LD_VAR 0 1
95990: PPUSH
95991: CALL_OW 255
95995: PPUSH
95996: LD_VAR 0 1
96000: PPUSH
96001: CALL_OW 250
96005: PPUSH
96006: LD_VAR 0 1
96010: PPUSH
96011: CALL_OW 251
96015: PPUSH
96016: LD_VAR 0 2
96020: PPUSH
96021: CALL 69380 0 4
96025: PUSH
96026: LD_INT 4
96028: ARRAY
96029: ST_TO_ADDR
// end ;
96030: LD_VAR 0 3
96034: RET
// export function PlayerSeeMe ( unit ) ; begin
96035: LD_INT 0
96037: PPUSH
// result := See ( your_side , unit ) ;
96038: LD_ADDR_VAR 0 2
96042: PUSH
96043: LD_OWVAR 2
96047: PPUSH
96048: LD_VAR 0 1
96052: PPUSH
96053: CALL_OW 292
96057: ST_TO_ADDR
// end ;
96058: LD_VAR 0 2
96062: RET
// export function ReverseDir ( unit ) ; begin
96063: LD_INT 0
96065: PPUSH
// if not unit then
96066: LD_VAR 0 1
96070: NOT
96071: IFFALSE 96075
// exit ;
96073: GO 96098
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96075: LD_ADDR_VAR 0 2
96079: PUSH
96080: LD_VAR 0 1
96084: PPUSH
96085: CALL_OW 254
96089: PUSH
96090: LD_INT 3
96092: PLUS
96093: PUSH
96094: LD_INT 6
96096: MOD
96097: ST_TO_ADDR
// end ;
96098: LD_VAR 0 2
96102: RET
// export function ReverseArray ( array ) ; var i ; begin
96103: LD_INT 0
96105: PPUSH
96106: PPUSH
// if not array then
96107: LD_VAR 0 1
96111: NOT
96112: IFFALSE 96116
// exit ;
96114: GO 96171
// result := [ ] ;
96116: LD_ADDR_VAR 0 2
96120: PUSH
96121: EMPTY
96122: ST_TO_ADDR
// for i := array downto 1 do
96123: LD_ADDR_VAR 0 3
96127: PUSH
96128: DOUBLE
96129: LD_VAR 0 1
96133: INC
96134: ST_TO_ADDR
96135: LD_INT 1
96137: PUSH
96138: FOR_DOWNTO
96139: IFFALSE 96169
// result := Join ( result , array [ i ] ) ;
96141: LD_ADDR_VAR 0 2
96145: PUSH
96146: LD_VAR 0 2
96150: PPUSH
96151: LD_VAR 0 1
96155: PUSH
96156: LD_VAR 0 3
96160: ARRAY
96161: PPUSH
96162: CALL 100815 0 2
96166: ST_TO_ADDR
96167: GO 96138
96169: POP
96170: POP
// end ;
96171: LD_VAR 0 2
96175: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
96176: LD_INT 0
96178: PPUSH
96179: PPUSH
96180: PPUSH
96181: PPUSH
96182: PPUSH
96183: PPUSH
// if not unit or not hexes then
96184: LD_VAR 0 1
96188: NOT
96189: PUSH
96190: LD_VAR 0 2
96194: NOT
96195: OR
96196: IFFALSE 96200
// exit ;
96198: GO 96323
// dist := 9999 ;
96200: LD_ADDR_VAR 0 5
96204: PUSH
96205: LD_INT 9999
96207: ST_TO_ADDR
// for i = 1 to hexes do
96208: LD_ADDR_VAR 0 4
96212: PUSH
96213: DOUBLE
96214: LD_INT 1
96216: DEC
96217: ST_TO_ADDR
96218: LD_VAR 0 2
96222: PUSH
96223: FOR_TO
96224: IFFALSE 96311
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96226: LD_ADDR_VAR 0 6
96230: PUSH
96231: LD_VAR 0 1
96235: PPUSH
96236: LD_VAR 0 2
96240: PUSH
96241: LD_VAR 0 4
96245: ARRAY
96246: PUSH
96247: LD_INT 1
96249: ARRAY
96250: PPUSH
96251: LD_VAR 0 2
96255: PUSH
96256: LD_VAR 0 4
96260: ARRAY
96261: PUSH
96262: LD_INT 2
96264: ARRAY
96265: PPUSH
96266: CALL_OW 297
96270: ST_TO_ADDR
// if tdist < dist then
96271: LD_VAR 0 6
96275: PUSH
96276: LD_VAR 0 5
96280: LESS
96281: IFFALSE 96309
// begin hex := hexes [ i ] ;
96283: LD_ADDR_VAR 0 8
96287: PUSH
96288: LD_VAR 0 2
96292: PUSH
96293: LD_VAR 0 4
96297: ARRAY
96298: ST_TO_ADDR
// dist := tdist ;
96299: LD_ADDR_VAR 0 5
96303: PUSH
96304: LD_VAR 0 6
96308: ST_TO_ADDR
// end ; end ;
96309: GO 96223
96311: POP
96312: POP
// result := hex ;
96313: LD_ADDR_VAR 0 3
96317: PUSH
96318: LD_VAR 0 8
96322: ST_TO_ADDR
// end ;
96323: LD_VAR 0 3
96327: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96328: LD_INT 0
96330: PPUSH
96331: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96332: LD_VAR 0 1
96336: NOT
96337: PUSH
96338: LD_VAR 0 1
96342: PUSH
96343: LD_INT 21
96345: PUSH
96346: LD_INT 2
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PUSH
96353: LD_INT 23
96355: PUSH
96356: LD_INT 2
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: PPUSH
96367: CALL_OW 69
96371: IN
96372: NOT
96373: OR
96374: IFFALSE 96378
// exit ;
96376: GO 96425
// for i = 1 to 3 do
96378: LD_ADDR_VAR 0 3
96382: PUSH
96383: DOUBLE
96384: LD_INT 1
96386: DEC
96387: ST_TO_ADDR
96388: LD_INT 3
96390: PUSH
96391: FOR_TO
96392: IFFALSE 96423
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96394: LD_VAR 0 1
96398: PPUSH
96399: CALL_OW 250
96403: PPUSH
96404: LD_VAR 0 1
96408: PPUSH
96409: CALL_OW 251
96413: PPUSH
96414: LD_INT 1
96416: PPUSH
96417: CALL_OW 453
96421: GO 96391
96423: POP
96424: POP
// end ;
96425: LD_VAR 0 2
96429: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96430: LD_INT 0
96432: PPUSH
96433: PPUSH
96434: PPUSH
96435: PPUSH
96436: PPUSH
96437: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96438: LD_VAR 0 1
96442: NOT
96443: PUSH
96444: LD_VAR 0 2
96448: NOT
96449: OR
96450: PUSH
96451: LD_VAR 0 1
96455: PPUSH
96456: CALL_OW 314
96460: OR
96461: IFFALSE 96465
// exit ;
96463: GO 96932
// if GetLives ( i ) < 250 then
96465: LD_VAR 0 4
96469: PPUSH
96470: CALL_OW 256
96474: PUSH
96475: LD_INT 250
96477: LESS
96478: IFFALSE 96491
// begin ComAutodestruct ( i ) ;
96480: LD_VAR 0 4
96484: PPUSH
96485: CALL 96328 0 1
// exit ;
96489: GO 96932
// end ; x := GetX ( enemy_unit ) ;
96491: LD_ADDR_VAR 0 7
96495: PUSH
96496: LD_VAR 0 2
96500: PPUSH
96501: CALL_OW 250
96505: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96506: LD_ADDR_VAR 0 8
96510: PUSH
96511: LD_VAR 0 2
96515: PPUSH
96516: CALL_OW 251
96520: ST_TO_ADDR
// if not x or not y then
96521: LD_VAR 0 7
96525: NOT
96526: PUSH
96527: LD_VAR 0 8
96531: NOT
96532: OR
96533: IFFALSE 96537
// exit ;
96535: GO 96932
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96537: LD_ADDR_VAR 0 6
96541: PUSH
96542: LD_VAR 0 7
96546: PPUSH
96547: LD_INT 0
96549: PPUSH
96550: LD_INT 4
96552: PPUSH
96553: CALL_OW 272
96557: PUSH
96558: LD_VAR 0 8
96562: PPUSH
96563: LD_INT 0
96565: PPUSH
96566: LD_INT 4
96568: PPUSH
96569: CALL_OW 273
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: PUSH
96578: LD_VAR 0 7
96582: PPUSH
96583: LD_INT 1
96585: PPUSH
96586: LD_INT 4
96588: PPUSH
96589: CALL_OW 272
96593: PUSH
96594: LD_VAR 0 8
96598: PPUSH
96599: LD_INT 1
96601: PPUSH
96602: LD_INT 4
96604: PPUSH
96605: CALL_OW 273
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_VAR 0 7
96618: PPUSH
96619: LD_INT 2
96621: PPUSH
96622: LD_INT 4
96624: PPUSH
96625: CALL_OW 272
96629: PUSH
96630: LD_VAR 0 8
96634: PPUSH
96635: LD_INT 2
96637: PPUSH
96638: LD_INT 4
96640: PPUSH
96641: CALL_OW 273
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: LD_VAR 0 7
96654: PPUSH
96655: LD_INT 3
96657: PPUSH
96658: LD_INT 4
96660: PPUSH
96661: CALL_OW 272
96665: PUSH
96666: LD_VAR 0 8
96670: PPUSH
96671: LD_INT 3
96673: PPUSH
96674: LD_INT 4
96676: PPUSH
96677: CALL_OW 273
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: LD_VAR 0 7
96690: PPUSH
96691: LD_INT 4
96693: PPUSH
96694: LD_INT 4
96696: PPUSH
96697: CALL_OW 272
96701: PUSH
96702: LD_VAR 0 8
96706: PPUSH
96707: LD_INT 4
96709: PPUSH
96710: LD_INT 4
96712: PPUSH
96713: CALL_OW 273
96717: PUSH
96718: EMPTY
96719: LIST
96720: LIST
96721: PUSH
96722: LD_VAR 0 7
96726: PPUSH
96727: LD_INT 5
96729: PPUSH
96730: LD_INT 4
96732: PPUSH
96733: CALL_OW 272
96737: PUSH
96738: LD_VAR 0 8
96742: PPUSH
96743: LD_INT 5
96745: PPUSH
96746: LD_INT 4
96748: PPUSH
96749: CALL_OW 273
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: ST_TO_ADDR
// for i = tmp downto 1 do
96766: LD_ADDR_VAR 0 4
96770: PUSH
96771: DOUBLE
96772: LD_VAR 0 6
96776: INC
96777: ST_TO_ADDR
96778: LD_INT 1
96780: PUSH
96781: FOR_DOWNTO
96782: IFFALSE 96883
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96784: LD_VAR 0 6
96788: PUSH
96789: LD_VAR 0 4
96793: ARRAY
96794: PUSH
96795: LD_INT 1
96797: ARRAY
96798: PPUSH
96799: LD_VAR 0 6
96803: PUSH
96804: LD_VAR 0 4
96808: ARRAY
96809: PUSH
96810: LD_INT 2
96812: ARRAY
96813: PPUSH
96814: CALL_OW 488
96818: NOT
96819: PUSH
96820: LD_VAR 0 6
96824: PUSH
96825: LD_VAR 0 4
96829: ARRAY
96830: PUSH
96831: LD_INT 1
96833: ARRAY
96834: PPUSH
96835: LD_VAR 0 6
96839: PUSH
96840: LD_VAR 0 4
96844: ARRAY
96845: PUSH
96846: LD_INT 2
96848: ARRAY
96849: PPUSH
96850: CALL_OW 428
96854: PUSH
96855: LD_INT 0
96857: NONEQUAL
96858: OR
96859: IFFALSE 96881
// tmp := Delete ( tmp , i ) ;
96861: LD_ADDR_VAR 0 6
96865: PUSH
96866: LD_VAR 0 6
96870: PPUSH
96871: LD_VAR 0 4
96875: PPUSH
96876: CALL_OW 3
96880: ST_TO_ADDR
96881: GO 96781
96883: POP
96884: POP
// j := GetClosestHex ( unit , tmp ) ;
96885: LD_ADDR_VAR 0 5
96889: PUSH
96890: LD_VAR 0 1
96894: PPUSH
96895: LD_VAR 0 6
96899: PPUSH
96900: CALL 96176 0 2
96904: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96905: LD_VAR 0 1
96909: PPUSH
96910: LD_VAR 0 5
96914: PUSH
96915: LD_INT 1
96917: ARRAY
96918: PPUSH
96919: LD_VAR 0 5
96923: PUSH
96924: LD_INT 2
96926: ARRAY
96927: PPUSH
96928: CALL_OW 111
// end ;
96932: LD_VAR 0 3
96936: RET
// export function PrepareApemanSoldier ( ) ; begin
96937: LD_INT 0
96939: PPUSH
// uc_nation := 0 ;
96940: LD_ADDR_OWVAR 21
96944: PUSH
96945: LD_INT 0
96947: ST_TO_ADDR
// hc_sex := sex_male ;
96948: LD_ADDR_OWVAR 27
96952: PUSH
96953: LD_INT 1
96955: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
96956: LD_ADDR_OWVAR 28
96960: PUSH
96961: LD_INT 15
96963: ST_TO_ADDR
// hc_gallery :=  ;
96964: LD_ADDR_OWVAR 33
96968: PUSH
96969: LD_STRING 
96971: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96972: LD_ADDR_OWVAR 31
96976: PUSH
96977: LD_INT 0
96979: PPUSH
96980: LD_INT 3
96982: PPUSH
96983: CALL_OW 12
96987: PUSH
96988: LD_INT 0
96990: PPUSH
96991: LD_INT 3
96993: PPUSH
96994: CALL_OW 12
96998: PUSH
96999: LD_INT 0
97001: PUSH
97002: LD_INT 0
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: ST_TO_ADDR
// end ;
97011: LD_VAR 0 1
97015: RET
// export function PrepareApemanEngineer ( ) ; begin
97016: LD_INT 0
97018: PPUSH
// uc_nation := 0 ;
97019: LD_ADDR_OWVAR 21
97023: PUSH
97024: LD_INT 0
97026: ST_TO_ADDR
// hc_sex := sex_male ;
97027: LD_ADDR_OWVAR 27
97031: PUSH
97032: LD_INT 1
97034: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
97035: LD_ADDR_OWVAR 28
97039: PUSH
97040: LD_INT 16
97042: ST_TO_ADDR
// hc_gallery :=  ;
97043: LD_ADDR_OWVAR 33
97047: PUSH
97048: LD_STRING 
97050: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97051: LD_ADDR_OWVAR 31
97055: PUSH
97056: LD_INT 0
97058: PPUSH
97059: LD_INT 3
97061: PPUSH
97062: CALL_OW 12
97066: PUSH
97067: LD_INT 0
97069: PPUSH
97070: LD_INT 3
97072: PPUSH
97073: CALL_OW 12
97077: PUSH
97078: LD_INT 0
97080: PUSH
97081: LD_INT 0
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: ST_TO_ADDR
// end ;
97090: LD_VAR 0 1
97094: RET
// export function PrepareApeman ( agressivity ) ; begin
97095: LD_INT 0
97097: PPUSH
// uc_side := 0 ;
97098: LD_ADDR_OWVAR 20
97102: PUSH
97103: LD_INT 0
97105: ST_TO_ADDR
// uc_nation := 0 ;
97106: LD_ADDR_OWVAR 21
97110: PUSH
97111: LD_INT 0
97113: ST_TO_ADDR
// hc_sex := sex_male ;
97114: LD_ADDR_OWVAR 27
97118: PUSH
97119: LD_INT 1
97121: ST_TO_ADDR
// hc_class := class_apeman ;
97122: LD_ADDR_OWVAR 28
97126: PUSH
97127: LD_INT 12
97129: ST_TO_ADDR
// hc_gallery :=  ;
97130: LD_ADDR_OWVAR 33
97134: PUSH
97135: LD_STRING 
97137: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97138: LD_ADDR_OWVAR 35
97142: PUSH
97143: LD_VAR 0 1
97147: NEG
97148: PPUSH
97149: LD_VAR 0 1
97153: PPUSH
97154: CALL_OW 12
97158: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97159: LD_ADDR_OWVAR 31
97163: PUSH
97164: LD_INT 0
97166: PPUSH
97167: LD_INT 3
97169: PPUSH
97170: CALL_OW 12
97174: PUSH
97175: LD_INT 0
97177: PPUSH
97178: LD_INT 3
97180: PPUSH
97181: CALL_OW 12
97185: PUSH
97186: LD_INT 0
97188: PUSH
97189: LD_INT 0
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: ST_TO_ADDR
// end ;
97198: LD_VAR 0 2
97202: RET
// export function PrepareTiger ( agressivity ) ; begin
97203: LD_INT 0
97205: PPUSH
// uc_side := 0 ;
97206: LD_ADDR_OWVAR 20
97210: PUSH
97211: LD_INT 0
97213: ST_TO_ADDR
// uc_nation := 0 ;
97214: LD_ADDR_OWVAR 21
97218: PUSH
97219: LD_INT 0
97221: ST_TO_ADDR
// hc_class := class_tiger ;
97222: LD_ADDR_OWVAR 28
97226: PUSH
97227: LD_INT 14
97229: ST_TO_ADDR
// hc_gallery :=  ;
97230: LD_ADDR_OWVAR 33
97234: PUSH
97235: LD_STRING 
97237: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97238: LD_ADDR_OWVAR 35
97242: PUSH
97243: LD_VAR 0 1
97247: NEG
97248: PPUSH
97249: LD_VAR 0 1
97253: PPUSH
97254: CALL_OW 12
97258: ST_TO_ADDR
// end ;
97259: LD_VAR 0 2
97263: RET
// export function PrepareEnchidna ( ) ; begin
97264: LD_INT 0
97266: PPUSH
// uc_side := 0 ;
97267: LD_ADDR_OWVAR 20
97271: PUSH
97272: LD_INT 0
97274: ST_TO_ADDR
// uc_nation := 0 ;
97275: LD_ADDR_OWVAR 21
97279: PUSH
97280: LD_INT 0
97282: ST_TO_ADDR
// hc_class := class_baggie ;
97283: LD_ADDR_OWVAR 28
97287: PUSH
97288: LD_INT 13
97290: ST_TO_ADDR
// hc_gallery :=  ;
97291: LD_ADDR_OWVAR 33
97295: PUSH
97296: LD_STRING 
97298: ST_TO_ADDR
// end ;
97299: LD_VAR 0 1
97303: RET
// export function PrepareFrog ( ) ; begin
97304: LD_INT 0
97306: PPUSH
// uc_side := 0 ;
97307: LD_ADDR_OWVAR 20
97311: PUSH
97312: LD_INT 0
97314: ST_TO_ADDR
// uc_nation := 0 ;
97315: LD_ADDR_OWVAR 21
97319: PUSH
97320: LD_INT 0
97322: ST_TO_ADDR
// hc_class := class_frog ;
97323: LD_ADDR_OWVAR 28
97327: PUSH
97328: LD_INT 19
97330: ST_TO_ADDR
// hc_gallery :=  ;
97331: LD_ADDR_OWVAR 33
97335: PUSH
97336: LD_STRING 
97338: ST_TO_ADDR
// end ;
97339: LD_VAR 0 1
97343: RET
// export function PrepareFish ( ) ; begin
97344: LD_INT 0
97346: PPUSH
// uc_side := 0 ;
97347: LD_ADDR_OWVAR 20
97351: PUSH
97352: LD_INT 0
97354: ST_TO_ADDR
// uc_nation := 0 ;
97355: LD_ADDR_OWVAR 21
97359: PUSH
97360: LD_INT 0
97362: ST_TO_ADDR
// hc_class := class_fish ;
97363: LD_ADDR_OWVAR 28
97367: PUSH
97368: LD_INT 20
97370: ST_TO_ADDR
// hc_gallery :=  ;
97371: LD_ADDR_OWVAR 33
97375: PUSH
97376: LD_STRING 
97378: ST_TO_ADDR
// end ;
97379: LD_VAR 0 1
97383: RET
// export function PrepareBird ( ) ; begin
97384: LD_INT 0
97386: PPUSH
// uc_side := 0 ;
97387: LD_ADDR_OWVAR 20
97391: PUSH
97392: LD_INT 0
97394: ST_TO_ADDR
// uc_nation := 0 ;
97395: LD_ADDR_OWVAR 21
97399: PUSH
97400: LD_INT 0
97402: ST_TO_ADDR
// hc_class := class_phororhacos ;
97403: LD_ADDR_OWVAR 28
97407: PUSH
97408: LD_INT 18
97410: ST_TO_ADDR
// hc_gallery :=  ;
97411: LD_ADDR_OWVAR 33
97415: PUSH
97416: LD_STRING 
97418: ST_TO_ADDR
// end ;
97419: LD_VAR 0 1
97423: RET
// export function PrepareHorse ( ) ; begin
97424: LD_INT 0
97426: PPUSH
// uc_side := 0 ;
97427: LD_ADDR_OWVAR 20
97431: PUSH
97432: LD_INT 0
97434: ST_TO_ADDR
// uc_nation := 0 ;
97435: LD_ADDR_OWVAR 21
97439: PUSH
97440: LD_INT 0
97442: ST_TO_ADDR
// hc_class := class_horse ;
97443: LD_ADDR_OWVAR 28
97447: PUSH
97448: LD_INT 21
97450: ST_TO_ADDR
// hc_gallery :=  ;
97451: LD_ADDR_OWVAR 33
97455: PUSH
97456: LD_STRING 
97458: ST_TO_ADDR
// end ;
97459: LD_VAR 0 1
97463: RET
// export function PrepareMastodont ( ) ; begin
97464: LD_INT 0
97466: PPUSH
// uc_side := 0 ;
97467: LD_ADDR_OWVAR 20
97471: PUSH
97472: LD_INT 0
97474: ST_TO_ADDR
// uc_nation := 0 ;
97475: LD_ADDR_OWVAR 21
97479: PUSH
97480: LD_INT 0
97482: ST_TO_ADDR
// vc_chassis := class_mastodont ;
97483: LD_ADDR_OWVAR 37
97487: PUSH
97488: LD_INT 31
97490: ST_TO_ADDR
// vc_control := control_rider ;
97491: LD_ADDR_OWVAR 38
97495: PUSH
97496: LD_INT 4
97498: ST_TO_ADDR
// end ;
97499: LD_VAR 0 1
97503: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97504: LD_INT 0
97506: PPUSH
97507: PPUSH
97508: PPUSH
// uc_side = 0 ;
97509: LD_ADDR_OWVAR 20
97513: PUSH
97514: LD_INT 0
97516: ST_TO_ADDR
// uc_nation = 0 ;
97517: LD_ADDR_OWVAR 21
97521: PUSH
97522: LD_INT 0
97524: ST_TO_ADDR
// InitHc_All ( ) ;
97525: CALL_OW 584
// InitVc ;
97529: CALL_OW 20
// if mastodonts then
97533: LD_VAR 0 6
97537: IFFALSE 97604
// for i = 1 to mastodonts do
97539: LD_ADDR_VAR 0 11
97543: PUSH
97544: DOUBLE
97545: LD_INT 1
97547: DEC
97548: ST_TO_ADDR
97549: LD_VAR 0 6
97553: PUSH
97554: FOR_TO
97555: IFFALSE 97602
// begin vc_chassis := 31 ;
97557: LD_ADDR_OWVAR 37
97561: PUSH
97562: LD_INT 31
97564: ST_TO_ADDR
// vc_control := control_rider ;
97565: LD_ADDR_OWVAR 38
97569: PUSH
97570: LD_INT 4
97572: ST_TO_ADDR
// animal := CreateVehicle ;
97573: LD_ADDR_VAR 0 12
97577: PUSH
97578: CALL_OW 45
97582: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97583: LD_VAR 0 12
97587: PPUSH
97588: LD_VAR 0 8
97592: PPUSH
97593: LD_INT 0
97595: PPUSH
97596: CALL 99732 0 3
// end ;
97600: GO 97554
97602: POP
97603: POP
// if horses then
97604: LD_VAR 0 5
97608: IFFALSE 97675
// for i = 1 to horses do
97610: LD_ADDR_VAR 0 11
97614: PUSH
97615: DOUBLE
97616: LD_INT 1
97618: DEC
97619: ST_TO_ADDR
97620: LD_VAR 0 5
97624: PUSH
97625: FOR_TO
97626: IFFALSE 97673
// begin hc_class := 21 ;
97628: LD_ADDR_OWVAR 28
97632: PUSH
97633: LD_INT 21
97635: ST_TO_ADDR
// hc_gallery :=  ;
97636: LD_ADDR_OWVAR 33
97640: PUSH
97641: LD_STRING 
97643: ST_TO_ADDR
// animal := CreateHuman ;
97644: LD_ADDR_VAR 0 12
97648: PUSH
97649: CALL_OW 44
97653: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97654: LD_VAR 0 12
97658: PPUSH
97659: LD_VAR 0 8
97663: PPUSH
97664: LD_INT 0
97666: PPUSH
97667: CALL 99732 0 3
// end ;
97671: GO 97625
97673: POP
97674: POP
// if birds then
97675: LD_VAR 0 1
97679: IFFALSE 97746
// for i = 1 to birds do
97681: LD_ADDR_VAR 0 11
97685: PUSH
97686: DOUBLE
97687: LD_INT 1
97689: DEC
97690: ST_TO_ADDR
97691: LD_VAR 0 1
97695: PUSH
97696: FOR_TO
97697: IFFALSE 97744
// begin hc_class = 18 ;
97699: LD_ADDR_OWVAR 28
97703: PUSH
97704: LD_INT 18
97706: ST_TO_ADDR
// hc_gallery =  ;
97707: LD_ADDR_OWVAR 33
97711: PUSH
97712: LD_STRING 
97714: ST_TO_ADDR
// animal := CreateHuman ;
97715: LD_ADDR_VAR 0 12
97719: PUSH
97720: CALL_OW 44
97724: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97725: LD_VAR 0 12
97729: PPUSH
97730: LD_VAR 0 8
97734: PPUSH
97735: LD_INT 0
97737: PPUSH
97738: CALL 99732 0 3
// end ;
97742: GO 97696
97744: POP
97745: POP
// if tigers then
97746: LD_VAR 0 2
97750: IFFALSE 97834
// for i = 1 to tigers do
97752: LD_ADDR_VAR 0 11
97756: PUSH
97757: DOUBLE
97758: LD_INT 1
97760: DEC
97761: ST_TO_ADDR
97762: LD_VAR 0 2
97766: PUSH
97767: FOR_TO
97768: IFFALSE 97832
// begin hc_class = class_tiger ;
97770: LD_ADDR_OWVAR 28
97774: PUSH
97775: LD_INT 14
97777: ST_TO_ADDR
// hc_gallery =  ;
97778: LD_ADDR_OWVAR 33
97782: PUSH
97783: LD_STRING 
97785: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97786: LD_ADDR_OWVAR 35
97790: PUSH
97791: LD_INT 7
97793: NEG
97794: PPUSH
97795: LD_INT 7
97797: PPUSH
97798: CALL_OW 12
97802: ST_TO_ADDR
// animal := CreateHuman ;
97803: LD_ADDR_VAR 0 12
97807: PUSH
97808: CALL_OW 44
97812: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97813: LD_VAR 0 12
97817: PPUSH
97818: LD_VAR 0 8
97822: PPUSH
97823: LD_INT 0
97825: PPUSH
97826: CALL 99732 0 3
// end ;
97830: GO 97767
97832: POP
97833: POP
// if apemans then
97834: LD_VAR 0 3
97838: IFFALSE 97961
// for i = 1 to apemans do
97840: LD_ADDR_VAR 0 11
97844: PUSH
97845: DOUBLE
97846: LD_INT 1
97848: DEC
97849: ST_TO_ADDR
97850: LD_VAR 0 3
97854: PUSH
97855: FOR_TO
97856: IFFALSE 97959
// begin hc_class = class_apeman ;
97858: LD_ADDR_OWVAR 28
97862: PUSH
97863: LD_INT 12
97865: ST_TO_ADDR
// hc_gallery =  ;
97866: LD_ADDR_OWVAR 33
97870: PUSH
97871: LD_STRING 
97873: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
97874: LD_ADDR_OWVAR 35
97878: PUSH
97879: LD_INT 2
97881: NEG
97882: PPUSH
97883: LD_INT 2
97885: PPUSH
97886: CALL_OW 12
97890: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97891: LD_ADDR_OWVAR 31
97895: PUSH
97896: LD_INT 1
97898: PPUSH
97899: LD_INT 3
97901: PPUSH
97902: CALL_OW 12
97906: PUSH
97907: LD_INT 1
97909: PPUSH
97910: LD_INT 3
97912: PPUSH
97913: CALL_OW 12
97917: PUSH
97918: LD_INT 0
97920: PUSH
97921: LD_INT 0
97923: PUSH
97924: EMPTY
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: ST_TO_ADDR
// animal := CreateHuman ;
97930: LD_ADDR_VAR 0 12
97934: PUSH
97935: CALL_OW 44
97939: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97940: LD_VAR 0 12
97944: PPUSH
97945: LD_VAR 0 8
97949: PPUSH
97950: LD_INT 0
97952: PPUSH
97953: CALL 99732 0 3
// end ;
97957: GO 97855
97959: POP
97960: POP
// if enchidnas then
97961: LD_VAR 0 4
97965: IFFALSE 98032
// for i = 1 to enchidnas do
97967: LD_ADDR_VAR 0 11
97971: PUSH
97972: DOUBLE
97973: LD_INT 1
97975: DEC
97976: ST_TO_ADDR
97977: LD_VAR 0 4
97981: PUSH
97982: FOR_TO
97983: IFFALSE 98030
// begin hc_class = 13 ;
97985: LD_ADDR_OWVAR 28
97989: PUSH
97990: LD_INT 13
97992: ST_TO_ADDR
// hc_gallery =  ;
97993: LD_ADDR_OWVAR 33
97997: PUSH
97998: LD_STRING 
98000: ST_TO_ADDR
// animal := CreateHuman ;
98001: LD_ADDR_VAR 0 12
98005: PUSH
98006: CALL_OW 44
98010: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98011: LD_VAR 0 12
98015: PPUSH
98016: LD_VAR 0 8
98020: PPUSH
98021: LD_INT 0
98023: PPUSH
98024: CALL 99732 0 3
// end ;
98028: GO 97982
98030: POP
98031: POP
// if fishes then
98032: LD_VAR 0 7
98036: IFFALSE 98103
// for i = 1 to fishes do
98038: LD_ADDR_VAR 0 11
98042: PUSH
98043: DOUBLE
98044: LD_INT 1
98046: DEC
98047: ST_TO_ADDR
98048: LD_VAR 0 7
98052: PUSH
98053: FOR_TO
98054: IFFALSE 98101
// begin hc_class = 20 ;
98056: LD_ADDR_OWVAR 28
98060: PUSH
98061: LD_INT 20
98063: ST_TO_ADDR
// hc_gallery =  ;
98064: LD_ADDR_OWVAR 33
98068: PUSH
98069: LD_STRING 
98071: ST_TO_ADDR
// animal := CreateHuman ;
98072: LD_ADDR_VAR 0 12
98076: PUSH
98077: CALL_OW 44
98081: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98082: LD_VAR 0 12
98086: PPUSH
98087: LD_VAR 0 9
98091: PPUSH
98092: LD_INT 0
98094: PPUSH
98095: CALL 99732 0 3
// end ;
98099: GO 98053
98101: POP
98102: POP
// end ;
98103: LD_VAR 0 10
98107: RET
// export function WantHeal ( sci , unit ) ; begin
98108: LD_INT 0
98110: PPUSH
// if GetTaskList ( sci ) > 0 then
98111: LD_VAR 0 1
98115: PPUSH
98116: CALL_OW 437
98120: PUSH
98121: LD_INT 0
98123: GREATER
98124: IFFALSE 98194
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98126: LD_VAR 0 1
98130: PPUSH
98131: CALL_OW 437
98135: PUSH
98136: LD_INT 1
98138: ARRAY
98139: PUSH
98140: LD_INT 1
98142: ARRAY
98143: PUSH
98144: LD_STRING l
98146: EQUAL
98147: PUSH
98148: LD_VAR 0 1
98152: PPUSH
98153: CALL_OW 437
98157: PUSH
98158: LD_INT 1
98160: ARRAY
98161: PUSH
98162: LD_INT 4
98164: ARRAY
98165: PUSH
98166: LD_VAR 0 2
98170: EQUAL
98171: AND
98172: IFFALSE 98184
// result := true else
98174: LD_ADDR_VAR 0 3
98178: PUSH
98179: LD_INT 1
98181: ST_TO_ADDR
98182: GO 98192
// result := false ;
98184: LD_ADDR_VAR 0 3
98188: PUSH
98189: LD_INT 0
98191: ST_TO_ADDR
// end else
98192: GO 98202
// result := false ;
98194: LD_ADDR_VAR 0 3
98198: PUSH
98199: LD_INT 0
98201: ST_TO_ADDR
// end ;
98202: LD_VAR 0 3
98206: RET
// export function HealTarget ( sci ) ; begin
98207: LD_INT 0
98209: PPUSH
// if not sci then
98210: LD_VAR 0 1
98214: NOT
98215: IFFALSE 98219
// exit ;
98217: GO 98284
// result := 0 ;
98219: LD_ADDR_VAR 0 2
98223: PUSH
98224: LD_INT 0
98226: ST_TO_ADDR
// if GetTaskList ( sci ) then
98227: LD_VAR 0 1
98231: PPUSH
98232: CALL_OW 437
98236: IFFALSE 98284
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98238: LD_VAR 0 1
98242: PPUSH
98243: CALL_OW 437
98247: PUSH
98248: LD_INT 1
98250: ARRAY
98251: PUSH
98252: LD_INT 1
98254: ARRAY
98255: PUSH
98256: LD_STRING l
98258: EQUAL
98259: IFFALSE 98284
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98261: LD_ADDR_VAR 0 2
98265: PUSH
98266: LD_VAR 0 1
98270: PPUSH
98271: CALL_OW 437
98275: PUSH
98276: LD_INT 1
98278: ARRAY
98279: PUSH
98280: LD_INT 4
98282: ARRAY
98283: ST_TO_ADDR
// end ;
98284: LD_VAR 0 2
98288: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98289: LD_INT 0
98291: PPUSH
98292: PPUSH
98293: PPUSH
98294: PPUSH
// if not base_units then
98295: LD_VAR 0 1
98299: NOT
98300: IFFALSE 98304
// exit ;
98302: GO 98391
// result := false ;
98304: LD_ADDR_VAR 0 2
98308: PUSH
98309: LD_INT 0
98311: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98312: LD_ADDR_VAR 0 5
98316: PUSH
98317: LD_VAR 0 1
98321: PPUSH
98322: LD_INT 21
98324: PUSH
98325: LD_INT 3
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: PPUSH
98332: CALL_OW 72
98336: ST_TO_ADDR
// if not tmp then
98337: LD_VAR 0 5
98341: NOT
98342: IFFALSE 98346
// exit ;
98344: GO 98391
// for i in tmp do
98346: LD_ADDR_VAR 0 3
98350: PUSH
98351: LD_VAR 0 5
98355: PUSH
98356: FOR_IN
98357: IFFALSE 98389
// begin result := EnemyInRange ( i , 22 ) ;
98359: LD_ADDR_VAR 0 2
98363: PUSH
98364: LD_VAR 0 3
98368: PPUSH
98369: LD_INT 22
98371: PPUSH
98372: CALL 95978 0 2
98376: ST_TO_ADDR
// if result then
98377: LD_VAR 0 2
98381: IFFALSE 98387
// exit ;
98383: POP
98384: POP
98385: GO 98391
// end ;
98387: GO 98356
98389: POP
98390: POP
// end ;
98391: LD_VAR 0 2
98395: RET
// export function FilterByTag ( units , tag ) ; begin
98396: LD_INT 0
98398: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
98399: LD_ADDR_VAR 0 3
98403: PUSH
98404: LD_VAR 0 1
98408: PPUSH
98409: LD_INT 120
98411: PUSH
98412: LD_VAR 0 2
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PPUSH
98421: CALL_OW 72
98425: ST_TO_ADDR
// end ;
98426: LD_VAR 0 3
98430: RET
// export function IsDriver ( un ) ; begin
98431: LD_INT 0
98433: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98434: LD_ADDR_VAR 0 2
98438: PUSH
98439: LD_VAR 0 1
98443: PUSH
98444: LD_INT 55
98446: PUSH
98447: EMPTY
98448: LIST
98449: PPUSH
98450: CALL_OW 69
98454: IN
98455: ST_TO_ADDR
// end ;
98456: LD_VAR 0 2
98460: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98461: LD_INT 0
98463: PPUSH
98464: PPUSH
// list := [ ] ;
98465: LD_ADDR_VAR 0 5
98469: PUSH
98470: EMPTY
98471: ST_TO_ADDR
// case d of 0 :
98472: LD_VAR 0 3
98476: PUSH
98477: LD_INT 0
98479: DOUBLE
98480: EQUAL
98481: IFTRUE 98485
98483: GO 98618
98485: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98486: LD_ADDR_VAR 0 5
98490: PUSH
98491: LD_VAR 0 1
98495: PUSH
98496: LD_INT 4
98498: MINUS
98499: PUSH
98500: LD_VAR 0 2
98504: PUSH
98505: LD_INT 4
98507: MINUS
98508: PUSH
98509: LD_INT 2
98511: PUSH
98512: EMPTY
98513: LIST
98514: LIST
98515: LIST
98516: PUSH
98517: LD_VAR 0 1
98521: PUSH
98522: LD_INT 3
98524: MINUS
98525: PUSH
98526: LD_VAR 0 2
98530: PUSH
98531: LD_INT 1
98533: PUSH
98534: EMPTY
98535: LIST
98536: LIST
98537: LIST
98538: PUSH
98539: LD_VAR 0 1
98543: PUSH
98544: LD_INT 4
98546: PLUS
98547: PUSH
98548: LD_VAR 0 2
98552: PUSH
98553: LD_INT 4
98555: PUSH
98556: EMPTY
98557: LIST
98558: LIST
98559: LIST
98560: PUSH
98561: LD_VAR 0 1
98565: PUSH
98566: LD_INT 3
98568: PLUS
98569: PUSH
98570: LD_VAR 0 2
98574: PUSH
98575: LD_INT 3
98577: PLUS
98578: PUSH
98579: LD_INT 5
98581: PUSH
98582: EMPTY
98583: LIST
98584: LIST
98585: LIST
98586: PUSH
98587: LD_VAR 0 1
98591: PUSH
98592: LD_VAR 0 2
98596: PUSH
98597: LD_INT 4
98599: PLUS
98600: PUSH
98601: LD_INT 0
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: LIST
98608: PUSH
98609: EMPTY
98610: LIST
98611: LIST
98612: LIST
98613: LIST
98614: LIST
98615: ST_TO_ADDR
// end ; 1 :
98616: GO 99316
98618: LD_INT 1
98620: DOUBLE
98621: EQUAL
98622: IFTRUE 98626
98624: GO 98759
98626: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98627: LD_ADDR_VAR 0 5
98631: PUSH
98632: LD_VAR 0 1
98636: PUSH
98637: LD_VAR 0 2
98641: PUSH
98642: LD_INT 4
98644: MINUS
98645: PUSH
98646: LD_INT 3
98648: PUSH
98649: EMPTY
98650: LIST
98651: LIST
98652: LIST
98653: PUSH
98654: LD_VAR 0 1
98658: PUSH
98659: LD_INT 3
98661: MINUS
98662: PUSH
98663: LD_VAR 0 2
98667: PUSH
98668: LD_INT 3
98670: MINUS
98671: PUSH
98672: LD_INT 2
98674: PUSH
98675: EMPTY
98676: LIST
98677: LIST
98678: LIST
98679: PUSH
98680: LD_VAR 0 1
98684: PUSH
98685: LD_INT 4
98687: MINUS
98688: PUSH
98689: LD_VAR 0 2
98693: PUSH
98694: LD_INT 1
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: LIST
98701: PUSH
98702: LD_VAR 0 1
98706: PUSH
98707: LD_VAR 0 2
98711: PUSH
98712: LD_INT 3
98714: PLUS
98715: PUSH
98716: LD_INT 0
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: LIST
98723: PUSH
98724: LD_VAR 0 1
98728: PUSH
98729: LD_INT 4
98731: PLUS
98732: PUSH
98733: LD_VAR 0 2
98737: PUSH
98738: LD_INT 4
98740: PLUS
98741: PUSH
98742: LD_INT 5
98744: PUSH
98745: EMPTY
98746: LIST
98747: LIST
98748: LIST
98749: PUSH
98750: EMPTY
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: ST_TO_ADDR
// end ; 2 :
98757: GO 99316
98759: LD_INT 2
98761: DOUBLE
98762: EQUAL
98763: IFTRUE 98767
98765: GO 98896
98767: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98768: LD_ADDR_VAR 0 5
98772: PUSH
98773: LD_VAR 0 1
98777: PUSH
98778: LD_VAR 0 2
98782: PUSH
98783: LD_INT 3
98785: MINUS
98786: PUSH
98787: LD_INT 3
98789: PUSH
98790: EMPTY
98791: LIST
98792: LIST
98793: LIST
98794: PUSH
98795: LD_VAR 0 1
98799: PUSH
98800: LD_INT 4
98802: PLUS
98803: PUSH
98804: LD_VAR 0 2
98808: PUSH
98809: LD_INT 4
98811: PUSH
98812: EMPTY
98813: LIST
98814: LIST
98815: LIST
98816: PUSH
98817: LD_VAR 0 1
98821: PUSH
98822: LD_VAR 0 2
98826: PUSH
98827: LD_INT 4
98829: PLUS
98830: PUSH
98831: LD_INT 0
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: LIST
98838: PUSH
98839: LD_VAR 0 1
98843: PUSH
98844: LD_INT 3
98846: MINUS
98847: PUSH
98848: LD_VAR 0 2
98852: PUSH
98853: LD_INT 1
98855: PUSH
98856: EMPTY
98857: LIST
98858: LIST
98859: LIST
98860: PUSH
98861: LD_VAR 0 1
98865: PUSH
98866: LD_INT 4
98868: MINUS
98869: PUSH
98870: LD_VAR 0 2
98874: PUSH
98875: LD_INT 4
98877: MINUS
98878: PUSH
98879: LD_INT 2
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: LIST
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: ST_TO_ADDR
// end ; 3 :
98894: GO 99316
98896: LD_INT 3
98898: DOUBLE
98899: EQUAL
98900: IFTRUE 98904
98902: GO 99037
98904: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
98905: LD_ADDR_VAR 0 5
98909: PUSH
98910: LD_VAR 0 1
98914: PUSH
98915: LD_INT 3
98917: PLUS
98918: PUSH
98919: LD_VAR 0 2
98923: PUSH
98924: LD_INT 4
98926: PUSH
98927: EMPTY
98928: LIST
98929: LIST
98930: LIST
98931: PUSH
98932: LD_VAR 0 1
98936: PUSH
98937: LD_INT 4
98939: PLUS
98940: PUSH
98941: LD_VAR 0 2
98945: PUSH
98946: LD_INT 4
98948: PLUS
98949: PUSH
98950: LD_INT 5
98952: PUSH
98953: EMPTY
98954: LIST
98955: LIST
98956: LIST
98957: PUSH
98958: LD_VAR 0 1
98962: PUSH
98963: LD_INT 4
98965: MINUS
98966: PUSH
98967: LD_VAR 0 2
98971: PUSH
98972: LD_INT 1
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: LIST
98979: PUSH
98980: LD_VAR 0 1
98984: PUSH
98985: LD_VAR 0 2
98989: PUSH
98990: LD_INT 4
98992: MINUS
98993: PUSH
98994: LD_INT 3
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: LIST
99001: PUSH
99002: LD_VAR 0 1
99006: PUSH
99007: LD_INT 3
99009: MINUS
99010: PUSH
99011: LD_VAR 0 2
99015: PUSH
99016: LD_INT 3
99018: MINUS
99019: PUSH
99020: LD_INT 2
99022: PUSH
99023: EMPTY
99024: LIST
99025: LIST
99026: LIST
99027: PUSH
99028: EMPTY
99029: LIST
99030: LIST
99031: LIST
99032: LIST
99033: LIST
99034: ST_TO_ADDR
// end ; 4 :
99035: GO 99316
99037: LD_INT 4
99039: DOUBLE
99040: EQUAL
99041: IFTRUE 99045
99043: GO 99178
99045: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99046: LD_ADDR_VAR 0 5
99050: PUSH
99051: LD_VAR 0 1
99055: PUSH
99056: LD_VAR 0 2
99060: PUSH
99061: LD_INT 4
99063: PLUS
99064: PUSH
99065: LD_INT 0
99067: PUSH
99068: EMPTY
99069: LIST
99070: LIST
99071: LIST
99072: PUSH
99073: LD_VAR 0 1
99077: PUSH
99078: LD_INT 3
99080: PLUS
99081: PUSH
99082: LD_VAR 0 2
99086: PUSH
99087: LD_INT 3
99089: PLUS
99090: PUSH
99091: LD_INT 5
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: LIST
99098: PUSH
99099: LD_VAR 0 1
99103: PUSH
99104: LD_INT 4
99106: PLUS
99107: PUSH
99108: LD_VAR 0 2
99112: PUSH
99113: LD_INT 4
99115: PUSH
99116: EMPTY
99117: LIST
99118: LIST
99119: LIST
99120: PUSH
99121: LD_VAR 0 1
99125: PUSH
99126: LD_VAR 0 2
99130: PUSH
99131: LD_INT 3
99133: MINUS
99134: PUSH
99135: LD_INT 3
99137: PUSH
99138: EMPTY
99139: LIST
99140: LIST
99141: LIST
99142: PUSH
99143: LD_VAR 0 1
99147: PUSH
99148: LD_INT 4
99150: MINUS
99151: PUSH
99152: LD_VAR 0 2
99156: PUSH
99157: LD_INT 4
99159: MINUS
99160: PUSH
99161: LD_INT 2
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: LIST
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: ST_TO_ADDR
// end ; 5 :
99176: GO 99316
99178: LD_INT 5
99180: DOUBLE
99181: EQUAL
99182: IFTRUE 99186
99184: GO 99315
99186: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99187: LD_ADDR_VAR 0 5
99191: PUSH
99192: LD_VAR 0 1
99196: PUSH
99197: LD_INT 4
99199: MINUS
99200: PUSH
99201: LD_VAR 0 2
99205: PUSH
99206: LD_INT 1
99208: PUSH
99209: EMPTY
99210: LIST
99211: LIST
99212: LIST
99213: PUSH
99214: LD_VAR 0 1
99218: PUSH
99219: LD_VAR 0 2
99223: PUSH
99224: LD_INT 4
99226: MINUS
99227: PUSH
99228: LD_INT 3
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: LIST
99235: PUSH
99236: LD_VAR 0 1
99240: PUSH
99241: LD_INT 4
99243: PLUS
99244: PUSH
99245: LD_VAR 0 2
99249: PUSH
99250: LD_INT 4
99252: PLUS
99253: PUSH
99254: LD_INT 5
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: LIST
99261: PUSH
99262: LD_VAR 0 1
99266: PUSH
99267: LD_INT 3
99269: PLUS
99270: PUSH
99271: LD_VAR 0 2
99275: PUSH
99276: LD_INT 4
99278: PUSH
99279: EMPTY
99280: LIST
99281: LIST
99282: LIST
99283: PUSH
99284: LD_VAR 0 1
99288: PUSH
99289: LD_VAR 0 2
99293: PUSH
99294: LD_INT 3
99296: PLUS
99297: PUSH
99298: LD_INT 0
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: LIST
99305: PUSH
99306: EMPTY
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: ST_TO_ADDR
// end ; end ;
99313: GO 99316
99315: POP
// result := list ;
99316: LD_ADDR_VAR 0 4
99320: PUSH
99321: LD_VAR 0 5
99325: ST_TO_ADDR
// end ;
99326: LD_VAR 0 4
99330: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99331: LD_INT 0
99333: PPUSH
99334: PPUSH
99335: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99336: LD_VAR 0 1
99340: NOT
99341: PUSH
99342: LD_VAR 0 2
99346: PUSH
99347: LD_INT 1
99349: PUSH
99350: LD_INT 2
99352: PUSH
99353: LD_INT 3
99355: PUSH
99356: LD_INT 4
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: IN
99365: NOT
99366: OR
99367: IFFALSE 99371
// exit ;
99369: GO 99454
// tmp := [ ] ;
99371: LD_ADDR_VAR 0 5
99375: PUSH
99376: EMPTY
99377: ST_TO_ADDR
// for i in units do
99378: LD_ADDR_VAR 0 4
99382: PUSH
99383: LD_VAR 0 1
99387: PUSH
99388: FOR_IN
99389: IFFALSE 99423
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
99391: LD_ADDR_VAR 0 5
99395: PUSH
99396: LD_VAR 0 5
99400: PPUSH
99401: LD_VAR 0 4
99405: PPUSH
99406: LD_VAR 0 2
99410: PPUSH
99411: CALL_OW 259
99415: PPUSH
99416: CALL 100815 0 2
99420: ST_TO_ADDR
99421: GO 99388
99423: POP
99424: POP
// if not tmp then
99425: LD_VAR 0 5
99429: NOT
99430: IFFALSE 99434
// exit ;
99432: GO 99454
// result := SortListByListDesc ( units , tmp ) ;
99434: LD_ADDR_VAR 0 3
99438: PUSH
99439: LD_VAR 0 1
99443: PPUSH
99444: LD_VAR 0 5
99448: PPUSH
99449: CALL_OW 77
99453: ST_TO_ADDR
// end ;
99454: LD_VAR 0 3
99458: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99459: LD_INT 0
99461: PPUSH
99462: PPUSH
99463: PPUSH
// result := false ;
99464: LD_ADDR_VAR 0 3
99468: PUSH
99469: LD_INT 0
99471: ST_TO_ADDR
// if not building then
99472: LD_VAR 0 2
99476: NOT
99477: IFFALSE 99481
// exit ;
99479: GO 99619
// x := GetX ( building ) ;
99481: LD_ADDR_VAR 0 4
99485: PUSH
99486: LD_VAR 0 2
99490: PPUSH
99491: CALL_OW 250
99495: ST_TO_ADDR
// y := GetY ( building ) ;
99496: LD_ADDR_VAR 0 5
99500: PUSH
99501: LD_VAR 0 2
99505: PPUSH
99506: CALL_OW 251
99510: ST_TO_ADDR
// if not x or not y then
99511: LD_VAR 0 4
99515: NOT
99516: PUSH
99517: LD_VAR 0 5
99521: NOT
99522: OR
99523: IFFALSE 99527
// exit ;
99525: GO 99619
// if GetTaskList ( unit ) then
99527: LD_VAR 0 1
99531: PPUSH
99532: CALL_OW 437
99536: IFFALSE 99619
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99538: LD_STRING e
99540: PUSH
99541: LD_VAR 0 1
99545: PPUSH
99546: CALL_OW 437
99550: PUSH
99551: LD_INT 1
99553: ARRAY
99554: PUSH
99555: LD_INT 1
99557: ARRAY
99558: EQUAL
99559: PUSH
99560: LD_VAR 0 4
99564: PUSH
99565: LD_VAR 0 1
99569: PPUSH
99570: CALL_OW 437
99574: PUSH
99575: LD_INT 1
99577: ARRAY
99578: PUSH
99579: LD_INT 2
99581: ARRAY
99582: EQUAL
99583: AND
99584: PUSH
99585: LD_VAR 0 5
99589: PUSH
99590: LD_VAR 0 1
99594: PPUSH
99595: CALL_OW 437
99599: PUSH
99600: LD_INT 1
99602: ARRAY
99603: PUSH
99604: LD_INT 3
99606: ARRAY
99607: EQUAL
99608: AND
99609: IFFALSE 99619
// result := true end ;
99611: LD_ADDR_VAR 0 3
99615: PUSH
99616: LD_INT 1
99618: ST_TO_ADDR
// end ;
99619: LD_VAR 0 3
99623: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99624: LD_INT 0
99626: PPUSH
// result := false ;
99627: LD_ADDR_VAR 0 4
99631: PUSH
99632: LD_INT 0
99634: ST_TO_ADDR
// if GetTaskList ( unit ) then
99635: LD_VAR 0 1
99639: PPUSH
99640: CALL_OW 437
99644: IFFALSE 99727
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99646: LD_STRING M
99648: PUSH
99649: LD_VAR 0 1
99653: PPUSH
99654: CALL_OW 437
99658: PUSH
99659: LD_INT 1
99661: ARRAY
99662: PUSH
99663: LD_INT 1
99665: ARRAY
99666: EQUAL
99667: PUSH
99668: LD_VAR 0 2
99672: PUSH
99673: LD_VAR 0 1
99677: PPUSH
99678: CALL_OW 437
99682: PUSH
99683: LD_INT 1
99685: ARRAY
99686: PUSH
99687: LD_INT 2
99689: ARRAY
99690: EQUAL
99691: AND
99692: PUSH
99693: LD_VAR 0 3
99697: PUSH
99698: LD_VAR 0 1
99702: PPUSH
99703: CALL_OW 437
99707: PUSH
99708: LD_INT 1
99710: ARRAY
99711: PUSH
99712: LD_INT 3
99714: ARRAY
99715: EQUAL
99716: AND
99717: IFFALSE 99727
// result := true ;
99719: LD_ADDR_VAR 0 4
99723: PUSH
99724: LD_INT 1
99726: ST_TO_ADDR
// end ; end ;
99727: LD_VAR 0 4
99731: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99732: LD_INT 0
99734: PPUSH
99735: PPUSH
99736: PPUSH
99737: PPUSH
// if not unit or not area then
99738: LD_VAR 0 1
99742: NOT
99743: PUSH
99744: LD_VAR 0 2
99748: NOT
99749: OR
99750: IFFALSE 99754
// exit ;
99752: GO 99918
// tmp := AreaToList ( area , i ) ;
99754: LD_ADDR_VAR 0 6
99758: PUSH
99759: LD_VAR 0 2
99763: PPUSH
99764: LD_VAR 0 5
99768: PPUSH
99769: CALL_OW 517
99773: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99774: LD_ADDR_VAR 0 5
99778: PUSH
99779: DOUBLE
99780: LD_INT 1
99782: DEC
99783: ST_TO_ADDR
99784: LD_VAR 0 6
99788: PUSH
99789: LD_INT 1
99791: ARRAY
99792: PUSH
99793: FOR_TO
99794: IFFALSE 99916
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99796: LD_ADDR_VAR 0 7
99800: PUSH
99801: LD_VAR 0 6
99805: PUSH
99806: LD_INT 1
99808: ARRAY
99809: PUSH
99810: LD_VAR 0 5
99814: ARRAY
99815: PUSH
99816: LD_VAR 0 6
99820: PUSH
99821: LD_INT 2
99823: ARRAY
99824: PUSH
99825: LD_VAR 0 5
99829: ARRAY
99830: PUSH
99831: EMPTY
99832: LIST
99833: LIST
99834: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99835: LD_VAR 0 7
99839: PUSH
99840: LD_INT 1
99842: ARRAY
99843: PPUSH
99844: LD_VAR 0 7
99848: PUSH
99849: LD_INT 2
99851: ARRAY
99852: PPUSH
99853: CALL_OW 428
99857: PUSH
99858: LD_INT 0
99860: EQUAL
99861: IFFALSE 99914
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99863: LD_VAR 0 1
99867: PPUSH
99868: LD_VAR 0 7
99872: PUSH
99873: LD_INT 1
99875: ARRAY
99876: PPUSH
99877: LD_VAR 0 7
99881: PUSH
99882: LD_INT 2
99884: ARRAY
99885: PPUSH
99886: LD_VAR 0 3
99890: PPUSH
99891: CALL_OW 48
// result := IsPlaced ( unit ) ;
99895: LD_ADDR_VAR 0 4
99899: PUSH
99900: LD_VAR 0 1
99904: PPUSH
99905: CALL_OW 305
99909: ST_TO_ADDR
// exit ;
99910: POP
99911: POP
99912: GO 99918
// end ; end ;
99914: GO 99793
99916: POP
99917: POP
// end ;
99918: LD_VAR 0 4
99922: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99923: LD_INT 0
99925: PPUSH
99926: PPUSH
99927: PPUSH
// if not side or side > 8 then
99928: LD_VAR 0 1
99932: NOT
99933: PUSH
99934: LD_VAR 0 1
99938: PUSH
99939: LD_INT 8
99941: GREATER
99942: OR
99943: IFFALSE 99947
// exit ;
99945: GO 100134
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99947: LD_ADDR_VAR 0 4
99951: PUSH
99952: LD_INT 22
99954: PUSH
99955: LD_VAR 0 1
99959: PUSH
99960: EMPTY
99961: LIST
99962: LIST
99963: PUSH
99964: LD_INT 21
99966: PUSH
99967: LD_INT 3
99969: PUSH
99970: EMPTY
99971: LIST
99972: LIST
99973: PUSH
99974: EMPTY
99975: LIST
99976: LIST
99977: PPUSH
99978: CALL_OW 69
99982: ST_TO_ADDR
// if not tmp then
99983: LD_VAR 0 4
99987: NOT
99988: IFFALSE 99992
// exit ;
99990: GO 100134
// enable_addtolog := true ;
99992: LD_ADDR_OWVAR 81
99996: PUSH
99997: LD_INT 1
99999: ST_TO_ADDR
// AddToLog ( [ ) ;
100000: LD_STRING [
100002: PPUSH
100003: CALL_OW 561
// for i in tmp do
100007: LD_ADDR_VAR 0 3
100011: PUSH
100012: LD_VAR 0 4
100016: PUSH
100017: FOR_IN
100018: IFFALSE 100125
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100020: LD_STRING [
100022: PUSH
100023: LD_VAR 0 3
100027: PPUSH
100028: CALL_OW 266
100032: STR
100033: PUSH
100034: LD_STRING , 
100036: STR
100037: PUSH
100038: LD_VAR 0 3
100042: PPUSH
100043: CALL_OW 250
100047: STR
100048: PUSH
100049: LD_STRING , 
100051: STR
100052: PUSH
100053: LD_VAR 0 3
100057: PPUSH
100058: CALL_OW 251
100062: STR
100063: PUSH
100064: LD_STRING , 
100066: STR
100067: PUSH
100068: LD_VAR 0 3
100072: PPUSH
100073: CALL_OW 254
100077: STR
100078: PUSH
100079: LD_STRING , 
100081: STR
100082: PUSH
100083: LD_VAR 0 3
100087: PPUSH
100088: LD_INT 1
100090: PPUSH
100091: CALL_OW 268
100095: STR
100096: PUSH
100097: LD_STRING , 
100099: STR
100100: PUSH
100101: LD_VAR 0 3
100105: PPUSH
100106: LD_INT 2
100108: PPUSH
100109: CALL_OW 268
100113: STR
100114: PUSH
100115: LD_STRING ],
100117: STR
100118: PPUSH
100119: CALL_OW 561
// end ;
100123: GO 100017
100125: POP
100126: POP
// AddToLog ( ]; ) ;
100127: LD_STRING ];
100129: PPUSH
100130: CALL_OW 561
// end ;
100134: LD_VAR 0 2
100138: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100139: LD_INT 0
100141: PPUSH
100142: PPUSH
100143: PPUSH
100144: PPUSH
100145: PPUSH
// if not area or not rate or not max then
100146: LD_VAR 0 1
100150: NOT
100151: PUSH
100152: LD_VAR 0 2
100156: NOT
100157: OR
100158: PUSH
100159: LD_VAR 0 4
100163: NOT
100164: OR
100165: IFFALSE 100169
// exit ;
100167: GO 100358
// while 1 do
100169: LD_INT 1
100171: IFFALSE 100358
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100173: LD_ADDR_VAR 0 9
100177: PUSH
100178: LD_VAR 0 1
100182: PPUSH
100183: LD_INT 1
100185: PPUSH
100186: CALL_OW 287
100190: PUSH
100191: LD_INT 10
100193: MUL
100194: ST_TO_ADDR
// r := rate / 10 ;
100195: LD_ADDR_VAR 0 7
100199: PUSH
100200: LD_VAR 0 2
100204: PUSH
100205: LD_INT 10
100207: DIVREAL
100208: ST_TO_ADDR
// time := 1 1$00 ;
100209: LD_ADDR_VAR 0 8
100213: PUSH
100214: LD_INT 2100
100216: ST_TO_ADDR
// if amount < min then
100217: LD_VAR 0 9
100221: PUSH
100222: LD_VAR 0 3
100226: LESS
100227: IFFALSE 100245
// r := r * 2 else
100229: LD_ADDR_VAR 0 7
100233: PUSH
100234: LD_VAR 0 7
100238: PUSH
100239: LD_INT 2
100241: MUL
100242: ST_TO_ADDR
100243: GO 100271
// if amount > max then
100245: LD_VAR 0 9
100249: PUSH
100250: LD_VAR 0 4
100254: GREATER
100255: IFFALSE 100271
// r := r / 2 ;
100257: LD_ADDR_VAR 0 7
100261: PUSH
100262: LD_VAR 0 7
100266: PUSH
100267: LD_INT 2
100269: DIVREAL
100270: ST_TO_ADDR
// time := time / r ;
100271: LD_ADDR_VAR 0 8
100275: PUSH
100276: LD_VAR 0 8
100280: PUSH
100281: LD_VAR 0 7
100285: DIVREAL
100286: ST_TO_ADDR
// if time < 0 then
100287: LD_VAR 0 8
100291: PUSH
100292: LD_INT 0
100294: LESS
100295: IFFALSE 100312
// time := time * - 1 ;
100297: LD_ADDR_VAR 0 8
100301: PUSH
100302: LD_VAR 0 8
100306: PUSH
100307: LD_INT 1
100309: NEG
100310: MUL
100311: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100312: LD_VAR 0 8
100316: PUSH
100317: LD_INT 35
100319: PPUSH
100320: LD_INT 875
100322: PPUSH
100323: CALL_OW 12
100327: PLUS
100328: PPUSH
100329: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100333: LD_INT 1
100335: PPUSH
100336: LD_INT 5
100338: PPUSH
100339: CALL_OW 12
100343: PPUSH
100344: LD_VAR 0 1
100348: PPUSH
100349: LD_INT 1
100351: PPUSH
100352: CALL_OW 55
// end ;
100356: GO 100169
// end ;
100358: LD_VAR 0 5
100362: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100363: LD_INT 0
100365: PPUSH
100366: PPUSH
100367: PPUSH
100368: PPUSH
100369: PPUSH
100370: PPUSH
100371: PPUSH
100372: PPUSH
// if not turrets or not factories then
100373: LD_VAR 0 1
100377: NOT
100378: PUSH
100379: LD_VAR 0 2
100383: NOT
100384: OR
100385: IFFALSE 100389
// exit ;
100387: GO 100696
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100389: LD_ADDR_VAR 0 10
100393: PUSH
100394: LD_INT 5
100396: PUSH
100397: LD_INT 6
100399: PUSH
100400: EMPTY
100401: LIST
100402: LIST
100403: PUSH
100404: LD_INT 2
100406: PUSH
100407: LD_INT 4
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: PUSH
100414: LD_INT 3
100416: PUSH
100417: LD_INT 5
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: EMPTY
100425: LIST
100426: LIST
100427: LIST
100428: PUSH
100429: LD_INT 24
100431: PUSH
100432: LD_INT 25
100434: PUSH
100435: EMPTY
100436: LIST
100437: LIST
100438: PUSH
100439: LD_INT 23
100441: PUSH
100442: LD_INT 27
100444: PUSH
100445: EMPTY
100446: LIST
100447: LIST
100448: PUSH
100449: EMPTY
100450: LIST
100451: LIST
100452: PUSH
100453: LD_INT 42
100455: PUSH
100456: LD_INT 43
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: PUSH
100463: LD_INT 44
100465: PUSH
100466: LD_INT 46
100468: PUSH
100469: EMPTY
100470: LIST
100471: LIST
100472: PUSH
100473: LD_INT 45
100475: PUSH
100476: LD_INT 47
100478: PUSH
100479: EMPTY
100480: LIST
100481: LIST
100482: PUSH
100483: EMPTY
100484: LIST
100485: LIST
100486: LIST
100487: PUSH
100488: EMPTY
100489: LIST
100490: LIST
100491: LIST
100492: ST_TO_ADDR
// result := [ ] ;
100493: LD_ADDR_VAR 0 3
100497: PUSH
100498: EMPTY
100499: ST_TO_ADDR
// for i in turrets do
100500: LD_ADDR_VAR 0 4
100504: PUSH
100505: LD_VAR 0 1
100509: PUSH
100510: FOR_IN
100511: IFFALSE 100694
// begin nat := GetNation ( i ) ;
100513: LD_ADDR_VAR 0 7
100517: PUSH
100518: LD_VAR 0 4
100522: PPUSH
100523: CALL_OW 248
100527: ST_TO_ADDR
// weapon := 0 ;
100528: LD_ADDR_VAR 0 8
100532: PUSH
100533: LD_INT 0
100535: ST_TO_ADDR
// if not nat then
100536: LD_VAR 0 7
100540: NOT
100541: IFFALSE 100545
// continue ;
100543: GO 100510
// for j in list [ nat ] do
100545: LD_ADDR_VAR 0 5
100549: PUSH
100550: LD_VAR 0 10
100554: PUSH
100555: LD_VAR 0 7
100559: ARRAY
100560: PUSH
100561: FOR_IN
100562: IFFALSE 100603
// if GetBWeapon ( i ) = j [ 1 ] then
100564: LD_VAR 0 4
100568: PPUSH
100569: CALL_OW 269
100573: PUSH
100574: LD_VAR 0 5
100578: PUSH
100579: LD_INT 1
100581: ARRAY
100582: EQUAL
100583: IFFALSE 100601
// begin weapon := j [ 2 ] ;
100585: LD_ADDR_VAR 0 8
100589: PUSH
100590: LD_VAR 0 5
100594: PUSH
100595: LD_INT 2
100597: ARRAY
100598: ST_TO_ADDR
// break ;
100599: GO 100603
// end ;
100601: GO 100561
100603: POP
100604: POP
// if not weapon then
100605: LD_VAR 0 8
100609: NOT
100610: IFFALSE 100614
// continue ;
100612: GO 100510
// for k in factories do
100614: LD_ADDR_VAR 0 6
100618: PUSH
100619: LD_VAR 0 2
100623: PUSH
100624: FOR_IN
100625: IFFALSE 100690
// begin weapons := AvailableWeaponList ( k ) ;
100627: LD_ADDR_VAR 0 9
100631: PUSH
100632: LD_VAR 0 6
100636: PPUSH
100637: CALL_OW 478
100641: ST_TO_ADDR
// if not weapons then
100642: LD_VAR 0 9
100646: NOT
100647: IFFALSE 100651
// continue ;
100649: GO 100624
// if weapon in weapons then
100651: LD_VAR 0 8
100655: PUSH
100656: LD_VAR 0 9
100660: IN
100661: IFFALSE 100688
// begin result := [ i , weapon ] ;
100663: LD_ADDR_VAR 0 3
100667: PUSH
100668: LD_VAR 0 4
100672: PUSH
100673: LD_VAR 0 8
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: ST_TO_ADDR
// exit ;
100682: POP
100683: POP
100684: POP
100685: POP
100686: GO 100696
// end ; end ;
100688: GO 100624
100690: POP
100691: POP
// end ;
100692: GO 100510
100694: POP
100695: POP
// end ;
100696: LD_VAR 0 3
100700: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100701: LD_INT 0
100703: PPUSH
// if not side or side > 8 then
100704: LD_VAR 0 3
100708: NOT
100709: PUSH
100710: LD_VAR 0 3
100714: PUSH
100715: LD_INT 8
100717: GREATER
100718: OR
100719: IFFALSE 100723
// exit ;
100721: GO 100782
// if not range then
100723: LD_VAR 0 4
100727: NOT
100728: IFFALSE 100739
// range := - 12 ;
100730: LD_ADDR_VAR 0 4
100734: PUSH
100735: LD_INT 12
100737: NEG
100738: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100739: LD_VAR 0 1
100743: PPUSH
100744: LD_VAR 0 2
100748: PPUSH
100749: LD_VAR 0 3
100753: PPUSH
100754: LD_VAR 0 4
100758: PPUSH
100759: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100763: LD_VAR 0 1
100767: PPUSH
100768: LD_VAR 0 2
100772: PPUSH
100773: LD_VAR 0 3
100777: PPUSH
100778: CALL_OW 331
// end ;
100782: LD_VAR 0 5
100786: RET
// export function Video ( mode ) ; begin
100787: LD_INT 0
100789: PPUSH
// ingame_video = mode ;
100790: LD_ADDR_OWVAR 52
100794: PUSH
100795: LD_VAR 0 1
100799: ST_TO_ADDR
// interface_hidden = mode ;
100800: LD_ADDR_OWVAR 54
100804: PUSH
100805: LD_VAR 0 1
100809: ST_TO_ADDR
// end ;
100810: LD_VAR 0 2
100814: RET
// export function Join ( array , element ) ; begin
100815: LD_INT 0
100817: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100818: LD_ADDR_VAR 0 3
100822: PUSH
100823: LD_VAR 0 1
100827: PPUSH
100828: LD_VAR 0 1
100832: PUSH
100833: LD_INT 1
100835: PLUS
100836: PPUSH
100837: LD_VAR 0 2
100841: PPUSH
100842: CALL_OW 1
100846: ST_TO_ADDR
// end ;
100847: LD_VAR 0 3
100851: RET
// export function JoinUnion ( array , element ) ; begin
100852: LD_INT 0
100854: PPUSH
// result := array union element ;
100855: LD_ADDR_VAR 0 3
100859: PUSH
100860: LD_VAR 0 1
100864: PUSH
100865: LD_VAR 0 2
100869: UNION
100870: ST_TO_ADDR
// end ;
100871: LD_VAR 0 3
100875: RET
// export function GetBehemoths ( side ) ; begin
100876: LD_INT 0
100878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
100879: LD_ADDR_VAR 0 2
100883: PUSH
100884: LD_INT 22
100886: PUSH
100887: LD_VAR 0 1
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PUSH
100896: LD_INT 31
100898: PUSH
100899: LD_INT 25
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PUSH
100906: EMPTY
100907: LIST
100908: LIST
100909: PPUSH
100910: CALL_OW 69
100914: ST_TO_ADDR
// end ;
100915: LD_VAR 0 2
100919: RET
// export function Shuffle ( array ) ; var i , index ; begin
100920: LD_INT 0
100922: PPUSH
100923: PPUSH
100924: PPUSH
// result := [ ] ;
100925: LD_ADDR_VAR 0 2
100929: PUSH
100930: EMPTY
100931: ST_TO_ADDR
// if not array then
100932: LD_VAR 0 1
100936: NOT
100937: IFFALSE 100941
// exit ;
100939: GO 101040
// Randomize ;
100941: CALL_OW 10
// for i = array downto 1 do
100945: LD_ADDR_VAR 0 3
100949: PUSH
100950: DOUBLE
100951: LD_VAR 0 1
100955: INC
100956: ST_TO_ADDR
100957: LD_INT 1
100959: PUSH
100960: FOR_DOWNTO
100961: IFFALSE 101038
// begin index := rand ( 1 , array ) ;
100963: LD_ADDR_VAR 0 4
100967: PUSH
100968: LD_INT 1
100970: PPUSH
100971: LD_VAR 0 1
100975: PPUSH
100976: CALL_OW 12
100980: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
100981: LD_ADDR_VAR 0 2
100985: PUSH
100986: LD_VAR 0 2
100990: PPUSH
100991: LD_VAR 0 2
100995: PUSH
100996: LD_INT 1
100998: PLUS
100999: PPUSH
101000: LD_VAR 0 1
101004: PUSH
101005: LD_VAR 0 4
101009: ARRAY
101010: PPUSH
101011: CALL_OW 2
101015: ST_TO_ADDR
// array := Delete ( array , index ) ;
101016: LD_ADDR_VAR 0 1
101020: PUSH
101021: LD_VAR 0 1
101025: PPUSH
101026: LD_VAR 0 4
101030: PPUSH
101031: CALL_OW 3
101035: ST_TO_ADDR
// end ;
101036: GO 100960
101038: POP
101039: POP
// end ;
101040: LD_VAR 0 2
101044: RET
// export function GetBaseMaterials ( base ) ; begin
101045: LD_INT 0
101047: PPUSH
// result := [ 0 , 0 , 0 ] ;
101048: LD_ADDR_VAR 0 2
101052: PUSH
101053: LD_INT 0
101055: PUSH
101056: LD_INT 0
101058: PUSH
101059: LD_INT 0
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: LIST
101066: ST_TO_ADDR
// if not base then
101067: LD_VAR 0 1
101071: NOT
101072: IFFALSE 101076
// exit ;
101074: GO 101125
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101076: LD_ADDR_VAR 0 2
101080: PUSH
101081: LD_VAR 0 1
101085: PPUSH
101086: LD_INT 1
101088: PPUSH
101089: CALL_OW 275
101093: PUSH
101094: LD_VAR 0 1
101098: PPUSH
101099: LD_INT 2
101101: PPUSH
101102: CALL_OW 275
101106: PUSH
101107: LD_VAR 0 1
101111: PPUSH
101112: LD_INT 3
101114: PPUSH
101115: CALL_OW 275
101119: PUSH
101120: EMPTY
101121: LIST
101122: LIST
101123: LIST
101124: ST_TO_ADDR
// end ;
101125: LD_VAR 0 2
101129: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101130: LD_INT 0
101132: PPUSH
101133: PPUSH
// result := array ;
101134: LD_ADDR_VAR 0 3
101138: PUSH
101139: LD_VAR 0 1
101143: ST_TO_ADDR
// if size >= result then
101144: LD_VAR 0 2
101148: PUSH
101149: LD_VAR 0 3
101153: GREATEREQUAL
101154: IFFALSE 101158
// exit ;
101156: GO 101208
// if size then
101158: LD_VAR 0 2
101162: IFFALSE 101208
// for i := array downto size do
101164: LD_ADDR_VAR 0 4
101168: PUSH
101169: DOUBLE
101170: LD_VAR 0 1
101174: INC
101175: ST_TO_ADDR
101176: LD_VAR 0 2
101180: PUSH
101181: FOR_DOWNTO
101182: IFFALSE 101206
// result := Delete ( result , result ) ;
101184: LD_ADDR_VAR 0 3
101188: PUSH
101189: LD_VAR 0 3
101193: PPUSH
101194: LD_VAR 0 3
101198: PPUSH
101199: CALL_OW 3
101203: ST_TO_ADDR
101204: GO 101181
101206: POP
101207: POP
// end ;
101208: LD_VAR 0 3
101212: RET
// export function ComExit ( unit ) ; var tmp ; begin
101213: LD_INT 0
101215: PPUSH
101216: PPUSH
// if not IsInUnit ( unit ) then
101217: LD_VAR 0 1
101221: PPUSH
101222: CALL_OW 310
101226: NOT
101227: IFFALSE 101231
// exit ;
101229: GO 101291
// tmp := IsInUnit ( unit ) ;
101231: LD_ADDR_VAR 0 3
101235: PUSH
101236: LD_VAR 0 1
101240: PPUSH
101241: CALL_OW 310
101245: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101246: LD_VAR 0 3
101250: PPUSH
101251: CALL_OW 247
101255: PUSH
101256: LD_INT 2
101258: EQUAL
101259: IFFALSE 101272
// ComExitVehicle ( unit ) else
101261: LD_VAR 0 1
101265: PPUSH
101266: CALL_OW 121
101270: GO 101281
// ComExitBuilding ( unit ) ;
101272: LD_VAR 0 1
101276: PPUSH
101277: CALL_OW 122
// result := tmp ;
101281: LD_ADDR_VAR 0 2
101285: PUSH
101286: LD_VAR 0 3
101290: ST_TO_ADDR
// end ;
101291: LD_VAR 0 2
101295: RET
// export function ComExitAll ( units ) ; var i ; begin
101296: LD_INT 0
101298: PPUSH
101299: PPUSH
// if not units then
101300: LD_VAR 0 1
101304: NOT
101305: IFFALSE 101309
// exit ;
101307: GO 101335
// for i in units do
101309: LD_ADDR_VAR 0 3
101313: PUSH
101314: LD_VAR 0 1
101318: PUSH
101319: FOR_IN
101320: IFFALSE 101333
// ComExit ( i ) ;
101322: LD_VAR 0 3
101326: PPUSH
101327: CALL 101213 0 1
101331: GO 101319
101333: POP
101334: POP
// end ;
101335: LD_VAR 0 2
101339: RET
// export function ResetHc ; begin
101340: LD_INT 0
101342: PPUSH
// InitHc ;
101343: CALL_OW 19
// hc_importance := 0 ;
101347: LD_ADDR_OWVAR 32
101351: PUSH
101352: LD_INT 0
101354: ST_TO_ADDR
// end ;
101355: LD_VAR 0 1
101359: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101360: LD_INT 0
101362: PPUSH
101363: PPUSH
101364: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101365: LD_ADDR_VAR 0 6
101369: PUSH
101370: LD_VAR 0 1
101374: PUSH
101375: LD_VAR 0 3
101379: PLUS
101380: PUSH
101381: LD_INT 2
101383: DIV
101384: ST_TO_ADDR
// if _x < 0 then
101385: LD_VAR 0 6
101389: PUSH
101390: LD_INT 0
101392: LESS
101393: IFFALSE 101410
// _x := _x * - 1 ;
101395: LD_ADDR_VAR 0 6
101399: PUSH
101400: LD_VAR 0 6
101404: PUSH
101405: LD_INT 1
101407: NEG
101408: MUL
101409: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101410: LD_ADDR_VAR 0 7
101414: PUSH
101415: LD_VAR 0 2
101419: PUSH
101420: LD_VAR 0 4
101424: PLUS
101425: PUSH
101426: LD_INT 2
101428: DIV
101429: ST_TO_ADDR
// if _y < 0 then
101430: LD_VAR 0 7
101434: PUSH
101435: LD_INT 0
101437: LESS
101438: IFFALSE 101455
// _y := _y * - 1 ;
101440: LD_ADDR_VAR 0 7
101444: PUSH
101445: LD_VAR 0 7
101449: PUSH
101450: LD_INT 1
101452: NEG
101453: MUL
101454: ST_TO_ADDR
// result := [ _x , _y ] ;
101455: LD_ADDR_VAR 0 5
101459: PUSH
101460: LD_VAR 0 6
101464: PUSH
101465: LD_VAR 0 7
101469: PUSH
101470: EMPTY
101471: LIST
101472: LIST
101473: ST_TO_ADDR
// end ;
101474: LD_VAR 0 5
101478: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101479: LD_INT 0
101481: PPUSH
101482: PPUSH
101483: PPUSH
101484: PPUSH
// task := GetTaskList ( unit ) ;
101485: LD_ADDR_VAR 0 7
101489: PUSH
101490: LD_VAR 0 1
101494: PPUSH
101495: CALL_OW 437
101499: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101500: LD_VAR 0 7
101504: NOT
101505: PUSH
101506: LD_VAR 0 1
101510: PPUSH
101511: LD_VAR 0 2
101515: PPUSH
101516: CALL_OW 308
101520: NOT
101521: AND
101522: IFFALSE 101526
// exit ;
101524: GO 101644
// if IsInArea ( unit , area ) then
101526: LD_VAR 0 1
101530: PPUSH
101531: LD_VAR 0 2
101535: PPUSH
101536: CALL_OW 308
101540: IFFALSE 101558
// begin ComMoveToArea ( unit , goAway ) ;
101542: LD_VAR 0 1
101546: PPUSH
101547: LD_VAR 0 3
101551: PPUSH
101552: CALL_OW 113
// exit ;
101556: GO 101644
// end ; if task [ 1 ] [ 1 ] <> M then
101558: LD_VAR 0 7
101562: PUSH
101563: LD_INT 1
101565: ARRAY
101566: PUSH
101567: LD_INT 1
101569: ARRAY
101570: PUSH
101571: LD_STRING M
101573: NONEQUAL
101574: IFFALSE 101578
// exit ;
101576: GO 101644
// x := task [ 1 ] [ 2 ] ;
101578: LD_ADDR_VAR 0 5
101582: PUSH
101583: LD_VAR 0 7
101587: PUSH
101588: LD_INT 1
101590: ARRAY
101591: PUSH
101592: LD_INT 2
101594: ARRAY
101595: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101596: LD_ADDR_VAR 0 6
101600: PUSH
101601: LD_VAR 0 7
101605: PUSH
101606: LD_INT 1
101608: ARRAY
101609: PUSH
101610: LD_INT 3
101612: ARRAY
101613: ST_TO_ADDR
// if InArea ( x , y , area ) then
101614: LD_VAR 0 5
101618: PPUSH
101619: LD_VAR 0 6
101623: PPUSH
101624: LD_VAR 0 2
101628: PPUSH
101629: CALL_OW 309
101633: IFFALSE 101644
// ComStop ( unit ) ;
101635: LD_VAR 0 1
101639: PPUSH
101640: CALL_OW 141
// end ;
101644: LD_VAR 0 4
101648: RET
// export function Abs ( value ) ; begin
101649: LD_INT 0
101651: PPUSH
// result := value ;
101652: LD_ADDR_VAR 0 2
101656: PUSH
101657: LD_VAR 0 1
101661: ST_TO_ADDR
// if value < 0 then
101662: LD_VAR 0 1
101666: PUSH
101667: LD_INT 0
101669: LESS
101670: IFFALSE 101687
// result := value * - 1 ;
101672: LD_ADDR_VAR 0 2
101676: PUSH
101677: LD_VAR 0 1
101681: PUSH
101682: LD_INT 1
101684: NEG
101685: MUL
101686: ST_TO_ADDR
// end ;
101687: LD_VAR 0 2
101691: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101692: LD_INT 0
101694: PPUSH
101695: PPUSH
101696: PPUSH
101697: PPUSH
101698: PPUSH
101699: PPUSH
101700: PPUSH
101701: PPUSH
// if not unit or not building then
101702: LD_VAR 0 1
101706: NOT
101707: PUSH
101708: LD_VAR 0 2
101712: NOT
101713: OR
101714: IFFALSE 101718
// exit ;
101716: GO 101944
// x := GetX ( building ) ;
101718: LD_ADDR_VAR 0 4
101722: PUSH
101723: LD_VAR 0 2
101727: PPUSH
101728: CALL_OW 250
101732: ST_TO_ADDR
// y := GetY ( building ) ;
101733: LD_ADDR_VAR 0 6
101737: PUSH
101738: LD_VAR 0 2
101742: PPUSH
101743: CALL_OW 251
101747: ST_TO_ADDR
// d := GetDir ( building ) ;
101748: LD_ADDR_VAR 0 8
101752: PUSH
101753: LD_VAR 0 2
101757: PPUSH
101758: CALL_OW 254
101762: ST_TO_ADDR
// r := 4 ;
101763: LD_ADDR_VAR 0 9
101767: PUSH
101768: LD_INT 4
101770: ST_TO_ADDR
// for i := 1 to 5 do
101771: LD_ADDR_VAR 0 10
101775: PUSH
101776: DOUBLE
101777: LD_INT 1
101779: DEC
101780: ST_TO_ADDR
101781: LD_INT 5
101783: PUSH
101784: FOR_TO
101785: IFFALSE 101942
// begin _x := ShiftX ( x , d , r + i ) ;
101787: LD_ADDR_VAR 0 5
101791: PUSH
101792: LD_VAR 0 4
101796: PPUSH
101797: LD_VAR 0 8
101801: PPUSH
101802: LD_VAR 0 9
101806: PUSH
101807: LD_VAR 0 10
101811: PLUS
101812: PPUSH
101813: CALL_OW 272
101817: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
101818: LD_ADDR_VAR 0 7
101822: PUSH
101823: LD_VAR 0 6
101827: PPUSH
101828: LD_VAR 0 8
101832: PPUSH
101833: LD_VAR 0 9
101837: PUSH
101838: LD_VAR 0 10
101842: PLUS
101843: PPUSH
101844: CALL_OW 273
101848: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
101849: LD_VAR 0 5
101853: PPUSH
101854: LD_VAR 0 7
101858: PPUSH
101859: CALL_OW 488
101863: PUSH
101864: LD_VAR 0 5
101868: PPUSH
101869: LD_VAR 0 7
101873: PPUSH
101874: CALL_OW 428
101878: PPUSH
101879: CALL_OW 247
101883: PUSH
101884: LD_INT 3
101886: PUSH
101887: LD_INT 2
101889: PUSH
101890: EMPTY
101891: LIST
101892: LIST
101893: IN
101894: NOT
101895: AND
101896: IFFALSE 101940
// begin ComMoveXY ( unit , _x , _y ) ;
101898: LD_VAR 0 1
101902: PPUSH
101903: LD_VAR 0 5
101907: PPUSH
101908: LD_VAR 0 7
101912: PPUSH
101913: CALL_OW 111
// result := [ _x , _y ] ;
101917: LD_ADDR_VAR 0 3
101921: PUSH
101922: LD_VAR 0 5
101926: PUSH
101927: LD_VAR 0 7
101931: PUSH
101932: EMPTY
101933: LIST
101934: LIST
101935: ST_TO_ADDR
// exit ;
101936: POP
101937: POP
101938: GO 101944
// end ; end ;
101940: GO 101784
101942: POP
101943: POP
// end ;
101944: LD_VAR 0 3
101948: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
101949: LD_INT 0
101951: PPUSH
101952: PPUSH
101953: PPUSH
// result := 0 ;
101954: LD_ADDR_VAR 0 3
101958: PUSH
101959: LD_INT 0
101961: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
101962: LD_VAR 0 1
101966: PUSH
101967: LD_INT 0
101969: LESS
101970: PUSH
101971: LD_VAR 0 1
101975: PUSH
101976: LD_INT 8
101978: GREATER
101979: OR
101980: PUSH
101981: LD_VAR 0 2
101985: PUSH
101986: LD_INT 0
101988: LESS
101989: OR
101990: PUSH
101991: LD_VAR 0 2
101995: PUSH
101996: LD_INT 8
101998: GREATER
101999: OR
102000: IFFALSE 102004
// exit ;
102002: GO 102079
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
102004: LD_ADDR_VAR 0 4
102008: PUSH
102009: LD_INT 22
102011: PUSH
102012: LD_VAR 0 2
102016: PUSH
102017: EMPTY
102018: LIST
102019: LIST
102020: PPUSH
102021: CALL_OW 69
102025: PUSH
102026: FOR_IN
102027: IFFALSE 102077
// begin un := UnitShoot ( i ) ;
102029: LD_ADDR_VAR 0 5
102033: PUSH
102034: LD_VAR 0 4
102038: PPUSH
102039: CALL_OW 504
102043: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102044: LD_VAR 0 5
102048: PPUSH
102049: CALL_OW 255
102053: PUSH
102054: LD_VAR 0 1
102058: EQUAL
102059: IFFALSE 102075
// begin result := un ;
102061: LD_ADDR_VAR 0 3
102065: PUSH
102066: LD_VAR 0 5
102070: ST_TO_ADDR
// exit ;
102071: POP
102072: POP
102073: GO 102079
// end ; end ;
102075: GO 102026
102077: POP
102078: POP
// end ;
102079: LD_VAR 0 3
102083: RET
// export function GetCargoBay ( units ) ; begin
102084: LD_INT 0
102086: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
102087: LD_ADDR_VAR 0 2
102091: PUSH
102092: LD_VAR 0 1
102096: PPUSH
102097: LD_INT 2
102099: PUSH
102100: LD_INT 34
102102: PUSH
102103: LD_INT 12
102105: PUSH
102106: EMPTY
102107: LIST
102108: LIST
102109: PUSH
102110: LD_INT 34
102112: PUSH
102113: LD_INT 51
102115: PUSH
102116: EMPTY
102117: LIST
102118: LIST
102119: PUSH
102120: LD_INT 34
102122: PUSH
102123: LD_INT 32
102125: PUSH
102126: EMPTY
102127: LIST
102128: LIST
102129: PUSH
102130: LD_INT 34
102132: PUSH
102133: LD_INT 89
102135: PUSH
102136: EMPTY
102137: LIST
102138: LIST
102139: PUSH
102140: EMPTY
102141: LIST
102142: LIST
102143: LIST
102144: LIST
102145: LIST
102146: PPUSH
102147: CALL_OW 72
102151: ST_TO_ADDR
// end ;
102152: LD_VAR 0 2
102156: RET
// export function Negate ( value ) ; begin
102157: LD_INT 0
102159: PPUSH
// result := not value ;
102160: LD_ADDR_VAR 0 2
102164: PUSH
102165: LD_VAR 0 1
102169: NOT
102170: ST_TO_ADDR
// end ;
102171: LD_VAR 0 2
102175: RET
// export function Inc ( value ) ; begin
102176: LD_INT 0
102178: PPUSH
// result := value + 1 ;
102179: LD_ADDR_VAR 0 2
102183: PUSH
102184: LD_VAR 0 1
102188: PUSH
102189: LD_INT 1
102191: PLUS
102192: ST_TO_ADDR
// end ;
102193: LD_VAR 0 2
102197: RET
// export function Dec ( value ) ; begin
102198: LD_INT 0
102200: PPUSH
// result := value - 1 ;
102201: LD_ADDR_VAR 0 2
102205: PUSH
102206: LD_VAR 0 1
102210: PUSH
102211: LD_INT 1
102213: MINUS
102214: ST_TO_ADDR
// end ;
102215: LD_VAR 0 2
102219: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
102220: LD_INT 0
102222: PPUSH
102223: PPUSH
102224: PPUSH
102225: PPUSH
102226: PPUSH
102227: PPUSH
102228: PPUSH
102229: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102230: LD_VAR 0 1
102234: PPUSH
102235: LD_VAR 0 2
102239: PPUSH
102240: CALL_OW 488
102244: NOT
102245: PUSH
102246: LD_VAR 0 3
102250: PPUSH
102251: LD_VAR 0 4
102255: PPUSH
102256: CALL_OW 488
102260: NOT
102261: OR
102262: IFFALSE 102275
// begin result := - 1 ;
102264: LD_ADDR_VAR 0 5
102268: PUSH
102269: LD_INT 1
102271: NEG
102272: ST_TO_ADDR
// exit ;
102273: GO 102510
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102275: LD_ADDR_VAR 0 12
102279: PUSH
102280: LD_VAR 0 1
102284: PPUSH
102285: LD_VAR 0 2
102289: PPUSH
102290: LD_VAR 0 3
102294: PPUSH
102295: LD_VAR 0 4
102299: PPUSH
102300: CALL 101360 0 4
102304: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102305: LD_ADDR_VAR 0 11
102309: PUSH
102310: LD_VAR 0 1
102314: PPUSH
102315: LD_VAR 0 2
102319: PPUSH
102320: LD_VAR 0 12
102324: PUSH
102325: LD_INT 1
102327: ARRAY
102328: PPUSH
102329: LD_VAR 0 12
102333: PUSH
102334: LD_INT 2
102336: ARRAY
102337: PPUSH
102338: CALL_OW 298
102342: ST_TO_ADDR
// distance := 9999 ;
102343: LD_ADDR_VAR 0 10
102347: PUSH
102348: LD_INT 9999
102350: ST_TO_ADDR
// for i := 0 to 5 do
102351: LD_ADDR_VAR 0 6
102355: PUSH
102356: DOUBLE
102357: LD_INT 0
102359: DEC
102360: ST_TO_ADDR
102361: LD_INT 5
102363: PUSH
102364: FOR_TO
102365: IFFALSE 102508
// begin _x := ShiftX ( x1 , i , centerDist ) ;
102367: LD_ADDR_VAR 0 7
102371: PUSH
102372: LD_VAR 0 1
102376: PPUSH
102377: LD_VAR 0 6
102381: PPUSH
102382: LD_VAR 0 11
102386: PPUSH
102387: CALL_OW 272
102391: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
102392: LD_ADDR_VAR 0 8
102396: PUSH
102397: LD_VAR 0 2
102401: PPUSH
102402: LD_VAR 0 6
102406: PPUSH
102407: LD_VAR 0 11
102411: PPUSH
102412: CALL_OW 273
102416: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102417: LD_VAR 0 7
102421: PPUSH
102422: LD_VAR 0 8
102426: PPUSH
102427: CALL_OW 488
102431: NOT
102432: IFFALSE 102436
// continue ;
102434: GO 102364
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
102436: LD_ADDR_VAR 0 9
102440: PUSH
102441: LD_VAR 0 12
102445: PUSH
102446: LD_INT 1
102448: ARRAY
102449: PPUSH
102450: LD_VAR 0 12
102454: PUSH
102455: LD_INT 2
102457: ARRAY
102458: PPUSH
102459: LD_VAR 0 7
102463: PPUSH
102464: LD_VAR 0 8
102468: PPUSH
102469: CALL_OW 298
102473: ST_TO_ADDR
// if tmp < distance then
102474: LD_VAR 0 9
102478: PUSH
102479: LD_VAR 0 10
102483: LESS
102484: IFFALSE 102506
// begin result := i ;
102486: LD_ADDR_VAR 0 5
102490: PUSH
102491: LD_VAR 0 6
102495: ST_TO_ADDR
// distance := tmp ;
102496: LD_ADDR_VAR 0 10
102500: PUSH
102501: LD_VAR 0 9
102505: ST_TO_ADDR
// end ; end ;
102506: GO 102364
102508: POP
102509: POP
// end ;
102510: LD_VAR 0 5
102514: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102515: LD_INT 0
102517: PPUSH
102518: PPUSH
// if not driver or not IsInUnit ( driver ) then
102519: LD_VAR 0 1
102523: NOT
102524: PUSH
102525: LD_VAR 0 1
102529: PPUSH
102530: CALL_OW 310
102534: NOT
102535: OR
102536: IFFALSE 102540
// exit ;
102538: GO 102630
// vehicle := IsInUnit ( driver ) ;
102540: LD_ADDR_VAR 0 3
102544: PUSH
102545: LD_VAR 0 1
102549: PPUSH
102550: CALL_OW 310
102554: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102555: LD_VAR 0 1
102559: PPUSH
102560: LD_STRING \
102562: PUSH
102563: LD_INT 0
102565: PUSH
102566: LD_INT 0
102568: PUSH
102569: LD_INT 0
102571: PUSH
102572: LD_INT 0
102574: PUSH
102575: LD_INT 0
102577: PUSH
102578: LD_INT 0
102580: PUSH
102581: EMPTY
102582: LIST
102583: LIST
102584: LIST
102585: LIST
102586: LIST
102587: LIST
102588: LIST
102589: PUSH
102590: LD_STRING E
102592: PUSH
102593: LD_INT 0
102595: PUSH
102596: LD_INT 0
102598: PUSH
102599: LD_VAR 0 3
102603: PUSH
102604: LD_INT 0
102606: PUSH
102607: LD_INT 0
102609: PUSH
102610: LD_INT 0
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: LIST
102617: LIST
102618: LIST
102619: LIST
102620: LIST
102621: PUSH
102622: EMPTY
102623: LIST
102624: LIST
102625: PPUSH
102626: CALL_OW 446
// end ;
102630: LD_VAR 0 2
102634: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102635: LD_INT 0
102637: PPUSH
102638: PPUSH
// if not driver or not IsInUnit ( driver ) then
102639: LD_VAR 0 1
102643: NOT
102644: PUSH
102645: LD_VAR 0 1
102649: PPUSH
102650: CALL_OW 310
102654: NOT
102655: OR
102656: IFFALSE 102660
// exit ;
102658: GO 102750
// vehicle := IsInUnit ( driver ) ;
102660: LD_ADDR_VAR 0 3
102664: PUSH
102665: LD_VAR 0 1
102669: PPUSH
102670: CALL_OW 310
102674: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102675: LD_VAR 0 1
102679: PPUSH
102680: LD_STRING \
102682: PUSH
102683: LD_INT 0
102685: PUSH
102686: LD_INT 0
102688: PUSH
102689: LD_INT 0
102691: PUSH
102692: LD_INT 0
102694: PUSH
102695: LD_INT 0
102697: PUSH
102698: LD_INT 0
102700: PUSH
102701: EMPTY
102702: LIST
102703: LIST
102704: LIST
102705: LIST
102706: LIST
102707: LIST
102708: LIST
102709: PUSH
102710: LD_STRING E
102712: PUSH
102713: LD_INT 0
102715: PUSH
102716: LD_INT 0
102718: PUSH
102719: LD_VAR 0 3
102723: PUSH
102724: LD_INT 0
102726: PUSH
102727: LD_INT 0
102729: PUSH
102730: LD_INT 0
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: LIST
102737: LIST
102738: LIST
102739: LIST
102740: LIST
102741: PUSH
102742: EMPTY
102743: LIST
102744: LIST
102745: PPUSH
102746: CALL_OW 447
// end ;
102750: LD_VAR 0 2
102754: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
102755: LD_INT 0
102757: PPUSH
102758: PPUSH
102759: PPUSH
// tmp := [ ] ;
102760: LD_ADDR_VAR 0 5
102764: PUSH
102765: EMPTY
102766: ST_TO_ADDR
// for i in units do
102767: LD_ADDR_VAR 0 4
102771: PUSH
102772: LD_VAR 0 1
102776: PUSH
102777: FOR_IN
102778: IFFALSE 102816
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
102780: LD_ADDR_VAR 0 5
102784: PUSH
102785: LD_VAR 0 5
102789: PPUSH
102790: LD_VAR 0 5
102794: PUSH
102795: LD_INT 1
102797: PLUS
102798: PPUSH
102799: LD_VAR 0 4
102803: PPUSH
102804: CALL_OW 256
102808: PPUSH
102809: CALL_OW 2
102813: ST_TO_ADDR
102814: GO 102777
102816: POP
102817: POP
// if not tmp then
102818: LD_VAR 0 5
102822: NOT
102823: IFFALSE 102827
// exit ;
102825: GO 102875
// if asc then
102827: LD_VAR 0 2
102831: IFFALSE 102855
// result := SortListByListAsc ( units , tmp ) else
102833: LD_ADDR_VAR 0 3
102837: PUSH
102838: LD_VAR 0 1
102842: PPUSH
102843: LD_VAR 0 5
102847: PPUSH
102848: CALL_OW 76
102852: ST_TO_ADDR
102853: GO 102875
// result := SortListByListDesc ( units , tmp ) ;
102855: LD_ADDR_VAR 0 3
102859: PUSH
102860: LD_VAR 0 1
102864: PPUSH
102865: LD_VAR 0 5
102869: PPUSH
102870: CALL_OW 77
102874: ST_TO_ADDR
// end ;
102875: LD_VAR 0 3
102879: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
102880: LD_INT 0
102882: PPUSH
102883: PPUSH
// task := GetTaskList ( mech ) ;
102884: LD_ADDR_VAR 0 4
102888: PUSH
102889: LD_VAR 0 1
102893: PPUSH
102894: CALL_OW 437
102898: ST_TO_ADDR
// if not task then
102899: LD_VAR 0 4
102903: NOT
102904: IFFALSE 102908
// exit ;
102906: GO 102950
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
102908: LD_ADDR_VAR 0 3
102912: PUSH
102913: LD_VAR 0 4
102917: PUSH
102918: LD_INT 1
102920: ARRAY
102921: PUSH
102922: LD_INT 1
102924: ARRAY
102925: PUSH
102926: LD_STRING r
102928: EQUAL
102929: PUSH
102930: LD_VAR 0 4
102934: PUSH
102935: LD_INT 1
102937: ARRAY
102938: PUSH
102939: LD_INT 4
102941: ARRAY
102942: PUSH
102943: LD_VAR 0 2
102947: EQUAL
102948: AND
102949: ST_TO_ADDR
// end ;
102950: LD_VAR 0 3
102954: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
102955: LD_INT 0
102957: PPUSH
// SetDir ( unit , d ) ;
102958: LD_VAR 0 1
102962: PPUSH
102963: LD_VAR 0 4
102967: PPUSH
102968: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
102972: LD_VAR 0 1
102976: PPUSH
102977: LD_VAR 0 2
102981: PPUSH
102982: LD_VAR 0 3
102986: PPUSH
102987: LD_VAR 0 5
102991: PPUSH
102992: CALL_OW 48
// end ;
102996: LD_VAR 0 6
103000: RET
// export function ToNaturalNumber ( number ) ; begin
103001: LD_INT 0
103003: PPUSH
// result := number div 1 ;
103004: LD_ADDR_VAR 0 2
103008: PUSH
103009: LD_VAR 0 1
103013: PUSH
103014: LD_INT 1
103016: DIV
103017: ST_TO_ADDR
// if number < 0 then
103018: LD_VAR 0 1
103022: PUSH
103023: LD_INT 0
103025: LESS
103026: IFFALSE 103036
// result := 0 ;
103028: LD_ADDR_VAR 0 2
103032: PUSH
103033: LD_INT 0
103035: ST_TO_ADDR
// end ;
103036: LD_VAR 0 2
103040: RET
// export function SortByClass ( units , class ) ; var un ; begin
103041: LD_INT 0
103043: PPUSH
103044: PPUSH
// if not units or not class then
103045: LD_VAR 0 1
103049: NOT
103050: PUSH
103051: LD_VAR 0 2
103055: NOT
103056: OR
103057: IFFALSE 103061
// exit ;
103059: GO 103156
// result := [ ] ;
103061: LD_ADDR_VAR 0 3
103065: PUSH
103066: EMPTY
103067: ST_TO_ADDR
// for un in units do
103068: LD_ADDR_VAR 0 4
103072: PUSH
103073: LD_VAR 0 1
103077: PUSH
103078: FOR_IN
103079: IFFALSE 103154
// if GetClass ( un ) = class then
103081: LD_VAR 0 4
103085: PPUSH
103086: CALL_OW 257
103090: PUSH
103091: LD_VAR 0 2
103095: EQUAL
103096: IFFALSE 103123
// result := Insert ( result , 1 , un ) else
103098: LD_ADDR_VAR 0 3
103102: PUSH
103103: LD_VAR 0 3
103107: PPUSH
103108: LD_INT 1
103110: PPUSH
103111: LD_VAR 0 4
103115: PPUSH
103116: CALL_OW 2
103120: ST_TO_ADDR
103121: GO 103152
// result := Replace ( result , result + 1 , un ) ;
103123: LD_ADDR_VAR 0 3
103127: PUSH
103128: LD_VAR 0 3
103132: PPUSH
103133: LD_VAR 0 3
103137: PUSH
103138: LD_INT 1
103140: PLUS
103141: PPUSH
103142: LD_VAR 0 4
103146: PPUSH
103147: CALL_OW 1
103151: ST_TO_ADDR
103152: GO 103078
103154: POP
103155: POP
// end ;
103156: LD_VAR 0 3
103160: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
103161: LD_INT 0
103163: PPUSH
103164: PPUSH
103165: PPUSH
103166: PPUSH
103167: PPUSH
103168: PPUSH
103169: PPUSH
// result := [ ] ;
103170: LD_ADDR_VAR 0 4
103174: PUSH
103175: EMPTY
103176: ST_TO_ADDR
// if x - r < 0 then
103177: LD_VAR 0 1
103181: PUSH
103182: LD_VAR 0 3
103186: MINUS
103187: PUSH
103188: LD_INT 0
103190: LESS
103191: IFFALSE 103203
// min_x := 0 else
103193: LD_ADDR_VAR 0 8
103197: PUSH
103198: LD_INT 0
103200: ST_TO_ADDR
103201: GO 103219
// min_x := x - r ;
103203: LD_ADDR_VAR 0 8
103207: PUSH
103208: LD_VAR 0 1
103212: PUSH
103213: LD_VAR 0 3
103217: MINUS
103218: ST_TO_ADDR
// if y - r < 0 then
103219: LD_VAR 0 2
103223: PUSH
103224: LD_VAR 0 3
103228: MINUS
103229: PUSH
103230: LD_INT 0
103232: LESS
103233: IFFALSE 103245
// min_y := 0 else
103235: LD_ADDR_VAR 0 7
103239: PUSH
103240: LD_INT 0
103242: ST_TO_ADDR
103243: GO 103261
// min_y := y - r ;
103245: LD_ADDR_VAR 0 7
103249: PUSH
103250: LD_VAR 0 2
103254: PUSH
103255: LD_VAR 0 3
103259: MINUS
103260: ST_TO_ADDR
// max_x := x + r ;
103261: LD_ADDR_VAR 0 9
103265: PUSH
103266: LD_VAR 0 1
103270: PUSH
103271: LD_VAR 0 3
103275: PLUS
103276: ST_TO_ADDR
// max_y := y + r ;
103277: LD_ADDR_VAR 0 10
103281: PUSH
103282: LD_VAR 0 2
103286: PUSH
103287: LD_VAR 0 3
103291: PLUS
103292: ST_TO_ADDR
// for _x = min_x to max_x do
103293: LD_ADDR_VAR 0 5
103297: PUSH
103298: DOUBLE
103299: LD_VAR 0 8
103303: DEC
103304: ST_TO_ADDR
103305: LD_VAR 0 9
103309: PUSH
103310: FOR_TO
103311: IFFALSE 103412
// for _y = min_y to max_y do
103313: LD_ADDR_VAR 0 6
103317: PUSH
103318: DOUBLE
103319: LD_VAR 0 7
103323: DEC
103324: ST_TO_ADDR
103325: LD_VAR 0 10
103329: PUSH
103330: FOR_TO
103331: IFFALSE 103408
// begin if not ValidHex ( _x , _y ) then
103333: LD_VAR 0 5
103337: PPUSH
103338: LD_VAR 0 6
103342: PPUSH
103343: CALL_OW 488
103347: NOT
103348: IFFALSE 103352
// continue ;
103350: GO 103330
// if GetResourceTypeXY ( _x , _y ) then
103352: LD_VAR 0 5
103356: PPUSH
103357: LD_VAR 0 6
103361: PPUSH
103362: CALL_OW 283
103366: IFFALSE 103406
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
103368: LD_ADDR_VAR 0 4
103372: PUSH
103373: LD_VAR 0 4
103377: PPUSH
103378: LD_VAR 0 4
103382: PUSH
103383: LD_INT 1
103385: PLUS
103386: PPUSH
103387: LD_VAR 0 5
103391: PUSH
103392: LD_VAR 0 6
103396: PUSH
103397: EMPTY
103398: LIST
103399: LIST
103400: PPUSH
103401: CALL_OW 1
103405: ST_TO_ADDR
// end ;
103406: GO 103330
103408: POP
103409: POP
103410: GO 103310
103412: POP
103413: POP
// end ;
103414: LD_VAR 0 4
103418: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
103419: LD_INT 0
103421: PPUSH
103422: PPUSH
103423: PPUSH
103424: PPUSH
103425: PPUSH
103426: PPUSH
103427: PPUSH
103428: PPUSH
// if not units then
103429: LD_VAR 0 1
103433: NOT
103434: IFFALSE 103438
// exit ;
103436: GO 103962
// result := UnitFilter ( units , [ f_ok ] ) ;
103438: LD_ADDR_VAR 0 3
103442: PUSH
103443: LD_VAR 0 1
103447: PPUSH
103448: LD_INT 50
103450: PUSH
103451: EMPTY
103452: LIST
103453: PPUSH
103454: CALL_OW 72
103458: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
103459: LD_ADDR_VAR 0 8
103463: PUSH
103464: LD_VAR 0 1
103468: PUSH
103469: LD_INT 1
103471: ARRAY
103472: PPUSH
103473: CALL_OW 255
103477: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
103478: LD_ADDR_VAR 0 10
103482: PUSH
103483: LD_INT 29
103485: PUSH
103486: LD_INT 91
103488: PUSH
103489: LD_INT 49
103491: PUSH
103492: EMPTY
103493: LIST
103494: LIST
103495: LIST
103496: ST_TO_ADDR
// if not result then
103497: LD_VAR 0 3
103501: NOT
103502: IFFALSE 103506
// exit ;
103504: GO 103962
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
103506: LD_ADDR_VAR 0 5
103510: PUSH
103511: LD_INT 81
103513: PUSH
103514: LD_VAR 0 8
103518: PUSH
103519: EMPTY
103520: LIST
103521: LIST
103522: PPUSH
103523: CALL_OW 69
103527: ST_TO_ADDR
// for i in result do
103528: LD_ADDR_VAR 0 4
103532: PUSH
103533: LD_VAR 0 3
103537: PUSH
103538: FOR_IN
103539: IFFALSE 103960
// begin tag := GetTag ( i ) + 1 ;
103541: LD_ADDR_VAR 0 9
103545: PUSH
103546: LD_VAR 0 4
103550: PPUSH
103551: CALL_OW 110
103555: PUSH
103556: LD_INT 1
103558: PLUS
103559: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
103560: LD_ADDR_VAR 0 7
103564: PUSH
103565: LD_VAR 0 4
103569: PPUSH
103570: CALL_OW 250
103574: PPUSH
103575: LD_VAR 0 4
103579: PPUSH
103580: CALL_OW 251
103584: PPUSH
103585: LD_INT 6
103587: PPUSH
103588: CALL 103161 0 3
103592: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
103593: LD_VAR 0 4
103597: PPUSH
103598: CALL_OW 247
103602: PUSH
103603: LD_INT 2
103605: EQUAL
103606: PUSH
103607: LD_VAR 0 7
103611: AND
103612: PUSH
103613: LD_VAR 0 4
103617: PPUSH
103618: CALL_OW 264
103622: PUSH
103623: LD_VAR 0 10
103627: IN
103628: NOT
103629: AND
103630: IFFALSE 103669
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
103632: LD_VAR 0 4
103636: PPUSH
103637: LD_VAR 0 7
103641: PUSH
103642: LD_INT 1
103644: ARRAY
103645: PUSH
103646: LD_INT 1
103648: ARRAY
103649: PPUSH
103650: LD_VAR 0 7
103654: PUSH
103655: LD_INT 1
103657: ARRAY
103658: PUSH
103659: LD_INT 2
103661: ARRAY
103662: PPUSH
103663: CALL_OW 116
103667: GO 103958
// if path > tag then
103669: LD_VAR 0 2
103673: PUSH
103674: LD_VAR 0 9
103678: GREATER
103679: IFFALSE 103887
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
103681: LD_ADDR_VAR 0 6
103685: PUSH
103686: LD_VAR 0 5
103690: PPUSH
103691: LD_INT 91
103693: PUSH
103694: LD_VAR 0 4
103698: PUSH
103699: LD_INT 8
103701: PUSH
103702: EMPTY
103703: LIST
103704: LIST
103705: LIST
103706: PPUSH
103707: CALL_OW 72
103711: ST_TO_ADDR
// if nearEnemy then
103712: LD_VAR 0 6
103716: IFFALSE 103785
// begin if GetWeapon ( i ) = ru_time_lapser then
103718: LD_VAR 0 4
103722: PPUSH
103723: CALL_OW 264
103727: PUSH
103728: LD_INT 49
103730: EQUAL
103731: IFFALSE 103759
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
103733: LD_VAR 0 4
103737: PPUSH
103738: LD_VAR 0 6
103742: PPUSH
103743: LD_VAR 0 4
103747: PPUSH
103748: CALL_OW 74
103752: PPUSH
103753: CALL_OW 112
103757: GO 103783
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
103759: LD_VAR 0 4
103763: PPUSH
103764: LD_VAR 0 6
103768: PPUSH
103769: LD_VAR 0 4
103773: PPUSH
103774: CALL_OW 74
103778: PPUSH
103779: CALL_OW 115
// end else
103783: GO 103885
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
103785: LD_VAR 0 4
103789: PPUSH
103790: LD_VAR 0 2
103794: PUSH
103795: LD_VAR 0 9
103799: ARRAY
103800: PUSH
103801: LD_INT 1
103803: ARRAY
103804: PPUSH
103805: LD_VAR 0 2
103809: PUSH
103810: LD_VAR 0 9
103814: ARRAY
103815: PUSH
103816: LD_INT 2
103818: ARRAY
103819: PPUSH
103820: CALL_OW 297
103824: PUSH
103825: LD_INT 6
103827: GREATER
103828: IFFALSE 103871
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
103830: LD_VAR 0 4
103834: PPUSH
103835: LD_VAR 0 2
103839: PUSH
103840: LD_VAR 0 9
103844: ARRAY
103845: PUSH
103846: LD_INT 1
103848: ARRAY
103849: PPUSH
103850: LD_VAR 0 2
103854: PUSH
103855: LD_VAR 0 9
103859: ARRAY
103860: PUSH
103861: LD_INT 2
103863: ARRAY
103864: PPUSH
103865: CALL_OW 114
103869: GO 103885
// SetTag ( i , tag ) ;
103871: LD_VAR 0 4
103875: PPUSH
103876: LD_VAR 0 9
103880: PPUSH
103881: CALL_OW 109
// end else
103885: GO 103958
// if enemy then
103887: LD_VAR 0 5
103891: IFFALSE 103958
// begin if GetWeapon ( i ) = ru_time_lapser then
103893: LD_VAR 0 4
103897: PPUSH
103898: CALL_OW 264
103902: PUSH
103903: LD_INT 49
103905: EQUAL
103906: IFFALSE 103934
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103908: LD_VAR 0 4
103912: PPUSH
103913: LD_VAR 0 5
103917: PPUSH
103918: LD_VAR 0 4
103922: PPUSH
103923: CALL_OW 74
103927: PPUSH
103928: CALL_OW 112
103932: GO 103958
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
103934: LD_VAR 0 4
103938: PPUSH
103939: LD_VAR 0 5
103943: PPUSH
103944: LD_VAR 0 4
103948: PPUSH
103949: CALL_OW 74
103953: PPUSH
103954: CALL_OW 115
// end ; end ;
103958: GO 103538
103960: POP
103961: POP
// end ;
103962: LD_VAR 0 3
103966: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
103967: LD_INT 0
103969: PPUSH
103970: PPUSH
103971: PPUSH
// if not unit or IsInUnit ( unit ) then
103972: LD_VAR 0 1
103976: NOT
103977: PUSH
103978: LD_VAR 0 1
103982: PPUSH
103983: CALL_OW 310
103987: OR
103988: IFFALSE 103992
// exit ;
103990: GO 104083
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
103992: LD_ADDR_VAR 0 4
103996: PUSH
103997: LD_VAR 0 1
104001: PPUSH
104002: CALL_OW 250
104006: PPUSH
104007: LD_VAR 0 2
104011: PPUSH
104012: LD_INT 1
104014: PPUSH
104015: CALL_OW 272
104019: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
104020: LD_ADDR_VAR 0 5
104024: PUSH
104025: LD_VAR 0 1
104029: PPUSH
104030: CALL_OW 251
104034: PPUSH
104035: LD_VAR 0 2
104039: PPUSH
104040: LD_INT 1
104042: PPUSH
104043: CALL_OW 273
104047: ST_TO_ADDR
// if ValidHex ( x , y ) then
104048: LD_VAR 0 4
104052: PPUSH
104053: LD_VAR 0 5
104057: PPUSH
104058: CALL_OW 488
104062: IFFALSE 104083
// ComTurnXY ( unit , x , y ) ;
104064: LD_VAR 0 1
104068: PPUSH
104069: LD_VAR 0 4
104073: PPUSH
104074: LD_VAR 0 5
104078: PPUSH
104079: CALL_OW 118
// end ;
104083: LD_VAR 0 3
104087: RET
// export function SeeUnits ( side , units ) ; var i ; begin
104088: LD_INT 0
104090: PPUSH
104091: PPUSH
// result := false ;
104092: LD_ADDR_VAR 0 3
104096: PUSH
104097: LD_INT 0
104099: ST_TO_ADDR
// if not units then
104100: LD_VAR 0 2
104104: NOT
104105: IFFALSE 104109
// exit ;
104107: GO 104154
// for i in units do
104109: LD_ADDR_VAR 0 4
104113: PUSH
104114: LD_VAR 0 2
104118: PUSH
104119: FOR_IN
104120: IFFALSE 104152
// if See ( side , i ) then
104122: LD_VAR 0 1
104126: PPUSH
104127: LD_VAR 0 4
104131: PPUSH
104132: CALL_OW 292
104136: IFFALSE 104150
// begin result := true ;
104138: LD_ADDR_VAR 0 3
104142: PUSH
104143: LD_INT 1
104145: ST_TO_ADDR
// exit ;
104146: POP
104147: POP
104148: GO 104154
// end ;
104150: GO 104119
104152: POP
104153: POP
// end ;
104154: LD_VAR 0 3
104158: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
104159: LD_INT 0
104161: PPUSH
104162: PPUSH
104163: PPUSH
104164: PPUSH
// if not unit or not points then
104165: LD_VAR 0 1
104169: NOT
104170: PUSH
104171: LD_VAR 0 2
104175: NOT
104176: OR
104177: IFFALSE 104181
// exit ;
104179: GO 104271
// dist := 99999 ;
104181: LD_ADDR_VAR 0 5
104185: PUSH
104186: LD_INT 99999
104188: ST_TO_ADDR
// for i in points do
104189: LD_ADDR_VAR 0 4
104193: PUSH
104194: LD_VAR 0 2
104198: PUSH
104199: FOR_IN
104200: IFFALSE 104269
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
104202: LD_ADDR_VAR 0 6
104206: PUSH
104207: LD_VAR 0 1
104211: PPUSH
104212: LD_VAR 0 4
104216: PUSH
104217: LD_INT 1
104219: ARRAY
104220: PPUSH
104221: LD_VAR 0 4
104225: PUSH
104226: LD_INT 2
104228: ARRAY
104229: PPUSH
104230: CALL_OW 297
104234: ST_TO_ADDR
// if tmpDist < dist then
104235: LD_VAR 0 6
104239: PUSH
104240: LD_VAR 0 5
104244: LESS
104245: IFFALSE 104267
// begin result := i ;
104247: LD_ADDR_VAR 0 3
104251: PUSH
104252: LD_VAR 0 4
104256: ST_TO_ADDR
// dist := tmpDist ;
104257: LD_ADDR_VAR 0 5
104261: PUSH
104262: LD_VAR 0 6
104266: ST_TO_ADDR
// end ; end ;
104267: GO 104199
104269: POP
104270: POP
// end ;
104271: LD_VAR 0 3
104275: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104276: LD_INT 0
104278: PPUSH
// uc_side := side ;
104279: LD_ADDR_OWVAR 20
104283: PUSH
104284: LD_VAR 0 1
104288: ST_TO_ADDR
// uc_nation := 3 ;
104289: LD_ADDR_OWVAR 21
104293: PUSH
104294: LD_INT 3
104296: ST_TO_ADDR
// vc_chassis := 25 ;
104297: LD_ADDR_OWVAR 37
104301: PUSH
104302: LD_INT 25
104304: ST_TO_ADDR
// vc_engine := engine_siberite ;
104305: LD_ADDR_OWVAR 39
104309: PUSH
104310: LD_INT 3
104312: ST_TO_ADDR
// vc_control := control_computer ;
104313: LD_ADDR_OWVAR 38
104317: PUSH
104318: LD_INT 3
104320: ST_TO_ADDR
// vc_weapon := 59 ;
104321: LD_ADDR_OWVAR 40
104325: PUSH
104326: LD_INT 59
104328: ST_TO_ADDR
// result := CreateVehicle ;
104329: LD_ADDR_VAR 0 5
104333: PUSH
104334: CALL_OW 45
104338: ST_TO_ADDR
// SetDir ( result , d ) ;
104339: LD_VAR 0 5
104343: PPUSH
104344: LD_VAR 0 4
104348: PPUSH
104349: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
104353: LD_VAR 0 5
104357: PPUSH
104358: LD_VAR 0 2
104362: PPUSH
104363: LD_VAR 0 3
104367: PPUSH
104368: LD_INT 0
104370: PPUSH
104371: CALL_OW 48
// end ;
104375: LD_VAR 0 5
104379: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
104380: LD_INT 0
104382: PPUSH
104383: PPUSH
104384: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
104385: LD_ADDR_VAR 0 2
104389: PUSH
104390: LD_INT 0
104392: PUSH
104393: LD_INT 0
104395: PUSH
104396: LD_INT 0
104398: PUSH
104399: LD_INT 0
104401: PUSH
104402: EMPTY
104403: LIST
104404: LIST
104405: LIST
104406: LIST
104407: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
104408: LD_VAR 0 1
104412: NOT
104413: PUSH
104414: LD_VAR 0 1
104418: PPUSH
104419: CALL_OW 264
104423: PUSH
104424: LD_INT 12
104426: PUSH
104427: LD_INT 51
104429: PUSH
104430: LD_INT 32
104432: PUSH
104433: LD_INT 89
104435: PUSH
104436: EMPTY
104437: LIST
104438: LIST
104439: LIST
104440: LIST
104441: IN
104442: NOT
104443: OR
104444: IFFALSE 104448
// exit ;
104446: GO 104546
// for i := 1 to 3 do
104448: LD_ADDR_VAR 0 3
104452: PUSH
104453: DOUBLE
104454: LD_INT 1
104456: DEC
104457: ST_TO_ADDR
104458: LD_INT 3
104460: PUSH
104461: FOR_TO
104462: IFFALSE 104544
// begin tmp := GetCargo ( cargo , i ) ;
104464: LD_ADDR_VAR 0 4
104468: PUSH
104469: LD_VAR 0 1
104473: PPUSH
104474: LD_VAR 0 3
104478: PPUSH
104479: CALL_OW 289
104483: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
104484: LD_ADDR_VAR 0 2
104488: PUSH
104489: LD_VAR 0 2
104493: PPUSH
104494: LD_VAR 0 3
104498: PPUSH
104499: LD_VAR 0 4
104503: PPUSH
104504: CALL_OW 1
104508: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
104509: LD_ADDR_VAR 0 2
104513: PUSH
104514: LD_VAR 0 2
104518: PPUSH
104519: LD_INT 4
104521: PPUSH
104522: LD_VAR 0 2
104526: PUSH
104527: LD_INT 4
104529: ARRAY
104530: PUSH
104531: LD_VAR 0 4
104535: PLUS
104536: PPUSH
104537: CALL_OW 1
104541: ST_TO_ADDR
// end ;
104542: GO 104461
104544: POP
104545: POP
// end ;
104546: LD_VAR 0 2
104550: RET
// export function Length ( array ) ; begin
104551: LD_INT 0
104553: PPUSH
// result := array + 0 ;
104554: LD_ADDR_VAR 0 2
104558: PUSH
104559: LD_VAR 0 1
104563: PUSH
104564: LD_INT 0
104566: PLUS
104567: ST_TO_ADDR
// end ;
104568: LD_VAR 0 2
104572: RET
// export function PrepareArray ( array ) ; begin
104573: LD_INT 0
104575: PPUSH
// result := array diff 0 ;
104576: LD_ADDR_VAR 0 2
104580: PUSH
104581: LD_VAR 0 1
104585: PUSH
104586: LD_INT 0
104588: DIFF
104589: ST_TO_ADDR
// if not result [ 1 ] then
104590: LD_VAR 0 2
104594: PUSH
104595: LD_INT 1
104597: ARRAY
104598: NOT
104599: IFFALSE 104619
// result := Delete ( result , 1 ) ;
104601: LD_ADDR_VAR 0 2
104605: PUSH
104606: LD_VAR 0 2
104610: PPUSH
104611: LD_INT 1
104613: PPUSH
104614: CALL_OW 3
104618: ST_TO_ADDR
// end ;
104619: LD_VAR 0 2
104623: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
104624: LD_INT 0
104626: PPUSH
104627: PPUSH
104628: PPUSH
104629: PPUSH
// sibRocketRange := 25 ;
104630: LD_ADDR_VAR 0 6
104634: PUSH
104635: LD_INT 25
104637: ST_TO_ADDR
// result := false ;
104638: LD_ADDR_VAR 0 4
104642: PUSH
104643: LD_INT 0
104645: ST_TO_ADDR
// for i := 0 to 5 do
104646: LD_ADDR_VAR 0 5
104650: PUSH
104651: DOUBLE
104652: LD_INT 0
104654: DEC
104655: ST_TO_ADDR
104656: LD_INT 5
104658: PUSH
104659: FOR_TO
104660: IFFALSE 104727
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
104662: LD_VAR 0 1
104666: PPUSH
104667: LD_VAR 0 5
104671: PPUSH
104672: LD_VAR 0 6
104676: PPUSH
104677: CALL_OW 272
104681: PPUSH
104682: LD_VAR 0 2
104686: PPUSH
104687: LD_VAR 0 5
104691: PPUSH
104692: LD_VAR 0 6
104696: PPUSH
104697: CALL_OW 273
104701: PPUSH
104702: LD_VAR 0 3
104706: PPUSH
104707: CALL_OW 309
104711: IFFALSE 104725
// begin result := true ;
104713: LD_ADDR_VAR 0 4
104717: PUSH
104718: LD_INT 1
104720: ST_TO_ADDR
// exit ;
104721: POP
104722: POP
104723: GO 104729
// end ;
104725: GO 104659
104727: POP
104728: POP
// end ;
104729: LD_VAR 0 4
104733: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
104734: LD_INT 0
104736: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
104737: LD_VAR 0 1
104741: PPUSH
104742: LD_VAR 0 2
104746: PPUSH
104747: LD_INT 0
104749: PPUSH
104750: LD_INT 0
104752: PPUSH
104753: LD_INT 1
104755: PPUSH
104756: LD_INT 0
104758: PPUSH
104759: CALL_OW 587
// end ; end_of_file
104763: LD_VAR 0 3
104767: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
104768: LD_VAR 0 1
104772: PUSH
104773: LD_INT 200
104775: DOUBLE
104776: GREATEREQUAL
104777: IFFALSE 104785
104779: LD_INT 299
104781: DOUBLE
104782: LESSEQUAL
104783: IFTRUE 104787
104785: GO 104819
104787: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
104788: LD_VAR 0 1
104792: PPUSH
104793: LD_VAR 0 2
104797: PPUSH
104798: LD_VAR 0 3
104802: PPUSH
104803: LD_VAR 0 4
104807: PPUSH
104808: LD_VAR 0 5
104812: PPUSH
104813: CALL 59434 0 5
104817: GO 104896
104819: LD_INT 300
104821: DOUBLE
104822: GREATEREQUAL
104823: IFFALSE 104831
104825: LD_INT 399
104827: DOUBLE
104828: LESSEQUAL
104829: IFTRUE 104833
104831: GO 104895
104833: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
104834: LD_VAR 0 1
104838: PPUSH
104839: LD_VAR 0 2
104843: PPUSH
104844: LD_VAR 0 3
104848: PPUSH
104849: LD_VAR 0 4
104853: PPUSH
104854: LD_VAR 0 5
104858: PPUSH
104859: LD_VAR 0 6
104863: PPUSH
104864: LD_VAR 0 7
104868: PPUSH
104869: LD_VAR 0 8
104873: PPUSH
104874: LD_VAR 0 9
104878: PPUSH
104879: LD_VAR 0 10
104883: PPUSH
104884: LD_VAR 0 11
104888: PPUSH
104889: CALL 55767 0 11
104893: GO 104896
104895: POP
// end ;
104896: PPOPN 11
104898: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
104899: LD_VAR 0 1
104903: PPUSH
104904: LD_VAR 0 2
104908: PPUSH
104909: LD_VAR 0 3
104913: PPUSH
104914: LD_VAR 0 4
104918: PPUSH
104919: LD_VAR 0 5
104923: PPUSH
104924: CALL 59170 0 5
// end ; end_of_file
104928: PPOPN 5
104930: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
104931: LD_VAR 0 1
104935: PPUSH
104936: LD_VAR 0 2
104940: PPUSH
104941: LD_VAR 0 3
104945: PPUSH
104946: LD_VAR 0 4
104950: PPUSH
104951: LD_VAR 0 5
104955: PPUSH
104956: LD_VAR 0 6
104960: PPUSH
104961: CALL 43419 0 6
// end ;
104965: PPOPN 6
104967: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
104968: LD_INT 0
104970: PPUSH
// begin if not units then
104971: LD_VAR 0 1
104975: NOT
104976: IFFALSE 104980
// exit ;
104978: GO 104980
// end ;
104980: PPOPN 7
104982: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
104983: CALL 43323 0 0
// end ;
104987: PPOPN 1
104989: END
