// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7695 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4864 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41681 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42132 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21435 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21371 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18364 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21271 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22285 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21512 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21305 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21338 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18143 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22193 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20450 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21025 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21025 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20822 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20486 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20662 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19946 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20560 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21061 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21801 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21371 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18364 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21271 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21512 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18143 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22193 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20450 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21025 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21025 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20822 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20486 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20662 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19946 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20560 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21061 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21801 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19946 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11651 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22019 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11651 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22019 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11651 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22019 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11651 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22019 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7914 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7914 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7914 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7914 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7914 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18364 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4861
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4859
// begin PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4785: LD_EXP 22
4789: PUSH
4790: LD_INT 1
4792: ARRAY
4793: PPUSH
4794: LD_INT 18
4796: PPUSH
4797: LD_INT 0
4799: PPUSH
4800: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4804: LD_EXP 22
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 107
4815: PPUSH
4816: LD_INT 88
4818: PPUSH
4819: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4823: LD_EXP 22
4827: PUSH
4828: LD_INT 1
4830: ARRAY
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4839: LD_ADDR_EXP 22
4843: PUSH
4844: LD_EXP 22
4848: PPUSH
4849: LD_INT 1
4851: PPUSH
4852: CALL_OW 3
4856: ST_TO_ADDR
// end ;
4857: GO 4782
4859: POP
4860: POP
// end ;
4861: PPOPN 1
4863: END
// export function Dialog ; var i ; begin
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
// if not isTest then
4868: LD_EXP 1
4872: NOT
4873: IFFALSE 4895
// case query ( task ) of 1 :
4875: LD_STRING task
4877: PPUSH
4878: CALL_OW 97
4882: PUSH
4883: LD_INT 1
4885: DOUBLE
4886: EQUAL
4887: IFTRUE 4891
4889: GO 4894
4891: POP
// ; end ;
4892: GO 4895
4894: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4895: LD_INT 105
4897: PPUSH
4898: LD_INT 84
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 30
4906: NEG
4907: PPUSH
4908: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4912: LD_INT 105
4914: PPUSH
4915: LD_INT 84
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: CALL_OW 331
// InGameOn ;
4925: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4929: LD_INT 128
4931: PPUSH
4932: LD_INT 64
4934: PPUSH
4935: CALL_OW 86
// if isTest then
4939: LD_EXP 1
4943: IFFALSE 4953
// dialogue_skipped := true ;
4945: LD_ADDR_OWVAR 59
4949: PUSH
4950: LD_INT 1
4952: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4965: LD_EXP 24
4969: PPUSH
4970: LD_STRING DR2
4972: PPUSH
4973: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4977: LD_EXP 24
4981: PPUSH
4982: LD_STRING DR3
4984: PPUSH
4985: CALL_OW 94
// InGameOff ;
4989: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4993: LD_STRING C1
4995: PPUSH
4996: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5000: LD_INT 35
5002: PPUSH
5003: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5007: LD_INT 9
5009: PPUSH
5010: LD_INT 22
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 70
5024: IFFALSE 5000
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 9
5033: PPUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 6
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 70
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5066
// SetSide ( i , 3 ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 3
5059: PPUSH
5060: CALL_OW 235
5064: GO 5049
5066: POP
5067: POP
// if not isTest then
5068: LD_EXP 1
5072: NOT
5073: IFFALSE 5095
// case query ( support ) of 1 :
5075: LD_STRING support
5077: PPUSH
5078: CALL_OW 97
5082: PUSH
5083: LD_INT 1
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5094
5091: POP
// ; end ;
5092: GO 5095
5094: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 12
5100: PPUSH
5101: LD_INT 2
5103: PPUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 0
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 468
// if player_com = stolypin then
5141: LD_EXP 23
5145: PUSH
5146: LD_EXP 21
5150: EQUAL
5151: IFFALSE 5180
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5153: LD_INT 18
5155: PPUSH
5156: LD_INT 3
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_OWVAR 67
5174: ARRAY
5175: PPUSH
5176: CALL 6592 0 2
// end ;
5180: LD_VAR 0 1
5184: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5185: LD_EXP 11
5189: PUSH
5190: LD_OWVAR 1
5194: PUSH
5195: LD_INT 31500
5197: LESS
5198: AND
5199: IFFALSE 5367
// case query ( call1 ) of 1 :
5201: LD_STRING call1
5203: PPUSH
5204: CALL_OW 97
5208: PUSH
5209: LD_INT 1
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5355
5217: POP
// begin callUsed := true ;
5218: LD_ADDR_EXP 3
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 12
5231: PPUSH
5232: LD_INT 1
5234: PPUSH
5235: LD_INT 1
5237: PPUSH
5238: CALL_OW 468
// call := false ;
5242: LD_ADDR_EXP 11
5246: PUSH
5247: LD_INT 0
5249: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5250: LD_EXP 24
5254: PPUSH
5255: LD_STRING DR6
5257: PPUSH
5258: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5262: LD_INT 6300
5264: PPUSH
5265: LD_INT 8400
5267: PPUSH
5268: CALL_OW 12
5272: PPUSH
5273: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5277: LD_INT 18
5279: PUSH
5280: LD_INT 19
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 1
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: CALL_OW 12
5297: ARRAY
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: PPUSH
5310: CALL 6592 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5314: LD_INT 25200
5316: PPUSH
5317: LD_INT 35700
5319: PPUSH
5320: CALL_OW 12
5324: PPUSH
5325: CALL_OW 67
// call := true ;
5329: LD_ADDR_EXP 11
5333: PUSH
5334: LD_INT 1
5336: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 12
5342: PPUSH
5343: LD_INT 2
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 468
// end ; 2 :
5353: GO 5367
5355: LD_INT 2
5357: DOUBLE
5358: EQUAL
5359: IFTRUE 5363
5361: GO 5366
5363: POP
// ; end ;
5364: GO 5367
5366: POP
// if call and tick >= 15 15$00 then
5367: LD_EXP 11
5371: PUSH
5372: LD_OWVAR 1
5376: PUSH
5377: LD_INT 31500
5379: GREATEREQUAL
5380: AND
5381: IFFALSE 5820
// case query ( call2 ) of 1 :
5383: LD_STRING call2
5385: PPUSH
5386: CALL_OW 97
5390: PUSH
5391: LD_INT 1
5393: DOUBLE
5394: EQUAL
5395: IFTRUE 5399
5397: GO 5641
5399: POP
// begin callUsed := true ;
5400: LD_ADDR_EXP 3
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// call := false ;
5408: LD_ADDR_EXP 11
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5416: LD_INT 1
5418: PPUSH
5419: LD_INT 21
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL 11651 0 2
5433: PUSH
5434: LD_INT 4
5436: PPUSH
5437: LD_INT 21
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PPUSH
5447: CALL 11651 0 2
5451: AND
5452: IFFALSE 5500
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5454: LD_INT 18
5456: PUSH
5457: LD_INT 19
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 1
5466: PPUSH
5467: LD_INT 2
5469: PPUSH
5470: CALL_OW 12
5474: ARRAY
5475: PPUSH
5476: LD_INT 5
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PPUSH
5496: CALL 6353 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5500: LD_INT 1
5502: PPUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PPUSH
5513: CALL 11651 0 2
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5550
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5523: LD_INT 19
5525: PPUSH
5526: LD_INT 5
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: CALL 6353 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5550: LD_INT 4
5552: PPUSH
5553: LD_INT 21
5555: PUSH
5556: LD_INT 3
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 11651 0 2
5567: PUSH
5568: LD_INT 0
5570: EQUAL
5571: IFFALSE 5600
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5573: LD_INT 18
5575: PPUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 4
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_OWVAR 67
5594: ARRAY
5595: PPUSH
5596: CALL 6353 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5600: LD_INT 10500
5602: PPUSH
5603: LD_INT 23100
5605: PPUSH
5606: CALL_OW 12
5610: PPUSH
5611: CALL_OW 67
// call := true ;
5615: LD_ADDR_EXP 11
5619: PUSH
5620: LD_INT 1
5622: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_INT 12
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: LD_INT 1
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5820
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5808
5649: POP
// begin callUsed := true ;
5650: LD_ADDR_EXP 3
5654: PUSH
5655: LD_INT 1
5657: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 1
5669: PPUSH
5670: CALL_OW 468
// call := false ;
5674: LD_ADDR_EXP 11
5678: PUSH
5679: LD_INT 0
5681: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5682: LD_EXP 24
5686: PPUSH
5687: LD_STRING DR6
5689: PPUSH
5690: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5694: LD_INT 6300
5696: PPUSH
5697: LD_INT 8400
5699: PPUSH
5700: CALL_OW 12
5704: PPUSH
5705: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5709: LD_INT 18
5711: PUSH
5712: LD_INT 19
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 1
5721: PPUSH
5722: LD_INT 2
5724: PPUSH
5725: CALL_OW 12
5729: ARRAY
5730: PPUSH
5731: LD_INT 3
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 2
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_OWVAR 67
5749: ARRAY
5750: PUSH
5751: LD_INT 0
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 12
5761: MINUS
5762: PPUSH
5763: CALL 6592 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5767: LD_INT 35700
5769: PPUSH
5770: LD_INT 44100
5772: PPUSH
5773: CALL_OW 12
5777: PPUSH
5778: CALL_OW 67
// call := true ;
5782: LD_ADDR_EXP 11
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 12
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 468
// end ; 3 :
5806: GO 5820
5808: LD_INT 3
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5819
5816: POP
// ; end ;
5817: GO 5820
5819: POP
// end ;
5820: PPOPN 4
5822: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_INT 0
5854: EQUAL
5855: PUSH
5856: LD_INT 22
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 21
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: AND
5889: IFFALSE 6193
5891: GO 5893
5893: DISABLE
// begin DialogueOn ;
5894: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5898: LD_EXP 24
5902: PPUSH
5903: LD_STRING DR7
5905: PPUSH
5906: CALL_OW 94
// case player_com of Gorki :
5910: LD_EXP 23
5914: PUSH
5915: LD_EXP 20
5919: DOUBLE
5920: EQUAL
5921: IFTRUE 5925
5923: GO 5935
5925: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5926: LD_STRING ACH_GORKI
5928: PPUSH
5929: CALL_OW 543
5933: GO 5996
5935: LD_EXP 21
5939: DOUBLE
5940: EQUAL
5941: IFTRUE 5945
5943: GO 5955
5945: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5946: LD_STRING ACH_STOLYP
5948: PPUSH
5949: CALL_OW 543
5953: GO 5996
5955: LD_EXP 19
5959: DOUBLE
5960: EQUAL
5961: IFTRUE 5965
5963: GO 5975
5965: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5966: LD_STRING ACH_DAVIDOV
5968: PPUSH
5969: CALL_OW 543
5973: GO 5996
5975: LD_EXP 18
5979: DOUBLE
5980: EQUAL
5981: IFTRUE 5985
5983: GO 5995
5985: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5986: LD_STRING ACH_GLADKOV
5988: PPUSH
5989: CALL_OW 543
5993: GO 5996
5995: POP
// if not callUsed then
5996: LD_EXP 3
6000: NOT
6001: IFFALSE 6010
// SetAchievement ( ACH_NOSUPP ) ;
6003: LD_STRING ACH_NOSUPP
6005: PPUSH
6006: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6010: LD_OWVAR 1
6014: PUSH
6015: LD_INT 116550
6017: PUSH
6018: LD_INT 95550
6020: PUSH
6021: LD_INT 89250
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_OWVAR 67
6033: ARRAY
6034: LESS
6035: IFFALSE 6049
// AddMedal ( med1 , 1 ) else
6037: LD_STRING med1
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med1 , - 1 ) ;
6049: LD_STRING med1
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6060: LD_INT 81
6062: PUSH
6063: LD_INT 3
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 21
6072: PUSH
6073: LD_INT 3
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PUSH
6089: LD_INT 0
6091: EQUAL
6092: IFFALSE 6106
// AddMedal ( med3 , 1 ) else
6094: LD_STRING med3
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 101
6104: GO 6117
// AddMedal ( med3 , - 1 ) ;
6106: LD_STRING med3
6108: PPUSH
6109: LD_INT 1
6111: NEG
6112: PPUSH
6113: CALL_OW 101
// if player_loss = 0 then
6117: LD_EXP 10
6121: PUSH
6122: LD_INT 0
6124: EQUAL
6125: IFFALSE 6139
// AddMedal ( med2 , 1 ) else
6127: LD_STRING med2
6129: PPUSH
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 101
6137: GO 6182
// if player_loss > 0 and player_loss < 3 then
6139: LD_EXP 10
6143: PUSH
6144: LD_INT 0
6146: GREATER
6147: PUSH
6148: LD_EXP 10
6152: PUSH
6153: LD_INT 3
6155: LESS
6156: AND
6157: IFFALSE 6171
// AddMedal ( med2 , 2 ) else
6159: LD_STRING med2
6161: PPUSH
6162: LD_INT 2
6164: PPUSH
6165: CALL_OW 101
6169: GO 6182
// AddMedal ( med2 , - 1 ) ;
6171: LD_STRING med2
6173: PPUSH
6174: LD_INT 1
6176: NEG
6177: PPUSH
6178: CALL_OW 101
// GiveMedals ( MAIN ) ;
6182: LD_STRING MAIN
6184: PPUSH
6185: CALL_OW 102
// YouWin ;
6189: CALL_OW 103
// end ;
6193: END
// every 0 0$01 trigger IsDead ( player_com ) do
6194: LD_EXP 23
6198: PPUSH
6199: CALL_OW 301
6203: IFFALSE 6270
6205: GO 6207
6207: DISABLE
// begin if IsLive ( Houten ) then
6208: LD_EXP 4
6212: PPUSH
6213: CALL_OW 300
6217: IFFALSE 6233
// SayRadio ( Houten , DJ5 ) else
6219: LD_EXP 4
6223: PPUSH
6224: LD_STRING DJ5
6226: PPUSH
6227: CALL_OW 94
6231: GO 6256
// if IsLive ( Brown ) then
6233: LD_EXP 5
6237: PPUSH
6238: CALL_OW 300
6242: IFFALSE 6256
// SayRadio ( Brown , DS5 ) ;
6244: LD_EXP 5
6248: PPUSH
6249: LD_STRING DS5
6251: PPUSH
6252: CALL_OW 94
// Wait ( 0 0$01 ) ;
6256: LD_INT 35
6258: PPUSH
6259: CALL_OW 67
// YouLost ( dead ) ;
6263: LD_STRING dead
6265: PPUSH
6266: CALL_OW 104
// end ;
6270: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 301
6278: PUSH
6279: LD_EXP 1
6283: NOT
6284: AND
6285: IFFALSE 6352
6287: GO 6289
6289: DISABLE
// begin if IsLive ( Brown ) then
6290: LD_EXP 5
6294: PPUSH
6295: CALL_OW 300
6299: IFFALSE 6315
// SayRadio ( Brown , DS5 ) else
6301: LD_EXP 5
6305: PPUSH
6306: LD_STRING DS5
6308: PPUSH
6309: CALL_OW 94
6313: GO 6338
// if IsLive ( Houten ) then
6315: LD_EXP 4
6319: PPUSH
6320: CALL_OW 300
6324: IFFALSE 6338
// SayRadio ( Houten , DJ5 ) ;
6326: LD_EXP 4
6330: PPUSH
6331: LD_STRING DJ5
6333: PPUSH
6334: CALL_OW 94
// Wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// YouLost ( depot ) ;
6345: LD_STRING depot
6347: PPUSH
6348: CALL_OW 104
// end ;
6352: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
// for i = 1 to n do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6577
// begin uc_side := 6 ;
6376: LD_ADDR_OWVAR 20
6380: PUSH
6381: LD_INT 6
6383: ST_TO_ADDR
// uc_nation := 3 ;
6384: LD_ADDR_OWVAR 21
6388: PUSH
6389: LD_INT 3
6391: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6392: LD_ADDR_OWVAR 37
6396: PUSH
6397: LD_INT 23
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: ST_TO_ADDR
// vc_control := control_computer ;
6419: LD_ADDR_OWVAR 38
6423: PUSH
6424: LD_INT 3
6426: ST_TO_ADDR
// vc_engine := engine_siberite ;
6427: LD_ADDR_OWVAR 39
6431: PUSH
6432: LD_INT 3
6434: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6435: LD_ADDR_OWVAR 40
6439: PUSH
6440: LD_INT 43
6442: PUSH
6443: LD_INT 44
6445: PUSH
6446: LD_INT 44
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: CALL_OW 12
6464: ARRAY
6465: ST_TO_ADDR
// un := CreateVehicle ;
6466: LD_ADDR_VAR 0 5
6470: PUSH
6471: CALL_OW 45
6475: ST_TO_ADDR
// case area of east_arr :
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 18
6483: DOUBLE
6484: EQUAL
6485: IFTRUE 6489
6487: GO 6524
6489: POP
// begin PlaceUnitArea ( un , area , false ) ;
6490: LD_VAR 0 5
6494: PPUSH
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_INT 0
6502: PPUSH
6503: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6507: LD_VAR 0 5
6511: PPUSH
6512: LD_INT 79
6514: PPUSH
6515: LD_INT 33
6517: PPUSH
6518: CALL_OW 111
// end ; south_arr :
6522: GO 6568
6524: LD_INT 19
6526: DOUBLE
6527: EQUAL
6528: IFTRUE 6532
6530: GO 6567
6532: POP
// begin PlaceUnitArea ( un , area , false ) ;
6533: LD_VAR 0 5
6537: PPUSH
6538: LD_VAR 0 1
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_INT 131
6557: PPUSH
6558: LD_INT 148
6560: PPUSH
6561: CALL_OW 111
// end ; end ;
6565: GO 6568
6567: POP
// Wait ( 0 0$02 ) ;
6568: LD_INT 70
6570: PPUSH
6571: CALL_OW 67
// end ;
6575: GO 6373
6577: POP
6578: POP
// pink_attack := true ;
6579: LD_ADDR_EXP 12
6583: PUSH
6584: LD_INT 1
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 3
6591: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// for i = 1 to n do
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: DOUBLE
6603: LD_INT 1
6605: DEC
6606: ST_TO_ADDR
6607: LD_VAR 0 2
6611: PUSH
6612: FOR_TO
6613: IFFALSE 6839
// begin uc_side := 6 ;
6615: LD_ADDR_OWVAR 20
6619: PUSH
6620: LD_INT 6
6622: ST_TO_ADDR
// uc_nation := 3 ;
6623: LD_ADDR_OWVAR 21
6627: PUSH
6628: LD_INT 3
6630: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6631: LD_INT 0
6633: PPUSH
6634: LD_INT 3
6636: PPUSH
6637: LD_INT 4
6639: PPUSH
6640: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6644: LD_ADDR_OWVAR 37
6648: PUSH
6649: LD_INT 22
6651: ST_TO_ADDR
// vc_control := control_manual ;
6652: LD_ADDR_OWVAR 38
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// vc_engine := engine_combustion ;
6660: LD_ADDR_OWVAR 39
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6668: LD_ADDR_OWVAR 40
6672: PUSH
6673: LD_INT 51
6675: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6676: LD_ADDR_OWVAR 41
6680: PUSH
6681: LD_INT 50
6683: ST_TO_ADDR
// un := CreateVehicle ;
6684: LD_ADDR_VAR 0 5
6688: PUSH
6689: CALL_OW 45
6693: ST_TO_ADDR
// case area of east_arr :
6694: LD_VAR 0 1
6698: PUSH
6699: LD_INT 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6722
6707: POP
// SetDir ( un , 4 ) ; south_arr :
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: CALL_OW 233
6720: GO 6746
6722: LD_INT 19
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6745
6730: POP
// SetDir ( un , 5 ) ; end ;
6731: LD_VAR 0 5
6735: PPUSH
6736: LD_INT 5
6738: PPUSH
6739: CALL_OW 233
6743: GO 6746
6745: POP
// PlaceUnitArea ( un , area , false ) ;
6746: LD_VAR 0 5
6750: PPUSH
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6763: CALL_OW 44
6767: PPUSH
6768: LD_VAR 0 5
6772: PPUSH
6773: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6777: LD_VAR 0 5
6781: PPUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 100
6787: PPUSH
6788: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6792: LD_VAR 0 5
6796: PPUSH
6797: LD_INT 106
6799: PPUSH
6800: LD_INT 88
6802: PPUSH
6803: CALL_OW 111
// AddComUnload ( un ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 173
// Wait ( 0 0$02 ) ;
6830: LD_INT 70
6832: PPUSH
6833: CALL_OW 67
// end ;
6837: GO 6612
6839: POP
6840: POP
// Wait ( 0 0$05 ) ;
6841: LD_INT 175
6843: PPUSH
6844: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6848: LD_INT 6
6850: PPUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 51
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL 11651 0 2
6865: IFFALSE 7053
// begin wait ( 0 0$01 ) ;
6867: LD_INT 35
6869: PPUSH
6870: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6874: LD_ADDR_VAR 0 4
6878: PUSH
6879: LD_INT 6
6881: PPUSH
6882: LD_INT 34
6884: PUSH
6885: LD_INT 51
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL 11651 0 2
6896: PUSH
6897: FOR_IN
6898: IFFALSE 7049
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6900: LD_VAR 0 4
6904: PPUSH
6905: LD_INT 9
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 4
6917: PPUSH
6918: CALL 31773 0 1
6922: PPUSH
6923: CALL_OW 258
6927: PUSH
6928: LD_INT 1
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 9
6937: AND
6938: IFFALSE 6965
// begin Say ( GetDriver ( i ) , Dtran ) ;
6940: LD_VAR 0 4
6944: PPUSH
6945: CALL 31773 0 1
6949: PPUSH
6950: LD_STRING Dtran
6952: PPUSH
6953: CALL_OW 88
// dialog_trans := false ;
6957: LD_ADDR_EXP 9
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6965: LD_VAR 0 4
6969: PPUSH
6970: CALL_OW 316
6974: IFFALSE 6990
// ComMoveToArea ( i , area ) ;
6976: LD_VAR 0 4
6980: PPUSH
6981: LD_VAR 0 1
6985: PPUSH
6986: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6990: LD_VAR 0 4
6994: PPUSH
6995: LD_VAR 0 1
6999: PPUSH
7000: CALL_OW 308
7004: PUSH
7005: LD_VAR 0 4
7009: PPUSH
7010: LD_INT 1
7012: PPUSH
7013: CALL_OW 289
7017: PUSH
7018: LD_INT 0
7020: EQUAL
7021: AND
7022: IFFALSE 7047
// begin RemoveUnit ( GetDriver ( i ) ) ;
7024: LD_VAR 0 4
7028: PPUSH
7029: CALL 31773 0 1
7033: PPUSH
7034: CALL_OW 64
// RemoveUnit ( i ) ;
7038: LD_VAR 0 4
7042: PPUSH
7043: CALL_OW 64
// end ; end ;
7047: GO 6897
7049: POP
7050: POP
// end ;
7051: GO 6848
// end ;
7053: LD_VAR 0 3
7057: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7058: LD_INT 0
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
// if isTest then
7064: LD_EXP 1
7068: IFFALSE 7072
// exit ;
7070: GO 7517
// for i = 1 to n do
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: DOUBLE
7078: LD_INT 1
7080: DEC
7081: ST_TO_ADDR
7082: LD_VAR 0 2
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7376
// begin uc_side := 8 ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_INT 8
7097: ST_TO_ADDR
// uc_nation := 1 ;
7098: LD_ADDR_OWVAR 21
7102: PUSH
7103: LD_INT 1
7105: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7106: LD_ADDR_VAR 0 6
7110: PUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: LD_INT 4
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 1
7127: PPUSH
7128: LD_OWVAR 67
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// vc_chassis := ch ;
7139: LD_ADDR_OWVAR 37
7143: PUSH
7144: LD_VAR 0 6
7148: ST_TO_ADDR
// vc_control := control_computer ;
7149: LD_ADDR_OWVAR 38
7153: PUSH
7154: LD_INT 3
7156: ST_TO_ADDR
// vc_engine := engine_combustion ;
7157: LD_ADDR_OWVAR 39
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7165: LD_OWVAR 1
7169: PUSH
7170: LD_INT 42000
7172: PUSH
7173: LD_INT 33600
7175: PUSH
7176: LD_INT 29400
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_OWVAR 67
7188: ARRAY
7189: LESS
7190: IFFALSE 7221
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7192: LD_ADDR_OWVAR 40
7196: PUSH
7197: LD_INT 3
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 1
7209: PPUSH
7210: LD_INT 2
7212: PPUSH
7213: CALL_OW 12
7217: ARRAY
7218: ST_TO_ADDR
7219: GO 7317
// if ch = us_medium_tracked then
7221: LD_VAR 0 6
7225: PUSH
7226: LD_INT 3
7228: EQUAL
7229: IFFALSE 7276
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7231: LD_ADDR_OWVAR 40
7235: PUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 4
7241: PUSH
7242: LD_INT 5
7244: PUSH
7245: LD_INT 7
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_OWVAR 67
7258: PPUSH
7259: LD_OWVAR 67
7263: PUSH
7264: LD_INT 1
7266: PLUS
7267: PPUSH
7268: CALL_OW 12
7272: ARRAY
7273: ST_TO_ADDR
7274: GO 7317
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7276: LD_ADDR_OWVAR 40
7280: PUSH
7281: LD_INT 5
7283: PUSH
7284: LD_INT 6
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 7
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_OWVAR 67
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PPUSH
7311: CALL_OW 12
7315: ARRAY
7316: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7317: LD_ADDR_OWVAR 41
7321: PUSH
7322: LD_INT 70
7324: ST_TO_ADDR
// un := CreateVehicle ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: CALL_OW 45
7334: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7335: LD_VAR 0 5
7339: PPUSH
7340: LD_VAR 0 1
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7352: LD_VAR 0 5
7356: PPUSH
7357: LD_INT 65
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL_OW 111
// Wait ( 0 0$02 ) ;
7367: LD_INT 70
7369: PPUSH
7370: CALL_OW 67
// end ;
7374: GO 7087
7376: POP
7377: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7378: LD_INT 90
7380: PUSH
7381: LD_INT 80
7383: PUSH
7384: LD_INT 70
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: PUSH
7392: LD_OWVAR 67
7396: ARRAY
7397: PPUSH
7398: CALL_OW 13
7402: IFFALSE 7509
// begin uc_side := 8 ;
7404: LD_ADDR_OWVAR 20
7408: PUSH
7409: LD_INT 8
7411: ST_TO_ADDR
// uc_nation := 1 ;
7412: LD_ADDR_OWVAR 21
7416: PUSH
7417: LD_INT 1
7419: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7420: LD_ADDR_OWVAR 37
7424: PUSH
7425: LD_INT 4
7427: ST_TO_ADDR
// vc_control := control_computer ;
7428: LD_ADDR_OWVAR 38
7432: PUSH
7433: LD_INT 3
7435: ST_TO_ADDR
// vc_engine := engine_combustion ;
7436: LD_ADDR_OWVAR 39
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7444: LD_ADDR_OWVAR 40
7448: PUSH
7449: LD_INT 14
7451: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7452: LD_ADDR_OWVAR 41
7456: PUSH
7457: LD_INT 70
7459: ST_TO_ADDR
// un := CreateVehicle ;
7460: LD_ADDR_VAR 0 5
7464: PUSH
7465: CALL_OW 45
7469: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7470: LD_VAR 0 5
7474: PPUSH
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7487: LD_VAR 0 5
7491: PPUSH
7492: LD_INT 65
7494: PPUSH
7495: LD_INT 9
7497: PPUSH
7498: CALL_OW 111
// Wait ( 0 0$02 ) ;
7502: LD_INT 70
7504: PPUSH
7505: CALL_OW 67
// end ; alfa_support := true ;
7509: LD_ADDR_EXP 13
7513: PUSH
7514: LD_INT 1
7516: ST_TO_ADDR
// end ;
7517: LD_VAR 0 3
7521: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7522: LD_OWVAR 1
7526: PUSH
7527: LD_INT 25200
7529: PUSH
7530: LD_INT 23100
7532: PUSH
7533: LD_INT 21000
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_OWVAR 67
7545: ARRAY
7546: GREATER
7547: IFFALSE 7692
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 3
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: LD_INT 5
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7580: LD_INT 1050
7582: PPUSH
7583: LD_INT 4200
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7595: LD_INT 20
7597: PPUSH
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL 7058 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7607: LD_INT 22
7609: PUSH
7610: LD_INT 8
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: IFFALSE 7635
// SayRadio ( Popov , DR5 ) ;
7623: LD_EXP 24
7627: PPUSH
7628: LD_STRING DR5
7630: PPUSH
7631: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7635: LD_INT 8400
7637: PPUSH
7638: LD_INT 12600
7640: PPUSH
7641: CALL_OW 12
7645: PPUSH
7646: CALL_OW 67
// n := n + 1 ;
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 1
7659: PUSH
7660: LD_INT 1
7662: PLUS
7663: ST_TO_ADDR
// if n > 9 then
7664: LD_VAR 0 1
7668: PUSH
7669: LD_INT 9
7671: GREATER
7672: IFFALSE 7682
// n := 9 ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 9
7681: ST_TO_ADDR
// until tick >= 120 120$00 ;
7682: LD_OWVAR 1
7686: PUSH
7687: LD_INT 252000
7689: GREATEREQUAL
7690: IFFALSE 7580
// end ; end_of_file
7692: PPOPN 1
7694: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7695: LD_INT 0
7697: PPUSH
// enable_addtolog := isTest ;
7698: LD_ADDR_OWVAR 81
7702: PUSH
7703: LD_EXP 1
7707: ST_TO_ADDR
// lines_break_limit := 5 ;
7708: LD_ADDR_EXP 26
7712: PUSH
7713: LD_INT 5
7715: ST_TO_ADDR
// lines_break_type := --- ;
7716: LD_ADDR_EXP 27
7720: PUSH
7721: LD_STRING ---
7723: ST_TO_ADDR
// lines_counter := 0 ;
7724: LD_ADDR_EXP 25
7728: PUSH
7729: LD_INT 0
7731: ST_TO_ADDR
// show_line_index := true ;
7732: LD_ADDR_EXP 28
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// tick_log := true ;
7740: LD_ADDR_EXP 29
7744: PUSH
7745: LD_INT 1
7747: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7748: LD_STRING ----------SAND OF SIBERIA LOG----------
7750: PPUSH
7751: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7755: LD_STRING Map Name: 
7757: PUSH
7758: LD_OWVAR 68
7762: STR
7763: PPUSH
7764: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7768: LD_STRING Map Number: 
7770: PUSH
7771: LD_OWVAR 70
7775: STR
7776: PPUSH
7777: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7781: LD_STRING Difficulty: 
7783: PUSH
7784: LD_OWVAR 67
7788: STR
7789: PPUSH
7790: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7794: LD_STRING ---------------------------------------
7796: PPUSH
7797: CALL_OW 561
// end ;
7801: LD_VAR 0 1
7805: RET
// function Log ( text ) ; begin
7806: LD_INT 0
7808: PPUSH
// if show_line_index then
7809: LD_EXP 28
7813: IFFALSE 7825
// result := lines_counter ;
7815: LD_ADDR_VAR 0 2
7819: PUSH
7820: LD_EXP 25
7824: ST_TO_ADDR
// if tick_log then
7825: LD_EXP 29
7829: IFFALSE 7855
// result := result &  T:  & tick &   ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_VAR 0 2
7840: PUSH
7841: LD_STRING  T: 
7843: STR
7844: PUSH
7845: LD_OWVAR 1
7849: STR
7850: PUSH
7851: LD_STRING  
7853: STR
7854: ST_TO_ADDR
// AddToLog ( result & text ) ;
7855: LD_VAR 0 2
7859: PUSH
7860: LD_VAR 0 1
7864: STR
7865: PPUSH
7866: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7870: LD_ADDR_EXP 25
7874: PUSH
7875: LD_EXP 25
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7884: LD_EXP 25
7888: PUSH
7889: LD_EXP 26
7893: MOD
7894: PUSH
7895: LD_INT 0
7897: EQUAL
7898: IFFALSE 7909
// AddToLog ( lines_break_type ) ;
7900: LD_EXP 27
7904: PPUSH
7905: CALL_OW 561
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogHuman ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7917: LD_STRING Human Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; class: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 257
7954: STR
7955: PUSH
7956: LD_STRING ; 
7958: STR
7959: PPUSH
7960: CALL 7806 0 1
// end ;
7964: LD_VAR 0 2
7968: RET
// export function LogVeh ( id ) ; begin
7969: LD_INT 0
7971: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7972: LD_STRING Vehicle Created. id: 
7974: PUSH
7975: LD_VAR 0 1
7979: STR
7980: PUSH
7981: LD_STRING ; side: 
7983: STR
7984: PUSH
7985: LD_VAR 0 1
7989: PPUSH
7990: CALL_OW 255
7994: STR
7995: PUSH
7996: LD_STRING ; nation: 
7998: STR
7999: PUSH
8000: LD_VAR 0 1
8004: PPUSH
8005: CALL_OW 248
8009: STR
8010: PUSH
8011: LD_STRING ; weapon: 
8013: STR
8014: PUSH
8015: LD_VAR 0 1
8019: PPUSH
8020: CALL_OW 264
8024: STR
8025: PUSH
8026: LD_STRING ; 
8028: STR
8029: PPUSH
8030: CALL 7806 0 1
// end ;
8034: LD_VAR 0 2
8038: RET
// export function LogEvent ( event ) ; begin
8039: LD_INT 0
8041: PPUSH
// Log ( Event Executed. id:  & event ) ;
8042: LD_STRING Event Executed. id: 
8044: PUSH
8045: LD_VAR 0 1
8049: STR
8050: PPUSH
8051: CALL 7806 0 1
// end ; end_of_file
8055: LD_VAR 0 2
8059: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
8068: PPUSH
8069: PPUSH
// if unit then
8070: LD_VAR 0 1
8074: IFFALSE 8474
// begin if mode = 0 then
8076: LD_VAR 0 3
8080: PUSH
8081: LD_INT 0
8083: EQUAL
8084: IFFALSE 8232
// begin if coords then
8086: LD_VAR 0 2
8090: IFFALSE 8230
// while ( coords > 1 ) do
8092: LD_VAR 0 2
8096: PUSH
8097: LD_INT 1
8099: GREATER
8100: IFFALSE 8230
// if not HasTask ( unit ) then
8102: LD_VAR 0 1
8106: PPUSH
8107: CALL_OW 314
8111: NOT
8112: IFFALSE 8228
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_VAR 0 2
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PPUSH
8137: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 250
8157: PUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: EQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 251
8177: PUSH
8178: LD_VAR 0 2
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: EQUAL
8187: AND
8188: IFFALSE 8141
// for i = 1 to 2 do
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_INT 2
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8226
// coords := Delete ( coords , 1 ) ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_VAR 0 2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 3
8223: ST_TO_ADDR
8224: GO 8203
8226: POP
8227: POP
// end ;
8228: GO 8092
// end else
8230: GO 8474
// begin if coords then
8232: LD_VAR 0 2
8236: IFFALSE 8474
// begin x := GetX ( unit ) ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 250
8252: ST_TO_ADDR
// y := GetY ( unit ) ;
8253: LD_ADDR_VAR 0 7
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 251
8267: ST_TO_ADDR
// while ( coords > 1 ) do
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8474
// begin Wait ( 0 0$0.3 ) ;
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 250
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 251
8314: PPUSH
8315: LD_INT 14
8317: PPUSH
8318: CALL 22821 0 4
8322: IFFALSE 8353
// begin ComMoveXY ( unit , x , y ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: LD_VAR 0 6
8333: PPUSH
8334: LD_VAR 0 7
8338: PPUSH
8339: CALL_OW 111
// result := false ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_INT 0
8350: ST_TO_ADDR
// end else
8351: GO 8392
// if not HasTask ( unit ) then
8353: LD_VAR 0 1
8357: PPUSH
8358: CALL_OW 314
8362: NOT
8363: IFFALSE 8392
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8365: LD_VAR 0 1
8369: PPUSH
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 1
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 2
8386: ARRAY
8387: PPUSH
8388: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8392: LD_VAR 0 1
8396: PPUSH
8397: CALL_OW 250
8401: PUSH
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: EQUAL
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 251
8421: PUSH
8422: LD_VAR 0 2
8426: PUSH
8427: LD_INT 2
8429: ARRAY
8430: EQUAL
8431: AND
8432: IFFALSE 8472
// for i = 1 to 2 do
8434: LD_ADDR_VAR 0 5
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_INT 2
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8470
// coords := Delete ( coords , 1 ) ;
8450: LD_ADDR_VAR 0 2
8454: PUSH
8455: LD_VAR 0 2
8459: PPUSH
8460: LD_INT 1
8462: PPUSH
8463: CALL_OW 3
8467: ST_TO_ADDR
8468: GO 8447
8470: POP
8471: POP
// end ;
8472: GO 8268
// end ; end ; end ; result := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// end ;
8482: LD_VAR 0 4
8486: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
// if not units then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8564
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8501: LD_ADDR_VAR 0 5
8505: PUSH
8506: LD_INT 81
8508: PUSH
8509: LD_VAR 0 1
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// for i in units do
8523: LD_ADDR_VAR 0 4
8527: PUSH
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_IN
8534: IFFALSE 8562
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8536: LD_VAR 0 4
8540: PPUSH
8541: LD_VAR 0 5
8545: PPUSH
8546: LD_VAR 0 4
8550: PPUSH
8551: CALL_OW 74
8555: PPUSH
8556: CALL_OW 115
// end ;
8560: GO 8533
8562: POP
8563: POP
// end ;
8564: LD_VAR 0 3
8568: RET
// export function MC_Show ( string ) ; begin
8569: LD_INT 0
8571: PPUSH
// display_strings := string ;
8572: LD_ADDR_OWVAR 47
8576: PUSH
8577: LD_VAR 0 1
8581: ST_TO_ADDR
// end ; end_of_file
8582: LD_VAR 0 2
8586: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8587: LD_INT 0
8589: PPUSH
8590: PPUSH
8591: PPUSH
8592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8593: LD_ADDR_VAR 0 8
8597: PUSH
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 2
8605: PPUSH
8606: EMPTY
8607: PPUSH
8608: CALL 11734 0 3
8612: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8613: LD_VAR 0 8
8617: PUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 428
8632: PUSH
8633: LD_INT 0
8635: EQUAL
8636: AND
8637: IFFALSE 8711
// for i = 1 to plist do
8639: LD_ADDR_VAR 0 6
8643: PUSH
8644: DOUBLE
8645: LD_INT 1
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 8
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8709
// if NotTask ( plist [ i ] ) then
8657: LD_VAR 0 8
8661: PUSH
8662: LD_VAR 0 6
8666: ARRAY
8667: PPUSH
8668: CALL 32236 0 1
8672: IFFALSE 8707
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8674: LD_VAR 0 8
8678: PUSH
8679: LD_VAR 0 6
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: LD_VAR 0 3
8697: PPUSH
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 145
// end ;
8707: GO 8654
8709: POP
8710: POP
// end ;
8711: LD_VAR 0 5
8715: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8716: LD_INT 0
8718: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8719: LD_VAR 0 1
8723: PPUSH
8724: LD_INT 6
8726: PPUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: LD_VAR 0 4
8741: PPUSH
8742: CALL 10220 0 5
// end ;
8746: LD_VAR 0 5
8750: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8751: LD_INT 0
8753: PPUSH
8754: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8755: LD_ADDR_VAR 0 4
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_VAR 0 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 0
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 1
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: PPUSH
8807: CALL_OW 69
8811: PPUSH
8812: LD_VAR 0 2
8816: PPUSH
8817: CALL_OW 250
8821: PPUSH
8822: LD_VAR 0 2
8826: PPUSH
8827: CALL_OW 251
8831: PPUSH
8832: CALL_OW 73
8836: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8837: LD_VAR 0 4
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: CALL 10509 0 2
8851: IFFALSE 8910
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8853: LD_VAR 0 1
8857: PPUSH
8858: LD_INT 30
8860: PUSH
8861: LD_VAR 0 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: PPUSH
8870: CALL 11651 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8883: LD_ADDR_EXP 48
8887: PUSH
8888: LD_EXP 48
8892: PPUSH
8893: LD_VAR 0 1
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: EMPTY
8904: PPUSH
8905: CALL 42051 0 4
8909: ST_TO_ADDR
// end ; end ;
8910: LD_VAR 0 3
8914: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// result := false ;
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: LD_INT 0
8930: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8931: LD_VAR 0 1
8935: PPUSH
8936: LD_EXP 40
8940: PPUSH
8941: CALL 42999 0 2
8945: IFFALSE 9158
// for i = 1 to MREG_LabList do
8947: LD_ADDR_VAR 0 5
8951: PUSH
8952: DOUBLE
8953: LD_INT 1
8955: DEC
8956: ST_TO_ADDR
8957: LD_EXP 40
8961: PUSH
8962: FOR_TO
8963: IFFALSE 9156
// begin if MREG_LabList [ i ] [ 1 ] = side then
8965: LD_EXP 40
8969: PUSH
8970: LD_VAR 0 5
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PUSH
8980: LD_VAR 0 1
8984: EQUAL
8985: IFFALSE 9154
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8987: LD_ADDR_VAR 0 7
8991: PUSH
8992: LD_EXP 40
8996: PUSH
8997: LD_VAR 0 5
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9007: LD_ADDR_VAR 0 9
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_VAR 0 1
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 0
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 30
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PUSH
9056: EMPTY
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PPUSH
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 250
9073: PPUSH
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 251
9083: PPUSH
9084: CALL_OW 73
9088: ST_TO_ADDR
// if dep then
9089: LD_VAR 0 9
9093: IFFALSE 9152
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9095: LD_VAR 0 9
9099: PPUSH
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 3
9109: PPUSH
9110: CALL 10625 0 3
9114: IFFALSE 9152
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9116: LD_VAR 0 7
9120: PPUSH
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9130: LD_VAR 0 7
9134: PPUSH
9135: LD_VAR 0 3
9139: PPUSH
9140: CALL_OW 207
// result := true ;
9144: LD_ADDR_VAR 0 4
9148: PUSH
9149: LD_INT 1
9151: ST_TO_ADDR
// end ; end ; break ;
9152: GO 9156
// end ; end ;
9154: GO 8962
9156: POP
9157: POP
// end ;
9158: LD_VAR 0 4
9162: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9168: LD_ADDR_VAR 0 7
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: LD_VAR 0 3
9182: PPUSH
9183: LD_VAR 0 4
9187: PPUSH
9188: CALL 9350 0 3
9192: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9193: LD_ADDR_EXP 46
9197: PUSH
9198: LD_EXP 46
9202: PPUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: LD_VAR 0 2
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 4
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41960 0 4
9235: ST_TO_ADDR
// if ext_list then
9236: LD_VAR 0 5
9240: IFFALSE 9345
// for i = 1 to ext_list do
9242: LD_ADDR_VAR 0 8
9246: PUSH
9247: DOUBLE
9248: LD_INT 1
9250: DEC
9251: ST_TO_ADDR
9252: LD_VAR 0 5
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9343
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9260: LD_ADDR_EXP 46
9264: PUSH
9265: LD_EXP 46
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_VAR 0 5
9279: PUSH
9280: LD_VAR 0 8
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 7
9290: PUSH
9291: LD_VAR 0 8
9295: ARRAY
9296: PUSH
9297: LD_INT 1
9299: ARRAY
9300: PUSH
9301: LD_VAR 0 7
9305: PUSH
9306: LD_VAR 0 8
9310: ARRAY
9311: PUSH
9312: LD_INT 2
9314: ARRAY
9315: PUSH
9316: LD_VAR 0 7
9320: PUSH
9321: LD_VAR 0 8
9325: ARRAY
9326: PUSH
9327: LD_INT 3
9329: ARRAY
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL 41960 0 4
9340: ST_TO_ADDR
9341: GO 9257
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 6
9349: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9350: LD_INT 0
9352: PPUSH
9353: PPUSH
// list := [ ] ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: EMPTY
9360: ST_TO_ADDR
// case d of 0 :
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 0
9368: DOUBLE
9369: EQUAL
9370: IFTRUE 9374
9372: GO 9507
9374: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 4
9387: MINUS
9388: PUSH
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 4
9396: MINUS
9397: PUSH
9398: LD_INT 2
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 3
9413: MINUS
9414: PUSH
9415: LD_VAR 0 2
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 4
9435: PLUS
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 4
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 3
9457: PLUS
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: PLUS
9467: PUSH
9468: LD_INT 5
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: ST_TO_ADDR
// end ; 1 :
9505: GO 10205
9507: LD_INT 1
9509: DOUBLE
9510: EQUAL
9511: IFTRUE 9515
9513: GO 9648
9515: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9516: LD_ADDR_VAR 0 5
9520: PUSH
9521: LD_VAR 0 1
9525: PUSH
9526: LD_VAR 0 2
9530: PUSH
9531: LD_INT 4
9533: MINUS
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: PUSH
9543: LD_VAR 0 1
9547: PUSH
9548: LD_INT 3
9550: MINUS
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: LD_INT 3
9559: MINUS
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 4
9576: MINUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 1
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 4
9629: PLUS
9630: PUSH
9631: LD_INT 5
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: ST_TO_ADDR
// end ; 2 :
9646: GO 10205
9648: LD_INT 2
9650: DOUBLE
9651: EQUAL
9652: IFTRUE 9656
9654: GO 9785
9656: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: MINUS
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: PUSH
9684: LD_VAR 0 1
9688: PUSH
9689: LD_INT 4
9691: PLUS
9692: PUSH
9693: LD_VAR 0 2
9697: PUSH
9698: LD_INT 4
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 4
9718: PLUS
9719: PUSH
9720: LD_INT 0
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_VAR 0 1
9732: PUSH
9733: LD_INT 3
9735: MINUS
9736: PUSH
9737: LD_VAR 0 2
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 4
9757: MINUS
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: LD_INT 4
9766: MINUS
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: ST_TO_ADDR
// end ; 3 :
9783: GO 10205
9785: LD_INT 3
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9926
9793: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9794: LD_ADDR_VAR 0 5
9798: PUSH
9799: LD_VAR 0 1
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: LD_INT 4
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: PUSH
9821: LD_VAR 0 1
9825: PUSH
9826: LD_INT 4
9828: PLUS
9829: PUSH
9830: LD_VAR 0 2
9834: PUSH
9835: LD_INT 4
9837: PLUS
9838: PUSH
9839: LD_INT 5
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_INT 4
9854: MINUS
9855: PUSH
9856: LD_VAR 0 2
9860: PUSH
9861: LD_INT 1
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: LD_INT 4
9881: MINUS
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: MINUS
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 3
9907: MINUS
9908: PUSH
9909: LD_INT 2
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
// end ; 4 :
9924: GO 10205
9926: LD_INT 4
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10067
9934: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9935: LD_ADDR_VAR 0 5
9939: PUSH
9940: LD_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 4
9952: PLUS
9953: PUSH
9954: LD_INT 0
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: PUSH
9962: LD_VAR 0 1
9966: PUSH
9967: LD_INT 3
9969: PLUS
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 3
9978: PLUS
9979: PUSH
9980: LD_INT 5
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_INT 3
9995: PLUS
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: LD_INT 4
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 3
10022: MINUS
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_VAR 0 1
10036: PUSH
10037: LD_INT 4
10039: MINUS
10040: PUSH
10041: LD_VAR 0 2
10045: PUSH
10046: LD_INT 4
10048: MINUS
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: ST_TO_ADDR
// end ; 5 :
10065: GO 10205
10067: LD_INT 5
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10204
10075: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10076: LD_ADDR_VAR 0 5
10080: PUSH
10081: LD_VAR 0 1
10085: PUSH
10086: LD_INT 4
10088: MINUS
10089: PUSH
10090: LD_VAR 0 2
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_VAR 0 1
10107: PUSH
10108: LD_VAR 0 2
10112: PUSH
10113: LD_INT 4
10115: MINUS
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_VAR 0 1
10129: PUSH
10130: LD_INT 4
10132: PLUS
10133: PUSH
10134: LD_VAR 0 2
10138: PUSH
10139: LD_INT 4
10141: PLUS
10142: PUSH
10143: LD_INT 5
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: PUSH
10151: LD_VAR 0 1
10155: PUSH
10156: LD_INT 3
10158: PLUS
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_INT 4
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 1
10177: PUSH
10178: LD_VAR 0 2
10182: PUSH
10183: LD_INT 3
10185: PLUS
10186: PUSH
10187: LD_INT 0
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: ST_TO_ADDR
// end ; end ;
10202: GO 10205
10204: POP
// result := list ;
10205: LD_ADDR_VAR 0 4
10209: PUSH
10210: LD_VAR 0 5
10214: ST_TO_ADDR
// end ;
10215: LD_VAR 0 4
10219: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10227: LD_ADDR_VAR 0 10
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: LD_INT 2
10239: PPUSH
10240: EMPTY
10241: PPUSH
10242: CALL 11734 0 3
10246: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10247: LD_ADDR_VAR 0 9
10251: PUSH
10252: LD_INT 22
10254: PUSH
10255: LD_VAR 0 1
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_INT 30
10269: PUSH
10270: LD_INT 0
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 30
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PPUSH
10304: LD_VAR 0 3
10308: PPUSH
10309: LD_VAR 0 4
10313: PPUSH
10314: CALL_OW 73
10318: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10319: LD_ADDR_VAR 0 8
10323: PUSH
10324: LD_VAR 0 9
10328: PPUSH
10329: LD_VAR 0 2
10333: PPUSH
10334: CALL 10509 0 2
10338: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10339: LD_VAR 0 10
10343: PUSH
10344: LD_VAR 0 8
10348: AND
10349: PUSH
10350: LD_VAR 0 9
10354: PPUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_VAR 0 4
10364: PPUSH
10365: CALL_OW 297
10369: PUSH
10370: LD_INT 26
10372: LESSEQUAL
10373: AND
10374: PUSH
10375: LD_VAR 0 3
10379: PPUSH
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 428
10389: PUSH
10390: LD_INT 0
10392: EQUAL
10393: AND
10394: IFFALSE 10504
// for i = 1 to plist do
10396: LD_ADDR_VAR 0 7
10400: PUSH
10401: DOUBLE
10402: LD_INT 1
10404: DEC
10405: ST_TO_ADDR
10406: LD_VAR 0 10
10410: PUSH
10411: FOR_TO
10412: IFFALSE 10502
// if IsInUnit ( plist [ i ] ) then
10414: LD_VAR 0 10
10418: PUSH
10419: LD_VAR 0 7
10423: ARRAY
10424: PPUSH
10425: CALL_OW 310
10429: IFFALSE 10448
// ComExitBuilding ( plist [ i ] ) else
10431: LD_VAR 0 10
10435: PUSH
10436: LD_VAR 0 7
10440: ARRAY
10441: PPUSH
10442: CALL_OW 122
10446: GO 10500
// if NotTask ( plist [ i ] ) then
10448: LD_VAR 0 10
10452: PUSH
10453: LD_VAR 0 7
10457: ARRAY
10458: PPUSH
10459: CALL 32236 0 1
10463: IFFALSE 10500
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10465: LD_VAR 0 10
10469: PUSH
10470: LD_VAR 0 7
10474: ARRAY
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL_OW 145
// end ;
10500: GO 10411
10502: POP
10503: POP
// end ;
10504: LD_VAR 0 6
10508: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10509: LD_INT 0
10511: PPUSH
10512: PPUSH
10513: PPUSH
// pom := GetBase ( bdepot ) ;
10514: LD_ADDR_VAR 0 4
10518: PUSH
10519: LD_VAR 0 1
10523: PPUSH
10524: CALL_OW 274
10528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10529: LD_ADDR_VAR 0 5
10533: PUSH
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 248
10548: PPUSH
10549: CALL_OW 450
10553: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: CALL_OW 275
10566: PUSH
10567: LD_VAR 0 5
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: GREATEREQUAL
10576: PUSH
10577: LD_VAR 0 4
10581: PPUSH
10582: LD_INT 3
10584: PPUSH
10585: CALL_OW 275
10589: PUSH
10590: LD_VAR 0 5
10594: PUSH
10595: LD_INT 3
10597: ARRAY
10598: GREATEREQUAL
10599: AND
10600: IFFALSE 10612
// result := true else
10602: LD_ADDR_VAR 0 3
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
10610: GO 10620
// result := false ;
10612: LD_ADDR_VAR 0 3
10616: PUSH
10617: LD_INT 0
10619: ST_TO_ADDR
// end ;
10620: LD_VAR 0 3
10624: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
10629: PPUSH
10630: PPUSH
10631: PPUSH
// pom := GetBase ( bdepot ) ;
10632: LD_ADDR_VAR 0 5
10636: PUSH
10637: LD_VAR 0 1
10641: PPUSH
10642: CALL_OW 274
10646: ST_TO_ADDR
// cost := [ ] ;
10647: LD_ADDR_VAR 0 8
10651: PUSH
10652: EMPTY
10653: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 248
10673: PPUSH
10674: CALL_OW 450
10678: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10679: LD_ADDR_VAR 0 7
10683: PUSH
10684: LD_VAR 0 3
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 248
10698: PPUSH
10699: CALL_OW 450
10703: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10704: LD_ADDR_VAR 0 8
10708: PUSH
10709: LD_VAR 0 8
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: LD_VAR 0 6
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PUSH
10726: LD_VAR 0 7
10730: PUSH
10731: LD_INT 1
10733: ARRAY
10734: PLUS
10735: PPUSH
10736: CALL_OW 1
10740: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: LD_VAR 0 8
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_VAR 0 6
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PUSH
10763: LD_VAR 0 7
10767: PUSH
10768: LD_INT 2
10770: ARRAY
10771: PLUS
10772: PPUSH
10773: CALL_OW 1
10777: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10778: LD_ADDR_VAR 0 8
10782: PUSH
10783: LD_VAR 0 8
10787: PPUSH
10788: LD_INT 3
10790: PPUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_INT 3
10798: ARRAY
10799: PUSH
10800: LD_VAR 0 7
10804: PUSH
10805: LD_INT 3
10807: ARRAY
10808: PLUS
10809: PPUSH
10810: CALL_OW 1
10814: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10815: LD_VAR 0 5
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 275
10827: PUSH
10828: LD_VAR 0 8
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: GREATEREQUAL
10837: PUSH
10838: LD_VAR 0 5
10842: PPUSH
10843: LD_INT 3
10845: PPUSH
10846: CALL_OW 275
10850: PUSH
10851: LD_VAR 0 8
10855: PUSH
10856: LD_INT 3
10858: ARRAY
10859: GREATEREQUAL
10860: AND
10861: IFFALSE 10873
// result := true else
10863: LD_ADDR_VAR 0 4
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
10871: GO 10881
// result := false ;
10873: LD_ADDR_VAR 0 4
10877: PUSH
10878: LD_INT 0
10880: ST_TO_ADDR
// end ;
10881: LD_VAR 0 4
10885: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10886: LD_INT 0
10888: PPUSH
10889: PPUSH
10890: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 2
10903: PPUSH
10904: EMPTY
10905: PPUSH
10906: CALL 11734 0 3
10910: ST_TO_ADDR
// if unit and plist then
10911: LD_VAR 0 2
10915: PUSH
10916: LD_VAR 0 5
10920: AND
10921: IFFALSE 10982
// for i = 1 to plist do
10923: LD_ADDR_VAR 0 4
10927: PUSH
10928: DOUBLE
10929: LD_INT 1
10931: DEC
10932: ST_TO_ADDR
10933: LD_VAR 0 5
10937: PUSH
10938: FOR_TO
10939: IFFALSE 10980
// if NotTask ( plist [ i ] ) then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_VAR 0 4
10950: ARRAY
10951: PPUSH
10952: CALL 32236 0 1
10956: IFFALSE 10978
// ComDismantle ( plist [ i ] , unit ) ;
10958: LD_VAR 0 5
10962: PUSH
10963: LD_VAR 0 4
10967: ARRAY
10968: PPUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 167
10978: GO 10938
10980: POP
10981: POP
// result := true ;
10982: LD_ADDR_VAR 0 3
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// end ;
10990: LD_VAR 0 3
10994: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10995: LD_INT 0
10997: PPUSH
10998: PPUSH
10999: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11000: LD_ADDR_VAR 0 5
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: LD_INT 2
11012: PPUSH
11013: EMPTY
11014: PPUSH
11015: CALL 11734 0 3
11019: ST_TO_ADDR
// if unit and plist then
11020: LD_VAR 0 2
11024: PUSH
11025: LD_VAR 0 5
11029: AND
11030: IFFALSE 11091
// for i = 1 to plist do
11032: LD_ADDR_VAR 0 4
11036: PUSH
11037: DOUBLE
11038: LD_INT 1
11040: DEC
11041: ST_TO_ADDR
11042: LD_VAR 0 5
11046: PUSH
11047: FOR_TO
11048: IFFALSE 11089
// if NotTask ( plist [ i ] ) then
11050: LD_VAR 0 5
11054: PUSH
11055: LD_VAR 0 4
11059: ARRAY
11060: PPUSH
11061: CALL 32236 0 1
11065: IFFALSE 11087
// ComComplete ( plist [ i ] , unit ) ;
11067: LD_VAR 0 5
11071: PUSH
11072: LD_VAR 0 4
11076: ARRAY
11077: PPUSH
11078: LD_VAR 0 2
11082: PPUSH
11083: CALL 71200 0 2
11087: GO 11047
11089: POP
11090: POP
// result := true ;
11091: LD_ADDR_VAR 0 3
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// end ;
11099: LD_VAR 0 3
11103: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11104: LD_INT 0
11106: PPUSH
11107: PPUSH
11108: PPUSH
11109: PPUSH
11110: PPUSH
11111: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11112: LD_ADDR_VAR 0 5
11116: PUSH
11117: LD_INT 22
11119: PUSH
11120: LD_VAR 0 1
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 21
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 3
11141: PUSH
11142: LD_INT 57
11144: PUSH
11145: EMPTY
11146: LIST
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 24
11157: PUSH
11158: LD_INT 1000
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: PPUSH
11175: CALL_OW 69
11179: ST_TO_ADDR
// r := [ ] ;
11180: LD_ADDR_VAR 0 6
11184: PUSH
11185: EMPTY
11186: ST_TO_ADDR
// if not tmp then
11187: LD_VAR 0 5
11191: NOT
11192: IFFALSE 11198
// exit else
11194: GO 11386
11196: GO 11366
// begin r := [ tmp [ 1 ] ] ;
11198: LD_ADDR_VAR 0 6
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: LD_INT 1
11210: ARRAY
11211: PUSH
11212: EMPTY
11213: LIST
11214: ST_TO_ADDR
// for i = 2 to tmp do
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: DOUBLE
11221: LD_INT 2
11223: DEC
11224: ST_TO_ADDR
11225: LD_VAR 0 5
11229: PUSH
11230: FOR_TO
11231: IFFALSE 11364
// begin m := false ;
11233: LD_ADDR_VAR 0 7
11237: PUSH
11238: LD_INT 0
11240: ST_TO_ADDR
// for j = 1 to r do
11241: LD_ADDR_VAR 0 4
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_VAR 0 6
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11331
// if GetLives ( tmp [ i ] ) < r [ j ] then
11259: LD_VAR 0 5
11263: PUSH
11264: LD_VAR 0 3
11268: ARRAY
11269: PPUSH
11270: CALL_OW 256
11274: PUSH
11275: LD_VAR 0 6
11279: PUSH
11280: LD_VAR 0 4
11284: ARRAY
11285: LESS
11286: IFFALSE 11329
// begin r := Insert ( r , j , tmp [ i ] ) ;
11288: LD_ADDR_VAR 0 6
11292: PUSH
11293: LD_VAR 0 6
11297: PPUSH
11298: LD_VAR 0 4
11302: PPUSH
11303: LD_VAR 0 5
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: CALL_OW 2
11318: ST_TO_ADDR
// m := true ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// break ;
11327: GO 11331
// end ;
11329: GO 11256
11331: POP
11332: POP
// if not m then
11333: LD_VAR 0 7
11337: NOT
11338: IFFALSE 11362
// r := r ^ tmp [ i ] ;
11340: LD_ADDR_VAR 0 6
11344: PUSH
11345: LD_VAR 0 6
11349: PUSH
11350: LD_VAR 0 5
11354: PUSH
11355: LD_VAR 0 3
11359: ARRAY
11360: ADD
11361: ST_TO_ADDR
// end ;
11362: GO 11230
11364: POP
11365: POP
// end ; if r then
11366: LD_VAR 0 6
11370: IFFALSE 11384
// result := r else
11372: LD_ADDR_VAR 0 2
11376: PUSH
11377: LD_VAR 0 6
11381: ST_TO_ADDR
11382: GO 11386
// exit ;
11384: GO 11386
// end ;
11386: LD_VAR 0 2
11390: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11391: LD_INT 0
11393: PPUSH
11394: PPUSH
11395: PPUSH
11396: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11397: LD_ADDR_VAR 0 5
11401: PUSH
11402: LD_INT 22
11404: PUSH
11405: LD_VAR 0 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: LD_INT 25
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 25
11429: PUSH
11430: LD_INT 16
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 34
11439: PUSH
11440: LD_INT 13
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 34
11449: PUSH
11450: LD_INT 52
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 24
11466: PUSH
11467: LD_INT 650
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: ST_TO_ADDR
// p := 1 ;
11484: LD_ADDR_VAR 0 4
11488: PUSH
11489: LD_INT 1
11491: ST_TO_ADDR
// for i = 1 to repairs do
11492: LD_ADDR_VAR 0 3
11496: PUSH
11497: DOUBLE
11498: LD_INT 1
11500: DEC
11501: ST_TO_ADDR
11502: LD_VAR 0 5
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// begin if IsInUnit ( repairs [ i ] ) then
11510: LD_VAR 0 5
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: PPUSH
11521: CALL_OW 310
11525: IFFALSE 11544
// ComExitBuilding ( repairs [ i ] ) else
11527: LD_VAR 0 5
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: PPUSH
11538: CALL_OW 122
11542: GO 11642
// if not HasTask ( repairs [ i ] ) then
11544: LD_VAR 0 5
11548: PUSH
11549: LD_VAR 0 3
11553: ARRAY
11554: PPUSH
11555: CALL_OW 314
11559: NOT
11560: IFFALSE 11642
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11562: LD_VAR 0 5
11566: PUSH
11567: LD_VAR 0 3
11571: ARRAY
11572: PPUSH
11573: LD_EXP 47
11577: PUSH
11578: LD_VAR 0 1
11582: ARRAY
11583: PUSH
11584: LD_VAR 0 4
11588: ARRAY
11589: PPUSH
11590: CALL_OW 130
// if i mod 3 = 0 then
11594: LD_VAR 0 3
11598: PUSH
11599: LD_INT 3
11601: MOD
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11622
// p := p + 1 ;
11608: LD_ADDR_VAR 0 4
11612: PUSH
11613: LD_VAR 0 4
11617: PUSH
11618: LD_INT 1
11620: PLUS
11621: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11622: LD_EXP 47
11626: PUSH
11627: LD_VAR 0 1
11631: ARRAY
11632: PUSH
11633: LD_VAR 0 4
11637: LESS
11638: IFFALSE 11642
// break ;
11640: GO 11644
// end ; end ;
11642: GO 11507
11644: POP
11645: POP
// end ; end_of_file
11646: LD_VAR 0 2
11650: RET
// export function MCF_Get ( side , filter ) ; begin
11651: LD_INT 0
11653: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_INT 22
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PPUSH
11680: CALL_OW 69
11684: ST_TO_ADDR
// end ;
11685: LD_VAR 0 3
11689: RET
// export function MCF_Lab ( side ) ; begin
11690: LD_INT 0
11692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11693: LD_ADDR_VAR 0 2
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: LD_INT 30
11712: PUSH
11713: LD_INT 8
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 69
11728: ST_TO_ADDR
// end ;
11729: LD_VAR 0 2
11733: RET
// export function MCF_Class ( side , class , filter ) ; begin
11734: LD_INT 0
11736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_INT 22
11744: PUSH
11745: LD_VAR 0 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 25
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 4
11785: RET
// export function MCF_All ( side , filter ) ; begin
11786: LD_INT 0
11788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 25
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 25
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 4
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: ST_TO_ADDR
// end ;
11871: LD_VAR 0 3
11875: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11876: LD_INT 0
11878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11879: LD_ADDR_VAR 0 4
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 92
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_INT 1
11906: ARRAY
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: LD_INT 2
11915: ARRAY
11916: PUSH
11917: LD_VAR 0 2
11921: PUSH
11922: LD_INT 3
11924: ARRAY
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: PUSH
11932: LD_VAR 0 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// end ;
11947: LD_VAR 0 4
11951: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11952: LD_INT 0
11954: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11955: LD_ADDR_VAR 0 3
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_VAR 0 1
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 21
11974: PUSH
11975: LD_INT 2
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 3
12001: RET
// export function MCF_Cargo ( side ) ; begin
12002: LD_INT 0
12004: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_INT 2
12017: PUSH
12018: LD_INT 34
12020: PUSH
12021: LD_INT 12
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 34
12030: PUSH
12031: LD_INT 32
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 34
12040: PUSH
12041: LD_INT 51
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PPUSH
12054: CALL 11952 0 2
12058: ST_TO_ADDR
// end ;
12059: LD_VAR 0 2
12063: RET
// export function MCF_Ape ( side ) ; begin
12064: LD_INT 0
12066: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_VAR 0 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 2
12086: PUSH
12087: LD_INT 25
12089: PUSH
12090: LD_INT 12
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 15
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 25
12109: PUSH
12110: LD_INT 16
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 17
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// end ;
12143: LD_VAR 0 2
12147: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
12153: PPUSH
// result := [ ] ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: EMPTY
12160: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL 12064 0 1
12175: ST_TO_ADDR
// case type of 0 , normal :
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12195
12187: LD_STRING normal
12189: DOUBLE
12190: EQUAL
12191: IFTRUE 12195
12193: GO 12206
12195: POP
// cl := class_apeman ; 1 , soldier :
12196: LD_ADDR_VAR 0 5
12200: PUSH
12201: LD_INT 12
12203: ST_TO_ADDR
12204: GO 12282
12206: LD_INT 1
12208: DOUBLE
12209: EQUAL
12210: IFTRUE 12220
12212: LD_STRING soldier
12214: DOUBLE
12215: EQUAL
12216: IFTRUE 12220
12218: GO 12231
12220: POP
// cl := class_apeman_soldier ; 2 , engineer :
12221: LD_ADDR_VAR 0 5
12225: PUSH
12226: LD_INT 15
12228: ST_TO_ADDR
12229: GO 12282
12231: LD_INT 2
12233: DOUBLE
12234: EQUAL
12235: IFTRUE 12245
12237: LD_STRING engineer
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12256
12245: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12246: LD_ADDR_VAR 0 5
12250: PUSH
12251: LD_INT 16
12253: ST_TO_ADDR
12254: GO 12282
12256: LD_INT 3
12258: DOUBLE
12259: EQUAL
12260: IFTRUE 12270
12262: LD_STRING kamikaze
12264: DOUBLE
12265: EQUAL
12266: IFTRUE 12270
12268: GO 12281
12270: POP
// cl := class_apeman_kamikaze ; end ;
12271: LD_ADDR_VAR 0 5
12275: PUSH
12276: LD_INT 17
12278: ST_TO_ADDR
12279: GO 12282
12281: POP
// for i = 1 to tmp do
12282: LD_ADDR_VAR 0 6
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 4
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12347
// if GetClass ( tmp [ i ] ) = cl then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_VAR 0 6
12309: ARRAY
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_VAR 0 5
12320: EQUAL
12321: IFFALSE 12345
// result := result ^ tmp [ i ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 3
12332: PUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_VAR 0 6
12342: ARRAY
12343: ADD
12344: ST_TO_ADDR
12345: GO 12297
12347: POP
12348: POP
// end ;
12349: LD_VAR 0 3
12353: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12354: LD_INT 0
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12360: LD_ADDR_VAR 0 5
12364: PUSH
12365: LD_INT 22
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: ST_TO_ADDR
// r := [ ] ;
12391: LD_ADDR_VAR 0 6
12395: PUSH
12396: EMPTY
12397: ST_TO_ADDR
// if tmp then
12398: LD_VAR 0 5
12402: IFFALSE 12471
// for i = 1 to tmp do
12404: LD_ADDR_VAR 0 7
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_VAR 0 5
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12469
// if GetTag ( tmp [ i ] ) = tag then
12422: LD_VAR 0 5
12426: PUSH
12427: LD_VAR 0 7
12431: ARRAY
12432: PPUSH
12433: CALL_OW 110
12437: PUSH
12438: LD_VAR 0 2
12442: EQUAL
12443: IFFALSE 12467
// r := r ^ tmp [ i ] ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 6
12454: PUSH
12455: LD_VAR 0 5
12459: PUSH
12460: LD_VAR 0 7
12464: ARRAY
12465: ADD
12466: ST_TO_ADDR
12467: GO 12419
12469: POP
12470: POP
// result := r ;
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: LD_VAR 0 6
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 4
12485: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
// tmp := plist ;
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 2
12500: ST_TO_ADDR
// if tmp then
12501: LD_VAR 0 5
12505: IFFALSE 12582
// begin for i = 1 to tmp do
12507: LD_ADDR_VAR 0 6
12511: PUSH
12512: DOUBLE
12513: LD_INT 1
12515: DEC
12516: ST_TO_ADDR
12517: LD_VAR 0 5
12521: PUSH
12522: FOR_TO
12523: IFFALSE 12570
// if GetTag ( tmp [ i ] ) <> tag then
12525: LD_VAR 0 5
12529: PUSH
12530: LD_VAR 0 6
12534: ARRAY
12535: PPUSH
12536: CALL_OW 110
12540: PUSH
12541: LD_VAR 0 3
12545: NONEQUAL
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , tag ) ;
12548: LD_VAR 0 5
12552: PUSH
12553: LD_VAR 0 6
12557: ARRAY
12558: PPUSH
12559: LD_VAR 0 3
12563: PPUSH
12564: CALL_OW 109
12568: GO 12522
12570: POP
12571: POP
// result := true ;
12572: LD_ADDR_VAR 0 4
12576: PUSH
12577: LD_INT 1
12579: ST_TO_ADDR
// end else
12580: GO 12590
// result := false ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 0
12589: ST_TO_ADDR
// end ;
12590: LD_VAR 0 4
12594: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12595: LD_INT 0
12597: PPUSH
12598: PPUSH
12599: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_VAR 0 2
12614: PPUSH
12615: EMPTY
12616: PPUSH
12617: CALL 12354 0 3
12621: ST_TO_ADDR
// if tmp then
12622: LD_VAR 0 4
12626: IFFALSE 12678
// begin for i = 1 to tmp do
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: DOUBLE
12634: LD_INT 1
12636: DEC
12637: ST_TO_ADDR
12638: LD_VAR 0 4
12642: PUSH
12643: FOR_TO
12644: IFFALSE 12666
// SetTag ( tmp [ i ] , 0 ) ;
12646: LD_VAR 0 4
12650: PUSH
12651: LD_VAR 0 5
12655: ARRAY
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 109
12664: GO 12643
12666: POP
12667: POP
// result := true ;
12668: LD_ADDR_VAR 0 3
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end else
12676: GO 12686
// result := false ;
12678: LD_ADDR_VAR 0 3
12682: PUSH
12683: LD_INT 0
12685: ST_TO_ADDR
// end ;
12686: LD_VAR 0 3
12690: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12691: LD_INT 0
12693: PPUSH
12694: PPUSH
12695: PPUSH
12696: PPUSH
12697: PPUSH
// sort_list := [ ] ;
12698: LD_ADDR_VAR 0 5
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// for i = 1 to list do
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: DOUBLE
12711: LD_INT 1
12713: DEC
12714: ST_TO_ADDR
12715: LD_VAR 0 1
12719: PUSH
12720: FOR_TO
12721: IFFALSE 12883
// begin if i = 1 then
12723: LD_VAR 0 3
12727: PUSH
12728: LD_INT 1
12730: EQUAL
12731: IFFALSE 12757
// sort_list := sort_list ^ list [ i ] else
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PUSH
12743: LD_VAR 0 1
12747: PUSH
12748: LD_VAR 0 3
12752: ARRAY
12753: ADD
12754: ST_TO_ADDR
12755: GO 12881
// begin for j = 1 to sort_list do
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: DOUBLE
12763: LD_INT 1
12765: DEC
12766: ST_TO_ADDR
12767: LD_VAR 0 5
12771: PUSH
12772: FOR_TO
12773: IFFALSE 12850
// begin add := false ;
12775: LD_ADDR_VAR 0 6
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12783: LD_VAR 0 1
12787: PUSH
12788: LD_VAR 0 3
12792: ARRAY
12793: PUSH
12794: LD_VAR 0 5
12798: PUSH
12799: LD_VAR 0 4
12803: ARRAY
12804: LESS
12805: IFFALSE 12848
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12807: LD_ADDR_VAR 0 5
12811: PUSH
12812: LD_VAR 0 5
12816: PPUSH
12817: LD_VAR 0 4
12821: PPUSH
12822: LD_VAR 0 1
12826: PUSH
12827: LD_VAR 0 3
12831: ARRAY
12832: PPUSH
12833: CALL_OW 2
12837: ST_TO_ADDR
// add := true ;
12838: LD_ADDR_VAR 0 6
12842: PUSH
12843: LD_INT 1
12845: ST_TO_ADDR
// break ;
12846: GO 12850
// end ; end ;
12848: GO 12772
12850: POP
12851: POP
// if not add then
12852: LD_VAR 0 6
12856: NOT
12857: IFFALSE 12881
// sort_list := sort_list ^ list [ i ] ;
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_VAR 0 5
12868: PUSH
12869: LD_VAR 0 1
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: ADD
12880: ST_TO_ADDR
// end ; end ;
12881: GO 12720
12883: POP
12884: POP
// result := sort_list ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_VAR 0 5
12894: ST_TO_ADDR
// end ;
12895: LD_VAR 0 2
12899: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// sort_list := [ ] ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// for i = 1 to list do
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: DOUBLE
12920: LD_INT 1
12922: DEC
12923: ST_TO_ADDR
12924: LD_VAR 0 1
12928: PUSH
12929: FOR_TO
12930: IFFALSE 13092
// begin if i = 1 then
12932: LD_VAR 0 3
12936: PUSH
12937: LD_INT 1
12939: EQUAL
12940: IFFALSE 12966
// sort_list := sort_list ^ list [ i ] else
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: LD_VAR 0 5
12951: PUSH
12952: LD_VAR 0 1
12956: PUSH
12957: LD_VAR 0 3
12961: ARRAY
12962: ADD
12963: ST_TO_ADDR
12964: GO 13090
// begin for j = 1 to sort_list do
12966: LD_ADDR_VAR 0 4
12970: PUSH
12971: DOUBLE
12972: LD_INT 1
12974: DEC
12975: ST_TO_ADDR
12976: LD_VAR 0 5
12980: PUSH
12981: FOR_TO
12982: IFFALSE 13059
// begin add := false ;
12984: LD_ADDR_VAR 0 6
12988: PUSH
12989: LD_INT 0
12991: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_VAR 0 3
13001: ARRAY
13002: PUSH
13003: LD_VAR 0 5
13007: PUSH
13008: LD_VAR 0 4
13012: ARRAY
13013: GREATER
13014: IFFALSE 13057
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13016: LD_ADDR_VAR 0 5
13020: PUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: LD_VAR 0 4
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_VAR 0 3
13040: ARRAY
13041: PPUSH
13042: CALL_OW 2
13046: ST_TO_ADDR
// add := true ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// break ;
13055: GO 13059
// end ; end ;
13057: GO 12981
13059: POP
13060: POP
// if not add then
13061: LD_VAR 0 6
13065: NOT
13066: IFFALSE 13090
// sort_list := sort_list ^ list [ i ] ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_VAR 0 5
13077: PUSH
13078: LD_VAR 0 1
13082: PUSH
13083: LD_VAR 0 3
13087: ARRAY
13088: ADD
13089: ST_TO_ADDR
// end ; end ;
13090: GO 12929
13092: POP
13093: POP
// result := sort_list ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 5
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 2
13108: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: LESS
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
13427: PPUSH
// tmp := [ ] ;
13428: LD_ADDR_VAR 0 8
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// r := [ ] ;
13435: LD_ADDR_VAR 0 7
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// add := false ;
13442: LD_ADDR_VAR 0 9
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// if plist then
13450: LD_VAR 0 2
13454: IFFALSE 13530
// begin for i = 1 to plist do
13456: LD_ADDR_VAR 0 5
13460: PUSH
13461: DOUBLE
13462: LD_INT 1
13464: DEC
13465: ST_TO_ADDR
13466: LD_VAR 0 2
13470: PUSH
13471: FOR_TO
13472: IFFALSE 13526
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13474: LD_ADDR_VAR 0 8
13478: PUSH
13479: LD_VAR 0 8
13483: PUSH
13484: LD_VAR 0 2
13488: PUSH
13489: LD_VAR 0 5
13493: ARRAY
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ARRAY
13505: PPUSH
13506: LD_VAR 0 3
13510: PPUSH
13511: CALL_OW 259
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: ADD
13523: ST_TO_ADDR
// end ;
13524: GO 13471
13526: POP
13527: POP
// end else
13528: GO 13538
// result := false ;
13530: LD_ADDR_VAR 0 4
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// if tmp then
13538: LD_VAR 0 8
13542: IFFALSE 13716
// begin r := r ^ [ tmp [ 1 ] ] ;
13544: LD_ADDR_VAR 0 7
13548: PUSH
13549: LD_VAR 0 7
13553: PUSH
13554: LD_VAR 0 8
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PUSH
13563: EMPTY
13564: LIST
13565: ADD
13566: ST_TO_ADDR
// for i = 2 to tmp do
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: DOUBLE
13573: LD_INT 2
13575: DEC
13576: ST_TO_ADDR
13577: LD_VAR 0 8
13581: PUSH
13582: FOR_TO
13583: IFFALSE 13714
// begin for j = 1 to r do
13585: LD_ADDR_VAR 0 6
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 7
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13678
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13603: LD_VAR 0 8
13607: PUSH
13608: LD_VAR 0 5
13612: ARRAY
13613: PUSH
13614: LD_INT 2
13616: ARRAY
13617: PUSH
13618: LD_VAR 0 7
13622: PUSH
13623: LD_VAR 0 6
13627: ARRAY
13628: PUSH
13629: LD_INT 2
13631: ARRAY
13632: GREATER
13633: IFFALSE 13676
// begin r := Insert ( r , j , tmp [ i ] ) ;
13635: LD_ADDR_VAR 0 7
13639: PUSH
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 8
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 2
13665: ST_TO_ADDR
// add := true ;
13666: LD_ADDR_VAR 0 9
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// break ;
13674: GO 13678
// end ; end ;
13676: GO 13600
13678: POP
13679: POP
// if not add then
13680: LD_VAR 0 9
13684: NOT
13685: IFFALSE 13712
// r := r ^ [ tmp [ i ] ] ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_VAR 0 7
13696: PUSH
13697: LD_VAR 0 8
13701: PUSH
13702: LD_VAR 0 5
13706: ARRAY
13707: PUSH
13708: EMPTY
13709: LIST
13710: ADD
13711: ST_TO_ADDR
// end ;
13712: GO 13582
13714: POP
13715: POP
// end ; result := r ;
13716: LD_ADDR_VAR 0 4
13720: PUSH
13721: LD_VAR 0 7
13725: ST_TO_ADDR
// end ;
13726: LD_VAR 0 4
13730: RET
// export function MCF_Clear ( side ) ; var i ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
// for i = 1 to 100 do
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: DOUBLE
13741: LD_INT 1
13743: DEC
13744: ST_TO_ADDR
13745: LD_INT 100
13747: PUSH
13748: FOR_TO
13749: IFFALSE 13785
// if MCF_Tag ( side , i , [ ] ) then
13751: LD_VAR 0 1
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: EMPTY
13762: PPUSH
13763: CALL 12354 0 3
13767: IFFALSE 13783
// MCF_ClearTag ( side , i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL 12595 0 2
13783: GO 13748
13785: POP
13786: POP
// result := true ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 1
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
// for i = 1 to plist do
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: DOUBLE
13811: LD_INT 1
13813: DEC
13814: ST_TO_ADDR
13815: LD_VAR 0 1
13819: PUSH
13820: FOR_TO
13821: IFFALSE 13870
// if MCF_HasClass ( plist [ i ] ) = n then
13823: LD_VAR 0 1
13827: PUSH
13828: LD_VAR 0 4
13832: ARRAY
13833: PPUSH
13834: CALL 14357 0 1
13838: PUSH
13839: LD_VAR 0 2
13843: EQUAL
13844: IFFALSE 13868
// tmp := tmp ^ plist [ i ] ;
13846: LD_ADDR_VAR 0 5
13850: PUSH
13851: LD_VAR 0 5
13855: PUSH
13856: LD_VAR 0 1
13860: PUSH
13861: LD_VAR 0 4
13865: ARRAY
13866: ADD
13867: ST_TO_ADDR
13868: GO 13820
13870: POP
13871: POP
// result := tmp ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_VAR 0 5
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 3
13886: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
13891: PPUSH
// if mreg = ToArm then
13892: LD_VAR 0 2
13896: PUSH
13897: LD_STRING ToArm
13899: EQUAL
13900: IFFALSE 14005
// begin tmp := MREG_ToArm [ side ] ;
13902: LD_ADDR_VAR 0 6
13906: PUSH
13907: LD_EXP 56
13911: PUSH
13912: LD_VAR 0 1
13916: ARRAY
13917: ST_TO_ADDR
// if tmp = 0 then
13918: LD_VAR 0 6
13922: PUSH
13923: LD_INT 0
13925: EQUAL
13926: IFFALSE 13932
// exit else
13928: GO 14352
13930: GO 14005
// begin for i = MREG_ToArm [ side ] downto n do
13932: LD_ADDR_VAR 0 5
13936: PUSH
13937: DOUBLE
13938: LD_EXP 56
13942: PUSH
13943: LD_VAR 0 1
13947: ARRAY
13948: INC
13949: ST_TO_ADDR
13950: LD_VAR 0 3
13954: PUSH
13955: FOR_DOWNTO
13956: IFFALSE 13978
// tmp := Delete ( tmp , 1 ) ;
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: LD_INT 1
13970: PPUSH
13971: CALL_OW 3
13975: ST_TO_ADDR
13976: GO 13955
13978: POP
13979: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13980: LD_ADDR_EXP 56
13984: PUSH
13985: LD_EXP 56
13989: PPUSH
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 6
13999: PPUSH
14000: CALL_OW 1
14004: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14005: LD_VAR 0 2
14009: PUSH
14010: LD_STRING ToDep
14012: EQUAL
14013: IFFALSE 14118
// begin tmp := MREG_ToDep [ side ] ;
14015: LD_ADDR_VAR 0 6
14019: PUSH
14020: LD_EXP 57
14024: PUSH
14025: LD_VAR 0 1
14029: ARRAY
14030: ST_TO_ADDR
// if tmp = 0 then
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 0
14038: EQUAL
14039: IFFALSE 14045
// exit else
14041: GO 14352
14043: GO 14118
// begin for i = MREG_ToDep [ side ] downto n do
14045: LD_ADDR_VAR 0 5
14049: PUSH
14050: DOUBLE
14051: LD_EXP 57
14055: PUSH
14056: LD_VAR 0 1
14060: ARRAY
14061: INC
14062: ST_TO_ADDR
14063: LD_VAR 0 3
14067: PUSH
14068: FOR_DOWNTO
14069: IFFALSE 14091
// tmp := Delete ( tmp , 1 ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 3
14088: ST_TO_ADDR
14089: GO 14068
14091: POP
14092: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14093: LD_ADDR_EXP 57
14097: PUSH
14098: LD_EXP 57
14102: PPUSH
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 6
14112: PPUSH
14113: CALL_OW 1
14117: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14118: LD_VAR 0 2
14122: PUSH
14123: LD_STRING ToFac
14125: EQUAL
14126: IFFALSE 14231
// begin tmp := MREG_ToFac [ side ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_EXP 55
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: ST_TO_ADDR
// if tmp = 0 then
14144: LD_VAR 0 6
14148: PUSH
14149: LD_INT 0
14151: EQUAL
14152: IFFALSE 14158
// exit else
14154: GO 14352
14156: GO 14231
// begin for i = MREG_ToFac [ side ] downto n do
14158: LD_ADDR_VAR 0 5
14162: PUSH
14163: DOUBLE
14164: LD_EXP 55
14168: PUSH
14169: LD_VAR 0 1
14173: ARRAY
14174: INC
14175: ST_TO_ADDR
14176: LD_VAR 0 3
14180: PUSH
14181: FOR_DOWNTO
14182: IFFALSE 14204
// tmp := Delete ( tmp , 1 ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 6
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 3
14201: ST_TO_ADDR
14202: GO 14181
14204: POP
14205: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14206: LD_ADDR_EXP 55
14210: PUSH
14211: LD_EXP 55
14215: PPUSH
14216: LD_VAR 0 1
14220: PPUSH
14221: LD_VAR 0 6
14225: PPUSH
14226: CALL_OW 1
14230: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14231: LD_VAR 0 2
14235: PUSH
14236: LD_STRING ToLab
14238: EQUAL
14239: IFFALSE 14344
// begin tmp := MREG_ToLab [ side ] ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_EXP 54
14250: PUSH
14251: LD_VAR 0 1
14255: ARRAY
14256: ST_TO_ADDR
// if tmp = 0 then
14257: LD_VAR 0 6
14261: PUSH
14262: LD_INT 0
14264: EQUAL
14265: IFFALSE 14271
// exit else
14267: GO 14352
14269: GO 14344
// begin for i = MREG_ToLab [ side ] downto n do
14271: LD_ADDR_VAR 0 5
14275: PUSH
14276: DOUBLE
14277: LD_EXP 54
14281: PUSH
14282: LD_VAR 0 1
14286: ARRAY
14287: INC
14288: ST_TO_ADDR
14289: LD_VAR 0 3
14293: PUSH
14294: FOR_DOWNTO
14295: IFFALSE 14317
// tmp := Delete ( tmp , 1 ) ;
14297: LD_ADDR_VAR 0 6
14301: PUSH
14302: LD_VAR 0 6
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 3
14314: ST_TO_ADDR
14315: GO 14294
14317: POP
14318: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14319: LD_ADDR_EXP 54
14323: PUSH
14324: LD_EXP 54
14328: PPUSH
14329: LD_VAR 0 1
14333: PPUSH
14334: LD_VAR 0 6
14338: PPUSH
14339: CALL_OW 1
14343: ST_TO_ADDR
// end ; end ; result := true ;
14344: LD_ADDR_VAR 0 4
14348: PUSH
14349: LD_INT 1
14351: ST_TO_ADDR
// end ;
14352: LD_VAR 0 4
14356: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
// side := GetSide ( unit ) ;
14362: LD_ADDR_VAR 0 4
14366: PUSH
14367: LD_VAR 0 1
14371: PPUSH
14372: CALL_OW 255
14376: ST_TO_ADDR
// tmp := 0 ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14385: LD_VAR 0 1
14389: PUSH
14390: LD_EXP 56
14394: PUSH
14395: LD_VAR 0 4
14399: ARRAY
14400: IN
14401: IFFALSE 14411
// tmp := 1 ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14411: LD_VAR 0 1
14415: PUSH
14416: LD_EXP 57
14420: PUSH
14421: LD_VAR 0 4
14425: ARRAY
14426: IN
14427: IFFALSE 14437
// tmp := 2 ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_INT 2
14436: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14437: LD_VAR 0 1
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: LD_VAR 0 4
14451: ARRAY
14452: IN
14453: IFFALSE 14463
// tmp := 3 ;
14455: LD_ADDR_VAR 0 3
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_EXP 54
14472: PUSH
14473: LD_VAR 0 4
14477: ARRAY
14478: IN
14479: IFFALSE 14489
// tmp := 4 ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: LD_INT 4
14488: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 68
14498: PUSH
14499: LD_VAR 0 4
14503: ARRAY
14504: IN
14505: IFFALSE 14515
// tmp := 5 ;
14507: LD_ADDR_VAR 0 3
14511: PUSH
14512: LD_INT 5
14514: ST_TO_ADDR
// result := tmp ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 3
14524: ST_TO_ADDR
// end ;
14525: LD_VAR 0 2
14529: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
// if mreg = ToArm then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_STRING ToArm
14541: EQUAL
14542: IFFALSE 14631
// for i = MREG_ToArm [ side ] downto 1 do
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: DOUBLE
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: INC
14561: ST_TO_ADDR
14562: LD_INT 1
14564: PUSH
14565: FOR_DOWNTO
14566: IFFALSE 14629
// if MREG_ToArm [ side ] [ i ] = unit then
14568: LD_EXP 56
14572: PUSH
14573: LD_VAR 0 1
14577: ARRAY
14578: PUSH
14579: LD_VAR 0 5
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: EQUAL
14590: IFFALSE 14627
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14592: LD_ADDR_EXP 56
14596: PUSH
14597: LD_EXP 56
14601: PPUSH
14602: LD_EXP 56
14606: PUSH
14607: LD_VAR 0 1
14611: ARRAY
14612: PUSH
14613: LD_VAR 0 5
14617: ARRAY
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 31289 0 3
14626: ST_TO_ADDR
// end ;
14627: GO 14565
14629: POP
14630: POP
// if mreg = ToDep then
14631: LD_VAR 0 2
14635: PUSH
14636: LD_STRING ToDep
14638: EQUAL
14639: IFFALSE 14728
// for i = MREG_ToDep [ side ] downto 1 do
14641: LD_ADDR_VAR 0 5
14645: PUSH
14646: DOUBLE
14647: LD_EXP 57
14651: PUSH
14652: LD_VAR 0 1
14656: ARRAY
14657: INC
14658: ST_TO_ADDR
14659: LD_INT 1
14661: PUSH
14662: FOR_DOWNTO
14663: IFFALSE 14726
// if MREG_ToDep [ side ] [ i ] = unit then
14665: LD_EXP 57
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PUSH
14676: LD_VAR 0 5
14680: ARRAY
14681: PUSH
14682: LD_VAR 0 3
14686: EQUAL
14687: IFFALSE 14724
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14689: LD_ADDR_EXP 57
14693: PUSH
14694: LD_EXP 57
14698: PPUSH
14699: LD_EXP 57
14703: PUSH
14704: LD_VAR 0 1
14708: ARRAY
14709: PUSH
14710: LD_VAR 0 5
14714: ARRAY
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: CALL 31289 0 3
14723: ST_TO_ADDR
// end ;
14724: GO 14662
14726: POP
14727: POP
// if mreg = ToFac then
14728: LD_VAR 0 2
14732: PUSH
14733: LD_STRING ToFac
14735: EQUAL
14736: IFFALSE 14825
// for i = MREG_ToFac [ side ] downto 1 do
14738: LD_ADDR_VAR 0 5
14742: PUSH
14743: DOUBLE
14744: LD_EXP 55
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: INC
14755: ST_TO_ADDR
14756: LD_INT 1
14758: PUSH
14759: FOR_DOWNTO
14760: IFFALSE 14823
// if MREG_ToFac [ side ] [ i ] = unit then
14762: LD_EXP 55
14766: PUSH
14767: LD_VAR 0 1
14771: ARRAY
14772: PUSH
14773: LD_VAR 0 5
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 3
14783: EQUAL
14784: IFFALSE 14821
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14786: LD_ADDR_EXP 55
14790: PUSH
14791: LD_EXP 55
14795: PPUSH
14796: LD_EXP 55
14800: PUSH
14801: LD_VAR 0 1
14805: ARRAY
14806: PUSH
14807: LD_VAR 0 5
14811: ARRAY
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL 31289 0 3
14820: ST_TO_ADDR
// end ;
14821: GO 14759
14823: POP
14824: POP
// if mreg = ToLab then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_STRING ToLab
14832: EQUAL
14833: IFFALSE 14922
// for i = MREG_ToLab [ side ] downto 1 do
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: DOUBLE
14841: LD_EXP 54
14845: PUSH
14846: LD_VAR 0 1
14850: ARRAY
14851: INC
14852: ST_TO_ADDR
14853: LD_INT 1
14855: PUSH
14856: FOR_DOWNTO
14857: IFFALSE 14920
// if MREG_ToLab [ side ] [ i ] = unit then
14859: LD_EXP 54
14863: PUSH
14864: LD_VAR 0 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 5
14874: ARRAY
14875: PUSH
14876: LD_VAR 0 3
14880: EQUAL
14881: IFFALSE 14918
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14883: LD_ADDR_EXP 54
14887: PUSH
14888: LD_EXP 54
14892: PPUSH
14893: LD_EXP 54
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PUSH
14904: LD_VAR 0 5
14908: ARRAY
14909: PPUSH
14910: LD_INT 1
14912: PPUSH
14913: CALL 31289 0 3
14917: ST_TO_ADDR
// end ;
14918: GO 14856
14920: POP
14921: POP
// end ;
14922: LD_VAR 0 4
14926: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// result := false ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: DOUBLE
14945: LD_INT 1
14947: DEC
14948: ST_TO_ADDR
14949: LD_EXP 46
14953: PUSH
14954: FOR_TO
14955: IFFALSE 15019
// if MREG_ToBuild [ i ] [ 1 ] = side then
14957: LD_EXP 46
14961: PUSH
14962: LD_VAR 0 3
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_VAR 0 1
14976: EQUAL
14977: IFFALSE 15017
// begin if MREG_ToBuild [ i ] [ 1 ] then
14979: LD_EXP 46
14983: PUSH
14984: LD_VAR 0 3
14988: ARRAY
14989: PUSH
14990: LD_INT 1
14992: ARRAY
14993: IFFALSE 15017
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14995: LD_ADDR_VAR 0 2
14999: PUSH
15000: LD_EXP 46
15004: PUSH
15005: LD_VAR 0 3
15009: ARRAY
15010: PUSH
15011: LD_INT 1
15013: ARRAY
15014: ST_TO_ADDR
// break ;
15015: GO 15019
// end ; end ;
15017: GO 14954
15019: POP
15020: POP
// for i = 1 to MREG_ToRepair do
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: DOUBLE
15027: LD_INT 1
15029: DEC
15030: ST_TO_ADDR
15031: LD_EXP 47
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15101
// if MREG_ToRepair [ i ] [ 1 ] = side then
15039: LD_EXP 47
15043: PUSH
15044: LD_VAR 0 3
15048: ARRAY
15049: PUSH
15050: LD_INT 1
15052: ARRAY
15053: PUSH
15054: LD_VAR 0 1
15058: EQUAL
15059: IFFALSE 15099
// begin if MREG_ToRepair [ i ] [ 1 ] then
15061: LD_EXP 47
15065: PUSH
15066: LD_VAR 0 3
15070: ARRAY
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: IFFALSE 15099
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15077: LD_ADDR_VAR 0 2
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: LD_VAR 0 3
15091: ARRAY
15092: PUSH
15093: LD_INT 1
15095: ARRAY
15096: ST_TO_ADDR
// break ;
15097: GO 15101
// end ; end ;
15099: GO 15036
15101: POP
15102: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_INT 57
15110: PUSH
15111: EMPTY
15112: LIST
15113: PPUSH
15114: CALL 11651 0 2
15118: IFFALSE 15145
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 57
15132: PUSH
15133: EMPTY
15134: LIST
15135: PPUSH
15136: CALL 11651 0 2
15140: PUSH
15141: LD_INT 1
15143: ARRAY
15144: ST_TO_ADDR
// end ;
15145: LD_VAR 0 2
15149: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL 11651 0 2
15181: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15182: LD_ADDR_VAR 0 7
15186: PUSH
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 81
15194: PUSH
15195: LD_VAR 0 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL 11651 0 2
15208: ST_TO_ADDR
// if not enemy then
15209: LD_VAR 0 7
15213: NOT
15214: IFFALSE 15226
// result := false else
15216: LD_ADDR_VAR 0 3
15220: PUSH
15221: LD_INT 0
15223: ST_TO_ADDR
15224: GO 15280
// begin scan := NearestUnit ( b , enemy ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 6
15235: PPUSH
15236: LD_VAR 0 7
15240: PPUSH
15241: CALL 32282 0 2
15245: ST_TO_ADDR
// if scan [ 2 ] < dist then
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 2
15259: LESS
15260: IFFALSE 15272
// result := true else
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
15270: GO 15280
// result := false ;
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 0
15279: ST_TO_ADDR
// end ; end ;
15280: LD_VAR 0 3
15284: RET
// export function MCF_Info ( ) ; begin
15285: LD_INT 0
15287: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15288: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15290: PUSH
15291: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15293: ADD
15294: PUSH
15295: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15297: ADD
15298: PUSH
15299: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15301: ADD
15302: PUSH
15303: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15305: ADD
15306: PUSH
15307: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15325: ADD
15326: PPUSH
15327: CALL 8569 0 1
// end ; end_of_file
15331: LD_VAR 0 1
15335: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 2
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11651 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13800 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 13420 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 1
15529: PPUSH
15530: CALL 41960 0 4
15534: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 56
15539: PUSH
15540: LD_EXP 56
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 56
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 31130 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 3
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11651 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13800 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 13420 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 2
15787: PPUSH
15788: CALL 41960 0 4
15792: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 57
15797: PUSH
15798: LD_EXP 57
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 57
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 31130 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 25
15893: PUSH
15894: LD_INT 4
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL 11651 0 2
15911: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15912: LD_ADDR_VAR 0 5
15916: PUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: LD_INT 0
15924: PPUSH
15925: CALL 13800 0 2
15929: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_VAR 0 5
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 13420 0 3
15952: ST_TO_ADDR
// if n > sk then
15953: LD_VAR 0 2
15957: PUSH
15958: LD_VAR 0 6
15962: GREATER
15963: IFFALSE 15975
// n := sk ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_VAR 0 6
15974: ST_TO_ADDR
// for i = 1 to n do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 2
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16103
// if ( sk [ i ] [ 1 ] ) <> 0 then
15993: LD_VAR 0 6
15997: PUSH
15998: LD_VAR 0 4
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PUSH
16008: LD_INT 0
16010: NONEQUAL
16011: IFFALSE 16101
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16013: LD_ADDR_EXP 53
16017: PUSH
16018: LD_EXP 53
16022: PPUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 6
16032: PUSH
16033: LD_VAR 0 4
16037: ARRAY
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_INT 3
16045: PPUSH
16046: CALL 41960 0 4
16050: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16051: LD_ADDR_EXP 55
16055: PUSH
16056: LD_EXP 55
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: LD_EXP 55
16070: PUSH
16071: LD_VAR 0 1
16075: ARRAY
16076: PUSH
16077: LD_INT 1
16079: PLUS
16080: PPUSH
16081: LD_VAR 0 6
16085: PUSH
16086: LD_VAR 0 4
16090: ARRAY
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL 31130 0 4
16100: ST_TO_ADDR
// end ;
16101: GO 15990
16103: POP
16104: POP
// end ;
16105: LD_VAR 0 3
16109: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16116: LD_ADDR_VAR 0 5
16120: PUSH
16121: LD_VAR 0 1
16125: PPUSH
16126: LD_INT 2
16128: PUSH
16129: LD_INT 25
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL 11651 0 2
16158: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: LD_VAR 0 5
16168: PPUSH
16169: LD_INT 0
16171: PPUSH
16172: CALL 13800 0 2
16176: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16177: LD_ADDR_VAR 0 6
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 13420 0 3
16199: ST_TO_ADDR
// if n > sk then
16200: LD_VAR 0 2
16204: PUSH
16205: LD_VAR 0 6
16209: GREATER
16210: IFFALSE 16222
// n := sk ;
16212: LD_ADDR_VAR 0 2
16216: PUSH
16217: LD_VAR 0 6
16221: ST_TO_ADDR
// for i = 1 to n do
16222: LD_ADDR_VAR 0 4
16226: PUSH
16227: DOUBLE
16228: LD_INT 1
16230: DEC
16231: ST_TO_ADDR
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_TO
16238: IFFALSE 16350
// if ( sk [ i ] [ 1 ] ) <> 0 then
16240: LD_VAR 0 6
16244: PUSH
16245: LD_VAR 0 4
16249: ARRAY
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: PUSH
16255: LD_INT 0
16257: NONEQUAL
16258: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 4
16284: ARRAY
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: PPUSH
16290: LD_INT 4
16292: PPUSH
16293: CALL 41960 0 4
16297: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16298: LD_ADDR_EXP 54
16302: PUSH
16303: LD_EXP 54
16307: PPUSH
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_EXP 54
16317: PUSH
16318: LD_VAR 0 1
16322: ARRAY
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: LD_VAR 0 6
16332: PUSH
16333: LD_VAR 0 4
16337: ARRAY
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 31130 0 4
16347: ST_TO_ADDR
// end ;
16348: GO 16237
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 3
16356: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 25
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 25
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 25
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL 11651 0 2
16427: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16428: LD_ADDR_VAR 0 6
16432: PUSH
16433: LD_VAR 0 6
16437: PPUSH
16438: LD_INT 0
16440: PPUSH
16441: CALL 13800 0 2
16445: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16446: LD_ADDR_VAR 0 7
16450: PUSH
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_VAR 0 6
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL 13420 0 3
16468: ST_TO_ADDR
// if n > sk then
16469: LD_VAR 0 2
16473: PUSH
16474: LD_VAR 0 7
16478: GREATER
16479: IFFALSE 16491
// n := sk ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 7
16490: ST_TO_ADDR
// for i = 1 to n do
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: DOUBLE
16497: LD_INT 1
16499: DEC
16500: ST_TO_ADDR
16501: LD_VAR 0 2
16505: PUSH
16506: FOR_TO
16507: IFFALSE 16551
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_EXP 53
16518: PPUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_VAR 0 7
16528: PUSH
16529: LD_VAR 0 5
16533: ARRAY
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 3
16543: PPUSH
16544: CALL 41960 0 4
16548: ST_TO_ADDR
// end ;
16549: GO 16506
16551: POP
16552: POP
// end ;
16553: LD_VAR 0 4
16557: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16558: LD_INT 0
16560: PPUSH
16561: PPUSH
16562: PPUSH
// b := false ;
16563: LD_ADDR_VAR 0 6
16567: PUSH
16568: LD_INT 0
16570: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: LD_INT 9
16581: PUSH
16582: LD_INT 5
16584: PUSH
16585: LD_INT 8
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: IN
16594: IFFALSE 16682
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16596: LD_VAR 0 1
16600: PPUSH
16601: LD_INT 2
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL 11651 0 2
16633: IFFALSE 16682
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 30
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL 11651 0 2
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: ST_TO_ADDR
// if class = class_engineer then
16682: LD_VAR 0 3
16686: PUSH
16687: LD_INT 2
16689: EQUAL
16690: IFFALSE 16778
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16692: LD_VAR 0 1
16696: PPUSH
16697: LD_INT 2
16699: PUSH
16700: LD_INT 30
16702: PUSH
16703: LD_INT 0
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 30
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL 11651 0 2
16729: IFFALSE 16778
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16731: LD_ADDR_VAR 0 6
16735: PUSH
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 30
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL 11651 0 2
16773: PUSH
16774: LD_INT 1
16776: ARRAY
16777: ST_TO_ADDR
// if class = class_mechanic then
16778: LD_VAR 0 3
16782: PUSH
16783: LD_INT 3
16785: EQUAL
16786: IFFALSE 16856
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 30
16795: PUSH
16796: LD_INT 3
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PPUSH
16803: CALL 11651 0 2
16807: IFFALSE 16856
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16809: LD_ADDR_VAR 0 6
16813: PUSH
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_INT 2
16821: PUSH
16822: LD_INT 30
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 30
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PPUSH
16847: CALL 11651 0 2
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: ST_TO_ADDR
// if class = class_scientistic then
16856: LD_VAR 0 3
16860: PUSH
16861: LD_INT 4
16863: EQUAL
16864: IFFALSE 16974
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16866: LD_VAR 0 1
16870: PPUSH
16871: LD_INT 2
16873: PUSH
16874: LD_INT 30
16876: PUSH
16877: LD_INT 6
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PUSH
16884: LD_INT 30
16886: PUSH
16887: LD_INT 7
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 30
16896: PUSH
16897: LD_INT 8
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PPUSH
16910: CALL 11651 0 2
16914: IFFALSE 16974
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16916: LD_ADDR_VAR 0 6
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: LD_INT 2
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 6
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 30
16941: PUSH
16942: LD_INT 7
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 30
16951: PUSH
16952: LD_INT 8
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL 11651 0 2
16969: PUSH
16970: LD_INT 1
16972: ARRAY
16973: ST_TO_ADDR
// if GetClass ( unit ) = class then
16974: LD_VAR 0 2
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_VAR 0 3
16988: EQUAL
16989: IFFALSE 17023
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16991: LD_ADDR_EXP 53
16995: PUSH
16996: LD_EXP 53
17000: PPUSH
17001: LD_VAR 0 1
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: LD_VAR 0 3
17015: PPUSH
17016: CALL 42051 0 4
17020: ST_TO_ADDR
// end else
17021: GO 17116
// if b then
17023: LD_VAR 0 6
17027: IFFALSE 17108
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17029: LD_VAR 0 2
17033: PPUSH
17034: CALL_OW 310
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: CALL_OW 310
17048: PUSH
17049: LD_VAR 0 6
17053: NONEQUAL
17054: AND
17055: IFFALSE 17066
// ComExitBuilding ( unit ) ;
17057: LD_VAR 0 2
17061: PPUSH
17062: CALL_OW 122
// if not IsInUnit ( unit ) then
17066: LD_VAR 0 2
17070: PPUSH
17071: CALL_OW 310
17075: NOT
17076: IFFALSE 17092
// ComEnterUnit ( unit , b ) ;
17078: LD_VAR 0 2
17082: PPUSH
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_VAR 0 3
17101: PPUSH
17102: CALL_OW 183
// end else
17106: GO 17116
// result := false ;
17108: LD_ADDR_VAR 0 4
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// end ; end_of_file
17116: LD_VAR 0 4
17120: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17121: LD_INT 0
17123: PPUSH
17124: PPUSH
17125: PPUSH
17126: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17127: LD_ADDR_VAR 0 5
17131: PUSH
17132: LD_INT 35
17134: PUSH
17135: LD_INT 45
17137: PUSH
17138: LD_INT 46
17140: PUSH
17141: LD_INT 47
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 48
17152: PUSH
17153: LD_INT 49
17155: PUSH
17156: LD_INT 50
17158: PUSH
17159: LD_INT 20
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// if MCF_Lab ( side ) then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL 11690 0 1
17183: IFFALSE 17422
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL 11690 0 1
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: CALL_OW 461
17203: PUSH
17204: LD_INT 2
17206: EQUAL
17207: IFFALSE 17346
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17209: LD_VAR 0 1
17213: PPUSH
17214: CALL 11690 0 1
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PPUSH
17223: LD_VAR 0 2
17227: PPUSH
17228: CALL 17518 0 2
17232: IFFALSE 17259
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11690 0 1
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 124
17257: GO 17346
// if MCF_Lab ( side ) > 1 then
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11690 0 1
17268: PUSH
17269: LD_INT 1
17271: GREATER
17272: IFFALSE 17346
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17274: LD_VAR 0 1
17278: PPUSH
17279: CALL 11690 0 1
17283: PUSH
17284: LD_INT 2
17286: ARRAY
17287: PPUSH
17288: CALL_OW 461
17292: PUSH
17293: LD_INT 2
17295: EQUAL
17296: IFFALSE 17346
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17298: LD_VAR 0 1
17302: PPUSH
17303: CALL 11690 0 1
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_VAR 0 2
17316: PPUSH
17317: CALL 17518 0 2
17321: IFFALSE 17346
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17323: LD_VAR 0 1
17327: PPUSH
17328: CALL 11690 0 1
17332: PUSH
17333: LD_INT 2
17335: ARRAY
17336: PPUSH
17337: LD_VAR 0 2
17341: PPUSH
17342: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 4
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: LIST
17367: LIST
17368: IN
17369: IFFALSE 17422
// begin for lab in MCF_Lab ( side ) do
17371: LD_ADDR_VAR 0 6
17375: PUSH
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 11690 0 1
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17420
// if BuildingStatus ( lab ) = bs_need_ape then
17389: LD_VAR 0 6
17393: PPUSH
17394: CALL_OW 461
17398: PUSH
17399: LD_INT 10
17401: EQUAL
17402: IFFALSE 17418
// MCL_ResTame ( side , lab ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL 17643 0 2
17418: GO 17386
17420: POP
17421: POP
// end ; end ; end ;
17422: LD_VAR 0 3
17426: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17427: LD_INT 0
17429: PPUSH
17430: PPUSH
// tmp := [ ] ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// if not lab then
17438: LD_VAR 0 1
17442: NOT
17443: IFFALSE 17455
// result := false else
17445: LD_ADDR_VAR 0 2
17449: PUSH
17450: LD_INT 0
17452: ST_TO_ADDR
17453: GO 17513
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17455: LD_ADDR_VAR 0 3
17459: PUSH
17460: LD_VAR 0 3
17464: PUSH
17465: LD_VAR 0 1
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 268
17477: ADD
17478: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_VAR 0 3
17488: PUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: LD_INT 2
17496: PPUSH
17497: CALL_OW 268
17501: ADD
17502: ST_TO_ADDR
// result := tmp ;
17503: LD_ADDR_VAR 0 2
17507: PUSH
17508: LD_VAR 0 3
17512: ST_TO_ADDR
// end ; end ;
17513: LD_VAR 0 2
17517: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 35
17530: PUSH
17531: LD_INT 45
17533: PUSH
17534: LD_INT 46
17536: PUSH
17537: LD_INT 47
17539: PUSH
17540: LD_INT 1
17542: PUSH
17543: LD_INT 2
17545: PUSH
17546: LD_INT 48
17548: PUSH
17549: LD_INT 49
17551: PUSH
17552: LD_INT 50
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: ST_TO_ADDR
// if lab then
17570: LD_VAR 0 1
17574: IFFALSE 17630
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17576: LD_VAR 0 2
17580: PUSH
17581: LD_VAR 0 5
17585: IN
17586: PUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: CALL_OW 481
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: CALL 17427 0 1
17606: IN
17607: OR
17608: IFFALSE 17620
// result := true else
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
17618: GO 17628
// result := false ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 0
17627: ST_TO_ADDR
// end else
17628: GO 17638
// result := false ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_INT 0
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 3
17642: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17643: LD_INT 0
17645: PPUSH
17646: PPUSH
17647: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17648: LD_ADDR_VAR 0 4
17652: PUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_INT 171
17660: PPUSH
17661: EMPTY
17662: PPUSH
17663: CALL 12354 0 3
17667: ST_TO_ADDR
// if not ape then
17668: LD_VAR 0 4
17672: NOT
17673: IFFALSE 17705
// if MCF_Ape ( side ) then
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 12064 0 1
17684: IFFALSE 17705
// ape := MCF_Ape ( side ) [ 1 ] ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12064 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: ST_TO_ADDR
// if ape then
17705: LD_VAR 0 4
17709: IFFALSE 17760
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17711: LD_VAR 0 4
17715: PUSH
17716: LD_INT 1
17718: ARRAY
17719: PPUSH
17720: CALL_OW 310
17724: PUSH
17725: LD_VAR 0 4
17729: PUSH
17730: LD_INT 1
17732: ARRAY
17733: PPUSH
17734: CALL_OW 310
17738: PUSH
17739: LD_VAR 0 2
17743: NONEQUAL
17744: AND
17745: IFFALSE 17760
// ComExitBuilding ( ape [ 1 ] ) ;
17747: LD_VAR 0 4
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 122
// if not lab then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17771
// exit else
17767: GO 17919
17769: GO 17879
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 4
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL 12354 0 3
17793: PUSH
17794: LD_INT 0
17796: EQUAL
17797: PUSH
17798: LD_VAR 0 2
17802: PPUSH
17803: CALL_OW 313
17807: PUSH
17808: LD_INT 6
17810: EQUAL
17811: AND
17812: IFFALSE 17879
// begin tmp := UnitsInside ( lab ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 313
17828: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17829: LD_VAR 0 5
17833: PUSH
17834: LD_VAR 0 5
17838: ARRAY
17839: PPUSH
17840: LD_INT 16
17842: PPUSH
17843: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17847: LD_VAR 0 5
17851: PUSH
17852: LD_VAR 0 5
17856: ARRAY
17857: PPUSH
17858: CALL_OW 310
17862: IFFALSE 17879
// ComExitBuilding ( tmp [ tmp ] ) ;
17864: LD_VAR 0 5
17868: PUSH
17869: LD_VAR 0 5
17873: ARRAY
17874: PPUSH
17875: CALL_OW 122
// end ; if ape then
17879: LD_VAR 0 4
17883: IFFALSE 17919
// if not IsInUnit ( ape [ 1 ] ) then
17885: LD_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: ARRAY
17893: PPUSH
17894: CALL_OW 310
17898: NOT
17899: IFFALSE 17919
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: LD_VAR 0 2
17914: PPUSH
17915: CALL_OW 120
// end ;
17919: LD_VAR 0 3
17923: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17924: LD_INT 0
17926: PPUSH
17927: PPUSH
17928: PPUSH
// result := false ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: LD_INT 0
17936: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PPUSH
17947: CALL 18034 0 1
17951: ST_TO_ADDR
// if techs then
17952: LD_VAR 0 3
17956: IFFALSE 17986
// if techs [ 2 ] then
17958: LD_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: ARRAY
17966: IFFALSE 17978
// result := true else
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ST_TO_ADDR
17976: GO 17986
// result := false ;
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 2
17990: RET
// export function MCL_Start ( side ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// if MCL_GetTechList ( side ) then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL 18034 0 1
18004: IFFALSE 18029
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18034 0 1
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL 17121 0 2
// end ;
18029: LD_VAR 0 2
18033: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18034: LD_INT 0
18036: PPUSH
18037: PPUSH
18038: PPUSH
// if MREG_ToRes then
18039: LD_EXP 50
18043: IFFALSE 18128
// for i = 1 to MREG_ToRes do
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_EXP 50
18059: PUSH
18060: FOR_TO
18061: IFFALSE 18126
// if MREG_ToRes [ i ] [ 1 ] = side then
18063: LD_EXP 50
18067: PUSH
18068: LD_VAR 0 3
18072: ARRAY
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PUSH
18078: LD_VAR 0 1
18082: EQUAL
18083: IFFALSE 18124
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18085: LD_ADDR_VAR 0 4
18089: PUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: LD_VAR 0 4
18099: PUSH
18100: LD_INT 1
18102: PLUS
18103: PPUSH
18104: LD_EXP 50
18108: PUSH
18109: LD_VAR 0 3
18113: ARRAY
18114: PUSH
18115: LD_INT 2
18117: ARRAY
18118: PPUSH
18119: CALL_OW 1
18123: ST_TO_ADDR
// end ;
18124: GO 18060
18126: POP
18127: POP
// result := techs ;
18128: LD_ADDR_VAR 0 2
18132: PUSH
18133: LD_VAR 0 4
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18143: LD_INT 0
18145: PPUSH
18146: PPUSH
// for i = 1 to tech_list do
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: DOUBLE
18153: LD_INT 1
18155: DEC
18156: ST_TO_ADDR
18157: LD_VAR 0 2
18161: PUSH
18162: FOR_TO
18163: IFFALSE 18217
// if not tech_list [ i ] = 20 then
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 4
18174: ARRAY
18175: PUSH
18176: LD_INT 20
18178: EQUAL
18179: NOT
18180: IFFALSE 18215
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: LD_VAR 0 2
18201: PUSH
18202: LD_VAR 0 4
18206: ARRAY
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL 41960 0 4
18214: ST_TO_ADDR
18215: GO 18162
18217: POP
18218: POP
// result := true ;
18219: LD_ADDR_VAR 0 3
18223: PUSH
18224: LD_INT 1
18226: ST_TO_ADDR
// end ;
18227: LD_VAR 0 3
18231: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// for i = MREG_ToRes downto 1 do
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: DOUBLE
18242: LD_EXP 50
18246: INC
18247: ST_TO_ADDR
18248: LD_INT 1
18250: PUSH
18251: FOR_DOWNTO
18252: IFFALSE 18298
// if MREG_ToRes [ i ] [ 1 ] = side then
18254: LD_EXP 50
18258: PUSH
18259: LD_VAR 0 3
18263: ARRAY
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_VAR 0 1
18273: EQUAL
18274: IFFALSE 18296
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18276: LD_ADDR_EXP 50
18280: PUSH
18281: LD_EXP 50
18285: PPUSH
18286: LD_VAR 0 3
18290: PPUSH
18291: CALL_OW 3
18295: ST_TO_ADDR
18296: GO 18251
18298: POP
18299: POP
// result := true ;
18300: LD_ADDR_VAR 0 2
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// end ;
18308: LD_VAR 0 2
18312: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18313: LD_INT 0
18315: PPUSH
// result := GetTechProgress ( side , tech ) ;
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 326
18335: ST_TO_ADDR
// end ;
18336: LD_VAR 0 3
18340: RET
// export function MCL_Require ( tech ) ; begin
18341: LD_INT 0
18343: PPUSH
// result := GetTechTechsReq ( tech ) ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL_OW 480
18358: ST_TO_ADDR
// end ; end_of_file
18359: LD_VAR 0 2
18363: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
18368: PPUSH
// uc_side := 0 ;
18369: LD_ADDR_OWVAR 20
18373: PUSH
18374: LD_INT 0
18376: ST_TO_ADDR
// uc_nation := 0 ;
18377: LD_ADDR_OWVAR 21
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// for i = 1 to n do
18385: LD_ADDR_VAR 0 5
18389: PUSH
18390: DOUBLE
18391: LD_INT 1
18393: DEC
18394: ST_TO_ADDR
18395: LD_VAR 0 2
18399: PUSH
18400: FOR_TO
18401: IFFALSE 18546
// begin hc_importance := 0 ;
18403: LD_ADDR_OWVAR 32
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// hc_gallery :=  ;
18411: LD_ADDR_OWVAR 33
18415: PUSH
18416: LD_STRING 
18418: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18419: LD_ADDR_OWVAR 35
18423: PUSH
18424: LD_VAR 0 3
18428: PUSH
18429: LD_INT 20
18431: MINUS
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_INT 20
18440: PLUS
18441: PPUSH
18442: CALL_OW 12
18446: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18447: LD_ADDR_OWVAR 31
18451: PUSH
18452: LD_INT 0
18454: PPUSH
18455: LD_INT 2
18457: PPUSH
18458: CALL_OW 12
18462: PUSH
18463: LD_INT 0
18465: PUSH
18466: LD_INT 0
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18478: LD_ADDR_OWVAR 30
18482: PUSH
18483: LD_INT 0
18485: PUSH
18486: LD_INT 0
18488: PUSH
18489: LD_INT 0
18491: PUSH
18492: LD_INT 0
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// hc_name :=  ;
18501: LD_ADDR_OWVAR 26
18505: PUSH
18506: LD_STRING 
18508: ST_TO_ADDR
// hc_class := class_apeman ;
18509: LD_ADDR_OWVAR 28
18513: PUSH
18514: LD_INT 12
18516: ST_TO_ADDR
// ape := CreateHuman ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: CALL_OW 44
18526: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18527: LD_VAR 0 6
18531: PPUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: LD_INT 0
18539: PPUSH
18540: CALL_OW 49
// end ;
18544: GO 18400
18546: POP
18547: POP
// end ;
18548: LD_VAR 0 4
18552: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18553: LD_INT 0
18555: PPUSH
18556: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 12064 0 1
18566: PUSH
18567: LD_EXP 37
18571: PUSH
18572: LD_VAR 0 1
18576: ARRAY
18577: GREATEREQUAL
18578: IFFALSE 18755
// begin if GetTag ( unit ) = 17 then
18580: LD_VAR 0 2
18584: PPUSH
18585: CALL_OW 110
18589: PUSH
18590: LD_INT 17
18592: EQUAL
18593: IFFALSE 18753
// begin SetTag ( unit , 0 ) ;
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_INT 0
18602: PPUSH
18603: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL 11690 0 1
18616: PUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL 18034 0 1
18626: NOT
18627: AND
18628: IFFALSE 18653
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18630: LD_VAR 0 2
18634: PPUSH
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 11690 0 1
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18653: LD_VAR 0 1
18657: PPUSH
18658: CALL 11690 0 1
18662: NOT
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 30
18671: PUSH
18672: LD_INT 1
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL 11651 0 2
18683: AND
18684: IFFALSE 18753
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18686: LD_VAR 0 2
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL 11651 0 2
18710: PUSH
18711: LD_INT 1
18713: ARRAY
18714: PPUSH
18715: CALL_OW 250
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 11651 0 2
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: CALL_OW 251
18748: PPUSH
18749: CALL_OW 111
// end ; end else
18753: GO 18939
// if GetClass ( unit ) <> 4 then
18755: LD_VAR 0 2
18759: PPUSH
18760: CALL_OW 257
18764: PUSH
18765: LD_INT 4
18767: NONEQUAL
18768: IFFALSE 18774
// exit else
18770: GO 18939
18772: GO 18939
// if GetTag ( unit ) = 0 then
18774: LD_VAR 0 2
18778: PPUSH
18779: CALL_OW 110
18783: PUSH
18784: LD_INT 0
18786: EQUAL
18787: IFFALSE 18803
// SetTag ( unit , 17 ) else
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 17
18796: PPUSH
18797: CALL_OW 109
18801: GO 18939
// begin if IsInUnit ( unit ) then
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18823
// ComExitBuilding ( unit ) ;
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 122
// Wait ( 1 ) ;
18823: LD_INT 1
18825: PPUSH
18826: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18830: LD_ADDR_VAR 0 4
18834: PUSH
18835: LD_INT 22
18837: PUSH
18838: LD_INT 0
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 25
18847: PUSH
18848: LD_INT 12
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PPUSH
18859: CALL_OW 69
18863: PPUSH
18864: LD_VAR 0 2
18868: PPUSH
18869: CALL_OW 74
18873: ST_TO_ADDR
// if not ape then
18874: LD_VAR 0 4
18878: NOT
18879: IFFALSE 18885
// exit else
18881: GO 18939
18883: GO 18894
// ComHold ( ape ) ;
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 140
// if not HasTask ( unit ) then
18894: LD_VAR 0 2
18898: PPUSH
18899: CALL_OW 314
18903: NOT
18904: IFFALSE 18937
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18906: LD_VAR 0 2
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: CALL_OW 250
18920: PPUSH
18921: LD_VAR 0 4
18925: PPUSH
18926: CALL_OW 251
18930: PPUSH
18931: CALL_OW 131
18935: GO 18939
// exit ;
18937: GO 18939
// end ; end ;
18939: LD_VAR 0 3
18943: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18944: LD_INT 0
18946: PPUSH
18947: PPUSH
18948: PPUSH
18949: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18950: LD_ADDR_VAR 0 4
18954: PUSH
18955: LD_EXP 38
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18966: LD_ADDR_VAR 0 5
18970: PUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: LD_STRING normal
18978: PPUSH
18979: CALL 12148 0 2
18983: ST_TO_ADDR
// if apes then
18984: LD_VAR 0 5
18988: IFFALSE 19216
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18990: LD_INT 2
18992: PPUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 321
19002: PUSH
19003: LD_INT 2
19005: EQUAL
19006: PUSH
19007: LD_VAR 0 4
19011: PUSH
19012: LD_INT 2
19014: ARRAY
19015: PUSH
19016: LD_INT 1
19018: EQUAL
19019: AND
19020: PUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: LD_STRING engineer
19028: PPUSH
19029: CALL 12148 0 2
19033: PUSH
19034: LD_INT 3
19036: LESS
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 1
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11651 0 2
19058: AND
19059: IFFALSE 19113
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 1
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11651 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end else
19111: GO 19216
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19113: LD_INT 11
19115: PPUSH
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 321
19125: PUSH
19126: LD_INT 2
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: LD_INT 1
19137: ARRAY
19138: PUSH
19139: LD_INT 1
19141: EQUAL
19142: AND
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_INT 30
19151: PUSH
19152: LD_INT 5
19154: PUSH
19155: EMPTY
19156: LIST
19157: LIST
19158: PPUSH
19159: CALL 11651 0 2
19163: AND
19164: IFFALSE 19216
// begin for i in apes do
19166: LD_ADDR_VAR 0 3
19170: PUSH
19171: LD_VAR 0 5
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19214
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 5
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11651 0 2
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: CALL_OW 120
// end ;
19212: GO 19176
19214: POP
19215: POP
// end ; end ; end ; end_of_file
19216: LD_VAR 0 2
19220: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 257
19234: PUSH
19235: LD_INT 4
19237: EQUAL
19238: NOT
19239: PUSH
19240: LD_VAR 0 2
19244: NOT
19245: OR
19246: IFFALSE 19252
// exit else
19248: GO 19286
19250: GO 19286
// if not GetTag ( unit ) = 4 then
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 110
19261: PUSH
19262: LD_INT 4
19264: EQUAL
19265: NOT
19266: IFFALSE 19272
// exit else
19268: GO 19286
19270: GO 19286
// ComHeal ( unit , target ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL_OW 128
// end ;
19286: LD_VAR 0 3
19290: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19291: LD_INT 0
19293: PPUSH
19294: PPUSH
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
19299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19300: LD_ADDR_VAR 0 5
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_VAR 0 1
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 1
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 55
19332: PUSH
19333: EMPTY
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 3
19342: PUSH
19343: LD_INT 54
19345: PUSH
19346: EMPTY
19347: LIST
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 3
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 1000
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_INT 30
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 11651 0 2
19406: ST_TO_ADDR
// r := [ ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: EMPTY
19413: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19414: LD_VAR 0 1
19418: PPUSH
19419: LD_INT 5
19421: PPUSH
19422: EMPTY
19423: PPUSH
19424: CALL 12354 0 3
19428: IFFALSE 19484
// for j in MCF_Tag ( side , 5 , [ ] ) do
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: LD_INT 5
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL 12354 0 3
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19482
// if GetLives ( j ) = 1000 then
19453: LD_VAR 0 4
19457: PPUSH
19458: CALL_OW 256
19462: PUSH
19463: LD_INT 1000
19465: EQUAL
19466: IFFALSE 19480
// SetTag ( j , 0 ) ;
19468: LD_VAR 0 4
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL_OW 109
19480: GO 19450
19482: POP
19483: POP
// if tmp then
19484: LD_VAR 0 5
19488: IFFALSE 19817
// begin r := [ tmp [ 1 ] ] ;
19490: LD_ADDR_VAR 0 6
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_INT 1
19502: ARRAY
19503: PUSH
19504: EMPTY
19505: LIST
19506: ST_TO_ADDR
// for i = 2 to tmp do
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: DOUBLE
19513: LD_INT 2
19515: DEC
19516: ST_TO_ADDR
19517: LD_VAR 0 5
19521: PUSH
19522: FOR_TO
19523: IFFALSE 19815
// begin m := false ;
19525: LD_ADDR_VAR 0 7
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// if d then
19533: LD_VAR 0 8
19537: IFFALSE 19692
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19539: LD_VAR 0 5
19543: PUSH
19544: LD_VAR 0 3
19548: ARRAY
19549: PPUSH
19550: CALL_OW 256
19554: PUSH
19555: LD_INT 650
19557: LESS
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: PPUSH
19570: LD_VAR 0 8
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: CALL_OW 250
19583: PPUSH
19584: LD_VAR 0 8
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: CALL_OW 251
19597: PPUSH
19598: CALL_OW 297
19602: PUSH
19603: LD_INT 10
19605: GREATER
19606: AND
19607: IFFALSE 19692
// begin if not GetTag ( tmp [ i ] ) = 5 then
19609: LD_VAR 0 5
19613: PUSH
19614: LD_VAR 0 3
19618: ARRAY
19619: PPUSH
19620: CALL_OW 110
19624: PUSH
19625: LD_INT 5
19627: EQUAL
19628: NOT
19629: IFFALSE 19649
// SetTag ( tmp [ i ] , 5 ) ;
19631: LD_VAR 0 5
19635: PUSH
19636: LD_VAR 0 3
19640: ARRAY
19641: PPUSH
19642: LD_INT 5
19644: PPUSH
19645: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: LD_VAR 0 8
19664: PUSH
19665: LD_INT 1
19667: ARRAY
19668: PPUSH
19669: CALL_OW 250
19673: PPUSH
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 1
19681: ARRAY
19682: PPUSH
19683: CALL_OW 251
19687: PPUSH
19688: CALL_OW 111
// end ; for j = 1 to r do
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_VAR 0 6
19706: PUSH
19707: FOR_TO
19708: IFFALSE 19782
// if GetLives ( tmp [ i ] ) < r [ j ] then
19710: LD_VAR 0 5
19714: PUSH
19715: LD_VAR 0 3
19719: ARRAY
19720: PPUSH
19721: CALL_OW 256
19725: PUSH
19726: LD_VAR 0 6
19730: PUSH
19731: LD_VAR 0 4
19735: ARRAY
19736: LESS
19737: IFFALSE 19780
// begin r := Insert ( r , j , tmp [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 6
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 5
19758: PUSH
19759: LD_VAR 0 3
19763: ARRAY
19764: PPUSH
19765: CALL_OW 2
19769: ST_TO_ADDR
// m := true ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// break ;
19778: GO 19782
// end ;
19780: GO 19707
19782: POP
19783: POP
// if not m then
19784: LD_VAR 0 7
19788: NOT
19789: IFFALSE 19813
// r := r ^ tmp [ i ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_VAR 0 6
19800: PUSH
19801: LD_VAR 0 5
19805: PUSH
19806: LD_VAR 0 3
19810: ARRAY
19811: ADD
19812: ST_TO_ADDR
// end ;
19813: GO 19522
19815: POP
19816: POP
// end ; result := r end ; end_of_file
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: LD_VAR 0 6
19826: ST_TO_ADDR
19827: LD_VAR 0 2
19831: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19832: LD_INT 0
19834: PPUSH
19835: PPUSH
19836: PPUSH
// pom := GetBase ( bdepot ) ;
19837: LD_ADDR_VAR 0 3
19841: PUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: CALL_OW 274
19851: ST_TO_ADDR
// sor := [ ] ;
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: EMPTY
19858: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 4
19868: PUSH
19869: LD_VAR 0 3
19873: PPUSH
19874: LD_INT 1
19876: PPUSH
19877: CALL_OW 275
19881: ADD
19882: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_VAR 0 4
19892: PUSH
19893: LD_VAR 0 3
19897: PPUSH
19898: LD_INT 2
19900: PPUSH
19901: CALL_OW 275
19905: ADD
19906: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19907: LD_ADDR_VAR 0 4
19911: PUSH
19912: LD_VAR 0 4
19916: PUSH
19917: LD_VAR 0 3
19921: PPUSH
19922: LD_INT 3
19924: PPUSH
19925: CALL_OW 275
19929: ADD
19930: ST_TO_ADDR
// result := sor ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_VAR 0 4
19940: ST_TO_ADDR
// end ;
19941: LD_VAR 0 2
19945: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19946: LD_INT 0
19948: PPUSH
19949: PPUSH
// while ( coord_list ) do
19950: LD_VAR 0 3
19954: IFFALSE 20128
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19956: LD_ADDR_EXP 46
19960: PUSH
19961: LD_EXP 46
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_VAR 0 3
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 3
20001: ARRAY
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PPUSH
20008: CALL 41960 0 4
20012: ST_TO_ADDR
// if weapon_list then
20013: LD_VAR 0 4
20017: IFFALSE 20088
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20019: LD_ADDR_EXP 43
20023: PUSH
20024: LD_EXP 43
20028: PPUSH
20029: LD_VAR 0 1
20033: PPUSH
20034: LD_VAR 0 4
20038: PUSH
20039: LD_INT 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 3
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_VAR 0 3
20056: PUSH
20057: LD_INT 2
20059: ARRAY
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL 41960 0 4
20069: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20070: LD_ADDR_VAR 0 4
20074: PUSH
20075: LD_VAR 0 4
20079: PPUSH
20080: LD_INT 1
20082: PPUSH
20083: CALL_OW 3
20087: ST_TO_ADDR
// end ; for i = 1 to 3 do
20088: LD_ADDR_VAR 0 6
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20124
// coord_list := Delete ( coord_list , 1 ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_VAR 0 3
20113: PPUSH
20114: LD_INT 1
20116: PPUSH
20117: CALL_OW 3
20121: ST_TO_ADDR
20122: GO 20101
20124: POP
20125: POP
// end ;
20126: GO 19950
// result := true ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// end ;
20136: LD_VAR 0 5
20140: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20141: LD_INT 0
20143: PPUSH
20144: PPUSH
// if not weapon_list then
20145: LD_VAR 0 3
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20269
// while ( coord_list ) do
20154: LD_VAR 0 2
20158: IFFALSE 20269
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20160: LD_ADDR_EXP 43
20164: PUSH
20165: LD_EXP 43
20169: PPUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 1
20182: ARRAY
20183: PPUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: PUSH
20193: LD_VAR 0 2
20197: PUSH
20198: LD_INT 2
20200: ARRAY
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL 41960 0 4
20210: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_VAR 0 3
20220: PPUSH
20221: LD_INT 1
20223: PPUSH
20224: CALL_OW 3
20228: ST_TO_ADDR
// for i = 1 to 2 do
20229: LD_ADDR_VAR 0 5
20233: PUSH
20234: DOUBLE
20235: LD_INT 1
20237: DEC
20238: ST_TO_ADDR
20239: LD_INT 2
20241: PUSH
20242: FOR_TO
20243: IFFALSE 20265
// coord_list := Delete ( coord_list , 1 ) ;
20245: LD_ADDR_VAR 0 2
20249: PUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: LD_INT 1
20257: PPUSH
20258: CALL_OW 3
20262: ST_TO_ADDR
20263: GO 20242
20265: POP
20266: POP
// end ;
20267: GO 20154
// end ;
20269: LD_VAR 0 4
20273: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// while ( coord_list ) do
20278: LD_VAR 0 2
20282: IFFALSE 20437
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: PPUSH
20293: LD_VAR 0 2
20297: PUSH
20298: LD_INT 2
20300: ARRAY
20301: PPUSH
20302: CALL_OW 428
20306: IFFALSE 20397
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 2
20321: PUSH
20322: LD_INT 2
20324: ARRAY
20325: PPUSH
20326: CALL_OW 428
20330: PPUSH
20331: CALL_OW 266
20335: PUSH
20336: LD_INT 31
20338: PUSH
20339: LD_INT 32
20341: PUSH
20342: LD_INT 33
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: LIST
20349: IN
20350: IFFALSE 20397
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20352: LD_ADDR_EXP 52
20356: PUSH
20357: LD_EXP 52
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: LD_VAR 0 2
20371: PUSH
20372: LD_INT 1
20374: ARRAY
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 2
20383: ARRAY
20384: PPUSH
20385: CALL_OW 428
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL 41960 0 4
20396: ST_TO_ADDR
// for i = 1 to 3 do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_INT 3
20409: PUSH
20410: FOR_TO
20411: IFFALSE 20433
// coord_list := Delete ( coord_list , 1 ) ;
20413: LD_ADDR_VAR 0 2
20417: PUSH
20418: LD_VAR 0 2
20422: PPUSH
20423: LD_INT 1
20425: PPUSH
20426: CALL_OW 3
20430: ST_TO_ADDR
20431: GO 20410
20433: POP
20434: POP
// end ;
20435: GO 20278
// result := true ;
20437: LD_ADDR_VAR 0 3
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 3
20449: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20450: LD_INT 0
20452: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20453: LD_ADDR_EXP 46
20457: PUSH
20458: LD_EXP 46
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_INT 0
20470: PPUSH
20471: LD_VAR 0 2
20475: PPUSH
20476: CALL 41960 0 4
20480: ST_TO_ADDR
// end ;
20481: LD_VAR 0 3
20485: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20486: LD_INT 0
20488: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20489: LD_ADDR_EXP 46
20493: PUSH
20494: LD_EXP 46
20498: PPUSH
20499: LD_VAR 0 1
20503: PPUSH
20504: LD_INT 6
20506: PPUSH
20507: LD_VAR 0 2
20511: PPUSH
20512: CALL 41960 0 4
20516: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20517: LD_ADDR_EXP 49
20521: PUSH
20522: LD_EXP 49
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 3
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL 41960 0 4
20554: ST_TO_ADDR
// end ;
20555: LD_VAR 0 4
20559: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// if ext_list > 5 then
20564: LD_VAR 0 3
20568: PUSH
20569: LD_INT 5
20571: GREATER
20572: IFFALSE 20616
// for i = 6 to ext_list do
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: DOUBLE
20580: LD_INT 6
20582: DEC
20583: ST_TO_ADDR
20584: LD_VAR 0 3
20588: PUSH
20589: FOR_TO
20590: IFFALSE 20614
// ext_list := Delete ( ext_list , ext_list ) ;
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: CALL_OW 3
20611: ST_TO_ADDR
20612: GO 20589
20614: POP
20615: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 3
20652: PPUSH
20653: CALL 9163 0 5
// end ;
20657: LD_VAR 0 4
20661: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
// p := 1 ;
20667: LD_ADDR_VAR 0 6
20671: PUSH
20672: LD_INT 1
20674: ST_TO_ADDR
// if type_list = [ ] then
20675: LD_VAR 0 3
20679: PUSH
20680: EMPTY
20681: EQUAL
20682: IFFALSE 20692
// type_list := b_oil_power ;
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 26
20691: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20692: LD_ADDR_VAR 0 5
20696: PUSH
20697: DOUBLE
20698: LD_INT 1
20700: DEC
20701: ST_TO_ADDR
20702: LD_VAR 0 2
20706: PUSH
20707: LD_INT 3
20709: DIVREAL
20710: PUSH
20711: FOR_TO
20712: IFFALSE 20815
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20714: LD_ADDR_EXP 46
20718: PUSH
20719: LD_EXP 46
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_VAR 0 3
20733: PUSH
20734: LD_INT 1
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 12
20746: ARRAY
20747: PPUSH
20748: LD_VAR 0 2
20752: PUSH
20753: LD_VAR 0 6
20757: ARRAY
20758: PUSH
20759: LD_VAR 0 2
20763: PUSH
20764: LD_VAR 0 6
20768: PUSH
20769: LD_INT 1
20771: PLUS
20772: ARRAY
20773: PUSH
20774: LD_VAR 0 2
20778: PUSH
20779: LD_VAR 0 6
20783: PUSH
20784: LD_INT 2
20786: PLUS
20787: ARRAY
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 41960 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_VAR 0 6
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20711
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 4
20821: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
// if not MREG_Deposit [ side ] then
20828: LD_EXP 61
20832: PUSH
20833: LD_VAR 0 1
20837: ARRAY
20838: NOT
20839: IFFALSE 20843
// exit ;
20841: GO 21020
// p := 1 ;
20843: LD_ADDR_VAR 0 4
20847: PUSH
20848: LD_INT 1
20850: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20851: LD_ADDR_VAR 0 3
20855: PUSH
20856: DOUBLE
20857: LD_INT 1
20859: DEC
20860: ST_TO_ADDR
20861: LD_EXP 61
20865: PUSH
20866: LD_VAR 0 1
20870: ARRAY
20871: PUSH
20872: LD_INT 3
20874: DIVREAL
20875: PUSH
20876: FOR_TO
20877: IFFALSE 21018
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20879: LD_EXP 61
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: PUSH
20895: LD_INT 2
20897: PLUS
20898: ARRAY
20899: PUSH
20900: LD_INT 2
20902: EQUAL
20903: IFFALSE 20915
// b := b_oil_mine else
20905: LD_ADDR_VAR 0 5
20909: PUSH
20910: LD_INT 29
20912: ST_TO_ADDR
20913: GO 20923
// b := b_siberite_mine ;
20915: LD_ADDR_VAR 0 5
20919: PUSH
20920: LD_INT 30
20922: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: LD_EXP 61
20947: PUSH
20948: LD_VAR 0 1
20952: ARRAY
20953: PUSH
20954: LD_VAR 0 4
20958: ARRAY
20959: PUSH
20960: LD_EXP 61
20964: PUSH
20965: LD_VAR 0 1
20969: ARRAY
20970: PUSH
20971: LD_VAR 0 4
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: ARRAY
20980: PUSH
20981: LD_INT 0
20983: PPUSH
20984: LD_INT 5
20986: PPUSH
20987: CALL_OW 12
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL 41960 0 4
21001: ST_TO_ADDR
// p := p + 3 ;
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: LD_VAR 0 4
21011: PUSH
21012: LD_INT 3
21014: PLUS
21015: ST_TO_ADDR
// end ;
21016: GO 20876
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 2
21024: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21025: LD_INT 0
21027: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21028: LD_ADDR_EXP 46
21032: PUSH
21033: LD_EXP 46
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 4
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: CALL 41960 0 4
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21061: LD_INT 0
21063: PPUSH
// case nation of 1 , us :
21064: LD_VAR 0 2
21068: PUSH
21069: LD_INT 1
21071: DOUBLE
21072: EQUAL
21073: IFTRUE 21083
21075: LD_STRING us
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21114
21083: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21084: LD_ADDR_EXP 46
21088: PUSH
21089: LD_EXP 46
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: LD_INT 36
21101: PPUSH
21102: LD_VAR 0 3
21106: PPUSH
21107: CALL 41960 0 4
21111: ST_TO_ADDR
21112: GO 21165
21114: LD_INT 2
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21128
21120: LD_STRING ar
21122: DOUBLE
21123: EQUAL
21124: IFTRUE 21128
21126: GO 21164
21128: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21129: LD_ADDR_EXP 46
21133: PUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 14
21141: PUSH
21142: LD_INT 2
21144: PUSH
21145: LD_INT 1
21147: PUSH
21148: LD_INT 31
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL 21170 0 2
21161: ST_TO_ADDR
21162: GO 21165
21164: POP
// end ;
21165: LD_VAR 0 4
21169: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21170: LD_INT 0
21172: PPUSH
21173: PPUSH
// for i = 1 to list do
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: DOUBLE
21180: LD_INT 1
21182: DEC
21183: ST_TO_ADDR
21184: LD_VAR 0 2
21188: PUSH
21189: FOR_TO
21190: IFFALSE 21240
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21192: LD_ADDR_EXP 51
21196: PUSH
21197: LD_EXP 51
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_EXP 51
21211: PUSH
21212: LD_VAR 0 1
21216: ARRAY
21217: PUSH
21218: LD_INT 1
21220: PLUS
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_VAR 0 4
21231: ARRAY
21232: PPUSH
21233: CALL 31130 0 4
21237: ST_TO_ADDR
21238: GO 21189
21240: POP
21241: POP
// end ;
21242: LD_VAR 0 3
21246: RET
// export function MCS_GetVehicleList ( side ) ; begin
21247: LD_INT 0
21249: PPUSH
// result := MREG_ToConstruct [ side ] ;
21250: LD_ADDR_VAR 0 2
21254: PUSH
21255: LD_EXP 51
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: ST_TO_ADDR
// end ;
21266: LD_VAR 0 2
21270: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21271: LD_INT 0
21273: PPUSH
21274: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21275: LD_ADDR_EXP 58
21279: PUSH
21280: LD_EXP 58
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: LD_VAR 0 2
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// end ;
21300: LD_VAR 0 3
21304: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21305: LD_INT 0
21307: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21308: LD_ADDR_EXP 37
21312: PUSH
21313: LD_EXP 37
21317: PPUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// end ;
21333: LD_VAR 0 3
21337: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21338: LD_INT 0
21340: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21341: LD_ADDR_EXP 38
21345: PUSH
21346: LD_EXP 38
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 3
21370: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21374: LD_ADDR_EXP 60
21378: PUSH
21379: LD_EXP 60
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL 31130 0 4
21401: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21402: LD_ADDR_EXP 60
21406: PUSH
21407: LD_EXP 60
21411: PPUSH
21412: LD_VAR 0 1
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: LD_VAR 0 3
21424: PPUSH
21425: CALL 31130 0 4
21429: ST_TO_ADDR
// end ;
21430: LD_VAR 0 4
21434: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21435: LD_INT 0
21437: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21438: LD_ADDR_EXP 72
21442: PUSH
21443: LD_EXP 72
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21461: LD_ADDR_EXP 72
21465: PUSH
21466: LD_EXP 72
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: LD_VAR 0 2
21478: PPUSH
21479: CALL_OW 1
21483: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21484: LD_ADDR_EXP 72
21488: PUSH
21489: LD_EXP 72
21493: PPUSH
21494: LD_INT 3
21496: PPUSH
21497: LD_VAR 0 3
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// end ;
21507: LD_VAR 0 4
21511: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
// if not side or not list then
21517: LD_VAR 0 1
21521: NOT
21522: PUSH
21523: LD_VAR 0 2
21527: NOT
21528: OR
21529: IFFALSE 21533
// exit ;
21531: GO 21701
// SetTech ( 20 , side , state_researched ) ;
21533: LD_INT 20
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_INT 2
21543: PPUSH
21544: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21548: LD_ADDR_EXP 61
21552: PUSH
21553: LD_EXP 61
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: CALL_OW 2
21572: ST_TO_ADDR
// p := 1 ;
21573: LD_ADDR_VAR 0 5
21577: PUSH
21578: LD_INT 1
21580: ST_TO_ADDR
// for i = 1 to list / 3 do
21581: LD_ADDR_VAR 0 4
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_VAR 0 2
21595: PUSH
21596: LD_INT 3
21598: DIVREAL
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21699
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21603: LD_VAR 0 2
21607: PUSH
21608: LD_VAR 0 5
21612: ARRAY
21613: PPUSH
21614: LD_VAR 0 2
21618: PUSH
21619: LD_VAR 0 5
21623: PUSH
21624: LD_INT 1
21626: PLUS
21627: ARRAY
21628: PPUSH
21629: LD_VAR 0 2
21633: PUSH
21634: LD_VAR 0 5
21638: PUSH
21639: LD_INT 2
21641: PLUS
21642: ARRAY
21643: PPUSH
21644: CALL 22403 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21648: LD_VAR 0 2
21652: PUSH
21653: LD_VAR 0 5
21657: ARRAY
21658: PPUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 5
21668: PUSH
21669: LD_INT 1
21671: PLUS
21672: ARRAY
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL_OW 441
// p := p + 3 ;
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: PLUS
21696: ST_TO_ADDR
// end ;
21697: GO 21600
21699: POP
21700: POP
// end ;
21701: LD_VAR 0 3
21705: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
// if nat = nation_arabian then
21710: LD_VAR 0 2
21714: PUSH
21715: LD_INT 2
21717: EQUAL
21718: IFFALSE 21724
// exit else
21720: GO 21796
21722: GO 21782
// if nat = nation_american then
21724: LD_VAR 0 2
21728: PUSH
21729: LD_INT 1
21731: EQUAL
21732: IFFALSE 21759
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21734: LD_ADDR_VAR 0 4
21738: PUSH
21739: LD_INT 4
21741: PUSH
21742: LD_INT 3
21744: PUSH
21745: LD_INT 1
21747: PUSH
21748: LD_INT 8
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
21757: GO 21782
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21759: LD_ADDR_VAR 0 4
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 48
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21782: LD_VAR 0 1
21786: PPUSH
21787: LD_VAR 0 4
21791: PPUSH
21792: CALL 21170 0 2
// end ;
21796: LD_VAR 0 3
21800: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21801: LD_INT 0
21803: PPUSH
21804: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21805: LD_ADDR_EXP 63
21809: PUSH
21810: LD_EXP 63
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: LD_INT 1
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: CALL 31130 0 4
21832: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21833: LD_ADDR_EXP 64
21837: PUSH
21838: LD_EXP 64
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: LD_INT 1
21850: PPUSH
21851: LD_VAR 0 2
21855: PPUSH
21856: CALL 31130 0 4
21860: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21861: LD_ADDR_EXP 65
21865: PUSH
21866: LD_EXP 65
21870: PPUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_VAR 0 3
21883: PPUSH
21884: CALL 31130 0 4
21888: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21889: LD_ADDR_EXP 66
21893: PUSH
21894: LD_EXP 66
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_INT 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL 31130 0 4
21916: ST_TO_ADDR
// while squad do
21917: LD_VAR 0 5
21921: IFFALSE 22014
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_VAR 0 5
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PUSH
21937: LD_VAR 0 5
21941: PUSH
21942: LD_INT 2
21944: ARRAY
21945: PUSH
21946: LD_VAR 0 5
21950: PUSH
21951: LD_INT 3
21953: ARRAY
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: PPUSH
21970: CALL 21170 0 2
// for i = 1 to 4 do
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: DOUBLE
21980: LD_INT 1
21982: DEC
21983: ST_TO_ADDR
21984: LD_INT 4
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22010
// squad := Delete ( squad , 1 ) ;
21990: LD_ADDR_VAR 0 5
21994: PUSH
21995: LD_VAR 0 5
21999: PPUSH
22000: LD_INT 1
22002: PPUSH
22003: CALL_OW 3
22007: ST_TO_ADDR
22008: GO 21987
22010: POP
22011: POP
// end ;
22012: GO 21917
// end ;
22014: LD_VAR 0 6
22018: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22019: LD_INT 0
22021: PPUSH
22022: PPUSH
// for i = 1 to squad do
22023: LD_ADDR_VAR 0 4
22027: PUSH
22028: DOUBLE
22029: LD_INT 1
22031: DEC
22032: ST_TO_ADDR
22033: LD_VAR 0 2
22037: PUSH
22038: FOR_TO
22039: IFFALSE 22089
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22041: LD_ADDR_EXP 69
22045: PUSH
22046: LD_EXP 69
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_EXP 69
22060: PUSH
22061: LD_VAR 0 1
22065: ARRAY
22066: PUSH
22067: LD_INT 1
22069: PLUS
22070: PPUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 4
22080: ARRAY
22081: PPUSH
22082: CALL 31130 0 4
22086: ST_TO_ADDR
22087: GO 22038
22089: POP
22090: POP
// while squad do
22091: LD_VAR 0 2
22095: IFFALSE 22188
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22097: LD_VAR 0 1
22101: PPUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: PUSH
22111: LD_VAR 0 2
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PUSH
22120: LD_VAR 0 2
22124: PUSH
22125: LD_INT 3
22127: ARRAY
22128: PUSH
22129: LD_VAR 0 2
22133: PUSH
22134: LD_INT 4
22136: ARRAY
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL 21170 0 2
// for i = 1 to 4 do
22148: LD_ADDR_VAR 0 4
22152: PUSH
22153: DOUBLE
22154: LD_INT 1
22156: DEC
22157: ST_TO_ADDR
22158: LD_INT 4
22160: PUSH
22161: FOR_TO
22162: IFFALSE 22184
// squad := Delete ( squad , 1 ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_INT 1
22176: PPUSH
22177: CALL_OW 3
22181: ST_TO_ADDR
22182: GO 22161
22184: POP
22185: POP
// end ;
22186: GO 22091
// end ;
22188: LD_VAR 0 3
22192: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22193: LD_INT 0
22195: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22196: LD_ADDR_EXP 62
22200: PUSH
22201: LD_EXP 62
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 2
22218: PPUSH
22219: CALL 31130 0 4
22223: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22224: LD_ADDR_EXP 62
22228: PUSH
22229: LD_EXP 62
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: LD_VAR 0 3
22246: PPUSH
22247: CALL 31130 0 4
22251: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22252: LD_ADDR_EXP 62
22256: PUSH
22257: LD_EXP 62
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: LD_INT 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: CALL 31130 0 4
22279: ST_TO_ADDR
// end ; end_of_file
22280: LD_VAR 0 5
22284: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22285: LD_INT 0
22287: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22288: LD_ADDR_EXP 42
22292: PUSH
22293: LD_EXP 42
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_INT 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: CALL 31130 0 4
22315: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL 11786 0 2
22327: PUSH
22328: LD_INT 1
22330: ARRAY
22331: PPUSH
22332: CALL_OW 248
22336: PUSH
22337: LD_INT 1
22339: EQUAL
22340: IFFALSE 22371
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: PUSH
22356: LD_INT 14
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL 21170 0 2
22369: GO 22398
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 24
22378: PUSH
22379: LD_INT 1
22381: PUSH
22382: LD_INT 1
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: PPUSH
22394: CALL 21170 0 2
// end ;
22398: LD_VAR 0 3
22402: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22403: LD_INT 0
22405: PPUSH
// CreateDepositXY ( x , y , t ) ;
22406: LD_VAR 0 1
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: LD_VAR 0 3
22420: PPUSH
22421: CALL_OW 62
// end ;
22425: LD_VAR 0 4
22429: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22430: LD_INT 0
22432: PPUSH
22433: PPUSH
// c := 1 ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 1
22441: ST_TO_ADDR
// case color of red :
22442: LD_VAR 0 3
22446: PUSH
22447: LD_STRING red
22449: DOUBLE
22450: EQUAL
22451: IFTRUE 22455
22453: GO 22466
22455: POP
// c = 1 ; dark-green :
22456: LD_ADDR_VAR 0 5
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
22464: GO 22752
22466: LD_STRING dark-green
22468: DOUBLE
22469: EQUAL
22470: IFTRUE 22474
22472: GO 22485
22474: POP
// c = 2 ; purple :
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
22483: GO 22752
22485: LD_STRING purple
22487: DOUBLE
22488: EQUAL
22489: IFTRUE 22493
22491: GO 22504
22493: POP
// c = 3 ; aqua :
22494: LD_ADDR_VAR 0 5
22498: PUSH
22499: LD_INT 3
22501: ST_TO_ADDR
22502: GO 22752
22504: LD_STRING aqua
22506: DOUBLE
22507: EQUAL
22508: IFTRUE 22512
22510: GO 22523
22512: POP
// c = 4 ; grey :
22513: LD_ADDR_VAR 0 5
22517: PUSH
22518: LD_INT 4
22520: ST_TO_ADDR
22521: GO 22752
22523: LD_STRING grey
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22542
22531: POP
// c = 5 ; lime :
22532: LD_ADDR_VAR 0 5
22536: PUSH
22537: LD_INT 5
22539: ST_TO_ADDR
22540: GO 22752
22542: LD_STRING lime
22544: DOUBLE
22545: EQUAL
22546: IFTRUE 22550
22548: GO 22561
22550: POP
// c = 6 ; tan :
22551: LD_ADDR_VAR 0 5
22555: PUSH
22556: LD_INT 6
22558: ST_TO_ADDR
22559: GO 22752
22561: LD_STRING tan
22563: DOUBLE
22564: EQUAL
22565: IFTRUE 22569
22567: GO 22580
22569: POP
// c = 7 ; pink :
22570: LD_ADDR_VAR 0 5
22574: PUSH
22575: LD_INT 7
22577: ST_TO_ADDR
22578: GO 22752
22580: LD_STRING pink
22582: DOUBLE
22583: EQUAL
22584: IFTRUE 22588
22586: GO 22599
22588: POP
// c = 8 ; green :
22589: LD_ADDR_VAR 0 5
22593: PUSH
22594: LD_INT 8
22596: ST_TO_ADDR
22597: GO 22752
22599: LD_STRING green
22601: DOUBLE
22602: EQUAL
22603: IFTRUE 22607
22605: GO 22618
22607: POP
// c = 9 ; blue :
22608: LD_ADDR_VAR 0 5
22612: PUSH
22613: LD_INT 9
22615: ST_TO_ADDR
22616: GO 22752
22618: LD_STRING blue
22620: DOUBLE
22621: EQUAL
22622: IFTRUE 22626
22624: GO 22637
22626: POP
// c = 10 ; yellow :
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_INT 10
22634: ST_TO_ADDR
22635: GO 22752
22637: LD_STRING yellow
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22656
22645: POP
// c = 11 ; brown :
22646: LD_ADDR_VAR 0 5
22650: PUSH
22651: LD_INT 11
22653: ST_TO_ADDR
22654: GO 22752
22656: LD_STRING brown
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22675
22664: POP
// c = 12 ; black :
22665: LD_ADDR_VAR 0 5
22669: PUSH
22670: LD_INT 12
22672: ST_TO_ADDR
22673: GO 22752
22675: LD_STRING black
22677: DOUBLE
22678: EQUAL
22679: IFTRUE 22683
22681: GO 22694
22683: POP
// c = 13 ; aqua2 :
22684: LD_ADDR_VAR 0 5
22688: PUSH
22689: LD_INT 13
22691: ST_TO_ADDR
22692: GO 22752
22694: LD_STRING aqua2
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22713
22702: POP
// c = 14 ; orange :
22703: LD_ADDR_VAR 0 5
22707: PUSH
22708: LD_INT 14
22710: ST_TO_ADDR
22711: GO 22752
22713: LD_STRING orange
22715: DOUBLE
22716: EQUAL
22717: IFTRUE 22721
22719: GO 22732
22721: POP
// c = 15 ; white :
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 15
22729: ST_TO_ADDR
22730: GO 22752
22732: LD_STRING white
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22751
22740: POP
// c = 16 ; end ;
22741: LD_ADDR_VAR 0 5
22745: PUSH
22746: LD_INT 16
22748: ST_TO_ADDR
22749: GO 22752
22751: POP
// if HexInfo ( x , y ) = 0 then
22752: LD_VAR 0 1
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: CALL_OW 428
22766: PUSH
22767: LD_INT 0
22769: EQUAL
22770: IFFALSE 22794
// PlaceEnvironment ( x , y , 58 , c ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: LD_INT 58
22784: PPUSH
22785: LD_VAR 0 5
22789: PPUSH
22790: CALL_OW 349
// end ;
22794: LD_VAR 0 4
22798: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22799: LD_INT 0
22801: PPUSH
// RemoveEnvironment ( x , y ) ;
22802: LD_VAR 0 1
22806: PPUSH
22807: LD_VAR 0 2
22811: PPUSH
22812: CALL_OW 347
// end ;
22816: LD_VAR 0 3
22820: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22821: LD_INT 0
22823: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22824: LD_ADDR_VAR 0 5
22828: PUSH
22829: LD_INT 81
22831: PUSH
22832: LD_VAR 0 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 92
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: LD_VAR 0 3
22853: PUSH
22854: LD_VAR 0 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PPUSH
22869: CALL_OW 69
22873: ST_TO_ADDR
// end ;
22874: LD_VAR 0 5
22878: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22879: LD_INT 0
22881: PPUSH
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22886: LD_VAR 0 1
22890: PPUSH
22891: LD_INT 81
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 255
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PPUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 74
22922: PPUSH
22923: CALL_OW 119
// dir := GetDir ( un ) ;
22927: LD_ADDR_VAR 0 4
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: CALL_OW 254
22941: ST_TO_ADDR
// dir := dir - 3 ;
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: LD_VAR 0 4
22951: PUSH
22952: LD_INT 3
22954: MINUS
22955: ST_TO_ADDR
// if dir < 0 then
22956: LD_VAR 0 4
22960: PUSH
22961: LD_INT 0
22963: LESS
22964: IFFALSE 22980
// dir := dir + 6 ;
22966: LD_ADDR_VAR 0 4
22970: PUSH
22971: LD_VAR 0 4
22975: PUSH
22976: LD_INT 6
22978: PLUS
22979: ST_TO_ADDR
// while true do
22980: LD_INT 1
22982: IFFALSE 23479
// begin coord_dist := 3 ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 3
22991: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: LD_VAR 0 3
23016: PPUSH
23017: CALL_OW 272
23021: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23022: LD_ADDR_VAR 0 6
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 251
23036: PPUSH
23037: LD_VAR 0 4
23041: PPUSH
23042: LD_VAR 0 3
23046: PPUSH
23047: CALL_OW 273
23051: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23052: LD_VAR 0 1
23056: PPUSH
23057: CALL_OW 255
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: CALL_OW 250
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 251
23081: PPUSH
23082: LD_INT 14
23084: PPUSH
23085: CALL 22821 0 4
23089: PUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: LD_VAR 0 6
23099: PPUSH
23100: CALL_OW 351
23104: OR
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 488
23120: PUSH
23121: LD_INT 0
23123: EQUAL
23124: OR
23125: PUSH
23126: LD_VAR 0 5
23130: PPUSH
23131: LD_VAR 0 6
23135: PPUSH
23136: CALL_OW 546
23140: PUSH
23141: LD_INT 1
23143: EQUAL
23144: OR
23145: PUSH
23146: LD_VAR 0 5
23150: PPUSH
23151: LD_VAR 0 6
23155: PPUSH
23156: CALL_OW 428
23160: PUSH
23161: LD_INT 0
23163: NONEQUAL
23164: OR
23165: IFFALSE 23393
// begin repeat begin Wait ( 0 0$0.3 ) ;
23167: LD_INT 10
23169: PPUSH
23170: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: LD_VAR 0 3
23183: PUSH
23184: LD_INT 1
23186: PLUS
23187: ST_TO_ADDR
// dir := dir + 1 ;
23188: LD_ADDR_VAR 0 4
23192: PUSH
23193: LD_VAR 0 4
23197: PUSH
23198: LD_INT 1
23200: PLUS
23201: ST_TO_ADDR
// if dir > 5 then
23202: LD_VAR 0 4
23206: PUSH
23207: LD_INT 5
23209: GREATER
23210: IFFALSE 23220
// dir = 0 ;
23212: LD_ADDR_VAR 0 4
23216: PUSH
23217: LD_INT 0
23219: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23220: LD_ADDR_VAR 0 5
23224: PUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: CALL_OW 250
23234: PPUSH
23235: LD_VAR 0 4
23239: PPUSH
23240: LD_VAR 0 3
23244: PPUSH
23245: CALL_OW 272
23249: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23250: LD_ADDR_VAR 0 6
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 251
23264: PPUSH
23265: LD_VAR 0 4
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: CALL_OW 273
23279: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 255
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: CALL_OW 250
23299: PPUSH
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 251
23309: PPUSH
23310: LD_INT 14
23312: PPUSH
23313: CALL 22821 0 4
23317: NOT
23318: PUSH
23319: LD_VAR 0 5
23323: PPUSH
23324: LD_VAR 0 6
23328: PPUSH
23329: CALL_OW 351
23333: NOT
23334: AND
23335: PUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 488
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 546
23366: PUSH
23367: LD_INT 0
23369: EQUAL
23370: AND
23371: PUSH
23372: LD_VAR 0 5
23376: PPUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 428
23386: PUSH
23387: LD_INT 0
23389: EQUAL
23390: AND
23391: IFFALSE 23167
// end ; ComMoveXY ( un , x , y ) ;
23393: LD_VAR 0 1
23397: PPUSH
23398: LD_VAR 0 5
23402: PPUSH
23403: LD_VAR 0 6
23407: PPUSH
23408: CALL_OW 111
// Wait ( 0 0$1 ) ;
23412: LD_INT 35
23414: PPUSH
23415: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23419: LD_VAR 0 1
23423: PPUSH
23424: LD_INT 81
23426: PUSH
23427: LD_VAR 0 1
23431: PPUSH
23432: CALL_OW 255
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_VAR 0 1
23450: PPUSH
23451: CALL_OW 74
23455: PPUSH
23456: CALL_OW 296
23460: PUSH
23461: LD_INT 14
23463: GREATEREQUAL
23464: IFFALSE 23477
// begin ComStop ( un ) ;
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 141
// break ;
23475: GO 23479
// end ; end ;
23477: GO 22980
// end ;
23479: LD_VAR 0 2
23483: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// x := GetX ( unit ) ;
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 250
23508: ST_TO_ADDR
// y := GetY ( unit ) ;
23509: LD_ADDR_VAR 0 4
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 251
23523: ST_TO_ADDR
// i := 0 ;
23524: LD_ADDR_VAR 0 8
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 81
23539: PUSH
23540: LD_VAR 0 1
23544: PPUSH
23545: CALL_OW 255
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 69
23558: PPUSH
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 74
23568: PPUSH
23569: CALL_OW 119
// dir := GetDir ( unit ) ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: CALL_OW 254
23587: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23588: LD_ADDR_VAR 0 9
23592: PUSH
23593: LD_INT 0
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 12
23603: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23604: LD_INT 10
23606: PPUSH
23607: CALL_OW 67
// if mode then
23611: LD_VAR 0 9
23615: IFFALSE 23633
// dir := dir + 1 else
23617: LD_ADDR_VAR 0 7
23621: PUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_INT 1
23629: PLUS
23630: ST_TO_ADDR
23631: GO 23647
// dir := dir - 1 ;
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: MINUS
23646: ST_TO_ADDR
// if ( dir < 0 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 0
23654: LESS
23655: IFFALSE 23665
// dir := 5 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 5
23664: ST_TO_ADDR
// if ( dir > 5 ) then
23665: LD_VAR 0 7
23669: PUSH
23670: LD_INT 5
23672: GREATER
23673: IFFALSE 23683
// dir := 0 ;
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: LD_INT 0
23682: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23683: LD_ADDR_VAR 0 5
23687: PUSH
23688: LD_VAR 0 3
23692: PPUSH
23693: LD_VAR 0 7
23697: PPUSH
23698: LD_INT 4
23700: PPUSH
23701: CALL_OW 272
23705: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23706: LD_ADDR_VAR 0 6
23710: PUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: LD_VAR 0 7
23720: PPUSH
23721: LD_INT 4
23723: PPUSH
23724: CALL_OW 273
23728: ST_TO_ADDR
// i := i + 1 ;
23729: LD_ADDR_VAR 0 8
23733: PUSH
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 1
23741: PLUS
23742: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23743: LD_VAR 0 1
23747: PPUSH
23748: CALL_OW 255
23752: PPUSH
23753: LD_VAR 0 5
23757: PPUSH
23758: LD_VAR 0 6
23762: PPUSH
23763: LD_INT 14
23765: PPUSH
23766: CALL 22821 0 4
23770: PUSH
23771: LD_INT 0
23773: EQUAL
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_VAR 0 6
23784: PPUSH
23785: CALL_OW 546
23789: PUSH
23790: LD_INT 0
23792: EQUAL
23793: AND
23794: PUSH
23795: LD_VAR 0 5
23799: PPUSH
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 428
23809: PUSH
23810: LD_INT 0
23812: EQUAL
23813: AND
23814: IFFALSE 23818
// break ;
23816: GO 23828
// end until i > 4 ;
23818: LD_VAR 0 8
23822: PUSH
23823: LD_INT 4
23825: GREATER
23826: IFFALSE 23604
// if x2 and y2 then
23828: LD_VAR 0 5
23832: PUSH
23833: LD_VAR 0 6
23837: AND
23838: IFFALSE 23861
// result := [ x2 , y2 ] else
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 5
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: ST_TO_ADDR
23859: GO 23890
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 250
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: CALL_OW 251
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// end ;
23890: LD_VAR 0 2
23894: RET
// export function MCT_Hex ( x , y ) ; begin
23895: LD_INT 0
23897: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL_OW 546
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 428
23932: PUSH
23933: EMPTY
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 3
23944: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23960: LD_ADDR_VAR 0 10
23964: PUSH
23965: LD_EXP 60
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PUSH
23976: LD_INT 1
23978: ARRAY
23979: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: LD_EXP 60
23989: PUSH
23990: LD_VAR 0 1
23994: ARRAY
23995: PUSH
23996: LD_INT 2
23998: ARRAY
23999: ST_TO_ADDR
// collectors := [ ] ;
24000: LD_ADDR_VAR 0 12
24004: PUSH
24005: EMPTY
24006: ST_TO_ADDR
// is_cargo := false ;
24007: LD_ADDR_VAR 0 13
24011: PUSH
24012: LD_INT 0
24014: ST_TO_ADDR
// if isTest then
24015: LD_EXP 1
24019: IFFALSE 24025
// TimerStart ( ) ;
24021: CALL_OW 548
// if MCF_Cargo ( side ) then
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL 12002 0 1
24034: IFFALSE 24061
// begin collectors := MCF_Cargo ( side ) ;
24036: LD_ADDR_VAR 0 12
24040: PUSH
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12002 0 1
24050: ST_TO_ADDR
// is_cargo := true ;
24051: LD_ADDR_VAR 0 13
24055: PUSH
24056: LD_INT 1
24058: ST_TO_ADDR
// end else
24059: GO 24210
// begin if MCF_ApeSpec ( side , engineer ) then
24061: LD_VAR 0 1
24065: PPUSH
24066: LD_STRING engineer
24068: PPUSH
24069: CALL 12148 0 2
24073: IFFALSE 24093
// collectors := MCF_ApeSpec ( side , engineer ) ;
24075: LD_ADDR_VAR 0 12
24079: PUSH
24080: LD_VAR 0 1
24084: PPUSH
24085: LD_STRING engineer
24087: PPUSH
24088: CALL 12148 0 2
24092: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24093: LD_VAR 0 1
24097: PPUSH
24098: LD_INT 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL 11734 0 3
24107: IFFALSE 24210
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL 11734 0 3
24128: ST_TO_ADDR
// if z > 5 then
24129: LD_VAR 0 7
24133: PUSH
24134: LD_INT 5
24136: GREATER
24137: IFFALSE 24149
// t1 := 5 else
24139: LD_ADDR_VAR 0 8
24143: PUSH
24144: LD_INT 5
24146: ST_TO_ADDR
24147: GO 24159
// t1 := z ;
24149: LD_ADDR_VAR 0 8
24153: PUSH
24154: LD_VAR 0 7
24158: ST_TO_ADDR
// for t2 = 1 to t1 do
24159: LD_ADDR_VAR 0 9
24163: PUSH
24164: DOUBLE
24165: LD_INT 1
24167: DEC
24168: ST_TO_ADDR
24169: LD_VAR 0 8
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24208
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24177: LD_ADDR_VAR 0 12
24181: PUSH
24182: LD_VAR 0 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: LD_VAR 0 7
24194: PUSH
24195: LD_VAR 0 9
24199: ARRAY
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
24206: GO 24174
24208: POP
24209: POP
// end ; end ; if not mode then
24210: LD_VAR 0 10
24214: NOT
24215: IFFALSE 24221
// exit else
24217: GO 24480
24219: GO 24480
// begin if collectors then
24221: LD_VAR 0 12
24225: IFFALSE 24480
// for i in areas do
24227: LD_ADDR_VAR 0 3
24231: PUSH
24232: LD_VAR 0 11
24236: PUSH
24237: FOR_IN
24238: IFFALSE 24478
// if GetListOfCratesInArea ( i ) then
24240: LD_VAR 0 3
24244: PPUSH
24245: CALL_OW 435
24249: IFFALSE 24476
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24251: LD_ADDR_VAR 0 5
24255: PUSH
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24270: LD_ADDR_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: PPUSH
24280: CALL_OW 435
24284: PUSH
24285: LD_INT 2
24287: ARRAY
24288: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24289: LD_VAR 0 13
24293: PUSH
24294: LD_VAR 0 12
24298: PUSH
24299: LD_INT 1
24301: ARRAY
24302: PPUSH
24303: CALL_OW 110
24307: PUSH
24308: LD_INT 0
24310: EQUAL
24311: AND
24312: IFFALSE 24374
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24314: LD_VAR 0 12
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 314
24327: NOT
24328: PUSH
24329: LD_VAR 0 12
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: CALL_OW 110
24342: PUSH
24343: LD_INT 0
24345: EQUAL
24346: AND
24347: IFFALSE 24372
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24349: LD_VAR 0 12
24353: PUSH
24354: LD_INT 1
24356: ARRAY
24357: PPUSH
24358: LD_VAR 0 5
24362: PPUSH
24363: LD_VAR 0 6
24367: PPUSH
24368: CALL_OW 117
// end ; end else
24372: GO 24460
// begin for j = 1 to collectors do
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: DOUBLE
24380: LD_INT 1
24382: DEC
24383: ST_TO_ADDR
24384: LD_VAR 0 12
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24458
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24392: LD_VAR 0 12
24396: PUSH
24397: LD_VAR 0 4
24401: ARRAY
24402: PPUSH
24403: CALL_OW 314
24407: NOT
24408: PUSH
24409: LD_VAR 0 12
24413: PUSH
24414: LD_VAR 0 4
24418: ARRAY
24419: PPUSH
24420: CALL_OW 110
24424: PUSH
24425: LD_INT 0
24427: EQUAL
24428: AND
24429: IFFALSE 24456
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24431: LD_VAR 0 12
24435: PUSH
24436: LD_VAR 0 4
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 5
24446: PPUSH
24447: LD_VAR 0 6
24451: PPUSH
24452: CALL 24851 0 3
// end ;
24456: GO 24389
24458: POP
24459: POP
// end ; if isTest then
24460: LD_EXP 1
24464: IFFALSE 24476
// begin debug_time := TimerEnd ( ) ;
24466: LD_ADDR_VAR 0 14
24470: PUSH
24471: CALL_OW 549
24475: ST_TO_ADDR
// end ; end ;
24476: GO 24237
24478: POP
24479: POP
// end ; end ;
24480: LD_VAR 0 2
24484: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24485: LD_INT 0
24487: PPUSH
24488: PPUSH
24489: PPUSH
24490: PPUSH
24491: PPUSH
24492: PPUSH
// if not area then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24504
// exit else
24500: GO 24766
24502: GO 24766
// if tick mod interval = 0 and Prob ( percent ) then
24504: LD_OWVAR 1
24508: PUSH
24509: LD_VAR 0 4
24513: MOD
24514: PUSH
24515: LD_INT 0
24517: EQUAL
24518: PUSH
24519: LD_VAR 0 3
24523: PPUSH
24524: CALL_OW 13
24528: AND
24529: IFFALSE 24766
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24531: LD_VAR 0 1
24535: PPUSH
24536: CALL_OW 435
24540: PUSH
24541: LD_VAR 0 5
24545: LESS
24546: PUSH
24547: LD_VAR 0 5
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: OR
24556: IFFALSE 24766
// begin Randomize ;
24558: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24562: LD_ADDR_VAR 0 7
24566: PUSH
24567: LD_INT 1
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 12
24579: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24580: LD_ADDR_VAR 0 9
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 517
24597: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24598: LD_ADDR_VAR 0 8
24602: PUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PUSH
24611: LD_INT 1
24613: ARRAY
24614: PPUSH
24615: CALL_OW 12
24619: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24620: LD_VAR 0 9
24624: PUSH
24625: LD_INT 1
24627: ARRAY
24628: PUSH
24629: LD_VAR 0 8
24633: ARRAY
24634: PPUSH
24635: LD_VAR 0 9
24639: PUSH
24640: LD_INT 2
24642: ARRAY
24643: PUSH
24644: LD_VAR 0 8
24648: ARRAY
24649: PPUSH
24650: CALL_OW 428
24654: PUSH
24655: LD_INT 0
24657: GREATER
24658: PUSH
24659: LD_VAR 0 9
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PUSH
24668: LD_VAR 0 8
24672: ARRAY
24673: PPUSH
24674: LD_VAR 0 9
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PUSH
24683: LD_VAR 0 8
24687: ARRAY
24688: PPUSH
24689: CALL_OW 284
24693: PUSH
24694: LD_INT 0
24696: GREATER
24697: AND
24698: IFFALSE 24724
// c := Rand ( 1 , tmp [ 1 ] ) ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 1
24707: PPUSH
24708: LD_VAR 0 9
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: CALL_OW 12
24721: ST_TO_ADDR
24722: GO 24620
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24724: LD_VAR 0 7
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PUSH
24738: LD_VAR 0 8
24742: ARRAY
24743: PPUSH
24744: LD_VAR 0 9
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PUSH
24753: LD_VAR 0 8
24757: ARRAY
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 54
// end ; end ; end ;
24766: LD_VAR 0 6
24770: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24771: LD_INT 0
24773: PPUSH
24774: PPUSH
// if not MREG_Crates then
24775: LD_EXP 34
24779: NOT
24780: IFFALSE 24784
// exit ;
24782: GO 24846
// for i = MREG_Crates downto 1 do
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: DOUBLE
24790: LD_EXP 34
24794: INC
24795: ST_TO_ADDR
24796: LD_INT 1
24798: PUSH
24799: FOR_DOWNTO
24800: IFFALSE 24844
// if MREG_Crates [ i ] [ 3 ] = 0 then
24802: LD_EXP 34
24806: PUSH
24807: LD_VAR 0 2
24811: ARRAY
24812: PUSH
24813: LD_INT 3
24815: ARRAY
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24842
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24822: LD_ADDR_EXP 34
24826: PUSH
24827: LD_EXP 34
24831: PPUSH
24832: LD_VAR 0 2
24836: PPUSH
24837: CALL_OW 3
24841: ST_TO_ADDR
24842: GO 24799
24844: POP
24845: POP
// end ;
24846: LD_VAR 0 1
24850: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not unit then
24857: LD_VAR 0 1
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25001
// if HasTask ( unit ) or not CanCarry ( unit ) then
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 314
24875: PUSH
24876: LD_VAR 0 1
24880: PPUSH
24881: CALL_OW 280
24885: NOT
24886: OR
24887: IFFALSE 24891
// exit ;
24889: GO 25001
// side := GetSide ( unit ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: CALL_OW 255
24905: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24906: LD_ADDR_VAR 0 7
24910: PUSH
24911: LD_VAR 0 6
24915: PPUSH
24916: LD_INT 30
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PPUSH
24926: CALL 11651 0 2
24930: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24931: LD_VAR 0 1
24935: PPUSH
24936: CALL_OW 281
24940: PUSH
24941: LD_VAR 0 7
24945: NOT
24946: OR
24947: IFFALSE 24953
// exit else
24949: GO 25001
24951: GO 25001
// if GetResourceAmountXY ( x , y ) then
24953: LD_VAR 0 2
24957: PPUSH
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 284
24967: IFFALSE 24999
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_VAR 0 2
24978: PPUSH
24979: LD_VAR 0 3
24983: PPUSH
24984: LD_VAR 0 7
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: CALL 32061 0 4
// end else
24997: GO 25001
// exit ;
24999: GO 25001
// end ;
25001: LD_VAR 0 4
25005: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25006: LD_INT 0
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
// result := [ ] ;
25013: LD_ADDR_VAR 0 2
25017: PUSH
25018: EMPTY
25019: ST_TO_ADDR
// p := 1 ;
25020: LD_ADDR_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_EXP 63
25042: PUSH
25043: LD_VAR 0 1
25047: ARRAY
25048: PUSH
25049: LD_INT 1
25051: ARRAY
25052: PUSH
25053: LD_INT 2
25055: DIVREAL
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25182
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25060: LD_ADDR_VAR 0 5
25064: PUSH
25065: LD_INT 81
25067: PUSH
25068: LD_VAR 0 1
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 92
25079: PUSH
25080: LD_EXP 63
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PUSH
25095: LD_VAR 0 4
25099: ARRAY
25100: PUSH
25101: LD_EXP 63
25105: PUSH
25106: LD_VAR 0 1
25110: ARRAY
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_INT 1
25123: PLUS
25124: ARRAY
25125: PUSH
25126: LD_INT 12
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: ST_TO_ADDR
// if tmp then
25144: LD_VAR 0 5
25148: IFFALSE 25166
// result := result union tmp ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_VAR 0 5
25164: UNION
25165: ST_TO_ADDR
// p := p + 2 ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 2
25178: PLUS
25179: ST_TO_ADDR
// end ;
25180: GO 25057
25182: POP
25183: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25184: LD_EXP 64
25188: PUSH
25189: LD_VAR 0 1
25193: ARRAY
25194: PPUSH
25195: LD_INT 81
25197: PUSH
25198: LD_VAR 0 1
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PPUSH
25207: CALL_OW 70
25211: IFFALSE 25252
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25213: LD_ADDR_VAR 0 2
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_EXP 64
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_INT 81
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PPUSH
25246: CALL_OW 70
25250: UNION
25251: ST_TO_ADDR
// end ; end_of_file
25252: LD_VAR 0 2
25256: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
// pom := GetBase ( fac ) ;
25262: LD_ADDR_VAR 0 5
25266: PUSH
25267: LD_VAR 0 1
25271: PPUSH
25272: CALL_OW 274
25276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25277: LD_ADDR_VAR 0 4
25281: PUSH
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: LD_VAR 0 2
25295: PUSH
25296: LD_INT 2
25298: ARRAY
25299: PPUSH
25300: LD_VAR 0 2
25304: PUSH
25305: LD_INT 3
25307: ARRAY
25308: PPUSH
25309: LD_VAR 0 2
25313: PUSH
25314: LD_INT 4
25316: ARRAY
25317: PPUSH
25318: CALL_OW 449
25322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25323: LD_ADDR_VAR 0 3
25327: PUSH
25328: LD_VAR 0 5
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: CALL_OW 275
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: GREATEREQUAL
25350: PUSH
25351: LD_VAR 0 5
25355: PPUSH
25356: LD_INT 2
25358: PPUSH
25359: CALL_OW 275
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_INT 2
25371: ARRAY
25372: GREATEREQUAL
25373: AND
25374: PUSH
25375: LD_VAR 0 5
25379: PPUSH
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 275
25387: PUSH
25388: LD_VAR 0 4
25392: PUSH
25393: LD_INT 3
25395: ARRAY
25396: GREATEREQUAL
25397: AND
25398: ST_TO_ADDR
// end ;
25399: LD_VAR 0 3
25403: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25404: LD_INT 0
25406: PPUSH
25407: PPUSH
25408: PPUSH
// result := false ;
25409: LD_ADDR_VAR 0 3
25413: PUSH
25414: LD_INT 0
25416: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25417: LD_ADDR_VAR 0 4
25421: PUSH
25422: LD_EXP 51
25426: PUSH
25427: LD_VAR 0 1
25431: ARRAY
25432: ST_TO_ADDR
// if tmp then
25433: LD_VAR 0 4
25437: IFFALSE 25491
// for i = 1 to tmp do
25439: LD_ADDR_VAR 0 5
25443: PUSH
25444: DOUBLE
25445: LD_INT 1
25447: DEC
25448: ST_TO_ADDR
25449: LD_VAR 0 4
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25489
// if component = tmp [ i ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 4
25466: PUSH
25467: LD_VAR 0 5
25471: ARRAY
25472: EQUAL
25473: IFFALSE 25487
// begin result := true ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_INT 1
25482: ST_TO_ADDR
// exit ;
25483: POP
25484: POP
25485: GO 25491
// end ;
25487: GO 25454
25489: POP
25490: POP
// end ;
25491: LD_VAR 0 3
25495: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25496: LD_INT 0
25498: PPUSH
25499: PPUSH
25500: PPUSH
// result := false ;
25501: LD_ADDR_VAR 0 4
25505: PUSH
25506: LD_INT 0
25508: ST_TO_ADDR
// if fac then
25509: LD_VAR 0 2
25513: IFFALSE 25736
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25515: LD_VAR 0 2
25519: PPUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL 25257 0 2
25529: PUSH
25530: LD_VAR 0 2
25534: PPUSH
25535: CALL_OW 461
25539: PUSH
25540: LD_INT 2
25542: EQUAL
25543: AND
25544: PUSH
25545: LD_VAR 0 2
25549: PPUSH
25550: LD_VAR 0 3
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 3
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: LD_VAR 0 3
25572: PUSH
25573: LD_INT 3
25575: ARRAY
25576: PPUSH
25577: LD_VAR 0 3
25581: PUSH
25582: LD_INT 4
25584: ARRAY
25585: PPUSH
25586: CALL_OW 448
25590: AND
25591: IFFALSE 25736
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25593: LD_VAR 0 2
25597: PPUSH
25598: LD_VAR 0 3
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 3
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_INT 3
25623: ARRAY
25624: PPUSH
25625: LD_VAR 0 3
25629: PUSH
25630: LD_INT 4
25632: ARRAY
25633: PPUSH
25634: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_EXP 51
25647: PUSH
25648: LD_VAR 0 1
25652: ARRAY
25653: ST_TO_ADDR
// for i = 4 downto 1 do
25654: LD_ADDR_VAR 0 5
25658: PUSH
25659: DOUBLE
25660: LD_INT 4
25662: INC
25663: ST_TO_ADDR
25664: LD_INT 1
25666: PUSH
25667: FOR_DOWNTO
25668: IFFALSE 25701
// tab := Remove ( tab , list [ i ] , true ) ;
25670: LD_ADDR_VAR 0 6
25674: PUSH
25675: LD_VAR 0 6
25679: PPUSH
25680: LD_VAR 0 3
25684: PUSH
25685: LD_VAR 0 5
25689: ARRAY
25690: PPUSH
25691: LD_INT 1
25693: PPUSH
25694: CALL 31289 0 3
25698: ST_TO_ADDR
25699: GO 25667
25701: POP
25702: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25703: LD_ADDR_EXP 51
25707: PUSH
25708: LD_EXP 51
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_VAR 0 6
25722: PPUSH
25723: CALL_OW 1
25727: ST_TO_ADDR
// result := true ;
25728: LD_ADDR_VAR 0 4
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// end ; end ; end ;
25736: LD_VAR 0 4
25740: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25741: LD_INT 0
25743: PPUSH
25744: PPUSH
// if not veh then
25745: LD_VAR 0 2
25749: NOT
25750: IFFALSE 25754
// exit ;
25752: GO 25928
// if MREG_Parking [ side ] then
25754: LD_EXP 58
25758: PUSH
25759: LD_VAR 0 1
25763: ARRAY
25764: IFFALSE 25928
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25766: LD_VAR 0 2
25770: PPUSH
25771: LD_EXP 58
25775: PUSH
25776: LD_VAR 0 1
25780: ARRAY
25781: PPUSH
25782: CALL_OW 308
25786: NOT
25787: IFFALSE 25928
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_EXP 58
25798: PUSH
25799: LD_VAR 0 1
25803: ARRAY
25804: PPUSH
25805: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25809: LD_VAR 0 2
25813: PPUSH
25814: CALL_OW 263
25818: PUSH
25819: LD_INT 1
25821: EQUAL
25822: IFFALSE 25928
// begin i := GetDriver ( veh ) ;
25824: LD_ADDR_VAR 0 4
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: CALL 31773 0 1
25838: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25846: LD_VAR 0 2
25850: PPUSH
25851: LD_EXP 58
25855: PUSH
25856: LD_VAR 0 1
25860: ARRAY
25861: PPUSH
25862: CALL_OW 308
25866: PUSH
25867: LD_VAR 0 2
25871: PPUSH
25872: CALL_OW 301
25876: OR
25877: IFFALSE 25839
// ComExitVehicle ( i ) ;
25879: LD_VAR 0 4
25883: PPUSH
25884: CALL_OW 121
// Wait ( 1 ) ;
25888: LD_INT 1
25890: PPUSH
25891: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL 11651 0 2
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PPUSH
25924: CALL_OW 180
// end ; end ; end ;
25928: LD_VAR 0 3
25932: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
25937: PPUSH
25938: PPUSH
25939: PPUSH
25940: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25941: LD_VAR 0 1
25945: PPUSH
25946: LD_INT 30
25948: PUSH
25949: LD_INT 3
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL 11651 0 2
25960: IFFALSE 26144
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25962: LD_VAR 0 1
25966: PPUSH
25967: LD_INT 30
25969: PUSH
25970: LD_INT 3
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL 11651 0 2
25981: PUSH
25982: LD_INT 1
25984: ARRAY
25985: PPUSH
25986: CALL_OW 461
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 26144
// begin for i = 1 to MREG_TurretWeapon do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_EXP 43
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26142
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26014: LD_EXP 43
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 1
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 1
26033: EQUAL
26034: IFFALSE 26140
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_EXP 43
26045: PUSH
26046: LD_VAR 0 3
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26056: LD_ADDR_VAR 0 6
26060: PUSH
26061: LD_EXP 43
26065: PUSH
26066: LD_VAR 0 3
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26080: LD_ADDR_VAR 0 7
26084: PUSH
26085: LD_EXP 43
26089: PUSH
26090: LD_VAR 0 3
26094: ARRAY
26095: PUSH
26096: LD_INT 3
26098: ARRAY
26099: PUSH
26100: LD_INT 2
26102: ARRAY
26103: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26104: LD_ADDR_VAR 0 4
26108: PUSH
26109: LD_VAR 0 6
26113: PPUSH
26114: LD_VAR 0 7
26118: PPUSH
26119: CALL_OW 428
26123: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26124: LD_VAR 0 4
26128: PPUSH
26129: LD_VAR 0 5
26133: PPUSH
26134: CALL_OW 148
// break ;
26138: GO 26142
// end ;
26140: GO 26011
26142: POP
26143: POP
// end ; end ;
26144: LD_VAR 0 2
26148: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26149: LD_INT 0
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_INT 32
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL 11651 0 2
26179: ST_TO_ADDR
// if not tmp then
26180: LD_VAR 0 4
26184: NOT
26185: IFFALSE 26191
// exit else
26187: GO 26273
26189: GO 26273
// begin for i = 1 to tmp do
26191: LD_ADDR_VAR 0 3
26195: PUSH
26196: DOUBLE
26197: LD_INT 1
26199: DEC
26200: ST_TO_ADDR
26201: LD_VAR 0 4
26205: PUSH
26206: FOR_TO
26207: IFFALSE 26271
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26209: LD_VAR 0 4
26213: PUSH
26214: LD_VAR 0 3
26218: ARRAY
26219: PPUSH
26220: CALL_OW 261
26224: PUSH
26225: LD_INT 20
26227: LESS
26228: PUSH
26229: LD_VAR 0 4
26233: PUSH
26234: LD_VAR 0 3
26238: ARRAY
26239: PPUSH
26240: CALL_OW 110
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: AND
26249: IFFALSE 26269
// begin SetTag ( tmp [ i ] , 21 ) ;
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 3
26260: ARRAY
26261: PPUSH
26262: LD_INT 21
26264: PPUSH
26265: CALL_OW 109
// end ;
26269: GO 26206
26271: POP
26272: POP
// end ; end ;
26273: LD_VAR 0 2
26277: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26278: LD_INT 0
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
26284: PPUSH
// if not unit then
26285: LD_VAR 0 1
26289: NOT
26290: IFFALSE 26294
// exit ;
26292: GO 26482
// side := GetSide ( unit ) ;
26294: LD_ADDR_VAR 0 3
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 255
26308: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26309: LD_ADDR_VAR 0 5
26313: PUSH
26314: LD_VAR 0 3
26318: PPUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 3
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 30
26344: PUSH
26345: LD_INT 29
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL 11651 0 2
26362: ST_TO_ADDR
// if not b then
26363: LD_VAR 0 5
26367: NOT
26368: IFFALSE 26372
// exit ;
26370: GO 26482
// if GetTag ( unit ) = 21 then
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 110
26381: PUSH
26382: LD_INT 21
26384: EQUAL
26385: IFFALSE 26482
// begin c := NearestUnitToUnit ( b , unit ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_VAR 0 5
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 74
26406: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26407: LD_VAR 0 1
26411: PPUSH
26412: LD_VAR 0 6
26416: PPUSH
26417: CALL_OW 250
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: CALL_OW 251
26431: PPUSH
26432: CALL_OW 297
26436: PUSH
26437: LD_INT 6
26439: GREATER
26440: IFFALSE 26458
// ComMoveUnit ( unit , c ) else
26442: LD_VAR 0 1
26446: PPUSH
26447: LD_VAR 0 6
26451: PPUSH
26452: CALL_OW 112
26456: GO 26482
// begin SetFuel ( unit , 100 ) ;
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_INT 100
26465: PPUSH
26466: CALL_OW 240
// SetTag ( unit , 0 ) ;
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 0
26477: PPUSH
26478: CALL_OW 109
// end ; end ; end ;
26482: LD_VAR 0 2
26486: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26487: LD_INT 0
26489: PPUSH
26490: PPUSH
26491: PPUSH
26492: PPUSH
26493: PPUSH
26494: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26495: LD_ADDR_VAR 0 7
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 33
26507: PUSH
26508: LD_INT 2
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 61
26520: PUSH
26521: EMPTY
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PPUSH
26532: CALL 11651 0 2
26536: ST_TO_ADDR
// if not vehs then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26831
// if nation = 1 then
26546: LD_VAR 0 2
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26724
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26556: LD_VAR 0 1
26560: PPUSH
26561: LD_INT 30
26563: PUSH
26564: LD_INT 36
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PPUSH
26571: CALL 11651 0 2
26575: NOT
26576: IFFALSE 26582
// exit else
26578: GO 26831
26580: GO 26722
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26582: LD_ADDR_VAR 0 5
26586: PUSH
26587: LD_VAR 0 1
26591: PPUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 36
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PPUSH
26602: CALL 11651 0 2
26606: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26607: LD_ADDR_VAR 0 6
26611: PUSH
26612: LD_VAR 0 5
26616: PUSH
26617: LD_INT 1
26619: ARRAY
26620: PPUSH
26621: CALL_OW 313
26625: ST_TO_ADDR
// for i = vehs downto 1 do
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: DOUBLE
26632: LD_VAR 0 7
26636: INC
26637: ST_TO_ADDR
26638: LD_INT 1
26640: PUSH
26641: FOR_DOWNTO
26642: IFFALSE 26720
// begin if not IsControledBy ( vehs [ i ] ) then
26644: LD_VAR 0 7
26648: PUSH
26649: LD_VAR 0 4
26653: ARRAY
26654: PPUSH
26655: CALL_OW 312
26659: NOT
26660: IFFALSE 26718
// begin tmp := MCV_RemoteDriver ( oper ) ;
26662: LD_ADDR_VAR 0 8
26666: PUSH
26667: LD_VAR 0 6
26671: PPUSH
26672: CALL 26836 0 1
26676: ST_TO_ADDR
// if not tmp then
26677: LD_VAR 0 8
26681: NOT
26682: IFFALSE 26690
// exit else
26684: POP
26685: POP
26686: GO 26831
26688: GO 26718
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26690: LD_VAR 0 7
26694: PUSH
26695: LD_VAR 0 4
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: CALL_OW 135
// end ; end ;
26718: GO 26641
26720: POP
26721: POP
// end ; end else
26722: GO 26831
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_INT 34
26731: PUSH
26732: LD_INT 31
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL 11651 0 2
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 26831
26748: GO 26831
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 1
26759: PPUSH
26760: LD_INT 34
26762: PUSH
26763: LD_INT 31
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PPUSH
26770: CALL 11651 0 2
26774: ST_TO_ADDR
// oper := [ ] ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: EMPTY
26781: ST_TO_ADDR
// for i = 1 to ct do
26782: LD_ADDR_VAR 0 4
26786: PUSH
26787: DOUBLE
26788: LD_INT 1
26790: DEC
26791: ST_TO_ADDR
26792: LD_VAR 0 5
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26829
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26800: LD_ADDR_VAR 0 6
26804: PUSH
26805: LD_VAR 0 6
26809: PUSH
26810: LD_VAR 0 5
26814: PUSH
26815: LD_VAR 0 4
26819: ARRAY
26820: PPUSH
26821: CALL 31773 0 1
26825: ADD
26826: ST_TO_ADDR
26827: GO 26797
26829: POP
26830: POP
// end ; end ; end ;
26831: LD_VAR 0 3
26835: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
// if not drivers then
26844: LD_VAR 0 1
26848: NOT
26849: IFFALSE 26855
// exit else
26851: GO 27135
26853: GO 27135
// begin linked := [ ] ;
26855: LD_ADDR_VAR 0 5
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// for i = 1 to drivers do
26862: LD_ADDR_VAR 0 3
26866: PUSH
26867: DOUBLE
26868: LD_INT 1
26870: DEC
26871: ST_TO_ADDR
26872: LD_VAR 0 1
26876: PUSH
26877: FOR_TO
26878: IFFALSE 27123
// begin if CanControl ( drivers [ i ] ) then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_VAR 0 3
26889: ARRAY
26890: PPUSH
26891: CALL 32163 0 1
26895: IFFALSE 27121
// if i > 1 then
26897: LD_VAR 0 3
26901: PUSH
26902: LD_INT 1
26904: GREATER
26905: IFFALSE 27082
// begin m := false ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26915: LD_ADDR_VAR 0 7
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_VAR 0 3
26929: ARRAY
26930: PPUSH
26931: CALL_OW 432
26935: ST_TO_ADDR
// for j = 1 to linked do
26936: LD_ADDR_VAR 0 4
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_VAR 0 5
26950: PUSH
26951: FOR_TO
26952: IFFALSE 27026
// begin if l < linked [ j ] [ 2 ] then
26954: LD_VAR 0 7
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: LD_VAR 0 4
26968: ARRAY
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: LESS
26974: IFFALSE 27024
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: LD_VAR 0 1
26993: PUSH
26994: LD_VAR 0 3
26998: ARRAY
26999: PUSH
27000: LD_VAR 0 7
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 2
27013: ST_TO_ADDR
// m := true ;
27014: LD_ADDR_VAR 0 6
27018: PUSH
27019: LD_INT 1
27021: ST_TO_ADDR
// break ;
27022: GO 27026
// end ; end ;
27024: GO 26951
27026: POP
27027: POP
// if not m then
27028: LD_VAR 0 6
27032: NOT
27033: IFFALSE 27080
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27035: LD_ADDR_VAR 0 5
27039: PUSH
27040: LD_VAR 0 5
27044: PUSH
27045: LD_VAR 0 1
27049: PUSH
27050: LD_VAR 0 3
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: ARRAY
27066: PPUSH
27067: CALL_OW 432
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: EMPTY
27077: LIST
27078: ADD
27079: ST_TO_ADDR
// end else
27080: GO 27121
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27082: LD_ADDR_VAR 0 5
27086: PUSH
27087: LD_VAR 0 1
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: PUSH
27098: LD_VAR 0 1
27102: PUSH
27103: LD_VAR 0 3
27107: ARRAY
27108: PPUSH
27109: CALL_OW 432
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: ST_TO_ADDR
// end ;
27121: GO 26877
27123: POP
27124: POP
// result := linked ;
27125: LD_ADDR_VAR 0 2
27129: PUSH
27130: LD_VAR 0 5
27134: ST_TO_ADDR
// end ; end ;
27135: LD_VAR 0 2
27139: RET
// export function MCV_ToRepair ( unit ) ; begin
27140: LD_INT 0
27142: PPUSH
// if not unit then
27143: LD_VAR 0 1
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27183
// SetTag ( unit , 6 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 6
27159: PPUSH
27160: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27164: LD_VAR 0 1
27168: PPUSH
27169: CALL_OW 255
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL 25741 0 2
// end ;
27183: LD_VAR 0 2
27187: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27192: LD_VAR 0 1
27196: PPUSH
27197: LD_INT 6
27199: PPUSH
27200: EMPTY
27201: PPUSH
27202: CALL 12354 0 3
27206: IFFALSE 27299
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: DOUBLE
27214: LD_VAR 0 1
27218: PPUSH
27219: LD_INT 6
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 12354 0 3
27228: INC
27229: ST_TO_ADDR
27230: LD_INT 1
27232: PUSH
27233: FOR_DOWNTO
27234: IFFALSE 27297
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27236: LD_VAR 0 1
27240: PPUSH
27241: LD_INT 6
27243: PPUSH
27244: EMPTY
27245: PPUSH
27246: CALL 12354 0 3
27250: PUSH
27251: LD_VAR 0 3
27255: ARRAY
27256: PPUSH
27257: CALL_OW 256
27261: PUSH
27262: LD_INT 1000
27264: EQUAL
27265: IFFALSE 27295
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 6
27274: PPUSH
27275: EMPTY
27276: PPUSH
27277: CALL 12354 0 3
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 0
27290: PPUSH
27291: CALL_OW 109
27295: GO 27233
27297: POP
27298: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27299: LD_VAR 0 1
27303: PPUSH
27304: LD_INT 10
27306: PPUSH
27307: EMPTY
27308: PPUSH
27309: CALL 12354 0 3
27313: IFFALSE 27430
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: DOUBLE
27321: LD_VAR 0 1
27325: PPUSH
27326: LD_INT 10
27328: PPUSH
27329: EMPTY
27330: PPUSH
27331: CALL 12354 0 3
27335: INC
27336: ST_TO_ADDR
27337: LD_INT 1
27339: PUSH
27340: FOR_DOWNTO
27341: IFFALSE 27428
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27343: LD_VAR 0 1
27347: PPUSH
27348: LD_INT 10
27350: PPUSH
27351: EMPTY
27352: PPUSH
27353: CALL 12354 0 3
27357: PUSH
27358: LD_VAR 0 3
27362: ARRAY
27363: PPUSH
27364: CALL_OW 302
27368: NOT
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: LD_INT 10
27377: PPUSH
27378: EMPTY
27379: PPUSH
27380: CALL 12354 0 3
27384: PUSH
27385: LD_VAR 0 3
27389: ARRAY
27390: PPUSH
27391: CALL_OW 301
27395: OR
27396: IFFALSE 27426
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27398: LD_VAR 0 1
27402: PPUSH
27403: LD_INT 10
27405: PPUSH
27406: EMPTY
27407: PPUSH
27408: CALL 12354 0 3
27412: PUSH
27413: LD_VAR 0 3
27417: ARRAY
27418: PPUSH
27419: LD_INT 0
27421: PPUSH
27422: CALL_OW 109
27426: GO 27340
27428: POP
27429: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27430: LD_ADDR_VAR 0 3
27434: PUSH
27435: LD_VAR 0 1
27439: PPUSH
27440: EMPTY
27441: PPUSH
27442: CALL 11952 0 2
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 7
27454: PPUSH
27455: EMPTY
27456: PPUSH
27457: CALL 12354 0 3
27461: DIFF
27462: PUSH
27463: FOR_IN
27464: IFFALSE 27508
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27466: LD_VAR 0 3
27470: PPUSH
27471: CALL_OW 256
27475: PUSH
27476: LD_INT 650
27478: LESS
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 110
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: NOT
27494: AND
27495: IFFALSE 27506
// MCV_ToRepair ( i ) ;
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL 27140 0 1
27506: GO 27463
27508: POP
27509: POP
// end ; end_of_file end_of_file
27510: LD_VAR 0 2
27514: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27515: LD_STRING SAILEvent [
27517: PUSH
27518: LD_VAR 0 1
27522: STR
27523: PUSH
27524: LD_STRING ]
27526: STR
27527: PPUSH
27528: CALL 8039 0 1
// if event = 101 and dialog_north then
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 101
27539: EQUAL
27540: PUSH
27541: LD_EXP 6
27545: AND
27546: IFFALSE 27610
// begin dialog_north := false ;
27548: LD_ADDR_EXP 6
27552: PUSH
27553: LD_INT 0
27555: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27556: LD_EXP 5
27560: PPUSH
27561: LD_STRING DS1
27563: PUSH
27564: LD_STRING DS2
27566: PUSH
27567: LD_STRING DS3
27569: PUSH
27570: LD_STRING DS6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PPUSH
27582: LD_INT 4
27584: PPUSH
27585: CALL_OW 12
27589: ARRAY
27590: PPUSH
27591: CALL_OW 94
// Wait ( 4 4$00 ) ;
27595: LD_INT 8400
27597: PPUSH
27598: CALL_OW 67
// dialog_north := true ;
27602: LD_ADDR_EXP 6
27606: PUSH
27607: LD_INT 1
27609: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27610: LD_VAR 0 1
27614: PUSH
27615: LD_INT 102
27617: EQUAL
27618: PUSH
27619: LD_EXP 7
27623: AND
27624: IFFALSE 27684
// begin dialog_south := false ;
27626: LD_ADDR_EXP 7
27630: PUSH
27631: LD_INT 0
27633: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27634: LD_EXP 4
27638: PPUSH
27639: LD_STRING DJ1
27641: PUSH
27642: LD_STRING DJ4
27644: PUSH
27645: LD_STRING DJ6
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PPUSH
27656: LD_INT 3
27658: PPUSH
27659: CALL_OW 12
27663: ARRAY
27664: PPUSH
27665: CALL_OW 94
// Wait ( 4 4$00 ) ;
27669: LD_INT 8400
27671: PPUSH
27672: CALL_OW 67
// dialog_south := true ;
27676: LD_ADDR_EXP 7
27680: PUSH
27681: LD_INT 1
27683: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27684: LD_VAR 0 1
27688: PUSH
27689: LD_INT 104
27691: EQUAL
27692: PUSH
27693: LD_EXP 8
27697: AND
27698: IFFALSE 27720
// begin dialog_popov := false ;
27700: LD_ADDR_EXP 8
27704: PUSH
27705: LD_INT 0
27707: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27708: LD_EXP 24
27712: PPUSH
27713: LD_STRING DR4
27715: PPUSH
27716: CALL_OW 94
// end ; end ;
27720: PPOPN 1
27722: END
// on BuildingStarted ( b , unit ) do var side , i ;
27723: LD_INT 0
27725: PPUSH
27726: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27727: LD_EXP 39
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ARRAY
27742: IFFALSE 27920
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27744: LD_STRING BuildingStarted [side: 
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: CALL_OW 255
27756: STR
27757: PUSH
27758: LD_STRING ; btype: 
27760: STR
27761: PUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 266
27771: STR
27772: PUSH
27773: LD_STRING ; unit: 
27775: STR
27776: PUSH
27777: LD_VAR 0 2
27781: STR
27782: PUSH
27783: LD_STRING ]
27785: STR
27786: PPUSH
27787: CALL 8039 0 1
// side := GetSide ( b ) ;
27791: LD_ADDR_VAR 0 3
27795: PUSH
27796: LD_VAR 0 1
27800: PPUSH
27801: CALL_OW 255
27805: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 21
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PPUSH
27821: CALL 11651 0 2
27825: PUSH
27826: LD_INT 1
27828: EQUAL
27829: IFFALSE 27920
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27831: LD_ADDR_VAR 0 4
27835: PUSH
27836: LD_VAR 0 3
27840: PPUSH
27841: LD_INT 21
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PPUSH
27851: CALL 11651 0 2
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: EMPTY
27865: PPUSH
27866: CALL 11734 0 3
27870: DIFF
27871: PUSH
27872: FOR_IN
27873: IFFALSE 27918
// if not HasTask ( i ) then
27875: LD_VAR 0 4
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: IFFALSE 27916
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27887: LD_VAR 0 4
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 250
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 251
27911: PPUSH
27912: CALL_OW 111
27916: GO 27872
27918: POP
27919: POP
// end ;
27920: PPOPN 4
27922: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27923: LD_EXP 39
27927: PUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 255
27937: ARRAY
27938: IFFALSE 28307
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27940: LD_STRING BuildingComplete [side: 
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 255
27952: STR
27953: PUSH
27954: LD_STRING ; btype: 
27956: STR
27957: PUSH
27958: LD_VAR 0 1
27962: PPUSH
27963: CALL_OW 266
27967: STR
27968: PUSH
27969: LD_STRING ]
27971: STR
27972: PPUSH
27973: CALL 8039 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27977: LD_ADDR_EXP 46
27981: PUSH
27982: LD_EXP 46
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 255
27996: PPUSH
27997: LD_VAR 0 1
28001: PPUSH
28002: CALL_OW 266
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 250
28016: PUSH
28017: LD_VAR 0 1
28021: PPUSH
28022: CALL_OW 251
28026: PUSH
28027: LD_VAR 0 1
28031: PPUSH
28032: CALL_OW 254
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL 42051 0 4
28046: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 266
28056: PUSH
28057: LD_INT 6
28059: EQUAL
28060: IFFALSE 28094
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28062: LD_ADDR_EXP 40
28066: PUSH
28067: LD_EXP 40
28071: PPUSH
28072: LD_VAR 0 1
28076: PPUSH
28077: CALL_OW 255
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: EMPTY
28088: PPUSH
28089: CALL 41960 0 4
28093: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 266
28103: PUSH
28104: LD_INT 0
28106: EQUAL
28107: IFFALSE 28217
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28109: LD_ADDR_EXP 48
28113: PUSH
28114: LD_EXP 48
28118: PPUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 255
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: EMPTY
28133: PPUSH
28134: CALL 41960 0 4
28138: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 274
28148: PPUSH
28149: LD_INT 1
28151: PPUSH
28152: LD_EXP 72
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: CALL_OW 274
28174: PPUSH
28175: LD_INT 2
28177: PPUSH
28178: LD_EXP 72
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28191: LD_VAR 0 1
28195: PPUSH
28196: CALL_OW 274
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 72
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PPUSH
28213: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 266
28226: PUSH
28227: LD_INT 2
28229: EQUAL
28230: IFFALSE 28262
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28232: LD_ADDR_EXP 48
28236: PUSH
28237: LD_EXP 48
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: CALL_OW 255
28251: PPUSH
28252: LD_INT 2
28254: PPUSH
28255: EMPTY
28256: PPUSH
28257: CALL 41960 0 4
28261: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 4
28274: EQUAL
28275: IFFALSE 28307
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28277: LD_ADDR_EXP 48
28281: PUSH
28282: LD_EXP 48
28286: PPUSH
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_INT 4
28299: PPUSH
28300: EMPTY
28301: PPUSH
28302: CALL 41960 0 4
28306: ST_TO_ADDR
// end ;
28307: PPOPN 1
28309: END
// on ResearchComplete ( tech , lab ) do var i ;
28310: LD_INT 0
28312: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28313: LD_EXP 39
28317: PUSH
28318: LD_VAR 0 2
28322: PPUSH
28323: CALL_OW 255
28327: ARRAY
28328: IFFALSE 28612
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28330: LD_STRING ResearchComplete [side: 
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: CALL_OW 255
28347: STR
28348: PUSH
28349: LD_STRING ; tech:
28351: STR
28352: PUSH
28353: LD_VAR 0 1
28357: STR
28358: PUSH
28359: LD_STRING ]
28361: STR
28362: PPUSH
28363: CALL 8039 0 1
// for i = 1 to MREG_ToRes do
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: DOUBLE
28373: LD_INT 1
28375: DEC
28376: ST_TO_ADDR
28377: LD_EXP 50
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28470
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28385: LD_EXP 50
28389: PUSH
28390: LD_VAR 0 3
28394: ARRAY
28395: PUSH
28396: LD_INT 1
28398: ARRAY
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: EQUAL
28410: PUSH
28411: LD_EXP 50
28415: PUSH
28416: LD_VAR 0 3
28420: ARRAY
28421: PUSH
28422: LD_INT 2
28424: ARRAY
28425: PUSH
28426: LD_VAR 0 1
28430: EQUAL
28431: AND
28432: IFFALSE 28468
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28434: LD_ADDR_EXP 50
28438: PUSH
28439: LD_EXP 50
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: PPUSH
28454: LD_VAR 0 1
28458: PPUSH
28459: EMPTY
28460: PPUSH
28461: CALL 42051 0 4
28465: ST_TO_ADDR
// break ;
28466: GO 28470
// end ;
28468: GO 28382
28470: POP
28471: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28472: LD_VAR 0 1
28476: PUSH
28477: LD_INT 2
28479: PUSH
28480: LD_INT 11
28482: PUSH
28483: LD_INT 4
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: IN
28495: IFFALSE 28612
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28497: LD_ADDR_VAR 0 3
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: CALL_OW 255
28511: PPUSH
28512: LD_INT 16
28514: PPUSH
28515: LD_INT 25
28517: PUSH
28518: LD_INT 4
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL 12354 0 3
28529: ST_TO_ADDR
// if i then
28530: LD_VAR 0 3
28534: IFFALSE 28552
// SetTag ( i [ 1 ] , 0 ) ;
28536: LD_VAR 0 3
28540: PUSH
28541: LD_INT 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 0
28547: PPUSH
28548: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28552: LD_ADDR_VAR 0 3
28556: PUSH
28557: LD_VAR 0 2
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: LD_INT 171
28569: PPUSH
28570: EMPTY
28571: PPUSH
28572: CALL 12354 0 3
28576: ST_TO_ADDR
// if i then
28577: LD_VAR 0 3
28581: IFFALSE 28612
// begin SetTag ( i [ 1 ] , 0 ) ;
28583: LD_VAR 0 3
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_INT 0
28594: PPUSH
28595: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: CALL_OW 122
// end ; end ; end ;
28612: PPOPN 3
28614: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28615: LD_INT 0
28617: PPUSH
28618: PPUSH
28619: PPUSH
28620: PPUSH
28621: PPUSH
28622: PPUSH
28623: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28624: LD_VAR 0 1
28628: PPUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: CALL 59033 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28638: LD_EXP 39
28642: PUSH
28643: LD_VAR 0 2
28647: PPUSH
28648: CALL_OW 255
28652: ARRAY
28653: IFFALSE 29380
// begin side := GetSide ( veh ) ;
28655: LD_ADDR_VAR 0 4
28659: PUSH
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 255
28669: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 265
28684: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28685: LD_ADDR_VAR 0 7
28689: PUSH
28690: LD_VAR 0 1
28694: PPUSH
28695: CALL_OW 262
28699: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28700: LD_ADDR_VAR 0 8
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 263
28714: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 1
28724: PPUSH
28725: CALL_OW 264
28729: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28730: LD_STRING VehicleConstructed [side: 
28732: PUSH
28733: LD_VAR 0 4
28737: STR
28738: PUSH
28739: LD_STRING ; id:
28741: STR
28742: PUSH
28743: LD_VAR 0 1
28747: STR
28748: PUSH
28749: LD_STRING ; components: [
28751: STR
28752: PUSH
28753: LD_VAR 0 6
28757: STR
28758: PUSH
28759: LD_STRING , 
28761: STR
28762: PUSH
28763: LD_VAR 0 7
28767: STR
28768: PUSH
28769: LD_STRING , 
28771: STR
28772: PUSH
28773: LD_VAR 0 8
28777: STR
28778: PUSH
28779: LD_STRING , 
28781: STR
28782: PUSH
28783: LD_VAR 0 9
28787: STR
28788: PUSH
28789: LD_STRING ]]
28791: STR
28792: PPUSH
28793: CALL 8039 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_INT 13
28809: PUSH
28810: LD_INT 12
28812: PUSH
28813: LD_INT 14
28815: PUSH
28816: LD_INT 51
28818: PUSH
28819: LD_INT 53
28821: PUSH
28822: LD_INT 52
28824: PUSH
28825: LD_INT 32
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: IN
28837: NOT
28838: IFFALSE 28880
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28840: LD_ADDR_EXP 59
28844: PUSH
28845: LD_EXP 59
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: LD_EXP 59
28859: PUSH
28860: LD_VAR 0 4
28864: ARRAY
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 1
28874: PPUSH
28875: CALL 31130 0 4
28879: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 264
28889: PUSH
28890: LD_INT 31
28892: EQUAL
28893: IFFALSE 28912
// SetTag ( GetDriver ( veh ) , 9 ) ;
28895: LD_VAR 0 1
28899: PPUSH
28900: CALL 31773 0 1
28904: PPUSH
28905: LD_INT 9
28907: PPUSH
28908: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28912: LD_VAR 0 1
28916: PPUSH
28917: CALL_OW 264
28921: PUSH
28922: LD_INT 14
28924: PUSH
28925: LD_INT 53
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: IN
28932: IFFALSE 28969
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28934: LD_ADDR_EXP 42
28938: PUSH
28939: LD_EXP 42
28943: PPUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 255
28953: PPUSH
28954: LD_INT 2
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: CALL 31130 0 4
28966: ST_TO_ADDR
// exit ;
28967: GO 29380
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28969: LD_VAR 0 1
28973: PPUSH
28974: CALL_OW 265
28978: PUSH
28979: LD_EXP 66
28983: PUSH
28984: LD_VAR 0 4
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IN
28994: PUSH
28995: LD_VAR 0 1
28999: PPUSH
29000: CALL_OW 262
29004: PUSH
29005: LD_EXP 66
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: IN
29020: AND
29021: PUSH
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 263
29031: PUSH
29032: LD_EXP 66
29036: PUSH
29037: LD_VAR 0 4
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: IN
29047: AND
29048: PUSH
29049: LD_VAR 0 1
29053: PPUSH
29054: CALL_OW 264
29058: PUSH
29059: LD_EXP 66
29063: PUSH
29064: LD_VAR 0 4
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: IN
29074: AND
29075: IFFALSE 29119
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29077: LD_ADDR_EXP 67
29081: PUSH
29082: LD_EXP 67
29086: PPUSH
29087: LD_VAR 0 4
29091: PPUSH
29092: LD_EXP 67
29096: PUSH
29097: LD_VAR 0 4
29101: ARRAY
29102: PUSH
29103: LD_INT 1
29105: PLUS
29106: PPUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL 31130 0 4
29116: ST_TO_ADDR
// exit ;
29117: GO 29380
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29119: LD_VAR 0 6
29123: PUSH
29124: LD_EXP 69
29128: PUSH
29129: LD_VAR 0 4
29133: ARRAY
29134: PUSH
29135: LD_INT 1
29137: ARRAY
29138: EQUAL
29139: PUSH
29140: LD_VAR 0 7
29144: PUSH
29145: LD_EXP 69
29149: PUSH
29150: LD_VAR 0 4
29154: ARRAY
29155: PUSH
29156: LD_INT 2
29158: ARRAY
29159: EQUAL
29160: AND
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_EXP 69
29171: PUSH
29172: LD_VAR 0 4
29176: ARRAY
29177: PUSH
29178: LD_INT 3
29180: ARRAY
29181: EQUAL
29182: AND
29183: PUSH
29184: LD_VAR 0 9
29188: PUSH
29189: LD_EXP 69
29193: PUSH
29194: LD_VAR 0 4
29198: ARRAY
29199: PUSH
29200: LD_INT 4
29202: ARRAY
29203: EQUAL
29204: AND
29205: IFFALSE 29361
// begin tmp := MREG_ToAttack [ side ] ;
29207: LD_ADDR_VAR 0 5
29211: PUSH
29212: LD_EXP 69
29216: PUSH
29217: LD_VAR 0 4
29221: ARRAY
29222: ST_TO_ADDR
// for i = 1 to 4 do
29223: LD_ADDR_VAR 0 3
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_INT 4
29235: PUSH
29236: FOR_TO
29237: IFFALSE 29259
// tmp := Delete ( tmp , 1 ) ;
29239: LD_ADDR_VAR 0 5
29243: PUSH
29244: LD_VAR 0 5
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 3
29256: ST_TO_ADDR
29257: GO 29236
29259: POP
29260: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29261: LD_ADDR_EXP 69
29265: PUSH
29266: LD_EXP 69
29270: PPUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_VAR 0 5
29280: PPUSH
29281: CALL_OW 1
29285: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29286: LD_ADDR_EXP 71
29290: PUSH
29291: LD_EXP 71
29295: PPUSH
29296: LD_VAR 0 4
29300: PPUSH
29301: LD_EXP 71
29305: PUSH
29306: LD_VAR 0 4
29310: ARRAY
29311: PUSH
29312: LD_INT 1
29314: PLUS
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL 31130 0 4
29325: ST_TO_ADDR
// if tmp = 0 then
29326: LD_VAR 0 5
29330: PUSH
29331: LD_INT 0
29333: EQUAL
29334: IFFALSE 29359
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29336: LD_ADDR_EXP 69
29340: PUSH
29341: LD_EXP 69
29345: PPUSH
29346: LD_VAR 0 4
29350: PPUSH
29351: LD_INT 0
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// exit ;
29359: GO 29380
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29361: LD_VAR 0 1
29365: PPUSH
29366: CALL_OW 255
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL 25741 0 2
// end ; end ;
29380: PPOPN 9
29382: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29383: LD_EXP 39
29387: PUSH
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 255
29397: ARRAY
29398: IFFALSE 29630
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29400: LD_STRING ApemanTamed [side: 
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: STR
29413: PUSH
29414: LD_STRING ; sci: 
29416: STR
29417: PUSH
29418: LD_VAR 0 2
29422: STR
29423: PUSH
29424: LD_STRING ; ape: 
29426: STR
29427: PUSH
29428: LD_VAR 0 1
29432: STR
29433: PUSH
29434: LD_STRING ]
29436: STR
29437: PPUSH
29438: CALL 8039 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29442: LD_INT 11
29444: PPUSH
29445: LD_VAR 0 2
29449: PPUSH
29450: CALL_OW 255
29454: PPUSH
29455: CALL_OW 321
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: NOT
29464: PUSH
29465: LD_INT 2
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: CALL_OW 255
29477: PPUSH
29478: CALL_OW 321
29482: PUSH
29483: LD_INT 2
29485: EQUAL
29486: NOT
29487: OR
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: CALL_OW 255
29498: PPUSH
29499: LD_INT 171
29501: PPUSH
29502: EMPTY
29503: PPUSH
29504: CALL 12354 0 3
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: AND
29513: IFFALSE 29527
// begin SetTag ( ape , 171 ) ;
29515: LD_VAR 0 1
29519: PPUSH
29520: LD_INT 171
29522: PPUSH
29523: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29527: LD_VAR 0 2
29531: PPUSH
29532: CALL_OW 255
29536: PPUSH
29537: LD_INT 30
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL 11651 0 2
29551: IFFALSE 29630
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29553: LD_VAR 0 1
29557: PPUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: CALL_OW 255
29567: PPUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL 11651 0 2
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: CALL_OW 250
29591: PPUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 255
29601: PPUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL 11651 0 2
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: CALL_OW 251
29625: PPUSH
29626: CALL_OW 111
// end ;
29630: PPOPN 2
29632: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29633: LD_EXP 39
29637: PUSH
29638: LD_VAR 0 1
29642: PPUSH
29643: CALL_OW 255
29647: ARRAY
29648: IFFALSE 29926
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29650: LD_VAR 0 2
29654: PUSH
29655: LD_VAR 0 2
29659: PPUSH
29660: CALL_OW 255
29664: PPUSH
29665: CALL 12064 0 1
29669: IN
29670: IFFALSE 29811
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29672: LD_VAR 0 1
29676: PPUSH
29677: CALL_OW 266
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: IFFALSE 29722
// begin Wait ( 0 0$0.3 ) ;
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 16
29708: PPUSH
29709: CALL_OW 336
// ComExitBuilding ( un ) ;
29713: LD_VAR 0 2
29717: PPUSH
29718: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 266
29731: PUSH
29732: LD_INT 4
29734: PUSH
29735: LD_INT 5
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: IN
29742: IFFALSE 29811
// begin Wait ( 0 0$0.3 ) ;
29744: LD_INT 10
29746: PPUSH
29747: CALL_OW 67
// if GetTag ( un ) = 0 then
29751: LD_VAR 0 2
29755: PPUSH
29756: CALL_OW 110
29760: PUSH
29761: LD_INT 0
29763: EQUAL
29764: IFFALSE 29780
// SetClass ( un , class_apeman_soldier ) else
29766: LD_VAR 0 2
29770: PPUSH
29771: LD_INT 15
29773: PPUSH
29774: CALL_OW 336
29778: GO 29811
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29780: LD_INT 3
29782: PPUSH
29783: LD_VAR 0 2
29787: PPUSH
29788: CALL_OW 255
29792: PPUSH
29793: CALL_OW 321
29797: IFFALSE 29811
// SetClass ( un , class_apeman_kamikaze ) ;
29799: LD_VAR 0 2
29803: PPUSH
29804: LD_INT 17
29806: PPUSH
29807: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 266
29820: PUSH
29821: LD_INT 32
29823: EQUAL
29824: IFFALSE 29926
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29826: LD_ADDR_EXP 68
29830: PUSH
29831: LD_EXP 68
29835: PPUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: CALL_OW 255
29845: PPUSH
29846: LD_EXP 68
29850: PUSH
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL_OW 255
29860: ARRAY
29861: PUSH
29862: LD_INT 1
29864: PLUS
29865: PPUSH
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL 31130 0 4
29875: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29876: LD_ADDR_EXP 68
29880: PUSH
29881: LD_EXP 68
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 255
29895: PPUSH
29896: LD_EXP 68
29900: PUSH
29901: LD_VAR 0 1
29905: PPUSH
29906: CALL_OW 255
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: PLUS
29915: PPUSH
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL 31130 0 4
29925: ST_TO_ADDR
// end ; end ;
29926: PPOPN 2
29928: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL 58913 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29938: LD_VAR 0 1
29942: PUSH
29943: LD_INT 22
29945: PUSH
29946: LD_INT 3
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 23
29955: PUSH
29956: LD_INT 3
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 21
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: PPUSH
29978: CALL_OW 69
29982: IN
29983: IFFALSE 29999
// player_loss := player_loss + 1 ;
29985: LD_ADDR_EXP 10
29989: PUSH
29990: LD_EXP 10
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 22
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 21
30016: PUSH
30017: LD_INT 3
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 69
30032: IN
30033: PUSH
30034: LD_EXP 14
30038: NOT
30039: AND
30040: IFFALSE 30103
// begin alfa_north_triggered := true ;
30042: LD_ADDR_EXP 14
30046: PUSH
30047: LD_INT 1
30049: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30050: LD_EXP 5
30054: PPUSH
30055: LD_STRING DS4
30057: PPUSH
30058: CALL_OW 94
// Wait ( 1 1$25 ) ;
30062: LD_INT 2975
30064: PPUSH
30065: CALL_OW 67
// if not isTest then
30069: LD_EXP 1
30073: NOT
30074: IFFALSE 30103
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30076: LD_INT 20
30078: PPUSH
30079: LD_INT 5
30081: PUSH
30082: LD_INT 6
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PUSH
30093: LD_OWVAR 67
30097: ARRAY
30098: PPUSH
30099: CALL 7058 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30103: LD_VAR 0 1
30107: PUSH
30108: LD_INT 22
30110: PUSH
30111: LD_INT 4
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 21
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PPUSH
30132: CALL_OW 69
30136: IN
30137: PUSH
30138: LD_EXP 15
30142: NOT
30143: AND
30144: IFFALSE 30207
// begin alfa_south_triggered := true ;
30146: LD_ADDR_EXP 15
30150: PUSH
30151: LD_INT 1
30153: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30154: LD_EXP 4
30158: PPUSH
30159: LD_STRING DJ3
30161: PPUSH
30162: CALL_OW 94
// Wait ( 0 0$45 ) ;
30166: LD_INT 1575
30168: PPUSH
30169: CALL_OW 67
// if not isTest then
30173: LD_EXP 1
30177: NOT
30178: IFFALSE 30207
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30180: LD_INT 20
30182: PPUSH
30183: LD_INT 5
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: LD_INT 7
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: LIST
30196: PUSH
30197: LD_OWVAR 67
30201: ARRAY
30202: PPUSH
30203: CALL 7058 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 266
30216: PUSH
30217: LD_INT 1
30219: EQUAL
30220: PUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 255
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 4
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: IN
30241: AND
30242: IFFALSE 30251
// RaiseSailEvent ( 104 ) ;
30244: LD_INT 104
30246: PPUSH
30247: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30251: LD_EXP 39
30255: PUSH
30256: LD_VAR 0 1
30260: PPUSH
30261: CALL_OW 255
30265: ARRAY
30266: IFFALSE 30653
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30268: LD_STRING UnitDestroyed [side 
30270: PUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL_OW 255
30280: STR
30281: PUSH
30282: LD_STRING ; id: 
30284: STR
30285: PUSH
30286: LD_VAR 0 1
30290: STR
30291: PUSH
30292: LD_STRING ; type: 
30294: STR
30295: PUSH
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 247
30305: STR
30306: PUSH
30307: LD_STRING ]
30309: STR
30310: PPUSH
30311: CALL 8039 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: CALL_OW 255
30329: PPUSH
30330: LD_INT 21
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL 11651 0 2
30344: IN
30345: IFFALSE 30501
// begin if MCF_HasClass ( un ) then
30347: LD_VAR 0 1
30351: PPUSH
30352: CALL 14357 0 1
30356: IFFALSE 30501
// case MCF_HasClass ( un ) of 1 :
30358: LD_VAR 0 1
30362: PPUSH
30363: CALL 14357 0 1
30367: PUSH
30368: LD_INT 1
30370: DOUBLE
30371: EQUAL
30372: IFTRUE 30376
30374: GO 30401
30376: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 255
30386: PPUSH
30387: LD_STRING ToArm
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL 14530 0 3
30399: GO 30501
30401: LD_INT 2
30403: DOUBLE
30404: EQUAL
30405: IFTRUE 30409
30407: GO 30434
30409: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30410: LD_VAR 0 1
30414: PPUSH
30415: CALL_OW 255
30419: PPUSH
30420: LD_STRING ToDep
30422: PPUSH
30423: LD_VAR 0 1
30427: PPUSH
30428: CALL 14530 0 3
30432: GO 30501
30434: LD_INT 3
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30467
30442: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30443: LD_VAR 0 1
30447: PPUSH
30448: CALL_OW 255
30452: PPUSH
30453: LD_STRING ToFac
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: CALL 14530 0 3
30465: GO 30501
30467: LD_INT 4
30469: DOUBLE
30470: EQUAL
30471: IFTRUE 30475
30473: GO 30500
30475: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30476: LD_VAR 0 1
30480: PPUSH
30481: CALL_OW 255
30485: PPUSH
30486: LD_STRING ToLab
30488: PPUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL 14530 0 3
30498: GO 30501
30500: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30501: LD_VAR 0 1
30505: PUSH
30506: LD_EXP 67
30510: PUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 255
30520: ARRAY
30521: IN
30522: IFFALSE 30607
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30524: LD_ADDR_EXP 67
30528: PUSH
30529: LD_EXP 67
30533: PPUSH
30534: LD_VAR 0 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 31289 0 3
30546: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 255
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: CALL_OW 265
30566: PUSH
30567: LD_VAR 0 1
30571: PPUSH
30572: CALL_OW 262
30576: PUSH
30577: LD_VAR 0 1
30581: PPUSH
30582: CALL_OW 263
30586: PUSH
30587: LD_VAR 0 1
30591: PPUSH
30592: CALL_OW 264
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PPUSH
30603: CALL 21170 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30607: LD_VAR 0 1
30611: PUSH
30612: LD_EXP 71
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 255
30626: ARRAY
30627: IN
30628: IFFALSE 30653
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30630: LD_ADDR_EXP 71
30634: PUSH
30635: LD_EXP 71
30639: PPUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: LD_INT 0
30647: PPUSH
30648: CALL 31289 0 3
30652: ST_TO_ADDR
// end ; end ;
30653: PPOPN 1
30655: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30656: LD_EXP 39
30660: PUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL_OW 255
30670: ARRAY
30671: IFFALSE 30843
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30673: LD_VAR 0 2
30677: PUSH
30678: LD_EXP 68
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 255
30692: ARRAY
30693: IN
30694: PUSH
30695: LD_VAR 0 1
30699: PPUSH
30700: CALL_OW 266
30704: PUSH
30705: LD_INT 32
30707: PUSH
30708: LD_INT 31
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: IN
30715: AND
30716: IFFALSE 30816
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30718: LD_ADDR_EXP 68
30722: PUSH
30723: LD_EXP 68
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: LD_INT 0
30735: PPUSH
30736: CALL 31289 0 3
30740: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30741: LD_ADDR_EXP 68
30745: PUSH
30746: LD_EXP 68
30750: PPUSH
30751: LD_VAR 0 2
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL 31289 0 3
30763: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30764: LD_EXP 68
30768: PUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: CALL_OW 255
30778: ARRAY
30779: PUSH
30780: LD_STRING 
30782: EQUAL
30783: IFFALSE 30816
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30785: LD_ADDR_EXP 68
30789: PUSH
30790: LD_EXP 68
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: CALL_OW 255
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL 31130 0 4
30815: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30816: LD_VAR 0 1
30820: PPUSH
30821: CALL_OW 266
30825: PUSH
30826: LD_INT 36
30828: IN
30829: IFFALSE 30843
// SetTag ( un , 0 ) ;
30831: LD_VAR 0 2
30835: PPUSH
30836: LD_INT 0
30838: PPUSH
30839: CALL_OW 109
// end ;
30843: PPOPN 2
30845: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30846: LD_EXP 39
30850: PUSH
30851: LD_VAR 0 1
30855: PPUSH
30856: CALL_OW 255
30860: ARRAY
30861: IFFALSE 30887
// begin if GetControl ( un ) = control_remote then
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 263
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: IFFALSE 30887
// ComUnlink ( un ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 136
// end ;
30887: PPOPN 1
30889: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30890: LD_EXP 39
30894: PUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 255
30904: ARRAY
30905: IFFALSE 30934
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30907: LD_VAR 0 2
30911: PPUSH
30912: CALL_OW 264
30916: PUSH
30917: LD_INT 31
30919: IN
30920: IFFALSE 30934
// SetTag ( driver , 0 ) ;
30922: LD_VAR 0 1
30926: PPUSH
30927: LD_INT 0
30929: PPUSH
30930: CALL_OW 109
// end ;
30934: PPOPN 4
30936: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 269
30956: ST_TO_ADDR
// x := GetX ( building ) ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_VAR 0 1
30966: PPUSH
30967: CALL_OW 250
30971: ST_TO_ADDR
// y := GetY ( building ) ;
30972: LD_ADDR_VAR 0 5
30976: PUSH
30977: LD_VAR 0 1
30981: PPUSH
30982: CALL_OW 251
30986: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30987: LD_ADDR_EXP 43
30991: PUSH
30992: LD_EXP 43
30996: PPUSH
30997: LD_VAR 0 1
31001: PPUSH
31002: CALL_OW 255
31006: PPUSH
31007: LD_VAR 0 3
31011: PPUSH
31012: LD_VAR 0 4
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PPUSH
31026: CALL 42051 0 4
31030: ST_TO_ADDR
// end ;
31031: PPOPN 5
31033: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 30
31043: IN
31044: NOT
31045: IFFALSE 31093
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31047: LD_ADDR_EXP 30
31051: PUSH
31052: LD_EXP 30
31056: PPUSH
31057: LD_EXP 30
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 1
31070: PPUSH
31071: CALL_OW 2
31075: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31076: LD_STRING DestinationUnrechable. [unit: 
31078: PUSH
31079: LD_VAR 0 1
31083: STR
31084: PUSH
31085: LD_STRING ]
31087: STR
31088: PPUSH
31089: CALL 8039 0 1
// end ; end ;
31093: PPOPN 1
31095: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL 59009 0 3
// end ;
31115: PPOPN 3
31117: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL 59017 0 1
// end ; end_of_file
31127: PPOPN 1
31129: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
31134: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31135: LD_ADDR_VAR 0 7
31139: PUSH
31140: LD_VAR 0 1
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PPUSH
31151: LD_VAR 0 3
31155: PPUSH
31156: LD_VAR 0 4
31160: PPUSH
31161: CALL_OW 1
31165: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31166: LD_ADDR_VAR 0 1
31170: PUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: LD_VAR 0 2
31180: PPUSH
31181: LD_VAR 0 7
31185: PPUSH
31186: CALL_OW 1
31190: ST_TO_ADDR
// result := tab ;
31191: LD_ADDR_VAR 0 5
31195: PUSH
31196: LD_VAR 0 1
31200: ST_TO_ADDR
// end ;
31201: LD_VAR 0 5
31205: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31206: LD_INT 0
31208: PPUSH
31209: PPUSH
31210: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31211: LD_ADDR_VAR 0 5
31215: PUSH
31216: LD_VAR 0 1
31220: PUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: ARRAY
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_INT 2
31238: ARRAY
31239: PPUSH
31240: CALL_OW 3
31244: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31245: LD_ADDR_VAR 0 1
31249: PUSH
31250: LD_VAR 0 1
31254: PPUSH
31255: LD_VAR 0 2
31259: PUSH
31260: LD_INT 1
31262: ARRAY
31263: PPUSH
31264: LD_VAR 0 5
31268: PPUSH
31269: CALL_OW 1
31273: ST_TO_ADDR
// result := tab ;
31274: LD_ADDR_VAR 0 3
31278: PUSH
31279: LD_VAR 0 1
31283: ST_TO_ADDR
// end ;
31284: LD_VAR 0 3
31288: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31289: LD_INT 0
31291: PPUSH
31292: PPUSH
31293: PPUSH
31294: PPUSH
// i := 1 ;
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// while ( i <= tab ) do
31303: LD_VAR 0 5
31307: PUSH
31308: LD_VAR 0 1
31312: LESSEQUAL
31313: IFFALSE 31688
// begin if not tab [ i ] then
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: NOT
31326: IFFALSE 31330
// break ;
31328: GO 31688
// if value in tab then
31330: LD_VAR 0 2
31334: PUSH
31335: LD_VAR 0 1
31339: IN
31340: IFFALSE 31453
// begin if not mode then
31342: LD_VAR 0 3
31346: NOT
31347: IFFALSE 31367
// tab := tab diff value else
31349: LD_ADDR_VAR 0 1
31353: PUSH
31354: LD_VAR 0 1
31358: PUSH
31359: LD_VAR 0 2
31363: DIFF
31364: ST_TO_ADDR
31365: GO 31429
// for j = 1 to tab do
31367: LD_ADDR_VAR 0 6
31371: PUSH
31372: DOUBLE
31373: LD_INT 1
31375: DEC
31376: ST_TO_ADDR
31377: LD_VAR 0 1
31381: PUSH
31382: FOR_TO
31383: IFFALSE 31427
// if tab [ j ] = value then
31385: LD_VAR 0 1
31389: PUSH
31390: LD_VAR 0 6
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 2
31400: EQUAL
31401: IFFALSE 31425
// begin tab := Delete ( tab , j ) ;
31403: LD_ADDR_VAR 0 1
31407: PUSH
31408: LD_VAR 0 1
31412: PPUSH
31413: LD_VAR 0 6
31417: PPUSH
31418: CALL_OW 3
31422: ST_TO_ADDR
// break ;
31423: GO 31427
// end ;
31425: GO 31382
31427: POP
31428: POP
// i := i - 1 ;
31429: LD_ADDR_VAR 0 5
31433: PUSH
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 1
31441: MINUS
31442: ST_TO_ADDR
// if mode then
31443: LD_VAR 0 3
31447: IFFALSE 31451
// break ;
31449: GO 31688
// end else
31451: GO 31672
// if tab [ i ] and value in tab [ i ] then
31453: LD_VAR 0 1
31457: PUSH
31458: LD_VAR 0 5
31462: ARRAY
31463: PUSH
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: IN
31480: AND
31481: IFFALSE 31672
// begin if not mode then
31483: LD_VAR 0 3
31487: NOT
31488: IFFALSE 31514
// tmp := tab [ i ] diff value else
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: LD_VAR 0 1
31499: PUSH
31500: LD_VAR 0 5
31504: ARRAY
31505: PUSH
31506: LD_VAR 0 2
31510: DIFF
31511: ST_TO_ADDR
31512: GO 31594
// for j = 1 to tab [ i ] do
31514: LD_ADDR_VAR 0 6
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 1
31528: PUSH
31529: LD_VAR 0 5
31533: ARRAY
31534: PUSH
31535: FOR_TO
31536: IFFALSE 31592
// if value = tab [ i ] [ j ] then
31538: LD_VAR 0 2
31542: PUSH
31543: LD_VAR 0 1
31547: PUSH
31548: LD_VAR 0 5
31552: ARRAY
31553: PUSH
31554: LD_VAR 0 6
31558: ARRAY
31559: EQUAL
31560: IFFALSE 31590
// begin tmp := Delete ( tab [ i ] , j ) ;
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: LD_VAR 0 1
31571: PUSH
31572: LD_VAR 0 5
31576: ARRAY
31577: PPUSH
31578: LD_VAR 0 6
31582: PPUSH
31583: CALL_OW 3
31587: ST_TO_ADDR
// break ;
31588: GO 31592
// end ;
31590: GO 31535
31592: POP
31593: POP
// if tmp = [ ] then
31594: LD_VAR 0 7
31598: PUSH
31599: EMPTY
31600: EQUAL
31601: IFFALSE 31625
// begin tab := Delete ( tab , i ) ;
31603: LD_ADDR_VAR 0 1
31607: PUSH
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: CALL_OW 3
31622: ST_TO_ADDR
// end else
31623: GO 31650
// tab := Replace ( tab , i , tmp ) ;
31625: LD_ADDR_VAR 0 1
31629: PUSH
31630: LD_VAR 0 1
31634: PPUSH
31635: LD_VAR 0 5
31639: PPUSH
31640: LD_VAR 0 7
31644: PPUSH
31645: CALL_OW 1
31649: ST_TO_ADDR
// i := i - 1 ;
31650: LD_ADDR_VAR 0 5
31654: PUSH
31655: LD_VAR 0 5
31659: PUSH
31660: LD_INT 1
31662: MINUS
31663: ST_TO_ADDR
// if mode then
31664: LD_VAR 0 3
31668: IFFALSE 31672
// break ;
31670: GO 31688
// end ; i := i + 1 ;
31672: LD_ADDR_VAR 0 5
31676: PUSH
31677: LD_VAR 0 5
31681: PUSH
31682: LD_INT 1
31684: PLUS
31685: ST_TO_ADDR
// end ;
31686: GO 31303
// result := tab ;
31688: LD_ADDR_VAR 0 4
31692: PUSH
31693: LD_VAR 0 1
31697: ST_TO_ADDR
// end ;
31698: LD_VAR 0 4
31702: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31703: LD_INT 0
31705: PPUSH
31706: PPUSH
// for i = 1 to values do
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: DOUBLE
31713: LD_INT 1
31715: DEC
31716: ST_TO_ADDR
31717: LD_VAR 0 2
31721: PUSH
31722: FOR_TO
31723: IFFALSE 31756
// tab := Remove ( tab , values [ i ] , false ) ;
31725: LD_ADDR_VAR 0 1
31729: PUSH
31730: LD_VAR 0 1
31734: PPUSH
31735: LD_VAR 0 2
31739: PUSH
31740: LD_VAR 0 4
31744: ARRAY
31745: PPUSH
31746: LD_INT 0
31748: PPUSH
31749: CALL 31289 0 3
31753: ST_TO_ADDR
31754: GO 31722
31756: POP
31757: POP
// result := tab ;
31758: LD_ADDR_VAR 0 3
31762: PUSH
31763: LD_VAR 0 1
31767: ST_TO_ADDR
// end ;
31768: LD_VAR 0 3
31772: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31773: LD_INT 0
31775: PPUSH
31776: PPUSH
31777: PPUSH
// if not GetControl ( veh ) = control_manual then
31778: LD_VAR 0 1
31782: PPUSH
31783: CALL_OW 263
31787: PUSH
31788: LD_INT 1
31790: EQUAL
31791: NOT
31792: IFFALSE 31804
// result := false else
31794: LD_ADDR_VAR 0 2
31798: PUSH
31799: LD_INT 0
31801: ST_TO_ADDR
31802: GO 31949
// if veh in FilterAllUnits ( [ f_empty ] ) then
31804: LD_VAR 0 1
31808: PUSH
31809: LD_INT 58
31811: PUSH
31812: EMPTY
31813: LIST
31814: PPUSH
31815: CALL_OW 69
31819: IN
31820: IFFALSE 31832
// result := false else
31822: LD_ADDR_VAR 0 2
31826: PUSH
31827: LD_INT 0
31829: ST_TO_ADDR
31830: GO 31949
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31832: LD_ADDR_VAR 0 4
31836: PUSH
31837: LD_INT 22
31839: PUSH
31840: LD_VAR 0 1
31844: PPUSH
31845: CALL_OW 255
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 55
31856: PUSH
31857: EMPTY
31858: LIST
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 69
31868: ST_TO_ADDR
// if not filter then
31869: LD_VAR 0 4
31873: NOT
31874: IFFALSE 31886
// result := false else
31876: LD_ADDR_VAR 0 2
31880: PUSH
31881: LD_INT 0
31883: ST_TO_ADDR
31884: GO 31949
// for i = 1 to filter do
31886: LD_ADDR_VAR 0 3
31890: PUSH
31891: DOUBLE
31892: LD_INT 1
31894: DEC
31895: ST_TO_ADDR
31896: LD_VAR 0 4
31900: PUSH
31901: FOR_TO
31902: IFFALSE 31947
// if IsDriver ( filter [ i ] ) = veh then
31904: LD_VAR 0 4
31908: PUSH
31909: LD_VAR 0 3
31913: ARRAY
31914: PPUSH
31915: CALL 98260 0 1
31919: PUSH
31920: LD_VAR 0 1
31924: EQUAL
31925: IFFALSE 31945
// begin result := filter [ i ] ;
31927: LD_ADDR_VAR 0 2
31931: PUSH
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 3
31941: ARRAY
31942: ST_TO_ADDR
// break ;
31943: GO 31947
// end ;
31945: GO 31901
31947: POP
31948: POP
// end ; end ;
31949: LD_VAR 0 2
31953: RET
// export function Compare ( val1 , val2 ) ; begin
31954: LD_INT 0
31956: PPUSH
// if val1 = val2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 31979
// result := true else
31969: LD_ADDR_VAR 0 3
31973: PUSH
31974: LD_INT 1
31976: ST_TO_ADDR
31977: GO 31987
// result := false ;
31979: LD_ADDR_VAR 0 3
31983: PUSH
31984: LD_INT 0
31986: ST_TO_ADDR
// end ;
31987: LD_VAR 0 3
31991: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31992: LD_INT 0
31994: PPUSH
31995: PPUSH
// result := false ;
31996: LD_ADDR_VAR 0 3
32000: PUSH
32001: LD_INT 0
32003: ST_TO_ADDR
// for j = 1 to e2 do
32004: LD_ADDR_VAR 0 4
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_VAR 0 2
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32054
// if Compare ( e1 , e2 [ j ] ) then
32022: LD_VAR 0 1
32026: PPUSH
32027: LD_VAR 0 2
32031: PUSH
32032: LD_VAR 0 4
32036: ARRAY
32037: PPUSH
32038: CALL 31954 0 2
32042: IFFALSE 32052
// result := true ;
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_INT 1
32051: ST_TO_ADDR
32052: GO 32019
32054: POP
32055: POP
// end ;
32056: LD_VAR 0 3
32060: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32061: LD_INT 0
32063: PPUSH
32064: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_STRING C
32072: PUSH
32073: LD_VAR 0 2
32077: PUSH
32078: LD_VAR 0 3
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: PUSH
32104: LD_STRING v
32106: PUSH
32107: LD_VAR 0 4
32111: PPUSH
32112: CALL_OW 250
32116: PUSH
32117: LD_VAR 0 4
32121: PPUSH
32122: CALL_OW 251
32126: PUSH
32127: LD_VAR 0 4
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 0
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: CALL_OW 446
// end ;
32158: LD_VAR 0 5
32162: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
// linked := UnitsLinked ( unit ) ;
32168: LD_ADDR_VAR 0 4
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 432
32182: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32183: LD_ADDR_VAR 0 3
32187: PUSH
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_INT 3
32195: PPUSH
32196: CALL_OW 259
32200: ST_TO_ADDR
// if sk > linked then
32201: LD_VAR 0 3
32205: PUSH
32206: LD_VAR 0 4
32210: GREATER
32211: IFFALSE 32223
// result := true else
32213: LD_ADDR_VAR 0 2
32217: PUSH
32218: LD_INT 1
32220: ST_TO_ADDR
32221: GO 32231
// result := false ;
32223: LD_ADDR_VAR 0 2
32227: PUSH
32228: LD_INT 0
32230: ST_TO_ADDR
// end ;
32231: LD_VAR 0 2
32235: RET
// export function NotTask ( unit ) ; begin
32236: LD_INT 0
32238: PPUSH
// result := true ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32247: LD_VAR 0 1
32251: PPUSH
32252: CALL_OW 437
32256: PUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: CALL_OW 314
32266: OR
32267: IFFALSE 32277
// result := false ;
32269: LD_ADDR_VAR 0 2
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// end ;
32277: LD_VAR 0 2
32281: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32282: LD_INT 0
32284: PPUSH
32285: PPUSH
32286: PPUSH
32287: PPUSH
32288: PPUSH
// dist := 99999 ;
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_INT 99999
32296: ST_TO_ADDR
// un := - 1 ;
32297: LD_ADDR_VAR 0 6
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: ST_TO_ADDR
// if units1 and units2 then
32306: LD_VAR 0 1
32310: PUSH
32311: LD_VAR 0 2
32315: AND
32316: IFFALSE 32404
// for i in units1 do
32318: LD_ADDR_VAR 0 4
32322: PUSH
32323: LD_VAR 0 1
32327: PUSH
32328: FOR_IN
32329: IFFALSE 32402
// for j in units2 do
32331: LD_ADDR_VAR 0 5
32335: PUSH
32336: LD_VAR 0 2
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32398
// if GetDistUnits ( i , j ) < dist then
32344: LD_VAR 0 4
32348: PPUSH
32349: LD_VAR 0 5
32353: PPUSH
32354: CALL_OW 296
32358: PUSH
32359: LD_VAR 0 7
32363: LESS
32364: IFFALSE 32396
// begin un := i ;
32366: LD_ADDR_VAR 0 6
32370: PUSH
32371: LD_VAR 0 4
32375: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32376: LD_ADDR_VAR 0 7
32380: PUSH
32381: LD_VAR 0 4
32385: PPUSH
32386: LD_VAR 0 5
32390: PPUSH
32391: CALL_OW 296
32395: ST_TO_ADDR
// end ;
32396: GO 32341
32398: POP
32399: POP
32400: GO 32328
32402: POP
32403: POP
// result := [ un , dist ] ;
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_VAR 0 6
32413: PUSH
32414: LD_VAR 0 7
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: ST_TO_ADDR
// end ;
32423: LD_VAR 0 3
32427: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32428: LD_INT 0
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32435: LD_VAR 0 1
32439: NOT
32440: PUSH
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 256
32450: PUSH
32451: LD_INT 250
32453: LESS
32454: OR
32455: PUSH
32456: LD_VAR 0 1
32460: PPUSH
32461: CALL_OW 314
32465: PUSH
32466: LD_VAR 0 1
32470: PPUSH
32471: CALL_OW 261
32475: PUSH
32476: LD_INT 20
32478: GREATER
32479: AND
32480: OR
32481: IFFALSE 32485
// exit ;
32483: GO 32859
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 261
32494: PUSH
32495: LD_INT 20
32497: LESS
32498: PUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 21
32511: EQUAL
32512: NOT
32513: AND
32514: IFFALSE 32550
// begin ComStop ( bulldozer ) ;
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32525: LD_VAR 0 1
32529: PPUSH
32530: LD_INT 21
32532: PPUSH
32533: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32537: LD_VAR 0 1
32541: PPUSH
32542: CALL 26278 0 1
// exit ;
32546: GO 32859
// end else
32548: GO 32577
// if GetFuel ( bulldozer ) > 20 then
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: IFFALSE 32577
// SetTag ( bulldozer , 0 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 0
32572: PPUSH
32573: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_VAR 0 2
32586: PPUSH
32587: CALL_OW 353
32591: ST_TO_ADDR
// tmp := [ ] ;
32592: LD_ADDR_VAR 0 6
32596: PUSH
32597: EMPTY
32598: ST_TO_ADDR
// for i = 1 to list do
32599: LD_ADDR_VAR 0 4
32603: PUSH
32604: DOUBLE
32605: LD_INT 1
32607: DEC
32608: ST_TO_ADDR
32609: LD_VAR 0 5
32613: PUSH
32614: FOR_TO
32615: IFFALSE 32713
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32617: LD_VAR 0 5
32621: PUSH
32622: LD_VAR 0 4
32626: ARRAY
32627: PUSH
32628: LD_INT 1
32630: ARRAY
32631: PPUSH
32632: LD_VAR 0 5
32636: PUSH
32637: LD_VAR 0 4
32641: ARRAY
32642: PUSH
32643: LD_INT 2
32645: ARRAY
32646: PPUSH
32647: CALL_OW 554
32651: IFFALSE 32711
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32653: LD_ADDR_VAR 0 6
32657: PUSH
32658: LD_VAR 0 6
32662: PPUSH
32663: LD_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PPUSH
32672: LD_VAR 0 5
32676: PUSH
32677: LD_VAR 0 4
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 5
32691: PUSH
32692: LD_VAR 0 4
32696: ARRAY
32697: PUSH
32698: LD_INT 2
32700: ARRAY
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 1
32710: ST_TO_ADDR
// end ;
32711: GO 32614
32713: POP
32714: POP
// ComStop ( bulldozer ) ;
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32724: LD_ADDR_VAR 0 7
32728: PUSH
32729: LD_VAR 0 1
32733: PPUSH
32734: CALL_OW 250
32738: PUSH
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 251
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: ST_TO_ADDR
// for i = tmp downto 1 do
32753: LD_ADDR_VAR 0 4
32757: PUSH
32758: DOUBLE
32759: LD_VAR 0 6
32763: INC
32764: ST_TO_ADDR
32765: LD_INT 1
32767: PUSH
32768: FOR_DOWNTO
32769: IFFALSE 32857
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32771: LD_ADDR_VAR 0 7
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 2
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 6
32798: PPUSH
32799: CALL 32960 0 3
32803: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32804: LD_VAR 0 1
32808: PPUSH
32809: LD_VAR 0 7
32813: PUSH
32814: LD_INT 1
32816: ARRAY
32817: PPUSH
32818: LD_VAR 0 7
32822: PUSH
32823: LD_INT 2
32825: ARRAY
32826: PPUSH
32827: CALL 32864 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32831: LD_ADDR_VAR 0 6
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_VAR 0 7
32845: PUSH
32846: LD_INT 3
32848: ARRAY
32849: PPUSH
32850: CALL_OW 3
32854: ST_TO_ADDR
// end ;
32855: GO 32768
32857: POP
32858: POP
// end ;
32859: LD_VAR 0 3
32863: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32864: LD_INT 0
32866: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32867: LD_VAR 0 2
32871: PPUSH
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 351
32881: PUSH
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 554
32896: AND
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 488
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 428
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: EQUAL
32933: AND
32934: IFFALSE 32955
// AddComMoveXY ( bulldozer , x , y ) ;
32936: LD_VAR 0 1
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 171
// end ;
32955: LD_VAR 0 4
32959: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32960: LD_INT 0
32962: PPUSH
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
// dist := 99999 ;
32969: LD_ADDR_VAR 0 6
32973: PUSH
32974: LD_INT 99999
32976: ST_TO_ADDR
// for i = 1 to list do
32977: LD_ADDR_VAR 0 5
32981: PUSH
32982: DOUBLE
32983: LD_INT 1
32985: DEC
32986: ST_TO_ADDR
32987: LD_VAR 0 3
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33131
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32995: LD_ADDR_VAR 0 7
32999: PUSH
33000: LD_VAR 0 1
33004: PPUSH
33005: LD_VAR 0 2
33009: PPUSH
33010: LD_VAR 0 3
33014: PUSH
33015: LD_VAR 0 5
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PPUSH
33025: LD_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: ARRAY
33035: PUSH
33036: LD_INT 2
33038: ARRAY
33039: PPUSH
33040: CALL_OW 298
33044: ST_TO_ADDR
// if d = 0 then
33045: LD_VAR 0 7
33049: PUSH
33050: LD_INT 0
33052: EQUAL
33053: IFFALSE 33057
// continue ;
33055: GO 32992
// if d < dist then
33057: LD_VAR 0 7
33061: PUSH
33062: LD_VAR 0 6
33066: LESS
33067: IFFALSE 33129
// begin _x := list [ i ] [ 1 ] ;
33069: LD_ADDR_VAR 0 8
33073: PUSH
33074: LD_VAR 0 3
33078: PUSH
33079: LD_VAR 0 5
33083: ARRAY
33084: PUSH
33085: LD_INT 1
33087: ARRAY
33088: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33089: LD_ADDR_VAR 0 9
33093: PUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 2
33107: ARRAY
33108: ST_TO_ADDR
// _i := i ;
33109: LD_ADDR_VAR 0 10
33113: PUSH
33114: LD_VAR 0 5
33118: ST_TO_ADDR
// dist := d ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_VAR 0 7
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32992
33131: POP
33132: POP
// result := [ _x , _y , _i , dist ] ;
33133: LD_ADDR_VAR 0 4
33137: PUSH
33138: LD_VAR 0 8
33142: PUSH
33143: LD_VAR 0 9
33147: PUSH
33148: LD_VAR 0 10
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: ST_TO_ADDR
// end ;
33164: LD_VAR 0 4
33168: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
// for i = 1 to list do
33176: LD_ADDR_VAR 0 5
33180: PUSH
33181: DOUBLE
33182: LD_INT 1
33184: DEC
33185: ST_TO_ADDR
33186: LD_VAR 0 1
33190: PUSH
33191: FOR_TO
33192: IFFALSE 33506
// begin for j = list downto 2 do
33194: LD_ADDR_VAR 0 6
33198: PUSH
33199: DOUBLE
33200: LD_VAR 0 1
33204: INC
33205: ST_TO_ADDR
33206: LD_INT 2
33208: PUSH
33209: FOR_DOWNTO
33210: IFFALSE 33502
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33212: LD_VAR 0 2
33216: PPUSH
33217: LD_VAR 0 3
33221: PPUSH
33222: LD_VAR 0 1
33226: PUSH
33227: LD_VAR 0 6
33231: ARRAY
33232: PUSH
33233: LD_INT 1
33235: ARRAY
33236: PPUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_VAR 0 6
33246: ARRAY
33247: PUSH
33248: LD_INT 2
33250: ARRAY
33251: PPUSH
33252: CALL_OW 298
33256: PUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_INT 1
33279: MINUS
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PPUSH
33286: LD_VAR 0 1
33290: PUSH
33291: LD_VAR 0 6
33295: PUSH
33296: LD_INT 1
33298: MINUS
33299: ARRAY
33300: PUSH
33301: LD_INT 2
33303: ARRAY
33304: PPUSH
33305: CALL_OW 298
33309: LESS
33310: IFFALSE 33500
// begin _x := list [ j ] [ 1 ] ;
33312: LD_ADDR_VAR 0 7
33316: PUSH
33317: LD_VAR 0 1
33321: PUSH
33322: LD_VAR 0 6
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33332: LD_ADDR_VAR 0 8
33336: PUSH
33337: LD_VAR 0 1
33341: PUSH
33342: LD_VAR 0 6
33346: ARRAY
33347: PUSH
33348: LD_INT 2
33350: ARRAY
33351: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_VAR 0 1
33361: PPUSH
33362: LD_VAR 0 6
33366: PPUSH
33367: LD_INT 1
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: CALL 31130 0 4
33393: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_VAR 0 1
33403: PPUSH
33404: LD_VAR 0 6
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 1
33416: PUSH
33417: LD_VAR 0 6
33421: PUSH
33422: LD_INT 1
33424: MINUS
33425: ARRAY
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: CALL 31130 0 4
33435: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PUSH
33451: LD_INT 1
33453: MINUS
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: LD_VAR 0 7
33462: PPUSH
33463: CALL 31130 0 4
33467: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33468: LD_ADDR_VAR 0 1
33472: PUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 6
33482: PUSH
33483: LD_INT 1
33485: MINUS
33486: PPUSH
33487: LD_INT 2
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: CALL 31130 0 4
33499: ST_TO_ADDR
// end ; end ;
33500: GO 33209
33502: POP
33503: POP
// end ;
33504: GO 33191
33506: POP
33507: POP
// result := list ;
33508: LD_ADDR_VAR 0 4
33512: PUSH
33513: LD_VAR 0 1
33517: ST_TO_ADDR
// end ;
33518: LD_VAR 0 4
33522: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33523: LD_INT 0
33525: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33526: LD_ADDR_VAR 0 5
33530: PUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: LD_VAR 0 2
33540: PPUSH
33541: CALL_OW 546
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PUSH
33550: LD_VAR 0 3
33554: PPUSH
33555: LD_VAR 0 4
33559: PPUSH
33560: CALL_OW 546
33564: PUSH
33565: LD_INT 2
33567: ARRAY
33568: MINUS
33569: ST_TO_ADDR
// if result < 0 then
33570: LD_VAR 0 5
33574: PUSH
33575: LD_INT 0
33577: LESS
33578: IFFALSE 33595
// result := result * - 1 ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_VAR 0 5
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: MUL
33594: ST_TO_ADDR
// end ;
33595: LD_VAR 0 5
33599: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
// area = ListEnvironmentArea ( area ) ;
33604: LD_ADDR_VAR 0 2
33608: PUSH
33609: LD_VAR 0 2
33613: PPUSH
33614: CALL_OW 353
33618: ST_TO_ADDR
// if bulldozer > 0 then
33619: LD_VAR 0 1
33623: PUSH
33624: LD_INT 0
33626: GREATER
33627: IFFALSE 33738
// for i = area downto 1 do
33629: LD_ADDR_VAR 0 4
33633: PUSH
33634: DOUBLE
33635: LD_VAR 0 2
33639: INC
33640: ST_TO_ADDR
33641: LD_INT 1
33643: PUSH
33644: FOR_DOWNTO
33645: IFFALSE 33736
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33647: LD_VAR 0 2
33651: PUSH
33652: LD_VAR 0 4
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_VAR 0 2
33666: PUSH
33667: LD_VAR 0 4
33671: ARRAY
33672: PUSH
33673: LD_INT 2
33675: ARRAY
33676: PPUSH
33677: CALL_OW 351
33681: IFFALSE 33734
// if not HasTask ( bulldozer ) then
33683: LD_VAR 0 1
33687: PPUSH
33688: CALL_OW 314
33692: NOT
33693: IFFALSE 33734
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33695: LD_VAR 0 1
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_VAR 0 4
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PPUSH
33715: LD_VAR 0 2
33719: PUSH
33720: LD_VAR 0 4
33724: ARRAY
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: PPUSH
33730: CALL_OW 171
33734: GO 33644
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 3
33742: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33749: LD_ADDR_VAR 0 6
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_VAR 0 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 21
33768: PUSH
33769: LD_VAR 0 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PPUSH
33782: CALL_OW 69
33786: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33787: LD_ADDR_VAR 0 7
33791: PUSH
33792: LD_VAR 0 3
33796: PPUSH
33797: LD_INT 22
33799: PUSH
33800: LD_VAR 0 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 21
33811: PUSH
33812: LD_VAR 0 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PPUSH
33825: CALL_OW 70
33829: ST_TO_ADDR
// if tmp and pom then
33830: LD_VAR 0 6
33834: PUSH
33835: LD_VAR 0 7
33839: AND
33840: IFFALSE 33860
// result := tmp diff pom else
33842: LD_ADDR_VAR 0 4
33846: PUSH
33847: LD_VAR 0 6
33851: PUSH
33852: LD_VAR 0 7
33856: DIFF
33857: ST_TO_ADDR
33858: GO 33868
// result := false ;
33860: LD_ADDR_VAR 0 4
33864: PUSH
33865: LD_INT 0
33867: ST_TO_ADDR
// end ;
33868: LD_VAR 0 4
33872: RET
// export function SavePosition ( unit ) ; begin
33873: LD_INT 0
33875: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: LD_VAR 0 1
33885: PPUSH
33886: CALL_OW 250
33890: PPUSH
33891: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 251
33909: PPUSH
33910: CALL_OW 232
// end ;
33914: LD_VAR 0 2
33918: RET
// export function GetPosition ( unit ) ; begin
33919: LD_INT 0
33921: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33922: LD_ADDR_VAR 0 2
33926: PUSH
33927: LD_VAR 0 1
33931: PPUSH
33932: CALL_OW 252
33936: PUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL_OW 253
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: ST_TO_ADDR
// end ;
33951: LD_VAR 0 2
33955: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33956: LD_INT 0
33958: PPUSH
// if unit in unreachableList then
33959: LD_VAR 0 1
33963: PUSH
33964: LD_EXP 30
33968: IN
33969: IFFALSE 33987
// unreachableList := unreachableList diff unit ;
33971: LD_ADDR_EXP 30
33975: PUSH
33976: LD_EXP 30
33980: PUSH
33981: LD_VAR 0 1
33985: DIFF
33986: ST_TO_ADDR
// if ValidHex ( x , y ) then
33987: LD_VAR 0 2
33991: PPUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: CALL_OW 488
34001: IFFALSE 34027
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_VAR 0 2
34012: PPUSH
34013: LD_VAR 0 3
34017: PPUSH
34018: CALL_OW 428
34022: PPUSH
34023: CALL_OW 115
// Wait ( 3 ) ;
34027: LD_INT 3
34029: PPUSH
34030: CALL_OW 67
// if unit in unreachableList then
34034: LD_VAR 0 1
34038: PUSH
34039: LD_EXP 30
34043: IN
34044: IFFALSE 34056
// result := false else
34046: LD_ADDR_VAR 0 4
34050: PUSH
34051: LD_INT 0
34053: ST_TO_ADDR
34054: GO 34064
// result := true ;
34056: LD_ADDR_VAR 0 4
34060: PUSH
34061: LD_INT 1
34063: ST_TO_ADDR
// end ; end_of_file
34064: LD_VAR 0 4
34068: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34069: LD_EXP 31
34073: IFFALSE 34135
34075: GO 34077
34077: DISABLE
34078: LD_INT 0
34080: PPUSH
// begin enable ;
34081: ENABLE
// for i = 1 to mc_crates_list do
34082: LD_ADDR_VAR 0 1
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 32
34096: PUSH
34097: FOR_TO
34098: IFFALSE 34129
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34100: LD_EXP 32
34104: PUSH
34105: LD_VAR 0 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 5
34113: PPUSH
34114: LD_INT 50
34116: PPUSH
34117: LD_INT 700
34119: PPUSH
34120: LD_INT 20
34122: PPUSH
34123: CALL 24485 0 5
34127: GO 34097
34129: POP
34130: POP
// MC_Game ( ) ;
34131: CALL 34138 0 0
// end ;
34135: PPOPN 1
34137: END
// export function MC_Game ( ) ; var i , side , un ; begin
34138: LD_INT 0
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not isTest then
34144: LD_EXP 1
34148: NOT
34149: IFFALSE 34169
// MC_Show ( [ #tick , tick ] ) else
34151: LD_STRING #tick
34153: PUSH
34154: LD_OWVAR 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PPUSH
34163: CALL 8569 0 1
34167: GO 34178
// MC_Show ( debug_string ) ;
34169: LD_EXP 2
34173: PPUSH
34174: CALL 8569 0 1
// for side = 1 to 8 do
34178: LD_ADDR_VAR 0 3
34182: PUSH
34183: DOUBLE
34184: LD_INT 1
34186: DEC
34187: ST_TO_ADDR
34188: LD_INT 8
34190: PUSH
34191: FOR_TO
34192: IFFALSE 36192
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34194: LD_EXP 39
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PUSH
34205: LD_INT 0
34207: EQUAL
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: EMPTY
34215: PPUSH
34216: CALL 11786 0 2
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: OR
34225: IFFALSE 34229
// continue ;
34227: GO 34191
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34229: LD_VAR 0 3
34233: PPUSH
34234: LD_VAR 0 3
34238: PPUSH
34239: CALL 25006 0 1
34243: PPUSH
34244: CALL 36199 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34248: LD_EXP 71
34252: PUSH
34253: LD_VAR 0 3
34257: ARRAY
34258: PUSH
34259: LD_INT 1
34261: ARRAY
34262: PUSH
34263: LD_INT 0
34265: GREATER
34266: PUSH
34267: LD_EXP 69
34271: PUSH
34272: LD_VAR 0 3
34276: ARRAY
34277: PUSH
34278: LD_INT 1
34280: ARRAY
34281: PUSH
34282: LD_INT 0
34284: EQUAL
34285: AND
34286: PUSH
34287: LD_VAR 0 3
34291: PPUSH
34292: LD_INT 7
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL 12354 0 3
34301: NOT
34302: AND
34303: IFFALSE 34340
// begin for i in MREG_Attackers [ side ] do
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_EXP 71
34314: PUSH
34315: LD_VAR 0 3
34319: ARRAY
34320: PUSH
34321: FOR_IN
34322: IFFALSE 34338
// SetTag ( i , 7 ) ;
34324: LD_VAR 0 2
34328: PPUSH
34329: LD_INT 7
34331: PPUSH
34332: CALL_OW 109
34336: GO 34321
34338: POP
34339: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34340: LD_VAR 0 3
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: EMPTY
34349: PPUSH
34350: CALL 12354 0 3
34354: IFFALSE 34414
// begin if side = 1 then
34356: LD_VAR 0 3
34360: PUSH
34361: LD_INT 1
34363: EQUAL
34364: IFFALSE 34373
// RaiseSailEvent ( 101 ) ;
34366: LD_INT 101
34368: PPUSH
34369: CALL_OW 427
// if side = 4 then
34373: LD_VAR 0 3
34377: PUSH
34378: LD_INT 4
34380: EQUAL
34381: IFFALSE 34390
// RaiseSailEvent ( 102 ) ;
34383: LD_INT 102
34385: PPUSH
34386: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: LD_INT 7
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL 12354 0 3
34409: PPUSH
34410: CALL 8487 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 18034 0 1
34423: PUSH
34424: LD_VAR 0 3
34428: PPUSH
34429: CALL 11690 0 1
34433: AND
34434: IFFALSE 34445
// MCL_Start ( side ) ;
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 17991 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34445: LD_ADDR_EXP 35
34449: PUSH
34450: LD_EXP 35
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL 19291 0 1
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34475: LD_ADDR_EXP 47
34479: PUSH
34480: LD_EXP 47
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL 11104 0 1
34499: PPUSH
34500: CALL_OW 1
34504: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34505: LD_VAR 0 3
34509: PPUSH
34510: LD_INT 21
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PPUSH
34520: CALL 11651 0 2
34524: IFFALSE 34535
// MCV_CheckStatus ( side ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL 27188 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 53
34544: PPUSH
34545: CALL 42999 0 2
34549: IFFALSE 34634
// begin for i = MREG_ToChangeClass downto 1 do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_EXP 53
34561: INC
34562: ST_TO_ADDR
34563: LD_INT 1
34565: PUSH
34566: FOR_DOWNTO
34567: IFFALSE 34632
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34569: LD_EXP 53
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 1
34582: ARRAY
34583: PUSH
34584: LD_VAR 0 3
34588: EQUAL
34589: IFFALSE 34630
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34591: LD_VAR 0 3
34595: PPUSH
34596: LD_EXP 53
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_INT 2
34609: ARRAY
34610: PPUSH
34611: LD_EXP 53
34615: PUSH
34616: LD_VAR 0 2
34620: ARRAY
34621: PUSH
34622: LD_INT 3
34624: ARRAY
34625: PPUSH
34626: CALL 16558 0 3
// end ; end ;
34630: GO 34566
34632: POP
34633: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34634: LD_INT 1
34636: PUSH
34637: LD_EXP 38
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: IN
34648: IFFALSE 34659
// begin MCN_TrainApe ( side ) ;
34650: LD_VAR 0 3
34654: PPUSH
34655: CALL 18944 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34659: LD_VAR 0 3
34663: PPUSH
34664: LD_INT 30
34666: PUSH
34667: LD_INT 3
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PPUSH
34674: CALL 11651 0 2
34678: IFFALSE 34852
// begin if MCF_Tag ( side , 10 , [ ] ) then
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 10
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL 12354 0 3
34694: IFFALSE 34741
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12354 0 3
34710: PPUSH
34711: LD_VAR 0 3
34715: PPUSH
34716: LD_INT 30
34718: PUSH
34719: LD_INT 3
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PPUSH
34726: CALL 11651 0 2
34730: PUSH
34731: LD_INT 1
34733: ARRAY
34734: PPUSH
34735: CALL_OW 168
// end else
34739: GO 34852
// if MREG_ToConstruct [ side ] then
34741: LD_EXP 51
34745: PUSH
34746: LD_VAR 0 3
34750: ARRAY
34751: IFFALSE 34852
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_VAR 0 3
34762: PPUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 3
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PPUSH
34773: CALL 11651 0 2
34777: PUSH
34778: LD_INT 1
34780: ARRAY
34781: PPUSH
34782: LD_EXP 51
34786: PUSH
34787: LD_VAR 0 3
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_EXP 51
34801: PUSH
34802: LD_VAR 0 3
34806: ARRAY
34807: PUSH
34808: LD_INT 2
34810: ARRAY
34811: PUSH
34812: LD_EXP 51
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 3
34825: ARRAY
34826: PUSH
34827: LD_EXP 51
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 4
34840: ARRAY
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL 25496 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34852: LD_VAR 0 3
34856: PPUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL 11651 0 2
34871: PUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_EXP 43
34881: PPUSH
34882: CALL 42999 0 2
34886: AND
34887: PUSH
34888: LD_INT 22
34890: PUSH
34891: LD_VAR 0 3
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 33
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 32
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 35
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL_OW 69
34947: AND
34948: IFFALSE 34959
// MCV_Turret ( side ) ;
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 25933 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34959: LD_EXP 42
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: GREATER
34973: PUSH
34974: LD_VAR 0 3
34978: PPUSH
34979: CALL 25006 0 1
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: AND
34988: IFFALSE 35150
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34990: LD_EXP 42
34994: PUSH
34995: LD_VAR 0 3
34999: ARRAY
35000: PUSH
35001: LD_INT 1
35003: ARRAY
35004: PPUSH
35005: CALL_OW 353
35009: IFFALSE 35047
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35011: LD_EXP 42
35015: PUSH
35016: LD_VAR 0 3
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: PPUSH
35026: LD_EXP 42
35030: PUSH
35031: LD_VAR 0 3
35035: ARRAY
35036: PUSH
35037: LD_INT 1
35039: ARRAY
35040: PPUSH
35041: CALL 32428 0 2
35045: GO 35150
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PPUSH
35062: CALL 11651 0 2
35066: IFFALSE 35150
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35068: LD_VAR 0 3
35072: PPUSH
35073: LD_INT 30
35075: PUSH
35076: LD_INT 3
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PPUSH
35083: CALL 11651 0 2
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 2
35099: EQUAL
35100: IFFALSE 35150
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35102: LD_EXP 42
35106: PUSH
35107: LD_VAR 0 3
35111: ARRAY
35112: PUSH
35113: LD_INT 2
35115: ARRAY
35116: PPUSH
35117: LD_INT 10
35119: PPUSH
35120: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35124: LD_ADDR_EXP 42
35128: PUSH
35129: LD_EXP 42
35133: PPUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PPUSH
35165: CALL 11651 0 2
35169: IFFALSE 35209
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PPUSH
35191: CALL 11651 0 2
35195: PUSH
35196: LD_INT 1
35198: ARRAY
35199: PPUSH
35200: CALL_OW 248
35204: PPUSH
35205: CALL 26487 0 2
// if MREG_ToRepair [ side ] then
35209: LD_EXP 47
35213: PUSH
35214: LD_VAR 0 3
35218: ARRAY
35219: IFFALSE 35232
// begin MCB_Repair ( side ) ;
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL 11391 0 1
// end else
35230: GO 36145
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35232: LD_VAR 0 3
35236: PPUSH
35237: LD_EXP 49
35241: PPUSH
35242: CALL 42999 0 2
35246: PUSH
35247: LD_VAR 0 3
35251: PPUSH
35252: LD_EXP 40
35256: PPUSH
35257: CALL 42999 0 2
35261: AND
35262: IFFALSE 35470
// begin for i = 1 to MREG_ToUpLab do
35264: LD_ADDR_VAR 0 2
35268: PUSH
35269: DOUBLE
35270: LD_INT 1
35272: DEC
35273: ST_TO_ADDR
35274: LD_EXP 49
35278: PUSH
35279: FOR_TO
35280: IFFALSE 35466
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35282: LD_EXP 49
35286: PUSH
35287: LD_VAR 0 2
35291: ARRAY
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PUSH
35297: LD_VAR 0 3
35301: EQUAL
35302: IFFALSE 35464
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35304: LD_EXP 49
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PUSH
35319: LD_EXP 49
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: PUSH
35330: LD_INT 3
35332: ARRAY
35333: AND
35334: IFFALSE 35462
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: LD_EXP 49
35345: PUSH
35346: LD_VAR 0 2
35350: ARRAY
35351: PUSH
35352: LD_INT 2
35354: ARRAY
35355: PPUSH
35356: LD_EXP 49
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 3
35369: ARRAY
35370: PPUSH
35371: CALL 8915 0 3
35375: IFFALSE 35462
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35377: LD_ADDR_EXP 49
35381: PUSH
35382: LD_EXP 49
35386: PPUSH
35387: LD_VAR 0 3
35391: PPUSH
35392: LD_EXP 49
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: PUSH
35403: LD_INT 2
35405: ARRAY
35406: PPUSH
35407: LD_EXP 49
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 3
35420: ARRAY
35421: PPUSH
35422: CALL 42051 0 4
35426: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35427: LD_ADDR_EXP 40
35431: PUSH
35432: LD_EXP 40
35436: PPUSH
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_EXP 40
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL 42051 0 4
35461: ST_TO_ADDR
// end ; break ;
35462: GO 35466
// end ;
35464: GO 35279
35466: POP
35467: POP
// end else
35468: GO 36145
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: LD_EXP 48
35479: PPUSH
35480: CALL 42999 0 2
35484: IFFALSE 35558
// begin for i = 1 to MREG_ToUpdate do
35486: LD_ADDR_VAR 0 2
35490: PUSH
35491: DOUBLE
35492: LD_INT 1
35494: DEC
35495: ST_TO_ADDR
35496: LD_EXP 48
35500: PUSH
35501: FOR_TO
35502: IFFALSE 35554
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35504: LD_EXP 48
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PUSH
35519: LD_VAR 0 3
35523: EQUAL
35524: IFFALSE 35552
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_EXP 48
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_INT 2
35544: ARRAY
35545: PPUSH
35546: CALL 8751 0 2
// break ;
35550: GO 35554
// end ;
35552: GO 35501
35554: POP
35555: POP
// end else
35556: GO 36145
// if MCF_Get ( side , [ f_constructed ] ) then
35558: LD_VAR 0 3
35562: PPUSH
35563: LD_INT 57
35565: PUSH
35566: EMPTY
35567: LIST
35568: PPUSH
35569: CALL 11651 0 2
35573: IFFALSE 35606
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_INT 57
35587: PUSH
35588: EMPTY
35589: LIST
35590: PPUSH
35591: CALL 11651 0 2
35595: PUSH
35596: LD_INT 1
35598: ARRAY
35599: PPUSH
35600: CALL 10995 0 2
35604: GO 36145
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_EXP 46
35615: PPUSH
35616: CALL 42999 0 2
35620: PUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 345
35630: NOT
35631: AND
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL 25006 0 1
35642: PUSH
35643: LD_INT 0
35645: EQUAL
35646: AND
35647: IFFALSE 36046
// begin for i = 1 to MREG_ToBuild do
35649: LD_ADDR_VAR 0 2
35653: PUSH
35654: DOUBLE
35655: LD_INT 1
35657: DEC
35658: ST_TO_ADDR
35659: LD_EXP 46
35663: PUSH
35664: FOR_TO
35665: IFFALSE 36042
// if MREG_ToBuild [ i ] [ 1 ] = side then
35667: LD_EXP 46
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 1
35680: ARRAY
35681: PUSH
35682: LD_VAR 0 3
35686: EQUAL
35687: IFFALSE 36040
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35689: LD_OWVAR 84
35693: PUSH
35694: LD_EXP 46
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 3
35707: ARRAY
35708: PUSH
35709: LD_INT 1
35711: ARRAY
35712: PPUSH
35713: LD_EXP 46
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PUSH
35728: LD_INT 2
35730: ARRAY
35731: PPUSH
35732: CALL_OW 351
35736: AND
35737: IFFALSE 35781
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35739: LD_EXP 46
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 46
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL 22799 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35781: LD_EXP 46
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 2
35794: ARRAY
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: IFFALSE 35869
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35801: LD_VAR 0 3
35805: PPUSH
35806: LD_EXP 46
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PUSH
35821: LD_INT 1
35823: ARRAY
35824: PPUSH
35825: LD_EXP 46
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 3
35838: ARRAY
35839: PUSH
35840: LD_INT 2
35842: ARRAY
35843: PPUSH
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 3
35857: ARRAY
35858: PUSH
35859: LD_INT 3
35861: ARRAY
35862: PPUSH
35863: CALL 8587 0 4
35867: GO 36038
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PUSH
35884: LD_INT 6
35886: EQUAL
35887: IFFALSE 35957
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35889: LD_VAR 0 3
35893: PPUSH
35894: LD_EXP 46
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 3
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PPUSH
35913: LD_EXP 46
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 3
35926: ARRAY
35927: PUSH
35928: LD_INT 2
35930: ARRAY
35931: PPUSH
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL 8716 0 4
35955: GO 36038
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35957: LD_VAR 0 3
35961: PPUSH
35962: LD_EXP 46
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 46
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PPUSH
35996: LD_EXP 46
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 2
36013: ARRAY
36014: PPUSH
36015: LD_EXP 46
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 3
36028: ARRAY
36029: PUSH
36030: LD_INT 3
36032: ARRAY
36033: PPUSH
36034: CALL 10220 0 5
// break ;
36038: GO 36042
// end ;
36040: GO 35664
36042: POP
36043: POP
// end else
36044: GO 36145
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36046: LD_VAR 0 3
36050: PPUSH
36051: LD_EXP 52
36055: PPUSH
36056: CALL 42999 0 2
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL 25006 0 1
36070: PUSH
36071: LD_INT 0
36073: EQUAL
36074: AND
36075: IFFALSE 36145
// begin for i = 1 to MREG_ToDismantle do
36077: LD_ADDR_VAR 0 2
36081: PUSH
36082: DOUBLE
36083: LD_INT 1
36085: DEC
36086: ST_TO_ADDR
36087: LD_EXP 52
36091: PUSH
36092: FOR_TO
36093: IFFALSE 36143
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36095: LD_EXP 52
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PUSH
36106: LD_INT 1
36108: ARRAY
36109: PUSH
36110: LD_VAR 0 3
36114: EQUAL
36115: IFFALSE 36141
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36117: LD_VAR 0 3
36121: PPUSH
36122: LD_EXP 52
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: CALL 10886 0 2
// end ;
36141: GO 36092
36143: POP
36144: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36145: LD_VAR 0 3
36149: PPUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PPUSH
36160: CALL 11651 0 2
36164: PUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL 25006 0 1
36174: PUSH
36175: LD_INT 0
36177: EQUAL
36178: AND
36179: IFFALSE 36190
// MCT_CollectCrates ( side ) ;
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 23945 0 1
// end ;
36190: GO 34191
36192: POP
36193: POP
// end ;
36194: LD_VAR 0 1
36198: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36199: LD_INT 0
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
// all := MCF_All ( side , [ ] ) ;
36216: LD_ADDR_VAR 0 17
36220: PUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL 11786 0 2
36232: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36233: LD_ADDR_VAR 0 13
36237: PUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_INT 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL 11734 0 3
36252: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36253: LD_ADDR_VAR 0 14
36257: PUSH
36258: LD_VAR 0 1
36262: PPUSH
36263: LD_INT 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL 11734 0 3
36272: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36273: LD_ADDR_VAR 0 15
36277: PUSH
36278: LD_VAR 0 1
36282: PPUSH
36283: LD_INT 3
36285: PPUSH
36286: EMPTY
36287: PPUSH
36288: CALL 11734 0 3
36292: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36293: LD_ADDR_VAR 0 16
36297: PUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_INT 4
36305: PPUSH
36306: EMPTY
36307: PPUSH
36308: CALL 11734 0 3
36312: ST_TO_ADDR
// if mech then
36313: LD_VAR 0 15
36317: IFFALSE 36334
// mech := MCF_SortListDesc ( mech ) ;
36319: LD_ADDR_VAR 0 15
36323: PUSH
36324: LD_VAR 0 15
36328: PPUSH
36329: CALL 12900 0 1
36333: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36334: LD_EXP 56
36338: PUSH
36339: LD_VAR 0 1
36343: ARRAY
36344: PUSH
36345: LD_STRING 
36347: EQUAL
36348: NOT
36349: IFFALSE 36405
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36351: LD_EXP 56
36355: PUSH
36356: LD_VAR 0 1
36360: ARRAY
36361: PUSH
36362: LD_INT 1
36364: ARRAY
36365: PPUSH
36366: CALL_OW 257
36370: PUSH
36371: LD_INT 1
36373: EQUAL
36374: IFFALSE 36403
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36376: LD_VAR 0 1
36380: PPUSH
36381: LD_STRING ToArm
36383: PPUSH
36384: LD_EXP 56
36388: PUSH
36389: LD_VAR 0 1
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL 14530 0 3
// end else
36403: GO 36431
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36405: LD_ADDR_EXP 56
36409: PUSH
36410: LD_EXP 56
36414: PPUSH
36415: LD_VAR 0 1
36419: PPUSH
36420: LD_INT 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL 31130 0 4
36430: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36431: LD_EXP 57
36435: PUSH
36436: LD_VAR 0 1
36440: ARRAY
36441: PUSH
36442: LD_STRING 
36444: EQUAL
36445: NOT
36446: IFFALSE 36502
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36448: LD_EXP 57
36452: PUSH
36453: LD_VAR 0 1
36457: ARRAY
36458: PUSH
36459: LD_INT 1
36461: ARRAY
36462: PPUSH
36463: CALL_OW 257
36467: PUSH
36468: LD_INT 2
36470: EQUAL
36471: IFFALSE 36500
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36473: LD_VAR 0 1
36477: PPUSH
36478: LD_STRING ToDep
36480: PPUSH
36481: LD_EXP 57
36485: PUSH
36486: LD_VAR 0 1
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: CALL 14530 0 3
// end else
36500: GO 36528
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36502: LD_ADDR_EXP 57
36506: PUSH
36507: LD_EXP 57
36511: PPUSH
36512: LD_VAR 0 1
36516: PPUSH
36517: LD_INT 1
36519: PPUSH
36520: LD_INT 0
36522: PPUSH
36523: CALL 31130 0 4
36527: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36528: LD_EXP 55
36532: PUSH
36533: LD_VAR 0 1
36537: ARRAY
36538: PUSH
36539: LD_STRING 
36541: EQUAL
36542: NOT
36543: IFFALSE 36599
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36545: LD_EXP 55
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: EQUAL
36568: IFFALSE 36597
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: LD_STRING ToFac
36577: PPUSH
36578: LD_EXP 55
36582: PUSH
36583: LD_VAR 0 1
36587: ARRAY
36588: PUSH
36589: LD_INT 1
36591: ARRAY
36592: PPUSH
36593: CALL 14530 0 3
// end else
36597: GO 36625
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36599: LD_ADDR_EXP 55
36603: PUSH
36604: LD_EXP 55
36608: PPUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: LD_INT 0
36619: PPUSH
36620: CALL 31130 0 4
36624: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36625: LD_EXP 54
36629: PUSH
36630: LD_VAR 0 1
36634: ARRAY
36635: PUSH
36636: LD_STRING 
36638: EQUAL
36639: NOT
36640: IFFALSE 36696
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36642: LD_EXP 54
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL_OW 257
36661: PUSH
36662: LD_INT 4
36664: EQUAL
36665: IFFALSE 36694
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36667: LD_VAR 0 1
36671: PPUSH
36672: LD_STRING ToLab
36674: PPUSH
36675: LD_EXP 54
36679: PUSH
36680: LD_VAR 0 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: CALL 14530 0 3
// end else
36694: GO 36722
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36696: LD_ADDR_EXP 54
36700: PUSH
36701: LD_EXP 54
36705: PPUSH
36706: LD_VAR 0 1
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: LD_INT 0
36716: PPUSH
36717: CALL 31130 0 4
36721: ST_TO_ADDR
// if mode = 0 then
36722: LD_VAR 0 2
36726: PUSH
36727: LD_INT 0
36729: EQUAL
36730: IFFALSE 38568
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36732: LD_VAR 0 1
36736: PPUSH
36737: LD_INT 30
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL 11651 0 2
36751: PUSH
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 21
36759: PUSH
36760: LD_INT 3
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PPUSH
36767: CALL 11651 0 2
36771: PUSH
36772: LD_INT 1
36774: EQUAL
36775: AND
36776: IFFALSE 36841
// begin if all then
36778: LD_VAR 0 17
36782: IFFALSE 36839
// for i in ( all diff eng ) do
36784: LD_ADDR_VAR 0 4
36788: PUSH
36789: LD_VAR 0 17
36793: PUSH
36794: LD_VAR 0 14
36798: DIFF
36799: PUSH
36800: FOR_IN
36801: IFFALSE 36837
// if GetTag ( i ) = 0 then
36803: LD_VAR 0 4
36807: PPUSH
36808: CALL_OW 110
36812: PUSH
36813: LD_INT 0
36815: EQUAL
36816: IFFALSE 36835
// MCH_ChangeClass ( side , i , 2 ) ;
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 2
36830: PPUSH
36831: CALL 16558 0 3
36835: GO 36800
36837: POP
36838: POP
// end else
36839: GO 37160
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36841: LD_VAR 0 13
36845: PUSH
36846: LD_EXP 56
36850: PUSH
36851: LD_VAR 0 1
36855: ARRAY
36856: PLUS
36857: PUSH
36858: LD_INT 22
36860: PUSH
36861: LD_VAR 0 1
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 32
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 69
36888: LESS
36889: IFFALSE 36914
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_VAR 0 14
36900: PUSH
36901: LD_INT 1
36903: ARRAY
36904: PPUSH
36905: LD_INT 1
36907: PPUSH
36908: CALL 16558 0 3
// end else
36912: GO 37160
// if sci < 6 and MCF_Lab ( side ) then
36914: LD_VAR 0 16
36918: PUSH
36919: LD_INT 6
36921: LESS
36922: PUSH
36923: LD_VAR 0 1
36927: PPUSH
36928: CALL 11690 0 1
36932: AND
36933: IFFALSE 37038
// begin if MREG_ToBunker [ side ] then
36935: LD_EXP 68
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: IFFALSE 36971
// tmp := sol diff MREG_ToBunker [ side ] else
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: PUSH
36957: LD_EXP 68
36961: PUSH
36962: LD_VAR 0 1
36966: ARRAY
36967: DIFF
36968: ST_TO_ADDR
36969: GO 36981
// tmp := sol ;
36971: LD_ADDR_VAR 0 12
36975: PUSH
36976: LD_VAR 0 13
36980: ST_TO_ADDR
// if tmp then
36981: LD_VAR 0 12
36985: IFFALSE 37036
// for i in tmp do
36987: LD_ADDR_VAR 0 4
36991: PUSH
36992: LD_VAR 0 12
36996: PUSH
36997: FOR_IN
36998: IFFALSE 37034
// if GetTag ( i ) = 0 then
37000: LD_VAR 0 4
37004: PPUSH
37005: CALL_OW 110
37009: PUSH
37010: LD_INT 0
37012: EQUAL
37013: IFFALSE 37032
// MCH_ChangeClass ( side , i , 4 ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: LD_INT 4
37027: PPUSH
37028: CALL 16558 0 3
37032: GO 36997
37034: POP
37035: POP
// end else
37036: GO 37160
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37038: LD_VAR 0 1
37042: PPUSH
37043: LD_INT 30
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL 11651 0 2
37057: IFFALSE 37160
// begin if MREG_ToBunker [ side ] then
37059: LD_EXP 68
37063: PUSH
37064: LD_VAR 0 1
37068: ARRAY
37069: IFFALSE 37095
// tmp := sol diff MREG_ToBunker [ side ] else
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: PUSH
37081: LD_EXP 68
37085: PUSH
37086: LD_VAR 0 1
37090: ARRAY
37091: DIFF
37092: ST_TO_ADDR
37093: GO 37105
// tmp := sol ;
37095: LD_ADDR_VAR 0 12
37099: PUSH
37100: LD_VAR 0 13
37104: ST_TO_ADDR
// if tmp then
37105: LD_VAR 0 12
37109: IFFALSE 37160
// for i in tmp do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 12
37120: PUSH
37121: FOR_IN
37122: IFFALSE 37158
// if GetTag ( i ) = 0 then
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL_OW 110
37133: PUSH
37134: LD_INT 0
37136: EQUAL
37137: IFFALSE 37156
// MCH_ChangeClass ( side , i , 2 ) ;
37139: LD_VAR 0 1
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: LD_INT 2
37151: PPUSH
37152: CALL 16558 0 3
37156: GO 37121
37158: POP
37159: POP
// end ; if MCF_Lab ( side ) then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL 11690 0 1
37169: IFFALSE 37709
// begin if MCL_GetTechList ( side ) then
37171: LD_VAR 0 1
37175: PPUSH
37176: CALL 18034 0 1
37180: IFFALSE 37306
// begin if MREG_ToLab [ side ] then
37182: LD_EXP 54
37186: PUSH
37187: LD_VAR 0 1
37191: ARRAY
37192: IFFALSE 37212
// k := MREG_ToLab [ side ] else
37194: LD_ADDR_VAR 0 8
37198: PUSH
37199: LD_EXP 54
37203: PUSH
37204: LD_VAR 0 1
37208: ARRAY
37209: ST_TO_ADDR
37210: GO 37220
// k := 0 ;
37212: LD_ADDR_VAR 0 8
37216: PUSH
37217: LD_INT 0
37219: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37220: LD_VAR 0 16
37224: PUSH
37225: LD_VAR 0 8
37229: PLUS
37230: PUSH
37231: LD_INT 6
37233: LESSEQUAL
37234: PUSH
37235: LD_VAR 0 17
37239: PUSH
37240: LD_INT 6
37242: GREATER
37243: AND
37244: IFFALSE 37260
// MCH_TrainScientist ( side , 1 ) else
37246: LD_VAR 0 1
37250: PPUSH
37251: LD_INT 1
37253: PPUSH
37254: CALL 16110 0 2
37258: GO 37304
// if all < 6 then
37260: LD_VAR 0 17
37264: PUSH
37265: LD_INT 6
37267: LESS
37268: IFFALSE 37304
// if sci + k < all / 2 then
37270: LD_VAR 0 16
37274: PUSH
37275: LD_VAR 0 8
37279: PLUS
37280: PUSH
37281: LD_VAR 0 17
37285: PUSH
37286: LD_INT 2
37288: DIVREAL
37289: LESS
37290: IFFALSE 37304
// MCH_TrainScientist ( side , 1 ) ;
37292: LD_VAR 0 1
37296: PPUSH
37297: LD_INT 1
37299: PPUSH
37300: CALL 16110 0 2
// end else
37304: GO 37382
// begin if sci > 2 then
37306: LD_VAR 0 16
37310: PUSH
37311: LD_INT 2
37313: GREATER
37314: IFFALSE 37382
// for i = sci downto 2 do
37316: LD_ADDR_VAR 0 4
37320: PUSH
37321: DOUBLE
37322: LD_VAR 0 16
37326: INC
37327: ST_TO_ADDR
37328: LD_INT 2
37330: PUSH
37331: FOR_DOWNTO
37332: IFFALSE 37380
// if GetTag ( sci [ i ] ) = 0 then
37334: LD_VAR 0 16
37338: PUSH
37339: LD_VAR 0 4
37343: ARRAY
37344: PPUSH
37345: CALL_OW 110
37349: PUSH
37350: LD_INT 0
37352: EQUAL
37353: IFFALSE 37378
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_VAR 0 16
37364: PUSH
37365: LD_VAR 0 4
37369: ARRAY
37370: PPUSH
37371: LD_INT 2
37373: PPUSH
37374: CALL 16558 0 3
37378: GO 37331
37380: POP
37381: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37382: LD_VAR 0 1
37386: PPUSH
37387: CALL 18034 0 1
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL 11690 0 1
37401: AND
37402: PUSH
37403: LD_EXP 35
37407: PUSH
37408: LD_VAR 0 1
37412: ARRAY
37413: NOT
37414: AND
37415: IFFALSE 37709
// begin for j = 1 to MCF_Lab ( side ) do
37417: LD_ADDR_VAR 0 5
37421: PUSH
37422: DOUBLE
37423: LD_INT 1
37425: DEC
37426: ST_TO_ADDR
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 11690 0 1
37436: PUSH
37437: FOR_TO
37438: IFFALSE 37498
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37440: LD_VAR 0 1
37444: PPUSH
37445: CALL 11690 0 1
37449: PUSH
37450: LD_VAR 0 5
37454: ARRAY
37455: PPUSH
37456: CALL_OW 461
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 6
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: IN
37471: IFFALSE 37496
// begin b := MCF_Lab ( side ) [ j ] ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: CALL 11690 0 1
37487: PUSH
37488: LD_VAR 0 5
37492: ARRAY
37493: ST_TO_ADDR
// break ;
37494: GO 37498
// end ;
37496: GO 37437
37498: POP
37499: POP
// if MCF_Class ( side , 4 , [ ] ) then
37500: LD_VAR 0 1
37504: PPUSH
37505: LD_INT 4
37507: PPUSH
37508: EMPTY
37509: PPUSH
37510: CALL 11734 0 3
37514: IFFALSE 37709
// for j in MCF_Class ( side , 4 , [ ] ) do
37516: LD_ADDR_VAR 0 5
37520: PUSH
37521: LD_VAR 0 1
37525: PPUSH
37526: LD_INT 4
37528: PPUSH
37529: EMPTY
37530: PPUSH
37531: CALL 11734 0 3
37535: PUSH
37536: FOR_IN
37537: IFFALSE 37707
// begin if GetTag ( j ) = 0 then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 110
37548: PUSH
37549: LD_INT 0
37551: EQUAL
37552: IFFALSE 37643
// begin if IsInUnit ( j ) and b then
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 310
37563: PUSH
37564: LD_VAR 0 11
37568: AND
37569: IFFALSE 37617
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37571: LD_VAR 0 5
37575: PPUSH
37576: CALL_OW 310
37580: PPUSH
37581: CALL_OW 461
37585: PUSH
37586: LD_INT 2
37588: EQUAL
37589: PUSH
37590: LD_VAR 0 5
37594: PPUSH
37595: CALL_OW 310
37599: PUSH
37600: LD_VAR 0 11
37604: NONEQUAL
37605: AND
37606: IFFALSE 37617
// ComExitBuilding ( j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 122
// if not IsInUnit ( j ) then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: NOT
37627: IFFALSE 37643
// ComEnterUnit ( j , b ) ;
37629: LD_VAR 0 5
37633: PPUSH
37634: LD_VAR 0 11
37638: PPUSH
37639: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37643: LD_INT 1
37645: PPUSH
37646: LD_VAR 0 5
37650: PPUSH
37651: CALL_OW 255
37655: PPUSH
37656: CALL_OW 321
37660: PUSH
37661: LD_INT 2
37663: EQUAL
37664: PUSH
37665: LD_VAR 0 5
37669: PPUSH
37670: CALL_OW 255
37674: PPUSH
37675: CALL 25006 0 1
37679: PUSH
37680: LD_INT 0
37682: EQUAL
37683: AND
37684: IFFALSE 37705
// MCN_Tame ( GetSide ( j ) , j ) ;
37686: LD_VAR 0 5
37690: PPUSH
37691: CALL_OW 255
37695: PPUSH
37696: LD_VAR 0 5
37700: PPUSH
37701: CALL 18553 0 2
// end ;
37705: GO 37536
37707: POP
37708: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37709: LD_VAR 0 1
37713: PPUSH
37714: LD_INT 30
37716: PUSH
37717: LD_INT 3
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PPUSH
37724: CALL 11651 0 2
37728: IFFALSE 37987
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37730: LD_ADDR_VAR 0 11
37734: PUSH
37735: LD_VAR 0 1
37739: PPUSH
37740: LD_INT 30
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PPUSH
37750: CALL 11651 0 2
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37759: LD_ADDR_VAR 0 12
37763: PUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: LD_INT 0
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 3
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL 12354 0 3
37786: ST_TO_ADDR
// for i = 1 to tmp do
37787: LD_ADDR_VAR 0 4
37791: PUSH
37792: DOUBLE
37793: LD_INT 1
37795: DEC
37796: ST_TO_ADDR
37797: LD_VAR 0 12
37801: PUSH
37802: FOR_TO
37803: IFFALSE 37863
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37805: LD_VAR 0 12
37809: PUSH
37810: LD_VAR 0 4
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: NOT
37821: PUSH
37822: LD_VAR 0 12
37826: PUSH
37827: LD_VAR 0 4
37831: ARRAY
37832: PPUSH
37833: CALL_OW 314
37837: NOT
37838: AND
37839: IFFALSE 37861
// ComEnterUnit ( tmp [ i ] , b ) ;
37841: LD_VAR 0 12
37845: PUSH
37846: LD_VAR 0 4
37850: ARRAY
37851: PPUSH
37852: LD_VAR 0 11
37856: PPUSH
37857: CALL_OW 120
37861: GO 37802
37863: POP
37864: POP
// if MREG_ToFac [ side ] then
37865: LD_EXP 55
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: IFFALSE 37895
// k := MREG_ToFac [ side ] else
37877: LD_ADDR_VAR 0 8
37881: PUSH
37882: LD_EXP 55
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: ST_TO_ADDR
37893: GO 37903
// k := 0 ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_INT 0
37902: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37903: LD_VAR 0 15
37907: PUSH
37908: LD_VAR 0 8
37912: PLUS
37913: PUSH
37914: LD_INT 6
37916: LESSEQUAL
37917: PUSH
37918: LD_VAR 0 17
37922: PUSH
37923: LD_INT 6
37925: GREATER
37926: AND
37927: IFFALSE 37943
// MCH_TrainMechanic ( side , 1 ) else
37929: LD_VAR 0 1
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL 15852 0 2
37941: GO 37987
// if all < 6 then
37943: LD_VAR 0 17
37947: PUSH
37948: LD_INT 6
37950: LESS
37951: IFFALSE 37987
// if mech + k < all / 2 then
37953: LD_VAR 0 15
37957: PUSH
37958: LD_VAR 0 8
37962: PLUS
37963: PUSH
37964: LD_VAR 0 17
37968: PUSH
37969: LD_INT 2
37971: DIVREAL
37972: LESS
37973: IFFALSE 37987
// MCH_TrainMechanic ( side , 1 ) ;
37975: LD_VAR 0 1
37979: PPUSH
37980: LD_INT 1
37982: PPUSH
37983: CALL 15852 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37987: LD_ADDR_VAR 0 10
37991: PUSH
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 30
37999: PUSH
38000: LD_INT 36
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL 11651 0 2
38011: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38012: LD_VAR 0 10
38016: PUSH
38017: LD_VAR 0 15
38021: AND
38022: PUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 3
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL 11734 0 3
38037: AND
38038: IFFALSE 38196
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38040: LD_VAR 0 1
38044: PPUSH
38045: LD_INT 9
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL 12354 0 3
38054: PUSH
38055: LD_INT 3
38057: LESS
38058: IFFALSE 38196
// begin if mech < 3 then
38060: LD_VAR 0 15
38064: PUSH
38065: LD_INT 3
38067: LESS
38068: IFFALSE 38082
// k := mech else
38070: LD_ADDR_VAR 0 8
38074: PUSH
38075: LD_VAR 0 15
38079: ST_TO_ADDR
38080: GO 38090
// k := 3 ;
38082: LD_ADDR_VAR 0 8
38086: PUSH
38087: LD_INT 3
38089: ST_TO_ADDR
// for j = 1 to k do
38090: LD_ADDR_VAR 0 5
38094: PUSH
38095: DOUBLE
38096: LD_INT 1
38098: DEC
38099: ST_TO_ADDR
38100: LD_VAR 0 8
38104: PUSH
38105: FOR_TO
38106: IFFALSE 38164
// if GetClass ( mech [ j ] ) = 3 then
38108: LD_VAR 0 15
38112: PUSH
38113: LD_VAR 0 5
38117: ARRAY
38118: PPUSH
38119: CALL_OW 257
38123: PUSH
38124: LD_INT 3
38126: EQUAL
38127: IFFALSE 38162
// begin SetTag ( mech [ j ] , 9 ) ;
38129: LD_VAR 0 15
38133: PUSH
38134: LD_VAR 0 5
38138: ARRAY
38139: PPUSH
38140: LD_INT 9
38142: PPUSH
38143: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38147: LD_VAR 0 15
38151: PUSH
38152: LD_VAR 0 5
38156: ARRAY
38157: PPUSH
38158: CALL_OW 122
// end ;
38162: GO 38105
38164: POP
38165: POP
// if mech < 6 + k then
38166: LD_VAR 0 15
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_VAR 0 8
38178: PLUS
38179: LESS
38180: IFFALSE 38196
// MCH_TrainMechanic ( side , k ) ;
38182: LD_VAR 0 1
38186: PPUSH
38187: LD_VAR 0 8
38191: PPUSH
38192: CALL 15852 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38196: LD_VAR 0 1
38200: PPUSH
38201: LD_INT 9
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL 12354 0 3
38210: IFFALSE 38301
// for j in MCF_Tag ( side , 9 , [ ] ) do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_VAR 0 1
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL 12354 0 3
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38299
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38235: LD_VAR 0 5
38239: PPUSH
38240: CALL_OW 310
38244: NOT
38245: PUSH
38246: LD_VAR 0 5
38250: PPUSH
38251: CALL 98260 0 1
38255: NOT
38256: AND
38257: IFFALSE 38297
// if ct then
38259: LD_VAR 0 10
38263: IFFALSE 38285
// ComEnterUnit ( j , ct [ 1 ] ) else
38265: LD_VAR 0 5
38269: PPUSH
38270: LD_VAR 0 10
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: PPUSH
38279: CALL_OW 120
38283: GO 38297
// SetTag ( j , 0 ) ;
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_INT 0
38292: PPUSH
38293: CALL_OW 109
38297: GO 38232
38299: POP
38300: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38301: LD_INT 1
38303: PPUSH
38304: LD_VAR 0 1
38308: PPUSH
38309: CALL_OW 321
38313: PUSH
38314: LD_INT 2
38316: EQUAL
38317: PUSH
38318: LD_EXP 35
38322: PUSH
38323: LD_VAR 0 1
38327: ARRAY
38328: NOT
38329: AND
38330: PUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: LD_INT 4
38338: PPUSH
38339: EMPTY
38340: PPUSH
38341: CALL 11734 0 3
38345: AND
38346: IFFALSE 38394
// for j in MCF_Class ( side , 4 , [ ] ) do
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: LD_INT 4
38360: PPUSH
38361: EMPTY
38362: PPUSH
38363: CALL 11734 0 3
38367: PUSH
38368: FOR_IN
38369: IFFALSE 38392
// MCN_Tame ( GetSide ( j ) , j ) ;
38371: LD_VAR 0 5
38375: PPUSH
38376: CALL_OW 255
38380: PPUSH
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL 18553 0 2
38390: GO 38368
38392: POP
38393: POP
// if MREG_DefVeh [ side ] then
38394: LD_EXP 67
38398: PUSH
38399: LD_VAR 0 1
38403: ARRAY
38404: IFFALSE 38568
// begin for i in MREG_DefVeh [ side ] do
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 67
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: PUSH
38422: FOR_IN
38423: IFFALSE 38476
// begin SetTag ( i , 0 ) ;
38425: LD_VAR 0 4
38429: PPUSH
38430: LD_INT 0
38432: PPUSH
38433: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38437: LD_VAR 0 4
38441: PPUSH
38442: LD_EXP 64
38446: PUSH
38447: LD_VAR 0 1
38451: ARRAY
38452: PPUSH
38453: CALL_OW 308
38457: NOT
38458: IFFALSE 38474
// MCV_Parking ( side , i ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: CALL 25741 0 2
// end ;
38474: GO 38422
38476: POP
38477: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38478: LD_VAR 0 1
38482: PPUSH
38483: LD_INT 36
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL 12354 0 3
38492: IFFALSE 38533
// for i in MCF_Tag ( side , 36 , [ ] ) do
38494: LD_ADDR_VAR 0 4
38498: PUSH
38499: LD_VAR 0 1
38503: PPUSH
38504: LD_INT 36
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL 12354 0 3
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38531
// SetTag ( i , 0 ) ;
38517: LD_VAR 0 4
38521: PPUSH
38522: LD_INT 0
38524: PPUSH
38525: CALL_OW 109
38529: GO 38514
38531: POP
38532: POP
// if MREG_DefMobActive [ side ] then
38533: LD_EXP 70
38537: PUSH
38538: LD_VAR 0 1
38542: ARRAY
38543: IFFALSE 38568
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38545: LD_ADDR_EXP 70
38549: PUSH
38550: LD_EXP 70
38554: PPUSH
38555: LD_VAR 0 1
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// end ; end ; if mode > 0 then
38568: LD_VAR 0 2
38572: PUSH
38573: LD_INT 0
38575: GREATER
38576: IFFALSE 40471
// begin if tick <= 15 15$00 then
38578: LD_OWVAR 1
38582: PUSH
38583: LD_INT 31500
38585: LESSEQUAL
38586: IFFALSE 38890
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38588: LD_VAR 0 13
38592: PUSH
38593: LD_VAR 0 1
38597: PPUSH
38598: CALL 25006 0 1
38602: PUSH
38603: LD_INT 4
38605: LESS
38606: AND
38607: IFFALSE 38718
// begin for i in sol do
38609: LD_ADDR_VAR 0 4
38613: PUSH
38614: LD_VAR 0 13
38618: PUSH
38619: FOR_IN
38620: IFFALSE 38716
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38622: LD_ADDR_VAR 0 8
38626: PUSH
38627: LD_VAR 0 1
38631: PPUSH
38632: CALL 25006 0 1
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: CALL_OW 74
38646: ST_TO_ADDR
// if IsInUnit ( i ) then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 310
38656: IFFALSE 38667
// ComExitBuilding ( i ) ;
38658: LD_VAR 0 4
38662: PPUSH
38663: CALL_OW 122
// if not HasTask ( i ) and k then
38667: LD_VAR 0 4
38671: PPUSH
38672: CALL_OW 314
38676: NOT
38677: PUSH
38678: LD_VAR 0 8
38682: AND
38683: IFFALSE 38714
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38685: LD_VAR 0 4
38689: PPUSH
38690: LD_VAR 0 8
38694: PPUSH
38695: CALL_OW 250
38699: PPUSH
38700: LD_VAR 0 8
38704: PPUSH
38705: CALL_OW 251
38709: PPUSH
38710: CALL_OW 174
// end ;
38714: GO 38619
38716: POP
38717: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38718: LD_VAR 0 1
38722: PPUSH
38723: LD_INT 30
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PPUSH
38733: CALL 11651 0 2
38737: IFFALSE 38888
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38739: LD_ADDR_VAR 0 11
38743: PUSH
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 30
38751: PUSH
38752: LD_INT 5
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL 11651 0 2
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: ST_TO_ADDR
// if mech then
38768: LD_VAR 0 15
38772: IFFALSE 38808
// for i in mech do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 15
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38806
// MCH_ChangeClass ( side , i , 1 ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: CALL 16558 0 3
38804: GO 38784
38806: POP
38807: POP
// if eng > 1 then
38808: LD_VAR 0 14
38812: PUSH
38813: LD_INT 1
38815: GREATER
38816: IFFALSE 38863
// for i = eng downto 2 do
38818: LD_ADDR_VAR 0 4
38822: PUSH
38823: DOUBLE
38824: LD_VAR 0 14
38828: INC
38829: ST_TO_ADDR
38830: LD_INT 2
38832: PUSH
38833: FOR_DOWNTO
38834: IFFALSE 38861
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 14
38845: PUSH
38846: LD_VAR 0 4
38850: ARRAY
38851: PPUSH
38852: LD_INT 1
38854: PPUSH
38855: CALL 16558 0 3
38859: GO 38833
38861: POP
38862: POP
// if UnitsInside ( b ) then
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: IFFALSE 38888
// ComExitBuilding ( UnitsInside ( b ) ) ;
38874: LD_VAR 0 11
38878: PPUSH
38879: CALL_OW 313
38883: PPUSH
38884: CALL_OW 122
// end ; end else
38888: GO 40471
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38890: LD_VAR 0 1
38894: PPUSH
38895: LD_INT 1
38897: PPUSH
38898: LD_EXP 65
38902: PUSH
38903: LD_VAR 0 1
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: PPUSH
38913: CALL 33743 0 3
38917: IFFALSE 39056
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38919: LD_ADDR_VAR 0 12
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: LD_INT 21
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL 11651 0 2
38943: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38944: LD_ADDR_VAR 0 11
38948: PUSH
38949: LD_VAR 0 1
38953: PPUSH
38954: LD_INT 30
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL 11651 0 2
38968: ST_TO_ADDR
// if b then
38969: LD_VAR 0 11
38973: IFFALSE 39056
// for i in tmp do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 12
38984: PUSH
38985: FOR_IN
38986: IFFALSE 39054
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38988: LD_VAR 0 4
38992: PPUSH
38993: LD_EXP 65
38997: PUSH
38998: LD_VAR 0 1
39002: ARRAY
39003: PUSH
39004: LD_INT 1
39006: ARRAY
39007: PPUSH
39008: CALL_OW 308
39012: NOT
39013: IFFALSE 39052
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39015: LD_VAR 0 4
39019: PPUSH
39020: LD_VAR 0 11
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 250
39033: PPUSH
39034: LD_VAR 0 11
39038: PUSH
39039: LD_INT 1
39041: ARRAY
39042: PPUSH
39043: CALL_OW 251
39047: PPUSH
39048: CALL_OW 111
39052: GO 38985
39054: POP
39055: POP
// end ; if MREG_DefVeh [ side ] then
39056: LD_EXP 67
39060: PUSH
39061: LD_VAR 0 1
39065: ARRAY
39066: IFFALSE 39634
// begin tmp := [ ] ;
39068: LD_ADDR_VAR 0 12
39072: PUSH
39073: EMPTY
39074: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39075: LD_EXP 70
39079: PUSH
39080: LD_VAR 0 1
39084: ARRAY
39085: PUSH
39086: LD_INT 0
39088: EQUAL
39089: IFFALSE 39229
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39091: LD_ADDR_VAR 0 8
39095: PUSH
39096: LD_VAR 0 1
39100: PPUSH
39101: LD_INT 0
39103: PPUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 3
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL 12354 0 3
39118: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39119: LD_VAR 0 8
39123: PUSH
39124: LD_EXP 67
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: GREATER
39135: IFFALSE 39196
// begin for i = 1 to MREG_DefVeh [ side ] do
39137: LD_ADDR_VAR 0 4
39141: PUSH
39142: DOUBLE
39143: LD_INT 1
39145: DEC
39146: ST_TO_ADDR
39147: LD_EXP 67
39151: PUSH
39152: LD_VAR 0 1
39156: ARRAY
39157: PUSH
39158: FOR_TO
39159: IFFALSE 39192
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39161: LD_ADDR_VAR 0 12
39165: PUSH
39166: LD_VAR 0 12
39170: PPUSH
39171: LD_INT 1
39173: PPUSH
39174: LD_VAR 0 8
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PPUSH
39185: CALL_OW 2
39189: ST_TO_ADDR
39190: GO 39158
39192: POP
39193: POP
// end else
39194: GO 39206
// tmp := k ;
39196: LD_ADDR_VAR 0 12
39200: PUSH
39201: LD_VAR 0 8
39205: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39206: LD_ADDR_EXP 70
39210: PUSH
39211: LD_EXP 70
39215: PPUSH
39216: LD_VAR 0 1
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39229: LD_ADDR_VAR 0 4
39233: PUSH
39234: LD_EXP 67
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: PUSH
39245: FOR_IN
39246: IFFALSE 39632
// begin if not GetDriver ( i ) then
39248: LD_VAR 0 4
39252: PPUSH
39253: CALL 31773 0 1
39257: NOT
39258: IFFALSE 39333
// begin if tmp then
39260: LD_VAR 0 12
39264: IFFALSE 39331
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39266: LD_VAR 0 12
39270: PUSH
39271: LD_INT 1
39273: ARRAY
39274: PPUSH
39275: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39279: LD_VAR 0 12
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: LD_VAR 0 4
39292: PPUSH
39293: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39297: LD_VAR 0 12
39301: PUSH
39302: LD_INT 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 36
39308: PPUSH
39309: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39313: LD_ADDR_VAR 0 12
39317: PUSH
39318: LD_VAR 0 12
39322: PPUSH
39323: LD_INT 1
39325: PPUSH
39326: CALL_OW 3
39330: ST_TO_ADDR
// end ; end else
39331: GO 39630
// begin if GetTag ( i ) = 0 then
39333: LD_VAR 0 4
39337: PPUSH
39338: CALL_OW 110
39342: PUSH
39343: LD_INT 0
39345: EQUAL
39346: IFFALSE 39362
// SetTag ( i , 31 ) else
39348: LD_VAR 0 4
39352: PPUSH
39353: LD_INT 31
39355: PPUSH
39356: CALL_OW 109
39360: GO 39630
// if GetTag ( i ) = 31 then
39362: LD_VAR 0 4
39366: PPUSH
39367: CALL_OW 110
39371: PUSH
39372: LD_INT 31
39374: EQUAL
39375: IFFALSE 39630
// begin if GetFuel ( i ) < 20 then
39377: LD_VAR 0 4
39381: PPUSH
39382: CALL_OW 261
39386: PUSH
39387: LD_INT 20
39389: LESS
39390: IFFALSE 39415
// begin SetTag ( i , 21 ) ;
39392: LD_VAR 0 4
39396: PPUSH
39397: LD_INT 21
39399: PPUSH
39400: CALL_OW 109
// MCV_Refuel ( i ) ;
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL 26278 0 1
// continue ;
39413: GO 39245
// end ; if GetLives ( i ) < 700 then
39415: LD_VAR 0 4
39419: PPUSH
39420: CALL_OW 256
39424: PUSH
39425: LD_INT 700
39427: LESS
39428: IFFALSE 39540
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39430: LD_VAR 0 4
39434: PPUSH
39435: LD_EXP 58
39439: PUSH
39440: LD_VAR 0 1
39444: ARRAY
39445: PPUSH
39446: CALL_OW 308
39450: NOT
39451: IFFALSE 39475
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39453: LD_VAR 0 4
39457: PPUSH
39458: LD_EXP 58
39462: PUSH
39463: LD_VAR 0 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 113
39473: GO 39538
// if GetDriver ( i ) then
39475: LD_VAR 0 4
39479: PPUSH
39480: CALL 31773 0 1
39484: IFFALSE 39538
// begin k := GetDriver ( i ) ;
39486: LD_ADDR_VAR 0 8
39490: PUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31773 0 1
39500: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39501: LD_VAR 0 8
39505: PPUSH
39506: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39510: LD_VAR 0 8
39514: PPUSH
39515: LD_VAR 0 4
39519: PPUSH
39520: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39524: LD_VAR 0 8
39528: PPUSH
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL_OW 180
// end ; end else
39538: GO 39630
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39540: LD_ADDR_VAR 0 8
39544: PUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: CALL 25006 0 1
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: CALL_OW 74
39564: ST_TO_ADDR
// if k then
39565: LD_VAR 0 8
39569: IFFALSE 39587
// ComAttackUnit ( i , k ) else
39571: LD_VAR 0 4
39575: PPUSH
39576: LD_VAR 0 8
39580: PPUSH
39581: CALL_OW 115
39585: GO 39630
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_EXP 58
39596: PUSH
39597: LD_VAR 0 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 308
39607: NOT
39608: IFFALSE 39630
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39610: LD_VAR 0 4
39614: PPUSH
39615: LD_EXP 58
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: CALL_OW 113
// end ; end ; end ; end ;
39630: GO 39245
39632: POP
39633: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_INT 30
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PPUSH
39649: CALL 11651 0 2
39653: IFFALSE 40471
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39655: LD_ADDR_VAR 0 11
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: LD_INT 30
39667: PUSH
39668: LD_INT 5
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PPUSH
39675: CALL 11651 0 2
39679: PUSH
39680: LD_INT 1
39682: ARRAY
39683: ST_TO_ADDR
// if eng > 1 then
39684: LD_VAR 0 14
39688: PUSH
39689: LD_INT 1
39691: GREATER
39692: IFFALSE 39739
// for i = eng downto 2 do
39694: LD_ADDR_VAR 0 4
39698: PUSH
39699: DOUBLE
39700: LD_VAR 0 14
39704: INC
39705: ST_TO_ADDR
39706: LD_INT 2
39708: PUSH
39709: FOR_DOWNTO
39710: IFFALSE 39737
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39712: LD_VAR 0 1
39716: PPUSH
39717: LD_VAR 0 14
39721: PUSH
39722: LD_VAR 0 4
39726: ARRAY
39727: PPUSH
39728: LD_INT 1
39730: PPUSH
39731: CALL 16558 0 3
39735: GO 39709
39737: POP
39738: POP
// if sci > 1 then
39739: LD_VAR 0 16
39743: PUSH
39744: LD_INT 1
39746: GREATER
39747: IFFALSE 39794
// for i = sci downto 2 do
39749: LD_ADDR_VAR 0 4
39753: PUSH
39754: DOUBLE
39755: LD_VAR 0 16
39759: INC
39760: ST_TO_ADDR
39761: LD_INT 2
39763: PUSH
39764: FOR_DOWNTO
39765: IFFALSE 39792
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39767: LD_VAR 0 1
39771: PPUSH
39772: LD_VAR 0 16
39776: PUSH
39777: LD_VAR 0 4
39781: ARRAY
39782: PPUSH
39783: LD_INT 1
39785: PPUSH
39786: CALL 16558 0 3
39790: GO 39764
39792: POP
39793: POP
// if sol then
39794: LD_VAR 0 13
39798: IFFALSE 40471
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39800: LD_VAR 0 13
39804: PUSH
39805: LD_EXP 68
39809: PUSH
39810: LD_VAR 0 1
39814: ARRAY
39815: DIFF
39816: PUSH
39817: LD_INT 22
39819: PUSH
39820: LD_VAR 0 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 58
39831: PUSH
39832: EMPTY
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 32
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 31
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: PUSH
39873: LD_INT 0
39875: EQUAL
39876: AND
39877: IFFALSE 40471
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39879: LD_ADDR_VAR 0 12
39883: PUSH
39884: LD_VAR 0 13
39888: PUSH
39889: LD_EXP 68
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: DIFF
39900: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39901: LD_VAR 0 1
39905: PPUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PPUSH
39916: CALL 11651 0 2
39920: PUSH
39921: LD_INT 1
39923: GREATER
39924: IFFALSE 39955
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39926: LD_ADDR_VAR 0 8
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 30
39938: PUSH
39939: LD_INT 5
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL 11651 0 2
39950: PUSH
39951: LD_INT 2
39953: ARRAY
39954: ST_TO_ADDR
// for j in tmp do
39955: LD_ADDR_VAR 0 5
39959: PUSH
39960: LD_VAR 0 12
39964: PUSH
39965: FOR_IN
39966: IFFALSE 40469
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39968: LD_VAR 0 5
39972: PUSH
39973: LD_VAR 0 11
39977: PPUSH
39978: CALL_OW 313
39982: IN
39983: PUSH
39984: LD_VAR 0 11
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: EQUAL
39997: AND
39998: PUSH
39999: LD_VAR 0 8
40003: AND
40004: PUSH
40005: LD_VAR 0 8
40009: PPUSH
40010: CALL_OW 313
40014: PUSH
40015: LD_INT 6
40017: LESS
40018: AND
40019: IFFALSE 40046
// begin ComExitBuilding ( j ) ;
40021: LD_VAR 0 5
40025: PPUSH
40026: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40030: LD_VAR 0 5
40034: PPUSH
40035: LD_VAR 0 8
40039: PPUSH
40040: CALL_OW 180
// continue ;
40044: GO 39965
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40046: LD_VAR 0 5
40050: PPUSH
40051: CALL_OW 314
40055: NOT
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: CALL_OW 110
40066: PUSH
40067: LD_INT 0
40069: EQUAL
40070: AND
40071: PUSH
40072: LD_VAR 0 5
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: AND
40083: IFFALSE 40189
// begin if k then
40085: LD_VAR 0 8
40089: IFFALSE 40160
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40091: LD_VAR 0 8
40095: PPUSH
40096: CALL_OW 313
40100: PUSH
40101: LD_VAR 0 11
40105: PPUSH
40106: CALL_OW 313
40110: LESS
40111: IFFALSE 40129
// ComEnterUnit ( j , k ) else
40113: LD_VAR 0 5
40117: PPUSH
40118: LD_VAR 0 8
40122: PPUSH
40123: CALL_OW 120
40127: GO 40158
// if UnitsInside ( b ) < 6 then
40129: LD_VAR 0 11
40133: PPUSH
40134: CALL_OW 313
40138: PUSH
40139: LD_INT 6
40141: LESS
40142: IFFALSE 40158
// ComEnterUnit ( j , b ) ;
40144: LD_VAR 0 5
40148: PPUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 120
// end else
40158: GO 40189
// if UnitsInside ( b ) < 6 then
40160: LD_VAR 0 11
40164: PPUSH
40165: CALL_OW 313
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: IFFALSE 40189
// ComEnterUnit ( j , b ) ;
40175: LD_VAR 0 5
40179: PPUSH
40180: LD_VAR 0 11
40184: PPUSH
40185: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40189: LD_VAR 0 5
40193: PUSH
40194: LD_VAR 0 1
40198: PPUSH
40199: LD_INT 54
40201: PUSH
40202: EMPTY
40203: LIST
40204: PPUSH
40205: CALL 11651 0 2
40209: IN
40210: PUSH
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 257
40220: PUSH
40221: LD_INT 1
40223: EQUAL
40224: AND
40225: IFFALSE 40467
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40227: LD_EXP 62
40231: PUSH
40232: LD_VAR 0 1
40236: ARRAY
40237: PUSH
40238: LD_INT 1
40240: ARRAY
40241: PUSH
40242: LD_INT 12
40244: PPUSH
40245: LD_VAR 0 1
40249: PPUSH
40250: CALL_OW 321
40254: PUSH
40255: LD_INT 2
40257: EQUAL
40258: AND
40259: IFFALSE 40307
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40261: LD_VAR 0 1
40265: PPUSH
40266: LD_INT 5
40268: PPUSH
40269: EMPTY
40270: PPUSH
40271: CALL 11734 0 3
40275: PUSH
40276: LD_EXP 62
40280: PUSH
40281: LD_VAR 0 1
40285: ARRAY
40286: PUSH
40287: LD_INT 1
40289: ARRAY
40290: LESS
40291: IFFALSE 40307
// begin SetClass ( j , class_sniper ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: LD_INT 5
40300: PPUSH
40301: CALL_OW 336
// continue ;
40305: GO 39965
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40307: LD_EXP 62
40311: PUSH
40312: LD_VAR 0 1
40316: ARRAY
40317: PUSH
40318: LD_INT 2
40320: ARRAY
40321: PUSH
40322: LD_INT 41
40324: PPUSH
40325: LD_VAR 0 1
40329: PPUSH
40330: CALL_OW 321
40334: PUSH
40335: LD_INT 2
40337: EQUAL
40338: AND
40339: IFFALSE 40387
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40341: LD_VAR 0 1
40345: PPUSH
40346: LD_INT 8
40348: PPUSH
40349: EMPTY
40350: PPUSH
40351: CALL 11734 0 3
40355: PUSH
40356: LD_EXP 62
40360: PUSH
40361: LD_VAR 0 1
40365: ARRAY
40366: PUSH
40367: LD_INT 2
40369: ARRAY
40370: LESS
40371: IFFALSE 40387
// begin SetClass ( j , class_mortar ) ;
40373: LD_VAR 0 5
40377: PPUSH
40378: LD_INT 8
40380: PPUSH
40381: CALL_OW 336
// continue ;
40385: GO 39965
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40387: LD_EXP 62
40391: PUSH
40392: LD_VAR 0 1
40396: ARRAY
40397: PUSH
40398: LD_INT 3
40400: ARRAY
40401: PUSH
40402: LD_INT 44
40404: PPUSH
40405: LD_VAR 0 1
40409: PPUSH
40410: CALL_OW 321
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: AND
40419: IFFALSE 40467
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40421: LD_VAR 0 1
40425: PPUSH
40426: LD_INT 9
40428: PPUSH
40429: EMPTY
40430: PPUSH
40431: CALL 11734 0 3
40435: PUSH
40436: LD_EXP 62
40440: PUSH
40441: LD_VAR 0 1
40445: ARRAY
40446: PUSH
40447: LD_INT 3
40449: ARRAY
40450: LESS
40451: IFFALSE 40467
// begin SetClass ( j , class_bazooker ) ;
40453: LD_VAR 0 5
40457: PPUSH
40458: LD_INT 9
40460: PPUSH
40461: CALL_OW 336
// continue ;
40465: GO 39965
// end ; end ; end ;
40467: GO 39965
40469: POP
40470: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40471: LD_INT 22
40473: PUSH
40474: LD_VAR 0 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 58
40485: PUSH
40486: EMPTY
40487: LIST
40488: PUSH
40489: LD_INT 30
40491: PUSH
40492: LD_INT 32
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: PPUSH
40504: CALL_OW 69
40508: IFFALSE 40658
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40510: LD_ADDR_VAR 0 12
40514: PUSH
40515: LD_INT 22
40517: PUSH
40518: LD_VAR 0 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 58
40529: PUSH
40530: EMPTY
40531: LIST
40532: PUSH
40533: LD_INT 30
40535: PUSH
40536: LD_INT 32
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: PPUSH
40548: CALL_OW 69
40552: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40553: LD_ADDR_VAR 0 8
40557: PUSH
40558: LD_VAR 0 13
40562: PUSH
40563: LD_EXP 68
40567: PUSH
40568: LD_VAR 0 1
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40575: LD_VAR 0 12
40579: PUSH
40580: LD_INT 1
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 2
40591: EQUAL
40592: PUSH
40593: LD_VAR 0 12
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_EXP 68
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: IN
40613: NOT
40614: AND
40615: PUSH
40616: LD_VAR 0 8
40620: AND
40621: IFFALSE 40658
// begin ComExitBuilding ( k [ 1 ] ) ;
40623: LD_VAR 0 8
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: PPUSH
40632: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40636: LD_VAR 0 8
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_VAR 0 12
40649: PUSH
40650: LD_INT 1
40652: ARRAY
40653: PPUSH
40654: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40658: LD_EXP 35
40662: PUSH
40663: LD_VAR 0 1
40667: ARRAY
40668: IFFALSE 40816
// begin if MCF_Class ( side , 4 , [ ] ) then
40670: LD_VAR 0 1
40674: PPUSH
40675: LD_INT 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL 11734 0 3
40684: IFFALSE 40814
// for j in MCF_Class ( side , 4 , [ ] ) do
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_VAR 0 1
40695: PPUSH
40696: LD_INT 4
40698: PPUSH
40699: EMPTY
40700: PPUSH
40701: CALL 11734 0 3
40705: PUSH
40706: FOR_IN
40707: IFFALSE 40812
// begin if not GetTag ( j ) = 4 then
40709: LD_VAR 0 5
40713: PPUSH
40714: CALL_OW 110
40718: PUSH
40719: LD_INT 4
40721: EQUAL
40722: NOT
40723: IFFALSE 40759
// begin SetTag ( j , 4 ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 4
40732: PPUSH
40733: CALL_OW 109
// if IsInUnit ( j ) then
40737: LD_VAR 0 5
40741: PPUSH
40742: CALL_OW 310
40746: IFFALSE 40757
// ComExitBuilding ( j ) ;
40748: LD_VAR 0 5
40752: PPUSH
40753: CALL_OW 122
// end else
40757: GO 40810
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40759: LD_VAR 0 5
40763: PPUSH
40764: LD_EXP 35
40768: PUSH
40769: LD_VAR 0 1
40773: ARRAY
40774: PUSH
40775: LD_INT 1
40777: ARRAY
40778: PPUSH
40779: CALL 97937 0 2
40783: NOT
40784: IFFALSE 40810
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_EXP 35
40795: PUSH
40796: LD_VAR 0 1
40800: ARRAY
40801: PUSH
40802: LD_INT 1
40804: ARRAY
40805: PPUSH
40806: CALL 19221 0 2
// end ;
40810: GO 40706
40812: POP
40813: POP
// end else
40814: GO 41048
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40816: LD_VAR 0 1
40820: PPUSH
40821: LD_INT 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL 11734 0 3
40830: PUSH
40831: LD_VAR 0 1
40835: PPUSH
40836: LD_INT 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL 12354 0 3
40845: AND
40846: IFFALSE 41048
// for j in MCF_Class ( side , 4 , [ ] ) do
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11734 0 3
40867: PUSH
40868: FOR_IN
40869: IFFALSE 41046
// begin if GetTag ( j ) = 4 then
40871: LD_VAR 0 5
40875: PPUSH
40876: CALL_OW 110
40880: PUSH
40881: LD_INT 4
40883: EQUAL
40884: IFFALSE 41044
// begin SetTag ( j , 0 ) ;
40886: LD_VAR 0 5
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40898: LD_VAR 0 1
40902: PPUSH
40903: CALL 11690 0 1
40907: PUSH
40908: LD_VAR 0 1
40912: PPUSH
40913: CALL 18034 0 1
40917: NOT
40918: AND
40919: IFFALSE 40944
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40921: LD_VAR 0 5
40925: PPUSH
40926: LD_VAR 0 1
40930: PPUSH
40931: CALL 11690 0 1
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: PPUSH
40940: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40944: LD_VAR 0 1
40948: PPUSH
40949: CALL 11690 0 1
40953: NOT
40954: PUSH
40955: LD_VAR 0 1
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL 11651 0 2
40974: AND
40975: IFFALSE 41044
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40977: LD_VAR 0 5
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 30
40989: PUSH
40990: LD_INT 1
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PPUSH
40997: CALL 11651 0 2
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 250
41010: PPUSH
41011: LD_VAR 0 1
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL 11651 0 2
41030: PUSH
41031: LD_INT 1
41033: ARRAY
41034: PPUSH
41035: CALL_OW 251
41039: PPUSH
41040: CALL_OW 111
// end ; end ;
41044: GO 40868
41046: POP
41047: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41048: LD_VAR 0 1
41052: PPUSH
41053: LD_INT 3
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL 11734 0 3
41062: PUSH
41063: LD_EXP 58
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: AND
41074: PUSH
41075: LD_VAR 0 1
41079: PPUSH
41080: LD_INT 6
41082: PPUSH
41083: EMPTY
41084: PPUSH
41085: CALL 12354 0 3
41089: AND
41090: IFFALSE 41621
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41092: LD_ADDR_VAR 0 6
41096: PUSH
41097: LD_EXP 58
41101: PUSH
41102: LD_VAR 0 1
41106: ARRAY
41107: PPUSH
41108: LD_INT 0
41110: PPUSH
41111: CALL_OW 517
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 1
41122: ARRAY
41123: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41124: LD_ADDR_VAR 0 7
41128: PUSH
41129: LD_EXP 58
41133: PUSH
41134: LD_VAR 0 1
41138: ARRAY
41139: PPUSH
41140: LD_INT 0
41142: PPUSH
41143: CALL_OW 517
41147: PUSH
41148: LD_INT 2
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 6
41163: PPUSH
41164: EMPTY
41165: PPUSH
41166: CALL 12354 0 3
41170: IFFALSE 41619
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 1
41181: PPUSH
41182: LD_INT 6
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL 12354 0 3
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41224
// if GetLives ( k ) = 1000 then
41195: LD_VAR 0 8
41199: PPUSH
41200: CALL_OW 256
41204: PUSH
41205: LD_INT 1000
41207: EQUAL
41208: IFFALSE 41222
// SetTag ( k , 0 ) ;
41210: LD_VAR 0 8
41214: PPUSH
41215: LD_INT 0
41217: PPUSH
41218: CALL_OW 109
41222: GO 41192
41224: POP
41225: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: LD_INT 25
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PPUSH
41244: CALL 12354 0 3
41248: IFFALSE 41312
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41250: LD_ADDR_VAR 0 8
41254: PUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: LD_INT 0
41262: PPUSH
41263: LD_INT 25
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: CALL 12354 0 3
41277: PUSH
41278: FOR_IN
41279: IFFALSE 41310
// if GetTag ( k ) = 0 then
41281: LD_VAR 0 8
41285: PPUSH
41286: CALL_OW 110
41290: PUSH
41291: LD_INT 0
41293: EQUAL
41294: IFFALSE 41308
// begin SetTag ( k , 8 ) ;
41296: LD_VAR 0 8
41300: PPUSH
41301: LD_INT 8
41303: PPUSH
41304: CALL_OW 109
// end ;
41308: GO 41278
41310: POP
41311: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41312: LD_VAR 0 1
41316: PPUSH
41317: LD_INT 6
41319: PPUSH
41320: LD_INT 92
41322: PUSH
41323: LD_VAR 0 6
41327: PUSH
41328: LD_VAR 0 7
41332: PUSH
41333: LD_INT 10
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL 12354 0 3
41346: IFFALSE 41470
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_VAR 0 4
41357: PPUSH
41358: LD_INT 6
41360: PPUSH
41361: LD_INT 92
41363: PUSH
41364: LD_VAR 0 6
41368: PUSH
41369: LD_VAR 0 7
41373: PUSH
41374: LD_INT 10
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 12354 0 3
41387: PUSH
41388: FOR_IN
41389: IFFALSE 41468
// begin if not HasTask ( j ) and GetDriver ( j ) then
41391: LD_VAR 0 5
41395: PPUSH
41396: CALL_OW 314
41400: NOT
41401: PUSH
41402: LD_VAR 0 5
41406: PPUSH
41407: CALL 31773 0 1
41411: AND
41412: IFFALSE 41466
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41414: LD_VAR 0 5
41418: PPUSH
41419: CALL 31773 0 1
41423: PPUSH
41424: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41428: LD_VAR 0 5
41432: PPUSH
41433: CALL 31773 0 1
41437: PPUSH
41438: LD_VAR 0 5
41442: PPUSH
41443: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41447: LD_VAR 0 5
41451: PPUSH
41452: CALL 31773 0 1
41456: PPUSH
41457: LD_VAR 0 5
41461: PPUSH
41462: CALL_OW 180
// end ; end ;
41466: GO 41388
41468: POP
41469: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41470: LD_VAR 0 1
41474: PPUSH
41475: LD_INT 6
41477: PPUSH
41478: LD_INT 92
41480: PUSH
41481: LD_VAR 0 6
41485: PUSH
41486: LD_VAR 0 7
41490: PUSH
41491: LD_INT 10
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL 12354 0 3
41504: PUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 8
41512: PPUSH
41513: EMPTY
41514: PPUSH
41515: CALL 12354 0 3
41519: AND
41520: IFFALSE 41619
// for j in MCF_Tag ( side , 8 , [ ] ) do
41522: LD_ADDR_VAR 0 5
41526: PUSH
41527: LD_VAR 0 1
41531: PPUSH
41532: LD_INT 8
41534: PPUSH
41535: EMPTY
41536: PPUSH
41537: CALL 12354 0 3
41541: PUSH
41542: FOR_IN
41543: IFFALSE 41617
// begin if IsInUnit ( j ) then
41545: LD_VAR 0 5
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41567
// ComExitBuilding ( j ) else
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 122
41565: GO 41615
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41567: LD_VAR 0 5
41571: PPUSH
41572: LD_VAR 0 1
41576: PPUSH
41577: LD_INT 6
41579: PPUSH
41580: LD_INT 92
41582: PUSH
41583: LD_VAR 0 6
41587: PUSH
41588: LD_VAR 0 7
41592: PUSH
41593: LD_INT 10
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: PPUSH
41602: CALL 12354 0 3
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: CALL_OW 129
// end ;
41615: GO 41542
41617: POP
41618: POP
// end ; end else
41619: GO 41676
// if MCF_Tag ( side , 8 , [ ] ) then
41621: LD_VAR 0 1
41625: PPUSH
41626: LD_INT 8
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL 12354 0 3
41635: IFFALSE 41676
// for k in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 8
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12354 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41674
// SetTag ( k , 0 ) ;
41660: LD_VAR 0 8
41664: PPUSH
41665: LD_INT 0
41667: PPUSH
41668: CALL_OW 109
41672: GO 41657
41674: POP
41675: POP
// end ; end_of_file
41676: LD_VAR 0 3
41680: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41681: LD_INT 0
41683: PPUSH
// MREG_Game := [ ] ;
41684: LD_ADDR_EXP 33
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_Crates := [ ] ;
41691: LD_ADDR_EXP 34
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_Heal := [ ] ;
41698: LD_ADDR_EXP 35
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_Tame := [ ] ;
41705: LD_ADDR_EXP 37
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41712: LD_ADDR_EXP 38
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41719: LD_ADDR_EXP 39
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_LabList := [ ] ;
41726: LD_ADDR_EXP 40
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41733: LD_ADDR_EXP 41
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41740: LD_ADDR_EXP 42
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41747: LD_ADDR_EXP 43
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41754: LD_ADDR_EXP 44
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_Status := [ ] ;
41761: LD_ADDR_EXP 45
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41768: LD_ADDR_EXP 46
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41775: LD_ADDR_EXP 47
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41782: LD_ADDR_EXP 48
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41789: LD_ADDR_EXP 49
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41796: LD_ADDR_EXP 50
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41803: LD_ADDR_EXP 51
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41810: LD_ADDR_EXP 52
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41817: LD_ADDR_EXP 53
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41824: LD_ADDR_EXP 54
41828: PUSH
41829: EMPTY
41830: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41831: LD_ADDR_EXP 55
41835: PUSH
41836: EMPTY
41837: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41838: LD_ADDR_EXP 56
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41845: LD_ADDR_EXP 57
41849: PUSH
41850: EMPTY
41851: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41852: LD_ADDR_EXP 61
41856: PUSH
41857: EMPTY
41858: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41859: LD_ADDR_EXP 62
41863: PUSH
41864: EMPTY
41865: ST_TO_ADDR
// MREG_Parking := [ ] ;
41866: LD_ADDR_EXP 58
41870: PUSH
41871: EMPTY
41872: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41873: LD_ADDR_EXP 59
41877: PUSH
41878: EMPTY
41879: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41880: LD_ADDR_EXP 63
41884: PUSH
41885: EMPTY
41886: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41887: LD_ADDR_EXP 64
41891: PUSH
41892: EMPTY
41893: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41894: LD_ADDR_EXP 65
41898: PUSH
41899: EMPTY
41900: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41901: LD_ADDR_EXP 67
41905: PUSH
41906: EMPTY
41907: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41908: LD_ADDR_EXP 68
41912: PUSH
41913: EMPTY
41914: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41915: LD_ADDR_EXP 69
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41922: LD_ADDR_EXP 71
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41929: LD_ADDR_EXP 70
41933: PUSH
41934: EMPTY
41935: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41936: LD_ADDR_EXP 72
41940: PUSH
41941: LD_INT 300
41943: PUSH
41944: LD_INT 100
41946: PUSH
41947: LD_INT 25
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 1
41959: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41960: LD_INT 0
41962: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41963: LD_VAR 0 2
41967: PUSH
41968: LD_VAR 0 3
41972: PUSH
41973: LD_VAR 0 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: LIST
41982: PUSH
41983: LD_VAR 0 1
41987: IN
41988: IFFALSE 42002
// result := mreg_list else
41990: LD_ADDR_VAR 0 5
41994: PUSH
41995: LD_VAR 0 1
41999: ST_TO_ADDR
42000: GO 42036
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42002: LD_ADDR_VAR 0 1
42006: PUSH
42007: LD_VAR 0 1
42011: PUSH
42012: LD_VAR 0 2
42016: PUSH
42017: LD_VAR 0 3
42021: PUSH
42022: LD_VAR 0 4
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: ADD
42035: ST_TO_ADDR
// result := mreg_list ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_VAR 0 1
42045: ST_TO_ADDR
// end ;
42046: LD_VAR 0 5
42050: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42051: LD_INT 0
42053: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42054: LD_VAR 0 2
42058: PUSH
42059: LD_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PUSH
42074: LD_VAR 0 1
42078: IN
42079: IFFALSE 42117
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_VAR 0 1
42090: PUSH
42091: LD_VAR 0 2
42095: PUSH
42096: LD_VAR 0 3
42100: PUSH
42101: LD_VAR 0 4
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: DIFF
42114: ST_TO_ADDR
42115: GO 42127
// result := mreg_list ;
42117: LD_ADDR_VAR 0 5
42121: PUSH
42122: LD_VAR 0 1
42126: ST_TO_ADDR
// end ;
42127: LD_VAR 0 5
42131: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42132: LD_INT 0
42134: PPUSH
42135: PPUSH
42136: PPUSH
// for j = 1 to 8 do
42137: LD_ADDR_VAR 0 3
42141: PUSH
42142: DOUBLE
42143: LD_INT 1
42145: DEC
42146: ST_TO_ADDR
42147: LD_INT 8
42149: PUSH
42150: FOR_TO
42151: IFFALSE 42992
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42153: LD_VAR 0 3
42157: PPUSH
42158: LD_INT 51
42160: PUSH
42161: EMPTY
42162: LIST
42163: PPUSH
42164: CALL 11651 0 2
42168: PUSH
42169: LD_OWVAR 2
42173: PUSH
42174: LD_VAR 0 3
42178: EQUAL
42179: NOT
42180: AND
42181: IFFALSE 42199
// MREG_SidesList := MREG_SidesList ^ 1 else
42183: LD_ADDR_EXP 39
42187: PUSH
42188: LD_EXP 39
42192: PUSH
42193: LD_INT 1
42195: ADD
42196: ST_TO_ADDR
42197: GO 42213
// MREG_SidesList := MREG_SidesList ^ 0 ;
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 0
42211: ADD
42212: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42213: LD_VAR 0 3
42217: PPUSH
42218: LD_INT 2
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 34
42233: PUSH
42234: LD_INT 32
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 34
42243: PUSH
42244: LD_INT 51
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11952 0 2
42264: IFFALSE 42365
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42266: LD_ADDR_VAR 0 2
42270: PUSH
42271: LD_VAR 0 3
42275: PPUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 34
42281: PUSH
42282: LD_INT 12
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 34
42291: PUSH
42292: LD_INT 32
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 34
42301: PUSH
42302: LD_INT 51
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: CALL 11952 0 2
42322: PUSH
42323: FOR_IN
42324: IFFALSE 42363
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42326: LD_ADDR_EXP 41
42330: PUSH
42331: LD_EXP 41
42335: PPUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_VAR 0 2
42345: PPUSH
42346: LD_VAR 0 2
42350: PPUSH
42351: CALL_OW 264
42355: PPUSH
42356: CALL 41960 0 4
42360: ST_TO_ADDR
42361: GO 42323
42363: POP
42364: POP
// if MCF_Class ( j , 4 , [ ] ) then
42365: LD_VAR 0 3
42369: PPUSH
42370: LD_INT 4
42372: PPUSH
42373: EMPTY
42374: PPUSH
42375: CALL 11734 0 3
42379: IFFALSE 42412
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42381: LD_ADDR_EXP 54
42385: PUSH
42386: LD_EXP 54
42390: PUSH
42391: LD_VAR 0 3
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: EMPTY
42400: PPUSH
42401: CALL 11734 0 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: ADD
42409: ST_TO_ADDR
42410: GO 42429
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42412: LD_ADDR_EXP 54
42416: PUSH
42417: LD_EXP 54
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: ADD
42428: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42429: LD_VAR 0 3
42433: PPUSH
42434: LD_INT 3
42436: PPUSH
42437: EMPTY
42438: PPUSH
42439: CALL 11734 0 3
42443: IFFALSE 42476
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42445: LD_ADDR_EXP 55
42449: PUSH
42450: LD_EXP 55
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_INT 3
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL 11734 0 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: ADD
42473: ST_TO_ADDR
42474: GO 42493
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42476: LD_ADDR_EXP 55
42480: PUSH
42481: LD_EXP 55
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: ADD
42492: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42493: LD_VAR 0 3
42497: PPUSH
42498: LD_INT 1
42500: PPUSH
42501: EMPTY
42502: PPUSH
42503: CALL 11734 0 3
42507: IFFALSE 42540
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42509: LD_ADDR_EXP 56
42513: PUSH
42514: LD_EXP 56
42518: PUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_INT 1
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 11734 0 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: ADD
42537: ST_TO_ADDR
42538: GO 42557
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42540: LD_ADDR_EXP 56
42544: PUSH
42545: LD_EXP 56
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: ADD
42556: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_INT 2
42564: PPUSH
42565: EMPTY
42566: PPUSH
42567: CALL 11734 0 3
42571: IFFALSE 42604
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42573: LD_ADDR_EXP 57
42577: PUSH
42578: LD_EXP 57
42582: PUSH
42583: LD_VAR 0 3
42587: PPUSH
42588: LD_INT 2
42590: PPUSH
42591: EMPTY
42592: PPUSH
42593: CALL 11734 0 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: ADD
42601: ST_TO_ADDR
42602: GO 42621
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42604: LD_ADDR_EXP 57
42608: PUSH
42609: LD_EXP 57
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: EMPTY
42618: LIST
42619: ADD
42620: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42621: LD_ADDR_EXP 47
42625: PUSH
42626: LD_EXP 47
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: ADD
42637: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42638: LD_ADDR_EXP 35
42642: PUSH
42643: LD_EXP 35
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: ADD
42654: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42655: LD_ADDR_EXP 37
42659: PUSH
42660: LD_EXP 37
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42672: LD_ADDR_EXP 58
42676: PUSH
42677: LD_EXP 58
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: EMPTY
42686: LIST
42687: ADD
42688: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42689: LD_ADDR_EXP 59
42693: PUSH
42694: LD_EXP 59
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: ADD
42705: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42706: LD_ADDR_EXP 51
42710: PUSH
42711: LD_EXP 51
42715: PUSH
42716: LD_INT 0
42718: PUSH
42719: EMPTY
42720: LIST
42721: ADD
42722: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42723: LD_ADDR_EXP 38
42727: PUSH
42728: LD_EXP 38
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: LD_INT 0
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42755: LD_ADDR_EXP 60
42759: PUSH
42760: LD_EXP 60
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: ADD
42777: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42778: LD_ADDR_EXP 61
42782: PUSH
42783: LD_EXP 61
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: EMPTY
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42798: LD_ADDR_EXP 42
42802: PUSH
42803: LD_EXP 42
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42815: LD_ADDR_EXP 63
42819: PUSH
42820: LD_EXP 63
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42832: LD_ADDR_EXP 64
42836: PUSH
42837: LD_EXP 64
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: ADD
42848: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42849: LD_ADDR_EXP 65
42853: PUSH
42854: LD_EXP 65
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: ADD
42865: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42866: LD_ADDR_EXP 66
42870: PUSH
42871: LD_EXP 66
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42883: LD_ADDR_EXP 67
42887: PUSH
42888: LD_EXP 67
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: ADD
42899: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42900: LD_ADDR_EXP 68
42904: PUSH
42905: LD_EXP 68
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: ADD
42916: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42917: LD_ADDR_EXP 69
42921: PUSH
42922: LD_EXP 69
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: EMPTY
42931: LIST
42932: ADD
42933: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42934: LD_ADDR_EXP 71
42938: PUSH
42939: LD_EXP 71
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42951: LD_ADDR_EXP 70
42955: PUSH
42956: LD_EXP 70
42960: PUSH
42961: LD_INT 0
42963: ADD
42964: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42965: LD_ADDR_EXP 62
42969: PUSH
42970: LD_EXP 62
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ADD
42989: ST_TO_ADDR
// end ;
42990: GO 42150
42992: POP
42993: POP
// end ;
42994: LD_VAR 0 1
42998: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42999: LD_INT 0
43001: PPUSH
43002: PPUSH
43003: PPUSH
// m := false ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_INT 0
43011: ST_TO_ADDR
// for i = 1 to mreg do
43012: LD_ADDR_VAR 0 4
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 2
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43064
// if mreg [ i ] [ 1 ] = side then
43030: LD_VAR 0 2
43034: PUSH
43035: LD_VAR 0 4
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_VAR 0 1
43049: EQUAL
43050: IFFALSE 43062
// begin m := true ;
43052: LD_ADDR_VAR 0 5
43056: PUSH
43057: LD_INT 1
43059: ST_TO_ADDR
// break ;
43060: GO 43064
// end ;
43062: GO 43027
43064: POP
43065: POP
// result := m ;
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// m := 0 ;
43086: LD_ADDR_VAR 0 5
43090: PUSH
43091: LD_INT 0
43093: ST_TO_ADDR
// for i = 1 to mreg do
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_VAR 0 2
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43150
// if mreg [ i ] [ 1 ] = side then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_VAR 0 4
43121: ARRAY
43122: PUSH
43123: LD_INT 1
43125: ARRAY
43126: PUSH
43127: LD_VAR 0 1
43131: EQUAL
43132: IFFALSE 43148
// begin m := m + 1 ;
43134: LD_ADDR_VAR 0 5
43138: PUSH
43139: LD_VAR 0 5
43143: PUSH
43144: LD_INT 1
43146: PLUS
43147: ST_TO_ADDR
// end ;
43148: GO 43109
43150: POP
43151: POP
// result := m ;
43152: LD_ADDR_VAR 0 3
43156: PUSH
43157: LD_VAR 0 5
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
// result := 0 ;
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: LD_INT 0
43178: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43179: LD_ADDR_VAR 0 4
43183: PUSH
43184: DOUBLE
43185: LD_INT 1
43187: DEC
43188: ST_TO_ADDR
43189: LD_EXP 53
43193: PUSH
43194: FOR_TO
43195: IFFALSE 43257
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43197: LD_EXP 53
43201: PUSH
43202: LD_VAR 0 4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PUSH
43212: LD_VAR 0 1
43216: EQUAL
43217: PUSH
43218: LD_EXP 53
43222: PUSH
43223: LD_VAR 0 4
43227: ARRAY
43228: PUSH
43229: LD_INT 2
43231: ARRAY
43232: PUSH
43233: LD_VAR 0 2
43237: EQUAL
43238: AND
43239: IFFALSE 43255
// begin result := result + 1 ;
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 3
43250: PUSH
43251: LD_INT 1
43253: PLUS
43254: ST_TO_ADDR
// end ;
43255: GO 43194
43257: POP
43258: POP
// end ; end_of_file end_of_file
43259: LD_VAR 0 3
43263: RET
// every 0 0$1 do
43264: GO 43266
43266: DISABLE
// begin enable ;
43267: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43268: LD_STRING updateTimer(
43270: PUSH
43271: LD_OWVAR 1
43275: STR
43276: PUSH
43277: LD_STRING );
43279: STR
43280: PPUSH
43281: CALL_OW 559
// end ;
43285: END
// export function SOS_MapStart ( ) ; begin
43286: LD_INT 0
43288: PPUSH
// if streamModeActive then
43289: LD_EXP 73
43293: IFFALSE 43302
// DefineStreamItems ( true ) ;
43295: LD_INT 1
43297: PPUSH
43298: CALL 44956 0 1
// UpdateFactoryWaypoints ( ) ;
43302: CALL 57817 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43306: CALL 58074 0 0
// end ;
43310: LD_VAR 0 1
43314: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43315: LD_INT 0
43317: PPUSH
// if p2 = hack_mode then
43318: LD_VAR 0 2
43322: PUSH
43323: LD_INT 100
43325: EQUAL
43326: IFFALSE 44329
// begin if not StreamModeActive then
43328: LD_EXP 73
43332: NOT
43333: IFFALSE 43343
// StreamModeActive := true ;
43335: LD_ADDR_EXP 73
43339: PUSH
43340: LD_INT 1
43342: ST_TO_ADDR
// if p3 = 0 then
43343: LD_VAR 0 3
43347: PUSH
43348: LD_INT 0
43350: EQUAL
43351: IFFALSE 43357
// InitStreamMode ;
43353: CALL 44492 0 0
// if p3 = 1 then
43357: LD_VAR 0 3
43361: PUSH
43362: LD_INT 1
43364: EQUAL
43365: IFFALSE 43375
// sRocket := true ;
43367: LD_ADDR_EXP 78
43371: PUSH
43372: LD_INT 1
43374: ST_TO_ADDR
// if p3 = 2 then
43375: LD_VAR 0 3
43379: PUSH
43380: LD_INT 2
43382: EQUAL
43383: IFFALSE 43393
// sSpeed := true ;
43385: LD_ADDR_EXP 77
43389: PUSH
43390: LD_INT 1
43392: ST_TO_ADDR
// if p3 = 3 then
43393: LD_VAR 0 3
43397: PUSH
43398: LD_INT 3
43400: EQUAL
43401: IFFALSE 43411
// sEngine := true ;
43403: LD_ADDR_EXP 79
43407: PUSH
43408: LD_INT 1
43410: ST_TO_ADDR
// if p3 = 4 then
43411: LD_VAR 0 3
43415: PUSH
43416: LD_INT 4
43418: EQUAL
43419: IFFALSE 43429
// sSpec := true ;
43421: LD_ADDR_EXP 76
43425: PUSH
43426: LD_INT 1
43428: ST_TO_ADDR
// if p3 = 5 then
43429: LD_VAR 0 3
43433: PUSH
43434: LD_INT 5
43436: EQUAL
43437: IFFALSE 43447
// sLevel := true ;
43439: LD_ADDR_EXP 80
43443: PUSH
43444: LD_INT 1
43446: ST_TO_ADDR
// if p3 = 6 then
43447: LD_VAR 0 3
43451: PUSH
43452: LD_INT 6
43454: EQUAL
43455: IFFALSE 43465
// sArmoury := true ;
43457: LD_ADDR_EXP 81
43461: PUSH
43462: LD_INT 1
43464: ST_TO_ADDR
// if p3 = 7 then
43465: LD_VAR 0 3
43469: PUSH
43470: LD_INT 7
43472: EQUAL
43473: IFFALSE 43483
// sRadar := true ;
43475: LD_ADDR_EXP 82
43479: PUSH
43480: LD_INT 1
43482: ST_TO_ADDR
// if p3 = 8 then
43483: LD_VAR 0 3
43487: PUSH
43488: LD_INT 8
43490: EQUAL
43491: IFFALSE 43501
// sBunker := true ;
43493: LD_ADDR_EXP 83
43497: PUSH
43498: LD_INT 1
43500: ST_TO_ADDR
// if p3 = 9 then
43501: LD_VAR 0 3
43505: PUSH
43506: LD_INT 9
43508: EQUAL
43509: IFFALSE 43519
// sHack := true ;
43511: LD_ADDR_EXP 84
43515: PUSH
43516: LD_INT 1
43518: ST_TO_ADDR
// if p3 = 10 then
43519: LD_VAR 0 3
43523: PUSH
43524: LD_INT 10
43526: EQUAL
43527: IFFALSE 43537
// sFire := true ;
43529: LD_ADDR_EXP 85
43533: PUSH
43534: LD_INT 1
43536: ST_TO_ADDR
// if p3 = 11 then
43537: LD_VAR 0 3
43541: PUSH
43542: LD_INT 11
43544: EQUAL
43545: IFFALSE 43555
// sRefresh := true ;
43547: LD_ADDR_EXP 86
43551: PUSH
43552: LD_INT 1
43554: ST_TO_ADDR
// if p3 = 12 then
43555: LD_VAR 0 3
43559: PUSH
43560: LD_INT 12
43562: EQUAL
43563: IFFALSE 43573
// sExp := true ;
43565: LD_ADDR_EXP 87
43569: PUSH
43570: LD_INT 1
43572: ST_TO_ADDR
// if p3 = 13 then
43573: LD_VAR 0 3
43577: PUSH
43578: LD_INT 13
43580: EQUAL
43581: IFFALSE 43591
// sDepot := true ;
43583: LD_ADDR_EXP 88
43587: PUSH
43588: LD_INT 1
43590: ST_TO_ADDR
// if p3 = 14 then
43591: LD_VAR 0 3
43595: PUSH
43596: LD_INT 14
43598: EQUAL
43599: IFFALSE 43609
// sFlag := true ;
43601: LD_ADDR_EXP 89
43605: PUSH
43606: LD_INT 1
43608: ST_TO_ADDR
// if p3 = 15 then
43609: LD_VAR 0 3
43613: PUSH
43614: LD_INT 15
43616: EQUAL
43617: IFFALSE 43627
// sKamikadze := true ;
43619: LD_ADDR_EXP 97
43623: PUSH
43624: LD_INT 1
43626: ST_TO_ADDR
// if p3 = 16 then
43627: LD_VAR 0 3
43631: PUSH
43632: LD_INT 16
43634: EQUAL
43635: IFFALSE 43645
// sTroll := true ;
43637: LD_ADDR_EXP 98
43641: PUSH
43642: LD_INT 1
43644: ST_TO_ADDR
// if p3 = 17 then
43645: LD_VAR 0 3
43649: PUSH
43650: LD_INT 17
43652: EQUAL
43653: IFFALSE 43663
// sSlow := true ;
43655: LD_ADDR_EXP 99
43659: PUSH
43660: LD_INT 1
43662: ST_TO_ADDR
// if p3 = 18 then
43663: LD_VAR 0 3
43667: PUSH
43668: LD_INT 18
43670: EQUAL
43671: IFFALSE 43681
// sLack := true ;
43673: LD_ADDR_EXP 100
43677: PUSH
43678: LD_INT 1
43680: ST_TO_ADDR
// if p3 = 19 then
43681: LD_VAR 0 3
43685: PUSH
43686: LD_INT 19
43688: EQUAL
43689: IFFALSE 43699
// sTank := true ;
43691: LD_ADDR_EXP 102
43695: PUSH
43696: LD_INT 1
43698: ST_TO_ADDR
// if p3 = 20 then
43699: LD_VAR 0 3
43703: PUSH
43704: LD_INT 20
43706: EQUAL
43707: IFFALSE 43717
// sRemote := true ;
43709: LD_ADDR_EXP 103
43713: PUSH
43714: LD_INT 1
43716: ST_TO_ADDR
// if p3 = 21 then
43717: LD_VAR 0 3
43721: PUSH
43722: LD_INT 21
43724: EQUAL
43725: IFFALSE 43735
// sPowell := true ;
43727: LD_ADDR_EXP 104
43731: PUSH
43732: LD_INT 1
43734: ST_TO_ADDR
// if p3 = 22 then
43735: LD_VAR 0 3
43739: PUSH
43740: LD_INT 22
43742: EQUAL
43743: IFFALSE 43753
// sTeleport := true ;
43745: LD_ADDR_EXP 107
43749: PUSH
43750: LD_INT 1
43752: ST_TO_ADDR
// if p3 = 23 then
43753: LD_VAR 0 3
43757: PUSH
43758: LD_INT 23
43760: EQUAL
43761: IFFALSE 43771
// sOilTower := true ;
43763: LD_ADDR_EXP 109
43767: PUSH
43768: LD_INT 1
43770: ST_TO_ADDR
// if p3 = 24 then
43771: LD_VAR 0 3
43775: PUSH
43776: LD_INT 24
43778: EQUAL
43779: IFFALSE 43789
// sShovel := true ;
43781: LD_ADDR_EXP 110
43785: PUSH
43786: LD_INT 1
43788: ST_TO_ADDR
// if p3 = 25 then
43789: LD_VAR 0 3
43793: PUSH
43794: LD_INT 25
43796: EQUAL
43797: IFFALSE 43807
// sSheik := true ;
43799: LD_ADDR_EXP 111
43803: PUSH
43804: LD_INT 1
43806: ST_TO_ADDR
// if p3 = 26 then
43807: LD_VAR 0 3
43811: PUSH
43812: LD_INT 26
43814: EQUAL
43815: IFFALSE 43825
// sEarthquake := true ;
43817: LD_ADDR_EXP 113
43821: PUSH
43822: LD_INT 1
43824: ST_TO_ADDR
// if p3 = 27 then
43825: LD_VAR 0 3
43829: PUSH
43830: LD_INT 27
43832: EQUAL
43833: IFFALSE 43843
// sAI := true ;
43835: LD_ADDR_EXP 114
43839: PUSH
43840: LD_INT 1
43842: ST_TO_ADDR
// if p3 = 28 then
43843: LD_VAR 0 3
43847: PUSH
43848: LD_INT 28
43850: EQUAL
43851: IFFALSE 43861
// sCargo := true ;
43853: LD_ADDR_EXP 117
43857: PUSH
43858: LD_INT 1
43860: ST_TO_ADDR
// if p3 = 29 then
43861: LD_VAR 0 3
43865: PUSH
43866: LD_INT 29
43868: EQUAL
43869: IFFALSE 43879
// sDLaser := true ;
43871: LD_ADDR_EXP 118
43875: PUSH
43876: LD_INT 1
43878: ST_TO_ADDR
// if p3 = 30 then
43879: LD_VAR 0 3
43883: PUSH
43884: LD_INT 30
43886: EQUAL
43887: IFFALSE 43897
// sExchange := true ;
43889: LD_ADDR_EXP 119
43893: PUSH
43894: LD_INT 1
43896: ST_TO_ADDR
// if p3 = 31 then
43897: LD_VAR 0 3
43901: PUSH
43902: LD_INT 31
43904: EQUAL
43905: IFFALSE 43915
// sFac := true ;
43907: LD_ADDR_EXP 120
43911: PUSH
43912: LD_INT 1
43914: ST_TO_ADDR
// if p3 = 32 then
43915: LD_VAR 0 3
43919: PUSH
43920: LD_INT 32
43922: EQUAL
43923: IFFALSE 43933
// sPower := true ;
43925: LD_ADDR_EXP 121
43929: PUSH
43930: LD_INT 1
43932: ST_TO_ADDR
// if p3 = 33 then
43933: LD_VAR 0 3
43937: PUSH
43938: LD_INT 33
43940: EQUAL
43941: IFFALSE 43951
// sRandom := true ;
43943: LD_ADDR_EXP 122
43947: PUSH
43948: LD_INT 1
43950: ST_TO_ADDR
// if p3 = 34 then
43951: LD_VAR 0 3
43955: PUSH
43956: LD_INT 34
43958: EQUAL
43959: IFFALSE 43969
// sShield := true ;
43961: LD_ADDR_EXP 123
43965: PUSH
43966: LD_INT 1
43968: ST_TO_ADDR
// if p3 = 35 then
43969: LD_VAR 0 3
43973: PUSH
43974: LD_INT 35
43976: EQUAL
43977: IFFALSE 43987
// sTime := true ;
43979: LD_ADDR_EXP 124
43983: PUSH
43984: LD_INT 1
43986: ST_TO_ADDR
// if p3 = 36 then
43987: LD_VAR 0 3
43991: PUSH
43992: LD_INT 36
43994: EQUAL
43995: IFFALSE 44005
// sTools := true ;
43997: LD_ADDR_EXP 125
44001: PUSH
44002: LD_INT 1
44004: ST_TO_ADDR
// if p3 = 101 then
44005: LD_VAR 0 3
44009: PUSH
44010: LD_INT 101
44012: EQUAL
44013: IFFALSE 44023
// sSold := true ;
44015: LD_ADDR_EXP 90
44019: PUSH
44020: LD_INT 1
44022: ST_TO_ADDR
// if p3 = 102 then
44023: LD_VAR 0 3
44027: PUSH
44028: LD_INT 102
44030: EQUAL
44031: IFFALSE 44041
// sDiff := true ;
44033: LD_ADDR_EXP 91
44037: PUSH
44038: LD_INT 1
44040: ST_TO_ADDR
// if p3 = 103 then
44041: LD_VAR 0 3
44045: PUSH
44046: LD_INT 103
44048: EQUAL
44049: IFFALSE 44059
// sFog := true ;
44051: LD_ADDR_EXP 94
44055: PUSH
44056: LD_INT 1
44058: ST_TO_ADDR
// if p3 = 104 then
44059: LD_VAR 0 3
44063: PUSH
44064: LD_INT 104
44066: EQUAL
44067: IFFALSE 44077
// sReset := true ;
44069: LD_ADDR_EXP 95
44073: PUSH
44074: LD_INT 1
44076: ST_TO_ADDR
// if p3 = 105 then
44077: LD_VAR 0 3
44081: PUSH
44082: LD_INT 105
44084: EQUAL
44085: IFFALSE 44095
// sSun := true ;
44087: LD_ADDR_EXP 96
44091: PUSH
44092: LD_INT 1
44094: ST_TO_ADDR
// if p3 = 106 then
44095: LD_VAR 0 3
44099: PUSH
44100: LD_INT 106
44102: EQUAL
44103: IFFALSE 44113
// sTiger := true ;
44105: LD_ADDR_EXP 92
44109: PUSH
44110: LD_INT 1
44112: ST_TO_ADDR
// if p3 = 107 then
44113: LD_VAR 0 3
44117: PUSH
44118: LD_INT 107
44120: EQUAL
44121: IFFALSE 44131
// sBomb := true ;
44123: LD_ADDR_EXP 93
44127: PUSH
44128: LD_INT 1
44130: ST_TO_ADDR
// if p3 = 108 then
44131: LD_VAR 0 3
44135: PUSH
44136: LD_INT 108
44138: EQUAL
44139: IFFALSE 44149
// sWound := true ;
44141: LD_ADDR_EXP 101
44145: PUSH
44146: LD_INT 1
44148: ST_TO_ADDR
// if p3 = 109 then
44149: LD_VAR 0 3
44153: PUSH
44154: LD_INT 109
44156: EQUAL
44157: IFFALSE 44167
// sBetray := true ;
44159: LD_ADDR_EXP 105
44163: PUSH
44164: LD_INT 1
44166: ST_TO_ADDR
// if p3 = 110 then
44167: LD_VAR 0 3
44171: PUSH
44172: LD_INT 110
44174: EQUAL
44175: IFFALSE 44185
// sContamin := true ;
44177: LD_ADDR_EXP 106
44181: PUSH
44182: LD_INT 1
44184: ST_TO_ADDR
// if p3 = 111 then
44185: LD_VAR 0 3
44189: PUSH
44190: LD_INT 111
44192: EQUAL
44193: IFFALSE 44203
// sOil := true ;
44195: LD_ADDR_EXP 108
44199: PUSH
44200: LD_INT 1
44202: ST_TO_ADDR
// if p3 = 112 then
44203: LD_VAR 0 3
44207: PUSH
44208: LD_INT 112
44210: EQUAL
44211: IFFALSE 44221
// sStu := true ;
44213: LD_ADDR_EXP 112
44217: PUSH
44218: LD_INT 1
44220: ST_TO_ADDR
// if p3 = 113 then
44221: LD_VAR 0 3
44225: PUSH
44226: LD_INT 113
44228: EQUAL
44229: IFFALSE 44239
// sBazooka := true ;
44231: LD_ADDR_EXP 115
44235: PUSH
44236: LD_INT 1
44238: ST_TO_ADDR
// if p3 = 114 then
44239: LD_VAR 0 3
44243: PUSH
44244: LD_INT 114
44246: EQUAL
44247: IFFALSE 44257
// sMortar := true ;
44249: LD_ADDR_EXP 116
44253: PUSH
44254: LD_INT 1
44256: ST_TO_ADDR
// if p3 = 115 then
44257: LD_VAR 0 3
44261: PUSH
44262: LD_INT 115
44264: EQUAL
44265: IFFALSE 44275
// sRanger := true ;
44267: LD_ADDR_EXP 126
44271: PUSH
44272: LD_INT 1
44274: ST_TO_ADDR
// if p3 = 116 then
44275: LD_VAR 0 3
44279: PUSH
44280: LD_INT 116
44282: EQUAL
44283: IFFALSE 44293
// sComputer := true ;
44285: LD_ADDR_EXP 127
44289: PUSH
44290: LD_INT 1
44292: ST_TO_ADDR
// if p3 = 117 then
44293: LD_VAR 0 3
44297: PUSH
44298: LD_INT 117
44300: EQUAL
44301: IFFALSE 44311
// s30 := true ;
44303: LD_ADDR_EXP 128
44307: PUSH
44308: LD_INT 1
44310: ST_TO_ADDR
// if p3 = 118 then
44311: LD_VAR 0 3
44315: PUSH
44316: LD_INT 118
44318: EQUAL
44319: IFFALSE 44329
// s60 := true ;
44321: LD_ADDR_EXP 129
44325: PUSH
44326: LD_INT 1
44328: ST_TO_ADDR
// end ; if p2 = stream_mode then
44329: LD_VAR 0 2
44333: PUSH
44334: LD_INT 101
44336: EQUAL
44337: IFFALSE 44465
// begin case p3 of 1 :
44339: LD_VAR 0 3
44343: PUSH
44344: LD_INT 1
44346: DOUBLE
44347: EQUAL
44348: IFTRUE 44352
44350: GO 44359
44352: POP
// hHackUnlimitedResources ; 2 :
44353: CALL 56563 0 0
44357: GO 44465
44359: LD_INT 2
44361: DOUBLE
44362: EQUAL
44363: IFTRUE 44367
44365: GO 44374
44367: POP
// hHackSetLevel10 ; 3 :
44368: CALL 56696 0 0
44372: GO 44465
44374: LD_INT 3
44376: DOUBLE
44377: EQUAL
44378: IFTRUE 44382
44380: GO 44389
44382: POP
// hHackSetLevel10YourUnits ; 4 :
44383: CALL 56781 0 0
44387: GO 44465
44389: LD_INT 4
44391: DOUBLE
44392: EQUAL
44393: IFTRUE 44397
44395: GO 44404
44397: POP
// hHackInvincible ; 5 :
44398: CALL 57229 0 0
44402: GO 44465
44404: LD_INT 5
44406: DOUBLE
44407: EQUAL
44408: IFTRUE 44412
44410: GO 44419
44412: POP
// hHackInvisible ; 6 :
44413: CALL 57340 0 0
44417: GO 44465
44419: LD_INT 6
44421: DOUBLE
44422: EQUAL
44423: IFTRUE 44427
44425: GO 44434
44427: POP
// hHackChangeYourSide ; 7 :
44428: CALL 57397 0 0
44432: GO 44465
44434: LD_INT 7
44436: DOUBLE
44437: EQUAL
44438: IFTRUE 44442
44440: GO 44449
44442: POP
// hHackChangeUnitSide ; 8 :
44443: CALL 57439 0 0
44447: GO 44465
44449: LD_INT 8
44451: DOUBLE
44452: EQUAL
44453: IFTRUE 44457
44455: GO 44464
44457: POP
// hHackFog ; end ;
44458: CALL 57540 0 0
44462: GO 44465
44464: POP
// end ; end ;
44465: LD_VAR 0 7
44469: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44470: GO 44472
44472: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44473: LD_STRING initStreamRollete();
44475: PPUSH
44476: CALL_OW 559
// InitStreamMode ;
44480: CALL 44492 0 0
// DefineStreamItems ( false ) ;
44484: LD_INT 0
44486: PPUSH
44487: CALL 44956 0 1
// end ;
44491: END
// function InitStreamMode ; begin
44492: LD_INT 0
44494: PPUSH
// streamModeActive := false ;
44495: LD_ADDR_EXP 73
44499: PUSH
44500: LD_INT 0
44502: ST_TO_ADDR
// normalCounter := 36 ;
44503: LD_ADDR_EXP 74
44507: PUSH
44508: LD_INT 36
44510: ST_TO_ADDR
// hardcoreCounter := 18 ;
44511: LD_ADDR_EXP 75
44515: PUSH
44516: LD_INT 18
44518: ST_TO_ADDR
// sRocket := false ;
44519: LD_ADDR_EXP 78
44523: PUSH
44524: LD_INT 0
44526: ST_TO_ADDR
// sSpeed := false ;
44527: LD_ADDR_EXP 77
44531: PUSH
44532: LD_INT 0
44534: ST_TO_ADDR
// sEngine := false ;
44535: LD_ADDR_EXP 79
44539: PUSH
44540: LD_INT 0
44542: ST_TO_ADDR
// sSpec := false ;
44543: LD_ADDR_EXP 76
44547: PUSH
44548: LD_INT 0
44550: ST_TO_ADDR
// sLevel := false ;
44551: LD_ADDR_EXP 80
44555: PUSH
44556: LD_INT 0
44558: ST_TO_ADDR
// sArmoury := false ;
44559: LD_ADDR_EXP 81
44563: PUSH
44564: LD_INT 0
44566: ST_TO_ADDR
// sRadar := false ;
44567: LD_ADDR_EXP 82
44571: PUSH
44572: LD_INT 0
44574: ST_TO_ADDR
// sBunker := false ;
44575: LD_ADDR_EXP 83
44579: PUSH
44580: LD_INT 0
44582: ST_TO_ADDR
// sHack := false ;
44583: LD_ADDR_EXP 84
44587: PUSH
44588: LD_INT 0
44590: ST_TO_ADDR
// sFire := false ;
44591: LD_ADDR_EXP 85
44595: PUSH
44596: LD_INT 0
44598: ST_TO_ADDR
// sRefresh := false ;
44599: LD_ADDR_EXP 86
44603: PUSH
44604: LD_INT 0
44606: ST_TO_ADDR
// sExp := false ;
44607: LD_ADDR_EXP 87
44611: PUSH
44612: LD_INT 0
44614: ST_TO_ADDR
// sDepot := false ;
44615: LD_ADDR_EXP 88
44619: PUSH
44620: LD_INT 0
44622: ST_TO_ADDR
// sFlag := false ;
44623: LD_ADDR_EXP 89
44627: PUSH
44628: LD_INT 0
44630: ST_TO_ADDR
// sKamikadze := false ;
44631: LD_ADDR_EXP 97
44635: PUSH
44636: LD_INT 0
44638: ST_TO_ADDR
// sTroll := false ;
44639: LD_ADDR_EXP 98
44643: PUSH
44644: LD_INT 0
44646: ST_TO_ADDR
// sSlow := false ;
44647: LD_ADDR_EXP 99
44651: PUSH
44652: LD_INT 0
44654: ST_TO_ADDR
// sLack := false ;
44655: LD_ADDR_EXP 100
44659: PUSH
44660: LD_INT 0
44662: ST_TO_ADDR
// sTank := false ;
44663: LD_ADDR_EXP 102
44667: PUSH
44668: LD_INT 0
44670: ST_TO_ADDR
// sRemote := false ;
44671: LD_ADDR_EXP 103
44675: PUSH
44676: LD_INT 0
44678: ST_TO_ADDR
// sPowell := false ;
44679: LD_ADDR_EXP 104
44683: PUSH
44684: LD_INT 0
44686: ST_TO_ADDR
// sTeleport := false ;
44687: LD_ADDR_EXP 107
44691: PUSH
44692: LD_INT 0
44694: ST_TO_ADDR
// sOilTower := false ;
44695: LD_ADDR_EXP 109
44699: PUSH
44700: LD_INT 0
44702: ST_TO_ADDR
// sShovel := false ;
44703: LD_ADDR_EXP 110
44707: PUSH
44708: LD_INT 0
44710: ST_TO_ADDR
// sSheik := false ;
44711: LD_ADDR_EXP 111
44715: PUSH
44716: LD_INT 0
44718: ST_TO_ADDR
// sEarthquake := false ;
44719: LD_ADDR_EXP 113
44723: PUSH
44724: LD_INT 0
44726: ST_TO_ADDR
// sAI := false ;
44727: LD_ADDR_EXP 114
44731: PUSH
44732: LD_INT 0
44734: ST_TO_ADDR
// sCargo := false ;
44735: LD_ADDR_EXP 117
44739: PUSH
44740: LD_INT 0
44742: ST_TO_ADDR
// sDLaser := false ;
44743: LD_ADDR_EXP 118
44747: PUSH
44748: LD_INT 0
44750: ST_TO_ADDR
// sExchange := false ;
44751: LD_ADDR_EXP 119
44755: PUSH
44756: LD_INT 0
44758: ST_TO_ADDR
// sFac := false ;
44759: LD_ADDR_EXP 120
44763: PUSH
44764: LD_INT 0
44766: ST_TO_ADDR
// sPower := false ;
44767: LD_ADDR_EXP 121
44771: PUSH
44772: LD_INT 0
44774: ST_TO_ADDR
// sRandom := false ;
44775: LD_ADDR_EXP 122
44779: PUSH
44780: LD_INT 0
44782: ST_TO_ADDR
// sShield := false ;
44783: LD_ADDR_EXP 123
44787: PUSH
44788: LD_INT 0
44790: ST_TO_ADDR
// sTime := false ;
44791: LD_ADDR_EXP 124
44795: PUSH
44796: LD_INT 0
44798: ST_TO_ADDR
// sTools := false ;
44799: LD_ADDR_EXP 125
44803: PUSH
44804: LD_INT 0
44806: ST_TO_ADDR
// sSold := false ;
44807: LD_ADDR_EXP 90
44811: PUSH
44812: LD_INT 0
44814: ST_TO_ADDR
// sDiff := false ;
44815: LD_ADDR_EXP 91
44819: PUSH
44820: LD_INT 0
44822: ST_TO_ADDR
// sFog := false ;
44823: LD_ADDR_EXP 94
44827: PUSH
44828: LD_INT 0
44830: ST_TO_ADDR
// sReset := false ;
44831: LD_ADDR_EXP 95
44835: PUSH
44836: LD_INT 0
44838: ST_TO_ADDR
// sSun := false ;
44839: LD_ADDR_EXP 96
44843: PUSH
44844: LD_INT 0
44846: ST_TO_ADDR
// sTiger := false ;
44847: LD_ADDR_EXP 92
44851: PUSH
44852: LD_INT 0
44854: ST_TO_ADDR
// sBomb := false ;
44855: LD_ADDR_EXP 93
44859: PUSH
44860: LD_INT 0
44862: ST_TO_ADDR
// sWound := false ;
44863: LD_ADDR_EXP 101
44867: PUSH
44868: LD_INT 0
44870: ST_TO_ADDR
// sBetray := false ;
44871: LD_ADDR_EXP 105
44875: PUSH
44876: LD_INT 0
44878: ST_TO_ADDR
// sContamin := false ;
44879: LD_ADDR_EXP 106
44883: PUSH
44884: LD_INT 0
44886: ST_TO_ADDR
// sOil := false ;
44887: LD_ADDR_EXP 108
44891: PUSH
44892: LD_INT 0
44894: ST_TO_ADDR
// sStu := false ;
44895: LD_ADDR_EXP 112
44899: PUSH
44900: LD_INT 0
44902: ST_TO_ADDR
// sBazooka := false ;
44903: LD_ADDR_EXP 115
44907: PUSH
44908: LD_INT 0
44910: ST_TO_ADDR
// sMortar := false ;
44911: LD_ADDR_EXP 116
44915: PUSH
44916: LD_INT 0
44918: ST_TO_ADDR
// sRanger := false ;
44919: LD_ADDR_EXP 126
44923: PUSH
44924: LD_INT 0
44926: ST_TO_ADDR
// sComputer := false ;
44927: LD_ADDR_EXP 127
44931: PUSH
44932: LD_INT 0
44934: ST_TO_ADDR
// s30 := false ;
44935: LD_ADDR_EXP 128
44939: PUSH
44940: LD_INT 0
44942: ST_TO_ADDR
// s60 := false ;
44943: LD_ADDR_EXP 129
44947: PUSH
44948: LD_INT 0
44950: ST_TO_ADDR
// end ;
44951: LD_VAR 0 1
44955: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
44956: LD_INT 0
44958: PPUSH
44959: PPUSH
44960: PPUSH
44961: PPUSH
44962: PPUSH
44963: PPUSH
44964: PPUSH
// result := [ ] ;
44965: LD_ADDR_VAR 0 2
44969: PUSH
44970: EMPTY
44971: ST_TO_ADDR
// if campaign_id = 1 then
44972: LD_OWVAR 69
44976: PUSH
44977: LD_INT 1
44979: EQUAL
44980: IFFALSE 48146
// begin case mission_number of 1 :
44982: LD_OWVAR 70
44986: PUSH
44987: LD_INT 1
44989: DOUBLE
44990: EQUAL
44991: IFTRUE 44995
44993: GO 45071
44995: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
44996: LD_ADDR_VAR 0 2
45000: PUSH
45001: LD_INT 2
45003: PUSH
45004: LD_INT 4
45006: PUSH
45007: LD_INT 11
45009: PUSH
45010: LD_INT 12
45012: PUSH
45013: LD_INT 15
45015: PUSH
45016: LD_INT 16
45018: PUSH
45019: LD_INT 22
45021: PUSH
45022: LD_INT 23
45024: PUSH
45025: LD_INT 26
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: LIST
45038: PUSH
45039: LD_INT 101
45041: PUSH
45042: LD_INT 102
45044: PUSH
45045: LD_INT 106
45047: PUSH
45048: LD_INT 116
45050: PUSH
45051: LD_INT 117
45053: PUSH
45054: LD_INT 118
45056: PUSH
45057: EMPTY
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: ST_TO_ADDR
45069: GO 48144
45071: LD_INT 2
45073: DOUBLE
45074: EQUAL
45075: IFTRUE 45079
45077: GO 45163
45079: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45080: LD_ADDR_VAR 0 2
45084: PUSH
45085: LD_INT 2
45087: PUSH
45088: LD_INT 4
45090: PUSH
45091: LD_INT 11
45093: PUSH
45094: LD_INT 12
45096: PUSH
45097: LD_INT 15
45099: PUSH
45100: LD_INT 16
45102: PUSH
45103: LD_INT 22
45105: PUSH
45106: LD_INT 23
45108: PUSH
45109: LD_INT 26
45111: PUSH
45112: EMPTY
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 101
45125: PUSH
45126: LD_INT 102
45128: PUSH
45129: LD_INT 105
45131: PUSH
45132: LD_INT 106
45134: PUSH
45135: LD_INT 108
45137: PUSH
45138: LD_INT 116
45140: PUSH
45141: LD_INT 117
45143: PUSH
45144: LD_INT 118
45146: PUSH
45147: EMPTY
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: ST_TO_ADDR
45161: GO 48144
45163: LD_INT 3
45165: DOUBLE
45166: EQUAL
45167: IFTRUE 45171
45169: GO 45259
45171: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45172: LD_ADDR_VAR 0 2
45176: PUSH
45177: LD_INT 2
45179: PUSH
45180: LD_INT 4
45182: PUSH
45183: LD_INT 5
45185: PUSH
45186: LD_INT 11
45188: PUSH
45189: LD_INT 12
45191: PUSH
45192: LD_INT 15
45194: PUSH
45195: LD_INT 16
45197: PUSH
45198: LD_INT 22
45200: PUSH
45201: LD_INT 26
45203: PUSH
45204: LD_INT 36
45206: PUSH
45207: EMPTY
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 101
45221: PUSH
45222: LD_INT 102
45224: PUSH
45225: LD_INT 105
45227: PUSH
45228: LD_INT 106
45230: PUSH
45231: LD_INT 108
45233: PUSH
45234: LD_INT 116
45236: PUSH
45237: LD_INT 117
45239: PUSH
45240: LD_INT 118
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: ST_TO_ADDR
45257: GO 48144
45259: LD_INT 4
45261: DOUBLE
45262: EQUAL
45263: IFTRUE 45267
45265: GO 45363
45267: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45268: LD_ADDR_VAR 0 2
45272: PUSH
45273: LD_INT 2
45275: PUSH
45276: LD_INT 4
45278: PUSH
45279: LD_INT 5
45281: PUSH
45282: LD_INT 8
45284: PUSH
45285: LD_INT 11
45287: PUSH
45288: LD_INT 12
45290: PUSH
45291: LD_INT 15
45293: PUSH
45294: LD_INT 16
45296: PUSH
45297: LD_INT 22
45299: PUSH
45300: LD_INT 23
45302: PUSH
45303: LD_INT 26
45305: PUSH
45306: LD_INT 36
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 101
45325: PUSH
45326: LD_INT 102
45328: PUSH
45329: LD_INT 105
45331: PUSH
45332: LD_INT 106
45334: PUSH
45335: LD_INT 108
45337: PUSH
45338: LD_INT 116
45340: PUSH
45341: LD_INT 117
45343: PUSH
45344: LD_INT 118
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: ST_TO_ADDR
45361: GO 48144
45363: LD_INT 5
45365: DOUBLE
45366: EQUAL
45367: IFTRUE 45371
45369: GO 45483
45371: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45372: LD_ADDR_VAR 0 2
45376: PUSH
45377: LD_INT 2
45379: PUSH
45380: LD_INT 4
45382: PUSH
45383: LD_INT 5
45385: PUSH
45386: LD_INT 6
45388: PUSH
45389: LD_INT 8
45391: PUSH
45392: LD_INT 11
45394: PUSH
45395: LD_INT 12
45397: PUSH
45398: LD_INT 15
45400: PUSH
45401: LD_INT 16
45403: PUSH
45404: LD_INT 22
45406: PUSH
45407: LD_INT 23
45409: PUSH
45410: LD_INT 25
45412: PUSH
45413: LD_INT 26
45415: PUSH
45416: LD_INT 36
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 101
45437: PUSH
45438: LD_INT 102
45440: PUSH
45441: LD_INT 105
45443: PUSH
45444: LD_INT 106
45446: PUSH
45447: LD_INT 108
45449: PUSH
45450: LD_INT 109
45452: PUSH
45453: LD_INT 112
45455: PUSH
45456: LD_INT 116
45458: PUSH
45459: LD_INT 117
45461: PUSH
45462: LD_INT 118
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: ST_TO_ADDR
45481: GO 48144
45483: LD_INT 6
45485: DOUBLE
45486: EQUAL
45487: IFTRUE 45491
45489: GO 45623
45491: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45492: LD_ADDR_VAR 0 2
45496: PUSH
45497: LD_INT 2
45499: PUSH
45500: LD_INT 4
45502: PUSH
45503: LD_INT 5
45505: PUSH
45506: LD_INT 6
45508: PUSH
45509: LD_INT 8
45511: PUSH
45512: LD_INT 11
45514: PUSH
45515: LD_INT 12
45517: PUSH
45518: LD_INT 15
45520: PUSH
45521: LD_INT 16
45523: PUSH
45524: LD_INT 20
45526: PUSH
45527: LD_INT 21
45529: PUSH
45530: LD_INT 22
45532: PUSH
45533: LD_INT 23
45535: PUSH
45536: LD_INT 25
45538: PUSH
45539: LD_INT 26
45541: PUSH
45542: LD_INT 30
45544: PUSH
45545: LD_INT 31
45547: PUSH
45548: LD_INT 32
45550: PUSH
45551: LD_INT 36
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 101
45577: PUSH
45578: LD_INT 102
45580: PUSH
45581: LD_INT 105
45583: PUSH
45584: LD_INT 106
45586: PUSH
45587: LD_INT 108
45589: PUSH
45590: LD_INT 109
45592: PUSH
45593: LD_INT 112
45595: PUSH
45596: LD_INT 116
45598: PUSH
45599: LD_INT 117
45601: PUSH
45602: LD_INT 118
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: ST_TO_ADDR
45621: GO 48144
45623: LD_INT 7
45625: DOUBLE
45626: EQUAL
45627: IFTRUE 45631
45629: GO 45743
45631: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45632: LD_ADDR_VAR 0 2
45636: PUSH
45637: LD_INT 2
45639: PUSH
45640: LD_INT 4
45642: PUSH
45643: LD_INT 5
45645: PUSH
45646: LD_INT 7
45648: PUSH
45649: LD_INT 11
45651: PUSH
45652: LD_INT 12
45654: PUSH
45655: LD_INT 15
45657: PUSH
45658: LD_INT 16
45660: PUSH
45661: LD_INT 20
45663: PUSH
45664: LD_INT 21
45666: PUSH
45667: LD_INT 22
45669: PUSH
45670: LD_INT 23
45672: PUSH
45673: LD_INT 25
45675: PUSH
45676: LD_INT 26
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 101
45697: PUSH
45698: LD_INT 102
45700: PUSH
45701: LD_INT 103
45703: PUSH
45704: LD_INT 105
45706: PUSH
45707: LD_INT 106
45709: PUSH
45710: LD_INT 108
45712: PUSH
45713: LD_INT 112
45715: PUSH
45716: LD_INT 116
45718: PUSH
45719: LD_INT 117
45721: PUSH
45722: LD_INT 118
45724: PUSH
45725: EMPTY
45726: LIST
45727: LIST
45728: LIST
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: LIST
45736: PUSH
45737: EMPTY
45738: LIST
45739: LIST
45740: ST_TO_ADDR
45741: GO 48144
45743: LD_INT 8
45745: DOUBLE
45746: EQUAL
45747: IFTRUE 45751
45749: GO 45891
45751: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45752: LD_ADDR_VAR 0 2
45756: PUSH
45757: LD_INT 2
45759: PUSH
45760: LD_INT 4
45762: PUSH
45763: LD_INT 5
45765: PUSH
45766: LD_INT 6
45768: PUSH
45769: LD_INT 7
45771: PUSH
45772: LD_INT 8
45774: PUSH
45775: LD_INT 11
45777: PUSH
45778: LD_INT 12
45780: PUSH
45781: LD_INT 15
45783: PUSH
45784: LD_INT 16
45786: PUSH
45787: LD_INT 20
45789: PUSH
45790: LD_INT 21
45792: PUSH
45793: LD_INT 22
45795: PUSH
45796: LD_INT 23
45798: PUSH
45799: LD_INT 25
45801: PUSH
45802: LD_INT 26
45804: PUSH
45805: LD_INT 30
45807: PUSH
45808: LD_INT 31
45810: PUSH
45811: LD_INT 32
45813: PUSH
45814: LD_INT 36
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: LIST
45828: LIST
45829: LIST
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 101
45841: PUSH
45842: LD_INT 102
45844: PUSH
45845: LD_INT 103
45847: PUSH
45848: LD_INT 105
45850: PUSH
45851: LD_INT 106
45853: PUSH
45854: LD_INT 108
45856: PUSH
45857: LD_INT 109
45859: PUSH
45860: LD_INT 112
45862: PUSH
45863: LD_INT 116
45865: PUSH
45866: LD_INT 117
45868: PUSH
45869: LD_INT 118
45871: PUSH
45872: EMPTY
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: ST_TO_ADDR
45889: GO 48144
45891: LD_INT 9
45893: DOUBLE
45894: EQUAL
45895: IFTRUE 45899
45897: GO 46047
45899: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
45900: LD_ADDR_VAR 0 2
45904: PUSH
45905: LD_INT 2
45907: PUSH
45908: LD_INT 4
45910: PUSH
45911: LD_INT 5
45913: PUSH
45914: LD_INT 6
45916: PUSH
45917: LD_INT 7
45919: PUSH
45920: LD_INT 8
45922: PUSH
45923: LD_INT 11
45925: PUSH
45926: LD_INT 12
45928: PUSH
45929: LD_INT 15
45931: PUSH
45932: LD_INT 16
45934: PUSH
45935: LD_INT 20
45937: PUSH
45938: LD_INT 21
45940: PUSH
45941: LD_INT 22
45943: PUSH
45944: LD_INT 23
45946: PUSH
45947: LD_INT 25
45949: PUSH
45950: LD_INT 26
45952: PUSH
45953: LD_INT 28
45955: PUSH
45956: LD_INT 30
45958: PUSH
45959: LD_INT 31
45961: PUSH
45962: LD_INT 32
45964: PUSH
45965: LD_INT 36
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: PUSH
45991: LD_INT 101
45993: PUSH
45994: LD_INT 102
45996: PUSH
45997: LD_INT 103
45999: PUSH
46000: LD_INT 105
46002: PUSH
46003: LD_INT 106
46005: PUSH
46006: LD_INT 108
46008: PUSH
46009: LD_INT 109
46011: PUSH
46012: LD_INT 112
46014: PUSH
46015: LD_INT 114
46017: PUSH
46018: LD_INT 116
46020: PUSH
46021: LD_INT 117
46023: PUSH
46024: LD_INT 118
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: ST_TO_ADDR
46045: GO 48144
46047: LD_INT 10
46049: DOUBLE
46050: EQUAL
46051: IFTRUE 46055
46053: GO 46251
46055: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46056: LD_ADDR_VAR 0 2
46060: PUSH
46061: LD_INT 2
46063: PUSH
46064: LD_INT 4
46066: PUSH
46067: LD_INT 5
46069: PUSH
46070: LD_INT 6
46072: PUSH
46073: LD_INT 7
46075: PUSH
46076: LD_INT 8
46078: PUSH
46079: LD_INT 9
46081: PUSH
46082: LD_INT 10
46084: PUSH
46085: LD_INT 11
46087: PUSH
46088: LD_INT 12
46090: PUSH
46091: LD_INT 13
46093: PUSH
46094: LD_INT 14
46096: PUSH
46097: LD_INT 15
46099: PUSH
46100: LD_INT 16
46102: PUSH
46103: LD_INT 17
46105: PUSH
46106: LD_INT 18
46108: PUSH
46109: LD_INT 19
46111: PUSH
46112: LD_INT 20
46114: PUSH
46115: LD_INT 21
46117: PUSH
46118: LD_INT 22
46120: PUSH
46121: LD_INT 23
46123: PUSH
46124: LD_INT 24
46126: PUSH
46127: LD_INT 25
46129: PUSH
46130: LD_INT 26
46132: PUSH
46133: LD_INT 28
46135: PUSH
46136: LD_INT 30
46138: PUSH
46139: LD_INT 31
46141: PUSH
46142: LD_INT 32
46144: PUSH
46145: LD_INT 36
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 101
46181: PUSH
46182: LD_INT 102
46184: PUSH
46185: LD_INT 103
46187: PUSH
46188: LD_INT 104
46190: PUSH
46191: LD_INT 105
46193: PUSH
46194: LD_INT 106
46196: PUSH
46197: LD_INT 107
46199: PUSH
46200: LD_INT 108
46202: PUSH
46203: LD_INT 109
46205: PUSH
46206: LD_INT 110
46208: PUSH
46209: LD_INT 111
46211: PUSH
46212: LD_INT 112
46214: PUSH
46215: LD_INT 114
46217: PUSH
46218: LD_INT 116
46220: PUSH
46221: LD_INT 117
46223: PUSH
46224: LD_INT 118
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: ST_TO_ADDR
46249: GO 48144
46251: LD_INT 11
46253: DOUBLE
46254: EQUAL
46255: IFTRUE 46259
46257: GO 46463
46259: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46260: LD_ADDR_VAR 0 2
46264: PUSH
46265: LD_INT 2
46267: PUSH
46268: LD_INT 3
46270: PUSH
46271: LD_INT 4
46273: PUSH
46274: LD_INT 5
46276: PUSH
46277: LD_INT 6
46279: PUSH
46280: LD_INT 7
46282: PUSH
46283: LD_INT 8
46285: PUSH
46286: LD_INT 9
46288: PUSH
46289: LD_INT 10
46291: PUSH
46292: LD_INT 11
46294: PUSH
46295: LD_INT 12
46297: PUSH
46298: LD_INT 13
46300: PUSH
46301: LD_INT 14
46303: PUSH
46304: LD_INT 15
46306: PUSH
46307: LD_INT 16
46309: PUSH
46310: LD_INT 17
46312: PUSH
46313: LD_INT 18
46315: PUSH
46316: LD_INT 19
46318: PUSH
46319: LD_INT 20
46321: PUSH
46322: LD_INT 21
46324: PUSH
46325: LD_INT 22
46327: PUSH
46328: LD_INT 23
46330: PUSH
46331: LD_INT 24
46333: PUSH
46334: LD_INT 25
46336: PUSH
46337: LD_INT 26
46339: PUSH
46340: LD_INT 28
46342: PUSH
46343: LD_INT 30
46345: PUSH
46346: LD_INT 31
46348: PUSH
46349: LD_INT 32
46351: PUSH
46352: LD_INT 34
46354: PUSH
46355: LD_INT 36
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: LIST
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 101
46393: PUSH
46394: LD_INT 102
46396: PUSH
46397: LD_INT 103
46399: PUSH
46400: LD_INT 104
46402: PUSH
46403: LD_INT 105
46405: PUSH
46406: LD_INT 106
46408: PUSH
46409: LD_INT 107
46411: PUSH
46412: LD_INT 108
46414: PUSH
46415: LD_INT 109
46417: PUSH
46418: LD_INT 110
46420: PUSH
46421: LD_INT 111
46423: PUSH
46424: LD_INT 112
46426: PUSH
46427: LD_INT 114
46429: PUSH
46430: LD_INT 116
46432: PUSH
46433: LD_INT 117
46435: PUSH
46436: LD_INT 118
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: ST_TO_ADDR
46461: GO 48144
46463: LD_INT 12
46465: DOUBLE
46466: EQUAL
46467: IFTRUE 46471
46469: GO 46691
46471: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46472: LD_ADDR_VAR 0 2
46476: PUSH
46477: LD_INT 1
46479: PUSH
46480: LD_INT 2
46482: PUSH
46483: LD_INT 3
46485: PUSH
46486: LD_INT 4
46488: PUSH
46489: LD_INT 5
46491: PUSH
46492: LD_INT 6
46494: PUSH
46495: LD_INT 7
46497: PUSH
46498: LD_INT 8
46500: PUSH
46501: LD_INT 9
46503: PUSH
46504: LD_INT 10
46506: PUSH
46507: LD_INT 11
46509: PUSH
46510: LD_INT 12
46512: PUSH
46513: LD_INT 13
46515: PUSH
46516: LD_INT 14
46518: PUSH
46519: LD_INT 15
46521: PUSH
46522: LD_INT 16
46524: PUSH
46525: LD_INT 17
46527: PUSH
46528: LD_INT 18
46530: PUSH
46531: LD_INT 19
46533: PUSH
46534: LD_INT 20
46536: PUSH
46537: LD_INT 21
46539: PUSH
46540: LD_INT 22
46542: PUSH
46543: LD_INT 23
46545: PUSH
46546: LD_INT 24
46548: PUSH
46549: LD_INT 25
46551: PUSH
46552: LD_INT 26
46554: PUSH
46555: LD_INT 27
46557: PUSH
46558: LD_INT 28
46560: PUSH
46561: LD_INT 30
46563: PUSH
46564: LD_INT 31
46566: PUSH
46567: LD_INT 32
46569: PUSH
46570: LD_INT 33
46572: PUSH
46573: LD_INT 34
46575: PUSH
46576: LD_INT 36
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: PUSH
46615: LD_INT 101
46617: PUSH
46618: LD_INT 102
46620: PUSH
46621: LD_INT 103
46623: PUSH
46624: LD_INT 104
46626: PUSH
46627: LD_INT 105
46629: PUSH
46630: LD_INT 106
46632: PUSH
46633: LD_INT 107
46635: PUSH
46636: LD_INT 108
46638: PUSH
46639: LD_INT 109
46641: PUSH
46642: LD_INT 110
46644: PUSH
46645: LD_INT 111
46647: PUSH
46648: LD_INT 112
46650: PUSH
46651: LD_INT 113
46653: PUSH
46654: LD_INT 114
46656: PUSH
46657: LD_INT 116
46659: PUSH
46660: LD_INT 117
46662: PUSH
46663: LD_INT 118
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: ST_TO_ADDR
46689: GO 48144
46691: LD_INT 13
46693: DOUBLE
46694: EQUAL
46695: IFTRUE 46699
46697: GO 46907
46699: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46700: LD_ADDR_VAR 0 2
46704: PUSH
46705: LD_INT 1
46707: PUSH
46708: LD_INT 2
46710: PUSH
46711: LD_INT 3
46713: PUSH
46714: LD_INT 4
46716: PUSH
46717: LD_INT 5
46719: PUSH
46720: LD_INT 8
46722: PUSH
46723: LD_INT 9
46725: PUSH
46726: LD_INT 10
46728: PUSH
46729: LD_INT 11
46731: PUSH
46732: LD_INT 12
46734: PUSH
46735: LD_INT 14
46737: PUSH
46738: LD_INT 15
46740: PUSH
46741: LD_INT 16
46743: PUSH
46744: LD_INT 17
46746: PUSH
46747: LD_INT 18
46749: PUSH
46750: LD_INT 19
46752: PUSH
46753: LD_INT 20
46755: PUSH
46756: LD_INT 21
46758: PUSH
46759: LD_INT 22
46761: PUSH
46762: LD_INT 23
46764: PUSH
46765: LD_INT 24
46767: PUSH
46768: LD_INT 25
46770: PUSH
46771: LD_INT 26
46773: PUSH
46774: LD_INT 27
46776: PUSH
46777: LD_INT 28
46779: PUSH
46780: LD_INT 30
46782: PUSH
46783: LD_INT 31
46785: PUSH
46786: LD_INT 32
46788: PUSH
46789: LD_INT 33
46791: PUSH
46792: LD_INT 34
46794: PUSH
46795: LD_INT 36
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: PUSH
46831: LD_INT 101
46833: PUSH
46834: LD_INT 102
46836: PUSH
46837: LD_INT 103
46839: PUSH
46840: LD_INT 104
46842: PUSH
46843: LD_INT 105
46845: PUSH
46846: LD_INT 106
46848: PUSH
46849: LD_INT 107
46851: PUSH
46852: LD_INT 108
46854: PUSH
46855: LD_INT 109
46857: PUSH
46858: LD_INT 110
46860: PUSH
46861: LD_INT 111
46863: PUSH
46864: LD_INT 112
46866: PUSH
46867: LD_INT 113
46869: PUSH
46870: LD_INT 114
46872: PUSH
46873: LD_INT 116
46875: PUSH
46876: LD_INT 117
46878: PUSH
46879: LD_INT 118
46881: PUSH
46882: EMPTY
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: LIST
46892: LIST
46893: LIST
46894: LIST
46895: LIST
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: ST_TO_ADDR
46905: GO 48144
46907: LD_INT 14
46909: DOUBLE
46910: EQUAL
46911: IFTRUE 46915
46913: GO 47139
46915: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
46916: LD_ADDR_VAR 0 2
46920: PUSH
46921: LD_INT 1
46923: PUSH
46924: LD_INT 2
46926: PUSH
46927: LD_INT 3
46929: PUSH
46930: LD_INT 4
46932: PUSH
46933: LD_INT 5
46935: PUSH
46936: LD_INT 6
46938: PUSH
46939: LD_INT 7
46941: PUSH
46942: LD_INT 8
46944: PUSH
46945: LD_INT 9
46947: PUSH
46948: LD_INT 10
46950: PUSH
46951: LD_INT 11
46953: PUSH
46954: LD_INT 12
46956: PUSH
46957: LD_INT 13
46959: PUSH
46960: LD_INT 14
46962: PUSH
46963: LD_INT 15
46965: PUSH
46966: LD_INT 16
46968: PUSH
46969: LD_INT 17
46971: PUSH
46972: LD_INT 18
46974: PUSH
46975: LD_INT 19
46977: PUSH
46978: LD_INT 20
46980: PUSH
46981: LD_INT 21
46983: PUSH
46984: LD_INT 22
46986: PUSH
46987: LD_INT 23
46989: PUSH
46990: LD_INT 24
46992: PUSH
46993: LD_INT 25
46995: PUSH
46996: LD_INT 26
46998: PUSH
46999: LD_INT 27
47001: PUSH
47002: LD_INT 28
47004: PUSH
47005: LD_INT 29
47007: PUSH
47008: LD_INT 30
47010: PUSH
47011: LD_INT 31
47013: PUSH
47014: LD_INT 32
47016: PUSH
47017: LD_INT 33
47019: PUSH
47020: LD_INT 34
47022: PUSH
47023: LD_INT 36
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 101
47065: PUSH
47066: LD_INT 102
47068: PUSH
47069: LD_INT 103
47071: PUSH
47072: LD_INT 104
47074: PUSH
47075: LD_INT 105
47077: PUSH
47078: LD_INT 106
47080: PUSH
47081: LD_INT 107
47083: PUSH
47084: LD_INT 108
47086: PUSH
47087: LD_INT 109
47089: PUSH
47090: LD_INT 110
47092: PUSH
47093: LD_INT 111
47095: PUSH
47096: LD_INT 112
47098: PUSH
47099: LD_INT 113
47101: PUSH
47102: LD_INT 114
47104: PUSH
47105: LD_INT 116
47107: PUSH
47108: LD_INT 117
47110: PUSH
47111: LD_INT 118
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: LIST
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: ST_TO_ADDR
47137: GO 48144
47139: LD_INT 15
47141: DOUBLE
47142: EQUAL
47143: IFTRUE 47147
47145: GO 47371
47147: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47148: LD_ADDR_VAR 0 2
47152: PUSH
47153: LD_INT 1
47155: PUSH
47156: LD_INT 2
47158: PUSH
47159: LD_INT 3
47161: PUSH
47162: LD_INT 4
47164: PUSH
47165: LD_INT 5
47167: PUSH
47168: LD_INT 6
47170: PUSH
47171: LD_INT 7
47173: PUSH
47174: LD_INT 8
47176: PUSH
47177: LD_INT 9
47179: PUSH
47180: LD_INT 10
47182: PUSH
47183: LD_INT 11
47185: PUSH
47186: LD_INT 12
47188: PUSH
47189: LD_INT 13
47191: PUSH
47192: LD_INT 14
47194: PUSH
47195: LD_INT 15
47197: PUSH
47198: LD_INT 16
47200: PUSH
47201: LD_INT 17
47203: PUSH
47204: LD_INT 18
47206: PUSH
47207: LD_INT 19
47209: PUSH
47210: LD_INT 20
47212: PUSH
47213: LD_INT 21
47215: PUSH
47216: LD_INT 22
47218: PUSH
47219: LD_INT 23
47221: PUSH
47222: LD_INT 24
47224: PUSH
47225: LD_INT 25
47227: PUSH
47228: LD_INT 26
47230: PUSH
47231: LD_INT 27
47233: PUSH
47234: LD_INT 28
47236: PUSH
47237: LD_INT 29
47239: PUSH
47240: LD_INT 30
47242: PUSH
47243: LD_INT 31
47245: PUSH
47246: LD_INT 32
47248: PUSH
47249: LD_INT 33
47251: PUSH
47252: LD_INT 34
47254: PUSH
47255: LD_INT 36
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: LIST
47267: LIST
47268: LIST
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: PUSH
47295: LD_INT 101
47297: PUSH
47298: LD_INT 102
47300: PUSH
47301: LD_INT 103
47303: PUSH
47304: LD_INT 104
47306: PUSH
47307: LD_INT 105
47309: PUSH
47310: LD_INT 106
47312: PUSH
47313: LD_INT 107
47315: PUSH
47316: LD_INT 108
47318: PUSH
47319: LD_INT 109
47321: PUSH
47322: LD_INT 110
47324: PUSH
47325: LD_INT 111
47327: PUSH
47328: LD_INT 112
47330: PUSH
47331: LD_INT 113
47333: PUSH
47334: LD_INT 114
47336: PUSH
47337: LD_INT 116
47339: PUSH
47340: LD_INT 117
47342: PUSH
47343: LD_INT 118
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: LIST
47350: LIST
47351: LIST
47352: LIST
47353: LIST
47354: LIST
47355: LIST
47356: LIST
47357: LIST
47358: LIST
47359: LIST
47360: LIST
47361: LIST
47362: LIST
47363: LIST
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: ST_TO_ADDR
47369: GO 48144
47371: LD_INT 16
47373: DOUBLE
47374: EQUAL
47375: IFTRUE 47379
47377: GO 47515
47379: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47380: LD_ADDR_VAR 0 2
47384: PUSH
47385: LD_INT 2
47387: PUSH
47388: LD_INT 4
47390: PUSH
47391: LD_INT 5
47393: PUSH
47394: LD_INT 7
47396: PUSH
47397: LD_INT 11
47399: PUSH
47400: LD_INT 12
47402: PUSH
47403: LD_INT 15
47405: PUSH
47406: LD_INT 16
47408: PUSH
47409: LD_INT 20
47411: PUSH
47412: LD_INT 21
47414: PUSH
47415: LD_INT 22
47417: PUSH
47418: LD_INT 23
47420: PUSH
47421: LD_INT 25
47423: PUSH
47424: LD_INT 26
47426: PUSH
47427: LD_INT 30
47429: PUSH
47430: LD_INT 31
47432: PUSH
47433: LD_INT 32
47435: PUSH
47436: LD_INT 33
47438: PUSH
47439: LD_INT 34
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: PUSH
47463: LD_INT 101
47465: PUSH
47466: LD_INT 102
47468: PUSH
47469: LD_INT 103
47471: PUSH
47472: LD_INT 106
47474: PUSH
47475: LD_INT 108
47477: PUSH
47478: LD_INT 112
47480: PUSH
47481: LD_INT 113
47483: PUSH
47484: LD_INT 114
47486: PUSH
47487: LD_INT 116
47489: PUSH
47490: LD_INT 117
47492: PUSH
47493: LD_INT 118
47495: PUSH
47496: EMPTY
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: PUSH
47509: EMPTY
47510: LIST
47511: LIST
47512: ST_TO_ADDR
47513: GO 48144
47515: LD_INT 17
47517: DOUBLE
47518: EQUAL
47519: IFTRUE 47523
47521: GO 47747
47523: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47524: LD_ADDR_VAR 0 2
47528: PUSH
47529: LD_INT 1
47531: PUSH
47532: LD_INT 2
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 4
47540: PUSH
47541: LD_INT 5
47543: PUSH
47544: LD_INT 6
47546: PUSH
47547: LD_INT 7
47549: PUSH
47550: LD_INT 8
47552: PUSH
47553: LD_INT 9
47555: PUSH
47556: LD_INT 10
47558: PUSH
47559: LD_INT 11
47561: PUSH
47562: LD_INT 12
47564: PUSH
47565: LD_INT 13
47567: PUSH
47568: LD_INT 14
47570: PUSH
47571: LD_INT 15
47573: PUSH
47574: LD_INT 16
47576: PUSH
47577: LD_INT 17
47579: PUSH
47580: LD_INT 18
47582: PUSH
47583: LD_INT 19
47585: PUSH
47586: LD_INT 20
47588: PUSH
47589: LD_INT 21
47591: PUSH
47592: LD_INT 22
47594: PUSH
47595: LD_INT 23
47597: PUSH
47598: LD_INT 24
47600: PUSH
47601: LD_INT 25
47603: PUSH
47604: LD_INT 26
47606: PUSH
47607: LD_INT 27
47609: PUSH
47610: LD_INT 28
47612: PUSH
47613: LD_INT 29
47615: PUSH
47616: LD_INT 30
47618: PUSH
47619: LD_INT 31
47621: PUSH
47622: LD_INT 32
47624: PUSH
47625: LD_INT 33
47627: PUSH
47628: LD_INT 34
47630: PUSH
47631: LD_INT 36
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: LIST
47646: LIST
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: PUSH
47671: LD_INT 101
47673: PUSH
47674: LD_INT 102
47676: PUSH
47677: LD_INT 103
47679: PUSH
47680: LD_INT 104
47682: PUSH
47683: LD_INT 105
47685: PUSH
47686: LD_INT 106
47688: PUSH
47689: LD_INT 107
47691: PUSH
47692: LD_INT 108
47694: PUSH
47695: LD_INT 109
47697: PUSH
47698: LD_INT 110
47700: PUSH
47701: LD_INT 111
47703: PUSH
47704: LD_INT 112
47706: PUSH
47707: LD_INT 113
47709: PUSH
47710: LD_INT 114
47712: PUSH
47713: LD_INT 116
47715: PUSH
47716: LD_INT 117
47718: PUSH
47719: LD_INT 118
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: LIST
47729: LIST
47730: LIST
47731: LIST
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: LIST
47740: PUSH
47741: EMPTY
47742: LIST
47743: LIST
47744: ST_TO_ADDR
47745: GO 48144
47747: LD_INT 18
47749: DOUBLE
47750: EQUAL
47751: IFTRUE 47755
47753: GO 47903
47755: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47756: LD_ADDR_VAR 0 2
47760: PUSH
47761: LD_INT 2
47763: PUSH
47764: LD_INT 4
47766: PUSH
47767: LD_INT 5
47769: PUSH
47770: LD_INT 7
47772: PUSH
47773: LD_INT 11
47775: PUSH
47776: LD_INT 12
47778: PUSH
47779: LD_INT 15
47781: PUSH
47782: LD_INT 16
47784: PUSH
47785: LD_INT 20
47787: PUSH
47788: LD_INT 21
47790: PUSH
47791: LD_INT 22
47793: PUSH
47794: LD_INT 23
47796: PUSH
47797: LD_INT 25
47799: PUSH
47800: LD_INT 26
47802: PUSH
47803: LD_INT 30
47805: PUSH
47806: LD_INT 31
47808: PUSH
47809: LD_INT 32
47811: PUSH
47812: LD_INT 33
47814: PUSH
47815: LD_INT 34
47817: PUSH
47818: LD_INT 35
47820: PUSH
47821: LD_INT 36
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: PUSH
47847: LD_INT 101
47849: PUSH
47850: LD_INT 102
47852: PUSH
47853: LD_INT 103
47855: PUSH
47856: LD_INT 106
47858: PUSH
47859: LD_INT 108
47861: PUSH
47862: LD_INT 112
47864: PUSH
47865: LD_INT 113
47867: PUSH
47868: LD_INT 114
47870: PUSH
47871: LD_INT 115
47873: PUSH
47874: LD_INT 116
47876: PUSH
47877: LD_INT 117
47879: PUSH
47880: LD_INT 118
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: PUSH
47897: EMPTY
47898: LIST
47899: LIST
47900: ST_TO_ADDR
47901: GO 48144
47903: LD_INT 19
47905: DOUBLE
47906: EQUAL
47907: IFTRUE 47911
47909: GO 48143
47911: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
47912: LD_ADDR_VAR 0 2
47916: PUSH
47917: LD_INT 1
47919: PUSH
47920: LD_INT 2
47922: PUSH
47923: LD_INT 3
47925: PUSH
47926: LD_INT 4
47928: PUSH
47929: LD_INT 5
47931: PUSH
47932: LD_INT 6
47934: PUSH
47935: LD_INT 7
47937: PUSH
47938: LD_INT 8
47940: PUSH
47941: LD_INT 9
47943: PUSH
47944: LD_INT 10
47946: PUSH
47947: LD_INT 11
47949: PUSH
47950: LD_INT 12
47952: PUSH
47953: LD_INT 13
47955: PUSH
47956: LD_INT 14
47958: PUSH
47959: LD_INT 15
47961: PUSH
47962: LD_INT 16
47964: PUSH
47965: LD_INT 17
47967: PUSH
47968: LD_INT 18
47970: PUSH
47971: LD_INT 19
47973: PUSH
47974: LD_INT 20
47976: PUSH
47977: LD_INT 21
47979: PUSH
47980: LD_INT 22
47982: PUSH
47983: LD_INT 23
47985: PUSH
47986: LD_INT 24
47988: PUSH
47989: LD_INT 25
47991: PUSH
47992: LD_INT 26
47994: PUSH
47995: LD_INT 27
47997: PUSH
47998: LD_INT 28
48000: PUSH
48001: LD_INT 29
48003: PUSH
48004: LD_INT 30
48006: PUSH
48007: LD_INT 31
48009: PUSH
48010: LD_INT 32
48012: PUSH
48013: LD_INT 33
48015: PUSH
48016: LD_INT 34
48018: PUSH
48019: LD_INT 35
48021: PUSH
48022: LD_INT 36
48024: PUSH
48025: EMPTY
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: LIST
48058: LIST
48059: LIST
48060: LIST
48061: LIST
48062: PUSH
48063: LD_INT 101
48065: PUSH
48066: LD_INT 102
48068: PUSH
48069: LD_INT 103
48071: PUSH
48072: LD_INT 104
48074: PUSH
48075: LD_INT 105
48077: PUSH
48078: LD_INT 106
48080: PUSH
48081: LD_INT 107
48083: PUSH
48084: LD_INT 108
48086: PUSH
48087: LD_INT 109
48089: PUSH
48090: LD_INT 110
48092: PUSH
48093: LD_INT 111
48095: PUSH
48096: LD_INT 112
48098: PUSH
48099: LD_INT 113
48101: PUSH
48102: LD_INT 114
48104: PUSH
48105: LD_INT 115
48107: PUSH
48108: LD_INT 116
48110: PUSH
48111: LD_INT 117
48113: PUSH
48114: LD_INT 118
48116: PUSH
48117: EMPTY
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: PUSH
48137: EMPTY
48138: LIST
48139: LIST
48140: ST_TO_ADDR
48141: GO 48144
48143: POP
// end else
48144: GO 48375
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48146: LD_ADDR_VAR 0 2
48150: PUSH
48151: LD_INT 1
48153: PUSH
48154: LD_INT 2
48156: PUSH
48157: LD_INT 3
48159: PUSH
48160: LD_INT 4
48162: PUSH
48163: LD_INT 5
48165: PUSH
48166: LD_INT 6
48168: PUSH
48169: LD_INT 7
48171: PUSH
48172: LD_INT 8
48174: PUSH
48175: LD_INT 9
48177: PUSH
48178: LD_INT 10
48180: PUSH
48181: LD_INT 11
48183: PUSH
48184: LD_INT 12
48186: PUSH
48187: LD_INT 13
48189: PUSH
48190: LD_INT 14
48192: PUSH
48193: LD_INT 15
48195: PUSH
48196: LD_INT 16
48198: PUSH
48199: LD_INT 17
48201: PUSH
48202: LD_INT 18
48204: PUSH
48205: LD_INT 19
48207: PUSH
48208: LD_INT 20
48210: PUSH
48211: LD_INT 21
48213: PUSH
48214: LD_INT 22
48216: PUSH
48217: LD_INT 23
48219: PUSH
48220: LD_INT 24
48222: PUSH
48223: LD_INT 25
48225: PUSH
48226: LD_INT 26
48228: PUSH
48229: LD_INT 27
48231: PUSH
48232: LD_INT 28
48234: PUSH
48235: LD_INT 29
48237: PUSH
48238: LD_INT 30
48240: PUSH
48241: LD_INT 31
48243: PUSH
48244: LD_INT 32
48246: PUSH
48247: LD_INT 33
48249: PUSH
48250: LD_INT 34
48252: PUSH
48253: LD_INT 35
48255: PUSH
48256: LD_INT 36
48258: PUSH
48259: EMPTY
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: LIST
48287: LIST
48288: LIST
48289: LIST
48290: LIST
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: PUSH
48297: LD_INT 101
48299: PUSH
48300: LD_INT 102
48302: PUSH
48303: LD_INT 103
48305: PUSH
48306: LD_INT 104
48308: PUSH
48309: LD_INT 105
48311: PUSH
48312: LD_INT 106
48314: PUSH
48315: LD_INT 107
48317: PUSH
48318: LD_INT 108
48320: PUSH
48321: LD_INT 109
48323: PUSH
48324: LD_INT 110
48326: PUSH
48327: LD_INT 111
48329: PUSH
48330: LD_INT 112
48332: PUSH
48333: LD_INT 113
48335: PUSH
48336: LD_INT 114
48338: PUSH
48339: LD_INT 115
48341: PUSH
48342: LD_INT 116
48344: PUSH
48345: LD_INT 117
48347: PUSH
48348: LD_INT 118
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: LIST
48355: LIST
48356: LIST
48357: LIST
48358: LIST
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: PUSH
48371: EMPTY
48372: LIST
48373: LIST
48374: ST_TO_ADDR
// if result then
48375: LD_VAR 0 2
48379: IFFALSE 49165
// begin normal :=  ;
48381: LD_ADDR_VAR 0 5
48385: PUSH
48386: LD_STRING 
48388: ST_TO_ADDR
// hardcore :=  ;
48389: LD_ADDR_VAR 0 6
48393: PUSH
48394: LD_STRING 
48396: ST_TO_ADDR
// active :=  ;
48397: LD_ADDR_VAR 0 7
48401: PUSH
48402: LD_STRING 
48404: ST_TO_ADDR
// for i = 1 to normalCounter do
48405: LD_ADDR_VAR 0 8
48409: PUSH
48410: DOUBLE
48411: LD_INT 1
48413: DEC
48414: ST_TO_ADDR
48415: LD_EXP 74
48419: PUSH
48420: FOR_TO
48421: IFFALSE 48522
// begin tmp := 0 ;
48423: LD_ADDR_VAR 0 3
48427: PUSH
48428: LD_STRING 0
48430: ST_TO_ADDR
// if result [ 1 ] then
48431: LD_VAR 0 2
48435: PUSH
48436: LD_INT 1
48438: ARRAY
48439: IFFALSE 48504
// if result [ 1 ] [ 1 ] = i then
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 1
48448: ARRAY
48449: PUSH
48450: LD_INT 1
48452: ARRAY
48453: PUSH
48454: LD_VAR 0 8
48458: EQUAL
48459: IFFALSE 48504
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48461: LD_ADDR_VAR 0 2
48465: PUSH
48466: LD_VAR 0 2
48470: PPUSH
48471: LD_INT 1
48473: PPUSH
48474: LD_VAR 0 2
48478: PUSH
48479: LD_INT 1
48481: ARRAY
48482: PPUSH
48483: LD_INT 1
48485: PPUSH
48486: CALL_OW 3
48490: PPUSH
48491: CALL_OW 1
48495: ST_TO_ADDR
// tmp := 1 ;
48496: LD_ADDR_VAR 0 3
48500: PUSH
48501: LD_STRING 1
48503: ST_TO_ADDR
// end ; normal := normal & tmp ;
48504: LD_ADDR_VAR 0 5
48508: PUSH
48509: LD_VAR 0 5
48513: PUSH
48514: LD_VAR 0 3
48518: STR
48519: ST_TO_ADDR
// end ;
48520: GO 48420
48522: POP
48523: POP
// for i = 1 to hardcoreCounter do
48524: LD_ADDR_VAR 0 8
48528: PUSH
48529: DOUBLE
48530: LD_INT 1
48532: DEC
48533: ST_TO_ADDR
48534: LD_EXP 75
48538: PUSH
48539: FOR_TO
48540: IFFALSE 48645
// begin tmp := 0 ;
48542: LD_ADDR_VAR 0 3
48546: PUSH
48547: LD_STRING 0
48549: ST_TO_ADDR
// if result [ 2 ] then
48550: LD_VAR 0 2
48554: PUSH
48555: LD_INT 2
48557: ARRAY
48558: IFFALSE 48627
// if result [ 2 ] [ 1 ] = 100 + i then
48560: LD_VAR 0 2
48564: PUSH
48565: LD_INT 2
48567: ARRAY
48568: PUSH
48569: LD_INT 1
48571: ARRAY
48572: PUSH
48573: LD_INT 100
48575: PUSH
48576: LD_VAR 0 8
48580: PLUS
48581: EQUAL
48582: IFFALSE 48627
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48584: LD_ADDR_VAR 0 2
48588: PUSH
48589: LD_VAR 0 2
48593: PPUSH
48594: LD_INT 2
48596: PPUSH
48597: LD_VAR 0 2
48601: PUSH
48602: LD_INT 2
48604: ARRAY
48605: PPUSH
48606: LD_INT 1
48608: PPUSH
48609: CALL_OW 3
48613: PPUSH
48614: CALL_OW 1
48618: ST_TO_ADDR
// tmp := 1 ;
48619: LD_ADDR_VAR 0 3
48623: PUSH
48624: LD_STRING 1
48626: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48627: LD_ADDR_VAR 0 6
48631: PUSH
48632: LD_VAR 0 6
48636: PUSH
48637: LD_VAR 0 3
48641: STR
48642: ST_TO_ADDR
// end ;
48643: GO 48539
48645: POP
48646: POP
// if isGameLoad then
48647: LD_VAR 0 1
48651: IFFALSE 49126
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48653: LD_ADDR_VAR 0 4
48657: PUSH
48658: LD_EXP 78
48662: PUSH
48663: LD_EXP 77
48667: PUSH
48668: LD_EXP 79
48672: PUSH
48673: LD_EXP 76
48677: PUSH
48678: LD_EXP 80
48682: PUSH
48683: LD_EXP 81
48687: PUSH
48688: LD_EXP 82
48692: PUSH
48693: LD_EXP 83
48697: PUSH
48698: LD_EXP 84
48702: PUSH
48703: LD_EXP 85
48707: PUSH
48708: LD_EXP 86
48712: PUSH
48713: LD_EXP 87
48717: PUSH
48718: LD_EXP 88
48722: PUSH
48723: LD_EXP 89
48727: PUSH
48728: LD_EXP 97
48732: PUSH
48733: LD_EXP 98
48737: PUSH
48738: LD_EXP 99
48742: PUSH
48743: LD_EXP 100
48747: PUSH
48748: LD_EXP 102
48752: PUSH
48753: LD_EXP 103
48757: PUSH
48758: LD_EXP 104
48762: PUSH
48763: LD_EXP 107
48767: PUSH
48768: LD_EXP 109
48772: PUSH
48773: LD_EXP 110
48777: PUSH
48778: LD_EXP 111
48782: PUSH
48783: LD_EXP 113
48787: PUSH
48788: LD_EXP 114
48792: PUSH
48793: LD_EXP 117
48797: PUSH
48798: LD_EXP 118
48802: PUSH
48803: LD_EXP 119
48807: PUSH
48808: LD_EXP 120
48812: PUSH
48813: LD_EXP 121
48817: PUSH
48818: LD_EXP 122
48822: PUSH
48823: LD_EXP 123
48827: PUSH
48828: LD_EXP 124
48832: PUSH
48833: LD_EXP 125
48837: PUSH
48838: LD_EXP 90
48842: PUSH
48843: LD_EXP 91
48847: PUSH
48848: LD_EXP 94
48852: PUSH
48853: LD_EXP 95
48857: PUSH
48858: LD_EXP 96
48862: PUSH
48863: LD_EXP 92
48867: PUSH
48868: LD_EXP 93
48872: PUSH
48873: LD_EXP 101
48877: PUSH
48878: LD_EXP 105
48882: PUSH
48883: LD_EXP 106
48887: PUSH
48888: LD_EXP 108
48892: PUSH
48893: LD_EXP 112
48897: PUSH
48898: LD_EXP 115
48902: PUSH
48903: LD_EXP 116
48907: PUSH
48908: LD_EXP 126
48912: PUSH
48913: LD_EXP 127
48917: PUSH
48918: LD_EXP 128
48922: PUSH
48923: LD_EXP 129
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: LIST
48960: LIST
48961: LIST
48962: LIST
48963: LIST
48964: LIST
48965: LIST
48966: LIST
48967: LIST
48968: LIST
48969: LIST
48970: LIST
48971: LIST
48972: LIST
48973: LIST
48974: LIST
48975: LIST
48976: LIST
48977: LIST
48978: LIST
48979: LIST
48980: LIST
48981: LIST
48982: LIST
48983: ST_TO_ADDR
// tmp :=  ;
48984: LD_ADDR_VAR 0 3
48988: PUSH
48989: LD_STRING 
48991: ST_TO_ADDR
// for i = 1 to normalCounter do
48992: LD_ADDR_VAR 0 8
48996: PUSH
48997: DOUBLE
48998: LD_INT 1
49000: DEC
49001: ST_TO_ADDR
49002: LD_EXP 74
49006: PUSH
49007: FOR_TO
49008: IFFALSE 49044
// begin if flags [ i ] then
49010: LD_VAR 0 4
49014: PUSH
49015: LD_VAR 0 8
49019: ARRAY
49020: IFFALSE 49042
// tmp := tmp & i & ; ;
49022: LD_ADDR_VAR 0 3
49026: PUSH
49027: LD_VAR 0 3
49031: PUSH
49032: LD_VAR 0 8
49036: STR
49037: PUSH
49038: LD_STRING ;
49040: STR
49041: ST_TO_ADDR
// end ;
49042: GO 49007
49044: POP
49045: POP
// for i = 1 to hardcoreCounter do
49046: LD_ADDR_VAR 0 8
49050: PUSH
49051: DOUBLE
49052: LD_INT 1
49054: DEC
49055: ST_TO_ADDR
49056: LD_EXP 75
49060: PUSH
49061: FOR_TO
49062: IFFALSE 49108
// begin if flags [ normalCounter + i ] then
49064: LD_VAR 0 4
49068: PUSH
49069: LD_EXP 74
49073: PUSH
49074: LD_VAR 0 8
49078: PLUS
49079: ARRAY
49080: IFFALSE 49106
// tmp := tmp & ( 100 + i ) & ; ;
49082: LD_ADDR_VAR 0 3
49086: PUSH
49087: LD_VAR 0 3
49091: PUSH
49092: LD_INT 100
49094: PUSH
49095: LD_VAR 0 8
49099: PLUS
49100: STR
49101: PUSH
49102: LD_STRING ;
49104: STR
49105: ST_TO_ADDR
// end ;
49106: GO 49061
49108: POP
49109: POP
// if tmp then
49110: LD_VAR 0 3
49114: IFFALSE 49126
// active := tmp ;
49116: LD_ADDR_VAR 0 7
49120: PUSH
49121: LD_VAR 0 3
49125: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49126: LD_STRING getStreamItemsFromMission("
49128: PUSH
49129: LD_VAR 0 5
49133: STR
49134: PUSH
49135: LD_STRING ","
49137: STR
49138: PUSH
49139: LD_VAR 0 6
49143: STR
49144: PUSH
49145: LD_STRING ","
49147: STR
49148: PUSH
49149: LD_VAR 0 7
49153: STR
49154: PUSH
49155: LD_STRING ")
49157: STR
49158: PPUSH
49159: CALL_OW 559
// end else
49163: GO 49172
// ToLua ( getStreamItemsFromMission("","","") ) ;
49165: LD_STRING getStreamItemsFromMission("","","")
49167: PPUSH
49168: CALL_OW 559
// end ;
49172: LD_VAR 0 2
49176: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49177: LD_EXP 73
49181: PUSH
49182: LD_EXP 78
49186: AND
49187: IFFALSE 49311
49189: GO 49191
49191: DISABLE
49192: LD_INT 0
49194: PPUSH
49195: PPUSH
// begin enable ;
49196: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49197: LD_ADDR_VAR 0 2
49201: PUSH
49202: LD_INT 22
49204: PUSH
49205: LD_OWVAR 2
49209: PUSH
49210: EMPTY
49211: LIST
49212: LIST
49213: PUSH
49214: LD_INT 2
49216: PUSH
49217: LD_INT 34
49219: PUSH
49220: LD_INT 7
49222: PUSH
49223: EMPTY
49224: LIST
49225: LIST
49226: PUSH
49227: LD_INT 34
49229: PUSH
49230: LD_INT 45
49232: PUSH
49233: EMPTY
49234: LIST
49235: LIST
49236: PUSH
49237: LD_INT 34
49239: PUSH
49240: LD_INT 28
49242: PUSH
49243: EMPTY
49244: LIST
49245: LIST
49246: PUSH
49247: LD_INT 34
49249: PUSH
49250: LD_INT 47
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: PUSH
49257: EMPTY
49258: LIST
49259: LIST
49260: LIST
49261: LIST
49262: LIST
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: PPUSH
49268: CALL_OW 69
49272: ST_TO_ADDR
// if not tmp then
49273: LD_VAR 0 2
49277: NOT
49278: IFFALSE 49282
// exit ;
49280: GO 49311
// for i in tmp do
49282: LD_ADDR_VAR 0 1
49286: PUSH
49287: LD_VAR 0 2
49291: PUSH
49292: FOR_IN
49293: IFFALSE 49309
// begin SetLives ( i , 0 ) ;
49295: LD_VAR 0 1
49299: PPUSH
49300: LD_INT 0
49302: PPUSH
49303: CALL_OW 234
// end ;
49307: GO 49292
49309: POP
49310: POP
// end ;
49311: PPOPN 2
49313: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49314: LD_EXP 73
49318: PUSH
49319: LD_EXP 79
49323: AND
49324: IFFALSE 49408
49326: GO 49328
49328: DISABLE
49329: LD_INT 0
49331: PPUSH
49332: PPUSH
// begin enable ;
49333: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49334: LD_ADDR_VAR 0 2
49338: PUSH
49339: LD_INT 22
49341: PUSH
49342: LD_OWVAR 2
49346: PUSH
49347: EMPTY
49348: LIST
49349: LIST
49350: PUSH
49351: LD_INT 32
49353: PUSH
49354: LD_INT 3
49356: PUSH
49357: EMPTY
49358: LIST
49359: LIST
49360: PUSH
49361: EMPTY
49362: LIST
49363: LIST
49364: PPUSH
49365: CALL_OW 69
49369: ST_TO_ADDR
// if not tmp then
49370: LD_VAR 0 2
49374: NOT
49375: IFFALSE 49379
// exit ;
49377: GO 49408
// for i in tmp do
49379: LD_ADDR_VAR 0 1
49383: PUSH
49384: LD_VAR 0 2
49388: PUSH
49389: FOR_IN
49390: IFFALSE 49406
// begin SetLives ( i , 0 ) ;
49392: LD_VAR 0 1
49396: PPUSH
49397: LD_INT 0
49399: PPUSH
49400: CALL_OW 234
// end ;
49404: GO 49389
49406: POP
49407: POP
// end ;
49408: PPOPN 2
49410: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49411: LD_EXP 73
49415: PUSH
49416: LD_EXP 76
49420: AND
49421: IFFALSE 49514
49423: GO 49425
49425: DISABLE
49426: LD_INT 0
49428: PPUSH
// begin enable ;
49429: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49430: LD_ADDR_VAR 0 1
49434: PUSH
49435: LD_INT 22
49437: PUSH
49438: LD_OWVAR 2
49442: PUSH
49443: EMPTY
49444: LIST
49445: LIST
49446: PUSH
49447: LD_INT 2
49449: PUSH
49450: LD_INT 25
49452: PUSH
49453: LD_INT 5
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: PUSH
49460: LD_INT 25
49462: PUSH
49463: LD_INT 9
49465: PUSH
49466: EMPTY
49467: LIST
49468: LIST
49469: PUSH
49470: LD_INT 25
49472: PUSH
49473: LD_INT 8
49475: PUSH
49476: EMPTY
49477: LIST
49478: LIST
49479: PUSH
49480: EMPTY
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: PPUSH
49490: CALL_OW 69
49494: PUSH
49495: FOR_IN
49496: IFFALSE 49512
// begin SetClass ( i , 1 ) ;
49498: LD_VAR 0 1
49502: PPUSH
49503: LD_INT 1
49505: PPUSH
49506: CALL_OW 336
// end ;
49510: GO 49495
49512: POP
49513: POP
// end ;
49514: PPOPN 1
49516: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49517: LD_EXP 73
49521: PUSH
49522: LD_EXP 77
49526: AND
49527: PUSH
49528: LD_OWVAR 65
49532: PUSH
49533: LD_INT 7
49535: LESS
49536: AND
49537: IFFALSE 49551
49539: GO 49541
49541: DISABLE
// begin enable ;
49542: ENABLE
// game_speed := 7 ;
49543: LD_ADDR_OWVAR 65
49547: PUSH
49548: LD_INT 7
49550: ST_TO_ADDR
// end ;
49551: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49552: LD_EXP 73
49556: PUSH
49557: LD_EXP 80
49561: AND
49562: IFFALSE 49764
49564: GO 49566
49566: DISABLE
49567: LD_INT 0
49569: PPUSH
49570: PPUSH
49571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49572: LD_ADDR_VAR 0 3
49576: PUSH
49577: LD_INT 81
49579: PUSH
49580: LD_OWVAR 2
49584: PUSH
49585: EMPTY
49586: LIST
49587: LIST
49588: PUSH
49589: LD_INT 21
49591: PUSH
49592: LD_INT 1
49594: PUSH
49595: EMPTY
49596: LIST
49597: LIST
49598: PUSH
49599: EMPTY
49600: LIST
49601: LIST
49602: PPUSH
49603: CALL_OW 69
49607: ST_TO_ADDR
// if not tmp then
49608: LD_VAR 0 3
49612: NOT
49613: IFFALSE 49617
// exit ;
49615: GO 49764
// if tmp > 5 then
49617: LD_VAR 0 3
49621: PUSH
49622: LD_INT 5
49624: GREATER
49625: IFFALSE 49637
// k := 5 else
49627: LD_ADDR_VAR 0 2
49631: PUSH
49632: LD_INT 5
49634: ST_TO_ADDR
49635: GO 49647
// k := tmp ;
49637: LD_ADDR_VAR 0 2
49641: PUSH
49642: LD_VAR 0 3
49646: ST_TO_ADDR
// for i := 1 to k do
49647: LD_ADDR_VAR 0 1
49651: PUSH
49652: DOUBLE
49653: LD_INT 1
49655: DEC
49656: ST_TO_ADDR
49657: LD_VAR 0 2
49661: PUSH
49662: FOR_TO
49663: IFFALSE 49762
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49665: LD_VAR 0 3
49669: PUSH
49670: LD_VAR 0 1
49674: ARRAY
49675: PPUSH
49676: LD_VAR 0 1
49680: PUSH
49681: LD_INT 4
49683: MOD
49684: PUSH
49685: LD_INT 1
49687: PLUS
49688: PPUSH
49689: CALL_OW 259
49693: PUSH
49694: LD_INT 10
49696: LESS
49697: IFFALSE 49760
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49699: LD_VAR 0 3
49703: PUSH
49704: LD_VAR 0 1
49708: ARRAY
49709: PPUSH
49710: LD_VAR 0 1
49714: PUSH
49715: LD_INT 4
49717: MOD
49718: PUSH
49719: LD_INT 1
49721: PLUS
49722: PPUSH
49723: LD_VAR 0 3
49727: PUSH
49728: LD_VAR 0 1
49732: ARRAY
49733: PPUSH
49734: LD_VAR 0 1
49738: PUSH
49739: LD_INT 4
49741: MOD
49742: PUSH
49743: LD_INT 1
49745: PLUS
49746: PPUSH
49747: CALL_OW 259
49751: PUSH
49752: LD_INT 1
49754: PLUS
49755: PPUSH
49756: CALL_OW 237
49760: GO 49662
49762: POP
49763: POP
// end ;
49764: PPOPN 3
49766: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49767: LD_EXP 73
49771: PUSH
49772: LD_EXP 81
49776: AND
49777: IFFALSE 49797
49779: GO 49781
49781: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49782: LD_INT 4
49784: PPUSH
49785: LD_OWVAR 2
49789: PPUSH
49790: LD_INT 0
49792: PPUSH
49793: CALL_OW 324
49797: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49798: LD_EXP 73
49802: PUSH
49803: LD_EXP 110
49807: AND
49808: IFFALSE 49828
49810: GO 49812
49812: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49813: LD_INT 19
49815: PPUSH
49816: LD_OWVAR 2
49820: PPUSH
49821: LD_INT 0
49823: PPUSH
49824: CALL_OW 324
49828: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49829: LD_EXP 73
49833: PUSH
49834: LD_EXP 82
49838: AND
49839: IFFALSE 49941
49841: GO 49843
49843: DISABLE
49844: LD_INT 0
49846: PPUSH
49847: PPUSH
// begin enable ;
49848: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49849: LD_ADDR_VAR 0 2
49853: PUSH
49854: LD_INT 22
49856: PUSH
49857: LD_OWVAR 2
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: LD_INT 2
49868: PUSH
49869: LD_INT 34
49871: PUSH
49872: LD_INT 11
49874: PUSH
49875: EMPTY
49876: LIST
49877: LIST
49878: PUSH
49879: LD_INT 34
49881: PUSH
49882: LD_INT 30
49884: PUSH
49885: EMPTY
49886: LIST
49887: LIST
49888: PUSH
49889: EMPTY
49890: LIST
49891: LIST
49892: LIST
49893: PUSH
49894: EMPTY
49895: LIST
49896: LIST
49897: PPUSH
49898: CALL_OW 69
49902: ST_TO_ADDR
// if not tmp then
49903: LD_VAR 0 2
49907: NOT
49908: IFFALSE 49912
// exit ;
49910: GO 49941
// for i in tmp do
49912: LD_ADDR_VAR 0 1
49916: PUSH
49917: LD_VAR 0 2
49921: PUSH
49922: FOR_IN
49923: IFFALSE 49939
// begin SetLives ( i , 0 ) ;
49925: LD_VAR 0 1
49929: PPUSH
49930: LD_INT 0
49932: PPUSH
49933: CALL_OW 234
// end ;
49937: GO 49922
49939: POP
49940: POP
// end ;
49941: PPOPN 2
49943: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49944: LD_EXP 73
49948: PUSH
49949: LD_EXP 83
49953: AND
49954: IFFALSE 49974
49956: GO 49958
49958: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49959: LD_INT 32
49961: PPUSH
49962: LD_OWVAR 2
49966: PPUSH
49967: LD_INT 0
49969: PPUSH
49970: CALL_OW 324
49974: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49975: LD_EXP 73
49979: PUSH
49980: LD_EXP 84
49984: AND
49985: IFFALSE 50166
49987: GO 49989
49989: DISABLE
49990: LD_INT 0
49992: PPUSH
49993: PPUSH
49994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49995: LD_ADDR_VAR 0 2
49999: PUSH
50000: LD_INT 22
50002: PUSH
50003: LD_OWVAR 2
50007: PUSH
50008: EMPTY
50009: LIST
50010: LIST
50011: PUSH
50012: LD_INT 33
50014: PUSH
50015: LD_INT 3
50017: PUSH
50018: EMPTY
50019: LIST
50020: LIST
50021: PUSH
50022: EMPTY
50023: LIST
50024: LIST
50025: PPUSH
50026: CALL_OW 69
50030: ST_TO_ADDR
// if not tmp then
50031: LD_VAR 0 2
50035: NOT
50036: IFFALSE 50040
// exit ;
50038: GO 50166
// side := 0 ;
50040: LD_ADDR_VAR 0 3
50044: PUSH
50045: LD_INT 0
50047: ST_TO_ADDR
// for i := 1 to 8 do
50048: LD_ADDR_VAR 0 1
50052: PUSH
50053: DOUBLE
50054: LD_INT 1
50056: DEC
50057: ST_TO_ADDR
50058: LD_INT 8
50060: PUSH
50061: FOR_TO
50062: IFFALSE 50110
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50064: LD_OWVAR 2
50068: PUSH
50069: LD_VAR 0 1
50073: NONEQUAL
50074: PUSH
50075: LD_OWVAR 2
50079: PPUSH
50080: LD_VAR 0 1
50084: PPUSH
50085: CALL_OW 81
50089: PUSH
50090: LD_INT 2
50092: EQUAL
50093: AND
50094: IFFALSE 50108
// begin side := i ;
50096: LD_ADDR_VAR 0 3
50100: PUSH
50101: LD_VAR 0 1
50105: ST_TO_ADDR
// break ;
50106: GO 50110
// end ;
50108: GO 50061
50110: POP
50111: POP
// if not side then
50112: LD_VAR 0 3
50116: NOT
50117: IFFALSE 50121
// exit ;
50119: GO 50166
// for i := 1 to tmp do
50121: LD_ADDR_VAR 0 1
50125: PUSH
50126: DOUBLE
50127: LD_INT 1
50129: DEC
50130: ST_TO_ADDR
50131: LD_VAR 0 2
50135: PUSH
50136: FOR_TO
50137: IFFALSE 50164
// if Prob ( 60 ) then
50139: LD_INT 60
50141: PPUSH
50142: CALL_OW 13
50146: IFFALSE 50162
// SetSide ( i , side ) ;
50148: LD_VAR 0 1
50152: PPUSH
50153: LD_VAR 0 3
50157: PPUSH
50158: CALL_OW 235
50162: GO 50136
50164: POP
50165: POP
// end ;
50166: PPOPN 3
50168: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50169: LD_EXP 73
50173: PUSH
50174: LD_EXP 86
50178: AND
50179: IFFALSE 50298
50181: GO 50183
50183: DISABLE
50184: LD_INT 0
50186: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50187: LD_ADDR_VAR 0 1
50191: PUSH
50192: LD_INT 22
50194: PUSH
50195: LD_OWVAR 2
50199: PUSH
50200: EMPTY
50201: LIST
50202: LIST
50203: PUSH
50204: LD_INT 21
50206: PUSH
50207: LD_INT 1
50209: PUSH
50210: EMPTY
50211: LIST
50212: LIST
50213: PUSH
50214: LD_INT 3
50216: PUSH
50217: LD_INT 23
50219: PUSH
50220: LD_INT 0
50222: PUSH
50223: EMPTY
50224: LIST
50225: LIST
50226: PUSH
50227: EMPTY
50228: LIST
50229: LIST
50230: PUSH
50231: EMPTY
50232: LIST
50233: LIST
50234: LIST
50235: PPUSH
50236: CALL_OW 69
50240: PUSH
50241: FOR_IN
50242: IFFALSE 50296
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50244: LD_VAR 0 1
50248: PPUSH
50249: CALL_OW 257
50253: PUSH
50254: LD_INT 1
50256: PUSH
50257: LD_INT 2
50259: PUSH
50260: LD_INT 3
50262: PUSH
50263: LD_INT 4
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: LIST
50270: LIST
50271: IN
50272: IFFALSE 50294
// SetClass ( un , rand ( 1 , 4 ) ) ;
50274: LD_VAR 0 1
50278: PPUSH
50279: LD_INT 1
50281: PPUSH
50282: LD_INT 4
50284: PPUSH
50285: CALL_OW 12
50289: PPUSH
50290: CALL_OW 336
50294: GO 50241
50296: POP
50297: POP
// end ;
50298: PPOPN 1
50300: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50301: LD_EXP 73
50305: PUSH
50306: LD_EXP 85
50310: AND
50311: IFFALSE 50390
50313: GO 50315
50315: DISABLE
50316: LD_INT 0
50318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50319: LD_ADDR_VAR 0 1
50323: PUSH
50324: LD_INT 22
50326: PUSH
50327: LD_OWVAR 2
50331: PUSH
50332: EMPTY
50333: LIST
50334: LIST
50335: PUSH
50336: LD_INT 21
50338: PUSH
50339: LD_INT 3
50341: PUSH
50342: EMPTY
50343: LIST
50344: LIST
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: PPUSH
50350: CALL_OW 69
50354: ST_TO_ADDR
// if not tmp then
50355: LD_VAR 0 1
50359: NOT
50360: IFFALSE 50364
// exit ;
50362: GO 50390
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50364: LD_VAR 0 1
50368: PUSH
50369: LD_INT 1
50371: PPUSH
50372: LD_VAR 0 1
50376: PPUSH
50377: CALL_OW 12
50381: ARRAY
50382: PPUSH
50383: LD_INT 100
50385: PPUSH
50386: CALL_OW 234
// end ;
50390: PPOPN 1
50392: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50393: LD_EXP 73
50397: PUSH
50398: LD_EXP 87
50402: AND
50403: IFFALSE 50501
50405: GO 50407
50407: DISABLE
50408: LD_INT 0
50410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50411: LD_ADDR_VAR 0 1
50415: PUSH
50416: LD_INT 22
50418: PUSH
50419: LD_OWVAR 2
50423: PUSH
50424: EMPTY
50425: LIST
50426: LIST
50427: PUSH
50428: LD_INT 21
50430: PUSH
50431: LD_INT 1
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PUSH
50438: EMPTY
50439: LIST
50440: LIST
50441: PPUSH
50442: CALL_OW 69
50446: ST_TO_ADDR
// if not tmp then
50447: LD_VAR 0 1
50451: NOT
50452: IFFALSE 50456
// exit ;
50454: GO 50501
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50456: LD_VAR 0 1
50460: PUSH
50461: LD_INT 1
50463: PPUSH
50464: LD_VAR 0 1
50468: PPUSH
50469: CALL_OW 12
50473: ARRAY
50474: PPUSH
50475: LD_INT 1
50477: PPUSH
50478: LD_INT 4
50480: PPUSH
50481: CALL_OW 12
50485: PPUSH
50486: LD_INT 3000
50488: PPUSH
50489: LD_INT 9000
50491: PPUSH
50492: CALL_OW 12
50496: PPUSH
50497: CALL_OW 492
// end ;
50501: PPOPN 1
50503: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50504: LD_EXP 73
50508: PUSH
50509: LD_EXP 88
50513: AND
50514: IFFALSE 50534
50516: GO 50518
50518: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50519: LD_INT 1
50521: PPUSH
50522: LD_OWVAR 2
50526: PPUSH
50527: LD_INT 0
50529: PPUSH
50530: CALL_OW 324
50534: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50535: LD_EXP 73
50539: PUSH
50540: LD_EXP 89
50544: AND
50545: IFFALSE 50628
50547: GO 50549
50549: DISABLE
50550: LD_INT 0
50552: PPUSH
50553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50554: LD_ADDR_VAR 0 2
50558: PUSH
50559: LD_INT 22
50561: PUSH
50562: LD_OWVAR 2
50566: PUSH
50567: EMPTY
50568: LIST
50569: LIST
50570: PUSH
50571: LD_INT 21
50573: PUSH
50574: LD_INT 3
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: PPUSH
50585: CALL_OW 69
50589: ST_TO_ADDR
// if not tmp then
50590: LD_VAR 0 2
50594: NOT
50595: IFFALSE 50599
// exit ;
50597: GO 50628
// for i in tmp do
50599: LD_ADDR_VAR 0 1
50603: PUSH
50604: LD_VAR 0 2
50608: PUSH
50609: FOR_IN
50610: IFFALSE 50626
// SetBLevel ( i , 10 ) ;
50612: LD_VAR 0 1
50616: PPUSH
50617: LD_INT 10
50619: PPUSH
50620: CALL_OW 241
50624: GO 50609
50626: POP
50627: POP
// end ;
50628: PPOPN 2
50630: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50631: LD_EXP 73
50635: PUSH
50636: LD_EXP 90
50640: AND
50641: IFFALSE 50752
50643: GO 50645
50645: DISABLE
50646: LD_INT 0
50648: PPUSH
50649: PPUSH
50650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50651: LD_ADDR_VAR 0 3
50655: PUSH
50656: LD_INT 22
50658: PUSH
50659: LD_OWVAR 2
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: LD_INT 25
50670: PUSH
50671: LD_INT 1
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: PUSH
50678: EMPTY
50679: LIST
50680: LIST
50681: PPUSH
50682: CALL_OW 69
50686: ST_TO_ADDR
// if not tmp then
50687: LD_VAR 0 3
50691: NOT
50692: IFFALSE 50696
// exit ;
50694: GO 50752
// un := tmp [ rand ( 1 , tmp ) ] ;
50696: LD_ADDR_VAR 0 2
50700: PUSH
50701: LD_VAR 0 3
50705: PUSH
50706: LD_INT 1
50708: PPUSH
50709: LD_VAR 0 3
50713: PPUSH
50714: CALL_OW 12
50718: ARRAY
50719: ST_TO_ADDR
// if Crawls ( un ) then
50720: LD_VAR 0 2
50724: PPUSH
50725: CALL_OW 318
50729: IFFALSE 50740
// ComWalk ( un ) ;
50731: LD_VAR 0 2
50735: PPUSH
50736: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50740: LD_VAR 0 2
50744: PPUSH
50745: LD_INT 5
50747: PPUSH
50748: CALL_OW 336
// end ;
50752: PPOPN 3
50754: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50755: LD_EXP 73
50759: PUSH
50760: LD_EXP 91
50764: AND
50765: PUSH
50766: LD_OWVAR 67
50770: PUSH
50771: LD_INT 4
50773: LESS
50774: AND
50775: IFFALSE 50794
50777: GO 50779
50779: DISABLE
// begin Difficulty := Difficulty + 1 ;
50780: LD_ADDR_OWVAR 67
50784: PUSH
50785: LD_OWVAR 67
50789: PUSH
50790: LD_INT 1
50792: PLUS
50793: ST_TO_ADDR
// end ;
50794: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50795: LD_EXP 73
50799: PUSH
50800: LD_EXP 92
50804: AND
50805: IFFALSE 50908
50807: GO 50809
50809: DISABLE
50810: LD_INT 0
50812: PPUSH
// begin for i := 1 to 5 do
50813: LD_ADDR_VAR 0 1
50817: PUSH
50818: DOUBLE
50819: LD_INT 1
50821: DEC
50822: ST_TO_ADDR
50823: LD_INT 5
50825: PUSH
50826: FOR_TO
50827: IFFALSE 50906
// begin uc_nation := nation_nature ;
50829: LD_ADDR_OWVAR 21
50833: PUSH
50834: LD_INT 0
50836: ST_TO_ADDR
// uc_side := 0 ;
50837: LD_ADDR_OWVAR 20
50841: PUSH
50842: LD_INT 0
50844: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50845: LD_ADDR_OWVAR 29
50849: PUSH
50850: LD_INT 12
50852: PUSH
50853: LD_INT 12
50855: PUSH
50856: EMPTY
50857: LIST
50858: LIST
50859: ST_TO_ADDR
// hc_agressivity := 20 ;
50860: LD_ADDR_OWVAR 35
50864: PUSH
50865: LD_INT 20
50867: ST_TO_ADDR
// hc_class := class_tiger ;
50868: LD_ADDR_OWVAR 28
50872: PUSH
50873: LD_INT 14
50875: ST_TO_ADDR
// hc_gallery :=  ;
50876: LD_ADDR_OWVAR 33
50880: PUSH
50881: LD_STRING 
50883: ST_TO_ADDR
// hc_name :=  ;
50884: LD_ADDR_OWVAR 26
50888: PUSH
50889: LD_STRING 
50891: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50892: CALL_OW 44
50896: PPUSH
50897: LD_INT 0
50899: PPUSH
50900: CALL_OW 51
// end ;
50904: GO 50826
50906: POP
50907: POP
// end ;
50908: PPOPN 1
50910: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50911: LD_EXP 73
50915: PUSH
50916: LD_EXP 93
50920: AND
50921: IFFALSE 50930
50923: GO 50925
50925: DISABLE
// StreamSibBomb ;
50926: CALL 50931 0 0
50930: END
// export function StreamSibBomb ; var i , x , y ; begin
50931: LD_INT 0
50933: PPUSH
50934: PPUSH
50935: PPUSH
50936: PPUSH
// result := false ;
50937: LD_ADDR_VAR 0 1
50941: PUSH
50942: LD_INT 0
50944: ST_TO_ADDR
// for i := 1 to 16 do
50945: LD_ADDR_VAR 0 2
50949: PUSH
50950: DOUBLE
50951: LD_INT 1
50953: DEC
50954: ST_TO_ADDR
50955: LD_INT 16
50957: PUSH
50958: FOR_TO
50959: IFFALSE 51158
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50961: LD_ADDR_VAR 0 3
50965: PUSH
50966: LD_INT 10
50968: PUSH
50969: LD_INT 20
50971: PUSH
50972: LD_INT 30
50974: PUSH
50975: LD_INT 40
50977: PUSH
50978: LD_INT 50
50980: PUSH
50981: LD_INT 60
50983: PUSH
50984: LD_INT 70
50986: PUSH
50987: LD_INT 80
50989: PUSH
50990: LD_INT 90
50992: PUSH
50993: LD_INT 100
50995: PUSH
50996: LD_INT 110
50998: PUSH
50999: LD_INT 120
51001: PUSH
51002: LD_INT 130
51004: PUSH
51005: LD_INT 140
51007: PUSH
51008: LD_INT 150
51010: PUSH
51011: EMPTY
51012: LIST
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: LIST
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: PUSH
51028: LD_INT 1
51030: PPUSH
51031: LD_INT 15
51033: PPUSH
51034: CALL_OW 12
51038: ARRAY
51039: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51040: LD_ADDR_VAR 0 4
51044: PUSH
51045: LD_INT 10
51047: PUSH
51048: LD_INT 20
51050: PUSH
51051: LD_INT 30
51053: PUSH
51054: LD_INT 40
51056: PUSH
51057: LD_INT 50
51059: PUSH
51060: LD_INT 60
51062: PUSH
51063: LD_INT 70
51065: PUSH
51066: LD_INT 80
51068: PUSH
51069: LD_INT 90
51071: PUSH
51072: LD_INT 100
51074: PUSH
51075: LD_INT 110
51077: PUSH
51078: LD_INT 120
51080: PUSH
51081: LD_INT 130
51083: PUSH
51084: LD_INT 140
51086: PUSH
51087: LD_INT 150
51089: PUSH
51090: EMPTY
51091: LIST
51092: LIST
51093: LIST
51094: LIST
51095: LIST
51096: LIST
51097: LIST
51098: LIST
51099: LIST
51100: LIST
51101: LIST
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: PUSH
51107: LD_INT 1
51109: PPUSH
51110: LD_INT 15
51112: PPUSH
51113: CALL_OW 12
51117: ARRAY
51118: ST_TO_ADDR
// if ValidHex ( x , y ) then
51119: LD_VAR 0 3
51123: PPUSH
51124: LD_VAR 0 4
51128: PPUSH
51129: CALL_OW 488
51133: IFFALSE 51156
// begin result := [ x , y ] ;
51135: LD_ADDR_VAR 0 1
51139: PUSH
51140: LD_VAR 0 3
51144: PUSH
51145: LD_VAR 0 4
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: ST_TO_ADDR
// break ;
51154: GO 51158
// end ; end ;
51156: GO 50958
51158: POP
51159: POP
// if result then
51160: LD_VAR 0 1
51164: IFFALSE 51224
// begin ToLua ( playSibBomb() ) ;
51166: LD_STRING playSibBomb()
51168: PPUSH
51169: CALL_OW 559
// wait ( 0 0$14 ) ;
51173: LD_INT 490
51175: PPUSH
51176: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51180: LD_VAR 0 1
51184: PUSH
51185: LD_INT 1
51187: ARRAY
51188: PPUSH
51189: LD_VAR 0 1
51193: PUSH
51194: LD_INT 2
51196: ARRAY
51197: PPUSH
51198: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51202: LD_VAR 0 1
51206: PUSH
51207: LD_INT 1
51209: ARRAY
51210: PPUSH
51211: LD_VAR 0 1
51215: PUSH
51216: LD_INT 2
51218: ARRAY
51219: PPUSH
51220: CALL_OW 429
// end ; end ;
51224: LD_VAR 0 1
51228: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51229: LD_EXP 73
51233: PUSH
51234: LD_EXP 95
51238: AND
51239: IFFALSE 51251
51241: GO 51243
51243: DISABLE
// YouLost (  ) ;
51244: LD_STRING 
51246: PPUSH
51247: CALL_OW 104
51251: END
// every 0 0$1 trigger StreamModeActive and sFog do
51252: LD_EXP 73
51256: PUSH
51257: LD_EXP 94
51261: AND
51262: IFFALSE 51276
51264: GO 51266
51266: DISABLE
// FogOff ( your_side ) ;
51267: LD_OWVAR 2
51271: PPUSH
51272: CALL_OW 344
51276: END
// every 0 0$1 trigger StreamModeActive and sSun do
51277: LD_EXP 73
51281: PUSH
51282: LD_EXP 96
51286: AND
51287: IFFALSE 51315
51289: GO 51291
51291: DISABLE
// begin solar_recharge_percent := 0 ;
51292: LD_ADDR_OWVAR 79
51296: PUSH
51297: LD_INT 0
51299: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51300: LD_INT 10500
51302: PPUSH
51303: CALL_OW 67
// solar_recharge_percent := 100 ;
51307: LD_ADDR_OWVAR 79
51311: PUSH
51312: LD_INT 100
51314: ST_TO_ADDR
// end ;
51315: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51316: LD_EXP 73
51320: PUSH
51321: LD_EXP 97
51325: AND
51326: IFFALSE 51565
51328: GO 51330
51330: DISABLE
51331: LD_INT 0
51333: PPUSH
51334: PPUSH
51335: PPUSH
// begin tmp := [ ] ;
51336: LD_ADDR_VAR 0 3
51340: PUSH
51341: EMPTY
51342: ST_TO_ADDR
// for i := 1 to 6 do
51343: LD_ADDR_VAR 0 1
51347: PUSH
51348: DOUBLE
51349: LD_INT 1
51351: DEC
51352: ST_TO_ADDR
51353: LD_INT 6
51355: PUSH
51356: FOR_TO
51357: IFFALSE 51462
// begin uc_nation := nation_nature ;
51359: LD_ADDR_OWVAR 21
51363: PUSH
51364: LD_INT 0
51366: ST_TO_ADDR
// uc_side := 0 ;
51367: LD_ADDR_OWVAR 20
51371: PUSH
51372: LD_INT 0
51374: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51375: LD_ADDR_OWVAR 29
51379: PUSH
51380: LD_INT 12
51382: PUSH
51383: LD_INT 12
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: ST_TO_ADDR
// hc_agressivity := 20 ;
51390: LD_ADDR_OWVAR 35
51394: PUSH
51395: LD_INT 20
51397: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51398: LD_ADDR_OWVAR 28
51402: PUSH
51403: LD_INT 17
51405: ST_TO_ADDR
// hc_gallery :=  ;
51406: LD_ADDR_OWVAR 33
51410: PUSH
51411: LD_STRING 
51413: ST_TO_ADDR
// hc_name :=  ;
51414: LD_ADDR_OWVAR 26
51418: PUSH
51419: LD_STRING 
51421: ST_TO_ADDR
// un := CreateHuman ;
51422: LD_ADDR_VAR 0 2
51426: PUSH
51427: CALL_OW 44
51431: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51432: LD_VAR 0 2
51436: PPUSH
51437: LD_INT 1
51439: PPUSH
51440: CALL_OW 51
// tmp := tmp ^ un ;
51444: LD_ADDR_VAR 0 3
51448: PUSH
51449: LD_VAR 0 3
51453: PUSH
51454: LD_VAR 0 2
51458: ADD
51459: ST_TO_ADDR
// end ;
51460: GO 51356
51462: POP
51463: POP
// repeat wait ( 0 0$1 ) ;
51464: LD_INT 35
51466: PPUSH
51467: CALL_OW 67
// for un in tmp do
51471: LD_ADDR_VAR 0 2
51475: PUSH
51476: LD_VAR 0 3
51480: PUSH
51481: FOR_IN
51482: IFFALSE 51556
// begin if IsDead ( un ) then
51484: LD_VAR 0 2
51488: PPUSH
51489: CALL_OW 301
51493: IFFALSE 51513
// begin tmp := tmp diff un ;
51495: LD_ADDR_VAR 0 3
51499: PUSH
51500: LD_VAR 0 3
51504: PUSH
51505: LD_VAR 0 2
51509: DIFF
51510: ST_TO_ADDR
// continue ;
51511: GO 51481
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51513: LD_VAR 0 2
51517: PPUSH
51518: LD_INT 3
51520: PUSH
51521: LD_INT 22
51523: PUSH
51524: LD_INT 0
51526: PUSH
51527: EMPTY
51528: LIST
51529: LIST
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: PPUSH
51535: CALL_OW 69
51539: PPUSH
51540: LD_VAR 0 2
51544: PPUSH
51545: CALL_OW 74
51549: PPUSH
51550: CALL_OW 115
// end ;
51554: GO 51481
51556: POP
51557: POP
// until not tmp ;
51558: LD_VAR 0 3
51562: NOT
51563: IFFALSE 51464
// end ;
51565: PPOPN 3
51567: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51568: LD_EXP 73
51572: PUSH
51573: LD_EXP 98
51577: AND
51578: IFFALSE 51632
51580: GO 51582
51582: DISABLE
// begin ToLua ( displayTroll(); ) ;
51583: LD_STRING displayTroll();
51585: PPUSH
51586: CALL_OW 559
// wait ( 3 3$00 ) ;
51590: LD_INT 6300
51592: PPUSH
51593: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51597: LD_STRING hideTroll();
51599: PPUSH
51600: CALL_OW 559
// wait ( 1 1$00 ) ;
51604: LD_INT 2100
51606: PPUSH
51607: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51611: LD_STRING displayTroll();
51613: PPUSH
51614: CALL_OW 559
// wait ( 1 1$00 ) ;
51618: LD_INT 2100
51620: PPUSH
51621: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51625: LD_STRING hideTroll();
51627: PPUSH
51628: CALL_OW 559
// end ;
51632: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51633: LD_EXP 73
51637: PUSH
51638: LD_EXP 99
51642: AND
51643: IFFALSE 51706
51645: GO 51647
51647: DISABLE
51648: LD_INT 0
51650: PPUSH
// begin p := 0 ;
51651: LD_ADDR_VAR 0 1
51655: PUSH
51656: LD_INT 0
51658: ST_TO_ADDR
// repeat game_speed := 1 ;
51659: LD_ADDR_OWVAR 65
51663: PUSH
51664: LD_INT 1
51666: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51667: LD_INT 35
51669: PPUSH
51670: CALL_OW 67
// p := p + 1 ;
51674: LD_ADDR_VAR 0 1
51678: PUSH
51679: LD_VAR 0 1
51683: PUSH
51684: LD_INT 1
51686: PLUS
51687: ST_TO_ADDR
// until p >= 60 ;
51688: LD_VAR 0 1
51692: PUSH
51693: LD_INT 60
51695: GREATEREQUAL
51696: IFFALSE 51659
// game_speed := 4 ;
51698: LD_ADDR_OWVAR 65
51702: PUSH
51703: LD_INT 4
51705: ST_TO_ADDR
// end ;
51706: PPOPN 1
51708: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51709: LD_EXP 73
51713: PUSH
51714: LD_EXP 100
51718: AND
51719: IFFALSE 51865
51721: GO 51723
51723: DISABLE
51724: LD_INT 0
51726: PPUSH
51727: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51728: LD_ADDR_VAR 0 1
51732: PUSH
51733: LD_INT 22
51735: PUSH
51736: LD_OWVAR 2
51740: PUSH
51741: EMPTY
51742: LIST
51743: LIST
51744: PUSH
51745: LD_INT 2
51747: PUSH
51748: LD_INT 30
51750: PUSH
51751: LD_INT 0
51753: PUSH
51754: EMPTY
51755: LIST
51756: LIST
51757: PUSH
51758: LD_INT 30
51760: PUSH
51761: LD_INT 1
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: PUSH
51768: EMPTY
51769: LIST
51770: LIST
51771: LIST
51772: PUSH
51773: EMPTY
51774: LIST
51775: LIST
51776: PPUSH
51777: CALL_OW 69
51781: ST_TO_ADDR
// if not depot then
51782: LD_VAR 0 1
51786: NOT
51787: IFFALSE 51791
// exit ;
51789: GO 51865
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51791: LD_ADDR_VAR 0 2
51795: PUSH
51796: LD_VAR 0 1
51800: PUSH
51801: LD_INT 1
51803: PPUSH
51804: LD_VAR 0 1
51808: PPUSH
51809: CALL_OW 12
51813: ARRAY
51814: PPUSH
51815: CALL_OW 274
51819: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51820: LD_VAR 0 2
51824: PPUSH
51825: LD_INT 1
51827: PPUSH
51828: LD_INT 0
51830: PPUSH
51831: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51835: LD_VAR 0 2
51839: PPUSH
51840: LD_INT 2
51842: PPUSH
51843: LD_INT 0
51845: PPUSH
51846: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51850: LD_VAR 0 2
51854: PPUSH
51855: LD_INT 3
51857: PPUSH
51858: LD_INT 0
51860: PPUSH
51861: CALL_OW 277
// end ;
51865: PPOPN 2
51867: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51868: LD_EXP 73
51872: PUSH
51873: LD_EXP 101
51877: AND
51878: IFFALSE 51975
51880: GO 51882
51882: DISABLE
51883: LD_INT 0
51885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51886: LD_ADDR_VAR 0 1
51890: PUSH
51891: LD_INT 22
51893: PUSH
51894: LD_OWVAR 2
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: PUSH
51903: LD_INT 21
51905: PUSH
51906: LD_INT 1
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: PUSH
51913: LD_INT 3
51915: PUSH
51916: LD_INT 23
51918: PUSH
51919: LD_INT 0
51921: PUSH
51922: EMPTY
51923: LIST
51924: LIST
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: PUSH
51930: EMPTY
51931: LIST
51932: LIST
51933: LIST
51934: PPUSH
51935: CALL_OW 69
51939: ST_TO_ADDR
// if not tmp then
51940: LD_VAR 0 1
51944: NOT
51945: IFFALSE 51949
// exit ;
51947: GO 51975
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51949: LD_VAR 0 1
51953: PUSH
51954: LD_INT 1
51956: PPUSH
51957: LD_VAR 0 1
51961: PPUSH
51962: CALL_OW 12
51966: ARRAY
51967: PPUSH
51968: LD_INT 200
51970: PPUSH
51971: CALL_OW 234
// end ;
51975: PPOPN 1
51977: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51978: LD_EXP 73
51982: PUSH
51983: LD_EXP 102
51987: AND
51988: IFFALSE 52067
51990: GO 51992
51992: DISABLE
51993: LD_INT 0
51995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51996: LD_ADDR_VAR 0 1
52000: PUSH
52001: LD_INT 22
52003: PUSH
52004: LD_OWVAR 2
52008: PUSH
52009: EMPTY
52010: LIST
52011: LIST
52012: PUSH
52013: LD_INT 21
52015: PUSH
52016: LD_INT 2
52018: PUSH
52019: EMPTY
52020: LIST
52021: LIST
52022: PUSH
52023: EMPTY
52024: LIST
52025: LIST
52026: PPUSH
52027: CALL_OW 69
52031: ST_TO_ADDR
// if not tmp then
52032: LD_VAR 0 1
52036: NOT
52037: IFFALSE 52041
// exit ;
52039: GO 52067
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52041: LD_VAR 0 1
52045: PUSH
52046: LD_INT 1
52048: PPUSH
52049: LD_VAR 0 1
52053: PPUSH
52054: CALL_OW 12
52058: ARRAY
52059: PPUSH
52060: LD_INT 60
52062: PPUSH
52063: CALL_OW 234
// end ;
52067: PPOPN 1
52069: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52070: LD_EXP 73
52074: PUSH
52075: LD_EXP 103
52079: AND
52080: IFFALSE 52179
52082: GO 52084
52084: DISABLE
52085: LD_INT 0
52087: PPUSH
52088: PPUSH
// begin enable ;
52089: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52090: LD_ADDR_VAR 0 1
52094: PUSH
52095: LD_INT 22
52097: PUSH
52098: LD_OWVAR 2
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: PUSH
52107: LD_INT 61
52109: PUSH
52110: EMPTY
52111: LIST
52112: PUSH
52113: LD_INT 33
52115: PUSH
52116: LD_INT 2
52118: PUSH
52119: EMPTY
52120: LIST
52121: LIST
52122: PUSH
52123: EMPTY
52124: LIST
52125: LIST
52126: LIST
52127: PPUSH
52128: CALL_OW 69
52132: ST_TO_ADDR
// if not tmp then
52133: LD_VAR 0 1
52137: NOT
52138: IFFALSE 52142
// exit ;
52140: GO 52179
// for i in tmp do
52142: LD_ADDR_VAR 0 2
52146: PUSH
52147: LD_VAR 0 1
52151: PUSH
52152: FOR_IN
52153: IFFALSE 52177
// if IsControledBy ( i ) then
52155: LD_VAR 0 2
52159: PPUSH
52160: CALL_OW 312
52164: IFFALSE 52175
// ComUnlink ( i ) ;
52166: LD_VAR 0 2
52170: PPUSH
52171: CALL_OW 136
52175: GO 52152
52177: POP
52178: POP
// end ;
52179: PPOPN 2
52181: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52182: LD_EXP 73
52186: PUSH
52187: LD_EXP 104
52191: AND
52192: IFFALSE 52332
52194: GO 52196
52196: DISABLE
52197: LD_INT 0
52199: PPUSH
52200: PPUSH
// begin ToLua ( displayPowell(); ) ;
52201: LD_STRING displayPowell();
52203: PPUSH
52204: CALL_OW 559
// uc_side := 0 ;
52208: LD_ADDR_OWVAR 20
52212: PUSH
52213: LD_INT 0
52215: ST_TO_ADDR
// uc_nation := 2 ;
52216: LD_ADDR_OWVAR 21
52220: PUSH
52221: LD_INT 2
52223: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52224: LD_ADDR_OWVAR 37
52228: PUSH
52229: LD_INT 14
52231: ST_TO_ADDR
// vc_engine := engine_siberite ;
52232: LD_ADDR_OWVAR 39
52236: PUSH
52237: LD_INT 3
52239: ST_TO_ADDR
// vc_control := control_apeman ;
52240: LD_ADDR_OWVAR 38
52244: PUSH
52245: LD_INT 5
52247: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52248: LD_ADDR_OWVAR 40
52252: PUSH
52253: LD_INT 29
52255: ST_TO_ADDR
// un := CreateVehicle ;
52256: LD_ADDR_VAR 0 2
52260: PUSH
52261: CALL_OW 45
52265: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52266: LD_VAR 0 2
52270: PPUSH
52271: LD_INT 1
52273: PPUSH
52274: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52278: LD_INT 35
52280: PPUSH
52281: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52285: LD_VAR 0 2
52289: PPUSH
52290: LD_INT 22
52292: PUSH
52293: LD_OWVAR 2
52297: PUSH
52298: EMPTY
52299: LIST
52300: LIST
52301: PPUSH
52302: CALL_OW 69
52306: PPUSH
52307: LD_VAR 0 2
52311: PPUSH
52312: CALL_OW 74
52316: PPUSH
52317: CALL_OW 115
// until IsDead ( un ) ;
52321: LD_VAR 0 2
52325: PPUSH
52326: CALL_OW 301
52330: IFFALSE 52278
// end ;
52332: PPOPN 2
52334: END
// every 0 0$1 trigger StreamModeActive and sStu do
52335: LD_EXP 73
52339: PUSH
52340: LD_EXP 112
52344: AND
52345: IFFALSE 52361
52347: GO 52349
52349: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52350: LD_STRING displayStucuk();
52352: PPUSH
52353: CALL_OW 559
// ResetFog ;
52357: CALL_OW 335
// end ;
52361: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52362: LD_EXP 73
52366: PUSH
52367: LD_EXP 105
52371: AND
52372: IFFALSE 52513
52374: GO 52376
52376: DISABLE
52377: LD_INT 0
52379: PPUSH
52380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52381: LD_ADDR_VAR 0 2
52385: PUSH
52386: LD_INT 22
52388: PUSH
52389: LD_OWVAR 2
52393: PUSH
52394: EMPTY
52395: LIST
52396: LIST
52397: PUSH
52398: LD_INT 21
52400: PUSH
52401: LD_INT 1
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: PUSH
52408: EMPTY
52409: LIST
52410: LIST
52411: PPUSH
52412: CALL_OW 69
52416: ST_TO_ADDR
// if not tmp then
52417: LD_VAR 0 2
52421: NOT
52422: IFFALSE 52426
// exit ;
52424: GO 52513
// un := tmp [ rand ( 1 , tmp ) ] ;
52426: LD_ADDR_VAR 0 1
52430: PUSH
52431: LD_VAR 0 2
52435: PUSH
52436: LD_INT 1
52438: PPUSH
52439: LD_VAR 0 2
52443: PPUSH
52444: CALL_OW 12
52448: ARRAY
52449: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52450: LD_VAR 0 1
52454: PPUSH
52455: LD_INT 0
52457: PPUSH
52458: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52462: LD_VAR 0 1
52466: PPUSH
52467: LD_OWVAR 3
52471: PUSH
52472: LD_VAR 0 1
52476: DIFF
52477: PPUSH
52478: LD_VAR 0 1
52482: PPUSH
52483: CALL_OW 74
52487: PPUSH
52488: CALL_OW 115
// wait ( 0 0$20 ) ;
52492: LD_INT 700
52494: PPUSH
52495: CALL_OW 67
// SetSide ( un , your_side ) ;
52499: LD_VAR 0 1
52503: PPUSH
52504: LD_OWVAR 2
52508: PPUSH
52509: CALL_OW 235
// end ;
52513: PPOPN 2
52515: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52516: LD_EXP 73
52520: PUSH
52521: LD_EXP 106
52525: AND
52526: IFFALSE 52632
52528: GO 52530
52530: DISABLE
52531: LD_INT 0
52533: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52534: LD_ADDR_VAR 0 1
52538: PUSH
52539: LD_INT 22
52541: PUSH
52542: LD_OWVAR 2
52546: PUSH
52547: EMPTY
52548: LIST
52549: LIST
52550: PUSH
52551: LD_INT 2
52553: PUSH
52554: LD_INT 30
52556: PUSH
52557: LD_INT 0
52559: PUSH
52560: EMPTY
52561: LIST
52562: LIST
52563: PUSH
52564: LD_INT 30
52566: PUSH
52567: LD_INT 1
52569: PUSH
52570: EMPTY
52571: LIST
52572: LIST
52573: PUSH
52574: EMPTY
52575: LIST
52576: LIST
52577: LIST
52578: PUSH
52579: EMPTY
52580: LIST
52581: LIST
52582: PPUSH
52583: CALL_OW 69
52587: ST_TO_ADDR
// if not depot then
52588: LD_VAR 0 1
52592: NOT
52593: IFFALSE 52597
// exit ;
52595: GO 52632
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52597: LD_VAR 0 1
52601: PUSH
52602: LD_INT 1
52604: ARRAY
52605: PPUSH
52606: CALL_OW 250
52610: PPUSH
52611: LD_VAR 0 1
52615: PUSH
52616: LD_INT 1
52618: ARRAY
52619: PPUSH
52620: CALL_OW 251
52624: PPUSH
52625: LD_INT 70
52627: PPUSH
52628: CALL_OW 495
// end ;
52632: PPOPN 1
52634: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52635: LD_EXP 73
52639: PUSH
52640: LD_EXP 107
52644: AND
52645: IFFALSE 52856
52647: GO 52649
52649: DISABLE
52650: LD_INT 0
52652: PPUSH
52653: PPUSH
52654: PPUSH
52655: PPUSH
52656: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52657: LD_ADDR_VAR 0 5
52661: PUSH
52662: LD_INT 22
52664: PUSH
52665: LD_OWVAR 2
52669: PUSH
52670: EMPTY
52671: LIST
52672: LIST
52673: PUSH
52674: LD_INT 21
52676: PUSH
52677: LD_INT 1
52679: PUSH
52680: EMPTY
52681: LIST
52682: LIST
52683: PUSH
52684: EMPTY
52685: LIST
52686: LIST
52687: PPUSH
52688: CALL_OW 69
52692: ST_TO_ADDR
// if not tmp then
52693: LD_VAR 0 5
52697: NOT
52698: IFFALSE 52702
// exit ;
52700: GO 52856
// for i in tmp do
52702: LD_ADDR_VAR 0 1
52706: PUSH
52707: LD_VAR 0 5
52711: PUSH
52712: FOR_IN
52713: IFFALSE 52854
// begin d := rand ( 0 , 5 ) ;
52715: LD_ADDR_VAR 0 4
52719: PUSH
52720: LD_INT 0
52722: PPUSH
52723: LD_INT 5
52725: PPUSH
52726: CALL_OW 12
52730: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52731: LD_ADDR_VAR 0 2
52735: PUSH
52736: LD_VAR 0 1
52740: PPUSH
52741: CALL_OW 250
52745: PPUSH
52746: LD_VAR 0 4
52750: PPUSH
52751: LD_INT 3
52753: PPUSH
52754: LD_INT 12
52756: PPUSH
52757: CALL_OW 12
52761: PPUSH
52762: CALL_OW 272
52766: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52767: LD_ADDR_VAR 0 3
52771: PUSH
52772: LD_VAR 0 1
52776: PPUSH
52777: CALL_OW 251
52781: PPUSH
52782: LD_VAR 0 4
52786: PPUSH
52787: LD_INT 3
52789: PPUSH
52790: LD_INT 12
52792: PPUSH
52793: CALL_OW 12
52797: PPUSH
52798: CALL_OW 273
52802: ST_TO_ADDR
// if ValidHex ( x , y ) then
52803: LD_VAR 0 2
52807: PPUSH
52808: LD_VAR 0 3
52812: PPUSH
52813: CALL_OW 488
52817: IFFALSE 52852
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52819: LD_VAR 0 1
52823: PPUSH
52824: LD_VAR 0 2
52828: PPUSH
52829: LD_VAR 0 3
52833: PPUSH
52834: LD_INT 3
52836: PPUSH
52837: LD_INT 6
52839: PPUSH
52840: CALL_OW 12
52844: PPUSH
52845: LD_INT 1
52847: PPUSH
52848: CALL_OW 483
// end ;
52852: GO 52712
52854: POP
52855: POP
// end ;
52856: PPOPN 5
52858: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52859: LD_EXP 73
52863: PUSH
52864: LD_EXP 108
52868: AND
52869: IFFALSE 52963
52871: GO 52873
52873: DISABLE
52874: LD_INT 0
52876: PPUSH
52877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52878: LD_ADDR_VAR 0 2
52882: PUSH
52883: LD_INT 22
52885: PUSH
52886: LD_OWVAR 2
52890: PUSH
52891: EMPTY
52892: LIST
52893: LIST
52894: PUSH
52895: LD_INT 32
52897: PUSH
52898: LD_INT 1
52900: PUSH
52901: EMPTY
52902: LIST
52903: LIST
52904: PUSH
52905: LD_INT 21
52907: PUSH
52908: LD_INT 2
52910: PUSH
52911: EMPTY
52912: LIST
52913: LIST
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: PPUSH
52920: CALL_OW 69
52924: ST_TO_ADDR
// if not tmp then
52925: LD_VAR 0 2
52929: NOT
52930: IFFALSE 52934
// exit ;
52932: GO 52963
// for i in tmp do
52934: LD_ADDR_VAR 0 1
52938: PUSH
52939: LD_VAR 0 2
52943: PUSH
52944: FOR_IN
52945: IFFALSE 52961
// SetFuel ( i , 0 ) ;
52947: LD_VAR 0 1
52951: PPUSH
52952: LD_INT 0
52954: PPUSH
52955: CALL_OW 240
52959: GO 52944
52961: POP
52962: POP
// end ;
52963: PPOPN 2
52965: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52966: LD_EXP 73
52970: PUSH
52971: LD_EXP 109
52975: AND
52976: IFFALSE 53042
52978: GO 52980
52980: DISABLE
52981: LD_INT 0
52983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52984: LD_ADDR_VAR 0 1
52988: PUSH
52989: LD_INT 22
52991: PUSH
52992: LD_OWVAR 2
52996: PUSH
52997: EMPTY
52998: LIST
52999: LIST
53000: PUSH
53001: LD_INT 30
53003: PUSH
53004: LD_INT 29
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: PPUSH
53015: CALL_OW 69
53019: ST_TO_ADDR
// if not tmp then
53020: LD_VAR 0 1
53024: NOT
53025: IFFALSE 53029
// exit ;
53027: GO 53042
// DestroyUnit ( tmp [ 1 ] ) ;
53029: LD_VAR 0 1
53033: PUSH
53034: LD_INT 1
53036: ARRAY
53037: PPUSH
53038: CALL_OW 65
// end ;
53042: PPOPN 1
53044: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53045: LD_EXP 73
53049: PUSH
53050: LD_EXP 111
53054: AND
53055: IFFALSE 53184
53057: GO 53059
53059: DISABLE
53060: LD_INT 0
53062: PPUSH
// begin uc_side := 0 ;
53063: LD_ADDR_OWVAR 20
53067: PUSH
53068: LD_INT 0
53070: ST_TO_ADDR
// uc_nation := nation_arabian ;
53071: LD_ADDR_OWVAR 21
53075: PUSH
53076: LD_INT 2
53078: ST_TO_ADDR
// hc_gallery :=  ;
53079: LD_ADDR_OWVAR 33
53083: PUSH
53084: LD_STRING 
53086: ST_TO_ADDR
// hc_name :=  ;
53087: LD_ADDR_OWVAR 26
53091: PUSH
53092: LD_STRING 
53094: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53095: LD_INT 1
53097: PPUSH
53098: LD_INT 11
53100: PPUSH
53101: LD_INT 10
53103: PPUSH
53104: CALL_OW 380
// un := CreateHuman ;
53108: LD_ADDR_VAR 0 1
53112: PUSH
53113: CALL_OW 44
53117: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53118: LD_VAR 0 1
53122: PPUSH
53123: LD_INT 1
53125: PPUSH
53126: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53130: LD_INT 35
53132: PPUSH
53133: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53137: LD_VAR 0 1
53141: PPUSH
53142: LD_INT 22
53144: PUSH
53145: LD_OWVAR 2
53149: PUSH
53150: EMPTY
53151: LIST
53152: LIST
53153: PPUSH
53154: CALL_OW 69
53158: PPUSH
53159: LD_VAR 0 1
53163: PPUSH
53164: CALL_OW 74
53168: PPUSH
53169: CALL_OW 115
// until IsDead ( un ) ;
53173: LD_VAR 0 1
53177: PPUSH
53178: CALL_OW 301
53182: IFFALSE 53130
// end ;
53184: PPOPN 1
53186: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53187: LD_EXP 73
53191: PUSH
53192: LD_EXP 113
53196: AND
53197: IFFALSE 53209
53199: GO 53201
53201: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53202: LD_STRING earthquake(getX(game), 0, 32)
53204: PPUSH
53205: CALL_OW 559
53209: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53210: LD_EXP 73
53214: PUSH
53215: LD_EXP 114
53219: AND
53220: IFFALSE 53311
53222: GO 53224
53224: DISABLE
53225: LD_INT 0
53227: PPUSH
// begin enable ;
53228: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53229: LD_ADDR_VAR 0 1
53233: PUSH
53234: LD_INT 22
53236: PUSH
53237: LD_OWVAR 2
53241: PUSH
53242: EMPTY
53243: LIST
53244: LIST
53245: PUSH
53246: LD_INT 21
53248: PUSH
53249: LD_INT 2
53251: PUSH
53252: EMPTY
53253: LIST
53254: LIST
53255: PUSH
53256: LD_INT 33
53258: PUSH
53259: LD_INT 3
53261: PUSH
53262: EMPTY
53263: LIST
53264: LIST
53265: PUSH
53266: EMPTY
53267: LIST
53268: LIST
53269: LIST
53270: PPUSH
53271: CALL_OW 69
53275: ST_TO_ADDR
// if not tmp then
53276: LD_VAR 0 1
53280: NOT
53281: IFFALSE 53285
// exit ;
53283: GO 53311
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53285: LD_VAR 0 1
53289: PUSH
53290: LD_INT 1
53292: PPUSH
53293: LD_VAR 0 1
53297: PPUSH
53298: CALL_OW 12
53302: ARRAY
53303: PPUSH
53304: LD_INT 1
53306: PPUSH
53307: CALL_OW 234
// end ;
53311: PPOPN 1
53313: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53314: LD_EXP 73
53318: PUSH
53319: LD_EXP 115
53323: AND
53324: IFFALSE 53465
53326: GO 53328
53328: DISABLE
53329: LD_INT 0
53331: PPUSH
53332: PPUSH
53333: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53334: LD_ADDR_VAR 0 3
53338: PUSH
53339: LD_INT 22
53341: PUSH
53342: LD_OWVAR 2
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: PUSH
53351: LD_INT 25
53353: PUSH
53354: LD_INT 1
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: PUSH
53361: EMPTY
53362: LIST
53363: LIST
53364: PPUSH
53365: CALL_OW 69
53369: ST_TO_ADDR
// if not tmp then
53370: LD_VAR 0 3
53374: NOT
53375: IFFALSE 53379
// exit ;
53377: GO 53465
// un := tmp [ rand ( 1 , tmp ) ] ;
53379: LD_ADDR_VAR 0 2
53383: PUSH
53384: LD_VAR 0 3
53388: PUSH
53389: LD_INT 1
53391: PPUSH
53392: LD_VAR 0 3
53396: PPUSH
53397: CALL_OW 12
53401: ARRAY
53402: ST_TO_ADDR
// if Crawls ( un ) then
53403: LD_VAR 0 2
53407: PPUSH
53408: CALL_OW 318
53412: IFFALSE 53423
// ComWalk ( un ) ;
53414: LD_VAR 0 2
53418: PPUSH
53419: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53423: LD_VAR 0 2
53427: PPUSH
53428: LD_INT 9
53430: PPUSH
53431: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53435: LD_INT 28
53437: PPUSH
53438: LD_OWVAR 2
53442: PPUSH
53443: LD_INT 2
53445: PPUSH
53446: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53450: LD_INT 29
53452: PPUSH
53453: LD_OWVAR 2
53457: PPUSH
53458: LD_INT 2
53460: PPUSH
53461: CALL_OW 322
// end ;
53465: PPOPN 3
53467: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53468: LD_EXP 73
53472: PUSH
53473: LD_EXP 116
53477: AND
53478: IFFALSE 53589
53480: GO 53482
53482: DISABLE
53483: LD_INT 0
53485: PPUSH
53486: PPUSH
53487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_INT 22
53495: PUSH
53496: LD_OWVAR 2
53500: PUSH
53501: EMPTY
53502: LIST
53503: LIST
53504: PUSH
53505: LD_INT 25
53507: PUSH
53508: LD_INT 1
53510: PUSH
53511: EMPTY
53512: LIST
53513: LIST
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: PPUSH
53519: CALL_OW 69
53523: ST_TO_ADDR
// if not tmp then
53524: LD_VAR 0 3
53528: NOT
53529: IFFALSE 53533
// exit ;
53531: GO 53589
// un := tmp [ rand ( 1 , tmp ) ] ;
53533: LD_ADDR_VAR 0 2
53537: PUSH
53538: LD_VAR 0 3
53542: PUSH
53543: LD_INT 1
53545: PPUSH
53546: LD_VAR 0 3
53550: PPUSH
53551: CALL_OW 12
53555: ARRAY
53556: ST_TO_ADDR
// if Crawls ( un ) then
53557: LD_VAR 0 2
53561: PPUSH
53562: CALL_OW 318
53566: IFFALSE 53577
// ComWalk ( un ) ;
53568: LD_VAR 0 2
53572: PPUSH
53573: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53577: LD_VAR 0 2
53581: PPUSH
53582: LD_INT 8
53584: PPUSH
53585: CALL_OW 336
// end ;
53589: PPOPN 3
53591: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53592: LD_EXP 73
53596: PUSH
53597: LD_EXP 117
53601: AND
53602: IFFALSE 53746
53604: GO 53606
53606: DISABLE
53607: LD_INT 0
53609: PPUSH
53610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53611: LD_ADDR_VAR 0 2
53615: PUSH
53616: LD_INT 22
53618: PUSH
53619: LD_OWVAR 2
53623: PUSH
53624: EMPTY
53625: LIST
53626: LIST
53627: PUSH
53628: LD_INT 21
53630: PUSH
53631: LD_INT 2
53633: PUSH
53634: EMPTY
53635: LIST
53636: LIST
53637: PUSH
53638: LD_INT 2
53640: PUSH
53641: LD_INT 34
53643: PUSH
53644: LD_INT 12
53646: PUSH
53647: EMPTY
53648: LIST
53649: LIST
53650: PUSH
53651: LD_INT 34
53653: PUSH
53654: LD_INT 51
53656: PUSH
53657: EMPTY
53658: LIST
53659: LIST
53660: PUSH
53661: LD_INT 34
53663: PUSH
53664: LD_INT 32
53666: PUSH
53667: EMPTY
53668: LIST
53669: LIST
53670: PUSH
53671: EMPTY
53672: LIST
53673: LIST
53674: LIST
53675: LIST
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: LIST
53681: PPUSH
53682: CALL_OW 69
53686: ST_TO_ADDR
// if not tmp then
53687: LD_VAR 0 2
53691: NOT
53692: IFFALSE 53696
// exit ;
53694: GO 53746
// for i in tmp do
53696: LD_ADDR_VAR 0 1
53700: PUSH
53701: LD_VAR 0 2
53705: PUSH
53706: FOR_IN
53707: IFFALSE 53744
// if GetCargo ( i , mat_artifact ) = 0 then
53709: LD_VAR 0 1
53713: PPUSH
53714: LD_INT 4
53716: PPUSH
53717: CALL_OW 289
53721: PUSH
53722: LD_INT 0
53724: EQUAL
53725: IFFALSE 53742
// SetCargo ( i , mat_siberit , 100 ) ;
53727: LD_VAR 0 1
53731: PPUSH
53732: LD_INT 3
53734: PPUSH
53735: LD_INT 100
53737: PPUSH
53738: CALL_OW 290
53742: GO 53706
53744: POP
53745: POP
// end ;
53746: PPOPN 2
53748: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53749: LD_EXP 73
53753: PUSH
53754: LD_EXP 118
53758: AND
53759: IFFALSE 53942
53761: GO 53763
53763: DISABLE
53764: LD_INT 0
53766: PPUSH
53767: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53768: LD_ADDR_VAR 0 2
53772: PUSH
53773: LD_INT 22
53775: PUSH
53776: LD_OWVAR 2
53780: PUSH
53781: EMPTY
53782: LIST
53783: LIST
53784: PPUSH
53785: CALL_OW 69
53789: ST_TO_ADDR
// if not tmp then
53790: LD_VAR 0 2
53794: NOT
53795: IFFALSE 53799
// exit ;
53797: GO 53942
// for i := 1 to 2 do
53799: LD_ADDR_VAR 0 1
53803: PUSH
53804: DOUBLE
53805: LD_INT 1
53807: DEC
53808: ST_TO_ADDR
53809: LD_INT 2
53811: PUSH
53812: FOR_TO
53813: IFFALSE 53940
// begin uc_side := your_side ;
53815: LD_ADDR_OWVAR 20
53819: PUSH
53820: LD_OWVAR 2
53824: ST_TO_ADDR
// uc_nation := nation_american ;
53825: LD_ADDR_OWVAR 21
53829: PUSH
53830: LD_INT 1
53832: ST_TO_ADDR
// vc_chassis := us_morphling ;
53833: LD_ADDR_OWVAR 37
53837: PUSH
53838: LD_INT 5
53840: ST_TO_ADDR
// vc_engine := engine_siberite ;
53841: LD_ADDR_OWVAR 39
53845: PUSH
53846: LD_INT 3
53848: ST_TO_ADDR
// vc_control := control_computer ;
53849: LD_ADDR_OWVAR 38
53853: PUSH
53854: LD_INT 3
53856: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53857: LD_ADDR_OWVAR 40
53861: PUSH
53862: LD_INT 10
53864: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53865: LD_VAR 0 2
53869: PUSH
53870: LD_INT 1
53872: ARRAY
53873: PPUSH
53874: CALL_OW 310
53878: NOT
53879: IFFALSE 53926
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53881: CALL_OW 45
53885: PPUSH
53886: LD_VAR 0 2
53890: PUSH
53891: LD_INT 1
53893: ARRAY
53894: PPUSH
53895: CALL_OW 250
53899: PPUSH
53900: LD_VAR 0 2
53904: PUSH
53905: LD_INT 1
53907: ARRAY
53908: PPUSH
53909: CALL_OW 251
53913: PPUSH
53914: LD_INT 12
53916: PPUSH
53917: LD_INT 1
53919: PPUSH
53920: CALL_OW 50
53924: GO 53938
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53926: CALL_OW 45
53930: PPUSH
53931: LD_INT 1
53933: PPUSH
53934: CALL_OW 51
// end ;
53938: GO 53812
53940: POP
53941: POP
// end ;
53942: PPOPN 2
53944: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53945: LD_EXP 73
53949: PUSH
53950: LD_EXP 119
53954: AND
53955: IFFALSE 54177
53957: GO 53959
53959: DISABLE
53960: LD_INT 0
53962: PPUSH
53963: PPUSH
53964: PPUSH
53965: PPUSH
53966: PPUSH
53967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53968: LD_ADDR_VAR 0 6
53972: PUSH
53973: LD_INT 22
53975: PUSH
53976: LD_OWVAR 2
53980: PUSH
53981: EMPTY
53982: LIST
53983: LIST
53984: PUSH
53985: LD_INT 21
53987: PUSH
53988: LD_INT 1
53990: PUSH
53991: EMPTY
53992: LIST
53993: LIST
53994: PUSH
53995: LD_INT 3
53997: PUSH
53998: LD_INT 23
54000: PUSH
54001: LD_INT 0
54003: PUSH
54004: EMPTY
54005: LIST
54006: LIST
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: PUSH
54012: EMPTY
54013: LIST
54014: LIST
54015: LIST
54016: PPUSH
54017: CALL_OW 69
54021: ST_TO_ADDR
// if not tmp then
54022: LD_VAR 0 6
54026: NOT
54027: IFFALSE 54031
// exit ;
54029: GO 54177
// s1 := rand ( 1 , 4 ) ;
54031: LD_ADDR_VAR 0 2
54035: PUSH
54036: LD_INT 1
54038: PPUSH
54039: LD_INT 4
54041: PPUSH
54042: CALL_OW 12
54046: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54047: LD_ADDR_VAR 0 4
54051: PUSH
54052: LD_VAR 0 6
54056: PUSH
54057: LD_INT 1
54059: ARRAY
54060: PPUSH
54061: LD_VAR 0 2
54065: PPUSH
54066: CALL_OW 259
54070: ST_TO_ADDR
// if s1 = 1 then
54071: LD_VAR 0 2
54075: PUSH
54076: LD_INT 1
54078: EQUAL
54079: IFFALSE 54099
// s2 := rand ( 2 , 4 ) else
54081: LD_ADDR_VAR 0 3
54085: PUSH
54086: LD_INT 2
54088: PPUSH
54089: LD_INT 4
54091: PPUSH
54092: CALL_OW 12
54096: ST_TO_ADDR
54097: GO 54107
// s2 := 1 ;
54099: LD_ADDR_VAR 0 3
54103: PUSH
54104: LD_INT 1
54106: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54107: LD_ADDR_VAR 0 5
54111: PUSH
54112: LD_VAR 0 6
54116: PUSH
54117: LD_INT 1
54119: ARRAY
54120: PPUSH
54121: LD_VAR 0 3
54125: PPUSH
54126: CALL_OW 259
54130: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54131: LD_VAR 0 6
54135: PUSH
54136: LD_INT 1
54138: ARRAY
54139: PPUSH
54140: LD_VAR 0 2
54144: PPUSH
54145: LD_VAR 0 5
54149: PPUSH
54150: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54154: LD_VAR 0 6
54158: PUSH
54159: LD_INT 1
54161: ARRAY
54162: PPUSH
54163: LD_VAR 0 3
54167: PPUSH
54168: LD_VAR 0 4
54172: PPUSH
54173: CALL_OW 237
// end ;
54177: PPOPN 6
54179: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54180: LD_EXP 73
54184: PUSH
54185: LD_EXP 120
54189: AND
54190: IFFALSE 54269
54192: GO 54194
54194: DISABLE
54195: LD_INT 0
54197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54198: LD_ADDR_VAR 0 1
54202: PUSH
54203: LD_INT 22
54205: PUSH
54206: LD_OWVAR 2
54210: PUSH
54211: EMPTY
54212: LIST
54213: LIST
54214: PUSH
54215: LD_INT 30
54217: PUSH
54218: LD_INT 3
54220: PUSH
54221: EMPTY
54222: LIST
54223: LIST
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: PPUSH
54229: CALL_OW 69
54233: ST_TO_ADDR
// if not tmp then
54234: LD_VAR 0 1
54238: NOT
54239: IFFALSE 54243
// exit ;
54241: GO 54269
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54243: LD_VAR 0 1
54247: PUSH
54248: LD_INT 1
54250: PPUSH
54251: LD_VAR 0 1
54255: PPUSH
54256: CALL_OW 12
54260: ARRAY
54261: PPUSH
54262: LD_INT 1
54264: PPUSH
54265: CALL_OW 234
// end ;
54269: PPOPN 1
54271: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54272: LD_EXP 73
54276: PUSH
54277: LD_EXP 121
54281: AND
54282: IFFALSE 54394
54284: GO 54286
54286: DISABLE
54287: LD_INT 0
54289: PPUSH
54290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54291: LD_ADDR_VAR 0 2
54295: PUSH
54296: LD_INT 22
54298: PUSH
54299: LD_OWVAR 2
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: PUSH
54308: LD_INT 2
54310: PUSH
54311: LD_INT 30
54313: PUSH
54314: LD_INT 27
54316: PUSH
54317: EMPTY
54318: LIST
54319: LIST
54320: PUSH
54321: LD_INT 30
54323: PUSH
54324: LD_INT 26
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: PUSH
54331: LD_INT 30
54333: PUSH
54334: LD_INT 28
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: PUSH
54341: EMPTY
54342: LIST
54343: LIST
54344: LIST
54345: LIST
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: PPUSH
54351: CALL_OW 69
54355: ST_TO_ADDR
// if not tmp then
54356: LD_VAR 0 2
54360: NOT
54361: IFFALSE 54365
// exit ;
54363: GO 54394
// for i in tmp do
54365: LD_ADDR_VAR 0 1
54369: PUSH
54370: LD_VAR 0 2
54374: PUSH
54375: FOR_IN
54376: IFFALSE 54392
// SetLives ( i , 1 ) ;
54378: LD_VAR 0 1
54382: PPUSH
54383: LD_INT 1
54385: PPUSH
54386: CALL_OW 234
54390: GO 54375
54392: POP
54393: POP
// end ;
54394: PPOPN 2
54396: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54397: LD_EXP 73
54401: PUSH
54402: LD_EXP 122
54406: AND
54407: IFFALSE 54694
54409: GO 54411
54411: DISABLE
54412: LD_INT 0
54414: PPUSH
54415: PPUSH
54416: PPUSH
// begin i := rand ( 1 , 7 ) ;
54417: LD_ADDR_VAR 0 1
54421: PUSH
54422: LD_INT 1
54424: PPUSH
54425: LD_INT 7
54427: PPUSH
54428: CALL_OW 12
54432: ST_TO_ADDR
// case i of 1 :
54433: LD_VAR 0 1
54437: PUSH
54438: LD_INT 1
54440: DOUBLE
54441: EQUAL
54442: IFTRUE 54446
54444: GO 54456
54446: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54447: LD_STRING earthquake(getX(game), 0, 32)
54449: PPUSH
54450: CALL_OW 559
54454: GO 54694
54456: LD_INT 2
54458: DOUBLE
54459: EQUAL
54460: IFTRUE 54464
54462: GO 54478
54464: POP
// begin ToLua ( displayStucuk(); ) ;
54465: LD_STRING displayStucuk();
54467: PPUSH
54468: CALL_OW 559
// ResetFog ;
54472: CALL_OW 335
// end ; 3 :
54476: GO 54694
54478: LD_INT 3
54480: DOUBLE
54481: EQUAL
54482: IFTRUE 54486
54484: GO 54590
54486: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54487: LD_ADDR_VAR 0 2
54491: PUSH
54492: LD_INT 22
54494: PUSH
54495: LD_OWVAR 2
54499: PUSH
54500: EMPTY
54501: LIST
54502: LIST
54503: PUSH
54504: LD_INT 25
54506: PUSH
54507: LD_INT 1
54509: PUSH
54510: EMPTY
54511: LIST
54512: LIST
54513: PUSH
54514: EMPTY
54515: LIST
54516: LIST
54517: PPUSH
54518: CALL_OW 69
54522: ST_TO_ADDR
// if not tmp then
54523: LD_VAR 0 2
54527: NOT
54528: IFFALSE 54532
// exit ;
54530: GO 54694
// un := tmp [ rand ( 1 , tmp ) ] ;
54532: LD_ADDR_VAR 0 3
54536: PUSH
54537: LD_VAR 0 2
54541: PUSH
54542: LD_INT 1
54544: PPUSH
54545: LD_VAR 0 2
54549: PPUSH
54550: CALL_OW 12
54554: ARRAY
54555: ST_TO_ADDR
// if Crawls ( un ) then
54556: LD_VAR 0 3
54560: PPUSH
54561: CALL_OW 318
54565: IFFALSE 54576
// ComWalk ( un ) ;
54567: LD_VAR 0 3
54571: PPUSH
54572: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54576: LD_VAR 0 3
54580: PPUSH
54581: LD_INT 8
54583: PPUSH
54584: CALL_OW 336
// end ; 4 :
54588: GO 54694
54590: LD_INT 4
54592: DOUBLE
54593: EQUAL
54594: IFTRUE 54598
54596: GO 54672
54598: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54599: LD_ADDR_VAR 0 2
54603: PUSH
54604: LD_INT 22
54606: PUSH
54607: LD_OWVAR 2
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: PUSH
54616: LD_INT 30
54618: PUSH
54619: LD_INT 29
54621: PUSH
54622: EMPTY
54623: LIST
54624: LIST
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: PPUSH
54630: CALL_OW 69
54634: ST_TO_ADDR
// if not tmp then
54635: LD_VAR 0 2
54639: NOT
54640: IFFALSE 54644
// exit ;
54642: GO 54694
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54644: LD_VAR 0 2
54648: PUSH
54649: LD_INT 1
54651: ARRAY
54652: PPUSH
54653: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54657: LD_VAR 0 2
54661: PUSH
54662: LD_INT 1
54664: ARRAY
54665: PPUSH
54666: CALL_OW 65
// end ; 5 .. 7 :
54670: GO 54694
54672: LD_INT 5
54674: DOUBLE
54675: GREATEREQUAL
54676: IFFALSE 54684
54678: LD_INT 7
54680: DOUBLE
54681: LESSEQUAL
54682: IFTRUE 54686
54684: GO 54693
54686: POP
// StreamSibBomb ; end ;
54687: CALL 50931 0 0
54691: GO 54694
54693: POP
// end ;
54694: PPOPN 3
54696: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54697: LD_EXP 73
54701: PUSH
54702: LD_EXP 123
54706: AND
54707: IFFALSE 54863
54709: GO 54711
54711: DISABLE
54712: LD_INT 0
54714: PPUSH
54715: PPUSH
54716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54717: LD_ADDR_VAR 0 2
54721: PUSH
54722: LD_INT 81
54724: PUSH
54725: LD_OWVAR 2
54729: PUSH
54730: EMPTY
54731: LIST
54732: LIST
54733: PUSH
54734: LD_INT 2
54736: PUSH
54737: LD_INT 21
54739: PUSH
54740: LD_INT 1
54742: PUSH
54743: EMPTY
54744: LIST
54745: LIST
54746: PUSH
54747: LD_INT 21
54749: PUSH
54750: LD_INT 2
54752: PUSH
54753: EMPTY
54754: LIST
54755: LIST
54756: PUSH
54757: EMPTY
54758: LIST
54759: LIST
54760: LIST
54761: PUSH
54762: EMPTY
54763: LIST
54764: LIST
54765: PPUSH
54766: CALL_OW 69
54770: ST_TO_ADDR
// if not tmp then
54771: LD_VAR 0 2
54775: NOT
54776: IFFALSE 54780
// exit ;
54778: GO 54863
// p := 0 ;
54780: LD_ADDR_VAR 0 3
54784: PUSH
54785: LD_INT 0
54787: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54788: LD_INT 35
54790: PPUSH
54791: CALL_OW 67
// p := p + 1 ;
54795: LD_ADDR_VAR 0 3
54799: PUSH
54800: LD_VAR 0 3
54804: PUSH
54805: LD_INT 1
54807: PLUS
54808: ST_TO_ADDR
// for i in tmp do
54809: LD_ADDR_VAR 0 1
54813: PUSH
54814: LD_VAR 0 2
54818: PUSH
54819: FOR_IN
54820: IFFALSE 54851
// if GetLives ( i ) < 1000 then
54822: LD_VAR 0 1
54826: PPUSH
54827: CALL_OW 256
54831: PUSH
54832: LD_INT 1000
54834: LESS
54835: IFFALSE 54849
// SetLives ( i , 1000 ) ;
54837: LD_VAR 0 1
54841: PPUSH
54842: LD_INT 1000
54844: PPUSH
54845: CALL_OW 234
54849: GO 54819
54851: POP
54852: POP
// until p > 20 ;
54853: LD_VAR 0 3
54857: PUSH
54858: LD_INT 20
54860: GREATER
54861: IFFALSE 54788
// end ;
54863: PPOPN 3
54865: END
// every 0 0$1 trigger StreamModeActive and sTime do
54866: LD_EXP 73
54870: PUSH
54871: LD_EXP 124
54875: AND
54876: IFFALSE 54911
54878: GO 54880
54880: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54881: LD_INT 28
54883: PPUSH
54884: LD_OWVAR 2
54888: PPUSH
54889: LD_INT 2
54891: PPUSH
54892: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54896: LD_INT 30
54898: PPUSH
54899: LD_OWVAR 2
54903: PPUSH
54904: LD_INT 2
54906: PPUSH
54907: CALL_OW 322
// end ;
54911: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54912: LD_EXP 73
54916: PUSH
54917: LD_EXP 125
54921: AND
54922: IFFALSE 55043
54924: GO 54926
54926: DISABLE
54927: LD_INT 0
54929: PPUSH
54930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54931: LD_ADDR_VAR 0 2
54935: PUSH
54936: LD_INT 22
54938: PUSH
54939: LD_OWVAR 2
54943: PUSH
54944: EMPTY
54945: LIST
54946: LIST
54947: PUSH
54948: LD_INT 21
54950: PUSH
54951: LD_INT 1
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: PUSH
54958: LD_INT 3
54960: PUSH
54961: LD_INT 23
54963: PUSH
54964: LD_INT 0
54966: PUSH
54967: EMPTY
54968: LIST
54969: LIST
54970: PUSH
54971: EMPTY
54972: LIST
54973: LIST
54974: PUSH
54975: EMPTY
54976: LIST
54977: LIST
54978: LIST
54979: PPUSH
54980: CALL_OW 69
54984: ST_TO_ADDR
// if not tmp then
54985: LD_VAR 0 2
54989: NOT
54990: IFFALSE 54994
// exit ;
54992: GO 55043
// for i in tmp do
54994: LD_ADDR_VAR 0 1
54998: PUSH
54999: LD_VAR 0 2
55003: PUSH
55004: FOR_IN
55005: IFFALSE 55041
// begin if Crawls ( i ) then
55007: LD_VAR 0 1
55011: PPUSH
55012: CALL_OW 318
55016: IFFALSE 55027
// ComWalk ( i ) ;
55018: LD_VAR 0 1
55022: PPUSH
55023: CALL_OW 138
// SetClass ( i , 2 ) ;
55027: LD_VAR 0 1
55031: PPUSH
55032: LD_INT 2
55034: PPUSH
55035: CALL_OW 336
// end ;
55039: GO 55004
55041: POP
55042: POP
// end ;
55043: PPOPN 2
55045: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55046: LD_EXP 73
55050: PUSH
55051: LD_EXP 126
55055: AND
55056: IFFALSE 55344
55058: GO 55060
55060: DISABLE
55061: LD_INT 0
55063: PPUSH
55064: PPUSH
55065: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55066: LD_OWVAR 2
55070: PPUSH
55071: LD_INT 9
55073: PPUSH
55074: LD_INT 1
55076: PPUSH
55077: LD_INT 1
55079: PPUSH
55080: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55084: LD_INT 9
55086: PPUSH
55087: LD_OWVAR 2
55091: PPUSH
55092: CALL_OW 343
// uc_side := 9 ;
55096: LD_ADDR_OWVAR 20
55100: PUSH
55101: LD_INT 9
55103: ST_TO_ADDR
// uc_nation := 2 ;
55104: LD_ADDR_OWVAR 21
55108: PUSH
55109: LD_INT 2
55111: ST_TO_ADDR
// hc_name := Dark Warrior ;
55112: LD_ADDR_OWVAR 26
55116: PUSH
55117: LD_STRING Dark Warrior
55119: ST_TO_ADDR
// hc_gallery :=  ;
55120: LD_ADDR_OWVAR 33
55124: PUSH
55125: LD_STRING 
55127: ST_TO_ADDR
// hc_noskilllimit := true ;
55128: LD_ADDR_OWVAR 76
55132: PUSH
55133: LD_INT 1
55135: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55136: LD_ADDR_OWVAR 31
55140: PUSH
55141: LD_INT 30
55143: PUSH
55144: LD_INT 30
55146: PUSH
55147: LD_INT 30
55149: PUSH
55150: LD_INT 30
55152: PUSH
55153: EMPTY
55154: LIST
55155: LIST
55156: LIST
55157: LIST
55158: ST_TO_ADDR
// un := CreateHuman ;
55159: LD_ADDR_VAR 0 3
55163: PUSH
55164: CALL_OW 44
55168: ST_TO_ADDR
// hc_noskilllimit := false ;
55169: LD_ADDR_OWVAR 76
55173: PUSH
55174: LD_INT 0
55176: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55177: LD_VAR 0 3
55181: PPUSH
55182: LD_INT 1
55184: PPUSH
55185: CALL_OW 51
// ToLua ( playRanger() ) ;
55189: LD_STRING playRanger()
55191: PPUSH
55192: CALL_OW 559
// p := 0 ;
55196: LD_ADDR_VAR 0 2
55200: PUSH
55201: LD_INT 0
55203: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55204: LD_INT 35
55206: PPUSH
55207: CALL_OW 67
// p := p + 1 ;
55211: LD_ADDR_VAR 0 2
55215: PUSH
55216: LD_VAR 0 2
55220: PUSH
55221: LD_INT 1
55223: PLUS
55224: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55225: LD_VAR 0 3
55229: PPUSH
55230: CALL_OW 256
55234: PUSH
55235: LD_INT 1000
55237: LESS
55238: IFFALSE 55252
// SetLives ( un , 1000 ) ;
55240: LD_VAR 0 3
55244: PPUSH
55245: LD_INT 1000
55247: PPUSH
55248: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55252: LD_VAR 0 3
55256: PPUSH
55257: LD_INT 81
55259: PUSH
55260: LD_OWVAR 2
55264: PUSH
55265: EMPTY
55266: LIST
55267: LIST
55268: PUSH
55269: LD_INT 91
55271: PUSH
55272: LD_VAR 0 3
55276: PUSH
55277: LD_INT 30
55279: PUSH
55280: EMPTY
55281: LIST
55282: LIST
55283: LIST
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: PPUSH
55289: CALL_OW 69
55293: PPUSH
55294: LD_VAR 0 3
55298: PPUSH
55299: CALL_OW 74
55303: PPUSH
55304: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55308: LD_VAR 0 2
55312: PUSH
55313: LD_INT 80
55315: GREATER
55316: PUSH
55317: LD_VAR 0 3
55321: PPUSH
55322: CALL_OW 301
55326: OR
55327: IFFALSE 55204
// if un then
55329: LD_VAR 0 3
55333: IFFALSE 55344
// RemoveUnit ( un ) ;
55335: LD_VAR 0 3
55339: PPUSH
55340: CALL_OW 64
// end ;
55344: PPOPN 3
55346: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55347: LD_EXP 127
55351: IFFALSE 55467
55353: GO 55355
55355: DISABLE
55356: LD_INT 0
55358: PPUSH
55359: PPUSH
55360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55361: LD_ADDR_VAR 0 2
55365: PUSH
55366: LD_INT 81
55368: PUSH
55369: LD_OWVAR 2
55373: PUSH
55374: EMPTY
55375: LIST
55376: LIST
55377: PUSH
55378: LD_INT 21
55380: PUSH
55381: LD_INT 1
55383: PUSH
55384: EMPTY
55385: LIST
55386: LIST
55387: PUSH
55388: EMPTY
55389: LIST
55390: LIST
55391: PPUSH
55392: CALL_OW 69
55396: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55397: LD_STRING playComputer()
55399: PPUSH
55400: CALL_OW 559
// if not tmp then
55404: LD_VAR 0 2
55408: NOT
55409: IFFALSE 55413
// exit ;
55411: GO 55467
// for i in tmp do
55413: LD_ADDR_VAR 0 1
55417: PUSH
55418: LD_VAR 0 2
55422: PUSH
55423: FOR_IN
55424: IFFALSE 55465
// for j := 1 to 4 do
55426: LD_ADDR_VAR 0 3
55430: PUSH
55431: DOUBLE
55432: LD_INT 1
55434: DEC
55435: ST_TO_ADDR
55436: LD_INT 4
55438: PUSH
55439: FOR_TO
55440: IFFALSE 55461
// SetSkill ( i , j , 10 ) ;
55442: LD_VAR 0 1
55446: PPUSH
55447: LD_VAR 0 3
55451: PPUSH
55452: LD_INT 10
55454: PPUSH
55455: CALL_OW 237
55459: GO 55439
55461: POP
55462: POP
55463: GO 55423
55465: POP
55466: POP
// end ;
55467: PPOPN 3
55469: END
// every 0 0$1 trigger s30 do var i , tmp ;
55470: LD_EXP 128
55474: IFFALSE 55543
55476: GO 55478
55478: DISABLE
55479: LD_INT 0
55481: PPUSH
55482: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55483: LD_ADDR_VAR 0 2
55487: PUSH
55488: LD_INT 22
55490: PUSH
55491: LD_OWVAR 2
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PPUSH
55500: CALL_OW 69
55504: ST_TO_ADDR
// if not tmp then
55505: LD_VAR 0 2
55509: NOT
55510: IFFALSE 55514
// exit ;
55512: GO 55543
// for i in tmp do
55514: LD_ADDR_VAR 0 1
55518: PUSH
55519: LD_VAR 0 2
55523: PUSH
55524: FOR_IN
55525: IFFALSE 55541
// SetLives ( i , 300 ) ;
55527: LD_VAR 0 1
55531: PPUSH
55532: LD_INT 300
55534: PPUSH
55535: CALL_OW 234
55539: GO 55524
55541: POP
55542: POP
// end ;
55543: PPOPN 2
55545: END
// every 0 0$1 trigger s60 do var i , tmp ;
55546: LD_EXP 129
55550: IFFALSE 55619
55552: GO 55554
55554: DISABLE
55555: LD_INT 0
55557: PPUSH
55558: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55559: LD_ADDR_VAR 0 2
55563: PUSH
55564: LD_INT 22
55566: PUSH
55567: LD_OWVAR 2
55571: PUSH
55572: EMPTY
55573: LIST
55574: LIST
55575: PPUSH
55576: CALL_OW 69
55580: ST_TO_ADDR
// if not tmp then
55581: LD_VAR 0 2
55585: NOT
55586: IFFALSE 55590
// exit ;
55588: GO 55619
// for i in tmp do
55590: LD_ADDR_VAR 0 1
55594: PUSH
55595: LD_VAR 0 2
55599: PUSH
55600: FOR_IN
55601: IFFALSE 55617
// SetLives ( i , 600 ) ;
55603: LD_VAR 0 1
55607: PPUSH
55608: LD_INT 600
55610: PPUSH
55611: CALL_OW 234
55615: GO 55600
55617: POP
55618: POP
// end ;
55619: PPOPN 2
55621: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55622: LD_INT 0
55624: PPUSH
// case cmd of 301 :
55625: LD_VAR 0 1
55629: PUSH
55630: LD_INT 301
55632: DOUBLE
55633: EQUAL
55634: IFTRUE 55638
55636: GO 55670
55638: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55639: LD_VAR 0 6
55643: PPUSH
55644: LD_VAR 0 7
55648: PPUSH
55649: LD_VAR 0 8
55653: PPUSH
55654: LD_VAR 0 4
55658: PPUSH
55659: LD_VAR 0 5
55663: PPUSH
55664: CALL 56871 0 5
55668: GO 55791
55670: LD_INT 302
55672: DOUBLE
55673: EQUAL
55674: IFTRUE 55678
55676: GO 55715
55678: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55679: LD_VAR 0 6
55683: PPUSH
55684: LD_VAR 0 7
55688: PPUSH
55689: LD_VAR 0 8
55693: PPUSH
55694: LD_VAR 0 9
55698: PPUSH
55699: LD_VAR 0 4
55703: PPUSH
55704: LD_VAR 0 5
55708: PPUSH
55709: CALL 56962 0 6
55713: GO 55791
55715: LD_INT 303
55717: DOUBLE
55718: EQUAL
55719: IFTRUE 55723
55721: GO 55760
55723: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55724: LD_VAR 0 6
55728: PPUSH
55729: LD_VAR 0 7
55733: PPUSH
55734: LD_VAR 0 8
55738: PPUSH
55739: LD_VAR 0 9
55743: PPUSH
55744: LD_VAR 0 4
55748: PPUSH
55749: LD_VAR 0 5
55753: PPUSH
55754: CALL 55796 0 6
55758: GO 55791
55760: LD_INT 304
55762: DOUBLE
55763: EQUAL
55764: IFTRUE 55768
55766: GO 55790
55768: POP
// hHackTeleport ( unit , x , y ) ; end ;
55769: LD_VAR 0 2
55773: PPUSH
55774: LD_VAR 0 4
55778: PPUSH
55779: LD_VAR 0 5
55783: PPUSH
55784: CALL 57555 0 3
55788: GO 55791
55790: POP
// end ;
55791: LD_VAR 0 12
55795: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55796: LD_INT 0
55798: PPUSH
55799: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55800: LD_VAR 0 1
55804: PUSH
55805: LD_INT 1
55807: LESS
55808: PUSH
55809: LD_VAR 0 1
55813: PUSH
55814: LD_INT 3
55816: GREATER
55817: OR
55818: PUSH
55819: LD_VAR 0 5
55823: PPUSH
55824: LD_VAR 0 6
55828: PPUSH
55829: CALL_OW 428
55833: OR
55834: IFFALSE 55838
// exit ;
55836: GO 56558
// uc_side := your_side ;
55838: LD_ADDR_OWVAR 20
55842: PUSH
55843: LD_OWVAR 2
55847: ST_TO_ADDR
// uc_nation := nation ;
55848: LD_ADDR_OWVAR 21
55852: PUSH
55853: LD_VAR 0 1
55857: ST_TO_ADDR
// bc_level = 1 ;
55858: LD_ADDR_OWVAR 43
55862: PUSH
55863: LD_INT 1
55865: ST_TO_ADDR
// case btype of 1 :
55866: LD_VAR 0 2
55870: PUSH
55871: LD_INT 1
55873: DOUBLE
55874: EQUAL
55875: IFTRUE 55879
55877: GO 55890
55879: POP
// bc_type := b_depot ; 2 :
55880: LD_ADDR_OWVAR 42
55884: PUSH
55885: LD_INT 0
55887: ST_TO_ADDR
55888: GO 56502
55890: LD_INT 2
55892: DOUBLE
55893: EQUAL
55894: IFTRUE 55898
55896: GO 55909
55898: POP
// bc_type := b_warehouse ; 3 :
55899: LD_ADDR_OWVAR 42
55903: PUSH
55904: LD_INT 1
55906: ST_TO_ADDR
55907: GO 56502
55909: LD_INT 3
55911: DOUBLE
55912: EQUAL
55913: IFTRUE 55917
55915: GO 55928
55917: POP
// bc_type := b_lab ; 4 .. 9 :
55918: LD_ADDR_OWVAR 42
55922: PUSH
55923: LD_INT 6
55925: ST_TO_ADDR
55926: GO 56502
55928: LD_INT 4
55930: DOUBLE
55931: GREATEREQUAL
55932: IFFALSE 55940
55934: LD_INT 9
55936: DOUBLE
55937: LESSEQUAL
55938: IFTRUE 55942
55940: GO 55994
55942: POP
// begin bc_type := b_lab_half ;
55943: LD_ADDR_OWVAR 42
55947: PUSH
55948: LD_INT 7
55950: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
55951: LD_ADDR_OWVAR 44
55955: PUSH
55956: LD_INT 10
55958: PUSH
55959: LD_INT 11
55961: PUSH
55962: LD_INT 12
55964: PUSH
55965: LD_INT 15
55967: PUSH
55968: LD_INT 14
55970: PUSH
55971: LD_INT 13
55973: PUSH
55974: EMPTY
55975: LIST
55976: LIST
55977: LIST
55978: LIST
55979: LIST
55980: LIST
55981: PUSH
55982: LD_VAR 0 2
55986: PUSH
55987: LD_INT 3
55989: MINUS
55990: ARRAY
55991: ST_TO_ADDR
// end ; 10 .. 13 :
55992: GO 56502
55994: LD_INT 10
55996: DOUBLE
55997: GREATEREQUAL
55998: IFFALSE 56006
56000: LD_INT 13
56002: DOUBLE
56003: LESSEQUAL
56004: IFTRUE 56008
56006: GO 56085
56008: POP
// begin bc_type := b_lab_full ;
56009: LD_ADDR_OWVAR 42
56013: PUSH
56014: LD_INT 8
56016: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56017: LD_ADDR_OWVAR 44
56021: PUSH
56022: LD_INT 10
56024: PUSH
56025: LD_INT 12
56027: PUSH
56028: LD_INT 14
56030: PUSH
56031: LD_INT 13
56033: PUSH
56034: EMPTY
56035: LIST
56036: LIST
56037: LIST
56038: LIST
56039: PUSH
56040: LD_VAR 0 2
56044: PUSH
56045: LD_INT 9
56047: MINUS
56048: ARRAY
56049: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56050: LD_ADDR_OWVAR 45
56054: PUSH
56055: LD_INT 11
56057: PUSH
56058: LD_INT 15
56060: PUSH
56061: LD_INT 12
56063: PUSH
56064: LD_INT 15
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: LIST
56071: LIST
56072: PUSH
56073: LD_VAR 0 2
56077: PUSH
56078: LD_INT 9
56080: MINUS
56081: ARRAY
56082: ST_TO_ADDR
// end ; 14 :
56083: GO 56502
56085: LD_INT 14
56087: DOUBLE
56088: EQUAL
56089: IFTRUE 56093
56091: GO 56104
56093: POP
// bc_type := b_workshop ; 15 :
56094: LD_ADDR_OWVAR 42
56098: PUSH
56099: LD_INT 2
56101: ST_TO_ADDR
56102: GO 56502
56104: LD_INT 15
56106: DOUBLE
56107: EQUAL
56108: IFTRUE 56112
56110: GO 56123
56112: POP
// bc_type := b_factory ; 16 :
56113: LD_ADDR_OWVAR 42
56117: PUSH
56118: LD_INT 3
56120: ST_TO_ADDR
56121: GO 56502
56123: LD_INT 16
56125: DOUBLE
56126: EQUAL
56127: IFTRUE 56131
56129: GO 56142
56131: POP
// bc_type := b_ext_gun ; 17 :
56132: LD_ADDR_OWVAR 42
56136: PUSH
56137: LD_INT 17
56139: ST_TO_ADDR
56140: GO 56502
56142: LD_INT 17
56144: DOUBLE
56145: EQUAL
56146: IFTRUE 56150
56148: GO 56178
56150: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56151: LD_ADDR_OWVAR 42
56155: PUSH
56156: LD_INT 19
56158: PUSH
56159: LD_INT 23
56161: PUSH
56162: LD_INT 19
56164: PUSH
56165: EMPTY
56166: LIST
56167: LIST
56168: LIST
56169: PUSH
56170: LD_VAR 0 1
56174: ARRAY
56175: ST_TO_ADDR
56176: GO 56502
56178: LD_INT 18
56180: DOUBLE
56181: EQUAL
56182: IFTRUE 56186
56184: GO 56197
56186: POP
// bc_type := b_ext_radar ; 19 :
56187: LD_ADDR_OWVAR 42
56191: PUSH
56192: LD_INT 20
56194: ST_TO_ADDR
56195: GO 56502
56197: LD_INT 19
56199: DOUBLE
56200: EQUAL
56201: IFTRUE 56205
56203: GO 56216
56205: POP
// bc_type := b_ext_radio ; 20 :
56206: LD_ADDR_OWVAR 42
56210: PUSH
56211: LD_INT 22
56213: ST_TO_ADDR
56214: GO 56502
56216: LD_INT 20
56218: DOUBLE
56219: EQUAL
56220: IFTRUE 56224
56222: GO 56235
56224: POP
// bc_type := b_ext_siberium ; 21 :
56225: LD_ADDR_OWVAR 42
56229: PUSH
56230: LD_INT 21
56232: ST_TO_ADDR
56233: GO 56502
56235: LD_INT 21
56237: DOUBLE
56238: EQUAL
56239: IFTRUE 56243
56241: GO 56254
56243: POP
// bc_type := b_ext_computer ; 22 :
56244: LD_ADDR_OWVAR 42
56248: PUSH
56249: LD_INT 24
56251: ST_TO_ADDR
56252: GO 56502
56254: LD_INT 22
56256: DOUBLE
56257: EQUAL
56258: IFTRUE 56262
56260: GO 56273
56262: POP
// bc_type := b_ext_track ; 23 :
56263: LD_ADDR_OWVAR 42
56267: PUSH
56268: LD_INT 16
56270: ST_TO_ADDR
56271: GO 56502
56273: LD_INT 23
56275: DOUBLE
56276: EQUAL
56277: IFTRUE 56281
56279: GO 56292
56281: POP
// bc_type := b_ext_laser ; 24 :
56282: LD_ADDR_OWVAR 42
56286: PUSH
56287: LD_INT 25
56289: ST_TO_ADDR
56290: GO 56502
56292: LD_INT 24
56294: DOUBLE
56295: EQUAL
56296: IFTRUE 56300
56298: GO 56311
56300: POP
// bc_type := b_control_tower ; 25 :
56301: LD_ADDR_OWVAR 42
56305: PUSH
56306: LD_INT 36
56308: ST_TO_ADDR
56309: GO 56502
56311: LD_INT 25
56313: DOUBLE
56314: EQUAL
56315: IFTRUE 56319
56317: GO 56330
56319: POP
// bc_type := b_breastwork ; 26 :
56320: LD_ADDR_OWVAR 42
56324: PUSH
56325: LD_INT 31
56327: ST_TO_ADDR
56328: GO 56502
56330: LD_INT 26
56332: DOUBLE
56333: EQUAL
56334: IFTRUE 56338
56336: GO 56349
56338: POP
// bc_type := b_bunker ; 27 :
56339: LD_ADDR_OWVAR 42
56343: PUSH
56344: LD_INT 32
56346: ST_TO_ADDR
56347: GO 56502
56349: LD_INT 27
56351: DOUBLE
56352: EQUAL
56353: IFTRUE 56357
56355: GO 56368
56357: POP
// bc_type := b_turret ; 28 :
56358: LD_ADDR_OWVAR 42
56362: PUSH
56363: LD_INT 33
56365: ST_TO_ADDR
56366: GO 56502
56368: LD_INT 28
56370: DOUBLE
56371: EQUAL
56372: IFTRUE 56376
56374: GO 56387
56376: POP
// bc_type := b_armoury ; 29 :
56377: LD_ADDR_OWVAR 42
56381: PUSH
56382: LD_INT 4
56384: ST_TO_ADDR
56385: GO 56502
56387: LD_INT 29
56389: DOUBLE
56390: EQUAL
56391: IFTRUE 56395
56393: GO 56406
56395: POP
// bc_type := b_barracks ; 30 :
56396: LD_ADDR_OWVAR 42
56400: PUSH
56401: LD_INT 5
56403: ST_TO_ADDR
56404: GO 56502
56406: LD_INT 30
56408: DOUBLE
56409: EQUAL
56410: IFTRUE 56414
56412: GO 56425
56414: POP
// bc_type := b_solar_power ; 31 :
56415: LD_ADDR_OWVAR 42
56419: PUSH
56420: LD_INT 27
56422: ST_TO_ADDR
56423: GO 56502
56425: LD_INT 31
56427: DOUBLE
56428: EQUAL
56429: IFTRUE 56433
56431: GO 56444
56433: POP
// bc_type := b_oil_power ; 32 :
56434: LD_ADDR_OWVAR 42
56438: PUSH
56439: LD_INT 26
56441: ST_TO_ADDR
56442: GO 56502
56444: LD_INT 32
56446: DOUBLE
56447: EQUAL
56448: IFTRUE 56452
56450: GO 56463
56452: POP
// bc_type := b_siberite_power ; 33 :
56453: LD_ADDR_OWVAR 42
56457: PUSH
56458: LD_INT 28
56460: ST_TO_ADDR
56461: GO 56502
56463: LD_INT 33
56465: DOUBLE
56466: EQUAL
56467: IFTRUE 56471
56469: GO 56482
56471: POP
// bc_type := b_oil_mine ; 34 :
56472: LD_ADDR_OWVAR 42
56476: PUSH
56477: LD_INT 29
56479: ST_TO_ADDR
56480: GO 56502
56482: LD_INT 34
56484: DOUBLE
56485: EQUAL
56486: IFTRUE 56490
56488: GO 56501
56490: POP
// bc_type := b_siberite_mine ; end ;
56491: LD_ADDR_OWVAR 42
56495: PUSH
56496: LD_INT 30
56498: ST_TO_ADDR
56499: GO 56502
56501: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56502: LD_ADDR_VAR 0 8
56506: PUSH
56507: LD_VAR 0 5
56511: PPUSH
56512: LD_VAR 0 6
56516: PPUSH
56517: LD_VAR 0 3
56521: PPUSH
56522: CALL_OW 47
56526: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56527: LD_OWVAR 42
56531: PUSH
56532: LD_INT 32
56534: PUSH
56535: LD_INT 33
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: IN
56542: IFFALSE 56558
// PlaceWeaponTurret ( b , weapon ) ;
56544: LD_VAR 0 8
56548: PPUSH
56549: LD_VAR 0 4
56553: PPUSH
56554: CALL_OW 431
// end ;
56558: LD_VAR 0 7
56562: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56563: LD_INT 0
56565: PPUSH
56566: PPUSH
56567: PPUSH
56568: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56569: LD_ADDR_VAR 0 4
56573: PUSH
56574: LD_INT 22
56576: PUSH
56577: LD_OWVAR 2
56581: PUSH
56582: EMPTY
56583: LIST
56584: LIST
56585: PUSH
56586: LD_INT 2
56588: PUSH
56589: LD_INT 30
56591: PUSH
56592: LD_INT 0
56594: PUSH
56595: EMPTY
56596: LIST
56597: LIST
56598: PUSH
56599: LD_INT 30
56601: PUSH
56602: LD_INT 1
56604: PUSH
56605: EMPTY
56606: LIST
56607: LIST
56608: PUSH
56609: EMPTY
56610: LIST
56611: LIST
56612: LIST
56613: PUSH
56614: EMPTY
56615: LIST
56616: LIST
56617: PPUSH
56618: CALL_OW 69
56622: ST_TO_ADDR
// if not tmp then
56623: LD_VAR 0 4
56627: NOT
56628: IFFALSE 56632
// exit ;
56630: GO 56691
// for i in tmp do
56632: LD_ADDR_VAR 0 2
56636: PUSH
56637: LD_VAR 0 4
56641: PUSH
56642: FOR_IN
56643: IFFALSE 56689
// for j = 1 to 3 do
56645: LD_ADDR_VAR 0 3
56649: PUSH
56650: DOUBLE
56651: LD_INT 1
56653: DEC
56654: ST_TO_ADDR
56655: LD_INT 3
56657: PUSH
56658: FOR_TO
56659: IFFALSE 56685
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56661: LD_VAR 0 2
56665: PPUSH
56666: CALL_OW 274
56670: PPUSH
56671: LD_VAR 0 3
56675: PPUSH
56676: LD_INT 99999
56678: PPUSH
56679: CALL_OW 277
56683: GO 56658
56685: POP
56686: POP
56687: GO 56642
56689: POP
56690: POP
// end ;
56691: LD_VAR 0 1
56695: RET
// export function hHackSetLevel10 ; var i , j ; begin
56696: LD_INT 0
56698: PPUSH
56699: PPUSH
56700: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56701: LD_ADDR_VAR 0 2
56705: PUSH
56706: LD_INT 21
56708: PUSH
56709: LD_INT 1
56711: PUSH
56712: EMPTY
56713: LIST
56714: LIST
56715: PPUSH
56716: CALL_OW 69
56720: PUSH
56721: FOR_IN
56722: IFFALSE 56774
// if IsSelected ( i ) then
56724: LD_VAR 0 2
56728: PPUSH
56729: CALL_OW 306
56733: IFFALSE 56772
// begin for j := 1 to 4 do
56735: LD_ADDR_VAR 0 3
56739: PUSH
56740: DOUBLE
56741: LD_INT 1
56743: DEC
56744: ST_TO_ADDR
56745: LD_INT 4
56747: PUSH
56748: FOR_TO
56749: IFFALSE 56770
// SetSkill ( i , j , 10 ) ;
56751: LD_VAR 0 2
56755: PPUSH
56756: LD_VAR 0 3
56760: PPUSH
56761: LD_INT 10
56763: PPUSH
56764: CALL_OW 237
56768: GO 56748
56770: POP
56771: POP
// end ;
56772: GO 56721
56774: POP
56775: POP
// end ;
56776: LD_VAR 0 1
56780: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56781: LD_INT 0
56783: PPUSH
56784: PPUSH
56785: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56786: LD_ADDR_VAR 0 2
56790: PUSH
56791: LD_INT 22
56793: PUSH
56794: LD_OWVAR 2
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: LD_INT 21
56805: PUSH
56806: LD_INT 1
56808: PUSH
56809: EMPTY
56810: LIST
56811: LIST
56812: PUSH
56813: EMPTY
56814: LIST
56815: LIST
56816: PPUSH
56817: CALL_OW 69
56821: PUSH
56822: FOR_IN
56823: IFFALSE 56864
// begin for j := 1 to 4 do
56825: LD_ADDR_VAR 0 3
56829: PUSH
56830: DOUBLE
56831: LD_INT 1
56833: DEC
56834: ST_TO_ADDR
56835: LD_INT 4
56837: PUSH
56838: FOR_TO
56839: IFFALSE 56860
// SetSkill ( i , j , 10 ) ;
56841: LD_VAR 0 2
56845: PPUSH
56846: LD_VAR 0 3
56850: PPUSH
56851: LD_INT 10
56853: PPUSH
56854: CALL_OW 237
56858: GO 56838
56860: POP
56861: POP
// end ;
56862: GO 56822
56864: POP
56865: POP
// end ;
56866: LD_VAR 0 1
56870: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
56871: LD_INT 0
56873: PPUSH
// uc_side := your_side ;
56874: LD_ADDR_OWVAR 20
56878: PUSH
56879: LD_OWVAR 2
56883: ST_TO_ADDR
// uc_nation := nation ;
56884: LD_ADDR_OWVAR 21
56888: PUSH
56889: LD_VAR 0 1
56893: ST_TO_ADDR
// InitHc ;
56894: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
56898: LD_INT 0
56900: PPUSH
56901: LD_VAR 0 2
56905: PPUSH
56906: LD_VAR 0 3
56910: PPUSH
56911: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
56915: LD_VAR 0 4
56919: PPUSH
56920: LD_VAR 0 5
56924: PPUSH
56925: CALL_OW 428
56929: PUSH
56930: LD_INT 0
56932: EQUAL
56933: IFFALSE 56957
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
56935: CALL_OW 44
56939: PPUSH
56940: LD_VAR 0 4
56944: PPUSH
56945: LD_VAR 0 5
56949: PPUSH
56950: LD_INT 1
56952: PPUSH
56953: CALL_OW 48
// end ;
56957: LD_VAR 0 6
56961: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
56962: LD_INT 0
56964: PPUSH
56965: PPUSH
// uc_side := your_side ;
56966: LD_ADDR_OWVAR 20
56970: PUSH
56971: LD_OWVAR 2
56975: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
56976: LD_VAR 0 1
56980: PUSH
56981: LD_INT 1
56983: PUSH
56984: LD_INT 2
56986: PUSH
56987: LD_INT 3
56989: PUSH
56990: LD_INT 4
56992: PUSH
56993: LD_INT 5
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: LIST
57000: LIST
57001: LIST
57002: IN
57003: IFFALSE 57015
// uc_nation := nation_american else
57005: LD_ADDR_OWVAR 21
57009: PUSH
57010: LD_INT 1
57012: ST_TO_ADDR
57013: GO 57058
// if chassis in [ 11 , 12 , 13 , 14 ] then
57015: LD_VAR 0 1
57019: PUSH
57020: LD_INT 11
57022: PUSH
57023: LD_INT 12
57025: PUSH
57026: LD_INT 13
57028: PUSH
57029: LD_INT 14
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: LIST
57036: LIST
57037: IN
57038: IFFALSE 57050
// uc_nation := nation_arabian else
57040: LD_ADDR_OWVAR 21
57044: PUSH
57045: LD_INT 2
57047: ST_TO_ADDR
57048: GO 57058
// uc_nation := nation_russian ;
57050: LD_ADDR_OWVAR 21
57054: PUSH
57055: LD_INT 3
57057: ST_TO_ADDR
// vc_chassis := chassis ;
57058: LD_ADDR_OWVAR 37
57062: PUSH
57063: LD_VAR 0 1
57067: ST_TO_ADDR
// vc_engine := engine ;
57068: LD_ADDR_OWVAR 39
57072: PUSH
57073: LD_VAR 0 2
57077: ST_TO_ADDR
// vc_control := control ;
57078: LD_ADDR_OWVAR 38
57082: PUSH
57083: LD_VAR 0 3
57087: ST_TO_ADDR
// vc_weapon := weapon ;
57088: LD_ADDR_OWVAR 40
57092: PUSH
57093: LD_VAR 0 4
57097: ST_TO_ADDR
// un := CreateVehicle ;
57098: LD_ADDR_VAR 0 8
57102: PUSH
57103: CALL_OW 45
57107: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57108: LD_VAR 0 8
57112: PPUSH
57113: LD_INT 0
57115: PPUSH
57116: LD_INT 5
57118: PPUSH
57119: CALL_OW 12
57123: PPUSH
57124: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57128: LD_VAR 0 8
57132: PPUSH
57133: LD_VAR 0 5
57137: PPUSH
57138: LD_VAR 0 6
57142: PPUSH
57143: LD_INT 1
57145: PPUSH
57146: CALL_OW 48
// end ;
57150: LD_VAR 0 7
57154: RET
// export hInvincible ; every 1 do
57155: GO 57157
57157: DISABLE
// hInvincible := [ ] ;
57158: LD_ADDR_EXP 130
57162: PUSH
57163: EMPTY
57164: ST_TO_ADDR
57165: END
// every 10 do var i ;
57166: GO 57168
57168: DISABLE
57169: LD_INT 0
57171: PPUSH
// begin enable ;
57172: ENABLE
// if not hInvincible then
57173: LD_EXP 130
57177: NOT
57178: IFFALSE 57182
// exit ;
57180: GO 57226
// for i in hInvincible do
57182: LD_ADDR_VAR 0 1
57186: PUSH
57187: LD_EXP 130
57191: PUSH
57192: FOR_IN
57193: IFFALSE 57224
// if GetLives ( i ) < 1000 then
57195: LD_VAR 0 1
57199: PPUSH
57200: CALL_OW 256
57204: PUSH
57205: LD_INT 1000
57207: LESS
57208: IFFALSE 57222
// SetLives ( i , 1000 ) ;
57210: LD_VAR 0 1
57214: PPUSH
57215: LD_INT 1000
57217: PPUSH
57218: CALL_OW 234
57222: GO 57192
57224: POP
57225: POP
// end ;
57226: PPOPN 1
57228: END
// export function hHackInvincible ; var i ; begin
57229: LD_INT 0
57231: PPUSH
57232: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57233: LD_ADDR_VAR 0 2
57237: PUSH
57238: LD_INT 2
57240: PUSH
57241: LD_INT 21
57243: PUSH
57244: LD_INT 1
57246: PUSH
57247: EMPTY
57248: LIST
57249: LIST
57250: PUSH
57251: LD_INT 21
57253: PUSH
57254: LD_INT 2
57256: PUSH
57257: EMPTY
57258: LIST
57259: LIST
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: LIST
57265: PPUSH
57266: CALL_OW 69
57270: PUSH
57271: FOR_IN
57272: IFFALSE 57333
// if IsSelected ( i ) then
57274: LD_VAR 0 2
57278: PPUSH
57279: CALL_OW 306
57283: IFFALSE 57331
// begin if i in hInvincible then
57285: LD_VAR 0 2
57289: PUSH
57290: LD_EXP 130
57294: IN
57295: IFFALSE 57315
// hInvincible := hInvincible diff i else
57297: LD_ADDR_EXP 130
57301: PUSH
57302: LD_EXP 130
57306: PUSH
57307: LD_VAR 0 2
57311: DIFF
57312: ST_TO_ADDR
57313: GO 57331
// hInvincible := hInvincible union i ;
57315: LD_ADDR_EXP 130
57319: PUSH
57320: LD_EXP 130
57324: PUSH
57325: LD_VAR 0 2
57329: UNION
57330: ST_TO_ADDR
// end ;
57331: GO 57271
57333: POP
57334: POP
// end ;
57335: LD_VAR 0 1
57339: RET
// export function hHackInvisible ; var i , j ; begin
57340: LD_INT 0
57342: PPUSH
57343: PPUSH
57344: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57345: LD_ADDR_VAR 0 2
57349: PUSH
57350: LD_INT 21
57352: PUSH
57353: LD_INT 1
57355: PUSH
57356: EMPTY
57357: LIST
57358: LIST
57359: PPUSH
57360: CALL_OW 69
57364: PUSH
57365: FOR_IN
57366: IFFALSE 57390
// if IsSelected ( i ) then
57368: LD_VAR 0 2
57372: PPUSH
57373: CALL_OW 306
57377: IFFALSE 57388
// ComForceInvisible ( i ) ;
57379: LD_VAR 0 2
57383: PPUSH
57384: CALL_OW 496
57388: GO 57365
57390: POP
57391: POP
// end ;
57392: LD_VAR 0 1
57396: RET
// export function hHackChangeYourSide ; begin
57397: LD_INT 0
57399: PPUSH
// if your_side = 8 then
57400: LD_OWVAR 2
57404: PUSH
57405: LD_INT 8
57407: EQUAL
57408: IFFALSE 57420
// your_side := 0 else
57410: LD_ADDR_OWVAR 2
57414: PUSH
57415: LD_INT 0
57417: ST_TO_ADDR
57418: GO 57434
// your_side := your_side + 1 ;
57420: LD_ADDR_OWVAR 2
57424: PUSH
57425: LD_OWVAR 2
57429: PUSH
57430: LD_INT 1
57432: PLUS
57433: ST_TO_ADDR
// end ;
57434: LD_VAR 0 1
57438: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57439: LD_INT 0
57441: PPUSH
57442: PPUSH
57443: PPUSH
// for i in all_units do
57444: LD_ADDR_VAR 0 2
57448: PUSH
57449: LD_OWVAR 3
57453: PUSH
57454: FOR_IN
57455: IFFALSE 57533
// if IsSelected ( i ) then
57457: LD_VAR 0 2
57461: PPUSH
57462: CALL_OW 306
57466: IFFALSE 57531
// begin j := GetSide ( i ) ;
57468: LD_ADDR_VAR 0 3
57472: PUSH
57473: LD_VAR 0 2
57477: PPUSH
57478: CALL_OW 255
57482: ST_TO_ADDR
// if j = 8 then
57483: LD_VAR 0 3
57487: PUSH
57488: LD_INT 8
57490: EQUAL
57491: IFFALSE 57503
// j := 0 else
57493: LD_ADDR_VAR 0 3
57497: PUSH
57498: LD_INT 0
57500: ST_TO_ADDR
57501: GO 57517
// j := j + 1 ;
57503: LD_ADDR_VAR 0 3
57507: PUSH
57508: LD_VAR 0 3
57512: PUSH
57513: LD_INT 1
57515: PLUS
57516: ST_TO_ADDR
// SetSide ( i , j ) ;
57517: LD_VAR 0 2
57521: PPUSH
57522: LD_VAR 0 3
57526: PPUSH
57527: CALL_OW 235
// end ;
57531: GO 57454
57533: POP
57534: POP
// end ;
57535: LD_VAR 0 1
57539: RET
// export function hHackFog ; begin
57540: LD_INT 0
57542: PPUSH
// FogOff ( true ) ;
57543: LD_INT 1
57545: PPUSH
57546: CALL_OW 344
// end ;
57550: LD_VAR 0 1
57554: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57555: LD_INT 0
57557: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57558: LD_VAR 0 1
57562: PPUSH
57563: LD_VAR 0 2
57567: PPUSH
57568: LD_VAR 0 3
57572: PPUSH
57573: LD_INT 1
57575: PPUSH
57576: LD_INT 1
57578: PPUSH
57579: CALL_OW 483
// CenterOnXY ( x , y ) ;
57583: LD_VAR 0 2
57587: PPUSH
57588: LD_VAR 0 3
57592: PPUSH
57593: CALL_OW 84
// end ;
57597: LD_VAR 0 4
57601: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57602: LD_INT 0
57604: PPUSH
57605: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57606: LD_VAR 0 1
57610: NOT
57611: PUSH
57612: LD_VAR 0 2
57616: PPUSH
57617: LD_VAR 0 3
57621: PPUSH
57622: CALL_OW 488
57626: NOT
57627: OR
57628: PUSH
57629: LD_VAR 0 1
57633: PPUSH
57634: CALL_OW 266
57638: PUSH
57639: LD_INT 3
57641: NONEQUAL
57642: PUSH
57643: LD_VAR 0 1
57647: PPUSH
57648: CALL_OW 247
57652: PUSH
57653: LD_INT 1
57655: EQUAL
57656: NOT
57657: AND
57658: OR
57659: IFFALSE 57663
// exit ;
57661: GO 57812
// if GetType ( factory ) = unit_human then
57663: LD_VAR 0 1
57667: PPUSH
57668: CALL_OW 247
57672: PUSH
57673: LD_INT 1
57675: EQUAL
57676: IFFALSE 57693
// factory := IsInUnit ( factory ) ;
57678: LD_ADDR_VAR 0 1
57682: PUSH
57683: LD_VAR 0 1
57687: PPUSH
57688: CALL_OW 310
57692: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57693: LD_VAR 0 1
57697: PPUSH
57698: CALL_OW 266
57702: PUSH
57703: LD_INT 3
57705: NONEQUAL
57706: IFFALSE 57710
// exit ;
57708: GO 57812
// if HexInfo ( x , y ) = factory then
57710: LD_VAR 0 2
57714: PPUSH
57715: LD_VAR 0 3
57719: PPUSH
57720: CALL_OW 428
57724: PUSH
57725: LD_VAR 0 1
57729: EQUAL
57730: IFFALSE 57757
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57732: LD_ADDR_EXP 131
57736: PUSH
57737: LD_EXP 131
57741: PPUSH
57742: LD_VAR 0 1
57746: PPUSH
57747: LD_INT 0
57749: PPUSH
57750: CALL_OW 1
57754: ST_TO_ADDR
57755: GO 57808
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57757: LD_ADDR_EXP 131
57761: PUSH
57762: LD_EXP 131
57766: PPUSH
57767: LD_VAR 0 1
57771: PPUSH
57772: LD_VAR 0 1
57776: PPUSH
57777: CALL_OW 255
57781: PUSH
57782: LD_VAR 0 1
57786: PUSH
57787: LD_VAR 0 2
57791: PUSH
57792: LD_VAR 0 3
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: LIST
57801: LIST
57802: PPUSH
57803: CALL_OW 1
57807: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57808: CALL 57817 0 0
// end ;
57812: LD_VAR 0 4
57816: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57817: LD_INT 0
57819: PPUSH
57820: PPUSH
57821: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57822: LD_STRING resetFactoryWaypoint();
57824: PPUSH
57825: CALL_OW 559
// if factoryWaypoints then
57829: LD_EXP 131
57833: IFFALSE 57959
// begin list := PrepareArray ( factoryWaypoints ) ;
57835: LD_ADDR_VAR 0 3
57839: PUSH
57840: LD_EXP 131
57844: PPUSH
57845: CALL 104409 0 1
57849: ST_TO_ADDR
// for i := 1 to list do
57850: LD_ADDR_VAR 0 2
57854: PUSH
57855: DOUBLE
57856: LD_INT 1
57858: DEC
57859: ST_TO_ADDR
57860: LD_VAR 0 3
57864: PUSH
57865: FOR_TO
57866: IFFALSE 57957
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
57868: LD_STRING setFactoryWaypointXY(
57870: PUSH
57871: LD_VAR 0 3
57875: PUSH
57876: LD_VAR 0 2
57880: ARRAY
57881: PUSH
57882: LD_INT 1
57884: ARRAY
57885: STR
57886: PUSH
57887: LD_STRING ,
57889: STR
57890: PUSH
57891: LD_VAR 0 3
57895: PUSH
57896: LD_VAR 0 2
57900: ARRAY
57901: PUSH
57902: LD_INT 2
57904: ARRAY
57905: STR
57906: PUSH
57907: LD_STRING ,
57909: STR
57910: PUSH
57911: LD_VAR 0 3
57915: PUSH
57916: LD_VAR 0 2
57920: ARRAY
57921: PUSH
57922: LD_INT 3
57924: ARRAY
57925: STR
57926: PUSH
57927: LD_STRING ,
57929: STR
57930: PUSH
57931: LD_VAR 0 3
57935: PUSH
57936: LD_VAR 0 2
57940: ARRAY
57941: PUSH
57942: LD_INT 4
57944: ARRAY
57945: STR
57946: PUSH
57947: LD_STRING )
57949: STR
57950: PPUSH
57951: CALL_OW 559
57955: GO 57865
57957: POP
57958: POP
// end ; end ;
57959: LD_VAR 0 1
57963: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
57964: LD_INT 0
57966: PPUSH
// if HexInfo ( x , y ) = warehouse then
57967: LD_VAR 0 2
57971: PPUSH
57972: LD_VAR 0 3
57976: PPUSH
57977: CALL_OW 428
57981: PUSH
57982: LD_VAR 0 1
57986: EQUAL
57987: IFFALSE 58014
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
57989: LD_ADDR_EXP 132
57993: PUSH
57994: LD_EXP 132
57998: PPUSH
57999: LD_VAR 0 1
58003: PPUSH
58004: LD_INT 0
58006: PPUSH
58007: CALL_OW 1
58011: ST_TO_ADDR
58012: GO 58065
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58014: LD_ADDR_EXP 132
58018: PUSH
58019: LD_EXP 132
58023: PPUSH
58024: LD_VAR 0 1
58028: PPUSH
58029: LD_VAR 0 1
58033: PPUSH
58034: CALL_OW 255
58038: PUSH
58039: LD_VAR 0 1
58043: PUSH
58044: LD_VAR 0 2
58048: PUSH
58049: LD_VAR 0 3
58053: PUSH
58054: EMPTY
58055: LIST
58056: LIST
58057: LIST
58058: LIST
58059: PPUSH
58060: CALL_OW 1
58064: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58065: CALL 58074 0 0
// end ;
58069: LD_VAR 0 4
58073: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58074: LD_INT 0
58076: PPUSH
58077: PPUSH
58078: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58079: LD_STRING resetWarehouseGatheringPoints();
58081: PPUSH
58082: CALL_OW 559
// if warehouseGatheringPoints then
58086: LD_EXP 132
58090: IFFALSE 58216
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58092: LD_ADDR_VAR 0 3
58096: PUSH
58097: LD_EXP 132
58101: PPUSH
58102: CALL 104409 0 1
58106: ST_TO_ADDR
// for i := 1 to list do
58107: LD_ADDR_VAR 0 2
58111: PUSH
58112: DOUBLE
58113: LD_INT 1
58115: DEC
58116: ST_TO_ADDR
58117: LD_VAR 0 3
58121: PUSH
58122: FOR_TO
58123: IFFALSE 58214
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58125: LD_STRING setWarehouseGatheringPointXY(
58127: PUSH
58128: LD_VAR 0 3
58132: PUSH
58133: LD_VAR 0 2
58137: ARRAY
58138: PUSH
58139: LD_INT 1
58141: ARRAY
58142: STR
58143: PUSH
58144: LD_STRING ,
58146: STR
58147: PUSH
58148: LD_VAR 0 3
58152: PUSH
58153: LD_VAR 0 2
58157: ARRAY
58158: PUSH
58159: LD_INT 2
58161: ARRAY
58162: STR
58163: PUSH
58164: LD_STRING ,
58166: STR
58167: PUSH
58168: LD_VAR 0 3
58172: PUSH
58173: LD_VAR 0 2
58177: ARRAY
58178: PUSH
58179: LD_INT 3
58181: ARRAY
58182: STR
58183: PUSH
58184: LD_STRING ,
58186: STR
58187: PUSH
58188: LD_VAR 0 3
58192: PUSH
58193: LD_VAR 0 2
58197: ARRAY
58198: PUSH
58199: LD_INT 4
58201: ARRAY
58202: STR
58203: PUSH
58204: LD_STRING )
58206: STR
58207: PPUSH
58208: CALL_OW 559
58212: GO 58122
58214: POP
58215: POP
// end ; end ;
58216: LD_VAR 0 1
58220: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58221: LD_EXP 132
58225: IFFALSE 58910
58227: GO 58229
58229: DISABLE
58230: LD_INT 0
58232: PPUSH
58233: PPUSH
58234: PPUSH
58235: PPUSH
58236: PPUSH
58237: PPUSH
58238: PPUSH
58239: PPUSH
58240: PPUSH
// begin enable ;
58241: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58242: LD_ADDR_VAR 0 3
58246: PUSH
58247: LD_EXP 132
58251: PPUSH
58252: CALL 104409 0 1
58256: ST_TO_ADDR
// if not list then
58257: LD_VAR 0 3
58261: NOT
58262: IFFALSE 58266
// exit ;
58264: GO 58910
// for i := 1 to list do
58266: LD_ADDR_VAR 0 1
58270: PUSH
58271: DOUBLE
58272: LD_INT 1
58274: DEC
58275: ST_TO_ADDR
58276: LD_VAR 0 3
58280: PUSH
58281: FOR_TO
58282: IFFALSE 58908
// begin depot := list [ i ] [ 2 ] ;
58284: LD_ADDR_VAR 0 8
58288: PUSH
58289: LD_VAR 0 3
58293: PUSH
58294: LD_VAR 0 1
58298: ARRAY
58299: PUSH
58300: LD_INT 2
58302: ARRAY
58303: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58304: LD_ADDR_VAR 0 5
58308: PUSH
58309: LD_VAR 0 3
58313: PUSH
58314: LD_VAR 0 1
58318: ARRAY
58319: PUSH
58320: LD_INT 1
58322: ARRAY
58323: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58324: LD_VAR 0 8
58328: PPUSH
58329: CALL_OW 301
58333: PUSH
58334: LD_VAR 0 5
58338: PUSH
58339: LD_VAR 0 8
58343: PPUSH
58344: CALL_OW 255
58348: NONEQUAL
58349: OR
58350: IFFALSE 58379
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58352: LD_ADDR_EXP 132
58356: PUSH
58357: LD_EXP 132
58361: PPUSH
58362: LD_VAR 0 8
58366: PPUSH
58367: LD_INT 0
58369: PPUSH
58370: CALL_OW 1
58374: ST_TO_ADDR
// exit ;
58375: POP
58376: POP
58377: GO 58910
// end ; x := list [ i ] [ 3 ] ;
58379: LD_ADDR_VAR 0 6
58383: PUSH
58384: LD_VAR 0 3
58388: PUSH
58389: LD_VAR 0 1
58393: ARRAY
58394: PUSH
58395: LD_INT 3
58397: ARRAY
58398: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58399: LD_ADDR_VAR 0 7
58403: PUSH
58404: LD_VAR 0 3
58408: PUSH
58409: LD_VAR 0 1
58413: ARRAY
58414: PUSH
58415: LD_INT 4
58417: ARRAY
58418: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58419: LD_ADDR_VAR 0 9
58423: PUSH
58424: LD_VAR 0 6
58428: PPUSH
58429: LD_VAR 0 7
58433: PPUSH
58434: LD_INT 16
58436: PPUSH
58437: CALL 102997 0 3
58441: ST_TO_ADDR
// if not cratesNearbyPoint then
58442: LD_VAR 0 9
58446: NOT
58447: IFFALSE 58453
// exit ;
58449: POP
58450: POP
58451: GO 58910
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58453: LD_ADDR_VAR 0 4
58457: PUSH
58458: LD_INT 22
58460: PUSH
58461: LD_VAR 0 5
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: PUSH
58470: LD_INT 3
58472: PUSH
58473: LD_INT 60
58475: PUSH
58476: EMPTY
58477: LIST
58478: PUSH
58479: EMPTY
58480: LIST
58481: LIST
58482: PUSH
58483: LD_INT 91
58485: PUSH
58486: LD_VAR 0 8
58490: PUSH
58491: LD_INT 6
58493: PUSH
58494: EMPTY
58495: LIST
58496: LIST
58497: LIST
58498: PUSH
58499: LD_INT 2
58501: PUSH
58502: LD_INT 25
58504: PUSH
58505: LD_INT 2
58507: PUSH
58508: EMPTY
58509: LIST
58510: LIST
58511: PUSH
58512: LD_INT 25
58514: PUSH
58515: LD_INT 16
58517: PUSH
58518: EMPTY
58519: LIST
58520: LIST
58521: PUSH
58522: EMPTY
58523: LIST
58524: LIST
58525: LIST
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: LIST
58531: LIST
58532: PPUSH
58533: CALL_OW 69
58537: PUSH
58538: LD_VAR 0 8
58542: PPUSH
58543: CALL_OW 313
58547: PPUSH
58548: LD_INT 3
58550: PUSH
58551: LD_INT 60
58553: PUSH
58554: EMPTY
58555: LIST
58556: PUSH
58557: EMPTY
58558: LIST
58559: LIST
58560: PUSH
58561: LD_INT 2
58563: PUSH
58564: LD_INT 25
58566: PUSH
58567: LD_INT 2
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: PUSH
58574: LD_INT 25
58576: PUSH
58577: LD_INT 16
58579: PUSH
58580: EMPTY
58581: LIST
58582: LIST
58583: PUSH
58584: EMPTY
58585: LIST
58586: LIST
58587: LIST
58588: PUSH
58589: EMPTY
58590: LIST
58591: LIST
58592: PPUSH
58593: CALL_OW 72
58597: UNION
58598: ST_TO_ADDR
// if tmp then
58599: LD_VAR 0 4
58603: IFFALSE 58683
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58605: LD_ADDR_VAR 0 4
58609: PUSH
58610: LD_VAR 0 4
58614: PPUSH
58615: LD_INT 3
58617: PPUSH
58618: CALL 100966 0 2
58622: ST_TO_ADDR
// for j in tmp do
58623: LD_ADDR_VAR 0 2
58627: PUSH
58628: LD_VAR 0 4
58632: PUSH
58633: FOR_IN
58634: IFFALSE 58677
// begin if IsInUnit ( j ) then
58636: LD_VAR 0 2
58640: PPUSH
58641: CALL_OW 310
58645: IFFALSE 58656
// ComExit ( j ) ;
58647: LD_VAR 0 2
58651: PPUSH
58652: CALL 101049 0 1
// AddComCollect ( j , x , y ) ;
58656: LD_VAR 0 2
58660: PPUSH
58661: LD_VAR 0 6
58665: PPUSH
58666: LD_VAR 0 7
58670: PPUSH
58671: CALL_OW 177
// end ;
58675: GO 58633
58677: POP
58678: POP
// exit ;
58679: POP
58680: POP
58681: GO 58910
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58683: LD_ADDR_VAR 0 4
58687: PUSH
58688: LD_INT 22
58690: PUSH
58691: LD_VAR 0 5
58695: PUSH
58696: EMPTY
58697: LIST
58698: LIST
58699: PUSH
58700: LD_INT 91
58702: PUSH
58703: LD_VAR 0 8
58707: PUSH
58708: LD_INT 8
58710: PUSH
58711: EMPTY
58712: LIST
58713: LIST
58714: LIST
58715: PUSH
58716: LD_INT 2
58718: PUSH
58719: LD_INT 34
58721: PUSH
58722: LD_INT 12
58724: PUSH
58725: EMPTY
58726: LIST
58727: LIST
58728: PUSH
58729: LD_INT 34
58731: PUSH
58732: LD_INT 51
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: PUSH
58739: LD_INT 34
58741: PUSH
58742: LD_INT 32
58744: PUSH
58745: EMPTY
58746: LIST
58747: LIST
58748: PUSH
58749: LD_INT 34
58751: PUSH
58752: LD_INT 89
58754: PUSH
58755: EMPTY
58756: LIST
58757: LIST
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: LIST
58763: LIST
58764: LIST
58765: PUSH
58766: EMPTY
58767: LIST
58768: LIST
58769: LIST
58770: PPUSH
58771: CALL_OW 69
58775: ST_TO_ADDR
// if tmp then
58776: LD_VAR 0 4
58780: IFFALSE 58906
// begin for j in tmp do
58782: LD_ADDR_VAR 0 2
58786: PUSH
58787: LD_VAR 0 4
58791: PUSH
58792: FOR_IN
58793: IFFALSE 58904
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58795: LD_VAR 0 2
58799: PPUSH
58800: CALL_OW 262
58804: PUSH
58805: LD_INT 3
58807: EQUAL
58808: PUSH
58809: LD_VAR 0 2
58813: PPUSH
58814: CALL_OW 261
58818: PUSH
58819: LD_INT 20
58821: GREATER
58822: OR
58823: PUSH
58824: LD_VAR 0 2
58828: PPUSH
58829: CALL_OW 314
58833: NOT
58834: AND
58835: PUSH
58836: LD_VAR 0 2
58840: PPUSH
58841: CALL_OW 263
58845: PUSH
58846: LD_INT 1
58848: NONEQUAL
58849: PUSH
58850: LD_VAR 0 2
58854: PPUSH
58855: CALL_OW 311
58859: OR
58860: AND
58861: IFFALSE 58902
// begin ComCollect ( j , x , y ) ;
58863: LD_VAR 0 2
58867: PPUSH
58868: LD_VAR 0 6
58872: PPUSH
58873: LD_VAR 0 7
58877: PPUSH
58878: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
58882: LD_VAR 0 2
58886: PPUSH
58887: LD_VAR 0 8
58891: PPUSH
58892: CALL_OW 172
// exit ;
58896: POP
58897: POP
58898: POP
58899: POP
58900: GO 58910
// end ;
58902: GO 58792
58904: POP
58905: POP
// end ; end ;
58906: GO 58281
58908: POP
58909: POP
// end ; end_of_file
58910: PPOPN 9
58912: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
58913: LD_INT 0
58915: PPUSH
58916: PPUSH
58917: PPUSH
58918: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
58919: LD_VAR 0 1
58923: PPUSH
58924: CALL_OW 264
58928: PUSH
58929: LD_INT 91
58931: EQUAL
58932: IFFALSE 59004
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
58934: LD_INT 68
58936: PPUSH
58937: LD_VAR 0 1
58941: PPUSH
58942: CALL_OW 255
58946: PPUSH
58947: CALL_OW 321
58951: PUSH
58952: LD_INT 2
58954: EQUAL
58955: IFFALSE 58967
// eff := 70 else
58957: LD_ADDR_VAR 0 4
58961: PUSH
58962: LD_INT 70
58964: ST_TO_ADDR
58965: GO 58975
// eff := 30 ;
58967: LD_ADDR_VAR 0 4
58971: PUSH
58972: LD_INT 30
58974: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
58975: LD_VAR 0 1
58979: PPUSH
58980: CALL_OW 250
58984: PPUSH
58985: LD_VAR 0 1
58989: PPUSH
58990: CALL_OW 251
58994: PPUSH
58995: LD_VAR 0 4
58999: PPUSH
59000: CALL_OW 495
// end ; end ;
59004: LD_VAR 0 2
59008: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59009: LD_INT 0
59011: PPUSH
// end ;
59012: LD_VAR 0 4
59016: RET
// export function SOS_Command ( cmd ) ; begin
59017: LD_INT 0
59019: PPUSH
// end ;
59020: LD_VAR 0 2
59024: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59025: LD_INT 0
59027: PPUSH
// end ;
59028: LD_VAR 0 6
59032: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59033: LD_INT 0
59035: PPUSH
59036: PPUSH
// if not vehicle or not factory then
59037: LD_VAR 0 1
59041: NOT
59042: PUSH
59043: LD_VAR 0 2
59047: NOT
59048: OR
59049: IFFALSE 59053
// exit ;
59051: GO 59284
// if factoryWaypoints >= factory then
59053: LD_EXP 131
59057: PUSH
59058: LD_VAR 0 2
59062: GREATEREQUAL
59063: IFFALSE 59284
// if factoryWaypoints [ factory ] then
59065: LD_EXP 131
59069: PUSH
59070: LD_VAR 0 2
59074: ARRAY
59075: IFFALSE 59284
// begin if GetControl ( vehicle ) = control_manual then
59077: LD_VAR 0 1
59081: PPUSH
59082: CALL_OW 263
59086: PUSH
59087: LD_INT 1
59089: EQUAL
59090: IFFALSE 59171
// begin driver := IsDrivenBy ( vehicle ) ;
59092: LD_ADDR_VAR 0 4
59096: PUSH
59097: LD_VAR 0 1
59101: PPUSH
59102: CALL_OW 311
59106: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59107: LD_VAR 0 4
59111: PPUSH
59112: LD_EXP 131
59116: PUSH
59117: LD_VAR 0 2
59121: ARRAY
59122: PUSH
59123: LD_INT 3
59125: ARRAY
59126: PPUSH
59127: LD_EXP 131
59131: PUSH
59132: LD_VAR 0 2
59136: ARRAY
59137: PUSH
59138: LD_INT 4
59140: ARRAY
59141: PPUSH
59142: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59146: LD_VAR 0 4
59150: PPUSH
59151: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59155: LD_VAR 0 4
59159: PPUSH
59160: LD_VAR 0 2
59164: PPUSH
59165: CALL_OW 180
// end else
59169: GO 59284
// if GetControl ( vehicle ) = control_remote then
59171: LD_VAR 0 1
59175: PPUSH
59176: CALL_OW 263
59180: PUSH
59181: LD_INT 2
59183: EQUAL
59184: IFFALSE 59245
// begin wait ( 0 0$2 ) ;
59186: LD_INT 70
59188: PPUSH
59189: CALL_OW 67
// if Connect ( vehicle ) then
59193: LD_VAR 0 1
59197: PPUSH
59198: CALL 71308 0 1
59202: IFFALSE 59243
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59204: LD_VAR 0 1
59208: PPUSH
59209: LD_EXP 131
59213: PUSH
59214: LD_VAR 0 2
59218: ARRAY
59219: PUSH
59220: LD_INT 3
59222: ARRAY
59223: PPUSH
59224: LD_EXP 131
59228: PUSH
59229: LD_VAR 0 2
59233: ARRAY
59234: PUSH
59235: LD_INT 4
59237: ARRAY
59238: PPUSH
59239: CALL_OW 171
// end else
59243: GO 59284
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59245: LD_VAR 0 1
59249: PPUSH
59250: LD_EXP 131
59254: PUSH
59255: LD_VAR 0 2
59259: ARRAY
59260: PUSH
59261: LD_INT 3
59263: ARRAY
59264: PPUSH
59265: LD_EXP 131
59269: PUSH
59270: LD_VAR 0 2
59274: ARRAY
59275: PUSH
59276: LD_INT 4
59278: ARRAY
59279: PPUSH
59280: CALL_OW 171
// end ; end ;
59284: LD_VAR 0 3
59288: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59289: LD_INT 0
59291: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59292: LD_VAR 0 1
59296: PUSH
59297: LD_INT 250
59299: EQUAL
59300: PUSH
59301: LD_VAR 0 2
59305: PPUSH
59306: CALL_OW 264
59310: PUSH
59311: LD_INT 81
59313: EQUAL
59314: AND
59315: IFFALSE 59336
// MinerPlaceMine ( unit , x , y ) ;
59317: LD_VAR 0 2
59321: PPUSH
59322: LD_VAR 0 4
59326: PPUSH
59327: LD_VAR 0 5
59331: PPUSH
59332: CALL 61721 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59336: LD_VAR 0 1
59340: PUSH
59341: LD_INT 251
59343: EQUAL
59344: PUSH
59345: LD_VAR 0 2
59349: PPUSH
59350: CALL_OW 264
59354: PUSH
59355: LD_INT 81
59357: EQUAL
59358: AND
59359: IFFALSE 59380
// MinerDetonateMine ( unit , x , y ) ;
59361: LD_VAR 0 2
59365: PPUSH
59366: LD_VAR 0 4
59370: PPUSH
59371: LD_VAR 0 5
59375: PPUSH
59376: CALL 61996 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59380: LD_VAR 0 1
59384: PUSH
59385: LD_INT 252
59387: EQUAL
59388: PUSH
59389: LD_VAR 0 2
59393: PPUSH
59394: CALL_OW 264
59398: PUSH
59399: LD_INT 81
59401: EQUAL
59402: AND
59403: IFFALSE 59424
// MinerCreateMinefield ( unit , x , y ) ;
59405: LD_VAR 0 2
59409: PPUSH
59410: LD_VAR 0 4
59414: PPUSH
59415: LD_VAR 0 5
59419: PPUSH
59420: CALL 62413 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59424: LD_VAR 0 1
59428: PUSH
59429: LD_INT 253
59431: EQUAL
59432: PUSH
59433: LD_VAR 0 2
59437: PPUSH
59438: CALL_OW 257
59442: PUSH
59443: LD_INT 5
59445: EQUAL
59446: AND
59447: IFFALSE 59468
// ComBinocular ( unit , x , y ) ;
59449: LD_VAR 0 2
59453: PPUSH
59454: LD_VAR 0 4
59458: PPUSH
59459: LD_VAR 0 5
59463: PPUSH
59464: CALL 62782 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59468: LD_VAR 0 1
59472: PUSH
59473: LD_INT 254
59475: EQUAL
59476: PUSH
59477: LD_VAR 0 2
59481: PPUSH
59482: CALL_OW 264
59486: PUSH
59487: LD_INT 99
59489: EQUAL
59490: AND
59491: PUSH
59492: LD_VAR 0 3
59496: PPUSH
59497: CALL_OW 263
59501: PUSH
59502: LD_INT 3
59504: EQUAL
59505: AND
59506: IFFALSE 59522
// HackDestroyVehicle ( unit , selectedUnit ) ;
59508: LD_VAR 0 2
59512: PPUSH
59513: LD_VAR 0 3
59517: PPUSH
59518: CALL 61085 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59522: LD_VAR 0 1
59526: PUSH
59527: LD_INT 255
59529: EQUAL
59530: PUSH
59531: LD_VAR 0 2
59535: PPUSH
59536: CALL_OW 264
59540: PUSH
59541: LD_INT 14
59543: PUSH
59544: LD_INT 53
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: IN
59551: AND
59552: PUSH
59553: LD_VAR 0 4
59557: PPUSH
59558: LD_VAR 0 5
59562: PPUSH
59563: CALL_OW 488
59567: AND
59568: IFFALSE 59592
// CutTreeXYR ( unit , x , y , 12 ) ;
59570: LD_VAR 0 2
59574: PPUSH
59575: LD_VAR 0 4
59579: PPUSH
59580: LD_VAR 0 5
59584: PPUSH
59585: LD_INT 12
59587: PPUSH
59588: CALL 59655 0 4
// if cmd = 256 then
59592: LD_VAR 0 1
59596: PUSH
59597: LD_INT 256
59599: EQUAL
59600: IFFALSE 59621
// SetFactoryWaypoint ( unit , x , y ) ;
59602: LD_VAR 0 2
59606: PPUSH
59607: LD_VAR 0 4
59611: PPUSH
59612: LD_VAR 0 5
59616: PPUSH
59617: CALL 57602 0 3
// if cmd = 257 then
59621: LD_VAR 0 1
59625: PUSH
59626: LD_INT 257
59628: EQUAL
59629: IFFALSE 59650
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59631: LD_VAR 0 2
59635: PPUSH
59636: LD_VAR 0 4
59640: PPUSH
59641: LD_VAR 0 5
59645: PPUSH
59646: CALL 57964 0 3
// end ;
59650: LD_VAR 0 6
59654: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59655: LD_INT 0
59657: PPUSH
59658: PPUSH
59659: PPUSH
59660: PPUSH
59661: PPUSH
59662: PPUSH
59663: PPUSH
59664: PPUSH
59665: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59666: LD_VAR 0 1
59670: NOT
59671: PUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: LD_VAR 0 3
59681: PPUSH
59682: CALL_OW 488
59686: NOT
59687: OR
59688: PUSH
59689: LD_VAR 0 4
59693: NOT
59694: OR
59695: IFFALSE 59699
// exit ;
59697: GO 60039
// list := [ ] ;
59699: LD_ADDR_VAR 0 13
59703: PUSH
59704: EMPTY
59705: ST_TO_ADDR
// if x - r < 0 then
59706: LD_VAR 0 2
59710: PUSH
59711: LD_VAR 0 4
59715: MINUS
59716: PUSH
59717: LD_INT 0
59719: LESS
59720: IFFALSE 59732
// min_x := 0 else
59722: LD_ADDR_VAR 0 7
59726: PUSH
59727: LD_INT 0
59729: ST_TO_ADDR
59730: GO 59748
// min_x := x - r ;
59732: LD_ADDR_VAR 0 7
59736: PUSH
59737: LD_VAR 0 2
59741: PUSH
59742: LD_VAR 0 4
59746: MINUS
59747: ST_TO_ADDR
// if y - r < 0 then
59748: LD_VAR 0 3
59752: PUSH
59753: LD_VAR 0 4
59757: MINUS
59758: PUSH
59759: LD_INT 0
59761: LESS
59762: IFFALSE 59774
// min_y := 0 else
59764: LD_ADDR_VAR 0 8
59768: PUSH
59769: LD_INT 0
59771: ST_TO_ADDR
59772: GO 59790
// min_y := y - r ;
59774: LD_ADDR_VAR 0 8
59778: PUSH
59779: LD_VAR 0 3
59783: PUSH
59784: LD_VAR 0 4
59788: MINUS
59789: ST_TO_ADDR
// max_x := x + r ;
59790: LD_ADDR_VAR 0 9
59794: PUSH
59795: LD_VAR 0 2
59799: PUSH
59800: LD_VAR 0 4
59804: PLUS
59805: ST_TO_ADDR
// max_y := y + r ;
59806: LD_ADDR_VAR 0 10
59810: PUSH
59811: LD_VAR 0 3
59815: PUSH
59816: LD_VAR 0 4
59820: PLUS
59821: ST_TO_ADDR
// for _x = min_x to max_x do
59822: LD_ADDR_VAR 0 11
59826: PUSH
59827: DOUBLE
59828: LD_VAR 0 7
59832: DEC
59833: ST_TO_ADDR
59834: LD_VAR 0 9
59838: PUSH
59839: FOR_TO
59840: IFFALSE 59957
// for _y = min_y to max_y do
59842: LD_ADDR_VAR 0 12
59846: PUSH
59847: DOUBLE
59848: LD_VAR 0 8
59852: DEC
59853: ST_TO_ADDR
59854: LD_VAR 0 10
59858: PUSH
59859: FOR_TO
59860: IFFALSE 59953
// begin if not ValidHex ( _x , _y ) then
59862: LD_VAR 0 11
59866: PPUSH
59867: LD_VAR 0 12
59871: PPUSH
59872: CALL_OW 488
59876: NOT
59877: IFFALSE 59881
// continue ;
59879: GO 59859
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59881: LD_VAR 0 11
59885: PPUSH
59886: LD_VAR 0 12
59890: PPUSH
59891: CALL_OW 351
59895: PUSH
59896: LD_VAR 0 11
59900: PPUSH
59901: LD_VAR 0 12
59905: PPUSH
59906: CALL_OW 554
59910: AND
59911: IFFALSE 59951
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
59913: LD_ADDR_VAR 0 13
59917: PUSH
59918: LD_VAR 0 13
59922: PPUSH
59923: LD_VAR 0 13
59927: PUSH
59928: LD_INT 1
59930: PLUS
59931: PPUSH
59932: LD_VAR 0 11
59936: PUSH
59937: LD_VAR 0 12
59941: PUSH
59942: EMPTY
59943: LIST
59944: LIST
59945: PPUSH
59946: CALL_OW 2
59950: ST_TO_ADDR
// end ;
59951: GO 59859
59953: POP
59954: POP
59955: GO 59839
59957: POP
59958: POP
// if not list then
59959: LD_VAR 0 13
59963: NOT
59964: IFFALSE 59968
// exit ;
59966: GO 60039
// for i in list do
59968: LD_ADDR_VAR 0 6
59972: PUSH
59973: LD_VAR 0 13
59977: PUSH
59978: FOR_IN
59979: IFFALSE 60037
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
59981: LD_VAR 0 1
59985: PPUSH
59986: LD_STRING M
59988: PUSH
59989: LD_VAR 0 6
59993: PUSH
59994: LD_INT 1
59996: ARRAY
59997: PUSH
59998: LD_VAR 0 6
60002: PUSH
60003: LD_INT 2
60005: ARRAY
60006: PUSH
60007: LD_INT 0
60009: PUSH
60010: LD_INT 0
60012: PUSH
60013: LD_INT 0
60015: PUSH
60016: LD_INT 0
60018: PUSH
60019: EMPTY
60020: LIST
60021: LIST
60022: LIST
60023: LIST
60024: LIST
60025: LIST
60026: LIST
60027: PUSH
60028: EMPTY
60029: LIST
60030: PPUSH
60031: CALL_OW 447
60035: GO 59978
60037: POP
60038: POP
// end ;
60039: LD_VAR 0 5
60043: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60044: LD_EXP 134
60048: NOT
60049: IFFALSE 60099
60051: GO 60053
60053: DISABLE
// begin initHack := true ;
60054: LD_ADDR_EXP 134
60058: PUSH
60059: LD_INT 1
60061: ST_TO_ADDR
// hackTanks := [ ] ;
60062: LD_ADDR_EXP 135
60066: PUSH
60067: EMPTY
60068: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60069: LD_ADDR_EXP 136
60073: PUSH
60074: EMPTY
60075: ST_TO_ADDR
// hackLimit := 3 ;
60076: LD_ADDR_EXP 137
60080: PUSH
60081: LD_INT 3
60083: ST_TO_ADDR
// hackDist := 12 ;
60084: LD_ADDR_EXP 138
60088: PUSH
60089: LD_INT 12
60091: ST_TO_ADDR
// hackCounter := [ ] ;
60092: LD_ADDR_EXP 139
60096: PUSH
60097: EMPTY
60098: ST_TO_ADDR
// end ;
60099: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60100: LD_EXP 134
60104: PUSH
60105: LD_INT 34
60107: PUSH
60108: LD_INT 99
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PPUSH
60115: CALL_OW 69
60119: AND
60120: IFFALSE 60373
60122: GO 60124
60124: DISABLE
60125: LD_INT 0
60127: PPUSH
60128: PPUSH
// begin enable ;
60129: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60130: LD_ADDR_VAR 0 1
60134: PUSH
60135: LD_INT 34
60137: PUSH
60138: LD_INT 99
60140: PUSH
60141: EMPTY
60142: LIST
60143: LIST
60144: PPUSH
60145: CALL_OW 69
60149: PUSH
60150: FOR_IN
60151: IFFALSE 60371
// begin if not i in hackTanks then
60153: LD_VAR 0 1
60157: PUSH
60158: LD_EXP 135
60162: IN
60163: NOT
60164: IFFALSE 60247
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60166: LD_ADDR_EXP 135
60170: PUSH
60171: LD_EXP 135
60175: PPUSH
60176: LD_EXP 135
60180: PUSH
60181: LD_INT 1
60183: PLUS
60184: PPUSH
60185: LD_VAR 0 1
60189: PPUSH
60190: CALL_OW 1
60194: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60195: LD_ADDR_EXP 136
60199: PUSH
60200: LD_EXP 136
60204: PPUSH
60205: LD_EXP 136
60209: PUSH
60210: LD_INT 1
60212: PLUS
60213: PPUSH
60214: EMPTY
60215: PPUSH
60216: CALL_OW 1
60220: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60221: LD_ADDR_EXP 139
60225: PUSH
60226: LD_EXP 139
60230: PPUSH
60231: LD_EXP 139
60235: PUSH
60236: LD_INT 1
60238: PLUS
60239: PPUSH
60240: EMPTY
60241: PPUSH
60242: CALL_OW 1
60246: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60247: LD_VAR 0 1
60251: PPUSH
60252: CALL_OW 302
60256: NOT
60257: IFFALSE 60270
// begin HackUnlinkAll ( i ) ;
60259: LD_VAR 0 1
60263: PPUSH
60264: CALL 60376 0 1
// continue ;
60268: GO 60150
// end ; HackCheckCapturedStatus ( i ) ;
60270: LD_VAR 0 1
60274: PPUSH
60275: CALL 60819 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60279: LD_ADDR_VAR 0 2
60283: PUSH
60284: LD_INT 81
60286: PUSH
60287: LD_VAR 0 1
60291: PPUSH
60292: CALL_OW 255
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PUSH
60301: LD_INT 33
60303: PUSH
60304: LD_INT 3
60306: PUSH
60307: EMPTY
60308: LIST
60309: LIST
60310: PUSH
60311: LD_INT 91
60313: PUSH
60314: LD_VAR 0 1
60318: PUSH
60319: LD_EXP 138
60323: PUSH
60324: EMPTY
60325: LIST
60326: LIST
60327: LIST
60328: PUSH
60329: LD_INT 50
60331: PUSH
60332: EMPTY
60333: LIST
60334: PUSH
60335: EMPTY
60336: LIST
60337: LIST
60338: LIST
60339: LIST
60340: PPUSH
60341: CALL_OW 69
60345: ST_TO_ADDR
// if not tmp then
60346: LD_VAR 0 2
60350: NOT
60351: IFFALSE 60355
// continue ;
60353: GO 60150
// HackLink ( i , tmp ) ;
60355: LD_VAR 0 1
60359: PPUSH
60360: LD_VAR 0 2
60364: PPUSH
60365: CALL 60512 0 2
// end ;
60369: GO 60150
60371: POP
60372: POP
// end ;
60373: PPOPN 2
60375: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60376: LD_INT 0
60378: PPUSH
60379: PPUSH
60380: PPUSH
// if not hack in hackTanks then
60381: LD_VAR 0 1
60385: PUSH
60386: LD_EXP 135
60390: IN
60391: NOT
60392: IFFALSE 60396
// exit ;
60394: GO 60507
// index := GetElementIndex ( hackTanks , hack ) ;
60396: LD_ADDR_VAR 0 4
60400: PUSH
60401: LD_EXP 135
60405: PPUSH
60406: LD_VAR 0 1
60410: PPUSH
60411: CALL 68124 0 2
60415: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60416: LD_EXP 136
60420: PUSH
60421: LD_VAR 0 4
60425: ARRAY
60426: IFFALSE 60507
// begin for i in hackTanksCaptured [ index ] do
60428: LD_ADDR_VAR 0 3
60432: PUSH
60433: LD_EXP 136
60437: PUSH
60438: LD_VAR 0 4
60442: ARRAY
60443: PUSH
60444: FOR_IN
60445: IFFALSE 60471
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60447: LD_VAR 0 3
60451: PUSH
60452: LD_INT 1
60454: ARRAY
60455: PPUSH
60456: LD_VAR 0 3
60460: PUSH
60461: LD_INT 2
60463: ARRAY
60464: PPUSH
60465: CALL_OW 235
60469: GO 60444
60471: POP
60472: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60473: LD_ADDR_EXP 136
60477: PUSH
60478: LD_EXP 136
60482: PPUSH
60483: LD_VAR 0 4
60487: PPUSH
60488: EMPTY
60489: PPUSH
60490: CALL_OW 1
60494: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60495: LD_VAR 0 1
60499: PPUSH
60500: LD_INT 0
60502: PPUSH
60503: CALL_OW 505
// end ; end ;
60507: LD_VAR 0 2
60511: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60512: LD_INT 0
60514: PPUSH
60515: PPUSH
60516: PPUSH
// if not hack in hackTanks or not vehicles then
60517: LD_VAR 0 1
60521: PUSH
60522: LD_EXP 135
60526: IN
60527: NOT
60528: PUSH
60529: LD_VAR 0 2
60533: NOT
60534: OR
60535: IFFALSE 60539
// exit ;
60537: GO 60814
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60539: LD_ADDR_VAR 0 2
60543: PUSH
60544: LD_VAR 0 1
60548: PPUSH
60549: LD_VAR 0 2
60553: PPUSH
60554: LD_INT 1
60556: PPUSH
60557: LD_INT 1
60559: PPUSH
60560: CALL 68774 0 4
60564: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60565: LD_ADDR_VAR 0 5
60569: PUSH
60570: LD_EXP 135
60574: PPUSH
60575: LD_VAR 0 1
60579: PPUSH
60580: CALL 68124 0 2
60584: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60585: LD_EXP 136
60589: PUSH
60590: LD_VAR 0 5
60594: ARRAY
60595: PUSH
60596: LD_EXP 137
60600: LESS
60601: IFFALSE 60790
// begin for i := 1 to vehicles do
60603: LD_ADDR_VAR 0 4
60607: PUSH
60608: DOUBLE
60609: LD_INT 1
60611: DEC
60612: ST_TO_ADDR
60613: LD_VAR 0 2
60617: PUSH
60618: FOR_TO
60619: IFFALSE 60788
// begin if hackTanksCaptured [ index ] = hackLimit then
60621: LD_EXP 136
60625: PUSH
60626: LD_VAR 0 5
60630: ARRAY
60631: PUSH
60632: LD_EXP 137
60636: EQUAL
60637: IFFALSE 60641
// break ;
60639: GO 60788
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60641: LD_ADDR_EXP 139
60645: PUSH
60646: LD_EXP 139
60650: PPUSH
60651: LD_VAR 0 5
60655: PPUSH
60656: LD_EXP 139
60660: PUSH
60661: LD_VAR 0 5
60665: ARRAY
60666: PUSH
60667: LD_INT 1
60669: PLUS
60670: PPUSH
60671: CALL_OW 1
60675: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60676: LD_ADDR_EXP 136
60680: PUSH
60681: LD_EXP 136
60685: PPUSH
60686: LD_VAR 0 5
60690: PUSH
60691: LD_EXP 136
60695: PUSH
60696: LD_VAR 0 5
60700: ARRAY
60701: PUSH
60702: LD_INT 1
60704: PLUS
60705: PUSH
60706: EMPTY
60707: LIST
60708: LIST
60709: PPUSH
60710: LD_VAR 0 2
60714: PUSH
60715: LD_VAR 0 4
60719: ARRAY
60720: PUSH
60721: LD_VAR 0 2
60725: PUSH
60726: LD_VAR 0 4
60730: ARRAY
60731: PPUSH
60732: CALL_OW 255
60736: PUSH
60737: EMPTY
60738: LIST
60739: LIST
60740: PPUSH
60741: CALL 68339 0 3
60745: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60746: LD_VAR 0 2
60750: PUSH
60751: LD_VAR 0 4
60755: ARRAY
60756: PPUSH
60757: LD_VAR 0 1
60761: PPUSH
60762: CALL_OW 255
60766: PPUSH
60767: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60771: LD_VAR 0 2
60775: PUSH
60776: LD_VAR 0 4
60780: ARRAY
60781: PPUSH
60782: CALL_OW 141
// end ;
60786: GO 60618
60788: POP
60789: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60790: LD_VAR 0 1
60794: PPUSH
60795: LD_EXP 136
60799: PUSH
60800: LD_VAR 0 5
60804: ARRAY
60805: PUSH
60806: LD_INT 0
60808: PLUS
60809: PPUSH
60810: CALL_OW 505
// end ;
60814: LD_VAR 0 3
60818: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60819: LD_INT 0
60821: PPUSH
60822: PPUSH
60823: PPUSH
60824: PPUSH
// if not hack in hackTanks then
60825: LD_VAR 0 1
60829: PUSH
60830: LD_EXP 135
60834: IN
60835: NOT
60836: IFFALSE 60840
// exit ;
60838: GO 61080
// index := GetElementIndex ( hackTanks , hack ) ;
60840: LD_ADDR_VAR 0 4
60844: PUSH
60845: LD_EXP 135
60849: PPUSH
60850: LD_VAR 0 1
60854: PPUSH
60855: CALL 68124 0 2
60859: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60860: LD_ADDR_VAR 0 3
60864: PUSH
60865: DOUBLE
60866: LD_EXP 136
60870: PUSH
60871: LD_VAR 0 4
60875: ARRAY
60876: INC
60877: ST_TO_ADDR
60878: LD_INT 1
60880: PUSH
60881: FOR_DOWNTO
60882: IFFALSE 61054
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60884: LD_ADDR_VAR 0 5
60888: PUSH
60889: LD_EXP 136
60893: PUSH
60894: LD_VAR 0 4
60898: ARRAY
60899: PUSH
60900: LD_VAR 0 3
60904: ARRAY
60905: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
60906: LD_VAR 0 5
60910: PUSH
60911: LD_INT 1
60913: ARRAY
60914: PPUSH
60915: CALL_OW 302
60919: NOT
60920: PUSH
60921: LD_VAR 0 5
60925: PUSH
60926: LD_INT 1
60928: ARRAY
60929: PPUSH
60930: CALL_OW 255
60934: PUSH
60935: LD_VAR 0 1
60939: PPUSH
60940: CALL_OW 255
60944: NONEQUAL
60945: OR
60946: IFFALSE 61052
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
60948: LD_VAR 0 5
60952: PUSH
60953: LD_INT 1
60955: ARRAY
60956: PPUSH
60957: CALL_OW 305
60961: PUSH
60962: LD_VAR 0 5
60966: PUSH
60967: LD_INT 1
60969: ARRAY
60970: PPUSH
60971: CALL_OW 255
60975: PUSH
60976: LD_VAR 0 1
60980: PPUSH
60981: CALL_OW 255
60985: EQUAL
60986: AND
60987: IFFALSE 61011
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
60989: LD_VAR 0 5
60993: PUSH
60994: LD_INT 1
60996: ARRAY
60997: PPUSH
60998: LD_VAR 0 5
61002: PUSH
61003: LD_INT 2
61005: ARRAY
61006: PPUSH
61007: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61011: LD_ADDR_EXP 136
61015: PUSH
61016: LD_EXP 136
61020: PPUSH
61021: LD_VAR 0 4
61025: PPUSH
61026: LD_EXP 136
61030: PUSH
61031: LD_VAR 0 4
61035: ARRAY
61036: PPUSH
61037: LD_VAR 0 3
61041: PPUSH
61042: CALL_OW 3
61046: PPUSH
61047: CALL_OW 1
61051: ST_TO_ADDR
// end ; end ;
61052: GO 60881
61054: POP
61055: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61056: LD_VAR 0 1
61060: PPUSH
61061: LD_EXP 136
61065: PUSH
61066: LD_VAR 0 4
61070: ARRAY
61071: PUSH
61072: LD_INT 0
61074: PLUS
61075: PPUSH
61076: CALL_OW 505
// end ;
61080: LD_VAR 0 2
61084: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61085: LD_INT 0
61087: PPUSH
61088: PPUSH
61089: PPUSH
61090: PPUSH
// if not hack in hackTanks then
61091: LD_VAR 0 1
61095: PUSH
61096: LD_EXP 135
61100: IN
61101: NOT
61102: IFFALSE 61106
// exit ;
61104: GO 61191
// index := GetElementIndex ( hackTanks , hack ) ;
61106: LD_ADDR_VAR 0 5
61110: PUSH
61111: LD_EXP 135
61115: PPUSH
61116: LD_VAR 0 1
61120: PPUSH
61121: CALL 68124 0 2
61125: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61126: LD_ADDR_VAR 0 4
61130: PUSH
61131: DOUBLE
61132: LD_INT 1
61134: DEC
61135: ST_TO_ADDR
61136: LD_EXP 136
61140: PUSH
61141: LD_VAR 0 5
61145: ARRAY
61146: PUSH
61147: FOR_TO
61148: IFFALSE 61189
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61150: LD_EXP 136
61154: PUSH
61155: LD_VAR 0 5
61159: ARRAY
61160: PUSH
61161: LD_VAR 0 4
61165: ARRAY
61166: PUSH
61167: LD_INT 1
61169: ARRAY
61170: PUSH
61171: LD_VAR 0 2
61175: EQUAL
61176: IFFALSE 61187
// KillUnit ( vehicle ) ;
61178: LD_VAR 0 2
61182: PPUSH
61183: CALL_OW 66
61187: GO 61147
61189: POP
61190: POP
// end ;
61191: LD_VAR 0 3
61195: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61196: LD_EXP 140
61200: NOT
61201: IFFALSE 61236
61203: GO 61205
61205: DISABLE
// begin initMiner := true ;
61206: LD_ADDR_EXP 140
61210: PUSH
61211: LD_INT 1
61213: ST_TO_ADDR
// minersList := [ ] ;
61214: LD_ADDR_EXP 141
61218: PUSH
61219: EMPTY
61220: ST_TO_ADDR
// minerMinesList := [ ] ;
61221: LD_ADDR_EXP 142
61225: PUSH
61226: EMPTY
61227: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61228: LD_ADDR_EXP 143
61232: PUSH
61233: LD_INT 5
61235: ST_TO_ADDR
// end ;
61236: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61237: LD_EXP 140
61241: PUSH
61242: LD_INT 34
61244: PUSH
61245: LD_INT 81
61247: PUSH
61248: EMPTY
61249: LIST
61250: LIST
61251: PPUSH
61252: CALL_OW 69
61256: AND
61257: IFFALSE 61718
61259: GO 61261
61261: DISABLE
61262: LD_INT 0
61264: PPUSH
61265: PPUSH
61266: PPUSH
61267: PPUSH
// begin enable ;
61268: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61269: LD_ADDR_VAR 0 1
61273: PUSH
61274: LD_INT 34
61276: PUSH
61277: LD_INT 81
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PPUSH
61284: CALL_OW 69
61288: PUSH
61289: FOR_IN
61290: IFFALSE 61362
// begin if not i in minersList then
61292: LD_VAR 0 1
61296: PUSH
61297: LD_EXP 141
61301: IN
61302: NOT
61303: IFFALSE 61360
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61305: LD_ADDR_EXP 141
61309: PUSH
61310: LD_EXP 141
61314: PPUSH
61315: LD_EXP 141
61319: PUSH
61320: LD_INT 1
61322: PLUS
61323: PPUSH
61324: LD_VAR 0 1
61328: PPUSH
61329: CALL_OW 1
61333: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61334: LD_ADDR_EXP 142
61338: PUSH
61339: LD_EXP 142
61343: PPUSH
61344: LD_EXP 142
61348: PUSH
61349: LD_INT 1
61351: PLUS
61352: PPUSH
61353: EMPTY
61354: PPUSH
61355: CALL_OW 1
61359: ST_TO_ADDR
// end end ;
61360: GO 61289
61362: POP
61363: POP
// for i := minerMinesList downto 1 do
61364: LD_ADDR_VAR 0 1
61368: PUSH
61369: DOUBLE
61370: LD_EXP 142
61374: INC
61375: ST_TO_ADDR
61376: LD_INT 1
61378: PUSH
61379: FOR_DOWNTO
61380: IFFALSE 61716
// begin if IsLive ( minersList [ i ] ) then
61382: LD_EXP 141
61386: PUSH
61387: LD_VAR 0 1
61391: ARRAY
61392: PPUSH
61393: CALL_OW 300
61397: IFFALSE 61425
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61399: LD_EXP 141
61403: PUSH
61404: LD_VAR 0 1
61408: ARRAY
61409: PPUSH
61410: LD_EXP 142
61414: PUSH
61415: LD_VAR 0 1
61419: ARRAY
61420: PPUSH
61421: CALL_OW 505
// if not minerMinesList [ i ] then
61425: LD_EXP 142
61429: PUSH
61430: LD_VAR 0 1
61434: ARRAY
61435: NOT
61436: IFFALSE 61440
// continue ;
61438: GO 61379
// for j := minerMinesList [ i ] downto 1 do
61440: LD_ADDR_VAR 0 2
61444: PUSH
61445: DOUBLE
61446: LD_EXP 142
61450: PUSH
61451: LD_VAR 0 1
61455: ARRAY
61456: INC
61457: ST_TO_ADDR
61458: LD_INT 1
61460: PUSH
61461: FOR_DOWNTO
61462: IFFALSE 61712
// begin side := GetSide ( minersList [ i ] ) ;
61464: LD_ADDR_VAR 0 3
61468: PUSH
61469: LD_EXP 141
61473: PUSH
61474: LD_VAR 0 1
61478: ARRAY
61479: PPUSH
61480: CALL_OW 255
61484: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61485: LD_ADDR_VAR 0 4
61489: PUSH
61490: LD_EXP 142
61494: PUSH
61495: LD_VAR 0 1
61499: ARRAY
61500: PUSH
61501: LD_VAR 0 2
61505: ARRAY
61506: PUSH
61507: LD_INT 1
61509: ARRAY
61510: PPUSH
61511: LD_EXP 142
61515: PUSH
61516: LD_VAR 0 1
61520: ARRAY
61521: PUSH
61522: LD_VAR 0 2
61526: ARRAY
61527: PUSH
61528: LD_INT 2
61530: ARRAY
61531: PPUSH
61532: CALL_OW 428
61536: ST_TO_ADDR
// if not tmp then
61537: LD_VAR 0 4
61541: NOT
61542: IFFALSE 61546
// continue ;
61544: GO 61461
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61546: LD_VAR 0 4
61550: PUSH
61551: LD_INT 81
61553: PUSH
61554: LD_VAR 0 3
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PPUSH
61563: CALL_OW 69
61567: IN
61568: PUSH
61569: LD_EXP 142
61573: PUSH
61574: LD_VAR 0 1
61578: ARRAY
61579: PUSH
61580: LD_VAR 0 2
61584: ARRAY
61585: PUSH
61586: LD_INT 1
61588: ARRAY
61589: PPUSH
61590: LD_EXP 142
61594: PUSH
61595: LD_VAR 0 1
61599: ARRAY
61600: PUSH
61601: LD_VAR 0 2
61605: ARRAY
61606: PUSH
61607: LD_INT 2
61609: ARRAY
61610: PPUSH
61611: CALL_OW 458
61615: AND
61616: IFFALSE 61710
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61618: LD_EXP 142
61622: PUSH
61623: LD_VAR 0 1
61627: ARRAY
61628: PUSH
61629: LD_VAR 0 2
61633: ARRAY
61634: PUSH
61635: LD_INT 1
61637: ARRAY
61638: PPUSH
61639: LD_EXP 142
61643: PUSH
61644: LD_VAR 0 1
61648: ARRAY
61649: PUSH
61650: LD_VAR 0 2
61654: ARRAY
61655: PUSH
61656: LD_INT 2
61658: ARRAY
61659: PPUSH
61660: LD_VAR 0 3
61664: PPUSH
61665: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61669: LD_ADDR_EXP 142
61673: PUSH
61674: LD_EXP 142
61678: PPUSH
61679: LD_VAR 0 1
61683: PPUSH
61684: LD_EXP 142
61688: PUSH
61689: LD_VAR 0 1
61693: ARRAY
61694: PPUSH
61695: LD_VAR 0 2
61699: PPUSH
61700: CALL_OW 3
61704: PPUSH
61705: CALL_OW 1
61709: ST_TO_ADDR
// end ; end ;
61710: GO 61461
61712: POP
61713: POP
// end ;
61714: GO 61379
61716: POP
61717: POP
// end ;
61718: PPOPN 4
61720: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61721: LD_INT 0
61723: PPUSH
61724: PPUSH
// result := false ;
61725: LD_ADDR_VAR 0 4
61729: PUSH
61730: LD_INT 0
61732: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61733: LD_VAR 0 1
61737: PPUSH
61738: CALL_OW 264
61742: PUSH
61743: LD_INT 81
61745: EQUAL
61746: NOT
61747: IFFALSE 61751
// exit ;
61749: GO 61991
// index := GetElementIndex ( minersList , unit ) ;
61751: LD_ADDR_VAR 0 5
61755: PUSH
61756: LD_EXP 141
61760: PPUSH
61761: LD_VAR 0 1
61765: PPUSH
61766: CALL 68124 0 2
61770: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61771: LD_EXP 142
61775: PUSH
61776: LD_VAR 0 5
61780: ARRAY
61781: PUSH
61782: LD_EXP 143
61786: GREATEREQUAL
61787: IFFALSE 61791
// exit ;
61789: GO 61991
// ComMoveXY ( unit , x , y ) ;
61791: LD_VAR 0 1
61795: PPUSH
61796: LD_VAR 0 2
61800: PPUSH
61801: LD_VAR 0 3
61805: PPUSH
61806: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61810: LD_INT 35
61812: PPUSH
61813: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61817: LD_VAR 0 1
61821: PPUSH
61822: LD_VAR 0 2
61826: PPUSH
61827: LD_VAR 0 3
61831: PPUSH
61832: CALL 99460 0 3
61836: NOT
61837: PUSH
61838: LD_VAR 0 1
61842: PPUSH
61843: CALL_OW 314
61847: AND
61848: IFFALSE 61852
// exit ;
61850: GO 61991
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61852: LD_VAR 0 2
61856: PPUSH
61857: LD_VAR 0 3
61861: PPUSH
61862: CALL_OW 428
61866: PUSH
61867: LD_VAR 0 1
61871: EQUAL
61872: PUSH
61873: LD_VAR 0 1
61877: PPUSH
61878: CALL_OW 314
61882: NOT
61883: AND
61884: IFFALSE 61810
// PlaySoundXY ( x , y , PlantMine ) ;
61886: LD_VAR 0 2
61890: PPUSH
61891: LD_VAR 0 3
61895: PPUSH
61896: LD_STRING PlantMine
61898: PPUSH
61899: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
61903: LD_VAR 0 2
61907: PPUSH
61908: LD_VAR 0 3
61912: PPUSH
61913: LD_VAR 0 1
61917: PPUSH
61918: CALL_OW 255
61922: PPUSH
61923: LD_INT 0
61925: PPUSH
61926: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
61930: LD_ADDR_EXP 142
61934: PUSH
61935: LD_EXP 142
61939: PPUSH
61940: LD_VAR 0 5
61944: PUSH
61945: LD_EXP 142
61949: PUSH
61950: LD_VAR 0 5
61954: ARRAY
61955: PUSH
61956: LD_INT 1
61958: PLUS
61959: PUSH
61960: EMPTY
61961: LIST
61962: LIST
61963: PPUSH
61964: LD_VAR 0 2
61968: PUSH
61969: LD_VAR 0 3
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PPUSH
61978: CALL 68339 0 3
61982: ST_TO_ADDR
// result := true ;
61983: LD_ADDR_VAR 0 4
61987: PUSH
61988: LD_INT 1
61990: ST_TO_ADDR
// end ;
61991: LD_VAR 0 4
61995: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
61996: LD_INT 0
61998: PPUSH
61999: PPUSH
62000: PPUSH
// if not unit in minersList then
62001: LD_VAR 0 1
62005: PUSH
62006: LD_EXP 141
62010: IN
62011: NOT
62012: IFFALSE 62016
// exit ;
62014: GO 62408
// index := GetElementIndex ( minersList , unit ) ;
62016: LD_ADDR_VAR 0 6
62020: PUSH
62021: LD_EXP 141
62025: PPUSH
62026: LD_VAR 0 1
62030: PPUSH
62031: CALL 68124 0 2
62035: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62036: LD_ADDR_VAR 0 5
62040: PUSH
62041: DOUBLE
62042: LD_EXP 142
62046: PUSH
62047: LD_VAR 0 6
62051: ARRAY
62052: INC
62053: ST_TO_ADDR
62054: LD_INT 1
62056: PUSH
62057: FOR_DOWNTO
62058: IFFALSE 62219
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62060: LD_EXP 142
62064: PUSH
62065: LD_VAR 0 6
62069: ARRAY
62070: PUSH
62071: LD_VAR 0 5
62075: ARRAY
62076: PUSH
62077: LD_INT 1
62079: ARRAY
62080: PUSH
62081: LD_VAR 0 2
62085: EQUAL
62086: PUSH
62087: LD_EXP 142
62091: PUSH
62092: LD_VAR 0 6
62096: ARRAY
62097: PUSH
62098: LD_VAR 0 5
62102: ARRAY
62103: PUSH
62104: LD_INT 2
62106: ARRAY
62107: PUSH
62108: LD_VAR 0 3
62112: EQUAL
62113: AND
62114: IFFALSE 62217
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62116: LD_EXP 142
62120: PUSH
62121: LD_VAR 0 6
62125: ARRAY
62126: PUSH
62127: LD_VAR 0 5
62131: ARRAY
62132: PUSH
62133: LD_INT 1
62135: ARRAY
62136: PPUSH
62137: LD_EXP 142
62141: PUSH
62142: LD_VAR 0 6
62146: ARRAY
62147: PUSH
62148: LD_VAR 0 5
62152: ARRAY
62153: PUSH
62154: LD_INT 2
62156: ARRAY
62157: PPUSH
62158: LD_VAR 0 1
62162: PPUSH
62163: CALL_OW 255
62167: PPUSH
62168: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62172: LD_ADDR_EXP 142
62176: PUSH
62177: LD_EXP 142
62181: PPUSH
62182: LD_VAR 0 6
62186: PPUSH
62187: LD_EXP 142
62191: PUSH
62192: LD_VAR 0 6
62196: ARRAY
62197: PPUSH
62198: LD_VAR 0 5
62202: PPUSH
62203: CALL_OW 3
62207: PPUSH
62208: CALL_OW 1
62212: ST_TO_ADDR
// exit ;
62213: POP
62214: POP
62215: GO 62408
// end ; end ;
62217: GO 62057
62219: POP
62220: POP
// for i := minerMinesList [ index ] downto 1 do
62221: LD_ADDR_VAR 0 5
62225: PUSH
62226: DOUBLE
62227: LD_EXP 142
62231: PUSH
62232: LD_VAR 0 6
62236: ARRAY
62237: INC
62238: ST_TO_ADDR
62239: LD_INT 1
62241: PUSH
62242: FOR_DOWNTO
62243: IFFALSE 62406
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62245: LD_EXP 142
62249: PUSH
62250: LD_VAR 0 6
62254: ARRAY
62255: PUSH
62256: LD_VAR 0 5
62260: ARRAY
62261: PUSH
62262: LD_INT 1
62264: ARRAY
62265: PPUSH
62266: LD_EXP 142
62270: PUSH
62271: LD_VAR 0 6
62275: ARRAY
62276: PUSH
62277: LD_VAR 0 5
62281: ARRAY
62282: PUSH
62283: LD_INT 2
62285: ARRAY
62286: PPUSH
62287: LD_VAR 0 2
62291: PPUSH
62292: LD_VAR 0 3
62296: PPUSH
62297: CALL_OW 298
62301: PUSH
62302: LD_INT 6
62304: LESS
62305: IFFALSE 62404
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62307: LD_EXP 142
62311: PUSH
62312: LD_VAR 0 6
62316: ARRAY
62317: PUSH
62318: LD_VAR 0 5
62322: ARRAY
62323: PUSH
62324: LD_INT 1
62326: ARRAY
62327: PPUSH
62328: LD_EXP 142
62332: PUSH
62333: LD_VAR 0 6
62337: ARRAY
62338: PUSH
62339: LD_VAR 0 5
62343: ARRAY
62344: PUSH
62345: LD_INT 2
62347: ARRAY
62348: PPUSH
62349: LD_VAR 0 1
62353: PPUSH
62354: CALL_OW 255
62358: PPUSH
62359: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62363: LD_ADDR_EXP 142
62367: PUSH
62368: LD_EXP 142
62372: PPUSH
62373: LD_VAR 0 6
62377: PPUSH
62378: LD_EXP 142
62382: PUSH
62383: LD_VAR 0 6
62387: ARRAY
62388: PPUSH
62389: LD_VAR 0 5
62393: PPUSH
62394: CALL_OW 3
62398: PPUSH
62399: CALL_OW 1
62403: ST_TO_ADDR
// end ; end ;
62404: GO 62242
62406: POP
62407: POP
// end ;
62408: LD_VAR 0 4
62412: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62413: LD_INT 0
62415: PPUSH
62416: PPUSH
62417: PPUSH
62418: PPUSH
62419: PPUSH
62420: PPUSH
62421: PPUSH
62422: PPUSH
62423: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62424: LD_VAR 0 1
62428: PPUSH
62429: CALL_OW 264
62433: PUSH
62434: LD_INT 81
62436: EQUAL
62437: NOT
62438: PUSH
62439: LD_VAR 0 1
62443: PUSH
62444: LD_EXP 141
62448: IN
62449: NOT
62450: OR
62451: IFFALSE 62455
// exit ;
62453: GO 62777
// index := GetElementIndex ( minersList , unit ) ;
62455: LD_ADDR_VAR 0 6
62459: PUSH
62460: LD_EXP 141
62464: PPUSH
62465: LD_VAR 0 1
62469: PPUSH
62470: CALL 68124 0 2
62474: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62475: LD_ADDR_VAR 0 8
62479: PUSH
62480: LD_EXP 143
62484: PUSH
62485: LD_EXP 142
62489: PUSH
62490: LD_VAR 0 6
62494: ARRAY
62495: MINUS
62496: ST_TO_ADDR
// if not minesFreeAmount then
62497: LD_VAR 0 8
62501: NOT
62502: IFFALSE 62506
// exit ;
62504: GO 62777
// tmp := [ ] ;
62506: LD_ADDR_VAR 0 7
62510: PUSH
62511: EMPTY
62512: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62513: LD_ADDR_VAR 0 5
62517: PUSH
62518: DOUBLE
62519: LD_INT 1
62521: DEC
62522: ST_TO_ADDR
62523: LD_VAR 0 8
62527: PUSH
62528: FOR_TO
62529: IFFALSE 62724
// begin _d := rand ( 0 , 5 ) ;
62531: LD_ADDR_VAR 0 11
62535: PUSH
62536: LD_INT 0
62538: PPUSH
62539: LD_INT 5
62541: PPUSH
62542: CALL_OW 12
62546: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62547: LD_ADDR_VAR 0 12
62551: PUSH
62552: LD_INT 2
62554: PPUSH
62555: LD_INT 6
62557: PPUSH
62558: CALL_OW 12
62562: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62563: LD_ADDR_VAR 0 9
62567: PUSH
62568: LD_VAR 0 2
62572: PPUSH
62573: LD_VAR 0 11
62577: PPUSH
62578: LD_VAR 0 12
62582: PPUSH
62583: CALL_OW 272
62587: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62588: LD_ADDR_VAR 0 10
62592: PUSH
62593: LD_VAR 0 3
62597: PPUSH
62598: LD_VAR 0 11
62602: PPUSH
62603: LD_VAR 0 12
62607: PPUSH
62608: CALL_OW 273
62612: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62613: LD_VAR 0 9
62617: PPUSH
62618: LD_VAR 0 10
62622: PPUSH
62623: CALL_OW 488
62627: PUSH
62628: LD_VAR 0 9
62632: PUSH
62633: LD_VAR 0 10
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: PUSH
62642: LD_VAR 0 7
62646: IN
62647: NOT
62648: AND
62649: PUSH
62650: LD_VAR 0 9
62654: PPUSH
62655: LD_VAR 0 10
62659: PPUSH
62660: CALL_OW 458
62664: NOT
62665: AND
62666: IFFALSE 62708
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62668: LD_ADDR_VAR 0 7
62672: PUSH
62673: LD_VAR 0 7
62677: PPUSH
62678: LD_VAR 0 7
62682: PUSH
62683: LD_INT 1
62685: PLUS
62686: PPUSH
62687: LD_VAR 0 9
62691: PUSH
62692: LD_VAR 0 10
62696: PUSH
62697: EMPTY
62698: LIST
62699: LIST
62700: PPUSH
62701: CALL_OW 1
62705: ST_TO_ADDR
62706: GO 62722
// i := i - 1 ;
62708: LD_ADDR_VAR 0 5
62712: PUSH
62713: LD_VAR 0 5
62717: PUSH
62718: LD_INT 1
62720: MINUS
62721: ST_TO_ADDR
// end ;
62722: GO 62528
62724: POP
62725: POP
// for i in tmp do
62726: LD_ADDR_VAR 0 5
62730: PUSH
62731: LD_VAR 0 7
62735: PUSH
62736: FOR_IN
62737: IFFALSE 62775
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62739: LD_VAR 0 1
62743: PPUSH
62744: LD_VAR 0 5
62748: PUSH
62749: LD_INT 1
62751: ARRAY
62752: PPUSH
62753: LD_VAR 0 5
62757: PUSH
62758: LD_INT 2
62760: ARRAY
62761: PPUSH
62762: CALL 61721 0 3
62766: NOT
62767: IFFALSE 62773
// exit ;
62769: POP
62770: POP
62771: GO 62777
62773: GO 62736
62775: POP
62776: POP
// end ;
62777: LD_VAR 0 4
62781: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62782: LD_INT 0
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
// if not GetClass ( unit ) = class_sniper then
62791: LD_VAR 0 1
62795: PPUSH
62796: CALL_OW 257
62800: PUSH
62801: LD_INT 5
62803: EQUAL
62804: NOT
62805: IFFALSE 62809
// exit ;
62807: GO 63197
// dist := 8 ;
62809: LD_ADDR_VAR 0 5
62813: PUSH
62814: LD_INT 8
62816: ST_TO_ADDR
// viewRange := 12 ;
62817: LD_ADDR_VAR 0 7
62821: PUSH
62822: LD_INT 12
62824: ST_TO_ADDR
// side := GetSide ( unit ) ;
62825: LD_ADDR_VAR 0 6
62829: PUSH
62830: LD_VAR 0 1
62834: PPUSH
62835: CALL_OW 255
62839: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62840: LD_INT 61
62842: PPUSH
62843: LD_VAR 0 6
62847: PPUSH
62848: CALL_OW 321
62852: PUSH
62853: LD_INT 2
62855: EQUAL
62856: IFFALSE 62866
// viewRange := 16 ;
62858: LD_ADDR_VAR 0 7
62862: PUSH
62863: LD_INT 16
62865: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62866: LD_VAR 0 1
62870: PPUSH
62871: LD_VAR 0 2
62875: PPUSH
62876: LD_VAR 0 3
62880: PPUSH
62881: CALL_OW 297
62885: PUSH
62886: LD_VAR 0 5
62890: GREATER
62891: IFFALSE 62970
// begin ComMoveXY ( unit , x , y ) ;
62893: LD_VAR 0 1
62897: PPUSH
62898: LD_VAR 0 2
62902: PPUSH
62903: LD_VAR 0 3
62907: PPUSH
62908: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62912: LD_INT 35
62914: PPUSH
62915: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
62919: LD_VAR 0 1
62923: PPUSH
62924: LD_VAR 0 2
62928: PPUSH
62929: LD_VAR 0 3
62933: PPUSH
62934: CALL 99460 0 3
62938: NOT
62939: IFFALSE 62943
// exit ;
62941: GO 63197
// until GetDistUnitXY ( unit , x , y ) < dist ;
62943: LD_VAR 0 1
62947: PPUSH
62948: LD_VAR 0 2
62952: PPUSH
62953: LD_VAR 0 3
62957: PPUSH
62958: CALL_OW 297
62962: PUSH
62963: LD_VAR 0 5
62967: LESS
62968: IFFALSE 62912
// end ; ComTurnXY ( unit , x , y ) ;
62970: LD_VAR 0 1
62974: PPUSH
62975: LD_VAR 0 2
62979: PPUSH
62980: LD_VAR 0 3
62984: PPUSH
62985: CALL_OW 118
// wait ( 5 ) ;
62989: LD_INT 5
62991: PPUSH
62992: CALL_OW 67
// _d := GetDir ( unit ) ;
62996: LD_ADDR_VAR 0 10
63000: PUSH
63001: LD_VAR 0 1
63005: PPUSH
63006: CALL_OW 254
63010: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63011: LD_ADDR_VAR 0 8
63015: PUSH
63016: LD_VAR 0 1
63020: PPUSH
63021: CALL_OW 250
63025: PPUSH
63026: LD_VAR 0 10
63030: PPUSH
63031: LD_VAR 0 5
63035: PPUSH
63036: CALL_OW 272
63040: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63041: LD_ADDR_VAR 0 9
63045: PUSH
63046: LD_VAR 0 1
63050: PPUSH
63051: CALL_OW 251
63055: PPUSH
63056: LD_VAR 0 10
63060: PPUSH
63061: LD_VAR 0 5
63065: PPUSH
63066: CALL_OW 273
63070: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63071: LD_VAR 0 8
63075: PPUSH
63076: LD_VAR 0 9
63080: PPUSH
63081: CALL_OW 488
63085: NOT
63086: IFFALSE 63090
// exit ;
63088: GO 63197
// ComAnimCustom ( unit , 1 ) ;
63090: LD_VAR 0 1
63094: PPUSH
63095: LD_INT 1
63097: PPUSH
63098: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63102: LD_VAR 0 8
63106: PPUSH
63107: LD_VAR 0 9
63111: PPUSH
63112: LD_VAR 0 6
63116: PPUSH
63117: LD_VAR 0 7
63121: PPUSH
63122: CALL_OW 330
// repeat wait ( 1 ) ;
63126: LD_INT 1
63128: PPUSH
63129: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63133: LD_VAR 0 1
63137: PPUSH
63138: CALL_OW 316
63142: PUSH
63143: LD_VAR 0 1
63147: PPUSH
63148: CALL_OW 314
63152: OR
63153: PUSH
63154: LD_VAR 0 1
63158: PPUSH
63159: CALL_OW 302
63163: NOT
63164: OR
63165: PUSH
63166: LD_VAR 0 1
63170: PPUSH
63171: CALL_OW 301
63175: OR
63176: IFFALSE 63126
// RemoveSeeing ( _x , _y , side ) ;
63178: LD_VAR 0 8
63182: PPUSH
63183: LD_VAR 0 9
63187: PPUSH
63188: LD_VAR 0 6
63192: PPUSH
63193: CALL_OW 331
// end ; end_of_file
63197: LD_VAR 0 4
63201: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63202: LD_INT 0
63204: PPUSH
63205: PPUSH
// if exist_mode then
63206: LD_VAR 0 2
63210: IFFALSE 63235
// unit := CreateCharacter ( prefix & ident ) else
63212: LD_ADDR_VAR 0 5
63216: PUSH
63217: LD_VAR 0 3
63221: PUSH
63222: LD_VAR 0 1
63226: STR
63227: PPUSH
63228: CALL_OW 34
63232: ST_TO_ADDR
63233: GO 63250
// unit := NewCharacter ( ident ) ;
63235: LD_ADDR_VAR 0 5
63239: PUSH
63240: LD_VAR 0 1
63244: PPUSH
63245: CALL_OW 25
63249: ST_TO_ADDR
// result := unit ;
63250: LD_ADDR_VAR 0 4
63254: PUSH
63255: LD_VAR 0 5
63259: ST_TO_ADDR
// end ;
63260: LD_VAR 0 4
63264: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63265: LD_INT 0
63267: PPUSH
63268: PPUSH
// if not side or not nation then
63269: LD_VAR 0 1
63273: NOT
63274: PUSH
63275: LD_VAR 0 2
63279: NOT
63280: OR
63281: IFFALSE 63285
// exit ;
63283: GO 64053
// case nation of nation_american :
63285: LD_VAR 0 2
63289: PUSH
63290: LD_INT 1
63292: DOUBLE
63293: EQUAL
63294: IFTRUE 63298
63296: GO 63512
63298: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63299: LD_ADDR_VAR 0 4
63303: PUSH
63304: LD_INT 35
63306: PUSH
63307: LD_INT 45
63309: PUSH
63310: LD_INT 46
63312: PUSH
63313: LD_INT 47
63315: PUSH
63316: LD_INT 82
63318: PUSH
63319: LD_INT 83
63321: PUSH
63322: LD_INT 84
63324: PUSH
63325: LD_INT 85
63327: PUSH
63328: LD_INT 86
63330: PUSH
63331: LD_INT 1
63333: PUSH
63334: LD_INT 2
63336: PUSH
63337: LD_INT 6
63339: PUSH
63340: LD_INT 15
63342: PUSH
63343: LD_INT 16
63345: PUSH
63346: LD_INT 7
63348: PUSH
63349: LD_INT 12
63351: PUSH
63352: LD_INT 13
63354: PUSH
63355: LD_INT 10
63357: PUSH
63358: LD_INT 14
63360: PUSH
63361: LD_INT 20
63363: PUSH
63364: LD_INT 21
63366: PUSH
63367: LD_INT 22
63369: PUSH
63370: LD_INT 25
63372: PUSH
63373: LD_INT 32
63375: PUSH
63376: LD_INT 27
63378: PUSH
63379: LD_INT 36
63381: PUSH
63382: LD_INT 69
63384: PUSH
63385: LD_INT 39
63387: PUSH
63388: LD_INT 34
63390: PUSH
63391: LD_INT 40
63393: PUSH
63394: LD_INT 48
63396: PUSH
63397: LD_INT 49
63399: PUSH
63400: LD_INT 50
63402: PUSH
63403: LD_INT 51
63405: PUSH
63406: LD_INT 52
63408: PUSH
63409: LD_INT 53
63411: PUSH
63412: LD_INT 54
63414: PUSH
63415: LD_INT 55
63417: PUSH
63418: LD_INT 56
63420: PUSH
63421: LD_INT 57
63423: PUSH
63424: LD_INT 58
63426: PUSH
63427: LD_INT 59
63429: PUSH
63430: LD_INT 60
63432: PUSH
63433: LD_INT 61
63435: PUSH
63436: LD_INT 62
63438: PUSH
63439: LD_INT 80
63441: PUSH
63442: LD_INT 82
63444: PUSH
63445: LD_INT 83
63447: PUSH
63448: LD_INT 84
63450: PUSH
63451: LD_INT 85
63453: PUSH
63454: LD_INT 86
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: LIST
63476: LIST
63477: LIST
63478: LIST
63479: LIST
63480: LIST
63481: LIST
63482: LIST
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: LIST
63491: LIST
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: LIST
63507: LIST
63508: LIST
63509: ST_TO_ADDR
63510: GO 63977
63512: LD_INT 2
63514: DOUBLE
63515: EQUAL
63516: IFTRUE 63520
63518: GO 63746
63520: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
63521: LD_ADDR_VAR 0 4
63525: PUSH
63526: LD_INT 35
63528: PUSH
63529: LD_INT 45
63531: PUSH
63532: LD_INT 46
63534: PUSH
63535: LD_INT 47
63537: PUSH
63538: LD_INT 82
63540: PUSH
63541: LD_INT 83
63543: PUSH
63544: LD_INT 84
63546: PUSH
63547: LD_INT 85
63549: PUSH
63550: LD_INT 87
63552: PUSH
63553: LD_INT 70
63555: PUSH
63556: LD_INT 1
63558: PUSH
63559: LD_INT 11
63561: PUSH
63562: LD_INT 3
63564: PUSH
63565: LD_INT 4
63567: PUSH
63568: LD_INT 5
63570: PUSH
63571: LD_INT 6
63573: PUSH
63574: LD_INT 15
63576: PUSH
63577: LD_INT 18
63579: PUSH
63580: LD_INT 7
63582: PUSH
63583: LD_INT 17
63585: PUSH
63586: LD_INT 8
63588: PUSH
63589: LD_INT 20
63591: PUSH
63592: LD_INT 21
63594: PUSH
63595: LD_INT 22
63597: PUSH
63598: LD_INT 72
63600: PUSH
63601: LD_INT 26
63603: PUSH
63604: LD_INT 69
63606: PUSH
63607: LD_INT 39
63609: PUSH
63610: LD_INT 40
63612: PUSH
63613: LD_INT 41
63615: PUSH
63616: LD_INT 42
63618: PUSH
63619: LD_INT 43
63621: PUSH
63622: LD_INT 48
63624: PUSH
63625: LD_INT 49
63627: PUSH
63628: LD_INT 50
63630: PUSH
63631: LD_INT 51
63633: PUSH
63634: LD_INT 52
63636: PUSH
63637: LD_INT 53
63639: PUSH
63640: LD_INT 54
63642: PUSH
63643: LD_INT 55
63645: PUSH
63646: LD_INT 56
63648: PUSH
63649: LD_INT 60
63651: PUSH
63652: LD_INT 61
63654: PUSH
63655: LD_INT 62
63657: PUSH
63658: LD_INT 66
63660: PUSH
63661: LD_INT 67
63663: PUSH
63664: LD_INT 68
63666: PUSH
63667: LD_INT 81
63669: PUSH
63670: LD_INT 82
63672: PUSH
63673: LD_INT 83
63675: PUSH
63676: LD_INT 84
63678: PUSH
63679: LD_INT 85
63681: PUSH
63682: LD_INT 87
63684: PUSH
63685: LD_INT 88
63687: PUSH
63688: EMPTY
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: LIST
63706: LIST
63707: LIST
63708: LIST
63709: LIST
63710: LIST
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: LIST
63716: LIST
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: ST_TO_ADDR
63744: GO 63977
63746: LD_INT 3
63748: DOUBLE
63749: EQUAL
63750: IFTRUE 63754
63752: GO 63976
63754: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
63755: LD_ADDR_VAR 0 4
63759: PUSH
63760: LD_INT 46
63762: PUSH
63763: LD_INT 47
63765: PUSH
63766: LD_INT 1
63768: PUSH
63769: LD_INT 2
63771: PUSH
63772: LD_INT 82
63774: PUSH
63775: LD_INT 83
63777: PUSH
63778: LD_INT 84
63780: PUSH
63781: LD_INT 85
63783: PUSH
63784: LD_INT 86
63786: PUSH
63787: LD_INT 11
63789: PUSH
63790: LD_INT 9
63792: PUSH
63793: LD_INT 20
63795: PUSH
63796: LD_INT 19
63798: PUSH
63799: LD_INT 21
63801: PUSH
63802: LD_INT 24
63804: PUSH
63805: LD_INT 22
63807: PUSH
63808: LD_INT 25
63810: PUSH
63811: LD_INT 28
63813: PUSH
63814: LD_INT 29
63816: PUSH
63817: LD_INT 30
63819: PUSH
63820: LD_INT 31
63822: PUSH
63823: LD_INT 37
63825: PUSH
63826: LD_INT 38
63828: PUSH
63829: LD_INT 32
63831: PUSH
63832: LD_INT 27
63834: PUSH
63835: LD_INT 33
63837: PUSH
63838: LD_INT 69
63840: PUSH
63841: LD_INT 39
63843: PUSH
63844: LD_INT 34
63846: PUSH
63847: LD_INT 40
63849: PUSH
63850: LD_INT 71
63852: PUSH
63853: LD_INT 23
63855: PUSH
63856: LD_INT 44
63858: PUSH
63859: LD_INT 48
63861: PUSH
63862: LD_INT 49
63864: PUSH
63865: LD_INT 50
63867: PUSH
63868: LD_INT 51
63870: PUSH
63871: LD_INT 52
63873: PUSH
63874: LD_INT 53
63876: PUSH
63877: LD_INT 54
63879: PUSH
63880: LD_INT 55
63882: PUSH
63883: LD_INT 56
63885: PUSH
63886: LD_INT 57
63888: PUSH
63889: LD_INT 58
63891: PUSH
63892: LD_INT 59
63894: PUSH
63895: LD_INT 63
63897: PUSH
63898: LD_INT 64
63900: PUSH
63901: LD_INT 65
63903: PUSH
63904: LD_INT 82
63906: PUSH
63907: LD_INT 83
63909: PUSH
63910: LD_INT 84
63912: PUSH
63913: LD_INT 85
63915: PUSH
63916: LD_INT 86
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: LIST
63961: LIST
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: LIST
63970: LIST
63971: LIST
63972: LIST
63973: ST_TO_ADDR
63974: GO 63977
63976: POP
// if state > - 1 and state < 3 then
63977: LD_VAR 0 3
63981: PUSH
63982: LD_INT 1
63984: NEG
63985: GREATER
63986: PUSH
63987: LD_VAR 0 3
63991: PUSH
63992: LD_INT 3
63994: LESS
63995: AND
63996: IFFALSE 64053
// for i in result do
63998: LD_ADDR_VAR 0 5
64002: PUSH
64003: LD_VAR 0 4
64007: PUSH
64008: FOR_IN
64009: IFFALSE 64051
// if GetTech ( i , side ) <> state then
64011: LD_VAR 0 5
64015: PPUSH
64016: LD_VAR 0 1
64020: PPUSH
64021: CALL_OW 321
64025: PUSH
64026: LD_VAR 0 3
64030: NONEQUAL
64031: IFFALSE 64049
// result := result diff i ;
64033: LD_ADDR_VAR 0 4
64037: PUSH
64038: LD_VAR 0 4
64042: PUSH
64043: LD_VAR 0 5
64047: DIFF
64048: ST_TO_ADDR
64049: GO 64008
64051: POP
64052: POP
// end ;
64053: LD_VAR 0 4
64057: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64058: LD_INT 0
64060: PPUSH
64061: PPUSH
64062: PPUSH
// result := true ;
64063: LD_ADDR_VAR 0 3
64067: PUSH
64068: LD_INT 1
64070: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64071: LD_ADDR_VAR 0 5
64075: PUSH
64076: LD_VAR 0 2
64080: PPUSH
64081: CALL_OW 480
64085: ST_TO_ADDR
// if not tmp then
64086: LD_VAR 0 5
64090: NOT
64091: IFFALSE 64095
// exit ;
64093: GO 64144
// for i in tmp do
64095: LD_ADDR_VAR 0 4
64099: PUSH
64100: LD_VAR 0 5
64104: PUSH
64105: FOR_IN
64106: IFFALSE 64142
// if GetTech ( i , side ) <> state_researched then
64108: LD_VAR 0 4
64112: PPUSH
64113: LD_VAR 0 1
64117: PPUSH
64118: CALL_OW 321
64122: PUSH
64123: LD_INT 2
64125: NONEQUAL
64126: IFFALSE 64140
// begin result := false ;
64128: LD_ADDR_VAR 0 3
64132: PUSH
64133: LD_INT 0
64135: ST_TO_ADDR
// exit ;
64136: POP
64137: POP
64138: GO 64144
// end ;
64140: GO 64105
64142: POP
64143: POP
// end ;
64144: LD_VAR 0 3
64148: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64149: LD_INT 0
64151: PPUSH
64152: PPUSH
64153: PPUSH
64154: PPUSH
64155: PPUSH
64156: PPUSH
64157: PPUSH
64158: PPUSH
64159: PPUSH
64160: PPUSH
64161: PPUSH
64162: PPUSH
64163: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64164: LD_VAR 0 1
64168: NOT
64169: PUSH
64170: LD_VAR 0 1
64174: PPUSH
64175: CALL_OW 257
64179: PUSH
64180: LD_INT 9
64182: NONEQUAL
64183: OR
64184: IFFALSE 64188
// exit ;
64186: GO 64761
// side := GetSide ( unit ) ;
64188: LD_ADDR_VAR 0 9
64192: PUSH
64193: LD_VAR 0 1
64197: PPUSH
64198: CALL_OW 255
64202: ST_TO_ADDR
// tech_space := tech_spacanom ;
64203: LD_ADDR_VAR 0 12
64207: PUSH
64208: LD_INT 29
64210: ST_TO_ADDR
// tech_time := tech_taurad ;
64211: LD_ADDR_VAR 0 13
64215: PUSH
64216: LD_INT 28
64218: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64219: LD_ADDR_VAR 0 11
64223: PUSH
64224: LD_VAR 0 1
64228: PPUSH
64229: CALL_OW 310
64233: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64234: LD_VAR 0 11
64238: PPUSH
64239: CALL_OW 247
64243: PUSH
64244: LD_INT 2
64246: EQUAL
64247: IFFALSE 64251
// exit ;
64249: GO 64761
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64251: LD_ADDR_VAR 0 8
64255: PUSH
64256: LD_INT 81
64258: PUSH
64259: LD_VAR 0 9
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: PUSH
64268: LD_INT 3
64270: PUSH
64271: LD_INT 21
64273: PUSH
64274: LD_INT 3
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: EMPTY
64286: LIST
64287: LIST
64288: PPUSH
64289: CALL_OW 69
64293: ST_TO_ADDR
// if not tmp then
64294: LD_VAR 0 8
64298: NOT
64299: IFFALSE 64303
// exit ;
64301: GO 64761
// if in_unit then
64303: LD_VAR 0 11
64307: IFFALSE 64331
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64309: LD_ADDR_VAR 0 10
64313: PUSH
64314: LD_VAR 0 8
64318: PPUSH
64319: LD_VAR 0 11
64323: PPUSH
64324: CALL_OW 74
64328: ST_TO_ADDR
64329: GO 64351
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64331: LD_ADDR_VAR 0 10
64335: PUSH
64336: LD_VAR 0 8
64340: PPUSH
64341: LD_VAR 0 1
64345: PPUSH
64346: CALL_OW 74
64350: ST_TO_ADDR
// if not enemy then
64351: LD_VAR 0 10
64355: NOT
64356: IFFALSE 64360
// exit ;
64358: GO 64761
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64360: LD_VAR 0 11
64364: PUSH
64365: LD_VAR 0 11
64369: PPUSH
64370: LD_VAR 0 10
64374: PPUSH
64375: CALL_OW 296
64379: PUSH
64380: LD_INT 13
64382: GREATER
64383: AND
64384: PUSH
64385: LD_VAR 0 1
64389: PPUSH
64390: LD_VAR 0 10
64394: PPUSH
64395: CALL_OW 296
64399: PUSH
64400: LD_INT 12
64402: GREATER
64403: OR
64404: IFFALSE 64408
// exit ;
64406: GO 64761
// missile := [ 1 ] ;
64408: LD_ADDR_VAR 0 14
64412: PUSH
64413: LD_INT 1
64415: PUSH
64416: EMPTY
64417: LIST
64418: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64419: LD_VAR 0 9
64423: PPUSH
64424: LD_VAR 0 12
64428: PPUSH
64429: CALL_OW 325
64433: IFFALSE 64462
// missile := Replace ( missile , missile + 1 , 2 ) ;
64435: LD_ADDR_VAR 0 14
64439: PUSH
64440: LD_VAR 0 14
64444: PPUSH
64445: LD_VAR 0 14
64449: PUSH
64450: LD_INT 1
64452: PLUS
64453: PPUSH
64454: LD_INT 2
64456: PPUSH
64457: CALL_OW 1
64461: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64462: LD_VAR 0 9
64466: PPUSH
64467: LD_VAR 0 13
64471: PPUSH
64472: CALL_OW 325
64476: PUSH
64477: LD_VAR 0 10
64481: PPUSH
64482: CALL_OW 255
64486: PPUSH
64487: LD_VAR 0 13
64491: PPUSH
64492: CALL_OW 325
64496: NOT
64497: AND
64498: IFFALSE 64527
// missile := Replace ( missile , missile + 1 , 3 ) ;
64500: LD_ADDR_VAR 0 14
64504: PUSH
64505: LD_VAR 0 14
64509: PPUSH
64510: LD_VAR 0 14
64514: PUSH
64515: LD_INT 1
64517: PLUS
64518: PPUSH
64519: LD_INT 3
64521: PPUSH
64522: CALL_OW 1
64526: ST_TO_ADDR
// if missile < 2 then
64527: LD_VAR 0 14
64531: PUSH
64532: LD_INT 2
64534: LESS
64535: IFFALSE 64539
// exit ;
64537: GO 64761
// x := GetX ( enemy ) ;
64539: LD_ADDR_VAR 0 4
64543: PUSH
64544: LD_VAR 0 10
64548: PPUSH
64549: CALL_OW 250
64553: ST_TO_ADDR
// y := GetY ( enemy ) ;
64554: LD_ADDR_VAR 0 5
64558: PUSH
64559: LD_VAR 0 10
64563: PPUSH
64564: CALL_OW 251
64568: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64569: LD_ADDR_VAR 0 6
64573: PUSH
64574: LD_VAR 0 4
64578: PUSH
64579: LD_INT 1
64581: NEG
64582: PPUSH
64583: LD_INT 1
64585: PPUSH
64586: CALL_OW 12
64590: PLUS
64591: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64592: LD_ADDR_VAR 0 7
64596: PUSH
64597: LD_VAR 0 5
64601: PUSH
64602: LD_INT 1
64604: NEG
64605: PPUSH
64606: LD_INT 1
64608: PPUSH
64609: CALL_OW 12
64613: PLUS
64614: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64615: LD_VAR 0 6
64619: PPUSH
64620: LD_VAR 0 7
64624: PPUSH
64625: CALL_OW 488
64629: NOT
64630: IFFALSE 64652
// begin _x := x ;
64632: LD_ADDR_VAR 0 6
64636: PUSH
64637: LD_VAR 0 4
64641: ST_TO_ADDR
// _y := y ;
64642: LD_ADDR_VAR 0 7
64646: PUSH
64647: LD_VAR 0 5
64651: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64652: LD_ADDR_VAR 0 3
64656: PUSH
64657: LD_INT 1
64659: PPUSH
64660: LD_VAR 0 14
64664: PPUSH
64665: CALL_OW 12
64669: ST_TO_ADDR
// case i of 1 :
64670: LD_VAR 0 3
64674: PUSH
64675: LD_INT 1
64677: DOUBLE
64678: EQUAL
64679: IFTRUE 64683
64681: GO 64700
64683: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64684: LD_VAR 0 1
64688: PPUSH
64689: LD_VAR 0 10
64693: PPUSH
64694: CALL_OW 115
64698: GO 64761
64700: LD_INT 2
64702: DOUBLE
64703: EQUAL
64704: IFTRUE 64708
64706: GO 64730
64708: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64709: LD_VAR 0 1
64713: PPUSH
64714: LD_VAR 0 6
64718: PPUSH
64719: LD_VAR 0 7
64723: PPUSH
64724: CALL_OW 153
64728: GO 64761
64730: LD_INT 3
64732: DOUBLE
64733: EQUAL
64734: IFTRUE 64738
64736: GO 64760
64738: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64739: LD_VAR 0 1
64743: PPUSH
64744: LD_VAR 0 6
64748: PPUSH
64749: LD_VAR 0 7
64753: PPUSH
64754: CALL_OW 154
64758: GO 64761
64760: POP
// end ;
64761: LD_VAR 0 2
64765: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64766: LD_INT 0
64768: PPUSH
64769: PPUSH
64770: PPUSH
64771: PPUSH
64772: PPUSH
64773: PPUSH
// if not unit or not building then
64774: LD_VAR 0 1
64778: NOT
64779: PUSH
64780: LD_VAR 0 2
64784: NOT
64785: OR
64786: IFFALSE 64790
// exit ;
64788: GO 64948
// x := GetX ( building ) ;
64790: LD_ADDR_VAR 0 5
64794: PUSH
64795: LD_VAR 0 2
64799: PPUSH
64800: CALL_OW 250
64804: ST_TO_ADDR
// y := GetY ( building ) ;
64805: LD_ADDR_VAR 0 6
64809: PUSH
64810: LD_VAR 0 2
64814: PPUSH
64815: CALL_OW 251
64819: ST_TO_ADDR
// for i = 0 to 5 do
64820: LD_ADDR_VAR 0 4
64824: PUSH
64825: DOUBLE
64826: LD_INT 0
64828: DEC
64829: ST_TO_ADDR
64830: LD_INT 5
64832: PUSH
64833: FOR_TO
64834: IFFALSE 64946
// begin _x := ShiftX ( x , i , 3 ) ;
64836: LD_ADDR_VAR 0 7
64840: PUSH
64841: LD_VAR 0 5
64845: PPUSH
64846: LD_VAR 0 4
64850: PPUSH
64851: LD_INT 3
64853: PPUSH
64854: CALL_OW 272
64858: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64859: LD_ADDR_VAR 0 8
64863: PUSH
64864: LD_VAR 0 6
64868: PPUSH
64869: LD_VAR 0 4
64873: PPUSH
64874: LD_INT 3
64876: PPUSH
64877: CALL_OW 273
64881: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64882: LD_VAR 0 7
64886: PPUSH
64887: LD_VAR 0 8
64891: PPUSH
64892: CALL_OW 488
64896: NOT
64897: IFFALSE 64901
// continue ;
64899: GO 64833
// if HexInfo ( _x , _y ) = 0 then
64901: LD_VAR 0 7
64905: PPUSH
64906: LD_VAR 0 8
64910: PPUSH
64911: CALL_OW 428
64915: PUSH
64916: LD_INT 0
64918: EQUAL
64919: IFFALSE 64944
// begin ComMoveXY ( unit , _x , _y ) ;
64921: LD_VAR 0 1
64925: PPUSH
64926: LD_VAR 0 7
64930: PPUSH
64931: LD_VAR 0 8
64935: PPUSH
64936: CALL_OW 111
// exit ;
64940: POP
64941: POP
64942: GO 64948
// end ; end ;
64944: GO 64833
64946: POP
64947: POP
// end ;
64948: LD_VAR 0 3
64952: RET
// export function ScanBase ( side , base_area ) ; begin
64953: LD_INT 0
64955: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64956: LD_ADDR_VAR 0 3
64960: PUSH
64961: LD_VAR 0 2
64965: PPUSH
64966: LD_INT 81
64968: PUSH
64969: LD_VAR 0 1
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PPUSH
64978: CALL_OW 70
64982: ST_TO_ADDR
// end ;
64983: LD_VAR 0 3
64987: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
64988: LD_INT 0
64990: PPUSH
64991: PPUSH
64992: PPUSH
64993: PPUSH
// result := false ;
64994: LD_ADDR_VAR 0 2
64998: PUSH
64999: LD_INT 0
65001: ST_TO_ADDR
// side := GetSide ( unit ) ;
65002: LD_ADDR_VAR 0 3
65006: PUSH
65007: LD_VAR 0 1
65011: PPUSH
65012: CALL_OW 255
65016: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65017: LD_ADDR_VAR 0 4
65021: PUSH
65022: LD_VAR 0 1
65026: PPUSH
65027: CALL_OW 248
65031: ST_TO_ADDR
// case nat of 1 :
65032: LD_VAR 0 4
65036: PUSH
65037: LD_INT 1
65039: DOUBLE
65040: EQUAL
65041: IFTRUE 65045
65043: GO 65056
65045: POP
// tech := tech_lassight ; 2 :
65046: LD_ADDR_VAR 0 5
65050: PUSH
65051: LD_INT 12
65053: ST_TO_ADDR
65054: GO 65095
65056: LD_INT 2
65058: DOUBLE
65059: EQUAL
65060: IFTRUE 65064
65062: GO 65075
65064: POP
// tech := tech_mortar ; 3 :
65065: LD_ADDR_VAR 0 5
65069: PUSH
65070: LD_INT 41
65072: ST_TO_ADDR
65073: GO 65095
65075: LD_INT 3
65077: DOUBLE
65078: EQUAL
65079: IFTRUE 65083
65081: GO 65094
65083: POP
// tech := tech_bazooka ; end ;
65084: LD_ADDR_VAR 0 5
65088: PUSH
65089: LD_INT 44
65091: ST_TO_ADDR
65092: GO 65095
65094: POP
// if Researched ( side , tech ) then
65095: LD_VAR 0 3
65099: PPUSH
65100: LD_VAR 0 5
65104: PPUSH
65105: CALL_OW 325
65109: IFFALSE 65136
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65111: LD_ADDR_VAR 0 2
65115: PUSH
65116: LD_INT 5
65118: PUSH
65119: LD_INT 8
65121: PUSH
65122: LD_INT 9
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: LIST
65129: PUSH
65130: LD_VAR 0 4
65134: ARRAY
65135: ST_TO_ADDR
// end ;
65136: LD_VAR 0 2
65140: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65141: LD_INT 0
65143: PPUSH
65144: PPUSH
65145: PPUSH
// if not mines then
65146: LD_VAR 0 2
65150: NOT
65151: IFFALSE 65155
// exit ;
65153: GO 65299
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65155: LD_ADDR_VAR 0 5
65159: PUSH
65160: LD_INT 81
65162: PUSH
65163: LD_VAR 0 1
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PUSH
65172: LD_INT 3
65174: PUSH
65175: LD_INT 21
65177: PUSH
65178: LD_INT 3
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PPUSH
65193: CALL_OW 69
65197: ST_TO_ADDR
// for i in mines do
65198: LD_ADDR_VAR 0 4
65202: PUSH
65203: LD_VAR 0 2
65207: PUSH
65208: FOR_IN
65209: IFFALSE 65297
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65211: LD_VAR 0 4
65215: PUSH
65216: LD_INT 1
65218: ARRAY
65219: PPUSH
65220: LD_VAR 0 4
65224: PUSH
65225: LD_INT 2
65227: ARRAY
65228: PPUSH
65229: CALL_OW 458
65233: NOT
65234: IFFALSE 65238
// continue ;
65236: GO 65208
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65238: LD_VAR 0 4
65242: PUSH
65243: LD_INT 1
65245: ARRAY
65246: PPUSH
65247: LD_VAR 0 4
65251: PUSH
65252: LD_INT 2
65254: ARRAY
65255: PPUSH
65256: CALL_OW 428
65260: PUSH
65261: LD_VAR 0 5
65265: IN
65266: IFFALSE 65295
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65268: LD_VAR 0 4
65272: PUSH
65273: LD_INT 1
65275: ARRAY
65276: PPUSH
65277: LD_VAR 0 4
65281: PUSH
65282: LD_INT 2
65284: ARRAY
65285: PPUSH
65286: LD_VAR 0 1
65290: PPUSH
65291: CALL_OW 456
// end ;
65295: GO 65208
65297: POP
65298: POP
// end ;
65299: LD_VAR 0 3
65303: RET
// export function Count ( array ) ; var i ; begin
65304: LD_INT 0
65306: PPUSH
65307: PPUSH
// result := 0 ;
65308: LD_ADDR_VAR 0 2
65312: PUSH
65313: LD_INT 0
65315: ST_TO_ADDR
// for i in array do
65316: LD_ADDR_VAR 0 3
65320: PUSH
65321: LD_VAR 0 1
65325: PUSH
65326: FOR_IN
65327: IFFALSE 65351
// if i then
65329: LD_VAR 0 3
65333: IFFALSE 65349
// result := result + 1 ;
65335: LD_ADDR_VAR 0 2
65339: PUSH
65340: LD_VAR 0 2
65344: PUSH
65345: LD_INT 1
65347: PLUS
65348: ST_TO_ADDR
65349: GO 65326
65351: POP
65352: POP
// end ;
65353: LD_VAR 0 2
65357: RET
// export function IsEmpty ( building ) ; begin
65358: LD_INT 0
65360: PPUSH
// if not building then
65361: LD_VAR 0 1
65365: NOT
65366: IFFALSE 65370
// exit ;
65368: GO 65413
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65370: LD_ADDR_VAR 0 2
65374: PUSH
65375: LD_VAR 0 1
65379: PUSH
65380: LD_INT 22
65382: PUSH
65383: LD_VAR 0 1
65387: PPUSH
65388: CALL_OW 255
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: LD_INT 58
65399: PUSH
65400: EMPTY
65401: LIST
65402: PUSH
65403: EMPTY
65404: LIST
65405: LIST
65406: PPUSH
65407: CALL_OW 69
65411: IN
65412: ST_TO_ADDR
// end ;
65413: LD_VAR 0 2
65417: RET
// export function IsNotFull ( building ) ; var places ; begin
65418: LD_INT 0
65420: PPUSH
65421: PPUSH
// if not building then
65422: LD_VAR 0 1
65426: NOT
65427: IFFALSE 65431
// exit ;
65429: GO 65602
// result := false ;
65431: LD_ADDR_VAR 0 2
65435: PUSH
65436: LD_INT 0
65438: ST_TO_ADDR
// places := 0 ;
65439: LD_ADDR_VAR 0 3
65443: PUSH
65444: LD_INT 0
65446: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
65447: LD_VAR 0 1
65451: PPUSH
65452: CALL_OW 266
65456: PUSH
65457: LD_INT 0
65459: DOUBLE
65460: EQUAL
65461: IFTRUE 65519
65463: LD_INT 1
65465: DOUBLE
65466: EQUAL
65467: IFTRUE 65519
65469: LD_INT 6
65471: DOUBLE
65472: EQUAL
65473: IFTRUE 65519
65475: LD_INT 7
65477: DOUBLE
65478: EQUAL
65479: IFTRUE 65519
65481: LD_INT 8
65483: DOUBLE
65484: EQUAL
65485: IFTRUE 65519
65487: LD_INT 4
65489: DOUBLE
65490: EQUAL
65491: IFTRUE 65519
65493: LD_INT 5
65495: DOUBLE
65496: EQUAL
65497: IFTRUE 65519
65499: LD_INT 2
65501: DOUBLE
65502: EQUAL
65503: IFTRUE 65519
65505: LD_INT 3
65507: DOUBLE
65508: EQUAL
65509: IFTRUE 65519
65511: LD_INT 35
65513: DOUBLE
65514: EQUAL
65515: IFTRUE 65519
65517: GO 65530
65519: POP
// places := 6 ; b_bunker , b_breastwork :
65520: LD_ADDR_VAR 0 3
65524: PUSH
65525: LD_INT 6
65527: ST_TO_ADDR
65528: GO 65575
65530: LD_INT 32
65532: DOUBLE
65533: EQUAL
65534: IFTRUE 65544
65536: LD_INT 31
65538: DOUBLE
65539: EQUAL
65540: IFTRUE 65544
65542: GO 65555
65544: POP
// places := 1 ; b_control_tower :
65545: LD_ADDR_VAR 0 3
65549: PUSH
65550: LD_INT 1
65552: ST_TO_ADDR
65553: GO 65575
65555: LD_INT 36
65557: DOUBLE
65558: EQUAL
65559: IFTRUE 65563
65561: GO 65574
65563: POP
// places := 3 ; end ;
65564: LD_ADDR_VAR 0 3
65568: PUSH
65569: LD_INT 3
65571: ST_TO_ADDR
65572: GO 65575
65574: POP
// if places then
65575: LD_VAR 0 3
65579: IFFALSE 65602
// result := UnitsInside ( building ) < places ;
65581: LD_ADDR_VAR 0 2
65585: PUSH
65586: LD_VAR 0 1
65590: PPUSH
65591: CALL_OW 313
65595: PUSH
65596: LD_VAR 0 3
65600: LESS
65601: ST_TO_ADDR
// end ;
65602: LD_VAR 0 2
65606: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65607: LD_INT 0
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
// tmp := [ ] ;
65613: LD_ADDR_VAR 0 3
65617: PUSH
65618: EMPTY
65619: ST_TO_ADDR
// list := [ ] ;
65620: LD_ADDR_VAR 0 5
65624: PUSH
65625: EMPTY
65626: ST_TO_ADDR
// for i = 16 to 25 do
65627: LD_ADDR_VAR 0 4
65631: PUSH
65632: DOUBLE
65633: LD_INT 16
65635: DEC
65636: ST_TO_ADDR
65637: LD_INT 25
65639: PUSH
65640: FOR_TO
65641: IFFALSE 65714
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65643: LD_ADDR_VAR 0 3
65647: PUSH
65648: LD_VAR 0 3
65652: PUSH
65653: LD_INT 22
65655: PUSH
65656: LD_VAR 0 1
65660: PPUSH
65661: CALL_OW 255
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 91
65672: PUSH
65673: LD_VAR 0 1
65677: PUSH
65678: LD_INT 6
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: LIST
65685: PUSH
65686: LD_INT 30
65688: PUSH
65689: LD_VAR 0 4
65693: PUSH
65694: EMPTY
65695: LIST
65696: LIST
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: LIST
65702: PUSH
65703: EMPTY
65704: LIST
65705: PPUSH
65706: CALL_OW 69
65710: ADD
65711: ST_TO_ADDR
65712: GO 65640
65714: POP
65715: POP
// for i = 1 to tmp do
65716: LD_ADDR_VAR 0 4
65720: PUSH
65721: DOUBLE
65722: LD_INT 1
65724: DEC
65725: ST_TO_ADDR
65726: LD_VAR 0 3
65730: PUSH
65731: FOR_TO
65732: IFFALSE 65820
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65734: LD_ADDR_VAR 0 5
65738: PUSH
65739: LD_VAR 0 5
65743: PUSH
65744: LD_VAR 0 3
65748: PUSH
65749: LD_VAR 0 4
65753: ARRAY
65754: PPUSH
65755: CALL_OW 266
65759: PUSH
65760: LD_VAR 0 3
65764: PUSH
65765: LD_VAR 0 4
65769: ARRAY
65770: PPUSH
65771: CALL_OW 250
65775: PUSH
65776: LD_VAR 0 3
65780: PUSH
65781: LD_VAR 0 4
65785: ARRAY
65786: PPUSH
65787: CALL_OW 251
65791: PUSH
65792: LD_VAR 0 3
65796: PUSH
65797: LD_VAR 0 4
65801: ARRAY
65802: PPUSH
65803: CALL_OW 254
65807: PUSH
65808: EMPTY
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: PUSH
65814: EMPTY
65815: LIST
65816: ADD
65817: ST_TO_ADDR
65818: GO 65731
65820: POP
65821: POP
// result := list ;
65822: LD_ADDR_VAR 0 2
65826: PUSH
65827: LD_VAR 0 5
65831: ST_TO_ADDR
// end ;
65832: LD_VAR 0 2
65836: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65837: LD_INT 0
65839: PPUSH
65840: PPUSH
65841: PPUSH
65842: PPUSH
65843: PPUSH
65844: PPUSH
65845: PPUSH
// if not factory then
65846: LD_VAR 0 1
65850: NOT
65851: IFFALSE 65855
// exit ;
65853: GO 66448
// if control = control_apeman then
65855: LD_VAR 0 4
65859: PUSH
65860: LD_INT 5
65862: EQUAL
65863: IFFALSE 65972
// begin tmp := UnitsInside ( factory ) ;
65865: LD_ADDR_VAR 0 8
65869: PUSH
65870: LD_VAR 0 1
65874: PPUSH
65875: CALL_OW 313
65879: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
65880: LD_VAR 0 8
65884: PPUSH
65885: LD_INT 25
65887: PUSH
65888: LD_INT 12
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PPUSH
65895: CALL_OW 72
65899: NOT
65900: IFFALSE 65910
// control := control_manual ;
65902: LD_ADDR_VAR 0 4
65906: PUSH
65907: LD_INT 1
65909: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
65910: LD_ADDR_VAR 0 8
65914: PUSH
65915: LD_VAR 0 1
65919: PPUSH
65920: CALL 65607 0 1
65924: ST_TO_ADDR
// if tmp then
65925: LD_VAR 0 8
65929: IFFALSE 65972
// begin for i in tmp do
65931: LD_ADDR_VAR 0 7
65935: PUSH
65936: LD_VAR 0 8
65940: PUSH
65941: FOR_IN
65942: IFFALSE 65970
// if i [ 1 ] = b_ext_radio then
65944: LD_VAR 0 7
65948: PUSH
65949: LD_INT 1
65951: ARRAY
65952: PUSH
65953: LD_INT 22
65955: EQUAL
65956: IFFALSE 65968
// begin control := control_remote ;
65958: LD_ADDR_VAR 0 4
65962: PUSH
65963: LD_INT 2
65965: ST_TO_ADDR
// break ;
65966: GO 65970
// end ;
65968: GO 65941
65970: POP
65971: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65972: LD_VAR 0 1
65976: PPUSH
65977: LD_VAR 0 2
65981: PPUSH
65982: LD_VAR 0 3
65986: PPUSH
65987: LD_VAR 0 4
65991: PPUSH
65992: LD_VAR 0 5
65996: PPUSH
65997: CALL_OW 448
66001: IFFALSE 66036
// begin result := [ chassis , engine , control , weapon ] ;
66003: LD_ADDR_VAR 0 6
66007: PUSH
66008: LD_VAR 0 2
66012: PUSH
66013: LD_VAR 0 3
66017: PUSH
66018: LD_VAR 0 4
66022: PUSH
66023: LD_VAR 0 5
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: LIST
66032: LIST
66033: ST_TO_ADDR
// exit ;
66034: GO 66448
// end ; _chassis := AvailableChassisList ( factory ) ;
66036: LD_ADDR_VAR 0 9
66040: PUSH
66041: LD_VAR 0 1
66045: PPUSH
66046: CALL_OW 475
66050: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66051: LD_ADDR_VAR 0 11
66055: PUSH
66056: LD_VAR 0 1
66060: PPUSH
66061: CALL_OW 476
66065: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66066: LD_ADDR_VAR 0 12
66070: PUSH
66071: LD_VAR 0 1
66075: PPUSH
66076: CALL_OW 477
66080: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66081: LD_ADDR_VAR 0 10
66085: PUSH
66086: LD_VAR 0 1
66090: PPUSH
66091: CALL_OW 478
66095: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66096: LD_VAR 0 9
66100: NOT
66101: PUSH
66102: LD_VAR 0 11
66106: NOT
66107: OR
66108: PUSH
66109: LD_VAR 0 12
66113: NOT
66114: OR
66115: PUSH
66116: LD_VAR 0 10
66120: NOT
66121: OR
66122: IFFALSE 66157
// begin result := [ chassis , engine , control , weapon ] ;
66124: LD_ADDR_VAR 0 6
66128: PUSH
66129: LD_VAR 0 2
66133: PUSH
66134: LD_VAR 0 3
66138: PUSH
66139: LD_VAR 0 4
66143: PUSH
66144: LD_VAR 0 5
66148: PUSH
66149: EMPTY
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: ST_TO_ADDR
// exit ;
66155: GO 66448
// end ; if not chassis in _chassis then
66157: LD_VAR 0 2
66161: PUSH
66162: LD_VAR 0 9
66166: IN
66167: NOT
66168: IFFALSE 66194
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66170: LD_ADDR_VAR 0 2
66174: PUSH
66175: LD_VAR 0 9
66179: PUSH
66180: LD_INT 1
66182: PPUSH
66183: LD_VAR 0 9
66187: PPUSH
66188: CALL_OW 12
66192: ARRAY
66193: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66194: LD_VAR 0 2
66198: PPUSH
66199: LD_VAR 0 3
66203: PPUSH
66204: CALL 66453 0 2
66208: NOT
66209: IFFALSE 66268
// repeat engine := _engine [ 1 ] ;
66211: LD_ADDR_VAR 0 3
66215: PUSH
66216: LD_VAR 0 11
66220: PUSH
66221: LD_INT 1
66223: ARRAY
66224: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66225: LD_ADDR_VAR 0 11
66229: PUSH
66230: LD_VAR 0 11
66234: PPUSH
66235: LD_INT 1
66237: PPUSH
66238: CALL_OW 3
66242: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66243: LD_VAR 0 2
66247: PPUSH
66248: LD_VAR 0 3
66252: PPUSH
66253: CALL 66453 0 2
66257: PUSH
66258: LD_VAR 0 11
66262: PUSH
66263: EMPTY
66264: EQUAL
66265: OR
66266: IFFALSE 66211
// if not control in _control then
66268: LD_VAR 0 4
66272: PUSH
66273: LD_VAR 0 12
66277: IN
66278: NOT
66279: IFFALSE 66305
// control := _control [ rand ( 1 , _control ) ] ;
66281: LD_ADDR_VAR 0 4
66285: PUSH
66286: LD_VAR 0 12
66290: PUSH
66291: LD_INT 1
66293: PPUSH
66294: LD_VAR 0 12
66298: PPUSH
66299: CALL_OW 12
66303: ARRAY
66304: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66305: LD_VAR 0 2
66309: PPUSH
66310: LD_VAR 0 5
66314: PPUSH
66315: CALL 66673 0 2
66319: NOT
66320: IFFALSE 66379
// repeat weapon := _weapon [ 1 ] ;
66322: LD_ADDR_VAR 0 5
66326: PUSH
66327: LD_VAR 0 10
66331: PUSH
66332: LD_INT 1
66334: ARRAY
66335: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66336: LD_ADDR_VAR 0 10
66340: PUSH
66341: LD_VAR 0 10
66345: PPUSH
66346: LD_INT 1
66348: PPUSH
66349: CALL_OW 3
66353: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66354: LD_VAR 0 2
66358: PPUSH
66359: LD_VAR 0 5
66363: PPUSH
66364: CALL 66673 0 2
66368: PUSH
66369: LD_VAR 0 10
66373: PUSH
66374: EMPTY
66375: EQUAL
66376: OR
66377: IFFALSE 66322
// result := [ ] ;
66379: LD_ADDR_VAR 0 6
66383: PUSH
66384: EMPTY
66385: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66386: LD_VAR 0 1
66390: PPUSH
66391: LD_VAR 0 2
66395: PPUSH
66396: LD_VAR 0 3
66400: PPUSH
66401: LD_VAR 0 4
66405: PPUSH
66406: LD_VAR 0 5
66410: PPUSH
66411: CALL_OW 448
66415: IFFALSE 66448
// result := [ chassis , engine , control , weapon ] ;
66417: LD_ADDR_VAR 0 6
66421: PUSH
66422: LD_VAR 0 2
66426: PUSH
66427: LD_VAR 0 3
66431: PUSH
66432: LD_VAR 0 4
66436: PUSH
66437: LD_VAR 0 5
66441: PUSH
66442: EMPTY
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: ST_TO_ADDR
// end ;
66448: LD_VAR 0 6
66452: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66453: LD_INT 0
66455: PPUSH
// if not chassis or not engine then
66456: LD_VAR 0 1
66460: NOT
66461: PUSH
66462: LD_VAR 0 2
66466: NOT
66467: OR
66468: IFFALSE 66472
// exit ;
66470: GO 66668
// case engine of engine_solar :
66472: LD_VAR 0 2
66476: PUSH
66477: LD_INT 2
66479: DOUBLE
66480: EQUAL
66481: IFTRUE 66485
66483: GO 66523
66485: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66486: LD_ADDR_VAR 0 3
66490: PUSH
66491: LD_INT 11
66493: PUSH
66494: LD_INT 12
66496: PUSH
66497: LD_INT 13
66499: PUSH
66500: LD_INT 14
66502: PUSH
66503: LD_INT 1
66505: PUSH
66506: LD_INT 2
66508: PUSH
66509: LD_INT 3
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: ST_TO_ADDR
66521: GO 66652
66523: LD_INT 1
66525: DOUBLE
66526: EQUAL
66527: IFTRUE 66531
66529: GO 66593
66531: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66532: LD_ADDR_VAR 0 3
66536: PUSH
66537: LD_INT 11
66539: PUSH
66540: LD_INT 12
66542: PUSH
66543: LD_INT 13
66545: PUSH
66546: LD_INT 14
66548: PUSH
66549: LD_INT 1
66551: PUSH
66552: LD_INT 2
66554: PUSH
66555: LD_INT 3
66557: PUSH
66558: LD_INT 4
66560: PUSH
66561: LD_INT 5
66563: PUSH
66564: LD_INT 21
66566: PUSH
66567: LD_INT 23
66569: PUSH
66570: LD_INT 22
66572: PUSH
66573: LD_INT 24
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: LIST
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: LIST
66585: LIST
66586: LIST
66587: LIST
66588: LIST
66589: LIST
66590: ST_TO_ADDR
66591: GO 66652
66593: LD_INT 3
66595: DOUBLE
66596: EQUAL
66597: IFTRUE 66601
66599: GO 66651
66601: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66602: LD_ADDR_VAR 0 3
66606: PUSH
66607: LD_INT 13
66609: PUSH
66610: LD_INT 14
66612: PUSH
66613: LD_INT 2
66615: PUSH
66616: LD_INT 3
66618: PUSH
66619: LD_INT 4
66621: PUSH
66622: LD_INT 5
66624: PUSH
66625: LD_INT 21
66627: PUSH
66628: LD_INT 22
66630: PUSH
66631: LD_INT 23
66633: PUSH
66634: LD_INT 24
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: ST_TO_ADDR
66649: GO 66652
66651: POP
// result := ( chassis in result ) ;
66652: LD_ADDR_VAR 0 3
66656: PUSH
66657: LD_VAR 0 1
66661: PUSH
66662: LD_VAR 0 3
66666: IN
66667: ST_TO_ADDR
// end ;
66668: LD_VAR 0 3
66672: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66673: LD_INT 0
66675: PPUSH
// if not chassis or not weapon then
66676: LD_VAR 0 1
66680: NOT
66681: PUSH
66682: LD_VAR 0 2
66686: NOT
66687: OR
66688: IFFALSE 66692
// exit ;
66690: GO 67752
// case weapon of us_machine_gun :
66692: LD_VAR 0 2
66696: PUSH
66697: LD_INT 2
66699: DOUBLE
66700: EQUAL
66701: IFTRUE 66705
66703: GO 66735
66705: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66706: LD_ADDR_VAR 0 3
66710: PUSH
66711: LD_INT 1
66713: PUSH
66714: LD_INT 2
66716: PUSH
66717: LD_INT 3
66719: PUSH
66720: LD_INT 4
66722: PUSH
66723: LD_INT 5
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: ST_TO_ADDR
66733: GO 67736
66735: LD_INT 3
66737: DOUBLE
66738: EQUAL
66739: IFTRUE 66743
66741: GO 66773
66743: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66744: LD_ADDR_VAR 0 3
66748: PUSH
66749: LD_INT 1
66751: PUSH
66752: LD_INT 2
66754: PUSH
66755: LD_INT 3
66757: PUSH
66758: LD_INT 4
66760: PUSH
66761: LD_INT 5
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: LIST
66770: ST_TO_ADDR
66771: GO 67736
66773: LD_INT 11
66775: DOUBLE
66776: EQUAL
66777: IFTRUE 66781
66779: GO 66811
66781: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66782: LD_ADDR_VAR 0 3
66786: PUSH
66787: LD_INT 1
66789: PUSH
66790: LD_INT 2
66792: PUSH
66793: LD_INT 3
66795: PUSH
66796: LD_INT 4
66798: PUSH
66799: LD_INT 5
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: ST_TO_ADDR
66809: GO 67736
66811: LD_INT 4
66813: DOUBLE
66814: EQUAL
66815: IFTRUE 66819
66817: GO 66845
66819: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66820: LD_ADDR_VAR 0 3
66824: PUSH
66825: LD_INT 2
66827: PUSH
66828: LD_INT 3
66830: PUSH
66831: LD_INT 4
66833: PUSH
66834: LD_INT 5
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: ST_TO_ADDR
66843: GO 67736
66845: LD_INT 5
66847: DOUBLE
66848: EQUAL
66849: IFTRUE 66853
66851: GO 66879
66853: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66854: LD_ADDR_VAR 0 3
66858: PUSH
66859: LD_INT 2
66861: PUSH
66862: LD_INT 3
66864: PUSH
66865: LD_INT 4
66867: PUSH
66868: LD_INT 5
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: LIST
66875: LIST
66876: ST_TO_ADDR
66877: GO 67736
66879: LD_INT 9
66881: DOUBLE
66882: EQUAL
66883: IFTRUE 66887
66885: GO 66913
66887: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
66888: LD_ADDR_VAR 0 3
66892: PUSH
66893: LD_INT 2
66895: PUSH
66896: LD_INT 3
66898: PUSH
66899: LD_INT 4
66901: PUSH
66902: LD_INT 5
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: ST_TO_ADDR
66911: GO 67736
66913: LD_INT 7
66915: DOUBLE
66916: EQUAL
66917: IFTRUE 66921
66919: GO 66947
66921: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
66922: LD_ADDR_VAR 0 3
66926: PUSH
66927: LD_INT 2
66929: PUSH
66930: LD_INT 3
66932: PUSH
66933: LD_INT 4
66935: PUSH
66936: LD_INT 5
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: ST_TO_ADDR
66945: GO 67736
66947: LD_INT 12
66949: DOUBLE
66950: EQUAL
66951: IFTRUE 66955
66953: GO 66981
66955: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66956: LD_ADDR_VAR 0 3
66960: PUSH
66961: LD_INT 2
66963: PUSH
66964: LD_INT 3
66966: PUSH
66967: LD_INT 4
66969: PUSH
66970: LD_INT 5
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: LIST
66977: LIST
66978: ST_TO_ADDR
66979: GO 67736
66981: LD_INT 13
66983: DOUBLE
66984: EQUAL
66985: IFTRUE 66989
66987: GO 67015
66989: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
66990: LD_ADDR_VAR 0 3
66994: PUSH
66995: LD_INT 2
66997: PUSH
66998: LD_INT 3
67000: PUSH
67001: LD_INT 4
67003: PUSH
67004: LD_INT 5
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: ST_TO_ADDR
67013: GO 67736
67015: LD_INT 14
67017: DOUBLE
67018: EQUAL
67019: IFTRUE 67023
67021: GO 67041
67023: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67024: LD_ADDR_VAR 0 3
67028: PUSH
67029: LD_INT 4
67031: PUSH
67032: LD_INT 5
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: ST_TO_ADDR
67039: GO 67736
67041: LD_INT 6
67043: DOUBLE
67044: EQUAL
67045: IFTRUE 67049
67047: GO 67067
67049: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67050: LD_ADDR_VAR 0 3
67054: PUSH
67055: LD_INT 4
67057: PUSH
67058: LD_INT 5
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: ST_TO_ADDR
67065: GO 67736
67067: LD_INT 10
67069: DOUBLE
67070: EQUAL
67071: IFTRUE 67075
67073: GO 67093
67075: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67076: LD_ADDR_VAR 0 3
67080: PUSH
67081: LD_INT 4
67083: PUSH
67084: LD_INT 5
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: ST_TO_ADDR
67091: GO 67736
67093: LD_INT 22
67095: DOUBLE
67096: EQUAL
67097: IFTRUE 67101
67099: GO 67127
67101: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67102: LD_ADDR_VAR 0 3
67106: PUSH
67107: LD_INT 11
67109: PUSH
67110: LD_INT 12
67112: PUSH
67113: LD_INT 13
67115: PUSH
67116: LD_INT 14
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: LIST
67123: LIST
67124: ST_TO_ADDR
67125: GO 67736
67127: LD_INT 23
67129: DOUBLE
67130: EQUAL
67131: IFTRUE 67135
67133: GO 67161
67135: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67136: LD_ADDR_VAR 0 3
67140: PUSH
67141: LD_INT 11
67143: PUSH
67144: LD_INT 12
67146: PUSH
67147: LD_INT 13
67149: PUSH
67150: LD_INT 14
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: ST_TO_ADDR
67159: GO 67736
67161: LD_INT 24
67163: DOUBLE
67164: EQUAL
67165: IFTRUE 67169
67167: GO 67195
67169: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67170: LD_ADDR_VAR 0 3
67174: PUSH
67175: LD_INT 11
67177: PUSH
67178: LD_INT 12
67180: PUSH
67181: LD_INT 13
67183: PUSH
67184: LD_INT 14
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: ST_TO_ADDR
67193: GO 67736
67195: LD_INT 30
67197: DOUBLE
67198: EQUAL
67199: IFTRUE 67203
67201: GO 67229
67203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67204: LD_ADDR_VAR 0 3
67208: PUSH
67209: LD_INT 11
67211: PUSH
67212: LD_INT 12
67214: PUSH
67215: LD_INT 13
67217: PUSH
67218: LD_INT 14
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: LIST
67225: LIST
67226: ST_TO_ADDR
67227: GO 67736
67229: LD_INT 25
67231: DOUBLE
67232: EQUAL
67233: IFTRUE 67237
67235: GO 67255
67237: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67238: LD_ADDR_VAR 0 3
67242: PUSH
67243: LD_INT 13
67245: PUSH
67246: LD_INT 14
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: ST_TO_ADDR
67253: GO 67736
67255: LD_INT 27
67257: DOUBLE
67258: EQUAL
67259: IFTRUE 67263
67261: GO 67281
67263: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67264: LD_ADDR_VAR 0 3
67268: PUSH
67269: LD_INT 13
67271: PUSH
67272: LD_INT 14
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: ST_TO_ADDR
67279: GO 67736
67281: LD_INT 92
67283: DOUBLE
67284: EQUAL
67285: IFTRUE 67289
67287: GO 67315
67289: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67290: LD_ADDR_VAR 0 3
67294: PUSH
67295: LD_INT 11
67297: PUSH
67298: LD_INT 12
67300: PUSH
67301: LD_INT 13
67303: PUSH
67304: LD_INT 14
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: ST_TO_ADDR
67313: GO 67736
67315: LD_INT 28
67317: DOUBLE
67318: EQUAL
67319: IFTRUE 67323
67321: GO 67341
67323: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67324: LD_ADDR_VAR 0 3
67328: PUSH
67329: LD_INT 13
67331: PUSH
67332: LD_INT 14
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: ST_TO_ADDR
67339: GO 67736
67341: LD_INT 29
67343: DOUBLE
67344: EQUAL
67345: IFTRUE 67349
67347: GO 67367
67349: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67350: LD_ADDR_VAR 0 3
67354: PUSH
67355: LD_INT 13
67357: PUSH
67358: LD_INT 14
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: ST_TO_ADDR
67365: GO 67736
67367: LD_INT 31
67369: DOUBLE
67370: EQUAL
67371: IFTRUE 67375
67373: GO 67393
67375: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67376: LD_ADDR_VAR 0 3
67380: PUSH
67381: LD_INT 13
67383: PUSH
67384: LD_INT 14
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: ST_TO_ADDR
67391: GO 67736
67393: LD_INT 26
67395: DOUBLE
67396: EQUAL
67397: IFTRUE 67401
67399: GO 67419
67401: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67402: LD_ADDR_VAR 0 3
67406: PUSH
67407: LD_INT 13
67409: PUSH
67410: LD_INT 14
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: ST_TO_ADDR
67417: GO 67736
67419: LD_INT 42
67421: DOUBLE
67422: EQUAL
67423: IFTRUE 67427
67425: GO 67453
67427: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67428: LD_ADDR_VAR 0 3
67432: PUSH
67433: LD_INT 21
67435: PUSH
67436: LD_INT 22
67438: PUSH
67439: LD_INT 23
67441: PUSH
67442: LD_INT 24
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: LIST
67449: LIST
67450: ST_TO_ADDR
67451: GO 67736
67453: LD_INT 43
67455: DOUBLE
67456: EQUAL
67457: IFTRUE 67461
67459: GO 67487
67461: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67462: LD_ADDR_VAR 0 3
67466: PUSH
67467: LD_INT 21
67469: PUSH
67470: LD_INT 22
67472: PUSH
67473: LD_INT 23
67475: PUSH
67476: LD_INT 24
67478: PUSH
67479: EMPTY
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: ST_TO_ADDR
67485: GO 67736
67487: LD_INT 44
67489: DOUBLE
67490: EQUAL
67491: IFTRUE 67495
67493: GO 67521
67495: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67496: LD_ADDR_VAR 0 3
67500: PUSH
67501: LD_INT 21
67503: PUSH
67504: LD_INT 22
67506: PUSH
67507: LD_INT 23
67509: PUSH
67510: LD_INT 24
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: LIST
67517: LIST
67518: ST_TO_ADDR
67519: GO 67736
67521: LD_INT 45
67523: DOUBLE
67524: EQUAL
67525: IFTRUE 67529
67527: GO 67555
67529: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67530: LD_ADDR_VAR 0 3
67534: PUSH
67535: LD_INT 21
67537: PUSH
67538: LD_INT 22
67540: PUSH
67541: LD_INT 23
67543: PUSH
67544: LD_INT 24
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: LIST
67551: LIST
67552: ST_TO_ADDR
67553: GO 67736
67555: LD_INT 49
67557: DOUBLE
67558: EQUAL
67559: IFTRUE 67563
67561: GO 67589
67563: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67564: LD_ADDR_VAR 0 3
67568: PUSH
67569: LD_INT 21
67571: PUSH
67572: LD_INT 22
67574: PUSH
67575: LD_INT 23
67577: PUSH
67578: LD_INT 24
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: ST_TO_ADDR
67587: GO 67736
67589: LD_INT 51
67591: DOUBLE
67592: EQUAL
67593: IFTRUE 67597
67595: GO 67623
67597: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67598: LD_ADDR_VAR 0 3
67602: PUSH
67603: LD_INT 21
67605: PUSH
67606: LD_INT 22
67608: PUSH
67609: LD_INT 23
67611: PUSH
67612: LD_INT 24
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: ST_TO_ADDR
67621: GO 67736
67623: LD_INT 52
67625: DOUBLE
67626: EQUAL
67627: IFTRUE 67631
67629: GO 67657
67631: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67632: LD_ADDR_VAR 0 3
67636: PUSH
67637: LD_INT 21
67639: PUSH
67640: LD_INT 22
67642: PUSH
67643: LD_INT 23
67645: PUSH
67646: LD_INT 24
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: ST_TO_ADDR
67655: GO 67736
67657: LD_INT 53
67659: DOUBLE
67660: EQUAL
67661: IFTRUE 67665
67663: GO 67683
67665: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67666: LD_ADDR_VAR 0 3
67670: PUSH
67671: LD_INT 23
67673: PUSH
67674: LD_INT 24
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: ST_TO_ADDR
67681: GO 67736
67683: LD_INT 46
67685: DOUBLE
67686: EQUAL
67687: IFTRUE 67691
67689: GO 67709
67691: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67692: LD_ADDR_VAR 0 3
67696: PUSH
67697: LD_INT 23
67699: PUSH
67700: LD_INT 24
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: ST_TO_ADDR
67707: GO 67736
67709: LD_INT 47
67711: DOUBLE
67712: EQUAL
67713: IFTRUE 67717
67715: GO 67735
67717: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67718: LD_ADDR_VAR 0 3
67722: PUSH
67723: LD_INT 23
67725: PUSH
67726: LD_INT 24
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: ST_TO_ADDR
67733: GO 67736
67735: POP
// result := ( chassis in result ) ;
67736: LD_ADDR_VAR 0 3
67740: PUSH
67741: LD_VAR 0 1
67745: PUSH
67746: LD_VAR 0 3
67750: IN
67751: ST_TO_ADDR
// end ;
67752: LD_VAR 0 3
67756: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67757: LD_INT 0
67759: PPUSH
67760: PPUSH
67761: PPUSH
67762: PPUSH
67763: PPUSH
67764: PPUSH
67765: PPUSH
// result := array ;
67766: LD_ADDR_VAR 0 5
67770: PUSH
67771: LD_VAR 0 1
67775: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67776: LD_VAR 0 1
67780: NOT
67781: PUSH
67782: LD_VAR 0 2
67786: NOT
67787: OR
67788: PUSH
67789: LD_VAR 0 3
67793: NOT
67794: OR
67795: PUSH
67796: LD_VAR 0 2
67800: PUSH
67801: LD_VAR 0 1
67805: GREATER
67806: OR
67807: PUSH
67808: LD_VAR 0 3
67812: PUSH
67813: LD_VAR 0 1
67817: GREATER
67818: OR
67819: IFFALSE 67823
// exit ;
67821: GO 68119
// if direction then
67823: LD_VAR 0 4
67827: IFFALSE 67891
// begin d := 1 ;
67829: LD_ADDR_VAR 0 9
67833: PUSH
67834: LD_INT 1
67836: ST_TO_ADDR
// if i_from > i_to then
67837: LD_VAR 0 2
67841: PUSH
67842: LD_VAR 0 3
67846: GREATER
67847: IFFALSE 67873
// length := ( array - i_from ) + i_to else
67849: LD_ADDR_VAR 0 11
67853: PUSH
67854: LD_VAR 0 1
67858: PUSH
67859: LD_VAR 0 2
67863: MINUS
67864: PUSH
67865: LD_VAR 0 3
67869: PLUS
67870: ST_TO_ADDR
67871: GO 67889
// length := i_to - i_from ;
67873: LD_ADDR_VAR 0 11
67877: PUSH
67878: LD_VAR 0 3
67882: PUSH
67883: LD_VAR 0 2
67887: MINUS
67888: ST_TO_ADDR
// end else
67889: GO 67952
// begin d := - 1 ;
67891: LD_ADDR_VAR 0 9
67895: PUSH
67896: LD_INT 1
67898: NEG
67899: ST_TO_ADDR
// if i_from > i_to then
67900: LD_VAR 0 2
67904: PUSH
67905: LD_VAR 0 3
67909: GREATER
67910: IFFALSE 67930
// length := i_from - i_to else
67912: LD_ADDR_VAR 0 11
67916: PUSH
67917: LD_VAR 0 2
67921: PUSH
67922: LD_VAR 0 3
67926: MINUS
67927: ST_TO_ADDR
67928: GO 67952
// length := ( array - i_to ) + i_from ;
67930: LD_ADDR_VAR 0 11
67934: PUSH
67935: LD_VAR 0 1
67939: PUSH
67940: LD_VAR 0 3
67944: MINUS
67945: PUSH
67946: LD_VAR 0 2
67950: PLUS
67951: ST_TO_ADDR
// end ; if not length then
67952: LD_VAR 0 11
67956: NOT
67957: IFFALSE 67961
// exit ;
67959: GO 68119
// tmp := array ;
67961: LD_ADDR_VAR 0 10
67965: PUSH
67966: LD_VAR 0 1
67970: ST_TO_ADDR
// for i = 1 to length do
67971: LD_ADDR_VAR 0 6
67975: PUSH
67976: DOUBLE
67977: LD_INT 1
67979: DEC
67980: ST_TO_ADDR
67981: LD_VAR 0 11
67985: PUSH
67986: FOR_TO
67987: IFFALSE 68107
// begin for j = 1 to array do
67989: LD_ADDR_VAR 0 7
67993: PUSH
67994: DOUBLE
67995: LD_INT 1
67997: DEC
67998: ST_TO_ADDR
67999: LD_VAR 0 1
68003: PUSH
68004: FOR_TO
68005: IFFALSE 68093
// begin k := j + d ;
68007: LD_ADDR_VAR 0 8
68011: PUSH
68012: LD_VAR 0 7
68016: PUSH
68017: LD_VAR 0 9
68021: PLUS
68022: ST_TO_ADDR
// if k > array then
68023: LD_VAR 0 8
68027: PUSH
68028: LD_VAR 0 1
68032: GREATER
68033: IFFALSE 68043
// k := 1 ;
68035: LD_ADDR_VAR 0 8
68039: PUSH
68040: LD_INT 1
68042: ST_TO_ADDR
// if not k then
68043: LD_VAR 0 8
68047: NOT
68048: IFFALSE 68060
// k := array ;
68050: LD_ADDR_VAR 0 8
68054: PUSH
68055: LD_VAR 0 1
68059: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68060: LD_ADDR_VAR 0 10
68064: PUSH
68065: LD_VAR 0 10
68069: PPUSH
68070: LD_VAR 0 8
68074: PPUSH
68075: LD_VAR 0 1
68079: PUSH
68080: LD_VAR 0 7
68084: ARRAY
68085: PPUSH
68086: CALL_OW 1
68090: ST_TO_ADDR
// end ;
68091: GO 68004
68093: POP
68094: POP
// array := tmp ;
68095: LD_ADDR_VAR 0 1
68099: PUSH
68100: LD_VAR 0 10
68104: ST_TO_ADDR
// end ;
68105: GO 67986
68107: POP
68108: POP
// result := array ;
68109: LD_ADDR_VAR 0 5
68113: PUSH
68114: LD_VAR 0 1
68118: ST_TO_ADDR
// end ;
68119: LD_VAR 0 5
68123: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68124: LD_INT 0
68126: PPUSH
68127: PPUSH
// result := 0 ;
68128: LD_ADDR_VAR 0 3
68132: PUSH
68133: LD_INT 0
68135: ST_TO_ADDR
// if not array or not value in array then
68136: LD_VAR 0 1
68140: NOT
68141: PUSH
68142: LD_VAR 0 2
68146: PUSH
68147: LD_VAR 0 1
68151: IN
68152: NOT
68153: OR
68154: IFFALSE 68158
// exit ;
68156: GO 68212
// for i = 1 to array do
68158: LD_ADDR_VAR 0 4
68162: PUSH
68163: DOUBLE
68164: LD_INT 1
68166: DEC
68167: ST_TO_ADDR
68168: LD_VAR 0 1
68172: PUSH
68173: FOR_TO
68174: IFFALSE 68210
// if value = array [ i ] then
68176: LD_VAR 0 2
68180: PUSH
68181: LD_VAR 0 1
68185: PUSH
68186: LD_VAR 0 4
68190: ARRAY
68191: EQUAL
68192: IFFALSE 68208
// begin result := i ;
68194: LD_ADDR_VAR 0 3
68198: PUSH
68199: LD_VAR 0 4
68203: ST_TO_ADDR
// exit ;
68204: POP
68205: POP
68206: GO 68212
// end ;
68208: GO 68173
68210: POP
68211: POP
// end ;
68212: LD_VAR 0 3
68216: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68217: LD_INT 0
68219: PPUSH
// vc_chassis := chassis ;
68220: LD_ADDR_OWVAR 37
68224: PUSH
68225: LD_VAR 0 1
68229: ST_TO_ADDR
// vc_engine := engine ;
68230: LD_ADDR_OWVAR 39
68234: PUSH
68235: LD_VAR 0 2
68239: ST_TO_ADDR
// vc_control := control ;
68240: LD_ADDR_OWVAR 38
68244: PUSH
68245: LD_VAR 0 3
68249: ST_TO_ADDR
// vc_weapon := weapon ;
68250: LD_ADDR_OWVAR 40
68254: PUSH
68255: LD_VAR 0 4
68259: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68260: LD_ADDR_OWVAR 41
68264: PUSH
68265: LD_VAR 0 5
68269: ST_TO_ADDR
// end ;
68270: LD_VAR 0 6
68274: RET
// export function WantPlant ( unit ) ; var task ; begin
68275: LD_INT 0
68277: PPUSH
68278: PPUSH
// result := false ;
68279: LD_ADDR_VAR 0 2
68283: PUSH
68284: LD_INT 0
68286: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68287: LD_ADDR_VAR 0 3
68291: PUSH
68292: LD_VAR 0 1
68296: PPUSH
68297: CALL_OW 437
68301: ST_TO_ADDR
// if task then
68302: LD_VAR 0 3
68306: IFFALSE 68334
// if task [ 1 ] [ 1 ] = p then
68308: LD_VAR 0 3
68312: PUSH
68313: LD_INT 1
68315: ARRAY
68316: PUSH
68317: LD_INT 1
68319: ARRAY
68320: PUSH
68321: LD_STRING p
68323: EQUAL
68324: IFFALSE 68334
// result := true ;
68326: LD_ADDR_VAR 0 2
68330: PUSH
68331: LD_INT 1
68333: ST_TO_ADDR
// end ;
68334: LD_VAR 0 2
68338: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68339: LD_INT 0
68341: PPUSH
68342: PPUSH
68343: PPUSH
68344: PPUSH
// if pos < 1 then
68345: LD_VAR 0 2
68349: PUSH
68350: LD_INT 1
68352: LESS
68353: IFFALSE 68357
// exit ;
68355: GO 68660
// if pos = 1 then
68357: LD_VAR 0 2
68361: PUSH
68362: LD_INT 1
68364: EQUAL
68365: IFFALSE 68398
// result := Replace ( arr , pos [ 1 ] , value ) else
68367: LD_ADDR_VAR 0 4
68371: PUSH
68372: LD_VAR 0 1
68376: PPUSH
68377: LD_VAR 0 2
68381: PUSH
68382: LD_INT 1
68384: ARRAY
68385: PPUSH
68386: LD_VAR 0 3
68390: PPUSH
68391: CALL_OW 1
68395: ST_TO_ADDR
68396: GO 68660
// begin tmp := arr ;
68398: LD_ADDR_VAR 0 6
68402: PUSH
68403: LD_VAR 0 1
68407: ST_TO_ADDR
// s_arr := [ tmp ] ;
68408: LD_ADDR_VAR 0 7
68412: PUSH
68413: LD_VAR 0 6
68417: PUSH
68418: EMPTY
68419: LIST
68420: ST_TO_ADDR
// for i = 1 to pos - 1 do
68421: LD_ADDR_VAR 0 5
68425: PUSH
68426: DOUBLE
68427: LD_INT 1
68429: DEC
68430: ST_TO_ADDR
68431: LD_VAR 0 2
68435: PUSH
68436: LD_INT 1
68438: MINUS
68439: PUSH
68440: FOR_TO
68441: IFFALSE 68486
// begin tmp := tmp [ pos [ i ] ] ;
68443: LD_ADDR_VAR 0 6
68447: PUSH
68448: LD_VAR 0 6
68452: PUSH
68453: LD_VAR 0 2
68457: PUSH
68458: LD_VAR 0 5
68462: ARRAY
68463: ARRAY
68464: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68465: LD_ADDR_VAR 0 7
68469: PUSH
68470: LD_VAR 0 7
68474: PUSH
68475: LD_VAR 0 6
68479: PUSH
68480: EMPTY
68481: LIST
68482: ADD
68483: ST_TO_ADDR
// end ;
68484: GO 68440
68486: POP
68487: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68488: LD_ADDR_VAR 0 6
68492: PUSH
68493: LD_VAR 0 6
68497: PPUSH
68498: LD_VAR 0 2
68502: PUSH
68503: LD_VAR 0 2
68507: ARRAY
68508: PPUSH
68509: LD_VAR 0 3
68513: PPUSH
68514: CALL_OW 1
68518: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68519: LD_ADDR_VAR 0 7
68523: PUSH
68524: LD_VAR 0 7
68528: PPUSH
68529: LD_VAR 0 7
68533: PPUSH
68534: LD_VAR 0 6
68538: PPUSH
68539: CALL_OW 1
68543: ST_TO_ADDR
// for i = s_arr downto 2 do
68544: LD_ADDR_VAR 0 5
68548: PUSH
68549: DOUBLE
68550: LD_VAR 0 7
68554: INC
68555: ST_TO_ADDR
68556: LD_INT 2
68558: PUSH
68559: FOR_DOWNTO
68560: IFFALSE 68644
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68562: LD_ADDR_VAR 0 6
68566: PUSH
68567: LD_VAR 0 7
68571: PUSH
68572: LD_VAR 0 5
68576: PUSH
68577: LD_INT 1
68579: MINUS
68580: ARRAY
68581: PPUSH
68582: LD_VAR 0 2
68586: PUSH
68587: LD_VAR 0 5
68591: PUSH
68592: LD_INT 1
68594: MINUS
68595: ARRAY
68596: PPUSH
68597: LD_VAR 0 7
68601: PUSH
68602: LD_VAR 0 5
68606: ARRAY
68607: PPUSH
68608: CALL_OW 1
68612: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68613: LD_ADDR_VAR 0 7
68617: PUSH
68618: LD_VAR 0 7
68622: PPUSH
68623: LD_VAR 0 5
68627: PUSH
68628: LD_INT 1
68630: MINUS
68631: PPUSH
68632: LD_VAR 0 6
68636: PPUSH
68637: CALL_OW 1
68641: ST_TO_ADDR
// end ;
68642: GO 68559
68644: POP
68645: POP
// result := s_arr [ 1 ] ;
68646: LD_ADDR_VAR 0 4
68650: PUSH
68651: LD_VAR 0 7
68655: PUSH
68656: LD_INT 1
68658: ARRAY
68659: ST_TO_ADDR
// end ; end ;
68660: LD_VAR 0 4
68664: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68665: LD_INT 0
68667: PPUSH
68668: PPUSH
// if not list then
68669: LD_VAR 0 1
68673: NOT
68674: IFFALSE 68678
// exit ;
68676: GO 68769
// i := list [ pos1 ] ;
68678: LD_ADDR_VAR 0 5
68682: PUSH
68683: LD_VAR 0 1
68687: PUSH
68688: LD_VAR 0 2
68692: ARRAY
68693: ST_TO_ADDR
// if not i then
68694: LD_VAR 0 5
68698: NOT
68699: IFFALSE 68703
// exit ;
68701: GO 68769
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68703: LD_ADDR_VAR 0 1
68707: PUSH
68708: LD_VAR 0 1
68712: PPUSH
68713: LD_VAR 0 2
68717: PPUSH
68718: LD_VAR 0 1
68722: PUSH
68723: LD_VAR 0 3
68727: ARRAY
68728: PPUSH
68729: CALL_OW 1
68733: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68734: LD_ADDR_VAR 0 1
68738: PUSH
68739: LD_VAR 0 1
68743: PPUSH
68744: LD_VAR 0 3
68748: PPUSH
68749: LD_VAR 0 5
68753: PPUSH
68754: CALL_OW 1
68758: ST_TO_ADDR
// result := list ;
68759: LD_ADDR_VAR 0 4
68763: PUSH
68764: LD_VAR 0 1
68768: ST_TO_ADDR
// end ;
68769: LD_VAR 0 4
68773: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68774: LD_INT 0
68776: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68777: LD_ADDR_VAR 0 5
68781: PUSH
68782: LD_VAR 0 1
68786: PPUSH
68787: CALL_OW 250
68791: PPUSH
68792: LD_VAR 0 1
68796: PPUSH
68797: CALL_OW 251
68801: PPUSH
68802: LD_VAR 0 2
68806: PPUSH
68807: LD_VAR 0 3
68811: PPUSH
68812: LD_VAR 0 4
68816: PPUSH
68817: CALL 68827 0 5
68821: ST_TO_ADDR
// end ;
68822: LD_VAR 0 5
68826: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68827: LD_INT 0
68829: PPUSH
68830: PPUSH
68831: PPUSH
68832: PPUSH
// if not list then
68833: LD_VAR 0 3
68837: NOT
68838: IFFALSE 68842
// exit ;
68840: GO 69230
// result := [ ] ;
68842: LD_ADDR_VAR 0 6
68846: PUSH
68847: EMPTY
68848: ST_TO_ADDR
// for i in list do
68849: LD_ADDR_VAR 0 7
68853: PUSH
68854: LD_VAR 0 3
68858: PUSH
68859: FOR_IN
68860: IFFALSE 69062
// begin tmp := GetDistUnitXY ( i , x , y ) ;
68862: LD_ADDR_VAR 0 9
68866: PUSH
68867: LD_VAR 0 7
68871: PPUSH
68872: LD_VAR 0 1
68876: PPUSH
68877: LD_VAR 0 2
68881: PPUSH
68882: CALL_OW 297
68886: ST_TO_ADDR
// if not result then
68887: LD_VAR 0 6
68891: NOT
68892: IFFALSE 68918
// result := [ [ i , tmp ] ] else
68894: LD_ADDR_VAR 0 6
68898: PUSH
68899: LD_VAR 0 7
68903: PUSH
68904: LD_VAR 0 9
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: EMPTY
68914: LIST
68915: ST_TO_ADDR
68916: GO 69060
// begin if result [ result ] [ 2 ] < tmp then
68918: LD_VAR 0 6
68922: PUSH
68923: LD_VAR 0 6
68927: ARRAY
68928: PUSH
68929: LD_INT 2
68931: ARRAY
68932: PUSH
68933: LD_VAR 0 9
68937: LESS
68938: IFFALSE 68980
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
68940: LD_ADDR_VAR 0 6
68944: PUSH
68945: LD_VAR 0 6
68949: PPUSH
68950: LD_VAR 0 6
68954: PUSH
68955: LD_INT 1
68957: PLUS
68958: PPUSH
68959: LD_VAR 0 7
68963: PUSH
68964: LD_VAR 0 9
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PPUSH
68973: CALL_OW 2
68977: ST_TO_ADDR
68978: GO 69060
// for j = 1 to result do
68980: LD_ADDR_VAR 0 8
68984: PUSH
68985: DOUBLE
68986: LD_INT 1
68988: DEC
68989: ST_TO_ADDR
68990: LD_VAR 0 6
68994: PUSH
68995: FOR_TO
68996: IFFALSE 69058
// begin if tmp < result [ j ] [ 2 ] then
68998: LD_VAR 0 9
69002: PUSH
69003: LD_VAR 0 6
69007: PUSH
69008: LD_VAR 0 8
69012: ARRAY
69013: PUSH
69014: LD_INT 2
69016: ARRAY
69017: LESS
69018: IFFALSE 69056
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69020: LD_ADDR_VAR 0 6
69024: PUSH
69025: LD_VAR 0 6
69029: PPUSH
69030: LD_VAR 0 8
69034: PPUSH
69035: LD_VAR 0 7
69039: PUSH
69040: LD_VAR 0 9
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PPUSH
69049: CALL_OW 2
69053: ST_TO_ADDR
// break ;
69054: GO 69058
// end ; end ;
69056: GO 68995
69058: POP
69059: POP
// end ; end ;
69060: GO 68859
69062: POP
69063: POP
// if result and not asc then
69064: LD_VAR 0 6
69068: PUSH
69069: LD_VAR 0 4
69073: NOT
69074: AND
69075: IFFALSE 69150
// begin tmp := result ;
69077: LD_ADDR_VAR 0 9
69081: PUSH
69082: LD_VAR 0 6
69086: ST_TO_ADDR
// for i = tmp downto 1 do
69087: LD_ADDR_VAR 0 7
69091: PUSH
69092: DOUBLE
69093: LD_VAR 0 9
69097: INC
69098: ST_TO_ADDR
69099: LD_INT 1
69101: PUSH
69102: FOR_DOWNTO
69103: IFFALSE 69148
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69105: LD_ADDR_VAR 0 6
69109: PUSH
69110: LD_VAR 0 6
69114: PPUSH
69115: LD_VAR 0 9
69119: PUSH
69120: LD_VAR 0 7
69124: MINUS
69125: PUSH
69126: LD_INT 1
69128: PLUS
69129: PPUSH
69130: LD_VAR 0 9
69134: PUSH
69135: LD_VAR 0 7
69139: ARRAY
69140: PPUSH
69141: CALL_OW 1
69145: ST_TO_ADDR
69146: GO 69102
69148: POP
69149: POP
// end ; tmp := [ ] ;
69150: LD_ADDR_VAR 0 9
69154: PUSH
69155: EMPTY
69156: ST_TO_ADDR
// if mode then
69157: LD_VAR 0 5
69161: IFFALSE 69230
// begin for i = 1 to result do
69163: LD_ADDR_VAR 0 7
69167: PUSH
69168: DOUBLE
69169: LD_INT 1
69171: DEC
69172: ST_TO_ADDR
69173: LD_VAR 0 6
69177: PUSH
69178: FOR_TO
69179: IFFALSE 69218
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69181: LD_ADDR_VAR 0 9
69185: PUSH
69186: LD_VAR 0 9
69190: PPUSH
69191: LD_VAR 0 7
69195: PPUSH
69196: LD_VAR 0 6
69200: PUSH
69201: LD_VAR 0 7
69205: ARRAY
69206: PUSH
69207: LD_INT 1
69209: ARRAY
69210: PPUSH
69211: CALL_OW 1
69215: ST_TO_ADDR
69216: GO 69178
69218: POP
69219: POP
// result := tmp ;
69220: LD_ADDR_VAR 0 6
69224: PUSH
69225: LD_VAR 0 9
69229: ST_TO_ADDR
// end ; end ;
69230: LD_VAR 0 6
69234: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69235: LD_INT 0
69237: PPUSH
69238: PPUSH
69239: PPUSH
69240: PPUSH
69241: PPUSH
69242: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69243: LD_ADDR_VAR 0 5
69247: PUSH
69248: LD_INT 0
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: EMPTY
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: ST_TO_ADDR
// if not x or not y then
69265: LD_VAR 0 2
69269: NOT
69270: PUSH
69271: LD_VAR 0 3
69275: NOT
69276: OR
69277: IFFALSE 69281
// exit ;
69279: GO 70931
// if not range then
69281: LD_VAR 0 4
69285: NOT
69286: IFFALSE 69296
// range := 10 ;
69288: LD_ADDR_VAR 0 4
69292: PUSH
69293: LD_INT 10
69295: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69296: LD_ADDR_VAR 0 8
69300: PUSH
69301: LD_INT 81
69303: PUSH
69304: LD_VAR 0 1
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 92
69315: PUSH
69316: LD_VAR 0 2
69320: PUSH
69321: LD_VAR 0 3
69325: PUSH
69326: LD_VAR 0 4
69330: PUSH
69331: EMPTY
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 3
69339: PUSH
69340: LD_INT 21
69342: PUSH
69343: LD_INT 3
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: LIST
69358: PPUSH
69359: CALL_OW 69
69363: ST_TO_ADDR
// if not tmp then
69364: LD_VAR 0 8
69368: NOT
69369: IFFALSE 69373
// exit ;
69371: GO 70931
// for i in tmp do
69373: LD_ADDR_VAR 0 6
69377: PUSH
69378: LD_VAR 0 8
69382: PUSH
69383: FOR_IN
69384: IFFALSE 70906
// begin points := [ 0 , 0 , 0 ] ;
69386: LD_ADDR_VAR 0 9
69390: PUSH
69391: LD_INT 0
69393: PUSH
69394: LD_INT 0
69396: PUSH
69397: LD_INT 0
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: LIST
69404: ST_TO_ADDR
// bpoints := 1 ;
69405: LD_ADDR_VAR 0 10
69409: PUSH
69410: LD_INT 1
69412: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69413: LD_VAR 0 6
69417: PPUSH
69418: CALL_OW 247
69422: PUSH
69423: LD_INT 1
69425: DOUBLE
69426: EQUAL
69427: IFTRUE 69431
69429: GO 70009
69431: POP
// begin if GetClass ( i ) = 1 then
69432: LD_VAR 0 6
69436: PPUSH
69437: CALL_OW 257
69441: PUSH
69442: LD_INT 1
69444: EQUAL
69445: IFFALSE 69466
// points := [ 10 , 5 , 3 ] ;
69447: LD_ADDR_VAR 0 9
69451: PUSH
69452: LD_INT 10
69454: PUSH
69455: LD_INT 5
69457: PUSH
69458: LD_INT 3
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: LIST
69465: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69466: LD_VAR 0 6
69470: PPUSH
69471: CALL_OW 257
69475: PUSH
69476: LD_INT 2
69478: PUSH
69479: LD_INT 3
69481: PUSH
69482: LD_INT 4
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: LIST
69489: IN
69490: IFFALSE 69511
// points := [ 3 , 2 , 1 ] ;
69492: LD_ADDR_VAR 0 9
69496: PUSH
69497: LD_INT 3
69499: PUSH
69500: LD_INT 2
69502: PUSH
69503: LD_INT 1
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: LIST
69510: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69511: LD_VAR 0 6
69515: PPUSH
69516: CALL_OW 257
69520: PUSH
69521: LD_INT 5
69523: EQUAL
69524: IFFALSE 69545
// points := [ 130 , 5 , 2 ] ;
69526: LD_ADDR_VAR 0 9
69530: PUSH
69531: LD_INT 130
69533: PUSH
69534: LD_INT 5
69536: PUSH
69537: LD_INT 2
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: LIST
69544: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69545: LD_VAR 0 6
69549: PPUSH
69550: CALL_OW 257
69554: PUSH
69555: LD_INT 8
69557: EQUAL
69558: IFFALSE 69579
// points := [ 35 , 35 , 30 ] ;
69560: LD_ADDR_VAR 0 9
69564: PUSH
69565: LD_INT 35
69567: PUSH
69568: LD_INT 35
69570: PUSH
69571: LD_INT 30
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: LIST
69578: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69579: LD_VAR 0 6
69583: PPUSH
69584: CALL_OW 257
69588: PUSH
69589: LD_INT 9
69591: EQUAL
69592: IFFALSE 69613
// points := [ 20 , 55 , 40 ] ;
69594: LD_ADDR_VAR 0 9
69598: PUSH
69599: LD_INT 20
69601: PUSH
69602: LD_INT 55
69604: PUSH
69605: LD_INT 40
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: LIST
69612: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69613: LD_VAR 0 6
69617: PPUSH
69618: CALL_OW 257
69622: PUSH
69623: LD_INT 12
69625: PUSH
69626: LD_INT 16
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: IN
69633: IFFALSE 69654
// points := [ 5 , 3 , 2 ] ;
69635: LD_ADDR_VAR 0 9
69639: PUSH
69640: LD_INT 5
69642: PUSH
69643: LD_INT 3
69645: PUSH
69646: LD_INT 2
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: LIST
69653: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69654: LD_VAR 0 6
69658: PPUSH
69659: CALL_OW 257
69663: PUSH
69664: LD_INT 17
69666: EQUAL
69667: IFFALSE 69688
// points := [ 100 , 50 , 75 ] ;
69669: LD_ADDR_VAR 0 9
69673: PUSH
69674: LD_INT 100
69676: PUSH
69677: LD_INT 50
69679: PUSH
69680: LD_INT 75
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69688: LD_VAR 0 6
69692: PPUSH
69693: CALL_OW 257
69697: PUSH
69698: LD_INT 15
69700: EQUAL
69701: IFFALSE 69722
// points := [ 10 , 5 , 3 ] ;
69703: LD_ADDR_VAR 0 9
69707: PUSH
69708: LD_INT 10
69710: PUSH
69711: LD_INT 5
69713: PUSH
69714: LD_INT 3
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69722: LD_VAR 0 6
69726: PPUSH
69727: CALL_OW 257
69731: PUSH
69732: LD_INT 14
69734: EQUAL
69735: IFFALSE 69756
// points := [ 10 , 0 , 0 ] ;
69737: LD_ADDR_VAR 0 9
69741: PUSH
69742: LD_INT 10
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: LD_INT 0
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: LIST
69755: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69756: LD_VAR 0 6
69760: PPUSH
69761: CALL_OW 257
69765: PUSH
69766: LD_INT 11
69768: EQUAL
69769: IFFALSE 69790
// points := [ 30 , 10 , 5 ] ;
69771: LD_ADDR_VAR 0 9
69775: PUSH
69776: LD_INT 30
69778: PUSH
69779: LD_INT 10
69781: PUSH
69782: LD_INT 5
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: LIST
69789: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69790: LD_VAR 0 1
69794: PPUSH
69795: LD_INT 5
69797: PPUSH
69798: CALL_OW 321
69802: PUSH
69803: LD_INT 2
69805: EQUAL
69806: IFFALSE 69823
// bpoints := bpoints * 1.8 ;
69808: LD_ADDR_VAR 0 10
69812: PUSH
69813: LD_VAR 0 10
69817: PUSH
69818: LD_REAL  1.80000000000000E+0000
69821: MUL
69822: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69823: LD_VAR 0 6
69827: PPUSH
69828: CALL_OW 257
69832: PUSH
69833: LD_INT 1
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: LD_INT 3
69841: PUSH
69842: LD_INT 4
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: IN
69851: PUSH
69852: LD_VAR 0 1
69856: PPUSH
69857: LD_INT 51
69859: PPUSH
69860: CALL_OW 321
69864: PUSH
69865: LD_INT 2
69867: EQUAL
69868: AND
69869: IFFALSE 69886
// bpoints := bpoints * 1.2 ;
69871: LD_ADDR_VAR 0 10
69875: PUSH
69876: LD_VAR 0 10
69880: PUSH
69881: LD_REAL  1.20000000000000E+0000
69884: MUL
69885: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
69886: LD_VAR 0 6
69890: PPUSH
69891: CALL_OW 257
69895: PUSH
69896: LD_INT 5
69898: PUSH
69899: LD_INT 7
69901: PUSH
69902: LD_INT 9
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: LIST
69909: IN
69910: PUSH
69911: LD_VAR 0 1
69915: PPUSH
69916: LD_INT 52
69918: PPUSH
69919: CALL_OW 321
69923: PUSH
69924: LD_INT 2
69926: EQUAL
69927: AND
69928: IFFALSE 69945
// bpoints := bpoints * 1.5 ;
69930: LD_ADDR_VAR 0 10
69934: PUSH
69935: LD_VAR 0 10
69939: PUSH
69940: LD_REAL  1.50000000000000E+0000
69943: MUL
69944: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
69945: LD_VAR 0 1
69949: PPUSH
69950: LD_INT 66
69952: PPUSH
69953: CALL_OW 321
69957: PUSH
69958: LD_INT 2
69960: EQUAL
69961: IFFALSE 69978
// bpoints := bpoints * 1.1 ;
69963: LD_ADDR_VAR 0 10
69967: PUSH
69968: LD_VAR 0 10
69972: PUSH
69973: LD_REAL  1.10000000000000E+0000
69976: MUL
69977: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69978: LD_ADDR_VAR 0 10
69982: PUSH
69983: LD_VAR 0 10
69987: PUSH
69988: LD_VAR 0 6
69992: PPUSH
69993: LD_INT 1
69995: PPUSH
69996: CALL_OW 259
70000: PUSH
70001: LD_REAL  1.15000000000000E+0000
70004: MUL
70005: MUL
70006: ST_TO_ADDR
// end ; unit_vehicle :
70007: GO 70835
70009: LD_INT 2
70011: DOUBLE
70012: EQUAL
70013: IFTRUE 70017
70015: GO 70823
70017: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70018: LD_VAR 0 6
70022: PPUSH
70023: CALL_OW 264
70027: PUSH
70028: LD_INT 2
70030: PUSH
70031: LD_INT 42
70033: PUSH
70034: LD_INT 24
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: LIST
70041: IN
70042: IFFALSE 70063
// points := [ 25 , 5 , 3 ] ;
70044: LD_ADDR_VAR 0 9
70048: PUSH
70049: LD_INT 25
70051: PUSH
70052: LD_INT 5
70054: PUSH
70055: LD_INT 3
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: LIST
70062: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70063: LD_VAR 0 6
70067: PPUSH
70068: CALL_OW 264
70072: PUSH
70073: LD_INT 4
70075: PUSH
70076: LD_INT 43
70078: PUSH
70079: LD_INT 25
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: LIST
70086: IN
70087: IFFALSE 70108
// points := [ 40 , 15 , 5 ] ;
70089: LD_ADDR_VAR 0 9
70093: PUSH
70094: LD_INT 40
70096: PUSH
70097: LD_INT 15
70099: PUSH
70100: LD_INT 5
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: LIST
70107: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70108: LD_VAR 0 6
70112: PPUSH
70113: CALL_OW 264
70117: PUSH
70118: LD_INT 3
70120: PUSH
70121: LD_INT 23
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: IN
70128: IFFALSE 70149
// points := [ 7 , 25 , 8 ] ;
70130: LD_ADDR_VAR 0 9
70134: PUSH
70135: LD_INT 7
70137: PUSH
70138: LD_INT 25
70140: PUSH
70141: LD_INT 8
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: LIST
70148: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70149: LD_VAR 0 6
70153: PPUSH
70154: CALL_OW 264
70158: PUSH
70159: LD_INT 5
70161: PUSH
70162: LD_INT 27
70164: PUSH
70165: LD_INT 44
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: LIST
70172: IN
70173: IFFALSE 70194
// points := [ 14 , 50 , 16 ] ;
70175: LD_ADDR_VAR 0 9
70179: PUSH
70180: LD_INT 14
70182: PUSH
70183: LD_INT 50
70185: PUSH
70186: LD_INT 16
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: LIST
70193: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70194: LD_VAR 0 6
70198: PPUSH
70199: CALL_OW 264
70203: PUSH
70204: LD_INT 6
70206: PUSH
70207: LD_INT 46
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: IN
70214: IFFALSE 70235
// points := [ 32 , 120 , 70 ] ;
70216: LD_ADDR_VAR 0 9
70220: PUSH
70221: LD_INT 32
70223: PUSH
70224: LD_INT 120
70226: PUSH
70227: LD_INT 70
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: LIST
70234: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
70235: LD_VAR 0 6
70239: PPUSH
70240: CALL_OW 264
70244: PUSH
70245: LD_INT 7
70247: PUSH
70248: LD_INT 28
70250: PUSH
70251: LD_INT 45
70253: PUSH
70254: LD_INT 92
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: IN
70263: IFFALSE 70284
// points := [ 35 , 20 , 45 ] ;
70265: LD_ADDR_VAR 0 9
70269: PUSH
70270: LD_INT 35
70272: PUSH
70273: LD_INT 20
70275: PUSH
70276: LD_INT 45
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: LIST
70283: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70284: LD_VAR 0 6
70288: PPUSH
70289: CALL_OW 264
70293: PUSH
70294: LD_INT 47
70296: PUSH
70297: EMPTY
70298: LIST
70299: IN
70300: IFFALSE 70321
// points := [ 67 , 45 , 75 ] ;
70302: LD_ADDR_VAR 0 9
70306: PUSH
70307: LD_INT 67
70309: PUSH
70310: LD_INT 45
70312: PUSH
70313: LD_INT 75
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: LIST
70320: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70321: LD_VAR 0 6
70325: PPUSH
70326: CALL_OW 264
70330: PUSH
70331: LD_INT 26
70333: PUSH
70334: EMPTY
70335: LIST
70336: IN
70337: IFFALSE 70358
// points := [ 120 , 30 , 80 ] ;
70339: LD_ADDR_VAR 0 9
70343: PUSH
70344: LD_INT 120
70346: PUSH
70347: LD_INT 30
70349: PUSH
70350: LD_INT 80
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: LIST
70357: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70358: LD_VAR 0 6
70362: PPUSH
70363: CALL_OW 264
70367: PUSH
70368: LD_INT 22
70370: PUSH
70371: EMPTY
70372: LIST
70373: IN
70374: IFFALSE 70395
// points := [ 40 , 1 , 1 ] ;
70376: LD_ADDR_VAR 0 9
70380: PUSH
70381: LD_INT 40
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: LD_INT 1
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: LIST
70394: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70395: LD_VAR 0 6
70399: PPUSH
70400: CALL_OW 264
70404: PUSH
70405: LD_INT 29
70407: PUSH
70408: EMPTY
70409: LIST
70410: IN
70411: IFFALSE 70432
// points := [ 70 , 200 , 400 ] ;
70413: LD_ADDR_VAR 0 9
70417: PUSH
70418: LD_INT 70
70420: PUSH
70421: LD_INT 200
70423: PUSH
70424: LD_INT 400
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: LIST
70431: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70432: LD_VAR 0 6
70436: PPUSH
70437: CALL_OW 264
70441: PUSH
70442: LD_INT 14
70444: PUSH
70445: LD_INT 53
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: IN
70452: IFFALSE 70473
// points := [ 40 , 10 , 20 ] ;
70454: LD_ADDR_VAR 0 9
70458: PUSH
70459: LD_INT 40
70461: PUSH
70462: LD_INT 10
70464: PUSH
70465: LD_INT 20
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: LIST
70472: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70473: LD_VAR 0 6
70477: PPUSH
70478: CALL_OW 264
70482: PUSH
70483: LD_INT 9
70485: PUSH
70486: EMPTY
70487: LIST
70488: IN
70489: IFFALSE 70510
// points := [ 5 , 70 , 20 ] ;
70491: LD_ADDR_VAR 0 9
70495: PUSH
70496: LD_INT 5
70498: PUSH
70499: LD_INT 70
70501: PUSH
70502: LD_INT 20
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: LIST
70509: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70510: LD_VAR 0 6
70514: PPUSH
70515: CALL_OW 264
70519: PUSH
70520: LD_INT 10
70522: PUSH
70523: EMPTY
70524: LIST
70525: IN
70526: IFFALSE 70547
// points := [ 35 , 110 , 70 ] ;
70528: LD_ADDR_VAR 0 9
70532: PUSH
70533: LD_INT 35
70535: PUSH
70536: LD_INT 110
70538: PUSH
70539: LD_INT 70
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: LIST
70546: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70547: LD_VAR 0 6
70551: PPUSH
70552: CALL_OW 265
70556: PUSH
70557: LD_INT 25
70559: EQUAL
70560: IFFALSE 70581
// points := [ 80 , 65 , 100 ] ;
70562: LD_ADDR_VAR 0 9
70566: PUSH
70567: LD_INT 80
70569: PUSH
70570: LD_INT 65
70572: PUSH
70573: LD_INT 100
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: LIST
70580: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70581: LD_VAR 0 6
70585: PPUSH
70586: CALL_OW 263
70590: PUSH
70591: LD_INT 1
70593: EQUAL
70594: IFFALSE 70629
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70596: LD_ADDR_VAR 0 10
70600: PUSH
70601: LD_VAR 0 10
70605: PUSH
70606: LD_VAR 0 6
70610: PPUSH
70611: CALL_OW 311
70615: PPUSH
70616: LD_INT 3
70618: PPUSH
70619: CALL_OW 259
70623: PUSH
70624: LD_INT 4
70626: MUL
70627: MUL
70628: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70629: LD_VAR 0 6
70633: PPUSH
70634: CALL_OW 263
70638: PUSH
70639: LD_INT 2
70641: EQUAL
70642: IFFALSE 70693
// begin j := IsControledBy ( i ) ;
70644: LD_ADDR_VAR 0 7
70648: PUSH
70649: LD_VAR 0 6
70653: PPUSH
70654: CALL_OW 312
70658: ST_TO_ADDR
// if j then
70659: LD_VAR 0 7
70663: IFFALSE 70693
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70665: LD_ADDR_VAR 0 10
70669: PUSH
70670: LD_VAR 0 10
70674: PUSH
70675: LD_VAR 0 7
70679: PPUSH
70680: LD_INT 3
70682: PPUSH
70683: CALL_OW 259
70687: PUSH
70688: LD_INT 3
70690: MUL
70691: MUL
70692: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70693: LD_VAR 0 6
70697: PPUSH
70698: CALL_OW 264
70702: PUSH
70703: LD_INT 5
70705: PUSH
70706: LD_INT 6
70708: PUSH
70709: LD_INT 46
70711: PUSH
70712: LD_INT 44
70714: PUSH
70715: LD_INT 47
70717: PUSH
70718: LD_INT 45
70720: PUSH
70721: LD_INT 28
70723: PUSH
70724: LD_INT 7
70726: PUSH
70727: LD_INT 27
70729: PUSH
70730: LD_INT 29
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: IN
70745: PUSH
70746: LD_VAR 0 1
70750: PPUSH
70751: LD_INT 52
70753: PPUSH
70754: CALL_OW 321
70758: PUSH
70759: LD_INT 2
70761: EQUAL
70762: AND
70763: IFFALSE 70780
// bpoints := bpoints * 1.2 ;
70765: LD_ADDR_VAR 0 10
70769: PUSH
70770: LD_VAR 0 10
70774: PUSH
70775: LD_REAL  1.20000000000000E+0000
70778: MUL
70779: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70780: LD_VAR 0 6
70784: PPUSH
70785: CALL_OW 264
70789: PUSH
70790: LD_INT 6
70792: PUSH
70793: LD_INT 46
70795: PUSH
70796: LD_INT 47
70798: PUSH
70799: EMPTY
70800: LIST
70801: LIST
70802: LIST
70803: IN
70804: IFFALSE 70821
// bpoints := bpoints * 1.2 ;
70806: LD_ADDR_VAR 0 10
70810: PUSH
70811: LD_VAR 0 10
70815: PUSH
70816: LD_REAL  1.20000000000000E+0000
70819: MUL
70820: ST_TO_ADDR
// end ; unit_building :
70821: GO 70835
70823: LD_INT 3
70825: DOUBLE
70826: EQUAL
70827: IFTRUE 70831
70829: GO 70834
70831: POP
// ; end ;
70832: GO 70835
70834: POP
// for j = 1 to 3 do
70835: LD_ADDR_VAR 0 7
70839: PUSH
70840: DOUBLE
70841: LD_INT 1
70843: DEC
70844: ST_TO_ADDR
70845: LD_INT 3
70847: PUSH
70848: FOR_TO
70849: IFFALSE 70902
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70851: LD_ADDR_VAR 0 5
70855: PUSH
70856: LD_VAR 0 5
70860: PPUSH
70861: LD_VAR 0 7
70865: PPUSH
70866: LD_VAR 0 5
70870: PUSH
70871: LD_VAR 0 7
70875: ARRAY
70876: PUSH
70877: LD_VAR 0 9
70881: PUSH
70882: LD_VAR 0 7
70886: ARRAY
70887: PUSH
70888: LD_VAR 0 10
70892: MUL
70893: PLUS
70894: PPUSH
70895: CALL_OW 1
70899: ST_TO_ADDR
70900: GO 70848
70902: POP
70903: POP
// end ;
70904: GO 69383
70906: POP
70907: POP
// result := Replace ( result , 4 , tmp ) ;
70908: LD_ADDR_VAR 0 5
70912: PUSH
70913: LD_VAR 0 5
70917: PPUSH
70918: LD_INT 4
70920: PPUSH
70921: LD_VAR 0 8
70925: PPUSH
70926: CALL_OW 1
70930: ST_TO_ADDR
// end ;
70931: LD_VAR 0 5
70935: RET
// export function DangerAtRange ( unit , range ) ; begin
70936: LD_INT 0
70938: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
70939: LD_ADDR_VAR 0 3
70943: PUSH
70944: LD_VAR 0 1
70948: PPUSH
70949: CALL_OW 255
70953: PPUSH
70954: LD_VAR 0 1
70958: PPUSH
70959: CALL_OW 250
70963: PPUSH
70964: LD_VAR 0 1
70968: PPUSH
70969: CALL_OW 251
70973: PPUSH
70974: LD_VAR 0 2
70978: PPUSH
70979: CALL 69235 0 4
70983: ST_TO_ADDR
// end ;
70984: LD_VAR 0 3
70988: RET
// export function DangerInArea ( side , area ) ; begin
70989: LD_INT 0
70991: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
70992: LD_ADDR_VAR 0 3
70996: PUSH
70997: LD_VAR 0 2
71001: PPUSH
71002: LD_INT 81
71004: PUSH
71005: LD_VAR 0 1
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: PPUSH
71014: CALL_OW 70
71018: ST_TO_ADDR
// end ;
71019: LD_VAR 0 3
71023: RET
// export function IsExtension ( b ) ; begin
71024: LD_INT 0
71026: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71027: LD_ADDR_VAR 0 2
71031: PUSH
71032: LD_VAR 0 1
71036: PUSH
71037: LD_INT 23
71039: PUSH
71040: LD_INT 20
71042: PUSH
71043: LD_INT 22
71045: PUSH
71046: LD_INT 17
71048: PUSH
71049: LD_INT 24
71051: PUSH
71052: LD_INT 21
71054: PUSH
71055: LD_INT 19
71057: PUSH
71058: LD_INT 16
71060: PUSH
71061: LD_INT 25
71063: PUSH
71064: LD_INT 18
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: IN
71079: ST_TO_ADDR
// end ;
71080: LD_VAR 0 2
71084: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71085: LD_INT 0
71087: PPUSH
71088: PPUSH
71089: PPUSH
// result := [ ] ;
71090: LD_ADDR_VAR 0 4
71094: PUSH
71095: EMPTY
71096: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71097: LD_ADDR_VAR 0 5
71101: PUSH
71102: LD_VAR 0 2
71106: PPUSH
71107: LD_INT 21
71109: PUSH
71110: LD_INT 3
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PPUSH
71117: CALL_OW 70
71121: ST_TO_ADDR
// if not tmp then
71122: LD_VAR 0 5
71126: NOT
71127: IFFALSE 71131
// exit ;
71129: GO 71195
// if checkLink then
71131: LD_VAR 0 3
71135: IFFALSE 71185
// begin for i in tmp do
71137: LD_ADDR_VAR 0 6
71141: PUSH
71142: LD_VAR 0 5
71146: PUSH
71147: FOR_IN
71148: IFFALSE 71183
// if GetBase ( i ) <> base then
71150: LD_VAR 0 6
71154: PPUSH
71155: CALL_OW 274
71159: PUSH
71160: LD_VAR 0 1
71164: NONEQUAL
71165: IFFALSE 71181
// ComLinkToBase ( base , i ) ;
71167: LD_VAR 0 1
71171: PPUSH
71172: LD_VAR 0 6
71176: PPUSH
71177: CALL_OW 169
71181: GO 71147
71183: POP
71184: POP
// end ; result := tmp ;
71185: LD_ADDR_VAR 0 4
71189: PUSH
71190: LD_VAR 0 5
71194: ST_TO_ADDR
// end ;
71195: LD_VAR 0 4
71199: RET
// export function ComComplete ( units , b ) ; var i ; begin
71200: LD_INT 0
71202: PPUSH
71203: PPUSH
// if not units then
71204: LD_VAR 0 1
71208: NOT
71209: IFFALSE 71213
// exit ;
71211: GO 71303
// for i in units do
71213: LD_ADDR_VAR 0 4
71217: PUSH
71218: LD_VAR 0 1
71222: PUSH
71223: FOR_IN
71224: IFFALSE 71301
// if BuildingStatus ( b ) = bs_build then
71226: LD_VAR 0 2
71230: PPUSH
71231: CALL_OW 461
71235: PUSH
71236: LD_INT 1
71238: EQUAL
71239: IFFALSE 71299
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71241: LD_VAR 0 4
71245: PPUSH
71246: LD_STRING h
71248: PUSH
71249: LD_VAR 0 2
71253: PPUSH
71254: CALL_OW 250
71258: PUSH
71259: LD_VAR 0 2
71263: PPUSH
71264: CALL_OW 251
71268: PUSH
71269: LD_VAR 0 2
71273: PUSH
71274: LD_INT 0
71276: PUSH
71277: LD_INT 0
71279: PUSH
71280: LD_INT 0
71282: PUSH
71283: EMPTY
71284: LIST
71285: LIST
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: PUSH
71292: EMPTY
71293: LIST
71294: PPUSH
71295: CALL_OW 446
71299: GO 71223
71301: POP
71302: POP
// end ;
71303: LD_VAR 0 3
71307: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71308: LD_INT 0
71310: PPUSH
71311: PPUSH
71312: PPUSH
71313: PPUSH
71314: PPUSH
71315: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
71316: LD_VAR 0 1
71320: NOT
71321: PUSH
71322: LD_VAR 0 1
71326: PPUSH
71327: CALL_OW 263
71331: PUSH
71332: LD_INT 2
71334: NONEQUAL
71335: OR
71336: IFFALSE 71340
// exit ;
71338: GO 71656
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71340: LD_ADDR_VAR 0 6
71344: PUSH
71345: LD_INT 22
71347: PUSH
71348: LD_VAR 0 1
71352: PPUSH
71353: CALL_OW 255
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: PUSH
71362: LD_INT 2
71364: PUSH
71365: LD_INT 30
71367: PUSH
71368: LD_INT 36
71370: PUSH
71371: EMPTY
71372: LIST
71373: LIST
71374: PUSH
71375: LD_INT 34
71377: PUSH
71378: LD_INT 31
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: LIST
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PPUSH
71394: CALL_OW 69
71398: ST_TO_ADDR
// if not tmp then
71399: LD_VAR 0 6
71403: NOT
71404: IFFALSE 71408
// exit ;
71406: GO 71656
// result := [ ] ;
71408: LD_ADDR_VAR 0 2
71412: PUSH
71413: EMPTY
71414: ST_TO_ADDR
// for i in tmp do
71415: LD_ADDR_VAR 0 3
71419: PUSH
71420: LD_VAR 0 6
71424: PUSH
71425: FOR_IN
71426: IFFALSE 71497
// begin t := UnitsInside ( i ) ;
71428: LD_ADDR_VAR 0 4
71432: PUSH
71433: LD_VAR 0 3
71437: PPUSH
71438: CALL_OW 313
71442: ST_TO_ADDR
// if t then
71443: LD_VAR 0 4
71447: IFFALSE 71495
// for j in t do
71449: LD_ADDR_VAR 0 7
71453: PUSH
71454: LD_VAR 0 4
71458: PUSH
71459: FOR_IN
71460: IFFALSE 71493
// result := Replace ( result , result + 1 , j ) ;
71462: LD_ADDR_VAR 0 2
71466: PUSH
71467: LD_VAR 0 2
71471: PPUSH
71472: LD_VAR 0 2
71476: PUSH
71477: LD_INT 1
71479: PLUS
71480: PPUSH
71481: LD_VAR 0 7
71485: PPUSH
71486: CALL_OW 1
71490: ST_TO_ADDR
71491: GO 71459
71493: POP
71494: POP
// end ;
71495: GO 71425
71497: POP
71498: POP
// if not result then
71499: LD_VAR 0 2
71503: NOT
71504: IFFALSE 71508
// exit ;
71506: GO 71656
// mech := result [ 1 ] ;
71508: LD_ADDR_VAR 0 5
71512: PUSH
71513: LD_VAR 0 2
71517: PUSH
71518: LD_INT 1
71520: ARRAY
71521: ST_TO_ADDR
// if result > 1 then
71522: LD_VAR 0 2
71526: PUSH
71527: LD_INT 1
71529: GREATER
71530: IFFALSE 71642
// begin for i = 2 to result do
71532: LD_ADDR_VAR 0 3
71536: PUSH
71537: DOUBLE
71538: LD_INT 2
71540: DEC
71541: ST_TO_ADDR
71542: LD_VAR 0 2
71546: PUSH
71547: FOR_TO
71548: IFFALSE 71640
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71550: LD_ADDR_VAR 0 4
71554: PUSH
71555: LD_VAR 0 2
71559: PUSH
71560: LD_VAR 0 3
71564: ARRAY
71565: PPUSH
71566: LD_INT 3
71568: PPUSH
71569: CALL_OW 259
71573: PUSH
71574: LD_VAR 0 2
71578: PUSH
71579: LD_VAR 0 3
71583: ARRAY
71584: PPUSH
71585: CALL_OW 432
71589: MINUS
71590: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71591: LD_VAR 0 4
71595: PUSH
71596: LD_VAR 0 5
71600: PPUSH
71601: LD_INT 3
71603: PPUSH
71604: CALL_OW 259
71608: PUSH
71609: LD_VAR 0 5
71613: PPUSH
71614: CALL_OW 432
71618: MINUS
71619: GREATEREQUAL
71620: IFFALSE 71638
// mech := result [ i ] ;
71622: LD_ADDR_VAR 0 5
71626: PUSH
71627: LD_VAR 0 2
71631: PUSH
71632: LD_VAR 0 3
71636: ARRAY
71637: ST_TO_ADDR
// end ;
71638: GO 71547
71640: POP
71641: POP
// end ; ComLinkTo ( vehicle , mech ) ;
71642: LD_VAR 0 1
71646: PPUSH
71647: LD_VAR 0 5
71651: PPUSH
71652: CALL_OW 135
// end ;
71656: LD_VAR 0 2
71660: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71661: LD_INT 0
71663: PPUSH
71664: PPUSH
71665: PPUSH
71666: PPUSH
71667: PPUSH
71668: PPUSH
71669: PPUSH
71670: PPUSH
71671: PPUSH
71672: PPUSH
71673: PPUSH
71674: PPUSH
71675: PPUSH
// result := [ ] ;
71676: LD_ADDR_VAR 0 7
71680: PUSH
71681: EMPTY
71682: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71683: LD_VAR 0 1
71687: PPUSH
71688: CALL_OW 266
71692: PUSH
71693: LD_INT 0
71695: PUSH
71696: LD_INT 1
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: IN
71703: NOT
71704: IFFALSE 71708
// exit ;
71706: GO 73342
// if name then
71708: LD_VAR 0 3
71712: IFFALSE 71728
// SetBName ( base_dep , name ) ;
71714: LD_VAR 0 1
71718: PPUSH
71719: LD_VAR 0 3
71723: PPUSH
71724: CALL_OW 500
// base := GetBase ( base_dep ) ;
71728: LD_ADDR_VAR 0 15
71732: PUSH
71733: LD_VAR 0 1
71737: PPUSH
71738: CALL_OW 274
71742: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71743: LD_ADDR_VAR 0 16
71747: PUSH
71748: LD_VAR 0 1
71752: PPUSH
71753: CALL_OW 255
71757: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71758: LD_ADDR_VAR 0 17
71762: PUSH
71763: LD_VAR 0 1
71767: PPUSH
71768: CALL_OW 248
71772: ST_TO_ADDR
// if sources then
71773: LD_VAR 0 5
71777: IFFALSE 71824
// for i = 1 to 3 do
71779: LD_ADDR_VAR 0 8
71783: PUSH
71784: DOUBLE
71785: LD_INT 1
71787: DEC
71788: ST_TO_ADDR
71789: LD_INT 3
71791: PUSH
71792: FOR_TO
71793: IFFALSE 71822
// AddResourceType ( base , i , sources [ i ] ) ;
71795: LD_VAR 0 15
71799: PPUSH
71800: LD_VAR 0 8
71804: PPUSH
71805: LD_VAR 0 5
71809: PUSH
71810: LD_VAR 0 8
71814: ARRAY
71815: PPUSH
71816: CALL_OW 276
71820: GO 71792
71822: POP
71823: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
71824: LD_ADDR_VAR 0 18
71828: PUSH
71829: LD_VAR 0 15
71833: PPUSH
71834: LD_VAR 0 2
71838: PPUSH
71839: LD_INT 1
71841: PPUSH
71842: CALL 71085 0 3
71846: ST_TO_ADDR
// InitHc ;
71847: CALL_OW 19
// InitUc ;
71851: CALL_OW 18
// uc_side := side ;
71855: LD_ADDR_OWVAR 20
71859: PUSH
71860: LD_VAR 0 16
71864: ST_TO_ADDR
// uc_nation := nation ;
71865: LD_ADDR_OWVAR 21
71869: PUSH
71870: LD_VAR 0 17
71874: ST_TO_ADDR
// if buildings then
71875: LD_VAR 0 18
71879: IFFALSE 73201
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
71881: LD_ADDR_VAR 0 19
71885: PUSH
71886: LD_VAR 0 18
71890: PPUSH
71891: LD_INT 2
71893: PUSH
71894: LD_INT 30
71896: PUSH
71897: LD_INT 29
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 30
71906: PUSH
71907: LD_INT 30
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: LIST
71918: PPUSH
71919: CALL_OW 72
71923: ST_TO_ADDR
// if tmp then
71924: LD_VAR 0 19
71928: IFFALSE 71976
// for i in tmp do
71930: LD_ADDR_VAR 0 8
71934: PUSH
71935: LD_VAR 0 19
71939: PUSH
71940: FOR_IN
71941: IFFALSE 71974
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71943: LD_VAR 0 8
71947: PPUSH
71948: CALL_OW 250
71952: PPUSH
71953: LD_VAR 0 8
71957: PPUSH
71958: CALL_OW 251
71962: PPUSH
71963: LD_VAR 0 16
71967: PPUSH
71968: CALL_OW 441
71972: GO 71940
71974: POP
71975: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71976: LD_VAR 0 18
71980: PPUSH
71981: LD_INT 2
71983: PUSH
71984: LD_INT 30
71986: PUSH
71987: LD_INT 32
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 30
71996: PUSH
71997: LD_INT 33
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: LIST
72008: PPUSH
72009: CALL_OW 72
72013: IFFALSE 72101
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72015: LD_ADDR_VAR 0 8
72019: PUSH
72020: LD_VAR 0 18
72024: PPUSH
72025: LD_INT 2
72027: PUSH
72028: LD_INT 30
72030: PUSH
72031: LD_INT 32
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 30
72040: PUSH
72041: LD_INT 33
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: LIST
72052: PPUSH
72053: CALL_OW 72
72057: PUSH
72058: FOR_IN
72059: IFFALSE 72099
// begin if not GetBWeapon ( i ) then
72061: LD_VAR 0 8
72065: PPUSH
72066: CALL_OW 269
72070: NOT
72071: IFFALSE 72097
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72073: LD_VAR 0 8
72077: PPUSH
72078: LD_VAR 0 8
72082: PPUSH
72083: LD_VAR 0 2
72087: PPUSH
72088: CALL 73347 0 2
72092: PPUSH
72093: CALL_OW 431
// end ;
72097: GO 72058
72099: POP
72100: POP
// end ; for i = 1 to personel do
72101: LD_ADDR_VAR 0 8
72105: PUSH
72106: DOUBLE
72107: LD_INT 1
72109: DEC
72110: ST_TO_ADDR
72111: LD_VAR 0 6
72115: PUSH
72116: FOR_TO
72117: IFFALSE 73181
// begin if i > 4 then
72119: LD_VAR 0 8
72123: PUSH
72124: LD_INT 4
72126: GREATER
72127: IFFALSE 72131
// break ;
72129: GO 73181
// case i of 1 :
72131: LD_VAR 0 8
72135: PUSH
72136: LD_INT 1
72138: DOUBLE
72139: EQUAL
72140: IFTRUE 72144
72142: GO 72224
72144: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72145: LD_ADDR_VAR 0 12
72149: PUSH
72150: LD_VAR 0 18
72154: PPUSH
72155: LD_INT 22
72157: PUSH
72158: LD_VAR 0 16
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 58
72169: PUSH
72170: EMPTY
72171: LIST
72172: PUSH
72173: LD_INT 2
72175: PUSH
72176: LD_INT 30
72178: PUSH
72179: LD_INT 32
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 30
72188: PUSH
72189: LD_INT 4
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: LD_INT 30
72198: PUSH
72199: LD_INT 5
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: LIST
72216: PPUSH
72217: CALL_OW 72
72221: ST_TO_ADDR
72222: GO 72446
72224: LD_INT 2
72226: DOUBLE
72227: EQUAL
72228: IFTRUE 72232
72230: GO 72294
72232: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72233: LD_ADDR_VAR 0 12
72237: PUSH
72238: LD_VAR 0 18
72242: PPUSH
72243: LD_INT 22
72245: PUSH
72246: LD_VAR 0 16
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 2
72257: PUSH
72258: LD_INT 30
72260: PUSH
72261: LD_INT 0
72263: PUSH
72264: EMPTY
72265: LIST
72266: LIST
72267: PUSH
72268: LD_INT 30
72270: PUSH
72271: LD_INT 1
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: LIST
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PPUSH
72287: CALL_OW 72
72291: ST_TO_ADDR
72292: GO 72446
72294: LD_INT 3
72296: DOUBLE
72297: EQUAL
72298: IFTRUE 72302
72300: GO 72364
72302: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72303: LD_ADDR_VAR 0 12
72307: PUSH
72308: LD_VAR 0 18
72312: PPUSH
72313: LD_INT 22
72315: PUSH
72316: LD_VAR 0 16
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 2
72327: PUSH
72328: LD_INT 30
72330: PUSH
72331: LD_INT 2
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 30
72340: PUSH
72341: LD_INT 3
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: LIST
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PPUSH
72357: CALL_OW 72
72361: ST_TO_ADDR
72362: GO 72446
72364: LD_INT 4
72366: DOUBLE
72367: EQUAL
72368: IFTRUE 72372
72370: GO 72445
72372: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72373: LD_ADDR_VAR 0 12
72377: PUSH
72378: LD_VAR 0 18
72382: PPUSH
72383: LD_INT 22
72385: PUSH
72386: LD_VAR 0 16
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 2
72397: PUSH
72398: LD_INT 30
72400: PUSH
72401: LD_INT 6
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: LD_INT 30
72410: PUSH
72411: LD_INT 7
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 30
72420: PUSH
72421: LD_INT 8
72423: PUSH
72424: EMPTY
72425: LIST
72426: LIST
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PPUSH
72438: CALL_OW 72
72442: ST_TO_ADDR
72443: GO 72446
72445: POP
// if i = 1 then
72446: LD_VAR 0 8
72450: PUSH
72451: LD_INT 1
72453: EQUAL
72454: IFFALSE 72565
// begin tmp := [ ] ;
72456: LD_ADDR_VAR 0 19
72460: PUSH
72461: EMPTY
72462: ST_TO_ADDR
// for j in f do
72463: LD_ADDR_VAR 0 9
72467: PUSH
72468: LD_VAR 0 12
72472: PUSH
72473: FOR_IN
72474: IFFALSE 72547
// if GetBType ( j ) = b_bunker then
72476: LD_VAR 0 9
72480: PPUSH
72481: CALL_OW 266
72485: PUSH
72486: LD_INT 32
72488: EQUAL
72489: IFFALSE 72516
// tmp := Insert ( tmp , 1 , j ) else
72491: LD_ADDR_VAR 0 19
72495: PUSH
72496: LD_VAR 0 19
72500: PPUSH
72501: LD_INT 1
72503: PPUSH
72504: LD_VAR 0 9
72508: PPUSH
72509: CALL_OW 2
72513: ST_TO_ADDR
72514: GO 72545
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72516: LD_ADDR_VAR 0 19
72520: PUSH
72521: LD_VAR 0 19
72525: PPUSH
72526: LD_VAR 0 19
72530: PUSH
72531: LD_INT 1
72533: PLUS
72534: PPUSH
72535: LD_VAR 0 9
72539: PPUSH
72540: CALL_OW 2
72544: ST_TO_ADDR
72545: GO 72473
72547: POP
72548: POP
// if tmp then
72549: LD_VAR 0 19
72553: IFFALSE 72565
// f := tmp ;
72555: LD_ADDR_VAR 0 12
72559: PUSH
72560: LD_VAR 0 19
72564: ST_TO_ADDR
// end ; x := personel [ i ] ;
72565: LD_ADDR_VAR 0 13
72569: PUSH
72570: LD_VAR 0 6
72574: PUSH
72575: LD_VAR 0 8
72579: ARRAY
72580: ST_TO_ADDR
// if x = - 1 then
72581: LD_VAR 0 13
72585: PUSH
72586: LD_INT 1
72588: NEG
72589: EQUAL
72590: IFFALSE 72799
// begin for j in f do
72592: LD_ADDR_VAR 0 9
72596: PUSH
72597: LD_VAR 0 12
72601: PUSH
72602: FOR_IN
72603: IFFALSE 72795
// repeat InitHc ;
72605: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72609: LD_VAR 0 9
72613: PPUSH
72614: CALL_OW 266
72618: PUSH
72619: LD_INT 5
72621: EQUAL
72622: IFFALSE 72692
// begin if UnitsInside ( j ) < 3 then
72624: LD_VAR 0 9
72628: PPUSH
72629: CALL_OW 313
72633: PUSH
72634: LD_INT 3
72636: LESS
72637: IFFALSE 72673
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72639: LD_INT 0
72641: PPUSH
72642: LD_INT 5
72644: PUSH
72645: LD_INT 8
72647: PUSH
72648: LD_INT 9
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: LIST
72655: PUSH
72656: LD_VAR 0 17
72660: ARRAY
72661: PPUSH
72662: LD_VAR 0 4
72666: PPUSH
72667: CALL_OW 380
72671: GO 72690
// PrepareHuman ( false , i , skill ) ;
72673: LD_INT 0
72675: PPUSH
72676: LD_VAR 0 8
72680: PPUSH
72681: LD_VAR 0 4
72685: PPUSH
72686: CALL_OW 380
// end else
72690: GO 72709
// PrepareHuman ( false , i , skill ) ;
72692: LD_INT 0
72694: PPUSH
72695: LD_VAR 0 8
72699: PPUSH
72700: LD_VAR 0 4
72704: PPUSH
72705: CALL_OW 380
// un := CreateHuman ;
72709: LD_ADDR_VAR 0 14
72713: PUSH
72714: CALL_OW 44
72718: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72719: LD_ADDR_VAR 0 7
72723: PUSH
72724: LD_VAR 0 7
72728: PPUSH
72729: LD_INT 1
72731: PPUSH
72732: LD_VAR 0 14
72736: PPUSH
72737: CALL_OW 2
72741: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72742: LD_VAR 0 14
72746: PPUSH
72747: LD_VAR 0 9
72751: PPUSH
72752: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72756: LD_VAR 0 9
72760: PPUSH
72761: CALL_OW 313
72765: PUSH
72766: LD_INT 6
72768: EQUAL
72769: PUSH
72770: LD_VAR 0 9
72774: PPUSH
72775: CALL_OW 266
72779: PUSH
72780: LD_INT 32
72782: PUSH
72783: LD_INT 31
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: IN
72790: OR
72791: IFFALSE 72605
72793: GO 72602
72795: POP
72796: POP
// end else
72797: GO 73179
// for j = 1 to x do
72799: LD_ADDR_VAR 0 9
72803: PUSH
72804: DOUBLE
72805: LD_INT 1
72807: DEC
72808: ST_TO_ADDR
72809: LD_VAR 0 13
72813: PUSH
72814: FOR_TO
72815: IFFALSE 73177
// begin InitHc ;
72817: CALL_OW 19
// if not f then
72821: LD_VAR 0 12
72825: NOT
72826: IFFALSE 72915
// begin PrepareHuman ( false , i , skill ) ;
72828: LD_INT 0
72830: PPUSH
72831: LD_VAR 0 8
72835: PPUSH
72836: LD_VAR 0 4
72840: PPUSH
72841: CALL_OW 380
// un := CreateHuman ;
72845: LD_ADDR_VAR 0 14
72849: PUSH
72850: CALL_OW 44
72854: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72855: LD_ADDR_VAR 0 7
72859: PUSH
72860: LD_VAR 0 7
72864: PPUSH
72865: LD_INT 1
72867: PPUSH
72868: LD_VAR 0 14
72872: PPUSH
72873: CALL_OW 2
72877: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72878: LD_VAR 0 14
72882: PPUSH
72883: LD_VAR 0 1
72887: PPUSH
72888: CALL_OW 250
72892: PPUSH
72893: LD_VAR 0 1
72897: PPUSH
72898: CALL_OW 251
72902: PPUSH
72903: LD_INT 10
72905: PPUSH
72906: LD_INT 0
72908: PPUSH
72909: CALL_OW 50
// continue ;
72913: GO 72814
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
72915: LD_VAR 0 12
72919: PUSH
72920: LD_INT 1
72922: ARRAY
72923: PPUSH
72924: CALL_OW 313
72928: PUSH
72929: LD_VAR 0 12
72933: PUSH
72934: LD_INT 1
72936: ARRAY
72937: PPUSH
72938: CALL_OW 266
72942: PUSH
72943: LD_INT 32
72945: PUSH
72946: LD_INT 31
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: IN
72953: AND
72954: PUSH
72955: LD_VAR 0 12
72959: PUSH
72960: LD_INT 1
72962: ARRAY
72963: PPUSH
72964: CALL_OW 313
72968: PUSH
72969: LD_INT 6
72971: EQUAL
72972: OR
72973: IFFALSE 72993
// f := Delete ( f , 1 ) ;
72975: LD_ADDR_VAR 0 12
72979: PUSH
72980: LD_VAR 0 12
72984: PPUSH
72985: LD_INT 1
72987: PPUSH
72988: CALL_OW 3
72992: ST_TO_ADDR
// if not f then
72993: LD_VAR 0 12
72997: NOT
72998: IFFALSE 73016
// begin x := x + 2 ;
73000: LD_ADDR_VAR 0 13
73004: PUSH
73005: LD_VAR 0 13
73009: PUSH
73010: LD_INT 2
73012: PLUS
73013: ST_TO_ADDR
// continue ;
73014: GO 72814
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73016: LD_VAR 0 12
73020: PUSH
73021: LD_INT 1
73023: ARRAY
73024: PPUSH
73025: CALL_OW 266
73029: PUSH
73030: LD_INT 5
73032: EQUAL
73033: IFFALSE 73107
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73035: LD_VAR 0 12
73039: PUSH
73040: LD_INT 1
73042: ARRAY
73043: PPUSH
73044: CALL_OW 313
73048: PUSH
73049: LD_INT 3
73051: LESS
73052: IFFALSE 73088
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73054: LD_INT 0
73056: PPUSH
73057: LD_INT 5
73059: PUSH
73060: LD_INT 8
73062: PUSH
73063: LD_INT 9
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: LIST
73070: PUSH
73071: LD_VAR 0 17
73075: ARRAY
73076: PPUSH
73077: LD_VAR 0 4
73081: PPUSH
73082: CALL_OW 380
73086: GO 73105
// PrepareHuman ( false , i , skill ) ;
73088: LD_INT 0
73090: PPUSH
73091: LD_VAR 0 8
73095: PPUSH
73096: LD_VAR 0 4
73100: PPUSH
73101: CALL_OW 380
// end else
73105: GO 73124
// PrepareHuman ( false , i , skill ) ;
73107: LD_INT 0
73109: PPUSH
73110: LD_VAR 0 8
73114: PPUSH
73115: LD_VAR 0 4
73119: PPUSH
73120: CALL_OW 380
// un := CreateHuman ;
73124: LD_ADDR_VAR 0 14
73128: PUSH
73129: CALL_OW 44
73133: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73134: LD_ADDR_VAR 0 7
73138: PUSH
73139: LD_VAR 0 7
73143: PPUSH
73144: LD_INT 1
73146: PPUSH
73147: LD_VAR 0 14
73151: PPUSH
73152: CALL_OW 2
73156: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73157: LD_VAR 0 14
73161: PPUSH
73162: LD_VAR 0 12
73166: PUSH
73167: LD_INT 1
73169: ARRAY
73170: PPUSH
73171: CALL_OW 52
// end ;
73175: GO 72814
73177: POP
73178: POP
// end ;
73179: GO 72116
73181: POP
73182: POP
// result := result ^ buildings ;
73183: LD_ADDR_VAR 0 7
73187: PUSH
73188: LD_VAR 0 7
73192: PUSH
73193: LD_VAR 0 18
73197: ADD
73198: ST_TO_ADDR
// end else
73199: GO 73342
// begin for i = 1 to personel do
73201: LD_ADDR_VAR 0 8
73205: PUSH
73206: DOUBLE
73207: LD_INT 1
73209: DEC
73210: ST_TO_ADDR
73211: LD_VAR 0 6
73215: PUSH
73216: FOR_TO
73217: IFFALSE 73340
// begin if i > 4 then
73219: LD_VAR 0 8
73223: PUSH
73224: LD_INT 4
73226: GREATER
73227: IFFALSE 73231
// break ;
73229: GO 73340
// x := personel [ i ] ;
73231: LD_ADDR_VAR 0 13
73235: PUSH
73236: LD_VAR 0 6
73240: PUSH
73241: LD_VAR 0 8
73245: ARRAY
73246: ST_TO_ADDR
// if x = - 1 then
73247: LD_VAR 0 13
73251: PUSH
73252: LD_INT 1
73254: NEG
73255: EQUAL
73256: IFFALSE 73260
// continue ;
73258: GO 73216
// PrepareHuman ( false , i , skill ) ;
73260: LD_INT 0
73262: PPUSH
73263: LD_VAR 0 8
73267: PPUSH
73268: LD_VAR 0 4
73272: PPUSH
73273: CALL_OW 380
// un := CreateHuman ;
73277: LD_ADDR_VAR 0 14
73281: PUSH
73282: CALL_OW 44
73286: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73287: LD_VAR 0 14
73291: PPUSH
73292: LD_VAR 0 1
73296: PPUSH
73297: CALL_OW 250
73301: PPUSH
73302: LD_VAR 0 1
73306: PPUSH
73307: CALL_OW 251
73311: PPUSH
73312: LD_INT 10
73314: PPUSH
73315: LD_INT 0
73317: PPUSH
73318: CALL_OW 50
// result := result ^ un ;
73322: LD_ADDR_VAR 0 7
73326: PUSH
73327: LD_VAR 0 7
73331: PUSH
73332: LD_VAR 0 14
73336: ADD
73337: ST_TO_ADDR
// end ;
73338: GO 73216
73340: POP
73341: POP
// end ; end ;
73342: LD_VAR 0 7
73346: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73347: LD_INT 0
73349: PPUSH
73350: PPUSH
73351: PPUSH
73352: PPUSH
73353: PPUSH
73354: PPUSH
73355: PPUSH
73356: PPUSH
73357: PPUSH
73358: PPUSH
73359: PPUSH
73360: PPUSH
73361: PPUSH
73362: PPUSH
73363: PPUSH
73364: PPUSH
// result := false ;
73365: LD_ADDR_VAR 0 3
73369: PUSH
73370: LD_INT 0
73372: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73373: LD_VAR 0 1
73377: NOT
73378: PUSH
73379: LD_VAR 0 1
73383: PPUSH
73384: CALL_OW 266
73388: PUSH
73389: LD_INT 32
73391: PUSH
73392: LD_INT 33
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: IN
73399: NOT
73400: OR
73401: IFFALSE 73405
// exit ;
73403: GO 74514
// nat := GetNation ( tower ) ;
73405: LD_ADDR_VAR 0 12
73409: PUSH
73410: LD_VAR 0 1
73414: PPUSH
73415: CALL_OW 248
73419: ST_TO_ADDR
// side := GetSide ( tower ) ;
73420: LD_ADDR_VAR 0 16
73424: PUSH
73425: LD_VAR 0 1
73429: PPUSH
73430: CALL_OW 255
73434: ST_TO_ADDR
// x := GetX ( tower ) ;
73435: LD_ADDR_VAR 0 10
73439: PUSH
73440: LD_VAR 0 1
73444: PPUSH
73445: CALL_OW 250
73449: ST_TO_ADDR
// y := GetY ( tower ) ;
73450: LD_ADDR_VAR 0 11
73454: PUSH
73455: LD_VAR 0 1
73459: PPUSH
73460: CALL_OW 251
73464: ST_TO_ADDR
// if not x or not y then
73465: LD_VAR 0 10
73469: NOT
73470: PUSH
73471: LD_VAR 0 11
73475: NOT
73476: OR
73477: IFFALSE 73481
// exit ;
73479: GO 74514
// weapon := 0 ;
73481: LD_ADDR_VAR 0 18
73485: PUSH
73486: LD_INT 0
73488: ST_TO_ADDR
// fac_list := [ ] ;
73489: LD_ADDR_VAR 0 17
73493: PUSH
73494: EMPTY
73495: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
73496: LD_ADDR_VAR 0 6
73500: PUSH
73501: LD_VAR 0 1
73505: PPUSH
73506: CALL_OW 274
73510: PPUSH
73511: LD_VAR 0 2
73515: PPUSH
73516: LD_INT 0
73518: PPUSH
73519: CALL 71085 0 3
73523: PPUSH
73524: LD_INT 30
73526: PUSH
73527: LD_INT 3
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PPUSH
73534: CALL_OW 72
73538: ST_TO_ADDR
// if not factories then
73539: LD_VAR 0 6
73543: NOT
73544: IFFALSE 73548
// exit ;
73546: GO 74514
// for i in factories do
73548: LD_ADDR_VAR 0 8
73552: PUSH
73553: LD_VAR 0 6
73557: PUSH
73558: FOR_IN
73559: IFFALSE 73584
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73561: LD_ADDR_VAR 0 17
73565: PUSH
73566: LD_VAR 0 17
73570: PUSH
73571: LD_VAR 0 8
73575: PPUSH
73576: CALL_OW 478
73580: UNION
73581: ST_TO_ADDR
73582: GO 73558
73584: POP
73585: POP
// if not fac_list then
73586: LD_VAR 0 17
73590: NOT
73591: IFFALSE 73595
// exit ;
73593: GO 74514
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73595: LD_ADDR_VAR 0 5
73599: PUSH
73600: LD_INT 4
73602: PUSH
73603: LD_INT 5
73605: PUSH
73606: LD_INT 9
73608: PUSH
73609: LD_INT 10
73611: PUSH
73612: LD_INT 6
73614: PUSH
73615: LD_INT 7
73617: PUSH
73618: LD_INT 11
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 27
73632: PUSH
73633: LD_INT 28
73635: PUSH
73636: LD_INT 26
73638: PUSH
73639: LD_INT 30
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: LIST
73646: LIST
73647: PUSH
73648: LD_INT 43
73650: PUSH
73651: LD_INT 44
73653: PUSH
73654: LD_INT 46
73656: PUSH
73657: LD_INT 45
73659: PUSH
73660: LD_INT 47
73662: PUSH
73663: LD_INT 49
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: LIST
73670: LIST
73671: LIST
73672: LIST
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: LIST
73678: PUSH
73679: LD_VAR 0 12
73683: ARRAY
73684: ST_TO_ADDR
// list := list isect fac_list ;
73685: LD_ADDR_VAR 0 5
73689: PUSH
73690: LD_VAR 0 5
73694: PUSH
73695: LD_VAR 0 17
73699: ISECT
73700: ST_TO_ADDR
// if not list then
73701: LD_VAR 0 5
73705: NOT
73706: IFFALSE 73710
// exit ;
73708: GO 74514
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73710: LD_VAR 0 12
73714: PUSH
73715: LD_INT 3
73717: EQUAL
73718: PUSH
73719: LD_INT 49
73721: PUSH
73722: LD_VAR 0 5
73726: IN
73727: AND
73728: PUSH
73729: LD_INT 31
73731: PPUSH
73732: LD_VAR 0 16
73736: PPUSH
73737: CALL_OW 321
73741: PUSH
73742: LD_INT 2
73744: EQUAL
73745: AND
73746: IFFALSE 73806
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73748: LD_INT 22
73750: PUSH
73751: LD_VAR 0 16
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 35
73762: PUSH
73763: LD_INT 49
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 91
73772: PUSH
73773: LD_VAR 0 1
73777: PUSH
73778: LD_INT 10
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: LIST
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: LIST
73790: PPUSH
73791: CALL_OW 69
73795: NOT
73796: IFFALSE 73806
// weapon := ru_time_lapser ;
73798: LD_ADDR_VAR 0 18
73802: PUSH
73803: LD_INT 49
73805: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73806: LD_VAR 0 12
73810: PUSH
73811: LD_INT 1
73813: PUSH
73814: LD_INT 2
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: IN
73821: PUSH
73822: LD_INT 11
73824: PUSH
73825: LD_VAR 0 5
73829: IN
73830: PUSH
73831: LD_INT 30
73833: PUSH
73834: LD_VAR 0 5
73838: IN
73839: OR
73840: AND
73841: PUSH
73842: LD_INT 6
73844: PPUSH
73845: LD_VAR 0 16
73849: PPUSH
73850: CALL_OW 321
73854: PUSH
73855: LD_INT 2
73857: EQUAL
73858: AND
73859: IFFALSE 74024
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
73861: LD_INT 22
73863: PUSH
73864: LD_VAR 0 16
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: PUSH
73873: LD_INT 2
73875: PUSH
73876: LD_INT 35
73878: PUSH
73879: LD_INT 11
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: PUSH
73886: LD_INT 35
73888: PUSH
73889: LD_INT 30
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 91
73903: PUSH
73904: LD_VAR 0 1
73908: PUSH
73909: LD_INT 18
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: LIST
73921: PPUSH
73922: CALL_OW 69
73926: NOT
73927: PUSH
73928: LD_INT 22
73930: PUSH
73931: LD_VAR 0 16
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 2
73942: PUSH
73943: LD_INT 30
73945: PUSH
73946: LD_INT 32
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 30
73955: PUSH
73956: LD_INT 33
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: EMPTY
73964: LIST
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 91
73970: PUSH
73971: LD_VAR 0 1
73975: PUSH
73976: LD_INT 12
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: LIST
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: LIST
73988: PUSH
73989: EMPTY
73990: LIST
73991: PPUSH
73992: CALL_OW 69
73996: PUSH
73997: LD_INT 2
73999: GREATER
74000: AND
74001: IFFALSE 74024
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74003: LD_ADDR_VAR 0 18
74007: PUSH
74008: LD_INT 11
74010: PUSH
74011: LD_INT 30
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: LD_VAR 0 12
74022: ARRAY
74023: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74024: LD_VAR 0 18
74028: NOT
74029: PUSH
74030: LD_INT 40
74032: PPUSH
74033: LD_VAR 0 16
74037: PPUSH
74038: CALL_OW 321
74042: PUSH
74043: LD_INT 2
74045: EQUAL
74046: AND
74047: PUSH
74048: LD_INT 7
74050: PUSH
74051: LD_VAR 0 5
74055: IN
74056: PUSH
74057: LD_INT 28
74059: PUSH
74060: LD_VAR 0 5
74064: IN
74065: OR
74066: PUSH
74067: LD_INT 45
74069: PUSH
74070: LD_VAR 0 5
74074: IN
74075: OR
74076: AND
74077: IFFALSE 74331
// begin hex := GetHexInfo ( x , y ) ;
74079: LD_ADDR_VAR 0 4
74083: PUSH
74084: LD_VAR 0 10
74088: PPUSH
74089: LD_VAR 0 11
74093: PPUSH
74094: CALL_OW 546
74098: ST_TO_ADDR
// if hex [ 1 ] then
74099: LD_VAR 0 4
74103: PUSH
74104: LD_INT 1
74106: ARRAY
74107: IFFALSE 74111
// exit ;
74109: GO 74514
// height := hex [ 2 ] ;
74111: LD_ADDR_VAR 0 15
74115: PUSH
74116: LD_VAR 0 4
74120: PUSH
74121: LD_INT 2
74123: ARRAY
74124: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74125: LD_ADDR_VAR 0 14
74129: PUSH
74130: LD_INT 0
74132: PUSH
74133: LD_INT 2
74135: PUSH
74136: LD_INT 3
74138: PUSH
74139: LD_INT 5
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: LIST
74146: LIST
74147: ST_TO_ADDR
// for i in tmp do
74148: LD_ADDR_VAR 0 8
74152: PUSH
74153: LD_VAR 0 14
74157: PUSH
74158: FOR_IN
74159: IFFALSE 74329
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74161: LD_ADDR_VAR 0 9
74165: PUSH
74166: LD_VAR 0 10
74170: PPUSH
74171: LD_VAR 0 8
74175: PPUSH
74176: LD_INT 5
74178: PPUSH
74179: CALL_OW 272
74183: PUSH
74184: LD_VAR 0 11
74188: PPUSH
74189: LD_VAR 0 8
74193: PPUSH
74194: LD_INT 5
74196: PPUSH
74197: CALL_OW 273
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74206: LD_VAR 0 9
74210: PUSH
74211: LD_INT 1
74213: ARRAY
74214: PPUSH
74215: LD_VAR 0 9
74219: PUSH
74220: LD_INT 2
74222: ARRAY
74223: PPUSH
74224: CALL_OW 488
74228: IFFALSE 74327
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74230: LD_ADDR_VAR 0 4
74234: PUSH
74235: LD_VAR 0 9
74239: PUSH
74240: LD_INT 1
74242: ARRAY
74243: PPUSH
74244: LD_VAR 0 9
74248: PUSH
74249: LD_INT 2
74251: ARRAY
74252: PPUSH
74253: CALL_OW 546
74257: ST_TO_ADDR
// if hex [ 1 ] then
74258: LD_VAR 0 4
74262: PUSH
74263: LD_INT 1
74265: ARRAY
74266: IFFALSE 74270
// continue ;
74268: GO 74158
// h := hex [ 2 ] ;
74270: LD_ADDR_VAR 0 13
74274: PUSH
74275: LD_VAR 0 4
74279: PUSH
74280: LD_INT 2
74282: ARRAY
74283: ST_TO_ADDR
// if h + 7 < height then
74284: LD_VAR 0 13
74288: PUSH
74289: LD_INT 7
74291: PLUS
74292: PUSH
74293: LD_VAR 0 15
74297: LESS
74298: IFFALSE 74327
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74300: LD_ADDR_VAR 0 18
74304: PUSH
74305: LD_INT 7
74307: PUSH
74308: LD_INT 28
74310: PUSH
74311: LD_INT 45
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: LIST
74318: PUSH
74319: LD_VAR 0 12
74323: ARRAY
74324: ST_TO_ADDR
// break ;
74325: GO 74329
// end ; end ; end ;
74327: GO 74158
74329: POP
74330: POP
// end ; if not weapon then
74331: LD_VAR 0 18
74335: NOT
74336: IFFALSE 74396
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74338: LD_ADDR_VAR 0 5
74342: PUSH
74343: LD_VAR 0 5
74347: PUSH
74348: LD_INT 11
74350: PUSH
74351: LD_INT 30
74353: PUSH
74354: LD_INT 49
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: LIST
74361: DIFF
74362: ST_TO_ADDR
// if not list then
74363: LD_VAR 0 5
74367: NOT
74368: IFFALSE 74372
// exit ;
74370: GO 74514
// weapon := list [ rand ( 1 , list ) ] ;
74372: LD_ADDR_VAR 0 18
74376: PUSH
74377: LD_VAR 0 5
74381: PUSH
74382: LD_INT 1
74384: PPUSH
74385: LD_VAR 0 5
74389: PPUSH
74390: CALL_OW 12
74394: ARRAY
74395: ST_TO_ADDR
// end ; if weapon then
74396: LD_VAR 0 18
74400: IFFALSE 74514
// begin tmp := CostOfWeapon ( weapon ) ;
74402: LD_ADDR_VAR 0 14
74406: PUSH
74407: LD_VAR 0 18
74411: PPUSH
74412: CALL_OW 451
74416: ST_TO_ADDR
// j := GetBase ( tower ) ;
74417: LD_ADDR_VAR 0 9
74421: PUSH
74422: LD_VAR 0 1
74426: PPUSH
74427: CALL_OW 274
74431: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74432: LD_VAR 0 9
74436: PPUSH
74437: LD_INT 1
74439: PPUSH
74440: CALL_OW 275
74444: PUSH
74445: LD_VAR 0 14
74449: PUSH
74450: LD_INT 1
74452: ARRAY
74453: GREATEREQUAL
74454: PUSH
74455: LD_VAR 0 9
74459: PPUSH
74460: LD_INT 2
74462: PPUSH
74463: CALL_OW 275
74467: PUSH
74468: LD_VAR 0 14
74472: PUSH
74473: LD_INT 2
74475: ARRAY
74476: GREATEREQUAL
74477: AND
74478: PUSH
74479: LD_VAR 0 9
74483: PPUSH
74484: LD_INT 3
74486: PPUSH
74487: CALL_OW 275
74491: PUSH
74492: LD_VAR 0 14
74496: PUSH
74497: LD_INT 3
74499: ARRAY
74500: GREATEREQUAL
74501: AND
74502: IFFALSE 74514
// result := weapon ;
74504: LD_ADDR_VAR 0 3
74508: PUSH
74509: LD_VAR 0 18
74513: ST_TO_ADDR
// end ; end ;
74514: LD_VAR 0 3
74518: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74519: LD_INT 0
74521: PPUSH
74522: PPUSH
// result := true ;
74523: LD_ADDR_VAR 0 3
74527: PUSH
74528: LD_INT 1
74530: ST_TO_ADDR
// if array1 = array2 then
74531: LD_VAR 0 1
74535: PUSH
74536: LD_VAR 0 2
74540: EQUAL
74541: IFFALSE 74601
// begin for i = 1 to array1 do
74543: LD_ADDR_VAR 0 4
74547: PUSH
74548: DOUBLE
74549: LD_INT 1
74551: DEC
74552: ST_TO_ADDR
74553: LD_VAR 0 1
74557: PUSH
74558: FOR_TO
74559: IFFALSE 74597
// if array1 [ i ] <> array2 [ i ] then
74561: LD_VAR 0 1
74565: PUSH
74566: LD_VAR 0 4
74570: ARRAY
74571: PUSH
74572: LD_VAR 0 2
74576: PUSH
74577: LD_VAR 0 4
74581: ARRAY
74582: NONEQUAL
74583: IFFALSE 74595
// begin result := false ;
74585: LD_ADDR_VAR 0 3
74589: PUSH
74590: LD_INT 0
74592: ST_TO_ADDR
// break ;
74593: GO 74597
// end ;
74595: GO 74558
74597: POP
74598: POP
// end else
74599: GO 74609
// result := false ;
74601: LD_ADDR_VAR 0 3
74605: PUSH
74606: LD_INT 0
74608: ST_TO_ADDR
// end ;
74609: LD_VAR 0 3
74613: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
74614: LD_INT 0
74616: PPUSH
74617: PPUSH
// if not array1 or not array2 then
74618: LD_VAR 0 1
74622: NOT
74623: PUSH
74624: LD_VAR 0 2
74628: NOT
74629: OR
74630: IFFALSE 74634
// exit ;
74632: GO 74698
// result := true ;
74634: LD_ADDR_VAR 0 3
74638: PUSH
74639: LD_INT 1
74641: ST_TO_ADDR
// for i = 1 to array1 do
74642: LD_ADDR_VAR 0 4
74646: PUSH
74647: DOUBLE
74648: LD_INT 1
74650: DEC
74651: ST_TO_ADDR
74652: LD_VAR 0 1
74656: PUSH
74657: FOR_TO
74658: IFFALSE 74696
// if array1 [ i ] <> array2 [ i ] then
74660: LD_VAR 0 1
74664: PUSH
74665: LD_VAR 0 4
74669: ARRAY
74670: PUSH
74671: LD_VAR 0 2
74675: PUSH
74676: LD_VAR 0 4
74680: ARRAY
74681: NONEQUAL
74682: IFFALSE 74694
// begin result := false ;
74684: LD_ADDR_VAR 0 3
74688: PUSH
74689: LD_INT 0
74691: ST_TO_ADDR
// break ;
74692: GO 74696
// end ;
74694: GO 74657
74696: POP
74697: POP
// end ;
74698: LD_VAR 0 3
74702: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74703: LD_INT 0
74705: PPUSH
74706: PPUSH
74707: PPUSH
// pom := GetBase ( fac ) ;
74708: LD_ADDR_VAR 0 5
74712: PUSH
74713: LD_VAR 0 1
74717: PPUSH
74718: CALL_OW 274
74722: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74723: LD_ADDR_VAR 0 4
74727: PUSH
74728: LD_VAR 0 2
74732: PUSH
74733: LD_INT 1
74735: ARRAY
74736: PPUSH
74737: LD_VAR 0 2
74741: PUSH
74742: LD_INT 2
74744: ARRAY
74745: PPUSH
74746: LD_VAR 0 2
74750: PUSH
74751: LD_INT 3
74753: ARRAY
74754: PPUSH
74755: LD_VAR 0 2
74759: PUSH
74760: LD_INT 4
74762: ARRAY
74763: PPUSH
74764: CALL_OW 449
74768: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74769: LD_ADDR_VAR 0 3
74773: PUSH
74774: LD_VAR 0 5
74778: PPUSH
74779: LD_INT 1
74781: PPUSH
74782: CALL_OW 275
74786: PUSH
74787: LD_VAR 0 4
74791: PUSH
74792: LD_INT 1
74794: ARRAY
74795: GREATEREQUAL
74796: PUSH
74797: LD_VAR 0 5
74801: PPUSH
74802: LD_INT 2
74804: PPUSH
74805: CALL_OW 275
74809: PUSH
74810: LD_VAR 0 4
74814: PUSH
74815: LD_INT 2
74817: ARRAY
74818: GREATEREQUAL
74819: AND
74820: PUSH
74821: LD_VAR 0 5
74825: PPUSH
74826: LD_INT 3
74828: PPUSH
74829: CALL_OW 275
74833: PUSH
74834: LD_VAR 0 4
74838: PUSH
74839: LD_INT 3
74841: ARRAY
74842: GREATEREQUAL
74843: AND
74844: ST_TO_ADDR
// end ;
74845: LD_VAR 0 3
74849: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74850: LD_INT 0
74852: PPUSH
74853: PPUSH
74854: PPUSH
74855: PPUSH
// pom := GetBase ( building ) ;
74856: LD_ADDR_VAR 0 3
74860: PUSH
74861: LD_VAR 0 1
74865: PPUSH
74866: CALL_OW 274
74870: ST_TO_ADDR
// if not pom then
74871: LD_VAR 0 3
74875: NOT
74876: IFFALSE 74880
// exit ;
74878: GO 75050
// btype := GetBType ( building ) ;
74880: LD_ADDR_VAR 0 5
74884: PUSH
74885: LD_VAR 0 1
74889: PPUSH
74890: CALL_OW 266
74894: ST_TO_ADDR
// if btype = b_armoury then
74895: LD_VAR 0 5
74899: PUSH
74900: LD_INT 4
74902: EQUAL
74903: IFFALSE 74913
// btype := b_barracks ;
74905: LD_ADDR_VAR 0 5
74909: PUSH
74910: LD_INT 5
74912: ST_TO_ADDR
// if btype = b_depot then
74913: LD_VAR 0 5
74917: PUSH
74918: LD_INT 0
74920: EQUAL
74921: IFFALSE 74931
// btype := b_warehouse ;
74923: LD_ADDR_VAR 0 5
74927: PUSH
74928: LD_INT 1
74930: ST_TO_ADDR
// if btype = b_workshop then
74931: LD_VAR 0 5
74935: PUSH
74936: LD_INT 2
74938: EQUAL
74939: IFFALSE 74949
// btype := b_factory ;
74941: LD_ADDR_VAR 0 5
74945: PUSH
74946: LD_INT 3
74948: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74949: LD_ADDR_VAR 0 4
74953: PUSH
74954: LD_VAR 0 5
74958: PPUSH
74959: LD_VAR 0 1
74963: PPUSH
74964: CALL_OW 248
74968: PPUSH
74969: CALL_OW 450
74973: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74974: LD_ADDR_VAR 0 2
74978: PUSH
74979: LD_VAR 0 3
74983: PPUSH
74984: LD_INT 1
74986: PPUSH
74987: CALL_OW 275
74991: PUSH
74992: LD_VAR 0 4
74996: PUSH
74997: LD_INT 1
74999: ARRAY
75000: GREATEREQUAL
75001: PUSH
75002: LD_VAR 0 3
75006: PPUSH
75007: LD_INT 2
75009: PPUSH
75010: CALL_OW 275
75014: PUSH
75015: LD_VAR 0 4
75019: PUSH
75020: LD_INT 2
75022: ARRAY
75023: GREATEREQUAL
75024: AND
75025: PUSH
75026: LD_VAR 0 3
75030: PPUSH
75031: LD_INT 3
75033: PPUSH
75034: CALL_OW 275
75038: PUSH
75039: LD_VAR 0 4
75043: PUSH
75044: LD_INT 3
75046: ARRAY
75047: GREATEREQUAL
75048: AND
75049: ST_TO_ADDR
// end ;
75050: LD_VAR 0 2
75054: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75055: LD_INT 0
75057: PPUSH
75058: PPUSH
75059: PPUSH
// pom := GetBase ( building ) ;
75060: LD_ADDR_VAR 0 4
75064: PUSH
75065: LD_VAR 0 1
75069: PPUSH
75070: CALL_OW 274
75074: ST_TO_ADDR
// if not pom then
75075: LD_VAR 0 4
75079: NOT
75080: IFFALSE 75084
// exit ;
75082: GO 75185
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75084: LD_ADDR_VAR 0 5
75088: PUSH
75089: LD_VAR 0 2
75093: PPUSH
75094: LD_VAR 0 1
75098: PPUSH
75099: CALL_OW 248
75103: PPUSH
75104: CALL_OW 450
75108: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75109: LD_ADDR_VAR 0 3
75113: PUSH
75114: LD_VAR 0 4
75118: PPUSH
75119: LD_INT 1
75121: PPUSH
75122: CALL_OW 275
75126: PUSH
75127: LD_VAR 0 5
75131: PUSH
75132: LD_INT 1
75134: ARRAY
75135: GREATEREQUAL
75136: PUSH
75137: LD_VAR 0 4
75141: PPUSH
75142: LD_INT 2
75144: PPUSH
75145: CALL_OW 275
75149: PUSH
75150: LD_VAR 0 5
75154: PUSH
75155: LD_INT 2
75157: ARRAY
75158: GREATEREQUAL
75159: AND
75160: PUSH
75161: LD_VAR 0 4
75165: PPUSH
75166: LD_INT 3
75168: PPUSH
75169: CALL_OW 275
75173: PUSH
75174: LD_VAR 0 5
75178: PUSH
75179: LD_INT 3
75181: ARRAY
75182: GREATEREQUAL
75183: AND
75184: ST_TO_ADDR
// end ;
75185: LD_VAR 0 3
75189: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75190: LD_INT 0
75192: PPUSH
75193: PPUSH
75194: PPUSH
75195: PPUSH
75196: PPUSH
75197: PPUSH
75198: PPUSH
75199: PPUSH
75200: PPUSH
75201: PPUSH
75202: PPUSH
// result := false ;
75203: LD_ADDR_VAR 0 8
75207: PUSH
75208: LD_INT 0
75210: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
75211: LD_VAR 0 5
75215: NOT
75216: PUSH
75217: LD_VAR 0 1
75221: NOT
75222: OR
75223: PUSH
75224: LD_VAR 0 2
75228: NOT
75229: OR
75230: PUSH
75231: LD_VAR 0 3
75235: NOT
75236: OR
75237: IFFALSE 75241
// exit ;
75239: GO 76055
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
75241: LD_ADDR_VAR 0 14
75245: PUSH
75246: LD_VAR 0 1
75250: PPUSH
75251: LD_VAR 0 2
75255: PPUSH
75256: LD_VAR 0 3
75260: PPUSH
75261: LD_VAR 0 4
75265: PPUSH
75266: LD_VAR 0 5
75270: PUSH
75271: LD_INT 1
75273: ARRAY
75274: PPUSH
75275: CALL_OW 248
75279: PPUSH
75280: LD_INT 0
75282: PPUSH
75283: CALL 77288 0 6
75287: ST_TO_ADDR
// if not hexes then
75288: LD_VAR 0 14
75292: NOT
75293: IFFALSE 75297
// exit ;
75295: GO 76055
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75297: LD_ADDR_VAR 0 17
75301: PUSH
75302: LD_VAR 0 5
75306: PPUSH
75307: LD_INT 22
75309: PUSH
75310: LD_VAR 0 13
75314: PPUSH
75315: CALL_OW 255
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: LD_INT 2
75326: PUSH
75327: LD_INT 30
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 30
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PPUSH
75356: CALL_OW 72
75360: ST_TO_ADDR
// for i = 1 to hexes do
75361: LD_ADDR_VAR 0 9
75365: PUSH
75366: DOUBLE
75367: LD_INT 1
75369: DEC
75370: ST_TO_ADDR
75371: LD_VAR 0 14
75375: PUSH
75376: FOR_TO
75377: IFFALSE 76053
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75379: LD_ADDR_VAR 0 13
75383: PUSH
75384: LD_VAR 0 14
75388: PUSH
75389: LD_VAR 0 9
75393: ARRAY
75394: PUSH
75395: LD_INT 1
75397: ARRAY
75398: PPUSH
75399: LD_VAR 0 14
75403: PUSH
75404: LD_VAR 0 9
75408: ARRAY
75409: PUSH
75410: LD_INT 2
75412: ARRAY
75413: PPUSH
75414: CALL_OW 428
75418: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75419: LD_VAR 0 14
75423: PUSH
75424: LD_VAR 0 9
75428: ARRAY
75429: PUSH
75430: LD_INT 1
75432: ARRAY
75433: PPUSH
75434: LD_VAR 0 14
75438: PUSH
75439: LD_VAR 0 9
75443: ARRAY
75444: PUSH
75445: LD_INT 2
75447: ARRAY
75448: PPUSH
75449: CALL_OW 351
75453: PUSH
75454: LD_VAR 0 14
75458: PUSH
75459: LD_VAR 0 9
75463: ARRAY
75464: PUSH
75465: LD_INT 1
75467: ARRAY
75468: PPUSH
75469: LD_VAR 0 14
75473: PUSH
75474: LD_VAR 0 9
75478: ARRAY
75479: PUSH
75480: LD_INT 2
75482: ARRAY
75483: PPUSH
75484: CALL_OW 488
75488: NOT
75489: OR
75490: PUSH
75491: LD_VAR 0 13
75495: PPUSH
75496: CALL_OW 247
75500: PUSH
75501: LD_INT 3
75503: EQUAL
75504: OR
75505: IFFALSE 75511
// exit ;
75507: POP
75508: POP
75509: GO 76055
// if not tmp then
75511: LD_VAR 0 13
75515: NOT
75516: IFFALSE 75520
// continue ;
75518: GO 75376
// result := true ;
75520: LD_ADDR_VAR 0 8
75524: PUSH
75525: LD_INT 1
75527: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
75528: LD_VAR 0 6
75532: PUSH
75533: LD_VAR 0 13
75537: PPUSH
75538: CALL_OW 247
75542: PUSH
75543: LD_INT 2
75545: EQUAL
75546: AND
75547: PUSH
75548: LD_VAR 0 13
75552: PPUSH
75553: CALL_OW 263
75557: PUSH
75558: LD_INT 1
75560: EQUAL
75561: AND
75562: IFFALSE 75726
// begin if IsDrivenBy ( tmp ) then
75564: LD_VAR 0 13
75568: PPUSH
75569: CALL_OW 311
75573: IFFALSE 75577
// continue ;
75575: GO 75376
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
75577: LD_VAR 0 6
75581: PPUSH
75582: LD_INT 3
75584: PUSH
75585: LD_INT 60
75587: PUSH
75588: EMPTY
75589: LIST
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 3
75597: PUSH
75598: LD_INT 55
75600: PUSH
75601: EMPTY
75602: LIST
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PPUSH
75612: CALL_OW 72
75616: IFFALSE 75724
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
75618: LD_ADDR_VAR 0 18
75622: PUSH
75623: LD_VAR 0 6
75627: PPUSH
75628: LD_INT 3
75630: PUSH
75631: LD_INT 60
75633: PUSH
75634: EMPTY
75635: LIST
75636: PUSH
75637: EMPTY
75638: LIST
75639: LIST
75640: PUSH
75641: LD_INT 3
75643: PUSH
75644: LD_INT 55
75646: PUSH
75647: EMPTY
75648: LIST
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PPUSH
75658: CALL_OW 72
75662: PUSH
75663: LD_INT 1
75665: ARRAY
75666: ST_TO_ADDR
// if IsInUnit ( driver ) then
75667: LD_VAR 0 18
75671: PPUSH
75672: CALL_OW 310
75676: IFFALSE 75687
// ComExit ( driver ) ;
75678: LD_VAR 0 18
75682: PPUSH
75683: CALL 101049 0 1
// AddComEnterUnit ( driver , tmp ) ;
75687: LD_VAR 0 18
75691: PPUSH
75692: LD_VAR 0 13
75696: PPUSH
75697: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
75701: LD_VAR 0 18
75705: PPUSH
75706: LD_VAR 0 7
75710: PPUSH
75711: CALL_OW 173
// AddComExitVehicle ( driver ) ;
75715: LD_VAR 0 18
75719: PPUSH
75720: CALL_OW 181
// end ; continue ;
75724: GO 75376
// end ; if not cleaners or not tmp in cleaners then
75726: LD_VAR 0 6
75730: NOT
75731: PUSH
75732: LD_VAR 0 13
75736: PUSH
75737: LD_VAR 0 6
75741: IN
75742: NOT
75743: OR
75744: IFFALSE 76051
// begin if dep then
75746: LD_VAR 0 17
75750: IFFALSE 75886
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75752: LD_ADDR_VAR 0 16
75756: PUSH
75757: LD_VAR 0 17
75761: PUSH
75762: LD_INT 1
75764: ARRAY
75765: PPUSH
75766: CALL_OW 250
75770: PPUSH
75771: LD_VAR 0 17
75775: PUSH
75776: LD_INT 1
75778: ARRAY
75779: PPUSH
75780: CALL_OW 254
75784: PPUSH
75785: LD_INT 5
75787: PPUSH
75788: CALL_OW 272
75792: PUSH
75793: LD_VAR 0 17
75797: PUSH
75798: LD_INT 1
75800: ARRAY
75801: PPUSH
75802: CALL_OW 251
75806: PPUSH
75807: LD_VAR 0 17
75811: PUSH
75812: LD_INT 1
75814: ARRAY
75815: PPUSH
75816: CALL_OW 254
75820: PPUSH
75821: LD_INT 5
75823: PPUSH
75824: CALL_OW 273
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75833: LD_VAR 0 16
75837: PUSH
75838: LD_INT 1
75840: ARRAY
75841: PPUSH
75842: LD_VAR 0 16
75846: PUSH
75847: LD_INT 2
75849: ARRAY
75850: PPUSH
75851: CALL_OW 488
75855: IFFALSE 75886
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
75857: LD_VAR 0 13
75861: PPUSH
75862: LD_VAR 0 16
75866: PUSH
75867: LD_INT 1
75869: ARRAY
75870: PPUSH
75871: LD_VAR 0 16
75875: PUSH
75876: LD_INT 2
75878: ARRAY
75879: PPUSH
75880: CALL_OW 111
// continue ;
75884: GO 75376
// end ; end ; r := GetDir ( tmp ) ;
75886: LD_ADDR_VAR 0 15
75890: PUSH
75891: LD_VAR 0 13
75895: PPUSH
75896: CALL_OW 254
75900: ST_TO_ADDR
// if r = 5 then
75901: LD_VAR 0 15
75905: PUSH
75906: LD_INT 5
75908: EQUAL
75909: IFFALSE 75919
// r := 0 ;
75911: LD_ADDR_VAR 0 15
75915: PUSH
75916: LD_INT 0
75918: ST_TO_ADDR
// for j = r to 5 do
75919: LD_ADDR_VAR 0 10
75923: PUSH
75924: DOUBLE
75925: LD_VAR 0 15
75929: DEC
75930: ST_TO_ADDR
75931: LD_INT 5
75933: PUSH
75934: FOR_TO
75935: IFFALSE 76049
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75937: LD_ADDR_VAR 0 11
75941: PUSH
75942: LD_VAR 0 13
75946: PPUSH
75947: CALL_OW 250
75951: PPUSH
75952: LD_VAR 0 10
75956: PPUSH
75957: LD_INT 2
75959: PPUSH
75960: CALL_OW 272
75964: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75965: LD_ADDR_VAR 0 12
75969: PUSH
75970: LD_VAR 0 13
75974: PPUSH
75975: CALL_OW 251
75979: PPUSH
75980: LD_VAR 0 10
75984: PPUSH
75985: LD_INT 2
75987: PPUSH
75988: CALL_OW 273
75992: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
75993: LD_VAR 0 11
75997: PPUSH
75998: LD_VAR 0 12
76002: PPUSH
76003: CALL_OW 488
76007: PUSH
76008: LD_VAR 0 11
76012: PPUSH
76013: LD_VAR 0 12
76017: PPUSH
76018: CALL_OW 428
76022: NOT
76023: AND
76024: IFFALSE 76047
// begin ComMoveXY ( tmp , _x , _y ) ;
76026: LD_VAR 0 13
76030: PPUSH
76031: LD_VAR 0 11
76035: PPUSH
76036: LD_VAR 0 12
76040: PPUSH
76041: CALL_OW 111
// break ;
76045: GO 76049
// end ; end ;
76047: GO 75934
76049: POP
76050: POP
// end ; end ;
76051: GO 75376
76053: POP
76054: POP
// end ;
76055: LD_VAR 0 8
76059: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76060: LD_INT 0
76062: PPUSH
// result := true ;
76063: LD_ADDR_VAR 0 3
76067: PUSH
76068: LD_INT 1
76070: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76071: LD_VAR 0 2
76075: PUSH
76076: LD_INT 24
76078: DOUBLE
76079: EQUAL
76080: IFTRUE 76090
76082: LD_INT 33
76084: DOUBLE
76085: EQUAL
76086: IFTRUE 76090
76088: GO 76115
76090: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76091: LD_ADDR_VAR 0 3
76095: PUSH
76096: LD_INT 32
76098: PPUSH
76099: LD_VAR 0 1
76103: PPUSH
76104: CALL_OW 321
76108: PUSH
76109: LD_INT 2
76111: EQUAL
76112: ST_TO_ADDR
76113: GO 76431
76115: LD_INT 20
76117: DOUBLE
76118: EQUAL
76119: IFTRUE 76123
76121: GO 76148
76123: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76124: LD_ADDR_VAR 0 3
76128: PUSH
76129: LD_INT 6
76131: PPUSH
76132: LD_VAR 0 1
76136: PPUSH
76137: CALL_OW 321
76141: PUSH
76142: LD_INT 2
76144: EQUAL
76145: ST_TO_ADDR
76146: GO 76431
76148: LD_INT 22
76150: DOUBLE
76151: EQUAL
76152: IFTRUE 76162
76154: LD_INT 36
76156: DOUBLE
76157: EQUAL
76158: IFTRUE 76162
76160: GO 76187
76162: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76163: LD_ADDR_VAR 0 3
76167: PUSH
76168: LD_INT 15
76170: PPUSH
76171: LD_VAR 0 1
76175: PPUSH
76176: CALL_OW 321
76180: PUSH
76181: LD_INT 2
76183: EQUAL
76184: ST_TO_ADDR
76185: GO 76431
76187: LD_INT 30
76189: DOUBLE
76190: EQUAL
76191: IFTRUE 76195
76193: GO 76220
76195: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76196: LD_ADDR_VAR 0 3
76200: PUSH
76201: LD_INT 20
76203: PPUSH
76204: LD_VAR 0 1
76208: PPUSH
76209: CALL_OW 321
76213: PUSH
76214: LD_INT 2
76216: EQUAL
76217: ST_TO_ADDR
76218: GO 76431
76220: LD_INT 28
76222: DOUBLE
76223: EQUAL
76224: IFTRUE 76234
76226: LD_INT 21
76228: DOUBLE
76229: EQUAL
76230: IFTRUE 76234
76232: GO 76259
76234: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
76235: LD_ADDR_VAR 0 3
76239: PUSH
76240: LD_INT 21
76242: PPUSH
76243: LD_VAR 0 1
76247: PPUSH
76248: CALL_OW 321
76252: PUSH
76253: LD_INT 2
76255: EQUAL
76256: ST_TO_ADDR
76257: GO 76431
76259: LD_INT 16
76261: DOUBLE
76262: EQUAL
76263: IFTRUE 76267
76265: GO 76292
76267: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
76268: LD_ADDR_VAR 0 3
76272: PUSH
76273: LD_INT 84
76275: PPUSH
76276: LD_VAR 0 1
76280: PPUSH
76281: CALL_OW 321
76285: PUSH
76286: LD_INT 2
76288: EQUAL
76289: ST_TO_ADDR
76290: GO 76431
76292: LD_INT 19
76294: DOUBLE
76295: EQUAL
76296: IFTRUE 76306
76298: LD_INT 23
76300: DOUBLE
76301: EQUAL
76302: IFTRUE 76306
76304: GO 76331
76306: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
76307: LD_ADDR_VAR 0 3
76311: PUSH
76312: LD_INT 83
76314: PPUSH
76315: LD_VAR 0 1
76319: PPUSH
76320: CALL_OW 321
76324: PUSH
76325: LD_INT 2
76327: EQUAL
76328: ST_TO_ADDR
76329: GO 76431
76331: LD_INT 17
76333: DOUBLE
76334: EQUAL
76335: IFTRUE 76339
76337: GO 76364
76339: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
76340: LD_ADDR_VAR 0 3
76344: PUSH
76345: LD_INT 39
76347: PPUSH
76348: LD_VAR 0 1
76352: PPUSH
76353: CALL_OW 321
76357: PUSH
76358: LD_INT 2
76360: EQUAL
76361: ST_TO_ADDR
76362: GO 76431
76364: LD_INT 18
76366: DOUBLE
76367: EQUAL
76368: IFTRUE 76372
76370: GO 76397
76372: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
76373: LD_ADDR_VAR 0 3
76377: PUSH
76378: LD_INT 40
76380: PPUSH
76381: LD_VAR 0 1
76385: PPUSH
76386: CALL_OW 321
76390: PUSH
76391: LD_INT 2
76393: EQUAL
76394: ST_TO_ADDR
76395: GO 76431
76397: LD_INT 27
76399: DOUBLE
76400: EQUAL
76401: IFTRUE 76405
76403: GO 76430
76405: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
76406: LD_ADDR_VAR 0 3
76410: PUSH
76411: LD_INT 35
76413: PPUSH
76414: LD_VAR 0 1
76418: PPUSH
76419: CALL_OW 321
76423: PUSH
76424: LD_INT 2
76426: EQUAL
76427: ST_TO_ADDR
76428: GO 76431
76430: POP
// end ;
76431: LD_VAR 0 3
76435: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
76436: LD_INT 0
76438: PPUSH
76439: PPUSH
76440: PPUSH
76441: PPUSH
76442: PPUSH
76443: PPUSH
76444: PPUSH
76445: PPUSH
76446: PPUSH
76447: PPUSH
76448: PPUSH
// result := false ;
76449: LD_ADDR_VAR 0 6
76453: PUSH
76454: LD_INT 0
76456: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76457: LD_VAR 0 1
76461: NOT
76462: PUSH
76463: LD_VAR 0 1
76467: PPUSH
76468: CALL_OW 266
76472: PUSH
76473: LD_INT 0
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: IN
76483: NOT
76484: OR
76485: PUSH
76486: LD_VAR 0 2
76490: NOT
76491: OR
76492: PUSH
76493: LD_VAR 0 5
76497: PUSH
76498: LD_INT 0
76500: PUSH
76501: LD_INT 1
76503: PUSH
76504: LD_INT 2
76506: PUSH
76507: LD_INT 3
76509: PUSH
76510: LD_INT 4
76512: PUSH
76513: LD_INT 5
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: IN
76524: NOT
76525: OR
76526: PUSH
76527: LD_VAR 0 3
76531: PPUSH
76532: LD_VAR 0 4
76536: PPUSH
76537: CALL_OW 488
76541: NOT
76542: OR
76543: IFFALSE 76547
// exit ;
76545: GO 77283
// side := GetSide ( depot ) ;
76547: LD_ADDR_VAR 0 9
76551: PUSH
76552: LD_VAR 0 1
76556: PPUSH
76557: CALL_OW 255
76561: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
76562: LD_VAR 0 9
76566: PPUSH
76567: LD_VAR 0 2
76571: PPUSH
76572: CALL 76060 0 2
76576: NOT
76577: IFFALSE 76581
// exit ;
76579: GO 77283
// pom := GetBase ( depot ) ;
76581: LD_ADDR_VAR 0 10
76585: PUSH
76586: LD_VAR 0 1
76590: PPUSH
76591: CALL_OW 274
76595: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
76596: LD_ADDR_VAR 0 11
76600: PUSH
76601: LD_VAR 0 2
76605: PPUSH
76606: LD_VAR 0 1
76610: PPUSH
76611: CALL_OW 248
76615: PPUSH
76616: CALL_OW 450
76620: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76621: LD_VAR 0 10
76625: PPUSH
76626: LD_INT 1
76628: PPUSH
76629: CALL_OW 275
76633: PUSH
76634: LD_VAR 0 11
76638: PUSH
76639: LD_INT 1
76641: ARRAY
76642: GREATEREQUAL
76643: PUSH
76644: LD_VAR 0 10
76648: PPUSH
76649: LD_INT 2
76651: PPUSH
76652: CALL_OW 275
76656: PUSH
76657: LD_VAR 0 11
76661: PUSH
76662: LD_INT 2
76664: ARRAY
76665: GREATEREQUAL
76666: AND
76667: PUSH
76668: LD_VAR 0 10
76672: PPUSH
76673: LD_INT 3
76675: PPUSH
76676: CALL_OW 275
76680: PUSH
76681: LD_VAR 0 11
76685: PUSH
76686: LD_INT 3
76688: ARRAY
76689: GREATEREQUAL
76690: AND
76691: NOT
76692: IFFALSE 76696
// exit ;
76694: GO 77283
// if GetBType ( depot ) = b_depot then
76696: LD_VAR 0 1
76700: PPUSH
76701: CALL_OW 266
76705: PUSH
76706: LD_INT 0
76708: EQUAL
76709: IFFALSE 76721
// dist := 28 else
76711: LD_ADDR_VAR 0 14
76715: PUSH
76716: LD_INT 28
76718: ST_TO_ADDR
76719: GO 76729
// dist := 36 ;
76721: LD_ADDR_VAR 0 14
76725: PUSH
76726: LD_INT 36
76728: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
76729: LD_VAR 0 1
76733: PPUSH
76734: LD_VAR 0 3
76738: PPUSH
76739: LD_VAR 0 4
76743: PPUSH
76744: CALL_OW 297
76748: PUSH
76749: LD_VAR 0 14
76753: GREATER
76754: IFFALSE 76758
// exit ;
76756: GO 77283
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
76758: LD_ADDR_VAR 0 12
76762: PUSH
76763: LD_VAR 0 2
76767: PPUSH
76768: LD_VAR 0 3
76772: PPUSH
76773: LD_VAR 0 4
76777: PPUSH
76778: LD_VAR 0 5
76782: PPUSH
76783: LD_VAR 0 1
76787: PPUSH
76788: CALL_OW 248
76792: PPUSH
76793: LD_INT 0
76795: PPUSH
76796: CALL 77288 0 6
76800: ST_TO_ADDR
// if not hexes then
76801: LD_VAR 0 12
76805: NOT
76806: IFFALSE 76810
// exit ;
76808: GO 77283
// hex := GetHexInfo ( x , y ) ;
76810: LD_ADDR_VAR 0 15
76814: PUSH
76815: LD_VAR 0 3
76819: PPUSH
76820: LD_VAR 0 4
76824: PPUSH
76825: CALL_OW 546
76829: ST_TO_ADDR
// if hex [ 1 ] then
76830: LD_VAR 0 15
76834: PUSH
76835: LD_INT 1
76837: ARRAY
76838: IFFALSE 76842
// exit ;
76840: GO 77283
// height := hex [ 2 ] ;
76842: LD_ADDR_VAR 0 13
76846: PUSH
76847: LD_VAR 0 15
76851: PUSH
76852: LD_INT 2
76854: ARRAY
76855: ST_TO_ADDR
// for i = 1 to hexes do
76856: LD_ADDR_VAR 0 7
76860: PUSH
76861: DOUBLE
76862: LD_INT 1
76864: DEC
76865: ST_TO_ADDR
76866: LD_VAR 0 12
76870: PUSH
76871: FOR_TO
76872: IFFALSE 77202
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
76874: LD_VAR 0 12
76878: PUSH
76879: LD_VAR 0 7
76883: ARRAY
76884: PUSH
76885: LD_INT 1
76887: ARRAY
76888: PPUSH
76889: LD_VAR 0 12
76893: PUSH
76894: LD_VAR 0 7
76898: ARRAY
76899: PUSH
76900: LD_INT 2
76902: ARRAY
76903: PPUSH
76904: CALL_OW 488
76908: NOT
76909: PUSH
76910: LD_VAR 0 12
76914: PUSH
76915: LD_VAR 0 7
76919: ARRAY
76920: PUSH
76921: LD_INT 1
76923: ARRAY
76924: PPUSH
76925: LD_VAR 0 12
76929: PUSH
76930: LD_VAR 0 7
76934: ARRAY
76935: PUSH
76936: LD_INT 2
76938: ARRAY
76939: PPUSH
76940: CALL_OW 428
76944: PUSH
76945: LD_INT 0
76947: GREATER
76948: OR
76949: PUSH
76950: LD_VAR 0 12
76954: PUSH
76955: LD_VAR 0 7
76959: ARRAY
76960: PUSH
76961: LD_INT 1
76963: ARRAY
76964: PPUSH
76965: LD_VAR 0 12
76969: PUSH
76970: LD_VAR 0 7
76974: ARRAY
76975: PUSH
76976: LD_INT 2
76978: ARRAY
76979: PPUSH
76980: CALL_OW 351
76984: OR
76985: IFFALSE 76991
// exit ;
76987: POP
76988: POP
76989: GO 77283
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76991: LD_ADDR_VAR 0 8
76995: PUSH
76996: LD_VAR 0 12
77000: PUSH
77001: LD_VAR 0 7
77005: ARRAY
77006: PUSH
77007: LD_INT 1
77009: ARRAY
77010: PPUSH
77011: LD_VAR 0 12
77015: PUSH
77016: LD_VAR 0 7
77020: ARRAY
77021: PUSH
77022: LD_INT 2
77024: ARRAY
77025: PPUSH
77026: CALL_OW 546
77030: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77031: LD_VAR 0 8
77035: PUSH
77036: LD_INT 1
77038: ARRAY
77039: PUSH
77040: LD_VAR 0 8
77044: PUSH
77045: LD_INT 2
77047: ARRAY
77048: PUSH
77049: LD_VAR 0 13
77053: PUSH
77054: LD_INT 2
77056: PLUS
77057: GREATER
77058: OR
77059: PUSH
77060: LD_VAR 0 8
77064: PUSH
77065: LD_INT 2
77067: ARRAY
77068: PUSH
77069: LD_VAR 0 13
77073: PUSH
77074: LD_INT 2
77076: MINUS
77077: LESS
77078: OR
77079: PUSH
77080: LD_VAR 0 8
77084: PUSH
77085: LD_INT 3
77087: ARRAY
77088: PUSH
77089: LD_INT 0
77091: PUSH
77092: LD_INT 8
77094: PUSH
77095: LD_INT 9
77097: PUSH
77098: LD_INT 10
77100: PUSH
77101: LD_INT 11
77103: PUSH
77104: LD_INT 12
77106: PUSH
77107: LD_INT 13
77109: PUSH
77110: LD_INT 16
77112: PUSH
77113: LD_INT 17
77115: PUSH
77116: LD_INT 18
77118: PUSH
77119: LD_INT 19
77121: PUSH
77122: LD_INT 20
77124: PUSH
77125: LD_INT 21
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: IN
77143: NOT
77144: OR
77145: PUSH
77146: LD_VAR 0 8
77150: PUSH
77151: LD_INT 5
77153: ARRAY
77154: NOT
77155: OR
77156: PUSH
77157: LD_VAR 0 8
77161: PUSH
77162: LD_INT 6
77164: ARRAY
77165: PUSH
77166: LD_INT 1
77168: PUSH
77169: LD_INT 2
77171: PUSH
77172: LD_INT 7
77174: PUSH
77175: LD_INT 9
77177: PUSH
77178: LD_INT 10
77180: PUSH
77181: LD_INT 11
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: IN
77192: NOT
77193: OR
77194: IFFALSE 77200
// exit ;
77196: POP
77197: POP
77198: GO 77283
// end ;
77200: GO 76871
77202: POP
77203: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77204: LD_VAR 0 9
77208: PPUSH
77209: LD_VAR 0 3
77213: PPUSH
77214: LD_VAR 0 4
77218: PPUSH
77219: LD_INT 20
77221: PPUSH
77222: CALL 69235 0 4
77226: PUSH
77227: LD_INT 4
77229: ARRAY
77230: IFFALSE 77234
// exit ;
77232: GO 77283
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77234: LD_VAR 0 2
77238: PUSH
77239: LD_INT 29
77241: PUSH
77242: LD_INT 30
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: IN
77249: PUSH
77250: LD_VAR 0 3
77254: PPUSH
77255: LD_VAR 0 4
77259: PPUSH
77260: LD_VAR 0 9
77264: PPUSH
77265: CALL_OW 440
77269: NOT
77270: AND
77271: IFFALSE 77275
// exit ;
77273: GO 77283
// result := true ;
77275: LD_ADDR_VAR 0 6
77279: PUSH
77280: LD_INT 1
77282: ST_TO_ADDR
// end ;
77283: LD_VAR 0 6
77287: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
77288: LD_INT 0
77290: PPUSH
77291: PPUSH
77292: PPUSH
77293: PPUSH
77294: PPUSH
77295: PPUSH
77296: PPUSH
77297: PPUSH
77298: PPUSH
77299: PPUSH
77300: PPUSH
77301: PPUSH
77302: PPUSH
77303: PPUSH
77304: PPUSH
77305: PPUSH
77306: PPUSH
77307: PPUSH
77308: PPUSH
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
77325: PPUSH
77326: PPUSH
77327: PPUSH
77328: PPUSH
77329: PPUSH
77330: PPUSH
77331: PPUSH
77332: PPUSH
77333: PPUSH
77334: PPUSH
77335: PPUSH
77336: PPUSH
77337: PPUSH
77338: PPUSH
77339: PPUSH
77340: PPUSH
77341: PPUSH
77342: PPUSH
77343: PPUSH
77344: PPUSH
77345: PPUSH
77346: PPUSH
77347: PPUSH
// result = [ ] ;
77348: LD_ADDR_VAR 0 7
77352: PUSH
77353: EMPTY
77354: ST_TO_ADDR
// temp_list = [ ] ;
77355: LD_ADDR_VAR 0 9
77359: PUSH
77360: EMPTY
77361: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77362: LD_VAR 0 4
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: LD_INT 1
77372: PUSH
77373: LD_INT 2
77375: PUSH
77376: LD_INT 3
77378: PUSH
77379: LD_INT 4
77381: PUSH
77382: LD_INT 5
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: LIST
77389: LIST
77390: LIST
77391: LIST
77392: IN
77393: NOT
77394: PUSH
77395: LD_VAR 0 1
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: LD_INT 1
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: IN
77410: PUSH
77411: LD_VAR 0 5
77415: PUSH
77416: LD_INT 1
77418: PUSH
77419: LD_INT 2
77421: PUSH
77422: LD_INT 3
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: LIST
77429: IN
77430: NOT
77431: AND
77432: OR
77433: IFFALSE 77437
// exit ;
77435: GO 95828
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77437: LD_VAR 0 1
77441: PUSH
77442: LD_INT 6
77444: PUSH
77445: LD_INT 7
77447: PUSH
77448: LD_INT 8
77450: PUSH
77451: LD_INT 13
77453: PUSH
77454: LD_INT 12
77456: PUSH
77457: LD_INT 15
77459: PUSH
77460: LD_INT 11
77462: PUSH
77463: LD_INT 14
77465: PUSH
77466: LD_INT 10
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: IN
77480: IFFALSE 77490
// btype = b_lab ;
77482: LD_ADDR_VAR 0 1
77486: PUSH
77487: LD_INT 6
77489: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77490: LD_VAR 0 6
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: LD_INT 2
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: LIST
77508: IN
77509: NOT
77510: PUSH
77511: LD_VAR 0 1
77515: PUSH
77516: LD_INT 0
77518: PUSH
77519: LD_INT 1
77521: PUSH
77522: LD_INT 2
77524: PUSH
77525: LD_INT 3
77527: PUSH
77528: LD_INT 6
77530: PUSH
77531: LD_INT 36
77533: PUSH
77534: LD_INT 4
77536: PUSH
77537: LD_INT 5
77539: PUSH
77540: LD_INT 31
77542: PUSH
77543: LD_INT 32
77545: PUSH
77546: LD_INT 33
77548: PUSH
77549: EMPTY
77550: LIST
77551: LIST
77552: LIST
77553: LIST
77554: LIST
77555: LIST
77556: LIST
77557: LIST
77558: LIST
77559: LIST
77560: LIST
77561: IN
77562: NOT
77563: PUSH
77564: LD_VAR 0 6
77568: PUSH
77569: LD_INT 1
77571: EQUAL
77572: AND
77573: OR
77574: PUSH
77575: LD_VAR 0 1
77579: PUSH
77580: LD_INT 2
77582: PUSH
77583: LD_INT 3
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: IN
77590: NOT
77591: PUSH
77592: LD_VAR 0 6
77596: PUSH
77597: LD_INT 2
77599: EQUAL
77600: AND
77601: OR
77602: IFFALSE 77612
// mode = 0 ;
77604: LD_ADDR_VAR 0 6
77608: PUSH
77609: LD_INT 0
77611: ST_TO_ADDR
// case mode of 0 :
77612: LD_VAR 0 6
77616: PUSH
77617: LD_INT 0
77619: DOUBLE
77620: EQUAL
77621: IFTRUE 77625
77623: GO 89078
77625: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77626: LD_ADDR_VAR 0 11
77630: PUSH
77631: LD_INT 0
77633: PUSH
77634: LD_INT 0
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 0
77643: PUSH
77644: LD_INT 1
77646: NEG
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: LD_INT 1
77654: PUSH
77655: LD_INT 0
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: PUSH
77662: LD_INT 1
77664: PUSH
77665: LD_INT 1
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: LD_INT 0
77674: PUSH
77675: LD_INT 1
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 1
77684: NEG
77685: PUSH
77686: LD_INT 0
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: NEG
77696: PUSH
77697: LD_INT 1
77699: NEG
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 1
77707: NEG
77708: PUSH
77709: LD_INT 2
77711: NEG
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 0
77719: PUSH
77720: LD_INT 2
77722: NEG
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: PUSH
77731: LD_INT 1
77733: NEG
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 1
77741: PUSH
77742: LD_INT 2
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 0
77751: PUSH
77752: LD_INT 2
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 1
77761: NEG
77762: PUSH
77763: LD_INT 1
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 1
77772: PUSH
77773: LD_INT 3
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: LD_INT 3
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 1
77792: NEG
77793: PUSH
77794: LD_INT 2
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: LIST
77805: LIST
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: LIST
77818: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77819: LD_ADDR_VAR 0 12
77823: PUSH
77824: LD_INT 0
77826: PUSH
77827: LD_INT 0
77829: PUSH
77830: EMPTY
77831: LIST
77832: LIST
77833: PUSH
77834: LD_INT 0
77836: PUSH
77837: LD_INT 1
77839: NEG
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 1
77847: PUSH
77848: LD_INT 0
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 1
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 0
77867: PUSH
77868: LD_INT 1
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 1
77877: NEG
77878: PUSH
77879: LD_INT 0
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 1
77888: NEG
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 1
77900: PUSH
77901: LD_INT 1
77903: NEG
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 2
77911: PUSH
77912: LD_INT 0
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 2
77921: PUSH
77922: LD_INT 1
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 1
77931: NEG
77932: PUSH
77933: LD_INT 1
77935: PUSH
77936: EMPTY
77937: LIST
77938: LIST
77939: PUSH
77940: LD_INT 2
77942: NEG
77943: PUSH
77944: LD_INT 0
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 2
77953: NEG
77954: PUSH
77955: LD_INT 1
77957: NEG
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 2
77965: NEG
77966: PUSH
77967: LD_INT 1
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 3
77976: NEG
77977: PUSH
77978: LD_INT 0
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 3
77987: NEG
77988: PUSH
77989: LD_INT 1
77991: NEG
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78015: LD_ADDR_VAR 0 13
78019: PUSH
78020: LD_INT 0
78022: PUSH
78023: LD_INT 0
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 0
78032: PUSH
78033: LD_INT 1
78035: NEG
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 1
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 1
78053: PUSH
78054: LD_INT 1
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 0
78063: PUSH
78064: LD_INT 1
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 1
78073: NEG
78074: PUSH
78075: LD_INT 0
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 1
78084: NEG
78085: PUSH
78086: LD_INT 1
78088: NEG
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 1
78096: NEG
78097: PUSH
78098: LD_INT 2
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 2
78108: PUSH
78109: LD_INT 1
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: PUSH
78116: LD_INT 2
78118: PUSH
78119: LD_INT 2
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: LD_INT 2
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_INT 2
78138: NEG
78139: PUSH
78140: LD_INT 1
78142: NEG
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 2
78150: NEG
78151: PUSH
78152: LD_INT 2
78154: NEG
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 2
78162: NEG
78163: PUSH
78164: LD_INT 3
78166: NEG
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 3
78174: NEG
78175: PUSH
78176: LD_INT 2
78178: NEG
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: PUSH
78184: LD_INT 3
78186: NEG
78187: PUSH
78188: LD_INT 3
78190: NEG
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: LIST
78200: LIST
78201: LIST
78202: LIST
78203: LIST
78204: LIST
78205: LIST
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78214: LD_ADDR_VAR 0 14
78218: PUSH
78219: LD_INT 0
78221: PUSH
78222: LD_INT 0
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 0
78231: PUSH
78232: LD_INT 1
78234: NEG
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 1
78242: PUSH
78243: LD_INT 0
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 1
78252: PUSH
78253: LD_INT 1
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 0
78262: PUSH
78263: LD_INT 1
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 1
78272: NEG
78273: PUSH
78274: LD_INT 0
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 1
78283: NEG
78284: PUSH
78285: LD_INT 1
78287: NEG
78288: PUSH
78289: EMPTY
78290: LIST
78291: LIST
78292: PUSH
78293: LD_INT 1
78295: NEG
78296: PUSH
78297: LD_INT 2
78299: NEG
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PUSH
78305: LD_INT 0
78307: PUSH
78308: LD_INT 2
78310: NEG
78311: PUSH
78312: EMPTY
78313: LIST
78314: LIST
78315: PUSH
78316: LD_INT 1
78318: PUSH
78319: LD_INT 1
78321: NEG
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 1
78329: PUSH
78330: LD_INT 2
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 0
78339: PUSH
78340: LD_INT 2
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: PUSH
78347: LD_INT 1
78349: NEG
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 1
78360: NEG
78361: PUSH
78362: LD_INT 3
78364: NEG
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PUSH
78370: LD_INT 0
78372: PUSH
78373: LD_INT 3
78375: NEG
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 1
78383: PUSH
78384: LD_INT 2
78386: NEG
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: LIST
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78410: LD_ADDR_VAR 0 15
78414: PUSH
78415: LD_INT 0
78417: PUSH
78418: LD_INT 0
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PUSH
78425: LD_INT 0
78427: PUSH
78428: LD_INT 1
78430: NEG
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 1
78438: PUSH
78439: LD_INT 0
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 1
78448: PUSH
78449: LD_INT 1
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 0
78458: PUSH
78459: LD_INT 1
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: LD_INT 0
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 1
78479: NEG
78480: PUSH
78481: LD_INT 1
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: PUSH
78492: LD_INT 1
78494: NEG
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 2
78502: PUSH
78503: LD_INT 0
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 2
78512: PUSH
78513: LD_INT 1
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 1
78522: NEG
78523: PUSH
78524: LD_INT 1
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 2
78533: NEG
78534: PUSH
78535: LD_INT 0
78537: PUSH
78538: EMPTY
78539: LIST
78540: LIST
78541: PUSH
78542: LD_INT 2
78544: NEG
78545: PUSH
78546: LD_INT 1
78548: NEG
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 2
78556: PUSH
78557: LD_INT 1
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 3
78567: PUSH
78568: LD_INT 0
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 3
78577: PUSH
78578: LD_INT 1
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: LIST
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78603: LD_ADDR_VAR 0 16
78607: PUSH
78608: LD_INT 0
78610: PUSH
78611: LD_INT 0
78613: PUSH
78614: EMPTY
78615: LIST
78616: LIST
78617: PUSH
78618: LD_INT 0
78620: PUSH
78621: LD_INT 1
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 1
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 1
78641: PUSH
78642: LD_INT 1
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 0
78651: PUSH
78652: LD_INT 1
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: NEG
78662: PUSH
78663: LD_INT 0
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: PUSH
78674: LD_INT 1
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 1
78684: NEG
78685: PUSH
78686: LD_INT 2
78688: NEG
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 2
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 2
78706: PUSH
78707: LD_INT 2
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 1
78716: PUSH
78717: LD_INT 2
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 2
78726: NEG
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 2
78738: NEG
78739: PUSH
78740: LD_INT 2
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 3
78750: PUSH
78751: LD_INT 2
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 3
78760: PUSH
78761: LD_INT 3
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 2
78770: PUSH
78771: LD_INT 3
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78796: LD_ADDR_VAR 0 17
78800: PUSH
78801: LD_INT 0
78803: PUSH
78804: LD_INT 0
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 0
78813: PUSH
78814: LD_INT 1
78816: NEG
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: PUSH
78822: LD_INT 1
78824: PUSH
78825: LD_INT 0
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 1
78834: PUSH
78835: LD_INT 1
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 0
78844: PUSH
78845: LD_INT 1
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 1
78854: NEG
78855: PUSH
78856: LD_INT 0
78858: PUSH
78859: EMPTY
78860: LIST
78861: LIST
78862: PUSH
78863: LD_INT 1
78865: NEG
78866: PUSH
78867: LD_INT 1
78869: NEG
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 1
78877: NEG
78878: PUSH
78879: LD_INT 2
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 0
78889: PUSH
78890: LD_INT 2
78892: NEG
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 1
78900: PUSH
78901: LD_INT 1
78903: NEG
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 2
78911: PUSH
78912: LD_INT 0
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 2
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: PUSH
78932: LD_INT 2
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 1
78941: PUSH
78942: LD_INT 2
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 0
78951: PUSH
78952: LD_INT 2
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 1
78961: NEG
78962: PUSH
78963: LD_INT 1
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 2
78972: NEG
78973: PUSH
78974: LD_INT 0
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 2
78983: NEG
78984: PUSH
78985: LD_INT 1
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 2
78995: NEG
78996: PUSH
78997: LD_INT 2
78999: NEG
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79026: LD_ADDR_VAR 0 18
79030: PUSH
79031: LD_INT 0
79033: PUSH
79034: LD_INT 0
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 0
79043: PUSH
79044: LD_INT 1
79046: NEG
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 1
79054: PUSH
79055: LD_INT 0
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 1
79064: PUSH
79065: LD_INT 1
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 0
79074: PUSH
79075: LD_INT 1
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 1
79084: NEG
79085: PUSH
79086: LD_INT 0
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 1
79095: NEG
79096: PUSH
79097: LD_INT 1
79099: NEG
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 1
79107: NEG
79108: PUSH
79109: LD_INT 2
79111: NEG
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 0
79119: PUSH
79120: LD_INT 2
79122: NEG
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: LD_INT 1
79133: NEG
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 2
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 2
79151: PUSH
79152: LD_INT 1
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 2
79161: PUSH
79162: LD_INT 2
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 1
79171: PUSH
79172: LD_INT 2
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 0
79181: PUSH
79182: LD_INT 2
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 1
79191: NEG
79192: PUSH
79193: LD_INT 1
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PUSH
79200: LD_INT 2
79202: NEG
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: LD_INT 2
79213: NEG
79214: PUSH
79215: LD_INT 1
79217: NEG
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 2
79225: NEG
79226: PUSH
79227: LD_INT 2
79229: NEG
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: LIST
79251: LIST
79252: LIST
79253: LIST
79254: LIST
79255: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79256: LD_ADDR_VAR 0 19
79260: PUSH
79261: LD_INT 0
79263: PUSH
79264: LD_INT 0
79266: PUSH
79267: EMPTY
79268: LIST
79269: LIST
79270: PUSH
79271: LD_INT 0
79273: PUSH
79274: LD_INT 1
79276: NEG
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 1
79284: PUSH
79285: LD_INT 0
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 1
79294: PUSH
79295: LD_INT 1
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 0
79304: PUSH
79305: LD_INT 1
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 1
79314: NEG
79315: PUSH
79316: LD_INT 0
79318: PUSH
79319: EMPTY
79320: LIST
79321: LIST
79322: PUSH
79323: LD_INT 1
79325: NEG
79326: PUSH
79327: LD_INT 1
79329: NEG
79330: PUSH
79331: EMPTY
79332: LIST
79333: LIST
79334: PUSH
79335: LD_INT 1
79337: NEG
79338: PUSH
79339: LD_INT 2
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 0
79349: PUSH
79350: LD_INT 2
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 1
79360: PUSH
79361: LD_INT 1
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 2
79371: PUSH
79372: LD_INT 0
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 2
79381: PUSH
79382: LD_INT 1
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 2
79391: PUSH
79392: LD_INT 2
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 1
79401: PUSH
79402: LD_INT 2
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: LD_INT 2
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 1
79421: NEG
79422: PUSH
79423: LD_INT 1
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 2
79432: NEG
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 2
79443: NEG
79444: PUSH
79445: LD_INT 1
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 2
79455: NEG
79456: PUSH
79457: LD_INT 2
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: LIST
79469: LIST
79470: LIST
79471: LIST
79472: LIST
79473: LIST
79474: LIST
79475: LIST
79476: LIST
79477: LIST
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79486: LD_ADDR_VAR 0 20
79490: PUSH
79491: LD_INT 0
79493: PUSH
79494: LD_INT 0
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 0
79503: PUSH
79504: LD_INT 1
79506: NEG
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 1
79514: PUSH
79515: LD_INT 0
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: LD_INT 1
79524: PUSH
79525: LD_INT 1
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 0
79534: PUSH
79535: LD_INT 1
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 1
79544: NEG
79545: PUSH
79546: LD_INT 0
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 1
79555: NEG
79556: PUSH
79557: LD_INT 1
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 1
79567: NEG
79568: PUSH
79569: LD_INT 2
79571: NEG
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 0
79579: PUSH
79580: LD_INT 2
79582: NEG
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 1
79590: PUSH
79591: LD_INT 1
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 2
79601: PUSH
79602: LD_INT 0
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 2
79611: PUSH
79612: LD_INT 1
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 2
79621: PUSH
79622: LD_INT 2
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: PUSH
79632: LD_INT 2
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 0
79641: PUSH
79642: LD_INT 2
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 1
79651: NEG
79652: PUSH
79653: LD_INT 1
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 2
79662: NEG
79663: PUSH
79664: LD_INT 0
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 2
79673: NEG
79674: PUSH
79675: LD_INT 1
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: LD_INT 2
79685: NEG
79686: PUSH
79687: LD_INT 2
79689: NEG
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79716: LD_ADDR_VAR 0 21
79720: PUSH
79721: LD_INT 0
79723: PUSH
79724: LD_INT 0
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 0
79733: PUSH
79734: LD_INT 1
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 1
79744: PUSH
79745: LD_INT 0
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: LD_INT 1
79754: PUSH
79755: LD_INT 1
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: LD_INT 0
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 1
79774: NEG
79775: PUSH
79776: LD_INT 0
79778: PUSH
79779: EMPTY
79780: LIST
79781: LIST
79782: PUSH
79783: LD_INT 1
79785: NEG
79786: PUSH
79787: LD_INT 1
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 1
79797: NEG
79798: PUSH
79799: LD_INT 2
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 0
79809: PUSH
79810: LD_INT 2
79812: NEG
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 1
79820: PUSH
79821: LD_INT 1
79823: NEG
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 2
79831: PUSH
79832: LD_INT 0
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 2
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 2
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: LD_INT 2
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: LD_INT 2
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: LD_INT 1
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 2
79892: NEG
79893: PUSH
79894: LD_INT 0
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 2
79903: NEG
79904: PUSH
79905: LD_INT 1
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 2
79915: NEG
79916: PUSH
79917: LD_INT 2
79919: NEG
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79946: LD_ADDR_VAR 0 22
79950: PUSH
79951: LD_INT 0
79953: PUSH
79954: LD_INT 0
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 0
79963: PUSH
79964: LD_INT 1
79966: NEG
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: LD_INT 0
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 1
79984: PUSH
79985: LD_INT 1
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: PUSH
79992: LD_INT 0
79994: PUSH
79995: LD_INT 1
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 1
80004: NEG
80005: PUSH
80006: LD_INT 0
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 1
80015: NEG
80016: PUSH
80017: LD_INT 1
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 1
80027: NEG
80028: PUSH
80029: LD_INT 2
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: LD_INT 2
80042: NEG
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: LD_INT 1
80053: NEG
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 2
80061: PUSH
80062: LD_INT 0
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 2
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 2
80081: PUSH
80082: LD_INT 2
80084: PUSH
80085: EMPTY
80086: LIST
80087: LIST
80088: PUSH
80089: LD_INT 1
80091: PUSH
80092: LD_INT 2
80094: PUSH
80095: EMPTY
80096: LIST
80097: LIST
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: LD_INT 2
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 1
80111: NEG
80112: PUSH
80113: LD_INT 1
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 2
80122: NEG
80123: PUSH
80124: LD_INT 0
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 2
80133: NEG
80134: PUSH
80135: LD_INT 1
80137: NEG
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: PUSH
80143: LD_INT 2
80145: NEG
80146: PUSH
80147: LD_INT 2
80149: NEG
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80176: LD_ADDR_VAR 0 23
80180: PUSH
80181: LD_INT 0
80183: PUSH
80184: LD_INT 0
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: LD_INT 1
80196: NEG
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: PUSH
80205: LD_INT 0
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 1
80214: PUSH
80215: LD_INT 1
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 0
80224: PUSH
80225: LD_INT 1
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 1
80234: NEG
80235: PUSH
80236: LD_INT 0
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: LD_INT 2
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 0
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 1
80280: PUSH
80281: LD_INT 1
80283: NEG
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 2
80291: PUSH
80292: LD_INT 0
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 2
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 2
80311: PUSH
80312: LD_INT 2
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PUSH
80319: LD_INT 1
80321: PUSH
80322: LD_INT 2
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 0
80331: PUSH
80332: LD_INT 2
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 1
80341: NEG
80342: PUSH
80343: LD_INT 1
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 2
80352: NEG
80353: PUSH
80354: LD_INT 0
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 2
80363: NEG
80364: PUSH
80365: LD_INT 1
80367: NEG
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: LD_INT 2
80375: NEG
80376: PUSH
80377: LD_INT 2
80379: NEG
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 2
80387: NEG
80388: PUSH
80389: LD_INT 3
80391: NEG
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 1
80399: NEG
80400: PUSH
80401: LD_INT 3
80403: NEG
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 1
80411: PUSH
80412: LD_INT 2
80414: NEG
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 2
80422: PUSH
80423: LD_INT 1
80425: NEG
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: LIST
80435: LIST
80436: LIST
80437: LIST
80438: LIST
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80456: LD_ADDR_VAR 0 24
80460: PUSH
80461: LD_INT 0
80463: PUSH
80464: LD_INT 0
80466: PUSH
80467: EMPTY
80468: LIST
80469: LIST
80470: PUSH
80471: LD_INT 0
80473: PUSH
80474: LD_INT 1
80476: NEG
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 1
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 1
80494: PUSH
80495: LD_INT 1
80497: PUSH
80498: EMPTY
80499: LIST
80500: LIST
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 1
80514: NEG
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: NEG
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 1
80537: NEG
80538: PUSH
80539: LD_INT 2
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: LD_INT 2
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 1
80560: PUSH
80561: LD_INT 1
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 2
80571: PUSH
80572: LD_INT 0
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 2
80581: PUSH
80582: LD_INT 1
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 2
80591: PUSH
80592: LD_INT 2
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 1
80601: PUSH
80602: LD_INT 2
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 0
80611: PUSH
80612: LD_INT 2
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 1
80621: NEG
80622: PUSH
80623: LD_INT 1
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 2
80632: NEG
80633: PUSH
80634: LD_INT 0
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: PUSH
80641: LD_INT 2
80643: NEG
80644: PUSH
80645: LD_INT 1
80647: NEG
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 2
80655: NEG
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 1
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 2
80678: PUSH
80679: LD_INT 1
80681: NEG
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 3
80689: PUSH
80690: LD_INT 1
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 3
80699: PUSH
80700: LD_INT 2
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80732: LD_ADDR_VAR 0 25
80736: PUSH
80737: LD_INT 0
80739: PUSH
80740: LD_INT 0
80742: PUSH
80743: EMPTY
80744: LIST
80745: LIST
80746: PUSH
80747: LD_INT 0
80749: PUSH
80750: LD_INT 1
80752: NEG
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 1
80760: PUSH
80761: LD_INT 0
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 1
80770: PUSH
80771: LD_INT 1
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 0
80780: PUSH
80781: LD_INT 1
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 1
80790: NEG
80791: PUSH
80792: LD_INT 0
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 1
80801: NEG
80802: PUSH
80803: LD_INT 1
80805: NEG
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 1
80813: NEG
80814: PUSH
80815: LD_INT 2
80817: NEG
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 0
80825: PUSH
80826: LD_INT 2
80828: NEG
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 1
80836: PUSH
80837: LD_INT 1
80839: NEG
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 2
80847: PUSH
80848: LD_INT 0
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 2
80857: PUSH
80858: LD_INT 1
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 2
80867: PUSH
80868: LD_INT 2
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: LD_INT 1
80877: PUSH
80878: LD_INT 2
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 0
80887: PUSH
80888: LD_INT 2
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: LD_INT 1
80897: NEG
80898: PUSH
80899: LD_INT 1
80901: PUSH
80902: EMPTY
80903: LIST
80904: LIST
80905: PUSH
80906: LD_INT 2
80908: NEG
80909: PUSH
80910: LD_INT 0
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 2
80919: NEG
80920: PUSH
80921: LD_INT 1
80923: NEG
80924: PUSH
80925: EMPTY
80926: LIST
80927: LIST
80928: PUSH
80929: LD_INT 2
80931: NEG
80932: PUSH
80933: LD_INT 2
80935: NEG
80936: PUSH
80937: EMPTY
80938: LIST
80939: LIST
80940: PUSH
80941: LD_INT 3
80943: PUSH
80944: LD_INT 1
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 3
80953: PUSH
80954: LD_INT 2
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 2
80963: PUSH
80964: LD_INT 3
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 1
80973: PUSH
80974: LD_INT 3
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81006: LD_ADDR_VAR 0 26
81010: PUSH
81011: LD_INT 0
81013: PUSH
81014: LD_INT 0
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 0
81023: PUSH
81024: LD_INT 1
81026: NEG
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: PUSH
81035: LD_INT 0
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: LD_INT 1
81047: PUSH
81048: EMPTY
81049: LIST
81050: LIST
81051: PUSH
81052: LD_INT 0
81054: PUSH
81055: LD_INT 1
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 1
81064: NEG
81065: PUSH
81066: LD_INT 0
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: LD_INT 1
81079: NEG
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 1
81087: NEG
81088: PUSH
81089: LD_INT 2
81091: NEG
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 0
81099: PUSH
81100: LD_INT 2
81102: NEG
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 1
81110: PUSH
81111: LD_INT 1
81113: NEG
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 2
81121: PUSH
81122: LD_INT 0
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 2
81131: PUSH
81132: LD_INT 1
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 2
81141: PUSH
81142: LD_INT 2
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 1
81151: PUSH
81152: LD_INT 2
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 0
81161: PUSH
81162: LD_INT 2
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 1
81171: NEG
81172: PUSH
81173: LD_INT 1
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 2
81182: NEG
81183: PUSH
81184: LD_INT 0
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 2
81193: NEG
81194: PUSH
81195: LD_INT 1
81197: NEG
81198: PUSH
81199: EMPTY
81200: LIST
81201: LIST
81202: PUSH
81203: LD_INT 2
81205: NEG
81206: PUSH
81207: LD_INT 2
81209: NEG
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 2
81217: PUSH
81218: LD_INT 3
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 1
81227: PUSH
81228: LD_INT 3
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PUSH
81235: LD_INT 1
81237: NEG
81238: PUSH
81239: LD_INT 2
81241: PUSH
81242: EMPTY
81243: LIST
81244: LIST
81245: PUSH
81246: LD_INT 2
81248: NEG
81249: PUSH
81250: LD_INT 1
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81282: LD_ADDR_VAR 0 27
81286: PUSH
81287: LD_INT 0
81289: PUSH
81290: LD_INT 0
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: LD_INT 1
81302: NEG
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 1
81310: PUSH
81311: LD_INT 0
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 1
81320: PUSH
81321: LD_INT 1
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 0
81330: PUSH
81331: LD_INT 1
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 1
81340: NEG
81341: PUSH
81342: LD_INT 0
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 1
81351: NEG
81352: PUSH
81353: LD_INT 1
81355: NEG
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 1
81363: NEG
81364: PUSH
81365: LD_INT 2
81367: NEG
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PUSH
81373: LD_INT 0
81375: PUSH
81376: LD_INT 2
81378: NEG
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 1
81386: PUSH
81387: LD_INT 1
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 2
81397: PUSH
81398: LD_INT 0
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: LD_INT 1
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 2
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 1
81427: PUSH
81428: LD_INT 2
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: LD_INT 0
81437: PUSH
81438: LD_INT 2
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 1
81447: NEG
81448: PUSH
81449: LD_INT 1
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 2
81458: NEG
81459: PUSH
81460: LD_INT 0
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 2
81469: NEG
81470: PUSH
81471: LD_INT 1
81473: NEG
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 2
81481: NEG
81482: PUSH
81483: LD_INT 2
81485: NEG
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: LD_INT 2
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 2
81504: NEG
81505: PUSH
81506: LD_INT 1
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 3
81515: NEG
81516: PUSH
81517: LD_INT 1
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 3
81527: NEG
81528: PUSH
81529: LD_INT 2
81531: NEG
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81562: LD_ADDR_VAR 0 28
81566: PUSH
81567: LD_INT 0
81569: PUSH
81570: LD_INT 0
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: LD_INT 1
81582: NEG
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 1
81590: PUSH
81591: LD_INT 0
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 1
81600: PUSH
81601: LD_INT 1
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 0
81610: PUSH
81611: LD_INT 1
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 1
81620: NEG
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 1
81631: NEG
81632: PUSH
81633: LD_INT 1
81635: NEG
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 1
81643: NEG
81644: PUSH
81645: LD_INT 2
81647: NEG
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 0
81655: PUSH
81656: LD_INT 2
81658: NEG
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 1
81666: PUSH
81667: LD_INT 1
81669: NEG
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 2
81677: PUSH
81678: LD_INT 0
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 2
81687: PUSH
81688: LD_INT 1
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 2
81697: PUSH
81698: LD_INT 2
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 1
81707: PUSH
81708: LD_INT 2
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 0
81717: PUSH
81718: LD_INT 2
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 1
81727: NEG
81728: PUSH
81729: LD_INT 1
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 2
81738: NEG
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 2
81749: NEG
81750: PUSH
81751: LD_INT 1
81753: NEG
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 2
81761: NEG
81762: PUSH
81763: LD_INT 2
81765: NEG
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 2
81773: NEG
81774: PUSH
81775: LD_INT 3
81777: NEG
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 1
81785: NEG
81786: PUSH
81787: LD_INT 3
81789: NEG
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 3
81797: NEG
81798: PUSH
81799: LD_INT 1
81801: NEG
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 3
81809: NEG
81810: PUSH
81811: LD_INT 2
81813: NEG
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: LIST
81823: LIST
81824: LIST
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: LIST
81832: LIST
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81844: LD_ADDR_VAR 0 29
81848: PUSH
81849: LD_INT 0
81851: PUSH
81852: LD_INT 0
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 0
81861: PUSH
81862: LD_INT 1
81864: NEG
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 1
81872: PUSH
81873: LD_INT 0
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 1
81882: PUSH
81883: LD_INT 1
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 0
81892: PUSH
81893: LD_INT 1
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: LD_INT 0
81906: PUSH
81907: EMPTY
81908: LIST
81909: LIST
81910: PUSH
81911: LD_INT 1
81913: NEG
81914: PUSH
81915: LD_INT 1
81917: NEG
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 1
81925: NEG
81926: PUSH
81927: LD_INT 2
81929: NEG
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: PUSH
81935: LD_INT 0
81937: PUSH
81938: LD_INT 2
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 2
81959: PUSH
81960: LD_INT 0
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 2
81969: PUSH
81970: LD_INT 1
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 1
81979: PUSH
81980: LD_INT 2
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 0
81989: PUSH
81990: LD_INT 2
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 1
81999: NEG
82000: PUSH
82001: LD_INT 1
82003: PUSH
82004: EMPTY
82005: LIST
82006: LIST
82007: PUSH
82008: LD_INT 2
82010: NEG
82011: PUSH
82012: LD_INT 1
82014: NEG
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 2
82022: NEG
82023: PUSH
82024: LD_INT 2
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 2
82034: NEG
82035: PUSH
82036: LD_INT 3
82038: NEG
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 2
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 3
82057: PUSH
82058: LD_INT 1
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: LD_INT 3
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 1
82077: NEG
82078: PUSH
82079: LD_INT 2
82081: PUSH
82082: EMPTY
82083: LIST
82084: LIST
82085: PUSH
82086: LD_INT 3
82088: NEG
82089: PUSH
82090: LD_INT 2
82092: NEG
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82123: LD_ADDR_VAR 0 30
82127: PUSH
82128: LD_INT 0
82130: PUSH
82131: LD_INT 0
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 0
82140: PUSH
82141: LD_INT 1
82143: NEG
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 1
82151: PUSH
82152: LD_INT 0
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 1
82161: PUSH
82162: LD_INT 1
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 0
82171: PUSH
82172: LD_INT 1
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 1
82181: NEG
82182: PUSH
82183: LD_INT 0
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 1
82192: NEG
82193: PUSH
82194: LD_INT 1
82196: NEG
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 1
82204: NEG
82205: PUSH
82206: LD_INT 2
82208: NEG
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 0
82216: PUSH
82217: LD_INT 2
82219: NEG
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 1
82227: PUSH
82228: LD_INT 1
82230: NEG
82231: PUSH
82232: EMPTY
82233: LIST
82234: LIST
82235: PUSH
82236: LD_INT 2
82238: PUSH
82239: LD_INT 0
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 2
82248: PUSH
82249: LD_INT 1
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: LD_INT 2
82258: PUSH
82259: LD_INT 2
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: LD_INT 1
82268: PUSH
82269: LD_INT 2
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 1
82278: NEG
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PUSH
82287: LD_INT 2
82289: NEG
82290: PUSH
82291: LD_INT 0
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 2
82300: NEG
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 1
82312: NEG
82313: PUSH
82314: LD_INT 3
82316: NEG
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 1
82324: PUSH
82325: LD_INT 2
82327: NEG
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 3
82335: PUSH
82336: LD_INT 2
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 2
82345: PUSH
82346: LD_INT 3
82348: PUSH
82349: EMPTY
82350: LIST
82351: LIST
82352: PUSH
82353: LD_INT 2
82355: NEG
82356: PUSH
82357: LD_INT 1
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 3
82366: NEG
82367: PUSH
82368: LD_INT 1
82370: NEG
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: LIST
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82401: LD_ADDR_VAR 0 31
82405: PUSH
82406: LD_INT 0
82408: PUSH
82409: LD_INT 0
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 0
82418: PUSH
82419: LD_INT 1
82421: NEG
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 1
82429: PUSH
82430: LD_INT 0
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 1
82439: PUSH
82440: LD_INT 1
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: LD_INT 1
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 1
82459: NEG
82460: PUSH
82461: LD_INT 0
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: PUSH
82468: LD_INT 1
82470: NEG
82471: PUSH
82472: LD_INT 1
82474: NEG
82475: PUSH
82476: EMPTY
82477: LIST
82478: LIST
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: LD_INT 2
82486: NEG
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 1
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 2
82505: PUSH
82506: LD_INT 0
82508: PUSH
82509: EMPTY
82510: LIST
82511: LIST
82512: PUSH
82513: LD_INT 2
82515: PUSH
82516: LD_INT 1
82518: PUSH
82519: EMPTY
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 2
82525: PUSH
82526: LD_INT 2
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 1
82535: PUSH
82536: LD_INT 2
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 0
82545: PUSH
82546: LD_INT 2
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 1
82555: NEG
82556: PUSH
82557: LD_INT 1
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 2
82566: NEG
82567: PUSH
82568: LD_INT 1
82570: NEG
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 2
82578: NEG
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 2
82590: NEG
82591: PUSH
82592: LD_INT 3
82594: NEG
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 2
82602: PUSH
82603: LD_INT 1
82605: NEG
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 3
82613: PUSH
82614: LD_INT 1
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: PUSH
82621: LD_INT 1
82623: PUSH
82624: LD_INT 3
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 1
82633: NEG
82634: PUSH
82635: LD_INT 2
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 3
82644: NEG
82645: PUSH
82646: LD_INT 2
82648: NEG
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82679: LD_ADDR_VAR 0 32
82683: PUSH
82684: LD_INT 0
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 0
82696: PUSH
82697: LD_INT 1
82699: NEG
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 1
82707: PUSH
82708: LD_INT 0
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: PUSH
82718: LD_INT 1
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 0
82727: PUSH
82728: LD_INT 1
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_INT 1
82737: NEG
82738: PUSH
82739: LD_INT 0
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 1
82748: NEG
82749: PUSH
82750: LD_INT 1
82752: NEG
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: PUSH
82758: LD_INT 1
82760: NEG
82761: PUSH
82762: LD_INT 2
82764: NEG
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 0
82772: PUSH
82773: LD_INT 2
82775: NEG
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: PUSH
82784: LD_INT 1
82786: NEG
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 2
82794: PUSH
82795: LD_INT 1
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 2
82804: PUSH
82805: LD_INT 2
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 1
82814: PUSH
82815: LD_INT 2
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: LD_INT 2
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 1
82834: NEG
82835: PUSH
82836: LD_INT 1
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 2
82845: NEG
82846: PUSH
82847: LD_INT 0
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 2
82856: NEG
82857: PUSH
82858: LD_INT 1
82860: NEG
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: PUSH
82866: LD_INT 1
82868: NEG
82869: PUSH
82870: LD_INT 3
82872: NEG
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 1
82880: PUSH
82881: LD_INT 2
82883: NEG
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 3
82891: PUSH
82892: LD_INT 2
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 2
82901: PUSH
82902: LD_INT 3
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 2
82911: NEG
82912: PUSH
82913: LD_INT 1
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 3
82922: NEG
82923: PUSH
82924: LD_INT 1
82926: NEG
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: LIST
82936: LIST
82937: LIST
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: LIST
82943: LIST
82944: LIST
82945: LIST
82946: LIST
82947: LIST
82948: LIST
82949: LIST
82950: LIST
82951: LIST
82952: LIST
82953: LIST
82954: LIST
82955: LIST
82956: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82957: LD_ADDR_VAR 0 33
82961: PUSH
82962: LD_INT 0
82964: PUSH
82965: LD_INT 0
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: LD_INT 0
82974: PUSH
82975: LD_INT 1
82977: NEG
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 1
82985: PUSH
82986: LD_INT 0
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PUSH
82993: LD_INT 1
82995: PUSH
82996: LD_INT 1
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: LD_INT 0
83005: PUSH
83006: LD_INT 1
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 1
83015: NEG
83016: PUSH
83017: LD_INT 0
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: LD_INT 1
83026: NEG
83027: PUSH
83028: LD_INT 1
83030: NEG
83031: PUSH
83032: EMPTY
83033: LIST
83034: LIST
83035: PUSH
83036: LD_INT 1
83038: NEG
83039: PUSH
83040: LD_INT 2
83042: NEG
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: LD_INT 1
83053: NEG
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 2
83061: PUSH
83062: LD_INT 0
83064: PUSH
83065: EMPTY
83066: LIST
83067: LIST
83068: PUSH
83069: LD_INT 2
83071: PUSH
83072: LD_INT 1
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: LD_INT 2
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: PUSH
83089: LD_INT 0
83091: PUSH
83092: LD_INT 2
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 1
83101: NEG
83102: PUSH
83103: LD_INT 1
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 2
83112: NEG
83113: PUSH
83114: LD_INT 0
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 2
83123: NEG
83124: PUSH
83125: LD_INT 1
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 2
83135: NEG
83136: PUSH
83137: LD_INT 2
83139: NEG
83140: PUSH
83141: EMPTY
83142: LIST
83143: LIST
83144: PUSH
83145: LD_INT 2
83147: NEG
83148: PUSH
83149: LD_INT 3
83151: NEG
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: LD_INT 1
83162: NEG
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 3
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 1
83180: PUSH
83181: LD_INT 3
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: NEG
83191: PUSH
83192: LD_INT 2
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 3
83201: NEG
83202: PUSH
83203: LD_INT 2
83205: NEG
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83236: LD_ADDR_VAR 0 34
83240: PUSH
83241: LD_INT 0
83243: PUSH
83244: LD_INT 0
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 0
83253: PUSH
83254: LD_INT 1
83256: NEG
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 1
83264: PUSH
83265: LD_INT 0
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: PUSH
83272: LD_INT 1
83274: PUSH
83275: LD_INT 1
83277: PUSH
83278: EMPTY
83279: LIST
83280: LIST
83281: PUSH
83282: LD_INT 0
83284: PUSH
83285: LD_INT 1
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 1
83294: NEG
83295: PUSH
83296: LD_INT 0
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 1
83305: NEG
83306: PUSH
83307: LD_INT 1
83309: NEG
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 1
83317: NEG
83318: PUSH
83319: LD_INT 2
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 0
83329: PUSH
83330: LD_INT 2
83332: NEG
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 1
83340: PUSH
83341: LD_INT 1
83343: NEG
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 2
83351: PUSH
83352: LD_INT 1
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 2
83361: PUSH
83362: LD_INT 2
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 1
83371: PUSH
83372: LD_INT 2
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 1
83381: NEG
83382: PUSH
83383: LD_INT 1
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 2
83392: NEG
83393: PUSH
83394: LD_INT 0
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 2
83403: NEG
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 2
83415: NEG
83416: PUSH
83417: LD_INT 2
83419: NEG
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 1
83427: NEG
83428: PUSH
83429: LD_INT 3
83431: NEG
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: LD_INT 2
83442: NEG
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 3
83450: PUSH
83451: LD_INT 2
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: PUSH
83458: LD_INT 2
83460: PUSH
83461: LD_INT 3
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 2
83470: NEG
83471: PUSH
83472: LD_INT 1
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 3
83481: NEG
83482: PUSH
83483: LD_INT 1
83485: NEG
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: LIST
83495: LIST
83496: LIST
83497: LIST
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: LIST
83505: LIST
83506: LIST
83507: LIST
83508: LIST
83509: LIST
83510: LIST
83511: LIST
83512: LIST
83513: LIST
83514: LIST
83515: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83516: LD_ADDR_VAR 0 35
83520: PUSH
83521: LD_INT 0
83523: PUSH
83524: LD_INT 0
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 0
83533: PUSH
83534: LD_INT 1
83536: NEG
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: PUSH
83545: LD_INT 0
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 1
83554: PUSH
83555: LD_INT 1
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 0
83564: PUSH
83565: LD_INT 1
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 1
83574: NEG
83575: PUSH
83576: LD_INT 0
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 1
83585: NEG
83586: PUSH
83587: LD_INT 1
83589: NEG
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 2
83597: PUSH
83598: LD_INT 1
83600: PUSH
83601: EMPTY
83602: LIST
83603: LIST
83604: PUSH
83605: LD_INT 2
83607: NEG
83608: PUSH
83609: LD_INT 1
83611: NEG
83612: PUSH
83613: EMPTY
83614: LIST
83615: LIST
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83628: LD_ADDR_VAR 0 36
83632: PUSH
83633: LD_INT 0
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 0
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 1
83656: PUSH
83657: LD_INT 0
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 1
83666: PUSH
83667: LD_INT 1
83669: PUSH
83670: EMPTY
83671: LIST
83672: LIST
83673: PUSH
83674: LD_INT 0
83676: PUSH
83677: LD_INT 1
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: LD_INT 0
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: LD_INT 2
83713: NEG
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 1
83721: PUSH
83722: LD_INT 2
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: EMPTY
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83740: LD_ADDR_VAR 0 37
83744: PUSH
83745: LD_INT 0
83747: PUSH
83748: LD_INT 0
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 0
83757: PUSH
83758: LD_INT 1
83760: NEG
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: PUSH
83769: LD_INT 0
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: PUSH
83779: LD_INT 1
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 0
83788: PUSH
83789: LD_INT 1
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: PUSH
83796: LD_INT 1
83798: NEG
83799: PUSH
83800: LD_INT 0
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 1
83809: NEG
83810: PUSH
83811: LD_INT 1
83813: NEG
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 1
83821: PUSH
83822: LD_INT 1
83824: NEG
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 1
83832: NEG
83833: PUSH
83834: LD_INT 1
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83852: LD_ADDR_VAR 0 38
83856: PUSH
83857: LD_INT 0
83859: PUSH
83860: LD_INT 0
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 0
83869: PUSH
83870: LD_INT 1
83872: NEG
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 1
83880: PUSH
83881: LD_INT 0
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 1
83890: PUSH
83891: LD_INT 1
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PUSH
83898: LD_INT 0
83900: PUSH
83901: LD_INT 1
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 1
83910: NEG
83911: PUSH
83912: LD_INT 0
83914: PUSH
83915: EMPTY
83916: LIST
83917: LIST
83918: PUSH
83919: LD_INT 1
83921: NEG
83922: PUSH
83923: LD_INT 1
83925: NEG
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: PUSH
83931: LD_INT 2
83933: PUSH
83934: LD_INT 1
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: LD_INT 2
83943: NEG
83944: PUSH
83945: LD_INT 1
83947: NEG
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83964: LD_ADDR_VAR 0 39
83968: PUSH
83969: LD_INT 0
83971: PUSH
83972: LD_INT 0
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 0
83981: PUSH
83982: LD_INT 1
83984: NEG
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 1
83992: PUSH
83993: LD_INT 0
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 1
84002: PUSH
84003: LD_INT 1
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 0
84012: PUSH
84013: LD_INT 1
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 1
84022: NEG
84023: PUSH
84024: LD_INT 0
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 1
84033: NEG
84034: PUSH
84035: LD_INT 1
84037: NEG
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 1
84045: NEG
84046: PUSH
84047: LD_INT 2
84049: NEG
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: LD_INT 1
84057: PUSH
84058: LD_INT 2
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: EMPTY
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84076: LD_ADDR_VAR 0 40
84080: PUSH
84081: LD_INT 0
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 0
84093: PUSH
84094: LD_INT 1
84096: NEG
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 1
84104: PUSH
84105: LD_INT 0
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 1
84114: PUSH
84115: LD_INT 1
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 0
84124: PUSH
84125: LD_INT 1
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: PUSH
84132: LD_INT 1
84134: NEG
84135: PUSH
84136: LD_INT 0
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 1
84145: NEG
84146: PUSH
84147: LD_INT 1
84149: NEG
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: LD_INT 1
84157: PUSH
84158: LD_INT 1
84160: NEG
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 1
84168: NEG
84169: PUSH
84170: LD_INT 1
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: LIST
84181: LIST
84182: LIST
84183: LIST
84184: LIST
84185: LIST
84186: LIST
84187: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84188: LD_ADDR_VAR 0 41
84192: PUSH
84193: LD_INT 0
84195: PUSH
84196: LD_INT 0
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 0
84205: PUSH
84206: LD_INT 1
84208: NEG
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 1
84216: PUSH
84217: LD_INT 0
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 1
84226: PUSH
84227: LD_INT 1
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 0
84236: PUSH
84237: LD_INT 1
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 1
84246: NEG
84247: PUSH
84248: LD_INT 0
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PUSH
84255: LD_INT 1
84257: NEG
84258: PUSH
84259: LD_INT 1
84261: NEG
84262: PUSH
84263: EMPTY
84264: LIST
84265: LIST
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: LD_INT 2
84273: NEG
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 1
84281: PUSH
84282: LD_INT 1
84284: NEG
84285: PUSH
84286: EMPTY
84287: LIST
84288: LIST
84289: PUSH
84290: LD_INT 2
84292: PUSH
84293: LD_INT 0
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: PUSH
84300: LD_INT 2
84302: PUSH
84303: LD_INT 1
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 2
84312: PUSH
84313: LD_INT 2
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: LD_INT 1
84322: PUSH
84323: LD_INT 2
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PUSH
84330: LD_INT 1
84332: NEG
84333: PUSH
84334: LD_INT 1
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 2
84343: NEG
84344: PUSH
84345: LD_INT 0
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 2
84354: NEG
84355: PUSH
84356: LD_INT 1
84358: NEG
84359: PUSH
84360: EMPTY
84361: LIST
84362: LIST
84363: PUSH
84364: LD_INT 2
84366: NEG
84367: PUSH
84368: LD_INT 2
84370: NEG
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 2
84378: NEG
84379: PUSH
84380: LD_INT 3
84382: NEG
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 2
84390: PUSH
84391: LD_INT 1
84393: NEG
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 3
84401: PUSH
84402: LD_INT 0
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 3
84411: PUSH
84412: LD_INT 1
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 3
84421: PUSH
84422: LD_INT 2
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 3
84431: PUSH
84432: LD_INT 3
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 2
84441: PUSH
84442: LD_INT 3
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 2
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 3
84462: NEG
84463: PUSH
84464: LD_INT 0
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: PUSH
84471: LD_INT 3
84473: NEG
84474: PUSH
84475: LD_INT 1
84477: NEG
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: PUSH
84483: LD_INT 3
84485: NEG
84486: PUSH
84487: LD_INT 2
84489: NEG
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 3
84497: NEG
84498: PUSH
84499: LD_INT 3
84501: NEG
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84538: LD_ADDR_VAR 0 42
84542: PUSH
84543: LD_INT 0
84545: PUSH
84546: LD_INT 0
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 0
84555: PUSH
84556: LD_INT 1
84558: NEG
84559: PUSH
84560: EMPTY
84561: LIST
84562: LIST
84563: PUSH
84564: LD_INT 1
84566: PUSH
84567: LD_INT 0
84569: PUSH
84570: EMPTY
84571: LIST
84572: LIST
84573: PUSH
84574: LD_INT 1
84576: PUSH
84577: LD_INT 1
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 0
84586: PUSH
84587: LD_INT 1
84589: PUSH
84590: EMPTY
84591: LIST
84592: LIST
84593: PUSH
84594: LD_INT 1
84596: NEG
84597: PUSH
84598: LD_INT 0
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 1
84607: NEG
84608: PUSH
84609: LD_INT 1
84611: NEG
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 1
84619: NEG
84620: PUSH
84621: LD_INT 2
84623: NEG
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 0
84631: PUSH
84632: LD_INT 2
84634: NEG
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 1
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 2
84653: PUSH
84654: LD_INT 1
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 2
84663: PUSH
84664: LD_INT 2
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 1
84673: PUSH
84674: LD_INT 2
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 0
84683: PUSH
84684: LD_INT 2
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 1
84693: NEG
84694: PUSH
84695: LD_INT 1
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 2
84704: NEG
84705: PUSH
84706: LD_INT 1
84708: NEG
84709: PUSH
84710: EMPTY
84711: LIST
84712: LIST
84713: PUSH
84714: LD_INT 2
84716: NEG
84717: PUSH
84718: LD_INT 2
84720: NEG
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 2
84728: NEG
84729: PUSH
84730: LD_INT 3
84732: NEG
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PUSH
84738: LD_INT 1
84740: NEG
84741: PUSH
84742: LD_INT 3
84744: NEG
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: PUSH
84750: LD_INT 0
84752: PUSH
84753: LD_INT 3
84755: NEG
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 1
84763: PUSH
84764: LD_INT 2
84766: NEG
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 3
84774: PUSH
84775: LD_INT 2
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 3
84784: PUSH
84785: LD_INT 3
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 2
84794: PUSH
84795: LD_INT 3
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 1
84804: PUSH
84805: LD_INT 3
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 0
84814: PUSH
84815: LD_INT 3
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 1
84824: NEG
84825: PUSH
84826: LD_INT 2
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 3
84835: NEG
84836: PUSH
84837: LD_INT 2
84839: NEG
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 3
84847: NEG
84848: PUSH
84849: LD_INT 3
84851: NEG
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84888: LD_ADDR_VAR 0 43
84892: PUSH
84893: LD_INT 0
84895: PUSH
84896: LD_INT 0
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 0
84905: PUSH
84906: LD_INT 1
84908: NEG
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 1
84916: PUSH
84917: LD_INT 0
84919: PUSH
84920: EMPTY
84921: LIST
84922: LIST
84923: PUSH
84924: LD_INT 1
84926: PUSH
84927: LD_INT 1
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 0
84936: PUSH
84937: LD_INT 1
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: PUSH
84944: LD_INT 1
84946: NEG
84947: PUSH
84948: LD_INT 0
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: PUSH
84955: LD_INT 1
84957: NEG
84958: PUSH
84959: LD_INT 1
84961: NEG
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 1
84969: NEG
84970: PUSH
84971: LD_INT 2
84973: NEG
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 0
84981: PUSH
84982: LD_INT 2
84984: NEG
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 1
84992: PUSH
84993: LD_INT 1
84995: NEG
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 2
85003: PUSH
85004: LD_INT 0
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: PUSH
85011: LD_INT 2
85013: PUSH
85014: LD_INT 1
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 1
85023: PUSH
85024: LD_INT 2
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 0
85033: PUSH
85034: LD_INT 2
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 1
85043: NEG
85044: PUSH
85045: LD_INT 1
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 2
85054: NEG
85055: PUSH
85056: LD_INT 0
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PUSH
85063: LD_INT 2
85065: NEG
85066: PUSH
85067: LD_INT 1
85069: NEG
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 1
85077: NEG
85078: PUSH
85079: LD_INT 3
85081: NEG
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: LD_INT 0
85089: PUSH
85090: LD_INT 3
85092: NEG
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_INT 1
85100: PUSH
85101: LD_INT 2
85103: NEG
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 2
85111: PUSH
85112: LD_INT 1
85114: NEG
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 3
85122: PUSH
85123: LD_INT 0
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 3
85132: PUSH
85133: LD_INT 1
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: PUSH
85143: LD_INT 3
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 0
85152: PUSH
85153: LD_INT 3
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: NEG
85163: PUSH
85164: LD_INT 2
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 2
85173: NEG
85174: PUSH
85175: LD_INT 1
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 3
85184: NEG
85185: PUSH
85186: LD_INT 0
85188: PUSH
85189: EMPTY
85190: LIST
85191: LIST
85192: PUSH
85193: LD_INT 3
85195: NEG
85196: PUSH
85197: LD_INT 1
85199: NEG
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85236: LD_ADDR_VAR 0 44
85240: PUSH
85241: LD_INT 0
85243: PUSH
85244: LD_INT 0
85246: PUSH
85247: EMPTY
85248: LIST
85249: LIST
85250: PUSH
85251: LD_INT 0
85253: PUSH
85254: LD_INT 1
85256: NEG
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: LD_INT 1
85264: PUSH
85265: LD_INT 0
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: PUSH
85272: LD_INT 1
85274: PUSH
85275: LD_INT 1
85277: PUSH
85278: EMPTY
85279: LIST
85280: LIST
85281: PUSH
85282: LD_INT 0
85284: PUSH
85285: LD_INT 1
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PUSH
85292: LD_INT 1
85294: NEG
85295: PUSH
85296: LD_INT 0
85298: PUSH
85299: EMPTY
85300: LIST
85301: LIST
85302: PUSH
85303: LD_INT 1
85305: NEG
85306: PUSH
85307: LD_INT 1
85309: NEG
85310: PUSH
85311: EMPTY
85312: LIST
85313: LIST
85314: PUSH
85315: LD_INT 1
85317: NEG
85318: PUSH
85319: LD_INT 2
85321: NEG
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 1
85329: PUSH
85330: LD_INT 1
85332: NEG
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 2
85340: PUSH
85341: LD_INT 0
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 2
85350: PUSH
85351: LD_INT 1
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 2
85360: PUSH
85361: LD_INT 2
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 1
85370: PUSH
85371: LD_INT 2
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: LD_INT 1
85380: NEG
85381: PUSH
85382: LD_INT 1
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: PUSH
85389: LD_INT 2
85391: NEG
85392: PUSH
85393: LD_INT 0
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 2
85402: NEG
85403: PUSH
85404: LD_INT 1
85406: NEG
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 2
85414: NEG
85415: PUSH
85416: LD_INT 2
85418: NEG
85419: PUSH
85420: EMPTY
85421: LIST
85422: LIST
85423: PUSH
85424: LD_INT 2
85426: NEG
85427: PUSH
85428: LD_INT 3
85430: NEG
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: LD_INT 2
85438: PUSH
85439: LD_INT 1
85441: NEG
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 3
85449: PUSH
85450: LD_INT 0
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 3
85459: PUSH
85460: LD_INT 1
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 3
85469: PUSH
85470: LD_INT 2
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: LD_INT 3
85479: PUSH
85480: LD_INT 3
85482: PUSH
85483: EMPTY
85484: LIST
85485: LIST
85486: PUSH
85487: LD_INT 2
85489: PUSH
85490: LD_INT 3
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: PUSH
85497: LD_INT 2
85499: NEG
85500: PUSH
85501: LD_INT 1
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: PUSH
85508: LD_INT 3
85510: NEG
85511: PUSH
85512: LD_INT 0
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: PUSH
85519: LD_INT 3
85521: NEG
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 3
85533: NEG
85534: PUSH
85535: LD_INT 2
85537: NEG
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: LD_INT 3
85545: NEG
85546: PUSH
85547: LD_INT 3
85549: NEG
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85586: LD_ADDR_VAR 0 45
85590: PUSH
85591: LD_INT 0
85593: PUSH
85594: LD_INT 0
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: LD_INT 1
85606: NEG
85607: PUSH
85608: EMPTY
85609: LIST
85610: LIST
85611: PUSH
85612: LD_INT 1
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 1
85624: PUSH
85625: LD_INT 1
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 0
85634: PUSH
85635: LD_INT 1
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 1
85644: NEG
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 1
85655: NEG
85656: PUSH
85657: LD_INT 1
85659: NEG
85660: PUSH
85661: EMPTY
85662: LIST
85663: LIST
85664: PUSH
85665: LD_INT 1
85667: NEG
85668: PUSH
85669: LD_INT 2
85671: NEG
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: LD_INT 0
85679: PUSH
85680: LD_INT 2
85682: NEG
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: PUSH
85691: LD_INT 1
85693: NEG
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: LD_INT 2
85701: PUSH
85702: LD_INT 1
85704: PUSH
85705: EMPTY
85706: LIST
85707: LIST
85708: PUSH
85709: LD_INT 2
85711: PUSH
85712: LD_INT 2
85714: PUSH
85715: EMPTY
85716: LIST
85717: LIST
85718: PUSH
85719: LD_INT 1
85721: PUSH
85722: LD_INT 2
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 0
85731: PUSH
85732: LD_INT 2
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 1
85741: NEG
85742: PUSH
85743: LD_INT 1
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 2
85752: NEG
85753: PUSH
85754: LD_INT 1
85756: NEG
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 2
85764: NEG
85765: PUSH
85766: LD_INT 2
85768: NEG
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 2
85776: NEG
85777: PUSH
85778: LD_INT 3
85780: NEG
85781: PUSH
85782: EMPTY
85783: LIST
85784: LIST
85785: PUSH
85786: LD_INT 1
85788: NEG
85789: PUSH
85790: LD_INT 3
85792: NEG
85793: PUSH
85794: EMPTY
85795: LIST
85796: LIST
85797: PUSH
85798: LD_INT 0
85800: PUSH
85801: LD_INT 3
85803: NEG
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 1
85811: PUSH
85812: LD_INT 2
85814: NEG
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 3
85822: PUSH
85823: LD_INT 2
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 3
85832: PUSH
85833: LD_INT 3
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 2
85842: PUSH
85843: LD_INT 3
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 1
85852: PUSH
85853: LD_INT 3
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 0
85862: PUSH
85863: LD_INT 3
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 1
85872: NEG
85873: PUSH
85874: LD_INT 2
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 3
85883: NEG
85884: PUSH
85885: LD_INT 2
85887: NEG
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PUSH
85893: LD_INT 3
85895: NEG
85896: PUSH
85897: LD_INT 3
85899: NEG
85900: PUSH
85901: EMPTY
85902: LIST
85903: LIST
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: LIST
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85936: LD_ADDR_VAR 0 46
85940: PUSH
85941: LD_INT 0
85943: PUSH
85944: LD_INT 0
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: LD_INT 1
85956: NEG
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: PUSH
85965: LD_INT 0
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: PUSH
85975: LD_INT 1
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 0
85984: PUSH
85985: LD_INT 1
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 1
85994: NEG
85995: PUSH
85996: LD_INT 0
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 1
86005: NEG
86006: PUSH
86007: LD_INT 1
86009: NEG
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 1
86017: NEG
86018: PUSH
86019: LD_INT 2
86021: NEG
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 0
86029: PUSH
86030: LD_INT 2
86032: NEG
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 1
86040: PUSH
86041: LD_INT 1
86043: NEG
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 2
86051: PUSH
86052: LD_INT 0
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 2
86061: PUSH
86062: LD_INT 1
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PUSH
86069: LD_INT 1
86071: PUSH
86072: LD_INT 2
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 0
86081: PUSH
86082: LD_INT 2
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 1
86091: NEG
86092: PUSH
86093: LD_INT 1
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 2
86102: NEG
86103: PUSH
86104: LD_INT 0
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: PUSH
86111: LD_INT 2
86113: NEG
86114: PUSH
86115: LD_INT 1
86117: NEG
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: NEG
86126: PUSH
86127: LD_INT 3
86129: NEG
86130: PUSH
86131: EMPTY
86132: LIST
86133: LIST
86134: PUSH
86135: LD_INT 0
86137: PUSH
86138: LD_INT 3
86140: NEG
86141: PUSH
86142: EMPTY
86143: LIST
86144: LIST
86145: PUSH
86146: LD_INT 1
86148: PUSH
86149: LD_INT 2
86151: NEG
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 2
86159: PUSH
86160: LD_INT 1
86162: NEG
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 3
86170: PUSH
86171: LD_INT 0
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 3
86180: PUSH
86181: LD_INT 1
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: PUSH
86191: LD_INT 3
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 0
86200: PUSH
86201: LD_INT 3
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: NEG
86211: PUSH
86212: LD_INT 2
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 2
86221: NEG
86222: PUSH
86223: LD_INT 1
86225: PUSH
86226: EMPTY
86227: LIST
86228: LIST
86229: PUSH
86230: LD_INT 3
86232: NEG
86233: PUSH
86234: LD_INT 0
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 3
86243: NEG
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: LIST
86283: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86284: LD_ADDR_VAR 0 47
86288: PUSH
86289: LD_INT 0
86291: PUSH
86292: LD_INT 0
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: LD_INT 1
86304: NEG
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PUSH
86310: LD_INT 1
86312: PUSH
86313: LD_INT 0
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 1
86322: PUSH
86323: LD_INT 1
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: PUSH
86330: LD_INT 0
86332: PUSH
86333: LD_INT 1
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 1
86342: NEG
86343: PUSH
86344: LD_INT 0
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: PUSH
86351: LD_INT 1
86353: NEG
86354: PUSH
86355: LD_INT 1
86357: NEG
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 1
86365: NEG
86366: PUSH
86367: LD_INT 2
86369: NEG
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 0
86377: PUSH
86378: LD_INT 2
86380: NEG
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 1
86388: PUSH
86389: LD_INT 1
86391: NEG
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 2
86399: NEG
86400: PUSH
86401: LD_INT 1
86403: NEG
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: LD_INT 2
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86435: LD_ADDR_VAR 0 48
86439: PUSH
86440: LD_INT 0
86442: PUSH
86443: LD_INT 0
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: LD_INT 1
86455: NEG
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 1
86463: PUSH
86464: LD_INT 0
86466: PUSH
86467: EMPTY
86468: LIST
86469: LIST
86470: PUSH
86471: LD_INT 1
86473: PUSH
86474: LD_INT 1
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PUSH
86481: LD_INT 0
86483: PUSH
86484: LD_INT 1
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: LD_INT 0
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 1
86504: NEG
86505: PUSH
86506: LD_INT 1
86508: NEG
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 1
86516: NEG
86517: PUSH
86518: LD_INT 2
86520: NEG
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: LD_INT 0
86528: PUSH
86529: LD_INT 2
86531: NEG
86532: PUSH
86533: EMPTY
86534: LIST
86535: LIST
86536: PUSH
86537: LD_INT 1
86539: PUSH
86540: LD_INT 1
86542: NEG
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 2
86550: PUSH
86551: LD_INT 0
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 2
86560: PUSH
86561: LD_INT 1
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86582: LD_ADDR_VAR 0 49
86586: PUSH
86587: LD_INT 0
86589: PUSH
86590: LD_INT 0
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 0
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 1
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 1
86620: PUSH
86621: LD_INT 1
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 0
86630: PUSH
86631: LD_INT 1
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: PUSH
86638: LD_INT 1
86640: NEG
86641: PUSH
86642: LD_INT 0
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 1
86651: NEG
86652: PUSH
86653: LD_INT 1
86655: NEG
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: PUSH
86661: LD_INT 1
86663: PUSH
86664: LD_INT 1
86666: NEG
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 2
86674: PUSH
86675: LD_INT 0
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 2
86684: PUSH
86685: LD_INT 1
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 2
86694: PUSH
86695: LD_INT 2
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 1
86704: PUSH
86705: LD_INT 2
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86726: LD_ADDR_VAR 0 50
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 0
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: PUSH
86741: LD_INT 0
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 1
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 1
86764: PUSH
86765: LD_INT 1
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: LD_INT 0
86774: PUSH
86775: LD_INT 1
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 1
86795: NEG
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 2
86807: PUSH
86808: LD_INT 1
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 2
86817: PUSH
86818: LD_INT 2
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 1
86827: PUSH
86828: LD_INT 2
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: LD_INT 2
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 1
86847: NEG
86848: PUSH
86849: LD_INT 1
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
86870: LD_ADDR_VAR 0 51
86874: PUSH
86875: LD_INT 0
86877: PUSH
86878: LD_INT 0
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 0
86887: PUSH
86888: LD_INT 1
86890: NEG
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 1
86898: PUSH
86899: LD_INT 0
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 1
86908: PUSH
86909: LD_INT 1
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 0
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 1
86928: NEG
86929: PUSH
86930: LD_INT 0
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 1
86939: NEG
86940: PUSH
86941: LD_INT 1
86943: NEG
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 1
86951: PUSH
86952: LD_INT 2
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 0
86961: PUSH
86962: LD_INT 2
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 1
86971: NEG
86972: PUSH
86973: LD_INT 1
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 2
86982: NEG
86983: PUSH
86984: LD_INT 0
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 2
86993: NEG
86994: PUSH
86995: LD_INT 1
86997: NEG
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: LIST
87010: LIST
87011: LIST
87012: LIST
87013: LIST
87014: LIST
87015: LIST
87016: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87017: LD_ADDR_VAR 0 52
87021: PUSH
87022: LD_INT 0
87024: PUSH
87025: LD_INT 0
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: LD_INT 1
87037: NEG
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: LD_INT 1
87045: PUSH
87046: LD_INT 0
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 1
87055: PUSH
87056: LD_INT 1
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 0
87065: PUSH
87066: LD_INT 1
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PUSH
87073: LD_INT 1
87075: NEG
87076: PUSH
87077: LD_INT 0
87079: PUSH
87080: EMPTY
87081: LIST
87082: LIST
87083: PUSH
87084: LD_INT 1
87086: NEG
87087: PUSH
87088: LD_INT 1
87090: NEG
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 1
87098: NEG
87099: PUSH
87100: LD_INT 2
87102: NEG
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 1
87110: NEG
87111: PUSH
87112: LD_INT 1
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 2
87121: NEG
87122: PUSH
87123: LD_INT 0
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 2
87132: NEG
87133: PUSH
87134: LD_INT 1
87136: NEG
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 2
87144: NEG
87145: PUSH
87146: LD_INT 2
87148: NEG
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87168: LD_ADDR_VAR 0 53
87172: PUSH
87173: LD_INT 0
87175: PUSH
87176: LD_INT 0
87178: PUSH
87179: EMPTY
87180: LIST
87181: LIST
87182: PUSH
87183: LD_INT 0
87185: PUSH
87186: LD_INT 1
87188: NEG
87189: PUSH
87190: EMPTY
87191: LIST
87192: LIST
87193: PUSH
87194: LD_INT 1
87196: PUSH
87197: LD_INT 0
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 1
87206: PUSH
87207: LD_INT 1
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 0
87216: PUSH
87217: LD_INT 1
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 1
87226: NEG
87227: PUSH
87228: LD_INT 0
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 1
87237: NEG
87238: PUSH
87239: LD_INT 1
87241: NEG
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: LD_INT 2
87253: NEG
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: PUSH
87259: LD_INT 0
87261: PUSH
87262: LD_INT 2
87264: NEG
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PUSH
87270: LD_INT 1
87272: PUSH
87273: LD_INT 1
87275: NEG
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 2
87283: PUSH
87284: LD_INT 0
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 2
87293: PUSH
87294: LD_INT 1
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: PUSH
87301: LD_INT 2
87303: PUSH
87304: LD_INT 2
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 1
87313: PUSH
87314: LD_INT 2
87316: PUSH
87317: EMPTY
87318: LIST
87319: LIST
87320: PUSH
87321: LD_INT 0
87323: PUSH
87324: LD_INT 2
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 1
87333: NEG
87334: PUSH
87335: LD_INT 1
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 2
87344: NEG
87345: PUSH
87346: LD_INT 0
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: LD_INT 2
87355: NEG
87356: PUSH
87357: LD_INT 1
87359: NEG
87360: PUSH
87361: EMPTY
87362: LIST
87363: LIST
87364: PUSH
87365: LD_INT 2
87367: NEG
87368: PUSH
87369: LD_INT 2
87371: NEG
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87398: LD_ADDR_VAR 0 54
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 0
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: PUSH
87420: EMPTY
87421: LIST
87422: LIST
87423: PUSH
87424: LD_INT 1
87426: PUSH
87427: LD_INT 0
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: LD_INT 1
87436: PUSH
87437: LD_INT 1
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 0
87446: PUSH
87447: LD_INT 1
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PUSH
87454: LD_INT 1
87456: NEG
87457: PUSH
87458: LD_INT 0
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 1
87467: NEG
87468: PUSH
87469: LD_INT 1
87471: NEG
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: PUSH
87477: LD_INT 1
87479: NEG
87480: PUSH
87481: LD_INT 2
87483: NEG
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 0
87491: PUSH
87492: LD_INT 2
87494: NEG
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: PUSH
87500: LD_INT 1
87502: PUSH
87503: LD_INT 1
87505: NEG
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: PUSH
87511: LD_INT 2
87513: PUSH
87514: LD_INT 0
87516: PUSH
87517: EMPTY
87518: LIST
87519: LIST
87520: PUSH
87521: LD_INT 2
87523: PUSH
87524: LD_INT 1
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 2
87533: PUSH
87534: LD_INT 2
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: PUSH
87541: LD_INT 1
87543: PUSH
87544: LD_INT 2
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 0
87553: PUSH
87554: LD_INT 2
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 1
87563: NEG
87564: PUSH
87565: LD_INT 1
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 2
87574: NEG
87575: PUSH
87576: LD_INT 0
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: LD_INT 2
87585: NEG
87586: PUSH
87587: LD_INT 1
87589: NEG
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: PUSH
87595: LD_INT 2
87597: NEG
87598: PUSH
87599: LD_INT 2
87601: NEG
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87628: LD_ADDR_VAR 0 55
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: LD_INT 0
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 0
87645: PUSH
87646: LD_INT 1
87648: NEG
87649: PUSH
87650: EMPTY
87651: LIST
87652: LIST
87653: PUSH
87654: LD_INT 1
87656: PUSH
87657: LD_INT 0
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: LD_INT 1
87666: PUSH
87667: LD_INT 1
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: PUSH
87674: LD_INT 0
87676: PUSH
87677: LD_INT 1
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: PUSH
87684: LD_INT 1
87686: NEG
87687: PUSH
87688: LD_INT 0
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 1
87697: NEG
87698: PUSH
87699: LD_INT 1
87701: NEG
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 1
87709: NEG
87710: PUSH
87711: LD_INT 2
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: LD_INT 2
87724: NEG
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 1
87732: PUSH
87733: LD_INT 1
87735: NEG
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 2
87743: PUSH
87744: LD_INT 0
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 2
87753: PUSH
87754: LD_INT 1
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 2
87763: PUSH
87764: LD_INT 2
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 1
87773: PUSH
87774: LD_INT 2
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: LD_INT 2
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: PUSH
87795: LD_INT 1
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: NEG
87805: PUSH
87806: LD_INT 0
87808: PUSH
87809: EMPTY
87810: LIST
87811: LIST
87812: PUSH
87813: LD_INT 2
87815: NEG
87816: PUSH
87817: LD_INT 1
87819: NEG
87820: PUSH
87821: EMPTY
87822: LIST
87823: LIST
87824: PUSH
87825: LD_INT 2
87827: NEG
87828: PUSH
87829: LD_INT 2
87831: NEG
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87858: LD_ADDR_VAR 0 56
87862: PUSH
87863: LD_INT 0
87865: PUSH
87866: LD_INT 0
87868: PUSH
87869: EMPTY
87870: LIST
87871: LIST
87872: PUSH
87873: LD_INT 0
87875: PUSH
87876: LD_INT 1
87878: NEG
87879: PUSH
87880: EMPTY
87881: LIST
87882: LIST
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: LD_INT 0
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 1
87896: PUSH
87897: LD_INT 1
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PUSH
87904: LD_INT 0
87906: PUSH
87907: LD_INT 1
87909: PUSH
87910: EMPTY
87911: LIST
87912: LIST
87913: PUSH
87914: LD_INT 1
87916: NEG
87917: PUSH
87918: LD_INT 0
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: LD_INT 1
87927: NEG
87928: PUSH
87929: LD_INT 1
87931: NEG
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 1
87939: NEG
87940: PUSH
87941: LD_INT 2
87943: NEG
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 0
87951: PUSH
87952: LD_INT 2
87954: NEG
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: PUSH
87960: LD_INT 1
87962: PUSH
87963: LD_INT 1
87965: NEG
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: PUSH
87971: LD_INT 2
87973: PUSH
87974: LD_INT 0
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 2
87983: PUSH
87984: LD_INT 1
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: PUSH
87991: LD_INT 2
87993: PUSH
87994: LD_INT 2
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: LD_INT 1
88003: PUSH
88004: LD_INT 2
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: LD_INT 2
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 1
88023: NEG
88024: PUSH
88025: LD_INT 1
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 2
88034: NEG
88035: PUSH
88036: LD_INT 0
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: PUSH
88043: LD_INT 2
88045: NEG
88046: PUSH
88047: LD_INT 1
88049: NEG
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 2
88057: NEG
88058: PUSH
88059: LD_INT 2
88061: NEG
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PUSH
88067: EMPTY
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88088: LD_ADDR_VAR 0 57
88092: PUSH
88093: LD_INT 0
88095: PUSH
88096: LD_INT 0
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: LD_INT 0
88105: PUSH
88106: LD_INT 1
88108: NEG
88109: PUSH
88110: EMPTY
88111: LIST
88112: LIST
88113: PUSH
88114: LD_INT 1
88116: PUSH
88117: LD_INT 0
88119: PUSH
88120: EMPTY
88121: LIST
88122: LIST
88123: PUSH
88124: LD_INT 1
88126: PUSH
88127: LD_INT 1
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 0
88136: PUSH
88137: LD_INT 1
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: PUSH
88144: LD_INT 1
88146: NEG
88147: PUSH
88148: LD_INT 0
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PUSH
88155: LD_INT 1
88157: NEG
88158: PUSH
88159: LD_INT 1
88161: NEG
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 1
88169: NEG
88170: PUSH
88171: LD_INT 2
88173: NEG
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 0
88181: PUSH
88182: LD_INT 2
88184: NEG
88185: PUSH
88186: EMPTY
88187: LIST
88188: LIST
88189: PUSH
88190: LD_INT 1
88192: PUSH
88193: LD_INT 1
88195: NEG
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 2
88203: PUSH
88204: LD_INT 0
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 2
88213: PUSH
88214: LD_INT 1
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 2
88223: PUSH
88224: LD_INT 2
88226: PUSH
88227: EMPTY
88228: LIST
88229: LIST
88230: PUSH
88231: LD_INT 1
88233: PUSH
88234: LD_INT 2
88236: PUSH
88237: EMPTY
88238: LIST
88239: LIST
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: LD_INT 2
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 1
88253: NEG
88254: PUSH
88255: LD_INT 1
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 2
88264: NEG
88265: PUSH
88266: LD_INT 0
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: PUSH
88273: LD_INT 2
88275: NEG
88276: PUSH
88277: LD_INT 1
88279: NEG
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: PUSH
88285: LD_INT 2
88287: NEG
88288: PUSH
88289: LD_INT 2
88291: NEG
88292: PUSH
88293: EMPTY
88294: LIST
88295: LIST
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: LIST
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88318: LD_ADDR_VAR 0 58
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: LD_INT 0
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 0
88335: PUSH
88336: LD_INT 1
88338: NEG
88339: PUSH
88340: EMPTY
88341: LIST
88342: LIST
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: LD_INT 0
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 1
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 0
88366: PUSH
88367: LD_INT 1
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 1
88376: NEG
88377: PUSH
88378: LD_INT 0
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 1
88387: NEG
88388: PUSH
88389: LD_INT 1
88391: NEG
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 1
88399: NEG
88400: PUSH
88401: LD_INT 2
88403: NEG
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 0
88411: PUSH
88412: LD_INT 2
88414: NEG
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 1
88422: PUSH
88423: LD_INT 1
88425: NEG
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 2
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 2
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 2
88453: PUSH
88454: LD_INT 2
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 1
88463: PUSH
88464: LD_INT 2
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: LD_INT 2
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 1
88483: NEG
88484: PUSH
88485: LD_INT 1
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 2
88494: NEG
88495: PUSH
88496: LD_INT 0
88498: PUSH
88499: EMPTY
88500: LIST
88501: LIST
88502: PUSH
88503: LD_INT 2
88505: NEG
88506: PUSH
88507: LD_INT 1
88509: NEG
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 2
88517: NEG
88518: PUSH
88519: LD_INT 2
88521: NEG
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: LIST
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88548: LD_ADDR_VAR 0 59
88552: PUSH
88553: LD_INT 0
88555: PUSH
88556: LD_INT 0
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 0
88565: PUSH
88566: LD_INT 1
88568: NEG
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 1
88576: PUSH
88577: LD_INT 0
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 1
88586: PUSH
88587: LD_INT 1
88589: PUSH
88590: EMPTY
88591: LIST
88592: LIST
88593: PUSH
88594: LD_INT 0
88596: PUSH
88597: LD_INT 1
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 1
88606: NEG
88607: PUSH
88608: LD_INT 0
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: PUSH
88615: LD_INT 1
88617: NEG
88618: PUSH
88619: LD_INT 1
88621: NEG
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88636: LD_ADDR_VAR 0 60
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: LD_INT 0
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 0
88653: PUSH
88654: LD_INT 1
88656: NEG
88657: PUSH
88658: EMPTY
88659: LIST
88660: LIST
88661: PUSH
88662: LD_INT 1
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 1
88674: PUSH
88675: LD_INT 1
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: PUSH
88682: LD_INT 0
88684: PUSH
88685: LD_INT 1
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 1
88694: NEG
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 1
88705: NEG
88706: PUSH
88707: LD_INT 1
88709: NEG
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88724: LD_ADDR_VAR 0 61
88728: PUSH
88729: LD_INT 0
88731: PUSH
88732: LD_INT 0
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 0
88741: PUSH
88742: LD_INT 1
88744: NEG
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 1
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 1
88762: PUSH
88763: LD_INT 1
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: LD_INT 1
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 1
88782: NEG
88783: PUSH
88784: LD_INT 0
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: LD_INT 1
88793: NEG
88794: PUSH
88795: LD_INT 1
88797: NEG
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88812: LD_ADDR_VAR 0 62
88816: PUSH
88817: LD_INT 0
88819: PUSH
88820: LD_INT 0
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: LD_INT 1
88832: NEG
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 1
88840: PUSH
88841: LD_INT 0
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 1
88850: PUSH
88851: LD_INT 1
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 0
88860: PUSH
88861: LD_INT 1
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 1
88870: NEG
88871: PUSH
88872: LD_INT 0
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 1
88881: NEG
88882: PUSH
88883: LD_INT 1
88885: NEG
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88900: LD_ADDR_VAR 0 63
88904: PUSH
88905: LD_INT 0
88907: PUSH
88908: LD_INT 0
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: LD_INT 1
88920: NEG
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 1
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 1
88938: PUSH
88939: LD_INT 1
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 0
88948: PUSH
88949: LD_INT 1
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 1
88958: NEG
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 1
88969: NEG
88970: PUSH
88971: LD_INT 1
88973: NEG
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88988: LD_ADDR_VAR 0 64
88992: PUSH
88993: LD_INT 0
88995: PUSH
88996: LD_INT 0
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 0
89005: PUSH
89006: LD_INT 1
89008: NEG
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 1
89026: PUSH
89027: LD_INT 1
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 0
89036: PUSH
89037: LD_INT 1
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: LD_INT 0
89050: PUSH
89051: EMPTY
89052: LIST
89053: LIST
89054: PUSH
89055: LD_INT 1
89057: NEG
89058: PUSH
89059: LD_INT 1
89061: NEG
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: ST_TO_ADDR
// end ; 1 :
89076: GO 94973
89078: LD_INT 1
89080: DOUBLE
89081: EQUAL
89082: IFTRUE 89086
89084: GO 91709
89086: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89087: LD_ADDR_VAR 0 11
89091: PUSH
89092: LD_INT 1
89094: NEG
89095: PUSH
89096: LD_INT 3
89098: NEG
89099: PUSH
89100: EMPTY
89101: LIST
89102: LIST
89103: PUSH
89104: LD_INT 0
89106: PUSH
89107: LD_INT 3
89109: NEG
89110: PUSH
89111: EMPTY
89112: LIST
89113: LIST
89114: PUSH
89115: LD_INT 1
89117: PUSH
89118: LD_INT 2
89120: NEG
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: EMPTY
89127: LIST
89128: LIST
89129: LIST
89130: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89131: LD_ADDR_VAR 0 12
89135: PUSH
89136: LD_INT 2
89138: PUSH
89139: LD_INT 1
89141: NEG
89142: PUSH
89143: EMPTY
89144: LIST
89145: LIST
89146: PUSH
89147: LD_INT 3
89149: PUSH
89150: LD_INT 0
89152: PUSH
89153: EMPTY
89154: LIST
89155: LIST
89156: PUSH
89157: LD_INT 3
89159: PUSH
89160: LD_INT 1
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: LIST
89171: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89172: LD_ADDR_VAR 0 13
89176: PUSH
89177: LD_INT 3
89179: PUSH
89180: LD_INT 2
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 3
89189: PUSH
89190: LD_INT 3
89192: PUSH
89193: EMPTY
89194: LIST
89195: LIST
89196: PUSH
89197: LD_INT 2
89199: PUSH
89200: LD_INT 3
89202: PUSH
89203: EMPTY
89204: LIST
89205: LIST
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: LIST
89211: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89212: LD_ADDR_VAR 0 14
89216: PUSH
89217: LD_INT 1
89219: PUSH
89220: LD_INT 3
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: PUSH
89227: LD_INT 0
89229: PUSH
89230: LD_INT 3
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 1
89239: NEG
89240: PUSH
89241: LD_INT 2
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: LIST
89252: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89253: LD_ADDR_VAR 0 15
89257: PUSH
89258: LD_INT 2
89260: NEG
89261: PUSH
89262: LD_INT 1
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 3
89271: NEG
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 3
89282: NEG
89283: PUSH
89284: LD_INT 1
89286: NEG
89287: PUSH
89288: EMPTY
89289: LIST
89290: LIST
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: LIST
89296: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89297: LD_ADDR_VAR 0 16
89301: PUSH
89302: LD_INT 2
89304: NEG
89305: PUSH
89306: LD_INT 3
89308: NEG
89309: PUSH
89310: EMPTY
89311: LIST
89312: LIST
89313: PUSH
89314: LD_INT 3
89316: NEG
89317: PUSH
89318: LD_INT 2
89320: NEG
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 3
89328: NEG
89329: PUSH
89330: LD_INT 3
89332: NEG
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: LIST
89342: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89343: LD_ADDR_VAR 0 17
89347: PUSH
89348: LD_INT 1
89350: NEG
89351: PUSH
89352: LD_INT 3
89354: NEG
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 0
89362: PUSH
89363: LD_INT 3
89365: NEG
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 1
89373: PUSH
89374: LD_INT 2
89376: NEG
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: LIST
89386: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89387: LD_ADDR_VAR 0 18
89391: PUSH
89392: LD_INT 2
89394: PUSH
89395: LD_INT 1
89397: NEG
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 3
89405: PUSH
89406: LD_INT 0
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 3
89415: PUSH
89416: LD_INT 1
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: LIST
89427: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89428: LD_ADDR_VAR 0 19
89432: PUSH
89433: LD_INT 3
89435: PUSH
89436: LD_INT 2
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 3
89445: PUSH
89446: LD_INT 3
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: PUSH
89453: LD_INT 2
89455: PUSH
89456: LD_INT 3
89458: PUSH
89459: EMPTY
89460: LIST
89461: LIST
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: LIST
89467: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89468: LD_ADDR_VAR 0 20
89472: PUSH
89473: LD_INT 1
89475: PUSH
89476: LD_INT 3
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: LD_INT 0
89485: PUSH
89486: LD_INT 3
89488: PUSH
89489: EMPTY
89490: LIST
89491: LIST
89492: PUSH
89493: LD_INT 1
89495: NEG
89496: PUSH
89497: LD_INT 2
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: LIST
89508: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89509: LD_ADDR_VAR 0 21
89513: PUSH
89514: LD_INT 2
89516: NEG
89517: PUSH
89518: LD_INT 1
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 3
89527: NEG
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 3
89538: NEG
89539: PUSH
89540: LD_INT 1
89542: NEG
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: LIST
89552: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89553: LD_ADDR_VAR 0 22
89557: PUSH
89558: LD_INT 2
89560: NEG
89561: PUSH
89562: LD_INT 3
89564: NEG
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 3
89572: NEG
89573: PUSH
89574: LD_INT 2
89576: NEG
89577: PUSH
89578: EMPTY
89579: LIST
89580: LIST
89581: PUSH
89582: LD_INT 3
89584: NEG
89585: PUSH
89586: LD_INT 3
89588: NEG
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: LIST
89598: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89599: LD_ADDR_VAR 0 23
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: LD_INT 3
89609: NEG
89610: PUSH
89611: EMPTY
89612: LIST
89613: LIST
89614: PUSH
89615: LD_INT 1
89617: NEG
89618: PUSH
89619: LD_INT 4
89621: NEG
89622: PUSH
89623: EMPTY
89624: LIST
89625: LIST
89626: PUSH
89627: LD_INT 1
89629: PUSH
89630: LD_INT 3
89632: NEG
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: LIST
89642: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89643: LD_ADDR_VAR 0 24
89647: PUSH
89648: LD_INT 3
89650: PUSH
89651: LD_INT 0
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 3
89660: PUSH
89661: LD_INT 1
89663: NEG
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 4
89671: PUSH
89672: LD_INT 1
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: LIST
89683: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89684: LD_ADDR_VAR 0 25
89688: PUSH
89689: LD_INT 3
89691: PUSH
89692: LD_INT 3
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 4
89701: PUSH
89702: LD_INT 3
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 3
89711: PUSH
89712: LD_INT 4
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: LIST
89723: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89724: LD_ADDR_VAR 0 26
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: LD_INT 3
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 1
89741: PUSH
89742: LD_INT 4
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 1
89751: NEG
89752: PUSH
89753: LD_INT 3
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: EMPTY
89761: LIST
89762: LIST
89763: LIST
89764: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89765: LD_ADDR_VAR 0 27
89769: PUSH
89770: LD_INT 3
89772: NEG
89773: PUSH
89774: LD_INT 0
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 3
89783: NEG
89784: PUSH
89785: LD_INT 1
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: LD_INT 4
89794: NEG
89795: PUSH
89796: LD_INT 1
89798: NEG
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: LIST
89808: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89809: LD_ADDR_VAR 0 28
89813: PUSH
89814: LD_INT 3
89816: NEG
89817: PUSH
89818: LD_INT 3
89820: NEG
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 3
89828: NEG
89829: PUSH
89830: LD_INT 4
89832: NEG
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PUSH
89838: LD_INT 4
89840: NEG
89841: PUSH
89842: LD_INT 3
89844: NEG
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: LIST
89854: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
89855: LD_ADDR_VAR 0 29
89859: PUSH
89860: LD_INT 1
89862: NEG
89863: PUSH
89864: LD_INT 3
89866: NEG
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 0
89874: PUSH
89875: LD_INT 3
89877: NEG
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 1
89885: PUSH
89886: LD_INT 2
89888: NEG
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 1
89896: NEG
89897: PUSH
89898: LD_INT 4
89900: NEG
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 0
89908: PUSH
89909: LD_INT 4
89911: NEG
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 1
89919: PUSH
89920: LD_INT 3
89922: NEG
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 1
89930: NEG
89931: PUSH
89932: LD_INT 5
89934: NEG
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 0
89942: PUSH
89943: LD_INT 5
89945: NEG
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 1
89953: PUSH
89954: LD_INT 4
89956: NEG
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 1
89964: NEG
89965: PUSH
89966: LD_INT 6
89968: NEG
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 6
89979: NEG
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 1
89987: PUSH
89988: LD_INT 5
89990: NEG
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: LIST
90000: LIST
90001: LIST
90002: LIST
90003: LIST
90004: LIST
90005: LIST
90006: LIST
90007: LIST
90008: LIST
90009: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90010: LD_ADDR_VAR 0 30
90014: PUSH
90015: LD_INT 2
90017: PUSH
90018: LD_INT 1
90020: NEG
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 3
90028: PUSH
90029: LD_INT 0
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: PUSH
90036: LD_INT 3
90038: PUSH
90039: LD_INT 1
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 3
90048: PUSH
90049: LD_INT 1
90051: NEG
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 4
90059: PUSH
90060: LD_INT 0
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: PUSH
90067: LD_INT 4
90069: PUSH
90070: LD_INT 1
90072: PUSH
90073: EMPTY
90074: LIST
90075: LIST
90076: PUSH
90077: LD_INT 4
90079: PUSH
90080: LD_INT 1
90082: NEG
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: LD_INT 5
90090: PUSH
90091: LD_INT 0
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 5
90100: PUSH
90101: LD_INT 1
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 5
90110: PUSH
90111: LD_INT 1
90113: NEG
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 6
90121: PUSH
90122: LD_INT 0
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: PUSH
90129: LD_INT 6
90131: PUSH
90132: LD_INT 1
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90153: LD_ADDR_VAR 0 31
90157: PUSH
90158: LD_INT 3
90160: PUSH
90161: LD_INT 2
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 3
90170: PUSH
90171: LD_INT 3
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 2
90180: PUSH
90181: LD_INT 3
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 4
90190: PUSH
90191: LD_INT 3
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PUSH
90198: LD_INT 4
90200: PUSH
90201: LD_INT 4
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 3
90210: PUSH
90211: LD_INT 4
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 5
90220: PUSH
90221: LD_INT 4
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 5
90230: PUSH
90231: LD_INT 5
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 4
90240: PUSH
90241: LD_INT 5
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 6
90250: PUSH
90251: LD_INT 5
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 6
90260: PUSH
90261: LD_INT 6
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 5
90270: PUSH
90271: LD_INT 6
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90292: LD_ADDR_VAR 0 32
90296: PUSH
90297: LD_INT 1
90299: PUSH
90300: LD_INT 3
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 0
90309: PUSH
90310: LD_INT 3
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: PUSH
90317: LD_INT 1
90319: NEG
90320: PUSH
90321: LD_INT 2
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: LD_INT 1
90330: PUSH
90331: LD_INT 4
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: PUSH
90338: LD_INT 0
90340: PUSH
90341: LD_INT 4
90343: PUSH
90344: EMPTY
90345: LIST
90346: LIST
90347: PUSH
90348: LD_INT 1
90350: NEG
90351: PUSH
90352: LD_INT 3
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: LD_INT 1
90361: PUSH
90362: LD_INT 5
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 0
90371: PUSH
90372: LD_INT 5
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: LD_INT 1
90381: NEG
90382: PUSH
90383: LD_INT 4
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: PUSH
90390: LD_INT 1
90392: PUSH
90393: LD_INT 6
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 0
90402: PUSH
90403: LD_INT 6
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 1
90412: NEG
90413: PUSH
90414: LD_INT 5
90416: PUSH
90417: EMPTY
90418: LIST
90419: LIST
90420: PUSH
90421: EMPTY
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90435: LD_ADDR_VAR 0 33
90439: PUSH
90440: LD_INT 2
90442: NEG
90443: PUSH
90444: LD_INT 1
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 3
90453: NEG
90454: PUSH
90455: LD_INT 0
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 3
90464: NEG
90465: PUSH
90466: LD_INT 1
90468: NEG
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 3
90476: NEG
90477: PUSH
90478: LD_INT 1
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PUSH
90485: LD_INT 4
90487: NEG
90488: PUSH
90489: LD_INT 0
90491: PUSH
90492: EMPTY
90493: LIST
90494: LIST
90495: PUSH
90496: LD_INT 4
90498: NEG
90499: PUSH
90500: LD_INT 1
90502: NEG
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: PUSH
90508: LD_INT 4
90510: NEG
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 5
90521: NEG
90522: PUSH
90523: LD_INT 0
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: PUSH
90530: LD_INT 5
90532: NEG
90533: PUSH
90534: LD_INT 1
90536: NEG
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 5
90544: NEG
90545: PUSH
90546: LD_INT 1
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 6
90555: NEG
90556: PUSH
90557: LD_INT 0
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: PUSH
90564: LD_INT 6
90566: NEG
90567: PUSH
90568: LD_INT 1
90570: NEG
90571: PUSH
90572: EMPTY
90573: LIST
90574: LIST
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90590: LD_ADDR_VAR 0 34
90594: PUSH
90595: LD_INT 2
90597: NEG
90598: PUSH
90599: LD_INT 3
90601: NEG
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 3
90609: NEG
90610: PUSH
90611: LD_INT 2
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 3
90621: NEG
90622: PUSH
90623: LD_INT 3
90625: NEG
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 3
90633: NEG
90634: PUSH
90635: LD_INT 4
90637: NEG
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: PUSH
90643: LD_INT 4
90645: NEG
90646: PUSH
90647: LD_INT 3
90649: NEG
90650: PUSH
90651: EMPTY
90652: LIST
90653: LIST
90654: PUSH
90655: LD_INT 4
90657: NEG
90658: PUSH
90659: LD_INT 4
90661: NEG
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 4
90669: NEG
90670: PUSH
90671: LD_INT 5
90673: NEG
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 5
90681: NEG
90682: PUSH
90683: LD_INT 4
90685: NEG
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 5
90693: NEG
90694: PUSH
90695: LD_INT 5
90697: NEG
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 5
90705: NEG
90706: PUSH
90707: LD_INT 6
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 6
90717: NEG
90718: PUSH
90719: LD_INT 5
90721: NEG
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 6
90729: NEG
90730: PUSH
90731: LD_INT 6
90733: NEG
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90753: LD_ADDR_VAR 0 41
90757: PUSH
90758: LD_INT 0
90760: PUSH
90761: LD_INT 2
90763: NEG
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: NEG
90772: PUSH
90773: LD_INT 3
90775: NEG
90776: PUSH
90777: EMPTY
90778: LIST
90779: LIST
90780: PUSH
90781: LD_INT 1
90783: PUSH
90784: LD_INT 2
90786: NEG
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: LIST
90796: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90797: LD_ADDR_VAR 0 42
90801: PUSH
90802: LD_INT 2
90804: PUSH
90805: LD_INT 0
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 2
90814: PUSH
90815: LD_INT 1
90817: NEG
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 3
90825: PUSH
90826: LD_INT 1
90828: PUSH
90829: EMPTY
90830: LIST
90831: LIST
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: LIST
90837: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90838: LD_ADDR_VAR 0 43
90842: PUSH
90843: LD_INT 2
90845: PUSH
90846: LD_INT 2
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 3
90855: PUSH
90856: LD_INT 2
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 2
90865: PUSH
90866: LD_INT 3
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: LIST
90877: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
90878: LD_ADDR_VAR 0 44
90882: PUSH
90883: LD_INT 0
90885: PUSH
90886: LD_INT 2
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: LD_INT 1
90895: PUSH
90896: LD_INT 3
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 1
90905: NEG
90906: PUSH
90907: LD_INT 2
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: LIST
90918: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90919: LD_ADDR_VAR 0 45
90923: PUSH
90924: LD_INT 2
90926: NEG
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 2
90937: NEG
90938: PUSH
90939: LD_INT 1
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 3
90948: NEG
90949: PUSH
90950: LD_INT 1
90952: NEG
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: LIST
90962: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90963: LD_ADDR_VAR 0 46
90967: PUSH
90968: LD_INT 2
90970: NEG
90971: PUSH
90972: LD_INT 2
90974: NEG
90975: PUSH
90976: EMPTY
90977: LIST
90978: LIST
90979: PUSH
90980: LD_INT 2
90982: NEG
90983: PUSH
90984: LD_INT 3
90986: NEG
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 3
90994: NEG
90995: PUSH
90996: LD_INT 2
90998: NEG
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: LIST
91008: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91009: LD_ADDR_VAR 0 47
91013: PUSH
91014: LD_INT 2
91016: NEG
91017: PUSH
91018: LD_INT 3
91020: NEG
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 1
91028: NEG
91029: PUSH
91030: LD_INT 3
91032: NEG
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91042: LD_ADDR_VAR 0 48
91046: PUSH
91047: LD_INT 1
91049: PUSH
91050: LD_INT 2
91052: NEG
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 2
91060: PUSH
91061: LD_INT 1
91063: NEG
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91073: LD_ADDR_VAR 0 49
91077: PUSH
91078: LD_INT 3
91080: PUSH
91081: LD_INT 1
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 3
91090: PUSH
91091: LD_INT 2
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91102: LD_ADDR_VAR 0 50
91106: PUSH
91107: LD_INT 2
91109: PUSH
91110: LD_INT 3
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: PUSH
91117: LD_INT 1
91119: PUSH
91120: LD_INT 3
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91131: LD_ADDR_VAR 0 51
91135: PUSH
91136: LD_INT 1
91138: NEG
91139: PUSH
91140: LD_INT 2
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: LD_INT 2
91149: NEG
91150: PUSH
91151: LD_INT 1
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: PUSH
91158: EMPTY
91159: LIST
91160: LIST
91161: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91162: LD_ADDR_VAR 0 52
91166: PUSH
91167: LD_INT 3
91169: NEG
91170: PUSH
91171: LD_INT 1
91173: NEG
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: PUSH
91179: LD_INT 3
91181: NEG
91182: PUSH
91183: LD_INT 2
91185: NEG
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91195: LD_ADDR_VAR 0 53
91199: PUSH
91200: LD_INT 1
91202: NEG
91203: PUSH
91204: LD_INT 3
91206: NEG
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: LD_INT 3
91217: NEG
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: LD_INT 2
91228: NEG
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: LIST
91238: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91239: LD_ADDR_VAR 0 54
91243: PUSH
91244: LD_INT 2
91246: PUSH
91247: LD_INT 1
91249: NEG
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 3
91257: PUSH
91258: LD_INT 0
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 3
91267: PUSH
91268: LD_INT 1
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: LIST
91279: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91280: LD_ADDR_VAR 0 55
91284: PUSH
91285: LD_INT 3
91287: PUSH
91288: LD_INT 2
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 3
91297: PUSH
91298: LD_INT 3
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 2
91307: PUSH
91308: LD_INT 3
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: LIST
91319: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91320: LD_ADDR_VAR 0 56
91324: PUSH
91325: LD_INT 1
91327: PUSH
91328: LD_INT 3
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 0
91337: PUSH
91338: LD_INT 3
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 1
91347: NEG
91348: PUSH
91349: LD_INT 2
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: LIST
91360: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91361: LD_ADDR_VAR 0 57
91365: PUSH
91366: LD_INT 2
91368: NEG
91369: PUSH
91370: LD_INT 1
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 3
91379: NEG
91380: PUSH
91381: LD_INT 0
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 3
91390: NEG
91391: PUSH
91392: LD_INT 1
91394: NEG
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: LIST
91404: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91405: LD_ADDR_VAR 0 58
91409: PUSH
91410: LD_INT 2
91412: NEG
91413: PUSH
91414: LD_INT 3
91416: NEG
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: PUSH
91422: LD_INT 3
91424: NEG
91425: PUSH
91426: LD_INT 2
91428: NEG
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 3
91436: NEG
91437: PUSH
91438: LD_INT 3
91440: NEG
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: LIST
91450: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91451: LD_ADDR_VAR 0 59
91455: PUSH
91456: LD_INT 1
91458: NEG
91459: PUSH
91460: LD_INT 2
91462: NEG
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 0
91470: PUSH
91471: LD_INT 2
91473: NEG
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: PUSH
91479: LD_INT 1
91481: PUSH
91482: LD_INT 1
91484: NEG
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: LIST
91494: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91495: LD_ADDR_VAR 0 60
91499: PUSH
91500: LD_INT 1
91502: PUSH
91503: LD_INT 1
91505: NEG
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: LD_INT 2
91513: PUSH
91514: LD_INT 0
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: PUSH
91521: LD_INT 2
91523: PUSH
91524: LD_INT 1
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: LIST
91535: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91536: LD_ADDR_VAR 0 61
91540: PUSH
91541: LD_INT 2
91543: PUSH
91544: LD_INT 1
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 2
91553: PUSH
91554: LD_INT 2
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 1
91563: PUSH
91564: LD_INT 2
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: EMPTY
91572: LIST
91573: LIST
91574: LIST
91575: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91576: LD_ADDR_VAR 0 62
91580: PUSH
91581: LD_INT 1
91583: PUSH
91584: LD_INT 2
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 0
91593: PUSH
91594: LD_INT 2
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 1
91603: NEG
91604: PUSH
91605: LD_INT 1
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: LIST
91616: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91617: LD_ADDR_VAR 0 63
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 1
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 2
91635: NEG
91636: PUSH
91637: LD_INT 0
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 2
91646: NEG
91647: PUSH
91648: LD_INT 1
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: LIST
91660: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91661: LD_ADDR_VAR 0 64
91665: PUSH
91666: LD_INT 1
91668: NEG
91669: PUSH
91670: LD_INT 2
91672: NEG
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: PUSH
91678: LD_INT 2
91680: NEG
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: PUSH
91690: LD_INT 2
91692: NEG
91693: PUSH
91694: LD_INT 2
91696: NEG
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: LIST
91706: ST_TO_ADDR
// end ; 2 :
91707: GO 94973
91709: LD_INT 2
91711: DOUBLE
91712: EQUAL
91713: IFTRUE 91717
91715: GO 94972
91717: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91718: LD_ADDR_VAR 0 29
91722: PUSH
91723: LD_INT 4
91725: PUSH
91726: LD_INT 0
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: PUSH
91733: LD_INT 4
91735: PUSH
91736: LD_INT 1
91738: NEG
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: LD_INT 5
91746: PUSH
91747: LD_INT 0
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 5
91756: PUSH
91757: LD_INT 1
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 4
91766: PUSH
91767: LD_INT 1
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: LD_INT 3
91776: PUSH
91777: LD_INT 0
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 3
91786: PUSH
91787: LD_INT 1
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 3
91797: PUSH
91798: LD_INT 2
91800: NEG
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 5
91808: PUSH
91809: LD_INT 2
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 3
91818: PUSH
91819: LD_INT 3
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PUSH
91826: LD_INT 3
91828: PUSH
91829: LD_INT 2
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 4
91838: PUSH
91839: LD_INT 3
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 4
91848: PUSH
91849: LD_INT 4
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 3
91858: PUSH
91859: LD_INT 4
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 2
91868: PUSH
91869: LD_INT 3
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 2
91878: PUSH
91879: LD_INT 2
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 4
91888: PUSH
91889: LD_INT 2
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: LD_INT 2
91898: PUSH
91899: LD_INT 4
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: LD_INT 0
91908: PUSH
91909: LD_INT 4
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: LD_INT 0
91918: PUSH
91919: LD_INT 3
91921: PUSH
91922: EMPTY
91923: LIST
91924: LIST
91925: PUSH
91926: LD_INT 1
91928: PUSH
91929: LD_INT 4
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 1
91938: PUSH
91939: LD_INT 5
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 0
91948: PUSH
91949: LD_INT 5
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: LD_INT 4
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: PUSH
91967: LD_INT 1
91969: NEG
91970: PUSH
91971: LD_INT 3
91973: PUSH
91974: EMPTY
91975: LIST
91976: LIST
91977: PUSH
91978: LD_INT 2
91980: PUSH
91981: LD_INT 5
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 2
91990: NEG
91991: PUSH
91992: LD_INT 3
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 3
92001: NEG
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: PUSH
92010: LD_INT 3
92012: NEG
92013: PUSH
92014: LD_INT 1
92016: NEG
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: PUSH
92022: LD_INT 2
92024: NEG
92025: PUSH
92026: LD_INT 0
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 2
92035: NEG
92036: PUSH
92037: LD_INT 1
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 4
92057: NEG
92058: PUSH
92059: LD_INT 0
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: LD_INT 4
92068: NEG
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: LD_INT 4
92080: NEG
92081: PUSH
92082: LD_INT 2
92084: NEG
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: PUSH
92090: LD_INT 2
92092: NEG
92093: PUSH
92094: LD_INT 2
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 4
92103: NEG
92104: PUSH
92105: LD_INT 4
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: LD_INT 4
92115: NEG
92116: PUSH
92117: LD_INT 5
92119: NEG
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: PUSH
92125: LD_INT 3
92127: NEG
92128: PUSH
92129: LD_INT 4
92131: NEG
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: LD_INT 3
92139: NEG
92140: PUSH
92141: LD_INT 3
92143: NEG
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 4
92151: NEG
92152: PUSH
92153: LD_INT 3
92155: NEG
92156: PUSH
92157: EMPTY
92158: LIST
92159: LIST
92160: PUSH
92161: LD_INT 5
92163: NEG
92164: PUSH
92165: LD_INT 4
92167: NEG
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: PUSH
92173: LD_INT 5
92175: NEG
92176: PUSH
92177: LD_INT 5
92179: NEG
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: LD_INT 3
92187: NEG
92188: PUSH
92189: LD_INT 5
92191: NEG
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 5
92199: NEG
92200: PUSH
92201: LD_INT 3
92203: NEG
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92256: LD_ADDR_VAR 0 30
92260: PUSH
92261: LD_INT 4
92263: PUSH
92264: LD_INT 4
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 4
92273: PUSH
92274: LD_INT 3
92276: PUSH
92277: EMPTY
92278: LIST
92279: LIST
92280: PUSH
92281: LD_INT 5
92283: PUSH
92284: LD_INT 4
92286: PUSH
92287: EMPTY
92288: LIST
92289: LIST
92290: PUSH
92291: LD_INT 5
92293: PUSH
92294: LD_INT 5
92296: PUSH
92297: EMPTY
92298: LIST
92299: LIST
92300: PUSH
92301: LD_INT 4
92303: PUSH
92304: LD_INT 5
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: PUSH
92311: LD_INT 3
92313: PUSH
92314: LD_INT 4
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 3
92323: PUSH
92324: LD_INT 3
92326: PUSH
92327: EMPTY
92328: LIST
92329: LIST
92330: PUSH
92331: LD_INT 5
92333: PUSH
92334: LD_INT 3
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 3
92343: PUSH
92344: LD_INT 5
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 0
92353: PUSH
92354: LD_INT 3
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 0
92363: PUSH
92364: LD_INT 2
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: LD_INT 1
92373: PUSH
92374: LD_INT 3
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 1
92383: PUSH
92384: LD_INT 4
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 0
92393: PUSH
92394: LD_INT 4
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: PUSH
92401: LD_INT 1
92403: NEG
92404: PUSH
92405: LD_INT 3
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 1
92414: NEG
92415: PUSH
92416: LD_INT 2
92418: PUSH
92419: EMPTY
92420: LIST
92421: LIST
92422: PUSH
92423: LD_INT 2
92425: PUSH
92426: LD_INT 4
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 2
92435: NEG
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 4
92446: NEG
92447: PUSH
92448: LD_INT 0
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 4
92457: NEG
92458: PUSH
92459: LD_INT 1
92461: NEG
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 3
92469: NEG
92470: PUSH
92471: LD_INT 0
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 3
92480: NEG
92481: PUSH
92482: LD_INT 1
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 4
92491: NEG
92492: PUSH
92493: LD_INT 1
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 5
92502: NEG
92503: PUSH
92504: LD_INT 0
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 5
92513: NEG
92514: PUSH
92515: LD_INT 1
92517: NEG
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 5
92525: NEG
92526: PUSH
92527: LD_INT 2
92529: NEG
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 3
92537: NEG
92538: PUSH
92539: LD_INT 2
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 3
92548: NEG
92549: PUSH
92550: LD_INT 3
92552: NEG
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 3
92560: NEG
92561: PUSH
92562: LD_INT 4
92564: NEG
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 2
92572: NEG
92573: PUSH
92574: LD_INT 3
92576: NEG
92577: PUSH
92578: EMPTY
92579: LIST
92580: LIST
92581: PUSH
92582: LD_INT 2
92584: NEG
92585: PUSH
92586: LD_INT 2
92588: NEG
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 3
92596: NEG
92597: PUSH
92598: LD_INT 2
92600: NEG
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 4
92608: NEG
92609: PUSH
92610: LD_INT 3
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 4
92620: NEG
92621: PUSH
92622: LD_INT 4
92624: NEG
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: NEG
92633: PUSH
92634: LD_INT 4
92636: NEG
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 4
92644: NEG
92645: PUSH
92646: LD_INT 2
92648: NEG
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: LD_INT 0
92656: PUSH
92657: LD_INT 4
92659: NEG
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 0
92667: PUSH
92668: LD_INT 5
92670: NEG
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 1
92678: PUSH
92679: LD_INT 4
92681: NEG
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 1
92689: PUSH
92690: LD_INT 3
92692: NEG
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 0
92700: PUSH
92701: LD_INT 3
92703: NEG
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 1
92711: NEG
92712: PUSH
92713: LD_INT 4
92715: NEG
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 1
92723: NEG
92724: PUSH
92725: LD_INT 5
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 2
92735: PUSH
92736: LD_INT 3
92738: NEG
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 2
92746: NEG
92747: PUSH
92748: LD_INT 5
92750: NEG
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92803: LD_ADDR_VAR 0 31
92807: PUSH
92808: LD_INT 0
92810: PUSH
92811: LD_INT 4
92813: PUSH
92814: EMPTY
92815: LIST
92816: LIST
92817: PUSH
92818: LD_INT 0
92820: PUSH
92821: LD_INT 3
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: PUSH
92828: LD_INT 1
92830: PUSH
92831: LD_INT 4
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 1
92840: PUSH
92841: LD_INT 5
92843: PUSH
92844: EMPTY
92845: LIST
92846: LIST
92847: PUSH
92848: LD_INT 0
92850: PUSH
92851: LD_INT 5
92853: PUSH
92854: EMPTY
92855: LIST
92856: LIST
92857: PUSH
92858: LD_INT 1
92860: NEG
92861: PUSH
92862: LD_INT 4
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: LD_INT 1
92871: NEG
92872: PUSH
92873: LD_INT 3
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: PUSH
92880: LD_INT 2
92882: PUSH
92883: LD_INT 5
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 2
92892: NEG
92893: PUSH
92894: LD_INT 3
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: PUSH
92901: LD_INT 3
92903: NEG
92904: PUSH
92905: LD_INT 0
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: PUSH
92912: LD_INT 3
92914: NEG
92915: PUSH
92916: LD_INT 1
92918: NEG
92919: PUSH
92920: EMPTY
92921: LIST
92922: LIST
92923: PUSH
92924: LD_INT 2
92926: NEG
92927: PUSH
92928: LD_INT 0
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 2
92937: NEG
92938: PUSH
92939: LD_INT 1
92941: PUSH
92942: EMPTY
92943: LIST
92944: LIST
92945: PUSH
92946: LD_INT 3
92948: NEG
92949: PUSH
92950: LD_INT 1
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 4
92959: NEG
92960: PUSH
92961: LD_INT 0
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 4
92970: NEG
92971: PUSH
92972: LD_INT 1
92974: NEG
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 4
92982: NEG
92983: PUSH
92984: LD_INT 2
92986: NEG
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: LD_INT 2
92994: NEG
92995: PUSH
92996: LD_INT 2
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 4
93005: NEG
93006: PUSH
93007: LD_INT 4
93009: NEG
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 4
93017: NEG
93018: PUSH
93019: LD_INT 5
93021: NEG
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 3
93029: NEG
93030: PUSH
93031: LD_INT 4
93033: NEG
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: PUSH
93039: LD_INT 3
93041: NEG
93042: PUSH
93043: LD_INT 3
93045: NEG
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 4
93053: NEG
93054: PUSH
93055: LD_INT 3
93057: NEG
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 5
93065: NEG
93066: PUSH
93067: LD_INT 4
93069: NEG
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 5
93077: NEG
93078: PUSH
93079: LD_INT 5
93081: NEG
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 3
93089: NEG
93090: PUSH
93091: LD_INT 5
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 5
93101: NEG
93102: PUSH
93103: LD_INT 3
93105: NEG
93106: PUSH
93107: EMPTY
93108: LIST
93109: LIST
93110: PUSH
93111: LD_INT 0
93113: PUSH
93114: LD_INT 3
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 0
93124: PUSH
93125: LD_INT 4
93127: NEG
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: PUSH
93133: LD_INT 1
93135: PUSH
93136: LD_INT 3
93138: NEG
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: LD_INT 1
93146: PUSH
93147: LD_INT 2
93149: NEG
93150: PUSH
93151: EMPTY
93152: LIST
93153: LIST
93154: PUSH
93155: LD_INT 0
93157: PUSH
93158: LD_INT 2
93160: NEG
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 1
93168: NEG
93169: PUSH
93170: LD_INT 3
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 1
93180: NEG
93181: PUSH
93182: LD_INT 4
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 2
93192: PUSH
93193: LD_INT 2
93195: NEG
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: LD_INT 2
93203: NEG
93204: PUSH
93205: LD_INT 4
93207: NEG
93208: PUSH
93209: EMPTY
93210: LIST
93211: LIST
93212: PUSH
93213: LD_INT 4
93215: PUSH
93216: LD_INT 0
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 4
93225: PUSH
93226: LD_INT 1
93228: NEG
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 5
93236: PUSH
93237: LD_INT 0
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 5
93246: PUSH
93247: LD_INT 1
93249: PUSH
93250: EMPTY
93251: LIST
93252: LIST
93253: PUSH
93254: LD_INT 4
93256: PUSH
93257: LD_INT 1
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 3
93266: PUSH
93267: LD_INT 0
93269: PUSH
93270: EMPTY
93271: LIST
93272: LIST
93273: PUSH
93274: LD_INT 3
93276: PUSH
93277: LD_INT 1
93279: NEG
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 3
93287: PUSH
93288: LD_INT 2
93290: NEG
93291: PUSH
93292: EMPTY
93293: LIST
93294: LIST
93295: PUSH
93296: LD_INT 5
93298: PUSH
93299: LD_INT 2
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: EMPTY
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93353: LD_ADDR_VAR 0 32
93357: PUSH
93358: LD_INT 4
93360: NEG
93361: PUSH
93362: LD_INT 0
93364: PUSH
93365: EMPTY
93366: LIST
93367: LIST
93368: PUSH
93369: LD_INT 4
93371: NEG
93372: PUSH
93373: LD_INT 1
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 3
93383: NEG
93384: PUSH
93385: LD_INT 0
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 3
93394: NEG
93395: PUSH
93396: LD_INT 1
93398: PUSH
93399: EMPTY
93400: LIST
93401: LIST
93402: PUSH
93403: LD_INT 4
93405: NEG
93406: PUSH
93407: LD_INT 1
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 5
93416: NEG
93417: PUSH
93418: LD_INT 0
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 5
93427: NEG
93428: PUSH
93429: LD_INT 1
93431: NEG
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 5
93439: NEG
93440: PUSH
93441: LD_INT 2
93443: NEG
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 3
93451: NEG
93452: PUSH
93453: LD_INT 2
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: PUSH
93460: LD_INT 3
93462: NEG
93463: PUSH
93464: LD_INT 3
93466: NEG
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 3
93474: NEG
93475: PUSH
93476: LD_INT 4
93478: NEG
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 2
93486: NEG
93487: PUSH
93488: LD_INT 3
93490: NEG
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 2
93498: NEG
93499: PUSH
93500: LD_INT 2
93502: NEG
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 3
93510: NEG
93511: PUSH
93512: LD_INT 2
93514: NEG
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 4
93522: NEG
93523: PUSH
93524: LD_INT 3
93526: NEG
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 4
93534: NEG
93535: PUSH
93536: LD_INT 4
93538: NEG
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 2
93546: NEG
93547: PUSH
93548: LD_INT 4
93550: NEG
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 4
93558: NEG
93559: PUSH
93560: LD_INT 2
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 0
93570: PUSH
93571: LD_INT 4
93573: NEG
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 0
93581: PUSH
93582: LD_INT 5
93584: NEG
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: LD_INT 1
93592: PUSH
93593: LD_INT 4
93595: NEG
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 1
93603: PUSH
93604: LD_INT 3
93606: NEG
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 0
93614: PUSH
93615: LD_INT 3
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 1
93625: NEG
93626: PUSH
93627: LD_INT 4
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 1
93637: NEG
93638: PUSH
93639: LD_INT 5
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 2
93649: PUSH
93650: LD_INT 3
93652: NEG
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: LD_INT 2
93660: NEG
93661: PUSH
93662: LD_INT 5
93664: NEG
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: LD_INT 3
93672: PUSH
93673: LD_INT 0
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 3
93682: PUSH
93683: LD_INT 1
93685: NEG
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 4
93693: PUSH
93694: LD_INT 0
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PUSH
93701: LD_INT 4
93703: PUSH
93704: LD_INT 1
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 3
93713: PUSH
93714: LD_INT 1
93716: PUSH
93717: EMPTY
93718: LIST
93719: LIST
93720: PUSH
93721: LD_INT 2
93723: PUSH
93724: LD_INT 0
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: LD_INT 2
93733: PUSH
93734: LD_INT 1
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 2
93744: PUSH
93745: LD_INT 2
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 4
93755: PUSH
93756: LD_INT 2
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 4
93765: PUSH
93766: LD_INT 4
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 4
93775: PUSH
93776: LD_INT 3
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 5
93785: PUSH
93786: LD_INT 4
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 5
93795: PUSH
93796: LD_INT 5
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 4
93805: PUSH
93806: LD_INT 5
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: LD_INT 3
93815: PUSH
93816: LD_INT 4
93818: PUSH
93819: EMPTY
93820: LIST
93821: LIST
93822: PUSH
93823: LD_INT 3
93825: PUSH
93826: LD_INT 3
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 5
93835: PUSH
93836: LD_INT 3
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 3
93845: PUSH
93846: LD_INT 5
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
93900: LD_ADDR_VAR 0 33
93904: PUSH
93905: LD_INT 4
93907: NEG
93908: PUSH
93909: LD_INT 4
93911: NEG
93912: PUSH
93913: EMPTY
93914: LIST
93915: LIST
93916: PUSH
93917: LD_INT 4
93919: NEG
93920: PUSH
93921: LD_INT 5
93923: NEG
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: PUSH
93929: LD_INT 3
93931: NEG
93932: PUSH
93933: LD_INT 4
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 3
93943: NEG
93944: PUSH
93945: LD_INT 3
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 4
93955: NEG
93956: PUSH
93957: LD_INT 3
93959: NEG
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 5
93967: NEG
93968: PUSH
93969: LD_INT 4
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 5
93979: NEG
93980: PUSH
93981: LD_INT 5
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 3
93991: NEG
93992: PUSH
93993: LD_INT 5
93995: NEG
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 5
94003: NEG
94004: PUSH
94005: LD_INT 3
94007: NEG
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 0
94015: PUSH
94016: LD_INT 3
94018: NEG
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 0
94026: PUSH
94027: LD_INT 4
94029: NEG
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PUSH
94035: LD_INT 1
94037: PUSH
94038: LD_INT 3
94040: NEG
94041: PUSH
94042: EMPTY
94043: LIST
94044: LIST
94045: PUSH
94046: LD_INT 1
94048: PUSH
94049: LD_INT 2
94051: NEG
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 0
94059: PUSH
94060: LD_INT 2
94062: NEG
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 1
94070: NEG
94071: PUSH
94072: LD_INT 3
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 1
94082: NEG
94083: PUSH
94084: LD_INT 4
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 2
94094: PUSH
94095: LD_INT 2
94097: NEG
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 2
94105: NEG
94106: PUSH
94107: LD_INT 4
94109: NEG
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 4
94117: PUSH
94118: LD_INT 0
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 4
94127: PUSH
94128: LD_INT 1
94130: NEG
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 5
94138: PUSH
94139: LD_INT 0
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 5
94148: PUSH
94149: LD_INT 1
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: PUSH
94156: LD_INT 4
94158: PUSH
94159: LD_INT 1
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: PUSH
94166: LD_INT 3
94168: PUSH
94169: LD_INT 0
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: LD_INT 3
94178: PUSH
94179: LD_INT 1
94181: NEG
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 3
94189: PUSH
94190: LD_INT 2
94192: NEG
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 5
94200: PUSH
94201: LD_INT 2
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 3
94210: PUSH
94211: LD_INT 3
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 3
94220: PUSH
94221: LD_INT 2
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 4
94230: PUSH
94231: LD_INT 3
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 4
94240: PUSH
94241: LD_INT 4
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 3
94250: PUSH
94251: LD_INT 4
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 2
94260: PUSH
94261: LD_INT 3
94263: PUSH
94264: EMPTY
94265: LIST
94266: LIST
94267: PUSH
94268: LD_INT 2
94270: PUSH
94271: LD_INT 2
94273: PUSH
94274: EMPTY
94275: LIST
94276: LIST
94277: PUSH
94278: LD_INT 4
94280: PUSH
94281: LD_INT 2
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 2
94290: PUSH
94291: LD_INT 4
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: LD_INT 0
94300: PUSH
94301: LD_INT 4
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: LD_INT 0
94310: PUSH
94311: LD_INT 3
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PUSH
94318: LD_INT 1
94320: PUSH
94321: LD_INT 4
94323: PUSH
94324: EMPTY
94325: LIST
94326: LIST
94327: PUSH
94328: LD_INT 1
94330: PUSH
94331: LD_INT 5
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 0
94340: PUSH
94341: LD_INT 5
94343: PUSH
94344: EMPTY
94345: LIST
94346: LIST
94347: PUSH
94348: LD_INT 1
94350: NEG
94351: PUSH
94352: LD_INT 4
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 1
94361: NEG
94362: PUSH
94363: LD_INT 3
94365: PUSH
94366: EMPTY
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 2
94372: PUSH
94373: LD_INT 5
94375: PUSH
94376: EMPTY
94377: LIST
94378: LIST
94379: PUSH
94380: LD_INT 2
94382: NEG
94383: PUSH
94384: LD_INT 3
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94438: LD_ADDR_VAR 0 34
94442: PUSH
94443: LD_INT 0
94445: PUSH
94446: LD_INT 4
94448: NEG
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 0
94456: PUSH
94457: LD_INT 5
94459: NEG
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: LD_INT 1
94467: PUSH
94468: LD_INT 4
94470: NEG
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: PUSH
94476: LD_INT 1
94478: PUSH
94479: LD_INT 3
94481: NEG
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PUSH
94487: LD_INT 0
94489: PUSH
94490: LD_INT 3
94492: NEG
94493: PUSH
94494: EMPTY
94495: LIST
94496: LIST
94497: PUSH
94498: LD_INT 1
94500: NEG
94501: PUSH
94502: LD_INT 4
94504: NEG
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: PUSH
94510: LD_INT 1
94512: NEG
94513: PUSH
94514: LD_INT 5
94516: NEG
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 2
94524: PUSH
94525: LD_INT 3
94527: NEG
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 2
94535: NEG
94536: PUSH
94537: LD_INT 5
94539: NEG
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PUSH
94545: LD_INT 3
94547: PUSH
94548: LD_INT 0
94550: PUSH
94551: EMPTY
94552: LIST
94553: LIST
94554: PUSH
94555: LD_INT 3
94557: PUSH
94558: LD_INT 1
94560: NEG
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: PUSH
94566: LD_INT 4
94568: PUSH
94569: LD_INT 0
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 4
94578: PUSH
94579: LD_INT 1
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 3
94588: PUSH
94589: LD_INT 1
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 2
94598: PUSH
94599: LD_INT 0
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 2
94608: PUSH
94609: LD_INT 1
94611: NEG
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 2
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 4
94630: PUSH
94631: LD_INT 2
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: PUSH
94638: LD_INT 4
94640: PUSH
94641: LD_INT 4
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 4
94650: PUSH
94651: LD_INT 3
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 5
94660: PUSH
94661: LD_INT 4
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 5
94670: PUSH
94671: LD_INT 5
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: LD_INT 4
94680: PUSH
94681: LD_INT 5
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 3
94690: PUSH
94691: LD_INT 4
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 3
94700: PUSH
94701: LD_INT 3
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 5
94710: PUSH
94711: LD_INT 3
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 3
94720: PUSH
94721: LD_INT 5
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 0
94730: PUSH
94731: LD_INT 3
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 0
94740: PUSH
94741: LD_INT 2
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 1
94750: PUSH
94751: LD_INT 3
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 1
94760: PUSH
94761: LD_INT 4
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: PUSH
94768: LD_INT 0
94770: PUSH
94771: LD_INT 4
94773: PUSH
94774: EMPTY
94775: LIST
94776: LIST
94777: PUSH
94778: LD_INT 1
94780: NEG
94781: PUSH
94782: LD_INT 3
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 1
94791: NEG
94792: PUSH
94793: LD_INT 2
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 2
94802: PUSH
94803: LD_INT 4
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 2
94812: NEG
94813: PUSH
94814: LD_INT 2
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 4
94823: NEG
94824: PUSH
94825: LD_INT 0
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 4
94834: NEG
94835: PUSH
94836: LD_INT 1
94838: NEG
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 3
94846: NEG
94847: PUSH
94848: LD_INT 0
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 3
94857: NEG
94858: PUSH
94859: LD_INT 1
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 4
94868: NEG
94869: PUSH
94870: LD_INT 1
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: PUSH
94877: LD_INT 5
94879: NEG
94880: PUSH
94881: LD_INT 0
94883: PUSH
94884: EMPTY
94885: LIST
94886: LIST
94887: PUSH
94888: LD_INT 5
94890: NEG
94891: PUSH
94892: LD_INT 1
94894: NEG
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: PUSH
94900: LD_INT 5
94902: NEG
94903: PUSH
94904: LD_INT 2
94906: NEG
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 3
94914: NEG
94915: PUSH
94916: LD_INT 2
94918: PUSH
94919: EMPTY
94920: LIST
94921: LIST
94922: PUSH
94923: EMPTY
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: ST_TO_ADDR
// end ; end ;
94970: GO 94973
94972: POP
// case btype of b_depot , b_warehouse :
94973: LD_VAR 0 1
94977: PUSH
94978: LD_INT 0
94980: DOUBLE
94981: EQUAL
94982: IFTRUE 94992
94984: LD_INT 1
94986: DOUBLE
94987: EQUAL
94988: IFTRUE 94992
94990: GO 95193
94992: POP
// case nation of nation_american :
94993: LD_VAR 0 5
94997: PUSH
94998: LD_INT 1
95000: DOUBLE
95001: EQUAL
95002: IFTRUE 95006
95004: GO 95062
95006: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95007: LD_ADDR_VAR 0 9
95011: PUSH
95012: LD_VAR 0 11
95016: PUSH
95017: LD_VAR 0 12
95021: PUSH
95022: LD_VAR 0 13
95026: PUSH
95027: LD_VAR 0 14
95031: PUSH
95032: LD_VAR 0 15
95036: PUSH
95037: LD_VAR 0 16
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: PUSH
95050: LD_VAR 0 4
95054: PUSH
95055: LD_INT 1
95057: PLUS
95058: ARRAY
95059: ST_TO_ADDR
95060: GO 95191
95062: LD_INT 2
95064: DOUBLE
95065: EQUAL
95066: IFTRUE 95070
95068: GO 95126
95070: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95071: LD_ADDR_VAR 0 9
95075: PUSH
95076: LD_VAR 0 17
95080: PUSH
95081: LD_VAR 0 18
95085: PUSH
95086: LD_VAR 0 19
95090: PUSH
95091: LD_VAR 0 20
95095: PUSH
95096: LD_VAR 0 21
95100: PUSH
95101: LD_VAR 0 22
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: PUSH
95114: LD_VAR 0 4
95118: PUSH
95119: LD_INT 1
95121: PLUS
95122: ARRAY
95123: ST_TO_ADDR
95124: GO 95191
95126: LD_INT 3
95128: DOUBLE
95129: EQUAL
95130: IFTRUE 95134
95132: GO 95190
95134: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95135: LD_ADDR_VAR 0 9
95139: PUSH
95140: LD_VAR 0 23
95144: PUSH
95145: LD_VAR 0 24
95149: PUSH
95150: LD_VAR 0 25
95154: PUSH
95155: LD_VAR 0 26
95159: PUSH
95160: LD_VAR 0 27
95164: PUSH
95165: LD_VAR 0 28
95169: PUSH
95170: EMPTY
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: PUSH
95178: LD_VAR 0 4
95182: PUSH
95183: LD_INT 1
95185: PLUS
95186: ARRAY
95187: ST_TO_ADDR
95188: GO 95191
95190: POP
95191: GO 95746
95193: LD_INT 2
95195: DOUBLE
95196: EQUAL
95197: IFTRUE 95207
95199: LD_INT 3
95201: DOUBLE
95202: EQUAL
95203: IFTRUE 95207
95205: GO 95263
95207: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95208: LD_ADDR_VAR 0 9
95212: PUSH
95213: LD_VAR 0 29
95217: PUSH
95218: LD_VAR 0 30
95222: PUSH
95223: LD_VAR 0 31
95227: PUSH
95228: LD_VAR 0 32
95232: PUSH
95233: LD_VAR 0 33
95237: PUSH
95238: LD_VAR 0 34
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: PUSH
95251: LD_VAR 0 4
95255: PUSH
95256: LD_INT 1
95258: PLUS
95259: ARRAY
95260: ST_TO_ADDR
95261: GO 95746
95263: LD_INT 16
95265: DOUBLE
95266: EQUAL
95267: IFTRUE 95325
95269: LD_INT 17
95271: DOUBLE
95272: EQUAL
95273: IFTRUE 95325
95275: LD_INT 18
95277: DOUBLE
95278: EQUAL
95279: IFTRUE 95325
95281: LD_INT 19
95283: DOUBLE
95284: EQUAL
95285: IFTRUE 95325
95287: LD_INT 22
95289: DOUBLE
95290: EQUAL
95291: IFTRUE 95325
95293: LD_INT 20
95295: DOUBLE
95296: EQUAL
95297: IFTRUE 95325
95299: LD_INT 21
95301: DOUBLE
95302: EQUAL
95303: IFTRUE 95325
95305: LD_INT 23
95307: DOUBLE
95308: EQUAL
95309: IFTRUE 95325
95311: LD_INT 24
95313: DOUBLE
95314: EQUAL
95315: IFTRUE 95325
95317: LD_INT 25
95319: DOUBLE
95320: EQUAL
95321: IFTRUE 95325
95323: GO 95381
95325: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95326: LD_ADDR_VAR 0 9
95330: PUSH
95331: LD_VAR 0 35
95335: PUSH
95336: LD_VAR 0 36
95340: PUSH
95341: LD_VAR 0 37
95345: PUSH
95346: LD_VAR 0 38
95350: PUSH
95351: LD_VAR 0 39
95355: PUSH
95356: LD_VAR 0 40
95360: PUSH
95361: EMPTY
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: PUSH
95369: LD_VAR 0 4
95373: PUSH
95374: LD_INT 1
95376: PLUS
95377: ARRAY
95378: ST_TO_ADDR
95379: GO 95746
95381: LD_INT 6
95383: DOUBLE
95384: EQUAL
95385: IFTRUE 95437
95387: LD_INT 7
95389: DOUBLE
95390: EQUAL
95391: IFTRUE 95437
95393: LD_INT 8
95395: DOUBLE
95396: EQUAL
95397: IFTRUE 95437
95399: LD_INT 13
95401: DOUBLE
95402: EQUAL
95403: IFTRUE 95437
95405: LD_INT 12
95407: DOUBLE
95408: EQUAL
95409: IFTRUE 95437
95411: LD_INT 15
95413: DOUBLE
95414: EQUAL
95415: IFTRUE 95437
95417: LD_INT 11
95419: DOUBLE
95420: EQUAL
95421: IFTRUE 95437
95423: LD_INT 14
95425: DOUBLE
95426: EQUAL
95427: IFTRUE 95437
95429: LD_INT 10
95431: DOUBLE
95432: EQUAL
95433: IFTRUE 95437
95435: GO 95493
95437: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
95438: LD_ADDR_VAR 0 9
95442: PUSH
95443: LD_VAR 0 41
95447: PUSH
95448: LD_VAR 0 42
95452: PUSH
95453: LD_VAR 0 43
95457: PUSH
95458: LD_VAR 0 44
95462: PUSH
95463: LD_VAR 0 45
95467: PUSH
95468: LD_VAR 0 46
95472: PUSH
95473: EMPTY
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: PUSH
95481: LD_VAR 0 4
95485: PUSH
95486: LD_INT 1
95488: PLUS
95489: ARRAY
95490: ST_TO_ADDR
95491: GO 95746
95493: LD_INT 36
95495: DOUBLE
95496: EQUAL
95497: IFTRUE 95501
95499: GO 95557
95501: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95502: LD_ADDR_VAR 0 9
95506: PUSH
95507: LD_VAR 0 47
95511: PUSH
95512: LD_VAR 0 48
95516: PUSH
95517: LD_VAR 0 49
95521: PUSH
95522: LD_VAR 0 50
95526: PUSH
95527: LD_VAR 0 51
95531: PUSH
95532: LD_VAR 0 52
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: PUSH
95545: LD_VAR 0 4
95549: PUSH
95550: LD_INT 1
95552: PLUS
95553: ARRAY
95554: ST_TO_ADDR
95555: GO 95746
95557: LD_INT 4
95559: DOUBLE
95560: EQUAL
95561: IFTRUE 95583
95563: LD_INT 5
95565: DOUBLE
95566: EQUAL
95567: IFTRUE 95583
95569: LD_INT 34
95571: DOUBLE
95572: EQUAL
95573: IFTRUE 95583
95575: LD_INT 37
95577: DOUBLE
95578: EQUAL
95579: IFTRUE 95583
95581: GO 95639
95583: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95584: LD_ADDR_VAR 0 9
95588: PUSH
95589: LD_VAR 0 53
95593: PUSH
95594: LD_VAR 0 54
95598: PUSH
95599: LD_VAR 0 55
95603: PUSH
95604: LD_VAR 0 56
95608: PUSH
95609: LD_VAR 0 57
95613: PUSH
95614: LD_VAR 0 58
95618: PUSH
95619: EMPTY
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: PUSH
95627: LD_VAR 0 4
95631: PUSH
95632: LD_INT 1
95634: PLUS
95635: ARRAY
95636: ST_TO_ADDR
95637: GO 95746
95639: LD_INT 31
95641: DOUBLE
95642: EQUAL
95643: IFTRUE 95689
95645: LD_INT 32
95647: DOUBLE
95648: EQUAL
95649: IFTRUE 95689
95651: LD_INT 33
95653: DOUBLE
95654: EQUAL
95655: IFTRUE 95689
95657: LD_INT 27
95659: DOUBLE
95660: EQUAL
95661: IFTRUE 95689
95663: LD_INT 26
95665: DOUBLE
95666: EQUAL
95667: IFTRUE 95689
95669: LD_INT 28
95671: DOUBLE
95672: EQUAL
95673: IFTRUE 95689
95675: LD_INT 29
95677: DOUBLE
95678: EQUAL
95679: IFTRUE 95689
95681: LD_INT 30
95683: DOUBLE
95684: EQUAL
95685: IFTRUE 95689
95687: GO 95745
95689: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
95690: LD_ADDR_VAR 0 9
95694: PUSH
95695: LD_VAR 0 59
95699: PUSH
95700: LD_VAR 0 60
95704: PUSH
95705: LD_VAR 0 61
95709: PUSH
95710: LD_VAR 0 62
95714: PUSH
95715: LD_VAR 0 63
95719: PUSH
95720: LD_VAR 0 64
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: PUSH
95733: LD_VAR 0 4
95737: PUSH
95738: LD_INT 1
95740: PLUS
95741: ARRAY
95742: ST_TO_ADDR
95743: GO 95746
95745: POP
// temp_list2 = [ ] ;
95746: LD_ADDR_VAR 0 10
95750: PUSH
95751: EMPTY
95752: ST_TO_ADDR
// for i in temp_list do
95753: LD_ADDR_VAR 0 8
95757: PUSH
95758: LD_VAR 0 9
95762: PUSH
95763: FOR_IN
95764: IFFALSE 95816
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95766: LD_ADDR_VAR 0 10
95770: PUSH
95771: LD_VAR 0 10
95775: PUSH
95776: LD_VAR 0 8
95780: PUSH
95781: LD_INT 1
95783: ARRAY
95784: PUSH
95785: LD_VAR 0 2
95789: PLUS
95790: PUSH
95791: LD_VAR 0 8
95795: PUSH
95796: LD_INT 2
95798: ARRAY
95799: PUSH
95800: LD_VAR 0 3
95804: PLUS
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: EMPTY
95811: LIST
95812: ADD
95813: ST_TO_ADDR
95814: GO 95763
95816: POP
95817: POP
// result = temp_list2 ;
95818: LD_ADDR_VAR 0 7
95822: PUSH
95823: LD_VAR 0 10
95827: ST_TO_ADDR
// end ;
95828: LD_VAR 0 7
95832: RET
// export function EnemyInRange ( unit , dist ) ; begin
95833: LD_INT 0
95835: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95836: LD_ADDR_VAR 0 3
95840: PUSH
95841: LD_VAR 0 1
95845: PPUSH
95846: CALL_OW 255
95850: PPUSH
95851: LD_VAR 0 1
95855: PPUSH
95856: CALL_OW 250
95860: PPUSH
95861: LD_VAR 0 1
95865: PPUSH
95866: CALL_OW 251
95870: PPUSH
95871: LD_VAR 0 2
95875: PPUSH
95876: CALL 69235 0 4
95880: PUSH
95881: LD_INT 4
95883: ARRAY
95884: ST_TO_ADDR
// end ;
95885: LD_VAR 0 3
95889: RET
// export function PlayerSeeMe ( unit ) ; begin
95890: LD_INT 0
95892: PPUSH
// result := See ( your_side , unit ) ;
95893: LD_ADDR_VAR 0 2
95897: PUSH
95898: LD_OWVAR 2
95902: PPUSH
95903: LD_VAR 0 1
95907: PPUSH
95908: CALL_OW 292
95912: ST_TO_ADDR
// end ;
95913: LD_VAR 0 2
95917: RET
// export function ReverseDir ( unit ) ; begin
95918: LD_INT 0
95920: PPUSH
// if not unit then
95921: LD_VAR 0 1
95925: NOT
95926: IFFALSE 95930
// exit ;
95928: GO 95953
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
95930: LD_ADDR_VAR 0 2
95934: PUSH
95935: LD_VAR 0 1
95939: PPUSH
95940: CALL_OW 254
95944: PUSH
95945: LD_INT 3
95947: PLUS
95948: PUSH
95949: LD_INT 6
95951: MOD
95952: ST_TO_ADDR
// end ;
95953: LD_VAR 0 2
95957: RET
// export function ReverseArray ( array ) ; var i ; begin
95958: LD_INT 0
95960: PPUSH
95961: PPUSH
// if not array then
95962: LD_VAR 0 1
95966: NOT
95967: IFFALSE 95971
// exit ;
95969: GO 96026
// result := [ ] ;
95971: LD_ADDR_VAR 0 2
95975: PUSH
95976: EMPTY
95977: ST_TO_ADDR
// for i := array downto 1 do
95978: LD_ADDR_VAR 0 3
95982: PUSH
95983: DOUBLE
95984: LD_VAR 0 1
95988: INC
95989: ST_TO_ADDR
95990: LD_INT 1
95992: PUSH
95993: FOR_DOWNTO
95994: IFFALSE 96024
// result := Join ( result , array [ i ] ) ;
95996: LD_ADDR_VAR 0 2
96000: PUSH
96001: LD_VAR 0 2
96005: PPUSH
96006: LD_VAR 0 1
96010: PUSH
96011: LD_VAR 0 3
96015: ARRAY
96016: PPUSH
96017: CALL 100651 0 2
96021: ST_TO_ADDR
96022: GO 95993
96024: POP
96025: POP
// end ;
96026: LD_VAR 0 2
96030: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
96031: LD_INT 0
96033: PPUSH
96034: PPUSH
96035: PPUSH
96036: PPUSH
96037: PPUSH
96038: PPUSH
// if not unit or not hexes then
96039: LD_VAR 0 1
96043: NOT
96044: PUSH
96045: LD_VAR 0 2
96049: NOT
96050: OR
96051: IFFALSE 96055
// exit ;
96053: GO 96178
// dist := 9999 ;
96055: LD_ADDR_VAR 0 5
96059: PUSH
96060: LD_INT 9999
96062: ST_TO_ADDR
// for i = 1 to hexes do
96063: LD_ADDR_VAR 0 4
96067: PUSH
96068: DOUBLE
96069: LD_INT 1
96071: DEC
96072: ST_TO_ADDR
96073: LD_VAR 0 2
96077: PUSH
96078: FOR_TO
96079: IFFALSE 96166
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96081: LD_ADDR_VAR 0 6
96085: PUSH
96086: LD_VAR 0 1
96090: PPUSH
96091: LD_VAR 0 2
96095: PUSH
96096: LD_VAR 0 4
96100: ARRAY
96101: PUSH
96102: LD_INT 1
96104: ARRAY
96105: PPUSH
96106: LD_VAR 0 2
96110: PUSH
96111: LD_VAR 0 4
96115: ARRAY
96116: PUSH
96117: LD_INT 2
96119: ARRAY
96120: PPUSH
96121: CALL_OW 297
96125: ST_TO_ADDR
// if tdist < dist then
96126: LD_VAR 0 6
96130: PUSH
96131: LD_VAR 0 5
96135: LESS
96136: IFFALSE 96164
// begin hex := hexes [ i ] ;
96138: LD_ADDR_VAR 0 8
96142: PUSH
96143: LD_VAR 0 2
96147: PUSH
96148: LD_VAR 0 4
96152: ARRAY
96153: ST_TO_ADDR
// dist := tdist ;
96154: LD_ADDR_VAR 0 5
96158: PUSH
96159: LD_VAR 0 6
96163: ST_TO_ADDR
// end ; end ;
96164: GO 96078
96166: POP
96167: POP
// result := hex ;
96168: LD_ADDR_VAR 0 3
96172: PUSH
96173: LD_VAR 0 8
96177: ST_TO_ADDR
// end ;
96178: LD_VAR 0 3
96182: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96183: LD_INT 0
96185: PPUSH
96186: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96187: LD_VAR 0 1
96191: NOT
96192: PUSH
96193: LD_VAR 0 1
96197: PUSH
96198: LD_INT 21
96200: PUSH
96201: LD_INT 2
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 23
96210: PUSH
96211: LD_INT 2
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: EMPTY
96219: LIST
96220: LIST
96221: PPUSH
96222: CALL_OW 69
96226: IN
96227: NOT
96228: OR
96229: IFFALSE 96233
// exit ;
96231: GO 96280
// for i = 1 to 3 do
96233: LD_ADDR_VAR 0 3
96237: PUSH
96238: DOUBLE
96239: LD_INT 1
96241: DEC
96242: ST_TO_ADDR
96243: LD_INT 3
96245: PUSH
96246: FOR_TO
96247: IFFALSE 96278
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96249: LD_VAR 0 1
96253: PPUSH
96254: CALL_OW 250
96258: PPUSH
96259: LD_VAR 0 1
96263: PPUSH
96264: CALL_OW 251
96268: PPUSH
96269: LD_INT 1
96271: PPUSH
96272: CALL_OW 453
96276: GO 96246
96278: POP
96279: POP
// end ;
96280: LD_VAR 0 2
96284: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96285: LD_INT 0
96287: PPUSH
96288: PPUSH
96289: PPUSH
96290: PPUSH
96291: PPUSH
96292: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96293: LD_VAR 0 1
96297: NOT
96298: PUSH
96299: LD_VAR 0 2
96303: NOT
96304: OR
96305: PUSH
96306: LD_VAR 0 1
96310: PPUSH
96311: CALL_OW 314
96315: OR
96316: IFFALSE 96320
// exit ;
96318: GO 96761
// x := GetX ( enemy_unit ) ;
96320: LD_ADDR_VAR 0 7
96324: PUSH
96325: LD_VAR 0 2
96329: PPUSH
96330: CALL_OW 250
96334: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96335: LD_ADDR_VAR 0 8
96339: PUSH
96340: LD_VAR 0 2
96344: PPUSH
96345: CALL_OW 251
96349: ST_TO_ADDR
// if not x or not y then
96350: LD_VAR 0 7
96354: NOT
96355: PUSH
96356: LD_VAR 0 8
96360: NOT
96361: OR
96362: IFFALSE 96366
// exit ;
96364: GO 96761
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96366: LD_ADDR_VAR 0 6
96370: PUSH
96371: LD_VAR 0 7
96375: PPUSH
96376: LD_INT 0
96378: PPUSH
96379: LD_INT 4
96381: PPUSH
96382: CALL_OW 272
96386: PUSH
96387: LD_VAR 0 8
96391: PPUSH
96392: LD_INT 0
96394: PPUSH
96395: LD_INT 4
96397: PPUSH
96398: CALL_OW 273
96402: PUSH
96403: EMPTY
96404: LIST
96405: LIST
96406: PUSH
96407: LD_VAR 0 7
96411: PPUSH
96412: LD_INT 1
96414: PPUSH
96415: LD_INT 4
96417: PPUSH
96418: CALL_OW 272
96422: PUSH
96423: LD_VAR 0 8
96427: PPUSH
96428: LD_INT 1
96430: PPUSH
96431: LD_INT 4
96433: PPUSH
96434: CALL_OW 273
96438: PUSH
96439: EMPTY
96440: LIST
96441: LIST
96442: PUSH
96443: LD_VAR 0 7
96447: PPUSH
96448: LD_INT 2
96450: PPUSH
96451: LD_INT 4
96453: PPUSH
96454: CALL_OW 272
96458: PUSH
96459: LD_VAR 0 8
96463: PPUSH
96464: LD_INT 2
96466: PPUSH
96467: LD_INT 4
96469: PPUSH
96470: CALL_OW 273
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_VAR 0 7
96483: PPUSH
96484: LD_INT 3
96486: PPUSH
96487: LD_INT 4
96489: PPUSH
96490: CALL_OW 272
96494: PUSH
96495: LD_VAR 0 8
96499: PPUSH
96500: LD_INT 3
96502: PPUSH
96503: LD_INT 4
96505: PPUSH
96506: CALL_OW 273
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_VAR 0 7
96519: PPUSH
96520: LD_INT 4
96522: PPUSH
96523: LD_INT 4
96525: PPUSH
96526: CALL_OW 272
96530: PUSH
96531: LD_VAR 0 8
96535: PPUSH
96536: LD_INT 4
96538: PPUSH
96539: LD_INT 4
96541: PPUSH
96542: CALL_OW 273
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: PUSH
96551: LD_VAR 0 7
96555: PPUSH
96556: LD_INT 5
96558: PPUSH
96559: LD_INT 4
96561: PPUSH
96562: CALL_OW 272
96566: PUSH
96567: LD_VAR 0 8
96571: PPUSH
96572: LD_INT 5
96574: PPUSH
96575: LD_INT 4
96577: PPUSH
96578: CALL_OW 273
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: ST_TO_ADDR
// for i = tmp downto 1 do
96595: LD_ADDR_VAR 0 4
96599: PUSH
96600: DOUBLE
96601: LD_VAR 0 6
96605: INC
96606: ST_TO_ADDR
96607: LD_INT 1
96609: PUSH
96610: FOR_DOWNTO
96611: IFFALSE 96712
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96613: LD_VAR 0 6
96617: PUSH
96618: LD_VAR 0 4
96622: ARRAY
96623: PUSH
96624: LD_INT 1
96626: ARRAY
96627: PPUSH
96628: LD_VAR 0 6
96632: PUSH
96633: LD_VAR 0 4
96637: ARRAY
96638: PUSH
96639: LD_INT 2
96641: ARRAY
96642: PPUSH
96643: CALL_OW 488
96647: NOT
96648: PUSH
96649: LD_VAR 0 6
96653: PUSH
96654: LD_VAR 0 4
96658: ARRAY
96659: PUSH
96660: LD_INT 1
96662: ARRAY
96663: PPUSH
96664: LD_VAR 0 6
96668: PUSH
96669: LD_VAR 0 4
96673: ARRAY
96674: PUSH
96675: LD_INT 2
96677: ARRAY
96678: PPUSH
96679: CALL_OW 428
96683: PUSH
96684: LD_INT 0
96686: NONEQUAL
96687: OR
96688: IFFALSE 96710
// tmp := Delete ( tmp , i ) ;
96690: LD_ADDR_VAR 0 6
96694: PUSH
96695: LD_VAR 0 6
96699: PPUSH
96700: LD_VAR 0 4
96704: PPUSH
96705: CALL_OW 3
96709: ST_TO_ADDR
96710: GO 96610
96712: POP
96713: POP
// j := GetClosestHex ( unit , tmp ) ;
96714: LD_ADDR_VAR 0 5
96718: PUSH
96719: LD_VAR 0 1
96723: PPUSH
96724: LD_VAR 0 6
96728: PPUSH
96729: CALL 96031 0 2
96733: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96734: LD_VAR 0 1
96738: PPUSH
96739: LD_VAR 0 5
96743: PUSH
96744: LD_INT 1
96746: ARRAY
96747: PPUSH
96748: LD_VAR 0 5
96752: PUSH
96753: LD_INT 2
96755: ARRAY
96756: PPUSH
96757: CALL_OW 111
// end ;
96761: LD_VAR 0 3
96765: RET
// export function PrepareApemanSoldier ( ) ; begin
96766: LD_INT 0
96768: PPUSH
// uc_nation := 0 ;
96769: LD_ADDR_OWVAR 21
96773: PUSH
96774: LD_INT 0
96776: ST_TO_ADDR
// hc_sex := sex_male ;
96777: LD_ADDR_OWVAR 27
96781: PUSH
96782: LD_INT 1
96784: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
96785: LD_ADDR_OWVAR 28
96789: PUSH
96790: LD_INT 15
96792: ST_TO_ADDR
// hc_gallery :=  ;
96793: LD_ADDR_OWVAR 33
96797: PUSH
96798: LD_STRING 
96800: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96801: LD_ADDR_OWVAR 31
96805: PUSH
96806: LD_INT 0
96808: PPUSH
96809: LD_INT 3
96811: PPUSH
96812: CALL_OW 12
96816: PUSH
96817: LD_INT 0
96819: PPUSH
96820: LD_INT 3
96822: PPUSH
96823: CALL_OW 12
96827: PUSH
96828: LD_INT 0
96830: PUSH
96831: LD_INT 0
96833: PUSH
96834: EMPTY
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: ST_TO_ADDR
// end ;
96840: LD_VAR 0 1
96844: RET
// export function PrepareApemanEngineer ( ) ; begin
96845: LD_INT 0
96847: PPUSH
// uc_nation := 0 ;
96848: LD_ADDR_OWVAR 21
96852: PUSH
96853: LD_INT 0
96855: ST_TO_ADDR
// hc_sex := sex_male ;
96856: LD_ADDR_OWVAR 27
96860: PUSH
96861: LD_INT 1
96863: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
96864: LD_ADDR_OWVAR 28
96868: PUSH
96869: LD_INT 16
96871: ST_TO_ADDR
// hc_gallery :=  ;
96872: LD_ADDR_OWVAR 33
96876: PUSH
96877: LD_STRING 
96879: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96880: LD_ADDR_OWVAR 31
96884: PUSH
96885: LD_INT 0
96887: PPUSH
96888: LD_INT 3
96890: PPUSH
96891: CALL_OW 12
96895: PUSH
96896: LD_INT 0
96898: PPUSH
96899: LD_INT 3
96901: PPUSH
96902: CALL_OW 12
96906: PUSH
96907: LD_INT 0
96909: PUSH
96910: LD_INT 0
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: ST_TO_ADDR
// end ;
96919: LD_VAR 0 1
96923: RET
// export function PrepareApeman ( agressivity ) ; begin
96924: LD_INT 0
96926: PPUSH
// uc_side := 0 ;
96927: LD_ADDR_OWVAR 20
96931: PUSH
96932: LD_INT 0
96934: ST_TO_ADDR
// uc_nation := 0 ;
96935: LD_ADDR_OWVAR 21
96939: PUSH
96940: LD_INT 0
96942: ST_TO_ADDR
// hc_sex := sex_male ;
96943: LD_ADDR_OWVAR 27
96947: PUSH
96948: LD_INT 1
96950: ST_TO_ADDR
// hc_class := class_apeman ;
96951: LD_ADDR_OWVAR 28
96955: PUSH
96956: LD_INT 12
96958: ST_TO_ADDR
// hc_gallery :=  ;
96959: LD_ADDR_OWVAR 33
96963: PUSH
96964: LD_STRING 
96966: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
96967: LD_ADDR_OWVAR 35
96971: PUSH
96972: LD_VAR 0 1
96976: NEG
96977: PPUSH
96978: LD_VAR 0 1
96982: PPUSH
96983: CALL_OW 12
96987: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96988: LD_ADDR_OWVAR 31
96992: PUSH
96993: LD_INT 0
96995: PPUSH
96996: LD_INT 3
96998: PPUSH
96999: CALL_OW 12
97003: PUSH
97004: LD_INT 0
97006: PPUSH
97007: LD_INT 3
97009: PPUSH
97010: CALL_OW 12
97014: PUSH
97015: LD_INT 0
97017: PUSH
97018: LD_INT 0
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: ST_TO_ADDR
// end ;
97027: LD_VAR 0 2
97031: RET
// export function PrepareTiger ( agressivity ) ; begin
97032: LD_INT 0
97034: PPUSH
// uc_side := 0 ;
97035: LD_ADDR_OWVAR 20
97039: PUSH
97040: LD_INT 0
97042: ST_TO_ADDR
// uc_nation := 0 ;
97043: LD_ADDR_OWVAR 21
97047: PUSH
97048: LD_INT 0
97050: ST_TO_ADDR
// hc_class := class_tiger ;
97051: LD_ADDR_OWVAR 28
97055: PUSH
97056: LD_INT 14
97058: ST_TO_ADDR
// hc_gallery :=  ;
97059: LD_ADDR_OWVAR 33
97063: PUSH
97064: LD_STRING 
97066: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97067: LD_ADDR_OWVAR 35
97071: PUSH
97072: LD_VAR 0 1
97076: NEG
97077: PPUSH
97078: LD_VAR 0 1
97082: PPUSH
97083: CALL_OW 12
97087: ST_TO_ADDR
// end ;
97088: LD_VAR 0 2
97092: RET
// export function PrepareEnchidna ( ) ; begin
97093: LD_INT 0
97095: PPUSH
// uc_side := 0 ;
97096: LD_ADDR_OWVAR 20
97100: PUSH
97101: LD_INT 0
97103: ST_TO_ADDR
// uc_nation := 0 ;
97104: LD_ADDR_OWVAR 21
97108: PUSH
97109: LD_INT 0
97111: ST_TO_ADDR
// hc_class := class_baggie ;
97112: LD_ADDR_OWVAR 28
97116: PUSH
97117: LD_INT 13
97119: ST_TO_ADDR
// hc_gallery :=  ;
97120: LD_ADDR_OWVAR 33
97124: PUSH
97125: LD_STRING 
97127: ST_TO_ADDR
// end ;
97128: LD_VAR 0 1
97132: RET
// export function PrepareFrog ( ) ; begin
97133: LD_INT 0
97135: PPUSH
// uc_side := 0 ;
97136: LD_ADDR_OWVAR 20
97140: PUSH
97141: LD_INT 0
97143: ST_TO_ADDR
// uc_nation := 0 ;
97144: LD_ADDR_OWVAR 21
97148: PUSH
97149: LD_INT 0
97151: ST_TO_ADDR
// hc_class := class_frog ;
97152: LD_ADDR_OWVAR 28
97156: PUSH
97157: LD_INT 19
97159: ST_TO_ADDR
// hc_gallery :=  ;
97160: LD_ADDR_OWVAR 33
97164: PUSH
97165: LD_STRING 
97167: ST_TO_ADDR
// end ;
97168: LD_VAR 0 1
97172: RET
// export function PrepareFish ( ) ; begin
97173: LD_INT 0
97175: PPUSH
// uc_side := 0 ;
97176: LD_ADDR_OWVAR 20
97180: PUSH
97181: LD_INT 0
97183: ST_TO_ADDR
// uc_nation := 0 ;
97184: LD_ADDR_OWVAR 21
97188: PUSH
97189: LD_INT 0
97191: ST_TO_ADDR
// hc_class := class_fish ;
97192: LD_ADDR_OWVAR 28
97196: PUSH
97197: LD_INT 20
97199: ST_TO_ADDR
// hc_gallery :=  ;
97200: LD_ADDR_OWVAR 33
97204: PUSH
97205: LD_STRING 
97207: ST_TO_ADDR
// end ;
97208: LD_VAR 0 1
97212: RET
// export function PrepareBird ( ) ; begin
97213: LD_INT 0
97215: PPUSH
// uc_side := 0 ;
97216: LD_ADDR_OWVAR 20
97220: PUSH
97221: LD_INT 0
97223: ST_TO_ADDR
// uc_nation := 0 ;
97224: LD_ADDR_OWVAR 21
97228: PUSH
97229: LD_INT 0
97231: ST_TO_ADDR
// hc_class := class_phororhacos ;
97232: LD_ADDR_OWVAR 28
97236: PUSH
97237: LD_INT 18
97239: ST_TO_ADDR
// hc_gallery :=  ;
97240: LD_ADDR_OWVAR 33
97244: PUSH
97245: LD_STRING 
97247: ST_TO_ADDR
// end ;
97248: LD_VAR 0 1
97252: RET
// export function PrepareHorse ( ) ; begin
97253: LD_INT 0
97255: PPUSH
// uc_side := 0 ;
97256: LD_ADDR_OWVAR 20
97260: PUSH
97261: LD_INT 0
97263: ST_TO_ADDR
// uc_nation := 0 ;
97264: LD_ADDR_OWVAR 21
97268: PUSH
97269: LD_INT 0
97271: ST_TO_ADDR
// hc_class := class_horse ;
97272: LD_ADDR_OWVAR 28
97276: PUSH
97277: LD_INT 21
97279: ST_TO_ADDR
// hc_gallery :=  ;
97280: LD_ADDR_OWVAR 33
97284: PUSH
97285: LD_STRING 
97287: ST_TO_ADDR
// end ;
97288: LD_VAR 0 1
97292: RET
// export function PrepareMastodont ( ) ; begin
97293: LD_INT 0
97295: PPUSH
// uc_side := 0 ;
97296: LD_ADDR_OWVAR 20
97300: PUSH
97301: LD_INT 0
97303: ST_TO_ADDR
// uc_nation := 0 ;
97304: LD_ADDR_OWVAR 21
97308: PUSH
97309: LD_INT 0
97311: ST_TO_ADDR
// vc_chassis := class_mastodont ;
97312: LD_ADDR_OWVAR 37
97316: PUSH
97317: LD_INT 31
97319: ST_TO_ADDR
// vc_control := control_rider ;
97320: LD_ADDR_OWVAR 38
97324: PUSH
97325: LD_INT 4
97327: ST_TO_ADDR
// end ;
97328: LD_VAR 0 1
97332: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97333: LD_INT 0
97335: PPUSH
97336: PPUSH
97337: PPUSH
// uc_side = 0 ;
97338: LD_ADDR_OWVAR 20
97342: PUSH
97343: LD_INT 0
97345: ST_TO_ADDR
// uc_nation = 0 ;
97346: LD_ADDR_OWVAR 21
97350: PUSH
97351: LD_INT 0
97353: ST_TO_ADDR
// InitHc_All ( ) ;
97354: CALL_OW 584
// InitVc ;
97358: CALL_OW 20
// if mastodonts then
97362: LD_VAR 0 6
97366: IFFALSE 97433
// for i = 1 to mastodonts do
97368: LD_ADDR_VAR 0 11
97372: PUSH
97373: DOUBLE
97374: LD_INT 1
97376: DEC
97377: ST_TO_ADDR
97378: LD_VAR 0 6
97382: PUSH
97383: FOR_TO
97384: IFFALSE 97431
// begin vc_chassis := 31 ;
97386: LD_ADDR_OWVAR 37
97390: PUSH
97391: LD_INT 31
97393: ST_TO_ADDR
// vc_control := control_rider ;
97394: LD_ADDR_OWVAR 38
97398: PUSH
97399: LD_INT 4
97401: ST_TO_ADDR
// animal := CreateVehicle ;
97402: LD_ADDR_VAR 0 12
97406: PUSH
97407: CALL_OW 45
97411: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97412: LD_VAR 0 12
97416: PPUSH
97417: LD_VAR 0 8
97421: PPUSH
97422: LD_INT 0
97424: PPUSH
97425: CALL 99568 0 3
// end ;
97429: GO 97383
97431: POP
97432: POP
// if horses then
97433: LD_VAR 0 5
97437: IFFALSE 97504
// for i = 1 to horses do
97439: LD_ADDR_VAR 0 11
97443: PUSH
97444: DOUBLE
97445: LD_INT 1
97447: DEC
97448: ST_TO_ADDR
97449: LD_VAR 0 5
97453: PUSH
97454: FOR_TO
97455: IFFALSE 97502
// begin hc_class := 21 ;
97457: LD_ADDR_OWVAR 28
97461: PUSH
97462: LD_INT 21
97464: ST_TO_ADDR
// hc_gallery :=  ;
97465: LD_ADDR_OWVAR 33
97469: PUSH
97470: LD_STRING 
97472: ST_TO_ADDR
// animal := CreateHuman ;
97473: LD_ADDR_VAR 0 12
97477: PUSH
97478: CALL_OW 44
97482: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97483: LD_VAR 0 12
97487: PPUSH
97488: LD_VAR 0 8
97492: PPUSH
97493: LD_INT 0
97495: PPUSH
97496: CALL 99568 0 3
// end ;
97500: GO 97454
97502: POP
97503: POP
// if birds then
97504: LD_VAR 0 1
97508: IFFALSE 97575
// for i = 1 to birds do
97510: LD_ADDR_VAR 0 11
97514: PUSH
97515: DOUBLE
97516: LD_INT 1
97518: DEC
97519: ST_TO_ADDR
97520: LD_VAR 0 1
97524: PUSH
97525: FOR_TO
97526: IFFALSE 97573
// begin hc_class = 18 ;
97528: LD_ADDR_OWVAR 28
97532: PUSH
97533: LD_INT 18
97535: ST_TO_ADDR
// hc_gallery =  ;
97536: LD_ADDR_OWVAR 33
97540: PUSH
97541: LD_STRING 
97543: ST_TO_ADDR
// animal := CreateHuman ;
97544: LD_ADDR_VAR 0 12
97548: PUSH
97549: CALL_OW 44
97553: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97554: LD_VAR 0 12
97558: PPUSH
97559: LD_VAR 0 8
97563: PPUSH
97564: LD_INT 0
97566: PPUSH
97567: CALL 99568 0 3
// end ;
97571: GO 97525
97573: POP
97574: POP
// if tigers then
97575: LD_VAR 0 2
97579: IFFALSE 97663
// for i = 1 to tigers do
97581: LD_ADDR_VAR 0 11
97585: PUSH
97586: DOUBLE
97587: LD_INT 1
97589: DEC
97590: ST_TO_ADDR
97591: LD_VAR 0 2
97595: PUSH
97596: FOR_TO
97597: IFFALSE 97661
// begin hc_class = class_tiger ;
97599: LD_ADDR_OWVAR 28
97603: PUSH
97604: LD_INT 14
97606: ST_TO_ADDR
// hc_gallery =  ;
97607: LD_ADDR_OWVAR 33
97611: PUSH
97612: LD_STRING 
97614: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97615: LD_ADDR_OWVAR 35
97619: PUSH
97620: LD_INT 7
97622: NEG
97623: PPUSH
97624: LD_INT 7
97626: PPUSH
97627: CALL_OW 12
97631: ST_TO_ADDR
// animal := CreateHuman ;
97632: LD_ADDR_VAR 0 12
97636: PUSH
97637: CALL_OW 44
97641: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97642: LD_VAR 0 12
97646: PPUSH
97647: LD_VAR 0 8
97651: PPUSH
97652: LD_INT 0
97654: PPUSH
97655: CALL 99568 0 3
// end ;
97659: GO 97596
97661: POP
97662: POP
// if apemans then
97663: LD_VAR 0 3
97667: IFFALSE 97790
// for i = 1 to apemans do
97669: LD_ADDR_VAR 0 11
97673: PUSH
97674: DOUBLE
97675: LD_INT 1
97677: DEC
97678: ST_TO_ADDR
97679: LD_VAR 0 3
97683: PUSH
97684: FOR_TO
97685: IFFALSE 97788
// begin hc_class = class_apeman ;
97687: LD_ADDR_OWVAR 28
97691: PUSH
97692: LD_INT 12
97694: ST_TO_ADDR
// hc_gallery =  ;
97695: LD_ADDR_OWVAR 33
97699: PUSH
97700: LD_STRING 
97702: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
97703: LD_ADDR_OWVAR 35
97707: PUSH
97708: LD_INT 2
97710: NEG
97711: PPUSH
97712: LD_INT 2
97714: PPUSH
97715: CALL_OW 12
97719: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97720: LD_ADDR_OWVAR 31
97724: PUSH
97725: LD_INT 1
97727: PPUSH
97728: LD_INT 3
97730: PPUSH
97731: CALL_OW 12
97735: PUSH
97736: LD_INT 1
97738: PPUSH
97739: LD_INT 3
97741: PPUSH
97742: CALL_OW 12
97746: PUSH
97747: LD_INT 0
97749: PUSH
97750: LD_INT 0
97752: PUSH
97753: EMPTY
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: ST_TO_ADDR
// animal := CreateHuman ;
97759: LD_ADDR_VAR 0 12
97763: PUSH
97764: CALL_OW 44
97768: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97769: LD_VAR 0 12
97773: PPUSH
97774: LD_VAR 0 8
97778: PPUSH
97779: LD_INT 0
97781: PPUSH
97782: CALL 99568 0 3
// end ;
97786: GO 97684
97788: POP
97789: POP
// if enchidnas then
97790: LD_VAR 0 4
97794: IFFALSE 97861
// for i = 1 to enchidnas do
97796: LD_ADDR_VAR 0 11
97800: PUSH
97801: DOUBLE
97802: LD_INT 1
97804: DEC
97805: ST_TO_ADDR
97806: LD_VAR 0 4
97810: PUSH
97811: FOR_TO
97812: IFFALSE 97859
// begin hc_class = 13 ;
97814: LD_ADDR_OWVAR 28
97818: PUSH
97819: LD_INT 13
97821: ST_TO_ADDR
// hc_gallery =  ;
97822: LD_ADDR_OWVAR 33
97826: PUSH
97827: LD_STRING 
97829: ST_TO_ADDR
// animal := CreateHuman ;
97830: LD_ADDR_VAR 0 12
97834: PUSH
97835: CALL_OW 44
97839: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97840: LD_VAR 0 12
97844: PPUSH
97845: LD_VAR 0 8
97849: PPUSH
97850: LD_INT 0
97852: PPUSH
97853: CALL 99568 0 3
// end ;
97857: GO 97811
97859: POP
97860: POP
// if fishes then
97861: LD_VAR 0 7
97865: IFFALSE 97932
// for i = 1 to fishes do
97867: LD_ADDR_VAR 0 11
97871: PUSH
97872: DOUBLE
97873: LD_INT 1
97875: DEC
97876: ST_TO_ADDR
97877: LD_VAR 0 7
97881: PUSH
97882: FOR_TO
97883: IFFALSE 97930
// begin hc_class = 20 ;
97885: LD_ADDR_OWVAR 28
97889: PUSH
97890: LD_INT 20
97892: ST_TO_ADDR
// hc_gallery =  ;
97893: LD_ADDR_OWVAR 33
97897: PUSH
97898: LD_STRING 
97900: ST_TO_ADDR
// animal := CreateHuman ;
97901: LD_ADDR_VAR 0 12
97905: PUSH
97906: CALL_OW 44
97910: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97911: LD_VAR 0 12
97915: PPUSH
97916: LD_VAR 0 9
97920: PPUSH
97921: LD_INT 0
97923: PPUSH
97924: CALL 99568 0 3
// end ;
97928: GO 97882
97930: POP
97931: POP
// end ;
97932: LD_VAR 0 10
97936: RET
// export function WantHeal ( sci , unit ) ; begin
97937: LD_INT 0
97939: PPUSH
// if GetTaskList ( sci ) > 0 then
97940: LD_VAR 0 1
97944: PPUSH
97945: CALL_OW 437
97949: PUSH
97950: LD_INT 0
97952: GREATER
97953: IFFALSE 98023
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
97955: LD_VAR 0 1
97959: PPUSH
97960: CALL_OW 437
97964: PUSH
97965: LD_INT 1
97967: ARRAY
97968: PUSH
97969: LD_INT 1
97971: ARRAY
97972: PUSH
97973: LD_STRING l
97975: EQUAL
97976: PUSH
97977: LD_VAR 0 1
97981: PPUSH
97982: CALL_OW 437
97986: PUSH
97987: LD_INT 1
97989: ARRAY
97990: PUSH
97991: LD_INT 4
97993: ARRAY
97994: PUSH
97995: LD_VAR 0 2
97999: EQUAL
98000: AND
98001: IFFALSE 98013
// result := true else
98003: LD_ADDR_VAR 0 3
98007: PUSH
98008: LD_INT 1
98010: ST_TO_ADDR
98011: GO 98021
// result := false ;
98013: LD_ADDR_VAR 0 3
98017: PUSH
98018: LD_INT 0
98020: ST_TO_ADDR
// end else
98021: GO 98031
// result := false ;
98023: LD_ADDR_VAR 0 3
98027: PUSH
98028: LD_INT 0
98030: ST_TO_ADDR
// end ;
98031: LD_VAR 0 3
98035: RET
// export function HealTarget ( sci ) ; begin
98036: LD_INT 0
98038: PPUSH
// if not sci then
98039: LD_VAR 0 1
98043: NOT
98044: IFFALSE 98048
// exit ;
98046: GO 98113
// result := 0 ;
98048: LD_ADDR_VAR 0 2
98052: PUSH
98053: LD_INT 0
98055: ST_TO_ADDR
// if GetTaskList ( sci ) then
98056: LD_VAR 0 1
98060: PPUSH
98061: CALL_OW 437
98065: IFFALSE 98113
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98067: LD_VAR 0 1
98071: PPUSH
98072: CALL_OW 437
98076: PUSH
98077: LD_INT 1
98079: ARRAY
98080: PUSH
98081: LD_INT 1
98083: ARRAY
98084: PUSH
98085: LD_STRING l
98087: EQUAL
98088: IFFALSE 98113
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98090: LD_ADDR_VAR 0 2
98094: PUSH
98095: LD_VAR 0 1
98099: PPUSH
98100: CALL_OW 437
98104: PUSH
98105: LD_INT 1
98107: ARRAY
98108: PUSH
98109: LD_INT 4
98111: ARRAY
98112: ST_TO_ADDR
// end ;
98113: LD_VAR 0 2
98117: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98118: LD_INT 0
98120: PPUSH
98121: PPUSH
98122: PPUSH
98123: PPUSH
// if not base_units then
98124: LD_VAR 0 1
98128: NOT
98129: IFFALSE 98133
// exit ;
98131: GO 98220
// result := false ;
98133: LD_ADDR_VAR 0 2
98137: PUSH
98138: LD_INT 0
98140: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98141: LD_ADDR_VAR 0 5
98145: PUSH
98146: LD_VAR 0 1
98150: PPUSH
98151: LD_INT 21
98153: PUSH
98154: LD_INT 3
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: PPUSH
98161: CALL_OW 72
98165: ST_TO_ADDR
// if not tmp then
98166: LD_VAR 0 5
98170: NOT
98171: IFFALSE 98175
// exit ;
98173: GO 98220
// for i in tmp do
98175: LD_ADDR_VAR 0 3
98179: PUSH
98180: LD_VAR 0 5
98184: PUSH
98185: FOR_IN
98186: IFFALSE 98218
// begin result := EnemyInRange ( i , 22 ) ;
98188: LD_ADDR_VAR 0 2
98192: PUSH
98193: LD_VAR 0 3
98197: PPUSH
98198: LD_INT 22
98200: PPUSH
98201: CALL 95833 0 2
98205: ST_TO_ADDR
// if result then
98206: LD_VAR 0 2
98210: IFFALSE 98216
// exit ;
98212: POP
98213: POP
98214: GO 98220
// end ;
98216: GO 98185
98218: POP
98219: POP
// end ;
98220: LD_VAR 0 2
98224: RET
// export function FilterByTag ( units , tag ) ; begin
98225: LD_INT 0
98227: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
98228: LD_ADDR_VAR 0 3
98232: PUSH
98233: LD_VAR 0 1
98237: PPUSH
98238: LD_INT 120
98240: PUSH
98241: LD_VAR 0 2
98245: PUSH
98246: EMPTY
98247: LIST
98248: LIST
98249: PPUSH
98250: CALL_OW 72
98254: ST_TO_ADDR
// end ;
98255: LD_VAR 0 3
98259: RET
// export function IsDriver ( un ) ; begin
98260: LD_INT 0
98262: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98263: LD_ADDR_VAR 0 2
98267: PUSH
98268: LD_VAR 0 1
98272: PUSH
98273: LD_INT 55
98275: PUSH
98276: EMPTY
98277: LIST
98278: PPUSH
98279: CALL_OW 69
98283: IN
98284: ST_TO_ADDR
// end ;
98285: LD_VAR 0 2
98289: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98290: LD_INT 0
98292: PPUSH
98293: PPUSH
// list := [ ] ;
98294: LD_ADDR_VAR 0 5
98298: PUSH
98299: EMPTY
98300: ST_TO_ADDR
// case d of 0 :
98301: LD_VAR 0 3
98305: PUSH
98306: LD_INT 0
98308: DOUBLE
98309: EQUAL
98310: IFTRUE 98314
98312: GO 98447
98314: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98315: LD_ADDR_VAR 0 5
98319: PUSH
98320: LD_VAR 0 1
98324: PUSH
98325: LD_INT 4
98327: MINUS
98328: PUSH
98329: LD_VAR 0 2
98333: PUSH
98334: LD_INT 4
98336: MINUS
98337: PUSH
98338: LD_INT 2
98340: PUSH
98341: EMPTY
98342: LIST
98343: LIST
98344: LIST
98345: PUSH
98346: LD_VAR 0 1
98350: PUSH
98351: LD_INT 3
98353: MINUS
98354: PUSH
98355: LD_VAR 0 2
98359: PUSH
98360: LD_INT 1
98362: PUSH
98363: EMPTY
98364: LIST
98365: LIST
98366: LIST
98367: PUSH
98368: LD_VAR 0 1
98372: PUSH
98373: LD_INT 4
98375: PLUS
98376: PUSH
98377: LD_VAR 0 2
98381: PUSH
98382: LD_INT 4
98384: PUSH
98385: EMPTY
98386: LIST
98387: LIST
98388: LIST
98389: PUSH
98390: LD_VAR 0 1
98394: PUSH
98395: LD_INT 3
98397: PLUS
98398: PUSH
98399: LD_VAR 0 2
98403: PUSH
98404: LD_INT 3
98406: PLUS
98407: PUSH
98408: LD_INT 5
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: LIST
98415: PUSH
98416: LD_VAR 0 1
98420: PUSH
98421: LD_VAR 0 2
98425: PUSH
98426: LD_INT 4
98428: PLUS
98429: PUSH
98430: LD_INT 0
98432: PUSH
98433: EMPTY
98434: LIST
98435: LIST
98436: LIST
98437: PUSH
98438: EMPTY
98439: LIST
98440: LIST
98441: LIST
98442: LIST
98443: LIST
98444: ST_TO_ADDR
// end ; 1 :
98445: GO 99145
98447: LD_INT 1
98449: DOUBLE
98450: EQUAL
98451: IFTRUE 98455
98453: GO 98588
98455: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98456: LD_ADDR_VAR 0 5
98460: PUSH
98461: LD_VAR 0 1
98465: PUSH
98466: LD_VAR 0 2
98470: PUSH
98471: LD_INT 4
98473: MINUS
98474: PUSH
98475: LD_INT 3
98477: PUSH
98478: EMPTY
98479: LIST
98480: LIST
98481: LIST
98482: PUSH
98483: LD_VAR 0 1
98487: PUSH
98488: LD_INT 3
98490: MINUS
98491: PUSH
98492: LD_VAR 0 2
98496: PUSH
98497: LD_INT 3
98499: MINUS
98500: PUSH
98501: LD_INT 2
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: LIST
98508: PUSH
98509: LD_VAR 0 1
98513: PUSH
98514: LD_INT 4
98516: MINUS
98517: PUSH
98518: LD_VAR 0 2
98522: PUSH
98523: LD_INT 1
98525: PUSH
98526: EMPTY
98527: LIST
98528: LIST
98529: LIST
98530: PUSH
98531: LD_VAR 0 1
98535: PUSH
98536: LD_VAR 0 2
98540: PUSH
98541: LD_INT 3
98543: PLUS
98544: PUSH
98545: LD_INT 0
98547: PUSH
98548: EMPTY
98549: LIST
98550: LIST
98551: LIST
98552: PUSH
98553: LD_VAR 0 1
98557: PUSH
98558: LD_INT 4
98560: PLUS
98561: PUSH
98562: LD_VAR 0 2
98566: PUSH
98567: LD_INT 4
98569: PLUS
98570: PUSH
98571: LD_INT 5
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: LIST
98578: PUSH
98579: EMPTY
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: ST_TO_ADDR
// end ; 2 :
98586: GO 99145
98588: LD_INT 2
98590: DOUBLE
98591: EQUAL
98592: IFTRUE 98596
98594: GO 98725
98596: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98597: LD_ADDR_VAR 0 5
98601: PUSH
98602: LD_VAR 0 1
98606: PUSH
98607: LD_VAR 0 2
98611: PUSH
98612: LD_INT 3
98614: MINUS
98615: PUSH
98616: LD_INT 3
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: LIST
98623: PUSH
98624: LD_VAR 0 1
98628: PUSH
98629: LD_INT 4
98631: PLUS
98632: PUSH
98633: LD_VAR 0 2
98637: PUSH
98638: LD_INT 4
98640: PUSH
98641: EMPTY
98642: LIST
98643: LIST
98644: LIST
98645: PUSH
98646: LD_VAR 0 1
98650: PUSH
98651: LD_VAR 0 2
98655: PUSH
98656: LD_INT 4
98658: PLUS
98659: PUSH
98660: LD_INT 0
98662: PUSH
98663: EMPTY
98664: LIST
98665: LIST
98666: LIST
98667: PUSH
98668: LD_VAR 0 1
98672: PUSH
98673: LD_INT 3
98675: MINUS
98676: PUSH
98677: LD_VAR 0 2
98681: PUSH
98682: LD_INT 1
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: LIST
98689: PUSH
98690: LD_VAR 0 1
98694: PUSH
98695: LD_INT 4
98697: MINUS
98698: PUSH
98699: LD_VAR 0 2
98703: PUSH
98704: LD_INT 4
98706: MINUS
98707: PUSH
98708: LD_INT 2
98710: PUSH
98711: EMPTY
98712: LIST
98713: LIST
98714: LIST
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: LIST
98722: ST_TO_ADDR
// end ; 3 :
98723: GO 99145
98725: LD_INT 3
98727: DOUBLE
98728: EQUAL
98729: IFTRUE 98733
98731: GO 98866
98733: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
98734: LD_ADDR_VAR 0 5
98738: PUSH
98739: LD_VAR 0 1
98743: PUSH
98744: LD_INT 3
98746: PLUS
98747: PUSH
98748: LD_VAR 0 2
98752: PUSH
98753: LD_INT 4
98755: PUSH
98756: EMPTY
98757: LIST
98758: LIST
98759: LIST
98760: PUSH
98761: LD_VAR 0 1
98765: PUSH
98766: LD_INT 4
98768: PLUS
98769: PUSH
98770: LD_VAR 0 2
98774: PUSH
98775: LD_INT 4
98777: PLUS
98778: PUSH
98779: LD_INT 5
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: LIST
98786: PUSH
98787: LD_VAR 0 1
98791: PUSH
98792: LD_INT 4
98794: MINUS
98795: PUSH
98796: LD_VAR 0 2
98800: PUSH
98801: LD_INT 1
98803: PUSH
98804: EMPTY
98805: LIST
98806: LIST
98807: LIST
98808: PUSH
98809: LD_VAR 0 1
98813: PUSH
98814: LD_VAR 0 2
98818: PUSH
98819: LD_INT 4
98821: MINUS
98822: PUSH
98823: LD_INT 3
98825: PUSH
98826: EMPTY
98827: LIST
98828: LIST
98829: LIST
98830: PUSH
98831: LD_VAR 0 1
98835: PUSH
98836: LD_INT 3
98838: MINUS
98839: PUSH
98840: LD_VAR 0 2
98844: PUSH
98845: LD_INT 3
98847: MINUS
98848: PUSH
98849: LD_INT 2
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: LIST
98856: PUSH
98857: EMPTY
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: ST_TO_ADDR
// end ; 4 :
98864: GO 99145
98866: LD_INT 4
98868: DOUBLE
98869: EQUAL
98870: IFTRUE 98874
98872: GO 99007
98874: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
98875: LD_ADDR_VAR 0 5
98879: PUSH
98880: LD_VAR 0 1
98884: PUSH
98885: LD_VAR 0 2
98889: PUSH
98890: LD_INT 4
98892: PLUS
98893: PUSH
98894: LD_INT 0
98896: PUSH
98897: EMPTY
98898: LIST
98899: LIST
98900: LIST
98901: PUSH
98902: LD_VAR 0 1
98906: PUSH
98907: LD_INT 3
98909: PLUS
98910: PUSH
98911: LD_VAR 0 2
98915: PUSH
98916: LD_INT 3
98918: PLUS
98919: PUSH
98920: LD_INT 5
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: LIST
98927: PUSH
98928: LD_VAR 0 1
98932: PUSH
98933: LD_INT 4
98935: PLUS
98936: PUSH
98937: LD_VAR 0 2
98941: PUSH
98942: LD_INT 4
98944: PUSH
98945: EMPTY
98946: LIST
98947: LIST
98948: LIST
98949: PUSH
98950: LD_VAR 0 1
98954: PUSH
98955: LD_VAR 0 2
98959: PUSH
98960: LD_INT 3
98962: MINUS
98963: PUSH
98964: LD_INT 3
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: LIST
98971: PUSH
98972: LD_VAR 0 1
98976: PUSH
98977: LD_INT 4
98979: MINUS
98980: PUSH
98981: LD_VAR 0 2
98985: PUSH
98986: LD_INT 4
98988: MINUS
98989: PUSH
98990: LD_INT 2
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: LIST
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: ST_TO_ADDR
// end ; 5 :
99005: GO 99145
99007: LD_INT 5
99009: DOUBLE
99010: EQUAL
99011: IFTRUE 99015
99013: GO 99144
99015: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99016: LD_ADDR_VAR 0 5
99020: PUSH
99021: LD_VAR 0 1
99025: PUSH
99026: LD_INT 4
99028: MINUS
99029: PUSH
99030: LD_VAR 0 2
99034: PUSH
99035: LD_INT 1
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: LIST
99042: PUSH
99043: LD_VAR 0 1
99047: PUSH
99048: LD_VAR 0 2
99052: PUSH
99053: LD_INT 4
99055: MINUS
99056: PUSH
99057: LD_INT 3
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: LIST
99064: PUSH
99065: LD_VAR 0 1
99069: PUSH
99070: LD_INT 4
99072: PLUS
99073: PUSH
99074: LD_VAR 0 2
99078: PUSH
99079: LD_INT 4
99081: PLUS
99082: PUSH
99083: LD_INT 5
99085: PUSH
99086: EMPTY
99087: LIST
99088: LIST
99089: LIST
99090: PUSH
99091: LD_VAR 0 1
99095: PUSH
99096: LD_INT 3
99098: PLUS
99099: PUSH
99100: LD_VAR 0 2
99104: PUSH
99105: LD_INT 4
99107: PUSH
99108: EMPTY
99109: LIST
99110: LIST
99111: LIST
99112: PUSH
99113: LD_VAR 0 1
99117: PUSH
99118: LD_VAR 0 2
99122: PUSH
99123: LD_INT 3
99125: PLUS
99126: PUSH
99127: LD_INT 0
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: LIST
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: LIST
99139: LIST
99140: LIST
99141: ST_TO_ADDR
// end ; end ;
99142: GO 99145
99144: POP
// result := list ;
99145: LD_ADDR_VAR 0 4
99149: PUSH
99150: LD_VAR 0 5
99154: ST_TO_ADDR
// end ;
99155: LD_VAR 0 4
99159: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99160: LD_INT 0
99162: PPUSH
99163: PPUSH
99164: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99165: LD_VAR 0 1
99169: NOT
99170: PUSH
99171: LD_VAR 0 2
99175: PUSH
99176: LD_INT 1
99178: PUSH
99179: LD_INT 2
99181: PUSH
99182: LD_INT 3
99184: PUSH
99185: LD_INT 4
99187: PUSH
99188: EMPTY
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: IN
99194: NOT
99195: OR
99196: IFFALSE 99200
// exit ;
99198: GO 99292
// tmp := [ ] ;
99200: LD_ADDR_VAR 0 5
99204: PUSH
99205: EMPTY
99206: ST_TO_ADDR
// for i in units do
99207: LD_ADDR_VAR 0 4
99211: PUSH
99212: LD_VAR 0 1
99216: PUSH
99217: FOR_IN
99218: IFFALSE 99261
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99220: LD_ADDR_VAR 0 5
99224: PUSH
99225: LD_VAR 0 5
99229: PPUSH
99230: LD_VAR 0 5
99234: PUSH
99235: LD_INT 1
99237: PLUS
99238: PPUSH
99239: LD_VAR 0 4
99243: PPUSH
99244: LD_VAR 0 2
99248: PPUSH
99249: CALL_OW 259
99253: PPUSH
99254: CALL_OW 2
99258: ST_TO_ADDR
99259: GO 99217
99261: POP
99262: POP
// if not tmp then
99263: LD_VAR 0 5
99267: NOT
99268: IFFALSE 99272
// exit ;
99270: GO 99292
// result := SortListByListDesc ( units , tmp ) ;
99272: LD_ADDR_VAR 0 3
99276: PUSH
99277: LD_VAR 0 1
99281: PPUSH
99282: LD_VAR 0 5
99286: PPUSH
99287: CALL_OW 77
99291: ST_TO_ADDR
// end ;
99292: LD_VAR 0 3
99296: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99297: LD_INT 0
99299: PPUSH
99300: PPUSH
99301: PPUSH
// result := false ;
99302: LD_ADDR_VAR 0 3
99306: PUSH
99307: LD_INT 0
99309: ST_TO_ADDR
// x := GetX ( building ) ;
99310: LD_ADDR_VAR 0 4
99314: PUSH
99315: LD_VAR 0 2
99319: PPUSH
99320: CALL_OW 250
99324: ST_TO_ADDR
// y := GetY ( building ) ;
99325: LD_ADDR_VAR 0 5
99329: PUSH
99330: LD_VAR 0 2
99334: PPUSH
99335: CALL_OW 251
99339: ST_TO_ADDR
// if not building or not x or not y then
99340: LD_VAR 0 2
99344: NOT
99345: PUSH
99346: LD_VAR 0 4
99350: NOT
99351: OR
99352: PUSH
99353: LD_VAR 0 5
99357: NOT
99358: OR
99359: IFFALSE 99363
// exit ;
99361: GO 99455
// if GetTaskList ( unit ) then
99363: LD_VAR 0 1
99367: PPUSH
99368: CALL_OW 437
99372: IFFALSE 99455
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99374: LD_STRING e
99376: PUSH
99377: LD_VAR 0 1
99381: PPUSH
99382: CALL_OW 437
99386: PUSH
99387: LD_INT 1
99389: ARRAY
99390: PUSH
99391: LD_INT 1
99393: ARRAY
99394: EQUAL
99395: PUSH
99396: LD_VAR 0 4
99400: PUSH
99401: LD_VAR 0 1
99405: PPUSH
99406: CALL_OW 437
99410: PUSH
99411: LD_INT 1
99413: ARRAY
99414: PUSH
99415: LD_INT 2
99417: ARRAY
99418: EQUAL
99419: AND
99420: PUSH
99421: LD_VAR 0 5
99425: PUSH
99426: LD_VAR 0 1
99430: PPUSH
99431: CALL_OW 437
99435: PUSH
99436: LD_INT 1
99438: ARRAY
99439: PUSH
99440: LD_INT 3
99442: ARRAY
99443: EQUAL
99444: AND
99445: IFFALSE 99455
// result := true end ;
99447: LD_ADDR_VAR 0 3
99451: PUSH
99452: LD_INT 1
99454: ST_TO_ADDR
// end ;
99455: LD_VAR 0 3
99459: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99460: LD_INT 0
99462: PPUSH
// result := false ;
99463: LD_ADDR_VAR 0 4
99467: PUSH
99468: LD_INT 0
99470: ST_TO_ADDR
// if GetTaskList ( unit ) then
99471: LD_VAR 0 1
99475: PPUSH
99476: CALL_OW 437
99480: IFFALSE 99563
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99482: LD_STRING M
99484: PUSH
99485: LD_VAR 0 1
99489: PPUSH
99490: CALL_OW 437
99494: PUSH
99495: LD_INT 1
99497: ARRAY
99498: PUSH
99499: LD_INT 1
99501: ARRAY
99502: EQUAL
99503: PUSH
99504: LD_VAR 0 2
99508: PUSH
99509: LD_VAR 0 1
99513: PPUSH
99514: CALL_OW 437
99518: PUSH
99519: LD_INT 1
99521: ARRAY
99522: PUSH
99523: LD_INT 2
99525: ARRAY
99526: EQUAL
99527: AND
99528: PUSH
99529: LD_VAR 0 3
99533: PUSH
99534: LD_VAR 0 1
99538: PPUSH
99539: CALL_OW 437
99543: PUSH
99544: LD_INT 1
99546: ARRAY
99547: PUSH
99548: LD_INT 3
99550: ARRAY
99551: EQUAL
99552: AND
99553: IFFALSE 99563
// result := true ;
99555: LD_ADDR_VAR 0 4
99559: PUSH
99560: LD_INT 1
99562: ST_TO_ADDR
// end ; end ;
99563: LD_VAR 0 4
99567: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99568: LD_INT 0
99570: PPUSH
99571: PPUSH
99572: PPUSH
99573: PPUSH
// if not unit or not area then
99574: LD_VAR 0 1
99578: NOT
99579: PUSH
99580: LD_VAR 0 2
99584: NOT
99585: OR
99586: IFFALSE 99590
// exit ;
99588: GO 99754
// tmp := AreaToList ( area , i ) ;
99590: LD_ADDR_VAR 0 6
99594: PUSH
99595: LD_VAR 0 2
99599: PPUSH
99600: LD_VAR 0 5
99604: PPUSH
99605: CALL_OW 517
99609: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99610: LD_ADDR_VAR 0 5
99614: PUSH
99615: DOUBLE
99616: LD_INT 1
99618: DEC
99619: ST_TO_ADDR
99620: LD_VAR 0 6
99624: PUSH
99625: LD_INT 1
99627: ARRAY
99628: PUSH
99629: FOR_TO
99630: IFFALSE 99752
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99632: LD_ADDR_VAR 0 7
99636: PUSH
99637: LD_VAR 0 6
99641: PUSH
99642: LD_INT 1
99644: ARRAY
99645: PUSH
99646: LD_VAR 0 5
99650: ARRAY
99651: PUSH
99652: LD_VAR 0 6
99656: PUSH
99657: LD_INT 2
99659: ARRAY
99660: PUSH
99661: LD_VAR 0 5
99665: ARRAY
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99671: LD_VAR 0 7
99675: PUSH
99676: LD_INT 1
99678: ARRAY
99679: PPUSH
99680: LD_VAR 0 7
99684: PUSH
99685: LD_INT 2
99687: ARRAY
99688: PPUSH
99689: CALL_OW 428
99693: PUSH
99694: LD_INT 0
99696: EQUAL
99697: IFFALSE 99750
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99699: LD_VAR 0 1
99703: PPUSH
99704: LD_VAR 0 7
99708: PUSH
99709: LD_INT 1
99711: ARRAY
99712: PPUSH
99713: LD_VAR 0 7
99717: PUSH
99718: LD_INT 2
99720: ARRAY
99721: PPUSH
99722: LD_VAR 0 3
99726: PPUSH
99727: CALL_OW 48
// result := IsPlaced ( unit ) ;
99731: LD_ADDR_VAR 0 4
99735: PUSH
99736: LD_VAR 0 1
99740: PPUSH
99741: CALL_OW 305
99745: ST_TO_ADDR
// exit ;
99746: POP
99747: POP
99748: GO 99754
// end ; end ;
99750: GO 99629
99752: POP
99753: POP
// end ;
99754: LD_VAR 0 4
99758: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99759: LD_INT 0
99761: PPUSH
99762: PPUSH
99763: PPUSH
// if not side or side > 8 then
99764: LD_VAR 0 1
99768: NOT
99769: PUSH
99770: LD_VAR 0 1
99774: PUSH
99775: LD_INT 8
99777: GREATER
99778: OR
99779: IFFALSE 99783
// exit ;
99781: GO 99970
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99783: LD_ADDR_VAR 0 4
99787: PUSH
99788: LD_INT 22
99790: PUSH
99791: LD_VAR 0 1
99795: PUSH
99796: EMPTY
99797: LIST
99798: LIST
99799: PUSH
99800: LD_INT 21
99802: PUSH
99803: LD_INT 3
99805: PUSH
99806: EMPTY
99807: LIST
99808: LIST
99809: PUSH
99810: EMPTY
99811: LIST
99812: LIST
99813: PPUSH
99814: CALL_OW 69
99818: ST_TO_ADDR
// if not tmp then
99819: LD_VAR 0 4
99823: NOT
99824: IFFALSE 99828
// exit ;
99826: GO 99970
// enable_addtolog := true ;
99828: LD_ADDR_OWVAR 81
99832: PUSH
99833: LD_INT 1
99835: ST_TO_ADDR
// AddToLog ( [ ) ;
99836: LD_STRING [
99838: PPUSH
99839: CALL_OW 561
// for i in tmp do
99843: LD_ADDR_VAR 0 3
99847: PUSH
99848: LD_VAR 0 4
99852: PUSH
99853: FOR_IN
99854: IFFALSE 99961
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
99856: LD_STRING [
99858: PUSH
99859: LD_VAR 0 3
99863: PPUSH
99864: CALL_OW 266
99868: STR
99869: PUSH
99870: LD_STRING , 
99872: STR
99873: PUSH
99874: LD_VAR 0 3
99878: PPUSH
99879: CALL_OW 250
99883: STR
99884: PUSH
99885: LD_STRING , 
99887: STR
99888: PUSH
99889: LD_VAR 0 3
99893: PPUSH
99894: CALL_OW 251
99898: STR
99899: PUSH
99900: LD_STRING , 
99902: STR
99903: PUSH
99904: LD_VAR 0 3
99908: PPUSH
99909: CALL_OW 254
99913: STR
99914: PUSH
99915: LD_STRING , 
99917: STR
99918: PUSH
99919: LD_VAR 0 3
99923: PPUSH
99924: LD_INT 1
99926: PPUSH
99927: CALL_OW 268
99931: STR
99932: PUSH
99933: LD_STRING , 
99935: STR
99936: PUSH
99937: LD_VAR 0 3
99941: PPUSH
99942: LD_INT 2
99944: PPUSH
99945: CALL_OW 268
99949: STR
99950: PUSH
99951: LD_STRING ],
99953: STR
99954: PPUSH
99955: CALL_OW 561
// end ;
99959: GO 99853
99961: POP
99962: POP
// AddToLog ( ]; ) ;
99963: LD_STRING ];
99965: PPUSH
99966: CALL_OW 561
// end ;
99970: LD_VAR 0 2
99974: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
99975: LD_INT 0
99977: PPUSH
99978: PPUSH
99979: PPUSH
99980: PPUSH
99981: PPUSH
// if not area or not rate or not max then
99982: LD_VAR 0 1
99986: NOT
99987: PUSH
99988: LD_VAR 0 2
99992: NOT
99993: OR
99994: PUSH
99995: LD_VAR 0 4
99999: NOT
100000: OR
100001: IFFALSE 100005
// exit ;
100003: GO 100194
// while 1 do
100005: LD_INT 1
100007: IFFALSE 100194
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100009: LD_ADDR_VAR 0 9
100013: PUSH
100014: LD_VAR 0 1
100018: PPUSH
100019: LD_INT 1
100021: PPUSH
100022: CALL_OW 287
100026: PUSH
100027: LD_INT 10
100029: MUL
100030: ST_TO_ADDR
// r := rate / 10 ;
100031: LD_ADDR_VAR 0 7
100035: PUSH
100036: LD_VAR 0 2
100040: PUSH
100041: LD_INT 10
100043: DIVREAL
100044: ST_TO_ADDR
// time := 1 1$00 ;
100045: LD_ADDR_VAR 0 8
100049: PUSH
100050: LD_INT 2100
100052: ST_TO_ADDR
// if amount < min then
100053: LD_VAR 0 9
100057: PUSH
100058: LD_VAR 0 3
100062: LESS
100063: IFFALSE 100081
// r := r * 2 else
100065: LD_ADDR_VAR 0 7
100069: PUSH
100070: LD_VAR 0 7
100074: PUSH
100075: LD_INT 2
100077: MUL
100078: ST_TO_ADDR
100079: GO 100107
// if amount > max then
100081: LD_VAR 0 9
100085: PUSH
100086: LD_VAR 0 4
100090: GREATER
100091: IFFALSE 100107
// r := r / 2 ;
100093: LD_ADDR_VAR 0 7
100097: PUSH
100098: LD_VAR 0 7
100102: PUSH
100103: LD_INT 2
100105: DIVREAL
100106: ST_TO_ADDR
// time := time / r ;
100107: LD_ADDR_VAR 0 8
100111: PUSH
100112: LD_VAR 0 8
100116: PUSH
100117: LD_VAR 0 7
100121: DIVREAL
100122: ST_TO_ADDR
// if time < 0 then
100123: LD_VAR 0 8
100127: PUSH
100128: LD_INT 0
100130: LESS
100131: IFFALSE 100148
// time := time * - 1 ;
100133: LD_ADDR_VAR 0 8
100137: PUSH
100138: LD_VAR 0 8
100142: PUSH
100143: LD_INT 1
100145: NEG
100146: MUL
100147: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100148: LD_VAR 0 8
100152: PUSH
100153: LD_INT 35
100155: PPUSH
100156: LD_INT 875
100158: PPUSH
100159: CALL_OW 12
100163: PLUS
100164: PPUSH
100165: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100169: LD_INT 1
100171: PPUSH
100172: LD_INT 5
100174: PPUSH
100175: CALL_OW 12
100179: PPUSH
100180: LD_VAR 0 1
100184: PPUSH
100185: LD_INT 1
100187: PPUSH
100188: CALL_OW 55
// end ;
100192: GO 100005
// end ;
100194: LD_VAR 0 5
100198: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100199: LD_INT 0
100201: PPUSH
100202: PPUSH
100203: PPUSH
100204: PPUSH
100205: PPUSH
100206: PPUSH
100207: PPUSH
100208: PPUSH
// if not turrets or not factories then
100209: LD_VAR 0 1
100213: NOT
100214: PUSH
100215: LD_VAR 0 2
100219: NOT
100220: OR
100221: IFFALSE 100225
// exit ;
100223: GO 100532
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100225: LD_ADDR_VAR 0 10
100229: PUSH
100230: LD_INT 5
100232: PUSH
100233: LD_INT 6
100235: PUSH
100236: EMPTY
100237: LIST
100238: LIST
100239: PUSH
100240: LD_INT 2
100242: PUSH
100243: LD_INT 4
100245: PUSH
100246: EMPTY
100247: LIST
100248: LIST
100249: PUSH
100250: LD_INT 3
100252: PUSH
100253: LD_INT 5
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: PUSH
100260: EMPTY
100261: LIST
100262: LIST
100263: LIST
100264: PUSH
100265: LD_INT 24
100267: PUSH
100268: LD_INT 25
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: PUSH
100275: LD_INT 23
100277: PUSH
100278: LD_INT 27
100280: PUSH
100281: EMPTY
100282: LIST
100283: LIST
100284: PUSH
100285: EMPTY
100286: LIST
100287: LIST
100288: PUSH
100289: LD_INT 42
100291: PUSH
100292: LD_INT 43
100294: PUSH
100295: EMPTY
100296: LIST
100297: LIST
100298: PUSH
100299: LD_INT 44
100301: PUSH
100302: LD_INT 46
100304: PUSH
100305: EMPTY
100306: LIST
100307: LIST
100308: PUSH
100309: LD_INT 45
100311: PUSH
100312: LD_INT 47
100314: PUSH
100315: EMPTY
100316: LIST
100317: LIST
100318: PUSH
100319: EMPTY
100320: LIST
100321: LIST
100322: LIST
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: LIST
100328: ST_TO_ADDR
// result := [ ] ;
100329: LD_ADDR_VAR 0 3
100333: PUSH
100334: EMPTY
100335: ST_TO_ADDR
// for i in turrets do
100336: LD_ADDR_VAR 0 4
100340: PUSH
100341: LD_VAR 0 1
100345: PUSH
100346: FOR_IN
100347: IFFALSE 100530
// begin nat := GetNation ( i ) ;
100349: LD_ADDR_VAR 0 7
100353: PUSH
100354: LD_VAR 0 4
100358: PPUSH
100359: CALL_OW 248
100363: ST_TO_ADDR
// weapon := 0 ;
100364: LD_ADDR_VAR 0 8
100368: PUSH
100369: LD_INT 0
100371: ST_TO_ADDR
// if not nat then
100372: LD_VAR 0 7
100376: NOT
100377: IFFALSE 100381
// continue ;
100379: GO 100346
// for j in list [ nat ] do
100381: LD_ADDR_VAR 0 5
100385: PUSH
100386: LD_VAR 0 10
100390: PUSH
100391: LD_VAR 0 7
100395: ARRAY
100396: PUSH
100397: FOR_IN
100398: IFFALSE 100439
// if GetBWeapon ( i ) = j [ 1 ] then
100400: LD_VAR 0 4
100404: PPUSH
100405: CALL_OW 269
100409: PUSH
100410: LD_VAR 0 5
100414: PUSH
100415: LD_INT 1
100417: ARRAY
100418: EQUAL
100419: IFFALSE 100437
// begin weapon := j [ 2 ] ;
100421: LD_ADDR_VAR 0 8
100425: PUSH
100426: LD_VAR 0 5
100430: PUSH
100431: LD_INT 2
100433: ARRAY
100434: ST_TO_ADDR
// break ;
100435: GO 100439
// end ;
100437: GO 100397
100439: POP
100440: POP
// if not weapon then
100441: LD_VAR 0 8
100445: NOT
100446: IFFALSE 100450
// continue ;
100448: GO 100346
// for k in factories do
100450: LD_ADDR_VAR 0 6
100454: PUSH
100455: LD_VAR 0 2
100459: PUSH
100460: FOR_IN
100461: IFFALSE 100526
// begin weapons := AvailableWeaponList ( k ) ;
100463: LD_ADDR_VAR 0 9
100467: PUSH
100468: LD_VAR 0 6
100472: PPUSH
100473: CALL_OW 478
100477: ST_TO_ADDR
// if not weapons then
100478: LD_VAR 0 9
100482: NOT
100483: IFFALSE 100487
// continue ;
100485: GO 100460
// if weapon in weapons then
100487: LD_VAR 0 8
100491: PUSH
100492: LD_VAR 0 9
100496: IN
100497: IFFALSE 100524
// begin result := [ i , weapon ] ;
100499: LD_ADDR_VAR 0 3
100503: PUSH
100504: LD_VAR 0 4
100508: PUSH
100509: LD_VAR 0 8
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: ST_TO_ADDR
// exit ;
100518: POP
100519: POP
100520: POP
100521: POP
100522: GO 100532
// end ; end ;
100524: GO 100460
100526: POP
100527: POP
// end ;
100528: GO 100346
100530: POP
100531: POP
// end ;
100532: LD_VAR 0 3
100536: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100537: LD_INT 0
100539: PPUSH
// if not side or side > 8 then
100540: LD_VAR 0 3
100544: NOT
100545: PUSH
100546: LD_VAR 0 3
100550: PUSH
100551: LD_INT 8
100553: GREATER
100554: OR
100555: IFFALSE 100559
// exit ;
100557: GO 100618
// if not range then
100559: LD_VAR 0 4
100563: NOT
100564: IFFALSE 100575
// range := - 12 ;
100566: LD_ADDR_VAR 0 4
100570: PUSH
100571: LD_INT 12
100573: NEG
100574: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100575: LD_VAR 0 1
100579: PPUSH
100580: LD_VAR 0 2
100584: PPUSH
100585: LD_VAR 0 3
100589: PPUSH
100590: LD_VAR 0 4
100594: PPUSH
100595: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100599: LD_VAR 0 1
100603: PPUSH
100604: LD_VAR 0 2
100608: PPUSH
100609: LD_VAR 0 3
100613: PPUSH
100614: CALL_OW 331
// end ;
100618: LD_VAR 0 5
100622: RET
// export function Video ( mode ) ; begin
100623: LD_INT 0
100625: PPUSH
// ingame_video = mode ;
100626: LD_ADDR_OWVAR 52
100630: PUSH
100631: LD_VAR 0 1
100635: ST_TO_ADDR
// interface_hidden = mode ;
100636: LD_ADDR_OWVAR 54
100640: PUSH
100641: LD_VAR 0 1
100645: ST_TO_ADDR
// end ;
100646: LD_VAR 0 2
100650: RET
// export function Join ( array , element ) ; begin
100651: LD_INT 0
100653: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100654: LD_ADDR_VAR 0 3
100658: PUSH
100659: LD_VAR 0 1
100663: PPUSH
100664: LD_VAR 0 1
100668: PUSH
100669: LD_INT 1
100671: PLUS
100672: PPUSH
100673: LD_VAR 0 2
100677: PPUSH
100678: CALL_OW 1
100682: ST_TO_ADDR
// end ;
100683: LD_VAR 0 3
100687: RET
// export function JoinUnion ( array , element ) ; begin
100688: LD_INT 0
100690: PPUSH
// result := array union element ;
100691: LD_ADDR_VAR 0 3
100695: PUSH
100696: LD_VAR 0 1
100700: PUSH
100701: LD_VAR 0 2
100705: UNION
100706: ST_TO_ADDR
// end ;
100707: LD_VAR 0 3
100711: RET
// export function GetBehemoths ( side ) ; begin
100712: LD_INT 0
100714: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
100715: LD_ADDR_VAR 0 2
100719: PUSH
100720: LD_INT 22
100722: PUSH
100723: LD_VAR 0 1
100727: PUSH
100728: EMPTY
100729: LIST
100730: LIST
100731: PUSH
100732: LD_INT 31
100734: PUSH
100735: LD_INT 25
100737: PUSH
100738: EMPTY
100739: LIST
100740: LIST
100741: PUSH
100742: EMPTY
100743: LIST
100744: LIST
100745: PPUSH
100746: CALL_OW 69
100750: ST_TO_ADDR
// end ;
100751: LD_VAR 0 2
100755: RET
// export function Shuffle ( array ) ; var i , index ; begin
100756: LD_INT 0
100758: PPUSH
100759: PPUSH
100760: PPUSH
// result := [ ] ;
100761: LD_ADDR_VAR 0 2
100765: PUSH
100766: EMPTY
100767: ST_TO_ADDR
// if not array then
100768: LD_VAR 0 1
100772: NOT
100773: IFFALSE 100777
// exit ;
100775: GO 100876
// Randomize ;
100777: CALL_OW 10
// for i = array downto 1 do
100781: LD_ADDR_VAR 0 3
100785: PUSH
100786: DOUBLE
100787: LD_VAR 0 1
100791: INC
100792: ST_TO_ADDR
100793: LD_INT 1
100795: PUSH
100796: FOR_DOWNTO
100797: IFFALSE 100874
// begin index := rand ( 1 , array ) ;
100799: LD_ADDR_VAR 0 4
100803: PUSH
100804: LD_INT 1
100806: PPUSH
100807: LD_VAR 0 1
100811: PPUSH
100812: CALL_OW 12
100816: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
100817: LD_ADDR_VAR 0 2
100821: PUSH
100822: LD_VAR 0 2
100826: PPUSH
100827: LD_VAR 0 2
100831: PUSH
100832: LD_INT 1
100834: PLUS
100835: PPUSH
100836: LD_VAR 0 1
100840: PUSH
100841: LD_VAR 0 4
100845: ARRAY
100846: PPUSH
100847: CALL_OW 2
100851: ST_TO_ADDR
// array := Delete ( array , index ) ;
100852: LD_ADDR_VAR 0 1
100856: PUSH
100857: LD_VAR 0 1
100861: PPUSH
100862: LD_VAR 0 4
100866: PPUSH
100867: CALL_OW 3
100871: ST_TO_ADDR
// end ;
100872: GO 100796
100874: POP
100875: POP
// end ;
100876: LD_VAR 0 2
100880: RET
// export function GetBaseMaterials ( base ) ; begin
100881: LD_INT 0
100883: PPUSH
// result := [ 0 , 0 , 0 ] ;
100884: LD_ADDR_VAR 0 2
100888: PUSH
100889: LD_INT 0
100891: PUSH
100892: LD_INT 0
100894: PUSH
100895: LD_INT 0
100897: PUSH
100898: EMPTY
100899: LIST
100900: LIST
100901: LIST
100902: ST_TO_ADDR
// if not base then
100903: LD_VAR 0 1
100907: NOT
100908: IFFALSE 100912
// exit ;
100910: GO 100961
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
100912: LD_ADDR_VAR 0 2
100916: PUSH
100917: LD_VAR 0 1
100921: PPUSH
100922: LD_INT 1
100924: PPUSH
100925: CALL_OW 275
100929: PUSH
100930: LD_VAR 0 1
100934: PPUSH
100935: LD_INT 2
100937: PPUSH
100938: CALL_OW 275
100942: PUSH
100943: LD_VAR 0 1
100947: PPUSH
100948: LD_INT 3
100950: PPUSH
100951: CALL_OW 275
100955: PUSH
100956: EMPTY
100957: LIST
100958: LIST
100959: LIST
100960: ST_TO_ADDR
// end ;
100961: LD_VAR 0 2
100965: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
100966: LD_INT 0
100968: PPUSH
100969: PPUSH
// result := array ;
100970: LD_ADDR_VAR 0 3
100974: PUSH
100975: LD_VAR 0 1
100979: ST_TO_ADDR
// if size >= result then
100980: LD_VAR 0 2
100984: PUSH
100985: LD_VAR 0 3
100989: GREATEREQUAL
100990: IFFALSE 100994
// exit ;
100992: GO 101044
// if size then
100994: LD_VAR 0 2
100998: IFFALSE 101044
// for i := array downto size do
101000: LD_ADDR_VAR 0 4
101004: PUSH
101005: DOUBLE
101006: LD_VAR 0 1
101010: INC
101011: ST_TO_ADDR
101012: LD_VAR 0 2
101016: PUSH
101017: FOR_DOWNTO
101018: IFFALSE 101042
// result := Delete ( result , result ) ;
101020: LD_ADDR_VAR 0 3
101024: PUSH
101025: LD_VAR 0 3
101029: PPUSH
101030: LD_VAR 0 3
101034: PPUSH
101035: CALL_OW 3
101039: ST_TO_ADDR
101040: GO 101017
101042: POP
101043: POP
// end ;
101044: LD_VAR 0 3
101048: RET
// export function ComExit ( unit ) ; var tmp ; begin
101049: LD_INT 0
101051: PPUSH
101052: PPUSH
// if not IsInUnit ( unit ) then
101053: LD_VAR 0 1
101057: PPUSH
101058: CALL_OW 310
101062: NOT
101063: IFFALSE 101067
// exit ;
101065: GO 101127
// tmp := IsInUnit ( unit ) ;
101067: LD_ADDR_VAR 0 3
101071: PUSH
101072: LD_VAR 0 1
101076: PPUSH
101077: CALL_OW 310
101081: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101082: LD_VAR 0 3
101086: PPUSH
101087: CALL_OW 247
101091: PUSH
101092: LD_INT 2
101094: EQUAL
101095: IFFALSE 101108
// ComExitVehicle ( unit ) else
101097: LD_VAR 0 1
101101: PPUSH
101102: CALL_OW 121
101106: GO 101117
// ComExitBuilding ( unit ) ;
101108: LD_VAR 0 1
101112: PPUSH
101113: CALL_OW 122
// result := tmp ;
101117: LD_ADDR_VAR 0 2
101121: PUSH
101122: LD_VAR 0 3
101126: ST_TO_ADDR
// end ;
101127: LD_VAR 0 2
101131: RET
// export function ComExitAll ( units ) ; var i ; begin
101132: LD_INT 0
101134: PPUSH
101135: PPUSH
// if not units then
101136: LD_VAR 0 1
101140: NOT
101141: IFFALSE 101145
// exit ;
101143: GO 101171
// for i in units do
101145: LD_ADDR_VAR 0 3
101149: PUSH
101150: LD_VAR 0 1
101154: PUSH
101155: FOR_IN
101156: IFFALSE 101169
// ComExit ( i ) ;
101158: LD_VAR 0 3
101162: PPUSH
101163: CALL 101049 0 1
101167: GO 101155
101169: POP
101170: POP
// end ;
101171: LD_VAR 0 2
101175: RET
// export function ResetHc ; begin
101176: LD_INT 0
101178: PPUSH
// InitHc ;
101179: CALL_OW 19
// hc_importance := 0 ;
101183: LD_ADDR_OWVAR 32
101187: PUSH
101188: LD_INT 0
101190: ST_TO_ADDR
// end ;
101191: LD_VAR 0 1
101195: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101196: LD_INT 0
101198: PPUSH
101199: PPUSH
101200: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101201: LD_ADDR_VAR 0 6
101205: PUSH
101206: LD_VAR 0 1
101210: PUSH
101211: LD_VAR 0 3
101215: PLUS
101216: PUSH
101217: LD_INT 2
101219: DIV
101220: ST_TO_ADDR
// if _x < 0 then
101221: LD_VAR 0 6
101225: PUSH
101226: LD_INT 0
101228: LESS
101229: IFFALSE 101246
// _x := _x * - 1 ;
101231: LD_ADDR_VAR 0 6
101235: PUSH
101236: LD_VAR 0 6
101240: PUSH
101241: LD_INT 1
101243: NEG
101244: MUL
101245: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101246: LD_ADDR_VAR 0 7
101250: PUSH
101251: LD_VAR 0 2
101255: PUSH
101256: LD_VAR 0 4
101260: PLUS
101261: PUSH
101262: LD_INT 2
101264: DIV
101265: ST_TO_ADDR
// if _y < 0 then
101266: LD_VAR 0 7
101270: PUSH
101271: LD_INT 0
101273: LESS
101274: IFFALSE 101291
// _y := _y * - 1 ;
101276: LD_ADDR_VAR 0 7
101280: PUSH
101281: LD_VAR 0 7
101285: PUSH
101286: LD_INT 1
101288: NEG
101289: MUL
101290: ST_TO_ADDR
// result := [ _x , _y ] ;
101291: LD_ADDR_VAR 0 5
101295: PUSH
101296: LD_VAR 0 6
101300: PUSH
101301: LD_VAR 0 7
101305: PUSH
101306: EMPTY
101307: LIST
101308: LIST
101309: ST_TO_ADDR
// end ;
101310: LD_VAR 0 5
101314: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101315: LD_INT 0
101317: PPUSH
101318: PPUSH
101319: PPUSH
101320: PPUSH
// task := GetTaskList ( unit ) ;
101321: LD_ADDR_VAR 0 7
101325: PUSH
101326: LD_VAR 0 1
101330: PPUSH
101331: CALL_OW 437
101335: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101336: LD_VAR 0 7
101340: NOT
101341: PUSH
101342: LD_VAR 0 1
101346: PPUSH
101347: LD_VAR 0 2
101351: PPUSH
101352: CALL_OW 308
101356: NOT
101357: AND
101358: IFFALSE 101362
// exit ;
101360: GO 101480
// if IsInArea ( unit , area ) then
101362: LD_VAR 0 1
101366: PPUSH
101367: LD_VAR 0 2
101371: PPUSH
101372: CALL_OW 308
101376: IFFALSE 101394
// begin ComMoveToArea ( unit , goAway ) ;
101378: LD_VAR 0 1
101382: PPUSH
101383: LD_VAR 0 3
101387: PPUSH
101388: CALL_OW 113
// exit ;
101392: GO 101480
// end ; if task [ 1 ] [ 1 ] <> M then
101394: LD_VAR 0 7
101398: PUSH
101399: LD_INT 1
101401: ARRAY
101402: PUSH
101403: LD_INT 1
101405: ARRAY
101406: PUSH
101407: LD_STRING M
101409: NONEQUAL
101410: IFFALSE 101414
// exit ;
101412: GO 101480
// x := task [ 1 ] [ 2 ] ;
101414: LD_ADDR_VAR 0 5
101418: PUSH
101419: LD_VAR 0 7
101423: PUSH
101424: LD_INT 1
101426: ARRAY
101427: PUSH
101428: LD_INT 2
101430: ARRAY
101431: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101432: LD_ADDR_VAR 0 6
101436: PUSH
101437: LD_VAR 0 7
101441: PUSH
101442: LD_INT 1
101444: ARRAY
101445: PUSH
101446: LD_INT 3
101448: ARRAY
101449: ST_TO_ADDR
// if InArea ( x , y , area ) then
101450: LD_VAR 0 5
101454: PPUSH
101455: LD_VAR 0 6
101459: PPUSH
101460: LD_VAR 0 2
101464: PPUSH
101465: CALL_OW 309
101469: IFFALSE 101480
// ComStop ( unit ) ;
101471: LD_VAR 0 1
101475: PPUSH
101476: CALL_OW 141
// end ;
101480: LD_VAR 0 4
101484: RET
// export function Abs ( value ) ; begin
101485: LD_INT 0
101487: PPUSH
// result := value ;
101488: LD_ADDR_VAR 0 2
101492: PUSH
101493: LD_VAR 0 1
101497: ST_TO_ADDR
// if value < 0 then
101498: LD_VAR 0 1
101502: PUSH
101503: LD_INT 0
101505: LESS
101506: IFFALSE 101523
// result := value * - 1 ;
101508: LD_ADDR_VAR 0 2
101512: PUSH
101513: LD_VAR 0 1
101517: PUSH
101518: LD_INT 1
101520: NEG
101521: MUL
101522: ST_TO_ADDR
// end ;
101523: LD_VAR 0 2
101527: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101528: LD_INT 0
101530: PPUSH
101531: PPUSH
101532: PPUSH
101533: PPUSH
101534: PPUSH
101535: PPUSH
101536: PPUSH
101537: PPUSH
// if not unit or not building then
101538: LD_VAR 0 1
101542: NOT
101543: PUSH
101544: LD_VAR 0 2
101548: NOT
101549: OR
101550: IFFALSE 101554
// exit ;
101552: GO 101780
// x := GetX ( building ) ;
101554: LD_ADDR_VAR 0 4
101558: PUSH
101559: LD_VAR 0 2
101563: PPUSH
101564: CALL_OW 250
101568: ST_TO_ADDR
// y := GetY ( building ) ;
101569: LD_ADDR_VAR 0 6
101573: PUSH
101574: LD_VAR 0 2
101578: PPUSH
101579: CALL_OW 251
101583: ST_TO_ADDR
// d := GetDir ( building ) ;
101584: LD_ADDR_VAR 0 8
101588: PUSH
101589: LD_VAR 0 2
101593: PPUSH
101594: CALL_OW 254
101598: ST_TO_ADDR
// r := 4 ;
101599: LD_ADDR_VAR 0 9
101603: PUSH
101604: LD_INT 4
101606: ST_TO_ADDR
// for i := 1 to 5 do
101607: LD_ADDR_VAR 0 10
101611: PUSH
101612: DOUBLE
101613: LD_INT 1
101615: DEC
101616: ST_TO_ADDR
101617: LD_INT 5
101619: PUSH
101620: FOR_TO
101621: IFFALSE 101778
// begin _x := ShiftX ( x , d , r + i ) ;
101623: LD_ADDR_VAR 0 5
101627: PUSH
101628: LD_VAR 0 4
101632: PPUSH
101633: LD_VAR 0 8
101637: PPUSH
101638: LD_VAR 0 9
101642: PUSH
101643: LD_VAR 0 10
101647: PLUS
101648: PPUSH
101649: CALL_OW 272
101653: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
101654: LD_ADDR_VAR 0 7
101658: PUSH
101659: LD_VAR 0 6
101663: PPUSH
101664: LD_VAR 0 8
101668: PPUSH
101669: LD_VAR 0 9
101673: PUSH
101674: LD_VAR 0 10
101678: PLUS
101679: PPUSH
101680: CALL_OW 273
101684: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
101685: LD_VAR 0 5
101689: PPUSH
101690: LD_VAR 0 7
101694: PPUSH
101695: CALL_OW 488
101699: PUSH
101700: LD_VAR 0 5
101704: PPUSH
101705: LD_VAR 0 7
101709: PPUSH
101710: CALL_OW 428
101714: PPUSH
101715: CALL_OW 247
101719: PUSH
101720: LD_INT 3
101722: PUSH
101723: LD_INT 2
101725: PUSH
101726: EMPTY
101727: LIST
101728: LIST
101729: IN
101730: NOT
101731: AND
101732: IFFALSE 101776
// begin ComMoveXY ( unit , _x , _y ) ;
101734: LD_VAR 0 1
101738: PPUSH
101739: LD_VAR 0 5
101743: PPUSH
101744: LD_VAR 0 7
101748: PPUSH
101749: CALL_OW 111
// result := [ _x , _y ] ;
101753: LD_ADDR_VAR 0 3
101757: PUSH
101758: LD_VAR 0 5
101762: PUSH
101763: LD_VAR 0 7
101767: PUSH
101768: EMPTY
101769: LIST
101770: LIST
101771: ST_TO_ADDR
// exit ;
101772: POP
101773: POP
101774: GO 101780
// end ; end ;
101776: GO 101620
101778: POP
101779: POP
// end ;
101780: LD_VAR 0 3
101784: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
101785: LD_INT 0
101787: PPUSH
101788: PPUSH
101789: PPUSH
// result := 0 ;
101790: LD_ADDR_VAR 0 3
101794: PUSH
101795: LD_INT 0
101797: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
101798: LD_VAR 0 1
101802: PUSH
101803: LD_INT 0
101805: LESS
101806: PUSH
101807: LD_VAR 0 1
101811: PUSH
101812: LD_INT 8
101814: GREATER
101815: OR
101816: PUSH
101817: LD_VAR 0 2
101821: PUSH
101822: LD_INT 0
101824: LESS
101825: OR
101826: PUSH
101827: LD_VAR 0 2
101831: PUSH
101832: LD_INT 8
101834: GREATER
101835: OR
101836: IFFALSE 101840
// exit ;
101838: GO 101915
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
101840: LD_ADDR_VAR 0 4
101844: PUSH
101845: LD_INT 22
101847: PUSH
101848: LD_VAR 0 2
101852: PUSH
101853: EMPTY
101854: LIST
101855: LIST
101856: PPUSH
101857: CALL_OW 69
101861: PUSH
101862: FOR_IN
101863: IFFALSE 101913
// begin un := UnitShoot ( i ) ;
101865: LD_ADDR_VAR 0 5
101869: PUSH
101870: LD_VAR 0 4
101874: PPUSH
101875: CALL_OW 504
101879: ST_TO_ADDR
// if GetSide ( un ) = side1 then
101880: LD_VAR 0 5
101884: PPUSH
101885: CALL_OW 255
101889: PUSH
101890: LD_VAR 0 1
101894: EQUAL
101895: IFFALSE 101911
// begin result := un ;
101897: LD_ADDR_VAR 0 3
101901: PUSH
101902: LD_VAR 0 5
101906: ST_TO_ADDR
// exit ;
101907: POP
101908: POP
101909: GO 101915
// end ; end ;
101911: GO 101862
101913: POP
101914: POP
// end ;
101915: LD_VAR 0 3
101919: RET
// export function GetCargoBay ( units ) ; begin
101920: LD_INT 0
101922: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
101923: LD_ADDR_VAR 0 2
101927: PUSH
101928: LD_VAR 0 1
101932: PPUSH
101933: LD_INT 2
101935: PUSH
101936: LD_INT 34
101938: PUSH
101939: LD_INT 12
101941: PUSH
101942: EMPTY
101943: LIST
101944: LIST
101945: PUSH
101946: LD_INT 34
101948: PUSH
101949: LD_INT 51
101951: PUSH
101952: EMPTY
101953: LIST
101954: LIST
101955: PUSH
101956: LD_INT 34
101958: PUSH
101959: LD_INT 32
101961: PUSH
101962: EMPTY
101963: LIST
101964: LIST
101965: PUSH
101966: LD_INT 34
101968: PUSH
101969: LD_INT 89
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: PUSH
101976: EMPTY
101977: LIST
101978: LIST
101979: LIST
101980: LIST
101981: LIST
101982: PPUSH
101983: CALL_OW 72
101987: ST_TO_ADDR
// end ;
101988: LD_VAR 0 2
101992: RET
// export function Negate ( value ) ; begin
101993: LD_INT 0
101995: PPUSH
// result := not value ;
101996: LD_ADDR_VAR 0 2
102000: PUSH
102001: LD_VAR 0 1
102005: NOT
102006: ST_TO_ADDR
// end ;
102007: LD_VAR 0 2
102011: RET
// export function Inc ( value ) ; begin
102012: LD_INT 0
102014: PPUSH
// result := value + 1 ;
102015: LD_ADDR_VAR 0 2
102019: PUSH
102020: LD_VAR 0 1
102024: PUSH
102025: LD_INT 1
102027: PLUS
102028: ST_TO_ADDR
// end ;
102029: LD_VAR 0 2
102033: RET
// export function Dec ( value ) ; begin
102034: LD_INT 0
102036: PPUSH
// result := value - 1 ;
102037: LD_ADDR_VAR 0 2
102041: PUSH
102042: LD_VAR 0 1
102046: PUSH
102047: LD_INT 1
102049: MINUS
102050: ST_TO_ADDR
// end ;
102051: LD_VAR 0 2
102055: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
102056: LD_INT 0
102058: PPUSH
102059: PPUSH
102060: PPUSH
102061: PPUSH
102062: PPUSH
102063: PPUSH
102064: PPUSH
102065: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102066: LD_VAR 0 1
102070: PPUSH
102071: LD_VAR 0 2
102075: PPUSH
102076: CALL_OW 488
102080: NOT
102081: PUSH
102082: LD_VAR 0 3
102086: PPUSH
102087: LD_VAR 0 4
102091: PPUSH
102092: CALL_OW 488
102096: NOT
102097: OR
102098: IFFALSE 102111
// begin result := - 1 ;
102100: LD_ADDR_VAR 0 5
102104: PUSH
102105: LD_INT 1
102107: NEG
102108: ST_TO_ADDR
// exit ;
102109: GO 102346
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102111: LD_ADDR_VAR 0 12
102115: PUSH
102116: LD_VAR 0 1
102120: PPUSH
102121: LD_VAR 0 2
102125: PPUSH
102126: LD_VAR 0 3
102130: PPUSH
102131: LD_VAR 0 4
102135: PPUSH
102136: CALL 101196 0 4
102140: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102141: LD_ADDR_VAR 0 11
102145: PUSH
102146: LD_VAR 0 1
102150: PPUSH
102151: LD_VAR 0 2
102155: PPUSH
102156: LD_VAR 0 12
102160: PUSH
102161: LD_INT 1
102163: ARRAY
102164: PPUSH
102165: LD_VAR 0 12
102169: PUSH
102170: LD_INT 2
102172: ARRAY
102173: PPUSH
102174: CALL_OW 298
102178: ST_TO_ADDR
// distance := 9999 ;
102179: LD_ADDR_VAR 0 10
102183: PUSH
102184: LD_INT 9999
102186: ST_TO_ADDR
// for i := 0 to 5 do
102187: LD_ADDR_VAR 0 6
102191: PUSH
102192: DOUBLE
102193: LD_INT 0
102195: DEC
102196: ST_TO_ADDR
102197: LD_INT 5
102199: PUSH
102200: FOR_TO
102201: IFFALSE 102344
// begin _x := ShiftX ( x1 , i , centerDist ) ;
102203: LD_ADDR_VAR 0 7
102207: PUSH
102208: LD_VAR 0 1
102212: PPUSH
102213: LD_VAR 0 6
102217: PPUSH
102218: LD_VAR 0 11
102222: PPUSH
102223: CALL_OW 272
102227: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
102228: LD_ADDR_VAR 0 8
102232: PUSH
102233: LD_VAR 0 2
102237: PPUSH
102238: LD_VAR 0 6
102242: PPUSH
102243: LD_VAR 0 11
102247: PPUSH
102248: CALL_OW 273
102252: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102253: LD_VAR 0 7
102257: PPUSH
102258: LD_VAR 0 8
102262: PPUSH
102263: CALL_OW 488
102267: NOT
102268: IFFALSE 102272
// continue ;
102270: GO 102200
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
102272: LD_ADDR_VAR 0 9
102276: PUSH
102277: LD_VAR 0 12
102281: PUSH
102282: LD_INT 1
102284: ARRAY
102285: PPUSH
102286: LD_VAR 0 12
102290: PUSH
102291: LD_INT 2
102293: ARRAY
102294: PPUSH
102295: LD_VAR 0 7
102299: PPUSH
102300: LD_VAR 0 8
102304: PPUSH
102305: CALL_OW 298
102309: ST_TO_ADDR
// if tmp < distance then
102310: LD_VAR 0 9
102314: PUSH
102315: LD_VAR 0 10
102319: LESS
102320: IFFALSE 102342
// begin result := i ;
102322: LD_ADDR_VAR 0 5
102326: PUSH
102327: LD_VAR 0 6
102331: ST_TO_ADDR
// distance := tmp ;
102332: LD_ADDR_VAR 0 10
102336: PUSH
102337: LD_VAR 0 9
102341: ST_TO_ADDR
// end ; end ;
102342: GO 102200
102344: POP
102345: POP
// end ;
102346: LD_VAR 0 5
102350: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102351: LD_INT 0
102353: PPUSH
102354: PPUSH
// if not driver or not IsInUnit ( driver ) then
102355: LD_VAR 0 1
102359: NOT
102360: PUSH
102361: LD_VAR 0 1
102365: PPUSH
102366: CALL_OW 310
102370: NOT
102371: OR
102372: IFFALSE 102376
// exit ;
102374: GO 102466
// vehicle := IsInUnit ( driver ) ;
102376: LD_ADDR_VAR 0 3
102380: PUSH
102381: LD_VAR 0 1
102385: PPUSH
102386: CALL_OW 310
102390: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102391: LD_VAR 0 1
102395: PPUSH
102396: LD_STRING \
102398: PUSH
102399: LD_INT 0
102401: PUSH
102402: LD_INT 0
102404: PUSH
102405: LD_INT 0
102407: PUSH
102408: LD_INT 0
102410: PUSH
102411: LD_INT 0
102413: PUSH
102414: LD_INT 0
102416: PUSH
102417: EMPTY
102418: LIST
102419: LIST
102420: LIST
102421: LIST
102422: LIST
102423: LIST
102424: LIST
102425: PUSH
102426: LD_STRING E
102428: PUSH
102429: LD_INT 0
102431: PUSH
102432: LD_INT 0
102434: PUSH
102435: LD_VAR 0 3
102439: PUSH
102440: LD_INT 0
102442: PUSH
102443: LD_INT 0
102445: PUSH
102446: LD_INT 0
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: LIST
102453: LIST
102454: LIST
102455: LIST
102456: LIST
102457: PUSH
102458: EMPTY
102459: LIST
102460: LIST
102461: PPUSH
102462: CALL_OW 446
// end ;
102466: LD_VAR 0 2
102470: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102471: LD_INT 0
102473: PPUSH
102474: PPUSH
// if not driver or not IsInUnit ( driver ) then
102475: LD_VAR 0 1
102479: NOT
102480: PUSH
102481: LD_VAR 0 1
102485: PPUSH
102486: CALL_OW 310
102490: NOT
102491: OR
102492: IFFALSE 102496
// exit ;
102494: GO 102586
// vehicle := IsInUnit ( driver ) ;
102496: LD_ADDR_VAR 0 3
102500: PUSH
102501: LD_VAR 0 1
102505: PPUSH
102506: CALL_OW 310
102510: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102511: LD_VAR 0 1
102515: PPUSH
102516: LD_STRING \
102518: PUSH
102519: LD_INT 0
102521: PUSH
102522: LD_INT 0
102524: PUSH
102525: LD_INT 0
102527: PUSH
102528: LD_INT 0
102530: PUSH
102531: LD_INT 0
102533: PUSH
102534: LD_INT 0
102536: PUSH
102537: EMPTY
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: LIST
102544: LIST
102545: PUSH
102546: LD_STRING E
102548: PUSH
102549: LD_INT 0
102551: PUSH
102552: LD_INT 0
102554: PUSH
102555: LD_VAR 0 3
102559: PUSH
102560: LD_INT 0
102562: PUSH
102563: LD_INT 0
102565: PUSH
102566: LD_INT 0
102568: PUSH
102569: EMPTY
102570: LIST
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: PUSH
102578: EMPTY
102579: LIST
102580: LIST
102581: PPUSH
102582: CALL_OW 447
// end ;
102586: LD_VAR 0 2
102590: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
102591: LD_INT 0
102593: PPUSH
102594: PPUSH
102595: PPUSH
// tmp := [ ] ;
102596: LD_ADDR_VAR 0 5
102600: PUSH
102601: EMPTY
102602: ST_TO_ADDR
// for i in units do
102603: LD_ADDR_VAR 0 4
102607: PUSH
102608: LD_VAR 0 1
102612: PUSH
102613: FOR_IN
102614: IFFALSE 102652
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
102616: LD_ADDR_VAR 0 5
102620: PUSH
102621: LD_VAR 0 5
102625: PPUSH
102626: LD_VAR 0 5
102630: PUSH
102631: LD_INT 1
102633: PLUS
102634: PPUSH
102635: LD_VAR 0 4
102639: PPUSH
102640: CALL_OW 256
102644: PPUSH
102645: CALL_OW 2
102649: ST_TO_ADDR
102650: GO 102613
102652: POP
102653: POP
// if not tmp then
102654: LD_VAR 0 5
102658: NOT
102659: IFFALSE 102663
// exit ;
102661: GO 102711
// if asc then
102663: LD_VAR 0 2
102667: IFFALSE 102691
// result := SortListByListAsc ( units , tmp ) else
102669: LD_ADDR_VAR 0 3
102673: PUSH
102674: LD_VAR 0 1
102678: PPUSH
102679: LD_VAR 0 5
102683: PPUSH
102684: CALL_OW 76
102688: ST_TO_ADDR
102689: GO 102711
// result := SortListByListDesc ( units , tmp ) ;
102691: LD_ADDR_VAR 0 3
102695: PUSH
102696: LD_VAR 0 1
102700: PPUSH
102701: LD_VAR 0 5
102705: PPUSH
102706: CALL_OW 77
102710: ST_TO_ADDR
// end ;
102711: LD_VAR 0 3
102715: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
102716: LD_INT 0
102718: PPUSH
102719: PPUSH
// task := GetTaskList ( mech ) ;
102720: LD_ADDR_VAR 0 4
102724: PUSH
102725: LD_VAR 0 1
102729: PPUSH
102730: CALL_OW 437
102734: ST_TO_ADDR
// if not task then
102735: LD_VAR 0 4
102739: NOT
102740: IFFALSE 102744
// exit ;
102742: GO 102786
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
102744: LD_ADDR_VAR 0 3
102748: PUSH
102749: LD_VAR 0 4
102753: PUSH
102754: LD_INT 1
102756: ARRAY
102757: PUSH
102758: LD_INT 1
102760: ARRAY
102761: PUSH
102762: LD_STRING r
102764: EQUAL
102765: PUSH
102766: LD_VAR 0 4
102770: PUSH
102771: LD_INT 1
102773: ARRAY
102774: PUSH
102775: LD_INT 4
102777: ARRAY
102778: PUSH
102779: LD_VAR 0 2
102783: EQUAL
102784: AND
102785: ST_TO_ADDR
// end ;
102786: LD_VAR 0 3
102790: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
102791: LD_INT 0
102793: PPUSH
// SetDir ( unit , d ) ;
102794: LD_VAR 0 1
102798: PPUSH
102799: LD_VAR 0 4
102803: PPUSH
102804: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
102808: LD_VAR 0 1
102812: PPUSH
102813: LD_VAR 0 2
102817: PPUSH
102818: LD_VAR 0 3
102822: PPUSH
102823: LD_VAR 0 5
102827: PPUSH
102828: CALL_OW 48
// end ;
102832: LD_VAR 0 6
102836: RET
// export function ToNaturalNumber ( number ) ; begin
102837: LD_INT 0
102839: PPUSH
// result := number div 1 ;
102840: LD_ADDR_VAR 0 2
102844: PUSH
102845: LD_VAR 0 1
102849: PUSH
102850: LD_INT 1
102852: DIV
102853: ST_TO_ADDR
// if number < 0 then
102854: LD_VAR 0 1
102858: PUSH
102859: LD_INT 0
102861: LESS
102862: IFFALSE 102872
// result := 0 ;
102864: LD_ADDR_VAR 0 2
102868: PUSH
102869: LD_INT 0
102871: ST_TO_ADDR
// end ;
102872: LD_VAR 0 2
102876: RET
// export function SortByClass ( units , class ) ; var un ; begin
102877: LD_INT 0
102879: PPUSH
102880: PPUSH
// if not units or not class then
102881: LD_VAR 0 1
102885: NOT
102886: PUSH
102887: LD_VAR 0 2
102891: NOT
102892: OR
102893: IFFALSE 102897
// exit ;
102895: GO 102992
// result := [ ] ;
102897: LD_ADDR_VAR 0 3
102901: PUSH
102902: EMPTY
102903: ST_TO_ADDR
// for un in units do
102904: LD_ADDR_VAR 0 4
102908: PUSH
102909: LD_VAR 0 1
102913: PUSH
102914: FOR_IN
102915: IFFALSE 102990
// if GetClass ( un ) = class then
102917: LD_VAR 0 4
102921: PPUSH
102922: CALL_OW 257
102926: PUSH
102927: LD_VAR 0 2
102931: EQUAL
102932: IFFALSE 102959
// result := Insert ( result , 1 , un ) else
102934: LD_ADDR_VAR 0 3
102938: PUSH
102939: LD_VAR 0 3
102943: PPUSH
102944: LD_INT 1
102946: PPUSH
102947: LD_VAR 0 4
102951: PPUSH
102952: CALL_OW 2
102956: ST_TO_ADDR
102957: GO 102988
// result := Replace ( result , result + 1 , un ) ;
102959: LD_ADDR_VAR 0 3
102963: PUSH
102964: LD_VAR 0 3
102968: PPUSH
102969: LD_VAR 0 3
102973: PUSH
102974: LD_INT 1
102976: PLUS
102977: PPUSH
102978: LD_VAR 0 4
102982: PPUSH
102983: CALL_OW 1
102987: ST_TO_ADDR
102988: GO 102914
102990: POP
102991: POP
// end ;
102992: LD_VAR 0 3
102996: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
102997: LD_INT 0
102999: PPUSH
103000: PPUSH
103001: PPUSH
103002: PPUSH
103003: PPUSH
103004: PPUSH
103005: PPUSH
// result := [ ] ;
103006: LD_ADDR_VAR 0 4
103010: PUSH
103011: EMPTY
103012: ST_TO_ADDR
// if x - r < 0 then
103013: LD_VAR 0 1
103017: PUSH
103018: LD_VAR 0 3
103022: MINUS
103023: PUSH
103024: LD_INT 0
103026: LESS
103027: IFFALSE 103039
// min_x := 0 else
103029: LD_ADDR_VAR 0 8
103033: PUSH
103034: LD_INT 0
103036: ST_TO_ADDR
103037: GO 103055
// min_x := x - r ;
103039: LD_ADDR_VAR 0 8
103043: PUSH
103044: LD_VAR 0 1
103048: PUSH
103049: LD_VAR 0 3
103053: MINUS
103054: ST_TO_ADDR
// if y - r < 0 then
103055: LD_VAR 0 2
103059: PUSH
103060: LD_VAR 0 3
103064: MINUS
103065: PUSH
103066: LD_INT 0
103068: LESS
103069: IFFALSE 103081
// min_y := 0 else
103071: LD_ADDR_VAR 0 7
103075: PUSH
103076: LD_INT 0
103078: ST_TO_ADDR
103079: GO 103097
// min_y := y - r ;
103081: LD_ADDR_VAR 0 7
103085: PUSH
103086: LD_VAR 0 2
103090: PUSH
103091: LD_VAR 0 3
103095: MINUS
103096: ST_TO_ADDR
// max_x := x + r ;
103097: LD_ADDR_VAR 0 9
103101: PUSH
103102: LD_VAR 0 1
103106: PUSH
103107: LD_VAR 0 3
103111: PLUS
103112: ST_TO_ADDR
// max_y := y + r ;
103113: LD_ADDR_VAR 0 10
103117: PUSH
103118: LD_VAR 0 2
103122: PUSH
103123: LD_VAR 0 3
103127: PLUS
103128: ST_TO_ADDR
// for _x = min_x to max_x do
103129: LD_ADDR_VAR 0 5
103133: PUSH
103134: DOUBLE
103135: LD_VAR 0 8
103139: DEC
103140: ST_TO_ADDR
103141: LD_VAR 0 9
103145: PUSH
103146: FOR_TO
103147: IFFALSE 103248
// for _y = min_y to max_y do
103149: LD_ADDR_VAR 0 6
103153: PUSH
103154: DOUBLE
103155: LD_VAR 0 7
103159: DEC
103160: ST_TO_ADDR
103161: LD_VAR 0 10
103165: PUSH
103166: FOR_TO
103167: IFFALSE 103244
// begin if not ValidHex ( _x , _y ) then
103169: LD_VAR 0 5
103173: PPUSH
103174: LD_VAR 0 6
103178: PPUSH
103179: CALL_OW 488
103183: NOT
103184: IFFALSE 103188
// continue ;
103186: GO 103166
// if GetResourceTypeXY ( _x , _y ) then
103188: LD_VAR 0 5
103192: PPUSH
103193: LD_VAR 0 6
103197: PPUSH
103198: CALL_OW 283
103202: IFFALSE 103242
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
103204: LD_ADDR_VAR 0 4
103208: PUSH
103209: LD_VAR 0 4
103213: PPUSH
103214: LD_VAR 0 4
103218: PUSH
103219: LD_INT 1
103221: PLUS
103222: PPUSH
103223: LD_VAR 0 5
103227: PUSH
103228: LD_VAR 0 6
103232: PUSH
103233: EMPTY
103234: LIST
103235: LIST
103236: PPUSH
103237: CALL_OW 1
103241: ST_TO_ADDR
// end ;
103242: GO 103166
103244: POP
103245: POP
103246: GO 103146
103248: POP
103249: POP
// end ;
103250: LD_VAR 0 4
103254: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
103255: LD_INT 0
103257: PPUSH
103258: PPUSH
103259: PPUSH
103260: PPUSH
103261: PPUSH
103262: PPUSH
103263: PPUSH
103264: PPUSH
// if not units then
103265: LD_VAR 0 1
103269: NOT
103270: IFFALSE 103274
// exit ;
103272: GO 103798
// result := UnitFilter ( units , [ f_ok ] ) ;
103274: LD_ADDR_VAR 0 3
103278: PUSH
103279: LD_VAR 0 1
103283: PPUSH
103284: LD_INT 50
103286: PUSH
103287: EMPTY
103288: LIST
103289: PPUSH
103290: CALL_OW 72
103294: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
103295: LD_ADDR_VAR 0 8
103299: PUSH
103300: LD_VAR 0 1
103304: PUSH
103305: LD_INT 1
103307: ARRAY
103308: PPUSH
103309: CALL_OW 255
103313: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
103314: LD_ADDR_VAR 0 10
103318: PUSH
103319: LD_INT 29
103321: PUSH
103322: LD_INT 91
103324: PUSH
103325: LD_INT 49
103327: PUSH
103328: EMPTY
103329: LIST
103330: LIST
103331: LIST
103332: ST_TO_ADDR
// if not result then
103333: LD_VAR 0 3
103337: NOT
103338: IFFALSE 103342
// exit ;
103340: GO 103798
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
103342: LD_ADDR_VAR 0 5
103346: PUSH
103347: LD_INT 81
103349: PUSH
103350: LD_VAR 0 8
103354: PUSH
103355: EMPTY
103356: LIST
103357: LIST
103358: PPUSH
103359: CALL_OW 69
103363: ST_TO_ADDR
// for i in result do
103364: LD_ADDR_VAR 0 4
103368: PUSH
103369: LD_VAR 0 3
103373: PUSH
103374: FOR_IN
103375: IFFALSE 103796
// begin tag := GetTag ( i ) + 1 ;
103377: LD_ADDR_VAR 0 9
103381: PUSH
103382: LD_VAR 0 4
103386: PPUSH
103387: CALL_OW 110
103391: PUSH
103392: LD_INT 1
103394: PLUS
103395: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
103396: LD_ADDR_VAR 0 7
103400: PUSH
103401: LD_VAR 0 4
103405: PPUSH
103406: CALL_OW 250
103410: PPUSH
103411: LD_VAR 0 4
103415: PPUSH
103416: CALL_OW 251
103420: PPUSH
103421: LD_INT 6
103423: PPUSH
103424: CALL 102997 0 3
103428: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
103429: LD_VAR 0 4
103433: PPUSH
103434: CALL_OW 247
103438: PUSH
103439: LD_INT 2
103441: EQUAL
103442: PUSH
103443: LD_VAR 0 7
103447: AND
103448: PUSH
103449: LD_VAR 0 4
103453: PPUSH
103454: CALL_OW 264
103458: PUSH
103459: LD_VAR 0 10
103463: IN
103464: NOT
103465: AND
103466: IFFALSE 103505
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
103468: LD_VAR 0 4
103472: PPUSH
103473: LD_VAR 0 7
103477: PUSH
103478: LD_INT 1
103480: ARRAY
103481: PUSH
103482: LD_INT 1
103484: ARRAY
103485: PPUSH
103486: LD_VAR 0 7
103490: PUSH
103491: LD_INT 1
103493: ARRAY
103494: PUSH
103495: LD_INT 2
103497: ARRAY
103498: PPUSH
103499: CALL_OW 116
103503: GO 103794
// if path > tag then
103505: LD_VAR 0 2
103509: PUSH
103510: LD_VAR 0 9
103514: GREATER
103515: IFFALSE 103723
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
103517: LD_ADDR_VAR 0 6
103521: PUSH
103522: LD_VAR 0 5
103526: PPUSH
103527: LD_INT 91
103529: PUSH
103530: LD_VAR 0 4
103534: PUSH
103535: LD_INT 8
103537: PUSH
103538: EMPTY
103539: LIST
103540: LIST
103541: LIST
103542: PPUSH
103543: CALL_OW 72
103547: ST_TO_ADDR
// if nearEnemy then
103548: LD_VAR 0 6
103552: IFFALSE 103621
// begin if GetWeapon ( i ) = ru_time_lapser then
103554: LD_VAR 0 4
103558: PPUSH
103559: CALL_OW 264
103563: PUSH
103564: LD_INT 49
103566: EQUAL
103567: IFFALSE 103595
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
103569: LD_VAR 0 4
103573: PPUSH
103574: LD_VAR 0 6
103578: PPUSH
103579: LD_VAR 0 4
103583: PPUSH
103584: CALL_OW 74
103588: PPUSH
103589: CALL_OW 112
103593: GO 103619
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
103595: LD_VAR 0 4
103599: PPUSH
103600: LD_VAR 0 6
103604: PPUSH
103605: LD_VAR 0 4
103609: PPUSH
103610: CALL_OW 74
103614: PPUSH
103615: CALL_OW 115
// end else
103619: GO 103721
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
103621: LD_VAR 0 4
103625: PPUSH
103626: LD_VAR 0 2
103630: PUSH
103631: LD_VAR 0 9
103635: ARRAY
103636: PUSH
103637: LD_INT 1
103639: ARRAY
103640: PPUSH
103641: LD_VAR 0 2
103645: PUSH
103646: LD_VAR 0 9
103650: ARRAY
103651: PUSH
103652: LD_INT 2
103654: ARRAY
103655: PPUSH
103656: CALL_OW 297
103660: PUSH
103661: LD_INT 6
103663: GREATER
103664: IFFALSE 103707
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
103666: LD_VAR 0 4
103670: PPUSH
103671: LD_VAR 0 2
103675: PUSH
103676: LD_VAR 0 9
103680: ARRAY
103681: PUSH
103682: LD_INT 1
103684: ARRAY
103685: PPUSH
103686: LD_VAR 0 2
103690: PUSH
103691: LD_VAR 0 9
103695: ARRAY
103696: PUSH
103697: LD_INT 2
103699: ARRAY
103700: PPUSH
103701: CALL_OW 114
103705: GO 103721
// SetTag ( i , tag ) ;
103707: LD_VAR 0 4
103711: PPUSH
103712: LD_VAR 0 9
103716: PPUSH
103717: CALL_OW 109
// end else
103721: GO 103794
// if enemy then
103723: LD_VAR 0 5
103727: IFFALSE 103794
// begin if GetWeapon ( i ) = ru_time_lapser then
103729: LD_VAR 0 4
103733: PPUSH
103734: CALL_OW 264
103738: PUSH
103739: LD_INT 49
103741: EQUAL
103742: IFFALSE 103770
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103744: LD_VAR 0 4
103748: PPUSH
103749: LD_VAR 0 5
103753: PPUSH
103754: LD_VAR 0 4
103758: PPUSH
103759: CALL_OW 74
103763: PPUSH
103764: CALL_OW 112
103768: GO 103794
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
103770: LD_VAR 0 4
103774: PPUSH
103775: LD_VAR 0 5
103779: PPUSH
103780: LD_VAR 0 4
103784: PPUSH
103785: CALL_OW 74
103789: PPUSH
103790: CALL_OW 115
// end ; end ;
103794: GO 103374
103796: POP
103797: POP
// end ;
103798: LD_VAR 0 3
103802: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
103803: LD_INT 0
103805: PPUSH
103806: PPUSH
103807: PPUSH
// if not unit or IsInUnit ( unit ) then
103808: LD_VAR 0 1
103812: NOT
103813: PUSH
103814: LD_VAR 0 1
103818: PPUSH
103819: CALL_OW 310
103823: OR
103824: IFFALSE 103828
// exit ;
103826: GO 103919
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
103828: LD_ADDR_VAR 0 4
103832: PUSH
103833: LD_VAR 0 1
103837: PPUSH
103838: CALL_OW 250
103842: PPUSH
103843: LD_VAR 0 2
103847: PPUSH
103848: LD_INT 1
103850: PPUSH
103851: CALL_OW 272
103855: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
103856: LD_ADDR_VAR 0 5
103860: PUSH
103861: LD_VAR 0 1
103865: PPUSH
103866: CALL_OW 251
103870: PPUSH
103871: LD_VAR 0 2
103875: PPUSH
103876: LD_INT 1
103878: PPUSH
103879: CALL_OW 273
103883: ST_TO_ADDR
// if ValidHex ( x , y ) then
103884: LD_VAR 0 4
103888: PPUSH
103889: LD_VAR 0 5
103893: PPUSH
103894: CALL_OW 488
103898: IFFALSE 103919
// ComTurnXY ( unit , x , y ) ;
103900: LD_VAR 0 1
103904: PPUSH
103905: LD_VAR 0 4
103909: PPUSH
103910: LD_VAR 0 5
103914: PPUSH
103915: CALL_OW 118
// end ;
103919: LD_VAR 0 3
103923: RET
// export function SeeUnits ( side , units ) ; var i ; begin
103924: LD_INT 0
103926: PPUSH
103927: PPUSH
// result := false ;
103928: LD_ADDR_VAR 0 3
103932: PUSH
103933: LD_INT 0
103935: ST_TO_ADDR
// if not units then
103936: LD_VAR 0 2
103940: NOT
103941: IFFALSE 103945
// exit ;
103943: GO 103990
// for i in units do
103945: LD_ADDR_VAR 0 4
103949: PUSH
103950: LD_VAR 0 2
103954: PUSH
103955: FOR_IN
103956: IFFALSE 103988
// if See ( side , i ) then
103958: LD_VAR 0 1
103962: PPUSH
103963: LD_VAR 0 4
103967: PPUSH
103968: CALL_OW 292
103972: IFFALSE 103986
// begin result := true ;
103974: LD_ADDR_VAR 0 3
103978: PUSH
103979: LD_INT 1
103981: ST_TO_ADDR
// exit ;
103982: POP
103983: POP
103984: GO 103990
// end ;
103986: GO 103955
103988: POP
103989: POP
// end ;
103990: LD_VAR 0 3
103994: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
103995: LD_INT 0
103997: PPUSH
103998: PPUSH
103999: PPUSH
104000: PPUSH
// if not unit or not points then
104001: LD_VAR 0 1
104005: NOT
104006: PUSH
104007: LD_VAR 0 2
104011: NOT
104012: OR
104013: IFFALSE 104017
// exit ;
104015: GO 104107
// dist := 99999 ;
104017: LD_ADDR_VAR 0 5
104021: PUSH
104022: LD_INT 99999
104024: ST_TO_ADDR
// for i in points do
104025: LD_ADDR_VAR 0 4
104029: PUSH
104030: LD_VAR 0 2
104034: PUSH
104035: FOR_IN
104036: IFFALSE 104105
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
104038: LD_ADDR_VAR 0 6
104042: PUSH
104043: LD_VAR 0 1
104047: PPUSH
104048: LD_VAR 0 4
104052: PUSH
104053: LD_INT 1
104055: ARRAY
104056: PPUSH
104057: LD_VAR 0 4
104061: PUSH
104062: LD_INT 2
104064: ARRAY
104065: PPUSH
104066: CALL_OW 297
104070: ST_TO_ADDR
// if tmpDist < dist then
104071: LD_VAR 0 6
104075: PUSH
104076: LD_VAR 0 5
104080: LESS
104081: IFFALSE 104103
// begin result := i ;
104083: LD_ADDR_VAR 0 3
104087: PUSH
104088: LD_VAR 0 4
104092: ST_TO_ADDR
// dist := tmpDist ;
104093: LD_ADDR_VAR 0 5
104097: PUSH
104098: LD_VAR 0 6
104102: ST_TO_ADDR
// end ; end ;
104103: GO 104035
104105: POP
104106: POP
// end ;
104107: LD_VAR 0 3
104111: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104112: LD_INT 0
104114: PPUSH
// uc_side := side ;
104115: LD_ADDR_OWVAR 20
104119: PUSH
104120: LD_VAR 0 1
104124: ST_TO_ADDR
// uc_nation := 3 ;
104125: LD_ADDR_OWVAR 21
104129: PUSH
104130: LD_INT 3
104132: ST_TO_ADDR
// vc_chassis := 25 ;
104133: LD_ADDR_OWVAR 37
104137: PUSH
104138: LD_INT 25
104140: ST_TO_ADDR
// vc_engine := engine_siberite ;
104141: LD_ADDR_OWVAR 39
104145: PUSH
104146: LD_INT 3
104148: ST_TO_ADDR
// vc_control := control_computer ;
104149: LD_ADDR_OWVAR 38
104153: PUSH
104154: LD_INT 3
104156: ST_TO_ADDR
// vc_weapon := 59 ;
104157: LD_ADDR_OWVAR 40
104161: PUSH
104162: LD_INT 59
104164: ST_TO_ADDR
// result := CreateVehicle ;
104165: LD_ADDR_VAR 0 5
104169: PUSH
104170: CALL_OW 45
104174: ST_TO_ADDR
// SetDir ( result , d ) ;
104175: LD_VAR 0 5
104179: PPUSH
104180: LD_VAR 0 4
104184: PPUSH
104185: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
104189: LD_VAR 0 5
104193: PPUSH
104194: LD_VAR 0 2
104198: PPUSH
104199: LD_VAR 0 3
104203: PPUSH
104204: LD_INT 0
104206: PPUSH
104207: CALL_OW 48
// end ;
104211: LD_VAR 0 5
104215: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
104216: LD_INT 0
104218: PPUSH
104219: PPUSH
104220: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
104221: LD_ADDR_VAR 0 2
104225: PUSH
104226: LD_INT 0
104228: PUSH
104229: LD_INT 0
104231: PUSH
104232: LD_INT 0
104234: PUSH
104235: LD_INT 0
104237: PUSH
104238: EMPTY
104239: LIST
104240: LIST
104241: LIST
104242: LIST
104243: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
104244: LD_VAR 0 1
104248: NOT
104249: PUSH
104250: LD_VAR 0 1
104254: PPUSH
104255: CALL_OW 264
104259: PUSH
104260: LD_INT 12
104262: PUSH
104263: LD_INT 51
104265: PUSH
104266: LD_INT 32
104268: PUSH
104269: LD_INT 89
104271: PUSH
104272: EMPTY
104273: LIST
104274: LIST
104275: LIST
104276: LIST
104277: IN
104278: NOT
104279: OR
104280: IFFALSE 104284
// exit ;
104282: GO 104382
// for i := 1 to 3 do
104284: LD_ADDR_VAR 0 3
104288: PUSH
104289: DOUBLE
104290: LD_INT 1
104292: DEC
104293: ST_TO_ADDR
104294: LD_INT 3
104296: PUSH
104297: FOR_TO
104298: IFFALSE 104380
// begin tmp := GetCargo ( cargo , i ) ;
104300: LD_ADDR_VAR 0 4
104304: PUSH
104305: LD_VAR 0 1
104309: PPUSH
104310: LD_VAR 0 3
104314: PPUSH
104315: CALL_OW 289
104319: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
104320: LD_ADDR_VAR 0 2
104324: PUSH
104325: LD_VAR 0 2
104329: PPUSH
104330: LD_VAR 0 3
104334: PPUSH
104335: LD_VAR 0 4
104339: PPUSH
104340: CALL_OW 1
104344: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
104345: LD_ADDR_VAR 0 2
104349: PUSH
104350: LD_VAR 0 2
104354: PPUSH
104355: LD_INT 4
104357: PPUSH
104358: LD_VAR 0 2
104362: PUSH
104363: LD_INT 4
104365: ARRAY
104366: PUSH
104367: LD_VAR 0 4
104371: PLUS
104372: PPUSH
104373: CALL_OW 1
104377: ST_TO_ADDR
// end ;
104378: GO 104297
104380: POP
104381: POP
// end ;
104382: LD_VAR 0 2
104386: RET
// export function Length ( array ) ; begin
104387: LD_INT 0
104389: PPUSH
// result := array + 0 ;
104390: LD_ADDR_VAR 0 2
104394: PUSH
104395: LD_VAR 0 1
104399: PUSH
104400: LD_INT 0
104402: PLUS
104403: ST_TO_ADDR
// end ;
104404: LD_VAR 0 2
104408: RET
// export function PrepareArray ( array ) ; begin
104409: LD_INT 0
104411: PPUSH
// result := array diff 0 ;
104412: LD_ADDR_VAR 0 2
104416: PUSH
104417: LD_VAR 0 1
104421: PUSH
104422: LD_INT 0
104424: DIFF
104425: ST_TO_ADDR
// if not result [ 1 ] then
104426: LD_VAR 0 2
104430: PUSH
104431: LD_INT 1
104433: ARRAY
104434: NOT
104435: IFFALSE 104455
// result := Delete ( result , 1 ) ;
104437: LD_ADDR_VAR 0 2
104441: PUSH
104442: LD_VAR 0 2
104446: PPUSH
104447: LD_INT 1
104449: PPUSH
104450: CALL_OW 3
104454: ST_TO_ADDR
// end ;
104455: LD_VAR 0 2
104459: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
104460: LD_INT 0
104462: PPUSH
104463: PPUSH
104464: PPUSH
104465: PPUSH
// sibRocketRange := 25 ;
104466: LD_ADDR_VAR 0 6
104470: PUSH
104471: LD_INT 25
104473: ST_TO_ADDR
// result := false ;
104474: LD_ADDR_VAR 0 4
104478: PUSH
104479: LD_INT 0
104481: ST_TO_ADDR
// for i := 0 to 5 do
104482: LD_ADDR_VAR 0 5
104486: PUSH
104487: DOUBLE
104488: LD_INT 0
104490: DEC
104491: ST_TO_ADDR
104492: LD_INT 5
104494: PUSH
104495: FOR_TO
104496: IFFALSE 104563
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
104498: LD_VAR 0 1
104502: PPUSH
104503: LD_VAR 0 5
104507: PPUSH
104508: LD_VAR 0 6
104512: PPUSH
104513: CALL_OW 272
104517: PPUSH
104518: LD_VAR 0 2
104522: PPUSH
104523: LD_VAR 0 5
104527: PPUSH
104528: LD_VAR 0 6
104532: PPUSH
104533: CALL_OW 273
104537: PPUSH
104538: LD_VAR 0 3
104542: PPUSH
104543: CALL_OW 309
104547: IFFALSE 104561
// begin result := true ;
104549: LD_ADDR_VAR 0 4
104553: PUSH
104554: LD_INT 1
104556: ST_TO_ADDR
// exit ;
104557: POP
104558: POP
104559: GO 104565
// end ;
104561: GO 104495
104563: POP
104564: POP
// end ; end_of_file
104565: LD_VAR 0 4
104569: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
104570: LD_VAR 0 1
104574: PUSH
104575: LD_INT 200
104577: DOUBLE
104578: GREATEREQUAL
104579: IFFALSE 104587
104581: LD_INT 299
104583: DOUBLE
104584: LESSEQUAL
104585: IFTRUE 104589
104587: GO 104621
104589: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
104590: LD_VAR 0 1
104594: PPUSH
104595: LD_VAR 0 2
104599: PPUSH
104600: LD_VAR 0 3
104604: PPUSH
104605: LD_VAR 0 4
104609: PPUSH
104610: LD_VAR 0 5
104614: PPUSH
104615: CALL 59289 0 5
104619: GO 104698
104621: LD_INT 300
104623: DOUBLE
104624: GREATEREQUAL
104625: IFFALSE 104633
104627: LD_INT 399
104629: DOUBLE
104630: LESSEQUAL
104631: IFTRUE 104635
104633: GO 104697
104635: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
104636: LD_VAR 0 1
104640: PPUSH
104641: LD_VAR 0 2
104645: PPUSH
104646: LD_VAR 0 3
104650: PPUSH
104651: LD_VAR 0 4
104655: PPUSH
104656: LD_VAR 0 5
104660: PPUSH
104661: LD_VAR 0 6
104665: PPUSH
104666: LD_VAR 0 7
104670: PPUSH
104671: LD_VAR 0 8
104675: PPUSH
104676: LD_VAR 0 9
104680: PPUSH
104681: LD_VAR 0 10
104685: PPUSH
104686: LD_VAR 0 11
104690: PPUSH
104691: CALL 55622 0 11
104695: GO 104698
104697: POP
// end ;
104698: PPOPN 11
104700: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
104701: LD_VAR 0 1
104705: PPUSH
104706: LD_VAR 0 2
104710: PPUSH
104711: LD_VAR 0 3
104715: PPUSH
104716: LD_VAR 0 4
104720: PPUSH
104721: LD_VAR 0 5
104725: PPUSH
104726: CALL 59025 0 5
// end ; end_of_file
104730: PPOPN 5
104732: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
104733: LD_VAR 0 1
104737: PPUSH
104738: LD_VAR 0 2
104742: PPUSH
104743: LD_VAR 0 3
104747: PPUSH
104748: LD_VAR 0 4
104752: PPUSH
104753: LD_VAR 0 5
104757: PPUSH
104758: LD_VAR 0 6
104762: PPUSH
104763: CALL 43315 0 6
// end ;
104767: PPOPN 6
104769: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
104770: LD_INT 0
104772: PPUSH
// begin if not units then
104773: LD_VAR 0 1
104777: NOT
104778: IFFALSE 104782
// exit ;
104780: GO 104782
// end ;
104782: PPOPN 7
104784: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
104785: CALL 43286 0 0
// end ;
104789: PPOPN 1
104791: END
