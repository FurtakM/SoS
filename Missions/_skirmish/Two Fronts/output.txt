// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7695 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4864 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41681 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42132 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21435 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21371 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18364 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21271 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22285 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21512 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21305 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21338 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18143 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22193 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20450 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21025 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21025 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20822 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20486 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20662 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19946 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20560 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21061 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21801 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21371 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18364 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21271 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21512 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18143 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22193 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20450 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21025 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21025 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20822 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20486 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20662 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19946 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20560 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21061 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21801 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19946 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11651 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22019 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11651 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22019 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11651 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22019 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11651 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22019 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7914 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7914 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7914 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7914 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7914 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18364 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4861
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4859
// begin PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4785: LD_EXP 22
4789: PUSH
4790: LD_INT 1
4792: ARRAY
4793: PPUSH
4794: LD_INT 18
4796: PPUSH
4797: LD_INT 0
4799: PPUSH
4800: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4804: LD_EXP 22
4808: PUSH
4809: LD_INT 1
4811: ARRAY
4812: PPUSH
4813: LD_INT 107
4815: PPUSH
4816: LD_INT 88
4818: PPUSH
4819: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4823: LD_EXP 22
4827: PUSH
4828: LD_INT 1
4830: ARRAY
4831: PPUSH
4832: LD_INT 3
4834: PPUSH
4835: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4839: LD_ADDR_EXP 22
4843: PUSH
4844: LD_EXP 22
4848: PPUSH
4849: LD_INT 1
4851: PPUSH
4852: CALL_OW 3
4856: ST_TO_ADDR
// end ;
4857: GO 4782
4859: POP
4860: POP
// end ;
4861: PPOPN 1
4863: END
// export function Dialog ; var i ; begin
4864: LD_INT 0
4866: PPUSH
4867: PPUSH
// if not isTest then
4868: LD_EXP 1
4872: NOT
4873: IFFALSE 4895
// case query ( task ) of 1 :
4875: LD_STRING task
4877: PPUSH
4878: CALL_OW 97
4882: PUSH
4883: LD_INT 1
4885: DOUBLE
4886: EQUAL
4887: IFTRUE 4891
4889: GO 4894
4891: POP
// ; end ;
4892: GO 4895
4894: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4895: LD_INT 105
4897: PPUSH
4898: LD_INT 84
4900: PPUSH
4901: LD_INT 3
4903: PPUSH
4904: LD_INT 30
4906: NEG
4907: PPUSH
4908: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4912: LD_INT 105
4914: PPUSH
4915: LD_INT 84
4917: PPUSH
4918: LD_INT 3
4920: PPUSH
4921: CALL_OW 331
// InGameOn ;
4925: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4929: LD_INT 128
4931: PPUSH
4932: LD_INT 64
4934: PPUSH
4935: CALL_OW 86
// if isTest then
4939: LD_EXP 1
4943: IFFALSE 4953
// dialogue_skipped := true ;
4945: LD_ADDR_OWVAR 59
4949: PUSH
4950: LD_INT 1
4952: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4953: LD_EXP 24
4957: PPUSH
4958: LD_STRING DR1
4960: PPUSH
4961: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4965: LD_EXP 24
4969: PPUSH
4970: LD_STRING DR2
4972: PPUSH
4973: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4977: LD_EXP 24
4981: PPUSH
4982: LD_STRING DR3
4984: PPUSH
4985: CALL_OW 94
// InGameOff ;
4989: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
4993: LD_STRING C1
4995: PPUSH
4996: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5000: LD_INT 35
5002: PPUSH
5003: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5007: LD_INT 9
5009: PPUSH
5010: LD_INT 22
5012: PUSH
5013: LD_INT 3
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 70
5024: IFFALSE 5000
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5026: LD_ADDR_VAR 0 2
5030: PUSH
5031: LD_INT 9
5033: PPUSH
5034: LD_INT 22
5036: PUSH
5037: LD_INT 6
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL_OW 70
5048: PUSH
5049: FOR_IN
5050: IFFALSE 5066
// SetSide ( i , 3 ) ;
5052: LD_VAR 0 2
5056: PPUSH
5057: LD_INT 3
5059: PPUSH
5060: CALL_OW 235
5064: GO 5049
5066: POP
5067: POP
// if not isTest then
5068: LD_EXP 1
5072: NOT
5073: IFFALSE 5095
// case query ( support ) of 1 :
5075: LD_STRING support
5077: PPUSH
5078: CALL_OW 97
5082: PUSH
5083: LD_INT 1
5085: DOUBLE
5086: EQUAL
5087: IFTRUE 5091
5089: GO 5094
5091: POP
// ; end ;
5092: GO 5095
5094: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5095: LD_INT 3
5097: PPUSH
5098: LD_INT 12
5100: PPUSH
5101: LD_INT 2
5103: PPUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 3
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 30
5116: PUSH
5117: LD_INT 0
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: LD_INT 1
5135: ARRAY
5136: PPUSH
5137: CALL_OW 468
// if player_com = stolypin then
5141: LD_EXP 23
5145: PUSH
5146: LD_EXP 21
5150: EQUAL
5151: IFFALSE 5180
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5153: LD_INT 18
5155: PPUSH
5156: LD_INT 3
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: LD_INT 2
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_OWVAR 67
5174: ARRAY
5175: PPUSH
5176: CALL 6592 0 2
// end ;
5180: LD_VAR 0 1
5184: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5185: LD_EXP 11
5189: PUSH
5190: LD_OWVAR 1
5194: PUSH
5195: LD_INT 31500
5197: LESS
5198: AND
5199: IFFALSE 5367
// case query ( call1 ) of 1 :
5201: LD_STRING call1
5203: PPUSH
5204: CALL_OW 97
5208: PUSH
5209: LD_INT 1
5211: DOUBLE
5212: EQUAL
5213: IFTRUE 5217
5215: GO 5355
5217: POP
// begin callUsed := true ;
5218: LD_ADDR_EXP 3
5222: PUSH
5223: LD_INT 1
5225: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5226: LD_INT 3
5228: PPUSH
5229: LD_INT 12
5231: PPUSH
5232: LD_INT 1
5234: PPUSH
5235: LD_INT 1
5237: PPUSH
5238: CALL_OW 468
// call := false ;
5242: LD_ADDR_EXP 11
5246: PUSH
5247: LD_INT 0
5249: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5250: LD_EXP 24
5254: PPUSH
5255: LD_STRING DR6
5257: PPUSH
5258: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5262: LD_INT 6300
5264: PPUSH
5265: LD_INT 8400
5267: PPUSH
5268: CALL_OW 12
5272: PPUSH
5273: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5277: LD_INT 18
5279: PUSH
5280: LD_INT 19
5282: PUSH
5283: EMPTY
5284: LIST
5285: LIST
5286: PUSH
5287: LD_INT 1
5289: PPUSH
5290: LD_INT 2
5292: PPUSH
5293: CALL_OW 12
5297: ARRAY
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: LD_INT 2
5304: PPUSH
5305: CALL_OW 12
5309: PPUSH
5310: CALL 6592 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5314: LD_INT 25200
5316: PPUSH
5317: LD_INT 35700
5319: PPUSH
5320: CALL_OW 12
5324: PPUSH
5325: CALL_OW 67
// call := true ;
5329: LD_ADDR_EXP 11
5333: PUSH
5334: LD_INT 1
5336: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 12
5342: PPUSH
5343: LD_INT 2
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 468
// end ; 2 :
5353: GO 5367
5355: LD_INT 2
5357: DOUBLE
5358: EQUAL
5359: IFTRUE 5363
5361: GO 5366
5363: POP
// ; end ;
5364: GO 5367
5366: POP
// if call and tick >= 15 15$00 then
5367: LD_EXP 11
5371: PUSH
5372: LD_OWVAR 1
5376: PUSH
5377: LD_INT 31500
5379: GREATEREQUAL
5380: AND
5381: IFFALSE 5820
// case query ( call2 ) of 1 :
5383: LD_STRING call2
5385: PPUSH
5386: CALL_OW 97
5390: PUSH
5391: LD_INT 1
5393: DOUBLE
5394: EQUAL
5395: IFTRUE 5399
5397: GO 5641
5399: POP
// begin callUsed := true ;
5400: LD_ADDR_EXP 3
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// call := false ;
5408: LD_ADDR_EXP 11
5412: PUSH
5413: LD_INT 0
5415: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5416: LD_INT 1
5418: PPUSH
5419: LD_INT 21
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PPUSH
5429: CALL 11651 0 2
5433: PUSH
5434: LD_INT 4
5436: PPUSH
5437: LD_INT 21
5439: PUSH
5440: LD_INT 3
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: PPUSH
5447: CALL 11651 0 2
5451: AND
5452: IFFALSE 5500
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5454: LD_INT 18
5456: PUSH
5457: LD_INT 19
5459: PUSH
5460: EMPTY
5461: LIST
5462: LIST
5463: PUSH
5464: LD_INT 1
5466: PPUSH
5467: LD_INT 2
5469: PPUSH
5470: CALL_OW 12
5474: ARRAY
5475: PPUSH
5476: LD_INT 5
5478: PUSH
5479: LD_INT 4
5481: PUSH
5482: LD_INT 4
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_OWVAR 67
5494: ARRAY
5495: PPUSH
5496: CALL 6353 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5500: LD_INT 1
5502: PPUSH
5503: LD_INT 21
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PPUSH
5513: CALL 11651 0 2
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5550
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5523: LD_INT 19
5525: PPUSH
5526: LD_INT 5
5528: PUSH
5529: LD_INT 4
5531: PUSH
5532: LD_INT 3
5534: PUSH
5535: EMPTY
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_OWVAR 67
5544: ARRAY
5545: PPUSH
5546: CALL 6353 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5550: LD_INT 4
5552: PPUSH
5553: LD_INT 21
5555: PUSH
5556: LD_INT 3
5558: PUSH
5559: EMPTY
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 11651 0 2
5567: PUSH
5568: LD_INT 0
5570: EQUAL
5571: IFFALSE 5600
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5573: LD_INT 18
5575: PPUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 4
5581: PUSH
5582: LD_INT 4
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_OWVAR 67
5594: ARRAY
5595: PPUSH
5596: CALL 6353 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5600: LD_INT 10500
5602: PPUSH
5603: LD_INT 23100
5605: PPUSH
5606: CALL_OW 12
5610: PPUSH
5611: CALL_OW 67
// call := true ;
5615: LD_ADDR_EXP 11
5619: PUSH
5620: LD_INT 1
5622: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5623: LD_INT 3
5625: PPUSH
5626: LD_INT 12
5628: PPUSH
5629: LD_INT 2
5631: PPUSH
5632: LD_INT 1
5634: PPUSH
5635: CALL_OW 468
// end ; 2 :
5639: GO 5820
5641: LD_INT 2
5643: DOUBLE
5644: EQUAL
5645: IFTRUE 5649
5647: GO 5808
5649: POP
// begin callUsed := true ;
5650: LD_ADDR_EXP 3
5654: PUSH
5655: LD_INT 1
5657: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5658: LD_INT 3
5660: PPUSH
5661: LD_INT 12
5663: PPUSH
5664: LD_INT 1
5666: PPUSH
5667: LD_INT 1
5669: PPUSH
5670: CALL_OW 468
// call := false ;
5674: LD_ADDR_EXP 11
5678: PUSH
5679: LD_INT 0
5681: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5682: LD_EXP 24
5686: PPUSH
5687: LD_STRING DR6
5689: PPUSH
5690: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5694: LD_INT 6300
5696: PPUSH
5697: LD_INT 8400
5699: PPUSH
5700: CALL_OW 12
5704: PPUSH
5705: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5709: LD_INT 18
5711: PUSH
5712: LD_INT 19
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 1
5721: PPUSH
5722: LD_INT 2
5724: PPUSH
5725: CALL_OW 12
5729: ARRAY
5730: PPUSH
5731: LD_INT 3
5733: PUSH
5734: LD_INT 2
5736: PUSH
5737: LD_INT 2
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: LIST
5744: PUSH
5745: LD_OWVAR 67
5749: ARRAY
5750: PUSH
5751: LD_INT 0
5753: PPUSH
5754: LD_INT 1
5756: PPUSH
5757: CALL_OW 12
5761: MINUS
5762: PPUSH
5763: CALL 6592 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5767: LD_INT 35700
5769: PPUSH
5770: LD_INT 44100
5772: PPUSH
5773: CALL_OW 12
5777: PPUSH
5778: CALL_OW 67
// call := true ;
5782: LD_ADDR_EXP 11
5786: PUSH
5787: LD_INT 1
5789: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5790: LD_INT 3
5792: PPUSH
5793: LD_INT 12
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL_OW 468
// end ; 3 :
5806: GO 5820
5808: LD_INT 3
5810: DOUBLE
5811: EQUAL
5812: IFTRUE 5816
5814: GO 5819
5816: POP
// ; end ;
5817: GO 5820
5819: POP
// end ;
5820: PPOPN 4
5822: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 21
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: PUSH
5852: LD_INT 0
5854: EQUAL
5855: PUSH
5856: LD_INT 22
5858: PUSH
5859: LD_INT 4
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PUSH
5866: LD_INT 21
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: PUSH
5885: LD_INT 0
5887: EQUAL
5888: AND
5889: IFFALSE 6193
5891: GO 5893
5893: DISABLE
// begin DialogueOn ;
5894: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5898: LD_EXP 24
5902: PPUSH
5903: LD_STRING DR7
5905: PPUSH
5906: CALL_OW 94
// case player_com of Gorki :
5910: LD_EXP 23
5914: PUSH
5915: LD_EXP 20
5919: DOUBLE
5920: EQUAL
5921: IFTRUE 5925
5923: GO 5935
5925: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5926: LD_STRING ACH_GORKI
5928: PPUSH
5929: CALL_OW 543
5933: GO 5996
5935: LD_EXP 21
5939: DOUBLE
5940: EQUAL
5941: IFTRUE 5945
5943: GO 5955
5945: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5946: LD_STRING ACH_STOLYP
5948: PPUSH
5949: CALL_OW 543
5953: GO 5996
5955: LD_EXP 19
5959: DOUBLE
5960: EQUAL
5961: IFTRUE 5965
5963: GO 5975
5965: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5966: LD_STRING ACH_DAVIDOV
5968: PPUSH
5969: CALL_OW 543
5973: GO 5996
5975: LD_EXP 18
5979: DOUBLE
5980: EQUAL
5981: IFTRUE 5985
5983: GO 5995
5985: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
5986: LD_STRING ACH_GLADKOV
5988: PPUSH
5989: CALL_OW 543
5993: GO 5996
5995: POP
// if not callUsed then
5996: LD_EXP 3
6000: NOT
6001: IFFALSE 6010
// SetAchievement ( ACH_NOSUPP ) ;
6003: LD_STRING ACH_NOSUPP
6005: PPUSH
6006: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6010: LD_OWVAR 1
6014: PUSH
6015: LD_INT 116550
6017: PUSH
6018: LD_INT 95550
6020: PUSH
6021: LD_INT 89250
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: PUSH
6029: LD_OWVAR 67
6033: ARRAY
6034: LESS
6035: IFFALSE 6049
// AddMedal ( med1 , 1 ) else
6037: LD_STRING med1
6039: PPUSH
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 101
6047: GO 6060
// AddMedal ( med1 , - 1 ) ;
6049: LD_STRING med1
6051: PPUSH
6052: LD_INT 1
6054: NEG
6055: PPUSH
6056: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6060: LD_INT 81
6062: PUSH
6063: LD_INT 3
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PUSH
6070: LD_INT 21
6072: PUSH
6073: LD_INT 3
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: PPUSH
6084: CALL_OW 69
6088: PUSH
6089: LD_INT 0
6091: EQUAL
6092: IFFALSE 6106
// AddMedal ( med3 , 1 ) else
6094: LD_STRING med3
6096: PPUSH
6097: LD_INT 1
6099: PPUSH
6100: CALL_OW 101
6104: GO 6117
// AddMedal ( med3 , - 1 ) ;
6106: LD_STRING med3
6108: PPUSH
6109: LD_INT 1
6111: NEG
6112: PPUSH
6113: CALL_OW 101
// if player_loss = 0 then
6117: LD_EXP 10
6121: PUSH
6122: LD_INT 0
6124: EQUAL
6125: IFFALSE 6139
// AddMedal ( med2 , 1 ) else
6127: LD_STRING med2
6129: PPUSH
6130: LD_INT 1
6132: PPUSH
6133: CALL_OW 101
6137: GO 6182
// if player_loss > 0 and player_loss < 3 then
6139: LD_EXP 10
6143: PUSH
6144: LD_INT 0
6146: GREATER
6147: PUSH
6148: LD_EXP 10
6152: PUSH
6153: LD_INT 3
6155: LESS
6156: AND
6157: IFFALSE 6171
// AddMedal ( med2 , 2 ) else
6159: LD_STRING med2
6161: PPUSH
6162: LD_INT 2
6164: PPUSH
6165: CALL_OW 101
6169: GO 6182
// AddMedal ( med2 , - 1 ) ;
6171: LD_STRING med2
6173: PPUSH
6174: LD_INT 1
6176: NEG
6177: PPUSH
6178: CALL_OW 101
// GiveMedals ( MAIN ) ;
6182: LD_STRING MAIN
6184: PPUSH
6185: CALL_OW 102
// YouWin ;
6189: CALL_OW 103
// end ;
6193: END
// every 0 0$01 trigger IsDead ( player_com ) do
6194: LD_EXP 23
6198: PPUSH
6199: CALL_OW 301
6203: IFFALSE 6270
6205: GO 6207
6207: DISABLE
// begin if IsLive ( Houten ) then
6208: LD_EXP 4
6212: PPUSH
6213: CALL_OW 300
6217: IFFALSE 6233
// SayRadio ( Houten , DJ5 ) else
6219: LD_EXP 4
6223: PPUSH
6224: LD_STRING DJ5
6226: PPUSH
6227: CALL_OW 94
6231: GO 6256
// if IsLive ( Brown ) then
6233: LD_EXP 5
6237: PPUSH
6238: CALL_OW 300
6242: IFFALSE 6256
// SayRadio ( Brown , DS5 ) ;
6244: LD_EXP 5
6248: PPUSH
6249: LD_STRING DS5
6251: PPUSH
6252: CALL_OW 94
// Wait ( 0 0$01 ) ;
6256: LD_INT 35
6258: PPUSH
6259: CALL_OW 67
// YouLost ( dead ) ;
6263: LD_STRING dead
6265: PPUSH
6266: CALL_OW 104
// end ;
6270: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6271: LD_INT 1
6273: PPUSH
6274: CALL_OW 301
6278: PUSH
6279: LD_EXP 1
6283: NOT
6284: AND
6285: IFFALSE 6352
6287: GO 6289
6289: DISABLE
// begin if IsLive ( Brown ) then
6290: LD_EXP 5
6294: PPUSH
6295: CALL_OW 300
6299: IFFALSE 6315
// SayRadio ( Brown , DS5 ) else
6301: LD_EXP 5
6305: PPUSH
6306: LD_STRING DS5
6308: PPUSH
6309: CALL_OW 94
6313: GO 6338
// if IsLive ( Houten ) then
6315: LD_EXP 4
6319: PPUSH
6320: CALL_OW 300
6324: IFFALSE 6338
// SayRadio ( Houten , DJ5 ) ;
6326: LD_EXP 4
6330: PPUSH
6331: LD_STRING DJ5
6333: PPUSH
6334: CALL_OW 94
// Wait ( 0 0$01 ) ;
6338: LD_INT 35
6340: PPUSH
6341: CALL_OW 67
// YouLost ( depot ) ;
6345: LD_STRING depot
6347: PPUSH
6348: CALL_OW 104
// end ;
6352: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6353: LD_INT 0
6355: PPUSH
6356: PPUSH
6357: PPUSH
// for i = 1 to n do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6577
// begin uc_side := 6 ;
6376: LD_ADDR_OWVAR 20
6380: PUSH
6381: LD_INT 6
6383: ST_TO_ADDR
// uc_nation := 3 ;
6384: LD_ADDR_OWVAR 21
6388: PUSH
6389: LD_INT 3
6391: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6392: LD_ADDR_OWVAR 37
6396: PUSH
6397: LD_INT 23
6399: PUSH
6400: LD_INT 22
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: ST_TO_ADDR
// vc_control := control_computer ;
6419: LD_ADDR_OWVAR 38
6423: PUSH
6424: LD_INT 3
6426: ST_TO_ADDR
// vc_engine := engine_siberite ;
6427: LD_ADDR_OWVAR 39
6431: PUSH
6432: LD_INT 3
6434: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6435: LD_ADDR_OWVAR 40
6439: PUSH
6440: LD_INT 43
6442: PUSH
6443: LD_INT 44
6445: PUSH
6446: LD_INT 44
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 3
6459: PPUSH
6460: CALL_OW 12
6464: ARRAY
6465: ST_TO_ADDR
// un := CreateVehicle ;
6466: LD_ADDR_VAR 0 5
6470: PUSH
6471: CALL_OW 45
6475: ST_TO_ADDR
// case area of east_arr :
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 18
6483: DOUBLE
6484: EQUAL
6485: IFTRUE 6489
6487: GO 6524
6489: POP
// begin PlaceUnitArea ( un , area , false ) ;
6490: LD_VAR 0 5
6494: PPUSH
6495: LD_VAR 0 1
6499: PPUSH
6500: LD_INT 0
6502: PPUSH
6503: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6507: LD_VAR 0 5
6511: PPUSH
6512: LD_INT 79
6514: PPUSH
6515: LD_INT 33
6517: PPUSH
6518: CALL_OW 111
// end ; south_arr :
6522: GO 6568
6524: LD_INT 19
6526: DOUBLE
6527: EQUAL
6528: IFTRUE 6532
6530: GO 6567
6532: POP
// begin PlaceUnitArea ( un , area , false ) ;
6533: LD_VAR 0 5
6537: PPUSH
6538: LD_VAR 0 1
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6550: LD_VAR 0 5
6554: PPUSH
6555: LD_INT 131
6557: PPUSH
6558: LD_INT 148
6560: PPUSH
6561: CALL_OW 111
// end ; end ;
6565: GO 6568
6567: POP
// Wait ( 0 0$02 ) ;
6568: LD_INT 70
6570: PPUSH
6571: CALL_OW 67
// end ;
6575: GO 6373
6577: POP
6578: POP
// pink_attack := true ;
6579: LD_ADDR_EXP 12
6583: PUSH
6584: LD_INT 1
6586: ST_TO_ADDR
// end ;
6587: LD_VAR 0 3
6591: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
// for i = 1 to n do
6597: LD_ADDR_VAR 0 4
6601: PUSH
6602: DOUBLE
6603: LD_INT 1
6605: DEC
6606: ST_TO_ADDR
6607: LD_VAR 0 2
6611: PUSH
6612: FOR_TO
6613: IFFALSE 6839
// begin uc_side := 6 ;
6615: LD_ADDR_OWVAR 20
6619: PUSH
6620: LD_INT 6
6622: ST_TO_ADDR
// uc_nation := 3 ;
6623: LD_ADDR_OWVAR 21
6627: PUSH
6628: LD_INT 3
6630: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6631: LD_INT 0
6633: PPUSH
6634: LD_INT 3
6636: PPUSH
6637: LD_INT 4
6639: PPUSH
6640: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6644: LD_ADDR_OWVAR 37
6648: PUSH
6649: LD_INT 22
6651: ST_TO_ADDR
// vc_control := control_manual ;
6652: LD_ADDR_OWVAR 38
6656: PUSH
6657: LD_INT 1
6659: ST_TO_ADDR
// vc_engine := engine_combustion ;
6660: LD_ADDR_OWVAR 39
6664: PUSH
6665: LD_INT 1
6667: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6668: LD_ADDR_OWVAR 40
6672: PUSH
6673: LD_INT 51
6675: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6676: LD_ADDR_OWVAR 41
6680: PUSH
6681: LD_INT 50
6683: ST_TO_ADDR
// un := CreateVehicle ;
6684: LD_ADDR_VAR 0 5
6688: PUSH
6689: CALL_OW 45
6693: ST_TO_ADDR
// case area of east_arr :
6694: LD_VAR 0 1
6698: PUSH
6699: LD_INT 18
6701: DOUBLE
6702: EQUAL
6703: IFTRUE 6707
6705: GO 6722
6707: POP
// SetDir ( un , 4 ) ; south_arr :
6708: LD_VAR 0 5
6712: PPUSH
6713: LD_INT 4
6715: PPUSH
6716: CALL_OW 233
6720: GO 6746
6722: LD_INT 19
6724: DOUBLE
6725: EQUAL
6726: IFTRUE 6730
6728: GO 6745
6730: POP
// SetDir ( un , 5 ) ; end ;
6731: LD_VAR 0 5
6735: PPUSH
6736: LD_INT 5
6738: PPUSH
6739: CALL_OW 233
6743: GO 6746
6745: POP
// PlaceUnitArea ( un , area , false ) ;
6746: LD_VAR 0 5
6750: PPUSH
6751: LD_VAR 0 1
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6763: CALL_OW 44
6767: PPUSH
6768: LD_VAR 0 5
6772: PPUSH
6773: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6777: LD_VAR 0 5
6781: PPUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 100
6787: PPUSH
6788: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6792: LD_VAR 0 5
6796: PPUSH
6797: LD_INT 106
6799: PPUSH
6800: LD_INT 88
6802: PPUSH
6803: CALL_OW 111
// AddComUnload ( un ) ;
6807: LD_VAR 0 5
6811: PPUSH
6812: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6816: LD_VAR 0 5
6820: PPUSH
6821: LD_VAR 0 1
6825: PPUSH
6826: CALL_OW 173
// Wait ( 0 0$02 ) ;
6830: LD_INT 70
6832: PPUSH
6833: CALL_OW 67
// end ;
6837: GO 6612
6839: POP
6840: POP
// Wait ( 0 0$05 ) ;
6841: LD_INT 175
6843: PPUSH
6844: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6848: LD_INT 6
6850: PPUSH
6851: LD_INT 34
6853: PUSH
6854: LD_INT 51
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: CALL 11651 0 2
6865: IFFALSE 7053
// begin wait ( 0 0$01 ) ;
6867: LD_INT 35
6869: PPUSH
6870: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6874: LD_ADDR_VAR 0 4
6878: PUSH
6879: LD_INT 6
6881: PPUSH
6882: LD_INT 34
6884: PUSH
6885: LD_INT 51
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: PPUSH
6892: CALL 11651 0 2
6896: PUSH
6897: FOR_IN
6898: IFFALSE 7049
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6900: LD_VAR 0 4
6904: PPUSH
6905: LD_INT 9
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 4
6917: PPUSH
6918: CALL 31773 0 1
6922: PPUSH
6923: CALL_OW 258
6927: PUSH
6928: LD_INT 1
6930: EQUAL
6931: AND
6932: PUSH
6933: LD_EXP 9
6937: AND
6938: IFFALSE 6965
// begin Say ( GetDriver ( i ) , Dtran ) ;
6940: LD_VAR 0 4
6944: PPUSH
6945: CALL 31773 0 1
6949: PPUSH
6950: LD_STRING Dtran
6952: PPUSH
6953: CALL_OW 88
// dialog_trans := false ;
6957: LD_ADDR_EXP 9
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6965: LD_VAR 0 4
6969: PPUSH
6970: CALL_OW 316
6974: IFFALSE 6990
// ComMoveToArea ( i , area ) ;
6976: LD_VAR 0 4
6980: PPUSH
6981: LD_VAR 0 1
6985: PPUSH
6986: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
6990: LD_VAR 0 4
6994: PPUSH
6995: LD_VAR 0 1
6999: PPUSH
7000: CALL_OW 308
7004: PUSH
7005: LD_VAR 0 4
7009: PPUSH
7010: LD_INT 1
7012: PPUSH
7013: CALL_OW 289
7017: PUSH
7018: LD_INT 0
7020: EQUAL
7021: AND
7022: IFFALSE 7047
// begin RemoveUnit ( GetDriver ( i ) ) ;
7024: LD_VAR 0 4
7028: PPUSH
7029: CALL 31773 0 1
7033: PPUSH
7034: CALL_OW 64
// RemoveUnit ( i ) ;
7038: LD_VAR 0 4
7042: PPUSH
7043: CALL_OW 64
// end ; end ;
7047: GO 6897
7049: POP
7050: POP
// end ;
7051: GO 6848
// end ;
7053: LD_VAR 0 3
7057: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7058: LD_INT 0
7060: PPUSH
7061: PPUSH
7062: PPUSH
7063: PPUSH
// if isTest then
7064: LD_EXP 1
7068: IFFALSE 7072
// exit ;
7070: GO 7517
// for i = 1 to n do
7072: LD_ADDR_VAR 0 4
7076: PUSH
7077: DOUBLE
7078: LD_INT 1
7080: DEC
7081: ST_TO_ADDR
7082: LD_VAR 0 2
7086: PUSH
7087: FOR_TO
7088: IFFALSE 7376
// begin uc_side := 8 ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_INT 8
7097: ST_TO_ADDR
// uc_nation := 1 ;
7098: LD_ADDR_OWVAR 21
7102: PUSH
7103: LD_INT 1
7105: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7106: LD_ADDR_VAR 0 6
7110: PUSH
7111: LD_INT 3
7113: PUSH
7114: LD_INT 4
7116: PUSH
7117: LD_INT 4
7119: PUSH
7120: EMPTY
7121: LIST
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 1
7127: PPUSH
7128: LD_OWVAR 67
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// vc_chassis := ch ;
7139: LD_ADDR_OWVAR 37
7143: PUSH
7144: LD_VAR 0 6
7148: ST_TO_ADDR
// vc_control := control_computer ;
7149: LD_ADDR_OWVAR 38
7153: PUSH
7154: LD_INT 3
7156: ST_TO_ADDR
// vc_engine := engine_combustion ;
7157: LD_ADDR_OWVAR 39
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7165: LD_OWVAR 1
7169: PUSH
7170: LD_INT 42000
7172: PUSH
7173: LD_INT 33600
7175: PUSH
7176: LD_INT 29400
7178: PUSH
7179: EMPTY
7180: LIST
7181: LIST
7182: LIST
7183: PUSH
7184: LD_OWVAR 67
7188: ARRAY
7189: LESS
7190: IFFALSE 7221
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7192: LD_ADDR_OWVAR 40
7196: PUSH
7197: LD_INT 3
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 1
7209: PPUSH
7210: LD_INT 2
7212: PPUSH
7213: CALL_OW 12
7217: ARRAY
7218: ST_TO_ADDR
7219: GO 7317
// if ch = us_medium_tracked then
7221: LD_VAR 0 6
7225: PUSH
7226: LD_INT 3
7228: EQUAL
7229: IFFALSE 7276
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7231: LD_ADDR_OWVAR 40
7235: PUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 4
7241: PUSH
7242: LD_INT 5
7244: PUSH
7245: LD_INT 7
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: LIST
7252: LIST
7253: PUSH
7254: LD_OWVAR 67
7258: PPUSH
7259: LD_OWVAR 67
7263: PUSH
7264: LD_INT 1
7266: PLUS
7267: PPUSH
7268: CALL_OW 12
7272: ARRAY
7273: ST_TO_ADDR
7274: GO 7317
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7276: LD_ADDR_OWVAR 40
7280: PUSH
7281: LD_INT 5
7283: PUSH
7284: LD_INT 6
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 7
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: LIST
7298: PUSH
7299: LD_INT 1
7301: PPUSH
7302: LD_OWVAR 67
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PPUSH
7311: CALL_OW 12
7315: ARRAY
7316: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7317: LD_ADDR_OWVAR 41
7321: PUSH
7322: LD_INT 70
7324: ST_TO_ADDR
// un := CreateVehicle ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: CALL_OW 45
7334: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7335: LD_VAR 0 5
7339: PPUSH
7340: LD_VAR 0 1
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7352: LD_VAR 0 5
7356: PPUSH
7357: LD_INT 65
7359: PPUSH
7360: LD_INT 9
7362: PPUSH
7363: CALL_OW 111
// Wait ( 0 0$02 ) ;
7367: LD_INT 70
7369: PPUSH
7370: CALL_OW 67
// end ;
7374: GO 7087
7376: POP
7377: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7378: LD_INT 90
7380: PUSH
7381: LD_INT 80
7383: PUSH
7384: LD_INT 70
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: PUSH
7392: LD_OWVAR 67
7396: ARRAY
7397: PPUSH
7398: CALL_OW 13
7402: IFFALSE 7509
// begin uc_side := 8 ;
7404: LD_ADDR_OWVAR 20
7408: PUSH
7409: LD_INT 8
7411: ST_TO_ADDR
// uc_nation := 1 ;
7412: LD_ADDR_OWVAR 21
7416: PUSH
7417: LD_INT 1
7419: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7420: LD_ADDR_OWVAR 37
7424: PUSH
7425: LD_INT 4
7427: ST_TO_ADDR
// vc_control := control_computer ;
7428: LD_ADDR_OWVAR 38
7432: PUSH
7433: LD_INT 3
7435: ST_TO_ADDR
// vc_engine := engine_combustion ;
7436: LD_ADDR_OWVAR 39
7440: PUSH
7441: LD_INT 1
7443: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7444: LD_ADDR_OWVAR 40
7448: PUSH
7449: LD_INT 14
7451: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7452: LD_ADDR_OWVAR 41
7456: PUSH
7457: LD_INT 70
7459: ST_TO_ADDR
// un := CreateVehicle ;
7460: LD_ADDR_VAR 0 5
7464: PUSH
7465: CALL_OW 45
7469: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7470: LD_VAR 0 5
7474: PPUSH
7475: LD_VAR 0 1
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7487: LD_VAR 0 5
7491: PPUSH
7492: LD_INT 65
7494: PPUSH
7495: LD_INT 9
7497: PPUSH
7498: CALL_OW 111
// Wait ( 0 0$02 ) ;
7502: LD_INT 70
7504: PPUSH
7505: CALL_OW 67
// end ; alfa_support := true ;
7509: LD_ADDR_EXP 13
7513: PUSH
7514: LD_INT 1
7516: ST_TO_ADDR
// end ;
7517: LD_VAR 0 3
7521: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7522: LD_OWVAR 1
7526: PUSH
7527: LD_INT 25200
7529: PUSH
7530: LD_INT 23100
7532: PUSH
7533: LD_INT 21000
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: LIST
7540: PUSH
7541: LD_OWVAR 67
7545: ARRAY
7546: GREATER
7547: IFFALSE 7692
7549: GO 7551
7551: DISABLE
7552: LD_INT 0
7554: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7555: LD_ADDR_VAR 0 1
7559: PUSH
7560: LD_INT 3
7562: PUSH
7563: LD_INT 4
7565: PUSH
7566: LD_INT 5
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7580: LD_INT 1050
7582: PPUSH
7583: LD_INT 4200
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7595: LD_INT 20
7597: PPUSH
7598: LD_VAR 0 1
7602: PPUSH
7603: CALL 7058 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7607: LD_INT 22
7609: PUSH
7610: LD_INT 8
7612: PUSH
7613: EMPTY
7614: LIST
7615: LIST
7616: PPUSH
7617: CALL_OW 69
7621: IFFALSE 7635
// SayRadio ( Popov , DR5 ) ;
7623: LD_EXP 24
7627: PPUSH
7628: LD_STRING DR5
7630: PPUSH
7631: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7635: LD_INT 8400
7637: PPUSH
7638: LD_INT 12600
7640: PPUSH
7641: CALL_OW 12
7645: PPUSH
7646: CALL_OW 67
// n := n + 1 ;
7650: LD_ADDR_VAR 0 1
7654: PUSH
7655: LD_VAR 0 1
7659: PUSH
7660: LD_INT 1
7662: PLUS
7663: ST_TO_ADDR
// if n > 9 then
7664: LD_VAR 0 1
7668: PUSH
7669: LD_INT 9
7671: GREATER
7672: IFFALSE 7682
// n := 9 ;
7674: LD_ADDR_VAR 0 1
7678: PUSH
7679: LD_INT 9
7681: ST_TO_ADDR
// until tick >= 120 120$00 ;
7682: LD_OWVAR 1
7686: PUSH
7687: LD_INT 252000
7689: GREATEREQUAL
7690: IFFALSE 7580
// end ; end_of_file
7692: PPOPN 1
7694: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7695: LD_INT 0
7697: PPUSH
// enable_addtolog := isTest ;
7698: LD_ADDR_OWVAR 81
7702: PUSH
7703: LD_EXP 1
7707: ST_TO_ADDR
// lines_break_limit := 5 ;
7708: LD_ADDR_EXP 26
7712: PUSH
7713: LD_INT 5
7715: ST_TO_ADDR
// lines_break_type := --- ;
7716: LD_ADDR_EXP 27
7720: PUSH
7721: LD_STRING ---
7723: ST_TO_ADDR
// lines_counter := 0 ;
7724: LD_ADDR_EXP 25
7728: PUSH
7729: LD_INT 0
7731: ST_TO_ADDR
// show_line_index := true ;
7732: LD_ADDR_EXP 28
7736: PUSH
7737: LD_INT 1
7739: ST_TO_ADDR
// tick_log := true ;
7740: LD_ADDR_EXP 29
7744: PUSH
7745: LD_INT 1
7747: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7748: LD_STRING ----------SAND OF SIBERIA LOG----------
7750: PPUSH
7751: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7755: LD_STRING Map Name: 
7757: PUSH
7758: LD_OWVAR 68
7762: STR
7763: PPUSH
7764: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7768: LD_STRING Map Number: 
7770: PUSH
7771: LD_OWVAR 70
7775: STR
7776: PPUSH
7777: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7781: LD_STRING Difficulty: 
7783: PUSH
7784: LD_OWVAR 67
7788: STR
7789: PPUSH
7790: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7794: LD_STRING ---------------------------------------
7796: PPUSH
7797: CALL_OW 561
// end ;
7801: LD_VAR 0 1
7805: RET
// function Log ( text ) ; begin
7806: LD_INT 0
7808: PPUSH
// if show_line_index then
7809: LD_EXP 28
7813: IFFALSE 7825
// result := lines_counter ;
7815: LD_ADDR_VAR 0 2
7819: PUSH
7820: LD_EXP 25
7824: ST_TO_ADDR
// if tick_log then
7825: LD_EXP 29
7829: IFFALSE 7855
// result := result &  T:  & tick &   ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_VAR 0 2
7840: PUSH
7841: LD_STRING  T: 
7843: STR
7844: PUSH
7845: LD_OWVAR 1
7849: STR
7850: PUSH
7851: LD_STRING  
7853: STR
7854: ST_TO_ADDR
// AddToLog ( result & text ) ;
7855: LD_VAR 0 2
7859: PUSH
7860: LD_VAR 0 1
7864: STR
7865: PPUSH
7866: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7870: LD_ADDR_EXP 25
7874: PUSH
7875: LD_EXP 25
7879: PUSH
7880: LD_INT 1
7882: PLUS
7883: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7884: LD_EXP 25
7888: PUSH
7889: LD_EXP 26
7893: MOD
7894: PUSH
7895: LD_INT 0
7897: EQUAL
7898: IFFALSE 7909
// AddToLog ( lines_break_type ) ;
7900: LD_EXP 27
7904: PPUSH
7905: CALL_OW 561
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogHuman ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7917: LD_STRING Human Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; class: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 257
7954: STR
7955: PUSH
7956: LD_STRING ; 
7958: STR
7959: PPUSH
7960: CALL 7806 0 1
// end ;
7964: LD_VAR 0 2
7968: RET
// export function LogVeh ( id ) ; begin
7969: LD_INT 0
7971: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7972: LD_STRING Vehicle Created. id: 
7974: PUSH
7975: LD_VAR 0 1
7979: STR
7980: PUSH
7981: LD_STRING ; side: 
7983: STR
7984: PUSH
7985: LD_VAR 0 1
7989: PPUSH
7990: CALL_OW 255
7994: STR
7995: PUSH
7996: LD_STRING ; nation: 
7998: STR
7999: PUSH
8000: LD_VAR 0 1
8004: PPUSH
8005: CALL_OW 248
8009: STR
8010: PUSH
8011: LD_STRING ; weapon: 
8013: STR
8014: PUSH
8015: LD_VAR 0 1
8019: PPUSH
8020: CALL_OW 264
8024: STR
8025: PUSH
8026: LD_STRING ; 
8028: STR
8029: PPUSH
8030: CALL 7806 0 1
// end ;
8034: LD_VAR 0 2
8038: RET
// export function LogEvent ( event ) ; begin
8039: LD_INT 0
8041: PPUSH
// Log ( Event Executed. id:  & event ) ;
8042: LD_STRING Event Executed. id: 
8044: PUSH
8045: LD_VAR 0 1
8049: STR
8050: PPUSH
8051: CALL 7806 0 1
// end ; end_of_file
8055: LD_VAR 0 2
8059: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8060: LD_INT 0
8062: PPUSH
8063: PPUSH
8064: PPUSH
8065: PPUSH
8066: PPUSH
8067: PPUSH
8068: PPUSH
8069: PPUSH
// if unit then
8070: LD_VAR 0 1
8074: IFFALSE 8474
// begin if mode = 0 then
8076: LD_VAR 0 3
8080: PUSH
8081: LD_INT 0
8083: EQUAL
8084: IFFALSE 8232
// begin if coords then
8086: LD_VAR 0 2
8090: IFFALSE 8230
// while ( coords > 1 ) do
8092: LD_VAR 0 2
8096: PUSH
8097: LD_INT 1
8099: GREATER
8100: IFFALSE 8230
// if not HasTask ( unit ) then
8102: LD_VAR 0 1
8106: PPUSH
8107: CALL_OW 314
8111: NOT
8112: IFFALSE 8228
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PUSH
8124: LD_INT 1
8126: ARRAY
8127: PPUSH
8128: LD_VAR 0 2
8132: PUSH
8133: LD_INT 2
8135: ARRAY
8136: PPUSH
8137: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8141: LD_INT 35
8143: PPUSH
8144: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 250
8157: PUSH
8158: LD_VAR 0 2
8162: PUSH
8163: LD_INT 1
8165: ARRAY
8166: EQUAL
8167: PUSH
8168: LD_VAR 0 1
8172: PPUSH
8173: CALL_OW 251
8177: PUSH
8178: LD_VAR 0 2
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: EQUAL
8187: AND
8188: IFFALSE 8141
// for i = 1 to 2 do
8190: LD_ADDR_VAR 0 5
8194: PUSH
8195: DOUBLE
8196: LD_INT 1
8198: DEC
8199: ST_TO_ADDR
8200: LD_INT 2
8202: PUSH
8203: FOR_TO
8204: IFFALSE 8226
// coords := Delete ( coords , 1 ) ;
8206: LD_ADDR_VAR 0 2
8210: PUSH
8211: LD_VAR 0 2
8215: PPUSH
8216: LD_INT 1
8218: PPUSH
8219: CALL_OW 3
8223: ST_TO_ADDR
8224: GO 8203
8226: POP
8227: POP
// end ;
8228: GO 8092
// end else
8230: GO 8474
// begin if coords then
8232: LD_VAR 0 2
8236: IFFALSE 8474
// begin x := GetX ( unit ) ;
8238: LD_ADDR_VAR 0 6
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 250
8252: ST_TO_ADDR
// y := GetY ( unit ) ;
8253: LD_ADDR_VAR 0 7
8257: PUSH
8258: LD_VAR 0 1
8262: PPUSH
8263: CALL_OW 251
8267: ST_TO_ADDR
// while ( coords > 1 ) do
8268: LD_VAR 0 2
8272: PUSH
8273: LD_INT 1
8275: GREATER
8276: IFFALSE 8474
// begin Wait ( 0 0$0.3 ) ;
8278: LD_INT 10
8280: PPUSH
8281: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8285: LD_VAR 0 1
8289: PPUSH
8290: CALL_OW 255
8294: PPUSH
8295: LD_VAR 0 1
8299: PPUSH
8300: CALL_OW 250
8304: PPUSH
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 251
8314: PPUSH
8315: LD_INT 14
8317: PPUSH
8318: CALL 22821 0 4
8322: IFFALSE 8353
// begin ComMoveXY ( unit , x , y ) ;
8324: LD_VAR 0 1
8328: PPUSH
8329: LD_VAR 0 6
8333: PPUSH
8334: LD_VAR 0 7
8338: PPUSH
8339: CALL_OW 111
// result := false ;
8343: LD_ADDR_VAR 0 4
8347: PUSH
8348: LD_INT 0
8350: ST_TO_ADDR
// end else
8351: GO 8392
// if not HasTask ( unit ) then
8353: LD_VAR 0 1
8357: PPUSH
8358: CALL_OW 314
8362: NOT
8363: IFFALSE 8392
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8365: LD_VAR 0 1
8369: PPUSH
8370: LD_VAR 0 2
8374: PUSH
8375: LD_INT 1
8377: ARRAY
8378: PPUSH
8379: LD_VAR 0 2
8383: PUSH
8384: LD_INT 2
8386: ARRAY
8387: PPUSH
8388: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8392: LD_VAR 0 1
8396: PPUSH
8397: CALL_OW 250
8401: PUSH
8402: LD_VAR 0 2
8406: PUSH
8407: LD_INT 1
8409: ARRAY
8410: EQUAL
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 251
8421: PUSH
8422: LD_VAR 0 2
8426: PUSH
8427: LD_INT 2
8429: ARRAY
8430: EQUAL
8431: AND
8432: IFFALSE 8472
// for i = 1 to 2 do
8434: LD_ADDR_VAR 0 5
8438: PUSH
8439: DOUBLE
8440: LD_INT 1
8442: DEC
8443: ST_TO_ADDR
8444: LD_INT 2
8446: PUSH
8447: FOR_TO
8448: IFFALSE 8470
// coords := Delete ( coords , 1 ) ;
8450: LD_ADDR_VAR 0 2
8454: PUSH
8455: LD_VAR 0 2
8459: PPUSH
8460: LD_INT 1
8462: PPUSH
8463: CALL_OW 3
8467: ST_TO_ADDR
8468: GO 8447
8470: POP
8471: POP
// end ;
8472: GO 8268
// end ; end ; end ; result := true ;
8474: LD_ADDR_VAR 0 4
8478: PUSH
8479: LD_INT 1
8481: ST_TO_ADDR
// end ;
8482: LD_VAR 0 4
8486: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8487: LD_INT 0
8489: PPUSH
8490: PPUSH
8491: PPUSH
// if not units then
8492: LD_VAR 0 2
8496: NOT
8497: IFFALSE 8501
// exit ;
8499: GO 8564
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8501: LD_ADDR_VAR 0 5
8505: PUSH
8506: LD_INT 81
8508: PUSH
8509: LD_VAR 0 1
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PPUSH
8518: CALL_OW 69
8522: ST_TO_ADDR
// for i in units do
8523: LD_ADDR_VAR 0 4
8527: PUSH
8528: LD_VAR 0 2
8532: PUSH
8533: FOR_IN
8534: IFFALSE 8562
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8536: LD_VAR 0 4
8540: PPUSH
8541: LD_VAR 0 5
8545: PPUSH
8546: LD_VAR 0 4
8550: PPUSH
8551: CALL_OW 74
8555: PPUSH
8556: CALL_OW 115
// end ;
8560: GO 8533
8562: POP
8563: POP
// end ;
8564: LD_VAR 0 3
8568: RET
// export function MC_Show ( string ) ; begin
8569: LD_INT 0
8571: PPUSH
// display_strings := string ;
8572: LD_ADDR_OWVAR 47
8576: PUSH
8577: LD_VAR 0 1
8581: ST_TO_ADDR
// end ; end_of_file
8582: LD_VAR 0 2
8586: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8587: LD_INT 0
8589: PPUSH
8590: PPUSH
8591: PPUSH
8592: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8593: LD_ADDR_VAR 0 8
8597: PUSH
8598: LD_VAR 0 1
8602: PPUSH
8603: LD_INT 2
8605: PPUSH
8606: EMPTY
8607: PPUSH
8608: CALL 11734 0 3
8612: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8613: LD_VAR 0 8
8617: PUSH
8618: LD_VAR 0 2
8622: PPUSH
8623: LD_VAR 0 3
8627: PPUSH
8628: CALL_OW 428
8632: PUSH
8633: LD_INT 0
8635: EQUAL
8636: AND
8637: IFFALSE 8711
// for i = 1 to plist do
8639: LD_ADDR_VAR 0 6
8643: PUSH
8644: DOUBLE
8645: LD_INT 1
8647: DEC
8648: ST_TO_ADDR
8649: LD_VAR 0 8
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8709
// if NotTask ( plist [ i ] ) then
8657: LD_VAR 0 8
8661: PUSH
8662: LD_VAR 0 6
8666: ARRAY
8667: PPUSH
8668: CALL 32236 0 1
8672: IFFALSE 8707
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8674: LD_VAR 0 8
8678: PUSH
8679: LD_VAR 0 6
8683: ARRAY
8684: PPUSH
8685: LD_INT 0
8687: PPUSH
8688: LD_VAR 0 2
8692: PPUSH
8693: LD_VAR 0 3
8697: PPUSH
8698: LD_VAR 0 4
8702: PPUSH
8703: CALL_OW 145
// end ;
8707: GO 8654
8709: POP
8710: POP
// end ;
8711: LD_VAR 0 5
8715: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8716: LD_INT 0
8718: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8719: LD_VAR 0 1
8723: PPUSH
8724: LD_INT 6
8726: PPUSH
8727: LD_VAR 0 2
8731: PPUSH
8732: LD_VAR 0 3
8736: PPUSH
8737: LD_VAR 0 4
8741: PPUSH
8742: CALL 10220 0 5
// end ;
8746: LD_VAR 0 5
8750: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8751: LD_INT 0
8753: PPUSH
8754: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8755: LD_ADDR_VAR 0 4
8759: PUSH
8760: LD_INT 22
8762: PUSH
8763: LD_VAR 0 1
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PUSH
8772: LD_INT 2
8774: PUSH
8775: LD_INT 30
8777: PUSH
8778: LD_INT 0
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PUSH
8785: LD_INT 30
8787: PUSH
8788: LD_INT 1
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: EMPTY
8805: LIST
8806: PPUSH
8807: CALL_OW 69
8811: PPUSH
8812: LD_VAR 0 2
8816: PPUSH
8817: CALL_OW 250
8821: PPUSH
8822: LD_VAR 0 2
8826: PPUSH
8827: CALL_OW 251
8831: PPUSH
8832: CALL_OW 73
8836: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8837: LD_VAR 0 4
8841: PPUSH
8842: LD_VAR 0 2
8846: PPUSH
8847: CALL 10509 0 2
8851: IFFALSE 8910
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8853: LD_VAR 0 1
8857: PPUSH
8858: LD_INT 30
8860: PUSH
8861: LD_VAR 0 2
8865: PUSH
8866: EMPTY
8867: LIST
8868: LIST
8869: PPUSH
8870: CALL 11651 0 2
8874: PUSH
8875: LD_INT 1
8877: ARRAY
8878: PPUSH
8879: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8883: LD_ADDR_EXP 48
8887: PUSH
8888: LD_EXP 48
8892: PPUSH
8893: LD_VAR 0 1
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: EMPTY
8904: PPUSH
8905: CALL 42051 0 4
8909: ST_TO_ADDR
// end ; end ;
8910: LD_VAR 0 3
8914: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8915: LD_INT 0
8917: PPUSH
8918: PPUSH
8919: PPUSH
8920: PPUSH
8921: PPUSH
8922: PPUSH
// result := false ;
8923: LD_ADDR_VAR 0 4
8927: PUSH
8928: LD_INT 0
8930: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8931: LD_VAR 0 1
8935: PPUSH
8936: LD_EXP 40
8940: PPUSH
8941: CALL 42999 0 2
8945: IFFALSE 9158
// for i = 1 to MREG_LabList do
8947: LD_ADDR_VAR 0 5
8951: PUSH
8952: DOUBLE
8953: LD_INT 1
8955: DEC
8956: ST_TO_ADDR
8957: LD_EXP 40
8961: PUSH
8962: FOR_TO
8963: IFFALSE 9156
// begin if MREG_LabList [ i ] [ 1 ] = side then
8965: LD_EXP 40
8969: PUSH
8970: LD_VAR 0 5
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PUSH
8980: LD_VAR 0 1
8984: EQUAL
8985: IFFALSE 9154
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8987: LD_ADDR_VAR 0 7
8991: PUSH
8992: LD_EXP 40
8996: PUSH
8997: LD_VAR 0 5
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9007: LD_ADDR_VAR 0 9
9011: PUSH
9012: LD_INT 22
9014: PUSH
9015: LD_VAR 0 1
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 30
9029: PUSH
9030: LD_INT 0
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: PUSH
9037: LD_INT 30
9039: PUSH
9040: LD_INT 1
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PUSH
9056: EMPTY
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PPUSH
9064: LD_VAR 0 7
9068: PPUSH
9069: CALL_OW 250
9073: PPUSH
9074: LD_VAR 0 7
9078: PPUSH
9079: CALL_OW 251
9083: PPUSH
9084: CALL_OW 73
9088: ST_TO_ADDR
// if dep then
9089: LD_VAR 0 9
9093: IFFALSE 9152
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9095: LD_VAR 0 9
9099: PPUSH
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 3
9109: PPUSH
9110: CALL 10625 0 3
9114: IFFALSE 9152
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9116: LD_VAR 0 7
9120: PPUSH
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9130: LD_VAR 0 7
9134: PPUSH
9135: LD_VAR 0 3
9139: PPUSH
9140: CALL_OW 207
// result := true ;
9144: LD_ADDR_VAR 0 4
9148: PUSH
9149: LD_INT 1
9151: ST_TO_ADDR
// end ; end ; break ;
9152: GO 9156
// end ; end ;
9154: GO 8962
9156: POP
9157: POP
// end ;
9158: LD_VAR 0 4
9162: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
9167: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9168: LD_ADDR_VAR 0 7
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: LD_VAR 0 3
9182: PPUSH
9183: LD_VAR 0 4
9187: PPUSH
9188: CALL 9350 0 3
9192: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9193: LD_ADDR_EXP 46
9197: PUSH
9198: LD_EXP 46
9202: PPUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: LD_INT 2
9210: PPUSH
9211: LD_VAR 0 2
9215: PUSH
9216: LD_VAR 0 3
9220: PUSH
9221: LD_VAR 0 4
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 41960 0 4
9235: ST_TO_ADDR
// if ext_list then
9236: LD_VAR 0 5
9240: IFFALSE 9345
// for i = 1 to ext_list do
9242: LD_ADDR_VAR 0 8
9246: PUSH
9247: DOUBLE
9248: LD_INT 1
9250: DEC
9251: ST_TO_ADDR
9252: LD_VAR 0 5
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9343
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9260: LD_ADDR_EXP 46
9264: PUSH
9265: LD_EXP 46
9269: PPUSH
9270: LD_VAR 0 1
9274: PPUSH
9275: LD_VAR 0 5
9279: PUSH
9280: LD_VAR 0 8
9284: ARRAY
9285: PPUSH
9286: LD_VAR 0 7
9290: PUSH
9291: LD_VAR 0 8
9295: ARRAY
9296: PUSH
9297: LD_INT 1
9299: ARRAY
9300: PUSH
9301: LD_VAR 0 7
9305: PUSH
9306: LD_VAR 0 8
9310: ARRAY
9311: PUSH
9312: LD_INT 2
9314: ARRAY
9315: PUSH
9316: LD_VAR 0 7
9320: PUSH
9321: LD_VAR 0 8
9325: ARRAY
9326: PUSH
9327: LD_INT 3
9329: ARRAY
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: LIST
9335: PPUSH
9336: CALL 41960 0 4
9340: ST_TO_ADDR
9341: GO 9257
9343: POP
9344: POP
// end ;
9345: LD_VAR 0 6
9349: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9350: LD_INT 0
9352: PPUSH
9353: PPUSH
// list := [ ] ;
9354: LD_ADDR_VAR 0 5
9358: PUSH
9359: EMPTY
9360: ST_TO_ADDR
// case d of 0 :
9361: LD_VAR 0 3
9365: PUSH
9366: LD_INT 0
9368: DOUBLE
9369: EQUAL
9370: IFTRUE 9374
9372: GO 9507
9374: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9375: LD_ADDR_VAR 0 5
9379: PUSH
9380: LD_VAR 0 1
9384: PUSH
9385: LD_INT 4
9387: MINUS
9388: PUSH
9389: LD_VAR 0 2
9393: PUSH
9394: LD_INT 4
9396: MINUS
9397: PUSH
9398: LD_INT 2
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: LIST
9405: PUSH
9406: LD_VAR 0 1
9410: PUSH
9411: LD_INT 3
9413: MINUS
9414: PUSH
9415: LD_VAR 0 2
9419: PUSH
9420: LD_INT 1
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PUSH
9428: LD_VAR 0 1
9432: PUSH
9433: LD_INT 4
9435: PLUS
9436: PUSH
9437: LD_VAR 0 2
9441: PUSH
9442: LD_INT 4
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: LIST
9449: PUSH
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 3
9457: PLUS
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: LD_INT 3
9466: PLUS
9467: PUSH
9468: LD_INT 5
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: LD_VAR 0 1
9480: PUSH
9481: LD_VAR 0 2
9485: PUSH
9486: LD_INT 4
9488: PLUS
9489: PUSH
9490: LD_INT 0
9492: PUSH
9493: EMPTY
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: LIST
9504: ST_TO_ADDR
// end ; 1 :
9505: GO 10205
9507: LD_INT 1
9509: DOUBLE
9510: EQUAL
9511: IFTRUE 9515
9513: GO 9648
9515: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9516: LD_ADDR_VAR 0 5
9520: PUSH
9521: LD_VAR 0 1
9525: PUSH
9526: LD_VAR 0 2
9530: PUSH
9531: LD_INT 4
9533: MINUS
9534: PUSH
9535: LD_INT 3
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: LIST
9542: PUSH
9543: LD_VAR 0 1
9547: PUSH
9548: LD_INT 3
9550: MINUS
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: LD_INT 3
9559: MINUS
9560: PUSH
9561: LD_INT 2
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: LIST
9568: PUSH
9569: LD_VAR 0 1
9573: PUSH
9574: LD_INT 4
9576: MINUS
9577: PUSH
9578: LD_VAR 0 2
9582: PUSH
9583: LD_INT 1
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: LIST
9590: PUSH
9591: LD_VAR 0 1
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: PLUS
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: LD_VAR 0 1
9617: PUSH
9618: LD_INT 4
9620: PLUS
9621: PUSH
9622: LD_VAR 0 2
9626: PUSH
9627: LD_INT 4
9629: PLUS
9630: PUSH
9631: LD_INT 5
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: LIST
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: LIST
9645: ST_TO_ADDR
// end ; 2 :
9646: GO 10205
9648: LD_INT 2
9650: DOUBLE
9651: EQUAL
9652: IFTRUE 9656
9654: GO 9785
9656: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9657: LD_ADDR_VAR 0 5
9661: PUSH
9662: LD_VAR 0 1
9666: PUSH
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: MINUS
9675: PUSH
9676: LD_INT 3
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: LIST
9683: PUSH
9684: LD_VAR 0 1
9688: PUSH
9689: LD_INT 4
9691: PLUS
9692: PUSH
9693: LD_VAR 0 2
9697: PUSH
9698: LD_INT 4
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: PUSH
9706: LD_VAR 0 1
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 4
9718: PLUS
9719: PUSH
9720: LD_INT 0
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: LIST
9727: PUSH
9728: LD_VAR 0 1
9732: PUSH
9733: LD_INT 3
9735: MINUS
9736: PUSH
9737: LD_VAR 0 2
9741: PUSH
9742: LD_INT 1
9744: PUSH
9745: EMPTY
9746: LIST
9747: LIST
9748: LIST
9749: PUSH
9750: LD_VAR 0 1
9754: PUSH
9755: LD_INT 4
9757: MINUS
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: LD_INT 4
9766: MINUS
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: LIST
9775: PUSH
9776: EMPTY
9777: LIST
9778: LIST
9779: LIST
9780: LIST
9781: LIST
9782: ST_TO_ADDR
// end ; 3 :
9783: GO 10205
9785: LD_INT 3
9787: DOUBLE
9788: EQUAL
9789: IFTRUE 9793
9791: GO 9926
9793: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9794: LD_ADDR_VAR 0 5
9798: PUSH
9799: LD_VAR 0 1
9803: PUSH
9804: LD_INT 3
9806: PLUS
9807: PUSH
9808: LD_VAR 0 2
9812: PUSH
9813: LD_INT 4
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: PUSH
9821: LD_VAR 0 1
9825: PUSH
9826: LD_INT 4
9828: PLUS
9829: PUSH
9830: LD_VAR 0 2
9834: PUSH
9835: LD_INT 4
9837: PLUS
9838: PUSH
9839: LD_INT 5
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_INT 4
9854: MINUS
9855: PUSH
9856: LD_VAR 0 2
9860: PUSH
9861: LD_INT 1
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: LIST
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: LD_INT 4
9881: MINUS
9882: PUSH
9883: LD_INT 3
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PUSH
9891: LD_VAR 0 1
9895: PUSH
9896: LD_INT 3
9898: MINUS
9899: PUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_INT 3
9907: MINUS
9908: PUSH
9909: LD_INT 2
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: LIST
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
// end ; 4 :
9924: GO 10205
9926: LD_INT 4
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10067
9934: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9935: LD_ADDR_VAR 0 5
9939: PUSH
9940: LD_VAR 0 1
9944: PUSH
9945: LD_VAR 0 2
9949: PUSH
9950: LD_INT 4
9952: PLUS
9953: PUSH
9954: LD_INT 0
9956: PUSH
9957: EMPTY
9958: LIST
9959: LIST
9960: LIST
9961: PUSH
9962: LD_VAR 0 1
9966: PUSH
9967: LD_INT 3
9969: PLUS
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 3
9978: PLUS
9979: PUSH
9980: LD_INT 5
9982: PUSH
9983: EMPTY
9984: LIST
9985: LIST
9986: LIST
9987: PUSH
9988: LD_VAR 0 1
9992: PUSH
9993: LD_INT 3
9995: PLUS
9996: PUSH
9997: LD_VAR 0 2
10001: PUSH
10002: LD_INT 4
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: LIST
10009: PUSH
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 2
10019: PUSH
10020: LD_INT 3
10022: MINUS
10023: PUSH
10024: LD_INT 3
10026: PUSH
10027: EMPTY
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: LD_VAR 0 1
10036: PUSH
10037: LD_INT 4
10039: MINUS
10040: PUSH
10041: LD_VAR 0 2
10045: PUSH
10046: LD_INT 4
10048: MINUS
10049: PUSH
10050: LD_INT 2
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: LIST
10062: LIST
10063: LIST
10064: ST_TO_ADDR
// end ; 5 :
10065: GO 10205
10067: LD_INT 5
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10204
10075: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10076: LD_ADDR_VAR 0 5
10080: PUSH
10081: LD_VAR 0 1
10085: PUSH
10086: LD_INT 4
10088: MINUS
10089: PUSH
10090: LD_VAR 0 2
10094: PUSH
10095: LD_INT 1
10097: PUSH
10098: EMPTY
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_VAR 0 1
10107: PUSH
10108: LD_VAR 0 2
10112: PUSH
10113: LD_INT 4
10115: MINUS
10116: PUSH
10117: LD_INT 3
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: LIST
10124: PUSH
10125: LD_VAR 0 1
10129: PUSH
10130: LD_INT 4
10132: PLUS
10133: PUSH
10134: LD_VAR 0 2
10138: PUSH
10139: LD_INT 4
10141: PLUS
10142: PUSH
10143: LD_INT 5
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: LIST
10150: PUSH
10151: LD_VAR 0 1
10155: PUSH
10156: LD_INT 3
10158: PLUS
10159: PUSH
10160: LD_VAR 0 2
10164: PUSH
10165: LD_INT 4
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: PUSH
10173: LD_VAR 0 1
10177: PUSH
10178: LD_VAR 0 2
10182: PUSH
10183: LD_INT 3
10185: PLUS
10186: PUSH
10187: LD_INT 0
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: ST_TO_ADDR
// end ; end ;
10202: GO 10205
10204: POP
// result := list ;
10205: LD_ADDR_VAR 0 4
10209: PUSH
10210: LD_VAR 0 5
10214: ST_TO_ADDR
// end ;
10215: LD_VAR 0 4
10219: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10220: LD_INT 0
10222: PPUSH
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10227: LD_ADDR_VAR 0 10
10231: PUSH
10232: LD_VAR 0 1
10236: PPUSH
10237: LD_INT 2
10239: PPUSH
10240: EMPTY
10241: PPUSH
10242: CALL 11734 0 3
10246: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10247: LD_ADDR_VAR 0 9
10251: PUSH
10252: LD_INT 22
10254: PUSH
10255: LD_VAR 0 1
10259: PUSH
10260: EMPTY
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 2
10266: PUSH
10267: LD_INT 30
10269: PUSH
10270: LD_INT 0
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: LD_INT 30
10279: PUSH
10280: LD_INT 1
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PPUSH
10304: LD_VAR 0 3
10308: PPUSH
10309: LD_VAR 0 4
10313: PPUSH
10314: CALL_OW 73
10318: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10319: LD_ADDR_VAR 0 8
10323: PUSH
10324: LD_VAR 0 9
10328: PPUSH
10329: LD_VAR 0 2
10333: PPUSH
10334: CALL 10509 0 2
10338: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10339: LD_VAR 0 10
10343: PUSH
10344: LD_VAR 0 8
10348: AND
10349: PUSH
10350: LD_VAR 0 9
10354: PPUSH
10355: LD_VAR 0 3
10359: PPUSH
10360: LD_VAR 0 4
10364: PPUSH
10365: CALL_OW 297
10369: PUSH
10370: LD_INT 26
10372: LESSEQUAL
10373: AND
10374: PUSH
10375: LD_VAR 0 3
10379: PPUSH
10380: LD_VAR 0 4
10384: PPUSH
10385: CALL_OW 428
10389: PUSH
10390: LD_INT 0
10392: EQUAL
10393: AND
10394: IFFALSE 10504
// for i = 1 to plist do
10396: LD_ADDR_VAR 0 7
10400: PUSH
10401: DOUBLE
10402: LD_INT 1
10404: DEC
10405: ST_TO_ADDR
10406: LD_VAR 0 10
10410: PUSH
10411: FOR_TO
10412: IFFALSE 10502
// if IsInUnit ( plist [ i ] ) then
10414: LD_VAR 0 10
10418: PUSH
10419: LD_VAR 0 7
10423: ARRAY
10424: PPUSH
10425: CALL_OW 310
10429: IFFALSE 10448
// ComExitBuilding ( plist [ i ] ) else
10431: LD_VAR 0 10
10435: PUSH
10436: LD_VAR 0 7
10440: ARRAY
10441: PPUSH
10442: CALL_OW 122
10446: GO 10500
// if NotTask ( plist [ i ] ) then
10448: LD_VAR 0 10
10452: PUSH
10453: LD_VAR 0 7
10457: ARRAY
10458: PPUSH
10459: CALL 32236 0 1
10463: IFFALSE 10500
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10465: LD_VAR 0 10
10469: PUSH
10470: LD_VAR 0 7
10474: ARRAY
10475: PPUSH
10476: LD_VAR 0 2
10480: PPUSH
10481: LD_VAR 0 3
10485: PPUSH
10486: LD_VAR 0 4
10490: PPUSH
10491: LD_VAR 0 5
10495: PPUSH
10496: CALL_OW 145
// end ;
10500: GO 10411
10502: POP
10503: POP
// end ;
10504: LD_VAR 0 6
10508: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10509: LD_INT 0
10511: PPUSH
10512: PPUSH
10513: PPUSH
// pom := GetBase ( bdepot ) ;
10514: LD_ADDR_VAR 0 4
10518: PUSH
10519: LD_VAR 0 1
10523: PPUSH
10524: CALL_OW 274
10528: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10529: LD_ADDR_VAR 0 5
10533: PUSH
10534: LD_VAR 0 2
10538: PPUSH
10539: LD_VAR 0 1
10543: PPUSH
10544: CALL_OW 248
10548: PPUSH
10549: CALL_OW 450
10553: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10554: LD_VAR 0 4
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: CALL_OW 275
10566: PUSH
10567: LD_VAR 0 5
10571: PUSH
10572: LD_INT 1
10574: ARRAY
10575: GREATEREQUAL
10576: PUSH
10577: LD_VAR 0 4
10581: PPUSH
10582: LD_INT 3
10584: PPUSH
10585: CALL_OW 275
10589: PUSH
10590: LD_VAR 0 5
10594: PUSH
10595: LD_INT 3
10597: ARRAY
10598: GREATEREQUAL
10599: AND
10600: IFFALSE 10612
// result := true else
10602: LD_ADDR_VAR 0 3
10606: PUSH
10607: LD_INT 1
10609: ST_TO_ADDR
10610: GO 10620
// result := false ;
10612: LD_ADDR_VAR 0 3
10616: PUSH
10617: LD_INT 0
10619: ST_TO_ADDR
// end ;
10620: LD_VAR 0 3
10624: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
10629: PPUSH
10630: PPUSH
10631: PPUSH
// pom := GetBase ( bdepot ) ;
10632: LD_ADDR_VAR 0 5
10636: PUSH
10637: LD_VAR 0 1
10641: PPUSH
10642: CALL_OW 274
10646: ST_TO_ADDR
// cost := [ ] ;
10647: LD_ADDR_VAR 0 8
10651: PUSH
10652: EMPTY
10653: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10654: LD_ADDR_VAR 0 6
10658: PUSH
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_VAR 0 1
10668: PPUSH
10669: CALL_OW 248
10673: PPUSH
10674: CALL_OW 450
10678: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10679: LD_ADDR_VAR 0 7
10683: PUSH
10684: LD_VAR 0 3
10688: PPUSH
10689: LD_VAR 0 1
10693: PPUSH
10694: CALL_OW 248
10698: PPUSH
10699: CALL_OW 450
10703: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10704: LD_ADDR_VAR 0 8
10708: PUSH
10709: LD_VAR 0 8
10713: PPUSH
10714: LD_INT 1
10716: PPUSH
10717: LD_VAR 0 6
10721: PUSH
10722: LD_INT 1
10724: ARRAY
10725: PUSH
10726: LD_VAR 0 7
10730: PUSH
10731: LD_INT 1
10733: ARRAY
10734: PLUS
10735: PPUSH
10736: CALL_OW 1
10740: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: LD_VAR 0 8
10750: PPUSH
10751: LD_INT 2
10753: PPUSH
10754: LD_VAR 0 6
10758: PUSH
10759: LD_INT 2
10761: ARRAY
10762: PUSH
10763: LD_VAR 0 7
10767: PUSH
10768: LD_INT 2
10770: ARRAY
10771: PLUS
10772: PPUSH
10773: CALL_OW 1
10777: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10778: LD_ADDR_VAR 0 8
10782: PUSH
10783: LD_VAR 0 8
10787: PPUSH
10788: LD_INT 3
10790: PPUSH
10791: LD_VAR 0 6
10795: PUSH
10796: LD_INT 3
10798: ARRAY
10799: PUSH
10800: LD_VAR 0 7
10804: PUSH
10805: LD_INT 3
10807: ARRAY
10808: PLUS
10809: PPUSH
10810: CALL_OW 1
10814: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10815: LD_VAR 0 5
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 275
10827: PUSH
10828: LD_VAR 0 8
10832: PUSH
10833: LD_INT 1
10835: ARRAY
10836: GREATEREQUAL
10837: PUSH
10838: LD_VAR 0 5
10842: PPUSH
10843: LD_INT 3
10845: PPUSH
10846: CALL_OW 275
10850: PUSH
10851: LD_VAR 0 8
10855: PUSH
10856: LD_INT 3
10858: ARRAY
10859: GREATEREQUAL
10860: AND
10861: IFFALSE 10873
// result := true else
10863: LD_ADDR_VAR 0 4
10867: PUSH
10868: LD_INT 1
10870: ST_TO_ADDR
10871: GO 10881
// result := false ;
10873: LD_ADDR_VAR 0 4
10877: PUSH
10878: LD_INT 0
10880: ST_TO_ADDR
// end ;
10881: LD_VAR 0 4
10885: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10886: LD_INT 0
10888: PPUSH
10889: PPUSH
10890: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10891: LD_ADDR_VAR 0 5
10895: PUSH
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_INT 2
10903: PPUSH
10904: EMPTY
10905: PPUSH
10906: CALL 11734 0 3
10910: ST_TO_ADDR
// if unit and plist then
10911: LD_VAR 0 2
10915: PUSH
10916: LD_VAR 0 5
10920: AND
10921: IFFALSE 10982
// for i = 1 to plist do
10923: LD_ADDR_VAR 0 4
10927: PUSH
10928: DOUBLE
10929: LD_INT 1
10931: DEC
10932: ST_TO_ADDR
10933: LD_VAR 0 5
10937: PUSH
10938: FOR_TO
10939: IFFALSE 10980
// if NotTask ( plist [ i ] ) then
10941: LD_VAR 0 5
10945: PUSH
10946: LD_VAR 0 4
10950: ARRAY
10951: PPUSH
10952: CALL 32236 0 1
10956: IFFALSE 10978
// ComDismantle ( plist [ i ] , unit ) ;
10958: LD_VAR 0 5
10962: PUSH
10963: LD_VAR 0 4
10967: ARRAY
10968: PPUSH
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 167
10978: GO 10938
10980: POP
10981: POP
// result := true ;
10982: LD_ADDR_VAR 0 3
10986: PUSH
10987: LD_INT 1
10989: ST_TO_ADDR
// end ;
10990: LD_VAR 0 3
10994: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10995: LD_INT 0
10997: PPUSH
10998: PPUSH
10999: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11000: LD_ADDR_VAR 0 5
11004: PUSH
11005: LD_VAR 0 1
11009: PPUSH
11010: LD_INT 2
11012: PPUSH
11013: EMPTY
11014: PPUSH
11015: CALL 11734 0 3
11019: ST_TO_ADDR
// if unit and plist then
11020: LD_VAR 0 2
11024: PUSH
11025: LD_VAR 0 5
11029: AND
11030: IFFALSE 11091
// for i = 1 to plist do
11032: LD_ADDR_VAR 0 4
11036: PUSH
11037: DOUBLE
11038: LD_INT 1
11040: DEC
11041: ST_TO_ADDR
11042: LD_VAR 0 5
11046: PUSH
11047: FOR_TO
11048: IFFALSE 11089
// if NotTask ( plist [ i ] ) then
11050: LD_VAR 0 5
11054: PUSH
11055: LD_VAR 0 4
11059: ARRAY
11060: PPUSH
11061: CALL 32236 0 1
11065: IFFALSE 11087
// ComComplete ( plist [ i ] , unit ) ;
11067: LD_VAR 0 5
11071: PUSH
11072: LD_VAR 0 4
11076: ARRAY
11077: PPUSH
11078: LD_VAR 0 2
11082: PPUSH
11083: CALL 72177 0 2
11087: GO 11047
11089: POP
11090: POP
// result := true ;
11091: LD_ADDR_VAR 0 3
11095: PUSH
11096: LD_INT 1
11098: ST_TO_ADDR
// end ;
11099: LD_VAR 0 3
11103: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11104: LD_INT 0
11106: PPUSH
11107: PPUSH
11108: PPUSH
11109: PPUSH
11110: PPUSH
11111: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11112: LD_ADDR_VAR 0 5
11116: PUSH
11117: LD_INT 22
11119: PUSH
11120: LD_VAR 0 1
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: PUSH
11129: LD_INT 21
11131: PUSH
11132: LD_INT 3
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: PUSH
11139: LD_INT 3
11141: PUSH
11142: LD_INT 57
11144: PUSH
11145: EMPTY
11146: LIST
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 24
11157: PUSH
11158: LD_INT 1000
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: PPUSH
11175: CALL_OW 69
11179: ST_TO_ADDR
// r := [ ] ;
11180: LD_ADDR_VAR 0 6
11184: PUSH
11185: EMPTY
11186: ST_TO_ADDR
// if not tmp then
11187: LD_VAR 0 5
11191: NOT
11192: IFFALSE 11198
// exit else
11194: GO 11386
11196: GO 11366
// begin r := [ tmp [ 1 ] ] ;
11198: LD_ADDR_VAR 0 6
11202: PUSH
11203: LD_VAR 0 5
11207: PUSH
11208: LD_INT 1
11210: ARRAY
11211: PUSH
11212: EMPTY
11213: LIST
11214: ST_TO_ADDR
// for i = 2 to tmp do
11215: LD_ADDR_VAR 0 3
11219: PUSH
11220: DOUBLE
11221: LD_INT 2
11223: DEC
11224: ST_TO_ADDR
11225: LD_VAR 0 5
11229: PUSH
11230: FOR_TO
11231: IFFALSE 11364
// begin m := false ;
11233: LD_ADDR_VAR 0 7
11237: PUSH
11238: LD_INT 0
11240: ST_TO_ADDR
// for j = 1 to r do
11241: LD_ADDR_VAR 0 4
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_VAR 0 6
11255: PUSH
11256: FOR_TO
11257: IFFALSE 11331
// if GetLives ( tmp [ i ] ) < r [ j ] then
11259: LD_VAR 0 5
11263: PUSH
11264: LD_VAR 0 3
11268: ARRAY
11269: PPUSH
11270: CALL_OW 256
11274: PUSH
11275: LD_VAR 0 6
11279: PUSH
11280: LD_VAR 0 4
11284: ARRAY
11285: LESS
11286: IFFALSE 11329
// begin r := Insert ( r , j , tmp [ i ] ) ;
11288: LD_ADDR_VAR 0 6
11292: PUSH
11293: LD_VAR 0 6
11297: PPUSH
11298: LD_VAR 0 4
11302: PPUSH
11303: LD_VAR 0 5
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: CALL_OW 2
11318: ST_TO_ADDR
// m := true ;
11319: LD_ADDR_VAR 0 7
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// break ;
11327: GO 11331
// end ;
11329: GO 11256
11331: POP
11332: POP
// if not m then
11333: LD_VAR 0 7
11337: NOT
11338: IFFALSE 11362
// r := r ^ tmp [ i ] ;
11340: LD_ADDR_VAR 0 6
11344: PUSH
11345: LD_VAR 0 6
11349: PUSH
11350: LD_VAR 0 5
11354: PUSH
11355: LD_VAR 0 3
11359: ARRAY
11360: ADD
11361: ST_TO_ADDR
// end ;
11362: GO 11230
11364: POP
11365: POP
// end ; if r then
11366: LD_VAR 0 6
11370: IFFALSE 11384
// result := r else
11372: LD_ADDR_VAR 0 2
11376: PUSH
11377: LD_VAR 0 6
11381: ST_TO_ADDR
11382: GO 11386
// exit ;
11384: GO 11386
// end ;
11386: LD_VAR 0 2
11390: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11391: LD_INT 0
11393: PPUSH
11394: PPUSH
11395: PPUSH
11396: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11397: LD_ADDR_VAR 0 5
11401: PUSH
11402: LD_INT 22
11404: PUSH
11405: LD_VAR 0 1
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: LD_INT 25
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 25
11429: PUSH
11430: LD_INT 16
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 34
11439: PUSH
11440: LD_INT 13
11442: PUSH
11443: EMPTY
11444: LIST
11445: LIST
11446: PUSH
11447: LD_INT 34
11449: PUSH
11450: LD_INT 52
11452: PUSH
11453: EMPTY
11454: LIST
11455: LIST
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: PUSH
11464: LD_INT 24
11466: PUSH
11467: LD_INT 650
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: PPUSH
11479: CALL_OW 69
11483: ST_TO_ADDR
// p := 1 ;
11484: LD_ADDR_VAR 0 4
11488: PUSH
11489: LD_INT 1
11491: ST_TO_ADDR
// for i = 1 to repairs do
11492: LD_ADDR_VAR 0 3
11496: PUSH
11497: DOUBLE
11498: LD_INT 1
11500: DEC
11501: ST_TO_ADDR
11502: LD_VAR 0 5
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// begin if IsInUnit ( repairs [ i ] ) then
11510: LD_VAR 0 5
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: PPUSH
11521: CALL_OW 310
11525: IFFALSE 11544
// ComExitBuilding ( repairs [ i ] ) else
11527: LD_VAR 0 5
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: PPUSH
11538: CALL_OW 122
11542: GO 11642
// if not HasTask ( repairs [ i ] ) then
11544: LD_VAR 0 5
11548: PUSH
11549: LD_VAR 0 3
11553: ARRAY
11554: PPUSH
11555: CALL_OW 314
11559: NOT
11560: IFFALSE 11642
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11562: LD_VAR 0 5
11566: PUSH
11567: LD_VAR 0 3
11571: ARRAY
11572: PPUSH
11573: LD_EXP 47
11577: PUSH
11578: LD_VAR 0 1
11582: ARRAY
11583: PUSH
11584: LD_VAR 0 4
11588: ARRAY
11589: PPUSH
11590: CALL_OW 130
// if i mod 3 = 0 then
11594: LD_VAR 0 3
11598: PUSH
11599: LD_INT 3
11601: MOD
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: IFFALSE 11622
// p := p + 1 ;
11608: LD_ADDR_VAR 0 4
11612: PUSH
11613: LD_VAR 0 4
11617: PUSH
11618: LD_INT 1
11620: PLUS
11621: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11622: LD_EXP 47
11626: PUSH
11627: LD_VAR 0 1
11631: ARRAY
11632: PUSH
11633: LD_VAR 0 4
11637: LESS
11638: IFFALSE 11642
// break ;
11640: GO 11644
// end ; end ;
11642: GO 11507
11644: POP
11645: POP
// end ; end_of_file
11646: LD_VAR 0 2
11650: RET
// export function MCF_Get ( side , filter ) ; begin
11651: LD_INT 0
11653: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_INT 22
11661: PUSH
11662: LD_VAR 0 1
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: LD_VAR 0 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PPUSH
11680: CALL_OW 69
11684: ST_TO_ADDR
// end ;
11685: LD_VAR 0 3
11689: RET
// export function MCF_Lab ( side ) ; begin
11690: LD_INT 0
11692: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11693: LD_ADDR_VAR 0 2
11697: PUSH
11698: LD_INT 22
11700: PUSH
11701: LD_VAR 0 1
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PUSH
11710: LD_INT 30
11712: PUSH
11713: LD_INT 8
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PPUSH
11724: CALL_OW 69
11728: ST_TO_ADDR
// end ;
11729: LD_VAR 0 2
11733: RET
// export function MCF_Class ( side , class , filter ) ; begin
11734: LD_INT 0
11736: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_INT 22
11744: PUSH
11745: LD_VAR 0 1
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: PUSH
11754: LD_INT 25
11756: PUSH
11757: LD_VAR 0 2
11761: PUSH
11762: EMPTY
11763: LIST
11764: LIST
11765: PUSH
11766: LD_VAR 0 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 4
11785: RET
// export function MCF_All ( side , filter ) ; begin
11786: LD_INT 0
11788: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11789: LD_ADDR_VAR 0 3
11793: PUSH
11794: LD_INT 22
11796: PUSH
11797: LD_VAR 0 1
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 25
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 25
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: LD_INT 25
11831: PUSH
11832: LD_INT 3
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 25
11841: PUSH
11842: LD_INT 4
11844: PUSH
11845: EMPTY
11846: LIST
11847: LIST
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PUSH
11856: LD_VAR 0 2
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: ST_TO_ADDR
// end ;
11871: LD_VAR 0 3
11875: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11876: LD_INT 0
11878: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11879: LD_ADDR_VAR 0 4
11883: PUSH
11884: LD_INT 22
11886: PUSH
11887: LD_VAR 0 1
11891: PUSH
11892: EMPTY
11893: LIST
11894: LIST
11895: PUSH
11896: LD_INT 92
11898: PUSH
11899: LD_VAR 0 2
11903: PUSH
11904: LD_INT 1
11906: ARRAY
11907: PUSH
11908: LD_VAR 0 2
11912: PUSH
11913: LD_INT 2
11915: ARRAY
11916: PUSH
11917: LD_VAR 0 2
11921: PUSH
11922: LD_INT 3
11924: ARRAY
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: PUSH
11932: LD_VAR 0 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: LIST
11941: PPUSH
11942: CALL_OW 69
11946: ST_TO_ADDR
// end ;
11947: LD_VAR 0 4
11951: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11952: LD_INT 0
11954: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11955: LD_ADDR_VAR 0 3
11959: PUSH
11960: LD_INT 22
11962: PUSH
11963: LD_VAR 0 1
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: PUSH
11972: LD_INT 21
11974: PUSH
11975: LD_INT 2
11977: PUSH
11978: EMPTY
11979: LIST
11980: LIST
11981: PUSH
11982: LD_VAR 0 2
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: ST_TO_ADDR
// end ;
11997: LD_VAR 0 3
12001: RET
// export function MCF_Cargo ( side ) ; begin
12002: LD_INT 0
12004: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12005: LD_ADDR_VAR 0 2
12009: PUSH
12010: LD_VAR 0 1
12014: PPUSH
12015: LD_INT 2
12017: PUSH
12018: LD_INT 34
12020: PUSH
12021: LD_INT 12
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: PUSH
12028: LD_INT 34
12030: PUSH
12031: LD_INT 32
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 34
12040: PUSH
12041: LD_INT 51
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: LIST
12052: LIST
12053: PPUSH
12054: CALL 11952 0 2
12058: ST_TO_ADDR
// end ;
12059: LD_VAR 0 2
12063: RET
// export function MCF_Ape ( side ) ; begin
12064: LD_INT 0
12066: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12067: LD_ADDR_VAR 0 2
12071: PUSH
12072: LD_INT 22
12074: PUSH
12075: LD_VAR 0 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: LD_INT 2
12086: PUSH
12087: LD_INT 25
12089: PUSH
12090: LD_INT 12
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 25
12099: PUSH
12100: LD_INT 15
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: LD_INT 25
12109: PUSH
12110: LD_INT 16
12112: PUSH
12113: EMPTY
12114: LIST
12115: LIST
12116: PUSH
12117: LD_INT 25
12119: PUSH
12120: LD_INT 17
12122: PUSH
12123: EMPTY
12124: LIST
12125: LIST
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PPUSH
12138: CALL_OW 69
12142: ST_TO_ADDR
// end ;
12143: LD_VAR 0 2
12147: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12148: LD_INT 0
12150: PPUSH
12151: PPUSH
12152: PPUSH
12153: PPUSH
// result := [ ] ;
12154: LD_ADDR_VAR 0 3
12158: PUSH
12159: EMPTY
12160: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12161: LD_ADDR_VAR 0 4
12165: PUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL 12064 0 1
12175: ST_TO_ADDR
// case type of 0 , normal :
12176: LD_VAR 0 2
12180: PUSH
12181: LD_INT 0
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12195
12187: LD_STRING normal
12189: DOUBLE
12190: EQUAL
12191: IFTRUE 12195
12193: GO 12206
12195: POP
// cl := class_apeman ; 1 , soldier :
12196: LD_ADDR_VAR 0 5
12200: PUSH
12201: LD_INT 12
12203: ST_TO_ADDR
12204: GO 12282
12206: LD_INT 1
12208: DOUBLE
12209: EQUAL
12210: IFTRUE 12220
12212: LD_STRING soldier
12214: DOUBLE
12215: EQUAL
12216: IFTRUE 12220
12218: GO 12231
12220: POP
// cl := class_apeman_soldier ; 2 , engineer :
12221: LD_ADDR_VAR 0 5
12225: PUSH
12226: LD_INT 15
12228: ST_TO_ADDR
12229: GO 12282
12231: LD_INT 2
12233: DOUBLE
12234: EQUAL
12235: IFTRUE 12245
12237: LD_STRING engineer
12239: DOUBLE
12240: EQUAL
12241: IFTRUE 12245
12243: GO 12256
12245: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12246: LD_ADDR_VAR 0 5
12250: PUSH
12251: LD_INT 16
12253: ST_TO_ADDR
12254: GO 12282
12256: LD_INT 3
12258: DOUBLE
12259: EQUAL
12260: IFTRUE 12270
12262: LD_STRING kamikaze
12264: DOUBLE
12265: EQUAL
12266: IFTRUE 12270
12268: GO 12281
12270: POP
// cl := class_apeman_kamikaze ; end ;
12271: LD_ADDR_VAR 0 5
12275: PUSH
12276: LD_INT 17
12278: ST_TO_ADDR
12279: GO 12282
12281: POP
// for i = 1 to tmp do
12282: LD_ADDR_VAR 0 6
12286: PUSH
12287: DOUBLE
12288: LD_INT 1
12290: DEC
12291: ST_TO_ADDR
12292: LD_VAR 0 4
12296: PUSH
12297: FOR_TO
12298: IFFALSE 12347
// if GetClass ( tmp [ i ] ) = cl then
12300: LD_VAR 0 4
12304: PUSH
12305: LD_VAR 0 6
12309: ARRAY
12310: PPUSH
12311: CALL_OW 257
12315: PUSH
12316: LD_VAR 0 5
12320: EQUAL
12321: IFFALSE 12345
// result := result ^ tmp [ i ] ;
12323: LD_ADDR_VAR 0 3
12327: PUSH
12328: LD_VAR 0 3
12332: PUSH
12333: LD_VAR 0 4
12337: PUSH
12338: LD_VAR 0 6
12342: ARRAY
12343: ADD
12344: ST_TO_ADDR
12345: GO 12297
12347: POP
12348: POP
// end ;
12349: LD_VAR 0 3
12353: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12354: LD_INT 0
12356: PPUSH
12357: PPUSH
12358: PPUSH
12359: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12360: LD_ADDR_VAR 0 5
12364: PUSH
12365: LD_INT 22
12367: PUSH
12368: LD_VAR 0 1
12372: PUSH
12373: EMPTY
12374: LIST
12375: LIST
12376: PUSH
12377: LD_VAR 0 3
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: ST_TO_ADDR
// r := [ ] ;
12391: LD_ADDR_VAR 0 6
12395: PUSH
12396: EMPTY
12397: ST_TO_ADDR
// if tmp then
12398: LD_VAR 0 5
12402: IFFALSE 12471
// for i = 1 to tmp do
12404: LD_ADDR_VAR 0 7
12408: PUSH
12409: DOUBLE
12410: LD_INT 1
12412: DEC
12413: ST_TO_ADDR
12414: LD_VAR 0 5
12418: PUSH
12419: FOR_TO
12420: IFFALSE 12469
// if GetTag ( tmp [ i ] ) = tag then
12422: LD_VAR 0 5
12426: PUSH
12427: LD_VAR 0 7
12431: ARRAY
12432: PPUSH
12433: CALL_OW 110
12437: PUSH
12438: LD_VAR 0 2
12442: EQUAL
12443: IFFALSE 12467
// r := r ^ tmp [ i ] ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 6
12454: PUSH
12455: LD_VAR 0 5
12459: PUSH
12460: LD_VAR 0 7
12464: ARRAY
12465: ADD
12466: ST_TO_ADDR
12467: GO 12419
12469: POP
12470: POP
// result := r ;
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: LD_VAR 0 6
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 4
12485: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
// tmp := plist ;
12491: LD_ADDR_VAR 0 5
12495: PUSH
12496: LD_VAR 0 2
12500: ST_TO_ADDR
// if tmp then
12501: LD_VAR 0 5
12505: IFFALSE 12582
// begin for i = 1 to tmp do
12507: LD_ADDR_VAR 0 6
12511: PUSH
12512: DOUBLE
12513: LD_INT 1
12515: DEC
12516: ST_TO_ADDR
12517: LD_VAR 0 5
12521: PUSH
12522: FOR_TO
12523: IFFALSE 12570
// if GetTag ( tmp [ i ] ) <> tag then
12525: LD_VAR 0 5
12529: PUSH
12530: LD_VAR 0 6
12534: ARRAY
12535: PPUSH
12536: CALL_OW 110
12540: PUSH
12541: LD_VAR 0 3
12545: NONEQUAL
12546: IFFALSE 12568
// SetTag ( tmp [ i ] , tag ) ;
12548: LD_VAR 0 5
12552: PUSH
12553: LD_VAR 0 6
12557: ARRAY
12558: PPUSH
12559: LD_VAR 0 3
12563: PPUSH
12564: CALL_OW 109
12568: GO 12522
12570: POP
12571: POP
// result := true ;
12572: LD_ADDR_VAR 0 4
12576: PUSH
12577: LD_INT 1
12579: ST_TO_ADDR
// end else
12580: GO 12590
// result := false ;
12582: LD_ADDR_VAR 0 4
12586: PUSH
12587: LD_INT 0
12589: ST_TO_ADDR
// end ;
12590: LD_VAR 0 4
12594: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12595: LD_INT 0
12597: PPUSH
12598: PPUSH
12599: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12600: LD_ADDR_VAR 0 4
12604: PUSH
12605: LD_VAR 0 1
12609: PPUSH
12610: LD_VAR 0 2
12614: PPUSH
12615: EMPTY
12616: PPUSH
12617: CALL 12354 0 3
12621: ST_TO_ADDR
// if tmp then
12622: LD_VAR 0 4
12626: IFFALSE 12678
// begin for i = 1 to tmp do
12628: LD_ADDR_VAR 0 5
12632: PUSH
12633: DOUBLE
12634: LD_INT 1
12636: DEC
12637: ST_TO_ADDR
12638: LD_VAR 0 4
12642: PUSH
12643: FOR_TO
12644: IFFALSE 12666
// SetTag ( tmp [ i ] , 0 ) ;
12646: LD_VAR 0 4
12650: PUSH
12651: LD_VAR 0 5
12655: ARRAY
12656: PPUSH
12657: LD_INT 0
12659: PPUSH
12660: CALL_OW 109
12664: GO 12643
12666: POP
12667: POP
// result := true ;
12668: LD_ADDR_VAR 0 3
12672: PUSH
12673: LD_INT 1
12675: ST_TO_ADDR
// end else
12676: GO 12686
// result := false ;
12678: LD_ADDR_VAR 0 3
12682: PUSH
12683: LD_INT 0
12685: ST_TO_ADDR
// end ;
12686: LD_VAR 0 3
12690: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12691: LD_INT 0
12693: PPUSH
12694: PPUSH
12695: PPUSH
12696: PPUSH
12697: PPUSH
// sort_list := [ ] ;
12698: LD_ADDR_VAR 0 5
12702: PUSH
12703: EMPTY
12704: ST_TO_ADDR
// for i = 1 to list do
12705: LD_ADDR_VAR 0 3
12709: PUSH
12710: DOUBLE
12711: LD_INT 1
12713: DEC
12714: ST_TO_ADDR
12715: LD_VAR 0 1
12719: PUSH
12720: FOR_TO
12721: IFFALSE 12883
// begin if i = 1 then
12723: LD_VAR 0 3
12727: PUSH
12728: LD_INT 1
12730: EQUAL
12731: IFFALSE 12757
// sort_list := sort_list ^ list [ i ] else
12733: LD_ADDR_VAR 0 5
12737: PUSH
12738: LD_VAR 0 5
12742: PUSH
12743: LD_VAR 0 1
12747: PUSH
12748: LD_VAR 0 3
12752: ARRAY
12753: ADD
12754: ST_TO_ADDR
12755: GO 12881
// begin for j = 1 to sort_list do
12757: LD_ADDR_VAR 0 4
12761: PUSH
12762: DOUBLE
12763: LD_INT 1
12765: DEC
12766: ST_TO_ADDR
12767: LD_VAR 0 5
12771: PUSH
12772: FOR_TO
12773: IFFALSE 12850
// begin add := false ;
12775: LD_ADDR_VAR 0 6
12779: PUSH
12780: LD_INT 0
12782: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12783: LD_VAR 0 1
12787: PUSH
12788: LD_VAR 0 3
12792: ARRAY
12793: PUSH
12794: LD_VAR 0 5
12798: PUSH
12799: LD_VAR 0 4
12803: ARRAY
12804: LESS
12805: IFFALSE 12848
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12807: LD_ADDR_VAR 0 5
12811: PUSH
12812: LD_VAR 0 5
12816: PPUSH
12817: LD_VAR 0 4
12821: PPUSH
12822: LD_VAR 0 1
12826: PUSH
12827: LD_VAR 0 3
12831: ARRAY
12832: PPUSH
12833: CALL_OW 2
12837: ST_TO_ADDR
// add := true ;
12838: LD_ADDR_VAR 0 6
12842: PUSH
12843: LD_INT 1
12845: ST_TO_ADDR
// break ;
12846: GO 12850
// end ; end ;
12848: GO 12772
12850: POP
12851: POP
// if not add then
12852: LD_VAR 0 6
12856: NOT
12857: IFFALSE 12881
// sort_list := sort_list ^ list [ i ] ;
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_VAR 0 5
12868: PUSH
12869: LD_VAR 0 1
12873: PUSH
12874: LD_VAR 0 3
12878: ARRAY
12879: ADD
12880: ST_TO_ADDR
// end ; end ;
12881: GO 12720
12883: POP
12884: POP
// result := sort_list ;
12885: LD_ADDR_VAR 0 2
12889: PUSH
12890: LD_VAR 0 5
12894: ST_TO_ADDR
// end ;
12895: LD_VAR 0 2
12899: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12900: LD_INT 0
12902: PPUSH
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// sort_list := [ ] ;
12907: LD_ADDR_VAR 0 5
12911: PUSH
12912: EMPTY
12913: ST_TO_ADDR
// for i = 1 to list do
12914: LD_ADDR_VAR 0 3
12918: PUSH
12919: DOUBLE
12920: LD_INT 1
12922: DEC
12923: ST_TO_ADDR
12924: LD_VAR 0 1
12928: PUSH
12929: FOR_TO
12930: IFFALSE 13092
// begin if i = 1 then
12932: LD_VAR 0 3
12936: PUSH
12937: LD_INT 1
12939: EQUAL
12940: IFFALSE 12966
// sort_list := sort_list ^ list [ i ] else
12942: LD_ADDR_VAR 0 5
12946: PUSH
12947: LD_VAR 0 5
12951: PUSH
12952: LD_VAR 0 1
12956: PUSH
12957: LD_VAR 0 3
12961: ARRAY
12962: ADD
12963: ST_TO_ADDR
12964: GO 13090
// begin for j = 1 to sort_list do
12966: LD_ADDR_VAR 0 4
12970: PUSH
12971: DOUBLE
12972: LD_INT 1
12974: DEC
12975: ST_TO_ADDR
12976: LD_VAR 0 5
12980: PUSH
12981: FOR_TO
12982: IFFALSE 13059
// begin add := false ;
12984: LD_ADDR_VAR 0 6
12988: PUSH
12989: LD_INT 0
12991: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12992: LD_VAR 0 1
12996: PUSH
12997: LD_VAR 0 3
13001: ARRAY
13002: PUSH
13003: LD_VAR 0 5
13007: PUSH
13008: LD_VAR 0 4
13012: ARRAY
13013: GREATER
13014: IFFALSE 13057
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13016: LD_ADDR_VAR 0 5
13020: PUSH
13021: LD_VAR 0 5
13025: PPUSH
13026: LD_VAR 0 4
13030: PPUSH
13031: LD_VAR 0 1
13035: PUSH
13036: LD_VAR 0 3
13040: ARRAY
13041: PPUSH
13042: CALL_OW 2
13046: ST_TO_ADDR
// add := true ;
13047: LD_ADDR_VAR 0 6
13051: PUSH
13052: LD_INT 1
13054: ST_TO_ADDR
// break ;
13055: GO 13059
// end ; end ;
13057: GO 12981
13059: POP
13060: POP
// if not add then
13061: LD_VAR 0 6
13065: NOT
13066: IFFALSE 13090
// sort_list := sort_list ^ list [ i ] ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_VAR 0 5
13077: PUSH
13078: LD_VAR 0 1
13082: PUSH
13083: LD_VAR 0 3
13087: ARRAY
13088: ADD
13089: ST_TO_ADDR
// end ; end ;
13090: GO 12929
13092: POP
13093: POP
// result := sort_list ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 5
13103: ST_TO_ADDR
// end ;
13104: LD_VAR 0 2
13108: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13109: LD_INT 0
13111: PPUSH
13112: PPUSH
13113: PPUSH
13114: PPUSH
13115: PPUSH
13116: PPUSH
// tmp := [ ] ;
13117: LD_ADDR_VAR 0 8
13121: PUSH
13122: EMPTY
13123: ST_TO_ADDR
// r := [ ] ;
13124: LD_ADDR_VAR 0 7
13128: PUSH
13129: EMPTY
13130: ST_TO_ADDR
// add := false ;
13131: LD_ADDR_VAR 0 9
13135: PUSH
13136: LD_INT 0
13138: ST_TO_ADDR
// if plist then
13139: LD_VAR 0 2
13143: IFFALSE 13219
// begin for i = 1 to plist do
13145: LD_ADDR_VAR 0 5
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_VAR 0 2
13159: PUSH
13160: FOR_TO
13161: IFFALSE 13215
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13163: LD_ADDR_VAR 0 8
13167: PUSH
13168: LD_VAR 0 8
13172: PUSH
13173: LD_VAR 0 2
13177: PUSH
13178: LD_VAR 0 5
13182: ARRAY
13183: PUSH
13184: LD_VAR 0 2
13188: PUSH
13189: LD_VAR 0 5
13193: ARRAY
13194: PPUSH
13195: LD_VAR 0 3
13199: PPUSH
13200: CALL_OW 259
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: ADD
13212: ST_TO_ADDR
// end ;
13213: GO 13160
13215: POP
13216: POP
// end else
13217: GO 13227
// result := false ;
13219: LD_ADDR_VAR 0 4
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// if tmp then
13227: LD_VAR 0 8
13231: IFFALSE 13405
// begin r := r ^ [ tmp [ 1 ] ] ;
13233: LD_ADDR_VAR 0 7
13237: PUSH
13238: LD_VAR 0 7
13242: PUSH
13243: LD_VAR 0 8
13247: PUSH
13248: LD_INT 1
13250: ARRAY
13251: PUSH
13252: EMPTY
13253: LIST
13254: ADD
13255: ST_TO_ADDR
// for i = 2 to tmp do
13256: LD_ADDR_VAR 0 5
13260: PUSH
13261: DOUBLE
13262: LD_INT 2
13264: DEC
13265: ST_TO_ADDR
13266: LD_VAR 0 8
13270: PUSH
13271: FOR_TO
13272: IFFALSE 13403
// begin for j = 1 to r do
13274: LD_ADDR_VAR 0 6
13278: PUSH
13279: DOUBLE
13280: LD_INT 1
13282: DEC
13283: ST_TO_ADDR
13284: LD_VAR 0 7
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13367
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13292: LD_VAR 0 8
13296: PUSH
13297: LD_VAR 0 5
13301: ARRAY
13302: PUSH
13303: LD_INT 2
13305: ARRAY
13306: PUSH
13307: LD_VAR 0 7
13311: PUSH
13312: LD_VAR 0 6
13316: ARRAY
13317: PUSH
13318: LD_INT 2
13320: ARRAY
13321: LESS
13322: IFFALSE 13365
// begin r := Insert ( r , j , tmp [ i ] ) ;
13324: LD_ADDR_VAR 0 7
13328: PUSH
13329: LD_VAR 0 7
13333: PPUSH
13334: LD_VAR 0 6
13338: PPUSH
13339: LD_VAR 0 8
13343: PUSH
13344: LD_VAR 0 5
13348: ARRAY
13349: PPUSH
13350: CALL_OW 2
13354: ST_TO_ADDR
// add := true ;
13355: LD_ADDR_VAR 0 9
13359: PUSH
13360: LD_INT 1
13362: ST_TO_ADDR
// break ;
13363: GO 13367
// end ; end ;
13365: GO 13289
13367: POP
13368: POP
// if not add then
13369: LD_VAR 0 9
13373: NOT
13374: IFFALSE 13401
// r := r ^ [ tmp [ i ] ] ;
13376: LD_ADDR_VAR 0 7
13380: PUSH
13381: LD_VAR 0 7
13385: PUSH
13386: LD_VAR 0 8
13390: PUSH
13391: LD_VAR 0 5
13395: ARRAY
13396: PUSH
13397: EMPTY
13398: LIST
13399: ADD
13400: ST_TO_ADDR
// end ;
13401: GO 13271
13403: POP
13404: POP
// end ; result := r ;
13405: LD_ADDR_VAR 0 4
13409: PUSH
13410: LD_VAR 0 7
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 4
13419: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
13426: PPUSH
13427: PPUSH
// tmp := [ ] ;
13428: LD_ADDR_VAR 0 8
13432: PUSH
13433: EMPTY
13434: ST_TO_ADDR
// r := [ ] ;
13435: LD_ADDR_VAR 0 7
13439: PUSH
13440: EMPTY
13441: ST_TO_ADDR
// add := false ;
13442: LD_ADDR_VAR 0 9
13446: PUSH
13447: LD_INT 0
13449: ST_TO_ADDR
// if plist then
13450: LD_VAR 0 2
13454: IFFALSE 13530
// begin for i = 1 to plist do
13456: LD_ADDR_VAR 0 5
13460: PUSH
13461: DOUBLE
13462: LD_INT 1
13464: DEC
13465: ST_TO_ADDR
13466: LD_VAR 0 2
13470: PUSH
13471: FOR_TO
13472: IFFALSE 13526
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13474: LD_ADDR_VAR 0 8
13478: PUSH
13479: LD_VAR 0 8
13483: PUSH
13484: LD_VAR 0 2
13488: PUSH
13489: LD_VAR 0 5
13493: ARRAY
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_VAR 0 5
13504: ARRAY
13505: PPUSH
13506: LD_VAR 0 3
13510: PPUSH
13511: CALL_OW 259
13515: PUSH
13516: EMPTY
13517: LIST
13518: LIST
13519: PUSH
13520: EMPTY
13521: LIST
13522: ADD
13523: ST_TO_ADDR
// end ;
13524: GO 13471
13526: POP
13527: POP
// end else
13528: GO 13538
// result := false ;
13530: LD_ADDR_VAR 0 4
13534: PUSH
13535: LD_INT 0
13537: ST_TO_ADDR
// if tmp then
13538: LD_VAR 0 8
13542: IFFALSE 13716
// begin r := r ^ [ tmp [ 1 ] ] ;
13544: LD_ADDR_VAR 0 7
13548: PUSH
13549: LD_VAR 0 7
13553: PUSH
13554: LD_VAR 0 8
13558: PUSH
13559: LD_INT 1
13561: ARRAY
13562: PUSH
13563: EMPTY
13564: LIST
13565: ADD
13566: ST_TO_ADDR
// for i = 2 to tmp do
13567: LD_ADDR_VAR 0 5
13571: PUSH
13572: DOUBLE
13573: LD_INT 2
13575: DEC
13576: ST_TO_ADDR
13577: LD_VAR 0 8
13581: PUSH
13582: FOR_TO
13583: IFFALSE 13714
// begin for j = 1 to r do
13585: LD_ADDR_VAR 0 6
13589: PUSH
13590: DOUBLE
13591: LD_INT 1
13593: DEC
13594: ST_TO_ADDR
13595: LD_VAR 0 7
13599: PUSH
13600: FOR_TO
13601: IFFALSE 13678
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13603: LD_VAR 0 8
13607: PUSH
13608: LD_VAR 0 5
13612: ARRAY
13613: PUSH
13614: LD_INT 2
13616: ARRAY
13617: PUSH
13618: LD_VAR 0 7
13622: PUSH
13623: LD_VAR 0 6
13627: ARRAY
13628: PUSH
13629: LD_INT 2
13631: ARRAY
13632: GREATER
13633: IFFALSE 13676
// begin r := Insert ( r , j , tmp [ i ] ) ;
13635: LD_ADDR_VAR 0 7
13639: PUSH
13640: LD_VAR 0 7
13644: PPUSH
13645: LD_VAR 0 6
13649: PPUSH
13650: LD_VAR 0 8
13654: PUSH
13655: LD_VAR 0 5
13659: ARRAY
13660: PPUSH
13661: CALL_OW 2
13665: ST_TO_ADDR
// add := true ;
13666: LD_ADDR_VAR 0 9
13670: PUSH
13671: LD_INT 1
13673: ST_TO_ADDR
// break ;
13674: GO 13678
// end ; end ;
13676: GO 13600
13678: POP
13679: POP
// if not add then
13680: LD_VAR 0 9
13684: NOT
13685: IFFALSE 13712
// r := r ^ [ tmp [ i ] ] ;
13687: LD_ADDR_VAR 0 7
13691: PUSH
13692: LD_VAR 0 7
13696: PUSH
13697: LD_VAR 0 8
13701: PUSH
13702: LD_VAR 0 5
13706: ARRAY
13707: PUSH
13708: EMPTY
13709: LIST
13710: ADD
13711: ST_TO_ADDR
// end ;
13712: GO 13582
13714: POP
13715: POP
// end ; result := r ;
13716: LD_ADDR_VAR 0 4
13720: PUSH
13721: LD_VAR 0 7
13725: ST_TO_ADDR
// end ;
13726: LD_VAR 0 4
13730: RET
// export function MCF_Clear ( side ) ; var i ; begin
13731: LD_INT 0
13733: PPUSH
13734: PPUSH
// for i = 1 to 100 do
13735: LD_ADDR_VAR 0 3
13739: PUSH
13740: DOUBLE
13741: LD_INT 1
13743: DEC
13744: ST_TO_ADDR
13745: LD_INT 100
13747: PUSH
13748: FOR_TO
13749: IFFALSE 13785
// if MCF_Tag ( side , i , [ ] ) then
13751: LD_VAR 0 1
13755: PPUSH
13756: LD_VAR 0 3
13760: PPUSH
13761: EMPTY
13762: PPUSH
13763: CALL 12354 0 3
13767: IFFALSE 13783
// MCF_ClearTag ( side , i ) ;
13769: LD_VAR 0 1
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: CALL 12595 0 2
13783: GO 13748
13785: POP
13786: POP
// result := true ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 1
13794: ST_TO_ADDR
// end ;
13795: LD_VAR 0 2
13799: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13800: LD_INT 0
13802: PPUSH
13803: PPUSH
13804: PPUSH
// for i = 1 to plist do
13805: LD_ADDR_VAR 0 4
13809: PUSH
13810: DOUBLE
13811: LD_INT 1
13813: DEC
13814: ST_TO_ADDR
13815: LD_VAR 0 1
13819: PUSH
13820: FOR_TO
13821: IFFALSE 13870
// if MCF_HasClass ( plist [ i ] ) = n then
13823: LD_VAR 0 1
13827: PUSH
13828: LD_VAR 0 4
13832: ARRAY
13833: PPUSH
13834: CALL 14357 0 1
13838: PUSH
13839: LD_VAR 0 2
13843: EQUAL
13844: IFFALSE 13868
// tmp := tmp ^ plist [ i ] ;
13846: LD_ADDR_VAR 0 5
13850: PUSH
13851: LD_VAR 0 5
13855: PUSH
13856: LD_VAR 0 1
13860: PUSH
13861: LD_VAR 0 4
13865: ARRAY
13866: ADD
13867: ST_TO_ADDR
13868: GO 13820
13870: POP
13871: POP
// result := tmp ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_VAR 0 5
13881: ST_TO_ADDR
// end ;
13882: LD_VAR 0 3
13886: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13887: LD_INT 0
13889: PPUSH
13890: PPUSH
13891: PPUSH
// if mreg = ToArm then
13892: LD_VAR 0 2
13896: PUSH
13897: LD_STRING ToArm
13899: EQUAL
13900: IFFALSE 14005
// begin tmp := MREG_ToArm [ side ] ;
13902: LD_ADDR_VAR 0 6
13906: PUSH
13907: LD_EXP 56
13911: PUSH
13912: LD_VAR 0 1
13916: ARRAY
13917: ST_TO_ADDR
// if tmp = 0 then
13918: LD_VAR 0 6
13922: PUSH
13923: LD_INT 0
13925: EQUAL
13926: IFFALSE 13932
// exit else
13928: GO 14352
13930: GO 14005
// begin for i = MREG_ToArm [ side ] downto n do
13932: LD_ADDR_VAR 0 5
13936: PUSH
13937: DOUBLE
13938: LD_EXP 56
13942: PUSH
13943: LD_VAR 0 1
13947: ARRAY
13948: INC
13949: ST_TO_ADDR
13950: LD_VAR 0 3
13954: PUSH
13955: FOR_DOWNTO
13956: IFFALSE 13978
// tmp := Delete ( tmp , 1 ) ;
13958: LD_ADDR_VAR 0 6
13962: PUSH
13963: LD_VAR 0 6
13967: PPUSH
13968: LD_INT 1
13970: PPUSH
13971: CALL_OW 3
13975: ST_TO_ADDR
13976: GO 13955
13978: POP
13979: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13980: LD_ADDR_EXP 56
13984: PUSH
13985: LD_EXP 56
13989: PPUSH
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_VAR 0 6
13999: PPUSH
14000: CALL_OW 1
14004: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14005: LD_VAR 0 2
14009: PUSH
14010: LD_STRING ToDep
14012: EQUAL
14013: IFFALSE 14118
// begin tmp := MREG_ToDep [ side ] ;
14015: LD_ADDR_VAR 0 6
14019: PUSH
14020: LD_EXP 57
14024: PUSH
14025: LD_VAR 0 1
14029: ARRAY
14030: ST_TO_ADDR
// if tmp = 0 then
14031: LD_VAR 0 6
14035: PUSH
14036: LD_INT 0
14038: EQUAL
14039: IFFALSE 14045
// exit else
14041: GO 14352
14043: GO 14118
// begin for i = MREG_ToDep [ side ] downto n do
14045: LD_ADDR_VAR 0 5
14049: PUSH
14050: DOUBLE
14051: LD_EXP 57
14055: PUSH
14056: LD_VAR 0 1
14060: ARRAY
14061: INC
14062: ST_TO_ADDR
14063: LD_VAR 0 3
14067: PUSH
14068: FOR_DOWNTO
14069: IFFALSE 14091
// tmp := Delete ( tmp , 1 ) ;
14071: LD_ADDR_VAR 0 6
14075: PUSH
14076: LD_VAR 0 6
14080: PPUSH
14081: LD_INT 1
14083: PPUSH
14084: CALL_OW 3
14088: ST_TO_ADDR
14089: GO 14068
14091: POP
14092: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14093: LD_ADDR_EXP 57
14097: PUSH
14098: LD_EXP 57
14102: PPUSH
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 6
14112: PPUSH
14113: CALL_OW 1
14117: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14118: LD_VAR 0 2
14122: PUSH
14123: LD_STRING ToFac
14125: EQUAL
14126: IFFALSE 14231
// begin tmp := MREG_ToFac [ side ] ;
14128: LD_ADDR_VAR 0 6
14132: PUSH
14133: LD_EXP 55
14137: PUSH
14138: LD_VAR 0 1
14142: ARRAY
14143: ST_TO_ADDR
// if tmp = 0 then
14144: LD_VAR 0 6
14148: PUSH
14149: LD_INT 0
14151: EQUAL
14152: IFFALSE 14158
// exit else
14154: GO 14352
14156: GO 14231
// begin for i = MREG_ToFac [ side ] downto n do
14158: LD_ADDR_VAR 0 5
14162: PUSH
14163: DOUBLE
14164: LD_EXP 55
14168: PUSH
14169: LD_VAR 0 1
14173: ARRAY
14174: INC
14175: ST_TO_ADDR
14176: LD_VAR 0 3
14180: PUSH
14181: FOR_DOWNTO
14182: IFFALSE 14204
// tmp := Delete ( tmp , 1 ) ;
14184: LD_ADDR_VAR 0 6
14188: PUSH
14189: LD_VAR 0 6
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 3
14201: ST_TO_ADDR
14202: GO 14181
14204: POP
14205: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14206: LD_ADDR_EXP 55
14210: PUSH
14211: LD_EXP 55
14215: PPUSH
14216: LD_VAR 0 1
14220: PPUSH
14221: LD_VAR 0 6
14225: PPUSH
14226: CALL_OW 1
14230: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14231: LD_VAR 0 2
14235: PUSH
14236: LD_STRING ToLab
14238: EQUAL
14239: IFFALSE 14344
// begin tmp := MREG_ToLab [ side ] ;
14241: LD_ADDR_VAR 0 6
14245: PUSH
14246: LD_EXP 54
14250: PUSH
14251: LD_VAR 0 1
14255: ARRAY
14256: ST_TO_ADDR
// if tmp = 0 then
14257: LD_VAR 0 6
14261: PUSH
14262: LD_INT 0
14264: EQUAL
14265: IFFALSE 14271
// exit else
14267: GO 14352
14269: GO 14344
// begin for i = MREG_ToLab [ side ] downto n do
14271: LD_ADDR_VAR 0 5
14275: PUSH
14276: DOUBLE
14277: LD_EXP 54
14281: PUSH
14282: LD_VAR 0 1
14286: ARRAY
14287: INC
14288: ST_TO_ADDR
14289: LD_VAR 0 3
14293: PUSH
14294: FOR_DOWNTO
14295: IFFALSE 14317
// tmp := Delete ( tmp , 1 ) ;
14297: LD_ADDR_VAR 0 6
14301: PUSH
14302: LD_VAR 0 6
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 3
14314: ST_TO_ADDR
14315: GO 14294
14317: POP
14318: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14319: LD_ADDR_EXP 54
14323: PUSH
14324: LD_EXP 54
14328: PPUSH
14329: LD_VAR 0 1
14333: PPUSH
14334: LD_VAR 0 6
14338: PPUSH
14339: CALL_OW 1
14343: ST_TO_ADDR
// end ; end ; result := true ;
14344: LD_ADDR_VAR 0 4
14348: PUSH
14349: LD_INT 1
14351: ST_TO_ADDR
// end ;
14352: LD_VAR 0 4
14356: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
14361: PPUSH
// side := GetSide ( unit ) ;
14362: LD_ADDR_VAR 0 4
14366: PUSH
14367: LD_VAR 0 1
14371: PPUSH
14372: CALL_OW 255
14376: ST_TO_ADDR
// tmp := 0 ;
14377: LD_ADDR_VAR 0 3
14381: PUSH
14382: LD_INT 0
14384: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14385: LD_VAR 0 1
14389: PUSH
14390: LD_EXP 56
14394: PUSH
14395: LD_VAR 0 4
14399: ARRAY
14400: IN
14401: IFFALSE 14411
// tmp := 1 ;
14403: LD_ADDR_VAR 0 3
14407: PUSH
14408: LD_INT 1
14410: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14411: LD_VAR 0 1
14415: PUSH
14416: LD_EXP 57
14420: PUSH
14421: LD_VAR 0 4
14425: ARRAY
14426: IN
14427: IFFALSE 14437
// tmp := 2 ;
14429: LD_ADDR_VAR 0 3
14433: PUSH
14434: LD_INT 2
14436: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14437: LD_VAR 0 1
14441: PUSH
14442: LD_EXP 55
14446: PUSH
14447: LD_VAR 0 4
14451: ARRAY
14452: IN
14453: IFFALSE 14463
// tmp := 3 ;
14455: LD_ADDR_VAR 0 3
14459: PUSH
14460: LD_INT 3
14462: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_EXP 54
14472: PUSH
14473: LD_VAR 0 4
14477: ARRAY
14478: IN
14479: IFFALSE 14489
// tmp := 4 ;
14481: LD_ADDR_VAR 0 3
14485: PUSH
14486: LD_INT 4
14488: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 68
14498: PUSH
14499: LD_VAR 0 4
14503: ARRAY
14504: IN
14505: IFFALSE 14515
// tmp := 5 ;
14507: LD_ADDR_VAR 0 3
14511: PUSH
14512: LD_INT 5
14514: ST_TO_ADDR
// result := tmp ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_VAR 0 3
14524: ST_TO_ADDR
// end ;
14525: LD_VAR 0 2
14529: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14530: LD_INT 0
14532: PPUSH
14533: PPUSH
// if mreg = ToArm then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_STRING ToArm
14541: EQUAL
14542: IFFALSE 14631
// for i = MREG_ToArm [ side ] downto 1 do
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: DOUBLE
14550: LD_EXP 56
14554: PUSH
14555: LD_VAR 0 1
14559: ARRAY
14560: INC
14561: ST_TO_ADDR
14562: LD_INT 1
14564: PUSH
14565: FOR_DOWNTO
14566: IFFALSE 14629
// if MREG_ToArm [ side ] [ i ] = unit then
14568: LD_EXP 56
14572: PUSH
14573: LD_VAR 0 1
14577: ARRAY
14578: PUSH
14579: LD_VAR 0 5
14583: ARRAY
14584: PUSH
14585: LD_VAR 0 3
14589: EQUAL
14590: IFFALSE 14627
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14592: LD_ADDR_EXP 56
14596: PUSH
14597: LD_EXP 56
14601: PPUSH
14602: LD_EXP 56
14606: PUSH
14607: LD_VAR 0 1
14611: ARRAY
14612: PUSH
14613: LD_VAR 0 5
14617: ARRAY
14618: PPUSH
14619: LD_INT 1
14621: PPUSH
14622: CALL 31289 0 3
14626: ST_TO_ADDR
// end ;
14627: GO 14565
14629: POP
14630: POP
// if mreg = ToDep then
14631: LD_VAR 0 2
14635: PUSH
14636: LD_STRING ToDep
14638: EQUAL
14639: IFFALSE 14728
// for i = MREG_ToDep [ side ] downto 1 do
14641: LD_ADDR_VAR 0 5
14645: PUSH
14646: DOUBLE
14647: LD_EXP 57
14651: PUSH
14652: LD_VAR 0 1
14656: ARRAY
14657: INC
14658: ST_TO_ADDR
14659: LD_INT 1
14661: PUSH
14662: FOR_DOWNTO
14663: IFFALSE 14726
// if MREG_ToDep [ side ] [ i ] = unit then
14665: LD_EXP 57
14669: PUSH
14670: LD_VAR 0 1
14674: ARRAY
14675: PUSH
14676: LD_VAR 0 5
14680: ARRAY
14681: PUSH
14682: LD_VAR 0 3
14686: EQUAL
14687: IFFALSE 14724
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14689: LD_ADDR_EXP 57
14693: PUSH
14694: LD_EXP 57
14698: PPUSH
14699: LD_EXP 57
14703: PUSH
14704: LD_VAR 0 1
14708: ARRAY
14709: PUSH
14710: LD_VAR 0 5
14714: ARRAY
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: CALL 31289 0 3
14723: ST_TO_ADDR
// end ;
14724: GO 14662
14726: POP
14727: POP
// if mreg = ToFac then
14728: LD_VAR 0 2
14732: PUSH
14733: LD_STRING ToFac
14735: EQUAL
14736: IFFALSE 14825
// for i = MREG_ToFac [ side ] downto 1 do
14738: LD_ADDR_VAR 0 5
14742: PUSH
14743: DOUBLE
14744: LD_EXP 55
14748: PUSH
14749: LD_VAR 0 1
14753: ARRAY
14754: INC
14755: ST_TO_ADDR
14756: LD_INT 1
14758: PUSH
14759: FOR_DOWNTO
14760: IFFALSE 14823
// if MREG_ToFac [ side ] [ i ] = unit then
14762: LD_EXP 55
14766: PUSH
14767: LD_VAR 0 1
14771: ARRAY
14772: PUSH
14773: LD_VAR 0 5
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 3
14783: EQUAL
14784: IFFALSE 14821
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14786: LD_ADDR_EXP 55
14790: PUSH
14791: LD_EXP 55
14795: PPUSH
14796: LD_EXP 55
14800: PUSH
14801: LD_VAR 0 1
14805: ARRAY
14806: PUSH
14807: LD_VAR 0 5
14811: ARRAY
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL 31289 0 3
14820: ST_TO_ADDR
// end ;
14821: GO 14759
14823: POP
14824: POP
// if mreg = ToLab then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_STRING ToLab
14832: EQUAL
14833: IFFALSE 14922
// for i = MREG_ToLab [ side ] downto 1 do
14835: LD_ADDR_VAR 0 5
14839: PUSH
14840: DOUBLE
14841: LD_EXP 54
14845: PUSH
14846: LD_VAR 0 1
14850: ARRAY
14851: INC
14852: ST_TO_ADDR
14853: LD_INT 1
14855: PUSH
14856: FOR_DOWNTO
14857: IFFALSE 14920
// if MREG_ToLab [ side ] [ i ] = unit then
14859: LD_EXP 54
14863: PUSH
14864: LD_VAR 0 1
14868: ARRAY
14869: PUSH
14870: LD_VAR 0 5
14874: ARRAY
14875: PUSH
14876: LD_VAR 0 3
14880: EQUAL
14881: IFFALSE 14918
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14883: LD_ADDR_EXP 54
14887: PUSH
14888: LD_EXP 54
14892: PPUSH
14893: LD_EXP 54
14897: PUSH
14898: LD_VAR 0 1
14902: ARRAY
14903: PUSH
14904: LD_VAR 0 5
14908: ARRAY
14909: PPUSH
14910: LD_INT 1
14912: PPUSH
14913: CALL 31289 0 3
14917: ST_TO_ADDR
// end ;
14918: GO 14856
14920: POP
14921: POP
// end ;
14922: LD_VAR 0 4
14926: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// result := false ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14939: LD_ADDR_VAR 0 3
14943: PUSH
14944: DOUBLE
14945: LD_INT 1
14947: DEC
14948: ST_TO_ADDR
14949: LD_EXP 46
14953: PUSH
14954: FOR_TO
14955: IFFALSE 15019
// if MREG_ToBuild [ i ] [ 1 ] = side then
14957: LD_EXP 46
14961: PUSH
14962: LD_VAR 0 3
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_VAR 0 1
14976: EQUAL
14977: IFFALSE 15017
// begin if MREG_ToBuild [ i ] [ 1 ] then
14979: LD_EXP 46
14983: PUSH
14984: LD_VAR 0 3
14988: ARRAY
14989: PUSH
14990: LD_INT 1
14992: ARRAY
14993: IFFALSE 15017
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14995: LD_ADDR_VAR 0 2
14999: PUSH
15000: LD_EXP 46
15004: PUSH
15005: LD_VAR 0 3
15009: ARRAY
15010: PUSH
15011: LD_INT 1
15013: ARRAY
15014: ST_TO_ADDR
// break ;
15015: GO 15019
// end ; end ;
15017: GO 14954
15019: POP
15020: POP
// for i = 1 to MREG_ToRepair do
15021: LD_ADDR_VAR 0 3
15025: PUSH
15026: DOUBLE
15027: LD_INT 1
15029: DEC
15030: ST_TO_ADDR
15031: LD_EXP 47
15035: PUSH
15036: FOR_TO
15037: IFFALSE 15101
// if MREG_ToRepair [ i ] [ 1 ] = side then
15039: LD_EXP 47
15043: PUSH
15044: LD_VAR 0 3
15048: ARRAY
15049: PUSH
15050: LD_INT 1
15052: ARRAY
15053: PUSH
15054: LD_VAR 0 1
15058: EQUAL
15059: IFFALSE 15099
// begin if MREG_ToRepair [ i ] [ 1 ] then
15061: LD_EXP 47
15065: PUSH
15066: LD_VAR 0 3
15070: ARRAY
15071: PUSH
15072: LD_INT 1
15074: ARRAY
15075: IFFALSE 15099
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15077: LD_ADDR_VAR 0 2
15081: PUSH
15082: LD_EXP 47
15086: PUSH
15087: LD_VAR 0 3
15091: ARRAY
15092: PUSH
15093: LD_INT 1
15095: ARRAY
15096: ST_TO_ADDR
// break ;
15097: GO 15101
// end ; end ;
15099: GO 15036
15101: POP
15102: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15103: LD_VAR 0 1
15107: PPUSH
15108: LD_INT 57
15110: PUSH
15111: EMPTY
15112: LIST
15113: PPUSH
15114: CALL 11651 0 2
15118: IFFALSE 15145
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15120: LD_ADDR_VAR 0 2
15124: PUSH
15125: LD_VAR 0 1
15129: PPUSH
15130: LD_INT 57
15132: PUSH
15133: EMPTY
15134: LIST
15135: PPUSH
15136: CALL 11651 0 2
15140: PUSH
15141: LD_INT 1
15143: ARRAY
15144: ST_TO_ADDR
// end ;
15145: LD_VAR 0 2
15149: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15150: LD_INT 0
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
15156: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15157: LD_ADDR_VAR 0 6
15161: PUSH
15162: LD_VAR 0 1
15166: PPUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 3
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL 11651 0 2
15181: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15182: LD_ADDR_VAR 0 7
15186: PUSH
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 81
15194: PUSH
15195: LD_VAR 0 1
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PPUSH
15204: CALL 11651 0 2
15208: ST_TO_ADDR
// if not enemy then
15209: LD_VAR 0 7
15213: NOT
15214: IFFALSE 15226
// result := false else
15216: LD_ADDR_VAR 0 3
15220: PUSH
15221: LD_INT 0
15223: ST_TO_ADDR
15224: GO 15280
// begin scan := NearestUnit ( b , enemy ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 6
15235: PPUSH
15236: LD_VAR 0 7
15240: PPUSH
15241: CALL 32282 0 2
15245: ST_TO_ADDR
// if scan [ 2 ] < dist then
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 2
15253: ARRAY
15254: PUSH
15255: LD_VAR 0 2
15259: LESS
15260: IFFALSE 15272
// result := true else
15262: LD_ADDR_VAR 0 3
15266: PUSH
15267: LD_INT 1
15269: ST_TO_ADDR
15270: GO 15280
// result := false ;
15272: LD_ADDR_VAR 0 3
15276: PUSH
15277: LD_INT 0
15279: ST_TO_ADDR
// end ; end ;
15280: LD_VAR 0 3
15284: RET
// export function MCF_Info ( ) ; begin
15285: LD_INT 0
15287: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15288: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15290: PUSH
15291: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15293: ADD
15294: PUSH
15295: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15297: ADD
15298: PUSH
15299: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15301: ADD
15302: PUSH
15303: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15305: ADD
15306: PUSH
15307: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15325: ADD
15326: PPUSH
15327: CALL 8569 0 1
// end ; end_of_file
15331: LD_VAR 0 1
15335: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15336: LD_INT 0
15338: PPUSH
15339: PPUSH
15340: PPUSH
15341: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15342: LD_ADDR_VAR 0 5
15346: PUSH
15347: LD_VAR 0 1
15351: PPUSH
15352: LD_INT 2
15354: PUSH
15355: LD_INT 25
15357: PUSH
15358: LD_INT 2
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: LD_INT 25
15367: PUSH
15368: LD_INT 3
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PUSH
15375: LD_INT 25
15377: PUSH
15378: LD_INT 4
15380: PUSH
15381: EMPTY
15382: LIST
15383: LIST
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: PPUSH
15391: CALL 11651 0 2
15395: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15396: LD_ADDR_VAR 0 5
15400: PUSH
15401: LD_VAR 0 5
15405: PPUSH
15406: LD_INT 0
15408: PPUSH
15409: CALL 13800 0 2
15413: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15414: LD_ADDR_VAR 0 6
15418: PUSH
15419: LD_VAR 0 1
15423: PPUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_INT 1
15431: PPUSH
15432: CALL 13420 0 3
15436: ST_TO_ADDR
// if n > sk then
15437: LD_VAR 0 2
15441: PUSH
15442: LD_VAR 0 6
15446: GREATER
15447: IFFALSE 15459
// n := sk ;
15449: LD_ADDR_VAR 0 2
15453: PUSH
15454: LD_VAR 0 6
15458: ST_TO_ADDR
// for i = 1 to n do
15459: LD_ADDR_VAR 0 4
15463: PUSH
15464: DOUBLE
15465: LD_INT 1
15467: DEC
15468: ST_TO_ADDR
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_TO
15475: IFFALSE 15587
// if ( sk [ i ] [ 1 ] ) <> 0 then
15477: LD_VAR 0 6
15481: PUSH
15482: LD_VAR 0 4
15486: ARRAY
15487: PUSH
15488: LD_INT 1
15490: ARRAY
15491: PUSH
15492: LD_INT 0
15494: NONEQUAL
15495: IFFALSE 15585
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15497: LD_ADDR_EXP 53
15501: PUSH
15502: LD_EXP 53
15506: PPUSH
15507: LD_VAR 0 1
15511: PPUSH
15512: LD_VAR 0 6
15516: PUSH
15517: LD_VAR 0 4
15521: ARRAY
15522: PUSH
15523: LD_INT 1
15525: ARRAY
15526: PPUSH
15527: LD_INT 1
15529: PPUSH
15530: CALL 41960 0 4
15534: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15535: LD_ADDR_EXP 56
15539: PUSH
15540: LD_EXP 56
15544: PPUSH
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_EXP 56
15554: PUSH
15555: LD_VAR 0 1
15559: ARRAY
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 6
15569: PUSH
15570: LD_VAR 0 4
15574: ARRAY
15575: PUSH
15576: LD_INT 1
15578: ARRAY
15579: PPUSH
15580: CALL 31130 0 4
15584: ST_TO_ADDR
// end ;
15585: GO 15474
15587: POP
15588: POP
// end ;
15589: LD_VAR 0 3
15593: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15594: LD_INT 0
15596: PPUSH
15597: PPUSH
15598: PPUSH
15599: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 1
15609: PPUSH
15610: LD_INT 2
15612: PUSH
15613: LD_INT 25
15615: PUSH
15616: LD_INT 1
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PUSH
15623: LD_INT 25
15625: PUSH
15626: LD_INT 3
15628: PUSH
15629: EMPTY
15630: LIST
15631: LIST
15632: PUSH
15633: LD_INT 25
15635: PUSH
15636: LD_INT 4
15638: PUSH
15639: EMPTY
15640: LIST
15641: LIST
15642: PUSH
15643: EMPTY
15644: LIST
15645: LIST
15646: LIST
15647: LIST
15648: PPUSH
15649: CALL 11651 0 2
15653: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15654: LD_ADDR_VAR 0 5
15658: PUSH
15659: LD_VAR 0 5
15663: PPUSH
15664: LD_INT 0
15666: PPUSH
15667: CALL 13800 0 2
15671: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15672: LD_ADDR_VAR 0 6
15676: PUSH
15677: LD_VAR 0 1
15681: PPUSH
15682: LD_VAR 0 5
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL 13420 0 3
15694: ST_TO_ADDR
// if n > sk then
15695: LD_VAR 0 2
15699: PUSH
15700: LD_VAR 0 6
15704: GREATER
15705: IFFALSE 15717
// n := sk ;
15707: LD_ADDR_VAR 0 2
15711: PUSH
15712: LD_VAR 0 6
15716: ST_TO_ADDR
// for i = 1 to n do
15717: LD_ADDR_VAR 0 4
15721: PUSH
15722: DOUBLE
15723: LD_INT 1
15725: DEC
15726: ST_TO_ADDR
15727: LD_VAR 0 2
15731: PUSH
15732: FOR_TO
15733: IFFALSE 15845
// if ( sk [ i ] [ 1 ] ) <> 0 then
15735: LD_VAR 0 6
15739: PUSH
15740: LD_VAR 0 4
15744: ARRAY
15745: PUSH
15746: LD_INT 1
15748: ARRAY
15749: PUSH
15750: LD_INT 0
15752: NONEQUAL
15753: IFFALSE 15843
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15755: LD_ADDR_EXP 53
15759: PUSH
15760: LD_EXP 53
15764: PPUSH
15765: LD_VAR 0 1
15769: PPUSH
15770: LD_VAR 0 6
15774: PUSH
15775: LD_VAR 0 4
15779: ARRAY
15780: PUSH
15781: LD_INT 1
15783: ARRAY
15784: PPUSH
15785: LD_INT 2
15787: PPUSH
15788: CALL 41960 0 4
15792: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15793: LD_ADDR_EXP 57
15797: PUSH
15798: LD_EXP 57
15802: PPUSH
15803: LD_VAR 0 1
15807: PPUSH
15808: LD_EXP 57
15812: PUSH
15813: LD_VAR 0 1
15817: ARRAY
15818: PUSH
15819: LD_INT 1
15821: PLUS
15822: PPUSH
15823: LD_VAR 0 6
15827: PUSH
15828: LD_VAR 0 4
15832: ARRAY
15833: PUSH
15834: LD_INT 1
15836: ARRAY
15837: PPUSH
15838: CALL 31130 0 4
15842: ST_TO_ADDR
// end ;
15843: GO 15732
15845: POP
15846: POP
// end ;
15847: LD_VAR 0 3
15851: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15858: LD_ADDR_VAR 0 5
15862: PUSH
15863: LD_VAR 0 1
15867: PPUSH
15868: LD_INT 2
15870: PUSH
15871: LD_INT 25
15873: PUSH
15874: LD_INT 1
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 25
15883: PUSH
15884: LD_INT 2
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PUSH
15891: LD_INT 25
15893: PUSH
15894: LD_INT 4
15896: PUSH
15897: EMPTY
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL 11651 0 2
15911: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15912: LD_ADDR_VAR 0 5
15916: PUSH
15917: LD_VAR 0 5
15921: PPUSH
15922: LD_INT 0
15924: PPUSH
15925: CALL 13800 0 2
15929: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 1
15939: PPUSH
15940: LD_VAR 0 5
15944: PPUSH
15945: LD_INT 3
15947: PPUSH
15948: CALL 13420 0 3
15952: ST_TO_ADDR
// if n > sk then
15953: LD_VAR 0 2
15957: PUSH
15958: LD_VAR 0 6
15962: GREATER
15963: IFFALSE 15975
// n := sk ;
15965: LD_ADDR_VAR 0 2
15969: PUSH
15970: LD_VAR 0 6
15974: ST_TO_ADDR
// for i = 1 to n do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 1
15983: DEC
15984: ST_TO_ADDR
15985: LD_VAR 0 2
15989: PUSH
15990: FOR_TO
15991: IFFALSE 16103
// if ( sk [ i ] [ 1 ] ) <> 0 then
15993: LD_VAR 0 6
15997: PUSH
15998: LD_VAR 0 4
16002: ARRAY
16003: PUSH
16004: LD_INT 1
16006: ARRAY
16007: PUSH
16008: LD_INT 0
16010: NONEQUAL
16011: IFFALSE 16101
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16013: LD_ADDR_EXP 53
16017: PUSH
16018: LD_EXP 53
16022: PPUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 6
16032: PUSH
16033: LD_VAR 0 4
16037: ARRAY
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_INT 3
16045: PPUSH
16046: CALL 41960 0 4
16050: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16051: LD_ADDR_EXP 55
16055: PUSH
16056: LD_EXP 55
16060: PPUSH
16061: LD_VAR 0 1
16065: PPUSH
16066: LD_EXP 55
16070: PUSH
16071: LD_VAR 0 1
16075: ARRAY
16076: PUSH
16077: LD_INT 1
16079: PLUS
16080: PPUSH
16081: LD_VAR 0 6
16085: PUSH
16086: LD_VAR 0 4
16090: ARRAY
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL 31130 0 4
16100: ST_TO_ADDR
// end ;
16101: GO 15990
16103: POP
16104: POP
// end ;
16105: LD_VAR 0 3
16109: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16116: LD_ADDR_VAR 0 5
16120: PUSH
16121: LD_VAR 0 1
16125: PPUSH
16126: LD_INT 2
16128: PUSH
16129: LD_INT 25
16131: PUSH
16132: LD_INT 1
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: LIST
16153: PPUSH
16154: CALL 11651 0 2
16158: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: LD_VAR 0 5
16168: PPUSH
16169: LD_INT 0
16171: PPUSH
16172: CALL 13800 0 2
16176: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16177: LD_ADDR_VAR 0 6
16181: PUSH
16182: LD_VAR 0 1
16186: PPUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_INT 4
16194: PPUSH
16195: CALL 13420 0 3
16199: ST_TO_ADDR
// if n > sk then
16200: LD_VAR 0 2
16204: PUSH
16205: LD_VAR 0 6
16209: GREATER
16210: IFFALSE 16222
// n := sk ;
16212: LD_ADDR_VAR 0 2
16216: PUSH
16217: LD_VAR 0 6
16221: ST_TO_ADDR
// for i = 1 to n do
16222: LD_ADDR_VAR 0 4
16226: PUSH
16227: DOUBLE
16228: LD_INT 1
16230: DEC
16231: ST_TO_ADDR
16232: LD_VAR 0 2
16236: PUSH
16237: FOR_TO
16238: IFFALSE 16350
// if ( sk [ i ] [ 1 ] ) <> 0 then
16240: LD_VAR 0 6
16244: PUSH
16245: LD_VAR 0 4
16249: ARRAY
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: PUSH
16255: LD_INT 0
16257: NONEQUAL
16258: IFFALSE 16348
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16260: LD_ADDR_EXP 53
16264: PUSH
16265: LD_EXP 53
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 4
16284: ARRAY
16285: PUSH
16286: LD_INT 1
16288: ARRAY
16289: PPUSH
16290: LD_INT 4
16292: PPUSH
16293: CALL 41960 0 4
16297: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16298: LD_ADDR_EXP 54
16302: PUSH
16303: LD_EXP 54
16307: PPUSH
16308: LD_VAR 0 1
16312: PPUSH
16313: LD_EXP 54
16317: PUSH
16318: LD_VAR 0 1
16322: ARRAY
16323: PUSH
16324: LD_INT 1
16326: PLUS
16327: PPUSH
16328: LD_VAR 0 6
16332: PUSH
16333: LD_VAR 0 4
16337: ARRAY
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 31130 0 4
16347: ST_TO_ADDR
// end ;
16348: GO 16237
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 3
16356: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 1
16372: PPUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 25
16378: PUSH
16379: LD_INT 1
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 2
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 25
16398: PUSH
16399: LD_INT 3
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: LD_INT 25
16408: PUSH
16409: LD_INT 4
16411: PUSH
16412: EMPTY
16413: LIST
16414: LIST
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PPUSH
16423: CALL 11651 0 2
16427: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16428: LD_ADDR_VAR 0 6
16432: PUSH
16433: LD_VAR 0 6
16437: PPUSH
16438: LD_INT 0
16440: PPUSH
16441: CALL 13800 0 2
16445: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16446: LD_ADDR_VAR 0 7
16450: PUSH
16451: LD_VAR 0 1
16455: PPUSH
16456: LD_VAR 0 6
16460: PPUSH
16461: LD_INT 1
16463: PPUSH
16464: CALL 13420 0 3
16468: ST_TO_ADDR
// if n > sk then
16469: LD_VAR 0 2
16473: PUSH
16474: LD_VAR 0 7
16478: GREATER
16479: IFFALSE 16491
// n := sk ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 7
16490: ST_TO_ADDR
// for i = 1 to n do
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: DOUBLE
16497: LD_INT 1
16499: DEC
16500: ST_TO_ADDR
16501: LD_VAR 0 2
16505: PUSH
16506: FOR_TO
16507: IFFALSE 16551
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16509: LD_ADDR_EXP 53
16513: PUSH
16514: LD_EXP 53
16518: PPUSH
16519: LD_VAR 0 1
16523: PPUSH
16524: LD_VAR 0 7
16528: PUSH
16529: LD_VAR 0 5
16533: ARRAY
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: LD_VAR 0 3
16543: PPUSH
16544: CALL 41960 0 4
16548: ST_TO_ADDR
// end ;
16549: GO 16506
16551: POP
16552: POP
// end ;
16553: LD_VAR 0 4
16557: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16558: LD_INT 0
16560: PPUSH
16561: PPUSH
16562: PPUSH
// b := false ;
16563: LD_ADDR_VAR 0 6
16567: PUSH
16568: LD_INT 0
16570: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16571: LD_VAR 0 3
16575: PUSH
16576: LD_INT 1
16578: PUSH
16579: LD_INT 9
16581: PUSH
16582: LD_INT 5
16584: PUSH
16585: LD_INT 8
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: LIST
16593: IN
16594: IFFALSE 16682
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16596: LD_VAR 0 1
16600: PPUSH
16601: LD_INT 2
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL 11651 0 2
16633: IFFALSE 16682
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16635: LD_ADDR_VAR 0 6
16639: PUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 4
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 30
16660: PUSH
16661: LD_INT 5
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL 11651 0 2
16677: PUSH
16678: LD_INT 1
16680: ARRAY
16681: ST_TO_ADDR
// if class = class_engineer then
16682: LD_VAR 0 3
16686: PUSH
16687: LD_INT 2
16689: EQUAL
16690: IFFALSE 16778
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16692: LD_VAR 0 1
16696: PPUSH
16697: LD_INT 2
16699: PUSH
16700: LD_INT 30
16702: PUSH
16703: LD_INT 0
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 30
16712: PUSH
16713: LD_INT 1
16715: PUSH
16716: EMPTY
16717: LIST
16718: LIST
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL 11651 0 2
16729: IFFALSE 16778
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16731: LD_ADDR_VAR 0 6
16735: PUSH
16736: LD_VAR 0 1
16740: PPUSH
16741: LD_INT 2
16743: PUSH
16744: LD_INT 30
16746: PUSH
16747: LD_INT 0
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 30
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: LIST
16768: PPUSH
16769: CALL 11651 0 2
16773: PUSH
16774: LD_INT 1
16776: ARRAY
16777: ST_TO_ADDR
// if class = class_mechanic then
16778: LD_VAR 0 3
16782: PUSH
16783: LD_INT 3
16785: EQUAL
16786: IFFALSE 16856
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16788: LD_VAR 0 1
16792: PPUSH
16793: LD_INT 30
16795: PUSH
16796: LD_INT 3
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PPUSH
16803: CALL 11651 0 2
16807: IFFALSE 16856
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16809: LD_ADDR_VAR 0 6
16813: PUSH
16814: LD_VAR 0 1
16818: PPUSH
16819: LD_INT 2
16821: PUSH
16822: LD_INT 30
16824: PUSH
16825: LD_INT 2
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: PUSH
16832: LD_INT 30
16834: PUSH
16835: LD_INT 3
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: PUSH
16842: EMPTY
16843: LIST
16844: LIST
16845: LIST
16846: PPUSH
16847: CALL 11651 0 2
16851: PUSH
16852: LD_INT 1
16854: ARRAY
16855: ST_TO_ADDR
// if class = class_scientistic then
16856: LD_VAR 0 3
16860: PUSH
16861: LD_INT 4
16863: EQUAL
16864: IFFALSE 16974
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16866: LD_VAR 0 1
16870: PPUSH
16871: LD_INT 2
16873: PUSH
16874: LD_INT 30
16876: PUSH
16877: LD_INT 6
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PUSH
16884: LD_INT 30
16886: PUSH
16887: LD_INT 7
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: PUSH
16894: LD_INT 30
16896: PUSH
16897: LD_INT 8
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: LIST
16908: LIST
16909: PPUSH
16910: CALL 11651 0 2
16914: IFFALSE 16974
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16916: LD_ADDR_VAR 0 6
16920: PUSH
16921: LD_VAR 0 1
16925: PPUSH
16926: LD_INT 2
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 6
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: LD_INT 30
16941: PUSH
16942: LD_INT 7
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PUSH
16949: LD_INT 30
16951: PUSH
16952: LD_INT 8
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL 11651 0 2
16969: PUSH
16970: LD_INT 1
16972: ARRAY
16973: ST_TO_ADDR
// if GetClass ( unit ) = class then
16974: LD_VAR 0 2
16978: PPUSH
16979: CALL_OW 257
16983: PUSH
16984: LD_VAR 0 3
16988: EQUAL
16989: IFFALSE 17023
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16991: LD_ADDR_EXP 53
16995: PUSH
16996: LD_EXP 53
17000: PPUSH
17001: LD_VAR 0 1
17005: PPUSH
17006: LD_VAR 0 2
17010: PPUSH
17011: LD_VAR 0 3
17015: PPUSH
17016: CALL 42051 0 4
17020: ST_TO_ADDR
// end else
17021: GO 17116
// if b then
17023: LD_VAR 0 6
17027: IFFALSE 17108
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17029: LD_VAR 0 2
17033: PPUSH
17034: CALL_OW 310
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: CALL_OW 310
17048: PUSH
17049: LD_VAR 0 6
17053: NONEQUAL
17054: AND
17055: IFFALSE 17066
// ComExitBuilding ( unit ) ;
17057: LD_VAR 0 2
17061: PPUSH
17062: CALL_OW 122
// if not IsInUnit ( unit ) then
17066: LD_VAR 0 2
17070: PPUSH
17071: CALL_OW 310
17075: NOT
17076: IFFALSE 17092
// ComEnterUnit ( unit , b ) ;
17078: LD_VAR 0 2
17082: PPUSH
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_VAR 0 3
17101: PPUSH
17102: CALL_OW 183
// end else
17106: GO 17116
// result := false ;
17108: LD_ADDR_VAR 0 4
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// end ; end_of_file
17116: LD_VAR 0 4
17120: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17121: LD_INT 0
17123: PPUSH
17124: PPUSH
17125: PPUSH
17126: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17127: LD_ADDR_VAR 0 5
17131: PUSH
17132: LD_INT 35
17134: PUSH
17135: LD_INT 45
17137: PUSH
17138: LD_INT 46
17140: PUSH
17141: LD_INT 47
17143: PUSH
17144: LD_INT 1
17146: PUSH
17147: LD_INT 2
17149: PUSH
17150: LD_INT 48
17152: PUSH
17153: LD_INT 49
17155: PUSH
17156: LD_INT 50
17158: PUSH
17159: LD_INT 20
17161: PUSH
17162: EMPTY
17163: LIST
17164: LIST
17165: LIST
17166: LIST
17167: LIST
17168: LIST
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: ST_TO_ADDR
// if MCF_Lab ( side ) then
17174: LD_VAR 0 1
17178: PPUSH
17179: CALL 11690 0 1
17183: IFFALSE 17422
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL 11690 0 1
17194: PUSH
17195: LD_INT 1
17197: ARRAY
17198: PPUSH
17199: CALL_OW 461
17203: PUSH
17204: LD_INT 2
17206: EQUAL
17207: IFFALSE 17346
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17209: LD_VAR 0 1
17213: PPUSH
17214: CALL 11690 0 1
17218: PUSH
17219: LD_INT 1
17221: ARRAY
17222: PPUSH
17223: LD_VAR 0 2
17227: PPUSH
17228: CALL 17518 0 2
17232: IFFALSE 17259
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11690 0 1
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL_OW 124
17257: GO 17346
// if MCF_Lab ( side ) > 1 then
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11690 0 1
17268: PUSH
17269: LD_INT 1
17271: GREATER
17272: IFFALSE 17346
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17274: LD_VAR 0 1
17278: PPUSH
17279: CALL 11690 0 1
17283: PUSH
17284: LD_INT 2
17286: ARRAY
17287: PPUSH
17288: CALL_OW 461
17292: PUSH
17293: LD_INT 2
17295: EQUAL
17296: IFFALSE 17346
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17298: LD_VAR 0 1
17302: PPUSH
17303: CALL 11690 0 1
17307: PUSH
17308: LD_INT 2
17310: ARRAY
17311: PPUSH
17312: LD_VAR 0 2
17316: PPUSH
17317: CALL 17518 0 2
17321: IFFALSE 17346
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17323: LD_VAR 0 1
17327: PPUSH
17328: CALL 11690 0 1
17332: PUSH
17333: LD_INT 2
17335: ARRAY
17336: PPUSH
17337: LD_VAR 0 2
17341: PPUSH
17342: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17346: LD_VAR 0 2
17350: PUSH
17351: LD_INT 2
17353: PUSH
17354: LD_INT 11
17356: PUSH
17357: LD_INT 4
17359: PUSH
17360: LD_INT 3
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: LIST
17367: LIST
17368: IN
17369: IFFALSE 17422
// begin for lab in MCF_Lab ( side ) do
17371: LD_ADDR_VAR 0 6
17375: PUSH
17376: LD_VAR 0 1
17380: PPUSH
17381: CALL 11690 0 1
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17420
// if BuildingStatus ( lab ) = bs_need_ape then
17389: LD_VAR 0 6
17393: PPUSH
17394: CALL_OW 461
17398: PUSH
17399: LD_INT 10
17401: EQUAL
17402: IFFALSE 17418
// MCL_ResTame ( side , lab ) ;
17404: LD_VAR 0 1
17408: PPUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL 17643 0 2
17418: GO 17386
17420: POP
17421: POP
// end ; end ; end ;
17422: LD_VAR 0 3
17426: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17427: LD_INT 0
17429: PPUSH
17430: PPUSH
// tmp := [ ] ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: EMPTY
17437: ST_TO_ADDR
// if not lab then
17438: LD_VAR 0 1
17442: NOT
17443: IFFALSE 17455
// result := false else
17445: LD_ADDR_VAR 0 2
17449: PUSH
17450: LD_INT 0
17452: ST_TO_ADDR
17453: GO 17513
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17455: LD_ADDR_VAR 0 3
17459: PUSH
17460: LD_VAR 0 3
17464: PUSH
17465: LD_VAR 0 1
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 268
17477: ADD
17478: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17479: LD_ADDR_VAR 0 3
17483: PUSH
17484: LD_VAR 0 3
17488: PUSH
17489: LD_VAR 0 1
17493: PPUSH
17494: LD_INT 2
17496: PPUSH
17497: CALL_OW 268
17501: ADD
17502: ST_TO_ADDR
// result := tmp ;
17503: LD_ADDR_VAR 0 2
17507: PUSH
17508: LD_VAR 0 3
17512: ST_TO_ADDR
// end ; end ;
17513: LD_VAR 0 2
17517: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17518: LD_INT 0
17520: PPUSH
17521: PPUSH
17522: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17523: LD_ADDR_VAR 0 5
17527: PUSH
17528: LD_INT 35
17530: PUSH
17531: LD_INT 45
17533: PUSH
17534: LD_INT 46
17536: PUSH
17537: LD_INT 47
17539: PUSH
17540: LD_INT 1
17542: PUSH
17543: LD_INT 2
17545: PUSH
17546: LD_INT 48
17548: PUSH
17549: LD_INT 49
17551: PUSH
17552: LD_INT 50
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: LIST
17562: LIST
17563: LIST
17564: LIST
17565: LIST
17566: LIST
17567: LIST
17568: LIST
17569: ST_TO_ADDR
// if lab then
17570: LD_VAR 0 1
17574: IFFALSE 17630
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17576: LD_VAR 0 2
17580: PUSH
17581: LD_VAR 0 5
17585: IN
17586: PUSH
17587: LD_VAR 0 2
17591: PPUSH
17592: CALL_OW 481
17596: PUSH
17597: LD_VAR 0 1
17601: PPUSH
17602: CALL 17427 0 1
17606: IN
17607: OR
17608: IFFALSE 17620
// result := true else
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
17618: GO 17628
// result := false ;
17620: LD_ADDR_VAR 0 3
17624: PUSH
17625: LD_INT 0
17627: ST_TO_ADDR
// end else
17628: GO 17638
// result := false ;
17630: LD_ADDR_VAR 0 3
17634: PUSH
17635: LD_INT 0
17637: ST_TO_ADDR
// end ;
17638: LD_VAR 0 3
17642: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17643: LD_INT 0
17645: PPUSH
17646: PPUSH
17647: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17648: LD_ADDR_VAR 0 4
17652: PUSH
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_INT 171
17660: PPUSH
17661: EMPTY
17662: PPUSH
17663: CALL 12354 0 3
17667: ST_TO_ADDR
// if not ape then
17668: LD_VAR 0 4
17672: NOT
17673: IFFALSE 17705
// if MCF_Ape ( side ) then
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL 12064 0 1
17684: IFFALSE 17705
// ape := MCF_Ape ( side ) [ 1 ] ;
17686: LD_ADDR_VAR 0 4
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12064 0 1
17700: PUSH
17701: LD_INT 1
17703: ARRAY
17704: ST_TO_ADDR
// if ape then
17705: LD_VAR 0 4
17709: IFFALSE 17760
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17711: LD_VAR 0 4
17715: PUSH
17716: LD_INT 1
17718: ARRAY
17719: PPUSH
17720: CALL_OW 310
17724: PUSH
17725: LD_VAR 0 4
17729: PUSH
17730: LD_INT 1
17732: ARRAY
17733: PPUSH
17734: CALL_OW 310
17738: PUSH
17739: LD_VAR 0 2
17743: NONEQUAL
17744: AND
17745: IFFALSE 17760
// ComExitBuilding ( ape [ 1 ] ) ;
17747: LD_VAR 0 4
17751: PUSH
17752: LD_INT 1
17754: ARRAY
17755: PPUSH
17756: CALL_OW 122
// if not lab then
17760: LD_VAR 0 2
17764: NOT
17765: IFFALSE 17771
// exit else
17767: GO 17919
17769: GO 17879
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17771: LD_VAR 0 1
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: LD_INT 25
17781: PUSH
17782: LD_INT 4
17784: PUSH
17785: EMPTY
17786: LIST
17787: LIST
17788: PPUSH
17789: CALL 12354 0 3
17793: PUSH
17794: LD_INT 0
17796: EQUAL
17797: PUSH
17798: LD_VAR 0 2
17802: PPUSH
17803: CALL_OW 313
17807: PUSH
17808: LD_INT 6
17810: EQUAL
17811: AND
17812: IFFALSE 17879
// begin tmp := UnitsInside ( lab ) ;
17814: LD_ADDR_VAR 0 5
17818: PUSH
17819: LD_VAR 0 2
17823: PPUSH
17824: CALL_OW 313
17828: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17829: LD_VAR 0 5
17833: PUSH
17834: LD_VAR 0 5
17838: ARRAY
17839: PPUSH
17840: LD_INT 16
17842: PPUSH
17843: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17847: LD_VAR 0 5
17851: PUSH
17852: LD_VAR 0 5
17856: ARRAY
17857: PPUSH
17858: CALL_OW 310
17862: IFFALSE 17879
// ComExitBuilding ( tmp [ tmp ] ) ;
17864: LD_VAR 0 5
17868: PUSH
17869: LD_VAR 0 5
17873: ARRAY
17874: PPUSH
17875: CALL_OW 122
// end ; if ape then
17879: LD_VAR 0 4
17883: IFFALSE 17919
// if not IsInUnit ( ape [ 1 ] ) then
17885: LD_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: ARRAY
17893: PPUSH
17894: CALL_OW 310
17898: NOT
17899: IFFALSE 17919
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: LD_VAR 0 2
17914: PPUSH
17915: CALL_OW 120
// end ;
17919: LD_VAR 0 3
17923: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17924: LD_INT 0
17926: PPUSH
17927: PPUSH
17928: PPUSH
// result := false ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: LD_INT 0
17936: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17937: LD_ADDR_VAR 0 3
17941: PUSH
17942: LD_VAR 0 1
17946: PPUSH
17947: CALL 18034 0 1
17951: ST_TO_ADDR
// if techs then
17952: LD_VAR 0 3
17956: IFFALSE 17986
// if techs [ 2 ] then
17958: LD_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: ARRAY
17966: IFFALSE 17978
// result := true else
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: LD_INT 1
17975: ST_TO_ADDR
17976: GO 17986
// result := false ;
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_INT 0
17985: ST_TO_ADDR
// end ;
17986: LD_VAR 0 2
17990: RET
// export function MCL_Start ( side ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// if MCL_GetTechList ( side ) then
17995: LD_VAR 0 1
17999: PPUSH
18000: CALL 18034 0 1
18004: IFFALSE 18029
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18006: LD_VAR 0 1
18010: PPUSH
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18034 0 1
18020: PUSH
18021: LD_INT 1
18023: ARRAY
18024: PPUSH
18025: CALL 17121 0 2
// end ;
18029: LD_VAR 0 2
18033: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18034: LD_INT 0
18036: PPUSH
18037: PPUSH
18038: PPUSH
// if MREG_ToRes then
18039: LD_EXP 50
18043: IFFALSE 18128
// for i = 1 to MREG_ToRes do
18045: LD_ADDR_VAR 0 3
18049: PUSH
18050: DOUBLE
18051: LD_INT 1
18053: DEC
18054: ST_TO_ADDR
18055: LD_EXP 50
18059: PUSH
18060: FOR_TO
18061: IFFALSE 18126
// if MREG_ToRes [ i ] [ 1 ] = side then
18063: LD_EXP 50
18067: PUSH
18068: LD_VAR 0 3
18072: ARRAY
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PUSH
18078: LD_VAR 0 1
18082: EQUAL
18083: IFFALSE 18124
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18085: LD_ADDR_VAR 0 4
18089: PUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: LD_VAR 0 4
18099: PUSH
18100: LD_INT 1
18102: PLUS
18103: PPUSH
18104: LD_EXP 50
18108: PUSH
18109: LD_VAR 0 3
18113: ARRAY
18114: PUSH
18115: LD_INT 2
18117: ARRAY
18118: PPUSH
18119: CALL_OW 1
18123: ST_TO_ADDR
// end ;
18124: GO 18060
18126: POP
18127: POP
// result := techs ;
18128: LD_ADDR_VAR 0 2
18132: PUSH
18133: LD_VAR 0 4
18137: ST_TO_ADDR
// end ;
18138: LD_VAR 0 2
18142: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18143: LD_INT 0
18145: PPUSH
18146: PPUSH
// for i = 1 to tech_list do
18147: LD_ADDR_VAR 0 4
18151: PUSH
18152: DOUBLE
18153: LD_INT 1
18155: DEC
18156: ST_TO_ADDR
18157: LD_VAR 0 2
18161: PUSH
18162: FOR_TO
18163: IFFALSE 18217
// if not tech_list [ i ] = 20 then
18165: LD_VAR 0 2
18169: PUSH
18170: LD_VAR 0 4
18174: ARRAY
18175: PUSH
18176: LD_INT 20
18178: EQUAL
18179: NOT
18180: IFFALSE 18215
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18182: LD_ADDR_EXP 50
18186: PUSH
18187: LD_EXP 50
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: LD_VAR 0 2
18201: PUSH
18202: LD_VAR 0 4
18206: ARRAY
18207: PPUSH
18208: EMPTY
18209: PPUSH
18210: CALL 41960 0 4
18214: ST_TO_ADDR
18215: GO 18162
18217: POP
18218: POP
// result := true ;
18219: LD_ADDR_VAR 0 3
18223: PUSH
18224: LD_INT 1
18226: ST_TO_ADDR
// end ;
18227: LD_VAR 0 3
18231: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18232: LD_INT 0
18234: PPUSH
18235: PPUSH
// for i = MREG_ToRes downto 1 do
18236: LD_ADDR_VAR 0 3
18240: PUSH
18241: DOUBLE
18242: LD_EXP 50
18246: INC
18247: ST_TO_ADDR
18248: LD_INT 1
18250: PUSH
18251: FOR_DOWNTO
18252: IFFALSE 18298
// if MREG_ToRes [ i ] [ 1 ] = side then
18254: LD_EXP 50
18258: PUSH
18259: LD_VAR 0 3
18263: ARRAY
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_VAR 0 1
18273: EQUAL
18274: IFFALSE 18296
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18276: LD_ADDR_EXP 50
18280: PUSH
18281: LD_EXP 50
18285: PPUSH
18286: LD_VAR 0 3
18290: PPUSH
18291: CALL_OW 3
18295: ST_TO_ADDR
18296: GO 18251
18298: POP
18299: POP
// result := true ;
18300: LD_ADDR_VAR 0 2
18304: PUSH
18305: LD_INT 1
18307: ST_TO_ADDR
// end ;
18308: LD_VAR 0 2
18312: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18313: LD_INT 0
18315: PPUSH
// result := GetTechProgress ( side , tech ) ;
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: LD_VAR 0 2
18330: PPUSH
18331: CALL_OW 326
18335: ST_TO_ADDR
// end ;
18336: LD_VAR 0 3
18340: RET
// export function MCL_Require ( tech ) ; begin
18341: LD_INT 0
18343: PPUSH
// result := GetTechTechsReq ( tech ) ;
18344: LD_ADDR_VAR 0 2
18348: PUSH
18349: LD_VAR 0 1
18353: PPUSH
18354: CALL_OW 480
18358: ST_TO_ADDR
// end ; end_of_file
18359: LD_VAR 0 2
18363: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18364: LD_INT 0
18366: PPUSH
18367: PPUSH
18368: PPUSH
// uc_side := 0 ;
18369: LD_ADDR_OWVAR 20
18373: PUSH
18374: LD_INT 0
18376: ST_TO_ADDR
// uc_nation := 0 ;
18377: LD_ADDR_OWVAR 21
18381: PUSH
18382: LD_INT 0
18384: ST_TO_ADDR
// for i = 1 to n do
18385: LD_ADDR_VAR 0 5
18389: PUSH
18390: DOUBLE
18391: LD_INT 1
18393: DEC
18394: ST_TO_ADDR
18395: LD_VAR 0 2
18399: PUSH
18400: FOR_TO
18401: IFFALSE 18546
// begin hc_importance := 0 ;
18403: LD_ADDR_OWVAR 32
18407: PUSH
18408: LD_INT 0
18410: ST_TO_ADDR
// hc_gallery :=  ;
18411: LD_ADDR_OWVAR 33
18415: PUSH
18416: LD_STRING 
18418: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18419: LD_ADDR_OWVAR 35
18423: PUSH
18424: LD_VAR 0 3
18428: PUSH
18429: LD_INT 20
18431: MINUS
18432: PPUSH
18433: LD_VAR 0 3
18437: PUSH
18438: LD_INT 20
18440: PLUS
18441: PPUSH
18442: CALL_OW 12
18446: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18447: LD_ADDR_OWVAR 31
18451: PUSH
18452: LD_INT 0
18454: PPUSH
18455: LD_INT 2
18457: PPUSH
18458: CALL_OW 12
18462: PUSH
18463: LD_INT 0
18465: PUSH
18466: LD_INT 0
18468: PUSH
18469: LD_INT 0
18471: PUSH
18472: EMPTY
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18478: LD_ADDR_OWVAR 30
18482: PUSH
18483: LD_INT 0
18485: PUSH
18486: LD_INT 0
18488: PUSH
18489: LD_INT 0
18491: PUSH
18492: LD_INT 0
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// hc_name :=  ;
18501: LD_ADDR_OWVAR 26
18505: PUSH
18506: LD_STRING 
18508: ST_TO_ADDR
// hc_class := class_apeman ;
18509: LD_ADDR_OWVAR 28
18513: PUSH
18514: LD_INT 12
18516: ST_TO_ADDR
// ape := CreateHuman ;
18517: LD_ADDR_VAR 0 6
18521: PUSH
18522: CALL_OW 44
18526: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18527: LD_VAR 0 6
18531: PPUSH
18532: LD_VAR 0 1
18536: PPUSH
18537: LD_INT 0
18539: PPUSH
18540: CALL_OW 49
// end ;
18544: GO 18400
18546: POP
18547: POP
// end ;
18548: LD_VAR 0 4
18552: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18553: LD_INT 0
18555: PPUSH
18556: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18557: LD_VAR 0 1
18561: PPUSH
18562: CALL 12064 0 1
18566: PUSH
18567: LD_EXP 37
18571: PUSH
18572: LD_VAR 0 1
18576: ARRAY
18577: GREATEREQUAL
18578: IFFALSE 18755
// begin if GetTag ( unit ) = 17 then
18580: LD_VAR 0 2
18584: PPUSH
18585: CALL_OW 110
18589: PUSH
18590: LD_INT 17
18592: EQUAL
18593: IFFALSE 18753
// begin SetTag ( unit , 0 ) ;
18595: LD_VAR 0 2
18599: PPUSH
18600: LD_INT 0
18602: PPUSH
18603: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL 11690 0 1
18616: PUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL 18034 0 1
18626: NOT
18627: AND
18628: IFFALSE 18653
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18630: LD_VAR 0 2
18634: PPUSH
18635: LD_VAR 0 1
18639: PPUSH
18640: CALL 11690 0 1
18644: PUSH
18645: LD_INT 1
18647: ARRAY
18648: PPUSH
18649: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18653: LD_VAR 0 1
18657: PPUSH
18658: CALL 11690 0 1
18662: NOT
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: LD_INT 30
18671: PUSH
18672: LD_INT 1
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PPUSH
18679: CALL 11651 0 2
18683: AND
18684: IFFALSE 18753
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18686: LD_VAR 0 2
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 1
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PPUSH
18706: CALL 11651 0 2
18710: PUSH
18711: LD_INT 1
18713: ARRAY
18714: PPUSH
18715: CALL_OW 250
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: LD_INT 30
18727: PUSH
18728: LD_INT 1
18730: PUSH
18731: EMPTY
18732: LIST
18733: LIST
18734: PPUSH
18735: CALL 11651 0 2
18739: PUSH
18740: LD_INT 1
18742: ARRAY
18743: PPUSH
18744: CALL_OW 251
18748: PPUSH
18749: CALL_OW 111
// end ; end else
18753: GO 18939
// if GetClass ( unit ) <> 4 then
18755: LD_VAR 0 2
18759: PPUSH
18760: CALL_OW 257
18764: PUSH
18765: LD_INT 4
18767: NONEQUAL
18768: IFFALSE 18774
// exit else
18770: GO 18939
18772: GO 18939
// if GetTag ( unit ) = 0 then
18774: LD_VAR 0 2
18778: PPUSH
18779: CALL_OW 110
18783: PUSH
18784: LD_INT 0
18786: EQUAL
18787: IFFALSE 18803
// SetTag ( unit , 17 ) else
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 17
18796: PPUSH
18797: CALL_OW 109
18801: GO 18939
// begin if IsInUnit ( unit ) then
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL_OW 310
18812: IFFALSE 18823
// ComExitBuilding ( unit ) ;
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 122
// Wait ( 1 ) ;
18823: LD_INT 1
18825: PPUSH
18826: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18830: LD_ADDR_VAR 0 4
18834: PUSH
18835: LD_INT 22
18837: PUSH
18838: LD_INT 0
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 25
18847: PUSH
18848: LD_INT 12
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PPUSH
18859: CALL_OW 69
18863: PPUSH
18864: LD_VAR 0 2
18868: PPUSH
18869: CALL_OW 74
18873: ST_TO_ADDR
// if not ape then
18874: LD_VAR 0 4
18878: NOT
18879: IFFALSE 18885
// exit else
18881: GO 18939
18883: GO 18894
// ComHold ( ape ) ;
18885: LD_VAR 0 4
18889: PPUSH
18890: CALL_OW 140
// if not HasTask ( unit ) then
18894: LD_VAR 0 2
18898: PPUSH
18899: CALL_OW 314
18903: NOT
18904: IFFALSE 18937
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18906: LD_VAR 0 2
18910: PPUSH
18911: LD_VAR 0 4
18915: PPUSH
18916: CALL_OW 250
18920: PPUSH
18921: LD_VAR 0 4
18925: PPUSH
18926: CALL_OW 251
18930: PPUSH
18931: CALL_OW 131
18935: GO 18939
// exit ;
18937: GO 18939
// end ; end ;
18939: LD_VAR 0 3
18943: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18944: LD_INT 0
18946: PPUSH
18947: PPUSH
18948: PPUSH
18949: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18950: LD_ADDR_VAR 0 4
18954: PUSH
18955: LD_EXP 38
18959: PUSH
18960: LD_VAR 0 1
18964: ARRAY
18965: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18966: LD_ADDR_VAR 0 5
18970: PUSH
18971: LD_VAR 0 1
18975: PPUSH
18976: LD_STRING normal
18978: PPUSH
18979: CALL 12148 0 2
18983: ST_TO_ADDR
// if apes then
18984: LD_VAR 0 5
18988: IFFALSE 19216
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18990: LD_INT 2
18992: PPUSH
18993: LD_VAR 0 1
18997: PPUSH
18998: CALL_OW 321
19002: PUSH
19003: LD_INT 2
19005: EQUAL
19006: PUSH
19007: LD_VAR 0 4
19011: PUSH
19012: LD_INT 2
19014: ARRAY
19015: PUSH
19016: LD_INT 1
19018: EQUAL
19019: AND
19020: PUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: LD_STRING engineer
19028: PPUSH
19029: CALL 12148 0 2
19033: PUSH
19034: LD_INT 3
19036: LESS
19037: AND
19038: PUSH
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 1
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: PPUSH
19054: CALL 11651 0 2
19058: AND
19059: IFFALSE 19113
// begin for i in apes do
19061: LD_ADDR_VAR 0 3
19065: PUSH
19066: LD_VAR 0 5
19070: PUSH
19071: FOR_IN
19072: IFFALSE 19109
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19074: LD_VAR 0 3
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_INT 30
19086: PUSH
19087: LD_INT 1
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: PPUSH
19094: CALL 11651 0 2
19098: PUSH
19099: LD_INT 1
19101: ARRAY
19102: PPUSH
19103: CALL_OW 120
// end ;
19107: GO 19071
19109: POP
19110: POP
// end else
19111: GO 19216
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19113: LD_INT 11
19115: PPUSH
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 321
19125: PUSH
19126: LD_INT 2
19128: EQUAL
19129: PUSH
19130: LD_VAR 0 4
19134: PUSH
19135: LD_INT 1
19137: ARRAY
19138: PUSH
19139: LD_INT 1
19141: EQUAL
19142: AND
19143: PUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: LD_INT 30
19151: PUSH
19152: LD_INT 5
19154: PUSH
19155: EMPTY
19156: LIST
19157: LIST
19158: PPUSH
19159: CALL 11651 0 2
19163: AND
19164: IFFALSE 19216
// begin for i in apes do
19166: LD_ADDR_VAR 0 3
19170: PUSH
19171: LD_VAR 0 5
19175: PUSH
19176: FOR_IN
19177: IFFALSE 19214
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19179: LD_VAR 0 3
19183: PPUSH
19184: LD_VAR 0 1
19188: PPUSH
19189: LD_INT 30
19191: PUSH
19192: LD_INT 5
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: PPUSH
19199: CALL 11651 0 2
19203: PUSH
19204: LD_INT 1
19206: ARRAY
19207: PPUSH
19208: CALL_OW 120
// end ;
19212: GO 19176
19214: POP
19215: POP
// end ; end ; end ; end_of_file
19216: LD_VAR 0 2
19220: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 257
19234: PUSH
19235: LD_INT 4
19237: EQUAL
19238: NOT
19239: PUSH
19240: LD_VAR 0 2
19244: NOT
19245: OR
19246: IFFALSE 19252
// exit else
19248: GO 19286
19250: GO 19286
// if not GetTag ( unit ) = 4 then
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 110
19261: PUSH
19262: LD_INT 4
19264: EQUAL
19265: NOT
19266: IFFALSE 19272
// exit else
19268: GO 19286
19270: GO 19286
// ComHeal ( unit , target ) ;
19272: LD_VAR 0 1
19276: PPUSH
19277: LD_VAR 0 2
19281: PPUSH
19282: CALL_OW 128
// end ;
19286: LD_VAR 0 3
19290: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19291: LD_INT 0
19293: PPUSH
19294: PPUSH
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
19299: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19300: LD_ADDR_VAR 0 5
19304: PUSH
19305: LD_INT 22
19307: PUSH
19308: LD_VAR 0 1
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: PUSH
19317: LD_INT 21
19319: PUSH
19320: LD_INT 1
19322: PUSH
19323: EMPTY
19324: LIST
19325: LIST
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 55
19332: PUSH
19333: EMPTY
19334: LIST
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: PUSH
19340: LD_INT 3
19342: PUSH
19343: LD_INT 54
19345: PUSH
19346: EMPTY
19347: LIST
19348: PUSH
19349: EMPTY
19350: LIST
19351: LIST
19352: PUSH
19353: LD_INT 3
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 1000
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_INT 30
19394: PUSH
19395: LD_INT 1
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PPUSH
19402: CALL 11651 0 2
19406: ST_TO_ADDR
// r := [ ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: EMPTY
19413: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19414: LD_VAR 0 1
19418: PPUSH
19419: LD_INT 5
19421: PPUSH
19422: EMPTY
19423: PPUSH
19424: CALL 12354 0 3
19428: IFFALSE 19484
// for j in MCF_Tag ( side , 5 , [ ] ) do
19430: LD_ADDR_VAR 0 4
19434: PUSH
19435: LD_VAR 0 1
19439: PPUSH
19440: LD_INT 5
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL 12354 0 3
19449: PUSH
19450: FOR_IN
19451: IFFALSE 19482
// if GetLives ( j ) = 1000 then
19453: LD_VAR 0 4
19457: PPUSH
19458: CALL_OW 256
19462: PUSH
19463: LD_INT 1000
19465: EQUAL
19466: IFFALSE 19480
// SetTag ( j , 0 ) ;
19468: LD_VAR 0 4
19472: PPUSH
19473: LD_INT 0
19475: PPUSH
19476: CALL_OW 109
19480: GO 19450
19482: POP
19483: POP
// if tmp then
19484: LD_VAR 0 5
19488: IFFALSE 19817
// begin r := [ tmp [ 1 ] ] ;
19490: LD_ADDR_VAR 0 6
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_INT 1
19502: ARRAY
19503: PUSH
19504: EMPTY
19505: LIST
19506: ST_TO_ADDR
// for i = 2 to tmp do
19507: LD_ADDR_VAR 0 3
19511: PUSH
19512: DOUBLE
19513: LD_INT 2
19515: DEC
19516: ST_TO_ADDR
19517: LD_VAR 0 5
19521: PUSH
19522: FOR_TO
19523: IFFALSE 19815
// begin m := false ;
19525: LD_ADDR_VAR 0 7
19529: PUSH
19530: LD_INT 0
19532: ST_TO_ADDR
// if d then
19533: LD_VAR 0 8
19537: IFFALSE 19692
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19539: LD_VAR 0 5
19543: PUSH
19544: LD_VAR 0 3
19548: ARRAY
19549: PPUSH
19550: CALL_OW 256
19554: PUSH
19555: LD_INT 650
19557: LESS
19558: PUSH
19559: LD_VAR 0 5
19563: PUSH
19564: LD_VAR 0 3
19568: ARRAY
19569: PPUSH
19570: LD_VAR 0 8
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: CALL_OW 250
19583: PPUSH
19584: LD_VAR 0 8
19588: PUSH
19589: LD_INT 1
19591: ARRAY
19592: PPUSH
19593: CALL_OW 251
19597: PPUSH
19598: CALL_OW 297
19602: PUSH
19603: LD_INT 10
19605: GREATER
19606: AND
19607: IFFALSE 19692
// begin if not GetTag ( tmp [ i ] ) = 5 then
19609: LD_VAR 0 5
19613: PUSH
19614: LD_VAR 0 3
19618: ARRAY
19619: PPUSH
19620: CALL_OW 110
19624: PUSH
19625: LD_INT 5
19627: EQUAL
19628: NOT
19629: IFFALSE 19649
// SetTag ( tmp [ i ] , 5 ) ;
19631: LD_VAR 0 5
19635: PUSH
19636: LD_VAR 0 3
19640: ARRAY
19641: PPUSH
19642: LD_INT 5
19644: PPUSH
19645: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19649: LD_VAR 0 5
19653: PUSH
19654: LD_VAR 0 3
19658: ARRAY
19659: PPUSH
19660: LD_VAR 0 8
19664: PUSH
19665: LD_INT 1
19667: ARRAY
19668: PPUSH
19669: CALL_OW 250
19673: PPUSH
19674: LD_VAR 0 8
19678: PUSH
19679: LD_INT 1
19681: ARRAY
19682: PPUSH
19683: CALL_OW 251
19687: PPUSH
19688: CALL_OW 111
// end ; for j = 1 to r do
19692: LD_ADDR_VAR 0 4
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_VAR 0 6
19706: PUSH
19707: FOR_TO
19708: IFFALSE 19782
// if GetLives ( tmp [ i ] ) < r [ j ] then
19710: LD_VAR 0 5
19714: PUSH
19715: LD_VAR 0 3
19719: ARRAY
19720: PPUSH
19721: CALL_OW 256
19725: PUSH
19726: LD_VAR 0 6
19730: PUSH
19731: LD_VAR 0 4
19735: ARRAY
19736: LESS
19737: IFFALSE 19780
// begin r := Insert ( r , j , tmp [ i ] ) ;
19739: LD_ADDR_VAR 0 6
19743: PUSH
19744: LD_VAR 0 6
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 5
19758: PUSH
19759: LD_VAR 0 3
19763: ARRAY
19764: PPUSH
19765: CALL_OW 2
19769: ST_TO_ADDR
// m := true ;
19770: LD_ADDR_VAR 0 7
19774: PUSH
19775: LD_INT 1
19777: ST_TO_ADDR
// break ;
19778: GO 19782
// end ;
19780: GO 19707
19782: POP
19783: POP
// if not m then
19784: LD_VAR 0 7
19788: NOT
19789: IFFALSE 19813
// r := r ^ tmp [ i ] ;
19791: LD_ADDR_VAR 0 6
19795: PUSH
19796: LD_VAR 0 6
19800: PUSH
19801: LD_VAR 0 5
19805: PUSH
19806: LD_VAR 0 3
19810: ARRAY
19811: ADD
19812: ST_TO_ADDR
// end ;
19813: GO 19522
19815: POP
19816: POP
// end ; result := r end ; end_of_file
19817: LD_ADDR_VAR 0 2
19821: PUSH
19822: LD_VAR 0 6
19826: ST_TO_ADDR
19827: LD_VAR 0 2
19831: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19832: LD_INT 0
19834: PPUSH
19835: PPUSH
19836: PPUSH
// pom := GetBase ( bdepot ) ;
19837: LD_ADDR_VAR 0 3
19841: PUSH
19842: LD_VAR 0 1
19846: PPUSH
19847: CALL_OW 274
19851: ST_TO_ADDR
// sor := [ ] ;
19852: LD_ADDR_VAR 0 4
19856: PUSH
19857: EMPTY
19858: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 4
19868: PUSH
19869: LD_VAR 0 3
19873: PPUSH
19874: LD_INT 1
19876: PPUSH
19877: CALL_OW 275
19881: ADD
19882: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19883: LD_ADDR_VAR 0 4
19887: PUSH
19888: LD_VAR 0 4
19892: PUSH
19893: LD_VAR 0 3
19897: PPUSH
19898: LD_INT 2
19900: PPUSH
19901: CALL_OW 275
19905: ADD
19906: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19907: LD_ADDR_VAR 0 4
19911: PUSH
19912: LD_VAR 0 4
19916: PUSH
19917: LD_VAR 0 3
19921: PPUSH
19922: LD_INT 3
19924: PPUSH
19925: CALL_OW 275
19929: ADD
19930: ST_TO_ADDR
// result := sor ;
19931: LD_ADDR_VAR 0 2
19935: PUSH
19936: LD_VAR 0 4
19940: ST_TO_ADDR
// end ;
19941: LD_VAR 0 2
19945: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19946: LD_INT 0
19948: PPUSH
19949: PPUSH
// while ( coord_list ) do
19950: LD_VAR 0 3
19954: IFFALSE 20128
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19956: LD_ADDR_EXP 46
19960: PUSH
19961: LD_EXP 46
19965: PPUSH
19966: LD_VAR 0 1
19970: PPUSH
19971: LD_VAR 0 2
19975: PPUSH
19976: LD_VAR 0 3
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_VAR 0 3
19989: PUSH
19990: LD_INT 2
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_INT 3
20001: ARRAY
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: LIST
20007: PPUSH
20008: CALL 41960 0 4
20012: ST_TO_ADDR
// if weapon_list then
20013: LD_VAR 0 4
20017: IFFALSE 20088
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20019: LD_ADDR_EXP 43
20023: PUSH
20024: LD_EXP 43
20028: PPUSH
20029: LD_VAR 0 1
20033: PPUSH
20034: LD_VAR 0 4
20038: PUSH
20039: LD_INT 1
20041: ARRAY
20042: PPUSH
20043: LD_VAR 0 3
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_VAR 0 3
20056: PUSH
20057: LD_INT 2
20059: ARRAY
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PPUSH
20065: CALL 41960 0 4
20069: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20070: LD_ADDR_VAR 0 4
20074: PUSH
20075: LD_VAR 0 4
20079: PPUSH
20080: LD_INT 1
20082: PPUSH
20083: CALL_OW 3
20087: ST_TO_ADDR
// end ; for i = 1 to 3 do
20088: LD_ADDR_VAR 0 6
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20124
// coord_list := Delete ( coord_list , 1 ) ;
20104: LD_ADDR_VAR 0 3
20108: PUSH
20109: LD_VAR 0 3
20113: PPUSH
20114: LD_INT 1
20116: PPUSH
20117: CALL_OW 3
20121: ST_TO_ADDR
20122: GO 20101
20124: POP
20125: POP
// end ;
20126: GO 19950
// result := true ;
20128: LD_ADDR_VAR 0 5
20132: PUSH
20133: LD_INT 1
20135: ST_TO_ADDR
// end ;
20136: LD_VAR 0 5
20140: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20141: LD_INT 0
20143: PPUSH
20144: PPUSH
// if not weapon_list then
20145: LD_VAR 0 3
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20269
// while ( coord_list ) do
20154: LD_VAR 0 2
20158: IFFALSE 20269
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20160: LD_ADDR_EXP 43
20164: PUSH
20165: LD_EXP 43
20169: PPUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 1
20182: ARRAY
20183: PPUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_INT 1
20191: ARRAY
20192: PUSH
20193: LD_VAR 0 2
20197: PUSH
20198: LD_INT 2
20200: ARRAY
20201: PUSH
20202: EMPTY
20203: LIST
20204: LIST
20205: PPUSH
20206: CALL 41960 0 4
20210: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_VAR 0 3
20220: PPUSH
20221: LD_INT 1
20223: PPUSH
20224: CALL_OW 3
20228: ST_TO_ADDR
// for i = 1 to 2 do
20229: LD_ADDR_VAR 0 5
20233: PUSH
20234: DOUBLE
20235: LD_INT 1
20237: DEC
20238: ST_TO_ADDR
20239: LD_INT 2
20241: PUSH
20242: FOR_TO
20243: IFFALSE 20265
// coord_list := Delete ( coord_list , 1 ) ;
20245: LD_ADDR_VAR 0 2
20249: PUSH
20250: LD_VAR 0 2
20254: PPUSH
20255: LD_INT 1
20257: PPUSH
20258: CALL_OW 3
20262: ST_TO_ADDR
20263: GO 20242
20265: POP
20266: POP
// end ;
20267: GO 20154
// end ;
20269: LD_VAR 0 4
20273: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20274: LD_INT 0
20276: PPUSH
20277: PPUSH
// while ( coord_list ) do
20278: LD_VAR 0 2
20282: IFFALSE 20437
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20284: LD_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: ARRAY
20292: PPUSH
20293: LD_VAR 0 2
20297: PUSH
20298: LD_INT 2
20300: ARRAY
20301: PPUSH
20302: CALL_OW 428
20306: IFFALSE 20397
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 2
20321: PUSH
20322: LD_INT 2
20324: ARRAY
20325: PPUSH
20326: CALL_OW 428
20330: PPUSH
20331: CALL_OW 266
20335: PUSH
20336: LD_INT 31
20338: PUSH
20339: LD_INT 32
20341: PUSH
20342: LD_INT 33
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: LIST
20349: IN
20350: IFFALSE 20397
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20352: LD_ADDR_EXP 52
20356: PUSH
20357: LD_EXP 52
20361: PPUSH
20362: LD_VAR 0 1
20366: PPUSH
20367: LD_VAR 0 2
20371: PUSH
20372: LD_INT 1
20374: ARRAY
20375: PPUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_INT 2
20383: ARRAY
20384: PPUSH
20385: CALL_OW 428
20389: PPUSH
20390: EMPTY
20391: PPUSH
20392: CALL 41960 0 4
20396: ST_TO_ADDR
// for i = 1 to 3 do
20397: LD_ADDR_VAR 0 4
20401: PUSH
20402: DOUBLE
20403: LD_INT 1
20405: DEC
20406: ST_TO_ADDR
20407: LD_INT 3
20409: PUSH
20410: FOR_TO
20411: IFFALSE 20433
// coord_list := Delete ( coord_list , 1 ) ;
20413: LD_ADDR_VAR 0 2
20417: PUSH
20418: LD_VAR 0 2
20422: PPUSH
20423: LD_INT 1
20425: PPUSH
20426: CALL_OW 3
20430: ST_TO_ADDR
20431: GO 20410
20433: POP
20434: POP
// end ;
20435: GO 20278
// result := true ;
20437: LD_ADDR_VAR 0 3
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 3
20449: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20450: LD_INT 0
20452: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20453: LD_ADDR_EXP 46
20457: PUSH
20458: LD_EXP 46
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_INT 0
20470: PPUSH
20471: LD_VAR 0 2
20475: PPUSH
20476: CALL 41960 0 4
20480: ST_TO_ADDR
// end ;
20481: LD_VAR 0 3
20485: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20486: LD_INT 0
20488: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20489: LD_ADDR_EXP 46
20493: PUSH
20494: LD_EXP 46
20498: PPUSH
20499: LD_VAR 0 1
20503: PPUSH
20504: LD_INT 6
20506: PPUSH
20507: LD_VAR 0 2
20511: PPUSH
20512: CALL 41960 0 4
20516: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20517: LD_ADDR_EXP 49
20521: PUSH
20522: LD_EXP 49
20526: PPUSH
20527: LD_VAR 0 1
20531: PPUSH
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: ARRAY
20540: PPUSH
20541: LD_VAR 0 3
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL 41960 0 4
20554: ST_TO_ADDR
// end ;
20555: LD_VAR 0 4
20559: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// if ext_list > 5 then
20564: LD_VAR 0 3
20568: PUSH
20569: LD_INT 5
20571: GREATER
20572: IFFALSE 20616
// for i = 6 to ext_list do
20574: LD_ADDR_VAR 0 5
20578: PUSH
20579: DOUBLE
20580: LD_INT 6
20582: DEC
20583: ST_TO_ADDR
20584: LD_VAR 0 3
20588: PUSH
20589: FOR_TO
20590: IFFALSE 20614
// ext_list := Delete ( ext_list , ext_list ) ;
20592: LD_ADDR_VAR 0 3
20596: PUSH
20597: LD_VAR 0 3
20601: PPUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: CALL_OW 3
20611: ST_TO_ADDR
20612: GO 20589
20614: POP
20615: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20616: LD_VAR 0 1
20620: PPUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 3
20652: PPUSH
20653: CALL 9163 0 5
// end ;
20657: LD_VAR 0 4
20661: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
// p := 1 ;
20667: LD_ADDR_VAR 0 6
20671: PUSH
20672: LD_INT 1
20674: ST_TO_ADDR
// if type_list = [ ] then
20675: LD_VAR 0 3
20679: PUSH
20680: EMPTY
20681: EQUAL
20682: IFFALSE 20692
// type_list := b_oil_power ;
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 26
20691: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20692: LD_ADDR_VAR 0 5
20696: PUSH
20697: DOUBLE
20698: LD_INT 1
20700: DEC
20701: ST_TO_ADDR
20702: LD_VAR 0 2
20706: PUSH
20707: LD_INT 3
20709: DIVREAL
20710: PUSH
20711: FOR_TO
20712: IFFALSE 20815
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20714: LD_ADDR_EXP 46
20718: PUSH
20719: LD_EXP 46
20723: PPUSH
20724: LD_VAR 0 1
20728: PPUSH
20729: LD_VAR 0 3
20733: PUSH
20734: LD_INT 1
20736: PPUSH
20737: LD_VAR 0 3
20741: PPUSH
20742: CALL_OW 12
20746: ARRAY
20747: PPUSH
20748: LD_VAR 0 2
20752: PUSH
20753: LD_VAR 0 6
20757: ARRAY
20758: PUSH
20759: LD_VAR 0 2
20763: PUSH
20764: LD_VAR 0 6
20768: PUSH
20769: LD_INT 1
20771: PLUS
20772: ARRAY
20773: PUSH
20774: LD_VAR 0 2
20778: PUSH
20779: LD_VAR 0 6
20783: PUSH
20784: LD_INT 2
20786: PLUS
20787: ARRAY
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: PPUSH
20794: CALL 41960 0 4
20798: ST_TO_ADDR
// p := p + 3 ;
20799: LD_ADDR_VAR 0 6
20803: PUSH
20804: LD_VAR 0 6
20808: PUSH
20809: LD_INT 3
20811: PLUS
20812: ST_TO_ADDR
// end ;
20813: GO 20711
20815: POP
20816: POP
// end ;
20817: LD_VAR 0 4
20821: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20822: LD_INT 0
20824: PPUSH
20825: PPUSH
20826: PPUSH
20827: PPUSH
// if not MREG_Deposit [ side ] then
20828: LD_EXP 61
20832: PUSH
20833: LD_VAR 0 1
20837: ARRAY
20838: NOT
20839: IFFALSE 20843
// exit ;
20841: GO 21020
// p := 1 ;
20843: LD_ADDR_VAR 0 4
20847: PUSH
20848: LD_INT 1
20850: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20851: LD_ADDR_VAR 0 3
20855: PUSH
20856: DOUBLE
20857: LD_INT 1
20859: DEC
20860: ST_TO_ADDR
20861: LD_EXP 61
20865: PUSH
20866: LD_VAR 0 1
20870: ARRAY
20871: PUSH
20872: LD_INT 3
20874: DIVREAL
20875: PUSH
20876: FOR_TO
20877: IFFALSE 21018
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20879: LD_EXP 61
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: PUSH
20895: LD_INT 2
20897: PLUS
20898: ARRAY
20899: PUSH
20900: LD_INT 2
20902: EQUAL
20903: IFFALSE 20915
// b := b_oil_mine else
20905: LD_ADDR_VAR 0 5
20909: PUSH
20910: LD_INT 29
20912: ST_TO_ADDR
20913: GO 20923
// b := b_siberite_mine ;
20915: LD_ADDR_VAR 0 5
20919: PUSH
20920: LD_INT 30
20922: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20923: LD_ADDR_EXP 46
20927: PUSH
20928: LD_EXP 46
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: LD_VAR 0 5
20942: PPUSH
20943: LD_EXP 61
20947: PUSH
20948: LD_VAR 0 1
20952: ARRAY
20953: PUSH
20954: LD_VAR 0 4
20958: ARRAY
20959: PUSH
20960: LD_EXP 61
20964: PUSH
20965: LD_VAR 0 1
20969: ARRAY
20970: PUSH
20971: LD_VAR 0 4
20975: PUSH
20976: LD_INT 1
20978: PLUS
20979: ARRAY
20980: PUSH
20981: LD_INT 0
20983: PPUSH
20984: LD_INT 5
20986: PPUSH
20987: CALL_OW 12
20991: PUSH
20992: EMPTY
20993: LIST
20994: LIST
20995: LIST
20996: PPUSH
20997: CALL 41960 0 4
21001: ST_TO_ADDR
// p := p + 3 ;
21002: LD_ADDR_VAR 0 4
21006: PUSH
21007: LD_VAR 0 4
21011: PUSH
21012: LD_INT 3
21014: PLUS
21015: ST_TO_ADDR
// end ;
21016: GO 20876
21018: POP
21019: POP
// end ;
21020: LD_VAR 0 2
21024: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21025: LD_INT 0
21027: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21028: LD_ADDR_EXP 46
21032: PUSH
21033: LD_EXP 46
21037: PPUSH
21038: LD_VAR 0 1
21042: PPUSH
21043: LD_INT 4
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: CALL 41960 0 4
21055: ST_TO_ADDR
// end ;
21056: LD_VAR 0 3
21060: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21061: LD_INT 0
21063: PPUSH
// case nation of 1 , us :
21064: LD_VAR 0 2
21068: PUSH
21069: LD_INT 1
21071: DOUBLE
21072: EQUAL
21073: IFTRUE 21083
21075: LD_STRING us
21077: DOUBLE
21078: EQUAL
21079: IFTRUE 21083
21081: GO 21114
21083: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21084: LD_ADDR_EXP 46
21088: PUSH
21089: LD_EXP 46
21093: PPUSH
21094: LD_VAR 0 1
21098: PPUSH
21099: LD_INT 36
21101: PPUSH
21102: LD_VAR 0 3
21106: PPUSH
21107: CALL 41960 0 4
21111: ST_TO_ADDR
21112: GO 21165
21114: LD_INT 2
21116: DOUBLE
21117: EQUAL
21118: IFTRUE 21128
21120: LD_STRING ar
21122: DOUBLE
21123: EQUAL
21124: IFTRUE 21128
21126: GO 21164
21128: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21129: LD_ADDR_EXP 46
21133: PUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: LD_INT 14
21141: PUSH
21142: LD_INT 2
21144: PUSH
21145: LD_INT 1
21147: PUSH
21148: LD_INT 31
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL 21170 0 2
21161: ST_TO_ADDR
21162: GO 21165
21164: POP
// end ;
21165: LD_VAR 0 4
21169: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21170: LD_INT 0
21172: PPUSH
21173: PPUSH
// for i = 1 to list do
21174: LD_ADDR_VAR 0 4
21178: PUSH
21179: DOUBLE
21180: LD_INT 1
21182: DEC
21183: ST_TO_ADDR
21184: LD_VAR 0 2
21188: PUSH
21189: FOR_TO
21190: IFFALSE 21240
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21192: LD_ADDR_EXP 51
21196: PUSH
21197: LD_EXP 51
21201: PPUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: LD_EXP 51
21211: PUSH
21212: LD_VAR 0 1
21216: ARRAY
21217: PUSH
21218: LD_INT 1
21220: PLUS
21221: PPUSH
21222: LD_VAR 0 2
21226: PUSH
21227: LD_VAR 0 4
21231: ARRAY
21232: PPUSH
21233: CALL 31130 0 4
21237: ST_TO_ADDR
21238: GO 21189
21240: POP
21241: POP
// end ;
21242: LD_VAR 0 3
21246: RET
// export function MCS_GetVehicleList ( side ) ; begin
21247: LD_INT 0
21249: PPUSH
// result := MREG_ToConstruct [ side ] ;
21250: LD_ADDR_VAR 0 2
21254: PUSH
21255: LD_EXP 51
21259: PUSH
21260: LD_VAR 0 1
21264: ARRAY
21265: ST_TO_ADDR
// end ;
21266: LD_VAR 0 2
21270: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21271: LD_INT 0
21273: PPUSH
21274: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21275: LD_ADDR_EXP 58
21279: PUSH
21280: LD_EXP 58
21284: PPUSH
21285: LD_VAR 0 1
21289: PPUSH
21290: LD_VAR 0 2
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// end ;
21300: LD_VAR 0 3
21304: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21305: LD_INT 0
21307: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21308: LD_ADDR_EXP 37
21312: PUSH
21313: LD_EXP 37
21317: PPUSH
21318: LD_VAR 0 1
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// end ;
21333: LD_VAR 0 3
21337: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21338: LD_INT 0
21340: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21341: LD_ADDR_EXP 38
21345: PUSH
21346: LD_EXP 38
21350: PPUSH
21351: LD_VAR 0 1
21355: PPUSH
21356: LD_VAR 0 2
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 3
21370: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21374: LD_ADDR_EXP 60
21378: PUSH
21379: LD_EXP 60
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_INT 1
21391: PPUSH
21392: LD_VAR 0 2
21396: PPUSH
21397: CALL 31130 0 4
21401: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21402: LD_ADDR_EXP 60
21406: PUSH
21407: LD_EXP 60
21411: PPUSH
21412: LD_VAR 0 1
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: LD_VAR 0 3
21424: PPUSH
21425: CALL 31130 0 4
21429: ST_TO_ADDR
// end ;
21430: LD_VAR 0 4
21434: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21435: LD_INT 0
21437: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21438: LD_ADDR_EXP 72
21442: PUSH
21443: LD_EXP 72
21447: PPUSH
21448: LD_INT 1
21450: PPUSH
21451: LD_VAR 0 1
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21461: LD_ADDR_EXP 72
21465: PUSH
21466: LD_EXP 72
21470: PPUSH
21471: LD_INT 2
21473: PPUSH
21474: LD_VAR 0 2
21478: PPUSH
21479: CALL_OW 1
21483: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21484: LD_ADDR_EXP 72
21488: PUSH
21489: LD_EXP 72
21493: PPUSH
21494: LD_INT 3
21496: PPUSH
21497: LD_VAR 0 3
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// end ;
21507: LD_VAR 0 4
21511: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21512: LD_INT 0
21514: PPUSH
21515: PPUSH
21516: PPUSH
// if not side or not list then
21517: LD_VAR 0 1
21521: NOT
21522: PUSH
21523: LD_VAR 0 2
21527: NOT
21528: OR
21529: IFFALSE 21533
// exit ;
21531: GO 21701
// SetTech ( 20 , side , state_researched ) ;
21533: LD_INT 20
21535: PPUSH
21536: LD_VAR 0 1
21540: PPUSH
21541: LD_INT 2
21543: PPUSH
21544: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21548: LD_ADDR_EXP 61
21552: PUSH
21553: LD_EXP 61
21557: PPUSH
21558: LD_VAR 0 1
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: CALL_OW 2
21572: ST_TO_ADDR
// p := 1 ;
21573: LD_ADDR_VAR 0 5
21577: PUSH
21578: LD_INT 1
21580: ST_TO_ADDR
// for i = 1 to list / 3 do
21581: LD_ADDR_VAR 0 4
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_VAR 0 2
21595: PUSH
21596: LD_INT 3
21598: DIVREAL
21599: PUSH
21600: FOR_TO
21601: IFFALSE 21699
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21603: LD_VAR 0 2
21607: PUSH
21608: LD_VAR 0 5
21612: ARRAY
21613: PPUSH
21614: LD_VAR 0 2
21618: PUSH
21619: LD_VAR 0 5
21623: PUSH
21624: LD_INT 1
21626: PLUS
21627: ARRAY
21628: PPUSH
21629: LD_VAR 0 2
21633: PUSH
21634: LD_VAR 0 5
21638: PUSH
21639: LD_INT 2
21641: PLUS
21642: ARRAY
21643: PPUSH
21644: CALL 22403 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21648: LD_VAR 0 2
21652: PUSH
21653: LD_VAR 0 5
21657: ARRAY
21658: PPUSH
21659: LD_VAR 0 2
21663: PUSH
21664: LD_VAR 0 5
21668: PUSH
21669: LD_INT 1
21671: PLUS
21672: ARRAY
21673: PPUSH
21674: LD_VAR 0 1
21678: PPUSH
21679: CALL_OW 441
// p := p + 3 ;
21683: LD_ADDR_VAR 0 5
21687: PUSH
21688: LD_VAR 0 5
21692: PUSH
21693: LD_INT 3
21695: PLUS
21696: ST_TO_ADDR
// end ;
21697: GO 21600
21699: POP
21700: POP
// end ;
21701: LD_VAR 0 3
21705: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21706: LD_INT 0
21708: PPUSH
21709: PPUSH
// if nat = nation_arabian then
21710: LD_VAR 0 2
21714: PUSH
21715: LD_INT 2
21717: EQUAL
21718: IFFALSE 21724
// exit else
21720: GO 21796
21722: GO 21782
// if nat = nation_american then
21724: LD_VAR 0 2
21728: PUSH
21729: LD_INT 1
21731: EQUAL
21732: IFFALSE 21759
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21734: LD_ADDR_VAR 0 4
21738: PUSH
21739: LD_INT 4
21741: PUSH
21742: LD_INT 3
21744: PUSH
21745: LD_INT 1
21747: PUSH
21748: LD_INT 8
21750: PUSH
21751: EMPTY
21752: LIST
21753: LIST
21754: LIST
21755: LIST
21756: ST_TO_ADDR
21757: GO 21782
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21759: LD_ADDR_VAR 0 4
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 48
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21782: LD_VAR 0 1
21786: PPUSH
21787: LD_VAR 0 4
21791: PPUSH
21792: CALL 21170 0 2
// end ;
21796: LD_VAR 0 3
21800: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21801: LD_INT 0
21803: PPUSH
21804: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21805: LD_ADDR_EXP 63
21809: PUSH
21810: LD_EXP 63
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: LD_INT 1
21822: PPUSH
21823: LD_VAR 0 4
21827: PPUSH
21828: CALL 31130 0 4
21832: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21833: LD_ADDR_EXP 64
21837: PUSH
21838: LD_EXP 64
21842: PPUSH
21843: LD_VAR 0 1
21847: PPUSH
21848: LD_INT 1
21850: PPUSH
21851: LD_VAR 0 2
21855: PPUSH
21856: CALL 31130 0 4
21860: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21861: LD_ADDR_EXP 65
21865: PUSH
21866: LD_EXP 65
21870: PPUSH
21871: LD_VAR 0 1
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_VAR 0 3
21883: PPUSH
21884: CALL 31130 0 4
21888: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21889: LD_ADDR_EXP 66
21893: PUSH
21894: LD_EXP 66
21898: PPUSH
21899: LD_VAR 0 1
21903: PPUSH
21904: LD_INT 1
21906: PPUSH
21907: LD_VAR 0 5
21911: PPUSH
21912: CALL 31130 0 4
21916: ST_TO_ADDR
// while squad do
21917: LD_VAR 0 5
21921: IFFALSE 22014
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21923: LD_VAR 0 1
21927: PPUSH
21928: LD_VAR 0 5
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PUSH
21937: LD_VAR 0 5
21941: PUSH
21942: LD_INT 2
21944: ARRAY
21945: PUSH
21946: LD_VAR 0 5
21950: PUSH
21951: LD_INT 3
21953: ARRAY
21954: PUSH
21955: LD_VAR 0 5
21959: PUSH
21960: LD_INT 4
21962: ARRAY
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: PPUSH
21970: CALL 21170 0 2
// for i = 1 to 4 do
21974: LD_ADDR_VAR 0 7
21978: PUSH
21979: DOUBLE
21980: LD_INT 1
21982: DEC
21983: ST_TO_ADDR
21984: LD_INT 4
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22010
// squad := Delete ( squad , 1 ) ;
21990: LD_ADDR_VAR 0 5
21994: PUSH
21995: LD_VAR 0 5
21999: PPUSH
22000: LD_INT 1
22002: PPUSH
22003: CALL_OW 3
22007: ST_TO_ADDR
22008: GO 21987
22010: POP
22011: POP
// end ;
22012: GO 21917
// end ;
22014: LD_VAR 0 6
22018: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22019: LD_INT 0
22021: PPUSH
22022: PPUSH
// for i = 1 to squad do
22023: LD_ADDR_VAR 0 4
22027: PUSH
22028: DOUBLE
22029: LD_INT 1
22031: DEC
22032: ST_TO_ADDR
22033: LD_VAR 0 2
22037: PUSH
22038: FOR_TO
22039: IFFALSE 22089
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22041: LD_ADDR_EXP 69
22045: PUSH
22046: LD_EXP 69
22050: PPUSH
22051: LD_VAR 0 1
22055: PPUSH
22056: LD_EXP 69
22060: PUSH
22061: LD_VAR 0 1
22065: ARRAY
22066: PUSH
22067: LD_INT 1
22069: PLUS
22070: PPUSH
22071: LD_VAR 0 2
22075: PUSH
22076: LD_VAR 0 4
22080: ARRAY
22081: PPUSH
22082: CALL 31130 0 4
22086: ST_TO_ADDR
22087: GO 22038
22089: POP
22090: POP
// while squad do
22091: LD_VAR 0 2
22095: IFFALSE 22188
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22097: LD_VAR 0 1
22101: PPUSH
22102: LD_VAR 0 2
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: PUSH
22111: LD_VAR 0 2
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PUSH
22120: LD_VAR 0 2
22124: PUSH
22125: LD_INT 3
22127: ARRAY
22128: PUSH
22129: LD_VAR 0 2
22133: PUSH
22134: LD_INT 4
22136: ARRAY
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: LIST
22143: PPUSH
22144: CALL 21170 0 2
// for i = 1 to 4 do
22148: LD_ADDR_VAR 0 4
22152: PUSH
22153: DOUBLE
22154: LD_INT 1
22156: DEC
22157: ST_TO_ADDR
22158: LD_INT 4
22160: PUSH
22161: FOR_TO
22162: IFFALSE 22184
// squad := Delete ( squad , 1 ) ;
22164: LD_ADDR_VAR 0 2
22168: PUSH
22169: LD_VAR 0 2
22173: PPUSH
22174: LD_INT 1
22176: PPUSH
22177: CALL_OW 3
22181: ST_TO_ADDR
22182: GO 22161
22184: POP
22185: POP
// end ;
22186: GO 22091
// end ;
22188: LD_VAR 0 3
22192: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22193: LD_INT 0
22195: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22196: LD_ADDR_EXP 62
22200: PUSH
22201: LD_EXP 62
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 2
22218: PPUSH
22219: CALL 31130 0 4
22223: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22224: LD_ADDR_EXP 62
22228: PUSH
22229: LD_EXP 62
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: LD_VAR 0 3
22246: PPUSH
22247: CALL 31130 0 4
22251: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22252: LD_ADDR_EXP 62
22256: PUSH
22257: LD_EXP 62
22261: PPUSH
22262: LD_VAR 0 1
22266: PPUSH
22267: LD_INT 3
22269: PPUSH
22270: LD_VAR 0 4
22274: PPUSH
22275: CALL 31130 0 4
22279: ST_TO_ADDR
// end ; end_of_file
22280: LD_VAR 0 5
22284: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22285: LD_INT 0
22287: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22288: LD_ADDR_EXP 42
22292: PUSH
22293: LD_EXP 42
22297: PPUSH
22298: LD_VAR 0 1
22302: PPUSH
22303: LD_INT 1
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: CALL 31130 0 4
22315: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL 11786 0 2
22327: PUSH
22328: LD_INT 1
22330: ARRAY
22331: PPUSH
22332: CALL_OW 248
22336: PUSH
22337: LD_INT 1
22339: EQUAL
22340: IFFALSE 22371
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 1
22352: PUSH
22353: LD_INT 1
22355: PUSH
22356: LD_INT 14
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: PPUSH
22365: CALL 21170 0 2
22369: GO 22398
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 24
22378: PUSH
22379: LD_INT 1
22381: PUSH
22382: LD_INT 1
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: LIST
22393: PPUSH
22394: CALL 21170 0 2
// end ;
22398: LD_VAR 0 3
22402: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22403: LD_INT 0
22405: PPUSH
// CreateDepositXY ( x , y , t ) ;
22406: LD_VAR 0 1
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: LD_VAR 0 3
22420: PPUSH
22421: CALL_OW 62
// end ;
22425: LD_VAR 0 4
22429: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22430: LD_INT 0
22432: PPUSH
22433: PPUSH
// c := 1 ;
22434: LD_ADDR_VAR 0 5
22438: PUSH
22439: LD_INT 1
22441: ST_TO_ADDR
// case color of red :
22442: LD_VAR 0 3
22446: PUSH
22447: LD_STRING red
22449: DOUBLE
22450: EQUAL
22451: IFTRUE 22455
22453: GO 22466
22455: POP
// c = 1 ; dark-green :
22456: LD_ADDR_VAR 0 5
22460: PUSH
22461: LD_INT 1
22463: ST_TO_ADDR
22464: GO 22752
22466: LD_STRING dark-green
22468: DOUBLE
22469: EQUAL
22470: IFTRUE 22474
22472: GO 22485
22474: POP
// c = 2 ; purple :
22475: LD_ADDR_VAR 0 5
22479: PUSH
22480: LD_INT 2
22482: ST_TO_ADDR
22483: GO 22752
22485: LD_STRING purple
22487: DOUBLE
22488: EQUAL
22489: IFTRUE 22493
22491: GO 22504
22493: POP
// c = 3 ; aqua :
22494: LD_ADDR_VAR 0 5
22498: PUSH
22499: LD_INT 3
22501: ST_TO_ADDR
22502: GO 22752
22504: LD_STRING aqua
22506: DOUBLE
22507: EQUAL
22508: IFTRUE 22512
22510: GO 22523
22512: POP
// c = 4 ; grey :
22513: LD_ADDR_VAR 0 5
22517: PUSH
22518: LD_INT 4
22520: ST_TO_ADDR
22521: GO 22752
22523: LD_STRING grey
22525: DOUBLE
22526: EQUAL
22527: IFTRUE 22531
22529: GO 22542
22531: POP
// c = 5 ; lime :
22532: LD_ADDR_VAR 0 5
22536: PUSH
22537: LD_INT 5
22539: ST_TO_ADDR
22540: GO 22752
22542: LD_STRING lime
22544: DOUBLE
22545: EQUAL
22546: IFTRUE 22550
22548: GO 22561
22550: POP
// c = 6 ; tan :
22551: LD_ADDR_VAR 0 5
22555: PUSH
22556: LD_INT 6
22558: ST_TO_ADDR
22559: GO 22752
22561: LD_STRING tan
22563: DOUBLE
22564: EQUAL
22565: IFTRUE 22569
22567: GO 22580
22569: POP
// c = 7 ; pink :
22570: LD_ADDR_VAR 0 5
22574: PUSH
22575: LD_INT 7
22577: ST_TO_ADDR
22578: GO 22752
22580: LD_STRING pink
22582: DOUBLE
22583: EQUAL
22584: IFTRUE 22588
22586: GO 22599
22588: POP
// c = 8 ; green :
22589: LD_ADDR_VAR 0 5
22593: PUSH
22594: LD_INT 8
22596: ST_TO_ADDR
22597: GO 22752
22599: LD_STRING green
22601: DOUBLE
22602: EQUAL
22603: IFTRUE 22607
22605: GO 22618
22607: POP
// c = 9 ; blue :
22608: LD_ADDR_VAR 0 5
22612: PUSH
22613: LD_INT 9
22615: ST_TO_ADDR
22616: GO 22752
22618: LD_STRING blue
22620: DOUBLE
22621: EQUAL
22622: IFTRUE 22626
22624: GO 22637
22626: POP
// c = 10 ; yellow :
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_INT 10
22634: ST_TO_ADDR
22635: GO 22752
22637: LD_STRING yellow
22639: DOUBLE
22640: EQUAL
22641: IFTRUE 22645
22643: GO 22656
22645: POP
// c = 11 ; brown :
22646: LD_ADDR_VAR 0 5
22650: PUSH
22651: LD_INT 11
22653: ST_TO_ADDR
22654: GO 22752
22656: LD_STRING brown
22658: DOUBLE
22659: EQUAL
22660: IFTRUE 22664
22662: GO 22675
22664: POP
// c = 12 ; black :
22665: LD_ADDR_VAR 0 5
22669: PUSH
22670: LD_INT 12
22672: ST_TO_ADDR
22673: GO 22752
22675: LD_STRING black
22677: DOUBLE
22678: EQUAL
22679: IFTRUE 22683
22681: GO 22694
22683: POP
// c = 13 ; aqua2 :
22684: LD_ADDR_VAR 0 5
22688: PUSH
22689: LD_INT 13
22691: ST_TO_ADDR
22692: GO 22752
22694: LD_STRING aqua2
22696: DOUBLE
22697: EQUAL
22698: IFTRUE 22702
22700: GO 22713
22702: POP
// c = 14 ; orange :
22703: LD_ADDR_VAR 0 5
22707: PUSH
22708: LD_INT 14
22710: ST_TO_ADDR
22711: GO 22752
22713: LD_STRING orange
22715: DOUBLE
22716: EQUAL
22717: IFTRUE 22721
22719: GO 22732
22721: POP
// c = 15 ; white :
22722: LD_ADDR_VAR 0 5
22726: PUSH
22727: LD_INT 15
22729: ST_TO_ADDR
22730: GO 22752
22732: LD_STRING white
22734: DOUBLE
22735: EQUAL
22736: IFTRUE 22740
22738: GO 22751
22740: POP
// c = 16 ; end ;
22741: LD_ADDR_VAR 0 5
22745: PUSH
22746: LD_INT 16
22748: ST_TO_ADDR
22749: GO 22752
22751: POP
// if HexInfo ( x , y ) = 0 then
22752: LD_VAR 0 1
22756: PPUSH
22757: LD_VAR 0 2
22761: PPUSH
22762: CALL_OW 428
22766: PUSH
22767: LD_INT 0
22769: EQUAL
22770: IFFALSE 22794
// PlaceEnvironment ( x , y , 58 , c ) ;
22772: LD_VAR 0 1
22776: PPUSH
22777: LD_VAR 0 2
22781: PPUSH
22782: LD_INT 58
22784: PPUSH
22785: LD_VAR 0 5
22789: PPUSH
22790: CALL_OW 349
// end ;
22794: LD_VAR 0 4
22798: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22799: LD_INT 0
22801: PPUSH
// RemoveEnvironment ( x , y ) ;
22802: LD_VAR 0 1
22806: PPUSH
22807: LD_VAR 0 2
22811: PPUSH
22812: CALL_OW 347
// end ;
22816: LD_VAR 0 3
22820: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22821: LD_INT 0
22823: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22824: LD_ADDR_VAR 0 5
22828: PUSH
22829: LD_INT 81
22831: PUSH
22832: LD_VAR 0 1
22836: PUSH
22837: EMPTY
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 92
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: LD_VAR 0 3
22853: PUSH
22854: LD_VAR 0 4
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PPUSH
22869: CALL_OW 69
22873: ST_TO_ADDR
// end ;
22874: LD_VAR 0 5
22878: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22879: LD_INT 0
22881: PPUSH
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22886: LD_VAR 0 1
22890: PPUSH
22891: LD_INT 81
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 255
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: PPUSH
22908: CALL_OW 69
22912: PPUSH
22913: LD_VAR 0 1
22917: PPUSH
22918: CALL_OW 74
22922: PPUSH
22923: CALL_OW 119
// dir := GetDir ( un ) ;
22927: LD_ADDR_VAR 0 4
22931: PUSH
22932: LD_VAR 0 1
22936: PPUSH
22937: CALL_OW 254
22941: ST_TO_ADDR
// dir := dir - 3 ;
22942: LD_ADDR_VAR 0 4
22946: PUSH
22947: LD_VAR 0 4
22951: PUSH
22952: LD_INT 3
22954: MINUS
22955: ST_TO_ADDR
// if dir < 0 then
22956: LD_VAR 0 4
22960: PUSH
22961: LD_INT 0
22963: LESS
22964: IFFALSE 22980
// dir := dir + 6 ;
22966: LD_ADDR_VAR 0 4
22970: PUSH
22971: LD_VAR 0 4
22975: PUSH
22976: LD_INT 6
22978: PLUS
22979: ST_TO_ADDR
// while true do
22980: LD_INT 1
22982: IFFALSE 23479
// begin coord_dist := 3 ;
22984: LD_ADDR_VAR 0 3
22988: PUSH
22989: LD_INT 3
22991: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 4
23011: PPUSH
23012: LD_VAR 0 3
23016: PPUSH
23017: CALL_OW 272
23021: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23022: LD_ADDR_VAR 0 6
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: CALL_OW 251
23036: PPUSH
23037: LD_VAR 0 4
23041: PPUSH
23042: LD_VAR 0 3
23046: PPUSH
23047: CALL_OW 273
23051: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23052: LD_VAR 0 1
23056: PPUSH
23057: CALL_OW 255
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: CALL_OW 250
23071: PPUSH
23072: LD_VAR 0 1
23076: PPUSH
23077: CALL_OW 251
23081: PPUSH
23082: LD_INT 14
23084: PPUSH
23085: CALL 22821 0 4
23089: PUSH
23090: LD_VAR 0 5
23094: PPUSH
23095: LD_VAR 0 6
23099: PPUSH
23100: CALL_OW 351
23104: OR
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 488
23120: PUSH
23121: LD_INT 0
23123: EQUAL
23124: OR
23125: PUSH
23126: LD_VAR 0 5
23130: PPUSH
23131: LD_VAR 0 6
23135: PPUSH
23136: CALL_OW 546
23140: PUSH
23141: LD_INT 1
23143: EQUAL
23144: OR
23145: PUSH
23146: LD_VAR 0 5
23150: PPUSH
23151: LD_VAR 0 6
23155: PPUSH
23156: CALL_OW 428
23160: PUSH
23161: LD_INT 0
23163: NONEQUAL
23164: OR
23165: IFFALSE 23393
// begin repeat begin Wait ( 0 0$0.3 ) ;
23167: LD_INT 10
23169: PPUSH
23170: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23174: LD_ADDR_VAR 0 3
23178: PUSH
23179: LD_VAR 0 3
23183: PUSH
23184: LD_INT 1
23186: PLUS
23187: ST_TO_ADDR
// dir := dir + 1 ;
23188: LD_ADDR_VAR 0 4
23192: PUSH
23193: LD_VAR 0 4
23197: PUSH
23198: LD_INT 1
23200: PLUS
23201: ST_TO_ADDR
// if dir > 5 then
23202: LD_VAR 0 4
23206: PUSH
23207: LD_INT 5
23209: GREATER
23210: IFFALSE 23220
// dir = 0 ;
23212: LD_ADDR_VAR 0 4
23216: PUSH
23217: LD_INT 0
23219: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23220: LD_ADDR_VAR 0 5
23224: PUSH
23225: LD_VAR 0 1
23229: PPUSH
23230: CALL_OW 250
23234: PPUSH
23235: LD_VAR 0 4
23239: PPUSH
23240: LD_VAR 0 3
23244: PPUSH
23245: CALL_OW 272
23249: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23250: LD_ADDR_VAR 0 6
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 251
23264: PPUSH
23265: LD_VAR 0 4
23269: PPUSH
23270: LD_VAR 0 3
23274: PPUSH
23275: CALL_OW 273
23279: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23280: LD_VAR 0 1
23284: PPUSH
23285: CALL_OW 255
23289: PPUSH
23290: LD_VAR 0 1
23294: PPUSH
23295: CALL_OW 250
23299: PPUSH
23300: LD_VAR 0 1
23304: PPUSH
23305: CALL_OW 251
23309: PPUSH
23310: LD_INT 14
23312: PPUSH
23313: CALL 22821 0 4
23317: NOT
23318: PUSH
23319: LD_VAR 0 5
23323: PPUSH
23324: LD_VAR 0 6
23328: PPUSH
23329: CALL_OW 351
23333: NOT
23334: AND
23335: PUSH
23336: LD_VAR 0 5
23340: PPUSH
23341: LD_VAR 0 6
23345: PPUSH
23346: CALL_OW 488
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 546
23366: PUSH
23367: LD_INT 0
23369: EQUAL
23370: AND
23371: PUSH
23372: LD_VAR 0 5
23376: PPUSH
23377: LD_VAR 0 6
23381: PPUSH
23382: CALL_OW 428
23386: PUSH
23387: LD_INT 0
23389: EQUAL
23390: AND
23391: IFFALSE 23167
// end ; ComMoveXY ( un , x , y ) ;
23393: LD_VAR 0 1
23397: PPUSH
23398: LD_VAR 0 5
23402: PPUSH
23403: LD_VAR 0 6
23407: PPUSH
23408: CALL_OW 111
// Wait ( 0 0$1 ) ;
23412: LD_INT 35
23414: PPUSH
23415: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23419: LD_VAR 0 1
23423: PPUSH
23424: LD_INT 81
23426: PUSH
23427: LD_VAR 0 1
23431: PPUSH
23432: CALL_OW 255
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 69
23445: PPUSH
23446: LD_VAR 0 1
23450: PPUSH
23451: CALL_OW 74
23455: PPUSH
23456: CALL_OW 296
23460: PUSH
23461: LD_INT 14
23463: GREATEREQUAL
23464: IFFALSE 23477
// begin ComStop ( un ) ;
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 141
// break ;
23475: GO 23479
// end ; end ;
23477: GO 22980
// end ;
23479: LD_VAR 0 2
23483: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23484: LD_INT 0
23486: PPUSH
23487: PPUSH
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// x := GetX ( unit ) ;
23494: LD_ADDR_VAR 0 3
23498: PUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 250
23508: ST_TO_ADDR
// y := GetY ( unit ) ;
23509: LD_ADDR_VAR 0 4
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 251
23523: ST_TO_ADDR
// i := 0 ;
23524: LD_ADDR_VAR 0 8
23528: PUSH
23529: LD_INT 0
23531: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23532: LD_VAR 0 1
23536: PPUSH
23537: LD_INT 81
23539: PUSH
23540: LD_VAR 0 1
23544: PPUSH
23545: CALL_OW 255
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 69
23558: PPUSH
23559: LD_VAR 0 1
23563: PPUSH
23564: CALL_OW 74
23568: PPUSH
23569: CALL_OW 119
// dir := GetDir ( unit ) ;
23573: LD_ADDR_VAR 0 7
23577: PUSH
23578: LD_VAR 0 1
23582: PPUSH
23583: CALL_OW 254
23587: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23588: LD_ADDR_VAR 0 9
23592: PUSH
23593: LD_INT 0
23595: PPUSH
23596: LD_INT 1
23598: PPUSH
23599: CALL_OW 12
23603: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23604: LD_INT 10
23606: PPUSH
23607: CALL_OW 67
// if mode then
23611: LD_VAR 0 9
23615: IFFALSE 23633
// dir := dir + 1 else
23617: LD_ADDR_VAR 0 7
23621: PUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_INT 1
23629: PLUS
23630: ST_TO_ADDR
23631: GO 23647
// dir := dir - 1 ;
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: MINUS
23646: ST_TO_ADDR
// if ( dir < 0 ) then
23647: LD_VAR 0 7
23651: PUSH
23652: LD_INT 0
23654: LESS
23655: IFFALSE 23665
// dir := 5 ;
23657: LD_ADDR_VAR 0 7
23661: PUSH
23662: LD_INT 5
23664: ST_TO_ADDR
// if ( dir > 5 ) then
23665: LD_VAR 0 7
23669: PUSH
23670: LD_INT 5
23672: GREATER
23673: IFFALSE 23683
// dir := 0 ;
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: LD_INT 0
23682: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23683: LD_ADDR_VAR 0 5
23687: PUSH
23688: LD_VAR 0 3
23692: PPUSH
23693: LD_VAR 0 7
23697: PPUSH
23698: LD_INT 4
23700: PPUSH
23701: CALL_OW 272
23705: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23706: LD_ADDR_VAR 0 6
23710: PUSH
23711: LD_VAR 0 4
23715: PPUSH
23716: LD_VAR 0 7
23720: PPUSH
23721: LD_INT 4
23723: PPUSH
23724: CALL_OW 273
23728: ST_TO_ADDR
// i := i + 1 ;
23729: LD_ADDR_VAR 0 8
23733: PUSH
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 1
23741: PLUS
23742: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23743: LD_VAR 0 1
23747: PPUSH
23748: CALL_OW 255
23752: PPUSH
23753: LD_VAR 0 5
23757: PPUSH
23758: LD_VAR 0 6
23762: PPUSH
23763: LD_INT 14
23765: PPUSH
23766: CALL 22821 0 4
23770: PUSH
23771: LD_INT 0
23773: EQUAL
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_VAR 0 6
23784: PPUSH
23785: CALL_OW 546
23789: PUSH
23790: LD_INT 0
23792: EQUAL
23793: AND
23794: PUSH
23795: LD_VAR 0 5
23799: PPUSH
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 428
23809: PUSH
23810: LD_INT 0
23812: EQUAL
23813: AND
23814: IFFALSE 23818
// break ;
23816: GO 23828
// end until i > 4 ;
23818: LD_VAR 0 8
23822: PUSH
23823: LD_INT 4
23825: GREATER
23826: IFFALSE 23604
// if x2 and y2 then
23828: LD_VAR 0 5
23832: PUSH
23833: LD_VAR 0 6
23837: AND
23838: IFFALSE 23861
// result := [ x2 , y2 ] else
23840: LD_ADDR_VAR 0 2
23844: PUSH
23845: LD_VAR 0 5
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: ST_TO_ADDR
23859: GO 23890
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23861: LD_ADDR_VAR 0 2
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 250
23875: PUSH
23876: LD_VAR 0 1
23880: PPUSH
23881: CALL_OW 251
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// end ;
23890: LD_VAR 0 2
23894: RET
// export function MCT_Hex ( x , y ) ; begin
23895: LD_INT 0
23897: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23898: LD_ADDR_VAR 0 3
23902: PUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL_OW 546
23917: PUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: LD_VAR 0 2
23927: PPUSH
23928: CALL_OW 428
23932: PUSH
23933: EMPTY
23934: LIST
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 3
23944: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23960: LD_ADDR_VAR 0 10
23964: PUSH
23965: LD_EXP 60
23969: PUSH
23970: LD_VAR 0 1
23974: ARRAY
23975: PUSH
23976: LD_INT 1
23978: ARRAY
23979: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23980: LD_ADDR_VAR 0 11
23984: PUSH
23985: LD_EXP 60
23989: PUSH
23990: LD_VAR 0 1
23994: ARRAY
23995: PUSH
23996: LD_INT 2
23998: ARRAY
23999: ST_TO_ADDR
// collectors := [ ] ;
24000: LD_ADDR_VAR 0 12
24004: PUSH
24005: EMPTY
24006: ST_TO_ADDR
// is_cargo := false ;
24007: LD_ADDR_VAR 0 13
24011: PUSH
24012: LD_INT 0
24014: ST_TO_ADDR
// if isTest then
24015: LD_EXP 1
24019: IFFALSE 24025
// TimerStart ( ) ;
24021: CALL_OW 548
// if MCF_Cargo ( side ) then
24025: LD_VAR 0 1
24029: PPUSH
24030: CALL 12002 0 1
24034: IFFALSE 24061
// begin collectors := MCF_Cargo ( side ) ;
24036: LD_ADDR_VAR 0 12
24040: PUSH
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12002 0 1
24050: ST_TO_ADDR
// is_cargo := true ;
24051: LD_ADDR_VAR 0 13
24055: PUSH
24056: LD_INT 1
24058: ST_TO_ADDR
// end else
24059: GO 24210
// begin if MCF_ApeSpec ( side , engineer ) then
24061: LD_VAR 0 1
24065: PPUSH
24066: LD_STRING engineer
24068: PPUSH
24069: CALL 12148 0 2
24073: IFFALSE 24093
// collectors := MCF_ApeSpec ( side , engineer ) ;
24075: LD_ADDR_VAR 0 12
24079: PUSH
24080: LD_VAR 0 1
24084: PPUSH
24085: LD_STRING engineer
24087: PPUSH
24088: CALL 12148 0 2
24092: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24093: LD_VAR 0 1
24097: PPUSH
24098: LD_INT 2
24100: PPUSH
24101: EMPTY
24102: PPUSH
24103: CALL 11734 0 3
24107: IFFALSE 24210
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24109: LD_ADDR_VAR 0 7
24113: PUSH
24114: LD_VAR 0 1
24118: PPUSH
24119: LD_INT 2
24121: PPUSH
24122: EMPTY
24123: PPUSH
24124: CALL 11734 0 3
24128: ST_TO_ADDR
// if z > 5 then
24129: LD_VAR 0 7
24133: PUSH
24134: LD_INT 5
24136: GREATER
24137: IFFALSE 24149
// t1 := 5 else
24139: LD_ADDR_VAR 0 8
24143: PUSH
24144: LD_INT 5
24146: ST_TO_ADDR
24147: GO 24159
// t1 := z ;
24149: LD_ADDR_VAR 0 8
24153: PUSH
24154: LD_VAR 0 7
24158: ST_TO_ADDR
// for t2 = 1 to t1 do
24159: LD_ADDR_VAR 0 9
24163: PUSH
24164: DOUBLE
24165: LD_INT 1
24167: DEC
24168: ST_TO_ADDR
24169: LD_VAR 0 8
24173: PUSH
24174: FOR_TO
24175: IFFALSE 24208
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24177: LD_ADDR_VAR 0 12
24181: PUSH
24182: LD_VAR 0 12
24186: PPUSH
24187: LD_INT 1
24189: PPUSH
24190: LD_VAR 0 7
24194: PUSH
24195: LD_VAR 0 9
24199: ARRAY
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
24206: GO 24174
24208: POP
24209: POP
// end ; end ; if not mode then
24210: LD_VAR 0 10
24214: NOT
24215: IFFALSE 24221
// exit else
24217: GO 24480
24219: GO 24480
// begin if collectors then
24221: LD_VAR 0 12
24225: IFFALSE 24480
// for i in areas do
24227: LD_ADDR_VAR 0 3
24231: PUSH
24232: LD_VAR 0 11
24236: PUSH
24237: FOR_IN
24238: IFFALSE 24478
// if GetListOfCratesInArea ( i ) then
24240: LD_VAR 0 3
24244: PPUSH
24245: CALL_OW 435
24249: IFFALSE 24476
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24251: LD_ADDR_VAR 0 5
24255: PUSH
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: PUSH
24266: LD_INT 1
24268: ARRAY
24269: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24270: LD_ADDR_VAR 0 6
24274: PUSH
24275: LD_VAR 0 3
24279: PPUSH
24280: CALL_OW 435
24284: PUSH
24285: LD_INT 2
24287: ARRAY
24288: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24289: LD_VAR 0 13
24293: PUSH
24294: LD_VAR 0 12
24298: PUSH
24299: LD_INT 1
24301: ARRAY
24302: PPUSH
24303: CALL_OW 110
24307: PUSH
24308: LD_INT 0
24310: EQUAL
24311: AND
24312: IFFALSE 24374
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24314: LD_VAR 0 12
24318: PUSH
24319: LD_INT 1
24321: ARRAY
24322: PPUSH
24323: CALL_OW 314
24327: NOT
24328: PUSH
24329: LD_VAR 0 12
24333: PUSH
24334: LD_INT 1
24336: ARRAY
24337: PPUSH
24338: CALL_OW 110
24342: PUSH
24343: LD_INT 0
24345: EQUAL
24346: AND
24347: IFFALSE 24372
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24349: LD_VAR 0 12
24353: PUSH
24354: LD_INT 1
24356: ARRAY
24357: PPUSH
24358: LD_VAR 0 5
24362: PPUSH
24363: LD_VAR 0 6
24367: PPUSH
24368: CALL_OW 117
// end ; end else
24372: GO 24460
// begin for j = 1 to collectors do
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: DOUBLE
24380: LD_INT 1
24382: DEC
24383: ST_TO_ADDR
24384: LD_VAR 0 12
24388: PUSH
24389: FOR_TO
24390: IFFALSE 24458
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24392: LD_VAR 0 12
24396: PUSH
24397: LD_VAR 0 4
24401: ARRAY
24402: PPUSH
24403: CALL_OW 314
24407: NOT
24408: PUSH
24409: LD_VAR 0 12
24413: PUSH
24414: LD_VAR 0 4
24418: ARRAY
24419: PPUSH
24420: CALL_OW 110
24424: PUSH
24425: LD_INT 0
24427: EQUAL
24428: AND
24429: IFFALSE 24456
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24431: LD_VAR 0 12
24435: PUSH
24436: LD_VAR 0 4
24440: ARRAY
24441: PPUSH
24442: LD_VAR 0 5
24446: PPUSH
24447: LD_VAR 0 6
24451: PPUSH
24452: CALL 24851 0 3
// end ;
24456: GO 24389
24458: POP
24459: POP
// end ; if isTest then
24460: LD_EXP 1
24464: IFFALSE 24476
// begin debug_time := TimerEnd ( ) ;
24466: LD_ADDR_VAR 0 14
24470: PUSH
24471: CALL_OW 549
24475: ST_TO_ADDR
// end ; end ;
24476: GO 24237
24478: POP
24479: POP
// end ; end ;
24480: LD_VAR 0 2
24484: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24485: LD_INT 0
24487: PPUSH
24488: PPUSH
24489: PPUSH
24490: PPUSH
24491: PPUSH
24492: PPUSH
// if not area then
24493: LD_VAR 0 1
24497: NOT
24498: IFFALSE 24504
// exit else
24500: GO 24766
24502: GO 24766
// if tick mod interval = 0 and Prob ( percent ) then
24504: LD_OWVAR 1
24508: PUSH
24509: LD_VAR 0 4
24513: MOD
24514: PUSH
24515: LD_INT 0
24517: EQUAL
24518: PUSH
24519: LD_VAR 0 3
24523: PPUSH
24524: CALL_OW 13
24528: AND
24529: IFFALSE 24766
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24531: LD_VAR 0 1
24535: PPUSH
24536: CALL_OW 435
24540: PUSH
24541: LD_VAR 0 5
24545: LESS
24546: PUSH
24547: LD_VAR 0 5
24551: PUSH
24552: LD_INT 0
24554: EQUAL
24555: OR
24556: IFFALSE 24766
// begin Randomize ;
24558: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24562: LD_ADDR_VAR 0 7
24566: PUSH
24567: LD_INT 1
24569: PPUSH
24570: LD_VAR 0 2
24574: PPUSH
24575: CALL_OW 12
24579: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24580: LD_ADDR_VAR 0 9
24584: PUSH
24585: LD_VAR 0 1
24589: PPUSH
24590: LD_INT 0
24592: PPUSH
24593: CALL_OW 517
24597: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24598: LD_ADDR_VAR 0 8
24602: PUSH
24603: LD_INT 1
24605: PPUSH
24606: LD_VAR 0 9
24610: PUSH
24611: LD_INT 1
24613: ARRAY
24614: PPUSH
24615: CALL_OW 12
24619: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24620: LD_VAR 0 9
24624: PUSH
24625: LD_INT 1
24627: ARRAY
24628: PUSH
24629: LD_VAR 0 8
24633: ARRAY
24634: PPUSH
24635: LD_VAR 0 9
24639: PUSH
24640: LD_INT 2
24642: ARRAY
24643: PUSH
24644: LD_VAR 0 8
24648: ARRAY
24649: PPUSH
24650: CALL_OW 428
24654: PUSH
24655: LD_INT 0
24657: GREATER
24658: PUSH
24659: LD_VAR 0 9
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PUSH
24668: LD_VAR 0 8
24672: ARRAY
24673: PPUSH
24674: LD_VAR 0 9
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PUSH
24683: LD_VAR 0 8
24687: ARRAY
24688: PPUSH
24689: CALL_OW 284
24693: PUSH
24694: LD_INT 0
24696: GREATER
24697: AND
24698: IFFALSE 24724
// c := Rand ( 1 , tmp [ 1 ] ) ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 1
24707: PPUSH
24708: LD_VAR 0 9
24712: PUSH
24713: LD_INT 1
24715: ARRAY
24716: PPUSH
24717: CALL_OW 12
24721: ST_TO_ADDR
24722: GO 24620
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24724: LD_VAR 0 7
24728: PPUSH
24729: LD_VAR 0 9
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PUSH
24738: LD_VAR 0 8
24742: ARRAY
24743: PPUSH
24744: LD_VAR 0 9
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PUSH
24753: LD_VAR 0 8
24757: ARRAY
24758: PPUSH
24759: LD_INT 1
24761: PPUSH
24762: CALL_OW 54
// end ; end ; end ;
24766: LD_VAR 0 6
24770: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24771: LD_INT 0
24773: PPUSH
24774: PPUSH
// if not MREG_Crates then
24775: LD_EXP 34
24779: NOT
24780: IFFALSE 24784
// exit ;
24782: GO 24846
// for i = MREG_Crates downto 1 do
24784: LD_ADDR_VAR 0 2
24788: PUSH
24789: DOUBLE
24790: LD_EXP 34
24794: INC
24795: ST_TO_ADDR
24796: LD_INT 1
24798: PUSH
24799: FOR_DOWNTO
24800: IFFALSE 24844
// if MREG_Crates [ i ] [ 3 ] = 0 then
24802: LD_EXP 34
24806: PUSH
24807: LD_VAR 0 2
24811: ARRAY
24812: PUSH
24813: LD_INT 3
24815: ARRAY
24816: PUSH
24817: LD_INT 0
24819: EQUAL
24820: IFFALSE 24842
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24822: LD_ADDR_EXP 34
24826: PUSH
24827: LD_EXP 34
24831: PPUSH
24832: LD_VAR 0 2
24836: PPUSH
24837: CALL_OW 3
24841: ST_TO_ADDR
24842: GO 24799
24844: POP
24845: POP
// end ;
24846: LD_VAR 0 1
24850: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24851: LD_INT 0
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
// if not unit then
24857: LD_VAR 0 1
24861: NOT
24862: IFFALSE 24866
// exit ;
24864: GO 25001
// if HasTask ( unit ) or not CanCarry ( unit ) then
24866: LD_VAR 0 1
24870: PPUSH
24871: CALL_OW 314
24875: PUSH
24876: LD_VAR 0 1
24880: PPUSH
24881: CALL_OW 280
24885: NOT
24886: OR
24887: IFFALSE 24891
// exit ;
24889: GO 25001
// side := GetSide ( unit ) ;
24891: LD_ADDR_VAR 0 6
24895: PUSH
24896: LD_VAR 0 1
24900: PPUSH
24901: CALL_OW 255
24905: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24906: LD_ADDR_VAR 0 7
24910: PUSH
24911: LD_VAR 0 6
24915: PPUSH
24916: LD_INT 30
24918: PUSH
24919: LD_INT 1
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PPUSH
24926: CALL 11651 0 2
24930: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24931: LD_VAR 0 1
24935: PPUSH
24936: CALL_OW 281
24940: PUSH
24941: LD_VAR 0 7
24945: NOT
24946: OR
24947: IFFALSE 24953
// exit else
24949: GO 25001
24951: GO 25001
// if GetResourceAmountXY ( x , y ) then
24953: LD_VAR 0 2
24957: PPUSH
24958: LD_VAR 0 3
24962: PPUSH
24963: CALL_OW 284
24967: IFFALSE 24999
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24969: LD_VAR 0 1
24973: PPUSH
24974: LD_VAR 0 2
24978: PPUSH
24979: LD_VAR 0 3
24983: PPUSH
24984: LD_VAR 0 7
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: CALL 32061 0 4
// end else
24997: GO 25001
// exit ;
24999: GO 25001
// end ;
25001: LD_VAR 0 4
25005: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25006: LD_INT 0
25008: PPUSH
25009: PPUSH
25010: PPUSH
25011: PPUSH
25012: PPUSH
// result := [ ] ;
25013: LD_ADDR_VAR 0 2
25017: PUSH
25018: EMPTY
25019: ST_TO_ADDR
// p := 1 ;
25020: LD_ADDR_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25028: LD_ADDR_VAR 0 3
25032: PUSH
25033: DOUBLE
25034: LD_INT 1
25036: DEC
25037: ST_TO_ADDR
25038: LD_EXP 63
25042: PUSH
25043: LD_VAR 0 1
25047: ARRAY
25048: PUSH
25049: LD_INT 1
25051: ARRAY
25052: PUSH
25053: LD_INT 2
25055: DIVREAL
25056: PUSH
25057: FOR_TO
25058: IFFALSE 25182
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25060: LD_ADDR_VAR 0 5
25064: PUSH
25065: LD_INT 81
25067: PUSH
25068: LD_VAR 0 1
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 92
25079: PUSH
25080: LD_EXP 63
25084: PUSH
25085: LD_VAR 0 1
25089: ARRAY
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PUSH
25095: LD_VAR 0 4
25099: ARRAY
25100: PUSH
25101: LD_EXP 63
25105: PUSH
25106: LD_VAR 0 1
25110: ARRAY
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: PUSH
25116: LD_VAR 0 4
25120: PUSH
25121: LD_INT 1
25123: PLUS
25124: ARRAY
25125: PUSH
25126: LD_INT 12
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: ST_TO_ADDR
// if tmp then
25144: LD_VAR 0 5
25148: IFFALSE 25166
// result := result union tmp ;
25150: LD_ADDR_VAR 0 2
25154: PUSH
25155: LD_VAR 0 2
25159: PUSH
25160: LD_VAR 0 5
25164: UNION
25165: ST_TO_ADDR
// p := p + 2 ;
25166: LD_ADDR_VAR 0 4
25170: PUSH
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 2
25178: PLUS
25179: ST_TO_ADDR
// end ;
25180: GO 25057
25182: POP
25183: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25184: LD_EXP 64
25188: PUSH
25189: LD_VAR 0 1
25193: ARRAY
25194: PPUSH
25195: LD_INT 81
25197: PUSH
25198: LD_VAR 0 1
25202: PUSH
25203: EMPTY
25204: LIST
25205: LIST
25206: PPUSH
25207: CALL_OW 70
25211: IFFALSE 25252
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25213: LD_ADDR_VAR 0 2
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_EXP 64
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_INT 81
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PPUSH
25246: CALL_OW 70
25250: UNION
25251: ST_TO_ADDR
// end ; end_of_file
25252: LD_VAR 0 2
25256: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25257: LD_INT 0
25259: PPUSH
25260: PPUSH
25261: PPUSH
// pom := GetBase ( fac ) ;
25262: LD_ADDR_VAR 0 5
25266: PUSH
25267: LD_VAR 0 1
25271: PPUSH
25272: CALL_OW 274
25276: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25277: LD_ADDR_VAR 0 4
25281: PUSH
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: LD_VAR 0 2
25295: PUSH
25296: LD_INT 2
25298: ARRAY
25299: PPUSH
25300: LD_VAR 0 2
25304: PUSH
25305: LD_INT 3
25307: ARRAY
25308: PPUSH
25309: LD_VAR 0 2
25313: PUSH
25314: LD_INT 4
25316: ARRAY
25317: PPUSH
25318: CALL_OW 449
25322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25323: LD_ADDR_VAR 0 3
25327: PUSH
25328: LD_VAR 0 5
25332: PPUSH
25333: LD_INT 1
25335: PPUSH
25336: CALL_OW 275
25340: PUSH
25341: LD_VAR 0 4
25345: PUSH
25346: LD_INT 1
25348: ARRAY
25349: GREATEREQUAL
25350: PUSH
25351: LD_VAR 0 5
25355: PPUSH
25356: LD_INT 2
25358: PPUSH
25359: CALL_OW 275
25363: PUSH
25364: LD_VAR 0 4
25368: PUSH
25369: LD_INT 2
25371: ARRAY
25372: GREATEREQUAL
25373: AND
25374: PUSH
25375: LD_VAR 0 5
25379: PPUSH
25380: LD_INT 3
25382: PPUSH
25383: CALL_OW 275
25387: PUSH
25388: LD_VAR 0 4
25392: PUSH
25393: LD_INT 3
25395: ARRAY
25396: GREATEREQUAL
25397: AND
25398: ST_TO_ADDR
// end ;
25399: LD_VAR 0 3
25403: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25404: LD_INT 0
25406: PPUSH
25407: PPUSH
25408: PPUSH
// result := false ;
25409: LD_ADDR_VAR 0 3
25413: PUSH
25414: LD_INT 0
25416: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25417: LD_ADDR_VAR 0 4
25421: PUSH
25422: LD_EXP 51
25426: PUSH
25427: LD_VAR 0 1
25431: ARRAY
25432: ST_TO_ADDR
// if tmp then
25433: LD_VAR 0 4
25437: IFFALSE 25491
// for i = 1 to tmp do
25439: LD_ADDR_VAR 0 5
25443: PUSH
25444: DOUBLE
25445: LD_INT 1
25447: DEC
25448: ST_TO_ADDR
25449: LD_VAR 0 4
25453: PUSH
25454: FOR_TO
25455: IFFALSE 25489
// if component = tmp [ i ] then
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 4
25466: PUSH
25467: LD_VAR 0 5
25471: ARRAY
25472: EQUAL
25473: IFFALSE 25487
// begin result := true ;
25475: LD_ADDR_VAR 0 3
25479: PUSH
25480: LD_INT 1
25482: ST_TO_ADDR
// exit ;
25483: POP
25484: POP
25485: GO 25491
// end ;
25487: GO 25454
25489: POP
25490: POP
// end ;
25491: LD_VAR 0 3
25495: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25496: LD_INT 0
25498: PPUSH
25499: PPUSH
25500: PPUSH
// result := false ;
25501: LD_ADDR_VAR 0 4
25505: PUSH
25506: LD_INT 0
25508: ST_TO_ADDR
// if fac then
25509: LD_VAR 0 2
25513: IFFALSE 25736
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25515: LD_VAR 0 2
25519: PPUSH
25520: LD_VAR 0 3
25524: PPUSH
25525: CALL 25257 0 2
25529: PUSH
25530: LD_VAR 0 2
25534: PPUSH
25535: CALL_OW 461
25539: PUSH
25540: LD_INT 2
25542: EQUAL
25543: AND
25544: PUSH
25545: LD_VAR 0 2
25549: PPUSH
25550: LD_VAR 0 3
25554: PUSH
25555: LD_INT 1
25557: ARRAY
25558: PPUSH
25559: LD_VAR 0 3
25563: PUSH
25564: LD_INT 2
25566: ARRAY
25567: PPUSH
25568: LD_VAR 0 3
25572: PUSH
25573: LD_INT 3
25575: ARRAY
25576: PPUSH
25577: LD_VAR 0 3
25581: PUSH
25582: LD_INT 4
25584: ARRAY
25585: PPUSH
25586: CALL_OW 448
25590: AND
25591: IFFALSE 25736
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25593: LD_VAR 0 2
25597: PPUSH
25598: LD_VAR 0 3
25602: PUSH
25603: LD_INT 1
25605: ARRAY
25606: PPUSH
25607: LD_VAR 0 3
25611: PUSH
25612: LD_INT 2
25614: ARRAY
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_INT 3
25623: ARRAY
25624: PPUSH
25625: LD_VAR 0 3
25629: PUSH
25630: LD_INT 4
25632: ARRAY
25633: PPUSH
25634: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25638: LD_ADDR_VAR 0 6
25642: PUSH
25643: LD_EXP 51
25647: PUSH
25648: LD_VAR 0 1
25652: ARRAY
25653: ST_TO_ADDR
// for i = 4 downto 1 do
25654: LD_ADDR_VAR 0 5
25658: PUSH
25659: DOUBLE
25660: LD_INT 4
25662: INC
25663: ST_TO_ADDR
25664: LD_INT 1
25666: PUSH
25667: FOR_DOWNTO
25668: IFFALSE 25701
// tab := Remove ( tab , list [ i ] , true ) ;
25670: LD_ADDR_VAR 0 6
25674: PUSH
25675: LD_VAR 0 6
25679: PPUSH
25680: LD_VAR 0 3
25684: PUSH
25685: LD_VAR 0 5
25689: ARRAY
25690: PPUSH
25691: LD_INT 1
25693: PPUSH
25694: CALL 31289 0 3
25698: ST_TO_ADDR
25699: GO 25667
25701: POP
25702: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25703: LD_ADDR_EXP 51
25707: PUSH
25708: LD_EXP 51
25712: PPUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: LD_VAR 0 6
25722: PPUSH
25723: CALL_OW 1
25727: ST_TO_ADDR
// result := true ;
25728: LD_ADDR_VAR 0 4
25732: PUSH
25733: LD_INT 1
25735: ST_TO_ADDR
// end ; end ; end ;
25736: LD_VAR 0 4
25740: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25741: LD_INT 0
25743: PPUSH
25744: PPUSH
// if not veh then
25745: LD_VAR 0 2
25749: NOT
25750: IFFALSE 25754
// exit ;
25752: GO 25928
// if MREG_Parking [ side ] then
25754: LD_EXP 58
25758: PUSH
25759: LD_VAR 0 1
25763: ARRAY
25764: IFFALSE 25928
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25766: LD_VAR 0 2
25770: PPUSH
25771: LD_EXP 58
25775: PUSH
25776: LD_VAR 0 1
25780: ARRAY
25781: PPUSH
25782: CALL_OW 308
25786: NOT
25787: IFFALSE 25928
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25789: LD_VAR 0 2
25793: PPUSH
25794: LD_EXP 58
25798: PUSH
25799: LD_VAR 0 1
25803: ARRAY
25804: PPUSH
25805: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25809: LD_VAR 0 2
25813: PPUSH
25814: CALL_OW 263
25818: PUSH
25819: LD_INT 1
25821: EQUAL
25822: IFFALSE 25928
// begin i := GetDriver ( veh ) ;
25824: LD_ADDR_VAR 0 4
25828: PUSH
25829: LD_VAR 0 2
25833: PPUSH
25834: CALL 31773 0 1
25838: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25839: LD_INT 35
25841: PPUSH
25842: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25846: LD_VAR 0 2
25850: PPUSH
25851: LD_EXP 58
25855: PUSH
25856: LD_VAR 0 1
25860: ARRAY
25861: PPUSH
25862: CALL_OW 308
25866: PUSH
25867: LD_VAR 0 2
25871: PPUSH
25872: CALL_OW 301
25876: OR
25877: IFFALSE 25839
// ComExitVehicle ( i ) ;
25879: LD_VAR 0 4
25883: PPUSH
25884: CALL_OW 121
// Wait ( 1 ) ;
25888: LD_INT 1
25890: PPUSH
25891: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PPUSH
25915: CALL 11651 0 2
25919: PUSH
25920: LD_INT 1
25922: ARRAY
25923: PPUSH
25924: CALL_OW 180
// end ; end ; end ;
25928: LD_VAR 0 3
25932: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25933: LD_INT 0
25935: PPUSH
25936: PPUSH
25937: PPUSH
25938: PPUSH
25939: PPUSH
25940: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25941: LD_VAR 0 1
25945: PPUSH
25946: LD_INT 30
25948: PUSH
25949: LD_INT 3
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PPUSH
25956: CALL 11651 0 2
25960: IFFALSE 26144
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25962: LD_VAR 0 1
25966: PPUSH
25967: LD_INT 30
25969: PUSH
25970: LD_INT 3
25972: PUSH
25973: EMPTY
25974: LIST
25975: LIST
25976: PPUSH
25977: CALL 11651 0 2
25981: PUSH
25982: LD_INT 1
25984: ARRAY
25985: PPUSH
25986: CALL_OW 461
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 26144
// begin for i = 1 to MREG_TurretWeapon do
25996: LD_ADDR_VAR 0 3
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_EXP 43
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26142
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26014: LD_EXP 43
26018: PUSH
26019: LD_VAR 0 3
26023: ARRAY
26024: PUSH
26025: LD_INT 1
26027: ARRAY
26028: PUSH
26029: LD_VAR 0 1
26033: EQUAL
26034: IFFALSE 26140
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26036: LD_ADDR_VAR 0 5
26040: PUSH
26041: LD_EXP 43
26045: PUSH
26046: LD_VAR 0 3
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26056: LD_ADDR_VAR 0 6
26060: PUSH
26061: LD_EXP 43
26065: PUSH
26066: LD_VAR 0 3
26070: ARRAY
26071: PUSH
26072: LD_INT 3
26074: ARRAY
26075: PUSH
26076: LD_INT 1
26078: ARRAY
26079: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26080: LD_ADDR_VAR 0 7
26084: PUSH
26085: LD_EXP 43
26089: PUSH
26090: LD_VAR 0 3
26094: ARRAY
26095: PUSH
26096: LD_INT 3
26098: ARRAY
26099: PUSH
26100: LD_INT 2
26102: ARRAY
26103: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26104: LD_ADDR_VAR 0 4
26108: PUSH
26109: LD_VAR 0 6
26113: PPUSH
26114: LD_VAR 0 7
26118: PPUSH
26119: CALL_OW 428
26123: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26124: LD_VAR 0 4
26128: PPUSH
26129: LD_VAR 0 5
26133: PPUSH
26134: CALL_OW 148
// break ;
26138: GO 26142
// end ;
26140: GO 26011
26142: POP
26143: POP
// end ; end ;
26144: LD_VAR 0 2
26148: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26149: LD_INT 0
26151: PPUSH
26152: PPUSH
26153: PPUSH
26154: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26155: LD_ADDR_VAR 0 4
26159: PUSH
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_INT 32
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PPUSH
26175: CALL 11651 0 2
26179: ST_TO_ADDR
// if not tmp then
26180: LD_VAR 0 4
26184: NOT
26185: IFFALSE 26191
// exit else
26187: GO 26273
26189: GO 26273
// begin for i = 1 to tmp do
26191: LD_ADDR_VAR 0 3
26195: PUSH
26196: DOUBLE
26197: LD_INT 1
26199: DEC
26200: ST_TO_ADDR
26201: LD_VAR 0 4
26205: PUSH
26206: FOR_TO
26207: IFFALSE 26271
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26209: LD_VAR 0 4
26213: PUSH
26214: LD_VAR 0 3
26218: ARRAY
26219: PPUSH
26220: CALL_OW 261
26224: PUSH
26225: LD_INT 20
26227: LESS
26228: PUSH
26229: LD_VAR 0 4
26233: PUSH
26234: LD_VAR 0 3
26238: ARRAY
26239: PPUSH
26240: CALL_OW 110
26244: PUSH
26245: LD_INT 0
26247: EQUAL
26248: AND
26249: IFFALSE 26269
// begin SetTag ( tmp [ i ] , 21 ) ;
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 3
26260: ARRAY
26261: PPUSH
26262: LD_INT 21
26264: PPUSH
26265: CALL_OW 109
// end ;
26269: GO 26206
26271: POP
26272: POP
// end ; end ;
26273: LD_VAR 0 2
26277: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26278: LD_INT 0
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
26284: PPUSH
// if not unit then
26285: LD_VAR 0 1
26289: NOT
26290: IFFALSE 26294
// exit ;
26292: GO 26482
// side := GetSide ( unit ) ;
26294: LD_ADDR_VAR 0 3
26298: PUSH
26299: LD_VAR 0 1
26303: PPUSH
26304: CALL_OW 255
26308: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26309: LD_ADDR_VAR 0 5
26313: PUSH
26314: LD_VAR 0 3
26318: PPUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 1
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 3
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 30
26344: PUSH
26345: LD_INT 29
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: PPUSH
26358: CALL 11651 0 2
26362: ST_TO_ADDR
// if not b then
26363: LD_VAR 0 5
26367: NOT
26368: IFFALSE 26372
// exit ;
26370: GO 26482
// if GetTag ( unit ) = 21 then
26372: LD_VAR 0 1
26376: PPUSH
26377: CALL_OW 110
26381: PUSH
26382: LD_INT 21
26384: EQUAL
26385: IFFALSE 26482
// begin c := NearestUnitToUnit ( b , unit ) ;
26387: LD_ADDR_VAR 0 6
26391: PUSH
26392: LD_VAR 0 5
26396: PPUSH
26397: LD_VAR 0 1
26401: PPUSH
26402: CALL_OW 74
26406: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26407: LD_VAR 0 1
26411: PPUSH
26412: LD_VAR 0 6
26416: PPUSH
26417: CALL_OW 250
26421: PPUSH
26422: LD_VAR 0 6
26426: PPUSH
26427: CALL_OW 251
26431: PPUSH
26432: CALL_OW 297
26436: PUSH
26437: LD_INT 6
26439: GREATER
26440: IFFALSE 26458
// ComMoveUnit ( unit , c ) else
26442: LD_VAR 0 1
26446: PPUSH
26447: LD_VAR 0 6
26451: PPUSH
26452: CALL_OW 112
26456: GO 26482
// begin SetFuel ( unit , 100 ) ;
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_INT 100
26465: PPUSH
26466: CALL_OW 240
// SetTag ( unit , 0 ) ;
26470: LD_VAR 0 1
26474: PPUSH
26475: LD_INT 0
26477: PPUSH
26478: CALL_OW 109
// end ; end ; end ;
26482: LD_VAR 0 2
26486: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26487: LD_INT 0
26489: PPUSH
26490: PPUSH
26491: PPUSH
26492: PPUSH
26493: PPUSH
26494: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26495: LD_ADDR_VAR 0 7
26499: PUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 33
26507: PUSH
26508: LD_INT 2
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 61
26520: PUSH
26521: EMPTY
26522: LIST
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PPUSH
26532: CALL 11651 0 2
26536: ST_TO_ADDR
// if not vehs then
26537: LD_VAR 0 7
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26831
// if nation = 1 then
26546: LD_VAR 0 2
26550: PUSH
26551: LD_INT 1
26553: EQUAL
26554: IFFALSE 26724
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26556: LD_VAR 0 1
26560: PPUSH
26561: LD_INT 30
26563: PUSH
26564: LD_INT 36
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PPUSH
26571: CALL 11651 0 2
26575: NOT
26576: IFFALSE 26582
// exit else
26578: GO 26831
26580: GO 26722
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26582: LD_ADDR_VAR 0 5
26586: PUSH
26587: LD_VAR 0 1
26591: PPUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 36
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PPUSH
26602: CALL 11651 0 2
26606: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26607: LD_ADDR_VAR 0 6
26611: PUSH
26612: LD_VAR 0 5
26616: PUSH
26617: LD_INT 1
26619: ARRAY
26620: PPUSH
26621: CALL_OW 313
26625: ST_TO_ADDR
// for i = vehs downto 1 do
26626: LD_ADDR_VAR 0 4
26630: PUSH
26631: DOUBLE
26632: LD_VAR 0 7
26636: INC
26637: ST_TO_ADDR
26638: LD_INT 1
26640: PUSH
26641: FOR_DOWNTO
26642: IFFALSE 26720
// begin if not IsControledBy ( vehs [ i ] ) then
26644: LD_VAR 0 7
26648: PUSH
26649: LD_VAR 0 4
26653: ARRAY
26654: PPUSH
26655: CALL_OW 312
26659: NOT
26660: IFFALSE 26718
// begin tmp := MCV_RemoteDriver ( oper ) ;
26662: LD_ADDR_VAR 0 8
26666: PUSH
26667: LD_VAR 0 6
26671: PPUSH
26672: CALL 26836 0 1
26676: ST_TO_ADDR
// if not tmp then
26677: LD_VAR 0 8
26681: NOT
26682: IFFALSE 26690
// exit else
26684: POP
26685: POP
26686: GO 26831
26688: GO 26718
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26690: LD_VAR 0 7
26694: PUSH
26695: LD_VAR 0 4
26699: ARRAY
26700: PPUSH
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: ARRAY
26709: PUSH
26710: LD_INT 1
26712: ARRAY
26713: PPUSH
26714: CALL_OW 135
// end ; end ;
26718: GO 26641
26720: POP
26721: POP
// end ; end else
26722: GO 26831
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26724: LD_VAR 0 1
26728: PPUSH
26729: LD_INT 34
26731: PUSH
26732: LD_INT 31
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PPUSH
26739: CALL 11651 0 2
26743: NOT
26744: IFFALSE 26750
// exit else
26746: GO 26831
26748: GO 26831
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 1
26759: PPUSH
26760: LD_INT 34
26762: PUSH
26763: LD_INT 31
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PPUSH
26770: CALL 11651 0 2
26774: ST_TO_ADDR
// oper := [ ] ;
26775: LD_ADDR_VAR 0 6
26779: PUSH
26780: EMPTY
26781: ST_TO_ADDR
// for i = 1 to ct do
26782: LD_ADDR_VAR 0 4
26786: PUSH
26787: DOUBLE
26788: LD_INT 1
26790: DEC
26791: ST_TO_ADDR
26792: LD_VAR 0 5
26796: PUSH
26797: FOR_TO
26798: IFFALSE 26829
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26800: LD_ADDR_VAR 0 6
26804: PUSH
26805: LD_VAR 0 6
26809: PUSH
26810: LD_VAR 0 5
26814: PUSH
26815: LD_VAR 0 4
26819: ARRAY
26820: PPUSH
26821: CALL 31773 0 1
26825: ADD
26826: ST_TO_ADDR
26827: GO 26797
26829: POP
26830: POP
// end ; end ; end ;
26831: LD_VAR 0 3
26835: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
26841: PPUSH
26842: PPUSH
26843: PPUSH
// if not drivers then
26844: LD_VAR 0 1
26848: NOT
26849: IFFALSE 26855
// exit else
26851: GO 27135
26853: GO 27135
// begin linked := [ ] ;
26855: LD_ADDR_VAR 0 5
26859: PUSH
26860: EMPTY
26861: ST_TO_ADDR
// for i = 1 to drivers do
26862: LD_ADDR_VAR 0 3
26866: PUSH
26867: DOUBLE
26868: LD_INT 1
26870: DEC
26871: ST_TO_ADDR
26872: LD_VAR 0 1
26876: PUSH
26877: FOR_TO
26878: IFFALSE 27123
// begin if CanControl ( drivers [ i ] ) then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_VAR 0 3
26889: ARRAY
26890: PPUSH
26891: CALL 32163 0 1
26895: IFFALSE 27121
// if i > 1 then
26897: LD_VAR 0 3
26901: PUSH
26902: LD_INT 1
26904: GREATER
26905: IFFALSE 27082
// begin m := false ;
26907: LD_ADDR_VAR 0 6
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26915: LD_ADDR_VAR 0 7
26919: PUSH
26920: LD_VAR 0 1
26924: PUSH
26925: LD_VAR 0 3
26929: ARRAY
26930: PPUSH
26931: CALL_OW 432
26935: ST_TO_ADDR
// for j = 1 to linked do
26936: LD_ADDR_VAR 0 4
26940: PUSH
26941: DOUBLE
26942: LD_INT 1
26944: DEC
26945: ST_TO_ADDR
26946: LD_VAR 0 5
26950: PUSH
26951: FOR_TO
26952: IFFALSE 27026
// begin if l < linked [ j ] [ 2 ] then
26954: LD_VAR 0 7
26958: PUSH
26959: LD_VAR 0 5
26963: PUSH
26964: LD_VAR 0 4
26968: ARRAY
26969: PUSH
26970: LD_INT 2
26972: ARRAY
26973: LESS
26974: IFFALSE 27024
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26976: LD_ADDR_VAR 0 5
26980: PUSH
26981: LD_VAR 0 5
26985: PPUSH
26986: LD_INT 1
26988: PPUSH
26989: LD_VAR 0 1
26993: PUSH
26994: LD_VAR 0 3
26998: ARRAY
26999: PUSH
27000: LD_VAR 0 7
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PPUSH
27009: CALL_OW 2
27013: ST_TO_ADDR
// m := true ;
27014: LD_ADDR_VAR 0 6
27018: PUSH
27019: LD_INT 1
27021: ST_TO_ADDR
// break ;
27022: GO 27026
// end ; end ;
27024: GO 26951
27026: POP
27027: POP
// if not m then
27028: LD_VAR 0 6
27032: NOT
27033: IFFALSE 27080
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27035: LD_ADDR_VAR 0 5
27039: PUSH
27040: LD_VAR 0 5
27044: PUSH
27045: LD_VAR 0 1
27049: PUSH
27050: LD_VAR 0 3
27054: ARRAY
27055: PUSH
27056: LD_VAR 0 1
27060: PUSH
27061: LD_VAR 0 3
27065: ARRAY
27066: PPUSH
27067: CALL_OW 432
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: EMPTY
27077: LIST
27078: ADD
27079: ST_TO_ADDR
// end else
27080: GO 27121
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27082: LD_ADDR_VAR 0 5
27086: PUSH
27087: LD_VAR 0 1
27091: PUSH
27092: LD_VAR 0 3
27096: ARRAY
27097: PUSH
27098: LD_VAR 0 1
27102: PUSH
27103: LD_VAR 0 3
27107: ARRAY
27108: PPUSH
27109: CALL_OW 432
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: ST_TO_ADDR
// end ;
27121: GO 26877
27123: POP
27124: POP
// result := linked ;
27125: LD_ADDR_VAR 0 2
27129: PUSH
27130: LD_VAR 0 5
27134: ST_TO_ADDR
// end ; end ;
27135: LD_VAR 0 2
27139: RET
// export function MCV_ToRepair ( unit ) ; begin
27140: LD_INT 0
27142: PPUSH
// if not unit then
27143: LD_VAR 0 1
27147: NOT
27148: IFFALSE 27152
// exit ;
27150: GO 27183
// SetTag ( unit , 6 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 6
27159: PPUSH
27160: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27164: LD_VAR 0 1
27168: PPUSH
27169: CALL_OW 255
27173: PPUSH
27174: LD_VAR 0 1
27178: PPUSH
27179: CALL 25741 0 2
// end ;
27183: LD_VAR 0 2
27187: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27192: LD_VAR 0 1
27196: PPUSH
27197: LD_INT 6
27199: PPUSH
27200: EMPTY
27201: PPUSH
27202: CALL 12354 0 3
27206: IFFALSE 27299
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: DOUBLE
27214: LD_VAR 0 1
27218: PPUSH
27219: LD_INT 6
27221: PPUSH
27222: EMPTY
27223: PPUSH
27224: CALL 12354 0 3
27228: INC
27229: ST_TO_ADDR
27230: LD_INT 1
27232: PUSH
27233: FOR_DOWNTO
27234: IFFALSE 27297
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27236: LD_VAR 0 1
27240: PPUSH
27241: LD_INT 6
27243: PPUSH
27244: EMPTY
27245: PPUSH
27246: CALL 12354 0 3
27250: PUSH
27251: LD_VAR 0 3
27255: ARRAY
27256: PPUSH
27257: CALL_OW 256
27261: PUSH
27262: LD_INT 1000
27264: EQUAL
27265: IFFALSE 27295
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27267: LD_VAR 0 1
27271: PPUSH
27272: LD_INT 6
27274: PPUSH
27275: EMPTY
27276: PPUSH
27277: CALL 12354 0 3
27281: PUSH
27282: LD_VAR 0 3
27286: ARRAY
27287: PPUSH
27288: LD_INT 0
27290: PPUSH
27291: CALL_OW 109
27295: GO 27233
27297: POP
27298: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27299: LD_VAR 0 1
27303: PPUSH
27304: LD_INT 10
27306: PPUSH
27307: EMPTY
27308: PPUSH
27309: CALL 12354 0 3
27313: IFFALSE 27430
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: DOUBLE
27321: LD_VAR 0 1
27325: PPUSH
27326: LD_INT 10
27328: PPUSH
27329: EMPTY
27330: PPUSH
27331: CALL 12354 0 3
27335: INC
27336: ST_TO_ADDR
27337: LD_INT 1
27339: PUSH
27340: FOR_DOWNTO
27341: IFFALSE 27428
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27343: LD_VAR 0 1
27347: PPUSH
27348: LD_INT 10
27350: PPUSH
27351: EMPTY
27352: PPUSH
27353: CALL 12354 0 3
27357: PUSH
27358: LD_VAR 0 3
27362: ARRAY
27363: PPUSH
27364: CALL_OW 302
27368: NOT
27369: PUSH
27370: LD_VAR 0 1
27374: PPUSH
27375: LD_INT 10
27377: PPUSH
27378: EMPTY
27379: PPUSH
27380: CALL 12354 0 3
27384: PUSH
27385: LD_VAR 0 3
27389: ARRAY
27390: PPUSH
27391: CALL_OW 301
27395: OR
27396: IFFALSE 27426
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27398: LD_VAR 0 1
27402: PPUSH
27403: LD_INT 10
27405: PPUSH
27406: EMPTY
27407: PPUSH
27408: CALL 12354 0 3
27412: PUSH
27413: LD_VAR 0 3
27417: ARRAY
27418: PPUSH
27419: LD_INT 0
27421: PPUSH
27422: CALL_OW 109
27426: GO 27340
27428: POP
27429: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27430: LD_ADDR_VAR 0 3
27434: PUSH
27435: LD_VAR 0 1
27439: PPUSH
27440: EMPTY
27441: PPUSH
27442: CALL 11952 0 2
27446: PUSH
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 7
27454: PPUSH
27455: EMPTY
27456: PPUSH
27457: CALL 12354 0 3
27461: DIFF
27462: PUSH
27463: FOR_IN
27464: IFFALSE 27508
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27466: LD_VAR 0 3
27470: PPUSH
27471: CALL_OW 256
27475: PUSH
27476: LD_INT 650
27478: LESS
27479: PUSH
27480: LD_VAR 0 3
27484: PPUSH
27485: CALL_OW 110
27489: PUSH
27490: LD_INT 6
27492: EQUAL
27493: NOT
27494: AND
27495: IFFALSE 27506
// MCV_ToRepair ( i ) ;
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL 27140 0 1
27506: GO 27463
27508: POP
27509: POP
// end ; end_of_file end_of_file
27510: LD_VAR 0 2
27514: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27515: LD_STRING SAILEvent [
27517: PUSH
27518: LD_VAR 0 1
27522: STR
27523: PUSH
27524: LD_STRING ]
27526: STR
27527: PPUSH
27528: CALL 8039 0 1
// if event = 101 and dialog_north then
27532: LD_VAR 0 1
27536: PUSH
27537: LD_INT 101
27539: EQUAL
27540: PUSH
27541: LD_EXP 6
27545: AND
27546: IFFALSE 27610
// begin dialog_north := false ;
27548: LD_ADDR_EXP 6
27552: PUSH
27553: LD_INT 0
27555: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27556: LD_EXP 5
27560: PPUSH
27561: LD_STRING DS1
27563: PUSH
27564: LD_STRING DS2
27566: PUSH
27567: LD_STRING DS3
27569: PUSH
27570: LD_STRING DS6
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 1
27581: PPUSH
27582: LD_INT 4
27584: PPUSH
27585: CALL_OW 12
27589: ARRAY
27590: PPUSH
27591: CALL_OW 94
// Wait ( 4 4$00 ) ;
27595: LD_INT 8400
27597: PPUSH
27598: CALL_OW 67
// dialog_north := true ;
27602: LD_ADDR_EXP 6
27606: PUSH
27607: LD_INT 1
27609: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27610: LD_VAR 0 1
27614: PUSH
27615: LD_INT 102
27617: EQUAL
27618: PUSH
27619: LD_EXP 7
27623: AND
27624: IFFALSE 27684
// begin dialog_south := false ;
27626: LD_ADDR_EXP 7
27630: PUSH
27631: LD_INT 0
27633: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27634: LD_EXP 4
27638: PPUSH
27639: LD_STRING DJ1
27641: PUSH
27642: LD_STRING DJ4
27644: PUSH
27645: LD_STRING DJ6
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PPUSH
27656: LD_INT 3
27658: PPUSH
27659: CALL_OW 12
27663: ARRAY
27664: PPUSH
27665: CALL_OW 94
// Wait ( 4 4$00 ) ;
27669: LD_INT 8400
27671: PPUSH
27672: CALL_OW 67
// dialog_south := true ;
27676: LD_ADDR_EXP 7
27680: PUSH
27681: LD_INT 1
27683: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27684: LD_VAR 0 1
27688: PUSH
27689: LD_INT 104
27691: EQUAL
27692: PUSH
27693: LD_EXP 8
27697: AND
27698: IFFALSE 27720
// begin dialog_popov := false ;
27700: LD_ADDR_EXP 8
27704: PUSH
27705: LD_INT 0
27707: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27708: LD_EXP 24
27712: PPUSH
27713: LD_STRING DR4
27715: PPUSH
27716: CALL_OW 94
// end ; end ;
27720: PPOPN 1
27722: END
// on BuildingStarted ( b , unit ) do var side , i ;
27723: LD_INT 0
27725: PPUSH
27726: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27727: LD_EXP 39
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ARRAY
27742: IFFALSE 27920
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27744: LD_STRING BuildingStarted [side: 
27746: PUSH
27747: LD_VAR 0 1
27751: PPUSH
27752: CALL_OW 255
27756: STR
27757: PUSH
27758: LD_STRING ; btype: 
27760: STR
27761: PUSH
27762: LD_VAR 0 1
27766: PPUSH
27767: CALL_OW 266
27771: STR
27772: PUSH
27773: LD_STRING ; unit: 
27775: STR
27776: PUSH
27777: LD_VAR 0 2
27781: STR
27782: PUSH
27783: LD_STRING ]
27785: STR
27786: PPUSH
27787: CALL 8039 0 1
// side := GetSide ( b ) ;
27791: LD_ADDR_VAR 0 3
27795: PUSH
27796: LD_VAR 0 1
27800: PPUSH
27801: CALL_OW 255
27805: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27806: LD_VAR 0 3
27810: PPUSH
27811: LD_INT 21
27813: PUSH
27814: LD_INT 3
27816: PUSH
27817: EMPTY
27818: LIST
27819: LIST
27820: PPUSH
27821: CALL 11651 0 2
27825: PUSH
27826: LD_INT 1
27828: EQUAL
27829: IFFALSE 27920
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27831: LD_ADDR_VAR 0 4
27835: PUSH
27836: LD_VAR 0 3
27840: PPUSH
27841: LD_INT 21
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PPUSH
27851: CALL 11651 0 2
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_INT 2
27863: PPUSH
27864: EMPTY
27865: PPUSH
27866: CALL 11734 0 3
27870: DIFF
27871: PUSH
27872: FOR_IN
27873: IFFALSE 27918
// if not HasTask ( i ) then
27875: LD_VAR 0 4
27879: PPUSH
27880: CALL_OW 314
27884: NOT
27885: IFFALSE 27916
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27887: LD_VAR 0 4
27891: PPUSH
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 250
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 251
27911: PPUSH
27912: CALL_OW 111
27916: GO 27872
27918: POP
27919: POP
// end ;
27920: PPOPN 4
27922: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27923: LD_EXP 39
27927: PUSH
27928: LD_VAR 0 1
27932: PPUSH
27933: CALL_OW 255
27937: ARRAY
27938: IFFALSE 28307
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27940: LD_STRING BuildingComplete [side: 
27942: PUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 255
27952: STR
27953: PUSH
27954: LD_STRING ; btype: 
27956: STR
27957: PUSH
27958: LD_VAR 0 1
27962: PPUSH
27963: CALL_OW 266
27967: STR
27968: PUSH
27969: LD_STRING ]
27971: STR
27972: PPUSH
27973: CALL 8039 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27977: LD_ADDR_EXP 46
27981: PUSH
27982: LD_EXP 46
27986: PPUSH
27987: LD_VAR 0 1
27991: PPUSH
27992: CALL_OW 255
27996: PPUSH
27997: LD_VAR 0 1
28001: PPUSH
28002: CALL_OW 266
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 250
28016: PUSH
28017: LD_VAR 0 1
28021: PPUSH
28022: CALL_OW 251
28026: PUSH
28027: LD_VAR 0 1
28031: PPUSH
28032: CALL_OW 254
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL 42051 0 4
28046: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28047: LD_VAR 0 1
28051: PPUSH
28052: CALL_OW 266
28056: PUSH
28057: LD_INT 6
28059: EQUAL
28060: IFFALSE 28094
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28062: LD_ADDR_EXP 40
28066: PUSH
28067: LD_EXP 40
28071: PPUSH
28072: LD_VAR 0 1
28076: PPUSH
28077: CALL_OW 255
28081: PPUSH
28082: LD_VAR 0 1
28086: PPUSH
28087: EMPTY
28088: PPUSH
28089: CALL 41960 0 4
28093: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28094: LD_VAR 0 1
28098: PPUSH
28099: CALL_OW 266
28103: PUSH
28104: LD_INT 0
28106: EQUAL
28107: IFFALSE 28217
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28109: LD_ADDR_EXP 48
28113: PUSH
28114: LD_EXP 48
28118: PPUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 255
28128: PPUSH
28129: LD_INT 0
28131: PPUSH
28132: EMPTY
28133: PPUSH
28134: CALL 41960 0 4
28138: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28139: LD_VAR 0 1
28143: PPUSH
28144: CALL_OW 274
28148: PPUSH
28149: LD_INT 1
28151: PPUSH
28152: LD_EXP 72
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: CALL_OW 274
28174: PPUSH
28175: LD_INT 2
28177: PPUSH
28178: LD_EXP 72
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28191: LD_VAR 0 1
28195: PPUSH
28196: CALL_OW 274
28200: PPUSH
28201: LD_INT 3
28203: PPUSH
28204: LD_EXP 72
28208: PUSH
28209: LD_INT 3
28211: ARRAY
28212: PPUSH
28213: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28217: LD_VAR 0 1
28221: PPUSH
28222: CALL_OW 266
28226: PUSH
28227: LD_INT 2
28229: EQUAL
28230: IFFALSE 28262
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28232: LD_ADDR_EXP 48
28236: PUSH
28237: LD_EXP 48
28241: PPUSH
28242: LD_VAR 0 1
28246: PPUSH
28247: CALL_OW 255
28251: PPUSH
28252: LD_INT 2
28254: PPUSH
28255: EMPTY
28256: PPUSH
28257: CALL 41960 0 4
28261: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 266
28271: PUSH
28272: LD_INT 4
28274: EQUAL
28275: IFFALSE 28307
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28277: LD_ADDR_EXP 48
28281: PUSH
28282: LD_EXP 48
28286: PPUSH
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 255
28296: PPUSH
28297: LD_INT 4
28299: PPUSH
28300: EMPTY
28301: PPUSH
28302: CALL 41960 0 4
28306: ST_TO_ADDR
// end ;
28307: PPOPN 1
28309: END
// on ResearchComplete ( tech , lab ) do var i ;
28310: LD_INT 0
28312: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28313: LD_EXP 39
28317: PUSH
28318: LD_VAR 0 2
28322: PPUSH
28323: CALL_OW 255
28327: ARRAY
28328: IFFALSE 28612
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28330: LD_STRING ResearchComplete [side: 
28332: PUSH
28333: LD_VAR 0 2
28337: PPUSH
28338: CALL_OW 255
28342: PPUSH
28343: CALL_OW 255
28347: STR
28348: PUSH
28349: LD_STRING ; tech:
28351: STR
28352: PUSH
28353: LD_VAR 0 1
28357: STR
28358: PUSH
28359: LD_STRING ]
28361: STR
28362: PPUSH
28363: CALL 8039 0 1
// for i = 1 to MREG_ToRes do
28367: LD_ADDR_VAR 0 3
28371: PUSH
28372: DOUBLE
28373: LD_INT 1
28375: DEC
28376: ST_TO_ADDR
28377: LD_EXP 50
28381: PUSH
28382: FOR_TO
28383: IFFALSE 28470
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28385: LD_EXP 50
28389: PUSH
28390: LD_VAR 0 3
28394: ARRAY
28395: PUSH
28396: LD_INT 1
28398: ARRAY
28399: PUSH
28400: LD_VAR 0 2
28404: PPUSH
28405: CALL_OW 255
28409: EQUAL
28410: PUSH
28411: LD_EXP 50
28415: PUSH
28416: LD_VAR 0 3
28420: ARRAY
28421: PUSH
28422: LD_INT 2
28424: ARRAY
28425: PUSH
28426: LD_VAR 0 1
28430: EQUAL
28431: AND
28432: IFFALSE 28468
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28434: LD_ADDR_EXP 50
28438: PUSH
28439: LD_EXP 50
28443: PPUSH
28444: LD_VAR 0 2
28448: PPUSH
28449: CALL_OW 255
28453: PPUSH
28454: LD_VAR 0 1
28458: PPUSH
28459: EMPTY
28460: PPUSH
28461: CALL 42051 0 4
28465: ST_TO_ADDR
// break ;
28466: GO 28470
// end ;
28468: GO 28382
28470: POP
28471: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28472: LD_VAR 0 1
28476: PUSH
28477: LD_INT 2
28479: PUSH
28480: LD_INT 11
28482: PUSH
28483: LD_INT 4
28485: PUSH
28486: LD_INT 3
28488: PUSH
28489: EMPTY
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: IN
28495: IFFALSE 28612
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28497: LD_ADDR_VAR 0 3
28501: PUSH
28502: LD_VAR 0 2
28506: PPUSH
28507: CALL_OW 255
28511: PPUSH
28512: LD_INT 16
28514: PPUSH
28515: LD_INT 25
28517: PUSH
28518: LD_INT 4
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PPUSH
28525: CALL 12354 0 3
28529: ST_TO_ADDR
// if i then
28530: LD_VAR 0 3
28534: IFFALSE 28552
// SetTag ( i [ 1 ] , 0 ) ;
28536: LD_VAR 0 3
28540: PUSH
28541: LD_INT 1
28543: ARRAY
28544: PPUSH
28545: LD_INT 0
28547: PPUSH
28548: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28552: LD_ADDR_VAR 0 3
28556: PUSH
28557: LD_VAR 0 2
28561: PPUSH
28562: CALL_OW 255
28566: PPUSH
28567: LD_INT 171
28569: PPUSH
28570: EMPTY
28571: PPUSH
28572: CALL 12354 0 3
28576: ST_TO_ADDR
// if i then
28577: LD_VAR 0 3
28581: IFFALSE 28612
// begin SetTag ( i [ 1 ] , 0 ) ;
28583: LD_VAR 0 3
28587: PUSH
28588: LD_INT 1
28590: ARRAY
28591: PPUSH
28592: LD_INT 0
28594: PPUSH
28595: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: CALL_OW 122
// end ; end ; end ;
28612: PPOPN 3
28614: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28615: LD_INT 0
28617: PPUSH
28618: PPUSH
28619: PPUSH
28620: PPUSH
28621: PPUSH
28622: PPUSH
28623: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28624: LD_VAR 0 1
28628: PPUSH
28629: LD_VAR 0 2
28633: PPUSH
28634: CALL 59203 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28638: LD_EXP 39
28642: PUSH
28643: LD_VAR 0 2
28647: PPUSH
28648: CALL_OW 255
28652: ARRAY
28653: IFFALSE 29380
// begin side := GetSide ( veh ) ;
28655: LD_ADDR_VAR 0 4
28659: PUSH
28660: LD_VAR 0 1
28664: PPUSH
28665: CALL_OW 255
28669: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28670: LD_ADDR_VAR 0 6
28674: PUSH
28675: LD_VAR 0 1
28679: PPUSH
28680: CALL_OW 265
28684: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28685: LD_ADDR_VAR 0 7
28689: PUSH
28690: LD_VAR 0 1
28694: PPUSH
28695: CALL_OW 262
28699: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28700: LD_ADDR_VAR 0 8
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 263
28714: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28715: LD_ADDR_VAR 0 9
28719: PUSH
28720: LD_VAR 0 1
28724: PPUSH
28725: CALL_OW 264
28729: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28730: LD_STRING VehicleConstructed [side: 
28732: PUSH
28733: LD_VAR 0 4
28737: STR
28738: PUSH
28739: LD_STRING ; id:
28741: STR
28742: PUSH
28743: LD_VAR 0 1
28747: STR
28748: PUSH
28749: LD_STRING ; components: [
28751: STR
28752: PUSH
28753: LD_VAR 0 6
28757: STR
28758: PUSH
28759: LD_STRING , 
28761: STR
28762: PUSH
28763: LD_VAR 0 7
28767: STR
28768: PUSH
28769: LD_STRING , 
28771: STR
28772: PUSH
28773: LD_VAR 0 8
28777: STR
28778: PUSH
28779: LD_STRING , 
28781: STR
28782: PUSH
28783: LD_VAR 0 9
28787: STR
28788: PUSH
28789: LD_STRING ]]
28791: STR
28792: PPUSH
28793: CALL 8039 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 264
28806: PUSH
28807: LD_INT 13
28809: PUSH
28810: LD_INT 12
28812: PUSH
28813: LD_INT 14
28815: PUSH
28816: LD_INT 51
28818: PUSH
28819: LD_INT 53
28821: PUSH
28822: LD_INT 52
28824: PUSH
28825: LD_INT 32
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: IN
28837: NOT
28838: IFFALSE 28880
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28840: LD_ADDR_EXP 59
28844: PUSH
28845: LD_EXP 59
28849: PPUSH
28850: LD_VAR 0 4
28854: PPUSH
28855: LD_EXP 59
28859: PUSH
28860: LD_VAR 0 4
28864: ARRAY
28865: PUSH
28866: LD_INT 1
28868: PLUS
28869: PPUSH
28870: LD_VAR 0 1
28874: PPUSH
28875: CALL 31130 0 4
28879: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28880: LD_VAR 0 1
28884: PPUSH
28885: CALL_OW 264
28889: PUSH
28890: LD_INT 31
28892: EQUAL
28893: IFFALSE 28912
// SetTag ( GetDriver ( veh ) , 9 ) ;
28895: LD_VAR 0 1
28899: PPUSH
28900: CALL 31773 0 1
28904: PPUSH
28905: LD_INT 9
28907: PPUSH
28908: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28912: LD_VAR 0 1
28916: PPUSH
28917: CALL_OW 264
28921: PUSH
28922: LD_INT 14
28924: PUSH
28925: LD_INT 53
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: IN
28932: IFFALSE 28969
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28934: LD_ADDR_EXP 42
28938: PUSH
28939: LD_EXP 42
28943: PPUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 255
28953: PPUSH
28954: LD_INT 2
28956: PPUSH
28957: LD_VAR 0 1
28961: PPUSH
28962: CALL 31130 0 4
28966: ST_TO_ADDR
// exit ;
28967: GO 29380
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28969: LD_VAR 0 1
28973: PPUSH
28974: CALL_OW 265
28978: PUSH
28979: LD_EXP 66
28983: PUSH
28984: LD_VAR 0 4
28988: ARRAY
28989: PUSH
28990: LD_INT 1
28992: ARRAY
28993: IN
28994: PUSH
28995: LD_VAR 0 1
28999: PPUSH
29000: CALL_OW 262
29004: PUSH
29005: LD_EXP 66
29009: PUSH
29010: LD_VAR 0 4
29014: ARRAY
29015: PUSH
29016: LD_INT 1
29018: ARRAY
29019: IN
29020: AND
29021: PUSH
29022: LD_VAR 0 1
29026: PPUSH
29027: CALL_OW 263
29031: PUSH
29032: LD_EXP 66
29036: PUSH
29037: LD_VAR 0 4
29041: ARRAY
29042: PUSH
29043: LD_INT 1
29045: ARRAY
29046: IN
29047: AND
29048: PUSH
29049: LD_VAR 0 1
29053: PPUSH
29054: CALL_OW 264
29058: PUSH
29059: LD_EXP 66
29063: PUSH
29064: LD_VAR 0 4
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: IN
29074: AND
29075: IFFALSE 29119
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29077: LD_ADDR_EXP 67
29081: PUSH
29082: LD_EXP 67
29086: PPUSH
29087: LD_VAR 0 4
29091: PPUSH
29092: LD_EXP 67
29096: PUSH
29097: LD_VAR 0 4
29101: ARRAY
29102: PUSH
29103: LD_INT 1
29105: PLUS
29106: PPUSH
29107: LD_VAR 0 1
29111: PPUSH
29112: CALL 31130 0 4
29116: ST_TO_ADDR
// exit ;
29117: GO 29380
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29119: LD_VAR 0 6
29123: PUSH
29124: LD_EXP 69
29128: PUSH
29129: LD_VAR 0 4
29133: ARRAY
29134: PUSH
29135: LD_INT 1
29137: ARRAY
29138: EQUAL
29139: PUSH
29140: LD_VAR 0 7
29144: PUSH
29145: LD_EXP 69
29149: PUSH
29150: LD_VAR 0 4
29154: ARRAY
29155: PUSH
29156: LD_INT 2
29158: ARRAY
29159: EQUAL
29160: AND
29161: PUSH
29162: LD_VAR 0 8
29166: PUSH
29167: LD_EXP 69
29171: PUSH
29172: LD_VAR 0 4
29176: ARRAY
29177: PUSH
29178: LD_INT 3
29180: ARRAY
29181: EQUAL
29182: AND
29183: PUSH
29184: LD_VAR 0 9
29188: PUSH
29189: LD_EXP 69
29193: PUSH
29194: LD_VAR 0 4
29198: ARRAY
29199: PUSH
29200: LD_INT 4
29202: ARRAY
29203: EQUAL
29204: AND
29205: IFFALSE 29361
// begin tmp := MREG_ToAttack [ side ] ;
29207: LD_ADDR_VAR 0 5
29211: PUSH
29212: LD_EXP 69
29216: PUSH
29217: LD_VAR 0 4
29221: ARRAY
29222: ST_TO_ADDR
// for i = 1 to 4 do
29223: LD_ADDR_VAR 0 3
29227: PUSH
29228: DOUBLE
29229: LD_INT 1
29231: DEC
29232: ST_TO_ADDR
29233: LD_INT 4
29235: PUSH
29236: FOR_TO
29237: IFFALSE 29259
// tmp := Delete ( tmp , 1 ) ;
29239: LD_ADDR_VAR 0 5
29243: PUSH
29244: LD_VAR 0 5
29248: PPUSH
29249: LD_INT 1
29251: PPUSH
29252: CALL_OW 3
29256: ST_TO_ADDR
29257: GO 29236
29259: POP
29260: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29261: LD_ADDR_EXP 69
29265: PUSH
29266: LD_EXP 69
29270: PPUSH
29271: LD_VAR 0 4
29275: PPUSH
29276: LD_VAR 0 5
29280: PPUSH
29281: CALL_OW 1
29285: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29286: LD_ADDR_EXP 71
29290: PUSH
29291: LD_EXP 71
29295: PPUSH
29296: LD_VAR 0 4
29300: PPUSH
29301: LD_EXP 71
29305: PUSH
29306: LD_VAR 0 4
29310: ARRAY
29311: PUSH
29312: LD_INT 1
29314: PLUS
29315: PPUSH
29316: LD_VAR 0 1
29320: PPUSH
29321: CALL 31130 0 4
29325: ST_TO_ADDR
// if tmp = 0 then
29326: LD_VAR 0 5
29330: PUSH
29331: LD_INT 0
29333: EQUAL
29334: IFFALSE 29359
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29336: LD_ADDR_EXP 69
29340: PUSH
29341: LD_EXP 69
29345: PPUSH
29346: LD_VAR 0 4
29350: PPUSH
29351: LD_INT 0
29353: PPUSH
29354: CALL_OW 1
29358: ST_TO_ADDR
// exit ;
29359: GO 29380
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29361: LD_VAR 0 1
29365: PPUSH
29366: CALL_OW 255
29370: PPUSH
29371: LD_VAR 0 1
29375: PPUSH
29376: CALL 25741 0 2
// end ; end ;
29380: PPOPN 9
29382: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29383: LD_EXP 39
29387: PUSH
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 255
29397: ARRAY
29398: IFFALSE 29630
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29400: LD_STRING ApemanTamed [side: 
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: CALL_OW 255
29412: STR
29413: PUSH
29414: LD_STRING ; sci: 
29416: STR
29417: PUSH
29418: LD_VAR 0 2
29422: STR
29423: PUSH
29424: LD_STRING ; ape: 
29426: STR
29427: PUSH
29428: LD_VAR 0 1
29432: STR
29433: PUSH
29434: LD_STRING ]
29436: STR
29437: PPUSH
29438: CALL 8039 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29442: LD_INT 11
29444: PPUSH
29445: LD_VAR 0 2
29449: PPUSH
29450: CALL_OW 255
29454: PPUSH
29455: CALL_OW 321
29459: PUSH
29460: LD_INT 2
29462: EQUAL
29463: NOT
29464: PUSH
29465: LD_INT 2
29467: PPUSH
29468: LD_VAR 0 2
29472: PPUSH
29473: CALL_OW 255
29477: PPUSH
29478: CALL_OW 321
29482: PUSH
29483: LD_INT 2
29485: EQUAL
29486: NOT
29487: OR
29488: PUSH
29489: LD_VAR 0 2
29493: PPUSH
29494: CALL_OW 255
29498: PPUSH
29499: LD_INT 171
29501: PPUSH
29502: EMPTY
29503: PPUSH
29504: CALL 12354 0 3
29508: PUSH
29509: LD_INT 0
29511: EQUAL
29512: AND
29513: IFFALSE 29527
// begin SetTag ( ape , 171 ) ;
29515: LD_VAR 0 1
29519: PPUSH
29520: LD_INT 171
29522: PPUSH
29523: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29527: LD_VAR 0 2
29531: PPUSH
29532: CALL_OW 255
29536: PPUSH
29537: LD_INT 30
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL 11651 0 2
29551: IFFALSE 29630
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29553: LD_VAR 0 1
29557: PPUSH
29558: LD_VAR 0 2
29562: PPUSH
29563: CALL_OW 255
29567: PPUSH
29568: LD_INT 30
29570: PUSH
29571: LD_INT 1
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PPUSH
29578: CALL 11651 0 2
29582: PUSH
29583: LD_INT 1
29585: ARRAY
29586: PPUSH
29587: CALL_OW 250
29591: PPUSH
29592: LD_VAR 0 2
29596: PPUSH
29597: CALL_OW 255
29601: PPUSH
29602: LD_INT 30
29604: PUSH
29605: LD_INT 1
29607: PUSH
29608: EMPTY
29609: LIST
29610: LIST
29611: PPUSH
29612: CALL 11651 0 2
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: CALL_OW 251
29625: PPUSH
29626: CALL_OW 111
// end ;
29630: PPOPN 2
29632: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29633: LD_EXP 39
29637: PUSH
29638: LD_VAR 0 1
29642: PPUSH
29643: CALL_OW 255
29647: ARRAY
29648: IFFALSE 29926
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29650: LD_VAR 0 2
29654: PUSH
29655: LD_VAR 0 2
29659: PPUSH
29660: CALL_OW 255
29664: PPUSH
29665: CALL 12064 0 1
29669: IN
29670: IFFALSE 29811
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29672: LD_VAR 0 1
29676: PPUSH
29677: CALL_OW 266
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: IN
29692: IFFALSE 29722
// begin Wait ( 0 0$0.3 ) ;
29694: LD_INT 10
29696: PPUSH
29697: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29701: LD_VAR 0 2
29705: PPUSH
29706: LD_INT 16
29708: PPUSH
29709: CALL_OW 336
// ComExitBuilding ( un ) ;
29713: LD_VAR 0 2
29717: PPUSH
29718: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 266
29731: PUSH
29732: LD_INT 4
29734: PUSH
29735: LD_INT 5
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: IN
29742: IFFALSE 29811
// begin Wait ( 0 0$0.3 ) ;
29744: LD_INT 10
29746: PPUSH
29747: CALL_OW 67
// if GetTag ( un ) = 0 then
29751: LD_VAR 0 2
29755: PPUSH
29756: CALL_OW 110
29760: PUSH
29761: LD_INT 0
29763: EQUAL
29764: IFFALSE 29780
// SetClass ( un , class_apeman_soldier ) else
29766: LD_VAR 0 2
29770: PPUSH
29771: LD_INT 15
29773: PPUSH
29774: CALL_OW 336
29778: GO 29811
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29780: LD_INT 3
29782: PPUSH
29783: LD_VAR 0 2
29787: PPUSH
29788: CALL_OW 255
29792: PPUSH
29793: CALL_OW 321
29797: IFFALSE 29811
// SetClass ( un , class_apeman_kamikaze ) ;
29799: LD_VAR 0 2
29803: PPUSH
29804: LD_INT 17
29806: PPUSH
29807: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29811: LD_VAR 0 1
29815: PPUSH
29816: CALL_OW 266
29820: PUSH
29821: LD_INT 32
29823: EQUAL
29824: IFFALSE 29926
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29826: LD_ADDR_EXP 68
29830: PUSH
29831: LD_EXP 68
29835: PPUSH
29836: LD_VAR 0 1
29840: PPUSH
29841: CALL_OW 255
29845: PPUSH
29846: LD_EXP 68
29850: PUSH
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL_OW 255
29860: ARRAY
29861: PUSH
29862: LD_INT 1
29864: PLUS
29865: PPUSH
29866: LD_VAR 0 1
29870: PPUSH
29871: CALL 31130 0 4
29875: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29876: LD_ADDR_EXP 68
29880: PUSH
29881: LD_EXP 68
29885: PPUSH
29886: LD_VAR 0 1
29890: PPUSH
29891: CALL_OW 255
29895: PPUSH
29896: LD_EXP 68
29900: PUSH
29901: LD_VAR 0 1
29905: PPUSH
29906: CALL_OW 255
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: PLUS
29915: PPUSH
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL 31130 0 4
29925: ST_TO_ADDR
// end ; end ;
29926: PPOPN 2
29928: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL 59083 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29938: LD_VAR 0 1
29942: PUSH
29943: LD_INT 22
29945: PUSH
29946: LD_INT 3
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 23
29955: PUSH
29956: LD_INT 3
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 21
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: LIST
29977: PPUSH
29978: CALL_OW 69
29982: IN
29983: IFFALSE 29999
// player_loss := player_loss + 1 ;
29985: LD_ADDR_EXP 10
29989: PUSH
29990: LD_EXP 10
29994: PUSH
29995: LD_INT 1
29997: PLUS
29998: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29999: LD_VAR 0 1
30003: PUSH
30004: LD_INT 22
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 21
30016: PUSH
30017: LD_INT 3
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: CALL_OW 69
30032: IN
30033: PUSH
30034: LD_EXP 14
30038: NOT
30039: AND
30040: IFFALSE 30103
// begin alfa_north_triggered := true ;
30042: LD_ADDR_EXP 14
30046: PUSH
30047: LD_INT 1
30049: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30050: LD_EXP 5
30054: PPUSH
30055: LD_STRING DS4
30057: PPUSH
30058: CALL_OW 94
// Wait ( 1 1$25 ) ;
30062: LD_INT 2975
30064: PPUSH
30065: CALL_OW 67
// if not isTest then
30069: LD_EXP 1
30073: NOT
30074: IFFALSE 30103
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30076: LD_INT 20
30078: PPUSH
30079: LD_INT 5
30081: PUSH
30082: LD_INT 6
30084: PUSH
30085: LD_INT 7
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PUSH
30093: LD_OWVAR 67
30097: ARRAY
30098: PPUSH
30099: CALL 7058 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30103: LD_VAR 0 1
30107: PUSH
30108: LD_INT 22
30110: PUSH
30111: LD_INT 4
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 21
30120: PUSH
30121: LD_INT 3
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PPUSH
30132: CALL_OW 69
30136: IN
30137: PUSH
30138: LD_EXP 15
30142: NOT
30143: AND
30144: IFFALSE 30207
// begin alfa_south_triggered := true ;
30146: LD_ADDR_EXP 15
30150: PUSH
30151: LD_INT 1
30153: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30154: LD_EXP 4
30158: PPUSH
30159: LD_STRING DJ3
30161: PPUSH
30162: CALL_OW 94
// Wait ( 0 0$45 ) ;
30166: LD_INT 1575
30168: PPUSH
30169: CALL_OW 67
// if not isTest then
30173: LD_EXP 1
30177: NOT
30178: IFFALSE 30207
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30180: LD_INT 20
30182: PPUSH
30183: LD_INT 5
30185: PUSH
30186: LD_INT 6
30188: PUSH
30189: LD_INT 7
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: LIST
30196: PUSH
30197: LD_OWVAR 67
30201: ARRAY
30202: PPUSH
30203: CALL 7058 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30207: LD_VAR 0 1
30211: PPUSH
30212: CALL_OW 266
30216: PUSH
30217: LD_INT 1
30219: EQUAL
30220: PUSH
30221: LD_VAR 0 1
30225: PPUSH
30226: CALL_OW 255
30230: PUSH
30231: LD_INT 1
30233: PUSH
30234: LD_INT 4
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: IN
30241: AND
30242: IFFALSE 30251
// RaiseSailEvent ( 104 ) ;
30244: LD_INT 104
30246: PPUSH
30247: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30251: LD_EXP 39
30255: PUSH
30256: LD_VAR 0 1
30260: PPUSH
30261: CALL_OW 255
30265: ARRAY
30266: IFFALSE 30653
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30268: LD_STRING UnitDestroyed [side 
30270: PUSH
30271: LD_VAR 0 1
30275: PPUSH
30276: CALL_OW 255
30280: STR
30281: PUSH
30282: LD_STRING ; id: 
30284: STR
30285: PUSH
30286: LD_VAR 0 1
30290: STR
30291: PUSH
30292: LD_STRING ; type: 
30294: STR
30295: PUSH
30296: LD_VAR 0 1
30300: PPUSH
30301: CALL_OW 247
30305: STR
30306: PUSH
30307: LD_STRING ]
30309: STR
30310: PPUSH
30311: CALL 8039 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30315: LD_VAR 0 1
30319: PUSH
30320: LD_VAR 0 1
30324: PPUSH
30325: CALL_OW 255
30329: PPUSH
30330: LD_INT 21
30332: PUSH
30333: LD_INT 1
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PPUSH
30340: CALL 11651 0 2
30344: IN
30345: IFFALSE 30501
// begin if MCF_HasClass ( un ) then
30347: LD_VAR 0 1
30351: PPUSH
30352: CALL 14357 0 1
30356: IFFALSE 30501
// case MCF_HasClass ( un ) of 1 :
30358: LD_VAR 0 1
30362: PPUSH
30363: CALL 14357 0 1
30367: PUSH
30368: LD_INT 1
30370: DOUBLE
30371: EQUAL
30372: IFTRUE 30376
30374: GO 30401
30376: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 255
30386: PPUSH
30387: LD_STRING ToArm
30389: PPUSH
30390: LD_VAR 0 1
30394: PPUSH
30395: CALL 14530 0 3
30399: GO 30501
30401: LD_INT 2
30403: DOUBLE
30404: EQUAL
30405: IFTRUE 30409
30407: GO 30434
30409: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30410: LD_VAR 0 1
30414: PPUSH
30415: CALL_OW 255
30419: PPUSH
30420: LD_STRING ToDep
30422: PPUSH
30423: LD_VAR 0 1
30427: PPUSH
30428: CALL 14530 0 3
30432: GO 30501
30434: LD_INT 3
30436: DOUBLE
30437: EQUAL
30438: IFTRUE 30442
30440: GO 30467
30442: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30443: LD_VAR 0 1
30447: PPUSH
30448: CALL_OW 255
30452: PPUSH
30453: LD_STRING ToFac
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: CALL 14530 0 3
30465: GO 30501
30467: LD_INT 4
30469: DOUBLE
30470: EQUAL
30471: IFTRUE 30475
30473: GO 30500
30475: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30476: LD_VAR 0 1
30480: PPUSH
30481: CALL_OW 255
30485: PPUSH
30486: LD_STRING ToLab
30488: PPUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL 14530 0 3
30498: GO 30501
30500: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30501: LD_VAR 0 1
30505: PUSH
30506: LD_EXP 67
30510: PUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 255
30520: ARRAY
30521: IN
30522: IFFALSE 30607
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30524: LD_ADDR_EXP 67
30528: PUSH
30529: LD_EXP 67
30533: PPUSH
30534: LD_VAR 0 1
30538: PPUSH
30539: LD_INT 0
30541: PPUSH
30542: CALL 31289 0 3
30546: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30547: LD_VAR 0 1
30551: PPUSH
30552: CALL_OW 255
30556: PPUSH
30557: LD_VAR 0 1
30561: PPUSH
30562: CALL_OW 265
30566: PUSH
30567: LD_VAR 0 1
30571: PPUSH
30572: CALL_OW 262
30576: PUSH
30577: LD_VAR 0 1
30581: PPUSH
30582: CALL_OW 263
30586: PUSH
30587: LD_VAR 0 1
30591: PPUSH
30592: CALL_OW 264
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: PPUSH
30603: CALL 21170 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30607: LD_VAR 0 1
30611: PUSH
30612: LD_EXP 71
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 255
30626: ARRAY
30627: IN
30628: IFFALSE 30653
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30630: LD_ADDR_EXP 71
30634: PUSH
30635: LD_EXP 71
30639: PPUSH
30640: LD_VAR 0 1
30644: PPUSH
30645: LD_INT 0
30647: PPUSH
30648: CALL 31289 0 3
30652: ST_TO_ADDR
// end ; end ;
30653: PPOPN 1
30655: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30656: LD_EXP 39
30660: PUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL_OW 255
30670: ARRAY
30671: IFFALSE 30843
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30673: LD_VAR 0 2
30677: PUSH
30678: LD_EXP 68
30682: PUSH
30683: LD_VAR 0 2
30687: PPUSH
30688: CALL_OW 255
30692: ARRAY
30693: IN
30694: PUSH
30695: LD_VAR 0 1
30699: PPUSH
30700: CALL_OW 266
30704: PUSH
30705: LD_INT 32
30707: PUSH
30708: LD_INT 31
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: IN
30715: AND
30716: IFFALSE 30816
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30718: LD_ADDR_EXP 68
30722: PUSH
30723: LD_EXP 68
30727: PPUSH
30728: LD_VAR 0 1
30732: PPUSH
30733: LD_INT 0
30735: PPUSH
30736: CALL 31289 0 3
30740: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30741: LD_ADDR_EXP 68
30745: PUSH
30746: LD_EXP 68
30750: PPUSH
30751: LD_VAR 0 2
30755: PPUSH
30756: LD_INT 0
30758: PPUSH
30759: CALL 31289 0 3
30763: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30764: LD_EXP 68
30768: PUSH
30769: LD_VAR 0 2
30773: PPUSH
30774: CALL_OW 255
30778: ARRAY
30779: PUSH
30780: LD_STRING 
30782: EQUAL
30783: IFFALSE 30816
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30785: LD_ADDR_EXP 68
30789: PUSH
30790: LD_EXP 68
30794: PPUSH
30795: LD_VAR 0 2
30799: PPUSH
30800: CALL_OW 255
30804: PPUSH
30805: LD_INT 1
30807: PPUSH
30808: LD_INT 0
30810: PPUSH
30811: CALL 31130 0 4
30815: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30816: LD_VAR 0 1
30820: PPUSH
30821: CALL_OW 266
30825: PUSH
30826: LD_INT 36
30828: IN
30829: IFFALSE 30843
// SetTag ( un , 0 ) ;
30831: LD_VAR 0 2
30835: PPUSH
30836: LD_INT 0
30838: PPUSH
30839: CALL_OW 109
// end ;
30843: PPOPN 2
30845: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30846: LD_EXP 39
30850: PUSH
30851: LD_VAR 0 1
30855: PPUSH
30856: CALL_OW 255
30860: ARRAY
30861: IFFALSE 30887
// begin if GetControl ( un ) = control_remote then
30863: LD_VAR 0 1
30867: PPUSH
30868: CALL_OW 263
30872: PUSH
30873: LD_INT 2
30875: EQUAL
30876: IFFALSE 30887
// ComUnlink ( un ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 136
// end ;
30887: PPOPN 1
30889: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30890: LD_EXP 39
30894: PUSH
30895: LD_VAR 0 1
30899: PPUSH
30900: CALL_OW 255
30904: ARRAY
30905: IFFALSE 30934
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30907: LD_VAR 0 2
30911: PPUSH
30912: CALL_OW 264
30916: PUSH
30917: LD_INT 31
30919: IN
30920: IFFALSE 30934
// SetTag ( driver , 0 ) ;
30922: LD_VAR 0 1
30926: PPUSH
30927: LD_INT 0
30929: PPUSH
30930: CALL_OW 109
// end ;
30934: PPOPN 4
30936: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30937: LD_INT 0
30939: PPUSH
30940: PPUSH
30941: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_VAR 0 1
30951: PPUSH
30952: CALL_OW 269
30956: ST_TO_ADDR
// x := GetX ( building ) ;
30957: LD_ADDR_VAR 0 4
30961: PUSH
30962: LD_VAR 0 1
30966: PPUSH
30967: CALL_OW 250
30971: ST_TO_ADDR
// y := GetY ( building ) ;
30972: LD_ADDR_VAR 0 5
30976: PUSH
30977: LD_VAR 0 1
30981: PPUSH
30982: CALL_OW 251
30986: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30987: LD_ADDR_EXP 43
30991: PUSH
30992: LD_EXP 43
30996: PPUSH
30997: LD_VAR 0 1
31001: PPUSH
31002: CALL_OW 255
31006: PPUSH
31007: LD_VAR 0 3
31011: PPUSH
31012: LD_VAR 0 4
31016: PUSH
31017: LD_VAR 0 5
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PPUSH
31026: CALL 42051 0 4
31030: ST_TO_ADDR
// end ;
31031: PPOPN 5
31033: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31034: LD_VAR 0 1
31038: PUSH
31039: LD_EXP 30
31043: IN
31044: NOT
31045: IFFALSE 31093
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31047: LD_ADDR_EXP 30
31051: PUSH
31052: LD_EXP 30
31056: PPUSH
31057: LD_EXP 30
31061: PUSH
31062: LD_INT 1
31064: PLUS
31065: PPUSH
31066: LD_VAR 0 1
31070: PPUSH
31071: CALL_OW 2
31075: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31076: LD_STRING DestinationUnrechable. [unit: 
31078: PUSH
31079: LD_VAR 0 1
31083: STR
31084: PUSH
31085: LD_STRING ]
31087: STR
31088: PPUSH
31089: CALL 8039 0 1
// end ; end ;
31093: PPOPN 1
31095: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: LD_VAR 0 2
31105: PPUSH
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL 59179 0 3
// end ;
31115: PPOPN 3
31117: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL 59187 0 1
// end ; end_of_file
31127: PPOPN 1
31129: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31130: LD_INT 0
31132: PPUSH
31133: PPUSH
31134: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31135: LD_ADDR_VAR 0 7
31139: PUSH
31140: LD_VAR 0 1
31144: PUSH
31145: LD_VAR 0 2
31149: ARRAY
31150: PPUSH
31151: LD_VAR 0 3
31155: PPUSH
31156: LD_VAR 0 4
31160: PPUSH
31161: CALL_OW 1
31165: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31166: LD_ADDR_VAR 0 1
31170: PUSH
31171: LD_VAR 0 1
31175: PPUSH
31176: LD_VAR 0 2
31180: PPUSH
31181: LD_VAR 0 7
31185: PPUSH
31186: CALL_OW 1
31190: ST_TO_ADDR
// result := tab ;
31191: LD_ADDR_VAR 0 5
31195: PUSH
31196: LD_VAR 0 1
31200: ST_TO_ADDR
// end ;
31201: LD_VAR 0 5
31205: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31206: LD_INT 0
31208: PPUSH
31209: PPUSH
31210: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31211: LD_ADDR_VAR 0 5
31215: PUSH
31216: LD_VAR 0 1
31220: PUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_INT 1
31228: ARRAY
31229: ARRAY
31230: PPUSH
31231: LD_VAR 0 2
31235: PUSH
31236: LD_INT 2
31238: ARRAY
31239: PPUSH
31240: CALL_OW 3
31244: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31245: LD_ADDR_VAR 0 1
31249: PUSH
31250: LD_VAR 0 1
31254: PPUSH
31255: LD_VAR 0 2
31259: PUSH
31260: LD_INT 1
31262: ARRAY
31263: PPUSH
31264: LD_VAR 0 5
31268: PPUSH
31269: CALL_OW 1
31273: ST_TO_ADDR
// result := tab ;
31274: LD_ADDR_VAR 0 3
31278: PUSH
31279: LD_VAR 0 1
31283: ST_TO_ADDR
// end ;
31284: LD_VAR 0 3
31288: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31289: LD_INT 0
31291: PPUSH
31292: PPUSH
31293: PPUSH
31294: PPUSH
// i := 1 ;
31295: LD_ADDR_VAR 0 5
31299: PUSH
31300: LD_INT 1
31302: ST_TO_ADDR
// while ( i <= tab ) do
31303: LD_VAR 0 5
31307: PUSH
31308: LD_VAR 0 1
31312: LESSEQUAL
31313: IFFALSE 31688
// begin if not tab [ i ] then
31315: LD_VAR 0 1
31319: PUSH
31320: LD_VAR 0 5
31324: ARRAY
31325: NOT
31326: IFFALSE 31330
// break ;
31328: GO 31688
// if value in tab then
31330: LD_VAR 0 2
31334: PUSH
31335: LD_VAR 0 1
31339: IN
31340: IFFALSE 31453
// begin if not mode then
31342: LD_VAR 0 3
31346: NOT
31347: IFFALSE 31367
// tab := tab diff value else
31349: LD_ADDR_VAR 0 1
31353: PUSH
31354: LD_VAR 0 1
31358: PUSH
31359: LD_VAR 0 2
31363: DIFF
31364: ST_TO_ADDR
31365: GO 31429
// for j = 1 to tab do
31367: LD_ADDR_VAR 0 6
31371: PUSH
31372: DOUBLE
31373: LD_INT 1
31375: DEC
31376: ST_TO_ADDR
31377: LD_VAR 0 1
31381: PUSH
31382: FOR_TO
31383: IFFALSE 31427
// if tab [ j ] = value then
31385: LD_VAR 0 1
31389: PUSH
31390: LD_VAR 0 6
31394: ARRAY
31395: PUSH
31396: LD_VAR 0 2
31400: EQUAL
31401: IFFALSE 31425
// begin tab := Delete ( tab , j ) ;
31403: LD_ADDR_VAR 0 1
31407: PUSH
31408: LD_VAR 0 1
31412: PPUSH
31413: LD_VAR 0 6
31417: PPUSH
31418: CALL_OW 3
31422: ST_TO_ADDR
// break ;
31423: GO 31427
// end ;
31425: GO 31382
31427: POP
31428: POP
// i := i - 1 ;
31429: LD_ADDR_VAR 0 5
31433: PUSH
31434: LD_VAR 0 5
31438: PUSH
31439: LD_INT 1
31441: MINUS
31442: ST_TO_ADDR
// if mode then
31443: LD_VAR 0 3
31447: IFFALSE 31451
// break ;
31449: GO 31688
// end else
31451: GO 31672
// if tab [ i ] and value in tab [ i ] then
31453: LD_VAR 0 1
31457: PUSH
31458: LD_VAR 0 5
31462: ARRAY
31463: PUSH
31464: LD_VAR 0 2
31468: PUSH
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: IN
31480: AND
31481: IFFALSE 31672
// begin if not mode then
31483: LD_VAR 0 3
31487: NOT
31488: IFFALSE 31514
// tmp := tab [ i ] diff value else
31490: LD_ADDR_VAR 0 7
31494: PUSH
31495: LD_VAR 0 1
31499: PUSH
31500: LD_VAR 0 5
31504: ARRAY
31505: PUSH
31506: LD_VAR 0 2
31510: DIFF
31511: ST_TO_ADDR
31512: GO 31594
// for j = 1 to tab [ i ] do
31514: LD_ADDR_VAR 0 6
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 1
31528: PUSH
31529: LD_VAR 0 5
31533: ARRAY
31534: PUSH
31535: FOR_TO
31536: IFFALSE 31592
// if value = tab [ i ] [ j ] then
31538: LD_VAR 0 2
31542: PUSH
31543: LD_VAR 0 1
31547: PUSH
31548: LD_VAR 0 5
31552: ARRAY
31553: PUSH
31554: LD_VAR 0 6
31558: ARRAY
31559: EQUAL
31560: IFFALSE 31590
// begin tmp := Delete ( tab [ i ] , j ) ;
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: LD_VAR 0 1
31571: PUSH
31572: LD_VAR 0 5
31576: ARRAY
31577: PPUSH
31578: LD_VAR 0 6
31582: PPUSH
31583: CALL_OW 3
31587: ST_TO_ADDR
// break ;
31588: GO 31592
// end ;
31590: GO 31535
31592: POP
31593: POP
// if tmp = [ ] then
31594: LD_VAR 0 7
31598: PUSH
31599: EMPTY
31600: EQUAL
31601: IFFALSE 31625
// begin tab := Delete ( tab , i ) ;
31603: LD_ADDR_VAR 0 1
31607: PUSH
31608: LD_VAR 0 1
31612: PPUSH
31613: LD_VAR 0 5
31617: PPUSH
31618: CALL_OW 3
31622: ST_TO_ADDR
// end else
31623: GO 31650
// tab := Replace ( tab , i , tmp ) ;
31625: LD_ADDR_VAR 0 1
31629: PUSH
31630: LD_VAR 0 1
31634: PPUSH
31635: LD_VAR 0 5
31639: PPUSH
31640: LD_VAR 0 7
31644: PPUSH
31645: CALL_OW 1
31649: ST_TO_ADDR
// i := i - 1 ;
31650: LD_ADDR_VAR 0 5
31654: PUSH
31655: LD_VAR 0 5
31659: PUSH
31660: LD_INT 1
31662: MINUS
31663: ST_TO_ADDR
// if mode then
31664: LD_VAR 0 3
31668: IFFALSE 31672
// break ;
31670: GO 31688
// end ; i := i + 1 ;
31672: LD_ADDR_VAR 0 5
31676: PUSH
31677: LD_VAR 0 5
31681: PUSH
31682: LD_INT 1
31684: PLUS
31685: ST_TO_ADDR
// end ;
31686: GO 31303
// result := tab ;
31688: LD_ADDR_VAR 0 4
31692: PUSH
31693: LD_VAR 0 1
31697: ST_TO_ADDR
// end ;
31698: LD_VAR 0 4
31702: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31703: LD_INT 0
31705: PPUSH
31706: PPUSH
// for i = 1 to values do
31707: LD_ADDR_VAR 0 4
31711: PUSH
31712: DOUBLE
31713: LD_INT 1
31715: DEC
31716: ST_TO_ADDR
31717: LD_VAR 0 2
31721: PUSH
31722: FOR_TO
31723: IFFALSE 31756
// tab := Remove ( tab , values [ i ] , false ) ;
31725: LD_ADDR_VAR 0 1
31729: PUSH
31730: LD_VAR 0 1
31734: PPUSH
31735: LD_VAR 0 2
31739: PUSH
31740: LD_VAR 0 4
31744: ARRAY
31745: PPUSH
31746: LD_INT 0
31748: PPUSH
31749: CALL 31289 0 3
31753: ST_TO_ADDR
31754: GO 31722
31756: POP
31757: POP
// result := tab ;
31758: LD_ADDR_VAR 0 3
31762: PUSH
31763: LD_VAR 0 1
31767: ST_TO_ADDR
// end ;
31768: LD_VAR 0 3
31772: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31773: LD_INT 0
31775: PPUSH
31776: PPUSH
31777: PPUSH
// if not GetControl ( veh ) = control_manual then
31778: LD_VAR 0 1
31782: PPUSH
31783: CALL_OW 263
31787: PUSH
31788: LD_INT 1
31790: EQUAL
31791: NOT
31792: IFFALSE 31804
// result := false else
31794: LD_ADDR_VAR 0 2
31798: PUSH
31799: LD_INT 0
31801: ST_TO_ADDR
31802: GO 31949
// if veh in FilterAllUnits ( [ f_empty ] ) then
31804: LD_VAR 0 1
31808: PUSH
31809: LD_INT 58
31811: PUSH
31812: EMPTY
31813: LIST
31814: PPUSH
31815: CALL_OW 69
31819: IN
31820: IFFALSE 31832
// result := false else
31822: LD_ADDR_VAR 0 2
31826: PUSH
31827: LD_INT 0
31829: ST_TO_ADDR
31830: GO 31949
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31832: LD_ADDR_VAR 0 4
31836: PUSH
31837: LD_INT 22
31839: PUSH
31840: LD_VAR 0 1
31844: PPUSH
31845: CALL_OW 255
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 55
31856: PUSH
31857: EMPTY
31858: LIST
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PPUSH
31864: CALL_OW 69
31868: ST_TO_ADDR
// if not filter then
31869: LD_VAR 0 4
31873: NOT
31874: IFFALSE 31886
// result := false else
31876: LD_ADDR_VAR 0 2
31880: PUSH
31881: LD_INT 0
31883: ST_TO_ADDR
31884: GO 31949
// for i = 1 to filter do
31886: LD_ADDR_VAR 0 3
31890: PUSH
31891: DOUBLE
31892: LD_INT 1
31894: DEC
31895: ST_TO_ADDR
31896: LD_VAR 0 4
31900: PUSH
31901: FOR_TO
31902: IFFALSE 31947
// if IsDriver ( filter [ i ] ) = veh then
31904: LD_VAR 0 4
31908: PUSH
31909: LD_VAR 0 3
31913: ARRAY
31914: PPUSH
31915: CALL 99272 0 1
31919: PUSH
31920: LD_VAR 0 1
31924: EQUAL
31925: IFFALSE 31945
// begin result := filter [ i ] ;
31927: LD_ADDR_VAR 0 2
31931: PUSH
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 3
31941: ARRAY
31942: ST_TO_ADDR
// break ;
31943: GO 31947
// end ;
31945: GO 31901
31947: POP
31948: POP
// end ; end ;
31949: LD_VAR 0 2
31953: RET
// export function Compare ( val1 , val2 ) ; begin
31954: LD_INT 0
31956: PPUSH
// if val1 = val2 then
31957: LD_VAR 0 1
31961: PUSH
31962: LD_VAR 0 2
31966: EQUAL
31967: IFFALSE 31979
// result := true else
31969: LD_ADDR_VAR 0 3
31973: PUSH
31974: LD_INT 1
31976: ST_TO_ADDR
31977: GO 31987
// result := false ;
31979: LD_ADDR_VAR 0 3
31983: PUSH
31984: LD_INT 0
31986: ST_TO_ADDR
// end ;
31987: LD_VAR 0 3
31991: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31992: LD_INT 0
31994: PPUSH
31995: PPUSH
// result := false ;
31996: LD_ADDR_VAR 0 3
32000: PUSH
32001: LD_INT 0
32003: ST_TO_ADDR
// for j = 1 to e2 do
32004: LD_ADDR_VAR 0 4
32008: PUSH
32009: DOUBLE
32010: LD_INT 1
32012: DEC
32013: ST_TO_ADDR
32014: LD_VAR 0 2
32018: PUSH
32019: FOR_TO
32020: IFFALSE 32054
// if Compare ( e1 , e2 [ j ] ) then
32022: LD_VAR 0 1
32026: PPUSH
32027: LD_VAR 0 2
32031: PUSH
32032: LD_VAR 0 4
32036: ARRAY
32037: PPUSH
32038: CALL 31954 0 2
32042: IFFALSE 32052
// result := true ;
32044: LD_ADDR_VAR 0 3
32048: PUSH
32049: LD_INT 1
32051: ST_TO_ADDR
32052: GO 32019
32054: POP
32055: POP
// end ;
32056: LD_VAR 0 3
32060: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32061: LD_INT 0
32063: PPUSH
32064: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32065: LD_VAR 0 1
32069: PPUSH
32070: LD_STRING C
32072: PUSH
32073: LD_VAR 0 2
32077: PUSH
32078: LD_VAR 0 3
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 0
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: LIST
32101: LIST
32102: LIST
32103: PUSH
32104: LD_STRING v
32106: PUSH
32107: LD_VAR 0 4
32111: PPUSH
32112: CALL_OW 250
32116: PUSH
32117: LD_VAR 0 4
32121: PPUSH
32122: CALL_OW 251
32126: PUSH
32127: LD_VAR 0 4
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 0
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PPUSH
32154: CALL_OW 446
// end ;
32158: LD_VAR 0 5
32162: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32163: LD_INT 0
32165: PPUSH
32166: PPUSH
32167: PPUSH
// linked := UnitsLinked ( unit ) ;
32168: LD_ADDR_VAR 0 4
32172: PUSH
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 432
32182: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32183: LD_ADDR_VAR 0 3
32187: PUSH
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_INT 3
32195: PPUSH
32196: CALL_OW 259
32200: ST_TO_ADDR
// if sk > linked then
32201: LD_VAR 0 3
32205: PUSH
32206: LD_VAR 0 4
32210: GREATER
32211: IFFALSE 32223
// result := true else
32213: LD_ADDR_VAR 0 2
32217: PUSH
32218: LD_INT 1
32220: ST_TO_ADDR
32221: GO 32231
// result := false ;
32223: LD_ADDR_VAR 0 2
32227: PUSH
32228: LD_INT 0
32230: ST_TO_ADDR
// end ;
32231: LD_VAR 0 2
32235: RET
// export function NotTask ( unit ) ; begin
32236: LD_INT 0
32238: PPUSH
// result := true ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32247: LD_VAR 0 1
32251: PPUSH
32252: CALL_OW 437
32256: PUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: CALL_OW 314
32266: OR
32267: IFFALSE 32277
// result := false ;
32269: LD_ADDR_VAR 0 2
32273: PUSH
32274: LD_INT 0
32276: ST_TO_ADDR
// end ;
32277: LD_VAR 0 2
32281: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32282: LD_INT 0
32284: PPUSH
32285: PPUSH
32286: PPUSH
32287: PPUSH
32288: PPUSH
// dist := 99999 ;
32289: LD_ADDR_VAR 0 7
32293: PUSH
32294: LD_INT 99999
32296: ST_TO_ADDR
// un := - 1 ;
32297: LD_ADDR_VAR 0 6
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: ST_TO_ADDR
// if units1 and units2 then
32306: LD_VAR 0 1
32310: PUSH
32311: LD_VAR 0 2
32315: AND
32316: IFFALSE 32404
// for i in units1 do
32318: LD_ADDR_VAR 0 4
32322: PUSH
32323: LD_VAR 0 1
32327: PUSH
32328: FOR_IN
32329: IFFALSE 32402
// for j in units2 do
32331: LD_ADDR_VAR 0 5
32335: PUSH
32336: LD_VAR 0 2
32340: PUSH
32341: FOR_IN
32342: IFFALSE 32398
// if GetDistUnits ( i , j ) < dist then
32344: LD_VAR 0 4
32348: PPUSH
32349: LD_VAR 0 5
32353: PPUSH
32354: CALL_OW 296
32358: PUSH
32359: LD_VAR 0 7
32363: LESS
32364: IFFALSE 32396
// begin un := i ;
32366: LD_ADDR_VAR 0 6
32370: PUSH
32371: LD_VAR 0 4
32375: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32376: LD_ADDR_VAR 0 7
32380: PUSH
32381: LD_VAR 0 4
32385: PPUSH
32386: LD_VAR 0 5
32390: PPUSH
32391: CALL_OW 296
32395: ST_TO_ADDR
// end ;
32396: GO 32341
32398: POP
32399: POP
32400: GO 32328
32402: POP
32403: POP
// result := [ un , dist ] ;
32404: LD_ADDR_VAR 0 3
32408: PUSH
32409: LD_VAR 0 6
32413: PUSH
32414: LD_VAR 0 7
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: ST_TO_ADDR
// end ;
32423: LD_VAR 0 3
32427: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32428: LD_INT 0
32430: PPUSH
32431: PPUSH
32432: PPUSH
32433: PPUSH
32434: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32435: LD_VAR 0 1
32439: NOT
32440: PUSH
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 256
32450: PUSH
32451: LD_INT 250
32453: LESS
32454: OR
32455: PUSH
32456: LD_VAR 0 1
32460: PPUSH
32461: CALL_OW 314
32465: PUSH
32466: LD_VAR 0 1
32470: PPUSH
32471: CALL_OW 261
32475: PUSH
32476: LD_INT 20
32478: GREATER
32479: AND
32480: OR
32481: IFFALSE 32485
// exit ;
32483: GO 32859
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32485: LD_VAR 0 1
32489: PPUSH
32490: CALL_OW 261
32494: PUSH
32495: LD_INT 20
32497: LESS
32498: PUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: CALL_OW 110
32508: PUSH
32509: LD_INT 21
32511: EQUAL
32512: NOT
32513: AND
32514: IFFALSE 32550
// begin ComStop ( bulldozer ) ;
32516: LD_VAR 0 1
32520: PPUSH
32521: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32525: LD_VAR 0 1
32529: PPUSH
32530: LD_INT 21
32532: PPUSH
32533: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32537: LD_VAR 0 1
32541: PPUSH
32542: CALL 26278 0 1
// exit ;
32546: GO 32859
// end else
32548: GO 32577
// if GetFuel ( bulldozer ) > 20 then
32550: LD_VAR 0 1
32554: PPUSH
32555: CALL_OW 261
32559: PUSH
32560: LD_INT 20
32562: GREATER
32563: IFFALSE 32577
// SetTag ( bulldozer , 0 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 0
32572: PPUSH
32573: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32577: LD_ADDR_VAR 0 5
32581: PUSH
32582: LD_VAR 0 2
32586: PPUSH
32587: CALL_OW 353
32591: ST_TO_ADDR
// tmp := [ ] ;
32592: LD_ADDR_VAR 0 6
32596: PUSH
32597: EMPTY
32598: ST_TO_ADDR
// for i = 1 to list do
32599: LD_ADDR_VAR 0 4
32603: PUSH
32604: DOUBLE
32605: LD_INT 1
32607: DEC
32608: ST_TO_ADDR
32609: LD_VAR 0 5
32613: PUSH
32614: FOR_TO
32615: IFFALSE 32713
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32617: LD_VAR 0 5
32621: PUSH
32622: LD_VAR 0 4
32626: ARRAY
32627: PUSH
32628: LD_INT 1
32630: ARRAY
32631: PPUSH
32632: LD_VAR 0 5
32636: PUSH
32637: LD_VAR 0 4
32641: ARRAY
32642: PUSH
32643: LD_INT 2
32645: ARRAY
32646: PPUSH
32647: CALL_OW 554
32651: IFFALSE 32711
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32653: LD_ADDR_VAR 0 6
32657: PUSH
32658: LD_VAR 0 6
32662: PPUSH
32663: LD_VAR 0 6
32667: PUSH
32668: LD_INT 1
32670: PLUS
32671: PPUSH
32672: LD_VAR 0 5
32676: PUSH
32677: LD_VAR 0 4
32681: ARRAY
32682: PUSH
32683: LD_INT 1
32685: ARRAY
32686: PUSH
32687: LD_VAR 0 5
32691: PUSH
32692: LD_VAR 0 4
32696: ARRAY
32697: PUSH
32698: LD_INT 2
32700: ARRAY
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PPUSH
32706: CALL_OW 1
32710: ST_TO_ADDR
// end ;
32711: GO 32614
32713: POP
32714: POP
// ComStop ( bulldozer ) ;
32715: LD_VAR 0 1
32719: PPUSH
32720: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32724: LD_ADDR_VAR 0 7
32728: PUSH
32729: LD_VAR 0 1
32733: PPUSH
32734: CALL_OW 250
32738: PUSH
32739: LD_VAR 0 1
32743: PPUSH
32744: CALL_OW 251
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: ST_TO_ADDR
// for i = tmp downto 1 do
32753: LD_ADDR_VAR 0 4
32757: PUSH
32758: DOUBLE
32759: LD_VAR 0 6
32763: INC
32764: ST_TO_ADDR
32765: LD_INT 1
32767: PUSH
32768: FOR_DOWNTO
32769: IFFALSE 32857
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32771: LD_ADDR_VAR 0 7
32775: PUSH
32776: LD_VAR 0 7
32780: PUSH
32781: LD_INT 1
32783: ARRAY
32784: PPUSH
32785: LD_VAR 0 7
32789: PUSH
32790: LD_INT 2
32792: ARRAY
32793: PPUSH
32794: LD_VAR 0 6
32798: PPUSH
32799: CALL 32960 0 3
32803: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32804: LD_VAR 0 1
32808: PPUSH
32809: LD_VAR 0 7
32813: PUSH
32814: LD_INT 1
32816: ARRAY
32817: PPUSH
32818: LD_VAR 0 7
32822: PUSH
32823: LD_INT 2
32825: ARRAY
32826: PPUSH
32827: CALL 32864 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32831: LD_ADDR_VAR 0 6
32835: PUSH
32836: LD_VAR 0 6
32840: PPUSH
32841: LD_VAR 0 7
32845: PUSH
32846: LD_INT 3
32848: ARRAY
32849: PPUSH
32850: CALL_OW 3
32854: ST_TO_ADDR
// end ;
32855: GO 32768
32857: POP
32858: POP
// end ;
32859: LD_VAR 0 3
32863: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32864: LD_INT 0
32866: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32867: LD_VAR 0 2
32871: PPUSH
32872: LD_VAR 0 3
32876: PPUSH
32877: CALL_OW 351
32881: PUSH
32882: LD_VAR 0 2
32886: PPUSH
32887: LD_VAR 0 3
32891: PPUSH
32892: CALL_OW 554
32896: AND
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 488
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 428
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: EQUAL
32933: AND
32934: IFFALSE 32955
// AddComMoveXY ( bulldozer , x , y ) ;
32936: LD_VAR 0 1
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_VAR 0 3
32950: PPUSH
32951: CALL_OW 171
// end ;
32955: LD_VAR 0 4
32959: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32960: LD_INT 0
32962: PPUSH
32963: PPUSH
32964: PPUSH
32965: PPUSH
32966: PPUSH
32967: PPUSH
32968: PPUSH
// dist := 99999 ;
32969: LD_ADDR_VAR 0 6
32973: PUSH
32974: LD_INT 99999
32976: ST_TO_ADDR
// for i = 1 to list do
32977: LD_ADDR_VAR 0 5
32981: PUSH
32982: DOUBLE
32983: LD_INT 1
32985: DEC
32986: ST_TO_ADDR
32987: LD_VAR 0 3
32991: PUSH
32992: FOR_TO
32993: IFFALSE 33131
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32995: LD_ADDR_VAR 0 7
32999: PUSH
33000: LD_VAR 0 1
33004: PPUSH
33005: LD_VAR 0 2
33009: PPUSH
33010: LD_VAR 0 3
33014: PUSH
33015: LD_VAR 0 5
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PPUSH
33025: LD_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: ARRAY
33035: PUSH
33036: LD_INT 2
33038: ARRAY
33039: PPUSH
33040: CALL_OW 298
33044: ST_TO_ADDR
// if d = 0 then
33045: LD_VAR 0 7
33049: PUSH
33050: LD_INT 0
33052: EQUAL
33053: IFFALSE 33057
// continue ;
33055: GO 32992
// if d < dist then
33057: LD_VAR 0 7
33061: PUSH
33062: LD_VAR 0 6
33066: LESS
33067: IFFALSE 33129
// begin _x := list [ i ] [ 1 ] ;
33069: LD_ADDR_VAR 0 8
33073: PUSH
33074: LD_VAR 0 3
33078: PUSH
33079: LD_VAR 0 5
33083: ARRAY
33084: PUSH
33085: LD_INT 1
33087: ARRAY
33088: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33089: LD_ADDR_VAR 0 9
33093: PUSH
33094: LD_VAR 0 3
33098: PUSH
33099: LD_VAR 0 5
33103: ARRAY
33104: PUSH
33105: LD_INT 2
33107: ARRAY
33108: ST_TO_ADDR
// _i := i ;
33109: LD_ADDR_VAR 0 10
33113: PUSH
33114: LD_VAR 0 5
33118: ST_TO_ADDR
// dist := d ;
33119: LD_ADDR_VAR 0 6
33123: PUSH
33124: LD_VAR 0 7
33128: ST_TO_ADDR
// end ; end ;
33129: GO 32992
33131: POP
33132: POP
// result := [ _x , _y , _i , dist ] ;
33133: LD_ADDR_VAR 0 4
33137: PUSH
33138: LD_VAR 0 8
33142: PUSH
33143: LD_VAR 0 9
33147: PUSH
33148: LD_VAR 0 10
33152: PUSH
33153: LD_VAR 0 6
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: ST_TO_ADDR
// end ;
33164: LD_VAR 0 4
33168: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33169: LD_INT 0
33171: PPUSH
33172: PPUSH
33173: PPUSH
33174: PPUSH
33175: PPUSH
// for i = 1 to list do
33176: LD_ADDR_VAR 0 5
33180: PUSH
33181: DOUBLE
33182: LD_INT 1
33184: DEC
33185: ST_TO_ADDR
33186: LD_VAR 0 1
33190: PUSH
33191: FOR_TO
33192: IFFALSE 33506
// begin for j = list downto 2 do
33194: LD_ADDR_VAR 0 6
33198: PUSH
33199: DOUBLE
33200: LD_VAR 0 1
33204: INC
33205: ST_TO_ADDR
33206: LD_INT 2
33208: PUSH
33209: FOR_DOWNTO
33210: IFFALSE 33502
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33212: LD_VAR 0 2
33216: PPUSH
33217: LD_VAR 0 3
33221: PPUSH
33222: LD_VAR 0 1
33226: PUSH
33227: LD_VAR 0 6
33231: ARRAY
33232: PUSH
33233: LD_INT 1
33235: ARRAY
33236: PPUSH
33237: LD_VAR 0 1
33241: PUSH
33242: LD_VAR 0 6
33246: ARRAY
33247: PUSH
33248: LD_INT 2
33250: ARRAY
33251: PPUSH
33252: CALL_OW 298
33256: PUSH
33257: LD_VAR 0 2
33261: PPUSH
33262: LD_VAR 0 3
33266: PPUSH
33267: LD_VAR 0 1
33271: PUSH
33272: LD_VAR 0 6
33276: PUSH
33277: LD_INT 1
33279: MINUS
33280: ARRAY
33281: PUSH
33282: LD_INT 1
33284: ARRAY
33285: PPUSH
33286: LD_VAR 0 1
33290: PUSH
33291: LD_VAR 0 6
33295: PUSH
33296: LD_INT 1
33298: MINUS
33299: ARRAY
33300: PUSH
33301: LD_INT 2
33303: ARRAY
33304: PPUSH
33305: CALL_OW 298
33309: LESS
33310: IFFALSE 33500
// begin _x := list [ j ] [ 1 ] ;
33312: LD_ADDR_VAR 0 7
33316: PUSH
33317: LD_VAR 0 1
33321: PUSH
33322: LD_VAR 0 6
33326: ARRAY
33327: PUSH
33328: LD_INT 1
33330: ARRAY
33331: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33332: LD_ADDR_VAR 0 8
33336: PUSH
33337: LD_VAR 0 1
33341: PUSH
33342: LD_VAR 0 6
33346: ARRAY
33347: PUSH
33348: LD_INT 2
33350: ARRAY
33351: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_VAR 0 1
33361: PPUSH
33362: LD_VAR 0 6
33366: PPUSH
33367: LD_INT 1
33369: PPUSH
33370: LD_VAR 0 1
33374: PUSH
33375: LD_VAR 0 6
33379: PUSH
33380: LD_INT 1
33382: MINUS
33383: ARRAY
33384: PUSH
33385: LD_INT 1
33387: ARRAY
33388: PPUSH
33389: CALL 31130 0 4
33393: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33394: LD_ADDR_VAR 0 1
33398: PUSH
33399: LD_VAR 0 1
33403: PPUSH
33404: LD_VAR 0 6
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 1
33416: PUSH
33417: LD_VAR 0 6
33421: PUSH
33422: LD_INT 1
33424: MINUS
33425: ARRAY
33426: PUSH
33427: LD_INT 2
33429: ARRAY
33430: PPUSH
33431: CALL 31130 0 4
33435: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33436: LD_ADDR_VAR 0 1
33440: PUSH
33441: LD_VAR 0 1
33445: PPUSH
33446: LD_VAR 0 6
33450: PUSH
33451: LD_INT 1
33453: MINUS
33454: PPUSH
33455: LD_INT 1
33457: PPUSH
33458: LD_VAR 0 7
33462: PPUSH
33463: CALL 31130 0 4
33467: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33468: LD_ADDR_VAR 0 1
33472: PUSH
33473: LD_VAR 0 1
33477: PPUSH
33478: LD_VAR 0 6
33482: PUSH
33483: LD_INT 1
33485: MINUS
33486: PPUSH
33487: LD_INT 2
33489: PPUSH
33490: LD_VAR 0 8
33494: PPUSH
33495: CALL 31130 0 4
33499: ST_TO_ADDR
// end ; end ;
33500: GO 33209
33502: POP
33503: POP
// end ;
33504: GO 33191
33506: POP
33507: POP
// result := list ;
33508: LD_ADDR_VAR 0 4
33512: PUSH
33513: LD_VAR 0 1
33517: ST_TO_ADDR
// end ;
33518: LD_VAR 0 4
33522: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33523: LD_INT 0
33525: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33526: LD_ADDR_VAR 0 5
33530: PUSH
33531: LD_VAR 0 1
33535: PPUSH
33536: LD_VAR 0 2
33540: PPUSH
33541: CALL_OW 546
33545: PUSH
33546: LD_INT 2
33548: ARRAY
33549: PUSH
33550: LD_VAR 0 3
33554: PPUSH
33555: LD_VAR 0 4
33559: PPUSH
33560: CALL_OW 546
33564: PUSH
33565: LD_INT 2
33567: ARRAY
33568: MINUS
33569: ST_TO_ADDR
// if result < 0 then
33570: LD_VAR 0 5
33574: PUSH
33575: LD_INT 0
33577: LESS
33578: IFFALSE 33595
// result := result * - 1 ;
33580: LD_ADDR_VAR 0 5
33584: PUSH
33585: LD_VAR 0 5
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: MUL
33594: ST_TO_ADDR
// end ;
33595: LD_VAR 0 5
33599: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
// area = ListEnvironmentArea ( area ) ;
33604: LD_ADDR_VAR 0 2
33608: PUSH
33609: LD_VAR 0 2
33613: PPUSH
33614: CALL_OW 353
33618: ST_TO_ADDR
// if bulldozer > 0 then
33619: LD_VAR 0 1
33623: PUSH
33624: LD_INT 0
33626: GREATER
33627: IFFALSE 33738
// for i = area downto 1 do
33629: LD_ADDR_VAR 0 4
33633: PUSH
33634: DOUBLE
33635: LD_VAR 0 2
33639: INC
33640: ST_TO_ADDR
33641: LD_INT 1
33643: PUSH
33644: FOR_DOWNTO
33645: IFFALSE 33736
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33647: LD_VAR 0 2
33651: PUSH
33652: LD_VAR 0 4
33656: ARRAY
33657: PUSH
33658: LD_INT 1
33660: ARRAY
33661: PPUSH
33662: LD_VAR 0 2
33666: PUSH
33667: LD_VAR 0 4
33671: ARRAY
33672: PUSH
33673: LD_INT 2
33675: ARRAY
33676: PPUSH
33677: CALL_OW 351
33681: IFFALSE 33734
// if not HasTask ( bulldozer ) then
33683: LD_VAR 0 1
33687: PPUSH
33688: CALL_OW 314
33692: NOT
33693: IFFALSE 33734
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33695: LD_VAR 0 1
33699: PPUSH
33700: LD_VAR 0 2
33704: PUSH
33705: LD_VAR 0 4
33709: ARRAY
33710: PUSH
33711: LD_INT 1
33713: ARRAY
33714: PPUSH
33715: LD_VAR 0 2
33719: PUSH
33720: LD_VAR 0 4
33724: ARRAY
33725: PUSH
33726: LD_INT 2
33728: ARRAY
33729: PPUSH
33730: CALL_OW 171
33734: GO 33644
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 3
33742: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33749: LD_ADDR_VAR 0 6
33753: PUSH
33754: LD_INT 22
33756: PUSH
33757: LD_VAR 0 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 21
33768: PUSH
33769: LD_VAR 0 2
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PPUSH
33782: CALL_OW 69
33786: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33787: LD_ADDR_VAR 0 7
33791: PUSH
33792: LD_VAR 0 3
33796: PPUSH
33797: LD_INT 22
33799: PUSH
33800: LD_VAR 0 1
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 21
33811: PUSH
33812: LD_VAR 0 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PPUSH
33825: CALL_OW 70
33829: ST_TO_ADDR
// if tmp and pom then
33830: LD_VAR 0 6
33834: PUSH
33835: LD_VAR 0 7
33839: AND
33840: IFFALSE 33860
// result := tmp diff pom else
33842: LD_ADDR_VAR 0 4
33846: PUSH
33847: LD_VAR 0 6
33851: PUSH
33852: LD_VAR 0 7
33856: DIFF
33857: ST_TO_ADDR
33858: GO 33868
// result := false ;
33860: LD_ADDR_VAR 0 4
33864: PUSH
33865: LD_INT 0
33867: ST_TO_ADDR
// end ;
33868: LD_VAR 0 4
33872: RET
// export function SavePosition ( unit ) ; begin
33873: LD_INT 0
33875: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33876: LD_VAR 0 1
33880: PPUSH
33881: LD_VAR 0 1
33885: PPUSH
33886: CALL_OW 250
33890: PPUSH
33891: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 1
33904: PPUSH
33905: CALL_OW 251
33909: PPUSH
33910: CALL_OW 232
// end ;
33914: LD_VAR 0 2
33918: RET
// export function GetPosition ( unit ) ; begin
33919: LD_INT 0
33921: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33922: LD_ADDR_VAR 0 2
33926: PUSH
33927: LD_VAR 0 1
33931: PPUSH
33932: CALL_OW 252
33936: PUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: CALL_OW 253
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: ST_TO_ADDR
// end ;
33951: LD_VAR 0 2
33955: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33956: LD_INT 0
33958: PPUSH
// if unit in unreachableList then
33959: LD_VAR 0 1
33963: PUSH
33964: LD_EXP 30
33968: IN
33969: IFFALSE 33987
// unreachableList := unreachableList diff unit ;
33971: LD_ADDR_EXP 30
33975: PUSH
33976: LD_EXP 30
33980: PUSH
33981: LD_VAR 0 1
33985: DIFF
33986: ST_TO_ADDR
// if ValidHex ( x , y ) then
33987: LD_VAR 0 2
33991: PPUSH
33992: LD_VAR 0 3
33996: PPUSH
33997: CALL_OW 488
34001: IFFALSE 34027
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34003: LD_VAR 0 1
34007: PPUSH
34008: LD_VAR 0 2
34012: PPUSH
34013: LD_VAR 0 3
34017: PPUSH
34018: CALL_OW 428
34022: PPUSH
34023: CALL_OW 115
// Wait ( 3 ) ;
34027: LD_INT 3
34029: PPUSH
34030: CALL_OW 67
// if unit in unreachableList then
34034: LD_VAR 0 1
34038: PUSH
34039: LD_EXP 30
34043: IN
34044: IFFALSE 34056
// result := false else
34046: LD_ADDR_VAR 0 4
34050: PUSH
34051: LD_INT 0
34053: ST_TO_ADDR
34054: GO 34064
// result := true ;
34056: LD_ADDR_VAR 0 4
34060: PUSH
34061: LD_INT 1
34063: ST_TO_ADDR
// end ; end_of_file
34064: LD_VAR 0 4
34068: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34069: LD_EXP 31
34073: IFFALSE 34135
34075: GO 34077
34077: DISABLE
34078: LD_INT 0
34080: PPUSH
// begin enable ;
34081: ENABLE
// for i = 1 to mc_crates_list do
34082: LD_ADDR_VAR 0 1
34086: PUSH
34087: DOUBLE
34088: LD_INT 1
34090: DEC
34091: ST_TO_ADDR
34092: LD_EXP 32
34096: PUSH
34097: FOR_TO
34098: IFFALSE 34129
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34100: LD_EXP 32
34104: PUSH
34105: LD_VAR 0 1
34109: ARRAY
34110: PPUSH
34111: LD_INT 5
34113: PPUSH
34114: LD_INT 50
34116: PPUSH
34117: LD_INT 700
34119: PPUSH
34120: LD_INT 20
34122: PPUSH
34123: CALL 24485 0 5
34127: GO 34097
34129: POP
34130: POP
// MC_Game ( ) ;
34131: CALL 34138 0 0
// end ;
34135: PPOPN 1
34137: END
// export function MC_Game ( ) ; var i , side , un ; begin
34138: LD_INT 0
34140: PPUSH
34141: PPUSH
34142: PPUSH
34143: PPUSH
// if not isTest then
34144: LD_EXP 1
34148: NOT
34149: IFFALSE 34169
// MC_Show ( [ #tick , tick ] ) else
34151: LD_STRING #tick
34153: PUSH
34154: LD_OWVAR 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PPUSH
34163: CALL 8569 0 1
34167: GO 34178
// MC_Show ( debug_string ) ;
34169: LD_EXP 2
34173: PPUSH
34174: CALL 8569 0 1
// for side = 1 to 8 do
34178: LD_ADDR_VAR 0 3
34182: PUSH
34183: DOUBLE
34184: LD_INT 1
34186: DEC
34187: ST_TO_ADDR
34188: LD_INT 8
34190: PUSH
34191: FOR_TO
34192: IFFALSE 36192
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34194: LD_EXP 39
34198: PUSH
34199: LD_VAR 0 3
34203: ARRAY
34204: PUSH
34205: LD_INT 0
34207: EQUAL
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: EMPTY
34215: PPUSH
34216: CALL 11786 0 2
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: OR
34225: IFFALSE 34229
// continue ;
34227: GO 34191
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34229: LD_VAR 0 3
34233: PPUSH
34234: LD_VAR 0 3
34238: PPUSH
34239: CALL 25006 0 1
34243: PPUSH
34244: CALL 36199 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34248: LD_EXP 71
34252: PUSH
34253: LD_VAR 0 3
34257: ARRAY
34258: PUSH
34259: LD_INT 1
34261: ARRAY
34262: PUSH
34263: LD_INT 0
34265: GREATER
34266: PUSH
34267: LD_EXP 69
34271: PUSH
34272: LD_VAR 0 3
34276: ARRAY
34277: PUSH
34278: LD_INT 1
34280: ARRAY
34281: PUSH
34282: LD_INT 0
34284: EQUAL
34285: AND
34286: PUSH
34287: LD_VAR 0 3
34291: PPUSH
34292: LD_INT 7
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL 12354 0 3
34301: NOT
34302: AND
34303: IFFALSE 34340
// begin for i in MREG_Attackers [ side ] do
34305: LD_ADDR_VAR 0 2
34309: PUSH
34310: LD_EXP 71
34314: PUSH
34315: LD_VAR 0 3
34319: ARRAY
34320: PUSH
34321: FOR_IN
34322: IFFALSE 34338
// SetTag ( i , 7 ) ;
34324: LD_VAR 0 2
34328: PPUSH
34329: LD_INT 7
34331: PPUSH
34332: CALL_OW 109
34336: GO 34321
34338: POP
34339: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34340: LD_VAR 0 3
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: EMPTY
34349: PPUSH
34350: CALL 12354 0 3
34354: IFFALSE 34414
// begin if side = 1 then
34356: LD_VAR 0 3
34360: PUSH
34361: LD_INT 1
34363: EQUAL
34364: IFFALSE 34373
// RaiseSailEvent ( 101 ) ;
34366: LD_INT 101
34368: PPUSH
34369: CALL_OW 427
// if side = 4 then
34373: LD_VAR 0 3
34377: PUSH
34378: LD_INT 4
34380: EQUAL
34381: IFFALSE 34390
// RaiseSailEvent ( 102 ) ;
34383: LD_INT 102
34385: PPUSH
34386: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34390: LD_VAR 0 3
34394: PPUSH
34395: LD_VAR 0 3
34399: PPUSH
34400: LD_INT 7
34402: PPUSH
34403: EMPTY
34404: PPUSH
34405: CALL 12354 0 3
34409: PPUSH
34410: CALL 8487 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34414: LD_VAR 0 3
34418: PPUSH
34419: CALL 18034 0 1
34423: PUSH
34424: LD_VAR 0 3
34428: PPUSH
34429: CALL 11690 0 1
34433: AND
34434: IFFALSE 34445
// MCL_Start ( side ) ;
34436: LD_VAR 0 3
34440: PPUSH
34441: CALL 17991 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34445: LD_ADDR_EXP 35
34449: PUSH
34450: LD_EXP 35
34454: PPUSH
34455: LD_VAR 0 3
34459: PPUSH
34460: LD_VAR 0 3
34464: PPUSH
34465: CALL 19291 0 1
34469: PPUSH
34470: CALL_OW 1
34474: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34475: LD_ADDR_EXP 47
34479: PUSH
34480: LD_EXP 47
34484: PPUSH
34485: LD_VAR 0 3
34489: PPUSH
34490: LD_VAR 0 3
34494: PPUSH
34495: CALL 11104 0 1
34499: PPUSH
34500: CALL_OW 1
34504: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34505: LD_VAR 0 3
34509: PPUSH
34510: LD_INT 21
34512: PUSH
34513: LD_INT 2
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PPUSH
34520: CALL 11651 0 2
34524: IFFALSE 34535
// MCV_CheckStatus ( side ) ;
34526: LD_VAR 0 3
34530: PPUSH
34531: CALL 27188 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34535: LD_VAR 0 3
34539: PPUSH
34540: LD_EXP 53
34544: PPUSH
34545: CALL 42999 0 2
34549: IFFALSE 34634
// begin for i = MREG_ToChangeClass downto 1 do
34551: LD_ADDR_VAR 0 2
34555: PUSH
34556: DOUBLE
34557: LD_EXP 53
34561: INC
34562: ST_TO_ADDR
34563: LD_INT 1
34565: PUSH
34566: FOR_DOWNTO
34567: IFFALSE 34632
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34569: LD_EXP 53
34573: PUSH
34574: LD_VAR 0 2
34578: ARRAY
34579: PUSH
34580: LD_INT 1
34582: ARRAY
34583: PUSH
34584: LD_VAR 0 3
34588: EQUAL
34589: IFFALSE 34630
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34591: LD_VAR 0 3
34595: PPUSH
34596: LD_EXP 53
34600: PUSH
34601: LD_VAR 0 2
34605: ARRAY
34606: PUSH
34607: LD_INT 2
34609: ARRAY
34610: PPUSH
34611: LD_EXP 53
34615: PUSH
34616: LD_VAR 0 2
34620: ARRAY
34621: PUSH
34622: LD_INT 3
34624: ARRAY
34625: PPUSH
34626: CALL 16558 0 3
// end ; end ;
34630: GO 34566
34632: POP
34633: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34634: LD_INT 1
34636: PUSH
34637: LD_EXP 38
34641: PUSH
34642: LD_VAR 0 3
34646: ARRAY
34647: IN
34648: IFFALSE 34659
// begin MCN_TrainApe ( side ) ;
34650: LD_VAR 0 3
34654: PPUSH
34655: CALL 18944 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34659: LD_VAR 0 3
34663: PPUSH
34664: LD_INT 30
34666: PUSH
34667: LD_INT 3
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PPUSH
34674: CALL 11651 0 2
34678: IFFALSE 34852
// begin if MCF_Tag ( side , 10 , [ ] ) then
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 10
34687: PPUSH
34688: EMPTY
34689: PPUSH
34690: CALL 12354 0 3
34694: IFFALSE 34741
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12354 0 3
34710: PPUSH
34711: LD_VAR 0 3
34715: PPUSH
34716: LD_INT 30
34718: PUSH
34719: LD_INT 3
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PPUSH
34726: CALL 11651 0 2
34730: PUSH
34731: LD_INT 1
34733: ARRAY
34734: PPUSH
34735: CALL_OW 168
// end else
34739: GO 34852
// if MREG_ToConstruct [ side ] then
34741: LD_EXP 51
34745: PUSH
34746: LD_VAR 0 3
34750: ARRAY
34751: IFFALSE 34852
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34753: LD_VAR 0 3
34757: PPUSH
34758: LD_VAR 0 3
34762: PPUSH
34763: LD_INT 30
34765: PUSH
34766: LD_INT 3
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PPUSH
34773: CALL 11651 0 2
34777: PUSH
34778: LD_INT 1
34780: ARRAY
34781: PPUSH
34782: LD_EXP 51
34786: PUSH
34787: LD_VAR 0 3
34791: ARRAY
34792: PUSH
34793: LD_INT 1
34795: ARRAY
34796: PUSH
34797: LD_EXP 51
34801: PUSH
34802: LD_VAR 0 3
34806: ARRAY
34807: PUSH
34808: LD_INT 2
34810: ARRAY
34811: PUSH
34812: LD_EXP 51
34816: PUSH
34817: LD_VAR 0 3
34821: ARRAY
34822: PUSH
34823: LD_INT 3
34825: ARRAY
34826: PUSH
34827: LD_EXP 51
34831: PUSH
34832: LD_VAR 0 3
34836: ARRAY
34837: PUSH
34838: LD_INT 4
34840: ARRAY
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: PPUSH
34848: CALL 25496 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34852: LD_VAR 0 3
34856: PPUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL 11651 0 2
34871: PUSH
34872: LD_VAR 0 3
34876: PPUSH
34877: LD_EXP 43
34881: PPUSH
34882: CALL 42999 0 2
34886: AND
34887: PUSH
34888: LD_INT 22
34890: PUSH
34891: LD_VAR 0 3
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 33
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 32
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 35
34930: PUSH
34931: LD_INT 0
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: LIST
34942: PPUSH
34943: CALL_OW 69
34947: AND
34948: IFFALSE 34959
// MCV_Turret ( side ) ;
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL 25933 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34959: LD_EXP 42
34963: PUSH
34964: LD_VAR 0 3
34968: ARRAY
34969: PUSH
34970: LD_INT 1
34972: GREATER
34973: PUSH
34974: LD_VAR 0 3
34978: PPUSH
34979: CALL 25006 0 1
34983: PUSH
34984: LD_INT 0
34986: EQUAL
34987: AND
34988: IFFALSE 35150
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34990: LD_EXP 42
34994: PUSH
34995: LD_VAR 0 3
34999: ARRAY
35000: PUSH
35001: LD_INT 1
35003: ARRAY
35004: PPUSH
35005: CALL_OW 353
35009: IFFALSE 35047
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35011: LD_EXP 42
35015: PUSH
35016: LD_VAR 0 3
35020: ARRAY
35021: PUSH
35022: LD_INT 2
35024: ARRAY
35025: PPUSH
35026: LD_EXP 42
35030: PUSH
35031: LD_VAR 0 3
35035: ARRAY
35036: PUSH
35037: LD_INT 1
35039: ARRAY
35040: PPUSH
35041: CALL 32428 0 2
35045: GO 35150
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_INT 30
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PPUSH
35062: CALL 11651 0 2
35066: IFFALSE 35150
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35068: LD_VAR 0 3
35072: PPUSH
35073: LD_INT 30
35075: PUSH
35076: LD_INT 3
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PPUSH
35083: CALL 11651 0 2
35087: PUSH
35088: LD_INT 1
35090: ARRAY
35091: PPUSH
35092: CALL_OW 461
35096: PUSH
35097: LD_INT 2
35099: EQUAL
35100: IFFALSE 35150
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35102: LD_EXP 42
35106: PUSH
35107: LD_VAR 0 3
35111: ARRAY
35112: PUSH
35113: LD_INT 2
35115: ARRAY
35116: PPUSH
35117: LD_INT 10
35119: PPUSH
35120: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35124: LD_ADDR_EXP 42
35128: PUSH
35129: LD_EXP 42
35133: PPUSH
35134: LD_VAR 0 3
35138: PPUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: PPUSH
35145: CALL_OW 1
35149: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 33
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PPUSH
35165: CALL 11651 0 2
35169: IFFALSE 35209
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35171: LD_VAR 0 3
35175: PPUSH
35176: LD_VAR 0 3
35180: PPUSH
35181: LD_INT 33
35183: PUSH
35184: LD_INT 2
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PPUSH
35191: CALL 11651 0 2
35195: PUSH
35196: LD_INT 1
35198: ARRAY
35199: PPUSH
35200: CALL_OW 248
35204: PPUSH
35205: CALL 26487 0 2
// if MREG_ToRepair [ side ] then
35209: LD_EXP 47
35213: PUSH
35214: LD_VAR 0 3
35218: ARRAY
35219: IFFALSE 35232
// begin MCB_Repair ( side ) ;
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL 11391 0 1
// end else
35230: GO 36145
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35232: LD_VAR 0 3
35236: PPUSH
35237: LD_EXP 49
35241: PPUSH
35242: CALL 42999 0 2
35246: PUSH
35247: LD_VAR 0 3
35251: PPUSH
35252: LD_EXP 40
35256: PPUSH
35257: CALL 42999 0 2
35261: AND
35262: IFFALSE 35470
// begin for i = 1 to MREG_ToUpLab do
35264: LD_ADDR_VAR 0 2
35268: PUSH
35269: DOUBLE
35270: LD_INT 1
35272: DEC
35273: ST_TO_ADDR
35274: LD_EXP 49
35278: PUSH
35279: FOR_TO
35280: IFFALSE 35466
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35282: LD_EXP 49
35286: PUSH
35287: LD_VAR 0 2
35291: ARRAY
35292: PUSH
35293: LD_INT 1
35295: ARRAY
35296: PUSH
35297: LD_VAR 0 3
35301: EQUAL
35302: IFFALSE 35464
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35304: LD_EXP 49
35308: PUSH
35309: LD_VAR 0 2
35313: ARRAY
35314: PUSH
35315: LD_INT 2
35317: ARRAY
35318: PUSH
35319: LD_EXP 49
35323: PUSH
35324: LD_VAR 0 2
35328: ARRAY
35329: PUSH
35330: LD_INT 3
35332: ARRAY
35333: AND
35334: IFFALSE 35462
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35336: LD_VAR 0 3
35340: PPUSH
35341: LD_EXP 49
35345: PUSH
35346: LD_VAR 0 2
35350: ARRAY
35351: PUSH
35352: LD_INT 2
35354: ARRAY
35355: PPUSH
35356: LD_EXP 49
35360: PUSH
35361: LD_VAR 0 2
35365: ARRAY
35366: PUSH
35367: LD_INT 3
35369: ARRAY
35370: PPUSH
35371: CALL 8915 0 3
35375: IFFALSE 35462
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35377: LD_ADDR_EXP 49
35381: PUSH
35382: LD_EXP 49
35386: PPUSH
35387: LD_VAR 0 3
35391: PPUSH
35392: LD_EXP 49
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: PUSH
35403: LD_INT 2
35405: ARRAY
35406: PPUSH
35407: LD_EXP 49
35411: PUSH
35412: LD_VAR 0 2
35416: ARRAY
35417: PUSH
35418: LD_INT 3
35420: ARRAY
35421: PPUSH
35422: CALL 42051 0 4
35426: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35427: LD_ADDR_EXP 40
35431: PUSH
35432: LD_EXP 40
35436: PPUSH
35437: LD_VAR 0 3
35441: PPUSH
35442: LD_EXP 40
35446: PUSH
35447: LD_INT 1
35449: ARRAY
35450: PUSH
35451: LD_INT 2
35453: ARRAY
35454: PPUSH
35455: EMPTY
35456: PPUSH
35457: CALL 42051 0 4
35461: ST_TO_ADDR
// end ; break ;
35462: GO 35466
// end ;
35464: GO 35279
35466: POP
35467: POP
// end else
35468: GO 36145
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35470: LD_VAR 0 3
35474: PPUSH
35475: LD_EXP 48
35479: PPUSH
35480: CALL 42999 0 2
35484: IFFALSE 35558
// begin for i = 1 to MREG_ToUpdate do
35486: LD_ADDR_VAR 0 2
35490: PUSH
35491: DOUBLE
35492: LD_INT 1
35494: DEC
35495: ST_TO_ADDR
35496: LD_EXP 48
35500: PUSH
35501: FOR_TO
35502: IFFALSE 35554
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35504: LD_EXP 48
35508: PUSH
35509: LD_VAR 0 2
35513: ARRAY
35514: PUSH
35515: LD_INT 1
35517: ARRAY
35518: PUSH
35519: LD_VAR 0 3
35523: EQUAL
35524: IFFALSE 35552
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35526: LD_VAR 0 3
35530: PPUSH
35531: LD_EXP 48
35535: PUSH
35536: LD_VAR 0 2
35540: ARRAY
35541: PUSH
35542: LD_INT 2
35544: ARRAY
35545: PPUSH
35546: CALL 8751 0 2
// break ;
35550: GO 35554
// end ;
35552: GO 35501
35554: POP
35555: POP
// end else
35556: GO 36145
// if MCF_Get ( side , [ f_constructed ] ) then
35558: LD_VAR 0 3
35562: PPUSH
35563: LD_INT 57
35565: PUSH
35566: EMPTY
35567: LIST
35568: PPUSH
35569: CALL 11651 0 2
35573: IFFALSE 35606
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35575: LD_VAR 0 3
35579: PPUSH
35580: LD_VAR 0 3
35584: PPUSH
35585: LD_INT 57
35587: PUSH
35588: EMPTY
35589: LIST
35590: PPUSH
35591: CALL 11651 0 2
35595: PUSH
35596: LD_INT 1
35598: ARRAY
35599: PPUSH
35600: CALL 10995 0 2
35604: GO 36145
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35606: LD_VAR 0 3
35610: PPUSH
35611: LD_EXP 46
35615: PPUSH
35616: CALL 42999 0 2
35620: PUSH
35621: LD_VAR 0 3
35625: PPUSH
35626: CALL_OW 345
35630: NOT
35631: AND
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: CALL 25006 0 1
35642: PUSH
35643: LD_INT 0
35645: EQUAL
35646: AND
35647: IFFALSE 36046
// begin for i = 1 to MREG_ToBuild do
35649: LD_ADDR_VAR 0 2
35653: PUSH
35654: DOUBLE
35655: LD_INT 1
35657: DEC
35658: ST_TO_ADDR
35659: LD_EXP 46
35663: PUSH
35664: FOR_TO
35665: IFFALSE 36042
// if MREG_ToBuild [ i ] [ 1 ] = side then
35667: LD_EXP 46
35671: PUSH
35672: LD_VAR 0 2
35676: ARRAY
35677: PUSH
35678: LD_INT 1
35680: ARRAY
35681: PUSH
35682: LD_VAR 0 3
35686: EQUAL
35687: IFFALSE 36040
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35689: LD_OWVAR 84
35693: PUSH
35694: LD_EXP 46
35698: PUSH
35699: LD_VAR 0 2
35703: ARRAY
35704: PUSH
35705: LD_INT 3
35707: ARRAY
35708: PUSH
35709: LD_INT 1
35711: ARRAY
35712: PPUSH
35713: LD_EXP 46
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PUSH
35724: LD_INT 3
35726: ARRAY
35727: PUSH
35728: LD_INT 2
35730: ARRAY
35731: PPUSH
35732: CALL_OW 351
35736: AND
35737: IFFALSE 35781
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35739: LD_EXP 46
35743: PUSH
35744: LD_VAR 0 2
35748: ARRAY
35749: PUSH
35750: LD_INT 3
35752: ARRAY
35753: PUSH
35754: LD_INT 1
35756: ARRAY
35757: PPUSH
35758: LD_EXP 46
35762: PUSH
35763: LD_VAR 0 2
35767: ARRAY
35768: PUSH
35769: LD_INT 3
35771: ARRAY
35772: PUSH
35773: LD_INT 2
35775: ARRAY
35776: PPUSH
35777: CALL 22799 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35781: LD_EXP 46
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 2
35794: ARRAY
35795: PUSH
35796: LD_INT 0
35798: EQUAL
35799: IFFALSE 35869
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35801: LD_VAR 0 3
35805: PPUSH
35806: LD_EXP 46
35810: PUSH
35811: LD_VAR 0 2
35815: ARRAY
35816: PUSH
35817: LD_INT 3
35819: ARRAY
35820: PUSH
35821: LD_INT 1
35823: ARRAY
35824: PPUSH
35825: LD_EXP 46
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PUSH
35836: LD_INT 3
35838: ARRAY
35839: PUSH
35840: LD_INT 2
35842: ARRAY
35843: PPUSH
35844: LD_EXP 46
35848: PUSH
35849: LD_VAR 0 2
35853: ARRAY
35854: PUSH
35855: LD_INT 3
35857: ARRAY
35858: PUSH
35859: LD_INT 3
35861: ARRAY
35862: PPUSH
35863: CALL 8587 0 4
35867: GO 36038
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35869: LD_EXP 46
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: PUSH
35880: LD_INT 2
35882: ARRAY
35883: PUSH
35884: LD_INT 6
35886: EQUAL
35887: IFFALSE 35957
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35889: LD_VAR 0 3
35893: PPUSH
35894: LD_EXP 46
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PUSH
35905: LD_INT 3
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PPUSH
35913: LD_EXP 46
35917: PUSH
35918: LD_VAR 0 2
35922: ARRAY
35923: PUSH
35924: LD_INT 3
35926: ARRAY
35927: PUSH
35928: LD_INT 2
35930: ARRAY
35931: PPUSH
35932: LD_EXP 46
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: PUSH
35943: LD_INT 3
35945: ARRAY
35946: PUSH
35947: LD_INT 3
35949: ARRAY
35950: PPUSH
35951: CALL 8716 0 4
35955: GO 36038
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35957: LD_VAR 0 3
35961: PPUSH
35962: LD_EXP 46
35966: PUSH
35967: LD_VAR 0 2
35971: ARRAY
35972: PUSH
35973: LD_INT 2
35975: ARRAY
35976: PPUSH
35977: LD_EXP 46
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: PUSH
35988: LD_INT 3
35990: ARRAY
35991: PUSH
35992: LD_INT 1
35994: ARRAY
35995: PPUSH
35996: LD_EXP 46
36000: PUSH
36001: LD_VAR 0 2
36005: ARRAY
36006: PUSH
36007: LD_INT 3
36009: ARRAY
36010: PUSH
36011: LD_INT 2
36013: ARRAY
36014: PPUSH
36015: LD_EXP 46
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: PUSH
36026: LD_INT 3
36028: ARRAY
36029: PUSH
36030: LD_INT 3
36032: ARRAY
36033: PPUSH
36034: CALL 10220 0 5
// break ;
36038: GO 36042
// end ;
36040: GO 35664
36042: POP
36043: POP
// end else
36044: GO 36145
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36046: LD_VAR 0 3
36050: PPUSH
36051: LD_EXP 52
36055: PPUSH
36056: CALL 42999 0 2
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL 25006 0 1
36070: PUSH
36071: LD_INT 0
36073: EQUAL
36074: AND
36075: IFFALSE 36145
// begin for i = 1 to MREG_ToDismantle do
36077: LD_ADDR_VAR 0 2
36081: PUSH
36082: DOUBLE
36083: LD_INT 1
36085: DEC
36086: ST_TO_ADDR
36087: LD_EXP 52
36091: PUSH
36092: FOR_TO
36093: IFFALSE 36143
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36095: LD_EXP 52
36099: PUSH
36100: LD_VAR 0 2
36104: ARRAY
36105: PUSH
36106: LD_INT 1
36108: ARRAY
36109: PUSH
36110: LD_VAR 0 3
36114: EQUAL
36115: IFFALSE 36141
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36117: LD_VAR 0 3
36121: PPUSH
36122: LD_EXP 52
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PUSH
36133: LD_INT 2
36135: ARRAY
36136: PPUSH
36137: CALL 10886 0 2
// end ;
36141: GO 36092
36143: POP
36144: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36145: LD_VAR 0 3
36149: PPUSH
36150: LD_INT 30
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PPUSH
36160: CALL 11651 0 2
36164: PUSH
36165: LD_VAR 0 3
36169: PPUSH
36170: CALL 25006 0 1
36174: PUSH
36175: LD_INT 0
36177: EQUAL
36178: AND
36179: IFFALSE 36190
// MCT_CollectCrates ( side ) ;
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 23945 0 1
// end ;
36190: GO 34191
36192: POP
36193: POP
// end ;
36194: LD_VAR 0 1
36198: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36199: LD_INT 0
36201: PPUSH
36202: PPUSH
36203: PPUSH
36204: PPUSH
36205: PPUSH
36206: PPUSH
36207: PPUSH
36208: PPUSH
36209: PPUSH
36210: PPUSH
36211: PPUSH
36212: PPUSH
36213: PPUSH
36214: PPUSH
36215: PPUSH
// all := MCF_All ( side , [ ] ) ;
36216: LD_ADDR_VAR 0 17
36220: PUSH
36221: LD_VAR 0 1
36225: PPUSH
36226: EMPTY
36227: PPUSH
36228: CALL 11786 0 2
36232: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36233: LD_ADDR_VAR 0 13
36237: PUSH
36238: LD_VAR 0 1
36242: PPUSH
36243: LD_INT 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL 11734 0 3
36252: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36253: LD_ADDR_VAR 0 14
36257: PUSH
36258: LD_VAR 0 1
36262: PPUSH
36263: LD_INT 2
36265: PPUSH
36266: EMPTY
36267: PPUSH
36268: CALL 11734 0 3
36272: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36273: LD_ADDR_VAR 0 15
36277: PUSH
36278: LD_VAR 0 1
36282: PPUSH
36283: LD_INT 3
36285: PPUSH
36286: EMPTY
36287: PPUSH
36288: CALL 11734 0 3
36292: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36293: LD_ADDR_VAR 0 16
36297: PUSH
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_INT 4
36305: PPUSH
36306: EMPTY
36307: PPUSH
36308: CALL 11734 0 3
36312: ST_TO_ADDR
// if mech then
36313: LD_VAR 0 15
36317: IFFALSE 36334
// mech := MCF_SortListDesc ( mech ) ;
36319: LD_ADDR_VAR 0 15
36323: PUSH
36324: LD_VAR 0 15
36328: PPUSH
36329: CALL 12900 0 1
36333: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36334: LD_EXP 56
36338: PUSH
36339: LD_VAR 0 1
36343: ARRAY
36344: PUSH
36345: LD_STRING 
36347: EQUAL
36348: NOT
36349: IFFALSE 36405
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36351: LD_EXP 56
36355: PUSH
36356: LD_VAR 0 1
36360: ARRAY
36361: PUSH
36362: LD_INT 1
36364: ARRAY
36365: PPUSH
36366: CALL_OW 257
36370: PUSH
36371: LD_INT 1
36373: EQUAL
36374: IFFALSE 36403
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36376: LD_VAR 0 1
36380: PPUSH
36381: LD_STRING ToArm
36383: PPUSH
36384: LD_EXP 56
36388: PUSH
36389: LD_VAR 0 1
36393: ARRAY
36394: PUSH
36395: LD_INT 1
36397: ARRAY
36398: PPUSH
36399: CALL 14530 0 3
// end else
36403: GO 36431
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36405: LD_ADDR_EXP 56
36409: PUSH
36410: LD_EXP 56
36414: PPUSH
36415: LD_VAR 0 1
36419: PPUSH
36420: LD_INT 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL 31130 0 4
36430: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36431: LD_EXP 57
36435: PUSH
36436: LD_VAR 0 1
36440: ARRAY
36441: PUSH
36442: LD_STRING 
36444: EQUAL
36445: NOT
36446: IFFALSE 36502
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36448: LD_EXP 57
36452: PUSH
36453: LD_VAR 0 1
36457: ARRAY
36458: PUSH
36459: LD_INT 1
36461: ARRAY
36462: PPUSH
36463: CALL_OW 257
36467: PUSH
36468: LD_INT 2
36470: EQUAL
36471: IFFALSE 36500
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36473: LD_VAR 0 1
36477: PPUSH
36478: LD_STRING ToDep
36480: PPUSH
36481: LD_EXP 57
36485: PUSH
36486: LD_VAR 0 1
36490: ARRAY
36491: PUSH
36492: LD_INT 1
36494: ARRAY
36495: PPUSH
36496: CALL 14530 0 3
// end else
36500: GO 36528
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36502: LD_ADDR_EXP 57
36506: PUSH
36507: LD_EXP 57
36511: PPUSH
36512: LD_VAR 0 1
36516: PPUSH
36517: LD_INT 1
36519: PPUSH
36520: LD_INT 0
36522: PPUSH
36523: CALL 31130 0 4
36527: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36528: LD_EXP 55
36532: PUSH
36533: LD_VAR 0 1
36537: ARRAY
36538: PUSH
36539: LD_STRING 
36541: EQUAL
36542: NOT
36543: IFFALSE 36599
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36545: LD_EXP 55
36549: PUSH
36550: LD_VAR 0 1
36554: ARRAY
36555: PUSH
36556: LD_INT 1
36558: ARRAY
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: EQUAL
36568: IFFALSE 36597
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36570: LD_VAR 0 1
36574: PPUSH
36575: LD_STRING ToFac
36577: PPUSH
36578: LD_EXP 55
36582: PUSH
36583: LD_VAR 0 1
36587: ARRAY
36588: PUSH
36589: LD_INT 1
36591: ARRAY
36592: PPUSH
36593: CALL 14530 0 3
// end else
36597: GO 36625
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36599: LD_ADDR_EXP 55
36603: PUSH
36604: LD_EXP 55
36608: PPUSH
36609: LD_VAR 0 1
36613: PPUSH
36614: LD_INT 1
36616: PPUSH
36617: LD_INT 0
36619: PPUSH
36620: CALL 31130 0 4
36624: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36625: LD_EXP 54
36629: PUSH
36630: LD_VAR 0 1
36634: ARRAY
36635: PUSH
36636: LD_STRING 
36638: EQUAL
36639: NOT
36640: IFFALSE 36696
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36642: LD_EXP 54
36646: PUSH
36647: LD_VAR 0 1
36651: ARRAY
36652: PUSH
36653: LD_INT 1
36655: ARRAY
36656: PPUSH
36657: CALL_OW 257
36661: PUSH
36662: LD_INT 4
36664: EQUAL
36665: IFFALSE 36694
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36667: LD_VAR 0 1
36671: PPUSH
36672: LD_STRING ToLab
36674: PPUSH
36675: LD_EXP 54
36679: PUSH
36680: LD_VAR 0 1
36684: ARRAY
36685: PUSH
36686: LD_INT 1
36688: ARRAY
36689: PPUSH
36690: CALL 14530 0 3
// end else
36694: GO 36722
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36696: LD_ADDR_EXP 54
36700: PUSH
36701: LD_EXP 54
36705: PPUSH
36706: LD_VAR 0 1
36710: PPUSH
36711: LD_INT 1
36713: PPUSH
36714: LD_INT 0
36716: PPUSH
36717: CALL 31130 0 4
36721: ST_TO_ADDR
// if mode = 0 then
36722: LD_VAR 0 2
36726: PUSH
36727: LD_INT 0
36729: EQUAL
36730: IFFALSE 38568
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36732: LD_VAR 0 1
36736: PPUSH
36737: LD_INT 30
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PPUSH
36747: CALL 11651 0 2
36751: PUSH
36752: LD_VAR 0 1
36756: PPUSH
36757: LD_INT 21
36759: PUSH
36760: LD_INT 3
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PPUSH
36767: CALL 11651 0 2
36771: PUSH
36772: LD_INT 1
36774: EQUAL
36775: AND
36776: IFFALSE 36841
// begin if all then
36778: LD_VAR 0 17
36782: IFFALSE 36839
// for i in ( all diff eng ) do
36784: LD_ADDR_VAR 0 4
36788: PUSH
36789: LD_VAR 0 17
36793: PUSH
36794: LD_VAR 0 14
36798: DIFF
36799: PUSH
36800: FOR_IN
36801: IFFALSE 36837
// if GetTag ( i ) = 0 then
36803: LD_VAR 0 4
36807: PPUSH
36808: CALL_OW 110
36812: PUSH
36813: LD_INT 0
36815: EQUAL
36816: IFFALSE 36835
// MCH_ChangeClass ( side , i , 2 ) ;
36818: LD_VAR 0 1
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: LD_INT 2
36830: PPUSH
36831: CALL 16558 0 3
36835: GO 36800
36837: POP
36838: POP
// end else
36839: GO 37160
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36841: LD_VAR 0 13
36845: PUSH
36846: LD_EXP 56
36850: PUSH
36851: LD_VAR 0 1
36855: ARRAY
36856: PLUS
36857: PUSH
36858: LD_INT 22
36860: PUSH
36861: LD_VAR 0 1
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 32
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PPUSH
36884: CALL_OW 69
36888: LESS
36889: IFFALSE 36914
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36891: LD_VAR 0 1
36895: PPUSH
36896: LD_VAR 0 14
36900: PUSH
36901: LD_INT 1
36903: ARRAY
36904: PPUSH
36905: LD_INT 1
36907: PPUSH
36908: CALL 16558 0 3
// end else
36912: GO 37160
// if sci < 6 and MCF_Lab ( side ) then
36914: LD_VAR 0 16
36918: PUSH
36919: LD_INT 6
36921: LESS
36922: PUSH
36923: LD_VAR 0 1
36927: PPUSH
36928: CALL 11690 0 1
36932: AND
36933: IFFALSE 37038
// begin if MREG_ToBunker [ side ] then
36935: LD_EXP 68
36939: PUSH
36940: LD_VAR 0 1
36944: ARRAY
36945: IFFALSE 36971
// tmp := sol diff MREG_ToBunker [ side ] else
36947: LD_ADDR_VAR 0 12
36951: PUSH
36952: LD_VAR 0 13
36956: PUSH
36957: LD_EXP 68
36961: PUSH
36962: LD_VAR 0 1
36966: ARRAY
36967: DIFF
36968: ST_TO_ADDR
36969: GO 36981
// tmp := sol ;
36971: LD_ADDR_VAR 0 12
36975: PUSH
36976: LD_VAR 0 13
36980: ST_TO_ADDR
// if tmp then
36981: LD_VAR 0 12
36985: IFFALSE 37036
// for i in tmp do
36987: LD_ADDR_VAR 0 4
36991: PUSH
36992: LD_VAR 0 12
36996: PUSH
36997: FOR_IN
36998: IFFALSE 37034
// if GetTag ( i ) = 0 then
37000: LD_VAR 0 4
37004: PPUSH
37005: CALL_OW 110
37009: PUSH
37010: LD_INT 0
37012: EQUAL
37013: IFFALSE 37032
// MCH_ChangeClass ( side , i , 4 ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: LD_VAR 0 4
37024: PPUSH
37025: LD_INT 4
37027: PPUSH
37028: CALL 16558 0 3
37032: GO 36997
37034: POP
37035: POP
// end else
37036: GO 37160
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37038: LD_VAR 0 1
37042: PPUSH
37043: LD_INT 30
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PPUSH
37053: CALL 11651 0 2
37057: IFFALSE 37160
// begin if MREG_ToBunker [ side ] then
37059: LD_EXP 68
37063: PUSH
37064: LD_VAR 0 1
37068: ARRAY
37069: IFFALSE 37095
// tmp := sol diff MREG_ToBunker [ side ] else
37071: LD_ADDR_VAR 0 12
37075: PUSH
37076: LD_VAR 0 13
37080: PUSH
37081: LD_EXP 68
37085: PUSH
37086: LD_VAR 0 1
37090: ARRAY
37091: DIFF
37092: ST_TO_ADDR
37093: GO 37105
// tmp := sol ;
37095: LD_ADDR_VAR 0 12
37099: PUSH
37100: LD_VAR 0 13
37104: ST_TO_ADDR
// if tmp then
37105: LD_VAR 0 12
37109: IFFALSE 37160
// for i in tmp do
37111: LD_ADDR_VAR 0 4
37115: PUSH
37116: LD_VAR 0 12
37120: PUSH
37121: FOR_IN
37122: IFFALSE 37158
// if GetTag ( i ) = 0 then
37124: LD_VAR 0 4
37128: PPUSH
37129: CALL_OW 110
37133: PUSH
37134: LD_INT 0
37136: EQUAL
37137: IFFALSE 37156
// MCH_ChangeClass ( side , i , 2 ) ;
37139: LD_VAR 0 1
37143: PPUSH
37144: LD_VAR 0 4
37148: PPUSH
37149: LD_INT 2
37151: PPUSH
37152: CALL 16558 0 3
37156: GO 37121
37158: POP
37159: POP
// end ; if MCF_Lab ( side ) then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL 11690 0 1
37169: IFFALSE 37709
// begin if MCL_GetTechList ( side ) then
37171: LD_VAR 0 1
37175: PPUSH
37176: CALL 18034 0 1
37180: IFFALSE 37306
// begin if MREG_ToLab [ side ] then
37182: LD_EXP 54
37186: PUSH
37187: LD_VAR 0 1
37191: ARRAY
37192: IFFALSE 37212
// k := MREG_ToLab [ side ] else
37194: LD_ADDR_VAR 0 8
37198: PUSH
37199: LD_EXP 54
37203: PUSH
37204: LD_VAR 0 1
37208: ARRAY
37209: ST_TO_ADDR
37210: GO 37220
// k := 0 ;
37212: LD_ADDR_VAR 0 8
37216: PUSH
37217: LD_INT 0
37219: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37220: LD_VAR 0 16
37224: PUSH
37225: LD_VAR 0 8
37229: PLUS
37230: PUSH
37231: LD_INT 6
37233: LESSEQUAL
37234: PUSH
37235: LD_VAR 0 17
37239: PUSH
37240: LD_INT 6
37242: GREATER
37243: AND
37244: IFFALSE 37260
// MCH_TrainScientist ( side , 1 ) else
37246: LD_VAR 0 1
37250: PPUSH
37251: LD_INT 1
37253: PPUSH
37254: CALL 16110 0 2
37258: GO 37304
// if all < 6 then
37260: LD_VAR 0 17
37264: PUSH
37265: LD_INT 6
37267: LESS
37268: IFFALSE 37304
// if sci + k < all / 2 then
37270: LD_VAR 0 16
37274: PUSH
37275: LD_VAR 0 8
37279: PLUS
37280: PUSH
37281: LD_VAR 0 17
37285: PUSH
37286: LD_INT 2
37288: DIVREAL
37289: LESS
37290: IFFALSE 37304
// MCH_TrainScientist ( side , 1 ) ;
37292: LD_VAR 0 1
37296: PPUSH
37297: LD_INT 1
37299: PPUSH
37300: CALL 16110 0 2
// end else
37304: GO 37382
// begin if sci > 2 then
37306: LD_VAR 0 16
37310: PUSH
37311: LD_INT 2
37313: GREATER
37314: IFFALSE 37382
// for i = sci downto 2 do
37316: LD_ADDR_VAR 0 4
37320: PUSH
37321: DOUBLE
37322: LD_VAR 0 16
37326: INC
37327: ST_TO_ADDR
37328: LD_INT 2
37330: PUSH
37331: FOR_DOWNTO
37332: IFFALSE 37380
// if GetTag ( sci [ i ] ) = 0 then
37334: LD_VAR 0 16
37338: PUSH
37339: LD_VAR 0 4
37343: ARRAY
37344: PPUSH
37345: CALL_OW 110
37349: PUSH
37350: LD_INT 0
37352: EQUAL
37353: IFFALSE 37378
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37355: LD_VAR 0 1
37359: PPUSH
37360: LD_VAR 0 16
37364: PUSH
37365: LD_VAR 0 4
37369: ARRAY
37370: PPUSH
37371: LD_INT 2
37373: PPUSH
37374: CALL 16558 0 3
37378: GO 37331
37380: POP
37381: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37382: LD_VAR 0 1
37386: PPUSH
37387: CALL 18034 0 1
37391: PUSH
37392: LD_VAR 0 1
37396: PPUSH
37397: CALL 11690 0 1
37401: AND
37402: PUSH
37403: LD_EXP 35
37407: PUSH
37408: LD_VAR 0 1
37412: ARRAY
37413: NOT
37414: AND
37415: IFFALSE 37709
// begin for j = 1 to MCF_Lab ( side ) do
37417: LD_ADDR_VAR 0 5
37421: PUSH
37422: DOUBLE
37423: LD_INT 1
37425: DEC
37426: ST_TO_ADDR
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL 11690 0 1
37436: PUSH
37437: FOR_TO
37438: IFFALSE 37498
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37440: LD_VAR 0 1
37444: PPUSH
37445: CALL 11690 0 1
37449: PUSH
37450: LD_VAR 0 5
37454: ARRAY
37455: PPUSH
37456: CALL_OW 461
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 6
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: IN
37471: IFFALSE 37496
// begin b := MCF_Lab ( side ) [ j ] ;
37473: LD_ADDR_VAR 0 11
37477: PUSH
37478: LD_VAR 0 1
37482: PPUSH
37483: CALL 11690 0 1
37487: PUSH
37488: LD_VAR 0 5
37492: ARRAY
37493: ST_TO_ADDR
// break ;
37494: GO 37498
// end ;
37496: GO 37437
37498: POP
37499: POP
// if MCF_Class ( side , 4 , [ ] ) then
37500: LD_VAR 0 1
37504: PPUSH
37505: LD_INT 4
37507: PPUSH
37508: EMPTY
37509: PPUSH
37510: CALL 11734 0 3
37514: IFFALSE 37709
// for j in MCF_Class ( side , 4 , [ ] ) do
37516: LD_ADDR_VAR 0 5
37520: PUSH
37521: LD_VAR 0 1
37525: PPUSH
37526: LD_INT 4
37528: PPUSH
37529: EMPTY
37530: PPUSH
37531: CALL 11734 0 3
37535: PUSH
37536: FOR_IN
37537: IFFALSE 37707
// begin if GetTag ( j ) = 0 then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 110
37548: PUSH
37549: LD_INT 0
37551: EQUAL
37552: IFFALSE 37643
// begin if IsInUnit ( j ) and b then
37554: LD_VAR 0 5
37558: PPUSH
37559: CALL_OW 310
37563: PUSH
37564: LD_VAR 0 11
37568: AND
37569: IFFALSE 37617
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37571: LD_VAR 0 5
37575: PPUSH
37576: CALL_OW 310
37580: PPUSH
37581: CALL_OW 461
37585: PUSH
37586: LD_INT 2
37588: EQUAL
37589: PUSH
37590: LD_VAR 0 5
37594: PPUSH
37595: CALL_OW 310
37599: PUSH
37600: LD_VAR 0 11
37604: NONEQUAL
37605: AND
37606: IFFALSE 37617
// ComExitBuilding ( j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 122
// if not IsInUnit ( j ) then
37617: LD_VAR 0 5
37621: PPUSH
37622: CALL_OW 310
37626: NOT
37627: IFFALSE 37643
// ComEnterUnit ( j , b ) ;
37629: LD_VAR 0 5
37633: PPUSH
37634: LD_VAR 0 11
37638: PPUSH
37639: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37643: LD_INT 1
37645: PPUSH
37646: LD_VAR 0 5
37650: PPUSH
37651: CALL_OW 255
37655: PPUSH
37656: CALL_OW 321
37660: PUSH
37661: LD_INT 2
37663: EQUAL
37664: PUSH
37665: LD_VAR 0 5
37669: PPUSH
37670: CALL_OW 255
37674: PPUSH
37675: CALL 25006 0 1
37679: PUSH
37680: LD_INT 0
37682: EQUAL
37683: AND
37684: IFFALSE 37705
// MCN_Tame ( GetSide ( j ) , j ) ;
37686: LD_VAR 0 5
37690: PPUSH
37691: CALL_OW 255
37695: PPUSH
37696: LD_VAR 0 5
37700: PPUSH
37701: CALL 18553 0 2
// end ;
37705: GO 37536
37707: POP
37708: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37709: LD_VAR 0 1
37713: PPUSH
37714: LD_INT 30
37716: PUSH
37717: LD_INT 3
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PPUSH
37724: CALL 11651 0 2
37728: IFFALSE 37987
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37730: LD_ADDR_VAR 0 11
37734: PUSH
37735: LD_VAR 0 1
37739: PPUSH
37740: LD_INT 30
37742: PUSH
37743: LD_INT 3
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PPUSH
37750: CALL 11651 0 2
37754: PUSH
37755: LD_INT 1
37757: ARRAY
37758: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37759: LD_ADDR_VAR 0 12
37763: PUSH
37764: LD_VAR 0 1
37768: PPUSH
37769: LD_INT 0
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 3
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL 12354 0 3
37786: ST_TO_ADDR
// for i = 1 to tmp do
37787: LD_ADDR_VAR 0 4
37791: PUSH
37792: DOUBLE
37793: LD_INT 1
37795: DEC
37796: ST_TO_ADDR
37797: LD_VAR 0 12
37801: PUSH
37802: FOR_TO
37803: IFFALSE 37863
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37805: LD_VAR 0 12
37809: PUSH
37810: LD_VAR 0 4
37814: ARRAY
37815: PPUSH
37816: CALL_OW 310
37820: NOT
37821: PUSH
37822: LD_VAR 0 12
37826: PUSH
37827: LD_VAR 0 4
37831: ARRAY
37832: PPUSH
37833: CALL_OW 314
37837: NOT
37838: AND
37839: IFFALSE 37861
// ComEnterUnit ( tmp [ i ] , b ) ;
37841: LD_VAR 0 12
37845: PUSH
37846: LD_VAR 0 4
37850: ARRAY
37851: PPUSH
37852: LD_VAR 0 11
37856: PPUSH
37857: CALL_OW 120
37861: GO 37802
37863: POP
37864: POP
// if MREG_ToFac [ side ] then
37865: LD_EXP 55
37869: PUSH
37870: LD_VAR 0 1
37874: ARRAY
37875: IFFALSE 37895
// k := MREG_ToFac [ side ] else
37877: LD_ADDR_VAR 0 8
37881: PUSH
37882: LD_EXP 55
37886: PUSH
37887: LD_VAR 0 1
37891: ARRAY
37892: ST_TO_ADDR
37893: GO 37903
// k := 0 ;
37895: LD_ADDR_VAR 0 8
37899: PUSH
37900: LD_INT 0
37902: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37903: LD_VAR 0 15
37907: PUSH
37908: LD_VAR 0 8
37912: PLUS
37913: PUSH
37914: LD_INT 6
37916: LESSEQUAL
37917: PUSH
37918: LD_VAR 0 17
37922: PUSH
37923: LD_INT 6
37925: GREATER
37926: AND
37927: IFFALSE 37943
// MCH_TrainMechanic ( side , 1 ) else
37929: LD_VAR 0 1
37933: PPUSH
37934: LD_INT 1
37936: PPUSH
37937: CALL 15852 0 2
37941: GO 37987
// if all < 6 then
37943: LD_VAR 0 17
37947: PUSH
37948: LD_INT 6
37950: LESS
37951: IFFALSE 37987
// if mech + k < all / 2 then
37953: LD_VAR 0 15
37957: PUSH
37958: LD_VAR 0 8
37962: PLUS
37963: PUSH
37964: LD_VAR 0 17
37968: PUSH
37969: LD_INT 2
37971: DIVREAL
37972: LESS
37973: IFFALSE 37987
// MCH_TrainMechanic ( side , 1 ) ;
37975: LD_VAR 0 1
37979: PPUSH
37980: LD_INT 1
37982: PPUSH
37983: CALL 15852 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37987: LD_ADDR_VAR 0 10
37991: PUSH
37992: LD_VAR 0 1
37996: PPUSH
37997: LD_INT 30
37999: PUSH
38000: LD_INT 36
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PPUSH
38007: CALL 11651 0 2
38011: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38012: LD_VAR 0 10
38016: PUSH
38017: LD_VAR 0 15
38021: AND
38022: PUSH
38023: LD_VAR 0 1
38027: PPUSH
38028: LD_INT 3
38030: PPUSH
38031: EMPTY
38032: PPUSH
38033: CALL 11734 0 3
38037: AND
38038: IFFALSE 38196
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38040: LD_VAR 0 1
38044: PPUSH
38045: LD_INT 9
38047: PPUSH
38048: EMPTY
38049: PPUSH
38050: CALL 12354 0 3
38054: PUSH
38055: LD_INT 3
38057: LESS
38058: IFFALSE 38196
// begin if mech < 3 then
38060: LD_VAR 0 15
38064: PUSH
38065: LD_INT 3
38067: LESS
38068: IFFALSE 38082
// k := mech else
38070: LD_ADDR_VAR 0 8
38074: PUSH
38075: LD_VAR 0 15
38079: ST_TO_ADDR
38080: GO 38090
// k := 3 ;
38082: LD_ADDR_VAR 0 8
38086: PUSH
38087: LD_INT 3
38089: ST_TO_ADDR
// for j = 1 to k do
38090: LD_ADDR_VAR 0 5
38094: PUSH
38095: DOUBLE
38096: LD_INT 1
38098: DEC
38099: ST_TO_ADDR
38100: LD_VAR 0 8
38104: PUSH
38105: FOR_TO
38106: IFFALSE 38164
// if GetClass ( mech [ j ] ) = 3 then
38108: LD_VAR 0 15
38112: PUSH
38113: LD_VAR 0 5
38117: ARRAY
38118: PPUSH
38119: CALL_OW 257
38123: PUSH
38124: LD_INT 3
38126: EQUAL
38127: IFFALSE 38162
// begin SetTag ( mech [ j ] , 9 ) ;
38129: LD_VAR 0 15
38133: PUSH
38134: LD_VAR 0 5
38138: ARRAY
38139: PPUSH
38140: LD_INT 9
38142: PPUSH
38143: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38147: LD_VAR 0 15
38151: PUSH
38152: LD_VAR 0 5
38156: ARRAY
38157: PPUSH
38158: CALL_OW 122
// end ;
38162: GO 38105
38164: POP
38165: POP
// if mech < 6 + k then
38166: LD_VAR 0 15
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_VAR 0 8
38178: PLUS
38179: LESS
38180: IFFALSE 38196
// MCH_TrainMechanic ( side , k ) ;
38182: LD_VAR 0 1
38186: PPUSH
38187: LD_VAR 0 8
38191: PPUSH
38192: CALL 15852 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38196: LD_VAR 0 1
38200: PPUSH
38201: LD_INT 9
38203: PPUSH
38204: EMPTY
38205: PPUSH
38206: CALL 12354 0 3
38210: IFFALSE 38301
// for j in MCF_Tag ( side , 9 , [ ] ) do
38212: LD_ADDR_VAR 0 5
38216: PUSH
38217: LD_VAR 0 1
38221: PPUSH
38222: LD_INT 9
38224: PPUSH
38225: EMPTY
38226: PPUSH
38227: CALL 12354 0 3
38231: PUSH
38232: FOR_IN
38233: IFFALSE 38299
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38235: LD_VAR 0 5
38239: PPUSH
38240: CALL_OW 310
38244: NOT
38245: PUSH
38246: LD_VAR 0 5
38250: PPUSH
38251: CALL 99272 0 1
38255: NOT
38256: AND
38257: IFFALSE 38297
// if ct then
38259: LD_VAR 0 10
38263: IFFALSE 38285
// ComEnterUnit ( j , ct [ 1 ] ) else
38265: LD_VAR 0 5
38269: PPUSH
38270: LD_VAR 0 10
38274: PUSH
38275: LD_INT 1
38277: ARRAY
38278: PPUSH
38279: CALL_OW 120
38283: GO 38297
// SetTag ( j , 0 ) ;
38285: LD_VAR 0 5
38289: PPUSH
38290: LD_INT 0
38292: PPUSH
38293: CALL_OW 109
38297: GO 38232
38299: POP
38300: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38301: LD_INT 1
38303: PPUSH
38304: LD_VAR 0 1
38308: PPUSH
38309: CALL_OW 321
38313: PUSH
38314: LD_INT 2
38316: EQUAL
38317: PUSH
38318: LD_EXP 35
38322: PUSH
38323: LD_VAR 0 1
38327: ARRAY
38328: NOT
38329: AND
38330: PUSH
38331: LD_VAR 0 1
38335: PPUSH
38336: LD_INT 4
38338: PPUSH
38339: EMPTY
38340: PPUSH
38341: CALL 11734 0 3
38345: AND
38346: IFFALSE 38394
// for j in MCF_Class ( side , 4 , [ ] ) do
38348: LD_ADDR_VAR 0 5
38352: PUSH
38353: LD_VAR 0 1
38357: PPUSH
38358: LD_INT 4
38360: PPUSH
38361: EMPTY
38362: PPUSH
38363: CALL 11734 0 3
38367: PUSH
38368: FOR_IN
38369: IFFALSE 38392
// MCN_Tame ( GetSide ( j ) , j ) ;
38371: LD_VAR 0 5
38375: PPUSH
38376: CALL_OW 255
38380: PPUSH
38381: LD_VAR 0 5
38385: PPUSH
38386: CALL 18553 0 2
38390: GO 38368
38392: POP
38393: POP
// if MREG_DefVeh [ side ] then
38394: LD_EXP 67
38398: PUSH
38399: LD_VAR 0 1
38403: ARRAY
38404: IFFALSE 38568
// begin for i in MREG_DefVeh [ side ] do
38406: LD_ADDR_VAR 0 4
38410: PUSH
38411: LD_EXP 67
38415: PUSH
38416: LD_VAR 0 1
38420: ARRAY
38421: PUSH
38422: FOR_IN
38423: IFFALSE 38476
// begin SetTag ( i , 0 ) ;
38425: LD_VAR 0 4
38429: PPUSH
38430: LD_INT 0
38432: PPUSH
38433: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38437: LD_VAR 0 4
38441: PPUSH
38442: LD_EXP 64
38446: PUSH
38447: LD_VAR 0 1
38451: ARRAY
38452: PPUSH
38453: CALL_OW 308
38457: NOT
38458: IFFALSE 38474
// MCV_Parking ( side , i ) ;
38460: LD_VAR 0 1
38464: PPUSH
38465: LD_VAR 0 4
38469: PPUSH
38470: CALL 25741 0 2
// end ;
38474: GO 38422
38476: POP
38477: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38478: LD_VAR 0 1
38482: PPUSH
38483: LD_INT 36
38485: PPUSH
38486: EMPTY
38487: PPUSH
38488: CALL 12354 0 3
38492: IFFALSE 38533
// for i in MCF_Tag ( side , 36 , [ ] ) do
38494: LD_ADDR_VAR 0 4
38498: PUSH
38499: LD_VAR 0 1
38503: PPUSH
38504: LD_INT 36
38506: PPUSH
38507: EMPTY
38508: PPUSH
38509: CALL 12354 0 3
38513: PUSH
38514: FOR_IN
38515: IFFALSE 38531
// SetTag ( i , 0 ) ;
38517: LD_VAR 0 4
38521: PPUSH
38522: LD_INT 0
38524: PPUSH
38525: CALL_OW 109
38529: GO 38514
38531: POP
38532: POP
// if MREG_DefMobActive [ side ] then
38533: LD_EXP 70
38537: PUSH
38538: LD_VAR 0 1
38542: ARRAY
38543: IFFALSE 38568
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38545: LD_ADDR_EXP 70
38549: PUSH
38550: LD_EXP 70
38554: PPUSH
38555: LD_VAR 0 1
38559: PPUSH
38560: LD_INT 0
38562: PPUSH
38563: CALL_OW 1
38567: ST_TO_ADDR
// end ; end ; if mode > 0 then
38568: LD_VAR 0 2
38572: PUSH
38573: LD_INT 0
38575: GREATER
38576: IFFALSE 40471
// begin if tick <= 15 15$00 then
38578: LD_OWVAR 1
38582: PUSH
38583: LD_INT 31500
38585: LESSEQUAL
38586: IFFALSE 38890
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38588: LD_VAR 0 13
38592: PUSH
38593: LD_VAR 0 1
38597: PPUSH
38598: CALL 25006 0 1
38602: PUSH
38603: LD_INT 4
38605: LESS
38606: AND
38607: IFFALSE 38718
// begin for i in sol do
38609: LD_ADDR_VAR 0 4
38613: PUSH
38614: LD_VAR 0 13
38618: PUSH
38619: FOR_IN
38620: IFFALSE 38716
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38622: LD_ADDR_VAR 0 8
38626: PUSH
38627: LD_VAR 0 1
38631: PPUSH
38632: CALL 25006 0 1
38636: PPUSH
38637: LD_VAR 0 4
38641: PPUSH
38642: CALL_OW 74
38646: ST_TO_ADDR
// if IsInUnit ( i ) then
38647: LD_VAR 0 4
38651: PPUSH
38652: CALL_OW 310
38656: IFFALSE 38667
// ComExitBuilding ( i ) ;
38658: LD_VAR 0 4
38662: PPUSH
38663: CALL_OW 122
// if not HasTask ( i ) and k then
38667: LD_VAR 0 4
38671: PPUSH
38672: CALL_OW 314
38676: NOT
38677: PUSH
38678: LD_VAR 0 8
38682: AND
38683: IFFALSE 38714
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38685: LD_VAR 0 4
38689: PPUSH
38690: LD_VAR 0 8
38694: PPUSH
38695: CALL_OW 250
38699: PPUSH
38700: LD_VAR 0 8
38704: PPUSH
38705: CALL_OW 251
38709: PPUSH
38710: CALL_OW 174
// end ;
38714: GO 38619
38716: POP
38717: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38718: LD_VAR 0 1
38722: PPUSH
38723: LD_INT 30
38725: PUSH
38726: LD_INT 5
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PPUSH
38733: CALL 11651 0 2
38737: IFFALSE 38888
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38739: LD_ADDR_VAR 0 11
38743: PUSH
38744: LD_VAR 0 1
38748: PPUSH
38749: LD_INT 30
38751: PUSH
38752: LD_INT 5
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL 11651 0 2
38763: PUSH
38764: LD_INT 1
38766: ARRAY
38767: ST_TO_ADDR
// if mech then
38768: LD_VAR 0 15
38772: IFFALSE 38808
// for i in mech do
38774: LD_ADDR_VAR 0 4
38778: PUSH
38779: LD_VAR 0 15
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38806
// MCH_ChangeClass ( side , i , 1 ) ;
38787: LD_VAR 0 1
38791: PPUSH
38792: LD_VAR 0 4
38796: PPUSH
38797: LD_INT 1
38799: PPUSH
38800: CALL 16558 0 3
38804: GO 38784
38806: POP
38807: POP
// if eng > 1 then
38808: LD_VAR 0 14
38812: PUSH
38813: LD_INT 1
38815: GREATER
38816: IFFALSE 38863
// for i = eng downto 2 do
38818: LD_ADDR_VAR 0 4
38822: PUSH
38823: DOUBLE
38824: LD_VAR 0 14
38828: INC
38829: ST_TO_ADDR
38830: LD_INT 2
38832: PUSH
38833: FOR_DOWNTO
38834: IFFALSE 38861
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38836: LD_VAR 0 1
38840: PPUSH
38841: LD_VAR 0 14
38845: PUSH
38846: LD_VAR 0 4
38850: ARRAY
38851: PPUSH
38852: LD_INT 1
38854: PPUSH
38855: CALL 16558 0 3
38859: GO 38833
38861: POP
38862: POP
// if UnitsInside ( b ) then
38863: LD_VAR 0 11
38867: PPUSH
38868: CALL_OW 313
38872: IFFALSE 38888
// ComExitBuilding ( UnitsInside ( b ) ) ;
38874: LD_VAR 0 11
38878: PPUSH
38879: CALL_OW 313
38883: PPUSH
38884: CALL_OW 122
// end ; end else
38888: GO 40471
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38890: LD_VAR 0 1
38894: PPUSH
38895: LD_INT 1
38897: PPUSH
38898: LD_EXP 65
38902: PUSH
38903: LD_VAR 0 1
38907: ARRAY
38908: PUSH
38909: LD_INT 1
38911: ARRAY
38912: PPUSH
38913: CALL 33743 0 3
38917: IFFALSE 39056
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38919: LD_ADDR_VAR 0 12
38923: PUSH
38924: LD_VAR 0 1
38928: PPUSH
38929: LD_INT 21
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL 11651 0 2
38943: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38944: LD_ADDR_VAR 0 11
38948: PUSH
38949: LD_VAR 0 1
38953: PPUSH
38954: LD_INT 30
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL 11651 0 2
38968: ST_TO_ADDR
// if b then
38969: LD_VAR 0 11
38973: IFFALSE 39056
// for i in tmp do
38975: LD_ADDR_VAR 0 4
38979: PUSH
38980: LD_VAR 0 12
38984: PUSH
38985: FOR_IN
38986: IFFALSE 39054
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38988: LD_VAR 0 4
38992: PPUSH
38993: LD_EXP 65
38997: PUSH
38998: LD_VAR 0 1
39002: ARRAY
39003: PUSH
39004: LD_INT 1
39006: ARRAY
39007: PPUSH
39008: CALL_OW 308
39012: NOT
39013: IFFALSE 39052
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39015: LD_VAR 0 4
39019: PPUSH
39020: LD_VAR 0 11
39024: PUSH
39025: LD_INT 1
39027: ARRAY
39028: PPUSH
39029: CALL_OW 250
39033: PPUSH
39034: LD_VAR 0 11
39038: PUSH
39039: LD_INT 1
39041: ARRAY
39042: PPUSH
39043: CALL_OW 251
39047: PPUSH
39048: CALL_OW 111
39052: GO 38985
39054: POP
39055: POP
// end ; if MREG_DefVeh [ side ] then
39056: LD_EXP 67
39060: PUSH
39061: LD_VAR 0 1
39065: ARRAY
39066: IFFALSE 39634
// begin tmp := [ ] ;
39068: LD_ADDR_VAR 0 12
39072: PUSH
39073: EMPTY
39074: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39075: LD_EXP 70
39079: PUSH
39080: LD_VAR 0 1
39084: ARRAY
39085: PUSH
39086: LD_INT 0
39088: EQUAL
39089: IFFALSE 39229
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39091: LD_ADDR_VAR 0 8
39095: PUSH
39096: LD_VAR 0 1
39100: PPUSH
39101: LD_INT 0
39103: PPUSH
39104: LD_INT 25
39106: PUSH
39107: LD_INT 3
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL 12354 0 3
39118: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39119: LD_VAR 0 8
39123: PUSH
39124: LD_EXP 67
39128: PUSH
39129: LD_VAR 0 1
39133: ARRAY
39134: GREATER
39135: IFFALSE 39196
// begin for i = 1 to MREG_DefVeh [ side ] do
39137: LD_ADDR_VAR 0 4
39141: PUSH
39142: DOUBLE
39143: LD_INT 1
39145: DEC
39146: ST_TO_ADDR
39147: LD_EXP 67
39151: PUSH
39152: LD_VAR 0 1
39156: ARRAY
39157: PUSH
39158: FOR_TO
39159: IFFALSE 39192
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39161: LD_ADDR_VAR 0 12
39165: PUSH
39166: LD_VAR 0 12
39170: PPUSH
39171: LD_INT 1
39173: PPUSH
39174: LD_VAR 0 8
39178: PUSH
39179: LD_VAR 0 4
39183: ARRAY
39184: PPUSH
39185: CALL_OW 2
39189: ST_TO_ADDR
39190: GO 39158
39192: POP
39193: POP
// end else
39194: GO 39206
// tmp := k ;
39196: LD_ADDR_VAR 0 12
39200: PUSH
39201: LD_VAR 0 8
39205: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39206: LD_ADDR_EXP 70
39210: PUSH
39211: LD_EXP 70
39215: PPUSH
39216: LD_VAR 0 1
39220: PPUSH
39221: LD_INT 1
39223: PPUSH
39224: CALL_OW 1
39228: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39229: LD_ADDR_VAR 0 4
39233: PUSH
39234: LD_EXP 67
39238: PUSH
39239: LD_VAR 0 1
39243: ARRAY
39244: PUSH
39245: FOR_IN
39246: IFFALSE 39632
// begin if not GetDriver ( i ) then
39248: LD_VAR 0 4
39252: PPUSH
39253: CALL 31773 0 1
39257: NOT
39258: IFFALSE 39333
// begin if tmp then
39260: LD_VAR 0 12
39264: IFFALSE 39331
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39266: LD_VAR 0 12
39270: PUSH
39271: LD_INT 1
39273: ARRAY
39274: PPUSH
39275: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39279: LD_VAR 0 12
39283: PUSH
39284: LD_INT 1
39286: ARRAY
39287: PPUSH
39288: LD_VAR 0 4
39292: PPUSH
39293: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39297: LD_VAR 0 12
39301: PUSH
39302: LD_INT 1
39304: ARRAY
39305: PPUSH
39306: LD_INT 36
39308: PPUSH
39309: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39313: LD_ADDR_VAR 0 12
39317: PUSH
39318: LD_VAR 0 12
39322: PPUSH
39323: LD_INT 1
39325: PPUSH
39326: CALL_OW 3
39330: ST_TO_ADDR
// end ; end else
39331: GO 39630
// begin if GetTag ( i ) = 0 then
39333: LD_VAR 0 4
39337: PPUSH
39338: CALL_OW 110
39342: PUSH
39343: LD_INT 0
39345: EQUAL
39346: IFFALSE 39362
// SetTag ( i , 31 ) else
39348: LD_VAR 0 4
39352: PPUSH
39353: LD_INT 31
39355: PPUSH
39356: CALL_OW 109
39360: GO 39630
// if GetTag ( i ) = 31 then
39362: LD_VAR 0 4
39366: PPUSH
39367: CALL_OW 110
39371: PUSH
39372: LD_INT 31
39374: EQUAL
39375: IFFALSE 39630
// begin if GetFuel ( i ) < 20 then
39377: LD_VAR 0 4
39381: PPUSH
39382: CALL_OW 261
39386: PUSH
39387: LD_INT 20
39389: LESS
39390: IFFALSE 39415
// begin SetTag ( i , 21 ) ;
39392: LD_VAR 0 4
39396: PPUSH
39397: LD_INT 21
39399: PPUSH
39400: CALL_OW 109
// MCV_Refuel ( i ) ;
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL 26278 0 1
// continue ;
39413: GO 39245
// end ; if GetLives ( i ) < 700 then
39415: LD_VAR 0 4
39419: PPUSH
39420: CALL_OW 256
39424: PUSH
39425: LD_INT 700
39427: LESS
39428: IFFALSE 39540
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39430: LD_VAR 0 4
39434: PPUSH
39435: LD_EXP 58
39439: PUSH
39440: LD_VAR 0 1
39444: ARRAY
39445: PPUSH
39446: CALL_OW 308
39450: NOT
39451: IFFALSE 39475
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39453: LD_VAR 0 4
39457: PPUSH
39458: LD_EXP 58
39462: PUSH
39463: LD_VAR 0 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 113
39473: GO 39538
// if GetDriver ( i ) then
39475: LD_VAR 0 4
39479: PPUSH
39480: CALL 31773 0 1
39484: IFFALSE 39538
// begin k := GetDriver ( i ) ;
39486: LD_ADDR_VAR 0 8
39490: PUSH
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31773 0 1
39500: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39501: LD_VAR 0 8
39505: PPUSH
39506: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39510: LD_VAR 0 8
39514: PPUSH
39515: LD_VAR 0 4
39519: PPUSH
39520: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39524: LD_VAR 0 8
39528: PPUSH
39529: LD_VAR 0 4
39533: PPUSH
39534: CALL_OW 180
// end ; end else
39538: GO 39630
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39540: LD_ADDR_VAR 0 8
39544: PUSH
39545: LD_VAR 0 1
39549: PPUSH
39550: CALL 25006 0 1
39554: PPUSH
39555: LD_VAR 0 4
39559: PPUSH
39560: CALL_OW 74
39564: ST_TO_ADDR
// if k then
39565: LD_VAR 0 8
39569: IFFALSE 39587
// ComAttackUnit ( i , k ) else
39571: LD_VAR 0 4
39575: PPUSH
39576: LD_VAR 0 8
39580: PPUSH
39581: CALL_OW 115
39585: GO 39630
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_EXP 58
39596: PUSH
39597: LD_VAR 0 1
39601: ARRAY
39602: PPUSH
39603: CALL_OW 308
39607: NOT
39608: IFFALSE 39630
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39610: LD_VAR 0 4
39614: PPUSH
39615: LD_EXP 58
39619: PUSH
39620: LD_VAR 0 1
39624: ARRAY
39625: PPUSH
39626: CALL_OW 113
// end ; end ; end ; end ;
39630: GO 39245
39632: POP
39633: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_INT 30
39641: PUSH
39642: LD_INT 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PPUSH
39649: CALL 11651 0 2
39653: IFFALSE 40471
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39655: LD_ADDR_VAR 0 11
39659: PUSH
39660: LD_VAR 0 1
39664: PPUSH
39665: LD_INT 30
39667: PUSH
39668: LD_INT 5
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PPUSH
39675: CALL 11651 0 2
39679: PUSH
39680: LD_INT 1
39682: ARRAY
39683: ST_TO_ADDR
// if eng > 1 then
39684: LD_VAR 0 14
39688: PUSH
39689: LD_INT 1
39691: GREATER
39692: IFFALSE 39739
// for i = eng downto 2 do
39694: LD_ADDR_VAR 0 4
39698: PUSH
39699: DOUBLE
39700: LD_VAR 0 14
39704: INC
39705: ST_TO_ADDR
39706: LD_INT 2
39708: PUSH
39709: FOR_DOWNTO
39710: IFFALSE 39737
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39712: LD_VAR 0 1
39716: PPUSH
39717: LD_VAR 0 14
39721: PUSH
39722: LD_VAR 0 4
39726: ARRAY
39727: PPUSH
39728: LD_INT 1
39730: PPUSH
39731: CALL 16558 0 3
39735: GO 39709
39737: POP
39738: POP
// if sci > 1 then
39739: LD_VAR 0 16
39743: PUSH
39744: LD_INT 1
39746: GREATER
39747: IFFALSE 39794
// for i = sci downto 2 do
39749: LD_ADDR_VAR 0 4
39753: PUSH
39754: DOUBLE
39755: LD_VAR 0 16
39759: INC
39760: ST_TO_ADDR
39761: LD_INT 2
39763: PUSH
39764: FOR_DOWNTO
39765: IFFALSE 39792
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39767: LD_VAR 0 1
39771: PPUSH
39772: LD_VAR 0 16
39776: PUSH
39777: LD_VAR 0 4
39781: ARRAY
39782: PPUSH
39783: LD_INT 1
39785: PPUSH
39786: CALL 16558 0 3
39790: GO 39764
39792: POP
39793: POP
// if sol then
39794: LD_VAR 0 13
39798: IFFALSE 40471
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39800: LD_VAR 0 13
39804: PUSH
39805: LD_EXP 68
39809: PUSH
39810: LD_VAR 0 1
39814: ARRAY
39815: DIFF
39816: PUSH
39817: LD_INT 22
39819: PUSH
39820: LD_VAR 0 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 58
39831: PUSH
39832: EMPTY
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 32
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 31
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: LIST
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL_OW 69
39872: PUSH
39873: LD_INT 0
39875: EQUAL
39876: AND
39877: IFFALSE 40471
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39879: LD_ADDR_VAR 0 12
39883: PUSH
39884: LD_VAR 0 13
39888: PUSH
39889: LD_EXP 68
39893: PUSH
39894: LD_VAR 0 1
39898: ARRAY
39899: DIFF
39900: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39901: LD_VAR 0 1
39905: PPUSH
39906: LD_INT 30
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PPUSH
39916: CALL 11651 0 2
39920: PUSH
39921: LD_INT 1
39923: GREATER
39924: IFFALSE 39955
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39926: LD_ADDR_VAR 0 8
39930: PUSH
39931: LD_VAR 0 1
39935: PPUSH
39936: LD_INT 30
39938: PUSH
39939: LD_INT 5
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PPUSH
39946: CALL 11651 0 2
39950: PUSH
39951: LD_INT 2
39953: ARRAY
39954: ST_TO_ADDR
// for j in tmp do
39955: LD_ADDR_VAR 0 5
39959: PUSH
39960: LD_VAR 0 12
39964: PUSH
39965: FOR_IN
39966: IFFALSE 40469
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39968: LD_VAR 0 5
39972: PUSH
39973: LD_VAR 0 11
39977: PPUSH
39978: CALL_OW 313
39982: IN
39983: PUSH
39984: LD_VAR 0 11
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: EQUAL
39997: AND
39998: PUSH
39999: LD_VAR 0 8
40003: AND
40004: PUSH
40005: LD_VAR 0 8
40009: PPUSH
40010: CALL_OW 313
40014: PUSH
40015: LD_INT 6
40017: LESS
40018: AND
40019: IFFALSE 40046
// begin ComExitBuilding ( j ) ;
40021: LD_VAR 0 5
40025: PPUSH
40026: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40030: LD_VAR 0 5
40034: PPUSH
40035: LD_VAR 0 8
40039: PPUSH
40040: CALL_OW 180
// continue ;
40044: GO 39965
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40046: LD_VAR 0 5
40050: PPUSH
40051: CALL_OW 314
40055: NOT
40056: PUSH
40057: LD_VAR 0 5
40061: PPUSH
40062: CALL_OW 110
40066: PUSH
40067: LD_INT 0
40069: EQUAL
40070: AND
40071: PUSH
40072: LD_VAR 0 5
40076: PPUSH
40077: CALL_OW 310
40081: NOT
40082: AND
40083: IFFALSE 40189
// begin if k then
40085: LD_VAR 0 8
40089: IFFALSE 40160
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40091: LD_VAR 0 8
40095: PPUSH
40096: CALL_OW 313
40100: PUSH
40101: LD_VAR 0 11
40105: PPUSH
40106: CALL_OW 313
40110: LESS
40111: IFFALSE 40129
// ComEnterUnit ( j , k ) else
40113: LD_VAR 0 5
40117: PPUSH
40118: LD_VAR 0 8
40122: PPUSH
40123: CALL_OW 120
40127: GO 40158
// if UnitsInside ( b ) < 6 then
40129: LD_VAR 0 11
40133: PPUSH
40134: CALL_OW 313
40138: PUSH
40139: LD_INT 6
40141: LESS
40142: IFFALSE 40158
// ComEnterUnit ( j , b ) ;
40144: LD_VAR 0 5
40148: PPUSH
40149: LD_VAR 0 11
40153: PPUSH
40154: CALL_OW 120
// end else
40158: GO 40189
// if UnitsInside ( b ) < 6 then
40160: LD_VAR 0 11
40164: PPUSH
40165: CALL_OW 313
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: IFFALSE 40189
// ComEnterUnit ( j , b ) ;
40175: LD_VAR 0 5
40179: PPUSH
40180: LD_VAR 0 11
40184: PPUSH
40185: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40189: LD_VAR 0 5
40193: PUSH
40194: LD_VAR 0 1
40198: PPUSH
40199: LD_INT 54
40201: PUSH
40202: EMPTY
40203: LIST
40204: PPUSH
40205: CALL 11651 0 2
40209: IN
40210: PUSH
40211: LD_VAR 0 5
40215: PPUSH
40216: CALL_OW 257
40220: PUSH
40221: LD_INT 1
40223: EQUAL
40224: AND
40225: IFFALSE 40467
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40227: LD_EXP 62
40231: PUSH
40232: LD_VAR 0 1
40236: ARRAY
40237: PUSH
40238: LD_INT 1
40240: ARRAY
40241: PUSH
40242: LD_INT 12
40244: PPUSH
40245: LD_VAR 0 1
40249: PPUSH
40250: CALL_OW 321
40254: PUSH
40255: LD_INT 2
40257: EQUAL
40258: AND
40259: IFFALSE 40307
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40261: LD_VAR 0 1
40265: PPUSH
40266: LD_INT 5
40268: PPUSH
40269: EMPTY
40270: PPUSH
40271: CALL 11734 0 3
40275: PUSH
40276: LD_EXP 62
40280: PUSH
40281: LD_VAR 0 1
40285: ARRAY
40286: PUSH
40287: LD_INT 1
40289: ARRAY
40290: LESS
40291: IFFALSE 40307
// begin SetClass ( j , class_sniper ) ;
40293: LD_VAR 0 5
40297: PPUSH
40298: LD_INT 5
40300: PPUSH
40301: CALL_OW 336
// continue ;
40305: GO 39965
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40307: LD_EXP 62
40311: PUSH
40312: LD_VAR 0 1
40316: ARRAY
40317: PUSH
40318: LD_INT 2
40320: ARRAY
40321: PUSH
40322: LD_INT 41
40324: PPUSH
40325: LD_VAR 0 1
40329: PPUSH
40330: CALL_OW 321
40334: PUSH
40335: LD_INT 2
40337: EQUAL
40338: AND
40339: IFFALSE 40387
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40341: LD_VAR 0 1
40345: PPUSH
40346: LD_INT 8
40348: PPUSH
40349: EMPTY
40350: PPUSH
40351: CALL 11734 0 3
40355: PUSH
40356: LD_EXP 62
40360: PUSH
40361: LD_VAR 0 1
40365: ARRAY
40366: PUSH
40367: LD_INT 2
40369: ARRAY
40370: LESS
40371: IFFALSE 40387
// begin SetClass ( j , class_mortar ) ;
40373: LD_VAR 0 5
40377: PPUSH
40378: LD_INT 8
40380: PPUSH
40381: CALL_OW 336
// continue ;
40385: GO 39965
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40387: LD_EXP 62
40391: PUSH
40392: LD_VAR 0 1
40396: ARRAY
40397: PUSH
40398: LD_INT 3
40400: ARRAY
40401: PUSH
40402: LD_INT 44
40404: PPUSH
40405: LD_VAR 0 1
40409: PPUSH
40410: CALL_OW 321
40414: PUSH
40415: LD_INT 2
40417: EQUAL
40418: AND
40419: IFFALSE 40467
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40421: LD_VAR 0 1
40425: PPUSH
40426: LD_INT 9
40428: PPUSH
40429: EMPTY
40430: PPUSH
40431: CALL 11734 0 3
40435: PUSH
40436: LD_EXP 62
40440: PUSH
40441: LD_VAR 0 1
40445: ARRAY
40446: PUSH
40447: LD_INT 3
40449: ARRAY
40450: LESS
40451: IFFALSE 40467
// begin SetClass ( j , class_bazooker ) ;
40453: LD_VAR 0 5
40457: PPUSH
40458: LD_INT 9
40460: PPUSH
40461: CALL_OW 336
// continue ;
40465: GO 39965
// end ; end ; end ;
40467: GO 39965
40469: POP
40470: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40471: LD_INT 22
40473: PUSH
40474: LD_VAR 0 1
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 58
40485: PUSH
40486: EMPTY
40487: LIST
40488: PUSH
40489: LD_INT 30
40491: PUSH
40492: LD_INT 32
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: LIST
40503: PPUSH
40504: CALL_OW 69
40508: IFFALSE 40658
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40510: LD_ADDR_VAR 0 12
40514: PUSH
40515: LD_INT 22
40517: PUSH
40518: LD_VAR 0 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 58
40529: PUSH
40530: EMPTY
40531: LIST
40532: PUSH
40533: LD_INT 30
40535: PUSH
40536: LD_INT 32
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: LIST
40547: PPUSH
40548: CALL_OW 69
40552: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40553: LD_ADDR_VAR 0 8
40557: PUSH
40558: LD_VAR 0 13
40562: PUSH
40563: LD_EXP 68
40567: PUSH
40568: LD_VAR 0 1
40572: ARRAY
40573: DIFF
40574: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40575: LD_VAR 0 12
40579: PUSH
40580: LD_INT 1
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 2
40591: EQUAL
40592: PUSH
40593: LD_VAR 0 12
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_EXP 68
40606: PUSH
40607: LD_VAR 0 1
40611: ARRAY
40612: IN
40613: NOT
40614: AND
40615: PUSH
40616: LD_VAR 0 8
40620: AND
40621: IFFALSE 40658
// begin ComExitBuilding ( k [ 1 ] ) ;
40623: LD_VAR 0 8
40627: PUSH
40628: LD_INT 1
40630: ARRAY
40631: PPUSH
40632: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40636: LD_VAR 0 8
40640: PUSH
40641: LD_INT 1
40643: ARRAY
40644: PPUSH
40645: LD_VAR 0 12
40649: PUSH
40650: LD_INT 1
40652: ARRAY
40653: PPUSH
40654: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40658: LD_EXP 35
40662: PUSH
40663: LD_VAR 0 1
40667: ARRAY
40668: IFFALSE 40816
// begin if MCF_Class ( side , 4 , [ ] ) then
40670: LD_VAR 0 1
40674: PPUSH
40675: LD_INT 4
40677: PPUSH
40678: EMPTY
40679: PPUSH
40680: CALL 11734 0 3
40684: IFFALSE 40814
// for j in MCF_Class ( side , 4 , [ ] ) do
40686: LD_ADDR_VAR 0 5
40690: PUSH
40691: LD_VAR 0 1
40695: PPUSH
40696: LD_INT 4
40698: PPUSH
40699: EMPTY
40700: PPUSH
40701: CALL 11734 0 3
40705: PUSH
40706: FOR_IN
40707: IFFALSE 40812
// begin if not GetTag ( j ) = 4 then
40709: LD_VAR 0 5
40713: PPUSH
40714: CALL_OW 110
40718: PUSH
40719: LD_INT 4
40721: EQUAL
40722: NOT
40723: IFFALSE 40759
// begin SetTag ( j , 4 ) ;
40725: LD_VAR 0 5
40729: PPUSH
40730: LD_INT 4
40732: PPUSH
40733: CALL_OW 109
// if IsInUnit ( j ) then
40737: LD_VAR 0 5
40741: PPUSH
40742: CALL_OW 310
40746: IFFALSE 40757
// ComExitBuilding ( j ) ;
40748: LD_VAR 0 5
40752: PPUSH
40753: CALL_OW 122
// end else
40757: GO 40810
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40759: LD_VAR 0 5
40763: PPUSH
40764: LD_EXP 35
40768: PUSH
40769: LD_VAR 0 1
40773: ARRAY
40774: PUSH
40775: LD_INT 1
40777: ARRAY
40778: PPUSH
40779: CALL 98949 0 2
40783: NOT
40784: IFFALSE 40810
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40786: LD_VAR 0 5
40790: PPUSH
40791: LD_EXP 35
40795: PUSH
40796: LD_VAR 0 1
40800: ARRAY
40801: PUSH
40802: LD_INT 1
40804: ARRAY
40805: PPUSH
40806: CALL 19221 0 2
// end ;
40810: GO 40706
40812: POP
40813: POP
// end else
40814: GO 41048
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40816: LD_VAR 0 1
40820: PPUSH
40821: LD_INT 4
40823: PPUSH
40824: EMPTY
40825: PPUSH
40826: CALL 11734 0 3
40830: PUSH
40831: LD_VAR 0 1
40835: PPUSH
40836: LD_INT 4
40838: PPUSH
40839: EMPTY
40840: PPUSH
40841: CALL 12354 0 3
40845: AND
40846: IFFALSE 41048
// for j in MCF_Class ( side , 4 , [ ] ) do
40848: LD_ADDR_VAR 0 5
40852: PUSH
40853: LD_VAR 0 1
40857: PPUSH
40858: LD_INT 4
40860: PPUSH
40861: EMPTY
40862: PPUSH
40863: CALL 11734 0 3
40867: PUSH
40868: FOR_IN
40869: IFFALSE 41046
// begin if GetTag ( j ) = 4 then
40871: LD_VAR 0 5
40875: PPUSH
40876: CALL_OW 110
40880: PUSH
40881: LD_INT 4
40883: EQUAL
40884: IFFALSE 41044
// begin SetTag ( j , 0 ) ;
40886: LD_VAR 0 5
40890: PPUSH
40891: LD_INT 0
40893: PPUSH
40894: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40898: LD_VAR 0 1
40902: PPUSH
40903: CALL 11690 0 1
40907: PUSH
40908: LD_VAR 0 1
40912: PPUSH
40913: CALL 18034 0 1
40917: NOT
40918: AND
40919: IFFALSE 40944
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40921: LD_VAR 0 5
40925: PPUSH
40926: LD_VAR 0 1
40930: PPUSH
40931: CALL 11690 0 1
40935: PUSH
40936: LD_INT 1
40938: ARRAY
40939: PPUSH
40940: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40944: LD_VAR 0 1
40948: PPUSH
40949: CALL 11690 0 1
40953: NOT
40954: PUSH
40955: LD_VAR 0 1
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL 11651 0 2
40974: AND
40975: IFFALSE 41044
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40977: LD_VAR 0 5
40981: PPUSH
40982: LD_VAR 0 1
40986: PPUSH
40987: LD_INT 30
40989: PUSH
40990: LD_INT 1
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PPUSH
40997: CALL 11651 0 2
41001: PUSH
41002: LD_INT 1
41004: ARRAY
41005: PPUSH
41006: CALL_OW 250
41010: PPUSH
41011: LD_VAR 0 1
41015: PPUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PPUSH
41026: CALL 11651 0 2
41030: PUSH
41031: LD_INT 1
41033: ARRAY
41034: PPUSH
41035: CALL_OW 251
41039: PPUSH
41040: CALL_OW 111
// end ; end ;
41044: GO 40868
41046: POP
41047: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41048: LD_VAR 0 1
41052: PPUSH
41053: LD_INT 3
41055: PPUSH
41056: EMPTY
41057: PPUSH
41058: CALL 11734 0 3
41062: PUSH
41063: LD_EXP 58
41067: PUSH
41068: LD_VAR 0 1
41072: ARRAY
41073: AND
41074: PUSH
41075: LD_VAR 0 1
41079: PPUSH
41080: LD_INT 6
41082: PPUSH
41083: EMPTY
41084: PPUSH
41085: CALL 12354 0 3
41089: AND
41090: IFFALSE 41621
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41092: LD_ADDR_VAR 0 6
41096: PUSH
41097: LD_EXP 58
41101: PUSH
41102: LD_VAR 0 1
41106: ARRAY
41107: PPUSH
41108: LD_INT 0
41110: PPUSH
41111: CALL_OW 517
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 1
41122: ARRAY
41123: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41124: LD_ADDR_VAR 0 7
41128: PUSH
41129: LD_EXP 58
41133: PUSH
41134: LD_VAR 0 1
41138: ARRAY
41139: PPUSH
41140: LD_INT 0
41142: PPUSH
41143: CALL_OW 517
41147: PUSH
41148: LD_INT 2
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41156: LD_VAR 0 1
41160: PPUSH
41161: LD_INT 6
41163: PPUSH
41164: EMPTY
41165: PPUSH
41166: CALL 12354 0 3
41170: IFFALSE 41619
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 1
41181: PPUSH
41182: LD_INT 6
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL 12354 0 3
41191: PUSH
41192: FOR_IN
41193: IFFALSE 41224
// if GetLives ( k ) = 1000 then
41195: LD_VAR 0 8
41199: PPUSH
41200: CALL_OW 256
41204: PUSH
41205: LD_INT 1000
41207: EQUAL
41208: IFFALSE 41222
// SetTag ( k , 0 ) ;
41210: LD_VAR 0 8
41214: PPUSH
41215: LD_INT 0
41217: PPUSH
41218: CALL_OW 109
41222: GO 41192
41224: POP
41225: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41226: LD_VAR 0 1
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: LD_INT 25
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PPUSH
41244: CALL 12354 0 3
41248: IFFALSE 41312
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41250: LD_ADDR_VAR 0 8
41254: PUSH
41255: LD_VAR 0 4
41259: PPUSH
41260: LD_INT 0
41262: PPUSH
41263: LD_INT 25
41265: PUSH
41266: LD_INT 3
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PPUSH
41273: CALL 12354 0 3
41277: PUSH
41278: FOR_IN
41279: IFFALSE 41310
// if GetTag ( k ) = 0 then
41281: LD_VAR 0 8
41285: PPUSH
41286: CALL_OW 110
41290: PUSH
41291: LD_INT 0
41293: EQUAL
41294: IFFALSE 41308
// begin SetTag ( k , 8 ) ;
41296: LD_VAR 0 8
41300: PPUSH
41301: LD_INT 8
41303: PPUSH
41304: CALL_OW 109
// end ;
41308: GO 41278
41310: POP
41311: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41312: LD_VAR 0 1
41316: PPUSH
41317: LD_INT 6
41319: PPUSH
41320: LD_INT 92
41322: PUSH
41323: LD_VAR 0 6
41327: PUSH
41328: LD_VAR 0 7
41332: PUSH
41333: LD_INT 10
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: LIST
41341: PPUSH
41342: CALL 12354 0 3
41346: IFFALSE 41470
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41348: LD_ADDR_VAR 0 5
41352: PUSH
41353: LD_VAR 0 4
41357: PPUSH
41358: LD_INT 6
41360: PPUSH
41361: LD_INT 92
41363: PUSH
41364: LD_VAR 0 6
41368: PUSH
41369: LD_VAR 0 7
41373: PUSH
41374: LD_INT 10
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: LIST
41381: LIST
41382: PPUSH
41383: CALL 12354 0 3
41387: PUSH
41388: FOR_IN
41389: IFFALSE 41468
// begin if not HasTask ( j ) and GetDriver ( j ) then
41391: LD_VAR 0 5
41395: PPUSH
41396: CALL_OW 314
41400: NOT
41401: PUSH
41402: LD_VAR 0 5
41406: PPUSH
41407: CALL 31773 0 1
41411: AND
41412: IFFALSE 41466
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41414: LD_VAR 0 5
41418: PPUSH
41419: CALL 31773 0 1
41423: PPUSH
41424: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41428: LD_VAR 0 5
41432: PPUSH
41433: CALL 31773 0 1
41437: PPUSH
41438: LD_VAR 0 5
41442: PPUSH
41443: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41447: LD_VAR 0 5
41451: PPUSH
41452: CALL 31773 0 1
41456: PPUSH
41457: LD_VAR 0 5
41461: PPUSH
41462: CALL_OW 180
// end ; end ;
41466: GO 41388
41468: POP
41469: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41470: LD_VAR 0 1
41474: PPUSH
41475: LD_INT 6
41477: PPUSH
41478: LD_INT 92
41480: PUSH
41481: LD_VAR 0 6
41485: PUSH
41486: LD_VAR 0 7
41490: PUSH
41491: LD_INT 10
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: PPUSH
41500: CALL 12354 0 3
41504: PUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 8
41512: PPUSH
41513: EMPTY
41514: PPUSH
41515: CALL 12354 0 3
41519: AND
41520: IFFALSE 41619
// for j in MCF_Tag ( side , 8 , [ ] ) do
41522: LD_ADDR_VAR 0 5
41526: PUSH
41527: LD_VAR 0 1
41531: PPUSH
41532: LD_INT 8
41534: PPUSH
41535: EMPTY
41536: PPUSH
41537: CALL 12354 0 3
41541: PUSH
41542: FOR_IN
41543: IFFALSE 41617
// begin if IsInUnit ( j ) then
41545: LD_VAR 0 5
41549: PPUSH
41550: CALL_OW 310
41554: IFFALSE 41567
// ComExitBuilding ( j ) else
41556: LD_VAR 0 5
41560: PPUSH
41561: CALL_OW 122
41565: GO 41615
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41567: LD_VAR 0 5
41571: PPUSH
41572: LD_VAR 0 1
41576: PPUSH
41577: LD_INT 6
41579: PPUSH
41580: LD_INT 92
41582: PUSH
41583: LD_VAR 0 6
41587: PUSH
41588: LD_VAR 0 7
41592: PUSH
41593: LD_INT 10
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: PPUSH
41602: CALL 12354 0 3
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PPUSH
41611: CALL_OW 129
// end ;
41615: GO 41542
41617: POP
41618: POP
// end ; end else
41619: GO 41676
// if MCF_Tag ( side , 8 , [ ] ) then
41621: LD_VAR 0 1
41625: PPUSH
41626: LD_INT 8
41628: PPUSH
41629: EMPTY
41630: PPUSH
41631: CALL 12354 0 3
41635: IFFALSE 41676
// for k in MCF_Tag ( side , 8 , [ ] ) do
41637: LD_ADDR_VAR 0 8
41641: PUSH
41642: LD_VAR 0 1
41646: PPUSH
41647: LD_INT 8
41649: PPUSH
41650: EMPTY
41651: PPUSH
41652: CALL 12354 0 3
41656: PUSH
41657: FOR_IN
41658: IFFALSE 41674
// SetTag ( k , 0 ) ;
41660: LD_VAR 0 8
41664: PPUSH
41665: LD_INT 0
41667: PPUSH
41668: CALL_OW 109
41672: GO 41657
41674: POP
41675: POP
// end ; end_of_file
41676: LD_VAR 0 3
41680: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41681: LD_INT 0
41683: PPUSH
// MREG_Game := [ ] ;
41684: LD_ADDR_EXP 33
41688: PUSH
41689: EMPTY
41690: ST_TO_ADDR
// MREG_Crates := [ ] ;
41691: LD_ADDR_EXP 34
41695: PUSH
41696: EMPTY
41697: ST_TO_ADDR
// MREG_Heal := [ ] ;
41698: LD_ADDR_EXP 35
41702: PUSH
41703: EMPTY
41704: ST_TO_ADDR
// MREG_Tame := [ ] ;
41705: LD_ADDR_EXP 37
41709: PUSH
41710: EMPTY
41711: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41712: LD_ADDR_EXP 38
41716: PUSH
41717: EMPTY
41718: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41719: LD_ADDR_EXP 39
41723: PUSH
41724: EMPTY
41725: ST_TO_ADDR
// MREG_LabList := [ ] ;
41726: LD_ADDR_EXP 40
41730: PUSH
41731: EMPTY
41732: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41733: LD_ADDR_EXP 41
41737: PUSH
41738: EMPTY
41739: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41740: LD_ADDR_EXP 42
41744: PUSH
41745: EMPTY
41746: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41747: LD_ADDR_EXP 43
41751: PUSH
41752: EMPTY
41753: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41754: LD_ADDR_EXP 44
41758: PUSH
41759: EMPTY
41760: ST_TO_ADDR
// MREG_Status := [ ] ;
41761: LD_ADDR_EXP 45
41765: PUSH
41766: EMPTY
41767: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41768: LD_ADDR_EXP 46
41772: PUSH
41773: EMPTY
41774: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41775: LD_ADDR_EXP 47
41779: PUSH
41780: EMPTY
41781: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41782: LD_ADDR_EXP 48
41786: PUSH
41787: EMPTY
41788: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41789: LD_ADDR_EXP 49
41793: PUSH
41794: EMPTY
41795: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41796: LD_ADDR_EXP 50
41800: PUSH
41801: EMPTY
41802: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41803: LD_ADDR_EXP 51
41807: PUSH
41808: EMPTY
41809: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41810: LD_ADDR_EXP 52
41814: PUSH
41815: EMPTY
41816: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41817: LD_ADDR_EXP 53
41821: PUSH
41822: EMPTY
41823: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41824: LD_ADDR_EXP 54
41828: PUSH
41829: EMPTY
41830: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41831: LD_ADDR_EXP 55
41835: PUSH
41836: EMPTY
41837: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41838: LD_ADDR_EXP 56
41842: PUSH
41843: EMPTY
41844: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41845: LD_ADDR_EXP 57
41849: PUSH
41850: EMPTY
41851: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41852: LD_ADDR_EXP 61
41856: PUSH
41857: EMPTY
41858: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41859: LD_ADDR_EXP 62
41863: PUSH
41864: EMPTY
41865: ST_TO_ADDR
// MREG_Parking := [ ] ;
41866: LD_ADDR_EXP 58
41870: PUSH
41871: EMPTY
41872: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41873: LD_ADDR_EXP 59
41877: PUSH
41878: EMPTY
41879: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41880: LD_ADDR_EXP 63
41884: PUSH
41885: EMPTY
41886: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41887: LD_ADDR_EXP 64
41891: PUSH
41892: EMPTY
41893: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41894: LD_ADDR_EXP 65
41898: PUSH
41899: EMPTY
41900: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41901: LD_ADDR_EXP 67
41905: PUSH
41906: EMPTY
41907: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41908: LD_ADDR_EXP 68
41912: PUSH
41913: EMPTY
41914: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41915: LD_ADDR_EXP 69
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41922: LD_ADDR_EXP 71
41926: PUSH
41927: EMPTY
41928: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41929: LD_ADDR_EXP 70
41933: PUSH
41934: EMPTY
41935: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41936: LD_ADDR_EXP 72
41940: PUSH
41941: LD_INT 300
41943: PUSH
41944: LD_INT 100
41946: PUSH
41947: LD_INT 25
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: ST_TO_ADDR
// end ;
41955: LD_VAR 0 1
41959: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41960: LD_INT 0
41962: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41963: LD_VAR 0 2
41967: PUSH
41968: LD_VAR 0 3
41972: PUSH
41973: LD_VAR 0 4
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: LIST
41982: PUSH
41983: LD_VAR 0 1
41987: IN
41988: IFFALSE 42002
// result := mreg_list else
41990: LD_ADDR_VAR 0 5
41994: PUSH
41995: LD_VAR 0 1
41999: ST_TO_ADDR
42000: GO 42036
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42002: LD_ADDR_VAR 0 1
42006: PUSH
42007: LD_VAR 0 1
42011: PUSH
42012: LD_VAR 0 2
42016: PUSH
42017: LD_VAR 0 3
42021: PUSH
42022: LD_VAR 0 4
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: PUSH
42032: EMPTY
42033: LIST
42034: ADD
42035: ST_TO_ADDR
// result := mreg_list ;
42036: LD_ADDR_VAR 0 5
42040: PUSH
42041: LD_VAR 0 1
42045: ST_TO_ADDR
// end ;
42046: LD_VAR 0 5
42050: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42051: LD_INT 0
42053: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42054: LD_VAR 0 2
42058: PUSH
42059: LD_VAR 0 3
42063: PUSH
42064: LD_VAR 0 4
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: LIST
42073: PUSH
42074: LD_VAR 0 1
42078: IN
42079: IFFALSE 42117
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42081: LD_ADDR_VAR 0 5
42085: PUSH
42086: LD_VAR 0 1
42090: PUSH
42091: LD_VAR 0 2
42095: PUSH
42096: LD_VAR 0 3
42100: PUSH
42101: LD_VAR 0 4
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: DIFF
42114: ST_TO_ADDR
42115: GO 42127
// result := mreg_list ;
42117: LD_ADDR_VAR 0 5
42121: PUSH
42122: LD_VAR 0 1
42126: ST_TO_ADDR
// end ;
42127: LD_VAR 0 5
42131: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42132: LD_INT 0
42134: PPUSH
42135: PPUSH
42136: PPUSH
// for j = 1 to 8 do
42137: LD_ADDR_VAR 0 3
42141: PUSH
42142: DOUBLE
42143: LD_INT 1
42145: DEC
42146: ST_TO_ADDR
42147: LD_INT 8
42149: PUSH
42150: FOR_TO
42151: IFFALSE 42992
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42153: LD_VAR 0 3
42157: PPUSH
42158: LD_INT 51
42160: PUSH
42161: EMPTY
42162: LIST
42163: PPUSH
42164: CALL 11651 0 2
42168: PUSH
42169: LD_OWVAR 2
42173: PUSH
42174: LD_VAR 0 3
42178: EQUAL
42179: NOT
42180: AND
42181: IFFALSE 42199
// MREG_SidesList := MREG_SidesList ^ 1 else
42183: LD_ADDR_EXP 39
42187: PUSH
42188: LD_EXP 39
42192: PUSH
42193: LD_INT 1
42195: ADD
42196: ST_TO_ADDR
42197: GO 42213
// MREG_SidesList := MREG_SidesList ^ 0 ;
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 0
42211: ADD
42212: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42213: LD_VAR 0 3
42217: PPUSH
42218: LD_INT 2
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 12
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 34
42233: PUSH
42234: LD_INT 32
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 34
42243: PUSH
42244: LD_INT 51
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: PUSH
42257: EMPTY
42258: LIST
42259: PPUSH
42260: CALL 11952 0 2
42264: IFFALSE 42365
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42266: LD_ADDR_VAR 0 2
42270: PUSH
42271: LD_VAR 0 3
42275: PPUSH
42276: LD_INT 2
42278: PUSH
42279: LD_INT 34
42281: PUSH
42282: LD_INT 12
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 34
42291: PUSH
42292: LD_INT 32
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 34
42301: PUSH
42302: LD_INT 51
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: LIST
42317: PPUSH
42318: CALL 11952 0 2
42322: PUSH
42323: FOR_IN
42324: IFFALSE 42363
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42326: LD_ADDR_EXP 41
42330: PUSH
42331: LD_EXP 41
42335: PPUSH
42336: LD_VAR 0 3
42340: PPUSH
42341: LD_VAR 0 2
42345: PPUSH
42346: LD_VAR 0 2
42350: PPUSH
42351: CALL_OW 264
42355: PPUSH
42356: CALL 41960 0 4
42360: ST_TO_ADDR
42361: GO 42323
42363: POP
42364: POP
// if MCF_Class ( j , 4 , [ ] ) then
42365: LD_VAR 0 3
42369: PPUSH
42370: LD_INT 4
42372: PPUSH
42373: EMPTY
42374: PPUSH
42375: CALL 11734 0 3
42379: IFFALSE 42412
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42381: LD_ADDR_EXP 54
42385: PUSH
42386: LD_EXP 54
42390: PUSH
42391: LD_VAR 0 3
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: EMPTY
42400: PPUSH
42401: CALL 11734 0 3
42405: PUSH
42406: EMPTY
42407: LIST
42408: ADD
42409: ST_TO_ADDR
42410: GO 42429
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42412: LD_ADDR_EXP 54
42416: PUSH
42417: LD_EXP 54
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: ADD
42428: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42429: LD_VAR 0 3
42433: PPUSH
42434: LD_INT 3
42436: PPUSH
42437: EMPTY
42438: PPUSH
42439: CALL 11734 0 3
42443: IFFALSE 42476
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42445: LD_ADDR_EXP 55
42449: PUSH
42450: LD_EXP 55
42454: PUSH
42455: LD_VAR 0 3
42459: PPUSH
42460: LD_INT 3
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL 11734 0 3
42469: PUSH
42470: EMPTY
42471: LIST
42472: ADD
42473: ST_TO_ADDR
42474: GO 42493
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42476: LD_ADDR_EXP 55
42480: PUSH
42481: LD_EXP 55
42485: PUSH
42486: LD_INT 0
42488: PUSH
42489: EMPTY
42490: LIST
42491: ADD
42492: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42493: LD_VAR 0 3
42497: PPUSH
42498: LD_INT 1
42500: PPUSH
42501: EMPTY
42502: PPUSH
42503: CALL 11734 0 3
42507: IFFALSE 42540
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42509: LD_ADDR_EXP 56
42513: PUSH
42514: LD_EXP 56
42518: PUSH
42519: LD_VAR 0 3
42523: PPUSH
42524: LD_INT 1
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 11734 0 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: ADD
42537: ST_TO_ADDR
42538: GO 42557
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42540: LD_ADDR_EXP 56
42544: PUSH
42545: LD_EXP 56
42549: PUSH
42550: LD_INT 0
42552: PUSH
42553: EMPTY
42554: LIST
42555: ADD
42556: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42557: LD_VAR 0 3
42561: PPUSH
42562: LD_INT 2
42564: PPUSH
42565: EMPTY
42566: PPUSH
42567: CALL 11734 0 3
42571: IFFALSE 42604
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42573: LD_ADDR_EXP 57
42577: PUSH
42578: LD_EXP 57
42582: PUSH
42583: LD_VAR 0 3
42587: PPUSH
42588: LD_INT 2
42590: PPUSH
42591: EMPTY
42592: PPUSH
42593: CALL 11734 0 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: ADD
42601: ST_TO_ADDR
42602: GO 42621
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42604: LD_ADDR_EXP 57
42608: PUSH
42609: LD_EXP 57
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: EMPTY
42618: LIST
42619: ADD
42620: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42621: LD_ADDR_EXP 47
42625: PUSH
42626: LD_EXP 47
42630: PUSH
42631: LD_INT 0
42633: PUSH
42634: EMPTY
42635: LIST
42636: ADD
42637: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42638: LD_ADDR_EXP 35
42642: PUSH
42643: LD_EXP 35
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: ADD
42654: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42655: LD_ADDR_EXP 37
42659: PUSH
42660: LD_EXP 37
42664: PUSH
42665: LD_INT 0
42667: PUSH
42668: EMPTY
42669: LIST
42670: ADD
42671: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42672: LD_ADDR_EXP 58
42676: PUSH
42677: LD_EXP 58
42681: PUSH
42682: LD_INT 0
42684: PUSH
42685: EMPTY
42686: LIST
42687: ADD
42688: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42689: LD_ADDR_EXP 59
42693: PUSH
42694: LD_EXP 59
42698: PUSH
42699: LD_INT 0
42701: PUSH
42702: EMPTY
42703: LIST
42704: ADD
42705: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42706: LD_ADDR_EXP 51
42710: PUSH
42711: LD_EXP 51
42715: PUSH
42716: LD_INT 0
42718: PUSH
42719: EMPTY
42720: LIST
42721: ADD
42722: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42723: LD_ADDR_EXP 38
42727: PUSH
42728: LD_EXP 38
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: LD_INT 0
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: ADD
42754: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42755: LD_ADDR_EXP 60
42759: PUSH
42760: LD_EXP 60
42764: PUSH
42765: LD_INT 0
42767: PUSH
42768: EMPTY
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: ADD
42777: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42778: LD_ADDR_EXP 61
42782: PUSH
42783: LD_EXP 61
42787: PUSH
42788: LD_INT 0
42790: PUSH
42791: EMPTY
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: ADD
42797: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42798: LD_ADDR_EXP 42
42802: PUSH
42803: LD_EXP 42
42807: PUSH
42808: LD_INT 0
42810: PUSH
42811: EMPTY
42812: LIST
42813: ADD
42814: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42815: LD_ADDR_EXP 63
42819: PUSH
42820: LD_EXP 63
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: EMPTY
42829: LIST
42830: ADD
42831: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42832: LD_ADDR_EXP 64
42836: PUSH
42837: LD_EXP 64
42841: PUSH
42842: LD_INT 0
42844: PUSH
42845: EMPTY
42846: LIST
42847: ADD
42848: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42849: LD_ADDR_EXP 65
42853: PUSH
42854: LD_EXP 65
42858: PUSH
42859: LD_INT 0
42861: PUSH
42862: EMPTY
42863: LIST
42864: ADD
42865: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42866: LD_ADDR_EXP 66
42870: PUSH
42871: LD_EXP 66
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: ADD
42882: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42883: LD_ADDR_EXP 67
42887: PUSH
42888: LD_EXP 67
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: ADD
42899: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42900: LD_ADDR_EXP 68
42904: PUSH
42905: LD_EXP 68
42909: PUSH
42910: LD_INT 0
42912: PUSH
42913: EMPTY
42914: LIST
42915: ADD
42916: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42917: LD_ADDR_EXP 69
42921: PUSH
42922: LD_EXP 69
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: EMPTY
42931: LIST
42932: ADD
42933: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42934: LD_ADDR_EXP 71
42938: PUSH
42939: LD_EXP 71
42943: PUSH
42944: LD_INT 0
42946: PUSH
42947: EMPTY
42948: LIST
42949: ADD
42950: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42951: LD_ADDR_EXP 70
42955: PUSH
42956: LD_EXP 70
42960: PUSH
42961: LD_INT 0
42963: ADD
42964: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42965: LD_ADDR_EXP 62
42969: PUSH
42970: LD_EXP 62
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 0
42980: PUSH
42981: LD_INT 0
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ADD
42989: ST_TO_ADDR
// end ;
42990: GO 42150
42992: POP
42993: POP
// end ;
42994: LD_VAR 0 1
42998: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42999: LD_INT 0
43001: PPUSH
43002: PPUSH
43003: PPUSH
// m := false ;
43004: LD_ADDR_VAR 0 5
43008: PUSH
43009: LD_INT 0
43011: ST_TO_ADDR
// for i = 1 to mreg do
43012: LD_ADDR_VAR 0 4
43016: PUSH
43017: DOUBLE
43018: LD_INT 1
43020: DEC
43021: ST_TO_ADDR
43022: LD_VAR 0 2
43026: PUSH
43027: FOR_TO
43028: IFFALSE 43064
// if mreg [ i ] [ 1 ] = side then
43030: LD_VAR 0 2
43034: PUSH
43035: LD_VAR 0 4
43039: ARRAY
43040: PUSH
43041: LD_INT 1
43043: ARRAY
43044: PUSH
43045: LD_VAR 0 1
43049: EQUAL
43050: IFFALSE 43062
// begin m := true ;
43052: LD_ADDR_VAR 0 5
43056: PUSH
43057: LD_INT 1
43059: ST_TO_ADDR
// break ;
43060: GO 43064
// end ;
43062: GO 43027
43064: POP
43065: POP
// result := m ;
43066: LD_ADDR_VAR 0 3
43070: PUSH
43071: LD_VAR 0 5
43075: ST_TO_ADDR
// end ;
43076: LD_VAR 0 3
43080: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43081: LD_INT 0
43083: PPUSH
43084: PPUSH
43085: PPUSH
// m := 0 ;
43086: LD_ADDR_VAR 0 5
43090: PUSH
43091: LD_INT 0
43093: ST_TO_ADDR
// for i = 1 to mreg do
43094: LD_ADDR_VAR 0 4
43098: PUSH
43099: DOUBLE
43100: LD_INT 1
43102: DEC
43103: ST_TO_ADDR
43104: LD_VAR 0 2
43108: PUSH
43109: FOR_TO
43110: IFFALSE 43150
// if mreg [ i ] [ 1 ] = side then
43112: LD_VAR 0 2
43116: PUSH
43117: LD_VAR 0 4
43121: ARRAY
43122: PUSH
43123: LD_INT 1
43125: ARRAY
43126: PUSH
43127: LD_VAR 0 1
43131: EQUAL
43132: IFFALSE 43148
// begin m := m + 1 ;
43134: LD_ADDR_VAR 0 5
43138: PUSH
43139: LD_VAR 0 5
43143: PUSH
43144: LD_INT 1
43146: PLUS
43147: ST_TO_ADDR
// end ;
43148: GO 43109
43150: POP
43151: POP
// result := m ;
43152: LD_ADDR_VAR 0 3
43156: PUSH
43157: LD_VAR 0 5
43161: ST_TO_ADDR
// end ;
43162: LD_VAR 0 3
43166: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43167: LD_INT 0
43169: PPUSH
43170: PPUSH
// result := 0 ;
43171: LD_ADDR_VAR 0 3
43175: PUSH
43176: LD_INT 0
43178: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43179: LD_ADDR_VAR 0 4
43183: PUSH
43184: DOUBLE
43185: LD_INT 1
43187: DEC
43188: ST_TO_ADDR
43189: LD_EXP 53
43193: PUSH
43194: FOR_TO
43195: IFFALSE 43257
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43197: LD_EXP 53
43201: PUSH
43202: LD_VAR 0 4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PUSH
43212: LD_VAR 0 1
43216: EQUAL
43217: PUSH
43218: LD_EXP 53
43222: PUSH
43223: LD_VAR 0 4
43227: ARRAY
43228: PUSH
43229: LD_INT 2
43231: ARRAY
43232: PUSH
43233: LD_VAR 0 2
43237: EQUAL
43238: AND
43239: IFFALSE 43255
// begin result := result + 1 ;
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 3
43250: PUSH
43251: LD_INT 1
43253: PLUS
43254: ST_TO_ADDR
// end ;
43255: GO 43194
43257: POP
43258: POP
// end ; end_of_file end_of_file
43259: LD_VAR 0 3
43263: RET
// export globalGameSaveCounter ; every 0 0$1 do
43264: GO 43266
43266: DISABLE
// begin enable ;
43267: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43268: LD_STRING updateTimer(
43270: PUSH
43271: LD_OWVAR 1
43275: STR
43276: PUSH
43277: LD_STRING );
43279: STR
43280: PPUSH
43281: CALL_OW 559
// end ;
43285: END
// every 0 0$1 do
43286: GO 43288
43288: DISABLE
// begin globalGameSaveCounter := 0 ;
43289: LD_ADDR_EXP 73
43293: PUSH
43294: LD_INT 0
43296: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
43297: LD_STRING setGameSaveCounter(0)
43299: PPUSH
43300: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
43304: LD_STRING initStreamRollete();
43306: PPUSH
43307: CALL_OW 559
// InitStreamMode ;
43311: CALL 44654 0 0
// DefineStreamItems ( false ) ;
43315: LD_INT 0
43317: PPUSH
43318: CALL 45118 0 1
// end ;
43322: END
// export function SOS_MapStart ( ) ; begin
43323: LD_INT 0
43325: PPUSH
// if streamModeActive then
43326: LD_EXP 74
43330: IFFALSE 43339
// DefineStreamItems ( true ) ;
43332: LD_INT 1
43334: PPUSH
43335: CALL 45118 0 1
// UpdateLuaVariables ( ) ;
43339: CALL 43356 0 0
// UpdateFactoryWaypoints ( ) ;
43343: CALL 57987 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43347: CALL 58244 0 0
// end ;
43351: LD_VAR 0 1
43355: RET
// function UpdateLuaVariables ( ) ; begin
43356: LD_INT 0
43358: PPUSH
// if globalGameSaveCounter then
43359: LD_EXP 73
43363: IFFALSE 43397
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
43365: LD_ADDR_EXP 73
43369: PUSH
43370: LD_EXP 73
43374: PPUSH
43375: CALL 103029 0 1
43379: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
43380: LD_STRING setGameSaveCounter(
43382: PUSH
43383: LD_EXP 73
43387: STR
43388: PUSH
43389: LD_STRING )
43391: STR
43392: PPUSH
43393: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
43397: LD_STRING setGameDifficulty(
43399: PUSH
43400: LD_OWVAR 67
43404: STR
43405: PUSH
43406: LD_STRING )
43408: STR
43409: PPUSH
43410: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
43414: LD_STRING displayDifficulty(
43416: PUSH
43417: LD_OWVAR 67
43421: STR
43422: PUSH
43423: LD_STRING )
43425: STR
43426: PPUSH
43427: CALL_OW 559
// end ;
43431: LD_VAR 0 1
43435: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43436: LD_INT 0
43438: PPUSH
// if p2 = stream_mode then
43439: LD_VAR 0 2
43443: PUSH
43444: LD_INT 100
43446: EQUAL
43447: IFFALSE 44450
// begin if not StreamModeActive then
43449: LD_EXP 74
43453: NOT
43454: IFFALSE 43464
// StreamModeActive := true ;
43456: LD_ADDR_EXP 74
43460: PUSH
43461: LD_INT 1
43463: ST_TO_ADDR
// if p3 = 0 then
43464: LD_VAR 0 3
43468: PUSH
43469: LD_INT 0
43471: EQUAL
43472: IFFALSE 43478
// InitStreamMode ;
43474: CALL 44654 0 0
// if p3 = 1 then
43478: LD_VAR 0 3
43482: PUSH
43483: LD_INT 1
43485: EQUAL
43486: IFFALSE 43496
// sRocket := true ;
43488: LD_ADDR_EXP 79
43492: PUSH
43493: LD_INT 1
43495: ST_TO_ADDR
// if p3 = 2 then
43496: LD_VAR 0 3
43500: PUSH
43501: LD_INT 2
43503: EQUAL
43504: IFFALSE 43514
// sSpeed := true ;
43506: LD_ADDR_EXP 78
43510: PUSH
43511: LD_INT 1
43513: ST_TO_ADDR
// if p3 = 3 then
43514: LD_VAR 0 3
43518: PUSH
43519: LD_INT 3
43521: EQUAL
43522: IFFALSE 43532
// sEngine := true ;
43524: LD_ADDR_EXP 80
43528: PUSH
43529: LD_INT 1
43531: ST_TO_ADDR
// if p3 = 4 then
43532: LD_VAR 0 3
43536: PUSH
43537: LD_INT 4
43539: EQUAL
43540: IFFALSE 43550
// sSpec := true ;
43542: LD_ADDR_EXP 77
43546: PUSH
43547: LD_INT 1
43549: ST_TO_ADDR
// if p3 = 5 then
43550: LD_VAR 0 3
43554: PUSH
43555: LD_INT 5
43557: EQUAL
43558: IFFALSE 43568
// sLevel := true ;
43560: LD_ADDR_EXP 81
43564: PUSH
43565: LD_INT 1
43567: ST_TO_ADDR
// if p3 = 6 then
43568: LD_VAR 0 3
43572: PUSH
43573: LD_INT 6
43575: EQUAL
43576: IFFALSE 43586
// sArmoury := true ;
43578: LD_ADDR_EXP 82
43582: PUSH
43583: LD_INT 1
43585: ST_TO_ADDR
// if p3 = 7 then
43586: LD_VAR 0 3
43590: PUSH
43591: LD_INT 7
43593: EQUAL
43594: IFFALSE 43604
// sRadar := true ;
43596: LD_ADDR_EXP 83
43600: PUSH
43601: LD_INT 1
43603: ST_TO_ADDR
// if p3 = 8 then
43604: LD_VAR 0 3
43608: PUSH
43609: LD_INT 8
43611: EQUAL
43612: IFFALSE 43622
// sBunker := true ;
43614: LD_ADDR_EXP 84
43618: PUSH
43619: LD_INT 1
43621: ST_TO_ADDR
// if p3 = 9 then
43622: LD_VAR 0 3
43626: PUSH
43627: LD_INT 9
43629: EQUAL
43630: IFFALSE 43640
// sHack := true ;
43632: LD_ADDR_EXP 85
43636: PUSH
43637: LD_INT 1
43639: ST_TO_ADDR
// if p3 = 10 then
43640: LD_VAR 0 3
43644: PUSH
43645: LD_INT 10
43647: EQUAL
43648: IFFALSE 43658
// sFire := true ;
43650: LD_ADDR_EXP 86
43654: PUSH
43655: LD_INT 1
43657: ST_TO_ADDR
// if p3 = 11 then
43658: LD_VAR 0 3
43662: PUSH
43663: LD_INT 11
43665: EQUAL
43666: IFFALSE 43676
// sRefresh := true ;
43668: LD_ADDR_EXP 87
43672: PUSH
43673: LD_INT 1
43675: ST_TO_ADDR
// if p3 = 12 then
43676: LD_VAR 0 3
43680: PUSH
43681: LD_INT 12
43683: EQUAL
43684: IFFALSE 43694
// sExp := true ;
43686: LD_ADDR_EXP 88
43690: PUSH
43691: LD_INT 1
43693: ST_TO_ADDR
// if p3 = 13 then
43694: LD_VAR 0 3
43698: PUSH
43699: LD_INT 13
43701: EQUAL
43702: IFFALSE 43712
// sDepot := true ;
43704: LD_ADDR_EXP 89
43708: PUSH
43709: LD_INT 1
43711: ST_TO_ADDR
// if p3 = 14 then
43712: LD_VAR 0 3
43716: PUSH
43717: LD_INT 14
43719: EQUAL
43720: IFFALSE 43730
// sFlag := true ;
43722: LD_ADDR_EXP 90
43726: PUSH
43727: LD_INT 1
43729: ST_TO_ADDR
// if p3 = 15 then
43730: LD_VAR 0 3
43734: PUSH
43735: LD_INT 15
43737: EQUAL
43738: IFFALSE 43748
// sKamikadze := true ;
43740: LD_ADDR_EXP 98
43744: PUSH
43745: LD_INT 1
43747: ST_TO_ADDR
// if p3 = 16 then
43748: LD_VAR 0 3
43752: PUSH
43753: LD_INT 16
43755: EQUAL
43756: IFFALSE 43766
// sTroll := true ;
43758: LD_ADDR_EXP 99
43762: PUSH
43763: LD_INT 1
43765: ST_TO_ADDR
// if p3 = 17 then
43766: LD_VAR 0 3
43770: PUSH
43771: LD_INT 17
43773: EQUAL
43774: IFFALSE 43784
// sSlow := true ;
43776: LD_ADDR_EXP 100
43780: PUSH
43781: LD_INT 1
43783: ST_TO_ADDR
// if p3 = 18 then
43784: LD_VAR 0 3
43788: PUSH
43789: LD_INT 18
43791: EQUAL
43792: IFFALSE 43802
// sLack := true ;
43794: LD_ADDR_EXP 101
43798: PUSH
43799: LD_INT 1
43801: ST_TO_ADDR
// if p3 = 19 then
43802: LD_VAR 0 3
43806: PUSH
43807: LD_INT 19
43809: EQUAL
43810: IFFALSE 43820
// sTank := true ;
43812: LD_ADDR_EXP 103
43816: PUSH
43817: LD_INT 1
43819: ST_TO_ADDR
// if p3 = 20 then
43820: LD_VAR 0 3
43824: PUSH
43825: LD_INT 20
43827: EQUAL
43828: IFFALSE 43838
// sRemote := true ;
43830: LD_ADDR_EXP 104
43834: PUSH
43835: LD_INT 1
43837: ST_TO_ADDR
// if p3 = 21 then
43838: LD_VAR 0 3
43842: PUSH
43843: LD_INT 21
43845: EQUAL
43846: IFFALSE 43856
// sPowell := true ;
43848: LD_ADDR_EXP 105
43852: PUSH
43853: LD_INT 1
43855: ST_TO_ADDR
// if p3 = 22 then
43856: LD_VAR 0 3
43860: PUSH
43861: LD_INT 22
43863: EQUAL
43864: IFFALSE 43874
// sTeleport := true ;
43866: LD_ADDR_EXP 108
43870: PUSH
43871: LD_INT 1
43873: ST_TO_ADDR
// if p3 = 23 then
43874: LD_VAR 0 3
43878: PUSH
43879: LD_INT 23
43881: EQUAL
43882: IFFALSE 43892
// sOilTower := true ;
43884: LD_ADDR_EXP 110
43888: PUSH
43889: LD_INT 1
43891: ST_TO_ADDR
// if p3 = 24 then
43892: LD_VAR 0 3
43896: PUSH
43897: LD_INT 24
43899: EQUAL
43900: IFFALSE 43910
// sShovel := true ;
43902: LD_ADDR_EXP 111
43906: PUSH
43907: LD_INT 1
43909: ST_TO_ADDR
// if p3 = 25 then
43910: LD_VAR 0 3
43914: PUSH
43915: LD_INT 25
43917: EQUAL
43918: IFFALSE 43928
// sSheik := true ;
43920: LD_ADDR_EXP 112
43924: PUSH
43925: LD_INT 1
43927: ST_TO_ADDR
// if p3 = 26 then
43928: LD_VAR 0 3
43932: PUSH
43933: LD_INT 26
43935: EQUAL
43936: IFFALSE 43946
// sEarthquake := true ;
43938: LD_ADDR_EXP 114
43942: PUSH
43943: LD_INT 1
43945: ST_TO_ADDR
// if p3 = 27 then
43946: LD_VAR 0 3
43950: PUSH
43951: LD_INT 27
43953: EQUAL
43954: IFFALSE 43964
// sAI := true ;
43956: LD_ADDR_EXP 115
43960: PUSH
43961: LD_INT 1
43963: ST_TO_ADDR
// if p3 = 28 then
43964: LD_VAR 0 3
43968: PUSH
43969: LD_INT 28
43971: EQUAL
43972: IFFALSE 43982
// sCargo := true ;
43974: LD_ADDR_EXP 118
43978: PUSH
43979: LD_INT 1
43981: ST_TO_ADDR
// if p3 = 29 then
43982: LD_VAR 0 3
43986: PUSH
43987: LD_INT 29
43989: EQUAL
43990: IFFALSE 44000
// sDLaser := true ;
43992: LD_ADDR_EXP 119
43996: PUSH
43997: LD_INT 1
43999: ST_TO_ADDR
// if p3 = 30 then
44000: LD_VAR 0 3
44004: PUSH
44005: LD_INT 30
44007: EQUAL
44008: IFFALSE 44018
// sExchange := true ;
44010: LD_ADDR_EXP 120
44014: PUSH
44015: LD_INT 1
44017: ST_TO_ADDR
// if p3 = 31 then
44018: LD_VAR 0 3
44022: PUSH
44023: LD_INT 31
44025: EQUAL
44026: IFFALSE 44036
// sFac := true ;
44028: LD_ADDR_EXP 121
44032: PUSH
44033: LD_INT 1
44035: ST_TO_ADDR
// if p3 = 32 then
44036: LD_VAR 0 3
44040: PUSH
44041: LD_INT 32
44043: EQUAL
44044: IFFALSE 44054
// sPower := true ;
44046: LD_ADDR_EXP 122
44050: PUSH
44051: LD_INT 1
44053: ST_TO_ADDR
// if p3 = 33 then
44054: LD_VAR 0 3
44058: PUSH
44059: LD_INT 33
44061: EQUAL
44062: IFFALSE 44072
// sRandom := true ;
44064: LD_ADDR_EXP 123
44068: PUSH
44069: LD_INT 1
44071: ST_TO_ADDR
// if p3 = 34 then
44072: LD_VAR 0 3
44076: PUSH
44077: LD_INT 34
44079: EQUAL
44080: IFFALSE 44090
// sShield := true ;
44082: LD_ADDR_EXP 124
44086: PUSH
44087: LD_INT 1
44089: ST_TO_ADDR
// if p3 = 35 then
44090: LD_VAR 0 3
44094: PUSH
44095: LD_INT 35
44097: EQUAL
44098: IFFALSE 44108
// sTime := true ;
44100: LD_ADDR_EXP 125
44104: PUSH
44105: LD_INT 1
44107: ST_TO_ADDR
// if p3 = 36 then
44108: LD_VAR 0 3
44112: PUSH
44113: LD_INT 36
44115: EQUAL
44116: IFFALSE 44126
// sTools := true ;
44118: LD_ADDR_EXP 126
44122: PUSH
44123: LD_INT 1
44125: ST_TO_ADDR
// if p3 = 101 then
44126: LD_VAR 0 3
44130: PUSH
44131: LD_INT 101
44133: EQUAL
44134: IFFALSE 44144
// sSold := true ;
44136: LD_ADDR_EXP 91
44140: PUSH
44141: LD_INT 1
44143: ST_TO_ADDR
// if p3 = 102 then
44144: LD_VAR 0 3
44148: PUSH
44149: LD_INT 102
44151: EQUAL
44152: IFFALSE 44162
// sDiff := true ;
44154: LD_ADDR_EXP 92
44158: PUSH
44159: LD_INT 1
44161: ST_TO_ADDR
// if p3 = 103 then
44162: LD_VAR 0 3
44166: PUSH
44167: LD_INT 103
44169: EQUAL
44170: IFFALSE 44180
// sFog := true ;
44172: LD_ADDR_EXP 95
44176: PUSH
44177: LD_INT 1
44179: ST_TO_ADDR
// if p3 = 104 then
44180: LD_VAR 0 3
44184: PUSH
44185: LD_INT 104
44187: EQUAL
44188: IFFALSE 44198
// sReset := true ;
44190: LD_ADDR_EXP 96
44194: PUSH
44195: LD_INT 1
44197: ST_TO_ADDR
// if p3 = 105 then
44198: LD_VAR 0 3
44202: PUSH
44203: LD_INT 105
44205: EQUAL
44206: IFFALSE 44216
// sSun := true ;
44208: LD_ADDR_EXP 97
44212: PUSH
44213: LD_INT 1
44215: ST_TO_ADDR
// if p3 = 106 then
44216: LD_VAR 0 3
44220: PUSH
44221: LD_INT 106
44223: EQUAL
44224: IFFALSE 44234
// sTiger := true ;
44226: LD_ADDR_EXP 93
44230: PUSH
44231: LD_INT 1
44233: ST_TO_ADDR
// if p3 = 107 then
44234: LD_VAR 0 3
44238: PUSH
44239: LD_INT 107
44241: EQUAL
44242: IFFALSE 44252
// sBomb := true ;
44244: LD_ADDR_EXP 94
44248: PUSH
44249: LD_INT 1
44251: ST_TO_ADDR
// if p3 = 108 then
44252: LD_VAR 0 3
44256: PUSH
44257: LD_INT 108
44259: EQUAL
44260: IFFALSE 44270
// sWound := true ;
44262: LD_ADDR_EXP 102
44266: PUSH
44267: LD_INT 1
44269: ST_TO_ADDR
// if p3 = 109 then
44270: LD_VAR 0 3
44274: PUSH
44275: LD_INT 109
44277: EQUAL
44278: IFFALSE 44288
// sBetray := true ;
44280: LD_ADDR_EXP 106
44284: PUSH
44285: LD_INT 1
44287: ST_TO_ADDR
// if p3 = 110 then
44288: LD_VAR 0 3
44292: PUSH
44293: LD_INT 110
44295: EQUAL
44296: IFFALSE 44306
// sContamin := true ;
44298: LD_ADDR_EXP 107
44302: PUSH
44303: LD_INT 1
44305: ST_TO_ADDR
// if p3 = 111 then
44306: LD_VAR 0 3
44310: PUSH
44311: LD_INT 111
44313: EQUAL
44314: IFFALSE 44324
// sOil := true ;
44316: LD_ADDR_EXP 109
44320: PUSH
44321: LD_INT 1
44323: ST_TO_ADDR
// if p3 = 112 then
44324: LD_VAR 0 3
44328: PUSH
44329: LD_INT 112
44331: EQUAL
44332: IFFALSE 44342
// sStu := true ;
44334: LD_ADDR_EXP 113
44338: PUSH
44339: LD_INT 1
44341: ST_TO_ADDR
// if p3 = 113 then
44342: LD_VAR 0 3
44346: PUSH
44347: LD_INT 113
44349: EQUAL
44350: IFFALSE 44360
// sBazooka := true ;
44352: LD_ADDR_EXP 116
44356: PUSH
44357: LD_INT 1
44359: ST_TO_ADDR
// if p3 = 114 then
44360: LD_VAR 0 3
44364: PUSH
44365: LD_INT 114
44367: EQUAL
44368: IFFALSE 44378
// sMortar := true ;
44370: LD_ADDR_EXP 117
44374: PUSH
44375: LD_INT 1
44377: ST_TO_ADDR
// if p3 = 115 then
44378: LD_VAR 0 3
44382: PUSH
44383: LD_INT 115
44385: EQUAL
44386: IFFALSE 44396
// sRanger := true ;
44388: LD_ADDR_EXP 127
44392: PUSH
44393: LD_INT 1
44395: ST_TO_ADDR
// if p3 = 116 then
44396: LD_VAR 0 3
44400: PUSH
44401: LD_INT 116
44403: EQUAL
44404: IFFALSE 44414
// sComputer := true ;
44406: LD_ADDR_EXP 128
44410: PUSH
44411: LD_INT 1
44413: ST_TO_ADDR
// if p3 = 117 then
44414: LD_VAR 0 3
44418: PUSH
44419: LD_INT 117
44421: EQUAL
44422: IFFALSE 44432
// s30 := true ;
44424: LD_ADDR_EXP 129
44428: PUSH
44429: LD_INT 1
44431: ST_TO_ADDR
// if p3 = 118 then
44432: LD_VAR 0 3
44436: PUSH
44437: LD_INT 118
44439: EQUAL
44440: IFFALSE 44450
// s60 := true ;
44442: LD_ADDR_EXP 130
44446: PUSH
44447: LD_INT 1
44449: ST_TO_ADDR
// end ; if p2 = hack_mode then
44450: LD_VAR 0 2
44454: PUSH
44455: LD_INT 101
44457: EQUAL
44458: IFFALSE 44586
// begin case p3 of 1 :
44460: LD_VAR 0 3
44464: PUSH
44465: LD_INT 1
44467: DOUBLE
44468: EQUAL
44469: IFTRUE 44473
44471: GO 44480
44473: POP
// hHackUnlimitedResources ; 2 :
44474: CALL 56733 0 0
44478: GO 44586
44480: LD_INT 2
44482: DOUBLE
44483: EQUAL
44484: IFTRUE 44488
44486: GO 44495
44488: POP
// hHackSetLevel10 ; 3 :
44489: CALL 56866 0 0
44493: GO 44586
44495: LD_INT 3
44497: DOUBLE
44498: EQUAL
44499: IFTRUE 44503
44501: GO 44510
44503: POP
// hHackSetLevel10YourUnits ; 4 :
44504: CALL 56951 0 0
44508: GO 44586
44510: LD_INT 4
44512: DOUBLE
44513: EQUAL
44514: IFTRUE 44518
44516: GO 44525
44518: POP
// hHackInvincible ; 5 :
44519: CALL 57399 0 0
44523: GO 44586
44525: LD_INT 5
44527: DOUBLE
44528: EQUAL
44529: IFTRUE 44533
44531: GO 44540
44533: POP
// hHackInvisible ; 6 :
44534: CALL 57510 0 0
44538: GO 44586
44540: LD_INT 6
44542: DOUBLE
44543: EQUAL
44544: IFTRUE 44548
44546: GO 44555
44548: POP
// hHackChangeYourSide ; 7 :
44549: CALL 57567 0 0
44553: GO 44586
44555: LD_INT 7
44557: DOUBLE
44558: EQUAL
44559: IFTRUE 44563
44561: GO 44570
44563: POP
// hHackChangeUnitSide ; 8 :
44564: CALL 57609 0 0
44568: GO 44586
44570: LD_INT 8
44572: DOUBLE
44573: EQUAL
44574: IFTRUE 44578
44576: GO 44585
44578: POP
// hHackFog ; end ;
44579: CALL 57710 0 0
44583: GO 44586
44585: POP
// end ; if p2 = game_save_mode then
44586: LD_VAR 0 2
44590: PUSH
44591: LD_INT 102
44593: EQUAL
44594: IFFALSE 44649
// begin if p3 = 1 then
44596: LD_VAR 0 3
44600: PUSH
44601: LD_INT 1
44603: EQUAL
44604: IFFALSE 44616
// globalGameSaveCounter := p4 ;
44606: LD_ADDR_EXP 73
44610: PUSH
44611: LD_VAR 0 4
44615: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
44616: LD_VAR 0 3
44620: PUSH
44621: LD_INT 2
44623: EQUAL
44624: PUSH
44625: LD_EXP 73
44629: AND
44630: IFFALSE 44649
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
44632: LD_STRING setGameSaveCounter(
44634: PUSH
44635: LD_EXP 73
44639: STR
44640: PUSH
44641: LD_STRING )
44643: STR
44644: PPUSH
44645: CALL_OW 559
// end ; end ;
44649: LD_VAR 0 7
44653: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
44654: LD_INT 0
44656: PPUSH
// streamModeActive := false ;
44657: LD_ADDR_EXP 74
44661: PUSH
44662: LD_INT 0
44664: ST_TO_ADDR
// normalCounter := 36 ;
44665: LD_ADDR_EXP 75
44669: PUSH
44670: LD_INT 36
44672: ST_TO_ADDR
// hardcoreCounter := 18 ;
44673: LD_ADDR_EXP 76
44677: PUSH
44678: LD_INT 18
44680: ST_TO_ADDR
// sRocket := false ;
44681: LD_ADDR_EXP 79
44685: PUSH
44686: LD_INT 0
44688: ST_TO_ADDR
// sSpeed := false ;
44689: LD_ADDR_EXP 78
44693: PUSH
44694: LD_INT 0
44696: ST_TO_ADDR
// sEngine := false ;
44697: LD_ADDR_EXP 80
44701: PUSH
44702: LD_INT 0
44704: ST_TO_ADDR
// sSpec := false ;
44705: LD_ADDR_EXP 77
44709: PUSH
44710: LD_INT 0
44712: ST_TO_ADDR
// sLevel := false ;
44713: LD_ADDR_EXP 81
44717: PUSH
44718: LD_INT 0
44720: ST_TO_ADDR
// sArmoury := false ;
44721: LD_ADDR_EXP 82
44725: PUSH
44726: LD_INT 0
44728: ST_TO_ADDR
// sRadar := false ;
44729: LD_ADDR_EXP 83
44733: PUSH
44734: LD_INT 0
44736: ST_TO_ADDR
// sBunker := false ;
44737: LD_ADDR_EXP 84
44741: PUSH
44742: LD_INT 0
44744: ST_TO_ADDR
// sHack := false ;
44745: LD_ADDR_EXP 85
44749: PUSH
44750: LD_INT 0
44752: ST_TO_ADDR
// sFire := false ;
44753: LD_ADDR_EXP 86
44757: PUSH
44758: LD_INT 0
44760: ST_TO_ADDR
// sRefresh := false ;
44761: LD_ADDR_EXP 87
44765: PUSH
44766: LD_INT 0
44768: ST_TO_ADDR
// sExp := false ;
44769: LD_ADDR_EXP 88
44773: PUSH
44774: LD_INT 0
44776: ST_TO_ADDR
// sDepot := false ;
44777: LD_ADDR_EXP 89
44781: PUSH
44782: LD_INT 0
44784: ST_TO_ADDR
// sFlag := false ;
44785: LD_ADDR_EXP 90
44789: PUSH
44790: LD_INT 0
44792: ST_TO_ADDR
// sKamikadze := false ;
44793: LD_ADDR_EXP 98
44797: PUSH
44798: LD_INT 0
44800: ST_TO_ADDR
// sTroll := false ;
44801: LD_ADDR_EXP 99
44805: PUSH
44806: LD_INT 0
44808: ST_TO_ADDR
// sSlow := false ;
44809: LD_ADDR_EXP 100
44813: PUSH
44814: LD_INT 0
44816: ST_TO_ADDR
// sLack := false ;
44817: LD_ADDR_EXP 101
44821: PUSH
44822: LD_INT 0
44824: ST_TO_ADDR
// sTank := false ;
44825: LD_ADDR_EXP 103
44829: PUSH
44830: LD_INT 0
44832: ST_TO_ADDR
// sRemote := false ;
44833: LD_ADDR_EXP 104
44837: PUSH
44838: LD_INT 0
44840: ST_TO_ADDR
// sPowell := false ;
44841: LD_ADDR_EXP 105
44845: PUSH
44846: LD_INT 0
44848: ST_TO_ADDR
// sTeleport := false ;
44849: LD_ADDR_EXP 108
44853: PUSH
44854: LD_INT 0
44856: ST_TO_ADDR
// sOilTower := false ;
44857: LD_ADDR_EXP 110
44861: PUSH
44862: LD_INT 0
44864: ST_TO_ADDR
// sShovel := false ;
44865: LD_ADDR_EXP 111
44869: PUSH
44870: LD_INT 0
44872: ST_TO_ADDR
// sSheik := false ;
44873: LD_ADDR_EXP 112
44877: PUSH
44878: LD_INT 0
44880: ST_TO_ADDR
// sEarthquake := false ;
44881: LD_ADDR_EXP 114
44885: PUSH
44886: LD_INT 0
44888: ST_TO_ADDR
// sAI := false ;
44889: LD_ADDR_EXP 115
44893: PUSH
44894: LD_INT 0
44896: ST_TO_ADDR
// sCargo := false ;
44897: LD_ADDR_EXP 118
44901: PUSH
44902: LD_INT 0
44904: ST_TO_ADDR
// sDLaser := false ;
44905: LD_ADDR_EXP 119
44909: PUSH
44910: LD_INT 0
44912: ST_TO_ADDR
// sExchange := false ;
44913: LD_ADDR_EXP 120
44917: PUSH
44918: LD_INT 0
44920: ST_TO_ADDR
// sFac := false ;
44921: LD_ADDR_EXP 121
44925: PUSH
44926: LD_INT 0
44928: ST_TO_ADDR
// sPower := false ;
44929: LD_ADDR_EXP 122
44933: PUSH
44934: LD_INT 0
44936: ST_TO_ADDR
// sRandom := false ;
44937: LD_ADDR_EXP 123
44941: PUSH
44942: LD_INT 0
44944: ST_TO_ADDR
// sShield := false ;
44945: LD_ADDR_EXP 124
44949: PUSH
44950: LD_INT 0
44952: ST_TO_ADDR
// sTime := false ;
44953: LD_ADDR_EXP 125
44957: PUSH
44958: LD_INT 0
44960: ST_TO_ADDR
// sTools := false ;
44961: LD_ADDR_EXP 126
44965: PUSH
44966: LD_INT 0
44968: ST_TO_ADDR
// sSold := false ;
44969: LD_ADDR_EXP 91
44973: PUSH
44974: LD_INT 0
44976: ST_TO_ADDR
// sDiff := false ;
44977: LD_ADDR_EXP 92
44981: PUSH
44982: LD_INT 0
44984: ST_TO_ADDR
// sFog := false ;
44985: LD_ADDR_EXP 95
44989: PUSH
44990: LD_INT 0
44992: ST_TO_ADDR
// sReset := false ;
44993: LD_ADDR_EXP 96
44997: PUSH
44998: LD_INT 0
45000: ST_TO_ADDR
// sSun := false ;
45001: LD_ADDR_EXP 97
45005: PUSH
45006: LD_INT 0
45008: ST_TO_ADDR
// sTiger := false ;
45009: LD_ADDR_EXP 93
45013: PUSH
45014: LD_INT 0
45016: ST_TO_ADDR
// sBomb := false ;
45017: LD_ADDR_EXP 94
45021: PUSH
45022: LD_INT 0
45024: ST_TO_ADDR
// sWound := false ;
45025: LD_ADDR_EXP 102
45029: PUSH
45030: LD_INT 0
45032: ST_TO_ADDR
// sBetray := false ;
45033: LD_ADDR_EXP 106
45037: PUSH
45038: LD_INT 0
45040: ST_TO_ADDR
// sContamin := false ;
45041: LD_ADDR_EXP 107
45045: PUSH
45046: LD_INT 0
45048: ST_TO_ADDR
// sOil := false ;
45049: LD_ADDR_EXP 109
45053: PUSH
45054: LD_INT 0
45056: ST_TO_ADDR
// sStu := false ;
45057: LD_ADDR_EXP 113
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// sBazooka := false ;
45065: LD_ADDR_EXP 116
45069: PUSH
45070: LD_INT 0
45072: ST_TO_ADDR
// sMortar := false ;
45073: LD_ADDR_EXP 117
45077: PUSH
45078: LD_INT 0
45080: ST_TO_ADDR
// sRanger := false ;
45081: LD_ADDR_EXP 127
45085: PUSH
45086: LD_INT 0
45088: ST_TO_ADDR
// sComputer := false ;
45089: LD_ADDR_EXP 128
45093: PUSH
45094: LD_INT 0
45096: ST_TO_ADDR
// s30 := false ;
45097: LD_ADDR_EXP 129
45101: PUSH
45102: LD_INT 0
45104: ST_TO_ADDR
// s60 := false ;
45105: LD_ADDR_EXP 130
45109: PUSH
45110: LD_INT 0
45112: ST_TO_ADDR
// end ;
45113: LD_VAR 0 1
45117: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45118: LD_INT 0
45120: PPUSH
45121: PPUSH
45122: PPUSH
45123: PPUSH
45124: PPUSH
45125: PPUSH
45126: PPUSH
// result := [ ] ;
45127: LD_ADDR_VAR 0 2
45131: PUSH
45132: EMPTY
45133: ST_TO_ADDR
// if campaign_id = 1 then
45134: LD_OWVAR 69
45138: PUSH
45139: LD_INT 1
45141: EQUAL
45142: IFFALSE 48308
// begin case mission_number of 1 :
45144: LD_OWVAR 70
45148: PUSH
45149: LD_INT 1
45151: DOUBLE
45152: EQUAL
45153: IFTRUE 45157
45155: GO 45233
45157: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45158: LD_ADDR_VAR 0 2
45162: PUSH
45163: LD_INT 2
45165: PUSH
45166: LD_INT 4
45168: PUSH
45169: LD_INT 11
45171: PUSH
45172: LD_INT 12
45174: PUSH
45175: LD_INT 15
45177: PUSH
45178: LD_INT 16
45180: PUSH
45181: LD_INT 22
45183: PUSH
45184: LD_INT 23
45186: PUSH
45187: LD_INT 26
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 101
45203: PUSH
45204: LD_INT 102
45206: PUSH
45207: LD_INT 106
45209: PUSH
45210: LD_INT 116
45212: PUSH
45213: LD_INT 117
45215: PUSH
45216: LD_INT 118
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: ST_TO_ADDR
45231: GO 48306
45233: LD_INT 2
45235: DOUBLE
45236: EQUAL
45237: IFTRUE 45241
45239: GO 45325
45241: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45242: LD_ADDR_VAR 0 2
45246: PUSH
45247: LD_INT 2
45249: PUSH
45250: LD_INT 4
45252: PUSH
45253: LD_INT 11
45255: PUSH
45256: LD_INT 12
45258: PUSH
45259: LD_INT 15
45261: PUSH
45262: LD_INT 16
45264: PUSH
45265: LD_INT 22
45267: PUSH
45268: LD_INT 23
45270: PUSH
45271: LD_INT 26
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: LIST
45278: LIST
45279: LIST
45280: LIST
45281: LIST
45282: LIST
45283: LIST
45284: PUSH
45285: LD_INT 101
45287: PUSH
45288: LD_INT 102
45290: PUSH
45291: LD_INT 105
45293: PUSH
45294: LD_INT 106
45296: PUSH
45297: LD_INT 108
45299: PUSH
45300: LD_INT 116
45302: PUSH
45303: LD_INT 117
45305: PUSH
45306: LD_INT 118
45308: PUSH
45309: EMPTY
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: ST_TO_ADDR
45323: GO 48306
45325: LD_INT 3
45327: DOUBLE
45328: EQUAL
45329: IFTRUE 45333
45331: GO 45421
45333: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45334: LD_ADDR_VAR 0 2
45338: PUSH
45339: LD_INT 2
45341: PUSH
45342: LD_INT 4
45344: PUSH
45345: LD_INT 5
45347: PUSH
45348: LD_INT 11
45350: PUSH
45351: LD_INT 12
45353: PUSH
45354: LD_INT 15
45356: PUSH
45357: LD_INT 16
45359: PUSH
45360: LD_INT 22
45362: PUSH
45363: LD_INT 26
45365: PUSH
45366: LD_INT 36
45368: PUSH
45369: EMPTY
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 101
45383: PUSH
45384: LD_INT 102
45386: PUSH
45387: LD_INT 105
45389: PUSH
45390: LD_INT 106
45392: PUSH
45393: LD_INT 108
45395: PUSH
45396: LD_INT 116
45398: PUSH
45399: LD_INT 117
45401: PUSH
45402: LD_INT 118
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: ST_TO_ADDR
45419: GO 48306
45421: LD_INT 4
45423: DOUBLE
45424: EQUAL
45425: IFTRUE 45429
45427: GO 45525
45429: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45430: LD_ADDR_VAR 0 2
45434: PUSH
45435: LD_INT 2
45437: PUSH
45438: LD_INT 4
45440: PUSH
45441: LD_INT 5
45443: PUSH
45444: LD_INT 8
45446: PUSH
45447: LD_INT 11
45449: PUSH
45450: LD_INT 12
45452: PUSH
45453: LD_INT 15
45455: PUSH
45456: LD_INT 16
45458: PUSH
45459: LD_INT 22
45461: PUSH
45462: LD_INT 23
45464: PUSH
45465: LD_INT 26
45467: PUSH
45468: LD_INT 36
45470: PUSH
45471: EMPTY
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 101
45487: PUSH
45488: LD_INT 102
45490: PUSH
45491: LD_INT 105
45493: PUSH
45494: LD_INT 106
45496: PUSH
45497: LD_INT 108
45499: PUSH
45500: LD_INT 116
45502: PUSH
45503: LD_INT 117
45505: PUSH
45506: LD_INT 118
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: LIST
45513: LIST
45514: LIST
45515: LIST
45516: LIST
45517: LIST
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: ST_TO_ADDR
45523: GO 48306
45525: LD_INT 5
45527: DOUBLE
45528: EQUAL
45529: IFTRUE 45533
45531: GO 45645
45533: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45534: LD_ADDR_VAR 0 2
45538: PUSH
45539: LD_INT 2
45541: PUSH
45542: LD_INT 4
45544: PUSH
45545: LD_INT 5
45547: PUSH
45548: LD_INT 6
45550: PUSH
45551: LD_INT 8
45553: PUSH
45554: LD_INT 11
45556: PUSH
45557: LD_INT 12
45559: PUSH
45560: LD_INT 15
45562: PUSH
45563: LD_INT 16
45565: PUSH
45566: LD_INT 22
45568: PUSH
45569: LD_INT 23
45571: PUSH
45572: LD_INT 25
45574: PUSH
45575: LD_INT 26
45577: PUSH
45578: LD_INT 36
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 101
45599: PUSH
45600: LD_INT 102
45602: PUSH
45603: LD_INT 105
45605: PUSH
45606: LD_INT 106
45608: PUSH
45609: LD_INT 108
45611: PUSH
45612: LD_INT 109
45614: PUSH
45615: LD_INT 112
45617: PUSH
45618: LD_INT 116
45620: PUSH
45621: LD_INT 117
45623: PUSH
45624: LD_INT 118
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: ST_TO_ADDR
45643: GO 48306
45645: LD_INT 6
45647: DOUBLE
45648: EQUAL
45649: IFTRUE 45653
45651: GO 45785
45653: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45654: LD_ADDR_VAR 0 2
45658: PUSH
45659: LD_INT 2
45661: PUSH
45662: LD_INT 4
45664: PUSH
45665: LD_INT 5
45667: PUSH
45668: LD_INT 6
45670: PUSH
45671: LD_INT 8
45673: PUSH
45674: LD_INT 11
45676: PUSH
45677: LD_INT 12
45679: PUSH
45680: LD_INT 15
45682: PUSH
45683: LD_INT 16
45685: PUSH
45686: LD_INT 20
45688: PUSH
45689: LD_INT 21
45691: PUSH
45692: LD_INT 22
45694: PUSH
45695: LD_INT 23
45697: PUSH
45698: LD_INT 25
45700: PUSH
45701: LD_INT 26
45703: PUSH
45704: LD_INT 30
45706: PUSH
45707: LD_INT 31
45709: PUSH
45710: LD_INT 32
45712: PUSH
45713: LD_INT 36
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: LIST
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: LIST
45726: LIST
45727: LIST
45728: LIST
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 101
45739: PUSH
45740: LD_INT 102
45742: PUSH
45743: LD_INT 105
45745: PUSH
45746: LD_INT 106
45748: PUSH
45749: LD_INT 108
45751: PUSH
45752: LD_INT 109
45754: PUSH
45755: LD_INT 112
45757: PUSH
45758: LD_INT 116
45760: PUSH
45761: LD_INT 117
45763: PUSH
45764: LD_INT 118
45766: PUSH
45767: EMPTY
45768: LIST
45769: LIST
45770: LIST
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: LIST
45778: PUSH
45779: EMPTY
45780: LIST
45781: LIST
45782: ST_TO_ADDR
45783: GO 48306
45785: LD_INT 7
45787: DOUBLE
45788: EQUAL
45789: IFTRUE 45793
45791: GO 45905
45793: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45794: LD_ADDR_VAR 0 2
45798: PUSH
45799: LD_INT 2
45801: PUSH
45802: LD_INT 4
45804: PUSH
45805: LD_INT 5
45807: PUSH
45808: LD_INT 7
45810: PUSH
45811: LD_INT 11
45813: PUSH
45814: LD_INT 12
45816: PUSH
45817: LD_INT 15
45819: PUSH
45820: LD_INT 16
45822: PUSH
45823: LD_INT 20
45825: PUSH
45826: LD_INT 21
45828: PUSH
45829: LD_INT 22
45831: PUSH
45832: LD_INT 23
45834: PUSH
45835: LD_INT 25
45837: PUSH
45838: LD_INT 26
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 101
45859: PUSH
45860: LD_INT 102
45862: PUSH
45863: LD_INT 103
45865: PUSH
45866: LD_INT 105
45868: PUSH
45869: LD_INT 106
45871: PUSH
45872: LD_INT 108
45874: PUSH
45875: LD_INT 112
45877: PUSH
45878: LD_INT 116
45880: PUSH
45881: LD_INT 117
45883: PUSH
45884: LD_INT 118
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: ST_TO_ADDR
45903: GO 48306
45905: LD_INT 8
45907: DOUBLE
45908: EQUAL
45909: IFTRUE 45913
45911: GO 46053
45913: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45914: LD_ADDR_VAR 0 2
45918: PUSH
45919: LD_INT 2
45921: PUSH
45922: LD_INT 4
45924: PUSH
45925: LD_INT 5
45927: PUSH
45928: LD_INT 6
45930: PUSH
45931: LD_INT 7
45933: PUSH
45934: LD_INT 8
45936: PUSH
45937: LD_INT 11
45939: PUSH
45940: LD_INT 12
45942: PUSH
45943: LD_INT 15
45945: PUSH
45946: LD_INT 16
45948: PUSH
45949: LD_INT 20
45951: PUSH
45952: LD_INT 21
45954: PUSH
45955: LD_INT 22
45957: PUSH
45958: LD_INT 23
45960: PUSH
45961: LD_INT 25
45963: PUSH
45964: LD_INT 26
45966: PUSH
45967: LD_INT 30
45969: PUSH
45970: LD_INT 31
45972: PUSH
45973: LD_INT 32
45975: PUSH
45976: LD_INT 36
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 101
46003: PUSH
46004: LD_INT 102
46006: PUSH
46007: LD_INT 103
46009: PUSH
46010: LD_INT 105
46012: PUSH
46013: LD_INT 106
46015: PUSH
46016: LD_INT 108
46018: PUSH
46019: LD_INT 109
46021: PUSH
46022: LD_INT 112
46024: PUSH
46025: LD_INT 116
46027: PUSH
46028: LD_INT 117
46030: PUSH
46031: LD_INT 118
46033: PUSH
46034: EMPTY
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: PUSH
46047: EMPTY
46048: LIST
46049: LIST
46050: ST_TO_ADDR
46051: GO 48306
46053: LD_INT 9
46055: DOUBLE
46056: EQUAL
46057: IFTRUE 46061
46059: GO 46209
46061: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46062: LD_ADDR_VAR 0 2
46066: PUSH
46067: LD_INT 2
46069: PUSH
46070: LD_INT 4
46072: PUSH
46073: LD_INT 5
46075: PUSH
46076: LD_INT 6
46078: PUSH
46079: LD_INT 7
46081: PUSH
46082: LD_INT 8
46084: PUSH
46085: LD_INT 11
46087: PUSH
46088: LD_INT 12
46090: PUSH
46091: LD_INT 15
46093: PUSH
46094: LD_INT 16
46096: PUSH
46097: LD_INT 20
46099: PUSH
46100: LD_INT 21
46102: PUSH
46103: LD_INT 22
46105: PUSH
46106: LD_INT 23
46108: PUSH
46109: LD_INT 25
46111: PUSH
46112: LD_INT 26
46114: PUSH
46115: LD_INT 28
46117: PUSH
46118: LD_INT 30
46120: PUSH
46121: LD_INT 31
46123: PUSH
46124: LD_INT 32
46126: PUSH
46127: LD_INT 36
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 101
46155: PUSH
46156: LD_INT 102
46158: PUSH
46159: LD_INT 103
46161: PUSH
46162: LD_INT 105
46164: PUSH
46165: LD_INT 106
46167: PUSH
46168: LD_INT 108
46170: PUSH
46171: LD_INT 109
46173: PUSH
46174: LD_INT 112
46176: PUSH
46177: LD_INT 114
46179: PUSH
46180: LD_INT 116
46182: PUSH
46183: LD_INT 117
46185: PUSH
46186: LD_INT 118
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: ST_TO_ADDR
46207: GO 48306
46209: LD_INT 10
46211: DOUBLE
46212: EQUAL
46213: IFTRUE 46217
46215: GO 46413
46217: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46218: LD_ADDR_VAR 0 2
46222: PUSH
46223: LD_INT 2
46225: PUSH
46226: LD_INT 4
46228: PUSH
46229: LD_INT 5
46231: PUSH
46232: LD_INT 6
46234: PUSH
46235: LD_INT 7
46237: PUSH
46238: LD_INT 8
46240: PUSH
46241: LD_INT 9
46243: PUSH
46244: LD_INT 10
46246: PUSH
46247: LD_INT 11
46249: PUSH
46250: LD_INT 12
46252: PUSH
46253: LD_INT 13
46255: PUSH
46256: LD_INT 14
46258: PUSH
46259: LD_INT 15
46261: PUSH
46262: LD_INT 16
46264: PUSH
46265: LD_INT 17
46267: PUSH
46268: LD_INT 18
46270: PUSH
46271: LD_INT 19
46273: PUSH
46274: LD_INT 20
46276: PUSH
46277: LD_INT 21
46279: PUSH
46280: LD_INT 22
46282: PUSH
46283: LD_INT 23
46285: PUSH
46286: LD_INT 24
46288: PUSH
46289: LD_INT 25
46291: PUSH
46292: LD_INT 26
46294: PUSH
46295: LD_INT 28
46297: PUSH
46298: LD_INT 30
46300: PUSH
46301: LD_INT 31
46303: PUSH
46304: LD_INT 32
46306: PUSH
46307: LD_INT 36
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: LIST
46314: LIST
46315: LIST
46316: LIST
46317: LIST
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: LIST
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 101
46343: PUSH
46344: LD_INT 102
46346: PUSH
46347: LD_INT 103
46349: PUSH
46350: LD_INT 104
46352: PUSH
46353: LD_INT 105
46355: PUSH
46356: LD_INT 106
46358: PUSH
46359: LD_INT 107
46361: PUSH
46362: LD_INT 108
46364: PUSH
46365: LD_INT 109
46367: PUSH
46368: LD_INT 110
46370: PUSH
46371: LD_INT 111
46373: PUSH
46374: LD_INT 112
46376: PUSH
46377: LD_INT 114
46379: PUSH
46380: LD_INT 116
46382: PUSH
46383: LD_INT 117
46385: PUSH
46386: LD_INT 118
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: ST_TO_ADDR
46411: GO 48306
46413: LD_INT 11
46415: DOUBLE
46416: EQUAL
46417: IFTRUE 46421
46419: GO 46625
46421: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46422: LD_ADDR_VAR 0 2
46426: PUSH
46427: LD_INT 2
46429: PUSH
46430: LD_INT 3
46432: PUSH
46433: LD_INT 4
46435: PUSH
46436: LD_INT 5
46438: PUSH
46439: LD_INT 6
46441: PUSH
46442: LD_INT 7
46444: PUSH
46445: LD_INT 8
46447: PUSH
46448: LD_INT 9
46450: PUSH
46451: LD_INT 10
46453: PUSH
46454: LD_INT 11
46456: PUSH
46457: LD_INT 12
46459: PUSH
46460: LD_INT 13
46462: PUSH
46463: LD_INT 14
46465: PUSH
46466: LD_INT 15
46468: PUSH
46469: LD_INT 16
46471: PUSH
46472: LD_INT 17
46474: PUSH
46475: LD_INT 18
46477: PUSH
46478: LD_INT 19
46480: PUSH
46481: LD_INT 20
46483: PUSH
46484: LD_INT 21
46486: PUSH
46487: LD_INT 22
46489: PUSH
46490: LD_INT 23
46492: PUSH
46493: LD_INT 24
46495: PUSH
46496: LD_INT 25
46498: PUSH
46499: LD_INT 26
46501: PUSH
46502: LD_INT 28
46504: PUSH
46505: LD_INT 30
46507: PUSH
46508: LD_INT 31
46510: PUSH
46511: LD_INT 32
46513: PUSH
46514: LD_INT 34
46516: PUSH
46517: LD_INT 36
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: PUSH
46553: LD_INT 101
46555: PUSH
46556: LD_INT 102
46558: PUSH
46559: LD_INT 103
46561: PUSH
46562: LD_INT 104
46564: PUSH
46565: LD_INT 105
46567: PUSH
46568: LD_INT 106
46570: PUSH
46571: LD_INT 107
46573: PUSH
46574: LD_INT 108
46576: PUSH
46577: LD_INT 109
46579: PUSH
46580: LD_INT 110
46582: PUSH
46583: LD_INT 111
46585: PUSH
46586: LD_INT 112
46588: PUSH
46589: LD_INT 114
46591: PUSH
46592: LD_INT 116
46594: PUSH
46595: LD_INT 117
46597: PUSH
46598: LD_INT 118
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: ST_TO_ADDR
46623: GO 48306
46625: LD_INT 12
46627: DOUBLE
46628: EQUAL
46629: IFTRUE 46633
46631: GO 46853
46633: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46634: LD_ADDR_VAR 0 2
46638: PUSH
46639: LD_INT 1
46641: PUSH
46642: LD_INT 2
46644: PUSH
46645: LD_INT 3
46647: PUSH
46648: LD_INT 4
46650: PUSH
46651: LD_INT 5
46653: PUSH
46654: LD_INT 6
46656: PUSH
46657: LD_INT 7
46659: PUSH
46660: LD_INT 8
46662: PUSH
46663: LD_INT 9
46665: PUSH
46666: LD_INT 10
46668: PUSH
46669: LD_INT 11
46671: PUSH
46672: LD_INT 12
46674: PUSH
46675: LD_INT 13
46677: PUSH
46678: LD_INT 14
46680: PUSH
46681: LD_INT 15
46683: PUSH
46684: LD_INT 16
46686: PUSH
46687: LD_INT 17
46689: PUSH
46690: LD_INT 18
46692: PUSH
46693: LD_INT 19
46695: PUSH
46696: LD_INT 20
46698: PUSH
46699: LD_INT 21
46701: PUSH
46702: LD_INT 22
46704: PUSH
46705: LD_INT 23
46707: PUSH
46708: LD_INT 24
46710: PUSH
46711: LD_INT 25
46713: PUSH
46714: LD_INT 26
46716: PUSH
46717: LD_INT 27
46719: PUSH
46720: LD_INT 28
46722: PUSH
46723: LD_INT 30
46725: PUSH
46726: LD_INT 31
46728: PUSH
46729: LD_INT 32
46731: PUSH
46732: LD_INT 33
46734: PUSH
46735: LD_INT 34
46737: PUSH
46738: LD_INT 36
46740: PUSH
46741: EMPTY
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: PUSH
46777: LD_INT 101
46779: PUSH
46780: LD_INT 102
46782: PUSH
46783: LD_INT 103
46785: PUSH
46786: LD_INT 104
46788: PUSH
46789: LD_INT 105
46791: PUSH
46792: LD_INT 106
46794: PUSH
46795: LD_INT 107
46797: PUSH
46798: LD_INT 108
46800: PUSH
46801: LD_INT 109
46803: PUSH
46804: LD_INT 110
46806: PUSH
46807: LD_INT 111
46809: PUSH
46810: LD_INT 112
46812: PUSH
46813: LD_INT 113
46815: PUSH
46816: LD_INT 114
46818: PUSH
46819: LD_INT 116
46821: PUSH
46822: LD_INT 117
46824: PUSH
46825: LD_INT 118
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: PUSH
46847: EMPTY
46848: LIST
46849: LIST
46850: ST_TO_ADDR
46851: GO 48306
46853: LD_INT 13
46855: DOUBLE
46856: EQUAL
46857: IFTRUE 46861
46859: GO 47069
46861: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46862: LD_ADDR_VAR 0 2
46866: PUSH
46867: LD_INT 1
46869: PUSH
46870: LD_INT 2
46872: PUSH
46873: LD_INT 3
46875: PUSH
46876: LD_INT 4
46878: PUSH
46879: LD_INT 5
46881: PUSH
46882: LD_INT 8
46884: PUSH
46885: LD_INT 9
46887: PUSH
46888: LD_INT 10
46890: PUSH
46891: LD_INT 11
46893: PUSH
46894: LD_INT 12
46896: PUSH
46897: LD_INT 14
46899: PUSH
46900: LD_INT 15
46902: PUSH
46903: LD_INT 16
46905: PUSH
46906: LD_INT 17
46908: PUSH
46909: LD_INT 18
46911: PUSH
46912: LD_INT 19
46914: PUSH
46915: LD_INT 20
46917: PUSH
46918: LD_INT 21
46920: PUSH
46921: LD_INT 22
46923: PUSH
46924: LD_INT 23
46926: PUSH
46927: LD_INT 24
46929: PUSH
46930: LD_INT 25
46932: PUSH
46933: LD_INT 26
46935: PUSH
46936: LD_INT 27
46938: PUSH
46939: LD_INT 28
46941: PUSH
46942: LD_INT 30
46944: PUSH
46945: LD_INT 31
46947: PUSH
46948: LD_INT 32
46950: PUSH
46951: LD_INT 33
46953: PUSH
46954: LD_INT 34
46956: PUSH
46957: LD_INT 36
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: LIST
46992: PUSH
46993: LD_INT 101
46995: PUSH
46996: LD_INT 102
46998: PUSH
46999: LD_INT 103
47001: PUSH
47002: LD_INT 104
47004: PUSH
47005: LD_INT 105
47007: PUSH
47008: LD_INT 106
47010: PUSH
47011: LD_INT 107
47013: PUSH
47014: LD_INT 108
47016: PUSH
47017: LD_INT 109
47019: PUSH
47020: LD_INT 110
47022: PUSH
47023: LD_INT 111
47025: PUSH
47026: LD_INT 112
47028: PUSH
47029: LD_INT 113
47031: PUSH
47032: LD_INT 114
47034: PUSH
47035: LD_INT 116
47037: PUSH
47038: LD_INT 117
47040: PUSH
47041: LD_INT 118
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: ST_TO_ADDR
47067: GO 48306
47069: LD_INT 14
47071: DOUBLE
47072: EQUAL
47073: IFTRUE 47077
47075: GO 47301
47077: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47078: LD_ADDR_VAR 0 2
47082: PUSH
47083: LD_INT 1
47085: PUSH
47086: LD_INT 2
47088: PUSH
47089: LD_INT 3
47091: PUSH
47092: LD_INT 4
47094: PUSH
47095: LD_INT 5
47097: PUSH
47098: LD_INT 6
47100: PUSH
47101: LD_INT 7
47103: PUSH
47104: LD_INT 8
47106: PUSH
47107: LD_INT 9
47109: PUSH
47110: LD_INT 10
47112: PUSH
47113: LD_INT 11
47115: PUSH
47116: LD_INT 12
47118: PUSH
47119: LD_INT 13
47121: PUSH
47122: LD_INT 14
47124: PUSH
47125: LD_INT 15
47127: PUSH
47128: LD_INT 16
47130: PUSH
47131: LD_INT 17
47133: PUSH
47134: LD_INT 18
47136: PUSH
47137: LD_INT 19
47139: PUSH
47140: LD_INT 20
47142: PUSH
47143: LD_INT 21
47145: PUSH
47146: LD_INT 22
47148: PUSH
47149: LD_INT 23
47151: PUSH
47152: LD_INT 24
47154: PUSH
47155: LD_INT 25
47157: PUSH
47158: LD_INT 26
47160: PUSH
47161: LD_INT 27
47163: PUSH
47164: LD_INT 28
47166: PUSH
47167: LD_INT 29
47169: PUSH
47170: LD_INT 30
47172: PUSH
47173: LD_INT 31
47175: PUSH
47176: LD_INT 32
47178: PUSH
47179: LD_INT 33
47181: PUSH
47182: LD_INT 34
47184: PUSH
47185: LD_INT 36
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: PUSH
47225: LD_INT 101
47227: PUSH
47228: LD_INT 102
47230: PUSH
47231: LD_INT 103
47233: PUSH
47234: LD_INT 104
47236: PUSH
47237: LD_INT 105
47239: PUSH
47240: LD_INT 106
47242: PUSH
47243: LD_INT 107
47245: PUSH
47246: LD_INT 108
47248: PUSH
47249: LD_INT 109
47251: PUSH
47252: LD_INT 110
47254: PUSH
47255: LD_INT 111
47257: PUSH
47258: LD_INT 112
47260: PUSH
47261: LD_INT 113
47263: PUSH
47264: LD_INT 114
47266: PUSH
47267: LD_INT 116
47269: PUSH
47270: LD_INT 117
47272: PUSH
47273: LD_INT 118
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: ST_TO_ADDR
47299: GO 48306
47301: LD_INT 15
47303: DOUBLE
47304: EQUAL
47305: IFTRUE 47309
47307: GO 47533
47309: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47310: LD_ADDR_VAR 0 2
47314: PUSH
47315: LD_INT 1
47317: PUSH
47318: LD_INT 2
47320: PUSH
47321: LD_INT 3
47323: PUSH
47324: LD_INT 4
47326: PUSH
47327: LD_INT 5
47329: PUSH
47330: LD_INT 6
47332: PUSH
47333: LD_INT 7
47335: PUSH
47336: LD_INT 8
47338: PUSH
47339: LD_INT 9
47341: PUSH
47342: LD_INT 10
47344: PUSH
47345: LD_INT 11
47347: PUSH
47348: LD_INT 12
47350: PUSH
47351: LD_INT 13
47353: PUSH
47354: LD_INT 14
47356: PUSH
47357: LD_INT 15
47359: PUSH
47360: LD_INT 16
47362: PUSH
47363: LD_INT 17
47365: PUSH
47366: LD_INT 18
47368: PUSH
47369: LD_INT 19
47371: PUSH
47372: LD_INT 20
47374: PUSH
47375: LD_INT 21
47377: PUSH
47378: LD_INT 22
47380: PUSH
47381: LD_INT 23
47383: PUSH
47384: LD_INT 24
47386: PUSH
47387: LD_INT 25
47389: PUSH
47390: LD_INT 26
47392: PUSH
47393: LD_INT 27
47395: PUSH
47396: LD_INT 28
47398: PUSH
47399: LD_INT 29
47401: PUSH
47402: LD_INT 30
47404: PUSH
47405: LD_INT 31
47407: PUSH
47408: LD_INT 32
47410: PUSH
47411: LD_INT 33
47413: PUSH
47414: LD_INT 34
47416: PUSH
47417: LD_INT 36
47419: PUSH
47420: EMPTY
47421: LIST
47422: LIST
47423: LIST
47424: LIST
47425: LIST
47426: LIST
47427: LIST
47428: LIST
47429: LIST
47430: LIST
47431: LIST
47432: LIST
47433: LIST
47434: LIST
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: PUSH
47457: LD_INT 101
47459: PUSH
47460: LD_INT 102
47462: PUSH
47463: LD_INT 103
47465: PUSH
47466: LD_INT 104
47468: PUSH
47469: LD_INT 105
47471: PUSH
47472: LD_INT 106
47474: PUSH
47475: LD_INT 107
47477: PUSH
47478: LD_INT 108
47480: PUSH
47481: LD_INT 109
47483: PUSH
47484: LD_INT 110
47486: PUSH
47487: LD_INT 111
47489: PUSH
47490: LD_INT 112
47492: PUSH
47493: LD_INT 113
47495: PUSH
47496: LD_INT 114
47498: PUSH
47499: LD_INT 116
47501: PUSH
47502: LD_INT 117
47504: PUSH
47505: LD_INT 118
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: LIST
47523: LIST
47524: LIST
47525: LIST
47526: PUSH
47527: EMPTY
47528: LIST
47529: LIST
47530: ST_TO_ADDR
47531: GO 48306
47533: LD_INT 16
47535: DOUBLE
47536: EQUAL
47537: IFTRUE 47541
47539: GO 47677
47541: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47542: LD_ADDR_VAR 0 2
47546: PUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 4
47552: PUSH
47553: LD_INT 5
47555: PUSH
47556: LD_INT 7
47558: PUSH
47559: LD_INT 11
47561: PUSH
47562: LD_INT 12
47564: PUSH
47565: LD_INT 15
47567: PUSH
47568: LD_INT 16
47570: PUSH
47571: LD_INT 20
47573: PUSH
47574: LD_INT 21
47576: PUSH
47577: LD_INT 22
47579: PUSH
47580: LD_INT 23
47582: PUSH
47583: LD_INT 25
47585: PUSH
47586: LD_INT 26
47588: PUSH
47589: LD_INT 30
47591: PUSH
47592: LD_INT 31
47594: PUSH
47595: LD_INT 32
47597: PUSH
47598: LD_INT 33
47600: PUSH
47601: LD_INT 34
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: LIST
47624: PUSH
47625: LD_INT 101
47627: PUSH
47628: LD_INT 102
47630: PUSH
47631: LD_INT 103
47633: PUSH
47634: LD_INT 106
47636: PUSH
47637: LD_INT 108
47639: PUSH
47640: LD_INT 112
47642: PUSH
47643: LD_INT 113
47645: PUSH
47646: LD_INT 114
47648: PUSH
47649: LD_INT 116
47651: PUSH
47652: LD_INT 117
47654: PUSH
47655: LD_INT 118
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: PUSH
47671: EMPTY
47672: LIST
47673: LIST
47674: ST_TO_ADDR
47675: GO 48306
47677: LD_INT 17
47679: DOUBLE
47680: EQUAL
47681: IFTRUE 47685
47683: GO 47909
47685: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47686: LD_ADDR_VAR 0 2
47690: PUSH
47691: LD_INT 1
47693: PUSH
47694: LD_INT 2
47696: PUSH
47697: LD_INT 3
47699: PUSH
47700: LD_INT 4
47702: PUSH
47703: LD_INT 5
47705: PUSH
47706: LD_INT 6
47708: PUSH
47709: LD_INT 7
47711: PUSH
47712: LD_INT 8
47714: PUSH
47715: LD_INT 9
47717: PUSH
47718: LD_INT 10
47720: PUSH
47721: LD_INT 11
47723: PUSH
47724: LD_INT 12
47726: PUSH
47727: LD_INT 13
47729: PUSH
47730: LD_INT 14
47732: PUSH
47733: LD_INT 15
47735: PUSH
47736: LD_INT 16
47738: PUSH
47739: LD_INT 17
47741: PUSH
47742: LD_INT 18
47744: PUSH
47745: LD_INT 19
47747: PUSH
47748: LD_INT 20
47750: PUSH
47751: LD_INT 21
47753: PUSH
47754: LD_INT 22
47756: PUSH
47757: LD_INT 23
47759: PUSH
47760: LD_INT 24
47762: PUSH
47763: LD_INT 25
47765: PUSH
47766: LD_INT 26
47768: PUSH
47769: LD_INT 27
47771: PUSH
47772: LD_INT 28
47774: PUSH
47775: LD_INT 29
47777: PUSH
47778: LD_INT 30
47780: PUSH
47781: LD_INT 31
47783: PUSH
47784: LD_INT 32
47786: PUSH
47787: LD_INT 33
47789: PUSH
47790: LD_INT 34
47792: PUSH
47793: LD_INT 36
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: LIST
47800: LIST
47801: LIST
47802: LIST
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: PUSH
47833: LD_INT 101
47835: PUSH
47836: LD_INT 102
47838: PUSH
47839: LD_INT 103
47841: PUSH
47842: LD_INT 104
47844: PUSH
47845: LD_INT 105
47847: PUSH
47848: LD_INT 106
47850: PUSH
47851: LD_INT 107
47853: PUSH
47854: LD_INT 108
47856: PUSH
47857: LD_INT 109
47859: PUSH
47860: LD_INT 110
47862: PUSH
47863: LD_INT 111
47865: PUSH
47866: LD_INT 112
47868: PUSH
47869: LD_INT 113
47871: PUSH
47872: LD_INT 114
47874: PUSH
47875: LD_INT 116
47877: PUSH
47878: LD_INT 117
47880: PUSH
47881: LD_INT 118
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: LIST
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: LIST
47895: LIST
47896: LIST
47897: LIST
47898: LIST
47899: LIST
47900: LIST
47901: LIST
47902: PUSH
47903: EMPTY
47904: LIST
47905: LIST
47906: ST_TO_ADDR
47907: GO 48306
47909: LD_INT 18
47911: DOUBLE
47912: EQUAL
47913: IFTRUE 47917
47915: GO 48065
47917: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47918: LD_ADDR_VAR 0 2
47922: PUSH
47923: LD_INT 2
47925: PUSH
47926: LD_INT 4
47928: PUSH
47929: LD_INT 5
47931: PUSH
47932: LD_INT 7
47934: PUSH
47935: LD_INT 11
47937: PUSH
47938: LD_INT 12
47940: PUSH
47941: LD_INT 15
47943: PUSH
47944: LD_INT 16
47946: PUSH
47947: LD_INT 20
47949: PUSH
47950: LD_INT 21
47952: PUSH
47953: LD_INT 22
47955: PUSH
47956: LD_INT 23
47958: PUSH
47959: LD_INT 25
47961: PUSH
47962: LD_INT 26
47964: PUSH
47965: LD_INT 30
47967: PUSH
47968: LD_INT 31
47970: PUSH
47971: LD_INT 32
47973: PUSH
47974: LD_INT 33
47976: PUSH
47977: LD_INT 34
47979: PUSH
47980: LD_INT 35
47982: PUSH
47983: LD_INT 36
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: PUSH
48009: LD_INT 101
48011: PUSH
48012: LD_INT 102
48014: PUSH
48015: LD_INT 103
48017: PUSH
48018: LD_INT 106
48020: PUSH
48021: LD_INT 108
48023: PUSH
48024: LD_INT 112
48026: PUSH
48027: LD_INT 113
48029: PUSH
48030: LD_INT 114
48032: PUSH
48033: LD_INT 115
48035: PUSH
48036: LD_INT 116
48038: PUSH
48039: LD_INT 117
48041: PUSH
48042: LD_INT 118
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: LIST
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: ST_TO_ADDR
48063: GO 48306
48065: LD_INT 19
48067: DOUBLE
48068: EQUAL
48069: IFTRUE 48073
48071: GO 48305
48073: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48074: LD_ADDR_VAR 0 2
48078: PUSH
48079: LD_INT 1
48081: PUSH
48082: LD_INT 2
48084: PUSH
48085: LD_INT 3
48087: PUSH
48088: LD_INT 4
48090: PUSH
48091: LD_INT 5
48093: PUSH
48094: LD_INT 6
48096: PUSH
48097: LD_INT 7
48099: PUSH
48100: LD_INT 8
48102: PUSH
48103: LD_INT 9
48105: PUSH
48106: LD_INT 10
48108: PUSH
48109: LD_INT 11
48111: PUSH
48112: LD_INT 12
48114: PUSH
48115: LD_INT 13
48117: PUSH
48118: LD_INT 14
48120: PUSH
48121: LD_INT 15
48123: PUSH
48124: LD_INT 16
48126: PUSH
48127: LD_INT 17
48129: PUSH
48130: LD_INT 18
48132: PUSH
48133: LD_INT 19
48135: PUSH
48136: LD_INT 20
48138: PUSH
48139: LD_INT 21
48141: PUSH
48142: LD_INT 22
48144: PUSH
48145: LD_INT 23
48147: PUSH
48148: LD_INT 24
48150: PUSH
48151: LD_INT 25
48153: PUSH
48154: LD_INT 26
48156: PUSH
48157: LD_INT 27
48159: PUSH
48160: LD_INT 28
48162: PUSH
48163: LD_INT 29
48165: PUSH
48166: LD_INT 30
48168: PUSH
48169: LD_INT 31
48171: PUSH
48172: LD_INT 32
48174: PUSH
48175: LD_INT 33
48177: PUSH
48178: LD_INT 34
48180: PUSH
48181: LD_INT 35
48183: PUSH
48184: LD_INT 36
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: LIST
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: LIST
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: PUSH
48225: LD_INT 101
48227: PUSH
48228: LD_INT 102
48230: PUSH
48231: LD_INT 103
48233: PUSH
48234: LD_INT 104
48236: PUSH
48237: LD_INT 105
48239: PUSH
48240: LD_INT 106
48242: PUSH
48243: LD_INT 107
48245: PUSH
48246: LD_INT 108
48248: PUSH
48249: LD_INT 109
48251: PUSH
48252: LD_INT 110
48254: PUSH
48255: LD_INT 111
48257: PUSH
48258: LD_INT 112
48260: PUSH
48261: LD_INT 113
48263: PUSH
48264: LD_INT 114
48266: PUSH
48267: LD_INT 115
48269: PUSH
48270: LD_INT 116
48272: PUSH
48273: LD_INT 117
48275: PUSH
48276: LD_INT 118
48278: PUSH
48279: EMPTY
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: LIST
48287: LIST
48288: LIST
48289: LIST
48290: LIST
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: ST_TO_ADDR
48303: GO 48306
48305: POP
// end else
48306: GO 48537
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48308: LD_ADDR_VAR 0 2
48312: PUSH
48313: LD_INT 1
48315: PUSH
48316: LD_INT 2
48318: PUSH
48319: LD_INT 3
48321: PUSH
48322: LD_INT 4
48324: PUSH
48325: LD_INT 5
48327: PUSH
48328: LD_INT 6
48330: PUSH
48331: LD_INT 7
48333: PUSH
48334: LD_INT 8
48336: PUSH
48337: LD_INT 9
48339: PUSH
48340: LD_INT 10
48342: PUSH
48343: LD_INT 11
48345: PUSH
48346: LD_INT 12
48348: PUSH
48349: LD_INT 13
48351: PUSH
48352: LD_INT 14
48354: PUSH
48355: LD_INT 15
48357: PUSH
48358: LD_INT 16
48360: PUSH
48361: LD_INT 17
48363: PUSH
48364: LD_INT 18
48366: PUSH
48367: LD_INT 19
48369: PUSH
48370: LD_INT 20
48372: PUSH
48373: LD_INT 21
48375: PUSH
48376: LD_INT 22
48378: PUSH
48379: LD_INT 23
48381: PUSH
48382: LD_INT 24
48384: PUSH
48385: LD_INT 25
48387: PUSH
48388: LD_INT 26
48390: PUSH
48391: LD_INT 27
48393: PUSH
48394: LD_INT 28
48396: PUSH
48397: LD_INT 29
48399: PUSH
48400: LD_INT 30
48402: PUSH
48403: LD_INT 31
48405: PUSH
48406: LD_INT 32
48408: PUSH
48409: LD_INT 33
48411: PUSH
48412: LD_INT 34
48414: PUSH
48415: LD_INT 35
48417: PUSH
48418: LD_INT 36
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 101
48461: PUSH
48462: LD_INT 102
48464: PUSH
48465: LD_INT 103
48467: PUSH
48468: LD_INT 104
48470: PUSH
48471: LD_INT 105
48473: PUSH
48474: LD_INT 106
48476: PUSH
48477: LD_INT 107
48479: PUSH
48480: LD_INT 108
48482: PUSH
48483: LD_INT 109
48485: PUSH
48486: LD_INT 110
48488: PUSH
48489: LD_INT 111
48491: PUSH
48492: LD_INT 112
48494: PUSH
48495: LD_INT 113
48497: PUSH
48498: LD_INT 114
48500: PUSH
48501: LD_INT 115
48503: PUSH
48504: LD_INT 116
48506: PUSH
48507: LD_INT 117
48509: PUSH
48510: LD_INT 118
48512: PUSH
48513: EMPTY
48514: LIST
48515: LIST
48516: LIST
48517: LIST
48518: LIST
48519: LIST
48520: LIST
48521: LIST
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: LIST
48530: LIST
48531: LIST
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: ST_TO_ADDR
// if result then
48537: LD_VAR 0 2
48541: IFFALSE 49327
// begin normal :=  ;
48543: LD_ADDR_VAR 0 5
48547: PUSH
48548: LD_STRING 
48550: ST_TO_ADDR
// hardcore :=  ;
48551: LD_ADDR_VAR 0 6
48555: PUSH
48556: LD_STRING 
48558: ST_TO_ADDR
// active :=  ;
48559: LD_ADDR_VAR 0 7
48563: PUSH
48564: LD_STRING 
48566: ST_TO_ADDR
// for i = 1 to normalCounter do
48567: LD_ADDR_VAR 0 8
48571: PUSH
48572: DOUBLE
48573: LD_INT 1
48575: DEC
48576: ST_TO_ADDR
48577: LD_EXP 75
48581: PUSH
48582: FOR_TO
48583: IFFALSE 48684
// begin tmp := 0 ;
48585: LD_ADDR_VAR 0 3
48589: PUSH
48590: LD_STRING 0
48592: ST_TO_ADDR
// if result [ 1 ] then
48593: LD_VAR 0 2
48597: PUSH
48598: LD_INT 1
48600: ARRAY
48601: IFFALSE 48666
// if result [ 1 ] [ 1 ] = i then
48603: LD_VAR 0 2
48607: PUSH
48608: LD_INT 1
48610: ARRAY
48611: PUSH
48612: LD_INT 1
48614: ARRAY
48615: PUSH
48616: LD_VAR 0 8
48620: EQUAL
48621: IFFALSE 48666
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48623: LD_ADDR_VAR 0 2
48627: PUSH
48628: LD_VAR 0 2
48632: PPUSH
48633: LD_INT 1
48635: PPUSH
48636: LD_VAR 0 2
48640: PUSH
48641: LD_INT 1
48643: ARRAY
48644: PPUSH
48645: LD_INT 1
48647: PPUSH
48648: CALL_OW 3
48652: PPUSH
48653: CALL_OW 1
48657: ST_TO_ADDR
// tmp := 1 ;
48658: LD_ADDR_VAR 0 3
48662: PUSH
48663: LD_STRING 1
48665: ST_TO_ADDR
// end ; normal := normal & tmp ;
48666: LD_ADDR_VAR 0 5
48670: PUSH
48671: LD_VAR 0 5
48675: PUSH
48676: LD_VAR 0 3
48680: STR
48681: ST_TO_ADDR
// end ;
48682: GO 48582
48684: POP
48685: POP
// for i = 1 to hardcoreCounter do
48686: LD_ADDR_VAR 0 8
48690: PUSH
48691: DOUBLE
48692: LD_INT 1
48694: DEC
48695: ST_TO_ADDR
48696: LD_EXP 76
48700: PUSH
48701: FOR_TO
48702: IFFALSE 48807
// begin tmp := 0 ;
48704: LD_ADDR_VAR 0 3
48708: PUSH
48709: LD_STRING 0
48711: ST_TO_ADDR
// if result [ 2 ] then
48712: LD_VAR 0 2
48716: PUSH
48717: LD_INT 2
48719: ARRAY
48720: IFFALSE 48789
// if result [ 2 ] [ 1 ] = 100 + i then
48722: LD_VAR 0 2
48726: PUSH
48727: LD_INT 2
48729: ARRAY
48730: PUSH
48731: LD_INT 1
48733: ARRAY
48734: PUSH
48735: LD_INT 100
48737: PUSH
48738: LD_VAR 0 8
48742: PLUS
48743: EQUAL
48744: IFFALSE 48789
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48746: LD_ADDR_VAR 0 2
48750: PUSH
48751: LD_VAR 0 2
48755: PPUSH
48756: LD_INT 2
48758: PPUSH
48759: LD_VAR 0 2
48763: PUSH
48764: LD_INT 2
48766: ARRAY
48767: PPUSH
48768: LD_INT 1
48770: PPUSH
48771: CALL_OW 3
48775: PPUSH
48776: CALL_OW 1
48780: ST_TO_ADDR
// tmp := 1 ;
48781: LD_ADDR_VAR 0 3
48785: PUSH
48786: LD_STRING 1
48788: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48789: LD_ADDR_VAR 0 6
48793: PUSH
48794: LD_VAR 0 6
48798: PUSH
48799: LD_VAR 0 3
48803: STR
48804: ST_TO_ADDR
// end ;
48805: GO 48701
48807: POP
48808: POP
// if isGameLoad then
48809: LD_VAR 0 1
48813: IFFALSE 49288
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48815: LD_ADDR_VAR 0 4
48819: PUSH
48820: LD_EXP 79
48824: PUSH
48825: LD_EXP 78
48829: PUSH
48830: LD_EXP 80
48834: PUSH
48835: LD_EXP 77
48839: PUSH
48840: LD_EXP 81
48844: PUSH
48845: LD_EXP 82
48849: PUSH
48850: LD_EXP 83
48854: PUSH
48855: LD_EXP 84
48859: PUSH
48860: LD_EXP 85
48864: PUSH
48865: LD_EXP 86
48869: PUSH
48870: LD_EXP 87
48874: PUSH
48875: LD_EXP 88
48879: PUSH
48880: LD_EXP 89
48884: PUSH
48885: LD_EXP 90
48889: PUSH
48890: LD_EXP 98
48894: PUSH
48895: LD_EXP 99
48899: PUSH
48900: LD_EXP 100
48904: PUSH
48905: LD_EXP 101
48909: PUSH
48910: LD_EXP 103
48914: PUSH
48915: LD_EXP 104
48919: PUSH
48920: LD_EXP 105
48924: PUSH
48925: LD_EXP 108
48929: PUSH
48930: LD_EXP 110
48934: PUSH
48935: LD_EXP 111
48939: PUSH
48940: LD_EXP 112
48944: PUSH
48945: LD_EXP 114
48949: PUSH
48950: LD_EXP 115
48954: PUSH
48955: LD_EXP 118
48959: PUSH
48960: LD_EXP 119
48964: PUSH
48965: LD_EXP 120
48969: PUSH
48970: LD_EXP 121
48974: PUSH
48975: LD_EXP 122
48979: PUSH
48980: LD_EXP 123
48984: PUSH
48985: LD_EXP 124
48989: PUSH
48990: LD_EXP 125
48994: PUSH
48995: LD_EXP 126
48999: PUSH
49000: LD_EXP 91
49004: PUSH
49005: LD_EXP 92
49009: PUSH
49010: LD_EXP 95
49014: PUSH
49015: LD_EXP 96
49019: PUSH
49020: LD_EXP 97
49024: PUSH
49025: LD_EXP 93
49029: PUSH
49030: LD_EXP 94
49034: PUSH
49035: LD_EXP 102
49039: PUSH
49040: LD_EXP 106
49044: PUSH
49045: LD_EXP 107
49049: PUSH
49050: LD_EXP 109
49054: PUSH
49055: LD_EXP 113
49059: PUSH
49060: LD_EXP 116
49064: PUSH
49065: LD_EXP 117
49069: PUSH
49070: LD_EXP 127
49074: PUSH
49075: LD_EXP 128
49079: PUSH
49080: LD_EXP 129
49084: PUSH
49085: LD_EXP 130
49089: PUSH
49090: EMPTY
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: ST_TO_ADDR
// tmp :=  ;
49146: LD_ADDR_VAR 0 3
49150: PUSH
49151: LD_STRING 
49153: ST_TO_ADDR
// for i = 1 to normalCounter do
49154: LD_ADDR_VAR 0 8
49158: PUSH
49159: DOUBLE
49160: LD_INT 1
49162: DEC
49163: ST_TO_ADDR
49164: LD_EXP 75
49168: PUSH
49169: FOR_TO
49170: IFFALSE 49206
// begin if flags [ i ] then
49172: LD_VAR 0 4
49176: PUSH
49177: LD_VAR 0 8
49181: ARRAY
49182: IFFALSE 49204
// tmp := tmp & i & ; ;
49184: LD_ADDR_VAR 0 3
49188: PUSH
49189: LD_VAR 0 3
49193: PUSH
49194: LD_VAR 0 8
49198: STR
49199: PUSH
49200: LD_STRING ;
49202: STR
49203: ST_TO_ADDR
// end ;
49204: GO 49169
49206: POP
49207: POP
// for i = 1 to hardcoreCounter do
49208: LD_ADDR_VAR 0 8
49212: PUSH
49213: DOUBLE
49214: LD_INT 1
49216: DEC
49217: ST_TO_ADDR
49218: LD_EXP 76
49222: PUSH
49223: FOR_TO
49224: IFFALSE 49270
// begin if flags [ normalCounter + i ] then
49226: LD_VAR 0 4
49230: PUSH
49231: LD_EXP 75
49235: PUSH
49236: LD_VAR 0 8
49240: PLUS
49241: ARRAY
49242: IFFALSE 49268
// tmp := tmp & ( 100 + i ) & ; ;
49244: LD_ADDR_VAR 0 3
49248: PUSH
49249: LD_VAR 0 3
49253: PUSH
49254: LD_INT 100
49256: PUSH
49257: LD_VAR 0 8
49261: PLUS
49262: STR
49263: PUSH
49264: LD_STRING ;
49266: STR
49267: ST_TO_ADDR
// end ;
49268: GO 49223
49270: POP
49271: POP
// if tmp then
49272: LD_VAR 0 3
49276: IFFALSE 49288
// active := tmp ;
49278: LD_ADDR_VAR 0 7
49282: PUSH
49283: LD_VAR 0 3
49287: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49288: LD_STRING getStreamItemsFromMission("
49290: PUSH
49291: LD_VAR 0 5
49295: STR
49296: PUSH
49297: LD_STRING ","
49299: STR
49300: PUSH
49301: LD_VAR 0 6
49305: STR
49306: PUSH
49307: LD_STRING ","
49309: STR
49310: PUSH
49311: LD_VAR 0 7
49315: STR
49316: PUSH
49317: LD_STRING ")
49319: STR
49320: PPUSH
49321: CALL_OW 559
// end else
49325: GO 49334
// ToLua ( getStreamItemsFromMission("","","") ) ;
49327: LD_STRING getStreamItemsFromMission("","","")
49329: PPUSH
49330: CALL_OW 559
// end ;
49334: LD_VAR 0 2
49338: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49339: LD_EXP 74
49343: PUSH
49344: LD_EXP 79
49348: AND
49349: IFFALSE 49473
49351: GO 49353
49353: DISABLE
49354: LD_INT 0
49356: PPUSH
49357: PPUSH
// begin enable ;
49358: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49359: LD_ADDR_VAR 0 2
49363: PUSH
49364: LD_INT 22
49366: PUSH
49367: LD_OWVAR 2
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: PUSH
49376: LD_INT 2
49378: PUSH
49379: LD_INT 34
49381: PUSH
49382: LD_INT 7
49384: PUSH
49385: EMPTY
49386: LIST
49387: LIST
49388: PUSH
49389: LD_INT 34
49391: PUSH
49392: LD_INT 45
49394: PUSH
49395: EMPTY
49396: LIST
49397: LIST
49398: PUSH
49399: LD_INT 34
49401: PUSH
49402: LD_INT 28
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: LD_INT 34
49411: PUSH
49412: LD_INT 47
49414: PUSH
49415: EMPTY
49416: LIST
49417: LIST
49418: PUSH
49419: EMPTY
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: LIST
49425: PUSH
49426: EMPTY
49427: LIST
49428: LIST
49429: PPUSH
49430: CALL_OW 69
49434: ST_TO_ADDR
// if not tmp then
49435: LD_VAR 0 2
49439: NOT
49440: IFFALSE 49444
// exit ;
49442: GO 49473
// for i in tmp do
49444: LD_ADDR_VAR 0 1
49448: PUSH
49449: LD_VAR 0 2
49453: PUSH
49454: FOR_IN
49455: IFFALSE 49471
// begin SetLives ( i , 0 ) ;
49457: LD_VAR 0 1
49461: PPUSH
49462: LD_INT 0
49464: PPUSH
49465: CALL_OW 234
// end ;
49469: GO 49454
49471: POP
49472: POP
// end ;
49473: PPOPN 2
49475: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49476: LD_EXP 74
49480: PUSH
49481: LD_EXP 80
49485: AND
49486: IFFALSE 49570
49488: GO 49490
49490: DISABLE
49491: LD_INT 0
49493: PPUSH
49494: PPUSH
// begin enable ;
49495: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49496: LD_ADDR_VAR 0 2
49500: PUSH
49501: LD_INT 22
49503: PUSH
49504: LD_OWVAR 2
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: LD_INT 32
49515: PUSH
49516: LD_INT 3
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PUSH
49523: EMPTY
49524: LIST
49525: LIST
49526: PPUSH
49527: CALL_OW 69
49531: ST_TO_ADDR
// if not tmp then
49532: LD_VAR 0 2
49536: NOT
49537: IFFALSE 49541
// exit ;
49539: GO 49570
// for i in tmp do
49541: LD_ADDR_VAR 0 1
49545: PUSH
49546: LD_VAR 0 2
49550: PUSH
49551: FOR_IN
49552: IFFALSE 49568
// begin SetLives ( i , 0 ) ;
49554: LD_VAR 0 1
49558: PPUSH
49559: LD_INT 0
49561: PPUSH
49562: CALL_OW 234
// end ;
49566: GO 49551
49568: POP
49569: POP
// end ;
49570: PPOPN 2
49572: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49573: LD_EXP 74
49577: PUSH
49578: LD_EXP 77
49582: AND
49583: IFFALSE 49676
49585: GO 49587
49587: DISABLE
49588: LD_INT 0
49590: PPUSH
// begin enable ;
49591: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49592: LD_ADDR_VAR 0 1
49596: PUSH
49597: LD_INT 22
49599: PUSH
49600: LD_OWVAR 2
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: PUSH
49609: LD_INT 2
49611: PUSH
49612: LD_INT 25
49614: PUSH
49615: LD_INT 5
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: PUSH
49622: LD_INT 25
49624: PUSH
49625: LD_INT 9
49627: PUSH
49628: EMPTY
49629: LIST
49630: LIST
49631: PUSH
49632: LD_INT 25
49634: PUSH
49635: LD_INT 8
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PUSH
49642: EMPTY
49643: LIST
49644: LIST
49645: LIST
49646: LIST
49647: PUSH
49648: EMPTY
49649: LIST
49650: LIST
49651: PPUSH
49652: CALL_OW 69
49656: PUSH
49657: FOR_IN
49658: IFFALSE 49674
// begin SetClass ( i , 1 ) ;
49660: LD_VAR 0 1
49664: PPUSH
49665: LD_INT 1
49667: PPUSH
49668: CALL_OW 336
// end ;
49672: GO 49657
49674: POP
49675: POP
// end ;
49676: PPOPN 1
49678: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49679: LD_EXP 74
49683: PUSH
49684: LD_EXP 78
49688: AND
49689: PUSH
49690: LD_OWVAR 65
49694: PUSH
49695: LD_INT 7
49697: LESS
49698: AND
49699: IFFALSE 49713
49701: GO 49703
49703: DISABLE
// begin enable ;
49704: ENABLE
// game_speed := 7 ;
49705: LD_ADDR_OWVAR 65
49709: PUSH
49710: LD_INT 7
49712: ST_TO_ADDR
// end ;
49713: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49714: LD_EXP 74
49718: PUSH
49719: LD_EXP 81
49723: AND
49724: IFFALSE 49926
49726: GO 49728
49728: DISABLE
49729: LD_INT 0
49731: PPUSH
49732: PPUSH
49733: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49734: LD_ADDR_VAR 0 3
49738: PUSH
49739: LD_INT 81
49741: PUSH
49742: LD_OWVAR 2
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 21
49753: PUSH
49754: LD_INT 1
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: EMPTY
49762: LIST
49763: LIST
49764: PPUSH
49765: CALL_OW 69
49769: ST_TO_ADDR
// if not tmp then
49770: LD_VAR 0 3
49774: NOT
49775: IFFALSE 49779
// exit ;
49777: GO 49926
// if tmp > 5 then
49779: LD_VAR 0 3
49783: PUSH
49784: LD_INT 5
49786: GREATER
49787: IFFALSE 49799
// k := 5 else
49789: LD_ADDR_VAR 0 2
49793: PUSH
49794: LD_INT 5
49796: ST_TO_ADDR
49797: GO 49809
// k := tmp ;
49799: LD_ADDR_VAR 0 2
49803: PUSH
49804: LD_VAR 0 3
49808: ST_TO_ADDR
// for i := 1 to k do
49809: LD_ADDR_VAR 0 1
49813: PUSH
49814: DOUBLE
49815: LD_INT 1
49817: DEC
49818: ST_TO_ADDR
49819: LD_VAR 0 2
49823: PUSH
49824: FOR_TO
49825: IFFALSE 49924
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49827: LD_VAR 0 3
49831: PUSH
49832: LD_VAR 0 1
49836: ARRAY
49837: PPUSH
49838: LD_VAR 0 1
49842: PUSH
49843: LD_INT 4
49845: MOD
49846: PUSH
49847: LD_INT 1
49849: PLUS
49850: PPUSH
49851: CALL_OW 259
49855: PUSH
49856: LD_INT 10
49858: LESS
49859: IFFALSE 49922
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49861: LD_VAR 0 3
49865: PUSH
49866: LD_VAR 0 1
49870: ARRAY
49871: PPUSH
49872: LD_VAR 0 1
49876: PUSH
49877: LD_INT 4
49879: MOD
49880: PUSH
49881: LD_INT 1
49883: PLUS
49884: PPUSH
49885: LD_VAR 0 3
49889: PUSH
49890: LD_VAR 0 1
49894: ARRAY
49895: PPUSH
49896: LD_VAR 0 1
49900: PUSH
49901: LD_INT 4
49903: MOD
49904: PUSH
49905: LD_INT 1
49907: PLUS
49908: PPUSH
49909: CALL_OW 259
49913: PUSH
49914: LD_INT 1
49916: PLUS
49917: PPUSH
49918: CALL_OW 237
49922: GO 49824
49924: POP
49925: POP
// end ;
49926: PPOPN 3
49928: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49929: LD_EXP 74
49933: PUSH
49934: LD_EXP 82
49938: AND
49939: IFFALSE 49959
49941: GO 49943
49943: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49944: LD_INT 4
49946: PPUSH
49947: LD_OWVAR 2
49951: PPUSH
49952: LD_INT 0
49954: PPUSH
49955: CALL_OW 324
49959: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49960: LD_EXP 74
49964: PUSH
49965: LD_EXP 111
49969: AND
49970: IFFALSE 49990
49972: GO 49974
49974: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49975: LD_INT 19
49977: PPUSH
49978: LD_OWVAR 2
49982: PPUSH
49983: LD_INT 0
49985: PPUSH
49986: CALL_OW 324
49990: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49991: LD_EXP 74
49995: PUSH
49996: LD_EXP 83
50000: AND
50001: IFFALSE 50103
50003: GO 50005
50005: DISABLE
50006: LD_INT 0
50008: PPUSH
50009: PPUSH
// begin enable ;
50010: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
50011: LD_ADDR_VAR 0 2
50015: PUSH
50016: LD_INT 22
50018: PUSH
50019: LD_OWVAR 2
50023: PUSH
50024: EMPTY
50025: LIST
50026: LIST
50027: PUSH
50028: LD_INT 2
50030: PUSH
50031: LD_INT 34
50033: PUSH
50034: LD_INT 11
50036: PUSH
50037: EMPTY
50038: LIST
50039: LIST
50040: PUSH
50041: LD_INT 34
50043: PUSH
50044: LD_INT 30
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: LIST
50055: PUSH
50056: EMPTY
50057: LIST
50058: LIST
50059: PPUSH
50060: CALL_OW 69
50064: ST_TO_ADDR
// if not tmp then
50065: LD_VAR 0 2
50069: NOT
50070: IFFALSE 50074
// exit ;
50072: GO 50103
// for i in tmp do
50074: LD_ADDR_VAR 0 1
50078: PUSH
50079: LD_VAR 0 2
50083: PUSH
50084: FOR_IN
50085: IFFALSE 50101
// begin SetLives ( i , 0 ) ;
50087: LD_VAR 0 1
50091: PPUSH
50092: LD_INT 0
50094: PPUSH
50095: CALL_OW 234
// end ;
50099: GO 50084
50101: POP
50102: POP
// end ;
50103: PPOPN 2
50105: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50106: LD_EXP 74
50110: PUSH
50111: LD_EXP 84
50115: AND
50116: IFFALSE 50136
50118: GO 50120
50120: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50121: LD_INT 32
50123: PPUSH
50124: LD_OWVAR 2
50128: PPUSH
50129: LD_INT 0
50131: PPUSH
50132: CALL_OW 324
50136: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50137: LD_EXP 74
50141: PUSH
50142: LD_EXP 85
50146: AND
50147: IFFALSE 50328
50149: GO 50151
50151: DISABLE
50152: LD_INT 0
50154: PPUSH
50155: PPUSH
50156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50157: LD_ADDR_VAR 0 2
50161: PUSH
50162: LD_INT 22
50164: PUSH
50165: LD_OWVAR 2
50169: PUSH
50170: EMPTY
50171: LIST
50172: LIST
50173: PUSH
50174: LD_INT 33
50176: PUSH
50177: LD_INT 3
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PPUSH
50188: CALL_OW 69
50192: ST_TO_ADDR
// if not tmp then
50193: LD_VAR 0 2
50197: NOT
50198: IFFALSE 50202
// exit ;
50200: GO 50328
// side := 0 ;
50202: LD_ADDR_VAR 0 3
50206: PUSH
50207: LD_INT 0
50209: ST_TO_ADDR
// for i := 1 to 8 do
50210: LD_ADDR_VAR 0 1
50214: PUSH
50215: DOUBLE
50216: LD_INT 1
50218: DEC
50219: ST_TO_ADDR
50220: LD_INT 8
50222: PUSH
50223: FOR_TO
50224: IFFALSE 50272
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50226: LD_OWVAR 2
50230: PUSH
50231: LD_VAR 0 1
50235: NONEQUAL
50236: PUSH
50237: LD_OWVAR 2
50241: PPUSH
50242: LD_VAR 0 1
50246: PPUSH
50247: CALL_OW 81
50251: PUSH
50252: LD_INT 2
50254: EQUAL
50255: AND
50256: IFFALSE 50270
// begin side := i ;
50258: LD_ADDR_VAR 0 3
50262: PUSH
50263: LD_VAR 0 1
50267: ST_TO_ADDR
// break ;
50268: GO 50272
// end ;
50270: GO 50223
50272: POP
50273: POP
// if not side then
50274: LD_VAR 0 3
50278: NOT
50279: IFFALSE 50283
// exit ;
50281: GO 50328
// for i := 1 to tmp do
50283: LD_ADDR_VAR 0 1
50287: PUSH
50288: DOUBLE
50289: LD_INT 1
50291: DEC
50292: ST_TO_ADDR
50293: LD_VAR 0 2
50297: PUSH
50298: FOR_TO
50299: IFFALSE 50326
// if Prob ( 60 ) then
50301: LD_INT 60
50303: PPUSH
50304: CALL_OW 13
50308: IFFALSE 50324
// SetSide ( i , side ) ;
50310: LD_VAR 0 1
50314: PPUSH
50315: LD_VAR 0 3
50319: PPUSH
50320: CALL_OW 235
50324: GO 50298
50326: POP
50327: POP
// end ;
50328: PPOPN 3
50330: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50331: LD_EXP 74
50335: PUSH
50336: LD_EXP 87
50340: AND
50341: IFFALSE 50460
50343: GO 50345
50345: DISABLE
50346: LD_INT 0
50348: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50349: LD_ADDR_VAR 0 1
50353: PUSH
50354: LD_INT 22
50356: PUSH
50357: LD_OWVAR 2
50361: PUSH
50362: EMPTY
50363: LIST
50364: LIST
50365: PUSH
50366: LD_INT 21
50368: PUSH
50369: LD_INT 1
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 3
50378: PUSH
50379: LD_INT 23
50381: PUSH
50382: LD_INT 0
50384: PUSH
50385: EMPTY
50386: LIST
50387: LIST
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: EMPTY
50394: LIST
50395: LIST
50396: LIST
50397: PPUSH
50398: CALL_OW 69
50402: PUSH
50403: FOR_IN
50404: IFFALSE 50458
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50406: LD_VAR 0 1
50410: PPUSH
50411: CALL_OW 257
50415: PUSH
50416: LD_INT 1
50418: PUSH
50419: LD_INT 2
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: LD_INT 4
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: IN
50434: IFFALSE 50456
// SetClass ( un , rand ( 1 , 4 ) ) ;
50436: LD_VAR 0 1
50440: PPUSH
50441: LD_INT 1
50443: PPUSH
50444: LD_INT 4
50446: PPUSH
50447: CALL_OW 12
50451: PPUSH
50452: CALL_OW 336
50456: GO 50403
50458: POP
50459: POP
// end ;
50460: PPOPN 1
50462: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50463: LD_EXP 74
50467: PUSH
50468: LD_EXP 86
50472: AND
50473: IFFALSE 50552
50475: GO 50477
50477: DISABLE
50478: LD_INT 0
50480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50481: LD_ADDR_VAR 0 1
50485: PUSH
50486: LD_INT 22
50488: PUSH
50489: LD_OWVAR 2
50493: PUSH
50494: EMPTY
50495: LIST
50496: LIST
50497: PUSH
50498: LD_INT 21
50500: PUSH
50501: LD_INT 3
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: PPUSH
50512: CALL_OW 69
50516: ST_TO_ADDR
// if not tmp then
50517: LD_VAR 0 1
50521: NOT
50522: IFFALSE 50526
// exit ;
50524: GO 50552
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50526: LD_VAR 0 1
50530: PUSH
50531: LD_INT 1
50533: PPUSH
50534: LD_VAR 0 1
50538: PPUSH
50539: CALL_OW 12
50543: ARRAY
50544: PPUSH
50545: LD_INT 100
50547: PPUSH
50548: CALL_OW 234
// end ;
50552: PPOPN 1
50554: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50555: LD_EXP 74
50559: PUSH
50560: LD_EXP 88
50564: AND
50565: IFFALSE 50663
50567: GO 50569
50569: DISABLE
50570: LD_INT 0
50572: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50573: LD_ADDR_VAR 0 1
50577: PUSH
50578: LD_INT 22
50580: PUSH
50581: LD_OWVAR 2
50585: PUSH
50586: EMPTY
50587: LIST
50588: LIST
50589: PUSH
50590: LD_INT 21
50592: PUSH
50593: LD_INT 1
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: PPUSH
50604: CALL_OW 69
50608: ST_TO_ADDR
// if not tmp then
50609: LD_VAR 0 1
50613: NOT
50614: IFFALSE 50618
// exit ;
50616: GO 50663
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50618: LD_VAR 0 1
50622: PUSH
50623: LD_INT 1
50625: PPUSH
50626: LD_VAR 0 1
50630: PPUSH
50631: CALL_OW 12
50635: ARRAY
50636: PPUSH
50637: LD_INT 1
50639: PPUSH
50640: LD_INT 4
50642: PPUSH
50643: CALL_OW 12
50647: PPUSH
50648: LD_INT 3000
50650: PPUSH
50651: LD_INT 9000
50653: PPUSH
50654: CALL_OW 12
50658: PPUSH
50659: CALL_OW 492
// end ;
50663: PPOPN 1
50665: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50666: LD_EXP 74
50670: PUSH
50671: LD_EXP 89
50675: AND
50676: IFFALSE 50696
50678: GO 50680
50680: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50681: LD_INT 1
50683: PPUSH
50684: LD_OWVAR 2
50688: PPUSH
50689: LD_INT 0
50691: PPUSH
50692: CALL_OW 324
50696: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50697: LD_EXP 74
50701: PUSH
50702: LD_EXP 90
50706: AND
50707: IFFALSE 50790
50709: GO 50711
50711: DISABLE
50712: LD_INT 0
50714: PPUSH
50715: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50716: LD_ADDR_VAR 0 2
50720: PUSH
50721: LD_INT 22
50723: PUSH
50724: LD_OWVAR 2
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: PUSH
50733: LD_INT 21
50735: PUSH
50736: LD_INT 3
50738: PUSH
50739: EMPTY
50740: LIST
50741: LIST
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PPUSH
50747: CALL_OW 69
50751: ST_TO_ADDR
// if not tmp then
50752: LD_VAR 0 2
50756: NOT
50757: IFFALSE 50761
// exit ;
50759: GO 50790
// for i in tmp do
50761: LD_ADDR_VAR 0 1
50765: PUSH
50766: LD_VAR 0 2
50770: PUSH
50771: FOR_IN
50772: IFFALSE 50788
// SetBLevel ( i , 10 ) ;
50774: LD_VAR 0 1
50778: PPUSH
50779: LD_INT 10
50781: PPUSH
50782: CALL_OW 241
50786: GO 50771
50788: POP
50789: POP
// end ;
50790: PPOPN 2
50792: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50793: LD_EXP 74
50797: PUSH
50798: LD_EXP 91
50802: AND
50803: IFFALSE 50914
50805: GO 50807
50807: DISABLE
50808: LD_INT 0
50810: PPUSH
50811: PPUSH
50812: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50813: LD_ADDR_VAR 0 3
50817: PUSH
50818: LD_INT 22
50820: PUSH
50821: LD_OWVAR 2
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: PUSH
50830: LD_INT 25
50832: PUSH
50833: LD_INT 1
50835: PUSH
50836: EMPTY
50837: LIST
50838: LIST
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PPUSH
50844: CALL_OW 69
50848: ST_TO_ADDR
// if not tmp then
50849: LD_VAR 0 3
50853: NOT
50854: IFFALSE 50858
// exit ;
50856: GO 50914
// un := tmp [ rand ( 1 , tmp ) ] ;
50858: LD_ADDR_VAR 0 2
50862: PUSH
50863: LD_VAR 0 3
50867: PUSH
50868: LD_INT 1
50870: PPUSH
50871: LD_VAR 0 3
50875: PPUSH
50876: CALL_OW 12
50880: ARRAY
50881: ST_TO_ADDR
// if Crawls ( un ) then
50882: LD_VAR 0 2
50886: PPUSH
50887: CALL_OW 318
50891: IFFALSE 50902
// ComWalk ( un ) ;
50893: LD_VAR 0 2
50897: PPUSH
50898: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50902: LD_VAR 0 2
50906: PPUSH
50907: LD_INT 5
50909: PPUSH
50910: CALL_OW 336
// end ;
50914: PPOPN 3
50916: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50917: LD_EXP 74
50921: PUSH
50922: LD_EXP 92
50926: AND
50927: PUSH
50928: LD_OWVAR 67
50932: PUSH
50933: LD_INT 4
50935: LESS
50936: AND
50937: IFFALSE 50956
50939: GO 50941
50941: DISABLE
// begin Difficulty := Difficulty + 1 ;
50942: LD_ADDR_OWVAR 67
50946: PUSH
50947: LD_OWVAR 67
50951: PUSH
50952: LD_INT 1
50954: PLUS
50955: ST_TO_ADDR
// end ;
50956: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50957: LD_EXP 74
50961: PUSH
50962: LD_EXP 93
50966: AND
50967: IFFALSE 51070
50969: GO 50971
50971: DISABLE
50972: LD_INT 0
50974: PPUSH
// begin for i := 1 to 5 do
50975: LD_ADDR_VAR 0 1
50979: PUSH
50980: DOUBLE
50981: LD_INT 1
50983: DEC
50984: ST_TO_ADDR
50985: LD_INT 5
50987: PUSH
50988: FOR_TO
50989: IFFALSE 51068
// begin uc_nation := nation_nature ;
50991: LD_ADDR_OWVAR 21
50995: PUSH
50996: LD_INT 0
50998: ST_TO_ADDR
// uc_side := 0 ;
50999: LD_ADDR_OWVAR 20
51003: PUSH
51004: LD_INT 0
51006: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51007: LD_ADDR_OWVAR 29
51011: PUSH
51012: LD_INT 12
51014: PUSH
51015: LD_INT 12
51017: PUSH
51018: EMPTY
51019: LIST
51020: LIST
51021: ST_TO_ADDR
// hc_agressivity := 20 ;
51022: LD_ADDR_OWVAR 35
51026: PUSH
51027: LD_INT 20
51029: ST_TO_ADDR
// hc_class := class_tiger ;
51030: LD_ADDR_OWVAR 28
51034: PUSH
51035: LD_INT 14
51037: ST_TO_ADDR
// hc_gallery :=  ;
51038: LD_ADDR_OWVAR 33
51042: PUSH
51043: LD_STRING 
51045: ST_TO_ADDR
// hc_name :=  ;
51046: LD_ADDR_OWVAR 26
51050: PUSH
51051: LD_STRING 
51053: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51054: CALL_OW 44
51058: PPUSH
51059: LD_INT 0
51061: PPUSH
51062: CALL_OW 51
// end ;
51066: GO 50988
51068: POP
51069: POP
// end ;
51070: PPOPN 1
51072: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51073: LD_EXP 74
51077: PUSH
51078: LD_EXP 94
51082: AND
51083: IFFALSE 51092
51085: GO 51087
51087: DISABLE
// StreamSibBomb ;
51088: CALL 51093 0 0
51092: END
// export function StreamSibBomb ; var i , x , y ; begin
51093: LD_INT 0
51095: PPUSH
51096: PPUSH
51097: PPUSH
51098: PPUSH
// result := false ;
51099: LD_ADDR_VAR 0 1
51103: PUSH
51104: LD_INT 0
51106: ST_TO_ADDR
// for i := 1 to 16 do
51107: LD_ADDR_VAR 0 2
51111: PUSH
51112: DOUBLE
51113: LD_INT 1
51115: DEC
51116: ST_TO_ADDR
51117: LD_INT 16
51119: PUSH
51120: FOR_TO
51121: IFFALSE 51320
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51123: LD_ADDR_VAR 0 3
51127: PUSH
51128: LD_INT 10
51130: PUSH
51131: LD_INT 20
51133: PUSH
51134: LD_INT 30
51136: PUSH
51137: LD_INT 40
51139: PUSH
51140: LD_INT 50
51142: PUSH
51143: LD_INT 60
51145: PUSH
51146: LD_INT 70
51148: PUSH
51149: LD_INT 80
51151: PUSH
51152: LD_INT 90
51154: PUSH
51155: LD_INT 100
51157: PUSH
51158: LD_INT 110
51160: PUSH
51161: LD_INT 120
51163: PUSH
51164: LD_INT 130
51166: PUSH
51167: LD_INT 140
51169: PUSH
51170: LD_INT 150
51172: PUSH
51173: EMPTY
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: PUSH
51190: LD_INT 1
51192: PPUSH
51193: LD_INT 15
51195: PPUSH
51196: CALL_OW 12
51200: ARRAY
51201: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51202: LD_ADDR_VAR 0 4
51206: PUSH
51207: LD_INT 10
51209: PUSH
51210: LD_INT 20
51212: PUSH
51213: LD_INT 30
51215: PUSH
51216: LD_INT 40
51218: PUSH
51219: LD_INT 50
51221: PUSH
51222: LD_INT 60
51224: PUSH
51225: LD_INT 70
51227: PUSH
51228: LD_INT 80
51230: PUSH
51231: LD_INT 90
51233: PUSH
51234: LD_INT 100
51236: PUSH
51237: LD_INT 110
51239: PUSH
51240: LD_INT 120
51242: PUSH
51243: LD_INT 130
51245: PUSH
51246: LD_INT 140
51248: PUSH
51249: LD_INT 150
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: PUSH
51269: LD_INT 1
51271: PPUSH
51272: LD_INT 15
51274: PPUSH
51275: CALL_OW 12
51279: ARRAY
51280: ST_TO_ADDR
// if ValidHex ( x , y ) then
51281: LD_VAR 0 3
51285: PPUSH
51286: LD_VAR 0 4
51290: PPUSH
51291: CALL_OW 488
51295: IFFALSE 51318
// begin result := [ x , y ] ;
51297: LD_ADDR_VAR 0 1
51301: PUSH
51302: LD_VAR 0 3
51306: PUSH
51307: LD_VAR 0 4
51311: PUSH
51312: EMPTY
51313: LIST
51314: LIST
51315: ST_TO_ADDR
// break ;
51316: GO 51320
// end ; end ;
51318: GO 51120
51320: POP
51321: POP
// if result then
51322: LD_VAR 0 1
51326: IFFALSE 51386
// begin ToLua ( playSibBomb() ) ;
51328: LD_STRING playSibBomb()
51330: PPUSH
51331: CALL_OW 559
// wait ( 0 0$14 ) ;
51335: LD_INT 490
51337: PPUSH
51338: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51342: LD_VAR 0 1
51346: PUSH
51347: LD_INT 1
51349: ARRAY
51350: PPUSH
51351: LD_VAR 0 1
51355: PUSH
51356: LD_INT 2
51358: ARRAY
51359: PPUSH
51360: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51364: LD_VAR 0 1
51368: PUSH
51369: LD_INT 1
51371: ARRAY
51372: PPUSH
51373: LD_VAR 0 1
51377: PUSH
51378: LD_INT 2
51380: ARRAY
51381: PPUSH
51382: CALL_OW 429
// end ; end ;
51386: LD_VAR 0 1
51390: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51391: LD_EXP 74
51395: PUSH
51396: LD_EXP 96
51400: AND
51401: IFFALSE 51413
51403: GO 51405
51405: DISABLE
// YouLost (  ) ;
51406: LD_STRING 
51408: PPUSH
51409: CALL_OW 104
51413: END
// every 0 0$1 trigger StreamModeActive and sFog do
51414: LD_EXP 74
51418: PUSH
51419: LD_EXP 95
51423: AND
51424: IFFALSE 51438
51426: GO 51428
51428: DISABLE
// FogOff ( your_side ) ;
51429: LD_OWVAR 2
51433: PPUSH
51434: CALL_OW 344
51438: END
// every 0 0$1 trigger StreamModeActive and sSun do
51439: LD_EXP 74
51443: PUSH
51444: LD_EXP 97
51448: AND
51449: IFFALSE 51477
51451: GO 51453
51453: DISABLE
// begin solar_recharge_percent := 0 ;
51454: LD_ADDR_OWVAR 79
51458: PUSH
51459: LD_INT 0
51461: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51462: LD_INT 10500
51464: PPUSH
51465: CALL_OW 67
// solar_recharge_percent := 100 ;
51469: LD_ADDR_OWVAR 79
51473: PUSH
51474: LD_INT 100
51476: ST_TO_ADDR
// end ;
51477: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51478: LD_EXP 74
51482: PUSH
51483: LD_EXP 98
51487: AND
51488: IFFALSE 51727
51490: GO 51492
51492: DISABLE
51493: LD_INT 0
51495: PPUSH
51496: PPUSH
51497: PPUSH
// begin tmp := [ ] ;
51498: LD_ADDR_VAR 0 3
51502: PUSH
51503: EMPTY
51504: ST_TO_ADDR
// for i := 1 to 6 do
51505: LD_ADDR_VAR 0 1
51509: PUSH
51510: DOUBLE
51511: LD_INT 1
51513: DEC
51514: ST_TO_ADDR
51515: LD_INT 6
51517: PUSH
51518: FOR_TO
51519: IFFALSE 51624
// begin uc_nation := nation_nature ;
51521: LD_ADDR_OWVAR 21
51525: PUSH
51526: LD_INT 0
51528: ST_TO_ADDR
// uc_side := 0 ;
51529: LD_ADDR_OWVAR 20
51533: PUSH
51534: LD_INT 0
51536: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51537: LD_ADDR_OWVAR 29
51541: PUSH
51542: LD_INT 12
51544: PUSH
51545: LD_INT 12
51547: PUSH
51548: EMPTY
51549: LIST
51550: LIST
51551: ST_TO_ADDR
// hc_agressivity := 20 ;
51552: LD_ADDR_OWVAR 35
51556: PUSH
51557: LD_INT 20
51559: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51560: LD_ADDR_OWVAR 28
51564: PUSH
51565: LD_INT 17
51567: ST_TO_ADDR
// hc_gallery :=  ;
51568: LD_ADDR_OWVAR 33
51572: PUSH
51573: LD_STRING 
51575: ST_TO_ADDR
// hc_name :=  ;
51576: LD_ADDR_OWVAR 26
51580: PUSH
51581: LD_STRING 
51583: ST_TO_ADDR
// un := CreateHuman ;
51584: LD_ADDR_VAR 0 2
51588: PUSH
51589: CALL_OW 44
51593: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51594: LD_VAR 0 2
51598: PPUSH
51599: LD_INT 1
51601: PPUSH
51602: CALL_OW 51
// tmp := tmp ^ un ;
51606: LD_ADDR_VAR 0 3
51610: PUSH
51611: LD_VAR 0 3
51615: PUSH
51616: LD_VAR 0 2
51620: ADD
51621: ST_TO_ADDR
// end ;
51622: GO 51518
51624: POP
51625: POP
// repeat wait ( 0 0$1 ) ;
51626: LD_INT 35
51628: PPUSH
51629: CALL_OW 67
// for un in tmp do
51633: LD_ADDR_VAR 0 2
51637: PUSH
51638: LD_VAR 0 3
51642: PUSH
51643: FOR_IN
51644: IFFALSE 51718
// begin if IsDead ( un ) then
51646: LD_VAR 0 2
51650: PPUSH
51651: CALL_OW 301
51655: IFFALSE 51675
// begin tmp := tmp diff un ;
51657: LD_ADDR_VAR 0 3
51661: PUSH
51662: LD_VAR 0 3
51666: PUSH
51667: LD_VAR 0 2
51671: DIFF
51672: ST_TO_ADDR
// continue ;
51673: GO 51643
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51675: LD_VAR 0 2
51679: PPUSH
51680: LD_INT 3
51682: PUSH
51683: LD_INT 22
51685: PUSH
51686: LD_INT 0
51688: PUSH
51689: EMPTY
51690: LIST
51691: LIST
51692: PUSH
51693: EMPTY
51694: LIST
51695: LIST
51696: PPUSH
51697: CALL_OW 69
51701: PPUSH
51702: LD_VAR 0 2
51706: PPUSH
51707: CALL_OW 74
51711: PPUSH
51712: CALL_OW 115
// end ;
51716: GO 51643
51718: POP
51719: POP
// until not tmp ;
51720: LD_VAR 0 3
51724: NOT
51725: IFFALSE 51626
// end ;
51727: PPOPN 3
51729: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51730: LD_EXP 74
51734: PUSH
51735: LD_EXP 99
51739: AND
51740: IFFALSE 51794
51742: GO 51744
51744: DISABLE
// begin ToLua ( displayTroll(); ) ;
51745: LD_STRING displayTroll();
51747: PPUSH
51748: CALL_OW 559
// wait ( 3 3$00 ) ;
51752: LD_INT 6300
51754: PPUSH
51755: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51759: LD_STRING hideTroll();
51761: PPUSH
51762: CALL_OW 559
// wait ( 1 1$00 ) ;
51766: LD_INT 2100
51768: PPUSH
51769: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51773: LD_STRING displayTroll();
51775: PPUSH
51776: CALL_OW 559
// wait ( 1 1$00 ) ;
51780: LD_INT 2100
51782: PPUSH
51783: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51787: LD_STRING hideTroll();
51789: PPUSH
51790: CALL_OW 559
// end ;
51794: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51795: LD_EXP 74
51799: PUSH
51800: LD_EXP 100
51804: AND
51805: IFFALSE 51868
51807: GO 51809
51809: DISABLE
51810: LD_INT 0
51812: PPUSH
// begin p := 0 ;
51813: LD_ADDR_VAR 0 1
51817: PUSH
51818: LD_INT 0
51820: ST_TO_ADDR
// repeat game_speed := 1 ;
51821: LD_ADDR_OWVAR 65
51825: PUSH
51826: LD_INT 1
51828: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51829: LD_INT 35
51831: PPUSH
51832: CALL_OW 67
// p := p + 1 ;
51836: LD_ADDR_VAR 0 1
51840: PUSH
51841: LD_VAR 0 1
51845: PUSH
51846: LD_INT 1
51848: PLUS
51849: ST_TO_ADDR
// until p >= 60 ;
51850: LD_VAR 0 1
51854: PUSH
51855: LD_INT 60
51857: GREATEREQUAL
51858: IFFALSE 51821
// game_speed := 4 ;
51860: LD_ADDR_OWVAR 65
51864: PUSH
51865: LD_INT 4
51867: ST_TO_ADDR
// end ;
51868: PPOPN 1
51870: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51871: LD_EXP 74
51875: PUSH
51876: LD_EXP 101
51880: AND
51881: IFFALSE 52027
51883: GO 51885
51885: DISABLE
51886: LD_INT 0
51888: PPUSH
51889: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51890: LD_ADDR_VAR 0 1
51894: PUSH
51895: LD_INT 22
51897: PUSH
51898: LD_OWVAR 2
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: PUSH
51907: LD_INT 2
51909: PUSH
51910: LD_INT 30
51912: PUSH
51913: LD_INT 0
51915: PUSH
51916: EMPTY
51917: LIST
51918: LIST
51919: PUSH
51920: LD_INT 30
51922: PUSH
51923: LD_INT 1
51925: PUSH
51926: EMPTY
51927: LIST
51928: LIST
51929: PUSH
51930: EMPTY
51931: LIST
51932: LIST
51933: LIST
51934: PUSH
51935: EMPTY
51936: LIST
51937: LIST
51938: PPUSH
51939: CALL_OW 69
51943: ST_TO_ADDR
// if not depot then
51944: LD_VAR 0 1
51948: NOT
51949: IFFALSE 51953
// exit ;
51951: GO 52027
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51953: LD_ADDR_VAR 0 2
51957: PUSH
51958: LD_VAR 0 1
51962: PUSH
51963: LD_INT 1
51965: PPUSH
51966: LD_VAR 0 1
51970: PPUSH
51971: CALL_OW 12
51975: ARRAY
51976: PPUSH
51977: CALL_OW 274
51981: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51982: LD_VAR 0 2
51986: PPUSH
51987: LD_INT 1
51989: PPUSH
51990: LD_INT 0
51992: PPUSH
51993: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51997: LD_VAR 0 2
52001: PPUSH
52002: LD_INT 2
52004: PPUSH
52005: LD_INT 0
52007: PPUSH
52008: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
52012: LD_VAR 0 2
52016: PPUSH
52017: LD_INT 3
52019: PPUSH
52020: LD_INT 0
52022: PPUSH
52023: CALL_OW 277
// end ;
52027: PPOPN 2
52029: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52030: LD_EXP 74
52034: PUSH
52035: LD_EXP 102
52039: AND
52040: IFFALSE 52137
52042: GO 52044
52044: DISABLE
52045: LD_INT 0
52047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52048: LD_ADDR_VAR 0 1
52052: PUSH
52053: LD_INT 22
52055: PUSH
52056: LD_OWVAR 2
52060: PUSH
52061: EMPTY
52062: LIST
52063: LIST
52064: PUSH
52065: LD_INT 21
52067: PUSH
52068: LD_INT 1
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: PUSH
52075: LD_INT 3
52077: PUSH
52078: LD_INT 23
52080: PUSH
52081: LD_INT 0
52083: PUSH
52084: EMPTY
52085: LIST
52086: LIST
52087: PUSH
52088: EMPTY
52089: LIST
52090: LIST
52091: PUSH
52092: EMPTY
52093: LIST
52094: LIST
52095: LIST
52096: PPUSH
52097: CALL_OW 69
52101: ST_TO_ADDR
// if not tmp then
52102: LD_VAR 0 1
52106: NOT
52107: IFFALSE 52111
// exit ;
52109: GO 52137
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52111: LD_VAR 0 1
52115: PUSH
52116: LD_INT 1
52118: PPUSH
52119: LD_VAR 0 1
52123: PPUSH
52124: CALL_OW 12
52128: ARRAY
52129: PPUSH
52130: LD_INT 200
52132: PPUSH
52133: CALL_OW 234
// end ;
52137: PPOPN 1
52139: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52140: LD_EXP 74
52144: PUSH
52145: LD_EXP 103
52149: AND
52150: IFFALSE 52229
52152: GO 52154
52154: DISABLE
52155: LD_INT 0
52157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52158: LD_ADDR_VAR 0 1
52162: PUSH
52163: LD_INT 22
52165: PUSH
52166: LD_OWVAR 2
52170: PUSH
52171: EMPTY
52172: LIST
52173: LIST
52174: PUSH
52175: LD_INT 21
52177: PUSH
52178: LD_INT 2
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: PUSH
52185: EMPTY
52186: LIST
52187: LIST
52188: PPUSH
52189: CALL_OW 69
52193: ST_TO_ADDR
// if not tmp then
52194: LD_VAR 0 1
52198: NOT
52199: IFFALSE 52203
// exit ;
52201: GO 52229
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52203: LD_VAR 0 1
52207: PUSH
52208: LD_INT 1
52210: PPUSH
52211: LD_VAR 0 1
52215: PPUSH
52216: CALL_OW 12
52220: ARRAY
52221: PPUSH
52222: LD_INT 60
52224: PPUSH
52225: CALL_OW 234
// end ;
52229: PPOPN 1
52231: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52232: LD_EXP 74
52236: PUSH
52237: LD_EXP 104
52241: AND
52242: IFFALSE 52341
52244: GO 52246
52246: DISABLE
52247: LD_INT 0
52249: PPUSH
52250: PPUSH
// begin enable ;
52251: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52252: LD_ADDR_VAR 0 1
52256: PUSH
52257: LD_INT 22
52259: PUSH
52260: LD_OWVAR 2
52264: PUSH
52265: EMPTY
52266: LIST
52267: LIST
52268: PUSH
52269: LD_INT 61
52271: PUSH
52272: EMPTY
52273: LIST
52274: PUSH
52275: LD_INT 33
52277: PUSH
52278: LD_INT 2
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PUSH
52285: EMPTY
52286: LIST
52287: LIST
52288: LIST
52289: PPUSH
52290: CALL_OW 69
52294: ST_TO_ADDR
// if not tmp then
52295: LD_VAR 0 1
52299: NOT
52300: IFFALSE 52304
// exit ;
52302: GO 52341
// for i in tmp do
52304: LD_ADDR_VAR 0 2
52308: PUSH
52309: LD_VAR 0 1
52313: PUSH
52314: FOR_IN
52315: IFFALSE 52339
// if IsControledBy ( i ) then
52317: LD_VAR 0 2
52321: PPUSH
52322: CALL_OW 312
52326: IFFALSE 52337
// ComUnlink ( i ) ;
52328: LD_VAR 0 2
52332: PPUSH
52333: CALL_OW 136
52337: GO 52314
52339: POP
52340: POP
// end ;
52341: PPOPN 2
52343: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52344: LD_EXP 74
52348: PUSH
52349: LD_EXP 105
52353: AND
52354: IFFALSE 52494
52356: GO 52358
52358: DISABLE
52359: LD_INT 0
52361: PPUSH
52362: PPUSH
// begin ToLua ( displayPowell(); ) ;
52363: LD_STRING displayPowell();
52365: PPUSH
52366: CALL_OW 559
// uc_side := 0 ;
52370: LD_ADDR_OWVAR 20
52374: PUSH
52375: LD_INT 0
52377: ST_TO_ADDR
// uc_nation := 2 ;
52378: LD_ADDR_OWVAR 21
52382: PUSH
52383: LD_INT 2
52385: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52386: LD_ADDR_OWVAR 37
52390: PUSH
52391: LD_INT 14
52393: ST_TO_ADDR
// vc_engine := engine_siberite ;
52394: LD_ADDR_OWVAR 39
52398: PUSH
52399: LD_INT 3
52401: ST_TO_ADDR
// vc_control := control_apeman ;
52402: LD_ADDR_OWVAR 38
52406: PUSH
52407: LD_INT 5
52409: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52410: LD_ADDR_OWVAR 40
52414: PUSH
52415: LD_INT 29
52417: ST_TO_ADDR
// un := CreateVehicle ;
52418: LD_ADDR_VAR 0 2
52422: PUSH
52423: CALL_OW 45
52427: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52428: LD_VAR 0 2
52432: PPUSH
52433: LD_INT 1
52435: PPUSH
52436: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52440: LD_INT 35
52442: PPUSH
52443: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52447: LD_VAR 0 2
52451: PPUSH
52452: LD_INT 22
52454: PUSH
52455: LD_OWVAR 2
52459: PUSH
52460: EMPTY
52461: LIST
52462: LIST
52463: PPUSH
52464: CALL_OW 69
52468: PPUSH
52469: LD_VAR 0 2
52473: PPUSH
52474: CALL_OW 74
52478: PPUSH
52479: CALL_OW 115
// until IsDead ( un ) ;
52483: LD_VAR 0 2
52487: PPUSH
52488: CALL_OW 301
52492: IFFALSE 52440
// end ;
52494: PPOPN 2
52496: END
// every 0 0$1 trigger StreamModeActive and sStu do
52497: LD_EXP 74
52501: PUSH
52502: LD_EXP 113
52506: AND
52507: IFFALSE 52523
52509: GO 52511
52511: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52512: LD_STRING displayStucuk();
52514: PPUSH
52515: CALL_OW 559
// ResetFog ;
52519: CALL_OW 335
// end ;
52523: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52524: LD_EXP 74
52528: PUSH
52529: LD_EXP 106
52533: AND
52534: IFFALSE 52675
52536: GO 52538
52538: DISABLE
52539: LD_INT 0
52541: PPUSH
52542: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52543: LD_ADDR_VAR 0 2
52547: PUSH
52548: LD_INT 22
52550: PUSH
52551: LD_OWVAR 2
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: PUSH
52560: LD_INT 21
52562: PUSH
52563: LD_INT 1
52565: PUSH
52566: EMPTY
52567: LIST
52568: LIST
52569: PUSH
52570: EMPTY
52571: LIST
52572: LIST
52573: PPUSH
52574: CALL_OW 69
52578: ST_TO_ADDR
// if not tmp then
52579: LD_VAR 0 2
52583: NOT
52584: IFFALSE 52588
// exit ;
52586: GO 52675
// un := tmp [ rand ( 1 , tmp ) ] ;
52588: LD_ADDR_VAR 0 1
52592: PUSH
52593: LD_VAR 0 2
52597: PUSH
52598: LD_INT 1
52600: PPUSH
52601: LD_VAR 0 2
52605: PPUSH
52606: CALL_OW 12
52610: ARRAY
52611: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52612: LD_VAR 0 1
52616: PPUSH
52617: LD_INT 0
52619: PPUSH
52620: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52624: LD_VAR 0 1
52628: PPUSH
52629: LD_OWVAR 3
52633: PUSH
52634: LD_VAR 0 1
52638: DIFF
52639: PPUSH
52640: LD_VAR 0 1
52644: PPUSH
52645: CALL_OW 74
52649: PPUSH
52650: CALL_OW 115
// wait ( 0 0$20 ) ;
52654: LD_INT 700
52656: PPUSH
52657: CALL_OW 67
// SetSide ( un , your_side ) ;
52661: LD_VAR 0 1
52665: PPUSH
52666: LD_OWVAR 2
52670: PPUSH
52671: CALL_OW 235
// end ;
52675: PPOPN 2
52677: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52678: LD_EXP 74
52682: PUSH
52683: LD_EXP 107
52687: AND
52688: IFFALSE 52794
52690: GO 52692
52692: DISABLE
52693: LD_INT 0
52695: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52696: LD_ADDR_VAR 0 1
52700: PUSH
52701: LD_INT 22
52703: PUSH
52704: LD_OWVAR 2
52708: PUSH
52709: EMPTY
52710: LIST
52711: LIST
52712: PUSH
52713: LD_INT 2
52715: PUSH
52716: LD_INT 30
52718: PUSH
52719: LD_INT 0
52721: PUSH
52722: EMPTY
52723: LIST
52724: LIST
52725: PUSH
52726: LD_INT 30
52728: PUSH
52729: LD_INT 1
52731: PUSH
52732: EMPTY
52733: LIST
52734: LIST
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: LIST
52740: PUSH
52741: EMPTY
52742: LIST
52743: LIST
52744: PPUSH
52745: CALL_OW 69
52749: ST_TO_ADDR
// if not depot then
52750: LD_VAR 0 1
52754: NOT
52755: IFFALSE 52759
// exit ;
52757: GO 52794
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52759: LD_VAR 0 1
52763: PUSH
52764: LD_INT 1
52766: ARRAY
52767: PPUSH
52768: CALL_OW 250
52772: PPUSH
52773: LD_VAR 0 1
52777: PUSH
52778: LD_INT 1
52780: ARRAY
52781: PPUSH
52782: CALL_OW 251
52786: PPUSH
52787: LD_INT 70
52789: PPUSH
52790: CALL_OW 495
// end ;
52794: PPOPN 1
52796: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52797: LD_EXP 74
52801: PUSH
52802: LD_EXP 108
52806: AND
52807: IFFALSE 53018
52809: GO 52811
52811: DISABLE
52812: LD_INT 0
52814: PPUSH
52815: PPUSH
52816: PPUSH
52817: PPUSH
52818: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52819: LD_ADDR_VAR 0 5
52823: PUSH
52824: LD_INT 22
52826: PUSH
52827: LD_OWVAR 2
52831: PUSH
52832: EMPTY
52833: LIST
52834: LIST
52835: PUSH
52836: LD_INT 21
52838: PUSH
52839: LD_INT 1
52841: PUSH
52842: EMPTY
52843: LIST
52844: LIST
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: PPUSH
52850: CALL_OW 69
52854: ST_TO_ADDR
// if not tmp then
52855: LD_VAR 0 5
52859: NOT
52860: IFFALSE 52864
// exit ;
52862: GO 53018
// for i in tmp do
52864: LD_ADDR_VAR 0 1
52868: PUSH
52869: LD_VAR 0 5
52873: PUSH
52874: FOR_IN
52875: IFFALSE 53016
// begin d := rand ( 0 , 5 ) ;
52877: LD_ADDR_VAR 0 4
52881: PUSH
52882: LD_INT 0
52884: PPUSH
52885: LD_INT 5
52887: PPUSH
52888: CALL_OW 12
52892: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52893: LD_ADDR_VAR 0 2
52897: PUSH
52898: LD_VAR 0 1
52902: PPUSH
52903: CALL_OW 250
52907: PPUSH
52908: LD_VAR 0 4
52912: PPUSH
52913: LD_INT 3
52915: PPUSH
52916: LD_INT 12
52918: PPUSH
52919: CALL_OW 12
52923: PPUSH
52924: CALL_OW 272
52928: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52929: LD_ADDR_VAR 0 3
52933: PUSH
52934: LD_VAR 0 1
52938: PPUSH
52939: CALL_OW 251
52943: PPUSH
52944: LD_VAR 0 4
52948: PPUSH
52949: LD_INT 3
52951: PPUSH
52952: LD_INT 12
52954: PPUSH
52955: CALL_OW 12
52959: PPUSH
52960: CALL_OW 273
52964: ST_TO_ADDR
// if ValidHex ( x , y ) then
52965: LD_VAR 0 2
52969: PPUSH
52970: LD_VAR 0 3
52974: PPUSH
52975: CALL_OW 488
52979: IFFALSE 53014
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52981: LD_VAR 0 1
52985: PPUSH
52986: LD_VAR 0 2
52990: PPUSH
52991: LD_VAR 0 3
52995: PPUSH
52996: LD_INT 3
52998: PPUSH
52999: LD_INT 6
53001: PPUSH
53002: CALL_OW 12
53006: PPUSH
53007: LD_INT 1
53009: PPUSH
53010: CALL_OW 483
// end ;
53014: GO 52874
53016: POP
53017: POP
// end ;
53018: PPOPN 5
53020: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53021: LD_EXP 74
53025: PUSH
53026: LD_EXP 109
53030: AND
53031: IFFALSE 53125
53033: GO 53035
53035: DISABLE
53036: LD_INT 0
53038: PPUSH
53039: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53040: LD_ADDR_VAR 0 2
53044: PUSH
53045: LD_INT 22
53047: PUSH
53048: LD_OWVAR 2
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: PUSH
53057: LD_INT 32
53059: PUSH
53060: LD_INT 1
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: PUSH
53067: LD_INT 21
53069: PUSH
53070: LD_INT 2
53072: PUSH
53073: EMPTY
53074: LIST
53075: LIST
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: LIST
53081: PPUSH
53082: CALL_OW 69
53086: ST_TO_ADDR
// if not tmp then
53087: LD_VAR 0 2
53091: NOT
53092: IFFALSE 53096
// exit ;
53094: GO 53125
// for i in tmp do
53096: LD_ADDR_VAR 0 1
53100: PUSH
53101: LD_VAR 0 2
53105: PUSH
53106: FOR_IN
53107: IFFALSE 53123
// SetFuel ( i , 0 ) ;
53109: LD_VAR 0 1
53113: PPUSH
53114: LD_INT 0
53116: PPUSH
53117: CALL_OW 240
53121: GO 53106
53123: POP
53124: POP
// end ;
53125: PPOPN 2
53127: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53128: LD_EXP 74
53132: PUSH
53133: LD_EXP 110
53137: AND
53138: IFFALSE 53204
53140: GO 53142
53142: DISABLE
53143: LD_INT 0
53145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53146: LD_ADDR_VAR 0 1
53150: PUSH
53151: LD_INT 22
53153: PUSH
53154: LD_OWVAR 2
53158: PUSH
53159: EMPTY
53160: LIST
53161: LIST
53162: PUSH
53163: LD_INT 30
53165: PUSH
53166: LD_INT 29
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: PPUSH
53177: CALL_OW 69
53181: ST_TO_ADDR
// if not tmp then
53182: LD_VAR 0 1
53186: NOT
53187: IFFALSE 53191
// exit ;
53189: GO 53204
// DestroyUnit ( tmp [ 1 ] ) ;
53191: LD_VAR 0 1
53195: PUSH
53196: LD_INT 1
53198: ARRAY
53199: PPUSH
53200: CALL_OW 65
// end ;
53204: PPOPN 1
53206: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53207: LD_EXP 74
53211: PUSH
53212: LD_EXP 112
53216: AND
53217: IFFALSE 53346
53219: GO 53221
53221: DISABLE
53222: LD_INT 0
53224: PPUSH
// begin uc_side := 0 ;
53225: LD_ADDR_OWVAR 20
53229: PUSH
53230: LD_INT 0
53232: ST_TO_ADDR
// uc_nation := nation_arabian ;
53233: LD_ADDR_OWVAR 21
53237: PUSH
53238: LD_INT 2
53240: ST_TO_ADDR
// hc_gallery :=  ;
53241: LD_ADDR_OWVAR 33
53245: PUSH
53246: LD_STRING 
53248: ST_TO_ADDR
// hc_name :=  ;
53249: LD_ADDR_OWVAR 26
53253: PUSH
53254: LD_STRING 
53256: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53257: LD_INT 1
53259: PPUSH
53260: LD_INT 11
53262: PPUSH
53263: LD_INT 10
53265: PPUSH
53266: CALL_OW 380
// un := CreateHuman ;
53270: LD_ADDR_VAR 0 1
53274: PUSH
53275: CALL_OW 44
53279: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53280: LD_VAR 0 1
53284: PPUSH
53285: LD_INT 1
53287: PPUSH
53288: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53292: LD_INT 35
53294: PPUSH
53295: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53299: LD_VAR 0 1
53303: PPUSH
53304: LD_INT 22
53306: PUSH
53307: LD_OWVAR 2
53311: PUSH
53312: EMPTY
53313: LIST
53314: LIST
53315: PPUSH
53316: CALL_OW 69
53320: PPUSH
53321: LD_VAR 0 1
53325: PPUSH
53326: CALL_OW 74
53330: PPUSH
53331: CALL_OW 115
// until IsDead ( un ) ;
53335: LD_VAR 0 1
53339: PPUSH
53340: CALL_OW 301
53344: IFFALSE 53292
// end ;
53346: PPOPN 1
53348: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53349: LD_EXP 74
53353: PUSH
53354: LD_EXP 114
53358: AND
53359: IFFALSE 53371
53361: GO 53363
53363: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53364: LD_STRING earthquake(getX(game), 0, 32)
53366: PPUSH
53367: CALL_OW 559
53371: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53372: LD_EXP 74
53376: PUSH
53377: LD_EXP 115
53381: AND
53382: IFFALSE 53473
53384: GO 53386
53386: DISABLE
53387: LD_INT 0
53389: PPUSH
// begin enable ;
53390: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53391: LD_ADDR_VAR 0 1
53395: PUSH
53396: LD_INT 22
53398: PUSH
53399: LD_OWVAR 2
53403: PUSH
53404: EMPTY
53405: LIST
53406: LIST
53407: PUSH
53408: LD_INT 21
53410: PUSH
53411: LD_INT 2
53413: PUSH
53414: EMPTY
53415: LIST
53416: LIST
53417: PUSH
53418: LD_INT 33
53420: PUSH
53421: LD_INT 3
53423: PUSH
53424: EMPTY
53425: LIST
53426: LIST
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: LIST
53432: PPUSH
53433: CALL_OW 69
53437: ST_TO_ADDR
// if not tmp then
53438: LD_VAR 0 1
53442: NOT
53443: IFFALSE 53447
// exit ;
53445: GO 53473
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53447: LD_VAR 0 1
53451: PUSH
53452: LD_INT 1
53454: PPUSH
53455: LD_VAR 0 1
53459: PPUSH
53460: CALL_OW 12
53464: ARRAY
53465: PPUSH
53466: LD_INT 1
53468: PPUSH
53469: CALL_OW 234
// end ;
53473: PPOPN 1
53475: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53476: LD_EXP 74
53480: PUSH
53481: LD_EXP 116
53485: AND
53486: IFFALSE 53627
53488: GO 53490
53490: DISABLE
53491: LD_INT 0
53493: PPUSH
53494: PPUSH
53495: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53496: LD_ADDR_VAR 0 3
53500: PUSH
53501: LD_INT 22
53503: PUSH
53504: LD_OWVAR 2
53508: PUSH
53509: EMPTY
53510: LIST
53511: LIST
53512: PUSH
53513: LD_INT 25
53515: PUSH
53516: LD_INT 1
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: PUSH
53523: EMPTY
53524: LIST
53525: LIST
53526: PPUSH
53527: CALL_OW 69
53531: ST_TO_ADDR
// if not tmp then
53532: LD_VAR 0 3
53536: NOT
53537: IFFALSE 53541
// exit ;
53539: GO 53627
// un := tmp [ rand ( 1 , tmp ) ] ;
53541: LD_ADDR_VAR 0 2
53545: PUSH
53546: LD_VAR 0 3
53550: PUSH
53551: LD_INT 1
53553: PPUSH
53554: LD_VAR 0 3
53558: PPUSH
53559: CALL_OW 12
53563: ARRAY
53564: ST_TO_ADDR
// if Crawls ( un ) then
53565: LD_VAR 0 2
53569: PPUSH
53570: CALL_OW 318
53574: IFFALSE 53585
// ComWalk ( un ) ;
53576: LD_VAR 0 2
53580: PPUSH
53581: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53585: LD_VAR 0 2
53589: PPUSH
53590: LD_INT 9
53592: PPUSH
53593: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53597: LD_INT 28
53599: PPUSH
53600: LD_OWVAR 2
53604: PPUSH
53605: LD_INT 2
53607: PPUSH
53608: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53612: LD_INT 29
53614: PPUSH
53615: LD_OWVAR 2
53619: PPUSH
53620: LD_INT 2
53622: PPUSH
53623: CALL_OW 322
// end ;
53627: PPOPN 3
53629: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53630: LD_EXP 74
53634: PUSH
53635: LD_EXP 117
53639: AND
53640: IFFALSE 53751
53642: GO 53644
53644: DISABLE
53645: LD_INT 0
53647: PPUSH
53648: PPUSH
53649: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53650: LD_ADDR_VAR 0 3
53654: PUSH
53655: LD_INT 22
53657: PUSH
53658: LD_OWVAR 2
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PUSH
53667: LD_INT 25
53669: PUSH
53670: LD_INT 1
53672: PUSH
53673: EMPTY
53674: LIST
53675: LIST
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: PPUSH
53681: CALL_OW 69
53685: ST_TO_ADDR
// if not tmp then
53686: LD_VAR 0 3
53690: NOT
53691: IFFALSE 53695
// exit ;
53693: GO 53751
// un := tmp [ rand ( 1 , tmp ) ] ;
53695: LD_ADDR_VAR 0 2
53699: PUSH
53700: LD_VAR 0 3
53704: PUSH
53705: LD_INT 1
53707: PPUSH
53708: LD_VAR 0 3
53712: PPUSH
53713: CALL_OW 12
53717: ARRAY
53718: ST_TO_ADDR
// if Crawls ( un ) then
53719: LD_VAR 0 2
53723: PPUSH
53724: CALL_OW 318
53728: IFFALSE 53739
// ComWalk ( un ) ;
53730: LD_VAR 0 2
53734: PPUSH
53735: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53739: LD_VAR 0 2
53743: PPUSH
53744: LD_INT 8
53746: PPUSH
53747: CALL_OW 336
// end ;
53751: PPOPN 3
53753: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53754: LD_EXP 74
53758: PUSH
53759: LD_EXP 118
53763: AND
53764: IFFALSE 53908
53766: GO 53768
53768: DISABLE
53769: LD_INT 0
53771: PPUSH
53772: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53773: LD_ADDR_VAR 0 2
53777: PUSH
53778: LD_INT 22
53780: PUSH
53781: LD_OWVAR 2
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: PUSH
53790: LD_INT 21
53792: PUSH
53793: LD_INT 2
53795: PUSH
53796: EMPTY
53797: LIST
53798: LIST
53799: PUSH
53800: LD_INT 2
53802: PUSH
53803: LD_INT 34
53805: PUSH
53806: LD_INT 12
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: PUSH
53813: LD_INT 34
53815: PUSH
53816: LD_INT 51
53818: PUSH
53819: EMPTY
53820: LIST
53821: LIST
53822: PUSH
53823: LD_INT 34
53825: PUSH
53826: LD_INT 32
53828: PUSH
53829: EMPTY
53830: LIST
53831: LIST
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: LIST
53837: LIST
53838: PUSH
53839: EMPTY
53840: LIST
53841: LIST
53842: LIST
53843: PPUSH
53844: CALL_OW 69
53848: ST_TO_ADDR
// if not tmp then
53849: LD_VAR 0 2
53853: NOT
53854: IFFALSE 53858
// exit ;
53856: GO 53908
// for i in tmp do
53858: LD_ADDR_VAR 0 1
53862: PUSH
53863: LD_VAR 0 2
53867: PUSH
53868: FOR_IN
53869: IFFALSE 53906
// if GetCargo ( i , mat_artifact ) = 0 then
53871: LD_VAR 0 1
53875: PPUSH
53876: LD_INT 4
53878: PPUSH
53879: CALL_OW 289
53883: PUSH
53884: LD_INT 0
53886: EQUAL
53887: IFFALSE 53904
// SetCargo ( i , mat_siberit , 100 ) ;
53889: LD_VAR 0 1
53893: PPUSH
53894: LD_INT 3
53896: PPUSH
53897: LD_INT 100
53899: PPUSH
53900: CALL_OW 290
53904: GO 53868
53906: POP
53907: POP
// end ;
53908: PPOPN 2
53910: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53911: LD_EXP 74
53915: PUSH
53916: LD_EXP 119
53920: AND
53921: IFFALSE 54104
53923: GO 53925
53925: DISABLE
53926: LD_INT 0
53928: PPUSH
53929: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53930: LD_ADDR_VAR 0 2
53934: PUSH
53935: LD_INT 22
53937: PUSH
53938: LD_OWVAR 2
53942: PUSH
53943: EMPTY
53944: LIST
53945: LIST
53946: PPUSH
53947: CALL_OW 69
53951: ST_TO_ADDR
// if not tmp then
53952: LD_VAR 0 2
53956: NOT
53957: IFFALSE 53961
// exit ;
53959: GO 54104
// for i := 1 to 2 do
53961: LD_ADDR_VAR 0 1
53965: PUSH
53966: DOUBLE
53967: LD_INT 1
53969: DEC
53970: ST_TO_ADDR
53971: LD_INT 2
53973: PUSH
53974: FOR_TO
53975: IFFALSE 54102
// begin uc_side := your_side ;
53977: LD_ADDR_OWVAR 20
53981: PUSH
53982: LD_OWVAR 2
53986: ST_TO_ADDR
// uc_nation := nation_american ;
53987: LD_ADDR_OWVAR 21
53991: PUSH
53992: LD_INT 1
53994: ST_TO_ADDR
// vc_chassis := us_morphling ;
53995: LD_ADDR_OWVAR 37
53999: PUSH
54000: LD_INT 5
54002: ST_TO_ADDR
// vc_engine := engine_siberite ;
54003: LD_ADDR_OWVAR 39
54007: PUSH
54008: LD_INT 3
54010: ST_TO_ADDR
// vc_control := control_computer ;
54011: LD_ADDR_OWVAR 38
54015: PUSH
54016: LD_INT 3
54018: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54019: LD_ADDR_OWVAR 40
54023: PUSH
54024: LD_INT 10
54026: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54027: LD_VAR 0 2
54031: PUSH
54032: LD_INT 1
54034: ARRAY
54035: PPUSH
54036: CALL_OW 310
54040: NOT
54041: IFFALSE 54088
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54043: CALL_OW 45
54047: PPUSH
54048: LD_VAR 0 2
54052: PUSH
54053: LD_INT 1
54055: ARRAY
54056: PPUSH
54057: CALL_OW 250
54061: PPUSH
54062: LD_VAR 0 2
54066: PUSH
54067: LD_INT 1
54069: ARRAY
54070: PPUSH
54071: CALL_OW 251
54075: PPUSH
54076: LD_INT 12
54078: PPUSH
54079: LD_INT 1
54081: PPUSH
54082: CALL_OW 50
54086: GO 54100
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54088: CALL_OW 45
54092: PPUSH
54093: LD_INT 1
54095: PPUSH
54096: CALL_OW 51
// end ;
54100: GO 53974
54102: POP
54103: POP
// end ;
54104: PPOPN 2
54106: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54107: LD_EXP 74
54111: PUSH
54112: LD_EXP 120
54116: AND
54117: IFFALSE 54339
54119: GO 54121
54121: DISABLE
54122: LD_INT 0
54124: PPUSH
54125: PPUSH
54126: PPUSH
54127: PPUSH
54128: PPUSH
54129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54130: LD_ADDR_VAR 0 6
54134: PUSH
54135: LD_INT 22
54137: PUSH
54138: LD_OWVAR 2
54142: PUSH
54143: EMPTY
54144: LIST
54145: LIST
54146: PUSH
54147: LD_INT 21
54149: PUSH
54150: LD_INT 1
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: PUSH
54157: LD_INT 3
54159: PUSH
54160: LD_INT 23
54162: PUSH
54163: LD_INT 0
54165: PUSH
54166: EMPTY
54167: LIST
54168: LIST
54169: PUSH
54170: EMPTY
54171: LIST
54172: LIST
54173: PUSH
54174: EMPTY
54175: LIST
54176: LIST
54177: LIST
54178: PPUSH
54179: CALL_OW 69
54183: ST_TO_ADDR
// if not tmp then
54184: LD_VAR 0 6
54188: NOT
54189: IFFALSE 54193
// exit ;
54191: GO 54339
// s1 := rand ( 1 , 4 ) ;
54193: LD_ADDR_VAR 0 2
54197: PUSH
54198: LD_INT 1
54200: PPUSH
54201: LD_INT 4
54203: PPUSH
54204: CALL_OW 12
54208: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54209: LD_ADDR_VAR 0 4
54213: PUSH
54214: LD_VAR 0 6
54218: PUSH
54219: LD_INT 1
54221: ARRAY
54222: PPUSH
54223: LD_VAR 0 2
54227: PPUSH
54228: CALL_OW 259
54232: ST_TO_ADDR
// if s1 = 1 then
54233: LD_VAR 0 2
54237: PUSH
54238: LD_INT 1
54240: EQUAL
54241: IFFALSE 54261
// s2 := rand ( 2 , 4 ) else
54243: LD_ADDR_VAR 0 3
54247: PUSH
54248: LD_INT 2
54250: PPUSH
54251: LD_INT 4
54253: PPUSH
54254: CALL_OW 12
54258: ST_TO_ADDR
54259: GO 54269
// s2 := 1 ;
54261: LD_ADDR_VAR 0 3
54265: PUSH
54266: LD_INT 1
54268: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54269: LD_ADDR_VAR 0 5
54273: PUSH
54274: LD_VAR 0 6
54278: PUSH
54279: LD_INT 1
54281: ARRAY
54282: PPUSH
54283: LD_VAR 0 3
54287: PPUSH
54288: CALL_OW 259
54292: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54293: LD_VAR 0 6
54297: PUSH
54298: LD_INT 1
54300: ARRAY
54301: PPUSH
54302: LD_VAR 0 2
54306: PPUSH
54307: LD_VAR 0 5
54311: PPUSH
54312: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54316: LD_VAR 0 6
54320: PUSH
54321: LD_INT 1
54323: ARRAY
54324: PPUSH
54325: LD_VAR 0 3
54329: PPUSH
54330: LD_VAR 0 4
54334: PPUSH
54335: CALL_OW 237
// end ;
54339: PPOPN 6
54341: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54342: LD_EXP 74
54346: PUSH
54347: LD_EXP 121
54351: AND
54352: IFFALSE 54431
54354: GO 54356
54356: DISABLE
54357: LD_INT 0
54359: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54360: LD_ADDR_VAR 0 1
54364: PUSH
54365: LD_INT 22
54367: PUSH
54368: LD_OWVAR 2
54372: PUSH
54373: EMPTY
54374: LIST
54375: LIST
54376: PUSH
54377: LD_INT 30
54379: PUSH
54380: LD_INT 3
54382: PUSH
54383: EMPTY
54384: LIST
54385: LIST
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: PPUSH
54391: CALL_OW 69
54395: ST_TO_ADDR
// if not tmp then
54396: LD_VAR 0 1
54400: NOT
54401: IFFALSE 54405
// exit ;
54403: GO 54431
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54405: LD_VAR 0 1
54409: PUSH
54410: LD_INT 1
54412: PPUSH
54413: LD_VAR 0 1
54417: PPUSH
54418: CALL_OW 12
54422: ARRAY
54423: PPUSH
54424: LD_INT 1
54426: PPUSH
54427: CALL_OW 234
// end ;
54431: PPOPN 1
54433: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54434: LD_EXP 74
54438: PUSH
54439: LD_EXP 122
54443: AND
54444: IFFALSE 54556
54446: GO 54448
54448: DISABLE
54449: LD_INT 0
54451: PPUSH
54452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54453: LD_ADDR_VAR 0 2
54457: PUSH
54458: LD_INT 22
54460: PUSH
54461: LD_OWVAR 2
54465: PUSH
54466: EMPTY
54467: LIST
54468: LIST
54469: PUSH
54470: LD_INT 2
54472: PUSH
54473: LD_INT 30
54475: PUSH
54476: LD_INT 27
54478: PUSH
54479: EMPTY
54480: LIST
54481: LIST
54482: PUSH
54483: LD_INT 30
54485: PUSH
54486: LD_INT 26
54488: PUSH
54489: EMPTY
54490: LIST
54491: LIST
54492: PUSH
54493: LD_INT 30
54495: PUSH
54496: LD_INT 28
54498: PUSH
54499: EMPTY
54500: LIST
54501: LIST
54502: PUSH
54503: EMPTY
54504: LIST
54505: LIST
54506: LIST
54507: LIST
54508: PUSH
54509: EMPTY
54510: LIST
54511: LIST
54512: PPUSH
54513: CALL_OW 69
54517: ST_TO_ADDR
// if not tmp then
54518: LD_VAR 0 2
54522: NOT
54523: IFFALSE 54527
// exit ;
54525: GO 54556
// for i in tmp do
54527: LD_ADDR_VAR 0 1
54531: PUSH
54532: LD_VAR 0 2
54536: PUSH
54537: FOR_IN
54538: IFFALSE 54554
// SetLives ( i , 1 ) ;
54540: LD_VAR 0 1
54544: PPUSH
54545: LD_INT 1
54547: PPUSH
54548: CALL_OW 234
54552: GO 54537
54554: POP
54555: POP
// end ;
54556: PPOPN 2
54558: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54559: LD_EXP 74
54563: PUSH
54564: LD_EXP 123
54568: AND
54569: IFFALSE 54856
54571: GO 54573
54573: DISABLE
54574: LD_INT 0
54576: PPUSH
54577: PPUSH
54578: PPUSH
// begin i := rand ( 1 , 7 ) ;
54579: LD_ADDR_VAR 0 1
54583: PUSH
54584: LD_INT 1
54586: PPUSH
54587: LD_INT 7
54589: PPUSH
54590: CALL_OW 12
54594: ST_TO_ADDR
// case i of 1 :
54595: LD_VAR 0 1
54599: PUSH
54600: LD_INT 1
54602: DOUBLE
54603: EQUAL
54604: IFTRUE 54608
54606: GO 54618
54608: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54609: LD_STRING earthquake(getX(game), 0, 32)
54611: PPUSH
54612: CALL_OW 559
54616: GO 54856
54618: LD_INT 2
54620: DOUBLE
54621: EQUAL
54622: IFTRUE 54626
54624: GO 54640
54626: POP
// begin ToLua ( displayStucuk(); ) ;
54627: LD_STRING displayStucuk();
54629: PPUSH
54630: CALL_OW 559
// ResetFog ;
54634: CALL_OW 335
// end ; 3 :
54638: GO 54856
54640: LD_INT 3
54642: DOUBLE
54643: EQUAL
54644: IFTRUE 54648
54646: GO 54752
54648: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54649: LD_ADDR_VAR 0 2
54653: PUSH
54654: LD_INT 22
54656: PUSH
54657: LD_OWVAR 2
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: PUSH
54666: LD_INT 25
54668: PUSH
54669: LD_INT 1
54671: PUSH
54672: EMPTY
54673: LIST
54674: LIST
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: PPUSH
54680: CALL_OW 69
54684: ST_TO_ADDR
// if not tmp then
54685: LD_VAR 0 2
54689: NOT
54690: IFFALSE 54694
// exit ;
54692: GO 54856
// un := tmp [ rand ( 1 , tmp ) ] ;
54694: LD_ADDR_VAR 0 3
54698: PUSH
54699: LD_VAR 0 2
54703: PUSH
54704: LD_INT 1
54706: PPUSH
54707: LD_VAR 0 2
54711: PPUSH
54712: CALL_OW 12
54716: ARRAY
54717: ST_TO_ADDR
// if Crawls ( un ) then
54718: LD_VAR 0 3
54722: PPUSH
54723: CALL_OW 318
54727: IFFALSE 54738
// ComWalk ( un ) ;
54729: LD_VAR 0 3
54733: PPUSH
54734: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54738: LD_VAR 0 3
54742: PPUSH
54743: LD_INT 8
54745: PPUSH
54746: CALL_OW 336
// end ; 4 :
54750: GO 54856
54752: LD_INT 4
54754: DOUBLE
54755: EQUAL
54756: IFTRUE 54760
54758: GO 54834
54760: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54761: LD_ADDR_VAR 0 2
54765: PUSH
54766: LD_INT 22
54768: PUSH
54769: LD_OWVAR 2
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: PUSH
54778: LD_INT 30
54780: PUSH
54781: LD_INT 29
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: PPUSH
54792: CALL_OW 69
54796: ST_TO_ADDR
// if not tmp then
54797: LD_VAR 0 2
54801: NOT
54802: IFFALSE 54806
// exit ;
54804: GO 54856
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54806: LD_VAR 0 2
54810: PUSH
54811: LD_INT 1
54813: ARRAY
54814: PPUSH
54815: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54819: LD_VAR 0 2
54823: PUSH
54824: LD_INT 1
54826: ARRAY
54827: PPUSH
54828: CALL_OW 65
// end ; 5 .. 7 :
54832: GO 54856
54834: LD_INT 5
54836: DOUBLE
54837: GREATEREQUAL
54838: IFFALSE 54846
54840: LD_INT 7
54842: DOUBLE
54843: LESSEQUAL
54844: IFTRUE 54848
54846: GO 54855
54848: POP
// StreamSibBomb ; end ;
54849: CALL 51093 0 0
54853: GO 54856
54855: POP
// end ;
54856: PPOPN 3
54858: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54859: LD_EXP 74
54863: PUSH
54864: LD_EXP 124
54868: AND
54869: IFFALSE 55025
54871: GO 54873
54873: DISABLE
54874: LD_INT 0
54876: PPUSH
54877: PPUSH
54878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54879: LD_ADDR_VAR 0 2
54883: PUSH
54884: LD_INT 81
54886: PUSH
54887: LD_OWVAR 2
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: PUSH
54896: LD_INT 2
54898: PUSH
54899: LD_INT 21
54901: PUSH
54902: LD_INT 1
54904: PUSH
54905: EMPTY
54906: LIST
54907: LIST
54908: PUSH
54909: LD_INT 21
54911: PUSH
54912: LD_INT 2
54914: PUSH
54915: EMPTY
54916: LIST
54917: LIST
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: LIST
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: PPUSH
54928: CALL_OW 69
54932: ST_TO_ADDR
// if not tmp then
54933: LD_VAR 0 2
54937: NOT
54938: IFFALSE 54942
// exit ;
54940: GO 55025
// p := 0 ;
54942: LD_ADDR_VAR 0 3
54946: PUSH
54947: LD_INT 0
54949: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54950: LD_INT 35
54952: PPUSH
54953: CALL_OW 67
// p := p + 1 ;
54957: LD_ADDR_VAR 0 3
54961: PUSH
54962: LD_VAR 0 3
54966: PUSH
54967: LD_INT 1
54969: PLUS
54970: ST_TO_ADDR
// for i in tmp do
54971: LD_ADDR_VAR 0 1
54975: PUSH
54976: LD_VAR 0 2
54980: PUSH
54981: FOR_IN
54982: IFFALSE 55013
// if GetLives ( i ) < 1000 then
54984: LD_VAR 0 1
54988: PPUSH
54989: CALL_OW 256
54993: PUSH
54994: LD_INT 1000
54996: LESS
54997: IFFALSE 55011
// SetLives ( i , 1000 ) ;
54999: LD_VAR 0 1
55003: PPUSH
55004: LD_INT 1000
55006: PPUSH
55007: CALL_OW 234
55011: GO 54981
55013: POP
55014: POP
// until p > 20 ;
55015: LD_VAR 0 3
55019: PUSH
55020: LD_INT 20
55022: GREATER
55023: IFFALSE 54950
// end ;
55025: PPOPN 3
55027: END
// every 0 0$1 trigger StreamModeActive and sTime do
55028: LD_EXP 74
55032: PUSH
55033: LD_EXP 125
55037: AND
55038: IFFALSE 55073
55040: GO 55042
55042: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55043: LD_INT 28
55045: PPUSH
55046: LD_OWVAR 2
55050: PPUSH
55051: LD_INT 2
55053: PPUSH
55054: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55058: LD_INT 30
55060: PPUSH
55061: LD_OWVAR 2
55065: PPUSH
55066: LD_INT 2
55068: PPUSH
55069: CALL_OW 322
// end ;
55073: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55074: LD_EXP 74
55078: PUSH
55079: LD_EXP 126
55083: AND
55084: IFFALSE 55205
55086: GO 55088
55088: DISABLE
55089: LD_INT 0
55091: PPUSH
55092: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55093: LD_ADDR_VAR 0 2
55097: PUSH
55098: LD_INT 22
55100: PUSH
55101: LD_OWVAR 2
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: PUSH
55110: LD_INT 21
55112: PUSH
55113: LD_INT 1
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: LD_INT 3
55122: PUSH
55123: LD_INT 23
55125: PUSH
55126: LD_INT 0
55128: PUSH
55129: EMPTY
55130: LIST
55131: LIST
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: LIST
55141: PPUSH
55142: CALL_OW 69
55146: ST_TO_ADDR
// if not tmp then
55147: LD_VAR 0 2
55151: NOT
55152: IFFALSE 55156
// exit ;
55154: GO 55205
// for i in tmp do
55156: LD_ADDR_VAR 0 1
55160: PUSH
55161: LD_VAR 0 2
55165: PUSH
55166: FOR_IN
55167: IFFALSE 55203
// begin if Crawls ( i ) then
55169: LD_VAR 0 1
55173: PPUSH
55174: CALL_OW 318
55178: IFFALSE 55189
// ComWalk ( i ) ;
55180: LD_VAR 0 1
55184: PPUSH
55185: CALL_OW 138
// SetClass ( i , 2 ) ;
55189: LD_VAR 0 1
55193: PPUSH
55194: LD_INT 2
55196: PPUSH
55197: CALL_OW 336
// end ;
55201: GO 55166
55203: POP
55204: POP
// end ;
55205: PPOPN 2
55207: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55208: LD_EXP 74
55212: PUSH
55213: LD_EXP 127
55217: AND
55218: IFFALSE 55506
55220: GO 55222
55222: DISABLE
55223: LD_INT 0
55225: PPUSH
55226: PPUSH
55227: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55228: LD_OWVAR 2
55232: PPUSH
55233: LD_INT 9
55235: PPUSH
55236: LD_INT 1
55238: PPUSH
55239: LD_INT 1
55241: PPUSH
55242: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55246: LD_INT 9
55248: PPUSH
55249: LD_OWVAR 2
55253: PPUSH
55254: CALL_OW 343
// uc_side := 9 ;
55258: LD_ADDR_OWVAR 20
55262: PUSH
55263: LD_INT 9
55265: ST_TO_ADDR
// uc_nation := 2 ;
55266: LD_ADDR_OWVAR 21
55270: PUSH
55271: LD_INT 2
55273: ST_TO_ADDR
// hc_name := Dark Warrior ;
55274: LD_ADDR_OWVAR 26
55278: PUSH
55279: LD_STRING Dark Warrior
55281: ST_TO_ADDR
// hc_gallery :=  ;
55282: LD_ADDR_OWVAR 33
55286: PUSH
55287: LD_STRING 
55289: ST_TO_ADDR
// hc_noskilllimit := true ;
55290: LD_ADDR_OWVAR 76
55294: PUSH
55295: LD_INT 1
55297: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55298: LD_ADDR_OWVAR 31
55302: PUSH
55303: LD_INT 30
55305: PUSH
55306: LD_INT 30
55308: PUSH
55309: LD_INT 30
55311: PUSH
55312: LD_INT 30
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: LIST
55319: LIST
55320: ST_TO_ADDR
// un := CreateHuman ;
55321: LD_ADDR_VAR 0 3
55325: PUSH
55326: CALL_OW 44
55330: ST_TO_ADDR
// hc_noskilllimit := false ;
55331: LD_ADDR_OWVAR 76
55335: PUSH
55336: LD_INT 0
55338: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55339: LD_VAR 0 3
55343: PPUSH
55344: LD_INT 1
55346: PPUSH
55347: CALL_OW 51
// ToLua ( playRanger() ) ;
55351: LD_STRING playRanger()
55353: PPUSH
55354: CALL_OW 559
// p := 0 ;
55358: LD_ADDR_VAR 0 2
55362: PUSH
55363: LD_INT 0
55365: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55366: LD_INT 35
55368: PPUSH
55369: CALL_OW 67
// p := p + 1 ;
55373: LD_ADDR_VAR 0 2
55377: PUSH
55378: LD_VAR 0 2
55382: PUSH
55383: LD_INT 1
55385: PLUS
55386: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55387: LD_VAR 0 3
55391: PPUSH
55392: CALL_OW 256
55396: PUSH
55397: LD_INT 1000
55399: LESS
55400: IFFALSE 55414
// SetLives ( un , 1000 ) ;
55402: LD_VAR 0 3
55406: PPUSH
55407: LD_INT 1000
55409: PPUSH
55410: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55414: LD_VAR 0 3
55418: PPUSH
55419: LD_INT 81
55421: PUSH
55422: LD_OWVAR 2
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 91
55433: PUSH
55434: LD_VAR 0 3
55438: PUSH
55439: LD_INT 30
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: LIST
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: PPUSH
55451: CALL_OW 69
55455: PPUSH
55456: LD_VAR 0 3
55460: PPUSH
55461: CALL_OW 74
55465: PPUSH
55466: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55470: LD_VAR 0 2
55474: PUSH
55475: LD_INT 80
55477: GREATER
55478: PUSH
55479: LD_VAR 0 3
55483: PPUSH
55484: CALL_OW 301
55488: OR
55489: IFFALSE 55366
// if un then
55491: LD_VAR 0 3
55495: IFFALSE 55506
// RemoveUnit ( un ) ;
55497: LD_VAR 0 3
55501: PPUSH
55502: CALL_OW 64
// end ;
55506: PPOPN 3
55508: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55509: LD_EXP 128
55513: IFFALSE 55629
55515: GO 55517
55517: DISABLE
55518: LD_INT 0
55520: PPUSH
55521: PPUSH
55522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55523: LD_ADDR_VAR 0 2
55527: PUSH
55528: LD_INT 81
55530: PUSH
55531: LD_OWVAR 2
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: PUSH
55540: LD_INT 21
55542: PUSH
55543: LD_INT 1
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: PPUSH
55554: CALL_OW 69
55558: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55559: LD_STRING playComputer()
55561: PPUSH
55562: CALL_OW 559
// if not tmp then
55566: LD_VAR 0 2
55570: NOT
55571: IFFALSE 55575
// exit ;
55573: GO 55629
// for i in tmp do
55575: LD_ADDR_VAR 0 1
55579: PUSH
55580: LD_VAR 0 2
55584: PUSH
55585: FOR_IN
55586: IFFALSE 55627
// for j := 1 to 4 do
55588: LD_ADDR_VAR 0 3
55592: PUSH
55593: DOUBLE
55594: LD_INT 1
55596: DEC
55597: ST_TO_ADDR
55598: LD_INT 4
55600: PUSH
55601: FOR_TO
55602: IFFALSE 55623
// SetSkill ( i , j , 10 ) ;
55604: LD_VAR 0 1
55608: PPUSH
55609: LD_VAR 0 3
55613: PPUSH
55614: LD_INT 10
55616: PPUSH
55617: CALL_OW 237
55621: GO 55601
55623: POP
55624: POP
55625: GO 55585
55627: POP
55628: POP
// end ;
55629: PPOPN 3
55631: END
// every 0 0$1 trigger s30 do var i , tmp ;
55632: LD_EXP 129
55636: IFFALSE 55705
55638: GO 55640
55640: DISABLE
55641: LD_INT 0
55643: PPUSH
55644: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55645: LD_ADDR_VAR 0 2
55649: PUSH
55650: LD_INT 22
55652: PUSH
55653: LD_OWVAR 2
55657: PUSH
55658: EMPTY
55659: LIST
55660: LIST
55661: PPUSH
55662: CALL_OW 69
55666: ST_TO_ADDR
// if not tmp then
55667: LD_VAR 0 2
55671: NOT
55672: IFFALSE 55676
// exit ;
55674: GO 55705
// for i in tmp do
55676: LD_ADDR_VAR 0 1
55680: PUSH
55681: LD_VAR 0 2
55685: PUSH
55686: FOR_IN
55687: IFFALSE 55703
// SetLives ( i , 300 ) ;
55689: LD_VAR 0 1
55693: PPUSH
55694: LD_INT 300
55696: PPUSH
55697: CALL_OW 234
55701: GO 55686
55703: POP
55704: POP
// end ;
55705: PPOPN 2
55707: END
// every 0 0$1 trigger s60 do var i , tmp ;
55708: LD_EXP 130
55712: IFFALSE 55781
55714: GO 55716
55716: DISABLE
55717: LD_INT 0
55719: PPUSH
55720: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55721: LD_ADDR_VAR 0 2
55725: PUSH
55726: LD_INT 22
55728: PUSH
55729: LD_OWVAR 2
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: PPUSH
55738: CALL_OW 69
55742: ST_TO_ADDR
// if not tmp then
55743: LD_VAR 0 2
55747: NOT
55748: IFFALSE 55752
// exit ;
55750: GO 55781
// for i in tmp do
55752: LD_ADDR_VAR 0 1
55756: PUSH
55757: LD_VAR 0 2
55761: PUSH
55762: FOR_IN
55763: IFFALSE 55779
// SetLives ( i , 600 ) ;
55765: LD_VAR 0 1
55769: PPUSH
55770: LD_INT 600
55772: PPUSH
55773: CALL_OW 234
55777: GO 55762
55779: POP
55780: POP
// end ;
55781: PPOPN 2
55783: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55784: LD_INT 0
55786: PPUSH
// case cmd of 301 :
55787: LD_VAR 0 1
55791: PUSH
55792: LD_INT 301
55794: DOUBLE
55795: EQUAL
55796: IFTRUE 55800
55798: GO 55832
55800: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55801: LD_VAR 0 6
55805: PPUSH
55806: LD_VAR 0 7
55810: PPUSH
55811: LD_VAR 0 8
55815: PPUSH
55816: LD_VAR 0 4
55820: PPUSH
55821: LD_VAR 0 5
55825: PPUSH
55826: CALL 57041 0 5
55830: GO 55953
55832: LD_INT 302
55834: DOUBLE
55835: EQUAL
55836: IFTRUE 55840
55838: GO 55877
55840: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55841: LD_VAR 0 6
55845: PPUSH
55846: LD_VAR 0 7
55850: PPUSH
55851: LD_VAR 0 8
55855: PPUSH
55856: LD_VAR 0 9
55860: PPUSH
55861: LD_VAR 0 4
55865: PPUSH
55866: LD_VAR 0 5
55870: PPUSH
55871: CALL 57132 0 6
55875: GO 55953
55877: LD_INT 303
55879: DOUBLE
55880: EQUAL
55881: IFTRUE 55885
55883: GO 55922
55885: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55886: LD_VAR 0 6
55890: PPUSH
55891: LD_VAR 0 7
55895: PPUSH
55896: LD_VAR 0 8
55900: PPUSH
55901: LD_VAR 0 9
55905: PPUSH
55906: LD_VAR 0 4
55910: PPUSH
55911: LD_VAR 0 5
55915: PPUSH
55916: CALL 55958 0 6
55920: GO 55953
55922: LD_INT 304
55924: DOUBLE
55925: EQUAL
55926: IFTRUE 55930
55928: GO 55952
55930: POP
// hHackTeleport ( unit , x , y ) ; end ;
55931: LD_VAR 0 2
55935: PPUSH
55936: LD_VAR 0 4
55940: PPUSH
55941: LD_VAR 0 5
55945: PPUSH
55946: CALL 57725 0 3
55950: GO 55953
55952: POP
// end ;
55953: LD_VAR 0 12
55957: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55958: LD_INT 0
55960: PPUSH
55961: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55962: LD_VAR 0 1
55966: PUSH
55967: LD_INT 1
55969: LESS
55970: PUSH
55971: LD_VAR 0 1
55975: PUSH
55976: LD_INT 3
55978: GREATER
55979: OR
55980: PUSH
55981: LD_VAR 0 5
55985: PPUSH
55986: LD_VAR 0 6
55990: PPUSH
55991: CALL_OW 428
55995: OR
55996: IFFALSE 56000
// exit ;
55998: GO 56728
// uc_side := your_side ;
56000: LD_ADDR_OWVAR 20
56004: PUSH
56005: LD_OWVAR 2
56009: ST_TO_ADDR
// uc_nation := nation ;
56010: LD_ADDR_OWVAR 21
56014: PUSH
56015: LD_VAR 0 1
56019: ST_TO_ADDR
// bc_level = 1 ;
56020: LD_ADDR_OWVAR 43
56024: PUSH
56025: LD_INT 1
56027: ST_TO_ADDR
// case btype of 1 :
56028: LD_VAR 0 2
56032: PUSH
56033: LD_INT 1
56035: DOUBLE
56036: EQUAL
56037: IFTRUE 56041
56039: GO 56052
56041: POP
// bc_type := b_depot ; 2 :
56042: LD_ADDR_OWVAR 42
56046: PUSH
56047: LD_INT 0
56049: ST_TO_ADDR
56050: GO 56672
56052: LD_INT 2
56054: DOUBLE
56055: EQUAL
56056: IFTRUE 56060
56058: GO 56071
56060: POP
// bc_type := b_warehouse ; 3 :
56061: LD_ADDR_OWVAR 42
56065: PUSH
56066: LD_INT 1
56068: ST_TO_ADDR
56069: GO 56672
56071: LD_INT 3
56073: DOUBLE
56074: EQUAL
56075: IFTRUE 56079
56077: GO 56090
56079: POP
// bc_type := b_lab ; 4 .. 9 :
56080: LD_ADDR_OWVAR 42
56084: PUSH
56085: LD_INT 6
56087: ST_TO_ADDR
56088: GO 56672
56090: LD_INT 4
56092: DOUBLE
56093: GREATEREQUAL
56094: IFFALSE 56102
56096: LD_INT 9
56098: DOUBLE
56099: LESSEQUAL
56100: IFTRUE 56104
56102: GO 56164
56104: POP
// begin bc_type := b_lab_half ;
56105: LD_ADDR_OWVAR 42
56109: PUSH
56110: LD_INT 7
56112: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56113: LD_ADDR_OWVAR 44
56117: PUSH
56118: LD_INT 10
56120: PUSH
56121: LD_INT 11
56123: PUSH
56124: LD_INT 12
56126: PUSH
56127: LD_INT 15
56129: PUSH
56130: LD_INT 14
56132: PUSH
56133: LD_INT 13
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: LIST
56140: LIST
56141: LIST
56142: LIST
56143: PUSH
56144: LD_VAR 0 2
56148: PUSH
56149: LD_INT 3
56151: MINUS
56152: ARRAY
56153: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
56154: LD_ADDR_OWVAR 45
56158: PUSH
56159: LD_INT 9
56161: ST_TO_ADDR
// end ; 10 .. 13 :
56162: GO 56672
56164: LD_INT 10
56166: DOUBLE
56167: GREATEREQUAL
56168: IFFALSE 56176
56170: LD_INT 13
56172: DOUBLE
56173: LESSEQUAL
56174: IFTRUE 56178
56176: GO 56255
56178: POP
// begin bc_type := b_lab_full ;
56179: LD_ADDR_OWVAR 42
56183: PUSH
56184: LD_INT 8
56186: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56187: LD_ADDR_OWVAR 44
56191: PUSH
56192: LD_INT 10
56194: PUSH
56195: LD_INT 12
56197: PUSH
56198: LD_INT 14
56200: PUSH
56201: LD_INT 13
56203: PUSH
56204: EMPTY
56205: LIST
56206: LIST
56207: LIST
56208: LIST
56209: PUSH
56210: LD_VAR 0 2
56214: PUSH
56215: LD_INT 9
56217: MINUS
56218: ARRAY
56219: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56220: LD_ADDR_OWVAR 45
56224: PUSH
56225: LD_INT 11
56227: PUSH
56228: LD_INT 15
56230: PUSH
56231: LD_INT 12
56233: PUSH
56234: LD_INT 15
56236: PUSH
56237: EMPTY
56238: LIST
56239: LIST
56240: LIST
56241: LIST
56242: PUSH
56243: LD_VAR 0 2
56247: PUSH
56248: LD_INT 9
56250: MINUS
56251: ARRAY
56252: ST_TO_ADDR
// end ; 14 :
56253: GO 56672
56255: LD_INT 14
56257: DOUBLE
56258: EQUAL
56259: IFTRUE 56263
56261: GO 56274
56263: POP
// bc_type := b_workshop ; 15 :
56264: LD_ADDR_OWVAR 42
56268: PUSH
56269: LD_INT 2
56271: ST_TO_ADDR
56272: GO 56672
56274: LD_INT 15
56276: DOUBLE
56277: EQUAL
56278: IFTRUE 56282
56280: GO 56293
56282: POP
// bc_type := b_factory ; 16 :
56283: LD_ADDR_OWVAR 42
56287: PUSH
56288: LD_INT 3
56290: ST_TO_ADDR
56291: GO 56672
56293: LD_INT 16
56295: DOUBLE
56296: EQUAL
56297: IFTRUE 56301
56299: GO 56312
56301: POP
// bc_type := b_ext_gun ; 17 :
56302: LD_ADDR_OWVAR 42
56306: PUSH
56307: LD_INT 17
56309: ST_TO_ADDR
56310: GO 56672
56312: LD_INT 17
56314: DOUBLE
56315: EQUAL
56316: IFTRUE 56320
56318: GO 56348
56320: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56321: LD_ADDR_OWVAR 42
56325: PUSH
56326: LD_INT 19
56328: PUSH
56329: LD_INT 23
56331: PUSH
56332: LD_INT 19
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: LIST
56339: PUSH
56340: LD_VAR 0 1
56344: ARRAY
56345: ST_TO_ADDR
56346: GO 56672
56348: LD_INT 18
56350: DOUBLE
56351: EQUAL
56352: IFTRUE 56356
56354: GO 56367
56356: POP
// bc_type := b_ext_radar ; 19 :
56357: LD_ADDR_OWVAR 42
56361: PUSH
56362: LD_INT 20
56364: ST_TO_ADDR
56365: GO 56672
56367: LD_INT 19
56369: DOUBLE
56370: EQUAL
56371: IFTRUE 56375
56373: GO 56386
56375: POP
// bc_type := b_ext_radio ; 20 :
56376: LD_ADDR_OWVAR 42
56380: PUSH
56381: LD_INT 22
56383: ST_TO_ADDR
56384: GO 56672
56386: LD_INT 20
56388: DOUBLE
56389: EQUAL
56390: IFTRUE 56394
56392: GO 56405
56394: POP
// bc_type := b_ext_siberium ; 21 :
56395: LD_ADDR_OWVAR 42
56399: PUSH
56400: LD_INT 21
56402: ST_TO_ADDR
56403: GO 56672
56405: LD_INT 21
56407: DOUBLE
56408: EQUAL
56409: IFTRUE 56413
56411: GO 56424
56413: POP
// bc_type := b_ext_computer ; 22 :
56414: LD_ADDR_OWVAR 42
56418: PUSH
56419: LD_INT 24
56421: ST_TO_ADDR
56422: GO 56672
56424: LD_INT 22
56426: DOUBLE
56427: EQUAL
56428: IFTRUE 56432
56430: GO 56443
56432: POP
// bc_type := b_ext_track ; 23 :
56433: LD_ADDR_OWVAR 42
56437: PUSH
56438: LD_INT 16
56440: ST_TO_ADDR
56441: GO 56672
56443: LD_INT 23
56445: DOUBLE
56446: EQUAL
56447: IFTRUE 56451
56449: GO 56462
56451: POP
// bc_type := b_ext_laser ; 24 :
56452: LD_ADDR_OWVAR 42
56456: PUSH
56457: LD_INT 25
56459: ST_TO_ADDR
56460: GO 56672
56462: LD_INT 24
56464: DOUBLE
56465: EQUAL
56466: IFTRUE 56470
56468: GO 56481
56470: POP
// bc_type := b_control_tower ; 25 :
56471: LD_ADDR_OWVAR 42
56475: PUSH
56476: LD_INT 36
56478: ST_TO_ADDR
56479: GO 56672
56481: LD_INT 25
56483: DOUBLE
56484: EQUAL
56485: IFTRUE 56489
56487: GO 56500
56489: POP
// bc_type := b_breastwork ; 26 :
56490: LD_ADDR_OWVAR 42
56494: PUSH
56495: LD_INT 31
56497: ST_TO_ADDR
56498: GO 56672
56500: LD_INT 26
56502: DOUBLE
56503: EQUAL
56504: IFTRUE 56508
56506: GO 56519
56508: POP
// bc_type := b_bunker ; 27 :
56509: LD_ADDR_OWVAR 42
56513: PUSH
56514: LD_INT 32
56516: ST_TO_ADDR
56517: GO 56672
56519: LD_INT 27
56521: DOUBLE
56522: EQUAL
56523: IFTRUE 56527
56525: GO 56538
56527: POP
// bc_type := b_turret ; 28 :
56528: LD_ADDR_OWVAR 42
56532: PUSH
56533: LD_INT 33
56535: ST_TO_ADDR
56536: GO 56672
56538: LD_INT 28
56540: DOUBLE
56541: EQUAL
56542: IFTRUE 56546
56544: GO 56557
56546: POP
// bc_type := b_armoury ; 29 :
56547: LD_ADDR_OWVAR 42
56551: PUSH
56552: LD_INT 4
56554: ST_TO_ADDR
56555: GO 56672
56557: LD_INT 29
56559: DOUBLE
56560: EQUAL
56561: IFTRUE 56565
56563: GO 56576
56565: POP
// bc_type := b_barracks ; 30 :
56566: LD_ADDR_OWVAR 42
56570: PUSH
56571: LD_INT 5
56573: ST_TO_ADDR
56574: GO 56672
56576: LD_INT 30
56578: DOUBLE
56579: EQUAL
56580: IFTRUE 56584
56582: GO 56595
56584: POP
// bc_type := b_solar_power ; 31 :
56585: LD_ADDR_OWVAR 42
56589: PUSH
56590: LD_INT 27
56592: ST_TO_ADDR
56593: GO 56672
56595: LD_INT 31
56597: DOUBLE
56598: EQUAL
56599: IFTRUE 56603
56601: GO 56614
56603: POP
// bc_type := b_oil_power ; 32 :
56604: LD_ADDR_OWVAR 42
56608: PUSH
56609: LD_INT 26
56611: ST_TO_ADDR
56612: GO 56672
56614: LD_INT 32
56616: DOUBLE
56617: EQUAL
56618: IFTRUE 56622
56620: GO 56633
56622: POP
// bc_type := b_siberite_power ; 33 :
56623: LD_ADDR_OWVAR 42
56627: PUSH
56628: LD_INT 28
56630: ST_TO_ADDR
56631: GO 56672
56633: LD_INT 33
56635: DOUBLE
56636: EQUAL
56637: IFTRUE 56641
56639: GO 56652
56641: POP
// bc_type := b_oil_mine ; 34 :
56642: LD_ADDR_OWVAR 42
56646: PUSH
56647: LD_INT 29
56649: ST_TO_ADDR
56650: GO 56672
56652: LD_INT 34
56654: DOUBLE
56655: EQUAL
56656: IFTRUE 56660
56658: GO 56671
56660: POP
// bc_type := b_siberite_mine ; end ;
56661: LD_ADDR_OWVAR 42
56665: PUSH
56666: LD_INT 30
56668: ST_TO_ADDR
56669: GO 56672
56671: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56672: LD_ADDR_VAR 0 8
56676: PUSH
56677: LD_VAR 0 5
56681: PPUSH
56682: LD_VAR 0 6
56686: PPUSH
56687: LD_VAR 0 3
56691: PPUSH
56692: CALL_OW 47
56696: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56697: LD_OWVAR 42
56701: PUSH
56702: LD_INT 32
56704: PUSH
56705: LD_INT 33
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: IN
56712: IFFALSE 56728
// PlaceWeaponTurret ( b , weapon ) ;
56714: LD_VAR 0 8
56718: PPUSH
56719: LD_VAR 0 4
56723: PPUSH
56724: CALL_OW 431
// end ;
56728: LD_VAR 0 7
56732: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56733: LD_INT 0
56735: PPUSH
56736: PPUSH
56737: PPUSH
56738: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56739: LD_ADDR_VAR 0 4
56743: PUSH
56744: LD_INT 22
56746: PUSH
56747: LD_OWVAR 2
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: PUSH
56756: LD_INT 2
56758: PUSH
56759: LD_INT 30
56761: PUSH
56762: LD_INT 0
56764: PUSH
56765: EMPTY
56766: LIST
56767: LIST
56768: PUSH
56769: LD_INT 30
56771: PUSH
56772: LD_INT 1
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: LIST
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: PPUSH
56788: CALL_OW 69
56792: ST_TO_ADDR
// if not tmp then
56793: LD_VAR 0 4
56797: NOT
56798: IFFALSE 56802
// exit ;
56800: GO 56861
// for i in tmp do
56802: LD_ADDR_VAR 0 2
56806: PUSH
56807: LD_VAR 0 4
56811: PUSH
56812: FOR_IN
56813: IFFALSE 56859
// for j = 1 to 3 do
56815: LD_ADDR_VAR 0 3
56819: PUSH
56820: DOUBLE
56821: LD_INT 1
56823: DEC
56824: ST_TO_ADDR
56825: LD_INT 3
56827: PUSH
56828: FOR_TO
56829: IFFALSE 56855
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56831: LD_VAR 0 2
56835: PPUSH
56836: CALL_OW 274
56840: PPUSH
56841: LD_VAR 0 3
56845: PPUSH
56846: LD_INT 99999
56848: PPUSH
56849: CALL_OW 277
56853: GO 56828
56855: POP
56856: POP
56857: GO 56812
56859: POP
56860: POP
// end ;
56861: LD_VAR 0 1
56865: RET
// export function hHackSetLevel10 ; var i , j ; begin
56866: LD_INT 0
56868: PPUSH
56869: PPUSH
56870: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56871: LD_ADDR_VAR 0 2
56875: PUSH
56876: LD_INT 21
56878: PUSH
56879: LD_INT 1
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PPUSH
56886: CALL_OW 69
56890: PUSH
56891: FOR_IN
56892: IFFALSE 56944
// if IsSelected ( i ) then
56894: LD_VAR 0 2
56898: PPUSH
56899: CALL_OW 306
56903: IFFALSE 56942
// begin for j := 1 to 4 do
56905: LD_ADDR_VAR 0 3
56909: PUSH
56910: DOUBLE
56911: LD_INT 1
56913: DEC
56914: ST_TO_ADDR
56915: LD_INT 4
56917: PUSH
56918: FOR_TO
56919: IFFALSE 56940
// SetSkill ( i , j , 10 ) ;
56921: LD_VAR 0 2
56925: PPUSH
56926: LD_VAR 0 3
56930: PPUSH
56931: LD_INT 10
56933: PPUSH
56934: CALL_OW 237
56938: GO 56918
56940: POP
56941: POP
// end ;
56942: GO 56891
56944: POP
56945: POP
// end ;
56946: LD_VAR 0 1
56950: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56951: LD_INT 0
56953: PPUSH
56954: PPUSH
56955: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56956: LD_ADDR_VAR 0 2
56960: PUSH
56961: LD_INT 22
56963: PUSH
56964: LD_OWVAR 2
56968: PUSH
56969: EMPTY
56970: LIST
56971: LIST
56972: PUSH
56973: LD_INT 21
56975: PUSH
56976: LD_INT 1
56978: PUSH
56979: EMPTY
56980: LIST
56981: LIST
56982: PUSH
56983: EMPTY
56984: LIST
56985: LIST
56986: PPUSH
56987: CALL_OW 69
56991: PUSH
56992: FOR_IN
56993: IFFALSE 57034
// begin for j := 1 to 4 do
56995: LD_ADDR_VAR 0 3
56999: PUSH
57000: DOUBLE
57001: LD_INT 1
57003: DEC
57004: ST_TO_ADDR
57005: LD_INT 4
57007: PUSH
57008: FOR_TO
57009: IFFALSE 57030
// SetSkill ( i , j , 10 ) ;
57011: LD_VAR 0 2
57015: PPUSH
57016: LD_VAR 0 3
57020: PPUSH
57021: LD_INT 10
57023: PPUSH
57024: CALL_OW 237
57028: GO 57008
57030: POP
57031: POP
// end ;
57032: GO 56992
57034: POP
57035: POP
// end ;
57036: LD_VAR 0 1
57040: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57041: LD_INT 0
57043: PPUSH
// uc_side := your_side ;
57044: LD_ADDR_OWVAR 20
57048: PUSH
57049: LD_OWVAR 2
57053: ST_TO_ADDR
// uc_nation := nation ;
57054: LD_ADDR_OWVAR 21
57058: PUSH
57059: LD_VAR 0 1
57063: ST_TO_ADDR
// InitHc ;
57064: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57068: LD_INT 0
57070: PPUSH
57071: LD_VAR 0 2
57075: PPUSH
57076: LD_VAR 0 3
57080: PPUSH
57081: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57085: LD_VAR 0 4
57089: PPUSH
57090: LD_VAR 0 5
57094: PPUSH
57095: CALL_OW 428
57099: PUSH
57100: LD_INT 0
57102: EQUAL
57103: IFFALSE 57127
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57105: CALL_OW 44
57109: PPUSH
57110: LD_VAR 0 4
57114: PPUSH
57115: LD_VAR 0 5
57119: PPUSH
57120: LD_INT 1
57122: PPUSH
57123: CALL_OW 48
// end ;
57127: LD_VAR 0 6
57131: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57132: LD_INT 0
57134: PPUSH
57135: PPUSH
// uc_side := your_side ;
57136: LD_ADDR_OWVAR 20
57140: PUSH
57141: LD_OWVAR 2
57145: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57146: LD_VAR 0 1
57150: PUSH
57151: LD_INT 1
57153: PUSH
57154: LD_INT 2
57156: PUSH
57157: LD_INT 3
57159: PUSH
57160: LD_INT 4
57162: PUSH
57163: LD_INT 5
57165: PUSH
57166: EMPTY
57167: LIST
57168: LIST
57169: LIST
57170: LIST
57171: LIST
57172: IN
57173: IFFALSE 57185
// uc_nation := nation_american else
57175: LD_ADDR_OWVAR 21
57179: PUSH
57180: LD_INT 1
57182: ST_TO_ADDR
57183: GO 57228
// if chassis in [ 11 , 12 , 13 , 14 ] then
57185: LD_VAR 0 1
57189: PUSH
57190: LD_INT 11
57192: PUSH
57193: LD_INT 12
57195: PUSH
57196: LD_INT 13
57198: PUSH
57199: LD_INT 14
57201: PUSH
57202: EMPTY
57203: LIST
57204: LIST
57205: LIST
57206: LIST
57207: IN
57208: IFFALSE 57220
// uc_nation := nation_arabian else
57210: LD_ADDR_OWVAR 21
57214: PUSH
57215: LD_INT 2
57217: ST_TO_ADDR
57218: GO 57228
// uc_nation := nation_russian ;
57220: LD_ADDR_OWVAR 21
57224: PUSH
57225: LD_INT 3
57227: ST_TO_ADDR
// vc_chassis := chassis ;
57228: LD_ADDR_OWVAR 37
57232: PUSH
57233: LD_VAR 0 1
57237: ST_TO_ADDR
// vc_engine := engine ;
57238: LD_ADDR_OWVAR 39
57242: PUSH
57243: LD_VAR 0 2
57247: ST_TO_ADDR
// vc_control := control ;
57248: LD_ADDR_OWVAR 38
57252: PUSH
57253: LD_VAR 0 3
57257: ST_TO_ADDR
// vc_weapon := weapon ;
57258: LD_ADDR_OWVAR 40
57262: PUSH
57263: LD_VAR 0 4
57267: ST_TO_ADDR
// un := CreateVehicle ;
57268: LD_ADDR_VAR 0 8
57272: PUSH
57273: CALL_OW 45
57277: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57278: LD_VAR 0 8
57282: PPUSH
57283: LD_INT 0
57285: PPUSH
57286: LD_INT 5
57288: PPUSH
57289: CALL_OW 12
57293: PPUSH
57294: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57298: LD_VAR 0 8
57302: PPUSH
57303: LD_VAR 0 5
57307: PPUSH
57308: LD_VAR 0 6
57312: PPUSH
57313: LD_INT 1
57315: PPUSH
57316: CALL_OW 48
// end ;
57320: LD_VAR 0 7
57324: RET
// export hInvincible ; every 1 do
57325: GO 57327
57327: DISABLE
// hInvincible := [ ] ;
57328: LD_ADDR_EXP 131
57332: PUSH
57333: EMPTY
57334: ST_TO_ADDR
57335: END
// every 10 do var i ;
57336: GO 57338
57338: DISABLE
57339: LD_INT 0
57341: PPUSH
// begin enable ;
57342: ENABLE
// if not hInvincible then
57343: LD_EXP 131
57347: NOT
57348: IFFALSE 57352
// exit ;
57350: GO 57396
// for i in hInvincible do
57352: LD_ADDR_VAR 0 1
57356: PUSH
57357: LD_EXP 131
57361: PUSH
57362: FOR_IN
57363: IFFALSE 57394
// if GetLives ( i ) < 1000 then
57365: LD_VAR 0 1
57369: PPUSH
57370: CALL_OW 256
57374: PUSH
57375: LD_INT 1000
57377: LESS
57378: IFFALSE 57392
// SetLives ( i , 1000 ) ;
57380: LD_VAR 0 1
57384: PPUSH
57385: LD_INT 1000
57387: PPUSH
57388: CALL_OW 234
57392: GO 57362
57394: POP
57395: POP
// end ;
57396: PPOPN 1
57398: END
// export function hHackInvincible ; var i ; begin
57399: LD_INT 0
57401: PPUSH
57402: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57403: LD_ADDR_VAR 0 2
57407: PUSH
57408: LD_INT 2
57410: PUSH
57411: LD_INT 21
57413: PUSH
57414: LD_INT 1
57416: PUSH
57417: EMPTY
57418: LIST
57419: LIST
57420: PUSH
57421: LD_INT 21
57423: PUSH
57424: LD_INT 2
57426: PUSH
57427: EMPTY
57428: LIST
57429: LIST
57430: PUSH
57431: EMPTY
57432: LIST
57433: LIST
57434: LIST
57435: PPUSH
57436: CALL_OW 69
57440: PUSH
57441: FOR_IN
57442: IFFALSE 57503
// if IsSelected ( i ) then
57444: LD_VAR 0 2
57448: PPUSH
57449: CALL_OW 306
57453: IFFALSE 57501
// begin if i in hInvincible then
57455: LD_VAR 0 2
57459: PUSH
57460: LD_EXP 131
57464: IN
57465: IFFALSE 57485
// hInvincible := hInvincible diff i else
57467: LD_ADDR_EXP 131
57471: PUSH
57472: LD_EXP 131
57476: PUSH
57477: LD_VAR 0 2
57481: DIFF
57482: ST_TO_ADDR
57483: GO 57501
// hInvincible := hInvincible union i ;
57485: LD_ADDR_EXP 131
57489: PUSH
57490: LD_EXP 131
57494: PUSH
57495: LD_VAR 0 2
57499: UNION
57500: ST_TO_ADDR
// end ;
57501: GO 57441
57503: POP
57504: POP
// end ;
57505: LD_VAR 0 1
57509: RET
// export function hHackInvisible ; var i , j ; begin
57510: LD_INT 0
57512: PPUSH
57513: PPUSH
57514: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57515: LD_ADDR_VAR 0 2
57519: PUSH
57520: LD_INT 21
57522: PUSH
57523: LD_INT 1
57525: PUSH
57526: EMPTY
57527: LIST
57528: LIST
57529: PPUSH
57530: CALL_OW 69
57534: PUSH
57535: FOR_IN
57536: IFFALSE 57560
// if IsSelected ( i ) then
57538: LD_VAR 0 2
57542: PPUSH
57543: CALL_OW 306
57547: IFFALSE 57558
// ComForceInvisible ( i ) ;
57549: LD_VAR 0 2
57553: PPUSH
57554: CALL_OW 496
57558: GO 57535
57560: POP
57561: POP
// end ;
57562: LD_VAR 0 1
57566: RET
// export function hHackChangeYourSide ; begin
57567: LD_INT 0
57569: PPUSH
// if your_side = 8 then
57570: LD_OWVAR 2
57574: PUSH
57575: LD_INT 8
57577: EQUAL
57578: IFFALSE 57590
// your_side := 0 else
57580: LD_ADDR_OWVAR 2
57584: PUSH
57585: LD_INT 0
57587: ST_TO_ADDR
57588: GO 57604
// your_side := your_side + 1 ;
57590: LD_ADDR_OWVAR 2
57594: PUSH
57595: LD_OWVAR 2
57599: PUSH
57600: LD_INT 1
57602: PLUS
57603: ST_TO_ADDR
// end ;
57604: LD_VAR 0 1
57608: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57609: LD_INT 0
57611: PPUSH
57612: PPUSH
57613: PPUSH
// for i in all_units do
57614: LD_ADDR_VAR 0 2
57618: PUSH
57619: LD_OWVAR 3
57623: PUSH
57624: FOR_IN
57625: IFFALSE 57703
// if IsSelected ( i ) then
57627: LD_VAR 0 2
57631: PPUSH
57632: CALL_OW 306
57636: IFFALSE 57701
// begin j := GetSide ( i ) ;
57638: LD_ADDR_VAR 0 3
57642: PUSH
57643: LD_VAR 0 2
57647: PPUSH
57648: CALL_OW 255
57652: ST_TO_ADDR
// if j = 8 then
57653: LD_VAR 0 3
57657: PUSH
57658: LD_INT 8
57660: EQUAL
57661: IFFALSE 57673
// j := 0 else
57663: LD_ADDR_VAR 0 3
57667: PUSH
57668: LD_INT 0
57670: ST_TO_ADDR
57671: GO 57687
// j := j + 1 ;
57673: LD_ADDR_VAR 0 3
57677: PUSH
57678: LD_VAR 0 3
57682: PUSH
57683: LD_INT 1
57685: PLUS
57686: ST_TO_ADDR
// SetSide ( i , j ) ;
57687: LD_VAR 0 2
57691: PPUSH
57692: LD_VAR 0 3
57696: PPUSH
57697: CALL_OW 235
// end ;
57701: GO 57624
57703: POP
57704: POP
// end ;
57705: LD_VAR 0 1
57709: RET
// export function hHackFog ; begin
57710: LD_INT 0
57712: PPUSH
// FogOff ( true ) ;
57713: LD_INT 1
57715: PPUSH
57716: CALL_OW 344
// end ;
57720: LD_VAR 0 1
57724: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57725: LD_INT 0
57727: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57728: LD_VAR 0 1
57732: PPUSH
57733: LD_VAR 0 2
57737: PPUSH
57738: LD_VAR 0 3
57742: PPUSH
57743: LD_INT 1
57745: PPUSH
57746: LD_INT 1
57748: PPUSH
57749: CALL_OW 483
// CenterOnXY ( x , y ) ;
57753: LD_VAR 0 2
57757: PPUSH
57758: LD_VAR 0 3
57762: PPUSH
57763: CALL_OW 84
// end ;
57767: LD_VAR 0 4
57771: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57772: LD_INT 0
57774: PPUSH
57775: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57776: LD_VAR 0 1
57780: NOT
57781: PUSH
57782: LD_VAR 0 2
57786: PPUSH
57787: LD_VAR 0 3
57791: PPUSH
57792: CALL_OW 488
57796: NOT
57797: OR
57798: PUSH
57799: LD_VAR 0 1
57803: PPUSH
57804: CALL_OW 266
57808: PUSH
57809: LD_INT 3
57811: NONEQUAL
57812: PUSH
57813: LD_VAR 0 1
57817: PPUSH
57818: CALL_OW 247
57822: PUSH
57823: LD_INT 1
57825: EQUAL
57826: NOT
57827: AND
57828: OR
57829: IFFALSE 57833
// exit ;
57831: GO 57982
// if GetType ( factory ) = unit_human then
57833: LD_VAR 0 1
57837: PPUSH
57838: CALL_OW 247
57842: PUSH
57843: LD_INT 1
57845: EQUAL
57846: IFFALSE 57863
// factory := IsInUnit ( factory ) ;
57848: LD_ADDR_VAR 0 1
57852: PUSH
57853: LD_VAR 0 1
57857: PPUSH
57858: CALL_OW 310
57862: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57863: LD_VAR 0 1
57867: PPUSH
57868: CALL_OW 266
57872: PUSH
57873: LD_INT 3
57875: NONEQUAL
57876: IFFALSE 57880
// exit ;
57878: GO 57982
// if HexInfo ( x , y ) = factory then
57880: LD_VAR 0 2
57884: PPUSH
57885: LD_VAR 0 3
57889: PPUSH
57890: CALL_OW 428
57894: PUSH
57895: LD_VAR 0 1
57899: EQUAL
57900: IFFALSE 57927
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57902: LD_ADDR_EXP 132
57906: PUSH
57907: LD_EXP 132
57911: PPUSH
57912: LD_VAR 0 1
57916: PPUSH
57917: LD_INT 0
57919: PPUSH
57920: CALL_OW 1
57924: ST_TO_ADDR
57925: GO 57978
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57927: LD_ADDR_EXP 132
57931: PUSH
57932: LD_EXP 132
57936: PPUSH
57937: LD_VAR 0 1
57941: PPUSH
57942: LD_VAR 0 1
57946: PPUSH
57947: CALL_OW 255
57951: PUSH
57952: LD_VAR 0 1
57956: PUSH
57957: LD_VAR 0 2
57961: PUSH
57962: LD_VAR 0 3
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: LIST
57971: LIST
57972: PPUSH
57973: CALL_OW 1
57977: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57978: CALL 57987 0 0
// end ;
57982: LD_VAR 0 4
57986: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57987: LD_INT 0
57989: PPUSH
57990: PPUSH
57991: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57992: LD_STRING resetFactoryWaypoint();
57994: PPUSH
57995: CALL_OW 559
// if factoryWaypoints then
57999: LD_EXP 132
58003: IFFALSE 58129
// begin list := PrepareArray ( factoryWaypoints ) ;
58005: LD_ADDR_VAR 0 3
58009: PUSH
58010: LD_EXP 132
58014: PPUSH
58015: CALL 105426 0 1
58019: ST_TO_ADDR
// for i := 1 to list do
58020: LD_ADDR_VAR 0 2
58024: PUSH
58025: DOUBLE
58026: LD_INT 1
58028: DEC
58029: ST_TO_ADDR
58030: LD_VAR 0 3
58034: PUSH
58035: FOR_TO
58036: IFFALSE 58127
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58038: LD_STRING setFactoryWaypointXY(
58040: PUSH
58041: LD_VAR 0 3
58045: PUSH
58046: LD_VAR 0 2
58050: ARRAY
58051: PUSH
58052: LD_INT 1
58054: ARRAY
58055: STR
58056: PUSH
58057: LD_STRING ,
58059: STR
58060: PUSH
58061: LD_VAR 0 3
58065: PUSH
58066: LD_VAR 0 2
58070: ARRAY
58071: PUSH
58072: LD_INT 2
58074: ARRAY
58075: STR
58076: PUSH
58077: LD_STRING ,
58079: STR
58080: PUSH
58081: LD_VAR 0 3
58085: PUSH
58086: LD_VAR 0 2
58090: ARRAY
58091: PUSH
58092: LD_INT 3
58094: ARRAY
58095: STR
58096: PUSH
58097: LD_STRING ,
58099: STR
58100: PUSH
58101: LD_VAR 0 3
58105: PUSH
58106: LD_VAR 0 2
58110: ARRAY
58111: PUSH
58112: LD_INT 4
58114: ARRAY
58115: STR
58116: PUSH
58117: LD_STRING )
58119: STR
58120: PPUSH
58121: CALL_OW 559
58125: GO 58035
58127: POP
58128: POP
// end ; end ;
58129: LD_VAR 0 1
58133: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
58134: LD_INT 0
58136: PPUSH
// if HexInfo ( x , y ) = warehouse then
58137: LD_VAR 0 2
58141: PPUSH
58142: LD_VAR 0 3
58146: PPUSH
58147: CALL_OW 428
58151: PUSH
58152: LD_VAR 0 1
58156: EQUAL
58157: IFFALSE 58184
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58159: LD_ADDR_EXP 133
58163: PUSH
58164: LD_EXP 133
58168: PPUSH
58169: LD_VAR 0 1
58173: PPUSH
58174: LD_INT 0
58176: PPUSH
58177: CALL_OW 1
58181: ST_TO_ADDR
58182: GO 58235
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58184: LD_ADDR_EXP 133
58188: PUSH
58189: LD_EXP 133
58193: PPUSH
58194: LD_VAR 0 1
58198: PPUSH
58199: LD_VAR 0 1
58203: PPUSH
58204: CALL_OW 255
58208: PUSH
58209: LD_VAR 0 1
58213: PUSH
58214: LD_VAR 0 2
58218: PUSH
58219: LD_VAR 0 3
58223: PUSH
58224: EMPTY
58225: LIST
58226: LIST
58227: LIST
58228: LIST
58229: PPUSH
58230: CALL_OW 1
58234: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58235: CALL 58244 0 0
// end ;
58239: LD_VAR 0 4
58243: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58244: LD_INT 0
58246: PPUSH
58247: PPUSH
58248: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58249: LD_STRING resetWarehouseGatheringPoints();
58251: PPUSH
58252: CALL_OW 559
// if warehouseGatheringPoints then
58256: LD_EXP 133
58260: IFFALSE 58386
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58262: LD_ADDR_VAR 0 3
58266: PUSH
58267: LD_EXP 133
58271: PPUSH
58272: CALL 105426 0 1
58276: ST_TO_ADDR
// for i := 1 to list do
58277: LD_ADDR_VAR 0 2
58281: PUSH
58282: DOUBLE
58283: LD_INT 1
58285: DEC
58286: ST_TO_ADDR
58287: LD_VAR 0 3
58291: PUSH
58292: FOR_TO
58293: IFFALSE 58384
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58295: LD_STRING setWarehouseGatheringPointXY(
58297: PUSH
58298: LD_VAR 0 3
58302: PUSH
58303: LD_VAR 0 2
58307: ARRAY
58308: PUSH
58309: LD_INT 1
58311: ARRAY
58312: STR
58313: PUSH
58314: LD_STRING ,
58316: STR
58317: PUSH
58318: LD_VAR 0 3
58322: PUSH
58323: LD_VAR 0 2
58327: ARRAY
58328: PUSH
58329: LD_INT 2
58331: ARRAY
58332: STR
58333: PUSH
58334: LD_STRING ,
58336: STR
58337: PUSH
58338: LD_VAR 0 3
58342: PUSH
58343: LD_VAR 0 2
58347: ARRAY
58348: PUSH
58349: LD_INT 3
58351: ARRAY
58352: STR
58353: PUSH
58354: LD_STRING ,
58356: STR
58357: PUSH
58358: LD_VAR 0 3
58362: PUSH
58363: LD_VAR 0 2
58367: ARRAY
58368: PUSH
58369: LD_INT 4
58371: ARRAY
58372: STR
58373: PUSH
58374: LD_STRING )
58376: STR
58377: PPUSH
58378: CALL_OW 559
58382: GO 58292
58384: POP
58385: POP
// end ; end ;
58386: LD_VAR 0 1
58390: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58391: LD_EXP 133
58395: IFFALSE 59080
58397: GO 58399
58399: DISABLE
58400: LD_INT 0
58402: PPUSH
58403: PPUSH
58404: PPUSH
58405: PPUSH
58406: PPUSH
58407: PPUSH
58408: PPUSH
58409: PPUSH
58410: PPUSH
// begin enable ;
58411: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58412: LD_ADDR_VAR 0 3
58416: PUSH
58417: LD_EXP 133
58421: PPUSH
58422: CALL 105426 0 1
58426: ST_TO_ADDR
// if not list then
58427: LD_VAR 0 3
58431: NOT
58432: IFFALSE 58436
// exit ;
58434: GO 59080
// for i := 1 to list do
58436: LD_ADDR_VAR 0 1
58440: PUSH
58441: DOUBLE
58442: LD_INT 1
58444: DEC
58445: ST_TO_ADDR
58446: LD_VAR 0 3
58450: PUSH
58451: FOR_TO
58452: IFFALSE 59078
// begin depot := list [ i ] [ 2 ] ;
58454: LD_ADDR_VAR 0 8
58458: PUSH
58459: LD_VAR 0 3
58463: PUSH
58464: LD_VAR 0 1
58468: ARRAY
58469: PUSH
58470: LD_INT 2
58472: ARRAY
58473: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58474: LD_ADDR_VAR 0 5
58478: PUSH
58479: LD_VAR 0 3
58483: PUSH
58484: LD_VAR 0 1
58488: ARRAY
58489: PUSH
58490: LD_INT 1
58492: ARRAY
58493: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58494: LD_VAR 0 8
58498: PPUSH
58499: CALL_OW 301
58503: PUSH
58504: LD_VAR 0 5
58508: PUSH
58509: LD_VAR 0 8
58513: PPUSH
58514: CALL_OW 255
58518: NONEQUAL
58519: OR
58520: IFFALSE 58549
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58522: LD_ADDR_EXP 133
58526: PUSH
58527: LD_EXP 133
58531: PPUSH
58532: LD_VAR 0 8
58536: PPUSH
58537: LD_INT 0
58539: PPUSH
58540: CALL_OW 1
58544: ST_TO_ADDR
// exit ;
58545: POP
58546: POP
58547: GO 59080
// end ; x := list [ i ] [ 3 ] ;
58549: LD_ADDR_VAR 0 6
58553: PUSH
58554: LD_VAR 0 3
58558: PUSH
58559: LD_VAR 0 1
58563: ARRAY
58564: PUSH
58565: LD_INT 3
58567: ARRAY
58568: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58569: LD_ADDR_VAR 0 7
58573: PUSH
58574: LD_VAR 0 3
58578: PUSH
58579: LD_VAR 0 1
58583: ARRAY
58584: PUSH
58585: LD_INT 4
58587: ARRAY
58588: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58589: LD_ADDR_VAR 0 9
58593: PUSH
58594: LD_VAR 0 6
58598: PPUSH
58599: LD_VAR 0 7
58603: PPUSH
58604: LD_INT 16
58606: PPUSH
58607: CALL 104014 0 3
58611: ST_TO_ADDR
// if not cratesNearbyPoint then
58612: LD_VAR 0 9
58616: NOT
58617: IFFALSE 58623
// exit ;
58619: POP
58620: POP
58621: GO 59080
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58623: LD_ADDR_VAR 0 4
58627: PUSH
58628: LD_INT 22
58630: PUSH
58631: LD_VAR 0 5
58635: PUSH
58636: EMPTY
58637: LIST
58638: LIST
58639: PUSH
58640: LD_INT 3
58642: PUSH
58643: LD_INT 60
58645: PUSH
58646: EMPTY
58647: LIST
58648: PUSH
58649: EMPTY
58650: LIST
58651: LIST
58652: PUSH
58653: LD_INT 91
58655: PUSH
58656: LD_VAR 0 8
58660: PUSH
58661: LD_INT 6
58663: PUSH
58664: EMPTY
58665: LIST
58666: LIST
58667: LIST
58668: PUSH
58669: LD_INT 2
58671: PUSH
58672: LD_INT 25
58674: PUSH
58675: LD_INT 2
58677: PUSH
58678: EMPTY
58679: LIST
58680: LIST
58681: PUSH
58682: LD_INT 25
58684: PUSH
58685: LD_INT 16
58687: PUSH
58688: EMPTY
58689: LIST
58690: LIST
58691: PUSH
58692: EMPTY
58693: LIST
58694: LIST
58695: LIST
58696: PUSH
58697: EMPTY
58698: LIST
58699: LIST
58700: LIST
58701: LIST
58702: PPUSH
58703: CALL_OW 69
58707: PUSH
58708: LD_VAR 0 8
58712: PPUSH
58713: CALL_OW 313
58717: PPUSH
58718: LD_INT 3
58720: PUSH
58721: LD_INT 60
58723: PUSH
58724: EMPTY
58725: LIST
58726: PUSH
58727: EMPTY
58728: LIST
58729: LIST
58730: PUSH
58731: LD_INT 2
58733: PUSH
58734: LD_INT 25
58736: PUSH
58737: LD_INT 2
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: PUSH
58744: LD_INT 25
58746: PUSH
58747: LD_INT 16
58749: PUSH
58750: EMPTY
58751: LIST
58752: LIST
58753: PUSH
58754: EMPTY
58755: LIST
58756: LIST
58757: LIST
58758: PUSH
58759: EMPTY
58760: LIST
58761: LIST
58762: PPUSH
58763: CALL_OW 72
58767: UNION
58768: ST_TO_ADDR
// if tmp then
58769: LD_VAR 0 4
58773: IFFALSE 58853
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58775: LD_ADDR_VAR 0 4
58779: PUSH
58780: LD_VAR 0 4
58784: PPUSH
58785: LD_INT 3
58787: PPUSH
58788: CALL 101983 0 2
58792: ST_TO_ADDR
// for j in tmp do
58793: LD_ADDR_VAR 0 2
58797: PUSH
58798: LD_VAR 0 4
58802: PUSH
58803: FOR_IN
58804: IFFALSE 58847
// begin if IsInUnit ( j ) then
58806: LD_VAR 0 2
58810: PPUSH
58811: CALL_OW 310
58815: IFFALSE 58826
// ComExit ( j ) ;
58817: LD_VAR 0 2
58821: PPUSH
58822: CALL 102066 0 1
// AddComCollect ( j , x , y ) ;
58826: LD_VAR 0 2
58830: PPUSH
58831: LD_VAR 0 6
58835: PPUSH
58836: LD_VAR 0 7
58840: PPUSH
58841: CALL_OW 177
// end ;
58845: GO 58803
58847: POP
58848: POP
// exit ;
58849: POP
58850: POP
58851: GO 59080
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58853: LD_ADDR_VAR 0 4
58857: PUSH
58858: LD_INT 22
58860: PUSH
58861: LD_VAR 0 5
58865: PUSH
58866: EMPTY
58867: LIST
58868: LIST
58869: PUSH
58870: LD_INT 91
58872: PUSH
58873: LD_VAR 0 8
58877: PUSH
58878: LD_INT 8
58880: PUSH
58881: EMPTY
58882: LIST
58883: LIST
58884: LIST
58885: PUSH
58886: LD_INT 2
58888: PUSH
58889: LD_INT 34
58891: PUSH
58892: LD_INT 12
58894: PUSH
58895: EMPTY
58896: LIST
58897: LIST
58898: PUSH
58899: LD_INT 34
58901: PUSH
58902: LD_INT 51
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: PUSH
58909: LD_INT 34
58911: PUSH
58912: LD_INT 32
58914: PUSH
58915: EMPTY
58916: LIST
58917: LIST
58918: PUSH
58919: LD_INT 34
58921: PUSH
58922: LD_INT 89
58924: PUSH
58925: EMPTY
58926: LIST
58927: LIST
58928: PUSH
58929: EMPTY
58930: LIST
58931: LIST
58932: LIST
58933: LIST
58934: LIST
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: LIST
58940: PPUSH
58941: CALL_OW 69
58945: ST_TO_ADDR
// if tmp then
58946: LD_VAR 0 4
58950: IFFALSE 59076
// begin for j in tmp do
58952: LD_ADDR_VAR 0 2
58956: PUSH
58957: LD_VAR 0 4
58961: PUSH
58962: FOR_IN
58963: IFFALSE 59074
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58965: LD_VAR 0 2
58969: PPUSH
58970: CALL_OW 262
58974: PUSH
58975: LD_INT 3
58977: EQUAL
58978: PUSH
58979: LD_VAR 0 2
58983: PPUSH
58984: CALL_OW 261
58988: PUSH
58989: LD_INT 20
58991: GREATER
58992: OR
58993: PUSH
58994: LD_VAR 0 2
58998: PPUSH
58999: CALL_OW 314
59003: NOT
59004: AND
59005: PUSH
59006: LD_VAR 0 2
59010: PPUSH
59011: CALL_OW 263
59015: PUSH
59016: LD_INT 1
59018: NONEQUAL
59019: PUSH
59020: LD_VAR 0 2
59024: PPUSH
59025: CALL_OW 311
59029: OR
59030: AND
59031: IFFALSE 59072
// begin ComCollect ( j , x , y ) ;
59033: LD_VAR 0 2
59037: PPUSH
59038: LD_VAR 0 6
59042: PPUSH
59043: LD_VAR 0 7
59047: PPUSH
59048: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
59052: LD_VAR 0 2
59056: PPUSH
59057: LD_VAR 0 8
59061: PPUSH
59062: CALL_OW 172
// exit ;
59066: POP
59067: POP
59068: POP
59069: POP
59070: GO 59080
// end ;
59072: GO 58962
59074: POP
59075: POP
// end ; end ;
59076: GO 58451
59078: POP
59079: POP
// end ; end_of_file
59080: PPOPN 9
59082: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59083: LD_INT 0
59085: PPUSH
59086: PPUSH
59087: PPUSH
59088: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59089: LD_VAR 0 1
59093: PPUSH
59094: CALL_OW 264
59098: PUSH
59099: LD_INT 91
59101: EQUAL
59102: IFFALSE 59174
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59104: LD_INT 68
59106: PPUSH
59107: LD_VAR 0 1
59111: PPUSH
59112: CALL_OW 255
59116: PPUSH
59117: CALL_OW 321
59121: PUSH
59122: LD_INT 2
59124: EQUAL
59125: IFFALSE 59137
// eff := 70 else
59127: LD_ADDR_VAR 0 4
59131: PUSH
59132: LD_INT 70
59134: ST_TO_ADDR
59135: GO 59145
// eff := 30 ;
59137: LD_ADDR_VAR 0 4
59141: PUSH
59142: LD_INT 30
59144: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59145: LD_VAR 0 1
59149: PPUSH
59150: CALL_OW 250
59154: PPUSH
59155: LD_VAR 0 1
59159: PPUSH
59160: CALL_OW 251
59164: PPUSH
59165: LD_VAR 0 4
59169: PPUSH
59170: CALL_OW 495
// end ; end ;
59174: LD_VAR 0 2
59178: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59179: LD_INT 0
59181: PPUSH
// end ;
59182: LD_VAR 0 4
59186: RET
// export function SOS_Command ( cmd ) ; begin
59187: LD_INT 0
59189: PPUSH
// end ;
59190: LD_VAR 0 2
59194: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59195: LD_INT 0
59197: PPUSH
// end ;
59198: LD_VAR 0 6
59202: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59203: LD_INT 0
59205: PPUSH
59206: PPUSH
// if not vehicle or not factory then
59207: LD_VAR 0 1
59211: NOT
59212: PUSH
59213: LD_VAR 0 2
59217: NOT
59218: OR
59219: IFFALSE 59223
// exit ;
59221: GO 59454
// if factoryWaypoints >= factory then
59223: LD_EXP 132
59227: PUSH
59228: LD_VAR 0 2
59232: GREATEREQUAL
59233: IFFALSE 59454
// if factoryWaypoints [ factory ] then
59235: LD_EXP 132
59239: PUSH
59240: LD_VAR 0 2
59244: ARRAY
59245: IFFALSE 59454
// begin if GetControl ( vehicle ) = control_manual then
59247: LD_VAR 0 1
59251: PPUSH
59252: CALL_OW 263
59256: PUSH
59257: LD_INT 1
59259: EQUAL
59260: IFFALSE 59341
// begin driver := IsDrivenBy ( vehicle ) ;
59262: LD_ADDR_VAR 0 4
59266: PUSH
59267: LD_VAR 0 1
59271: PPUSH
59272: CALL_OW 311
59276: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59277: LD_VAR 0 4
59281: PPUSH
59282: LD_EXP 132
59286: PUSH
59287: LD_VAR 0 2
59291: ARRAY
59292: PUSH
59293: LD_INT 3
59295: ARRAY
59296: PPUSH
59297: LD_EXP 132
59301: PUSH
59302: LD_VAR 0 2
59306: ARRAY
59307: PUSH
59308: LD_INT 4
59310: ARRAY
59311: PPUSH
59312: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59316: LD_VAR 0 4
59320: PPUSH
59321: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59325: LD_VAR 0 4
59329: PPUSH
59330: LD_VAR 0 2
59334: PPUSH
59335: CALL_OW 180
// end else
59339: GO 59454
// if GetControl ( vehicle ) = control_remote then
59341: LD_VAR 0 1
59345: PPUSH
59346: CALL_OW 263
59350: PUSH
59351: LD_INT 2
59353: EQUAL
59354: IFFALSE 59415
// begin wait ( 0 0$2 ) ;
59356: LD_INT 70
59358: PPUSH
59359: CALL_OW 67
// if Connect ( vehicle ) then
59363: LD_VAR 0 1
59367: PPUSH
59368: CALL 72285 0 1
59372: IFFALSE 59413
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59374: LD_VAR 0 1
59378: PPUSH
59379: LD_EXP 132
59383: PUSH
59384: LD_VAR 0 2
59388: ARRAY
59389: PUSH
59390: LD_INT 3
59392: ARRAY
59393: PPUSH
59394: LD_EXP 132
59398: PUSH
59399: LD_VAR 0 2
59403: ARRAY
59404: PUSH
59405: LD_INT 4
59407: ARRAY
59408: PPUSH
59409: CALL_OW 171
// end else
59413: GO 59454
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59415: LD_VAR 0 1
59419: PPUSH
59420: LD_EXP 132
59424: PUSH
59425: LD_VAR 0 2
59429: ARRAY
59430: PUSH
59431: LD_INT 3
59433: ARRAY
59434: PPUSH
59435: LD_EXP 132
59439: PUSH
59440: LD_VAR 0 2
59444: ARRAY
59445: PUSH
59446: LD_INT 4
59448: ARRAY
59449: PPUSH
59450: CALL_OW 171
// end ; end ;
59454: LD_VAR 0 3
59458: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59459: LD_INT 0
59461: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59462: LD_VAR 0 1
59466: PUSH
59467: LD_INT 250
59469: EQUAL
59470: PUSH
59471: LD_VAR 0 2
59475: PPUSH
59476: CALL_OW 264
59480: PUSH
59481: LD_INT 81
59483: EQUAL
59484: AND
59485: IFFALSE 59506
// MinerPlaceMine ( unit , x , y ) ;
59487: LD_VAR 0 2
59491: PPUSH
59492: LD_VAR 0 4
59496: PPUSH
59497: LD_VAR 0 5
59501: PPUSH
59502: CALL 62496 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59506: LD_VAR 0 1
59510: PUSH
59511: LD_INT 251
59513: EQUAL
59514: PUSH
59515: LD_VAR 0 2
59519: PPUSH
59520: CALL_OW 264
59524: PUSH
59525: LD_INT 81
59527: EQUAL
59528: AND
59529: IFFALSE 59550
// MinerDetonateMine ( unit , x , y ) ;
59531: LD_VAR 0 2
59535: PPUSH
59536: LD_VAR 0 4
59540: PPUSH
59541: LD_VAR 0 5
59545: PPUSH
59546: CALL 62771 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59550: LD_VAR 0 1
59554: PUSH
59555: LD_INT 252
59557: EQUAL
59558: PUSH
59559: LD_VAR 0 2
59563: PPUSH
59564: CALL_OW 264
59568: PUSH
59569: LD_INT 81
59571: EQUAL
59572: AND
59573: IFFALSE 59594
// MinerCreateMinefield ( unit , x , y ) ;
59575: LD_VAR 0 2
59579: PPUSH
59580: LD_VAR 0 4
59584: PPUSH
59585: LD_VAR 0 5
59589: PPUSH
59590: CALL 63188 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59594: LD_VAR 0 1
59598: PUSH
59599: LD_INT 253
59601: EQUAL
59602: PUSH
59603: LD_VAR 0 2
59607: PPUSH
59608: CALL_OW 257
59612: PUSH
59613: LD_INT 5
59615: EQUAL
59616: AND
59617: IFFALSE 59638
// ComBinocular ( unit , x , y ) ;
59619: LD_VAR 0 2
59623: PPUSH
59624: LD_VAR 0 4
59628: PPUSH
59629: LD_VAR 0 5
59633: PPUSH
59634: CALL 63557 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59638: LD_VAR 0 1
59642: PUSH
59643: LD_INT 254
59645: EQUAL
59646: PUSH
59647: LD_VAR 0 2
59651: PPUSH
59652: CALL_OW 264
59656: PUSH
59657: LD_INT 99
59659: EQUAL
59660: AND
59661: PUSH
59662: LD_VAR 0 3
59666: PPUSH
59667: CALL_OW 263
59671: PUSH
59672: LD_INT 3
59674: EQUAL
59675: AND
59676: IFFALSE 59692
// HackDestroyVehicle ( unit , selectedUnit ) ;
59678: LD_VAR 0 2
59682: PPUSH
59683: LD_VAR 0 3
59687: PPUSH
59688: CALL 61860 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59692: LD_VAR 0 1
59696: PUSH
59697: LD_INT 255
59699: EQUAL
59700: PUSH
59701: LD_VAR 0 2
59705: PPUSH
59706: CALL_OW 264
59710: PUSH
59711: LD_INT 14
59713: PUSH
59714: LD_INT 53
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: IN
59721: AND
59722: PUSH
59723: LD_VAR 0 4
59727: PPUSH
59728: LD_VAR 0 5
59732: PPUSH
59733: CALL_OW 488
59737: AND
59738: IFFALSE 59762
// CutTreeXYR ( unit , x , y , 12 ) ;
59740: LD_VAR 0 2
59744: PPUSH
59745: LD_VAR 0 4
59749: PPUSH
59750: LD_VAR 0 5
59754: PPUSH
59755: LD_INT 12
59757: PPUSH
59758: CALL 59857 0 4
// if cmd = 256 then
59762: LD_VAR 0 1
59766: PUSH
59767: LD_INT 256
59769: EQUAL
59770: IFFALSE 59791
// SetFactoryWaypoint ( unit , x , y ) ;
59772: LD_VAR 0 2
59776: PPUSH
59777: LD_VAR 0 4
59781: PPUSH
59782: LD_VAR 0 5
59786: PPUSH
59787: CALL 57772 0 3
// if cmd = 257 then
59791: LD_VAR 0 1
59795: PUSH
59796: LD_INT 257
59798: EQUAL
59799: IFFALSE 59820
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59801: LD_VAR 0 2
59805: PPUSH
59806: LD_VAR 0 4
59810: PPUSH
59811: LD_VAR 0 5
59815: PPUSH
59816: CALL 58134 0 3
// if cmd = 258 then
59820: LD_VAR 0 1
59824: PUSH
59825: LD_INT 258
59827: EQUAL
59828: IFFALSE 59852
// BurnTreeXYR ( unit , x , y , 8 ) ;
59830: LD_VAR 0 2
59834: PPUSH
59835: LD_VAR 0 4
59839: PPUSH
59840: LD_VAR 0 5
59844: PPUSH
59845: LD_INT 8
59847: PPUSH
59848: CALL 60251 0 4
// end ;
59852: LD_VAR 0 6
59856: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59857: LD_INT 0
59859: PPUSH
59860: PPUSH
59861: PPUSH
59862: PPUSH
59863: PPUSH
59864: PPUSH
59865: PPUSH
59866: PPUSH
59867: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
59868: LD_VAR 0 1
59872: PPUSH
59873: CALL_OW 302
59877: NOT
59878: PUSH
59879: LD_VAR 0 2
59883: PPUSH
59884: LD_VAR 0 3
59888: PPUSH
59889: CALL_OW 488
59893: NOT
59894: OR
59895: PUSH
59896: LD_VAR 0 4
59900: NOT
59901: OR
59902: IFFALSE 59906
// exit ;
59904: GO 60246
// list := [ ] ;
59906: LD_ADDR_VAR 0 13
59910: PUSH
59911: EMPTY
59912: ST_TO_ADDR
// if x - r < 0 then
59913: LD_VAR 0 2
59917: PUSH
59918: LD_VAR 0 4
59922: MINUS
59923: PUSH
59924: LD_INT 0
59926: LESS
59927: IFFALSE 59939
// min_x := 0 else
59929: LD_ADDR_VAR 0 7
59933: PUSH
59934: LD_INT 0
59936: ST_TO_ADDR
59937: GO 59955
// min_x := x - r ;
59939: LD_ADDR_VAR 0 7
59943: PUSH
59944: LD_VAR 0 2
59948: PUSH
59949: LD_VAR 0 4
59953: MINUS
59954: ST_TO_ADDR
// if y - r < 0 then
59955: LD_VAR 0 3
59959: PUSH
59960: LD_VAR 0 4
59964: MINUS
59965: PUSH
59966: LD_INT 0
59968: LESS
59969: IFFALSE 59981
// min_y := 0 else
59971: LD_ADDR_VAR 0 8
59975: PUSH
59976: LD_INT 0
59978: ST_TO_ADDR
59979: GO 59997
// min_y := y - r ;
59981: LD_ADDR_VAR 0 8
59985: PUSH
59986: LD_VAR 0 3
59990: PUSH
59991: LD_VAR 0 4
59995: MINUS
59996: ST_TO_ADDR
// max_x := x + r ;
59997: LD_ADDR_VAR 0 9
60001: PUSH
60002: LD_VAR 0 2
60006: PUSH
60007: LD_VAR 0 4
60011: PLUS
60012: ST_TO_ADDR
// max_y := y + r ;
60013: LD_ADDR_VAR 0 10
60017: PUSH
60018: LD_VAR 0 3
60022: PUSH
60023: LD_VAR 0 4
60027: PLUS
60028: ST_TO_ADDR
// for _x = min_x to max_x do
60029: LD_ADDR_VAR 0 11
60033: PUSH
60034: DOUBLE
60035: LD_VAR 0 7
60039: DEC
60040: ST_TO_ADDR
60041: LD_VAR 0 9
60045: PUSH
60046: FOR_TO
60047: IFFALSE 60164
// for _y = min_y to max_y do
60049: LD_ADDR_VAR 0 12
60053: PUSH
60054: DOUBLE
60055: LD_VAR 0 8
60059: DEC
60060: ST_TO_ADDR
60061: LD_VAR 0 10
60065: PUSH
60066: FOR_TO
60067: IFFALSE 60160
// begin if not ValidHex ( _x , _y ) then
60069: LD_VAR 0 11
60073: PPUSH
60074: LD_VAR 0 12
60078: PPUSH
60079: CALL_OW 488
60083: NOT
60084: IFFALSE 60088
// continue ;
60086: GO 60066
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60088: LD_VAR 0 11
60092: PPUSH
60093: LD_VAR 0 12
60097: PPUSH
60098: CALL_OW 351
60102: PUSH
60103: LD_VAR 0 11
60107: PPUSH
60108: LD_VAR 0 12
60112: PPUSH
60113: CALL_OW 554
60117: AND
60118: IFFALSE 60158
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60120: LD_ADDR_VAR 0 13
60124: PUSH
60125: LD_VAR 0 13
60129: PPUSH
60130: LD_VAR 0 13
60134: PUSH
60135: LD_INT 1
60137: PLUS
60138: PPUSH
60139: LD_VAR 0 11
60143: PUSH
60144: LD_VAR 0 12
60148: PUSH
60149: EMPTY
60150: LIST
60151: LIST
60152: PPUSH
60153: CALL_OW 2
60157: ST_TO_ADDR
// end ;
60158: GO 60066
60160: POP
60161: POP
60162: GO 60046
60164: POP
60165: POP
// if not list then
60166: LD_VAR 0 13
60170: NOT
60171: IFFALSE 60175
// exit ;
60173: GO 60246
// for i in list do
60175: LD_ADDR_VAR 0 6
60179: PUSH
60180: LD_VAR 0 13
60184: PUSH
60185: FOR_IN
60186: IFFALSE 60244
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60188: LD_VAR 0 1
60192: PPUSH
60193: LD_STRING M
60195: PUSH
60196: LD_VAR 0 6
60200: PUSH
60201: LD_INT 1
60203: ARRAY
60204: PUSH
60205: LD_VAR 0 6
60209: PUSH
60210: LD_INT 2
60212: ARRAY
60213: PUSH
60214: LD_INT 0
60216: PUSH
60217: LD_INT 0
60219: PUSH
60220: LD_INT 0
60222: PUSH
60223: LD_INT 0
60225: PUSH
60226: EMPTY
60227: LIST
60228: LIST
60229: LIST
60230: LIST
60231: LIST
60232: LIST
60233: LIST
60234: PUSH
60235: EMPTY
60236: LIST
60237: PPUSH
60238: CALL_OW 447
60242: GO 60185
60244: POP
60245: POP
// end ;
60246: LD_VAR 0 5
60250: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
60251: LD_INT 0
60253: PPUSH
60254: PPUSH
60255: PPUSH
60256: PPUSH
60257: PPUSH
60258: PPUSH
60259: PPUSH
60260: PPUSH
60261: PPUSH
60262: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
60263: LD_VAR 0 1
60267: PPUSH
60268: CALL_OW 302
60272: NOT
60273: PUSH
60274: LD_VAR 0 2
60278: PPUSH
60279: LD_VAR 0 3
60283: PPUSH
60284: CALL_OW 488
60288: NOT
60289: OR
60290: PUSH
60291: LD_VAR 0 4
60295: NOT
60296: OR
60297: IFFALSE 60301
// exit ;
60299: GO 60814
// list := [ ] ;
60301: LD_ADDR_VAR 0 13
60305: PUSH
60306: EMPTY
60307: ST_TO_ADDR
// if x - r < 0 then
60308: LD_VAR 0 2
60312: PUSH
60313: LD_VAR 0 4
60317: MINUS
60318: PUSH
60319: LD_INT 0
60321: LESS
60322: IFFALSE 60334
// min_x := 0 else
60324: LD_ADDR_VAR 0 7
60328: PUSH
60329: LD_INT 0
60331: ST_TO_ADDR
60332: GO 60350
// min_x := x - r ;
60334: LD_ADDR_VAR 0 7
60338: PUSH
60339: LD_VAR 0 2
60343: PUSH
60344: LD_VAR 0 4
60348: MINUS
60349: ST_TO_ADDR
// if y - r < 0 then
60350: LD_VAR 0 3
60354: PUSH
60355: LD_VAR 0 4
60359: MINUS
60360: PUSH
60361: LD_INT 0
60363: LESS
60364: IFFALSE 60376
// min_y := 0 else
60366: LD_ADDR_VAR 0 8
60370: PUSH
60371: LD_INT 0
60373: ST_TO_ADDR
60374: GO 60392
// min_y := y - r ;
60376: LD_ADDR_VAR 0 8
60380: PUSH
60381: LD_VAR 0 3
60385: PUSH
60386: LD_VAR 0 4
60390: MINUS
60391: ST_TO_ADDR
// max_x := x + r ;
60392: LD_ADDR_VAR 0 9
60396: PUSH
60397: LD_VAR 0 2
60401: PUSH
60402: LD_VAR 0 4
60406: PLUS
60407: ST_TO_ADDR
// max_y := y + r ;
60408: LD_ADDR_VAR 0 10
60412: PUSH
60413: LD_VAR 0 3
60417: PUSH
60418: LD_VAR 0 4
60422: PLUS
60423: ST_TO_ADDR
// for _x = min_x to max_x do
60424: LD_ADDR_VAR 0 11
60428: PUSH
60429: DOUBLE
60430: LD_VAR 0 7
60434: DEC
60435: ST_TO_ADDR
60436: LD_VAR 0 9
60440: PUSH
60441: FOR_TO
60442: IFFALSE 60559
// for _y = min_y to max_y do
60444: LD_ADDR_VAR 0 12
60448: PUSH
60449: DOUBLE
60450: LD_VAR 0 8
60454: DEC
60455: ST_TO_ADDR
60456: LD_VAR 0 10
60460: PUSH
60461: FOR_TO
60462: IFFALSE 60555
// begin if not ValidHex ( _x , _y ) then
60464: LD_VAR 0 11
60468: PPUSH
60469: LD_VAR 0 12
60473: PPUSH
60474: CALL_OW 488
60478: NOT
60479: IFFALSE 60483
// continue ;
60481: GO 60461
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60483: LD_VAR 0 11
60487: PPUSH
60488: LD_VAR 0 12
60492: PPUSH
60493: CALL_OW 351
60497: PUSH
60498: LD_VAR 0 11
60502: PPUSH
60503: LD_VAR 0 12
60507: PPUSH
60508: CALL_OW 554
60512: AND
60513: IFFALSE 60553
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60515: LD_ADDR_VAR 0 13
60519: PUSH
60520: LD_VAR 0 13
60524: PPUSH
60525: LD_VAR 0 13
60529: PUSH
60530: LD_INT 1
60532: PLUS
60533: PPUSH
60534: LD_VAR 0 11
60538: PUSH
60539: LD_VAR 0 12
60543: PUSH
60544: EMPTY
60545: LIST
60546: LIST
60547: PPUSH
60548: CALL_OW 2
60552: ST_TO_ADDR
// end ;
60553: GO 60461
60555: POP
60556: POP
60557: GO 60441
60559: POP
60560: POP
// if not list then
60561: LD_VAR 0 13
60565: NOT
60566: IFFALSE 60570
// exit ;
60568: GO 60814
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
60570: LD_ADDR_VAR 0 13
60574: PUSH
60575: LD_VAR 0 1
60579: PPUSH
60580: LD_VAR 0 13
60584: PPUSH
60585: LD_INT 1
60587: PPUSH
60588: LD_INT 1
60590: PPUSH
60591: CALL 69427 0 4
60595: ST_TO_ADDR
// ComStop ( flame ) ;
60596: LD_VAR 0 1
60600: PPUSH
60601: CALL_OW 141
// for i in list do
60605: LD_ADDR_VAR 0 6
60609: PUSH
60610: LD_VAR 0 13
60614: PUSH
60615: FOR_IN
60616: IFFALSE 60647
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
60618: LD_VAR 0 1
60622: PPUSH
60623: LD_VAR 0 6
60627: PUSH
60628: LD_INT 1
60630: ARRAY
60631: PPUSH
60632: LD_VAR 0 6
60636: PUSH
60637: LD_INT 2
60639: ARRAY
60640: PPUSH
60641: CALL_OW 176
60645: GO 60615
60647: POP
60648: POP
// repeat wait ( 0 0$1 ) ;
60649: LD_INT 35
60651: PPUSH
60652: CALL_OW 67
// task := GetTaskList ( flame ) ;
60656: LD_ADDR_VAR 0 14
60660: PUSH
60661: LD_VAR 0 1
60665: PPUSH
60666: CALL_OW 437
60670: ST_TO_ADDR
// if not task then
60671: LD_VAR 0 14
60675: NOT
60676: IFFALSE 60680
// exit ;
60678: GO 60814
// if task [ 1 ] [ 1 ] <> | then
60680: LD_VAR 0 14
60684: PUSH
60685: LD_INT 1
60687: ARRAY
60688: PUSH
60689: LD_INT 1
60691: ARRAY
60692: PUSH
60693: LD_STRING |
60695: NONEQUAL
60696: IFFALSE 60700
// exit ;
60698: GO 60814
// _x := task [ 1 ] [ 2 ] ;
60700: LD_ADDR_VAR 0 11
60704: PUSH
60705: LD_VAR 0 14
60709: PUSH
60710: LD_INT 1
60712: ARRAY
60713: PUSH
60714: LD_INT 2
60716: ARRAY
60717: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
60718: LD_ADDR_VAR 0 12
60722: PUSH
60723: LD_VAR 0 14
60727: PUSH
60728: LD_INT 1
60730: ARRAY
60731: PUSH
60732: LD_INT 3
60734: ARRAY
60735: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
60736: LD_VAR 0 11
60740: PPUSH
60741: LD_VAR 0 12
60745: PPUSH
60746: CALL_OW 351
60750: NOT
60751: PUSH
60752: LD_VAR 0 11
60756: PPUSH
60757: LD_VAR 0 12
60761: PPUSH
60762: CALL_OW 554
60766: NOT
60767: OR
60768: IFFALSE 60802
// begin task := Delete ( task , 1 ) ;
60770: LD_ADDR_VAR 0 14
60774: PUSH
60775: LD_VAR 0 14
60779: PPUSH
60780: LD_INT 1
60782: PPUSH
60783: CALL_OW 3
60787: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
60788: LD_VAR 0 1
60792: PPUSH
60793: LD_VAR 0 14
60797: PPUSH
60798: CALL_OW 446
// end ; until not HasTask ( flame ) ;
60802: LD_VAR 0 1
60806: PPUSH
60807: CALL_OW 314
60811: NOT
60812: IFFALSE 60649
// end ;
60814: LD_VAR 0 5
60818: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60819: LD_EXP 135
60823: NOT
60824: IFFALSE 60874
60826: GO 60828
60828: DISABLE
// begin initHack := true ;
60829: LD_ADDR_EXP 135
60833: PUSH
60834: LD_INT 1
60836: ST_TO_ADDR
// hackTanks := [ ] ;
60837: LD_ADDR_EXP 136
60841: PUSH
60842: EMPTY
60843: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60844: LD_ADDR_EXP 137
60848: PUSH
60849: EMPTY
60850: ST_TO_ADDR
// hackLimit := 3 ;
60851: LD_ADDR_EXP 138
60855: PUSH
60856: LD_INT 3
60858: ST_TO_ADDR
// hackDist := 12 ;
60859: LD_ADDR_EXP 139
60863: PUSH
60864: LD_INT 12
60866: ST_TO_ADDR
// hackCounter := [ ] ;
60867: LD_ADDR_EXP 140
60871: PUSH
60872: EMPTY
60873: ST_TO_ADDR
// end ;
60874: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60875: LD_EXP 135
60879: PUSH
60880: LD_INT 34
60882: PUSH
60883: LD_INT 99
60885: PUSH
60886: EMPTY
60887: LIST
60888: LIST
60889: PPUSH
60890: CALL_OW 69
60894: AND
60895: IFFALSE 61148
60897: GO 60899
60899: DISABLE
60900: LD_INT 0
60902: PPUSH
60903: PPUSH
// begin enable ;
60904: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60905: LD_ADDR_VAR 0 1
60909: PUSH
60910: LD_INT 34
60912: PUSH
60913: LD_INT 99
60915: PUSH
60916: EMPTY
60917: LIST
60918: LIST
60919: PPUSH
60920: CALL_OW 69
60924: PUSH
60925: FOR_IN
60926: IFFALSE 61146
// begin if not i in hackTanks then
60928: LD_VAR 0 1
60932: PUSH
60933: LD_EXP 136
60937: IN
60938: NOT
60939: IFFALSE 61022
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60941: LD_ADDR_EXP 136
60945: PUSH
60946: LD_EXP 136
60950: PPUSH
60951: LD_EXP 136
60955: PUSH
60956: LD_INT 1
60958: PLUS
60959: PPUSH
60960: LD_VAR 0 1
60964: PPUSH
60965: CALL_OW 1
60969: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60970: LD_ADDR_EXP 137
60974: PUSH
60975: LD_EXP 137
60979: PPUSH
60980: LD_EXP 137
60984: PUSH
60985: LD_INT 1
60987: PLUS
60988: PPUSH
60989: EMPTY
60990: PPUSH
60991: CALL_OW 1
60995: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60996: LD_ADDR_EXP 140
61000: PUSH
61001: LD_EXP 140
61005: PPUSH
61006: LD_EXP 140
61010: PUSH
61011: LD_INT 1
61013: PLUS
61014: PPUSH
61015: EMPTY
61016: PPUSH
61017: CALL_OW 1
61021: ST_TO_ADDR
// end ; if not IsOk ( i ) then
61022: LD_VAR 0 1
61026: PPUSH
61027: CALL_OW 302
61031: NOT
61032: IFFALSE 61045
// begin HackUnlinkAll ( i ) ;
61034: LD_VAR 0 1
61038: PPUSH
61039: CALL 61151 0 1
// continue ;
61043: GO 60925
// end ; HackCheckCapturedStatus ( i ) ;
61045: LD_VAR 0 1
61049: PPUSH
61050: CALL 61594 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
61054: LD_ADDR_VAR 0 2
61058: PUSH
61059: LD_INT 81
61061: PUSH
61062: LD_VAR 0 1
61066: PPUSH
61067: CALL_OW 255
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PUSH
61076: LD_INT 33
61078: PUSH
61079: LD_INT 3
61081: PUSH
61082: EMPTY
61083: LIST
61084: LIST
61085: PUSH
61086: LD_INT 91
61088: PUSH
61089: LD_VAR 0 1
61093: PUSH
61094: LD_EXP 139
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: LIST
61103: PUSH
61104: LD_INT 50
61106: PUSH
61107: EMPTY
61108: LIST
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: LIST
61114: LIST
61115: PPUSH
61116: CALL_OW 69
61120: ST_TO_ADDR
// if not tmp then
61121: LD_VAR 0 2
61125: NOT
61126: IFFALSE 61130
// continue ;
61128: GO 60925
// HackLink ( i , tmp ) ;
61130: LD_VAR 0 1
61134: PPUSH
61135: LD_VAR 0 2
61139: PPUSH
61140: CALL 61287 0 2
// end ;
61144: GO 60925
61146: POP
61147: POP
// end ;
61148: PPOPN 2
61150: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
61151: LD_INT 0
61153: PPUSH
61154: PPUSH
61155: PPUSH
// if not hack in hackTanks then
61156: LD_VAR 0 1
61160: PUSH
61161: LD_EXP 136
61165: IN
61166: NOT
61167: IFFALSE 61171
// exit ;
61169: GO 61282
// index := GetElementIndex ( hackTanks , hack ) ;
61171: LD_ADDR_VAR 0 4
61175: PUSH
61176: LD_EXP 136
61180: PPUSH
61181: LD_VAR 0 1
61185: PPUSH
61186: CALL 68724 0 2
61190: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
61191: LD_EXP 137
61195: PUSH
61196: LD_VAR 0 4
61200: ARRAY
61201: IFFALSE 61282
// begin for i in hackTanksCaptured [ index ] do
61203: LD_ADDR_VAR 0 3
61207: PUSH
61208: LD_EXP 137
61212: PUSH
61213: LD_VAR 0 4
61217: ARRAY
61218: PUSH
61219: FOR_IN
61220: IFFALSE 61246
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
61222: LD_VAR 0 3
61226: PUSH
61227: LD_INT 1
61229: ARRAY
61230: PPUSH
61231: LD_VAR 0 3
61235: PUSH
61236: LD_INT 2
61238: ARRAY
61239: PPUSH
61240: CALL_OW 235
61244: GO 61219
61246: POP
61247: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
61248: LD_ADDR_EXP 137
61252: PUSH
61253: LD_EXP 137
61257: PPUSH
61258: LD_VAR 0 4
61262: PPUSH
61263: EMPTY
61264: PPUSH
61265: CALL_OW 1
61269: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
61270: LD_VAR 0 1
61274: PPUSH
61275: LD_INT 0
61277: PPUSH
61278: CALL_OW 505
// end ; end ;
61282: LD_VAR 0 2
61286: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
61287: LD_INT 0
61289: PPUSH
61290: PPUSH
61291: PPUSH
// if not hack in hackTanks or not vehicles then
61292: LD_VAR 0 1
61296: PUSH
61297: LD_EXP 136
61301: IN
61302: NOT
61303: PUSH
61304: LD_VAR 0 2
61308: NOT
61309: OR
61310: IFFALSE 61314
// exit ;
61312: GO 61589
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
61314: LD_ADDR_VAR 0 2
61318: PUSH
61319: LD_VAR 0 1
61323: PPUSH
61324: LD_VAR 0 2
61328: PPUSH
61329: LD_INT 1
61331: PPUSH
61332: LD_INT 1
61334: PPUSH
61335: CALL 69374 0 4
61339: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
61340: LD_ADDR_VAR 0 5
61344: PUSH
61345: LD_EXP 136
61349: PPUSH
61350: LD_VAR 0 1
61354: PPUSH
61355: CALL 68724 0 2
61359: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
61360: LD_EXP 137
61364: PUSH
61365: LD_VAR 0 5
61369: ARRAY
61370: PUSH
61371: LD_EXP 138
61375: LESS
61376: IFFALSE 61565
// begin for i := 1 to vehicles do
61378: LD_ADDR_VAR 0 4
61382: PUSH
61383: DOUBLE
61384: LD_INT 1
61386: DEC
61387: ST_TO_ADDR
61388: LD_VAR 0 2
61392: PUSH
61393: FOR_TO
61394: IFFALSE 61563
// begin if hackTanksCaptured [ index ] = hackLimit then
61396: LD_EXP 137
61400: PUSH
61401: LD_VAR 0 5
61405: ARRAY
61406: PUSH
61407: LD_EXP 138
61411: EQUAL
61412: IFFALSE 61416
// break ;
61414: GO 61563
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
61416: LD_ADDR_EXP 140
61420: PUSH
61421: LD_EXP 140
61425: PPUSH
61426: LD_VAR 0 5
61430: PPUSH
61431: LD_EXP 140
61435: PUSH
61436: LD_VAR 0 5
61440: ARRAY
61441: PUSH
61442: LD_INT 1
61444: PLUS
61445: PPUSH
61446: CALL_OW 1
61450: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
61451: LD_ADDR_EXP 137
61455: PUSH
61456: LD_EXP 137
61460: PPUSH
61461: LD_VAR 0 5
61465: PUSH
61466: LD_EXP 137
61470: PUSH
61471: LD_VAR 0 5
61475: ARRAY
61476: PUSH
61477: LD_INT 1
61479: PLUS
61480: PUSH
61481: EMPTY
61482: LIST
61483: LIST
61484: PPUSH
61485: LD_VAR 0 2
61489: PUSH
61490: LD_VAR 0 4
61494: ARRAY
61495: PUSH
61496: LD_VAR 0 2
61500: PUSH
61501: LD_VAR 0 4
61505: ARRAY
61506: PPUSH
61507: CALL_OW 255
61511: PUSH
61512: EMPTY
61513: LIST
61514: LIST
61515: PPUSH
61516: CALL 68939 0 3
61520: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
61521: LD_VAR 0 2
61525: PUSH
61526: LD_VAR 0 4
61530: ARRAY
61531: PPUSH
61532: LD_VAR 0 1
61536: PPUSH
61537: CALL_OW 255
61541: PPUSH
61542: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
61546: LD_VAR 0 2
61550: PUSH
61551: LD_VAR 0 4
61555: ARRAY
61556: PPUSH
61557: CALL_OW 141
// end ;
61561: GO 61393
61563: POP
61564: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61565: LD_VAR 0 1
61569: PPUSH
61570: LD_EXP 137
61574: PUSH
61575: LD_VAR 0 5
61579: ARRAY
61580: PUSH
61581: LD_INT 0
61583: PLUS
61584: PPUSH
61585: CALL_OW 505
// end ;
61589: LD_VAR 0 3
61593: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
61594: LD_INT 0
61596: PPUSH
61597: PPUSH
61598: PPUSH
61599: PPUSH
// if not hack in hackTanks then
61600: LD_VAR 0 1
61604: PUSH
61605: LD_EXP 136
61609: IN
61610: NOT
61611: IFFALSE 61615
// exit ;
61613: GO 61855
// index := GetElementIndex ( hackTanks , hack ) ;
61615: LD_ADDR_VAR 0 4
61619: PUSH
61620: LD_EXP 136
61624: PPUSH
61625: LD_VAR 0 1
61629: PPUSH
61630: CALL 68724 0 2
61634: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61635: LD_ADDR_VAR 0 3
61639: PUSH
61640: DOUBLE
61641: LD_EXP 137
61645: PUSH
61646: LD_VAR 0 4
61650: ARRAY
61651: INC
61652: ST_TO_ADDR
61653: LD_INT 1
61655: PUSH
61656: FOR_DOWNTO
61657: IFFALSE 61829
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61659: LD_ADDR_VAR 0 5
61663: PUSH
61664: LD_EXP 137
61668: PUSH
61669: LD_VAR 0 4
61673: ARRAY
61674: PUSH
61675: LD_VAR 0 3
61679: ARRAY
61680: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61681: LD_VAR 0 5
61685: PUSH
61686: LD_INT 1
61688: ARRAY
61689: PPUSH
61690: CALL_OW 302
61694: NOT
61695: PUSH
61696: LD_VAR 0 5
61700: PUSH
61701: LD_INT 1
61703: ARRAY
61704: PPUSH
61705: CALL_OW 255
61709: PUSH
61710: LD_VAR 0 1
61714: PPUSH
61715: CALL_OW 255
61719: NONEQUAL
61720: OR
61721: IFFALSE 61827
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61723: LD_VAR 0 5
61727: PUSH
61728: LD_INT 1
61730: ARRAY
61731: PPUSH
61732: CALL_OW 305
61736: PUSH
61737: LD_VAR 0 5
61741: PUSH
61742: LD_INT 1
61744: ARRAY
61745: PPUSH
61746: CALL_OW 255
61750: PUSH
61751: LD_VAR 0 1
61755: PPUSH
61756: CALL_OW 255
61760: EQUAL
61761: AND
61762: IFFALSE 61786
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61764: LD_VAR 0 5
61768: PUSH
61769: LD_INT 1
61771: ARRAY
61772: PPUSH
61773: LD_VAR 0 5
61777: PUSH
61778: LD_INT 2
61780: ARRAY
61781: PPUSH
61782: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61786: LD_ADDR_EXP 137
61790: PUSH
61791: LD_EXP 137
61795: PPUSH
61796: LD_VAR 0 4
61800: PPUSH
61801: LD_EXP 137
61805: PUSH
61806: LD_VAR 0 4
61810: ARRAY
61811: PPUSH
61812: LD_VAR 0 3
61816: PPUSH
61817: CALL_OW 3
61821: PPUSH
61822: CALL_OW 1
61826: ST_TO_ADDR
// end ; end ;
61827: GO 61656
61829: POP
61830: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61831: LD_VAR 0 1
61835: PPUSH
61836: LD_EXP 137
61840: PUSH
61841: LD_VAR 0 4
61845: ARRAY
61846: PUSH
61847: LD_INT 0
61849: PLUS
61850: PPUSH
61851: CALL_OW 505
// end ;
61855: LD_VAR 0 2
61859: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61860: LD_INT 0
61862: PPUSH
61863: PPUSH
61864: PPUSH
61865: PPUSH
// if not hack in hackTanks then
61866: LD_VAR 0 1
61870: PUSH
61871: LD_EXP 136
61875: IN
61876: NOT
61877: IFFALSE 61881
// exit ;
61879: GO 61966
// index := GetElementIndex ( hackTanks , hack ) ;
61881: LD_ADDR_VAR 0 5
61885: PUSH
61886: LD_EXP 136
61890: PPUSH
61891: LD_VAR 0 1
61895: PPUSH
61896: CALL 68724 0 2
61900: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61901: LD_ADDR_VAR 0 4
61905: PUSH
61906: DOUBLE
61907: LD_INT 1
61909: DEC
61910: ST_TO_ADDR
61911: LD_EXP 137
61915: PUSH
61916: LD_VAR 0 5
61920: ARRAY
61921: PUSH
61922: FOR_TO
61923: IFFALSE 61964
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61925: LD_EXP 137
61929: PUSH
61930: LD_VAR 0 5
61934: ARRAY
61935: PUSH
61936: LD_VAR 0 4
61940: ARRAY
61941: PUSH
61942: LD_INT 1
61944: ARRAY
61945: PUSH
61946: LD_VAR 0 2
61950: EQUAL
61951: IFFALSE 61962
// KillUnit ( vehicle ) ;
61953: LD_VAR 0 2
61957: PPUSH
61958: CALL_OW 66
61962: GO 61922
61964: POP
61965: POP
// end ;
61966: LD_VAR 0 3
61970: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61971: LD_EXP 141
61975: NOT
61976: IFFALSE 62011
61978: GO 61980
61980: DISABLE
// begin initMiner := true ;
61981: LD_ADDR_EXP 141
61985: PUSH
61986: LD_INT 1
61988: ST_TO_ADDR
// minersList := [ ] ;
61989: LD_ADDR_EXP 142
61993: PUSH
61994: EMPTY
61995: ST_TO_ADDR
// minerMinesList := [ ] ;
61996: LD_ADDR_EXP 143
62000: PUSH
62001: EMPTY
62002: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
62003: LD_ADDR_EXP 144
62007: PUSH
62008: LD_INT 5
62010: ST_TO_ADDR
// end ;
62011: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
62012: LD_EXP 141
62016: PUSH
62017: LD_INT 34
62019: PUSH
62020: LD_INT 81
62022: PUSH
62023: EMPTY
62024: LIST
62025: LIST
62026: PPUSH
62027: CALL_OW 69
62031: AND
62032: IFFALSE 62493
62034: GO 62036
62036: DISABLE
62037: LD_INT 0
62039: PPUSH
62040: PPUSH
62041: PPUSH
62042: PPUSH
// begin enable ;
62043: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
62044: LD_ADDR_VAR 0 1
62048: PUSH
62049: LD_INT 34
62051: PUSH
62052: LD_INT 81
62054: PUSH
62055: EMPTY
62056: LIST
62057: LIST
62058: PPUSH
62059: CALL_OW 69
62063: PUSH
62064: FOR_IN
62065: IFFALSE 62137
// begin if not i in minersList then
62067: LD_VAR 0 1
62071: PUSH
62072: LD_EXP 142
62076: IN
62077: NOT
62078: IFFALSE 62135
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
62080: LD_ADDR_EXP 142
62084: PUSH
62085: LD_EXP 142
62089: PPUSH
62090: LD_EXP 142
62094: PUSH
62095: LD_INT 1
62097: PLUS
62098: PPUSH
62099: LD_VAR 0 1
62103: PPUSH
62104: CALL_OW 1
62108: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
62109: LD_ADDR_EXP 143
62113: PUSH
62114: LD_EXP 143
62118: PPUSH
62119: LD_EXP 143
62123: PUSH
62124: LD_INT 1
62126: PLUS
62127: PPUSH
62128: EMPTY
62129: PPUSH
62130: CALL_OW 1
62134: ST_TO_ADDR
// end end ;
62135: GO 62064
62137: POP
62138: POP
// for i := minerMinesList downto 1 do
62139: LD_ADDR_VAR 0 1
62143: PUSH
62144: DOUBLE
62145: LD_EXP 143
62149: INC
62150: ST_TO_ADDR
62151: LD_INT 1
62153: PUSH
62154: FOR_DOWNTO
62155: IFFALSE 62491
// begin if IsLive ( minersList [ i ] ) then
62157: LD_EXP 142
62161: PUSH
62162: LD_VAR 0 1
62166: ARRAY
62167: PPUSH
62168: CALL_OW 300
62172: IFFALSE 62200
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
62174: LD_EXP 142
62178: PUSH
62179: LD_VAR 0 1
62183: ARRAY
62184: PPUSH
62185: LD_EXP 143
62189: PUSH
62190: LD_VAR 0 1
62194: ARRAY
62195: PPUSH
62196: CALL_OW 505
// if not minerMinesList [ i ] then
62200: LD_EXP 143
62204: PUSH
62205: LD_VAR 0 1
62209: ARRAY
62210: NOT
62211: IFFALSE 62215
// continue ;
62213: GO 62154
// for j := minerMinesList [ i ] downto 1 do
62215: LD_ADDR_VAR 0 2
62219: PUSH
62220: DOUBLE
62221: LD_EXP 143
62225: PUSH
62226: LD_VAR 0 1
62230: ARRAY
62231: INC
62232: ST_TO_ADDR
62233: LD_INT 1
62235: PUSH
62236: FOR_DOWNTO
62237: IFFALSE 62487
// begin side := GetSide ( minersList [ i ] ) ;
62239: LD_ADDR_VAR 0 3
62243: PUSH
62244: LD_EXP 142
62248: PUSH
62249: LD_VAR 0 1
62253: ARRAY
62254: PPUSH
62255: CALL_OW 255
62259: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
62260: LD_ADDR_VAR 0 4
62264: PUSH
62265: LD_EXP 143
62269: PUSH
62270: LD_VAR 0 1
62274: ARRAY
62275: PUSH
62276: LD_VAR 0 2
62280: ARRAY
62281: PUSH
62282: LD_INT 1
62284: ARRAY
62285: PPUSH
62286: LD_EXP 143
62290: PUSH
62291: LD_VAR 0 1
62295: ARRAY
62296: PUSH
62297: LD_VAR 0 2
62301: ARRAY
62302: PUSH
62303: LD_INT 2
62305: ARRAY
62306: PPUSH
62307: CALL_OW 428
62311: ST_TO_ADDR
// if not tmp then
62312: LD_VAR 0 4
62316: NOT
62317: IFFALSE 62321
// continue ;
62319: GO 62236
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
62321: LD_VAR 0 4
62325: PUSH
62326: LD_INT 81
62328: PUSH
62329: LD_VAR 0 3
62333: PUSH
62334: EMPTY
62335: LIST
62336: LIST
62337: PPUSH
62338: CALL_OW 69
62342: IN
62343: PUSH
62344: LD_EXP 143
62348: PUSH
62349: LD_VAR 0 1
62353: ARRAY
62354: PUSH
62355: LD_VAR 0 2
62359: ARRAY
62360: PUSH
62361: LD_INT 1
62363: ARRAY
62364: PPUSH
62365: LD_EXP 143
62369: PUSH
62370: LD_VAR 0 1
62374: ARRAY
62375: PUSH
62376: LD_VAR 0 2
62380: ARRAY
62381: PUSH
62382: LD_INT 2
62384: ARRAY
62385: PPUSH
62386: CALL_OW 458
62390: AND
62391: IFFALSE 62485
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
62393: LD_EXP 143
62397: PUSH
62398: LD_VAR 0 1
62402: ARRAY
62403: PUSH
62404: LD_VAR 0 2
62408: ARRAY
62409: PUSH
62410: LD_INT 1
62412: ARRAY
62413: PPUSH
62414: LD_EXP 143
62418: PUSH
62419: LD_VAR 0 1
62423: ARRAY
62424: PUSH
62425: LD_VAR 0 2
62429: ARRAY
62430: PUSH
62431: LD_INT 2
62433: ARRAY
62434: PPUSH
62435: LD_VAR 0 3
62439: PPUSH
62440: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
62444: LD_ADDR_EXP 143
62448: PUSH
62449: LD_EXP 143
62453: PPUSH
62454: LD_VAR 0 1
62458: PPUSH
62459: LD_EXP 143
62463: PUSH
62464: LD_VAR 0 1
62468: ARRAY
62469: PPUSH
62470: LD_VAR 0 2
62474: PPUSH
62475: CALL_OW 3
62479: PPUSH
62480: CALL_OW 1
62484: ST_TO_ADDR
// end ; end ;
62485: GO 62236
62487: POP
62488: POP
// end ;
62489: GO 62154
62491: POP
62492: POP
// end ;
62493: PPOPN 4
62495: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
62496: LD_INT 0
62498: PPUSH
62499: PPUSH
// result := false ;
62500: LD_ADDR_VAR 0 4
62504: PUSH
62505: LD_INT 0
62507: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
62508: LD_VAR 0 1
62512: PPUSH
62513: CALL_OW 264
62517: PUSH
62518: LD_INT 81
62520: EQUAL
62521: NOT
62522: IFFALSE 62526
// exit ;
62524: GO 62766
// index := GetElementIndex ( minersList , unit ) ;
62526: LD_ADDR_VAR 0 5
62530: PUSH
62531: LD_EXP 142
62535: PPUSH
62536: LD_VAR 0 1
62540: PPUSH
62541: CALL 68724 0 2
62545: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
62546: LD_EXP 143
62550: PUSH
62551: LD_VAR 0 5
62555: ARRAY
62556: PUSH
62557: LD_EXP 144
62561: GREATEREQUAL
62562: IFFALSE 62566
// exit ;
62564: GO 62766
// ComMoveXY ( unit , x , y ) ;
62566: LD_VAR 0 1
62570: PPUSH
62571: LD_VAR 0 2
62575: PPUSH
62576: LD_VAR 0 3
62580: PPUSH
62581: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62585: LD_INT 35
62587: PPUSH
62588: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
62592: LD_VAR 0 1
62596: PPUSH
62597: LD_VAR 0 2
62601: PPUSH
62602: LD_VAR 0 3
62606: PPUSH
62607: CALL 100465 0 3
62611: NOT
62612: PUSH
62613: LD_VAR 0 1
62617: PPUSH
62618: CALL_OW 314
62622: AND
62623: IFFALSE 62627
// exit ;
62625: GO 62766
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
62627: LD_VAR 0 2
62631: PPUSH
62632: LD_VAR 0 3
62636: PPUSH
62637: CALL_OW 428
62641: PUSH
62642: LD_VAR 0 1
62646: EQUAL
62647: PUSH
62648: LD_VAR 0 1
62652: PPUSH
62653: CALL_OW 314
62657: NOT
62658: AND
62659: IFFALSE 62585
// PlaySoundXY ( x , y , PlantMine ) ;
62661: LD_VAR 0 2
62665: PPUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: LD_STRING PlantMine
62673: PPUSH
62674: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62678: LD_VAR 0 2
62682: PPUSH
62683: LD_VAR 0 3
62687: PPUSH
62688: LD_VAR 0 1
62692: PPUSH
62693: CALL_OW 255
62697: PPUSH
62698: LD_INT 0
62700: PPUSH
62701: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62705: LD_ADDR_EXP 143
62709: PUSH
62710: LD_EXP 143
62714: PPUSH
62715: LD_VAR 0 5
62719: PUSH
62720: LD_EXP 143
62724: PUSH
62725: LD_VAR 0 5
62729: ARRAY
62730: PUSH
62731: LD_INT 1
62733: PLUS
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: PPUSH
62739: LD_VAR 0 2
62743: PUSH
62744: LD_VAR 0 3
62748: PUSH
62749: EMPTY
62750: LIST
62751: LIST
62752: PPUSH
62753: CALL 68939 0 3
62757: ST_TO_ADDR
// result := true ;
62758: LD_ADDR_VAR 0 4
62762: PUSH
62763: LD_INT 1
62765: ST_TO_ADDR
// end ;
62766: LD_VAR 0 4
62770: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62771: LD_INT 0
62773: PPUSH
62774: PPUSH
62775: PPUSH
// if not unit in minersList then
62776: LD_VAR 0 1
62780: PUSH
62781: LD_EXP 142
62785: IN
62786: NOT
62787: IFFALSE 62791
// exit ;
62789: GO 63183
// index := GetElementIndex ( minersList , unit ) ;
62791: LD_ADDR_VAR 0 6
62795: PUSH
62796: LD_EXP 142
62800: PPUSH
62801: LD_VAR 0 1
62805: PPUSH
62806: CALL 68724 0 2
62810: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62811: LD_ADDR_VAR 0 5
62815: PUSH
62816: DOUBLE
62817: LD_EXP 143
62821: PUSH
62822: LD_VAR 0 6
62826: ARRAY
62827: INC
62828: ST_TO_ADDR
62829: LD_INT 1
62831: PUSH
62832: FOR_DOWNTO
62833: IFFALSE 62994
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62835: LD_EXP 143
62839: PUSH
62840: LD_VAR 0 6
62844: ARRAY
62845: PUSH
62846: LD_VAR 0 5
62850: ARRAY
62851: PUSH
62852: LD_INT 1
62854: ARRAY
62855: PUSH
62856: LD_VAR 0 2
62860: EQUAL
62861: PUSH
62862: LD_EXP 143
62866: PUSH
62867: LD_VAR 0 6
62871: ARRAY
62872: PUSH
62873: LD_VAR 0 5
62877: ARRAY
62878: PUSH
62879: LD_INT 2
62881: ARRAY
62882: PUSH
62883: LD_VAR 0 3
62887: EQUAL
62888: AND
62889: IFFALSE 62992
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62891: LD_EXP 143
62895: PUSH
62896: LD_VAR 0 6
62900: ARRAY
62901: PUSH
62902: LD_VAR 0 5
62906: ARRAY
62907: PUSH
62908: LD_INT 1
62910: ARRAY
62911: PPUSH
62912: LD_EXP 143
62916: PUSH
62917: LD_VAR 0 6
62921: ARRAY
62922: PUSH
62923: LD_VAR 0 5
62927: ARRAY
62928: PUSH
62929: LD_INT 2
62931: ARRAY
62932: PPUSH
62933: LD_VAR 0 1
62937: PPUSH
62938: CALL_OW 255
62942: PPUSH
62943: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62947: LD_ADDR_EXP 143
62951: PUSH
62952: LD_EXP 143
62956: PPUSH
62957: LD_VAR 0 6
62961: PPUSH
62962: LD_EXP 143
62966: PUSH
62967: LD_VAR 0 6
62971: ARRAY
62972: PPUSH
62973: LD_VAR 0 5
62977: PPUSH
62978: CALL_OW 3
62982: PPUSH
62983: CALL_OW 1
62987: ST_TO_ADDR
// exit ;
62988: POP
62989: POP
62990: GO 63183
// end ; end ;
62992: GO 62832
62994: POP
62995: POP
// for i := minerMinesList [ index ] downto 1 do
62996: LD_ADDR_VAR 0 5
63000: PUSH
63001: DOUBLE
63002: LD_EXP 143
63006: PUSH
63007: LD_VAR 0 6
63011: ARRAY
63012: INC
63013: ST_TO_ADDR
63014: LD_INT 1
63016: PUSH
63017: FOR_DOWNTO
63018: IFFALSE 63181
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
63020: LD_EXP 143
63024: PUSH
63025: LD_VAR 0 6
63029: ARRAY
63030: PUSH
63031: LD_VAR 0 5
63035: ARRAY
63036: PUSH
63037: LD_INT 1
63039: ARRAY
63040: PPUSH
63041: LD_EXP 143
63045: PUSH
63046: LD_VAR 0 6
63050: ARRAY
63051: PUSH
63052: LD_VAR 0 5
63056: ARRAY
63057: PUSH
63058: LD_INT 2
63060: ARRAY
63061: PPUSH
63062: LD_VAR 0 2
63066: PPUSH
63067: LD_VAR 0 3
63071: PPUSH
63072: CALL_OW 298
63076: PUSH
63077: LD_INT 6
63079: LESS
63080: IFFALSE 63179
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
63082: LD_EXP 143
63086: PUSH
63087: LD_VAR 0 6
63091: ARRAY
63092: PUSH
63093: LD_VAR 0 5
63097: ARRAY
63098: PUSH
63099: LD_INT 1
63101: ARRAY
63102: PPUSH
63103: LD_EXP 143
63107: PUSH
63108: LD_VAR 0 6
63112: ARRAY
63113: PUSH
63114: LD_VAR 0 5
63118: ARRAY
63119: PUSH
63120: LD_INT 2
63122: ARRAY
63123: PPUSH
63124: LD_VAR 0 1
63128: PPUSH
63129: CALL_OW 255
63133: PPUSH
63134: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
63138: LD_ADDR_EXP 143
63142: PUSH
63143: LD_EXP 143
63147: PPUSH
63148: LD_VAR 0 6
63152: PPUSH
63153: LD_EXP 143
63157: PUSH
63158: LD_VAR 0 6
63162: ARRAY
63163: PPUSH
63164: LD_VAR 0 5
63168: PPUSH
63169: CALL_OW 3
63173: PPUSH
63174: CALL_OW 1
63178: ST_TO_ADDR
// end ; end ;
63179: GO 63017
63181: POP
63182: POP
// end ;
63183: LD_VAR 0 4
63187: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
63188: LD_INT 0
63190: PPUSH
63191: PPUSH
63192: PPUSH
63193: PPUSH
63194: PPUSH
63195: PPUSH
63196: PPUSH
63197: PPUSH
63198: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
63199: LD_VAR 0 1
63203: PPUSH
63204: CALL_OW 264
63208: PUSH
63209: LD_INT 81
63211: EQUAL
63212: NOT
63213: PUSH
63214: LD_VAR 0 1
63218: PUSH
63219: LD_EXP 142
63223: IN
63224: NOT
63225: OR
63226: IFFALSE 63230
// exit ;
63228: GO 63552
// index := GetElementIndex ( minersList , unit ) ;
63230: LD_ADDR_VAR 0 6
63234: PUSH
63235: LD_EXP 142
63239: PPUSH
63240: LD_VAR 0 1
63244: PPUSH
63245: CALL 68724 0 2
63249: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
63250: LD_ADDR_VAR 0 8
63254: PUSH
63255: LD_EXP 144
63259: PUSH
63260: LD_EXP 143
63264: PUSH
63265: LD_VAR 0 6
63269: ARRAY
63270: MINUS
63271: ST_TO_ADDR
// if not minesFreeAmount then
63272: LD_VAR 0 8
63276: NOT
63277: IFFALSE 63281
// exit ;
63279: GO 63552
// tmp := [ ] ;
63281: LD_ADDR_VAR 0 7
63285: PUSH
63286: EMPTY
63287: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
63288: LD_ADDR_VAR 0 5
63292: PUSH
63293: DOUBLE
63294: LD_INT 1
63296: DEC
63297: ST_TO_ADDR
63298: LD_VAR 0 8
63302: PUSH
63303: FOR_TO
63304: IFFALSE 63499
// begin _d := rand ( 0 , 5 ) ;
63306: LD_ADDR_VAR 0 11
63310: PUSH
63311: LD_INT 0
63313: PPUSH
63314: LD_INT 5
63316: PPUSH
63317: CALL_OW 12
63321: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
63322: LD_ADDR_VAR 0 12
63326: PUSH
63327: LD_INT 2
63329: PPUSH
63330: LD_INT 6
63332: PPUSH
63333: CALL_OW 12
63337: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
63338: LD_ADDR_VAR 0 9
63342: PUSH
63343: LD_VAR 0 2
63347: PPUSH
63348: LD_VAR 0 11
63352: PPUSH
63353: LD_VAR 0 12
63357: PPUSH
63358: CALL_OW 272
63362: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
63363: LD_ADDR_VAR 0 10
63367: PUSH
63368: LD_VAR 0 3
63372: PPUSH
63373: LD_VAR 0 11
63377: PPUSH
63378: LD_VAR 0 12
63382: PPUSH
63383: CALL_OW 273
63387: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
63388: LD_VAR 0 9
63392: PPUSH
63393: LD_VAR 0 10
63397: PPUSH
63398: CALL_OW 488
63402: PUSH
63403: LD_VAR 0 9
63407: PUSH
63408: LD_VAR 0 10
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_VAR 0 7
63421: IN
63422: NOT
63423: AND
63424: PUSH
63425: LD_VAR 0 9
63429: PPUSH
63430: LD_VAR 0 10
63434: PPUSH
63435: CALL_OW 458
63439: NOT
63440: AND
63441: IFFALSE 63483
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
63443: LD_ADDR_VAR 0 7
63447: PUSH
63448: LD_VAR 0 7
63452: PPUSH
63453: LD_VAR 0 7
63457: PUSH
63458: LD_INT 1
63460: PLUS
63461: PPUSH
63462: LD_VAR 0 9
63466: PUSH
63467: LD_VAR 0 10
63471: PUSH
63472: EMPTY
63473: LIST
63474: LIST
63475: PPUSH
63476: CALL_OW 1
63480: ST_TO_ADDR
63481: GO 63497
// i := i - 1 ;
63483: LD_ADDR_VAR 0 5
63487: PUSH
63488: LD_VAR 0 5
63492: PUSH
63493: LD_INT 1
63495: MINUS
63496: ST_TO_ADDR
// end ;
63497: GO 63303
63499: POP
63500: POP
// for i in tmp do
63501: LD_ADDR_VAR 0 5
63505: PUSH
63506: LD_VAR 0 7
63510: PUSH
63511: FOR_IN
63512: IFFALSE 63550
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
63514: LD_VAR 0 1
63518: PPUSH
63519: LD_VAR 0 5
63523: PUSH
63524: LD_INT 1
63526: ARRAY
63527: PPUSH
63528: LD_VAR 0 5
63532: PUSH
63533: LD_INT 2
63535: ARRAY
63536: PPUSH
63537: CALL 62496 0 3
63541: NOT
63542: IFFALSE 63548
// exit ;
63544: POP
63545: POP
63546: GO 63552
63548: GO 63511
63550: POP
63551: POP
// end ;
63552: LD_VAR 0 4
63556: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
63557: LD_INT 0
63559: PPUSH
63560: PPUSH
63561: PPUSH
63562: PPUSH
63563: PPUSH
63564: PPUSH
63565: PPUSH
// if not GetClass ( unit ) = class_sniper then
63566: LD_VAR 0 1
63570: PPUSH
63571: CALL_OW 257
63575: PUSH
63576: LD_INT 5
63578: EQUAL
63579: NOT
63580: IFFALSE 63584
// exit ;
63582: GO 63972
// dist := 8 ;
63584: LD_ADDR_VAR 0 5
63588: PUSH
63589: LD_INT 8
63591: ST_TO_ADDR
// viewRange := 12 ;
63592: LD_ADDR_VAR 0 7
63596: PUSH
63597: LD_INT 12
63599: ST_TO_ADDR
// side := GetSide ( unit ) ;
63600: LD_ADDR_VAR 0 6
63604: PUSH
63605: LD_VAR 0 1
63609: PPUSH
63610: CALL_OW 255
63614: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
63615: LD_INT 61
63617: PPUSH
63618: LD_VAR 0 6
63622: PPUSH
63623: CALL_OW 321
63627: PUSH
63628: LD_INT 2
63630: EQUAL
63631: IFFALSE 63641
// viewRange := 16 ;
63633: LD_ADDR_VAR 0 7
63637: PUSH
63638: LD_INT 16
63640: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63641: LD_VAR 0 1
63645: PPUSH
63646: LD_VAR 0 2
63650: PPUSH
63651: LD_VAR 0 3
63655: PPUSH
63656: CALL_OW 297
63660: PUSH
63661: LD_VAR 0 5
63665: GREATER
63666: IFFALSE 63745
// begin ComMoveXY ( unit , x , y ) ;
63668: LD_VAR 0 1
63672: PPUSH
63673: LD_VAR 0 2
63677: PPUSH
63678: LD_VAR 0 3
63682: PPUSH
63683: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63687: LD_INT 35
63689: PPUSH
63690: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63694: LD_VAR 0 1
63698: PPUSH
63699: LD_VAR 0 2
63703: PPUSH
63704: LD_VAR 0 3
63708: PPUSH
63709: CALL 100465 0 3
63713: NOT
63714: IFFALSE 63718
// exit ;
63716: GO 63972
// until GetDistUnitXY ( unit , x , y ) < dist ;
63718: LD_VAR 0 1
63722: PPUSH
63723: LD_VAR 0 2
63727: PPUSH
63728: LD_VAR 0 3
63732: PPUSH
63733: CALL_OW 297
63737: PUSH
63738: LD_VAR 0 5
63742: LESS
63743: IFFALSE 63687
// end ; ComTurnXY ( unit , x , y ) ;
63745: LD_VAR 0 1
63749: PPUSH
63750: LD_VAR 0 2
63754: PPUSH
63755: LD_VAR 0 3
63759: PPUSH
63760: CALL_OW 118
// wait ( 5 ) ;
63764: LD_INT 5
63766: PPUSH
63767: CALL_OW 67
// _d := GetDir ( unit ) ;
63771: LD_ADDR_VAR 0 10
63775: PUSH
63776: LD_VAR 0 1
63780: PPUSH
63781: CALL_OW 254
63785: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63786: LD_ADDR_VAR 0 8
63790: PUSH
63791: LD_VAR 0 1
63795: PPUSH
63796: CALL_OW 250
63800: PPUSH
63801: LD_VAR 0 10
63805: PPUSH
63806: LD_VAR 0 5
63810: PPUSH
63811: CALL_OW 272
63815: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63816: LD_ADDR_VAR 0 9
63820: PUSH
63821: LD_VAR 0 1
63825: PPUSH
63826: CALL_OW 251
63830: PPUSH
63831: LD_VAR 0 10
63835: PPUSH
63836: LD_VAR 0 5
63840: PPUSH
63841: CALL_OW 273
63845: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63846: LD_VAR 0 8
63850: PPUSH
63851: LD_VAR 0 9
63855: PPUSH
63856: CALL_OW 488
63860: NOT
63861: IFFALSE 63865
// exit ;
63863: GO 63972
// ComAnimCustom ( unit , 1 ) ;
63865: LD_VAR 0 1
63869: PPUSH
63870: LD_INT 1
63872: PPUSH
63873: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63877: LD_VAR 0 8
63881: PPUSH
63882: LD_VAR 0 9
63886: PPUSH
63887: LD_VAR 0 6
63891: PPUSH
63892: LD_VAR 0 7
63896: PPUSH
63897: CALL_OW 330
// repeat wait ( 1 ) ;
63901: LD_INT 1
63903: PPUSH
63904: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63908: LD_VAR 0 1
63912: PPUSH
63913: CALL_OW 316
63917: PUSH
63918: LD_VAR 0 1
63922: PPUSH
63923: CALL_OW 314
63927: OR
63928: PUSH
63929: LD_VAR 0 1
63933: PPUSH
63934: CALL_OW 302
63938: NOT
63939: OR
63940: PUSH
63941: LD_VAR 0 1
63945: PPUSH
63946: CALL_OW 301
63950: OR
63951: IFFALSE 63901
// RemoveSeeing ( _x , _y , side ) ;
63953: LD_VAR 0 8
63957: PPUSH
63958: LD_VAR 0 9
63962: PPUSH
63963: LD_VAR 0 6
63967: PPUSH
63968: CALL_OW 331
// end ; end_of_file
63972: LD_VAR 0 4
63976: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63977: LD_INT 0
63979: PPUSH
63980: PPUSH
// if exist_mode then
63981: LD_VAR 0 2
63985: IFFALSE 64010
// unit := CreateCharacter ( prefix & ident ) else
63987: LD_ADDR_VAR 0 5
63991: PUSH
63992: LD_VAR 0 3
63996: PUSH
63997: LD_VAR 0 1
64001: STR
64002: PPUSH
64003: CALL_OW 34
64007: ST_TO_ADDR
64008: GO 64025
// unit := NewCharacter ( ident ) ;
64010: LD_ADDR_VAR 0 5
64014: PUSH
64015: LD_VAR 0 1
64019: PPUSH
64020: CALL_OW 25
64024: ST_TO_ADDR
// result := unit ;
64025: LD_ADDR_VAR 0 4
64029: PUSH
64030: LD_VAR 0 5
64034: ST_TO_ADDR
// end ;
64035: LD_VAR 0 4
64039: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64040: LD_INT 0
64042: PPUSH
64043: PPUSH
// if not side or not nation then
64044: LD_VAR 0 1
64048: NOT
64049: PUSH
64050: LD_VAR 0 2
64054: NOT
64055: OR
64056: IFFALSE 64060
// exit ;
64058: GO 64828
// case nation of nation_american :
64060: LD_VAR 0 2
64064: PUSH
64065: LD_INT 1
64067: DOUBLE
64068: EQUAL
64069: IFTRUE 64073
64071: GO 64287
64073: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
64074: LD_ADDR_VAR 0 4
64078: PUSH
64079: LD_INT 35
64081: PUSH
64082: LD_INT 45
64084: PUSH
64085: LD_INT 46
64087: PUSH
64088: LD_INT 47
64090: PUSH
64091: LD_INT 82
64093: PUSH
64094: LD_INT 83
64096: PUSH
64097: LD_INT 84
64099: PUSH
64100: LD_INT 85
64102: PUSH
64103: LD_INT 86
64105: PUSH
64106: LD_INT 1
64108: PUSH
64109: LD_INT 2
64111: PUSH
64112: LD_INT 6
64114: PUSH
64115: LD_INT 15
64117: PUSH
64118: LD_INT 16
64120: PUSH
64121: LD_INT 7
64123: PUSH
64124: LD_INT 12
64126: PUSH
64127: LD_INT 13
64129: PUSH
64130: LD_INT 10
64132: PUSH
64133: LD_INT 14
64135: PUSH
64136: LD_INT 20
64138: PUSH
64139: LD_INT 21
64141: PUSH
64142: LD_INT 22
64144: PUSH
64145: LD_INT 25
64147: PUSH
64148: LD_INT 32
64150: PUSH
64151: LD_INT 27
64153: PUSH
64154: LD_INT 36
64156: PUSH
64157: LD_INT 69
64159: PUSH
64160: LD_INT 39
64162: PUSH
64163: LD_INT 34
64165: PUSH
64166: LD_INT 40
64168: PUSH
64169: LD_INT 48
64171: PUSH
64172: LD_INT 49
64174: PUSH
64175: LD_INT 50
64177: PUSH
64178: LD_INT 51
64180: PUSH
64181: LD_INT 52
64183: PUSH
64184: LD_INT 53
64186: PUSH
64187: LD_INT 54
64189: PUSH
64190: LD_INT 55
64192: PUSH
64193: LD_INT 56
64195: PUSH
64196: LD_INT 57
64198: PUSH
64199: LD_INT 58
64201: PUSH
64202: LD_INT 59
64204: PUSH
64205: LD_INT 60
64207: PUSH
64208: LD_INT 61
64210: PUSH
64211: LD_INT 62
64213: PUSH
64214: LD_INT 80
64216: PUSH
64217: LD_INT 82
64219: PUSH
64220: LD_INT 83
64222: PUSH
64223: LD_INT 84
64225: PUSH
64226: LD_INT 85
64228: PUSH
64229: LD_INT 86
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: LIST
64250: LIST
64251: LIST
64252: LIST
64253: LIST
64254: LIST
64255: LIST
64256: LIST
64257: LIST
64258: LIST
64259: LIST
64260: LIST
64261: LIST
64262: LIST
64263: LIST
64264: LIST
64265: LIST
64266: LIST
64267: LIST
64268: LIST
64269: LIST
64270: LIST
64271: LIST
64272: LIST
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: LIST
64278: LIST
64279: LIST
64280: LIST
64281: LIST
64282: LIST
64283: LIST
64284: ST_TO_ADDR
64285: GO 64752
64287: LD_INT 2
64289: DOUBLE
64290: EQUAL
64291: IFTRUE 64295
64293: GO 64521
64295: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
64296: LD_ADDR_VAR 0 4
64300: PUSH
64301: LD_INT 35
64303: PUSH
64304: LD_INT 45
64306: PUSH
64307: LD_INT 46
64309: PUSH
64310: LD_INT 47
64312: PUSH
64313: LD_INT 82
64315: PUSH
64316: LD_INT 83
64318: PUSH
64319: LD_INT 84
64321: PUSH
64322: LD_INT 85
64324: PUSH
64325: LD_INT 87
64327: PUSH
64328: LD_INT 70
64330: PUSH
64331: LD_INT 1
64333: PUSH
64334: LD_INT 11
64336: PUSH
64337: LD_INT 3
64339: PUSH
64340: LD_INT 4
64342: PUSH
64343: LD_INT 5
64345: PUSH
64346: LD_INT 6
64348: PUSH
64349: LD_INT 15
64351: PUSH
64352: LD_INT 18
64354: PUSH
64355: LD_INT 7
64357: PUSH
64358: LD_INT 17
64360: PUSH
64361: LD_INT 8
64363: PUSH
64364: LD_INT 20
64366: PUSH
64367: LD_INT 21
64369: PUSH
64370: LD_INT 22
64372: PUSH
64373: LD_INT 72
64375: PUSH
64376: LD_INT 26
64378: PUSH
64379: LD_INT 69
64381: PUSH
64382: LD_INT 39
64384: PUSH
64385: LD_INT 40
64387: PUSH
64388: LD_INT 41
64390: PUSH
64391: LD_INT 42
64393: PUSH
64394: LD_INT 43
64396: PUSH
64397: LD_INT 48
64399: PUSH
64400: LD_INT 49
64402: PUSH
64403: LD_INT 50
64405: PUSH
64406: LD_INT 51
64408: PUSH
64409: LD_INT 52
64411: PUSH
64412: LD_INT 53
64414: PUSH
64415: LD_INT 54
64417: PUSH
64418: LD_INT 55
64420: PUSH
64421: LD_INT 56
64423: PUSH
64424: LD_INT 60
64426: PUSH
64427: LD_INT 61
64429: PUSH
64430: LD_INT 62
64432: PUSH
64433: LD_INT 66
64435: PUSH
64436: LD_INT 67
64438: PUSH
64439: LD_INT 68
64441: PUSH
64442: LD_INT 81
64444: PUSH
64445: LD_INT 82
64447: PUSH
64448: LD_INT 83
64450: PUSH
64451: LD_INT 84
64453: PUSH
64454: LD_INT 85
64456: PUSH
64457: LD_INT 87
64459: PUSH
64460: LD_INT 88
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: ST_TO_ADDR
64519: GO 64752
64521: LD_INT 3
64523: DOUBLE
64524: EQUAL
64525: IFTRUE 64529
64527: GO 64751
64529: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
64530: LD_ADDR_VAR 0 4
64534: PUSH
64535: LD_INT 46
64537: PUSH
64538: LD_INT 47
64540: PUSH
64541: LD_INT 1
64543: PUSH
64544: LD_INT 2
64546: PUSH
64547: LD_INT 82
64549: PUSH
64550: LD_INT 83
64552: PUSH
64553: LD_INT 84
64555: PUSH
64556: LD_INT 85
64558: PUSH
64559: LD_INT 86
64561: PUSH
64562: LD_INT 11
64564: PUSH
64565: LD_INT 9
64567: PUSH
64568: LD_INT 20
64570: PUSH
64571: LD_INT 19
64573: PUSH
64574: LD_INT 21
64576: PUSH
64577: LD_INT 24
64579: PUSH
64580: LD_INT 22
64582: PUSH
64583: LD_INT 25
64585: PUSH
64586: LD_INT 28
64588: PUSH
64589: LD_INT 29
64591: PUSH
64592: LD_INT 30
64594: PUSH
64595: LD_INT 31
64597: PUSH
64598: LD_INT 37
64600: PUSH
64601: LD_INT 38
64603: PUSH
64604: LD_INT 32
64606: PUSH
64607: LD_INT 27
64609: PUSH
64610: LD_INT 33
64612: PUSH
64613: LD_INT 69
64615: PUSH
64616: LD_INT 39
64618: PUSH
64619: LD_INT 34
64621: PUSH
64622: LD_INT 40
64624: PUSH
64625: LD_INT 71
64627: PUSH
64628: LD_INT 23
64630: PUSH
64631: LD_INT 44
64633: PUSH
64634: LD_INT 48
64636: PUSH
64637: LD_INT 49
64639: PUSH
64640: LD_INT 50
64642: PUSH
64643: LD_INT 51
64645: PUSH
64646: LD_INT 52
64648: PUSH
64649: LD_INT 53
64651: PUSH
64652: LD_INT 54
64654: PUSH
64655: LD_INT 55
64657: PUSH
64658: LD_INT 56
64660: PUSH
64661: LD_INT 57
64663: PUSH
64664: LD_INT 58
64666: PUSH
64667: LD_INT 59
64669: PUSH
64670: LD_INT 63
64672: PUSH
64673: LD_INT 64
64675: PUSH
64676: LD_INT 65
64678: PUSH
64679: LD_INT 82
64681: PUSH
64682: LD_INT 83
64684: PUSH
64685: LD_INT 84
64687: PUSH
64688: LD_INT 85
64690: PUSH
64691: LD_INT 86
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: LIST
64715: LIST
64716: LIST
64717: LIST
64718: LIST
64719: LIST
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: LIST
64725: LIST
64726: LIST
64727: LIST
64728: LIST
64729: LIST
64730: LIST
64731: LIST
64732: LIST
64733: LIST
64734: LIST
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: LIST
64740: LIST
64741: LIST
64742: LIST
64743: LIST
64744: LIST
64745: LIST
64746: LIST
64747: LIST
64748: ST_TO_ADDR
64749: GO 64752
64751: POP
// if state > - 1 and state < 3 then
64752: LD_VAR 0 3
64756: PUSH
64757: LD_INT 1
64759: NEG
64760: GREATER
64761: PUSH
64762: LD_VAR 0 3
64766: PUSH
64767: LD_INT 3
64769: LESS
64770: AND
64771: IFFALSE 64828
// for i in result do
64773: LD_ADDR_VAR 0 5
64777: PUSH
64778: LD_VAR 0 4
64782: PUSH
64783: FOR_IN
64784: IFFALSE 64826
// if GetTech ( i , side ) <> state then
64786: LD_VAR 0 5
64790: PPUSH
64791: LD_VAR 0 1
64795: PPUSH
64796: CALL_OW 321
64800: PUSH
64801: LD_VAR 0 3
64805: NONEQUAL
64806: IFFALSE 64824
// result := result diff i ;
64808: LD_ADDR_VAR 0 4
64812: PUSH
64813: LD_VAR 0 4
64817: PUSH
64818: LD_VAR 0 5
64822: DIFF
64823: ST_TO_ADDR
64824: GO 64783
64826: POP
64827: POP
// end ;
64828: LD_VAR 0 4
64832: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64833: LD_INT 0
64835: PPUSH
64836: PPUSH
64837: PPUSH
// result := true ;
64838: LD_ADDR_VAR 0 3
64842: PUSH
64843: LD_INT 1
64845: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64846: LD_ADDR_VAR 0 5
64850: PUSH
64851: LD_VAR 0 2
64855: PPUSH
64856: CALL_OW 480
64860: ST_TO_ADDR
// if not tmp then
64861: LD_VAR 0 5
64865: NOT
64866: IFFALSE 64870
// exit ;
64868: GO 64919
// for i in tmp do
64870: LD_ADDR_VAR 0 4
64874: PUSH
64875: LD_VAR 0 5
64879: PUSH
64880: FOR_IN
64881: IFFALSE 64917
// if GetTech ( i , side ) <> state_researched then
64883: LD_VAR 0 4
64887: PPUSH
64888: LD_VAR 0 1
64892: PPUSH
64893: CALL_OW 321
64897: PUSH
64898: LD_INT 2
64900: NONEQUAL
64901: IFFALSE 64915
// begin result := false ;
64903: LD_ADDR_VAR 0 3
64907: PUSH
64908: LD_INT 0
64910: ST_TO_ADDR
// exit ;
64911: POP
64912: POP
64913: GO 64919
// end ;
64915: GO 64880
64917: POP
64918: POP
// end ;
64919: LD_VAR 0 3
64923: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64924: LD_INT 0
64926: PPUSH
64927: PPUSH
64928: PPUSH
64929: PPUSH
64930: PPUSH
64931: PPUSH
64932: PPUSH
64933: PPUSH
64934: PPUSH
64935: PPUSH
64936: PPUSH
64937: PPUSH
64938: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64939: LD_VAR 0 1
64943: NOT
64944: PUSH
64945: LD_VAR 0 1
64949: PPUSH
64950: CALL_OW 257
64954: PUSH
64955: LD_INT 9
64957: NONEQUAL
64958: OR
64959: IFFALSE 64963
// exit ;
64961: GO 65536
// side := GetSide ( unit ) ;
64963: LD_ADDR_VAR 0 9
64967: PUSH
64968: LD_VAR 0 1
64972: PPUSH
64973: CALL_OW 255
64977: ST_TO_ADDR
// tech_space := tech_spacanom ;
64978: LD_ADDR_VAR 0 12
64982: PUSH
64983: LD_INT 29
64985: ST_TO_ADDR
// tech_time := tech_taurad ;
64986: LD_ADDR_VAR 0 13
64990: PUSH
64991: LD_INT 28
64993: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64994: LD_ADDR_VAR 0 11
64998: PUSH
64999: LD_VAR 0 1
65003: PPUSH
65004: CALL_OW 310
65008: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65009: LD_VAR 0 11
65013: PPUSH
65014: CALL_OW 247
65018: PUSH
65019: LD_INT 2
65021: EQUAL
65022: IFFALSE 65026
// exit ;
65024: GO 65536
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65026: LD_ADDR_VAR 0 8
65030: PUSH
65031: LD_INT 81
65033: PUSH
65034: LD_VAR 0 9
65038: PUSH
65039: EMPTY
65040: LIST
65041: LIST
65042: PUSH
65043: LD_INT 3
65045: PUSH
65046: LD_INT 21
65048: PUSH
65049: LD_INT 3
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PPUSH
65064: CALL_OW 69
65068: ST_TO_ADDR
// if not tmp then
65069: LD_VAR 0 8
65073: NOT
65074: IFFALSE 65078
// exit ;
65076: GO 65536
// if in_unit then
65078: LD_VAR 0 11
65082: IFFALSE 65106
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65084: LD_ADDR_VAR 0 10
65088: PUSH
65089: LD_VAR 0 8
65093: PPUSH
65094: LD_VAR 0 11
65098: PPUSH
65099: CALL_OW 74
65103: ST_TO_ADDR
65104: GO 65126
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65106: LD_ADDR_VAR 0 10
65110: PUSH
65111: LD_VAR 0 8
65115: PPUSH
65116: LD_VAR 0 1
65120: PPUSH
65121: CALL_OW 74
65125: ST_TO_ADDR
// if not enemy then
65126: LD_VAR 0 10
65130: NOT
65131: IFFALSE 65135
// exit ;
65133: GO 65536
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65135: LD_VAR 0 11
65139: PUSH
65140: LD_VAR 0 11
65144: PPUSH
65145: LD_VAR 0 10
65149: PPUSH
65150: CALL_OW 296
65154: PUSH
65155: LD_INT 13
65157: GREATER
65158: AND
65159: PUSH
65160: LD_VAR 0 1
65164: PPUSH
65165: LD_VAR 0 10
65169: PPUSH
65170: CALL_OW 296
65174: PUSH
65175: LD_INT 12
65177: GREATER
65178: OR
65179: IFFALSE 65183
// exit ;
65181: GO 65536
// missile := [ 1 ] ;
65183: LD_ADDR_VAR 0 14
65187: PUSH
65188: LD_INT 1
65190: PUSH
65191: EMPTY
65192: LIST
65193: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65194: LD_VAR 0 9
65198: PPUSH
65199: LD_VAR 0 12
65203: PPUSH
65204: CALL_OW 325
65208: IFFALSE 65237
// missile := Replace ( missile , missile + 1 , 2 ) ;
65210: LD_ADDR_VAR 0 14
65214: PUSH
65215: LD_VAR 0 14
65219: PPUSH
65220: LD_VAR 0 14
65224: PUSH
65225: LD_INT 1
65227: PLUS
65228: PPUSH
65229: LD_INT 2
65231: PPUSH
65232: CALL_OW 1
65236: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65237: LD_VAR 0 9
65241: PPUSH
65242: LD_VAR 0 13
65246: PPUSH
65247: CALL_OW 325
65251: PUSH
65252: LD_VAR 0 10
65256: PPUSH
65257: CALL_OW 255
65261: PPUSH
65262: LD_VAR 0 13
65266: PPUSH
65267: CALL_OW 325
65271: NOT
65272: AND
65273: IFFALSE 65302
// missile := Replace ( missile , missile + 1 , 3 ) ;
65275: LD_ADDR_VAR 0 14
65279: PUSH
65280: LD_VAR 0 14
65284: PPUSH
65285: LD_VAR 0 14
65289: PUSH
65290: LD_INT 1
65292: PLUS
65293: PPUSH
65294: LD_INT 3
65296: PPUSH
65297: CALL_OW 1
65301: ST_TO_ADDR
// if missile < 2 then
65302: LD_VAR 0 14
65306: PUSH
65307: LD_INT 2
65309: LESS
65310: IFFALSE 65314
// exit ;
65312: GO 65536
// x := GetX ( enemy ) ;
65314: LD_ADDR_VAR 0 4
65318: PUSH
65319: LD_VAR 0 10
65323: PPUSH
65324: CALL_OW 250
65328: ST_TO_ADDR
// y := GetY ( enemy ) ;
65329: LD_ADDR_VAR 0 5
65333: PUSH
65334: LD_VAR 0 10
65338: PPUSH
65339: CALL_OW 251
65343: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65344: LD_ADDR_VAR 0 6
65348: PUSH
65349: LD_VAR 0 4
65353: PUSH
65354: LD_INT 1
65356: NEG
65357: PPUSH
65358: LD_INT 1
65360: PPUSH
65361: CALL_OW 12
65365: PLUS
65366: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65367: LD_ADDR_VAR 0 7
65371: PUSH
65372: LD_VAR 0 5
65376: PUSH
65377: LD_INT 1
65379: NEG
65380: PPUSH
65381: LD_INT 1
65383: PPUSH
65384: CALL_OW 12
65388: PLUS
65389: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65390: LD_VAR 0 6
65394: PPUSH
65395: LD_VAR 0 7
65399: PPUSH
65400: CALL_OW 488
65404: NOT
65405: IFFALSE 65427
// begin _x := x ;
65407: LD_ADDR_VAR 0 6
65411: PUSH
65412: LD_VAR 0 4
65416: ST_TO_ADDR
// _y := y ;
65417: LD_ADDR_VAR 0 7
65421: PUSH
65422: LD_VAR 0 5
65426: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65427: LD_ADDR_VAR 0 3
65431: PUSH
65432: LD_INT 1
65434: PPUSH
65435: LD_VAR 0 14
65439: PPUSH
65440: CALL_OW 12
65444: ST_TO_ADDR
// case i of 1 :
65445: LD_VAR 0 3
65449: PUSH
65450: LD_INT 1
65452: DOUBLE
65453: EQUAL
65454: IFTRUE 65458
65456: GO 65475
65458: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65459: LD_VAR 0 1
65463: PPUSH
65464: LD_VAR 0 10
65468: PPUSH
65469: CALL_OW 115
65473: GO 65536
65475: LD_INT 2
65477: DOUBLE
65478: EQUAL
65479: IFTRUE 65483
65481: GO 65505
65483: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65484: LD_VAR 0 1
65488: PPUSH
65489: LD_VAR 0 6
65493: PPUSH
65494: LD_VAR 0 7
65498: PPUSH
65499: CALL_OW 153
65503: GO 65536
65505: LD_INT 3
65507: DOUBLE
65508: EQUAL
65509: IFTRUE 65513
65511: GO 65535
65513: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65514: LD_VAR 0 1
65518: PPUSH
65519: LD_VAR 0 6
65523: PPUSH
65524: LD_VAR 0 7
65528: PPUSH
65529: CALL_OW 154
65533: GO 65536
65535: POP
// end ;
65536: LD_VAR 0 2
65540: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65541: LD_INT 0
65543: PPUSH
65544: PPUSH
65545: PPUSH
65546: PPUSH
65547: PPUSH
65548: PPUSH
// if not unit or not building then
65549: LD_VAR 0 1
65553: NOT
65554: PUSH
65555: LD_VAR 0 2
65559: NOT
65560: OR
65561: IFFALSE 65565
// exit ;
65563: GO 65723
// x := GetX ( building ) ;
65565: LD_ADDR_VAR 0 5
65569: PUSH
65570: LD_VAR 0 2
65574: PPUSH
65575: CALL_OW 250
65579: ST_TO_ADDR
// y := GetY ( building ) ;
65580: LD_ADDR_VAR 0 6
65584: PUSH
65585: LD_VAR 0 2
65589: PPUSH
65590: CALL_OW 251
65594: ST_TO_ADDR
// for i = 0 to 5 do
65595: LD_ADDR_VAR 0 4
65599: PUSH
65600: DOUBLE
65601: LD_INT 0
65603: DEC
65604: ST_TO_ADDR
65605: LD_INT 5
65607: PUSH
65608: FOR_TO
65609: IFFALSE 65721
// begin _x := ShiftX ( x , i , 3 ) ;
65611: LD_ADDR_VAR 0 7
65615: PUSH
65616: LD_VAR 0 5
65620: PPUSH
65621: LD_VAR 0 4
65625: PPUSH
65626: LD_INT 3
65628: PPUSH
65629: CALL_OW 272
65633: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65634: LD_ADDR_VAR 0 8
65638: PUSH
65639: LD_VAR 0 6
65643: PPUSH
65644: LD_VAR 0 4
65648: PPUSH
65649: LD_INT 3
65651: PPUSH
65652: CALL_OW 273
65656: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65657: LD_VAR 0 7
65661: PPUSH
65662: LD_VAR 0 8
65666: PPUSH
65667: CALL_OW 488
65671: NOT
65672: IFFALSE 65676
// continue ;
65674: GO 65608
// if HexInfo ( _x , _y ) = 0 then
65676: LD_VAR 0 7
65680: PPUSH
65681: LD_VAR 0 8
65685: PPUSH
65686: CALL_OW 428
65690: PUSH
65691: LD_INT 0
65693: EQUAL
65694: IFFALSE 65719
// begin ComMoveXY ( unit , _x , _y ) ;
65696: LD_VAR 0 1
65700: PPUSH
65701: LD_VAR 0 7
65705: PPUSH
65706: LD_VAR 0 8
65710: PPUSH
65711: CALL_OW 111
// exit ;
65715: POP
65716: POP
65717: GO 65723
// end ; end ;
65719: GO 65608
65721: POP
65722: POP
// end ;
65723: LD_VAR 0 3
65727: RET
// export function ScanBase ( side , base_area ) ; begin
65728: LD_INT 0
65730: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65731: LD_ADDR_VAR 0 3
65735: PUSH
65736: LD_VAR 0 2
65740: PPUSH
65741: LD_INT 81
65743: PUSH
65744: LD_VAR 0 1
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PPUSH
65753: CALL_OW 70
65757: ST_TO_ADDR
// end ;
65758: LD_VAR 0 3
65762: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65763: LD_INT 0
65765: PPUSH
65766: PPUSH
65767: PPUSH
65768: PPUSH
// result := false ;
65769: LD_ADDR_VAR 0 2
65773: PUSH
65774: LD_INT 0
65776: ST_TO_ADDR
// side := GetSide ( unit ) ;
65777: LD_ADDR_VAR 0 3
65781: PUSH
65782: LD_VAR 0 1
65786: PPUSH
65787: CALL_OW 255
65791: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65792: LD_ADDR_VAR 0 4
65796: PUSH
65797: LD_VAR 0 1
65801: PPUSH
65802: CALL_OW 248
65806: ST_TO_ADDR
// case nat of 1 :
65807: LD_VAR 0 4
65811: PUSH
65812: LD_INT 1
65814: DOUBLE
65815: EQUAL
65816: IFTRUE 65820
65818: GO 65831
65820: POP
// tech := tech_lassight ; 2 :
65821: LD_ADDR_VAR 0 5
65825: PUSH
65826: LD_INT 12
65828: ST_TO_ADDR
65829: GO 65870
65831: LD_INT 2
65833: DOUBLE
65834: EQUAL
65835: IFTRUE 65839
65837: GO 65850
65839: POP
// tech := tech_mortar ; 3 :
65840: LD_ADDR_VAR 0 5
65844: PUSH
65845: LD_INT 41
65847: ST_TO_ADDR
65848: GO 65870
65850: LD_INT 3
65852: DOUBLE
65853: EQUAL
65854: IFTRUE 65858
65856: GO 65869
65858: POP
// tech := tech_bazooka ; end ;
65859: LD_ADDR_VAR 0 5
65863: PUSH
65864: LD_INT 44
65866: ST_TO_ADDR
65867: GO 65870
65869: POP
// if Researched ( side , tech ) then
65870: LD_VAR 0 3
65874: PPUSH
65875: LD_VAR 0 5
65879: PPUSH
65880: CALL_OW 325
65884: IFFALSE 65911
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65886: LD_ADDR_VAR 0 2
65890: PUSH
65891: LD_INT 5
65893: PUSH
65894: LD_INT 8
65896: PUSH
65897: LD_INT 9
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: LIST
65904: PUSH
65905: LD_VAR 0 4
65909: ARRAY
65910: ST_TO_ADDR
// end ;
65911: LD_VAR 0 2
65915: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65916: LD_INT 0
65918: PPUSH
65919: PPUSH
65920: PPUSH
// if not mines then
65921: LD_VAR 0 2
65925: NOT
65926: IFFALSE 65930
// exit ;
65928: GO 66074
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65930: LD_ADDR_VAR 0 5
65934: PUSH
65935: LD_INT 81
65937: PUSH
65938: LD_VAR 0 1
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PUSH
65947: LD_INT 3
65949: PUSH
65950: LD_INT 21
65952: PUSH
65953: LD_INT 3
65955: PUSH
65956: EMPTY
65957: LIST
65958: LIST
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PPUSH
65968: CALL_OW 69
65972: ST_TO_ADDR
// for i in mines do
65973: LD_ADDR_VAR 0 4
65977: PUSH
65978: LD_VAR 0 2
65982: PUSH
65983: FOR_IN
65984: IFFALSE 66072
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65986: LD_VAR 0 4
65990: PUSH
65991: LD_INT 1
65993: ARRAY
65994: PPUSH
65995: LD_VAR 0 4
65999: PUSH
66000: LD_INT 2
66002: ARRAY
66003: PPUSH
66004: CALL_OW 458
66008: NOT
66009: IFFALSE 66013
// continue ;
66011: GO 65983
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
66013: LD_VAR 0 4
66017: PUSH
66018: LD_INT 1
66020: ARRAY
66021: PPUSH
66022: LD_VAR 0 4
66026: PUSH
66027: LD_INT 2
66029: ARRAY
66030: PPUSH
66031: CALL_OW 428
66035: PUSH
66036: LD_VAR 0 5
66040: IN
66041: IFFALSE 66070
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
66043: LD_VAR 0 4
66047: PUSH
66048: LD_INT 1
66050: ARRAY
66051: PPUSH
66052: LD_VAR 0 4
66056: PUSH
66057: LD_INT 2
66059: ARRAY
66060: PPUSH
66061: LD_VAR 0 1
66065: PPUSH
66066: CALL_OW 456
// end ;
66070: GO 65983
66072: POP
66073: POP
// end ;
66074: LD_VAR 0 3
66078: RET
// export function Count ( array ) ; begin
66079: LD_INT 0
66081: PPUSH
// result := array + 0 ;
66082: LD_ADDR_VAR 0 2
66086: PUSH
66087: LD_VAR 0 1
66091: PUSH
66092: LD_INT 0
66094: PLUS
66095: ST_TO_ADDR
// end ;
66096: LD_VAR 0 2
66100: RET
// export function IsEmpty ( building ) ; begin
66101: LD_INT 0
66103: PPUSH
// if not building then
66104: LD_VAR 0 1
66108: NOT
66109: IFFALSE 66113
// exit ;
66111: GO 66156
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
66113: LD_ADDR_VAR 0 2
66117: PUSH
66118: LD_VAR 0 1
66122: PUSH
66123: LD_INT 22
66125: PUSH
66126: LD_VAR 0 1
66130: PPUSH
66131: CALL_OW 255
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: LD_INT 58
66142: PUSH
66143: EMPTY
66144: LIST
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PPUSH
66150: CALL_OW 69
66154: IN
66155: ST_TO_ADDR
// end ;
66156: LD_VAR 0 2
66160: RET
// export function IsNotFull ( building ) ; var places ; begin
66161: LD_INT 0
66163: PPUSH
66164: PPUSH
// if not building then
66165: LD_VAR 0 1
66169: NOT
66170: IFFALSE 66174
// exit ;
66172: GO 66202
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
66174: LD_ADDR_VAR 0 2
66178: PUSH
66179: LD_VAR 0 1
66183: PPUSH
66184: LD_INT 3
66186: PUSH
66187: LD_INT 62
66189: PUSH
66190: EMPTY
66191: LIST
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PPUSH
66197: CALL_OW 72
66201: ST_TO_ADDR
// end ;
66202: LD_VAR 0 2
66206: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
66207: LD_INT 0
66209: PPUSH
66210: PPUSH
66211: PPUSH
66212: PPUSH
// tmp := [ ] ;
66213: LD_ADDR_VAR 0 3
66217: PUSH
66218: EMPTY
66219: ST_TO_ADDR
// list := [ ] ;
66220: LD_ADDR_VAR 0 5
66224: PUSH
66225: EMPTY
66226: ST_TO_ADDR
// for i = 16 to 25 do
66227: LD_ADDR_VAR 0 4
66231: PUSH
66232: DOUBLE
66233: LD_INT 16
66235: DEC
66236: ST_TO_ADDR
66237: LD_INT 25
66239: PUSH
66240: FOR_TO
66241: IFFALSE 66314
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
66243: LD_ADDR_VAR 0 3
66247: PUSH
66248: LD_VAR 0 3
66252: PUSH
66253: LD_INT 22
66255: PUSH
66256: LD_VAR 0 1
66260: PPUSH
66261: CALL_OW 255
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 91
66272: PUSH
66273: LD_VAR 0 1
66277: PUSH
66278: LD_INT 6
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 30
66288: PUSH
66289: LD_VAR 0 4
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: LIST
66302: PUSH
66303: EMPTY
66304: LIST
66305: PPUSH
66306: CALL_OW 69
66310: ADD
66311: ST_TO_ADDR
66312: GO 66240
66314: POP
66315: POP
// for i = 1 to tmp do
66316: LD_ADDR_VAR 0 4
66320: PUSH
66321: DOUBLE
66322: LD_INT 1
66324: DEC
66325: ST_TO_ADDR
66326: LD_VAR 0 3
66330: PUSH
66331: FOR_TO
66332: IFFALSE 66420
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
66334: LD_ADDR_VAR 0 5
66338: PUSH
66339: LD_VAR 0 5
66343: PUSH
66344: LD_VAR 0 3
66348: PUSH
66349: LD_VAR 0 4
66353: ARRAY
66354: PPUSH
66355: CALL_OW 266
66359: PUSH
66360: LD_VAR 0 3
66364: PUSH
66365: LD_VAR 0 4
66369: ARRAY
66370: PPUSH
66371: CALL_OW 250
66375: PUSH
66376: LD_VAR 0 3
66380: PUSH
66381: LD_VAR 0 4
66385: ARRAY
66386: PPUSH
66387: CALL_OW 251
66391: PUSH
66392: LD_VAR 0 3
66396: PUSH
66397: LD_VAR 0 4
66401: ARRAY
66402: PPUSH
66403: CALL_OW 254
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: PUSH
66414: EMPTY
66415: LIST
66416: ADD
66417: ST_TO_ADDR
66418: GO 66331
66420: POP
66421: POP
// result := list ;
66422: LD_ADDR_VAR 0 2
66426: PUSH
66427: LD_VAR 0 5
66431: ST_TO_ADDR
// end ;
66432: LD_VAR 0 2
66436: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
66437: LD_INT 0
66439: PPUSH
66440: PPUSH
66441: PPUSH
66442: PPUSH
66443: PPUSH
66444: PPUSH
66445: PPUSH
// if not factory then
66446: LD_VAR 0 1
66450: NOT
66451: IFFALSE 66455
// exit ;
66453: GO 67048
// if control = control_apeman then
66455: LD_VAR 0 4
66459: PUSH
66460: LD_INT 5
66462: EQUAL
66463: IFFALSE 66572
// begin tmp := UnitsInside ( factory ) ;
66465: LD_ADDR_VAR 0 8
66469: PUSH
66470: LD_VAR 0 1
66474: PPUSH
66475: CALL_OW 313
66479: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66480: LD_VAR 0 8
66484: PPUSH
66485: LD_INT 25
66487: PUSH
66488: LD_INT 12
66490: PUSH
66491: EMPTY
66492: LIST
66493: LIST
66494: PPUSH
66495: CALL_OW 72
66499: NOT
66500: IFFALSE 66510
// control := control_manual ;
66502: LD_ADDR_VAR 0 4
66506: PUSH
66507: LD_INT 1
66509: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66510: LD_ADDR_VAR 0 8
66514: PUSH
66515: LD_VAR 0 1
66519: PPUSH
66520: CALL 66207 0 1
66524: ST_TO_ADDR
// if tmp then
66525: LD_VAR 0 8
66529: IFFALSE 66572
// begin for i in tmp do
66531: LD_ADDR_VAR 0 7
66535: PUSH
66536: LD_VAR 0 8
66540: PUSH
66541: FOR_IN
66542: IFFALSE 66570
// if i [ 1 ] = b_ext_radio then
66544: LD_VAR 0 7
66548: PUSH
66549: LD_INT 1
66551: ARRAY
66552: PUSH
66553: LD_INT 22
66555: EQUAL
66556: IFFALSE 66568
// begin control := control_remote ;
66558: LD_ADDR_VAR 0 4
66562: PUSH
66563: LD_INT 2
66565: ST_TO_ADDR
// break ;
66566: GO 66570
// end ;
66568: GO 66541
66570: POP
66571: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66572: LD_VAR 0 1
66576: PPUSH
66577: LD_VAR 0 2
66581: PPUSH
66582: LD_VAR 0 3
66586: PPUSH
66587: LD_VAR 0 4
66591: PPUSH
66592: LD_VAR 0 5
66596: PPUSH
66597: CALL_OW 448
66601: IFFALSE 66636
// begin result := [ chassis , engine , control , weapon ] ;
66603: LD_ADDR_VAR 0 6
66607: PUSH
66608: LD_VAR 0 2
66612: PUSH
66613: LD_VAR 0 3
66617: PUSH
66618: LD_VAR 0 4
66622: PUSH
66623: LD_VAR 0 5
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: LIST
66632: LIST
66633: ST_TO_ADDR
// exit ;
66634: GO 67048
// end ; _chassis := AvailableChassisList ( factory ) ;
66636: LD_ADDR_VAR 0 9
66640: PUSH
66641: LD_VAR 0 1
66645: PPUSH
66646: CALL_OW 475
66650: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66651: LD_ADDR_VAR 0 11
66655: PUSH
66656: LD_VAR 0 1
66660: PPUSH
66661: CALL_OW 476
66665: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66666: LD_ADDR_VAR 0 12
66670: PUSH
66671: LD_VAR 0 1
66675: PPUSH
66676: CALL_OW 477
66680: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66681: LD_ADDR_VAR 0 10
66685: PUSH
66686: LD_VAR 0 1
66690: PPUSH
66691: CALL_OW 478
66695: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66696: LD_VAR 0 9
66700: NOT
66701: PUSH
66702: LD_VAR 0 11
66706: NOT
66707: OR
66708: PUSH
66709: LD_VAR 0 12
66713: NOT
66714: OR
66715: PUSH
66716: LD_VAR 0 10
66720: NOT
66721: OR
66722: IFFALSE 66757
// begin result := [ chassis , engine , control , weapon ] ;
66724: LD_ADDR_VAR 0 6
66728: PUSH
66729: LD_VAR 0 2
66733: PUSH
66734: LD_VAR 0 3
66738: PUSH
66739: LD_VAR 0 4
66743: PUSH
66744: LD_VAR 0 5
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: ST_TO_ADDR
// exit ;
66755: GO 67048
// end ; if not chassis in _chassis then
66757: LD_VAR 0 2
66761: PUSH
66762: LD_VAR 0 9
66766: IN
66767: NOT
66768: IFFALSE 66794
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66770: LD_ADDR_VAR 0 2
66774: PUSH
66775: LD_VAR 0 9
66779: PUSH
66780: LD_INT 1
66782: PPUSH
66783: LD_VAR 0 9
66787: PPUSH
66788: CALL_OW 12
66792: ARRAY
66793: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66794: LD_VAR 0 2
66798: PPUSH
66799: LD_VAR 0 3
66803: PPUSH
66804: CALL 67053 0 2
66808: NOT
66809: IFFALSE 66868
// repeat engine := _engine [ 1 ] ;
66811: LD_ADDR_VAR 0 3
66815: PUSH
66816: LD_VAR 0 11
66820: PUSH
66821: LD_INT 1
66823: ARRAY
66824: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66825: LD_ADDR_VAR 0 11
66829: PUSH
66830: LD_VAR 0 11
66834: PPUSH
66835: LD_INT 1
66837: PPUSH
66838: CALL_OW 3
66842: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66843: LD_VAR 0 2
66847: PPUSH
66848: LD_VAR 0 3
66852: PPUSH
66853: CALL 67053 0 2
66857: PUSH
66858: LD_VAR 0 11
66862: PUSH
66863: EMPTY
66864: EQUAL
66865: OR
66866: IFFALSE 66811
// if not control in _control then
66868: LD_VAR 0 4
66872: PUSH
66873: LD_VAR 0 12
66877: IN
66878: NOT
66879: IFFALSE 66905
// control := _control [ rand ( 1 , _control ) ] ;
66881: LD_ADDR_VAR 0 4
66885: PUSH
66886: LD_VAR 0 12
66890: PUSH
66891: LD_INT 1
66893: PPUSH
66894: LD_VAR 0 12
66898: PPUSH
66899: CALL_OW 12
66903: ARRAY
66904: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66905: LD_VAR 0 2
66909: PPUSH
66910: LD_VAR 0 5
66914: PPUSH
66915: CALL 67273 0 2
66919: NOT
66920: IFFALSE 66979
// repeat weapon := _weapon [ 1 ] ;
66922: LD_ADDR_VAR 0 5
66926: PUSH
66927: LD_VAR 0 10
66931: PUSH
66932: LD_INT 1
66934: ARRAY
66935: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66936: LD_ADDR_VAR 0 10
66940: PUSH
66941: LD_VAR 0 10
66945: PPUSH
66946: LD_INT 1
66948: PPUSH
66949: CALL_OW 3
66953: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66954: LD_VAR 0 2
66958: PPUSH
66959: LD_VAR 0 5
66963: PPUSH
66964: CALL 67273 0 2
66968: PUSH
66969: LD_VAR 0 10
66973: PUSH
66974: EMPTY
66975: EQUAL
66976: OR
66977: IFFALSE 66922
// result := [ ] ;
66979: LD_ADDR_VAR 0 6
66983: PUSH
66984: EMPTY
66985: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66986: LD_VAR 0 1
66990: PPUSH
66991: LD_VAR 0 2
66995: PPUSH
66996: LD_VAR 0 3
67000: PPUSH
67001: LD_VAR 0 4
67005: PPUSH
67006: LD_VAR 0 5
67010: PPUSH
67011: CALL_OW 448
67015: IFFALSE 67048
// result := [ chassis , engine , control , weapon ] ;
67017: LD_ADDR_VAR 0 6
67021: PUSH
67022: LD_VAR 0 2
67026: PUSH
67027: LD_VAR 0 3
67031: PUSH
67032: LD_VAR 0 4
67036: PUSH
67037: LD_VAR 0 5
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: ST_TO_ADDR
// end ;
67048: LD_VAR 0 6
67052: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
67053: LD_INT 0
67055: PPUSH
// if not chassis or not engine then
67056: LD_VAR 0 1
67060: NOT
67061: PUSH
67062: LD_VAR 0 2
67066: NOT
67067: OR
67068: IFFALSE 67072
// exit ;
67070: GO 67268
// case engine of engine_solar :
67072: LD_VAR 0 2
67076: PUSH
67077: LD_INT 2
67079: DOUBLE
67080: EQUAL
67081: IFTRUE 67085
67083: GO 67123
67085: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
67086: LD_ADDR_VAR 0 3
67090: PUSH
67091: LD_INT 11
67093: PUSH
67094: LD_INT 12
67096: PUSH
67097: LD_INT 13
67099: PUSH
67100: LD_INT 14
67102: PUSH
67103: LD_INT 1
67105: PUSH
67106: LD_INT 2
67108: PUSH
67109: LD_INT 3
67111: PUSH
67112: EMPTY
67113: LIST
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: LIST
67119: LIST
67120: ST_TO_ADDR
67121: GO 67252
67123: LD_INT 1
67125: DOUBLE
67126: EQUAL
67127: IFTRUE 67131
67129: GO 67193
67131: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
67132: LD_ADDR_VAR 0 3
67136: PUSH
67137: LD_INT 11
67139: PUSH
67140: LD_INT 12
67142: PUSH
67143: LD_INT 13
67145: PUSH
67146: LD_INT 14
67148: PUSH
67149: LD_INT 1
67151: PUSH
67152: LD_INT 2
67154: PUSH
67155: LD_INT 3
67157: PUSH
67158: LD_INT 4
67160: PUSH
67161: LD_INT 5
67163: PUSH
67164: LD_INT 21
67166: PUSH
67167: LD_INT 23
67169: PUSH
67170: LD_INT 22
67172: PUSH
67173: LD_INT 24
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: LIST
67180: LIST
67181: LIST
67182: LIST
67183: LIST
67184: LIST
67185: LIST
67186: LIST
67187: LIST
67188: LIST
67189: LIST
67190: ST_TO_ADDR
67191: GO 67252
67193: LD_INT 3
67195: DOUBLE
67196: EQUAL
67197: IFTRUE 67201
67199: GO 67251
67201: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67202: LD_ADDR_VAR 0 3
67206: PUSH
67207: LD_INT 13
67209: PUSH
67210: LD_INT 14
67212: PUSH
67213: LD_INT 2
67215: PUSH
67216: LD_INT 3
67218: PUSH
67219: LD_INT 4
67221: PUSH
67222: LD_INT 5
67224: PUSH
67225: LD_INT 21
67227: PUSH
67228: LD_INT 22
67230: PUSH
67231: LD_INT 23
67233: PUSH
67234: LD_INT 24
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: LIST
67243: LIST
67244: LIST
67245: LIST
67246: LIST
67247: LIST
67248: ST_TO_ADDR
67249: GO 67252
67251: POP
// result := ( chassis in result ) ;
67252: LD_ADDR_VAR 0 3
67256: PUSH
67257: LD_VAR 0 1
67261: PUSH
67262: LD_VAR 0 3
67266: IN
67267: ST_TO_ADDR
// end ;
67268: LD_VAR 0 3
67272: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
67273: LD_INT 0
67275: PPUSH
// if not chassis or not weapon then
67276: LD_VAR 0 1
67280: NOT
67281: PUSH
67282: LD_VAR 0 2
67286: NOT
67287: OR
67288: IFFALSE 67292
// exit ;
67290: GO 68352
// case weapon of us_machine_gun :
67292: LD_VAR 0 2
67296: PUSH
67297: LD_INT 2
67299: DOUBLE
67300: EQUAL
67301: IFTRUE 67305
67303: GO 67335
67305: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
67306: LD_ADDR_VAR 0 3
67310: PUSH
67311: LD_INT 1
67313: PUSH
67314: LD_INT 2
67316: PUSH
67317: LD_INT 3
67319: PUSH
67320: LD_INT 4
67322: PUSH
67323: LD_INT 5
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: ST_TO_ADDR
67333: GO 68336
67335: LD_INT 3
67337: DOUBLE
67338: EQUAL
67339: IFTRUE 67343
67341: GO 67373
67343: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
67344: LD_ADDR_VAR 0 3
67348: PUSH
67349: LD_INT 1
67351: PUSH
67352: LD_INT 2
67354: PUSH
67355: LD_INT 3
67357: PUSH
67358: LD_INT 4
67360: PUSH
67361: LD_INT 5
67363: PUSH
67364: EMPTY
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: ST_TO_ADDR
67371: GO 68336
67373: LD_INT 11
67375: DOUBLE
67376: EQUAL
67377: IFTRUE 67381
67379: GO 67411
67381: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
67382: LD_ADDR_VAR 0 3
67386: PUSH
67387: LD_INT 1
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: LD_INT 3
67395: PUSH
67396: LD_INT 4
67398: PUSH
67399: LD_INT 5
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: LIST
67406: LIST
67407: LIST
67408: ST_TO_ADDR
67409: GO 68336
67411: LD_INT 4
67413: DOUBLE
67414: EQUAL
67415: IFTRUE 67419
67417: GO 67445
67419: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
67420: LD_ADDR_VAR 0 3
67424: PUSH
67425: LD_INT 2
67427: PUSH
67428: LD_INT 3
67430: PUSH
67431: LD_INT 4
67433: PUSH
67434: LD_INT 5
67436: PUSH
67437: EMPTY
67438: LIST
67439: LIST
67440: LIST
67441: LIST
67442: ST_TO_ADDR
67443: GO 68336
67445: LD_INT 5
67447: DOUBLE
67448: EQUAL
67449: IFTRUE 67453
67451: GO 67479
67453: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
67454: LD_ADDR_VAR 0 3
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: LD_INT 3
67464: PUSH
67465: LD_INT 4
67467: PUSH
67468: LD_INT 5
67470: PUSH
67471: EMPTY
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: ST_TO_ADDR
67477: GO 68336
67479: LD_INT 9
67481: DOUBLE
67482: EQUAL
67483: IFTRUE 67487
67485: GO 67513
67487: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67488: LD_ADDR_VAR 0 3
67492: PUSH
67493: LD_INT 2
67495: PUSH
67496: LD_INT 3
67498: PUSH
67499: LD_INT 4
67501: PUSH
67502: LD_INT 5
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: LIST
67509: LIST
67510: ST_TO_ADDR
67511: GO 68336
67513: LD_INT 7
67515: DOUBLE
67516: EQUAL
67517: IFTRUE 67521
67519: GO 67547
67521: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67522: LD_ADDR_VAR 0 3
67526: PUSH
67527: LD_INT 2
67529: PUSH
67530: LD_INT 3
67532: PUSH
67533: LD_INT 4
67535: PUSH
67536: LD_INT 5
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: LIST
67543: LIST
67544: ST_TO_ADDR
67545: GO 68336
67547: LD_INT 12
67549: DOUBLE
67550: EQUAL
67551: IFTRUE 67555
67553: GO 67581
67555: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67556: LD_ADDR_VAR 0 3
67560: PUSH
67561: LD_INT 2
67563: PUSH
67564: LD_INT 3
67566: PUSH
67567: LD_INT 4
67569: PUSH
67570: LD_INT 5
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: LIST
67577: LIST
67578: ST_TO_ADDR
67579: GO 68336
67581: LD_INT 13
67583: DOUBLE
67584: EQUAL
67585: IFTRUE 67589
67587: GO 67615
67589: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67590: LD_ADDR_VAR 0 3
67594: PUSH
67595: LD_INT 2
67597: PUSH
67598: LD_INT 3
67600: PUSH
67601: LD_INT 4
67603: PUSH
67604: LD_INT 5
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: ST_TO_ADDR
67613: GO 68336
67615: LD_INT 14
67617: DOUBLE
67618: EQUAL
67619: IFTRUE 67623
67621: GO 67641
67623: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67624: LD_ADDR_VAR 0 3
67628: PUSH
67629: LD_INT 4
67631: PUSH
67632: LD_INT 5
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: ST_TO_ADDR
67639: GO 68336
67641: LD_INT 6
67643: DOUBLE
67644: EQUAL
67645: IFTRUE 67649
67647: GO 67667
67649: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67650: LD_ADDR_VAR 0 3
67654: PUSH
67655: LD_INT 4
67657: PUSH
67658: LD_INT 5
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: ST_TO_ADDR
67665: GO 68336
67667: LD_INT 10
67669: DOUBLE
67670: EQUAL
67671: IFTRUE 67675
67673: GO 67693
67675: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67676: LD_ADDR_VAR 0 3
67680: PUSH
67681: LD_INT 4
67683: PUSH
67684: LD_INT 5
67686: PUSH
67687: EMPTY
67688: LIST
67689: LIST
67690: ST_TO_ADDR
67691: GO 68336
67693: LD_INT 22
67695: DOUBLE
67696: EQUAL
67697: IFTRUE 67701
67699: GO 67727
67701: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67702: LD_ADDR_VAR 0 3
67706: PUSH
67707: LD_INT 11
67709: PUSH
67710: LD_INT 12
67712: PUSH
67713: LD_INT 13
67715: PUSH
67716: LD_INT 14
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: ST_TO_ADDR
67725: GO 68336
67727: LD_INT 23
67729: DOUBLE
67730: EQUAL
67731: IFTRUE 67735
67733: GO 67761
67735: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67736: LD_ADDR_VAR 0 3
67740: PUSH
67741: LD_INT 11
67743: PUSH
67744: LD_INT 12
67746: PUSH
67747: LD_INT 13
67749: PUSH
67750: LD_INT 14
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: ST_TO_ADDR
67759: GO 68336
67761: LD_INT 24
67763: DOUBLE
67764: EQUAL
67765: IFTRUE 67769
67767: GO 67795
67769: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67770: LD_ADDR_VAR 0 3
67774: PUSH
67775: LD_INT 11
67777: PUSH
67778: LD_INT 12
67780: PUSH
67781: LD_INT 13
67783: PUSH
67784: LD_INT 14
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: LIST
67791: LIST
67792: ST_TO_ADDR
67793: GO 68336
67795: LD_INT 30
67797: DOUBLE
67798: EQUAL
67799: IFTRUE 67803
67801: GO 67829
67803: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67804: LD_ADDR_VAR 0 3
67808: PUSH
67809: LD_INT 11
67811: PUSH
67812: LD_INT 12
67814: PUSH
67815: LD_INT 13
67817: PUSH
67818: LD_INT 14
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: LIST
67825: LIST
67826: ST_TO_ADDR
67827: GO 68336
67829: LD_INT 25
67831: DOUBLE
67832: EQUAL
67833: IFTRUE 67837
67835: GO 67855
67837: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67838: LD_ADDR_VAR 0 3
67842: PUSH
67843: LD_INT 13
67845: PUSH
67846: LD_INT 14
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: ST_TO_ADDR
67853: GO 68336
67855: LD_INT 27
67857: DOUBLE
67858: EQUAL
67859: IFTRUE 67863
67861: GO 67881
67863: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67864: LD_ADDR_VAR 0 3
67868: PUSH
67869: LD_INT 13
67871: PUSH
67872: LD_INT 14
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: ST_TO_ADDR
67879: GO 68336
67881: LD_INT 92
67883: DOUBLE
67884: EQUAL
67885: IFTRUE 67889
67887: GO 67915
67889: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67890: LD_ADDR_VAR 0 3
67894: PUSH
67895: LD_INT 11
67897: PUSH
67898: LD_INT 12
67900: PUSH
67901: LD_INT 13
67903: PUSH
67904: LD_INT 14
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: LIST
67911: LIST
67912: ST_TO_ADDR
67913: GO 68336
67915: LD_INT 28
67917: DOUBLE
67918: EQUAL
67919: IFTRUE 67923
67921: GO 67941
67923: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67924: LD_ADDR_VAR 0 3
67928: PUSH
67929: LD_INT 13
67931: PUSH
67932: LD_INT 14
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: ST_TO_ADDR
67939: GO 68336
67941: LD_INT 29
67943: DOUBLE
67944: EQUAL
67945: IFTRUE 67949
67947: GO 67967
67949: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67950: LD_ADDR_VAR 0 3
67954: PUSH
67955: LD_INT 13
67957: PUSH
67958: LD_INT 14
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: ST_TO_ADDR
67965: GO 68336
67967: LD_INT 31
67969: DOUBLE
67970: EQUAL
67971: IFTRUE 67975
67973: GO 67993
67975: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67976: LD_ADDR_VAR 0 3
67980: PUSH
67981: LD_INT 13
67983: PUSH
67984: LD_INT 14
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: ST_TO_ADDR
67991: GO 68336
67993: LD_INT 26
67995: DOUBLE
67996: EQUAL
67997: IFTRUE 68001
67999: GO 68019
68001: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68002: LD_ADDR_VAR 0 3
68006: PUSH
68007: LD_INT 13
68009: PUSH
68010: LD_INT 14
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: ST_TO_ADDR
68017: GO 68336
68019: LD_INT 42
68021: DOUBLE
68022: EQUAL
68023: IFTRUE 68027
68025: GO 68053
68027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
68028: LD_ADDR_VAR 0 3
68032: PUSH
68033: LD_INT 21
68035: PUSH
68036: LD_INT 22
68038: PUSH
68039: LD_INT 23
68041: PUSH
68042: LD_INT 24
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: ST_TO_ADDR
68051: GO 68336
68053: LD_INT 43
68055: DOUBLE
68056: EQUAL
68057: IFTRUE 68061
68059: GO 68087
68061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
68062: LD_ADDR_VAR 0 3
68066: PUSH
68067: LD_INT 21
68069: PUSH
68070: LD_INT 22
68072: PUSH
68073: LD_INT 23
68075: PUSH
68076: LD_INT 24
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: ST_TO_ADDR
68085: GO 68336
68087: LD_INT 44
68089: DOUBLE
68090: EQUAL
68091: IFTRUE 68095
68093: GO 68121
68095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
68096: LD_ADDR_VAR 0 3
68100: PUSH
68101: LD_INT 21
68103: PUSH
68104: LD_INT 22
68106: PUSH
68107: LD_INT 23
68109: PUSH
68110: LD_INT 24
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: ST_TO_ADDR
68119: GO 68336
68121: LD_INT 45
68123: DOUBLE
68124: EQUAL
68125: IFTRUE 68129
68127: GO 68155
68129: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
68130: LD_ADDR_VAR 0 3
68134: PUSH
68135: LD_INT 21
68137: PUSH
68138: LD_INT 22
68140: PUSH
68141: LD_INT 23
68143: PUSH
68144: LD_INT 24
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: ST_TO_ADDR
68153: GO 68336
68155: LD_INT 49
68157: DOUBLE
68158: EQUAL
68159: IFTRUE 68163
68161: GO 68189
68163: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
68164: LD_ADDR_VAR 0 3
68168: PUSH
68169: LD_INT 21
68171: PUSH
68172: LD_INT 22
68174: PUSH
68175: LD_INT 23
68177: PUSH
68178: LD_INT 24
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: ST_TO_ADDR
68187: GO 68336
68189: LD_INT 51
68191: DOUBLE
68192: EQUAL
68193: IFTRUE 68197
68195: GO 68223
68197: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68198: LD_ADDR_VAR 0 3
68202: PUSH
68203: LD_INT 21
68205: PUSH
68206: LD_INT 22
68208: PUSH
68209: LD_INT 23
68211: PUSH
68212: LD_INT 24
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: ST_TO_ADDR
68221: GO 68336
68223: LD_INT 52
68225: DOUBLE
68226: EQUAL
68227: IFTRUE 68231
68229: GO 68257
68231: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
68232: LD_ADDR_VAR 0 3
68236: PUSH
68237: LD_INT 21
68239: PUSH
68240: LD_INT 22
68242: PUSH
68243: LD_INT 23
68245: PUSH
68246: LD_INT 24
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: LIST
68253: LIST
68254: ST_TO_ADDR
68255: GO 68336
68257: LD_INT 53
68259: DOUBLE
68260: EQUAL
68261: IFTRUE 68265
68263: GO 68283
68265: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
68266: LD_ADDR_VAR 0 3
68270: PUSH
68271: LD_INT 23
68273: PUSH
68274: LD_INT 24
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: ST_TO_ADDR
68281: GO 68336
68283: LD_INT 46
68285: DOUBLE
68286: EQUAL
68287: IFTRUE 68291
68289: GO 68309
68291: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
68292: LD_ADDR_VAR 0 3
68296: PUSH
68297: LD_INT 23
68299: PUSH
68300: LD_INT 24
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: ST_TO_ADDR
68307: GO 68336
68309: LD_INT 47
68311: DOUBLE
68312: EQUAL
68313: IFTRUE 68317
68315: GO 68335
68317: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68318: LD_ADDR_VAR 0 3
68322: PUSH
68323: LD_INT 23
68325: PUSH
68326: LD_INT 24
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: ST_TO_ADDR
68333: GO 68336
68335: POP
// result := ( chassis in result ) ;
68336: LD_ADDR_VAR 0 3
68340: PUSH
68341: LD_VAR 0 1
68345: PUSH
68346: LD_VAR 0 3
68350: IN
68351: ST_TO_ADDR
// end ;
68352: LD_VAR 0 3
68356: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
68357: LD_INT 0
68359: PPUSH
68360: PPUSH
68361: PPUSH
68362: PPUSH
68363: PPUSH
68364: PPUSH
68365: PPUSH
// result := array ;
68366: LD_ADDR_VAR 0 5
68370: PUSH
68371: LD_VAR 0 1
68375: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
68376: LD_VAR 0 1
68380: NOT
68381: PUSH
68382: LD_VAR 0 2
68386: NOT
68387: OR
68388: PUSH
68389: LD_VAR 0 3
68393: NOT
68394: OR
68395: PUSH
68396: LD_VAR 0 2
68400: PUSH
68401: LD_VAR 0 1
68405: GREATER
68406: OR
68407: PUSH
68408: LD_VAR 0 3
68412: PUSH
68413: LD_VAR 0 1
68417: GREATER
68418: OR
68419: IFFALSE 68423
// exit ;
68421: GO 68719
// if direction then
68423: LD_VAR 0 4
68427: IFFALSE 68491
// begin d := 1 ;
68429: LD_ADDR_VAR 0 9
68433: PUSH
68434: LD_INT 1
68436: ST_TO_ADDR
// if i_from > i_to then
68437: LD_VAR 0 2
68441: PUSH
68442: LD_VAR 0 3
68446: GREATER
68447: IFFALSE 68473
// length := ( array - i_from ) + i_to else
68449: LD_ADDR_VAR 0 11
68453: PUSH
68454: LD_VAR 0 1
68458: PUSH
68459: LD_VAR 0 2
68463: MINUS
68464: PUSH
68465: LD_VAR 0 3
68469: PLUS
68470: ST_TO_ADDR
68471: GO 68489
// length := i_to - i_from ;
68473: LD_ADDR_VAR 0 11
68477: PUSH
68478: LD_VAR 0 3
68482: PUSH
68483: LD_VAR 0 2
68487: MINUS
68488: ST_TO_ADDR
// end else
68489: GO 68552
// begin d := - 1 ;
68491: LD_ADDR_VAR 0 9
68495: PUSH
68496: LD_INT 1
68498: NEG
68499: ST_TO_ADDR
// if i_from > i_to then
68500: LD_VAR 0 2
68504: PUSH
68505: LD_VAR 0 3
68509: GREATER
68510: IFFALSE 68530
// length := i_from - i_to else
68512: LD_ADDR_VAR 0 11
68516: PUSH
68517: LD_VAR 0 2
68521: PUSH
68522: LD_VAR 0 3
68526: MINUS
68527: ST_TO_ADDR
68528: GO 68552
// length := ( array - i_to ) + i_from ;
68530: LD_ADDR_VAR 0 11
68534: PUSH
68535: LD_VAR 0 1
68539: PUSH
68540: LD_VAR 0 3
68544: MINUS
68545: PUSH
68546: LD_VAR 0 2
68550: PLUS
68551: ST_TO_ADDR
// end ; if not length then
68552: LD_VAR 0 11
68556: NOT
68557: IFFALSE 68561
// exit ;
68559: GO 68719
// tmp := array ;
68561: LD_ADDR_VAR 0 10
68565: PUSH
68566: LD_VAR 0 1
68570: ST_TO_ADDR
// for i = 1 to length do
68571: LD_ADDR_VAR 0 6
68575: PUSH
68576: DOUBLE
68577: LD_INT 1
68579: DEC
68580: ST_TO_ADDR
68581: LD_VAR 0 11
68585: PUSH
68586: FOR_TO
68587: IFFALSE 68707
// begin for j = 1 to array do
68589: LD_ADDR_VAR 0 7
68593: PUSH
68594: DOUBLE
68595: LD_INT 1
68597: DEC
68598: ST_TO_ADDR
68599: LD_VAR 0 1
68603: PUSH
68604: FOR_TO
68605: IFFALSE 68693
// begin k := j + d ;
68607: LD_ADDR_VAR 0 8
68611: PUSH
68612: LD_VAR 0 7
68616: PUSH
68617: LD_VAR 0 9
68621: PLUS
68622: ST_TO_ADDR
// if k > array then
68623: LD_VAR 0 8
68627: PUSH
68628: LD_VAR 0 1
68632: GREATER
68633: IFFALSE 68643
// k := 1 ;
68635: LD_ADDR_VAR 0 8
68639: PUSH
68640: LD_INT 1
68642: ST_TO_ADDR
// if not k then
68643: LD_VAR 0 8
68647: NOT
68648: IFFALSE 68660
// k := array ;
68650: LD_ADDR_VAR 0 8
68654: PUSH
68655: LD_VAR 0 1
68659: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68660: LD_ADDR_VAR 0 10
68664: PUSH
68665: LD_VAR 0 10
68669: PPUSH
68670: LD_VAR 0 8
68674: PPUSH
68675: LD_VAR 0 1
68679: PUSH
68680: LD_VAR 0 7
68684: ARRAY
68685: PPUSH
68686: CALL_OW 1
68690: ST_TO_ADDR
// end ;
68691: GO 68604
68693: POP
68694: POP
// array := tmp ;
68695: LD_ADDR_VAR 0 1
68699: PUSH
68700: LD_VAR 0 10
68704: ST_TO_ADDR
// end ;
68705: GO 68586
68707: POP
68708: POP
// result := array ;
68709: LD_ADDR_VAR 0 5
68713: PUSH
68714: LD_VAR 0 1
68718: ST_TO_ADDR
// end ;
68719: LD_VAR 0 5
68723: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68724: LD_INT 0
68726: PPUSH
68727: PPUSH
// result := 0 ;
68728: LD_ADDR_VAR 0 3
68732: PUSH
68733: LD_INT 0
68735: ST_TO_ADDR
// if not array or not value in array then
68736: LD_VAR 0 1
68740: NOT
68741: PUSH
68742: LD_VAR 0 2
68746: PUSH
68747: LD_VAR 0 1
68751: IN
68752: NOT
68753: OR
68754: IFFALSE 68758
// exit ;
68756: GO 68812
// for i = 1 to array do
68758: LD_ADDR_VAR 0 4
68762: PUSH
68763: DOUBLE
68764: LD_INT 1
68766: DEC
68767: ST_TO_ADDR
68768: LD_VAR 0 1
68772: PUSH
68773: FOR_TO
68774: IFFALSE 68810
// if value = array [ i ] then
68776: LD_VAR 0 2
68780: PUSH
68781: LD_VAR 0 1
68785: PUSH
68786: LD_VAR 0 4
68790: ARRAY
68791: EQUAL
68792: IFFALSE 68808
// begin result := i ;
68794: LD_ADDR_VAR 0 3
68798: PUSH
68799: LD_VAR 0 4
68803: ST_TO_ADDR
// exit ;
68804: POP
68805: POP
68806: GO 68812
// end ;
68808: GO 68773
68810: POP
68811: POP
// end ;
68812: LD_VAR 0 3
68816: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68817: LD_INT 0
68819: PPUSH
// vc_chassis := chassis ;
68820: LD_ADDR_OWVAR 37
68824: PUSH
68825: LD_VAR 0 1
68829: ST_TO_ADDR
// vc_engine := engine ;
68830: LD_ADDR_OWVAR 39
68834: PUSH
68835: LD_VAR 0 2
68839: ST_TO_ADDR
// vc_control := control ;
68840: LD_ADDR_OWVAR 38
68844: PUSH
68845: LD_VAR 0 3
68849: ST_TO_ADDR
// vc_weapon := weapon ;
68850: LD_ADDR_OWVAR 40
68854: PUSH
68855: LD_VAR 0 4
68859: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68860: LD_ADDR_OWVAR 41
68864: PUSH
68865: LD_VAR 0 5
68869: ST_TO_ADDR
// end ;
68870: LD_VAR 0 6
68874: RET
// export function WantPlant ( unit ) ; var task ; begin
68875: LD_INT 0
68877: PPUSH
68878: PPUSH
// result := false ;
68879: LD_ADDR_VAR 0 2
68883: PUSH
68884: LD_INT 0
68886: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68887: LD_ADDR_VAR 0 3
68891: PUSH
68892: LD_VAR 0 1
68896: PPUSH
68897: CALL_OW 437
68901: ST_TO_ADDR
// if task then
68902: LD_VAR 0 3
68906: IFFALSE 68934
// if task [ 1 ] [ 1 ] = p then
68908: LD_VAR 0 3
68912: PUSH
68913: LD_INT 1
68915: ARRAY
68916: PUSH
68917: LD_INT 1
68919: ARRAY
68920: PUSH
68921: LD_STRING p
68923: EQUAL
68924: IFFALSE 68934
// result := true ;
68926: LD_ADDR_VAR 0 2
68930: PUSH
68931: LD_INT 1
68933: ST_TO_ADDR
// end ;
68934: LD_VAR 0 2
68938: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68939: LD_INT 0
68941: PPUSH
68942: PPUSH
68943: PPUSH
68944: PPUSH
// if pos < 1 then
68945: LD_VAR 0 2
68949: PUSH
68950: LD_INT 1
68952: LESS
68953: IFFALSE 68957
// exit ;
68955: GO 69260
// if pos = 1 then
68957: LD_VAR 0 2
68961: PUSH
68962: LD_INT 1
68964: EQUAL
68965: IFFALSE 68998
// result := Replace ( arr , pos [ 1 ] , value ) else
68967: LD_ADDR_VAR 0 4
68971: PUSH
68972: LD_VAR 0 1
68976: PPUSH
68977: LD_VAR 0 2
68981: PUSH
68982: LD_INT 1
68984: ARRAY
68985: PPUSH
68986: LD_VAR 0 3
68990: PPUSH
68991: CALL_OW 1
68995: ST_TO_ADDR
68996: GO 69260
// begin tmp := arr ;
68998: LD_ADDR_VAR 0 6
69002: PUSH
69003: LD_VAR 0 1
69007: ST_TO_ADDR
// s_arr := [ tmp ] ;
69008: LD_ADDR_VAR 0 7
69012: PUSH
69013: LD_VAR 0 6
69017: PUSH
69018: EMPTY
69019: LIST
69020: ST_TO_ADDR
// for i = 1 to pos - 1 do
69021: LD_ADDR_VAR 0 5
69025: PUSH
69026: DOUBLE
69027: LD_INT 1
69029: DEC
69030: ST_TO_ADDR
69031: LD_VAR 0 2
69035: PUSH
69036: LD_INT 1
69038: MINUS
69039: PUSH
69040: FOR_TO
69041: IFFALSE 69086
// begin tmp := tmp [ pos [ i ] ] ;
69043: LD_ADDR_VAR 0 6
69047: PUSH
69048: LD_VAR 0 6
69052: PUSH
69053: LD_VAR 0 2
69057: PUSH
69058: LD_VAR 0 5
69062: ARRAY
69063: ARRAY
69064: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
69065: LD_ADDR_VAR 0 7
69069: PUSH
69070: LD_VAR 0 7
69074: PUSH
69075: LD_VAR 0 6
69079: PUSH
69080: EMPTY
69081: LIST
69082: ADD
69083: ST_TO_ADDR
// end ;
69084: GO 69040
69086: POP
69087: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
69088: LD_ADDR_VAR 0 6
69092: PUSH
69093: LD_VAR 0 6
69097: PPUSH
69098: LD_VAR 0 2
69102: PUSH
69103: LD_VAR 0 2
69107: ARRAY
69108: PPUSH
69109: LD_VAR 0 3
69113: PPUSH
69114: CALL_OW 1
69118: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
69119: LD_ADDR_VAR 0 7
69123: PUSH
69124: LD_VAR 0 7
69128: PPUSH
69129: LD_VAR 0 7
69133: PPUSH
69134: LD_VAR 0 6
69138: PPUSH
69139: CALL_OW 1
69143: ST_TO_ADDR
// for i = s_arr downto 2 do
69144: LD_ADDR_VAR 0 5
69148: PUSH
69149: DOUBLE
69150: LD_VAR 0 7
69154: INC
69155: ST_TO_ADDR
69156: LD_INT 2
69158: PUSH
69159: FOR_DOWNTO
69160: IFFALSE 69244
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
69162: LD_ADDR_VAR 0 6
69166: PUSH
69167: LD_VAR 0 7
69171: PUSH
69172: LD_VAR 0 5
69176: PUSH
69177: LD_INT 1
69179: MINUS
69180: ARRAY
69181: PPUSH
69182: LD_VAR 0 2
69186: PUSH
69187: LD_VAR 0 5
69191: PUSH
69192: LD_INT 1
69194: MINUS
69195: ARRAY
69196: PPUSH
69197: LD_VAR 0 7
69201: PUSH
69202: LD_VAR 0 5
69206: ARRAY
69207: PPUSH
69208: CALL_OW 1
69212: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69213: LD_ADDR_VAR 0 7
69217: PUSH
69218: LD_VAR 0 7
69222: PPUSH
69223: LD_VAR 0 5
69227: PUSH
69228: LD_INT 1
69230: MINUS
69231: PPUSH
69232: LD_VAR 0 6
69236: PPUSH
69237: CALL_OW 1
69241: ST_TO_ADDR
// end ;
69242: GO 69159
69244: POP
69245: POP
// result := s_arr [ 1 ] ;
69246: LD_ADDR_VAR 0 4
69250: PUSH
69251: LD_VAR 0 7
69255: PUSH
69256: LD_INT 1
69258: ARRAY
69259: ST_TO_ADDR
// end ; end ;
69260: LD_VAR 0 4
69264: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
69265: LD_INT 0
69267: PPUSH
69268: PPUSH
// if not list then
69269: LD_VAR 0 1
69273: NOT
69274: IFFALSE 69278
// exit ;
69276: GO 69369
// i := list [ pos1 ] ;
69278: LD_ADDR_VAR 0 5
69282: PUSH
69283: LD_VAR 0 1
69287: PUSH
69288: LD_VAR 0 2
69292: ARRAY
69293: ST_TO_ADDR
// if not i then
69294: LD_VAR 0 5
69298: NOT
69299: IFFALSE 69303
// exit ;
69301: GO 69369
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
69303: LD_ADDR_VAR 0 1
69307: PUSH
69308: LD_VAR 0 1
69312: PPUSH
69313: LD_VAR 0 2
69317: PPUSH
69318: LD_VAR 0 1
69322: PUSH
69323: LD_VAR 0 3
69327: ARRAY
69328: PPUSH
69329: CALL_OW 1
69333: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
69334: LD_ADDR_VAR 0 1
69338: PUSH
69339: LD_VAR 0 1
69343: PPUSH
69344: LD_VAR 0 3
69348: PPUSH
69349: LD_VAR 0 5
69353: PPUSH
69354: CALL_OW 1
69358: ST_TO_ADDR
// result := list ;
69359: LD_ADDR_VAR 0 4
69363: PUSH
69364: LD_VAR 0 1
69368: ST_TO_ADDR
// end ;
69369: LD_VAR 0 4
69373: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
69374: LD_INT 0
69376: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
69377: LD_ADDR_VAR 0 5
69381: PUSH
69382: LD_VAR 0 1
69386: PPUSH
69387: CALL_OW 250
69391: PPUSH
69392: LD_VAR 0 1
69396: PPUSH
69397: CALL_OW 251
69401: PPUSH
69402: LD_VAR 0 2
69406: PPUSH
69407: LD_VAR 0 3
69411: PPUSH
69412: LD_VAR 0 4
69416: PPUSH
69417: CALL 69795 0 5
69421: ST_TO_ADDR
// end ;
69422: LD_VAR 0 5
69426: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
69427: LD_INT 0
69429: PPUSH
69430: PPUSH
69431: PPUSH
69432: PPUSH
// if not list or not unit then
69433: LD_VAR 0 2
69437: NOT
69438: PUSH
69439: LD_VAR 0 1
69443: NOT
69444: OR
69445: IFFALSE 69449
// exit ;
69447: GO 69790
// result := [ ] ;
69449: LD_ADDR_VAR 0 5
69453: PUSH
69454: EMPTY
69455: ST_TO_ADDR
// for i in list do
69456: LD_ADDR_VAR 0 6
69460: PUSH
69461: LD_VAR 0 2
69465: PUSH
69466: FOR_IN
69467: IFFALSE 69685
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
69469: LD_ADDR_VAR 0 8
69473: PUSH
69474: LD_VAR 0 1
69478: PPUSH
69479: LD_VAR 0 6
69483: PUSH
69484: LD_INT 1
69486: ARRAY
69487: PPUSH
69488: LD_VAR 0 6
69492: PUSH
69493: LD_INT 2
69495: ARRAY
69496: PPUSH
69497: CALL_OW 297
69501: ST_TO_ADDR
// if not Count ( result ) then
69502: LD_VAR 0 5
69506: PPUSH
69507: CALL 66079 0 1
69511: NOT
69512: IFFALSE 69545
// begin result := Join ( result , [ i , tmp ] ) ;
69514: LD_ADDR_VAR 0 5
69518: PUSH
69519: LD_VAR 0 5
69523: PPUSH
69524: LD_VAR 0 6
69528: PUSH
69529: LD_VAR 0 8
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PPUSH
69538: CALL 101668 0 2
69542: ST_TO_ADDR
// continue ;
69543: GO 69466
// end ; if result [ result ] [ 2 ] <= tmp then
69545: LD_VAR 0 5
69549: PUSH
69550: LD_VAR 0 5
69554: ARRAY
69555: PUSH
69556: LD_INT 2
69558: ARRAY
69559: PUSH
69560: LD_VAR 0 8
69564: LESSEQUAL
69565: IFFALSE 69598
// result := Join ( result , [ i , tmp ] ) else
69567: LD_ADDR_VAR 0 5
69571: PUSH
69572: LD_VAR 0 5
69576: PPUSH
69577: LD_VAR 0 6
69581: PUSH
69582: LD_VAR 0 8
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PPUSH
69591: CALL 101668 0 2
69595: ST_TO_ADDR
69596: GO 69683
// begin for j := 1 to Count ( result ) do
69598: LD_ADDR_VAR 0 7
69602: PUSH
69603: DOUBLE
69604: LD_INT 1
69606: DEC
69607: ST_TO_ADDR
69608: LD_VAR 0 5
69612: PPUSH
69613: CALL 66079 0 1
69617: PUSH
69618: FOR_TO
69619: IFFALSE 69681
// begin if tmp < result [ j ] [ 2 ] then
69621: LD_VAR 0 8
69625: PUSH
69626: LD_VAR 0 5
69630: PUSH
69631: LD_VAR 0 7
69635: ARRAY
69636: PUSH
69637: LD_INT 2
69639: ARRAY
69640: LESS
69641: IFFALSE 69679
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69643: LD_ADDR_VAR 0 5
69647: PUSH
69648: LD_VAR 0 5
69652: PPUSH
69653: LD_VAR 0 7
69657: PPUSH
69658: LD_VAR 0 6
69662: PUSH
69663: LD_VAR 0 8
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PPUSH
69672: CALL_OW 2
69676: ST_TO_ADDR
// break ;
69677: GO 69681
// end ; end ;
69679: GO 69618
69681: POP
69682: POP
// end ; end ;
69683: GO 69466
69685: POP
69686: POP
// if result and not asc then
69687: LD_VAR 0 5
69691: PUSH
69692: LD_VAR 0 3
69696: NOT
69697: AND
69698: IFFALSE 69715
// result := ReverseArray ( result ) ;
69700: LD_ADDR_VAR 0 5
69704: PUSH
69705: LD_VAR 0 5
69709: PPUSH
69710: CALL 96955 0 1
69714: ST_TO_ADDR
// tmp := [ ] ;
69715: LD_ADDR_VAR 0 8
69719: PUSH
69720: EMPTY
69721: ST_TO_ADDR
// if mode then
69722: LD_VAR 0 4
69726: IFFALSE 69790
// begin for i := 1 to result do
69728: LD_ADDR_VAR 0 6
69732: PUSH
69733: DOUBLE
69734: LD_INT 1
69736: DEC
69737: ST_TO_ADDR
69738: LD_VAR 0 5
69742: PUSH
69743: FOR_TO
69744: IFFALSE 69778
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
69746: LD_ADDR_VAR 0 8
69750: PUSH
69751: LD_VAR 0 8
69755: PPUSH
69756: LD_VAR 0 5
69760: PUSH
69761: LD_VAR 0 6
69765: ARRAY
69766: PUSH
69767: LD_INT 1
69769: ARRAY
69770: PPUSH
69771: CALL 101668 0 2
69775: ST_TO_ADDR
69776: GO 69743
69778: POP
69779: POP
// result := tmp ;
69780: LD_ADDR_VAR 0 5
69784: PUSH
69785: LD_VAR 0 8
69789: ST_TO_ADDR
// end ; end ;
69790: LD_VAR 0 5
69794: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
69795: LD_INT 0
69797: PPUSH
69798: PPUSH
69799: PPUSH
69800: PPUSH
// if not list then
69801: LD_VAR 0 3
69805: NOT
69806: IFFALSE 69810
// exit ;
69808: GO 70198
// result := [ ] ;
69810: LD_ADDR_VAR 0 6
69814: PUSH
69815: EMPTY
69816: ST_TO_ADDR
// for i in list do
69817: LD_ADDR_VAR 0 7
69821: PUSH
69822: LD_VAR 0 3
69826: PUSH
69827: FOR_IN
69828: IFFALSE 70030
// begin tmp := GetDistUnitXY ( i , x , y ) ;
69830: LD_ADDR_VAR 0 9
69834: PUSH
69835: LD_VAR 0 7
69839: PPUSH
69840: LD_VAR 0 1
69844: PPUSH
69845: LD_VAR 0 2
69849: PPUSH
69850: CALL_OW 297
69854: ST_TO_ADDR
// if not result then
69855: LD_VAR 0 6
69859: NOT
69860: IFFALSE 69886
// result := [ [ i , tmp ] ] else
69862: LD_ADDR_VAR 0 6
69866: PUSH
69867: LD_VAR 0 7
69871: PUSH
69872: LD_VAR 0 9
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: EMPTY
69882: LIST
69883: ST_TO_ADDR
69884: GO 70028
// begin if result [ result ] [ 2 ] < tmp then
69886: LD_VAR 0 6
69890: PUSH
69891: LD_VAR 0 6
69895: ARRAY
69896: PUSH
69897: LD_INT 2
69899: ARRAY
69900: PUSH
69901: LD_VAR 0 9
69905: LESS
69906: IFFALSE 69948
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69908: LD_ADDR_VAR 0 6
69912: PUSH
69913: LD_VAR 0 6
69917: PPUSH
69918: LD_VAR 0 6
69922: PUSH
69923: LD_INT 1
69925: PLUS
69926: PPUSH
69927: LD_VAR 0 7
69931: PUSH
69932: LD_VAR 0 9
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PPUSH
69941: CALL_OW 2
69945: ST_TO_ADDR
69946: GO 70028
// for j = 1 to result do
69948: LD_ADDR_VAR 0 8
69952: PUSH
69953: DOUBLE
69954: LD_INT 1
69956: DEC
69957: ST_TO_ADDR
69958: LD_VAR 0 6
69962: PUSH
69963: FOR_TO
69964: IFFALSE 70026
// begin if tmp < result [ j ] [ 2 ] then
69966: LD_VAR 0 9
69970: PUSH
69971: LD_VAR 0 6
69975: PUSH
69976: LD_VAR 0 8
69980: ARRAY
69981: PUSH
69982: LD_INT 2
69984: ARRAY
69985: LESS
69986: IFFALSE 70024
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69988: LD_ADDR_VAR 0 6
69992: PUSH
69993: LD_VAR 0 6
69997: PPUSH
69998: LD_VAR 0 8
70002: PPUSH
70003: LD_VAR 0 7
70007: PUSH
70008: LD_VAR 0 9
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PPUSH
70017: CALL_OW 2
70021: ST_TO_ADDR
// break ;
70022: GO 70026
// end ; end ;
70024: GO 69963
70026: POP
70027: POP
// end ; end ;
70028: GO 69827
70030: POP
70031: POP
// if result and not asc then
70032: LD_VAR 0 6
70036: PUSH
70037: LD_VAR 0 4
70041: NOT
70042: AND
70043: IFFALSE 70118
// begin tmp := result ;
70045: LD_ADDR_VAR 0 9
70049: PUSH
70050: LD_VAR 0 6
70054: ST_TO_ADDR
// for i = tmp downto 1 do
70055: LD_ADDR_VAR 0 7
70059: PUSH
70060: DOUBLE
70061: LD_VAR 0 9
70065: INC
70066: ST_TO_ADDR
70067: LD_INT 1
70069: PUSH
70070: FOR_DOWNTO
70071: IFFALSE 70116
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70073: LD_ADDR_VAR 0 6
70077: PUSH
70078: LD_VAR 0 6
70082: PPUSH
70083: LD_VAR 0 9
70087: PUSH
70088: LD_VAR 0 7
70092: MINUS
70093: PUSH
70094: LD_INT 1
70096: PLUS
70097: PPUSH
70098: LD_VAR 0 9
70102: PUSH
70103: LD_VAR 0 7
70107: ARRAY
70108: PPUSH
70109: CALL_OW 1
70113: ST_TO_ADDR
70114: GO 70070
70116: POP
70117: POP
// end ; tmp := [ ] ;
70118: LD_ADDR_VAR 0 9
70122: PUSH
70123: EMPTY
70124: ST_TO_ADDR
// if mode then
70125: LD_VAR 0 5
70129: IFFALSE 70198
// begin for i = 1 to result do
70131: LD_ADDR_VAR 0 7
70135: PUSH
70136: DOUBLE
70137: LD_INT 1
70139: DEC
70140: ST_TO_ADDR
70141: LD_VAR 0 6
70145: PUSH
70146: FOR_TO
70147: IFFALSE 70186
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70149: LD_ADDR_VAR 0 9
70153: PUSH
70154: LD_VAR 0 9
70158: PPUSH
70159: LD_VAR 0 7
70163: PPUSH
70164: LD_VAR 0 6
70168: PUSH
70169: LD_VAR 0 7
70173: ARRAY
70174: PUSH
70175: LD_INT 1
70177: ARRAY
70178: PPUSH
70179: CALL_OW 1
70183: ST_TO_ADDR
70184: GO 70146
70186: POP
70187: POP
// result := tmp ;
70188: LD_ADDR_VAR 0 6
70192: PUSH
70193: LD_VAR 0 9
70197: ST_TO_ADDR
// end ; end ;
70198: LD_VAR 0 6
70202: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70203: LD_INT 0
70205: PPUSH
70206: PPUSH
70207: PPUSH
70208: PPUSH
70209: PPUSH
70210: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70211: LD_ADDR_VAR 0 5
70215: PUSH
70216: LD_INT 0
70218: PUSH
70219: LD_INT 0
70221: PUSH
70222: LD_INT 0
70224: PUSH
70225: EMPTY
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: ST_TO_ADDR
// if not x or not y then
70233: LD_VAR 0 2
70237: NOT
70238: PUSH
70239: LD_VAR 0 3
70243: NOT
70244: OR
70245: IFFALSE 70249
// exit ;
70247: GO 71899
// if not range then
70249: LD_VAR 0 4
70253: NOT
70254: IFFALSE 70264
// range := 10 ;
70256: LD_ADDR_VAR 0 4
70260: PUSH
70261: LD_INT 10
70263: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70264: LD_ADDR_VAR 0 8
70268: PUSH
70269: LD_INT 81
70271: PUSH
70272: LD_VAR 0 1
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 92
70283: PUSH
70284: LD_VAR 0 2
70288: PUSH
70289: LD_VAR 0 3
70293: PUSH
70294: LD_VAR 0 4
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 3
70307: PUSH
70308: LD_INT 21
70310: PUSH
70311: LD_INT 3
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: LIST
70326: PPUSH
70327: CALL_OW 69
70331: ST_TO_ADDR
// if not tmp then
70332: LD_VAR 0 8
70336: NOT
70337: IFFALSE 70341
// exit ;
70339: GO 71899
// for i in tmp do
70341: LD_ADDR_VAR 0 6
70345: PUSH
70346: LD_VAR 0 8
70350: PUSH
70351: FOR_IN
70352: IFFALSE 71874
// begin points := [ 0 , 0 , 0 ] ;
70354: LD_ADDR_VAR 0 9
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 0
70364: PUSH
70365: LD_INT 0
70367: PUSH
70368: EMPTY
70369: LIST
70370: LIST
70371: LIST
70372: ST_TO_ADDR
// bpoints := 1 ;
70373: LD_ADDR_VAR 0 10
70377: PUSH
70378: LD_INT 1
70380: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70381: LD_VAR 0 6
70385: PPUSH
70386: CALL_OW 247
70390: PUSH
70391: LD_INT 1
70393: DOUBLE
70394: EQUAL
70395: IFTRUE 70399
70397: GO 70977
70399: POP
// begin if GetClass ( i ) = 1 then
70400: LD_VAR 0 6
70404: PPUSH
70405: CALL_OW 257
70409: PUSH
70410: LD_INT 1
70412: EQUAL
70413: IFFALSE 70434
// points := [ 10 , 5 , 3 ] ;
70415: LD_ADDR_VAR 0 9
70419: PUSH
70420: LD_INT 10
70422: PUSH
70423: LD_INT 5
70425: PUSH
70426: LD_INT 3
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: LIST
70433: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70434: LD_VAR 0 6
70438: PPUSH
70439: CALL_OW 257
70443: PUSH
70444: LD_INT 2
70446: PUSH
70447: LD_INT 3
70449: PUSH
70450: LD_INT 4
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: LIST
70457: IN
70458: IFFALSE 70479
// points := [ 3 , 2 , 1 ] ;
70460: LD_ADDR_VAR 0 9
70464: PUSH
70465: LD_INT 3
70467: PUSH
70468: LD_INT 2
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: LIST
70478: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70479: LD_VAR 0 6
70483: PPUSH
70484: CALL_OW 257
70488: PUSH
70489: LD_INT 5
70491: EQUAL
70492: IFFALSE 70513
// points := [ 130 , 5 , 2 ] ;
70494: LD_ADDR_VAR 0 9
70498: PUSH
70499: LD_INT 130
70501: PUSH
70502: LD_INT 5
70504: PUSH
70505: LD_INT 2
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: LIST
70512: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70513: LD_VAR 0 6
70517: PPUSH
70518: CALL_OW 257
70522: PUSH
70523: LD_INT 8
70525: EQUAL
70526: IFFALSE 70547
// points := [ 35 , 35 , 30 ] ;
70528: LD_ADDR_VAR 0 9
70532: PUSH
70533: LD_INT 35
70535: PUSH
70536: LD_INT 35
70538: PUSH
70539: LD_INT 30
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: LIST
70546: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70547: LD_VAR 0 6
70551: PPUSH
70552: CALL_OW 257
70556: PUSH
70557: LD_INT 9
70559: EQUAL
70560: IFFALSE 70581
// points := [ 20 , 55 , 40 ] ;
70562: LD_ADDR_VAR 0 9
70566: PUSH
70567: LD_INT 20
70569: PUSH
70570: LD_INT 55
70572: PUSH
70573: LD_INT 40
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: LIST
70580: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70581: LD_VAR 0 6
70585: PPUSH
70586: CALL_OW 257
70590: PUSH
70591: LD_INT 12
70593: PUSH
70594: LD_INT 16
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: IN
70601: IFFALSE 70622
// points := [ 5 , 3 , 2 ] ;
70603: LD_ADDR_VAR 0 9
70607: PUSH
70608: LD_INT 5
70610: PUSH
70611: LD_INT 3
70613: PUSH
70614: LD_INT 2
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: LIST
70621: ST_TO_ADDR
// if GetClass ( i ) = 17 then
70622: LD_VAR 0 6
70626: PPUSH
70627: CALL_OW 257
70631: PUSH
70632: LD_INT 17
70634: EQUAL
70635: IFFALSE 70656
// points := [ 100 , 50 , 75 ] ;
70637: LD_ADDR_VAR 0 9
70641: PUSH
70642: LD_INT 100
70644: PUSH
70645: LD_INT 50
70647: PUSH
70648: LD_INT 75
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: LIST
70655: ST_TO_ADDR
// if GetClass ( i ) = 15 then
70656: LD_VAR 0 6
70660: PPUSH
70661: CALL_OW 257
70665: PUSH
70666: LD_INT 15
70668: EQUAL
70669: IFFALSE 70690
// points := [ 10 , 5 , 3 ] ;
70671: LD_ADDR_VAR 0 9
70675: PUSH
70676: LD_INT 10
70678: PUSH
70679: LD_INT 5
70681: PUSH
70682: LD_INT 3
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: LIST
70689: ST_TO_ADDR
// if GetClass ( i ) = 14 then
70690: LD_VAR 0 6
70694: PPUSH
70695: CALL_OW 257
70699: PUSH
70700: LD_INT 14
70702: EQUAL
70703: IFFALSE 70724
// points := [ 10 , 0 , 0 ] ;
70705: LD_ADDR_VAR 0 9
70709: PUSH
70710: LD_INT 10
70712: PUSH
70713: LD_INT 0
70715: PUSH
70716: LD_INT 0
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: LIST
70723: ST_TO_ADDR
// if GetClass ( i ) = 11 then
70724: LD_VAR 0 6
70728: PPUSH
70729: CALL_OW 257
70733: PUSH
70734: LD_INT 11
70736: EQUAL
70737: IFFALSE 70758
// points := [ 30 , 10 , 5 ] ;
70739: LD_ADDR_VAR 0 9
70743: PUSH
70744: LD_INT 30
70746: PUSH
70747: LD_INT 10
70749: PUSH
70750: LD_INT 5
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: LIST
70757: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
70758: LD_VAR 0 1
70762: PPUSH
70763: LD_INT 5
70765: PPUSH
70766: CALL_OW 321
70770: PUSH
70771: LD_INT 2
70773: EQUAL
70774: IFFALSE 70791
// bpoints := bpoints * 1.8 ;
70776: LD_ADDR_VAR 0 10
70780: PUSH
70781: LD_VAR 0 10
70785: PUSH
70786: LD_REAL  1.80000000000000E+0000
70789: MUL
70790: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
70791: LD_VAR 0 6
70795: PPUSH
70796: CALL_OW 257
70800: PUSH
70801: LD_INT 1
70803: PUSH
70804: LD_INT 2
70806: PUSH
70807: LD_INT 3
70809: PUSH
70810: LD_INT 4
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: IN
70819: PUSH
70820: LD_VAR 0 1
70824: PPUSH
70825: LD_INT 51
70827: PPUSH
70828: CALL_OW 321
70832: PUSH
70833: LD_INT 2
70835: EQUAL
70836: AND
70837: IFFALSE 70854
// bpoints := bpoints * 1.2 ;
70839: LD_ADDR_VAR 0 10
70843: PUSH
70844: LD_VAR 0 10
70848: PUSH
70849: LD_REAL  1.20000000000000E+0000
70852: MUL
70853: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
70854: LD_VAR 0 6
70858: PPUSH
70859: CALL_OW 257
70863: PUSH
70864: LD_INT 5
70866: PUSH
70867: LD_INT 7
70869: PUSH
70870: LD_INT 9
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: LIST
70877: IN
70878: PUSH
70879: LD_VAR 0 1
70883: PPUSH
70884: LD_INT 52
70886: PPUSH
70887: CALL_OW 321
70891: PUSH
70892: LD_INT 2
70894: EQUAL
70895: AND
70896: IFFALSE 70913
// bpoints := bpoints * 1.5 ;
70898: LD_ADDR_VAR 0 10
70902: PUSH
70903: LD_VAR 0 10
70907: PUSH
70908: LD_REAL  1.50000000000000E+0000
70911: MUL
70912: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70913: LD_VAR 0 1
70917: PPUSH
70918: LD_INT 66
70920: PPUSH
70921: CALL_OW 321
70925: PUSH
70926: LD_INT 2
70928: EQUAL
70929: IFFALSE 70946
// bpoints := bpoints * 1.1 ;
70931: LD_ADDR_VAR 0 10
70935: PUSH
70936: LD_VAR 0 10
70940: PUSH
70941: LD_REAL  1.10000000000000E+0000
70944: MUL
70945: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70946: LD_ADDR_VAR 0 10
70950: PUSH
70951: LD_VAR 0 10
70955: PUSH
70956: LD_VAR 0 6
70960: PPUSH
70961: LD_INT 1
70963: PPUSH
70964: CALL_OW 259
70968: PUSH
70969: LD_REAL  1.15000000000000E+0000
70972: MUL
70973: MUL
70974: ST_TO_ADDR
// end ; unit_vehicle :
70975: GO 71803
70977: LD_INT 2
70979: DOUBLE
70980: EQUAL
70981: IFTRUE 70985
70983: GO 71791
70985: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70986: LD_VAR 0 6
70990: PPUSH
70991: CALL_OW 264
70995: PUSH
70996: LD_INT 2
70998: PUSH
70999: LD_INT 42
71001: PUSH
71002: LD_INT 24
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: LIST
71009: IN
71010: IFFALSE 71031
// points := [ 25 , 5 , 3 ] ;
71012: LD_ADDR_VAR 0 9
71016: PUSH
71017: LD_INT 25
71019: PUSH
71020: LD_INT 5
71022: PUSH
71023: LD_INT 3
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: LIST
71030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71031: LD_VAR 0 6
71035: PPUSH
71036: CALL_OW 264
71040: PUSH
71041: LD_INT 4
71043: PUSH
71044: LD_INT 43
71046: PUSH
71047: LD_INT 25
71049: PUSH
71050: EMPTY
71051: LIST
71052: LIST
71053: LIST
71054: IN
71055: IFFALSE 71076
// points := [ 40 , 15 , 5 ] ;
71057: LD_ADDR_VAR 0 9
71061: PUSH
71062: LD_INT 40
71064: PUSH
71065: LD_INT 15
71067: PUSH
71068: LD_INT 5
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: LIST
71075: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71076: LD_VAR 0 6
71080: PPUSH
71081: CALL_OW 264
71085: PUSH
71086: LD_INT 3
71088: PUSH
71089: LD_INT 23
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: IN
71096: IFFALSE 71117
// points := [ 7 , 25 , 8 ] ;
71098: LD_ADDR_VAR 0 9
71102: PUSH
71103: LD_INT 7
71105: PUSH
71106: LD_INT 25
71108: PUSH
71109: LD_INT 8
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: LIST
71116: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71117: LD_VAR 0 6
71121: PPUSH
71122: CALL_OW 264
71126: PUSH
71127: LD_INT 5
71129: PUSH
71130: LD_INT 27
71132: PUSH
71133: LD_INT 44
71135: PUSH
71136: EMPTY
71137: LIST
71138: LIST
71139: LIST
71140: IN
71141: IFFALSE 71162
// points := [ 14 , 50 , 16 ] ;
71143: LD_ADDR_VAR 0 9
71147: PUSH
71148: LD_INT 14
71150: PUSH
71151: LD_INT 50
71153: PUSH
71154: LD_INT 16
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: LIST
71161: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71162: LD_VAR 0 6
71166: PPUSH
71167: CALL_OW 264
71171: PUSH
71172: LD_INT 6
71174: PUSH
71175: LD_INT 46
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: IN
71182: IFFALSE 71203
// points := [ 32 , 120 , 70 ] ;
71184: LD_ADDR_VAR 0 9
71188: PUSH
71189: LD_INT 32
71191: PUSH
71192: LD_INT 120
71194: PUSH
71195: LD_INT 70
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: LIST
71202: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
71203: LD_VAR 0 6
71207: PPUSH
71208: CALL_OW 264
71212: PUSH
71213: LD_INT 7
71215: PUSH
71216: LD_INT 28
71218: PUSH
71219: LD_INT 45
71221: PUSH
71222: LD_INT 92
71224: PUSH
71225: EMPTY
71226: LIST
71227: LIST
71228: LIST
71229: LIST
71230: IN
71231: IFFALSE 71252
// points := [ 35 , 20 , 45 ] ;
71233: LD_ADDR_VAR 0 9
71237: PUSH
71238: LD_INT 35
71240: PUSH
71241: LD_INT 20
71243: PUSH
71244: LD_INT 45
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: LIST
71251: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71252: LD_VAR 0 6
71256: PPUSH
71257: CALL_OW 264
71261: PUSH
71262: LD_INT 47
71264: PUSH
71265: EMPTY
71266: LIST
71267: IN
71268: IFFALSE 71289
// points := [ 67 , 45 , 75 ] ;
71270: LD_ADDR_VAR 0 9
71274: PUSH
71275: LD_INT 67
71277: PUSH
71278: LD_INT 45
71280: PUSH
71281: LD_INT 75
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: LIST
71288: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71289: LD_VAR 0 6
71293: PPUSH
71294: CALL_OW 264
71298: PUSH
71299: LD_INT 26
71301: PUSH
71302: EMPTY
71303: LIST
71304: IN
71305: IFFALSE 71326
// points := [ 120 , 30 , 80 ] ;
71307: LD_ADDR_VAR 0 9
71311: PUSH
71312: LD_INT 120
71314: PUSH
71315: LD_INT 30
71317: PUSH
71318: LD_INT 80
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: LIST
71325: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71326: LD_VAR 0 6
71330: PPUSH
71331: CALL_OW 264
71335: PUSH
71336: LD_INT 22
71338: PUSH
71339: EMPTY
71340: LIST
71341: IN
71342: IFFALSE 71363
// points := [ 40 , 1 , 1 ] ;
71344: LD_ADDR_VAR 0 9
71348: PUSH
71349: LD_INT 40
71351: PUSH
71352: LD_INT 1
71354: PUSH
71355: LD_INT 1
71357: PUSH
71358: EMPTY
71359: LIST
71360: LIST
71361: LIST
71362: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71363: LD_VAR 0 6
71367: PPUSH
71368: CALL_OW 264
71372: PUSH
71373: LD_INT 29
71375: PUSH
71376: EMPTY
71377: LIST
71378: IN
71379: IFFALSE 71400
// points := [ 70 , 200 , 400 ] ;
71381: LD_ADDR_VAR 0 9
71385: PUSH
71386: LD_INT 70
71388: PUSH
71389: LD_INT 200
71391: PUSH
71392: LD_INT 400
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: LIST
71399: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71400: LD_VAR 0 6
71404: PPUSH
71405: CALL_OW 264
71409: PUSH
71410: LD_INT 14
71412: PUSH
71413: LD_INT 53
71415: PUSH
71416: EMPTY
71417: LIST
71418: LIST
71419: IN
71420: IFFALSE 71441
// points := [ 40 , 10 , 20 ] ;
71422: LD_ADDR_VAR 0 9
71426: PUSH
71427: LD_INT 40
71429: PUSH
71430: LD_INT 10
71432: PUSH
71433: LD_INT 20
71435: PUSH
71436: EMPTY
71437: LIST
71438: LIST
71439: LIST
71440: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71441: LD_VAR 0 6
71445: PPUSH
71446: CALL_OW 264
71450: PUSH
71451: LD_INT 9
71453: PUSH
71454: EMPTY
71455: LIST
71456: IN
71457: IFFALSE 71478
// points := [ 5 , 70 , 20 ] ;
71459: LD_ADDR_VAR 0 9
71463: PUSH
71464: LD_INT 5
71466: PUSH
71467: LD_INT 70
71469: PUSH
71470: LD_INT 20
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: LIST
71477: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71478: LD_VAR 0 6
71482: PPUSH
71483: CALL_OW 264
71487: PUSH
71488: LD_INT 10
71490: PUSH
71491: EMPTY
71492: LIST
71493: IN
71494: IFFALSE 71515
// points := [ 35 , 110 , 70 ] ;
71496: LD_ADDR_VAR 0 9
71500: PUSH
71501: LD_INT 35
71503: PUSH
71504: LD_INT 110
71506: PUSH
71507: LD_INT 70
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: LIST
71514: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71515: LD_VAR 0 6
71519: PPUSH
71520: CALL_OW 265
71524: PUSH
71525: LD_INT 25
71527: EQUAL
71528: IFFALSE 71549
// points := [ 80 , 65 , 100 ] ;
71530: LD_ADDR_VAR 0 9
71534: PUSH
71535: LD_INT 80
71537: PUSH
71538: LD_INT 65
71540: PUSH
71541: LD_INT 100
71543: PUSH
71544: EMPTY
71545: LIST
71546: LIST
71547: LIST
71548: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71549: LD_VAR 0 6
71553: PPUSH
71554: CALL_OW 263
71558: PUSH
71559: LD_INT 1
71561: EQUAL
71562: IFFALSE 71597
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71564: LD_ADDR_VAR 0 10
71568: PUSH
71569: LD_VAR 0 10
71573: PUSH
71574: LD_VAR 0 6
71578: PPUSH
71579: CALL_OW 311
71583: PPUSH
71584: LD_INT 3
71586: PPUSH
71587: CALL_OW 259
71591: PUSH
71592: LD_INT 4
71594: MUL
71595: MUL
71596: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71597: LD_VAR 0 6
71601: PPUSH
71602: CALL_OW 263
71606: PUSH
71607: LD_INT 2
71609: EQUAL
71610: IFFALSE 71661
// begin j := IsControledBy ( i ) ;
71612: LD_ADDR_VAR 0 7
71616: PUSH
71617: LD_VAR 0 6
71621: PPUSH
71622: CALL_OW 312
71626: ST_TO_ADDR
// if j then
71627: LD_VAR 0 7
71631: IFFALSE 71661
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
71633: LD_ADDR_VAR 0 10
71637: PUSH
71638: LD_VAR 0 10
71642: PUSH
71643: LD_VAR 0 7
71647: PPUSH
71648: LD_INT 3
71650: PPUSH
71651: CALL_OW 259
71655: PUSH
71656: LD_INT 3
71658: MUL
71659: MUL
71660: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
71661: LD_VAR 0 6
71665: PPUSH
71666: CALL_OW 264
71670: PUSH
71671: LD_INT 5
71673: PUSH
71674: LD_INT 6
71676: PUSH
71677: LD_INT 46
71679: PUSH
71680: LD_INT 44
71682: PUSH
71683: LD_INT 47
71685: PUSH
71686: LD_INT 45
71688: PUSH
71689: LD_INT 28
71691: PUSH
71692: LD_INT 7
71694: PUSH
71695: LD_INT 27
71697: PUSH
71698: LD_INT 29
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: IN
71713: PUSH
71714: LD_VAR 0 1
71718: PPUSH
71719: LD_INT 52
71721: PPUSH
71722: CALL_OW 321
71726: PUSH
71727: LD_INT 2
71729: EQUAL
71730: AND
71731: IFFALSE 71748
// bpoints := bpoints * 1.2 ;
71733: LD_ADDR_VAR 0 10
71737: PUSH
71738: LD_VAR 0 10
71742: PUSH
71743: LD_REAL  1.20000000000000E+0000
71746: MUL
71747: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
71748: LD_VAR 0 6
71752: PPUSH
71753: CALL_OW 264
71757: PUSH
71758: LD_INT 6
71760: PUSH
71761: LD_INT 46
71763: PUSH
71764: LD_INT 47
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: LIST
71771: IN
71772: IFFALSE 71789
// bpoints := bpoints * 1.2 ;
71774: LD_ADDR_VAR 0 10
71778: PUSH
71779: LD_VAR 0 10
71783: PUSH
71784: LD_REAL  1.20000000000000E+0000
71787: MUL
71788: ST_TO_ADDR
// end ; unit_building :
71789: GO 71803
71791: LD_INT 3
71793: DOUBLE
71794: EQUAL
71795: IFTRUE 71799
71797: GO 71802
71799: POP
// ; end ;
71800: GO 71803
71802: POP
// for j = 1 to 3 do
71803: LD_ADDR_VAR 0 7
71807: PUSH
71808: DOUBLE
71809: LD_INT 1
71811: DEC
71812: ST_TO_ADDR
71813: LD_INT 3
71815: PUSH
71816: FOR_TO
71817: IFFALSE 71870
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
71819: LD_ADDR_VAR 0 5
71823: PUSH
71824: LD_VAR 0 5
71828: PPUSH
71829: LD_VAR 0 7
71833: PPUSH
71834: LD_VAR 0 5
71838: PUSH
71839: LD_VAR 0 7
71843: ARRAY
71844: PUSH
71845: LD_VAR 0 9
71849: PUSH
71850: LD_VAR 0 7
71854: ARRAY
71855: PUSH
71856: LD_VAR 0 10
71860: MUL
71861: PLUS
71862: PPUSH
71863: CALL_OW 1
71867: ST_TO_ADDR
71868: GO 71816
71870: POP
71871: POP
// end ;
71872: GO 70351
71874: POP
71875: POP
// result := Replace ( result , 4 , tmp ) ;
71876: LD_ADDR_VAR 0 5
71880: PUSH
71881: LD_VAR 0 5
71885: PPUSH
71886: LD_INT 4
71888: PPUSH
71889: LD_VAR 0 8
71893: PPUSH
71894: CALL_OW 1
71898: ST_TO_ADDR
// end ;
71899: LD_VAR 0 5
71903: RET
// export function DangerAtRange ( unit , range ) ; begin
71904: LD_INT 0
71906: PPUSH
// if not unit then
71907: LD_VAR 0 1
71911: NOT
71912: IFFALSE 71916
// exit ;
71914: GO 71961
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71916: LD_ADDR_VAR 0 3
71920: PUSH
71921: LD_VAR 0 1
71925: PPUSH
71926: CALL_OW 255
71930: PPUSH
71931: LD_VAR 0 1
71935: PPUSH
71936: CALL_OW 250
71940: PPUSH
71941: LD_VAR 0 1
71945: PPUSH
71946: CALL_OW 251
71950: PPUSH
71951: LD_VAR 0 2
71955: PPUSH
71956: CALL 70203 0 4
71960: ST_TO_ADDR
// end ;
71961: LD_VAR 0 3
71965: RET
// export function DangerInArea ( side , area ) ; begin
71966: LD_INT 0
71968: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71969: LD_ADDR_VAR 0 3
71973: PUSH
71974: LD_VAR 0 2
71978: PPUSH
71979: LD_INT 81
71981: PUSH
71982: LD_VAR 0 1
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PPUSH
71991: CALL_OW 70
71995: ST_TO_ADDR
// end ;
71996: LD_VAR 0 3
72000: RET
// export function IsExtension ( b ) ; begin
72001: LD_INT 0
72003: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72004: LD_ADDR_VAR 0 2
72008: PUSH
72009: LD_VAR 0 1
72013: PUSH
72014: LD_INT 23
72016: PUSH
72017: LD_INT 20
72019: PUSH
72020: LD_INT 22
72022: PUSH
72023: LD_INT 17
72025: PUSH
72026: LD_INT 24
72028: PUSH
72029: LD_INT 21
72031: PUSH
72032: LD_INT 19
72034: PUSH
72035: LD_INT 16
72037: PUSH
72038: LD_INT 25
72040: PUSH
72041: LD_INT 18
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: IN
72056: ST_TO_ADDR
// end ;
72057: LD_VAR 0 2
72061: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
72062: LD_INT 0
72064: PPUSH
72065: PPUSH
72066: PPUSH
// result := [ ] ;
72067: LD_ADDR_VAR 0 4
72071: PUSH
72072: EMPTY
72073: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72074: LD_ADDR_VAR 0 5
72078: PUSH
72079: LD_VAR 0 2
72083: PPUSH
72084: LD_INT 21
72086: PUSH
72087: LD_INT 3
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PPUSH
72094: CALL_OW 70
72098: ST_TO_ADDR
// if not tmp then
72099: LD_VAR 0 5
72103: NOT
72104: IFFALSE 72108
// exit ;
72106: GO 72172
// if checkLink then
72108: LD_VAR 0 3
72112: IFFALSE 72162
// begin for i in tmp do
72114: LD_ADDR_VAR 0 6
72118: PUSH
72119: LD_VAR 0 5
72123: PUSH
72124: FOR_IN
72125: IFFALSE 72160
// if GetBase ( i ) <> base then
72127: LD_VAR 0 6
72131: PPUSH
72132: CALL_OW 274
72136: PUSH
72137: LD_VAR 0 1
72141: NONEQUAL
72142: IFFALSE 72158
// ComLinkToBase ( base , i ) ;
72144: LD_VAR 0 1
72148: PPUSH
72149: LD_VAR 0 6
72153: PPUSH
72154: CALL_OW 169
72158: GO 72124
72160: POP
72161: POP
// end ; result := tmp ;
72162: LD_ADDR_VAR 0 4
72166: PUSH
72167: LD_VAR 0 5
72171: ST_TO_ADDR
// end ;
72172: LD_VAR 0 4
72176: RET
// export function ComComplete ( units , b ) ; var i ; begin
72177: LD_INT 0
72179: PPUSH
72180: PPUSH
// if not units then
72181: LD_VAR 0 1
72185: NOT
72186: IFFALSE 72190
// exit ;
72188: GO 72280
// for i in units do
72190: LD_ADDR_VAR 0 4
72194: PUSH
72195: LD_VAR 0 1
72199: PUSH
72200: FOR_IN
72201: IFFALSE 72278
// if BuildingStatus ( b ) = bs_build then
72203: LD_VAR 0 2
72207: PPUSH
72208: CALL_OW 461
72212: PUSH
72213: LD_INT 1
72215: EQUAL
72216: IFFALSE 72276
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72218: LD_VAR 0 4
72222: PPUSH
72223: LD_STRING h
72225: PUSH
72226: LD_VAR 0 2
72230: PPUSH
72231: CALL_OW 250
72235: PUSH
72236: LD_VAR 0 2
72240: PPUSH
72241: CALL_OW 251
72245: PUSH
72246: LD_VAR 0 2
72250: PUSH
72251: LD_INT 0
72253: PUSH
72254: LD_INT 0
72256: PUSH
72257: LD_INT 0
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: PUSH
72269: EMPTY
72270: LIST
72271: PPUSH
72272: CALL_OW 446
72276: GO 72200
72278: POP
72279: POP
// end ;
72280: LD_VAR 0 3
72284: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72285: LD_INT 0
72287: PPUSH
72288: PPUSH
72289: PPUSH
72290: PPUSH
72291: PPUSH
72292: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
72293: LD_VAR 0 1
72297: NOT
72298: PUSH
72299: LD_VAR 0 1
72303: PPUSH
72304: CALL_OW 263
72308: PUSH
72309: LD_INT 2
72311: NONEQUAL
72312: OR
72313: IFFALSE 72317
// exit ;
72315: GO 72633
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72317: LD_ADDR_VAR 0 6
72321: PUSH
72322: LD_INT 22
72324: PUSH
72325: LD_VAR 0 1
72329: PPUSH
72330: CALL_OW 255
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PUSH
72339: LD_INT 2
72341: PUSH
72342: LD_INT 30
72344: PUSH
72345: LD_INT 36
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 34
72354: PUSH
72355: LD_INT 31
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: LIST
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PPUSH
72371: CALL_OW 69
72375: ST_TO_ADDR
// if not tmp then
72376: LD_VAR 0 6
72380: NOT
72381: IFFALSE 72385
// exit ;
72383: GO 72633
// result := [ ] ;
72385: LD_ADDR_VAR 0 2
72389: PUSH
72390: EMPTY
72391: ST_TO_ADDR
// for i in tmp do
72392: LD_ADDR_VAR 0 3
72396: PUSH
72397: LD_VAR 0 6
72401: PUSH
72402: FOR_IN
72403: IFFALSE 72474
// begin t := UnitsInside ( i ) ;
72405: LD_ADDR_VAR 0 4
72409: PUSH
72410: LD_VAR 0 3
72414: PPUSH
72415: CALL_OW 313
72419: ST_TO_ADDR
// if t then
72420: LD_VAR 0 4
72424: IFFALSE 72472
// for j in t do
72426: LD_ADDR_VAR 0 7
72430: PUSH
72431: LD_VAR 0 4
72435: PUSH
72436: FOR_IN
72437: IFFALSE 72470
// result := Replace ( result , result + 1 , j ) ;
72439: LD_ADDR_VAR 0 2
72443: PUSH
72444: LD_VAR 0 2
72448: PPUSH
72449: LD_VAR 0 2
72453: PUSH
72454: LD_INT 1
72456: PLUS
72457: PPUSH
72458: LD_VAR 0 7
72462: PPUSH
72463: CALL_OW 1
72467: ST_TO_ADDR
72468: GO 72436
72470: POP
72471: POP
// end ;
72472: GO 72402
72474: POP
72475: POP
// if not result then
72476: LD_VAR 0 2
72480: NOT
72481: IFFALSE 72485
// exit ;
72483: GO 72633
// mech := result [ 1 ] ;
72485: LD_ADDR_VAR 0 5
72489: PUSH
72490: LD_VAR 0 2
72494: PUSH
72495: LD_INT 1
72497: ARRAY
72498: ST_TO_ADDR
// if result > 1 then
72499: LD_VAR 0 2
72503: PUSH
72504: LD_INT 1
72506: GREATER
72507: IFFALSE 72619
// begin for i = 2 to result do
72509: LD_ADDR_VAR 0 3
72513: PUSH
72514: DOUBLE
72515: LD_INT 2
72517: DEC
72518: ST_TO_ADDR
72519: LD_VAR 0 2
72523: PUSH
72524: FOR_TO
72525: IFFALSE 72617
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72527: LD_ADDR_VAR 0 4
72531: PUSH
72532: LD_VAR 0 2
72536: PUSH
72537: LD_VAR 0 3
72541: ARRAY
72542: PPUSH
72543: LD_INT 3
72545: PPUSH
72546: CALL_OW 259
72550: PUSH
72551: LD_VAR 0 2
72555: PUSH
72556: LD_VAR 0 3
72560: ARRAY
72561: PPUSH
72562: CALL_OW 432
72566: MINUS
72567: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72568: LD_VAR 0 4
72572: PUSH
72573: LD_VAR 0 5
72577: PPUSH
72578: LD_INT 3
72580: PPUSH
72581: CALL_OW 259
72585: PUSH
72586: LD_VAR 0 5
72590: PPUSH
72591: CALL_OW 432
72595: MINUS
72596: GREATEREQUAL
72597: IFFALSE 72615
// mech := result [ i ] ;
72599: LD_ADDR_VAR 0 5
72603: PUSH
72604: LD_VAR 0 2
72608: PUSH
72609: LD_VAR 0 3
72613: ARRAY
72614: ST_TO_ADDR
// end ;
72615: GO 72524
72617: POP
72618: POP
// end ; ComLinkTo ( vehicle , mech ) ;
72619: LD_VAR 0 1
72623: PPUSH
72624: LD_VAR 0 5
72628: PPUSH
72629: CALL_OW 135
// end ;
72633: LD_VAR 0 2
72637: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72638: LD_INT 0
72640: PPUSH
72641: PPUSH
72642: PPUSH
72643: PPUSH
72644: PPUSH
72645: PPUSH
72646: PPUSH
72647: PPUSH
72648: PPUSH
72649: PPUSH
72650: PPUSH
72651: PPUSH
72652: PPUSH
// result := [ ] ;
72653: LD_ADDR_VAR 0 7
72657: PUSH
72658: EMPTY
72659: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
72660: LD_VAR 0 1
72664: PPUSH
72665: CALL_OW 266
72669: PUSH
72670: LD_INT 0
72672: PUSH
72673: LD_INT 1
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: IN
72680: NOT
72681: IFFALSE 72685
// exit ;
72683: GO 74319
// if name then
72685: LD_VAR 0 3
72689: IFFALSE 72705
// SetBName ( base_dep , name ) ;
72691: LD_VAR 0 1
72695: PPUSH
72696: LD_VAR 0 3
72700: PPUSH
72701: CALL_OW 500
// base := GetBase ( base_dep ) ;
72705: LD_ADDR_VAR 0 15
72709: PUSH
72710: LD_VAR 0 1
72714: PPUSH
72715: CALL_OW 274
72719: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
72720: LD_ADDR_VAR 0 16
72724: PUSH
72725: LD_VAR 0 1
72729: PPUSH
72730: CALL_OW 255
72734: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
72735: LD_ADDR_VAR 0 17
72739: PUSH
72740: LD_VAR 0 1
72744: PPUSH
72745: CALL_OW 248
72749: ST_TO_ADDR
// if sources then
72750: LD_VAR 0 5
72754: IFFALSE 72801
// for i = 1 to 3 do
72756: LD_ADDR_VAR 0 8
72760: PUSH
72761: DOUBLE
72762: LD_INT 1
72764: DEC
72765: ST_TO_ADDR
72766: LD_INT 3
72768: PUSH
72769: FOR_TO
72770: IFFALSE 72799
// AddResourceType ( base , i , sources [ i ] ) ;
72772: LD_VAR 0 15
72776: PPUSH
72777: LD_VAR 0 8
72781: PPUSH
72782: LD_VAR 0 5
72786: PUSH
72787: LD_VAR 0 8
72791: ARRAY
72792: PPUSH
72793: CALL_OW 276
72797: GO 72769
72799: POP
72800: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
72801: LD_ADDR_VAR 0 18
72805: PUSH
72806: LD_VAR 0 15
72810: PPUSH
72811: LD_VAR 0 2
72815: PPUSH
72816: LD_INT 1
72818: PPUSH
72819: CALL 72062 0 3
72823: ST_TO_ADDR
// InitHc ;
72824: CALL_OW 19
// InitUc ;
72828: CALL_OW 18
// uc_side := side ;
72832: LD_ADDR_OWVAR 20
72836: PUSH
72837: LD_VAR 0 16
72841: ST_TO_ADDR
// uc_nation := nation ;
72842: LD_ADDR_OWVAR 21
72846: PUSH
72847: LD_VAR 0 17
72851: ST_TO_ADDR
// if buildings then
72852: LD_VAR 0 18
72856: IFFALSE 74178
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
72858: LD_ADDR_VAR 0 19
72862: PUSH
72863: LD_VAR 0 18
72867: PPUSH
72868: LD_INT 2
72870: PUSH
72871: LD_INT 30
72873: PUSH
72874: LD_INT 29
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 30
72883: PUSH
72884: LD_INT 30
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: LIST
72895: PPUSH
72896: CALL_OW 72
72900: ST_TO_ADDR
// if tmp then
72901: LD_VAR 0 19
72905: IFFALSE 72953
// for i in tmp do
72907: LD_ADDR_VAR 0 8
72911: PUSH
72912: LD_VAR 0 19
72916: PUSH
72917: FOR_IN
72918: IFFALSE 72951
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
72920: LD_VAR 0 8
72924: PPUSH
72925: CALL_OW 250
72929: PPUSH
72930: LD_VAR 0 8
72934: PPUSH
72935: CALL_OW 251
72939: PPUSH
72940: LD_VAR 0 16
72944: PPUSH
72945: CALL_OW 441
72949: GO 72917
72951: POP
72952: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72953: LD_VAR 0 18
72957: PPUSH
72958: LD_INT 2
72960: PUSH
72961: LD_INT 30
72963: PUSH
72964: LD_INT 32
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 30
72973: PUSH
72974: LD_INT 33
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: LIST
72985: PPUSH
72986: CALL_OW 72
72990: IFFALSE 73078
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72992: LD_ADDR_VAR 0 8
72996: PUSH
72997: LD_VAR 0 18
73001: PPUSH
73002: LD_INT 2
73004: PUSH
73005: LD_INT 30
73007: PUSH
73008: LD_INT 32
73010: PUSH
73011: EMPTY
73012: LIST
73013: LIST
73014: PUSH
73015: LD_INT 30
73017: PUSH
73018: LD_INT 33
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: LIST
73029: PPUSH
73030: CALL_OW 72
73034: PUSH
73035: FOR_IN
73036: IFFALSE 73076
// begin if not GetBWeapon ( i ) then
73038: LD_VAR 0 8
73042: PPUSH
73043: CALL_OW 269
73047: NOT
73048: IFFALSE 73074
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73050: LD_VAR 0 8
73054: PPUSH
73055: LD_VAR 0 8
73059: PPUSH
73060: LD_VAR 0 2
73064: PPUSH
73065: CALL 74324 0 2
73069: PPUSH
73070: CALL_OW 431
// end ;
73074: GO 73035
73076: POP
73077: POP
// end ; for i = 1 to personel do
73078: LD_ADDR_VAR 0 8
73082: PUSH
73083: DOUBLE
73084: LD_INT 1
73086: DEC
73087: ST_TO_ADDR
73088: LD_VAR 0 6
73092: PUSH
73093: FOR_TO
73094: IFFALSE 74158
// begin if i > 4 then
73096: LD_VAR 0 8
73100: PUSH
73101: LD_INT 4
73103: GREATER
73104: IFFALSE 73108
// break ;
73106: GO 74158
// case i of 1 :
73108: LD_VAR 0 8
73112: PUSH
73113: LD_INT 1
73115: DOUBLE
73116: EQUAL
73117: IFTRUE 73121
73119: GO 73201
73121: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73122: LD_ADDR_VAR 0 12
73126: PUSH
73127: LD_VAR 0 18
73131: PPUSH
73132: LD_INT 22
73134: PUSH
73135: LD_VAR 0 16
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 58
73146: PUSH
73147: EMPTY
73148: LIST
73149: PUSH
73150: LD_INT 2
73152: PUSH
73153: LD_INT 30
73155: PUSH
73156: LD_INT 32
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 30
73165: PUSH
73166: LD_INT 4
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 30
73175: PUSH
73176: LD_INT 5
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: LIST
73187: LIST
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: LIST
73193: PPUSH
73194: CALL_OW 72
73198: ST_TO_ADDR
73199: GO 73423
73201: LD_INT 2
73203: DOUBLE
73204: EQUAL
73205: IFTRUE 73209
73207: GO 73271
73209: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73210: LD_ADDR_VAR 0 12
73214: PUSH
73215: LD_VAR 0 18
73219: PPUSH
73220: LD_INT 22
73222: PUSH
73223: LD_VAR 0 16
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 2
73234: PUSH
73235: LD_INT 30
73237: PUSH
73238: LD_INT 0
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 30
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: LIST
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PPUSH
73264: CALL_OW 72
73268: ST_TO_ADDR
73269: GO 73423
73271: LD_INT 3
73273: DOUBLE
73274: EQUAL
73275: IFTRUE 73279
73277: GO 73341
73279: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73280: LD_ADDR_VAR 0 12
73284: PUSH
73285: LD_VAR 0 18
73289: PPUSH
73290: LD_INT 22
73292: PUSH
73293: LD_VAR 0 16
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PUSH
73302: LD_INT 2
73304: PUSH
73305: LD_INT 30
73307: PUSH
73308: LD_INT 2
73310: PUSH
73311: EMPTY
73312: LIST
73313: LIST
73314: PUSH
73315: LD_INT 30
73317: PUSH
73318: LD_INT 3
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: LIST
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PPUSH
73334: CALL_OW 72
73338: ST_TO_ADDR
73339: GO 73423
73341: LD_INT 4
73343: DOUBLE
73344: EQUAL
73345: IFTRUE 73349
73347: GO 73422
73349: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73350: LD_ADDR_VAR 0 12
73354: PUSH
73355: LD_VAR 0 18
73359: PPUSH
73360: LD_INT 22
73362: PUSH
73363: LD_VAR 0 16
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 2
73374: PUSH
73375: LD_INT 30
73377: PUSH
73378: LD_INT 6
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 30
73387: PUSH
73388: LD_INT 7
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 30
73397: PUSH
73398: LD_INT 8
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: LIST
73409: LIST
73410: PUSH
73411: EMPTY
73412: LIST
73413: LIST
73414: PPUSH
73415: CALL_OW 72
73419: ST_TO_ADDR
73420: GO 73423
73422: POP
// if i = 1 then
73423: LD_VAR 0 8
73427: PUSH
73428: LD_INT 1
73430: EQUAL
73431: IFFALSE 73542
// begin tmp := [ ] ;
73433: LD_ADDR_VAR 0 19
73437: PUSH
73438: EMPTY
73439: ST_TO_ADDR
// for j in f do
73440: LD_ADDR_VAR 0 9
73444: PUSH
73445: LD_VAR 0 12
73449: PUSH
73450: FOR_IN
73451: IFFALSE 73524
// if GetBType ( j ) = b_bunker then
73453: LD_VAR 0 9
73457: PPUSH
73458: CALL_OW 266
73462: PUSH
73463: LD_INT 32
73465: EQUAL
73466: IFFALSE 73493
// tmp := Insert ( tmp , 1 , j ) else
73468: LD_ADDR_VAR 0 19
73472: PUSH
73473: LD_VAR 0 19
73477: PPUSH
73478: LD_INT 1
73480: PPUSH
73481: LD_VAR 0 9
73485: PPUSH
73486: CALL_OW 2
73490: ST_TO_ADDR
73491: GO 73522
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73493: LD_ADDR_VAR 0 19
73497: PUSH
73498: LD_VAR 0 19
73502: PPUSH
73503: LD_VAR 0 19
73507: PUSH
73508: LD_INT 1
73510: PLUS
73511: PPUSH
73512: LD_VAR 0 9
73516: PPUSH
73517: CALL_OW 2
73521: ST_TO_ADDR
73522: GO 73450
73524: POP
73525: POP
// if tmp then
73526: LD_VAR 0 19
73530: IFFALSE 73542
// f := tmp ;
73532: LD_ADDR_VAR 0 12
73536: PUSH
73537: LD_VAR 0 19
73541: ST_TO_ADDR
// end ; x := personel [ i ] ;
73542: LD_ADDR_VAR 0 13
73546: PUSH
73547: LD_VAR 0 6
73551: PUSH
73552: LD_VAR 0 8
73556: ARRAY
73557: ST_TO_ADDR
// if x = - 1 then
73558: LD_VAR 0 13
73562: PUSH
73563: LD_INT 1
73565: NEG
73566: EQUAL
73567: IFFALSE 73776
// begin for j in f do
73569: LD_ADDR_VAR 0 9
73573: PUSH
73574: LD_VAR 0 12
73578: PUSH
73579: FOR_IN
73580: IFFALSE 73772
// repeat InitHc ;
73582: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73586: LD_VAR 0 9
73590: PPUSH
73591: CALL_OW 266
73595: PUSH
73596: LD_INT 5
73598: EQUAL
73599: IFFALSE 73669
// begin if UnitsInside ( j ) < 3 then
73601: LD_VAR 0 9
73605: PPUSH
73606: CALL_OW 313
73610: PUSH
73611: LD_INT 3
73613: LESS
73614: IFFALSE 73650
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73616: LD_INT 0
73618: PPUSH
73619: LD_INT 5
73621: PUSH
73622: LD_INT 8
73624: PUSH
73625: LD_INT 9
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: LIST
73632: PUSH
73633: LD_VAR 0 17
73637: ARRAY
73638: PPUSH
73639: LD_VAR 0 4
73643: PPUSH
73644: CALL_OW 380
73648: GO 73667
// PrepareHuman ( false , i , skill ) ;
73650: LD_INT 0
73652: PPUSH
73653: LD_VAR 0 8
73657: PPUSH
73658: LD_VAR 0 4
73662: PPUSH
73663: CALL_OW 380
// end else
73667: GO 73686
// PrepareHuman ( false , i , skill ) ;
73669: LD_INT 0
73671: PPUSH
73672: LD_VAR 0 8
73676: PPUSH
73677: LD_VAR 0 4
73681: PPUSH
73682: CALL_OW 380
// un := CreateHuman ;
73686: LD_ADDR_VAR 0 14
73690: PUSH
73691: CALL_OW 44
73695: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73696: LD_ADDR_VAR 0 7
73700: PUSH
73701: LD_VAR 0 7
73705: PPUSH
73706: LD_INT 1
73708: PPUSH
73709: LD_VAR 0 14
73713: PPUSH
73714: CALL_OW 2
73718: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
73719: LD_VAR 0 14
73723: PPUSH
73724: LD_VAR 0 9
73728: PPUSH
73729: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
73733: LD_VAR 0 9
73737: PPUSH
73738: CALL_OW 313
73742: PUSH
73743: LD_INT 6
73745: EQUAL
73746: PUSH
73747: LD_VAR 0 9
73751: PPUSH
73752: CALL_OW 266
73756: PUSH
73757: LD_INT 32
73759: PUSH
73760: LD_INT 31
73762: PUSH
73763: EMPTY
73764: LIST
73765: LIST
73766: IN
73767: OR
73768: IFFALSE 73582
73770: GO 73579
73772: POP
73773: POP
// end else
73774: GO 74156
// for j = 1 to x do
73776: LD_ADDR_VAR 0 9
73780: PUSH
73781: DOUBLE
73782: LD_INT 1
73784: DEC
73785: ST_TO_ADDR
73786: LD_VAR 0 13
73790: PUSH
73791: FOR_TO
73792: IFFALSE 74154
// begin InitHc ;
73794: CALL_OW 19
// if not f then
73798: LD_VAR 0 12
73802: NOT
73803: IFFALSE 73892
// begin PrepareHuman ( false , i , skill ) ;
73805: LD_INT 0
73807: PPUSH
73808: LD_VAR 0 8
73812: PPUSH
73813: LD_VAR 0 4
73817: PPUSH
73818: CALL_OW 380
// un := CreateHuman ;
73822: LD_ADDR_VAR 0 14
73826: PUSH
73827: CALL_OW 44
73831: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73832: LD_ADDR_VAR 0 7
73836: PUSH
73837: LD_VAR 0 7
73841: PPUSH
73842: LD_INT 1
73844: PPUSH
73845: LD_VAR 0 14
73849: PPUSH
73850: CALL_OW 2
73854: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73855: LD_VAR 0 14
73859: PPUSH
73860: LD_VAR 0 1
73864: PPUSH
73865: CALL_OW 250
73869: PPUSH
73870: LD_VAR 0 1
73874: PPUSH
73875: CALL_OW 251
73879: PPUSH
73880: LD_INT 10
73882: PPUSH
73883: LD_INT 0
73885: PPUSH
73886: CALL_OW 50
// continue ;
73890: GO 73791
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
73892: LD_VAR 0 12
73896: PUSH
73897: LD_INT 1
73899: ARRAY
73900: PPUSH
73901: CALL_OW 313
73905: PUSH
73906: LD_VAR 0 12
73910: PUSH
73911: LD_INT 1
73913: ARRAY
73914: PPUSH
73915: CALL_OW 266
73919: PUSH
73920: LD_INT 32
73922: PUSH
73923: LD_INT 31
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: IN
73930: AND
73931: PUSH
73932: LD_VAR 0 12
73936: PUSH
73937: LD_INT 1
73939: ARRAY
73940: PPUSH
73941: CALL_OW 313
73945: PUSH
73946: LD_INT 6
73948: EQUAL
73949: OR
73950: IFFALSE 73970
// f := Delete ( f , 1 ) ;
73952: LD_ADDR_VAR 0 12
73956: PUSH
73957: LD_VAR 0 12
73961: PPUSH
73962: LD_INT 1
73964: PPUSH
73965: CALL_OW 3
73969: ST_TO_ADDR
// if not f then
73970: LD_VAR 0 12
73974: NOT
73975: IFFALSE 73993
// begin x := x + 2 ;
73977: LD_ADDR_VAR 0 13
73981: PUSH
73982: LD_VAR 0 13
73986: PUSH
73987: LD_INT 2
73989: PLUS
73990: ST_TO_ADDR
// continue ;
73991: GO 73791
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73993: LD_VAR 0 12
73997: PUSH
73998: LD_INT 1
74000: ARRAY
74001: PPUSH
74002: CALL_OW 266
74006: PUSH
74007: LD_INT 5
74009: EQUAL
74010: IFFALSE 74084
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74012: LD_VAR 0 12
74016: PUSH
74017: LD_INT 1
74019: ARRAY
74020: PPUSH
74021: CALL_OW 313
74025: PUSH
74026: LD_INT 3
74028: LESS
74029: IFFALSE 74065
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74031: LD_INT 0
74033: PPUSH
74034: LD_INT 5
74036: PUSH
74037: LD_INT 8
74039: PUSH
74040: LD_INT 9
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: LIST
74047: PUSH
74048: LD_VAR 0 17
74052: ARRAY
74053: PPUSH
74054: LD_VAR 0 4
74058: PPUSH
74059: CALL_OW 380
74063: GO 74082
// PrepareHuman ( false , i , skill ) ;
74065: LD_INT 0
74067: PPUSH
74068: LD_VAR 0 8
74072: PPUSH
74073: LD_VAR 0 4
74077: PPUSH
74078: CALL_OW 380
// end else
74082: GO 74101
// PrepareHuman ( false , i , skill ) ;
74084: LD_INT 0
74086: PPUSH
74087: LD_VAR 0 8
74091: PPUSH
74092: LD_VAR 0 4
74096: PPUSH
74097: CALL_OW 380
// un := CreateHuman ;
74101: LD_ADDR_VAR 0 14
74105: PUSH
74106: CALL_OW 44
74110: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74111: LD_ADDR_VAR 0 7
74115: PUSH
74116: LD_VAR 0 7
74120: PPUSH
74121: LD_INT 1
74123: PPUSH
74124: LD_VAR 0 14
74128: PPUSH
74129: CALL_OW 2
74133: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74134: LD_VAR 0 14
74138: PPUSH
74139: LD_VAR 0 12
74143: PUSH
74144: LD_INT 1
74146: ARRAY
74147: PPUSH
74148: CALL_OW 52
// end ;
74152: GO 73791
74154: POP
74155: POP
// end ;
74156: GO 73093
74158: POP
74159: POP
// result := result ^ buildings ;
74160: LD_ADDR_VAR 0 7
74164: PUSH
74165: LD_VAR 0 7
74169: PUSH
74170: LD_VAR 0 18
74174: ADD
74175: ST_TO_ADDR
// end else
74176: GO 74319
// begin for i = 1 to personel do
74178: LD_ADDR_VAR 0 8
74182: PUSH
74183: DOUBLE
74184: LD_INT 1
74186: DEC
74187: ST_TO_ADDR
74188: LD_VAR 0 6
74192: PUSH
74193: FOR_TO
74194: IFFALSE 74317
// begin if i > 4 then
74196: LD_VAR 0 8
74200: PUSH
74201: LD_INT 4
74203: GREATER
74204: IFFALSE 74208
// break ;
74206: GO 74317
// x := personel [ i ] ;
74208: LD_ADDR_VAR 0 13
74212: PUSH
74213: LD_VAR 0 6
74217: PUSH
74218: LD_VAR 0 8
74222: ARRAY
74223: ST_TO_ADDR
// if x = - 1 then
74224: LD_VAR 0 13
74228: PUSH
74229: LD_INT 1
74231: NEG
74232: EQUAL
74233: IFFALSE 74237
// continue ;
74235: GO 74193
// PrepareHuman ( false , i , skill ) ;
74237: LD_INT 0
74239: PPUSH
74240: LD_VAR 0 8
74244: PPUSH
74245: LD_VAR 0 4
74249: PPUSH
74250: CALL_OW 380
// un := CreateHuman ;
74254: LD_ADDR_VAR 0 14
74258: PUSH
74259: CALL_OW 44
74263: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74264: LD_VAR 0 14
74268: PPUSH
74269: LD_VAR 0 1
74273: PPUSH
74274: CALL_OW 250
74278: PPUSH
74279: LD_VAR 0 1
74283: PPUSH
74284: CALL_OW 251
74288: PPUSH
74289: LD_INT 10
74291: PPUSH
74292: LD_INT 0
74294: PPUSH
74295: CALL_OW 50
// result := result ^ un ;
74299: LD_ADDR_VAR 0 7
74303: PUSH
74304: LD_VAR 0 7
74308: PUSH
74309: LD_VAR 0 14
74313: ADD
74314: ST_TO_ADDR
// end ;
74315: GO 74193
74317: POP
74318: POP
// end ; end ;
74319: LD_VAR 0 7
74323: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74324: LD_INT 0
74326: PPUSH
74327: PPUSH
74328: PPUSH
74329: PPUSH
74330: PPUSH
74331: PPUSH
74332: PPUSH
74333: PPUSH
74334: PPUSH
74335: PPUSH
74336: PPUSH
74337: PPUSH
74338: PPUSH
74339: PPUSH
74340: PPUSH
74341: PPUSH
// result := false ;
74342: LD_ADDR_VAR 0 3
74346: PUSH
74347: LD_INT 0
74349: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74350: LD_VAR 0 1
74354: NOT
74355: PUSH
74356: LD_VAR 0 1
74360: PPUSH
74361: CALL_OW 266
74365: PUSH
74366: LD_INT 32
74368: PUSH
74369: LD_INT 33
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: IN
74376: NOT
74377: OR
74378: IFFALSE 74382
// exit ;
74380: GO 75491
// nat := GetNation ( tower ) ;
74382: LD_ADDR_VAR 0 12
74386: PUSH
74387: LD_VAR 0 1
74391: PPUSH
74392: CALL_OW 248
74396: ST_TO_ADDR
// side := GetSide ( tower ) ;
74397: LD_ADDR_VAR 0 16
74401: PUSH
74402: LD_VAR 0 1
74406: PPUSH
74407: CALL_OW 255
74411: ST_TO_ADDR
// x := GetX ( tower ) ;
74412: LD_ADDR_VAR 0 10
74416: PUSH
74417: LD_VAR 0 1
74421: PPUSH
74422: CALL_OW 250
74426: ST_TO_ADDR
// y := GetY ( tower ) ;
74427: LD_ADDR_VAR 0 11
74431: PUSH
74432: LD_VAR 0 1
74436: PPUSH
74437: CALL_OW 251
74441: ST_TO_ADDR
// if not x or not y then
74442: LD_VAR 0 10
74446: NOT
74447: PUSH
74448: LD_VAR 0 11
74452: NOT
74453: OR
74454: IFFALSE 74458
// exit ;
74456: GO 75491
// weapon := 0 ;
74458: LD_ADDR_VAR 0 18
74462: PUSH
74463: LD_INT 0
74465: ST_TO_ADDR
// fac_list := [ ] ;
74466: LD_ADDR_VAR 0 17
74470: PUSH
74471: EMPTY
74472: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
74473: LD_ADDR_VAR 0 6
74477: PUSH
74478: LD_VAR 0 1
74482: PPUSH
74483: CALL_OW 274
74487: PPUSH
74488: LD_VAR 0 2
74492: PPUSH
74493: LD_INT 0
74495: PPUSH
74496: CALL 72062 0 3
74500: PPUSH
74501: LD_INT 30
74503: PUSH
74504: LD_INT 3
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PPUSH
74511: CALL_OW 72
74515: ST_TO_ADDR
// if not factories then
74516: LD_VAR 0 6
74520: NOT
74521: IFFALSE 74525
// exit ;
74523: GO 75491
// for i in factories do
74525: LD_ADDR_VAR 0 8
74529: PUSH
74530: LD_VAR 0 6
74534: PUSH
74535: FOR_IN
74536: IFFALSE 74561
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74538: LD_ADDR_VAR 0 17
74542: PUSH
74543: LD_VAR 0 17
74547: PUSH
74548: LD_VAR 0 8
74552: PPUSH
74553: CALL_OW 478
74557: UNION
74558: ST_TO_ADDR
74559: GO 74535
74561: POP
74562: POP
// if not fac_list then
74563: LD_VAR 0 17
74567: NOT
74568: IFFALSE 74572
// exit ;
74570: GO 75491
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74572: LD_ADDR_VAR 0 5
74576: PUSH
74577: LD_INT 4
74579: PUSH
74580: LD_INT 5
74582: PUSH
74583: LD_INT 9
74585: PUSH
74586: LD_INT 10
74588: PUSH
74589: LD_INT 6
74591: PUSH
74592: LD_INT 7
74594: PUSH
74595: LD_INT 11
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 27
74609: PUSH
74610: LD_INT 28
74612: PUSH
74613: LD_INT 26
74615: PUSH
74616: LD_INT 30
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 43
74627: PUSH
74628: LD_INT 44
74630: PUSH
74631: LD_INT 46
74633: PUSH
74634: LD_INT 45
74636: PUSH
74637: LD_INT 47
74639: PUSH
74640: LD_INT 49
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: LIST
74647: LIST
74648: LIST
74649: LIST
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: LIST
74655: PUSH
74656: LD_VAR 0 12
74660: ARRAY
74661: ST_TO_ADDR
// list := list isect fac_list ;
74662: LD_ADDR_VAR 0 5
74666: PUSH
74667: LD_VAR 0 5
74671: PUSH
74672: LD_VAR 0 17
74676: ISECT
74677: ST_TO_ADDR
// if not list then
74678: LD_VAR 0 5
74682: NOT
74683: IFFALSE 74687
// exit ;
74685: GO 75491
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
74687: LD_VAR 0 12
74691: PUSH
74692: LD_INT 3
74694: EQUAL
74695: PUSH
74696: LD_INT 49
74698: PUSH
74699: LD_VAR 0 5
74703: IN
74704: AND
74705: PUSH
74706: LD_INT 31
74708: PPUSH
74709: LD_VAR 0 16
74713: PPUSH
74714: CALL_OW 321
74718: PUSH
74719: LD_INT 2
74721: EQUAL
74722: AND
74723: IFFALSE 74783
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
74725: LD_INT 22
74727: PUSH
74728: LD_VAR 0 16
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 35
74739: PUSH
74740: LD_INT 49
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 91
74749: PUSH
74750: LD_VAR 0 1
74754: PUSH
74755: LD_INT 10
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: LIST
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: LIST
74767: PPUSH
74768: CALL_OW 69
74772: NOT
74773: IFFALSE 74783
// weapon := ru_time_lapser ;
74775: LD_ADDR_VAR 0 18
74779: PUSH
74780: LD_INT 49
74782: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
74783: LD_VAR 0 12
74787: PUSH
74788: LD_INT 1
74790: PUSH
74791: LD_INT 2
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: IN
74798: PUSH
74799: LD_INT 11
74801: PUSH
74802: LD_VAR 0 5
74806: IN
74807: PUSH
74808: LD_INT 30
74810: PUSH
74811: LD_VAR 0 5
74815: IN
74816: OR
74817: AND
74818: PUSH
74819: LD_INT 6
74821: PPUSH
74822: LD_VAR 0 16
74826: PPUSH
74827: CALL_OW 321
74831: PUSH
74832: LD_INT 2
74834: EQUAL
74835: AND
74836: IFFALSE 75001
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
74838: LD_INT 22
74840: PUSH
74841: LD_VAR 0 16
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 2
74852: PUSH
74853: LD_INT 35
74855: PUSH
74856: LD_INT 11
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 35
74865: PUSH
74866: LD_INT 30
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 91
74880: PUSH
74881: LD_VAR 0 1
74885: PUSH
74886: LD_INT 18
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: LIST
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: LIST
74898: PPUSH
74899: CALL_OW 69
74903: NOT
74904: PUSH
74905: LD_INT 22
74907: PUSH
74908: LD_VAR 0 16
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 2
74919: PUSH
74920: LD_INT 30
74922: PUSH
74923: LD_INT 32
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 30
74932: PUSH
74933: LD_INT 33
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 91
74947: PUSH
74948: LD_VAR 0 1
74952: PUSH
74953: LD_INT 12
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: LIST
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: LIST
74965: PUSH
74966: EMPTY
74967: LIST
74968: PPUSH
74969: CALL_OW 69
74973: PUSH
74974: LD_INT 2
74976: GREATER
74977: AND
74978: IFFALSE 75001
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74980: LD_ADDR_VAR 0 18
74984: PUSH
74985: LD_INT 11
74987: PUSH
74988: LD_INT 30
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: LD_VAR 0 12
74999: ARRAY
75000: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75001: LD_VAR 0 18
75005: NOT
75006: PUSH
75007: LD_INT 40
75009: PPUSH
75010: LD_VAR 0 16
75014: PPUSH
75015: CALL_OW 321
75019: PUSH
75020: LD_INT 2
75022: EQUAL
75023: AND
75024: PUSH
75025: LD_INT 7
75027: PUSH
75028: LD_VAR 0 5
75032: IN
75033: PUSH
75034: LD_INT 28
75036: PUSH
75037: LD_VAR 0 5
75041: IN
75042: OR
75043: PUSH
75044: LD_INT 45
75046: PUSH
75047: LD_VAR 0 5
75051: IN
75052: OR
75053: AND
75054: IFFALSE 75308
// begin hex := GetHexInfo ( x , y ) ;
75056: LD_ADDR_VAR 0 4
75060: PUSH
75061: LD_VAR 0 10
75065: PPUSH
75066: LD_VAR 0 11
75070: PPUSH
75071: CALL_OW 546
75075: ST_TO_ADDR
// if hex [ 1 ] then
75076: LD_VAR 0 4
75080: PUSH
75081: LD_INT 1
75083: ARRAY
75084: IFFALSE 75088
// exit ;
75086: GO 75491
// height := hex [ 2 ] ;
75088: LD_ADDR_VAR 0 15
75092: PUSH
75093: LD_VAR 0 4
75097: PUSH
75098: LD_INT 2
75100: ARRAY
75101: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75102: LD_ADDR_VAR 0 14
75106: PUSH
75107: LD_INT 0
75109: PUSH
75110: LD_INT 2
75112: PUSH
75113: LD_INT 3
75115: PUSH
75116: LD_INT 5
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: ST_TO_ADDR
// for i in tmp do
75125: LD_ADDR_VAR 0 8
75129: PUSH
75130: LD_VAR 0 14
75134: PUSH
75135: FOR_IN
75136: IFFALSE 75306
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75138: LD_ADDR_VAR 0 9
75142: PUSH
75143: LD_VAR 0 10
75147: PPUSH
75148: LD_VAR 0 8
75152: PPUSH
75153: LD_INT 5
75155: PPUSH
75156: CALL_OW 272
75160: PUSH
75161: LD_VAR 0 11
75165: PPUSH
75166: LD_VAR 0 8
75170: PPUSH
75171: LD_INT 5
75173: PPUSH
75174: CALL_OW 273
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75183: LD_VAR 0 9
75187: PUSH
75188: LD_INT 1
75190: ARRAY
75191: PPUSH
75192: LD_VAR 0 9
75196: PUSH
75197: LD_INT 2
75199: ARRAY
75200: PPUSH
75201: CALL_OW 488
75205: IFFALSE 75304
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75207: LD_ADDR_VAR 0 4
75211: PUSH
75212: LD_VAR 0 9
75216: PUSH
75217: LD_INT 1
75219: ARRAY
75220: PPUSH
75221: LD_VAR 0 9
75225: PUSH
75226: LD_INT 2
75228: ARRAY
75229: PPUSH
75230: CALL_OW 546
75234: ST_TO_ADDR
// if hex [ 1 ] then
75235: LD_VAR 0 4
75239: PUSH
75240: LD_INT 1
75242: ARRAY
75243: IFFALSE 75247
// continue ;
75245: GO 75135
// h := hex [ 2 ] ;
75247: LD_ADDR_VAR 0 13
75251: PUSH
75252: LD_VAR 0 4
75256: PUSH
75257: LD_INT 2
75259: ARRAY
75260: ST_TO_ADDR
// if h + 7 < height then
75261: LD_VAR 0 13
75265: PUSH
75266: LD_INT 7
75268: PLUS
75269: PUSH
75270: LD_VAR 0 15
75274: LESS
75275: IFFALSE 75304
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75277: LD_ADDR_VAR 0 18
75281: PUSH
75282: LD_INT 7
75284: PUSH
75285: LD_INT 28
75287: PUSH
75288: LD_INT 45
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: LIST
75295: PUSH
75296: LD_VAR 0 12
75300: ARRAY
75301: ST_TO_ADDR
// break ;
75302: GO 75306
// end ; end ; end ;
75304: GO 75135
75306: POP
75307: POP
// end ; if not weapon then
75308: LD_VAR 0 18
75312: NOT
75313: IFFALSE 75373
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75315: LD_ADDR_VAR 0 5
75319: PUSH
75320: LD_VAR 0 5
75324: PUSH
75325: LD_INT 11
75327: PUSH
75328: LD_INT 30
75330: PUSH
75331: LD_INT 49
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: LIST
75338: DIFF
75339: ST_TO_ADDR
// if not list then
75340: LD_VAR 0 5
75344: NOT
75345: IFFALSE 75349
// exit ;
75347: GO 75491
// weapon := list [ rand ( 1 , list ) ] ;
75349: LD_ADDR_VAR 0 18
75353: PUSH
75354: LD_VAR 0 5
75358: PUSH
75359: LD_INT 1
75361: PPUSH
75362: LD_VAR 0 5
75366: PPUSH
75367: CALL_OW 12
75371: ARRAY
75372: ST_TO_ADDR
// end ; if weapon then
75373: LD_VAR 0 18
75377: IFFALSE 75491
// begin tmp := CostOfWeapon ( weapon ) ;
75379: LD_ADDR_VAR 0 14
75383: PUSH
75384: LD_VAR 0 18
75388: PPUSH
75389: CALL_OW 451
75393: ST_TO_ADDR
// j := GetBase ( tower ) ;
75394: LD_ADDR_VAR 0 9
75398: PUSH
75399: LD_VAR 0 1
75403: PPUSH
75404: CALL_OW 274
75408: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75409: LD_VAR 0 9
75413: PPUSH
75414: LD_INT 1
75416: PPUSH
75417: CALL_OW 275
75421: PUSH
75422: LD_VAR 0 14
75426: PUSH
75427: LD_INT 1
75429: ARRAY
75430: GREATEREQUAL
75431: PUSH
75432: LD_VAR 0 9
75436: PPUSH
75437: LD_INT 2
75439: PPUSH
75440: CALL_OW 275
75444: PUSH
75445: LD_VAR 0 14
75449: PUSH
75450: LD_INT 2
75452: ARRAY
75453: GREATEREQUAL
75454: AND
75455: PUSH
75456: LD_VAR 0 9
75460: PPUSH
75461: LD_INT 3
75463: PPUSH
75464: CALL_OW 275
75468: PUSH
75469: LD_VAR 0 14
75473: PUSH
75474: LD_INT 3
75476: ARRAY
75477: GREATEREQUAL
75478: AND
75479: IFFALSE 75491
// result := weapon ;
75481: LD_ADDR_VAR 0 3
75485: PUSH
75486: LD_VAR 0 18
75490: ST_TO_ADDR
// end ; end ;
75491: LD_VAR 0 3
75495: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75496: LD_INT 0
75498: PPUSH
75499: PPUSH
// result := true ;
75500: LD_ADDR_VAR 0 3
75504: PUSH
75505: LD_INT 1
75507: ST_TO_ADDR
// if array1 = array2 then
75508: LD_VAR 0 1
75512: PUSH
75513: LD_VAR 0 2
75517: EQUAL
75518: IFFALSE 75578
// begin for i = 1 to array1 do
75520: LD_ADDR_VAR 0 4
75524: PUSH
75525: DOUBLE
75526: LD_INT 1
75528: DEC
75529: ST_TO_ADDR
75530: LD_VAR 0 1
75534: PUSH
75535: FOR_TO
75536: IFFALSE 75574
// if array1 [ i ] <> array2 [ i ] then
75538: LD_VAR 0 1
75542: PUSH
75543: LD_VAR 0 4
75547: ARRAY
75548: PUSH
75549: LD_VAR 0 2
75553: PUSH
75554: LD_VAR 0 4
75558: ARRAY
75559: NONEQUAL
75560: IFFALSE 75572
// begin result := false ;
75562: LD_ADDR_VAR 0 3
75566: PUSH
75567: LD_INT 0
75569: ST_TO_ADDR
// break ;
75570: GO 75574
// end ;
75572: GO 75535
75574: POP
75575: POP
// end else
75576: GO 75586
// result := false ;
75578: LD_ADDR_VAR 0 3
75582: PUSH
75583: LD_INT 0
75585: ST_TO_ADDR
// end ;
75586: LD_VAR 0 3
75590: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
75591: LD_INT 0
75593: PPUSH
75594: PPUSH
// if not array1 or not array2 then
75595: LD_VAR 0 1
75599: NOT
75600: PUSH
75601: LD_VAR 0 2
75605: NOT
75606: OR
75607: IFFALSE 75611
// exit ;
75609: GO 75675
// result := true ;
75611: LD_ADDR_VAR 0 3
75615: PUSH
75616: LD_INT 1
75618: ST_TO_ADDR
// for i = 1 to array1 do
75619: LD_ADDR_VAR 0 4
75623: PUSH
75624: DOUBLE
75625: LD_INT 1
75627: DEC
75628: ST_TO_ADDR
75629: LD_VAR 0 1
75633: PUSH
75634: FOR_TO
75635: IFFALSE 75673
// if array1 [ i ] <> array2 [ i ] then
75637: LD_VAR 0 1
75641: PUSH
75642: LD_VAR 0 4
75646: ARRAY
75647: PUSH
75648: LD_VAR 0 2
75652: PUSH
75653: LD_VAR 0 4
75657: ARRAY
75658: NONEQUAL
75659: IFFALSE 75671
// begin result := false ;
75661: LD_ADDR_VAR 0 3
75665: PUSH
75666: LD_INT 0
75668: ST_TO_ADDR
// break ;
75669: GO 75673
// end ;
75671: GO 75634
75673: POP
75674: POP
// end ;
75675: LD_VAR 0 3
75679: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75680: LD_INT 0
75682: PPUSH
75683: PPUSH
75684: PPUSH
// pom := GetBase ( fac ) ;
75685: LD_ADDR_VAR 0 5
75689: PUSH
75690: LD_VAR 0 1
75694: PPUSH
75695: CALL_OW 274
75699: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75700: LD_ADDR_VAR 0 4
75704: PUSH
75705: LD_VAR 0 2
75709: PUSH
75710: LD_INT 1
75712: ARRAY
75713: PPUSH
75714: LD_VAR 0 2
75718: PUSH
75719: LD_INT 2
75721: ARRAY
75722: PPUSH
75723: LD_VAR 0 2
75727: PUSH
75728: LD_INT 3
75730: ARRAY
75731: PPUSH
75732: LD_VAR 0 2
75736: PUSH
75737: LD_INT 4
75739: ARRAY
75740: PPUSH
75741: CALL_OW 449
75745: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75746: LD_ADDR_VAR 0 3
75750: PUSH
75751: LD_VAR 0 5
75755: PPUSH
75756: LD_INT 1
75758: PPUSH
75759: CALL_OW 275
75763: PUSH
75764: LD_VAR 0 4
75768: PUSH
75769: LD_INT 1
75771: ARRAY
75772: GREATEREQUAL
75773: PUSH
75774: LD_VAR 0 5
75778: PPUSH
75779: LD_INT 2
75781: PPUSH
75782: CALL_OW 275
75786: PUSH
75787: LD_VAR 0 4
75791: PUSH
75792: LD_INT 2
75794: ARRAY
75795: GREATEREQUAL
75796: AND
75797: PUSH
75798: LD_VAR 0 5
75802: PPUSH
75803: LD_INT 3
75805: PPUSH
75806: CALL_OW 275
75810: PUSH
75811: LD_VAR 0 4
75815: PUSH
75816: LD_INT 3
75818: ARRAY
75819: GREATEREQUAL
75820: AND
75821: ST_TO_ADDR
// end ;
75822: LD_VAR 0 3
75826: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
75827: LD_INT 0
75829: PPUSH
75830: PPUSH
75831: PPUSH
75832: PPUSH
// pom := GetBase ( building ) ;
75833: LD_ADDR_VAR 0 3
75837: PUSH
75838: LD_VAR 0 1
75842: PPUSH
75843: CALL_OW 274
75847: ST_TO_ADDR
// if not pom then
75848: LD_VAR 0 3
75852: NOT
75853: IFFALSE 75857
// exit ;
75855: GO 76027
// btype := GetBType ( building ) ;
75857: LD_ADDR_VAR 0 5
75861: PUSH
75862: LD_VAR 0 1
75866: PPUSH
75867: CALL_OW 266
75871: ST_TO_ADDR
// if btype = b_armoury then
75872: LD_VAR 0 5
75876: PUSH
75877: LD_INT 4
75879: EQUAL
75880: IFFALSE 75890
// btype := b_barracks ;
75882: LD_ADDR_VAR 0 5
75886: PUSH
75887: LD_INT 5
75889: ST_TO_ADDR
// if btype = b_depot then
75890: LD_VAR 0 5
75894: PUSH
75895: LD_INT 0
75897: EQUAL
75898: IFFALSE 75908
// btype := b_warehouse ;
75900: LD_ADDR_VAR 0 5
75904: PUSH
75905: LD_INT 1
75907: ST_TO_ADDR
// if btype = b_workshop then
75908: LD_VAR 0 5
75912: PUSH
75913: LD_INT 2
75915: EQUAL
75916: IFFALSE 75926
// btype := b_factory ;
75918: LD_ADDR_VAR 0 5
75922: PUSH
75923: LD_INT 3
75925: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75926: LD_ADDR_VAR 0 4
75930: PUSH
75931: LD_VAR 0 5
75935: PPUSH
75936: LD_VAR 0 1
75940: PPUSH
75941: CALL_OW 248
75945: PPUSH
75946: CALL_OW 450
75950: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75951: LD_ADDR_VAR 0 2
75955: PUSH
75956: LD_VAR 0 3
75960: PPUSH
75961: LD_INT 1
75963: PPUSH
75964: CALL_OW 275
75968: PUSH
75969: LD_VAR 0 4
75973: PUSH
75974: LD_INT 1
75976: ARRAY
75977: GREATEREQUAL
75978: PUSH
75979: LD_VAR 0 3
75983: PPUSH
75984: LD_INT 2
75986: PPUSH
75987: CALL_OW 275
75991: PUSH
75992: LD_VAR 0 4
75996: PUSH
75997: LD_INT 2
75999: ARRAY
76000: GREATEREQUAL
76001: AND
76002: PUSH
76003: LD_VAR 0 3
76007: PPUSH
76008: LD_INT 3
76010: PPUSH
76011: CALL_OW 275
76015: PUSH
76016: LD_VAR 0 4
76020: PUSH
76021: LD_INT 3
76023: ARRAY
76024: GREATEREQUAL
76025: AND
76026: ST_TO_ADDR
// end ;
76027: LD_VAR 0 2
76031: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76032: LD_INT 0
76034: PPUSH
76035: PPUSH
76036: PPUSH
// pom := GetBase ( building ) ;
76037: LD_ADDR_VAR 0 4
76041: PUSH
76042: LD_VAR 0 1
76046: PPUSH
76047: CALL_OW 274
76051: ST_TO_ADDR
// if not pom then
76052: LD_VAR 0 4
76056: NOT
76057: IFFALSE 76061
// exit ;
76059: GO 76162
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76061: LD_ADDR_VAR 0 5
76065: PUSH
76066: LD_VAR 0 2
76070: PPUSH
76071: LD_VAR 0 1
76075: PPUSH
76076: CALL_OW 248
76080: PPUSH
76081: CALL_OW 450
76085: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76086: LD_ADDR_VAR 0 3
76090: PUSH
76091: LD_VAR 0 4
76095: PPUSH
76096: LD_INT 1
76098: PPUSH
76099: CALL_OW 275
76103: PUSH
76104: LD_VAR 0 5
76108: PUSH
76109: LD_INT 1
76111: ARRAY
76112: GREATEREQUAL
76113: PUSH
76114: LD_VAR 0 4
76118: PPUSH
76119: LD_INT 2
76121: PPUSH
76122: CALL_OW 275
76126: PUSH
76127: LD_VAR 0 5
76131: PUSH
76132: LD_INT 2
76134: ARRAY
76135: GREATEREQUAL
76136: AND
76137: PUSH
76138: LD_VAR 0 4
76142: PPUSH
76143: LD_INT 3
76145: PPUSH
76146: CALL_OW 275
76150: PUSH
76151: LD_VAR 0 5
76155: PUSH
76156: LD_INT 3
76158: ARRAY
76159: GREATEREQUAL
76160: AND
76161: ST_TO_ADDR
// end ;
76162: LD_VAR 0 3
76166: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
76167: LD_INT 0
76169: PPUSH
76170: PPUSH
76171: PPUSH
76172: PPUSH
76173: PPUSH
76174: PPUSH
76175: PPUSH
76176: PPUSH
76177: PPUSH
76178: PPUSH
76179: PPUSH
// result := false ;
76180: LD_ADDR_VAR 0 8
76184: PUSH
76185: LD_INT 0
76187: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
76188: LD_VAR 0 5
76192: NOT
76193: PUSH
76194: LD_VAR 0 1
76198: NOT
76199: OR
76200: PUSH
76201: LD_VAR 0 2
76205: NOT
76206: OR
76207: PUSH
76208: LD_VAR 0 3
76212: NOT
76213: OR
76214: IFFALSE 76218
// exit ;
76216: GO 77032
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
76218: LD_ADDR_VAR 0 14
76222: PUSH
76223: LD_VAR 0 1
76227: PPUSH
76228: LD_VAR 0 2
76232: PPUSH
76233: LD_VAR 0 3
76237: PPUSH
76238: LD_VAR 0 4
76242: PPUSH
76243: LD_VAR 0 5
76247: PUSH
76248: LD_INT 1
76250: ARRAY
76251: PPUSH
76252: CALL_OW 248
76256: PPUSH
76257: LD_INT 0
76259: PPUSH
76260: CALL 78285 0 6
76264: ST_TO_ADDR
// if not hexes then
76265: LD_VAR 0 14
76269: NOT
76270: IFFALSE 76274
// exit ;
76272: GO 77032
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76274: LD_ADDR_VAR 0 17
76278: PUSH
76279: LD_VAR 0 5
76283: PPUSH
76284: LD_INT 22
76286: PUSH
76287: LD_VAR 0 13
76291: PPUSH
76292: CALL_OW 255
76296: PUSH
76297: EMPTY
76298: LIST
76299: LIST
76300: PUSH
76301: LD_INT 2
76303: PUSH
76304: LD_INT 30
76306: PUSH
76307: LD_INT 0
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 30
76316: PUSH
76317: LD_INT 1
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: LIST
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PPUSH
76333: CALL_OW 72
76337: ST_TO_ADDR
// for i = 1 to hexes do
76338: LD_ADDR_VAR 0 9
76342: PUSH
76343: DOUBLE
76344: LD_INT 1
76346: DEC
76347: ST_TO_ADDR
76348: LD_VAR 0 14
76352: PUSH
76353: FOR_TO
76354: IFFALSE 77030
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76356: LD_ADDR_VAR 0 13
76360: PUSH
76361: LD_VAR 0 14
76365: PUSH
76366: LD_VAR 0 9
76370: ARRAY
76371: PUSH
76372: LD_INT 1
76374: ARRAY
76375: PPUSH
76376: LD_VAR 0 14
76380: PUSH
76381: LD_VAR 0 9
76385: ARRAY
76386: PUSH
76387: LD_INT 2
76389: ARRAY
76390: PPUSH
76391: CALL_OW 428
76395: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76396: LD_VAR 0 14
76400: PUSH
76401: LD_VAR 0 9
76405: ARRAY
76406: PUSH
76407: LD_INT 1
76409: ARRAY
76410: PPUSH
76411: LD_VAR 0 14
76415: PUSH
76416: LD_VAR 0 9
76420: ARRAY
76421: PUSH
76422: LD_INT 2
76424: ARRAY
76425: PPUSH
76426: CALL_OW 351
76430: PUSH
76431: LD_VAR 0 14
76435: PUSH
76436: LD_VAR 0 9
76440: ARRAY
76441: PUSH
76442: LD_INT 1
76444: ARRAY
76445: PPUSH
76446: LD_VAR 0 14
76450: PUSH
76451: LD_VAR 0 9
76455: ARRAY
76456: PUSH
76457: LD_INT 2
76459: ARRAY
76460: PPUSH
76461: CALL_OW 488
76465: NOT
76466: OR
76467: PUSH
76468: LD_VAR 0 13
76472: PPUSH
76473: CALL_OW 247
76477: PUSH
76478: LD_INT 3
76480: EQUAL
76481: OR
76482: IFFALSE 76488
// exit ;
76484: POP
76485: POP
76486: GO 77032
// if not tmp then
76488: LD_VAR 0 13
76492: NOT
76493: IFFALSE 76497
// continue ;
76495: GO 76353
// result := true ;
76497: LD_ADDR_VAR 0 8
76501: PUSH
76502: LD_INT 1
76504: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
76505: LD_VAR 0 6
76509: PUSH
76510: LD_VAR 0 13
76514: PPUSH
76515: CALL_OW 247
76519: PUSH
76520: LD_INT 2
76522: EQUAL
76523: AND
76524: PUSH
76525: LD_VAR 0 13
76529: PPUSH
76530: CALL_OW 263
76534: PUSH
76535: LD_INT 1
76537: EQUAL
76538: AND
76539: IFFALSE 76703
// begin if IsDrivenBy ( tmp ) then
76541: LD_VAR 0 13
76545: PPUSH
76546: CALL_OW 311
76550: IFFALSE 76554
// continue ;
76552: GO 76353
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
76554: LD_VAR 0 6
76558: PPUSH
76559: LD_INT 3
76561: PUSH
76562: LD_INT 60
76564: PUSH
76565: EMPTY
76566: LIST
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 3
76574: PUSH
76575: LD_INT 55
76577: PUSH
76578: EMPTY
76579: LIST
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PPUSH
76589: CALL_OW 72
76593: IFFALSE 76701
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
76595: LD_ADDR_VAR 0 18
76599: PUSH
76600: LD_VAR 0 6
76604: PPUSH
76605: LD_INT 3
76607: PUSH
76608: LD_INT 60
76610: PUSH
76611: EMPTY
76612: LIST
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 3
76620: PUSH
76621: LD_INT 55
76623: PUSH
76624: EMPTY
76625: LIST
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PPUSH
76635: CALL_OW 72
76639: PUSH
76640: LD_INT 1
76642: ARRAY
76643: ST_TO_ADDR
// if IsInUnit ( driver ) then
76644: LD_VAR 0 18
76648: PPUSH
76649: CALL_OW 310
76653: IFFALSE 76664
// ComExit ( driver ) ;
76655: LD_VAR 0 18
76659: PPUSH
76660: CALL 102066 0 1
// AddComEnterUnit ( driver , tmp ) ;
76664: LD_VAR 0 18
76668: PPUSH
76669: LD_VAR 0 13
76673: PPUSH
76674: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
76678: LD_VAR 0 18
76682: PPUSH
76683: LD_VAR 0 7
76687: PPUSH
76688: CALL_OW 173
// AddComExitVehicle ( driver ) ;
76692: LD_VAR 0 18
76696: PPUSH
76697: CALL_OW 181
// end ; continue ;
76701: GO 76353
// end ; if not cleaners or not tmp in cleaners then
76703: LD_VAR 0 6
76707: NOT
76708: PUSH
76709: LD_VAR 0 13
76713: PUSH
76714: LD_VAR 0 6
76718: IN
76719: NOT
76720: OR
76721: IFFALSE 77028
// begin if dep then
76723: LD_VAR 0 17
76727: IFFALSE 76863
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76729: LD_ADDR_VAR 0 16
76733: PUSH
76734: LD_VAR 0 17
76738: PUSH
76739: LD_INT 1
76741: ARRAY
76742: PPUSH
76743: CALL_OW 250
76747: PPUSH
76748: LD_VAR 0 17
76752: PUSH
76753: LD_INT 1
76755: ARRAY
76756: PPUSH
76757: CALL_OW 254
76761: PPUSH
76762: LD_INT 5
76764: PPUSH
76765: CALL_OW 272
76769: PUSH
76770: LD_VAR 0 17
76774: PUSH
76775: LD_INT 1
76777: ARRAY
76778: PPUSH
76779: CALL_OW 251
76783: PPUSH
76784: LD_VAR 0 17
76788: PUSH
76789: LD_INT 1
76791: ARRAY
76792: PPUSH
76793: CALL_OW 254
76797: PPUSH
76798: LD_INT 5
76800: PPUSH
76801: CALL_OW 273
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76810: LD_VAR 0 16
76814: PUSH
76815: LD_INT 1
76817: ARRAY
76818: PPUSH
76819: LD_VAR 0 16
76823: PUSH
76824: LD_INT 2
76826: ARRAY
76827: PPUSH
76828: CALL_OW 488
76832: IFFALSE 76863
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76834: LD_VAR 0 13
76838: PPUSH
76839: LD_VAR 0 16
76843: PUSH
76844: LD_INT 1
76846: ARRAY
76847: PPUSH
76848: LD_VAR 0 16
76852: PUSH
76853: LD_INT 2
76855: ARRAY
76856: PPUSH
76857: CALL_OW 111
// continue ;
76861: GO 76353
// end ; end ; r := GetDir ( tmp ) ;
76863: LD_ADDR_VAR 0 15
76867: PUSH
76868: LD_VAR 0 13
76872: PPUSH
76873: CALL_OW 254
76877: ST_TO_ADDR
// if r = 5 then
76878: LD_VAR 0 15
76882: PUSH
76883: LD_INT 5
76885: EQUAL
76886: IFFALSE 76896
// r := 0 ;
76888: LD_ADDR_VAR 0 15
76892: PUSH
76893: LD_INT 0
76895: ST_TO_ADDR
// for j = r to 5 do
76896: LD_ADDR_VAR 0 10
76900: PUSH
76901: DOUBLE
76902: LD_VAR 0 15
76906: DEC
76907: ST_TO_ADDR
76908: LD_INT 5
76910: PUSH
76911: FOR_TO
76912: IFFALSE 77026
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76914: LD_ADDR_VAR 0 11
76918: PUSH
76919: LD_VAR 0 13
76923: PPUSH
76924: CALL_OW 250
76928: PPUSH
76929: LD_VAR 0 10
76933: PPUSH
76934: LD_INT 2
76936: PPUSH
76937: CALL_OW 272
76941: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76942: LD_ADDR_VAR 0 12
76946: PUSH
76947: LD_VAR 0 13
76951: PPUSH
76952: CALL_OW 251
76956: PPUSH
76957: LD_VAR 0 10
76961: PPUSH
76962: LD_INT 2
76964: PPUSH
76965: CALL_OW 273
76969: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76970: LD_VAR 0 11
76974: PPUSH
76975: LD_VAR 0 12
76979: PPUSH
76980: CALL_OW 488
76984: PUSH
76985: LD_VAR 0 11
76989: PPUSH
76990: LD_VAR 0 12
76994: PPUSH
76995: CALL_OW 428
76999: NOT
77000: AND
77001: IFFALSE 77024
// begin ComMoveXY ( tmp , _x , _y ) ;
77003: LD_VAR 0 13
77007: PPUSH
77008: LD_VAR 0 11
77012: PPUSH
77013: LD_VAR 0 12
77017: PPUSH
77018: CALL_OW 111
// break ;
77022: GO 77026
// end ; end ;
77024: GO 76911
77026: POP
77027: POP
// end ; end ;
77028: GO 76353
77030: POP
77031: POP
// end ;
77032: LD_VAR 0 8
77036: RET
// export function BuildingTechInvented ( side , btype ) ; begin
77037: LD_INT 0
77039: PPUSH
// result := true ;
77040: LD_ADDR_VAR 0 3
77044: PUSH
77045: LD_INT 1
77047: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
77048: LD_VAR 0 2
77052: PUSH
77053: LD_INT 24
77055: DOUBLE
77056: EQUAL
77057: IFTRUE 77067
77059: LD_INT 33
77061: DOUBLE
77062: EQUAL
77063: IFTRUE 77067
77065: GO 77092
77067: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
77068: LD_ADDR_VAR 0 3
77072: PUSH
77073: LD_INT 32
77075: PPUSH
77076: LD_VAR 0 1
77080: PPUSH
77081: CALL_OW 321
77085: PUSH
77086: LD_INT 2
77088: EQUAL
77089: ST_TO_ADDR
77090: GO 77408
77092: LD_INT 20
77094: DOUBLE
77095: EQUAL
77096: IFTRUE 77100
77098: GO 77125
77100: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
77101: LD_ADDR_VAR 0 3
77105: PUSH
77106: LD_INT 6
77108: PPUSH
77109: LD_VAR 0 1
77113: PPUSH
77114: CALL_OW 321
77118: PUSH
77119: LD_INT 2
77121: EQUAL
77122: ST_TO_ADDR
77123: GO 77408
77125: LD_INT 22
77127: DOUBLE
77128: EQUAL
77129: IFTRUE 77139
77131: LD_INT 36
77133: DOUBLE
77134: EQUAL
77135: IFTRUE 77139
77137: GO 77164
77139: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
77140: LD_ADDR_VAR 0 3
77144: PUSH
77145: LD_INT 15
77147: PPUSH
77148: LD_VAR 0 1
77152: PPUSH
77153: CALL_OW 321
77157: PUSH
77158: LD_INT 2
77160: EQUAL
77161: ST_TO_ADDR
77162: GO 77408
77164: LD_INT 30
77166: DOUBLE
77167: EQUAL
77168: IFTRUE 77172
77170: GO 77197
77172: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
77173: LD_ADDR_VAR 0 3
77177: PUSH
77178: LD_INT 20
77180: PPUSH
77181: LD_VAR 0 1
77185: PPUSH
77186: CALL_OW 321
77190: PUSH
77191: LD_INT 2
77193: EQUAL
77194: ST_TO_ADDR
77195: GO 77408
77197: LD_INT 28
77199: DOUBLE
77200: EQUAL
77201: IFTRUE 77211
77203: LD_INT 21
77205: DOUBLE
77206: EQUAL
77207: IFTRUE 77211
77209: GO 77236
77211: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
77212: LD_ADDR_VAR 0 3
77216: PUSH
77217: LD_INT 21
77219: PPUSH
77220: LD_VAR 0 1
77224: PPUSH
77225: CALL_OW 321
77229: PUSH
77230: LD_INT 2
77232: EQUAL
77233: ST_TO_ADDR
77234: GO 77408
77236: LD_INT 16
77238: DOUBLE
77239: EQUAL
77240: IFTRUE 77244
77242: GO 77269
77244: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
77245: LD_ADDR_VAR 0 3
77249: PUSH
77250: LD_INT 84
77252: PPUSH
77253: LD_VAR 0 1
77257: PPUSH
77258: CALL_OW 321
77262: PUSH
77263: LD_INT 2
77265: EQUAL
77266: ST_TO_ADDR
77267: GO 77408
77269: LD_INT 19
77271: DOUBLE
77272: EQUAL
77273: IFTRUE 77283
77275: LD_INT 23
77277: DOUBLE
77278: EQUAL
77279: IFTRUE 77283
77281: GO 77308
77283: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
77284: LD_ADDR_VAR 0 3
77288: PUSH
77289: LD_INT 83
77291: PPUSH
77292: LD_VAR 0 1
77296: PPUSH
77297: CALL_OW 321
77301: PUSH
77302: LD_INT 2
77304: EQUAL
77305: ST_TO_ADDR
77306: GO 77408
77308: LD_INT 17
77310: DOUBLE
77311: EQUAL
77312: IFTRUE 77316
77314: GO 77341
77316: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
77317: LD_ADDR_VAR 0 3
77321: PUSH
77322: LD_INT 39
77324: PPUSH
77325: LD_VAR 0 1
77329: PPUSH
77330: CALL_OW 321
77334: PUSH
77335: LD_INT 2
77337: EQUAL
77338: ST_TO_ADDR
77339: GO 77408
77341: LD_INT 18
77343: DOUBLE
77344: EQUAL
77345: IFTRUE 77349
77347: GO 77374
77349: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
77350: LD_ADDR_VAR 0 3
77354: PUSH
77355: LD_INT 40
77357: PPUSH
77358: LD_VAR 0 1
77362: PPUSH
77363: CALL_OW 321
77367: PUSH
77368: LD_INT 2
77370: EQUAL
77371: ST_TO_ADDR
77372: GO 77408
77374: LD_INT 27
77376: DOUBLE
77377: EQUAL
77378: IFTRUE 77382
77380: GO 77407
77382: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
77383: LD_ADDR_VAR 0 3
77387: PUSH
77388: LD_INT 35
77390: PPUSH
77391: LD_VAR 0 1
77395: PPUSH
77396: CALL_OW 321
77400: PUSH
77401: LD_INT 2
77403: EQUAL
77404: ST_TO_ADDR
77405: GO 77408
77407: POP
// end ;
77408: LD_VAR 0 3
77412: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
77413: LD_INT 0
77415: PPUSH
77416: PPUSH
77417: PPUSH
77418: PPUSH
77419: PPUSH
77420: PPUSH
77421: PPUSH
77422: PPUSH
77423: PPUSH
77424: PPUSH
77425: PPUSH
// result := false ;
77426: LD_ADDR_VAR 0 6
77430: PUSH
77431: LD_INT 0
77433: ST_TO_ADDR
// if btype = b_depot then
77434: LD_VAR 0 2
77438: PUSH
77439: LD_INT 0
77441: EQUAL
77442: IFFALSE 77454
// begin result := true ;
77444: LD_ADDR_VAR 0 6
77448: PUSH
77449: LD_INT 1
77451: ST_TO_ADDR
// exit ;
77452: GO 78280
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77454: LD_VAR 0 1
77458: NOT
77459: PUSH
77460: LD_VAR 0 1
77464: PPUSH
77465: CALL_OW 266
77469: PUSH
77470: LD_INT 0
77472: PUSH
77473: LD_INT 1
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: IN
77480: NOT
77481: OR
77482: PUSH
77483: LD_VAR 0 2
77487: NOT
77488: OR
77489: PUSH
77490: LD_VAR 0 5
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: LD_INT 2
77503: PUSH
77504: LD_INT 3
77506: PUSH
77507: LD_INT 4
77509: PUSH
77510: LD_INT 5
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: IN
77521: NOT
77522: OR
77523: PUSH
77524: LD_VAR 0 3
77528: PPUSH
77529: LD_VAR 0 4
77533: PPUSH
77534: CALL_OW 488
77538: NOT
77539: OR
77540: IFFALSE 77544
// exit ;
77542: GO 78280
// side := GetSide ( depot ) ;
77544: LD_ADDR_VAR 0 9
77548: PUSH
77549: LD_VAR 0 1
77553: PPUSH
77554: CALL_OW 255
77558: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
77559: LD_VAR 0 9
77563: PPUSH
77564: LD_VAR 0 2
77568: PPUSH
77569: CALL 77037 0 2
77573: NOT
77574: IFFALSE 77578
// exit ;
77576: GO 78280
// pom := GetBase ( depot ) ;
77578: LD_ADDR_VAR 0 10
77582: PUSH
77583: LD_VAR 0 1
77587: PPUSH
77588: CALL_OW 274
77592: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77593: LD_ADDR_VAR 0 11
77597: PUSH
77598: LD_VAR 0 2
77602: PPUSH
77603: LD_VAR 0 1
77607: PPUSH
77608: CALL_OW 248
77612: PPUSH
77613: CALL_OW 450
77617: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77618: LD_VAR 0 10
77622: PPUSH
77623: LD_INT 1
77625: PPUSH
77626: CALL_OW 275
77630: PUSH
77631: LD_VAR 0 11
77635: PUSH
77636: LD_INT 1
77638: ARRAY
77639: GREATEREQUAL
77640: PUSH
77641: LD_VAR 0 10
77645: PPUSH
77646: LD_INT 2
77648: PPUSH
77649: CALL_OW 275
77653: PUSH
77654: LD_VAR 0 11
77658: PUSH
77659: LD_INT 2
77661: ARRAY
77662: GREATEREQUAL
77663: AND
77664: PUSH
77665: LD_VAR 0 10
77669: PPUSH
77670: LD_INT 3
77672: PPUSH
77673: CALL_OW 275
77677: PUSH
77678: LD_VAR 0 11
77682: PUSH
77683: LD_INT 3
77685: ARRAY
77686: GREATEREQUAL
77687: AND
77688: NOT
77689: IFFALSE 77693
// exit ;
77691: GO 78280
// if GetBType ( depot ) = b_depot then
77693: LD_VAR 0 1
77697: PPUSH
77698: CALL_OW 266
77702: PUSH
77703: LD_INT 0
77705: EQUAL
77706: IFFALSE 77718
// dist := 28 else
77708: LD_ADDR_VAR 0 14
77712: PUSH
77713: LD_INT 28
77715: ST_TO_ADDR
77716: GO 77726
// dist := 36 ;
77718: LD_ADDR_VAR 0 14
77722: PUSH
77723: LD_INT 36
77725: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77726: LD_VAR 0 1
77730: PPUSH
77731: LD_VAR 0 3
77735: PPUSH
77736: LD_VAR 0 4
77740: PPUSH
77741: CALL_OW 297
77745: PUSH
77746: LD_VAR 0 14
77750: GREATER
77751: IFFALSE 77755
// exit ;
77753: GO 78280
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77755: LD_ADDR_VAR 0 12
77759: PUSH
77760: LD_VAR 0 2
77764: PPUSH
77765: LD_VAR 0 3
77769: PPUSH
77770: LD_VAR 0 4
77774: PPUSH
77775: LD_VAR 0 5
77779: PPUSH
77780: LD_VAR 0 1
77784: PPUSH
77785: CALL_OW 248
77789: PPUSH
77790: LD_INT 0
77792: PPUSH
77793: CALL 78285 0 6
77797: ST_TO_ADDR
// if not hexes then
77798: LD_VAR 0 12
77802: NOT
77803: IFFALSE 77807
// exit ;
77805: GO 78280
// hex := GetHexInfo ( x , y ) ;
77807: LD_ADDR_VAR 0 15
77811: PUSH
77812: LD_VAR 0 3
77816: PPUSH
77817: LD_VAR 0 4
77821: PPUSH
77822: CALL_OW 546
77826: ST_TO_ADDR
// if hex [ 1 ] then
77827: LD_VAR 0 15
77831: PUSH
77832: LD_INT 1
77834: ARRAY
77835: IFFALSE 77839
// exit ;
77837: GO 78280
// height := hex [ 2 ] ;
77839: LD_ADDR_VAR 0 13
77843: PUSH
77844: LD_VAR 0 15
77848: PUSH
77849: LD_INT 2
77851: ARRAY
77852: ST_TO_ADDR
// for i = 1 to hexes do
77853: LD_ADDR_VAR 0 7
77857: PUSH
77858: DOUBLE
77859: LD_INT 1
77861: DEC
77862: ST_TO_ADDR
77863: LD_VAR 0 12
77867: PUSH
77868: FOR_TO
77869: IFFALSE 78199
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77871: LD_VAR 0 12
77875: PUSH
77876: LD_VAR 0 7
77880: ARRAY
77881: PUSH
77882: LD_INT 1
77884: ARRAY
77885: PPUSH
77886: LD_VAR 0 12
77890: PUSH
77891: LD_VAR 0 7
77895: ARRAY
77896: PUSH
77897: LD_INT 2
77899: ARRAY
77900: PPUSH
77901: CALL_OW 488
77905: NOT
77906: PUSH
77907: LD_VAR 0 12
77911: PUSH
77912: LD_VAR 0 7
77916: ARRAY
77917: PUSH
77918: LD_INT 1
77920: ARRAY
77921: PPUSH
77922: LD_VAR 0 12
77926: PUSH
77927: LD_VAR 0 7
77931: ARRAY
77932: PUSH
77933: LD_INT 2
77935: ARRAY
77936: PPUSH
77937: CALL_OW 428
77941: PUSH
77942: LD_INT 0
77944: GREATER
77945: OR
77946: PUSH
77947: LD_VAR 0 12
77951: PUSH
77952: LD_VAR 0 7
77956: ARRAY
77957: PUSH
77958: LD_INT 1
77960: ARRAY
77961: PPUSH
77962: LD_VAR 0 12
77966: PUSH
77967: LD_VAR 0 7
77971: ARRAY
77972: PUSH
77973: LD_INT 2
77975: ARRAY
77976: PPUSH
77977: CALL_OW 351
77981: OR
77982: IFFALSE 77988
// exit ;
77984: POP
77985: POP
77986: GO 78280
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77988: LD_ADDR_VAR 0 8
77992: PUSH
77993: LD_VAR 0 12
77997: PUSH
77998: LD_VAR 0 7
78002: ARRAY
78003: PUSH
78004: LD_INT 1
78006: ARRAY
78007: PPUSH
78008: LD_VAR 0 12
78012: PUSH
78013: LD_VAR 0 7
78017: ARRAY
78018: PUSH
78019: LD_INT 2
78021: ARRAY
78022: PPUSH
78023: CALL_OW 546
78027: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78028: LD_VAR 0 8
78032: PUSH
78033: LD_INT 1
78035: ARRAY
78036: PUSH
78037: LD_VAR 0 8
78041: PUSH
78042: LD_INT 2
78044: ARRAY
78045: PUSH
78046: LD_VAR 0 13
78050: PUSH
78051: LD_INT 2
78053: PLUS
78054: GREATER
78055: OR
78056: PUSH
78057: LD_VAR 0 8
78061: PUSH
78062: LD_INT 2
78064: ARRAY
78065: PUSH
78066: LD_VAR 0 13
78070: PUSH
78071: LD_INT 2
78073: MINUS
78074: LESS
78075: OR
78076: PUSH
78077: LD_VAR 0 8
78081: PUSH
78082: LD_INT 3
78084: ARRAY
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 8
78091: PUSH
78092: LD_INT 9
78094: PUSH
78095: LD_INT 10
78097: PUSH
78098: LD_INT 11
78100: PUSH
78101: LD_INT 12
78103: PUSH
78104: LD_INT 13
78106: PUSH
78107: LD_INT 16
78109: PUSH
78110: LD_INT 17
78112: PUSH
78113: LD_INT 18
78115: PUSH
78116: LD_INT 19
78118: PUSH
78119: LD_INT 20
78121: PUSH
78122: LD_INT 21
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: IN
78140: NOT
78141: OR
78142: PUSH
78143: LD_VAR 0 8
78147: PUSH
78148: LD_INT 5
78150: ARRAY
78151: NOT
78152: OR
78153: PUSH
78154: LD_VAR 0 8
78158: PUSH
78159: LD_INT 6
78161: ARRAY
78162: PUSH
78163: LD_INT 1
78165: PUSH
78166: LD_INT 2
78168: PUSH
78169: LD_INT 7
78171: PUSH
78172: LD_INT 9
78174: PUSH
78175: LD_INT 10
78177: PUSH
78178: LD_INT 11
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: LIST
78188: IN
78189: NOT
78190: OR
78191: IFFALSE 78197
// exit ;
78193: POP
78194: POP
78195: GO 78280
// end ;
78197: GO 77868
78199: POP
78200: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78201: LD_VAR 0 9
78205: PPUSH
78206: LD_VAR 0 3
78210: PPUSH
78211: LD_VAR 0 4
78215: PPUSH
78216: LD_INT 20
78218: PPUSH
78219: CALL 70203 0 4
78223: PUSH
78224: LD_INT 4
78226: ARRAY
78227: IFFALSE 78231
// exit ;
78229: GO 78280
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78231: LD_VAR 0 2
78235: PUSH
78236: LD_INT 29
78238: PUSH
78239: LD_INT 30
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: IN
78246: PUSH
78247: LD_VAR 0 3
78251: PPUSH
78252: LD_VAR 0 4
78256: PPUSH
78257: LD_VAR 0 9
78261: PPUSH
78262: CALL_OW 440
78266: NOT
78267: AND
78268: IFFALSE 78272
// exit ;
78270: GO 78280
// result := true ;
78272: LD_ADDR_VAR 0 6
78276: PUSH
78277: LD_INT 1
78279: ST_TO_ADDR
// end ;
78280: LD_VAR 0 6
78284: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78285: LD_INT 0
78287: PPUSH
78288: PPUSH
78289: PPUSH
78290: PPUSH
78291: PPUSH
78292: PPUSH
78293: PPUSH
78294: PPUSH
78295: PPUSH
78296: PPUSH
78297: PPUSH
78298: PPUSH
78299: PPUSH
78300: PPUSH
78301: PPUSH
78302: PPUSH
78303: PPUSH
78304: PPUSH
78305: PPUSH
78306: PPUSH
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
78314: PPUSH
78315: PPUSH
78316: PPUSH
78317: PPUSH
78318: PPUSH
78319: PPUSH
78320: PPUSH
78321: PPUSH
78322: PPUSH
78323: PPUSH
78324: PPUSH
78325: PPUSH
78326: PPUSH
78327: PPUSH
78328: PPUSH
78329: PPUSH
78330: PPUSH
78331: PPUSH
78332: PPUSH
78333: PPUSH
78334: PPUSH
78335: PPUSH
78336: PPUSH
78337: PPUSH
78338: PPUSH
78339: PPUSH
78340: PPUSH
78341: PPUSH
78342: PPUSH
78343: PPUSH
78344: PPUSH
// result = [ ] ;
78345: LD_ADDR_VAR 0 7
78349: PUSH
78350: EMPTY
78351: ST_TO_ADDR
// temp_list = [ ] ;
78352: LD_ADDR_VAR 0 9
78356: PUSH
78357: EMPTY
78358: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78359: LD_VAR 0 4
78363: PUSH
78364: LD_INT 0
78366: PUSH
78367: LD_INT 1
78369: PUSH
78370: LD_INT 2
78372: PUSH
78373: LD_INT 3
78375: PUSH
78376: LD_INT 4
78378: PUSH
78379: LD_INT 5
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: LIST
78386: LIST
78387: LIST
78388: LIST
78389: IN
78390: NOT
78391: PUSH
78392: LD_VAR 0 1
78396: PUSH
78397: LD_INT 0
78399: PUSH
78400: LD_INT 1
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: IN
78407: PUSH
78408: LD_VAR 0 5
78412: PUSH
78413: LD_INT 1
78415: PUSH
78416: LD_INT 2
78418: PUSH
78419: LD_INT 3
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: LIST
78426: IN
78427: NOT
78428: AND
78429: OR
78430: IFFALSE 78434
// exit ;
78432: GO 96825
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78434: LD_VAR 0 1
78438: PUSH
78439: LD_INT 6
78441: PUSH
78442: LD_INT 7
78444: PUSH
78445: LD_INT 8
78447: PUSH
78448: LD_INT 13
78450: PUSH
78451: LD_INT 12
78453: PUSH
78454: LD_INT 15
78456: PUSH
78457: LD_INT 11
78459: PUSH
78460: LD_INT 14
78462: PUSH
78463: LD_INT 10
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: LIST
78470: LIST
78471: LIST
78472: LIST
78473: LIST
78474: LIST
78475: LIST
78476: IN
78477: IFFALSE 78487
// btype = b_lab ;
78479: LD_ADDR_VAR 0 1
78483: PUSH
78484: LD_INT 6
78486: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78487: LD_VAR 0 6
78491: PUSH
78492: LD_INT 0
78494: PUSH
78495: LD_INT 1
78497: PUSH
78498: LD_INT 2
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: LIST
78505: IN
78506: NOT
78507: PUSH
78508: LD_VAR 0 1
78512: PUSH
78513: LD_INT 0
78515: PUSH
78516: LD_INT 1
78518: PUSH
78519: LD_INT 2
78521: PUSH
78522: LD_INT 3
78524: PUSH
78525: LD_INT 6
78527: PUSH
78528: LD_INT 36
78530: PUSH
78531: LD_INT 4
78533: PUSH
78534: LD_INT 5
78536: PUSH
78537: LD_INT 31
78539: PUSH
78540: LD_INT 32
78542: PUSH
78543: LD_INT 33
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: IN
78559: NOT
78560: PUSH
78561: LD_VAR 0 6
78565: PUSH
78566: LD_INT 1
78568: EQUAL
78569: AND
78570: OR
78571: PUSH
78572: LD_VAR 0 1
78576: PUSH
78577: LD_INT 2
78579: PUSH
78580: LD_INT 3
78582: PUSH
78583: EMPTY
78584: LIST
78585: LIST
78586: IN
78587: NOT
78588: PUSH
78589: LD_VAR 0 6
78593: PUSH
78594: LD_INT 2
78596: EQUAL
78597: AND
78598: OR
78599: IFFALSE 78609
// mode = 0 ;
78601: LD_ADDR_VAR 0 6
78605: PUSH
78606: LD_INT 0
78608: ST_TO_ADDR
// case mode of 0 :
78609: LD_VAR 0 6
78613: PUSH
78614: LD_INT 0
78616: DOUBLE
78617: EQUAL
78618: IFTRUE 78622
78620: GO 90075
78622: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78623: LD_ADDR_VAR 0 11
78627: PUSH
78628: LD_INT 0
78630: PUSH
78631: LD_INT 0
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 0
78640: PUSH
78641: LD_INT 1
78643: NEG
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 1
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 1
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: LD_INT 1
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 1
78681: NEG
78682: PUSH
78683: LD_INT 0
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: LD_INT 1
78696: NEG
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: LD_INT 2
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 0
78716: PUSH
78717: LD_INT 2
78719: NEG
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 1
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 1
78738: PUSH
78739: LD_INT 2
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 0
78748: PUSH
78749: LD_INT 2
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 1
78758: NEG
78759: PUSH
78760: LD_INT 1
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 1
78769: PUSH
78770: LD_INT 3
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 0
78779: PUSH
78780: LD_INT 3
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 1
78789: NEG
78790: PUSH
78791: LD_INT 2
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78816: LD_ADDR_VAR 0 12
78820: PUSH
78821: LD_INT 0
78823: PUSH
78824: LD_INT 0
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 0
78833: PUSH
78834: LD_INT 1
78836: NEG
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: LD_INT 0
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: LD_INT 1
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 0
78864: PUSH
78865: LD_INT 1
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 1
78874: NEG
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 1
78885: NEG
78886: PUSH
78887: LD_INT 1
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 1
78897: PUSH
78898: LD_INT 1
78900: NEG
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PUSH
78906: LD_INT 2
78908: PUSH
78909: LD_INT 0
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: LD_INT 2
78918: PUSH
78919: LD_INT 1
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 1
78928: NEG
78929: PUSH
78930: LD_INT 1
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 2
78939: NEG
78940: PUSH
78941: LD_INT 0
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 2
78950: NEG
78951: PUSH
78952: LD_INT 1
78954: NEG
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 2
78962: NEG
78963: PUSH
78964: LD_INT 1
78966: PUSH
78967: EMPTY
78968: LIST
78969: LIST
78970: PUSH
78971: LD_INT 3
78973: NEG
78974: PUSH
78975: LD_INT 0
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 3
78984: NEG
78985: PUSH
78986: LD_INT 1
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79012: LD_ADDR_VAR 0 13
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: LD_INT 0
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 0
79029: PUSH
79030: LD_INT 1
79032: NEG
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 0
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 1
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: LD_INT 1
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 1
79070: NEG
79071: PUSH
79072: LD_INT 0
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 1
79081: NEG
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 1
79093: NEG
79094: PUSH
79095: LD_INT 2
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 2
79105: PUSH
79106: LD_INT 1
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 2
79115: PUSH
79116: LD_INT 2
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: LD_INT 1
79125: PUSH
79126: LD_INT 2
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 2
79135: NEG
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 2
79147: NEG
79148: PUSH
79149: LD_INT 2
79151: NEG
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 2
79159: NEG
79160: PUSH
79161: LD_INT 3
79163: NEG
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 3
79171: NEG
79172: PUSH
79173: LD_INT 2
79175: NEG
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 3
79183: NEG
79184: PUSH
79185: LD_INT 3
79187: NEG
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: LIST
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79211: LD_ADDR_VAR 0 14
79215: PUSH
79216: LD_INT 0
79218: PUSH
79219: LD_INT 0
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 0
79228: PUSH
79229: LD_INT 1
79231: NEG
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 1
79239: PUSH
79240: LD_INT 0
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 1
79249: PUSH
79250: LD_INT 1
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 0
79259: PUSH
79260: LD_INT 1
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 1
79269: NEG
79270: PUSH
79271: LD_INT 0
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: NEG
79281: PUSH
79282: LD_INT 1
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 1
79292: NEG
79293: PUSH
79294: LD_INT 2
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 0
79304: PUSH
79305: LD_INT 2
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 1
79315: PUSH
79316: LD_INT 1
79318: NEG
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: PUSH
79324: LD_INT 1
79326: PUSH
79327: LD_INT 2
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 0
79336: PUSH
79337: LD_INT 2
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 1
79346: NEG
79347: PUSH
79348: LD_INT 1
79350: PUSH
79351: EMPTY
79352: LIST
79353: LIST
79354: PUSH
79355: LD_INT 1
79357: NEG
79358: PUSH
79359: LD_INT 3
79361: NEG
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: LD_INT 3
79372: NEG
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 1
79380: PUSH
79381: LD_INT 2
79383: NEG
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79407: LD_ADDR_VAR 0 15
79411: PUSH
79412: LD_INT 0
79414: PUSH
79415: LD_INT 0
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 0
79424: PUSH
79425: LD_INT 1
79427: NEG
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 1
79435: PUSH
79436: LD_INT 0
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: LD_INT 1
79445: PUSH
79446: LD_INT 1
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 0
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 1
79465: NEG
79466: PUSH
79467: LD_INT 0
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 1
79476: NEG
79477: PUSH
79478: LD_INT 1
79480: NEG
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 1
79488: PUSH
79489: LD_INT 1
79491: NEG
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: LD_INT 0
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 2
79509: PUSH
79510: LD_INT 1
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 1
79519: NEG
79520: PUSH
79521: LD_INT 1
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 2
79530: NEG
79531: PUSH
79532: LD_INT 0
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_INT 2
79541: NEG
79542: PUSH
79543: LD_INT 1
79545: NEG
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 2
79553: PUSH
79554: LD_INT 1
79556: NEG
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 3
79564: PUSH
79565: LD_INT 0
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 3
79574: PUSH
79575: LD_INT 1
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: LIST
79586: LIST
79587: LIST
79588: LIST
79589: LIST
79590: LIST
79591: LIST
79592: LIST
79593: LIST
79594: LIST
79595: LIST
79596: LIST
79597: LIST
79598: LIST
79599: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79600: LD_ADDR_VAR 0 16
79604: PUSH
79605: LD_INT 0
79607: PUSH
79608: LD_INT 0
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: LD_INT 0
79617: PUSH
79618: LD_INT 1
79620: NEG
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 1
79628: PUSH
79629: LD_INT 0
79631: PUSH
79632: EMPTY
79633: LIST
79634: LIST
79635: PUSH
79636: LD_INT 1
79638: PUSH
79639: LD_INT 1
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 0
79648: PUSH
79649: LD_INT 1
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 1
79658: NEG
79659: PUSH
79660: LD_INT 0
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 1
79669: NEG
79670: PUSH
79671: LD_INT 1
79673: NEG
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 1
79681: NEG
79682: PUSH
79683: LD_INT 2
79685: NEG
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 2
79693: PUSH
79694: LD_INT 1
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 2
79703: PUSH
79704: LD_INT 2
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 1
79713: PUSH
79714: LD_INT 2
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PUSH
79721: LD_INT 2
79723: NEG
79724: PUSH
79725: LD_INT 1
79727: NEG
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 2
79735: NEG
79736: PUSH
79737: LD_INT 2
79739: NEG
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 3
79747: PUSH
79748: LD_INT 2
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 3
79757: PUSH
79758: LD_INT 3
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 2
79767: PUSH
79768: LD_INT 3
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79793: LD_ADDR_VAR 0 17
79797: PUSH
79798: LD_INT 0
79800: PUSH
79801: LD_INT 0
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 0
79810: PUSH
79811: LD_INT 1
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 1
79831: PUSH
79832: LD_INT 1
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 0
79841: PUSH
79842: LD_INT 1
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 1
79851: NEG
79852: PUSH
79853: LD_INT 0
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 1
79862: NEG
79863: PUSH
79864: LD_INT 1
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 1
79874: NEG
79875: PUSH
79876: LD_INT 2
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 0
79886: PUSH
79887: LD_INT 2
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 1
79897: PUSH
79898: LD_INT 1
79900: NEG
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 2
79908: PUSH
79909: LD_INT 0
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 2
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 2
79928: PUSH
79929: LD_INT 2
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 1
79938: PUSH
79939: LD_INT 2
79941: PUSH
79942: EMPTY
79943: LIST
79944: LIST
79945: PUSH
79946: LD_INT 0
79948: PUSH
79949: LD_INT 2
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: NEG
79959: PUSH
79960: LD_INT 1
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 2
79969: NEG
79970: PUSH
79971: LD_INT 0
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 2
79980: NEG
79981: PUSH
79982: LD_INT 1
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 2
79992: NEG
79993: PUSH
79994: LD_INT 2
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80023: LD_ADDR_VAR 0 18
80027: PUSH
80028: LD_INT 0
80030: PUSH
80031: LD_INT 0
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 0
80040: PUSH
80041: LD_INT 1
80043: NEG
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: LD_INT 0
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 1
80061: PUSH
80062: LD_INT 1
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 0
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 1
80081: NEG
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 1
80092: NEG
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 1
80104: NEG
80105: PUSH
80106: LD_INT 2
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 0
80116: PUSH
80117: LD_INT 2
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 1
80127: PUSH
80128: LD_INT 1
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 2
80138: PUSH
80139: LD_INT 0
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 2
80148: PUSH
80149: LD_INT 1
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 2
80158: PUSH
80159: LD_INT 2
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: PUSH
80166: LD_INT 1
80168: PUSH
80169: LD_INT 2
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 0
80178: PUSH
80179: LD_INT 2
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 1
80188: NEG
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 2
80199: NEG
80200: PUSH
80201: LD_INT 0
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 2
80210: NEG
80211: PUSH
80212: LD_INT 1
80214: NEG
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 2
80222: NEG
80223: PUSH
80224: LD_INT 2
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: LIST
80240: LIST
80241: LIST
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: LIST
80250: LIST
80251: LIST
80252: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80253: LD_ADDR_VAR 0 19
80257: PUSH
80258: LD_INT 0
80260: PUSH
80261: LD_INT 0
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 0
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 1
80281: PUSH
80282: LD_INT 0
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: LD_INT 1
80294: PUSH
80295: EMPTY
80296: LIST
80297: LIST
80298: PUSH
80299: LD_INT 0
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: PUSH
80309: LD_INT 1
80311: NEG
80312: PUSH
80313: LD_INT 0
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 1
80322: NEG
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 1
80334: NEG
80335: PUSH
80336: LD_INT 2
80338: NEG
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 0
80346: PUSH
80347: LD_INT 2
80349: NEG
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 1
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 2
80368: PUSH
80369: LD_INT 0
80371: PUSH
80372: EMPTY
80373: LIST
80374: LIST
80375: PUSH
80376: LD_INT 2
80378: PUSH
80379: LD_INT 1
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 2
80388: PUSH
80389: LD_INT 2
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PUSH
80396: LD_INT 1
80398: PUSH
80399: LD_INT 2
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 0
80408: PUSH
80409: LD_INT 2
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: NEG
80419: PUSH
80420: LD_INT 1
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: LD_INT 2
80429: NEG
80430: PUSH
80431: LD_INT 0
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 2
80440: NEG
80441: PUSH
80442: LD_INT 1
80444: NEG
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 2
80452: NEG
80453: PUSH
80454: LD_INT 2
80456: NEG
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80483: LD_ADDR_VAR 0 20
80487: PUSH
80488: LD_INT 0
80490: PUSH
80491: LD_INT 0
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 0
80500: PUSH
80501: LD_INT 1
80503: NEG
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 1
80511: PUSH
80512: LD_INT 0
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 1
80521: PUSH
80522: LD_INT 1
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 0
80531: PUSH
80532: LD_INT 1
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: NEG
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 1
80552: NEG
80553: PUSH
80554: LD_INT 1
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 1
80564: NEG
80565: PUSH
80566: LD_INT 2
80568: NEG
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: LD_INT 2
80579: NEG
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 1
80587: PUSH
80588: LD_INT 1
80590: NEG
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 2
80598: PUSH
80599: LD_INT 0
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 2
80608: PUSH
80609: LD_INT 1
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PUSH
80616: LD_INT 2
80618: PUSH
80619: LD_INT 2
80621: PUSH
80622: EMPTY
80623: LIST
80624: LIST
80625: PUSH
80626: LD_INT 1
80628: PUSH
80629: LD_INT 2
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 0
80638: PUSH
80639: LD_INT 2
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: LD_INT 1
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: LD_INT 0
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 2
80670: NEG
80671: PUSH
80672: LD_INT 1
80674: NEG
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 2
80682: NEG
80683: PUSH
80684: LD_INT 2
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80713: LD_ADDR_VAR 0 21
80717: PUSH
80718: LD_INT 0
80720: PUSH
80721: LD_INT 0
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 0
80730: PUSH
80731: LD_INT 1
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 1
80741: PUSH
80742: LD_INT 0
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: PUSH
80749: LD_INT 1
80751: PUSH
80752: LD_INT 1
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: PUSH
80759: LD_INT 0
80761: PUSH
80762: LD_INT 1
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 1
80771: NEG
80772: PUSH
80773: LD_INT 0
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 1
80782: NEG
80783: PUSH
80784: LD_INT 1
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 1
80794: NEG
80795: PUSH
80796: LD_INT 2
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 0
80806: PUSH
80807: LD_INT 2
80809: NEG
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 1
80817: PUSH
80818: LD_INT 1
80820: NEG
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 2
80828: PUSH
80829: LD_INT 0
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 2
80838: PUSH
80839: LD_INT 1
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 2
80848: PUSH
80849: LD_INT 2
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 1
80858: PUSH
80859: LD_INT 2
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 0
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 1
80878: NEG
80879: PUSH
80880: LD_INT 1
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 2
80889: NEG
80890: PUSH
80891: LD_INT 0
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 2
80900: NEG
80901: PUSH
80902: LD_INT 1
80904: NEG
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 2
80912: NEG
80913: PUSH
80914: LD_INT 2
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80943: LD_ADDR_VAR 0 22
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: LD_INT 0
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 0
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 1
80971: PUSH
80972: LD_INT 0
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: LD_INT 1
80984: PUSH
80985: EMPTY
80986: LIST
80987: LIST
80988: PUSH
80989: LD_INT 0
80991: PUSH
80992: LD_INT 1
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 1
81001: NEG
81002: PUSH
81003: LD_INT 0
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 1
81012: NEG
81013: PUSH
81014: LD_INT 1
81016: NEG
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 1
81024: NEG
81025: PUSH
81026: LD_INT 2
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 0
81036: PUSH
81037: LD_INT 2
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 1
81047: PUSH
81048: LD_INT 1
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 2
81058: PUSH
81059: LD_INT 0
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 2
81068: PUSH
81069: LD_INT 1
81071: PUSH
81072: EMPTY
81073: LIST
81074: LIST
81075: PUSH
81076: LD_INT 2
81078: PUSH
81079: LD_INT 2
81081: PUSH
81082: EMPTY
81083: LIST
81084: LIST
81085: PUSH
81086: LD_INT 1
81088: PUSH
81089: LD_INT 2
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 0
81098: PUSH
81099: LD_INT 2
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 1
81108: NEG
81109: PUSH
81110: LD_INT 1
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 2
81119: NEG
81120: PUSH
81121: LD_INT 0
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 2
81130: NEG
81131: PUSH
81132: LD_INT 1
81134: NEG
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 2
81142: NEG
81143: PUSH
81144: LD_INT 2
81146: NEG
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81173: LD_ADDR_VAR 0 23
81177: PUSH
81178: LD_INT 0
81180: PUSH
81181: LD_INT 0
81183: PUSH
81184: EMPTY
81185: LIST
81186: LIST
81187: PUSH
81188: LD_INT 0
81190: PUSH
81191: LD_INT 1
81193: NEG
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 1
81201: PUSH
81202: LD_INT 0
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 1
81211: PUSH
81212: LD_INT 1
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 0
81221: PUSH
81222: LD_INT 1
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 1
81231: NEG
81232: PUSH
81233: LD_INT 0
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 1
81242: NEG
81243: PUSH
81244: LD_INT 1
81246: NEG
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 1
81254: NEG
81255: PUSH
81256: LD_INT 2
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 0
81266: PUSH
81267: LD_INT 2
81269: NEG
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 1
81277: PUSH
81278: LD_INT 1
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 2
81288: PUSH
81289: LD_INT 0
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 2
81298: PUSH
81299: LD_INT 1
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: PUSH
81309: LD_INT 2
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 1
81318: PUSH
81319: LD_INT 2
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 0
81328: PUSH
81329: LD_INT 2
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 1
81338: NEG
81339: PUSH
81340: LD_INT 1
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 2
81349: NEG
81350: PUSH
81351: LD_INT 0
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: LD_INT 2
81360: NEG
81361: PUSH
81362: LD_INT 1
81364: NEG
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 2
81372: NEG
81373: PUSH
81374: LD_INT 2
81376: NEG
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 2
81384: NEG
81385: PUSH
81386: LD_INT 3
81388: NEG
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 1
81396: NEG
81397: PUSH
81398: LD_INT 3
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 1
81408: PUSH
81409: LD_INT 2
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 2
81419: PUSH
81420: LD_INT 1
81422: NEG
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: LIST
81432: LIST
81433: LIST
81434: LIST
81435: LIST
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81453: LD_ADDR_VAR 0 24
81457: PUSH
81458: LD_INT 0
81460: PUSH
81461: LD_INT 0
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 0
81470: PUSH
81471: LD_INT 1
81473: NEG
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 1
81481: PUSH
81482: LD_INT 0
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: PUSH
81489: LD_INT 1
81491: PUSH
81492: LD_INT 1
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 0
81501: PUSH
81502: LD_INT 1
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 1
81511: NEG
81512: PUSH
81513: LD_INT 0
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 1
81522: NEG
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 1
81534: NEG
81535: PUSH
81536: LD_INT 2
81538: NEG
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 0
81546: PUSH
81547: LD_INT 2
81549: NEG
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 1
81557: PUSH
81558: LD_INT 1
81560: NEG
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 2
81568: PUSH
81569: LD_INT 0
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PUSH
81576: LD_INT 2
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 2
81588: PUSH
81589: LD_INT 2
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 1
81598: PUSH
81599: LD_INT 2
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: LD_INT 2
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 1
81618: NEG
81619: PUSH
81620: LD_INT 1
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 2
81629: NEG
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 2
81640: NEG
81641: PUSH
81642: LD_INT 1
81644: NEG
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 2
81652: NEG
81653: PUSH
81654: LD_INT 2
81656: NEG
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PUSH
81662: LD_INT 1
81664: PUSH
81665: LD_INT 2
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: LD_INT 2
81675: PUSH
81676: LD_INT 1
81678: NEG
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 3
81686: PUSH
81687: LD_INT 1
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 3
81696: PUSH
81697: LD_INT 2
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: LIST
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81729: LD_ADDR_VAR 0 25
81733: PUSH
81734: LD_INT 0
81736: PUSH
81737: LD_INT 0
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PUSH
81744: LD_INT 0
81746: PUSH
81747: LD_INT 1
81749: NEG
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 1
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 1
81767: PUSH
81768: LD_INT 1
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 0
81777: PUSH
81778: LD_INT 1
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: NEG
81788: PUSH
81789: LD_INT 0
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 1
81798: NEG
81799: PUSH
81800: LD_INT 1
81802: NEG
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 1
81810: NEG
81811: PUSH
81812: LD_INT 2
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 0
81822: PUSH
81823: LD_INT 2
81825: NEG
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 1
81833: PUSH
81834: LD_INT 1
81836: NEG
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 2
81844: PUSH
81845: LD_INT 0
81847: PUSH
81848: EMPTY
81849: LIST
81850: LIST
81851: PUSH
81852: LD_INT 2
81854: PUSH
81855: LD_INT 1
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: LD_INT 2
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 1
81874: PUSH
81875: LD_INT 2
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 0
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: NEG
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 2
81905: NEG
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 2
81916: NEG
81917: PUSH
81918: LD_INT 1
81920: NEG
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 2
81928: NEG
81929: PUSH
81930: LD_INT 2
81932: NEG
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 3
81940: PUSH
81941: LD_INT 1
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 3
81950: PUSH
81951: LD_INT 2
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 2
81960: PUSH
81961: LD_INT 3
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 1
81970: PUSH
81971: LD_INT 3
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82003: LD_ADDR_VAR 0 26
82007: PUSH
82008: LD_INT 0
82010: PUSH
82011: LD_INT 0
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PUSH
82018: LD_INT 0
82020: PUSH
82021: LD_INT 1
82023: NEG
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: LD_INT 1
82031: PUSH
82032: LD_INT 0
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 1
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 0
82051: PUSH
82052: LD_INT 1
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 1
82061: NEG
82062: PUSH
82063: LD_INT 0
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 1
82072: NEG
82073: PUSH
82074: LD_INT 1
82076: NEG
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 1
82084: NEG
82085: PUSH
82086: LD_INT 2
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 0
82096: PUSH
82097: LD_INT 2
82099: NEG
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: LD_INT 1
82107: PUSH
82108: LD_INT 1
82110: NEG
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 2
82118: PUSH
82119: LD_INT 0
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 2
82128: PUSH
82129: LD_INT 1
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: PUSH
82136: LD_INT 2
82138: PUSH
82139: LD_INT 2
82141: PUSH
82142: EMPTY
82143: LIST
82144: LIST
82145: PUSH
82146: LD_INT 1
82148: PUSH
82149: LD_INT 2
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 0
82158: PUSH
82159: LD_INT 2
82161: PUSH
82162: EMPTY
82163: LIST
82164: LIST
82165: PUSH
82166: LD_INT 1
82168: NEG
82169: PUSH
82170: LD_INT 1
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 2
82179: NEG
82180: PUSH
82181: LD_INT 0
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 2
82190: NEG
82191: PUSH
82192: LD_INT 1
82194: NEG
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 2
82202: NEG
82203: PUSH
82204: LD_INT 2
82206: NEG
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 2
82214: PUSH
82215: LD_INT 3
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 1
82224: PUSH
82225: LD_INT 3
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 1
82234: NEG
82235: PUSH
82236: LD_INT 2
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 2
82245: NEG
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82279: LD_ADDR_VAR 0 27
82283: PUSH
82284: LD_INT 0
82286: PUSH
82287: LD_INT 0
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 0
82296: PUSH
82297: LD_INT 1
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: LD_INT 1
82307: PUSH
82308: LD_INT 0
82310: PUSH
82311: EMPTY
82312: LIST
82313: LIST
82314: PUSH
82315: LD_INT 1
82317: PUSH
82318: LD_INT 1
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 0
82327: PUSH
82328: LD_INT 1
82330: PUSH
82331: EMPTY
82332: LIST
82333: LIST
82334: PUSH
82335: LD_INT 1
82337: NEG
82338: PUSH
82339: LD_INT 0
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: LD_INT 1
82348: NEG
82349: PUSH
82350: LD_INT 1
82352: NEG
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 1
82360: NEG
82361: PUSH
82362: LD_INT 2
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: LD_INT 2
82375: NEG
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 1
82383: PUSH
82384: LD_INT 1
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 2
82394: PUSH
82395: LD_INT 0
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: PUSH
82402: LD_INT 2
82404: PUSH
82405: LD_INT 1
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 2
82414: PUSH
82415: LD_INT 2
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 1
82424: PUSH
82425: LD_INT 2
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: LD_INT 2
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 1
82444: NEG
82445: PUSH
82446: LD_INT 1
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: LD_INT 2
82455: NEG
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 2
82466: NEG
82467: PUSH
82468: LD_INT 1
82470: NEG
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: NEG
82479: PUSH
82480: LD_INT 2
82482: NEG
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 1
82490: NEG
82491: PUSH
82492: LD_INT 2
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 2
82501: NEG
82502: PUSH
82503: LD_INT 1
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 3
82512: NEG
82513: PUSH
82514: LD_INT 1
82516: NEG
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 3
82524: NEG
82525: PUSH
82526: LD_INT 2
82528: NEG
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82559: LD_ADDR_VAR 0 28
82563: PUSH
82564: LD_INT 0
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 0
82576: PUSH
82577: LD_INT 1
82579: NEG
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 1
82587: PUSH
82588: LD_INT 0
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 1
82597: PUSH
82598: LD_INT 1
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 0
82607: PUSH
82608: LD_INT 1
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 1
82617: NEG
82618: PUSH
82619: LD_INT 0
82621: PUSH
82622: EMPTY
82623: LIST
82624: LIST
82625: PUSH
82626: LD_INT 1
82628: NEG
82629: PUSH
82630: LD_INT 1
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: NEG
82641: PUSH
82642: LD_INT 2
82644: NEG
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: LD_INT 2
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: LD_INT 1
82666: NEG
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 2
82674: PUSH
82675: LD_INT 0
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 2
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 2
82694: PUSH
82695: LD_INT 2
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 1
82704: PUSH
82705: LD_INT 2
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 0
82714: PUSH
82715: LD_INT 2
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 1
82724: NEG
82725: PUSH
82726: LD_INT 1
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 2
82735: NEG
82736: PUSH
82737: LD_INT 0
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 2
82746: NEG
82747: PUSH
82748: LD_INT 1
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 2
82758: NEG
82759: PUSH
82760: LD_INT 2
82762: NEG
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: PUSH
82768: LD_INT 2
82770: NEG
82771: PUSH
82772: LD_INT 3
82774: NEG
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 1
82782: NEG
82783: PUSH
82784: LD_INT 3
82786: NEG
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 3
82794: NEG
82795: PUSH
82796: LD_INT 1
82798: NEG
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 3
82806: NEG
82807: PUSH
82808: LD_INT 2
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82841: LD_ADDR_VAR 0 29
82845: PUSH
82846: LD_INT 0
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 0
82858: PUSH
82859: LD_INT 1
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 1
82869: PUSH
82870: LD_INT 0
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 1
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 0
82889: PUSH
82890: LD_INT 1
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 1
82899: NEG
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: LD_INT 1
82914: NEG
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 1
82922: NEG
82923: PUSH
82924: LD_INT 2
82926: NEG
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: LD_INT 2
82937: NEG
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 1
82945: PUSH
82946: LD_INT 1
82948: NEG
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 2
82956: PUSH
82957: LD_INT 0
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: PUSH
82964: LD_INT 2
82966: PUSH
82967: LD_INT 1
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 1
82976: PUSH
82977: LD_INT 2
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: LD_INT 2
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 1
82996: NEG
82997: PUSH
82998: LD_INT 1
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: LD_INT 2
83007: NEG
83008: PUSH
83009: LD_INT 1
83011: NEG
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 2
83019: NEG
83020: PUSH
83021: LD_INT 2
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: LD_INT 3
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 2
83043: PUSH
83044: LD_INT 1
83046: NEG
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 3
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 1
83064: PUSH
83065: LD_INT 3
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 1
83074: NEG
83075: PUSH
83076: LD_INT 2
83078: PUSH
83079: EMPTY
83080: LIST
83081: LIST
83082: PUSH
83083: LD_INT 3
83085: NEG
83086: PUSH
83087: LD_INT 2
83089: NEG
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83120: LD_ADDR_VAR 0 30
83124: PUSH
83125: LD_INT 0
83127: PUSH
83128: LD_INT 0
83130: PUSH
83131: EMPTY
83132: LIST
83133: LIST
83134: PUSH
83135: LD_INT 0
83137: PUSH
83138: LD_INT 1
83140: NEG
83141: PUSH
83142: EMPTY
83143: LIST
83144: LIST
83145: PUSH
83146: LD_INT 1
83148: PUSH
83149: LD_INT 0
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 1
83158: PUSH
83159: LD_INT 1
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: LD_INT 1
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: PUSH
83176: LD_INT 1
83178: NEG
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 1
83189: NEG
83190: PUSH
83191: LD_INT 1
83193: NEG
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: LD_INT 2
83205: NEG
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: LD_INT 2
83216: NEG
83217: PUSH
83218: EMPTY
83219: LIST
83220: LIST
83221: PUSH
83222: LD_INT 1
83224: PUSH
83225: LD_INT 1
83227: NEG
83228: PUSH
83229: EMPTY
83230: LIST
83231: LIST
83232: PUSH
83233: LD_INT 2
83235: PUSH
83236: LD_INT 0
83238: PUSH
83239: EMPTY
83240: LIST
83241: LIST
83242: PUSH
83243: LD_INT 2
83245: PUSH
83246: LD_INT 1
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 2
83255: PUSH
83256: LD_INT 2
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 1
83265: PUSH
83266: LD_INT 2
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 1
83275: NEG
83276: PUSH
83277: LD_INT 1
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 2
83286: NEG
83287: PUSH
83288: LD_INT 0
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 2
83297: NEG
83298: PUSH
83299: LD_INT 1
83301: NEG
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 1
83309: NEG
83310: PUSH
83311: LD_INT 3
83313: NEG
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: LD_INT 2
83324: NEG
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 3
83332: PUSH
83333: LD_INT 2
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 2
83342: PUSH
83343: LD_INT 3
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 2
83352: NEG
83353: PUSH
83354: LD_INT 1
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 3
83363: NEG
83364: PUSH
83365: LD_INT 1
83367: NEG
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: LIST
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83398: LD_ADDR_VAR 0 31
83402: PUSH
83403: LD_INT 0
83405: PUSH
83406: LD_INT 0
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 0
83415: PUSH
83416: LD_INT 1
83418: NEG
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 1
83426: PUSH
83427: LD_INT 0
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 1
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 0
83446: PUSH
83447: LD_INT 1
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 1
83456: NEG
83457: PUSH
83458: LD_INT 0
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 1
83467: NEG
83468: PUSH
83469: LD_INT 1
83471: NEG
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: LD_INT 2
83483: NEG
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: PUSH
83492: LD_INT 1
83494: NEG
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 2
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 2
83512: PUSH
83513: LD_INT 1
83515: PUSH
83516: EMPTY
83517: LIST
83518: LIST
83519: PUSH
83520: LD_INT 2
83522: PUSH
83523: LD_INT 2
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: PUSH
83530: LD_INT 1
83532: PUSH
83533: LD_INT 2
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: LD_INT 0
83542: PUSH
83543: LD_INT 2
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 1
83552: NEG
83553: PUSH
83554: LD_INT 1
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 2
83563: NEG
83564: PUSH
83565: LD_INT 1
83567: NEG
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 2
83575: NEG
83576: PUSH
83577: LD_INT 2
83579: NEG
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 2
83587: NEG
83588: PUSH
83589: LD_INT 3
83591: NEG
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: PUSH
83597: LD_INT 2
83599: PUSH
83600: LD_INT 1
83602: NEG
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 3
83610: PUSH
83611: LD_INT 1
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 1
83620: PUSH
83621: LD_INT 3
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 1
83630: NEG
83631: PUSH
83632: LD_INT 2
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PUSH
83639: LD_INT 3
83641: NEG
83642: PUSH
83643: LD_INT 2
83645: NEG
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83676: LD_ADDR_VAR 0 32
83680: PUSH
83681: LD_INT 0
83683: PUSH
83684: LD_INT 0
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: LD_INT 0
83693: PUSH
83694: LD_INT 1
83696: NEG
83697: PUSH
83698: EMPTY
83699: LIST
83700: LIST
83701: PUSH
83702: LD_INT 1
83704: PUSH
83705: LD_INT 0
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 1
83714: PUSH
83715: LD_INT 1
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: LD_INT 1
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 1
83734: NEG
83735: PUSH
83736: LD_INT 0
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 1
83745: NEG
83746: PUSH
83747: LD_INT 1
83749: NEG
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 1
83757: NEG
83758: PUSH
83759: LD_INT 2
83761: NEG
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 0
83769: PUSH
83770: LD_INT 2
83772: NEG
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: LD_INT 1
83780: PUSH
83781: LD_INT 1
83783: NEG
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 2
83791: PUSH
83792: LD_INT 1
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PUSH
83799: LD_INT 2
83801: PUSH
83802: LD_INT 2
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 1
83811: PUSH
83812: LD_INT 2
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: LD_INT 0
83821: PUSH
83822: LD_INT 2
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: PUSH
83829: LD_INT 1
83831: NEG
83832: PUSH
83833: LD_INT 1
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 2
83842: NEG
83843: PUSH
83844: LD_INT 0
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 2
83853: NEG
83854: PUSH
83855: LD_INT 1
83857: NEG
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 1
83865: NEG
83866: PUSH
83867: LD_INT 3
83869: NEG
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 1
83877: PUSH
83878: LD_INT 2
83880: NEG
83881: PUSH
83882: EMPTY
83883: LIST
83884: LIST
83885: PUSH
83886: LD_INT 3
83888: PUSH
83889: LD_INT 2
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 2
83898: PUSH
83899: LD_INT 3
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 2
83908: NEG
83909: PUSH
83910: LD_INT 1
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 3
83919: NEG
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83954: LD_ADDR_VAR 0 33
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: LD_INT 0
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 0
83971: PUSH
83972: LD_INT 1
83974: NEG
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: PUSH
83980: LD_INT 1
83982: PUSH
83983: LD_INT 0
83985: PUSH
83986: EMPTY
83987: LIST
83988: LIST
83989: PUSH
83990: LD_INT 1
83992: PUSH
83993: LD_INT 1
83995: PUSH
83996: EMPTY
83997: LIST
83998: LIST
83999: PUSH
84000: LD_INT 0
84002: PUSH
84003: LD_INT 1
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: LD_INT 0
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 1
84023: NEG
84024: PUSH
84025: LD_INT 1
84027: NEG
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 1
84035: NEG
84036: PUSH
84037: LD_INT 2
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 1
84050: NEG
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 2
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: LD_INT 1
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 1
84078: PUSH
84079: LD_INT 2
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 0
84088: PUSH
84089: LD_INT 2
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 1
84098: NEG
84099: PUSH
84100: LD_INT 1
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 2
84109: NEG
84110: PUSH
84111: LD_INT 0
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 2
84120: NEG
84121: PUSH
84122: LD_INT 1
84124: NEG
84125: PUSH
84126: EMPTY
84127: LIST
84128: LIST
84129: PUSH
84130: LD_INT 2
84132: NEG
84133: PUSH
84134: LD_INT 2
84136: NEG
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 2
84144: NEG
84145: PUSH
84146: LD_INT 3
84148: NEG
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 2
84156: PUSH
84157: LD_INT 1
84159: NEG
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 3
84167: PUSH
84168: LD_INT 1
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 1
84177: PUSH
84178: LD_INT 3
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: PUSH
84185: LD_INT 1
84187: NEG
84188: PUSH
84189: LD_INT 2
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: LD_INT 3
84198: NEG
84199: PUSH
84200: LD_INT 2
84202: NEG
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84233: LD_ADDR_VAR 0 34
84237: PUSH
84238: LD_INT 0
84240: PUSH
84241: LD_INT 0
84243: PUSH
84244: EMPTY
84245: LIST
84246: LIST
84247: PUSH
84248: LD_INT 0
84250: PUSH
84251: LD_INT 1
84253: NEG
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: PUSH
84259: LD_INT 1
84261: PUSH
84262: LD_INT 0
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 1
84271: PUSH
84272: LD_INT 1
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 0
84281: PUSH
84282: LD_INT 1
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 1
84291: NEG
84292: PUSH
84293: LD_INT 0
84295: PUSH
84296: EMPTY
84297: LIST
84298: LIST
84299: PUSH
84300: LD_INT 1
84302: NEG
84303: PUSH
84304: LD_INT 1
84306: NEG
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 1
84314: NEG
84315: PUSH
84316: LD_INT 2
84318: NEG
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 0
84326: PUSH
84327: LD_INT 2
84329: NEG
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: PUSH
84335: LD_INT 1
84337: PUSH
84338: LD_INT 1
84340: NEG
84341: PUSH
84342: EMPTY
84343: LIST
84344: LIST
84345: PUSH
84346: LD_INT 2
84348: PUSH
84349: LD_INT 1
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 2
84358: PUSH
84359: LD_INT 2
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 1
84368: PUSH
84369: LD_INT 2
84371: PUSH
84372: EMPTY
84373: LIST
84374: LIST
84375: PUSH
84376: LD_INT 1
84378: NEG
84379: PUSH
84380: LD_INT 1
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 2
84389: NEG
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 2
84400: NEG
84401: PUSH
84402: LD_INT 1
84404: NEG
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 2
84412: NEG
84413: PUSH
84414: LD_INT 2
84416: NEG
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 1
84424: NEG
84425: PUSH
84426: LD_INT 3
84428: NEG
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: PUSH
84437: LD_INT 2
84439: NEG
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 3
84447: PUSH
84448: LD_INT 2
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 2
84457: PUSH
84458: LD_INT 3
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 3
84478: NEG
84479: PUSH
84480: LD_INT 1
84482: NEG
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: LIST
84492: LIST
84493: LIST
84494: LIST
84495: LIST
84496: LIST
84497: LIST
84498: LIST
84499: LIST
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84513: LD_ADDR_VAR 0 35
84517: PUSH
84518: LD_INT 0
84520: PUSH
84521: LD_INT 0
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 0
84530: PUSH
84531: LD_INT 1
84533: NEG
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: LD_INT 0
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 1
84551: PUSH
84552: LD_INT 1
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: LD_INT 0
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 1
84571: NEG
84572: PUSH
84573: LD_INT 0
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 1
84582: NEG
84583: PUSH
84584: LD_INT 1
84586: NEG
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 2
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 2
84604: NEG
84605: PUSH
84606: LD_INT 1
84608: NEG
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: LIST
84622: LIST
84623: LIST
84624: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84625: LD_ADDR_VAR 0 36
84629: PUSH
84630: LD_INT 0
84632: PUSH
84633: LD_INT 0
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: PUSH
84640: LD_INT 0
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: LD_INT 1
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 0
84673: PUSH
84674: LD_INT 1
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 1
84683: NEG
84684: PUSH
84685: LD_INT 0
84687: PUSH
84688: EMPTY
84689: LIST
84690: LIST
84691: PUSH
84692: LD_INT 1
84694: NEG
84695: PUSH
84696: LD_INT 1
84698: NEG
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 1
84706: NEG
84707: PUSH
84708: LD_INT 2
84710: NEG
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: PUSH
84716: LD_INT 1
84718: PUSH
84719: LD_INT 2
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84737: LD_ADDR_VAR 0 37
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: LD_INT 0
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 0
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: LD_INT 1
84775: PUSH
84776: LD_INT 1
84778: PUSH
84779: EMPTY
84780: LIST
84781: LIST
84782: PUSH
84783: LD_INT 0
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 1
84795: NEG
84796: PUSH
84797: LD_INT 0
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: NEG
84807: PUSH
84808: LD_INT 1
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 1
84821: NEG
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 1
84829: NEG
84830: PUSH
84831: LD_INT 1
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: LIST
84847: LIST
84848: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84849: LD_ADDR_VAR 0 38
84853: PUSH
84854: LD_INT 0
84856: PUSH
84857: LD_INT 0
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 0
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: EMPTY
84882: LIST
84883: LIST
84884: PUSH
84885: LD_INT 1
84887: PUSH
84888: LD_INT 1
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PUSH
84895: LD_INT 0
84897: PUSH
84898: LD_INT 1
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: NEG
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: NEG
84919: PUSH
84920: LD_INT 1
84922: NEG
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 2
84930: PUSH
84931: LD_INT 1
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 2
84940: NEG
84941: PUSH
84942: LD_INT 1
84944: NEG
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84961: LD_ADDR_VAR 0 39
84965: PUSH
84966: LD_INT 0
84968: PUSH
84969: LD_INT 0
84971: PUSH
84972: EMPTY
84973: LIST
84974: LIST
84975: PUSH
84976: LD_INT 0
84978: PUSH
84979: LD_INT 1
84981: NEG
84982: PUSH
84983: EMPTY
84984: LIST
84985: LIST
84986: PUSH
84987: LD_INT 1
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: PUSH
84997: LD_INT 1
84999: PUSH
85000: LD_INT 1
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: LD_INT 1
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 1
85019: NEG
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: PUSH
85028: LD_INT 1
85030: NEG
85031: PUSH
85032: LD_INT 1
85034: NEG
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 1
85042: NEG
85043: PUSH
85044: LD_INT 2
85046: NEG
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 1
85054: PUSH
85055: LD_INT 2
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85073: LD_ADDR_VAR 0 40
85077: PUSH
85078: LD_INT 0
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 0
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: LD_INT 1
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 0
85121: PUSH
85122: LD_INT 1
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 1
85142: NEG
85143: PUSH
85144: LD_INT 1
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: PUSH
85155: LD_INT 1
85157: NEG
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 1
85165: NEG
85166: PUSH
85167: LD_INT 1
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: EMPTY
85175: LIST
85176: LIST
85177: LIST
85178: LIST
85179: LIST
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85185: LD_ADDR_VAR 0 41
85189: PUSH
85190: LD_INT 0
85192: PUSH
85193: LD_INT 0
85195: PUSH
85196: EMPTY
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 0
85202: PUSH
85203: LD_INT 1
85205: NEG
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 0
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 1
85223: PUSH
85224: LD_INT 1
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: LD_INT 1
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: PUSH
85241: LD_INT 1
85243: NEG
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: NEG
85255: PUSH
85256: LD_INT 1
85258: NEG
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 1
85266: NEG
85267: PUSH
85268: LD_INT 2
85270: NEG
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: PUSH
85279: LD_INT 1
85281: NEG
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 2
85289: PUSH
85290: LD_INT 0
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: PUSH
85297: LD_INT 2
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 2
85309: PUSH
85310: LD_INT 2
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: PUSH
85317: LD_INT 1
85319: PUSH
85320: LD_INT 2
85322: PUSH
85323: EMPTY
85324: LIST
85325: LIST
85326: PUSH
85327: LD_INT 1
85329: NEG
85330: PUSH
85331: LD_INT 1
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 2
85340: NEG
85341: PUSH
85342: LD_INT 0
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 2
85351: NEG
85352: PUSH
85353: LD_INT 1
85355: NEG
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: LD_INT 2
85363: NEG
85364: PUSH
85365: LD_INT 2
85367: NEG
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: NEG
85376: PUSH
85377: LD_INT 3
85379: NEG
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 2
85387: PUSH
85388: LD_INT 1
85390: NEG
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 3
85398: PUSH
85399: LD_INT 0
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 3
85408: PUSH
85409: LD_INT 1
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 3
85418: PUSH
85419: LD_INT 2
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 3
85428: PUSH
85429: LD_INT 3
85431: PUSH
85432: EMPTY
85433: LIST
85434: LIST
85435: PUSH
85436: LD_INT 2
85438: PUSH
85439: LD_INT 3
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: LD_INT 2
85448: NEG
85449: PUSH
85450: LD_INT 1
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: PUSH
85457: LD_INT 3
85459: NEG
85460: PUSH
85461: LD_INT 0
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: PUSH
85468: LD_INT 3
85470: NEG
85471: PUSH
85472: LD_INT 1
85474: NEG
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 3
85482: NEG
85483: PUSH
85484: LD_INT 2
85486: NEG
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 3
85494: NEG
85495: PUSH
85496: LD_INT 3
85498: NEG
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: EMPTY
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85535: LD_ADDR_VAR 0 42
85539: PUSH
85540: LD_INT 0
85542: PUSH
85543: LD_INT 0
85545: PUSH
85546: EMPTY
85547: LIST
85548: LIST
85549: PUSH
85550: LD_INT 0
85552: PUSH
85553: LD_INT 1
85555: NEG
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: PUSH
85561: LD_INT 1
85563: PUSH
85564: LD_INT 0
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: LD_INT 1
85573: PUSH
85574: LD_INT 1
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 0
85583: PUSH
85584: LD_INT 1
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: LD_INT 1
85593: NEG
85594: PUSH
85595: LD_INT 0
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: PUSH
85602: LD_INT 1
85604: NEG
85605: PUSH
85606: LD_INT 1
85608: NEG
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: LD_INT 1
85616: NEG
85617: PUSH
85618: LD_INT 2
85620: NEG
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 0
85628: PUSH
85629: LD_INT 2
85631: NEG
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 1
85639: PUSH
85640: LD_INT 1
85642: NEG
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 2
85650: PUSH
85651: LD_INT 1
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 2
85660: PUSH
85661: LD_INT 2
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 1
85670: PUSH
85671: LD_INT 2
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 0
85680: PUSH
85681: LD_INT 2
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: NEG
85691: PUSH
85692: LD_INT 1
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: LD_INT 2
85701: NEG
85702: PUSH
85703: LD_INT 1
85705: NEG
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: PUSH
85711: LD_INT 2
85713: NEG
85714: PUSH
85715: LD_INT 2
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 2
85725: NEG
85726: PUSH
85727: LD_INT 3
85729: NEG
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 1
85737: NEG
85738: PUSH
85739: LD_INT 3
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 0
85749: PUSH
85750: LD_INT 3
85752: NEG
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 1
85760: PUSH
85761: LD_INT 2
85763: NEG
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: LD_INT 3
85771: PUSH
85772: LD_INT 2
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 3
85781: PUSH
85782: LD_INT 3
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 2
85791: PUSH
85792: LD_INT 3
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 1
85801: PUSH
85802: LD_INT 3
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: LD_INT 3
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: PUSH
85819: LD_INT 1
85821: NEG
85822: PUSH
85823: LD_INT 2
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 3
85832: NEG
85833: PUSH
85834: LD_INT 2
85836: NEG
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 3
85844: NEG
85845: PUSH
85846: LD_INT 3
85848: NEG
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: LIST
85858: LIST
85859: LIST
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85885: LD_ADDR_VAR 0 43
85889: PUSH
85890: LD_INT 0
85892: PUSH
85893: LD_INT 0
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 0
85902: PUSH
85903: LD_INT 1
85905: NEG
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 1
85913: PUSH
85914: LD_INT 0
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: LD_INT 1
85923: PUSH
85924: LD_INT 1
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 0
85933: PUSH
85934: LD_INT 1
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 1
85943: NEG
85944: PUSH
85945: LD_INT 0
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 1
85954: NEG
85955: PUSH
85956: LD_INT 1
85958: NEG
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: NEG
85967: PUSH
85968: LD_INT 2
85970: NEG
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 0
85978: PUSH
85979: LD_INT 2
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: PUSH
85990: LD_INT 1
85992: NEG
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 2
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 2
86010: PUSH
86011: LD_INT 1
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 1
86020: PUSH
86021: LD_INT 2
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: LD_INT 0
86030: PUSH
86031: LD_INT 2
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 1
86040: NEG
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 2
86051: NEG
86052: PUSH
86053: LD_INT 0
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: LD_INT 2
86062: NEG
86063: PUSH
86064: LD_INT 1
86066: NEG
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 1
86074: NEG
86075: PUSH
86076: LD_INT 3
86078: NEG
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 0
86086: PUSH
86087: LD_INT 3
86089: NEG
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 1
86097: PUSH
86098: LD_INT 2
86100: NEG
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PUSH
86106: LD_INT 2
86108: PUSH
86109: LD_INT 1
86111: NEG
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: PUSH
86117: LD_INT 3
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 3
86129: PUSH
86130: LD_INT 1
86132: PUSH
86133: EMPTY
86134: LIST
86135: LIST
86136: PUSH
86137: LD_INT 1
86139: PUSH
86140: LD_INT 3
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: LD_INT 3
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 1
86159: NEG
86160: PUSH
86161: LD_INT 2
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 2
86170: NEG
86171: PUSH
86172: LD_INT 1
86174: PUSH
86175: EMPTY
86176: LIST
86177: LIST
86178: PUSH
86179: LD_INT 3
86181: NEG
86182: PUSH
86183: LD_INT 0
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 3
86192: NEG
86193: PUSH
86194: LD_INT 1
86196: NEG
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: EMPTY
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86233: LD_ADDR_VAR 0 44
86237: PUSH
86238: LD_INT 0
86240: PUSH
86241: LD_INT 0
86243: PUSH
86244: EMPTY
86245: LIST
86246: LIST
86247: PUSH
86248: LD_INT 0
86250: PUSH
86251: LD_INT 1
86253: NEG
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: LD_INT 1
86261: PUSH
86262: LD_INT 0
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: PUSH
86272: LD_INT 1
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 0
86281: PUSH
86282: LD_INT 1
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: NEG
86292: PUSH
86293: LD_INT 0
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PUSH
86300: LD_INT 1
86302: NEG
86303: PUSH
86304: LD_INT 1
86306: NEG
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: NEG
86315: PUSH
86316: LD_INT 2
86318: NEG
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 1
86326: PUSH
86327: LD_INT 1
86329: NEG
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 2
86337: PUSH
86338: LD_INT 0
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 2
86347: PUSH
86348: LD_INT 1
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 2
86357: PUSH
86358: LD_INT 2
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: PUSH
86368: LD_INT 2
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 1
86377: NEG
86378: PUSH
86379: LD_INT 1
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 2
86388: NEG
86389: PUSH
86390: LD_INT 0
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 2
86399: NEG
86400: PUSH
86401: LD_INT 1
86403: NEG
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: LD_INT 2
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: LD_INT 3
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 2
86435: PUSH
86436: LD_INT 1
86438: NEG
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: PUSH
86444: LD_INT 3
86446: PUSH
86447: LD_INT 0
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 3
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 3
86466: PUSH
86467: LD_INT 2
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 3
86476: PUSH
86477: LD_INT 3
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 2
86486: PUSH
86487: LD_INT 3
86489: PUSH
86490: EMPTY
86491: LIST
86492: LIST
86493: PUSH
86494: LD_INT 2
86496: NEG
86497: PUSH
86498: LD_INT 1
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PUSH
86505: LD_INT 3
86507: NEG
86508: PUSH
86509: LD_INT 0
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 3
86518: NEG
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 3
86530: NEG
86531: PUSH
86532: LD_INT 2
86534: NEG
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 3
86542: NEG
86543: PUSH
86544: LD_INT 3
86546: NEG
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: LIST
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86583: LD_ADDR_VAR 0 45
86587: PUSH
86588: LD_INT 0
86590: PUSH
86591: LD_INT 0
86593: PUSH
86594: EMPTY
86595: LIST
86596: LIST
86597: PUSH
86598: LD_INT 0
86600: PUSH
86601: LD_INT 1
86603: NEG
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 1
86611: PUSH
86612: LD_INT 0
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: LD_INT 1
86621: PUSH
86622: LD_INT 1
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 0
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 1
86641: NEG
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 1
86652: NEG
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: LD_INT 2
86668: NEG
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: LD_INT 2
86679: NEG
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 1
86687: PUSH
86688: LD_INT 1
86690: NEG
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 2
86698: PUSH
86699: LD_INT 1
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: PUSH
86706: LD_INT 2
86708: PUSH
86709: LD_INT 2
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: LD_INT 2
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: LD_INT 2
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: PUSH
86740: LD_INT 1
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: PUSH
86747: LD_INT 2
86749: NEG
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 2
86761: NEG
86762: PUSH
86763: LD_INT 2
86765: NEG
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 2
86773: NEG
86774: PUSH
86775: LD_INT 3
86777: NEG
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 1
86785: NEG
86786: PUSH
86787: LD_INT 3
86789: NEG
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: LD_INT 3
86800: NEG
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 1
86808: PUSH
86809: LD_INT 2
86811: NEG
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 3
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 3
86829: PUSH
86830: LD_INT 3
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 2
86839: PUSH
86840: LD_INT 3
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 1
86849: PUSH
86850: LD_INT 3
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 0
86859: PUSH
86860: LD_INT 3
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: NEG
86870: PUSH
86871: LD_INT 2
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 3
86880: NEG
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 3
86892: NEG
86893: PUSH
86894: LD_INT 3
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86933: LD_ADDR_VAR 0 46
86937: PUSH
86938: LD_INT 0
86940: PUSH
86941: LD_INT 0
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 0
86950: PUSH
86951: LD_INT 1
86953: NEG
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: PUSH
86962: LD_INT 0
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 1
86971: PUSH
86972: LD_INT 1
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 0
86981: PUSH
86982: LD_INT 1
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 1
86991: NEG
86992: PUSH
86993: LD_INT 0
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 1
87002: NEG
87003: PUSH
87004: LD_INT 1
87006: NEG
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 1
87014: NEG
87015: PUSH
87016: LD_INT 2
87018: NEG
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 0
87026: PUSH
87027: LD_INT 2
87029: NEG
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 1
87037: PUSH
87038: LD_INT 1
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 2
87048: PUSH
87049: LD_INT 0
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 2
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 1
87068: PUSH
87069: LD_INT 2
87071: PUSH
87072: EMPTY
87073: LIST
87074: LIST
87075: PUSH
87076: LD_INT 0
87078: PUSH
87079: LD_INT 2
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 1
87088: NEG
87089: PUSH
87090: LD_INT 1
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PUSH
87097: LD_INT 2
87099: NEG
87100: PUSH
87101: LD_INT 0
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 2
87110: NEG
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 1
87122: NEG
87123: PUSH
87124: LD_INT 3
87126: NEG
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 0
87134: PUSH
87135: LD_INT 3
87137: NEG
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 1
87145: PUSH
87146: LD_INT 2
87148: NEG
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 2
87156: PUSH
87157: LD_INT 1
87159: NEG
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: PUSH
87165: LD_INT 3
87167: PUSH
87168: LD_INT 0
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 3
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: LD_INT 3
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: LD_INT 3
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 1
87207: NEG
87208: PUSH
87209: LD_INT 2
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 2
87218: NEG
87219: PUSH
87220: LD_INT 1
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: LD_INT 3
87229: NEG
87230: PUSH
87231: LD_INT 0
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: PUSH
87238: LD_INT 3
87240: NEG
87241: PUSH
87242: LD_INT 1
87244: NEG
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87281: LD_ADDR_VAR 0 47
87285: PUSH
87286: LD_INT 0
87288: PUSH
87289: LD_INT 0
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 0
87298: PUSH
87299: LD_INT 1
87301: NEG
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 1
87309: PUSH
87310: LD_INT 0
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 0
87329: PUSH
87330: LD_INT 1
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 1
87339: NEG
87340: PUSH
87341: LD_INT 0
87343: PUSH
87344: EMPTY
87345: LIST
87346: LIST
87347: PUSH
87348: LD_INT 1
87350: NEG
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 1
87362: NEG
87363: PUSH
87364: LD_INT 2
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 0
87374: PUSH
87375: LD_INT 2
87377: NEG
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 1
87385: PUSH
87386: LD_INT 1
87388: NEG
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 2
87396: NEG
87397: PUSH
87398: LD_INT 1
87400: NEG
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 2
87408: NEG
87409: PUSH
87410: LD_INT 2
87412: NEG
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87432: LD_ADDR_VAR 0 48
87436: PUSH
87437: LD_INT 0
87439: PUSH
87440: LD_INT 0
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: LD_INT 0
87449: PUSH
87450: LD_INT 1
87452: NEG
87453: PUSH
87454: EMPTY
87455: LIST
87456: LIST
87457: PUSH
87458: LD_INT 1
87460: PUSH
87461: LD_INT 0
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PUSH
87468: LD_INT 1
87470: PUSH
87471: LD_INT 1
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: LD_INT 1
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: PUSH
87488: LD_INT 1
87490: NEG
87491: PUSH
87492: LD_INT 0
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 1
87501: NEG
87502: PUSH
87503: LD_INT 1
87505: NEG
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: PUSH
87511: LD_INT 1
87513: NEG
87514: PUSH
87515: LD_INT 2
87517: NEG
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 0
87525: PUSH
87526: LD_INT 2
87528: NEG
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 1
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 2
87547: PUSH
87548: LD_INT 0
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 2
87557: PUSH
87558: LD_INT 1
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87579: LD_ADDR_VAR 0 49
87583: PUSH
87584: LD_INT 0
87586: PUSH
87587: LD_INT 0
87589: PUSH
87590: EMPTY
87591: LIST
87592: LIST
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: LD_INT 1
87599: NEG
87600: PUSH
87601: EMPTY
87602: LIST
87603: LIST
87604: PUSH
87605: LD_INT 1
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 1
87617: PUSH
87618: LD_INT 1
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 0
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 1
87637: NEG
87638: PUSH
87639: LD_INT 0
87641: PUSH
87642: EMPTY
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 1
87648: NEG
87649: PUSH
87650: LD_INT 1
87652: NEG
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 1
87660: PUSH
87661: LD_INT 1
87663: NEG
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 2
87671: PUSH
87672: LD_INT 0
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 2
87681: PUSH
87682: LD_INT 1
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: LD_INT 2
87691: PUSH
87692: LD_INT 2
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 1
87701: PUSH
87702: LD_INT 2
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: LIST
87722: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87723: LD_ADDR_VAR 0 50
87727: PUSH
87728: LD_INT 0
87730: PUSH
87731: LD_INT 0
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 0
87740: PUSH
87741: LD_INT 1
87743: NEG
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: LD_INT 0
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: PUSH
87762: LD_INT 1
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 0
87771: PUSH
87772: LD_INT 1
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 1
87781: NEG
87782: PUSH
87783: LD_INT 0
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 1
87792: NEG
87793: PUSH
87794: LD_INT 1
87796: NEG
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: PUSH
87805: LD_INT 1
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 2
87814: PUSH
87815: LD_INT 2
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: PUSH
87825: LD_INT 2
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 0
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: PUSH
87842: LD_INT 1
87844: NEG
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87867: LD_ADDR_VAR 0 51
87871: PUSH
87872: LD_INT 0
87874: PUSH
87875: LD_INT 0
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_INT 1
87887: NEG
87888: PUSH
87889: EMPTY
87890: LIST
87891: LIST
87892: PUSH
87893: LD_INT 1
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PUSH
87903: LD_INT 1
87905: PUSH
87906: LD_INT 1
87908: PUSH
87909: EMPTY
87910: LIST
87911: LIST
87912: PUSH
87913: LD_INT 0
87915: PUSH
87916: LD_INT 1
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: LD_INT 1
87925: NEG
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 1
87936: NEG
87937: PUSH
87938: LD_INT 1
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 1
87948: PUSH
87949: LD_INT 2
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 0
87958: PUSH
87959: LD_INT 2
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 1
87968: NEG
87969: PUSH
87970: LD_INT 1
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 2
87979: NEG
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 2
87990: NEG
87991: PUSH
87992: LD_INT 1
87994: NEG
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: EMPTY
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88014: LD_ADDR_VAR 0 52
88018: PUSH
88019: LD_INT 0
88021: PUSH
88022: LD_INT 0
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 0
88031: PUSH
88032: LD_INT 1
88034: NEG
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 1
88042: PUSH
88043: LD_INT 0
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 1
88052: PUSH
88053: LD_INT 1
88055: PUSH
88056: EMPTY
88057: LIST
88058: LIST
88059: PUSH
88060: LD_INT 0
88062: PUSH
88063: LD_INT 1
88065: PUSH
88066: EMPTY
88067: LIST
88068: LIST
88069: PUSH
88070: LD_INT 1
88072: NEG
88073: PUSH
88074: LD_INT 0
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 1
88083: NEG
88084: PUSH
88085: LD_INT 1
88087: NEG
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 1
88095: NEG
88096: PUSH
88097: LD_INT 2
88099: NEG
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: LD_INT 1
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 2
88118: NEG
88119: PUSH
88120: LD_INT 0
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 2
88129: NEG
88130: PUSH
88131: LD_INT 1
88133: NEG
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 2
88141: NEG
88142: PUSH
88143: LD_INT 2
88145: NEG
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: LIST
88164: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88165: LD_ADDR_VAR 0 53
88169: PUSH
88170: LD_INT 0
88172: PUSH
88173: LD_INT 0
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 0
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 1
88193: PUSH
88194: LD_INT 0
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: LD_INT 1
88203: PUSH
88204: LD_INT 1
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 0
88213: PUSH
88214: LD_INT 1
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PUSH
88221: LD_INT 1
88223: NEG
88224: PUSH
88225: LD_INT 0
88227: PUSH
88228: EMPTY
88229: LIST
88230: LIST
88231: PUSH
88232: LD_INT 1
88234: NEG
88235: PUSH
88236: LD_INT 1
88238: NEG
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: PUSH
88244: LD_INT 1
88246: NEG
88247: PUSH
88248: LD_INT 2
88250: NEG
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 0
88258: PUSH
88259: LD_INT 2
88261: NEG
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 1
88269: PUSH
88270: LD_INT 1
88272: NEG
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 2
88280: PUSH
88281: LD_INT 0
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 2
88290: PUSH
88291: LD_INT 1
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 2
88300: PUSH
88301: LD_INT 2
88303: PUSH
88304: EMPTY
88305: LIST
88306: LIST
88307: PUSH
88308: LD_INT 1
88310: PUSH
88311: LD_INT 2
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: LD_INT 0
88320: PUSH
88321: LD_INT 2
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: EMPTY
88336: LIST
88337: LIST
88338: PUSH
88339: LD_INT 2
88341: NEG
88342: PUSH
88343: LD_INT 0
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 2
88352: NEG
88353: PUSH
88354: LD_INT 1
88356: NEG
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 2
88364: NEG
88365: PUSH
88366: LD_INT 2
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88395: LD_ADDR_VAR 0 54
88399: PUSH
88400: LD_INT 0
88402: PUSH
88403: LD_INT 0
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 0
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 1
88423: PUSH
88424: LD_INT 0
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 1
88433: PUSH
88434: LD_INT 1
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 0
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 1
88453: NEG
88454: PUSH
88455: LD_INT 0
88457: PUSH
88458: EMPTY
88459: LIST
88460: LIST
88461: PUSH
88462: LD_INT 1
88464: NEG
88465: PUSH
88466: LD_INT 1
88468: NEG
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: LD_INT 2
88480: NEG
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: LD_INT 0
88488: PUSH
88489: LD_INT 2
88491: NEG
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 1
88499: PUSH
88500: LD_INT 1
88502: NEG
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 2
88510: PUSH
88511: LD_INT 0
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 2
88520: PUSH
88521: LD_INT 1
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 2
88530: PUSH
88531: LD_INT 2
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: PUSH
88538: LD_INT 1
88540: PUSH
88541: LD_INT 2
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PUSH
88548: LD_INT 0
88550: PUSH
88551: LD_INT 2
88553: PUSH
88554: EMPTY
88555: LIST
88556: LIST
88557: PUSH
88558: LD_INT 1
88560: NEG
88561: PUSH
88562: LD_INT 1
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PUSH
88569: LD_INT 2
88571: NEG
88572: PUSH
88573: LD_INT 0
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: LD_INT 1
88586: NEG
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 2
88594: NEG
88595: PUSH
88596: LD_INT 2
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88625: LD_ADDR_VAR 0 55
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: LD_INT 0
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 0
88642: PUSH
88643: LD_INT 1
88645: NEG
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 1
88653: PUSH
88654: LD_INT 0
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: PUSH
88664: LD_INT 1
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 0
88673: PUSH
88674: LD_INT 1
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 1
88683: NEG
88684: PUSH
88685: LD_INT 0
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: LD_INT 1
88694: NEG
88695: PUSH
88696: LD_INT 1
88698: NEG
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 1
88706: NEG
88707: PUSH
88708: LD_INT 2
88710: NEG
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 0
88718: PUSH
88719: LD_INT 2
88721: NEG
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: LD_INT 1
88729: PUSH
88730: LD_INT 1
88732: NEG
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 2
88740: PUSH
88741: LD_INT 0
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: PUSH
88748: LD_INT 2
88750: PUSH
88751: LD_INT 1
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: PUSH
88758: LD_INT 2
88760: PUSH
88761: LD_INT 2
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 1
88770: PUSH
88771: LD_INT 2
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: PUSH
88778: LD_INT 0
88780: PUSH
88781: LD_INT 2
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: PUSH
88788: LD_INT 1
88790: NEG
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: EMPTY
88796: LIST
88797: LIST
88798: PUSH
88799: LD_INT 2
88801: NEG
88802: PUSH
88803: LD_INT 0
88805: PUSH
88806: EMPTY
88807: LIST
88808: LIST
88809: PUSH
88810: LD_INT 2
88812: NEG
88813: PUSH
88814: LD_INT 1
88816: NEG
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 2
88824: NEG
88825: PUSH
88826: LD_INT 2
88828: NEG
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88855: LD_ADDR_VAR 0 56
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: LD_INT 0
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 0
88872: PUSH
88873: LD_INT 1
88875: NEG
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: PUSH
88884: LD_INT 0
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: LD_INT 1
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 0
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 1
88913: NEG
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 1
88924: NEG
88925: PUSH
88926: LD_INT 1
88928: NEG
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: LD_INT 2
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 0
88948: PUSH
88949: LD_INT 2
88951: NEG
88952: PUSH
88953: EMPTY
88954: LIST
88955: LIST
88956: PUSH
88957: LD_INT 1
88959: PUSH
88960: LD_INT 1
88962: NEG
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: PUSH
88968: LD_INT 2
88970: PUSH
88971: LD_INT 0
88973: PUSH
88974: EMPTY
88975: LIST
88976: LIST
88977: PUSH
88978: LD_INT 2
88980: PUSH
88981: LD_INT 1
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 2
88990: PUSH
88991: LD_INT 2
88993: PUSH
88994: EMPTY
88995: LIST
88996: LIST
88997: PUSH
88998: LD_INT 1
89000: PUSH
89001: LD_INT 2
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: LD_INT 2
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: NEG
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 2
89031: NEG
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 2
89042: NEG
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 2
89054: NEG
89055: PUSH
89056: LD_INT 2
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89085: LD_ADDR_VAR 0 57
89089: PUSH
89090: LD_INT 0
89092: PUSH
89093: LD_INT 0
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 0
89102: PUSH
89103: LD_INT 1
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 1
89113: PUSH
89114: LD_INT 0
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 1
89123: PUSH
89124: LD_INT 1
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 0
89133: PUSH
89134: LD_INT 1
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 1
89143: NEG
89144: PUSH
89145: LD_INT 0
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 1
89154: NEG
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: LD_INT 2
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 0
89178: PUSH
89179: LD_INT 2
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 1
89189: PUSH
89190: LD_INT 1
89192: NEG
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: LD_INT 2
89200: PUSH
89201: LD_INT 0
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PUSH
89208: LD_INT 2
89210: PUSH
89211: LD_INT 1
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 2
89220: PUSH
89221: LD_INT 2
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 1
89230: PUSH
89231: LD_INT 2
89233: PUSH
89234: EMPTY
89235: LIST
89236: LIST
89237: PUSH
89238: LD_INT 0
89240: PUSH
89241: LD_INT 2
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: NEG
89251: PUSH
89252: LD_INT 1
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 2
89261: NEG
89262: PUSH
89263: LD_INT 0
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 2
89272: NEG
89273: PUSH
89274: LD_INT 1
89276: NEG
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 2
89284: NEG
89285: PUSH
89286: LD_INT 2
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89315: LD_ADDR_VAR 0 58
89319: PUSH
89320: LD_INT 0
89322: PUSH
89323: LD_INT 0
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 0
89332: PUSH
89333: LD_INT 1
89335: NEG
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 1
89343: PUSH
89344: LD_INT 0
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 1
89353: PUSH
89354: LD_INT 1
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 0
89363: PUSH
89364: LD_INT 1
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 1
89373: NEG
89374: PUSH
89375: LD_INT 0
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 1
89384: NEG
89385: PUSH
89386: LD_INT 1
89388: NEG
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 1
89396: NEG
89397: PUSH
89398: LD_INT 2
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 0
89408: PUSH
89409: LD_INT 2
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 1
89419: PUSH
89420: LD_INT 1
89422: NEG
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 2
89430: PUSH
89431: LD_INT 0
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 2
89440: PUSH
89441: LD_INT 1
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 2
89450: PUSH
89451: LD_INT 2
89453: PUSH
89454: EMPTY
89455: LIST
89456: LIST
89457: PUSH
89458: LD_INT 1
89460: PUSH
89461: LD_INT 2
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: LD_INT 2
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: NEG
89481: PUSH
89482: LD_INT 1
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 2
89491: NEG
89492: PUSH
89493: LD_INT 0
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 2
89502: NEG
89503: PUSH
89504: LD_INT 1
89506: NEG
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 2
89514: NEG
89515: PUSH
89516: LD_INT 2
89518: NEG
89519: PUSH
89520: EMPTY
89521: LIST
89522: LIST
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89545: LD_ADDR_VAR 0 59
89549: PUSH
89550: LD_INT 0
89552: PUSH
89553: LD_INT 0
89555: PUSH
89556: EMPTY
89557: LIST
89558: LIST
89559: PUSH
89560: LD_INT 0
89562: PUSH
89563: LD_INT 1
89565: NEG
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: LD_INT 1
89573: PUSH
89574: LD_INT 0
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 1
89583: PUSH
89584: LD_INT 1
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 0
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 1
89603: NEG
89604: PUSH
89605: LD_INT 0
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 1
89614: NEG
89615: PUSH
89616: LD_INT 1
89618: NEG
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: LIST
89628: LIST
89629: LIST
89630: LIST
89631: LIST
89632: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89633: LD_ADDR_VAR 0 60
89637: PUSH
89638: LD_INT 0
89640: PUSH
89641: LD_INT 0
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 0
89650: PUSH
89651: LD_INT 1
89653: NEG
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: PUSH
89659: LD_INT 1
89661: PUSH
89662: LD_INT 0
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 1
89671: PUSH
89672: LD_INT 1
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: LD_INT 1
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 1
89691: NEG
89692: PUSH
89693: LD_INT 0
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 1
89702: NEG
89703: PUSH
89704: LD_INT 1
89706: NEG
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89721: LD_ADDR_VAR 0 61
89725: PUSH
89726: LD_INT 0
89728: PUSH
89729: LD_INT 0
89731: PUSH
89732: EMPTY
89733: LIST
89734: LIST
89735: PUSH
89736: LD_INT 0
89738: PUSH
89739: LD_INT 1
89741: NEG
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 1
89749: PUSH
89750: LD_INT 0
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: PUSH
89757: LD_INT 1
89759: PUSH
89760: LD_INT 1
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 0
89769: PUSH
89770: LD_INT 1
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: LD_INT 0
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 1
89790: NEG
89791: PUSH
89792: LD_INT 1
89794: NEG
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89809: LD_ADDR_VAR 0 62
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: LD_INT 0
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 0
89826: PUSH
89827: LD_INT 1
89829: NEG
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: LD_INT 0
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 1
89847: PUSH
89848: LD_INT 1
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 0
89857: PUSH
89858: LD_INT 1
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 1
89867: NEG
89868: PUSH
89869: LD_INT 0
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 1
89878: NEG
89879: PUSH
89880: LD_INT 1
89882: NEG
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89897: LD_ADDR_VAR 0 63
89901: PUSH
89902: LD_INT 0
89904: PUSH
89905: LD_INT 0
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: LD_INT 0
89914: PUSH
89915: LD_INT 1
89917: NEG
89918: PUSH
89919: EMPTY
89920: LIST
89921: LIST
89922: PUSH
89923: LD_INT 1
89925: PUSH
89926: LD_INT 0
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: LD_INT 1
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: LD_INT 1
89948: PUSH
89949: EMPTY
89950: LIST
89951: LIST
89952: PUSH
89953: LD_INT 1
89955: NEG
89956: PUSH
89957: LD_INT 0
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: PUSH
89964: LD_INT 1
89966: NEG
89967: PUSH
89968: LD_INT 1
89970: NEG
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: EMPTY
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89985: LD_ADDR_VAR 0 64
89989: PUSH
89990: LD_INT 0
89992: PUSH
89993: LD_INT 0
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 0
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 1
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 1
90023: PUSH
90024: LD_INT 1
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 0
90033: PUSH
90034: LD_INT 1
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 1
90043: NEG
90044: PUSH
90045: LD_INT 0
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 1
90054: NEG
90055: PUSH
90056: LD_INT 1
90058: NEG
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: ST_TO_ADDR
// end ; 1 :
90073: GO 95970
90075: LD_INT 1
90077: DOUBLE
90078: EQUAL
90079: IFTRUE 90083
90081: GO 92706
90083: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90084: LD_ADDR_VAR 0 11
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: LD_INT 3
90095: NEG
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 0
90103: PUSH
90104: LD_INT 3
90106: NEG
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 1
90114: PUSH
90115: LD_INT 2
90117: NEG
90118: PUSH
90119: EMPTY
90120: LIST
90121: LIST
90122: PUSH
90123: EMPTY
90124: LIST
90125: LIST
90126: LIST
90127: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90128: LD_ADDR_VAR 0 12
90132: PUSH
90133: LD_INT 2
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 3
90146: PUSH
90147: LD_INT 0
90149: PUSH
90150: EMPTY
90151: LIST
90152: LIST
90153: PUSH
90154: LD_INT 3
90156: PUSH
90157: LD_INT 1
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: LIST
90168: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90169: LD_ADDR_VAR 0 13
90173: PUSH
90174: LD_INT 3
90176: PUSH
90177: LD_INT 2
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 3
90186: PUSH
90187: LD_INT 3
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 2
90196: PUSH
90197: LD_INT 3
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: LIST
90208: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90209: LD_ADDR_VAR 0 14
90213: PUSH
90214: LD_INT 1
90216: PUSH
90217: LD_INT 3
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 0
90226: PUSH
90227: LD_INT 3
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 1
90236: NEG
90237: PUSH
90238: LD_INT 2
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: EMPTY
90246: LIST
90247: LIST
90248: LIST
90249: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90250: LD_ADDR_VAR 0 15
90254: PUSH
90255: LD_INT 2
90257: NEG
90258: PUSH
90259: LD_INT 1
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 3
90268: NEG
90269: PUSH
90270: LD_INT 0
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: PUSH
90277: LD_INT 3
90279: NEG
90280: PUSH
90281: LD_INT 1
90283: NEG
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: LIST
90293: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90294: LD_ADDR_VAR 0 16
90298: PUSH
90299: LD_INT 2
90301: NEG
90302: PUSH
90303: LD_INT 3
90305: NEG
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 3
90313: NEG
90314: PUSH
90315: LD_INT 2
90317: NEG
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 3
90325: NEG
90326: PUSH
90327: LD_INT 3
90329: NEG
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: LIST
90339: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90340: LD_ADDR_VAR 0 17
90344: PUSH
90345: LD_INT 1
90347: NEG
90348: PUSH
90349: LD_INT 3
90351: NEG
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 0
90359: PUSH
90360: LD_INT 3
90362: NEG
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 1
90370: PUSH
90371: LD_INT 2
90373: NEG
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: LIST
90383: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90384: LD_ADDR_VAR 0 18
90388: PUSH
90389: LD_INT 2
90391: PUSH
90392: LD_INT 1
90394: NEG
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 3
90402: PUSH
90403: LD_INT 0
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 3
90412: PUSH
90413: LD_INT 1
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: LIST
90424: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90425: LD_ADDR_VAR 0 19
90429: PUSH
90430: LD_INT 3
90432: PUSH
90433: LD_INT 2
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: PUSH
90440: LD_INT 3
90442: PUSH
90443: LD_INT 3
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: PUSH
90450: LD_INT 2
90452: PUSH
90453: LD_INT 3
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: LIST
90464: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90465: LD_ADDR_VAR 0 20
90469: PUSH
90470: LD_INT 1
90472: PUSH
90473: LD_INT 3
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 0
90482: PUSH
90483: LD_INT 3
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: LD_INT 2
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: EMPTY
90502: LIST
90503: LIST
90504: LIST
90505: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90506: LD_ADDR_VAR 0 21
90510: PUSH
90511: LD_INT 2
90513: NEG
90514: PUSH
90515: LD_INT 1
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 3
90524: NEG
90525: PUSH
90526: LD_INT 0
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 3
90535: NEG
90536: PUSH
90537: LD_INT 1
90539: NEG
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: LIST
90549: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90550: LD_ADDR_VAR 0 22
90554: PUSH
90555: LD_INT 2
90557: NEG
90558: PUSH
90559: LD_INT 3
90561: NEG
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 3
90569: NEG
90570: PUSH
90571: LD_INT 2
90573: NEG
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: LD_INT 3
90581: NEG
90582: PUSH
90583: LD_INT 3
90585: NEG
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: EMPTY
90592: LIST
90593: LIST
90594: LIST
90595: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90596: LD_ADDR_VAR 0 23
90600: PUSH
90601: LD_INT 0
90603: PUSH
90604: LD_INT 3
90606: NEG
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 1
90614: NEG
90615: PUSH
90616: LD_INT 4
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 1
90626: PUSH
90627: LD_INT 3
90629: NEG
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: LIST
90639: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90640: LD_ADDR_VAR 0 24
90644: PUSH
90645: LD_INT 3
90647: PUSH
90648: LD_INT 0
90650: PUSH
90651: EMPTY
90652: LIST
90653: LIST
90654: PUSH
90655: LD_INT 3
90657: PUSH
90658: LD_INT 1
90660: NEG
90661: PUSH
90662: EMPTY
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 4
90668: PUSH
90669: LD_INT 1
90671: PUSH
90672: EMPTY
90673: LIST
90674: LIST
90675: PUSH
90676: EMPTY
90677: LIST
90678: LIST
90679: LIST
90680: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90681: LD_ADDR_VAR 0 25
90685: PUSH
90686: LD_INT 3
90688: PUSH
90689: LD_INT 3
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 4
90698: PUSH
90699: LD_INT 3
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 3
90708: PUSH
90709: LD_INT 4
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: LIST
90720: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90721: LD_ADDR_VAR 0 26
90725: PUSH
90726: LD_INT 0
90728: PUSH
90729: LD_INT 3
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: LD_INT 4
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 1
90748: NEG
90749: PUSH
90750: LD_INT 3
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: LIST
90761: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90762: LD_ADDR_VAR 0 27
90766: PUSH
90767: LD_INT 3
90769: NEG
90770: PUSH
90771: LD_INT 0
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 3
90780: NEG
90781: PUSH
90782: LD_INT 1
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 4
90791: NEG
90792: PUSH
90793: LD_INT 1
90795: NEG
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: LIST
90805: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90806: LD_ADDR_VAR 0 28
90810: PUSH
90811: LD_INT 3
90813: NEG
90814: PUSH
90815: LD_INT 3
90817: NEG
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 3
90825: NEG
90826: PUSH
90827: LD_INT 4
90829: NEG
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: LD_INT 4
90837: NEG
90838: PUSH
90839: LD_INT 3
90841: NEG
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: LIST
90851: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90852: LD_ADDR_VAR 0 29
90856: PUSH
90857: LD_INT 1
90859: NEG
90860: PUSH
90861: LD_INT 3
90863: NEG
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 0
90871: PUSH
90872: LD_INT 3
90874: NEG
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PUSH
90880: LD_INT 1
90882: PUSH
90883: LD_INT 2
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 1
90893: NEG
90894: PUSH
90895: LD_INT 4
90897: NEG
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 0
90905: PUSH
90906: LD_INT 4
90908: NEG
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 1
90916: PUSH
90917: LD_INT 3
90919: NEG
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 1
90927: NEG
90928: PUSH
90929: LD_INT 5
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 0
90939: PUSH
90940: LD_INT 5
90942: NEG
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 1
90950: PUSH
90951: LD_INT 4
90953: NEG
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 1
90961: NEG
90962: PUSH
90963: LD_INT 6
90965: NEG
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 0
90973: PUSH
90974: LD_INT 6
90976: NEG
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: PUSH
90982: LD_INT 1
90984: PUSH
90985: LD_INT 5
90987: NEG
90988: PUSH
90989: EMPTY
90990: LIST
90991: LIST
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91007: LD_ADDR_VAR 0 30
91011: PUSH
91012: LD_INT 2
91014: PUSH
91015: LD_INT 1
91017: NEG
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 3
91025: PUSH
91026: LD_INT 0
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 3
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 3
91045: PUSH
91046: LD_INT 1
91048: NEG
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 4
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 4
91066: PUSH
91067: LD_INT 1
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: PUSH
91074: LD_INT 4
91076: PUSH
91077: LD_INT 1
91079: NEG
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: LD_INT 5
91087: PUSH
91088: LD_INT 0
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: PUSH
91095: LD_INT 5
91097: PUSH
91098: LD_INT 1
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 5
91107: PUSH
91108: LD_INT 1
91110: NEG
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 6
91118: PUSH
91119: LD_INT 0
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 6
91128: PUSH
91129: LD_INT 1
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: PUSH
91136: EMPTY
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91150: LD_ADDR_VAR 0 31
91154: PUSH
91155: LD_INT 3
91157: PUSH
91158: LD_INT 2
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 3
91167: PUSH
91168: LD_INT 3
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 2
91177: PUSH
91178: LD_INT 3
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 4
91187: PUSH
91188: LD_INT 3
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 4
91197: PUSH
91198: LD_INT 4
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 3
91207: PUSH
91208: LD_INT 4
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 5
91217: PUSH
91218: LD_INT 4
91220: PUSH
91221: EMPTY
91222: LIST
91223: LIST
91224: PUSH
91225: LD_INT 5
91227: PUSH
91228: LD_INT 5
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: LD_INT 4
91237: PUSH
91238: LD_INT 5
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PUSH
91245: LD_INT 6
91247: PUSH
91248: LD_INT 5
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 6
91257: PUSH
91258: LD_INT 6
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 5
91267: PUSH
91268: LD_INT 6
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: EMPTY
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91289: LD_ADDR_VAR 0 32
91293: PUSH
91294: LD_INT 1
91296: PUSH
91297: LD_INT 3
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 0
91306: PUSH
91307: LD_INT 3
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 1
91316: NEG
91317: PUSH
91318: LD_INT 2
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 1
91327: PUSH
91328: LD_INT 4
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 0
91337: PUSH
91338: LD_INT 4
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: PUSH
91345: LD_INT 1
91347: NEG
91348: PUSH
91349: LD_INT 3
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 1
91358: PUSH
91359: LD_INT 5
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 0
91368: PUSH
91369: LD_INT 5
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 1
91378: NEG
91379: PUSH
91380: LD_INT 4
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 1
91389: PUSH
91390: LD_INT 6
91392: PUSH
91393: EMPTY
91394: LIST
91395: LIST
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: LD_INT 6
91402: PUSH
91403: EMPTY
91404: LIST
91405: LIST
91406: PUSH
91407: LD_INT 1
91409: NEG
91410: PUSH
91411: LD_INT 5
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: EMPTY
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91432: LD_ADDR_VAR 0 33
91436: PUSH
91437: LD_INT 2
91439: NEG
91440: PUSH
91441: LD_INT 1
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 3
91450: NEG
91451: PUSH
91452: LD_INT 0
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: LD_INT 3
91461: NEG
91462: PUSH
91463: LD_INT 1
91465: NEG
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: PUSH
91471: LD_INT 3
91473: NEG
91474: PUSH
91475: LD_INT 1
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 4
91484: NEG
91485: PUSH
91486: LD_INT 0
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 4
91495: NEG
91496: PUSH
91497: LD_INT 1
91499: NEG
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 4
91507: NEG
91508: PUSH
91509: LD_INT 1
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 5
91518: NEG
91519: PUSH
91520: LD_INT 0
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 5
91529: NEG
91530: PUSH
91531: LD_INT 1
91533: NEG
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 5
91541: NEG
91542: PUSH
91543: LD_INT 1
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: LD_INT 6
91552: NEG
91553: PUSH
91554: LD_INT 0
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 6
91563: NEG
91564: PUSH
91565: LD_INT 1
91567: NEG
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: LIST
91582: LIST
91583: LIST
91584: LIST
91585: LIST
91586: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91587: LD_ADDR_VAR 0 34
91591: PUSH
91592: LD_INT 2
91594: NEG
91595: PUSH
91596: LD_INT 3
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 3
91606: NEG
91607: PUSH
91608: LD_INT 2
91610: NEG
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 3
91618: NEG
91619: PUSH
91620: LD_INT 3
91622: NEG
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 3
91630: NEG
91631: PUSH
91632: LD_INT 4
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 4
91642: NEG
91643: PUSH
91644: LD_INT 3
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 4
91654: NEG
91655: PUSH
91656: LD_INT 4
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 4
91666: NEG
91667: PUSH
91668: LD_INT 5
91670: NEG
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 5
91678: NEG
91679: PUSH
91680: LD_INT 4
91682: NEG
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: PUSH
91688: LD_INT 5
91690: NEG
91691: PUSH
91692: LD_INT 5
91694: NEG
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 5
91702: NEG
91703: PUSH
91704: LD_INT 6
91706: NEG
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 6
91714: NEG
91715: PUSH
91716: LD_INT 5
91718: NEG
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 6
91726: NEG
91727: PUSH
91728: LD_INT 6
91730: NEG
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91750: LD_ADDR_VAR 0 41
91754: PUSH
91755: LD_INT 0
91757: PUSH
91758: LD_INT 2
91760: NEG
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 1
91768: NEG
91769: PUSH
91770: LD_INT 3
91772: NEG
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 1
91780: PUSH
91781: LD_INT 2
91783: NEG
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: EMPTY
91790: LIST
91791: LIST
91792: LIST
91793: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91794: LD_ADDR_VAR 0 42
91798: PUSH
91799: LD_INT 2
91801: PUSH
91802: LD_INT 0
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 2
91811: PUSH
91812: LD_INT 1
91814: NEG
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 3
91822: PUSH
91823: LD_INT 1
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91835: LD_ADDR_VAR 0 43
91839: PUSH
91840: LD_INT 2
91842: PUSH
91843: LD_INT 2
91845: PUSH
91846: EMPTY
91847: LIST
91848: LIST
91849: PUSH
91850: LD_INT 3
91852: PUSH
91853: LD_INT 2
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: PUSH
91860: LD_INT 2
91862: PUSH
91863: LD_INT 3
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: LIST
91874: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91875: LD_ADDR_VAR 0 44
91879: PUSH
91880: LD_INT 0
91882: PUSH
91883: LD_INT 2
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: LD_INT 3
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 1
91902: NEG
91903: PUSH
91904: LD_INT 2
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: LIST
91915: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91916: LD_ADDR_VAR 0 45
91920: PUSH
91921: LD_INT 2
91923: NEG
91924: PUSH
91925: LD_INT 0
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 2
91934: NEG
91935: PUSH
91936: LD_INT 1
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 3
91945: NEG
91946: PUSH
91947: LD_INT 1
91949: NEG
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: EMPTY
91956: LIST
91957: LIST
91958: LIST
91959: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91960: LD_ADDR_VAR 0 46
91964: PUSH
91965: LD_INT 2
91967: NEG
91968: PUSH
91969: LD_INT 2
91971: NEG
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 2
91979: NEG
91980: PUSH
91981: LD_INT 3
91983: NEG
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 3
91991: NEG
91992: PUSH
91993: LD_INT 2
91995: NEG
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: LIST
92005: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92006: LD_ADDR_VAR 0 47
92010: PUSH
92011: LD_INT 2
92013: NEG
92014: PUSH
92015: LD_INT 3
92017: NEG
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 1
92025: NEG
92026: PUSH
92027: LD_INT 3
92029: NEG
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92039: LD_ADDR_VAR 0 48
92043: PUSH
92044: LD_INT 1
92046: PUSH
92047: LD_INT 2
92049: NEG
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 2
92057: PUSH
92058: LD_INT 1
92060: NEG
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92070: LD_ADDR_VAR 0 49
92074: PUSH
92075: LD_INT 3
92077: PUSH
92078: LD_INT 1
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 3
92087: PUSH
92088: LD_INT 2
92090: PUSH
92091: EMPTY
92092: LIST
92093: LIST
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92099: LD_ADDR_VAR 0 50
92103: PUSH
92104: LD_INT 2
92106: PUSH
92107: LD_INT 3
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 1
92116: PUSH
92117: LD_INT 3
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92128: LD_ADDR_VAR 0 51
92132: PUSH
92133: LD_INT 1
92135: NEG
92136: PUSH
92137: LD_INT 2
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 2
92146: NEG
92147: PUSH
92148: LD_INT 1
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92159: LD_ADDR_VAR 0 52
92163: PUSH
92164: LD_INT 3
92166: NEG
92167: PUSH
92168: LD_INT 1
92170: NEG
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: LD_INT 3
92178: NEG
92179: PUSH
92180: LD_INT 2
92182: NEG
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92192: LD_ADDR_VAR 0 53
92196: PUSH
92197: LD_INT 1
92199: NEG
92200: PUSH
92201: LD_INT 3
92203: NEG
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: LD_INT 0
92211: PUSH
92212: LD_INT 3
92214: NEG
92215: PUSH
92216: EMPTY
92217: LIST
92218: LIST
92219: PUSH
92220: LD_INT 1
92222: PUSH
92223: LD_INT 2
92225: NEG
92226: PUSH
92227: EMPTY
92228: LIST
92229: LIST
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: LIST
92235: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92236: LD_ADDR_VAR 0 54
92240: PUSH
92241: LD_INT 2
92243: PUSH
92244: LD_INT 1
92246: NEG
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: LD_INT 3
92254: PUSH
92255: LD_INT 0
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: PUSH
92262: LD_INT 3
92264: PUSH
92265: LD_INT 1
92267: PUSH
92268: EMPTY
92269: LIST
92270: LIST
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: LIST
92276: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92277: LD_ADDR_VAR 0 55
92281: PUSH
92282: LD_INT 3
92284: PUSH
92285: LD_INT 2
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 3
92294: PUSH
92295: LD_INT 3
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: PUSH
92302: LD_INT 2
92304: PUSH
92305: LD_INT 3
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: LIST
92316: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92317: LD_ADDR_VAR 0 56
92321: PUSH
92322: LD_INT 1
92324: PUSH
92325: LD_INT 3
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: PUSH
92332: LD_INT 0
92334: PUSH
92335: LD_INT 3
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 1
92344: NEG
92345: PUSH
92346: LD_INT 2
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: LIST
92357: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92358: LD_ADDR_VAR 0 57
92362: PUSH
92363: LD_INT 2
92365: NEG
92366: PUSH
92367: LD_INT 1
92369: PUSH
92370: EMPTY
92371: LIST
92372: LIST
92373: PUSH
92374: LD_INT 3
92376: NEG
92377: PUSH
92378: LD_INT 0
92380: PUSH
92381: EMPTY
92382: LIST
92383: LIST
92384: PUSH
92385: LD_INT 3
92387: NEG
92388: PUSH
92389: LD_INT 1
92391: NEG
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: EMPTY
92398: LIST
92399: LIST
92400: LIST
92401: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92402: LD_ADDR_VAR 0 58
92406: PUSH
92407: LD_INT 2
92409: NEG
92410: PUSH
92411: LD_INT 3
92413: NEG
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PUSH
92419: LD_INT 3
92421: NEG
92422: PUSH
92423: LD_INT 2
92425: NEG
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 3
92433: NEG
92434: PUSH
92435: LD_INT 3
92437: NEG
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: LIST
92447: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92448: LD_ADDR_VAR 0 59
92452: PUSH
92453: LD_INT 1
92455: NEG
92456: PUSH
92457: LD_INT 2
92459: NEG
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PUSH
92465: LD_INT 0
92467: PUSH
92468: LD_INT 2
92470: NEG
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 1
92478: PUSH
92479: LD_INT 1
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: LIST
92491: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92492: LD_ADDR_VAR 0 60
92496: PUSH
92497: LD_INT 1
92499: PUSH
92500: LD_INT 1
92502: NEG
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: PUSH
92508: LD_INT 2
92510: PUSH
92511: LD_INT 0
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: PUSH
92518: LD_INT 2
92520: PUSH
92521: LD_INT 1
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: LIST
92532: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92533: LD_ADDR_VAR 0 61
92537: PUSH
92538: LD_INT 2
92540: PUSH
92541: LD_INT 1
92543: PUSH
92544: EMPTY
92545: LIST
92546: LIST
92547: PUSH
92548: LD_INT 2
92550: PUSH
92551: LD_INT 2
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 1
92560: PUSH
92561: LD_INT 2
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: LIST
92572: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92573: LD_ADDR_VAR 0 62
92577: PUSH
92578: LD_INT 1
92580: PUSH
92581: LD_INT 2
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: PUSH
92588: LD_INT 0
92590: PUSH
92591: LD_INT 2
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 1
92600: NEG
92601: PUSH
92602: LD_INT 1
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: LIST
92613: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92614: LD_ADDR_VAR 0 63
92618: PUSH
92619: LD_INT 1
92621: NEG
92622: PUSH
92623: LD_INT 1
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: NEG
92633: PUSH
92634: LD_INT 0
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 2
92643: NEG
92644: PUSH
92645: LD_INT 1
92647: NEG
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: LIST
92657: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92658: LD_ADDR_VAR 0 64
92662: PUSH
92663: LD_INT 1
92665: NEG
92666: PUSH
92667: LD_INT 2
92669: NEG
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 2
92677: NEG
92678: PUSH
92679: LD_INT 1
92681: NEG
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 2
92689: NEG
92690: PUSH
92691: LD_INT 2
92693: NEG
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: LIST
92703: ST_TO_ADDR
// end ; 2 :
92704: GO 95970
92706: LD_INT 2
92708: DOUBLE
92709: EQUAL
92710: IFTRUE 92714
92712: GO 95969
92714: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92715: LD_ADDR_VAR 0 29
92719: PUSH
92720: LD_INT 4
92722: PUSH
92723: LD_INT 0
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PUSH
92730: LD_INT 4
92732: PUSH
92733: LD_INT 1
92735: NEG
92736: PUSH
92737: EMPTY
92738: LIST
92739: LIST
92740: PUSH
92741: LD_INT 5
92743: PUSH
92744: LD_INT 0
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 5
92753: PUSH
92754: LD_INT 1
92756: PUSH
92757: EMPTY
92758: LIST
92759: LIST
92760: PUSH
92761: LD_INT 4
92763: PUSH
92764: LD_INT 1
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 3
92773: PUSH
92774: LD_INT 0
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 3
92783: PUSH
92784: LD_INT 1
92786: NEG
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: PUSH
92792: LD_INT 3
92794: PUSH
92795: LD_INT 2
92797: NEG
92798: PUSH
92799: EMPTY
92800: LIST
92801: LIST
92802: PUSH
92803: LD_INT 5
92805: PUSH
92806: LD_INT 2
92808: PUSH
92809: EMPTY
92810: LIST
92811: LIST
92812: PUSH
92813: LD_INT 3
92815: PUSH
92816: LD_INT 3
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 3
92825: PUSH
92826: LD_INT 2
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 4
92835: PUSH
92836: LD_INT 3
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 4
92845: PUSH
92846: LD_INT 4
92848: PUSH
92849: EMPTY
92850: LIST
92851: LIST
92852: PUSH
92853: LD_INT 3
92855: PUSH
92856: LD_INT 4
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 2
92865: PUSH
92866: LD_INT 3
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 2
92875: PUSH
92876: LD_INT 2
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 4
92885: PUSH
92886: LD_INT 2
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: PUSH
92893: LD_INT 2
92895: PUSH
92896: LD_INT 4
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 0
92905: PUSH
92906: LD_INT 4
92908: PUSH
92909: EMPTY
92910: LIST
92911: LIST
92912: PUSH
92913: LD_INT 0
92915: PUSH
92916: LD_INT 3
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: PUSH
92923: LD_INT 1
92925: PUSH
92926: LD_INT 4
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 1
92935: PUSH
92936: LD_INT 5
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 0
92945: PUSH
92946: LD_INT 5
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 1
92955: NEG
92956: PUSH
92957: LD_INT 4
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 1
92966: NEG
92967: PUSH
92968: LD_INT 3
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 2
92977: PUSH
92978: LD_INT 5
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 2
92987: NEG
92988: PUSH
92989: LD_INT 3
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 3
92998: NEG
92999: PUSH
93000: LD_INT 0
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: PUSH
93007: LD_INT 3
93009: NEG
93010: PUSH
93011: LD_INT 1
93013: NEG
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 2
93021: NEG
93022: PUSH
93023: LD_INT 0
93025: PUSH
93026: EMPTY
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 2
93032: NEG
93033: PUSH
93034: LD_INT 1
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 3
93043: NEG
93044: PUSH
93045: LD_INT 1
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 4
93054: NEG
93055: PUSH
93056: LD_INT 0
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 4
93065: NEG
93066: PUSH
93067: LD_INT 1
93069: NEG
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 4
93077: NEG
93078: PUSH
93079: LD_INT 2
93081: NEG
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 2
93089: NEG
93090: PUSH
93091: LD_INT 2
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: PUSH
93098: LD_INT 4
93100: NEG
93101: PUSH
93102: LD_INT 4
93104: NEG
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 4
93112: NEG
93113: PUSH
93114: LD_INT 5
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 3
93124: NEG
93125: PUSH
93126: LD_INT 4
93128: NEG
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 3
93136: NEG
93137: PUSH
93138: LD_INT 3
93140: NEG
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 4
93148: NEG
93149: PUSH
93150: LD_INT 3
93152: NEG
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: LD_INT 5
93160: NEG
93161: PUSH
93162: LD_INT 4
93164: NEG
93165: PUSH
93166: EMPTY
93167: LIST
93168: LIST
93169: PUSH
93170: LD_INT 5
93172: NEG
93173: PUSH
93174: LD_INT 5
93176: NEG
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 3
93184: NEG
93185: PUSH
93186: LD_INT 5
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 5
93196: NEG
93197: PUSH
93198: LD_INT 3
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93253: LD_ADDR_VAR 0 30
93257: PUSH
93258: LD_INT 4
93260: PUSH
93261: LD_INT 4
93263: PUSH
93264: EMPTY
93265: LIST
93266: LIST
93267: PUSH
93268: LD_INT 4
93270: PUSH
93271: LD_INT 3
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 5
93280: PUSH
93281: LD_INT 4
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PUSH
93288: LD_INT 5
93290: PUSH
93291: LD_INT 5
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 4
93300: PUSH
93301: LD_INT 5
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: LD_INT 3
93310: PUSH
93311: LD_INT 4
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 3
93320: PUSH
93321: LD_INT 3
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 5
93330: PUSH
93331: LD_INT 3
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 3
93340: PUSH
93341: LD_INT 5
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 0
93350: PUSH
93351: LD_INT 3
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 0
93360: PUSH
93361: LD_INT 2
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 1
93370: PUSH
93371: LD_INT 3
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 1
93380: PUSH
93381: LD_INT 4
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 0
93390: PUSH
93391: LD_INT 4
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 1
93400: NEG
93401: PUSH
93402: LD_INT 3
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 1
93411: NEG
93412: PUSH
93413: LD_INT 2
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 2
93422: PUSH
93423: LD_INT 4
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 2
93432: NEG
93433: PUSH
93434: LD_INT 2
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 4
93443: NEG
93444: PUSH
93445: LD_INT 0
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: LD_INT 4
93454: NEG
93455: PUSH
93456: LD_INT 1
93458: NEG
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: PUSH
93464: LD_INT 3
93466: NEG
93467: PUSH
93468: LD_INT 0
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 3
93477: NEG
93478: PUSH
93479: LD_INT 1
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 4
93488: NEG
93489: PUSH
93490: LD_INT 1
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: LD_INT 5
93499: NEG
93500: PUSH
93501: LD_INT 0
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 5
93510: NEG
93511: PUSH
93512: LD_INT 1
93514: NEG
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 5
93522: NEG
93523: PUSH
93524: LD_INT 2
93526: NEG
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 3
93534: NEG
93535: PUSH
93536: LD_INT 2
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 3
93545: NEG
93546: PUSH
93547: LD_INT 3
93549: NEG
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: LD_INT 3
93557: NEG
93558: PUSH
93559: LD_INT 4
93561: NEG
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 2
93569: NEG
93570: PUSH
93571: LD_INT 3
93573: NEG
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 2
93581: NEG
93582: PUSH
93583: LD_INT 2
93585: NEG
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 3
93593: NEG
93594: PUSH
93595: LD_INT 2
93597: NEG
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 4
93605: NEG
93606: PUSH
93607: LD_INT 3
93609: NEG
93610: PUSH
93611: EMPTY
93612: LIST
93613: LIST
93614: PUSH
93615: LD_INT 4
93617: NEG
93618: PUSH
93619: LD_INT 4
93621: NEG
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 2
93629: NEG
93630: PUSH
93631: LD_INT 4
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 4
93641: NEG
93642: PUSH
93643: LD_INT 2
93645: NEG
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 0
93653: PUSH
93654: LD_INT 4
93656: NEG
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_INT 0
93664: PUSH
93665: LD_INT 5
93667: NEG
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 1
93675: PUSH
93676: LD_INT 4
93678: NEG
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 1
93686: PUSH
93687: LD_INT 3
93689: NEG
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 0
93697: PUSH
93698: LD_INT 3
93700: NEG
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 1
93708: NEG
93709: PUSH
93710: LD_INT 4
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 1
93720: NEG
93721: PUSH
93722: LD_INT 5
93724: NEG
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 2
93732: PUSH
93733: LD_INT 3
93735: NEG
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 2
93743: NEG
93744: PUSH
93745: LD_INT 5
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93800: LD_ADDR_VAR 0 31
93804: PUSH
93805: LD_INT 0
93807: PUSH
93808: LD_INT 4
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 0
93817: PUSH
93818: LD_INT 3
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 1
93827: PUSH
93828: LD_INT 4
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 1
93837: PUSH
93838: LD_INT 5
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 0
93847: PUSH
93848: LD_INT 5
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: PUSH
93855: LD_INT 1
93857: NEG
93858: PUSH
93859: LD_INT 4
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 1
93868: NEG
93869: PUSH
93870: LD_INT 3
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 2
93879: PUSH
93880: LD_INT 5
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: PUSH
93887: LD_INT 2
93889: NEG
93890: PUSH
93891: LD_INT 3
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: LD_INT 3
93900: NEG
93901: PUSH
93902: LD_INT 0
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 3
93911: NEG
93912: PUSH
93913: LD_INT 1
93915: NEG
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 2
93923: NEG
93924: PUSH
93925: LD_INT 0
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 2
93934: NEG
93935: PUSH
93936: LD_INT 1
93938: PUSH
93939: EMPTY
93940: LIST
93941: LIST
93942: PUSH
93943: LD_INT 3
93945: NEG
93946: PUSH
93947: LD_INT 1
93949: PUSH
93950: EMPTY
93951: LIST
93952: LIST
93953: PUSH
93954: LD_INT 4
93956: NEG
93957: PUSH
93958: LD_INT 0
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 4
93967: NEG
93968: PUSH
93969: LD_INT 1
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 4
93979: NEG
93980: PUSH
93981: LD_INT 2
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 2
93991: NEG
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 4
94002: NEG
94003: PUSH
94004: LD_INT 4
94006: NEG
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: LD_INT 4
94014: NEG
94015: PUSH
94016: LD_INT 5
94018: NEG
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 3
94026: NEG
94027: PUSH
94028: LD_INT 4
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 3
94038: NEG
94039: PUSH
94040: LD_INT 3
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 4
94050: NEG
94051: PUSH
94052: LD_INT 3
94054: NEG
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_INT 5
94062: NEG
94063: PUSH
94064: LD_INT 4
94066: NEG
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: LD_INT 5
94074: NEG
94075: PUSH
94076: LD_INT 5
94078: NEG
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 3
94086: NEG
94087: PUSH
94088: LD_INT 5
94090: NEG
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 5
94098: NEG
94099: PUSH
94100: LD_INT 3
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 0
94110: PUSH
94111: LD_INT 3
94113: NEG
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 0
94121: PUSH
94122: LD_INT 4
94124: NEG
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: PUSH
94130: LD_INT 1
94132: PUSH
94133: LD_INT 3
94135: NEG
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: PUSH
94141: LD_INT 1
94143: PUSH
94144: LD_INT 2
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 0
94154: PUSH
94155: LD_INT 2
94157: NEG
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 1
94165: NEG
94166: PUSH
94167: LD_INT 3
94169: NEG
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 1
94177: NEG
94178: PUSH
94179: LD_INT 4
94181: NEG
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 2
94189: PUSH
94190: LD_INT 2
94192: NEG
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 2
94200: NEG
94201: PUSH
94202: LD_INT 4
94204: NEG
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 4
94212: PUSH
94213: LD_INT 0
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 4
94222: PUSH
94223: LD_INT 1
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 5
94233: PUSH
94234: LD_INT 0
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 5
94243: PUSH
94244: LD_INT 1
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 4
94253: PUSH
94254: LD_INT 1
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 3
94263: PUSH
94264: LD_INT 0
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 3
94273: PUSH
94274: LD_INT 1
94276: NEG
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 3
94284: PUSH
94285: LD_INT 2
94287: NEG
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 5
94295: PUSH
94296: LD_INT 2
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94350: LD_ADDR_VAR 0 32
94354: PUSH
94355: LD_INT 4
94357: NEG
94358: PUSH
94359: LD_INT 0
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 4
94368: NEG
94369: PUSH
94370: LD_INT 1
94372: NEG
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 3
94380: NEG
94381: PUSH
94382: LD_INT 0
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 3
94391: NEG
94392: PUSH
94393: LD_INT 1
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 4
94402: NEG
94403: PUSH
94404: LD_INT 1
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 5
94413: NEG
94414: PUSH
94415: LD_INT 0
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 5
94424: NEG
94425: PUSH
94426: LD_INT 1
94428: NEG
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 5
94436: NEG
94437: PUSH
94438: LD_INT 2
94440: NEG
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 3
94448: NEG
94449: PUSH
94450: LD_INT 2
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 3
94459: NEG
94460: PUSH
94461: LD_INT 3
94463: NEG
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 3
94471: NEG
94472: PUSH
94473: LD_INT 4
94475: NEG
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 2
94483: NEG
94484: PUSH
94485: LD_INT 3
94487: NEG
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 2
94495: NEG
94496: PUSH
94497: LD_INT 2
94499: NEG
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 3
94507: NEG
94508: PUSH
94509: LD_INT 2
94511: NEG
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 4
94519: NEG
94520: PUSH
94521: LD_INT 3
94523: NEG
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 4
94531: NEG
94532: PUSH
94533: LD_INT 4
94535: NEG
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 2
94543: NEG
94544: PUSH
94545: LD_INT 4
94547: NEG
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: PUSH
94553: LD_INT 4
94555: NEG
94556: PUSH
94557: LD_INT 2
94559: NEG
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 0
94567: PUSH
94568: LD_INT 4
94570: NEG
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 0
94578: PUSH
94579: LD_INT 5
94581: NEG
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: PUSH
94587: LD_INT 1
94589: PUSH
94590: LD_INT 4
94592: NEG
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: PUSH
94598: LD_INT 1
94600: PUSH
94601: LD_INT 3
94603: NEG
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: PUSH
94609: LD_INT 0
94611: PUSH
94612: LD_INT 3
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 1
94622: NEG
94623: PUSH
94624: LD_INT 4
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 1
94634: NEG
94635: PUSH
94636: LD_INT 5
94638: NEG
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 2
94646: PUSH
94647: LD_INT 3
94649: NEG
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: LD_INT 2
94657: NEG
94658: PUSH
94659: LD_INT 5
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 3
94669: PUSH
94670: LD_INT 0
94672: PUSH
94673: EMPTY
94674: LIST
94675: LIST
94676: PUSH
94677: LD_INT 3
94679: PUSH
94680: LD_INT 1
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 4
94690: PUSH
94691: LD_INT 0
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 4
94700: PUSH
94701: LD_INT 1
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 3
94710: PUSH
94711: LD_INT 1
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 2
94720: PUSH
94721: LD_INT 0
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 2
94730: PUSH
94731: LD_INT 1
94733: NEG
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: LD_INT 2
94741: PUSH
94742: LD_INT 2
94744: NEG
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 4
94752: PUSH
94753: LD_INT 2
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: PUSH
94760: LD_INT 4
94762: PUSH
94763: LD_INT 4
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: LD_INT 4
94772: PUSH
94773: LD_INT 3
94775: PUSH
94776: EMPTY
94777: LIST
94778: LIST
94779: PUSH
94780: LD_INT 5
94782: PUSH
94783: LD_INT 4
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 5
94792: PUSH
94793: LD_INT 5
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 4
94802: PUSH
94803: LD_INT 5
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 3
94812: PUSH
94813: LD_INT 4
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 3
94822: PUSH
94823: LD_INT 3
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 5
94832: PUSH
94833: LD_INT 3
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 3
94842: PUSH
94843: LD_INT 5
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: LIST
94861: LIST
94862: LIST
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94897: LD_ADDR_VAR 0 33
94901: PUSH
94902: LD_INT 4
94904: NEG
94905: PUSH
94906: LD_INT 4
94908: NEG
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 4
94916: NEG
94917: PUSH
94918: LD_INT 5
94920: NEG
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 3
94928: NEG
94929: PUSH
94930: LD_INT 4
94932: NEG
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PUSH
94938: LD_INT 3
94940: NEG
94941: PUSH
94942: LD_INT 3
94944: NEG
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 4
94952: NEG
94953: PUSH
94954: LD_INT 3
94956: NEG
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 5
94964: NEG
94965: PUSH
94966: LD_INT 4
94968: NEG
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 5
94976: NEG
94977: PUSH
94978: LD_INT 5
94980: NEG
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 3
94988: NEG
94989: PUSH
94990: LD_INT 5
94992: NEG
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 5
95000: NEG
95001: PUSH
95002: LD_INT 3
95004: NEG
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: PUSH
95010: LD_INT 0
95012: PUSH
95013: LD_INT 3
95015: NEG
95016: PUSH
95017: EMPTY
95018: LIST
95019: LIST
95020: PUSH
95021: LD_INT 0
95023: PUSH
95024: LD_INT 4
95026: NEG
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 1
95034: PUSH
95035: LD_INT 3
95037: NEG
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 1
95045: PUSH
95046: LD_INT 2
95048: NEG
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 0
95056: PUSH
95057: LD_INT 2
95059: NEG
95060: PUSH
95061: EMPTY
95062: LIST
95063: LIST
95064: PUSH
95065: LD_INT 1
95067: NEG
95068: PUSH
95069: LD_INT 3
95071: NEG
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 1
95079: NEG
95080: PUSH
95081: LD_INT 4
95083: NEG
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: LD_INT 2
95091: PUSH
95092: LD_INT 2
95094: NEG
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PUSH
95100: LD_INT 2
95102: NEG
95103: PUSH
95104: LD_INT 4
95106: NEG
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 4
95114: PUSH
95115: LD_INT 0
95117: PUSH
95118: EMPTY
95119: LIST
95120: LIST
95121: PUSH
95122: LD_INT 4
95124: PUSH
95125: LD_INT 1
95127: NEG
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: LD_INT 5
95135: PUSH
95136: LD_INT 0
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 5
95145: PUSH
95146: LD_INT 1
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 4
95155: PUSH
95156: LD_INT 1
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 3
95165: PUSH
95166: LD_INT 0
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 3
95175: PUSH
95176: LD_INT 1
95178: NEG
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 3
95186: PUSH
95187: LD_INT 2
95189: NEG
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 5
95197: PUSH
95198: LD_INT 2
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 3
95207: PUSH
95208: LD_INT 3
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 3
95217: PUSH
95218: LD_INT 2
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 4
95227: PUSH
95228: LD_INT 3
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: PUSH
95235: LD_INT 4
95237: PUSH
95238: LD_INT 4
95240: PUSH
95241: EMPTY
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 3
95247: PUSH
95248: LD_INT 4
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 2
95257: PUSH
95258: LD_INT 3
95260: PUSH
95261: EMPTY
95262: LIST
95263: LIST
95264: PUSH
95265: LD_INT 2
95267: PUSH
95268: LD_INT 2
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 4
95277: PUSH
95278: LD_INT 2
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 2
95287: PUSH
95288: LD_INT 4
95290: PUSH
95291: EMPTY
95292: LIST
95293: LIST
95294: PUSH
95295: LD_INT 0
95297: PUSH
95298: LD_INT 4
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 0
95307: PUSH
95308: LD_INT 3
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PUSH
95315: LD_INT 1
95317: PUSH
95318: LD_INT 4
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: LD_INT 1
95327: PUSH
95328: LD_INT 5
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 0
95337: PUSH
95338: LD_INT 5
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 1
95347: NEG
95348: PUSH
95349: LD_INT 4
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 1
95358: NEG
95359: PUSH
95360: LD_INT 3
95362: PUSH
95363: EMPTY
95364: LIST
95365: LIST
95366: PUSH
95367: LD_INT 2
95369: PUSH
95370: LD_INT 5
95372: PUSH
95373: EMPTY
95374: LIST
95375: LIST
95376: PUSH
95377: LD_INT 2
95379: NEG
95380: PUSH
95381: LD_INT 3
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: EMPTY
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95435: LD_ADDR_VAR 0 34
95439: PUSH
95440: LD_INT 0
95442: PUSH
95443: LD_INT 4
95445: NEG
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 0
95453: PUSH
95454: LD_INT 5
95456: NEG
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 1
95464: PUSH
95465: LD_INT 4
95467: NEG
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 1
95475: PUSH
95476: LD_INT 3
95478: NEG
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 0
95486: PUSH
95487: LD_INT 3
95489: NEG
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 1
95497: NEG
95498: PUSH
95499: LD_INT 4
95501: NEG
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 1
95509: NEG
95510: PUSH
95511: LD_INT 5
95513: NEG
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: LD_INT 2
95521: PUSH
95522: LD_INT 3
95524: NEG
95525: PUSH
95526: EMPTY
95527: LIST
95528: LIST
95529: PUSH
95530: LD_INT 2
95532: NEG
95533: PUSH
95534: LD_INT 5
95536: NEG
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: LD_INT 3
95544: PUSH
95545: LD_INT 0
95547: PUSH
95548: EMPTY
95549: LIST
95550: LIST
95551: PUSH
95552: LD_INT 3
95554: PUSH
95555: LD_INT 1
95557: NEG
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 4
95565: PUSH
95566: LD_INT 0
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: PUSH
95573: LD_INT 4
95575: PUSH
95576: LD_INT 1
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 3
95585: PUSH
95586: LD_INT 1
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 2
95595: PUSH
95596: LD_INT 0
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 2
95605: PUSH
95606: LD_INT 1
95608: NEG
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 2
95616: PUSH
95617: LD_INT 2
95619: NEG
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: LD_INT 4
95627: PUSH
95628: LD_INT 2
95630: PUSH
95631: EMPTY
95632: LIST
95633: LIST
95634: PUSH
95635: LD_INT 4
95637: PUSH
95638: LD_INT 4
95640: PUSH
95641: EMPTY
95642: LIST
95643: LIST
95644: PUSH
95645: LD_INT 4
95647: PUSH
95648: LD_INT 3
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 5
95657: PUSH
95658: LD_INT 4
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: LD_INT 5
95667: PUSH
95668: LD_INT 5
95670: PUSH
95671: EMPTY
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 4
95677: PUSH
95678: LD_INT 5
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 3
95687: PUSH
95688: LD_INT 4
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 3
95697: PUSH
95698: LD_INT 3
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 5
95707: PUSH
95708: LD_INT 3
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 3
95717: PUSH
95718: LD_INT 5
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 0
95727: PUSH
95728: LD_INT 3
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 0
95737: PUSH
95738: LD_INT 2
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: PUSH
95745: LD_INT 1
95747: PUSH
95748: LD_INT 3
95750: PUSH
95751: EMPTY
95752: LIST
95753: LIST
95754: PUSH
95755: LD_INT 1
95757: PUSH
95758: LD_INT 4
95760: PUSH
95761: EMPTY
95762: LIST
95763: LIST
95764: PUSH
95765: LD_INT 0
95767: PUSH
95768: LD_INT 4
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: LD_INT 1
95777: NEG
95778: PUSH
95779: LD_INT 3
95781: PUSH
95782: EMPTY
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 1
95788: NEG
95789: PUSH
95790: LD_INT 2
95792: PUSH
95793: EMPTY
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 2
95799: PUSH
95800: LD_INT 4
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 2
95809: NEG
95810: PUSH
95811: LD_INT 2
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: PUSH
95818: LD_INT 4
95820: NEG
95821: PUSH
95822: LD_INT 0
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PUSH
95829: LD_INT 4
95831: NEG
95832: PUSH
95833: LD_INT 1
95835: NEG
95836: PUSH
95837: EMPTY
95838: LIST
95839: LIST
95840: PUSH
95841: LD_INT 3
95843: NEG
95844: PUSH
95845: LD_INT 0
95847: PUSH
95848: EMPTY
95849: LIST
95850: LIST
95851: PUSH
95852: LD_INT 3
95854: NEG
95855: PUSH
95856: LD_INT 1
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: PUSH
95863: LD_INT 4
95865: NEG
95866: PUSH
95867: LD_INT 1
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: PUSH
95874: LD_INT 5
95876: NEG
95877: PUSH
95878: LD_INT 0
95880: PUSH
95881: EMPTY
95882: LIST
95883: LIST
95884: PUSH
95885: LD_INT 5
95887: NEG
95888: PUSH
95889: LD_INT 1
95891: NEG
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 5
95899: NEG
95900: PUSH
95901: LD_INT 2
95903: NEG
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 3
95911: NEG
95912: PUSH
95913: LD_INT 2
95915: PUSH
95916: EMPTY
95917: LIST
95918: LIST
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: ST_TO_ADDR
// end ; end ;
95967: GO 95970
95969: POP
// case btype of b_depot , b_warehouse :
95970: LD_VAR 0 1
95974: PUSH
95975: LD_INT 0
95977: DOUBLE
95978: EQUAL
95979: IFTRUE 95989
95981: LD_INT 1
95983: DOUBLE
95984: EQUAL
95985: IFTRUE 95989
95987: GO 96190
95989: POP
// case nation of nation_american :
95990: LD_VAR 0 5
95994: PUSH
95995: LD_INT 1
95997: DOUBLE
95998: EQUAL
95999: IFTRUE 96003
96001: GO 96059
96003: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96004: LD_ADDR_VAR 0 9
96008: PUSH
96009: LD_VAR 0 11
96013: PUSH
96014: LD_VAR 0 12
96018: PUSH
96019: LD_VAR 0 13
96023: PUSH
96024: LD_VAR 0 14
96028: PUSH
96029: LD_VAR 0 15
96033: PUSH
96034: LD_VAR 0 16
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: PUSH
96047: LD_VAR 0 4
96051: PUSH
96052: LD_INT 1
96054: PLUS
96055: ARRAY
96056: ST_TO_ADDR
96057: GO 96188
96059: LD_INT 2
96061: DOUBLE
96062: EQUAL
96063: IFTRUE 96067
96065: GO 96123
96067: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96068: LD_ADDR_VAR 0 9
96072: PUSH
96073: LD_VAR 0 17
96077: PUSH
96078: LD_VAR 0 18
96082: PUSH
96083: LD_VAR 0 19
96087: PUSH
96088: LD_VAR 0 20
96092: PUSH
96093: LD_VAR 0 21
96097: PUSH
96098: LD_VAR 0 22
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: PUSH
96111: LD_VAR 0 4
96115: PUSH
96116: LD_INT 1
96118: PLUS
96119: ARRAY
96120: ST_TO_ADDR
96121: GO 96188
96123: LD_INT 3
96125: DOUBLE
96126: EQUAL
96127: IFTRUE 96131
96129: GO 96187
96131: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96132: LD_ADDR_VAR 0 9
96136: PUSH
96137: LD_VAR 0 23
96141: PUSH
96142: LD_VAR 0 24
96146: PUSH
96147: LD_VAR 0 25
96151: PUSH
96152: LD_VAR 0 26
96156: PUSH
96157: LD_VAR 0 27
96161: PUSH
96162: LD_VAR 0 28
96166: PUSH
96167: EMPTY
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: PUSH
96175: LD_VAR 0 4
96179: PUSH
96180: LD_INT 1
96182: PLUS
96183: ARRAY
96184: ST_TO_ADDR
96185: GO 96188
96187: POP
96188: GO 96743
96190: LD_INT 2
96192: DOUBLE
96193: EQUAL
96194: IFTRUE 96204
96196: LD_INT 3
96198: DOUBLE
96199: EQUAL
96200: IFTRUE 96204
96202: GO 96260
96204: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96205: LD_ADDR_VAR 0 9
96209: PUSH
96210: LD_VAR 0 29
96214: PUSH
96215: LD_VAR 0 30
96219: PUSH
96220: LD_VAR 0 31
96224: PUSH
96225: LD_VAR 0 32
96229: PUSH
96230: LD_VAR 0 33
96234: PUSH
96235: LD_VAR 0 34
96239: PUSH
96240: EMPTY
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: PUSH
96248: LD_VAR 0 4
96252: PUSH
96253: LD_INT 1
96255: PLUS
96256: ARRAY
96257: ST_TO_ADDR
96258: GO 96743
96260: LD_INT 16
96262: DOUBLE
96263: EQUAL
96264: IFTRUE 96322
96266: LD_INT 17
96268: DOUBLE
96269: EQUAL
96270: IFTRUE 96322
96272: LD_INT 18
96274: DOUBLE
96275: EQUAL
96276: IFTRUE 96322
96278: LD_INT 19
96280: DOUBLE
96281: EQUAL
96282: IFTRUE 96322
96284: LD_INT 22
96286: DOUBLE
96287: EQUAL
96288: IFTRUE 96322
96290: LD_INT 20
96292: DOUBLE
96293: EQUAL
96294: IFTRUE 96322
96296: LD_INT 21
96298: DOUBLE
96299: EQUAL
96300: IFTRUE 96322
96302: LD_INT 23
96304: DOUBLE
96305: EQUAL
96306: IFTRUE 96322
96308: LD_INT 24
96310: DOUBLE
96311: EQUAL
96312: IFTRUE 96322
96314: LD_INT 25
96316: DOUBLE
96317: EQUAL
96318: IFTRUE 96322
96320: GO 96378
96322: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96323: LD_ADDR_VAR 0 9
96327: PUSH
96328: LD_VAR 0 35
96332: PUSH
96333: LD_VAR 0 36
96337: PUSH
96338: LD_VAR 0 37
96342: PUSH
96343: LD_VAR 0 38
96347: PUSH
96348: LD_VAR 0 39
96352: PUSH
96353: LD_VAR 0 40
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: LIST
96362: LIST
96363: LIST
96364: LIST
96365: PUSH
96366: LD_VAR 0 4
96370: PUSH
96371: LD_INT 1
96373: PLUS
96374: ARRAY
96375: ST_TO_ADDR
96376: GO 96743
96378: LD_INT 6
96380: DOUBLE
96381: EQUAL
96382: IFTRUE 96434
96384: LD_INT 7
96386: DOUBLE
96387: EQUAL
96388: IFTRUE 96434
96390: LD_INT 8
96392: DOUBLE
96393: EQUAL
96394: IFTRUE 96434
96396: LD_INT 13
96398: DOUBLE
96399: EQUAL
96400: IFTRUE 96434
96402: LD_INT 12
96404: DOUBLE
96405: EQUAL
96406: IFTRUE 96434
96408: LD_INT 15
96410: DOUBLE
96411: EQUAL
96412: IFTRUE 96434
96414: LD_INT 11
96416: DOUBLE
96417: EQUAL
96418: IFTRUE 96434
96420: LD_INT 14
96422: DOUBLE
96423: EQUAL
96424: IFTRUE 96434
96426: LD_INT 10
96428: DOUBLE
96429: EQUAL
96430: IFTRUE 96434
96432: GO 96490
96434: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96435: LD_ADDR_VAR 0 9
96439: PUSH
96440: LD_VAR 0 41
96444: PUSH
96445: LD_VAR 0 42
96449: PUSH
96450: LD_VAR 0 43
96454: PUSH
96455: LD_VAR 0 44
96459: PUSH
96460: LD_VAR 0 45
96464: PUSH
96465: LD_VAR 0 46
96469: PUSH
96470: EMPTY
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: PUSH
96478: LD_VAR 0 4
96482: PUSH
96483: LD_INT 1
96485: PLUS
96486: ARRAY
96487: ST_TO_ADDR
96488: GO 96743
96490: LD_INT 36
96492: DOUBLE
96493: EQUAL
96494: IFTRUE 96498
96496: GO 96554
96498: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96499: LD_ADDR_VAR 0 9
96503: PUSH
96504: LD_VAR 0 47
96508: PUSH
96509: LD_VAR 0 48
96513: PUSH
96514: LD_VAR 0 49
96518: PUSH
96519: LD_VAR 0 50
96523: PUSH
96524: LD_VAR 0 51
96528: PUSH
96529: LD_VAR 0 52
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: PUSH
96542: LD_VAR 0 4
96546: PUSH
96547: LD_INT 1
96549: PLUS
96550: ARRAY
96551: ST_TO_ADDR
96552: GO 96743
96554: LD_INT 4
96556: DOUBLE
96557: EQUAL
96558: IFTRUE 96580
96560: LD_INT 5
96562: DOUBLE
96563: EQUAL
96564: IFTRUE 96580
96566: LD_INT 34
96568: DOUBLE
96569: EQUAL
96570: IFTRUE 96580
96572: LD_INT 37
96574: DOUBLE
96575: EQUAL
96576: IFTRUE 96580
96578: GO 96636
96580: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96581: LD_ADDR_VAR 0 9
96585: PUSH
96586: LD_VAR 0 53
96590: PUSH
96591: LD_VAR 0 54
96595: PUSH
96596: LD_VAR 0 55
96600: PUSH
96601: LD_VAR 0 56
96605: PUSH
96606: LD_VAR 0 57
96610: PUSH
96611: LD_VAR 0 58
96615: PUSH
96616: EMPTY
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: PUSH
96624: LD_VAR 0 4
96628: PUSH
96629: LD_INT 1
96631: PLUS
96632: ARRAY
96633: ST_TO_ADDR
96634: GO 96743
96636: LD_INT 31
96638: DOUBLE
96639: EQUAL
96640: IFTRUE 96686
96642: LD_INT 32
96644: DOUBLE
96645: EQUAL
96646: IFTRUE 96686
96648: LD_INT 33
96650: DOUBLE
96651: EQUAL
96652: IFTRUE 96686
96654: LD_INT 27
96656: DOUBLE
96657: EQUAL
96658: IFTRUE 96686
96660: LD_INT 26
96662: DOUBLE
96663: EQUAL
96664: IFTRUE 96686
96666: LD_INT 28
96668: DOUBLE
96669: EQUAL
96670: IFTRUE 96686
96672: LD_INT 29
96674: DOUBLE
96675: EQUAL
96676: IFTRUE 96686
96678: LD_INT 30
96680: DOUBLE
96681: EQUAL
96682: IFTRUE 96686
96684: GO 96742
96686: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96687: LD_ADDR_VAR 0 9
96691: PUSH
96692: LD_VAR 0 59
96696: PUSH
96697: LD_VAR 0 60
96701: PUSH
96702: LD_VAR 0 61
96706: PUSH
96707: LD_VAR 0 62
96711: PUSH
96712: LD_VAR 0 63
96716: PUSH
96717: LD_VAR 0 64
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: PUSH
96730: LD_VAR 0 4
96734: PUSH
96735: LD_INT 1
96737: PLUS
96738: ARRAY
96739: ST_TO_ADDR
96740: GO 96743
96742: POP
// temp_list2 = [ ] ;
96743: LD_ADDR_VAR 0 10
96747: PUSH
96748: EMPTY
96749: ST_TO_ADDR
// for i in temp_list do
96750: LD_ADDR_VAR 0 8
96754: PUSH
96755: LD_VAR 0 9
96759: PUSH
96760: FOR_IN
96761: IFFALSE 96813
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96763: LD_ADDR_VAR 0 10
96767: PUSH
96768: LD_VAR 0 10
96772: PUSH
96773: LD_VAR 0 8
96777: PUSH
96778: LD_INT 1
96780: ARRAY
96781: PUSH
96782: LD_VAR 0 2
96786: PLUS
96787: PUSH
96788: LD_VAR 0 8
96792: PUSH
96793: LD_INT 2
96795: ARRAY
96796: PUSH
96797: LD_VAR 0 3
96801: PLUS
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: EMPTY
96808: LIST
96809: ADD
96810: ST_TO_ADDR
96811: GO 96760
96813: POP
96814: POP
// result = temp_list2 ;
96815: LD_ADDR_VAR 0 7
96819: PUSH
96820: LD_VAR 0 10
96824: ST_TO_ADDR
// end ;
96825: LD_VAR 0 7
96829: RET
// export function EnemyInRange ( unit , dist ) ; begin
96830: LD_INT 0
96832: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96833: LD_ADDR_VAR 0 3
96837: PUSH
96838: LD_VAR 0 1
96842: PPUSH
96843: CALL_OW 255
96847: PPUSH
96848: LD_VAR 0 1
96852: PPUSH
96853: CALL_OW 250
96857: PPUSH
96858: LD_VAR 0 1
96862: PPUSH
96863: CALL_OW 251
96867: PPUSH
96868: LD_VAR 0 2
96872: PPUSH
96873: CALL 70203 0 4
96877: PUSH
96878: LD_INT 4
96880: ARRAY
96881: ST_TO_ADDR
// end ;
96882: LD_VAR 0 3
96886: RET
// export function PlayerSeeMe ( unit ) ; begin
96887: LD_INT 0
96889: PPUSH
// result := See ( your_side , unit ) ;
96890: LD_ADDR_VAR 0 2
96894: PUSH
96895: LD_OWVAR 2
96899: PPUSH
96900: LD_VAR 0 1
96904: PPUSH
96905: CALL_OW 292
96909: ST_TO_ADDR
// end ;
96910: LD_VAR 0 2
96914: RET
// export function ReverseDir ( unit ) ; begin
96915: LD_INT 0
96917: PPUSH
// if not unit then
96918: LD_VAR 0 1
96922: NOT
96923: IFFALSE 96927
// exit ;
96925: GO 96950
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96927: LD_ADDR_VAR 0 2
96931: PUSH
96932: LD_VAR 0 1
96936: PPUSH
96937: CALL_OW 254
96941: PUSH
96942: LD_INT 3
96944: PLUS
96945: PUSH
96946: LD_INT 6
96948: MOD
96949: ST_TO_ADDR
// end ;
96950: LD_VAR 0 2
96954: RET
// export function ReverseArray ( array ) ; var i ; begin
96955: LD_INT 0
96957: PPUSH
96958: PPUSH
// if not array then
96959: LD_VAR 0 1
96963: NOT
96964: IFFALSE 96968
// exit ;
96966: GO 97023
// result := [ ] ;
96968: LD_ADDR_VAR 0 2
96972: PUSH
96973: EMPTY
96974: ST_TO_ADDR
// for i := array downto 1 do
96975: LD_ADDR_VAR 0 3
96979: PUSH
96980: DOUBLE
96981: LD_VAR 0 1
96985: INC
96986: ST_TO_ADDR
96987: LD_INT 1
96989: PUSH
96990: FOR_DOWNTO
96991: IFFALSE 97021
// result := Join ( result , array [ i ] ) ;
96993: LD_ADDR_VAR 0 2
96997: PUSH
96998: LD_VAR 0 2
97002: PPUSH
97003: LD_VAR 0 1
97007: PUSH
97008: LD_VAR 0 3
97012: ARRAY
97013: PPUSH
97014: CALL 101668 0 2
97018: ST_TO_ADDR
97019: GO 96990
97021: POP
97022: POP
// end ;
97023: LD_VAR 0 2
97027: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
97028: LD_INT 0
97030: PPUSH
97031: PPUSH
97032: PPUSH
97033: PPUSH
97034: PPUSH
97035: PPUSH
// if not unit or not hexes then
97036: LD_VAR 0 1
97040: NOT
97041: PUSH
97042: LD_VAR 0 2
97046: NOT
97047: OR
97048: IFFALSE 97052
// exit ;
97050: GO 97175
// dist := 9999 ;
97052: LD_ADDR_VAR 0 5
97056: PUSH
97057: LD_INT 9999
97059: ST_TO_ADDR
// for i = 1 to hexes do
97060: LD_ADDR_VAR 0 4
97064: PUSH
97065: DOUBLE
97066: LD_INT 1
97068: DEC
97069: ST_TO_ADDR
97070: LD_VAR 0 2
97074: PUSH
97075: FOR_TO
97076: IFFALSE 97163
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97078: LD_ADDR_VAR 0 6
97082: PUSH
97083: LD_VAR 0 1
97087: PPUSH
97088: LD_VAR 0 2
97092: PUSH
97093: LD_VAR 0 4
97097: ARRAY
97098: PUSH
97099: LD_INT 1
97101: ARRAY
97102: PPUSH
97103: LD_VAR 0 2
97107: PUSH
97108: LD_VAR 0 4
97112: ARRAY
97113: PUSH
97114: LD_INT 2
97116: ARRAY
97117: PPUSH
97118: CALL_OW 297
97122: ST_TO_ADDR
// if tdist < dist then
97123: LD_VAR 0 6
97127: PUSH
97128: LD_VAR 0 5
97132: LESS
97133: IFFALSE 97161
// begin hex := hexes [ i ] ;
97135: LD_ADDR_VAR 0 8
97139: PUSH
97140: LD_VAR 0 2
97144: PUSH
97145: LD_VAR 0 4
97149: ARRAY
97150: ST_TO_ADDR
// dist := tdist ;
97151: LD_ADDR_VAR 0 5
97155: PUSH
97156: LD_VAR 0 6
97160: ST_TO_ADDR
// end ; end ;
97161: GO 97075
97163: POP
97164: POP
// result := hex ;
97165: LD_ADDR_VAR 0 3
97169: PUSH
97170: LD_VAR 0 8
97174: ST_TO_ADDR
// end ;
97175: LD_VAR 0 3
97179: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97180: LD_INT 0
97182: PPUSH
97183: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97184: LD_VAR 0 1
97188: NOT
97189: PUSH
97190: LD_VAR 0 1
97194: PUSH
97195: LD_INT 21
97197: PUSH
97198: LD_INT 2
97200: PUSH
97201: EMPTY
97202: LIST
97203: LIST
97204: PUSH
97205: LD_INT 23
97207: PUSH
97208: LD_INT 2
97210: PUSH
97211: EMPTY
97212: LIST
97213: LIST
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: PPUSH
97219: CALL_OW 69
97223: IN
97224: NOT
97225: OR
97226: IFFALSE 97230
// exit ;
97228: GO 97277
// for i = 1 to 3 do
97230: LD_ADDR_VAR 0 3
97234: PUSH
97235: DOUBLE
97236: LD_INT 1
97238: DEC
97239: ST_TO_ADDR
97240: LD_INT 3
97242: PUSH
97243: FOR_TO
97244: IFFALSE 97275
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97246: LD_VAR 0 1
97250: PPUSH
97251: CALL_OW 250
97255: PPUSH
97256: LD_VAR 0 1
97260: PPUSH
97261: CALL_OW 251
97265: PPUSH
97266: LD_INT 1
97268: PPUSH
97269: CALL_OW 453
97273: GO 97243
97275: POP
97276: POP
// end ;
97277: LD_VAR 0 2
97281: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97282: LD_INT 0
97284: PPUSH
97285: PPUSH
97286: PPUSH
97287: PPUSH
97288: PPUSH
97289: PPUSH
// if not unit or not enemy_unit then
97290: LD_VAR 0 1
97294: NOT
97295: PUSH
97296: LD_VAR 0 2
97300: NOT
97301: OR
97302: IFFALSE 97306
// exit ;
97304: GO 97773
// if GetLives ( i ) < 250 then
97306: LD_VAR 0 4
97310: PPUSH
97311: CALL_OW 256
97315: PUSH
97316: LD_INT 250
97318: LESS
97319: IFFALSE 97332
// begin ComAutodestruct ( i ) ;
97321: LD_VAR 0 4
97325: PPUSH
97326: CALL 97180 0 1
// exit ;
97330: GO 97773
// end ; x := GetX ( enemy_unit ) ;
97332: LD_ADDR_VAR 0 7
97336: PUSH
97337: LD_VAR 0 2
97341: PPUSH
97342: CALL_OW 250
97346: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97347: LD_ADDR_VAR 0 8
97351: PUSH
97352: LD_VAR 0 2
97356: PPUSH
97357: CALL_OW 251
97361: ST_TO_ADDR
// if not x or not y then
97362: LD_VAR 0 7
97366: NOT
97367: PUSH
97368: LD_VAR 0 8
97372: NOT
97373: OR
97374: IFFALSE 97378
// exit ;
97376: GO 97773
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97378: LD_ADDR_VAR 0 6
97382: PUSH
97383: LD_VAR 0 7
97387: PPUSH
97388: LD_INT 0
97390: PPUSH
97391: LD_INT 4
97393: PPUSH
97394: CALL_OW 272
97398: PUSH
97399: LD_VAR 0 8
97403: PPUSH
97404: LD_INT 0
97406: PPUSH
97407: LD_INT 4
97409: PPUSH
97410: CALL_OW 273
97414: PUSH
97415: EMPTY
97416: LIST
97417: LIST
97418: PUSH
97419: LD_VAR 0 7
97423: PPUSH
97424: LD_INT 1
97426: PPUSH
97427: LD_INT 4
97429: PPUSH
97430: CALL_OW 272
97434: PUSH
97435: LD_VAR 0 8
97439: PPUSH
97440: LD_INT 1
97442: PPUSH
97443: LD_INT 4
97445: PPUSH
97446: CALL_OW 273
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PUSH
97455: LD_VAR 0 7
97459: PPUSH
97460: LD_INT 2
97462: PPUSH
97463: LD_INT 4
97465: PPUSH
97466: CALL_OW 272
97470: PUSH
97471: LD_VAR 0 8
97475: PPUSH
97476: LD_INT 2
97478: PPUSH
97479: LD_INT 4
97481: PPUSH
97482: CALL_OW 273
97486: PUSH
97487: EMPTY
97488: LIST
97489: LIST
97490: PUSH
97491: LD_VAR 0 7
97495: PPUSH
97496: LD_INT 3
97498: PPUSH
97499: LD_INT 4
97501: PPUSH
97502: CALL_OW 272
97506: PUSH
97507: LD_VAR 0 8
97511: PPUSH
97512: LD_INT 3
97514: PPUSH
97515: LD_INT 4
97517: PPUSH
97518: CALL_OW 273
97522: PUSH
97523: EMPTY
97524: LIST
97525: LIST
97526: PUSH
97527: LD_VAR 0 7
97531: PPUSH
97532: LD_INT 4
97534: PPUSH
97535: LD_INT 4
97537: PPUSH
97538: CALL_OW 272
97542: PUSH
97543: LD_VAR 0 8
97547: PPUSH
97548: LD_INT 4
97550: PPUSH
97551: LD_INT 4
97553: PPUSH
97554: CALL_OW 273
97558: PUSH
97559: EMPTY
97560: LIST
97561: LIST
97562: PUSH
97563: LD_VAR 0 7
97567: PPUSH
97568: LD_INT 5
97570: PPUSH
97571: LD_INT 4
97573: PPUSH
97574: CALL_OW 272
97578: PUSH
97579: LD_VAR 0 8
97583: PPUSH
97584: LD_INT 5
97586: PPUSH
97587: LD_INT 4
97589: PPUSH
97590: CALL_OW 273
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: LIST
97606: ST_TO_ADDR
// for i = tmp downto 1 do
97607: LD_ADDR_VAR 0 4
97611: PUSH
97612: DOUBLE
97613: LD_VAR 0 6
97617: INC
97618: ST_TO_ADDR
97619: LD_INT 1
97621: PUSH
97622: FOR_DOWNTO
97623: IFFALSE 97724
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97625: LD_VAR 0 6
97629: PUSH
97630: LD_VAR 0 4
97634: ARRAY
97635: PUSH
97636: LD_INT 1
97638: ARRAY
97639: PPUSH
97640: LD_VAR 0 6
97644: PUSH
97645: LD_VAR 0 4
97649: ARRAY
97650: PUSH
97651: LD_INT 2
97653: ARRAY
97654: PPUSH
97655: CALL_OW 488
97659: NOT
97660: PUSH
97661: LD_VAR 0 6
97665: PUSH
97666: LD_VAR 0 4
97670: ARRAY
97671: PUSH
97672: LD_INT 1
97674: ARRAY
97675: PPUSH
97676: LD_VAR 0 6
97680: PUSH
97681: LD_VAR 0 4
97685: ARRAY
97686: PUSH
97687: LD_INT 2
97689: ARRAY
97690: PPUSH
97691: CALL_OW 428
97695: PUSH
97696: LD_INT 0
97698: NONEQUAL
97699: OR
97700: IFFALSE 97722
// tmp := Delete ( tmp , i ) ;
97702: LD_ADDR_VAR 0 6
97706: PUSH
97707: LD_VAR 0 6
97711: PPUSH
97712: LD_VAR 0 4
97716: PPUSH
97717: CALL_OW 3
97721: ST_TO_ADDR
97722: GO 97622
97724: POP
97725: POP
// j := GetClosestHex ( unit , tmp ) ;
97726: LD_ADDR_VAR 0 5
97730: PUSH
97731: LD_VAR 0 1
97735: PPUSH
97736: LD_VAR 0 6
97740: PPUSH
97741: CALL 97028 0 2
97745: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97746: LD_VAR 0 1
97750: PPUSH
97751: LD_VAR 0 5
97755: PUSH
97756: LD_INT 1
97758: ARRAY
97759: PPUSH
97760: LD_VAR 0 5
97764: PUSH
97765: LD_INT 2
97767: ARRAY
97768: PPUSH
97769: CALL_OW 111
// end ;
97773: LD_VAR 0 3
97777: RET
// export function PrepareApemanSoldier ( ) ; begin
97778: LD_INT 0
97780: PPUSH
// uc_nation := 0 ;
97781: LD_ADDR_OWVAR 21
97785: PUSH
97786: LD_INT 0
97788: ST_TO_ADDR
// hc_sex := sex_male ;
97789: LD_ADDR_OWVAR 27
97793: PUSH
97794: LD_INT 1
97796: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
97797: LD_ADDR_OWVAR 28
97801: PUSH
97802: LD_INT 15
97804: ST_TO_ADDR
// hc_gallery :=  ;
97805: LD_ADDR_OWVAR 33
97809: PUSH
97810: LD_STRING 
97812: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97813: LD_ADDR_OWVAR 31
97817: PUSH
97818: LD_INT 0
97820: PPUSH
97821: LD_INT 3
97823: PPUSH
97824: CALL_OW 12
97828: PUSH
97829: LD_INT 0
97831: PPUSH
97832: LD_INT 3
97834: PPUSH
97835: CALL_OW 12
97839: PUSH
97840: LD_INT 0
97842: PUSH
97843: LD_INT 0
97845: PUSH
97846: EMPTY
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: ST_TO_ADDR
// end ;
97852: LD_VAR 0 1
97856: RET
// export function PrepareApemanEngineer ( ) ; begin
97857: LD_INT 0
97859: PPUSH
// uc_nation := 0 ;
97860: LD_ADDR_OWVAR 21
97864: PUSH
97865: LD_INT 0
97867: ST_TO_ADDR
// hc_sex := sex_male ;
97868: LD_ADDR_OWVAR 27
97872: PUSH
97873: LD_INT 1
97875: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
97876: LD_ADDR_OWVAR 28
97880: PUSH
97881: LD_INT 16
97883: ST_TO_ADDR
// hc_gallery :=  ;
97884: LD_ADDR_OWVAR 33
97888: PUSH
97889: LD_STRING 
97891: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97892: LD_ADDR_OWVAR 31
97896: PUSH
97897: LD_INT 0
97899: PPUSH
97900: LD_INT 3
97902: PPUSH
97903: CALL_OW 12
97907: PUSH
97908: LD_INT 0
97910: PPUSH
97911: LD_INT 3
97913: PPUSH
97914: CALL_OW 12
97918: PUSH
97919: LD_INT 0
97921: PUSH
97922: LD_INT 0
97924: PUSH
97925: EMPTY
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: ST_TO_ADDR
// end ;
97931: LD_VAR 0 1
97935: RET
// export function PrepareApeman ( agressivity ) ; begin
97936: LD_INT 0
97938: PPUSH
// uc_side := 0 ;
97939: LD_ADDR_OWVAR 20
97943: PUSH
97944: LD_INT 0
97946: ST_TO_ADDR
// uc_nation := 0 ;
97947: LD_ADDR_OWVAR 21
97951: PUSH
97952: LD_INT 0
97954: ST_TO_ADDR
// hc_sex := sex_male ;
97955: LD_ADDR_OWVAR 27
97959: PUSH
97960: LD_INT 1
97962: ST_TO_ADDR
// hc_class := class_apeman ;
97963: LD_ADDR_OWVAR 28
97967: PUSH
97968: LD_INT 12
97970: ST_TO_ADDR
// hc_gallery :=  ;
97971: LD_ADDR_OWVAR 33
97975: PUSH
97976: LD_STRING 
97978: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97979: LD_ADDR_OWVAR 35
97983: PUSH
97984: LD_VAR 0 1
97988: NEG
97989: PPUSH
97990: LD_VAR 0 1
97994: PPUSH
97995: CALL_OW 12
97999: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
98000: LD_ADDR_OWVAR 31
98004: PUSH
98005: LD_INT 0
98007: PPUSH
98008: LD_INT 3
98010: PPUSH
98011: CALL_OW 12
98015: PUSH
98016: LD_INT 0
98018: PPUSH
98019: LD_INT 3
98021: PPUSH
98022: CALL_OW 12
98026: PUSH
98027: LD_INT 0
98029: PUSH
98030: LD_INT 0
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: ST_TO_ADDR
// end ;
98039: LD_VAR 0 2
98043: RET
// export function PrepareTiger ( agressivity ) ; begin
98044: LD_INT 0
98046: PPUSH
// uc_side := 0 ;
98047: LD_ADDR_OWVAR 20
98051: PUSH
98052: LD_INT 0
98054: ST_TO_ADDR
// uc_nation := 0 ;
98055: LD_ADDR_OWVAR 21
98059: PUSH
98060: LD_INT 0
98062: ST_TO_ADDR
// hc_class := class_tiger ;
98063: LD_ADDR_OWVAR 28
98067: PUSH
98068: LD_INT 14
98070: ST_TO_ADDR
// hc_gallery :=  ;
98071: LD_ADDR_OWVAR 33
98075: PUSH
98076: LD_STRING 
98078: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
98079: LD_ADDR_OWVAR 35
98083: PUSH
98084: LD_VAR 0 1
98088: NEG
98089: PPUSH
98090: LD_VAR 0 1
98094: PPUSH
98095: CALL_OW 12
98099: ST_TO_ADDR
// end ;
98100: LD_VAR 0 2
98104: RET
// export function PrepareEnchidna ( ) ; begin
98105: LD_INT 0
98107: PPUSH
// uc_side := 0 ;
98108: LD_ADDR_OWVAR 20
98112: PUSH
98113: LD_INT 0
98115: ST_TO_ADDR
// uc_nation := 0 ;
98116: LD_ADDR_OWVAR 21
98120: PUSH
98121: LD_INT 0
98123: ST_TO_ADDR
// hc_class := class_baggie ;
98124: LD_ADDR_OWVAR 28
98128: PUSH
98129: LD_INT 13
98131: ST_TO_ADDR
// hc_gallery :=  ;
98132: LD_ADDR_OWVAR 33
98136: PUSH
98137: LD_STRING 
98139: ST_TO_ADDR
// end ;
98140: LD_VAR 0 1
98144: RET
// export function PrepareFrog ( ) ; begin
98145: LD_INT 0
98147: PPUSH
// uc_side := 0 ;
98148: LD_ADDR_OWVAR 20
98152: PUSH
98153: LD_INT 0
98155: ST_TO_ADDR
// uc_nation := 0 ;
98156: LD_ADDR_OWVAR 21
98160: PUSH
98161: LD_INT 0
98163: ST_TO_ADDR
// hc_class := class_frog ;
98164: LD_ADDR_OWVAR 28
98168: PUSH
98169: LD_INT 19
98171: ST_TO_ADDR
// hc_gallery :=  ;
98172: LD_ADDR_OWVAR 33
98176: PUSH
98177: LD_STRING 
98179: ST_TO_ADDR
// end ;
98180: LD_VAR 0 1
98184: RET
// export function PrepareFish ( ) ; begin
98185: LD_INT 0
98187: PPUSH
// uc_side := 0 ;
98188: LD_ADDR_OWVAR 20
98192: PUSH
98193: LD_INT 0
98195: ST_TO_ADDR
// uc_nation := 0 ;
98196: LD_ADDR_OWVAR 21
98200: PUSH
98201: LD_INT 0
98203: ST_TO_ADDR
// hc_class := class_fish ;
98204: LD_ADDR_OWVAR 28
98208: PUSH
98209: LD_INT 20
98211: ST_TO_ADDR
// hc_gallery :=  ;
98212: LD_ADDR_OWVAR 33
98216: PUSH
98217: LD_STRING 
98219: ST_TO_ADDR
// end ;
98220: LD_VAR 0 1
98224: RET
// export function PrepareBird ( ) ; begin
98225: LD_INT 0
98227: PPUSH
// uc_side := 0 ;
98228: LD_ADDR_OWVAR 20
98232: PUSH
98233: LD_INT 0
98235: ST_TO_ADDR
// uc_nation := 0 ;
98236: LD_ADDR_OWVAR 21
98240: PUSH
98241: LD_INT 0
98243: ST_TO_ADDR
// hc_class := class_phororhacos ;
98244: LD_ADDR_OWVAR 28
98248: PUSH
98249: LD_INT 18
98251: ST_TO_ADDR
// hc_gallery :=  ;
98252: LD_ADDR_OWVAR 33
98256: PUSH
98257: LD_STRING 
98259: ST_TO_ADDR
// end ;
98260: LD_VAR 0 1
98264: RET
// export function PrepareHorse ( ) ; begin
98265: LD_INT 0
98267: PPUSH
// uc_side := 0 ;
98268: LD_ADDR_OWVAR 20
98272: PUSH
98273: LD_INT 0
98275: ST_TO_ADDR
// uc_nation := 0 ;
98276: LD_ADDR_OWVAR 21
98280: PUSH
98281: LD_INT 0
98283: ST_TO_ADDR
// hc_class := class_horse ;
98284: LD_ADDR_OWVAR 28
98288: PUSH
98289: LD_INT 21
98291: ST_TO_ADDR
// hc_gallery :=  ;
98292: LD_ADDR_OWVAR 33
98296: PUSH
98297: LD_STRING 
98299: ST_TO_ADDR
// end ;
98300: LD_VAR 0 1
98304: RET
// export function PrepareMastodont ( ) ; begin
98305: LD_INT 0
98307: PPUSH
// uc_side := 0 ;
98308: LD_ADDR_OWVAR 20
98312: PUSH
98313: LD_INT 0
98315: ST_TO_ADDR
// uc_nation := 0 ;
98316: LD_ADDR_OWVAR 21
98320: PUSH
98321: LD_INT 0
98323: ST_TO_ADDR
// vc_chassis := class_mastodont ;
98324: LD_ADDR_OWVAR 37
98328: PUSH
98329: LD_INT 31
98331: ST_TO_ADDR
// vc_control := control_rider ;
98332: LD_ADDR_OWVAR 38
98336: PUSH
98337: LD_INT 4
98339: ST_TO_ADDR
// end ;
98340: LD_VAR 0 1
98344: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98345: LD_INT 0
98347: PPUSH
98348: PPUSH
98349: PPUSH
// uc_side = 0 ;
98350: LD_ADDR_OWVAR 20
98354: PUSH
98355: LD_INT 0
98357: ST_TO_ADDR
// uc_nation = 0 ;
98358: LD_ADDR_OWVAR 21
98362: PUSH
98363: LD_INT 0
98365: ST_TO_ADDR
// InitHc_All ( ) ;
98366: CALL_OW 584
// InitVc ;
98370: CALL_OW 20
// if mastodonts then
98374: LD_VAR 0 6
98378: IFFALSE 98445
// for i = 1 to mastodonts do
98380: LD_ADDR_VAR 0 11
98384: PUSH
98385: DOUBLE
98386: LD_INT 1
98388: DEC
98389: ST_TO_ADDR
98390: LD_VAR 0 6
98394: PUSH
98395: FOR_TO
98396: IFFALSE 98443
// begin vc_chassis := 31 ;
98398: LD_ADDR_OWVAR 37
98402: PUSH
98403: LD_INT 31
98405: ST_TO_ADDR
// vc_control := control_rider ;
98406: LD_ADDR_OWVAR 38
98410: PUSH
98411: LD_INT 4
98413: ST_TO_ADDR
// animal := CreateVehicle ;
98414: LD_ADDR_VAR 0 12
98418: PUSH
98419: CALL_OW 45
98423: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98424: LD_VAR 0 12
98428: PPUSH
98429: LD_VAR 0 8
98433: PPUSH
98434: LD_INT 0
98436: PPUSH
98437: CALL 100573 0 3
// end ;
98441: GO 98395
98443: POP
98444: POP
// if horses then
98445: LD_VAR 0 5
98449: IFFALSE 98516
// for i = 1 to horses do
98451: LD_ADDR_VAR 0 11
98455: PUSH
98456: DOUBLE
98457: LD_INT 1
98459: DEC
98460: ST_TO_ADDR
98461: LD_VAR 0 5
98465: PUSH
98466: FOR_TO
98467: IFFALSE 98514
// begin hc_class := 21 ;
98469: LD_ADDR_OWVAR 28
98473: PUSH
98474: LD_INT 21
98476: ST_TO_ADDR
// hc_gallery :=  ;
98477: LD_ADDR_OWVAR 33
98481: PUSH
98482: LD_STRING 
98484: ST_TO_ADDR
// animal := CreateHuman ;
98485: LD_ADDR_VAR 0 12
98489: PUSH
98490: CALL_OW 44
98494: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98495: LD_VAR 0 12
98499: PPUSH
98500: LD_VAR 0 8
98504: PPUSH
98505: LD_INT 0
98507: PPUSH
98508: CALL 100573 0 3
// end ;
98512: GO 98466
98514: POP
98515: POP
// if birds then
98516: LD_VAR 0 1
98520: IFFALSE 98587
// for i = 1 to birds do
98522: LD_ADDR_VAR 0 11
98526: PUSH
98527: DOUBLE
98528: LD_INT 1
98530: DEC
98531: ST_TO_ADDR
98532: LD_VAR 0 1
98536: PUSH
98537: FOR_TO
98538: IFFALSE 98585
// begin hc_class := 18 ;
98540: LD_ADDR_OWVAR 28
98544: PUSH
98545: LD_INT 18
98547: ST_TO_ADDR
// hc_gallery =  ;
98548: LD_ADDR_OWVAR 33
98552: PUSH
98553: LD_STRING 
98555: ST_TO_ADDR
// animal := CreateHuman ;
98556: LD_ADDR_VAR 0 12
98560: PUSH
98561: CALL_OW 44
98565: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98566: LD_VAR 0 12
98570: PPUSH
98571: LD_VAR 0 8
98575: PPUSH
98576: LD_INT 0
98578: PPUSH
98579: CALL 100573 0 3
// end ;
98583: GO 98537
98585: POP
98586: POP
// if tigers then
98587: LD_VAR 0 2
98591: IFFALSE 98675
// for i = 1 to tigers do
98593: LD_ADDR_VAR 0 11
98597: PUSH
98598: DOUBLE
98599: LD_INT 1
98601: DEC
98602: ST_TO_ADDR
98603: LD_VAR 0 2
98607: PUSH
98608: FOR_TO
98609: IFFALSE 98673
// begin hc_class = class_tiger ;
98611: LD_ADDR_OWVAR 28
98615: PUSH
98616: LD_INT 14
98618: ST_TO_ADDR
// hc_gallery =  ;
98619: LD_ADDR_OWVAR 33
98623: PUSH
98624: LD_STRING 
98626: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98627: LD_ADDR_OWVAR 35
98631: PUSH
98632: LD_INT 7
98634: NEG
98635: PPUSH
98636: LD_INT 7
98638: PPUSH
98639: CALL_OW 12
98643: ST_TO_ADDR
// animal := CreateHuman ;
98644: LD_ADDR_VAR 0 12
98648: PUSH
98649: CALL_OW 44
98653: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98654: LD_VAR 0 12
98658: PPUSH
98659: LD_VAR 0 8
98663: PPUSH
98664: LD_INT 0
98666: PPUSH
98667: CALL 100573 0 3
// end ;
98671: GO 98608
98673: POP
98674: POP
// if apemans then
98675: LD_VAR 0 3
98679: IFFALSE 98802
// for i = 1 to apemans do
98681: LD_ADDR_VAR 0 11
98685: PUSH
98686: DOUBLE
98687: LD_INT 1
98689: DEC
98690: ST_TO_ADDR
98691: LD_VAR 0 3
98695: PUSH
98696: FOR_TO
98697: IFFALSE 98800
// begin hc_class = class_apeman ;
98699: LD_ADDR_OWVAR 28
98703: PUSH
98704: LD_INT 12
98706: ST_TO_ADDR
// hc_gallery =  ;
98707: LD_ADDR_OWVAR 33
98711: PUSH
98712: LD_STRING 
98714: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
98715: LD_ADDR_OWVAR 35
98719: PUSH
98720: LD_INT 2
98722: NEG
98723: PPUSH
98724: LD_INT 2
98726: PPUSH
98727: CALL_OW 12
98731: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98732: LD_ADDR_OWVAR 31
98736: PUSH
98737: LD_INT 1
98739: PPUSH
98740: LD_INT 3
98742: PPUSH
98743: CALL_OW 12
98747: PUSH
98748: LD_INT 1
98750: PPUSH
98751: LD_INT 3
98753: PPUSH
98754: CALL_OW 12
98758: PUSH
98759: LD_INT 0
98761: PUSH
98762: LD_INT 0
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: ST_TO_ADDR
// animal := CreateHuman ;
98771: LD_ADDR_VAR 0 12
98775: PUSH
98776: CALL_OW 44
98780: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98781: LD_VAR 0 12
98785: PPUSH
98786: LD_VAR 0 8
98790: PPUSH
98791: LD_INT 0
98793: PPUSH
98794: CALL 100573 0 3
// end ;
98798: GO 98696
98800: POP
98801: POP
// if enchidnas then
98802: LD_VAR 0 4
98806: IFFALSE 98873
// for i = 1 to enchidnas do
98808: LD_ADDR_VAR 0 11
98812: PUSH
98813: DOUBLE
98814: LD_INT 1
98816: DEC
98817: ST_TO_ADDR
98818: LD_VAR 0 4
98822: PUSH
98823: FOR_TO
98824: IFFALSE 98871
// begin hc_class = 13 ;
98826: LD_ADDR_OWVAR 28
98830: PUSH
98831: LD_INT 13
98833: ST_TO_ADDR
// hc_gallery =  ;
98834: LD_ADDR_OWVAR 33
98838: PUSH
98839: LD_STRING 
98841: ST_TO_ADDR
// animal := CreateHuman ;
98842: LD_ADDR_VAR 0 12
98846: PUSH
98847: CALL_OW 44
98851: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98852: LD_VAR 0 12
98856: PPUSH
98857: LD_VAR 0 8
98861: PPUSH
98862: LD_INT 0
98864: PPUSH
98865: CALL 100573 0 3
// end ;
98869: GO 98823
98871: POP
98872: POP
// if fishes then
98873: LD_VAR 0 7
98877: IFFALSE 98944
// for i = 1 to fishes do
98879: LD_ADDR_VAR 0 11
98883: PUSH
98884: DOUBLE
98885: LD_INT 1
98887: DEC
98888: ST_TO_ADDR
98889: LD_VAR 0 7
98893: PUSH
98894: FOR_TO
98895: IFFALSE 98942
// begin hc_class = 20 ;
98897: LD_ADDR_OWVAR 28
98901: PUSH
98902: LD_INT 20
98904: ST_TO_ADDR
// hc_gallery =  ;
98905: LD_ADDR_OWVAR 33
98909: PUSH
98910: LD_STRING 
98912: ST_TO_ADDR
// animal := CreateHuman ;
98913: LD_ADDR_VAR 0 12
98917: PUSH
98918: CALL_OW 44
98922: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98923: LD_VAR 0 12
98927: PPUSH
98928: LD_VAR 0 9
98932: PPUSH
98933: LD_INT 0
98935: PPUSH
98936: CALL 100573 0 3
// end ;
98940: GO 98894
98942: POP
98943: POP
// end ;
98944: LD_VAR 0 10
98948: RET
// export function WantHeal ( sci , unit ) ; begin
98949: LD_INT 0
98951: PPUSH
// if GetTaskList ( sci ) > 0 then
98952: LD_VAR 0 1
98956: PPUSH
98957: CALL_OW 437
98961: PUSH
98962: LD_INT 0
98964: GREATER
98965: IFFALSE 99035
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98967: LD_VAR 0 1
98971: PPUSH
98972: CALL_OW 437
98976: PUSH
98977: LD_INT 1
98979: ARRAY
98980: PUSH
98981: LD_INT 1
98983: ARRAY
98984: PUSH
98985: LD_STRING l
98987: EQUAL
98988: PUSH
98989: LD_VAR 0 1
98993: PPUSH
98994: CALL_OW 437
98998: PUSH
98999: LD_INT 1
99001: ARRAY
99002: PUSH
99003: LD_INT 4
99005: ARRAY
99006: PUSH
99007: LD_VAR 0 2
99011: EQUAL
99012: AND
99013: IFFALSE 99025
// result := true else
99015: LD_ADDR_VAR 0 3
99019: PUSH
99020: LD_INT 1
99022: ST_TO_ADDR
99023: GO 99033
// result := false ;
99025: LD_ADDR_VAR 0 3
99029: PUSH
99030: LD_INT 0
99032: ST_TO_ADDR
// end else
99033: GO 99043
// result := false ;
99035: LD_ADDR_VAR 0 3
99039: PUSH
99040: LD_INT 0
99042: ST_TO_ADDR
// end ;
99043: LD_VAR 0 3
99047: RET
// export function HealTarget ( sci ) ; begin
99048: LD_INT 0
99050: PPUSH
// if not sci then
99051: LD_VAR 0 1
99055: NOT
99056: IFFALSE 99060
// exit ;
99058: GO 99125
// result := 0 ;
99060: LD_ADDR_VAR 0 2
99064: PUSH
99065: LD_INT 0
99067: ST_TO_ADDR
// if GetTaskList ( sci ) then
99068: LD_VAR 0 1
99072: PPUSH
99073: CALL_OW 437
99077: IFFALSE 99125
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99079: LD_VAR 0 1
99083: PPUSH
99084: CALL_OW 437
99088: PUSH
99089: LD_INT 1
99091: ARRAY
99092: PUSH
99093: LD_INT 1
99095: ARRAY
99096: PUSH
99097: LD_STRING l
99099: EQUAL
99100: IFFALSE 99125
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99102: LD_ADDR_VAR 0 2
99106: PUSH
99107: LD_VAR 0 1
99111: PPUSH
99112: CALL_OW 437
99116: PUSH
99117: LD_INT 1
99119: ARRAY
99120: PUSH
99121: LD_INT 4
99123: ARRAY
99124: ST_TO_ADDR
// end ;
99125: LD_VAR 0 2
99129: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
99134: PPUSH
99135: PPUSH
// if not base_units then
99136: LD_VAR 0 1
99140: NOT
99141: IFFALSE 99145
// exit ;
99143: GO 99232
// result := false ;
99145: LD_ADDR_VAR 0 2
99149: PUSH
99150: LD_INT 0
99152: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99153: LD_ADDR_VAR 0 5
99157: PUSH
99158: LD_VAR 0 1
99162: PPUSH
99163: LD_INT 21
99165: PUSH
99166: LD_INT 3
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PPUSH
99173: CALL_OW 72
99177: ST_TO_ADDR
// if not tmp then
99178: LD_VAR 0 5
99182: NOT
99183: IFFALSE 99187
// exit ;
99185: GO 99232
// for i in tmp do
99187: LD_ADDR_VAR 0 3
99191: PUSH
99192: LD_VAR 0 5
99196: PUSH
99197: FOR_IN
99198: IFFALSE 99230
// begin result := EnemyInRange ( i , 22 ) ;
99200: LD_ADDR_VAR 0 2
99204: PUSH
99205: LD_VAR 0 3
99209: PPUSH
99210: LD_INT 22
99212: PPUSH
99213: CALL 96830 0 2
99217: ST_TO_ADDR
// if result then
99218: LD_VAR 0 2
99222: IFFALSE 99228
// exit ;
99224: POP
99225: POP
99226: GO 99232
// end ;
99228: GO 99197
99230: POP
99231: POP
// end ;
99232: LD_VAR 0 2
99236: RET
// export function FilterByTag ( units , tag ) ; begin
99237: LD_INT 0
99239: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
99240: LD_ADDR_VAR 0 3
99244: PUSH
99245: LD_VAR 0 1
99249: PPUSH
99250: LD_INT 120
99252: PUSH
99253: LD_VAR 0 2
99257: PUSH
99258: EMPTY
99259: LIST
99260: LIST
99261: PPUSH
99262: CALL_OW 72
99266: ST_TO_ADDR
// end ;
99267: LD_VAR 0 3
99271: RET
// export function IsDriver ( un ) ; begin
99272: LD_INT 0
99274: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99275: LD_ADDR_VAR 0 2
99279: PUSH
99280: LD_VAR 0 1
99284: PUSH
99285: LD_INT 55
99287: PUSH
99288: EMPTY
99289: LIST
99290: PPUSH
99291: CALL_OW 69
99295: IN
99296: ST_TO_ADDR
// end ;
99297: LD_VAR 0 2
99301: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99302: LD_INT 0
99304: PPUSH
99305: PPUSH
// list := [ ] ;
99306: LD_ADDR_VAR 0 5
99310: PUSH
99311: EMPTY
99312: ST_TO_ADDR
// case d of 0 :
99313: LD_VAR 0 3
99317: PUSH
99318: LD_INT 0
99320: DOUBLE
99321: EQUAL
99322: IFTRUE 99326
99324: GO 99459
99326: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
99327: LD_ADDR_VAR 0 5
99331: PUSH
99332: LD_VAR 0 1
99336: PUSH
99337: LD_INT 4
99339: MINUS
99340: PUSH
99341: LD_VAR 0 2
99345: PUSH
99346: LD_INT 4
99348: MINUS
99349: PUSH
99350: LD_INT 2
99352: PUSH
99353: EMPTY
99354: LIST
99355: LIST
99356: LIST
99357: PUSH
99358: LD_VAR 0 1
99362: PUSH
99363: LD_INT 3
99365: MINUS
99366: PUSH
99367: LD_VAR 0 2
99371: PUSH
99372: LD_INT 1
99374: PUSH
99375: EMPTY
99376: LIST
99377: LIST
99378: LIST
99379: PUSH
99380: LD_VAR 0 1
99384: PUSH
99385: LD_INT 4
99387: PLUS
99388: PUSH
99389: LD_VAR 0 2
99393: PUSH
99394: LD_INT 4
99396: PUSH
99397: EMPTY
99398: LIST
99399: LIST
99400: LIST
99401: PUSH
99402: LD_VAR 0 1
99406: PUSH
99407: LD_INT 3
99409: PLUS
99410: PUSH
99411: LD_VAR 0 2
99415: PUSH
99416: LD_INT 3
99418: PLUS
99419: PUSH
99420: LD_INT 5
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: LIST
99427: PUSH
99428: LD_VAR 0 1
99432: PUSH
99433: LD_VAR 0 2
99437: PUSH
99438: LD_INT 4
99440: PLUS
99441: PUSH
99442: LD_INT 0
99444: PUSH
99445: EMPTY
99446: LIST
99447: LIST
99448: LIST
99449: PUSH
99450: EMPTY
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: ST_TO_ADDR
// end ; 1 :
99457: GO 100157
99459: LD_INT 1
99461: DOUBLE
99462: EQUAL
99463: IFTRUE 99467
99465: GO 99600
99467: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
99468: LD_ADDR_VAR 0 5
99472: PUSH
99473: LD_VAR 0 1
99477: PUSH
99478: LD_VAR 0 2
99482: PUSH
99483: LD_INT 4
99485: MINUS
99486: PUSH
99487: LD_INT 3
99489: PUSH
99490: EMPTY
99491: LIST
99492: LIST
99493: LIST
99494: PUSH
99495: LD_VAR 0 1
99499: PUSH
99500: LD_INT 3
99502: MINUS
99503: PUSH
99504: LD_VAR 0 2
99508: PUSH
99509: LD_INT 3
99511: MINUS
99512: PUSH
99513: LD_INT 2
99515: PUSH
99516: EMPTY
99517: LIST
99518: LIST
99519: LIST
99520: PUSH
99521: LD_VAR 0 1
99525: PUSH
99526: LD_INT 4
99528: MINUS
99529: PUSH
99530: LD_VAR 0 2
99534: PUSH
99535: LD_INT 1
99537: PUSH
99538: EMPTY
99539: LIST
99540: LIST
99541: LIST
99542: PUSH
99543: LD_VAR 0 1
99547: PUSH
99548: LD_VAR 0 2
99552: PUSH
99553: LD_INT 3
99555: PLUS
99556: PUSH
99557: LD_INT 0
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: LIST
99564: PUSH
99565: LD_VAR 0 1
99569: PUSH
99570: LD_INT 4
99572: PLUS
99573: PUSH
99574: LD_VAR 0 2
99578: PUSH
99579: LD_INT 4
99581: PLUS
99582: PUSH
99583: LD_INT 5
99585: PUSH
99586: EMPTY
99587: LIST
99588: LIST
99589: LIST
99590: PUSH
99591: EMPTY
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: ST_TO_ADDR
// end ; 2 :
99598: GO 100157
99600: LD_INT 2
99602: DOUBLE
99603: EQUAL
99604: IFTRUE 99608
99606: GO 99737
99608: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99609: LD_ADDR_VAR 0 5
99613: PUSH
99614: LD_VAR 0 1
99618: PUSH
99619: LD_VAR 0 2
99623: PUSH
99624: LD_INT 3
99626: MINUS
99627: PUSH
99628: LD_INT 3
99630: PUSH
99631: EMPTY
99632: LIST
99633: LIST
99634: LIST
99635: PUSH
99636: LD_VAR 0 1
99640: PUSH
99641: LD_INT 4
99643: PLUS
99644: PUSH
99645: LD_VAR 0 2
99649: PUSH
99650: LD_INT 4
99652: PUSH
99653: EMPTY
99654: LIST
99655: LIST
99656: LIST
99657: PUSH
99658: LD_VAR 0 1
99662: PUSH
99663: LD_VAR 0 2
99667: PUSH
99668: LD_INT 4
99670: PLUS
99671: PUSH
99672: LD_INT 0
99674: PUSH
99675: EMPTY
99676: LIST
99677: LIST
99678: LIST
99679: PUSH
99680: LD_VAR 0 1
99684: PUSH
99685: LD_INT 3
99687: MINUS
99688: PUSH
99689: LD_VAR 0 2
99693: PUSH
99694: LD_INT 1
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: LIST
99701: PUSH
99702: LD_VAR 0 1
99706: PUSH
99707: LD_INT 4
99709: MINUS
99710: PUSH
99711: LD_VAR 0 2
99715: PUSH
99716: LD_INT 4
99718: MINUS
99719: PUSH
99720: LD_INT 2
99722: PUSH
99723: EMPTY
99724: LIST
99725: LIST
99726: LIST
99727: PUSH
99728: EMPTY
99729: LIST
99730: LIST
99731: LIST
99732: LIST
99733: LIST
99734: ST_TO_ADDR
// end ; 3 :
99735: GO 100157
99737: LD_INT 3
99739: DOUBLE
99740: EQUAL
99741: IFTRUE 99745
99743: GO 99878
99745: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99746: LD_ADDR_VAR 0 5
99750: PUSH
99751: LD_VAR 0 1
99755: PUSH
99756: LD_INT 3
99758: PLUS
99759: PUSH
99760: LD_VAR 0 2
99764: PUSH
99765: LD_INT 4
99767: PUSH
99768: EMPTY
99769: LIST
99770: LIST
99771: LIST
99772: PUSH
99773: LD_VAR 0 1
99777: PUSH
99778: LD_INT 4
99780: PLUS
99781: PUSH
99782: LD_VAR 0 2
99786: PUSH
99787: LD_INT 4
99789: PLUS
99790: PUSH
99791: LD_INT 5
99793: PUSH
99794: EMPTY
99795: LIST
99796: LIST
99797: LIST
99798: PUSH
99799: LD_VAR 0 1
99803: PUSH
99804: LD_INT 4
99806: MINUS
99807: PUSH
99808: LD_VAR 0 2
99812: PUSH
99813: LD_INT 1
99815: PUSH
99816: EMPTY
99817: LIST
99818: LIST
99819: LIST
99820: PUSH
99821: LD_VAR 0 1
99825: PUSH
99826: LD_VAR 0 2
99830: PUSH
99831: LD_INT 4
99833: MINUS
99834: PUSH
99835: LD_INT 3
99837: PUSH
99838: EMPTY
99839: LIST
99840: LIST
99841: LIST
99842: PUSH
99843: LD_VAR 0 1
99847: PUSH
99848: LD_INT 3
99850: MINUS
99851: PUSH
99852: LD_VAR 0 2
99856: PUSH
99857: LD_INT 3
99859: MINUS
99860: PUSH
99861: LD_INT 2
99863: PUSH
99864: EMPTY
99865: LIST
99866: LIST
99867: LIST
99868: PUSH
99869: EMPTY
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: ST_TO_ADDR
// end ; 4 :
99876: GO 100157
99878: LD_INT 4
99880: DOUBLE
99881: EQUAL
99882: IFTRUE 99886
99884: GO 100019
99886: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99887: LD_ADDR_VAR 0 5
99891: PUSH
99892: LD_VAR 0 1
99896: PUSH
99897: LD_VAR 0 2
99901: PUSH
99902: LD_INT 4
99904: PLUS
99905: PUSH
99906: LD_INT 0
99908: PUSH
99909: EMPTY
99910: LIST
99911: LIST
99912: LIST
99913: PUSH
99914: LD_VAR 0 1
99918: PUSH
99919: LD_INT 3
99921: PLUS
99922: PUSH
99923: LD_VAR 0 2
99927: PUSH
99928: LD_INT 3
99930: PLUS
99931: PUSH
99932: LD_INT 5
99934: PUSH
99935: EMPTY
99936: LIST
99937: LIST
99938: LIST
99939: PUSH
99940: LD_VAR 0 1
99944: PUSH
99945: LD_INT 4
99947: PLUS
99948: PUSH
99949: LD_VAR 0 2
99953: PUSH
99954: LD_INT 4
99956: PUSH
99957: EMPTY
99958: LIST
99959: LIST
99960: LIST
99961: PUSH
99962: LD_VAR 0 1
99966: PUSH
99967: LD_VAR 0 2
99971: PUSH
99972: LD_INT 3
99974: MINUS
99975: PUSH
99976: LD_INT 3
99978: PUSH
99979: EMPTY
99980: LIST
99981: LIST
99982: LIST
99983: PUSH
99984: LD_VAR 0 1
99988: PUSH
99989: LD_INT 4
99991: MINUS
99992: PUSH
99993: LD_VAR 0 2
99997: PUSH
99998: LD_INT 4
100000: MINUS
100001: PUSH
100002: LD_INT 2
100004: PUSH
100005: EMPTY
100006: LIST
100007: LIST
100008: LIST
100009: PUSH
100010: EMPTY
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: ST_TO_ADDR
// end ; 5 :
100017: GO 100157
100019: LD_INT 5
100021: DOUBLE
100022: EQUAL
100023: IFTRUE 100027
100025: GO 100156
100027: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100028: LD_ADDR_VAR 0 5
100032: PUSH
100033: LD_VAR 0 1
100037: PUSH
100038: LD_INT 4
100040: MINUS
100041: PUSH
100042: LD_VAR 0 2
100046: PUSH
100047: LD_INT 1
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: LIST
100054: PUSH
100055: LD_VAR 0 1
100059: PUSH
100060: LD_VAR 0 2
100064: PUSH
100065: LD_INT 4
100067: MINUS
100068: PUSH
100069: LD_INT 3
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: LIST
100076: PUSH
100077: LD_VAR 0 1
100081: PUSH
100082: LD_INT 4
100084: PLUS
100085: PUSH
100086: LD_VAR 0 2
100090: PUSH
100091: LD_INT 4
100093: PLUS
100094: PUSH
100095: LD_INT 5
100097: PUSH
100098: EMPTY
100099: LIST
100100: LIST
100101: LIST
100102: PUSH
100103: LD_VAR 0 1
100107: PUSH
100108: LD_INT 3
100110: PLUS
100111: PUSH
100112: LD_VAR 0 2
100116: PUSH
100117: LD_INT 4
100119: PUSH
100120: EMPTY
100121: LIST
100122: LIST
100123: LIST
100124: PUSH
100125: LD_VAR 0 1
100129: PUSH
100130: LD_VAR 0 2
100134: PUSH
100135: LD_INT 3
100137: PLUS
100138: PUSH
100139: LD_INT 0
100141: PUSH
100142: EMPTY
100143: LIST
100144: LIST
100145: LIST
100146: PUSH
100147: EMPTY
100148: LIST
100149: LIST
100150: LIST
100151: LIST
100152: LIST
100153: ST_TO_ADDR
// end ; end ;
100154: GO 100157
100156: POP
// result := list ;
100157: LD_ADDR_VAR 0 4
100161: PUSH
100162: LD_VAR 0 5
100166: ST_TO_ADDR
// end ;
100167: LD_VAR 0 4
100171: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100172: LD_INT 0
100174: PPUSH
100175: PPUSH
100176: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100177: LD_VAR 0 1
100181: NOT
100182: PUSH
100183: LD_VAR 0 2
100187: PUSH
100188: LD_INT 1
100190: PUSH
100191: LD_INT 2
100193: PUSH
100194: LD_INT 3
100196: PUSH
100197: LD_INT 4
100199: PUSH
100200: EMPTY
100201: LIST
100202: LIST
100203: LIST
100204: LIST
100205: IN
100206: NOT
100207: OR
100208: IFFALSE 100212
// exit ;
100210: GO 100295
// tmp := [ ] ;
100212: LD_ADDR_VAR 0 5
100216: PUSH
100217: EMPTY
100218: ST_TO_ADDR
// for i in units do
100219: LD_ADDR_VAR 0 4
100223: PUSH
100224: LD_VAR 0 1
100228: PUSH
100229: FOR_IN
100230: IFFALSE 100264
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
100232: LD_ADDR_VAR 0 5
100236: PUSH
100237: LD_VAR 0 5
100241: PPUSH
100242: LD_VAR 0 4
100246: PPUSH
100247: LD_VAR 0 2
100251: PPUSH
100252: CALL_OW 259
100256: PPUSH
100257: CALL 101668 0 2
100261: ST_TO_ADDR
100262: GO 100229
100264: POP
100265: POP
// if not tmp then
100266: LD_VAR 0 5
100270: NOT
100271: IFFALSE 100275
// exit ;
100273: GO 100295
// result := SortListByListDesc ( units , tmp ) ;
100275: LD_ADDR_VAR 0 3
100279: PUSH
100280: LD_VAR 0 1
100284: PPUSH
100285: LD_VAR 0 5
100289: PPUSH
100290: CALL_OW 77
100294: ST_TO_ADDR
// end ;
100295: LD_VAR 0 3
100299: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
100300: LD_INT 0
100302: PPUSH
100303: PPUSH
100304: PPUSH
// result := false ;
100305: LD_ADDR_VAR 0 3
100309: PUSH
100310: LD_INT 0
100312: ST_TO_ADDR
// if not building then
100313: LD_VAR 0 2
100317: NOT
100318: IFFALSE 100322
// exit ;
100320: GO 100460
// x := GetX ( building ) ;
100322: LD_ADDR_VAR 0 4
100326: PUSH
100327: LD_VAR 0 2
100331: PPUSH
100332: CALL_OW 250
100336: ST_TO_ADDR
// y := GetY ( building ) ;
100337: LD_ADDR_VAR 0 5
100341: PUSH
100342: LD_VAR 0 2
100346: PPUSH
100347: CALL_OW 251
100351: ST_TO_ADDR
// if not x or not y then
100352: LD_VAR 0 4
100356: NOT
100357: PUSH
100358: LD_VAR 0 5
100362: NOT
100363: OR
100364: IFFALSE 100368
// exit ;
100366: GO 100460
// if GetTaskList ( unit ) then
100368: LD_VAR 0 1
100372: PPUSH
100373: CALL_OW 437
100377: IFFALSE 100460
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100379: LD_STRING e
100381: PUSH
100382: LD_VAR 0 1
100386: PPUSH
100387: CALL_OW 437
100391: PUSH
100392: LD_INT 1
100394: ARRAY
100395: PUSH
100396: LD_INT 1
100398: ARRAY
100399: EQUAL
100400: PUSH
100401: LD_VAR 0 4
100405: PUSH
100406: LD_VAR 0 1
100410: PPUSH
100411: CALL_OW 437
100415: PUSH
100416: LD_INT 1
100418: ARRAY
100419: PUSH
100420: LD_INT 2
100422: ARRAY
100423: EQUAL
100424: AND
100425: PUSH
100426: LD_VAR 0 5
100430: PUSH
100431: LD_VAR 0 1
100435: PPUSH
100436: CALL_OW 437
100440: PUSH
100441: LD_INT 1
100443: ARRAY
100444: PUSH
100445: LD_INT 3
100447: ARRAY
100448: EQUAL
100449: AND
100450: IFFALSE 100460
// result := true end ;
100452: LD_ADDR_VAR 0 3
100456: PUSH
100457: LD_INT 1
100459: ST_TO_ADDR
// end ;
100460: LD_VAR 0 3
100464: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
100465: LD_INT 0
100467: PPUSH
// result := false ;
100468: LD_ADDR_VAR 0 4
100472: PUSH
100473: LD_INT 0
100475: ST_TO_ADDR
// if GetTaskList ( unit ) then
100476: LD_VAR 0 1
100480: PPUSH
100481: CALL_OW 437
100485: IFFALSE 100568
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100487: LD_STRING M
100489: PUSH
100490: LD_VAR 0 1
100494: PPUSH
100495: CALL_OW 437
100499: PUSH
100500: LD_INT 1
100502: ARRAY
100503: PUSH
100504: LD_INT 1
100506: ARRAY
100507: EQUAL
100508: PUSH
100509: LD_VAR 0 2
100513: PUSH
100514: LD_VAR 0 1
100518: PPUSH
100519: CALL_OW 437
100523: PUSH
100524: LD_INT 1
100526: ARRAY
100527: PUSH
100528: LD_INT 2
100530: ARRAY
100531: EQUAL
100532: AND
100533: PUSH
100534: LD_VAR 0 3
100538: PUSH
100539: LD_VAR 0 1
100543: PPUSH
100544: CALL_OW 437
100548: PUSH
100549: LD_INT 1
100551: ARRAY
100552: PUSH
100553: LD_INT 3
100555: ARRAY
100556: EQUAL
100557: AND
100558: IFFALSE 100568
// result := true ;
100560: LD_ADDR_VAR 0 4
100564: PUSH
100565: LD_INT 1
100567: ST_TO_ADDR
// end ; end ;
100568: LD_VAR 0 4
100572: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100573: LD_INT 0
100575: PPUSH
100576: PPUSH
100577: PPUSH
100578: PPUSH
// if not unit or not area then
100579: LD_VAR 0 1
100583: NOT
100584: PUSH
100585: LD_VAR 0 2
100589: NOT
100590: OR
100591: IFFALSE 100595
// exit ;
100593: GO 100771
// tmp := AreaToList ( area , i ) ;
100595: LD_ADDR_VAR 0 6
100599: PUSH
100600: LD_VAR 0 2
100604: PPUSH
100605: LD_VAR 0 5
100609: PPUSH
100610: CALL_OW 517
100614: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100615: LD_ADDR_VAR 0 5
100619: PUSH
100620: DOUBLE
100621: LD_INT 1
100623: DEC
100624: ST_TO_ADDR
100625: LD_VAR 0 6
100629: PUSH
100630: LD_INT 1
100632: ARRAY
100633: PUSH
100634: FOR_TO
100635: IFFALSE 100769
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100637: LD_ADDR_VAR 0 7
100641: PUSH
100642: LD_VAR 0 6
100646: PUSH
100647: LD_INT 1
100649: ARRAY
100650: PUSH
100651: LD_VAR 0 5
100655: ARRAY
100656: PUSH
100657: LD_VAR 0 6
100661: PUSH
100662: LD_INT 2
100664: ARRAY
100665: PUSH
100666: LD_VAR 0 5
100670: ARRAY
100671: PUSH
100672: EMPTY
100673: LIST
100674: LIST
100675: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
100676: LD_INT 92
100678: PUSH
100679: LD_VAR 0 7
100683: PUSH
100684: LD_INT 1
100686: ARRAY
100687: PUSH
100688: LD_VAR 0 7
100692: PUSH
100693: LD_INT 2
100695: ARRAY
100696: PUSH
100697: LD_INT 2
100699: PUSH
100700: EMPTY
100701: LIST
100702: LIST
100703: LIST
100704: LIST
100705: PPUSH
100706: CALL_OW 69
100710: PUSH
100711: LD_INT 0
100713: EQUAL
100714: IFFALSE 100767
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100716: LD_VAR 0 1
100720: PPUSH
100721: LD_VAR 0 7
100725: PUSH
100726: LD_INT 1
100728: ARRAY
100729: PPUSH
100730: LD_VAR 0 7
100734: PUSH
100735: LD_INT 2
100737: ARRAY
100738: PPUSH
100739: LD_VAR 0 3
100743: PPUSH
100744: CALL_OW 48
// result := IsPlaced ( unit ) ;
100748: LD_ADDR_VAR 0 4
100752: PUSH
100753: LD_VAR 0 1
100757: PPUSH
100758: CALL_OW 305
100762: ST_TO_ADDR
// exit ;
100763: POP
100764: POP
100765: GO 100771
// end ; end ;
100767: GO 100634
100769: POP
100770: POP
// end ;
100771: LD_VAR 0 4
100775: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100776: LD_INT 0
100778: PPUSH
100779: PPUSH
100780: PPUSH
// if not side or side > 8 then
100781: LD_VAR 0 1
100785: NOT
100786: PUSH
100787: LD_VAR 0 1
100791: PUSH
100792: LD_INT 8
100794: GREATER
100795: OR
100796: IFFALSE 100800
// exit ;
100798: GO 100987
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100800: LD_ADDR_VAR 0 4
100804: PUSH
100805: LD_INT 22
100807: PUSH
100808: LD_VAR 0 1
100812: PUSH
100813: EMPTY
100814: LIST
100815: LIST
100816: PUSH
100817: LD_INT 21
100819: PUSH
100820: LD_INT 3
100822: PUSH
100823: EMPTY
100824: LIST
100825: LIST
100826: PUSH
100827: EMPTY
100828: LIST
100829: LIST
100830: PPUSH
100831: CALL_OW 69
100835: ST_TO_ADDR
// if not tmp then
100836: LD_VAR 0 4
100840: NOT
100841: IFFALSE 100845
// exit ;
100843: GO 100987
// enable_addtolog := true ;
100845: LD_ADDR_OWVAR 81
100849: PUSH
100850: LD_INT 1
100852: ST_TO_ADDR
// AddToLog ( [ ) ;
100853: LD_STRING [
100855: PPUSH
100856: CALL_OW 561
// for i in tmp do
100860: LD_ADDR_VAR 0 3
100864: PUSH
100865: LD_VAR 0 4
100869: PUSH
100870: FOR_IN
100871: IFFALSE 100978
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100873: LD_STRING [
100875: PUSH
100876: LD_VAR 0 3
100880: PPUSH
100881: CALL_OW 266
100885: STR
100886: PUSH
100887: LD_STRING , 
100889: STR
100890: PUSH
100891: LD_VAR 0 3
100895: PPUSH
100896: CALL_OW 250
100900: STR
100901: PUSH
100902: LD_STRING , 
100904: STR
100905: PUSH
100906: LD_VAR 0 3
100910: PPUSH
100911: CALL_OW 251
100915: STR
100916: PUSH
100917: LD_STRING , 
100919: STR
100920: PUSH
100921: LD_VAR 0 3
100925: PPUSH
100926: CALL_OW 254
100930: STR
100931: PUSH
100932: LD_STRING , 
100934: STR
100935: PUSH
100936: LD_VAR 0 3
100940: PPUSH
100941: LD_INT 1
100943: PPUSH
100944: CALL_OW 268
100948: STR
100949: PUSH
100950: LD_STRING , 
100952: STR
100953: PUSH
100954: LD_VAR 0 3
100958: PPUSH
100959: LD_INT 2
100961: PPUSH
100962: CALL_OW 268
100966: STR
100967: PUSH
100968: LD_STRING ],
100970: STR
100971: PPUSH
100972: CALL_OW 561
// end ;
100976: GO 100870
100978: POP
100979: POP
// AddToLog ( ]; ) ;
100980: LD_STRING ];
100982: PPUSH
100983: CALL_OW 561
// end ;
100987: LD_VAR 0 2
100991: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100992: LD_INT 0
100994: PPUSH
100995: PPUSH
100996: PPUSH
100997: PPUSH
100998: PPUSH
// if not area or not rate or not max then
100999: LD_VAR 0 1
101003: NOT
101004: PUSH
101005: LD_VAR 0 2
101009: NOT
101010: OR
101011: PUSH
101012: LD_VAR 0 4
101016: NOT
101017: OR
101018: IFFALSE 101022
// exit ;
101020: GO 101211
// while 1 do
101022: LD_INT 1
101024: IFFALSE 101211
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101026: LD_ADDR_VAR 0 9
101030: PUSH
101031: LD_VAR 0 1
101035: PPUSH
101036: LD_INT 1
101038: PPUSH
101039: CALL_OW 287
101043: PUSH
101044: LD_INT 10
101046: MUL
101047: ST_TO_ADDR
// r := rate / 10 ;
101048: LD_ADDR_VAR 0 7
101052: PUSH
101053: LD_VAR 0 2
101057: PUSH
101058: LD_INT 10
101060: DIVREAL
101061: ST_TO_ADDR
// time := 1 1$00 ;
101062: LD_ADDR_VAR 0 8
101066: PUSH
101067: LD_INT 2100
101069: ST_TO_ADDR
// if amount < min then
101070: LD_VAR 0 9
101074: PUSH
101075: LD_VAR 0 3
101079: LESS
101080: IFFALSE 101098
// r := r * 2 else
101082: LD_ADDR_VAR 0 7
101086: PUSH
101087: LD_VAR 0 7
101091: PUSH
101092: LD_INT 2
101094: MUL
101095: ST_TO_ADDR
101096: GO 101124
// if amount > max then
101098: LD_VAR 0 9
101102: PUSH
101103: LD_VAR 0 4
101107: GREATER
101108: IFFALSE 101124
// r := r / 2 ;
101110: LD_ADDR_VAR 0 7
101114: PUSH
101115: LD_VAR 0 7
101119: PUSH
101120: LD_INT 2
101122: DIVREAL
101123: ST_TO_ADDR
// time := time / r ;
101124: LD_ADDR_VAR 0 8
101128: PUSH
101129: LD_VAR 0 8
101133: PUSH
101134: LD_VAR 0 7
101138: DIVREAL
101139: ST_TO_ADDR
// if time < 0 then
101140: LD_VAR 0 8
101144: PUSH
101145: LD_INT 0
101147: LESS
101148: IFFALSE 101165
// time := time * - 1 ;
101150: LD_ADDR_VAR 0 8
101154: PUSH
101155: LD_VAR 0 8
101159: PUSH
101160: LD_INT 1
101162: NEG
101163: MUL
101164: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
101165: LD_VAR 0 8
101169: PUSH
101170: LD_INT 35
101172: PPUSH
101173: LD_INT 875
101175: PPUSH
101176: CALL_OW 12
101180: PLUS
101181: PPUSH
101182: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101186: LD_INT 1
101188: PPUSH
101189: LD_INT 5
101191: PPUSH
101192: CALL_OW 12
101196: PPUSH
101197: LD_VAR 0 1
101201: PPUSH
101202: LD_INT 1
101204: PPUSH
101205: CALL_OW 55
// end ;
101209: GO 101022
// end ;
101211: LD_VAR 0 5
101215: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101216: LD_INT 0
101218: PPUSH
101219: PPUSH
101220: PPUSH
101221: PPUSH
101222: PPUSH
101223: PPUSH
101224: PPUSH
101225: PPUSH
// if not turrets or not factories then
101226: LD_VAR 0 1
101230: NOT
101231: PUSH
101232: LD_VAR 0 2
101236: NOT
101237: OR
101238: IFFALSE 101242
// exit ;
101240: GO 101549
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101242: LD_ADDR_VAR 0 10
101246: PUSH
101247: LD_INT 5
101249: PUSH
101250: LD_INT 6
101252: PUSH
101253: EMPTY
101254: LIST
101255: LIST
101256: PUSH
101257: LD_INT 2
101259: PUSH
101260: LD_INT 4
101262: PUSH
101263: EMPTY
101264: LIST
101265: LIST
101266: PUSH
101267: LD_INT 3
101269: PUSH
101270: LD_INT 5
101272: PUSH
101273: EMPTY
101274: LIST
101275: LIST
101276: PUSH
101277: EMPTY
101278: LIST
101279: LIST
101280: LIST
101281: PUSH
101282: LD_INT 24
101284: PUSH
101285: LD_INT 25
101287: PUSH
101288: EMPTY
101289: LIST
101290: LIST
101291: PUSH
101292: LD_INT 23
101294: PUSH
101295: LD_INT 27
101297: PUSH
101298: EMPTY
101299: LIST
101300: LIST
101301: PUSH
101302: EMPTY
101303: LIST
101304: LIST
101305: PUSH
101306: LD_INT 42
101308: PUSH
101309: LD_INT 43
101311: PUSH
101312: EMPTY
101313: LIST
101314: LIST
101315: PUSH
101316: LD_INT 44
101318: PUSH
101319: LD_INT 46
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 45
101328: PUSH
101329: LD_INT 47
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: LIST
101340: PUSH
101341: EMPTY
101342: LIST
101343: LIST
101344: LIST
101345: ST_TO_ADDR
// result := [ ] ;
101346: LD_ADDR_VAR 0 3
101350: PUSH
101351: EMPTY
101352: ST_TO_ADDR
// for i in turrets do
101353: LD_ADDR_VAR 0 4
101357: PUSH
101358: LD_VAR 0 1
101362: PUSH
101363: FOR_IN
101364: IFFALSE 101547
// begin nat := GetNation ( i ) ;
101366: LD_ADDR_VAR 0 7
101370: PUSH
101371: LD_VAR 0 4
101375: PPUSH
101376: CALL_OW 248
101380: ST_TO_ADDR
// weapon := 0 ;
101381: LD_ADDR_VAR 0 8
101385: PUSH
101386: LD_INT 0
101388: ST_TO_ADDR
// if not nat then
101389: LD_VAR 0 7
101393: NOT
101394: IFFALSE 101398
// continue ;
101396: GO 101363
// for j in list [ nat ] do
101398: LD_ADDR_VAR 0 5
101402: PUSH
101403: LD_VAR 0 10
101407: PUSH
101408: LD_VAR 0 7
101412: ARRAY
101413: PUSH
101414: FOR_IN
101415: IFFALSE 101456
// if GetBWeapon ( i ) = j [ 1 ] then
101417: LD_VAR 0 4
101421: PPUSH
101422: CALL_OW 269
101426: PUSH
101427: LD_VAR 0 5
101431: PUSH
101432: LD_INT 1
101434: ARRAY
101435: EQUAL
101436: IFFALSE 101454
// begin weapon := j [ 2 ] ;
101438: LD_ADDR_VAR 0 8
101442: PUSH
101443: LD_VAR 0 5
101447: PUSH
101448: LD_INT 2
101450: ARRAY
101451: ST_TO_ADDR
// break ;
101452: GO 101456
// end ;
101454: GO 101414
101456: POP
101457: POP
// if not weapon then
101458: LD_VAR 0 8
101462: NOT
101463: IFFALSE 101467
// continue ;
101465: GO 101363
// for k in factories do
101467: LD_ADDR_VAR 0 6
101471: PUSH
101472: LD_VAR 0 2
101476: PUSH
101477: FOR_IN
101478: IFFALSE 101543
// begin weapons := AvailableWeaponList ( k ) ;
101480: LD_ADDR_VAR 0 9
101484: PUSH
101485: LD_VAR 0 6
101489: PPUSH
101490: CALL_OW 478
101494: ST_TO_ADDR
// if not weapons then
101495: LD_VAR 0 9
101499: NOT
101500: IFFALSE 101504
// continue ;
101502: GO 101477
// if weapon in weapons then
101504: LD_VAR 0 8
101508: PUSH
101509: LD_VAR 0 9
101513: IN
101514: IFFALSE 101541
// begin result := [ i , weapon ] ;
101516: LD_ADDR_VAR 0 3
101520: PUSH
101521: LD_VAR 0 4
101525: PUSH
101526: LD_VAR 0 8
101530: PUSH
101531: EMPTY
101532: LIST
101533: LIST
101534: ST_TO_ADDR
// exit ;
101535: POP
101536: POP
101537: POP
101538: POP
101539: GO 101549
// end ; end ;
101541: GO 101477
101543: POP
101544: POP
// end ;
101545: GO 101363
101547: POP
101548: POP
// end ;
101549: LD_VAR 0 3
101553: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101554: LD_INT 0
101556: PPUSH
// if not side or side > 8 then
101557: LD_VAR 0 3
101561: NOT
101562: PUSH
101563: LD_VAR 0 3
101567: PUSH
101568: LD_INT 8
101570: GREATER
101571: OR
101572: IFFALSE 101576
// exit ;
101574: GO 101635
// if not range then
101576: LD_VAR 0 4
101580: NOT
101581: IFFALSE 101592
// range := - 12 ;
101583: LD_ADDR_VAR 0 4
101587: PUSH
101588: LD_INT 12
101590: NEG
101591: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101592: LD_VAR 0 1
101596: PPUSH
101597: LD_VAR 0 2
101601: PPUSH
101602: LD_VAR 0 3
101606: PPUSH
101607: LD_VAR 0 4
101611: PPUSH
101612: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101616: LD_VAR 0 1
101620: PPUSH
101621: LD_VAR 0 2
101625: PPUSH
101626: LD_VAR 0 3
101630: PPUSH
101631: CALL_OW 331
// end ;
101635: LD_VAR 0 5
101639: RET
// export function Video ( mode ) ; begin
101640: LD_INT 0
101642: PPUSH
// ingame_video = mode ;
101643: LD_ADDR_OWVAR 52
101647: PUSH
101648: LD_VAR 0 1
101652: ST_TO_ADDR
// interface_hidden = mode ;
101653: LD_ADDR_OWVAR 54
101657: PUSH
101658: LD_VAR 0 1
101662: ST_TO_ADDR
// end ;
101663: LD_VAR 0 2
101667: RET
// export function Join ( array , element ) ; begin
101668: LD_INT 0
101670: PPUSH
// result := Replace ( array , array + 1 , element ) ;
101671: LD_ADDR_VAR 0 3
101675: PUSH
101676: LD_VAR 0 1
101680: PPUSH
101681: LD_VAR 0 1
101685: PUSH
101686: LD_INT 1
101688: PLUS
101689: PPUSH
101690: LD_VAR 0 2
101694: PPUSH
101695: CALL_OW 1
101699: ST_TO_ADDR
// end ;
101700: LD_VAR 0 3
101704: RET
// export function JoinUnion ( array , element ) ; begin
101705: LD_INT 0
101707: PPUSH
// result := array union element ;
101708: LD_ADDR_VAR 0 3
101712: PUSH
101713: LD_VAR 0 1
101717: PUSH
101718: LD_VAR 0 2
101722: UNION
101723: ST_TO_ADDR
// end ;
101724: LD_VAR 0 3
101728: RET
// export function GetBehemoths ( side ) ; begin
101729: LD_INT 0
101731: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
101732: LD_ADDR_VAR 0 2
101736: PUSH
101737: LD_INT 22
101739: PUSH
101740: LD_VAR 0 1
101744: PUSH
101745: EMPTY
101746: LIST
101747: LIST
101748: PUSH
101749: LD_INT 31
101751: PUSH
101752: LD_INT 25
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: EMPTY
101760: LIST
101761: LIST
101762: PPUSH
101763: CALL_OW 69
101767: ST_TO_ADDR
// end ;
101768: LD_VAR 0 2
101772: RET
// export function Shuffle ( array ) ; var i , index ; begin
101773: LD_INT 0
101775: PPUSH
101776: PPUSH
101777: PPUSH
// result := [ ] ;
101778: LD_ADDR_VAR 0 2
101782: PUSH
101783: EMPTY
101784: ST_TO_ADDR
// if not array then
101785: LD_VAR 0 1
101789: NOT
101790: IFFALSE 101794
// exit ;
101792: GO 101893
// Randomize ;
101794: CALL_OW 10
// for i = array downto 1 do
101798: LD_ADDR_VAR 0 3
101802: PUSH
101803: DOUBLE
101804: LD_VAR 0 1
101808: INC
101809: ST_TO_ADDR
101810: LD_INT 1
101812: PUSH
101813: FOR_DOWNTO
101814: IFFALSE 101891
// begin index := rand ( 1 , array ) ;
101816: LD_ADDR_VAR 0 4
101820: PUSH
101821: LD_INT 1
101823: PPUSH
101824: LD_VAR 0 1
101828: PPUSH
101829: CALL_OW 12
101833: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101834: LD_ADDR_VAR 0 2
101838: PUSH
101839: LD_VAR 0 2
101843: PPUSH
101844: LD_VAR 0 2
101848: PUSH
101849: LD_INT 1
101851: PLUS
101852: PPUSH
101853: LD_VAR 0 1
101857: PUSH
101858: LD_VAR 0 4
101862: ARRAY
101863: PPUSH
101864: CALL_OW 2
101868: ST_TO_ADDR
// array := Delete ( array , index ) ;
101869: LD_ADDR_VAR 0 1
101873: PUSH
101874: LD_VAR 0 1
101878: PPUSH
101879: LD_VAR 0 4
101883: PPUSH
101884: CALL_OW 3
101888: ST_TO_ADDR
// end ;
101889: GO 101813
101891: POP
101892: POP
// end ;
101893: LD_VAR 0 2
101897: RET
// export function GetBaseMaterials ( base ) ; begin
101898: LD_INT 0
101900: PPUSH
// result := [ 0 , 0 , 0 ] ;
101901: LD_ADDR_VAR 0 2
101905: PUSH
101906: LD_INT 0
101908: PUSH
101909: LD_INT 0
101911: PUSH
101912: LD_INT 0
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: LIST
101919: ST_TO_ADDR
// if not base then
101920: LD_VAR 0 1
101924: NOT
101925: IFFALSE 101929
// exit ;
101927: GO 101978
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101929: LD_ADDR_VAR 0 2
101933: PUSH
101934: LD_VAR 0 1
101938: PPUSH
101939: LD_INT 1
101941: PPUSH
101942: CALL_OW 275
101946: PUSH
101947: LD_VAR 0 1
101951: PPUSH
101952: LD_INT 2
101954: PPUSH
101955: CALL_OW 275
101959: PUSH
101960: LD_VAR 0 1
101964: PPUSH
101965: LD_INT 3
101967: PPUSH
101968: CALL_OW 275
101972: PUSH
101973: EMPTY
101974: LIST
101975: LIST
101976: LIST
101977: ST_TO_ADDR
// end ;
101978: LD_VAR 0 2
101982: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101983: LD_INT 0
101985: PPUSH
101986: PPUSH
// result := array ;
101987: LD_ADDR_VAR 0 3
101991: PUSH
101992: LD_VAR 0 1
101996: ST_TO_ADDR
// if size >= result then
101997: LD_VAR 0 2
102001: PUSH
102002: LD_VAR 0 3
102006: GREATEREQUAL
102007: IFFALSE 102011
// exit ;
102009: GO 102061
// if size then
102011: LD_VAR 0 2
102015: IFFALSE 102061
// for i := array downto size do
102017: LD_ADDR_VAR 0 4
102021: PUSH
102022: DOUBLE
102023: LD_VAR 0 1
102027: INC
102028: ST_TO_ADDR
102029: LD_VAR 0 2
102033: PUSH
102034: FOR_DOWNTO
102035: IFFALSE 102059
// result := Delete ( result , result ) ;
102037: LD_ADDR_VAR 0 3
102041: PUSH
102042: LD_VAR 0 3
102046: PPUSH
102047: LD_VAR 0 3
102051: PPUSH
102052: CALL_OW 3
102056: ST_TO_ADDR
102057: GO 102034
102059: POP
102060: POP
// end ;
102061: LD_VAR 0 3
102065: RET
// export function ComExit ( unit ) ; var tmp ; begin
102066: LD_INT 0
102068: PPUSH
102069: PPUSH
// if not IsInUnit ( unit ) then
102070: LD_VAR 0 1
102074: PPUSH
102075: CALL_OW 310
102079: NOT
102080: IFFALSE 102084
// exit ;
102082: GO 102144
// tmp := IsInUnit ( unit ) ;
102084: LD_ADDR_VAR 0 3
102088: PUSH
102089: LD_VAR 0 1
102093: PPUSH
102094: CALL_OW 310
102098: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
102099: LD_VAR 0 3
102103: PPUSH
102104: CALL_OW 247
102108: PUSH
102109: LD_INT 2
102111: EQUAL
102112: IFFALSE 102125
// ComExitVehicle ( unit ) else
102114: LD_VAR 0 1
102118: PPUSH
102119: CALL_OW 121
102123: GO 102134
// ComExitBuilding ( unit ) ;
102125: LD_VAR 0 1
102129: PPUSH
102130: CALL_OW 122
// result := tmp ;
102134: LD_ADDR_VAR 0 2
102138: PUSH
102139: LD_VAR 0 3
102143: ST_TO_ADDR
// end ;
102144: LD_VAR 0 2
102148: RET
// export function ComExitAll ( units ) ; var i ; begin
102149: LD_INT 0
102151: PPUSH
102152: PPUSH
// if not units then
102153: LD_VAR 0 1
102157: NOT
102158: IFFALSE 102162
// exit ;
102160: GO 102188
// for i in units do
102162: LD_ADDR_VAR 0 3
102166: PUSH
102167: LD_VAR 0 1
102171: PUSH
102172: FOR_IN
102173: IFFALSE 102186
// ComExit ( i ) ;
102175: LD_VAR 0 3
102179: PPUSH
102180: CALL 102066 0 1
102184: GO 102172
102186: POP
102187: POP
// end ;
102188: LD_VAR 0 2
102192: RET
// export function ResetHc ; begin
102193: LD_INT 0
102195: PPUSH
// InitHc ;
102196: CALL_OW 19
// hc_importance := 0 ;
102200: LD_ADDR_OWVAR 32
102204: PUSH
102205: LD_INT 0
102207: ST_TO_ADDR
// end ;
102208: LD_VAR 0 1
102212: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
102213: LD_INT 0
102215: PPUSH
102216: PPUSH
102217: PPUSH
// _x := ( x1 + x2 ) div 2 ;
102218: LD_ADDR_VAR 0 6
102222: PUSH
102223: LD_VAR 0 1
102227: PUSH
102228: LD_VAR 0 3
102232: PLUS
102233: PUSH
102234: LD_INT 2
102236: DIV
102237: ST_TO_ADDR
// if _x < 0 then
102238: LD_VAR 0 6
102242: PUSH
102243: LD_INT 0
102245: LESS
102246: IFFALSE 102263
// _x := _x * - 1 ;
102248: LD_ADDR_VAR 0 6
102252: PUSH
102253: LD_VAR 0 6
102257: PUSH
102258: LD_INT 1
102260: NEG
102261: MUL
102262: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
102263: LD_ADDR_VAR 0 7
102267: PUSH
102268: LD_VAR 0 2
102272: PUSH
102273: LD_VAR 0 4
102277: PLUS
102278: PUSH
102279: LD_INT 2
102281: DIV
102282: ST_TO_ADDR
// if _y < 0 then
102283: LD_VAR 0 7
102287: PUSH
102288: LD_INT 0
102290: LESS
102291: IFFALSE 102308
// _y := _y * - 1 ;
102293: LD_ADDR_VAR 0 7
102297: PUSH
102298: LD_VAR 0 7
102302: PUSH
102303: LD_INT 1
102305: NEG
102306: MUL
102307: ST_TO_ADDR
// result := [ _x , _y ] ;
102308: LD_ADDR_VAR 0 5
102312: PUSH
102313: LD_VAR 0 6
102317: PUSH
102318: LD_VAR 0 7
102322: PUSH
102323: EMPTY
102324: LIST
102325: LIST
102326: ST_TO_ADDR
// end ;
102327: LD_VAR 0 5
102331: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
102332: LD_INT 0
102334: PPUSH
102335: PPUSH
102336: PPUSH
102337: PPUSH
// task := GetTaskList ( unit ) ;
102338: LD_ADDR_VAR 0 7
102342: PUSH
102343: LD_VAR 0 1
102347: PPUSH
102348: CALL_OW 437
102352: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
102353: LD_VAR 0 7
102357: NOT
102358: PUSH
102359: LD_VAR 0 1
102363: PPUSH
102364: LD_VAR 0 2
102368: PPUSH
102369: CALL_OW 308
102373: NOT
102374: AND
102375: IFFALSE 102379
// exit ;
102377: GO 102497
// if IsInArea ( unit , area ) then
102379: LD_VAR 0 1
102383: PPUSH
102384: LD_VAR 0 2
102388: PPUSH
102389: CALL_OW 308
102393: IFFALSE 102411
// begin ComMoveToArea ( unit , goAway ) ;
102395: LD_VAR 0 1
102399: PPUSH
102400: LD_VAR 0 3
102404: PPUSH
102405: CALL_OW 113
// exit ;
102409: GO 102497
// end ; if task [ 1 ] [ 1 ] <> M then
102411: LD_VAR 0 7
102415: PUSH
102416: LD_INT 1
102418: ARRAY
102419: PUSH
102420: LD_INT 1
102422: ARRAY
102423: PUSH
102424: LD_STRING M
102426: NONEQUAL
102427: IFFALSE 102431
// exit ;
102429: GO 102497
// x := task [ 1 ] [ 2 ] ;
102431: LD_ADDR_VAR 0 5
102435: PUSH
102436: LD_VAR 0 7
102440: PUSH
102441: LD_INT 1
102443: ARRAY
102444: PUSH
102445: LD_INT 2
102447: ARRAY
102448: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
102449: LD_ADDR_VAR 0 6
102453: PUSH
102454: LD_VAR 0 7
102458: PUSH
102459: LD_INT 1
102461: ARRAY
102462: PUSH
102463: LD_INT 3
102465: ARRAY
102466: ST_TO_ADDR
// if InArea ( x , y , area ) then
102467: LD_VAR 0 5
102471: PPUSH
102472: LD_VAR 0 6
102476: PPUSH
102477: LD_VAR 0 2
102481: PPUSH
102482: CALL_OW 309
102486: IFFALSE 102497
// ComStop ( unit ) ;
102488: LD_VAR 0 1
102492: PPUSH
102493: CALL_OW 141
// end ;
102497: LD_VAR 0 4
102501: RET
// export function Abs ( value ) ; begin
102502: LD_INT 0
102504: PPUSH
// result := value ;
102505: LD_ADDR_VAR 0 2
102509: PUSH
102510: LD_VAR 0 1
102514: ST_TO_ADDR
// if value < 0 then
102515: LD_VAR 0 1
102519: PUSH
102520: LD_INT 0
102522: LESS
102523: IFFALSE 102540
// result := value * - 1 ;
102525: LD_ADDR_VAR 0 2
102529: PUSH
102530: LD_VAR 0 1
102534: PUSH
102535: LD_INT 1
102537: NEG
102538: MUL
102539: ST_TO_ADDR
// end ;
102540: LD_VAR 0 2
102544: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
102545: LD_INT 0
102547: PPUSH
102548: PPUSH
102549: PPUSH
102550: PPUSH
102551: PPUSH
102552: PPUSH
102553: PPUSH
102554: PPUSH
// if not unit or not building then
102555: LD_VAR 0 1
102559: NOT
102560: PUSH
102561: LD_VAR 0 2
102565: NOT
102566: OR
102567: IFFALSE 102571
// exit ;
102569: GO 102797
// x := GetX ( building ) ;
102571: LD_ADDR_VAR 0 4
102575: PUSH
102576: LD_VAR 0 2
102580: PPUSH
102581: CALL_OW 250
102585: ST_TO_ADDR
// y := GetY ( building ) ;
102586: LD_ADDR_VAR 0 6
102590: PUSH
102591: LD_VAR 0 2
102595: PPUSH
102596: CALL_OW 251
102600: ST_TO_ADDR
// d := GetDir ( building ) ;
102601: LD_ADDR_VAR 0 8
102605: PUSH
102606: LD_VAR 0 2
102610: PPUSH
102611: CALL_OW 254
102615: ST_TO_ADDR
// r := 4 ;
102616: LD_ADDR_VAR 0 9
102620: PUSH
102621: LD_INT 4
102623: ST_TO_ADDR
// for i := 1 to 5 do
102624: LD_ADDR_VAR 0 10
102628: PUSH
102629: DOUBLE
102630: LD_INT 1
102632: DEC
102633: ST_TO_ADDR
102634: LD_INT 5
102636: PUSH
102637: FOR_TO
102638: IFFALSE 102795
// begin _x := ShiftX ( x , d , r + i ) ;
102640: LD_ADDR_VAR 0 5
102644: PUSH
102645: LD_VAR 0 4
102649: PPUSH
102650: LD_VAR 0 8
102654: PPUSH
102655: LD_VAR 0 9
102659: PUSH
102660: LD_VAR 0 10
102664: PLUS
102665: PPUSH
102666: CALL_OW 272
102670: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
102671: LD_ADDR_VAR 0 7
102675: PUSH
102676: LD_VAR 0 6
102680: PPUSH
102681: LD_VAR 0 8
102685: PPUSH
102686: LD_VAR 0 9
102690: PUSH
102691: LD_VAR 0 10
102695: PLUS
102696: PPUSH
102697: CALL_OW 273
102701: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
102702: LD_VAR 0 5
102706: PPUSH
102707: LD_VAR 0 7
102711: PPUSH
102712: CALL_OW 488
102716: PUSH
102717: LD_VAR 0 5
102721: PPUSH
102722: LD_VAR 0 7
102726: PPUSH
102727: CALL_OW 428
102731: PPUSH
102732: CALL_OW 247
102736: PUSH
102737: LD_INT 3
102739: PUSH
102740: LD_INT 2
102742: PUSH
102743: EMPTY
102744: LIST
102745: LIST
102746: IN
102747: NOT
102748: AND
102749: IFFALSE 102793
// begin ComMoveXY ( unit , _x , _y ) ;
102751: LD_VAR 0 1
102755: PPUSH
102756: LD_VAR 0 5
102760: PPUSH
102761: LD_VAR 0 7
102765: PPUSH
102766: CALL_OW 111
// result := [ _x , _y ] ;
102770: LD_ADDR_VAR 0 3
102774: PUSH
102775: LD_VAR 0 5
102779: PUSH
102780: LD_VAR 0 7
102784: PUSH
102785: EMPTY
102786: LIST
102787: LIST
102788: ST_TO_ADDR
// exit ;
102789: POP
102790: POP
102791: GO 102797
// end ; end ;
102793: GO 102637
102795: POP
102796: POP
// end ;
102797: LD_VAR 0 3
102801: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
102802: LD_INT 0
102804: PPUSH
102805: PPUSH
102806: PPUSH
// result := 0 ;
102807: LD_ADDR_VAR 0 3
102811: PUSH
102812: LD_INT 0
102814: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
102815: LD_VAR 0 1
102819: PUSH
102820: LD_INT 0
102822: LESS
102823: PUSH
102824: LD_VAR 0 1
102828: PUSH
102829: LD_INT 8
102831: GREATER
102832: OR
102833: PUSH
102834: LD_VAR 0 2
102838: PUSH
102839: LD_INT 0
102841: LESS
102842: OR
102843: PUSH
102844: LD_VAR 0 2
102848: PUSH
102849: LD_INT 8
102851: GREATER
102852: OR
102853: IFFALSE 102857
// exit ;
102855: GO 102932
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
102857: LD_ADDR_VAR 0 4
102861: PUSH
102862: LD_INT 22
102864: PUSH
102865: LD_VAR 0 2
102869: PUSH
102870: EMPTY
102871: LIST
102872: LIST
102873: PPUSH
102874: CALL_OW 69
102878: PUSH
102879: FOR_IN
102880: IFFALSE 102930
// begin un := UnitShoot ( i ) ;
102882: LD_ADDR_VAR 0 5
102886: PUSH
102887: LD_VAR 0 4
102891: PPUSH
102892: CALL_OW 504
102896: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102897: LD_VAR 0 5
102901: PPUSH
102902: CALL_OW 255
102906: PUSH
102907: LD_VAR 0 1
102911: EQUAL
102912: IFFALSE 102928
// begin result := un ;
102914: LD_ADDR_VAR 0 3
102918: PUSH
102919: LD_VAR 0 5
102923: ST_TO_ADDR
// exit ;
102924: POP
102925: POP
102926: GO 102932
// end ; end ;
102928: GO 102879
102930: POP
102931: POP
// end ;
102932: LD_VAR 0 3
102936: RET
// export function GetCargoBay ( units ) ; begin
102937: LD_INT 0
102939: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
102940: LD_ADDR_VAR 0 2
102944: PUSH
102945: LD_VAR 0 1
102949: PPUSH
102950: LD_INT 2
102952: PUSH
102953: LD_INT 34
102955: PUSH
102956: LD_INT 12
102958: PUSH
102959: EMPTY
102960: LIST
102961: LIST
102962: PUSH
102963: LD_INT 34
102965: PUSH
102966: LD_INT 51
102968: PUSH
102969: EMPTY
102970: LIST
102971: LIST
102972: PUSH
102973: LD_INT 34
102975: PUSH
102976: LD_INT 32
102978: PUSH
102979: EMPTY
102980: LIST
102981: LIST
102982: PUSH
102983: LD_INT 34
102985: PUSH
102986: LD_INT 89
102988: PUSH
102989: EMPTY
102990: LIST
102991: LIST
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: LIST
102997: LIST
102998: LIST
102999: PPUSH
103000: CALL_OW 72
103004: ST_TO_ADDR
// end ;
103005: LD_VAR 0 2
103009: RET
// export function Negate ( value ) ; begin
103010: LD_INT 0
103012: PPUSH
// result := not value ;
103013: LD_ADDR_VAR 0 2
103017: PUSH
103018: LD_VAR 0 1
103022: NOT
103023: ST_TO_ADDR
// end ;
103024: LD_VAR 0 2
103028: RET
// export function Inc ( value ) ; begin
103029: LD_INT 0
103031: PPUSH
// result := value + 1 ;
103032: LD_ADDR_VAR 0 2
103036: PUSH
103037: LD_VAR 0 1
103041: PUSH
103042: LD_INT 1
103044: PLUS
103045: ST_TO_ADDR
// end ;
103046: LD_VAR 0 2
103050: RET
// export function Dec ( value ) ; begin
103051: LD_INT 0
103053: PPUSH
// result := value - 1 ;
103054: LD_ADDR_VAR 0 2
103058: PUSH
103059: LD_VAR 0 1
103063: PUSH
103064: LD_INT 1
103066: MINUS
103067: ST_TO_ADDR
// end ;
103068: LD_VAR 0 2
103072: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
103073: LD_INT 0
103075: PPUSH
103076: PPUSH
103077: PPUSH
103078: PPUSH
103079: PPUSH
103080: PPUSH
103081: PPUSH
103082: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
103083: LD_VAR 0 1
103087: PPUSH
103088: LD_VAR 0 2
103092: PPUSH
103093: CALL_OW 488
103097: NOT
103098: PUSH
103099: LD_VAR 0 3
103103: PPUSH
103104: LD_VAR 0 4
103108: PPUSH
103109: CALL_OW 488
103113: NOT
103114: OR
103115: IFFALSE 103128
// begin result := - 1 ;
103117: LD_ADDR_VAR 0 5
103121: PUSH
103122: LD_INT 1
103124: NEG
103125: ST_TO_ADDR
// exit ;
103126: GO 103363
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
103128: LD_ADDR_VAR 0 12
103132: PUSH
103133: LD_VAR 0 1
103137: PPUSH
103138: LD_VAR 0 2
103142: PPUSH
103143: LD_VAR 0 3
103147: PPUSH
103148: LD_VAR 0 4
103152: PPUSH
103153: CALL 102213 0 4
103157: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
103158: LD_ADDR_VAR 0 11
103162: PUSH
103163: LD_VAR 0 1
103167: PPUSH
103168: LD_VAR 0 2
103172: PPUSH
103173: LD_VAR 0 12
103177: PUSH
103178: LD_INT 1
103180: ARRAY
103181: PPUSH
103182: LD_VAR 0 12
103186: PUSH
103187: LD_INT 2
103189: ARRAY
103190: PPUSH
103191: CALL_OW 298
103195: ST_TO_ADDR
// distance := 9999 ;
103196: LD_ADDR_VAR 0 10
103200: PUSH
103201: LD_INT 9999
103203: ST_TO_ADDR
// for i := 0 to 5 do
103204: LD_ADDR_VAR 0 6
103208: PUSH
103209: DOUBLE
103210: LD_INT 0
103212: DEC
103213: ST_TO_ADDR
103214: LD_INT 5
103216: PUSH
103217: FOR_TO
103218: IFFALSE 103361
// begin _x := ShiftX ( x1 , i , centerDist ) ;
103220: LD_ADDR_VAR 0 7
103224: PUSH
103225: LD_VAR 0 1
103229: PPUSH
103230: LD_VAR 0 6
103234: PPUSH
103235: LD_VAR 0 11
103239: PPUSH
103240: CALL_OW 272
103244: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
103245: LD_ADDR_VAR 0 8
103249: PUSH
103250: LD_VAR 0 2
103254: PPUSH
103255: LD_VAR 0 6
103259: PPUSH
103260: LD_VAR 0 11
103264: PPUSH
103265: CALL_OW 273
103269: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
103270: LD_VAR 0 7
103274: PPUSH
103275: LD_VAR 0 8
103279: PPUSH
103280: CALL_OW 488
103284: NOT
103285: IFFALSE 103289
// continue ;
103287: GO 103217
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
103289: LD_ADDR_VAR 0 9
103293: PUSH
103294: LD_VAR 0 12
103298: PUSH
103299: LD_INT 1
103301: ARRAY
103302: PPUSH
103303: LD_VAR 0 12
103307: PUSH
103308: LD_INT 2
103310: ARRAY
103311: PPUSH
103312: LD_VAR 0 7
103316: PPUSH
103317: LD_VAR 0 8
103321: PPUSH
103322: CALL_OW 298
103326: ST_TO_ADDR
// if tmp < distance then
103327: LD_VAR 0 9
103331: PUSH
103332: LD_VAR 0 10
103336: LESS
103337: IFFALSE 103359
// begin result := i ;
103339: LD_ADDR_VAR 0 5
103343: PUSH
103344: LD_VAR 0 6
103348: ST_TO_ADDR
// distance := tmp ;
103349: LD_ADDR_VAR 0 10
103353: PUSH
103354: LD_VAR 0 9
103358: ST_TO_ADDR
// end ; end ;
103359: GO 103217
103361: POP
103362: POP
// end ;
103363: LD_VAR 0 5
103367: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103368: LD_INT 0
103370: PPUSH
103371: PPUSH
// if not driver or not IsInUnit ( driver ) then
103372: LD_VAR 0 1
103376: NOT
103377: PUSH
103378: LD_VAR 0 1
103382: PPUSH
103383: CALL_OW 310
103387: NOT
103388: OR
103389: IFFALSE 103393
// exit ;
103391: GO 103483
// vehicle := IsInUnit ( driver ) ;
103393: LD_ADDR_VAR 0 3
103397: PUSH
103398: LD_VAR 0 1
103402: PPUSH
103403: CALL_OW 310
103407: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103408: LD_VAR 0 1
103412: PPUSH
103413: LD_STRING \
103415: PUSH
103416: LD_INT 0
103418: PUSH
103419: LD_INT 0
103421: PUSH
103422: LD_INT 0
103424: PUSH
103425: LD_INT 0
103427: PUSH
103428: LD_INT 0
103430: PUSH
103431: LD_INT 0
103433: PUSH
103434: EMPTY
103435: LIST
103436: LIST
103437: LIST
103438: LIST
103439: LIST
103440: LIST
103441: LIST
103442: PUSH
103443: LD_STRING E
103445: PUSH
103446: LD_INT 0
103448: PUSH
103449: LD_INT 0
103451: PUSH
103452: LD_VAR 0 3
103456: PUSH
103457: LD_INT 0
103459: PUSH
103460: LD_INT 0
103462: PUSH
103463: LD_INT 0
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: LIST
103470: LIST
103471: LIST
103472: LIST
103473: LIST
103474: PUSH
103475: EMPTY
103476: LIST
103477: LIST
103478: PPUSH
103479: CALL_OW 446
// end ;
103483: LD_VAR 0 2
103487: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
103488: LD_INT 0
103490: PPUSH
103491: PPUSH
// if not driver or not IsInUnit ( driver ) then
103492: LD_VAR 0 1
103496: NOT
103497: PUSH
103498: LD_VAR 0 1
103502: PPUSH
103503: CALL_OW 310
103507: NOT
103508: OR
103509: IFFALSE 103513
// exit ;
103511: GO 103603
// vehicle := IsInUnit ( driver ) ;
103513: LD_ADDR_VAR 0 3
103517: PUSH
103518: LD_VAR 0 1
103522: PPUSH
103523: CALL_OW 310
103527: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
103528: LD_VAR 0 1
103532: PPUSH
103533: LD_STRING \
103535: PUSH
103536: LD_INT 0
103538: PUSH
103539: LD_INT 0
103541: PUSH
103542: LD_INT 0
103544: PUSH
103545: LD_INT 0
103547: PUSH
103548: LD_INT 0
103550: PUSH
103551: LD_INT 0
103553: PUSH
103554: EMPTY
103555: LIST
103556: LIST
103557: LIST
103558: LIST
103559: LIST
103560: LIST
103561: LIST
103562: PUSH
103563: LD_STRING E
103565: PUSH
103566: LD_INT 0
103568: PUSH
103569: LD_INT 0
103571: PUSH
103572: LD_VAR 0 3
103576: PUSH
103577: LD_INT 0
103579: PUSH
103580: LD_INT 0
103582: PUSH
103583: LD_INT 0
103585: PUSH
103586: EMPTY
103587: LIST
103588: LIST
103589: LIST
103590: LIST
103591: LIST
103592: LIST
103593: LIST
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PPUSH
103599: CALL_OW 447
// end ;
103603: LD_VAR 0 2
103607: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
103608: LD_INT 0
103610: PPUSH
103611: PPUSH
103612: PPUSH
// tmp := [ ] ;
103613: LD_ADDR_VAR 0 5
103617: PUSH
103618: EMPTY
103619: ST_TO_ADDR
// for i in units do
103620: LD_ADDR_VAR 0 4
103624: PUSH
103625: LD_VAR 0 1
103629: PUSH
103630: FOR_IN
103631: IFFALSE 103669
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
103633: LD_ADDR_VAR 0 5
103637: PUSH
103638: LD_VAR 0 5
103642: PPUSH
103643: LD_VAR 0 5
103647: PUSH
103648: LD_INT 1
103650: PLUS
103651: PPUSH
103652: LD_VAR 0 4
103656: PPUSH
103657: CALL_OW 256
103661: PPUSH
103662: CALL_OW 2
103666: ST_TO_ADDR
103667: GO 103630
103669: POP
103670: POP
// if not tmp then
103671: LD_VAR 0 5
103675: NOT
103676: IFFALSE 103680
// exit ;
103678: GO 103728
// if asc then
103680: LD_VAR 0 2
103684: IFFALSE 103708
// result := SortListByListAsc ( units , tmp ) else
103686: LD_ADDR_VAR 0 3
103690: PUSH
103691: LD_VAR 0 1
103695: PPUSH
103696: LD_VAR 0 5
103700: PPUSH
103701: CALL_OW 76
103705: ST_TO_ADDR
103706: GO 103728
// result := SortListByListDesc ( units , tmp ) ;
103708: LD_ADDR_VAR 0 3
103712: PUSH
103713: LD_VAR 0 1
103717: PPUSH
103718: LD_VAR 0 5
103722: PPUSH
103723: CALL_OW 77
103727: ST_TO_ADDR
// end ;
103728: LD_VAR 0 3
103732: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
103733: LD_INT 0
103735: PPUSH
103736: PPUSH
// task := GetTaskList ( mech ) ;
103737: LD_ADDR_VAR 0 4
103741: PUSH
103742: LD_VAR 0 1
103746: PPUSH
103747: CALL_OW 437
103751: ST_TO_ADDR
// if not task then
103752: LD_VAR 0 4
103756: NOT
103757: IFFALSE 103761
// exit ;
103759: GO 103803
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
103761: LD_ADDR_VAR 0 3
103765: PUSH
103766: LD_VAR 0 4
103770: PUSH
103771: LD_INT 1
103773: ARRAY
103774: PUSH
103775: LD_INT 1
103777: ARRAY
103778: PUSH
103779: LD_STRING r
103781: EQUAL
103782: PUSH
103783: LD_VAR 0 4
103787: PUSH
103788: LD_INT 1
103790: ARRAY
103791: PUSH
103792: LD_INT 4
103794: ARRAY
103795: PUSH
103796: LD_VAR 0 2
103800: EQUAL
103801: AND
103802: ST_TO_ADDR
// end ;
103803: LD_VAR 0 3
103807: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
103808: LD_INT 0
103810: PPUSH
// SetDir ( unit , d ) ;
103811: LD_VAR 0 1
103815: PPUSH
103816: LD_VAR 0 4
103820: PPUSH
103821: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
103825: LD_VAR 0 1
103829: PPUSH
103830: LD_VAR 0 2
103834: PPUSH
103835: LD_VAR 0 3
103839: PPUSH
103840: LD_VAR 0 5
103844: PPUSH
103845: CALL_OW 48
// end ;
103849: LD_VAR 0 6
103853: RET
// export function ToNaturalNumber ( number ) ; begin
103854: LD_INT 0
103856: PPUSH
// result := number div 1 ;
103857: LD_ADDR_VAR 0 2
103861: PUSH
103862: LD_VAR 0 1
103866: PUSH
103867: LD_INT 1
103869: DIV
103870: ST_TO_ADDR
// if number < 0 then
103871: LD_VAR 0 1
103875: PUSH
103876: LD_INT 0
103878: LESS
103879: IFFALSE 103889
// result := 0 ;
103881: LD_ADDR_VAR 0 2
103885: PUSH
103886: LD_INT 0
103888: ST_TO_ADDR
// end ;
103889: LD_VAR 0 2
103893: RET
// export function SortByClass ( units , class ) ; var un ; begin
103894: LD_INT 0
103896: PPUSH
103897: PPUSH
// if not units or not class then
103898: LD_VAR 0 1
103902: NOT
103903: PUSH
103904: LD_VAR 0 2
103908: NOT
103909: OR
103910: IFFALSE 103914
// exit ;
103912: GO 104009
// result := [ ] ;
103914: LD_ADDR_VAR 0 3
103918: PUSH
103919: EMPTY
103920: ST_TO_ADDR
// for un in units do
103921: LD_ADDR_VAR 0 4
103925: PUSH
103926: LD_VAR 0 1
103930: PUSH
103931: FOR_IN
103932: IFFALSE 104007
// if GetClass ( un ) = class then
103934: LD_VAR 0 4
103938: PPUSH
103939: CALL_OW 257
103943: PUSH
103944: LD_VAR 0 2
103948: EQUAL
103949: IFFALSE 103976
// result := Insert ( result , 1 , un ) else
103951: LD_ADDR_VAR 0 3
103955: PUSH
103956: LD_VAR 0 3
103960: PPUSH
103961: LD_INT 1
103963: PPUSH
103964: LD_VAR 0 4
103968: PPUSH
103969: CALL_OW 2
103973: ST_TO_ADDR
103974: GO 104005
// result := Replace ( result , result + 1 , un ) ;
103976: LD_ADDR_VAR 0 3
103980: PUSH
103981: LD_VAR 0 3
103985: PPUSH
103986: LD_VAR 0 3
103990: PUSH
103991: LD_INT 1
103993: PLUS
103994: PPUSH
103995: LD_VAR 0 4
103999: PPUSH
104000: CALL_OW 1
104004: ST_TO_ADDR
104005: GO 103931
104007: POP
104008: POP
// end ;
104009: LD_VAR 0 3
104013: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
104014: LD_INT 0
104016: PPUSH
104017: PPUSH
104018: PPUSH
104019: PPUSH
104020: PPUSH
104021: PPUSH
104022: PPUSH
// result := [ ] ;
104023: LD_ADDR_VAR 0 4
104027: PUSH
104028: EMPTY
104029: ST_TO_ADDR
// if x - r < 0 then
104030: LD_VAR 0 1
104034: PUSH
104035: LD_VAR 0 3
104039: MINUS
104040: PUSH
104041: LD_INT 0
104043: LESS
104044: IFFALSE 104056
// min_x := 0 else
104046: LD_ADDR_VAR 0 8
104050: PUSH
104051: LD_INT 0
104053: ST_TO_ADDR
104054: GO 104072
// min_x := x - r ;
104056: LD_ADDR_VAR 0 8
104060: PUSH
104061: LD_VAR 0 1
104065: PUSH
104066: LD_VAR 0 3
104070: MINUS
104071: ST_TO_ADDR
// if y - r < 0 then
104072: LD_VAR 0 2
104076: PUSH
104077: LD_VAR 0 3
104081: MINUS
104082: PUSH
104083: LD_INT 0
104085: LESS
104086: IFFALSE 104098
// min_y := 0 else
104088: LD_ADDR_VAR 0 7
104092: PUSH
104093: LD_INT 0
104095: ST_TO_ADDR
104096: GO 104114
// min_y := y - r ;
104098: LD_ADDR_VAR 0 7
104102: PUSH
104103: LD_VAR 0 2
104107: PUSH
104108: LD_VAR 0 3
104112: MINUS
104113: ST_TO_ADDR
// max_x := x + r ;
104114: LD_ADDR_VAR 0 9
104118: PUSH
104119: LD_VAR 0 1
104123: PUSH
104124: LD_VAR 0 3
104128: PLUS
104129: ST_TO_ADDR
// max_y := y + r ;
104130: LD_ADDR_VAR 0 10
104134: PUSH
104135: LD_VAR 0 2
104139: PUSH
104140: LD_VAR 0 3
104144: PLUS
104145: ST_TO_ADDR
// for _x = min_x to max_x do
104146: LD_ADDR_VAR 0 5
104150: PUSH
104151: DOUBLE
104152: LD_VAR 0 8
104156: DEC
104157: ST_TO_ADDR
104158: LD_VAR 0 9
104162: PUSH
104163: FOR_TO
104164: IFFALSE 104265
// for _y = min_y to max_y do
104166: LD_ADDR_VAR 0 6
104170: PUSH
104171: DOUBLE
104172: LD_VAR 0 7
104176: DEC
104177: ST_TO_ADDR
104178: LD_VAR 0 10
104182: PUSH
104183: FOR_TO
104184: IFFALSE 104261
// begin if not ValidHex ( _x , _y ) then
104186: LD_VAR 0 5
104190: PPUSH
104191: LD_VAR 0 6
104195: PPUSH
104196: CALL_OW 488
104200: NOT
104201: IFFALSE 104205
// continue ;
104203: GO 104183
// if GetResourceTypeXY ( _x , _y ) then
104205: LD_VAR 0 5
104209: PPUSH
104210: LD_VAR 0 6
104214: PPUSH
104215: CALL_OW 283
104219: IFFALSE 104259
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
104221: LD_ADDR_VAR 0 4
104225: PUSH
104226: LD_VAR 0 4
104230: PPUSH
104231: LD_VAR 0 4
104235: PUSH
104236: LD_INT 1
104238: PLUS
104239: PPUSH
104240: LD_VAR 0 5
104244: PUSH
104245: LD_VAR 0 6
104249: PUSH
104250: EMPTY
104251: LIST
104252: LIST
104253: PPUSH
104254: CALL_OW 1
104258: ST_TO_ADDR
// end ;
104259: GO 104183
104261: POP
104262: POP
104263: GO 104163
104265: POP
104266: POP
// end ;
104267: LD_VAR 0 4
104271: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
104272: LD_INT 0
104274: PPUSH
104275: PPUSH
104276: PPUSH
104277: PPUSH
104278: PPUSH
104279: PPUSH
104280: PPUSH
104281: PPUSH
// if not units then
104282: LD_VAR 0 1
104286: NOT
104287: IFFALSE 104291
// exit ;
104289: GO 104815
// result := UnitFilter ( units , [ f_ok ] ) ;
104291: LD_ADDR_VAR 0 3
104295: PUSH
104296: LD_VAR 0 1
104300: PPUSH
104301: LD_INT 50
104303: PUSH
104304: EMPTY
104305: LIST
104306: PPUSH
104307: CALL_OW 72
104311: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
104312: LD_ADDR_VAR 0 8
104316: PUSH
104317: LD_VAR 0 1
104321: PUSH
104322: LD_INT 1
104324: ARRAY
104325: PPUSH
104326: CALL_OW 255
104330: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
104331: LD_ADDR_VAR 0 10
104335: PUSH
104336: LD_INT 29
104338: PUSH
104339: LD_INT 91
104341: PUSH
104342: LD_INT 49
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: LIST
104349: ST_TO_ADDR
// if not result then
104350: LD_VAR 0 3
104354: NOT
104355: IFFALSE 104359
// exit ;
104357: GO 104815
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
104359: LD_ADDR_VAR 0 5
104363: PUSH
104364: LD_INT 81
104366: PUSH
104367: LD_VAR 0 8
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: PPUSH
104376: CALL_OW 69
104380: ST_TO_ADDR
// for i in result do
104381: LD_ADDR_VAR 0 4
104385: PUSH
104386: LD_VAR 0 3
104390: PUSH
104391: FOR_IN
104392: IFFALSE 104813
// begin tag := GetTag ( i ) + 1 ;
104394: LD_ADDR_VAR 0 9
104398: PUSH
104399: LD_VAR 0 4
104403: PPUSH
104404: CALL_OW 110
104408: PUSH
104409: LD_INT 1
104411: PLUS
104412: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
104413: LD_ADDR_VAR 0 7
104417: PUSH
104418: LD_VAR 0 4
104422: PPUSH
104423: CALL_OW 250
104427: PPUSH
104428: LD_VAR 0 4
104432: PPUSH
104433: CALL_OW 251
104437: PPUSH
104438: LD_INT 6
104440: PPUSH
104441: CALL 104014 0 3
104445: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
104446: LD_VAR 0 4
104450: PPUSH
104451: CALL_OW 247
104455: PUSH
104456: LD_INT 2
104458: EQUAL
104459: PUSH
104460: LD_VAR 0 7
104464: AND
104465: PUSH
104466: LD_VAR 0 4
104470: PPUSH
104471: CALL_OW 264
104475: PUSH
104476: LD_VAR 0 10
104480: IN
104481: NOT
104482: AND
104483: IFFALSE 104522
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
104485: LD_VAR 0 4
104489: PPUSH
104490: LD_VAR 0 7
104494: PUSH
104495: LD_INT 1
104497: ARRAY
104498: PUSH
104499: LD_INT 1
104501: ARRAY
104502: PPUSH
104503: LD_VAR 0 7
104507: PUSH
104508: LD_INT 1
104510: ARRAY
104511: PUSH
104512: LD_INT 2
104514: ARRAY
104515: PPUSH
104516: CALL_OW 116
104520: GO 104811
// if path > tag then
104522: LD_VAR 0 2
104526: PUSH
104527: LD_VAR 0 9
104531: GREATER
104532: IFFALSE 104740
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
104534: LD_ADDR_VAR 0 6
104538: PUSH
104539: LD_VAR 0 5
104543: PPUSH
104544: LD_INT 91
104546: PUSH
104547: LD_VAR 0 4
104551: PUSH
104552: LD_INT 8
104554: PUSH
104555: EMPTY
104556: LIST
104557: LIST
104558: LIST
104559: PPUSH
104560: CALL_OW 72
104564: ST_TO_ADDR
// if nearEnemy then
104565: LD_VAR 0 6
104569: IFFALSE 104638
// begin if GetWeapon ( i ) = ru_time_lapser then
104571: LD_VAR 0 4
104575: PPUSH
104576: CALL_OW 264
104580: PUSH
104581: LD_INT 49
104583: EQUAL
104584: IFFALSE 104612
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
104586: LD_VAR 0 4
104590: PPUSH
104591: LD_VAR 0 6
104595: PPUSH
104596: LD_VAR 0 4
104600: PPUSH
104601: CALL_OW 74
104605: PPUSH
104606: CALL_OW 112
104610: GO 104636
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
104612: LD_VAR 0 4
104616: PPUSH
104617: LD_VAR 0 6
104621: PPUSH
104622: LD_VAR 0 4
104626: PPUSH
104627: CALL_OW 74
104631: PPUSH
104632: CALL 105740 0 2
// end else
104636: GO 104738
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
104638: LD_VAR 0 4
104642: PPUSH
104643: LD_VAR 0 2
104647: PUSH
104648: LD_VAR 0 9
104652: ARRAY
104653: PUSH
104654: LD_INT 1
104656: ARRAY
104657: PPUSH
104658: LD_VAR 0 2
104662: PUSH
104663: LD_VAR 0 9
104667: ARRAY
104668: PUSH
104669: LD_INT 2
104671: ARRAY
104672: PPUSH
104673: CALL_OW 297
104677: PUSH
104678: LD_INT 6
104680: GREATER
104681: IFFALSE 104724
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
104683: LD_VAR 0 4
104687: PPUSH
104688: LD_VAR 0 2
104692: PUSH
104693: LD_VAR 0 9
104697: ARRAY
104698: PUSH
104699: LD_INT 1
104701: ARRAY
104702: PPUSH
104703: LD_VAR 0 2
104707: PUSH
104708: LD_VAR 0 9
104712: ARRAY
104713: PUSH
104714: LD_INT 2
104716: ARRAY
104717: PPUSH
104718: CALL_OW 114
104722: GO 104738
// SetTag ( i , tag ) ;
104724: LD_VAR 0 4
104728: PPUSH
104729: LD_VAR 0 9
104733: PPUSH
104734: CALL_OW 109
// end else
104738: GO 104811
// if enemy then
104740: LD_VAR 0 5
104744: IFFALSE 104811
// begin if GetWeapon ( i ) = ru_time_lapser then
104746: LD_VAR 0 4
104750: PPUSH
104751: CALL_OW 264
104755: PUSH
104756: LD_INT 49
104758: EQUAL
104759: IFFALSE 104787
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
104761: LD_VAR 0 4
104765: PPUSH
104766: LD_VAR 0 5
104770: PPUSH
104771: LD_VAR 0 4
104775: PPUSH
104776: CALL_OW 74
104780: PPUSH
104781: CALL_OW 112
104785: GO 104811
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
104787: LD_VAR 0 4
104791: PPUSH
104792: LD_VAR 0 5
104796: PPUSH
104797: LD_VAR 0 4
104801: PPUSH
104802: CALL_OW 74
104806: PPUSH
104807: CALL 105740 0 2
// end ; end ;
104811: GO 104391
104813: POP
104814: POP
// end ;
104815: LD_VAR 0 3
104819: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
104820: LD_INT 0
104822: PPUSH
104823: PPUSH
104824: PPUSH
// if not unit or IsInUnit ( unit ) then
104825: LD_VAR 0 1
104829: NOT
104830: PUSH
104831: LD_VAR 0 1
104835: PPUSH
104836: CALL_OW 310
104840: OR
104841: IFFALSE 104845
// exit ;
104843: GO 104936
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
104845: LD_ADDR_VAR 0 4
104849: PUSH
104850: LD_VAR 0 1
104854: PPUSH
104855: CALL_OW 250
104859: PPUSH
104860: LD_VAR 0 2
104864: PPUSH
104865: LD_INT 1
104867: PPUSH
104868: CALL_OW 272
104872: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
104873: LD_ADDR_VAR 0 5
104877: PUSH
104878: LD_VAR 0 1
104882: PPUSH
104883: CALL_OW 251
104887: PPUSH
104888: LD_VAR 0 2
104892: PPUSH
104893: LD_INT 1
104895: PPUSH
104896: CALL_OW 273
104900: ST_TO_ADDR
// if ValidHex ( x , y ) then
104901: LD_VAR 0 4
104905: PPUSH
104906: LD_VAR 0 5
104910: PPUSH
104911: CALL_OW 488
104915: IFFALSE 104936
// ComTurnXY ( unit , x , y ) ;
104917: LD_VAR 0 1
104921: PPUSH
104922: LD_VAR 0 4
104926: PPUSH
104927: LD_VAR 0 5
104931: PPUSH
104932: CALL_OW 118
// end ;
104936: LD_VAR 0 3
104940: RET
// export function SeeUnits ( side , units ) ; var i ; begin
104941: LD_INT 0
104943: PPUSH
104944: PPUSH
// result := false ;
104945: LD_ADDR_VAR 0 3
104949: PUSH
104950: LD_INT 0
104952: ST_TO_ADDR
// if not units then
104953: LD_VAR 0 2
104957: NOT
104958: IFFALSE 104962
// exit ;
104960: GO 105007
// for i in units do
104962: LD_ADDR_VAR 0 4
104966: PUSH
104967: LD_VAR 0 2
104971: PUSH
104972: FOR_IN
104973: IFFALSE 105005
// if See ( side , i ) then
104975: LD_VAR 0 1
104979: PPUSH
104980: LD_VAR 0 4
104984: PPUSH
104985: CALL_OW 292
104989: IFFALSE 105003
// begin result := true ;
104991: LD_ADDR_VAR 0 3
104995: PUSH
104996: LD_INT 1
104998: ST_TO_ADDR
// exit ;
104999: POP
105000: POP
105001: GO 105007
// end ;
105003: GO 104972
105005: POP
105006: POP
// end ;
105007: LD_VAR 0 3
105011: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
105012: LD_INT 0
105014: PPUSH
105015: PPUSH
105016: PPUSH
105017: PPUSH
// if not unit or not points then
105018: LD_VAR 0 1
105022: NOT
105023: PUSH
105024: LD_VAR 0 2
105028: NOT
105029: OR
105030: IFFALSE 105034
// exit ;
105032: GO 105124
// dist := 99999 ;
105034: LD_ADDR_VAR 0 5
105038: PUSH
105039: LD_INT 99999
105041: ST_TO_ADDR
// for i in points do
105042: LD_ADDR_VAR 0 4
105046: PUSH
105047: LD_VAR 0 2
105051: PUSH
105052: FOR_IN
105053: IFFALSE 105122
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
105055: LD_ADDR_VAR 0 6
105059: PUSH
105060: LD_VAR 0 1
105064: PPUSH
105065: LD_VAR 0 4
105069: PUSH
105070: LD_INT 1
105072: ARRAY
105073: PPUSH
105074: LD_VAR 0 4
105078: PUSH
105079: LD_INT 2
105081: ARRAY
105082: PPUSH
105083: CALL_OW 297
105087: ST_TO_ADDR
// if tmpDist < dist then
105088: LD_VAR 0 6
105092: PUSH
105093: LD_VAR 0 5
105097: LESS
105098: IFFALSE 105120
// begin result := i ;
105100: LD_ADDR_VAR 0 3
105104: PUSH
105105: LD_VAR 0 4
105109: ST_TO_ADDR
// dist := tmpDist ;
105110: LD_ADDR_VAR 0 5
105114: PUSH
105115: LD_VAR 0 6
105119: ST_TO_ADDR
// end ; end ;
105120: GO 105052
105122: POP
105123: POP
// end ;
105124: LD_VAR 0 3
105128: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
105129: LD_INT 0
105131: PPUSH
// uc_side := side ;
105132: LD_ADDR_OWVAR 20
105136: PUSH
105137: LD_VAR 0 1
105141: ST_TO_ADDR
// uc_nation := 3 ;
105142: LD_ADDR_OWVAR 21
105146: PUSH
105147: LD_INT 3
105149: ST_TO_ADDR
// vc_chassis := 25 ;
105150: LD_ADDR_OWVAR 37
105154: PUSH
105155: LD_INT 25
105157: ST_TO_ADDR
// vc_engine := engine_siberite ;
105158: LD_ADDR_OWVAR 39
105162: PUSH
105163: LD_INT 3
105165: ST_TO_ADDR
// vc_control := control_computer ;
105166: LD_ADDR_OWVAR 38
105170: PUSH
105171: LD_INT 3
105173: ST_TO_ADDR
// vc_weapon := 59 ;
105174: LD_ADDR_OWVAR 40
105178: PUSH
105179: LD_INT 59
105181: ST_TO_ADDR
// result := CreateVehicle ;
105182: LD_ADDR_VAR 0 5
105186: PUSH
105187: CALL_OW 45
105191: ST_TO_ADDR
// SetDir ( result , d ) ;
105192: LD_VAR 0 5
105196: PPUSH
105197: LD_VAR 0 4
105201: PPUSH
105202: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
105206: LD_VAR 0 5
105210: PPUSH
105211: LD_VAR 0 2
105215: PPUSH
105216: LD_VAR 0 3
105220: PPUSH
105221: LD_INT 0
105223: PPUSH
105224: CALL_OW 48
// end ;
105228: LD_VAR 0 5
105232: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
105233: LD_INT 0
105235: PPUSH
105236: PPUSH
105237: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
105238: LD_ADDR_VAR 0 2
105242: PUSH
105243: LD_INT 0
105245: PUSH
105246: LD_INT 0
105248: PUSH
105249: LD_INT 0
105251: PUSH
105252: LD_INT 0
105254: PUSH
105255: EMPTY
105256: LIST
105257: LIST
105258: LIST
105259: LIST
105260: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
105261: LD_VAR 0 1
105265: NOT
105266: PUSH
105267: LD_VAR 0 1
105271: PPUSH
105272: CALL_OW 264
105276: PUSH
105277: LD_INT 12
105279: PUSH
105280: LD_INT 51
105282: PUSH
105283: LD_INT 32
105285: PUSH
105286: LD_INT 89
105288: PUSH
105289: EMPTY
105290: LIST
105291: LIST
105292: LIST
105293: LIST
105294: IN
105295: NOT
105296: OR
105297: IFFALSE 105301
// exit ;
105299: GO 105399
// for i := 1 to 3 do
105301: LD_ADDR_VAR 0 3
105305: PUSH
105306: DOUBLE
105307: LD_INT 1
105309: DEC
105310: ST_TO_ADDR
105311: LD_INT 3
105313: PUSH
105314: FOR_TO
105315: IFFALSE 105397
// begin tmp := GetCargo ( cargo , i ) ;
105317: LD_ADDR_VAR 0 4
105321: PUSH
105322: LD_VAR 0 1
105326: PPUSH
105327: LD_VAR 0 3
105331: PPUSH
105332: CALL_OW 289
105336: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
105337: LD_ADDR_VAR 0 2
105341: PUSH
105342: LD_VAR 0 2
105346: PPUSH
105347: LD_VAR 0 3
105351: PPUSH
105352: LD_VAR 0 4
105356: PPUSH
105357: CALL_OW 1
105361: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
105362: LD_ADDR_VAR 0 2
105366: PUSH
105367: LD_VAR 0 2
105371: PPUSH
105372: LD_INT 4
105374: PPUSH
105375: LD_VAR 0 2
105379: PUSH
105380: LD_INT 4
105382: ARRAY
105383: PUSH
105384: LD_VAR 0 4
105388: PLUS
105389: PPUSH
105390: CALL_OW 1
105394: ST_TO_ADDR
// end ;
105395: GO 105314
105397: POP
105398: POP
// end ;
105399: LD_VAR 0 2
105403: RET
// export function Length ( array ) ; begin
105404: LD_INT 0
105406: PPUSH
// result := array + 0 ;
105407: LD_ADDR_VAR 0 2
105411: PUSH
105412: LD_VAR 0 1
105416: PUSH
105417: LD_INT 0
105419: PLUS
105420: ST_TO_ADDR
// end ;
105421: LD_VAR 0 2
105425: RET
// export function PrepareArray ( array ) ; begin
105426: LD_INT 0
105428: PPUSH
// result := array diff 0 ;
105429: LD_ADDR_VAR 0 2
105433: PUSH
105434: LD_VAR 0 1
105438: PUSH
105439: LD_INT 0
105441: DIFF
105442: ST_TO_ADDR
// if not result [ 1 ] then
105443: LD_VAR 0 2
105447: PUSH
105448: LD_INT 1
105450: ARRAY
105451: NOT
105452: IFFALSE 105472
// result := Delete ( result , 1 ) ;
105454: LD_ADDR_VAR 0 2
105458: PUSH
105459: LD_VAR 0 2
105463: PPUSH
105464: LD_INT 1
105466: PPUSH
105467: CALL_OW 3
105471: ST_TO_ADDR
// end ;
105472: LD_VAR 0 2
105476: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
105477: LD_INT 0
105479: PPUSH
105480: PPUSH
105481: PPUSH
105482: PPUSH
// sibRocketRange := 25 ;
105483: LD_ADDR_VAR 0 6
105487: PUSH
105488: LD_INT 25
105490: ST_TO_ADDR
// result := false ;
105491: LD_ADDR_VAR 0 4
105495: PUSH
105496: LD_INT 0
105498: ST_TO_ADDR
// for i := 0 to 5 do
105499: LD_ADDR_VAR 0 5
105503: PUSH
105504: DOUBLE
105505: LD_INT 0
105507: DEC
105508: ST_TO_ADDR
105509: LD_INT 5
105511: PUSH
105512: FOR_TO
105513: IFFALSE 105580
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
105515: LD_VAR 0 1
105519: PPUSH
105520: LD_VAR 0 5
105524: PPUSH
105525: LD_VAR 0 6
105529: PPUSH
105530: CALL_OW 272
105534: PPUSH
105535: LD_VAR 0 2
105539: PPUSH
105540: LD_VAR 0 5
105544: PPUSH
105545: LD_VAR 0 6
105549: PPUSH
105550: CALL_OW 273
105554: PPUSH
105555: LD_VAR 0 3
105559: PPUSH
105560: CALL_OW 309
105564: IFFALSE 105578
// begin result := true ;
105566: LD_ADDR_VAR 0 4
105570: PUSH
105571: LD_INT 1
105573: ST_TO_ADDR
// exit ;
105574: POP
105575: POP
105576: GO 105582
// end ;
105578: GO 105512
105580: POP
105581: POP
// end ;
105582: LD_VAR 0 4
105586: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
105587: LD_INT 0
105589: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
105590: LD_VAR 0 1
105594: PPUSH
105595: LD_VAR 0 2
105599: PPUSH
105600: LD_INT 0
105602: PPUSH
105603: LD_INT 0
105605: PPUSH
105606: LD_INT 1
105608: PPUSH
105609: LD_INT 0
105611: PPUSH
105612: CALL_OW 587
// end ;
105616: LD_VAR 0 3
105620: RET
// export function CenterOnNow ( unit ) ; begin
105621: LD_INT 0
105623: PPUSH
// result := IsInUnit ( unit ) ;
105624: LD_ADDR_VAR 0 2
105628: PUSH
105629: LD_VAR 0 1
105633: PPUSH
105634: CALL_OW 310
105638: ST_TO_ADDR
// if not result then
105639: LD_VAR 0 2
105643: NOT
105644: IFFALSE 105656
// result := unit ;
105646: LD_ADDR_VAR 0 2
105650: PUSH
105651: LD_VAR 0 1
105655: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
105656: LD_VAR 0 1
105660: PPUSH
105661: CALL_OW 87
// end ;
105665: LD_VAR 0 2
105669: RET
// export function ComMoveHex ( unit , hex ) ; begin
105670: LD_INT 0
105672: PPUSH
// if not hex then
105673: LD_VAR 0 2
105677: NOT
105678: IFFALSE 105682
// exit ;
105680: GO 105735
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
105682: LD_VAR 0 2
105686: PUSH
105687: LD_INT 1
105689: ARRAY
105690: PPUSH
105691: LD_VAR 0 2
105695: PUSH
105696: LD_INT 2
105698: ARRAY
105699: PPUSH
105700: CALL_OW 428
105704: IFFALSE 105708
// exit ;
105706: GO 105735
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
105708: LD_VAR 0 1
105712: PPUSH
105713: LD_VAR 0 2
105717: PUSH
105718: LD_INT 1
105720: ARRAY
105721: PPUSH
105722: LD_VAR 0 2
105726: PUSH
105727: LD_INT 2
105729: ARRAY
105730: PPUSH
105731: CALL_OW 111
// end ;
105735: LD_VAR 0 3
105739: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
105740: LD_INT 0
105742: PPUSH
105743: PPUSH
105744: PPUSH
// if not unit or not enemy then
105745: LD_VAR 0 1
105749: NOT
105750: PUSH
105751: LD_VAR 0 2
105755: NOT
105756: OR
105757: IFFALSE 105761
// exit ;
105759: GO 105885
// x := GetX ( enemy ) ;
105761: LD_ADDR_VAR 0 4
105765: PUSH
105766: LD_VAR 0 2
105770: PPUSH
105771: CALL_OW 250
105775: ST_TO_ADDR
// y := GetY ( enemy ) ;
105776: LD_ADDR_VAR 0 5
105780: PUSH
105781: LD_VAR 0 2
105785: PPUSH
105786: CALL_OW 251
105790: ST_TO_ADDR
// if ValidHex ( x , y ) then
105791: LD_VAR 0 4
105795: PPUSH
105796: LD_VAR 0 5
105800: PPUSH
105801: CALL_OW 488
105805: IFFALSE 105885
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
105807: LD_VAR 0 2
105811: PPUSH
105812: CALL_OW 247
105816: PUSH
105817: LD_INT 3
105819: PUSH
105820: LD_INT 2
105822: PUSH
105823: EMPTY
105824: LIST
105825: LIST
105826: IN
105827: PUSH
105828: LD_VAR 0 1
105832: PPUSH
105833: CALL_OW 255
105837: PPUSH
105838: LD_VAR 0 2
105842: PPUSH
105843: CALL_OW 292
105847: OR
105848: IFFALSE 105866
// ComAttackUnit ( unit , enemy ) else
105850: LD_VAR 0 1
105854: PPUSH
105855: LD_VAR 0 2
105859: PPUSH
105860: CALL_OW 115
105864: GO 105885
// ComAgressiveMove ( unit , x , y ) ;
105866: LD_VAR 0 1
105870: PPUSH
105871: LD_VAR 0 4
105875: PPUSH
105876: LD_VAR 0 5
105880: PPUSH
105881: CALL_OW 114
// end ;
105885: LD_VAR 0 3
105889: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
105890: LD_INT 0
105892: PPUSH
105893: PPUSH
105894: PPUSH
// list := AreaToList ( area , 0 ) ;
105895: LD_ADDR_VAR 0 5
105899: PUSH
105900: LD_VAR 0 1
105904: PPUSH
105905: LD_INT 0
105907: PPUSH
105908: CALL_OW 517
105912: ST_TO_ADDR
// if not list then
105913: LD_VAR 0 5
105917: NOT
105918: IFFALSE 105922
// exit ;
105920: GO 106052
// if all then
105922: LD_VAR 0 2
105926: IFFALSE 106014
// begin for i := 1 to list [ 1 ] do
105928: LD_ADDR_VAR 0 4
105932: PUSH
105933: DOUBLE
105934: LD_INT 1
105936: DEC
105937: ST_TO_ADDR
105938: LD_VAR 0 5
105942: PUSH
105943: LD_INT 1
105945: ARRAY
105946: PUSH
105947: FOR_TO
105948: IFFALSE 106010
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
105950: LD_ADDR_VAR 0 3
105954: PUSH
105955: LD_VAR 0 3
105959: PPUSH
105960: LD_VAR 0 3
105964: PUSH
105965: LD_INT 1
105967: PLUS
105968: PPUSH
105969: LD_VAR 0 5
105973: PUSH
105974: LD_INT 1
105976: ARRAY
105977: PUSH
105978: LD_VAR 0 4
105982: ARRAY
105983: PUSH
105984: LD_VAR 0 5
105988: PUSH
105989: LD_INT 2
105991: ARRAY
105992: PUSH
105993: LD_VAR 0 4
105997: ARRAY
105998: PUSH
105999: EMPTY
106000: LIST
106001: LIST
106002: PPUSH
106003: CALL_OW 1
106007: ST_TO_ADDR
106008: GO 105947
106010: POP
106011: POP
// exit ;
106012: GO 106052
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
106014: LD_ADDR_VAR 0 3
106018: PUSH
106019: LD_VAR 0 5
106023: PUSH
106024: LD_INT 1
106026: ARRAY
106027: PUSH
106028: LD_INT 1
106030: ARRAY
106031: PUSH
106032: LD_VAR 0 5
106036: PUSH
106037: LD_INT 2
106039: ARRAY
106040: PUSH
106041: LD_INT 1
106043: ARRAY
106044: PUSH
106045: EMPTY
106046: LIST
106047: LIST
106048: PUSH
106049: EMPTY
106050: LIST
106051: ST_TO_ADDR
// end ;
106052: LD_VAR 0 3
106056: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
106057: LD_INT 0
106059: PPUSH
106060: PPUSH
// list := AreaToList ( area , 0 ) ;
106061: LD_ADDR_VAR 0 4
106065: PUSH
106066: LD_VAR 0 1
106070: PPUSH
106071: LD_INT 0
106073: PPUSH
106074: CALL_OW 517
106078: ST_TO_ADDR
// if not list then
106079: LD_VAR 0 4
106083: NOT
106084: IFFALSE 106088
// exit ;
106086: GO 106129
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
106088: LD_ADDR_VAR 0 3
106092: PUSH
106093: LD_VAR 0 4
106097: PUSH
106098: LD_INT 1
106100: ARRAY
106101: PUSH
106102: LD_INT 1
106104: ARRAY
106105: PUSH
106106: LD_VAR 0 4
106110: PUSH
106111: LD_INT 2
106113: ARRAY
106114: PUSH
106115: LD_INT 1
106117: ARRAY
106118: PUSH
106119: LD_VAR 0 2
106123: PUSH
106124: EMPTY
106125: LIST
106126: LIST
106127: LIST
106128: ST_TO_ADDR
// end ;
106129: LD_VAR 0 3
106133: RET
// export function First ( array ) ; begin
106134: LD_INT 0
106136: PPUSH
// if not array then
106137: LD_VAR 0 1
106141: NOT
106142: IFFALSE 106146
// exit ;
106144: GO 106160
// result := array [ 1 ] ;
106146: LD_ADDR_VAR 0 2
106150: PUSH
106151: LD_VAR 0 1
106155: PUSH
106156: LD_INT 1
106158: ARRAY
106159: ST_TO_ADDR
// end ;
106160: LD_VAR 0 2
106164: RET
// export function Last ( array ) ; begin
106165: LD_INT 0
106167: PPUSH
// if not array then
106168: LD_VAR 0 1
106172: NOT
106173: IFFALSE 106177
// exit ;
106175: GO 106193
// result := array [ array ] ;
106177: LD_ADDR_VAR 0 2
106181: PUSH
106182: LD_VAR 0 1
106186: PUSH
106187: LD_VAR 0 1
106191: ARRAY
106192: ST_TO_ADDR
// end ;
106193: LD_VAR 0 2
106197: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
106198: LD_INT 0
106200: PPUSH
106201: PPUSH
// result := [ ] ;
106202: LD_ADDR_VAR 0 5
106206: PUSH
106207: EMPTY
106208: ST_TO_ADDR
// if not array then
106209: LD_VAR 0 1
106213: NOT
106214: IFFALSE 106218
// exit ;
106216: GO 106330
// for i := 1 to array do
106218: LD_ADDR_VAR 0 6
106222: PUSH
106223: DOUBLE
106224: LD_INT 1
106226: DEC
106227: ST_TO_ADDR
106228: LD_VAR 0 1
106232: PUSH
106233: FOR_TO
106234: IFFALSE 106328
// if array [ i ] [ index ] = value then
106236: LD_VAR 0 1
106240: PUSH
106241: LD_VAR 0 6
106245: ARRAY
106246: PUSH
106247: LD_VAR 0 2
106251: ARRAY
106252: PUSH
106253: LD_VAR 0 3
106257: EQUAL
106258: IFFALSE 106326
// begin if indexColumn then
106260: LD_VAR 0 4
106264: IFFALSE 106300
// result := Join ( result , array [ i ] [ indexColumn ] ) else
106266: LD_ADDR_VAR 0 5
106270: PUSH
106271: LD_VAR 0 5
106275: PPUSH
106276: LD_VAR 0 1
106280: PUSH
106281: LD_VAR 0 6
106285: ARRAY
106286: PUSH
106287: LD_VAR 0 4
106291: ARRAY
106292: PPUSH
106293: CALL 101668 0 2
106297: ST_TO_ADDR
106298: GO 106326
// result := Join ( result , array [ i ] ) ;
106300: LD_ADDR_VAR 0 5
106304: PUSH
106305: LD_VAR 0 5
106309: PPUSH
106310: LD_VAR 0 1
106314: PUSH
106315: LD_VAR 0 6
106319: ARRAY
106320: PPUSH
106321: CALL 101668 0 2
106325: ST_TO_ADDR
// end ;
106326: GO 106233
106328: POP
106329: POP
// end ;
106330: LD_VAR 0 5
106334: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
106335: LD_INT 0
106337: PPUSH
106338: PPUSH
106339: PPUSH
// if btype = b_depot then
106340: LD_VAR 0 2
106344: PUSH
106345: LD_INT 0
106347: EQUAL
106348: IFFALSE 106360
// begin result := true ;
106350: LD_ADDR_VAR 0 3
106354: PUSH
106355: LD_INT 1
106357: ST_TO_ADDR
// exit ;
106358: GO 106476
// end ; pom := GetBase ( depot ) ;
106360: LD_ADDR_VAR 0 4
106364: PUSH
106365: LD_VAR 0 1
106369: PPUSH
106370: CALL_OW 274
106374: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
106375: LD_ADDR_VAR 0 5
106379: PUSH
106380: LD_VAR 0 2
106384: PPUSH
106385: LD_VAR 0 1
106389: PPUSH
106390: CALL_OW 248
106394: PPUSH
106395: CALL_OW 450
106399: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
106400: LD_ADDR_VAR 0 3
106404: PUSH
106405: LD_VAR 0 4
106409: PPUSH
106410: LD_INT 1
106412: PPUSH
106413: CALL_OW 275
106417: PUSH
106418: LD_VAR 0 5
106422: PUSH
106423: LD_INT 1
106425: ARRAY
106426: GREATEREQUAL
106427: PUSH
106428: LD_VAR 0 4
106432: PPUSH
106433: LD_INT 2
106435: PPUSH
106436: CALL_OW 275
106440: PUSH
106441: LD_VAR 0 5
106445: PUSH
106446: LD_INT 2
106448: ARRAY
106449: GREATEREQUAL
106450: AND
106451: PUSH
106452: LD_VAR 0 4
106456: PPUSH
106457: LD_INT 3
106459: PPUSH
106460: CALL_OW 275
106464: PUSH
106465: LD_VAR 0 5
106469: PUSH
106470: LD_INT 3
106472: ARRAY
106473: GREATEREQUAL
106474: AND
106475: ST_TO_ADDR
// end ;
106476: LD_VAR 0 3
106480: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
106481: LD_INT 0
106483: PPUSH
// if not vehicles or not parkingPoint then
106484: LD_VAR 0 1
106488: NOT
106489: PUSH
106490: LD_VAR 0 2
106494: NOT
106495: OR
106496: IFFALSE 106500
// exit ;
106498: GO 106598
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
106500: LD_ADDR_VAR 0 1
106504: PUSH
106505: LD_VAR 0 1
106509: PPUSH
106510: LD_INT 50
106512: PUSH
106513: EMPTY
106514: LIST
106515: PUSH
106516: LD_INT 3
106518: PUSH
106519: LD_INT 92
106521: PUSH
106522: LD_VAR 0 2
106526: PUSH
106527: LD_INT 1
106529: ARRAY
106530: PUSH
106531: LD_VAR 0 2
106535: PUSH
106536: LD_INT 2
106538: ARRAY
106539: PUSH
106540: LD_INT 8
106542: PUSH
106543: EMPTY
106544: LIST
106545: LIST
106546: LIST
106547: LIST
106548: PUSH
106549: EMPTY
106550: LIST
106551: LIST
106552: PUSH
106553: EMPTY
106554: LIST
106555: LIST
106556: PPUSH
106557: CALL_OW 72
106561: ST_TO_ADDR
// if not vehicles then
106562: LD_VAR 0 1
106566: NOT
106567: IFFALSE 106571
// exit ;
106569: GO 106598
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
106571: LD_VAR 0 1
106575: PPUSH
106576: LD_VAR 0 2
106580: PUSH
106581: LD_INT 1
106583: ARRAY
106584: PPUSH
106585: LD_VAR 0 2
106589: PUSH
106590: LD_INT 2
106592: ARRAY
106593: PPUSH
106594: CALL_OW 111
// end ;
106598: LD_VAR 0 3
106602: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
106603: LD_INT 0
106605: PPUSH
106606: PPUSH
106607: PPUSH
// if not side or not area then
106608: LD_VAR 0 1
106612: NOT
106613: PUSH
106614: LD_VAR 0 2
106618: NOT
106619: OR
106620: IFFALSE 106624
// exit ;
106622: GO 106743
// tmp := AreaToList ( area , 0 ) ;
106624: LD_ADDR_VAR 0 5
106628: PUSH
106629: LD_VAR 0 2
106633: PPUSH
106634: LD_INT 0
106636: PPUSH
106637: CALL_OW 517
106641: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
106642: LD_ADDR_VAR 0 4
106646: PUSH
106647: DOUBLE
106648: LD_INT 1
106650: DEC
106651: ST_TO_ADDR
106652: LD_VAR 0 5
106656: PUSH
106657: LD_INT 1
106659: ARRAY
106660: PUSH
106661: FOR_TO
106662: IFFALSE 106741
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
106664: LD_VAR 0 5
106668: PUSH
106669: LD_INT 1
106671: ARRAY
106672: PUSH
106673: LD_VAR 0 4
106677: ARRAY
106678: PPUSH
106679: LD_VAR 0 5
106683: PUSH
106684: LD_INT 2
106686: ARRAY
106687: PUSH
106688: LD_VAR 0 4
106692: ARRAY
106693: PPUSH
106694: CALL_OW 351
106698: IFFALSE 106739
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
106700: LD_VAR 0 5
106704: PUSH
106705: LD_INT 1
106707: ARRAY
106708: PUSH
106709: LD_VAR 0 4
106713: ARRAY
106714: PPUSH
106715: LD_VAR 0 5
106719: PUSH
106720: LD_INT 2
106722: ARRAY
106723: PUSH
106724: LD_VAR 0 4
106728: ARRAY
106729: PPUSH
106730: LD_VAR 0 1
106734: PPUSH
106735: CALL_OW 244
// end ;
106739: GO 106661
106741: POP
106742: POP
// end ; end_of_file
106743: LD_VAR 0 3
106747: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
106748: LD_VAR 0 1
106752: PUSH
106753: LD_INT 200
106755: DOUBLE
106756: GREATEREQUAL
106757: IFFALSE 106765
106759: LD_INT 299
106761: DOUBLE
106762: LESSEQUAL
106763: IFTRUE 106767
106765: GO 106799
106767: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
106768: LD_VAR 0 1
106772: PPUSH
106773: LD_VAR 0 2
106777: PPUSH
106778: LD_VAR 0 3
106782: PPUSH
106783: LD_VAR 0 4
106787: PPUSH
106788: LD_VAR 0 5
106792: PPUSH
106793: CALL 59459 0 5
106797: GO 106876
106799: LD_INT 300
106801: DOUBLE
106802: GREATEREQUAL
106803: IFFALSE 106811
106805: LD_INT 399
106807: DOUBLE
106808: LESSEQUAL
106809: IFTRUE 106813
106811: GO 106875
106813: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
106814: LD_VAR 0 1
106818: PPUSH
106819: LD_VAR 0 2
106823: PPUSH
106824: LD_VAR 0 3
106828: PPUSH
106829: LD_VAR 0 4
106833: PPUSH
106834: LD_VAR 0 5
106838: PPUSH
106839: LD_VAR 0 6
106843: PPUSH
106844: LD_VAR 0 7
106848: PPUSH
106849: LD_VAR 0 8
106853: PPUSH
106854: LD_VAR 0 9
106858: PPUSH
106859: LD_VAR 0 10
106863: PPUSH
106864: LD_VAR 0 11
106868: PPUSH
106869: CALL 55784 0 11
106873: GO 106876
106875: POP
// end ;
106876: PPOPN 11
106878: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
106879: LD_VAR 0 1
106883: PPUSH
106884: LD_VAR 0 2
106888: PPUSH
106889: LD_VAR 0 3
106893: PPUSH
106894: LD_VAR 0 4
106898: PPUSH
106899: LD_VAR 0 5
106903: PPUSH
106904: CALL 59195 0 5
// end ; end_of_file
106908: PPOPN 5
106910: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
106911: LD_VAR 0 1
106915: PPUSH
106916: LD_VAR 0 2
106920: PPUSH
106921: LD_VAR 0 3
106925: PPUSH
106926: LD_VAR 0 4
106930: PPUSH
106931: LD_VAR 0 5
106935: PPUSH
106936: LD_VAR 0 6
106940: PPUSH
106941: CALL 43436 0 6
// end ;
106945: PPOPN 6
106947: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
106948: LD_INT 0
106950: PPUSH
// begin if not units then
106951: LD_VAR 0 1
106955: NOT
106956: IFFALSE 106960
// exit ;
106958: GO 106960
// end ;
106960: PPOPN 7
106962: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
106963: CALL 43323 0 0
// end ;
106967: PPOPN 1
106969: END
