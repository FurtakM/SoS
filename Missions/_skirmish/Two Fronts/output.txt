// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7640 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4617 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4916 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41603 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42054 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21371 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21307 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18300 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21207 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22221 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21448 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21241 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21274 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18079 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22129 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20386 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20961 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20961 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20758 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20422 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20598 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19882 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20496 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20997 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21737 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21307 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18300 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21207 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21448 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21241 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21274 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18079 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22129 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20386 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20961 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20961 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20758 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20422 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20598 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19882 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20496 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20997 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21737 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19882 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11587 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21955 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11587 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21955 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11587 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21955 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11587 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21955 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7859 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7859 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7859 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7859 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7859 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4477
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 10
4389: PUSH
4390: LD_INT 9
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: LD_OWVAR 67
4405: ARRAY
4406: PPUSH
4407: LD_INT 10
4409: PUSH
4410: LD_INT 9
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: LD_INT -2
4429: PUSH
4430: LD_INT -5
4432: PUSH
4433: LD_INT -3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: LD_VAR 0 6
4445: ADD
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 2
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 3
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 42
4476: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4477: LD_EXP 25
4481: PPUSH
4482: LD_INT 9
4484: PPUSH
4485: LD_INT 0
4487: PPUSH
4488: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: PPUSH
4501: LD_INT 2
4503: PPUSH
4504: CALL_OW 336
// for i = 1 to tmp do
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: DOUBLE
4514: LD_INT 1
4516: DEC
4517: ST_TO_ADDR
4518: LD_VAR 0 5
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4579
// if i < 4 then
4526: LD_VAR 0 3
4530: PUSH
4531: LD_INT 4
4533: LESS
4534: IFFALSE 4559
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4536: LD_VAR 0 5
4540: PUSH
4541: LD_VAR 0 3
4545: ARRAY
4546: PPUSH
4547: LD_INT 9
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 49
4557: GO 4577
// SetSide ( tmp [ i ] , 6 ) ;
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: ARRAY
4569: PPUSH
4570: LD_INT 6
4572: PPUSH
4573: CALL_OW 235
4577: GO 4523
4579: POP
4580: POP
// player_squad := tmp ;
4581: LD_ADDR_EXP 23
4585: PUSH
4586: LD_VAR 0 5
4590: ST_TO_ADDR
// pl_counter := 4 ;
4591: LD_ADDR_EXP 24
4595: PUSH
4596: LD_INT 4
4598: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4599: LD_INT 17
4601: PPUSH
4602: LD_INT 5
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL 18300 0 3
// end ;
4612: LD_VAR 0 2
4616: RET
// export Popov ; export function InitAction ; var commander ; begin
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4621: LD_INT 6
4623: PPUSH
4624: LD_INT 3
4626: PPUSH
4627: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: CALL_OW 86
// uc_side := 6 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 6
4648: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4649: LD_ADDR_EXP 26
4653: PUSH
4654: LD_STRING Popov
4656: PPUSH
4657: CALL_OW 25
4661: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4662: LD_ADDR_OWVAR 67
4666: PUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 426
4674: ST_TO_ADDR
// if not Difficulty then
4675: LD_OWVAR 67
4679: NOT
4680: IFFALSE 4690
// Difficulty := 2 ;
4682: LD_ADDR_OWVAR 67
4686: PUSH
4687: LD_INT 2
4689: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: LD_INT 1
4697: PPUSH
4698: CALL_OW 426
4702: ST_TO_ADDR
// if not commander then
4703: LD_VAR 0 2
4707: NOT
4708: IFFALSE 4718
// commander := 1 ;
4710: LD_ADDR_VAR 0 2
4714: PUSH
4715: LD_INT 1
4717: ST_TO_ADDR
// InitCommanders ( commander ) ;
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL 3137 0 1
// end ;
4727: LD_VAR 0 1
4731: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4732: LD_EXP 24
4736: PUSH
4737: LD_INT 12
4739: LESS
4740: IFFALSE 4913
4742: GO 4744
4744: DISABLE
4745: LD_INT 0
4747: PPUSH
// begin enable ;
4748: ENABLE
// for i = pl_counter to pl_counter + 2 do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_EXP 24
4759: DEC
4760: ST_TO_ADDR
4761: LD_EXP 24
4765: PUSH
4766: LD_INT 2
4768: PLUS
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4817
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4773: LD_EXP 23
4777: PUSH
4778: LD_VAR 0 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 18
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4794: LD_EXP 23
4798: PUSH
4799: LD_VAR 0 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 107
4807: PPUSH
4808: LD_INT 88
4810: PPUSH
4811: CALL_OW 111
// end ;
4815: GO 4770
4817: POP
4818: POP
// for i = pl_counter to pl_counter + 2 do
4819: LD_ADDR_VAR 0 1
4823: PUSH
4824: DOUBLE
4825: LD_EXP 24
4829: DEC
4830: ST_TO_ADDR
4831: LD_EXP 24
4835: PUSH
4836: LD_INT 2
4838: PLUS
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4897
// begin repeat wait ( 0 0$01 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4850: LD_EXP 23
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 107
4863: PPUSH
4864: LD_INT 88
4866: PPUSH
4867: CALL_OW 297
4871: PUSH
4872: LD_INT 6
4874: LESS
4875: IFFALSE 4843
// SetSide ( player_squad [ i ] , 3 ) ;
4877: LD_EXP 23
4881: PUSH
4882: LD_VAR 0 1
4886: ARRAY
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: CALL_OW 235
// end ;
4895: GO 4840
4897: POP
4898: POP
// pl_counter := pl_counter + 3 ;
4899: LD_ADDR_EXP 24
4903: PUSH
4904: LD_EXP 24
4908: PUSH
4909: LD_INT 3
4911: PLUS
4912: ST_TO_ADDR
// end ;
4913: PPOPN 1
4915: END
// export function Dialog ; begin
4916: LD_INT 0
4918: PPUSH
// if not isTest then
4919: LD_EXP 1
4923: NOT
4924: IFFALSE 4946
// case query ( task ) of 1 :
4926: LD_STRING task
4928: PPUSH
4929: CALL_OW 97
4933: PUSH
4934: LD_INT 1
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// InGameOn ;
4946: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4950: LD_INT 107
4952: PPUSH
4953: LD_INT 84
4955: PPUSH
4956: CALL_OW 86
// if isTest then
4960: LD_EXP 1
4964: IFFALSE 4974
// dialogue_skipped := true ;
4966: LD_ADDR_OWVAR 59
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4974: LD_ADDR_EXP 11
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_INT 1
4986: ARRAY
4987: PPUSH
4988: LD_INT 0
4990: PPUSH
4991: LD_INT 96
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 2
4999: PPUSH
5000: CALL_OW 145
5004: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5012: LD_EXP 26
5016: PPUSH
5017: LD_STRING DR1
5019: PPUSH
5020: CALL_OW 94
// Wait ( 0 0$01 ) ;
5024: LD_INT 35
5026: PPUSH
5027: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5031: LD_EXP 26
5035: PPUSH
5036: LD_STRING DR2
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5043: LD_EXP 26
5047: PPUSH
5048: LD_STRING DR3
5050: PPUSH
5051: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5062: LD_INT 3
5064: PPUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL 11587 0 2
5079: PUSH
5080: LD_EXP 1
5084: OR
5085: IFFALSE 5055
// InGameOff ;
5087: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5091: LD_STRING C1
5093: PPUSH
5094: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5105: LD_EXP 11
5109: PPUSH
5110: CALL_OW 461
5114: PUSH
5115: LD_INT 2
5117: EQUAL
5118: IFFALSE 5098
// if not isTest then
5120: LD_EXP 1
5124: NOT
5125: IFFALSE 5147
// case query ( support ) of 1 :
5127: LD_STRING support
5129: PPUSH
5130: CALL_OW 97
5134: PUSH
5135: LD_INT 1
5137: DOUBLE
5138: EQUAL
5139: IFTRUE 5143
5141: GO 5146
5143: POP
// ; end ;
5144: GO 5147
5146: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5147: LD_INT 3
5149: PPUSH
5150: LD_INT 12
5152: PPUSH
5153: LD_INT 2
5155: PPUSH
5156: LD_INT 22
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 0
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 69
5184: PUSH
5185: LD_INT 1
5187: ARRAY
5188: PPUSH
5189: CALL_OW 468
// if player_com = stolypin then
5193: LD_EXP 25
5197: PUSH
5198: LD_EXP 22
5202: EQUAL
5203: IFFALSE 5232
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5205: LD_INT 18
5207: PPUSH
5208: LD_INT 3
5210: PUSH
5211: LD_INT 3
5213: PUSH
5214: LD_INT 2
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: ARRAY
5227: PPUSH
5228: CALL 6656 0 2
// end ;
5232: LD_VAR 0 1
5236: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5237: LD_EXP 12
5241: PUSH
5242: LD_OWVAR 1
5246: PUSH
5247: LD_INT 31500
5249: LESS
5250: AND
5251: IFFALSE 5423
// case query ( call1 ) of 1 :
5253: LD_STRING call1
5255: PPUSH
5256: CALL_OW 97
5260: PUSH
5261: LD_INT 1
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5411
5269: POP
// begin callUsed := true ;
5270: LD_ADDR_EXP 3
5274: PUSH
5275: LD_INT 1
5277: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5278: LD_INT 3
5280: PPUSH
5281: LD_INT 12
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_EXP 11
5291: PPUSH
5292: CALL_OW 468
// call := false ;
5296: LD_ADDR_EXP 12
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5304: LD_EXP 26
5308: PPUSH
5309: LD_STRING DR6
5311: PPUSH
5312: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5316: LD_INT 6300
5318: PPUSH
5319: LD_INT 8400
5321: PPUSH
5322: CALL_OW 12
5326: PPUSH
5327: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5331: LD_INT 18
5333: PUSH
5334: LD_INT 19
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_INT 2
5346: PPUSH
5347: CALL_OW 12
5351: ARRAY
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 2
5358: PPUSH
5359: CALL_OW 12
5363: PPUSH
5364: CALL 6656 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5368: LD_INT 25200
5370: PPUSH
5371: LD_INT 35700
5373: PPUSH
5374: CALL_OW 12
5378: PPUSH
5379: CALL_OW 67
// call := true ;
5383: LD_ADDR_EXP 12
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 12
5396: PPUSH
5397: LD_INT 2
5399: PPUSH
5400: LD_EXP 11
5404: PPUSH
5405: CALL_OW 468
// end ; 2 :
5409: GO 5423
5411: LD_INT 2
5413: DOUBLE
5414: EQUAL
5415: IFTRUE 5419
5417: GO 5422
5419: POP
// ; end ;
5420: GO 5423
5422: POP
// if call and tick >= 15 15$00 then
5423: LD_EXP 12
5427: PUSH
5428: LD_OWVAR 1
5432: PUSH
5433: LD_INT 31500
5435: GREATEREQUAL
5436: AND
5437: IFFALSE 5882
// case query ( call2 ) of 1 :
5439: LD_STRING call2
5441: PPUSH
5442: CALL_OW 97
5446: PUSH
5447: LD_INT 1
5449: DOUBLE
5450: EQUAL
5451: IFTRUE 5455
5453: GO 5699
5455: POP
// begin callUsed := true ;
5456: LD_ADDR_EXP 3
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// call := false ;
5464: LD_ADDR_EXP 12
5468: PUSH
5469: LD_INT 0
5471: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5472: LD_INT 1
5474: PPUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL 11587 0 2
5489: PUSH
5490: LD_INT 4
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11587 0 2
5507: AND
5508: IFFALSE 5556
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PUSH
5513: LD_INT 19
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 2
5525: PPUSH
5526: CALL_OW 12
5530: ARRAY
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6417 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11587 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5579: LD_INT 19
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 3
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6417 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5606: LD_INT 4
5608: PPUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL 11587 0 2
5623: PUSH
5624: LD_INT 0
5626: EQUAL
5627: IFFALSE 5656
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5629: LD_INT 18
5631: PPUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 4
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: PUSH
5646: LD_OWVAR 67
5650: ARRAY
5651: PPUSH
5652: CALL 6417 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5656: LD_INT 10500
5658: PPUSH
5659: LD_INT 23100
5661: PPUSH
5662: CALL_OW 12
5666: PPUSH
5667: CALL_OW 67
// call := true ;
5671: LD_ADDR_EXP 12
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5679: LD_INT 3
5681: PPUSH
5682: LD_INT 12
5684: PPUSH
5685: LD_INT 2
5687: PPUSH
5688: LD_EXP 11
5692: PPUSH
5693: CALL_OW 468
// end ; 2 :
5697: GO 5882
5699: LD_INT 2
5701: DOUBLE
5702: EQUAL
5703: IFTRUE 5707
5705: GO 5870
5707: POP
// begin callUsed := true ;
5708: LD_ADDR_EXP 3
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5716: LD_INT 3
5718: PPUSH
5719: LD_INT 12
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: LD_EXP 11
5729: PPUSH
5730: CALL_OW 468
// call := false ;
5734: LD_ADDR_EXP 12
5738: PUSH
5739: LD_INT 0
5741: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5742: LD_EXP 26
5746: PPUSH
5747: LD_STRING DR6
5749: PPUSH
5750: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5754: LD_INT 6300
5756: PPUSH
5757: LD_INT 8400
5759: PPUSH
5760: CALL_OW 12
5764: PPUSH
5765: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5769: LD_INT 18
5771: PUSH
5772: LD_INT 19
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PUSH
5779: LD_INT 1
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: CALL_OW 12
5789: ARRAY
5790: PPUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_OWVAR 67
5809: ARRAY
5810: PUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 12
5821: MINUS
5822: PPUSH
5823: CALL 6656 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5827: LD_INT 35700
5829: PPUSH
5830: LD_INT 44100
5832: PPUSH
5833: CALL_OW 12
5837: PPUSH
5838: CALL_OW 67
// call := true ;
5842: LD_ADDR_EXP 12
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5850: LD_INT 3
5852: PPUSH
5853: LD_INT 12
5855: PPUSH
5856: LD_INT 2
5858: PPUSH
5859: LD_EXP 11
5863: PPUSH
5864: CALL_OW 468
// end ; 3 :
5868: GO 5882
5870: LD_INT 3
5872: DOUBLE
5873: EQUAL
5874: IFTRUE 5878
5876: GO 5881
5878: POP
// ; end ;
5879: GO 5882
5881: POP
// end ;
5882: PPOPN 4
5884: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5885: LD_INT 22
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 69
5913: PUSH
5914: LD_INT 0
5916: EQUAL
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 21
5930: PUSH
5931: LD_INT 1
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 69
5946: PUSH
5947: LD_INT 0
5949: EQUAL
5950: AND
5951: IFFALSE 6255
5953: GO 5955
5955: DISABLE
// begin DialogueOn ;
5956: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5960: LD_EXP 26
5964: PPUSH
5965: LD_STRING DR7
5967: PPUSH
5968: CALL_OW 94
// case player_com of Gorki :
5972: LD_EXP 25
5976: PUSH
5977: LD_EXP 21
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 5997
5987: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5988: LD_STRING ACH_GORKI
5990: PPUSH
5991: CALL_OW 543
5995: GO 6058
5997: LD_EXP 22
6001: DOUBLE
6002: EQUAL
6003: IFTRUE 6007
6005: GO 6017
6007: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
6008: LD_STRING ACH_STOLYP
6010: PPUSH
6011: CALL_OW 543
6015: GO 6058
6017: LD_EXP 20
6021: DOUBLE
6022: EQUAL
6023: IFTRUE 6027
6025: GO 6037
6027: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
6028: LD_STRING ACH_DAVIDOV
6030: PPUSH
6031: CALL_OW 543
6035: GO 6058
6037: LD_EXP 19
6041: DOUBLE
6042: EQUAL
6043: IFTRUE 6047
6045: GO 6057
6047: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6048: LD_STRING ACH_GLADKOV
6050: PPUSH
6051: CALL_OW 543
6055: GO 6058
6057: POP
// if not callUsed then
6058: LD_EXP 3
6062: NOT
6063: IFFALSE 6072
// SetAchievement ( ACH_NOSUPP ) ;
6065: LD_STRING ACH_NOSUPP
6067: PPUSH
6068: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6072: LD_OWVAR 1
6076: PUSH
6077: LD_INT 116550
6079: PUSH
6080: LD_INT 95550
6082: PUSH
6083: LD_INT 89250
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: LESS
6097: IFFALSE 6111
// AddMedal ( med1 , 1 ) else
6099: LD_STRING med1
6101: PPUSH
6102: LD_INT 1
6104: PPUSH
6105: CALL_OW 101
6109: GO 6122
// AddMedal ( med1 , - 1 ) ;
6111: LD_STRING med1
6113: PPUSH
6114: LD_INT 1
6116: NEG
6117: PPUSH
6118: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6122: LD_INT 81
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 21
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: LD_INT 0
6153: EQUAL
6154: IFFALSE 6168
// AddMedal ( med3 , 1 ) else
6156: LD_STRING med3
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 101
6166: GO 6179
// AddMedal ( med3 , - 1 ) ;
6168: LD_STRING med3
6170: PPUSH
6171: LD_INT 1
6173: NEG
6174: PPUSH
6175: CALL_OW 101
// if player_loss = 0 then
6179: LD_EXP 10
6183: PUSH
6184: LD_INT 0
6186: EQUAL
6187: IFFALSE 6201
// AddMedal ( med2 , 1 ) else
6189: LD_STRING med2
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 101
6199: GO 6244
// if player_loss > 0 and player_loss < 3 then
6201: LD_EXP 10
6205: PUSH
6206: LD_INT 0
6208: GREATER
6209: PUSH
6210: LD_EXP 10
6214: PUSH
6215: LD_INT 3
6217: LESS
6218: AND
6219: IFFALSE 6233
// AddMedal ( med2 , 2 ) else
6221: LD_STRING med2
6223: PPUSH
6224: LD_INT 2
6226: PPUSH
6227: CALL_OW 101
6231: GO 6244
// AddMedal ( med2 , - 1 ) ;
6233: LD_STRING med2
6235: PPUSH
6236: LD_INT 1
6238: NEG
6239: PPUSH
6240: CALL_OW 101
// GiveMedals ( MAIN ) ;
6244: LD_STRING MAIN
6246: PPUSH
6247: CALL_OW 102
// YouWin ;
6251: CALL_OW 103
// end ;
6255: END
// every 0 0$01 trigger IsDead ( player_com ) do
6256: LD_EXP 25
6260: PPUSH
6261: CALL_OW 301
6265: IFFALSE 6332
6267: GO 6269
6269: DISABLE
// begin if IsLive ( Houten ) then
6270: LD_EXP 4
6274: PPUSH
6275: CALL_OW 300
6279: IFFALSE 6295
// SayRadio ( Houten , DJ5 ) else
6281: LD_EXP 4
6285: PPUSH
6286: LD_STRING DJ5
6288: PPUSH
6289: CALL_OW 94
6293: GO 6318
// if IsLive ( Brown ) then
6295: LD_EXP 5
6299: PPUSH
6300: CALL_OW 300
6304: IFFALSE 6318
// SayRadio ( Brown , DS5 ) ;
6306: LD_EXP 5
6310: PPUSH
6311: LD_STRING DS5
6313: PPUSH
6314: CALL_OW 94
// Wait ( 0 0$01 ) ;
6318: LD_INT 35
6320: PPUSH
6321: CALL_OW 67
// YouLost ( dead ) ;
6325: LD_STRING dead
6327: PPUSH
6328: CALL_OW 104
// end ;
6332: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6333: LD_EXP 11
6337: PPUSH
6338: CALL_OW 301
6342: PUSH
6343: LD_EXP 1
6347: NOT
6348: AND
6349: IFFALSE 6416
6351: GO 6353
6353: DISABLE
// begin if IsLive ( Brown ) then
6354: LD_EXP 5
6358: PPUSH
6359: CALL_OW 300
6363: IFFALSE 6379
// SayRadio ( Brown , DS5 ) else
6365: LD_EXP 5
6369: PPUSH
6370: LD_STRING DS5
6372: PPUSH
6373: CALL_OW 94
6377: GO 6402
// if IsLive ( Houten ) then
6379: LD_EXP 4
6383: PPUSH
6384: CALL_OW 300
6388: IFFALSE 6402
// SayRadio ( Houten , DJ5 ) ;
6390: LD_EXP 4
6394: PPUSH
6395: LD_STRING DJ5
6397: PPUSH
6398: CALL_OW 94
// Wait ( 0 0$01 ) ;
6402: LD_INT 35
6404: PPUSH
6405: CALL_OW 67
// YouLost ( depot ) ;
6409: LD_STRING depot
6411: PPUSH
6412: CALL_OW 104
// end ;
6416: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
6421: PPUSH
// for i = 1 to n do
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6641
// begin uc_side := 6 ;
6440: LD_ADDR_OWVAR 20
6444: PUSH
6445: LD_INT 6
6447: ST_TO_ADDR
// uc_nation := 3 ;
6448: LD_ADDR_OWVAR 21
6452: PUSH
6453: LD_INT 3
6455: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6456: LD_ADDR_OWVAR 37
6460: PUSH
6461: LD_INT 23
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 1
6473: PPUSH
6474: LD_INT 2
6476: PPUSH
6477: CALL_OW 12
6481: ARRAY
6482: ST_TO_ADDR
// vc_control := control_computer ;
6483: LD_ADDR_OWVAR 38
6487: PUSH
6488: LD_INT 3
6490: ST_TO_ADDR
// vc_engine := engine_siberite ;
6491: LD_ADDR_OWVAR 39
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6499: LD_ADDR_OWVAR 40
6503: PUSH
6504: LD_INT 43
6506: PUSH
6507: LD_INT 44
6509: PUSH
6510: LD_INT 44
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 1
6520: PPUSH
6521: LD_INT 3
6523: PPUSH
6524: CALL_OW 12
6528: ARRAY
6529: ST_TO_ADDR
// un := CreateVehicle ;
6530: LD_ADDR_VAR 0 5
6534: PUSH
6535: CALL_OW 45
6539: ST_TO_ADDR
// case area of east_arr :
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 18
6547: DOUBLE
6548: EQUAL
6549: IFTRUE 6553
6551: GO 6588
6553: POP
// begin PlaceUnitArea ( un , area , false ) ;
6554: LD_VAR 0 5
6558: PPUSH
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 0
6566: PPUSH
6567: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_INT 79
6578: PPUSH
6579: LD_INT 33
6581: PPUSH
6582: CALL_OW 111
// end ; south_arr :
6586: GO 6632
6588: LD_INT 19
6590: DOUBLE
6591: EQUAL
6592: IFTRUE 6596
6594: GO 6631
6596: POP
// begin PlaceUnitArea ( un , area , false ) ;
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 1
6606: PPUSH
6607: LD_INT 0
6609: PPUSH
6610: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 131
6621: PPUSH
6622: LD_INT 148
6624: PPUSH
6625: CALL_OW 111
// end ; end ;
6629: GO 6632
6631: POP
// Wait ( 0 0$02 ) ;
6632: LD_INT 70
6634: PPUSH
6635: CALL_OW 67
// end ;
6639: GO 6437
6641: POP
6642: POP
// pink_attack := true ;
6643: LD_ADDR_EXP 13
6647: PUSH
6648: LD_INT 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 3
6655: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// for i = 1 to n do
6661: LD_ADDR_VAR 0 4
6665: PUSH
6666: DOUBLE
6667: LD_INT 1
6669: DEC
6670: ST_TO_ADDR
6671: LD_VAR 0 2
6675: PUSH
6676: FOR_TO
6677: IFFALSE 6903
// begin uc_side := 6 ;
6679: LD_ADDR_OWVAR 20
6683: PUSH
6684: LD_INT 6
6686: ST_TO_ADDR
// uc_nation := 3 ;
6687: LD_ADDR_OWVAR 21
6691: PUSH
6692: LD_INT 3
6694: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6695: LD_INT 0
6697: PPUSH
6698: LD_INT 3
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6708: LD_ADDR_OWVAR 37
6712: PUSH
6713: LD_INT 22
6715: ST_TO_ADDR
// vc_control := control_manual ;
6716: LD_ADDR_OWVAR 38
6720: PUSH
6721: LD_INT 1
6723: ST_TO_ADDR
// vc_engine := engine_combustion ;
6724: LD_ADDR_OWVAR 39
6728: PUSH
6729: LD_INT 1
6731: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6732: LD_ADDR_OWVAR 40
6736: PUSH
6737: LD_INT 51
6739: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6740: LD_ADDR_OWVAR 41
6744: PUSH
6745: LD_INT 50
6747: ST_TO_ADDR
// un := CreateVehicle ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: CALL_OW 45
6757: ST_TO_ADDR
// case area of east_arr :
6758: LD_VAR 0 1
6762: PUSH
6763: LD_INT 18
6765: DOUBLE
6766: EQUAL
6767: IFTRUE 6771
6769: GO 6786
6771: POP
// SetDir ( un , 4 ) ; south_arr :
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 4
6779: PPUSH
6780: CALL_OW 233
6784: GO 6810
6786: LD_INT 19
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6809
6794: POP
// SetDir ( un , 5 ) ; end ;
6795: LD_VAR 0 5
6799: PPUSH
6800: LD_INT 5
6802: PPUSH
6803: CALL_OW 233
6807: GO 6810
6809: POP
// PlaceUnitArea ( un , area , false ) ;
6810: LD_VAR 0 5
6814: PPUSH
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6827: CALL_OW 44
6831: PPUSH
6832: LD_VAR 0 5
6836: PPUSH
6837: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6841: LD_VAR 0 5
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 100
6851: PPUSH
6852: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 106
6863: PPUSH
6864: LD_INT 88
6866: PPUSH
6867: CALL_OW 111
// AddComUnload ( un ) ;
6871: LD_VAR 0 5
6875: PPUSH
6876: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 173
// Wait ( 0 0$02 ) ;
6894: LD_INT 70
6896: PPUSH
6897: CALL_OW 67
// end ;
6901: GO 6676
6903: POP
6904: POP
// Wait ( 0 0$05 ) ;
6905: LD_INT 175
6907: PPUSH
6908: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6912: LD_INT 6
6914: PPUSH
6915: LD_INT 34
6917: PUSH
6918: LD_INT 51
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL 11587 0 2
6929: IFFALSE 7117
// begin wait ( 0 0$01 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6938: LD_ADDR_VAR 0 4
6942: PUSH
6943: LD_INT 6
6945: PPUSH
6946: LD_INT 34
6948: PUSH
6949: LD_INT 51
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL 11587 0 2
6960: PUSH
6961: FOR_IN
6962: IFFALSE 7113
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6964: LD_VAR 0 4
6968: PPUSH
6969: LD_INT 9
6971: PPUSH
6972: CALL_OW 308
6976: PUSH
6977: LD_VAR 0 4
6981: PPUSH
6982: CALL 31695 0 1
6986: PPUSH
6987: CALL_OW 258
6991: PUSH
6992: LD_INT 1
6994: EQUAL
6995: AND
6996: PUSH
6997: LD_EXP 9
7001: AND
7002: IFFALSE 7029
// begin Say ( GetDriver ( i ) , Dtran ) ;
7004: LD_VAR 0 4
7008: PPUSH
7009: CALL 31695 0 1
7013: PPUSH
7014: LD_STRING Dtran
7016: PPUSH
7017: CALL_OW 88
// dialog_trans := false ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// end ; if IsIdle ( i ) then
7029: LD_VAR 0 4
7033: PPUSH
7034: CALL_OW 316
7038: IFFALSE 7054
// ComMoveToArea ( i , area ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: LD_VAR 0 1
7049: PPUSH
7050: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7054: LD_VAR 0 4
7058: PPUSH
7059: LD_VAR 0 1
7063: PPUSH
7064: CALL_OW 308
7068: PUSH
7069: LD_VAR 0 4
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL_OW 289
7081: PUSH
7082: LD_INT 0
7084: EQUAL
7085: AND
7086: IFFALSE 7111
// begin RemoveUnit ( GetDriver ( i ) ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL 31695 0 1
7097: PPUSH
7098: CALL_OW 64
// RemoveUnit ( i ) ;
7102: LD_VAR 0 4
7106: PPUSH
7107: CALL_OW 64
// end ; end ;
7111: GO 6961
7113: POP
7114: POP
// end ;
7115: GO 6912
// end ;
7117: LD_VAR 0 3
7121: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7122: LD_INT 0
7124: PPUSH
7125: PPUSH
7126: PPUSH
7127: PPUSH
// if isTest then
7128: LD_EXP 1
7132: IFFALSE 7136
// exit ;
7134: GO 7525
// for i = 1 to n do
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7384
// begin uc_side := 8 ;
7154: LD_ADDR_OWVAR 20
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// uc_nation := 1 ;
7162: LD_ADDR_OWVAR 21
7166: PUSH
7167: LD_INT 1
7169: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7170: LD_ADDR_VAR 0 6
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 1
7191: PPUSH
7192: LD_OWVAR 67
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// vc_chassis := ch ;
7203: LD_ADDR_OWVAR 37
7207: PUSH
7208: LD_VAR 0 6
7212: ST_TO_ADDR
// vc_control := control_computer ;
7213: LD_ADDR_OWVAR 38
7217: PUSH
7218: LD_INT 3
7220: ST_TO_ADDR
// vc_engine := engine_combustion ;
7221: LD_ADDR_OWVAR 39
7225: PUSH
7226: LD_INT 1
7228: ST_TO_ADDR
// if ch = us_medium_tracked then
7229: LD_VAR 0 6
7233: PUSH
7234: LD_INT 3
7236: EQUAL
7237: IFFALSE 7284
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7239: LD_ADDR_OWVAR 40
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 4
7249: PUSH
7250: LD_INT 5
7252: PUSH
7253: LD_INT 7
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: PPUSH
7267: LD_OWVAR 67
7271: PUSH
7272: LD_INT 1
7274: PLUS
7275: PPUSH
7276: CALL_OW 12
7280: ARRAY
7281: ST_TO_ADDR
7282: GO 7325
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7284: LD_ADDR_OWVAR 40
7288: PUSH
7289: LD_INT 5
7291: PUSH
7292: LD_INT 6
7294: PUSH
7295: LD_INT 7
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_OWVAR 67
7314: PUSH
7315: LD_INT 1
7317: PLUS
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7325: LD_ADDR_OWVAR 41
7329: PUSH
7330: LD_INT 70
7332: ST_TO_ADDR
// un := CreateVehicle ;
7333: LD_ADDR_VAR 0 5
7337: PUSH
7338: CALL_OW 45
7342: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7343: LD_VAR 0 5
7347: PPUSH
7348: LD_VAR 0 1
7352: PPUSH
7353: LD_INT 0
7355: PPUSH
7356: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7360: LD_VAR 0 5
7364: PPUSH
7365: LD_INT 65
7367: PPUSH
7368: LD_INT 9
7370: PPUSH
7371: CALL_OW 111
// Wait ( 0 0$02 ) ;
7375: LD_INT 70
7377: PPUSH
7378: CALL_OW 67
// end ;
7382: GO 7151
7384: POP
7385: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7386: LD_INT 90
7388: PUSH
7389: LD_INT 80
7391: PUSH
7392: LD_INT 70
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_OWVAR 67
7404: ARRAY
7405: PPUSH
7406: CALL_OW 13
7410: IFFALSE 7517
// begin uc_side := 8 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 8
7419: ST_TO_ADDR
// uc_nation := 1 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 1
7427: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7428: LD_ADDR_OWVAR 37
7432: PUSH
7433: LD_INT 4
7435: ST_TO_ADDR
// vc_control := control_computer ;
7436: LD_ADDR_OWVAR 38
7440: PUSH
7441: LD_INT 3
7443: ST_TO_ADDR
// vc_engine := engine_combustion ;
7444: LD_ADDR_OWVAR 39
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7452: LD_ADDR_OWVAR 40
7456: PUSH
7457: LD_INT 14
7459: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7460: LD_ADDR_OWVAR 41
7464: PUSH
7465: LD_INT 70
7467: ST_TO_ADDR
// un := CreateVehicle ;
7468: LD_ADDR_VAR 0 5
7472: PUSH
7473: CALL_OW 45
7477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7478: LD_VAR 0 5
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7495: LD_VAR 0 5
7499: PPUSH
7500: LD_INT 65
7502: PPUSH
7503: LD_INT 9
7505: PPUSH
7506: CALL_OW 111
// Wait ( 0 0$02 ) ;
7510: LD_INT 70
7512: PPUSH
7513: CALL_OW 67
// end ; alfa_support := true ;
7517: LD_ADDR_EXP 14
7521: PUSH
7522: LD_INT 1
7524: ST_TO_ADDR
// end ;
7525: LD_VAR 0 3
7529: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7530: LD_OWVAR 1
7534: PUSH
7535: LD_INT 21000
7537: PUSH
7538: LD_INT 18900
7540: PUSH
7541: LD_INT 16800
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: LD_OWVAR 67
7553: ARRAY
7554: GREATER
7555: IFFALSE 7639
7557: GO 7559
7559: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7560: LD_EXP 26
7564: PPUSH
7565: LD_STRING DR5
7567: PPUSH
7568: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7572: LD_INT 1050
7574: PPUSH
7575: LD_INT 4200
7577: PPUSH
7578: CALL_OW 12
7582: PPUSH
7583: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7587: LD_INT 20
7589: PPUSH
7590: LD_INT 5
7592: PUSH
7593: LD_INT 6
7595: PUSH
7596: LD_INT 8
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_OWVAR 67
7608: ARRAY
7609: PPUSH
7610: CALL 7122 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7614: LD_INT 8400
7616: PPUSH
7617: LD_INT 12600
7619: PPUSH
7620: CALL_OW 12
7624: PPUSH
7625: CALL_OW 67
// until tick >= 120 120$00 ;
7629: LD_OWVAR 1
7633: PUSH
7634: LD_INT 252000
7636: GREATEREQUAL
7637: IFFALSE 7560
// end ; end_of_file
7639: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7640: LD_INT 0
7642: PPUSH
// enable_addtolog := isTest ;
7643: LD_ADDR_OWVAR 81
7647: PUSH
7648: LD_EXP 1
7652: ST_TO_ADDR
// lines_break_limit := 5 ;
7653: LD_ADDR_EXP 28
7657: PUSH
7658: LD_INT 5
7660: ST_TO_ADDR
// lines_break_type := --- ;
7661: LD_ADDR_EXP 29
7665: PUSH
7666: LD_STRING ---
7668: ST_TO_ADDR
// lines_counter := 0 ;
7669: LD_ADDR_EXP 27
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// show_line_index := true ;
7677: LD_ADDR_EXP 30
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// tick_log := true ;
7685: LD_ADDR_EXP 31
7689: PUSH
7690: LD_INT 1
7692: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7693: LD_STRING ----------SAND OF SIBERIA LOG----------
7695: PPUSH
7696: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7700: LD_STRING Map Name: 
7702: PUSH
7703: LD_OWVAR 68
7707: STR
7708: PPUSH
7709: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7713: LD_STRING Map Number: 
7715: PUSH
7716: LD_OWVAR 70
7720: STR
7721: PPUSH
7722: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7726: LD_STRING Difficulty: 
7728: PUSH
7729: LD_OWVAR 67
7733: STR
7734: PPUSH
7735: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7739: LD_STRING ---------------------------------------
7741: PPUSH
7742: CALL_OW 561
// end ;
7746: LD_VAR 0 1
7750: RET
// function Log ( text ) ; begin
7751: LD_INT 0
7753: PPUSH
// if show_line_index then
7754: LD_EXP 30
7758: IFFALSE 7770
// result := lines_counter ;
7760: LD_ADDR_VAR 0 2
7764: PUSH
7765: LD_EXP 27
7769: ST_TO_ADDR
// if tick_log then
7770: LD_EXP 31
7774: IFFALSE 7800
// result := result &  T:  & tick &   ;
7776: LD_ADDR_VAR 0 2
7780: PUSH
7781: LD_VAR 0 2
7785: PUSH
7786: LD_STRING  T: 
7788: STR
7789: PUSH
7790: LD_OWVAR 1
7794: STR
7795: PUSH
7796: LD_STRING  
7798: STR
7799: ST_TO_ADDR
// AddToLog ( result & text ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_VAR 0 1
7809: STR
7810: PPUSH
7811: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7815: LD_ADDR_EXP 27
7819: PUSH
7820: LD_EXP 27
7824: PUSH
7825: LD_INT 1
7827: PLUS
7828: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7829: LD_EXP 27
7833: PUSH
7834: LD_EXP 28
7838: MOD
7839: PUSH
7840: LD_INT 0
7842: EQUAL
7843: IFFALSE 7854
// AddToLog ( lines_break_type ) ;
7845: LD_EXP 29
7849: PPUSH
7850: CALL_OW 561
// end ;
7854: LD_VAR 0 2
7858: RET
// export function LogHuman ( id ) ; begin
7859: LD_INT 0
7861: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7862: LD_STRING Human Created. id: 
7864: PUSH
7865: LD_VAR 0 1
7869: STR
7870: PUSH
7871: LD_STRING ; side: 
7873: STR
7874: PUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 255
7884: STR
7885: PUSH
7886: LD_STRING ; class: 
7888: STR
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 257
7899: STR
7900: PUSH
7901: LD_STRING ; 
7903: STR
7904: PPUSH
7905: CALL 7751 0 1
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogVeh ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7917: LD_STRING Vehicle Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; nation: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 248
7954: STR
7955: PUSH
7956: LD_STRING ; weapon: 
7958: STR
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 264
7969: STR
7970: PUSH
7971: LD_STRING ; 
7973: STR
7974: PPUSH
7975: CALL 7751 0 1
// end ;
7979: LD_VAR 0 2
7983: RET
// export function LogEvent ( event ) ; begin
7984: LD_INT 0
7986: PPUSH
// Log ( Event Executed. id:  & event ) ;
7987: LD_STRING Event Executed. id: 
7989: PUSH
7990: LD_VAR 0 1
7994: STR
7995: PPUSH
7996: CALL 7751 0 1
// end ; end_of_file
8000: LD_VAR 0 2
8004: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8005: LD_INT 0
8007: PPUSH
8008: PPUSH
8009: PPUSH
8010: PPUSH
8011: PPUSH
8012: PPUSH
8013: PPUSH
8014: PPUSH
// if unit then
8015: LD_VAR 0 1
8019: IFFALSE 8419
// begin if mode = 0 then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_INT 0
8028: EQUAL
8029: IFFALSE 8177
// begin if coords then
8031: LD_VAR 0 2
8035: IFFALSE 8175
// while ( coords > 1 ) do
8037: LD_VAR 0 2
8041: PUSH
8042: LD_INT 1
8044: GREATER
8045: IFFALSE 8175
// if not HasTask ( unit ) then
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 314
8056: NOT
8057: IFFALSE 8173
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8059: LD_VAR 0 1
8063: PPUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 1
8071: ARRAY
8072: PPUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: PPUSH
8082: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8086: LD_INT 35
8088: PPUSH
8089: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 250
8102: PUSH
8103: LD_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ARRAY
8111: EQUAL
8112: PUSH
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 251
8122: PUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 2
8130: ARRAY
8131: EQUAL
8132: AND
8133: IFFALSE 8086
// for i = 1 to 2 do
8135: LD_ADDR_VAR 0 5
8139: PUSH
8140: DOUBLE
8141: LD_INT 1
8143: DEC
8144: ST_TO_ADDR
8145: LD_INT 2
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8171
// coords := Delete ( coords , 1 ) ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: LD_INT 1
8163: PPUSH
8164: CALL_OW 3
8168: ST_TO_ADDR
8169: GO 8148
8171: POP
8172: POP
// end ;
8173: GO 8037
// end else
8175: GO 8419
// begin if coords then
8177: LD_VAR 0 2
8181: IFFALSE 8419
// begin x := GetX ( unit ) ;
8183: LD_ADDR_VAR 0 6
8187: PUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 250
8197: ST_TO_ADDR
// y := GetY ( unit ) ;
8198: LD_ADDR_VAR 0 7
8202: PUSH
8203: LD_VAR 0 1
8207: PPUSH
8208: CALL_OW 251
8212: ST_TO_ADDR
// while ( coords > 1 ) do
8213: LD_VAR 0 2
8217: PUSH
8218: LD_INT 1
8220: GREATER
8221: IFFALSE 8419
// begin Wait ( 0 0$0.3 ) ;
8223: LD_INT 10
8225: PPUSH
8226: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 255
8239: PPUSH
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 250
8249: PPUSH
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 251
8259: PPUSH
8260: LD_INT 14
8262: PPUSH
8263: CALL 22757 0 4
8267: IFFALSE 8298
// begin ComMoveXY ( unit , x , y ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 7
8283: PPUSH
8284: CALL_OW 111
// result := false ;
8288: LD_ADDR_VAR 0 4
8292: PUSH
8293: LD_INT 0
8295: ST_TO_ADDR
// end else
8296: GO 8337
// if not HasTask ( unit ) then
8298: LD_VAR 0 1
8302: PPUSH
8303: CALL_OW 314
8307: NOT
8308: IFFALSE 8337
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8310: LD_VAR 0 1
8314: PPUSH
8315: LD_VAR 0 2
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 2
8331: ARRAY
8332: PPUSH
8333: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8337: LD_VAR 0 1
8341: PPUSH
8342: CALL_OW 250
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: EQUAL
8356: PUSH
8357: LD_VAR 0 1
8361: PPUSH
8362: CALL_OW 251
8366: PUSH
8367: LD_VAR 0 2
8371: PUSH
8372: LD_INT 2
8374: ARRAY
8375: EQUAL
8376: AND
8377: IFFALSE 8417
// for i = 1 to 2 do
8379: LD_ADDR_VAR 0 5
8383: PUSH
8384: DOUBLE
8385: LD_INT 1
8387: DEC
8388: ST_TO_ADDR
8389: LD_INT 2
8391: PUSH
8392: FOR_TO
8393: IFFALSE 8415
// coords := Delete ( coords , 1 ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 2
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
8413: GO 8392
8415: POP
8416: POP
// end ;
8417: GO 8213
// end ; end ; end ; result := true ;
8419: LD_ADDR_VAR 0 4
8423: PUSH
8424: LD_INT 1
8426: ST_TO_ADDR
// end ;
8427: LD_VAR 0 4
8431: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8437: LD_ADDR_VAR 0 5
8441: PUSH
8442: LD_INT 81
8444: PUSH
8445: LD_VAR 0 1
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// for i in units do
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_VAR 0 2
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8498
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8472: LD_VAR 0 4
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL_OW 74
8491: PPUSH
8492: CALL_OW 115
// end ;
8496: GO 8469
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 3
8504: RET
// export function MC_Show ( string ) ; begin
8505: LD_INT 0
8507: PPUSH
// display_strings := string ;
8508: LD_ADDR_OWVAR 47
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// end ; end_of_file
8518: LD_VAR 0 2
8522: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
8527: PPUSH
8528: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8529: LD_ADDR_VAR 0 8
8533: PUSH
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 2
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL 11670 0 3
8548: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8549: LD_VAR 0 8
8553: PUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: LD_VAR 0 3
8563: PPUSH
8564: CALL_OW 428
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: AND
8573: IFFALSE 8647
// for i = 1 to plist do
8575: LD_ADDR_VAR 0 6
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 8
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8645
// if NotTask ( plist [ i ] ) then
8593: LD_VAR 0 8
8597: PUSH
8598: LD_VAR 0 6
8602: ARRAY
8603: PPUSH
8604: CALL 32158 0 1
8608: IFFALSE 8643
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8610: LD_VAR 0 8
8614: PUSH
8615: LD_VAR 0 6
8619: ARRAY
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: LD_VAR 0 2
8628: PPUSH
8629: LD_VAR 0 3
8633: PPUSH
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 145
// end ;
8643: GO 8590
8645: POP
8646: POP
// end ;
8647: LD_VAR 0 5
8651: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8652: LD_INT 0
8654: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 6
8662: PPUSH
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_VAR 0 4
8677: PPUSH
8678: CALL 10156 0 5
// end ;
8682: LD_VAR 0 5
8686: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8691: LD_ADDR_VAR 0 4
8695: PUSH
8696: LD_INT 22
8698: PUSH
8699: LD_VAR 0 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 30
8713: PUSH
8714: LD_INT 0
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 30
8723: PUSH
8724: LD_INT 1
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: EMPTY
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 250
8757: PPUSH
8758: LD_VAR 0 2
8762: PPUSH
8763: CALL_OW 251
8767: PPUSH
8768: CALL_OW 73
8772: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8773: LD_VAR 0 4
8777: PPUSH
8778: LD_VAR 0 2
8782: PPUSH
8783: CALL 10445 0 2
8787: IFFALSE 8846
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8789: LD_VAR 0 1
8793: PPUSH
8794: LD_INT 30
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PPUSH
8806: CALL 11587 0 2
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8819: LD_ADDR_EXP 50
8823: PUSH
8824: LD_EXP 50
8828: PPUSH
8829: LD_VAR 0 1
8833: PPUSH
8834: LD_VAR 0 2
8838: PPUSH
8839: EMPTY
8840: PPUSH
8841: CALL 41973 0 4
8845: ST_TO_ADDR
// end ; end ;
8846: LD_VAR 0 3
8850: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8851: LD_INT 0
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// result := false ;
8859: LD_ADDR_VAR 0 4
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8867: LD_VAR 0 1
8871: PPUSH
8872: LD_EXP 42
8876: PPUSH
8877: CALL 42921 0 2
8881: IFFALSE 9094
// for i = 1 to MREG_LabList do
8883: LD_ADDR_VAR 0 5
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_EXP 42
8897: PUSH
8898: FOR_TO
8899: IFFALSE 9092
// begin if MREG_LabList [ i ] [ 1 ] = side then
8901: LD_EXP 42
8905: PUSH
8906: LD_VAR 0 5
8910: ARRAY
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PUSH
8916: LD_VAR 0 1
8920: EQUAL
8921: IFFALSE 9090
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8923: LD_ADDR_VAR 0 7
8927: PUSH
8928: LD_EXP 42
8932: PUSH
8933: LD_VAR 0 5
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8943: LD_ADDR_VAR 0 9
8947: PUSH
8948: LD_INT 22
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 0
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 30
8975: PUSH
8976: LD_INT 1
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: EMPTY
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: CALL_OW 250
9009: PPUSH
9010: LD_VAR 0 7
9014: PPUSH
9015: CALL_OW 251
9019: PPUSH
9020: CALL_OW 73
9024: ST_TO_ADDR
// if dep then
9025: LD_VAR 0 9
9029: IFFALSE 9088
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9031: LD_VAR 0 9
9035: PPUSH
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 3
9045: PPUSH
9046: CALL 10561 0 3
9050: IFFALSE 9088
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9052: LD_VAR 0 7
9056: PPUSH
9057: LD_VAR 0 2
9061: PPUSH
9062: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9066: LD_VAR 0 7
9070: PPUSH
9071: LD_VAR 0 3
9075: PPUSH
9076: CALL_OW 207
// result := true ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 1
9087: ST_TO_ADDR
// end ; end ; break ;
9088: GO 9092
// end ; end ;
9090: GO 8898
9092: POP
9093: POP
// end ;
9094: LD_VAR 0 4
9098: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9104: LD_ADDR_VAR 0 7
9108: PUSH
9109: LD_VAR 0 2
9113: PPUSH
9114: LD_VAR 0 3
9118: PPUSH
9119: LD_VAR 0 4
9123: PPUSH
9124: CALL 9286 0 3
9128: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9129: LD_ADDR_EXP 48
9133: PUSH
9134: LD_EXP 48
9138: PPUSH
9139: LD_VAR 0 1
9143: PPUSH
9144: LD_INT 2
9146: PPUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_VAR 0 3
9156: PUSH
9157: LD_VAR 0 4
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL 41882 0 4
9171: ST_TO_ADDR
// if ext_list then
9172: LD_VAR 0 5
9176: IFFALSE 9281
// for i = 1 to ext_list do
9178: LD_ADDR_VAR 0 8
9182: PUSH
9183: DOUBLE
9184: LD_INT 1
9186: DEC
9187: ST_TO_ADDR
9188: LD_VAR 0 5
9192: PUSH
9193: FOR_TO
9194: IFFALSE 9279
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9196: LD_ADDR_EXP 48
9200: PUSH
9201: LD_EXP 48
9205: PPUSH
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 8
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PUSH
9237: LD_VAR 0 7
9241: PUSH
9242: LD_VAR 0 8
9246: ARRAY
9247: PUSH
9248: LD_INT 2
9250: ARRAY
9251: PUSH
9252: LD_VAR 0 7
9256: PUSH
9257: LD_VAR 0 8
9261: ARRAY
9262: PUSH
9263: LD_INT 3
9265: ARRAY
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: PPUSH
9272: CALL 41882 0 4
9276: ST_TO_ADDR
9277: GO 9193
9279: POP
9280: POP
// end ;
9281: LD_VAR 0 6
9285: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
// list := [ ] ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: EMPTY
9296: ST_TO_ADDR
// case d of 0 :
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 0
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9443
9310: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9311: LD_ADDR_VAR 0 5
9315: PUSH
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 4
9323: MINUS
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 4
9332: MINUS
9333: PUSH
9334: LD_INT 2
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: LD_VAR 0 1
9346: PUSH
9347: LD_INT 3
9349: MINUS
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: LD_INT 1
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 4
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_VAR 0 1
9390: PUSH
9391: LD_INT 3
9393: PLUS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 3
9402: PLUS
9403: PUSH
9404: LD_INT 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_VAR 0 2
9421: PUSH
9422: LD_INT 4
9424: PLUS
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: ST_TO_ADDR
// end ; 1 :
9441: GO 10141
9443: LD_INT 1
9445: DOUBLE
9446: EQUAL
9447: IFTRUE 9451
9449: GO 9584
9451: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9452: LD_ADDR_VAR 0 5
9456: PUSH
9457: LD_VAR 0 1
9461: PUSH
9462: LD_VAR 0 2
9466: PUSH
9467: LD_INT 4
9469: MINUS
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: PUSH
9479: LD_VAR 0 1
9483: PUSH
9484: LD_INT 3
9486: MINUS
9487: PUSH
9488: LD_VAR 0 2
9492: PUSH
9493: LD_INT 3
9495: MINUS
9496: PUSH
9497: LD_INT 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: PUSH
9505: LD_VAR 0 1
9509: PUSH
9510: LD_INT 4
9512: MINUS
9513: PUSH
9514: LD_VAR 0 2
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: LD_INT 3
9539: PLUS
9540: PUSH
9541: LD_INT 0
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: LD_VAR 0 1
9553: PUSH
9554: LD_INT 4
9556: PLUS
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 4
9565: PLUS
9566: PUSH
9567: LD_INT 5
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: ST_TO_ADDR
// end ; 2 :
9582: GO 10141
9584: LD_INT 2
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9721
9592: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9593: LD_ADDR_VAR 0 5
9597: PUSH
9598: LD_VAR 0 1
9602: PUSH
9603: LD_VAR 0 2
9607: PUSH
9608: LD_INT 3
9610: MINUS
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: PLUS
9628: PUSH
9629: LD_VAR 0 2
9633: PUSH
9634: LD_INT 4
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 2
9651: PUSH
9652: LD_INT 4
9654: PLUS
9655: PUSH
9656: LD_INT 0
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 3
9671: MINUS
9672: PUSH
9673: LD_VAR 0 2
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: LD_INT 4
9693: MINUS
9694: PUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 4
9702: MINUS
9703: PUSH
9704: LD_INT 2
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: ST_TO_ADDR
// end ; 3 :
9719: GO 10141
9721: LD_INT 3
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9862
9729: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_VAR 0 1
9739: PUSH
9740: LD_INT 3
9742: PLUS
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 4
9764: PLUS
9765: PUSH
9766: LD_VAR 0 2
9770: PUSH
9771: LD_INT 4
9773: PLUS
9774: PUSH
9775: LD_INT 5
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_VAR 0 1
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_VAR 0 2
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: LD_INT 4
9817: MINUS
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: LIST
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_INT 3
9834: MINUS
9835: PUSH
9836: LD_VAR 0 2
9840: PUSH
9841: LD_INT 3
9843: MINUS
9844: PUSH
9845: LD_INT 2
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: ST_TO_ADDR
// end ; 4 :
9860: GO 10141
9862: LD_INT 4
9864: DOUBLE
9865: EQUAL
9866: IFTRUE 9870
9868: GO 10003
9870: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9871: LD_ADDR_VAR 0 5
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 4
9888: PLUS
9889: PUSH
9890: LD_INT 0
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_VAR 0 1
9902: PUSH
9903: LD_INT 3
9905: PLUS
9906: PUSH
9907: LD_VAR 0 2
9911: PUSH
9912: LD_INT 3
9914: PLUS
9915: PUSH
9916: LD_INT 5
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: PUSH
9924: LD_VAR 0 1
9928: PUSH
9929: LD_INT 3
9931: PLUS
9932: PUSH
9933: LD_VAR 0 2
9937: PUSH
9938: LD_INT 4
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: PUSH
9946: LD_VAR 0 1
9950: PUSH
9951: LD_VAR 0 2
9955: PUSH
9956: LD_INT 3
9958: MINUS
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: PUSH
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 4
9975: MINUS
9976: PUSH
9977: LD_VAR 0 2
9981: PUSH
9982: LD_INT 4
9984: MINUS
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: ST_TO_ADDR
// end ; 5 :
10001: GO 10141
10003: LD_INT 5
10005: DOUBLE
10006: EQUAL
10007: IFTRUE 10011
10009: GO 10140
10011: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10012: LD_ADDR_VAR 0 5
10016: PUSH
10017: LD_VAR 0 1
10021: PUSH
10022: LD_INT 4
10024: MINUS
10025: PUSH
10026: LD_VAR 0 2
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: LD_INT 4
10051: MINUS
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: PUSH
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 4
10068: PLUS
10069: PUSH
10070: LD_VAR 0 2
10074: PUSH
10075: LD_INT 4
10077: PLUS
10078: PUSH
10079: LD_INT 5
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: LD_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PLUS
10095: PUSH
10096: LD_VAR 0 2
10100: PUSH
10101: LD_INT 4
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_VAR 0 2
10118: PUSH
10119: LD_INT 3
10121: PLUS
10122: PUSH
10123: LD_INT 0
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: ST_TO_ADDR
// end ; end ;
10138: GO 10141
10140: POP
// result := list ;
10141: LD_ADDR_VAR 0 4
10145: PUSH
10146: LD_VAR 0 5
10150: ST_TO_ADDR
// end ;
10151: LD_VAR 0 4
10155: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10156: LD_INT 0
10158: PPUSH
10159: PPUSH
10160: PPUSH
10161: PPUSH
10162: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10163: LD_ADDR_VAR 0 10
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: EMPTY
10177: PPUSH
10178: CALL 11670 0 3
10182: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_VAR 0 1
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 30
10205: PUSH
10206: LD_INT 0
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_VAR 0 3
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL_OW 73
10254: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10255: LD_ADDR_VAR 0 8
10259: PUSH
10260: LD_VAR 0 9
10264: PPUSH
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL 10445 0 2
10274: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10275: LD_VAR 0 10
10279: PUSH
10280: LD_VAR 0 8
10284: AND
10285: PUSH
10286: LD_VAR 0 9
10290: PPUSH
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_VAR 0 4
10300: PPUSH
10301: CALL_OW 297
10305: PUSH
10306: LD_INT 26
10308: LESSEQUAL
10309: AND
10310: PUSH
10311: LD_VAR 0 3
10315: PPUSH
10316: LD_VAR 0 4
10320: PPUSH
10321: CALL_OW 428
10325: PUSH
10326: LD_INT 0
10328: EQUAL
10329: AND
10330: IFFALSE 10440
// for i = 1 to plist do
10332: LD_ADDR_VAR 0 7
10336: PUSH
10337: DOUBLE
10338: LD_INT 1
10340: DEC
10341: ST_TO_ADDR
10342: LD_VAR 0 10
10346: PUSH
10347: FOR_TO
10348: IFFALSE 10438
// if IsInUnit ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL_OW 310
10365: IFFALSE 10384
// ComExitBuilding ( plist [ i ] ) else
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: CALL_OW 122
10382: GO 10436
// if NotTask ( plist [ i ] ) then
10384: LD_VAR 0 10
10388: PUSH
10389: LD_VAR 0 7
10393: ARRAY
10394: PPUSH
10395: CALL 32158 0 1
10399: IFFALSE 10436
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10401: LD_VAR 0 10
10405: PUSH
10406: LD_VAR 0 7
10410: ARRAY
10411: PPUSH
10412: LD_VAR 0 2
10416: PPUSH
10417: LD_VAR 0 3
10421: PPUSH
10422: LD_VAR 0 4
10426: PPUSH
10427: LD_VAR 0 5
10431: PPUSH
10432: CALL_OW 145
// end ;
10436: GO 10347
10438: POP
10439: POP
// end ;
10440: LD_VAR 0 6
10444: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10445: LD_INT 0
10447: PPUSH
10448: PPUSH
10449: PPUSH
// pom := GetBase ( bdepot ) ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 274
10464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10465: LD_ADDR_VAR 0 5
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 248
10484: PPUSH
10485: CALL_OW 450
10489: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10490: LD_VAR 0 4
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 275
10502: PUSH
10503: LD_VAR 0 5
10507: PUSH
10508: LD_INT 1
10510: ARRAY
10511: GREATEREQUAL
10512: PUSH
10513: LD_VAR 0 4
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: CALL_OW 275
10525: PUSH
10526: LD_VAR 0 5
10530: PUSH
10531: LD_INT 3
10533: ARRAY
10534: GREATEREQUAL
10535: AND
10536: IFFALSE 10548
// result := true else
10538: LD_ADDR_VAR 0 3
10542: PUSH
10543: LD_INT 1
10545: ST_TO_ADDR
10546: GO 10556
// result := false ;
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: LD_INT 0
10555: ST_TO_ADDR
// end ;
10556: LD_VAR 0 3
10560: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10561: LD_INT 0
10563: PPUSH
10564: PPUSH
10565: PPUSH
10566: PPUSH
10567: PPUSH
// pom := GetBase ( bdepot ) ;
10568: LD_ADDR_VAR 0 5
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 274
10582: ST_TO_ADDR
// cost := [ ] ;
10583: LD_ADDR_VAR 0 8
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_VAR 0 1
10604: PPUSH
10605: CALL_OW 248
10609: PPUSH
10610: CALL_OW 450
10614: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10615: LD_ADDR_VAR 0 7
10619: PUSH
10620: LD_VAR 0 3
10624: PPUSH
10625: LD_VAR 0 1
10629: PPUSH
10630: CALL_OW 248
10634: PPUSH
10635: CALL_OW 450
10639: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10640: LD_ADDR_VAR 0 8
10644: PUSH
10645: LD_VAR 0 8
10649: PPUSH
10650: LD_INT 1
10652: PPUSH
10653: LD_VAR 0 6
10657: PUSH
10658: LD_INT 1
10660: ARRAY
10661: PUSH
10662: LD_VAR 0 7
10666: PUSH
10667: LD_INT 1
10669: ARRAY
10670: PLUS
10671: PPUSH
10672: CALL_OW 1
10676: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10677: LD_ADDR_VAR 0 8
10681: PUSH
10682: LD_VAR 0 8
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_VAR 0 6
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: PUSH
10699: LD_VAR 0 7
10703: PUSH
10704: LD_INT 2
10706: ARRAY
10707: PLUS
10708: PPUSH
10709: CALL_OW 1
10713: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10714: LD_ADDR_VAR 0 8
10718: PUSH
10719: LD_VAR 0 8
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_VAR 0 6
10731: PUSH
10732: LD_INT 3
10734: ARRAY
10735: PUSH
10736: LD_VAR 0 7
10740: PUSH
10741: LD_INT 3
10743: ARRAY
10744: PLUS
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 275
10763: PUSH
10764: LD_VAR 0 8
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: GREATEREQUAL
10773: PUSH
10774: LD_VAR 0 5
10778: PPUSH
10779: LD_INT 3
10781: PPUSH
10782: CALL_OW 275
10786: PUSH
10787: LD_VAR 0 8
10791: PUSH
10792: LD_INT 3
10794: ARRAY
10795: GREATEREQUAL
10796: AND
10797: IFFALSE 10809
// result := true else
10799: LD_ADDR_VAR 0 4
10803: PUSH
10804: LD_INT 1
10806: ST_TO_ADDR
10807: GO 10817
// result := false ;
10809: LD_ADDR_VAR 0 4
10813: PUSH
10814: LD_INT 0
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 4
10821: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
10826: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10827: LD_ADDR_VAR 0 5
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_INT 2
10839: PPUSH
10840: EMPTY
10841: PPUSH
10842: CALL 11670 0 3
10846: ST_TO_ADDR
// if unit and plist then
10847: LD_VAR 0 2
10851: PUSH
10852: LD_VAR 0 5
10856: AND
10857: IFFALSE 10918
// for i = 1 to plist do
10859: LD_ADDR_VAR 0 4
10863: PUSH
10864: DOUBLE
10865: LD_INT 1
10867: DEC
10868: ST_TO_ADDR
10869: LD_VAR 0 5
10873: PUSH
10874: FOR_TO
10875: IFFALSE 10916
// if NotTask ( plist [ i ] ) then
10877: LD_VAR 0 5
10881: PUSH
10882: LD_VAR 0 4
10886: ARRAY
10887: PPUSH
10888: CALL 32158 0 1
10892: IFFALSE 10914
// ComDismantle ( plist [ i ] , unit ) ;
10894: LD_VAR 0 5
10898: PUSH
10899: LD_VAR 0 4
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 2
10909: PPUSH
10910: CALL_OW 167
10914: GO 10874
10916: POP
10917: POP
// result := true ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// end ;
10926: LD_VAR 0 3
10930: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10931: LD_INT 0
10933: PPUSH
10934: PPUSH
10935: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10936: LD_ADDR_VAR 0 5
10940: PUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL 11670 0 3
10955: ST_TO_ADDR
// if unit and plist then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_VAR 0 5
10965: AND
10966: IFFALSE 11027
// for i = 1 to plist do
10968: LD_ADDR_VAR 0 4
10972: PUSH
10973: DOUBLE
10974: LD_INT 1
10976: DEC
10977: ST_TO_ADDR
10978: LD_VAR 0 5
10982: PUSH
10983: FOR_TO
10984: IFFALSE 11025
// if NotTask ( plist [ i ] ) then
10986: LD_VAR 0 5
10990: PUSH
10991: LD_VAR 0 4
10995: ARRAY
10996: PPUSH
10997: CALL 32158 0 1
11001: IFFALSE 11023
// ComComplete ( plist [ i ] , unit ) ;
11003: LD_VAR 0 5
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: CALL 68315 0 2
11023: GO 10983
11025: POP
11026: POP
// result := true ;
11027: LD_ADDR_VAR 0 3
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// end ;
11035: LD_VAR 0 3
11039: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11040: LD_INT 0
11042: PPUSH
11043: PPUSH
11044: PPUSH
11045: PPUSH
11046: PPUSH
11047: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 21
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 3
11077: PUSH
11078: LD_INT 57
11080: PUSH
11081: EMPTY
11082: LIST
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: LD_INT 24
11093: PUSH
11094: LD_INT 1000
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: ST_TO_ADDR
// r := [ ] ;
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: EMPTY
11122: ST_TO_ADDR
// if not tmp then
11123: LD_VAR 0 5
11127: NOT
11128: IFFALSE 11134
// exit else
11130: GO 11322
11132: GO 11302
// begin r := [ tmp [ 1 ] ] ;
11134: LD_ADDR_VAR 0 6
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 1
11146: ARRAY
11147: PUSH
11148: EMPTY
11149: LIST
11150: ST_TO_ADDR
// for i = 2 to tmp do
11151: LD_ADDR_VAR 0 3
11155: PUSH
11156: DOUBLE
11157: LD_INT 2
11159: DEC
11160: ST_TO_ADDR
11161: LD_VAR 0 5
11165: PUSH
11166: FOR_TO
11167: IFFALSE 11300
// begin m := false ;
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// for j = 1 to r do
11177: LD_ADDR_VAR 0 4
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 6
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11267
// if GetLives ( tmp [ i ] ) < r [ j ] then
11195: LD_VAR 0 5
11199: PUSH
11200: LD_VAR 0 3
11204: ARRAY
11205: PPUSH
11206: CALL_OW 256
11210: PUSH
11211: LD_VAR 0 6
11215: PUSH
11216: LD_VAR 0 4
11220: ARRAY
11221: LESS
11222: IFFALSE 11265
// begin r := Insert ( r , j , tmp [ i ] ) ;
11224: LD_ADDR_VAR 0 6
11228: PUSH
11229: LD_VAR 0 6
11233: PPUSH
11234: LD_VAR 0 4
11238: PPUSH
11239: LD_VAR 0 5
11243: PUSH
11244: LD_VAR 0 3
11248: ARRAY
11249: PPUSH
11250: CALL_OW 2
11254: ST_TO_ADDR
// m := true ;
11255: LD_ADDR_VAR 0 7
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// break ;
11263: GO 11267
// end ;
11265: GO 11192
11267: POP
11268: POP
// if not m then
11269: LD_VAR 0 7
11273: NOT
11274: IFFALSE 11298
// r := r ^ tmp [ i ] ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_VAR 0 6
11285: PUSH
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: ADD
11297: ST_TO_ADDR
// end ;
11298: GO 11166
11300: POP
11301: POP
// end ; if r then
11302: LD_VAR 0 6
11306: IFFALSE 11320
// result := r else
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_VAR 0 6
11317: ST_TO_ADDR
11318: GO 11322
// exit ;
11320: GO 11322
// end ;
11322: LD_VAR 0 2
11326: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11327: LD_INT 0
11329: PPUSH
11330: PPUSH
11331: PPUSH
11332: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 16
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 13
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 34
11385: PUSH
11386: LD_INT 52
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 24
11402: PUSH
11403: LD_INT 650
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// p := 1 ;
11420: LD_ADDR_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: ST_TO_ADDR
// for i = 1 to repairs do
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: DOUBLE
11434: LD_INT 1
11436: DEC
11437: ST_TO_ADDR
11438: LD_VAR 0 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11580
// begin if IsInUnit ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 310
11461: IFFALSE 11480
// ComExitBuilding ( repairs [ i ] ) else
11463: LD_VAR 0 5
11467: PUSH
11468: LD_VAR 0 3
11472: ARRAY
11473: PPUSH
11474: CALL_OW 122
11478: GO 11578
// if not HasTask ( repairs [ i ] ) then
11480: LD_VAR 0 5
11484: PUSH
11485: LD_VAR 0 3
11489: ARRAY
11490: PPUSH
11491: CALL_OW 314
11495: NOT
11496: IFFALSE 11578
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11498: LD_VAR 0 5
11502: PUSH
11503: LD_VAR 0 3
11507: ARRAY
11508: PPUSH
11509: LD_EXP 49
11513: PUSH
11514: LD_VAR 0 1
11518: ARRAY
11519: PUSH
11520: LD_VAR 0 4
11524: ARRAY
11525: PPUSH
11526: CALL_OW 130
// if i mod 3 = 0 then
11530: LD_VAR 0 3
11534: PUSH
11535: LD_INT 3
11537: MOD
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11558
// p := p + 1 ;
11544: LD_ADDR_VAR 0 4
11548: PUSH
11549: LD_VAR 0 4
11553: PUSH
11554: LD_INT 1
11556: PLUS
11557: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11558: LD_EXP 49
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: PUSH
11569: LD_VAR 0 4
11573: LESS
11574: IFFALSE 11578
// break ;
11576: GO 11580
// end ; end ;
11578: GO 11443
11580: POP
11581: POP
// end ; end_of_file
11582: LD_VAR 0 2
11586: RET
// export function MCF_Get ( side , filter ) ; begin
11587: LD_INT 0
11589: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// end ;
11621: LD_VAR 0 3
11625: RET
// export function MCF_Lab ( side ) ; begin
11626: LD_INT 0
11628: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11629: LD_ADDR_VAR 0 2
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_VAR 0 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 30
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: ST_TO_ADDR
// end ;
11665: LD_VAR 0 2
11669: RET
// export function MCF_Class ( side , class , filter ) ; begin
11670: LD_INT 0
11672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11673: LD_ADDR_VAR 0 4
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_VAR 0 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_All ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 25
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 25
11767: PUSH
11768: LD_INT 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// end ;
11807: LD_VAR 0 3
11811: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11812: LD_INT 0
11814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11815: LD_ADDR_VAR 0 4
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 92
11834: PUSH
11835: LD_VAR 0 2
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PUSH
11844: LD_VAR 0 2
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PUSH
11853: LD_VAR 0 2
11857: PUSH
11858: LD_INT 3
11860: ARRAY
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// end ;
11883: LD_VAR 0 4
11887: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11888: LD_INT 0
11890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_VAR 0 1
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 21
11910: PUSH
11911: LD_INT 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_VAR 0 2
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PPUSH
11928: CALL_OW 69
11932: ST_TO_ADDR
// end ;
11933: LD_VAR 0 3
11937: RET
// export function MCF_Cargo ( side ) ; begin
11938: LD_INT 0
11940: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11941: LD_ADDR_VAR 0 2
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 12
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 51
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL 11888 0 2
11994: ST_TO_ADDR
// end ;
11995: LD_VAR 0 2
11999: RET
// export function MCF_Ape ( side ) ; begin
12000: LD_INT 0
12002: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12003: LD_ADDR_VAR 0 2
12007: PUSH
12008: LD_INT 22
12010: PUSH
12011: LD_VAR 0 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 2
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 12
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 15
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 16
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 25
12055: PUSH
12056: LD_INT 17
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: ST_TO_ADDR
// end ;
12079: LD_VAR 0 2
12083: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12084: LD_INT 0
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 3
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12097: LD_ADDR_VAR 0 4
12101: PUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL 12000 0 1
12111: ST_TO_ADDR
// case type of 0 , normal :
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12131
12123: LD_STRING normal
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12142
12131: POP
// cl := class_apeman ; 1 , soldier :
12132: LD_ADDR_VAR 0 5
12136: PUSH
12137: LD_INT 12
12139: ST_TO_ADDR
12140: GO 12218
12142: LD_INT 1
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12156
12148: LD_STRING soldier
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12156
12154: GO 12167
12156: POP
// cl := class_apeman_soldier ; 2 , engineer :
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 15
12164: ST_TO_ADDR
12165: GO 12218
12167: LD_INT 2
12169: DOUBLE
12170: EQUAL
12171: IFTRUE 12181
12173: LD_STRING engineer
12175: DOUBLE
12176: EQUAL
12177: IFTRUE 12181
12179: GO 12192
12181: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12182: LD_ADDR_VAR 0 5
12186: PUSH
12187: LD_INT 16
12189: ST_TO_ADDR
12190: GO 12218
12192: LD_INT 3
12194: DOUBLE
12195: EQUAL
12196: IFTRUE 12206
12198: LD_STRING kamikaze
12200: DOUBLE
12201: EQUAL
12202: IFTRUE 12206
12204: GO 12217
12206: POP
// cl := class_apeman_kamikaze ; end ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_INT 17
12214: ST_TO_ADDR
12215: GO 12218
12217: POP
// for i = 1 to tmp do
12218: LD_ADDR_VAR 0 6
12222: PUSH
12223: DOUBLE
12224: LD_INT 1
12226: DEC
12227: ST_TO_ADDR
12228: LD_VAR 0 4
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12283
// if GetClass ( tmp [ i ] ) = cl then
12236: LD_VAR 0 4
12240: PUSH
12241: LD_VAR 0 6
12245: ARRAY
12246: PPUSH
12247: CALL_OW 257
12251: PUSH
12252: LD_VAR 0 5
12256: EQUAL
12257: IFFALSE 12281
// result := result ^ tmp [ i ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_VAR 0 4
12273: PUSH
12274: LD_VAR 0 6
12278: ARRAY
12279: ADD
12280: ST_TO_ADDR
12281: GO 12233
12283: POP
12284: POP
// end ;
12285: LD_VAR 0 3
12289: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_VAR 0 3
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 69
12326: ST_TO_ADDR
// r := [ ] ;
12327: LD_ADDR_VAR 0 6
12331: PUSH
12332: EMPTY
12333: ST_TO_ADDR
// if tmp then
12334: LD_VAR 0 5
12338: IFFALSE 12407
// for i = 1 to tmp do
12340: LD_ADDR_VAR 0 7
12344: PUSH
12345: DOUBLE
12346: LD_INT 1
12348: DEC
12349: ST_TO_ADDR
12350: LD_VAR 0 5
12354: PUSH
12355: FOR_TO
12356: IFFALSE 12405
// if GetTag ( tmp [ i ] ) = tag then
12358: LD_VAR 0 5
12362: PUSH
12363: LD_VAR 0 7
12367: ARRAY
12368: PPUSH
12369: CALL_OW 110
12373: PUSH
12374: LD_VAR 0 2
12378: EQUAL
12379: IFFALSE 12403
// r := r ^ tmp [ i ] ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_VAR 0 6
12390: PUSH
12391: LD_VAR 0 5
12395: PUSH
12396: LD_VAR 0 7
12400: ARRAY
12401: ADD
12402: ST_TO_ADDR
12403: GO 12355
12405: POP
12406: POP
// result := r ;
12407: LD_ADDR_VAR 0 4
12411: PUSH
12412: LD_VAR 0 6
12416: ST_TO_ADDR
// end ;
12417: LD_VAR 0 4
12421: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12422: LD_INT 0
12424: PPUSH
12425: PPUSH
12426: PPUSH
// tmp := plist ;
12427: LD_ADDR_VAR 0 5
12431: PUSH
12432: LD_VAR 0 2
12436: ST_TO_ADDR
// if tmp then
12437: LD_VAR 0 5
12441: IFFALSE 12518
// begin for i = 1 to tmp do
12443: LD_ADDR_VAR 0 6
12447: PUSH
12448: DOUBLE
12449: LD_INT 1
12451: DEC
12452: ST_TO_ADDR
12453: LD_VAR 0 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12506
// if GetTag ( tmp [ i ] ) <> tag then
12461: LD_VAR 0 5
12465: PUSH
12466: LD_VAR 0 6
12470: ARRAY
12471: PPUSH
12472: CALL_OW 110
12476: PUSH
12477: LD_VAR 0 3
12481: NONEQUAL
12482: IFFALSE 12504
// SetTag ( tmp [ i ] , tag ) ;
12484: LD_VAR 0 5
12488: PUSH
12489: LD_VAR 0 6
12493: ARRAY
12494: PPUSH
12495: LD_VAR 0 3
12499: PPUSH
12500: CALL_OW 109
12504: GO 12458
12506: POP
12507: POP
// result := true ;
12508: LD_ADDR_VAR 0 4
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// end else
12516: GO 12526
// result := false ;
12518: LD_ADDR_VAR 0 4
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// end ;
12526: LD_VAR 0 4
12530: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: EMPTY
12552: PPUSH
12553: CALL 12290 0 3
12557: ST_TO_ADDR
// if tmp then
12558: LD_VAR 0 4
12562: IFFALSE 12614
// begin for i = 1 to tmp do
12564: LD_ADDR_VAR 0 5
12568: PUSH
12569: DOUBLE
12570: LD_INT 1
12572: DEC
12573: ST_TO_ADDR
12574: LD_VAR 0 4
12578: PUSH
12579: FOR_TO
12580: IFFALSE 12602
// SetTag ( tmp [ i ] , 0 ) ;
12582: LD_VAR 0 4
12586: PUSH
12587: LD_VAR 0 5
12591: ARRAY
12592: PPUSH
12593: LD_INT 0
12595: PPUSH
12596: CALL_OW 109
12600: GO 12579
12602: POP
12603: POP
// result := true ;
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// end else
12612: GO 12622
// result := false ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 3
12626: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
12631: PPUSH
12632: PPUSH
12633: PPUSH
// sort_list := [ ] ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: EMPTY
12640: ST_TO_ADDR
// for i = 1 to list do
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: DOUBLE
12647: LD_INT 1
12649: DEC
12650: ST_TO_ADDR
12651: LD_VAR 0 1
12655: PUSH
12656: FOR_TO
12657: IFFALSE 12819
// begin if i = 1 then
12659: LD_VAR 0 3
12663: PUSH
12664: LD_INT 1
12666: EQUAL
12667: IFFALSE 12693
// sort_list := sort_list ^ list [ i ] else
12669: LD_ADDR_VAR 0 5
12673: PUSH
12674: LD_VAR 0 5
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: LD_VAR 0 3
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
12691: GO 12817
// begin for j = 1 to sort_list do
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: DOUBLE
12699: LD_INT 1
12701: DEC
12702: ST_TO_ADDR
12703: LD_VAR 0 5
12707: PUSH
12708: FOR_TO
12709: IFFALSE 12786
// begin add := false ;
12711: LD_ADDR_VAR 0 6
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12719: LD_VAR 0 1
12723: PUSH
12724: LD_VAR 0 3
12728: ARRAY
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: LD_VAR 0 4
12739: ARRAY
12740: LESS
12741: IFFALSE 12784
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12743: LD_ADDR_VAR 0 5
12747: PUSH
12748: LD_VAR 0 5
12752: PPUSH
12753: LD_VAR 0 4
12757: PPUSH
12758: LD_VAR 0 1
12762: PUSH
12763: LD_VAR 0 3
12767: ARRAY
12768: PPUSH
12769: CALL_OW 2
12773: ST_TO_ADDR
// add := true ;
12774: LD_ADDR_VAR 0 6
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// break ;
12782: GO 12786
// end ; end ;
12784: GO 12708
12786: POP
12787: POP
// if not add then
12788: LD_VAR 0 6
12792: NOT
12793: IFFALSE 12817
// sort_list := sort_list ^ list [ i ] ;
12795: LD_ADDR_VAR 0 5
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 1
12809: PUSH
12810: LD_VAR 0 3
12814: ARRAY
12815: ADD
12816: ST_TO_ADDR
// end ; end ;
12817: GO 12656
12819: POP
12820: POP
// result := sort_list ;
12821: LD_ADDR_VAR 0 2
12825: PUSH
12826: LD_VAR 0 5
12830: ST_TO_ADDR
// end ;
12831: LD_VAR 0 2
12835: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
// sort_list := [ ] ;
12843: LD_ADDR_VAR 0 5
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i = 1 to list do
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_VAR 0 1
12864: PUSH
12865: FOR_TO
12866: IFFALSE 13028
// begin if i = 1 then
12868: LD_VAR 0 3
12872: PUSH
12873: LD_INT 1
12875: EQUAL
12876: IFFALSE 12902
// sort_list := sort_list ^ list [ i ] else
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_VAR 0 5
12887: PUSH
12888: LD_VAR 0 1
12892: PUSH
12893: LD_VAR 0 3
12897: ARRAY
12898: ADD
12899: ST_TO_ADDR
12900: GO 13026
// begin for j = 1 to sort_list do
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: DOUBLE
12908: LD_INT 1
12910: DEC
12911: ST_TO_ADDR
12912: LD_VAR 0 5
12916: PUSH
12917: FOR_TO
12918: IFFALSE 12995
// begin add := false ;
12920: LD_ADDR_VAR 0 6
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 5
12943: PUSH
12944: LD_VAR 0 4
12948: ARRAY
12949: GREATER
12950: IFFALSE 12993
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12952: LD_ADDR_VAR 0 5
12956: PUSH
12957: LD_VAR 0 5
12961: PPUSH
12962: LD_VAR 0 4
12966: PPUSH
12967: LD_VAR 0 1
12971: PUSH
12972: LD_VAR 0 3
12976: ARRAY
12977: PPUSH
12978: CALL_OW 2
12982: ST_TO_ADDR
// add := true ;
12983: LD_ADDR_VAR 0 6
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// break ;
12991: GO 12995
// end ; end ;
12993: GO 12917
12995: POP
12996: POP
// if not add then
12997: LD_VAR 0 6
13001: NOT
13002: IFFALSE 13026
// sort_list := sort_list ^ list [ i ] ;
13004: LD_ADDR_VAR 0 5
13008: PUSH
13009: LD_VAR 0 5
13013: PUSH
13014: LD_VAR 0 1
13018: PUSH
13019: LD_VAR 0 3
13023: ARRAY
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12865
13028: POP
13029: POP
// result := sort_list ;
13030: LD_ADDR_VAR 0 2
13034: PUSH
13035: LD_VAR 0 5
13039: ST_TO_ADDR
// end ;
13040: LD_VAR 0 2
13044: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13045: LD_INT 0
13047: PPUSH
13048: PPUSH
13049: PPUSH
13050: PPUSH
13051: PPUSH
13052: PPUSH
// tmp := [ ] ;
13053: LD_ADDR_VAR 0 8
13057: PUSH
13058: EMPTY
13059: ST_TO_ADDR
// r := [ ] ;
13060: LD_ADDR_VAR 0 7
13064: PUSH
13065: EMPTY
13066: ST_TO_ADDR
// add := false ;
13067: LD_ADDR_VAR 0 9
13071: PUSH
13072: LD_INT 0
13074: ST_TO_ADDR
// if plist then
13075: LD_VAR 0 2
13079: IFFALSE 13155
// begin for i = 1 to plist do
13081: LD_ADDR_VAR 0 5
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13151
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13099: LD_ADDR_VAR 0 8
13103: PUSH
13104: LD_VAR 0 8
13108: PUSH
13109: LD_VAR 0 2
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PUSH
13120: LD_VAR 0 2
13124: PUSH
13125: LD_VAR 0 5
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 3
13135: PPUSH
13136: CALL_OW 259
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: ADD
13148: ST_TO_ADDR
// end ;
13149: GO 13096
13151: POP
13152: POP
// end else
13153: GO 13163
// result := false ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 0
13162: ST_TO_ADDR
// if tmp then
13163: LD_VAR 0 8
13167: IFFALSE 13341
// begin r := r ^ [ tmp [ 1 ] ] ;
13169: LD_ADDR_VAR 0 7
13173: PUSH
13174: LD_VAR 0 7
13178: PUSH
13179: LD_VAR 0 8
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: EMPTY
13189: LIST
13190: ADD
13191: ST_TO_ADDR
// for i = 2 to tmp do
13192: LD_ADDR_VAR 0 5
13196: PUSH
13197: DOUBLE
13198: LD_INT 2
13200: DEC
13201: ST_TO_ADDR
13202: LD_VAR 0 8
13206: PUSH
13207: FOR_TO
13208: IFFALSE 13339
// begin for j = 1 to r do
13210: LD_ADDR_VAR 0 6
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_VAR 0 7
13224: PUSH
13225: FOR_TO
13226: IFFALSE 13303
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13228: LD_VAR 0 8
13232: PUSH
13233: LD_VAR 0 5
13237: ARRAY
13238: PUSH
13239: LD_INT 2
13241: ARRAY
13242: PUSH
13243: LD_VAR 0 7
13247: PUSH
13248: LD_VAR 0 6
13252: ARRAY
13253: PUSH
13254: LD_INT 2
13256: ARRAY
13257: LESS
13258: IFFALSE 13301
// begin r := Insert ( r , j , tmp [ i ] ) ;
13260: LD_ADDR_VAR 0 7
13264: PUSH
13265: LD_VAR 0 7
13269: PPUSH
13270: LD_VAR 0 6
13274: PPUSH
13275: LD_VAR 0 8
13279: PUSH
13280: LD_VAR 0 5
13284: ARRAY
13285: PPUSH
13286: CALL_OW 2
13290: ST_TO_ADDR
// add := true ;
13291: LD_ADDR_VAR 0 9
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// break ;
13299: GO 13303
// end ; end ;
13301: GO 13225
13303: POP
13304: POP
// if not add then
13305: LD_VAR 0 9
13309: NOT
13310: IFFALSE 13337
// r := r ^ [ tmp [ i ] ] ;
13312: LD_ADDR_VAR 0 7
13316: PUSH
13317: LD_VAR 0 7
13321: PUSH
13322: LD_VAR 0 8
13326: PUSH
13327: LD_VAR 0 5
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// end ;
13337: GO 13207
13339: POP
13340: POP
// end ; result := r ;
13341: LD_ADDR_VAR 0 4
13345: PUSH
13346: LD_VAR 0 7
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 4
13355: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
// tmp := [ ] ;
13364: LD_ADDR_VAR 0 8
13368: PUSH
13369: EMPTY
13370: ST_TO_ADDR
// r := [ ] ;
13371: LD_ADDR_VAR 0 7
13375: PUSH
13376: EMPTY
13377: ST_TO_ADDR
// add := false ;
13378: LD_ADDR_VAR 0 9
13382: PUSH
13383: LD_INT 0
13385: ST_TO_ADDR
// if plist then
13386: LD_VAR 0 2
13390: IFFALSE 13466
// begin for i = 1 to plist do
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: DOUBLE
13398: LD_INT 1
13400: DEC
13401: ST_TO_ADDR
13402: LD_VAR 0 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13462
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13410: LD_ADDR_VAR 0 8
13414: PUSH
13415: LD_VAR 0 8
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: LD_VAR 0 5
13440: ARRAY
13441: PPUSH
13442: LD_VAR 0 3
13446: PPUSH
13447: CALL_OW 259
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: ADD
13459: ST_TO_ADDR
// end ;
13460: GO 13407
13462: POP
13463: POP
// end else
13464: GO 13474
// result := false ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// if tmp then
13474: LD_VAR 0 8
13478: IFFALSE 13652
// begin r := r ^ [ tmp [ 1 ] ] ;
13480: LD_ADDR_VAR 0 7
13484: PUSH
13485: LD_VAR 0 7
13489: PUSH
13490: LD_VAR 0 8
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: PUSH
13499: EMPTY
13500: LIST
13501: ADD
13502: ST_TO_ADDR
// for i = 2 to tmp do
13503: LD_ADDR_VAR 0 5
13507: PUSH
13508: DOUBLE
13509: LD_INT 2
13511: DEC
13512: ST_TO_ADDR
13513: LD_VAR 0 8
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13650
// begin for j = 1 to r do
13521: LD_ADDR_VAR 0 6
13525: PUSH
13526: DOUBLE
13527: LD_INT 1
13529: DEC
13530: ST_TO_ADDR
13531: LD_VAR 0 7
13535: PUSH
13536: FOR_TO
13537: IFFALSE 13614
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13539: LD_VAR 0 8
13543: PUSH
13544: LD_VAR 0 5
13548: ARRAY
13549: PUSH
13550: LD_INT 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 7
13558: PUSH
13559: LD_VAR 0 6
13563: ARRAY
13564: PUSH
13565: LD_INT 2
13567: ARRAY
13568: GREATER
13569: IFFALSE 13612
// begin r := Insert ( r , j , tmp [ i ] ) ;
13571: LD_ADDR_VAR 0 7
13575: PUSH
13576: LD_VAR 0 7
13580: PPUSH
13581: LD_VAR 0 6
13585: PPUSH
13586: LD_VAR 0 8
13590: PUSH
13591: LD_VAR 0 5
13595: ARRAY
13596: PPUSH
13597: CALL_OW 2
13601: ST_TO_ADDR
// add := true ;
13602: LD_ADDR_VAR 0 9
13606: PUSH
13607: LD_INT 1
13609: ST_TO_ADDR
// break ;
13610: GO 13614
// end ; end ;
13612: GO 13536
13614: POP
13615: POP
// if not add then
13616: LD_VAR 0 9
13620: NOT
13621: IFFALSE 13648
// r := r ^ [ tmp [ i ] ] ;
13623: LD_ADDR_VAR 0 7
13627: PUSH
13628: LD_VAR 0 7
13632: PUSH
13633: LD_VAR 0 8
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: EMPTY
13645: LIST
13646: ADD
13647: ST_TO_ADDR
// end ;
13648: GO 13518
13650: POP
13651: POP
// end ; result := r ;
13652: LD_ADDR_VAR 0 4
13656: PUSH
13657: LD_VAR 0 7
13661: ST_TO_ADDR
// end ;
13662: LD_VAR 0 4
13666: RET
// export function MCF_Clear ( side ) ; var i ; begin
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
// for i = 1 to 100 do
13671: LD_ADDR_VAR 0 3
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 100
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13721
// if MCF_Tag ( side , i , [ ] ) then
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 3
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL 12290 0 3
13703: IFFALSE 13719
// MCF_ClearTag ( side , i ) ;
13705: LD_VAR 0 1
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: CALL 12531 0 2
13719: GO 13684
13721: POP
13722: POP
// result := true ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_INT 1
13730: ST_TO_ADDR
// end ;
13731: LD_VAR 0 2
13735: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// for i = 1 to plist do
13741: LD_ADDR_VAR 0 4
13745: PUSH
13746: DOUBLE
13747: LD_INT 1
13749: DEC
13750: ST_TO_ADDR
13751: LD_VAR 0 1
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13806
// if MCF_HasClass ( plist [ i ] ) = n then
13759: LD_VAR 0 1
13763: PUSH
13764: LD_VAR 0 4
13768: ARRAY
13769: PPUSH
13770: CALL 14293 0 1
13774: PUSH
13775: LD_VAR 0 2
13779: EQUAL
13780: IFFALSE 13804
// tmp := tmp ^ plist [ i ] ;
13782: LD_ADDR_VAR 0 5
13786: PUSH
13787: LD_VAR 0 5
13791: PUSH
13792: LD_VAR 0 1
13796: PUSH
13797: LD_VAR 0 4
13801: ARRAY
13802: ADD
13803: ST_TO_ADDR
13804: GO 13756
13806: POP
13807: POP
// result := tmp ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_VAR 0 5
13817: ST_TO_ADDR
// end ;
13818: LD_VAR 0 3
13822: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13823: LD_INT 0
13825: PPUSH
13826: PPUSH
13827: PPUSH
// if mreg = ToArm then
13828: LD_VAR 0 2
13832: PUSH
13833: LD_STRING ToArm
13835: EQUAL
13836: IFFALSE 13941
// begin tmp := MREG_ToArm [ side ] ;
13838: LD_ADDR_VAR 0 6
13842: PUSH
13843: LD_EXP 58
13847: PUSH
13848: LD_VAR 0 1
13852: ARRAY
13853: ST_TO_ADDR
// if tmp = 0 then
13854: LD_VAR 0 6
13858: PUSH
13859: LD_INT 0
13861: EQUAL
13862: IFFALSE 13868
// exit else
13864: GO 14288
13866: GO 13941
// begin for i = MREG_ToArm [ side ] downto n do
13868: LD_ADDR_VAR 0 5
13872: PUSH
13873: DOUBLE
13874: LD_EXP 58
13878: PUSH
13879: LD_VAR 0 1
13883: ARRAY
13884: INC
13885: ST_TO_ADDR
13886: LD_VAR 0 3
13890: PUSH
13891: FOR_DOWNTO
13892: IFFALSE 13914
// tmp := Delete ( tmp , 1 ) ;
13894: LD_ADDR_VAR 0 6
13898: PUSH
13899: LD_VAR 0 6
13903: PPUSH
13904: LD_INT 1
13906: PPUSH
13907: CALL_OW 3
13911: ST_TO_ADDR
13912: GO 13891
13914: POP
13915: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13916: LD_ADDR_EXP 58
13920: PUSH
13921: LD_EXP 58
13925: PPUSH
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: CALL_OW 1
13940: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13941: LD_VAR 0 2
13945: PUSH
13946: LD_STRING ToDep
13948: EQUAL
13949: IFFALSE 14054
// begin tmp := MREG_ToDep [ side ] ;
13951: LD_ADDR_VAR 0 6
13955: PUSH
13956: LD_EXP 59
13960: PUSH
13961: LD_VAR 0 1
13965: ARRAY
13966: ST_TO_ADDR
// if tmp = 0 then
13967: LD_VAR 0 6
13971: PUSH
13972: LD_INT 0
13974: EQUAL
13975: IFFALSE 13981
// exit else
13977: GO 14288
13979: GO 14054
// begin for i = MREG_ToDep [ side ] downto n do
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: DOUBLE
13987: LD_EXP 59
13991: PUSH
13992: LD_VAR 0 1
13996: ARRAY
13997: INC
13998: ST_TO_ADDR
13999: LD_VAR 0 3
14003: PUSH
14004: FOR_DOWNTO
14005: IFFALSE 14027
// tmp := Delete ( tmp , 1 ) ;
14007: LD_ADDR_VAR 0 6
14011: PUSH
14012: LD_VAR 0 6
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL_OW 3
14024: ST_TO_ADDR
14025: GO 14004
14027: POP
14028: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14029: LD_ADDR_EXP 59
14033: PUSH
14034: LD_EXP 59
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: CALL_OW 1
14053: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14054: LD_VAR 0 2
14058: PUSH
14059: LD_STRING ToFac
14061: EQUAL
14062: IFFALSE 14167
// begin tmp := MREG_ToFac [ side ] ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_EXP 57
14073: PUSH
14074: LD_VAR 0 1
14078: ARRAY
14079: ST_TO_ADDR
// if tmp = 0 then
14080: LD_VAR 0 6
14084: PUSH
14085: LD_INT 0
14087: EQUAL
14088: IFFALSE 14094
// exit else
14090: GO 14288
14092: GO 14167
// begin for i = MREG_ToFac [ side ] downto n do
14094: LD_ADDR_VAR 0 5
14098: PUSH
14099: DOUBLE
14100: LD_EXP 57
14104: PUSH
14105: LD_VAR 0 1
14109: ARRAY
14110: INC
14111: ST_TO_ADDR
14112: LD_VAR 0 3
14116: PUSH
14117: FOR_DOWNTO
14118: IFFALSE 14140
// tmp := Delete ( tmp , 1 ) ;
14120: LD_ADDR_VAR 0 6
14124: PUSH
14125: LD_VAR 0 6
14129: PPUSH
14130: LD_INT 1
14132: PPUSH
14133: CALL_OW 3
14137: ST_TO_ADDR
14138: GO 14117
14140: POP
14141: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14142: LD_ADDR_EXP 57
14146: PUSH
14147: LD_EXP 57
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 6
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14167: LD_VAR 0 2
14171: PUSH
14172: LD_STRING ToLab
14174: EQUAL
14175: IFFALSE 14280
// begin tmp := MREG_ToLab [ side ] ;
14177: LD_ADDR_VAR 0 6
14181: PUSH
14182: LD_EXP 56
14186: PUSH
14187: LD_VAR 0 1
14191: ARRAY
14192: ST_TO_ADDR
// if tmp = 0 then
14193: LD_VAR 0 6
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: IFFALSE 14207
// exit else
14203: GO 14288
14205: GO 14280
// begin for i = MREG_ToLab [ side ] downto n do
14207: LD_ADDR_VAR 0 5
14211: PUSH
14212: DOUBLE
14213: LD_EXP 56
14217: PUSH
14218: LD_VAR 0 1
14222: ARRAY
14223: INC
14224: ST_TO_ADDR
14225: LD_VAR 0 3
14229: PUSH
14230: FOR_DOWNTO
14231: IFFALSE 14253
// tmp := Delete ( tmp , 1 ) ;
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 6
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: CALL_OW 3
14250: ST_TO_ADDR
14251: GO 14230
14253: POP
14254: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_EXP 56
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_VAR 0 6
14274: PPUSH
14275: CALL_OW 1
14279: ST_TO_ADDR
// end ; end ; result := true ;
14280: LD_ADDR_VAR 0 4
14284: PUSH
14285: LD_INT 1
14287: ST_TO_ADDR
// end ;
14288: LD_VAR 0 4
14292: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14293: LD_INT 0
14295: PPUSH
14296: PPUSH
14297: PPUSH
// side := GetSide ( unit ) ;
14298: LD_ADDR_VAR 0 4
14302: PUSH
14303: LD_VAR 0 1
14307: PPUSH
14308: CALL_OW 255
14312: ST_TO_ADDR
// tmp := 0 ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 4
14335: ARRAY
14336: IN
14337: IFFALSE 14347
// tmp := 1 ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 1
14346: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14347: LD_VAR 0 1
14351: PUSH
14352: LD_EXP 59
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: IN
14363: IFFALSE 14373
// tmp := 2 ;
14365: LD_ADDR_VAR 0 3
14369: PUSH
14370: LD_INT 2
14372: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14373: LD_VAR 0 1
14377: PUSH
14378: LD_EXP 57
14382: PUSH
14383: LD_VAR 0 4
14387: ARRAY
14388: IN
14389: IFFALSE 14399
// tmp := 3 ;
14391: LD_ADDR_VAR 0 3
14395: PUSH
14396: LD_INT 3
14398: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 56
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: IN
14415: IFFALSE 14425
// tmp := 4 ;
14417: LD_ADDR_VAR 0 3
14421: PUSH
14422: LD_INT 4
14424: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14425: LD_VAR 0 1
14429: PUSH
14430: LD_EXP 70
14434: PUSH
14435: LD_VAR 0 4
14439: ARRAY
14440: IN
14441: IFFALSE 14451
// tmp := 5 ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 5
14450: ST_TO_ADDR
// result := tmp ;
14451: LD_ADDR_VAR 0 2
14455: PUSH
14456: LD_VAR 0 3
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
// if mreg = ToArm then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToArm
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToArm [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 58
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToArm [ side ] [ i ] = unit then
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 58
14532: PUSH
14533: LD_EXP 58
14537: PPUSH
14538: LD_EXP 58
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31211 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToDep then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToDep
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToDep [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 59
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToDep [ side ] [ i ] = unit then
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 59
14629: PUSH
14630: LD_EXP 59
14634: PPUSH
14635: LD_EXP 59
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31211 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// if mreg = ToFac then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_STRING ToFac
14671: EQUAL
14672: IFFALSE 14761
// for i = MREG_ToFac [ side ] downto 1 do
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: DOUBLE
14680: LD_EXP 57
14684: PUSH
14685: LD_VAR 0 1
14689: ARRAY
14690: INC
14691: ST_TO_ADDR
14692: LD_INT 1
14694: PUSH
14695: FOR_DOWNTO
14696: IFFALSE 14759
// if MREG_ToFac [ side ] [ i ] = unit then
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PUSH
14715: LD_VAR 0 3
14719: EQUAL
14720: IFFALSE 14757
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14722: LD_ADDR_EXP 57
14726: PUSH
14727: LD_EXP 57
14731: PPUSH
14732: LD_EXP 57
14736: PUSH
14737: LD_VAR 0 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 5
14747: ARRAY
14748: PPUSH
14749: LD_INT 1
14751: PPUSH
14752: CALL 31211 0 3
14756: ST_TO_ADDR
// end ;
14757: GO 14695
14759: POP
14760: POP
// if mreg = ToLab then
14761: LD_VAR 0 2
14765: PUSH
14766: LD_STRING ToLab
14768: EQUAL
14769: IFFALSE 14858
// for i = MREG_ToLab [ side ] downto 1 do
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: DOUBLE
14777: LD_EXP 56
14781: PUSH
14782: LD_VAR 0 1
14786: ARRAY
14787: INC
14788: ST_TO_ADDR
14789: LD_INT 1
14791: PUSH
14792: FOR_DOWNTO
14793: IFFALSE 14856
// if MREG_ToLab [ side ] [ i ] = unit then
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 3
14816: EQUAL
14817: IFFALSE 14854
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14819: LD_ADDR_EXP 56
14823: PUSH
14824: LD_EXP 56
14828: PPUSH
14829: LD_EXP 56
14833: PUSH
14834: LD_VAR 0 1
14838: ARRAY
14839: PUSH
14840: LD_VAR 0 5
14844: ARRAY
14845: PPUSH
14846: LD_INT 1
14848: PPUSH
14849: CALL 31211 0 3
14853: ST_TO_ADDR
// end ;
14854: GO 14792
14856: POP
14857: POP
// end ;
14858: LD_VAR 0 4
14862: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14863: LD_INT 0
14865: PPUSH
14866: PPUSH
// result := false ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_INT 0
14874: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_EXP 48
14889: PUSH
14890: FOR_TO
14891: IFFALSE 14955
// if MREG_ToBuild [ i ] [ 1 ] = side then
14893: LD_EXP 48
14897: PUSH
14898: LD_VAR 0 3
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 1
14912: EQUAL
14913: IFFALSE 14953
// begin if MREG_ToBuild [ i ] [ 1 ] then
14915: LD_EXP 48
14919: PUSH
14920: LD_VAR 0 3
14924: ARRAY
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: IFFALSE 14953
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_EXP 48
14940: PUSH
14941: LD_VAR 0 3
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: ST_TO_ADDR
// break ;
14951: GO 14955
// end ; end ;
14953: GO 14890
14955: POP
14956: POP
// for i = 1 to MREG_ToRepair do
14957: LD_ADDR_VAR 0 3
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 49
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15037
// if MREG_ToRepair [ i ] [ 1 ] = side then
14975: LD_EXP 49
14979: PUSH
14980: LD_VAR 0 3
14984: ARRAY
14985: PUSH
14986: LD_INT 1
14988: ARRAY
14989: PUSH
14990: LD_VAR 0 1
14994: EQUAL
14995: IFFALSE 15035
// begin if MREG_ToRepair [ i ] [ 1 ] then
14997: LD_EXP 49
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: IFFALSE 15035
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15013: LD_ADDR_VAR 0 2
15017: PUSH
15018: LD_EXP 49
15022: PUSH
15023: LD_VAR 0 3
15027: ARRAY
15028: PUSH
15029: LD_INT 1
15031: ARRAY
15032: ST_TO_ADDR
// break ;
15033: GO 15037
// end ; end ;
15035: GO 14972
15037: POP
15038: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 57
15046: PUSH
15047: EMPTY
15048: LIST
15049: PPUSH
15050: CALL 11587 0 2
15054: IFFALSE 15081
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15056: LD_ADDR_VAR 0 2
15060: PUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 57
15068: PUSH
15069: EMPTY
15070: LIST
15071: PPUSH
15072: CALL 11587 0 2
15076: PUSH
15077: LD_INT 1
15079: ARRAY
15080: ST_TO_ADDR
// end ;
15081: LD_VAR 0 2
15085: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15093: LD_ADDR_VAR 0 6
15097: PUSH
15098: LD_VAR 0 1
15102: PPUSH
15103: LD_INT 21
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PPUSH
15113: CALL 11587 0 2
15117: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15118: LD_ADDR_VAR 0 7
15122: PUSH
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_INT 81
15130: PUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 11587 0 2
15144: ST_TO_ADDR
// if not enemy then
15145: LD_VAR 0 7
15149: NOT
15150: IFFALSE 15162
// result := false else
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 0
15159: ST_TO_ADDR
15160: GO 15216
// begin scan := NearestUnit ( b , enemy ) ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 6
15171: PPUSH
15172: LD_VAR 0 7
15176: PPUSH
15177: CALL 32204 0 2
15181: ST_TO_ADDR
// if scan [ 2 ] < dist then
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 2
15189: ARRAY
15190: PUSH
15191: LD_VAR 0 2
15195: LESS
15196: IFFALSE 15208
// result := true else
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
15206: GO 15216
// result := false ;
15208: LD_ADDR_VAR 0 3
15212: PUSH
15213: LD_INT 0
15215: ST_TO_ADDR
// end ; end ;
15216: LD_VAR 0 3
15220: RET
// export function MCF_Info ( ) ; begin
15221: LD_INT 0
15223: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15224: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15226: PUSH
15227: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15229: ADD
15230: PUSH
15231: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15233: ADD
15234: PUSH
15235: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15237: ADD
15238: PUSH
15239: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15241: ADD
15242: PUSH
15243: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15245: ADD
15246: PUSH
15247: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15249: ADD
15250: PUSH
15251: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15253: ADD
15254: PUSH
15255: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15257: ADD
15258: PUSH
15259: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15261: ADD
15262: PPUSH
15263: CALL 8505 0 1
// end ; end_of_file
15267: LD_VAR 0 1
15271: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15272: LD_INT 0
15274: PPUSH
15275: PPUSH
15276: PPUSH
15277: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15278: LD_ADDR_VAR 0 5
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 25
15293: PUSH
15294: LD_INT 2
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PUSH
15301: LD_INT 25
15303: PUSH
15304: LD_INT 3
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 25
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL 11587 0 2
15331: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_VAR 0 5
15341: PPUSH
15342: LD_INT 0
15344: PPUSH
15345: CALL 13736 0 2
15349: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15350: LD_ADDR_VAR 0 6
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 5
15364: PPUSH
15365: LD_INT 1
15367: PPUSH
15368: CALL 13356 0 3
15372: ST_TO_ADDR
// if n > sk then
15373: LD_VAR 0 2
15377: PUSH
15378: LD_VAR 0 6
15382: GREATER
15383: IFFALSE 15395
// n := sk ;
15385: LD_ADDR_VAR 0 2
15389: PUSH
15390: LD_VAR 0 6
15394: ST_TO_ADDR
// for i = 1 to n do
15395: LD_ADDR_VAR 0 4
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_TO
15411: IFFALSE 15523
// if ( sk [ i ] [ 1 ] ) <> 0 then
15413: LD_VAR 0 6
15417: PUSH
15418: LD_VAR 0 4
15422: ARRAY
15423: PUSH
15424: LD_INT 1
15426: ARRAY
15427: PUSH
15428: LD_INT 0
15430: NONEQUAL
15431: IFFALSE 15521
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15433: LD_ADDR_EXP 55
15437: PUSH
15438: LD_EXP 55
15442: PPUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 6
15452: PUSH
15453: LD_VAR 0 4
15457: ARRAY
15458: PUSH
15459: LD_INT 1
15461: ARRAY
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: CALL 41882 0 4
15470: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_EXP 58
15480: PPUSH
15481: LD_VAR 0 1
15485: PPUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PUSH
15497: LD_INT 1
15499: PLUS
15500: PPUSH
15501: LD_VAR 0 6
15505: PUSH
15506: LD_VAR 0 4
15510: ARRAY
15511: PUSH
15512: LD_INT 1
15514: ARRAY
15515: PPUSH
15516: CALL 31052 0 4
15520: ST_TO_ADDR
// end ;
15521: GO 15410
15523: POP
15524: POP
// end ;
15525: LD_VAR 0 3
15529: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15530: LD_INT 0
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: LD_INT 2
15548: PUSH
15549: LD_INT 25
15551: PUSH
15552: LD_INT 1
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: LD_INT 25
15561: PUSH
15562: LD_INT 3
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 25
15571: PUSH
15572: LD_INT 4
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: PPUSH
15585: CALL 11587 0 2
15589: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15590: LD_ADDR_VAR 0 5
15594: PUSH
15595: LD_VAR 0 5
15599: PPUSH
15600: LD_INT 0
15602: PPUSH
15603: CALL 13736 0 2
15607: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_VAR 0 5
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL 13356 0 3
15630: ST_TO_ADDR
// if n > sk then
15631: LD_VAR 0 2
15635: PUSH
15636: LD_VAR 0 6
15640: GREATER
15641: IFFALSE 15653
// n := sk ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_VAR 0 6
15652: ST_TO_ADDR
// for i = 1 to n do
15653: LD_ADDR_VAR 0 4
15657: PUSH
15658: DOUBLE
15659: LD_INT 1
15661: DEC
15662: ST_TO_ADDR
15663: LD_VAR 0 2
15667: PUSH
15668: FOR_TO
15669: IFFALSE 15781
// if ( sk [ i ] [ 1 ] ) <> 0 then
15671: LD_VAR 0 6
15675: PUSH
15676: LD_VAR 0 4
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_INT 0
15688: NONEQUAL
15689: IFFALSE 15779
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15691: LD_ADDR_EXP 55
15695: PUSH
15696: LD_EXP 55
15700: PPUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PUSH
15711: LD_VAR 0 4
15715: ARRAY
15716: PUSH
15717: LD_INT 1
15719: ARRAY
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL 41882 0 4
15728: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15729: LD_ADDR_EXP 59
15733: PUSH
15734: LD_EXP 59
15738: PPUSH
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_EXP 59
15748: PUSH
15749: LD_VAR 0 1
15753: ARRAY
15754: PUSH
15755: LD_INT 1
15757: PLUS
15758: PPUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 4
15768: ARRAY
15769: PUSH
15770: LD_INT 1
15772: ARRAY
15773: PPUSH
15774: CALL 31052 0 4
15778: ST_TO_ADDR
// end ;
15779: GO 15668
15781: POP
15782: POP
// end ;
15783: LD_VAR 0 3
15787: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15788: LD_INT 0
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15794: LD_ADDR_VAR 0 5
15798: PUSH
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 2
15806: PUSH
15807: LD_INT 25
15809: PUSH
15810: LD_INT 1
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 25
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 25
15829: PUSH
15830: LD_INT 4
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11587 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13736 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 3
15883: PPUSH
15884: CALL 13356 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL 41882 0 4
15986: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 57
15991: PUSH
15992: LD_EXP 57
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 57
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 31052 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL 11587 0 2
16094: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: LD_VAR 0 5
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL 13736 0 2
16112: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16113: LD_ADDR_VAR 0 6
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 5
16127: PPUSH
16128: LD_INT 4
16130: PPUSH
16131: CALL 13356 0 3
16135: ST_TO_ADDR
// if n > sk then
16136: LD_VAR 0 2
16140: PUSH
16141: LD_VAR 0 6
16145: GREATER
16146: IFFALSE 16158
// n := sk ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_VAR 0 6
16157: ST_TO_ADDR
// for i = 1 to n do
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: DOUBLE
16164: LD_INT 1
16166: DEC
16167: ST_TO_ADDR
16168: LD_VAR 0 2
16172: PUSH
16173: FOR_TO
16174: IFFALSE 16286
// if ( sk [ i ] [ 1 ] ) <> 0 then
16176: LD_VAR 0 6
16180: PUSH
16181: LD_VAR 0 4
16185: ARRAY
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PUSH
16191: LD_INT 0
16193: NONEQUAL
16194: IFFALSE 16284
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16196: LD_ADDR_EXP 55
16200: PUSH
16201: LD_EXP 55
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 6
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: LD_INT 4
16228: PPUSH
16229: CALL 41882 0 4
16233: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16234: LD_ADDR_EXP 56
16238: PUSH
16239: LD_EXP 56
16243: PPUSH
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_EXP 56
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PUSH
16260: LD_INT 1
16262: PLUS
16263: PPUSH
16264: LD_VAR 0 6
16268: PUSH
16269: LD_VAR 0 4
16273: ARRAY
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL 31052 0 4
16283: ST_TO_ADDR
// end ;
16284: GO 16173
16286: POP
16287: POP
// end ;
16288: LD_VAR 0 3
16292: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16293: LD_INT 0
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_INT 2
16311: PUSH
16312: LD_INT 25
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 25
16324: PUSH
16325: LD_INT 2
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 25
16334: PUSH
16335: LD_INT 3
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PUSH
16342: LD_INT 25
16344: PUSH
16345: LD_INT 4
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL 11587 0 2
16363: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16364: LD_ADDR_VAR 0 6
16368: PUSH
16369: LD_VAR 0 6
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL 13736 0 2
16381: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16382: LD_ADDR_VAR 0 7
16386: PUSH
16387: LD_VAR 0 1
16391: PPUSH
16392: LD_VAR 0 6
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: CALL 13356 0 3
16404: ST_TO_ADDR
// if n > sk then
16405: LD_VAR 0 2
16409: PUSH
16410: LD_VAR 0 7
16414: GREATER
16415: IFFALSE 16427
// n := sk ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 7
16426: ST_TO_ADDR
// for i = 1 to n do
16427: LD_ADDR_VAR 0 5
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16445: LD_ADDR_EXP 55
16449: PUSH
16450: LD_EXP 55
16454: PPUSH
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PUSH
16465: LD_VAR 0 5
16469: ARRAY
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: CALL 41882 0 4
16484: ST_TO_ADDR
// end ;
16485: GO 16442
16487: POP
16488: POP
// end ;
16489: LD_VAR 0 4
16493: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// b := false ;
16499: LD_ADDR_VAR 0 6
16503: PUSH
16504: LD_INT 0
16506: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 9
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 8
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: IN
16530: IFFALSE 16618
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 30
16542: PUSH
16543: LD_INT 4
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL 11587 0 2
16569: IFFALSE 16618
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16571: LD_ADDR_VAR 0 6
16575: PUSH
16576: LD_VAR 0 1
16580: PPUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 30
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 5
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL 11587 0 2
16613: PUSH
16614: LD_INT 1
16616: ARRAY
16617: ST_TO_ADDR
// if class = class_engineer then
16618: LD_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: EQUAL
16626: IFFALSE 16714
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16628: LD_VAR 0 1
16632: PPUSH
16633: LD_INT 2
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 0
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PPUSH
16661: CALL 11587 0 2
16665: IFFALSE 16714
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16667: LD_ADDR_VAR 0 6
16671: PUSH
16672: LD_VAR 0 1
16676: PPUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 30
16682: PUSH
16683: LD_INT 0
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 30
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11587 0 2
16709: PUSH
16710: LD_INT 1
16712: ARRAY
16713: ST_TO_ADDR
// if class = class_mechanic then
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 3
16721: EQUAL
16722: IFFALSE 16792
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16724: LD_VAR 0 1
16728: PPUSH
16729: LD_INT 30
16731: PUSH
16732: LD_INT 3
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL 11587 0 2
16743: IFFALSE 16792
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16745: LD_ADDR_VAR 0 6
16749: PUSH
16750: LD_VAR 0 1
16754: PPUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 30
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 30
16770: PUSH
16771: LD_INT 3
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL 11587 0 2
16787: PUSH
16788: LD_INT 1
16790: ARRAY
16791: ST_TO_ADDR
// if class = class_scientistic then
16792: LD_VAR 0 3
16796: PUSH
16797: LD_INT 4
16799: EQUAL
16800: IFFALSE 16910
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16802: LD_VAR 0 1
16806: PPUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 30
16812: PUSH
16813: LD_INT 6
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 30
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 30
16832: PUSH
16833: LD_INT 8
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL 11587 0 2
16850: IFFALSE 16910
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16852: LD_ADDR_VAR 0 6
16856: PUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: LD_INT 2
16864: PUSH
16865: LD_INT 30
16867: PUSH
16868: LD_INT 6
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 30
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 30
16887: PUSH
16888: LD_INT 8
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PPUSH
16901: CALL 11587 0 2
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: ST_TO_ADDR
// if GetClass ( unit ) = class then
16910: LD_VAR 0 2
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_VAR 0 3
16924: EQUAL
16925: IFFALSE 16959
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16927: LD_ADDR_EXP 55
16931: PUSH
16932: LD_EXP 55
16936: PPUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: LD_VAR 0 3
16951: PPUSH
16952: CALL 41973 0 4
16956: ST_TO_ADDR
// end else
16957: GO 17052
// if b then
16959: LD_VAR 0 6
16963: IFFALSE 17044
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 310
16974: PUSH
16975: LD_VAR 0 2
16979: PPUSH
16980: CALL_OW 310
16984: PUSH
16985: LD_VAR 0 6
16989: NONEQUAL
16990: AND
16991: IFFALSE 17002
// ComExitBuilding ( unit ) ;
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL_OW 122
// if not IsInUnit ( unit ) then
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 310
17011: NOT
17012: IFFALSE 17028
// ComEnterUnit ( unit , b ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17028: LD_VAR 0 2
17032: PPUSH
17033: LD_VAR 0 3
17037: PPUSH
17038: CALL_OW 183
// end else
17042: GO 17052
// result := false ;
17044: LD_ADDR_VAR 0 4
17048: PUSH
17049: LD_INT 0
17051: ST_TO_ADDR
// end ; end_of_file
17052: LD_VAR 0 4
17056: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
17062: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17063: LD_ADDR_VAR 0 5
17067: PUSH
17068: LD_INT 35
17070: PUSH
17071: LD_INT 45
17073: PUSH
17074: LD_INT 46
17076: PUSH
17077: LD_INT 47
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 48
17088: PUSH
17089: LD_INT 49
17091: PUSH
17092: LD_INT 50
17094: PUSH
17095: LD_INT 20
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
// if MCF_Lab ( side ) then
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 11626 0 1
17119: IFFALSE 17358
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL 11626 0 1
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: CALL_OW 461
17139: PUSH
17140: LD_INT 2
17142: EQUAL
17143: IFFALSE 17282
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL 11626 0 1
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL 17454 0 2
17168: IFFALSE 17195
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL 11626 0 1
17179: PUSH
17180: LD_INT 1
17182: ARRAY
17183: PPUSH
17184: LD_VAR 0 2
17188: PPUSH
17189: CALL_OW 124
17193: GO 17282
// if MCF_Lab ( side ) > 1 then
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL 11626 0 1
17204: PUSH
17205: LD_INT 1
17207: GREATER
17208: IFFALSE 17282
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17210: LD_VAR 0 1
17214: PPUSH
17215: CALL 11626 0 1
17219: PUSH
17220: LD_INT 2
17222: ARRAY
17223: PPUSH
17224: CALL_OW 461
17228: PUSH
17229: LD_INT 2
17231: EQUAL
17232: IFFALSE 17282
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11626 0 1
17243: PUSH
17244: LD_INT 2
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL 17454 0 2
17257: IFFALSE 17282
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11626 0 1
17268: PUSH
17269: LD_INT 2
17271: ARRAY
17272: PPUSH
17273: LD_VAR 0 2
17277: PPUSH
17278: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17282: LD_VAR 0 2
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: LD_INT 11
17292: PUSH
17293: LD_INT 4
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: IN
17305: IFFALSE 17358
// begin for lab in MCF_Lab ( side ) do
17307: LD_ADDR_VAR 0 6
17311: PUSH
17312: LD_VAR 0 1
17316: PPUSH
17317: CALL 11626 0 1
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17356
// if BuildingStatus ( lab ) = bs_need_ape then
17325: LD_VAR 0 6
17329: PPUSH
17330: CALL_OW 461
17334: PUSH
17335: LD_INT 10
17337: EQUAL
17338: IFFALSE 17354
// MCL_ResTame ( side , lab ) ;
17340: LD_VAR 0 1
17344: PPUSH
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL 17579 0 2
17354: GO 17322
17356: POP
17357: POP
// end ; end ; end ;
17358: LD_VAR 0 3
17362: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
// tmp := [ ] ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: EMPTY
17373: ST_TO_ADDR
// if not lab then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17391
// result := false else
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: LD_INT 0
17388: ST_TO_ADDR
17389: GO 17449
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: CALL_OW 268
17413: ADD
17414: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 3
17424: PUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: LD_INT 2
17432: PPUSH
17433: CALL_OW 268
17437: ADD
17438: ST_TO_ADDR
// result := tmp ;
17439: LD_ADDR_VAR 0 2
17443: PUSH
17444: LD_VAR 0 3
17448: ST_TO_ADDR
// end ; end ;
17449: LD_VAR 0 2
17453: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 35
17466: PUSH
17467: LD_INT 45
17469: PUSH
17470: LD_INT 46
17472: PUSH
17473: LD_INT 47
17475: PUSH
17476: LD_INT 1
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: LD_INT 48
17484: PUSH
17485: LD_INT 49
17487: PUSH
17488: LD_INT 50
17490: PUSH
17491: LD_INT 20
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: ST_TO_ADDR
// if lab then
17506: LD_VAR 0 1
17510: IFFALSE 17566
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17512: LD_VAR 0 2
17516: PUSH
17517: LD_VAR 0 5
17521: IN
17522: PUSH
17523: LD_VAR 0 2
17527: PPUSH
17528: CALL_OW 481
17532: PUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: CALL 17363 0 1
17542: IN
17543: OR
17544: IFFALSE 17556
// result := true else
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
17554: GO 17564
// result := false ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_INT 0
17563: ST_TO_ADDR
// end else
17564: GO 17574
// result := false ;
17566: LD_ADDR_VAR 0 3
17570: PUSH
17571: LD_INT 0
17573: ST_TO_ADDR
// end ;
17574: LD_VAR 0 3
17578: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17579: LD_INT 0
17581: PPUSH
17582: PPUSH
17583: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 171
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL 12290 0 3
17603: ST_TO_ADDR
// if not ape then
17604: LD_VAR 0 4
17608: NOT
17609: IFFALSE 17641
// if MCF_Ape ( side ) then
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL 12000 0 1
17620: IFFALSE 17641
// ape := MCF_Ape ( side ) [ 1 ] ;
17622: LD_ADDR_VAR 0 4
17626: PUSH
17627: LD_VAR 0 1
17631: PPUSH
17632: CALL 12000 0 1
17636: PUSH
17637: LD_INT 1
17639: ARRAY
17640: ST_TO_ADDR
// if ape then
17641: LD_VAR 0 4
17645: IFFALSE 17696
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17647: LD_VAR 0 4
17651: PUSH
17652: LD_INT 1
17654: ARRAY
17655: PPUSH
17656: CALL_OW 310
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: LD_INT 1
17668: ARRAY
17669: PPUSH
17670: CALL_OW 310
17674: PUSH
17675: LD_VAR 0 2
17679: NONEQUAL
17680: AND
17681: IFFALSE 17696
// ComExitBuilding ( ape [ 1 ] ) ;
17683: LD_VAR 0 4
17687: PUSH
17688: LD_INT 1
17690: ARRAY
17691: PPUSH
17692: CALL_OW 122
// if not lab then
17696: LD_VAR 0 2
17700: NOT
17701: IFFALSE 17707
// exit else
17703: GO 17855
17705: GO 17815
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 16
17714: PPUSH
17715: LD_INT 25
17717: PUSH
17718: LD_INT 4
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL 12290 0 3
17729: PUSH
17730: LD_INT 0
17732: EQUAL
17733: PUSH
17734: LD_VAR 0 2
17738: PPUSH
17739: CALL_OW 313
17743: PUSH
17744: LD_INT 6
17746: EQUAL
17747: AND
17748: IFFALSE 17815
// begin tmp := UnitsInside ( lab ) ;
17750: LD_ADDR_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: CALL_OW 313
17764: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 5
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 5
17792: ARRAY
17793: PPUSH
17794: CALL_OW 310
17798: IFFALSE 17815
// ComExitBuilding ( tmp [ tmp ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 5
17809: ARRAY
17810: PPUSH
17811: CALL_OW 122
// end ; if ape then
17815: LD_VAR 0 4
17819: IFFALSE 17855
// if not IsInUnit ( ape [ 1 ] ) then
17821: LD_VAR 0 4
17825: PUSH
17826: LD_INT 1
17828: ARRAY
17829: PPUSH
17830: CALL_OW 310
17834: NOT
17835: IFFALSE 17855
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PPUSH
17846: LD_VAR 0 2
17850: PPUSH
17851: CALL_OW 120
// end ;
17855: LD_VAR 0 3
17859: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17860: LD_INT 0
17862: PPUSH
17863: PPUSH
17864: PPUSH
// result := false ;
17865: LD_ADDR_VAR 0 2
17869: PUSH
17870: LD_INT 0
17872: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 1
17882: PPUSH
17883: CALL 17970 0 1
17887: ST_TO_ADDR
// if techs then
17888: LD_VAR 0 3
17892: IFFALSE 17922
// if techs [ 2 ] then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 2
17901: ARRAY
17902: IFFALSE 17914
// result := true else
17904: LD_ADDR_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: ST_TO_ADDR
17912: GO 17922
// result := false ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// end ;
17922: LD_VAR 0 2
17926: RET
// export function MCL_Start ( side ) ; var i ; begin
17927: LD_INT 0
17929: PPUSH
17930: PPUSH
// if MCL_GetTechList ( side ) then
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 17970 0 1
17940: IFFALSE 17965
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 17970 0 1
17956: PUSH
17957: LD_INT 1
17959: ARRAY
17960: PPUSH
17961: CALL 17057 0 2
// end ;
17965: LD_VAR 0 2
17969: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17970: LD_INT 0
17972: PPUSH
17973: PPUSH
17974: PPUSH
// if MREG_ToRes then
17975: LD_EXP 52
17979: IFFALSE 18064
// for i = 1 to MREG_ToRes do
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: DOUBLE
17987: LD_INT 1
17989: DEC
17990: ST_TO_ADDR
17991: LD_EXP 52
17995: PUSH
17996: FOR_TO
17997: IFFALSE 18062
// if MREG_ToRes [ i ] [ 1 ] = side then
17999: LD_EXP 52
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 1
18012: ARRAY
18013: PUSH
18014: LD_VAR 0 1
18018: EQUAL
18019: IFFALSE 18060
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18021: LD_ADDR_VAR 0 4
18025: PUSH
18026: LD_VAR 0 4
18030: PPUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: PLUS
18039: PPUSH
18040: LD_EXP 52
18044: PUSH
18045: LD_VAR 0 3
18049: ARRAY
18050: PUSH
18051: LD_INT 2
18053: ARRAY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// end ;
18060: GO 17996
18062: POP
18063: POP
// result := techs ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_VAR 0 4
18073: ST_TO_ADDR
// end ;
18074: LD_VAR 0 2
18078: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18079: LD_INT 0
18081: PPUSH
18082: PPUSH
// for i = 1 to tech_list do
18083: LD_ADDR_VAR 0 4
18087: PUSH
18088: DOUBLE
18089: LD_INT 1
18091: DEC
18092: ST_TO_ADDR
18093: LD_VAR 0 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18153
// if not tech_list [ i ] = 20 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_VAR 0 4
18110: ARRAY
18111: PUSH
18112: LD_INT 20
18114: EQUAL
18115: NOT
18116: IFFALSE 18151
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18118: LD_ADDR_EXP 52
18122: PUSH
18123: LD_EXP 52
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: ARRAY
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL 41882 0 4
18150: ST_TO_ADDR
18151: GO 18098
18153: POP
18154: POP
// result := true ;
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
// for i = MREG_ToRes downto 1 do
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: DOUBLE
18178: LD_EXP 52
18182: INC
18183: ST_TO_ADDR
18184: LD_INT 1
18186: PUSH
18187: FOR_DOWNTO
18188: IFFALSE 18234
// if MREG_ToRes [ i ] [ 1 ] = side then
18190: LD_EXP 52
18194: PUSH
18195: LD_VAR 0 3
18199: ARRAY
18200: PUSH
18201: LD_INT 1
18203: ARRAY
18204: PUSH
18205: LD_VAR 0 1
18209: EQUAL
18210: IFFALSE 18232
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18212: LD_ADDR_EXP 52
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: LD_VAR 0 3
18226: PPUSH
18227: CALL_OW 3
18231: ST_TO_ADDR
18232: GO 18187
18234: POP
18235: POP
// result := true ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 1
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18249: LD_INT 0
18251: PPUSH
// result := GetTechProgress ( side , tech ) ;
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: CALL_OW 326
18271: ST_TO_ADDR
// end ;
18272: LD_VAR 0 3
18276: RET
// export function MCL_Require ( tech ) ; begin
18277: LD_INT 0
18279: PPUSH
// result := GetTechTechsReq ( tech ) ;
18280: LD_ADDR_VAR 0 2
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 480
18294: ST_TO_ADDR
// end ; end_of_file
18295: LD_VAR 0 2
18299: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18300: LD_INT 0
18302: PPUSH
18303: PPUSH
18304: PPUSH
// uc_side := 0 ;
18305: LD_ADDR_OWVAR 20
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// uc_nation := 0 ;
18313: LD_ADDR_OWVAR 21
18317: PUSH
18318: LD_INT 0
18320: ST_TO_ADDR
// for i = 1 to n do
18321: LD_ADDR_VAR 0 5
18325: PUSH
18326: DOUBLE
18327: LD_INT 1
18329: DEC
18330: ST_TO_ADDR
18331: LD_VAR 0 2
18335: PUSH
18336: FOR_TO
18337: IFFALSE 18482
// begin hc_importance := 0 ;
18339: LD_ADDR_OWVAR 32
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// hc_gallery :=  ;
18347: LD_ADDR_OWVAR 33
18351: PUSH
18352: LD_STRING 
18354: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18355: LD_ADDR_OWVAR 35
18359: PUSH
18360: LD_VAR 0 3
18364: PUSH
18365: LD_INT 20
18367: MINUS
18368: PPUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_INT 20
18376: PLUS
18377: PPUSH
18378: CALL_OW 12
18382: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18383: LD_ADDR_OWVAR 31
18387: PUSH
18388: LD_INT 0
18390: PPUSH
18391: LD_INT 2
18393: PPUSH
18394: CALL_OW 12
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: LD_INT 0
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18414: LD_ADDR_OWVAR 30
18418: PUSH
18419: LD_INT 0
18421: PUSH
18422: LD_INT 0
18424: PUSH
18425: LD_INT 0
18427: PUSH
18428: LD_INT 0
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_class := class_apeman ;
18445: LD_ADDR_OWVAR 28
18449: PUSH
18450: LD_INT 12
18452: ST_TO_ADDR
// ape := CreateHuman ;
18453: LD_ADDR_VAR 0 6
18457: PUSH
18458: CALL_OW 44
18462: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18463: LD_VAR 0 6
18467: PPUSH
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 0
18475: PPUSH
18476: CALL_OW 49
// end ;
18480: GO 18336
18482: POP
18483: POP
// end ;
18484: LD_VAR 0 4
18488: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18489: LD_INT 0
18491: PPUSH
18492: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL 12000 0 1
18502: PUSH
18503: LD_EXP 39
18507: PUSH
18508: LD_VAR 0 1
18512: ARRAY
18513: GREATEREQUAL
18514: IFFALSE 18691
// begin if GetTag ( unit ) = 17 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 17
18528: EQUAL
18529: IFFALSE 18689
// begin SetTag ( unit , 0 ) ;
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 0
18538: PPUSH
18539: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18543: LD_VAR 0 1
18547: PPUSH
18548: CALL 11626 0 1
18552: PUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL 17970 0 1
18562: NOT
18563: AND
18564: IFFALSE 18589
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18566: LD_VAR 0 2
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: CALL 11626 0 1
18580: PUSH
18581: LD_INT 1
18583: ARRAY
18584: PPUSH
18585: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18589: LD_VAR 0 1
18593: PPUSH
18594: CALL 11626 0 1
18598: NOT
18599: PUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL 11587 0 2
18619: AND
18620: IFFALSE 18689
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18622: LD_VAR 0 2
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: LD_INT 30
18634: PUSH
18635: LD_INT 1
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PPUSH
18642: CALL 11587 0 2
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 250
18655: PPUSH
18656: LD_VAR 0 1
18660: PPUSH
18661: LD_INT 30
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL 11587 0 2
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: PPUSH
18680: CALL_OW 251
18684: PPUSH
18685: CALL_OW 111
// end ; end else
18689: GO 18875
// if GetClass ( unit ) <> 4 then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 257
18700: PUSH
18701: LD_INT 4
18703: NONEQUAL
18704: IFFALSE 18710
// exit else
18706: GO 18875
18708: GO 18875
// if GetTag ( unit ) = 0 then
18710: LD_VAR 0 2
18714: PPUSH
18715: CALL_OW 110
18719: PUSH
18720: LD_INT 0
18722: EQUAL
18723: IFFALSE 18739
// SetTag ( unit , 17 ) else
18725: LD_VAR 0 2
18729: PPUSH
18730: LD_INT 17
18732: PPUSH
18733: CALL_OW 109
18737: GO 18875
// begin if IsInUnit ( unit ) then
18739: LD_VAR 0 2
18743: PPUSH
18744: CALL_OW 310
18748: IFFALSE 18759
// ComExitBuilding ( unit ) ;
18750: LD_VAR 0 2
18754: PPUSH
18755: CALL_OW 122
// Wait ( 1 ) ;
18759: LD_INT 1
18761: PPUSH
18762: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: LD_INT 22
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 12
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: PPUSH
18800: LD_VAR 0 2
18804: PPUSH
18805: CALL_OW 74
18809: ST_TO_ADDR
// if not ape then
18810: LD_VAR 0 4
18814: NOT
18815: IFFALSE 18821
// exit else
18817: GO 18875
18819: GO 18830
// ComHold ( ape ) ;
18821: LD_VAR 0 4
18825: PPUSH
18826: CALL_OW 140
// if not HasTask ( unit ) then
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 314
18839: NOT
18840: IFFALSE 18873
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18842: LD_VAR 0 2
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: CALL_OW 250
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: CALL_OW 251
18866: PPUSH
18867: CALL_OW 131
18871: GO 18875
// exit ;
18873: GO 18875
// end ; end ;
18875: LD_VAR 0 3
18879: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18880: LD_INT 0
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_EXP 40
18895: PUSH
18896: LD_VAR 0 1
18900: ARRAY
18901: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18902: LD_ADDR_VAR 0 5
18906: PUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_STRING normal
18914: PPUSH
18915: CALL 12084 0 2
18919: ST_TO_ADDR
// if apes then
18920: LD_VAR 0 5
18924: IFFALSE 19152
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18926: LD_INT 2
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: CALL_OW 321
18938: PUSH
18939: LD_INT 2
18941: EQUAL
18942: PUSH
18943: LD_VAR 0 4
18947: PUSH
18948: LD_INT 2
18950: ARRAY
18951: PUSH
18952: LD_INT 1
18954: EQUAL
18955: AND
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_STRING engineer
18964: PPUSH
18965: CALL 12084 0 2
18969: PUSH
18970: LD_INT 3
18972: LESS
18973: AND
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 30
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PPUSH
18990: CALL 11587 0 2
18994: AND
18995: IFFALSE 19049
// begin for i in apes do
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 5
19006: PUSH
19007: FOR_IN
19008: IFFALSE 19045
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_VAR 0 1
19019: PPUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL 11587 0 2
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: PPUSH
19039: CALL_OW 120
// end ;
19043: GO 19007
19045: POP
19046: POP
// end else
19047: GO 19152
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19049: LD_INT 11
19051: PPUSH
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 321
19061: PUSH
19062: LD_INT 2
19064: EQUAL
19065: PUSH
19066: LD_VAR 0 4
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PUSH
19075: LD_INT 1
19077: EQUAL
19078: AND
19079: PUSH
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 30
19087: PUSH
19088: LD_INT 5
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PPUSH
19095: CALL 11587 0 2
19099: AND
19100: IFFALSE 19152
// begin for i in apes do
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19150
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19115: LD_VAR 0 3
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 30
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL 11587 0 2
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PPUSH
19144: CALL_OW 120
// end ;
19148: GO 19112
19150: POP
19151: POP
// end ; end ; end ; end_of_file
19152: LD_VAR 0 2
19156: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 257
19170: PUSH
19171: LD_INT 4
19173: EQUAL
19174: NOT
19175: PUSH
19176: LD_VAR 0 2
19180: NOT
19181: OR
19182: IFFALSE 19188
// exit else
19184: GO 19222
19186: GO 19222
// if not GetTag ( unit ) = 4 then
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 110
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: NOT
19202: IFFALSE 19208
// exit else
19204: GO 19222
19206: GO 19222
// ComHeal ( unit , target ) ;
19208: LD_VAR 0 1
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: CALL_OW 128
// end ;
19222: LD_VAR 0 3
19226: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19227: LD_INT 0
19229: PPUSH
19230: PPUSH
19231: PPUSH
19232: PPUSH
19233: PPUSH
19234: PPUSH
19235: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19236: LD_ADDR_VAR 0 5
19240: PUSH
19241: LD_INT 22
19243: PUSH
19244: LD_VAR 0 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 55
19268: PUSH
19269: EMPTY
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 3
19278: PUSH
19279: LD_INT 54
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: LD_INT 1000
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19318: LD_ADDR_VAR 0 8
19322: PUSH
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_INT 30
19330: PUSH
19331: LD_INT 1
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL 11587 0 2
19342: ST_TO_ADDR
// r := [ ] ;
19343: LD_ADDR_VAR 0 6
19347: PUSH
19348: EMPTY
19349: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 5
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL 12290 0 3
19364: IFFALSE 19420
// for j in MCF_Tag ( side , 5 , [ ] ) do
19366: LD_ADDR_VAR 0 4
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: EMPTY
19380: PPUSH
19381: CALL 12290 0 3
19385: PUSH
19386: FOR_IN
19387: IFFALSE 19418
// if GetLives ( j ) = 1000 then
19389: LD_VAR 0 4
19393: PPUSH
19394: CALL_OW 256
19398: PUSH
19399: LD_INT 1000
19401: EQUAL
19402: IFFALSE 19416
// SetTag ( j , 0 ) ;
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 109
19416: GO 19386
19418: POP
19419: POP
// if tmp then
19420: LD_VAR 0 5
19424: IFFALSE 19753
// begin r := [ tmp [ 1 ] ] ;
19426: LD_ADDR_VAR 0 6
19430: PUSH
19431: LD_VAR 0 5
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: PUSH
19440: EMPTY
19441: LIST
19442: ST_TO_ADDR
// for i = 2 to tmp do
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: DOUBLE
19449: LD_INT 2
19451: DEC
19452: ST_TO_ADDR
19453: LD_VAR 0 5
19457: PUSH
19458: FOR_TO
19459: IFFALSE 19751
// begin m := false ;
19461: LD_ADDR_VAR 0 7
19465: PUSH
19466: LD_INT 0
19468: ST_TO_ADDR
// if d then
19469: LD_VAR 0 8
19473: IFFALSE 19628
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19475: LD_VAR 0 5
19479: PUSH
19480: LD_VAR 0 3
19484: ARRAY
19485: PPUSH
19486: CALL_OW 256
19490: PUSH
19491: LD_INT 650
19493: LESS
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_VAR 0 3
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 8
19510: PUSH
19511: LD_INT 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 250
19519: PPUSH
19520: LD_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: CALL_OW 251
19533: PPUSH
19534: CALL_OW 297
19538: PUSH
19539: LD_INT 10
19541: GREATER
19542: AND
19543: IFFALSE 19628
// begin if not GetTag ( tmp [ i ] ) = 5 then
19545: LD_VAR 0 5
19549: PUSH
19550: LD_VAR 0 3
19554: ARRAY
19555: PPUSH
19556: CALL_OW 110
19560: PUSH
19561: LD_INT 5
19563: EQUAL
19564: NOT
19565: IFFALSE 19585
// SetTag ( tmp [ i ] , 5 ) ;
19567: LD_VAR 0 5
19571: PUSH
19572: LD_VAR 0 3
19576: ARRAY
19577: PPUSH
19578: LD_INT 5
19580: PPUSH
19581: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19585: LD_VAR 0 5
19589: PUSH
19590: LD_VAR 0 3
19594: ARRAY
19595: PPUSH
19596: LD_VAR 0 8
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PPUSH
19605: CALL_OW 250
19609: PPUSH
19610: LD_VAR 0 8
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: PPUSH
19619: CALL_OW 251
19623: PPUSH
19624: CALL_OW 111
// end ; for j = 1 to r do
19628: LD_ADDR_VAR 0 4
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19718
// if GetLives ( tmp [ i ] ) < r [ j ] then
19646: LD_VAR 0 5
19650: PUSH
19651: LD_VAR 0 3
19655: ARRAY
19656: PPUSH
19657: CALL_OW 256
19661: PUSH
19662: LD_VAR 0 6
19666: PUSH
19667: LD_VAR 0 4
19671: ARRAY
19672: LESS
19673: IFFALSE 19716
// begin r := Insert ( r , j , tmp [ i ] ) ;
19675: LD_ADDR_VAR 0 6
19679: PUSH
19680: LD_VAR 0 6
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PUSH
19695: LD_VAR 0 3
19699: ARRAY
19700: PPUSH
19701: CALL_OW 2
19705: ST_TO_ADDR
// m := true ;
19706: LD_ADDR_VAR 0 7
19710: PUSH
19711: LD_INT 1
19713: ST_TO_ADDR
// break ;
19714: GO 19718
// end ;
19716: GO 19643
19718: POP
19719: POP
// if not m then
19720: LD_VAR 0 7
19724: NOT
19725: IFFALSE 19749
// r := r ^ tmp [ i ] ;
19727: LD_ADDR_VAR 0 6
19731: PUSH
19732: LD_VAR 0 6
19736: PUSH
19737: LD_VAR 0 5
19741: PUSH
19742: LD_VAR 0 3
19746: ARRAY
19747: ADD
19748: ST_TO_ADDR
// end ;
19749: GO 19458
19751: POP
19752: POP
// end ; result := r end ; end_of_file
19753: LD_ADDR_VAR 0 2
19757: PUSH
19758: LD_VAR 0 6
19762: ST_TO_ADDR
19763: LD_VAR 0 2
19767: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19768: LD_INT 0
19770: PPUSH
19771: PPUSH
19772: PPUSH
// pom := GetBase ( bdepot ) ;
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: CALL_OW 274
19787: ST_TO_ADDR
// sor := [ ] ;
19788: LD_ADDR_VAR 0 4
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_VAR 0 4
19804: PUSH
19805: LD_VAR 0 3
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 275
19817: ADD
19818: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19819: LD_ADDR_VAR 0 4
19823: PUSH
19824: LD_VAR 0 4
19828: PUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 275
19841: ADD
19842: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19843: LD_ADDR_VAR 0 4
19847: PUSH
19848: LD_VAR 0 4
19852: PUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: LD_INT 3
19860: PPUSH
19861: CALL_OW 275
19865: ADD
19866: ST_TO_ADDR
// result := sor ;
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 4
19876: ST_TO_ADDR
// end ;
19877: LD_VAR 0 2
19881: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19882: LD_INT 0
19884: PPUSH
19885: PPUSH
// while ( coord_list ) do
19886: LD_VAR 0 3
19890: IFFALSE 20064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19892: LD_ADDR_EXP 48
19896: PUSH
19897: LD_EXP 48
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PUSH
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: PUSH
19930: LD_VAR 0 3
19934: PUSH
19935: LD_INT 3
19937: ARRAY
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: PPUSH
19944: CALL 41882 0 4
19948: ST_TO_ADDR
// if weapon_list then
19949: LD_VAR 0 4
19953: IFFALSE 20024
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19955: LD_ADDR_EXP 45
19959: PUSH
19960: LD_EXP 45
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: LD_VAR 0 4
19974: PUSH
19975: LD_INT 1
19977: ARRAY
19978: PPUSH
19979: LD_VAR 0 3
19983: PUSH
19984: LD_INT 1
19986: ARRAY
19987: PUSH
19988: LD_VAR 0 3
19992: PUSH
19993: LD_INT 2
19995: ARRAY
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PPUSH
20001: CALL 41882 0 4
20005: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 4
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
// end ; for i = 1 to 3 do
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: DOUBLE
20030: LD_INT 1
20032: DEC
20033: ST_TO_ADDR
20034: LD_INT 3
20036: PUSH
20037: FOR_TO
20038: IFFALSE 20060
// coord_list := Delete ( coord_list , 1 ) ;
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_VAR 0 3
20049: PPUSH
20050: LD_INT 1
20052: PPUSH
20053: CALL_OW 3
20057: ST_TO_ADDR
20058: GO 20037
20060: POP
20061: POP
// end ;
20062: GO 19886
// result := true ;
20064: LD_ADDR_VAR 0 5
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// end ;
20072: LD_VAR 0 5
20076: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20077: LD_INT 0
20079: PPUSH
20080: PPUSH
// if not weapon_list then
20081: LD_VAR 0 3
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20205
// while ( coord_list ) do
20090: LD_VAR 0 2
20094: IFFALSE 20205
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20096: LD_ADDR_EXP 45
20100: PUSH
20101: LD_EXP 45
20105: PPUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: LD_VAR 0 2
20124: PUSH
20125: LD_INT 1
20127: ARRAY
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_INT 2
20136: ARRAY
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL 41882 0 4
20146: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_VAR 0 3
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
// for i = 1 to 2 do
20165: LD_ADDR_VAR 0 5
20169: PUSH
20170: DOUBLE
20171: LD_INT 1
20173: DEC
20174: ST_TO_ADDR
20175: LD_INT 2
20177: PUSH
20178: FOR_TO
20179: IFFALSE 20201
// coord_list := Delete ( coord_list , 1 ) ;
20181: LD_ADDR_VAR 0 2
20185: PUSH
20186: LD_VAR 0 2
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 3
20198: ST_TO_ADDR
20199: GO 20178
20201: POP
20202: POP
// end ;
20203: GO 20090
// end ;
20205: LD_VAR 0 4
20209: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20210: LD_INT 0
20212: PPUSH
20213: PPUSH
// while ( coord_list ) do
20214: LD_VAR 0 2
20218: IFFALSE 20373
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20220: LD_VAR 0 2
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_INT 2
20236: ARRAY
20237: PPUSH
20238: CALL_OW 428
20242: IFFALSE 20333
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20244: LD_VAR 0 2
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_VAR 0 2
20257: PUSH
20258: LD_INT 2
20260: ARRAY
20261: PPUSH
20262: CALL_OW 428
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 31
20274: PUSH
20275: LD_INT 32
20277: PUSH
20278: LD_INT 33
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: IN
20286: IFFALSE 20333
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20288: LD_ADDR_EXP 54
20292: PUSH
20293: LD_EXP 54
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: LD_VAR 0 2
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 2
20316: PUSH
20317: LD_INT 2
20319: ARRAY
20320: PPUSH
20321: CALL_OW 428
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL 41882 0 4
20332: ST_TO_ADDR
// for i = 1 to 3 do
20333: LD_ADDR_VAR 0 4
20337: PUSH
20338: DOUBLE
20339: LD_INT 1
20341: DEC
20342: ST_TO_ADDR
20343: LD_INT 3
20345: PUSH
20346: FOR_TO
20347: IFFALSE 20369
// coord_list := Delete ( coord_list , 1 ) ;
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: CALL_OW 3
20366: ST_TO_ADDR
20367: GO 20346
20369: POP
20370: POP
// end ;
20371: GO 20214
// result := true ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// end ;
20381: LD_VAR 0 3
20385: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20386: LD_INT 0
20388: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20389: LD_ADDR_EXP 48
20393: PUSH
20394: LD_EXP 48
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: LD_INT 0
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: CALL 41882 0 4
20416: ST_TO_ADDR
// end ;
20417: LD_VAR 0 3
20421: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20422: LD_INT 0
20424: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20425: LD_ADDR_EXP 48
20429: PUSH
20430: LD_EXP 48
20434: PPUSH
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 6
20442: PPUSH
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL 41882 0 4
20452: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20453: LD_ADDR_EXP 51
20457: PUSH
20458: LD_EXP 51
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 1
20475: ARRAY
20476: PPUSH
20477: LD_VAR 0 3
20481: PUSH
20482: LD_INT 2
20484: ARRAY
20485: PPUSH
20486: CALL 41882 0 4
20490: ST_TO_ADDR
// end ;
20491: LD_VAR 0 4
20495: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20496: LD_INT 0
20498: PPUSH
20499: PPUSH
// if ext_list > 5 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 5
20507: GREATER
20508: IFFALSE 20552
// for i = 6 to ext_list do
20510: LD_ADDR_VAR 0 5
20514: PUSH
20515: DOUBLE
20516: LD_INT 6
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 3
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20550
// ext_list := Delete ( ext_list , ext_list ) ;
20528: LD_ADDR_VAR 0 3
20532: PUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: CALL_OW 3
20547: ST_TO_ADDR
20548: GO 20525
20550: POP
20551: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20552: LD_VAR 0 1
20556: PPUSH
20557: LD_VAR 0 2
20561: PUSH
20562: LD_INT 1
20564: ARRAY
20565: PPUSH
20566: LD_VAR 0 2
20570: PUSH
20571: LD_INT 2
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 3
20588: PPUSH
20589: CALL 9099 0 5
// end ;
20593: LD_VAR 0 4
20597: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
// p := 1 ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_INT 1
20610: ST_TO_ADDR
// if type_list = [ ] then
20611: LD_VAR 0 3
20615: PUSH
20616: EMPTY
20617: EQUAL
20618: IFFALSE 20628
// type_list := b_oil_power ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_INT 26
20627: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20628: LD_ADDR_VAR 0 5
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 2
20642: PUSH
20643: LD_INT 3
20645: DIVREAL
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20751
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20650: LD_ADDR_EXP 48
20654: PUSH
20655: LD_EXP 48
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 3
20669: PUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_VAR 0 3
20677: PPUSH
20678: CALL_OW 12
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 6
20693: ARRAY
20694: PUSH
20695: LD_VAR 0 2
20699: PUSH
20700: LD_VAR 0 6
20704: PUSH
20705: LD_INT 1
20707: PLUS
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 2
20722: PLUS
20723: ARRAY
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL 41882 0 4
20734: ST_TO_ADDR
// p := p + 3 ;
20735: LD_ADDR_VAR 0 6
20739: PUSH
20740: LD_VAR 0 6
20744: PUSH
20745: LD_INT 3
20747: PLUS
20748: ST_TO_ADDR
// end ;
20749: GO 20647
20751: POP
20752: POP
// end ;
20753: LD_VAR 0 4
20757: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not MREG_Deposit [ side ] then
20764: LD_EXP 63
20768: PUSH
20769: LD_VAR 0 1
20773: ARRAY
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20956
// p := 1 ;
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: DOUBLE
20793: LD_INT 1
20795: DEC
20796: ST_TO_ADDR
20797: LD_EXP 63
20801: PUSH
20802: LD_VAR 0 1
20806: ARRAY
20807: PUSH
20808: LD_INT 3
20810: DIVREAL
20811: PUSH
20812: FOR_TO
20813: IFFALSE 20954
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20815: LD_EXP 63
20819: PUSH
20820: LD_VAR 0 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 4
20830: PUSH
20831: LD_INT 2
20833: PLUS
20834: ARRAY
20835: PUSH
20836: LD_INT 2
20838: EQUAL
20839: IFFALSE 20851
// b := b_oil_mine else
20841: LD_ADDR_VAR 0 5
20845: PUSH
20846: LD_INT 29
20848: ST_TO_ADDR
20849: GO 20859
// b := b_siberite_mine ;
20851: LD_ADDR_VAR 0 5
20855: PUSH
20856: LD_INT 30
20858: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20859: LD_ADDR_EXP 48
20863: PUSH
20864: LD_EXP 48
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 5
20878: PPUSH
20879: LD_EXP 63
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: ARRAY
20895: PUSH
20896: LD_EXP 63
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: ARRAY
20916: PUSH
20917: LD_INT 0
20919: PPUSH
20920: LD_INT 5
20922: PPUSH
20923: CALL_OW 12
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: LIST
20932: PPUSH
20933: CALL 41882 0 4
20937: ST_TO_ADDR
// p := p + 3 ;
20938: LD_ADDR_VAR 0 4
20942: PUSH
20943: LD_VAR 0 4
20947: PUSH
20948: LD_INT 3
20950: PLUS
20951: ST_TO_ADDR
// end ;
20952: GO 20812
20954: POP
20955: POP
// end ;
20956: LD_VAR 0 2
20960: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20961: LD_INT 0
20963: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20964: LD_ADDR_EXP 48
20968: PUSH
20969: LD_EXP 48
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: CALL 41882 0 4
20991: ST_TO_ADDR
// end ;
20992: LD_VAR 0 3
20996: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20997: LD_INT 0
20999: PPUSH
// case nation of 1 , us :
21000: LD_VAR 0 2
21004: PUSH
21005: LD_INT 1
21007: DOUBLE
21008: EQUAL
21009: IFTRUE 21019
21011: LD_STRING us
21013: DOUBLE
21014: EQUAL
21015: IFTRUE 21019
21017: GO 21050
21019: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21020: LD_ADDR_EXP 48
21024: PUSH
21025: LD_EXP 48
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_INT 36
21037: PPUSH
21038: LD_VAR 0 3
21042: PPUSH
21043: CALL 41882 0 4
21047: ST_TO_ADDR
21048: GO 21101
21050: LD_INT 2
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21064
21056: LD_STRING ar
21058: DOUBLE
21059: EQUAL
21060: IFTRUE 21064
21062: GO 21100
21064: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21065: LD_ADDR_EXP 48
21069: PUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: LD_INT 14
21077: PUSH
21078: LD_INT 2
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: LD_INT 31
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: PPUSH
21093: CALL 21106 0 2
21097: ST_TO_ADDR
21098: GO 21101
21100: POP
// end ;
21101: LD_VAR 0 4
21105: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21106: LD_INT 0
21108: PPUSH
21109: PPUSH
// for i = 1 to list do
21110: LD_ADDR_VAR 0 4
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 2
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21176
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21128: LD_ADDR_EXP 53
21132: PUSH
21133: LD_EXP 53
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_EXP 53
21147: PUSH
21148: LD_VAR 0 1
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: PLUS
21157: PPUSH
21158: LD_VAR 0 2
21162: PUSH
21163: LD_VAR 0 4
21167: ARRAY
21168: PPUSH
21169: CALL 31052 0 4
21173: ST_TO_ADDR
21174: GO 21125
21176: POP
21177: POP
// end ;
21178: LD_VAR 0 3
21182: RET
// export function MCS_GetVehicleList ( side ) ; begin
21183: LD_INT 0
21185: PPUSH
// result := MREG_ToConstruct [ side ] ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_EXP 53
21195: PUSH
21196: LD_VAR 0 1
21200: ARRAY
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 2
21206: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21207: LD_INT 0
21209: PPUSH
21210: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21211: LD_ADDR_EXP 60
21215: PUSH
21216: LD_EXP 60
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 2
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 3
21240: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21241: LD_INT 0
21243: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21244: LD_ADDR_EXP 39
21248: PUSH
21249: LD_EXP 39
21253: PPUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_VAR 0 2
21263: PPUSH
21264: CALL_OW 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 3
21273: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21274: LD_INT 0
21276: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21277: LD_ADDR_EXP 40
21281: PUSH
21282: LD_EXP 40
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 3
21306: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21307: LD_INT 0
21309: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21310: LD_ADDR_EXP 62
21314: PUSH
21315: LD_EXP 62
21319: PPUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: LD_INT 1
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: CALL 31052 0 4
21337: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21338: LD_ADDR_EXP 62
21342: PUSH
21343: LD_EXP 62
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: LD_VAR 0 3
21360: PPUSH
21361: CALL 31052 0 4
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 4
21370: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21374: LD_ADDR_EXP 74
21378: PUSH
21379: LD_EXP 74
21383: PPUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21397: LD_ADDR_EXP 74
21401: PUSH
21402: LD_EXP 74
21406: PPUSH
21407: LD_INT 2
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21420: LD_ADDR_EXP 74
21424: PUSH
21425: LD_EXP 74
21429: PPUSH
21430: LD_INT 3
21432: PPUSH
21433: LD_VAR 0 3
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 4
21447: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
// if not side or not list then
21453: LD_VAR 0 1
21457: NOT
21458: PUSH
21459: LD_VAR 0 2
21463: NOT
21464: OR
21465: IFFALSE 21469
// exit ;
21467: GO 21637
// SetTech ( 20 , side , state_researched ) ;
21469: LD_INT 20
21471: PPUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21484: LD_ADDR_EXP 63
21488: PUSH
21489: LD_EXP 63
21493: PPUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_VAR 0 2
21503: PPUSH
21504: CALL_OW 2
21508: ST_TO_ADDR
// p := 1 ;
21509: LD_ADDR_VAR 0 5
21513: PUSH
21514: LD_INT 1
21516: ST_TO_ADDR
// for i = 1 to list / 3 do
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: DOUBLE
21523: LD_INT 1
21525: DEC
21526: ST_TO_ADDR
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 3
21534: DIVREAL
21535: PUSH
21536: FOR_TO
21537: IFFALSE 21635
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_VAR 0 5
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: LD_INT 1
21562: PLUS
21563: ARRAY
21564: PPUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_VAR 0 5
21574: PUSH
21575: LD_INT 2
21577: PLUS
21578: ARRAY
21579: PPUSH
21580: CALL 22339 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21584: LD_VAR 0 2
21588: PUSH
21589: LD_VAR 0 5
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_VAR 0 5
21604: PUSH
21605: LD_INT 1
21607: PLUS
21608: ARRAY
21609: PPUSH
21610: LD_VAR 0 1
21614: PPUSH
21615: CALL_OW 441
// p := p + 3 ;
21619: LD_ADDR_VAR 0 5
21623: PUSH
21624: LD_VAR 0 5
21628: PUSH
21629: LD_INT 3
21631: PLUS
21632: ST_TO_ADDR
// end ;
21633: GO 21536
21635: POP
21636: POP
// end ;
21637: LD_VAR 0 3
21641: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
// if nat = nation_arabian then
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 2
21653: EQUAL
21654: IFFALSE 21660
// exit else
21656: GO 21732
21658: GO 21718
// if nat = nation_american then
21660: LD_VAR 0 2
21664: PUSH
21665: LD_INT 1
21667: EQUAL
21668: IFFALSE 21695
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_INT 4
21677: PUSH
21678: LD_INT 3
21680: PUSH
21681: LD_INT 1
21683: PUSH
21684: LD_INT 8
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: ST_TO_ADDR
21693: GO 21718
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: LD_INT 24
21702: PUSH
21703: LD_INT 3
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: LD_INT 48
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21718: LD_VAR 0 1
21722: PPUSH
21723: LD_VAR 0 4
21727: PPUSH
21728: CALL 21106 0 2
// end ;
21732: LD_VAR 0 3
21736: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21741: LD_ADDR_EXP 65
21745: PUSH
21746: LD_EXP 65
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: LD_VAR 0 4
21763: PPUSH
21764: CALL 31052 0 4
21768: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21769: LD_ADDR_EXP 66
21773: PUSH
21774: LD_EXP 66
21778: PPUSH
21779: LD_VAR 0 1
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_VAR 0 2
21791: PPUSH
21792: CALL 31052 0 4
21796: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21797: LD_ADDR_EXP 67
21801: PUSH
21802: LD_EXP 67
21806: PPUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_INT 1
21814: PPUSH
21815: LD_VAR 0 3
21819: PPUSH
21820: CALL 31052 0 4
21824: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21825: LD_ADDR_EXP 68
21829: PUSH
21830: LD_EXP 68
21834: PPUSH
21835: LD_VAR 0 1
21839: PPUSH
21840: LD_INT 1
21842: PPUSH
21843: LD_VAR 0 5
21847: PPUSH
21848: CALL 31052 0 4
21852: ST_TO_ADDR
// while squad do
21853: LD_VAR 0 5
21857: IFFALSE 21950
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_VAR 0 5
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 2
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 3
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: LD_INT 4
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL 21106 0 2
// for i = 1 to 4 do
21910: LD_ADDR_VAR 0 7
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_INT 4
21922: PUSH
21923: FOR_TO
21924: IFFALSE 21946
// squad := Delete ( squad , 1 ) ;
21926: LD_ADDR_VAR 0 5
21930: PUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: LD_INT 1
21938: PPUSH
21939: CALL_OW 3
21943: ST_TO_ADDR
21944: GO 21923
21946: POP
21947: POP
// end ;
21948: GO 21853
// end ;
21950: LD_VAR 0 6
21954: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21955: LD_INT 0
21957: PPUSH
21958: PPUSH
// for i = 1 to squad do
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: DOUBLE
21965: LD_INT 1
21967: DEC
21968: ST_TO_ADDR
21969: LD_VAR 0 2
21973: PUSH
21974: FOR_TO
21975: IFFALSE 22025
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21977: LD_ADDR_EXP 71
21981: PUSH
21982: LD_EXP 71
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_EXP 71
21996: PUSH
21997: LD_VAR 0 1
22001: ARRAY
22002: PUSH
22003: LD_INT 1
22005: PLUS
22006: PPUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 4
22016: ARRAY
22017: PPUSH
22018: CALL 31052 0 4
22022: ST_TO_ADDR
22023: GO 21974
22025: POP
22026: POP
// while squad do
22027: LD_VAR 0 2
22031: IFFALSE 22124
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PUSH
22047: LD_VAR 0 2
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PUSH
22056: LD_VAR 0 2
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 4
22072: ARRAY
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: PPUSH
22080: CALL 21106 0 2
// for i = 1 to 4 do
22084: LD_ADDR_VAR 0 4
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_INT 4
22096: PUSH
22097: FOR_TO
22098: IFFALSE 22120
// squad := Delete ( squad , 1 ) ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 2
22109: PPUSH
22110: LD_INT 1
22112: PPUSH
22113: CALL_OW 3
22117: ST_TO_ADDR
22118: GO 22097
22120: POP
22121: POP
// end ;
22122: GO 22027
// end ;
22124: LD_VAR 0 3
22128: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22129: LD_INT 0
22131: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22132: LD_ADDR_EXP 64
22136: PUSH
22137: LD_EXP 64
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: CALL 31052 0 4
22159: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22160: LD_ADDR_EXP 64
22164: PUSH
22165: LD_EXP 64
22169: PPUSH
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: LD_VAR 0 3
22182: PPUSH
22183: CALL 31052 0 4
22187: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22188: LD_ADDR_EXP 64
22192: PUSH
22193: LD_EXP 64
22197: PPUSH
22198: LD_VAR 0 1
22202: PPUSH
22203: LD_INT 3
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL 31052 0 4
22215: ST_TO_ADDR
// end ; end_of_file
22216: LD_VAR 0 5
22220: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22221: LD_INT 0
22223: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22224: LD_ADDR_EXP 44
22228: PUSH
22229: LD_EXP 44
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 1
22241: PPUSH
22242: LD_VAR 0 2
22246: PPUSH
22247: CALL 31052 0 4
22251: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22252: LD_VAR 0 1
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL 11722 0 2
22263: PUSH
22264: LD_INT 1
22266: ARRAY
22267: PPUSH
22268: CALL_OW 248
22272: PUSH
22273: LD_INT 1
22275: EQUAL
22276: IFFALSE 22307
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: LD_INT 1
22291: PUSH
22292: LD_INT 14
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: PPUSH
22301: CALL 21106 0 2
22305: GO 22334
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22307: LD_VAR 0 1
22311: PPUSH
22312: LD_INT 24
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 1
22320: PUSH
22321: LD_INT 53
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL 21106 0 2
// end ;
22334: LD_VAR 0 3
22338: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22339: LD_INT 0
22341: PPUSH
// CreateDepositXY ( x , y , t ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 2
22351: PPUSH
22352: LD_VAR 0 3
22356: PPUSH
22357: CALL_OW 62
// end ;
22361: LD_VAR 0 4
22365: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22366: LD_INT 0
22368: PPUSH
22369: PPUSH
// c := 1 ;
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 1
22377: ST_TO_ADDR
// case color of red :
22378: LD_VAR 0 3
22382: PUSH
22383: LD_STRING red
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 1 ; dark-green :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
22400: GO 22688
22402: LD_STRING dark-green
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 2 ; purple :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 2
22418: ST_TO_ADDR
22419: GO 22688
22421: LD_STRING purple
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 3 ; aqua :
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 3
22437: ST_TO_ADDR
22438: GO 22688
22440: LD_STRING aqua
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22459
22448: POP
// c = 4 ; grey :
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_INT 4
22456: ST_TO_ADDR
22457: GO 22688
22459: LD_STRING grey
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22478
22467: POP
// c = 5 ; lime :
22468: LD_ADDR_VAR 0 5
22472: PUSH
22473: LD_INT 5
22475: ST_TO_ADDR
22476: GO 22688
22478: LD_STRING lime
22480: DOUBLE
22481: EQUAL
22482: IFTRUE 22486
22484: GO 22497
22486: POP
// c = 6 ; tan :
22487: LD_ADDR_VAR 0 5
22491: PUSH
22492: LD_INT 6
22494: ST_TO_ADDR
22495: GO 22688
22497: LD_STRING tan
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22516
22505: POP
// c = 7 ; pink :
22506: LD_ADDR_VAR 0 5
22510: PUSH
22511: LD_INT 7
22513: ST_TO_ADDR
22514: GO 22688
22516: LD_STRING pink
22518: DOUBLE
22519: EQUAL
22520: IFTRUE 22524
22522: GO 22535
22524: POP
// c = 8 ; green :
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_INT 8
22532: ST_TO_ADDR
22533: GO 22688
22535: LD_STRING green
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22554
22543: POP
// c = 9 ; blue :
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_INT 9
22551: ST_TO_ADDR
22552: GO 22688
22554: LD_STRING blue
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22573
22562: POP
// c = 10 ; yellow :
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_INT 10
22570: ST_TO_ADDR
22571: GO 22688
22573: LD_STRING yellow
22575: DOUBLE
22576: EQUAL
22577: IFTRUE 22581
22579: GO 22592
22581: POP
// c = 11 ; brown :
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_INT 11
22589: ST_TO_ADDR
22590: GO 22688
22592: LD_STRING brown
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22600
22598: GO 22611
22600: POP
// c = 12 ; black :
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 12
22608: ST_TO_ADDR
22609: GO 22688
22611: LD_STRING black
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22630
22619: POP
// c = 13 ; aqua2 :
22620: LD_ADDR_VAR 0 5
22624: PUSH
22625: LD_INT 13
22627: ST_TO_ADDR
22628: GO 22688
22630: LD_STRING aqua2
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22649
22638: POP
// c = 14 ; orange :
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_INT 14
22646: ST_TO_ADDR
22647: GO 22688
22649: LD_STRING orange
22651: DOUBLE
22652: EQUAL
22653: IFTRUE 22657
22655: GO 22668
22657: POP
// c = 15 ; white :
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_INT 15
22665: ST_TO_ADDR
22666: GO 22688
22668: LD_STRING white
22670: DOUBLE
22671: EQUAL
22672: IFTRUE 22676
22674: GO 22687
22676: POP
// c = 16 ; end ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_INT 16
22684: ST_TO_ADDR
22685: GO 22688
22687: POP
// if HexInfo ( x , y ) = 0 then
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_VAR 0 2
22697: PPUSH
22698: CALL_OW 428
22702: PUSH
22703: LD_INT 0
22705: EQUAL
22706: IFFALSE 22730
// PlaceEnvironment ( x , y , 58 , c ) ;
22708: LD_VAR 0 1
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: LD_INT 58
22720: PPUSH
22721: LD_VAR 0 5
22725: PPUSH
22726: CALL_OW 349
// end ;
22730: LD_VAR 0 4
22734: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22735: LD_INT 0
22737: PPUSH
// RemoveEnvironment ( x , y ) ;
22738: LD_VAR 0 1
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: CALL_OW 347
// end ;
22752: LD_VAR 0 3
22756: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22757: LD_INT 0
22759: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22760: LD_ADDR_VAR 0 5
22764: PUSH
22765: LD_INT 81
22767: PUSH
22768: LD_VAR 0 1
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 92
22779: PUSH
22780: LD_VAR 0 2
22784: PUSH
22785: LD_VAR 0 3
22789: PUSH
22790: LD_VAR 0 4
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 69
22809: ST_TO_ADDR
// end ;
22810: LD_VAR 0 5
22814: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22815: LD_INT 0
22817: PPUSH
22818: PPUSH
22819: PPUSH
22820: PPUSH
22821: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22822: LD_VAR 0 1
22826: PPUSH
22827: LD_INT 81
22829: PUSH
22830: LD_VAR 0 1
22834: PPUSH
22835: CALL_OW 255
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PPUSH
22844: CALL_OW 69
22848: PPUSH
22849: LD_VAR 0 1
22853: PPUSH
22854: CALL_OW 74
22858: PPUSH
22859: CALL_OW 119
// dir := GetDir ( un ) ;
22863: LD_ADDR_VAR 0 4
22867: PUSH
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 254
22877: ST_TO_ADDR
// dir := dir - 3 ;
22878: LD_ADDR_VAR 0 4
22882: PUSH
22883: LD_VAR 0 4
22887: PUSH
22888: LD_INT 3
22890: MINUS
22891: ST_TO_ADDR
// if dir < 0 then
22892: LD_VAR 0 4
22896: PUSH
22897: LD_INT 0
22899: LESS
22900: IFFALSE 22916
// dir := dir + 6 ;
22902: LD_ADDR_VAR 0 4
22906: PUSH
22907: LD_VAR 0 4
22911: PUSH
22912: LD_INT 6
22914: PLUS
22915: ST_TO_ADDR
// while true do
22916: LD_INT 1
22918: IFFALSE 23415
// begin coord_dist := 3 ;
22920: LD_ADDR_VAR 0 3
22924: PUSH
22925: LD_INT 3
22927: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22928: LD_ADDR_VAR 0 5
22932: PUSH
22933: LD_VAR 0 1
22937: PPUSH
22938: CALL_OW 250
22942: PPUSH
22943: LD_VAR 0 4
22947: PPUSH
22948: LD_VAR 0 3
22952: PPUSH
22953: CALL_OW 272
22957: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22958: LD_ADDR_VAR 0 6
22962: PUSH
22963: LD_VAR 0 1
22967: PPUSH
22968: CALL_OW 251
22972: PPUSH
22973: LD_VAR 0 4
22977: PPUSH
22978: LD_VAR 0 3
22982: PPUSH
22983: CALL_OW 273
22987: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22988: LD_VAR 0 1
22992: PPUSH
22993: CALL_OW 255
22997: PPUSH
22998: LD_VAR 0 1
23002: PPUSH
23003: CALL_OW 250
23007: PPUSH
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 251
23017: PPUSH
23018: LD_INT 14
23020: PPUSH
23021: CALL 22757 0 4
23025: PUSH
23026: LD_VAR 0 5
23030: PPUSH
23031: LD_VAR 0 6
23035: PPUSH
23036: CALL_OW 351
23040: OR
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 6
23051: PPUSH
23052: CALL_OW 488
23056: PUSH
23057: LD_INT 0
23059: EQUAL
23060: OR
23061: PUSH
23062: LD_VAR 0 5
23066: PPUSH
23067: LD_VAR 0 6
23071: PPUSH
23072: CALL_OW 546
23076: PUSH
23077: LD_INT 1
23079: EQUAL
23080: OR
23081: PUSH
23082: LD_VAR 0 5
23086: PPUSH
23087: LD_VAR 0 6
23091: PPUSH
23092: CALL_OW 428
23096: PUSH
23097: LD_INT 0
23099: NONEQUAL
23100: OR
23101: IFFALSE 23329
// begin repeat begin Wait ( 0 0$0.3 ) ;
23103: LD_INT 10
23105: PPUSH
23106: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23110: LD_ADDR_VAR 0 3
23114: PUSH
23115: LD_VAR 0 3
23119: PUSH
23120: LD_INT 1
23122: PLUS
23123: ST_TO_ADDR
// dir := dir + 1 ;
23124: LD_ADDR_VAR 0 4
23128: PUSH
23129: LD_VAR 0 4
23133: PUSH
23134: LD_INT 1
23136: PLUS
23137: ST_TO_ADDR
// if dir > 5 then
23138: LD_VAR 0 4
23142: PUSH
23143: LD_INT 5
23145: GREATER
23146: IFFALSE 23156
// dir = 0 ;
23148: LD_ADDR_VAR 0 4
23152: PUSH
23153: LD_INT 0
23155: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23156: LD_ADDR_VAR 0 5
23160: PUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: CALL_OW 250
23170: PPUSH
23171: LD_VAR 0 4
23175: PPUSH
23176: LD_VAR 0 3
23180: PPUSH
23181: CALL_OW 272
23185: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23186: LD_ADDR_VAR 0 6
23190: PUSH
23191: LD_VAR 0 1
23195: PPUSH
23196: CALL_OW 251
23200: PPUSH
23201: LD_VAR 0 4
23205: PPUSH
23206: LD_VAR 0 3
23210: PPUSH
23211: CALL_OW 273
23215: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23216: LD_VAR 0 1
23220: PPUSH
23221: CALL_OW 255
23225: PPUSH
23226: LD_VAR 0 1
23230: PPUSH
23231: CALL_OW 250
23235: PPUSH
23236: LD_VAR 0 1
23240: PPUSH
23241: CALL_OW 251
23245: PPUSH
23246: LD_INT 14
23248: PPUSH
23249: CALL 22757 0 4
23253: NOT
23254: PUSH
23255: LD_VAR 0 5
23259: PPUSH
23260: LD_VAR 0 6
23264: PPUSH
23265: CALL_OW 351
23269: NOT
23270: AND
23271: PUSH
23272: LD_VAR 0 5
23276: PPUSH
23277: LD_VAR 0 6
23281: PPUSH
23282: CALL_OW 488
23286: AND
23287: PUSH
23288: LD_VAR 0 5
23292: PPUSH
23293: LD_VAR 0 6
23297: PPUSH
23298: CALL_OW 546
23302: PUSH
23303: LD_INT 0
23305: EQUAL
23306: AND
23307: PUSH
23308: LD_VAR 0 5
23312: PPUSH
23313: LD_VAR 0 6
23317: PPUSH
23318: CALL_OW 428
23322: PUSH
23323: LD_INT 0
23325: EQUAL
23326: AND
23327: IFFALSE 23103
// end ; ComMoveXY ( un , x , y ) ;
23329: LD_VAR 0 1
23333: PPUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 111
// Wait ( 0 0$1 ) ;
23348: LD_INT 35
23350: PPUSH
23351: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23355: LD_VAR 0 1
23359: PPUSH
23360: LD_INT 81
23362: PUSH
23363: LD_VAR 0 1
23367: PPUSH
23368: CALL_OW 255
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PPUSH
23377: CALL_OW 69
23381: PPUSH
23382: LD_VAR 0 1
23386: PPUSH
23387: CALL_OW 74
23391: PPUSH
23392: CALL_OW 296
23396: PUSH
23397: LD_INT 14
23399: GREATEREQUAL
23400: IFFALSE 23413
// begin ComStop ( un ) ;
23402: LD_VAR 0 1
23406: PPUSH
23407: CALL_OW 141
// break ;
23411: GO 23415
// end ; end ;
23413: GO 22916
// end ;
23415: LD_VAR 0 2
23419: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23420: LD_INT 0
23422: PPUSH
23423: PPUSH
23424: PPUSH
23425: PPUSH
23426: PPUSH
23427: PPUSH
23428: PPUSH
23429: PPUSH
// x := GetX ( unit ) ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_VAR 0 1
23439: PPUSH
23440: CALL_OW 250
23444: ST_TO_ADDR
// y := GetY ( unit ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: CALL_OW 251
23459: ST_TO_ADDR
// i := 0 ;
23460: LD_ADDR_VAR 0 8
23464: PUSH
23465: LD_INT 0
23467: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23468: LD_VAR 0 1
23472: PPUSH
23473: LD_INT 81
23475: PUSH
23476: LD_VAR 0 1
23480: PPUSH
23481: CALL_OW 255
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PPUSH
23490: CALL_OW 69
23494: PPUSH
23495: LD_VAR 0 1
23499: PPUSH
23500: CALL_OW 74
23504: PPUSH
23505: CALL_OW 119
// dir := GetDir ( unit ) ;
23509: LD_ADDR_VAR 0 7
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 254
23523: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23524: LD_ADDR_VAR 0 9
23528: PUSH
23529: LD_INT 0
23531: PPUSH
23532: LD_INT 1
23534: PPUSH
23535: CALL_OW 12
23539: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23540: LD_INT 10
23542: PPUSH
23543: CALL_OW 67
// if mode then
23547: LD_VAR 0 9
23551: IFFALSE 23569
// dir := dir + 1 else
23553: LD_ADDR_VAR 0 7
23557: PUSH
23558: LD_VAR 0 7
23562: PUSH
23563: LD_INT 1
23565: PLUS
23566: ST_TO_ADDR
23567: GO 23583
// dir := dir - 1 ;
23569: LD_ADDR_VAR 0 7
23573: PUSH
23574: LD_VAR 0 7
23578: PUSH
23579: LD_INT 1
23581: MINUS
23582: ST_TO_ADDR
// if ( dir < 0 ) then
23583: LD_VAR 0 7
23587: PUSH
23588: LD_INT 0
23590: LESS
23591: IFFALSE 23601
// dir := 5 ;
23593: LD_ADDR_VAR 0 7
23597: PUSH
23598: LD_INT 5
23600: ST_TO_ADDR
// if ( dir > 5 ) then
23601: LD_VAR 0 7
23605: PUSH
23606: LD_INT 5
23608: GREATER
23609: IFFALSE 23619
// dir := 0 ;
23611: LD_ADDR_VAR 0 7
23615: PUSH
23616: LD_INT 0
23618: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23619: LD_ADDR_VAR 0 5
23623: PUSH
23624: LD_VAR 0 3
23628: PPUSH
23629: LD_VAR 0 7
23633: PPUSH
23634: LD_INT 4
23636: PPUSH
23637: CALL_OW 272
23641: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23642: LD_ADDR_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: PPUSH
23652: LD_VAR 0 7
23656: PPUSH
23657: LD_INT 4
23659: PPUSH
23660: CALL_OW 273
23664: ST_TO_ADDR
// i := i + 1 ;
23665: LD_ADDR_VAR 0 8
23669: PUSH
23670: LD_VAR 0 8
23674: PUSH
23675: LD_INT 1
23677: PLUS
23678: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23679: LD_VAR 0 1
23683: PPUSH
23684: CALL_OW 255
23688: PPUSH
23689: LD_VAR 0 5
23693: PPUSH
23694: LD_VAR 0 6
23698: PPUSH
23699: LD_INT 14
23701: PPUSH
23702: CALL 22757 0 4
23706: PUSH
23707: LD_INT 0
23709: EQUAL
23710: PUSH
23711: LD_VAR 0 5
23715: PPUSH
23716: LD_VAR 0 6
23720: PPUSH
23721: CALL_OW 546
23725: PUSH
23726: LD_INT 0
23728: EQUAL
23729: AND
23730: PUSH
23731: LD_VAR 0 5
23735: PPUSH
23736: LD_VAR 0 6
23740: PPUSH
23741: CALL_OW 428
23745: PUSH
23746: LD_INT 0
23748: EQUAL
23749: AND
23750: IFFALSE 23754
// break ;
23752: GO 23764
// end until i > 4 ;
23754: LD_VAR 0 8
23758: PUSH
23759: LD_INT 4
23761: GREATER
23762: IFFALSE 23540
// if x2 and y2 then
23764: LD_VAR 0 5
23768: PUSH
23769: LD_VAR 0 6
23773: AND
23774: IFFALSE 23797
// result := [ x2 , y2 ] else
23776: LD_ADDR_VAR 0 2
23780: PUSH
23781: LD_VAR 0 5
23785: PUSH
23786: LD_VAR 0 6
23790: PUSH
23791: EMPTY
23792: LIST
23793: LIST
23794: ST_TO_ADDR
23795: GO 23826
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23797: LD_ADDR_VAR 0 2
23801: PUSH
23802: LD_VAR 0 1
23806: PPUSH
23807: CALL_OW 250
23811: PUSH
23812: LD_VAR 0 1
23816: PPUSH
23817: CALL_OW 251
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: ST_TO_ADDR
// end ;
23826: LD_VAR 0 2
23830: RET
// export function MCT_Hex ( x , y ) ; begin
23831: LD_INT 0
23833: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: LD_VAR 0 2
23848: PPUSH
23849: CALL_OW 546
23853: PUSH
23854: LD_VAR 0 1
23858: PPUSH
23859: LD_VAR 0 2
23863: PPUSH
23864: CALL_OW 428
23868: PUSH
23869: EMPTY
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: ST_TO_ADDR
// end ;
23876: LD_VAR 0 3
23880: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23881: LD_INT 0
23883: PPUSH
23884: PPUSH
23885: PPUSH
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
23892: PPUSH
23893: PPUSH
23894: PPUSH
23895: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23896: LD_ADDR_VAR 0 10
23900: PUSH
23901: LD_EXP 62
23905: PUSH
23906: LD_VAR 0 1
23910: ARRAY
23911: PUSH
23912: LD_INT 1
23914: ARRAY
23915: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23916: LD_ADDR_VAR 0 11
23920: PUSH
23921: LD_EXP 62
23925: PUSH
23926: LD_VAR 0 1
23930: ARRAY
23931: PUSH
23932: LD_INT 2
23934: ARRAY
23935: ST_TO_ADDR
// collectors := [ ] ;
23936: LD_ADDR_VAR 0 12
23940: PUSH
23941: EMPTY
23942: ST_TO_ADDR
// is_cargo := false ;
23943: LD_ADDR_VAR 0 13
23947: PUSH
23948: LD_INT 0
23950: ST_TO_ADDR
// if isTest then
23951: LD_EXP 1
23955: IFFALSE 23961
// TimerStart ( ) ;
23957: CALL_OW 548
// if MCF_Cargo ( side ) then
23961: LD_VAR 0 1
23965: PPUSH
23966: CALL 11938 0 1
23970: IFFALSE 23997
// begin collectors := MCF_Cargo ( side ) ;
23972: LD_ADDR_VAR 0 12
23976: PUSH
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL 11938 0 1
23986: ST_TO_ADDR
// is_cargo := true ;
23987: LD_ADDR_VAR 0 13
23991: PUSH
23992: LD_INT 1
23994: ST_TO_ADDR
// end else
23995: GO 24146
// begin if MCF_ApeSpec ( side , engineer ) then
23997: LD_VAR 0 1
24001: PPUSH
24002: LD_STRING engineer
24004: PPUSH
24005: CALL 12084 0 2
24009: IFFALSE 24029
// collectors := MCF_ApeSpec ( side , engineer ) ;
24011: LD_ADDR_VAR 0 12
24015: PUSH
24016: LD_VAR 0 1
24020: PPUSH
24021: LD_STRING engineer
24023: PPUSH
24024: CALL 12084 0 2
24028: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24029: LD_VAR 0 1
24033: PPUSH
24034: LD_INT 2
24036: PPUSH
24037: EMPTY
24038: PPUSH
24039: CALL 11670 0 3
24043: IFFALSE 24146
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24045: LD_ADDR_VAR 0 7
24049: PUSH
24050: LD_VAR 0 1
24054: PPUSH
24055: LD_INT 2
24057: PPUSH
24058: EMPTY
24059: PPUSH
24060: CALL 11670 0 3
24064: ST_TO_ADDR
// if z > 5 then
24065: LD_VAR 0 7
24069: PUSH
24070: LD_INT 5
24072: GREATER
24073: IFFALSE 24085
// t1 := 5 else
24075: LD_ADDR_VAR 0 8
24079: PUSH
24080: LD_INT 5
24082: ST_TO_ADDR
24083: GO 24095
// t1 := z ;
24085: LD_ADDR_VAR 0 8
24089: PUSH
24090: LD_VAR 0 7
24094: ST_TO_ADDR
// for t2 = 1 to t1 do
24095: LD_ADDR_VAR 0 9
24099: PUSH
24100: DOUBLE
24101: LD_INT 1
24103: DEC
24104: ST_TO_ADDR
24105: LD_VAR 0 8
24109: PUSH
24110: FOR_TO
24111: IFFALSE 24144
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24113: LD_ADDR_VAR 0 12
24117: PUSH
24118: LD_VAR 0 12
24122: PPUSH
24123: LD_INT 1
24125: PPUSH
24126: LD_VAR 0 7
24130: PUSH
24131: LD_VAR 0 9
24135: ARRAY
24136: PPUSH
24137: CALL_OW 2
24141: ST_TO_ADDR
24142: GO 24110
24144: POP
24145: POP
// end ; end ; if not mode then
24146: LD_VAR 0 10
24150: NOT
24151: IFFALSE 24157
// exit else
24153: GO 24416
24155: GO 24416
// begin if collectors then
24157: LD_VAR 0 12
24161: IFFALSE 24416
// for i in areas do
24163: LD_ADDR_VAR 0 3
24167: PUSH
24168: LD_VAR 0 11
24172: PUSH
24173: FOR_IN
24174: IFFALSE 24414
// if GetListOfCratesInArea ( i ) then
24176: LD_VAR 0 3
24180: PPUSH
24181: CALL_OW 435
24185: IFFALSE 24412
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24187: LD_ADDR_VAR 0 5
24191: PUSH
24192: LD_VAR 0 3
24196: PPUSH
24197: CALL_OW 435
24201: PUSH
24202: LD_INT 1
24204: ARRAY
24205: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24206: LD_ADDR_VAR 0 6
24210: PUSH
24211: LD_VAR 0 3
24215: PPUSH
24216: CALL_OW 435
24220: PUSH
24221: LD_INT 2
24223: ARRAY
24224: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24225: LD_VAR 0 13
24229: PUSH
24230: LD_VAR 0 12
24234: PUSH
24235: LD_INT 1
24237: ARRAY
24238: PPUSH
24239: CALL_OW 110
24243: PUSH
24244: LD_INT 0
24246: EQUAL
24247: AND
24248: IFFALSE 24310
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24250: LD_VAR 0 12
24254: PUSH
24255: LD_INT 1
24257: ARRAY
24258: PPUSH
24259: CALL_OW 314
24263: NOT
24264: PUSH
24265: LD_VAR 0 12
24269: PUSH
24270: LD_INT 1
24272: ARRAY
24273: PPUSH
24274: CALL_OW 110
24278: PUSH
24279: LD_INT 0
24281: EQUAL
24282: AND
24283: IFFALSE 24308
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24285: LD_VAR 0 12
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 5
24298: PPUSH
24299: LD_VAR 0 6
24303: PPUSH
24304: CALL_OW 117
// end ; end else
24308: GO 24396
// begin for j = 1 to collectors do
24310: LD_ADDR_VAR 0 4
24314: PUSH
24315: DOUBLE
24316: LD_INT 1
24318: DEC
24319: ST_TO_ADDR
24320: LD_VAR 0 12
24324: PUSH
24325: FOR_TO
24326: IFFALSE 24394
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24328: LD_VAR 0 12
24332: PUSH
24333: LD_VAR 0 4
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_VAR 0 4
24354: ARRAY
24355: PPUSH
24356: CALL_OW 110
24360: PUSH
24361: LD_INT 0
24363: EQUAL
24364: AND
24365: IFFALSE 24392
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24367: LD_VAR 0 12
24371: PUSH
24372: LD_VAR 0 4
24376: ARRAY
24377: PPUSH
24378: LD_VAR 0 5
24382: PPUSH
24383: LD_VAR 0 6
24387: PPUSH
24388: CALL 24787 0 3
// end ;
24392: GO 24325
24394: POP
24395: POP
// end ; if isTest then
24396: LD_EXP 1
24400: IFFALSE 24412
// begin debug_time := TimerEnd ( ) ;
24402: LD_ADDR_VAR 0 14
24406: PUSH
24407: CALL_OW 549
24411: ST_TO_ADDR
// end ; end ;
24412: GO 24173
24414: POP
24415: POP
// end ; end ;
24416: LD_VAR 0 2
24420: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24421: LD_INT 0
24423: PPUSH
24424: PPUSH
24425: PPUSH
24426: PPUSH
24427: PPUSH
24428: PPUSH
// if not area then
24429: LD_VAR 0 1
24433: NOT
24434: IFFALSE 24440
// exit else
24436: GO 24702
24438: GO 24702
// if tick mod interval = 0 and Prob ( percent ) then
24440: LD_OWVAR 1
24444: PUSH
24445: LD_VAR 0 4
24449: MOD
24450: PUSH
24451: LD_INT 0
24453: EQUAL
24454: PUSH
24455: LD_VAR 0 3
24459: PPUSH
24460: CALL_OW 13
24464: AND
24465: IFFALSE 24702
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24467: LD_VAR 0 1
24471: PPUSH
24472: CALL_OW 435
24476: PUSH
24477: LD_VAR 0 5
24481: LESS
24482: PUSH
24483: LD_VAR 0 5
24487: PUSH
24488: LD_INT 0
24490: EQUAL
24491: OR
24492: IFFALSE 24702
// begin Randomize ;
24494: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24498: LD_ADDR_VAR 0 7
24502: PUSH
24503: LD_INT 1
24505: PPUSH
24506: LD_VAR 0 2
24510: PPUSH
24511: CALL_OW 12
24515: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24516: LD_ADDR_VAR 0 9
24520: PUSH
24521: LD_VAR 0 1
24525: PPUSH
24526: LD_INT 0
24528: PPUSH
24529: CALL_OW 517
24533: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24534: LD_ADDR_VAR 0 8
24538: PUSH
24539: LD_INT 1
24541: PPUSH
24542: LD_VAR 0 9
24546: PUSH
24547: LD_INT 1
24549: ARRAY
24550: PPUSH
24551: CALL_OW 12
24555: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24556: LD_VAR 0 9
24560: PUSH
24561: LD_INT 1
24563: ARRAY
24564: PUSH
24565: LD_VAR 0 8
24569: ARRAY
24570: PPUSH
24571: LD_VAR 0 9
24575: PUSH
24576: LD_INT 2
24578: ARRAY
24579: PUSH
24580: LD_VAR 0 8
24584: ARRAY
24585: PPUSH
24586: CALL_OW 428
24590: PUSH
24591: LD_INT 0
24593: GREATER
24594: PUSH
24595: LD_VAR 0 9
24599: PUSH
24600: LD_INT 1
24602: ARRAY
24603: PUSH
24604: LD_VAR 0 8
24608: ARRAY
24609: PPUSH
24610: LD_VAR 0 9
24614: PUSH
24615: LD_INT 2
24617: ARRAY
24618: PUSH
24619: LD_VAR 0 8
24623: ARRAY
24624: PPUSH
24625: CALL_OW 284
24629: PUSH
24630: LD_INT 0
24632: GREATER
24633: AND
24634: IFFALSE 24660
// c := Rand ( 1 , tmp [ 1 ] ) ;
24636: LD_ADDR_VAR 0 8
24640: PUSH
24641: LD_INT 1
24643: PPUSH
24644: LD_VAR 0 9
24648: PUSH
24649: LD_INT 1
24651: ARRAY
24652: PPUSH
24653: CALL_OW 12
24657: ST_TO_ADDR
24658: GO 24556
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24660: LD_VAR 0 7
24664: PPUSH
24665: LD_VAR 0 9
24669: PUSH
24670: LD_INT 1
24672: ARRAY
24673: PUSH
24674: LD_VAR 0 8
24678: ARRAY
24679: PPUSH
24680: LD_VAR 0 9
24684: PUSH
24685: LD_INT 2
24687: ARRAY
24688: PUSH
24689: LD_VAR 0 8
24693: ARRAY
24694: PPUSH
24695: LD_INT 1
24697: PPUSH
24698: CALL_OW 54
// end ; end ; end ;
24702: LD_VAR 0 6
24706: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24707: LD_INT 0
24709: PPUSH
24710: PPUSH
// if not MREG_Crates then
24711: LD_EXP 36
24715: NOT
24716: IFFALSE 24720
// exit ;
24718: GO 24782
// for i = MREG_Crates downto 1 do
24720: LD_ADDR_VAR 0 2
24724: PUSH
24725: DOUBLE
24726: LD_EXP 36
24730: INC
24731: ST_TO_ADDR
24732: LD_INT 1
24734: PUSH
24735: FOR_DOWNTO
24736: IFFALSE 24780
// if MREG_Crates [ i ] [ 3 ] = 0 then
24738: LD_EXP 36
24742: PUSH
24743: LD_VAR 0 2
24747: ARRAY
24748: PUSH
24749: LD_INT 3
24751: ARRAY
24752: PUSH
24753: LD_INT 0
24755: EQUAL
24756: IFFALSE 24778
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24758: LD_ADDR_EXP 36
24762: PUSH
24763: LD_EXP 36
24767: PPUSH
24768: LD_VAR 0 2
24772: PPUSH
24773: CALL_OW 3
24777: ST_TO_ADDR
24778: GO 24735
24780: POP
24781: POP
// end ;
24782: LD_VAR 0 1
24786: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
24791: PPUSH
24792: PPUSH
// if not unit then
24793: LD_VAR 0 1
24797: NOT
24798: IFFALSE 24802
// exit ;
24800: GO 24937
// if HasTask ( unit ) or not CanCarry ( unit ) then
24802: LD_VAR 0 1
24806: PPUSH
24807: CALL_OW 314
24811: PUSH
24812: LD_VAR 0 1
24816: PPUSH
24817: CALL_OW 280
24821: NOT
24822: OR
24823: IFFALSE 24827
// exit ;
24825: GO 24937
// side := GetSide ( unit ) ;
24827: LD_ADDR_VAR 0 6
24831: PUSH
24832: LD_VAR 0 1
24836: PPUSH
24837: CALL_OW 255
24841: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24842: LD_ADDR_VAR 0 7
24846: PUSH
24847: LD_VAR 0 6
24851: PPUSH
24852: LD_INT 30
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PPUSH
24862: CALL 11587 0 2
24866: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24867: LD_VAR 0 1
24871: PPUSH
24872: CALL_OW 281
24876: PUSH
24877: LD_VAR 0 7
24881: NOT
24882: OR
24883: IFFALSE 24889
// exit else
24885: GO 24937
24887: GO 24937
// if GetResourceAmountXY ( x , y ) then
24889: LD_VAR 0 2
24893: PPUSH
24894: LD_VAR 0 3
24898: PPUSH
24899: CALL_OW 284
24903: IFFALSE 24935
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24905: LD_VAR 0 1
24909: PPUSH
24910: LD_VAR 0 2
24914: PPUSH
24915: LD_VAR 0 3
24919: PPUSH
24920: LD_VAR 0 7
24924: PUSH
24925: LD_INT 1
24927: ARRAY
24928: PPUSH
24929: CALL 31983 0 4
// end else
24933: GO 24937
// exit ;
24935: GO 24937
// end ;
24937: LD_VAR 0 4
24941: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24942: LD_INT 0
24944: PPUSH
24945: PPUSH
24946: PPUSH
24947: PPUSH
24948: PPUSH
// result := [ ] ;
24949: LD_ADDR_VAR 0 2
24953: PUSH
24954: EMPTY
24955: ST_TO_ADDR
// p := 1 ;
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: LD_INT 1
24963: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24964: LD_ADDR_VAR 0 3
24968: PUSH
24969: DOUBLE
24970: LD_INT 1
24972: DEC
24973: ST_TO_ADDR
24974: LD_EXP 65
24978: PUSH
24979: LD_VAR 0 1
24983: ARRAY
24984: PUSH
24985: LD_INT 1
24987: ARRAY
24988: PUSH
24989: LD_INT 2
24991: DIVREAL
24992: PUSH
24993: FOR_TO
24994: IFFALSE 25118
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24996: LD_ADDR_VAR 0 5
25000: PUSH
25001: LD_INT 81
25003: PUSH
25004: LD_VAR 0 1
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 92
25015: PUSH
25016: LD_EXP 65
25020: PUSH
25021: LD_VAR 0 1
25025: ARRAY
25026: PUSH
25027: LD_INT 1
25029: ARRAY
25030: PUSH
25031: LD_VAR 0 4
25035: ARRAY
25036: PUSH
25037: LD_EXP 65
25041: PUSH
25042: LD_VAR 0 1
25046: ARRAY
25047: PUSH
25048: LD_INT 1
25050: ARRAY
25051: PUSH
25052: LD_VAR 0 4
25056: PUSH
25057: LD_INT 1
25059: PLUS
25060: ARRAY
25061: PUSH
25062: LD_INT 12
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: LIST
25069: LIST
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PPUSH
25075: CALL_OW 69
25079: ST_TO_ADDR
// if tmp then
25080: LD_VAR 0 5
25084: IFFALSE 25102
// result := result union tmp ;
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_VAR 0 2
25095: PUSH
25096: LD_VAR 0 5
25100: UNION
25101: ST_TO_ADDR
// p := p + 2 ;
25102: LD_ADDR_VAR 0 4
25106: PUSH
25107: LD_VAR 0 4
25111: PUSH
25112: LD_INT 2
25114: PLUS
25115: ST_TO_ADDR
// end ;
25116: GO 24993
25118: POP
25119: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25120: LD_EXP 66
25124: PUSH
25125: LD_VAR 0 1
25129: ARRAY
25130: PPUSH
25131: LD_INT 81
25133: PUSH
25134: LD_VAR 0 1
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PPUSH
25143: CALL_OW 70
25147: IFFALSE 25188
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25149: LD_ADDR_VAR 0 2
25153: PUSH
25154: LD_VAR 0 2
25158: PUSH
25159: LD_EXP 66
25163: PUSH
25164: LD_VAR 0 1
25168: ARRAY
25169: PPUSH
25170: LD_INT 81
25172: PUSH
25173: LD_VAR 0 1
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PPUSH
25182: CALL_OW 70
25186: UNION
25187: ST_TO_ADDR
// end ; end_of_file
25188: LD_VAR 0 2
25192: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25193: LD_INT 0
25195: PPUSH
25196: PPUSH
25197: PPUSH
// pom := GetBase ( fac ) ;
25198: LD_ADDR_VAR 0 5
25202: PUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 274
25212: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25213: LD_ADDR_VAR 0 4
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_INT 1
25225: ARRAY
25226: PPUSH
25227: LD_VAR 0 2
25231: PUSH
25232: LD_INT 2
25234: ARRAY
25235: PPUSH
25236: LD_VAR 0 2
25240: PUSH
25241: LD_INT 3
25243: ARRAY
25244: PPUSH
25245: LD_VAR 0 2
25249: PUSH
25250: LD_INT 4
25252: ARRAY
25253: PPUSH
25254: CALL_OW 449
25258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25259: LD_ADDR_VAR 0 3
25263: PUSH
25264: LD_VAR 0 5
25268: PPUSH
25269: LD_INT 1
25271: PPUSH
25272: CALL_OW 275
25276: PUSH
25277: LD_VAR 0 4
25281: PUSH
25282: LD_INT 1
25284: ARRAY
25285: GREATEREQUAL
25286: PUSH
25287: LD_VAR 0 5
25291: PPUSH
25292: LD_INT 2
25294: PPUSH
25295: CALL_OW 275
25299: PUSH
25300: LD_VAR 0 4
25304: PUSH
25305: LD_INT 2
25307: ARRAY
25308: GREATEREQUAL
25309: AND
25310: PUSH
25311: LD_VAR 0 5
25315: PPUSH
25316: LD_INT 3
25318: PPUSH
25319: CALL_OW 275
25323: PUSH
25324: LD_VAR 0 4
25328: PUSH
25329: LD_INT 3
25331: ARRAY
25332: GREATEREQUAL
25333: AND
25334: ST_TO_ADDR
// end ;
25335: LD_VAR 0 3
25339: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25340: LD_INT 0
25342: PPUSH
25343: PPUSH
25344: PPUSH
// result := false ;
25345: LD_ADDR_VAR 0 3
25349: PUSH
25350: LD_INT 0
25352: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25353: LD_ADDR_VAR 0 4
25357: PUSH
25358: LD_EXP 53
25362: PUSH
25363: LD_VAR 0 1
25367: ARRAY
25368: ST_TO_ADDR
// if tmp then
25369: LD_VAR 0 4
25373: IFFALSE 25427
// for i = 1 to tmp do
25375: LD_ADDR_VAR 0 5
25379: PUSH
25380: DOUBLE
25381: LD_INT 1
25383: DEC
25384: ST_TO_ADDR
25385: LD_VAR 0 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25425
// if component = tmp [ i ] then
25393: LD_VAR 0 2
25397: PUSH
25398: LD_VAR 0 4
25402: PUSH
25403: LD_VAR 0 5
25407: ARRAY
25408: EQUAL
25409: IFFALSE 25423
// begin result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// exit ;
25419: POP
25420: POP
25421: GO 25427
// end ;
25423: GO 25390
25425: POP
25426: POP
// end ;
25427: LD_VAR 0 3
25431: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25432: LD_INT 0
25434: PPUSH
25435: PPUSH
25436: PPUSH
// result := false ;
25437: LD_ADDR_VAR 0 4
25441: PUSH
25442: LD_INT 0
25444: ST_TO_ADDR
// if fac then
25445: LD_VAR 0 2
25449: IFFALSE 25672
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25451: LD_VAR 0 2
25455: PPUSH
25456: LD_VAR 0 3
25460: PPUSH
25461: CALL 25193 0 2
25465: PUSH
25466: LD_VAR 0 2
25470: PPUSH
25471: CALL_OW 461
25475: PUSH
25476: LD_INT 2
25478: EQUAL
25479: AND
25480: PUSH
25481: LD_VAR 0 2
25485: PPUSH
25486: LD_VAR 0 3
25490: PUSH
25491: LD_INT 1
25493: ARRAY
25494: PPUSH
25495: LD_VAR 0 3
25499: PUSH
25500: LD_INT 2
25502: ARRAY
25503: PPUSH
25504: LD_VAR 0 3
25508: PUSH
25509: LD_INT 3
25511: ARRAY
25512: PPUSH
25513: LD_VAR 0 3
25517: PUSH
25518: LD_INT 4
25520: ARRAY
25521: PPUSH
25522: CALL_OW 448
25526: AND
25527: IFFALSE 25672
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25529: LD_VAR 0 2
25533: PPUSH
25534: LD_VAR 0 3
25538: PUSH
25539: LD_INT 1
25541: ARRAY
25542: PPUSH
25543: LD_VAR 0 3
25547: PUSH
25548: LD_INT 2
25550: ARRAY
25551: PPUSH
25552: LD_VAR 0 3
25556: PUSH
25557: LD_INT 3
25559: ARRAY
25560: PPUSH
25561: LD_VAR 0 3
25565: PUSH
25566: LD_INT 4
25568: ARRAY
25569: PPUSH
25570: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25574: LD_ADDR_VAR 0 6
25578: PUSH
25579: LD_EXP 53
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: ST_TO_ADDR
// for i = 4 downto 1 do
25590: LD_ADDR_VAR 0 5
25594: PUSH
25595: DOUBLE
25596: LD_INT 4
25598: INC
25599: ST_TO_ADDR
25600: LD_INT 1
25602: PUSH
25603: FOR_DOWNTO
25604: IFFALSE 25637
// tab := Remove ( tab , list [ i ] , true ) ;
25606: LD_ADDR_VAR 0 6
25610: PUSH
25611: LD_VAR 0 6
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_VAR 0 5
25625: ARRAY
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL 31211 0 3
25634: ST_TO_ADDR
25635: GO 25603
25637: POP
25638: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25639: LD_ADDR_EXP 53
25643: PUSH
25644: LD_EXP 53
25648: PPUSH
25649: LD_VAR 0 1
25653: PPUSH
25654: LD_VAR 0 6
25658: PPUSH
25659: CALL_OW 1
25663: ST_TO_ADDR
// result := true ;
25664: LD_ADDR_VAR 0 4
25668: PUSH
25669: LD_INT 1
25671: ST_TO_ADDR
// end ; end ; end ;
25672: LD_VAR 0 4
25676: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25677: LD_INT 0
25679: PPUSH
25680: PPUSH
// if not veh then
25681: LD_VAR 0 2
25685: NOT
25686: IFFALSE 25690
// exit ;
25688: GO 25864
// if MREG_Parking [ side ] then
25690: LD_EXP 60
25694: PUSH
25695: LD_VAR 0 1
25699: ARRAY
25700: IFFALSE 25864
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25702: LD_VAR 0 2
25706: PPUSH
25707: LD_EXP 60
25711: PUSH
25712: LD_VAR 0 1
25716: ARRAY
25717: PPUSH
25718: CALL_OW 308
25722: NOT
25723: IFFALSE 25864
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25725: LD_VAR 0 2
25729: PPUSH
25730: LD_EXP 60
25734: PUSH
25735: LD_VAR 0 1
25739: ARRAY
25740: PPUSH
25741: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25745: LD_VAR 0 2
25749: PPUSH
25750: CALL_OW 263
25754: PUSH
25755: LD_INT 1
25757: EQUAL
25758: IFFALSE 25864
// begin i := GetDriver ( veh ) ;
25760: LD_ADDR_VAR 0 4
25764: PUSH
25765: LD_VAR 0 2
25769: PPUSH
25770: CALL 31695 0 1
25774: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25775: LD_INT 35
25777: PPUSH
25778: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 60
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: PUSH
25803: LD_VAR 0 2
25807: PPUSH
25808: CALL_OW 301
25812: OR
25813: IFFALSE 25775
// ComExitVehicle ( i ) ;
25815: LD_VAR 0 4
25819: PPUSH
25820: CALL_OW 121
// Wait ( 1 ) ;
25824: LD_INT 1
25826: PPUSH
25827: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25831: LD_VAR 0 4
25835: PPUSH
25836: LD_VAR 0 1
25840: PPUSH
25841: LD_INT 30
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PPUSH
25851: CALL 11587 0 2
25855: PUSH
25856: LD_INT 1
25858: ARRAY
25859: PPUSH
25860: CALL_OW 180
// end ; end ; end ;
25864: LD_VAR 0 3
25868: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25869: LD_INT 0
25871: PPUSH
25872: PPUSH
25873: PPUSH
25874: PPUSH
25875: PPUSH
25876: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25877: LD_VAR 0 1
25881: PPUSH
25882: LD_INT 30
25884: PUSH
25885: LD_INT 3
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PPUSH
25892: CALL 11587 0 2
25896: IFFALSE 26080
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25898: LD_VAR 0 1
25902: PPUSH
25903: LD_INT 30
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL 11587 0 2
25917: PUSH
25918: LD_INT 1
25920: ARRAY
25921: PPUSH
25922: CALL_OW 461
25926: PUSH
25927: LD_INT 2
25929: EQUAL
25930: IFFALSE 26080
// begin for i = 1 to MREG_TurretWeapon do
25932: LD_ADDR_VAR 0 3
25936: PUSH
25937: DOUBLE
25938: LD_INT 1
25940: DEC
25941: ST_TO_ADDR
25942: LD_EXP 45
25946: PUSH
25947: FOR_TO
25948: IFFALSE 26078
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25950: LD_EXP 45
25954: PUSH
25955: LD_VAR 0 3
25959: ARRAY
25960: PUSH
25961: LD_INT 1
25963: ARRAY
25964: PUSH
25965: LD_VAR 0 1
25969: EQUAL
25970: IFFALSE 26076
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25972: LD_ADDR_VAR 0 5
25976: PUSH
25977: LD_EXP 45
25981: PUSH
25982: LD_VAR 0 3
25986: ARRAY
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25992: LD_ADDR_VAR 0 6
25996: PUSH
25997: LD_EXP 45
26001: PUSH
26002: LD_VAR 0 3
26006: ARRAY
26007: PUSH
26008: LD_INT 3
26010: ARRAY
26011: PUSH
26012: LD_INT 1
26014: ARRAY
26015: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26016: LD_ADDR_VAR 0 7
26020: PUSH
26021: LD_EXP 45
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: LD_INT 3
26034: ARRAY
26035: PUSH
26036: LD_INT 2
26038: ARRAY
26039: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26040: LD_ADDR_VAR 0 4
26044: PUSH
26045: LD_VAR 0 6
26049: PPUSH
26050: LD_VAR 0 7
26054: PPUSH
26055: CALL_OW 428
26059: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26060: LD_VAR 0 4
26064: PPUSH
26065: LD_VAR 0 5
26069: PPUSH
26070: CALL_OW 148
// break ;
26074: GO 26078
// end ;
26076: GO 25947
26078: POP
26079: POP
// end ; end ;
26080: LD_VAR 0 2
26084: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26085: LD_INT 0
26087: PPUSH
26088: PPUSH
26089: PPUSH
26090: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26091: LD_ADDR_VAR 0 4
26095: PUSH
26096: LD_VAR 0 1
26100: PPUSH
26101: LD_INT 32
26103: PUSH
26104: LD_INT 1
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: PPUSH
26111: CALL 11587 0 2
26115: ST_TO_ADDR
// if not tmp then
26116: LD_VAR 0 4
26120: NOT
26121: IFFALSE 26127
// exit else
26123: GO 26209
26125: GO 26209
// begin for i = 1 to tmp do
26127: LD_ADDR_VAR 0 3
26131: PUSH
26132: DOUBLE
26133: LD_INT 1
26135: DEC
26136: ST_TO_ADDR
26137: LD_VAR 0 4
26141: PUSH
26142: FOR_TO
26143: IFFALSE 26207
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26145: LD_VAR 0 4
26149: PUSH
26150: LD_VAR 0 3
26154: ARRAY
26155: PPUSH
26156: CALL_OW 261
26160: PUSH
26161: LD_INT 20
26163: LESS
26164: PUSH
26165: LD_VAR 0 4
26169: PUSH
26170: LD_VAR 0 3
26174: ARRAY
26175: PPUSH
26176: CALL_OW 110
26180: PUSH
26181: LD_INT 0
26183: EQUAL
26184: AND
26185: IFFALSE 26205
// begin SetTag ( tmp [ i ] , 21 ) ;
26187: LD_VAR 0 4
26191: PUSH
26192: LD_VAR 0 3
26196: ARRAY
26197: PPUSH
26198: LD_INT 21
26200: PPUSH
26201: CALL_OW 109
// end ;
26205: GO 26142
26207: POP
26208: POP
// end ; end ;
26209: LD_VAR 0 2
26213: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26214: LD_INT 0
26216: PPUSH
26217: PPUSH
26218: PPUSH
26219: PPUSH
26220: PPUSH
// if not unit then
26221: LD_VAR 0 1
26225: NOT
26226: IFFALSE 26230
// exit ;
26228: GO 26418
// side := GetSide ( unit ) ;
26230: LD_ADDR_VAR 0 3
26234: PUSH
26235: LD_VAR 0 1
26239: PPUSH
26240: CALL_OW 255
26244: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26245: LD_ADDR_VAR 0 5
26249: PUSH
26250: LD_VAR 0 3
26254: PPUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 3
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 30
26280: PUSH
26281: LD_INT 29
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: PPUSH
26294: CALL 11587 0 2
26298: ST_TO_ADDR
// if not b then
26299: LD_VAR 0 5
26303: NOT
26304: IFFALSE 26308
// exit ;
26306: GO 26418
// if GetTag ( unit ) = 21 then
26308: LD_VAR 0 1
26312: PPUSH
26313: CALL_OW 110
26317: PUSH
26318: LD_INT 21
26320: EQUAL
26321: IFFALSE 26418
// begin c := NearestUnitToUnit ( b , unit ) ;
26323: LD_ADDR_VAR 0 6
26327: PUSH
26328: LD_VAR 0 5
26332: PPUSH
26333: LD_VAR 0 1
26337: PPUSH
26338: CALL_OW 74
26342: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26343: LD_VAR 0 1
26347: PPUSH
26348: LD_VAR 0 6
26352: PPUSH
26353: CALL_OW 250
26357: PPUSH
26358: LD_VAR 0 6
26362: PPUSH
26363: CALL_OW 251
26367: PPUSH
26368: CALL_OW 297
26372: PUSH
26373: LD_INT 6
26375: GREATER
26376: IFFALSE 26394
// ComMoveUnit ( unit , c ) else
26378: LD_VAR 0 1
26382: PPUSH
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 112
26392: GO 26418
// begin SetFuel ( unit , 100 ) ;
26394: LD_VAR 0 1
26398: PPUSH
26399: LD_INT 100
26401: PPUSH
26402: CALL_OW 240
// SetTag ( unit , 0 ) ;
26406: LD_VAR 0 1
26410: PPUSH
26411: LD_INT 0
26413: PPUSH
26414: CALL_OW 109
// end ; end ; end ;
26418: LD_VAR 0 2
26422: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26423: LD_INT 0
26425: PPUSH
26426: PPUSH
26427: PPUSH
26428: PPUSH
26429: PPUSH
26430: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26431: LD_ADDR_VAR 0 7
26435: PUSH
26436: LD_VAR 0 1
26440: PPUSH
26441: LD_INT 33
26443: PUSH
26444: LD_INT 2
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 61
26456: PUSH
26457: EMPTY
26458: LIST
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PPUSH
26468: CALL 11587 0 2
26472: ST_TO_ADDR
// if not vehs then
26473: LD_VAR 0 7
26477: NOT
26478: IFFALSE 26482
// exit ;
26480: GO 26767
// if nation = 1 then
26482: LD_VAR 0 2
26486: PUSH
26487: LD_INT 1
26489: EQUAL
26490: IFFALSE 26660
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26492: LD_VAR 0 1
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 36
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL 11587 0 2
26511: NOT
26512: IFFALSE 26518
// exit else
26514: GO 26767
26516: GO 26658
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26518: LD_ADDR_VAR 0 5
26522: PUSH
26523: LD_VAR 0 1
26527: PPUSH
26528: LD_INT 30
26530: PUSH
26531: LD_INT 36
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PPUSH
26538: CALL 11587 0 2
26542: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26543: LD_ADDR_VAR 0 6
26547: PUSH
26548: LD_VAR 0 5
26552: PUSH
26553: LD_INT 1
26555: ARRAY
26556: PPUSH
26557: CALL_OW 313
26561: ST_TO_ADDR
// for i = vehs downto 1 do
26562: LD_ADDR_VAR 0 4
26566: PUSH
26567: DOUBLE
26568: LD_VAR 0 7
26572: INC
26573: ST_TO_ADDR
26574: LD_INT 1
26576: PUSH
26577: FOR_DOWNTO
26578: IFFALSE 26656
// begin if not IsControledBy ( vehs [ i ] ) then
26580: LD_VAR 0 7
26584: PUSH
26585: LD_VAR 0 4
26589: ARRAY
26590: PPUSH
26591: CALL_OW 312
26595: NOT
26596: IFFALSE 26654
// begin tmp := MCV_RemoteDriver ( oper ) ;
26598: LD_ADDR_VAR 0 8
26602: PUSH
26603: LD_VAR 0 6
26607: PPUSH
26608: CALL 26772 0 1
26612: ST_TO_ADDR
// if not tmp then
26613: LD_VAR 0 8
26617: NOT
26618: IFFALSE 26626
// exit else
26620: POP
26621: POP
26622: GO 26767
26624: GO 26654
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26626: LD_VAR 0 7
26630: PUSH
26631: LD_VAR 0 4
26635: ARRAY
26636: PPUSH
26637: LD_VAR 0 8
26641: PUSH
26642: LD_INT 1
26644: ARRAY
26645: PUSH
26646: LD_INT 1
26648: ARRAY
26649: PPUSH
26650: CALL_OW 135
// end ; end ;
26654: GO 26577
26656: POP
26657: POP
// end ; end else
26658: GO 26767
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26660: LD_VAR 0 1
26664: PPUSH
26665: LD_INT 34
26667: PUSH
26668: LD_INT 31
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PPUSH
26675: CALL 11587 0 2
26679: NOT
26680: IFFALSE 26686
// exit else
26682: GO 26767
26684: GO 26767
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26686: LD_ADDR_VAR 0 5
26690: PUSH
26691: LD_VAR 0 1
26695: PPUSH
26696: LD_INT 34
26698: PUSH
26699: LD_INT 31
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL 11587 0 2
26710: ST_TO_ADDR
// oper := [ ] ;
26711: LD_ADDR_VAR 0 6
26715: PUSH
26716: EMPTY
26717: ST_TO_ADDR
// for i = 1 to ct do
26718: LD_ADDR_VAR 0 4
26722: PUSH
26723: DOUBLE
26724: LD_INT 1
26726: DEC
26727: ST_TO_ADDR
26728: LD_VAR 0 5
26732: PUSH
26733: FOR_TO
26734: IFFALSE 26765
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26736: LD_ADDR_VAR 0 6
26740: PUSH
26741: LD_VAR 0 6
26745: PUSH
26746: LD_VAR 0 5
26750: PUSH
26751: LD_VAR 0 4
26755: ARRAY
26756: PPUSH
26757: CALL 31695 0 1
26761: ADD
26762: ST_TO_ADDR
26763: GO 26733
26765: POP
26766: POP
// end ; end ; end ;
26767: LD_VAR 0 3
26771: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26772: LD_INT 0
26774: PPUSH
26775: PPUSH
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
// if not drivers then
26780: LD_VAR 0 1
26784: NOT
26785: IFFALSE 26791
// exit else
26787: GO 27071
26789: GO 27071
// begin linked := [ ] ;
26791: LD_ADDR_VAR 0 5
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to drivers do
26798: LD_ADDR_VAR 0 3
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 1
26812: PUSH
26813: FOR_TO
26814: IFFALSE 27059
// begin if CanControl ( drivers [ i ] ) then
26816: LD_VAR 0 1
26820: PUSH
26821: LD_VAR 0 3
26825: ARRAY
26826: PPUSH
26827: CALL 32085 0 1
26831: IFFALSE 27057
// if i > 1 then
26833: LD_VAR 0 3
26837: PUSH
26838: LD_INT 1
26840: GREATER
26841: IFFALSE 27018
// begin m := false ;
26843: LD_ADDR_VAR 0 6
26847: PUSH
26848: LD_INT 0
26850: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26851: LD_ADDR_VAR 0 7
26855: PUSH
26856: LD_VAR 0 1
26860: PUSH
26861: LD_VAR 0 3
26865: ARRAY
26866: PPUSH
26867: CALL_OW 432
26871: ST_TO_ADDR
// for j = 1 to linked do
26872: LD_ADDR_VAR 0 4
26876: PUSH
26877: DOUBLE
26878: LD_INT 1
26880: DEC
26881: ST_TO_ADDR
26882: LD_VAR 0 5
26886: PUSH
26887: FOR_TO
26888: IFFALSE 26962
// begin if l < linked [ j ] [ 2 ] then
26890: LD_VAR 0 7
26894: PUSH
26895: LD_VAR 0 5
26899: PUSH
26900: LD_VAR 0 4
26904: ARRAY
26905: PUSH
26906: LD_INT 2
26908: ARRAY
26909: LESS
26910: IFFALSE 26960
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26912: LD_ADDR_VAR 0 5
26916: PUSH
26917: LD_VAR 0 5
26921: PPUSH
26922: LD_INT 1
26924: PPUSH
26925: LD_VAR 0 1
26929: PUSH
26930: LD_VAR 0 3
26934: ARRAY
26935: PUSH
26936: LD_VAR 0 7
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PPUSH
26945: CALL_OW 2
26949: ST_TO_ADDR
// m := true ;
26950: LD_ADDR_VAR 0 6
26954: PUSH
26955: LD_INT 1
26957: ST_TO_ADDR
// break ;
26958: GO 26962
// end ; end ;
26960: GO 26887
26962: POP
26963: POP
// if not m then
26964: LD_VAR 0 6
26968: NOT
26969: IFFALSE 27016
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26971: LD_ADDR_VAR 0 5
26975: PUSH
26976: LD_VAR 0 5
26980: PUSH
26981: LD_VAR 0 1
26985: PUSH
26986: LD_VAR 0 3
26990: ARRAY
26991: PUSH
26992: LD_VAR 0 1
26996: PUSH
26997: LD_VAR 0 3
27001: ARRAY
27002: PPUSH
27003: CALL_OW 432
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: EMPTY
27013: LIST
27014: ADD
27015: ST_TO_ADDR
// end else
27016: GO 27057
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27018: LD_ADDR_VAR 0 5
27022: PUSH
27023: LD_VAR 0 1
27027: PUSH
27028: LD_VAR 0 3
27032: ARRAY
27033: PUSH
27034: LD_VAR 0 1
27038: PUSH
27039: LD_VAR 0 3
27043: ARRAY
27044: PPUSH
27045: CALL_OW 432
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: ST_TO_ADDR
// end ;
27057: GO 26813
27059: POP
27060: POP
// result := linked ;
27061: LD_ADDR_VAR 0 2
27065: PUSH
27066: LD_VAR 0 5
27070: ST_TO_ADDR
// end ; end ;
27071: LD_VAR 0 2
27075: RET
// export function MCV_ToRepair ( unit ) ; begin
27076: LD_INT 0
27078: PPUSH
// if not unit then
27079: LD_VAR 0 1
27083: NOT
27084: IFFALSE 27088
// exit ;
27086: GO 27119
// SetTag ( unit , 6 ) ;
27088: LD_VAR 0 1
27092: PPUSH
27093: LD_INT 6
27095: PPUSH
27096: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27100: LD_VAR 0 1
27104: PPUSH
27105: CALL_OW 255
27109: PPUSH
27110: LD_VAR 0 1
27114: PPUSH
27115: CALL 25677 0 2
// end ;
27119: LD_VAR 0 2
27123: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27124: LD_INT 0
27126: PPUSH
27127: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27128: LD_VAR 0 1
27132: PPUSH
27133: LD_INT 6
27135: PPUSH
27136: EMPTY
27137: PPUSH
27138: CALL 12290 0 3
27142: IFFALSE 27235
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27144: LD_ADDR_VAR 0 3
27148: PUSH
27149: DOUBLE
27150: LD_VAR 0 1
27154: PPUSH
27155: LD_INT 6
27157: PPUSH
27158: EMPTY
27159: PPUSH
27160: CALL 12290 0 3
27164: INC
27165: ST_TO_ADDR
27166: LD_INT 1
27168: PUSH
27169: FOR_DOWNTO
27170: IFFALSE 27233
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27172: LD_VAR 0 1
27176: PPUSH
27177: LD_INT 6
27179: PPUSH
27180: EMPTY
27181: PPUSH
27182: CALL 12290 0 3
27186: PUSH
27187: LD_VAR 0 3
27191: ARRAY
27192: PPUSH
27193: CALL_OW 256
27197: PUSH
27198: LD_INT 1000
27200: EQUAL
27201: IFFALSE 27231
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27203: LD_VAR 0 1
27207: PPUSH
27208: LD_INT 6
27210: PPUSH
27211: EMPTY
27212: PPUSH
27213: CALL 12290 0 3
27217: PUSH
27218: LD_VAR 0 3
27222: ARRAY
27223: PPUSH
27224: LD_INT 0
27226: PPUSH
27227: CALL_OW 109
27231: GO 27169
27233: POP
27234: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27235: LD_VAR 0 1
27239: PPUSH
27240: LD_INT 10
27242: PPUSH
27243: EMPTY
27244: PPUSH
27245: CALL 12290 0 3
27249: IFFALSE 27366
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27251: LD_ADDR_VAR 0 3
27255: PUSH
27256: DOUBLE
27257: LD_VAR 0 1
27261: PPUSH
27262: LD_INT 10
27264: PPUSH
27265: EMPTY
27266: PPUSH
27267: CALL 12290 0 3
27271: INC
27272: ST_TO_ADDR
27273: LD_INT 1
27275: PUSH
27276: FOR_DOWNTO
27277: IFFALSE 27364
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27279: LD_VAR 0 1
27283: PPUSH
27284: LD_INT 10
27286: PPUSH
27287: EMPTY
27288: PPUSH
27289: CALL 12290 0 3
27293: PUSH
27294: LD_VAR 0 3
27298: ARRAY
27299: PPUSH
27300: CALL_OW 302
27304: NOT
27305: PUSH
27306: LD_VAR 0 1
27310: PPUSH
27311: LD_INT 10
27313: PPUSH
27314: EMPTY
27315: PPUSH
27316: CALL 12290 0 3
27320: PUSH
27321: LD_VAR 0 3
27325: ARRAY
27326: PPUSH
27327: CALL_OW 301
27331: OR
27332: IFFALSE 27362
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27334: LD_VAR 0 1
27338: PPUSH
27339: LD_INT 10
27341: PPUSH
27342: EMPTY
27343: PPUSH
27344: CALL 12290 0 3
27348: PUSH
27349: LD_VAR 0 3
27353: ARRAY
27354: PPUSH
27355: LD_INT 0
27357: PPUSH
27358: CALL_OW 109
27362: GO 27276
27364: POP
27365: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27366: LD_ADDR_VAR 0 3
27370: PUSH
27371: LD_VAR 0 1
27375: PPUSH
27376: EMPTY
27377: PPUSH
27378: CALL 11888 0 2
27382: PUSH
27383: LD_VAR 0 1
27387: PPUSH
27388: LD_INT 7
27390: PPUSH
27391: EMPTY
27392: PPUSH
27393: CALL 12290 0 3
27397: DIFF
27398: PUSH
27399: FOR_IN
27400: IFFALSE 27444
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27402: LD_VAR 0 3
27406: PPUSH
27407: CALL_OW 256
27411: PUSH
27412: LD_INT 650
27414: LESS
27415: PUSH
27416: LD_VAR 0 3
27420: PPUSH
27421: CALL_OW 110
27425: PUSH
27426: LD_INT 6
27428: EQUAL
27429: NOT
27430: AND
27431: IFFALSE 27442
// MCV_ToRepair ( i ) ;
27433: LD_VAR 0 3
27437: PPUSH
27438: CALL 27076 0 1
27442: GO 27399
27444: POP
27445: POP
// end ; end_of_file end_of_file
27446: LD_VAR 0 2
27450: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27451: LD_STRING SAILEvent [
27453: PUSH
27454: LD_VAR 0 1
27458: STR
27459: PUSH
27460: LD_STRING ]
27462: STR
27463: PPUSH
27464: CALL 7984 0 1
// if event = 101 and dialog_north then
27468: LD_VAR 0 1
27472: PUSH
27473: LD_INT 101
27475: EQUAL
27476: PUSH
27477: LD_EXP 6
27481: AND
27482: IFFALSE 27546
// begin dialog_north := false ;
27484: LD_ADDR_EXP 6
27488: PUSH
27489: LD_INT 0
27491: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27492: LD_EXP 5
27496: PPUSH
27497: LD_STRING DS1
27499: PUSH
27500: LD_STRING DS2
27502: PUSH
27503: LD_STRING DS3
27505: PUSH
27506: LD_STRING DS6
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 1
27517: PPUSH
27518: LD_INT 4
27520: PPUSH
27521: CALL_OW 12
27525: ARRAY
27526: PPUSH
27527: CALL_OW 94
// Wait ( 4 4$00 ) ;
27531: LD_INT 8400
27533: PPUSH
27534: CALL_OW 67
// dialog_north := true ;
27538: LD_ADDR_EXP 6
27542: PUSH
27543: LD_INT 1
27545: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27546: LD_VAR 0 1
27550: PUSH
27551: LD_INT 102
27553: EQUAL
27554: PUSH
27555: LD_EXP 7
27559: AND
27560: IFFALSE 27620
// begin dialog_south := false ;
27562: LD_ADDR_EXP 7
27566: PUSH
27567: LD_INT 0
27569: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27570: LD_EXP 4
27574: PPUSH
27575: LD_STRING DJ1
27577: PUSH
27578: LD_STRING DJ4
27580: PUSH
27581: LD_STRING DJ6
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PPUSH
27592: LD_INT 3
27594: PPUSH
27595: CALL_OW 12
27599: ARRAY
27600: PPUSH
27601: CALL_OW 94
// Wait ( 4 4$00 ) ;
27605: LD_INT 8400
27607: PPUSH
27608: CALL_OW 67
// dialog_south := true ;
27612: LD_ADDR_EXP 7
27616: PUSH
27617: LD_INT 1
27619: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27620: LD_VAR 0 1
27624: PUSH
27625: LD_INT 104
27627: EQUAL
27628: PUSH
27629: LD_EXP 8
27633: AND
27634: IFFALSE 27656
// begin dialog_popov := false ;
27636: LD_ADDR_EXP 8
27640: PUSH
27641: LD_INT 0
27643: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27644: LD_EXP 26
27648: PPUSH
27649: LD_STRING DR4
27651: PPUSH
27652: CALL_OW 94
// end ; end ;
27656: PPOPN 1
27658: END
// on BuildingStarted ( b , unit ) do var side , i ;
27659: LD_INT 0
27661: PPUSH
27662: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27663: LD_EXP 41
27667: PUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 255
27677: ARRAY
27678: IFFALSE 27856
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27680: LD_STRING BuildingStarted [side: 
27682: PUSH
27683: LD_VAR 0 1
27687: PPUSH
27688: CALL_OW 255
27692: STR
27693: PUSH
27694: LD_STRING ; btype: 
27696: STR
27697: PUSH
27698: LD_VAR 0 1
27702: PPUSH
27703: CALL_OW 266
27707: STR
27708: PUSH
27709: LD_STRING ; unit: 
27711: STR
27712: PUSH
27713: LD_VAR 0 2
27717: STR
27718: PUSH
27719: LD_STRING ]
27721: STR
27722: PPUSH
27723: CALL 7984 0 1
// side := GetSide ( b ) ;
27727: LD_ADDR_VAR 0 3
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27742: LD_VAR 0 3
27746: PPUSH
27747: LD_INT 21
27749: PUSH
27750: LD_INT 3
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PPUSH
27757: CALL 11587 0 2
27761: PUSH
27762: LD_INT 1
27764: EQUAL
27765: IFFALSE 27856
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27767: LD_ADDR_VAR 0 4
27771: PUSH
27772: LD_VAR 0 3
27776: PPUSH
27777: LD_INT 21
27779: PUSH
27780: LD_INT 1
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL 11587 0 2
27791: PUSH
27792: LD_VAR 0 3
27796: PPUSH
27797: LD_INT 2
27799: PPUSH
27800: EMPTY
27801: PPUSH
27802: CALL 11670 0 3
27806: DIFF
27807: PUSH
27808: FOR_IN
27809: IFFALSE 27854
// if not HasTask ( i ) then
27811: LD_VAR 0 4
27815: PPUSH
27816: CALL_OW 314
27820: NOT
27821: IFFALSE 27852
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27823: LD_VAR 0 4
27827: PPUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 250
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 251
27847: PPUSH
27848: CALL_OW 111
27852: GO 27808
27854: POP
27855: POP
// end ;
27856: PPOPN 4
27858: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27859: LD_EXP 41
27863: PUSH
27864: LD_VAR 0 1
27868: PPUSH
27869: CALL_OW 255
27873: ARRAY
27874: IFFALSE 28243
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27876: LD_STRING BuildingComplete [side: 
27878: PUSH
27879: LD_VAR 0 1
27883: PPUSH
27884: CALL_OW 255
27888: STR
27889: PUSH
27890: LD_STRING ; btype: 
27892: STR
27893: PUSH
27894: LD_VAR 0 1
27898: PPUSH
27899: CALL_OW 266
27903: STR
27904: PUSH
27905: LD_STRING ]
27907: STR
27908: PPUSH
27909: CALL 7984 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27913: LD_ADDR_EXP 48
27917: PUSH
27918: LD_EXP 48
27922: PPUSH
27923: LD_VAR 0 1
27927: PPUSH
27928: CALL_OW 255
27932: PPUSH
27933: LD_VAR 0 1
27937: PPUSH
27938: CALL_OW 266
27942: PPUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 250
27952: PUSH
27953: LD_VAR 0 1
27957: PPUSH
27958: CALL_OW 251
27962: PUSH
27963: LD_VAR 0 1
27967: PPUSH
27968: CALL_OW 254
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: PPUSH
27978: CALL 41973 0 4
27982: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27983: LD_VAR 0 1
27987: PPUSH
27988: CALL_OW 266
27992: PUSH
27993: LD_INT 6
27995: EQUAL
27996: IFFALSE 28030
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27998: LD_ADDR_EXP 42
28002: PUSH
28003: LD_EXP 42
28007: PPUSH
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 255
28017: PPUSH
28018: LD_VAR 0 1
28022: PPUSH
28023: EMPTY
28024: PPUSH
28025: CALL 41882 0 4
28029: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 266
28039: PUSH
28040: LD_INT 0
28042: EQUAL
28043: IFFALSE 28153
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28045: LD_ADDR_EXP 50
28049: PUSH
28050: LD_EXP 50
28054: PPUSH
28055: LD_VAR 0 1
28059: PPUSH
28060: CALL_OW 255
28064: PPUSH
28065: LD_INT 0
28067: PPUSH
28068: EMPTY
28069: PPUSH
28070: CALL 41882 0 4
28074: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28075: LD_VAR 0 1
28079: PPUSH
28080: CALL_OW 274
28084: PPUSH
28085: LD_INT 1
28087: PPUSH
28088: LD_EXP 74
28092: PUSH
28093: LD_INT 1
28095: ARRAY
28096: PPUSH
28097: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28101: LD_VAR 0 1
28105: PPUSH
28106: CALL_OW 274
28110: PPUSH
28111: LD_INT 2
28113: PPUSH
28114: LD_EXP 74
28118: PUSH
28119: LD_INT 2
28121: ARRAY
28122: PPUSH
28123: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28127: LD_VAR 0 1
28131: PPUSH
28132: CALL_OW 274
28136: PPUSH
28137: LD_INT 3
28139: PPUSH
28140: LD_EXP 74
28144: PUSH
28145: LD_INT 3
28147: ARRAY
28148: PPUSH
28149: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28153: LD_VAR 0 1
28157: PPUSH
28158: CALL_OW 266
28162: PUSH
28163: LD_INT 2
28165: EQUAL
28166: IFFALSE 28198
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28168: LD_ADDR_EXP 50
28172: PUSH
28173: LD_EXP 50
28177: PPUSH
28178: LD_VAR 0 1
28182: PPUSH
28183: CALL_OW 255
28187: PPUSH
28188: LD_INT 2
28190: PPUSH
28191: EMPTY
28192: PPUSH
28193: CALL 41882 0 4
28197: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28198: LD_VAR 0 1
28202: PPUSH
28203: CALL_OW 266
28207: PUSH
28208: LD_INT 4
28210: EQUAL
28211: IFFALSE 28243
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28213: LD_ADDR_EXP 50
28217: PUSH
28218: LD_EXP 50
28222: PPUSH
28223: LD_VAR 0 1
28227: PPUSH
28228: CALL_OW 255
28232: PPUSH
28233: LD_INT 4
28235: PPUSH
28236: EMPTY
28237: PPUSH
28238: CALL 41882 0 4
28242: ST_TO_ADDR
// end ;
28243: PPOPN 1
28245: END
// on ResearchComplete ( tech , lab ) do var i ;
28246: LD_INT 0
28248: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28249: LD_EXP 41
28253: PUSH
28254: LD_VAR 0 2
28258: PPUSH
28259: CALL_OW 255
28263: ARRAY
28264: IFFALSE 28548
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28266: LD_STRING ResearchComplete [side: 
28268: PUSH
28269: LD_VAR 0 2
28273: PPUSH
28274: CALL_OW 255
28278: PPUSH
28279: CALL_OW 255
28283: STR
28284: PUSH
28285: LD_STRING ; tech:
28287: STR
28288: PUSH
28289: LD_VAR 0 1
28293: STR
28294: PUSH
28295: LD_STRING ]
28297: STR
28298: PPUSH
28299: CALL 7984 0 1
// for i = 1 to MREG_ToRes do
28303: LD_ADDR_VAR 0 3
28307: PUSH
28308: DOUBLE
28309: LD_INT 1
28311: DEC
28312: ST_TO_ADDR
28313: LD_EXP 52
28317: PUSH
28318: FOR_TO
28319: IFFALSE 28406
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28321: LD_EXP 52
28325: PUSH
28326: LD_VAR 0 3
28330: ARRAY
28331: PUSH
28332: LD_INT 1
28334: ARRAY
28335: PUSH
28336: LD_VAR 0 2
28340: PPUSH
28341: CALL_OW 255
28345: EQUAL
28346: PUSH
28347: LD_EXP 52
28351: PUSH
28352: LD_VAR 0 3
28356: ARRAY
28357: PUSH
28358: LD_INT 2
28360: ARRAY
28361: PUSH
28362: LD_VAR 0 1
28366: EQUAL
28367: AND
28368: IFFALSE 28404
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28370: LD_ADDR_EXP 52
28374: PUSH
28375: LD_EXP 52
28379: PPUSH
28380: LD_VAR 0 2
28384: PPUSH
28385: CALL_OW 255
28389: PPUSH
28390: LD_VAR 0 1
28394: PPUSH
28395: EMPTY
28396: PPUSH
28397: CALL 41973 0 4
28401: ST_TO_ADDR
// break ;
28402: GO 28406
// end ;
28404: GO 28318
28406: POP
28407: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28408: LD_VAR 0 1
28412: PUSH
28413: LD_INT 2
28415: PUSH
28416: LD_INT 11
28418: PUSH
28419: LD_INT 4
28421: PUSH
28422: LD_INT 3
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: IN
28431: IFFALSE 28548
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28433: LD_ADDR_VAR 0 3
28437: PUSH
28438: LD_VAR 0 2
28442: PPUSH
28443: CALL_OW 255
28447: PPUSH
28448: LD_INT 16
28450: PPUSH
28451: LD_INT 25
28453: PUSH
28454: LD_INT 4
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PPUSH
28461: CALL 12290 0 3
28465: ST_TO_ADDR
// if i then
28466: LD_VAR 0 3
28470: IFFALSE 28488
// SetTag ( i [ 1 ] , 0 ) ;
28472: LD_VAR 0 3
28476: PUSH
28477: LD_INT 1
28479: ARRAY
28480: PPUSH
28481: LD_INT 0
28483: PPUSH
28484: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28488: LD_ADDR_VAR 0 3
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: CALL_OW 255
28502: PPUSH
28503: LD_INT 171
28505: PPUSH
28506: EMPTY
28507: PPUSH
28508: CALL 12290 0 3
28512: ST_TO_ADDR
// if i then
28513: LD_VAR 0 3
28517: IFFALSE 28548
// begin SetTag ( i [ 1 ] , 0 ) ;
28519: LD_VAR 0 3
28523: PUSH
28524: LD_INT 1
28526: ARRAY
28527: PPUSH
28528: LD_INT 0
28530: PPUSH
28531: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28535: LD_VAR 0 3
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: PPUSH
28544: CALL_OW 122
// end ; end ; end ;
28548: PPOPN 3
28550: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28551: LD_INT 0
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28560: LD_EXP 41
28564: PUSH
28565: LD_VAR 0 2
28569: PPUSH
28570: CALL_OW 255
28574: ARRAY
28575: IFFALSE 29302
// begin side := GetSide ( veh ) ;
28577: LD_ADDR_VAR 0 4
28581: PUSH
28582: LD_VAR 0 1
28586: PPUSH
28587: CALL_OW 255
28591: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28592: LD_ADDR_VAR 0 6
28596: PUSH
28597: LD_VAR 0 1
28601: PPUSH
28602: CALL_OW 265
28606: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28607: LD_ADDR_VAR 0 7
28611: PUSH
28612: LD_VAR 0 1
28616: PPUSH
28617: CALL_OW 262
28621: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28622: LD_ADDR_VAR 0 8
28626: PUSH
28627: LD_VAR 0 1
28631: PPUSH
28632: CALL_OW 263
28636: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28637: LD_ADDR_VAR 0 9
28641: PUSH
28642: LD_VAR 0 1
28646: PPUSH
28647: CALL_OW 264
28651: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28652: LD_STRING VehicleConstructed [side: 
28654: PUSH
28655: LD_VAR 0 4
28659: STR
28660: PUSH
28661: LD_STRING ; id:
28663: STR
28664: PUSH
28665: LD_VAR 0 1
28669: STR
28670: PUSH
28671: LD_STRING ; components: [
28673: STR
28674: PUSH
28675: LD_VAR 0 6
28679: STR
28680: PUSH
28681: LD_STRING , 
28683: STR
28684: PUSH
28685: LD_VAR 0 7
28689: STR
28690: PUSH
28691: LD_STRING , 
28693: STR
28694: PUSH
28695: LD_VAR 0 8
28699: STR
28700: PUSH
28701: LD_STRING , 
28703: STR
28704: PUSH
28705: LD_VAR 0 9
28709: STR
28710: PUSH
28711: LD_STRING ]]
28713: STR
28714: PPUSH
28715: CALL 7984 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28719: LD_VAR 0 1
28723: PPUSH
28724: CALL_OW 264
28728: PUSH
28729: LD_INT 13
28731: PUSH
28732: LD_INT 12
28734: PUSH
28735: LD_INT 14
28737: PUSH
28738: LD_INT 51
28740: PUSH
28741: LD_INT 53
28743: PUSH
28744: LD_INT 52
28746: PUSH
28747: LD_INT 32
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: IN
28759: NOT
28760: IFFALSE 28802
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28762: LD_ADDR_EXP 61
28766: PUSH
28767: LD_EXP 61
28771: PPUSH
28772: LD_VAR 0 4
28776: PPUSH
28777: LD_EXP 61
28781: PUSH
28782: LD_VAR 0 4
28786: ARRAY
28787: PUSH
28788: LD_INT 1
28790: PLUS
28791: PPUSH
28792: LD_VAR 0 1
28796: PPUSH
28797: CALL 31052 0 4
28801: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28802: LD_VAR 0 1
28806: PPUSH
28807: CALL_OW 264
28811: PUSH
28812: LD_INT 31
28814: EQUAL
28815: IFFALSE 28834
// SetTag ( GetDriver ( veh ) , 9 ) ;
28817: LD_VAR 0 1
28821: PPUSH
28822: CALL 31695 0 1
28826: PPUSH
28827: LD_INT 9
28829: PPUSH
28830: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28834: LD_VAR 0 1
28838: PPUSH
28839: CALL_OW 264
28843: PUSH
28844: LD_INT 14
28846: PUSH
28847: LD_INT 53
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: IN
28854: IFFALSE 28891
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28856: LD_ADDR_EXP 44
28860: PUSH
28861: LD_EXP 44
28865: PPUSH
28866: LD_VAR 0 1
28870: PPUSH
28871: CALL_OW 255
28875: PPUSH
28876: LD_INT 2
28878: PPUSH
28879: LD_VAR 0 1
28883: PPUSH
28884: CALL 31052 0 4
28888: ST_TO_ADDR
// exit ;
28889: GO 29302
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28891: LD_VAR 0 1
28895: PPUSH
28896: CALL_OW 265
28900: PUSH
28901: LD_EXP 68
28905: PUSH
28906: LD_VAR 0 4
28910: ARRAY
28911: PUSH
28912: LD_INT 1
28914: ARRAY
28915: IN
28916: PUSH
28917: LD_VAR 0 1
28921: PPUSH
28922: CALL_OW 262
28926: PUSH
28927: LD_EXP 68
28931: PUSH
28932: LD_VAR 0 4
28936: ARRAY
28937: PUSH
28938: LD_INT 1
28940: ARRAY
28941: IN
28942: AND
28943: PUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 263
28953: PUSH
28954: LD_EXP 68
28958: PUSH
28959: LD_VAR 0 4
28963: ARRAY
28964: PUSH
28965: LD_INT 1
28967: ARRAY
28968: IN
28969: AND
28970: PUSH
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 264
28980: PUSH
28981: LD_EXP 68
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: AND
28997: IFFALSE 29041
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28999: LD_ADDR_EXP 69
29003: PUSH
29004: LD_EXP 69
29008: PPUSH
29009: LD_VAR 0 4
29013: PPUSH
29014: LD_EXP 69
29018: PUSH
29019: LD_VAR 0 4
29023: ARRAY
29024: PUSH
29025: LD_INT 1
29027: PLUS
29028: PPUSH
29029: LD_VAR 0 1
29033: PPUSH
29034: CALL 31052 0 4
29038: ST_TO_ADDR
// exit ;
29039: GO 29302
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29041: LD_VAR 0 6
29045: PUSH
29046: LD_EXP 71
29050: PUSH
29051: LD_VAR 0 4
29055: ARRAY
29056: PUSH
29057: LD_INT 1
29059: ARRAY
29060: EQUAL
29061: PUSH
29062: LD_VAR 0 7
29066: PUSH
29067: LD_EXP 71
29071: PUSH
29072: LD_VAR 0 4
29076: ARRAY
29077: PUSH
29078: LD_INT 2
29080: ARRAY
29081: EQUAL
29082: AND
29083: PUSH
29084: LD_VAR 0 8
29088: PUSH
29089: LD_EXP 71
29093: PUSH
29094: LD_VAR 0 4
29098: ARRAY
29099: PUSH
29100: LD_INT 3
29102: ARRAY
29103: EQUAL
29104: AND
29105: PUSH
29106: LD_VAR 0 9
29110: PUSH
29111: LD_EXP 71
29115: PUSH
29116: LD_VAR 0 4
29120: ARRAY
29121: PUSH
29122: LD_INT 4
29124: ARRAY
29125: EQUAL
29126: AND
29127: IFFALSE 29283
// begin tmp := MREG_ToAttack [ side ] ;
29129: LD_ADDR_VAR 0 5
29133: PUSH
29134: LD_EXP 71
29138: PUSH
29139: LD_VAR 0 4
29143: ARRAY
29144: ST_TO_ADDR
// for i = 1 to 4 do
29145: LD_ADDR_VAR 0 3
29149: PUSH
29150: DOUBLE
29151: LD_INT 1
29153: DEC
29154: ST_TO_ADDR
29155: LD_INT 4
29157: PUSH
29158: FOR_TO
29159: IFFALSE 29181
// tmp := Delete ( tmp , 1 ) ;
29161: LD_ADDR_VAR 0 5
29165: PUSH
29166: LD_VAR 0 5
29170: PPUSH
29171: LD_INT 1
29173: PPUSH
29174: CALL_OW 3
29178: ST_TO_ADDR
29179: GO 29158
29181: POP
29182: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29183: LD_ADDR_EXP 71
29187: PUSH
29188: LD_EXP 71
29192: PPUSH
29193: LD_VAR 0 4
29197: PPUSH
29198: LD_VAR 0 5
29202: PPUSH
29203: CALL_OW 1
29207: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29208: LD_ADDR_EXP 73
29212: PUSH
29213: LD_EXP 73
29217: PPUSH
29218: LD_VAR 0 4
29222: PPUSH
29223: LD_EXP 73
29227: PUSH
29228: LD_VAR 0 4
29232: ARRAY
29233: PUSH
29234: LD_INT 1
29236: PLUS
29237: PPUSH
29238: LD_VAR 0 1
29242: PPUSH
29243: CALL 31052 0 4
29247: ST_TO_ADDR
// if tmp = 0 then
29248: LD_VAR 0 5
29252: PUSH
29253: LD_INT 0
29255: EQUAL
29256: IFFALSE 29281
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29258: LD_ADDR_EXP 71
29262: PUSH
29263: LD_EXP 71
29267: PPUSH
29268: LD_VAR 0 4
29272: PPUSH
29273: LD_INT 0
29275: PPUSH
29276: CALL_OW 1
29280: ST_TO_ADDR
// exit ;
29281: GO 29302
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 255
29292: PPUSH
29293: LD_VAR 0 1
29297: PPUSH
29298: CALL 25677 0 2
// end ;
29302: PPOPN 9
29304: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29305: LD_EXP 41
29309: PUSH
29310: LD_VAR 0 2
29314: PPUSH
29315: CALL_OW 255
29319: ARRAY
29320: IFFALSE 29552
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29322: LD_STRING ApemanTamed [side: 
29324: PUSH
29325: LD_VAR 0 2
29329: PPUSH
29330: CALL_OW 255
29334: STR
29335: PUSH
29336: LD_STRING ; sci: 
29338: STR
29339: PUSH
29340: LD_VAR 0 2
29344: STR
29345: PUSH
29346: LD_STRING ; ape: 
29348: STR
29349: PUSH
29350: LD_VAR 0 1
29354: STR
29355: PUSH
29356: LD_STRING ]
29358: STR
29359: PPUSH
29360: CALL 7984 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29364: LD_INT 11
29366: PPUSH
29367: LD_VAR 0 2
29371: PPUSH
29372: CALL_OW 255
29376: PPUSH
29377: CALL_OW 321
29381: PUSH
29382: LD_INT 2
29384: EQUAL
29385: NOT
29386: PUSH
29387: LD_INT 2
29389: PPUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: PPUSH
29400: CALL_OW 321
29404: PUSH
29405: LD_INT 2
29407: EQUAL
29408: NOT
29409: OR
29410: PUSH
29411: LD_VAR 0 2
29415: PPUSH
29416: CALL_OW 255
29420: PPUSH
29421: LD_INT 171
29423: PPUSH
29424: EMPTY
29425: PPUSH
29426: CALL 12290 0 3
29430: PUSH
29431: LD_INT 0
29433: EQUAL
29434: AND
29435: IFFALSE 29449
// begin SetTag ( ape , 171 ) ;
29437: LD_VAR 0 1
29441: PPUSH
29442: LD_INT 171
29444: PPUSH
29445: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29449: LD_VAR 0 2
29453: PPUSH
29454: CALL_OW 255
29458: PPUSH
29459: LD_INT 30
29461: PUSH
29462: LD_INT 1
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PPUSH
29469: CALL 11587 0 2
29473: IFFALSE 29552
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29475: LD_VAR 0 1
29479: PPUSH
29480: LD_VAR 0 2
29484: PPUSH
29485: CALL_OW 255
29489: PPUSH
29490: LD_INT 30
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PPUSH
29500: CALL 11587 0 2
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: CALL_OW 250
29513: PPUSH
29514: LD_VAR 0 2
29518: PPUSH
29519: CALL_OW 255
29523: PPUSH
29524: LD_INT 30
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PPUSH
29534: CALL 11587 0 2
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PPUSH
29543: CALL_OW 251
29547: PPUSH
29548: CALL_OW 111
// end ;
29552: PPOPN 2
29554: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29555: LD_EXP 41
29559: PUSH
29560: LD_VAR 0 1
29564: PPUSH
29565: CALL_OW 255
29569: ARRAY
29570: IFFALSE 29848
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 2
29581: PPUSH
29582: CALL_OW 255
29586: PPUSH
29587: CALL 12000 0 1
29591: IN
29592: IFFALSE 29733
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29594: LD_VAR 0 1
29598: PPUSH
29599: CALL_OW 266
29603: PUSH
29604: LD_INT 0
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: IN
29614: IFFALSE 29644
// begin Wait ( 0 0$0.3 ) ;
29616: LD_INT 10
29618: PPUSH
29619: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29623: LD_VAR 0 2
29627: PPUSH
29628: LD_INT 16
29630: PPUSH
29631: CALL_OW 336
// ComExitBuilding ( un ) ;
29635: LD_VAR 0 2
29639: PPUSH
29640: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29644: LD_VAR 0 1
29648: PPUSH
29649: CALL_OW 266
29653: PUSH
29654: LD_INT 4
29656: PUSH
29657: LD_INT 5
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: IN
29664: IFFALSE 29733
// begin Wait ( 0 0$0.3 ) ;
29666: LD_INT 10
29668: PPUSH
29669: CALL_OW 67
// if GetTag ( un ) = 0 then
29673: LD_VAR 0 2
29677: PPUSH
29678: CALL_OW 110
29682: PUSH
29683: LD_INT 0
29685: EQUAL
29686: IFFALSE 29702
// SetClass ( un , class_apeman_soldier ) else
29688: LD_VAR 0 2
29692: PPUSH
29693: LD_INT 15
29695: PPUSH
29696: CALL_OW 336
29700: GO 29733
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29702: LD_INT 3
29704: PPUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: CALL_OW 255
29714: PPUSH
29715: CALL_OW 321
29719: IFFALSE 29733
// SetClass ( un , class_apeman_kamikaze ) ;
29721: LD_VAR 0 2
29725: PPUSH
29726: LD_INT 17
29728: PPUSH
29729: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29733: LD_VAR 0 1
29737: PPUSH
29738: CALL_OW 266
29742: PUSH
29743: LD_INT 32
29745: EQUAL
29746: IFFALSE 29848
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29748: LD_ADDR_EXP 70
29752: PUSH
29753: LD_EXP 70
29757: PPUSH
29758: LD_VAR 0 1
29762: PPUSH
29763: CALL_OW 255
29767: PPUSH
29768: LD_EXP 70
29772: PUSH
29773: LD_VAR 0 1
29777: PPUSH
29778: CALL_OW 255
29782: ARRAY
29783: PUSH
29784: LD_INT 1
29786: PLUS
29787: PPUSH
29788: LD_VAR 0 1
29792: PPUSH
29793: CALL 31052 0 4
29797: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29798: LD_ADDR_EXP 70
29802: PUSH
29803: LD_EXP 70
29807: PPUSH
29808: LD_VAR 0 1
29812: PPUSH
29813: CALL_OW 255
29817: PPUSH
29818: LD_EXP 70
29822: PUSH
29823: LD_VAR 0 1
29827: PPUSH
29828: CALL_OW 255
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: PLUS
29837: PPUSH
29838: LD_VAR 0 2
29842: PPUSH
29843: CALL 31052 0 4
29847: ST_TO_ADDR
// end ; end ;
29848: PPOPN 2
29850: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL 56497 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29860: LD_VAR 0 1
29864: PUSH
29865: LD_INT 22
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 23
29877: PUSH
29878: LD_INT 3
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 21
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: LIST
29899: PPUSH
29900: CALL_OW 69
29904: IN
29905: IFFALSE 29921
// player_loss := player_loss + 1 ;
29907: LD_ADDR_EXP 10
29911: PUSH
29912: LD_EXP 10
29916: PUSH
29917: LD_INT 1
29919: PLUS
29920: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29921: LD_VAR 0 1
29925: PUSH
29926: LD_INT 22
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 21
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PPUSH
29950: CALL_OW 69
29954: IN
29955: PUSH
29956: LD_EXP 15
29960: NOT
29961: AND
29962: IFFALSE 30025
// begin alfa_north_triggered := true ;
29964: LD_ADDR_EXP 15
29968: PUSH
29969: LD_INT 1
29971: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29972: LD_EXP 5
29976: PPUSH
29977: LD_STRING DS4
29979: PPUSH
29980: CALL_OW 94
// Wait ( 1 1$25 ) ;
29984: LD_INT 2975
29986: PPUSH
29987: CALL_OW 67
// if not isTest then
29991: LD_EXP 1
29995: NOT
29996: IFFALSE 30025
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29998: LD_INT 20
30000: PPUSH
30001: LD_INT 5
30003: PUSH
30004: LD_INT 6
30006: PUSH
30007: LD_INT 7
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: PUSH
30015: LD_OWVAR 67
30019: ARRAY
30020: PPUSH
30021: CALL 7122 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30025: LD_VAR 0 1
30029: PUSH
30030: LD_INT 22
30032: PUSH
30033: LD_INT 4
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 21
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PPUSH
30054: CALL_OW 69
30058: IN
30059: PUSH
30060: LD_EXP 16
30064: NOT
30065: AND
30066: IFFALSE 30129
// begin alfa_south_triggered := true ;
30068: LD_ADDR_EXP 16
30072: PUSH
30073: LD_INT 1
30075: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30076: LD_EXP 4
30080: PPUSH
30081: LD_STRING DJ3
30083: PPUSH
30084: CALL_OW 94
// Wait ( 0 0$45 ) ;
30088: LD_INT 1575
30090: PPUSH
30091: CALL_OW 67
// if not isTest then
30095: LD_EXP 1
30099: NOT
30100: IFFALSE 30129
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30102: LD_INT 20
30104: PPUSH
30105: LD_INT 5
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: LD_INT 7
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: LIST
30118: PUSH
30119: LD_OWVAR 67
30123: ARRAY
30124: PPUSH
30125: CALL 7122 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30129: LD_VAR 0 1
30133: PPUSH
30134: CALL_OW 266
30138: PUSH
30139: LD_INT 1
30141: EQUAL
30142: PUSH
30143: LD_VAR 0 1
30147: PPUSH
30148: CALL_OW 255
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: LD_INT 4
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: IN
30163: AND
30164: IFFALSE 30173
// RaiseSailEvent ( 104 ) ;
30166: LD_INT 104
30168: PPUSH
30169: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30173: LD_EXP 41
30177: PUSH
30178: LD_VAR 0 1
30182: PPUSH
30183: CALL_OW 255
30187: ARRAY
30188: IFFALSE 30575
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30190: LD_STRING UnitDestroyed [side 
30192: PUSH
30193: LD_VAR 0 1
30197: PPUSH
30198: CALL_OW 255
30202: STR
30203: PUSH
30204: LD_STRING ; id: 
30206: STR
30207: PUSH
30208: LD_VAR 0 1
30212: STR
30213: PUSH
30214: LD_STRING ; type: 
30216: STR
30217: PUSH
30218: LD_VAR 0 1
30222: PPUSH
30223: CALL_OW 247
30227: STR
30228: PUSH
30229: LD_STRING ]
30231: STR
30232: PPUSH
30233: CALL 7984 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30237: LD_VAR 0 1
30241: PUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: CALL_OW 255
30251: PPUSH
30252: LD_INT 21
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PPUSH
30262: CALL 11587 0 2
30266: IN
30267: IFFALSE 30423
// begin if MCF_HasClass ( un ) then
30269: LD_VAR 0 1
30273: PPUSH
30274: CALL 14293 0 1
30278: IFFALSE 30423
// case MCF_HasClass ( un ) of 1 :
30280: LD_VAR 0 1
30284: PPUSH
30285: CALL 14293 0 1
30289: PUSH
30290: LD_INT 1
30292: DOUBLE
30293: EQUAL
30294: IFTRUE 30298
30296: GO 30323
30298: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30299: LD_VAR 0 1
30303: PPUSH
30304: CALL_OW 255
30308: PPUSH
30309: LD_STRING ToArm
30311: PPUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL 14466 0 3
30321: GO 30423
30323: LD_INT 2
30325: DOUBLE
30326: EQUAL
30327: IFTRUE 30331
30329: GO 30356
30331: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30332: LD_VAR 0 1
30336: PPUSH
30337: CALL_OW 255
30341: PPUSH
30342: LD_STRING ToDep
30344: PPUSH
30345: LD_VAR 0 1
30349: PPUSH
30350: CALL 14466 0 3
30354: GO 30423
30356: LD_INT 3
30358: DOUBLE
30359: EQUAL
30360: IFTRUE 30364
30362: GO 30389
30364: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30365: LD_VAR 0 1
30369: PPUSH
30370: CALL_OW 255
30374: PPUSH
30375: LD_STRING ToFac
30377: PPUSH
30378: LD_VAR 0 1
30382: PPUSH
30383: CALL 14466 0 3
30387: GO 30423
30389: LD_INT 4
30391: DOUBLE
30392: EQUAL
30393: IFTRUE 30397
30395: GO 30422
30397: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30398: LD_VAR 0 1
30402: PPUSH
30403: CALL_OW 255
30407: PPUSH
30408: LD_STRING ToLab
30410: PPUSH
30411: LD_VAR 0 1
30415: PPUSH
30416: CALL 14466 0 3
30420: GO 30423
30422: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30423: LD_VAR 0 1
30427: PUSH
30428: LD_EXP 69
30432: PUSH
30433: LD_VAR 0 1
30437: PPUSH
30438: CALL_OW 255
30442: ARRAY
30443: IN
30444: IFFALSE 30529
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30446: LD_ADDR_EXP 69
30450: PUSH
30451: LD_EXP 69
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: LD_INT 0
30463: PPUSH
30464: CALL 31211 0 3
30468: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30469: LD_VAR 0 1
30473: PPUSH
30474: CALL_OW 255
30478: PPUSH
30479: LD_VAR 0 1
30483: PPUSH
30484: CALL_OW 265
30488: PUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL_OW 262
30498: PUSH
30499: LD_VAR 0 1
30503: PPUSH
30504: CALL_OW 263
30508: PUSH
30509: LD_VAR 0 1
30513: PPUSH
30514: CALL_OW 264
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: PPUSH
30525: CALL 21106 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30529: LD_VAR 0 1
30533: PUSH
30534: LD_EXP 73
30538: PUSH
30539: LD_VAR 0 1
30543: PPUSH
30544: CALL_OW 255
30548: ARRAY
30549: IN
30550: IFFALSE 30575
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30552: LD_ADDR_EXP 73
30556: PUSH
30557: LD_EXP 73
30561: PPUSH
30562: LD_VAR 0 1
30566: PPUSH
30567: LD_INT 0
30569: PPUSH
30570: CALL 31211 0 3
30574: ST_TO_ADDR
// end ; end ;
30575: PPOPN 1
30577: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30578: LD_EXP 41
30582: PUSH
30583: LD_VAR 0 2
30587: PPUSH
30588: CALL_OW 255
30592: ARRAY
30593: IFFALSE 30765
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30595: LD_VAR 0 2
30599: PUSH
30600: LD_EXP 70
30604: PUSH
30605: LD_VAR 0 2
30609: PPUSH
30610: CALL_OW 255
30614: ARRAY
30615: IN
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 266
30626: PUSH
30627: LD_INT 32
30629: PUSH
30630: LD_INT 31
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: IN
30637: AND
30638: IFFALSE 30738
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30640: LD_ADDR_EXP 70
30644: PUSH
30645: LD_EXP 70
30649: PPUSH
30650: LD_VAR 0 1
30654: PPUSH
30655: LD_INT 0
30657: PPUSH
30658: CALL 31211 0 3
30662: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30663: LD_ADDR_EXP 70
30667: PUSH
30668: LD_EXP 70
30672: PPUSH
30673: LD_VAR 0 2
30677: PPUSH
30678: LD_INT 0
30680: PPUSH
30681: CALL 31211 0 3
30685: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30686: LD_EXP 70
30690: PUSH
30691: LD_VAR 0 2
30695: PPUSH
30696: CALL_OW 255
30700: ARRAY
30701: PUSH
30702: LD_STRING 
30704: EQUAL
30705: IFFALSE 30738
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30707: LD_ADDR_EXP 70
30711: PUSH
30712: LD_EXP 70
30716: PPUSH
30717: LD_VAR 0 2
30721: PPUSH
30722: CALL_OW 255
30726: PPUSH
30727: LD_INT 1
30729: PPUSH
30730: LD_INT 0
30732: PPUSH
30733: CALL 31052 0 4
30737: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30738: LD_VAR 0 1
30742: PPUSH
30743: CALL_OW 266
30747: PUSH
30748: LD_INT 36
30750: IN
30751: IFFALSE 30765
// SetTag ( un , 0 ) ;
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL_OW 109
// end ;
30765: PPOPN 2
30767: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30768: LD_EXP 41
30772: PUSH
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 255
30782: ARRAY
30783: IFFALSE 30809
// begin if GetControl ( un ) = control_remote then
30785: LD_VAR 0 1
30789: PPUSH
30790: CALL_OW 263
30794: PUSH
30795: LD_INT 2
30797: EQUAL
30798: IFFALSE 30809
// ComUnlink ( un ) ;
30800: LD_VAR 0 1
30804: PPUSH
30805: CALL_OW 136
// end ;
30809: PPOPN 1
30811: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30812: LD_EXP 41
30816: PUSH
30817: LD_VAR 0 1
30821: PPUSH
30822: CALL_OW 255
30826: ARRAY
30827: IFFALSE 30856
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30829: LD_VAR 0 2
30833: PPUSH
30834: CALL_OW 264
30838: PUSH
30839: LD_INT 31
30841: IN
30842: IFFALSE 30856
// SetTag ( driver , 0 ) ;
30844: LD_VAR 0 1
30848: PPUSH
30849: LD_INT 0
30851: PPUSH
30852: CALL_OW 109
// end ;
30856: PPOPN 4
30858: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30859: LD_INT 0
30861: PPUSH
30862: PPUSH
30863: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30864: LD_ADDR_VAR 0 3
30868: PUSH
30869: LD_VAR 0 1
30873: PPUSH
30874: CALL_OW 269
30878: ST_TO_ADDR
// x := GetX ( building ) ;
30879: LD_ADDR_VAR 0 4
30883: PUSH
30884: LD_VAR 0 1
30888: PPUSH
30889: CALL_OW 250
30893: ST_TO_ADDR
// y := GetY ( building ) ;
30894: LD_ADDR_VAR 0 5
30898: PUSH
30899: LD_VAR 0 1
30903: PPUSH
30904: CALL_OW 251
30908: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30909: LD_ADDR_EXP 45
30913: PUSH
30914: LD_EXP 45
30918: PPUSH
30919: LD_VAR 0 1
30923: PPUSH
30924: CALL_OW 255
30928: PPUSH
30929: LD_VAR 0 3
30933: PPUSH
30934: LD_VAR 0 4
30938: PUSH
30939: LD_VAR 0 5
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PPUSH
30948: CALL 41973 0 4
30952: ST_TO_ADDR
// end ;
30953: PPOPN 5
30955: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30956: LD_VAR 0 1
30960: PUSH
30961: LD_EXP 32
30965: IN
30966: NOT
30967: IFFALSE 31015
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30969: LD_ADDR_EXP 32
30973: PUSH
30974: LD_EXP 32
30978: PPUSH
30979: LD_EXP 32
30983: PUSH
30984: LD_INT 1
30986: PLUS
30987: PPUSH
30988: LD_VAR 0 1
30992: PPUSH
30993: CALL_OW 2
30997: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30998: LD_STRING DestinationUnrechable. [unit: 
31000: PUSH
31001: LD_VAR 0 1
31005: STR
31006: PUSH
31007: LD_STRING ]
31009: STR
31010: PPUSH
31011: CALL 7984 0 1
// end ; end ;
31015: PPOPN 1
31017: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31018: LD_VAR 0 1
31022: PPUSH
31023: LD_VAR 0 2
31027: PPUSH
31028: LD_VAR 0 3
31032: PPUSH
31033: CALL 56595 0 3
// end ;
31037: PPOPN 3
31039: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31040: LD_VAR 0 1
31044: PPUSH
31045: CALL 56603 0 1
// end ; end_of_file
31049: PPOPN 1
31051: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31052: LD_INT 0
31054: PPUSH
31055: PPUSH
31056: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31057: LD_ADDR_VAR 0 7
31061: PUSH
31062: LD_VAR 0 1
31066: PUSH
31067: LD_VAR 0 2
31071: ARRAY
31072: PPUSH
31073: LD_VAR 0 3
31077: PPUSH
31078: LD_VAR 0 4
31082: PPUSH
31083: CALL_OW 1
31087: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31088: LD_ADDR_VAR 0 1
31092: PUSH
31093: LD_VAR 0 1
31097: PPUSH
31098: LD_VAR 0 2
31102: PPUSH
31103: LD_VAR 0 7
31107: PPUSH
31108: CALL_OW 1
31112: ST_TO_ADDR
// result := tab ;
31113: LD_ADDR_VAR 0 5
31117: PUSH
31118: LD_VAR 0 1
31122: ST_TO_ADDR
// end ;
31123: LD_VAR 0 5
31127: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31128: LD_INT 0
31130: PPUSH
31131: PPUSH
31132: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31133: LD_ADDR_VAR 0 5
31137: PUSH
31138: LD_VAR 0 1
31142: PUSH
31143: LD_VAR 0 2
31147: PUSH
31148: LD_INT 1
31150: ARRAY
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 2
31157: PUSH
31158: LD_INT 2
31160: ARRAY
31161: PPUSH
31162: CALL_OW 3
31166: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31167: LD_ADDR_VAR 0 1
31171: PUSH
31172: LD_VAR 0 1
31176: PPUSH
31177: LD_VAR 0 2
31181: PUSH
31182: LD_INT 1
31184: ARRAY
31185: PPUSH
31186: LD_VAR 0 5
31190: PPUSH
31191: CALL_OW 1
31195: ST_TO_ADDR
// result := tab ;
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: LD_VAR 0 1
31205: ST_TO_ADDR
// end ;
31206: LD_VAR 0 3
31210: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31211: LD_INT 0
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
// i := 1 ;
31217: LD_ADDR_VAR 0 5
31221: PUSH
31222: LD_INT 1
31224: ST_TO_ADDR
// while ( i <= tab ) do
31225: LD_VAR 0 5
31229: PUSH
31230: LD_VAR 0 1
31234: LESSEQUAL
31235: IFFALSE 31610
// begin if not tab [ i ] then
31237: LD_VAR 0 1
31241: PUSH
31242: LD_VAR 0 5
31246: ARRAY
31247: NOT
31248: IFFALSE 31252
// break ;
31250: GO 31610
// if value in tab then
31252: LD_VAR 0 2
31256: PUSH
31257: LD_VAR 0 1
31261: IN
31262: IFFALSE 31375
// begin if not mode then
31264: LD_VAR 0 3
31268: NOT
31269: IFFALSE 31289
// tab := tab diff value else
31271: LD_ADDR_VAR 0 1
31275: PUSH
31276: LD_VAR 0 1
31280: PUSH
31281: LD_VAR 0 2
31285: DIFF
31286: ST_TO_ADDR
31287: GO 31351
// for j = 1 to tab do
31289: LD_ADDR_VAR 0 6
31293: PUSH
31294: DOUBLE
31295: LD_INT 1
31297: DEC
31298: ST_TO_ADDR
31299: LD_VAR 0 1
31303: PUSH
31304: FOR_TO
31305: IFFALSE 31349
// if tab [ j ] = value then
31307: LD_VAR 0 1
31311: PUSH
31312: LD_VAR 0 6
31316: ARRAY
31317: PUSH
31318: LD_VAR 0 2
31322: EQUAL
31323: IFFALSE 31347
// begin tab := Delete ( tab , j ) ;
31325: LD_ADDR_VAR 0 1
31329: PUSH
31330: LD_VAR 0 1
31334: PPUSH
31335: LD_VAR 0 6
31339: PPUSH
31340: CALL_OW 3
31344: ST_TO_ADDR
// break ;
31345: GO 31349
// end ;
31347: GO 31304
31349: POP
31350: POP
// i := i - 1 ;
31351: LD_ADDR_VAR 0 5
31355: PUSH
31356: LD_VAR 0 5
31360: PUSH
31361: LD_INT 1
31363: MINUS
31364: ST_TO_ADDR
// if mode then
31365: LD_VAR 0 3
31369: IFFALSE 31373
// break ;
31371: GO 31610
// end else
31373: GO 31594
// if tab [ i ] and value in tab [ i ] then
31375: LD_VAR 0 1
31379: PUSH
31380: LD_VAR 0 5
31384: ARRAY
31385: PUSH
31386: LD_VAR 0 2
31390: PUSH
31391: LD_VAR 0 1
31395: PUSH
31396: LD_VAR 0 5
31400: ARRAY
31401: IN
31402: AND
31403: IFFALSE 31594
// begin if not mode then
31405: LD_VAR 0 3
31409: NOT
31410: IFFALSE 31436
// tmp := tab [ i ] diff value else
31412: LD_ADDR_VAR 0 7
31416: PUSH
31417: LD_VAR 0 1
31421: PUSH
31422: LD_VAR 0 5
31426: ARRAY
31427: PUSH
31428: LD_VAR 0 2
31432: DIFF
31433: ST_TO_ADDR
31434: GO 31516
// for j = 1 to tab [ i ] do
31436: LD_ADDR_VAR 0 6
31440: PUSH
31441: DOUBLE
31442: LD_INT 1
31444: DEC
31445: ST_TO_ADDR
31446: LD_VAR 0 1
31450: PUSH
31451: LD_VAR 0 5
31455: ARRAY
31456: PUSH
31457: FOR_TO
31458: IFFALSE 31514
// if value = tab [ i ] [ j ] then
31460: LD_VAR 0 2
31464: PUSH
31465: LD_VAR 0 1
31469: PUSH
31470: LD_VAR 0 5
31474: ARRAY
31475: PUSH
31476: LD_VAR 0 6
31480: ARRAY
31481: EQUAL
31482: IFFALSE 31512
// begin tmp := Delete ( tab [ i ] , j ) ;
31484: LD_ADDR_VAR 0 7
31488: PUSH
31489: LD_VAR 0 1
31493: PUSH
31494: LD_VAR 0 5
31498: ARRAY
31499: PPUSH
31500: LD_VAR 0 6
31504: PPUSH
31505: CALL_OW 3
31509: ST_TO_ADDR
// break ;
31510: GO 31514
// end ;
31512: GO 31457
31514: POP
31515: POP
// if tmp = [ ] then
31516: LD_VAR 0 7
31520: PUSH
31521: EMPTY
31522: EQUAL
31523: IFFALSE 31547
// begin tab := Delete ( tab , i ) ;
31525: LD_ADDR_VAR 0 1
31529: PUSH
31530: LD_VAR 0 1
31534: PPUSH
31535: LD_VAR 0 5
31539: PPUSH
31540: CALL_OW 3
31544: ST_TO_ADDR
// end else
31545: GO 31572
// tab := Replace ( tab , i , tmp ) ;
31547: LD_ADDR_VAR 0 1
31551: PUSH
31552: LD_VAR 0 1
31556: PPUSH
31557: LD_VAR 0 5
31561: PPUSH
31562: LD_VAR 0 7
31566: PPUSH
31567: CALL_OW 1
31571: ST_TO_ADDR
// i := i - 1 ;
31572: LD_ADDR_VAR 0 5
31576: PUSH
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 1
31584: MINUS
31585: ST_TO_ADDR
// if mode then
31586: LD_VAR 0 3
31590: IFFALSE 31594
// break ;
31592: GO 31610
// end ; i := i + 1 ;
31594: LD_ADDR_VAR 0 5
31598: PUSH
31599: LD_VAR 0 5
31603: PUSH
31604: LD_INT 1
31606: PLUS
31607: ST_TO_ADDR
// end ;
31608: GO 31225
// result := tab ;
31610: LD_ADDR_VAR 0 4
31614: PUSH
31615: LD_VAR 0 1
31619: ST_TO_ADDR
// end ;
31620: LD_VAR 0 4
31624: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31625: LD_INT 0
31627: PPUSH
31628: PPUSH
// for i = 1 to values do
31629: LD_ADDR_VAR 0 4
31633: PUSH
31634: DOUBLE
31635: LD_INT 1
31637: DEC
31638: ST_TO_ADDR
31639: LD_VAR 0 2
31643: PUSH
31644: FOR_TO
31645: IFFALSE 31678
// tab := Remove ( tab , values [ i ] , false ) ;
31647: LD_ADDR_VAR 0 1
31651: PUSH
31652: LD_VAR 0 1
31656: PPUSH
31657: LD_VAR 0 2
31661: PUSH
31662: LD_VAR 0 4
31666: ARRAY
31667: PPUSH
31668: LD_INT 0
31670: PPUSH
31671: CALL 31211 0 3
31675: ST_TO_ADDR
31676: GO 31644
31678: POP
31679: POP
// result := tab ;
31680: LD_ADDR_VAR 0 3
31684: PUSH
31685: LD_VAR 0 1
31689: ST_TO_ADDR
// end ;
31690: LD_VAR 0 3
31694: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31695: LD_INT 0
31697: PPUSH
31698: PPUSH
31699: PPUSH
// if not GetControl ( veh ) = control_manual then
31700: LD_VAR 0 1
31704: PPUSH
31705: CALL_OW 263
31709: PUSH
31710: LD_INT 1
31712: EQUAL
31713: NOT
31714: IFFALSE 31726
// result := false else
31716: LD_ADDR_VAR 0 2
31720: PUSH
31721: LD_INT 0
31723: ST_TO_ADDR
31724: GO 31871
// if veh in FilterAllUnits ( [ f_empty ] ) then
31726: LD_VAR 0 1
31730: PUSH
31731: LD_INT 58
31733: PUSH
31734: EMPTY
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: IN
31742: IFFALSE 31754
// result := false else
31744: LD_ADDR_VAR 0 2
31748: PUSH
31749: LD_INT 0
31751: ST_TO_ADDR
31752: GO 31871
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31754: LD_ADDR_VAR 0 4
31758: PUSH
31759: LD_INT 22
31761: PUSH
31762: LD_VAR 0 1
31766: PPUSH
31767: CALL_OW 255
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 55
31778: PUSH
31779: EMPTY
31780: LIST
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PPUSH
31786: CALL_OW 69
31790: ST_TO_ADDR
// if not filter then
31791: LD_VAR 0 4
31795: NOT
31796: IFFALSE 31808
// result := false else
31798: LD_ADDR_VAR 0 2
31802: PUSH
31803: LD_INT 0
31805: ST_TO_ADDR
31806: GO 31871
// for i = 1 to filter do
31808: LD_ADDR_VAR 0 3
31812: PUSH
31813: DOUBLE
31814: LD_INT 1
31816: DEC
31817: ST_TO_ADDR
31818: LD_VAR 0 4
31822: PUSH
31823: FOR_TO
31824: IFFALSE 31869
// if IsDriver ( filter [ i ] ) = veh then
31826: LD_VAR 0 4
31830: PUSH
31831: LD_VAR 0 3
31835: ARRAY
31836: PPUSH
31837: CALL 94440 0 1
31841: PUSH
31842: LD_VAR 0 1
31846: EQUAL
31847: IFFALSE 31867
// begin result := filter [ i ] ;
31849: LD_ADDR_VAR 0 2
31853: PUSH
31854: LD_VAR 0 4
31858: PUSH
31859: LD_VAR 0 3
31863: ARRAY
31864: ST_TO_ADDR
// break ;
31865: GO 31869
// end ;
31867: GO 31823
31869: POP
31870: POP
// end ; end ;
31871: LD_VAR 0 2
31875: RET
// export function Compare ( val1 , val2 ) ; begin
31876: LD_INT 0
31878: PPUSH
// if val1 = val2 then
31879: LD_VAR 0 1
31883: PUSH
31884: LD_VAR 0 2
31888: EQUAL
31889: IFFALSE 31901
// result := true else
31891: LD_ADDR_VAR 0 3
31895: PUSH
31896: LD_INT 1
31898: ST_TO_ADDR
31899: GO 31909
// result := false ;
31901: LD_ADDR_VAR 0 3
31905: PUSH
31906: LD_INT 0
31908: ST_TO_ADDR
// end ;
31909: LD_VAR 0 3
31913: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31914: LD_INT 0
31916: PPUSH
31917: PPUSH
// result := false ;
31918: LD_ADDR_VAR 0 3
31922: PUSH
31923: LD_INT 0
31925: ST_TO_ADDR
// for j = 1 to e2 do
31926: LD_ADDR_VAR 0 4
31930: PUSH
31931: DOUBLE
31932: LD_INT 1
31934: DEC
31935: ST_TO_ADDR
31936: LD_VAR 0 2
31940: PUSH
31941: FOR_TO
31942: IFFALSE 31976
// if Compare ( e1 , e2 [ j ] ) then
31944: LD_VAR 0 1
31948: PPUSH
31949: LD_VAR 0 2
31953: PUSH
31954: LD_VAR 0 4
31958: ARRAY
31959: PPUSH
31960: CALL 31876 0 2
31964: IFFALSE 31974
// result := true ;
31966: LD_ADDR_VAR 0 3
31970: PUSH
31971: LD_INT 1
31973: ST_TO_ADDR
31974: GO 31941
31976: POP
31977: POP
// end ;
31978: LD_VAR 0 3
31982: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
31983: LD_INT 0
31985: PPUSH
31986: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
31987: LD_VAR 0 1
31991: PPUSH
31992: LD_STRING C
31994: PUSH
31995: LD_VAR 0 2
31999: PUSH
32000: LD_VAR 0 3
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: LD_INT 0
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: PUSH
32026: LD_STRING v
32028: PUSH
32029: LD_VAR 0 4
32033: PPUSH
32034: CALL_OW 250
32038: PUSH
32039: LD_VAR 0 4
32043: PPUSH
32044: CALL_OW 251
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PPUSH
32076: CALL_OW 446
// end ;
32080: LD_VAR 0 5
32084: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32085: LD_INT 0
32087: PPUSH
32088: PPUSH
32089: PPUSH
// linked := UnitsLinked ( unit ) ;
32090: LD_ADDR_VAR 0 4
32094: PUSH
32095: LD_VAR 0 1
32099: PPUSH
32100: CALL_OW 432
32104: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32105: LD_ADDR_VAR 0 3
32109: PUSH
32110: LD_VAR 0 1
32114: PPUSH
32115: LD_INT 3
32117: PPUSH
32118: CALL_OW 259
32122: ST_TO_ADDR
// if sk > linked then
32123: LD_VAR 0 3
32127: PUSH
32128: LD_VAR 0 4
32132: GREATER
32133: IFFALSE 32145
// result := true else
32135: LD_ADDR_VAR 0 2
32139: PUSH
32140: LD_INT 1
32142: ST_TO_ADDR
32143: GO 32153
// result := false ;
32145: LD_ADDR_VAR 0 2
32149: PUSH
32150: LD_INT 0
32152: ST_TO_ADDR
// end ;
32153: LD_VAR 0 2
32157: RET
// export function NotTask ( unit ) ; begin
32158: LD_INT 0
32160: PPUSH
// result := true ;
32161: LD_ADDR_VAR 0 2
32165: PUSH
32166: LD_INT 1
32168: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32169: LD_VAR 0 1
32173: PPUSH
32174: CALL_OW 437
32178: PUSH
32179: LD_VAR 0 1
32183: PPUSH
32184: CALL_OW 314
32188: OR
32189: IFFALSE 32199
// result := false ;
32191: LD_ADDR_VAR 0 2
32195: PUSH
32196: LD_INT 0
32198: ST_TO_ADDR
// end ;
32199: LD_VAR 0 2
32203: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
32209: PPUSH
32210: PPUSH
// dist := 99999 ;
32211: LD_ADDR_VAR 0 7
32215: PUSH
32216: LD_INT 99999
32218: ST_TO_ADDR
// un := - 1 ;
32219: LD_ADDR_VAR 0 6
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: ST_TO_ADDR
// if units1 and units2 then
32228: LD_VAR 0 1
32232: PUSH
32233: LD_VAR 0 2
32237: AND
32238: IFFALSE 32326
// for i in units1 do
32240: LD_ADDR_VAR 0 4
32244: PUSH
32245: LD_VAR 0 1
32249: PUSH
32250: FOR_IN
32251: IFFALSE 32324
// for j in units2 do
32253: LD_ADDR_VAR 0 5
32257: PUSH
32258: LD_VAR 0 2
32262: PUSH
32263: FOR_IN
32264: IFFALSE 32320
// if GetDistUnits ( i , j ) < dist then
32266: LD_VAR 0 4
32270: PPUSH
32271: LD_VAR 0 5
32275: PPUSH
32276: CALL_OW 296
32280: PUSH
32281: LD_VAR 0 7
32285: LESS
32286: IFFALSE 32318
// begin un := i ;
32288: LD_ADDR_VAR 0 6
32292: PUSH
32293: LD_VAR 0 4
32297: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32298: LD_ADDR_VAR 0 7
32302: PUSH
32303: LD_VAR 0 4
32307: PPUSH
32308: LD_VAR 0 5
32312: PPUSH
32313: CALL_OW 296
32317: ST_TO_ADDR
// end ;
32318: GO 32263
32320: POP
32321: POP
32322: GO 32250
32324: POP
32325: POP
// result := [ un , dist ] ;
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_VAR 0 6
32335: PUSH
32336: LD_VAR 0 7
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// end ;
32345: LD_VAR 0 3
32349: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32350: LD_INT 0
32352: PPUSH
32353: PPUSH
32354: PPUSH
32355: PPUSH
32356: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32357: LD_VAR 0 1
32361: NOT
32362: PUSH
32363: LD_VAR 0 1
32367: PPUSH
32368: CALL_OW 256
32372: PUSH
32373: LD_INT 250
32375: LESS
32376: OR
32377: PUSH
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 314
32387: PUSH
32388: LD_VAR 0 1
32392: PPUSH
32393: CALL_OW 261
32397: PUSH
32398: LD_INT 20
32400: GREATER
32401: AND
32402: OR
32403: IFFALSE 32407
// exit ;
32405: GO 32781
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32407: LD_VAR 0 1
32411: PPUSH
32412: CALL_OW 261
32416: PUSH
32417: LD_INT 20
32419: LESS
32420: PUSH
32421: LD_VAR 0 1
32425: PPUSH
32426: CALL_OW 110
32430: PUSH
32431: LD_INT 21
32433: EQUAL
32434: NOT
32435: AND
32436: IFFALSE 32472
// begin ComStop ( bulldozer ) ;
32438: LD_VAR 0 1
32442: PPUSH
32443: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32447: LD_VAR 0 1
32451: PPUSH
32452: LD_INT 21
32454: PPUSH
32455: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32459: LD_VAR 0 1
32463: PPUSH
32464: CALL 26214 0 1
// exit ;
32468: GO 32781
// end else
32470: GO 32499
// if GetFuel ( bulldozer ) > 20 then
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 261
32481: PUSH
32482: LD_INT 20
32484: GREATER
32485: IFFALSE 32499
// SetTag ( bulldozer , 0 ) ;
32487: LD_VAR 0 1
32491: PPUSH
32492: LD_INT 0
32494: PPUSH
32495: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32499: LD_ADDR_VAR 0 5
32503: PUSH
32504: LD_VAR 0 2
32508: PPUSH
32509: CALL_OW 353
32513: ST_TO_ADDR
// tmp := [ ] ;
32514: LD_ADDR_VAR 0 6
32518: PUSH
32519: EMPTY
32520: ST_TO_ADDR
// for i = 1 to list do
32521: LD_ADDR_VAR 0 4
32525: PUSH
32526: DOUBLE
32527: LD_INT 1
32529: DEC
32530: ST_TO_ADDR
32531: LD_VAR 0 5
32535: PUSH
32536: FOR_TO
32537: IFFALSE 32635
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32539: LD_VAR 0 5
32543: PUSH
32544: LD_VAR 0 4
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: ARRAY
32553: PPUSH
32554: LD_VAR 0 5
32558: PUSH
32559: LD_VAR 0 4
32563: ARRAY
32564: PUSH
32565: LD_INT 2
32567: ARRAY
32568: PPUSH
32569: CALL_OW 554
32573: IFFALSE 32633
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32575: LD_ADDR_VAR 0 6
32579: PUSH
32580: LD_VAR 0 6
32584: PPUSH
32585: LD_VAR 0 6
32589: PUSH
32590: LD_INT 1
32592: PLUS
32593: PPUSH
32594: LD_VAR 0 5
32598: PUSH
32599: LD_VAR 0 4
32603: ARRAY
32604: PUSH
32605: LD_INT 1
32607: ARRAY
32608: PUSH
32609: LD_VAR 0 5
32613: PUSH
32614: LD_VAR 0 4
32618: ARRAY
32619: PUSH
32620: LD_INT 2
32622: ARRAY
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PPUSH
32628: CALL_OW 1
32632: ST_TO_ADDR
// end ;
32633: GO 32536
32635: POP
32636: POP
// ComStop ( bulldozer ) ;
32637: LD_VAR 0 1
32641: PPUSH
32642: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32646: LD_ADDR_VAR 0 7
32650: PUSH
32651: LD_VAR 0 1
32655: PPUSH
32656: CALL_OW 250
32660: PUSH
32661: LD_VAR 0 1
32665: PPUSH
32666: CALL_OW 251
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: ST_TO_ADDR
// for i = tmp downto 1 do
32675: LD_ADDR_VAR 0 4
32679: PUSH
32680: DOUBLE
32681: LD_VAR 0 6
32685: INC
32686: ST_TO_ADDR
32687: LD_INT 1
32689: PUSH
32690: FOR_DOWNTO
32691: IFFALSE 32779
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32693: LD_ADDR_VAR 0 7
32697: PUSH
32698: LD_VAR 0 7
32702: PUSH
32703: LD_INT 1
32705: ARRAY
32706: PPUSH
32707: LD_VAR 0 7
32711: PUSH
32712: LD_INT 2
32714: ARRAY
32715: PPUSH
32716: LD_VAR 0 6
32720: PPUSH
32721: CALL 32882 0 3
32725: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32726: LD_VAR 0 1
32730: PPUSH
32731: LD_VAR 0 7
32735: PUSH
32736: LD_INT 1
32738: ARRAY
32739: PPUSH
32740: LD_VAR 0 7
32744: PUSH
32745: LD_INT 2
32747: ARRAY
32748: PPUSH
32749: CALL 32786 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32753: LD_ADDR_VAR 0 6
32757: PUSH
32758: LD_VAR 0 6
32762: PPUSH
32763: LD_VAR 0 7
32767: PUSH
32768: LD_INT 3
32770: ARRAY
32771: PPUSH
32772: CALL_OW 3
32776: ST_TO_ADDR
// end ;
32777: GO 32690
32779: POP
32780: POP
// end ;
32781: LD_VAR 0 3
32785: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32786: LD_INT 0
32788: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32789: LD_VAR 0 2
32793: PPUSH
32794: LD_VAR 0 3
32798: PPUSH
32799: CALL_OW 351
32803: PUSH
32804: LD_VAR 0 2
32808: PPUSH
32809: LD_VAR 0 3
32813: PPUSH
32814: CALL_OW 554
32818: AND
32819: PUSH
32820: LD_VAR 0 2
32824: PPUSH
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL_OW 488
32834: AND
32835: PUSH
32836: LD_VAR 0 2
32840: PPUSH
32841: LD_VAR 0 3
32845: PPUSH
32846: CALL_OW 428
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: EQUAL
32855: AND
32856: IFFALSE 32877
// AddComMoveXY ( bulldozer , x , y ) ;
32858: LD_VAR 0 1
32862: PPUSH
32863: LD_VAR 0 2
32867: PPUSH
32868: LD_VAR 0 3
32872: PPUSH
32873: CALL_OW 171
// end ;
32877: LD_VAR 0 4
32881: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32882: LD_INT 0
32884: PPUSH
32885: PPUSH
32886: PPUSH
32887: PPUSH
32888: PPUSH
32889: PPUSH
32890: PPUSH
// dist := 99999 ;
32891: LD_ADDR_VAR 0 6
32895: PUSH
32896: LD_INT 99999
32898: ST_TO_ADDR
// for i = 1 to list do
32899: LD_ADDR_VAR 0 5
32903: PUSH
32904: DOUBLE
32905: LD_INT 1
32907: DEC
32908: ST_TO_ADDR
32909: LD_VAR 0 3
32913: PUSH
32914: FOR_TO
32915: IFFALSE 33053
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32917: LD_ADDR_VAR 0 7
32921: PUSH
32922: LD_VAR 0 1
32926: PPUSH
32927: LD_VAR 0 2
32931: PPUSH
32932: LD_VAR 0 3
32936: PUSH
32937: LD_VAR 0 5
32941: ARRAY
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: LD_VAR 0 3
32951: PUSH
32952: LD_VAR 0 5
32956: ARRAY
32957: PUSH
32958: LD_INT 2
32960: ARRAY
32961: PPUSH
32962: CALL_OW 298
32966: ST_TO_ADDR
// if d = 0 then
32967: LD_VAR 0 7
32971: PUSH
32972: LD_INT 0
32974: EQUAL
32975: IFFALSE 32979
// continue ;
32977: GO 32914
// if d < dist then
32979: LD_VAR 0 7
32983: PUSH
32984: LD_VAR 0 6
32988: LESS
32989: IFFALSE 33051
// begin _x := list [ i ] [ 1 ] ;
32991: LD_ADDR_VAR 0 8
32995: PUSH
32996: LD_VAR 0 3
33000: PUSH
33001: LD_VAR 0 5
33005: ARRAY
33006: PUSH
33007: LD_INT 1
33009: ARRAY
33010: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33011: LD_ADDR_VAR 0 9
33015: PUSH
33016: LD_VAR 0 3
33020: PUSH
33021: LD_VAR 0 5
33025: ARRAY
33026: PUSH
33027: LD_INT 2
33029: ARRAY
33030: ST_TO_ADDR
// _i := i ;
33031: LD_ADDR_VAR 0 10
33035: PUSH
33036: LD_VAR 0 5
33040: ST_TO_ADDR
// dist := d ;
33041: LD_ADDR_VAR 0 6
33045: PUSH
33046: LD_VAR 0 7
33050: ST_TO_ADDR
// end ; end ;
33051: GO 32914
33053: POP
33054: POP
// result := [ _x , _y , _i , dist ] ;
33055: LD_ADDR_VAR 0 4
33059: PUSH
33060: LD_VAR 0 8
33064: PUSH
33065: LD_VAR 0 9
33069: PUSH
33070: LD_VAR 0 10
33074: PUSH
33075: LD_VAR 0 6
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// end ;
33086: LD_VAR 0 4
33090: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33091: LD_INT 0
33093: PPUSH
33094: PPUSH
33095: PPUSH
33096: PPUSH
33097: PPUSH
// for i = 1 to list do
33098: LD_ADDR_VAR 0 5
33102: PUSH
33103: DOUBLE
33104: LD_INT 1
33106: DEC
33107: ST_TO_ADDR
33108: LD_VAR 0 1
33112: PUSH
33113: FOR_TO
33114: IFFALSE 33428
// begin for j = list downto 2 do
33116: LD_ADDR_VAR 0 6
33120: PUSH
33121: DOUBLE
33122: LD_VAR 0 1
33126: INC
33127: ST_TO_ADDR
33128: LD_INT 2
33130: PUSH
33131: FOR_DOWNTO
33132: IFFALSE 33424
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33134: LD_VAR 0 2
33138: PPUSH
33139: LD_VAR 0 3
33143: PPUSH
33144: LD_VAR 0 1
33148: PUSH
33149: LD_VAR 0 6
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: ARRAY
33158: PPUSH
33159: LD_VAR 0 1
33163: PUSH
33164: LD_VAR 0 6
33168: ARRAY
33169: PUSH
33170: LD_INT 2
33172: ARRAY
33173: PPUSH
33174: CALL_OW 298
33178: PUSH
33179: LD_VAR 0 2
33183: PPUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: LD_VAR 0 1
33193: PUSH
33194: LD_VAR 0 6
33198: PUSH
33199: LD_INT 1
33201: MINUS
33202: ARRAY
33203: PUSH
33204: LD_INT 1
33206: ARRAY
33207: PPUSH
33208: LD_VAR 0 1
33212: PUSH
33213: LD_VAR 0 6
33217: PUSH
33218: LD_INT 1
33220: MINUS
33221: ARRAY
33222: PUSH
33223: LD_INT 2
33225: ARRAY
33226: PPUSH
33227: CALL_OW 298
33231: LESS
33232: IFFALSE 33422
// begin _x := list [ j ] [ 1 ] ;
33234: LD_ADDR_VAR 0 7
33238: PUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 1
33252: ARRAY
33253: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33254: LD_ADDR_VAR 0 8
33258: PUSH
33259: LD_VAR 0 1
33263: PUSH
33264: LD_VAR 0 6
33268: ARRAY
33269: PUSH
33270: LD_INT 2
33272: ARRAY
33273: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33274: LD_ADDR_VAR 0 1
33278: PUSH
33279: LD_VAR 0 1
33283: PPUSH
33284: LD_VAR 0 6
33288: PPUSH
33289: LD_INT 1
33291: PPUSH
33292: LD_VAR 0 1
33296: PUSH
33297: LD_VAR 0 6
33301: PUSH
33302: LD_INT 1
33304: MINUS
33305: ARRAY
33306: PUSH
33307: LD_INT 1
33309: ARRAY
33310: PPUSH
33311: CALL 31052 0 4
33315: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33316: LD_ADDR_VAR 0 1
33320: PUSH
33321: LD_VAR 0 1
33325: PPUSH
33326: LD_VAR 0 6
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: LD_VAR 0 1
33338: PUSH
33339: LD_VAR 0 6
33343: PUSH
33344: LD_INT 1
33346: MINUS
33347: ARRAY
33348: PUSH
33349: LD_INT 2
33351: ARRAY
33352: PPUSH
33353: CALL 31052 0 4
33357: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_VAR 0 1
33367: PPUSH
33368: LD_VAR 0 6
33372: PUSH
33373: LD_INT 1
33375: MINUS
33376: PPUSH
33377: LD_INT 1
33379: PPUSH
33380: LD_VAR 0 7
33384: PPUSH
33385: CALL 31052 0 4
33389: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33390: LD_ADDR_VAR 0 1
33394: PUSH
33395: LD_VAR 0 1
33399: PPUSH
33400: LD_VAR 0 6
33404: PUSH
33405: LD_INT 1
33407: MINUS
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 8
33416: PPUSH
33417: CALL 31052 0 4
33421: ST_TO_ADDR
// end ; end ;
33422: GO 33131
33424: POP
33425: POP
// end ;
33426: GO 33113
33428: POP
33429: POP
// result := list ;
33430: LD_ADDR_VAR 0 4
33434: PUSH
33435: LD_VAR 0 1
33439: ST_TO_ADDR
// end ;
33440: LD_VAR 0 4
33444: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33445: LD_INT 0
33447: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33448: LD_ADDR_VAR 0 5
33452: PUSH
33453: LD_VAR 0 1
33457: PPUSH
33458: LD_VAR 0 2
33462: PPUSH
33463: CALL_OW 546
33467: PUSH
33468: LD_INT 2
33470: ARRAY
33471: PUSH
33472: LD_VAR 0 3
33476: PPUSH
33477: LD_VAR 0 4
33481: PPUSH
33482: CALL_OW 546
33486: PUSH
33487: LD_INT 2
33489: ARRAY
33490: MINUS
33491: ST_TO_ADDR
// if result < 0 then
33492: LD_VAR 0 5
33496: PUSH
33497: LD_INT 0
33499: LESS
33500: IFFALSE 33517
// result := result * - 1 ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_VAR 0 5
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: MUL
33516: ST_TO_ADDR
// end ;
33517: LD_VAR 0 5
33521: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33522: LD_INT 0
33524: PPUSH
33525: PPUSH
// area = ListEnvironmentArea ( area ) ;
33526: LD_ADDR_VAR 0 2
33530: PUSH
33531: LD_VAR 0 2
33535: PPUSH
33536: CALL_OW 353
33540: ST_TO_ADDR
// if bulldozer > 0 then
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 0
33548: GREATER
33549: IFFALSE 33660
// for i = area downto 1 do
33551: LD_ADDR_VAR 0 4
33555: PUSH
33556: DOUBLE
33557: LD_VAR 0 2
33561: INC
33562: ST_TO_ADDR
33563: LD_INT 1
33565: PUSH
33566: FOR_DOWNTO
33567: IFFALSE 33658
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33569: LD_VAR 0 2
33573: PUSH
33574: LD_VAR 0 4
33578: ARRAY
33579: PUSH
33580: LD_INT 1
33582: ARRAY
33583: PPUSH
33584: LD_VAR 0 2
33588: PUSH
33589: LD_VAR 0 4
33593: ARRAY
33594: PUSH
33595: LD_INT 2
33597: ARRAY
33598: PPUSH
33599: CALL_OW 351
33603: IFFALSE 33656
// if not HasTask ( bulldozer ) then
33605: LD_VAR 0 1
33609: PPUSH
33610: CALL_OW 314
33614: NOT
33615: IFFALSE 33656
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33617: LD_VAR 0 1
33621: PPUSH
33622: LD_VAR 0 2
33626: PUSH
33627: LD_VAR 0 4
33631: ARRAY
33632: PUSH
33633: LD_INT 1
33635: ARRAY
33636: PPUSH
33637: LD_VAR 0 2
33641: PUSH
33642: LD_VAR 0 4
33646: ARRAY
33647: PUSH
33648: LD_INT 2
33650: ARRAY
33651: PPUSH
33652: CALL_OW 171
33656: GO 33566
33658: POP
33659: POP
// end ;
33660: LD_VAR 0 3
33664: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33665: LD_INT 0
33667: PPUSH
33668: PPUSH
33669: PPUSH
33670: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33671: LD_ADDR_VAR 0 6
33675: PUSH
33676: LD_INT 22
33678: PUSH
33679: LD_VAR 0 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 21
33690: PUSH
33691: LD_VAR 0 2
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PPUSH
33704: CALL_OW 69
33708: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33709: LD_ADDR_VAR 0 7
33713: PUSH
33714: LD_VAR 0 3
33718: PPUSH
33719: LD_INT 22
33721: PUSH
33722: LD_VAR 0 1
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 21
33733: PUSH
33734: LD_VAR 0 2
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PPUSH
33747: CALL_OW 70
33751: ST_TO_ADDR
// if tmp and pom then
33752: LD_VAR 0 6
33756: PUSH
33757: LD_VAR 0 7
33761: AND
33762: IFFALSE 33782
// result := tmp diff pom else
33764: LD_ADDR_VAR 0 4
33768: PUSH
33769: LD_VAR 0 6
33773: PUSH
33774: LD_VAR 0 7
33778: DIFF
33779: ST_TO_ADDR
33780: GO 33790
// result := false ;
33782: LD_ADDR_VAR 0 4
33786: PUSH
33787: LD_INT 0
33789: ST_TO_ADDR
// end ;
33790: LD_VAR 0 4
33794: RET
// export function SavePosition ( unit ) ; begin
33795: LD_INT 0
33797: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33798: LD_VAR 0 1
33802: PPUSH
33803: LD_VAR 0 1
33807: PPUSH
33808: CALL_OW 250
33812: PPUSH
33813: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33817: LD_VAR 0 1
33821: PPUSH
33822: LD_VAR 0 1
33826: PPUSH
33827: CALL_OW 251
33831: PPUSH
33832: CALL_OW 232
// end ;
33836: LD_VAR 0 2
33840: RET
// export function GetPosition ( unit ) ; begin
33841: LD_INT 0
33843: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33844: LD_ADDR_VAR 0 2
33848: PUSH
33849: LD_VAR 0 1
33853: PPUSH
33854: CALL_OW 252
33858: PUSH
33859: LD_VAR 0 1
33863: PPUSH
33864: CALL_OW 253
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: ST_TO_ADDR
// end ;
33873: LD_VAR 0 2
33877: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33878: LD_INT 0
33880: PPUSH
// if unit in unreachableList then
33881: LD_VAR 0 1
33885: PUSH
33886: LD_EXP 32
33890: IN
33891: IFFALSE 33909
// unreachableList := unreachableList diff unit ;
33893: LD_ADDR_EXP 32
33897: PUSH
33898: LD_EXP 32
33902: PUSH
33903: LD_VAR 0 1
33907: DIFF
33908: ST_TO_ADDR
// if ValidHex ( x , y ) then
33909: LD_VAR 0 2
33913: PPUSH
33914: LD_VAR 0 3
33918: PPUSH
33919: CALL_OW 488
33923: IFFALSE 33949
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33925: LD_VAR 0 1
33929: PPUSH
33930: LD_VAR 0 2
33934: PPUSH
33935: LD_VAR 0 3
33939: PPUSH
33940: CALL_OW 428
33944: PPUSH
33945: CALL_OW 115
// Wait ( 3 ) ;
33949: LD_INT 3
33951: PPUSH
33952: CALL_OW 67
// if unit in unreachableList then
33956: LD_VAR 0 1
33960: PUSH
33961: LD_EXP 32
33965: IN
33966: IFFALSE 33978
// result := false else
33968: LD_ADDR_VAR 0 4
33972: PUSH
33973: LD_INT 0
33975: ST_TO_ADDR
33976: GO 33986
// result := true ;
33978: LD_ADDR_VAR 0 4
33982: PUSH
33983: LD_INT 1
33985: ST_TO_ADDR
// end ; end_of_file
33986: LD_VAR 0 4
33990: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
33991: LD_EXP 33
33995: IFFALSE 34057
33997: GO 33999
33999: DISABLE
34000: LD_INT 0
34002: PPUSH
// begin enable ;
34003: ENABLE
// for i = 1 to mc_crates_list do
34004: LD_ADDR_VAR 0 1
34008: PUSH
34009: DOUBLE
34010: LD_INT 1
34012: DEC
34013: ST_TO_ADDR
34014: LD_EXP 34
34018: PUSH
34019: FOR_TO
34020: IFFALSE 34051
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34022: LD_EXP 34
34026: PUSH
34027: LD_VAR 0 1
34031: ARRAY
34032: PPUSH
34033: LD_INT 5
34035: PPUSH
34036: LD_INT 50
34038: PPUSH
34039: LD_INT 700
34041: PPUSH
34042: LD_INT 20
34044: PPUSH
34045: CALL 24421 0 5
34049: GO 34019
34051: POP
34052: POP
// MC_Game ( ) ;
34053: CALL 34060 0 0
// end ;
34057: PPOPN 1
34059: END
// export function MC_Game ( ) ; var i , side , un ; begin
34060: LD_INT 0
34062: PPUSH
34063: PPUSH
34064: PPUSH
34065: PPUSH
// if not isTest then
34066: LD_EXP 1
34070: NOT
34071: IFFALSE 34091
// MC_Show ( [ #tick , tick ] ) else
34073: LD_STRING #tick
34075: PUSH
34076: LD_OWVAR 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PPUSH
34085: CALL 8505 0 1
34089: GO 34100
// MC_Show ( debug_string ) ;
34091: LD_EXP 2
34095: PPUSH
34096: CALL 8505 0 1
// for side = 1 to 8 do
34100: LD_ADDR_VAR 0 3
34104: PUSH
34105: DOUBLE
34106: LD_INT 1
34108: DEC
34109: ST_TO_ADDR
34110: LD_INT 8
34112: PUSH
34113: FOR_TO
34114: IFFALSE 36114
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34116: LD_EXP 41
34120: PUSH
34121: LD_VAR 0 3
34125: ARRAY
34126: PUSH
34127: LD_INT 0
34129: EQUAL
34130: PUSH
34131: LD_VAR 0 3
34135: PPUSH
34136: EMPTY
34137: PPUSH
34138: CALL 11722 0 2
34142: PUSH
34143: LD_INT 0
34145: EQUAL
34146: OR
34147: IFFALSE 34151
// continue ;
34149: GO 34113
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34151: LD_VAR 0 3
34155: PPUSH
34156: LD_VAR 0 3
34160: PPUSH
34161: CALL 24942 0 1
34165: PPUSH
34166: CALL 36121 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34170: LD_EXP 73
34174: PUSH
34175: LD_VAR 0 3
34179: ARRAY
34180: PUSH
34181: LD_INT 1
34183: ARRAY
34184: PUSH
34185: LD_INT 0
34187: GREATER
34188: PUSH
34189: LD_EXP 71
34193: PUSH
34194: LD_VAR 0 3
34198: ARRAY
34199: PUSH
34200: LD_INT 1
34202: ARRAY
34203: PUSH
34204: LD_INT 0
34206: EQUAL
34207: AND
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: LD_INT 7
34216: PPUSH
34217: EMPTY
34218: PPUSH
34219: CALL 12290 0 3
34223: NOT
34224: AND
34225: IFFALSE 34296
// begin if side = 1 then
34227: LD_VAR 0 3
34231: PUSH
34232: LD_INT 1
34234: EQUAL
34235: IFFALSE 34244
// RaiseSailEvent ( 101 ) ;
34237: LD_INT 101
34239: PPUSH
34240: CALL_OW 427
// if side = 4 then
34244: LD_VAR 0 3
34248: PUSH
34249: LD_INT 4
34251: EQUAL
34252: IFFALSE 34261
// RaiseSailEvent ( 102 ) ;
34254: LD_INT 102
34256: PPUSH
34257: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34261: LD_ADDR_VAR 0 2
34265: PUSH
34266: LD_EXP 73
34270: PUSH
34271: LD_VAR 0 3
34275: ARRAY
34276: PUSH
34277: FOR_IN
34278: IFFALSE 34294
// SetTag ( i , 7 ) ;
34280: LD_VAR 0 2
34284: PPUSH
34285: LD_INT 7
34287: PPUSH
34288: CALL_OW 109
34292: GO 34277
34294: POP
34295: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34296: LD_VAR 0 3
34300: PPUSH
34301: LD_INT 7
34303: PPUSH
34304: EMPTY
34305: PPUSH
34306: CALL 12290 0 3
34310: IFFALSE 34336
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34312: LD_VAR 0 3
34316: PPUSH
34317: LD_VAR 0 3
34321: PPUSH
34322: LD_INT 7
34324: PPUSH
34325: EMPTY
34326: PPUSH
34327: CALL 12290 0 3
34331: PPUSH
34332: CALL 8432 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34336: LD_VAR 0 3
34340: PPUSH
34341: CALL 17970 0 1
34345: PUSH
34346: LD_VAR 0 3
34350: PPUSH
34351: CALL 11626 0 1
34355: AND
34356: IFFALSE 34367
// MCL_Start ( side ) ;
34358: LD_VAR 0 3
34362: PPUSH
34363: CALL 17927 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34367: LD_ADDR_EXP 37
34371: PUSH
34372: LD_EXP 37
34376: PPUSH
34377: LD_VAR 0 3
34381: PPUSH
34382: LD_VAR 0 3
34386: PPUSH
34387: CALL 19227 0 1
34391: PPUSH
34392: CALL_OW 1
34396: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34397: LD_ADDR_EXP 49
34401: PUSH
34402: LD_EXP 49
34406: PPUSH
34407: LD_VAR 0 3
34411: PPUSH
34412: LD_VAR 0 3
34416: PPUSH
34417: CALL 11040 0 1
34421: PPUSH
34422: CALL_OW 1
34426: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34427: LD_VAR 0 3
34431: PPUSH
34432: LD_INT 21
34434: PUSH
34435: LD_INT 2
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PPUSH
34442: CALL 11587 0 2
34446: IFFALSE 34457
// MCV_CheckStatus ( side ) ;
34448: LD_VAR 0 3
34452: PPUSH
34453: CALL 27124 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_EXP 55
34466: PPUSH
34467: CALL 42921 0 2
34471: IFFALSE 34556
// begin for i = MREG_ToChangeClass downto 1 do
34473: LD_ADDR_VAR 0 2
34477: PUSH
34478: DOUBLE
34479: LD_EXP 55
34483: INC
34484: ST_TO_ADDR
34485: LD_INT 1
34487: PUSH
34488: FOR_DOWNTO
34489: IFFALSE 34554
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34491: LD_EXP 55
34495: PUSH
34496: LD_VAR 0 2
34500: ARRAY
34501: PUSH
34502: LD_INT 1
34504: ARRAY
34505: PUSH
34506: LD_VAR 0 3
34510: EQUAL
34511: IFFALSE 34552
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34513: LD_VAR 0 3
34517: PPUSH
34518: LD_EXP 55
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: PUSH
34529: LD_INT 2
34531: ARRAY
34532: PPUSH
34533: LD_EXP 55
34537: PUSH
34538: LD_VAR 0 2
34542: ARRAY
34543: PUSH
34544: LD_INT 3
34546: ARRAY
34547: PPUSH
34548: CALL 16494 0 3
// end ; end ;
34552: GO 34488
34554: POP
34555: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34556: LD_INT 1
34558: PUSH
34559: LD_EXP 40
34563: PUSH
34564: LD_VAR 0 3
34568: ARRAY
34569: IN
34570: IFFALSE 34581
// begin MCN_TrainApe ( side ) ;
34572: LD_VAR 0 3
34576: PPUSH
34577: CALL 18880 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34581: LD_VAR 0 3
34585: PPUSH
34586: LD_INT 30
34588: PUSH
34589: LD_INT 3
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PPUSH
34596: CALL 11587 0 2
34600: IFFALSE 34774
// begin if MCF_Tag ( side , 10 , [ ] ) then
34602: LD_VAR 0 3
34606: PPUSH
34607: LD_INT 10
34609: PPUSH
34610: EMPTY
34611: PPUSH
34612: CALL 12290 0 3
34616: IFFALSE 34663
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34618: LD_VAR 0 3
34622: PPUSH
34623: LD_INT 10
34625: PPUSH
34626: EMPTY
34627: PPUSH
34628: CALL 12290 0 3
34632: PPUSH
34633: LD_VAR 0 3
34637: PPUSH
34638: LD_INT 30
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PPUSH
34648: CALL 11587 0 2
34652: PUSH
34653: LD_INT 1
34655: ARRAY
34656: PPUSH
34657: CALL_OW 168
// end else
34661: GO 34774
// if MREG_ToConstruct [ side ] then
34663: LD_EXP 53
34667: PUSH
34668: LD_VAR 0 3
34672: ARRAY
34673: IFFALSE 34774
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 30
34687: PUSH
34688: LD_INT 3
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PPUSH
34695: CALL 11587 0 2
34699: PUSH
34700: LD_INT 1
34702: ARRAY
34703: PPUSH
34704: LD_EXP 53
34708: PUSH
34709: LD_VAR 0 3
34713: ARRAY
34714: PUSH
34715: LD_INT 1
34717: ARRAY
34718: PUSH
34719: LD_EXP 53
34723: PUSH
34724: LD_VAR 0 3
34728: ARRAY
34729: PUSH
34730: LD_INT 2
34732: ARRAY
34733: PUSH
34734: LD_EXP 53
34738: PUSH
34739: LD_VAR 0 3
34743: ARRAY
34744: PUSH
34745: LD_INT 3
34747: ARRAY
34748: PUSH
34749: LD_EXP 53
34753: PUSH
34754: LD_VAR 0 3
34758: ARRAY
34759: PUSH
34760: LD_INT 4
34762: ARRAY
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: PPUSH
34770: CALL 25432 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11587 0 2
34793: PUSH
34794: LD_VAR 0 3
34798: PPUSH
34799: LD_EXP 45
34803: PPUSH
34804: CALL 42921 0 2
34808: AND
34809: PUSH
34810: LD_INT 22
34812: PUSH
34813: LD_VAR 0 3
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: PUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 33
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 30
34837: PUSH
34838: LD_INT 32
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 35
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: LIST
34864: PPUSH
34865: CALL_OW 69
34869: AND
34870: IFFALSE 34881
// MCV_Turret ( side ) ;
34872: LD_VAR 0 3
34876: PPUSH
34877: CALL 25869 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34881: LD_EXP 44
34885: PUSH
34886: LD_VAR 0 3
34890: ARRAY
34891: PUSH
34892: LD_INT 1
34894: GREATER
34895: PUSH
34896: LD_VAR 0 3
34900: PPUSH
34901: CALL 24942 0 1
34905: PUSH
34906: LD_INT 0
34908: EQUAL
34909: AND
34910: IFFALSE 35072
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34912: LD_EXP 44
34916: PUSH
34917: LD_VAR 0 3
34921: ARRAY
34922: PUSH
34923: LD_INT 1
34925: ARRAY
34926: PPUSH
34927: CALL_OW 353
34931: IFFALSE 34969
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
34933: LD_EXP 44
34937: PUSH
34938: LD_VAR 0 3
34942: ARRAY
34943: PUSH
34944: LD_INT 2
34946: ARRAY
34947: PPUSH
34948: LD_EXP 44
34952: PUSH
34953: LD_VAR 0 3
34957: ARRAY
34958: PUSH
34959: LD_INT 1
34961: ARRAY
34962: PPUSH
34963: CALL 32350 0 2
34967: GO 35072
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
34969: LD_VAR 0 3
34973: PPUSH
34974: LD_INT 30
34976: PUSH
34977: LD_INT 3
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PPUSH
34984: CALL 11587 0 2
34988: IFFALSE 35072
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
34990: LD_VAR 0 3
34994: PPUSH
34995: LD_INT 30
34997: PUSH
34998: LD_INT 3
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PPUSH
35005: CALL 11587 0 2
35009: PUSH
35010: LD_INT 1
35012: ARRAY
35013: PPUSH
35014: CALL_OW 461
35018: PUSH
35019: LD_INT 2
35021: EQUAL
35022: IFFALSE 35072
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35024: LD_EXP 44
35028: PUSH
35029: LD_VAR 0 3
35033: ARRAY
35034: PUSH
35035: LD_INT 2
35037: ARRAY
35038: PPUSH
35039: LD_INT 10
35041: PPUSH
35042: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35046: LD_ADDR_EXP 44
35050: PUSH
35051: LD_EXP 44
35055: PPUSH
35056: LD_VAR 0 3
35060: PPUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: PPUSH
35067: CALL_OW 1
35071: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35072: LD_VAR 0 3
35076: PPUSH
35077: LD_INT 33
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PPUSH
35087: CALL 11587 0 2
35091: IFFALSE 35131
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35093: LD_VAR 0 3
35097: PPUSH
35098: LD_VAR 0 3
35102: PPUSH
35103: LD_INT 33
35105: PUSH
35106: LD_INT 2
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PPUSH
35113: CALL 11587 0 2
35117: PUSH
35118: LD_INT 1
35120: ARRAY
35121: PPUSH
35122: CALL_OW 248
35126: PPUSH
35127: CALL 26423 0 2
// if MREG_ToRepair [ side ] then
35131: LD_EXP 49
35135: PUSH
35136: LD_VAR 0 3
35140: ARRAY
35141: IFFALSE 35154
// begin MCB_Repair ( side ) ;
35143: LD_VAR 0 3
35147: PPUSH
35148: CALL 11327 0 1
// end else
35152: GO 36067
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35154: LD_VAR 0 3
35158: PPUSH
35159: LD_EXP 51
35163: PPUSH
35164: CALL 42921 0 2
35168: PUSH
35169: LD_VAR 0 3
35173: PPUSH
35174: LD_EXP 42
35178: PPUSH
35179: CALL 42921 0 2
35183: AND
35184: IFFALSE 35392
// begin for i = 1 to MREG_ToUpLab do
35186: LD_ADDR_VAR 0 2
35190: PUSH
35191: DOUBLE
35192: LD_INT 1
35194: DEC
35195: ST_TO_ADDR
35196: LD_EXP 51
35200: PUSH
35201: FOR_TO
35202: IFFALSE 35388
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35204: LD_EXP 51
35208: PUSH
35209: LD_VAR 0 2
35213: ARRAY
35214: PUSH
35215: LD_INT 1
35217: ARRAY
35218: PUSH
35219: LD_VAR 0 3
35223: EQUAL
35224: IFFALSE 35386
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35226: LD_EXP 51
35230: PUSH
35231: LD_VAR 0 2
35235: ARRAY
35236: PUSH
35237: LD_INT 2
35239: ARRAY
35240: PUSH
35241: LD_EXP 51
35245: PUSH
35246: LD_VAR 0 2
35250: ARRAY
35251: PUSH
35252: LD_INT 3
35254: ARRAY
35255: AND
35256: IFFALSE 35384
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35258: LD_VAR 0 3
35262: PPUSH
35263: LD_EXP 51
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PUSH
35274: LD_INT 2
35276: ARRAY
35277: PPUSH
35278: LD_EXP 51
35282: PUSH
35283: LD_VAR 0 2
35287: ARRAY
35288: PUSH
35289: LD_INT 3
35291: ARRAY
35292: PPUSH
35293: CALL 8851 0 3
35297: IFFALSE 35384
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35299: LD_ADDR_EXP 51
35303: PUSH
35304: LD_EXP 51
35308: PPUSH
35309: LD_VAR 0 3
35313: PPUSH
35314: LD_EXP 51
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PUSH
35325: LD_INT 2
35327: ARRAY
35328: PPUSH
35329: LD_EXP 51
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_INT 3
35342: ARRAY
35343: PPUSH
35344: CALL 41973 0 4
35348: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35349: LD_ADDR_EXP 42
35353: PUSH
35354: LD_EXP 42
35358: PPUSH
35359: LD_VAR 0 3
35363: PPUSH
35364: LD_EXP 42
35368: PUSH
35369: LD_INT 1
35371: ARRAY
35372: PUSH
35373: LD_INT 2
35375: ARRAY
35376: PPUSH
35377: EMPTY
35378: PPUSH
35379: CALL 41973 0 4
35383: ST_TO_ADDR
// end ; break ;
35384: GO 35388
// end ;
35386: GO 35201
35388: POP
35389: POP
// end else
35390: GO 36067
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35392: LD_VAR 0 3
35396: PPUSH
35397: LD_EXP 50
35401: PPUSH
35402: CALL 42921 0 2
35406: IFFALSE 35480
// begin for i = 1 to MREG_ToUpdate do
35408: LD_ADDR_VAR 0 2
35412: PUSH
35413: DOUBLE
35414: LD_INT 1
35416: DEC
35417: ST_TO_ADDR
35418: LD_EXP 50
35422: PUSH
35423: FOR_TO
35424: IFFALSE 35476
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35426: LD_EXP 50
35430: PUSH
35431: LD_VAR 0 2
35435: ARRAY
35436: PUSH
35437: LD_INT 1
35439: ARRAY
35440: PUSH
35441: LD_VAR 0 3
35445: EQUAL
35446: IFFALSE 35474
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35448: LD_VAR 0 3
35452: PPUSH
35453: LD_EXP 50
35457: PUSH
35458: LD_VAR 0 2
35462: ARRAY
35463: PUSH
35464: LD_INT 2
35466: ARRAY
35467: PPUSH
35468: CALL 8687 0 2
// break ;
35472: GO 35476
// end ;
35474: GO 35423
35476: POP
35477: POP
// end else
35478: GO 36067
// if MCF_Get ( side , [ f_constructed ] ) then
35480: LD_VAR 0 3
35484: PPUSH
35485: LD_INT 57
35487: PUSH
35488: EMPTY
35489: LIST
35490: PPUSH
35491: CALL 11587 0 2
35495: IFFALSE 35528
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35497: LD_VAR 0 3
35501: PPUSH
35502: LD_VAR 0 3
35506: PPUSH
35507: LD_INT 57
35509: PUSH
35510: EMPTY
35511: LIST
35512: PPUSH
35513: CALL 11587 0 2
35517: PUSH
35518: LD_INT 1
35520: ARRAY
35521: PPUSH
35522: CALL 10931 0 2
35526: GO 36067
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PPUSH
35538: CALL 42921 0 2
35542: PUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 345
35552: NOT
35553: AND
35554: PUSH
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL 24942 0 1
35564: PUSH
35565: LD_INT 0
35567: EQUAL
35568: AND
35569: IFFALSE 35968
// begin for i = 1 to MREG_ToBuild do
35571: LD_ADDR_VAR 0 2
35575: PUSH
35576: DOUBLE
35577: LD_INT 1
35579: DEC
35580: ST_TO_ADDR
35581: LD_EXP 48
35585: PUSH
35586: FOR_TO
35587: IFFALSE 35964
// if MREG_ToBuild [ i ] [ 1 ] = side then
35589: LD_EXP 48
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: PUSH
35600: LD_INT 1
35602: ARRAY
35603: PUSH
35604: LD_VAR 0 3
35608: EQUAL
35609: IFFALSE 35962
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35611: LD_OWVAR 84
35615: PUSH
35616: LD_EXP 48
35620: PUSH
35621: LD_VAR 0 2
35625: ARRAY
35626: PUSH
35627: LD_INT 3
35629: ARRAY
35630: PUSH
35631: LD_INT 1
35633: ARRAY
35634: PPUSH
35635: LD_EXP 48
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 3
35648: ARRAY
35649: PUSH
35650: LD_INT 2
35652: ARRAY
35653: PPUSH
35654: CALL_OW 351
35658: AND
35659: IFFALSE 35703
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35661: LD_EXP 48
35665: PUSH
35666: LD_VAR 0 2
35670: ARRAY
35671: PUSH
35672: LD_INT 3
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PPUSH
35680: LD_EXP 48
35684: PUSH
35685: LD_VAR 0 2
35689: ARRAY
35690: PUSH
35691: LD_INT 3
35693: ARRAY
35694: PUSH
35695: LD_INT 2
35697: ARRAY
35698: PPUSH
35699: CALL 22735 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35703: LD_EXP 48
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_INT 2
35716: ARRAY
35717: PUSH
35718: LD_INT 0
35720: EQUAL
35721: IFFALSE 35791
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35723: LD_VAR 0 3
35727: PPUSH
35728: LD_EXP 48
35732: PUSH
35733: LD_VAR 0 2
35737: ARRAY
35738: PUSH
35739: LD_INT 3
35741: ARRAY
35742: PUSH
35743: LD_INT 1
35745: ARRAY
35746: PPUSH
35747: LD_EXP 48
35751: PUSH
35752: LD_VAR 0 2
35756: ARRAY
35757: PUSH
35758: LD_INT 3
35760: ARRAY
35761: PUSH
35762: LD_INT 2
35764: ARRAY
35765: PPUSH
35766: LD_EXP 48
35770: PUSH
35771: LD_VAR 0 2
35775: ARRAY
35776: PUSH
35777: LD_INT 3
35779: ARRAY
35780: PUSH
35781: LD_INT 3
35783: ARRAY
35784: PPUSH
35785: CALL 8523 0 4
35789: GO 35960
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35791: LD_EXP 48
35795: PUSH
35796: LD_VAR 0 2
35800: ARRAY
35801: PUSH
35802: LD_INT 2
35804: ARRAY
35805: PUSH
35806: LD_INT 6
35808: EQUAL
35809: IFFALSE 35879
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35811: LD_VAR 0 3
35815: PPUSH
35816: LD_EXP 48
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: PUSH
35827: LD_INT 3
35829: ARRAY
35830: PUSH
35831: LD_INT 1
35833: ARRAY
35834: PPUSH
35835: LD_EXP 48
35839: PUSH
35840: LD_VAR 0 2
35844: ARRAY
35845: PUSH
35846: LD_INT 3
35848: ARRAY
35849: PUSH
35850: LD_INT 2
35852: ARRAY
35853: PPUSH
35854: LD_EXP 48
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PUSH
35865: LD_INT 3
35867: ARRAY
35868: PUSH
35869: LD_INT 3
35871: ARRAY
35872: PPUSH
35873: CALL 8652 0 4
35877: GO 35960
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35879: LD_VAR 0 3
35883: PPUSH
35884: LD_EXP 48
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: PUSH
35895: LD_INT 2
35897: ARRAY
35898: PPUSH
35899: LD_EXP 48
35903: PUSH
35904: LD_VAR 0 2
35908: ARRAY
35909: PUSH
35910: LD_INT 3
35912: ARRAY
35913: PUSH
35914: LD_INT 1
35916: ARRAY
35917: PPUSH
35918: LD_EXP 48
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: PUSH
35929: LD_INT 3
35931: ARRAY
35932: PUSH
35933: LD_INT 2
35935: ARRAY
35936: PPUSH
35937: LD_EXP 48
35941: PUSH
35942: LD_VAR 0 2
35946: ARRAY
35947: PUSH
35948: LD_INT 3
35950: ARRAY
35951: PUSH
35952: LD_INT 3
35954: ARRAY
35955: PPUSH
35956: CALL 10156 0 5
// break ;
35960: GO 35964
// end ;
35962: GO 35586
35964: POP
35965: POP
// end else
35966: GO 36067
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
35968: LD_VAR 0 3
35972: PPUSH
35973: LD_EXP 54
35977: PPUSH
35978: CALL 42921 0 2
35982: PUSH
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL 24942 0 1
35992: PUSH
35993: LD_INT 0
35995: EQUAL
35996: AND
35997: IFFALSE 36067
// begin for i = 1 to MREG_ToDismantle do
35999: LD_ADDR_VAR 0 2
36003: PUSH
36004: DOUBLE
36005: LD_INT 1
36007: DEC
36008: ST_TO_ADDR
36009: LD_EXP 54
36013: PUSH
36014: FOR_TO
36015: IFFALSE 36065
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36017: LD_EXP 54
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 1
36030: ARRAY
36031: PUSH
36032: LD_VAR 0 3
36036: EQUAL
36037: IFFALSE 36063
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36039: LD_VAR 0 3
36043: PPUSH
36044: LD_EXP 54
36048: PUSH
36049: LD_VAR 0 2
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: CALL 10822 0 2
// end ;
36063: GO 36014
36065: POP
36066: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36067: LD_VAR 0 3
36071: PPUSH
36072: LD_INT 30
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PPUSH
36082: CALL 11587 0 2
36086: PUSH
36087: LD_VAR 0 3
36091: PPUSH
36092: CALL 24942 0 1
36096: PUSH
36097: LD_INT 0
36099: EQUAL
36100: AND
36101: IFFALSE 36112
// MCT_CollectCrates ( side ) ;
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL 23881 0 1
// end ;
36112: GO 34113
36114: POP
36115: POP
// end ;
36116: LD_VAR 0 1
36120: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36121: LD_INT 0
36123: PPUSH
36124: PPUSH
36125: PPUSH
36126: PPUSH
36127: PPUSH
36128: PPUSH
36129: PPUSH
36130: PPUSH
36131: PPUSH
36132: PPUSH
36133: PPUSH
36134: PPUSH
36135: PPUSH
36136: PPUSH
36137: PPUSH
// all := MCF_All ( side , [ ] ) ;
36138: LD_ADDR_VAR 0 17
36142: PUSH
36143: LD_VAR 0 1
36147: PPUSH
36148: EMPTY
36149: PPUSH
36150: CALL 11722 0 2
36154: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36155: LD_ADDR_VAR 0 13
36159: PUSH
36160: LD_VAR 0 1
36164: PPUSH
36165: LD_INT 1
36167: PPUSH
36168: EMPTY
36169: PPUSH
36170: CALL 11670 0 3
36174: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36175: LD_ADDR_VAR 0 14
36179: PUSH
36180: LD_VAR 0 1
36184: PPUSH
36185: LD_INT 2
36187: PPUSH
36188: EMPTY
36189: PPUSH
36190: CALL 11670 0 3
36194: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36195: LD_ADDR_VAR 0 15
36199: PUSH
36200: LD_VAR 0 1
36204: PPUSH
36205: LD_INT 3
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL 11670 0 3
36214: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36215: LD_ADDR_VAR 0 16
36219: PUSH
36220: LD_VAR 0 1
36224: PPUSH
36225: LD_INT 4
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11670 0 3
36234: ST_TO_ADDR
// if mech then
36235: LD_VAR 0 15
36239: IFFALSE 36256
// mech := MCF_SortListDesc ( mech ) ;
36241: LD_ADDR_VAR 0 15
36245: PUSH
36246: LD_VAR 0 15
36250: PPUSH
36251: CALL 12836 0 1
36255: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36256: LD_EXP 58
36260: PUSH
36261: LD_VAR 0 1
36265: ARRAY
36266: PUSH
36267: LD_STRING 
36269: EQUAL
36270: NOT
36271: IFFALSE 36327
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36273: LD_EXP 58
36277: PUSH
36278: LD_VAR 0 1
36282: ARRAY
36283: PUSH
36284: LD_INT 1
36286: ARRAY
36287: PPUSH
36288: CALL_OW 257
36292: PUSH
36293: LD_INT 1
36295: EQUAL
36296: IFFALSE 36325
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_STRING ToArm
36305: PPUSH
36306: LD_EXP 58
36310: PUSH
36311: LD_VAR 0 1
36315: ARRAY
36316: PUSH
36317: LD_INT 1
36319: ARRAY
36320: PPUSH
36321: CALL 14466 0 3
// end else
36325: GO 36353
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36327: LD_ADDR_EXP 58
36331: PUSH
36332: LD_EXP 58
36336: PPUSH
36337: LD_VAR 0 1
36341: PPUSH
36342: LD_INT 1
36344: PPUSH
36345: LD_INT 0
36347: PPUSH
36348: CALL 31052 0 4
36352: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36353: LD_EXP 59
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_STRING 
36366: EQUAL
36367: NOT
36368: IFFALSE 36424
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36370: LD_EXP 59
36374: PUSH
36375: LD_VAR 0 1
36379: ARRAY
36380: PUSH
36381: LD_INT 1
36383: ARRAY
36384: PPUSH
36385: CALL_OW 257
36389: PUSH
36390: LD_INT 2
36392: EQUAL
36393: IFFALSE 36422
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_STRING ToDep
36402: PPUSH
36403: LD_EXP 59
36407: PUSH
36408: LD_VAR 0 1
36412: ARRAY
36413: PUSH
36414: LD_INT 1
36416: ARRAY
36417: PPUSH
36418: CALL 14466 0 3
// end else
36422: GO 36450
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36424: LD_ADDR_EXP 59
36428: PUSH
36429: LD_EXP 59
36433: PPUSH
36434: LD_VAR 0 1
36438: PPUSH
36439: LD_INT 1
36441: PPUSH
36442: LD_INT 0
36444: PPUSH
36445: CALL 31052 0 4
36449: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_STRING 
36463: EQUAL
36464: NOT
36465: IFFALSE 36521
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36467: LD_EXP 57
36471: PUSH
36472: LD_VAR 0 1
36476: ARRAY
36477: PUSH
36478: LD_INT 1
36480: ARRAY
36481: PPUSH
36482: CALL_OW 257
36486: PUSH
36487: LD_INT 3
36489: EQUAL
36490: IFFALSE 36519
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36492: LD_VAR 0 1
36496: PPUSH
36497: LD_STRING ToFac
36499: PPUSH
36500: LD_EXP 57
36504: PUSH
36505: LD_VAR 0 1
36509: ARRAY
36510: PUSH
36511: LD_INT 1
36513: ARRAY
36514: PPUSH
36515: CALL 14466 0 3
// end else
36519: GO 36547
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36521: LD_ADDR_EXP 57
36525: PUSH
36526: LD_EXP 57
36530: PPUSH
36531: LD_VAR 0 1
36535: PPUSH
36536: LD_INT 1
36538: PPUSH
36539: LD_INT 0
36541: PPUSH
36542: CALL 31052 0 4
36546: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36547: LD_EXP 56
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_STRING 
36560: EQUAL
36561: NOT
36562: IFFALSE 36618
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36564: LD_EXP 56
36568: PUSH
36569: LD_VAR 0 1
36573: ARRAY
36574: PUSH
36575: LD_INT 1
36577: ARRAY
36578: PPUSH
36579: CALL_OW 257
36583: PUSH
36584: LD_INT 4
36586: EQUAL
36587: IFFALSE 36616
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36589: LD_VAR 0 1
36593: PPUSH
36594: LD_STRING ToLab
36596: PPUSH
36597: LD_EXP 56
36601: PUSH
36602: LD_VAR 0 1
36606: ARRAY
36607: PUSH
36608: LD_INT 1
36610: ARRAY
36611: PPUSH
36612: CALL 14466 0 3
// end else
36616: GO 36644
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36618: LD_ADDR_EXP 56
36622: PUSH
36623: LD_EXP 56
36627: PPUSH
36628: LD_VAR 0 1
36632: PPUSH
36633: LD_INT 1
36635: PPUSH
36636: LD_INT 0
36638: PPUSH
36639: CALL 31052 0 4
36643: ST_TO_ADDR
// if mode = 0 then
36644: LD_VAR 0 2
36648: PUSH
36649: LD_INT 0
36651: EQUAL
36652: IFFALSE 38490
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36654: LD_VAR 0 1
36658: PPUSH
36659: LD_INT 30
36661: PUSH
36662: LD_INT 1
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PPUSH
36669: CALL 11587 0 2
36673: PUSH
36674: LD_VAR 0 1
36678: PPUSH
36679: LD_INT 21
36681: PUSH
36682: LD_INT 3
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PPUSH
36689: CALL 11587 0 2
36693: PUSH
36694: LD_INT 1
36696: EQUAL
36697: AND
36698: IFFALSE 36763
// begin if all then
36700: LD_VAR 0 17
36704: IFFALSE 36761
// for i in ( all diff eng ) do
36706: LD_ADDR_VAR 0 4
36710: PUSH
36711: LD_VAR 0 17
36715: PUSH
36716: LD_VAR 0 14
36720: DIFF
36721: PUSH
36722: FOR_IN
36723: IFFALSE 36759
// if GetTag ( i ) = 0 then
36725: LD_VAR 0 4
36729: PPUSH
36730: CALL_OW 110
36734: PUSH
36735: LD_INT 0
36737: EQUAL
36738: IFFALSE 36757
// MCH_ChangeClass ( side , i , 2 ) ;
36740: LD_VAR 0 1
36744: PPUSH
36745: LD_VAR 0 4
36749: PPUSH
36750: LD_INT 2
36752: PPUSH
36753: CALL 16494 0 3
36757: GO 36722
36759: POP
36760: POP
// end else
36761: GO 37082
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36763: LD_VAR 0 13
36767: PUSH
36768: LD_EXP 58
36772: PUSH
36773: LD_VAR 0 1
36777: ARRAY
36778: PLUS
36779: PUSH
36780: LD_INT 22
36782: PUSH
36783: LD_VAR 0 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 30
36794: PUSH
36795: LD_INT 32
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PPUSH
36806: CALL_OW 69
36810: LESS
36811: IFFALSE 36836
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36813: LD_VAR 0 1
36817: PPUSH
36818: LD_VAR 0 14
36822: PUSH
36823: LD_INT 1
36825: ARRAY
36826: PPUSH
36827: LD_INT 1
36829: PPUSH
36830: CALL 16494 0 3
// end else
36834: GO 37082
// if sci < 6 and MCF_Lab ( side ) then
36836: LD_VAR 0 16
36840: PUSH
36841: LD_INT 6
36843: LESS
36844: PUSH
36845: LD_VAR 0 1
36849: PPUSH
36850: CALL 11626 0 1
36854: AND
36855: IFFALSE 36960
// begin if MREG_ToBunker [ side ] then
36857: LD_EXP 70
36861: PUSH
36862: LD_VAR 0 1
36866: ARRAY
36867: IFFALSE 36893
// tmp := sol diff MREG_ToBunker [ side ] else
36869: LD_ADDR_VAR 0 12
36873: PUSH
36874: LD_VAR 0 13
36878: PUSH
36879: LD_EXP 70
36883: PUSH
36884: LD_VAR 0 1
36888: ARRAY
36889: DIFF
36890: ST_TO_ADDR
36891: GO 36903
// tmp := sol ;
36893: LD_ADDR_VAR 0 12
36897: PUSH
36898: LD_VAR 0 13
36902: ST_TO_ADDR
// if tmp then
36903: LD_VAR 0 12
36907: IFFALSE 36958
// for i in tmp do
36909: LD_ADDR_VAR 0 4
36913: PUSH
36914: LD_VAR 0 12
36918: PUSH
36919: FOR_IN
36920: IFFALSE 36956
// if GetTag ( i ) = 0 then
36922: LD_VAR 0 4
36926: PPUSH
36927: CALL_OW 110
36931: PUSH
36932: LD_INT 0
36934: EQUAL
36935: IFFALSE 36954
// MCH_ChangeClass ( side , i , 4 ) ;
36937: LD_VAR 0 1
36941: PPUSH
36942: LD_VAR 0 4
36946: PPUSH
36947: LD_INT 4
36949: PPUSH
36950: CALL 16494 0 3
36954: GO 36919
36956: POP
36957: POP
// end else
36958: GO 37082
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
36960: LD_VAR 0 1
36964: PPUSH
36965: LD_INT 30
36967: PUSH
36968: LD_INT 1
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL 11587 0 2
36979: IFFALSE 37082
// begin if MREG_ToBunker [ side ] then
36981: LD_EXP 70
36985: PUSH
36986: LD_VAR 0 1
36990: ARRAY
36991: IFFALSE 37017
// tmp := sol diff MREG_ToBunker [ side ] else
36993: LD_ADDR_VAR 0 12
36997: PUSH
36998: LD_VAR 0 13
37002: PUSH
37003: LD_EXP 70
37007: PUSH
37008: LD_VAR 0 1
37012: ARRAY
37013: DIFF
37014: ST_TO_ADDR
37015: GO 37027
// tmp := sol ;
37017: LD_ADDR_VAR 0 12
37021: PUSH
37022: LD_VAR 0 13
37026: ST_TO_ADDR
// if tmp then
37027: LD_VAR 0 12
37031: IFFALSE 37082
// for i in tmp do
37033: LD_ADDR_VAR 0 4
37037: PUSH
37038: LD_VAR 0 12
37042: PUSH
37043: FOR_IN
37044: IFFALSE 37080
// if GetTag ( i ) = 0 then
37046: LD_VAR 0 4
37050: PPUSH
37051: CALL_OW 110
37055: PUSH
37056: LD_INT 0
37058: EQUAL
37059: IFFALSE 37078
// MCH_ChangeClass ( side , i , 2 ) ;
37061: LD_VAR 0 1
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: LD_INT 2
37073: PPUSH
37074: CALL 16494 0 3
37078: GO 37043
37080: POP
37081: POP
// end ; if MCF_Lab ( side ) then
37082: LD_VAR 0 1
37086: PPUSH
37087: CALL 11626 0 1
37091: IFFALSE 37631
// begin if MCL_GetTechList ( side ) then
37093: LD_VAR 0 1
37097: PPUSH
37098: CALL 17970 0 1
37102: IFFALSE 37228
// begin if MREG_ToLab [ side ] then
37104: LD_EXP 56
37108: PUSH
37109: LD_VAR 0 1
37113: ARRAY
37114: IFFALSE 37134
// k := MREG_ToLab [ side ] else
37116: LD_ADDR_VAR 0 8
37120: PUSH
37121: LD_EXP 56
37125: PUSH
37126: LD_VAR 0 1
37130: ARRAY
37131: ST_TO_ADDR
37132: GO 37142
// k := 0 ;
37134: LD_ADDR_VAR 0 8
37138: PUSH
37139: LD_INT 0
37141: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37142: LD_VAR 0 16
37146: PUSH
37147: LD_VAR 0 8
37151: PLUS
37152: PUSH
37153: LD_INT 6
37155: LESSEQUAL
37156: PUSH
37157: LD_VAR 0 17
37161: PUSH
37162: LD_INT 6
37164: GREATER
37165: AND
37166: IFFALSE 37182
// MCH_TrainScientist ( side , 1 ) else
37168: LD_VAR 0 1
37172: PPUSH
37173: LD_INT 1
37175: PPUSH
37176: CALL 16046 0 2
37180: GO 37226
// if all < 6 then
37182: LD_VAR 0 17
37186: PUSH
37187: LD_INT 6
37189: LESS
37190: IFFALSE 37226
// if sci + k < all / 2 then
37192: LD_VAR 0 16
37196: PUSH
37197: LD_VAR 0 8
37201: PLUS
37202: PUSH
37203: LD_VAR 0 17
37207: PUSH
37208: LD_INT 2
37210: DIVREAL
37211: LESS
37212: IFFALSE 37226
// MCH_TrainScientist ( side , 1 ) ;
37214: LD_VAR 0 1
37218: PPUSH
37219: LD_INT 1
37221: PPUSH
37222: CALL 16046 0 2
// end else
37226: GO 37304
// begin if sci > 2 then
37228: LD_VAR 0 16
37232: PUSH
37233: LD_INT 2
37235: GREATER
37236: IFFALSE 37304
// for i = sci downto 2 do
37238: LD_ADDR_VAR 0 4
37242: PUSH
37243: DOUBLE
37244: LD_VAR 0 16
37248: INC
37249: ST_TO_ADDR
37250: LD_INT 2
37252: PUSH
37253: FOR_DOWNTO
37254: IFFALSE 37302
// if GetTag ( sci [ i ] ) = 0 then
37256: LD_VAR 0 16
37260: PUSH
37261: LD_VAR 0 4
37265: ARRAY
37266: PPUSH
37267: CALL_OW 110
37271: PUSH
37272: LD_INT 0
37274: EQUAL
37275: IFFALSE 37300
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37277: LD_VAR 0 1
37281: PPUSH
37282: LD_VAR 0 16
37286: PUSH
37287: LD_VAR 0 4
37291: ARRAY
37292: PPUSH
37293: LD_INT 2
37295: PPUSH
37296: CALL 16494 0 3
37300: GO 37253
37302: POP
37303: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37304: LD_VAR 0 1
37308: PPUSH
37309: CALL 17970 0 1
37313: PUSH
37314: LD_VAR 0 1
37318: PPUSH
37319: CALL 11626 0 1
37323: AND
37324: PUSH
37325: LD_EXP 37
37329: PUSH
37330: LD_VAR 0 1
37334: ARRAY
37335: NOT
37336: AND
37337: IFFALSE 37631
// begin for j = 1 to MCF_Lab ( side ) do
37339: LD_ADDR_VAR 0 5
37343: PUSH
37344: DOUBLE
37345: LD_INT 1
37347: DEC
37348: ST_TO_ADDR
37349: LD_VAR 0 1
37353: PPUSH
37354: CALL 11626 0 1
37358: PUSH
37359: FOR_TO
37360: IFFALSE 37420
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37362: LD_VAR 0 1
37366: PPUSH
37367: CALL 11626 0 1
37371: PUSH
37372: LD_VAR 0 5
37376: ARRAY
37377: PPUSH
37378: CALL_OW 461
37382: PUSH
37383: LD_INT 3
37385: PUSH
37386: LD_INT 6
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: IN
37393: IFFALSE 37418
// begin b := MCF_Lab ( side ) [ j ] ;
37395: LD_ADDR_VAR 0 11
37399: PUSH
37400: LD_VAR 0 1
37404: PPUSH
37405: CALL 11626 0 1
37409: PUSH
37410: LD_VAR 0 5
37414: ARRAY
37415: ST_TO_ADDR
// break ;
37416: GO 37420
// end ;
37418: GO 37359
37420: POP
37421: POP
// if MCF_Class ( side , 4 , [ ] ) then
37422: LD_VAR 0 1
37426: PPUSH
37427: LD_INT 4
37429: PPUSH
37430: EMPTY
37431: PPUSH
37432: CALL 11670 0 3
37436: IFFALSE 37631
// for j in MCF_Class ( side , 4 , [ ] ) do
37438: LD_ADDR_VAR 0 5
37442: PUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: LD_INT 4
37450: PPUSH
37451: EMPTY
37452: PPUSH
37453: CALL 11670 0 3
37457: PUSH
37458: FOR_IN
37459: IFFALSE 37629
// begin if GetTag ( j ) = 0 then
37461: LD_VAR 0 5
37465: PPUSH
37466: CALL_OW 110
37470: PUSH
37471: LD_INT 0
37473: EQUAL
37474: IFFALSE 37565
// begin if IsInUnit ( j ) and b then
37476: LD_VAR 0 5
37480: PPUSH
37481: CALL_OW 310
37485: PUSH
37486: LD_VAR 0 11
37490: AND
37491: IFFALSE 37539
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37493: LD_VAR 0 5
37497: PPUSH
37498: CALL_OW 310
37502: PPUSH
37503: CALL_OW 461
37507: PUSH
37508: LD_INT 2
37510: EQUAL
37511: PUSH
37512: LD_VAR 0 5
37516: PPUSH
37517: CALL_OW 310
37521: PUSH
37522: LD_VAR 0 11
37526: NONEQUAL
37527: AND
37528: IFFALSE 37539
// ComExitBuilding ( j ) ;
37530: LD_VAR 0 5
37534: PPUSH
37535: CALL_OW 122
// if not IsInUnit ( j ) then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 310
37548: NOT
37549: IFFALSE 37565
// ComEnterUnit ( j , b ) ;
37551: LD_VAR 0 5
37555: PPUSH
37556: LD_VAR 0 11
37560: PPUSH
37561: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37565: LD_INT 1
37567: PPUSH
37568: LD_VAR 0 5
37572: PPUSH
37573: CALL_OW 255
37577: PPUSH
37578: CALL_OW 321
37582: PUSH
37583: LD_INT 2
37585: EQUAL
37586: PUSH
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 255
37596: PPUSH
37597: CALL 24942 0 1
37601: PUSH
37602: LD_INT 0
37604: EQUAL
37605: AND
37606: IFFALSE 37627
// MCN_Tame ( GetSide ( j ) , j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 255
37617: PPUSH
37618: LD_VAR 0 5
37622: PPUSH
37623: CALL 18489 0 2
// end ;
37627: GO 37458
37629: POP
37630: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37631: LD_VAR 0 1
37635: PPUSH
37636: LD_INT 30
37638: PUSH
37639: LD_INT 3
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PPUSH
37646: CALL 11587 0 2
37650: IFFALSE 37909
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37652: LD_ADDR_VAR 0 11
37656: PUSH
37657: LD_VAR 0 1
37661: PPUSH
37662: LD_INT 30
37664: PUSH
37665: LD_INT 3
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PPUSH
37672: CALL 11587 0 2
37676: PUSH
37677: LD_INT 1
37679: ARRAY
37680: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37681: LD_ADDR_VAR 0 12
37685: PUSH
37686: LD_VAR 0 1
37690: PPUSH
37691: LD_INT 0
37693: PPUSH
37694: LD_INT 25
37696: PUSH
37697: LD_INT 3
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PPUSH
37704: CALL 12290 0 3
37708: ST_TO_ADDR
// for i = 1 to tmp do
37709: LD_ADDR_VAR 0 4
37713: PUSH
37714: DOUBLE
37715: LD_INT 1
37717: DEC
37718: ST_TO_ADDR
37719: LD_VAR 0 12
37723: PUSH
37724: FOR_TO
37725: IFFALSE 37785
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37727: LD_VAR 0 12
37731: PUSH
37732: LD_VAR 0 4
37736: ARRAY
37737: PPUSH
37738: CALL_OW 310
37742: NOT
37743: PUSH
37744: LD_VAR 0 12
37748: PUSH
37749: LD_VAR 0 4
37753: ARRAY
37754: PPUSH
37755: CALL_OW 314
37759: NOT
37760: AND
37761: IFFALSE 37783
// ComEnterUnit ( tmp [ i ] , b ) ;
37763: LD_VAR 0 12
37767: PUSH
37768: LD_VAR 0 4
37772: ARRAY
37773: PPUSH
37774: LD_VAR 0 11
37778: PPUSH
37779: CALL_OW 120
37783: GO 37724
37785: POP
37786: POP
// if MREG_ToFac [ side ] then
37787: LD_EXP 57
37791: PUSH
37792: LD_VAR 0 1
37796: ARRAY
37797: IFFALSE 37817
// k := MREG_ToFac [ side ] else
37799: LD_ADDR_VAR 0 8
37803: PUSH
37804: LD_EXP 57
37808: PUSH
37809: LD_VAR 0 1
37813: ARRAY
37814: ST_TO_ADDR
37815: GO 37825
// k := 0 ;
37817: LD_ADDR_VAR 0 8
37821: PUSH
37822: LD_INT 0
37824: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37825: LD_VAR 0 15
37829: PUSH
37830: LD_VAR 0 8
37834: PLUS
37835: PUSH
37836: LD_INT 6
37838: LESSEQUAL
37839: PUSH
37840: LD_VAR 0 17
37844: PUSH
37845: LD_INT 6
37847: GREATER
37848: AND
37849: IFFALSE 37865
// MCH_TrainMechanic ( side , 1 ) else
37851: LD_VAR 0 1
37855: PPUSH
37856: LD_INT 1
37858: PPUSH
37859: CALL 15788 0 2
37863: GO 37909
// if all < 6 then
37865: LD_VAR 0 17
37869: PUSH
37870: LD_INT 6
37872: LESS
37873: IFFALSE 37909
// if mech + k < all / 2 then
37875: LD_VAR 0 15
37879: PUSH
37880: LD_VAR 0 8
37884: PLUS
37885: PUSH
37886: LD_VAR 0 17
37890: PUSH
37891: LD_INT 2
37893: DIVREAL
37894: LESS
37895: IFFALSE 37909
// MCH_TrainMechanic ( side , 1 ) ;
37897: LD_VAR 0 1
37901: PPUSH
37902: LD_INT 1
37904: PPUSH
37905: CALL 15788 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37909: LD_ADDR_VAR 0 10
37913: PUSH
37914: LD_VAR 0 1
37918: PPUSH
37919: LD_INT 30
37921: PUSH
37922: LD_INT 36
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PPUSH
37929: CALL 11587 0 2
37933: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
37934: LD_VAR 0 10
37938: PUSH
37939: LD_VAR 0 15
37943: AND
37944: PUSH
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 3
37952: PPUSH
37953: EMPTY
37954: PPUSH
37955: CALL 11670 0 3
37959: AND
37960: IFFALSE 38118
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
37962: LD_VAR 0 1
37966: PPUSH
37967: LD_INT 9
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL 12290 0 3
37976: PUSH
37977: LD_INT 3
37979: LESS
37980: IFFALSE 38118
// begin if mech < 3 then
37982: LD_VAR 0 15
37986: PUSH
37987: LD_INT 3
37989: LESS
37990: IFFALSE 38004
// k := mech else
37992: LD_ADDR_VAR 0 8
37996: PUSH
37997: LD_VAR 0 15
38001: ST_TO_ADDR
38002: GO 38012
// k := 3 ;
38004: LD_ADDR_VAR 0 8
38008: PUSH
38009: LD_INT 3
38011: ST_TO_ADDR
// for j = 1 to k do
38012: LD_ADDR_VAR 0 5
38016: PUSH
38017: DOUBLE
38018: LD_INT 1
38020: DEC
38021: ST_TO_ADDR
38022: LD_VAR 0 8
38026: PUSH
38027: FOR_TO
38028: IFFALSE 38086
// if GetClass ( mech [ j ] ) = 3 then
38030: LD_VAR 0 15
38034: PUSH
38035: LD_VAR 0 5
38039: ARRAY
38040: PPUSH
38041: CALL_OW 257
38045: PUSH
38046: LD_INT 3
38048: EQUAL
38049: IFFALSE 38084
// begin SetTag ( mech [ j ] , 9 ) ;
38051: LD_VAR 0 15
38055: PUSH
38056: LD_VAR 0 5
38060: ARRAY
38061: PPUSH
38062: LD_INT 9
38064: PPUSH
38065: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38069: LD_VAR 0 15
38073: PUSH
38074: LD_VAR 0 5
38078: ARRAY
38079: PPUSH
38080: CALL_OW 122
// end ;
38084: GO 38027
38086: POP
38087: POP
// if mech < 6 + k then
38088: LD_VAR 0 15
38092: PUSH
38093: LD_INT 6
38095: PUSH
38096: LD_VAR 0 8
38100: PLUS
38101: LESS
38102: IFFALSE 38118
// MCH_TrainMechanic ( side , k ) ;
38104: LD_VAR 0 1
38108: PPUSH
38109: LD_VAR 0 8
38113: PPUSH
38114: CALL 15788 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38118: LD_VAR 0 1
38122: PPUSH
38123: LD_INT 9
38125: PPUSH
38126: EMPTY
38127: PPUSH
38128: CALL 12290 0 3
38132: IFFALSE 38223
// for j in MCF_Tag ( side , 9 , [ ] ) do
38134: LD_ADDR_VAR 0 5
38138: PUSH
38139: LD_VAR 0 1
38143: PPUSH
38144: LD_INT 9
38146: PPUSH
38147: EMPTY
38148: PPUSH
38149: CALL 12290 0 3
38153: PUSH
38154: FOR_IN
38155: IFFALSE 38221
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38157: LD_VAR 0 5
38161: PPUSH
38162: CALL_OW 310
38166: NOT
38167: PUSH
38168: LD_VAR 0 5
38172: PPUSH
38173: CALL 94440 0 1
38177: NOT
38178: AND
38179: IFFALSE 38219
// if ct then
38181: LD_VAR 0 10
38185: IFFALSE 38207
// ComEnterUnit ( j , ct [ 1 ] ) else
38187: LD_VAR 0 5
38191: PPUSH
38192: LD_VAR 0 10
38196: PUSH
38197: LD_INT 1
38199: ARRAY
38200: PPUSH
38201: CALL_OW 120
38205: GO 38219
// SetTag ( j , 0 ) ;
38207: LD_VAR 0 5
38211: PPUSH
38212: LD_INT 0
38214: PPUSH
38215: CALL_OW 109
38219: GO 38154
38221: POP
38222: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38223: LD_INT 1
38225: PPUSH
38226: LD_VAR 0 1
38230: PPUSH
38231: CALL_OW 321
38235: PUSH
38236: LD_INT 2
38238: EQUAL
38239: PUSH
38240: LD_EXP 37
38244: PUSH
38245: LD_VAR 0 1
38249: ARRAY
38250: NOT
38251: AND
38252: PUSH
38253: LD_VAR 0 1
38257: PPUSH
38258: LD_INT 4
38260: PPUSH
38261: EMPTY
38262: PPUSH
38263: CALL 11670 0 3
38267: AND
38268: IFFALSE 38316
// for j in MCF_Class ( side , 4 , [ ] ) do
38270: LD_ADDR_VAR 0 5
38274: PUSH
38275: LD_VAR 0 1
38279: PPUSH
38280: LD_INT 4
38282: PPUSH
38283: EMPTY
38284: PPUSH
38285: CALL 11670 0 3
38289: PUSH
38290: FOR_IN
38291: IFFALSE 38314
// MCN_Tame ( GetSide ( j ) , j ) ;
38293: LD_VAR 0 5
38297: PPUSH
38298: CALL_OW 255
38302: PPUSH
38303: LD_VAR 0 5
38307: PPUSH
38308: CALL 18489 0 2
38312: GO 38290
38314: POP
38315: POP
// if MREG_DefVeh [ side ] then
38316: LD_EXP 69
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: IFFALSE 38490
// begin for i in MREG_DefVeh [ side ] do
38328: LD_ADDR_VAR 0 4
38332: PUSH
38333: LD_EXP 69
38337: PUSH
38338: LD_VAR 0 1
38342: ARRAY
38343: PUSH
38344: FOR_IN
38345: IFFALSE 38398
// begin SetTag ( i , 0 ) ;
38347: LD_VAR 0 4
38351: PPUSH
38352: LD_INT 0
38354: PPUSH
38355: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38359: LD_VAR 0 4
38363: PPUSH
38364: LD_EXP 66
38368: PUSH
38369: LD_VAR 0 1
38373: ARRAY
38374: PPUSH
38375: CALL_OW 308
38379: NOT
38380: IFFALSE 38396
// MCV_Parking ( side , i ) ;
38382: LD_VAR 0 1
38386: PPUSH
38387: LD_VAR 0 4
38391: PPUSH
38392: CALL 25677 0 2
// end ;
38396: GO 38344
38398: POP
38399: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38400: LD_VAR 0 1
38404: PPUSH
38405: LD_INT 36
38407: PPUSH
38408: EMPTY
38409: PPUSH
38410: CALL 12290 0 3
38414: IFFALSE 38455
// for i in MCF_Tag ( side , 36 , [ ] ) do
38416: LD_ADDR_VAR 0 4
38420: PUSH
38421: LD_VAR 0 1
38425: PPUSH
38426: LD_INT 36
38428: PPUSH
38429: EMPTY
38430: PPUSH
38431: CALL 12290 0 3
38435: PUSH
38436: FOR_IN
38437: IFFALSE 38453
// SetTag ( i , 0 ) ;
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_INT 0
38446: PPUSH
38447: CALL_OW 109
38451: GO 38436
38453: POP
38454: POP
// if MREG_DefMobActive [ side ] then
38455: LD_EXP 72
38459: PUSH
38460: LD_VAR 0 1
38464: ARRAY
38465: IFFALSE 38490
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38467: LD_ADDR_EXP 72
38471: PUSH
38472: LD_EXP 72
38476: PPUSH
38477: LD_VAR 0 1
38481: PPUSH
38482: LD_INT 0
38484: PPUSH
38485: CALL_OW 1
38489: ST_TO_ADDR
// end ; end ; if mode > 0 then
38490: LD_VAR 0 2
38494: PUSH
38495: LD_INT 0
38497: GREATER
38498: IFFALSE 40393
// begin if tick <= 15 15$00 then
38500: LD_OWVAR 1
38504: PUSH
38505: LD_INT 31500
38507: LESSEQUAL
38508: IFFALSE 38812
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38510: LD_VAR 0 13
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: CALL 24942 0 1
38524: PUSH
38525: LD_INT 4
38527: LESS
38528: AND
38529: IFFALSE 38640
// begin for i in sol do
38531: LD_ADDR_VAR 0 4
38535: PUSH
38536: LD_VAR 0 13
38540: PUSH
38541: FOR_IN
38542: IFFALSE 38638
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38544: LD_ADDR_VAR 0 8
38548: PUSH
38549: LD_VAR 0 1
38553: PPUSH
38554: CALL 24942 0 1
38558: PPUSH
38559: LD_VAR 0 4
38563: PPUSH
38564: CALL_OW 74
38568: ST_TO_ADDR
// if IsInUnit ( i ) then
38569: LD_VAR 0 4
38573: PPUSH
38574: CALL_OW 310
38578: IFFALSE 38589
// ComExitBuilding ( i ) ;
38580: LD_VAR 0 4
38584: PPUSH
38585: CALL_OW 122
// if not HasTask ( i ) and k then
38589: LD_VAR 0 4
38593: PPUSH
38594: CALL_OW 314
38598: NOT
38599: PUSH
38600: LD_VAR 0 8
38604: AND
38605: IFFALSE 38636
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38607: LD_VAR 0 4
38611: PPUSH
38612: LD_VAR 0 8
38616: PPUSH
38617: CALL_OW 250
38621: PPUSH
38622: LD_VAR 0 8
38626: PPUSH
38627: CALL_OW 251
38631: PPUSH
38632: CALL_OW 174
// end ;
38636: GO 38541
38638: POP
38639: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38640: LD_VAR 0 1
38644: PPUSH
38645: LD_INT 30
38647: PUSH
38648: LD_INT 5
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PPUSH
38655: CALL 11587 0 2
38659: IFFALSE 38810
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38661: LD_ADDR_VAR 0 11
38665: PUSH
38666: LD_VAR 0 1
38670: PPUSH
38671: LD_INT 30
38673: PUSH
38674: LD_INT 5
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PPUSH
38681: CALL 11587 0 2
38685: PUSH
38686: LD_INT 1
38688: ARRAY
38689: ST_TO_ADDR
// if mech then
38690: LD_VAR 0 15
38694: IFFALSE 38730
// for i in mech do
38696: LD_ADDR_VAR 0 4
38700: PUSH
38701: LD_VAR 0 15
38705: PUSH
38706: FOR_IN
38707: IFFALSE 38728
// MCH_ChangeClass ( side , i , 1 ) ;
38709: LD_VAR 0 1
38713: PPUSH
38714: LD_VAR 0 4
38718: PPUSH
38719: LD_INT 1
38721: PPUSH
38722: CALL 16494 0 3
38726: GO 38706
38728: POP
38729: POP
// if eng > 1 then
38730: LD_VAR 0 14
38734: PUSH
38735: LD_INT 1
38737: GREATER
38738: IFFALSE 38785
// for i = eng downto 2 do
38740: LD_ADDR_VAR 0 4
38744: PUSH
38745: DOUBLE
38746: LD_VAR 0 14
38750: INC
38751: ST_TO_ADDR
38752: LD_INT 2
38754: PUSH
38755: FOR_DOWNTO
38756: IFFALSE 38783
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38758: LD_VAR 0 1
38762: PPUSH
38763: LD_VAR 0 14
38767: PUSH
38768: LD_VAR 0 4
38772: ARRAY
38773: PPUSH
38774: LD_INT 1
38776: PPUSH
38777: CALL 16494 0 3
38781: GO 38755
38783: POP
38784: POP
// if UnitsInside ( b ) then
38785: LD_VAR 0 11
38789: PPUSH
38790: CALL_OW 313
38794: IFFALSE 38810
// ComExitBuilding ( UnitsInside ( b ) ) ;
38796: LD_VAR 0 11
38800: PPUSH
38801: CALL_OW 313
38805: PPUSH
38806: CALL_OW 122
// end ; end else
38810: GO 40393
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38812: LD_VAR 0 1
38816: PPUSH
38817: LD_INT 1
38819: PPUSH
38820: LD_EXP 67
38824: PUSH
38825: LD_VAR 0 1
38829: ARRAY
38830: PUSH
38831: LD_INT 1
38833: ARRAY
38834: PPUSH
38835: CALL 33665 0 3
38839: IFFALSE 38978
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38841: LD_ADDR_VAR 0 12
38845: PUSH
38846: LD_VAR 0 1
38850: PPUSH
38851: LD_INT 21
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PPUSH
38861: CALL 11587 0 2
38865: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38866: LD_ADDR_VAR 0 11
38870: PUSH
38871: LD_VAR 0 1
38875: PPUSH
38876: LD_INT 30
38878: PUSH
38879: LD_INT 1
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PPUSH
38886: CALL 11587 0 2
38890: ST_TO_ADDR
// if b then
38891: LD_VAR 0 11
38895: IFFALSE 38978
// for i in tmp do
38897: LD_ADDR_VAR 0 4
38901: PUSH
38902: LD_VAR 0 12
38906: PUSH
38907: FOR_IN
38908: IFFALSE 38976
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38910: LD_VAR 0 4
38914: PPUSH
38915: LD_EXP 67
38919: PUSH
38920: LD_VAR 0 1
38924: ARRAY
38925: PUSH
38926: LD_INT 1
38928: ARRAY
38929: PPUSH
38930: CALL_OW 308
38934: NOT
38935: IFFALSE 38974
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
38937: LD_VAR 0 4
38941: PPUSH
38942: LD_VAR 0 11
38946: PUSH
38947: LD_INT 1
38949: ARRAY
38950: PPUSH
38951: CALL_OW 250
38955: PPUSH
38956: LD_VAR 0 11
38960: PUSH
38961: LD_INT 1
38963: ARRAY
38964: PPUSH
38965: CALL_OW 251
38969: PPUSH
38970: CALL_OW 111
38974: GO 38907
38976: POP
38977: POP
// end ; if MREG_DefVeh [ side ] then
38978: LD_EXP 69
38982: PUSH
38983: LD_VAR 0 1
38987: ARRAY
38988: IFFALSE 39556
// begin tmp := [ ] ;
38990: LD_ADDR_VAR 0 12
38994: PUSH
38995: EMPTY
38996: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
38997: LD_EXP 72
39001: PUSH
39002: LD_VAR 0 1
39006: ARRAY
39007: PUSH
39008: LD_INT 0
39010: EQUAL
39011: IFFALSE 39151
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_VAR 0 1
39022: PPUSH
39023: LD_INT 0
39025: PPUSH
39026: LD_INT 25
39028: PUSH
39029: LD_INT 3
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PPUSH
39036: CALL 12290 0 3
39040: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39041: LD_VAR 0 8
39045: PUSH
39046: LD_EXP 69
39050: PUSH
39051: LD_VAR 0 1
39055: ARRAY
39056: GREATER
39057: IFFALSE 39118
// begin for i = 1 to MREG_DefVeh [ side ] do
39059: LD_ADDR_VAR 0 4
39063: PUSH
39064: DOUBLE
39065: LD_INT 1
39067: DEC
39068: ST_TO_ADDR
39069: LD_EXP 69
39073: PUSH
39074: LD_VAR 0 1
39078: ARRAY
39079: PUSH
39080: FOR_TO
39081: IFFALSE 39114
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39083: LD_ADDR_VAR 0 12
39087: PUSH
39088: LD_VAR 0 12
39092: PPUSH
39093: LD_INT 1
39095: PPUSH
39096: LD_VAR 0 8
39100: PUSH
39101: LD_VAR 0 4
39105: ARRAY
39106: PPUSH
39107: CALL_OW 2
39111: ST_TO_ADDR
39112: GO 39080
39114: POP
39115: POP
// end else
39116: GO 39128
// tmp := k ;
39118: LD_ADDR_VAR 0 12
39122: PUSH
39123: LD_VAR 0 8
39127: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39128: LD_ADDR_EXP 72
39132: PUSH
39133: LD_EXP 72
39137: PPUSH
39138: LD_VAR 0 1
39142: PPUSH
39143: LD_INT 1
39145: PPUSH
39146: CALL_OW 1
39150: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39151: LD_ADDR_VAR 0 4
39155: PUSH
39156: LD_EXP 69
39160: PUSH
39161: LD_VAR 0 1
39165: ARRAY
39166: PUSH
39167: FOR_IN
39168: IFFALSE 39554
// begin if not GetDriver ( i ) then
39170: LD_VAR 0 4
39174: PPUSH
39175: CALL 31695 0 1
39179: NOT
39180: IFFALSE 39255
// begin if tmp then
39182: LD_VAR 0 12
39186: IFFALSE 39253
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39188: LD_VAR 0 12
39192: PUSH
39193: LD_INT 1
39195: ARRAY
39196: PPUSH
39197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39201: LD_VAR 0 12
39205: PUSH
39206: LD_INT 1
39208: ARRAY
39209: PPUSH
39210: LD_VAR 0 4
39214: PPUSH
39215: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39219: LD_VAR 0 12
39223: PUSH
39224: LD_INT 1
39226: ARRAY
39227: PPUSH
39228: LD_INT 36
39230: PPUSH
39231: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39235: LD_ADDR_VAR 0 12
39239: PUSH
39240: LD_VAR 0 12
39244: PPUSH
39245: LD_INT 1
39247: PPUSH
39248: CALL_OW 3
39252: ST_TO_ADDR
// end ; end else
39253: GO 39552
// begin if GetTag ( i ) = 0 then
39255: LD_VAR 0 4
39259: PPUSH
39260: CALL_OW 110
39264: PUSH
39265: LD_INT 0
39267: EQUAL
39268: IFFALSE 39284
// SetTag ( i , 31 ) else
39270: LD_VAR 0 4
39274: PPUSH
39275: LD_INT 31
39277: PPUSH
39278: CALL_OW 109
39282: GO 39552
// if GetTag ( i ) = 31 then
39284: LD_VAR 0 4
39288: PPUSH
39289: CALL_OW 110
39293: PUSH
39294: LD_INT 31
39296: EQUAL
39297: IFFALSE 39552
// begin if GetFuel ( i ) < 20 then
39299: LD_VAR 0 4
39303: PPUSH
39304: CALL_OW 261
39308: PUSH
39309: LD_INT 20
39311: LESS
39312: IFFALSE 39337
// begin SetTag ( i , 21 ) ;
39314: LD_VAR 0 4
39318: PPUSH
39319: LD_INT 21
39321: PPUSH
39322: CALL_OW 109
// MCV_Refuel ( i ) ;
39326: LD_VAR 0 4
39330: PPUSH
39331: CALL 26214 0 1
// continue ;
39335: GO 39167
// end ; if GetLives ( i ) < 700 then
39337: LD_VAR 0 4
39341: PPUSH
39342: CALL_OW 256
39346: PUSH
39347: LD_INT 700
39349: LESS
39350: IFFALSE 39462
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39352: LD_VAR 0 4
39356: PPUSH
39357: LD_EXP 60
39361: PUSH
39362: LD_VAR 0 1
39366: ARRAY
39367: PPUSH
39368: CALL_OW 308
39372: NOT
39373: IFFALSE 39397
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39375: LD_VAR 0 4
39379: PPUSH
39380: LD_EXP 60
39384: PUSH
39385: LD_VAR 0 1
39389: ARRAY
39390: PPUSH
39391: CALL_OW 113
39395: GO 39460
// if GetDriver ( i ) then
39397: LD_VAR 0 4
39401: PPUSH
39402: CALL 31695 0 1
39406: IFFALSE 39460
// begin k := GetDriver ( i ) ;
39408: LD_ADDR_VAR 0 8
39412: PUSH
39413: LD_VAR 0 4
39417: PPUSH
39418: CALL 31695 0 1
39422: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39423: LD_VAR 0 8
39427: PPUSH
39428: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39432: LD_VAR 0 8
39436: PPUSH
39437: LD_VAR 0 4
39441: PPUSH
39442: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39446: LD_VAR 0 8
39450: PPUSH
39451: LD_VAR 0 4
39455: PPUSH
39456: CALL_OW 180
// end ; end else
39460: GO 39552
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39462: LD_ADDR_VAR 0 8
39466: PUSH
39467: LD_VAR 0 1
39471: PPUSH
39472: CALL 24942 0 1
39476: PPUSH
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL_OW 74
39486: ST_TO_ADDR
// if k then
39487: LD_VAR 0 8
39491: IFFALSE 39509
// ComAttackUnit ( i , k ) else
39493: LD_VAR 0 4
39497: PPUSH
39498: LD_VAR 0 8
39502: PPUSH
39503: CALL_OW 115
39507: GO 39552
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39509: LD_VAR 0 4
39513: PPUSH
39514: LD_EXP 60
39518: PUSH
39519: LD_VAR 0 1
39523: ARRAY
39524: PPUSH
39525: CALL_OW 308
39529: NOT
39530: IFFALSE 39552
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39532: LD_VAR 0 4
39536: PPUSH
39537: LD_EXP 60
39541: PUSH
39542: LD_VAR 0 1
39546: ARRAY
39547: PPUSH
39548: CALL_OW 113
// end ; end ; end ; end ;
39552: GO 39167
39554: POP
39555: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39556: LD_VAR 0 1
39560: PPUSH
39561: LD_INT 30
39563: PUSH
39564: LD_INT 5
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PPUSH
39571: CALL 11587 0 2
39575: IFFALSE 40393
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39577: LD_ADDR_VAR 0 11
39581: PUSH
39582: LD_VAR 0 1
39586: PPUSH
39587: LD_INT 30
39589: PUSH
39590: LD_INT 5
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PPUSH
39597: CALL 11587 0 2
39601: PUSH
39602: LD_INT 1
39604: ARRAY
39605: ST_TO_ADDR
// if eng > 1 then
39606: LD_VAR 0 14
39610: PUSH
39611: LD_INT 1
39613: GREATER
39614: IFFALSE 39661
// for i = eng downto 2 do
39616: LD_ADDR_VAR 0 4
39620: PUSH
39621: DOUBLE
39622: LD_VAR 0 14
39626: INC
39627: ST_TO_ADDR
39628: LD_INT 2
39630: PUSH
39631: FOR_DOWNTO
39632: IFFALSE 39659
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_VAR 0 14
39643: PUSH
39644: LD_VAR 0 4
39648: ARRAY
39649: PPUSH
39650: LD_INT 1
39652: PPUSH
39653: CALL 16494 0 3
39657: GO 39631
39659: POP
39660: POP
// if sci > 1 then
39661: LD_VAR 0 16
39665: PUSH
39666: LD_INT 1
39668: GREATER
39669: IFFALSE 39716
// for i = sci downto 2 do
39671: LD_ADDR_VAR 0 4
39675: PUSH
39676: DOUBLE
39677: LD_VAR 0 16
39681: INC
39682: ST_TO_ADDR
39683: LD_INT 2
39685: PUSH
39686: FOR_DOWNTO
39687: IFFALSE 39714
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39689: LD_VAR 0 1
39693: PPUSH
39694: LD_VAR 0 16
39698: PUSH
39699: LD_VAR 0 4
39703: ARRAY
39704: PPUSH
39705: LD_INT 1
39707: PPUSH
39708: CALL 16494 0 3
39712: GO 39686
39714: POP
39715: POP
// if sol then
39716: LD_VAR 0 13
39720: IFFALSE 40393
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39722: LD_VAR 0 13
39726: PUSH
39727: LD_EXP 70
39731: PUSH
39732: LD_VAR 0 1
39736: ARRAY
39737: DIFF
39738: PUSH
39739: LD_INT 22
39741: PUSH
39742: LD_VAR 0 1
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 58
39753: PUSH
39754: EMPTY
39755: LIST
39756: PUSH
39757: LD_INT 2
39759: PUSH
39760: LD_INT 30
39762: PUSH
39763: LD_INT 32
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 30
39772: PUSH
39773: LD_INT 31
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL_OW 69
39794: PUSH
39795: LD_INT 0
39797: EQUAL
39798: AND
39799: IFFALSE 40393
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39801: LD_ADDR_VAR 0 12
39805: PUSH
39806: LD_VAR 0 13
39810: PUSH
39811: LD_EXP 70
39815: PUSH
39816: LD_VAR 0 1
39820: ARRAY
39821: DIFF
39822: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39823: LD_VAR 0 1
39827: PPUSH
39828: LD_INT 30
39830: PUSH
39831: LD_INT 5
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PPUSH
39838: CALL 11587 0 2
39842: PUSH
39843: LD_INT 1
39845: GREATER
39846: IFFALSE 39877
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39848: LD_ADDR_VAR 0 8
39852: PUSH
39853: LD_VAR 0 1
39857: PPUSH
39858: LD_INT 30
39860: PUSH
39861: LD_INT 5
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL 11587 0 2
39872: PUSH
39873: LD_INT 2
39875: ARRAY
39876: ST_TO_ADDR
// for j in tmp do
39877: LD_ADDR_VAR 0 5
39881: PUSH
39882: LD_VAR 0 12
39886: PUSH
39887: FOR_IN
39888: IFFALSE 40391
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39890: LD_VAR 0 5
39894: PUSH
39895: LD_VAR 0 11
39899: PPUSH
39900: CALL_OW 313
39904: IN
39905: PUSH
39906: LD_VAR 0 11
39910: PPUSH
39911: CALL_OW 313
39915: PUSH
39916: LD_INT 6
39918: EQUAL
39919: AND
39920: PUSH
39921: LD_VAR 0 8
39925: AND
39926: PUSH
39927: LD_VAR 0 8
39931: PPUSH
39932: CALL_OW 313
39936: PUSH
39937: LD_INT 6
39939: LESS
39940: AND
39941: IFFALSE 39968
// begin ComExitBuilding ( j ) ;
39943: LD_VAR 0 5
39947: PPUSH
39948: CALL_OW 122
// AddComEnterunit ( j , k ) ;
39952: LD_VAR 0 5
39956: PPUSH
39957: LD_VAR 0 8
39961: PPUSH
39962: CALL_OW 180
// continue ;
39966: GO 39887
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
39968: LD_VAR 0 5
39972: PPUSH
39973: CALL_OW 314
39977: NOT
39978: PUSH
39979: LD_VAR 0 5
39983: PPUSH
39984: CALL_OW 110
39988: PUSH
39989: LD_INT 0
39991: EQUAL
39992: AND
39993: PUSH
39994: LD_VAR 0 5
39998: PPUSH
39999: CALL_OW 310
40003: NOT
40004: AND
40005: IFFALSE 40111
// begin if k then
40007: LD_VAR 0 8
40011: IFFALSE 40082
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40013: LD_VAR 0 8
40017: PPUSH
40018: CALL_OW 313
40022: PUSH
40023: LD_VAR 0 11
40027: PPUSH
40028: CALL_OW 313
40032: LESS
40033: IFFALSE 40051
// ComEnterUnit ( j , k ) else
40035: LD_VAR 0 5
40039: PPUSH
40040: LD_VAR 0 8
40044: PPUSH
40045: CALL_OW 120
40049: GO 40080
// if UnitsInside ( b ) < 6 then
40051: LD_VAR 0 11
40055: PPUSH
40056: CALL_OW 313
40060: PUSH
40061: LD_INT 6
40063: LESS
40064: IFFALSE 40080
// ComEnterUnit ( j , b ) ;
40066: LD_VAR 0 5
40070: PPUSH
40071: LD_VAR 0 11
40075: PPUSH
40076: CALL_OW 120
// end else
40080: GO 40111
// if UnitsInside ( b ) < 6 then
40082: LD_VAR 0 11
40086: PPUSH
40087: CALL_OW 313
40091: PUSH
40092: LD_INT 6
40094: LESS
40095: IFFALSE 40111
// ComEnterUnit ( j , b ) ;
40097: LD_VAR 0 5
40101: PPUSH
40102: LD_VAR 0 11
40106: PPUSH
40107: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40111: LD_VAR 0 5
40115: PUSH
40116: LD_VAR 0 1
40120: PPUSH
40121: LD_INT 54
40123: PUSH
40124: EMPTY
40125: LIST
40126: PPUSH
40127: CALL 11587 0 2
40131: IN
40132: PUSH
40133: LD_VAR 0 5
40137: PPUSH
40138: CALL_OW 257
40142: PUSH
40143: LD_INT 1
40145: EQUAL
40146: AND
40147: IFFALSE 40389
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40149: LD_EXP 64
40153: PUSH
40154: LD_VAR 0 1
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: PUSH
40164: LD_INT 12
40166: PPUSH
40167: LD_VAR 0 1
40171: PPUSH
40172: CALL_OW 321
40176: PUSH
40177: LD_INT 2
40179: EQUAL
40180: AND
40181: IFFALSE 40229
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40183: LD_VAR 0 1
40187: PPUSH
40188: LD_INT 5
40190: PPUSH
40191: EMPTY
40192: PPUSH
40193: CALL 11670 0 3
40197: PUSH
40198: LD_EXP 64
40202: PUSH
40203: LD_VAR 0 1
40207: ARRAY
40208: PUSH
40209: LD_INT 1
40211: ARRAY
40212: LESS
40213: IFFALSE 40229
// begin SetClass ( j , class_sniper ) ;
40215: LD_VAR 0 5
40219: PPUSH
40220: LD_INT 5
40222: PPUSH
40223: CALL_OW 336
// continue ;
40227: GO 39887
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40229: LD_EXP 64
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 2
40242: ARRAY
40243: PUSH
40244: LD_INT 41
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 8
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11670 0 3
40277: PUSH
40278: LD_EXP 64
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 2
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_mortar ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 8
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39887
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40309: LD_EXP 64
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 3
40322: ARRAY
40323: PUSH
40324: LD_INT 44
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 9
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11670 0 3
40357: PUSH
40358: LD_EXP 64
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 3
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_bazooker ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 9
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39887
// end ; end ; end ;
40389: GO 39887
40391: POP
40392: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40393: LD_INT 22
40395: PUSH
40396: LD_VAR 0 1
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 58
40407: PUSH
40408: EMPTY
40409: LIST
40410: PUSH
40411: LD_INT 30
40413: PUSH
40414: LD_INT 32
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: PPUSH
40426: CALL_OW 69
40430: IFFALSE 40580
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40432: LD_ADDR_VAR 0 12
40436: PUSH
40437: LD_INT 22
40439: PUSH
40440: LD_VAR 0 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 58
40451: PUSH
40452: EMPTY
40453: LIST
40454: PUSH
40455: LD_INT 30
40457: PUSH
40458: LD_INT 32
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: LIST
40469: PPUSH
40470: CALL_OW 69
40474: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40475: LD_ADDR_VAR 0 8
40479: PUSH
40480: LD_VAR 0 13
40484: PUSH
40485: LD_EXP 70
40489: PUSH
40490: LD_VAR 0 1
40494: ARRAY
40495: DIFF
40496: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40497: LD_VAR 0 12
40501: PUSH
40502: LD_INT 1
40504: ARRAY
40505: PPUSH
40506: CALL_OW 461
40510: PUSH
40511: LD_INT 2
40513: EQUAL
40514: PUSH
40515: LD_VAR 0 12
40519: PUSH
40520: LD_INT 1
40522: ARRAY
40523: PUSH
40524: LD_EXP 70
40528: PUSH
40529: LD_VAR 0 1
40533: ARRAY
40534: IN
40535: NOT
40536: AND
40537: PUSH
40538: LD_VAR 0 8
40542: AND
40543: IFFALSE 40580
// begin ComExitBuilding ( k [ 1 ] ) ;
40545: LD_VAR 0 8
40549: PUSH
40550: LD_INT 1
40552: ARRAY
40553: PPUSH
40554: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40558: LD_VAR 0 8
40562: PUSH
40563: LD_INT 1
40565: ARRAY
40566: PPUSH
40567: LD_VAR 0 12
40571: PUSH
40572: LD_INT 1
40574: ARRAY
40575: PPUSH
40576: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40580: LD_EXP 37
40584: PUSH
40585: LD_VAR 0 1
40589: ARRAY
40590: IFFALSE 40738
// begin if MCF_Class ( side , 4 , [ ] ) then
40592: LD_VAR 0 1
40596: PPUSH
40597: LD_INT 4
40599: PPUSH
40600: EMPTY
40601: PPUSH
40602: CALL 11670 0 3
40606: IFFALSE 40736
// for j in MCF_Class ( side , 4 , [ ] ) do
40608: LD_ADDR_VAR 0 5
40612: PUSH
40613: LD_VAR 0 1
40617: PPUSH
40618: LD_INT 4
40620: PPUSH
40621: EMPTY
40622: PPUSH
40623: CALL 11670 0 3
40627: PUSH
40628: FOR_IN
40629: IFFALSE 40734
// begin if not GetTag ( j ) = 4 then
40631: LD_VAR 0 5
40635: PPUSH
40636: CALL_OW 110
40640: PUSH
40641: LD_INT 4
40643: EQUAL
40644: NOT
40645: IFFALSE 40681
// begin SetTag ( j , 4 ) ;
40647: LD_VAR 0 5
40651: PPUSH
40652: LD_INT 4
40654: PPUSH
40655: CALL_OW 109
// if IsInUnit ( j ) then
40659: LD_VAR 0 5
40663: PPUSH
40664: CALL_OW 310
40668: IFFALSE 40679
// ComExitBuilding ( j ) ;
40670: LD_VAR 0 5
40674: PPUSH
40675: CALL_OW 122
// end else
40679: GO 40732
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40681: LD_VAR 0 5
40685: PPUSH
40686: LD_EXP 37
40690: PUSH
40691: LD_VAR 0 1
40695: ARRAY
40696: PUSH
40697: LD_INT 1
40699: ARRAY
40700: PPUSH
40701: CALL 94064 0 2
40705: NOT
40706: IFFALSE 40732
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40708: LD_VAR 0 5
40712: PPUSH
40713: LD_EXP 37
40717: PUSH
40718: LD_VAR 0 1
40722: ARRAY
40723: PUSH
40724: LD_INT 1
40726: ARRAY
40727: PPUSH
40728: CALL 19157 0 2
// end ;
40732: GO 40628
40734: POP
40735: POP
// end else
40736: GO 40970
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40738: LD_VAR 0 1
40742: PPUSH
40743: LD_INT 4
40745: PPUSH
40746: EMPTY
40747: PPUSH
40748: CALL 11670 0 3
40752: PUSH
40753: LD_VAR 0 1
40757: PPUSH
40758: LD_INT 4
40760: PPUSH
40761: EMPTY
40762: PPUSH
40763: CALL 12290 0 3
40767: AND
40768: IFFALSE 40970
// for j in MCF_Class ( side , 4 , [ ] ) do
40770: LD_ADDR_VAR 0 5
40774: PUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 4
40782: PPUSH
40783: EMPTY
40784: PPUSH
40785: CALL 11670 0 3
40789: PUSH
40790: FOR_IN
40791: IFFALSE 40968
// begin if GetTag ( j ) = 4 then
40793: LD_VAR 0 5
40797: PPUSH
40798: CALL_OW 110
40802: PUSH
40803: LD_INT 4
40805: EQUAL
40806: IFFALSE 40966
// begin SetTag ( j , 0 ) ;
40808: LD_VAR 0 5
40812: PPUSH
40813: LD_INT 0
40815: PPUSH
40816: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40820: LD_VAR 0 1
40824: PPUSH
40825: CALL 11626 0 1
40829: PUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: CALL 17970 0 1
40839: NOT
40840: AND
40841: IFFALSE 40866
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40843: LD_VAR 0 5
40847: PPUSH
40848: LD_VAR 0 1
40852: PPUSH
40853: CALL 11626 0 1
40857: PUSH
40858: LD_INT 1
40860: ARRAY
40861: PPUSH
40862: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40866: LD_VAR 0 1
40870: PPUSH
40871: CALL 11626 0 1
40875: NOT
40876: PUSH
40877: LD_VAR 0 1
40881: PPUSH
40882: LD_INT 30
40884: PUSH
40885: LD_INT 1
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PPUSH
40892: CALL 11587 0 2
40896: AND
40897: IFFALSE 40966
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40899: LD_VAR 0 5
40903: PPUSH
40904: LD_VAR 0 1
40908: PPUSH
40909: LD_INT 30
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PPUSH
40919: CALL 11587 0 2
40923: PUSH
40924: LD_INT 1
40926: ARRAY
40927: PPUSH
40928: CALL_OW 250
40932: PPUSH
40933: LD_VAR 0 1
40937: PPUSH
40938: LD_INT 30
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PPUSH
40948: CALL 11587 0 2
40952: PUSH
40953: LD_INT 1
40955: ARRAY
40956: PPUSH
40957: CALL_OW 251
40961: PPUSH
40962: CALL_OW 111
// end ; end ;
40966: GO 40790
40968: POP
40969: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
40970: LD_VAR 0 1
40974: PPUSH
40975: LD_INT 3
40977: PPUSH
40978: EMPTY
40979: PPUSH
40980: CALL 11670 0 3
40984: PUSH
40985: LD_EXP 60
40989: PUSH
40990: LD_VAR 0 1
40994: ARRAY
40995: AND
40996: PUSH
40997: LD_VAR 0 1
41001: PPUSH
41002: LD_INT 6
41004: PPUSH
41005: EMPTY
41006: PPUSH
41007: CALL 12290 0 3
41011: AND
41012: IFFALSE 41543
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41014: LD_ADDR_VAR 0 6
41018: PUSH
41019: LD_EXP 60
41023: PUSH
41024: LD_VAR 0 1
41028: ARRAY
41029: PPUSH
41030: LD_INT 0
41032: PPUSH
41033: CALL_OW 517
41037: PUSH
41038: LD_INT 1
41040: ARRAY
41041: PUSH
41042: LD_INT 1
41044: ARRAY
41045: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41046: LD_ADDR_VAR 0 7
41050: PUSH
41051: LD_EXP 60
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PPUSH
41062: LD_INT 0
41064: PPUSH
41065: CALL_OW 517
41069: PUSH
41070: LD_INT 2
41072: ARRAY
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41078: LD_VAR 0 1
41082: PPUSH
41083: LD_INT 6
41085: PPUSH
41086: EMPTY
41087: PPUSH
41088: CALL 12290 0 3
41092: IFFALSE 41541
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41094: LD_ADDR_VAR 0 8
41098: PUSH
41099: LD_VAR 0 1
41103: PPUSH
41104: LD_INT 6
41106: PPUSH
41107: EMPTY
41108: PPUSH
41109: CALL 12290 0 3
41113: PUSH
41114: FOR_IN
41115: IFFALSE 41146
// if GetLives ( k ) = 1000 then
41117: LD_VAR 0 8
41121: PPUSH
41122: CALL_OW 256
41126: PUSH
41127: LD_INT 1000
41129: EQUAL
41130: IFFALSE 41144
// SetTag ( k , 0 ) ;
41132: LD_VAR 0 8
41136: PPUSH
41137: LD_INT 0
41139: PPUSH
41140: CALL_OW 109
41144: GO 41114
41146: POP
41147: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41148: LD_VAR 0 1
41152: PPUSH
41153: LD_INT 0
41155: PPUSH
41156: LD_INT 25
41158: PUSH
41159: LD_INT 3
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PPUSH
41166: CALL 12290 0 3
41170: IFFALSE 41234
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 4
41181: PPUSH
41182: LD_INT 0
41184: PPUSH
41185: LD_INT 25
41187: PUSH
41188: LD_INT 3
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PPUSH
41195: CALL 12290 0 3
41199: PUSH
41200: FOR_IN
41201: IFFALSE 41232
// if GetTag ( k ) = 0 then
41203: LD_VAR 0 8
41207: PPUSH
41208: CALL_OW 110
41212: PUSH
41213: LD_INT 0
41215: EQUAL
41216: IFFALSE 41230
// begin SetTag ( k , 8 ) ;
41218: LD_VAR 0 8
41222: PPUSH
41223: LD_INT 8
41225: PPUSH
41226: CALL_OW 109
// end ;
41230: GO 41200
41232: POP
41233: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41234: LD_VAR 0 1
41238: PPUSH
41239: LD_INT 6
41241: PPUSH
41242: LD_INT 92
41244: PUSH
41245: LD_VAR 0 6
41249: PUSH
41250: LD_VAR 0 7
41254: PUSH
41255: LD_INT 10
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: PPUSH
41264: CALL 12290 0 3
41268: IFFALSE 41392
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41270: LD_ADDR_VAR 0 5
41274: PUSH
41275: LD_VAR 0 4
41279: PPUSH
41280: LD_INT 6
41282: PPUSH
41283: LD_INT 92
41285: PUSH
41286: LD_VAR 0 6
41290: PUSH
41291: LD_VAR 0 7
41295: PUSH
41296: LD_INT 10
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: PPUSH
41305: CALL 12290 0 3
41309: PUSH
41310: FOR_IN
41311: IFFALSE 41390
// begin if not HasTask ( j ) and GetDriver ( j ) then
41313: LD_VAR 0 5
41317: PPUSH
41318: CALL_OW 314
41322: NOT
41323: PUSH
41324: LD_VAR 0 5
41328: PPUSH
41329: CALL 31695 0 1
41333: AND
41334: IFFALSE 41388
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41336: LD_VAR 0 5
41340: PPUSH
41341: CALL 31695 0 1
41345: PPUSH
41346: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41350: LD_VAR 0 5
41354: PPUSH
41355: CALL 31695 0 1
41359: PPUSH
41360: LD_VAR 0 5
41364: PPUSH
41365: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41369: LD_VAR 0 5
41373: PPUSH
41374: CALL 31695 0 1
41378: PPUSH
41379: LD_VAR 0 5
41383: PPUSH
41384: CALL_OW 180
// end ; end ;
41388: GO 41310
41390: POP
41391: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41392: LD_VAR 0 1
41396: PPUSH
41397: LD_INT 6
41399: PPUSH
41400: LD_INT 92
41402: PUSH
41403: LD_VAR 0 6
41407: PUSH
41408: LD_VAR 0 7
41412: PUSH
41413: LD_INT 10
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL 12290 0 3
41426: PUSH
41427: LD_VAR 0 1
41431: PPUSH
41432: LD_INT 8
41434: PPUSH
41435: EMPTY
41436: PPUSH
41437: CALL 12290 0 3
41441: AND
41442: IFFALSE 41541
// for j in MCF_Tag ( side , 8 , [ ] ) do
41444: LD_ADDR_VAR 0 5
41448: PUSH
41449: LD_VAR 0 1
41453: PPUSH
41454: LD_INT 8
41456: PPUSH
41457: EMPTY
41458: PPUSH
41459: CALL 12290 0 3
41463: PUSH
41464: FOR_IN
41465: IFFALSE 41539
// begin if IsInUnit ( j ) then
41467: LD_VAR 0 5
41471: PPUSH
41472: CALL_OW 310
41476: IFFALSE 41489
// ComExitBuilding ( j ) else
41478: LD_VAR 0 5
41482: PPUSH
41483: CALL_OW 122
41487: GO 41537
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41489: LD_VAR 0 5
41493: PPUSH
41494: LD_VAR 0 1
41498: PPUSH
41499: LD_INT 6
41501: PPUSH
41502: LD_INT 92
41504: PUSH
41505: LD_VAR 0 6
41509: PUSH
41510: LD_VAR 0 7
41514: PUSH
41515: LD_INT 10
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: PPUSH
41524: CALL 12290 0 3
41528: PUSH
41529: LD_INT 1
41531: ARRAY
41532: PPUSH
41533: CALL_OW 129
// end ;
41537: GO 41464
41539: POP
41540: POP
// end ; end else
41541: GO 41598
// if MCF_Tag ( side , 8 , [ ] ) then
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12290 0 3
41557: IFFALSE 41598
// for k in MCF_Tag ( side , 8 , [ ] ) do
41559: LD_ADDR_VAR 0 8
41563: PUSH
41564: LD_VAR 0 1
41568: PPUSH
41569: LD_INT 8
41571: PPUSH
41572: EMPTY
41573: PPUSH
41574: CALL 12290 0 3
41578: PUSH
41579: FOR_IN
41580: IFFALSE 41596
// SetTag ( k , 0 ) ;
41582: LD_VAR 0 8
41586: PPUSH
41587: LD_INT 0
41589: PPUSH
41590: CALL_OW 109
41594: GO 41579
41596: POP
41597: POP
// end ; end_of_file
41598: LD_VAR 0 3
41602: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41603: LD_INT 0
41605: PPUSH
// MREG_Game := [ ] ;
41606: LD_ADDR_EXP 35
41610: PUSH
41611: EMPTY
41612: ST_TO_ADDR
// MREG_Crates := [ ] ;
41613: LD_ADDR_EXP 36
41617: PUSH
41618: EMPTY
41619: ST_TO_ADDR
// MREG_Heal := [ ] ;
41620: LD_ADDR_EXP 37
41624: PUSH
41625: EMPTY
41626: ST_TO_ADDR
// MREG_Tame := [ ] ;
41627: LD_ADDR_EXP 39
41631: PUSH
41632: EMPTY
41633: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41634: LD_ADDR_EXP 40
41638: PUSH
41639: EMPTY
41640: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41641: LD_ADDR_EXP 41
41645: PUSH
41646: EMPTY
41647: ST_TO_ADDR
// MREG_LabList := [ ] ;
41648: LD_ADDR_EXP 42
41652: PUSH
41653: EMPTY
41654: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41655: LD_ADDR_EXP 43
41659: PUSH
41660: EMPTY
41661: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41662: LD_ADDR_EXP 44
41666: PUSH
41667: EMPTY
41668: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41669: LD_ADDR_EXP 45
41673: PUSH
41674: EMPTY
41675: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41676: LD_ADDR_EXP 46
41680: PUSH
41681: EMPTY
41682: ST_TO_ADDR
// MREG_Status := [ ] ;
41683: LD_ADDR_EXP 47
41687: PUSH
41688: EMPTY
41689: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41690: LD_ADDR_EXP 48
41694: PUSH
41695: EMPTY
41696: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41697: LD_ADDR_EXP 49
41701: PUSH
41702: EMPTY
41703: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41704: LD_ADDR_EXP 50
41708: PUSH
41709: EMPTY
41710: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41711: LD_ADDR_EXP 51
41715: PUSH
41716: EMPTY
41717: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41718: LD_ADDR_EXP 52
41722: PUSH
41723: EMPTY
41724: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41725: LD_ADDR_EXP 53
41729: PUSH
41730: EMPTY
41731: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41732: LD_ADDR_EXP 54
41736: PUSH
41737: EMPTY
41738: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41739: LD_ADDR_EXP 55
41743: PUSH
41744: EMPTY
41745: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41746: LD_ADDR_EXP 56
41750: PUSH
41751: EMPTY
41752: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41753: LD_ADDR_EXP 57
41757: PUSH
41758: EMPTY
41759: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41760: LD_ADDR_EXP 58
41764: PUSH
41765: EMPTY
41766: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41767: LD_ADDR_EXP 59
41771: PUSH
41772: EMPTY
41773: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41774: LD_ADDR_EXP 63
41778: PUSH
41779: EMPTY
41780: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41781: LD_ADDR_EXP 64
41785: PUSH
41786: EMPTY
41787: ST_TO_ADDR
// MREG_Parking := [ ] ;
41788: LD_ADDR_EXP 60
41792: PUSH
41793: EMPTY
41794: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41795: LD_ADDR_EXP 61
41799: PUSH
41800: EMPTY
41801: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41802: LD_ADDR_EXP 65
41806: PUSH
41807: EMPTY
41808: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41809: LD_ADDR_EXP 66
41813: PUSH
41814: EMPTY
41815: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41816: LD_ADDR_EXP 67
41820: PUSH
41821: EMPTY
41822: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41823: LD_ADDR_EXP 69
41827: PUSH
41828: EMPTY
41829: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41830: LD_ADDR_EXP 70
41834: PUSH
41835: EMPTY
41836: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41837: LD_ADDR_EXP 71
41841: PUSH
41842: EMPTY
41843: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41844: LD_ADDR_EXP 73
41848: PUSH
41849: EMPTY
41850: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41851: LD_ADDR_EXP 72
41855: PUSH
41856: EMPTY
41857: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41858: LD_ADDR_EXP 74
41862: PUSH
41863: LD_INT 300
41865: PUSH
41866: LD_INT 100
41868: PUSH
41869: LD_INT 25
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: LIST
41876: ST_TO_ADDR
// end ;
41877: LD_VAR 0 1
41881: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41882: LD_INT 0
41884: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41885: LD_VAR 0 2
41889: PUSH
41890: LD_VAR 0 3
41894: PUSH
41895: LD_VAR 0 4
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: PUSH
41905: LD_VAR 0 1
41909: IN
41910: IFFALSE 41924
// result := mreg_list else
41912: LD_ADDR_VAR 0 5
41916: PUSH
41917: LD_VAR 0 1
41921: ST_TO_ADDR
41922: GO 41958
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
41924: LD_ADDR_VAR 0 1
41928: PUSH
41929: LD_VAR 0 1
41933: PUSH
41934: LD_VAR 0 2
41938: PUSH
41939: LD_VAR 0 3
41943: PUSH
41944: LD_VAR 0 4
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: LIST
41953: PUSH
41954: EMPTY
41955: LIST
41956: ADD
41957: ST_TO_ADDR
// result := mreg_list ;
41958: LD_ADDR_VAR 0 5
41962: PUSH
41963: LD_VAR 0 1
41967: ST_TO_ADDR
// end ;
41968: LD_VAR 0 5
41972: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
41973: LD_INT 0
41975: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41976: LD_VAR 0 2
41980: PUSH
41981: LD_VAR 0 3
41985: PUSH
41986: LD_VAR 0 4
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: LIST
41995: PUSH
41996: LD_VAR 0 1
42000: IN
42001: IFFALSE 42039
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42003: LD_ADDR_VAR 0 5
42007: PUSH
42008: LD_VAR 0 1
42012: PUSH
42013: LD_VAR 0 2
42017: PUSH
42018: LD_VAR 0 3
42022: PUSH
42023: LD_VAR 0 4
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: PUSH
42033: EMPTY
42034: LIST
42035: DIFF
42036: ST_TO_ADDR
42037: GO 42049
// result := mreg_list ;
42039: LD_ADDR_VAR 0 5
42043: PUSH
42044: LD_VAR 0 1
42048: ST_TO_ADDR
// end ;
42049: LD_VAR 0 5
42053: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42054: LD_INT 0
42056: PPUSH
42057: PPUSH
42058: PPUSH
// for j = 1 to 8 do
42059: LD_ADDR_VAR 0 3
42063: PUSH
42064: DOUBLE
42065: LD_INT 1
42067: DEC
42068: ST_TO_ADDR
42069: LD_INT 8
42071: PUSH
42072: FOR_TO
42073: IFFALSE 42914
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42075: LD_VAR 0 3
42079: PPUSH
42080: LD_INT 51
42082: PUSH
42083: EMPTY
42084: LIST
42085: PPUSH
42086: CALL 11587 0 2
42090: PUSH
42091: LD_OWVAR 2
42095: PUSH
42096: LD_VAR 0 3
42100: EQUAL
42101: NOT
42102: AND
42103: IFFALSE 42121
// MREG_SidesList := MREG_SidesList ^ 1 else
42105: LD_ADDR_EXP 41
42109: PUSH
42110: LD_EXP 41
42114: PUSH
42115: LD_INT 1
42117: ADD
42118: ST_TO_ADDR
42119: GO 42135
// MREG_SidesList := MREG_SidesList ^ 0 ;
42121: LD_ADDR_EXP 41
42125: PUSH
42126: LD_EXP 41
42130: PUSH
42131: LD_INT 0
42133: ADD
42134: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42135: LD_VAR 0 3
42139: PPUSH
42140: LD_INT 2
42142: PUSH
42143: LD_INT 34
42145: PUSH
42146: LD_INT 12
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 34
42155: PUSH
42156: LD_INT 32
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 34
42165: PUSH
42166: LD_INT 51
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: PUSH
42179: EMPTY
42180: LIST
42181: PPUSH
42182: CALL 11888 0 2
42186: IFFALSE 42287
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42188: LD_ADDR_VAR 0 2
42192: PUSH
42193: LD_VAR 0 3
42197: PPUSH
42198: LD_INT 2
42200: PUSH
42201: LD_INT 34
42203: PUSH
42204: LD_INT 12
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 34
42213: PUSH
42214: LD_INT 32
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 51
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PPUSH
42240: CALL 11888 0 2
42244: PUSH
42245: FOR_IN
42246: IFFALSE 42285
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42248: LD_ADDR_EXP 43
42252: PUSH
42253: LD_EXP 43
42257: PPUSH
42258: LD_VAR 0 3
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: LD_VAR 0 2
42272: PPUSH
42273: CALL_OW 264
42277: PPUSH
42278: CALL 41882 0 4
42282: ST_TO_ADDR
42283: GO 42245
42285: POP
42286: POP
// if MCF_Class ( j , 4 , [ ] ) then
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 4
42294: PPUSH
42295: EMPTY
42296: PPUSH
42297: CALL 11670 0 3
42301: IFFALSE 42334
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42303: LD_ADDR_EXP 56
42307: PUSH
42308: LD_EXP 56
42312: PUSH
42313: LD_VAR 0 3
42317: PPUSH
42318: LD_INT 4
42320: PPUSH
42321: EMPTY
42322: PPUSH
42323: CALL 11670 0 3
42327: PUSH
42328: EMPTY
42329: LIST
42330: ADD
42331: ST_TO_ADDR
42332: GO 42351
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42334: LD_ADDR_EXP 56
42338: PUSH
42339: LD_EXP 56
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: ADD
42350: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42351: LD_VAR 0 3
42355: PPUSH
42356: LD_INT 3
42358: PPUSH
42359: EMPTY
42360: PPUSH
42361: CALL 11670 0 3
42365: IFFALSE 42398
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42367: LD_ADDR_EXP 57
42371: PUSH
42372: LD_EXP 57
42376: PUSH
42377: LD_VAR 0 3
42381: PPUSH
42382: LD_INT 3
42384: PPUSH
42385: EMPTY
42386: PPUSH
42387: CALL 11670 0 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: ADD
42395: ST_TO_ADDR
42396: GO 42415
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42398: LD_ADDR_EXP 57
42402: PUSH
42403: LD_EXP 57
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: EMPTY
42412: LIST
42413: ADD
42414: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42415: LD_VAR 0 3
42419: PPUSH
42420: LD_INT 1
42422: PPUSH
42423: EMPTY
42424: PPUSH
42425: CALL 11670 0 3
42429: IFFALSE 42462
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42431: LD_ADDR_EXP 58
42435: PUSH
42436: LD_EXP 58
42440: PUSH
42441: LD_VAR 0 3
42445: PPUSH
42446: LD_INT 1
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL 11670 0 3
42455: PUSH
42456: EMPTY
42457: LIST
42458: ADD
42459: ST_TO_ADDR
42460: GO 42479
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42462: LD_ADDR_EXP 58
42466: PUSH
42467: LD_EXP 58
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: ADD
42478: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42479: LD_VAR 0 3
42483: PPUSH
42484: LD_INT 2
42486: PPUSH
42487: EMPTY
42488: PPUSH
42489: CALL 11670 0 3
42493: IFFALSE 42526
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42495: LD_ADDR_EXP 59
42499: PUSH
42500: LD_EXP 59
42504: PUSH
42505: LD_VAR 0 3
42509: PPUSH
42510: LD_INT 2
42512: PPUSH
42513: EMPTY
42514: PPUSH
42515: CALL 11670 0 3
42519: PUSH
42520: EMPTY
42521: LIST
42522: ADD
42523: ST_TO_ADDR
42524: GO 42543
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42526: LD_ADDR_EXP 59
42530: PUSH
42531: LD_EXP 59
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: ADD
42542: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42543: LD_ADDR_EXP 49
42547: PUSH
42548: LD_EXP 49
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: EMPTY
42557: LIST
42558: ADD
42559: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42560: LD_ADDR_EXP 37
42564: PUSH
42565: LD_EXP 37
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: EMPTY
42574: LIST
42575: ADD
42576: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42577: LD_ADDR_EXP 39
42581: PUSH
42582: LD_EXP 39
42586: PUSH
42587: LD_INT 0
42589: PUSH
42590: EMPTY
42591: LIST
42592: ADD
42593: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42594: LD_ADDR_EXP 60
42598: PUSH
42599: LD_EXP 60
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: EMPTY
42608: LIST
42609: ADD
42610: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42611: LD_ADDR_EXP 61
42615: PUSH
42616: LD_EXP 61
42620: PUSH
42621: LD_INT 0
42623: PUSH
42624: EMPTY
42625: LIST
42626: ADD
42627: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42628: LD_ADDR_EXP 53
42632: PUSH
42633: LD_EXP 53
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: ADD
42644: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42645: LD_ADDR_EXP 40
42649: PUSH
42650: LD_EXP 40
42654: PUSH
42655: LD_INT 0
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: PUSH
42673: EMPTY
42674: LIST
42675: ADD
42676: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42677: LD_ADDR_EXP 62
42681: PUSH
42682: LD_EXP 62
42686: PUSH
42687: LD_INT 0
42689: PUSH
42690: EMPTY
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: EMPTY
42697: LIST
42698: ADD
42699: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42700: LD_ADDR_EXP 63
42704: PUSH
42705: LD_EXP 63
42709: PUSH
42710: LD_INT 0
42712: PUSH
42713: EMPTY
42714: LIST
42715: PUSH
42716: EMPTY
42717: LIST
42718: ADD
42719: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42720: LD_ADDR_EXP 44
42724: PUSH
42725: LD_EXP 44
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: ADD
42736: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42737: LD_ADDR_EXP 65
42741: PUSH
42742: LD_EXP 65
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: EMPTY
42751: LIST
42752: ADD
42753: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42754: LD_ADDR_EXP 66
42758: PUSH
42759: LD_EXP 66
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42771: LD_ADDR_EXP 67
42775: PUSH
42776: LD_EXP 67
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: LIST
42786: ADD
42787: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42788: LD_ADDR_EXP 68
42792: PUSH
42793: LD_EXP 68
42797: PUSH
42798: LD_INT 0
42800: PUSH
42801: EMPTY
42802: LIST
42803: ADD
42804: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42805: LD_ADDR_EXP 69
42809: PUSH
42810: LD_EXP 69
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: EMPTY
42819: LIST
42820: ADD
42821: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42822: LD_ADDR_EXP 70
42826: PUSH
42827: LD_EXP 70
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: EMPTY
42836: LIST
42837: ADD
42838: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42839: LD_ADDR_EXP 71
42843: PUSH
42844: LD_EXP 71
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: ADD
42855: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42856: LD_ADDR_EXP 73
42860: PUSH
42861: LD_EXP 73
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: EMPTY
42870: LIST
42871: ADD
42872: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42873: LD_ADDR_EXP 72
42877: PUSH
42878: LD_EXP 72
42882: PUSH
42883: LD_INT 0
42885: ADD
42886: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42887: LD_ADDR_EXP 64
42891: PUSH
42892: LD_EXP 64
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: LIST
42910: ADD
42911: ST_TO_ADDR
// end ;
42912: GO 42072
42914: POP
42915: POP
// end ;
42916: LD_VAR 0 1
42920: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42921: LD_INT 0
42923: PPUSH
42924: PPUSH
42925: PPUSH
// m := false ;
42926: LD_ADDR_VAR 0 5
42930: PUSH
42931: LD_INT 0
42933: ST_TO_ADDR
// for i = 1 to mreg do
42934: LD_ADDR_VAR 0 4
42938: PUSH
42939: DOUBLE
42940: LD_INT 1
42942: DEC
42943: ST_TO_ADDR
42944: LD_VAR 0 2
42948: PUSH
42949: FOR_TO
42950: IFFALSE 42986
// if mreg [ i ] [ 1 ] = side then
42952: LD_VAR 0 2
42956: PUSH
42957: LD_VAR 0 4
42961: ARRAY
42962: PUSH
42963: LD_INT 1
42965: ARRAY
42966: PUSH
42967: LD_VAR 0 1
42971: EQUAL
42972: IFFALSE 42984
// begin m := true ;
42974: LD_ADDR_VAR 0 5
42978: PUSH
42979: LD_INT 1
42981: ST_TO_ADDR
// break ;
42982: GO 42986
// end ;
42984: GO 42949
42986: POP
42987: POP
// result := m ;
42988: LD_ADDR_VAR 0 3
42992: PUSH
42993: LD_VAR 0 5
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43003: LD_INT 0
43005: PPUSH
43006: PPUSH
43007: PPUSH
// m := 0 ;
43008: LD_ADDR_VAR 0 5
43012: PUSH
43013: LD_INT 0
43015: ST_TO_ADDR
// for i = 1 to mreg do
43016: LD_ADDR_VAR 0 4
43020: PUSH
43021: DOUBLE
43022: LD_INT 1
43024: DEC
43025: ST_TO_ADDR
43026: LD_VAR 0 2
43030: PUSH
43031: FOR_TO
43032: IFFALSE 43072
// if mreg [ i ] [ 1 ] = side then
43034: LD_VAR 0 2
43038: PUSH
43039: LD_VAR 0 4
43043: ARRAY
43044: PUSH
43045: LD_INT 1
43047: ARRAY
43048: PUSH
43049: LD_VAR 0 1
43053: EQUAL
43054: IFFALSE 43070
// begin m := m + 1 ;
43056: LD_ADDR_VAR 0 5
43060: PUSH
43061: LD_VAR 0 5
43065: PUSH
43066: LD_INT 1
43068: PLUS
43069: ST_TO_ADDR
// end ;
43070: GO 43031
43072: POP
43073: POP
// result := m ;
43074: LD_ADDR_VAR 0 3
43078: PUSH
43079: LD_VAR 0 5
43083: ST_TO_ADDR
// end ;
43084: LD_VAR 0 3
43088: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43089: LD_INT 0
43091: PPUSH
43092: PPUSH
// result := 0 ;
43093: LD_ADDR_VAR 0 3
43097: PUSH
43098: LD_INT 0
43100: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43101: LD_ADDR_VAR 0 4
43105: PUSH
43106: DOUBLE
43107: LD_INT 1
43109: DEC
43110: ST_TO_ADDR
43111: LD_EXP 55
43115: PUSH
43116: FOR_TO
43117: IFFALSE 43179
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43119: LD_EXP 55
43123: PUSH
43124: LD_VAR 0 4
43128: ARRAY
43129: PUSH
43130: LD_INT 1
43132: ARRAY
43133: PUSH
43134: LD_VAR 0 1
43138: EQUAL
43139: PUSH
43140: LD_EXP 55
43144: PUSH
43145: LD_VAR 0 4
43149: ARRAY
43150: PUSH
43151: LD_INT 2
43153: ARRAY
43154: PUSH
43155: LD_VAR 0 2
43159: EQUAL
43160: AND
43161: IFFALSE 43177
// begin result := result + 1 ;
43163: LD_ADDR_VAR 0 3
43167: PUSH
43168: LD_VAR 0 3
43172: PUSH
43173: LD_INT 1
43175: PLUS
43176: ST_TO_ADDR
// end ;
43177: GO 43116
43179: POP
43180: POP
// end ; end_of_file
43181: LD_VAR 0 3
43185: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
43186: LD_INT 0
43188: PPUSH
// ar_miner := 81 ;
43189: LD_ADDR_EXP 82
43193: PUSH
43194: LD_INT 81
43196: ST_TO_ADDR
// ar_crane := 88 ;
43197: LD_ADDR_EXP 81
43201: PUSH
43202: LD_INT 88
43204: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43205: LD_ADDR_EXP 76
43209: PUSH
43210: LD_INT 89
43212: ST_TO_ADDR
// us_hack := 99 ;
43213: LD_ADDR_EXP 77
43217: PUSH
43218: LD_INT 99
43220: ST_TO_ADDR
// us_artillery := 97 ;
43221: LD_ADDR_EXP 78
43225: PUSH
43226: LD_INT 97
43228: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43229: LD_ADDR_EXP 79
43233: PUSH
43234: LD_INT 91
43236: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
43237: LD_ADDR_EXP 80
43241: PUSH
43242: LD_INT 92
43244: ST_TO_ADDR
// ru_radar := 98 ;
43245: LD_ADDR_EXP 75
43249: PUSH
43250: LD_INT 98
43252: ST_TO_ADDR
// tech_Artillery := 80 ;
43253: LD_ADDR_EXP 83
43257: PUSH
43258: LD_INT 80
43260: ST_TO_ADDR
// tech_RadMat := 81 ;
43261: LD_ADDR_EXP 84
43265: PUSH
43266: LD_INT 81
43268: ST_TO_ADDR
// tech_BasicTools := 82 ;
43269: LD_ADDR_EXP 85
43273: PUSH
43274: LD_INT 82
43276: ST_TO_ADDR
// tech_Cargo := 83 ;
43277: LD_ADDR_EXP 86
43281: PUSH
43282: LD_INT 83
43284: ST_TO_ADDR
// tech_Track := 84 ;
43285: LD_ADDR_EXP 87
43289: PUSH
43290: LD_INT 84
43292: ST_TO_ADDR
// tech_Crane := 85 ;
43293: LD_ADDR_EXP 88
43297: PUSH
43298: LD_INT 85
43300: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43301: LD_ADDR_EXP 89
43305: PUSH
43306: LD_INT 86
43308: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43309: LD_ADDR_EXP 90
43313: PUSH
43314: LD_INT 87
43316: ST_TO_ADDR
// end ;
43317: LD_VAR 0 1
43321: RET
// every 1 do
43322: GO 43324
43324: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43325: CALL 43186 0 0
43329: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
43330: LD_VAR 0 2
43334: PUSH
43335: LD_INT 100
43337: EQUAL
43338: IFFALSE 44287
// begin if not StreamModeActive then
43340: LD_EXP 91
43344: NOT
43345: IFFALSE 43355
// StreamModeActive := true ;
43347: LD_ADDR_EXP 91
43351: PUSH
43352: LD_INT 1
43354: ST_TO_ADDR
// if p3 = 0 then
43355: LD_VAR 0 3
43359: PUSH
43360: LD_INT 0
43362: EQUAL
43363: IFFALSE 43369
// InitStreamMode ;
43365: CALL 44445 0 0
// if p3 = 1 then
43369: LD_VAR 0 3
43373: PUSH
43374: LD_INT 1
43376: EQUAL
43377: IFFALSE 43387
// sRocket := true ;
43379: LD_ADDR_EXP 96
43383: PUSH
43384: LD_INT 1
43386: ST_TO_ADDR
// if p3 = 2 then
43387: LD_VAR 0 3
43391: PUSH
43392: LD_INT 2
43394: EQUAL
43395: IFFALSE 43405
// sSpeed := true ;
43397: LD_ADDR_EXP 95
43401: PUSH
43402: LD_INT 1
43404: ST_TO_ADDR
// if p3 = 3 then
43405: LD_VAR 0 3
43409: PUSH
43410: LD_INT 3
43412: EQUAL
43413: IFFALSE 43423
// sEngine := true ;
43415: LD_ADDR_EXP 97
43419: PUSH
43420: LD_INT 1
43422: ST_TO_ADDR
// if p3 = 4 then
43423: LD_VAR 0 3
43427: PUSH
43428: LD_INT 4
43430: EQUAL
43431: IFFALSE 43441
// sSpec := true ;
43433: LD_ADDR_EXP 94
43437: PUSH
43438: LD_INT 1
43440: ST_TO_ADDR
// if p3 = 5 then
43441: LD_VAR 0 3
43445: PUSH
43446: LD_INT 5
43448: EQUAL
43449: IFFALSE 43459
// sLevel := true ;
43451: LD_ADDR_EXP 98
43455: PUSH
43456: LD_INT 1
43458: ST_TO_ADDR
// if p3 = 6 then
43459: LD_VAR 0 3
43463: PUSH
43464: LD_INT 6
43466: EQUAL
43467: IFFALSE 43477
// sArmoury := true ;
43469: LD_ADDR_EXP 99
43473: PUSH
43474: LD_INT 1
43476: ST_TO_ADDR
// if p3 = 7 then
43477: LD_VAR 0 3
43481: PUSH
43482: LD_INT 7
43484: EQUAL
43485: IFFALSE 43495
// sRadar := true ;
43487: LD_ADDR_EXP 100
43491: PUSH
43492: LD_INT 1
43494: ST_TO_ADDR
// if p3 = 8 then
43495: LD_VAR 0 3
43499: PUSH
43500: LD_INT 8
43502: EQUAL
43503: IFFALSE 43513
// sBunker := true ;
43505: LD_ADDR_EXP 101
43509: PUSH
43510: LD_INT 1
43512: ST_TO_ADDR
// if p3 = 9 then
43513: LD_VAR 0 3
43517: PUSH
43518: LD_INT 9
43520: EQUAL
43521: IFFALSE 43531
// sHack := true ;
43523: LD_ADDR_EXP 102
43527: PUSH
43528: LD_INT 1
43530: ST_TO_ADDR
// if p3 = 10 then
43531: LD_VAR 0 3
43535: PUSH
43536: LD_INT 10
43538: EQUAL
43539: IFFALSE 43549
// sFire := true ;
43541: LD_ADDR_EXP 103
43545: PUSH
43546: LD_INT 1
43548: ST_TO_ADDR
// if p3 = 11 then
43549: LD_VAR 0 3
43553: PUSH
43554: LD_INT 11
43556: EQUAL
43557: IFFALSE 43567
// sRefresh := true ;
43559: LD_ADDR_EXP 104
43563: PUSH
43564: LD_INT 1
43566: ST_TO_ADDR
// if p3 = 12 then
43567: LD_VAR 0 3
43571: PUSH
43572: LD_INT 12
43574: EQUAL
43575: IFFALSE 43585
// sExp := true ;
43577: LD_ADDR_EXP 105
43581: PUSH
43582: LD_INT 1
43584: ST_TO_ADDR
// if p3 = 13 then
43585: LD_VAR 0 3
43589: PUSH
43590: LD_INT 13
43592: EQUAL
43593: IFFALSE 43603
// sDepot := true ;
43595: LD_ADDR_EXP 106
43599: PUSH
43600: LD_INT 1
43602: ST_TO_ADDR
// if p3 = 14 then
43603: LD_VAR 0 3
43607: PUSH
43608: LD_INT 14
43610: EQUAL
43611: IFFALSE 43621
// sFlag := true ;
43613: LD_ADDR_EXP 107
43617: PUSH
43618: LD_INT 1
43620: ST_TO_ADDR
// if p3 = 15 then
43621: LD_VAR 0 3
43625: PUSH
43626: LD_INT 15
43628: EQUAL
43629: IFFALSE 43639
// sKamikadze := true ;
43631: LD_ADDR_EXP 115
43635: PUSH
43636: LD_INT 1
43638: ST_TO_ADDR
// if p3 = 16 then
43639: LD_VAR 0 3
43643: PUSH
43644: LD_INT 16
43646: EQUAL
43647: IFFALSE 43657
// sTroll := true ;
43649: LD_ADDR_EXP 116
43653: PUSH
43654: LD_INT 1
43656: ST_TO_ADDR
// if p3 = 17 then
43657: LD_VAR 0 3
43661: PUSH
43662: LD_INT 17
43664: EQUAL
43665: IFFALSE 43675
// sSlow := true ;
43667: LD_ADDR_EXP 117
43671: PUSH
43672: LD_INT 1
43674: ST_TO_ADDR
// if p3 = 18 then
43675: LD_VAR 0 3
43679: PUSH
43680: LD_INT 18
43682: EQUAL
43683: IFFALSE 43693
// sLack := true ;
43685: LD_ADDR_EXP 118
43689: PUSH
43690: LD_INT 1
43692: ST_TO_ADDR
// if p3 = 19 then
43693: LD_VAR 0 3
43697: PUSH
43698: LD_INT 19
43700: EQUAL
43701: IFFALSE 43711
// sTank := true ;
43703: LD_ADDR_EXP 120
43707: PUSH
43708: LD_INT 1
43710: ST_TO_ADDR
// if p3 = 20 then
43711: LD_VAR 0 3
43715: PUSH
43716: LD_INT 20
43718: EQUAL
43719: IFFALSE 43729
// sRemote := true ;
43721: LD_ADDR_EXP 121
43725: PUSH
43726: LD_INT 1
43728: ST_TO_ADDR
// if p3 = 21 then
43729: LD_VAR 0 3
43733: PUSH
43734: LD_INT 21
43736: EQUAL
43737: IFFALSE 43747
// sPowell := true ;
43739: LD_ADDR_EXP 122
43743: PUSH
43744: LD_INT 1
43746: ST_TO_ADDR
// if p3 = 22 then
43747: LD_VAR 0 3
43751: PUSH
43752: LD_INT 22
43754: EQUAL
43755: IFFALSE 43765
// sTeleport := true ;
43757: LD_ADDR_EXP 125
43761: PUSH
43762: LD_INT 1
43764: ST_TO_ADDR
// if p3 = 23 then
43765: LD_VAR 0 3
43769: PUSH
43770: LD_INT 23
43772: EQUAL
43773: IFFALSE 43783
// sOilTower := true ;
43775: LD_ADDR_EXP 127
43779: PUSH
43780: LD_INT 1
43782: ST_TO_ADDR
// if p3 = 24 then
43783: LD_VAR 0 3
43787: PUSH
43788: LD_INT 24
43790: EQUAL
43791: IFFALSE 43801
// sShovel := true ;
43793: LD_ADDR_EXP 128
43797: PUSH
43798: LD_INT 1
43800: ST_TO_ADDR
// if p3 = 25 then
43801: LD_VAR 0 3
43805: PUSH
43806: LD_INT 25
43808: EQUAL
43809: IFFALSE 43819
// sSheik := true ;
43811: LD_ADDR_EXP 129
43815: PUSH
43816: LD_INT 1
43818: ST_TO_ADDR
// if p3 = 26 then
43819: LD_VAR 0 3
43823: PUSH
43824: LD_INT 26
43826: EQUAL
43827: IFFALSE 43837
// sEarthquake := true ;
43829: LD_ADDR_EXP 131
43833: PUSH
43834: LD_INT 1
43836: ST_TO_ADDR
// if p3 = 27 then
43837: LD_VAR 0 3
43841: PUSH
43842: LD_INT 27
43844: EQUAL
43845: IFFALSE 43855
// sAI := true ;
43847: LD_ADDR_EXP 132
43851: PUSH
43852: LD_INT 1
43854: ST_TO_ADDR
// if p3 = 28 then
43855: LD_VAR 0 3
43859: PUSH
43860: LD_INT 28
43862: EQUAL
43863: IFFALSE 43873
// sCargo := true ;
43865: LD_ADDR_EXP 135
43869: PUSH
43870: LD_INT 1
43872: ST_TO_ADDR
// if p3 = 29 then
43873: LD_VAR 0 3
43877: PUSH
43878: LD_INT 29
43880: EQUAL
43881: IFFALSE 43891
// sDLaser := true ;
43883: LD_ADDR_EXP 136
43887: PUSH
43888: LD_INT 1
43890: ST_TO_ADDR
// if p3 = 30 then
43891: LD_VAR 0 3
43895: PUSH
43896: LD_INT 30
43898: EQUAL
43899: IFFALSE 43909
// sExchange := true ;
43901: LD_ADDR_EXP 137
43905: PUSH
43906: LD_INT 1
43908: ST_TO_ADDR
// if p3 = 31 then
43909: LD_VAR 0 3
43913: PUSH
43914: LD_INT 31
43916: EQUAL
43917: IFFALSE 43927
// sFac := true ;
43919: LD_ADDR_EXP 138
43923: PUSH
43924: LD_INT 1
43926: ST_TO_ADDR
// if p3 = 32 then
43927: LD_VAR 0 3
43931: PUSH
43932: LD_INT 32
43934: EQUAL
43935: IFFALSE 43945
// sPower := true ;
43937: LD_ADDR_EXP 139
43941: PUSH
43942: LD_INT 1
43944: ST_TO_ADDR
// if p3 = 33 then
43945: LD_VAR 0 3
43949: PUSH
43950: LD_INT 33
43952: EQUAL
43953: IFFALSE 43963
// sRandom := true ;
43955: LD_ADDR_EXP 140
43959: PUSH
43960: LD_INT 1
43962: ST_TO_ADDR
// if p3 = 34 then
43963: LD_VAR 0 3
43967: PUSH
43968: LD_INT 34
43970: EQUAL
43971: IFFALSE 43981
// sShield := true ;
43973: LD_ADDR_EXP 141
43977: PUSH
43978: LD_INT 1
43980: ST_TO_ADDR
// if p3 = 35 then
43981: LD_VAR 0 3
43985: PUSH
43986: LD_INT 35
43988: EQUAL
43989: IFFALSE 43999
// sTime := true ;
43991: LD_ADDR_EXP 142
43995: PUSH
43996: LD_INT 1
43998: ST_TO_ADDR
// if p3 = 36 then
43999: LD_VAR 0 3
44003: PUSH
44004: LD_INT 36
44006: EQUAL
44007: IFFALSE 44017
// sTools := true ;
44009: LD_ADDR_EXP 143
44013: PUSH
44014: LD_INT 1
44016: ST_TO_ADDR
// if p3 = 101 then
44017: LD_VAR 0 3
44021: PUSH
44022: LD_INT 101
44024: EQUAL
44025: IFFALSE 44035
// sSold := true ;
44027: LD_ADDR_EXP 108
44031: PUSH
44032: LD_INT 1
44034: ST_TO_ADDR
// if p3 = 102 then
44035: LD_VAR 0 3
44039: PUSH
44040: LD_INT 102
44042: EQUAL
44043: IFFALSE 44053
// sDiff := true ;
44045: LD_ADDR_EXP 109
44049: PUSH
44050: LD_INT 1
44052: ST_TO_ADDR
// if p3 = 103 then
44053: LD_VAR 0 3
44057: PUSH
44058: LD_INT 103
44060: EQUAL
44061: IFFALSE 44071
// sFog := true ;
44063: LD_ADDR_EXP 112
44067: PUSH
44068: LD_INT 1
44070: ST_TO_ADDR
// if p3 = 104 then
44071: LD_VAR 0 3
44075: PUSH
44076: LD_INT 104
44078: EQUAL
44079: IFFALSE 44089
// sReset := true ;
44081: LD_ADDR_EXP 113
44085: PUSH
44086: LD_INT 1
44088: ST_TO_ADDR
// if p3 = 105 then
44089: LD_VAR 0 3
44093: PUSH
44094: LD_INT 105
44096: EQUAL
44097: IFFALSE 44107
// sSun := true ;
44099: LD_ADDR_EXP 114
44103: PUSH
44104: LD_INT 1
44106: ST_TO_ADDR
// if p3 = 106 then
44107: LD_VAR 0 3
44111: PUSH
44112: LD_INT 106
44114: EQUAL
44115: IFFALSE 44125
// sTiger := true ;
44117: LD_ADDR_EXP 110
44121: PUSH
44122: LD_INT 1
44124: ST_TO_ADDR
// if p3 = 107 then
44125: LD_VAR 0 3
44129: PUSH
44130: LD_INT 107
44132: EQUAL
44133: IFFALSE 44143
// sBomb := true ;
44135: LD_ADDR_EXP 111
44139: PUSH
44140: LD_INT 1
44142: ST_TO_ADDR
// if p3 = 108 then
44143: LD_VAR 0 3
44147: PUSH
44148: LD_INT 108
44150: EQUAL
44151: IFFALSE 44161
// sWound := true ;
44153: LD_ADDR_EXP 119
44157: PUSH
44158: LD_INT 1
44160: ST_TO_ADDR
// if p3 = 109 then
44161: LD_VAR 0 3
44165: PUSH
44166: LD_INT 109
44168: EQUAL
44169: IFFALSE 44179
// sBetray := true ;
44171: LD_ADDR_EXP 123
44175: PUSH
44176: LD_INT 1
44178: ST_TO_ADDR
// if p3 = 110 then
44179: LD_VAR 0 3
44183: PUSH
44184: LD_INT 110
44186: EQUAL
44187: IFFALSE 44197
// sContamin := true ;
44189: LD_ADDR_EXP 124
44193: PUSH
44194: LD_INT 1
44196: ST_TO_ADDR
// if p3 = 111 then
44197: LD_VAR 0 3
44201: PUSH
44202: LD_INT 111
44204: EQUAL
44205: IFFALSE 44215
// sOil := true ;
44207: LD_ADDR_EXP 126
44211: PUSH
44212: LD_INT 1
44214: ST_TO_ADDR
// if p3 = 112 then
44215: LD_VAR 0 3
44219: PUSH
44220: LD_INT 112
44222: EQUAL
44223: IFFALSE 44233
// sStu := true ;
44225: LD_ADDR_EXP 130
44229: PUSH
44230: LD_INT 1
44232: ST_TO_ADDR
// if p3 = 113 then
44233: LD_VAR 0 3
44237: PUSH
44238: LD_INT 113
44240: EQUAL
44241: IFFALSE 44251
// sBazooka := true ;
44243: LD_ADDR_EXP 133
44247: PUSH
44248: LD_INT 1
44250: ST_TO_ADDR
// if p3 = 114 then
44251: LD_VAR 0 3
44255: PUSH
44256: LD_INT 114
44258: EQUAL
44259: IFFALSE 44269
// sMortar := true ;
44261: LD_ADDR_EXP 134
44265: PUSH
44266: LD_INT 1
44268: ST_TO_ADDR
// if p3 = 115 then
44269: LD_VAR 0 3
44273: PUSH
44274: LD_INT 115
44276: EQUAL
44277: IFFALSE 44287
// sRanger := true ;
44279: LD_ADDR_EXP 144
44283: PUSH
44284: LD_INT 1
44286: ST_TO_ADDR
// end ; if p2 = 101 then
44287: LD_VAR 0 2
44291: PUSH
44292: LD_INT 101
44294: EQUAL
44295: IFFALSE 44423
// begin case p3 of 1 :
44297: LD_VAR 0 3
44301: PUSH
44302: LD_INT 1
44304: DOUBLE
44305: EQUAL
44306: IFTRUE 44310
44308: GO 44317
44310: POP
// hHackUnlimitedResources ; 2 :
44311: CALL 55458 0 0
44315: GO 44423
44317: LD_INT 2
44319: DOUBLE
44320: EQUAL
44321: IFTRUE 44325
44323: GO 44332
44325: POP
// hHackSetLevel10 ; 3 :
44326: CALL 55591 0 0
44330: GO 44423
44332: LD_INT 3
44334: DOUBLE
44335: EQUAL
44336: IFTRUE 44340
44338: GO 44347
44340: POP
// hHackSetLevel10YourUnits ; 4 :
44341: CALL 55676 0 0
44345: GO 44423
44347: LD_INT 4
44349: DOUBLE
44350: EQUAL
44351: IFTRUE 44355
44353: GO 44362
44355: POP
// hHackInvincible ; 5 :
44356: CALL 56124 0 0
44360: GO 44423
44362: LD_INT 5
44364: DOUBLE
44365: EQUAL
44366: IFTRUE 44370
44368: GO 44377
44370: POP
// hHackInvisible ; 6 :
44371: CALL 56235 0 0
44375: GO 44423
44377: LD_INT 6
44379: DOUBLE
44380: EQUAL
44381: IFTRUE 44385
44383: GO 44392
44385: POP
// hHackChangeYourSide ; 7 :
44386: CALL 56292 0 0
44390: GO 44423
44392: LD_INT 7
44394: DOUBLE
44395: EQUAL
44396: IFTRUE 44400
44398: GO 44407
44400: POP
// hHackChangeUnitSide ; 8 :
44401: CALL 56334 0 0
44405: GO 44423
44407: LD_INT 8
44409: DOUBLE
44410: EQUAL
44411: IFTRUE 44415
44413: GO 44422
44415: POP
// hHackFog ; end ;
44416: CALL 56435 0 0
44420: GO 44423
44422: POP
// end ; end ;
44423: PPOPN 6
44425: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44426: GO 44428
44428: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44429: LD_STRING initStreamRollete();
44431: PPUSH
44432: CALL_OW 559
// InitStreamMode ;
44436: CALL 44445 0 0
// DefineStreamItems ( ) ;
44440: CALL 44885 0 0
// end ;
44444: END
// function InitStreamMode ; begin
44445: LD_INT 0
44447: PPUSH
// streamModeActive := false ;
44448: LD_ADDR_EXP 91
44452: PUSH
44453: LD_INT 0
44455: ST_TO_ADDR
// normalCounter := 36 ;
44456: LD_ADDR_EXP 92
44460: PUSH
44461: LD_INT 36
44463: ST_TO_ADDR
// hardcoreCounter := 16 ;
44464: LD_ADDR_EXP 93
44468: PUSH
44469: LD_INT 16
44471: ST_TO_ADDR
// sRocket := false ;
44472: LD_ADDR_EXP 96
44476: PUSH
44477: LD_INT 0
44479: ST_TO_ADDR
// sSpeed := false ;
44480: LD_ADDR_EXP 95
44484: PUSH
44485: LD_INT 0
44487: ST_TO_ADDR
// sEngine := false ;
44488: LD_ADDR_EXP 97
44492: PUSH
44493: LD_INT 0
44495: ST_TO_ADDR
// sSpec := false ;
44496: LD_ADDR_EXP 94
44500: PUSH
44501: LD_INT 0
44503: ST_TO_ADDR
// sLevel := false ;
44504: LD_ADDR_EXP 98
44508: PUSH
44509: LD_INT 0
44511: ST_TO_ADDR
// sArmoury := false ;
44512: LD_ADDR_EXP 99
44516: PUSH
44517: LD_INT 0
44519: ST_TO_ADDR
// sRadar := false ;
44520: LD_ADDR_EXP 100
44524: PUSH
44525: LD_INT 0
44527: ST_TO_ADDR
// sBunker := false ;
44528: LD_ADDR_EXP 101
44532: PUSH
44533: LD_INT 0
44535: ST_TO_ADDR
// sHack := false ;
44536: LD_ADDR_EXP 102
44540: PUSH
44541: LD_INT 0
44543: ST_TO_ADDR
// sFire := false ;
44544: LD_ADDR_EXP 103
44548: PUSH
44549: LD_INT 0
44551: ST_TO_ADDR
// sRefresh := false ;
44552: LD_ADDR_EXP 104
44556: PUSH
44557: LD_INT 0
44559: ST_TO_ADDR
// sExp := false ;
44560: LD_ADDR_EXP 105
44564: PUSH
44565: LD_INT 0
44567: ST_TO_ADDR
// sDepot := false ;
44568: LD_ADDR_EXP 106
44572: PUSH
44573: LD_INT 0
44575: ST_TO_ADDR
// sFlag := false ;
44576: LD_ADDR_EXP 107
44580: PUSH
44581: LD_INT 0
44583: ST_TO_ADDR
// sKamikadze := false ;
44584: LD_ADDR_EXP 115
44588: PUSH
44589: LD_INT 0
44591: ST_TO_ADDR
// sTroll := false ;
44592: LD_ADDR_EXP 116
44596: PUSH
44597: LD_INT 0
44599: ST_TO_ADDR
// sSlow := false ;
44600: LD_ADDR_EXP 117
44604: PUSH
44605: LD_INT 0
44607: ST_TO_ADDR
// sLack := false ;
44608: LD_ADDR_EXP 118
44612: PUSH
44613: LD_INT 0
44615: ST_TO_ADDR
// sTank := false ;
44616: LD_ADDR_EXP 120
44620: PUSH
44621: LD_INT 0
44623: ST_TO_ADDR
// sRemote := false ;
44624: LD_ADDR_EXP 121
44628: PUSH
44629: LD_INT 0
44631: ST_TO_ADDR
// sPowell := false ;
44632: LD_ADDR_EXP 122
44636: PUSH
44637: LD_INT 0
44639: ST_TO_ADDR
// sTeleport := false ;
44640: LD_ADDR_EXP 125
44644: PUSH
44645: LD_INT 0
44647: ST_TO_ADDR
// sOilTower := false ;
44648: LD_ADDR_EXP 127
44652: PUSH
44653: LD_INT 0
44655: ST_TO_ADDR
// sShovel := false ;
44656: LD_ADDR_EXP 128
44660: PUSH
44661: LD_INT 0
44663: ST_TO_ADDR
// sSheik := false ;
44664: LD_ADDR_EXP 129
44668: PUSH
44669: LD_INT 0
44671: ST_TO_ADDR
// sEarthquake := false ;
44672: LD_ADDR_EXP 131
44676: PUSH
44677: LD_INT 0
44679: ST_TO_ADDR
// sAI := false ;
44680: LD_ADDR_EXP 132
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sCargo := false ;
44688: LD_ADDR_EXP 135
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sDLaser := false ;
44696: LD_ADDR_EXP 136
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sExchange := false ;
44704: LD_ADDR_EXP 137
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sFac := false ;
44712: LD_ADDR_EXP 138
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sPower := false ;
44720: LD_ADDR_EXP 139
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sRandom := false ;
44728: LD_ADDR_EXP 140
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sShield := false ;
44736: LD_ADDR_EXP 141
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sTime := false ;
44744: LD_ADDR_EXP 142
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sTools := false ;
44752: LD_ADDR_EXP 143
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sSold := false ;
44760: LD_ADDR_EXP 108
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sDiff := false ;
44768: LD_ADDR_EXP 109
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sFog := false ;
44776: LD_ADDR_EXP 112
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sReset := false ;
44784: LD_ADDR_EXP 113
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sSun := false ;
44792: LD_ADDR_EXP 114
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sTiger := false ;
44800: LD_ADDR_EXP 110
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sBomb := false ;
44808: LD_ADDR_EXP 111
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sWound := false ;
44816: LD_ADDR_EXP 119
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sBetray := false ;
44824: LD_ADDR_EXP 123
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sContamin := false ;
44832: LD_ADDR_EXP 124
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sOil := false ;
44840: LD_ADDR_EXP 126
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sStu := false ;
44848: LD_ADDR_EXP 130
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sBazooka := false ;
44856: LD_ADDR_EXP 133
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sMortar := false ;
44864: LD_ADDR_EXP 134
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// sRanger := false ;
44872: LD_ADDR_EXP 144
44876: PUSH
44877: LD_INT 0
44879: ST_TO_ADDR
// end ;
44880: LD_VAR 0 1
44884: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44885: LD_INT 0
44887: PPUSH
44888: PPUSH
44889: PPUSH
44890: PPUSH
44891: PPUSH
// result := [ ] ;
44892: LD_ADDR_VAR 0 1
44896: PUSH
44897: EMPTY
44898: ST_TO_ADDR
// if campaign_id = 1 then
44899: LD_OWVAR 69
44903: PUSH
44904: LD_INT 1
44906: EQUAL
44907: IFFALSE 47845
// begin case mission_number of 1 :
44909: LD_OWVAR 70
44913: PUSH
44914: LD_INT 1
44916: DOUBLE
44917: EQUAL
44918: IFTRUE 44922
44920: GO 44986
44922: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44923: LD_ADDR_VAR 0 1
44927: PUSH
44928: LD_INT 2
44930: PUSH
44931: LD_INT 4
44933: PUSH
44934: LD_INT 11
44936: PUSH
44937: LD_INT 12
44939: PUSH
44940: LD_INT 15
44942: PUSH
44943: LD_INT 16
44945: PUSH
44946: LD_INT 22
44948: PUSH
44949: LD_INT 23
44951: PUSH
44952: LD_INT 26
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 101
44968: PUSH
44969: LD_INT 102
44971: PUSH
44972: LD_INT 106
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: LIST
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: ST_TO_ADDR
44984: GO 47843
44986: LD_INT 2
44988: DOUBLE
44989: EQUAL
44990: IFTRUE 44994
44992: GO 45066
44994: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44995: LD_ADDR_VAR 0 1
44999: PUSH
45000: LD_INT 2
45002: PUSH
45003: LD_INT 4
45005: PUSH
45006: LD_INT 11
45008: PUSH
45009: LD_INT 12
45011: PUSH
45012: LD_INT 15
45014: PUSH
45015: LD_INT 16
45017: PUSH
45018: LD_INT 22
45020: PUSH
45021: LD_INT 23
45023: PUSH
45024: LD_INT 26
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 101
45040: PUSH
45041: LD_INT 102
45043: PUSH
45044: LD_INT 105
45046: PUSH
45047: LD_INT 106
45049: PUSH
45050: LD_INT 108
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: ST_TO_ADDR
45064: GO 47843
45066: LD_INT 3
45068: DOUBLE
45069: EQUAL
45070: IFTRUE 45074
45072: GO 45150
45074: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45075: LD_ADDR_VAR 0 1
45079: PUSH
45080: LD_INT 2
45082: PUSH
45083: LD_INT 4
45085: PUSH
45086: LD_INT 5
45088: PUSH
45089: LD_INT 11
45091: PUSH
45092: LD_INT 12
45094: PUSH
45095: LD_INT 15
45097: PUSH
45098: LD_INT 16
45100: PUSH
45101: LD_INT 22
45103: PUSH
45104: LD_INT 26
45106: PUSH
45107: LD_INT 36
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 101
45124: PUSH
45125: LD_INT 102
45127: PUSH
45128: LD_INT 105
45130: PUSH
45131: LD_INT 106
45133: PUSH
45134: LD_INT 108
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: ST_TO_ADDR
45148: GO 47843
45150: LD_INT 4
45152: DOUBLE
45153: EQUAL
45154: IFTRUE 45158
45156: GO 45242
45158: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45159: LD_ADDR_VAR 0 1
45163: PUSH
45164: LD_INT 2
45166: PUSH
45167: LD_INT 4
45169: PUSH
45170: LD_INT 5
45172: PUSH
45173: LD_INT 8
45175: PUSH
45176: LD_INT 11
45178: PUSH
45179: LD_INT 12
45181: PUSH
45182: LD_INT 15
45184: PUSH
45185: LD_INT 16
45187: PUSH
45188: LD_INT 22
45190: PUSH
45191: LD_INT 23
45193: PUSH
45194: LD_INT 26
45196: PUSH
45197: LD_INT 36
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 101
45216: PUSH
45217: LD_INT 102
45219: PUSH
45220: LD_INT 105
45222: PUSH
45223: LD_INT 106
45225: PUSH
45226: LD_INT 108
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: LIST
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: ST_TO_ADDR
45240: GO 47843
45242: LD_INT 5
45244: DOUBLE
45245: EQUAL
45246: IFTRUE 45250
45248: GO 45350
45250: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45251: LD_ADDR_VAR 0 1
45255: PUSH
45256: LD_INT 2
45258: PUSH
45259: LD_INT 4
45261: PUSH
45262: LD_INT 5
45264: PUSH
45265: LD_INT 6
45267: PUSH
45268: LD_INT 8
45270: PUSH
45271: LD_INT 11
45273: PUSH
45274: LD_INT 12
45276: PUSH
45277: LD_INT 15
45279: PUSH
45280: LD_INT 16
45282: PUSH
45283: LD_INT 22
45285: PUSH
45286: LD_INT 23
45288: PUSH
45289: LD_INT 25
45291: PUSH
45292: LD_INT 26
45294: PUSH
45295: LD_INT 36
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 101
45316: PUSH
45317: LD_INT 102
45319: PUSH
45320: LD_INT 105
45322: PUSH
45323: LD_INT 106
45325: PUSH
45326: LD_INT 108
45328: PUSH
45329: LD_INT 109
45331: PUSH
45332: LD_INT 112
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: ST_TO_ADDR
45348: GO 47843
45350: LD_INT 6
45352: DOUBLE
45353: EQUAL
45354: IFTRUE 45358
45356: GO 45478
45358: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45359: LD_ADDR_VAR 0 1
45363: PUSH
45364: LD_INT 2
45366: PUSH
45367: LD_INT 4
45369: PUSH
45370: LD_INT 5
45372: PUSH
45373: LD_INT 6
45375: PUSH
45376: LD_INT 8
45378: PUSH
45379: LD_INT 11
45381: PUSH
45382: LD_INT 12
45384: PUSH
45385: LD_INT 15
45387: PUSH
45388: LD_INT 16
45390: PUSH
45391: LD_INT 20
45393: PUSH
45394: LD_INT 21
45396: PUSH
45397: LD_INT 22
45399: PUSH
45400: LD_INT 23
45402: PUSH
45403: LD_INT 25
45405: PUSH
45406: LD_INT 26
45408: PUSH
45409: LD_INT 30
45411: PUSH
45412: LD_INT 31
45414: PUSH
45415: LD_INT 32
45417: PUSH
45418: LD_INT 36
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 101
45444: PUSH
45445: LD_INT 102
45447: PUSH
45448: LD_INT 105
45450: PUSH
45451: LD_INT 106
45453: PUSH
45454: LD_INT 108
45456: PUSH
45457: LD_INT 109
45459: PUSH
45460: LD_INT 112
45462: PUSH
45463: EMPTY
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: ST_TO_ADDR
45476: GO 47843
45478: LD_INT 7
45480: DOUBLE
45481: EQUAL
45482: IFTRUE 45486
45484: GO 45586
45486: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45487: LD_ADDR_VAR 0 1
45491: PUSH
45492: LD_INT 2
45494: PUSH
45495: LD_INT 4
45497: PUSH
45498: LD_INT 5
45500: PUSH
45501: LD_INT 7
45503: PUSH
45504: LD_INT 11
45506: PUSH
45507: LD_INT 12
45509: PUSH
45510: LD_INT 15
45512: PUSH
45513: LD_INT 16
45515: PUSH
45516: LD_INT 20
45518: PUSH
45519: LD_INT 21
45521: PUSH
45522: LD_INT 22
45524: PUSH
45525: LD_INT 23
45527: PUSH
45528: LD_INT 25
45530: PUSH
45531: LD_INT 26
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: PUSH
45550: LD_INT 101
45552: PUSH
45553: LD_INT 102
45555: PUSH
45556: LD_INT 103
45558: PUSH
45559: LD_INT 105
45561: PUSH
45562: LD_INT 106
45564: PUSH
45565: LD_INT 108
45567: PUSH
45568: LD_INT 112
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: ST_TO_ADDR
45584: GO 47843
45586: LD_INT 8
45588: DOUBLE
45589: EQUAL
45590: IFTRUE 45594
45592: GO 45722
45594: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45595: LD_ADDR_VAR 0 1
45599: PUSH
45600: LD_INT 2
45602: PUSH
45603: LD_INT 4
45605: PUSH
45606: LD_INT 5
45608: PUSH
45609: LD_INT 6
45611: PUSH
45612: LD_INT 7
45614: PUSH
45615: LD_INT 8
45617: PUSH
45618: LD_INT 11
45620: PUSH
45621: LD_INT 12
45623: PUSH
45624: LD_INT 15
45626: PUSH
45627: LD_INT 16
45629: PUSH
45630: LD_INT 20
45632: PUSH
45633: LD_INT 21
45635: PUSH
45636: LD_INT 22
45638: PUSH
45639: LD_INT 23
45641: PUSH
45642: LD_INT 25
45644: PUSH
45645: LD_INT 26
45647: PUSH
45648: LD_INT 30
45650: PUSH
45651: LD_INT 31
45653: PUSH
45654: LD_INT 32
45656: PUSH
45657: LD_INT 36
45659: PUSH
45660: EMPTY
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: PUSH
45682: LD_INT 101
45684: PUSH
45685: LD_INT 102
45687: PUSH
45688: LD_INT 103
45690: PUSH
45691: LD_INT 105
45693: PUSH
45694: LD_INT 106
45696: PUSH
45697: LD_INT 108
45699: PUSH
45700: LD_INT 109
45702: PUSH
45703: LD_INT 112
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: LIST
45713: LIST
45714: LIST
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: ST_TO_ADDR
45720: GO 47843
45722: LD_INT 9
45724: DOUBLE
45725: EQUAL
45726: IFTRUE 45730
45728: GO 45866
45730: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45731: LD_ADDR_VAR 0 1
45735: PUSH
45736: LD_INT 2
45738: PUSH
45739: LD_INT 4
45741: PUSH
45742: LD_INT 5
45744: PUSH
45745: LD_INT 6
45747: PUSH
45748: LD_INT 7
45750: PUSH
45751: LD_INT 8
45753: PUSH
45754: LD_INT 11
45756: PUSH
45757: LD_INT 12
45759: PUSH
45760: LD_INT 15
45762: PUSH
45763: LD_INT 16
45765: PUSH
45766: LD_INT 20
45768: PUSH
45769: LD_INT 21
45771: PUSH
45772: LD_INT 22
45774: PUSH
45775: LD_INT 23
45777: PUSH
45778: LD_INT 25
45780: PUSH
45781: LD_INT 26
45783: PUSH
45784: LD_INT 28
45786: PUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 31
45792: PUSH
45793: LD_INT 32
45795: PUSH
45796: LD_INT 36
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: LIST
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 101
45824: PUSH
45825: LD_INT 102
45827: PUSH
45828: LD_INT 103
45830: PUSH
45831: LD_INT 105
45833: PUSH
45834: LD_INT 106
45836: PUSH
45837: LD_INT 108
45839: PUSH
45840: LD_INT 109
45842: PUSH
45843: LD_INT 112
45845: PUSH
45846: LD_INT 114
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: ST_TO_ADDR
45864: GO 47843
45866: LD_INT 10
45868: DOUBLE
45869: EQUAL
45870: IFTRUE 45874
45872: GO 46058
45874: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45875: LD_ADDR_VAR 0 1
45879: PUSH
45880: LD_INT 2
45882: PUSH
45883: LD_INT 4
45885: PUSH
45886: LD_INT 5
45888: PUSH
45889: LD_INT 6
45891: PUSH
45892: LD_INT 7
45894: PUSH
45895: LD_INT 8
45897: PUSH
45898: LD_INT 9
45900: PUSH
45901: LD_INT 10
45903: PUSH
45904: LD_INT 11
45906: PUSH
45907: LD_INT 12
45909: PUSH
45910: LD_INT 13
45912: PUSH
45913: LD_INT 14
45915: PUSH
45916: LD_INT 15
45918: PUSH
45919: LD_INT 16
45921: PUSH
45922: LD_INT 17
45924: PUSH
45925: LD_INT 18
45927: PUSH
45928: LD_INT 19
45930: PUSH
45931: LD_INT 20
45933: PUSH
45934: LD_INT 21
45936: PUSH
45937: LD_INT 22
45939: PUSH
45940: LD_INT 23
45942: PUSH
45943: LD_INT 24
45945: PUSH
45946: LD_INT 25
45948: PUSH
45949: LD_INT 26
45951: PUSH
45952: LD_INT 28
45954: PUSH
45955: LD_INT 30
45957: PUSH
45958: LD_INT 31
45960: PUSH
45961: LD_INT 32
45963: PUSH
45964: LD_INT 36
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 101
46000: PUSH
46001: LD_INT 102
46003: PUSH
46004: LD_INT 103
46006: PUSH
46007: LD_INT 104
46009: PUSH
46010: LD_INT 105
46012: PUSH
46013: LD_INT 106
46015: PUSH
46016: LD_INT 107
46018: PUSH
46019: LD_INT 108
46021: PUSH
46022: LD_INT 109
46024: PUSH
46025: LD_INT 110
46027: PUSH
46028: LD_INT 111
46030: PUSH
46031: LD_INT 112
46033: PUSH
46034: LD_INT 114
46036: PUSH
46037: EMPTY
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: ST_TO_ADDR
46056: GO 47843
46058: LD_INT 11
46060: DOUBLE
46061: EQUAL
46062: IFTRUE 46066
46064: GO 46258
46066: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46067: LD_ADDR_VAR 0 1
46071: PUSH
46072: LD_INT 2
46074: PUSH
46075: LD_INT 3
46077: PUSH
46078: LD_INT 4
46080: PUSH
46081: LD_INT 5
46083: PUSH
46084: LD_INT 6
46086: PUSH
46087: LD_INT 7
46089: PUSH
46090: LD_INT 8
46092: PUSH
46093: LD_INT 9
46095: PUSH
46096: LD_INT 10
46098: PUSH
46099: LD_INT 11
46101: PUSH
46102: LD_INT 12
46104: PUSH
46105: LD_INT 13
46107: PUSH
46108: LD_INT 14
46110: PUSH
46111: LD_INT 15
46113: PUSH
46114: LD_INT 16
46116: PUSH
46117: LD_INT 17
46119: PUSH
46120: LD_INT 18
46122: PUSH
46123: LD_INT 19
46125: PUSH
46126: LD_INT 20
46128: PUSH
46129: LD_INT 21
46131: PUSH
46132: LD_INT 22
46134: PUSH
46135: LD_INT 23
46137: PUSH
46138: LD_INT 24
46140: PUSH
46141: LD_INT 25
46143: PUSH
46144: LD_INT 26
46146: PUSH
46147: LD_INT 28
46149: PUSH
46150: LD_INT 30
46152: PUSH
46153: LD_INT 31
46155: PUSH
46156: LD_INT 32
46158: PUSH
46159: LD_INT 34
46161: PUSH
46162: LD_INT 36
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 101
46200: PUSH
46201: LD_INT 102
46203: PUSH
46204: LD_INT 103
46206: PUSH
46207: LD_INT 104
46209: PUSH
46210: LD_INT 105
46212: PUSH
46213: LD_INT 106
46215: PUSH
46216: LD_INT 107
46218: PUSH
46219: LD_INT 108
46221: PUSH
46222: LD_INT 109
46224: PUSH
46225: LD_INT 110
46227: PUSH
46228: LD_INT 111
46230: PUSH
46231: LD_INT 112
46233: PUSH
46234: LD_INT 114
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: LIST
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: ST_TO_ADDR
46256: GO 47843
46258: LD_INT 12
46260: DOUBLE
46261: EQUAL
46262: IFTRUE 46266
46264: GO 46474
46266: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46267: LD_ADDR_VAR 0 1
46271: PUSH
46272: LD_INT 1
46274: PUSH
46275: LD_INT 2
46277: PUSH
46278: LD_INT 3
46280: PUSH
46281: LD_INT 4
46283: PUSH
46284: LD_INT 5
46286: PUSH
46287: LD_INT 6
46289: PUSH
46290: LD_INT 7
46292: PUSH
46293: LD_INT 8
46295: PUSH
46296: LD_INT 9
46298: PUSH
46299: LD_INT 10
46301: PUSH
46302: LD_INT 11
46304: PUSH
46305: LD_INT 12
46307: PUSH
46308: LD_INT 13
46310: PUSH
46311: LD_INT 14
46313: PUSH
46314: LD_INT 15
46316: PUSH
46317: LD_INT 16
46319: PUSH
46320: LD_INT 17
46322: PUSH
46323: LD_INT 18
46325: PUSH
46326: LD_INT 19
46328: PUSH
46329: LD_INT 20
46331: PUSH
46332: LD_INT 21
46334: PUSH
46335: LD_INT 22
46337: PUSH
46338: LD_INT 23
46340: PUSH
46341: LD_INT 24
46343: PUSH
46344: LD_INT 25
46346: PUSH
46347: LD_INT 26
46349: PUSH
46350: LD_INT 27
46352: PUSH
46353: LD_INT 28
46355: PUSH
46356: LD_INT 30
46358: PUSH
46359: LD_INT 31
46361: PUSH
46362: LD_INT 32
46364: PUSH
46365: LD_INT 33
46367: PUSH
46368: LD_INT 34
46370: PUSH
46371: LD_INT 36
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: PUSH
46410: LD_INT 101
46412: PUSH
46413: LD_INT 102
46415: PUSH
46416: LD_INT 103
46418: PUSH
46419: LD_INT 104
46421: PUSH
46422: LD_INT 105
46424: PUSH
46425: LD_INT 106
46427: PUSH
46428: LD_INT 107
46430: PUSH
46431: LD_INT 108
46433: PUSH
46434: LD_INT 109
46436: PUSH
46437: LD_INT 110
46439: PUSH
46440: LD_INT 111
46442: PUSH
46443: LD_INT 112
46445: PUSH
46446: LD_INT 113
46448: PUSH
46449: LD_INT 114
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: ST_TO_ADDR
46472: GO 47843
46474: LD_INT 13
46476: DOUBLE
46477: EQUAL
46478: IFTRUE 46482
46480: GO 46678
46482: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46483: LD_ADDR_VAR 0 1
46487: PUSH
46488: LD_INT 1
46490: PUSH
46491: LD_INT 2
46493: PUSH
46494: LD_INT 3
46496: PUSH
46497: LD_INT 4
46499: PUSH
46500: LD_INT 5
46502: PUSH
46503: LD_INT 8
46505: PUSH
46506: LD_INT 9
46508: PUSH
46509: LD_INT 10
46511: PUSH
46512: LD_INT 11
46514: PUSH
46515: LD_INT 12
46517: PUSH
46518: LD_INT 14
46520: PUSH
46521: LD_INT 15
46523: PUSH
46524: LD_INT 16
46526: PUSH
46527: LD_INT 17
46529: PUSH
46530: LD_INT 18
46532: PUSH
46533: LD_INT 19
46535: PUSH
46536: LD_INT 20
46538: PUSH
46539: LD_INT 21
46541: PUSH
46542: LD_INT 22
46544: PUSH
46545: LD_INT 23
46547: PUSH
46548: LD_INT 24
46550: PUSH
46551: LD_INT 25
46553: PUSH
46554: LD_INT 26
46556: PUSH
46557: LD_INT 27
46559: PUSH
46560: LD_INT 28
46562: PUSH
46563: LD_INT 30
46565: PUSH
46566: LD_INT 31
46568: PUSH
46569: LD_INT 32
46571: PUSH
46572: LD_INT 33
46574: PUSH
46575: LD_INT 34
46577: PUSH
46578: LD_INT 36
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: PUSH
46614: LD_INT 101
46616: PUSH
46617: LD_INT 102
46619: PUSH
46620: LD_INT 103
46622: PUSH
46623: LD_INT 104
46625: PUSH
46626: LD_INT 105
46628: PUSH
46629: LD_INT 106
46631: PUSH
46632: LD_INT 107
46634: PUSH
46635: LD_INT 108
46637: PUSH
46638: LD_INT 109
46640: PUSH
46641: LD_INT 110
46643: PUSH
46644: LD_INT 111
46646: PUSH
46647: LD_INT 112
46649: PUSH
46650: LD_INT 113
46652: PUSH
46653: LD_INT 114
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: ST_TO_ADDR
46676: GO 47843
46678: LD_INT 14
46680: DOUBLE
46681: EQUAL
46682: IFTRUE 46686
46684: GO 46898
46686: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46687: LD_ADDR_VAR 0 1
46691: PUSH
46692: LD_INT 1
46694: PUSH
46695: LD_INT 2
46697: PUSH
46698: LD_INT 3
46700: PUSH
46701: LD_INT 4
46703: PUSH
46704: LD_INT 5
46706: PUSH
46707: LD_INT 6
46709: PUSH
46710: LD_INT 7
46712: PUSH
46713: LD_INT 8
46715: PUSH
46716: LD_INT 9
46718: PUSH
46719: LD_INT 10
46721: PUSH
46722: LD_INT 11
46724: PUSH
46725: LD_INT 12
46727: PUSH
46728: LD_INT 13
46730: PUSH
46731: LD_INT 14
46733: PUSH
46734: LD_INT 15
46736: PUSH
46737: LD_INT 16
46739: PUSH
46740: LD_INT 17
46742: PUSH
46743: LD_INT 18
46745: PUSH
46746: LD_INT 19
46748: PUSH
46749: LD_INT 20
46751: PUSH
46752: LD_INT 21
46754: PUSH
46755: LD_INT 22
46757: PUSH
46758: LD_INT 23
46760: PUSH
46761: LD_INT 24
46763: PUSH
46764: LD_INT 25
46766: PUSH
46767: LD_INT 26
46769: PUSH
46770: LD_INT 27
46772: PUSH
46773: LD_INT 28
46775: PUSH
46776: LD_INT 29
46778: PUSH
46779: LD_INT 30
46781: PUSH
46782: LD_INT 31
46784: PUSH
46785: LD_INT 32
46787: PUSH
46788: LD_INT 33
46790: PUSH
46791: LD_INT 34
46793: PUSH
46794: LD_INT 36
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 101
46836: PUSH
46837: LD_INT 102
46839: PUSH
46840: LD_INT 103
46842: PUSH
46843: LD_INT 104
46845: PUSH
46846: LD_INT 105
46848: PUSH
46849: LD_INT 106
46851: PUSH
46852: LD_INT 107
46854: PUSH
46855: LD_INT 108
46857: PUSH
46858: LD_INT 109
46860: PUSH
46861: LD_INT 110
46863: PUSH
46864: LD_INT 111
46866: PUSH
46867: LD_INT 112
46869: PUSH
46870: LD_INT 113
46872: PUSH
46873: LD_INT 114
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: LIST
46884: LIST
46885: LIST
46886: LIST
46887: LIST
46888: LIST
46889: LIST
46890: LIST
46891: PUSH
46892: EMPTY
46893: LIST
46894: LIST
46895: ST_TO_ADDR
46896: GO 47843
46898: LD_INT 15
46900: DOUBLE
46901: EQUAL
46902: IFTRUE 46906
46904: GO 47118
46906: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46907: LD_ADDR_VAR 0 1
46911: PUSH
46912: LD_INT 1
46914: PUSH
46915: LD_INT 2
46917: PUSH
46918: LD_INT 3
46920: PUSH
46921: LD_INT 4
46923: PUSH
46924: LD_INT 5
46926: PUSH
46927: LD_INT 6
46929: PUSH
46930: LD_INT 7
46932: PUSH
46933: LD_INT 8
46935: PUSH
46936: LD_INT 9
46938: PUSH
46939: LD_INT 10
46941: PUSH
46942: LD_INT 11
46944: PUSH
46945: LD_INT 12
46947: PUSH
46948: LD_INT 13
46950: PUSH
46951: LD_INT 14
46953: PUSH
46954: LD_INT 15
46956: PUSH
46957: LD_INT 16
46959: PUSH
46960: LD_INT 17
46962: PUSH
46963: LD_INT 18
46965: PUSH
46966: LD_INT 19
46968: PUSH
46969: LD_INT 20
46971: PUSH
46972: LD_INT 21
46974: PUSH
46975: LD_INT 22
46977: PUSH
46978: LD_INT 23
46980: PUSH
46981: LD_INT 24
46983: PUSH
46984: LD_INT 25
46986: PUSH
46987: LD_INT 26
46989: PUSH
46990: LD_INT 27
46992: PUSH
46993: LD_INT 28
46995: PUSH
46996: LD_INT 29
46998: PUSH
46999: LD_INT 30
47001: PUSH
47002: LD_INT 31
47004: PUSH
47005: LD_INT 32
47007: PUSH
47008: LD_INT 33
47010: PUSH
47011: LD_INT 34
47013: PUSH
47014: LD_INT 36
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 101
47056: PUSH
47057: LD_INT 102
47059: PUSH
47060: LD_INT 103
47062: PUSH
47063: LD_INT 104
47065: PUSH
47066: LD_INT 105
47068: PUSH
47069: LD_INT 106
47071: PUSH
47072: LD_INT 107
47074: PUSH
47075: LD_INT 108
47077: PUSH
47078: LD_INT 109
47080: PUSH
47081: LD_INT 110
47083: PUSH
47084: LD_INT 111
47086: PUSH
47087: LD_INT 112
47089: PUSH
47090: LD_INT 113
47092: PUSH
47093: LD_INT 114
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: PUSH
47112: EMPTY
47113: LIST
47114: LIST
47115: ST_TO_ADDR
47116: GO 47843
47118: LD_INT 16
47120: DOUBLE
47121: EQUAL
47122: IFTRUE 47126
47124: GO 47250
47126: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47127: LD_ADDR_VAR 0 1
47131: PUSH
47132: LD_INT 2
47134: PUSH
47135: LD_INT 4
47137: PUSH
47138: LD_INT 5
47140: PUSH
47141: LD_INT 7
47143: PUSH
47144: LD_INT 11
47146: PUSH
47147: LD_INT 12
47149: PUSH
47150: LD_INT 15
47152: PUSH
47153: LD_INT 16
47155: PUSH
47156: LD_INT 20
47158: PUSH
47159: LD_INT 21
47161: PUSH
47162: LD_INT 22
47164: PUSH
47165: LD_INT 23
47167: PUSH
47168: LD_INT 25
47170: PUSH
47171: LD_INT 26
47173: PUSH
47174: LD_INT 30
47176: PUSH
47177: LD_INT 31
47179: PUSH
47180: LD_INT 32
47182: PUSH
47183: LD_INT 33
47185: PUSH
47186: LD_INT 34
47188: PUSH
47189: EMPTY
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: PUSH
47210: LD_INT 101
47212: PUSH
47213: LD_INT 102
47215: PUSH
47216: LD_INT 103
47218: PUSH
47219: LD_INT 106
47221: PUSH
47222: LD_INT 108
47224: PUSH
47225: LD_INT 112
47227: PUSH
47228: LD_INT 113
47230: PUSH
47231: LD_INT 114
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: LIST
47238: LIST
47239: LIST
47240: LIST
47241: LIST
47242: LIST
47243: PUSH
47244: EMPTY
47245: LIST
47246: LIST
47247: ST_TO_ADDR
47248: GO 47843
47250: LD_INT 17
47252: DOUBLE
47253: EQUAL
47254: IFTRUE 47258
47256: GO 47470
47258: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47259: LD_ADDR_VAR 0 1
47263: PUSH
47264: LD_INT 1
47266: PUSH
47267: LD_INT 2
47269: PUSH
47270: LD_INT 3
47272: PUSH
47273: LD_INT 4
47275: PUSH
47276: LD_INT 5
47278: PUSH
47279: LD_INT 6
47281: PUSH
47282: LD_INT 7
47284: PUSH
47285: LD_INT 8
47287: PUSH
47288: LD_INT 9
47290: PUSH
47291: LD_INT 10
47293: PUSH
47294: LD_INT 11
47296: PUSH
47297: LD_INT 12
47299: PUSH
47300: LD_INT 13
47302: PUSH
47303: LD_INT 14
47305: PUSH
47306: LD_INT 15
47308: PUSH
47309: LD_INT 16
47311: PUSH
47312: LD_INT 17
47314: PUSH
47315: LD_INT 18
47317: PUSH
47318: LD_INT 19
47320: PUSH
47321: LD_INT 20
47323: PUSH
47324: LD_INT 21
47326: PUSH
47327: LD_INT 22
47329: PUSH
47330: LD_INT 23
47332: PUSH
47333: LD_INT 24
47335: PUSH
47336: LD_INT 25
47338: PUSH
47339: LD_INT 26
47341: PUSH
47342: LD_INT 27
47344: PUSH
47345: LD_INT 28
47347: PUSH
47348: LD_INT 29
47350: PUSH
47351: LD_INT 30
47353: PUSH
47354: LD_INT 31
47356: PUSH
47357: LD_INT 32
47359: PUSH
47360: LD_INT 33
47362: PUSH
47363: LD_INT 34
47365: PUSH
47366: LD_INT 36
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: LIST
47404: LIST
47405: PUSH
47406: LD_INT 101
47408: PUSH
47409: LD_INT 102
47411: PUSH
47412: LD_INT 103
47414: PUSH
47415: LD_INT 104
47417: PUSH
47418: LD_INT 105
47420: PUSH
47421: LD_INT 106
47423: PUSH
47424: LD_INT 107
47426: PUSH
47427: LD_INT 108
47429: PUSH
47430: LD_INT 109
47432: PUSH
47433: LD_INT 110
47435: PUSH
47436: LD_INT 111
47438: PUSH
47439: LD_INT 112
47441: PUSH
47442: LD_INT 113
47444: PUSH
47445: LD_INT 114
47447: PUSH
47448: EMPTY
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: ST_TO_ADDR
47468: GO 47843
47470: LD_INT 18
47472: DOUBLE
47473: EQUAL
47474: IFTRUE 47478
47476: GO 47614
47478: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47479: LD_ADDR_VAR 0 1
47483: PUSH
47484: LD_INT 2
47486: PUSH
47487: LD_INT 4
47489: PUSH
47490: LD_INT 5
47492: PUSH
47493: LD_INT 7
47495: PUSH
47496: LD_INT 11
47498: PUSH
47499: LD_INT 12
47501: PUSH
47502: LD_INT 15
47504: PUSH
47505: LD_INT 16
47507: PUSH
47508: LD_INT 20
47510: PUSH
47511: LD_INT 21
47513: PUSH
47514: LD_INT 22
47516: PUSH
47517: LD_INT 23
47519: PUSH
47520: LD_INT 25
47522: PUSH
47523: LD_INT 26
47525: PUSH
47526: LD_INT 30
47528: PUSH
47529: LD_INT 31
47531: PUSH
47532: LD_INT 32
47534: PUSH
47535: LD_INT 33
47537: PUSH
47538: LD_INT 34
47540: PUSH
47541: LD_INT 35
47543: PUSH
47544: LD_INT 36
47546: PUSH
47547: EMPTY
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 101
47572: PUSH
47573: LD_INT 102
47575: PUSH
47576: LD_INT 103
47578: PUSH
47579: LD_INT 106
47581: PUSH
47582: LD_INT 108
47584: PUSH
47585: LD_INT 112
47587: PUSH
47588: LD_INT 113
47590: PUSH
47591: LD_INT 114
47593: PUSH
47594: LD_INT 115
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: ST_TO_ADDR
47612: GO 47843
47614: LD_INT 19
47616: DOUBLE
47617: EQUAL
47618: IFTRUE 47622
47620: GO 47842
47622: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47623: LD_ADDR_VAR 0 1
47627: PUSH
47628: LD_INT 1
47630: PUSH
47631: LD_INT 2
47633: PUSH
47634: LD_INT 3
47636: PUSH
47637: LD_INT 4
47639: PUSH
47640: LD_INT 5
47642: PUSH
47643: LD_INT 6
47645: PUSH
47646: LD_INT 7
47648: PUSH
47649: LD_INT 8
47651: PUSH
47652: LD_INT 9
47654: PUSH
47655: LD_INT 10
47657: PUSH
47658: LD_INT 11
47660: PUSH
47661: LD_INT 12
47663: PUSH
47664: LD_INT 13
47666: PUSH
47667: LD_INT 14
47669: PUSH
47670: LD_INT 15
47672: PUSH
47673: LD_INT 16
47675: PUSH
47676: LD_INT 17
47678: PUSH
47679: LD_INT 18
47681: PUSH
47682: LD_INT 19
47684: PUSH
47685: LD_INT 20
47687: PUSH
47688: LD_INT 21
47690: PUSH
47691: LD_INT 22
47693: PUSH
47694: LD_INT 23
47696: PUSH
47697: LD_INT 24
47699: PUSH
47700: LD_INT 25
47702: PUSH
47703: LD_INT 26
47705: PUSH
47706: LD_INT 27
47708: PUSH
47709: LD_INT 28
47711: PUSH
47712: LD_INT 29
47714: PUSH
47715: LD_INT 30
47717: PUSH
47718: LD_INT 31
47720: PUSH
47721: LD_INT 32
47723: PUSH
47724: LD_INT 33
47726: PUSH
47727: LD_INT 34
47729: PUSH
47730: LD_INT 35
47732: PUSH
47733: LD_INT 36
47735: PUSH
47736: EMPTY
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: LIST
47767: LIST
47768: LIST
47769: LIST
47770: LIST
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 101
47776: PUSH
47777: LD_INT 102
47779: PUSH
47780: LD_INT 103
47782: PUSH
47783: LD_INT 104
47785: PUSH
47786: LD_INT 105
47788: PUSH
47789: LD_INT 106
47791: PUSH
47792: LD_INT 107
47794: PUSH
47795: LD_INT 108
47797: PUSH
47798: LD_INT 109
47800: PUSH
47801: LD_INT 110
47803: PUSH
47804: LD_INT 111
47806: PUSH
47807: LD_INT 112
47809: PUSH
47810: LD_INT 113
47812: PUSH
47813: LD_INT 114
47815: PUSH
47816: LD_INT 115
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: ST_TO_ADDR
47840: GO 47843
47842: POP
// end else
47843: GO 48062
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47845: LD_ADDR_VAR 0 1
47849: PUSH
47850: LD_INT 1
47852: PUSH
47853: LD_INT 2
47855: PUSH
47856: LD_INT 3
47858: PUSH
47859: LD_INT 4
47861: PUSH
47862: LD_INT 5
47864: PUSH
47865: LD_INT 6
47867: PUSH
47868: LD_INT 7
47870: PUSH
47871: LD_INT 8
47873: PUSH
47874: LD_INT 9
47876: PUSH
47877: LD_INT 10
47879: PUSH
47880: LD_INT 11
47882: PUSH
47883: LD_INT 12
47885: PUSH
47886: LD_INT 13
47888: PUSH
47889: LD_INT 14
47891: PUSH
47892: LD_INT 15
47894: PUSH
47895: LD_INT 16
47897: PUSH
47898: LD_INT 17
47900: PUSH
47901: LD_INT 18
47903: PUSH
47904: LD_INT 19
47906: PUSH
47907: LD_INT 20
47909: PUSH
47910: LD_INT 21
47912: PUSH
47913: LD_INT 22
47915: PUSH
47916: LD_INT 23
47918: PUSH
47919: LD_INT 24
47921: PUSH
47922: LD_INT 25
47924: PUSH
47925: LD_INT 26
47927: PUSH
47928: LD_INT 27
47930: PUSH
47931: LD_INT 28
47933: PUSH
47934: LD_INT 29
47936: PUSH
47937: LD_INT 30
47939: PUSH
47940: LD_INT 31
47942: PUSH
47943: LD_INT 32
47945: PUSH
47946: LD_INT 33
47948: PUSH
47949: LD_INT 34
47951: PUSH
47952: LD_INT 35
47954: PUSH
47955: LD_INT 36
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: PUSH
47996: LD_INT 101
47998: PUSH
47999: LD_INT 102
48001: PUSH
48002: LD_INT 103
48004: PUSH
48005: LD_INT 104
48007: PUSH
48008: LD_INT 105
48010: PUSH
48011: LD_INT 106
48013: PUSH
48014: LD_INT 107
48016: PUSH
48017: LD_INT 108
48019: PUSH
48020: LD_INT 109
48022: PUSH
48023: LD_INT 110
48025: PUSH
48026: LD_INT 111
48028: PUSH
48029: LD_INT 112
48031: PUSH
48032: LD_INT 113
48034: PUSH
48035: LD_INT 114
48037: PUSH
48038: LD_INT 115
48040: PUSH
48041: EMPTY
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: ST_TO_ADDR
// if result then
48062: LD_VAR 0 1
48066: IFFALSE 48355
// begin normal :=  ;
48068: LD_ADDR_VAR 0 3
48072: PUSH
48073: LD_STRING 
48075: ST_TO_ADDR
// hardcore :=  ;
48076: LD_ADDR_VAR 0 4
48080: PUSH
48081: LD_STRING 
48083: ST_TO_ADDR
// for i = 1 to normalCounter do
48084: LD_ADDR_VAR 0 5
48088: PUSH
48089: DOUBLE
48090: LD_INT 1
48092: DEC
48093: ST_TO_ADDR
48094: LD_EXP 92
48098: PUSH
48099: FOR_TO
48100: IFFALSE 48201
// begin tmp := 0 ;
48102: LD_ADDR_VAR 0 2
48106: PUSH
48107: LD_STRING 0
48109: ST_TO_ADDR
// if result [ 1 ] then
48110: LD_VAR 0 1
48114: PUSH
48115: LD_INT 1
48117: ARRAY
48118: IFFALSE 48183
// if result [ 1 ] [ 1 ] = i then
48120: LD_VAR 0 1
48124: PUSH
48125: LD_INT 1
48127: ARRAY
48128: PUSH
48129: LD_INT 1
48131: ARRAY
48132: PUSH
48133: LD_VAR 0 5
48137: EQUAL
48138: IFFALSE 48183
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48140: LD_ADDR_VAR 0 1
48144: PUSH
48145: LD_VAR 0 1
48149: PPUSH
48150: LD_INT 1
48152: PPUSH
48153: LD_VAR 0 1
48157: PUSH
48158: LD_INT 1
48160: ARRAY
48161: PPUSH
48162: LD_INT 1
48164: PPUSH
48165: CALL_OW 3
48169: PPUSH
48170: CALL_OW 1
48174: ST_TO_ADDR
// tmp := 1 ;
48175: LD_ADDR_VAR 0 2
48179: PUSH
48180: LD_STRING 1
48182: ST_TO_ADDR
// end ; normal := normal & tmp ;
48183: LD_ADDR_VAR 0 3
48187: PUSH
48188: LD_VAR 0 3
48192: PUSH
48193: LD_VAR 0 2
48197: STR
48198: ST_TO_ADDR
// end ;
48199: GO 48099
48201: POP
48202: POP
// for i = 1 to hardcoreCounter do
48203: LD_ADDR_VAR 0 5
48207: PUSH
48208: DOUBLE
48209: LD_INT 1
48211: DEC
48212: ST_TO_ADDR
48213: LD_EXP 93
48217: PUSH
48218: FOR_TO
48219: IFFALSE 48324
// begin tmp := 0 ;
48221: LD_ADDR_VAR 0 2
48225: PUSH
48226: LD_STRING 0
48228: ST_TO_ADDR
// if result [ 2 ] then
48229: LD_VAR 0 1
48233: PUSH
48234: LD_INT 2
48236: ARRAY
48237: IFFALSE 48306
// if result [ 2 ] [ 1 ] = 100 + i then
48239: LD_VAR 0 1
48243: PUSH
48244: LD_INT 2
48246: ARRAY
48247: PUSH
48248: LD_INT 1
48250: ARRAY
48251: PUSH
48252: LD_INT 100
48254: PUSH
48255: LD_VAR 0 5
48259: PLUS
48260: EQUAL
48261: IFFALSE 48306
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48263: LD_ADDR_VAR 0 1
48267: PUSH
48268: LD_VAR 0 1
48272: PPUSH
48273: LD_INT 2
48275: PPUSH
48276: LD_VAR 0 1
48280: PUSH
48281: LD_INT 2
48283: ARRAY
48284: PPUSH
48285: LD_INT 1
48287: PPUSH
48288: CALL_OW 3
48292: PPUSH
48293: CALL_OW 1
48297: ST_TO_ADDR
// tmp := 1 ;
48298: LD_ADDR_VAR 0 2
48302: PUSH
48303: LD_STRING 1
48305: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48306: LD_ADDR_VAR 0 4
48310: PUSH
48311: LD_VAR 0 4
48315: PUSH
48316: LD_VAR 0 2
48320: STR
48321: ST_TO_ADDR
// end ;
48322: GO 48218
48324: POP
48325: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48326: LD_STRING getStreamItemsFromMission("
48328: PUSH
48329: LD_VAR 0 3
48333: STR
48334: PUSH
48335: LD_STRING ","
48337: STR
48338: PUSH
48339: LD_VAR 0 4
48343: STR
48344: PUSH
48345: LD_STRING ")
48347: STR
48348: PPUSH
48349: CALL_OW 559
// end else
48353: GO 48362
// ToLua ( getStreamItemsFromMission("","") ) ;
48355: LD_STRING getStreamItemsFromMission("","")
48357: PPUSH
48358: CALL_OW 559
// end ;
48362: LD_VAR 0 1
48366: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48367: LD_EXP 91
48371: PUSH
48372: LD_EXP 96
48376: AND
48377: IFFALSE 48501
48379: GO 48381
48381: DISABLE
48382: LD_INT 0
48384: PPUSH
48385: PPUSH
// begin enable ;
48386: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48387: LD_ADDR_VAR 0 2
48391: PUSH
48392: LD_INT 22
48394: PUSH
48395: LD_OWVAR 2
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: LD_INT 2
48406: PUSH
48407: LD_INT 34
48409: PUSH
48410: LD_INT 7
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: PUSH
48417: LD_INT 34
48419: PUSH
48420: LD_INT 45
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: PUSH
48427: LD_INT 34
48429: PUSH
48430: LD_INT 28
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: PUSH
48437: LD_INT 34
48439: PUSH
48440: LD_INT 47
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PPUSH
48458: CALL_OW 69
48462: ST_TO_ADDR
// if not tmp then
48463: LD_VAR 0 2
48467: NOT
48468: IFFALSE 48472
// exit ;
48470: GO 48501
// for i in tmp do
48472: LD_ADDR_VAR 0 1
48476: PUSH
48477: LD_VAR 0 2
48481: PUSH
48482: FOR_IN
48483: IFFALSE 48499
// begin SetLives ( i , 0 ) ;
48485: LD_VAR 0 1
48489: PPUSH
48490: LD_INT 0
48492: PPUSH
48493: CALL_OW 234
// end ;
48497: GO 48482
48499: POP
48500: POP
// end ;
48501: PPOPN 2
48503: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48504: LD_EXP 91
48508: PUSH
48509: LD_EXP 97
48513: AND
48514: IFFALSE 48598
48516: GO 48518
48518: DISABLE
48519: LD_INT 0
48521: PPUSH
48522: PPUSH
// begin enable ;
48523: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48524: LD_ADDR_VAR 0 2
48528: PUSH
48529: LD_INT 22
48531: PUSH
48532: LD_OWVAR 2
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 32
48543: PUSH
48544: LD_INT 3
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PPUSH
48555: CALL_OW 69
48559: ST_TO_ADDR
// if not tmp then
48560: LD_VAR 0 2
48564: NOT
48565: IFFALSE 48569
// exit ;
48567: GO 48598
// for i in tmp do
48569: LD_ADDR_VAR 0 1
48573: PUSH
48574: LD_VAR 0 2
48578: PUSH
48579: FOR_IN
48580: IFFALSE 48596
// begin SetLives ( i , 0 ) ;
48582: LD_VAR 0 1
48586: PPUSH
48587: LD_INT 0
48589: PPUSH
48590: CALL_OW 234
// end ;
48594: GO 48579
48596: POP
48597: POP
// end ;
48598: PPOPN 2
48600: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48601: LD_EXP 91
48605: PUSH
48606: LD_EXP 94
48610: AND
48611: IFFALSE 48704
48613: GO 48615
48615: DISABLE
48616: LD_INT 0
48618: PPUSH
// begin enable ;
48619: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48620: LD_ADDR_VAR 0 1
48624: PUSH
48625: LD_INT 22
48627: PUSH
48628: LD_OWVAR 2
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: PUSH
48637: LD_INT 2
48639: PUSH
48640: LD_INT 25
48642: PUSH
48643: LD_INT 5
48645: PUSH
48646: EMPTY
48647: LIST
48648: LIST
48649: PUSH
48650: LD_INT 25
48652: PUSH
48653: LD_INT 9
48655: PUSH
48656: EMPTY
48657: LIST
48658: LIST
48659: PUSH
48660: LD_INT 25
48662: PUSH
48663: LD_INT 8
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: PUSH
48676: EMPTY
48677: LIST
48678: LIST
48679: PPUSH
48680: CALL_OW 69
48684: PUSH
48685: FOR_IN
48686: IFFALSE 48702
// begin SetClass ( i , 1 ) ;
48688: LD_VAR 0 1
48692: PPUSH
48693: LD_INT 1
48695: PPUSH
48696: CALL_OW 336
// end ;
48700: GO 48685
48702: POP
48703: POP
// end ;
48704: PPOPN 1
48706: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48707: LD_EXP 91
48711: PUSH
48712: LD_EXP 95
48716: AND
48717: PUSH
48718: LD_OWVAR 65
48722: PUSH
48723: LD_INT 7
48725: LESS
48726: AND
48727: IFFALSE 48741
48729: GO 48731
48731: DISABLE
// begin enable ;
48732: ENABLE
// game_speed := 7 ;
48733: LD_ADDR_OWVAR 65
48737: PUSH
48738: LD_INT 7
48740: ST_TO_ADDR
// end ;
48741: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48742: LD_EXP 91
48746: PUSH
48747: LD_EXP 98
48751: AND
48752: IFFALSE 48954
48754: GO 48756
48756: DISABLE
48757: LD_INT 0
48759: PPUSH
48760: PPUSH
48761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48762: LD_ADDR_VAR 0 3
48766: PUSH
48767: LD_INT 81
48769: PUSH
48770: LD_OWVAR 2
48774: PUSH
48775: EMPTY
48776: LIST
48777: LIST
48778: PUSH
48779: LD_INT 21
48781: PUSH
48782: LD_INT 1
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: EMPTY
48790: LIST
48791: LIST
48792: PPUSH
48793: CALL_OW 69
48797: ST_TO_ADDR
// if not tmp then
48798: LD_VAR 0 3
48802: NOT
48803: IFFALSE 48807
// exit ;
48805: GO 48954
// if tmp > 5 then
48807: LD_VAR 0 3
48811: PUSH
48812: LD_INT 5
48814: GREATER
48815: IFFALSE 48827
// k := 5 else
48817: LD_ADDR_VAR 0 2
48821: PUSH
48822: LD_INT 5
48824: ST_TO_ADDR
48825: GO 48837
// k := tmp ;
48827: LD_ADDR_VAR 0 2
48831: PUSH
48832: LD_VAR 0 3
48836: ST_TO_ADDR
// for i := 1 to k do
48837: LD_ADDR_VAR 0 1
48841: PUSH
48842: DOUBLE
48843: LD_INT 1
48845: DEC
48846: ST_TO_ADDR
48847: LD_VAR 0 2
48851: PUSH
48852: FOR_TO
48853: IFFALSE 48952
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48855: LD_VAR 0 3
48859: PUSH
48860: LD_VAR 0 1
48864: ARRAY
48865: PPUSH
48866: LD_VAR 0 1
48870: PUSH
48871: LD_INT 4
48873: MOD
48874: PUSH
48875: LD_INT 1
48877: PLUS
48878: PPUSH
48879: CALL_OW 259
48883: PUSH
48884: LD_INT 10
48886: LESS
48887: IFFALSE 48950
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48889: LD_VAR 0 3
48893: PUSH
48894: LD_VAR 0 1
48898: ARRAY
48899: PPUSH
48900: LD_VAR 0 1
48904: PUSH
48905: LD_INT 4
48907: MOD
48908: PUSH
48909: LD_INT 1
48911: PLUS
48912: PPUSH
48913: LD_VAR 0 3
48917: PUSH
48918: LD_VAR 0 1
48922: ARRAY
48923: PPUSH
48924: LD_VAR 0 1
48928: PUSH
48929: LD_INT 4
48931: MOD
48932: PUSH
48933: LD_INT 1
48935: PLUS
48936: PPUSH
48937: CALL_OW 259
48941: PUSH
48942: LD_INT 1
48944: PLUS
48945: PPUSH
48946: CALL_OW 237
48950: GO 48852
48952: POP
48953: POP
// end ;
48954: PPOPN 3
48956: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
48957: LD_EXP 91
48961: PUSH
48962: LD_EXP 99
48966: AND
48967: IFFALSE 48987
48969: GO 48971
48971: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
48972: LD_INT 4
48974: PPUSH
48975: LD_OWVAR 2
48979: PPUSH
48980: LD_INT 0
48982: PPUSH
48983: CALL_OW 324
48987: END
// every 0 0$1 trigger StreamModeActive and sShovel do
48988: LD_EXP 91
48992: PUSH
48993: LD_EXP 128
48997: AND
48998: IFFALSE 49018
49000: GO 49002
49002: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49003: LD_INT 19
49005: PPUSH
49006: LD_OWVAR 2
49010: PPUSH
49011: LD_INT 0
49013: PPUSH
49014: CALL_OW 324
49018: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49019: LD_EXP 91
49023: PUSH
49024: LD_EXP 100
49028: AND
49029: IFFALSE 49131
49031: GO 49033
49033: DISABLE
49034: LD_INT 0
49036: PPUSH
49037: PPUSH
// begin enable ;
49038: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49039: LD_ADDR_VAR 0 2
49043: PUSH
49044: LD_INT 22
49046: PUSH
49047: LD_OWVAR 2
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 2
49058: PUSH
49059: LD_INT 34
49061: PUSH
49062: LD_INT 11
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 34
49071: PUSH
49072: LD_INT 30
49074: PUSH
49075: EMPTY
49076: LIST
49077: LIST
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: LIST
49083: PUSH
49084: EMPTY
49085: LIST
49086: LIST
49087: PPUSH
49088: CALL_OW 69
49092: ST_TO_ADDR
// if not tmp then
49093: LD_VAR 0 2
49097: NOT
49098: IFFALSE 49102
// exit ;
49100: GO 49131
// for i in tmp do
49102: LD_ADDR_VAR 0 1
49106: PUSH
49107: LD_VAR 0 2
49111: PUSH
49112: FOR_IN
49113: IFFALSE 49129
// begin SetLives ( i , 0 ) ;
49115: LD_VAR 0 1
49119: PPUSH
49120: LD_INT 0
49122: PPUSH
49123: CALL_OW 234
// end ;
49127: GO 49112
49129: POP
49130: POP
// end ;
49131: PPOPN 2
49133: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49134: LD_EXP 91
49138: PUSH
49139: LD_EXP 101
49143: AND
49144: IFFALSE 49164
49146: GO 49148
49148: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49149: LD_INT 32
49151: PPUSH
49152: LD_OWVAR 2
49156: PPUSH
49157: LD_INT 0
49159: PPUSH
49160: CALL_OW 324
49164: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49165: LD_EXP 91
49169: PUSH
49170: LD_EXP 102
49174: AND
49175: IFFALSE 49356
49177: GO 49179
49179: DISABLE
49180: LD_INT 0
49182: PPUSH
49183: PPUSH
49184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49185: LD_ADDR_VAR 0 2
49189: PUSH
49190: LD_INT 22
49192: PUSH
49193: LD_OWVAR 2
49197: PUSH
49198: EMPTY
49199: LIST
49200: LIST
49201: PUSH
49202: LD_INT 33
49204: PUSH
49205: LD_INT 3
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: EMPTY
49213: LIST
49214: LIST
49215: PPUSH
49216: CALL_OW 69
49220: ST_TO_ADDR
// if not tmp then
49221: LD_VAR 0 2
49225: NOT
49226: IFFALSE 49230
// exit ;
49228: GO 49356
// side := 0 ;
49230: LD_ADDR_VAR 0 3
49234: PUSH
49235: LD_INT 0
49237: ST_TO_ADDR
// for i := 1 to 8 do
49238: LD_ADDR_VAR 0 1
49242: PUSH
49243: DOUBLE
49244: LD_INT 1
49246: DEC
49247: ST_TO_ADDR
49248: LD_INT 8
49250: PUSH
49251: FOR_TO
49252: IFFALSE 49300
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49254: LD_OWVAR 2
49258: PUSH
49259: LD_VAR 0 1
49263: NONEQUAL
49264: PUSH
49265: LD_OWVAR 2
49269: PPUSH
49270: LD_VAR 0 1
49274: PPUSH
49275: CALL_OW 81
49279: PUSH
49280: LD_INT 2
49282: EQUAL
49283: AND
49284: IFFALSE 49298
// begin side := i ;
49286: LD_ADDR_VAR 0 3
49290: PUSH
49291: LD_VAR 0 1
49295: ST_TO_ADDR
// break ;
49296: GO 49300
// end ;
49298: GO 49251
49300: POP
49301: POP
// if not side then
49302: LD_VAR 0 3
49306: NOT
49307: IFFALSE 49311
// exit ;
49309: GO 49356
// for i := 1 to tmp do
49311: LD_ADDR_VAR 0 1
49315: PUSH
49316: DOUBLE
49317: LD_INT 1
49319: DEC
49320: ST_TO_ADDR
49321: LD_VAR 0 2
49325: PUSH
49326: FOR_TO
49327: IFFALSE 49354
// if Prob ( 60 ) then
49329: LD_INT 60
49331: PPUSH
49332: CALL_OW 13
49336: IFFALSE 49352
// SetSide ( i , side ) ;
49338: LD_VAR 0 1
49342: PPUSH
49343: LD_VAR 0 3
49347: PPUSH
49348: CALL_OW 235
49352: GO 49326
49354: POP
49355: POP
// end ;
49356: PPOPN 3
49358: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49359: LD_EXP 91
49363: PUSH
49364: LD_EXP 104
49368: AND
49369: IFFALSE 49488
49371: GO 49373
49373: DISABLE
49374: LD_INT 0
49376: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49377: LD_ADDR_VAR 0 1
49381: PUSH
49382: LD_INT 22
49384: PUSH
49385: LD_OWVAR 2
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 21
49396: PUSH
49397: LD_INT 1
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: PUSH
49404: LD_INT 3
49406: PUSH
49407: LD_INT 23
49409: PUSH
49410: LD_INT 0
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PUSH
49421: EMPTY
49422: LIST
49423: LIST
49424: LIST
49425: PPUSH
49426: CALL_OW 69
49430: PUSH
49431: FOR_IN
49432: IFFALSE 49486
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49434: LD_VAR 0 1
49438: PPUSH
49439: CALL_OW 257
49443: PUSH
49444: LD_INT 1
49446: PUSH
49447: LD_INT 2
49449: PUSH
49450: LD_INT 3
49452: PUSH
49453: LD_INT 4
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: IN
49462: IFFALSE 49484
// SetClass ( un , rand ( 1 , 4 ) ) ;
49464: LD_VAR 0 1
49468: PPUSH
49469: LD_INT 1
49471: PPUSH
49472: LD_INT 4
49474: PPUSH
49475: CALL_OW 12
49479: PPUSH
49480: CALL_OW 336
49484: GO 49431
49486: POP
49487: POP
// end ;
49488: PPOPN 1
49490: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49491: LD_EXP 91
49495: PUSH
49496: LD_EXP 103
49500: AND
49501: IFFALSE 49580
49503: GO 49505
49505: DISABLE
49506: LD_INT 0
49508: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49509: LD_ADDR_VAR 0 1
49513: PUSH
49514: LD_INT 22
49516: PUSH
49517: LD_OWVAR 2
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 21
49528: PUSH
49529: LD_INT 3
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: PUSH
49536: EMPTY
49537: LIST
49538: LIST
49539: PPUSH
49540: CALL_OW 69
49544: ST_TO_ADDR
// if not tmp then
49545: LD_VAR 0 1
49549: NOT
49550: IFFALSE 49554
// exit ;
49552: GO 49580
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49554: LD_VAR 0 1
49558: PUSH
49559: LD_INT 1
49561: PPUSH
49562: LD_VAR 0 1
49566: PPUSH
49567: CALL_OW 12
49571: ARRAY
49572: PPUSH
49573: LD_INT 100
49575: PPUSH
49576: CALL_OW 234
// end ;
49580: PPOPN 1
49582: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49583: LD_EXP 91
49587: PUSH
49588: LD_EXP 105
49592: AND
49593: IFFALSE 49691
49595: GO 49597
49597: DISABLE
49598: LD_INT 0
49600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49601: LD_ADDR_VAR 0 1
49605: PUSH
49606: LD_INT 22
49608: PUSH
49609: LD_OWVAR 2
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: PUSH
49618: LD_INT 21
49620: PUSH
49621: LD_INT 1
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: PUSH
49628: EMPTY
49629: LIST
49630: LIST
49631: PPUSH
49632: CALL_OW 69
49636: ST_TO_ADDR
// if not tmp then
49637: LD_VAR 0 1
49641: NOT
49642: IFFALSE 49646
// exit ;
49644: GO 49691
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49646: LD_VAR 0 1
49650: PUSH
49651: LD_INT 1
49653: PPUSH
49654: LD_VAR 0 1
49658: PPUSH
49659: CALL_OW 12
49663: ARRAY
49664: PPUSH
49665: LD_INT 1
49667: PPUSH
49668: LD_INT 4
49670: PPUSH
49671: CALL_OW 12
49675: PPUSH
49676: LD_INT 3000
49678: PPUSH
49679: LD_INT 9000
49681: PPUSH
49682: CALL_OW 12
49686: PPUSH
49687: CALL_OW 492
// end ;
49691: PPOPN 1
49693: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49694: LD_EXP 91
49698: PUSH
49699: LD_EXP 106
49703: AND
49704: IFFALSE 49724
49706: GO 49708
49708: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49709: LD_INT 1
49711: PPUSH
49712: LD_OWVAR 2
49716: PPUSH
49717: LD_INT 0
49719: PPUSH
49720: CALL_OW 324
49724: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49725: LD_EXP 91
49729: PUSH
49730: LD_EXP 107
49734: AND
49735: IFFALSE 49818
49737: GO 49739
49739: DISABLE
49740: LD_INT 0
49742: PPUSH
49743: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49744: LD_ADDR_VAR 0 2
49748: PUSH
49749: LD_INT 22
49751: PUSH
49752: LD_OWVAR 2
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 21
49763: PUSH
49764: LD_INT 3
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PPUSH
49775: CALL_OW 69
49779: ST_TO_ADDR
// if not tmp then
49780: LD_VAR 0 2
49784: NOT
49785: IFFALSE 49789
// exit ;
49787: GO 49818
// for i in tmp do
49789: LD_ADDR_VAR 0 1
49793: PUSH
49794: LD_VAR 0 2
49798: PUSH
49799: FOR_IN
49800: IFFALSE 49816
// SetBLevel ( i , 10 ) ;
49802: LD_VAR 0 1
49806: PPUSH
49807: LD_INT 10
49809: PPUSH
49810: CALL_OW 241
49814: GO 49799
49816: POP
49817: POP
// end ;
49818: PPOPN 2
49820: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49821: LD_EXP 91
49825: PUSH
49826: LD_EXP 108
49830: AND
49831: IFFALSE 49942
49833: GO 49835
49835: DISABLE
49836: LD_INT 0
49838: PPUSH
49839: PPUSH
49840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49841: LD_ADDR_VAR 0 3
49845: PUSH
49846: LD_INT 22
49848: PUSH
49849: LD_OWVAR 2
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: PUSH
49858: LD_INT 25
49860: PUSH
49861: LD_INT 1
49863: PUSH
49864: EMPTY
49865: LIST
49866: LIST
49867: PUSH
49868: EMPTY
49869: LIST
49870: LIST
49871: PPUSH
49872: CALL_OW 69
49876: ST_TO_ADDR
// if not tmp then
49877: LD_VAR 0 3
49881: NOT
49882: IFFALSE 49886
// exit ;
49884: GO 49942
// un := tmp [ rand ( 1 , tmp ) ] ;
49886: LD_ADDR_VAR 0 2
49890: PUSH
49891: LD_VAR 0 3
49895: PUSH
49896: LD_INT 1
49898: PPUSH
49899: LD_VAR 0 3
49903: PPUSH
49904: CALL_OW 12
49908: ARRAY
49909: ST_TO_ADDR
// if Crawls ( un ) then
49910: LD_VAR 0 2
49914: PPUSH
49915: CALL_OW 318
49919: IFFALSE 49930
// ComWalk ( un ) ;
49921: LD_VAR 0 2
49925: PPUSH
49926: CALL_OW 138
// SetClass ( un , class_sniper ) ;
49930: LD_VAR 0 2
49934: PPUSH
49935: LD_INT 5
49937: PPUSH
49938: CALL_OW 336
// end ;
49942: PPOPN 3
49944: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
49945: LD_EXP 91
49949: PUSH
49950: LD_EXP 109
49954: AND
49955: PUSH
49956: LD_OWVAR 67
49960: PUSH
49961: LD_INT 3
49963: LESS
49964: AND
49965: IFFALSE 49984
49967: GO 49969
49969: DISABLE
// Difficulty := Difficulty + 1 ;
49970: LD_ADDR_OWVAR 67
49974: PUSH
49975: LD_OWVAR 67
49979: PUSH
49980: LD_INT 1
49982: PLUS
49983: ST_TO_ADDR
49984: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
49985: LD_EXP 91
49989: PUSH
49990: LD_EXP 110
49994: AND
49995: IFFALSE 50098
49997: GO 49999
49999: DISABLE
50000: LD_INT 0
50002: PPUSH
// begin for i := 1 to 5 do
50003: LD_ADDR_VAR 0 1
50007: PUSH
50008: DOUBLE
50009: LD_INT 1
50011: DEC
50012: ST_TO_ADDR
50013: LD_INT 5
50015: PUSH
50016: FOR_TO
50017: IFFALSE 50096
// begin uc_nation := nation_nature ;
50019: LD_ADDR_OWVAR 21
50023: PUSH
50024: LD_INT 0
50026: ST_TO_ADDR
// uc_side := 0 ;
50027: LD_ADDR_OWVAR 20
50031: PUSH
50032: LD_INT 0
50034: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50035: LD_ADDR_OWVAR 29
50039: PUSH
50040: LD_INT 12
50042: PUSH
50043: LD_INT 12
50045: PUSH
50046: EMPTY
50047: LIST
50048: LIST
50049: ST_TO_ADDR
// hc_agressivity := 20 ;
50050: LD_ADDR_OWVAR 35
50054: PUSH
50055: LD_INT 20
50057: ST_TO_ADDR
// hc_class := class_tiger ;
50058: LD_ADDR_OWVAR 28
50062: PUSH
50063: LD_INT 14
50065: ST_TO_ADDR
// hc_gallery :=  ;
50066: LD_ADDR_OWVAR 33
50070: PUSH
50071: LD_STRING 
50073: ST_TO_ADDR
// hc_name :=  ;
50074: LD_ADDR_OWVAR 26
50078: PUSH
50079: LD_STRING 
50081: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50082: CALL_OW 44
50086: PPUSH
50087: LD_INT 0
50089: PPUSH
50090: CALL_OW 51
// end ;
50094: GO 50016
50096: POP
50097: POP
// end ;
50098: PPOPN 1
50100: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50101: LD_EXP 91
50105: PUSH
50106: LD_EXP 111
50110: AND
50111: IFFALSE 50120
50113: GO 50115
50115: DISABLE
// StreamSibBomb ;
50116: CALL 50121 0 0
50120: END
// export function StreamSibBomb ; var i , x , y ; begin
50121: LD_INT 0
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
// result := false ;
50127: LD_ADDR_VAR 0 1
50131: PUSH
50132: LD_INT 0
50134: ST_TO_ADDR
// for i := 1 to 16 do
50135: LD_ADDR_VAR 0 2
50139: PUSH
50140: DOUBLE
50141: LD_INT 1
50143: DEC
50144: ST_TO_ADDR
50145: LD_INT 16
50147: PUSH
50148: FOR_TO
50149: IFFALSE 50348
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50151: LD_ADDR_VAR 0 3
50155: PUSH
50156: LD_INT 10
50158: PUSH
50159: LD_INT 20
50161: PUSH
50162: LD_INT 30
50164: PUSH
50165: LD_INT 40
50167: PUSH
50168: LD_INT 50
50170: PUSH
50171: LD_INT 60
50173: PUSH
50174: LD_INT 70
50176: PUSH
50177: LD_INT 80
50179: PUSH
50180: LD_INT 90
50182: PUSH
50183: LD_INT 100
50185: PUSH
50186: LD_INT 110
50188: PUSH
50189: LD_INT 120
50191: PUSH
50192: LD_INT 130
50194: PUSH
50195: LD_INT 140
50197: PUSH
50198: LD_INT 150
50200: PUSH
50201: EMPTY
50202: LIST
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: LIST
50211: LIST
50212: LIST
50213: LIST
50214: LIST
50215: LIST
50216: LIST
50217: PUSH
50218: LD_INT 1
50220: PPUSH
50221: LD_INT 15
50223: PPUSH
50224: CALL_OW 12
50228: ARRAY
50229: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50230: LD_ADDR_VAR 0 4
50234: PUSH
50235: LD_INT 10
50237: PUSH
50238: LD_INT 20
50240: PUSH
50241: LD_INT 30
50243: PUSH
50244: LD_INT 40
50246: PUSH
50247: LD_INT 50
50249: PUSH
50250: LD_INT 60
50252: PUSH
50253: LD_INT 70
50255: PUSH
50256: LD_INT 80
50258: PUSH
50259: LD_INT 90
50261: PUSH
50262: LD_INT 100
50264: PUSH
50265: LD_INT 110
50267: PUSH
50268: LD_INT 120
50270: PUSH
50271: LD_INT 130
50273: PUSH
50274: LD_INT 140
50276: PUSH
50277: LD_INT 150
50279: PUSH
50280: EMPTY
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: PUSH
50297: LD_INT 1
50299: PPUSH
50300: LD_INT 15
50302: PPUSH
50303: CALL_OW 12
50307: ARRAY
50308: ST_TO_ADDR
// if ValidHex ( x , y ) then
50309: LD_VAR 0 3
50313: PPUSH
50314: LD_VAR 0 4
50318: PPUSH
50319: CALL_OW 488
50323: IFFALSE 50346
// begin result := [ x , y ] ;
50325: LD_ADDR_VAR 0 1
50329: PUSH
50330: LD_VAR 0 3
50334: PUSH
50335: LD_VAR 0 4
50339: PUSH
50340: EMPTY
50341: LIST
50342: LIST
50343: ST_TO_ADDR
// break ;
50344: GO 50348
// end ; end ;
50346: GO 50148
50348: POP
50349: POP
// if result then
50350: LD_VAR 0 1
50354: IFFALSE 50414
// begin ToLua ( playSibBomb() ) ;
50356: LD_STRING playSibBomb()
50358: PPUSH
50359: CALL_OW 559
// wait ( 0 0$14 ) ;
50363: LD_INT 490
50365: PPUSH
50366: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50370: LD_VAR 0 1
50374: PUSH
50375: LD_INT 1
50377: ARRAY
50378: PPUSH
50379: LD_VAR 0 1
50383: PUSH
50384: LD_INT 2
50386: ARRAY
50387: PPUSH
50388: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50392: LD_VAR 0 1
50396: PUSH
50397: LD_INT 1
50399: ARRAY
50400: PPUSH
50401: LD_VAR 0 1
50405: PUSH
50406: LD_INT 2
50408: ARRAY
50409: PPUSH
50410: CALL_OW 429
// end ; end ;
50414: LD_VAR 0 1
50418: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50419: LD_EXP 91
50423: PUSH
50424: LD_EXP 113
50428: AND
50429: IFFALSE 50441
50431: GO 50433
50433: DISABLE
// YouLost (  ) ;
50434: LD_STRING 
50436: PPUSH
50437: CALL_OW 104
50441: END
// every 0 0$1 trigger StreamModeActive and sFog do
50442: LD_EXP 91
50446: PUSH
50447: LD_EXP 112
50451: AND
50452: IFFALSE 50466
50454: GO 50456
50456: DISABLE
// FogOff ( your_side ) ;
50457: LD_OWVAR 2
50461: PPUSH
50462: CALL_OW 344
50466: END
// every 0 0$1 trigger StreamModeActive and sSun do
50467: LD_EXP 91
50471: PUSH
50472: LD_EXP 114
50476: AND
50477: IFFALSE 50505
50479: GO 50481
50481: DISABLE
// begin solar_recharge_percent := 0 ;
50482: LD_ADDR_OWVAR 79
50486: PUSH
50487: LD_INT 0
50489: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50490: LD_INT 10500
50492: PPUSH
50493: CALL_OW 67
// solar_recharge_percent := 100 ;
50497: LD_ADDR_OWVAR 79
50501: PUSH
50502: LD_INT 100
50504: ST_TO_ADDR
// end ;
50505: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50506: LD_EXP 91
50510: PUSH
50511: LD_EXP 115
50515: AND
50516: IFFALSE 50755
50518: GO 50520
50520: DISABLE
50521: LD_INT 0
50523: PPUSH
50524: PPUSH
50525: PPUSH
// begin tmp := [ ] ;
50526: LD_ADDR_VAR 0 3
50530: PUSH
50531: EMPTY
50532: ST_TO_ADDR
// for i := 1 to 6 do
50533: LD_ADDR_VAR 0 1
50537: PUSH
50538: DOUBLE
50539: LD_INT 1
50541: DEC
50542: ST_TO_ADDR
50543: LD_INT 6
50545: PUSH
50546: FOR_TO
50547: IFFALSE 50652
// begin uc_nation := nation_nature ;
50549: LD_ADDR_OWVAR 21
50553: PUSH
50554: LD_INT 0
50556: ST_TO_ADDR
// uc_side := 0 ;
50557: LD_ADDR_OWVAR 20
50561: PUSH
50562: LD_INT 0
50564: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50565: LD_ADDR_OWVAR 29
50569: PUSH
50570: LD_INT 12
50572: PUSH
50573: LD_INT 12
50575: PUSH
50576: EMPTY
50577: LIST
50578: LIST
50579: ST_TO_ADDR
// hc_agressivity := 20 ;
50580: LD_ADDR_OWVAR 35
50584: PUSH
50585: LD_INT 20
50587: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50588: LD_ADDR_OWVAR 28
50592: PUSH
50593: LD_INT 17
50595: ST_TO_ADDR
// hc_gallery :=  ;
50596: LD_ADDR_OWVAR 33
50600: PUSH
50601: LD_STRING 
50603: ST_TO_ADDR
// hc_name :=  ;
50604: LD_ADDR_OWVAR 26
50608: PUSH
50609: LD_STRING 
50611: ST_TO_ADDR
// un := CreateHuman ;
50612: LD_ADDR_VAR 0 2
50616: PUSH
50617: CALL_OW 44
50621: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50622: LD_VAR 0 2
50626: PPUSH
50627: LD_INT 1
50629: PPUSH
50630: CALL_OW 51
// tmp := tmp ^ un ;
50634: LD_ADDR_VAR 0 3
50638: PUSH
50639: LD_VAR 0 3
50643: PUSH
50644: LD_VAR 0 2
50648: ADD
50649: ST_TO_ADDR
// end ;
50650: GO 50546
50652: POP
50653: POP
// repeat wait ( 0 0$1 ) ;
50654: LD_INT 35
50656: PPUSH
50657: CALL_OW 67
// for un in tmp do
50661: LD_ADDR_VAR 0 2
50665: PUSH
50666: LD_VAR 0 3
50670: PUSH
50671: FOR_IN
50672: IFFALSE 50746
// begin if IsDead ( un ) then
50674: LD_VAR 0 2
50678: PPUSH
50679: CALL_OW 301
50683: IFFALSE 50703
// begin tmp := tmp diff un ;
50685: LD_ADDR_VAR 0 3
50689: PUSH
50690: LD_VAR 0 3
50694: PUSH
50695: LD_VAR 0 2
50699: DIFF
50700: ST_TO_ADDR
// continue ;
50701: GO 50671
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50703: LD_VAR 0 2
50707: PPUSH
50708: LD_INT 3
50710: PUSH
50711: LD_INT 22
50713: PUSH
50714: LD_INT 0
50716: PUSH
50717: EMPTY
50718: LIST
50719: LIST
50720: PUSH
50721: EMPTY
50722: LIST
50723: LIST
50724: PPUSH
50725: CALL_OW 69
50729: PPUSH
50730: LD_VAR 0 2
50734: PPUSH
50735: CALL_OW 74
50739: PPUSH
50740: CALL_OW 115
// end ;
50744: GO 50671
50746: POP
50747: POP
// until not tmp ;
50748: LD_VAR 0 3
50752: NOT
50753: IFFALSE 50654
// end ;
50755: PPOPN 3
50757: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50758: LD_EXP 91
50762: PUSH
50763: LD_EXP 116
50767: AND
50768: IFFALSE 50822
50770: GO 50772
50772: DISABLE
// begin ToLua ( displayTroll(); ) ;
50773: LD_STRING displayTroll();
50775: PPUSH
50776: CALL_OW 559
// wait ( 3 3$00 ) ;
50780: LD_INT 6300
50782: PPUSH
50783: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50787: LD_STRING hideTroll();
50789: PPUSH
50790: CALL_OW 559
// wait ( 1 1$00 ) ;
50794: LD_INT 2100
50796: PPUSH
50797: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50801: LD_STRING displayTroll();
50803: PPUSH
50804: CALL_OW 559
// wait ( 1 1$00 ) ;
50808: LD_INT 2100
50810: PPUSH
50811: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50815: LD_STRING hideTroll();
50817: PPUSH
50818: CALL_OW 559
// end ;
50822: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50823: LD_EXP 91
50827: PUSH
50828: LD_EXP 117
50832: AND
50833: IFFALSE 50896
50835: GO 50837
50837: DISABLE
50838: LD_INT 0
50840: PPUSH
// begin p := 0 ;
50841: LD_ADDR_VAR 0 1
50845: PUSH
50846: LD_INT 0
50848: ST_TO_ADDR
// repeat game_speed := 1 ;
50849: LD_ADDR_OWVAR 65
50853: PUSH
50854: LD_INT 1
50856: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50857: LD_INT 35
50859: PPUSH
50860: CALL_OW 67
// p := p + 1 ;
50864: LD_ADDR_VAR 0 1
50868: PUSH
50869: LD_VAR 0 1
50873: PUSH
50874: LD_INT 1
50876: PLUS
50877: ST_TO_ADDR
// until p >= 60 ;
50878: LD_VAR 0 1
50882: PUSH
50883: LD_INT 60
50885: GREATEREQUAL
50886: IFFALSE 50849
// game_speed := 4 ;
50888: LD_ADDR_OWVAR 65
50892: PUSH
50893: LD_INT 4
50895: ST_TO_ADDR
// end ;
50896: PPOPN 1
50898: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
50899: LD_EXP 91
50903: PUSH
50904: LD_EXP 118
50908: AND
50909: IFFALSE 51055
50911: GO 50913
50913: DISABLE
50914: LD_INT 0
50916: PPUSH
50917: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
50918: LD_ADDR_VAR 0 1
50922: PUSH
50923: LD_INT 22
50925: PUSH
50926: LD_OWVAR 2
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PUSH
50935: LD_INT 2
50937: PUSH
50938: LD_INT 30
50940: PUSH
50941: LD_INT 0
50943: PUSH
50944: EMPTY
50945: LIST
50946: LIST
50947: PUSH
50948: LD_INT 30
50950: PUSH
50951: LD_INT 1
50953: PUSH
50954: EMPTY
50955: LIST
50956: LIST
50957: PUSH
50958: EMPTY
50959: LIST
50960: LIST
50961: LIST
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: PPUSH
50967: CALL_OW 69
50971: ST_TO_ADDR
// if not depot then
50972: LD_VAR 0 1
50976: NOT
50977: IFFALSE 50981
// exit ;
50979: GO 51055
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
50981: LD_ADDR_VAR 0 2
50985: PUSH
50986: LD_VAR 0 1
50990: PUSH
50991: LD_INT 1
50993: PPUSH
50994: LD_VAR 0 1
50998: PPUSH
50999: CALL_OW 12
51003: ARRAY
51004: PPUSH
51005: CALL_OW 274
51009: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51010: LD_VAR 0 2
51014: PPUSH
51015: LD_INT 1
51017: PPUSH
51018: LD_INT 0
51020: PPUSH
51021: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51025: LD_VAR 0 2
51029: PPUSH
51030: LD_INT 2
51032: PPUSH
51033: LD_INT 0
51035: PPUSH
51036: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51040: LD_VAR 0 2
51044: PPUSH
51045: LD_INT 3
51047: PPUSH
51048: LD_INT 0
51050: PPUSH
51051: CALL_OW 277
// end ;
51055: PPOPN 2
51057: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51058: LD_EXP 91
51062: PUSH
51063: LD_EXP 119
51067: AND
51068: IFFALSE 51165
51070: GO 51072
51072: DISABLE
51073: LD_INT 0
51075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51076: LD_ADDR_VAR 0 1
51080: PUSH
51081: LD_INT 22
51083: PUSH
51084: LD_OWVAR 2
51088: PUSH
51089: EMPTY
51090: LIST
51091: LIST
51092: PUSH
51093: LD_INT 21
51095: PUSH
51096: LD_INT 1
51098: PUSH
51099: EMPTY
51100: LIST
51101: LIST
51102: PUSH
51103: LD_INT 3
51105: PUSH
51106: LD_INT 23
51108: PUSH
51109: LD_INT 0
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PUSH
51120: EMPTY
51121: LIST
51122: LIST
51123: LIST
51124: PPUSH
51125: CALL_OW 69
51129: ST_TO_ADDR
// if not tmp then
51130: LD_VAR 0 1
51134: NOT
51135: IFFALSE 51139
// exit ;
51137: GO 51165
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51139: LD_VAR 0 1
51143: PUSH
51144: LD_INT 1
51146: PPUSH
51147: LD_VAR 0 1
51151: PPUSH
51152: CALL_OW 12
51156: ARRAY
51157: PPUSH
51158: LD_INT 200
51160: PPUSH
51161: CALL_OW 234
// end ;
51165: PPOPN 1
51167: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51168: LD_EXP 91
51172: PUSH
51173: LD_EXP 120
51177: AND
51178: IFFALSE 51257
51180: GO 51182
51182: DISABLE
51183: LD_INT 0
51185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51186: LD_ADDR_VAR 0 1
51190: PUSH
51191: LD_INT 22
51193: PUSH
51194: LD_OWVAR 2
51198: PUSH
51199: EMPTY
51200: LIST
51201: LIST
51202: PUSH
51203: LD_INT 21
51205: PUSH
51206: LD_INT 2
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PUSH
51213: EMPTY
51214: LIST
51215: LIST
51216: PPUSH
51217: CALL_OW 69
51221: ST_TO_ADDR
// if not tmp then
51222: LD_VAR 0 1
51226: NOT
51227: IFFALSE 51231
// exit ;
51229: GO 51257
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51231: LD_VAR 0 1
51235: PUSH
51236: LD_INT 1
51238: PPUSH
51239: LD_VAR 0 1
51243: PPUSH
51244: CALL_OW 12
51248: ARRAY
51249: PPUSH
51250: LD_INT 60
51252: PPUSH
51253: CALL_OW 234
// end ;
51257: PPOPN 1
51259: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51260: LD_EXP 91
51264: PUSH
51265: LD_EXP 121
51269: AND
51270: IFFALSE 51369
51272: GO 51274
51274: DISABLE
51275: LD_INT 0
51277: PPUSH
51278: PPUSH
// begin enable ;
51279: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51280: LD_ADDR_VAR 0 1
51284: PUSH
51285: LD_INT 22
51287: PUSH
51288: LD_OWVAR 2
51292: PUSH
51293: EMPTY
51294: LIST
51295: LIST
51296: PUSH
51297: LD_INT 61
51299: PUSH
51300: EMPTY
51301: LIST
51302: PUSH
51303: LD_INT 33
51305: PUSH
51306: LD_INT 2
51308: PUSH
51309: EMPTY
51310: LIST
51311: LIST
51312: PUSH
51313: EMPTY
51314: LIST
51315: LIST
51316: LIST
51317: PPUSH
51318: CALL_OW 69
51322: ST_TO_ADDR
// if not tmp then
51323: LD_VAR 0 1
51327: NOT
51328: IFFALSE 51332
// exit ;
51330: GO 51369
// for i in tmp do
51332: LD_ADDR_VAR 0 2
51336: PUSH
51337: LD_VAR 0 1
51341: PUSH
51342: FOR_IN
51343: IFFALSE 51367
// if IsControledBy ( i ) then
51345: LD_VAR 0 2
51349: PPUSH
51350: CALL_OW 312
51354: IFFALSE 51365
// ComUnlink ( i ) ;
51356: LD_VAR 0 2
51360: PPUSH
51361: CALL_OW 136
51365: GO 51342
51367: POP
51368: POP
// end ;
51369: PPOPN 2
51371: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51372: LD_EXP 91
51376: PUSH
51377: LD_EXP 122
51381: AND
51382: IFFALSE 51522
51384: GO 51386
51386: DISABLE
51387: LD_INT 0
51389: PPUSH
51390: PPUSH
// begin ToLua ( displayPowell(); ) ;
51391: LD_STRING displayPowell();
51393: PPUSH
51394: CALL_OW 559
// uc_side := 0 ;
51398: LD_ADDR_OWVAR 20
51402: PUSH
51403: LD_INT 0
51405: ST_TO_ADDR
// uc_nation := 2 ;
51406: LD_ADDR_OWVAR 21
51410: PUSH
51411: LD_INT 2
51413: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51414: LD_ADDR_OWVAR 37
51418: PUSH
51419: LD_INT 14
51421: ST_TO_ADDR
// vc_engine := engine_siberite ;
51422: LD_ADDR_OWVAR 39
51426: PUSH
51427: LD_INT 3
51429: ST_TO_ADDR
// vc_control := control_apeman ;
51430: LD_ADDR_OWVAR 38
51434: PUSH
51435: LD_INT 5
51437: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51438: LD_ADDR_OWVAR 40
51442: PUSH
51443: LD_INT 29
51445: ST_TO_ADDR
// un := CreateVehicle ;
51446: LD_ADDR_VAR 0 2
51450: PUSH
51451: CALL_OW 45
51455: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51456: LD_VAR 0 2
51460: PPUSH
51461: LD_INT 1
51463: PPUSH
51464: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51468: LD_INT 35
51470: PPUSH
51471: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51475: LD_VAR 0 2
51479: PPUSH
51480: LD_INT 22
51482: PUSH
51483: LD_OWVAR 2
51487: PUSH
51488: EMPTY
51489: LIST
51490: LIST
51491: PPUSH
51492: CALL_OW 69
51496: PPUSH
51497: LD_VAR 0 2
51501: PPUSH
51502: CALL_OW 74
51506: PPUSH
51507: CALL_OW 115
// until IsDead ( un ) ;
51511: LD_VAR 0 2
51515: PPUSH
51516: CALL_OW 301
51520: IFFALSE 51468
// end ;
51522: PPOPN 2
51524: END
// every 0 0$1 trigger StreamModeActive and sStu do
51525: LD_EXP 91
51529: PUSH
51530: LD_EXP 130
51534: AND
51535: IFFALSE 51551
51537: GO 51539
51539: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51540: LD_STRING displayStucuk();
51542: PPUSH
51543: CALL_OW 559
// ResetFog ;
51547: CALL_OW 335
// end ;
51551: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51552: LD_EXP 91
51556: PUSH
51557: LD_EXP 123
51561: AND
51562: IFFALSE 51703
51564: GO 51566
51566: DISABLE
51567: LD_INT 0
51569: PPUSH
51570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51571: LD_ADDR_VAR 0 2
51575: PUSH
51576: LD_INT 22
51578: PUSH
51579: LD_OWVAR 2
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PUSH
51588: LD_INT 21
51590: PUSH
51591: LD_INT 1
51593: PUSH
51594: EMPTY
51595: LIST
51596: LIST
51597: PUSH
51598: EMPTY
51599: LIST
51600: LIST
51601: PPUSH
51602: CALL_OW 69
51606: ST_TO_ADDR
// if not tmp then
51607: LD_VAR 0 2
51611: NOT
51612: IFFALSE 51616
// exit ;
51614: GO 51703
// un := tmp [ rand ( 1 , tmp ) ] ;
51616: LD_ADDR_VAR 0 1
51620: PUSH
51621: LD_VAR 0 2
51625: PUSH
51626: LD_INT 1
51628: PPUSH
51629: LD_VAR 0 2
51633: PPUSH
51634: CALL_OW 12
51638: ARRAY
51639: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51640: LD_VAR 0 1
51644: PPUSH
51645: LD_INT 0
51647: PPUSH
51648: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51652: LD_VAR 0 1
51656: PPUSH
51657: LD_OWVAR 3
51661: PUSH
51662: LD_VAR 0 1
51666: DIFF
51667: PPUSH
51668: LD_VAR 0 1
51672: PPUSH
51673: CALL_OW 74
51677: PPUSH
51678: CALL_OW 115
// wait ( 0 0$20 ) ;
51682: LD_INT 700
51684: PPUSH
51685: CALL_OW 67
// SetSide ( un , your_side ) ;
51689: LD_VAR 0 1
51693: PPUSH
51694: LD_OWVAR 2
51698: PPUSH
51699: CALL_OW 235
// end ;
51703: PPOPN 2
51705: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51706: LD_EXP 91
51710: PUSH
51711: LD_EXP 124
51715: AND
51716: IFFALSE 51822
51718: GO 51720
51720: DISABLE
51721: LD_INT 0
51723: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51724: LD_ADDR_VAR 0 1
51728: PUSH
51729: LD_INT 22
51731: PUSH
51732: LD_OWVAR 2
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: PUSH
51741: LD_INT 2
51743: PUSH
51744: LD_INT 30
51746: PUSH
51747: LD_INT 0
51749: PUSH
51750: EMPTY
51751: LIST
51752: LIST
51753: PUSH
51754: LD_INT 30
51756: PUSH
51757: LD_INT 1
51759: PUSH
51760: EMPTY
51761: LIST
51762: LIST
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: LIST
51768: PUSH
51769: EMPTY
51770: LIST
51771: LIST
51772: PPUSH
51773: CALL_OW 69
51777: ST_TO_ADDR
// if not depot then
51778: LD_VAR 0 1
51782: NOT
51783: IFFALSE 51787
// exit ;
51785: GO 51822
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51787: LD_VAR 0 1
51791: PUSH
51792: LD_INT 1
51794: ARRAY
51795: PPUSH
51796: CALL_OW 250
51800: PPUSH
51801: LD_VAR 0 1
51805: PUSH
51806: LD_INT 1
51808: ARRAY
51809: PPUSH
51810: CALL_OW 251
51814: PPUSH
51815: LD_INT 70
51817: PPUSH
51818: CALL_OW 495
// end ;
51822: PPOPN 1
51824: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51825: LD_EXP 91
51829: PUSH
51830: LD_EXP 125
51834: AND
51835: IFFALSE 52046
51837: GO 51839
51839: DISABLE
51840: LD_INT 0
51842: PPUSH
51843: PPUSH
51844: PPUSH
51845: PPUSH
51846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51847: LD_ADDR_VAR 0 5
51851: PUSH
51852: LD_INT 22
51854: PUSH
51855: LD_OWVAR 2
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: LD_INT 21
51866: PUSH
51867: LD_INT 1
51869: PUSH
51870: EMPTY
51871: LIST
51872: LIST
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PPUSH
51878: CALL_OW 69
51882: ST_TO_ADDR
// if not tmp then
51883: LD_VAR 0 5
51887: NOT
51888: IFFALSE 51892
// exit ;
51890: GO 52046
// for i in tmp do
51892: LD_ADDR_VAR 0 1
51896: PUSH
51897: LD_VAR 0 5
51901: PUSH
51902: FOR_IN
51903: IFFALSE 52044
// begin d := rand ( 0 , 5 ) ;
51905: LD_ADDR_VAR 0 4
51909: PUSH
51910: LD_INT 0
51912: PPUSH
51913: LD_INT 5
51915: PPUSH
51916: CALL_OW 12
51920: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
51921: LD_ADDR_VAR 0 2
51925: PUSH
51926: LD_VAR 0 1
51930: PPUSH
51931: CALL_OW 250
51935: PPUSH
51936: LD_VAR 0 4
51940: PPUSH
51941: LD_INT 3
51943: PPUSH
51944: LD_INT 12
51946: PPUSH
51947: CALL_OW 12
51951: PPUSH
51952: CALL_OW 272
51956: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
51957: LD_ADDR_VAR 0 3
51961: PUSH
51962: LD_VAR 0 1
51966: PPUSH
51967: CALL_OW 251
51971: PPUSH
51972: LD_VAR 0 4
51976: PPUSH
51977: LD_INT 3
51979: PPUSH
51980: LD_INT 12
51982: PPUSH
51983: CALL_OW 12
51987: PPUSH
51988: CALL_OW 273
51992: ST_TO_ADDR
// if ValidHex ( x , y ) then
51993: LD_VAR 0 2
51997: PPUSH
51998: LD_VAR 0 3
52002: PPUSH
52003: CALL_OW 488
52007: IFFALSE 52042
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52009: LD_VAR 0 1
52013: PPUSH
52014: LD_VAR 0 2
52018: PPUSH
52019: LD_VAR 0 3
52023: PPUSH
52024: LD_INT 3
52026: PPUSH
52027: LD_INT 6
52029: PPUSH
52030: CALL_OW 12
52034: PPUSH
52035: LD_INT 1
52037: PPUSH
52038: CALL_OW 483
// end ;
52042: GO 51902
52044: POP
52045: POP
// end ;
52046: PPOPN 5
52048: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52049: LD_EXP 91
52053: PUSH
52054: LD_EXP 126
52058: AND
52059: IFFALSE 52153
52061: GO 52063
52063: DISABLE
52064: LD_INT 0
52066: PPUSH
52067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52068: LD_ADDR_VAR 0 2
52072: PUSH
52073: LD_INT 22
52075: PUSH
52076: LD_OWVAR 2
52080: PUSH
52081: EMPTY
52082: LIST
52083: LIST
52084: PUSH
52085: LD_INT 32
52087: PUSH
52088: LD_INT 1
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PUSH
52095: LD_INT 21
52097: PUSH
52098: LD_INT 2
52100: PUSH
52101: EMPTY
52102: LIST
52103: LIST
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: LIST
52109: PPUSH
52110: CALL_OW 69
52114: ST_TO_ADDR
// if not tmp then
52115: LD_VAR 0 2
52119: NOT
52120: IFFALSE 52124
// exit ;
52122: GO 52153
// for i in tmp do
52124: LD_ADDR_VAR 0 1
52128: PUSH
52129: LD_VAR 0 2
52133: PUSH
52134: FOR_IN
52135: IFFALSE 52151
// SetFuel ( i , 0 ) ;
52137: LD_VAR 0 1
52141: PPUSH
52142: LD_INT 0
52144: PPUSH
52145: CALL_OW 240
52149: GO 52134
52151: POP
52152: POP
// end ;
52153: PPOPN 2
52155: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52156: LD_EXP 91
52160: PUSH
52161: LD_EXP 127
52165: AND
52166: IFFALSE 52232
52168: GO 52170
52170: DISABLE
52171: LD_INT 0
52173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52174: LD_ADDR_VAR 0 1
52178: PUSH
52179: LD_INT 22
52181: PUSH
52182: LD_OWVAR 2
52186: PUSH
52187: EMPTY
52188: LIST
52189: LIST
52190: PUSH
52191: LD_INT 30
52193: PUSH
52194: LD_INT 29
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: PUSH
52201: EMPTY
52202: LIST
52203: LIST
52204: PPUSH
52205: CALL_OW 69
52209: ST_TO_ADDR
// if not tmp then
52210: LD_VAR 0 1
52214: NOT
52215: IFFALSE 52219
// exit ;
52217: GO 52232
// DestroyUnit ( tmp [ 1 ] ) ;
52219: LD_VAR 0 1
52223: PUSH
52224: LD_INT 1
52226: ARRAY
52227: PPUSH
52228: CALL_OW 65
// end ;
52232: PPOPN 1
52234: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52235: LD_EXP 91
52239: PUSH
52240: LD_EXP 129
52244: AND
52245: IFFALSE 52374
52247: GO 52249
52249: DISABLE
52250: LD_INT 0
52252: PPUSH
// begin uc_side := 0 ;
52253: LD_ADDR_OWVAR 20
52257: PUSH
52258: LD_INT 0
52260: ST_TO_ADDR
// uc_nation := nation_arabian ;
52261: LD_ADDR_OWVAR 21
52265: PUSH
52266: LD_INT 2
52268: ST_TO_ADDR
// hc_gallery :=  ;
52269: LD_ADDR_OWVAR 33
52273: PUSH
52274: LD_STRING 
52276: ST_TO_ADDR
// hc_name :=  ;
52277: LD_ADDR_OWVAR 26
52281: PUSH
52282: LD_STRING 
52284: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52285: LD_INT 1
52287: PPUSH
52288: LD_INT 11
52290: PPUSH
52291: LD_INT 10
52293: PPUSH
52294: CALL_OW 380
// un := CreateHuman ;
52298: LD_ADDR_VAR 0 1
52302: PUSH
52303: CALL_OW 44
52307: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52308: LD_VAR 0 1
52312: PPUSH
52313: LD_INT 1
52315: PPUSH
52316: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52320: LD_INT 35
52322: PPUSH
52323: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52327: LD_VAR 0 1
52331: PPUSH
52332: LD_INT 22
52334: PUSH
52335: LD_OWVAR 2
52339: PUSH
52340: EMPTY
52341: LIST
52342: LIST
52343: PPUSH
52344: CALL_OW 69
52348: PPUSH
52349: LD_VAR 0 1
52353: PPUSH
52354: CALL_OW 74
52358: PPUSH
52359: CALL_OW 115
// until IsDead ( un ) ;
52363: LD_VAR 0 1
52367: PPUSH
52368: CALL_OW 301
52372: IFFALSE 52320
// end ;
52374: PPOPN 1
52376: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52377: LD_EXP 91
52381: PUSH
52382: LD_EXP 131
52386: AND
52387: IFFALSE 52399
52389: GO 52391
52391: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52392: LD_STRING earthquake(getX(game), 0, 32)
52394: PPUSH
52395: CALL_OW 559
52399: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52400: LD_EXP 91
52404: PUSH
52405: LD_EXP 132
52409: AND
52410: IFFALSE 52501
52412: GO 52414
52414: DISABLE
52415: LD_INT 0
52417: PPUSH
// begin enable ;
52418: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52419: LD_ADDR_VAR 0 1
52423: PUSH
52424: LD_INT 22
52426: PUSH
52427: LD_OWVAR 2
52431: PUSH
52432: EMPTY
52433: LIST
52434: LIST
52435: PUSH
52436: LD_INT 21
52438: PUSH
52439: LD_INT 2
52441: PUSH
52442: EMPTY
52443: LIST
52444: LIST
52445: PUSH
52446: LD_INT 33
52448: PUSH
52449: LD_INT 3
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: PUSH
52456: EMPTY
52457: LIST
52458: LIST
52459: LIST
52460: PPUSH
52461: CALL_OW 69
52465: ST_TO_ADDR
// if not tmp then
52466: LD_VAR 0 1
52470: NOT
52471: IFFALSE 52475
// exit ;
52473: GO 52501
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52475: LD_VAR 0 1
52479: PUSH
52480: LD_INT 1
52482: PPUSH
52483: LD_VAR 0 1
52487: PPUSH
52488: CALL_OW 12
52492: ARRAY
52493: PPUSH
52494: LD_INT 1
52496: PPUSH
52497: CALL_OW 234
// end ;
52501: PPOPN 1
52503: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52504: LD_EXP 91
52508: PUSH
52509: LD_EXP 133
52513: AND
52514: IFFALSE 52655
52516: GO 52518
52518: DISABLE
52519: LD_INT 0
52521: PPUSH
52522: PPUSH
52523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52524: LD_ADDR_VAR 0 3
52528: PUSH
52529: LD_INT 22
52531: PUSH
52532: LD_OWVAR 2
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: PUSH
52541: LD_INT 25
52543: PUSH
52544: LD_INT 1
52546: PUSH
52547: EMPTY
52548: LIST
52549: LIST
52550: PUSH
52551: EMPTY
52552: LIST
52553: LIST
52554: PPUSH
52555: CALL_OW 69
52559: ST_TO_ADDR
// if not tmp then
52560: LD_VAR 0 3
52564: NOT
52565: IFFALSE 52569
// exit ;
52567: GO 52655
// un := tmp [ rand ( 1 , tmp ) ] ;
52569: LD_ADDR_VAR 0 2
52573: PUSH
52574: LD_VAR 0 3
52578: PUSH
52579: LD_INT 1
52581: PPUSH
52582: LD_VAR 0 3
52586: PPUSH
52587: CALL_OW 12
52591: ARRAY
52592: ST_TO_ADDR
// if Crawls ( un ) then
52593: LD_VAR 0 2
52597: PPUSH
52598: CALL_OW 318
52602: IFFALSE 52613
// ComWalk ( un ) ;
52604: LD_VAR 0 2
52608: PPUSH
52609: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52613: LD_VAR 0 2
52617: PPUSH
52618: LD_INT 9
52620: PPUSH
52621: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52625: LD_INT 28
52627: PPUSH
52628: LD_OWVAR 2
52632: PPUSH
52633: LD_INT 2
52635: PPUSH
52636: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52640: LD_INT 29
52642: PPUSH
52643: LD_OWVAR 2
52647: PPUSH
52648: LD_INT 2
52650: PPUSH
52651: CALL_OW 322
// end ;
52655: PPOPN 3
52657: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52658: LD_EXP 91
52662: PUSH
52663: LD_EXP 134
52667: AND
52668: IFFALSE 52779
52670: GO 52672
52672: DISABLE
52673: LD_INT 0
52675: PPUSH
52676: PPUSH
52677: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52678: LD_ADDR_VAR 0 3
52682: PUSH
52683: LD_INT 22
52685: PUSH
52686: LD_OWVAR 2
52690: PUSH
52691: EMPTY
52692: LIST
52693: LIST
52694: PUSH
52695: LD_INT 25
52697: PUSH
52698: LD_INT 1
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: PUSH
52705: EMPTY
52706: LIST
52707: LIST
52708: PPUSH
52709: CALL_OW 69
52713: ST_TO_ADDR
// if not tmp then
52714: LD_VAR 0 3
52718: NOT
52719: IFFALSE 52723
// exit ;
52721: GO 52779
// un := tmp [ rand ( 1 , tmp ) ] ;
52723: LD_ADDR_VAR 0 2
52727: PUSH
52728: LD_VAR 0 3
52732: PUSH
52733: LD_INT 1
52735: PPUSH
52736: LD_VAR 0 3
52740: PPUSH
52741: CALL_OW 12
52745: ARRAY
52746: ST_TO_ADDR
// if Crawls ( un ) then
52747: LD_VAR 0 2
52751: PPUSH
52752: CALL_OW 318
52756: IFFALSE 52767
// ComWalk ( un ) ;
52758: LD_VAR 0 2
52762: PPUSH
52763: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52767: LD_VAR 0 2
52771: PPUSH
52772: LD_INT 8
52774: PPUSH
52775: CALL_OW 336
// end ;
52779: PPOPN 3
52781: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52782: LD_EXP 91
52786: PUSH
52787: LD_EXP 135
52791: AND
52792: IFFALSE 52936
52794: GO 52796
52796: DISABLE
52797: LD_INT 0
52799: PPUSH
52800: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52801: LD_ADDR_VAR 0 2
52805: PUSH
52806: LD_INT 22
52808: PUSH
52809: LD_OWVAR 2
52813: PUSH
52814: EMPTY
52815: LIST
52816: LIST
52817: PUSH
52818: LD_INT 21
52820: PUSH
52821: LD_INT 2
52823: PUSH
52824: EMPTY
52825: LIST
52826: LIST
52827: PUSH
52828: LD_INT 2
52830: PUSH
52831: LD_INT 34
52833: PUSH
52834: LD_INT 12
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: PUSH
52841: LD_INT 34
52843: PUSH
52844: LD_INT 51
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PUSH
52851: LD_INT 34
52853: PUSH
52854: LD_INT 32
52856: PUSH
52857: EMPTY
52858: LIST
52859: LIST
52860: PUSH
52861: EMPTY
52862: LIST
52863: LIST
52864: LIST
52865: LIST
52866: PUSH
52867: EMPTY
52868: LIST
52869: LIST
52870: LIST
52871: PPUSH
52872: CALL_OW 69
52876: ST_TO_ADDR
// if not tmp then
52877: LD_VAR 0 2
52881: NOT
52882: IFFALSE 52886
// exit ;
52884: GO 52936
// for i in tmp do
52886: LD_ADDR_VAR 0 1
52890: PUSH
52891: LD_VAR 0 2
52895: PUSH
52896: FOR_IN
52897: IFFALSE 52934
// if GetCargo ( i , mat_artifact ) = 0 then
52899: LD_VAR 0 1
52903: PPUSH
52904: LD_INT 4
52906: PPUSH
52907: CALL_OW 289
52911: PUSH
52912: LD_INT 0
52914: EQUAL
52915: IFFALSE 52932
// SetCargo ( i , mat_siberit , 100 ) ;
52917: LD_VAR 0 1
52921: PPUSH
52922: LD_INT 3
52924: PPUSH
52925: LD_INT 100
52927: PPUSH
52928: CALL_OW 290
52932: GO 52896
52934: POP
52935: POP
// end ;
52936: PPOPN 2
52938: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
52939: LD_EXP 91
52943: PUSH
52944: LD_EXP 136
52948: AND
52949: IFFALSE 53132
52951: GO 52953
52953: DISABLE
52954: LD_INT 0
52956: PPUSH
52957: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
52958: LD_ADDR_VAR 0 2
52962: PUSH
52963: LD_INT 22
52965: PUSH
52966: LD_OWVAR 2
52970: PUSH
52971: EMPTY
52972: LIST
52973: LIST
52974: PPUSH
52975: CALL_OW 69
52979: ST_TO_ADDR
// if not tmp then
52980: LD_VAR 0 2
52984: NOT
52985: IFFALSE 52989
// exit ;
52987: GO 53132
// for i := 1 to 2 do
52989: LD_ADDR_VAR 0 1
52993: PUSH
52994: DOUBLE
52995: LD_INT 1
52997: DEC
52998: ST_TO_ADDR
52999: LD_INT 2
53001: PUSH
53002: FOR_TO
53003: IFFALSE 53130
// begin uc_side := your_side ;
53005: LD_ADDR_OWVAR 20
53009: PUSH
53010: LD_OWVAR 2
53014: ST_TO_ADDR
// uc_nation := nation_american ;
53015: LD_ADDR_OWVAR 21
53019: PUSH
53020: LD_INT 1
53022: ST_TO_ADDR
// vc_chassis := us_morphling ;
53023: LD_ADDR_OWVAR 37
53027: PUSH
53028: LD_INT 5
53030: ST_TO_ADDR
// vc_engine := engine_siberite ;
53031: LD_ADDR_OWVAR 39
53035: PUSH
53036: LD_INT 3
53038: ST_TO_ADDR
// vc_control := control_computer ;
53039: LD_ADDR_OWVAR 38
53043: PUSH
53044: LD_INT 3
53046: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53047: LD_ADDR_OWVAR 40
53051: PUSH
53052: LD_INT 10
53054: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53055: LD_VAR 0 2
53059: PUSH
53060: LD_INT 1
53062: ARRAY
53063: PPUSH
53064: CALL_OW 310
53068: NOT
53069: IFFALSE 53116
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53071: CALL_OW 45
53075: PPUSH
53076: LD_VAR 0 2
53080: PUSH
53081: LD_INT 1
53083: ARRAY
53084: PPUSH
53085: CALL_OW 250
53089: PPUSH
53090: LD_VAR 0 2
53094: PUSH
53095: LD_INT 1
53097: ARRAY
53098: PPUSH
53099: CALL_OW 251
53103: PPUSH
53104: LD_INT 12
53106: PPUSH
53107: LD_INT 1
53109: PPUSH
53110: CALL_OW 50
53114: GO 53128
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53116: CALL_OW 45
53120: PPUSH
53121: LD_INT 1
53123: PPUSH
53124: CALL_OW 51
// end ;
53128: GO 53002
53130: POP
53131: POP
// end ;
53132: PPOPN 2
53134: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53135: LD_EXP 91
53139: PUSH
53140: LD_EXP 137
53144: AND
53145: IFFALSE 53367
53147: GO 53149
53149: DISABLE
53150: LD_INT 0
53152: PPUSH
53153: PPUSH
53154: PPUSH
53155: PPUSH
53156: PPUSH
53157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53158: LD_ADDR_VAR 0 6
53162: PUSH
53163: LD_INT 22
53165: PUSH
53166: LD_OWVAR 2
53170: PUSH
53171: EMPTY
53172: LIST
53173: LIST
53174: PUSH
53175: LD_INT 21
53177: PUSH
53178: LD_INT 1
53180: PUSH
53181: EMPTY
53182: LIST
53183: LIST
53184: PUSH
53185: LD_INT 3
53187: PUSH
53188: LD_INT 23
53190: PUSH
53191: LD_INT 0
53193: PUSH
53194: EMPTY
53195: LIST
53196: LIST
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: EMPTY
53203: LIST
53204: LIST
53205: LIST
53206: PPUSH
53207: CALL_OW 69
53211: ST_TO_ADDR
// if not tmp then
53212: LD_VAR 0 6
53216: NOT
53217: IFFALSE 53221
// exit ;
53219: GO 53367
// s1 := rand ( 1 , 4 ) ;
53221: LD_ADDR_VAR 0 2
53225: PUSH
53226: LD_INT 1
53228: PPUSH
53229: LD_INT 4
53231: PPUSH
53232: CALL_OW 12
53236: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53237: LD_ADDR_VAR 0 4
53241: PUSH
53242: LD_VAR 0 6
53246: PUSH
53247: LD_INT 1
53249: ARRAY
53250: PPUSH
53251: LD_VAR 0 2
53255: PPUSH
53256: CALL_OW 259
53260: ST_TO_ADDR
// if s1 = 1 then
53261: LD_VAR 0 2
53265: PUSH
53266: LD_INT 1
53268: EQUAL
53269: IFFALSE 53289
// s2 := rand ( 2 , 4 ) else
53271: LD_ADDR_VAR 0 3
53275: PUSH
53276: LD_INT 2
53278: PPUSH
53279: LD_INT 4
53281: PPUSH
53282: CALL_OW 12
53286: ST_TO_ADDR
53287: GO 53297
// s2 := 1 ;
53289: LD_ADDR_VAR 0 3
53293: PUSH
53294: LD_INT 1
53296: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53297: LD_ADDR_VAR 0 5
53301: PUSH
53302: LD_VAR 0 6
53306: PUSH
53307: LD_INT 1
53309: ARRAY
53310: PPUSH
53311: LD_VAR 0 3
53315: PPUSH
53316: CALL_OW 259
53320: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53321: LD_VAR 0 6
53325: PUSH
53326: LD_INT 1
53328: ARRAY
53329: PPUSH
53330: LD_VAR 0 2
53334: PPUSH
53335: LD_VAR 0 5
53339: PPUSH
53340: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53344: LD_VAR 0 6
53348: PUSH
53349: LD_INT 1
53351: ARRAY
53352: PPUSH
53353: LD_VAR 0 3
53357: PPUSH
53358: LD_VAR 0 4
53362: PPUSH
53363: CALL_OW 237
// end ;
53367: PPOPN 6
53369: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53370: LD_EXP 91
53374: PUSH
53375: LD_EXP 138
53379: AND
53380: IFFALSE 53459
53382: GO 53384
53384: DISABLE
53385: LD_INT 0
53387: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53388: LD_ADDR_VAR 0 1
53392: PUSH
53393: LD_INT 22
53395: PUSH
53396: LD_OWVAR 2
53400: PUSH
53401: EMPTY
53402: LIST
53403: LIST
53404: PUSH
53405: LD_INT 30
53407: PUSH
53408: LD_INT 3
53410: PUSH
53411: EMPTY
53412: LIST
53413: LIST
53414: PUSH
53415: EMPTY
53416: LIST
53417: LIST
53418: PPUSH
53419: CALL_OW 69
53423: ST_TO_ADDR
// if not tmp then
53424: LD_VAR 0 1
53428: NOT
53429: IFFALSE 53433
// exit ;
53431: GO 53459
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53433: LD_VAR 0 1
53437: PUSH
53438: LD_INT 1
53440: PPUSH
53441: LD_VAR 0 1
53445: PPUSH
53446: CALL_OW 12
53450: ARRAY
53451: PPUSH
53452: LD_INT 1
53454: PPUSH
53455: CALL_OW 234
// end ;
53459: PPOPN 1
53461: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53462: LD_EXP 91
53466: PUSH
53467: LD_EXP 139
53471: AND
53472: IFFALSE 53584
53474: GO 53476
53476: DISABLE
53477: LD_INT 0
53479: PPUSH
53480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53481: LD_ADDR_VAR 0 2
53485: PUSH
53486: LD_INT 22
53488: PUSH
53489: LD_OWVAR 2
53493: PUSH
53494: EMPTY
53495: LIST
53496: LIST
53497: PUSH
53498: LD_INT 2
53500: PUSH
53501: LD_INT 30
53503: PUSH
53504: LD_INT 27
53506: PUSH
53507: EMPTY
53508: LIST
53509: LIST
53510: PUSH
53511: LD_INT 30
53513: PUSH
53514: LD_INT 26
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: PUSH
53521: LD_INT 30
53523: PUSH
53524: LD_INT 28
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: LIST
53535: LIST
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PPUSH
53541: CALL_OW 69
53545: ST_TO_ADDR
// if not tmp then
53546: LD_VAR 0 2
53550: NOT
53551: IFFALSE 53555
// exit ;
53553: GO 53584
// for i in tmp do
53555: LD_ADDR_VAR 0 1
53559: PUSH
53560: LD_VAR 0 2
53564: PUSH
53565: FOR_IN
53566: IFFALSE 53582
// SetLives ( i , 1 ) ;
53568: LD_VAR 0 1
53572: PPUSH
53573: LD_INT 1
53575: PPUSH
53576: CALL_OW 234
53580: GO 53565
53582: POP
53583: POP
// end ;
53584: PPOPN 2
53586: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53587: LD_EXP 91
53591: PUSH
53592: LD_EXP 140
53596: AND
53597: IFFALSE 53871
53599: GO 53601
53601: DISABLE
53602: LD_INT 0
53604: PPUSH
53605: PPUSH
53606: PPUSH
// begin i := rand ( 1 , 7 ) ;
53607: LD_ADDR_VAR 0 1
53611: PUSH
53612: LD_INT 1
53614: PPUSH
53615: LD_INT 7
53617: PPUSH
53618: CALL_OW 12
53622: ST_TO_ADDR
// case i of 1 :
53623: LD_VAR 0 1
53627: PUSH
53628: LD_INT 1
53630: DOUBLE
53631: EQUAL
53632: IFTRUE 53636
53634: GO 53646
53636: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53637: LD_STRING earthquake(getX(game), 0, 32)
53639: PPUSH
53640: CALL_OW 559
53644: GO 53871
53646: LD_INT 2
53648: DOUBLE
53649: EQUAL
53650: IFTRUE 53654
53652: GO 53668
53654: POP
// begin ToLua ( displayStucuk(); ) ;
53655: LD_STRING displayStucuk();
53657: PPUSH
53658: CALL_OW 559
// ResetFog ;
53662: CALL_OW 335
// end ; 3 :
53666: GO 53871
53668: LD_INT 3
53670: DOUBLE
53671: EQUAL
53672: IFTRUE 53676
53674: GO 53780
53676: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53677: LD_ADDR_VAR 0 2
53681: PUSH
53682: LD_INT 22
53684: PUSH
53685: LD_OWVAR 2
53689: PUSH
53690: EMPTY
53691: LIST
53692: LIST
53693: PUSH
53694: LD_INT 25
53696: PUSH
53697: LD_INT 1
53699: PUSH
53700: EMPTY
53701: LIST
53702: LIST
53703: PUSH
53704: EMPTY
53705: LIST
53706: LIST
53707: PPUSH
53708: CALL_OW 69
53712: ST_TO_ADDR
// if not tmp then
53713: LD_VAR 0 2
53717: NOT
53718: IFFALSE 53722
// exit ;
53720: GO 53871
// un := tmp [ rand ( 1 , tmp ) ] ;
53722: LD_ADDR_VAR 0 3
53726: PUSH
53727: LD_VAR 0 2
53731: PUSH
53732: LD_INT 1
53734: PPUSH
53735: LD_VAR 0 2
53739: PPUSH
53740: CALL_OW 12
53744: ARRAY
53745: ST_TO_ADDR
// if Crawls ( un ) then
53746: LD_VAR 0 3
53750: PPUSH
53751: CALL_OW 318
53755: IFFALSE 53766
// ComWalk ( un ) ;
53757: LD_VAR 0 3
53761: PPUSH
53762: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53766: LD_VAR 0 3
53770: PPUSH
53771: LD_INT 8
53773: PPUSH
53774: CALL_OW 336
// end ; 4 :
53778: GO 53871
53780: LD_INT 4
53782: DOUBLE
53783: EQUAL
53784: IFTRUE 53788
53786: GO 53849
53788: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53789: LD_ADDR_VAR 0 2
53793: PUSH
53794: LD_INT 22
53796: PUSH
53797: LD_OWVAR 2
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: PUSH
53806: LD_INT 30
53808: PUSH
53809: LD_INT 29
53811: PUSH
53812: EMPTY
53813: LIST
53814: LIST
53815: PUSH
53816: EMPTY
53817: LIST
53818: LIST
53819: PPUSH
53820: CALL_OW 69
53824: ST_TO_ADDR
// if not tmp then
53825: LD_VAR 0 2
53829: NOT
53830: IFFALSE 53834
// exit ;
53832: GO 53871
// DestroyUnit ( tmp [ 1 ] ) ;
53834: LD_VAR 0 2
53838: PUSH
53839: LD_INT 1
53841: ARRAY
53842: PPUSH
53843: CALL_OW 65
// end ; 5 .. 7 :
53847: GO 53871
53849: LD_INT 5
53851: DOUBLE
53852: GREATEREQUAL
53853: IFFALSE 53861
53855: LD_INT 7
53857: DOUBLE
53858: LESSEQUAL
53859: IFTRUE 53863
53861: GO 53870
53863: POP
// StreamSibBomb ; end ;
53864: CALL 50121 0 0
53868: GO 53871
53870: POP
// end ;
53871: PPOPN 3
53873: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53874: LD_EXP 91
53878: PUSH
53879: LD_EXP 141
53883: AND
53884: IFFALSE 54040
53886: GO 53888
53888: DISABLE
53889: LD_INT 0
53891: PPUSH
53892: PPUSH
53893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
53894: LD_ADDR_VAR 0 2
53898: PUSH
53899: LD_INT 81
53901: PUSH
53902: LD_OWVAR 2
53906: PUSH
53907: EMPTY
53908: LIST
53909: LIST
53910: PUSH
53911: LD_INT 2
53913: PUSH
53914: LD_INT 21
53916: PUSH
53917: LD_INT 1
53919: PUSH
53920: EMPTY
53921: LIST
53922: LIST
53923: PUSH
53924: LD_INT 21
53926: PUSH
53927: LD_INT 2
53929: PUSH
53930: EMPTY
53931: LIST
53932: LIST
53933: PUSH
53934: EMPTY
53935: LIST
53936: LIST
53937: LIST
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PPUSH
53943: CALL_OW 69
53947: ST_TO_ADDR
// if not tmp then
53948: LD_VAR 0 2
53952: NOT
53953: IFFALSE 53957
// exit ;
53955: GO 54040
// p := 0 ;
53957: LD_ADDR_VAR 0 3
53961: PUSH
53962: LD_INT 0
53964: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53965: LD_INT 35
53967: PPUSH
53968: CALL_OW 67
// p := p + 1 ;
53972: LD_ADDR_VAR 0 3
53976: PUSH
53977: LD_VAR 0 3
53981: PUSH
53982: LD_INT 1
53984: PLUS
53985: ST_TO_ADDR
// for i in tmp do
53986: LD_ADDR_VAR 0 1
53990: PUSH
53991: LD_VAR 0 2
53995: PUSH
53996: FOR_IN
53997: IFFALSE 54028
// if GetLives ( i ) < 1000 then
53999: LD_VAR 0 1
54003: PPUSH
54004: CALL_OW 256
54008: PUSH
54009: LD_INT 1000
54011: LESS
54012: IFFALSE 54026
// SetLives ( i , 1000 ) ;
54014: LD_VAR 0 1
54018: PPUSH
54019: LD_INT 1000
54021: PPUSH
54022: CALL_OW 234
54026: GO 53996
54028: POP
54029: POP
// until p > 20 ;
54030: LD_VAR 0 3
54034: PUSH
54035: LD_INT 20
54037: GREATER
54038: IFFALSE 53965
// end ;
54040: PPOPN 3
54042: END
// every 0 0$1 trigger StreamModeActive and sTime do
54043: LD_EXP 91
54047: PUSH
54048: LD_EXP 142
54052: AND
54053: IFFALSE 54088
54055: GO 54057
54057: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54058: LD_INT 28
54060: PPUSH
54061: LD_OWVAR 2
54065: PPUSH
54066: LD_INT 2
54068: PPUSH
54069: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54073: LD_INT 30
54075: PPUSH
54076: LD_OWVAR 2
54080: PPUSH
54081: LD_INT 2
54083: PPUSH
54084: CALL_OW 322
// end ;
54088: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54089: LD_EXP 91
54093: PUSH
54094: LD_EXP 143
54098: AND
54099: IFFALSE 54220
54101: GO 54103
54103: DISABLE
54104: LD_INT 0
54106: PPUSH
54107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54108: LD_ADDR_VAR 0 2
54112: PUSH
54113: LD_INT 22
54115: PUSH
54116: LD_OWVAR 2
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: PUSH
54125: LD_INT 21
54127: PUSH
54128: LD_INT 1
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: PUSH
54135: LD_INT 3
54137: PUSH
54138: LD_INT 23
54140: PUSH
54141: LD_INT 0
54143: PUSH
54144: EMPTY
54145: LIST
54146: LIST
54147: PUSH
54148: EMPTY
54149: LIST
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: PPUSH
54157: CALL_OW 69
54161: ST_TO_ADDR
// if not tmp then
54162: LD_VAR 0 2
54166: NOT
54167: IFFALSE 54171
// exit ;
54169: GO 54220
// for i in tmp do
54171: LD_ADDR_VAR 0 1
54175: PUSH
54176: LD_VAR 0 2
54180: PUSH
54181: FOR_IN
54182: IFFALSE 54218
// begin if Crawls ( i ) then
54184: LD_VAR 0 1
54188: PPUSH
54189: CALL_OW 318
54193: IFFALSE 54204
// ComWalk ( i ) ;
54195: LD_VAR 0 1
54199: PPUSH
54200: CALL_OW 138
// SetClass ( i , 2 ) ;
54204: LD_VAR 0 1
54208: PPUSH
54209: LD_INT 2
54211: PPUSH
54212: CALL_OW 336
// end ;
54216: GO 54181
54218: POP
54219: POP
// end ;
54220: PPOPN 2
54222: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54223: LD_EXP 91
54227: PUSH
54228: LD_EXP 144
54232: AND
54233: IFFALSE 54514
54235: GO 54237
54237: DISABLE
54238: LD_INT 0
54240: PPUSH
54241: PPUSH
54242: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54243: LD_OWVAR 2
54247: PPUSH
54248: LD_INT 9
54250: PPUSH
54251: LD_INT 1
54253: PPUSH
54254: LD_INT 1
54256: PPUSH
54257: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54261: LD_INT 9
54263: PPUSH
54264: LD_OWVAR 2
54268: PPUSH
54269: CALL_OW 343
// uc_side := 9 ;
54273: LD_ADDR_OWVAR 20
54277: PUSH
54278: LD_INT 9
54280: ST_TO_ADDR
// uc_nation := 2 ;
54281: LD_ADDR_OWVAR 21
54285: PUSH
54286: LD_INT 2
54288: ST_TO_ADDR
// hc_name := Dark Warrior ;
54289: LD_ADDR_OWVAR 26
54293: PUSH
54294: LD_STRING Dark Warrior
54296: ST_TO_ADDR
// hc_gallery :=  ;
54297: LD_ADDR_OWVAR 33
54301: PUSH
54302: LD_STRING 
54304: ST_TO_ADDR
// hc_noskilllimit := true ;
54305: LD_ADDR_OWVAR 76
54309: PUSH
54310: LD_INT 1
54312: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54313: LD_ADDR_OWVAR 31
54317: PUSH
54318: LD_INT 30
54320: PUSH
54321: LD_INT 30
54323: PUSH
54324: LD_INT 30
54326: PUSH
54327: LD_INT 30
54329: PUSH
54330: EMPTY
54331: LIST
54332: LIST
54333: LIST
54334: LIST
54335: ST_TO_ADDR
// un := CreateHuman ;
54336: LD_ADDR_VAR 0 3
54340: PUSH
54341: CALL_OW 44
54345: ST_TO_ADDR
// hc_noskilllimit := false ;
54346: LD_ADDR_OWVAR 76
54350: PUSH
54351: LD_INT 0
54353: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54354: LD_VAR 0 3
54358: PPUSH
54359: LD_INT 1
54361: PPUSH
54362: CALL_OW 51
// p := 0 ;
54366: LD_ADDR_VAR 0 2
54370: PUSH
54371: LD_INT 0
54373: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54374: LD_INT 35
54376: PPUSH
54377: CALL_OW 67
// p := p + 1 ;
54381: LD_ADDR_VAR 0 2
54385: PUSH
54386: LD_VAR 0 2
54390: PUSH
54391: LD_INT 1
54393: PLUS
54394: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54395: LD_VAR 0 3
54399: PPUSH
54400: CALL_OW 256
54404: PUSH
54405: LD_INT 1000
54407: LESS
54408: IFFALSE 54422
// SetLives ( un , 1000 ) ;
54410: LD_VAR 0 3
54414: PPUSH
54415: LD_INT 1000
54417: PPUSH
54418: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54422: LD_VAR 0 3
54426: PPUSH
54427: LD_INT 81
54429: PUSH
54430: LD_OWVAR 2
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: PUSH
54439: LD_INT 91
54441: PUSH
54442: LD_VAR 0 3
54446: PUSH
54447: LD_INT 30
54449: PUSH
54450: EMPTY
54451: LIST
54452: LIST
54453: LIST
54454: PUSH
54455: EMPTY
54456: LIST
54457: LIST
54458: PPUSH
54459: CALL_OW 69
54463: PPUSH
54464: LD_VAR 0 3
54468: PPUSH
54469: CALL_OW 74
54473: PPUSH
54474: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54478: LD_VAR 0 2
54482: PUSH
54483: LD_INT 60
54485: GREATER
54486: PUSH
54487: LD_VAR 0 3
54491: PPUSH
54492: CALL_OW 301
54496: OR
54497: IFFALSE 54374
// if un then
54499: LD_VAR 0 3
54503: IFFALSE 54514
// RemoveUnit ( un ) ;
54505: LD_VAR 0 3
54509: PPUSH
54510: CALL_OW 64
// end ;
54514: PPOPN 3
54516: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
54517: LD_INT 0
54519: PPUSH
// case cmd of 301 :
54520: LD_VAR 0 1
54524: PUSH
54525: LD_INT 301
54527: DOUBLE
54528: EQUAL
54529: IFTRUE 54533
54531: GO 54565
54533: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
54534: LD_VAR 0 6
54538: PPUSH
54539: LD_VAR 0 7
54543: PPUSH
54544: LD_VAR 0 8
54548: PPUSH
54549: LD_VAR 0 4
54553: PPUSH
54554: LD_VAR 0 5
54558: PPUSH
54559: CALL 55766 0 5
54563: GO 54686
54565: LD_INT 302
54567: DOUBLE
54568: EQUAL
54569: IFTRUE 54573
54571: GO 54610
54573: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
54574: LD_VAR 0 6
54578: PPUSH
54579: LD_VAR 0 7
54583: PPUSH
54584: LD_VAR 0 8
54588: PPUSH
54589: LD_VAR 0 9
54593: PPUSH
54594: LD_VAR 0 4
54598: PPUSH
54599: LD_VAR 0 5
54603: PPUSH
54604: CALL 55857 0 6
54608: GO 54686
54610: LD_INT 303
54612: DOUBLE
54613: EQUAL
54614: IFTRUE 54618
54616: GO 54655
54618: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
54619: LD_VAR 0 6
54623: PPUSH
54624: LD_VAR 0 7
54628: PPUSH
54629: LD_VAR 0 8
54633: PPUSH
54634: LD_VAR 0 9
54638: PPUSH
54639: LD_VAR 0 4
54643: PPUSH
54644: LD_VAR 0 5
54648: PPUSH
54649: CALL 54691 0 6
54653: GO 54686
54655: LD_INT 304
54657: DOUBLE
54658: EQUAL
54659: IFTRUE 54663
54661: GO 54685
54663: POP
// hHackTeleport ( unit , x , y ) ; end ;
54664: LD_VAR 0 2
54668: PPUSH
54669: LD_VAR 0 4
54673: PPUSH
54674: LD_VAR 0 5
54678: PPUSH
54679: CALL 56450 0 3
54683: GO 54686
54685: POP
// end ;
54686: LD_VAR 0 12
54690: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
54691: LD_INT 0
54693: PPUSH
54694: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
54695: LD_VAR 0 1
54699: PUSH
54700: LD_INT 1
54702: LESS
54703: PUSH
54704: LD_VAR 0 1
54708: PUSH
54709: LD_INT 3
54711: GREATER
54712: OR
54713: PUSH
54714: LD_VAR 0 5
54718: PPUSH
54719: LD_VAR 0 6
54723: PPUSH
54724: CALL_OW 428
54728: OR
54729: IFFALSE 54733
// exit ;
54731: GO 55453
// uc_side := your_side ;
54733: LD_ADDR_OWVAR 20
54737: PUSH
54738: LD_OWVAR 2
54742: ST_TO_ADDR
// uc_nation := nation ;
54743: LD_ADDR_OWVAR 21
54747: PUSH
54748: LD_VAR 0 1
54752: ST_TO_ADDR
// bc_level = 1 ;
54753: LD_ADDR_OWVAR 43
54757: PUSH
54758: LD_INT 1
54760: ST_TO_ADDR
// case btype of 1 :
54761: LD_VAR 0 2
54765: PUSH
54766: LD_INT 1
54768: DOUBLE
54769: EQUAL
54770: IFTRUE 54774
54772: GO 54785
54774: POP
// bc_type := b_depot ; 2 :
54775: LD_ADDR_OWVAR 42
54779: PUSH
54780: LD_INT 0
54782: ST_TO_ADDR
54783: GO 55397
54785: LD_INT 2
54787: DOUBLE
54788: EQUAL
54789: IFTRUE 54793
54791: GO 54804
54793: POP
// bc_type := b_warehouse ; 3 :
54794: LD_ADDR_OWVAR 42
54798: PUSH
54799: LD_INT 1
54801: ST_TO_ADDR
54802: GO 55397
54804: LD_INT 3
54806: DOUBLE
54807: EQUAL
54808: IFTRUE 54812
54810: GO 54823
54812: POP
// bc_type := b_lab ; 4 .. 9 :
54813: LD_ADDR_OWVAR 42
54817: PUSH
54818: LD_INT 6
54820: ST_TO_ADDR
54821: GO 55397
54823: LD_INT 4
54825: DOUBLE
54826: GREATEREQUAL
54827: IFFALSE 54835
54829: LD_INT 9
54831: DOUBLE
54832: LESSEQUAL
54833: IFTRUE 54837
54835: GO 54889
54837: POP
// begin bc_type := b_lab_half ;
54838: LD_ADDR_OWVAR 42
54842: PUSH
54843: LD_INT 7
54845: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
54846: LD_ADDR_OWVAR 44
54850: PUSH
54851: LD_INT 10
54853: PUSH
54854: LD_INT 11
54856: PUSH
54857: LD_INT 12
54859: PUSH
54860: LD_INT 15
54862: PUSH
54863: LD_INT 14
54865: PUSH
54866: LD_INT 13
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: LIST
54873: LIST
54874: LIST
54875: LIST
54876: PUSH
54877: LD_VAR 0 2
54881: PUSH
54882: LD_INT 3
54884: MINUS
54885: ARRAY
54886: ST_TO_ADDR
// end ; 10 .. 13 :
54887: GO 55397
54889: LD_INT 10
54891: DOUBLE
54892: GREATEREQUAL
54893: IFFALSE 54901
54895: LD_INT 13
54897: DOUBLE
54898: LESSEQUAL
54899: IFTRUE 54903
54901: GO 54980
54903: POP
// begin bc_type := b_lab_full ;
54904: LD_ADDR_OWVAR 42
54908: PUSH
54909: LD_INT 8
54911: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
54912: LD_ADDR_OWVAR 44
54916: PUSH
54917: LD_INT 10
54919: PUSH
54920: LD_INT 12
54922: PUSH
54923: LD_INT 14
54925: PUSH
54926: LD_INT 13
54928: PUSH
54929: EMPTY
54930: LIST
54931: LIST
54932: LIST
54933: LIST
54934: PUSH
54935: LD_VAR 0 2
54939: PUSH
54940: LD_INT 9
54942: MINUS
54943: ARRAY
54944: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
54945: LD_ADDR_OWVAR 45
54949: PUSH
54950: LD_INT 11
54952: PUSH
54953: LD_INT 15
54955: PUSH
54956: LD_INT 12
54958: PUSH
54959: LD_INT 15
54961: PUSH
54962: EMPTY
54963: LIST
54964: LIST
54965: LIST
54966: LIST
54967: PUSH
54968: LD_VAR 0 2
54972: PUSH
54973: LD_INT 9
54975: MINUS
54976: ARRAY
54977: ST_TO_ADDR
// end ; 14 :
54978: GO 55397
54980: LD_INT 14
54982: DOUBLE
54983: EQUAL
54984: IFTRUE 54988
54986: GO 54999
54988: POP
// bc_type := b_workshop ; 15 :
54989: LD_ADDR_OWVAR 42
54993: PUSH
54994: LD_INT 2
54996: ST_TO_ADDR
54997: GO 55397
54999: LD_INT 15
55001: DOUBLE
55002: EQUAL
55003: IFTRUE 55007
55005: GO 55018
55007: POP
// bc_type := b_factory ; 16 :
55008: LD_ADDR_OWVAR 42
55012: PUSH
55013: LD_INT 3
55015: ST_TO_ADDR
55016: GO 55397
55018: LD_INT 16
55020: DOUBLE
55021: EQUAL
55022: IFTRUE 55026
55024: GO 55037
55026: POP
// bc_type := b_ext_gun ; 17 :
55027: LD_ADDR_OWVAR 42
55031: PUSH
55032: LD_INT 17
55034: ST_TO_ADDR
55035: GO 55397
55037: LD_INT 17
55039: DOUBLE
55040: EQUAL
55041: IFTRUE 55045
55043: GO 55073
55045: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55046: LD_ADDR_OWVAR 42
55050: PUSH
55051: LD_INT 19
55053: PUSH
55054: LD_INT 23
55056: PUSH
55057: LD_INT 19
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: LIST
55064: PUSH
55065: LD_VAR 0 1
55069: ARRAY
55070: ST_TO_ADDR
55071: GO 55397
55073: LD_INT 18
55075: DOUBLE
55076: EQUAL
55077: IFTRUE 55081
55079: GO 55092
55081: POP
// bc_type := b_ext_radar ; 19 :
55082: LD_ADDR_OWVAR 42
55086: PUSH
55087: LD_INT 20
55089: ST_TO_ADDR
55090: GO 55397
55092: LD_INT 19
55094: DOUBLE
55095: EQUAL
55096: IFTRUE 55100
55098: GO 55111
55100: POP
// bc_type := b_ext_radio ; 20 :
55101: LD_ADDR_OWVAR 42
55105: PUSH
55106: LD_INT 22
55108: ST_TO_ADDR
55109: GO 55397
55111: LD_INT 20
55113: DOUBLE
55114: EQUAL
55115: IFTRUE 55119
55117: GO 55130
55119: POP
// bc_type := b_ext_siberium ; 21 :
55120: LD_ADDR_OWVAR 42
55124: PUSH
55125: LD_INT 21
55127: ST_TO_ADDR
55128: GO 55397
55130: LD_INT 21
55132: DOUBLE
55133: EQUAL
55134: IFTRUE 55138
55136: GO 55149
55138: POP
// bc_type := b_ext_computer ; 22 :
55139: LD_ADDR_OWVAR 42
55143: PUSH
55144: LD_INT 24
55146: ST_TO_ADDR
55147: GO 55397
55149: LD_INT 22
55151: DOUBLE
55152: EQUAL
55153: IFTRUE 55157
55155: GO 55168
55157: POP
// bc_type := b_ext_track ; 23 :
55158: LD_ADDR_OWVAR 42
55162: PUSH
55163: LD_INT 16
55165: ST_TO_ADDR
55166: GO 55397
55168: LD_INT 23
55170: DOUBLE
55171: EQUAL
55172: IFTRUE 55176
55174: GO 55187
55176: POP
// bc_type := b_ext_laser ; 24 :
55177: LD_ADDR_OWVAR 42
55181: PUSH
55182: LD_INT 25
55184: ST_TO_ADDR
55185: GO 55397
55187: LD_INT 24
55189: DOUBLE
55190: EQUAL
55191: IFTRUE 55195
55193: GO 55206
55195: POP
// bc_type := b_control_tower ; 25 :
55196: LD_ADDR_OWVAR 42
55200: PUSH
55201: LD_INT 36
55203: ST_TO_ADDR
55204: GO 55397
55206: LD_INT 25
55208: DOUBLE
55209: EQUAL
55210: IFTRUE 55214
55212: GO 55225
55214: POP
// bc_type := b_breastwork ; 26 :
55215: LD_ADDR_OWVAR 42
55219: PUSH
55220: LD_INT 31
55222: ST_TO_ADDR
55223: GO 55397
55225: LD_INT 26
55227: DOUBLE
55228: EQUAL
55229: IFTRUE 55233
55231: GO 55244
55233: POP
// bc_type := b_bunker ; 27 :
55234: LD_ADDR_OWVAR 42
55238: PUSH
55239: LD_INT 32
55241: ST_TO_ADDR
55242: GO 55397
55244: LD_INT 27
55246: DOUBLE
55247: EQUAL
55248: IFTRUE 55252
55250: GO 55263
55252: POP
// bc_type := b_turret ; 28 :
55253: LD_ADDR_OWVAR 42
55257: PUSH
55258: LD_INT 33
55260: ST_TO_ADDR
55261: GO 55397
55263: LD_INT 28
55265: DOUBLE
55266: EQUAL
55267: IFTRUE 55271
55269: GO 55282
55271: POP
// bc_type := b_armoury ; 29 :
55272: LD_ADDR_OWVAR 42
55276: PUSH
55277: LD_INT 4
55279: ST_TO_ADDR
55280: GO 55397
55282: LD_INT 29
55284: DOUBLE
55285: EQUAL
55286: IFTRUE 55290
55288: GO 55301
55290: POP
// bc_type := b_barracks ; 30 :
55291: LD_ADDR_OWVAR 42
55295: PUSH
55296: LD_INT 5
55298: ST_TO_ADDR
55299: GO 55397
55301: LD_INT 30
55303: DOUBLE
55304: EQUAL
55305: IFTRUE 55309
55307: GO 55320
55309: POP
// bc_type := b_solar_power ; 31 :
55310: LD_ADDR_OWVAR 42
55314: PUSH
55315: LD_INT 27
55317: ST_TO_ADDR
55318: GO 55397
55320: LD_INT 31
55322: DOUBLE
55323: EQUAL
55324: IFTRUE 55328
55326: GO 55339
55328: POP
// bc_type := b_oil_power ; 32 :
55329: LD_ADDR_OWVAR 42
55333: PUSH
55334: LD_INT 26
55336: ST_TO_ADDR
55337: GO 55397
55339: LD_INT 32
55341: DOUBLE
55342: EQUAL
55343: IFTRUE 55347
55345: GO 55358
55347: POP
// bc_type := b_siberite_power ; 33 :
55348: LD_ADDR_OWVAR 42
55352: PUSH
55353: LD_INT 28
55355: ST_TO_ADDR
55356: GO 55397
55358: LD_INT 33
55360: DOUBLE
55361: EQUAL
55362: IFTRUE 55366
55364: GO 55377
55366: POP
// bc_type := b_oil_mine ; 34 :
55367: LD_ADDR_OWVAR 42
55371: PUSH
55372: LD_INT 29
55374: ST_TO_ADDR
55375: GO 55397
55377: LD_INT 34
55379: DOUBLE
55380: EQUAL
55381: IFTRUE 55385
55383: GO 55396
55385: POP
// bc_type := b_siberite_mine ; end ;
55386: LD_ADDR_OWVAR 42
55390: PUSH
55391: LD_INT 30
55393: ST_TO_ADDR
55394: GO 55397
55396: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
55397: LD_ADDR_VAR 0 8
55401: PUSH
55402: LD_VAR 0 5
55406: PPUSH
55407: LD_VAR 0 6
55411: PPUSH
55412: LD_VAR 0 3
55416: PPUSH
55417: CALL_OW 47
55421: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
55422: LD_OWVAR 42
55426: PUSH
55427: LD_INT 32
55429: PUSH
55430: LD_INT 33
55432: PUSH
55433: EMPTY
55434: LIST
55435: LIST
55436: IN
55437: IFFALSE 55453
// PlaceWeaponTurret ( b , weapon ) ;
55439: LD_VAR 0 8
55443: PPUSH
55444: LD_VAR 0 4
55448: PPUSH
55449: CALL_OW 431
// end ;
55453: LD_VAR 0 7
55457: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
55458: LD_INT 0
55460: PPUSH
55461: PPUSH
55462: PPUSH
55463: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
55464: LD_ADDR_VAR 0 4
55468: PUSH
55469: LD_INT 22
55471: PUSH
55472: LD_OWVAR 2
55476: PUSH
55477: EMPTY
55478: LIST
55479: LIST
55480: PUSH
55481: LD_INT 2
55483: PUSH
55484: LD_INT 30
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PUSH
55494: LD_INT 30
55496: PUSH
55497: LD_INT 1
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: PUSH
55509: EMPTY
55510: LIST
55511: LIST
55512: PPUSH
55513: CALL_OW 69
55517: ST_TO_ADDR
// if not tmp then
55518: LD_VAR 0 4
55522: NOT
55523: IFFALSE 55527
// exit ;
55525: GO 55586
// for i in tmp do
55527: LD_ADDR_VAR 0 2
55531: PUSH
55532: LD_VAR 0 4
55536: PUSH
55537: FOR_IN
55538: IFFALSE 55584
// for j = 1 to 3 do
55540: LD_ADDR_VAR 0 3
55544: PUSH
55545: DOUBLE
55546: LD_INT 1
55548: DEC
55549: ST_TO_ADDR
55550: LD_INT 3
55552: PUSH
55553: FOR_TO
55554: IFFALSE 55580
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
55556: LD_VAR 0 2
55560: PPUSH
55561: CALL_OW 274
55565: PPUSH
55566: LD_VAR 0 3
55570: PPUSH
55571: LD_INT 99999
55573: PPUSH
55574: CALL_OW 277
55578: GO 55553
55580: POP
55581: POP
55582: GO 55537
55584: POP
55585: POP
// end ;
55586: LD_VAR 0 1
55590: RET
// export function hHackSetLevel10 ; var i , j ; begin
55591: LD_INT 0
55593: PPUSH
55594: PPUSH
55595: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55596: LD_ADDR_VAR 0 2
55600: PUSH
55601: LD_INT 21
55603: PUSH
55604: LD_INT 1
55606: PUSH
55607: EMPTY
55608: LIST
55609: LIST
55610: PPUSH
55611: CALL_OW 69
55615: PUSH
55616: FOR_IN
55617: IFFALSE 55669
// if IsSelected ( i ) then
55619: LD_VAR 0 2
55623: PPUSH
55624: CALL_OW 306
55628: IFFALSE 55667
// begin for j := 1 to 4 do
55630: LD_ADDR_VAR 0 3
55634: PUSH
55635: DOUBLE
55636: LD_INT 1
55638: DEC
55639: ST_TO_ADDR
55640: LD_INT 4
55642: PUSH
55643: FOR_TO
55644: IFFALSE 55665
// SetSkill ( i , j , 10 ) ;
55646: LD_VAR 0 2
55650: PPUSH
55651: LD_VAR 0 3
55655: PPUSH
55656: LD_INT 10
55658: PPUSH
55659: CALL_OW 237
55663: GO 55643
55665: POP
55666: POP
// end ;
55667: GO 55616
55669: POP
55670: POP
// end ;
55671: LD_VAR 0 1
55675: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
55676: LD_INT 0
55678: PPUSH
55679: PPUSH
55680: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55681: LD_ADDR_VAR 0 2
55685: PUSH
55686: LD_INT 22
55688: PUSH
55689: LD_OWVAR 2
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: PUSH
55698: LD_INT 21
55700: PUSH
55701: LD_INT 1
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: PPUSH
55712: CALL_OW 69
55716: PUSH
55717: FOR_IN
55718: IFFALSE 55759
// begin for j := 1 to 4 do
55720: LD_ADDR_VAR 0 3
55724: PUSH
55725: DOUBLE
55726: LD_INT 1
55728: DEC
55729: ST_TO_ADDR
55730: LD_INT 4
55732: PUSH
55733: FOR_TO
55734: IFFALSE 55755
// SetSkill ( i , j , 10 ) ;
55736: LD_VAR 0 2
55740: PPUSH
55741: LD_VAR 0 3
55745: PPUSH
55746: LD_INT 10
55748: PPUSH
55749: CALL_OW 237
55753: GO 55733
55755: POP
55756: POP
// end ;
55757: GO 55717
55759: POP
55760: POP
// end ;
55761: LD_VAR 0 1
55765: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
55766: LD_INT 0
55768: PPUSH
// uc_side := your_side ;
55769: LD_ADDR_OWVAR 20
55773: PUSH
55774: LD_OWVAR 2
55778: ST_TO_ADDR
// uc_nation := nation ;
55779: LD_ADDR_OWVAR 21
55783: PUSH
55784: LD_VAR 0 1
55788: ST_TO_ADDR
// InitHc ;
55789: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55793: LD_INT 0
55795: PPUSH
55796: LD_VAR 0 2
55800: PPUSH
55801: LD_VAR 0 3
55805: PPUSH
55806: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
55810: LD_VAR 0 4
55814: PPUSH
55815: LD_VAR 0 5
55819: PPUSH
55820: CALL_OW 428
55824: PUSH
55825: LD_INT 0
55827: EQUAL
55828: IFFALSE 55852
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
55830: CALL_OW 44
55834: PPUSH
55835: LD_VAR 0 4
55839: PPUSH
55840: LD_VAR 0 5
55844: PPUSH
55845: LD_INT 1
55847: PPUSH
55848: CALL_OW 48
// end ;
55852: LD_VAR 0 6
55856: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
55857: LD_INT 0
55859: PPUSH
55860: PPUSH
// uc_side := your_side ;
55861: LD_ADDR_OWVAR 20
55865: PUSH
55866: LD_OWVAR 2
55870: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
55871: LD_VAR 0 1
55875: PUSH
55876: LD_INT 1
55878: PUSH
55879: LD_INT 2
55881: PUSH
55882: LD_INT 3
55884: PUSH
55885: LD_INT 4
55887: PUSH
55888: LD_INT 5
55890: PUSH
55891: EMPTY
55892: LIST
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: IN
55898: IFFALSE 55910
// uc_nation := nation_american else
55900: LD_ADDR_OWVAR 21
55904: PUSH
55905: LD_INT 1
55907: ST_TO_ADDR
55908: GO 55953
// if chassis in [ 11 , 12 , 13 , 14 ] then
55910: LD_VAR 0 1
55914: PUSH
55915: LD_INT 11
55917: PUSH
55918: LD_INT 12
55920: PUSH
55921: LD_INT 13
55923: PUSH
55924: LD_INT 14
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: LIST
55931: LIST
55932: IN
55933: IFFALSE 55945
// uc_nation := nation_arabian else
55935: LD_ADDR_OWVAR 21
55939: PUSH
55940: LD_INT 2
55942: ST_TO_ADDR
55943: GO 55953
// uc_nation := nation_russian ;
55945: LD_ADDR_OWVAR 21
55949: PUSH
55950: LD_INT 3
55952: ST_TO_ADDR
// vc_chassis := chassis ;
55953: LD_ADDR_OWVAR 37
55957: PUSH
55958: LD_VAR 0 1
55962: ST_TO_ADDR
// vc_engine := engine ;
55963: LD_ADDR_OWVAR 39
55967: PUSH
55968: LD_VAR 0 2
55972: ST_TO_ADDR
// vc_control := control ;
55973: LD_ADDR_OWVAR 38
55977: PUSH
55978: LD_VAR 0 3
55982: ST_TO_ADDR
// vc_weapon := weapon ;
55983: LD_ADDR_OWVAR 40
55987: PUSH
55988: LD_VAR 0 4
55992: ST_TO_ADDR
// un := CreateVehicle ;
55993: LD_ADDR_VAR 0 8
55997: PUSH
55998: CALL_OW 45
56002: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
56003: LD_VAR 0 8
56007: PPUSH
56008: LD_INT 0
56010: PPUSH
56011: LD_INT 5
56013: PPUSH
56014: CALL_OW 12
56018: PPUSH
56019: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56023: LD_VAR 0 8
56027: PPUSH
56028: LD_VAR 0 5
56032: PPUSH
56033: LD_VAR 0 6
56037: PPUSH
56038: LD_INT 1
56040: PPUSH
56041: CALL_OW 48
// end ;
56045: LD_VAR 0 7
56049: RET
// export hInvincible ; every 1 do
56050: GO 56052
56052: DISABLE
// hInvincible := [ ] ;
56053: LD_ADDR_EXP 145
56057: PUSH
56058: EMPTY
56059: ST_TO_ADDR
56060: END
// every 10 do var i ;
56061: GO 56063
56063: DISABLE
56064: LD_INT 0
56066: PPUSH
// begin enable ;
56067: ENABLE
// if not hInvincible then
56068: LD_EXP 145
56072: NOT
56073: IFFALSE 56077
// exit ;
56075: GO 56121
// for i in hInvincible do
56077: LD_ADDR_VAR 0 1
56081: PUSH
56082: LD_EXP 145
56086: PUSH
56087: FOR_IN
56088: IFFALSE 56119
// if GetLives ( i ) < 1000 then
56090: LD_VAR 0 1
56094: PPUSH
56095: CALL_OW 256
56099: PUSH
56100: LD_INT 1000
56102: LESS
56103: IFFALSE 56117
// SetLives ( i , 1000 ) ;
56105: LD_VAR 0 1
56109: PPUSH
56110: LD_INT 1000
56112: PPUSH
56113: CALL_OW 234
56117: GO 56087
56119: POP
56120: POP
// end ;
56121: PPOPN 1
56123: END
// export function hHackInvincible ; var i ; begin
56124: LD_INT 0
56126: PPUSH
56127: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56128: LD_ADDR_VAR 0 2
56132: PUSH
56133: LD_INT 2
56135: PUSH
56136: LD_INT 21
56138: PUSH
56139: LD_INT 1
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: PUSH
56146: LD_INT 21
56148: PUSH
56149: LD_INT 2
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: PUSH
56156: EMPTY
56157: LIST
56158: LIST
56159: LIST
56160: PPUSH
56161: CALL_OW 69
56165: PUSH
56166: FOR_IN
56167: IFFALSE 56228
// if IsSelected ( i ) then
56169: LD_VAR 0 2
56173: PPUSH
56174: CALL_OW 306
56178: IFFALSE 56226
// begin if i in hInvincible then
56180: LD_VAR 0 2
56184: PUSH
56185: LD_EXP 145
56189: IN
56190: IFFALSE 56210
// hInvincible := hInvincible diff i else
56192: LD_ADDR_EXP 145
56196: PUSH
56197: LD_EXP 145
56201: PUSH
56202: LD_VAR 0 2
56206: DIFF
56207: ST_TO_ADDR
56208: GO 56226
// hInvincible := hInvincible union i ;
56210: LD_ADDR_EXP 145
56214: PUSH
56215: LD_EXP 145
56219: PUSH
56220: LD_VAR 0 2
56224: UNION
56225: ST_TO_ADDR
// end ;
56226: GO 56166
56228: POP
56229: POP
// end ;
56230: LD_VAR 0 1
56234: RET
// export function hHackInvisible ; var i , j ; begin
56235: LD_INT 0
56237: PPUSH
56238: PPUSH
56239: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56240: LD_ADDR_VAR 0 2
56244: PUSH
56245: LD_INT 21
56247: PUSH
56248: LD_INT 1
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: PPUSH
56255: CALL_OW 69
56259: PUSH
56260: FOR_IN
56261: IFFALSE 56285
// if IsSelected ( i ) then
56263: LD_VAR 0 2
56267: PPUSH
56268: CALL_OW 306
56272: IFFALSE 56283
// ComForceInvisible ( i ) ;
56274: LD_VAR 0 2
56278: PPUSH
56279: CALL_OW 496
56283: GO 56260
56285: POP
56286: POP
// end ;
56287: LD_VAR 0 1
56291: RET
// export function hHackChangeYourSide ; begin
56292: LD_INT 0
56294: PPUSH
// if your_side = 8 then
56295: LD_OWVAR 2
56299: PUSH
56300: LD_INT 8
56302: EQUAL
56303: IFFALSE 56315
// your_side := 0 else
56305: LD_ADDR_OWVAR 2
56309: PUSH
56310: LD_INT 0
56312: ST_TO_ADDR
56313: GO 56329
// your_side := your_side + 1 ;
56315: LD_ADDR_OWVAR 2
56319: PUSH
56320: LD_OWVAR 2
56324: PUSH
56325: LD_INT 1
56327: PLUS
56328: ST_TO_ADDR
// end ;
56329: LD_VAR 0 1
56333: RET
// export function hHackChangeUnitSide ; var i , j ; begin
56334: LD_INT 0
56336: PPUSH
56337: PPUSH
56338: PPUSH
// for i in all_units do
56339: LD_ADDR_VAR 0 2
56343: PUSH
56344: LD_OWVAR 3
56348: PUSH
56349: FOR_IN
56350: IFFALSE 56428
// if IsSelected ( i ) then
56352: LD_VAR 0 2
56356: PPUSH
56357: CALL_OW 306
56361: IFFALSE 56426
// begin j := GetSide ( i ) ;
56363: LD_ADDR_VAR 0 3
56367: PUSH
56368: LD_VAR 0 2
56372: PPUSH
56373: CALL_OW 255
56377: ST_TO_ADDR
// if j = 8 then
56378: LD_VAR 0 3
56382: PUSH
56383: LD_INT 8
56385: EQUAL
56386: IFFALSE 56398
// j := 0 else
56388: LD_ADDR_VAR 0 3
56392: PUSH
56393: LD_INT 0
56395: ST_TO_ADDR
56396: GO 56412
// j := j + 1 ;
56398: LD_ADDR_VAR 0 3
56402: PUSH
56403: LD_VAR 0 3
56407: PUSH
56408: LD_INT 1
56410: PLUS
56411: ST_TO_ADDR
// SetSide ( i , j ) ;
56412: LD_VAR 0 2
56416: PPUSH
56417: LD_VAR 0 3
56421: PPUSH
56422: CALL_OW 235
// end ;
56426: GO 56349
56428: POP
56429: POP
// end ;
56430: LD_VAR 0 1
56434: RET
// export function hHackFog ; begin
56435: LD_INT 0
56437: PPUSH
// FogOff ( true ) ;
56438: LD_INT 1
56440: PPUSH
56441: CALL_OW 344
// end ;
56445: LD_VAR 0 1
56449: RET
// export function hHackTeleport ( unit , x , y ) ; begin
56450: LD_INT 0
56452: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
56453: LD_VAR 0 1
56457: PPUSH
56458: LD_VAR 0 2
56462: PPUSH
56463: LD_VAR 0 3
56467: PPUSH
56468: LD_INT 1
56470: PPUSH
56471: LD_INT 1
56473: PPUSH
56474: CALL_OW 483
// CenterOnXY ( x , y ) ;
56478: LD_VAR 0 2
56482: PPUSH
56483: LD_VAR 0 3
56487: PPUSH
56488: CALL_OW 84
// end ; end_of_file
56492: LD_VAR 0 4
56496: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56497: LD_INT 0
56499: PPUSH
56500: PPUSH
56501: PPUSH
56502: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56503: LD_VAR 0 1
56507: PPUSH
56508: CALL_OW 264
56512: PUSH
56513: LD_EXP 79
56517: EQUAL
56518: IFFALSE 56590
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56520: LD_INT 68
56522: PPUSH
56523: LD_VAR 0 1
56527: PPUSH
56528: CALL_OW 255
56532: PPUSH
56533: CALL_OW 321
56537: PUSH
56538: LD_INT 2
56540: EQUAL
56541: IFFALSE 56553
// eff := 70 else
56543: LD_ADDR_VAR 0 4
56547: PUSH
56548: LD_INT 70
56550: ST_TO_ADDR
56551: GO 56561
// eff := 30 ;
56553: LD_ADDR_VAR 0 4
56557: PUSH
56558: LD_INT 30
56560: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56561: LD_VAR 0 1
56565: PPUSH
56566: CALL_OW 250
56570: PPUSH
56571: LD_VAR 0 1
56575: PPUSH
56576: CALL_OW 251
56580: PPUSH
56581: LD_VAR 0 4
56585: PPUSH
56586: CALL_OW 495
// end ; end ;
56590: LD_VAR 0 2
56594: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56595: LD_INT 0
56597: PPUSH
// end ;
56598: LD_VAR 0 4
56602: RET
// export function SOS_Command ( cmd ) ; begin
56603: LD_INT 0
56605: PPUSH
// end ;
56606: LD_VAR 0 2
56610: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
56611: LD_INT 0
56613: PPUSH
// if cmd = 121 then
56614: LD_VAR 0 1
56618: PUSH
56619: LD_INT 121
56621: EQUAL
56622: IFFALSE 56624
// end ;
56624: LD_VAR 0 6
56628: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56629: LD_INT 0
56631: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
56632: LD_VAR 0 1
56636: PUSH
56637: LD_INT 250
56639: EQUAL
56640: PUSH
56641: LD_VAR 0 2
56645: PPUSH
56646: CALL_OW 264
56650: PUSH
56651: LD_EXP 82
56655: EQUAL
56656: AND
56657: IFFALSE 56678
// MinerPlaceMine ( unit , x , y ) ;
56659: LD_VAR 0 2
56663: PPUSH
56664: LD_VAR 0 4
56668: PPUSH
56669: LD_VAR 0 5
56673: PPUSH
56674: CALL 59027 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
56678: LD_VAR 0 1
56682: PUSH
56683: LD_INT 251
56685: EQUAL
56686: PUSH
56687: LD_VAR 0 2
56691: PPUSH
56692: CALL_OW 264
56696: PUSH
56697: LD_EXP 82
56701: EQUAL
56702: AND
56703: IFFALSE 56724
// MinerDetonateMine ( unit , x , y ) ;
56705: LD_VAR 0 2
56709: PPUSH
56710: LD_VAR 0 4
56714: PPUSH
56715: LD_VAR 0 5
56719: PPUSH
56720: CALL 59304 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
56724: LD_VAR 0 1
56728: PUSH
56729: LD_INT 252
56731: EQUAL
56732: PUSH
56733: LD_VAR 0 2
56737: PPUSH
56738: CALL_OW 264
56742: PUSH
56743: LD_EXP 82
56747: EQUAL
56748: AND
56749: IFFALSE 56770
// MinerCreateMinefield ( unit , x , y ) ;
56751: LD_VAR 0 2
56755: PPUSH
56756: LD_VAR 0 4
56760: PPUSH
56761: LD_VAR 0 5
56765: PPUSH
56766: CALL 59721 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
56770: LD_VAR 0 1
56774: PUSH
56775: LD_INT 253
56777: EQUAL
56778: PUSH
56779: LD_VAR 0 2
56783: PPUSH
56784: CALL_OW 257
56788: PUSH
56789: LD_INT 5
56791: EQUAL
56792: AND
56793: IFFALSE 56814
// ComBinocular ( unit , x , y ) ;
56795: LD_VAR 0 2
56799: PPUSH
56800: LD_VAR 0 4
56804: PPUSH
56805: LD_VAR 0 5
56809: PPUSH
56810: CALL 60092 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56814: LD_VAR 0 1
56818: PUSH
56819: LD_INT 254
56821: EQUAL
56822: PUSH
56823: LD_VAR 0 2
56827: PPUSH
56828: CALL_OW 264
56832: PUSH
56833: LD_EXP 77
56837: EQUAL
56838: AND
56839: PUSH
56840: LD_VAR 0 3
56844: PPUSH
56845: CALL_OW 263
56849: PUSH
56850: LD_INT 3
56852: EQUAL
56853: AND
56854: IFFALSE 56870
// HackDestroyVehicle ( unit , selectedUnit ) ;
56856: LD_VAR 0 2
56860: PPUSH
56861: LD_VAR 0 3
56865: PPUSH
56866: CALL 58387 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56870: LD_VAR 0 1
56874: PUSH
56875: LD_INT 255
56877: EQUAL
56878: PUSH
56879: LD_VAR 0 2
56883: PPUSH
56884: CALL_OW 264
56888: PUSH
56889: LD_INT 14
56891: PUSH
56892: LD_INT 53
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: IN
56899: AND
56900: PUSH
56901: LD_VAR 0 4
56905: PPUSH
56906: LD_VAR 0 5
56910: PPUSH
56911: CALL_OW 488
56915: AND
56916: IFFALSE 56940
// CutTreeXYR ( unit , x , y , 12 ) ;
56918: LD_VAR 0 2
56922: PPUSH
56923: LD_VAR 0 4
56927: PPUSH
56928: LD_VAR 0 5
56932: PPUSH
56933: LD_INT 12
56935: PPUSH
56936: CALL 56953 0 4
// end ;
56940: LD_VAR 0 6
56944: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
56945: LD_INT 0
56947: PPUSH
// end ;
56948: LD_VAR 0 4
56952: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56953: LD_INT 0
56955: PPUSH
56956: PPUSH
56957: PPUSH
56958: PPUSH
56959: PPUSH
56960: PPUSH
56961: PPUSH
56962: PPUSH
56963: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56964: LD_VAR 0 1
56968: NOT
56969: PUSH
56970: LD_VAR 0 2
56974: PPUSH
56975: LD_VAR 0 3
56979: PPUSH
56980: CALL_OW 488
56984: NOT
56985: OR
56986: PUSH
56987: LD_VAR 0 4
56991: NOT
56992: OR
56993: IFFALSE 56997
// exit ;
56995: GO 57337
// list := [ ] ;
56997: LD_ADDR_VAR 0 13
57001: PUSH
57002: EMPTY
57003: ST_TO_ADDR
// if x - r < 0 then
57004: LD_VAR 0 2
57008: PUSH
57009: LD_VAR 0 4
57013: MINUS
57014: PUSH
57015: LD_INT 0
57017: LESS
57018: IFFALSE 57030
// min_x := 0 else
57020: LD_ADDR_VAR 0 7
57024: PUSH
57025: LD_INT 0
57027: ST_TO_ADDR
57028: GO 57046
// min_x := x - r ;
57030: LD_ADDR_VAR 0 7
57034: PUSH
57035: LD_VAR 0 2
57039: PUSH
57040: LD_VAR 0 4
57044: MINUS
57045: ST_TO_ADDR
// if y - r < 0 then
57046: LD_VAR 0 3
57050: PUSH
57051: LD_VAR 0 4
57055: MINUS
57056: PUSH
57057: LD_INT 0
57059: LESS
57060: IFFALSE 57072
// min_y := 0 else
57062: LD_ADDR_VAR 0 8
57066: PUSH
57067: LD_INT 0
57069: ST_TO_ADDR
57070: GO 57088
// min_y := y - r ;
57072: LD_ADDR_VAR 0 8
57076: PUSH
57077: LD_VAR 0 3
57081: PUSH
57082: LD_VAR 0 4
57086: MINUS
57087: ST_TO_ADDR
// max_x := x + r ;
57088: LD_ADDR_VAR 0 9
57092: PUSH
57093: LD_VAR 0 2
57097: PUSH
57098: LD_VAR 0 4
57102: PLUS
57103: ST_TO_ADDR
// max_y := y + r ;
57104: LD_ADDR_VAR 0 10
57108: PUSH
57109: LD_VAR 0 3
57113: PUSH
57114: LD_VAR 0 4
57118: PLUS
57119: ST_TO_ADDR
// for _x = min_x to max_x do
57120: LD_ADDR_VAR 0 11
57124: PUSH
57125: DOUBLE
57126: LD_VAR 0 7
57130: DEC
57131: ST_TO_ADDR
57132: LD_VAR 0 9
57136: PUSH
57137: FOR_TO
57138: IFFALSE 57255
// for _y = min_y to max_y do
57140: LD_ADDR_VAR 0 12
57144: PUSH
57145: DOUBLE
57146: LD_VAR 0 8
57150: DEC
57151: ST_TO_ADDR
57152: LD_VAR 0 10
57156: PUSH
57157: FOR_TO
57158: IFFALSE 57251
// begin if not ValidHex ( _x , _y ) then
57160: LD_VAR 0 11
57164: PPUSH
57165: LD_VAR 0 12
57169: PPUSH
57170: CALL_OW 488
57174: NOT
57175: IFFALSE 57179
// continue ;
57177: GO 57157
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
57179: LD_VAR 0 11
57183: PPUSH
57184: LD_VAR 0 12
57188: PPUSH
57189: CALL_OW 351
57193: PUSH
57194: LD_VAR 0 11
57198: PPUSH
57199: LD_VAR 0 12
57203: PPUSH
57204: CALL_OW 554
57208: AND
57209: IFFALSE 57249
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
57211: LD_ADDR_VAR 0 13
57215: PUSH
57216: LD_VAR 0 13
57220: PPUSH
57221: LD_VAR 0 13
57225: PUSH
57226: LD_INT 1
57228: PLUS
57229: PPUSH
57230: LD_VAR 0 11
57234: PUSH
57235: LD_VAR 0 12
57239: PUSH
57240: EMPTY
57241: LIST
57242: LIST
57243: PPUSH
57244: CALL_OW 2
57248: ST_TO_ADDR
// end ;
57249: GO 57157
57251: POP
57252: POP
57253: GO 57137
57255: POP
57256: POP
// if not list then
57257: LD_VAR 0 13
57261: NOT
57262: IFFALSE 57266
// exit ;
57264: GO 57337
// for i in list do
57266: LD_ADDR_VAR 0 6
57270: PUSH
57271: LD_VAR 0 13
57275: PUSH
57276: FOR_IN
57277: IFFALSE 57335
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57279: LD_VAR 0 1
57283: PPUSH
57284: LD_STRING M
57286: PUSH
57287: LD_VAR 0 6
57291: PUSH
57292: LD_INT 1
57294: ARRAY
57295: PUSH
57296: LD_VAR 0 6
57300: PUSH
57301: LD_INT 2
57303: ARRAY
57304: PUSH
57305: LD_INT 0
57307: PUSH
57308: LD_INT 0
57310: PUSH
57311: LD_INT 0
57313: PUSH
57314: LD_INT 0
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: LIST
57321: LIST
57322: LIST
57323: LIST
57324: LIST
57325: PUSH
57326: EMPTY
57327: LIST
57328: PPUSH
57329: CALL_OW 447
57333: GO 57276
57335: POP
57336: POP
// end ;
57337: LD_VAR 0 5
57341: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57342: LD_EXP 148
57346: NOT
57347: IFFALSE 57397
57349: GO 57351
57351: DISABLE
// begin initHack := true ;
57352: LD_ADDR_EXP 148
57356: PUSH
57357: LD_INT 1
57359: ST_TO_ADDR
// hackTanks := [ ] ;
57360: LD_ADDR_EXP 149
57364: PUSH
57365: EMPTY
57366: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57367: LD_ADDR_EXP 150
57371: PUSH
57372: EMPTY
57373: ST_TO_ADDR
// hackLimit := 3 ;
57374: LD_ADDR_EXP 151
57378: PUSH
57379: LD_INT 3
57381: ST_TO_ADDR
// hackDist := 12 ;
57382: LD_ADDR_EXP 152
57386: PUSH
57387: LD_INT 12
57389: ST_TO_ADDR
// hackCounter := [ ] ;
57390: LD_ADDR_EXP 153
57394: PUSH
57395: EMPTY
57396: ST_TO_ADDR
// end ;
57397: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57398: LD_EXP 148
57402: PUSH
57403: LD_INT 34
57405: PUSH
57406: LD_EXP 77
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: PPUSH
57415: CALL_OW 69
57419: AND
57420: IFFALSE 57675
57422: GO 57424
57424: DISABLE
57425: LD_INT 0
57427: PPUSH
57428: PPUSH
// begin enable ;
57429: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57430: LD_ADDR_VAR 0 1
57434: PUSH
57435: LD_INT 34
57437: PUSH
57438: LD_EXP 77
57442: PUSH
57443: EMPTY
57444: LIST
57445: LIST
57446: PPUSH
57447: CALL_OW 69
57451: PUSH
57452: FOR_IN
57453: IFFALSE 57673
// begin if not i in hackTanks then
57455: LD_VAR 0 1
57459: PUSH
57460: LD_EXP 149
57464: IN
57465: NOT
57466: IFFALSE 57549
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57468: LD_ADDR_EXP 149
57472: PUSH
57473: LD_EXP 149
57477: PPUSH
57478: LD_EXP 149
57482: PUSH
57483: LD_INT 1
57485: PLUS
57486: PPUSH
57487: LD_VAR 0 1
57491: PPUSH
57492: CALL_OW 1
57496: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57497: LD_ADDR_EXP 150
57501: PUSH
57502: LD_EXP 150
57506: PPUSH
57507: LD_EXP 150
57511: PUSH
57512: LD_INT 1
57514: PLUS
57515: PPUSH
57516: EMPTY
57517: PPUSH
57518: CALL_OW 1
57522: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57523: LD_ADDR_EXP 153
57527: PUSH
57528: LD_EXP 153
57532: PPUSH
57533: LD_EXP 153
57537: PUSH
57538: LD_INT 1
57540: PLUS
57541: PPUSH
57542: EMPTY
57543: PPUSH
57544: CALL_OW 1
57548: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57549: LD_VAR 0 1
57553: PPUSH
57554: CALL_OW 302
57558: NOT
57559: IFFALSE 57572
// begin HackUnlinkAll ( i ) ;
57561: LD_VAR 0 1
57565: PPUSH
57566: CALL 57678 0 1
// continue ;
57570: GO 57452
// end ; HackCheckCapturedStatus ( i ) ;
57572: LD_VAR 0 1
57576: PPUSH
57577: CALL 58121 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57581: LD_ADDR_VAR 0 2
57585: PUSH
57586: LD_INT 81
57588: PUSH
57589: LD_VAR 0 1
57593: PPUSH
57594: CALL_OW 255
57598: PUSH
57599: EMPTY
57600: LIST
57601: LIST
57602: PUSH
57603: LD_INT 33
57605: PUSH
57606: LD_INT 3
57608: PUSH
57609: EMPTY
57610: LIST
57611: LIST
57612: PUSH
57613: LD_INT 91
57615: PUSH
57616: LD_VAR 0 1
57620: PUSH
57621: LD_EXP 152
57625: PUSH
57626: EMPTY
57627: LIST
57628: LIST
57629: LIST
57630: PUSH
57631: LD_INT 50
57633: PUSH
57634: EMPTY
57635: LIST
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: LIST
57641: LIST
57642: PPUSH
57643: CALL_OW 69
57647: ST_TO_ADDR
// if not tmp then
57648: LD_VAR 0 2
57652: NOT
57653: IFFALSE 57657
// continue ;
57655: GO 57452
// HackLink ( i , tmp ) ;
57657: LD_VAR 0 1
57661: PPUSH
57662: LD_VAR 0 2
57666: PPUSH
57667: CALL 57814 0 2
// end ;
57671: GO 57452
57673: POP
57674: POP
// end ;
57675: PPOPN 2
57677: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57678: LD_INT 0
57680: PPUSH
57681: PPUSH
57682: PPUSH
// if not hack in hackTanks then
57683: LD_VAR 0 1
57687: PUSH
57688: LD_EXP 149
57692: IN
57693: NOT
57694: IFFALSE 57698
// exit ;
57696: GO 57809
// index := GetElementIndex ( hackTanks , hack ) ;
57698: LD_ADDR_VAR 0 4
57702: PUSH
57703: LD_EXP 149
57707: PPUSH
57708: LD_VAR 0 1
57712: PPUSH
57713: CALL 65243 0 2
57717: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57718: LD_EXP 150
57722: PUSH
57723: LD_VAR 0 4
57727: ARRAY
57728: IFFALSE 57809
// begin for i in hackTanksCaptured [ index ] do
57730: LD_ADDR_VAR 0 3
57734: PUSH
57735: LD_EXP 150
57739: PUSH
57740: LD_VAR 0 4
57744: ARRAY
57745: PUSH
57746: FOR_IN
57747: IFFALSE 57773
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57749: LD_VAR 0 3
57753: PUSH
57754: LD_INT 1
57756: ARRAY
57757: PPUSH
57758: LD_VAR 0 3
57762: PUSH
57763: LD_INT 2
57765: ARRAY
57766: PPUSH
57767: CALL_OW 235
57771: GO 57746
57773: POP
57774: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57775: LD_ADDR_EXP 150
57779: PUSH
57780: LD_EXP 150
57784: PPUSH
57785: LD_VAR 0 4
57789: PPUSH
57790: EMPTY
57791: PPUSH
57792: CALL_OW 1
57796: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57797: LD_VAR 0 1
57801: PPUSH
57802: LD_INT 0
57804: PPUSH
57805: CALL_OW 505
// end ; end ;
57809: LD_VAR 0 2
57813: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57814: LD_INT 0
57816: PPUSH
57817: PPUSH
57818: PPUSH
// if not hack in hackTanks or not vehicles then
57819: LD_VAR 0 1
57823: PUSH
57824: LD_EXP 149
57828: IN
57829: NOT
57830: PUSH
57831: LD_VAR 0 2
57835: NOT
57836: OR
57837: IFFALSE 57841
// exit ;
57839: GO 58116
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57841: LD_ADDR_VAR 0 2
57845: PUSH
57846: LD_VAR 0 1
57850: PPUSH
57851: LD_VAR 0 2
57855: PPUSH
57856: LD_INT 1
57858: PPUSH
57859: LD_INT 1
57861: PPUSH
57862: CALL 65893 0 4
57866: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57867: LD_ADDR_VAR 0 5
57871: PUSH
57872: LD_EXP 149
57876: PPUSH
57877: LD_VAR 0 1
57881: PPUSH
57882: CALL 65243 0 2
57886: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57887: LD_EXP 150
57891: PUSH
57892: LD_VAR 0 5
57896: ARRAY
57897: PUSH
57898: LD_EXP 151
57902: LESS
57903: IFFALSE 58092
// begin for i := 1 to vehicles do
57905: LD_ADDR_VAR 0 4
57909: PUSH
57910: DOUBLE
57911: LD_INT 1
57913: DEC
57914: ST_TO_ADDR
57915: LD_VAR 0 2
57919: PUSH
57920: FOR_TO
57921: IFFALSE 58090
// begin if hackTanksCaptured [ index ] = hackLimit then
57923: LD_EXP 150
57927: PUSH
57928: LD_VAR 0 5
57932: ARRAY
57933: PUSH
57934: LD_EXP 151
57938: EQUAL
57939: IFFALSE 57943
// break ;
57941: GO 58090
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57943: LD_ADDR_EXP 153
57947: PUSH
57948: LD_EXP 153
57952: PPUSH
57953: LD_VAR 0 5
57957: PPUSH
57958: LD_EXP 153
57962: PUSH
57963: LD_VAR 0 5
57967: ARRAY
57968: PUSH
57969: LD_INT 1
57971: PLUS
57972: PPUSH
57973: CALL_OW 1
57977: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57978: LD_ADDR_EXP 150
57982: PUSH
57983: LD_EXP 150
57987: PPUSH
57988: LD_VAR 0 5
57992: PUSH
57993: LD_EXP 150
57997: PUSH
57998: LD_VAR 0 5
58002: ARRAY
58003: PUSH
58004: LD_INT 1
58006: PLUS
58007: PUSH
58008: EMPTY
58009: LIST
58010: LIST
58011: PPUSH
58012: LD_VAR 0 2
58016: PUSH
58017: LD_VAR 0 4
58021: ARRAY
58022: PUSH
58023: LD_VAR 0 2
58027: PUSH
58028: LD_VAR 0 4
58032: ARRAY
58033: PPUSH
58034: CALL_OW 255
58038: PUSH
58039: EMPTY
58040: LIST
58041: LIST
58042: PPUSH
58043: CALL 65458 0 3
58047: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
58048: LD_VAR 0 2
58052: PUSH
58053: LD_VAR 0 4
58057: ARRAY
58058: PPUSH
58059: LD_VAR 0 1
58063: PPUSH
58064: CALL_OW 255
58068: PPUSH
58069: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
58073: LD_VAR 0 2
58077: PUSH
58078: LD_VAR 0 4
58082: ARRAY
58083: PPUSH
58084: CALL_OW 141
// end ;
58088: GO 57920
58090: POP
58091: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58092: LD_VAR 0 1
58096: PPUSH
58097: LD_EXP 150
58101: PUSH
58102: LD_VAR 0 5
58106: ARRAY
58107: PUSH
58108: LD_INT 0
58110: PLUS
58111: PPUSH
58112: CALL_OW 505
// end ;
58116: LD_VAR 0 3
58120: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
58121: LD_INT 0
58123: PPUSH
58124: PPUSH
58125: PPUSH
58126: PPUSH
// if not hack in hackTanks then
58127: LD_VAR 0 1
58131: PUSH
58132: LD_EXP 149
58136: IN
58137: NOT
58138: IFFALSE 58142
// exit ;
58140: GO 58382
// index := GetElementIndex ( hackTanks , hack ) ;
58142: LD_ADDR_VAR 0 4
58146: PUSH
58147: LD_EXP 149
58151: PPUSH
58152: LD_VAR 0 1
58156: PPUSH
58157: CALL 65243 0 2
58161: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
58162: LD_ADDR_VAR 0 3
58166: PUSH
58167: DOUBLE
58168: LD_EXP 150
58172: PUSH
58173: LD_VAR 0 4
58177: ARRAY
58178: INC
58179: ST_TO_ADDR
58180: LD_INT 1
58182: PUSH
58183: FOR_DOWNTO
58184: IFFALSE 58356
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
58186: LD_ADDR_VAR 0 5
58190: PUSH
58191: LD_EXP 150
58195: PUSH
58196: LD_VAR 0 4
58200: ARRAY
58201: PUSH
58202: LD_VAR 0 3
58206: ARRAY
58207: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
58208: LD_VAR 0 5
58212: PUSH
58213: LD_INT 1
58215: ARRAY
58216: PPUSH
58217: CALL_OW 302
58221: NOT
58222: PUSH
58223: LD_VAR 0 5
58227: PUSH
58228: LD_INT 1
58230: ARRAY
58231: PPUSH
58232: CALL_OW 255
58236: PUSH
58237: LD_VAR 0 1
58241: PPUSH
58242: CALL_OW 255
58246: NONEQUAL
58247: OR
58248: IFFALSE 58354
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58250: LD_VAR 0 5
58254: PUSH
58255: LD_INT 1
58257: ARRAY
58258: PPUSH
58259: CALL_OW 305
58263: PUSH
58264: LD_VAR 0 5
58268: PUSH
58269: LD_INT 1
58271: ARRAY
58272: PPUSH
58273: CALL_OW 255
58277: PUSH
58278: LD_VAR 0 1
58282: PPUSH
58283: CALL_OW 255
58287: EQUAL
58288: AND
58289: IFFALSE 58313
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58291: LD_VAR 0 5
58295: PUSH
58296: LD_INT 1
58298: ARRAY
58299: PPUSH
58300: LD_VAR 0 5
58304: PUSH
58305: LD_INT 2
58307: ARRAY
58308: PPUSH
58309: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58313: LD_ADDR_EXP 150
58317: PUSH
58318: LD_EXP 150
58322: PPUSH
58323: LD_VAR 0 4
58327: PPUSH
58328: LD_EXP 150
58332: PUSH
58333: LD_VAR 0 4
58337: ARRAY
58338: PPUSH
58339: LD_VAR 0 3
58343: PPUSH
58344: CALL_OW 3
58348: PPUSH
58349: CALL_OW 1
58353: ST_TO_ADDR
// end ; end ;
58354: GO 58183
58356: POP
58357: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58358: LD_VAR 0 1
58362: PPUSH
58363: LD_EXP 150
58367: PUSH
58368: LD_VAR 0 4
58372: ARRAY
58373: PUSH
58374: LD_INT 0
58376: PLUS
58377: PPUSH
58378: CALL_OW 505
// end ;
58382: LD_VAR 0 2
58386: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58387: LD_INT 0
58389: PPUSH
58390: PPUSH
58391: PPUSH
58392: PPUSH
// if not hack in hackTanks then
58393: LD_VAR 0 1
58397: PUSH
58398: LD_EXP 149
58402: IN
58403: NOT
58404: IFFALSE 58408
// exit ;
58406: GO 58493
// index := GetElementIndex ( hackTanks , hack ) ;
58408: LD_ADDR_VAR 0 5
58412: PUSH
58413: LD_EXP 149
58417: PPUSH
58418: LD_VAR 0 1
58422: PPUSH
58423: CALL 65243 0 2
58427: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58428: LD_ADDR_VAR 0 4
58432: PUSH
58433: DOUBLE
58434: LD_INT 1
58436: DEC
58437: ST_TO_ADDR
58438: LD_EXP 150
58442: PUSH
58443: LD_VAR 0 5
58447: ARRAY
58448: PUSH
58449: FOR_TO
58450: IFFALSE 58491
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58452: LD_EXP 150
58456: PUSH
58457: LD_VAR 0 5
58461: ARRAY
58462: PUSH
58463: LD_VAR 0 4
58467: ARRAY
58468: PUSH
58469: LD_INT 1
58471: ARRAY
58472: PUSH
58473: LD_VAR 0 2
58477: EQUAL
58478: IFFALSE 58489
// KillUnit ( vehicle ) ;
58480: LD_VAR 0 2
58484: PPUSH
58485: CALL_OW 66
58489: GO 58449
58491: POP
58492: POP
// end ;
58493: LD_VAR 0 3
58497: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
58498: LD_EXP 154
58502: NOT
58503: IFFALSE 58538
58505: GO 58507
58507: DISABLE
// begin initMiner := true ;
58508: LD_ADDR_EXP 154
58512: PUSH
58513: LD_INT 1
58515: ST_TO_ADDR
// minersList := [ ] ;
58516: LD_ADDR_EXP 155
58520: PUSH
58521: EMPTY
58522: ST_TO_ADDR
// minerMinesList := [ ] ;
58523: LD_ADDR_EXP 156
58527: PUSH
58528: EMPTY
58529: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
58530: LD_ADDR_EXP 157
58534: PUSH
58535: LD_INT 5
58537: ST_TO_ADDR
// end ;
58538: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
58539: LD_EXP 154
58543: PUSH
58544: LD_INT 34
58546: PUSH
58547: LD_EXP 82
58551: PUSH
58552: EMPTY
58553: LIST
58554: LIST
58555: PPUSH
58556: CALL_OW 69
58560: AND
58561: IFFALSE 59024
58563: GO 58565
58565: DISABLE
58566: LD_INT 0
58568: PPUSH
58569: PPUSH
58570: PPUSH
58571: PPUSH
// begin enable ;
58572: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
58573: LD_ADDR_VAR 0 1
58577: PUSH
58578: LD_INT 34
58580: PUSH
58581: LD_EXP 82
58585: PUSH
58586: EMPTY
58587: LIST
58588: LIST
58589: PPUSH
58590: CALL_OW 69
58594: PUSH
58595: FOR_IN
58596: IFFALSE 58668
// begin if not i in minersList then
58598: LD_VAR 0 1
58602: PUSH
58603: LD_EXP 155
58607: IN
58608: NOT
58609: IFFALSE 58666
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
58611: LD_ADDR_EXP 155
58615: PUSH
58616: LD_EXP 155
58620: PPUSH
58621: LD_EXP 155
58625: PUSH
58626: LD_INT 1
58628: PLUS
58629: PPUSH
58630: LD_VAR 0 1
58634: PPUSH
58635: CALL_OW 1
58639: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
58640: LD_ADDR_EXP 156
58644: PUSH
58645: LD_EXP 156
58649: PPUSH
58650: LD_EXP 156
58654: PUSH
58655: LD_INT 1
58657: PLUS
58658: PPUSH
58659: EMPTY
58660: PPUSH
58661: CALL_OW 1
58665: ST_TO_ADDR
// end end ;
58666: GO 58595
58668: POP
58669: POP
// for i := minerMinesList downto 1 do
58670: LD_ADDR_VAR 0 1
58674: PUSH
58675: DOUBLE
58676: LD_EXP 156
58680: INC
58681: ST_TO_ADDR
58682: LD_INT 1
58684: PUSH
58685: FOR_DOWNTO
58686: IFFALSE 59022
// begin if IsLive ( minersList [ i ] ) then
58688: LD_EXP 155
58692: PUSH
58693: LD_VAR 0 1
58697: ARRAY
58698: PPUSH
58699: CALL_OW 300
58703: IFFALSE 58731
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
58705: LD_EXP 155
58709: PUSH
58710: LD_VAR 0 1
58714: ARRAY
58715: PPUSH
58716: LD_EXP 156
58720: PUSH
58721: LD_VAR 0 1
58725: ARRAY
58726: PPUSH
58727: CALL_OW 505
// if not minerMinesList [ i ] then
58731: LD_EXP 156
58735: PUSH
58736: LD_VAR 0 1
58740: ARRAY
58741: NOT
58742: IFFALSE 58746
// continue ;
58744: GO 58685
// for j := minerMinesList [ i ] downto 1 do
58746: LD_ADDR_VAR 0 2
58750: PUSH
58751: DOUBLE
58752: LD_EXP 156
58756: PUSH
58757: LD_VAR 0 1
58761: ARRAY
58762: INC
58763: ST_TO_ADDR
58764: LD_INT 1
58766: PUSH
58767: FOR_DOWNTO
58768: IFFALSE 59018
// begin side := GetSide ( minersList [ i ] ) ;
58770: LD_ADDR_VAR 0 3
58774: PUSH
58775: LD_EXP 155
58779: PUSH
58780: LD_VAR 0 1
58784: ARRAY
58785: PPUSH
58786: CALL_OW 255
58790: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
58791: LD_ADDR_VAR 0 4
58795: PUSH
58796: LD_EXP 156
58800: PUSH
58801: LD_VAR 0 1
58805: ARRAY
58806: PUSH
58807: LD_VAR 0 2
58811: ARRAY
58812: PUSH
58813: LD_INT 1
58815: ARRAY
58816: PPUSH
58817: LD_EXP 156
58821: PUSH
58822: LD_VAR 0 1
58826: ARRAY
58827: PUSH
58828: LD_VAR 0 2
58832: ARRAY
58833: PUSH
58834: LD_INT 2
58836: ARRAY
58837: PPUSH
58838: CALL_OW 428
58842: ST_TO_ADDR
// if not tmp then
58843: LD_VAR 0 4
58847: NOT
58848: IFFALSE 58852
// continue ;
58850: GO 58767
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
58852: LD_VAR 0 4
58856: PUSH
58857: LD_INT 81
58859: PUSH
58860: LD_VAR 0 3
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PPUSH
58869: CALL_OW 69
58873: IN
58874: PUSH
58875: LD_EXP 156
58879: PUSH
58880: LD_VAR 0 1
58884: ARRAY
58885: PUSH
58886: LD_VAR 0 2
58890: ARRAY
58891: PUSH
58892: LD_INT 1
58894: ARRAY
58895: PPUSH
58896: LD_EXP 156
58900: PUSH
58901: LD_VAR 0 1
58905: ARRAY
58906: PUSH
58907: LD_VAR 0 2
58911: ARRAY
58912: PUSH
58913: LD_INT 2
58915: ARRAY
58916: PPUSH
58917: CALL_OW 458
58921: AND
58922: IFFALSE 59016
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
58924: LD_EXP 156
58928: PUSH
58929: LD_VAR 0 1
58933: ARRAY
58934: PUSH
58935: LD_VAR 0 2
58939: ARRAY
58940: PUSH
58941: LD_INT 1
58943: ARRAY
58944: PPUSH
58945: LD_EXP 156
58949: PUSH
58950: LD_VAR 0 1
58954: ARRAY
58955: PUSH
58956: LD_VAR 0 2
58960: ARRAY
58961: PUSH
58962: LD_INT 2
58964: ARRAY
58965: PPUSH
58966: LD_VAR 0 3
58970: PPUSH
58971: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
58975: LD_ADDR_EXP 156
58979: PUSH
58980: LD_EXP 156
58984: PPUSH
58985: LD_VAR 0 1
58989: PPUSH
58990: LD_EXP 156
58994: PUSH
58995: LD_VAR 0 1
58999: ARRAY
59000: PPUSH
59001: LD_VAR 0 2
59005: PPUSH
59006: CALL_OW 3
59010: PPUSH
59011: CALL_OW 1
59015: ST_TO_ADDR
// end ; end ;
59016: GO 58767
59018: POP
59019: POP
// end ;
59020: GO 58685
59022: POP
59023: POP
// end ;
59024: PPOPN 4
59026: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
59027: LD_INT 0
59029: PPUSH
59030: PPUSH
// result := false ;
59031: LD_ADDR_VAR 0 4
59035: PUSH
59036: LD_INT 0
59038: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
59039: LD_VAR 0 1
59043: PPUSH
59044: CALL_OW 264
59048: PUSH
59049: LD_EXP 82
59053: EQUAL
59054: NOT
59055: IFFALSE 59059
// exit ;
59057: GO 59299
// index := GetElementIndex ( minersList , unit ) ;
59059: LD_ADDR_VAR 0 5
59063: PUSH
59064: LD_EXP 155
59068: PPUSH
59069: LD_VAR 0 1
59073: PPUSH
59074: CALL 65243 0 2
59078: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
59079: LD_EXP 156
59083: PUSH
59084: LD_VAR 0 5
59088: ARRAY
59089: PUSH
59090: LD_EXP 157
59094: GREATEREQUAL
59095: IFFALSE 59099
// exit ;
59097: GO 59299
// ComMoveXY ( unit , x , y ) ;
59099: LD_VAR 0 1
59103: PPUSH
59104: LD_VAR 0 2
59108: PPUSH
59109: LD_VAR 0 3
59113: PPUSH
59114: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
59118: LD_INT 35
59120: PPUSH
59121: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
59125: LD_VAR 0 1
59129: PPUSH
59130: LD_VAR 0 2
59134: PPUSH
59135: LD_VAR 0 3
59139: PPUSH
59140: CALL 95640 0 3
59144: NOT
59145: PUSH
59146: LD_VAR 0 1
59150: PPUSH
59151: CALL_OW 314
59155: AND
59156: IFFALSE 59160
// exit ;
59158: GO 59299
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
59160: LD_VAR 0 2
59164: PPUSH
59165: LD_VAR 0 3
59169: PPUSH
59170: CALL_OW 428
59174: PUSH
59175: LD_VAR 0 1
59179: EQUAL
59180: PUSH
59181: LD_VAR 0 1
59185: PPUSH
59186: CALL_OW 314
59190: NOT
59191: AND
59192: IFFALSE 59118
// PlaySoundXY ( x , y , PlantMine ) ;
59194: LD_VAR 0 2
59198: PPUSH
59199: LD_VAR 0 3
59203: PPUSH
59204: LD_STRING PlantMine
59206: PPUSH
59207: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
59211: LD_VAR 0 2
59215: PPUSH
59216: LD_VAR 0 3
59220: PPUSH
59221: LD_VAR 0 1
59225: PPUSH
59226: CALL_OW 255
59230: PPUSH
59231: LD_INT 0
59233: PPUSH
59234: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
59238: LD_ADDR_EXP 156
59242: PUSH
59243: LD_EXP 156
59247: PPUSH
59248: LD_VAR 0 5
59252: PUSH
59253: LD_EXP 156
59257: PUSH
59258: LD_VAR 0 5
59262: ARRAY
59263: PUSH
59264: LD_INT 1
59266: PLUS
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PPUSH
59272: LD_VAR 0 2
59276: PUSH
59277: LD_VAR 0 3
59281: PUSH
59282: EMPTY
59283: LIST
59284: LIST
59285: PPUSH
59286: CALL 65458 0 3
59290: ST_TO_ADDR
// result := true ;
59291: LD_ADDR_VAR 0 4
59295: PUSH
59296: LD_INT 1
59298: ST_TO_ADDR
// end ;
59299: LD_VAR 0 4
59303: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
59304: LD_INT 0
59306: PPUSH
59307: PPUSH
59308: PPUSH
// if not unit in minersList then
59309: LD_VAR 0 1
59313: PUSH
59314: LD_EXP 155
59318: IN
59319: NOT
59320: IFFALSE 59324
// exit ;
59322: GO 59716
// index := GetElementIndex ( minersList , unit ) ;
59324: LD_ADDR_VAR 0 6
59328: PUSH
59329: LD_EXP 155
59333: PPUSH
59334: LD_VAR 0 1
59338: PPUSH
59339: CALL 65243 0 2
59343: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
59344: LD_ADDR_VAR 0 5
59348: PUSH
59349: DOUBLE
59350: LD_EXP 156
59354: PUSH
59355: LD_VAR 0 6
59359: ARRAY
59360: INC
59361: ST_TO_ADDR
59362: LD_INT 1
59364: PUSH
59365: FOR_DOWNTO
59366: IFFALSE 59527
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
59368: LD_EXP 156
59372: PUSH
59373: LD_VAR 0 6
59377: ARRAY
59378: PUSH
59379: LD_VAR 0 5
59383: ARRAY
59384: PUSH
59385: LD_INT 1
59387: ARRAY
59388: PUSH
59389: LD_VAR 0 2
59393: EQUAL
59394: PUSH
59395: LD_EXP 156
59399: PUSH
59400: LD_VAR 0 6
59404: ARRAY
59405: PUSH
59406: LD_VAR 0 5
59410: ARRAY
59411: PUSH
59412: LD_INT 2
59414: ARRAY
59415: PUSH
59416: LD_VAR 0 3
59420: EQUAL
59421: AND
59422: IFFALSE 59525
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59424: LD_EXP 156
59428: PUSH
59429: LD_VAR 0 6
59433: ARRAY
59434: PUSH
59435: LD_VAR 0 5
59439: ARRAY
59440: PUSH
59441: LD_INT 1
59443: ARRAY
59444: PPUSH
59445: LD_EXP 156
59449: PUSH
59450: LD_VAR 0 6
59454: ARRAY
59455: PUSH
59456: LD_VAR 0 5
59460: ARRAY
59461: PUSH
59462: LD_INT 2
59464: ARRAY
59465: PPUSH
59466: LD_VAR 0 1
59470: PPUSH
59471: CALL_OW 255
59475: PPUSH
59476: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59480: LD_ADDR_EXP 156
59484: PUSH
59485: LD_EXP 156
59489: PPUSH
59490: LD_VAR 0 6
59494: PPUSH
59495: LD_EXP 156
59499: PUSH
59500: LD_VAR 0 6
59504: ARRAY
59505: PPUSH
59506: LD_VAR 0 5
59510: PPUSH
59511: CALL_OW 3
59515: PPUSH
59516: CALL_OW 1
59520: ST_TO_ADDR
// exit ;
59521: POP
59522: POP
59523: GO 59716
// end ; end ;
59525: GO 59365
59527: POP
59528: POP
// for i := minerMinesList [ index ] downto 1 do
59529: LD_ADDR_VAR 0 5
59533: PUSH
59534: DOUBLE
59535: LD_EXP 156
59539: PUSH
59540: LD_VAR 0 6
59544: ARRAY
59545: INC
59546: ST_TO_ADDR
59547: LD_INT 1
59549: PUSH
59550: FOR_DOWNTO
59551: IFFALSE 59714
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
59553: LD_EXP 156
59557: PUSH
59558: LD_VAR 0 6
59562: ARRAY
59563: PUSH
59564: LD_VAR 0 5
59568: ARRAY
59569: PUSH
59570: LD_INT 1
59572: ARRAY
59573: PPUSH
59574: LD_EXP 156
59578: PUSH
59579: LD_VAR 0 6
59583: ARRAY
59584: PUSH
59585: LD_VAR 0 5
59589: ARRAY
59590: PUSH
59591: LD_INT 2
59593: ARRAY
59594: PPUSH
59595: LD_VAR 0 2
59599: PPUSH
59600: LD_VAR 0 3
59604: PPUSH
59605: CALL_OW 298
59609: PUSH
59610: LD_INT 6
59612: LESS
59613: IFFALSE 59712
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
59615: LD_EXP 156
59619: PUSH
59620: LD_VAR 0 6
59624: ARRAY
59625: PUSH
59626: LD_VAR 0 5
59630: ARRAY
59631: PUSH
59632: LD_INT 1
59634: ARRAY
59635: PPUSH
59636: LD_EXP 156
59640: PUSH
59641: LD_VAR 0 6
59645: ARRAY
59646: PUSH
59647: LD_VAR 0 5
59651: ARRAY
59652: PUSH
59653: LD_INT 2
59655: ARRAY
59656: PPUSH
59657: LD_VAR 0 1
59661: PPUSH
59662: CALL_OW 255
59666: PPUSH
59667: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
59671: LD_ADDR_EXP 156
59675: PUSH
59676: LD_EXP 156
59680: PPUSH
59681: LD_VAR 0 6
59685: PPUSH
59686: LD_EXP 156
59690: PUSH
59691: LD_VAR 0 6
59695: ARRAY
59696: PPUSH
59697: LD_VAR 0 5
59701: PPUSH
59702: CALL_OW 3
59706: PPUSH
59707: CALL_OW 1
59711: ST_TO_ADDR
// end ; end ;
59712: GO 59550
59714: POP
59715: POP
// end ;
59716: LD_VAR 0 4
59720: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
59721: LD_INT 0
59723: PPUSH
59724: PPUSH
59725: PPUSH
59726: PPUSH
59727: PPUSH
59728: PPUSH
59729: PPUSH
59730: PPUSH
59731: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
59732: LD_VAR 0 1
59736: PPUSH
59737: CALL_OW 264
59741: PUSH
59742: LD_EXP 82
59746: EQUAL
59747: NOT
59748: PUSH
59749: LD_VAR 0 1
59753: PUSH
59754: LD_EXP 155
59758: IN
59759: NOT
59760: OR
59761: IFFALSE 59765
// exit ;
59763: GO 60087
// index := GetElementIndex ( minersList , unit ) ;
59765: LD_ADDR_VAR 0 6
59769: PUSH
59770: LD_EXP 155
59774: PPUSH
59775: LD_VAR 0 1
59779: PPUSH
59780: CALL 65243 0 2
59784: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
59785: LD_ADDR_VAR 0 8
59789: PUSH
59790: LD_EXP 157
59794: PUSH
59795: LD_EXP 156
59799: PUSH
59800: LD_VAR 0 6
59804: ARRAY
59805: MINUS
59806: ST_TO_ADDR
// if not minesFreeAmount then
59807: LD_VAR 0 8
59811: NOT
59812: IFFALSE 59816
// exit ;
59814: GO 60087
// tmp := [ ] ;
59816: LD_ADDR_VAR 0 7
59820: PUSH
59821: EMPTY
59822: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
59823: LD_ADDR_VAR 0 5
59827: PUSH
59828: DOUBLE
59829: LD_INT 1
59831: DEC
59832: ST_TO_ADDR
59833: LD_VAR 0 8
59837: PUSH
59838: FOR_TO
59839: IFFALSE 60034
// begin _d := rand ( 0 , 5 ) ;
59841: LD_ADDR_VAR 0 11
59845: PUSH
59846: LD_INT 0
59848: PPUSH
59849: LD_INT 5
59851: PPUSH
59852: CALL_OW 12
59856: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
59857: LD_ADDR_VAR 0 12
59861: PUSH
59862: LD_INT 2
59864: PPUSH
59865: LD_INT 6
59867: PPUSH
59868: CALL_OW 12
59872: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
59873: LD_ADDR_VAR 0 9
59877: PUSH
59878: LD_VAR 0 2
59882: PPUSH
59883: LD_VAR 0 11
59887: PPUSH
59888: LD_VAR 0 12
59892: PPUSH
59893: CALL_OW 272
59897: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
59898: LD_ADDR_VAR 0 10
59902: PUSH
59903: LD_VAR 0 3
59907: PPUSH
59908: LD_VAR 0 11
59912: PPUSH
59913: LD_VAR 0 12
59917: PPUSH
59918: CALL_OW 273
59922: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
59923: LD_VAR 0 9
59927: PPUSH
59928: LD_VAR 0 10
59932: PPUSH
59933: CALL_OW 488
59937: PUSH
59938: LD_VAR 0 9
59942: PUSH
59943: LD_VAR 0 10
59947: PUSH
59948: EMPTY
59949: LIST
59950: LIST
59951: PUSH
59952: LD_VAR 0 7
59956: IN
59957: NOT
59958: AND
59959: PUSH
59960: LD_VAR 0 9
59964: PPUSH
59965: LD_VAR 0 10
59969: PPUSH
59970: CALL_OW 458
59974: NOT
59975: AND
59976: IFFALSE 60018
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
59978: LD_ADDR_VAR 0 7
59982: PUSH
59983: LD_VAR 0 7
59987: PPUSH
59988: LD_VAR 0 7
59992: PUSH
59993: LD_INT 1
59995: PLUS
59996: PPUSH
59997: LD_VAR 0 9
60001: PUSH
60002: LD_VAR 0 10
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PPUSH
60011: CALL_OW 1
60015: ST_TO_ADDR
60016: GO 60032
// i := i - 1 ;
60018: LD_ADDR_VAR 0 5
60022: PUSH
60023: LD_VAR 0 5
60027: PUSH
60028: LD_INT 1
60030: MINUS
60031: ST_TO_ADDR
// end ;
60032: GO 59838
60034: POP
60035: POP
// for i in tmp do
60036: LD_ADDR_VAR 0 5
60040: PUSH
60041: LD_VAR 0 7
60045: PUSH
60046: FOR_IN
60047: IFFALSE 60085
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
60049: LD_VAR 0 1
60053: PPUSH
60054: LD_VAR 0 5
60058: PUSH
60059: LD_INT 1
60061: ARRAY
60062: PPUSH
60063: LD_VAR 0 5
60067: PUSH
60068: LD_INT 2
60070: ARRAY
60071: PPUSH
60072: CALL 59027 0 3
60076: NOT
60077: IFFALSE 60083
// exit ;
60079: POP
60080: POP
60081: GO 60087
60083: GO 60046
60085: POP
60086: POP
// end ;
60087: LD_VAR 0 4
60091: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
60092: LD_INT 0
60094: PPUSH
60095: PPUSH
60096: PPUSH
60097: PPUSH
60098: PPUSH
60099: PPUSH
60100: PPUSH
// if not GetClass ( unit ) = class_sniper then
60101: LD_VAR 0 1
60105: PPUSH
60106: CALL_OW 257
60110: PUSH
60111: LD_INT 5
60113: EQUAL
60114: NOT
60115: IFFALSE 60119
// exit ;
60117: GO 60507
// dist := 8 ;
60119: LD_ADDR_VAR 0 5
60123: PUSH
60124: LD_INT 8
60126: ST_TO_ADDR
// viewRange := 12 ;
60127: LD_ADDR_VAR 0 7
60131: PUSH
60132: LD_INT 12
60134: ST_TO_ADDR
// side := GetSide ( unit ) ;
60135: LD_ADDR_VAR 0 6
60139: PUSH
60140: LD_VAR 0 1
60144: PPUSH
60145: CALL_OW 255
60149: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
60150: LD_INT 61
60152: PPUSH
60153: LD_VAR 0 6
60157: PPUSH
60158: CALL_OW 321
60162: PUSH
60163: LD_INT 2
60165: EQUAL
60166: IFFALSE 60176
// viewRange := 16 ;
60168: LD_ADDR_VAR 0 7
60172: PUSH
60173: LD_INT 16
60175: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
60176: LD_VAR 0 1
60180: PPUSH
60181: LD_VAR 0 2
60185: PPUSH
60186: LD_VAR 0 3
60190: PPUSH
60191: CALL_OW 297
60195: PUSH
60196: LD_VAR 0 5
60200: GREATER
60201: IFFALSE 60280
// begin ComMoveXY ( unit , x , y ) ;
60203: LD_VAR 0 1
60207: PPUSH
60208: LD_VAR 0 2
60212: PPUSH
60213: LD_VAR 0 3
60217: PPUSH
60218: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
60222: LD_INT 35
60224: PPUSH
60225: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
60229: LD_VAR 0 1
60233: PPUSH
60234: LD_VAR 0 2
60238: PPUSH
60239: LD_VAR 0 3
60243: PPUSH
60244: CALL 95640 0 3
60248: NOT
60249: IFFALSE 60253
// exit ;
60251: GO 60507
// until GetDistUnitXY ( unit , x , y ) < dist ;
60253: LD_VAR 0 1
60257: PPUSH
60258: LD_VAR 0 2
60262: PPUSH
60263: LD_VAR 0 3
60267: PPUSH
60268: CALL_OW 297
60272: PUSH
60273: LD_VAR 0 5
60277: LESS
60278: IFFALSE 60222
// end ; ComTurnXY ( unit , x , y ) ;
60280: LD_VAR 0 1
60284: PPUSH
60285: LD_VAR 0 2
60289: PPUSH
60290: LD_VAR 0 3
60294: PPUSH
60295: CALL_OW 118
// wait ( 5 ) ;
60299: LD_INT 5
60301: PPUSH
60302: CALL_OW 67
// _d := GetDir ( unit ) ;
60306: LD_ADDR_VAR 0 10
60310: PUSH
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 254
60320: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
60321: LD_ADDR_VAR 0 8
60325: PUSH
60326: LD_VAR 0 1
60330: PPUSH
60331: CALL_OW 250
60335: PPUSH
60336: LD_VAR 0 10
60340: PPUSH
60341: LD_VAR 0 5
60345: PPUSH
60346: CALL_OW 272
60350: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
60351: LD_ADDR_VAR 0 9
60355: PUSH
60356: LD_VAR 0 1
60360: PPUSH
60361: CALL_OW 251
60365: PPUSH
60366: LD_VAR 0 10
60370: PPUSH
60371: LD_VAR 0 5
60375: PPUSH
60376: CALL_OW 273
60380: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60381: LD_VAR 0 8
60385: PPUSH
60386: LD_VAR 0 9
60390: PPUSH
60391: CALL_OW 488
60395: NOT
60396: IFFALSE 60400
// exit ;
60398: GO 60507
// ComAnimCustom ( unit , 1 ) ;
60400: LD_VAR 0 1
60404: PPUSH
60405: LD_INT 1
60407: PPUSH
60408: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
60412: LD_VAR 0 8
60416: PPUSH
60417: LD_VAR 0 9
60421: PPUSH
60422: LD_VAR 0 6
60426: PPUSH
60427: LD_VAR 0 7
60431: PPUSH
60432: CALL_OW 330
// repeat wait ( 1 ) ;
60436: LD_INT 1
60438: PPUSH
60439: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
60443: LD_VAR 0 1
60447: PPUSH
60448: CALL_OW 316
60452: PUSH
60453: LD_VAR 0 1
60457: PPUSH
60458: CALL_OW 314
60462: OR
60463: PUSH
60464: LD_VAR 0 1
60468: PPUSH
60469: CALL_OW 302
60473: NOT
60474: OR
60475: PUSH
60476: LD_VAR 0 1
60480: PPUSH
60481: CALL_OW 301
60485: OR
60486: IFFALSE 60436
// RemoveSeeing ( _x , _y , side ) ;
60488: LD_VAR 0 8
60492: PPUSH
60493: LD_VAR 0 9
60497: PPUSH
60498: LD_VAR 0 6
60502: PPUSH
60503: CALL_OW 331
// end ; end_of_file
60507: LD_VAR 0 4
60511: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
60512: LD_INT 0
60514: PPUSH
60515: PPUSH
// if exist_mode then
60516: LD_VAR 0 2
60520: IFFALSE 60545
// unit := CreateCharacter ( prefix & ident ) else
60522: LD_ADDR_VAR 0 5
60526: PUSH
60527: LD_VAR 0 3
60531: PUSH
60532: LD_VAR 0 1
60536: STR
60537: PPUSH
60538: CALL_OW 34
60542: ST_TO_ADDR
60543: GO 60560
// unit := NewCharacter ( ident ) ;
60545: LD_ADDR_VAR 0 5
60549: PUSH
60550: LD_VAR 0 1
60554: PPUSH
60555: CALL_OW 25
60559: ST_TO_ADDR
// result := unit ;
60560: LD_ADDR_VAR 0 4
60564: PUSH
60565: LD_VAR 0 5
60569: ST_TO_ADDR
// end ;
60570: LD_VAR 0 4
60574: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
60575: LD_INT 0
60577: PPUSH
60578: PPUSH
// if not side or not nation then
60579: LD_VAR 0 1
60583: NOT
60584: PUSH
60585: LD_VAR 0 2
60589: NOT
60590: OR
60591: IFFALSE 60595
// exit ;
60593: GO 61359
// case nation of nation_american :
60595: LD_VAR 0 2
60599: PUSH
60600: LD_INT 1
60602: DOUBLE
60603: EQUAL
60604: IFTRUE 60608
60606: GO 60822
60608: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
60609: LD_ADDR_VAR 0 4
60613: PUSH
60614: LD_INT 35
60616: PUSH
60617: LD_INT 45
60619: PUSH
60620: LD_INT 46
60622: PUSH
60623: LD_INT 47
60625: PUSH
60626: LD_INT 82
60628: PUSH
60629: LD_INT 83
60631: PUSH
60632: LD_INT 84
60634: PUSH
60635: LD_INT 85
60637: PUSH
60638: LD_INT 86
60640: PUSH
60641: LD_INT 1
60643: PUSH
60644: LD_INT 2
60646: PUSH
60647: LD_INT 6
60649: PUSH
60650: LD_INT 15
60652: PUSH
60653: LD_INT 16
60655: PUSH
60656: LD_INT 7
60658: PUSH
60659: LD_INT 12
60661: PUSH
60662: LD_INT 13
60664: PUSH
60665: LD_INT 10
60667: PUSH
60668: LD_INT 14
60670: PUSH
60671: LD_INT 20
60673: PUSH
60674: LD_INT 21
60676: PUSH
60677: LD_INT 22
60679: PUSH
60680: LD_INT 25
60682: PUSH
60683: LD_INT 32
60685: PUSH
60686: LD_INT 27
60688: PUSH
60689: LD_INT 36
60691: PUSH
60692: LD_INT 69
60694: PUSH
60695: LD_INT 39
60697: PUSH
60698: LD_INT 34
60700: PUSH
60701: LD_INT 40
60703: PUSH
60704: LD_INT 48
60706: PUSH
60707: LD_INT 49
60709: PUSH
60710: LD_INT 50
60712: PUSH
60713: LD_INT 51
60715: PUSH
60716: LD_INT 52
60718: PUSH
60719: LD_INT 53
60721: PUSH
60722: LD_INT 54
60724: PUSH
60725: LD_INT 55
60727: PUSH
60728: LD_INT 56
60730: PUSH
60731: LD_INT 57
60733: PUSH
60734: LD_INT 58
60736: PUSH
60737: LD_INT 59
60739: PUSH
60740: LD_INT 60
60742: PUSH
60743: LD_INT 61
60745: PUSH
60746: LD_INT 62
60748: PUSH
60749: LD_INT 80
60751: PUSH
60752: LD_INT 82
60754: PUSH
60755: LD_INT 83
60757: PUSH
60758: LD_INT 84
60760: PUSH
60761: LD_INT 85
60763: PUSH
60764: LD_INT 86
60766: PUSH
60767: EMPTY
60768: LIST
60769: LIST
60770: LIST
60771: LIST
60772: LIST
60773: LIST
60774: LIST
60775: LIST
60776: LIST
60777: LIST
60778: LIST
60779: LIST
60780: LIST
60781: LIST
60782: LIST
60783: LIST
60784: LIST
60785: LIST
60786: LIST
60787: LIST
60788: LIST
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: LIST
60798: LIST
60799: LIST
60800: LIST
60801: LIST
60802: LIST
60803: LIST
60804: LIST
60805: LIST
60806: LIST
60807: LIST
60808: LIST
60809: LIST
60810: LIST
60811: LIST
60812: LIST
60813: LIST
60814: LIST
60815: LIST
60816: LIST
60817: LIST
60818: LIST
60819: ST_TO_ADDR
60820: GO 61283
60822: LD_INT 2
60824: DOUBLE
60825: EQUAL
60826: IFTRUE 60830
60828: GO 61052
60830: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
60831: LD_ADDR_VAR 0 4
60835: PUSH
60836: LD_INT 35
60838: PUSH
60839: LD_INT 45
60841: PUSH
60842: LD_INT 46
60844: PUSH
60845: LD_INT 47
60847: PUSH
60848: LD_INT 82
60850: PUSH
60851: LD_INT 83
60853: PUSH
60854: LD_INT 84
60856: PUSH
60857: LD_INT 85
60859: PUSH
60860: LD_INT 87
60862: PUSH
60863: LD_INT 70
60865: PUSH
60866: LD_INT 1
60868: PUSH
60869: LD_INT 11
60871: PUSH
60872: LD_INT 3
60874: PUSH
60875: LD_INT 4
60877: PUSH
60878: LD_INT 5
60880: PUSH
60881: LD_INT 6
60883: PUSH
60884: LD_INT 15
60886: PUSH
60887: LD_INT 18
60889: PUSH
60890: LD_INT 7
60892: PUSH
60893: LD_INT 17
60895: PUSH
60896: LD_INT 8
60898: PUSH
60899: LD_INT 20
60901: PUSH
60902: LD_INT 21
60904: PUSH
60905: LD_INT 22
60907: PUSH
60908: LD_INT 72
60910: PUSH
60911: LD_INT 26
60913: PUSH
60914: LD_INT 69
60916: PUSH
60917: LD_INT 39
60919: PUSH
60920: LD_INT 40
60922: PUSH
60923: LD_INT 41
60925: PUSH
60926: LD_INT 42
60928: PUSH
60929: LD_INT 43
60931: PUSH
60932: LD_INT 48
60934: PUSH
60935: LD_INT 49
60937: PUSH
60938: LD_INT 50
60940: PUSH
60941: LD_INT 51
60943: PUSH
60944: LD_INT 52
60946: PUSH
60947: LD_INT 53
60949: PUSH
60950: LD_INT 54
60952: PUSH
60953: LD_INT 55
60955: PUSH
60956: LD_INT 56
60958: PUSH
60959: LD_INT 60
60961: PUSH
60962: LD_INT 61
60964: PUSH
60965: LD_INT 62
60967: PUSH
60968: LD_INT 66
60970: PUSH
60971: LD_INT 67
60973: PUSH
60974: LD_INT 68
60976: PUSH
60977: LD_INT 81
60979: PUSH
60980: LD_INT 82
60982: PUSH
60983: LD_INT 83
60985: PUSH
60986: LD_INT 84
60988: PUSH
60989: LD_INT 85
60991: PUSH
60992: LD_INT 87
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: LIST
60999: LIST
61000: LIST
61001: LIST
61002: LIST
61003: LIST
61004: LIST
61005: LIST
61006: LIST
61007: LIST
61008: LIST
61009: LIST
61010: LIST
61011: LIST
61012: LIST
61013: LIST
61014: LIST
61015: LIST
61016: LIST
61017: LIST
61018: LIST
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: LIST
61037: LIST
61038: LIST
61039: LIST
61040: LIST
61041: LIST
61042: LIST
61043: LIST
61044: LIST
61045: LIST
61046: LIST
61047: LIST
61048: LIST
61049: ST_TO_ADDR
61050: GO 61283
61052: LD_INT 3
61054: DOUBLE
61055: EQUAL
61056: IFTRUE 61060
61058: GO 61282
61060: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
61061: LD_ADDR_VAR 0 4
61065: PUSH
61066: LD_INT 46
61068: PUSH
61069: LD_INT 47
61071: PUSH
61072: LD_INT 1
61074: PUSH
61075: LD_INT 2
61077: PUSH
61078: LD_INT 82
61080: PUSH
61081: LD_INT 83
61083: PUSH
61084: LD_INT 84
61086: PUSH
61087: LD_INT 85
61089: PUSH
61090: LD_INT 86
61092: PUSH
61093: LD_INT 11
61095: PUSH
61096: LD_INT 9
61098: PUSH
61099: LD_INT 20
61101: PUSH
61102: LD_INT 19
61104: PUSH
61105: LD_INT 21
61107: PUSH
61108: LD_INT 24
61110: PUSH
61111: LD_INT 22
61113: PUSH
61114: LD_INT 25
61116: PUSH
61117: LD_INT 28
61119: PUSH
61120: LD_INT 29
61122: PUSH
61123: LD_INT 30
61125: PUSH
61126: LD_INT 31
61128: PUSH
61129: LD_INT 37
61131: PUSH
61132: LD_INT 38
61134: PUSH
61135: LD_INT 32
61137: PUSH
61138: LD_INT 27
61140: PUSH
61141: LD_INT 33
61143: PUSH
61144: LD_INT 69
61146: PUSH
61147: LD_INT 39
61149: PUSH
61150: LD_INT 34
61152: PUSH
61153: LD_INT 40
61155: PUSH
61156: LD_INT 71
61158: PUSH
61159: LD_INT 23
61161: PUSH
61162: LD_INT 44
61164: PUSH
61165: LD_INT 48
61167: PUSH
61168: LD_INT 49
61170: PUSH
61171: LD_INT 50
61173: PUSH
61174: LD_INT 51
61176: PUSH
61177: LD_INT 52
61179: PUSH
61180: LD_INT 53
61182: PUSH
61183: LD_INT 54
61185: PUSH
61186: LD_INT 55
61188: PUSH
61189: LD_INT 56
61191: PUSH
61192: LD_INT 57
61194: PUSH
61195: LD_INT 58
61197: PUSH
61198: LD_INT 59
61200: PUSH
61201: LD_INT 63
61203: PUSH
61204: LD_INT 64
61206: PUSH
61207: LD_INT 65
61209: PUSH
61210: LD_INT 82
61212: PUSH
61213: LD_INT 83
61215: PUSH
61216: LD_INT 84
61218: PUSH
61219: LD_INT 85
61221: PUSH
61222: LD_INT 86
61224: PUSH
61225: EMPTY
61226: LIST
61227: LIST
61228: LIST
61229: LIST
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: LIST
61254: LIST
61255: LIST
61256: LIST
61257: LIST
61258: LIST
61259: LIST
61260: LIST
61261: LIST
61262: LIST
61263: LIST
61264: LIST
61265: LIST
61266: LIST
61267: LIST
61268: LIST
61269: LIST
61270: LIST
61271: LIST
61272: LIST
61273: LIST
61274: LIST
61275: LIST
61276: LIST
61277: LIST
61278: LIST
61279: ST_TO_ADDR
61280: GO 61283
61282: POP
// if state > - 1 and state < 3 then
61283: LD_VAR 0 3
61287: PUSH
61288: LD_INT 1
61290: NEG
61291: GREATER
61292: PUSH
61293: LD_VAR 0 3
61297: PUSH
61298: LD_INT 3
61300: LESS
61301: AND
61302: IFFALSE 61359
// for i in result do
61304: LD_ADDR_VAR 0 5
61308: PUSH
61309: LD_VAR 0 4
61313: PUSH
61314: FOR_IN
61315: IFFALSE 61357
// if GetTech ( i , side ) <> state then
61317: LD_VAR 0 5
61321: PPUSH
61322: LD_VAR 0 1
61326: PPUSH
61327: CALL_OW 321
61331: PUSH
61332: LD_VAR 0 3
61336: NONEQUAL
61337: IFFALSE 61355
// result := result diff i ;
61339: LD_ADDR_VAR 0 4
61343: PUSH
61344: LD_VAR 0 4
61348: PUSH
61349: LD_VAR 0 5
61353: DIFF
61354: ST_TO_ADDR
61355: GO 61314
61357: POP
61358: POP
// end ;
61359: LD_VAR 0 4
61363: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
61364: LD_INT 0
61366: PPUSH
61367: PPUSH
61368: PPUSH
// result := true ;
61369: LD_ADDR_VAR 0 3
61373: PUSH
61374: LD_INT 1
61376: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
61377: LD_ADDR_VAR 0 5
61381: PUSH
61382: LD_VAR 0 2
61386: PPUSH
61387: CALL_OW 480
61391: ST_TO_ADDR
// if not tmp then
61392: LD_VAR 0 5
61396: NOT
61397: IFFALSE 61401
// exit ;
61399: GO 61450
// for i in tmp do
61401: LD_ADDR_VAR 0 4
61405: PUSH
61406: LD_VAR 0 5
61410: PUSH
61411: FOR_IN
61412: IFFALSE 61448
// if GetTech ( i , side ) <> state_researched then
61414: LD_VAR 0 4
61418: PPUSH
61419: LD_VAR 0 1
61423: PPUSH
61424: CALL_OW 321
61428: PUSH
61429: LD_INT 2
61431: NONEQUAL
61432: IFFALSE 61446
// begin result := false ;
61434: LD_ADDR_VAR 0 3
61438: PUSH
61439: LD_INT 0
61441: ST_TO_ADDR
// exit ;
61442: POP
61443: POP
61444: GO 61450
// end ;
61446: GO 61411
61448: POP
61449: POP
// end ;
61450: LD_VAR 0 3
61454: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
61455: LD_INT 0
61457: PPUSH
61458: PPUSH
61459: PPUSH
61460: PPUSH
61461: PPUSH
61462: PPUSH
61463: PPUSH
61464: PPUSH
61465: PPUSH
61466: PPUSH
61467: PPUSH
61468: PPUSH
61469: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
61470: LD_VAR 0 1
61474: NOT
61475: PUSH
61476: LD_VAR 0 1
61480: PPUSH
61481: CALL_OW 257
61485: PUSH
61486: LD_INT 9
61488: NONEQUAL
61489: OR
61490: IFFALSE 61494
// exit ;
61492: GO 62067
// side := GetSide ( unit ) ;
61494: LD_ADDR_VAR 0 9
61498: PUSH
61499: LD_VAR 0 1
61503: PPUSH
61504: CALL_OW 255
61508: ST_TO_ADDR
// tech_space := tech_spacanom ;
61509: LD_ADDR_VAR 0 12
61513: PUSH
61514: LD_INT 29
61516: ST_TO_ADDR
// tech_time := tech_taurad ;
61517: LD_ADDR_VAR 0 13
61521: PUSH
61522: LD_INT 28
61524: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
61525: LD_ADDR_VAR 0 11
61529: PUSH
61530: LD_VAR 0 1
61534: PPUSH
61535: CALL_OW 310
61539: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
61540: LD_VAR 0 11
61544: PPUSH
61545: CALL_OW 247
61549: PUSH
61550: LD_INT 2
61552: EQUAL
61553: IFFALSE 61557
// exit ;
61555: GO 62067
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
61557: LD_ADDR_VAR 0 8
61561: PUSH
61562: LD_INT 81
61564: PUSH
61565: LD_VAR 0 9
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: PUSH
61574: LD_INT 3
61576: PUSH
61577: LD_INT 21
61579: PUSH
61580: LD_INT 3
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: PUSH
61587: EMPTY
61588: LIST
61589: LIST
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: PPUSH
61595: CALL_OW 69
61599: ST_TO_ADDR
// if not tmp then
61600: LD_VAR 0 8
61604: NOT
61605: IFFALSE 61609
// exit ;
61607: GO 62067
// if in_unit then
61609: LD_VAR 0 11
61613: IFFALSE 61637
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
61615: LD_ADDR_VAR 0 10
61619: PUSH
61620: LD_VAR 0 8
61624: PPUSH
61625: LD_VAR 0 11
61629: PPUSH
61630: CALL_OW 74
61634: ST_TO_ADDR
61635: GO 61657
// enemy := NearestUnitToUnit ( tmp , unit ) ;
61637: LD_ADDR_VAR 0 10
61641: PUSH
61642: LD_VAR 0 8
61646: PPUSH
61647: LD_VAR 0 1
61651: PPUSH
61652: CALL_OW 74
61656: ST_TO_ADDR
// if not enemy then
61657: LD_VAR 0 10
61661: NOT
61662: IFFALSE 61666
// exit ;
61664: GO 62067
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
61666: LD_VAR 0 11
61670: PUSH
61671: LD_VAR 0 11
61675: PPUSH
61676: LD_VAR 0 10
61680: PPUSH
61681: CALL_OW 296
61685: PUSH
61686: LD_INT 13
61688: GREATER
61689: AND
61690: PUSH
61691: LD_VAR 0 1
61695: PPUSH
61696: LD_VAR 0 10
61700: PPUSH
61701: CALL_OW 296
61705: PUSH
61706: LD_INT 12
61708: GREATER
61709: OR
61710: IFFALSE 61714
// exit ;
61712: GO 62067
// missile := [ 1 ] ;
61714: LD_ADDR_VAR 0 14
61718: PUSH
61719: LD_INT 1
61721: PUSH
61722: EMPTY
61723: LIST
61724: ST_TO_ADDR
// if Researched ( side , tech_space ) then
61725: LD_VAR 0 9
61729: PPUSH
61730: LD_VAR 0 12
61734: PPUSH
61735: CALL_OW 325
61739: IFFALSE 61768
// missile := Insert ( missile , missile + 1 , 2 ) ;
61741: LD_ADDR_VAR 0 14
61745: PUSH
61746: LD_VAR 0 14
61750: PPUSH
61751: LD_VAR 0 14
61755: PUSH
61756: LD_INT 1
61758: PLUS
61759: PPUSH
61760: LD_INT 2
61762: PPUSH
61763: CALL_OW 2
61767: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
61768: LD_VAR 0 9
61772: PPUSH
61773: LD_VAR 0 13
61777: PPUSH
61778: CALL_OW 325
61782: PUSH
61783: LD_VAR 0 10
61787: PPUSH
61788: CALL_OW 255
61792: PPUSH
61793: LD_VAR 0 13
61797: PPUSH
61798: CALL_OW 325
61802: NOT
61803: AND
61804: IFFALSE 61833
// missile := Insert ( missile , missile + 1 , 3 ) ;
61806: LD_ADDR_VAR 0 14
61810: PUSH
61811: LD_VAR 0 14
61815: PPUSH
61816: LD_VAR 0 14
61820: PUSH
61821: LD_INT 1
61823: PLUS
61824: PPUSH
61825: LD_INT 3
61827: PPUSH
61828: CALL_OW 2
61832: ST_TO_ADDR
// if missile < 2 then
61833: LD_VAR 0 14
61837: PUSH
61838: LD_INT 2
61840: LESS
61841: IFFALSE 61845
// exit ;
61843: GO 62067
// x := GetX ( enemy ) ;
61845: LD_ADDR_VAR 0 4
61849: PUSH
61850: LD_VAR 0 10
61854: PPUSH
61855: CALL_OW 250
61859: ST_TO_ADDR
// y := GetY ( enemy ) ;
61860: LD_ADDR_VAR 0 5
61864: PUSH
61865: LD_VAR 0 10
61869: PPUSH
61870: CALL_OW 251
61874: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
61875: LD_ADDR_VAR 0 6
61879: PUSH
61880: LD_VAR 0 4
61884: PUSH
61885: LD_INT 1
61887: NEG
61888: PPUSH
61889: LD_INT 1
61891: PPUSH
61892: CALL_OW 12
61896: PLUS
61897: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
61898: LD_ADDR_VAR 0 7
61902: PUSH
61903: LD_VAR 0 5
61907: PUSH
61908: LD_INT 1
61910: NEG
61911: PPUSH
61912: LD_INT 1
61914: PPUSH
61915: CALL_OW 12
61919: PLUS
61920: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
61921: LD_VAR 0 6
61925: PPUSH
61926: LD_VAR 0 7
61930: PPUSH
61931: CALL_OW 488
61935: NOT
61936: IFFALSE 61958
// begin _x := x ;
61938: LD_ADDR_VAR 0 6
61942: PUSH
61943: LD_VAR 0 4
61947: ST_TO_ADDR
// _y := y ;
61948: LD_ADDR_VAR 0 7
61952: PUSH
61953: LD_VAR 0 5
61957: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
61958: LD_ADDR_VAR 0 3
61962: PUSH
61963: LD_INT 1
61965: PPUSH
61966: LD_VAR 0 14
61970: PPUSH
61971: CALL_OW 12
61975: ST_TO_ADDR
// case i of 1 :
61976: LD_VAR 0 3
61980: PUSH
61981: LD_INT 1
61983: DOUBLE
61984: EQUAL
61985: IFTRUE 61989
61987: GO 62006
61989: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
61990: LD_VAR 0 1
61994: PPUSH
61995: LD_VAR 0 10
61999: PPUSH
62000: CALL_OW 115
62004: GO 62067
62006: LD_INT 2
62008: DOUBLE
62009: EQUAL
62010: IFTRUE 62014
62012: GO 62036
62014: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
62015: LD_VAR 0 1
62019: PPUSH
62020: LD_VAR 0 6
62024: PPUSH
62025: LD_VAR 0 7
62029: PPUSH
62030: CALL_OW 153
62034: GO 62067
62036: LD_INT 3
62038: DOUBLE
62039: EQUAL
62040: IFTRUE 62044
62042: GO 62066
62044: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
62045: LD_VAR 0 1
62049: PPUSH
62050: LD_VAR 0 6
62054: PPUSH
62055: LD_VAR 0 7
62059: PPUSH
62060: CALL_OW 154
62064: GO 62067
62066: POP
// end ;
62067: LD_VAR 0 2
62071: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
62072: LD_INT 0
62074: PPUSH
62075: PPUSH
62076: PPUSH
62077: PPUSH
62078: PPUSH
62079: PPUSH
// if not unit or not building then
62080: LD_VAR 0 1
62084: NOT
62085: PUSH
62086: LD_VAR 0 2
62090: NOT
62091: OR
62092: IFFALSE 62096
// exit ;
62094: GO 62254
// x := GetX ( building ) ;
62096: LD_ADDR_VAR 0 5
62100: PUSH
62101: LD_VAR 0 2
62105: PPUSH
62106: CALL_OW 250
62110: ST_TO_ADDR
// y := GetY ( building ) ;
62111: LD_ADDR_VAR 0 6
62115: PUSH
62116: LD_VAR 0 2
62120: PPUSH
62121: CALL_OW 251
62125: ST_TO_ADDR
// for i = 0 to 5 do
62126: LD_ADDR_VAR 0 4
62130: PUSH
62131: DOUBLE
62132: LD_INT 0
62134: DEC
62135: ST_TO_ADDR
62136: LD_INT 5
62138: PUSH
62139: FOR_TO
62140: IFFALSE 62252
// begin _x := ShiftX ( x , i , 3 ) ;
62142: LD_ADDR_VAR 0 7
62146: PUSH
62147: LD_VAR 0 5
62151: PPUSH
62152: LD_VAR 0 4
62156: PPUSH
62157: LD_INT 3
62159: PPUSH
62160: CALL_OW 272
62164: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
62165: LD_ADDR_VAR 0 8
62169: PUSH
62170: LD_VAR 0 6
62174: PPUSH
62175: LD_VAR 0 4
62179: PPUSH
62180: LD_INT 3
62182: PPUSH
62183: CALL_OW 273
62187: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
62188: LD_VAR 0 7
62192: PPUSH
62193: LD_VAR 0 8
62197: PPUSH
62198: CALL_OW 488
62202: NOT
62203: IFFALSE 62207
// continue ;
62205: GO 62139
// if HexInfo ( _x , _y ) = 0 then
62207: LD_VAR 0 7
62211: PPUSH
62212: LD_VAR 0 8
62216: PPUSH
62217: CALL_OW 428
62221: PUSH
62222: LD_INT 0
62224: EQUAL
62225: IFFALSE 62250
// begin ComMoveXY ( unit , _x , _y ) ;
62227: LD_VAR 0 1
62231: PPUSH
62232: LD_VAR 0 7
62236: PPUSH
62237: LD_VAR 0 8
62241: PPUSH
62242: CALL_OW 111
// exit ;
62246: POP
62247: POP
62248: GO 62254
// end ; end ;
62250: GO 62139
62252: POP
62253: POP
// end ;
62254: LD_VAR 0 3
62258: RET
// export function ScanBase ( side , base_area ) ; begin
62259: LD_INT 0
62261: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
62262: LD_ADDR_VAR 0 3
62266: PUSH
62267: LD_VAR 0 2
62271: PPUSH
62272: LD_INT 81
62274: PUSH
62275: LD_VAR 0 1
62279: PUSH
62280: EMPTY
62281: LIST
62282: LIST
62283: PPUSH
62284: CALL_OW 70
62288: ST_TO_ADDR
// end ;
62289: LD_VAR 0 3
62293: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
62294: LD_INT 0
62296: PPUSH
62297: PPUSH
62298: PPUSH
62299: PPUSH
// result := false ;
62300: LD_ADDR_VAR 0 2
62304: PUSH
62305: LD_INT 0
62307: ST_TO_ADDR
// side := GetSide ( unit ) ;
62308: LD_ADDR_VAR 0 3
62312: PUSH
62313: LD_VAR 0 1
62317: PPUSH
62318: CALL_OW 255
62322: ST_TO_ADDR
// nat := GetNation ( unit ) ;
62323: LD_ADDR_VAR 0 4
62327: PUSH
62328: LD_VAR 0 1
62332: PPUSH
62333: CALL_OW 248
62337: ST_TO_ADDR
// case nat of 1 :
62338: LD_VAR 0 4
62342: PUSH
62343: LD_INT 1
62345: DOUBLE
62346: EQUAL
62347: IFTRUE 62351
62349: GO 62362
62351: POP
// tech := tech_lassight ; 2 :
62352: LD_ADDR_VAR 0 5
62356: PUSH
62357: LD_INT 12
62359: ST_TO_ADDR
62360: GO 62401
62362: LD_INT 2
62364: DOUBLE
62365: EQUAL
62366: IFTRUE 62370
62368: GO 62381
62370: POP
// tech := tech_mortar ; 3 :
62371: LD_ADDR_VAR 0 5
62375: PUSH
62376: LD_INT 41
62378: ST_TO_ADDR
62379: GO 62401
62381: LD_INT 3
62383: DOUBLE
62384: EQUAL
62385: IFTRUE 62389
62387: GO 62400
62389: POP
// tech := tech_bazooka ; end ;
62390: LD_ADDR_VAR 0 5
62394: PUSH
62395: LD_INT 44
62397: ST_TO_ADDR
62398: GO 62401
62400: POP
// if Researched ( side , tech ) then
62401: LD_VAR 0 3
62405: PPUSH
62406: LD_VAR 0 5
62410: PPUSH
62411: CALL_OW 325
62415: IFFALSE 62442
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
62417: LD_ADDR_VAR 0 2
62421: PUSH
62422: LD_INT 5
62424: PUSH
62425: LD_INT 8
62427: PUSH
62428: LD_INT 9
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: LIST
62435: PUSH
62436: LD_VAR 0 4
62440: ARRAY
62441: ST_TO_ADDR
// end ;
62442: LD_VAR 0 2
62446: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
62447: LD_INT 0
62449: PPUSH
62450: PPUSH
62451: PPUSH
// if not mines then
62452: LD_VAR 0 2
62456: NOT
62457: IFFALSE 62461
// exit ;
62459: GO 62605
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
62461: LD_ADDR_VAR 0 5
62465: PUSH
62466: LD_INT 81
62468: PUSH
62469: LD_VAR 0 1
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 3
62480: PUSH
62481: LD_INT 21
62483: PUSH
62484: LD_INT 3
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: EMPTY
62492: LIST
62493: LIST
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: PPUSH
62499: CALL_OW 69
62503: ST_TO_ADDR
// for i in mines do
62504: LD_ADDR_VAR 0 4
62508: PUSH
62509: LD_VAR 0 2
62513: PUSH
62514: FOR_IN
62515: IFFALSE 62603
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
62517: LD_VAR 0 4
62521: PUSH
62522: LD_INT 1
62524: ARRAY
62525: PPUSH
62526: LD_VAR 0 4
62530: PUSH
62531: LD_INT 2
62533: ARRAY
62534: PPUSH
62535: CALL_OW 458
62539: NOT
62540: IFFALSE 62544
// continue ;
62542: GO 62514
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
62544: LD_VAR 0 4
62548: PUSH
62549: LD_INT 1
62551: ARRAY
62552: PPUSH
62553: LD_VAR 0 4
62557: PUSH
62558: LD_INT 2
62560: ARRAY
62561: PPUSH
62562: CALL_OW 428
62566: PUSH
62567: LD_VAR 0 5
62571: IN
62572: IFFALSE 62601
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
62574: LD_VAR 0 4
62578: PUSH
62579: LD_INT 1
62581: ARRAY
62582: PPUSH
62583: LD_VAR 0 4
62587: PUSH
62588: LD_INT 2
62590: ARRAY
62591: PPUSH
62592: LD_VAR 0 1
62596: PPUSH
62597: CALL_OW 456
// end ;
62601: GO 62514
62603: POP
62604: POP
// end ;
62605: LD_VAR 0 3
62609: RET
// export function Count ( array ) ; var i ; begin
62610: LD_INT 0
62612: PPUSH
62613: PPUSH
// result := 0 ;
62614: LD_ADDR_VAR 0 2
62618: PUSH
62619: LD_INT 0
62621: ST_TO_ADDR
// for i in array do
62622: LD_ADDR_VAR 0 3
62626: PUSH
62627: LD_VAR 0 1
62631: PUSH
62632: FOR_IN
62633: IFFALSE 62657
// if i then
62635: LD_VAR 0 3
62639: IFFALSE 62655
// result := result + 1 ;
62641: LD_ADDR_VAR 0 2
62645: PUSH
62646: LD_VAR 0 2
62650: PUSH
62651: LD_INT 1
62653: PLUS
62654: ST_TO_ADDR
62655: GO 62632
62657: POP
62658: POP
// end ;
62659: LD_VAR 0 2
62663: RET
// export function IsEmpty ( building ) ; begin
62664: LD_INT 0
62666: PPUSH
// if not building then
62667: LD_VAR 0 1
62671: NOT
62672: IFFALSE 62676
// exit ;
62674: GO 62719
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
62676: LD_ADDR_VAR 0 2
62680: PUSH
62681: LD_VAR 0 1
62685: PUSH
62686: LD_INT 22
62688: PUSH
62689: LD_VAR 0 1
62693: PPUSH
62694: CALL_OW 255
62698: PUSH
62699: EMPTY
62700: LIST
62701: LIST
62702: PUSH
62703: LD_INT 58
62705: PUSH
62706: EMPTY
62707: LIST
62708: PUSH
62709: EMPTY
62710: LIST
62711: LIST
62712: PPUSH
62713: CALL_OW 69
62717: IN
62718: ST_TO_ADDR
// end ;
62719: LD_VAR 0 2
62723: RET
// export function IsNotFull ( building ) ; begin
62724: LD_INT 0
62726: PPUSH
// if not building then
62727: LD_VAR 0 1
62731: NOT
62732: IFFALSE 62736
// exit ;
62734: GO 62755
// result := UnitsInside ( building ) < 6 ;
62736: LD_ADDR_VAR 0 2
62740: PUSH
62741: LD_VAR 0 1
62745: PPUSH
62746: CALL_OW 313
62750: PUSH
62751: LD_INT 6
62753: LESS
62754: ST_TO_ADDR
// end ;
62755: LD_VAR 0 2
62759: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
62760: LD_INT 0
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
// tmp := [ ] ;
62766: LD_ADDR_VAR 0 3
62770: PUSH
62771: EMPTY
62772: ST_TO_ADDR
// list := [ ] ;
62773: LD_ADDR_VAR 0 5
62777: PUSH
62778: EMPTY
62779: ST_TO_ADDR
// for i = 16 to 25 do
62780: LD_ADDR_VAR 0 4
62784: PUSH
62785: DOUBLE
62786: LD_INT 16
62788: DEC
62789: ST_TO_ADDR
62790: LD_INT 25
62792: PUSH
62793: FOR_TO
62794: IFFALSE 62867
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
62796: LD_ADDR_VAR 0 3
62800: PUSH
62801: LD_VAR 0 3
62805: PUSH
62806: LD_INT 22
62808: PUSH
62809: LD_VAR 0 1
62813: PPUSH
62814: CALL_OW 255
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: LD_INT 91
62825: PUSH
62826: LD_VAR 0 1
62830: PUSH
62831: LD_INT 6
62833: PUSH
62834: EMPTY
62835: LIST
62836: LIST
62837: LIST
62838: PUSH
62839: LD_INT 30
62841: PUSH
62842: LD_VAR 0 4
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PUSH
62851: EMPTY
62852: LIST
62853: LIST
62854: LIST
62855: PUSH
62856: EMPTY
62857: LIST
62858: PPUSH
62859: CALL_OW 69
62863: ADD
62864: ST_TO_ADDR
62865: GO 62793
62867: POP
62868: POP
// for i = 1 to tmp do
62869: LD_ADDR_VAR 0 4
62873: PUSH
62874: DOUBLE
62875: LD_INT 1
62877: DEC
62878: ST_TO_ADDR
62879: LD_VAR 0 3
62883: PUSH
62884: FOR_TO
62885: IFFALSE 62973
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
62887: LD_ADDR_VAR 0 5
62891: PUSH
62892: LD_VAR 0 5
62896: PUSH
62897: LD_VAR 0 3
62901: PUSH
62902: LD_VAR 0 4
62906: ARRAY
62907: PPUSH
62908: CALL_OW 266
62912: PUSH
62913: LD_VAR 0 3
62917: PUSH
62918: LD_VAR 0 4
62922: ARRAY
62923: PPUSH
62924: CALL_OW 250
62928: PUSH
62929: LD_VAR 0 3
62933: PUSH
62934: LD_VAR 0 4
62938: ARRAY
62939: PPUSH
62940: CALL_OW 251
62944: PUSH
62945: LD_VAR 0 3
62949: PUSH
62950: LD_VAR 0 4
62954: ARRAY
62955: PPUSH
62956: CALL_OW 254
62960: PUSH
62961: EMPTY
62962: LIST
62963: LIST
62964: LIST
62965: LIST
62966: PUSH
62967: EMPTY
62968: LIST
62969: ADD
62970: ST_TO_ADDR
62971: GO 62884
62973: POP
62974: POP
// result := list ;
62975: LD_ADDR_VAR 0 2
62979: PUSH
62980: LD_VAR 0 5
62984: ST_TO_ADDR
// end ;
62985: LD_VAR 0 2
62989: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
62990: LD_INT 0
62992: PPUSH
62993: PPUSH
62994: PPUSH
62995: PPUSH
62996: PPUSH
62997: PPUSH
62998: PPUSH
// if not factory then
62999: LD_VAR 0 1
63003: NOT
63004: IFFALSE 63008
// exit ;
63006: GO 63601
// if control = control_apeman then
63008: LD_VAR 0 4
63012: PUSH
63013: LD_INT 5
63015: EQUAL
63016: IFFALSE 63125
// begin tmp := UnitsInside ( factory ) ;
63018: LD_ADDR_VAR 0 8
63022: PUSH
63023: LD_VAR 0 1
63027: PPUSH
63028: CALL_OW 313
63032: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63033: LD_VAR 0 8
63037: PPUSH
63038: LD_INT 25
63040: PUSH
63041: LD_INT 12
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: PPUSH
63048: CALL_OW 72
63052: NOT
63053: IFFALSE 63063
// control := control_manual ;
63055: LD_ADDR_VAR 0 4
63059: PUSH
63060: LD_INT 1
63062: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63063: LD_ADDR_VAR 0 8
63067: PUSH
63068: LD_VAR 0 1
63072: PPUSH
63073: CALL 62760 0 1
63077: ST_TO_ADDR
// if tmp then
63078: LD_VAR 0 8
63082: IFFALSE 63125
// begin for i in tmp do
63084: LD_ADDR_VAR 0 7
63088: PUSH
63089: LD_VAR 0 8
63093: PUSH
63094: FOR_IN
63095: IFFALSE 63123
// if i [ 1 ] = b_ext_radio then
63097: LD_VAR 0 7
63101: PUSH
63102: LD_INT 1
63104: ARRAY
63105: PUSH
63106: LD_INT 22
63108: EQUAL
63109: IFFALSE 63121
// begin control := control_remote ;
63111: LD_ADDR_VAR 0 4
63115: PUSH
63116: LD_INT 2
63118: ST_TO_ADDR
// break ;
63119: GO 63123
// end ;
63121: GO 63094
63123: POP
63124: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63125: LD_VAR 0 1
63129: PPUSH
63130: LD_VAR 0 2
63134: PPUSH
63135: LD_VAR 0 3
63139: PPUSH
63140: LD_VAR 0 4
63144: PPUSH
63145: LD_VAR 0 5
63149: PPUSH
63150: CALL_OW 448
63154: IFFALSE 63189
// begin result := [ chassis , engine , control , weapon ] ;
63156: LD_ADDR_VAR 0 6
63160: PUSH
63161: LD_VAR 0 2
63165: PUSH
63166: LD_VAR 0 3
63170: PUSH
63171: LD_VAR 0 4
63175: PUSH
63176: LD_VAR 0 5
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: LIST
63185: LIST
63186: ST_TO_ADDR
// exit ;
63187: GO 63601
// end ; _chassis := AvailableChassisList ( factory ) ;
63189: LD_ADDR_VAR 0 9
63193: PUSH
63194: LD_VAR 0 1
63198: PPUSH
63199: CALL_OW 475
63203: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
63204: LD_ADDR_VAR 0 11
63208: PUSH
63209: LD_VAR 0 1
63213: PPUSH
63214: CALL_OW 476
63218: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
63219: LD_ADDR_VAR 0 12
63223: PUSH
63224: LD_VAR 0 1
63228: PPUSH
63229: CALL_OW 477
63233: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
63234: LD_ADDR_VAR 0 10
63238: PUSH
63239: LD_VAR 0 1
63243: PPUSH
63244: CALL_OW 478
63248: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
63249: LD_VAR 0 9
63253: NOT
63254: PUSH
63255: LD_VAR 0 11
63259: NOT
63260: OR
63261: PUSH
63262: LD_VAR 0 12
63266: NOT
63267: OR
63268: PUSH
63269: LD_VAR 0 10
63273: NOT
63274: OR
63275: IFFALSE 63310
// begin result := [ chassis , engine , control , weapon ] ;
63277: LD_ADDR_VAR 0 6
63281: PUSH
63282: LD_VAR 0 2
63286: PUSH
63287: LD_VAR 0 3
63291: PUSH
63292: LD_VAR 0 4
63296: PUSH
63297: LD_VAR 0 5
63301: PUSH
63302: EMPTY
63303: LIST
63304: LIST
63305: LIST
63306: LIST
63307: ST_TO_ADDR
// exit ;
63308: GO 63601
// end ; if not chassis in _chassis then
63310: LD_VAR 0 2
63314: PUSH
63315: LD_VAR 0 9
63319: IN
63320: NOT
63321: IFFALSE 63347
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
63323: LD_ADDR_VAR 0 2
63327: PUSH
63328: LD_VAR 0 9
63332: PUSH
63333: LD_INT 1
63335: PPUSH
63336: LD_VAR 0 9
63340: PPUSH
63341: CALL_OW 12
63345: ARRAY
63346: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
63347: LD_VAR 0 2
63351: PPUSH
63352: LD_VAR 0 3
63356: PPUSH
63357: CALL 63606 0 2
63361: NOT
63362: IFFALSE 63421
// repeat engine := _engine [ 1 ] ;
63364: LD_ADDR_VAR 0 3
63368: PUSH
63369: LD_VAR 0 11
63373: PUSH
63374: LD_INT 1
63376: ARRAY
63377: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
63378: LD_ADDR_VAR 0 11
63382: PUSH
63383: LD_VAR 0 11
63387: PPUSH
63388: LD_INT 1
63390: PPUSH
63391: CALL_OW 3
63395: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
63396: LD_VAR 0 2
63400: PPUSH
63401: LD_VAR 0 3
63405: PPUSH
63406: CALL 63606 0 2
63410: PUSH
63411: LD_VAR 0 11
63415: PUSH
63416: EMPTY
63417: EQUAL
63418: OR
63419: IFFALSE 63364
// if not control in _control then
63421: LD_VAR 0 4
63425: PUSH
63426: LD_VAR 0 12
63430: IN
63431: NOT
63432: IFFALSE 63458
// control := _control [ rand ( 1 , _control ) ] ;
63434: LD_ADDR_VAR 0 4
63438: PUSH
63439: LD_VAR 0 12
63443: PUSH
63444: LD_INT 1
63446: PPUSH
63447: LD_VAR 0 12
63451: PPUSH
63452: CALL_OW 12
63456: ARRAY
63457: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
63458: LD_VAR 0 2
63462: PPUSH
63463: LD_VAR 0 5
63467: PPUSH
63468: CALL 63826 0 2
63472: NOT
63473: IFFALSE 63532
// repeat weapon := _weapon [ 1 ] ;
63475: LD_ADDR_VAR 0 5
63479: PUSH
63480: LD_VAR 0 10
63484: PUSH
63485: LD_INT 1
63487: ARRAY
63488: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
63489: LD_ADDR_VAR 0 10
63493: PUSH
63494: LD_VAR 0 10
63498: PPUSH
63499: LD_INT 1
63501: PPUSH
63502: CALL_OW 3
63506: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
63507: LD_VAR 0 2
63511: PPUSH
63512: LD_VAR 0 5
63516: PPUSH
63517: CALL 63826 0 2
63521: PUSH
63522: LD_VAR 0 10
63526: PUSH
63527: EMPTY
63528: EQUAL
63529: OR
63530: IFFALSE 63475
// result := [ ] ;
63532: LD_ADDR_VAR 0 6
63536: PUSH
63537: EMPTY
63538: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63539: LD_VAR 0 1
63543: PPUSH
63544: LD_VAR 0 2
63548: PPUSH
63549: LD_VAR 0 3
63553: PPUSH
63554: LD_VAR 0 4
63558: PPUSH
63559: LD_VAR 0 5
63563: PPUSH
63564: CALL_OW 448
63568: IFFALSE 63601
// result := [ chassis , engine , control , weapon ] ;
63570: LD_ADDR_VAR 0 6
63574: PUSH
63575: LD_VAR 0 2
63579: PUSH
63580: LD_VAR 0 3
63584: PUSH
63585: LD_VAR 0 4
63589: PUSH
63590: LD_VAR 0 5
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: LIST
63599: LIST
63600: ST_TO_ADDR
// end ;
63601: LD_VAR 0 6
63605: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
63606: LD_INT 0
63608: PPUSH
// if not chassis or not engine then
63609: LD_VAR 0 1
63613: NOT
63614: PUSH
63615: LD_VAR 0 2
63619: NOT
63620: OR
63621: IFFALSE 63625
// exit ;
63623: GO 63821
// case engine of engine_solar :
63625: LD_VAR 0 2
63629: PUSH
63630: LD_INT 2
63632: DOUBLE
63633: EQUAL
63634: IFTRUE 63638
63636: GO 63676
63638: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
63639: LD_ADDR_VAR 0 3
63643: PUSH
63644: LD_INT 11
63646: PUSH
63647: LD_INT 12
63649: PUSH
63650: LD_INT 13
63652: PUSH
63653: LD_INT 14
63655: PUSH
63656: LD_INT 1
63658: PUSH
63659: LD_INT 2
63661: PUSH
63662: LD_INT 3
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: LIST
63672: LIST
63673: ST_TO_ADDR
63674: GO 63805
63676: LD_INT 1
63678: DOUBLE
63679: EQUAL
63680: IFTRUE 63684
63682: GO 63746
63684: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
63685: LD_ADDR_VAR 0 3
63689: PUSH
63690: LD_INT 11
63692: PUSH
63693: LD_INT 12
63695: PUSH
63696: LD_INT 13
63698: PUSH
63699: LD_INT 14
63701: PUSH
63702: LD_INT 1
63704: PUSH
63705: LD_INT 2
63707: PUSH
63708: LD_INT 3
63710: PUSH
63711: LD_INT 4
63713: PUSH
63714: LD_INT 5
63716: PUSH
63717: LD_INT 21
63719: PUSH
63720: LD_INT 23
63722: PUSH
63723: LD_INT 22
63725: PUSH
63726: LD_INT 24
63728: PUSH
63729: EMPTY
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: ST_TO_ADDR
63744: GO 63805
63746: LD_INT 3
63748: DOUBLE
63749: EQUAL
63750: IFTRUE 63754
63752: GO 63804
63754: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
63755: LD_ADDR_VAR 0 3
63759: PUSH
63760: LD_INT 13
63762: PUSH
63763: LD_INT 14
63765: PUSH
63766: LD_INT 2
63768: PUSH
63769: LD_INT 3
63771: PUSH
63772: LD_INT 4
63774: PUSH
63775: LD_INT 5
63777: PUSH
63778: LD_INT 21
63780: PUSH
63781: LD_INT 22
63783: PUSH
63784: LD_INT 23
63786: PUSH
63787: LD_INT 24
63789: PUSH
63790: EMPTY
63791: LIST
63792: LIST
63793: LIST
63794: LIST
63795: LIST
63796: LIST
63797: LIST
63798: LIST
63799: LIST
63800: LIST
63801: ST_TO_ADDR
63802: GO 63805
63804: POP
// result := ( chassis in result ) ;
63805: LD_ADDR_VAR 0 3
63809: PUSH
63810: LD_VAR 0 1
63814: PUSH
63815: LD_VAR 0 3
63819: IN
63820: ST_TO_ADDR
// end ;
63821: LD_VAR 0 3
63825: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
63826: LD_INT 0
63828: PPUSH
// if not chassis or not weapon then
63829: LD_VAR 0 1
63833: NOT
63834: PUSH
63835: LD_VAR 0 2
63839: NOT
63840: OR
63841: IFFALSE 63845
// exit ;
63843: GO 64871
// case weapon of us_machine_gun :
63845: LD_VAR 0 2
63849: PUSH
63850: LD_INT 2
63852: DOUBLE
63853: EQUAL
63854: IFTRUE 63858
63856: GO 63888
63858: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
63859: LD_ADDR_VAR 0 3
63863: PUSH
63864: LD_INT 1
63866: PUSH
63867: LD_INT 2
63869: PUSH
63870: LD_INT 3
63872: PUSH
63873: LD_INT 4
63875: PUSH
63876: LD_INT 5
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: LIST
63883: LIST
63884: LIST
63885: ST_TO_ADDR
63886: GO 64855
63888: LD_INT 3
63890: DOUBLE
63891: EQUAL
63892: IFTRUE 63896
63894: GO 63926
63896: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
63897: LD_ADDR_VAR 0 3
63901: PUSH
63902: LD_INT 1
63904: PUSH
63905: LD_INT 2
63907: PUSH
63908: LD_INT 3
63910: PUSH
63911: LD_INT 4
63913: PUSH
63914: LD_INT 5
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: ST_TO_ADDR
63924: GO 64855
63926: LD_INT 11
63928: DOUBLE
63929: EQUAL
63930: IFTRUE 63934
63932: GO 63964
63934: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
63935: LD_ADDR_VAR 0 3
63939: PUSH
63940: LD_INT 1
63942: PUSH
63943: LD_INT 2
63945: PUSH
63946: LD_INT 3
63948: PUSH
63949: LD_INT 4
63951: PUSH
63952: LD_INT 5
63954: PUSH
63955: EMPTY
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: LIST
63961: ST_TO_ADDR
63962: GO 64855
63964: LD_INT 4
63966: DOUBLE
63967: EQUAL
63968: IFTRUE 63972
63970: GO 63998
63972: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
63973: LD_ADDR_VAR 0 3
63977: PUSH
63978: LD_INT 2
63980: PUSH
63981: LD_INT 3
63983: PUSH
63984: LD_INT 4
63986: PUSH
63987: LD_INT 5
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: ST_TO_ADDR
63996: GO 64855
63998: LD_INT 5
64000: DOUBLE
64001: EQUAL
64002: IFTRUE 64006
64004: GO 64032
64006: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
64007: LD_ADDR_VAR 0 3
64011: PUSH
64012: LD_INT 2
64014: PUSH
64015: LD_INT 3
64017: PUSH
64018: LD_INT 4
64020: PUSH
64021: LD_INT 5
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: LIST
64028: LIST
64029: ST_TO_ADDR
64030: GO 64855
64032: LD_INT 9
64034: DOUBLE
64035: EQUAL
64036: IFTRUE 64040
64038: GO 64066
64040: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64041: LD_ADDR_VAR 0 3
64045: PUSH
64046: LD_INT 2
64048: PUSH
64049: LD_INT 3
64051: PUSH
64052: LD_INT 4
64054: PUSH
64055: LD_INT 5
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: ST_TO_ADDR
64064: GO 64855
64066: LD_INT 7
64068: DOUBLE
64069: EQUAL
64070: IFTRUE 64074
64072: GO 64100
64074: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64075: LD_ADDR_VAR 0 3
64079: PUSH
64080: LD_INT 2
64082: PUSH
64083: LD_INT 3
64085: PUSH
64086: LD_INT 4
64088: PUSH
64089: LD_INT 5
64091: PUSH
64092: EMPTY
64093: LIST
64094: LIST
64095: LIST
64096: LIST
64097: ST_TO_ADDR
64098: GO 64855
64100: LD_INT 12
64102: DOUBLE
64103: EQUAL
64104: IFTRUE 64108
64106: GO 64134
64108: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64109: LD_ADDR_VAR 0 3
64113: PUSH
64114: LD_INT 2
64116: PUSH
64117: LD_INT 3
64119: PUSH
64120: LD_INT 4
64122: PUSH
64123: LD_INT 5
64125: PUSH
64126: EMPTY
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: ST_TO_ADDR
64132: GO 64855
64134: LD_INT 13
64136: DOUBLE
64137: EQUAL
64138: IFTRUE 64142
64140: GO 64168
64142: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64143: LD_ADDR_VAR 0 3
64147: PUSH
64148: LD_INT 2
64150: PUSH
64151: LD_INT 3
64153: PUSH
64154: LD_INT 4
64156: PUSH
64157: LD_INT 5
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: ST_TO_ADDR
64166: GO 64855
64168: LD_INT 14
64170: DOUBLE
64171: EQUAL
64172: IFTRUE 64176
64174: GO 64194
64176: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64177: LD_ADDR_VAR 0 3
64181: PUSH
64182: LD_INT 4
64184: PUSH
64185: LD_INT 5
64187: PUSH
64188: EMPTY
64189: LIST
64190: LIST
64191: ST_TO_ADDR
64192: GO 64855
64194: LD_INT 6
64196: DOUBLE
64197: EQUAL
64198: IFTRUE 64202
64200: GO 64220
64202: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64203: LD_ADDR_VAR 0 3
64207: PUSH
64208: LD_INT 4
64210: PUSH
64211: LD_INT 5
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: ST_TO_ADDR
64218: GO 64855
64220: LD_INT 10
64222: DOUBLE
64223: EQUAL
64224: IFTRUE 64228
64226: GO 64246
64228: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64229: LD_ADDR_VAR 0 3
64233: PUSH
64234: LD_INT 4
64236: PUSH
64237: LD_INT 5
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: ST_TO_ADDR
64244: GO 64855
64246: LD_INT 22
64248: DOUBLE
64249: EQUAL
64250: IFTRUE 64254
64252: GO 64280
64254: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64255: LD_ADDR_VAR 0 3
64259: PUSH
64260: LD_INT 11
64262: PUSH
64263: LD_INT 12
64265: PUSH
64266: LD_INT 13
64268: PUSH
64269: LD_INT 14
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: LIST
64276: LIST
64277: ST_TO_ADDR
64278: GO 64855
64280: LD_INT 23
64282: DOUBLE
64283: EQUAL
64284: IFTRUE 64288
64286: GO 64314
64288: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
64289: LD_ADDR_VAR 0 3
64293: PUSH
64294: LD_INT 11
64296: PUSH
64297: LD_INT 12
64299: PUSH
64300: LD_INT 13
64302: PUSH
64303: LD_INT 14
64305: PUSH
64306: EMPTY
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: ST_TO_ADDR
64312: GO 64855
64314: LD_INT 24
64316: DOUBLE
64317: EQUAL
64318: IFTRUE 64322
64320: GO 64348
64322: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
64323: LD_ADDR_VAR 0 3
64327: PUSH
64328: LD_INT 11
64330: PUSH
64331: LD_INT 12
64333: PUSH
64334: LD_INT 13
64336: PUSH
64337: LD_INT 14
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: LIST
64344: LIST
64345: ST_TO_ADDR
64346: GO 64855
64348: LD_INT 30
64350: DOUBLE
64351: EQUAL
64352: IFTRUE 64356
64354: GO 64382
64356: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
64357: LD_ADDR_VAR 0 3
64361: PUSH
64362: LD_INT 11
64364: PUSH
64365: LD_INT 12
64367: PUSH
64368: LD_INT 13
64370: PUSH
64371: LD_INT 14
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: LIST
64378: LIST
64379: ST_TO_ADDR
64380: GO 64855
64382: LD_INT 25
64384: DOUBLE
64385: EQUAL
64386: IFTRUE 64390
64388: GO 64408
64390: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
64391: LD_ADDR_VAR 0 3
64395: PUSH
64396: LD_INT 13
64398: PUSH
64399: LD_INT 14
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: ST_TO_ADDR
64406: GO 64855
64408: LD_INT 27
64410: DOUBLE
64411: EQUAL
64412: IFTRUE 64416
64414: GO 64434
64416: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
64417: LD_ADDR_VAR 0 3
64421: PUSH
64422: LD_INT 13
64424: PUSH
64425: LD_INT 14
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: ST_TO_ADDR
64432: GO 64855
64434: LD_INT 28
64436: DOUBLE
64437: EQUAL
64438: IFTRUE 64442
64440: GO 64460
64442: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
64443: LD_ADDR_VAR 0 3
64447: PUSH
64448: LD_INT 13
64450: PUSH
64451: LD_INT 14
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: ST_TO_ADDR
64458: GO 64855
64460: LD_INT 29
64462: DOUBLE
64463: EQUAL
64464: IFTRUE 64468
64466: GO 64486
64468: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
64469: LD_ADDR_VAR 0 3
64473: PUSH
64474: LD_INT 13
64476: PUSH
64477: LD_INT 14
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: ST_TO_ADDR
64484: GO 64855
64486: LD_INT 31
64488: DOUBLE
64489: EQUAL
64490: IFTRUE 64494
64492: GO 64512
64494: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
64495: LD_ADDR_VAR 0 3
64499: PUSH
64500: LD_INT 13
64502: PUSH
64503: LD_INT 14
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: ST_TO_ADDR
64510: GO 64855
64512: LD_INT 26
64514: DOUBLE
64515: EQUAL
64516: IFTRUE 64520
64518: GO 64538
64520: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
64521: LD_ADDR_VAR 0 3
64525: PUSH
64526: LD_INT 13
64528: PUSH
64529: LD_INT 14
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: ST_TO_ADDR
64536: GO 64855
64538: LD_INT 42
64540: DOUBLE
64541: EQUAL
64542: IFTRUE 64546
64544: GO 64572
64546: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
64547: LD_ADDR_VAR 0 3
64551: PUSH
64552: LD_INT 21
64554: PUSH
64555: LD_INT 22
64557: PUSH
64558: LD_INT 23
64560: PUSH
64561: LD_INT 24
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: LIST
64568: LIST
64569: ST_TO_ADDR
64570: GO 64855
64572: LD_INT 43
64574: DOUBLE
64575: EQUAL
64576: IFTRUE 64580
64578: GO 64606
64580: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
64581: LD_ADDR_VAR 0 3
64585: PUSH
64586: LD_INT 21
64588: PUSH
64589: LD_INT 22
64591: PUSH
64592: LD_INT 23
64594: PUSH
64595: LD_INT 24
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: ST_TO_ADDR
64604: GO 64855
64606: LD_INT 44
64608: DOUBLE
64609: EQUAL
64610: IFTRUE 64614
64612: GO 64640
64614: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
64615: LD_ADDR_VAR 0 3
64619: PUSH
64620: LD_INT 21
64622: PUSH
64623: LD_INT 22
64625: PUSH
64626: LD_INT 23
64628: PUSH
64629: LD_INT 24
64631: PUSH
64632: EMPTY
64633: LIST
64634: LIST
64635: LIST
64636: LIST
64637: ST_TO_ADDR
64638: GO 64855
64640: LD_INT 45
64642: DOUBLE
64643: EQUAL
64644: IFTRUE 64648
64646: GO 64674
64648: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
64649: LD_ADDR_VAR 0 3
64653: PUSH
64654: LD_INT 21
64656: PUSH
64657: LD_INT 22
64659: PUSH
64660: LD_INT 23
64662: PUSH
64663: LD_INT 24
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: ST_TO_ADDR
64672: GO 64855
64674: LD_INT 49
64676: DOUBLE
64677: EQUAL
64678: IFTRUE 64682
64680: GO 64708
64682: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
64683: LD_ADDR_VAR 0 3
64687: PUSH
64688: LD_INT 21
64690: PUSH
64691: LD_INT 22
64693: PUSH
64694: LD_INT 23
64696: PUSH
64697: LD_INT 24
64699: PUSH
64700: EMPTY
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: ST_TO_ADDR
64706: GO 64855
64708: LD_INT 51
64710: DOUBLE
64711: EQUAL
64712: IFTRUE 64716
64714: GO 64742
64716: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
64717: LD_ADDR_VAR 0 3
64721: PUSH
64722: LD_INT 21
64724: PUSH
64725: LD_INT 22
64727: PUSH
64728: LD_INT 23
64730: PUSH
64731: LD_INT 24
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: ST_TO_ADDR
64740: GO 64855
64742: LD_INT 52
64744: DOUBLE
64745: EQUAL
64746: IFTRUE 64750
64748: GO 64776
64750: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
64751: LD_ADDR_VAR 0 3
64755: PUSH
64756: LD_INT 21
64758: PUSH
64759: LD_INT 22
64761: PUSH
64762: LD_INT 23
64764: PUSH
64765: LD_INT 24
64767: PUSH
64768: EMPTY
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: ST_TO_ADDR
64774: GO 64855
64776: LD_INT 53
64778: DOUBLE
64779: EQUAL
64780: IFTRUE 64784
64782: GO 64802
64784: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
64785: LD_ADDR_VAR 0 3
64789: PUSH
64790: LD_INT 23
64792: PUSH
64793: LD_INT 24
64795: PUSH
64796: EMPTY
64797: LIST
64798: LIST
64799: ST_TO_ADDR
64800: GO 64855
64802: LD_INT 46
64804: DOUBLE
64805: EQUAL
64806: IFTRUE 64810
64808: GO 64828
64810: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
64811: LD_ADDR_VAR 0 3
64815: PUSH
64816: LD_INT 23
64818: PUSH
64819: LD_INT 24
64821: PUSH
64822: EMPTY
64823: LIST
64824: LIST
64825: ST_TO_ADDR
64826: GO 64855
64828: LD_INT 47
64830: DOUBLE
64831: EQUAL
64832: IFTRUE 64836
64834: GO 64854
64836: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64837: LD_ADDR_VAR 0 3
64841: PUSH
64842: LD_INT 23
64844: PUSH
64845: LD_INT 24
64847: PUSH
64848: EMPTY
64849: LIST
64850: LIST
64851: ST_TO_ADDR
64852: GO 64855
64854: POP
// result := ( chassis in result ) ;
64855: LD_ADDR_VAR 0 3
64859: PUSH
64860: LD_VAR 0 1
64864: PUSH
64865: LD_VAR 0 3
64869: IN
64870: ST_TO_ADDR
// end ;
64871: LD_VAR 0 3
64875: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
64876: LD_INT 0
64878: PPUSH
64879: PPUSH
64880: PPUSH
64881: PPUSH
64882: PPUSH
64883: PPUSH
64884: PPUSH
// result := array ;
64885: LD_ADDR_VAR 0 5
64889: PUSH
64890: LD_VAR 0 1
64894: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
64895: LD_VAR 0 1
64899: NOT
64900: PUSH
64901: LD_VAR 0 2
64905: NOT
64906: OR
64907: PUSH
64908: LD_VAR 0 3
64912: NOT
64913: OR
64914: PUSH
64915: LD_VAR 0 2
64919: PUSH
64920: LD_VAR 0 1
64924: GREATER
64925: OR
64926: PUSH
64927: LD_VAR 0 3
64931: PUSH
64932: LD_VAR 0 1
64936: GREATER
64937: OR
64938: IFFALSE 64942
// exit ;
64940: GO 65238
// if direction then
64942: LD_VAR 0 4
64946: IFFALSE 65010
// begin d := 1 ;
64948: LD_ADDR_VAR 0 9
64952: PUSH
64953: LD_INT 1
64955: ST_TO_ADDR
// if i_from > i_to then
64956: LD_VAR 0 2
64960: PUSH
64961: LD_VAR 0 3
64965: GREATER
64966: IFFALSE 64992
// length := ( array - i_from ) + i_to else
64968: LD_ADDR_VAR 0 11
64972: PUSH
64973: LD_VAR 0 1
64977: PUSH
64978: LD_VAR 0 2
64982: MINUS
64983: PUSH
64984: LD_VAR 0 3
64988: PLUS
64989: ST_TO_ADDR
64990: GO 65008
// length := i_to - i_from ;
64992: LD_ADDR_VAR 0 11
64996: PUSH
64997: LD_VAR 0 3
65001: PUSH
65002: LD_VAR 0 2
65006: MINUS
65007: ST_TO_ADDR
// end else
65008: GO 65071
// begin d := - 1 ;
65010: LD_ADDR_VAR 0 9
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: ST_TO_ADDR
// if i_from > i_to then
65019: LD_VAR 0 2
65023: PUSH
65024: LD_VAR 0 3
65028: GREATER
65029: IFFALSE 65049
// length := i_from - i_to else
65031: LD_ADDR_VAR 0 11
65035: PUSH
65036: LD_VAR 0 2
65040: PUSH
65041: LD_VAR 0 3
65045: MINUS
65046: ST_TO_ADDR
65047: GO 65071
// length := ( array - i_to ) + i_from ;
65049: LD_ADDR_VAR 0 11
65053: PUSH
65054: LD_VAR 0 1
65058: PUSH
65059: LD_VAR 0 3
65063: MINUS
65064: PUSH
65065: LD_VAR 0 2
65069: PLUS
65070: ST_TO_ADDR
// end ; if not length then
65071: LD_VAR 0 11
65075: NOT
65076: IFFALSE 65080
// exit ;
65078: GO 65238
// tmp := array ;
65080: LD_ADDR_VAR 0 10
65084: PUSH
65085: LD_VAR 0 1
65089: ST_TO_ADDR
// for i = 1 to length do
65090: LD_ADDR_VAR 0 6
65094: PUSH
65095: DOUBLE
65096: LD_INT 1
65098: DEC
65099: ST_TO_ADDR
65100: LD_VAR 0 11
65104: PUSH
65105: FOR_TO
65106: IFFALSE 65226
// begin for j = 1 to array do
65108: LD_ADDR_VAR 0 7
65112: PUSH
65113: DOUBLE
65114: LD_INT 1
65116: DEC
65117: ST_TO_ADDR
65118: LD_VAR 0 1
65122: PUSH
65123: FOR_TO
65124: IFFALSE 65212
// begin k := j + d ;
65126: LD_ADDR_VAR 0 8
65130: PUSH
65131: LD_VAR 0 7
65135: PUSH
65136: LD_VAR 0 9
65140: PLUS
65141: ST_TO_ADDR
// if k > array then
65142: LD_VAR 0 8
65146: PUSH
65147: LD_VAR 0 1
65151: GREATER
65152: IFFALSE 65162
// k := 1 ;
65154: LD_ADDR_VAR 0 8
65158: PUSH
65159: LD_INT 1
65161: ST_TO_ADDR
// if not k then
65162: LD_VAR 0 8
65166: NOT
65167: IFFALSE 65179
// k := array ;
65169: LD_ADDR_VAR 0 8
65173: PUSH
65174: LD_VAR 0 1
65178: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65179: LD_ADDR_VAR 0 10
65183: PUSH
65184: LD_VAR 0 10
65188: PPUSH
65189: LD_VAR 0 8
65193: PPUSH
65194: LD_VAR 0 1
65198: PUSH
65199: LD_VAR 0 7
65203: ARRAY
65204: PPUSH
65205: CALL_OW 1
65209: ST_TO_ADDR
// end ;
65210: GO 65123
65212: POP
65213: POP
// array := tmp ;
65214: LD_ADDR_VAR 0 1
65218: PUSH
65219: LD_VAR 0 10
65223: ST_TO_ADDR
// end ;
65224: GO 65105
65226: POP
65227: POP
// result := array ;
65228: LD_ADDR_VAR 0 5
65232: PUSH
65233: LD_VAR 0 1
65237: ST_TO_ADDR
// end ;
65238: LD_VAR 0 5
65242: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65243: LD_INT 0
65245: PPUSH
65246: PPUSH
// result := 0 ;
65247: LD_ADDR_VAR 0 3
65251: PUSH
65252: LD_INT 0
65254: ST_TO_ADDR
// if not array or not value in array then
65255: LD_VAR 0 1
65259: NOT
65260: PUSH
65261: LD_VAR 0 2
65265: PUSH
65266: LD_VAR 0 1
65270: IN
65271: NOT
65272: OR
65273: IFFALSE 65277
// exit ;
65275: GO 65331
// for i = 1 to array do
65277: LD_ADDR_VAR 0 4
65281: PUSH
65282: DOUBLE
65283: LD_INT 1
65285: DEC
65286: ST_TO_ADDR
65287: LD_VAR 0 1
65291: PUSH
65292: FOR_TO
65293: IFFALSE 65329
// if value = array [ i ] then
65295: LD_VAR 0 2
65299: PUSH
65300: LD_VAR 0 1
65304: PUSH
65305: LD_VAR 0 4
65309: ARRAY
65310: EQUAL
65311: IFFALSE 65327
// begin result := i ;
65313: LD_ADDR_VAR 0 3
65317: PUSH
65318: LD_VAR 0 4
65322: ST_TO_ADDR
// exit ;
65323: POP
65324: POP
65325: GO 65331
// end ;
65327: GO 65292
65329: POP
65330: POP
// end ;
65331: LD_VAR 0 3
65335: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
65336: LD_INT 0
65338: PPUSH
// vc_chassis := chassis ;
65339: LD_ADDR_OWVAR 37
65343: PUSH
65344: LD_VAR 0 1
65348: ST_TO_ADDR
// vc_engine := engine ;
65349: LD_ADDR_OWVAR 39
65353: PUSH
65354: LD_VAR 0 2
65358: ST_TO_ADDR
// vc_control := control ;
65359: LD_ADDR_OWVAR 38
65363: PUSH
65364: LD_VAR 0 3
65368: ST_TO_ADDR
// vc_weapon := weapon ;
65369: LD_ADDR_OWVAR 40
65373: PUSH
65374: LD_VAR 0 4
65378: ST_TO_ADDR
// vc_fuel_battery := fuel ;
65379: LD_ADDR_OWVAR 41
65383: PUSH
65384: LD_VAR 0 5
65388: ST_TO_ADDR
// end ;
65389: LD_VAR 0 6
65393: RET
// export function WantPlant ( unit ) ; var task ; begin
65394: LD_INT 0
65396: PPUSH
65397: PPUSH
// result := false ;
65398: LD_ADDR_VAR 0 2
65402: PUSH
65403: LD_INT 0
65405: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
65406: LD_ADDR_VAR 0 3
65410: PUSH
65411: LD_VAR 0 1
65415: PPUSH
65416: CALL_OW 437
65420: ST_TO_ADDR
// if task then
65421: LD_VAR 0 3
65425: IFFALSE 65453
// if task [ 1 ] [ 1 ] = p then
65427: LD_VAR 0 3
65431: PUSH
65432: LD_INT 1
65434: ARRAY
65435: PUSH
65436: LD_INT 1
65438: ARRAY
65439: PUSH
65440: LD_STRING p
65442: EQUAL
65443: IFFALSE 65453
// result := true ;
65445: LD_ADDR_VAR 0 2
65449: PUSH
65450: LD_INT 1
65452: ST_TO_ADDR
// end ;
65453: LD_VAR 0 2
65457: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
65458: LD_INT 0
65460: PPUSH
65461: PPUSH
65462: PPUSH
65463: PPUSH
// if pos < 1 then
65464: LD_VAR 0 2
65468: PUSH
65469: LD_INT 1
65471: LESS
65472: IFFALSE 65476
// exit ;
65474: GO 65779
// if pos = 1 then
65476: LD_VAR 0 2
65480: PUSH
65481: LD_INT 1
65483: EQUAL
65484: IFFALSE 65517
// result := Replace ( arr , pos [ 1 ] , value ) else
65486: LD_ADDR_VAR 0 4
65490: PUSH
65491: LD_VAR 0 1
65495: PPUSH
65496: LD_VAR 0 2
65500: PUSH
65501: LD_INT 1
65503: ARRAY
65504: PPUSH
65505: LD_VAR 0 3
65509: PPUSH
65510: CALL_OW 1
65514: ST_TO_ADDR
65515: GO 65779
// begin tmp := arr ;
65517: LD_ADDR_VAR 0 6
65521: PUSH
65522: LD_VAR 0 1
65526: ST_TO_ADDR
// s_arr := [ tmp ] ;
65527: LD_ADDR_VAR 0 7
65531: PUSH
65532: LD_VAR 0 6
65536: PUSH
65537: EMPTY
65538: LIST
65539: ST_TO_ADDR
// for i = 1 to pos - 1 do
65540: LD_ADDR_VAR 0 5
65544: PUSH
65545: DOUBLE
65546: LD_INT 1
65548: DEC
65549: ST_TO_ADDR
65550: LD_VAR 0 2
65554: PUSH
65555: LD_INT 1
65557: MINUS
65558: PUSH
65559: FOR_TO
65560: IFFALSE 65605
// begin tmp := tmp [ pos [ i ] ] ;
65562: LD_ADDR_VAR 0 6
65566: PUSH
65567: LD_VAR 0 6
65571: PUSH
65572: LD_VAR 0 2
65576: PUSH
65577: LD_VAR 0 5
65581: ARRAY
65582: ARRAY
65583: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
65584: LD_ADDR_VAR 0 7
65588: PUSH
65589: LD_VAR 0 7
65593: PUSH
65594: LD_VAR 0 6
65598: PUSH
65599: EMPTY
65600: LIST
65601: ADD
65602: ST_TO_ADDR
// end ;
65603: GO 65559
65605: POP
65606: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
65607: LD_ADDR_VAR 0 6
65611: PUSH
65612: LD_VAR 0 6
65616: PPUSH
65617: LD_VAR 0 2
65621: PUSH
65622: LD_VAR 0 2
65626: ARRAY
65627: PPUSH
65628: LD_VAR 0 3
65632: PPUSH
65633: CALL_OW 1
65637: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
65638: LD_ADDR_VAR 0 7
65642: PUSH
65643: LD_VAR 0 7
65647: PPUSH
65648: LD_VAR 0 7
65652: PPUSH
65653: LD_VAR 0 6
65657: PPUSH
65658: CALL_OW 1
65662: ST_TO_ADDR
// for i = s_arr downto 2 do
65663: LD_ADDR_VAR 0 5
65667: PUSH
65668: DOUBLE
65669: LD_VAR 0 7
65673: INC
65674: ST_TO_ADDR
65675: LD_INT 2
65677: PUSH
65678: FOR_DOWNTO
65679: IFFALSE 65763
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
65681: LD_ADDR_VAR 0 6
65685: PUSH
65686: LD_VAR 0 7
65690: PUSH
65691: LD_VAR 0 5
65695: PUSH
65696: LD_INT 1
65698: MINUS
65699: ARRAY
65700: PPUSH
65701: LD_VAR 0 2
65705: PUSH
65706: LD_VAR 0 5
65710: PUSH
65711: LD_INT 1
65713: MINUS
65714: ARRAY
65715: PPUSH
65716: LD_VAR 0 7
65720: PUSH
65721: LD_VAR 0 5
65725: ARRAY
65726: PPUSH
65727: CALL_OW 1
65731: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
65732: LD_ADDR_VAR 0 7
65736: PUSH
65737: LD_VAR 0 7
65741: PPUSH
65742: LD_VAR 0 5
65746: PUSH
65747: LD_INT 1
65749: MINUS
65750: PPUSH
65751: LD_VAR 0 6
65755: PPUSH
65756: CALL_OW 1
65760: ST_TO_ADDR
// end ;
65761: GO 65678
65763: POP
65764: POP
// result := s_arr [ 1 ] ;
65765: LD_ADDR_VAR 0 4
65769: PUSH
65770: LD_VAR 0 7
65774: PUSH
65775: LD_INT 1
65777: ARRAY
65778: ST_TO_ADDR
// end ; end ;
65779: LD_VAR 0 4
65783: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
65784: LD_INT 0
65786: PPUSH
65787: PPUSH
// if not list then
65788: LD_VAR 0 1
65792: NOT
65793: IFFALSE 65797
// exit ;
65795: GO 65888
// i := list [ pos1 ] ;
65797: LD_ADDR_VAR 0 5
65801: PUSH
65802: LD_VAR 0 1
65806: PUSH
65807: LD_VAR 0 2
65811: ARRAY
65812: ST_TO_ADDR
// if not i then
65813: LD_VAR 0 5
65817: NOT
65818: IFFALSE 65822
// exit ;
65820: GO 65888
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
65822: LD_ADDR_VAR 0 1
65826: PUSH
65827: LD_VAR 0 1
65831: PPUSH
65832: LD_VAR 0 2
65836: PPUSH
65837: LD_VAR 0 1
65841: PUSH
65842: LD_VAR 0 3
65846: ARRAY
65847: PPUSH
65848: CALL_OW 1
65852: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
65853: LD_ADDR_VAR 0 1
65857: PUSH
65858: LD_VAR 0 1
65862: PPUSH
65863: LD_VAR 0 3
65867: PPUSH
65868: LD_VAR 0 5
65872: PPUSH
65873: CALL_OW 1
65877: ST_TO_ADDR
// result := list ;
65878: LD_ADDR_VAR 0 4
65882: PUSH
65883: LD_VAR 0 1
65887: ST_TO_ADDR
// end ;
65888: LD_VAR 0 4
65892: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
65893: LD_INT 0
65895: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
65896: LD_ADDR_VAR 0 5
65900: PUSH
65901: LD_VAR 0 1
65905: PPUSH
65906: CALL_OW 250
65910: PPUSH
65911: LD_VAR 0 1
65915: PPUSH
65916: CALL_OW 251
65920: PPUSH
65921: LD_VAR 0 2
65925: PPUSH
65926: LD_VAR 0 3
65930: PPUSH
65931: LD_VAR 0 4
65935: PPUSH
65936: CALL 65946 0 5
65940: ST_TO_ADDR
// end ;
65941: LD_VAR 0 5
65945: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
65946: LD_INT 0
65948: PPUSH
65949: PPUSH
65950: PPUSH
65951: PPUSH
// if not list then
65952: LD_VAR 0 3
65956: NOT
65957: IFFALSE 65961
// exit ;
65959: GO 66349
// result := [ ] ;
65961: LD_ADDR_VAR 0 6
65965: PUSH
65966: EMPTY
65967: ST_TO_ADDR
// for i in list do
65968: LD_ADDR_VAR 0 7
65972: PUSH
65973: LD_VAR 0 3
65977: PUSH
65978: FOR_IN
65979: IFFALSE 66181
// begin tmp := GetDistUnitXY ( i , x , y ) ;
65981: LD_ADDR_VAR 0 9
65985: PUSH
65986: LD_VAR 0 7
65990: PPUSH
65991: LD_VAR 0 1
65995: PPUSH
65996: LD_VAR 0 2
66000: PPUSH
66001: CALL_OW 297
66005: ST_TO_ADDR
// if not result then
66006: LD_VAR 0 6
66010: NOT
66011: IFFALSE 66037
// result := [ [ i , tmp ] ] else
66013: LD_ADDR_VAR 0 6
66017: PUSH
66018: LD_VAR 0 7
66022: PUSH
66023: LD_VAR 0 9
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: PUSH
66032: EMPTY
66033: LIST
66034: ST_TO_ADDR
66035: GO 66179
// begin if result [ result ] [ 2 ] < tmp then
66037: LD_VAR 0 6
66041: PUSH
66042: LD_VAR 0 6
66046: ARRAY
66047: PUSH
66048: LD_INT 2
66050: ARRAY
66051: PUSH
66052: LD_VAR 0 9
66056: LESS
66057: IFFALSE 66099
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66059: LD_ADDR_VAR 0 6
66063: PUSH
66064: LD_VAR 0 6
66068: PPUSH
66069: LD_VAR 0 6
66073: PUSH
66074: LD_INT 1
66076: PLUS
66077: PPUSH
66078: LD_VAR 0 7
66082: PUSH
66083: LD_VAR 0 9
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PPUSH
66092: CALL_OW 2
66096: ST_TO_ADDR
66097: GO 66179
// for j = 1 to result do
66099: LD_ADDR_VAR 0 8
66103: PUSH
66104: DOUBLE
66105: LD_INT 1
66107: DEC
66108: ST_TO_ADDR
66109: LD_VAR 0 6
66113: PUSH
66114: FOR_TO
66115: IFFALSE 66177
// begin if tmp < result [ j ] [ 2 ] then
66117: LD_VAR 0 9
66121: PUSH
66122: LD_VAR 0 6
66126: PUSH
66127: LD_VAR 0 8
66131: ARRAY
66132: PUSH
66133: LD_INT 2
66135: ARRAY
66136: LESS
66137: IFFALSE 66175
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66139: LD_ADDR_VAR 0 6
66143: PUSH
66144: LD_VAR 0 6
66148: PPUSH
66149: LD_VAR 0 8
66153: PPUSH
66154: LD_VAR 0 7
66158: PUSH
66159: LD_VAR 0 9
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PPUSH
66168: CALL_OW 2
66172: ST_TO_ADDR
// break ;
66173: GO 66177
// end ; end ;
66175: GO 66114
66177: POP
66178: POP
// end ; end ;
66179: GO 65978
66181: POP
66182: POP
// if result and not asc then
66183: LD_VAR 0 6
66187: PUSH
66188: LD_VAR 0 4
66192: NOT
66193: AND
66194: IFFALSE 66269
// begin tmp := result ;
66196: LD_ADDR_VAR 0 9
66200: PUSH
66201: LD_VAR 0 6
66205: ST_TO_ADDR
// for i = tmp downto 1 do
66206: LD_ADDR_VAR 0 7
66210: PUSH
66211: DOUBLE
66212: LD_VAR 0 9
66216: INC
66217: ST_TO_ADDR
66218: LD_INT 1
66220: PUSH
66221: FOR_DOWNTO
66222: IFFALSE 66267
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66224: LD_ADDR_VAR 0 6
66228: PUSH
66229: LD_VAR 0 6
66233: PPUSH
66234: LD_VAR 0 9
66238: PUSH
66239: LD_VAR 0 7
66243: MINUS
66244: PUSH
66245: LD_INT 1
66247: PLUS
66248: PPUSH
66249: LD_VAR 0 9
66253: PUSH
66254: LD_VAR 0 7
66258: ARRAY
66259: PPUSH
66260: CALL_OW 1
66264: ST_TO_ADDR
66265: GO 66221
66267: POP
66268: POP
// end ; tmp := [ ] ;
66269: LD_ADDR_VAR 0 9
66273: PUSH
66274: EMPTY
66275: ST_TO_ADDR
// if mode then
66276: LD_VAR 0 5
66280: IFFALSE 66349
// begin for i = 1 to result do
66282: LD_ADDR_VAR 0 7
66286: PUSH
66287: DOUBLE
66288: LD_INT 1
66290: DEC
66291: ST_TO_ADDR
66292: LD_VAR 0 6
66296: PUSH
66297: FOR_TO
66298: IFFALSE 66337
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
66300: LD_ADDR_VAR 0 9
66304: PUSH
66305: LD_VAR 0 9
66309: PPUSH
66310: LD_VAR 0 7
66314: PPUSH
66315: LD_VAR 0 6
66319: PUSH
66320: LD_VAR 0 7
66324: ARRAY
66325: PUSH
66326: LD_INT 1
66328: ARRAY
66329: PPUSH
66330: CALL_OW 1
66334: ST_TO_ADDR
66335: GO 66297
66337: POP
66338: POP
// result := tmp ;
66339: LD_ADDR_VAR 0 6
66343: PUSH
66344: LD_VAR 0 9
66348: ST_TO_ADDR
// end ; end ;
66349: LD_VAR 0 6
66353: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
66354: LD_INT 0
66356: PPUSH
66357: PPUSH
66358: PPUSH
66359: PPUSH
66360: PPUSH
66361: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
66362: LD_ADDR_VAR 0 5
66366: PUSH
66367: LD_INT 0
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: LD_INT 0
66375: PUSH
66376: EMPTY
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: ST_TO_ADDR
// if not x or not y then
66384: LD_VAR 0 2
66388: NOT
66389: PUSH
66390: LD_VAR 0 3
66394: NOT
66395: OR
66396: IFFALSE 66400
// exit ;
66398: GO 68046
// if not range then
66400: LD_VAR 0 4
66404: NOT
66405: IFFALSE 66415
// range := 10 ;
66407: LD_ADDR_VAR 0 4
66411: PUSH
66412: LD_INT 10
66414: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66415: LD_ADDR_VAR 0 8
66419: PUSH
66420: LD_INT 81
66422: PUSH
66423: LD_VAR 0 1
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 92
66434: PUSH
66435: LD_VAR 0 2
66439: PUSH
66440: LD_VAR 0 3
66444: PUSH
66445: LD_VAR 0 4
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 3
66458: PUSH
66459: LD_INT 21
66461: PUSH
66462: LD_INT 3
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: LIST
66477: PPUSH
66478: CALL_OW 69
66482: ST_TO_ADDR
// if not tmp then
66483: LD_VAR 0 8
66487: NOT
66488: IFFALSE 66492
// exit ;
66490: GO 68046
// for i in tmp do
66492: LD_ADDR_VAR 0 6
66496: PUSH
66497: LD_VAR 0 8
66501: PUSH
66502: FOR_IN
66503: IFFALSE 68021
// begin points := [ 0 , 0 , 0 ] ;
66505: LD_ADDR_VAR 0 9
66509: PUSH
66510: LD_INT 0
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: LIST
66523: ST_TO_ADDR
// bpoints := 1 ;
66524: LD_ADDR_VAR 0 10
66528: PUSH
66529: LD_INT 1
66531: ST_TO_ADDR
// case GetType ( i ) of unit_human :
66532: LD_VAR 0 6
66536: PPUSH
66537: CALL_OW 247
66541: PUSH
66542: LD_INT 1
66544: DOUBLE
66545: EQUAL
66546: IFTRUE 66550
66548: GO 67128
66550: POP
// begin if GetClass ( i ) = 1 then
66551: LD_VAR 0 6
66555: PPUSH
66556: CALL_OW 257
66560: PUSH
66561: LD_INT 1
66563: EQUAL
66564: IFFALSE 66585
// points := [ 10 , 5 , 3 ] ;
66566: LD_ADDR_VAR 0 9
66570: PUSH
66571: LD_INT 10
66573: PUSH
66574: LD_INT 5
66576: PUSH
66577: LD_INT 3
66579: PUSH
66580: EMPTY
66581: LIST
66582: LIST
66583: LIST
66584: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
66585: LD_VAR 0 6
66589: PPUSH
66590: CALL_OW 257
66594: PUSH
66595: LD_INT 2
66597: PUSH
66598: LD_INT 3
66600: PUSH
66601: LD_INT 4
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: LIST
66608: IN
66609: IFFALSE 66630
// points := [ 3 , 2 , 1 ] ;
66611: LD_ADDR_VAR 0 9
66615: PUSH
66616: LD_INT 3
66618: PUSH
66619: LD_INT 2
66621: PUSH
66622: LD_INT 1
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: LIST
66629: ST_TO_ADDR
// if GetClass ( i ) = 5 then
66630: LD_VAR 0 6
66634: PPUSH
66635: CALL_OW 257
66639: PUSH
66640: LD_INT 5
66642: EQUAL
66643: IFFALSE 66664
// points := [ 130 , 5 , 2 ] ;
66645: LD_ADDR_VAR 0 9
66649: PUSH
66650: LD_INT 130
66652: PUSH
66653: LD_INT 5
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: LIST
66663: ST_TO_ADDR
// if GetClass ( i ) = 8 then
66664: LD_VAR 0 6
66668: PPUSH
66669: CALL_OW 257
66673: PUSH
66674: LD_INT 8
66676: EQUAL
66677: IFFALSE 66698
// points := [ 35 , 35 , 30 ] ;
66679: LD_ADDR_VAR 0 9
66683: PUSH
66684: LD_INT 35
66686: PUSH
66687: LD_INT 35
66689: PUSH
66690: LD_INT 30
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: LIST
66697: ST_TO_ADDR
// if GetClass ( i ) = 9 then
66698: LD_VAR 0 6
66702: PPUSH
66703: CALL_OW 257
66707: PUSH
66708: LD_INT 9
66710: EQUAL
66711: IFFALSE 66732
// points := [ 20 , 55 , 40 ] ;
66713: LD_ADDR_VAR 0 9
66717: PUSH
66718: LD_INT 20
66720: PUSH
66721: LD_INT 55
66723: PUSH
66724: LD_INT 40
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: LIST
66731: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
66732: LD_VAR 0 6
66736: PPUSH
66737: CALL_OW 257
66741: PUSH
66742: LD_INT 12
66744: PUSH
66745: LD_INT 16
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: IN
66752: IFFALSE 66773
// points := [ 5 , 3 , 2 ] ;
66754: LD_ADDR_VAR 0 9
66758: PUSH
66759: LD_INT 5
66761: PUSH
66762: LD_INT 3
66764: PUSH
66765: LD_INT 2
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: LIST
66772: ST_TO_ADDR
// if GetClass ( i ) = 17 then
66773: LD_VAR 0 6
66777: PPUSH
66778: CALL_OW 257
66782: PUSH
66783: LD_INT 17
66785: EQUAL
66786: IFFALSE 66807
// points := [ 100 , 50 , 75 ] ;
66788: LD_ADDR_VAR 0 9
66792: PUSH
66793: LD_INT 100
66795: PUSH
66796: LD_INT 50
66798: PUSH
66799: LD_INT 75
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: LIST
66806: ST_TO_ADDR
// if GetClass ( i ) = 15 then
66807: LD_VAR 0 6
66811: PPUSH
66812: CALL_OW 257
66816: PUSH
66817: LD_INT 15
66819: EQUAL
66820: IFFALSE 66841
// points := [ 10 , 5 , 3 ] ;
66822: LD_ADDR_VAR 0 9
66826: PUSH
66827: LD_INT 10
66829: PUSH
66830: LD_INT 5
66832: PUSH
66833: LD_INT 3
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: LIST
66840: ST_TO_ADDR
// if GetClass ( i ) = 14 then
66841: LD_VAR 0 6
66845: PPUSH
66846: CALL_OW 257
66850: PUSH
66851: LD_INT 14
66853: EQUAL
66854: IFFALSE 66875
// points := [ 10 , 0 , 0 ] ;
66856: LD_ADDR_VAR 0 9
66860: PUSH
66861: LD_INT 10
66863: PUSH
66864: LD_INT 0
66866: PUSH
66867: LD_INT 0
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: LIST
66874: ST_TO_ADDR
// if GetClass ( i ) = 11 then
66875: LD_VAR 0 6
66879: PPUSH
66880: CALL_OW 257
66884: PUSH
66885: LD_INT 11
66887: EQUAL
66888: IFFALSE 66909
// points := [ 30 , 10 , 5 ] ;
66890: LD_ADDR_VAR 0 9
66894: PUSH
66895: LD_INT 30
66897: PUSH
66898: LD_INT 10
66900: PUSH
66901: LD_INT 5
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: LIST
66908: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
66909: LD_VAR 0 1
66913: PPUSH
66914: LD_INT 5
66916: PPUSH
66917: CALL_OW 321
66921: PUSH
66922: LD_INT 2
66924: EQUAL
66925: IFFALSE 66942
// bpoints := bpoints * 1.8 ;
66927: LD_ADDR_VAR 0 10
66931: PUSH
66932: LD_VAR 0 10
66936: PUSH
66937: LD_REAL  1.80000000000000E+0000
66940: MUL
66941: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
66942: LD_VAR 0 6
66946: PPUSH
66947: CALL_OW 257
66951: PUSH
66952: LD_INT 1
66954: PUSH
66955: LD_INT 2
66957: PUSH
66958: LD_INT 3
66960: PUSH
66961: LD_INT 4
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: IN
66970: PUSH
66971: LD_VAR 0 1
66975: PPUSH
66976: LD_INT 51
66978: PPUSH
66979: CALL_OW 321
66983: PUSH
66984: LD_INT 2
66986: EQUAL
66987: AND
66988: IFFALSE 67005
// bpoints := bpoints * 1.2 ;
66990: LD_ADDR_VAR 0 10
66994: PUSH
66995: LD_VAR 0 10
66999: PUSH
67000: LD_REAL  1.20000000000000E+0000
67003: MUL
67004: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67005: LD_VAR 0 6
67009: PPUSH
67010: CALL_OW 257
67014: PUSH
67015: LD_INT 5
67017: PUSH
67018: LD_INT 7
67020: PUSH
67021: LD_INT 9
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: LIST
67028: IN
67029: PUSH
67030: LD_VAR 0 1
67034: PPUSH
67035: LD_INT 52
67037: PPUSH
67038: CALL_OW 321
67042: PUSH
67043: LD_INT 2
67045: EQUAL
67046: AND
67047: IFFALSE 67064
// bpoints := bpoints * 1.5 ;
67049: LD_ADDR_VAR 0 10
67053: PUSH
67054: LD_VAR 0 10
67058: PUSH
67059: LD_REAL  1.50000000000000E+0000
67062: MUL
67063: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67064: LD_VAR 0 1
67068: PPUSH
67069: LD_INT 66
67071: PPUSH
67072: CALL_OW 321
67076: PUSH
67077: LD_INT 2
67079: EQUAL
67080: IFFALSE 67097
// bpoints := bpoints * 1.1 ;
67082: LD_ADDR_VAR 0 10
67086: PUSH
67087: LD_VAR 0 10
67091: PUSH
67092: LD_REAL  1.10000000000000E+0000
67095: MUL
67096: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67097: LD_ADDR_VAR 0 10
67101: PUSH
67102: LD_VAR 0 10
67106: PUSH
67107: LD_VAR 0 6
67111: PPUSH
67112: LD_INT 1
67114: PPUSH
67115: CALL_OW 259
67119: PUSH
67120: LD_REAL  1.15000000000000E+0000
67123: MUL
67124: MUL
67125: ST_TO_ADDR
// end ; unit_vehicle :
67126: GO 67950
67128: LD_INT 2
67130: DOUBLE
67131: EQUAL
67132: IFTRUE 67136
67134: GO 67938
67136: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67137: LD_VAR 0 6
67141: PPUSH
67142: CALL_OW 264
67146: PUSH
67147: LD_INT 2
67149: PUSH
67150: LD_INT 42
67152: PUSH
67153: LD_INT 24
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: LIST
67160: IN
67161: IFFALSE 67182
// points := [ 25 , 5 , 3 ] ;
67163: LD_ADDR_VAR 0 9
67167: PUSH
67168: LD_INT 25
67170: PUSH
67171: LD_INT 5
67173: PUSH
67174: LD_INT 3
67176: PUSH
67177: EMPTY
67178: LIST
67179: LIST
67180: LIST
67181: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67182: LD_VAR 0 6
67186: PPUSH
67187: CALL_OW 264
67191: PUSH
67192: LD_INT 4
67194: PUSH
67195: LD_INT 43
67197: PUSH
67198: LD_INT 25
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: LIST
67205: IN
67206: IFFALSE 67227
// points := [ 40 , 15 , 5 ] ;
67208: LD_ADDR_VAR 0 9
67212: PUSH
67213: LD_INT 40
67215: PUSH
67216: LD_INT 15
67218: PUSH
67219: LD_INT 5
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: LIST
67226: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67227: LD_VAR 0 6
67231: PPUSH
67232: CALL_OW 264
67236: PUSH
67237: LD_INT 3
67239: PUSH
67240: LD_INT 23
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: IN
67247: IFFALSE 67268
// points := [ 7 , 25 , 8 ] ;
67249: LD_ADDR_VAR 0 9
67253: PUSH
67254: LD_INT 7
67256: PUSH
67257: LD_INT 25
67259: PUSH
67260: LD_INT 8
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: LIST
67267: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
67268: LD_VAR 0 6
67272: PPUSH
67273: CALL_OW 264
67277: PUSH
67278: LD_INT 5
67280: PUSH
67281: LD_INT 27
67283: PUSH
67284: LD_INT 44
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: LIST
67291: IN
67292: IFFALSE 67313
// points := [ 14 , 50 , 16 ] ;
67294: LD_ADDR_VAR 0 9
67298: PUSH
67299: LD_INT 14
67301: PUSH
67302: LD_INT 50
67304: PUSH
67305: LD_INT 16
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: LIST
67312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
67313: LD_VAR 0 6
67317: PPUSH
67318: CALL_OW 264
67322: PUSH
67323: LD_INT 6
67325: PUSH
67326: LD_INT 46
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: IN
67333: IFFALSE 67354
// points := [ 32 , 120 , 70 ] ;
67335: LD_ADDR_VAR 0 9
67339: PUSH
67340: LD_INT 32
67342: PUSH
67343: LD_INT 120
67345: PUSH
67346: LD_INT 70
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: LIST
67353: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
67354: LD_VAR 0 6
67358: PPUSH
67359: CALL_OW 264
67363: PUSH
67364: LD_INT 7
67366: PUSH
67367: LD_INT 28
67369: PUSH
67370: LD_INT 45
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: LIST
67377: IN
67378: IFFALSE 67399
// points := [ 35 , 20 , 45 ] ;
67380: LD_ADDR_VAR 0 9
67384: PUSH
67385: LD_INT 35
67387: PUSH
67388: LD_INT 20
67390: PUSH
67391: LD_INT 45
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: LIST
67398: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
67399: LD_VAR 0 6
67403: PPUSH
67404: CALL_OW 264
67408: PUSH
67409: LD_INT 47
67411: PUSH
67412: EMPTY
67413: LIST
67414: IN
67415: IFFALSE 67436
// points := [ 67 , 45 , 75 ] ;
67417: LD_ADDR_VAR 0 9
67421: PUSH
67422: LD_INT 67
67424: PUSH
67425: LD_INT 45
67427: PUSH
67428: LD_INT 75
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: LIST
67435: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
67436: LD_VAR 0 6
67440: PPUSH
67441: CALL_OW 264
67445: PUSH
67446: LD_INT 26
67448: PUSH
67449: EMPTY
67450: LIST
67451: IN
67452: IFFALSE 67473
// points := [ 120 , 30 , 80 ] ;
67454: LD_ADDR_VAR 0 9
67458: PUSH
67459: LD_INT 120
67461: PUSH
67462: LD_INT 30
67464: PUSH
67465: LD_INT 80
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: LIST
67472: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
67473: LD_VAR 0 6
67477: PPUSH
67478: CALL_OW 264
67482: PUSH
67483: LD_INT 22
67485: PUSH
67486: EMPTY
67487: LIST
67488: IN
67489: IFFALSE 67510
// points := [ 40 , 1 , 1 ] ;
67491: LD_ADDR_VAR 0 9
67495: PUSH
67496: LD_INT 40
67498: PUSH
67499: LD_INT 1
67501: PUSH
67502: LD_INT 1
67504: PUSH
67505: EMPTY
67506: LIST
67507: LIST
67508: LIST
67509: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
67510: LD_VAR 0 6
67514: PPUSH
67515: CALL_OW 264
67519: PUSH
67520: LD_INT 29
67522: PUSH
67523: EMPTY
67524: LIST
67525: IN
67526: IFFALSE 67547
// points := [ 70 , 200 , 400 ] ;
67528: LD_ADDR_VAR 0 9
67532: PUSH
67533: LD_INT 70
67535: PUSH
67536: LD_INT 200
67538: PUSH
67539: LD_INT 400
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: LIST
67546: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
67547: LD_VAR 0 6
67551: PPUSH
67552: CALL_OW 264
67556: PUSH
67557: LD_INT 14
67559: PUSH
67560: LD_INT 53
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: IN
67567: IFFALSE 67588
// points := [ 40 , 10 , 20 ] ;
67569: LD_ADDR_VAR 0 9
67573: PUSH
67574: LD_INT 40
67576: PUSH
67577: LD_INT 10
67579: PUSH
67580: LD_INT 20
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: LIST
67587: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
67588: LD_VAR 0 6
67592: PPUSH
67593: CALL_OW 264
67597: PUSH
67598: LD_INT 9
67600: PUSH
67601: EMPTY
67602: LIST
67603: IN
67604: IFFALSE 67625
// points := [ 5 , 70 , 20 ] ;
67606: LD_ADDR_VAR 0 9
67610: PUSH
67611: LD_INT 5
67613: PUSH
67614: LD_INT 70
67616: PUSH
67617: LD_INT 20
67619: PUSH
67620: EMPTY
67621: LIST
67622: LIST
67623: LIST
67624: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
67625: LD_VAR 0 6
67629: PPUSH
67630: CALL_OW 264
67634: PUSH
67635: LD_INT 10
67637: PUSH
67638: EMPTY
67639: LIST
67640: IN
67641: IFFALSE 67662
// points := [ 35 , 110 , 70 ] ;
67643: LD_ADDR_VAR 0 9
67647: PUSH
67648: LD_INT 35
67650: PUSH
67651: LD_INT 110
67653: PUSH
67654: LD_INT 70
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: LIST
67661: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
67662: LD_VAR 0 6
67666: PPUSH
67667: CALL_OW 265
67671: PUSH
67672: LD_INT 25
67674: EQUAL
67675: IFFALSE 67696
// points := [ 80 , 65 , 100 ] ;
67677: LD_ADDR_VAR 0 9
67681: PUSH
67682: LD_INT 80
67684: PUSH
67685: LD_INT 65
67687: PUSH
67688: LD_INT 100
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: LIST
67695: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
67696: LD_VAR 0 6
67700: PPUSH
67701: CALL_OW 263
67705: PUSH
67706: LD_INT 1
67708: EQUAL
67709: IFFALSE 67744
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
67711: LD_ADDR_VAR 0 10
67715: PUSH
67716: LD_VAR 0 10
67720: PUSH
67721: LD_VAR 0 6
67725: PPUSH
67726: CALL_OW 311
67730: PPUSH
67731: LD_INT 3
67733: PPUSH
67734: CALL_OW 259
67738: PUSH
67739: LD_INT 4
67741: MUL
67742: MUL
67743: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
67744: LD_VAR 0 6
67748: PPUSH
67749: CALL_OW 263
67753: PUSH
67754: LD_INT 2
67756: EQUAL
67757: IFFALSE 67808
// begin j := IsControledBy ( i ) ;
67759: LD_ADDR_VAR 0 7
67763: PUSH
67764: LD_VAR 0 6
67768: PPUSH
67769: CALL_OW 312
67773: ST_TO_ADDR
// if j then
67774: LD_VAR 0 7
67778: IFFALSE 67808
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
67780: LD_ADDR_VAR 0 10
67784: PUSH
67785: LD_VAR 0 10
67789: PUSH
67790: LD_VAR 0 7
67794: PPUSH
67795: LD_INT 3
67797: PPUSH
67798: CALL_OW 259
67802: PUSH
67803: LD_INT 3
67805: MUL
67806: MUL
67807: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
67808: LD_VAR 0 6
67812: PPUSH
67813: CALL_OW 264
67817: PUSH
67818: LD_INT 5
67820: PUSH
67821: LD_INT 6
67823: PUSH
67824: LD_INT 46
67826: PUSH
67827: LD_INT 44
67829: PUSH
67830: LD_INT 47
67832: PUSH
67833: LD_INT 45
67835: PUSH
67836: LD_INT 28
67838: PUSH
67839: LD_INT 7
67841: PUSH
67842: LD_INT 27
67844: PUSH
67845: LD_INT 29
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: LIST
67859: IN
67860: PUSH
67861: LD_VAR 0 1
67865: PPUSH
67866: LD_INT 52
67868: PPUSH
67869: CALL_OW 321
67873: PUSH
67874: LD_INT 2
67876: EQUAL
67877: AND
67878: IFFALSE 67895
// bpoints := bpoints * 1.2 ;
67880: LD_ADDR_VAR 0 10
67884: PUSH
67885: LD_VAR 0 10
67889: PUSH
67890: LD_REAL  1.20000000000000E+0000
67893: MUL
67894: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
67895: LD_VAR 0 6
67899: PPUSH
67900: CALL_OW 264
67904: PUSH
67905: LD_INT 6
67907: PUSH
67908: LD_INT 46
67910: PUSH
67911: LD_INT 47
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: LIST
67918: IN
67919: IFFALSE 67936
// bpoints := bpoints * 1.2 ;
67921: LD_ADDR_VAR 0 10
67925: PUSH
67926: LD_VAR 0 10
67930: PUSH
67931: LD_REAL  1.20000000000000E+0000
67934: MUL
67935: ST_TO_ADDR
// end ; unit_building :
67936: GO 67950
67938: LD_INT 3
67940: DOUBLE
67941: EQUAL
67942: IFTRUE 67946
67944: GO 67949
67946: POP
// ; end ;
67947: GO 67950
67949: POP
// for j = 1 to 3 do
67950: LD_ADDR_VAR 0 7
67954: PUSH
67955: DOUBLE
67956: LD_INT 1
67958: DEC
67959: ST_TO_ADDR
67960: LD_INT 3
67962: PUSH
67963: FOR_TO
67964: IFFALSE 68017
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
67966: LD_ADDR_VAR 0 5
67970: PUSH
67971: LD_VAR 0 5
67975: PPUSH
67976: LD_VAR 0 7
67980: PPUSH
67981: LD_VAR 0 5
67985: PUSH
67986: LD_VAR 0 7
67990: ARRAY
67991: PUSH
67992: LD_VAR 0 9
67996: PUSH
67997: LD_VAR 0 7
68001: ARRAY
68002: PUSH
68003: LD_VAR 0 10
68007: MUL
68008: PLUS
68009: PPUSH
68010: CALL_OW 1
68014: ST_TO_ADDR
68015: GO 67963
68017: POP
68018: POP
// end ;
68019: GO 66502
68021: POP
68022: POP
// result := Replace ( result , 4 , tmp ) ;
68023: LD_ADDR_VAR 0 5
68027: PUSH
68028: LD_VAR 0 5
68032: PPUSH
68033: LD_INT 4
68035: PPUSH
68036: LD_VAR 0 8
68040: PPUSH
68041: CALL_OW 1
68045: ST_TO_ADDR
// end ;
68046: LD_VAR 0 5
68050: RET
// export function DangerAtRange ( unit , range ) ; begin
68051: LD_INT 0
68053: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68054: LD_ADDR_VAR 0 3
68058: PUSH
68059: LD_VAR 0 1
68063: PPUSH
68064: CALL_OW 255
68068: PPUSH
68069: LD_VAR 0 1
68073: PPUSH
68074: CALL_OW 250
68078: PPUSH
68079: LD_VAR 0 1
68083: PPUSH
68084: CALL_OW 251
68088: PPUSH
68089: LD_VAR 0 2
68093: PPUSH
68094: CALL 66354 0 4
68098: ST_TO_ADDR
// end ;
68099: LD_VAR 0 3
68103: RET
// export function DangerInArea ( side , area ) ; begin
68104: LD_INT 0
68106: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68107: LD_ADDR_VAR 0 3
68111: PUSH
68112: LD_VAR 0 2
68116: PPUSH
68117: LD_INT 81
68119: PUSH
68120: LD_VAR 0 1
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PPUSH
68129: CALL_OW 70
68133: ST_TO_ADDR
// end ;
68134: LD_VAR 0 3
68138: RET
// export function IsExtension ( b ) ; begin
68139: LD_INT 0
68141: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68142: LD_ADDR_VAR 0 2
68146: PUSH
68147: LD_VAR 0 1
68151: PUSH
68152: LD_INT 23
68154: PUSH
68155: LD_INT 20
68157: PUSH
68158: LD_INT 22
68160: PUSH
68161: LD_INT 17
68163: PUSH
68164: LD_INT 24
68166: PUSH
68167: LD_INT 21
68169: PUSH
68170: LD_INT 19
68172: PUSH
68173: LD_INT 16
68175: PUSH
68176: LD_INT 25
68178: PUSH
68179: LD_INT 18
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: LIST
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: LIST
68193: IN
68194: ST_TO_ADDR
// end ;
68195: LD_VAR 0 2
68199: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
68200: LD_INT 0
68202: PPUSH
68203: PPUSH
68204: PPUSH
// result := [ ] ;
68205: LD_ADDR_VAR 0 4
68209: PUSH
68210: EMPTY
68211: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68212: LD_ADDR_VAR 0 5
68216: PUSH
68217: LD_VAR 0 2
68221: PPUSH
68222: LD_INT 21
68224: PUSH
68225: LD_INT 3
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PPUSH
68232: CALL_OW 70
68236: ST_TO_ADDR
// if not tmp then
68237: LD_VAR 0 5
68241: NOT
68242: IFFALSE 68246
// exit ;
68244: GO 68310
// if checkLink then
68246: LD_VAR 0 3
68250: IFFALSE 68300
// begin for i in tmp do
68252: LD_ADDR_VAR 0 6
68256: PUSH
68257: LD_VAR 0 5
68261: PUSH
68262: FOR_IN
68263: IFFALSE 68298
// if GetBase ( i ) <> base then
68265: LD_VAR 0 6
68269: PPUSH
68270: CALL_OW 274
68274: PUSH
68275: LD_VAR 0 1
68279: NONEQUAL
68280: IFFALSE 68296
// ComLinkToBase ( base , i ) ;
68282: LD_VAR 0 1
68286: PPUSH
68287: LD_VAR 0 6
68291: PPUSH
68292: CALL_OW 169
68296: GO 68262
68298: POP
68299: POP
// end ; result := tmp ;
68300: LD_ADDR_VAR 0 4
68304: PUSH
68305: LD_VAR 0 5
68309: ST_TO_ADDR
// end ;
68310: LD_VAR 0 4
68314: RET
// export function ComComplete ( units , b ) ; var i ; begin
68315: LD_INT 0
68317: PPUSH
68318: PPUSH
// if not units then
68319: LD_VAR 0 1
68323: NOT
68324: IFFALSE 68328
// exit ;
68326: GO 68418
// for i in units do
68328: LD_ADDR_VAR 0 4
68332: PUSH
68333: LD_VAR 0 1
68337: PUSH
68338: FOR_IN
68339: IFFALSE 68416
// if BuildingStatus ( b ) = bs_build then
68341: LD_VAR 0 2
68345: PPUSH
68346: CALL_OW 461
68350: PUSH
68351: LD_INT 1
68353: EQUAL
68354: IFFALSE 68414
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
68356: LD_VAR 0 4
68360: PPUSH
68361: LD_STRING h
68363: PUSH
68364: LD_VAR 0 2
68368: PPUSH
68369: CALL_OW 250
68373: PUSH
68374: LD_VAR 0 2
68378: PPUSH
68379: CALL_OW 251
68383: PUSH
68384: LD_VAR 0 2
68388: PUSH
68389: LD_INT 0
68391: PUSH
68392: LD_INT 0
68394: PUSH
68395: LD_INT 0
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: PUSH
68407: EMPTY
68408: LIST
68409: PPUSH
68410: CALL_OW 446
68414: GO 68338
68416: POP
68417: POP
// end ;
68418: LD_VAR 0 3
68422: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
68423: LD_INT 0
68425: PPUSH
68426: PPUSH
68427: PPUSH
68428: PPUSH
68429: PPUSH
68430: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
68431: LD_VAR 0 1
68435: NOT
68436: PUSH
68437: LD_VAR 0 1
68441: PPUSH
68442: CALL_OW 263
68446: PUSH
68447: LD_INT 2
68449: EQUAL
68450: NOT
68451: OR
68452: IFFALSE 68456
// exit ;
68454: GO 68772
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
68456: LD_ADDR_VAR 0 6
68460: PUSH
68461: LD_INT 22
68463: PUSH
68464: LD_VAR 0 1
68468: PPUSH
68469: CALL_OW 255
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 2
68480: PUSH
68481: LD_INT 30
68483: PUSH
68484: LD_INT 36
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 34
68493: PUSH
68494: LD_INT 31
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: LIST
68505: PUSH
68506: EMPTY
68507: LIST
68508: LIST
68509: PPUSH
68510: CALL_OW 69
68514: ST_TO_ADDR
// if not tmp then
68515: LD_VAR 0 6
68519: NOT
68520: IFFALSE 68524
// exit ;
68522: GO 68772
// result := [ ] ;
68524: LD_ADDR_VAR 0 2
68528: PUSH
68529: EMPTY
68530: ST_TO_ADDR
// for i in tmp do
68531: LD_ADDR_VAR 0 3
68535: PUSH
68536: LD_VAR 0 6
68540: PUSH
68541: FOR_IN
68542: IFFALSE 68613
// begin t := UnitsInside ( i ) ;
68544: LD_ADDR_VAR 0 4
68548: PUSH
68549: LD_VAR 0 3
68553: PPUSH
68554: CALL_OW 313
68558: ST_TO_ADDR
// if t then
68559: LD_VAR 0 4
68563: IFFALSE 68611
// for j in t do
68565: LD_ADDR_VAR 0 7
68569: PUSH
68570: LD_VAR 0 4
68574: PUSH
68575: FOR_IN
68576: IFFALSE 68609
// result := Insert ( result , result + 1 , j ) ;
68578: LD_ADDR_VAR 0 2
68582: PUSH
68583: LD_VAR 0 2
68587: PPUSH
68588: LD_VAR 0 2
68592: PUSH
68593: LD_INT 1
68595: PLUS
68596: PPUSH
68597: LD_VAR 0 7
68601: PPUSH
68602: CALL_OW 2
68606: ST_TO_ADDR
68607: GO 68575
68609: POP
68610: POP
// end ;
68611: GO 68541
68613: POP
68614: POP
// if not result then
68615: LD_VAR 0 2
68619: NOT
68620: IFFALSE 68624
// exit ;
68622: GO 68772
// mech := result [ 1 ] ;
68624: LD_ADDR_VAR 0 5
68628: PUSH
68629: LD_VAR 0 2
68633: PUSH
68634: LD_INT 1
68636: ARRAY
68637: ST_TO_ADDR
// if result > 1 then
68638: LD_VAR 0 2
68642: PUSH
68643: LD_INT 1
68645: GREATER
68646: IFFALSE 68758
// for i = 2 to result do
68648: LD_ADDR_VAR 0 3
68652: PUSH
68653: DOUBLE
68654: LD_INT 2
68656: DEC
68657: ST_TO_ADDR
68658: LD_VAR 0 2
68662: PUSH
68663: FOR_TO
68664: IFFALSE 68756
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
68666: LD_ADDR_VAR 0 4
68670: PUSH
68671: LD_VAR 0 2
68675: PUSH
68676: LD_VAR 0 3
68680: ARRAY
68681: PPUSH
68682: LD_INT 3
68684: PPUSH
68685: CALL_OW 259
68689: PUSH
68690: LD_VAR 0 2
68694: PUSH
68695: LD_VAR 0 3
68699: ARRAY
68700: PPUSH
68701: CALL_OW 432
68705: MINUS
68706: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
68707: LD_VAR 0 4
68711: PUSH
68712: LD_VAR 0 5
68716: PPUSH
68717: LD_INT 3
68719: PPUSH
68720: CALL_OW 259
68724: PUSH
68725: LD_VAR 0 5
68729: PPUSH
68730: CALL_OW 432
68734: MINUS
68735: GREATEREQUAL
68736: IFFALSE 68754
// mech := result [ i ] ;
68738: LD_ADDR_VAR 0 5
68742: PUSH
68743: LD_VAR 0 2
68747: PUSH
68748: LD_VAR 0 3
68752: ARRAY
68753: ST_TO_ADDR
// end ;
68754: GO 68663
68756: POP
68757: POP
// ComLinkTo ( vehicle , mech ) ;
68758: LD_VAR 0 1
68762: PPUSH
68763: LD_VAR 0 5
68767: PPUSH
68768: CALL_OW 135
// end ;
68772: LD_VAR 0 2
68776: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
68777: LD_INT 0
68779: PPUSH
68780: PPUSH
68781: PPUSH
68782: PPUSH
68783: PPUSH
68784: PPUSH
68785: PPUSH
68786: PPUSH
68787: PPUSH
68788: PPUSH
68789: PPUSH
68790: PPUSH
68791: PPUSH
// result := [ ] ;
68792: LD_ADDR_VAR 0 7
68796: PUSH
68797: EMPTY
68798: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
68799: LD_VAR 0 1
68803: PPUSH
68804: CALL_OW 266
68808: PUSH
68809: LD_INT 0
68811: PUSH
68812: LD_INT 1
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: IN
68819: NOT
68820: IFFALSE 68824
// exit ;
68822: GO 70458
// if name then
68824: LD_VAR 0 3
68828: IFFALSE 68844
// SetBName ( base_dep , name ) ;
68830: LD_VAR 0 1
68834: PPUSH
68835: LD_VAR 0 3
68839: PPUSH
68840: CALL_OW 500
// base := GetBase ( base_dep ) ;
68844: LD_ADDR_VAR 0 15
68848: PUSH
68849: LD_VAR 0 1
68853: PPUSH
68854: CALL_OW 274
68858: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
68859: LD_ADDR_VAR 0 16
68863: PUSH
68864: LD_VAR 0 1
68868: PPUSH
68869: CALL_OW 255
68873: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
68874: LD_ADDR_VAR 0 17
68878: PUSH
68879: LD_VAR 0 1
68883: PPUSH
68884: CALL_OW 248
68888: ST_TO_ADDR
// if sources then
68889: LD_VAR 0 5
68893: IFFALSE 68940
// for i = 1 to 3 do
68895: LD_ADDR_VAR 0 8
68899: PUSH
68900: DOUBLE
68901: LD_INT 1
68903: DEC
68904: ST_TO_ADDR
68905: LD_INT 3
68907: PUSH
68908: FOR_TO
68909: IFFALSE 68938
// AddResourceType ( base , i , sources [ i ] ) ;
68911: LD_VAR 0 15
68915: PPUSH
68916: LD_VAR 0 8
68920: PPUSH
68921: LD_VAR 0 5
68925: PUSH
68926: LD_VAR 0 8
68930: ARRAY
68931: PPUSH
68932: CALL_OW 276
68936: GO 68908
68938: POP
68939: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
68940: LD_ADDR_VAR 0 18
68944: PUSH
68945: LD_VAR 0 15
68949: PPUSH
68950: LD_VAR 0 2
68954: PPUSH
68955: LD_INT 1
68957: PPUSH
68958: CALL 68200 0 3
68962: ST_TO_ADDR
// InitHc ;
68963: CALL_OW 19
// InitUc ;
68967: CALL_OW 18
// uc_side := side ;
68971: LD_ADDR_OWVAR 20
68975: PUSH
68976: LD_VAR 0 16
68980: ST_TO_ADDR
// uc_nation := nation ;
68981: LD_ADDR_OWVAR 21
68985: PUSH
68986: LD_VAR 0 17
68990: ST_TO_ADDR
// if buildings then
68991: LD_VAR 0 18
68995: IFFALSE 70317
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
68997: LD_ADDR_VAR 0 19
69001: PUSH
69002: LD_VAR 0 18
69006: PPUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 30
69012: PUSH
69013: LD_INT 29
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 30
69022: PUSH
69023: LD_INT 30
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: LIST
69034: PPUSH
69035: CALL_OW 72
69039: ST_TO_ADDR
// if tmp then
69040: LD_VAR 0 19
69044: IFFALSE 69092
// for i in tmp do
69046: LD_ADDR_VAR 0 8
69050: PUSH
69051: LD_VAR 0 19
69055: PUSH
69056: FOR_IN
69057: IFFALSE 69090
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69059: LD_VAR 0 8
69063: PPUSH
69064: CALL_OW 250
69068: PPUSH
69069: LD_VAR 0 8
69073: PPUSH
69074: CALL_OW 251
69078: PPUSH
69079: LD_VAR 0 16
69083: PPUSH
69084: CALL_OW 441
69088: GO 69056
69090: POP
69091: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69092: LD_VAR 0 18
69096: PPUSH
69097: LD_INT 2
69099: PUSH
69100: LD_INT 30
69102: PUSH
69103: LD_INT 32
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 30
69112: PUSH
69113: LD_INT 33
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: LIST
69124: PPUSH
69125: CALL_OW 72
69129: IFFALSE 69217
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69131: LD_ADDR_VAR 0 8
69135: PUSH
69136: LD_VAR 0 18
69140: PPUSH
69141: LD_INT 2
69143: PUSH
69144: LD_INT 30
69146: PUSH
69147: LD_INT 32
69149: PUSH
69150: EMPTY
69151: LIST
69152: LIST
69153: PUSH
69154: LD_INT 30
69156: PUSH
69157: LD_INT 33
69159: PUSH
69160: EMPTY
69161: LIST
69162: LIST
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: LIST
69168: PPUSH
69169: CALL_OW 72
69173: PUSH
69174: FOR_IN
69175: IFFALSE 69215
// begin if not GetBWeapon ( i ) then
69177: LD_VAR 0 8
69181: PPUSH
69182: CALL_OW 269
69186: NOT
69187: IFFALSE 69213
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69189: LD_VAR 0 8
69193: PPUSH
69194: LD_VAR 0 8
69198: PPUSH
69199: LD_VAR 0 2
69203: PPUSH
69204: CALL 70463 0 2
69208: PPUSH
69209: CALL_OW 431
// end ;
69213: GO 69174
69215: POP
69216: POP
// end ; for i = 1 to personel do
69217: LD_ADDR_VAR 0 8
69221: PUSH
69222: DOUBLE
69223: LD_INT 1
69225: DEC
69226: ST_TO_ADDR
69227: LD_VAR 0 6
69231: PUSH
69232: FOR_TO
69233: IFFALSE 70297
// begin if i > 4 then
69235: LD_VAR 0 8
69239: PUSH
69240: LD_INT 4
69242: GREATER
69243: IFFALSE 69247
// break ;
69245: GO 70297
// case i of 1 :
69247: LD_VAR 0 8
69251: PUSH
69252: LD_INT 1
69254: DOUBLE
69255: EQUAL
69256: IFTRUE 69260
69258: GO 69340
69260: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
69261: LD_ADDR_VAR 0 12
69265: PUSH
69266: LD_VAR 0 18
69270: PPUSH
69271: LD_INT 22
69273: PUSH
69274: LD_VAR 0 16
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 58
69285: PUSH
69286: EMPTY
69287: LIST
69288: PUSH
69289: LD_INT 2
69291: PUSH
69292: LD_INT 30
69294: PUSH
69295: LD_INT 32
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 30
69304: PUSH
69305: LD_INT 4
69307: PUSH
69308: EMPTY
69309: LIST
69310: LIST
69311: PUSH
69312: LD_INT 30
69314: PUSH
69315: LD_INT 5
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: LIST
69332: PPUSH
69333: CALL_OW 72
69337: ST_TO_ADDR
69338: GO 69562
69340: LD_INT 2
69342: DOUBLE
69343: EQUAL
69344: IFTRUE 69348
69346: GO 69410
69348: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
69349: LD_ADDR_VAR 0 12
69353: PUSH
69354: LD_VAR 0 18
69358: PPUSH
69359: LD_INT 22
69361: PUSH
69362: LD_VAR 0 16
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 2
69373: PUSH
69374: LD_INT 30
69376: PUSH
69377: LD_INT 0
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 30
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: LIST
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PPUSH
69403: CALL_OW 72
69407: ST_TO_ADDR
69408: GO 69562
69410: LD_INT 3
69412: DOUBLE
69413: EQUAL
69414: IFTRUE 69418
69416: GO 69480
69418: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
69419: LD_ADDR_VAR 0 12
69423: PUSH
69424: LD_VAR 0 18
69428: PPUSH
69429: LD_INT 22
69431: PUSH
69432: LD_VAR 0 16
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 2
69443: PUSH
69444: LD_INT 30
69446: PUSH
69447: LD_INT 2
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: PUSH
69454: LD_INT 30
69456: PUSH
69457: LD_INT 3
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: LIST
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: PPUSH
69473: CALL_OW 72
69477: ST_TO_ADDR
69478: GO 69562
69480: LD_INT 4
69482: DOUBLE
69483: EQUAL
69484: IFTRUE 69488
69486: GO 69561
69488: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
69489: LD_ADDR_VAR 0 12
69493: PUSH
69494: LD_VAR 0 18
69498: PPUSH
69499: LD_INT 22
69501: PUSH
69502: LD_VAR 0 16
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 2
69513: PUSH
69514: LD_INT 30
69516: PUSH
69517: LD_INT 6
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 30
69526: PUSH
69527: LD_INT 7
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 30
69536: PUSH
69537: LD_INT 8
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PPUSH
69554: CALL_OW 72
69558: ST_TO_ADDR
69559: GO 69562
69561: POP
// if i = 1 then
69562: LD_VAR 0 8
69566: PUSH
69567: LD_INT 1
69569: EQUAL
69570: IFFALSE 69681
// begin tmp := [ ] ;
69572: LD_ADDR_VAR 0 19
69576: PUSH
69577: EMPTY
69578: ST_TO_ADDR
// for j in f do
69579: LD_ADDR_VAR 0 9
69583: PUSH
69584: LD_VAR 0 12
69588: PUSH
69589: FOR_IN
69590: IFFALSE 69663
// if GetBType ( j ) = b_bunker then
69592: LD_VAR 0 9
69596: PPUSH
69597: CALL_OW 266
69601: PUSH
69602: LD_INT 32
69604: EQUAL
69605: IFFALSE 69632
// tmp := Insert ( tmp , 1 , j ) else
69607: LD_ADDR_VAR 0 19
69611: PUSH
69612: LD_VAR 0 19
69616: PPUSH
69617: LD_INT 1
69619: PPUSH
69620: LD_VAR 0 9
69624: PPUSH
69625: CALL_OW 2
69629: ST_TO_ADDR
69630: GO 69661
// tmp := Insert ( tmp , tmp + 1 , j ) ;
69632: LD_ADDR_VAR 0 19
69636: PUSH
69637: LD_VAR 0 19
69641: PPUSH
69642: LD_VAR 0 19
69646: PUSH
69647: LD_INT 1
69649: PLUS
69650: PPUSH
69651: LD_VAR 0 9
69655: PPUSH
69656: CALL_OW 2
69660: ST_TO_ADDR
69661: GO 69589
69663: POP
69664: POP
// if tmp then
69665: LD_VAR 0 19
69669: IFFALSE 69681
// f := tmp ;
69671: LD_ADDR_VAR 0 12
69675: PUSH
69676: LD_VAR 0 19
69680: ST_TO_ADDR
// end ; x := personel [ i ] ;
69681: LD_ADDR_VAR 0 13
69685: PUSH
69686: LD_VAR 0 6
69690: PUSH
69691: LD_VAR 0 8
69695: ARRAY
69696: ST_TO_ADDR
// if x = - 1 then
69697: LD_VAR 0 13
69701: PUSH
69702: LD_INT 1
69704: NEG
69705: EQUAL
69706: IFFALSE 69915
// begin for j in f do
69708: LD_ADDR_VAR 0 9
69712: PUSH
69713: LD_VAR 0 12
69717: PUSH
69718: FOR_IN
69719: IFFALSE 69911
// repeat InitHc ;
69721: CALL_OW 19
// if GetBType ( j ) = b_barracks then
69725: LD_VAR 0 9
69729: PPUSH
69730: CALL_OW 266
69734: PUSH
69735: LD_INT 5
69737: EQUAL
69738: IFFALSE 69808
// begin if UnitsInside ( j ) < 3 then
69740: LD_VAR 0 9
69744: PPUSH
69745: CALL_OW 313
69749: PUSH
69750: LD_INT 3
69752: LESS
69753: IFFALSE 69789
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
69755: LD_INT 0
69757: PPUSH
69758: LD_INT 5
69760: PUSH
69761: LD_INT 8
69763: PUSH
69764: LD_INT 9
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: LIST
69771: PUSH
69772: LD_VAR 0 17
69776: ARRAY
69777: PPUSH
69778: LD_VAR 0 4
69782: PPUSH
69783: CALL_OW 380
69787: GO 69806
// PrepareHuman ( false , i , skill ) ;
69789: LD_INT 0
69791: PPUSH
69792: LD_VAR 0 8
69796: PPUSH
69797: LD_VAR 0 4
69801: PPUSH
69802: CALL_OW 380
// end else
69806: GO 69825
// PrepareHuman ( false , i , skill ) ;
69808: LD_INT 0
69810: PPUSH
69811: LD_VAR 0 8
69815: PPUSH
69816: LD_VAR 0 4
69820: PPUSH
69821: CALL_OW 380
// un := CreateHuman ;
69825: LD_ADDR_VAR 0 14
69829: PUSH
69830: CALL_OW 44
69834: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69835: LD_ADDR_VAR 0 7
69839: PUSH
69840: LD_VAR 0 7
69844: PPUSH
69845: LD_INT 1
69847: PPUSH
69848: LD_VAR 0 14
69852: PPUSH
69853: CALL_OW 2
69857: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
69858: LD_VAR 0 14
69862: PPUSH
69863: LD_VAR 0 9
69867: PPUSH
69868: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
69872: LD_VAR 0 9
69876: PPUSH
69877: CALL_OW 313
69881: PUSH
69882: LD_INT 6
69884: EQUAL
69885: PUSH
69886: LD_VAR 0 9
69890: PPUSH
69891: CALL_OW 266
69895: PUSH
69896: LD_INT 32
69898: PUSH
69899: LD_INT 31
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: IN
69906: OR
69907: IFFALSE 69721
69909: GO 69718
69911: POP
69912: POP
// end else
69913: GO 70295
// for j = 1 to x do
69915: LD_ADDR_VAR 0 9
69919: PUSH
69920: DOUBLE
69921: LD_INT 1
69923: DEC
69924: ST_TO_ADDR
69925: LD_VAR 0 13
69929: PUSH
69930: FOR_TO
69931: IFFALSE 70293
// begin InitHc ;
69933: CALL_OW 19
// if not f then
69937: LD_VAR 0 12
69941: NOT
69942: IFFALSE 70031
// begin PrepareHuman ( false , i , skill ) ;
69944: LD_INT 0
69946: PPUSH
69947: LD_VAR 0 8
69951: PPUSH
69952: LD_VAR 0 4
69956: PPUSH
69957: CALL_OW 380
// un := CreateHuman ;
69961: LD_ADDR_VAR 0 14
69965: PUSH
69966: CALL_OW 44
69970: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
69971: LD_ADDR_VAR 0 7
69975: PUSH
69976: LD_VAR 0 7
69980: PPUSH
69981: LD_INT 1
69983: PPUSH
69984: LD_VAR 0 14
69988: PPUSH
69989: CALL_OW 2
69993: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
69994: LD_VAR 0 14
69998: PPUSH
69999: LD_VAR 0 1
70003: PPUSH
70004: CALL_OW 250
70008: PPUSH
70009: LD_VAR 0 1
70013: PPUSH
70014: CALL_OW 251
70018: PPUSH
70019: LD_INT 10
70021: PPUSH
70022: LD_INT 0
70024: PPUSH
70025: CALL_OW 50
// continue ;
70029: GO 69930
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70031: LD_VAR 0 12
70035: PUSH
70036: LD_INT 1
70038: ARRAY
70039: PPUSH
70040: CALL_OW 313
70044: PUSH
70045: LD_VAR 0 12
70049: PUSH
70050: LD_INT 1
70052: ARRAY
70053: PPUSH
70054: CALL_OW 266
70058: PUSH
70059: LD_INT 32
70061: PUSH
70062: LD_INT 31
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: IN
70069: AND
70070: PUSH
70071: LD_VAR 0 12
70075: PUSH
70076: LD_INT 1
70078: ARRAY
70079: PPUSH
70080: CALL_OW 313
70084: PUSH
70085: LD_INT 6
70087: EQUAL
70088: OR
70089: IFFALSE 70109
// f := Delete ( f , 1 ) ;
70091: LD_ADDR_VAR 0 12
70095: PUSH
70096: LD_VAR 0 12
70100: PPUSH
70101: LD_INT 1
70103: PPUSH
70104: CALL_OW 3
70108: ST_TO_ADDR
// if not f then
70109: LD_VAR 0 12
70113: NOT
70114: IFFALSE 70132
// begin x := x + 2 ;
70116: LD_ADDR_VAR 0 13
70120: PUSH
70121: LD_VAR 0 13
70125: PUSH
70126: LD_INT 2
70128: PLUS
70129: ST_TO_ADDR
// continue ;
70130: GO 69930
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70132: LD_VAR 0 12
70136: PUSH
70137: LD_INT 1
70139: ARRAY
70140: PPUSH
70141: CALL_OW 266
70145: PUSH
70146: LD_INT 5
70148: EQUAL
70149: IFFALSE 70223
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70151: LD_VAR 0 12
70155: PUSH
70156: LD_INT 1
70158: ARRAY
70159: PPUSH
70160: CALL_OW 313
70164: PUSH
70165: LD_INT 3
70167: LESS
70168: IFFALSE 70204
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70170: LD_INT 0
70172: PPUSH
70173: LD_INT 5
70175: PUSH
70176: LD_INT 8
70178: PUSH
70179: LD_INT 9
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: LIST
70186: PUSH
70187: LD_VAR 0 17
70191: ARRAY
70192: PPUSH
70193: LD_VAR 0 4
70197: PPUSH
70198: CALL_OW 380
70202: GO 70221
// PrepareHuman ( false , i , skill ) ;
70204: LD_INT 0
70206: PPUSH
70207: LD_VAR 0 8
70211: PPUSH
70212: LD_VAR 0 4
70216: PPUSH
70217: CALL_OW 380
// end else
70221: GO 70240
// PrepareHuman ( false , i , skill ) ;
70223: LD_INT 0
70225: PPUSH
70226: LD_VAR 0 8
70230: PPUSH
70231: LD_VAR 0 4
70235: PPUSH
70236: CALL_OW 380
// un := CreateHuman ;
70240: LD_ADDR_VAR 0 14
70244: PUSH
70245: CALL_OW 44
70249: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70250: LD_ADDR_VAR 0 7
70254: PUSH
70255: LD_VAR 0 7
70259: PPUSH
70260: LD_INT 1
70262: PPUSH
70263: LD_VAR 0 14
70267: PPUSH
70268: CALL_OW 2
70272: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
70273: LD_VAR 0 14
70277: PPUSH
70278: LD_VAR 0 12
70282: PUSH
70283: LD_INT 1
70285: ARRAY
70286: PPUSH
70287: CALL_OW 52
// end ;
70291: GO 69930
70293: POP
70294: POP
// end ;
70295: GO 69232
70297: POP
70298: POP
// result := result ^ buildings ;
70299: LD_ADDR_VAR 0 7
70303: PUSH
70304: LD_VAR 0 7
70308: PUSH
70309: LD_VAR 0 18
70313: ADD
70314: ST_TO_ADDR
// end else
70315: GO 70458
// begin for i = 1 to personel do
70317: LD_ADDR_VAR 0 8
70321: PUSH
70322: DOUBLE
70323: LD_INT 1
70325: DEC
70326: ST_TO_ADDR
70327: LD_VAR 0 6
70331: PUSH
70332: FOR_TO
70333: IFFALSE 70456
// begin if i > 4 then
70335: LD_VAR 0 8
70339: PUSH
70340: LD_INT 4
70342: GREATER
70343: IFFALSE 70347
// break ;
70345: GO 70456
// x := personel [ i ] ;
70347: LD_ADDR_VAR 0 13
70351: PUSH
70352: LD_VAR 0 6
70356: PUSH
70357: LD_VAR 0 8
70361: ARRAY
70362: ST_TO_ADDR
// if x = - 1 then
70363: LD_VAR 0 13
70367: PUSH
70368: LD_INT 1
70370: NEG
70371: EQUAL
70372: IFFALSE 70376
// continue ;
70374: GO 70332
// PrepareHuman ( false , i , skill ) ;
70376: LD_INT 0
70378: PPUSH
70379: LD_VAR 0 8
70383: PPUSH
70384: LD_VAR 0 4
70388: PPUSH
70389: CALL_OW 380
// un := CreateHuman ;
70393: LD_ADDR_VAR 0 14
70397: PUSH
70398: CALL_OW 44
70402: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70403: LD_VAR 0 14
70407: PPUSH
70408: LD_VAR 0 1
70412: PPUSH
70413: CALL_OW 250
70417: PPUSH
70418: LD_VAR 0 1
70422: PPUSH
70423: CALL_OW 251
70427: PPUSH
70428: LD_INT 10
70430: PPUSH
70431: LD_INT 0
70433: PPUSH
70434: CALL_OW 50
// result := result ^ un ;
70438: LD_ADDR_VAR 0 7
70442: PUSH
70443: LD_VAR 0 7
70447: PUSH
70448: LD_VAR 0 14
70452: ADD
70453: ST_TO_ADDR
// end ;
70454: GO 70332
70456: POP
70457: POP
// end ; end ;
70458: LD_VAR 0 7
70462: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
70463: LD_INT 0
70465: PPUSH
70466: PPUSH
70467: PPUSH
70468: PPUSH
70469: PPUSH
70470: PPUSH
70471: PPUSH
70472: PPUSH
70473: PPUSH
70474: PPUSH
70475: PPUSH
70476: PPUSH
70477: PPUSH
70478: PPUSH
70479: PPUSH
70480: PPUSH
// result := false ;
70481: LD_ADDR_VAR 0 3
70485: PUSH
70486: LD_INT 0
70488: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
70489: LD_VAR 0 1
70493: NOT
70494: PUSH
70495: LD_VAR 0 1
70499: PPUSH
70500: CALL_OW 266
70504: PUSH
70505: LD_INT 32
70507: PUSH
70508: LD_INT 33
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: IN
70515: NOT
70516: OR
70517: IFFALSE 70521
// exit ;
70519: GO 71660
// nat := GetNation ( tower ) ;
70521: LD_ADDR_VAR 0 12
70525: PUSH
70526: LD_VAR 0 1
70530: PPUSH
70531: CALL_OW 248
70535: ST_TO_ADDR
// side := GetSide ( tower ) ;
70536: LD_ADDR_VAR 0 16
70540: PUSH
70541: LD_VAR 0 1
70545: PPUSH
70546: CALL_OW 255
70550: ST_TO_ADDR
// x := GetX ( tower ) ;
70551: LD_ADDR_VAR 0 10
70555: PUSH
70556: LD_VAR 0 1
70560: PPUSH
70561: CALL_OW 250
70565: ST_TO_ADDR
// y := GetY ( tower ) ;
70566: LD_ADDR_VAR 0 11
70570: PUSH
70571: LD_VAR 0 1
70575: PPUSH
70576: CALL_OW 251
70580: ST_TO_ADDR
// if not x or not y then
70581: LD_VAR 0 10
70585: NOT
70586: PUSH
70587: LD_VAR 0 11
70591: NOT
70592: OR
70593: IFFALSE 70597
// exit ;
70595: GO 71660
// weapon := 0 ;
70597: LD_ADDR_VAR 0 18
70601: PUSH
70602: LD_INT 0
70604: ST_TO_ADDR
// fac_list := [ ] ;
70605: LD_ADDR_VAR 0 17
70609: PUSH
70610: EMPTY
70611: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
70612: LD_ADDR_VAR 0 6
70616: PUSH
70617: LD_VAR 0 1
70621: PPUSH
70622: CALL_OW 274
70626: PPUSH
70627: LD_VAR 0 2
70631: PPUSH
70632: LD_INT 0
70634: PPUSH
70635: CALL 68200 0 3
70639: PPUSH
70640: LD_INT 30
70642: PUSH
70643: LD_INT 3
70645: PUSH
70646: EMPTY
70647: LIST
70648: LIST
70649: PPUSH
70650: CALL_OW 72
70654: ST_TO_ADDR
// if not factories then
70655: LD_VAR 0 6
70659: NOT
70660: IFFALSE 70664
// exit ;
70662: GO 71660
// for i in factories do
70664: LD_ADDR_VAR 0 8
70668: PUSH
70669: LD_VAR 0 6
70673: PUSH
70674: FOR_IN
70675: IFFALSE 70700
// fac_list := fac_list union AvailableWeaponList ( i ) ;
70677: LD_ADDR_VAR 0 17
70681: PUSH
70682: LD_VAR 0 17
70686: PUSH
70687: LD_VAR 0 8
70691: PPUSH
70692: CALL_OW 478
70696: UNION
70697: ST_TO_ADDR
70698: GO 70674
70700: POP
70701: POP
// if not fac_list then
70702: LD_VAR 0 17
70706: NOT
70707: IFFALSE 70711
// exit ;
70709: GO 71660
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
70711: LD_ADDR_VAR 0 5
70715: PUSH
70716: LD_INT 4
70718: PUSH
70719: LD_INT 5
70721: PUSH
70722: LD_INT 9
70724: PUSH
70725: LD_INT 10
70727: PUSH
70728: LD_INT 6
70730: PUSH
70731: LD_INT 7
70733: PUSH
70734: LD_INT 11
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 27
70748: PUSH
70749: LD_INT 28
70751: PUSH
70752: LD_INT 26
70754: PUSH
70755: LD_INT 30
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: PUSH
70764: LD_INT 43
70766: PUSH
70767: LD_INT 44
70769: PUSH
70770: LD_INT 46
70772: PUSH
70773: LD_INT 45
70775: PUSH
70776: LD_INT 47
70778: PUSH
70779: LD_INT 49
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: LIST
70794: PUSH
70795: LD_VAR 0 12
70799: ARRAY
70800: ST_TO_ADDR
// for i in list do
70801: LD_ADDR_VAR 0 8
70805: PUSH
70806: LD_VAR 0 5
70810: PUSH
70811: FOR_IN
70812: IFFALSE 70845
// if not i in fac_list then
70814: LD_VAR 0 8
70818: PUSH
70819: LD_VAR 0 17
70823: IN
70824: NOT
70825: IFFALSE 70843
// list := list diff i ;
70827: LD_ADDR_VAR 0 5
70831: PUSH
70832: LD_VAR 0 5
70836: PUSH
70837: LD_VAR 0 8
70841: DIFF
70842: ST_TO_ADDR
70843: GO 70811
70845: POP
70846: POP
// if not list then
70847: LD_VAR 0 5
70851: NOT
70852: IFFALSE 70856
// exit ;
70854: GO 71660
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
70856: LD_VAR 0 12
70860: PUSH
70861: LD_INT 3
70863: EQUAL
70864: PUSH
70865: LD_INT 49
70867: PUSH
70868: LD_VAR 0 5
70872: IN
70873: AND
70874: PUSH
70875: LD_INT 31
70877: PPUSH
70878: LD_VAR 0 16
70882: PPUSH
70883: CALL_OW 321
70887: PUSH
70888: LD_INT 2
70890: EQUAL
70891: AND
70892: IFFALSE 70952
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
70894: LD_INT 22
70896: PUSH
70897: LD_VAR 0 16
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 35
70908: PUSH
70909: LD_INT 49
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 91
70918: PUSH
70919: LD_VAR 0 1
70923: PUSH
70924: LD_INT 10
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: LIST
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: LIST
70936: PPUSH
70937: CALL_OW 69
70941: NOT
70942: IFFALSE 70952
// weapon := ru_time_lapser ;
70944: LD_ADDR_VAR 0 18
70948: PUSH
70949: LD_INT 49
70951: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
70952: LD_VAR 0 12
70956: PUSH
70957: LD_INT 1
70959: PUSH
70960: LD_INT 2
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: IN
70967: PUSH
70968: LD_INT 11
70970: PUSH
70971: LD_VAR 0 5
70975: IN
70976: PUSH
70977: LD_INT 30
70979: PUSH
70980: LD_VAR 0 5
70984: IN
70985: OR
70986: AND
70987: PUSH
70988: LD_INT 6
70990: PPUSH
70991: LD_VAR 0 16
70995: PPUSH
70996: CALL_OW 321
71000: PUSH
71001: LD_INT 2
71003: EQUAL
71004: AND
71005: IFFALSE 71170
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71007: LD_INT 22
71009: PUSH
71010: LD_VAR 0 16
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 2
71021: PUSH
71022: LD_INT 35
71024: PUSH
71025: LD_INT 11
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 35
71034: PUSH
71035: LD_INT 30
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 91
71049: PUSH
71050: LD_VAR 0 1
71054: PUSH
71055: LD_INT 18
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: LIST
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: LIST
71067: PPUSH
71068: CALL_OW 69
71072: NOT
71073: PUSH
71074: LD_INT 22
71076: PUSH
71077: LD_VAR 0 16
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: PUSH
71086: LD_INT 2
71088: PUSH
71089: LD_INT 30
71091: PUSH
71092: LD_INT 32
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: PUSH
71099: LD_INT 30
71101: PUSH
71102: LD_INT 33
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: LIST
71113: PUSH
71114: LD_INT 91
71116: PUSH
71117: LD_VAR 0 1
71121: PUSH
71122: LD_INT 12
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: LIST
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: LIST
71134: PUSH
71135: EMPTY
71136: LIST
71137: PPUSH
71138: CALL_OW 69
71142: PUSH
71143: LD_INT 2
71145: GREATER
71146: AND
71147: IFFALSE 71170
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71149: LD_ADDR_VAR 0 18
71153: PUSH
71154: LD_INT 11
71156: PUSH
71157: LD_INT 30
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_VAR 0 12
71168: ARRAY
71169: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71170: LD_VAR 0 18
71174: NOT
71175: PUSH
71176: LD_INT 40
71178: PPUSH
71179: LD_VAR 0 16
71183: PPUSH
71184: CALL_OW 321
71188: PUSH
71189: LD_INT 2
71191: EQUAL
71192: AND
71193: PUSH
71194: LD_INT 7
71196: PUSH
71197: LD_VAR 0 5
71201: IN
71202: PUSH
71203: LD_INT 28
71205: PUSH
71206: LD_VAR 0 5
71210: IN
71211: OR
71212: PUSH
71213: LD_INT 45
71215: PUSH
71216: LD_VAR 0 5
71220: IN
71221: OR
71222: AND
71223: IFFALSE 71477
// begin hex := GetHexInfo ( x , y ) ;
71225: LD_ADDR_VAR 0 4
71229: PUSH
71230: LD_VAR 0 10
71234: PPUSH
71235: LD_VAR 0 11
71239: PPUSH
71240: CALL_OW 546
71244: ST_TO_ADDR
// if hex [ 1 ] then
71245: LD_VAR 0 4
71249: PUSH
71250: LD_INT 1
71252: ARRAY
71253: IFFALSE 71257
// exit ;
71255: GO 71660
// height := hex [ 2 ] ;
71257: LD_ADDR_VAR 0 15
71261: PUSH
71262: LD_VAR 0 4
71266: PUSH
71267: LD_INT 2
71269: ARRAY
71270: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71271: LD_ADDR_VAR 0 14
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: LD_INT 2
71281: PUSH
71282: LD_INT 3
71284: PUSH
71285: LD_INT 5
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: ST_TO_ADDR
// for i in tmp do
71294: LD_ADDR_VAR 0 8
71298: PUSH
71299: LD_VAR 0 14
71303: PUSH
71304: FOR_IN
71305: IFFALSE 71475
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
71307: LD_ADDR_VAR 0 9
71311: PUSH
71312: LD_VAR 0 10
71316: PPUSH
71317: LD_VAR 0 8
71321: PPUSH
71322: LD_INT 5
71324: PPUSH
71325: CALL_OW 272
71329: PUSH
71330: LD_VAR 0 11
71334: PPUSH
71335: LD_VAR 0 8
71339: PPUSH
71340: LD_INT 5
71342: PPUSH
71343: CALL_OW 273
71347: PUSH
71348: EMPTY
71349: LIST
71350: LIST
71351: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
71352: LD_VAR 0 9
71356: PUSH
71357: LD_INT 1
71359: ARRAY
71360: PPUSH
71361: LD_VAR 0 9
71365: PUSH
71366: LD_INT 2
71368: ARRAY
71369: PPUSH
71370: CALL_OW 488
71374: IFFALSE 71473
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
71376: LD_ADDR_VAR 0 4
71380: PUSH
71381: LD_VAR 0 9
71385: PUSH
71386: LD_INT 1
71388: ARRAY
71389: PPUSH
71390: LD_VAR 0 9
71394: PUSH
71395: LD_INT 2
71397: ARRAY
71398: PPUSH
71399: CALL_OW 546
71403: ST_TO_ADDR
// if hex [ 1 ] then
71404: LD_VAR 0 4
71408: PUSH
71409: LD_INT 1
71411: ARRAY
71412: IFFALSE 71416
// continue ;
71414: GO 71304
// h := hex [ 2 ] ;
71416: LD_ADDR_VAR 0 13
71420: PUSH
71421: LD_VAR 0 4
71425: PUSH
71426: LD_INT 2
71428: ARRAY
71429: ST_TO_ADDR
// if h + 7 < height then
71430: LD_VAR 0 13
71434: PUSH
71435: LD_INT 7
71437: PLUS
71438: PUSH
71439: LD_VAR 0 15
71443: LESS
71444: IFFALSE 71473
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
71446: LD_ADDR_VAR 0 18
71450: PUSH
71451: LD_INT 7
71453: PUSH
71454: LD_INT 28
71456: PUSH
71457: LD_INT 45
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: LIST
71464: PUSH
71465: LD_VAR 0 12
71469: ARRAY
71470: ST_TO_ADDR
// break ;
71471: GO 71475
// end ; end ; end ;
71473: GO 71304
71475: POP
71476: POP
// end ; if not weapon then
71477: LD_VAR 0 18
71481: NOT
71482: IFFALSE 71542
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
71484: LD_ADDR_VAR 0 5
71488: PUSH
71489: LD_VAR 0 5
71493: PUSH
71494: LD_INT 11
71496: PUSH
71497: LD_INT 30
71499: PUSH
71500: LD_INT 49
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: LIST
71507: DIFF
71508: ST_TO_ADDR
// if not list then
71509: LD_VAR 0 5
71513: NOT
71514: IFFALSE 71518
// exit ;
71516: GO 71660
// weapon := list [ rand ( 1 , list ) ] ;
71518: LD_ADDR_VAR 0 18
71522: PUSH
71523: LD_VAR 0 5
71527: PUSH
71528: LD_INT 1
71530: PPUSH
71531: LD_VAR 0 5
71535: PPUSH
71536: CALL_OW 12
71540: ARRAY
71541: ST_TO_ADDR
// end ; if weapon then
71542: LD_VAR 0 18
71546: IFFALSE 71660
// begin tmp := CostOfWeapon ( weapon ) ;
71548: LD_ADDR_VAR 0 14
71552: PUSH
71553: LD_VAR 0 18
71557: PPUSH
71558: CALL_OW 451
71562: ST_TO_ADDR
// j := GetBase ( tower ) ;
71563: LD_ADDR_VAR 0 9
71567: PUSH
71568: LD_VAR 0 1
71572: PPUSH
71573: CALL_OW 274
71577: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
71578: LD_VAR 0 9
71582: PPUSH
71583: LD_INT 1
71585: PPUSH
71586: CALL_OW 275
71590: PUSH
71591: LD_VAR 0 14
71595: PUSH
71596: LD_INT 1
71598: ARRAY
71599: GREATEREQUAL
71600: PUSH
71601: LD_VAR 0 9
71605: PPUSH
71606: LD_INT 2
71608: PPUSH
71609: CALL_OW 275
71613: PUSH
71614: LD_VAR 0 14
71618: PUSH
71619: LD_INT 2
71621: ARRAY
71622: GREATEREQUAL
71623: AND
71624: PUSH
71625: LD_VAR 0 9
71629: PPUSH
71630: LD_INT 3
71632: PPUSH
71633: CALL_OW 275
71637: PUSH
71638: LD_VAR 0 14
71642: PUSH
71643: LD_INT 3
71645: ARRAY
71646: GREATEREQUAL
71647: AND
71648: IFFALSE 71660
// result := weapon ;
71650: LD_ADDR_VAR 0 3
71654: PUSH
71655: LD_VAR 0 18
71659: ST_TO_ADDR
// end ; end ;
71660: LD_VAR 0 3
71664: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
71665: LD_INT 0
71667: PPUSH
71668: PPUSH
// result := true ;
71669: LD_ADDR_VAR 0 3
71673: PUSH
71674: LD_INT 1
71676: ST_TO_ADDR
// if array1 = array2 then
71677: LD_VAR 0 1
71681: PUSH
71682: LD_VAR 0 2
71686: EQUAL
71687: IFFALSE 71747
// begin for i = 1 to array1 do
71689: LD_ADDR_VAR 0 4
71693: PUSH
71694: DOUBLE
71695: LD_INT 1
71697: DEC
71698: ST_TO_ADDR
71699: LD_VAR 0 1
71703: PUSH
71704: FOR_TO
71705: IFFALSE 71743
// if array1 [ i ] <> array2 [ i ] then
71707: LD_VAR 0 1
71711: PUSH
71712: LD_VAR 0 4
71716: ARRAY
71717: PUSH
71718: LD_VAR 0 2
71722: PUSH
71723: LD_VAR 0 4
71727: ARRAY
71728: NONEQUAL
71729: IFFALSE 71741
// begin result := false ;
71731: LD_ADDR_VAR 0 3
71735: PUSH
71736: LD_INT 0
71738: ST_TO_ADDR
// break ;
71739: GO 71743
// end ;
71741: GO 71704
71743: POP
71744: POP
// end else
71745: GO 71755
// result := false ;
71747: LD_ADDR_VAR 0 3
71751: PUSH
71752: LD_INT 0
71754: ST_TO_ADDR
// end ;
71755: LD_VAR 0 3
71759: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
71760: LD_INT 0
71762: PPUSH
71763: PPUSH
// if not array1 or not array2 then
71764: LD_VAR 0 1
71768: NOT
71769: PUSH
71770: LD_VAR 0 2
71774: NOT
71775: OR
71776: IFFALSE 71780
// exit ;
71778: GO 71844
// result := true ;
71780: LD_ADDR_VAR 0 3
71784: PUSH
71785: LD_INT 1
71787: ST_TO_ADDR
// for i = 1 to array1 do
71788: LD_ADDR_VAR 0 4
71792: PUSH
71793: DOUBLE
71794: LD_INT 1
71796: DEC
71797: ST_TO_ADDR
71798: LD_VAR 0 1
71802: PUSH
71803: FOR_TO
71804: IFFALSE 71842
// if array1 [ i ] <> array2 [ i ] then
71806: LD_VAR 0 1
71810: PUSH
71811: LD_VAR 0 4
71815: ARRAY
71816: PUSH
71817: LD_VAR 0 2
71821: PUSH
71822: LD_VAR 0 4
71826: ARRAY
71827: NONEQUAL
71828: IFFALSE 71840
// begin result := false ;
71830: LD_ADDR_VAR 0 3
71834: PUSH
71835: LD_INT 0
71837: ST_TO_ADDR
// break ;
71838: GO 71842
// end ;
71840: GO 71803
71842: POP
71843: POP
// end ;
71844: LD_VAR 0 3
71848: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
71849: LD_INT 0
71851: PPUSH
71852: PPUSH
71853: PPUSH
// pom := GetBase ( fac ) ;
71854: LD_ADDR_VAR 0 5
71858: PUSH
71859: LD_VAR 0 1
71863: PPUSH
71864: CALL_OW 274
71868: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
71869: LD_ADDR_VAR 0 4
71873: PUSH
71874: LD_VAR 0 2
71878: PUSH
71879: LD_INT 1
71881: ARRAY
71882: PPUSH
71883: LD_VAR 0 2
71887: PUSH
71888: LD_INT 2
71890: ARRAY
71891: PPUSH
71892: LD_VAR 0 2
71896: PUSH
71897: LD_INT 3
71899: ARRAY
71900: PPUSH
71901: LD_VAR 0 2
71905: PUSH
71906: LD_INT 4
71908: ARRAY
71909: PPUSH
71910: CALL_OW 449
71914: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
71915: LD_ADDR_VAR 0 3
71919: PUSH
71920: LD_VAR 0 5
71924: PPUSH
71925: LD_INT 1
71927: PPUSH
71928: CALL_OW 275
71932: PUSH
71933: LD_VAR 0 4
71937: PUSH
71938: LD_INT 1
71940: ARRAY
71941: GREATEREQUAL
71942: PUSH
71943: LD_VAR 0 5
71947: PPUSH
71948: LD_INT 2
71950: PPUSH
71951: CALL_OW 275
71955: PUSH
71956: LD_VAR 0 4
71960: PUSH
71961: LD_INT 2
71963: ARRAY
71964: GREATEREQUAL
71965: AND
71966: PUSH
71967: LD_VAR 0 5
71971: PPUSH
71972: LD_INT 3
71974: PPUSH
71975: CALL_OW 275
71979: PUSH
71980: LD_VAR 0 4
71984: PUSH
71985: LD_INT 3
71987: ARRAY
71988: GREATEREQUAL
71989: AND
71990: ST_TO_ADDR
// end ;
71991: LD_VAR 0 3
71995: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
71996: LD_INT 0
71998: PPUSH
71999: PPUSH
72000: PPUSH
72001: PPUSH
// pom := GetBase ( building ) ;
72002: LD_ADDR_VAR 0 3
72006: PUSH
72007: LD_VAR 0 1
72011: PPUSH
72012: CALL_OW 274
72016: ST_TO_ADDR
// if not pom then
72017: LD_VAR 0 3
72021: NOT
72022: IFFALSE 72026
// exit ;
72024: GO 72196
// btype := GetBType ( building ) ;
72026: LD_ADDR_VAR 0 5
72030: PUSH
72031: LD_VAR 0 1
72035: PPUSH
72036: CALL_OW 266
72040: ST_TO_ADDR
// if btype = b_armoury then
72041: LD_VAR 0 5
72045: PUSH
72046: LD_INT 4
72048: EQUAL
72049: IFFALSE 72059
// btype := b_barracks ;
72051: LD_ADDR_VAR 0 5
72055: PUSH
72056: LD_INT 5
72058: ST_TO_ADDR
// if btype = b_depot then
72059: LD_VAR 0 5
72063: PUSH
72064: LD_INT 0
72066: EQUAL
72067: IFFALSE 72077
// btype := b_warehouse ;
72069: LD_ADDR_VAR 0 5
72073: PUSH
72074: LD_INT 1
72076: ST_TO_ADDR
// if btype = b_workshop then
72077: LD_VAR 0 5
72081: PUSH
72082: LD_INT 2
72084: EQUAL
72085: IFFALSE 72095
// btype := b_factory ;
72087: LD_ADDR_VAR 0 5
72091: PUSH
72092: LD_INT 3
72094: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72095: LD_ADDR_VAR 0 4
72099: PUSH
72100: LD_VAR 0 5
72104: PPUSH
72105: LD_VAR 0 1
72109: PPUSH
72110: CALL_OW 248
72114: PPUSH
72115: CALL_OW 450
72119: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72120: LD_ADDR_VAR 0 2
72124: PUSH
72125: LD_VAR 0 3
72129: PPUSH
72130: LD_INT 1
72132: PPUSH
72133: CALL_OW 275
72137: PUSH
72138: LD_VAR 0 4
72142: PUSH
72143: LD_INT 1
72145: ARRAY
72146: GREATEREQUAL
72147: PUSH
72148: LD_VAR 0 3
72152: PPUSH
72153: LD_INT 2
72155: PPUSH
72156: CALL_OW 275
72160: PUSH
72161: LD_VAR 0 4
72165: PUSH
72166: LD_INT 2
72168: ARRAY
72169: GREATEREQUAL
72170: AND
72171: PUSH
72172: LD_VAR 0 3
72176: PPUSH
72177: LD_INT 3
72179: PPUSH
72180: CALL_OW 275
72184: PUSH
72185: LD_VAR 0 4
72189: PUSH
72190: LD_INT 3
72192: ARRAY
72193: GREATEREQUAL
72194: AND
72195: ST_TO_ADDR
// end ;
72196: LD_VAR 0 2
72200: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72201: LD_INT 0
72203: PPUSH
72204: PPUSH
72205: PPUSH
// pom := GetBase ( building ) ;
72206: LD_ADDR_VAR 0 4
72210: PUSH
72211: LD_VAR 0 1
72215: PPUSH
72216: CALL_OW 274
72220: ST_TO_ADDR
// if not pom then
72221: LD_VAR 0 4
72225: NOT
72226: IFFALSE 72230
// exit ;
72228: GO 72331
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72230: LD_ADDR_VAR 0 5
72234: PUSH
72235: LD_VAR 0 2
72239: PPUSH
72240: LD_VAR 0 1
72244: PPUSH
72245: CALL_OW 248
72249: PPUSH
72250: CALL_OW 450
72254: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72255: LD_ADDR_VAR 0 3
72259: PUSH
72260: LD_VAR 0 4
72264: PPUSH
72265: LD_INT 1
72267: PPUSH
72268: CALL_OW 275
72272: PUSH
72273: LD_VAR 0 5
72277: PUSH
72278: LD_INT 1
72280: ARRAY
72281: GREATEREQUAL
72282: PUSH
72283: LD_VAR 0 4
72287: PPUSH
72288: LD_INT 2
72290: PPUSH
72291: CALL_OW 275
72295: PUSH
72296: LD_VAR 0 5
72300: PUSH
72301: LD_INT 2
72303: ARRAY
72304: GREATEREQUAL
72305: AND
72306: PUSH
72307: LD_VAR 0 4
72311: PPUSH
72312: LD_INT 3
72314: PPUSH
72315: CALL_OW 275
72319: PUSH
72320: LD_VAR 0 5
72324: PUSH
72325: LD_INT 3
72327: ARRAY
72328: GREATEREQUAL
72329: AND
72330: ST_TO_ADDR
// end ;
72331: LD_VAR 0 3
72335: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
72336: LD_INT 0
72338: PPUSH
72339: PPUSH
72340: PPUSH
72341: PPUSH
72342: PPUSH
72343: PPUSH
72344: PPUSH
72345: PPUSH
72346: PPUSH
72347: PPUSH
72348: PPUSH
// result := false ;
72349: LD_ADDR_VAR 0 8
72353: PUSH
72354: LD_INT 0
72356: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
72357: LD_VAR 0 5
72361: NOT
72362: PUSH
72363: LD_VAR 0 1
72367: NOT
72368: OR
72369: PUSH
72370: LD_VAR 0 2
72374: NOT
72375: OR
72376: PUSH
72377: LD_VAR 0 3
72381: NOT
72382: OR
72383: IFFALSE 72387
// exit ;
72385: GO 73201
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
72387: LD_ADDR_VAR 0 14
72391: PUSH
72392: LD_VAR 0 1
72396: PPUSH
72397: LD_VAR 0 2
72401: PPUSH
72402: LD_VAR 0 3
72406: PPUSH
72407: LD_VAR 0 4
72411: PPUSH
72412: LD_VAR 0 5
72416: PUSH
72417: LD_INT 1
72419: ARRAY
72420: PPUSH
72421: CALL_OW 248
72425: PPUSH
72426: LD_INT 0
72428: PPUSH
72429: CALL 74038 0 6
72433: ST_TO_ADDR
// if not hexes then
72434: LD_VAR 0 14
72438: NOT
72439: IFFALSE 72443
// exit ;
72441: GO 73201
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
72443: LD_ADDR_VAR 0 17
72447: PUSH
72448: LD_VAR 0 5
72452: PPUSH
72453: LD_INT 22
72455: PUSH
72456: LD_VAR 0 13
72460: PPUSH
72461: CALL_OW 255
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 2
72472: PUSH
72473: LD_INT 30
72475: PUSH
72476: LD_INT 0
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 30
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: LIST
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PPUSH
72502: CALL_OW 72
72506: ST_TO_ADDR
// for i = 1 to hexes do
72507: LD_ADDR_VAR 0 9
72511: PUSH
72512: DOUBLE
72513: LD_INT 1
72515: DEC
72516: ST_TO_ADDR
72517: LD_VAR 0 14
72521: PUSH
72522: FOR_TO
72523: IFFALSE 73199
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
72525: LD_ADDR_VAR 0 13
72529: PUSH
72530: LD_VAR 0 14
72534: PUSH
72535: LD_VAR 0 9
72539: ARRAY
72540: PUSH
72541: LD_INT 1
72543: ARRAY
72544: PPUSH
72545: LD_VAR 0 14
72549: PUSH
72550: LD_VAR 0 9
72554: ARRAY
72555: PUSH
72556: LD_INT 2
72558: ARRAY
72559: PPUSH
72560: CALL_OW 428
72564: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
72565: LD_VAR 0 14
72569: PUSH
72570: LD_VAR 0 9
72574: ARRAY
72575: PUSH
72576: LD_INT 1
72578: ARRAY
72579: PPUSH
72580: LD_VAR 0 14
72584: PUSH
72585: LD_VAR 0 9
72589: ARRAY
72590: PUSH
72591: LD_INT 2
72593: ARRAY
72594: PPUSH
72595: CALL_OW 351
72599: PUSH
72600: LD_VAR 0 14
72604: PUSH
72605: LD_VAR 0 9
72609: ARRAY
72610: PUSH
72611: LD_INT 1
72613: ARRAY
72614: PPUSH
72615: LD_VAR 0 14
72619: PUSH
72620: LD_VAR 0 9
72624: ARRAY
72625: PUSH
72626: LD_INT 2
72628: ARRAY
72629: PPUSH
72630: CALL_OW 488
72634: NOT
72635: OR
72636: PUSH
72637: LD_VAR 0 13
72641: PPUSH
72642: CALL_OW 247
72646: PUSH
72647: LD_INT 3
72649: EQUAL
72650: OR
72651: IFFALSE 72657
// exit ;
72653: POP
72654: POP
72655: GO 73201
// if not tmp then
72657: LD_VAR 0 13
72661: NOT
72662: IFFALSE 72666
// continue ;
72664: GO 72522
// result := true ;
72666: LD_ADDR_VAR 0 8
72670: PUSH
72671: LD_INT 1
72673: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
72674: LD_VAR 0 6
72678: PUSH
72679: LD_VAR 0 13
72683: PPUSH
72684: CALL_OW 247
72688: PUSH
72689: LD_INT 2
72691: EQUAL
72692: AND
72693: PUSH
72694: LD_VAR 0 13
72698: PPUSH
72699: CALL_OW 263
72703: PUSH
72704: LD_INT 1
72706: EQUAL
72707: AND
72708: IFFALSE 72872
// begin if IsDrivenBy ( tmp ) then
72710: LD_VAR 0 13
72714: PPUSH
72715: CALL_OW 311
72719: IFFALSE 72723
// continue ;
72721: GO 72522
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
72723: LD_VAR 0 6
72727: PPUSH
72728: LD_INT 3
72730: PUSH
72731: LD_INT 60
72733: PUSH
72734: EMPTY
72735: LIST
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 3
72743: PUSH
72744: LD_INT 55
72746: PUSH
72747: EMPTY
72748: LIST
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PPUSH
72758: CALL_OW 72
72762: IFFALSE 72870
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
72764: LD_ADDR_VAR 0 18
72768: PUSH
72769: LD_VAR 0 6
72773: PPUSH
72774: LD_INT 3
72776: PUSH
72777: LD_INT 60
72779: PUSH
72780: EMPTY
72781: LIST
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 3
72789: PUSH
72790: LD_INT 55
72792: PUSH
72793: EMPTY
72794: LIST
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PPUSH
72804: CALL_OW 72
72808: PUSH
72809: LD_INT 1
72811: ARRAY
72812: ST_TO_ADDR
// if IsInUnit ( driver ) then
72813: LD_VAR 0 18
72817: PPUSH
72818: CALL_OW 310
72822: IFFALSE 72833
// ComExit ( driver ) ;
72824: LD_VAR 0 18
72828: PPUSH
72829: CALL 97222 0 1
// AddComEnterUnit ( driver , tmp ) ;
72833: LD_VAR 0 18
72837: PPUSH
72838: LD_VAR 0 13
72842: PPUSH
72843: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
72847: LD_VAR 0 18
72851: PPUSH
72852: LD_VAR 0 7
72856: PPUSH
72857: CALL_OW 173
// AddComExitVehicle ( driver ) ;
72861: LD_VAR 0 18
72865: PPUSH
72866: CALL_OW 181
// end ; continue ;
72870: GO 72522
// end ; if not cleaners or not tmp in cleaners then
72872: LD_VAR 0 6
72876: NOT
72877: PUSH
72878: LD_VAR 0 13
72882: PUSH
72883: LD_VAR 0 6
72887: IN
72888: NOT
72889: OR
72890: IFFALSE 73197
// begin if dep then
72892: LD_VAR 0 17
72896: IFFALSE 73032
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
72898: LD_ADDR_VAR 0 16
72902: PUSH
72903: LD_VAR 0 17
72907: PUSH
72908: LD_INT 1
72910: ARRAY
72911: PPUSH
72912: CALL_OW 250
72916: PPUSH
72917: LD_VAR 0 17
72921: PUSH
72922: LD_INT 1
72924: ARRAY
72925: PPUSH
72926: CALL_OW 254
72930: PPUSH
72931: LD_INT 5
72933: PPUSH
72934: CALL_OW 272
72938: PUSH
72939: LD_VAR 0 17
72943: PUSH
72944: LD_INT 1
72946: ARRAY
72947: PPUSH
72948: CALL_OW 251
72952: PPUSH
72953: LD_VAR 0 17
72957: PUSH
72958: LD_INT 1
72960: ARRAY
72961: PPUSH
72962: CALL_OW 254
72966: PPUSH
72967: LD_INT 5
72969: PPUSH
72970: CALL_OW 273
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
72979: LD_VAR 0 16
72983: PUSH
72984: LD_INT 1
72986: ARRAY
72987: PPUSH
72988: LD_VAR 0 16
72992: PUSH
72993: LD_INT 2
72995: ARRAY
72996: PPUSH
72997: CALL_OW 488
73001: IFFALSE 73032
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73003: LD_VAR 0 13
73007: PPUSH
73008: LD_VAR 0 16
73012: PUSH
73013: LD_INT 1
73015: ARRAY
73016: PPUSH
73017: LD_VAR 0 16
73021: PUSH
73022: LD_INT 2
73024: ARRAY
73025: PPUSH
73026: CALL_OW 111
// continue ;
73030: GO 72522
// end ; end ; r := GetDir ( tmp ) ;
73032: LD_ADDR_VAR 0 15
73036: PUSH
73037: LD_VAR 0 13
73041: PPUSH
73042: CALL_OW 254
73046: ST_TO_ADDR
// if r = 5 then
73047: LD_VAR 0 15
73051: PUSH
73052: LD_INT 5
73054: EQUAL
73055: IFFALSE 73065
// r := 0 ;
73057: LD_ADDR_VAR 0 15
73061: PUSH
73062: LD_INT 0
73064: ST_TO_ADDR
// for j = r to 5 do
73065: LD_ADDR_VAR 0 10
73069: PUSH
73070: DOUBLE
73071: LD_VAR 0 15
73075: DEC
73076: ST_TO_ADDR
73077: LD_INT 5
73079: PUSH
73080: FOR_TO
73081: IFFALSE 73195
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73083: LD_ADDR_VAR 0 11
73087: PUSH
73088: LD_VAR 0 13
73092: PPUSH
73093: CALL_OW 250
73097: PPUSH
73098: LD_VAR 0 10
73102: PPUSH
73103: LD_INT 2
73105: PPUSH
73106: CALL_OW 272
73110: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73111: LD_ADDR_VAR 0 12
73115: PUSH
73116: LD_VAR 0 13
73120: PPUSH
73121: CALL_OW 251
73125: PPUSH
73126: LD_VAR 0 10
73130: PPUSH
73131: LD_INT 2
73133: PPUSH
73134: CALL_OW 273
73138: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73139: LD_VAR 0 11
73143: PPUSH
73144: LD_VAR 0 12
73148: PPUSH
73149: CALL_OW 488
73153: PUSH
73154: LD_VAR 0 11
73158: PPUSH
73159: LD_VAR 0 12
73163: PPUSH
73164: CALL_OW 428
73168: NOT
73169: AND
73170: IFFALSE 73193
// begin ComMoveXY ( tmp , _x , _y ) ;
73172: LD_VAR 0 13
73176: PPUSH
73177: LD_VAR 0 11
73181: PPUSH
73182: LD_VAR 0 12
73186: PPUSH
73187: CALL_OW 111
// break ;
73191: GO 73195
// end ; end ;
73193: GO 73080
73195: POP
73196: POP
// end ; end ;
73197: GO 72522
73199: POP
73200: POP
// end ;
73201: LD_VAR 0 8
73205: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
73206: LD_INT 0
73208: PPUSH
73209: PPUSH
73210: PPUSH
73211: PPUSH
73212: PPUSH
73213: PPUSH
73214: PPUSH
73215: PPUSH
73216: PPUSH
73217: PPUSH
// result := false ;
73218: LD_ADDR_VAR 0 6
73222: PUSH
73223: LD_INT 0
73225: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
73226: LD_VAR 0 1
73230: NOT
73231: PUSH
73232: LD_VAR 0 1
73236: PPUSH
73237: CALL_OW 266
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: LD_INT 1
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: IN
73252: NOT
73253: OR
73254: PUSH
73255: LD_VAR 0 2
73259: NOT
73260: OR
73261: PUSH
73262: LD_VAR 0 5
73266: PUSH
73267: LD_INT 0
73269: PUSH
73270: LD_INT 1
73272: PUSH
73273: LD_INT 2
73275: PUSH
73276: LD_INT 3
73278: PUSH
73279: LD_INT 4
73281: PUSH
73282: LD_INT 5
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: IN
73293: NOT
73294: OR
73295: PUSH
73296: LD_VAR 0 3
73300: PPUSH
73301: LD_VAR 0 4
73305: PPUSH
73306: CALL_OW 488
73310: NOT
73311: OR
73312: IFFALSE 73316
// exit ;
73314: GO 74033
// pom := GetBase ( depot ) ;
73316: LD_ADDR_VAR 0 10
73320: PUSH
73321: LD_VAR 0 1
73325: PPUSH
73326: CALL_OW 274
73330: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
73331: LD_ADDR_VAR 0 11
73335: PUSH
73336: LD_VAR 0 2
73340: PPUSH
73341: LD_VAR 0 1
73345: PPUSH
73346: CALL_OW 248
73350: PPUSH
73351: CALL_OW 450
73355: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
73356: LD_VAR 0 10
73360: PPUSH
73361: LD_INT 1
73363: PPUSH
73364: CALL_OW 275
73368: PUSH
73369: LD_VAR 0 11
73373: PUSH
73374: LD_INT 1
73376: ARRAY
73377: GREATEREQUAL
73378: PUSH
73379: LD_VAR 0 10
73383: PPUSH
73384: LD_INT 2
73386: PPUSH
73387: CALL_OW 275
73391: PUSH
73392: LD_VAR 0 11
73396: PUSH
73397: LD_INT 2
73399: ARRAY
73400: GREATEREQUAL
73401: AND
73402: PUSH
73403: LD_VAR 0 10
73407: PPUSH
73408: LD_INT 3
73410: PPUSH
73411: CALL_OW 275
73415: PUSH
73416: LD_VAR 0 11
73420: PUSH
73421: LD_INT 3
73423: ARRAY
73424: GREATEREQUAL
73425: AND
73426: NOT
73427: IFFALSE 73431
// exit ;
73429: GO 74033
// if GetBType ( depot ) = b_depot then
73431: LD_VAR 0 1
73435: PPUSH
73436: CALL_OW 266
73440: PUSH
73441: LD_INT 0
73443: EQUAL
73444: IFFALSE 73456
// dist := 28 else
73446: LD_ADDR_VAR 0 14
73450: PUSH
73451: LD_INT 28
73453: ST_TO_ADDR
73454: GO 73464
// dist := 36 ;
73456: LD_ADDR_VAR 0 14
73460: PUSH
73461: LD_INT 36
73463: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
73464: LD_VAR 0 1
73468: PPUSH
73469: LD_VAR 0 3
73473: PPUSH
73474: LD_VAR 0 4
73478: PPUSH
73479: CALL_OW 297
73483: PUSH
73484: LD_VAR 0 14
73488: GREATER
73489: IFFALSE 73493
// exit ;
73491: GO 74033
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
73493: LD_ADDR_VAR 0 12
73497: PUSH
73498: LD_VAR 0 2
73502: PPUSH
73503: LD_VAR 0 3
73507: PPUSH
73508: LD_VAR 0 4
73512: PPUSH
73513: LD_VAR 0 5
73517: PPUSH
73518: LD_VAR 0 1
73522: PPUSH
73523: CALL_OW 248
73527: PPUSH
73528: LD_INT 0
73530: PPUSH
73531: CALL 74038 0 6
73535: ST_TO_ADDR
// if not hexes then
73536: LD_VAR 0 12
73540: NOT
73541: IFFALSE 73545
// exit ;
73543: GO 74033
// hex := GetHexInfo ( x , y ) ;
73545: LD_ADDR_VAR 0 15
73549: PUSH
73550: LD_VAR 0 3
73554: PPUSH
73555: LD_VAR 0 4
73559: PPUSH
73560: CALL_OW 546
73564: ST_TO_ADDR
// if hex [ 1 ] then
73565: LD_VAR 0 15
73569: PUSH
73570: LD_INT 1
73572: ARRAY
73573: IFFALSE 73577
// exit ;
73575: GO 74033
// height := hex [ 2 ] ;
73577: LD_ADDR_VAR 0 13
73581: PUSH
73582: LD_VAR 0 15
73586: PUSH
73587: LD_INT 2
73589: ARRAY
73590: ST_TO_ADDR
// for i = 1 to hexes do
73591: LD_ADDR_VAR 0 7
73595: PUSH
73596: DOUBLE
73597: LD_INT 1
73599: DEC
73600: ST_TO_ADDR
73601: LD_VAR 0 12
73605: PUSH
73606: FOR_TO
73607: IFFALSE 73937
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
73609: LD_VAR 0 12
73613: PUSH
73614: LD_VAR 0 7
73618: ARRAY
73619: PUSH
73620: LD_INT 1
73622: ARRAY
73623: PPUSH
73624: LD_VAR 0 12
73628: PUSH
73629: LD_VAR 0 7
73633: ARRAY
73634: PUSH
73635: LD_INT 2
73637: ARRAY
73638: PPUSH
73639: CALL_OW 488
73643: NOT
73644: PUSH
73645: LD_VAR 0 12
73649: PUSH
73650: LD_VAR 0 7
73654: ARRAY
73655: PUSH
73656: LD_INT 1
73658: ARRAY
73659: PPUSH
73660: LD_VAR 0 12
73664: PUSH
73665: LD_VAR 0 7
73669: ARRAY
73670: PUSH
73671: LD_INT 2
73673: ARRAY
73674: PPUSH
73675: CALL_OW 428
73679: PUSH
73680: LD_INT 0
73682: GREATER
73683: OR
73684: PUSH
73685: LD_VAR 0 12
73689: PUSH
73690: LD_VAR 0 7
73694: ARRAY
73695: PUSH
73696: LD_INT 1
73698: ARRAY
73699: PPUSH
73700: LD_VAR 0 12
73704: PUSH
73705: LD_VAR 0 7
73709: ARRAY
73710: PUSH
73711: LD_INT 2
73713: ARRAY
73714: PPUSH
73715: CALL_OW 351
73719: OR
73720: IFFALSE 73726
// exit ;
73722: POP
73723: POP
73724: GO 74033
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
73726: LD_ADDR_VAR 0 8
73730: PUSH
73731: LD_VAR 0 12
73735: PUSH
73736: LD_VAR 0 7
73740: ARRAY
73741: PUSH
73742: LD_INT 1
73744: ARRAY
73745: PPUSH
73746: LD_VAR 0 12
73750: PUSH
73751: LD_VAR 0 7
73755: ARRAY
73756: PUSH
73757: LD_INT 2
73759: ARRAY
73760: PPUSH
73761: CALL_OW 546
73765: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
73766: LD_VAR 0 8
73770: PUSH
73771: LD_INT 1
73773: ARRAY
73774: PUSH
73775: LD_VAR 0 8
73779: PUSH
73780: LD_INT 2
73782: ARRAY
73783: PUSH
73784: LD_VAR 0 13
73788: PUSH
73789: LD_INT 2
73791: PLUS
73792: GREATER
73793: OR
73794: PUSH
73795: LD_VAR 0 8
73799: PUSH
73800: LD_INT 2
73802: ARRAY
73803: PUSH
73804: LD_VAR 0 13
73808: PUSH
73809: LD_INT 2
73811: MINUS
73812: LESS
73813: OR
73814: PUSH
73815: LD_VAR 0 8
73819: PUSH
73820: LD_INT 3
73822: ARRAY
73823: PUSH
73824: LD_INT 0
73826: PUSH
73827: LD_INT 8
73829: PUSH
73830: LD_INT 9
73832: PUSH
73833: LD_INT 10
73835: PUSH
73836: LD_INT 11
73838: PUSH
73839: LD_INT 12
73841: PUSH
73842: LD_INT 13
73844: PUSH
73845: LD_INT 16
73847: PUSH
73848: LD_INT 17
73850: PUSH
73851: LD_INT 18
73853: PUSH
73854: LD_INT 19
73856: PUSH
73857: LD_INT 20
73859: PUSH
73860: LD_INT 21
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: LIST
73867: LIST
73868: LIST
73869: LIST
73870: LIST
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: IN
73878: NOT
73879: OR
73880: PUSH
73881: LD_VAR 0 8
73885: PUSH
73886: LD_INT 5
73888: ARRAY
73889: NOT
73890: OR
73891: PUSH
73892: LD_VAR 0 8
73896: PUSH
73897: LD_INT 6
73899: ARRAY
73900: PUSH
73901: LD_INT 1
73903: PUSH
73904: LD_INT 2
73906: PUSH
73907: LD_INT 7
73909: PUSH
73910: LD_INT 9
73912: PUSH
73913: LD_INT 10
73915: PUSH
73916: LD_INT 11
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: IN
73927: NOT
73928: OR
73929: IFFALSE 73935
// exit ;
73931: POP
73932: POP
73933: GO 74033
// end ;
73935: GO 73606
73937: POP
73938: POP
// side := GetSide ( depot ) ;
73939: LD_ADDR_VAR 0 9
73943: PUSH
73944: LD_VAR 0 1
73948: PPUSH
73949: CALL_OW 255
73953: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73954: LD_VAR 0 9
73958: PPUSH
73959: LD_VAR 0 3
73963: PPUSH
73964: LD_VAR 0 4
73968: PPUSH
73969: LD_INT 20
73971: PPUSH
73972: CALL 66354 0 4
73976: PUSH
73977: LD_INT 4
73979: ARRAY
73980: IFFALSE 73984
// exit ;
73982: GO 74033
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
73984: LD_VAR 0 2
73988: PUSH
73989: LD_INT 29
73991: PUSH
73992: LD_INT 30
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: IN
73999: PUSH
74000: LD_VAR 0 3
74004: PPUSH
74005: LD_VAR 0 4
74009: PPUSH
74010: LD_VAR 0 9
74014: PPUSH
74015: CALL_OW 440
74019: NOT
74020: AND
74021: IFFALSE 74025
// exit ;
74023: GO 74033
// result := true ;
74025: LD_ADDR_VAR 0 6
74029: PUSH
74030: LD_INT 1
74032: ST_TO_ADDR
// end ;
74033: LD_VAR 0 6
74037: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
74038: LD_INT 0
74040: PPUSH
74041: PPUSH
74042: PPUSH
74043: PPUSH
74044: PPUSH
74045: PPUSH
74046: PPUSH
74047: PPUSH
74048: PPUSH
74049: PPUSH
74050: PPUSH
74051: PPUSH
74052: PPUSH
74053: PPUSH
74054: PPUSH
74055: PPUSH
74056: PPUSH
74057: PPUSH
74058: PPUSH
74059: PPUSH
74060: PPUSH
74061: PPUSH
74062: PPUSH
74063: PPUSH
74064: PPUSH
74065: PPUSH
74066: PPUSH
74067: PPUSH
74068: PPUSH
74069: PPUSH
74070: PPUSH
74071: PPUSH
74072: PPUSH
74073: PPUSH
74074: PPUSH
74075: PPUSH
74076: PPUSH
74077: PPUSH
74078: PPUSH
74079: PPUSH
74080: PPUSH
74081: PPUSH
74082: PPUSH
74083: PPUSH
74084: PPUSH
74085: PPUSH
74086: PPUSH
74087: PPUSH
74088: PPUSH
74089: PPUSH
74090: PPUSH
74091: PPUSH
74092: PPUSH
74093: PPUSH
74094: PPUSH
74095: PPUSH
74096: PPUSH
74097: PPUSH
// result = [ ] ;
74098: LD_ADDR_VAR 0 7
74102: PUSH
74103: EMPTY
74104: ST_TO_ADDR
// temp_list = [ ] ;
74105: LD_ADDR_VAR 0 9
74109: PUSH
74110: EMPTY
74111: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
74112: LD_VAR 0 4
74116: PUSH
74117: LD_INT 0
74119: PUSH
74120: LD_INT 1
74122: PUSH
74123: LD_INT 2
74125: PUSH
74126: LD_INT 3
74128: PUSH
74129: LD_INT 4
74131: PUSH
74132: LD_INT 5
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: LIST
74142: IN
74143: NOT
74144: PUSH
74145: LD_VAR 0 1
74149: PUSH
74150: LD_INT 0
74152: PUSH
74153: LD_INT 1
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: IN
74160: PUSH
74161: LD_VAR 0 5
74165: PUSH
74166: LD_INT 1
74168: PUSH
74169: LD_INT 2
74171: PUSH
74172: LD_INT 3
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: LIST
74179: IN
74180: NOT
74181: AND
74182: OR
74183: IFFALSE 74187
// exit ;
74185: GO 92578
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
74187: LD_VAR 0 1
74191: PUSH
74192: LD_INT 6
74194: PUSH
74195: LD_INT 7
74197: PUSH
74198: LD_INT 8
74200: PUSH
74201: LD_INT 13
74203: PUSH
74204: LD_INT 12
74206: PUSH
74207: LD_INT 15
74209: PUSH
74210: LD_INT 11
74212: PUSH
74213: LD_INT 14
74215: PUSH
74216: LD_INT 10
74218: PUSH
74219: EMPTY
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: LIST
74225: LIST
74226: LIST
74227: LIST
74228: LIST
74229: IN
74230: IFFALSE 74240
// btype = b_lab ;
74232: LD_ADDR_VAR 0 1
74236: PUSH
74237: LD_INT 6
74239: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
74240: LD_VAR 0 6
74244: PUSH
74245: LD_INT 0
74247: PUSH
74248: LD_INT 1
74250: PUSH
74251: LD_INT 2
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: LIST
74258: IN
74259: NOT
74260: PUSH
74261: LD_VAR 0 1
74265: PUSH
74266: LD_INT 0
74268: PUSH
74269: LD_INT 1
74271: PUSH
74272: LD_INT 2
74274: PUSH
74275: LD_INT 3
74277: PUSH
74278: LD_INT 6
74280: PUSH
74281: LD_INT 36
74283: PUSH
74284: LD_INT 4
74286: PUSH
74287: LD_INT 5
74289: PUSH
74290: LD_INT 31
74292: PUSH
74293: LD_INT 32
74295: PUSH
74296: LD_INT 33
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: IN
74312: NOT
74313: PUSH
74314: LD_VAR 0 6
74318: PUSH
74319: LD_INT 1
74321: EQUAL
74322: AND
74323: OR
74324: PUSH
74325: LD_VAR 0 1
74329: PUSH
74330: LD_INT 2
74332: PUSH
74333: LD_INT 3
74335: PUSH
74336: EMPTY
74337: LIST
74338: LIST
74339: IN
74340: NOT
74341: PUSH
74342: LD_VAR 0 6
74346: PUSH
74347: LD_INT 2
74349: EQUAL
74350: AND
74351: OR
74352: IFFALSE 74362
// mode = 0 ;
74354: LD_ADDR_VAR 0 6
74358: PUSH
74359: LD_INT 0
74361: ST_TO_ADDR
// case mode of 0 :
74362: LD_VAR 0 6
74366: PUSH
74367: LD_INT 0
74369: DOUBLE
74370: EQUAL
74371: IFTRUE 74375
74373: GO 85828
74375: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74376: LD_ADDR_VAR 0 11
74380: PUSH
74381: LD_INT 0
74383: PUSH
74384: LD_INT 0
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: LD_INT 0
74393: PUSH
74394: LD_INT 1
74396: NEG
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: LD_INT 1
74404: PUSH
74405: LD_INT 0
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: PUSH
74412: LD_INT 1
74414: PUSH
74415: LD_INT 1
74417: PUSH
74418: EMPTY
74419: LIST
74420: LIST
74421: PUSH
74422: LD_INT 0
74424: PUSH
74425: LD_INT 1
74427: PUSH
74428: EMPTY
74429: LIST
74430: LIST
74431: PUSH
74432: LD_INT 1
74434: NEG
74435: PUSH
74436: LD_INT 0
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: LD_INT 1
74449: NEG
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: PUSH
74455: LD_INT 1
74457: NEG
74458: PUSH
74459: LD_INT 2
74461: NEG
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: LD_INT 2
74472: NEG
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 1
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: LD_INT 2
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 0
74501: PUSH
74502: LD_INT 2
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 1
74511: NEG
74512: PUSH
74513: LD_INT 1
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 1
74522: PUSH
74523: LD_INT 3
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 0
74532: PUSH
74533: LD_INT 3
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 1
74542: NEG
74543: PUSH
74544: LD_INT 2
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: EMPTY
74552: LIST
74553: LIST
74554: LIST
74555: LIST
74556: LIST
74557: LIST
74558: LIST
74559: LIST
74560: LIST
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74569: LD_ADDR_VAR 0 12
74573: PUSH
74574: LD_INT 0
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: LD_INT 1
74589: NEG
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 1
74597: PUSH
74598: LD_INT 0
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 1
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 0
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 1
74627: NEG
74628: PUSH
74629: LD_INT 0
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 1
74638: NEG
74639: PUSH
74640: LD_INT 1
74642: NEG
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: LD_INT 1
74650: PUSH
74651: LD_INT 1
74653: NEG
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: PUSH
74659: LD_INT 2
74661: PUSH
74662: LD_INT 0
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 2
74671: PUSH
74672: LD_INT 1
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 1
74681: NEG
74682: PUSH
74683: LD_INT 1
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 2
74692: NEG
74693: PUSH
74694: LD_INT 0
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 2
74703: NEG
74704: PUSH
74705: LD_INT 1
74707: NEG
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 2
74715: NEG
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 3
74726: NEG
74727: PUSH
74728: LD_INT 0
74730: PUSH
74731: EMPTY
74732: LIST
74733: LIST
74734: PUSH
74735: LD_INT 3
74737: NEG
74738: PUSH
74739: LD_INT 1
74741: NEG
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: LIST
74753: LIST
74754: LIST
74755: LIST
74756: LIST
74757: LIST
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: LIST
74764: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74765: LD_ADDR_VAR 0 13
74769: PUSH
74770: LD_INT 0
74772: PUSH
74773: LD_INT 0
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: LD_INT 0
74782: PUSH
74783: LD_INT 1
74785: NEG
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 1
74793: PUSH
74794: LD_INT 0
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: LD_INT 1
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: LD_INT 1
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 1
74823: NEG
74824: PUSH
74825: LD_INT 0
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: LD_INT 1
74838: NEG
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: PUSH
74844: LD_INT 1
74846: NEG
74847: PUSH
74848: LD_INT 2
74850: NEG
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: LD_INT 2
74858: PUSH
74859: LD_INT 1
74861: PUSH
74862: EMPTY
74863: LIST
74864: LIST
74865: PUSH
74866: LD_INT 2
74868: PUSH
74869: LD_INT 2
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 1
74878: PUSH
74879: LD_INT 2
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: PUSH
74886: LD_INT 2
74888: NEG
74889: PUSH
74890: LD_INT 1
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 2
74900: NEG
74901: PUSH
74902: LD_INT 2
74904: NEG
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 2
74912: NEG
74913: PUSH
74914: LD_INT 3
74916: NEG
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: LD_INT 3
74924: NEG
74925: PUSH
74926: LD_INT 2
74928: NEG
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 3
74936: NEG
74937: PUSH
74938: LD_INT 3
74940: NEG
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: LIST
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74964: LD_ADDR_VAR 0 14
74968: PUSH
74969: LD_INT 0
74971: PUSH
74972: LD_INT 0
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: LD_INT 1
74984: NEG
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 1
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 1
75002: PUSH
75003: LD_INT 1
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: LD_INT 1
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 1
75022: NEG
75023: PUSH
75024: LD_INT 0
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 1
75033: NEG
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 1
75045: NEG
75046: PUSH
75047: LD_INT 2
75049: NEG
75050: PUSH
75051: EMPTY
75052: LIST
75053: LIST
75054: PUSH
75055: LD_INT 0
75057: PUSH
75058: LD_INT 2
75060: NEG
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: LD_INT 1
75068: PUSH
75069: LD_INT 1
75071: NEG
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: LD_INT 2
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 0
75089: PUSH
75090: LD_INT 2
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 1
75099: NEG
75100: PUSH
75101: LD_INT 1
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 1
75110: NEG
75111: PUSH
75112: LD_INT 3
75114: NEG
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 0
75122: PUSH
75123: LD_INT 3
75125: NEG
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: LD_INT 2
75136: NEG
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: LIST
75149: LIST
75150: LIST
75151: LIST
75152: LIST
75153: LIST
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: LIST
75159: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75160: LD_ADDR_VAR 0 15
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: LD_INT 0
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 0
75177: PUSH
75178: LD_INT 1
75180: NEG
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 1
75188: PUSH
75189: LD_INT 0
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 1
75198: PUSH
75199: LD_INT 1
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: LD_INT 0
75208: PUSH
75209: LD_INT 1
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: NEG
75219: PUSH
75220: LD_INT 0
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 1
75229: NEG
75230: PUSH
75231: LD_INT 1
75233: NEG
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 1
75241: PUSH
75242: LD_INT 1
75244: NEG
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 2
75252: PUSH
75253: LD_INT 0
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 2
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 1
75272: NEG
75273: PUSH
75274: LD_INT 1
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 2
75283: NEG
75284: PUSH
75285: LD_INT 0
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: LD_INT 2
75294: NEG
75295: PUSH
75296: LD_INT 1
75298: NEG
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: LD_INT 2
75306: PUSH
75307: LD_INT 1
75309: NEG
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 3
75317: PUSH
75318: LD_INT 0
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 3
75327: PUSH
75328: LD_INT 1
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: LIST
75342: LIST
75343: LIST
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75353: LD_ADDR_VAR 0 16
75357: PUSH
75358: LD_INT 0
75360: PUSH
75361: LD_INT 0
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 0
75370: PUSH
75371: LD_INT 1
75373: NEG
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: PUSH
75379: LD_INT 1
75381: PUSH
75382: LD_INT 0
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 1
75391: PUSH
75392: LD_INT 1
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: LD_INT 1
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 1
75411: NEG
75412: PUSH
75413: LD_INT 0
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 1
75422: NEG
75423: PUSH
75424: LD_INT 1
75426: NEG
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 1
75434: NEG
75435: PUSH
75436: LD_INT 2
75438: NEG
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 2
75446: PUSH
75447: LD_INT 1
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 2
75456: PUSH
75457: LD_INT 2
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: LD_INT 1
75466: PUSH
75467: LD_INT 2
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 2
75476: NEG
75477: PUSH
75478: LD_INT 1
75480: NEG
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 2
75488: NEG
75489: PUSH
75490: LD_INT 2
75492: NEG
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 3
75500: PUSH
75501: LD_INT 2
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PUSH
75508: LD_INT 3
75510: PUSH
75511: LD_INT 3
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 2
75520: PUSH
75521: LD_INT 3
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: EMPTY
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75546: LD_ADDR_VAR 0 17
75550: PUSH
75551: LD_INT 0
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 0
75563: PUSH
75564: LD_INT 1
75566: NEG
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 1
75574: PUSH
75575: LD_INT 0
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 1
75584: PUSH
75585: LD_INT 1
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 0
75594: PUSH
75595: LD_INT 1
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 1
75604: NEG
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: EMPTY
75610: LIST
75611: LIST
75612: PUSH
75613: LD_INT 1
75615: NEG
75616: PUSH
75617: LD_INT 1
75619: NEG
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PUSH
75625: LD_INT 1
75627: NEG
75628: PUSH
75629: LD_INT 2
75631: NEG
75632: PUSH
75633: EMPTY
75634: LIST
75635: LIST
75636: PUSH
75637: LD_INT 0
75639: PUSH
75640: LD_INT 2
75642: NEG
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: PUSH
75651: LD_INT 1
75653: NEG
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 2
75661: PUSH
75662: LD_INT 0
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 2
75671: PUSH
75672: LD_INT 1
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 2
75681: PUSH
75682: LD_INT 2
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 1
75691: PUSH
75692: LD_INT 2
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PUSH
75699: LD_INT 0
75701: PUSH
75702: LD_INT 2
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 1
75711: NEG
75712: PUSH
75713: LD_INT 1
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: LD_INT 2
75722: NEG
75723: PUSH
75724: LD_INT 0
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 2
75733: NEG
75734: PUSH
75735: LD_INT 1
75737: NEG
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: PUSH
75743: LD_INT 2
75745: NEG
75746: PUSH
75747: LD_INT 2
75749: NEG
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: LIST
75770: LIST
75771: LIST
75772: LIST
75773: LIST
75774: LIST
75775: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75776: LD_ADDR_VAR 0 18
75780: PUSH
75781: LD_INT 0
75783: PUSH
75784: LD_INT 0
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 0
75793: PUSH
75794: LD_INT 1
75796: NEG
75797: PUSH
75798: EMPTY
75799: LIST
75800: LIST
75801: PUSH
75802: LD_INT 1
75804: PUSH
75805: LD_INT 0
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: LD_INT 1
75814: PUSH
75815: LD_INT 1
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 0
75824: PUSH
75825: LD_INT 1
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: LD_INT 0
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PUSH
75843: LD_INT 1
75845: NEG
75846: PUSH
75847: LD_INT 1
75849: NEG
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 1
75857: NEG
75858: PUSH
75859: LD_INT 2
75861: NEG
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: LD_INT 2
75872: NEG
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: LD_INT 1
75883: NEG
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: LD_INT 2
75891: PUSH
75892: LD_INT 0
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 2
75901: PUSH
75902: LD_INT 1
75904: PUSH
75905: EMPTY
75906: LIST
75907: LIST
75908: PUSH
75909: LD_INT 2
75911: PUSH
75912: LD_INT 2
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 1
75921: PUSH
75922: LD_INT 2
75924: PUSH
75925: EMPTY
75926: LIST
75927: LIST
75928: PUSH
75929: LD_INT 0
75931: PUSH
75932: LD_INT 2
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: LD_INT 1
75941: NEG
75942: PUSH
75943: LD_INT 1
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 2
75952: NEG
75953: PUSH
75954: LD_INT 0
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 2
75963: NEG
75964: PUSH
75965: LD_INT 1
75967: NEG
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 2
75975: NEG
75976: PUSH
75977: LD_INT 2
75979: NEG
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: LIST
76000: LIST
76001: LIST
76002: LIST
76003: LIST
76004: LIST
76005: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76006: LD_ADDR_VAR 0 19
76010: PUSH
76011: LD_INT 0
76013: PUSH
76014: LD_INT 0
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 0
76023: PUSH
76024: LD_INT 1
76026: NEG
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: LD_INT 0
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 1
76044: PUSH
76045: LD_INT 1
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 0
76054: PUSH
76055: LD_INT 1
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PUSH
76062: LD_INT 1
76064: NEG
76065: PUSH
76066: LD_INT 0
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 1
76075: NEG
76076: PUSH
76077: LD_INT 1
76079: NEG
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 1
76087: NEG
76088: PUSH
76089: LD_INT 2
76091: NEG
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: LD_INT 2
76102: NEG
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 1
76110: PUSH
76111: LD_INT 1
76113: NEG
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: LD_INT 2
76121: PUSH
76122: LD_INT 0
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 2
76131: PUSH
76132: LD_INT 1
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: LD_INT 2
76141: PUSH
76142: LD_INT 2
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 1
76151: PUSH
76152: LD_INT 2
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: PUSH
76159: LD_INT 0
76161: PUSH
76162: LD_INT 2
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 1
76171: NEG
76172: PUSH
76173: LD_INT 1
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 2
76182: NEG
76183: PUSH
76184: LD_INT 0
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 2
76193: NEG
76194: PUSH
76195: LD_INT 1
76197: NEG
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: PUSH
76203: LD_INT 2
76205: NEG
76206: PUSH
76207: LD_INT 2
76209: NEG
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: LIST
76230: LIST
76231: LIST
76232: LIST
76233: LIST
76234: LIST
76235: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76236: LD_ADDR_VAR 0 20
76240: PUSH
76241: LD_INT 0
76243: PUSH
76244: LD_INT 0
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 0
76253: PUSH
76254: LD_INT 1
76256: NEG
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 1
76264: PUSH
76265: LD_INT 0
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 1
76274: PUSH
76275: LD_INT 1
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 0
76284: PUSH
76285: LD_INT 1
76287: PUSH
76288: EMPTY
76289: LIST
76290: LIST
76291: PUSH
76292: LD_INT 1
76294: NEG
76295: PUSH
76296: LD_INT 0
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 1
76305: NEG
76306: PUSH
76307: LD_INT 1
76309: NEG
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PUSH
76315: LD_INT 1
76317: NEG
76318: PUSH
76319: LD_INT 2
76321: NEG
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 0
76329: PUSH
76330: LD_INT 2
76332: NEG
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 1
76340: PUSH
76341: LD_INT 1
76343: NEG
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: LD_INT 2
76351: PUSH
76352: LD_INT 0
76354: PUSH
76355: EMPTY
76356: LIST
76357: LIST
76358: PUSH
76359: LD_INT 2
76361: PUSH
76362: LD_INT 1
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 2
76371: PUSH
76372: LD_INT 2
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 1
76381: PUSH
76382: LD_INT 2
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 0
76391: PUSH
76392: LD_INT 2
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 1
76401: NEG
76402: PUSH
76403: LD_INT 1
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 2
76412: NEG
76413: PUSH
76414: LD_INT 0
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 2
76423: NEG
76424: PUSH
76425: LD_INT 1
76427: NEG
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 2
76435: NEG
76436: PUSH
76437: LD_INT 2
76439: NEG
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: LIST
76459: LIST
76460: LIST
76461: LIST
76462: LIST
76463: LIST
76464: LIST
76465: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76466: LD_ADDR_VAR 0 21
76470: PUSH
76471: LD_INT 0
76473: PUSH
76474: LD_INT 0
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 0
76483: PUSH
76484: LD_INT 1
76486: NEG
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 1
76494: PUSH
76495: LD_INT 0
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 1
76504: PUSH
76505: LD_INT 1
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 0
76514: PUSH
76515: LD_INT 1
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 1
76524: NEG
76525: PUSH
76526: LD_INT 0
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 1
76535: NEG
76536: PUSH
76537: LD_INT 1
76539: NEG
76540: PUSH
76541: EMPTY
76542: LIST
76543: LIST
76544: PUSH
76545: LD_INT 1
76547: NEG
76548: PUSH
76549: LD_INT 2
76551: NEG
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 0
76559: PUSH
76560: LD_INT 2
76562: NEG
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: PUSH
76568: LD_INT 1
76570: PUSH
76571: LD_INT 1
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: LD_INT 2
76581: PUSH
76582: LD_INT 0
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PUSH
76589: LD_INT 2
76591: PUSH
76592: LD_INT 1
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: PUSH
76599: LD_INT 2
76601: PUSH
76602: LD_INT 2
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 1
76611: PUSH
76612: LD_INT 2
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: LD_INT 0
76621: PUSH
76622: LD_INT 2
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 1
76631: NEG
76632: PUSH
76633: LD_INT 1
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 2
76642: NEG
76643: PUSH
76644: LD_INT 0
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 2
76653: NEG
76654: PUSH
76655: LD_INT 1
76657: NEG
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: LD_INT 2
76665: NEG
76666: PUSH
76667: LD_INT 2
76669: NEG
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: LIST
76694: LIST
76695: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76696: LD_ADDR_VAR 0 22
76700: PUSH
76701: LD_INT 0
76703: PUSH
76704: LD_INT 0
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 0
76713: PUSH
76714: LD_INT 1
76716: NEG
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 1
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 1
76734: PUSH
76735: LD_INT 1
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 0
76744: PUSH
76745: LD_INT 1
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 1
76754: NEG
76755: PUSH
76756: LD_INT 0
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 1
76765: NEG
76766: PUSH
76767: LD_INT 1
76769: NEG
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 1
76777: NEG
76778: PUSH
76779: LD_INT 2
76781: NEG
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 0
76789: PUSH
76790: LD_INT 2
76792: NEG
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 1
76800: PUSH
76801: LD_INT 1
76803: NEG
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: LD_INT 2
76811: PUSH
76812: LD_INT 0
76814: PUSH
76815: EMPTY
76816: LIST
76817: LIST
76818: PUSH
76819: LD_INT 2
76821: PUSH
76822: LD_INT 1
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: LD_INT 2
76831: PUSH
76832: LD_INT 2
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: LD_INT 2
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 0
76851: PUSH
76852: LD_INT 2
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 1
76861: NEG
76862: PUSH
76863: LD_INT 1
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 2
76872: NEG
76873: PUSH
76874: LD_INT 0
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 2
76883: NEG
76884: PUSH
76885: LD_INT 1
76887: NEG
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: PUSH
76893: LD_INT 2
76895: NEG
76896: PUSH
76897: LD_INT 2
76899: NEG
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: LIST
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76926: LD_ADDR_VAR 0 23
76930: PUSH
76931: LD_INT 0
76933: PUSH
76934: LD_INT 0
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 0
76943: PUSH
76944: LD_INT 1
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 1
76954: PUSH
76955: LD_INT 0
76957: PUSH
76958: EMPTY
76959: LIST
76960: LIST
76961: PUSH
76962: LD_INT 1
76964: PUSH
76965: LD_INT 1
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_INT 0
76974: PUSH
76975: LD_INT 1
76977: PUSH
76978: EMPTY
76979: LIST
76980: LIST
76981: PUSH
76982: LD_INT 1
76984: NEG
76985: PUSH
76986: LD_INT 0
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 1
76995: NEG
76996: PUSH
76997: LD_INT 1
76999: NEG
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: PUSH
77005: LD_INT 1
77007: NEG
77008: PUSH
77009: LD_INT 2
77011: NEG
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 0
77019: PUSH
77020: LD_INT 2
77022: NEG
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: PUSH
77031: LD_INT 1
77033: NEG
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: LD_INT 2
77041: PUSH
77042: LD_INT 0
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PUSH
77049: LD_INT 2
77051: PUSH
77052: LD_INT 1
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 2
77061: PUSH
77062: LD_INT 2
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 1
77071: PUSH
77072: LD_INT 2
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 0
77081: PUSH
77082: LD_INT 2
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 1
77091: NEG
77092: PUSH
77093: LD_INT 1
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 2
77102: NEG
77103: PUSH
77104: LD_INT 0
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 2
77113: NEG
77114: PUSH
77115: LD_INT 1
77117: NEG
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: LD_INT 2
77125: NEG
77126: PUSH
77127: LD_INT 2
77129: NEG
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 2
77137: NEG
77138: PUSH
77139: LD_INT 3
77141: NEG
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 1
77149: NEG
77150: PUSH
77151: LD_INT 3
77153: NEG
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 1
77161: PUSH
77162: LD_INT 2
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 2
77172: PUSH
77173: LD_INT 1
77175: NEG
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: LIST
77185: LIST
77186: LIST
77187: LIST
77188: LIST
77189: LIST
77190: LIST
77191: LIST
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
77206: LD_ADDR_VAR 0 24
77210: PUSH
77211: LD_INT 0
77213: PUSH
77214: LD_INT 0
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PUSH
77221: LD_INT 0
77223: PUSH
77224: LD_INT 1
77226: NEG
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: PUSH
77232: LD_INT 1
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 1
77244: PUSH
77245: LD_INT 1
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 0
77254: PUSH
77255: LD_INT 1
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 1
77264: NEG
77265: PUSH
77266: LD_INT 0
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 1
77275: NEG
77276: PUSH
77277: LD_INT 1
77279: NEG
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 1
77287: NEG
77288: PUSH
77289: LD_INT 2
77291: NEG
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 0
77299: PUSH
77300: LD_INT 2
77302: NEG
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 1
77310: PUSH
77311: LD_INT 1
77313: NEG
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 2
77321: PUSH
77322: LD_INT 0
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 2
77331: PUSH
77332: LD_INT 1
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: LD_INT 2
77341: PUSH
77342: LD_INT 2
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 1
77351: PUSH
77352: LD_INT 2
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 0
77361: PUSH
77362: LD_INT 2
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: LD_INT 1
77371: NEG
77372: PUSH
77373: LD_INT 1
77375: PUSH
77376: EMPTY
77377: LIST
77378: LIST
77379: PUSH
77380: LD_INT 2
77382: NEG
77383: PUSH
77384: LD_INT 0
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: PUSH
77391: LD_INT 2
77393: NEG
77394: PUSH
77395: LD_INT 1
77397: NEG
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: PUSH
77403: LD_INT 2
77405: NEG
77406: PUSH
77407: LD_INT 2
77409: NEG
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: PUSH
77415: LD_INT 1
77417: PUSH
77418: LD_INT 2
77420: NEG
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 2
77428: PUSH
77429: LD_INT 1
77431: NEG
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 3
77439: PUSH
77440: LD_INT 1
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 3
77449: PUSH
77450: LD_INT 2
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: LIST
77466: LIST
77467: LIST
77468: LIST
77469: LIST
77470: LIST
77471: LIST
77472: LIST
77473: LIST
77474: LIST
77475: LIST
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: LIST
77481: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
77482: LD_ADDR_VAR 0 25
77486: PUSH
77487: LD_INT 0
77489: PUSH
77490: LD_INT 0
77492: PUSH
77493: EMPTY
77494: LIST
77495: LIST
77496: PUSH
77497: LD_INT 0
77499: PUSH
77500: LD_INT 1
77502: NEG
77503: PUSH
77504: EMPTY
77505: LIST
77506: LIST
77507: PUSH
77508: LD_INT 1
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 1
77520: PUSH
77521: LD_INT 1
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 0
77530: PUSH
77531: LD_INT 1
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PUSH
77538: LD_INT 1
77540: NEG
77541: PUSH
77542: LD_INT 0
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 1
77551: NEG
77552: PUSH
77553: LD_INT 1
77555: NEG
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 1
77563: NEG
77564: PUSH
77565: LD_INT 2
77567: NEG
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 0
77575: PUSH
77576: LD_INT 2
77578: NEG
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 1
77586: PUSH
77587: LD_INT 1
77589: NEG
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 2
77597: PUSH
77598: LD_INT 0
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 2
77607: PUSH
77608: LD_INT 1
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 2
77617: PUSH
77618: LD_INT 2
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 1
77627: PUSH
77628: LD_INT 2
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 0
77637: PUSH
77638: LD_INT 2
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: LD_INT 1
77647: NEG
77648: PUSH
77649: LD_INT 1
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 2
77658: NEG
77659: PUSH
77660: LD_INT 0
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 2
77669: NEG
77670: PUSH
77671: LD_INT 1
77673: NEG
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: PUSH
77679: LD_INT 2
77681: NEG
77682: PUSH
77683: LD_INT 2
77685: NEG
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 3
77693: PUSH
77694: LD_INT 1
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: PUSH
77701: LD_INT 3
77703: PUSH
77704: LD_INT 2
77706: PUSH
77707: EMPTY
77708: LIST
77709: LIST
77710: PUSH
77711: LD_INT 2
77713: PUSH
77714: LD_INT 3
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 1
77723: PUSH
77724: LD_INT 3
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: LIST
77735: LIST
77736: LIST
77737: LIST
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: LIST
77755: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77756: LD_ADDR_VAR 0 26
77760: PUSH
77761: LD_INT 0
77763: PUSH
77764: LD_INT 0
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 0
77773: PUSH
77774: LD_INT 1
77776: NEG
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 1
77784: PUSH
77785: LD_INT 0
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 1
77794: PUSH
77795: LD_INT 1
77797: PUSH
77798: EMPTY
77799: LIST
77800: LIST
77801: PUSH
77802: LD_INT 0
77804: PUSH
77805: LD_INT 1
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 1
77814: NEG
77815: PUSH
77816: LD_INT 0
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 1
77825: NEG
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 1
77837: NEG
77838: PUSH
77839: LD_INT 2
77841: NEG
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 0
77849: PUSH
77850: LD_INT 2
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: LD_INT 1
77863: NEG
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: LD_INT 2
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 2
77881: PUSH
77882: LD_INT 1
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 2
77891: PUSH
77892: LD_INT 2
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 1
77901: PUSH
77902: LD_INT 2
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: LD_INT 2
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: LD_INT 1
77921: NEG
77922: PUSH
77923: LD_INT 1
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 2
77932: NEG
77933: PUSH
77934: LD_INT 0
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 2
77943: NEG
77944: PUSH
77945: LD_INT 1
77947: NEG
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 2
77955: NEG
77956: PUSH
77957: LD_INT 2
77959: NEG
77960: PUSH
77961: EMPTY
77962: LIST
77963: LIST
77964: PUSH
77965: LD_INT 2
77967: PUSH
77968: LD_INT 3
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 1
77977: PUSH
77978: LD_INT 3
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 1
77987: NEG
77988: PUSH
77989: LD_INT 2
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 2
77998: NEG
77999: PUSH
78000: LD_INT 1
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: LIST
78030: LIST
78031: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78032: LD_ADDR_VAR 0 27
78036: PUSH
78037: LD_INT 0
78039: PUSH
78040: LD_INT 0
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 0
78049: PUSH
78050: LD_INT 1
78052: NEG
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 1
78060: PUSH
78061: LD_INT 0
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 1
78070: PUSH
78071: LD_INT 1
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 0
78080: PUSH
78081: LD_INT 1
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 1
78090: NEG
78091: PUSH
78092: LD_INT 0
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 1
78101: NEG
78102: PUSH
78103: LD_INT 1
78105: NEG
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 1
78113: NEG
78114: PUSH
78115: LD_INT 2
78117: NEG
78118: PUSH
78119: EMPTY
78120: LIST
78121: LIST
78122: PUSH
78123: LD_INT 0
78125: PUSH
78126: LD_INT 2
78128: NEG
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: PUSH
78134: LD_INT 1
78136: PUSH
78137: LD_INT 1
78139: NEG
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 2
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 2
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: LD_INT 2
78167: PUSH
78168: LD_INT 2
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 1
78177: PUSH
78178: LD_INT 2
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 0
78187: PUSH
78188: LD_INT 2
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 1
78197: NEG
78198: PUSH
78199: LD_INT 1
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: LD_INT 2
78208: NEG
78209: PUSH
78210: LD_INT 0
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: LD_INT 2
78219: NEG
78220: PUSH
78221: LD_INT 1
78223: NEG
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 2
78231: NEG
78232: PUSH
78233: LD_INT 2
78235: NEG
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 1
78243: NEG
78244: PUSH
78245: LD_INT 2
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: PUSH
78252: LD_INT 2
78254: NEG
78255: PUSH
78256: LD_INT 1
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PUSH
78263: LD_INT 3
78265: NEG
78266: PUSH
78267: LD_INT 1
78269: NEG
78270: PUSH
78271: EMPTY
78272: LIST
78273: LIST
78274: PUSH
78275: LD_INT 3
78277: NEG
78278: PUSH
78279: LD_INT 2
78281: NEG
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78312: LD_ADDR_VAR 0 28
78316: PUSH
78317: LD_INT 0
78319: PUSH
78320: LD_INT 0
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 0
78329: PUSH
78330: LD_INT 1
78332: NEG
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 1
78340: PUSH
78341: LD_INT 0
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 1
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 0
78360: PUSH
78361: LD_INT 1
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 1
78370: NEG
78371: PUSH
78372: LD_INT 0
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 1
78381: NEG
78382: PUSH
78383: LD_INT 1
78385: NEG
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 1
78393: NEG
78394: PUSH
78395: LD_INT 2
78397: NEG
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: LD_INT 0
78405: PUSH
78406: LD_INT 2
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: LD_INT 1
78416: PUSH
78417: LD_INT 1
78419: NEG
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PUSH
78425: LD_INT 2
78427: PUSH
78428: LD_INT 0
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 2
78437: PUSH
78438: LD_INT 1
78440: PUSH
78441: EMPTY
78442: LIST
78443: LIST
78444: PUSH
78445: LD_INT 2
78447: PUSH
78448: LD_INT 2
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 1
78457: PUSH
78458: LD_INT 2
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 0
78467: PUSH
78468: LD_INT 2
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: LD_INT 1
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 2
78488: NEG
78489: PUSH
78490: LD_INT 0
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 2
78499: NEG
78500: PUSH
78501: LD_INT 1
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 2
78511: NEG
78512: PUSH
78513: LD_INT 2
78515: NEG
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 2
78523: NEG
78524: PUSH
78525: LD_INT 3
78527: NEG
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 1
78535: NEG
78536: PUSH
78537: LD_INT 3
78539: NEG
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 3
78547: NEG
78548: PUSH
78549: LD_INT 1
78551: NEG
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PUSH
78557: LD_INT 3
78559: NEG
78560: PUSH
78561: LD_INT 2
78563: NEG
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: LIST
78586: LIST
78587: LIST
78588: LIST
78589: LIST
78590: LIST
78591: LIST
78592: LIST
78593: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
78594: LD_ADDR_VAR 0 29
78598: PUSH
78599: LD_INT 0
78601: PUSH
78602: LD_INT 0
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: PUSH
78609: LD_INT 0
78611: PUSH
78612: LD_INT 1
78614: NEG
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 1
78622: PUSH
78623: LD_INT 0
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 1
78632: PUSH
78633: LD_INT 1
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 0
78642: PUSH
78643: LD_INT 1
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 1
78652: NEG
78653: PUSH
78654: LD_INT 0
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 1
78663: NEG
78664: PUSH
78665: LD_INT 1
78667: NEG
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 1
78675: NEG
78676: PUSH
78677: LD_INT 2
78679: NEG
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 0
78687: PUSH
78688: LD_INT 2
78690: NEG
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: PUSH
78696: LD_INT 1
78698: PUSH
78699: LD_INT 1
78701: NEG
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: PUSH
78707: LD_INT 2
78709: PUSH
78710: LD_INT 0
78712: PUSH
78713: EMPTY
78714: LIST
78715: LIST
78716: PUSH
78717: LD_INT 2
78719: PUSH
78720: LD_INT 1
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 1
78729: PUSH
78730: LD_INT 2
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 0
78739: PUSH
78740: LD_INT 2
78742: PUSH
78743: EMPTY
78744: LIST
78745: LIST
78746: PUSH
78747: LD_INT 1
78749: NEG
78750: PUSH
78751: LD_INT 1
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 2
78760: NEG
78761: PUSH
78762: LD_INT 1
78764: NEG
78765: PUSH
78766: EMPTY
78767: LIST
78768: LIST
78769: PUSH
78770: LD_INT 2
78772: NEG
78773: PUSH
78774: LD_INT 2
78776: NEG
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 2
78784: NEG
78785: PUSH
78786: LD_INT 3
78788: NEG
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 2
78796: PUSH
78797: LD_INT 1
78799: NEG
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 3
78807: PUSH
78808: LD_INT 1
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 1
78817: PUSH
78818: LD_INT 3
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 1
78827: NEG
78828: PUSH
78829: LD_INT 2
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 3
78838: NEG
78839: PUSH
78840: LD_INT 2
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78873: LD_ADDR_VAR 0 30
78877: PUSH
78878: LD_INT 0
78880: PUSH
78881: LD_INT 0
78883: PUSH
78884: EMPTY
78885: LIST
78886: LIST
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 1
78901: PUSH
78902: LD_INT 0
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: LD_INT 1
78911: PUSH
78912: LD_INT 1
78914: PUSH
78915: EMPTY
78916: LIST
78917: LIST
78918: PUSH
78919: LD_INT 0
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 1
78931: NEG
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 1
78942: NEG
78943: PUSH
78944: LD_INT 1
78946: NEG
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 1
78954: NEG
78955: PUSH
78956: LD_INT 2
78958: NEG
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: PUSH
78964: LD_INT 0
78966: PUSH
78967: LD_INT 2
78969: NEG
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: LD_INT 1
78977: PUSH
78978: LD_INT 1
78980: NEG
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 2
78988: PUSH
78989: LD_INT 0
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 2
78998: PUSH
78999: LD_INT 1
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 2
79008: PUSH
79009: LD_INT 2
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 1
79018: PUSH
79019: LD_INT 2
79021: PUSH
79022: EMPTY
79023: LIST
79024: LIST
79025: PUSH
79026: LD_INT 1
79028: NEG
79029: PUSH
79030: LD_INT 1
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 2
79039: NEG
79040: PUSH
79041: LD_INT 0
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 2
79050: NEG
79051: PUSH
79052: LD_INT 1
79054: NEG
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 1
79062: NEG
79063: PUSH
79064: LD_INT 3
79066: NEG
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: LD_INT 2
79077: NEG
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 3
79085: PUSH
79086: LD_INT 2
79088: PUSH
79089: EMPTY
79090: LIST
79091: LIST
79092: PUSH
79093: LD_INT 2
79095: PUSH
79096: LD_INT 3
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 2
79105: NEG
79106: PUSH
79107: LD_INT 1
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 3
79116: NEG
79117: PUSH
79118: LD_INT 1
79120: NEG
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: LIST
79141: LIST
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79151: LD_ADDR_VAR 0 31
79155: PUSH
79156: LD_INT 0
79158: PUSH
79159: LD_INT 0
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 0
79168: PUSH
79169: LD_INT 1
79171: NEG
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 1
79179: PUSH
79180: LD_INT 0
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 1
79189: PUSH
79190: LD_INT 1
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 0
79199: PUSH
79200: LD_INT 1
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 1
79209: NEG
79210: PUSH
79211: LD_INT 0
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 1
79220: NEG
79221: PUSH
79222: LD_INT 1
79224: NEG
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PUSH
79230: LD_INT 1
79232: NEG
79233: PUSH
79234: LD_INT 2
79236: NEG
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 1
79244: PUSH
79245: LD_INT 1
79247: NEG
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 2
79255: PUSH
79256: LD_INT 0
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 2
79265: PUSH
79266: LD_INT 1
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 2
79275: PUSH
79276: LD_INT 2
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 1
79285: PUSH
79286: LD_INT 2
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 0
79295: PUSH
79296: LD_INT 2
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 1
79305: NEG
79306: PUSH
79307: LD_INT 1
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 2
79316: NEG
79317: PUSH
79318: LD_INT 1
79320: NEG
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: LD_INT 2
79328: NEG
79329: PUSH
79330: LD_INT 2
79332: NEG
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 2
79340: NEG
79341: PUSH
79342: LD_INT 3
79344: NEG
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: LD_INT 2
79352: PUSH
79353: LD_INT 1
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 3
79363: PUSH
79364: LD_INT 1
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 1
79373: PUSH
79374: LD_INT 3
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 1
79383: NEG
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 3
79394: NEG
79395: PUSH
79396: LD_INT 2
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79429: LD_ADDR_VAR 0 32
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: LD_INT 0
79439: PUSH
79440: EMPTY
79441: LIST
79442: LIST
79443: PUSH
79444: LD_INT 0
79446: PUSH
79447: LD_INT 1
79449: NEG
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 1
79457: PUSH
79458: LD_INT 0
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: PUSH
79468: LD_INT 1
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 0
79477: PUSH
79478: LD_INT 1
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 1
79487: NEG
79488: PUSH
79489: LD_INT 0
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 1
79498: NEG
79499: PUSH
79500: LD_INT 1
79502: NEG
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PUSH
79508: LD_INT 1
79510: NEG
79511: PUSH
79512: LD_INT 2
79514: NEG
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 0
79522: PUSH
79523: LD_INT 2
79525: NEG
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 1
79533: PUSH
79534: LD_INT 1
79536: NEG
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: LD_INT 1
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: LD_INT 2
79554: PUSH
79555: LD_INT 2
79557: PUSH
79558: EMPTY
79559: LIST
79560: LIST
79561: PUSH
79562: LD_INT 1
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 0
79574: PUSH
79575: LD_INT 2
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 1
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 2
79595: NEG
79596: PUSH
79597: LD_INT 0
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 2
79606: NEG
79607: PUSH
79608: LD_INT 1
79610: NEG
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 1
79618: NEG
79619: PUSH
79620: LD_INT 3
79622: NEG
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: PUSH
79628: LD_INT 1
79630: PUSH
79631: LD_INT 2
79633: NEG
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 3
79641: PUSH
79642: LD_INT 2
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 2
79651: PUSH
79652: LD_INT 3
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 2
79661: NEG
79662: PUSH
79663: LD_INT 1
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 3
79672: NEG
79673: PUSH
79674: LD_INT 1
79676: NEG
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: LIST
79694: LIST
79695: LIST
79696: LIST
79697: LIST
79698: LIST
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79707: LD_ADDR_VAR 0 33
79711: PUSH
79712: LD_INT 0
79714: PUSH
79715: LD_INT 0
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 0
79724: PUSH
79725: LD_INT 1
79727: NEG
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 1
79735: PUSH
79736: LD_INT 0
79738: PUSH
79739: EMPTY
79740: LIST
79741: LIST
79742: PUSH
79743: LD_INT 1
79745: PUSH
79746: LD_INT 1
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 0
79755: PUSH
79756: LD_INT 1
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: LD_INT 0
79769: PUSH
79770: EMPTY
79771: LIST
79772: LIST
79773: PUSH
79774: LD_INT 1
79776: NEG
79777: PUSH
79778: LD_INT 1
79780: NEG
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: PUSH
79786: LD_INT 1
79788: NEG
79789: PUSH
79790: LD_INT 2
79792: NEG
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 1
79800: PUSH
79801: LD_INT 1
79803: NEG
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 2
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: PUSH
79822: LD_INT 1
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 1
79831: PUSH
79832: LD_INT 2
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 0
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 1
79851: NEG
79852: PUSH
79853: LD_INT 1
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: NEG
79863: PUSH
79864: LD_INT 0
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: PUSH
79871: LD_INT 2
79873: NEG
79874: PUSH
79875: LD_INT 1
79877: NEG
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 2
79885: NEG
79886: PUSH
79887: LD_INT 2
79889: NEG
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 2
79897: NEG
79898: PUSH
79899: LD_INT 3
79901: NEG
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 2
79909: PUSH
79910: LD_INT 1
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 3
79920: PUSH
79921: LD_INT 1
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: LD_INT 3
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 1
79940: NEG
79941: PUSH
79942: LD_INT 2
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 3
79951: NEG
79952: PUSH
79953: LD_INT 2
79955: NEG
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: LIST
79965: LIST
79966: LIST
79967: LIST
79968: LIST
79969: LIST
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79986: LD_ADDR_VAR 0 34
79990: PUSH
79991: LD_INT 0
79993: PUSH
79994: LD_INT 0
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: PUSH
80001: LD_INT 0
80003: PUSH
80004: LD_INT 1
80006: NEG
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 1
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 1
80024: PUSH
80025: LD_INT 1
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 0
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: LD_INT 1
80044: NEG
80045: PUSH
80046: LD_INT 0
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 1
80055: NEG
80056: PUSH
80057: LD_INT 1
80059: NEG
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 1
80067: NEG
80068: PUSH
80069: LD_INT 2
80071: NEG
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 2
80082: NEG
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 1
80090: PUSH
80091: LD_INT 1
80093: NEG
80094: PUSH
80095: EMPTY
80096: LIST
80097: LIST
80098: PUSH
80099: LD_INT 2
80101: PUSH
80102: LD_INT 1
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 2
80111: PUSH
80112: LD_INT 2
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: LD_INT 2
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 1
80131: NEG
80132: PUSH
80133: LD_INT 1
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 2
80142: NEG
80143: PUSH
80144: LD_INT 0
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: PUSH
80151: LD_INT 2
80153: NEG
80154: PUSH
80155: LD_INT 1
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 2
80165: NEG
80166: PUSH
80167: LD_INT 2
80169: NEG
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 1
80177: NEG
80178: PUSH
80179: LD_INT 3
80181: NEG
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 1
80189: PUSH
80190: LD_INT 2
80192: NEG
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 3
80200: PUSH
80201: LD_INT 2
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 2
80210: PUSH
80211: LD_INT 3
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 2
80220: NEG
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 3
80231: NEG
80232: PUSH
80233: LD_INT 1
80235: NEG
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: LIST
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: LIST
80250: LIST
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80266: LD_ADDR_VAR 0 35
80270: PUSH
80271: LD_INT 0
80273: PUSH
80274: LD_INT 0
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 0
80283: PUSH
80284: LD_INT 1
80286: NEG
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PUSH
80292: LD_INT 1
80294: PUSH
80295: LD_INT 0
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 1
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 0
80314: PUSH
80315: LD_INT 1
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 1
80324: NEG
80325: PUSH
80326: LD_INT 0
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: NEG
80336: PUSH
80337: LD_INT 1
80339: NEG
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 2
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 2
80357: NEG
80358: PUSH
80359: LD_INT 1
80361: NEG
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80378: LD_ADDR_VAR 0 36
80382: PUSH
80383: LD_INT 0
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 0
80395: PUSH
80396: LD_INT 1
80398: NEG
80399: PUSH
80400: EMPTY
80401: LIST
80402: LIST
80403: PUSH
80404: LD_INT 1
80406: PUSH
80407: LD_INT 0
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: LD_INT 1
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 0
80426: PUSH
80427: LD_INT 1
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 1
80436: NEG
80437: PUSH
80438: LD_INT 0
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 1
80447: NEG
80448: PUSH
80449: LD_INT 1
80451: NEG
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 1
80459: NEG
80460: PUSH
80461: LD_INT 2
80463: NEG
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: LD_INT 2
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80490: LD_ADDR_VAR 0 37
80494: PUSH
80495: LD_INT 0
80497: PUSH
80498: LD_INT 0
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 0
80507: PUSH
80508: LD_INT 1
80510: NEG
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 1
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 1
80528: PUSH
80529: LD_INT 1
80531: PUSH
80532: EMPTY
80533: LIST
80534: LIST
80535: PUSH
80536: LD_INT 0
80538: PUSH
80539: LD_INT 1
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 1
80559: NEG
80560: PUSH
80561: LD_INT 1
80563: NEG
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 1
80571: PUSH
80572: LD_INT 1
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 1
80582: NEG
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80602: LD_ADDR_VAR 0 38
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: LD_INT 0
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 0
80619: PUSH
80620: LD_INT 1
80622: NEG
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: LD_INT 0
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 1
80640: PUSH
80641: LD_INT 1
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 1
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: NEG
80661: PUSH
80662: LD_INT 0
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: NEG
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 2
80683: PUSH
80684: LD_INT 1
80686: PUSH
80687: EMPTY
80688: LIST
80689: LIST
80690: PUSH
80691: LD_INT 2
80693: NEG
80694: PUSH
80695: LD_INT 1
80697: NEG
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80714: LD_ADDR_VAR 0 39
80718: PUSH
80719: LD_INT 0
80721: PUSH
80722: LD_INT 0
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 0
80731: PUSH
80732: LD_INT 1
80734: NEG
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 1
80742: PUSH
80743: LD_INT 0
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: PUSH
80753: LD_INT 1
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: PUSH
80760: LD_INT 0
80762: PUSH
80763: LD_INT 1
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 1
80772: NEG
80773: PUSH
80774: LD_INT 0
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 1
80783: NEG
80784: PUSH
80785: LD_INT 1
80787: NEG
80788: PUSH
80789: EMPTY
80790: LIST
80791: LIST
80792: PUSH
80793: LD_INT 1
80795: NEG
80796: PUSH
80797: LD_INT 2
80799: NEG
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: LD_INT 2
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80826: LD_ADDR_VAR 0 40
80830: PUSH
80831: LD_INT 0
80833: PUSH
80834: LD_INT 0
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PUSH
80841: LD_INT 0
80843: PUSH
80844: LD_INT 1
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 1
80854: PUSH
80855: LD_INT 0
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: LD_INT 1
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 0
80874: PUSH
80875: LD_INT 1
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 1
80884: NEG
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 1
80895: NEG
80896: PUSH
80897: LD_INT 1
80899: NEG
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 1
80907: PUSH
80908: LD_INT 1
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 1
80918: NEG
80919: PUSH
80920: LD_INT 1
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80938: LD_ADDR_VAR 0 41
80942: PUSH
80943: LD_INT 0
80945: PUSH
80946: LD_INT 0
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 0
80955: PUSH
80956: LD_INT 1
80958: NEG
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: PUSH
80964: LD_INT 1
80966: PUSH
80967: LD_INT 0
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: LD_INT 1
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: LD_INT 1
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 1
80996: NEG
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 1
81007: NEG
81008: PUSH
81009: LD_INT 1
81011: NEG
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 1
81019: NEG
81020: PUSH
81021: LD_INT 2
81023: NEG
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 2
81042: PUSH
81043: LD_INT 0
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 2
81052: PUSH
81053: LD_INT 1
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 2
81062: PUSH
81063: LD_INT 2
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 1
81072: PUSH
81073: LD_INT 2
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 1
81082: NEG
81083: PUSH
81084: LD_INT 1
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 2
81093: NEG
81094: PUSH
81095: LD_INT 0
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 2
81104: NEG
81105: PUSH
81106: LD_INT 1
81108: NEG
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 2
81116: NEG
81117: PUSH
81118: LD_INT 2
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 2
81128: NEG
81129: PUSH
81130: LD_INT 3
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 2
81140: PUSH
81141: LD_INT 1
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 3
81151: PUSH
81152: LD_INT 0
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 3
81161: PUSH
81162: LD_INT 1
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 3
81171: PUSH
81172: LD_INT 2
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 3
81181: PUSH
81182: LD_INT 3
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 2
81191: PUSH
81192: LD_INT 3
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PUSH
81199: LD_INT 2
81201: NEG
81202: PUSH
81203: LD_INT 1
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 3
81212: NEG
81213: PUSH
81214: LD_INT 0
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 3
81223: NEG
81224: PUSH
81225: LD_INT 1
81227: NEG
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 3
81235: NEG
81236: PUSH
81237: LD_INT 2
81239: NEG
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 3
81247: NEG
81248: PUSH
81249: LD_INT 3
81251: NEG
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: LIST
81268: LIST
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81288: LD_ADDR_VAR 0 42
81292: PUSH
81293: LD_INT 0
81295: PUSH
81296: LD_INT 0
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: LD_INT 0
81305: PUSH
81306: LD_INT 1
81308: NEG
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 1
81316: PUSH
81317: LD_INT 0
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: LD_INT 1
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 0
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 1
81346: NEG
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: NEG
81358: PUSH
81359: LD_INT 1
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 1
81369: NEG
81370: PUSH
81371: LD_INT 2
81373: NEG
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 0
81381: PUSH
81382: LD_INT 2
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: LD_INT 1
81395: NEG
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 2
81403: PUSH
81404: LD_INT 1
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 2
81413: PUSH
81414: LD_INT 2
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 1
81423: PUSH
81424: LD_INT 2
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 0
81433: PUSH
81434: LD_INT 2
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: NEG
81444: PUSH
81445: LD_INT 1
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 2
81454: NEG
81455: PUSH
81456: LD_INT 1
81458: NEG
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: PUSH
81464: LD_INT 2
81466: NEG
81467: PUSH
81468: LD_INT 2
81470: NEG
81471: PUSH
81472: EMPTY
81473: LIST
81474: LIST
81475: PUSH
81476: LD_INT 2
81478: NEG
81479: PUSH
81480: LD_INT 3
81482: NEG
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 1
81490: NEG
81491: PUSH
81492: LD_INT 3
81494: NEG
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 0
81502: PUSH
81503: LD_INT 3
81505: NEG
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 1
81513: PUSH
81514: LD_INT 2
81516: NEG
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 3
81524: PUSH
81525: LD_INT 2
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 3
81534: PUSH
81535: LD_INT 3
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 2
81544: PUSH
81545: LD_INT 3
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 1
81554: PUSH
81555: LD_INT 3
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 0
81564: PUSH
81565: LD_INT 3
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PUSH
81572: LD_INT 1
81574: NEG
81575: PUSH
81576: LD_INT 2
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 3
81585: NEG
81586: PUSH
81587: LD_INT 2
81589: NEG
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 3
81597: NEG
81598: PUSH
81599: LD_INT 3
81601: NEG
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: LIST
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: LIST
81637: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81638: LD_ADDR_VAR 0 43
81642: PUSH
81643: LD_INT 0
81645: PUSH
81646: LD_INT 0
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 0
81655: PUSH
81656: LD_INT 1
81658: NEG
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 1
81666: PUSH
81667: LD_INT 0
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 1
81676: PUSH
81677: LD_INT 1
81679: PUSH
81680: EMPTY
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 0
81686: PUSH
81687: LD_INT 1
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 1
81696: NEG
81697: PUSH
81698: LD_INT 0
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 1
81707: NEG
81708: PUSH
81709: LD_INT 1
81711: NEG
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 1
81719: NEG
81720: PUSH
81721: LD_INT 2
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 0
81731: PUSH
81732: LD_INT 2
81734: NEG
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 1
81742: PUSH
81743: LD_INT 1
81745: NEG
81746: PUSH
81747: EMPTY
81748: LIST
81749: LIST
81750: PUSH
81751: LD_INT 2
81753: PUSH
81754: LD_INT 0
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 2
81763: PUSH
81764: LD_INT 1
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 1
81773: PUSH
81774: LD_INT 2
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 0
81783: PUSH
81784: LD_INT 2
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: LD_INT 1
81797: PUSH
81798: EMPTY
81799: LIST
81800: LIST
81801: PUSH
81802: LD_INT 2
81804: NEG
81805: PUSH
81806: LD_INT 0
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 2
81815: NEG
81816: PUSH
81817: LD_INT 1
81819: NEG
81820: PUSH
81821: EMPTY
81822: LIST
81823: LIST
81824: PUSH
81825: LD_INT 1
81827: NEG
81828: PUSH
81829: LD_INT 3
81831: NEG
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 0
81839: PUSH
81840: LD_INT 3
81842: NEG
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 1
81850: PUSH
81851: LD_INT 2
81853: NEG
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: PUSH
81859: LD_INT 2
81861: PUSH
81862: LD_INT 1
81864: NEG
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 3
81872: PUSH
81873: LD_INT 0
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 3
81882: PUSH
81883: LD_INT 1
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 1
81892: PUSH
81893: LD_INT 3
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 0
81902: PUSH
81903: LD_INT 3
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 1
81912: NEG
81913: PUSH
81914: LD_INT 2
81916: PUSH
81917: EMPTY
81918: LIST
81919: LIST
81920: PUSH
81921: LD_INT 2
81923: NEG
81924: PUSH
81925: LD_INT 1
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 3
81934: NEG
81935: PUSH
81936: LD_INT 0
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 3
81945: NEG
81946: PUSH
81947: LD_INT 1
81949: NEG
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: EMPTY
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: LIST
81979: LIST
81980: LIST
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81986: LD_ADDR_VAR 0 44
81990: PUSH
81991: LD_INT 0
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 0
82003: PUSH
82004: LD_INT 1
82006: NEG
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: PUSH
82012: LD_INT 1
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: PUSH
82022: LD_INT 1
82024: PUSH
82025: LD_INT 1
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 0
82034: PUSH
82035: LD_INT 1
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: LD_INT 0
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 1
82055: NEG
82056: PUSH
82057: LD_INT 1
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: LD_INT 2
82071: NEG
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 1
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 2
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 2
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 2
82110: PUSH
82111: LD_INT 2
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 1
82120: PUSH
82121: LD_INT 2
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 1
82130: NEG
82131: PUSH
82132: LD_INT 1
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: NEG
82142: PUSH
82143: LD_INT 0
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 2
82152: NEG
82153: PUSH
82154: LD_INT 1
82156: NEG
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 2
82164: NEG
82165: PUSH
82166: LD_INT 2
82168: NEG
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 2
82176: NEG
82177: PUSH
82178: LD_INT 3
82180: NEG
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 2
82188: PUSH
82189: LD_INT 1
82191: NEG
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PUSH
82197: LD_INT 3
82199: PUSH
82200: LD_INT 0
82202: PUSH
82203: EMPTY
82204: LIST
82205: LIST
82206: PUSH
82207: LD_INT 3
82209: PUSH
82210: LD_INT 1
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: PUSH
82217: LD_INT 3
82219: PUSH
82220: LD_INT 2
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 3
82229: PUSH
82230: LD_INT 3
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 2
82239: PUSH
82240: LD_INT 3
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 2
82249: NEG
82250: PUSH
82251: LD_INT 1
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 3
82260: NEG
82261: PUSH
82262: LD_INT 0
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 3
82271: NEG
82272: PUSH
82273: LD_INT 1
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 3
82283: NEG
82284: PUSH
82285: LD_INT 2
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 3
82295: NEG
82296: PUSH
82297: LD_INT 3
82299: NEG
82300: PUSH
82301: EMPTY
82302: LIST
82303: LIST
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82336: LD_ADDR_VAR 0 45
82340: PUSH
82341: LD_INT 0
82343: PUSH
82344: LD_INT 0
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: LD_INT 1
82356: NEG
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 1
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 1
82374: PUSH
82375: LD_INT 1
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: LD_INT 1
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: LD_INT 1
82394: NEG
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 1
82405: NEG
82406: PUSH
82407: LD_INT 1
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 1
82417: NEG
82418: PUSH
82419: LD_INT 2
82421: NEG
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 0
82429: PUSH
82430: LD_INT 2
82432: NEG
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 1
82440: PUSH
82441: LD_INT 1
82443: NEG
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 2
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 2
82461: PUSH
82462: LD_INT 2
82464: PUSH
82465: EMPTY
82466: LIST
82467: LIST
82468: PUSH
82469: LD_INT 1
82471: PUSH
82472: LD_INT 2
82474: PUSH
82475: EMPTY
82476: LIST
82477: LIST
82478: PUSH
82479: LD_INT 0
82481: PUSH
82482: LD_INT 2
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PUSH
82489: LD_INT 1
82491: NEG
82492: PUSH
82493: LD_INT 1
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 2
82502: NEG
82503: PUSH
82504: LD_INT 1
82506: NEG
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 2
82514: NEG
82515: PUSH
82516: LD_INT 2
82518: NEG
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 2
82526: NEG
82527: PUSH
82528: LD_INT 3
82530: NEG
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 1
82538: NEG
82539: PUSH
82540: LD_INT 3
82542: NEG
82543: PUSH
82544: EMPTY
82545: LIST
82546: LIST
82547: PUSH
82548: LD_INT 0
82550: PUSH
82551: LD_INT 3
82553: NEG
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 1
82561: PUSH
82562: LD_INT 2
82564: NEG
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 3
82572: PUSH
82573: LD_INT 2
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 3
82582: PUSH
82583: LD_INT 3
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 2
82592: PUSH
82593: LD_INT 3
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 1
82602: PUSH
82603: LD_INT 3
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 0
82612: PUSH
82613: LD_INT 3
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 1
82622: NEG
82623: PUSH
82624: LD_INT 2
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 3
82633: NEG
82634: PUSH
82635: LD_INT 2
82637: NEG
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 3
82645: NEG
82646: PUSH
82647: LD_INT 3
82649: NEG
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: LIST
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82686: LD_ADDR_VAR 0 46
82690: PUSH
82691: LD_INT 0
82693: PUSH
82694: LD_INT 0
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 0
82703: PUSH
82704: LD_INT 1
82706: NEG
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 1
82714: PUSH
82715: LD_INT 0
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 1
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 0
82734: PUSH
82735: LD_INT 1
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 1
82744: NEG
82745: PUSH
82746: LD_INT 0
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: LD_INT 1
82755: NEG
82756: PUSH
82757: LD_INT 1
82759: NEG
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 1
82767: NEG
82768: PUSH
82769: LD_INT 2
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: LD_INT 2
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 1
82790: PUSH
82791: LD_INT 1
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 2
82801: PUSH
82802: LD_INT 0
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 2
82811: PUSH
82812: LD_INT 1
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 1
82821: PUSH
82822: LD_INT 2
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 0
82831: PUSH
82832: LD_INT 2
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 1
82841: NEG
82842: PUSH
82843: LD_INT 1
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 2
82852: NEG
82853: PUSH
82854: LD_INT 0
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 2
82863: NEG
82864: PUSH
82865: LD_INT 1
82867: NEG
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 1
82875: NEG
82876: PUSH
82877: LD_INT 3
82879: NEG
82880: PUSH
82881: EMPTY
82882: LIST
82883: LIST
82884: PUSH
82885: LD_INT 0
82887: PUSH
82888: LD_INT 3
82890: NEG
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PUSH
82896: LD_INT 1
82898: PUSH
82899: LD_INT 2
82901: NEG
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 2
82909: PUSH
82910: LD_INT 1
82912: NEG
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 3
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 3
82930: PUSH
82931: LD_INT 1
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 1
82940: PUSH
82941: LD_INT 3
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: LD_INT 3
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 1
82960: NEG
82961: PUSH
82962: LD_INT 2
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: LD_INT 2
82971: NEG
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 3
82982: NEG
82983: PUSH
82984: LD_INT 0
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 3
82993: NEG
82994: PUSH
82995: LD_INT 1
82997: NEG
82998: PUSH
82999: EMPTY
83000: LIST
83001: LIST
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: LIST
83028: LIST
83029: LIST
83030: LIST
83031: LIST
83032: LIST
83033: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83034: LD_ADDR_VAR 0 47
83038: PUSH
83039: LD_INT 0
83041: PUSH
83042: LD_INT 0
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 0
83051: PUSH
83052: LD_INT 1
83054: NEG
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 1
83062: PUSH
83063: LD_INT 0
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: LD_INT 1
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 0
83082: PUSH
83083: LD_INT 1
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 1
83092: NEG
83093: PUSH
83094: LD_INT 0
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: LD_INT 1
83107: NEG
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 1
83115: NEG
83116: PUSH
83117: LD_INT 2
83119: NEG
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 0
83127: PUSH
83128: LD_INT 2
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 1
83138: PUSH
83139: LD_INT 1
83141: NEG
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 2
83149: NEG
83150: PUSH
83151: LD_INT 1
83153: NEG
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: PUSH
83159: LD_INT 2
83161: NEG
83162: PUSH
83163: LD_INT 2
83165: NEG
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: EMPTY
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: LIST
83180: LIST
83181: LIST
83182: LIST
83183: LIST
83184: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83185: LD_ADDR_VAR 0 48
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: LD_INT 0
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: LD_INT 1
83205: NEG
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 1
83213: PUSH
83214: LD_INT 0
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 1
83223: PUSH
83224: LD_INT 1
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 0
83233: PUSH
83234: LD_INT 1
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 1
83243: NEG
83244: PUSH
83245: LD_INT 0
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 1
83254: NEG
83255: PUSH
83256: LD_INT 1
83258: NEG
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 1
83266: NEG
83267: PUSH
83268: LD_INT 2
83270: NEG
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 0
83278: PUSH
83279: LD_INT 2
83281: NEG
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 1
83289: PUSH
83290: LD_INT 1
83292: NEG
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 2
83300: PUSH
83301: LD_INT 0
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 2
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83332: LD_ADDR_VAR 0 49
83336: PUSH
83337: LD_INT 0
83339: PUSH
83340: LD_INT 0
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 0
83349: PUSH
83350: LD_INT 1
83352: NEG
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 1
83360: PUSH
83361: LD_INT 0
83363: PUSH
83364: EMPTY
83365: LIST
83366: LIST
83367: PUSH
83368: LD_INT 1
83370: PUSH
83371: LD_INT 1
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: PUSH
83378: LD_INT 0
83380: PUSH
83381: LD_INT 1
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 1
83390: NEG
83391: PUSH
83392: LD_INT 0
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 1
83401: NEG
83402: PUSH
83403: LD_INT 1
83405: NEG
83406: PUSH
83407: EMPTY
83408: LIST
83409: LIST
83410: PUSH
83411: LD_INT 1
83413: PUSH
83414: LD_INT 1
83416: NEG
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 2
83424: PUSH
83425: LD_INT 0
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 2
83434: PUSH
83435: LD_INT 1
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 2
83444: PUSH
83445: LD_INT 2
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 1
83454: PUSH
83455: LD_INT 2
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83476: LD_ADDR_VAR 0 50
83480: PUSH
83481: LD_INT 0
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 0
83493: PUSH
83494: LD_INT 1
83496: NEG
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 1
83504: PUSH
83505: LD_INT 0
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 1
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 0
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 1
83534: NEG
83535: PUSH
83536: LD_INT 0
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 1
83545: NEG
83546: PUSH
83547: LD_INT 1
83549: NEG
83550: PUSH
83551: EMPTY
83552: LIST
83553: LIST
83554: PUSH
83555: LD_INT 2
83557: PUSH
83558: LD_INT 1
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: PUSH
83565: LD_INT 2
83567: PUSH
83568: LD_INT 2
83570: PUSH
83571: EMPTY
83572: LIST
83573: LIST
83574: PUSH
83575: LD_INT 1
83577: PUSH
83578: LD_INT 2
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 0
83587: PUSH
83588: LD_INT 2
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PUSH
83595: LD_INT 1
83597: NEG
83598: PUSH
83599: LD_INT 1
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83620: LD_ADDR_VAR 0 51
83624: PUSH
83625: LD_INT 0
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: PUSH
83649: LD_INT 0
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 1
83658: PUSH
83659: LD_INT 1
83661: PUSH
83662: EMPTY
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 0
83668: PUSH
83669: LD_INT 1
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 1
83678: NEG
83679: PUSH
83680: LD_INT 0
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 1
83689: NEG
83690: PUSH
83691: LD_INT 1
83693: NEG
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 1
83701: PUSH
83702: LD_INT 2
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: LD_INT 0
83711: PUSH
83712: LD_INT 2
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 1
83721: NEG
83722: PUSH
83723: LD_INT 1
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 2
83732: NEG
83733: PUSH
83734: LD_INT 0
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 1
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: LIST
83757: LIST
83758: LIST
83759: LIST
83760: LIST
83761: LIST
83762: LIST
83763: LIST
83764: LIST
83765: LIST
83766: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83767: LD_ADDR_VAR 0 52
83771: PUSH
83772: LD_INT 0
83774: PUSH
83775: LD_INT 0
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 0
83784: PUSH
83785: LD_INT 1
83787: NEG
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: LD_INT 1
83795: PUSH
83796: LD_INT 0
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 1
83805: PUSH
83806: LD_INT 1
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 0
83815: PUSH
83816: LD_INT 1
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 1
83825: NEG
83826: PUSH
83827: LD_INT 0
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 1
83836: NEG
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 1
83848: NEG
83849: PUSH
83850: LD_INT 2
83852: NEG
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 1
83860: NEG
83861: PUSH
83862: LD_INT 1
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 2
83871: NEG
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 2
83882: NEG
83883: PUSH
83884: LD_INT 1
83886: NEG
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 2
83894: NEG
83895: PUSH
83896: LD_INT 2
83898: NEG
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: LIST
83908: LIST
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83918: LD_ADDR_VAR 0 53
83922: PUSH
83923: LD_INT 0
83925: PUSH
83926: LD_INT 0
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 0
83935: PUSH
83936: LD_INT 1
83938: NEG
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 1
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 1
83956: PUSH
83957: LD_INT 1
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: LD_INT 0
83966: PUSH
83967: LD_INT 1
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 1
83976: NEG
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 1
83987: NEG
83988: PUSH
83989: LD_INT 1
83991: NEG
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 1
83999: NEG
84000: PUSH
84001: LD_INT 2
84003: NEG
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: LD_INT 2
84014: NEG
84015: PUSH
84016: EMPTY
84017: LIST
84018: LIST
84019: PUSH
84020: LD_INT 1
84022: PUSH
84023: LD_INT 1
84025: NEG
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 2
84033: PUSH
84034: LD_INT 0
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 2
84043: PUSH
84044: LD_INT 1
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 2
84053: PUSH
84054: LD_INT 2
84056: PUSH
84057: EMPTY
84058: LIST
84059: LIST
84060: PUSH
84061: LD_INT 1
84063: PUSH
84064: LD_INT 2
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 0
84073: PUSH
84074: LD_INT 2
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 1
84083: NEG
84084: PUSH
84085: LD_INT 1
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 2
84094: NEG
84095: PUSH
84096: LD_INT 0
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 2
84105: NEG
84106: PUSH
84107: LD_INT 1
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 2
84117: NEG
84118: PUSH
84119: LD_INT 2
84121: NEG
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84148: LD_ADDR_VAR 0 54
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: LD_INT 0
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 0
84165: PUSH
84166: LD_INT 1
84168: NEG
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 1
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: EMPTY
84191: LIST
84192: LIST
84193: PUSH
84194: LD_INT 0
84196: PUSH
84197: LD_INT 1
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 1
84206: NEG
84207: PUSH
84208: LD_INT 0
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 1
84217: NEG
84218: PUSH
84219: LD_INT 1
84221: NEG
84222: PUSH
84223: EMPTY
84224: LIST
84225: LIST
84226: PUSH
84227: LD_INT 1
84229: NEG
84230: PUSH
84231: LD_INT 2
84233: NEG
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 2
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 1
84255: NEG
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 2
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 2
84273: PUSH
84274: LD_INT 1
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 2
84283: PUSH
84284: LD_INT 2
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 1
84293: PUSH
84294: LD_INT 2
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 0
84303: PUSH
84304: LD_INT 2
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: PUSH
84311: LD_INT 1
84313: NEG
84314: PUSH
84315: LD_INT 1
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 2
84324: NEG
84325: PUSH
84326: LD_INT 0
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 2
84335: NEG
84336: PUSH
84337: LD_INT 1
84339: NEG
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 2
84347: NEG
84348: PUSH
84349: LD_INT 2
84351: NEG
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84378: LD_ADDR_VAR 0 55
84382: PUSH
84383: LD_INT 0
84385: PUSH
84386: LD_INT 0
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 0
84395: PUSH
84396: LD_INT 1
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 1
84406: PUSH
84407: LD_INT 0
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 1
84416: PUSH
84417: LD_INT 1
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 0
84426: PUSH
84427: LD_INT 1
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: NEG
84437: PUSH
84438: LD_INT 0
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: LD_INT 1
84451: NEG
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 1
84459: NEG
84460: PUSH
84461: LD_INT 2
84463: NEG
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 0
84471: PUSH
84472: LD_INT 2
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: PUSH
84483: LD_INT 1
84485: NEG
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 2
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 2
84503: PUSH
84504: LD_INT 1
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: PUSH
84514: LD_INT 2
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 1
84523: PUSH
84524: LD_INT 2
84526: PUSH
84527: EMPTY
84528: LIST
84529: LIST
84530: PUSH
84531: LD_INT 0
84533: PUSH
84534: LD_INT 2
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: LD_INT 1
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: LD_INT 2
84554: NEG
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: PUSH
84563: LD_INT 2
84565: NEG
84566: PUSH
84567: LD_INT 1
84569: NEG
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 2
84577: NEG
84578: PUSH
84579: LD_INT 2
84581: NEG
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84608: LD_ADDR_VAR 0 56
84612: PUSH
84613: LD_INT 0
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 0
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 1
84636: PUSH
84637: LD_INT 0
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 1
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 0
84656: PUSH
84657: LD_INT 1
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 1
84666: NEG
84667: PUSH
84668: LD_INT 0
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 1
84677: NEG
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: NEG
84690: PUSH
84691: LD_INT 2
84693: NEG
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: LD_INT 2
84704: NEG
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: LD_INT 1
84715: NEG
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: PUSH
84724: LD_INT 0
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 2
84733: PUSH
84734: LD_INT 1
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 2
84743: PUSH
84744: LD_INT 2
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: LD_INT 2
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 0
84763: PUSH
84764: LD_INT 2
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 2
84784: NEG
84785: PUSH
84786: LD_INT 0
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 2
84795: NEG
84796: PUSH
84797: LD_INT 1
84799: NEG
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 2
84807: NEG
84808: PUSH
84809: LD_INT 2
84811: NEG
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84838: LD_ADDR_VAR 0 57
84842: PUSH
84843: LD_INT 0
84845: PUSH
84846: LD_INT 0
84848: PUSH
84849: EMPTY
84850: LIST
84851: LIST
84852: PUSH
84853: LD_INT 0
84855: PUSH
84856: LD_INT 1
84858: NEG
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: LD_INT 1
84866: PUSH
84867: LD_INT 0
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 1
84876: PUSH
84877: LD_INT 1
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 0
84886: PUSH
84887: LD_INT 1
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 1
84896: NEG
84897: PUSH
84898: LD_INT 0
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 1
84907: NEG
84908: PUSH
84909: LD_INT 1
84911: NEG
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 1
84919: NEG
84920: PUSH
84921: LD_INT 2
84923: NEG
84924: PUSH
84925: EMPTY
84926: LIST
84927: LIST
84928: PUSH
84929: LD_INT 0
84931: PUSH
84932: LD_INT 2
84934: NEG
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 1
84942: PUSH
84943: LD_INT 1
84945: NEG
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 2
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PUSH
84961: LD_INT 2
84963: PUSH
84964: LD_INT 1
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 2
84973: PUSH
84974: LD_INT 2
84976: PUSH
84977: EMPTY
84978: LIST
84979: LIST
84980: PUSH
84981: LD_INT 1
84983: PUSH
84984: LD_INT 2
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: PUSH
84991: LD_INT 0
84993: PUSH
84994: LD_INT 2
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 1
85003: NEG
85004: PUSH
85005: LD_INT 1
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 2
85014: NEG
85015: PUSH
85016: LD_INT 0
85018: PUSH
85019: EMPTY
85020: LIST
85021: LIST
85022: PUSH
85023: LD_INT 2
85025: NEG
85026: PUSH
85027: LD_INT 1
85029: NEG
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 2
85037: NEG
85038: PUSH
85039: LD_INT 2
85041: NEG
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: LIST
85051: LIST
85052: LIST
85053: LIST
85054: LIST
85055: LIST
85056: LIST
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85068: LD_ADDR_VAR 0 58
85072: PUSH
85073: LD_INT 0
85075: PUSH
85076: LD_INT 0
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 0
85085: PUSH
85086: LD_INT 1
85088: NEG
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: PUSH
85097: LD_INT 0
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 1
85106: PUSH
85107: LD_INT 1
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 0
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 1
85126: NEG
85127: PUSH
85128: LD_INT 0
85130: PUSH
85131: EMPTY
85132: LIST
85133: LIST
85134: PUSH
85135: LD_INT 1
85137: NEG
85138: PUSH
85139: LD_INT 1
85141: NEG
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: LD_INT 2
85153: NEG
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 0
85161: PUSH
85162: LD_INT 2
85164: NEG
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: LD_INT 1
85175: NEG
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 2
85183: PUSH
85184: LD_INT 0
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: LD_INT 2
85193: PUSH
85194: LD_INT 1
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 2
85203: PUSH
85204: LD_INT 2
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PUSH
85211: LD_INT 1
85213: PUSH
85214: LD_INT 2
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: LD_INT 2
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: LD_INT 1
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 2
85244: NEG
85245: PUSH
85246: LD_INT 0
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 2
85255: NEG
85256: PUSH
85257: LD_INT 1
85259: NEG
85260: PUSH
85261: EMPTY
85262: LIST
85263: LIST
85264: PUSH
85265: LD_INT 2
85267: NEG
85268: PUSH
85269: LD_INT 2
85271: NEG
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85298: LD_ADDR_VAR 0 59
85302: PUSH
85303: LD_INT 0
85305: PUSH
85306: LD_INT 0
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 0
85315: PUSH
85316: LD_INT 1
85318: NEG
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: PUSH
85324: LD_INT 1
85326: PUSH
85327: LD_INT 0
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 1
85336: PUSH
85337: LD_INT 1
85339: PUSH
85340: EMPTY
85341: LIST
85342: LIST
85343: PUSH
85344: LD_INT 0
85346: PUSH
85347: LD_INT 1
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: NEG
85357: PUSH
85358: LD_INT 0
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: LD_INT 1
85367: NEG
85368: PUSH
85369: LD_INT 1
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85386: LD_ADDR_VAR 0 60
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 0
85403: PUSH
85404: LD_INT 1
85406: NEG
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 1
85424: PUSH
85425: LD_INT 1
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 0
85434: PUSH
85435: LD_INT 1
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 1
85444: NEG
85445: PUSH
85446: LD_INT 0
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 1
85455: NEG
85456: PUSH
85457: LD_INT 1
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85474: LD_ADDR_VAR 0 61
85478: PUSH
85479: LD_INT 0
85481: PUSH
85482: LD_INT 0
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: PUSH
85489: LD_INT 0
85491: PUSH
85492: LD_INT 1
85494: NEG
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 1
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 1
85512: PUSH
85513: LD_INT 1
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 0
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 1
85532: NEG
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 1
85543: NEG
85544: PUSH
85545: LD_INT 1
85547: NEG
85548: PUSH
85549: EMPTY
85550: LIST
85551: LIST
85552: PUSH
85553: EMPTY
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85562: LD_ADDR_VAR 0 62
85566: PUSH
85567: LD_INT 0
85569: PUSH
85570: LD_INT 0
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 0
85579: PUSH
85580: LD_INT 1
85582: NEG
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PUSH
85588: LD_INT 1
85590: PUSH
85591: LD_INT 0
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 1
85600: PUSH
85601: LD_INT 1
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: LD_INT 1
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 1
85620: NEG
85621: PUSH
85622: LD_INT 0
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: NEG
85632: PUSH
85633: LD_INT 1
85635: NEG
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: PUSH
85641: EMPTY
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85650: LD_ADDR_VAR 0 63
85654: PUSH
85655: LD_INT 0
85657: PUSH
85658: LD_INT 0
85660: PUSH
85661: EMPTY
85662: LIST
85663: LIST
85664: PUSH
85665: LD_INT 0
85667: PUSH
85668: LD_INT 1
85670: NEG
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: LD_INT 1
85678: PUSH
85679: LD_INT 0
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: PUSH
85686: LD_INT 1
85688: PUSH
85689: LD_INT 1
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: PUSH
85696: LD_INT 0
85698: PUSH
85699: LD_INT 1
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 1
85708: NEG
85709: PUSH
85710: LD_INT 0
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 1
85719: NEG
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: LIST
85737: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85738: LD_ADDR_VAR 0 64
85742: PUSH
85743: LD_INT 0
85745: PUSH
85746: LD_INT 0
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 0
85755: PUSH
85756: LD_INT 1
85758: NEG
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 1
85766: PUSH
85767: LD_INT 0
85769: PUSH
85770: EMPTY
85771: LIST
85772: LIST
85773: PUSH
85774: LD_INT 1
85776: PUSH
85777: LD_INT 1
85779: PUSH
85780: EMPTY
85781: LIST
85782: LIST
85783: PUSH
85784: LD_INT 0
85786: PUSH
85787: LD_INT 1
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: PUSH
85794: LD_INT 1
85796: NEG
85797: PUSH
85798: LD_INT 0
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 1
85807: NEG
85808: PUSH
85809: LD_INT 1
85811: NEG
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: ST_TO_ADDR
// end ; 1 :
85826: GO 91723
85828: LD_INT 1
85830: DOUBLE
85831: EQUAL
85832: IFTRUE 85836
85834: GO 88459
85836: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85837: LD_ADDR_VAR 0 11
85841: PUSH
85842: LD_INT 1
85844: NEG
85845: PUSH
85846: LD_INT 3
85848: NEG
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 0
85856: PUSH
85857: LD_INT 3
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 1
85867: PUSH
85868: LD_INT 2
85870: NEG
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: LIST
85880: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85881: LD_ADDR_VAR 0 12
85885: PUSH
85886: LD_INT 2
85888: PUSH
85889: LD_INT 1
85891: NEG
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: LD_INT 3
85899: PUSH
85900: LD_INT 0
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 3
85909: PUSH
85910: LD_INT 1
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: LIST
85921: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85922: LD_ADDR_VAR 0 13
85926: PUSH
85927: LD_INT 3
85929: PUSH
85930: LD_INT 2
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 3
85939: PUSH
85940: LD_INT 3
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_INT 2
85949: PUSH
85950: LD_INT 3
85952: PUSH
85953: EMPTY
85954: LIST
85955: LIST
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: LIST
85961: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85962: LD_ADDR_VAR 0 14
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: LD_INT 3
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 0
85979: PUSH
85980: LD_INT 3
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: NEG
85990: PUSH
85991: LD_INT 2
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: LIST
86002: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86003: LD_ADDR_VAR 0 15
86007: PUSH
86008: LD_INT 2
86010: NEG
86011: PUSH
86012: LD_INT 1
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 3
86021: NEG
86022: PUSH
86023: LD_INT 0
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 3
86032: NEG
86033: PUSH
86034: LD_INT 1
86036: NEG
86037: PUSH
86038: EMPTY
86039: LIST
86040: LIST
86041: PUSH
86042: EMPTY
86043: LIST
86044: LIST
86045: LIST
86046: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86047: LD_ADDR_VAR 0 16
86051: PUSH
86052: LD_INT 2
86054: NEG
86055: PUSH
86056: LD_INT 3
86058: NEG
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 3
86066: NEG
86067: PUSH
86068: LD_INT 2
86070: NEG
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 3
86078: NEG
86079: PUSH
86080: LD_INT 3
86082: NEG
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: LIST
86092: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86093: LD_ADDR_VAR 0 17
86097: PUSH
86098: LD_INT 1
86100: NEG
86101: PUSH
86102: LD_INT 3
86104: NEG
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 0
86112: PUSH
86113: LD_INT 3
86115: NEG
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: PUSH
86124: LD_INT 2
86126: NEG
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: LIST
86136: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86137: LD_ADDR_VAR 0 18
86141: PUSH
86142: LD_INT 2
86144: PUSH
86145: LD_INT 1
86147: NEG
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 3
86155: PUSH
86156: LD_INT 0
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 3
86165: PUSH
86166: LD_INT 1
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: LIST
86177: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86178: LD_ADDR_VAR 0 19
86182: PUSH
86183: LD_INT 3
86185: PUSH
86186: LD_INT 2
86188: PUSH
86189: EMPTY
86190: LIST
86191: LIST
86192: PUSH
86193: LD_INT 3
86195: PUSH
86196: LD_INT 3
86198: PUSH
86199: EMPTY
86200: LIST
86201: LIST
86202: PUSH
86203: LD_INT 2
86205: PUSH
86206: LD_INT 3
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: LIST
86217: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86218: LD_ADDR_VAR 0 20
86222: PUSH
86223: LD_INT 1
86225: PUSH
86226: LD_INT 3
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 0
86235: PUSH
86236: LD_INT 3
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 1
86245: NEG
86246: PUSH
86247: LD_INT 2
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: LIST
86258: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86259: LD_ADDR_VAR 0 21
86263: PUSH
86264: LD_INT 2
86266: NEG
86267: PUSH
86268: LD_INT 1
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 3
86277: NEG
86278: PUSH
86279: LD_INT 0
86281: PUSH
86282: EMPTY
86283: LIST
86284: LIST
86285: PUSH
86286: LD_INT 3
86288: NEG
86289: PUSH
86290: LD_INT 1
86292: NEG
86293: PUSH
86294: EMPTY
86295: LIST
86296: LIST
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: LIST
86302: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86303: LD_ADDR_VAR 0 22
86307: PUSH
86308: LD_INT 2
86310: NEG
86311: PUSH
86312: LD_INT 3
86314: NEG
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 3
86322: NEG
86323: PUSH
86324: LD_INT 2
86326: NEG
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 3
86334: NEG
86335: PUSH
86336: LD_INT 3
86338: NEG
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: LIST
86348: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
86349: LD_ADDR_VAR 0 23
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: LD_INT 3
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: LD_INT 4
86371: NEG
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 1
86379: PUSH
86380: LD_INT 3
86382: NEG
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: LIST
86392: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
86393: LD_ADDR_VAR 0 24
86397: PUSH
86398: LD_INT 3
86400: PUSH
86401: LD_INT 0
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 3
86410: PUSH
86411: LD_INT 1
86413: NEG
86414: PUSH
86415: EMPTY
86416: LIST
86417: LIST
86418: PUSH
86419: LD_INT 4
86421: PUSH
86422: LD_INT 1
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: LIST
86433: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
86434: LD_ADDR_VAR 0 25
86438: PUSH
86439: LD_INT 3
86441: PUSH
86442: LD_INT 3
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 4
86451: PUSH
86452: LD_INT 3
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 3
86461: PUSH
86462: LD_INT 4
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: LIST
86473: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
86474: LD_ADDR_VAR 0 26
86478: PUSH
86479: LD_INT 0
86481: PUSH
86482: LD_INT 3
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 1
86491: PUSH
86492: LD_INT 4
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 1
86501: NEG
86502: PUSH
86503: LD_INT 3
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: LIST
86514: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
86515: LD_ADDR_VAR 0 27
86519: PUSH
86520: LD_INT 3
86522: NEG
86523: PUSH
86524: LD_INT 0
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 3
86533: NEG
86534: PUSH
86535: LD_INT 1
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 4
86544: NEG
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: LIST
86558: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
86559: LD_ADDR_VAR 0 28
86563: PUSH
86564: LD_INT 3
86566: NEG
86567: PUSH
86568: LD_INT 3
86570: NEG
86571: PUSH
86572: EMPTY
86573: LIST
86574: LIST
86575: PUSH
86576: LD_INT 3
86578: NEG
86579: PUSH
86580: LD_INT 4
86582: NEG
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 4
86590: NEG
86591: PUSH
86592: LD_INT 3
86594: NEG
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: LIST
86604: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
86605: LD_ADDR_VAR 0 29
86609: PUSH
86610: LD_INT 1
86612: NEG
86613: PUSH
86614: LD_INT 3
86616: NEG
86617: PUSH
86618: EMPTY
86619: LIST
86620: LIST
86621: PUSH
86622: LD_INT 0
86624: PUSH
86625: LD_INT 3
86627: NEG
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: PUSH
86633: LD_INT 1
86635: PUSH
86636: LD_INT 2
86638: NEG
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 1
86646: NEG
86647: PUSH
86648: LD_INT 4
86650: NEG
86651: PUSH
86652: EMPTY
86653: LIST
86654: LIST
86655: PUSH
86656: LD_INT 0
86658: PUSH
86659: LD_INT 4
86661: NEG
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 1
86669: PUSH
86670: LD_INT 3
86672: NEG
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PUSH
86678: LD_INT 1
86680: NEG
86681: PUSH
86682: LD_INT 5
86684: NEG
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 0
86692: PUSH
86693: LD_INT 5
86695: NEG
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: LD_INT 4
86706: NEG
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 1
86714: NEG
86715: PUSH
86716: LD_INT 6
86718: NEG
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 0
86726: PUSH
86727: LD_INT 6
86729: NEG
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 1
86737: PUSH
86738: LD_INT 5
86740: NEG
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: LIST
86750: LIST
86751: LIST
86752: LIST
86753: LIST
86754: LIST
86755: LIST
86756: LIST
86757: LIST
86758: LIST
86759: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
86760: LD_ADDR_VAR 0 30
86764: PUSH
86765: LD_INT 2
86767: PUSH
86768: LD_INT 1
86770: NEG
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 3
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 3
86788: PUSH
86789: LD_INT 1
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 3
86798: PUSH
86799: LD_INT 1
86801: NEG
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 4
86809: PUSH
86810: LD_INT 0
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 4
86819: PUSH
86820: LD_INT 1
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 4
86829: PUSH
86830: LD_INT 1
86832: NEG
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 5
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 5
86850: PUSH
86851: LD_INT 1
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 5
86860: PUSH
86861: LD_INT 1
86863: NEG
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 6
86871: PUSH
86872: LD_INT 0
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 6
86881: PUSH
86882: LD_INT 1
86884: PUSH
86885: EMPTY
86886: LIST
86887: LIST
86888: PUSH
86889: EMPTY
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: LIST
86895: LIST
86896: LIST
86897: LIST
86898: LIST
86899: LIST
86900: LIST
86901: LIST
86902: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
86903: LD_ADDR_VAR 0 31
86907: PUSH
86908: LD_INT 3
86910: PUSH
86911: LD_INT 2
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 3
86920: PUSH
86921: LD_INT 3
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: PUSH
86928: LD_INT 2
86930: PUSH
86931: LD_INT 3
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 4
86940: PUSH
86941: LD_INT 3
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 4
86950: PUSH
86951: LD_INT 4
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: PUSH
86958: LD_INT 3
86960: PUSH
86961: LD_INT 4
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 5
86970: PUSH
86971: LD_INT 4
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: LD_INT 5
86980: PUSH
86981: LD_INT 5
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 4
86990: PUSH
86991: LD_INT 5
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 6
87000: PUSH
87001: LD_INT 5
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: PUSH
87008: LD_INT 6
87010: PUSH
87011: LD_INT 6
87013: PUSH
87014: EMPTY
87015: LIST
87016: LIST
87017: PUSH
87018: LD_INT 5
87020: PUSH
87021: LD_INT 6
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
87042: LD_ADDR_VAR 0 32
87046: PUSH
87047: LD_INT 1
87049: PUSH
87050: LD_INT 3
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 0
87059: PUSH
87060: LD_INT 3
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 1
87069: NEG
87070: PUSH
87071: LD_INT 2
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: PUSH
87081: LD_INT 4
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 0
87090: PUSH
87091: LD_INT 4
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 1
87100: NEG
87101: PUSH
87102: LD_INT 3
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 1
87111: PUSH
87112: LD_INT 5
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 0
87121: PUSH
87122: LD_INT 5
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: PUSH
87129: LD_INT 1
87131: NEG
87132: PUSH
87133: LD_INT 4
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: PUSH
87143: LD_INT 6
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 0
87152: PUSH
87153: LD_INT 6
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 1
87162: NEG
87163: PUSH
87164: LD_INT 5
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
87185: LD_ADDR_VAR 0 33
87189: PUSH
87190: LD_INT 2
87192: NEG
87193: PUSH
87194: LD_INT 1
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 3
87203: NEG
87204: PUSH
87205: LD_INT 0
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 3
87214: NEG
87215: PUSH
87216: LD_INT 1
87218: NEG
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 3
87226: NEG
87227: PUSH
87228: LD_INT 1
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 4
87237: NEG
87238: PUSH
87239: LD_INT 0
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 4
87248: NEG
87249: PUSH
87250: LD_INT 1
87252: NEG
87253: PUSH
87254: EMPTY
87255: LIST
87256: LIST
87257: PUSH
87258: LD_INT 4
87260: NEG
87261: PUSH
87262: LD_INT 1
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 5
87271: NEG
87272: PUSH
87273: LD_INT 0
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 5
87282: NEG
87283: PUSH
87284: LD_INT 1
87286: NEG
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 5
87294: NEG
87295: PUSH
87296: LD_INT 1
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PUSH
87303: LD_INT 6
87305: NEG
87306: PUSH
87307: LD_INT 0
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 6
87316: NEG
87317: PUSH
87318: LD_INT 1
87320: NEG
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
87340: LD_ADDR_VAR 0 34
87344: PUSH
87345: LD_INT 2
87347: NEG
87348: PUSH
87349: LD_INT 3
87351: NEG
87352: PUSH
87353: EMPTY
87354: LIST
87355: LIST
87356: PUSH
87357: LD_INT 3
87359: NEG
87360: PUSH
87361: LD_INT 2
87363: NEG
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 3
87371: NEG
87372: PUSH
87373: LD_INT 3
87375: NEG
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 3
87383: NEG
87384: PUSH
87385: LD_INT 4
87387: NEG
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 4
87395: NEG
87396: PUSH
87397: LD_INT 3
87399: NEG
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 4
87407: NEG
87408: PUSH
87409: LD_INT 4
87411: NEG
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 4
87419: NEG
87420: PUSH
87421: LD_INT 5
87423: NEG
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 5
87431: NEG
87432: PUSH
87433: LD_INT 4
87435: NEG
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 5
87443: NEG
87444: PUSH
87445: LD_INT 5
87447: NEG
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 5
87455: NEG
87456: PUSH
87457: LD_INT 6
87459: NEG
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: PUSH
87465: LD_INT 6
87467: NEG
87468: PUSH
87469: LD_INT 5
87471: NEG
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: PUSH
87477: LD_INT 6
87479: NEG
87480: PUSH
87481: LD_INT 6
87483: NEG
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
87503: LD_ADDR_VAR 0 41
87507: PUSH
87508: LD_INT 0
87510: PUSH
87511: LD_INT 2
87513: NEG
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: LD_INT 1
87521: NEG
87522: PUSH
87523: LD_INT 3
87525: NEG
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 1
87533: PUSH
87534: LD_INT 2
87536: NEG
87537: PUSH
87538: EMPTY
87539: LIST
87540: LIST
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: LIST
87546: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
87547: LD_ADDR_VAR 0 42
87551: PUSH
87552: LD_INT 2
87554: PUSH
87555: LD_INT 0
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 3
87575: PUSH
87576: LD_INT 1
87578: PUSH
87579: EMPTY
87580: LIST
87581: LIST
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: LIST
87587: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
87588: LD_ADDR_VAR 0 43
87592: PUSH
87593: LD_INT 2
87595: PUSH
87596: LD_INT 2
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: PUSH
87603: LD_INT 3
87605: PUSH
87606: LD_INT 2
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 2
87615: PUSH
87616: LD_INT 3
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: LIST
87627: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
87628: LD_ADDR_VAR 0 44
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: LD_INT 2
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: LD_INT 3
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: LD_INT 1
87655: NEG
87656: PUSH
87657: LD_INT 2
87659: PUSH
87660: EMPTY
87661: LIST
87662: LIST
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: LIST
87668: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87669: LD_ADDR_VAR 0 45
87673: PUSH
87674: LD_INT 2
87676: NEG
87677: PUSH
87678: LD_INT 0
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: LD_INT 2
87687: NEG
87688: PUSH
87689: LD_INT 1
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: LD_INT 3
87698: NEG
87699: PUSH
87700: LD_INT 1
87702: NEG
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: LIST
87712: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
87713: LD_ADDR_VAR 0 46
87717: PUSH
87718: LD_INT 2
87720: NEG
87721: PUSH
87722: LD_INT 2
87724: NEG
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 2
87732: NEG
87733: PUSH
87734: LD_INT 3
87736: NEG
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 3
87744: NEG
87745: PUSH
87746: LD_INT 2
87748: NEG
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: EMPTY
87755: LIST
87756: LIST
87757: LIST
87758: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
87759: LD_ADDR_VAR 0 47
87763: PUSH
87764: LD_INT 2
87766: NEG
87767: PUSH
87768: LD_INT 3
87770: NEG
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 1
87778: NEG
87779: PUSH
87780: LD_INT 3
87782: NEG
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: EMPTY
87789: LIST
87790: LIST
87791: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
87792: LD_ADDR_VAR 0 48
87796: PUSH
87797: LD_INT 1
87799: PUSH
87800: LD_INT 2
87802: NEG
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 2
87810: PUSH
87811: LD_INT 1
87813: NEG
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
87823: LD_ADDR_VAR 0 49
87827: PUSH
87828: LD_INT 3
87830: PUSH
87831: LD_INT 1
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PUSH
87838: LD_INT 3
87840: PUSH
87841: LD_INT 2
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
87852: LD_ADDR_VAR 0 50
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: LD_INT 3
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 1
87869: PUSH
87870: LD_INT 3
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
87881: LD_ADDR_VAR 0 51
87885: PUSH
87886: LD_INT 1
87888: NEG
87889: PUSH
87890: LD_INT 2
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 2
87899: NEG
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87912: LD_ADDR_VAR 0 52
87916: PUSH
87917: LD_INT 3
87919: NEG
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 3
87931: NEG
87932: PUSH
87933: LD_INT 2
87935: NEG
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
87945: LD_ADDR_VAR 0 53
87949: PUSH
87950: LD_INT 1
87952: NEG
87953: PUSH
87954: LD_INT 3
87956: NEG
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: LD_INT 3
87967: NEG
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: LD_INT 1
87975: PUSH
87976: LD_INT 2
87978: NEG
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: LIST
87988: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
87989: LD_ADDR_VAR 0 54
87993: PUSH
87994: LD_INT 2
87996: PUSH
87997: LD_INT 1
87999: NEG
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 3
88007: PUSH
88008: LD_INT 0
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 3
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: LIST
88029: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88030: LD_ADDR_VAR 0 55
88034: PUSH
88035: LD_INT 3
88037: PUSH
88038: LD_INT 2
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: LD_INT 3
88047: PUSH
88048: LD_INT 3
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: PUSH
88055: LD_INT 2
88057: PUSH
88058: LD_INT 3
88060: PUSH
88061: EMPTY
88062: LIST
88063: LIST
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: LIST
88069: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88070: LD_ADDR_VAR 0 56
88074: PUSH
88075: LD_INT 1
88077: PUSH
88078: LD_INT 3
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 0
88087: PUSH
88088: LD_INT 3
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 1
88097: NEG
88098: PUSH
88099: LD_INT 2
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: LIST
88110: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88111: LD_ADDR_VAR 0 57
88115: PUSH
88116: LD_INT 2
88118: NEG
88119: PUSH
88120: LD_INT 1
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 3
88129: NEG
88130: PUSH
88131: LD_INT 0
88133: PUSH
88134: EMPTY
88135: LIST
88136: LIST
88137: PUSH
88138: LD_INT 3
88140: NEG
88141: PUSH
88142: LD_INT 1
88144: NEG
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: EMPTY
88151: LIST
88152: LIST
88153: LIST
88154: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88155: LD_ADDR_VAR 0 58
88159: PUSH
88160: LD_INT 2
88162: NEG
88163: PUSH
88164: LD_INT 3
88166: NEG
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: PUSH
88172: LD_INT 3
88174: NEG
88175: PUSH
88176: LD_INT 2
88178: NEG
88179: PUSH
88180: EMPTY
88181: LIST
88182: LIST
88183: PUSH
88184: LD_INT 3
88186: NEG
88187: PUSH
88188: LD_INT 3
88190: NEG
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: LIST
88200: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
88201: LD_ADDR_VAR 0 59
88205: PUSH
88206: LD_INT 1
88208: NEG
88209: PUSH
88210: LD_INT 2
88212: NEG
88213: PUSH
88214: EMPTY
88215: LIST
88216: LIST
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: PUSH
88232: LD_INT 1
88234: NEG
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: LIST
88244: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88245: LD_ADDR_VAR 0 60
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: LD_INT 1
88255: NEG
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PUSH
88261: LD_INT 2
88263: PUSH
88264: LD_INT 0
88266: PUSH
88267: EMPTY
88268: LIST
88269: LIST
88270: PUSH
88271: LD_INT 2
88273: PUSH
88274: LD_INT 1
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: LIST
88285: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88286: LD_ADDR_VAR 0 61
88290: PUSH
88291: LD_INT 2
88293: PUSH
88294: LD_INT 1
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 2
88303: PUSH
88304: LD_INT 2
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 1
88313: PUSH
88314: LD_INT 2
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: LIST
88325: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88326: LD_ADDR_VAR 0 62
88330: PUSH
88331: LD_INT 1
88333: PUSH
88334: LD_INT 2
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: LD_INT 2
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: NEG
88354: PUSH
88355: LD_INT 1
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: LIST
88366: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88367: LD_ADDR_VAR 0 63
88371: PUSH
88372: LD_INT 1
88374: NEG
88375: PUSH
88376: LD_INT 1
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 2
88385: NEG
88386: PUSH
88387: LD_INT 0
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 2
88396: NEG
88397: PUSH
88398: LD_INT 1
88400: NEG
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: LIST
88410: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88411: LD_ADDR_VAR 0 64
88415: PUSH
88416: LD_INT 1
88418: NEG
88419: PUSH
88420: LD_INT 2
88422: NEG
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: LD_INT 2
88430: NEG
88431: PUSH
88432: LD_INT 1
88434: NEG
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: PUSH
88440: LD_INT 2
88442: NEG
88443: PUSH
88444: LD_INT 2
88446: NEG
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: EMPTY
88453: LIST
88454: LIST
88455: LIST
88456: ST_TO_ADDR
// end ; 2 :
88457: GO 91723
88459: LD_INT 2
88461: DOUBLE
88462: EQUAL
88463: IFTRUE 88467
88465: GO 91722
88467: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
88468: LD_ADDR_VAR 0 29
88472: PUSH
88473: LD_INT 4
88475: PUSH
88476: LD_INT 0
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 4
88485: PUSH
88486: LD_INT 1
88488: NEG
88489: PUSH
88490: EMPTY
88491: LIST
88492: LIST
88493: PUSH
88494: LD_INT 5
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 5
88506: PUSH
88507: LD_INT 1
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 4
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 3
88526: PUSH
88527: LD_INT 0
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: LD_INT 3
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 3
88547: PUSH
88548: LD_INT 2
88550: NEG
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 5
88558: PUSH
88559: LD_INT 2
88561: PUSH
88562: EMPTY
88563: LIST
88564: LIST
88565: PUSH
88566: LD_INT 3
88568: PUSH
88569: LD_INT 3
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 3
88578: PUSH
88579: LD_INT 2
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 4
88588: PUSH
88589: LD_INT 3
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 4
88598: PUSH
88599: LD_INT 4
88601: PUSH
88602: EMPTY
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 3
88608: PUSH
88609: LD_INT 4
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: LD_INT 2
88618: PUSH
88619: LD_INT 3
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 2
88628: PUSH
88629: LD_INT 2
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: PUSH
88636: LD_INT 4
88638: PUSH
88639: LD_INT 2
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: PUSH
88646: LD_INT 2
88648: PUSH
88649: LD_INT 4
88651: PUSH
88652: EMPTY
88653: LIST
88654: LIST
88655: PUSH
88656: LD_INT 0
88658: PUSH
88659: LD_INT 4
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: LD_INT 3
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: LD_INT 4
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: PUSH
88686: LD_INT 1
88688: PUSH
88689: LD_INT 5
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: LD_INT 5
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: PUSH
88706: LD_INT 1
88708: NEG
88709: PUSH
88710: LD_INT 4
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 1
88719: NEG
88720: PUSH
88721: LD_INT 3
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 2
88730: PUSH
88731: LD_INT 5
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 2
88740: NEG
88741: PUSH
88742: LD_INT 3
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 3
88751: NEG
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 3
88762: NEG
88763: PUSH
88764: LD_INT 1
88766: NEG
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 2
88774: NEG
88775: PUSH
88776: LD_INT 0
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: NEG
88786: PUSH
88787: LD_INT 1
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 3
88796: NEG
88797: PUSH
88798: LD_INT 1
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 4
88807: NEG
88808: PUSH
88809: LD_INT 0
88811: PUSH
88812: EMPTY
88813: LIST
88814: LIST
88815: PUSH
88816: LD_INT 4
88818: NEG
88819: PUSH
88820: LD_INT 1
88822: NEG
88823: PUSH
88824: EMPTY
88825: LIST
88826: LIST
88827: PUSH
88828: LD_INT 4
88830: NEG
88831: PUSH
88832: LD_INT 2
88834: NEG
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 2
88842: NEG
88843: PUSH
88844: LD_INT 2
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: PUSH
88851: LD_INT 4
88853: NEG
88854: PUSH
88855: LD_INT 4
88857: NEG
88858: PUSH
88859: EMPTY
88860: LIST
88861: LIST
88862: PUSH
88863: LD_INT 4
88865: NEG
88866: PUSH
88867: LD_INT 5
88869: NEG
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 3
88877: NEG
88878: PUSH
88879: LD_INT 4
88881: NEG
88882: PUSH
88883: EMPTY
88884: LIST
88885: LIST
88886: PUSH
88887: LD_INT 3
88889: NEG
88890: PUSH
88891: LD_INT 3
88893: NEG
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PUSH
88899: LD_INT 4
88901: NEG
88902: PUSH
88903: LD_INT 3
88905: NEG
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 5
88913: NEG
88914: PUSH
88915: LD_INT 4
88917: NEG
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: PUSH
88923: LD_INT 5
88925: NEG
88926: PUSH
88927: LD_INT 5
88929: NEG
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 3
88937: NEG
88938: PUSH
88939: LD_INT 5
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 5
88949: NEG
88950: PUSH
88951: LD_INT 3
88953: NEG
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: LIST
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
89006: LD_ADDR_VAR 0 30
89010: PUSH
89011: LD_INT 4
89013: PUSH
89014: LD_INT 4
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: PUSH
89021: LD_INT 4
89023: PUSH
89024: LD_INT 3
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 5
89033: PUSH
89034: LD_INT 4
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 5
89043: PUSH
89044: LD_INT 5
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PUSH
89051: LD_INT 4
89053: PUSH
89054: LD_INT 5
89056: PUSH
89057: EMPTY
89058: LIST
89059: LIST
89060: PUSH
89061: LD_INT 3
89063: PUSH
89064: LD_INT 4
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 3
89073: PUSH
89074: LD_INT 3
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: PUSH
89081: LD_INT 5
89083: PUSH
89084: LD_INT 3
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 3
89093: PUSH
89094: LD_INT 5
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 0
89103: PUSH
89104: LD_INT 3
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 0
89113: PUSH
89114: LD_INT 2
89116: PUSH
89117: EMPTY
89118: LIST
89119: LIST
89120: PUSH
89121: LD_INT 1
89123: PUSH
89124: LD_INT 3
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 1
89133: PUSH
89134: LD_INT 4
89136: PUSH
89137: EMPTY
89138: LIST
89139: LIST
89140: PUSH
89141: LD_INT 0
89143: PUSH
89144: LD_INT 4
89146: PUSH
89147: EMPTY
89148: LIST
89149: LIST
89150: PUSH
89151: LD_INT 1
89153: NEG
89154: PUSH
89155: LD_INT 3
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 1
89164: NEG
89165: PUSH
89166: LD_INT 2
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: LD_INT 2
89175: PUSH
89176: LD_INT 4
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 2
89185: NEG
89186: PUSH
89187: LD_INT 2
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 4
89196: NEG
89197: PUSH
89198: LD_INT 0
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: PUSH
89205: LD_INT 4
89207: NEG
89208: PUSH
89209: LD_INT 1
89211: NEG
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: PUSH
89217: LD_INT 3
89219: NEG
89220: PUSH
89221: LD_INT 0
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 3
89230: NEG
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 4
89241: NEG
89242: PUSH
89243: LD_INT 1
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 5
89252: NEG
89253: PUSH
89254: LD_INT 0
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: PUSH
89261: LD_INT 5
89263: NEG
89264: PUSH
89265: LD_INT 1
89267: NEG
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: LD_INT 5
89275: NEG
89276: PUSH
89277: LD_INT 2
89279: NEG
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 3
89287: NEG
89288: PUSH
89289: LD_INT 2
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 3
89298: NEG
89299: PUSH
89300: LD_INT 3
89302: NEG
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: LD_INT 3
89310: NEG
89311: PUSH
89312: LD_INT 4
89314: NEG
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 2
89322: NEG
89323: PUSH
89324: LD_INT 3
89326: NEG
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 2
89334: NEG
89335: PUSH
89336: LD_INT 2
89338: NEG
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: PUSH
89344: LD_INT 3
89346: NEG
89347: PUSH
89348: LD_INT 2
89350: NEG
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: LD_INT 4
89358: NEG
89359: PUSH
89360: LD_INT 3
89362: NEG
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: PUSH
89368: LD_INT 4
89370: NEG
89371: PUSH
89372: LD_INT 4
89374: NEG
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 2
89382: NEG
89383: PUSH
89384: LD_INT 4
89386: NEG
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: LD_INT 4
89394: NEG
89395: PUSH
89396: LD_INT 2
89398: NEG
89399: PUSH
89400: EMPTY
89401: LIST
89402: LIST
89403: PUSH
89404: LD_INT 0
89406: PUSH
89407: LD_INT 4
89409: NEG
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 0
89417: PUSH
89418: LD_INT 5
89420: NEG
89421: PUSH
89422: EMPTY
89423: LIST
89424: LIST
89425: PUSH
89426: LD_INT 1
89428: PUSH
89429: LD_INT 4
89431: NEG
89432: PUSH
89433: EMPTY
89434: LIST
89435: LIST
89436: PUSH
89437: LD_INT 1
89439: PUSH
89440: LD_INT 3
89442: NEG
89443: PUSH
89444: EMPTY
89445: LIST
89446: LIST
89447: PUSH
89448: LD_INT 0
89450: PUSH
89451: LD_INT 3
89453: NEG
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 1
89461: NEG
89462: PUSH
89463: LD_INT 4
89465: NEG
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 1
89473: NEG
89474: PUSH
89475: LD_INT 5
89477: NEG
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: PUSH
89483: LD_INT 2
89485: PUSH
89486: LD_INT 3
89488: NEG
89489: PUSH
89490: EMPTY
89491: LIST
89492: LIST
89493: PUSH
89494: LD_INT 2
89496: NEG
89497: PUSH
89498: LD_INT 5
89500: NEG
89501: PUSH
89502: EMPTY
89503: LIST
89504: LIST
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: LIST
89518: LIST
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
89553: LD_ADDR_VAR 0 31
89557: PUSH
89558: LD_INT 0
89560: PUSH
89561: LD_INT 4
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: LD_INT 3
89573: PUSH
89574: EMPTY
89575: LIST
89576: LIST
89577: PUSH
89578: LD_INT 1
89580: PUSH
89581: LD_INT 4
89583: PUSH
89584: EMPTY
89585: LIST
89586: LIST
89587: PUSH
89588: LD_INT 1
89590: PUSH
89591: LD_INT 5
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 0
89600: PUSH
89601: LD_INT 5
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: LD_INT 1
89610: NEG
89611: PUSH
89612: LD_INT 4
89614: PUSH
89615: EMPTY
89616: LIST
89617: LIST
89618: PUSH
89619: LD_INT 1
89621: NEG
89622: PUSH
89623: LD_INT 3
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 2
89632: PUSH
89633: LD_INT 5
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 2
89642: NEG
89643: PUSH
89644: LD_INT 3
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 3
89653: NEG
89654: PUSH
89655: LD_INT 0
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 3
89664: NEG
89665: PUSH
89666: LD_INT 1
89668: NEG
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 2
89676: NEG
89677: PUSH
89678: LD_INT 0
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: LD_INT 2
89687: NEG
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: PUSH
89696: LD_INT 3
89698: NEG
89699: PUSH
89700: LD_INT 1
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 4
89709: NEG
89710: PUSH
89711: LD_INT 0
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: LD_INT 4
89720: NEG
89721: PUSH
89722: LD_INT 1
89724: NEG
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 4
89732: NEG
89733: PUSH
89734: LD_INT 2
89736: NEG
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 2
89744: NEG
89745: PUSH
89746: LD_INT 2
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 4
89755: NEG
89756: PUSH
89757: LD_INT 4
89759: NEG
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 4
89767: NEG
89768: PUSH
89769: LD_INT 5
89771: NEG
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: PUSH
89777: LD_INT 3
89779: NEG
89780: PUSH
89781: LD_INT 4
89783: NEG
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 3
89791: NEG
89792: PUSH
89793: LD_INT 3
89795: NEG
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 4
89803: NEG
89804: PUSH
89805: LD_INT 3
89807: NEG
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 5
89815: NEG
89816: PUSH
89817: LD_INT 4
89819: NEG
89820: PUSH
89821: EMPTY
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 5
89827: NEG
89828: PUSH
89829: LD_INT 5
89831: NEG
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 3
89839: NEG
89840: PUSH
89841: LD_INT 5
89843: NEG
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 5
89851: NEG
89852: PUSH
89853: LD_INT 3
89855: NEG
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: LD_INT 0
89863: PUSH
89864: LD_INT 3
89866: NEG
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 0
89874: PUSH
89875: LD_INT 4
89877: NEG
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 1
89885: PUSH
89886: LD_INT 3
89888: NEG
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: LD_INT 1
89896: PUSH
89897: LD_INT 2
89899: NEG
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PUSH
89905: LD_INT 0
89907: PUSH
89908: LD_INT 2
89910: NEG
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: PUSH
89916: LD_INT 1
89918: NEG
89919: PUSH
89920: LD_INT 3
89922: NEG
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 1
89930: NEG
89931: PUSH
89932: LD_INT 4
89934: NEG
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 2
89942: PUSH
89943: LD_INT 2
89945: NEG
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 2
89953: NEG
89954: PUSH
89955: LD_INT 4
89957: NEG
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: PUSH
89963: LD_INT 4
89965: PUSH
89966: LD_INT 0
89968: PUSH
89969: EMPTY
89970: LIST
89971: LIST
89972: PUSH
89973: LD_INT 4
89975: PUSH
89976: LD_INT 1
89978: NEG
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: PUSH
89984: LD_INT 5
89986: PUSH
89987: LD_INT 0
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 5
89996: PUSH
89997: LD_INT 1
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 4
90006: PUSH
90007: LD_INT 1
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 3
90016: PUSH
90017: LD_INT 0
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 3
90026: PUSH
90027: LD_INT 1
90029: NEG
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 3
90037: PUSH
90038: LD_INT 2
90040: NEG
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 5
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: EMPTY
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
90103: LD_ADDR_VAR 0 32
90107: PUSH
90108: LD_INT 4
90110: NEG
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 4
90121: NEG
90122: PUSH
90123: LD_INT 1
90125: NEG
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 3
90133: NEG
90134: PUSH
90135: LD_INT 0
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: LD_INT 3
90144: NEG
90145: PUSH
90146: LD_INT 1
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: LD_INT 4
90155: NEG
90156: PUSH
90157: LD_INT 1
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: PUSH
90164: LD_INT 5
90166: NEG
90167: PUSH
90168: LD_INT 0
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: PUSH
90175: LD_INT 5
90177: NEG
90178: PUSH
90179: LD_INT 1
90181: NEG
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: PUSH
90187: LD_INT 5
90189: NEG
90190: PUSH
90191: LD_INT 2
90193: NEG
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 3
90201: NEG
90202: PUSH
90203: LD_INT 2
90205: PUSH
90206: EMPTY
90207: LIST
90208: LIST
90209: PUSH
90210: LD_INT 3
90212: NEG
90213: PUSH
90214: LD_INT 3
90216: NEG
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 3
90224: NEG
90225: PUSH
90226: LD_INT 4
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 2
90236: NEG
90237: PUSH
90238: LD_INT 3
90240: NEG
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 2
90248: NEG
90249: PUSH
90250: LD_INT 2
90252: NEG
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 3
90260: NEG
90261: PUSH
90262: LD_INT 2
90264: NEG
90265: PUSH
90266: EMPTY
90267: LIST
90268: LIST
90269: PUSH
90270: LD_INT 4
90272: NEG
90273: PUSH
90274: LD_INT 3
90276: NEG
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 4
90284: NEG
90285: PUSH
90286: LD_INT 4
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 2
90296: NEG
90297: PUSH
90298: LD_INT 4
90300: NEG
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 4
90308: NEG
90309: PUSH
90310: LD_INT 2
90312: NEG
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 0
90320: PUSH
90321: LD_INT 4
90323: NEG
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 0
90331: PUSH
90332: LD_INT 5
90334: NEG
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: LD_INT 4
90345: NEG
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 1
90353: PUSH
90354: LD_INT 3
90356: NEG
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 0
90364: PUSH
90365: LD_INT 3
90367: NEG
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: LD_INT 1
90375: NEG
90376: PUSH
90377: LD_INT 4
90379: NEG
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 1
90387: NEG
90388: PUSH
90389: LD_INT 5
90391: NEG
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 2
90399: PUSH
90400: LD_INT 3
90402: NEG
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 2
90410: NEG
90411: PUSH
90412: LD_INT 5
90414: NEG
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 3
90422: PUSH
90423: LD_INT 0
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 3
90432: PUSH
90433: LD_INT 1
90435: NEG
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 4
90443: PUSH
90444: LD_INT 0
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 4
90453: PUSH
90454: LD_INT 1
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: PUSH
90461: LD_INT 3
90463: PUSH
90464: LD_INT 1
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: PUSH
90471: LD_INT 2
90473: PUSH
90474: LD_INT 0
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 2
90483: PUSH
90484: LD_INT 1
90486: NEG
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 2
90494: PUSH
90495: LD_INT 2
90497: NEG
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 4
90505: PUSH
90506: LD_INT 2
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 4
90515: PUSH
90516: LD_INT 4
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: PUSH
90523: LD_INT 4
90525: PUSH
90526: LD_INT 3
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PUSH
90533: LD_INT 5
90535: PUSH
90536: LD_INT 4
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PUSH
90543: LD_INT 5
90545: PUSH
90546: LD_INT 5
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 4
90555: PUSH
90556: LD_INT 5
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PUSH
90563: LD_INT 3
90565: PUSH
90566: LD_INT 4
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 3
90575: PUSH
90576: LD_INT 3
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 5
90585: PUSH
90586: LD_INT 3
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 3
90595: PUSH
90596: LD_INT 5
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
90650: LD_ADDR_VAR 0 33
90654: PUSH
90655: LD_INT 4
90657: NEG
90658: PUSH
90659: LD_INT 4
90661: NEG
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 4
90669: NEG
90670: PUSH
90671: LD_INT 5
90673: NEG
90674: PUSH
90675: EMPTY
90676: LIST
90677: LIST
90678: PUSH
90679: LD_INT 3
90681: NEG
90682: PUSH
90683: LD_INT 4
90685: NEG
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 3
90693: NEG
90694: PUSH
90695: LD_INT 3
90697: NEG
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 4
90705: NEG
90706: PUSH
90707: LD_INT 3
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 5
90717: NEG
90718: PUSH
90719: LD_INT 4
90721: NEG
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 5
90729: NEG
90730: PUSH
90731: LD_INT 5
90733: NEG
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 3
90741: NEG
90742: PUSH
90743: LD_INT 5
90745: NEG
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 5
90753: NEG
90754: PUSH
90755: LD_INT 3
90757: NEG
90758: PUSH
90759: EMPTY
90760: LIST
90761: LIST
90762: PUSH
90763: LD_INT 0
90765: PUSH
90766: LD_INT 3
90768: NEG
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: LD_INT 4
90779: NEG
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: LD_INT 3
90790: NEG
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 1
90798: PUSH
90799: LD_INT 2
90801: NEG
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 0
90809: PUSH
90810: LD_INT 2
90812: NEG
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: LD_INT 3
90824: NEG
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 1
90832: NEG
90833: PUSH
90834: LD_INT 4
90836: NEG
90837: PUSH
90838: EMPTY
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 2
90844: PUSH
90845: LD_INT 2
90847: NEG
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 2
90855: NEG
90856: PUSH
90857: LD_INT 4
90859: NEG
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 4
90867: PUSH
90868: LD_INT 0
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 4
90877: PUSH
90878: LD_INT 1
90880: NEG
90881: PUSH
90882: EMPTY
90883: LIST
90884: LIST
90885: PUSH
90886: LD_INT 5
90888: PUSH
90889: LD_INT 0
90891: PUSH
90892: EMPTY
90893: LIST
90894: LIST
90895: PUSH
90896: LD_INT 5
90898: PUSH
90899: LD_INT 1
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: PUSH
90906: LD_INT 4
90908: PUSH
90909: LD_INT 1
90911: PUSH
90912: EMPTY
90913: LIST
90914: LIST
90915: PUSH
90916: LD_INT 3
90918: PUSH
90919: LD_INT 0
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 3
90928: PUSH
90929: LD_INT 1
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 3
90939: PUSH
90940: LD_INT 2
90942: NEG
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 5
90950: PUSH
90951: LD_INT 2
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 3
90960: PUSH
90961: LD_INT 3
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: LD_INT 3
90970: PUSH
90971: LD_INT 2
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 4
90980: PUSH
90981: LD_INT 3
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 4
90990: PUSH
90991: LD_INT 4
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 3
91000: PUSH
91001: LD_INT 4
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 2
91010: PUSH
91011: LD_INT 3
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 2
91020: PUSH
91021: LD_INT 2
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 4
91030: PUSH
91031: LD_INT 2
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: PUSH
91038: LD_INT 2
91040: PUSH
91041: LD_INT 4
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: PUSH
91048: LD_INT 0
91050: PUSH
91051: LD_INT 4
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 0
91060: PUSH
91061: LD_INT 3
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 1
91070: PUSH
91071: LD_INT 4
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 1
91080: PUSH
91081: LD_INT 5
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: LD_INT 0
91090: PUSH
91091: LD_INT 5
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: LD_INT 1
91100: NEG
91101: PUSH
91102: LD_INT 4
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: LD_INT 3
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 2
91122: PUSH
91123: LD_INT 5
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: LD_INT 2
91132: NEG
91133: PUSH
91134: LD_INT 3
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: LIST
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
91188: LD_ADDR_VAR 0 34
91192: PUSH
91193: LD_INT 0
91195: PUSH
91196: LD_INT 4
91198: NEG
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 0
91206: PUSH
91207: LD_INT 5
91209: NEG
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 1
91217: PUSH
91218: LD_INT 4
91220: NEG
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 1
91228: PUSH
91229: LD_INT 3
91231: NEG
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 0
91239: PUSH
91240: LD_INT 3
91242: NEG
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 1
91250: NEG
91251: PUSH
91252: LD_INT 4
91254: NEG
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 5
91266: NEG
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 2
91274: PUSH
91275: LD_INT 3
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 2
91285: NEG
91286: PUSH
91287: LD_INT 5
91289: NEG
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 3
91297: PUSH
91298: LD_INT 0
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 3
91307: PUSH
91308: LD_INT 1
91310: NEG
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 4
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 4
91328: PUSH
91329: LD_INT 1
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 3
91338: PUSH
91339: LD_INT 1
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 2
91348: PUSH
91349: LD_INT 0
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 2
91358: PUSH
91359: LD_INT 1
91361: NEG
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 2
91369: PUSH
91370: LD_INT 2
91372: NEG
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 4
91380: PUSH
91381: LD_INT 2
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 4
91390: PUSH
91391: LD_INT 4
91393: PUSH
91394: EMPTY
91395: LIST
91396: LIST
91397: PUSH
91398: LD_INT 4
91400: PUSH
91401: LD_INT 3
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 5
91410: PUSH
91411: LD_INT 4
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 5
91420: PUSH
91421: LD_INT 5
91423: PUSH
91424: EMPTY
91425: LIST
91426: LIST
91427: PUSH
91428: LD_INT 4
91430: PUSH
91431: LD_INT 5
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 3
91440: PUSH
91441: LD_INT 4
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 3
91450: PUSH
91451: LD_INT 3
91453: PUSH
91454: EMPTY
91455: LIST
91456: LIST
91457: PUSH
91458: LD_INT 5
91460: PUSH
91461: LD_INT 3
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 3
91470: PUSH
91471: LD_INT 5
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 0
91480: PUSH
91481: LD_INT 3
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: PUSH
91488: LD_INT 0
91490: PUSH
91491: LD_INT 2
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 1
91500: PUSH
91501: LD_INT 3
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: LD_INT 1
91510: PUSH
91511: LD_INT 4
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: LD_INT 0
91520: PUSH
91521: LD_INT 4
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 1
91530: NEG
91531: PUSH
91532: LD_INT 3
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 1
91541: NEG
91542: PUSH
91543: LD_INT 2
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: LD_INT 2
91552: PUSH
91553: LD_INT 4
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PUSH
91560: LD_INT 2
91562: NEG
91563: PUSH
91564: LD_INT 2
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 4
91573: NEG
91574: PUSH
91575: LD_INT 0
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 4
91584: NEG
91585: PUSH
91586: LD_INT 1
91588: NEG
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: PUSH
91594: LD_INT 3
91596: NEG
91597: PUSH
91598: LD_INT 0
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: LD_INT 3
91607: NEG
91608: PUSH
91609: LD_INT 1
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 4
91618: NEG
91619: PUSH
91620: LD_INT 1
91622: PUSH
91623: EMPTY
91624: LIST
91625: LIST
91626: PUSH
91627: LD_INT 5
91629: NEG
91630: PUSH
91631: LD_INT 0
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: PUSH
91638: LD_INT 5
91640: NEG
91641: PUSH
91642: LD_INT 1
91644: NEG
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 5
91652: NEG
91653: PUSH
91654: LD_INT 2
91656: NEG
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 3
91664: NEG
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: ST_TO_ADDR
// end ; end ;
91720: GO 91723
91722: POP
// case btype of b_depot , b_warehouse :
91723: LD_VAR 0 1
91727: PUSH
91728: LD_INT 0
91730: DOUBLE
91731: EQUAL
91732: IFTRUE 91742
91734: LD_INT 1
91736: DOUBLE
91737: EQUAL
91738: IFTRUE 91742
91740: GO 91943
91742: POP
// case nation of nation_american :
91743: LD_VAR 0 5
91747: PUSH
91748: LD_INT 1
91750: DOUBLE
91751: EQUAL
91752: IFTRUE 91756
91754: GO 91812
91756: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
91757: LD_ADDR_VAR 0 9
91761: PUSH
91762: LD_VAR 0 11
91766: PUSH
91767: LD_VAR 0 12
91771: PUSH
91772: LD_VAR 0 13
91776: PUSH
91777: LD_VAR 0 14
91781: PUSH
91782: LD_VAR 0 15
91786: PUSH
91787: LD_VAR 0 16
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: PUSH
91800: LD_VAR 0 4
91804: PUSH
91805: LD_INT 1
91807: PLUS
91808: ARRAY
91809: ST_TO_ADDR
91810: GO 91941
91812: LD_INT 2
91814: DOUBLE
91815: EQUAL
91816: IFTRUE 91820
91818: GO 91876
91820: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
91821: LD_ADDR_VAR 0 9
91825: PUSH
91826: LD_VAR 0 17
91830: PUSH
91831: LD_VAR 0 18
91835: PUSH
91836: LD_VAR 0 19
91840: PUSH
91841: LD_VAR 0 20
91845: PUSH
91846: LD_VAR 0 21
91850: PUSH
91851: LD_VAR 0 22
91855: PUSH
91856: EMPTY
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: PUSH
91864: LD_VAR 0 4
91868: PUSH
91869: LD_INT 1
91871: PLUS
91872: ARRAY
91873: ST_TO_ADDR
91874: GO 91941
91876: LD_INT 3
91878: DOUBLE
91879: EQUAL
91880: IFTRUE 91884
91882: GO 91940
91884: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
91885: LD_ADDR_VAR 0 9
91889: PUSH
91890: LD_VAR 0 23
91894: PUSH
91895: LD_VAR 0 24
91899: PUSH
91900: LD_VAR 0 25
91904: PUSH
91905: LD_VAR 0 26
91909: PUSH
91910: LD_VAR 0 27
91914: PUSH
91915: LD_VAR 0 28
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: PUSH
91928: LD_VAR 0 4
91932: PUSH
91933: LD_INT 1
91935: PLUS
91936: ARRAY
91937: ST_TO_ADDR
91938: GO 91941
91940: POP
91941: GO 92496
91943: LD_INT 2
91945: DOUBLE
91946: EQUAL
91947: IFTRUE 91957
91949: LD_INT 3
91951: DOUBLE
91952: EQUAL
91953: IFTRUE 91957
91955: GO 92013
91957: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
91958: LD_ADDR_VAR 0 9
91962: PUSH
91963: LD_VAR 0 29
91967: PUSH
91968: LD_VAR 0 30
91972: PUSH
91973: LD_VAR 0 31
91977: PUSH
91978: LD_VAR 0 32
91982: PUSH
91983: LD_VAR 0 33
91987: PUSH
91988: LD_VAR 0 34
91992: PUSH
91993: EMPTY
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: PUSH
92001: LD_VAR 0 4
92005: PUSH
92006: LD_INT 1
92008: PLUS
92009: ARRAY
92010: ST_TO_ADDR
92011: GO 92496
92013: LD_INT 16
92015: DOUBLE
92016: EQUAL
92017: IFTRUE 92075
92019: LD_INT 17
92021: DOUBLE
92022: EQUAL
92023: IFTRUE 92075
92025: LD_INT 18
92027: DOUBLE
92028: EQUAL
92029: IFTRUE 92075
92031: LD_INT 19
92033: DOUBLE
92034: EQUAL
92035: IFTRUE 92075
92037: LD_INT 22
92039: DOUBLE
92040: EQUAL
92041: IFTRUE 92075
92043: LD_INT 20
92045: DOUBLE
92046: EQUAL
92047: IFTRUE 92075
92049: LD_INT 21
92051: DOUBLE
92052: EQUAL
92053: IFTRUE 92075
92055: LD_INT 23
92057: DOUBLE
92058: EQUAL
92059: IFTRUE 92075
92061: LD_INT 24
92063: DOUBLE
92064: EQUAL
92065: IFTRUE 92075
92067: LD_INT 25
92069: DOUBLE
92070: EQUAL
92071: IFTRUE 92075
92073: GO 92131
92075: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
92076: LD_ADDR_VAR 0 9
92080: PUSH
92081: LD_VAR 0 35
92085: PUSH
92086: LD_VAR 0 36
92090: PUSH
92091: LD_VAR 0 37
92095: PUSH
92096: LD_VAR 0 38
92100: PUSH
92101: LD_VAR 0 39
92105: PUSH
92106: LD_VAR 0 40
92110: PUSH
92111: EMPTY
92112: LIST
92113: LIST
92114: LIST
92115: LIST
92116: LIST
92117: LIST
92118: PUSH
92119: LD_VAR 0 4
92123: PUSH
92124: LD_INT 1
92126: PLUS
92127: ARRAY
92128: ST_TO_ADDR
92129: GO 92496
92131: LD_INT 6
92133: DOUBLE
92134: EQUAL
92135: IFTRUE 92187
92137: LD_INT 7
92139: DOUBLE
92140: EQUAL
92141: IFTRUE 92187
92143: LD_INT 8
92145: DOUBLE
92146: EQUAL
92147: IFTRUE 92187
92149: LD_INT 13
92151: DOUBLE
92152: EQUAL
92153: IFTRUE 92187
92155: LD_INT 12
92157: DOUBLE
92158: EQUAL
92159: IFTRUE 92187
92161: LD_INT 15
92163: DOUBLE
92164: EQUAL
92165: IFTRUE 92187
92167: LD_INT 11
92169: DOUBLE
92170: EQUAL
92171: IFTRUE 92187
92173: LD_INT 14
92175: DOUBLE
92176: EQUAL
92177: IFTRUE 92187
92179: LD_INT 10
92181: DOUBLE
92182: EQUAL
92183: IFTRUE 92187
92185: GO 92243
92187: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
92188: LD_ADDR_VAR 0 9
92192: PUSH
92193: LD_VAR 0 41
92197: PUSH
92198: LD_VAR 0 42
92202: PUSH
92203: LD_VAR 0 43
92207: PUSH
92208: LD_VAR 0 44
92212: PUSH
92213: LD_VAR 0 45
92217: PUSH
92218: LD_VAR 0 46
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: PUSH
92231: LD_VAR 0 4
92235: PUSH
92236: LD_INT 1
92238: PLUS
92239: ARRAY
92240: ST_TO_ADDR
92241: GO 92496
92243: LD_INT 36
92245: DOUBLE
92246: EQUAL
92247: IFTRUE 92251
92249: GO 92307
92251: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
92252: LD_ADDR_VAR 0 9
92256: PUSH
92257: LD_VAR 0 47
92261: PUSH
92262: LD_VAR 0 48
92266: PUSH
92267: LD_VAR 0 49
92271: PUSH
92272: LD_VAR 0 50
92276: PUSH
92277: LD_VAR 0 51
92281: PUSH
92282: LD_VAR 0 52
92286: PUSH
92287: EMPTY
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: PUSH
92295: LD_VAR 0 4
92299: PUSH
92300: LD_INT 1
92302: PLUS
92303: ARRAY
92304: ST_TO_ADDR
92305: GO 92496
92307: LD_INT 4
92309: DOUBLE
92310: EQUAL
92311: IFTRUE 92333
92313: LD_INT 5
92315: DOUBLE
92316: EQUAL
92317: IFTRUE 92333
92319: LD_INT 34
92321: DOUBLE
92322: EQUAL
92323: IFTRUE 92333
92325: LD_INT 37
92327: DOUBLE
92328: EQUAL
92329: IFTRUE 92333
92331: GO 92389
92333: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
92334: LD_ADDR_VAR 0 9
92338: PUSH
92339: LD_VAR 0 53
92343: PUSH
92344: LD_VAR 0 54
92348: PUSH
92349: LD_VAR 0 55
92353: PUSH
92354: LD_VAR 0 56
92358: PUSH
92359: LD_VAR 0 57
92363: PUSH
92364: LD_VAR 0 58
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: PUSH
92377: LD_VAR 0 4
92381: PUSH
92382: LD_INT 1
92384: PLUS
92385: ARRAY
92386: ST_TO_ADDR
92387: GO 92496
92389: LD_INT 31
92391: DOUBLE
92392: EQUAL
92393: IFTRUE 92439
92395: LD_INT 32
92397: DOUBLE
92398: EQUAL
92399: IFTRUE 92439
92401: LD_INT 33
92403: DOUBLE
92404: EQUAL
92405: IFTRUE 92439
92407: LD_INT 27
92409: DOUBLE
92410: EQUAL
92411: IFTRUE 92439
92413: LD_INT 26
92415: DOUBLE
92416: EQUAL
92417: IFTRUE 92439
92419: LD_INT 28
92421: DOUBLE
92422: EQUAL
92423: IFTRUE 92439
92425: LD_INT 29
92427: DOUBLE
92428: EQUAL
92429: IFTRUE 92439
92431: LD_INT 30
92433: DOUBLE
92434: EQUAL
92435: IFTRUE 92439
92437: GO 92495
92439: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
92440: LD_ADDR_VAR 0 9
92444: PUSH
92445: LD_VAR 0 59
92449: PUSH
92450: LD_VAR 0 60
92454: PUSH
92455: LD_VAR 0 61
92459: PUSH
92460: LD_VAR 0 62
92464: PUSH
92465: LD_VAR 0 63
92469: PUSH
92470: LD_VAR 0 64
92474: PUSH
92475: EMPTY
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: LIST
92481: LIST
92482: PUSH
92483: LD_VAR 0 4
92487: PUSH
92488: LD_INT 1
92490: PLUS
92491: ARRAY
92492: ST_TO_ADDR
92493: GO 92496
92495: POP
// temp_list2 = [ ] ;
92496: LD_ADDR_VAR 0 10
92500: PUSH
92501: EMPTY
92502: ST_TO_ADDR
// for i in temp_list do
92503: LD_ADDR_VAR 0 8
92507: PUSH
92508: LD_VAR 0 9
92512: PUSH
92513: FOR_IN
92514: IFFALSE 92566
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
92516: LD_ADDR_VAR 0 10
92520: PUSH
92521: LD_VAR 0 10
92525: PUSH
92526: LD_VAR 0 8
92530: PUSH
92531: LD_INT 1
92533: ARRAY
92534: PUSH
92535: LD_VAR 0 2
92539: PLUS
92540: PUSH
92541: LD_VAR 0 8
92545: PUSH
92546: LD_INT 2
92548: ARRAY
92549: PUSH
92550: LD_VAR 0 3
92554: PLUS
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: EMPTY
92561: LIST
92562: ADD
92563: ST_TO_ADDR
92564: GO 92513
92566: POP
92567: POP
// result = temp_list2 ;
92568: LD_ADDR_VAR 0 7
92572: PUSH
92573: LD_VAR 0 10
92577: ST_TO_ADDR
// end ;
92578: LD_VAR 0 7
92582: RET
// export function EnemyInRange ( unit , dist ) ; begin
92583: LD_INT 0
92585: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
92586: LD_ADDR_VAR 0 3
92590: PUSH
92591: LD_VAR 0 1
92595: PPUSH
92596: CALL_OW 255
92600: PPUSH
92601: LD_VAR 0 1
92605: PPUSH
92606: CALL_OW 250
92610: PPUSH
92611: LD_VAR 0 1
92615: PPUSH
92616: CALL_OW 251
92620: PPUSH
92621: LD_VAR 0 2
92625: PPUSH
92626: CALL 66354 0 4
92630: PUSH
92631: LD_INT 4
92633: ARRAY
92634: ST_TO_ADDR
// end ;
92635: LD_VAR 0 3
92639: RET
// export function PlayerSeeMe ( unit ) ; begin
92640: LD_INT 0
92642: PPUSH
// result := See ( your_side , unit ) ;
92643: LD_ADDR_VAR 0 2
92647: PUSH
92648: LD_OWVAR 2
92652: PPUSH
92653: LD_VAR 0 1
92657: PPUSH
92658: CALL_OW 292
92662: ST_TO_ADDR
// end ;
92663: LD_VAR 0 2
92667: RET
// export function ReverseDir ( unit ) ; begin
92668: LD_INT 0
92670: PPUSH
// if not unit then
92671: LD_VAR 0 1
92675: NOT
92676: IFFALSE 92680
// exit ;
92678: GO 92703
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
92680: LD_ADDR_VAR 0 2
92684: PUSH
92685: LD_VAR 0 1
92689: PPUSH
92690: CALL_OW 254
92694: PUSH
92695: LD_INT 3
92697: PLUS
92698: PUSH
92699: LD_INT 6
92701: MOD
92702: ST_TO_ADDR
// end ;
92703: LD_VAR 0 2
92707: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
92708: LD_INT 0
92710: PPUSH
92711: PPUSH
92712: PPUSH
92713: PPUSH
92714: PPUSH
// if not hexes then
92715: LD_VAR 0 2
92719: NOT
92720: IFFALSE 92724
// exit ;
92722: GO 92872
// dist := 9999 ;
92724: LD_ADDR_VAR 0 5
92728: PUSH
92729: LD_INT 9999
92731: ST_TO_ADDR
// for i = 1 to hexes do
92732: LD_ADDR_VAR 0 4
92736: PUSH
92737: DOUBLE
92738: LD_INT 1
92740: DEC
92741: ST_TO_ADDR
92742: LD_VAR 0 2
92746: PUSH
92747: FOR_TO
92748: IFFALSE 92860
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
92750: LD_VAR 0 1
92754: PPUSH
92755: LD_VAR 0 2
92759: PUSH
92760: LD_VAR 0 4
92764: ARRAY
92765: PUSH
92766: LD_INT 1
92768: ARRAY
92769: PPUSH
92770: LD_VAR 0 2
92774: PUSH
92775: LD_VAR 0 4
92779: ARRAY
92780: PUSH
92781: LD_INT 2
92783: ARRAY
92784: PPUSH
92785: CALL_OW 297
92789: PUSH
92790: LD_VAR 0 5
92794: LESS
92795: IFFALSE 92858
// begin hex := hexes [ i ] ;
92797: LD_ADDR_VAR 0 7
92801: PUSH
92802: LD_VAR 0 2
92806: PUSH
92807: LD_VAR 0 4
92811: ARRAY
92812: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
92813: LD_ADDR_VAR 0 5
92817: PUSH
92818: LD_VAR 0 1
92822: PPUSH
92823: LD_VAR 0 2
92827: PUSH
92828: LD_VAR 0 4
92832: ARRAY
92833: PUSH
92834: LD_INT 1
92836: ARRAY
92837: PPUSH
92838: LD_VAR 0 2
92842: PUSH
92843: LD_VAR 0 4
92847: ARRAY
92848: PUSH
92849: LD_INT 2
92851: ARRAY
92852: PPUSH
92853: CALL_OW 297
92857: ST_TO_ADDR
// end ; end ;
92858: GO 92747
92860: POP
92861: POP
// result := hex ;
92862: LD_ADDR_VAR 0 3
92866: PUSH
92867: LD_VAR 0 7
92871: ST_TO_ADDR
// end ;
92872: LD_VAR 0 3
92876: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
92877: LD_INT 0
92879: PPUSH
92880: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
92881: LD_VAR 0 1
92885: NOT
92886: PUSH
92887: LD_VAR 0 1
92891: PUSH
92892: LD_INT 21
92894: PUSH
92895: LD_INT 2
92897: PUSH
92898: EMPTY
92899: LIST
92900: LIST
92901: PUSH
92902: LD_INT 23
92904: PUSH
92905: LD_INT 2
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: PUSH
92912: EMPTY
92913: LIST
92914: LIST
92915: PPUSH
92916: CALL_OW 69
92920: IN
92921: NOT
92922: OR
92923: IFFALSE 92927
// exit ;
92925: GO 92974
// for i = 1 to 3 do
92927: LD_ADDR_VAR 0 3
92931: PUSH
92932: DOUBLE
92933: LD_INT 1
92935: DEC
92936: ST_TO_ADDR
92937: LD_INT 3
92939: PUSH
92940: FOR_TO
92941: IFFALSE 92972
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
92943: LD_VAR 0 1
92947: PPUSH
92948: CALL_OW 250
92952: PPUSH
92953: LD_VAR 0 1
92957: PPUSH
92958: CALL_OW 251
92962: PPUSH
92963: LD_INT 1
92965: PPUSH
92966: CALL_OW 453
92970: GO 92940
92972: POP
92973: POP
// end ;
92974: LD_VAR 0 2
92978: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
92979: LD_INT 0
92981: PPUSH
92982: PPUSH
92983: PPUSH
92984: PPUSH
92985: PPUSH
92986: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
92987: LD_VAR 0 1
92991: NOT
92992: PUSH
92993: LD_VAR 0 2
92997: NOT
92998: OR
92999: PUSH
93000: LD_VAR 0 1
93004: PPUSH
93005: CALL_OW 314
93009: OR
93010: IFFALSE 93014
// exit ;
93012: GO 93455
// x := GetX ( enemy_unit ) ;
93014: LD_ADDR_VAR 0 7
93018: PUSH
93019: LD_VAR 0 2
93023: PPUSH
93024: CALL_OW 250
93028: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
93029: LD_ADDR_VAR 0 8
93033: PUSH
93034: LD_VAR 0 2
93038: PPUSH
93039: CALL_OW 251
93043: ST_TO_ADDR
// if not x or not y then
93044: LD_VAR 0 7
93048: NOT
93049: PUSH
93050: LD_VAR 0 8
93054: NOT
93055: OR
93056: IFFALSE 93060
// exit ;
93058: GO 93455
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
93060: LD_ADDR_VAR 0 6
93064: PUSH
93065: LD_VAR 0 7
93069: PPUSH
93070: LD_INT 0
93072: PPUSH
93073: LD_INT 4
93075: PPUSH
93076: CALL_OW 272
93080: PUSH
93081: LD_VAR 0 8
93085: PPUSH
93086: LD_INT 0
93088: PPUSH
93089: LD_INT 4
93091: PPUSH
93092: CALL_OW 273
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_VAR 0 7
93105: PPUSH
93106: LD_INT 1
93108: PPUSH
93109: LD_INT 4
93111: PPUSH
93112: CALL_OW 272
93116: PUSH
93117: LD_VAR 0 8
93121: PPUSH
93122: LD_INT 1
93124: PPUSH
93125: LD_INT 4
93127: PPUSH
93128: CALL_OW 273
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_VAR 0 7
93141: PPUSH
93142: LD_INT 2
93144: PPUSH
93145: LD_INT 4
93147: PPUSH
93148: CALL_OW 272
93152: PUSH
93153: LD_VAR 0 8
93157: PPUSH
93158: LD_INT 2
93160: PPUSH
93161: LD_INT 4
93163: PPUSH
93164: CALL_OW 273
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: LD_VAR 0 7
93177: PPUSH
93178: LD_INT 3
93180: PPUSH
93181: LD_INT 4
93183: PPUSH
93184: CALL_OW 272
93188: PUSH
93189: LD_VAR 0 8
93193: PPUSH
93194: LD_INT 3
93196: PPUSH
93197: LD_INT 4
93199: PPUSH
93200: CALL_OW 273
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_VAR 0 7
93213: PPUSH
93214: LD_INT 4
93216: PPUSH
93217: LD_INT 4
93219: PPUSH
93220: CALL_OW 272
93224: PUSH
93225: LD_VAR 0 8
93229: PPUSH
93230: LD_INT 4
93232: PPUSH
93233: LD_INT 4
93235: PPUSH
93236: CALL_OW 273
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: PUSH
93245: LD_VAR 0 7
93249: PPUSH
93250: LD_INT 5
93252: PPUSH
93253: LD_INT 4
93255: PPUSH
93256: CALL_OW 272
93260: PUSH
93261: LD_VAR 0 8
93265: PPUSH
93266: LD_INT 5
93268: PPUSH
93269: LD_INT 4
93271: PPUSH
93272: CALL_OW 273
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: ST_TO_ADDR
// for i = tmp downto 1 do
93289: LD_ADDR_VAR 0 4
93293: PUSH
93294: DOUBLE
93295: LD_VAR 0 6
93299: INC
93300: ST_TO_ADDR
93301: LD_INT 1
93303: PUSH
93304: FOR_DOWNTO
93305: IFFALSE 93406
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
93307: LD_VAR 0 6
93311: PUSH
93312: LD_VAR 0 4
93316: ARRAY
93317: PUSH
93318: LD_INT 1
93320: ARRAY
93321: PPUSH
93322: LD_VAR 0 6
93326: PUSH
93327: LD_VAR 0 4
93331: ARRAY
93332: PUSH
93333: LD_INT 2
93335: ARRAY
93336: PPUSH
93337: CALL_OW 488
93341: NOT
93342: PUSH
93343: LD_VAR 0 6
93347: PUSH
93348: LD_VAR 0 4
93352: ARRAY
93353: PUSH
93354: LD_INT 1
93356: ARRAY
93357: PPUSH
93358: LD_VAR 0 6
93362: PUSH
93363: LD_VAR 0 4
93367: ARRAY
93368: PUSH
93369: LD_INT 2
93371: ARRAY
93372: PPUSH
93373: CALL_OW 428
93377: PUSH
93378: LD_INT 0
93380: NONEQUAL
93381: OR
93382: IFFALSE 93404
// tmp := Delete ( tmp , i ) ;
93384: LD_ADDR_VAR 0 6
93388: PUSH
93389: LD_VAR 0 6
93393: PPUSH
93394: LD_VAR 0 4
93398: PPUSH
93399: CALL_OW 3
93403: ST_TO_ADDR
93404: GO 93304
93406: POP
93407: POP
// j := GetClosestHex ( unit , tmp ) ;
93408: LD_ADDR_VAR 0 5
93412: PUSH
93413: LD_VAR 0 1
93417: PPUSH
93418: LD_VAR 0 6
93422: PPUSH
93423: CALL 92708 0 2
93427: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
93428: LD_VAR 0 1
93432: PPUSH
93433: LD_VAR 0 5
93437: PUSH
93438: LD_INT 1
93440: ARRAY
93441: PPUSH
93442: LD_VAR 0 5
93446: PUSH
93447: LD_INT 2
93449: ARRAY
93450: PPUSH
93451: CALL_OW 111
// end ;
93455: LD_VAR 0 3
93459: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
93460: LD_INT 0
93462: PPUSH
93463: PPUSH
93464: PPUSH
// uc_side = 0 ;
93465: LD_ADDR_OWVAR 20
93469: PUSH
93470: LD_INT 0
93472: ST_TO_ADDR
// uc_nation = 0 ;
93473: LD_ADDR_OWVAR 21
93477: PUSH
93478: LD_INT 0
93480: ST_TO_ADDR
// InitHc_All ( ) ;
93481: CALL_OW 584
// InitVc ;
93485: CALL_OW 20
// if mastodonts then
93489: LD_VAR 0 6
93493: IFFALSE 93560
// for i = 1 to mastodonts do
93495: LD_ADDR_VAR 0 11
93499: PUSH
93500: DOUBLE
93501: LD_INT 1
93503: DEC
93504: ST_TO_ADDR
93505: LD_VAR 0 6
93509: PUSH
93510: FOR_TO
93511: IFFALSE 93558
// begin vc_chassis := 31 ;
93513: LD_ADDR_OWVAR 37
93517: PUSH
93518: LD_INT 31
93520: ST_TO_ADDR
// vc_control := control_rider ;
93521: LD_ADDR_OWVAR 38
93525: PUSH
93526: LD_INT 4
93528: ST_TO_ADDR
// animal := CreateVehicle ;
93529: LD_ADDR_VAR 0 12
93533: PUSH
93534: CALL_OW 45
93538: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93539: LD_VAR 0 12
93543: PPUSH
93544: LD_VAR 0 8
93548: PPUSH
93549: LD_INT 0
93551: PPUSH
93552: CALL 95748 0 3
// end ;
93556: GO 93510
93558: POP
93559: POP
// if horses then
93560: LD_VAR 0 5
93564: IFFALSE 93631
// for i = 1 to horses do
93566: LD_ADDR_VAR 0 11
93570: PUSH
93571: DOUBLE
93572: LD_INT 1
93574: DEC
93575: ST_TO_ADDR
93576: LD_VAR 0 5
93580: PUSH
93581: FOR_TO
93582: IFFALSE 93629
// begin hc_class := 21 ;
93584: LD_ADDR_OWVAR 28
93588: PUSH
93589: LD_INT 21
93591: ST_TO_ADDR
// hc_gallery :=  ;
93592: LD_ADDR_OWVAR 33
93596: PUSH
93597: LD_STRING 
93599: ST_TO_ADDR
// animal := CreateHuman ;
93600: LD_ADDR_VAR 0 12
93604: PUSH
93605: CALL_OW 44
93609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93610: LD_VAR 0 12
93614: PPUSH
93615: LD_VAR 0 8
93619: PPUSH
93620: LD_INT 0
93622: PPUSH
93623: CALL 95748 0 3
// end ;
93627: GO 93581
93629: POP
93630: POP
// if birds then
93631: LD_VAR 0 1
93635: IFFALSE 93702
// for i = 1 to birds do
93637: LD_ADDR_VAR 0 11
93641: PUSH
93642: DOUBLE
93643: LD_INT 1
93645: DEC
93646: ST_TO_ADDR
93647: LD_VAR 0 1
93651: PUSH
93652: FOR_TO
93653: IFFALSE 93700
// begin hc_class = 18 ;
93655: LD_ADDR_OWVAR 28
93659: PUSH
93660: LD_INT 18
93662: ST_TO_ADDR
// hc_gallery =  ;
93663: LD_ADDR_OWVAR 33
93667: PUSH
93668: LD_STRING 
93670: ST_TO_ADDR
// animal := CreateHuman ;
93671: LD_ADDR_VAR 0 12
93675: PUSH
93676: CALL_OW 44
93680: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93681: LD_VAR 0 12
93685: PPUSH
93686: LD_VAR 0 8
93690: PPUSH
93691: LD_INT 0
93693: PPUSH
93694: CALL 95748 0 3
// end ;
93698: GO 93652
93700: POP
93701: POP
// if tigers then
93702: LD_VAR 0 2
93706: IFFALSE 93790
// for i = 1 to tigers do
93708: LD_ADDR_VAR 0 11
93712: PUSH
93713: DOUBLE
93714: LD_INT 1
93716: DEC
93717: ST_TO_ADDR
93718: LD_VAR 0 2
93722: PUSH
93723: FOR_TO
93724: IFFALSE 93788
// begin hc_class = class_tiger ;
93726: LD_ADDR_OWVAR 28
93730: PUSH
93731: LD_INT 14
93733: ST_TO_ADDR
// hc_gallery =  ;
93734: LD_ADDR_OWVAR 33
93738: PUSH
93739: LD_STRING 
93741: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
93742: LD_ADDR_OWVAR 35
93746: PUSH
93747: LD_INT 7
93749: NEG
93750: PPUSH
93751: LD_INT 7
93753: PPUSH
93754: CALL_OW 12
93758: ST_TO_ADDR
// animal := CreateHuman ;
93759: LD_ADDR_VAR 0 12
93763: PUSH
93764: CALL_OW 44
93768: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93769: LD_VAR 0 12
93773: PPUSH
93774: LD_VAR 0 8
93778: PPUSH
93779: LD_INT 0
93781: PPUSH
93782: CALL 95748 0 3
// end ;
93786: GO 93723
93788: POP
93789: POP
// if apemans then
93790: LD_VAR 0 3
93794: IFFALSE 93917
// for i = 1 to apemans do
93796: LD_ADDR_VAR 0 11
93800: PUSH
93801: DOUBLE
93802: LD_INT 1
93804: DEC
93805: ST_TO_ADDR
93806: LD_VAR 0 3
93810: PUSH
93811: FOR_TO
93812: IFFALSE 93915
// begin hc_class = class_apeman ;
93814: LD_ADDR_OWVAR 28
93818: PUSH
93819: LD_INT 12
93821: ST_TO_ADDR
// hc_gallery =  ;
93822: LD_ADDR_OWVAR 33
93826: PUSH
93827: LD_STRING 
93829: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
93830: LD_ADDR_OWVAR 35
93834: PUSH
93835: LD_INT 5
93837: NEG
93838: PPUSH
93839: LD_INT 5
93841: PPUSH
93842: CALL_OW 12
93846: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
93847: LD_ADDR_OWVAR 31
93851: PUSH
93852: LD_INT 1
93854: PPUSH
93855: LD_INT 3
93857: PPUSH
93858: CALL_OW 12
93862: PUSH
93863: LD_INT 1
93865: PPUSH
93866: LD_INT 3
93868: PPUSH
93869: CALL_OW 12
93873: PUSH
93874: LD_INT 0
93876: PUSH
93877: LD_INT 0
93879: PUSH
93880: EMPTY
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: ST_TO_ADDR
// animal := CreateHuman ;
93886: LD_ADDR_VAR 0 12
93890: PUSH
93891: CALL_OW 44
93895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93896: LD_VAR 0 12
93900: PPUSH
93901: LD_VAR 0 8
93905: PPUSH
93906: LD_INT 0
93908: PPUSH
93909: CALL 95748 0 3
// end ;
93913: GO 93811
93915: POP
93916: POP
// if enchidnas then
93917: LD_VAR 0 4
93921: IFFALSE 93988
// for i = 1 to enchidnas do
93923: LD_ADDR_VAR 0 11
93927: PUSH
93928: DOUBLE
93929: LD_INT 1
93931: DEC
93932: ST_TO_ADDR
93933: LD_VAR 0 4
93937: PUSH
93938: FOR_TO
93939: IFFALSE 93986
// begin hc_class = 13 ;
93941: LD_ADDR_OWVAR 28
93945: PUSH
93946: LD_INT 13
93948: ST_TO_ADDR
// hc_gallery =  ;
93949: LD_ADDR_OWVAR 33
93953: PUSH
93954: LD_STRING 
93956: ST_TO_ADDR
// animal := CreateHuman ;
93957: LD_ADDR_VAR 0 12
93961: PUSH
93962: CALL_OW 44
93966: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93967: LD_VAR 0 12
93971: PPUSH
93972: LD_VAR 0 8
93976: PPUSH
93977: LD_INT 0
93979: PPUSH
93980: CALL 95748 0 3
// end ;
93984: GO 93938
93986: POP
93987: POP
// if fishes then
93988: LD_VAR 0 7
93992: IFFALSE 94059
// for i = 1 to fishes do
93994: LD_ADDR_VAR 0 11
93998: PUSH
93999: DOUBLE
94000: LD_INT 1
94002: DEC
94003: ST_TO_ADDR
94004: LD_VAR 0 7
94008: PUSH
94009: FOR_TO
94010: IFFALSE 94057
// begin hc_class = 20 ;
94012: LD_ADDR_OWVAR 28
94016: PUSH
94017: LD_INT 20
94019: ST_TO_ADDR
// hc_gallery =  ;
94020: LD_ADDR_OWVAR 33
94024: PUSH
94025: LD_STRING 
94027: ST_TO_ADDR
// animal := CreateHuman ;
94028: LD_ADDR_VAR 0 12
94032: PUSH
94033: CALL_OW 44
94037: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
94038: LD_VAR 0 12
94042: PPUSH
94043: LD_VAR 0 9
94047: PPUSH
94048: LD_INT 0
94050: PPUSH
94051: CALL 95748 0 3
// end ;
94055: GO 94009
94057: POP
94058: POP
// end ;
94059: LD_VAR 0 10
94063: RET
// export function WantHeal ( sci , unit ) ; begin
94064: LD_INT 0
94066: PPUSH
// if GetTaskList ( sci ) > 0 then
94067: LD_VAR 0 1
94071: PPUSH
94072: CALL_OW 437
94076: PUSH
94077: LD_INT 0
94079: GREATER
94080: IFFALSE 94150
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
94082: LD_VAR 0 1
94086: PPUSH
94087: CALL_OW 437
94091: PUSH
94092: LD_INT 1
94094: ARRAY
94095: PUSH
94096: LD_INT 1
94098: ARRAY
94099: PUSH
94100: LD_STRING l
94102: EQUAL
94103: PUSH
94104: LD_VAR 0 1
94108: PPUSH
94109: CALL_OW 437
94113: PUSH
94114: LD_INT 1
94116: ARRAY
94117: PUSH
94118: LD_INT 4
94120: ARRAY
94121: PUSH
94122: LD_VAR 0 2
94126: EQUAL
94127: AND
94128: IFFALSE 94140
// result := true else
94130: LD_ADDR_VAR 0 3
94134: PUSH
94135: LD_INT 1
94137: ST_TO_ADDR
94138: GO 94148
// result := false ;
94140: LD_ADDR_VAR 0 3
94144: PUSH
94145: LD_INT 0
94147: ST_TO_ADDR
// end else
94148: GO 94158
// result := false ;
94150: LD_ADDR_VAR 0 3
94154: PUSH
94155: LD_INT 0
94157: ST_TO_ADDR
// end ;
94158: LD_VAR 0 3
94162: RET
// export function HealTarget ( sci ) ; begin
94163: LD_INT 0
94165: PPUSH
// if not sci then
94166: LD_VAR 0 1
94170: NOT
94171: IFFALSE 94175
// exit ;
94173: GO 94240
// result := 0 ;
94175: LD_ADDR_VAR 0 2
94179: PUSH
94180: LD_INT 0
94182: ST_TO_ADDR
// if GetTaskList ( sci ) then
94183: LD_VAR 0 1
94187: PPUSH
94188: CALL_OW 437
94192: IFFALSE 94240
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
94194: LD_VAR 0 1
94198: PPUSH
94199: CALL_OW 437
94203: PUSH
94204: LD_INT 1
94206: ARRAY
94207: PUSH
94208: LD_INT 1
94210: ARRAY
94211: PUSH
94212: LD_STRING l
94214: EQUAL
94215: IFFALSE 94240
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
94217: LD_ADDR_VAR 0 2
94221: PUSH
94222: LD_VAR 0 1
94226: PPUSH
94227: CALL_OW 437
94231: PUSH
94232: LD_INT 1
94234: ARRAY
94235: PUSH
94236: LD_INT 4
94238: ARRAY
94239: ST_TO_ADDR
// end ;
94240: LD_VAR 0 2
94244: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
94245: LD_INT 0
94247: PPUSH
94248: PPUSH
94249: PPUSH
94250: PPUSH
// if not base_units then
94251: LD_VAR 0 1
94255: NOT
94256: IFFALSE 94260
// exit ;
94258: GO 94347
// result := false ;
94260: LD_ADDR_VAR 0 2
94264: PUSH
94265: LD_INT 0
94267: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
94268: LD_ADDR_VAR 0 5
94272: PUSH
94273: LD_VAR 0 1
94277: PPUSH
94278: LD_INT 21
94280: PUSH
94281: LD_INT 3
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PPUSH
94288: CALL_OW 72
94292: ST_TO_ADDR
// if not tmp then
94293: LD_VAR 0 5
94297: NOT
94298: IFFALSE 94302
// exit ;
94300: GO 94347
// for i in tmp do
94302: LD_ADDR_VAR 0 3
94306: PUSH
94307: LD_VAR 0 5
94311: PUSH
94312: FOR_IN
94313: IFFALSE 94345
// begin result := EnemyInRange ( i , 22 ) ;
94315: LD_ADDR_VAR 0 2
94319: PUSH
94320: LD_VAR 0 3
94324: PPUSH
94325: LD_INT 22
94327: PPUSH
94328: CALL 92583 0 2
94332: ST_TO_ADDR
// if result then
94333: LD_VAR 0 2
94337: IFFALSE 94343
// exit ;
94339: POP
94340: POP
94341: GO 94347
// end ;
94343: GO 94312
94345: POP
94346: POP
// end ;
94347: LD_VAR 0 2
94351: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
94352: LD_INT 0
94354: PPUSH
94355: PPUSH
// if not units then
94356: LD_VAR 0 1
94360: NOT
94361: IFFALSE 94365
// exit ;
94363: GO 94435
// result := [ ] ;
94365: LD_ADDR_VAR 0 3
94369: PUSH
94370: EMPTY
94371: ST_TO_ADDR
// for i in units do
94372: LD_ADDR_VAR 0 4
94376: PUSH
94377: LD_VAR 0 1
94381: PUSH
94382: FOR_IN
94383: IFFALSE 94433
// if GetTag ( i ) = tag then
94385: LD_VAR 0 4
94389: PPUSH
94390: CALL_OW 110
94394: PUSH
94395: LD_VAR 0 2
94399: EQUAL
94400: IFFALSE 94431
// result := Insert ( result , result + 1 , i ) ;
94402: LD_ADDR_VAR 0 3
94406: PUSH
94407: LD_VAR 0 3
94411: PPUSH
94412: LD_VAR 0 3
94416: PUSH
94417: LD_INT 1
94419: PLUS
94420: PPUSH
94421: LD_VAR 0 4
94425: PPUSH
94426: CALL_OW 2
94430: ST_TO_ADDR
94431: GO 94382
94433: POP
94434: POP
// end ;
94435: LD_VAR 0 3
94439: RET
// export function IsDriver ( un ) ; begin
94440: LD_INT 0
94442: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
94443: LD_ADDR_VAR 0 2
94447: PUSH
94448: LD_VAR 0 1
94452: PUSH
94453: LD_INT 55
94455: PUSH
94456: EMPTY
94457: LIST
94458: PPUSH
94459: CALL_OW 69
94463: IN
94464: ST_TO_ADDR
// end ;
94465: LD_VAR 0 2
94469: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
94470: LD_INT 0
94472: PPUSH
94473: PPUSH
// list := [ ] ;
94474: LD_ADDR_VAR 0 5
94478: PUSH
94479: EMPTY
94480: ST_TO_ADDR
// case d of 0 :
94481: LD_VAR 0 3
94485: PUSH
94486: LD_INT 0
94488: DOUBLE
94489: EQUAL
94490: IFTRUE 94494
94492: GO 94627
94494: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
94495: LD_ADDR_VAR 0 5
94499: PUSH
94500: LD_VAR 0 1
94504: PUSH
94505: LD_INT 4
94507: MINUS
94508: PUSH
94509: LD_VAR 0 2
94513: PUSH
94514: LD_INT 4
94516: MINUS
94517: PUSH
94518: LD_INT 2
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: LIST
94525: PUSH
94526: LD_VAR 0 1
94530: PUSH
94531: LD_INT 3
94533: MINUS
94534: PUSH
94535: LD_VAR 0 2
94539: PUSH
94540: LD_INT 1
94542: PUSH
94543: EMPTY
94544: LIST
94545: LIST
94546: LIST
94547: PUSH
94548: LD_VAR 0 1
94552: PUSH
94553: LD_INT 4
94555: PLUS
94556: PUSH
94557: LD_VAR 0 2
94561: PUSH
94562: LD_INT 4
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: LIST
94569: PUSH
94570: LD_VAR 0 1
94574: PUSH
94575: LD_INT 3
94577: PLUS
94578: PUSH
94579: LD_VAR 0 2
94583: PUSH
94584: LD_INT 3
94586: PLUS
94587: PUSH
94588: LD_INT 5
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: LIST
94595: PUSH
94596: LD_VAR 0 1
94600: PUSH
94601: LD_VAR 0 2
94605: PUSH
94606: LD_INT 4
94608: PLUS
94609: PUSH
94610: LD_INT 0
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: LIST
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: ST_TO_ADDR
// end ; 1 :
94625: GO 95325
94627: LD_INT 1
94629: DOUBLE
94630: EQUAL
94631: IFTRUE 94635
94633: GO 94768
94635: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
94636: LD_ADDR_VAR 0 5
94640: PUSH
94641: LD_VAR 0 1
94645: PUSH
94646: LD_VAR 0 2
94650: PUSH
94651: LD_INT 4
94653: MINUS
94654: PUSH
94655: LD_INT 3
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: LIST
94662: PUSH
94663: LD_VAR 0 1
94667: PUSH
94668: LD_INT 3
94670: MINUS
94671: PUSH
94672: LD_VAR 0 2
94676: PUSH
94677: LD_INT 3
94679: MINUS
94680: PUSH
94681: LD_INT 2
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: LIST
94688: PUSH
94689: LD_VAR 0 1
94693: PUSH
94694: LD_INT 4
94696: MINUS
94697: PUSH
94698: LD_VAR 0 2
94702: PUSH
94703: LD_INT 1
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: LIST
94710: PUSH
94711: LD_VAR 0 1
94715: PUSH
94716: LD_VAR 0 2
94720: PUSH
94721: LD_INT 3
94723: PLUS
94724: PUSH
94725: LD_INT 0
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: LIST
94732: PUSH
94733: LD_VAR 0 1
94737: PUSH
94738: LD_INT 4
94740: PLUS
94741: PUSH
94742: LD_VAR 0 2
94746: PUSH
94747: LD_INT 4
94749: PLUS
94750: PUSH
94751: LD_INT 5
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: LIST
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: ST_TO_ADDR
// end ; 2 :
94766: GO 95325
94768: LD_INT 2
94770: DOUBLE
94771: EQUAL
94772: IFTRUE 94776
94774: GO 94905
94776: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
94777: LD_ADDR_VAR 0 5
94781: PUSH
94782: LD_VAR 0 1
94786: PUSH
94787: LD_VAR 0 2
94791: PUSH
94792: LD_INT 3
94794: MINUS
94795: PUSH
94796: LD_INT 3
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: LIST
94803: PUSH
94804: LD_VAR 0 1
94808: PUSH
94809: LD_INT 4
94811: PLUS
94812: PUSH
94813: LD_VAR 0 2
94817: PUSH
94818: LD_INT 4
94820: PUSH
94821: EMPTY
94822: LIST
94823: LIST
94824: LIST
94825: PUSH
94826: LD_VAR 0 1
94830: PUSH
94831: LD_VAR 0 2
94835: PUSH
94836: LD_INT 4
94838: PLUS
94839: PUSH
94840: LD_INT 0
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: LIST
94847: PUSH
94848: LD_VAR 0 1
94852: PUSH
94853: LD_INT 3
94855: MINUS
94856: PUSH
94857: LD_VAR 0 2
94861: PUSH
94862: LD_INT 1
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: LIST
94869: PUSH
94870: LD_VAR 0 1
94874: PUSH
94875: LD_INT 4
94877: MINUS
94878: PUSH
94879: LD_VAR 0 2
94883: PUSH
94884: LD_INT 4
94886: MINUS
94887: PUSH
94888: LD_INT 2
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: LIST
94895: PUSH
94896: EMPTY
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: ST_TO_ADDR
// end ; 3 :
94903: GO 95325
94905: LD_INT 3
94907: DOUBLE
94908: EQUAL
94909: IFTRUE 94913
94911: GO 95046
94913: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
94914: LD_ADDR_VAR 0 5
94918: PUSH
94919: LD_VAR 0 1
94923: PUSH
94924: LD_INT 3
94926: PLUS
94927: PUSH
94928: LD_VAR 0 2
94932: PUSH
94933: LD_INT 4
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: LIST
94940: PUSH
94941: LD_VAR 0 1
94945: PUSH
94946: LD_INT 4
94948: PLUS
94949: PUSH
94950: LD_VAR 0 2
94954: PUSH
94955: LD_INT 4
94957: PLUS
94958: PUSH
94959: LD_INT 5
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: LIST
94966: PUSH
94967: LD_VAR 0 1
94971: PUSH
94972: LD_INT 4
94974: MINUS
94975: PUSH
94976: LD_VAR 0 2
94980: PUSH
94981: LD_INT 1
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: LIST
94988: PUSH
94989: LD_VAR 0 1
94993: PUSH
94994: LD_VAR 0 2
94998: PUSH
94999: LD_INT 4
95001: MINUS
95002: PUSH
95003: LD_INT 3
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: LIST
95010: PUSH
95011: LD_VAR 0 1
95015: PUSH
95016: LD_INT 3
95018: MINUS
95019: PUSH
95020: LD_VAR 0 2
95024: PUSH
95025: LD_INT 3
95027: MINUS
95028: PUSH
95029: LD_INT 2
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: LIST
95036: PUSH
95037: EMPTY
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: ST_TO_ADDR
// end ; 4 :
95044: GO 95325
95046: LD_INT 4
95048: DOUBLE
95049: EQUAL
95050: IFTRUE 95054
95052: GO 95187
95054: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
95055: LD_ADDR_VAR 0 5
95059: PUSH
95060: LD_VAR 0 1
95064: PUSH
95065: LD_VAR 0 2
95069: PUSH
95070: LD_INT 4
95072: PLUS
95073: PUSH
95074: LD_INT 0
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: LIST
95081: PUSH
95082: LD_VAR 0 1
95086: PUSH
95087: LD_INT 3
95089: PLUS
95090: PUSH
95091: LD_VAR 0 2
95095: PUSH
95096: LD_INT 3
95098: PLUS
95099: PUSH
95100: LD_INT 5
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: LIST
95107: PUSH
95108: LD_VAR 0 1
95112: PUSH
95113: LD_INT 4
95115: PLUS
95116: PUSH
95117: LD_VAR 0 2
95121: PUSH
95122: LD_INT 4
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: LIST
95129: PUSH
95130: LD_VAR 0 1
95134: PUSH
95135: LD_VAR 0 2
95139: PUSH
95140: LD_INT 3
95142: MINUS
95143: PUSH
95144: LD_INT 3
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: LIST
95151: PUSH
95152: LD_VAR 0 1
95156: PUSH
95157: LD_INT 4
95159: MINUS
95160: PUSH
95161: LD_VAR 0 2
95165: PUSH
95166: LD_INT 4
95168: MINUS
95169: PUSH
95170: LD_INT 2
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: LIST
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: ST_TO_ADDR
// end ; 5 :
95185: GO 95325
95187: LD_INT 5
95189: DOUBLE
95190: EQUAL
95191: IFTRUE 95195
95193: GO 95324
95195: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
95196: LD_ADDR_VAR 0 5
95200: PUSH
95201: LD_VAR 0 1
95205: PUSH
95206: LD_INT 4
95208: MINUS
95209: PUSH
95210: LD_VAR 0 2
95214: PUSH
95215: LD_INT 1
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: LIST
95222: PUSH
95223: LD_VAR 0 1
95227: PUSH
95228: LD_VAR 0 2
95232: PUSH
95233: LD_INT 4
95235: MINUS
95236: PUSH
95237: LD_INT 3
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: LIST
95244: PUSH
95245: LD_VAR 0 1
95249: PUSH
95250: LD_INT 4
95252: PLUS
95253: PUSH
95254: LD_VAR 0 2
95258: PUSH
95259: LD_INT 4
95261: PLUS
95262: PUSH
95263: LD_INT 5
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: LIST
95270: PUSH
95271: LD_VAR 0 1
95275: PUSH
95276: LD_INT 3
95278: PLUS
95279: PUSH
95280: LD_VAR 0 2
95284: PUSH
95285: LD_INT 4
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: LIST
95292: PUSH
95293: LD_VAR 0 1
95297: PUSH
95298: LD_VAR 0 2
95302: PUSH
95303: LD_INT 3
95305: PLUS
95306: PUSH
95307: LD_INT 0
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: LIST
95314: PUSH
95315: EMPTY
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: ST_TO_ADDR
// end ; end ;
95322: GO 95325
95324: POP
// result := list ;
95325: LD_ADDR_VAR 0 4
95329: PUSH
95330: LD_VAR 0 5
95334: ST_TO_ADDR
// end ;
95335: LD_VAR 0 4
95339: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
95340: LD_INT 0
95342: PPUSH
95343: PPUSH
95344: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
95345: LD_VAR 0 1
95349: NOT
95350: PUSH
95351: LD_VAR 0 2
95355: PUSH
95356: LD_INT 1
95358: PUSH
95359: LD_INT 2
95361: PUSH
95362: LD_INT 3
95364: PUSH
95365: LD_INT 4
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: IN
95374: NOT
95375: OR
95376: IFFALSE 95380
// exit ;
95378: GO 95472
// tmp := [ ] ;
95380: LD_ADDR_VAR 0 5
95384: PUSH
95385: EMPTY
95386: ST_TO_ADDR
// for i in units do
95387: LD_ADDR_VAR 0 4
95391: PUSH
95392: LD_VAR 0 1
95396: PUSH
95397: FOR_IN
95398: IFFALSE 95441
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
95400: LD_ADDR_VAR 0 5
95404: PUSH
95405: LD_VAR 0 5
95409: PPUSH
95410: LD_VAR 0 5
95414: PUSH
95415: LD_INT 1
95417: PLUS
95418: PPUSH
95419: LD_VAR 0 4
95423: PPUSH
95424: LD_VAR 0 2
95428: PPUSH
95429: CALL_OW 259
95433: PPUSH
95434: CALL_OW 2
95438: ST_TO_ADDR
95439: GO 95397
95441: POP
95442: POP
// if not tmp then
95443: LD_VAR 0 5
95447: NOT
95448: IFFALSE 95452
// exit ;
95450: GO 95472
// result := SortListByListDesc ( units , tmp ) ;
95452: LD_ADDR_VAR 0 3
95456: PUSH
95457: LD_VAR 0 1
95461: PPUSH
95462: LD_VAR 0 5
95466: PPUSH
95467: CALL_OW 77
95471: ST_TO_ADDR
// end ;
95472: LD_VAR 0 3
95476: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
95477: LD_INT 0
95479: PPUSH
95480: PPUSH
95481: PPUSH
// result := false ;
95482: LD_ADDR_VAR 0 3
95486: PUSH
95487: LD_INT 0
95489: ST_TO_ADDR
// x := GetX ( building ) ;
95490: LD_ADDR_VAR 0 4
95494: PUSH
95495: LD_VAR 0 2
95499: PPUSH
95500: CALL_OW 250
95504: ST_TO_ADDR
// y := GetY ( building ) ;
95505: LD_ADDR_VAR 0 5
95509: PUSH
95510: LD_VAR 0 2
95514: PPUSH
95515: CALL_OW 251
95519: ST_TO_ADDR
// if not building or not x or not y then
95520: LD_VAR 0 2
95524: NOT
95525: PUSH
95526: LD_VAR 0 4
95530: NOT
95531: OR
95532: PUSH
95533: LD_VAR 0 5
95537: NOT
95538: OR
95539: IFFALSE 95543
// exit ;
95541: GO 95635
// if GetTaskList ( unit ) then
95543: LD_VAR 0 1
95547: PPUSH
95548: CALL_OW 437
95552: IFFALSE 95635
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95554: LD_STRING e
95556: PUSH
95557: LD_VAR 0 1
95561: PPUSH
95562: CALL_OW 437
95566: PUSH
95567: LD_INT 1
95569: ARRAY
95570: PUSH
95571: LD_INT 1
95573: ARRAY
95574: EQUAL
95575: PUSH
95576: LD_VAR 0 4
95580: PUSH
95581: LD_VAR 0 1
95585: PPUSH
95586: CALL_OW 437
95590: PUSH
95591: LD_INT 1
95593: ARRAY
95594: PUSH
95595: LD_INT 2
95597: ARRAY
95598: EQUAL
95599: AND
95600: PUSH
95601: LD_VAR 0 5
95605: PUSH
95606: LD_VAR 0 1
95610: PPUSH
95611: CALL_OW 437
95615: PUSH
95616: LD_INT 1
95618: ARRAY
95619: PUSH
95620: LD_INT 3
95622: ARRAY
95623: EQUAL
95624: AND
95625: IFFALSE 95635
// result := true end ;
95627: LD_ADDR_VAR 0 3
95631: PUSH
95632: LD_INT 1
95634: ST_TO_ADDR
// end ;
95635: LD_VAR 0 3
95639: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
95640: LD_INT 0
95642: PPUSH
// result := false ;
95643: LD_ADDR_VAR 0 4
95647: PUSH
95648: LD_INT 0
95650: ST_TO_ADDR
// if GetTaskList ( unit ) then
95651: LD_VAR 0 1
95655: PPUSH
95656: CALL_OW 437
95660: IFFALSE 95743
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
95662: LD_STRING M
95664: PUSH
95665: LD_VAR 0 1
95669: PPUSH
95670: CALL_OW 437
95674: PUSH
95675: LD_INT 1
95677: ARRAY
95678: PUSH
95679: LD_INT 1
95681: ARRAY
95682: EQUAL
95683: PUSH
95684: LD_VAR 0 2
95688: PUSH
95689: LD_VAR 0 1
95693: PPUSH
95694: CALL_OW 437
95698: PUSH
95699: LD_INT 1
95701: ARRAY
95702: PUSH
95703: LD_INT 2
95705: ARRAY
95706: EQUAL
95707: AND
95708: PUSH
95709: LD_VAR 0 3
95713: PUSH
95714: LD_VAR 0 1
95718: PPUSH
95719: CALL_OW 437
95723: PUSH
95724: LD_INT 1
95726: ARRAY
95727: PUSH
95728: LD_INT 3
95730: ARRAY
95731: EQUAL
95732: AND
95733: IFFALSE 95743
// result := true ;
95735: LD_ADDR_VAR 0 4
95739: PUSH
95740: LD_INT 1
95742: ST_TO_ADDR
// end ; end ;
95743: LD_VAR 0 4
95747: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
95748: LD_INT 0
95750: PPUSH
95751: PPUSH
95752: PPUSH
95753: PPUSH
// if not unit or not area then
95754: LD_VAR 0 1
95758: NOT
95759: PUSH
95760: LD_VAR 0 2
95764: NOT
95765: OR
95766: IFFALSE 95770
// exit ;
95768: GO 95934
// tmp := AreaToList ( area , i ) ;
95770: LD_ADDR_VAR 0 6
95774: PUSH
95775: LD_VAR 0 2
95779: PPUSH
95780: LD_VAR 0 5
95784: PPUSH
95785: CALL_OW 517
95789: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
95790: LD_ADDR_VAR 0 5
95794: PUSH
95795: DOUBLE
95796: LD_INT 1
95798: DEC
95799: ST_TO_ADDR
95800: LD_VAR 0 6
95804: PUSH
95805: LD_INT 1
95807: ARRAY
95808: PUSH
95809: FOR_TO
95810: IFFALSE 95932
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
95812: LD_ADDR_VAR 0 7
95816: PUSH
95817: LD_VAR 0 6
95821: PUSH
95822: LD_INT 1
95824: ARRAY
95825: PUSH
95826: LD_VAR 0 5
95830: ARRAY
95831: PUSH
95832: LD_VAR 0 6
95836: PUSH
95837: LD_INT 2
95839: ARRAY
95840: PUSH
95841: LD_VAR 0 5
95845: ARRAY
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
95851: LD_VAR 0 7
95855: PUSH
95856: LD_INT 1
95858: ARRAY
95859: PPUSH
95860: LD_VAR 0 7
95864: PUSH
95865: LD_INT 2
95867: ARRAY
95868: PPUSH
95869: CALL_OW 428
95873: PUSH
95874: LD_INT 0
95876: EQUAL
95877: IFFALSE 95930
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
95879: LD_VAR 0 1
95883: PPUSH
95884: LD_VAR 0 7
95888: PUSH
95889: LD_INT 1
95891: ARRAY
95892: PPUSH
95893: LD_VAR 0 7
95897: PUSH
95898: LD_INT 2
95900: ARRAY
95901: PPUSH
95902: LD_VAR 0 3
95906: PPUSH
95907: CALL_OW 48
// result := IsPlaced ( unit ) ;
95911: LD_ADDR_VAR 0 4
95915: PUSH
95916: LD_VAR 0 1
95920: PPUSH
95921: CALL_OW 305
95925: ST_TO_ADDR
// exit ;
95926: POP
95927: POP
95928: GO 95934
// end ; end ;
95930: GO 95809
95932: POP
95933: POP
// end ;
95934: LD_VAR 0 4
95938: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
95939: LD_INT 0
95941: PPUSH
95942: PPUSH
95943: PPUSH
// if not side or side > 8 then
95944: LD_VAR 0 1
95948: NOT
95949: PUSH
95950: LD_VAR 0 1
95954: PUSH
95955: LD_INT 8
95957: GREATER
95958: OR
95959: IFFALSE 95963
// exit ;
95961: GO 96150
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
95963: LD_ADDR_VAR 0 4
95967: PUSH
95968: LD_INT 22
95970: PUSH
95971: LD_VAR 0 1
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PUSH
95980: LD_INT 21
95982: PUSH
95983: LD_INT 3
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PPUSH
95994: CALL_OW 69
95998: ST_TO_ADDR
// if not tmp then
95999: LD_VAR 0 4
96003: NOT
96004: IFFALSE 96008
// exit ;
96006: GO 96150
// enable_addtolog := true ;
96008: LD_ADDR_OWVAR 81
96012: PUSH
96013: LD_INT 1
96015: ST_TO_ADDR
// AddToLog ( [ ) ;
96016: LD_STRING [
96018: PPUSH
96019: CALL_OW 561
// for i in tmp do
96023: LD_ADDR_VAR 0 3
96027: PUSH
96028: LD_VAR 0 4
96032: PUSH
96033: FOR_IN
96034: IFFALSE 96141
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
96036: LD_STRING [
96038: PUSH
96039: LD_VAR 0 3
96043: PPUSH
96044: CALL_OW 266
96048: STR
96049: PUSH
96050: LD_STRING , 
96052: STR
96053: PUSH
96054: LD_VAR 0 3
96058: PPUSH
96059: CALL_OW 250
96063: STR
96064: PUSH
96065: LD_STRING , 
96067: STR
96068: PUSH
96069: LD_VAR 0 3
96073: PPUSH
96074: CALL_OW 251
96078: STR
96079: PUSH
96080: LD_STRING , 
96082: STR
96083: PUSH
96084: LD_VAR 0 3
96088: PPUSH
96089: CALL_OW 254
96093: STR
96094: PUSH
96095: LD_STRING , 
96097: STR
96098: PUSH
96099: LD_VAR 0 3
96103: PPUSH
96104: LD_INT 1
96106: PPUSH
96107: CALL_OW 268
96111: STR
96112: PUSH
96113: LD_STRING , 
96115: STR
96116: PUSH
96117: LD_VAR 0 3
96121: PPUSH
96122: LD_INT 2
96124: PPUSH
96125: CALL_OW 268
96129: STR
96130: PUSH
96131: LD_STRING ],
96133: STR
96134: PPUSH
96135: CALL_OW 561
// end ;
96139: GO 96033
96141: POP
96142: POP
// AddToLog ( ]; ) ;
96143: LD_STRING ];
96145: PPUSH
96146: CALL_OW 561
// end ;
96150: LD_VAR 0 2
96154: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
96155: LD_INT 0
96157: PPUSH
96158: PPUSH
96159: PPUSH
96160: PPUSH
96161: PPUSH
// if not area or not rate or not max then
96162: LD_VAR 0 1
96166: NOT
96167: PUSH
96168: LD_VAR 0 2
96172: NOT
96173: OR
96174: PUSH
96175: LD_VAR 0 4
96179: NOT
96180: OR
96181: IFFALSE 96185
// exit ;
96183: GO 96377
// while 1 do
96185: LD_INT 1
96187: IFFALSE 96377
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
96189: LD_ADDR_VAR 0 9
96193: PUSH
96194: LD_VAR 0 1
96198: PPUSH
96199: LD_INT 1
96201: PPUSH
96202: CALL_OW 287
96206: PUSH
96207: LD_INT 10
96209: MUL
96210: ST_TO_ADDR
// r := rate / 10 ;
96211: LD_ADDR_VAR 0 7
96215: PUSH
96216: LD_VAR 0 2
96220: PUSH
96221: LD_INT 10
96223: DIVREAL
96224: ST_TO_ADDR
// time := 1 1$00 ;
96225: LD_ADDR_VAR 0 8
96229: PUSH
96230: LD_INT 2100
96232: ST_TO_ADDR
// if amount < min then
96233: LD_VAR 0 9
96237: PUSH
96238: LD_VAR 0 3
96242: LESS
96243: IFFALSE 96261
// r := r * 2 else
96245: LD_ADDR_VAR 0 7
96249: PUSH
96250: LD_VAR 0 7
96254: PUSH
96255: LD_INT 2
96257: MUL
96258: ST_TO_ADDR
96259: GO 96287
// if amount > max then
96261: LD_VAR 0 9
96265: PUSH
96266: LD_VAR 0 4
96270: GREATER
96271: IFFALSE 96287
// r := r / 2 ;
96273: LD_ADDR_VAR 0 7
96277: PUSH
96278: LD_VAR 0 7
96282: PUSH
96283: LD_INT 2
96285: DIVREAL
96286: ST_TO_ADDR
// time := time / r ;
96287: LD_ADDR_VAR 0 8
96291: PUSH
96292: LD_VAR 0 8
96296: PUSH
96297: LD_VAR 0 7
96301: DIVREAL
96302: ST_TO_ADDR
// if time < 0 then
96303: LD_VAR 0 8
96307: PUSH
96308: LD_INT 0
96310: LESS
96311: IFFALSE 96328
// time := time * - 1 ;
96313: LD_ADDR_VAR 0 8
96317: PUSH
96318: LD_VAR 0 8
96322: PUSH
96323: LD_INT 1
96325: NEG
96326: MUL
96327: ST_TO_ADDR
// wait ( time ) ;
96328: LD_VAR 0 8
96332: PPUSH
96333: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
96337: LD_INT 35
96339: PPUSH
96340: LD_INT 875
96342: PPUSH
96343: CALL_OW 12
96347: PPUSH
96348: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
96352: LD_INT 1
96354: PPUSH
96355: LD_INT 5
96357: PPUSH
96358: CALL_OW 12
96362: PPUSH
96363: LD_VAR 0 1
96367: PPUSH
96368: LD_INT 1
96370: PPUSH
96371: CALL_OW 55
// end ;
96375: GO 96185
// end ;
96377: LD_VAR 0 5
96381: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
96382: LD_INT 0
96384: PPUSH
96385: PPUSH
96386: PPUSH
96387: PPUSH
96388: PPUSH
96389: PPUSH
96390: PPUSH
96391: PPUSH
// if not turrets or not factories then
96392: LD_VAR 0 1
96396: NOT
96397: PUSH
96398: LD_VAR 0 2
96402: NOT
96403: OR
96404: IFFALSE 96408
// exit ;
96406: GO 96715
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
96408: LD_ADDR_VAR 0 10
96412: PUSH
96413: LD_INT 5
96415: PUSH
96416: LD_INT 6
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PUSH
96423: LD_INT 2
96425: PUSH
96426: LD_INT 4
96428: PUSH
96429: EMPTY
96430: LIST
96431: LIST
96432: PUSH
96433: LD_INT 3
96435: PUSH
96436: LD_INT 5
96438: PUSH
96439: EMPTY
96440: LIST
96441: LIST
96442: PUSH
96443: EMPTY
96444: LIST
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 24
96450: PUSH
96451: LD_INT 25
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_INT 23
96460: PUSH
96461: LD_INT 27
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: PUSH
96472: LD_INT 42
96474: PUSH
96475: LD_INT 43
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 44
96484: PUSH
96485: LD_INT 46
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 45
96494: PUSH
96495: LD_INT 47
96497: PUSH
96498: EMPTY
96499: LIST
96500: LIST
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: LIST
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: LIST
96511: ST_TO_ADDR
// result := [ ] ;
96512: LD_ADDR_VAR 0 3
96516: PUSH
96517: EMPTY
96518: ST_TO_ADDR
// for i in turrets do
96519: LD_ADDR_VAR 0 4
96523: PUSH
96524: LD_VAR 0 1
96528: PUSH
96529: FOR_IN
96530: IFFALSE 96713
// begin nat := GetNation ( i ) ;
96532: LD_ADDR_VAR 0 7
96536: PUSH
96537: LD_VAR 0 4
96541: PPUSH
96542: CALL_OW 248
96546: ST_TO_ADDR
// weapon := 0 ;
96547: LD_ADDR_VAR 0 8
96551: PUSH
96552: LD_INT 0
96554: ST_TO_ADDR
// if not nat then
96555: LD_VAR 0 7
96559: NOT
96560: IFFALSE 96564
// continue ;
96562: GO 96529
// for j in list [ nat ] do
96564: LD_ADDR_VAR 0 5
96568: PUSH
96569: LD_VAR 0 10
96573: PUSH
96574: LD_VAR 0 7
96578: ARRAY
96579: PUSH
96580: FOR_IN
96581: IFFALSE 96622
// if GetBWeapon ( i ) = j [ 1 ] then
96583: LD_VAR 0 4
96587: PPUSH
96588: CALL_OW 269
96592: PUSH
96593: LD_VAR 0 5
96597: PUSH
96598: LD_INT 1
96600: ARRAY
96601: EQUAL
96602: IFFALSE 96620
// begin weapon := j [ 2 ] ;
96604: LD_ADDR_VAR 0 8
96608: PUSH
96609: LD_VAR 0 5
96613: PUSH
96614: LD_INT 2
96616: ARRAY
96617: ST_TO_ADDR
// break ;
96618: GO 96622
// end ;
96620: GO 96580
96622: POP
96623: POP
// if not weapon then
96624: LD_VAR 0 8
96628: NOT
96629: IFFALSE 96633
// continue ;
96631: GO 96529
// for k in factories do
96633: LD_ADDR_VAR 0 6
96637: PUSH
96638: LD_VAR 0 2
96642: PUSH
96643: FOR_IN
96644: IFFALSE 96709
// begin weapons := AvailableWeaponList ( k ) ;
96646: LD_ADDR_VAR 0 9
96650: PUSH
96651: LD_VAR 0 6
96655: PPUSH
96656: CALL_OW 478
96660: ST_TO_ADDR
// if not weapons then
96661: LD_VAR 0 9
96665: NOT
96666: IFFALSE 96670
// continue ;
96668: GO 96643
// if weapon in weapons then
96670: LD_VAR 0 8
96674: PUSH
96675: LD_VAR 0 9
96679: IN
96680: IFFALSE 96707
// begin result := [ i , weapon ] ;
96682: LD_ADDR_VAR 0 3
96686: PUSH
96687: LD_VAR 0 4
96691: PUSH
96692: LD_VAR 0 8
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: ST_TO_ADDR
// exit ;
96701: POP
96702: POP
96703: POP
96704: POP
96705: GO 96715
// end ; end ;
96707: GO 96643
96709: POP
96710: POP
// end ;
96711: GO 96529
96713: POP
96714: POP
// end ;
96715: LD_VAR 0 3
96719: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
96720: LD_INT 0
96722: PPUSH
// if not side or side > 8 then
96723: LD_VAR 0 3
96727: NOT
96728: PUSH
96729: LD_VAR 0 3
96733: PUSH
96734: LD_INT 8
96736: GREATER
96737: OR
96738: IFFALSE 96742
// exit ;
96740: GO 96801
// if not range then
96742: LD_VAR 0 4
96746: NOT
96747: IFFALSE 96758
// range := - 12 ;
96749: LD_ADDR_VAR 0 4
96753: PUSH
96754: LD_INT 12
96756: NEG
96757: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
96758: LD_VAR 0 1
96762: PPUSH
96763: LD_VAR 0 2
96767: PPUSH
96768: LD_VAR 0 3
96772: PPUSH
96773: LD_VAR 0 4
96777: PPUSH
96778: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
96782: LD_VAR 0 1
96786: PPUSH
96787: LD_VAR 0 2
96791: PPUSH
96792: LD_VAR 0 3
96796: PPUSH
96797: CALL_OW 331
// end ;
96801: LD_VAR 0 5
96805: RET
// export function Video ( mode ) ; begin
96806: LD_INT 0
96808: PPUSH
// ingame_video = mode ;
96809: LD_ADDR_OWVAR 52
96813: PUSH
96814: LD_VAR 0 1
96818: ST_TO_ADDR
// interface_hidden = mode ;
96819: LD_ADDR_OWVAR 54
96823: PUSH
96824: LD_VAR 0 1
96828: ST_TO_ADDR
// end ;
96829: LD_VAR 0 2
96833: RET
// export function Join ( array , element ) ; begin
96834: LD_INT 0
96836: PPUSH
// result := Replace ( array , array + 1 , element ) ;
96837: LD_ADDR_VAR 0 3
96841: PUSH
96842: LD_VAR 0 1
96846: PPUSH
96847: LD_VAR 0 1
96851: PUSH
96852: LD_INT 1
96854: PLUS
96855: PPUSH
96856: LD_VAR 0 2
96860: PPUSH
96861: CALL_OW 1
96865: ST_TO_ADDR
// end ;
96866: LD_VAR 0 3
96870: RET
// export function JoinUnion ( array , element ) ; begin
96871: LD_INT 0
96873: PPUSH
// result := array union element ;
96874: LD_ADDR_VAR 0 3
96878: PUSH
96879: LD_VAR 0 1
96883: PUSH
96884: LD_VAR 0 2
96888: UNION
96889: ST_TO_ADDR
// end ;
96890: LD_VAR 0 3
96894: RET
// export function GetBehemoths ( side ) ; begin
96895: LD_INT 0
96897: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
96898: LD_ADDR_VAR 0 2
96902: PUSH
96903: LD_INT 22
96905: PUSH
96906: LD_VAR 0 1
96910: PUSH
96911: EMPTY
96912: LIST
96913: LIST
96914: PUSH
96915: LD_INT 31
96917: PUSH
96918: LD_INT 25
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: PPUSH
96929: CALL_OW 69
96933: ST_TO_ADDR
// end ;
96934: LD_VAR 0 2
96938: RET
// export function Shuffle ( array ) ; var i , index ; begin
96939: LD_INT 0
96941: PPUSH
96942: PPUSH
96943: PPUSH
// result := [ ] ;
96944: LD_ADDR_VAR 0 2
96948: PUSH
96949: EMPTY
96950: ST_TO_ADDR
// if not array then
96951: LD_VAR 0 1
96955: NOT
96956: IFFALSE 96960
// exit ;
96958: GO 97059
// Randomize ;
96960: CALL_OW 10
// for i = array downto 1 do
96964: LD_ADDR_VAR 0 3
96968: PUSH
96969: DOUBLE
96970: LD_VAR 0 1
96974: INC
96975: ST_TO_ADDR
96976: LD_INT 1
96978: PUSH
96979: FOR_DOWNTO
96980: IFFALSE 97057
// begin index := rand ( 1 , array ) ;
96982: LD_ADDR_VAR 0 4
96986: PUSH
96987: LD_INT 1
96989: PPUSH
96990: LD_VAR 0 1
96994: PPUSH
96995: CALL_OW 12
96999: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
97000: LD_ADDR_VAR 0 2
97004: PUSH
97005: LD_VAR 0 2
97009: PPUSH
97010: LD_VAR 0 2
97014: PUSH
97015: LD_INT 1
97017: PLUS
97018: PPUSH
97019: LD_VAR 0 1
97023: PUSH
97024: LD_VAR 0 4
97028: ARRAY
97029: PPUSH
97030: CALL_OW 2
97034: ST_TO_ADDR
// array := Delete ( array , index ) ;
97035: LD_ADDR_VAR 0 1
97039: PUSH
97040: LD_VAR 0 1
97044: PPUSH
97045: LD_VAR 0 4
97049: PPUSH
97050: CALL_OW 3
97054: ST_TO_ADDR
// end ;
97055: GO 96979
97057: POP
97058: POP
// end ;
97059: LD_VAR 0 2
97063: RET
// export function GetBaseMaterials ( base ) ; begin
97064: LD_INT 0
97066: PPUSH
// result := [ 0 , 0 , 0 ] ;
97067: LD_ADDR_VAR 0 2
97071: PUSH
97072: LD_INT 0
97074: PUSH
97075: LD_INT 0
97077: PUSH
97078: LD_INT 0
97080: PUSH
97081: EMPTY
97082: LIST
97083: LIST
97084: LIST
97085: ST_TO_ADDR
// if not base then
97086: LD_VAR 0 1
97090: NOT
97091: IFFALSE 97095
// exit ;
97093: GO 97144
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
97095: LD_ADDR_VAR 0 2
97099: PUSH
97100: LD_VAR 0 1
97104: PPUSH
97105: LD_INT 1
97107: PPUSH
97108: CALL_OW 275
97112: PUSH
97113: LD_VAR 0 1
97117: PPUSH
97118: LD_INT 2
97120: PPUSH
97121: CALL_OW 275
97125: PUSH
97126: LD_VAR 0 1
97130: PPUSH
97131: LD_INT 3
97133: PPUSH
97134: CALL_OW 275
97138: PUSH
97139: EMPTY
97140: LIST
97141: LIST
97142: LIST
97143: ST_TO_ADDR
// end ;
97144: LD_VAR 0 2
97148: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
97149: LD_INT 0
97151: PPUSH
97152: PPUSH
// result := array ;
97153: LD_ADDR_VAR 0 3
97157: PUSH
97158: LD_VAR 0 1
97162: ST_TO_ADDR
// if size > 0 then
97163: LD_VAR 0 2
97167: PUSH
97168: LD_INT 0
97170: GREATER
97171: IFFALSE 97217
// for i := array downto size do
97173: LD_ADDR_VAR 0 4
97177: PUSH
97178: DOUBLE
97179: LD_VAR 0 1
97183: INC
97184: ST_TO_ADDR
97185: LD_VAR 0 2
97189: PUSH
97190: FOR_DOWNTO
97191: IFFALSE 97215
// result := Delete ( result , result ) ;
97193: LD_ADDR_VAR 0 3
97197: PUSH
97198: LD_VAR 0 3
97202: PPUSH
97203: LD_VAR 0 3
97207: PPUSH
97208: CALL_OW 3
97212: ST_TO_ADDR
97213: GO 97190
97215: POP
97216: POP
// end ;
97217: LD_VAR 0 3
97221: RET
// export function ComExit ( unit ) ; var tmp ; begin
97222: LD_INT 0
97224: PPUSH
97225: PPUSH
// if not IsInUnit ( unit ) then
97226: LD_VAR 0 1
97230: PPUSH
97231: CALL_OW 310
97235: NOT
97236: IFFALSE 97240
// exit ;
97238: GO 97300
// tmp := IsInUnit ( unit ) ;
97240: LD_ADDR_VAR 0 3
97244: PUSH
97245: LD_VAR 0 1
97249: PPUSH
97250: CALL_OW 310
97254: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
97255: LD_VAR 0 3
97259: PPUSH
97260: CALL_OW 247
97264: PUSH
97265: LD_INT 2
97267: EQUAL
97268: IFFALSE 97281
// ComExitVehicle ( unit ) else
97270: LD_VAR 0 1
97274: PPUSH
97275: CALL_OW 121
97279: GO 97290
// ComExitBuilding ( unit ) ;
97281: LD_VAR 0 1
97285: PPUSH
97286: CALL_OW 122
// result := tmp ;
97290: LD_ADDR_VAR 0 2
97294: PUSH
97295: LD_VAR 0 3
97299: ST_TO_ADDR
// end ;
97300: LD_VAR 0 2
97304: RET
// export function ComExitAll ( units ) ; var i ; begin
97305: LD_INT 0
97307: PPUSH
97308: PPUSH
// if not units then
97309: LD_VAR 0 1
97313: NOT
97314: IFFALSE 97318
// exit ;
97316: GO 97344
// for i in units do
97318: LD_ADDR_VAR 0 3
97322: PUSH
97323: LD_VAR 0 1
97327: PUSH
97328: FOR_IN
97329: IFFALSE 97342
// ComExit ( i ) ;
97331: LD_VAR 0 3
97335: PPUSH
97336: CALL 97222 0 1
97340: GO 97328
97342: POP
97343: POP
// end ;
97344: LD_VAR 0 2
97348: RET
// export function ResetHc ; begin
97349: LD_INT 0
97351: PPUSH
// InitHc ;
97352: CALL_OW 19
// hc_importance := 0 ;
97356: LD_ADDR_OWVAR 32
97360: PUSH
97361: LD_INT 0
97363: ST_TO_ADDR
// end ;
97364: LD_VAR 0 1
97368: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
97369: LD_INT 0
97371: PPUSH
97372: PPUSH
97373: PPUSH
// _x := ( x1 + x2 ) div 2 ;
97374: LD_ADDR_VAR 0 6
97378: PUSH
97379: LD_VAR 0 1
97383: PUSH
97384: LD_VAR 0 3
97388: PLUS
97389: PUSH
97390: LD_INT 2
97392: DIV
97393: ST_TO_ADDR
// if _x < 0 then
97394: LD_VAR 0 6
97398: PUSH
97399: LD_INT 0
97401: LESS
97402: IFFALSE 97419
// _x := _x * - 1 ;
97404: LD_ADDR_VAR 0 6
97408: PUSH
97409: LD_VAR 0 6
97413: PUSH
97414: LD_INT 1
97416: NEG
97417: MUL
97418: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
97419: LD_ADDR_VAR 0 7
97423: PUSH
97424: LD_VAR 0 2
97428: PUSH
97429: LD_VAR 0 4
97433: PLUS
97434: PUSH
97435: LD_INT 2
97437: DIV
97438: ST_TO_ADDR
// if _y < 0 then
97439: LD_VAR 0 7
97443: PUSH
97444: LD_INT 0
97446: LESS
97447: IFFALSE 97464
// _y := _y * - 1 ;
97449: LD_ADDR_VAR 0 7
97453: PUSH
97454: LD_VAR 0 7
97458: PUSH
97459: LD_INT 1
97461: NEG
97462: MUL
97463: ST_TO_ADDR
// result := [ _x , _y ] ;
97464: LD_ADDR_VAR 0 5
97468: PUSH
97469: LD_VAR 0 6
97473: PUSH
97474: LD_VAR 0 7
97478: PUSH
97479: EMPTY
97480: LIST
97481: LIST
97482: ST_TO_ADDR
// end ;
97483: LD_VAR 0 5
97487: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
97488: LD_INT 0
97490: PPUSH
97491: PPUSH
97492: PPUSH
97493: PPUSH
// task := GetTaskList ( unit ) ;
97494: LD_ADDR_VAR 0 7
97498: PUSH
97499: LD_VAR 0 1
97503: PPUSH
97504: CALL_OW 437
97508: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
97509: LD_VAR 0 7
97513: NOT
97514: PUSH
97515: LD_VAR 0 1
97519: PPUSH
97520: LD_VAR 0 2
97524: PPUSH
97525: CALL_OW 308
97529: NOT
97530: AND
97531: IFFALSE 97535
// exit ;
97533: GO 97653
// if IsInArea ( unit , area ) then
97535: LD_VAR 0 1
97539: PPUSH
97540: LD_VAR 0 2
97544: PPUSH
97545: CALL_OW 308
97549: IFFALSE 97567
// begin ComMoveToArea ( unit , goAway ) ;
97551: LD_VAR 0 1
97555: PPUSH
97556: LD_VAR 0 3
97560: PPUSH
97561: CALL_OW 113
// exit ;
97565: GO 97653
// end ; if task [ 1 ] [ 1 ] <> M then
97567: LD_VAR 0 7
97571: PUSH
97572: LD_INT 1
97574: ARRAY
97575: PUSH
97576: LD_INT 1
97578: ARRAY
97579: PUSH
97580: LD_STRING M
97582: NONEQUAL
97583: IFFALSE 97587
// exit ;
97585: GO 97653
// x := task [ 1 ] [ 2 ] ;
97587: LD_ADDR_VAR 0 5
97591: PUSH
97592: LD_VAR 0 7
97596: PUSH
97597: LD_INT 1
97599: ARRAY
97600: PUSH
97601: LD_INT 2
97603: ARRAY
97604: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
97605: LD_ADDR_VAR 0 6
97609: PUSH
97610: LD_VAR 0 7
97614: PUSH
97615: LD_INT 1
97617: ARRAY
97618: PUSH
97619: LD_INT 3
97621: ARRAY
97622: ST_TO_ADDR
// if InArea ( x , y , area ) then
97623: LD_VAR 0 5
97627: PPUSH
97628: LD_VAR 0 6
97632: PPUSH
97633: LD_VAR 0 2
97637: PPUSH
97638: CALL_OW 309
97642: IFFALSE 97653
// ComStop ( unit ) ;
97644: LD_VAR 0 1
97648: PPUSH
97649: CALL_OW 141
// end ;
97653: LD_VAR 0 4
97657: RET
// export function Abs ( value ) ; begin
97658: LD_INT 0
97660: PPUSH
// result := value ;
97661: LD_ADDR_VAR 0 2
97665: PUSH
97666: LD_VAR 0 1
97670: ST_TO_ADDR
// if value < 0 then
97671: LD_VAR 0 1
97675: PUSH
97676: LD_INT 0
97678: LESS
97679: IFFALSE 97696
// result := value * - 1 ;
97681: LD_ADDR_VAR 0 2
97685: PUSH
97686: LD_VAR 0 1
97690: PUSH
97691: LD_INT 1
97693: NEG
97694: MUL
97695: ST_TO_ADDR
// end ;
97696: LD_VAR 0 2
97700: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
97701: LD_INT 0
97703: PPUSH
97704: PPUSH
97705: PPUSH
97706: PPUSH
97707: PPUSH
97708: PPUSH
97709: PPUSH
97710: PPUSH
// if not unit or not building then
97711: LD_VAR 0 1
97715: NOT
97716: PUSH
97717: LD_VAR 0 2
97721: NOT
97722: OR
97723: IFFALSE 97727
// exit ;
97725: GO 97953
// x := GetX ( building ) ;
97727: LD_ADDR_VAR 0 4
97731: PUSH
97732: LD_VAR 0 2
97736: PPUSH
97737: CALL_OW 250
97741: ST_TO_ADDR
// y := GetY ( building ) ;
97742: LD_ADDR_VAR 0 6
97746: PUSH
97747: LD_VAR 0 2
97751: PPUSH
97752: CALL_OW 251
97756: ST_TO_ADDR
// d := GetDir ( building ) ;
97757: LD_ADDR_VAR 0 8
97761: PUSH
97762: LD_VAR 0 2
97766: PPUSH
97767: CALL_OW 254
97771: ST_TO_ADDR
// r := 4 ;
97772: LD_ADDR_VAR 0 9
97776: PUSH
97777: LD_INT 4
97779: ST_TO_ADDR
// for i := 1 to 5 do
97780: LD_ADDR_VAR 0 10
97784: PUSH
97785: DOUBLE
97786: LD_INT 1
97788: DEC
97789: ST_TO_ADDR
97790: LD_INT 5
97792: PUSH
97793: FOR_TO
97794: IFFALSE 97951
// begin _x := ShiftX ( x , d , r + i ) ;
97796: LD_ADDR_VAR 0 5
97800: PUSH
97801: LD_VAR 0 4
97805: PPUSH
97806: LD_VAR 0 8
97810: PPUSH
97811: LD_VAR 0 9
97815: PUSH
97816: LD_VAR 0 10
97820: PLUS
97821: PPUSH
97822: CALL_OW 272
97826: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
97827: LD_ADDR_VAR 0 7
97831: PUSH
97832: LD_VAR 0 6
97836: PPUSH
97837: LD_VAR 0 8
97841: PPUSH
97842: LD_VAR 0 9
97846: PUSH
97847: LD_VAR 0 10
97851: PLUS
97852: PPUSH
97853: CALL_OW 273
97857: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
97858: LD_VAR 0 5
97862: PPUSH
97863: LD_VAR 0 7
97867: PPUSH
97868: CALL_OW 488
97872: PUSH
97873: LD_VAR 0 5
97877: PPUSH
97878: LD_VAR 0 7
97882: PPUSH
97883: CALL_OW 428
97887: PPUSH
97888: CALL_OW 247
97892: PUSH
97893: LD_INT 3
97895: PUSH
97896: LD_INT 2
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: IN
97903: NOT
97904: AND
97905: IFFALSE 97949
// begin ComMoveXY ( unit , _x , _y ) ;
97907: LD_VAR 0 1
97911: PPUSH
97912: LD_VAR 0 5
97916: PPUSH
97917: LD_VAR 0 7
97921: PPUSH
97922: CALL_OW 111
// result := [ _x , _y ] ;
97926: LD_ADDR_VAR 0 3
97930: PUSH
97931: LD_VAR 0 5
97935: PUSH
97936: LD_VAR 0 7
97940: PUSH
97941: EMPTY
97942: LIST
97943: LIST
97944: ST_TO_ADDR
// exit ;
97945: POP
97946: POP
97947: GO 97953
// end ; end ;
97949: GO 97793
97951: POP
97952: POP
// end ;
97953: LD_VAR 0 3
97957: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
97958: LD_INT 0
97960: PPUSH
97961: PPUSH
97962: PPUSH
// result := 0 ;
97963: LD_ADDR_VAR 0 3
97967: PUSH
97968: LD_INT 0
97970: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
97971: LD_VAR 0 1
97975: PUSH
97976: LD_INT 0
97978: LESS
97979: PUSH
97980: LD_VAR 0 1
97984: PUSH
97985: LD_INT 8
97987: GREATER
97988: OR
97989: PUSH
97990: LD_VAR 0 2
97994: PUSH
97995: LD_INT 0
97997: LESS
97998: OR
97999: PUSH
98000: LD_VAR 0 2
98004: PUSH
98005: LD_INT 8
98007: GREATER
98008: OR
98009: IFFALSE 98013
// exit ;
98011: GO 98088
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
98013: LD_ADDR_VAR 0 4
98017: PUSH
98018: LD_INT 22
98020: PUSH
98021: LD_VAR 0 2
98025: PUSH
98026: EMPTY
98027: LIST
98028: LIST
98029: PPUSH
98030: CALL_OW 69
98034: PUSH
98035: FOR_IN
98036: IFFALSE 98086
// begin un := UnitShoot ( i ) ;
98038: LD_ADDR_VAR 0 5
98042: PUSH
98043: LD_VAR 0 4
98047: PPUSH
98048: CALL_OW 504
98052: ST_TO_ADDR
// if GetSide ( un ) = side1 then
98053: LD_VAR 0 5
98057: PPUSH
98058: CALL_OW 255
98062: PUSH
98063: LD_VAR 0 1
98067: EQUAL
98068: IFFALSE 98084
// begin result := un ;
98070: LD_ADDR_VAR 0 3
98074: PUSH
98075: LD_VAR 0 5
98079: ST_TO_ADDR
// exit ;
98080: POP
98081: POP
98082: GO 98088
// end ; end ;
98084: GO 98035
98086: POP
98087: POP
// end ;
98088: LD_VAR 0 3
98092: RET
// export function GetCargoBay ( units ) ; begin
98093: LD_INT 0
98095: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
98096: LD_ADDR_VAR 0 2
98100: PUSH
98101: LD_VAR 0 1
98105: PPUSH
98106: LD_INT 2
98108: PUSH
98109: LD_INT 34
98111: PUSH
98112: LD_INT 12
98114: PUSH
98115: EMPTY
98116: LIST
98117: LIST
98118: PUSH
98119: LD_INT 34
98121: PUSH
98122: LD_INT 51
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PUSH
98129: LD_INT 34
98131: PUSH
98132: LD_INT 32
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: PUSH
98139: LD_INT 34
98141: PUSH
98142: LD_EXP 76
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: EMPTY
98152: LIST
98153: LIST
98154: LIST
98155: LIST
98156: LIST
98157: PPUSH
98158: CALL_OW 72
98162: ST_TO_ADDR
// end ;
98163: LD_VAR 0 2
98167: RET
