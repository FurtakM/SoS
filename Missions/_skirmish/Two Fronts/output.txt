// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41697 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42148 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31789 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31789 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31789 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32252 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42067 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43015 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41976 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41976 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32252 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32252 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32252 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 71404 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31305 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31305 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31305 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31305 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32298 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41976 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31146 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41976 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31146 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41976 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31146 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41976 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31146 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41976 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42067 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41976 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41976 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41976 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41976 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41976 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41976 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41976 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41976 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41976 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41976 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41976 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41976 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31146 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31146 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31146 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31146 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31146 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31146 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31146 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31146 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31146 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31146 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31146 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31146 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32077 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31305 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31789 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31789 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32179 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42067 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41976 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41976 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41976 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41976 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42067 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28640: LD_VAR 0 1
28644: PPUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL 59213 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28654: LD_EXP 39
28658: PUSH
28659: LD_VAR 0 2
28663: PPUSH
28664: CALL_OW 255
28668: ARRAY
28669: IFFALSE 29396
// begin side := GetSide ( veh ) ;
28671: LD_ADDR_VAR 0 4
28675: PUSH
28676: LD_VAR 0 1
28680: PPUSH
28681: CALL_OW 255
28685: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28686: LD_ADDR_VAR 0 6
28690: PUSH
28691: LD_VAR 0 1
28695: PPUSH
28696: CALL_OW 265
28700: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28701: LD_ADDR_VAR 0 7
28705: PUSH
28706: LD_VAR 0 1
28710: PPUSH
28711: CALL_OW 262
28715: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28716: LD_ADDR_VAR 0 8
28720: PUSH
28721: LD_VAR 0 1
28725: PPUSH
28726: CALL_OW 263
28730: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28731: LD_ADDR_VAR 0 9
28735: PUSH
28736: LD_VAR 0 1
28740: PPUSH
28741: CALL_OW 264
28745: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28746: LD_STRING VehicleConstructed [side: 
28748: PUSH
28749: LD_VAR 0 4
28753: STR
28754: PUSH
28755: LD_STRING ; id:
28757: STR
28758: PUSH
28759: LD_VAR 0 1
28763: STR
28764: PUSH
28765: LD_STRING ; components: [
28767: STR
28768: PUSH
28769: LD_VAR 0 6
28773: STR
28774: PUSH
28775: LD_STRING , 
28777: STR
28778: PUSH
28779: LD_VAR 0 7
28783: STR
28784: PUSH
28785: LD_STRING , 
28787: STR
28788: PUSH
28789: LD_VAR 0 8
28793: STR
28794: PUSH
28795: LD_STRING , 
28797: STR
28798: PUSH
28799: LD_VAR 0 9
28803: STR
28804: PUSH
28805: LD_STRING ]]
28807: STR
28808: PPUSH
28809: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28813: LD_VAR 0 1
28817: PPUSH
28818: CALL_OW 264
28822: PUSH
28823: LD_INT 13
28825: PUSH
28826: LD_INT 12
28828: PUSH
28829: LD_INT 14
28831: PUSH
28832: LD_INT 51
28834: PUSH
28835: LD_INT 53
28837: PUSH
28838: LD_INT 52
28840: PUSH
28841: LD_INT 32
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: IN
28853: NOT
28854: IFFALSE 28896
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28856: LD_ADDR_EXP 59
28860: PUSH
28861: LD_EXP 59
28865: PPUSH
28866: LD_VAR 0 4
28870: PPUSH
28871: LD_EXP 59
28875: PUSH
28876: LD_VAR 0 4
28880: ARRAY
28881: PUSH
28882: LD_INT 1
28884: PLUS
28885: PPUSH
28886: LD_VAR 0 1
28890: PPUSH
28891: CALL 31146 0 4
28895: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28896: LD_VAR 0 1
28900: PPUSH
28901: CALL_OW 264
28905: PUSH
28906: LD_INT 31
28908: EQUAL
28909: IFFALSE 28928
// SetTag ( GetDriver ( veh ) , 9 ) ;
28911: LD_VAR 0 1
28915: PPUSH
28916: CALL 31789 0 1
28920: PPUSH
28921: LD_INT 9
28923: PPUSH
28924: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28928: LD_VAR 0 1
28932: PPUSH
28933: CALL_OW 264
28937: PUSH
28938: LD_INT 14
28940: PUSH
28941: LD_INT 53
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: IN
28948: IFFALSE 28985
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28950: LD_ADDR_EXP 42
28954: PUSH
28955: LD_EXP 42
28959: PPUSH
28960: LD_VAR 0 1
28964: PPUSH
28965: CALL_OW 255
28969: PPUSH
28970: LD_INT 2
28972: PPUSH
28973: LD_VAR 0 1
28977: PPUSH
28978: CALL 31146 0 4
28982: ST_TO_ADDR
// exit ;
28983: GO 29396
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28985: LD_VAR 0 1
28989: PPUSH
28990: CALL_OW 265
28994: PUSH
28995: LD_EXP 66
28999: PUSH
29000: LD_VAR 0 4
29004: ARRAY
29005: PUSH
29006: LD_INT 1
29008: ARRAY
29009: IN
29010: PUSH
29011: LD_VAR 0 1
29015: PPUSH
29016: CALL_OW 262
29020: PUSH
29021: LD_EXP 66
29025: PUSH
29026: LD_VAR 0 4
29030: ARRAY
29031: PUSH
29032: LD_INT 1
29034: ARRAY
29035: IN
29036: AND
29037: PUSH
29038: LD_VAR 0 1
29042: PPUSH
29043: CALL_OW 263
29047: PUSH
29048: LD_EXP 66
29052: PUSH
29053: LD_VAR 0 4
29057: ARRAY
29058: PUSH
29059: LD_INT 1
29061: ARRAY
29062: IN
29063: AND
29064: PUSH
29065: LD_VAR 0 1
29069: PPUSH
29070: CALL_OW 264
29074: PUSH
29075: LD_EXP 66
29079: PUSH
29080: LD_VAR 0 4
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: IN
29090: AND
29091: IFFALSE 29135
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29093: LD_ADDR_EXP 67
29097: PUSH
29098: LD_EXP 67
29102: PPUSH
29103: LD_VAR 0 4
29107: PPUSH
29108: LD_EXP 67
29112: PUSH
29113: LD_VAR 0 4
29117: ARRAY
29118: PUSH
29119: LD_INT 1
29121: PLUS
29122: PPUSH
29123: LD_VAR 0 1
29127: PPUSH
29128: CALL 31146 0 4
29132: ST_TO_ADDR
// exit ;
29133: GO 29396
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29135: LD_VAR 0 6
29139: PUSH
29140: LD_EXP 69
29144: PUSH
29145: LD_VAR 0 4
29149: ARRAY
29150: PUSH
29151: LD_INT 1
29153: ARRAY
29154: EQUAL
29155: PUSH
29156: LD_VAR 0 7
29160: PUSH
29161: LD_EXP 69
29165: PUSH
29166: LD_VAR 0 4
29170: ARRAY
29171: PUSH
29172: LD_INT 2
29174: ARRAY
29175: EQUAL
29176: AND
29177: PUSH
29178: LD_VAR 0 8
29182: PUSH
29183: LD_EXP 69
29187: PUSH
29188: LD_VAR 0 4
29192: ARRAY
29193: PUSH
29194: LD_INT 3
29196: ARRAY
29197: EQUAL
29198: AND
29199: PUSH
29200: LD_VAR 0 9
29204: PUSH
29205: LD_EXP 69
29209: PUSH
29210: LD_VAR 0 4
29214: ARRAY
29215: PUSH
29216: LD_INT 4
29218: ARRAY
29219: EQUAL
29220: AND
29221: IFFALSE 29377
// begin tmp := MREG_ToAttack [ side ] ;
29223: LD_ADDR_VAR 0 5
29227: PUSH
29228: LD_EXP 69
29232: PUSH
29233: LD_VAR 0 4
29237: ARRAY
29238: ST_TO_ADDR
// for i = 1 to 4 do
29239: LD_ADDR_VAR 0 3
29243: PUSH
29244: DOUBLE
29245: LD_INT 1
29247: DEC
29248: ST_TO_ADDR
29249: LD_INT 4
29251: PUSH
29252: FOR_TO
29253: IFFALSE 29275
// tmp := Delete ( tmp , 1 ) ;
29255: LD_ADDR_VAR 0 5
29259: PUSH
29260: LD_VAR 0 5
29264: PPUSH
29265: LD_INT 1
29267: PPUSH
29268: CALL_OW 3
29272: ST_TO_ADDR
29273: GO 29252
29275: POP
29276: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29277: LD_ADDR_EXP 69
29281: PUSH
29282: LD_EXP 69
29286: PPUSH
29287: LD_VAR 0 4
29291: PPUSH
29292: LD_VAR 0 5
29296: PPUSH
29297: CALL_OW 1
29301: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29302: LD_ADDR_EXP 71
29306: PUSH
29307: LD_EXP 71
29311: PPUSH
29312: LD_VAR 0 4
29316: PPUSH
29317: LD_EXP 71
29321: PUSH
29322: LD_VAR 0 4
29326: ARRAY
29327: PUSH
29328: LD_INT 1
29330: PLUS
29331: PPUSH
29332: LD_VAR 0 1
29336: PPUSH
29337: CALL 31146 0 4
29341: ST_TO_ADDR
// if tmp = 0 then
29342: LD_VAR 0 5
29346: PUSH
29347: LD_INT 0
29349: EQUAL
29350: IFFALSE 29375
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29352: LD_ADDR_EXP 69
29356: PUSH
29357: LD_EXP 69
29361: PPUSH
29362: LD_VAR 0 4
29366: PPUSH
29367: LD_INT 0
29369: PPUSH
29370: CALL_OW 1
29374: ST_TO_ADDR
// exit ;
29375: GO 29396
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29377: LD_VAR 0 1
29381: PPUSH
29382: CALL_OW 255
29386: PPUSH
29387: LD_VAR 0 1
29391: PPUSH
29392: CALL 25757 0 2
// end ; end ;
29396: PPOPN 9
29398: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29399: LD_EXP 39
29403: PUSH
29404: LD_VAR 0 2
29408: PPUSH
29409: CALL_OW 255
29413: ARRAY
29414: IFFALSE 29646
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29416: LD_STRING ApemanTamed [side: 
29418: PUSH
29419: LD_VAR 0 2
29423: PPUSH
29424: CALL_OW 255
29428: STR
29429: PUSH
29430: LD_STRING ; sci: 
29432: STR
29433: PUSH
29434: LD_VAR 0 2
29438: STR
29439: PUSH
29440: LD_STRING ; ape: 
29442: STR
29443: PUSH
29444: LD_VAR 0 1
29448: STR
29449: PUSH
29450: LD_STRING ]
29452: STR
29453: PPUSH
29454: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29458: LD_INT 11
29460: PPUSH
29461: LD_VAR 0 2
29465: PPUSH
29466: CALL_OW 255
29470: PPUSH
29471: CALL_OW 321
29475: PUSH
29476: LD_INT 2
29478: EQUAL
29479: NOT
29480: PUSH
29481: LD_INT 2
29483: PPUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: CALL_OW 321
29498: PUSH
29499: LD_INT 2
29501: EQUAL
29502: NOT
29503: OR
29504: PUSH
29505: LD_VAR 0 2
29509: PPUSH
29510: CALL_OW 255
29514: PPUSH
29515: LD_INT 171
29517: PPUSH
29518: EMPTY
29519: PPUSH
29520: CALL 12370 0 3
29524: PUSH
29525: LD_INT 0
29527: EQUAL
29528: AND
29529: IFFALSE 29543
// begin SetTag ( ape , 171 ) ;
29531: LD_VAR 0 1
29535: PPUSH
29536: LD_INT 171
29538: PPUSH
29539: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29543: LD_VAR 0 2
29547: PPUSH
29548: CALL_OW 255
29552: PPUSH
29553: LD_INT 30
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PPUSH
29563: CALL 11667 0 2
29567: IFFALSE 29646
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29569: LD_VAR 0 1
29573: PPUSH
29574: LD_VAR 0 2
29578: PPUSH
29579: CALL_OW 255
29583: PPUSH
29584: LD_INT 30
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PPUSH
29594: CALL 11667 0 2
29598: PUSH
29599: LD_INT 1
29601: ARRAY
29602: PPUSH
29603: CALL_OW 250
29607: PPUSH
29608: LD_VAR 0 2
29612: PPUSH
29613: CALL_OW 255
29617: PPUSH
29618: LD_INT 30
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PPUSH
29628: CALL 11667 0 2
29632: PUSH
29633: LD_INT 1
29635: ARRAY
29636: PPUSH
29637: CALL_OW 251
29641: PPUSH
29642: CALL_OW 111
// end ;
29646: PPOPN 2
29648: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29649: LD_EXP 39
29653: PUSH
29654: LD_VAR 0 1
29658: PPUSH
29659: CALL_OW 255
29663: ARRAY
29664: IFFALSE 29942
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29666: LD_VAR 0 2
29670: PUSH
29671: LD_VAR 0 2
29675: PPUSH
29676: CALL_OW 255
29680: PPUSH
29681: CALL 12080 0 1
29685: IN
29686: IFFALSE 29827
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29688: LD_VAR 0 1
29692: PPUSH
29693: CALL_OW 266
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: IN
29708: IFFALSE 29738
// begin Wait ( 0 0$0.3 ) ;
29710: LD_INT 10
29712: PPUSH
29713: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29717: LD_VAR 0 2
29721: PPUSH
29722: LD_INT 16
29724: PPUSH
29725: CALL_OW 336
// ComExitBuilding ( un ) ;
29729: LD_VAR 0 2
29733: PPUSH
29734: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29738: LD_VAR 0 1
29742: PPUSH
29743: CALL_OW 266
29747: PUSH
29748: LD_INT 4
29750: PUSH
29751: LD_INT 5
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: IN
29758: IFFALSE 29827
// begin Wait ( 0 0$0.3 ) ;
29760: LD_INT 10
29762: PPUSH
29763: CALL_OW 67
// if GetTag ( un ) = 0 then
29767: LD_VAR 0 2
29771: PPUSH
29772: CALL_OW 110
29776: PUSH
29777: LD_INT 0
29779: EQUAL
29780: IFFALSE 29796
// SetClass ( un , class_apeman_soldier ) else
29782: LD_VAR 0 2
29786: PPUSH
29787: LD_INT 15
29789: PPUSH
29790: CALL_OW 336
29794: GO 29827
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29796: LD_INT 3
29798: PPUSH
29799: LD_VAR 0 2
29803: PPUSH
29804: CALL_OW 255
29808: PPUSH
29809: CALL_OW 321
29813: IFFALSE 29827
// SetClass ( un , class_apeman_kamikaze ) ;
29815: LD_VAR 0 2
29819: PPUSH
29820: LD_INT 17
29822: PPUSH
29823: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29827: LD_VAR 0 1
29831: PPUSH
29832: CALL_OW 266
29836: PUSH
29837: LD_INT 32
29839: EQUAL
29840: IFFALSE 29942
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29842: LD_ADDR_EXP 68
29846: PUSH
29847: LD_EXP 68
29851: PPUSH
29852: LD_VAR 0 1
29856: PPUSH
29857: CALL_OW 255
29861: PPUSH
29862: LD_EXP 68
29866: PUSH
29867: LD_VAR 0 1
29871: PPUSH
29872: CALL_OW 255
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: PLUS
29881: PPUSH
29882: LD_VAR 0 1
29886: PPUSH
29887: CALL 31146 0 4
29891: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29892: LD_ADDR_EXP 68
29896: PUSH
29897: LD_EXP 68
29901: PPUSH
29902: LD_VAR 0 1
29906: PPUSH
29907: CALL_OW 255
29911: PPUSH
29912: LD_EXP 68
29916: PUSH
29917: LD_VAR 0 1
29921: PPUSH
29922: CALL_OW 255
29926: ARRAY
29927: PUSH
29928: LD_INT 1
29930: PLUS
29931: PPUSH
29932: LD_VAR 0 2
29936: PPUSH
29937: CALL 31146 0 4
29941: ST_TO_ADDR
// end ; end ;
29942: PPOPN 2
29944: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29945: LD_VAR 0 1
29949: PPUSH
29950: CALL 59091 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29954: LD_VAR 0 1
29958: PUSH
29959: LD_INT 22
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 23
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 21
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PPUSH
29994: CALL_OW 69
29998: IN
29999: IFFALSE 30015
// player_loss := player_loss + 1 ;
30001: LD_ADDR_EXP 10
30005: PUSH
30006: LD_EXP 10
30010: PUSH
30011: LD_INT 1
30013: PLUS
30014: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30015: LD_VAR 0 1
30019: PUSH
30020: LD_INT 22
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 21
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PPUSH
30044: CALL_OW 69
30048: IN
30049: PUSH
30050: LD_EXP 14
30054: NOT
30055: AND
30056: IFFALSE 30119
// begin alfa_north_triggered := true ;
30058: LD_ADDR_EXP 14
30062: PUSH
30063: LD_INT 1
30065: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30066: LD_EXP 5
30070: PPUSH
30071: LD_STRING DS4
30073: PPUSH
30074: CALL_OW 94
// Wait ( 1 1$25 ) ;
30078: LD_INT 2975
30080: PPUSH
30081: CALL_OW 67
// if not isTest then
30085: LD_EXP 1
30089: NOT
30090: IFFALSE 30119
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30092: LD_INT 20
30094: PPUSH
30095: LD_INT 5
30097: PUSH
30098: LD_INT 6
30100: PUSH
30101: LD_INT 7
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: LIST
30108: PUSH
30109: LD_OWVAR 67
30113: ARRAY
30114: PPUSH
30115: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30119: LD_VAR 0 1
30123: PUSH
30124: LD_INT 22
30126: PUSH
30127: LD_INT 4
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 21
30136: PUSH
30137: LD_INT 3
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PPUSH
30148: CALL_OW 69
30152: IN
30153: PUSH
30154: LD_EXP 15
30158: NOT
30159: AND
30160: IFFALSE 30223
// begin alfa_south_triggered := true ;
30162: LD_ADDR_EXP 15
30166: PUSH
30167: LD_INT 1
30169: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30170: LD_EXP 4
30174: PPUSH
30175: LD_STRING DJ3
30177: PPUSH
30178: CALL_OW 94
// Wait ( 0 0$45 ) ;
30182: LD_INT 1575
30184: PPUSH
30185: CALL_OW 67
// if not isTest then
30189: LD_EXP 1
30193: NOT
30194: IFFALSE 30223
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30196: LD_INT 20
30198: PPUSH
30199: LD_INT 5
30201: PUSH
30202: LD_INT 6
30204: PUSH
30205: LD_INT 7
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: LIST
30212: PUSH
30213: LD_OWVAR 67
30217: ARRAY
30218: PPUSH
30219: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 266
30232: PUSH
30233: LD_INT 1
30235: EQUAL
30236: PUSH
30237: LD_VAR 0 1
30241: PPUSH
30242: CALL_OW 255
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: LD_INT 4
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: IN
30257: AND
30258: IFFALSE 30267
// RaiseSailEvent ( 104 ) ;
30260: LD_INT 104
30262: PPUSH
30263: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30267: LD_EXP 39
30271: PUSH
30272: LD_VAR 0 1
30276: PPUSH
30277: CALL_OW 255
30281: ARRAY
30282: IFFALSE 30669
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30284: LD_STRING UnitDestroyed [side 
30286: PUSH
30287: LD_VAR 0 1
30291: PPUSH
30292: CALL_OW 255
30296: STR
30297: PUSH
30298: LD_STRING ; id: 
30300: STR
30301: PUSH
30302: LD_VAR 0 1
30306: STR
30307: PUSH
30308: LD_STRING ; type: 
30310: STR
30311: PUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL_OW 247
30321: STR
30322: PUSH
30323: LD_STRING ]
30325: STR
30326: PPUSH
30327: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30331: LD_VAR 0 1
30335: PUSH
30336: LD_VAR 0 1
30340: PPUSH
30341: CALL_OW 255
30345: PPUSH
30346: LD_INT 21
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PPUSH
30356: CALL 11667 0 2
30360: IN
30361: IFFALSE 30517
// begin if MCF_HasClass ( un ) then
30363: LD_VAR 0 1
30367: PPUSH
30368: CALL 14373 0 1
30372: IFFALSE 30517
// case MCF_HasClass ( un ) of 1 :
30374: LD_VAR 0 1
30378: PPUSH
30379: CALL 14373 0 1
30383: PUSH
30384: LD_INT 1
30386: DOUBLE
30387: EQUAL
30388: IFTRUE 30392
30390: GO 30417
30392: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30393: LD_VAR 0 1
30397: PPUSH
30398: CALL_OW 255
30402: PPUSH
30403: LD_STRING ToArm
30405: PPUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: CALL 14546 0 3
30415: GO 30517
30417: LD_INT 2
30419: DOUBLE
30420: EQUAL
30421: IFTRUE 30425
30423: GO 30450
30425: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30426: LD_VAR 0 1
30430: PPUSH
30431: CALL_OW 255
30435: PPUSH
30436: LD_STRING ToDep
30438: PPUSH
30439: LD_VAR 0 1
30443: PPUSH
30444: CALL 14546 0 3
30448: GO 30517
30450: LD_INT 3
30452: DOUBLE
30453: EQUAL
30454: IFTRUE 30458
30456: GO 30483
30458: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30459: LD_VAR 0 1
30463: PPUSH
30464: CALL_OW 255
30468: PPUSH
30469: LD_STRING ToFac
30471: PPUSH
30472: LD_VAR 0 1
30476: PPUSH
30477: CALL 14546 0 3
30481: GO 30517
30483: LD_INT 4
30485: DOUBLE
30486: EQUAL
30487: IFTRUE 30491
30489: GO 30516
30491: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30492: LD_VAR 0 1
30496: PPUSH
30497: CALL_OW 255
30501: PPUSH
30502: LD_STRING ToLab
30504: PPUSH
30505: LD_VAR 0 1
30509: PPUSH
30510: CALL 14546 0 3
30514: GO 30517
30516: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30517: LD_VAR 0 1
30521: PUSH
30522: LD_EXP 67
30526: PUSH
30527: LD_VAR 0 1
30531: PPUSH
30532: CALL_OW 255
30536: ARRAY
30537: IN
30538: IFFALSE 30623
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30540: LD_ADDR_EXP 67
30544: PUSH
30545: LD_EXP 67
30549: PPUSH
30550: LD_VAR 0 1
30554: PPUSH
30555: LD_INT 0
30557: PPUSH
30558: CALL 31305 0 3
30562: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30563: LD_VAR 0 1
30567: PPUSH
30568: CALL_OW 255
30572: PPUSH
30573: LD_VAR 0 1
30577: PPUSH
30578: CALL_OW 265
30582: PUSH
30583: LD_VAR 0 1
30587: PPUSH
30588: CALL_OW 262
30592: PUSH
30593: LD_VAR 0 1
30597: PPUSH
30598: CALL_OW 263
30602: PUSH
30603: LD_VAR 0 1
30607: PPUSH
30608: CALL_OW 264
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: PPUSH
30619: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30623: LD_VAR 0 1
30627: PUSH
30628: LD_EXP 71
30632: PUSH
30633: LD_VAR 0 1
30637: PPUSH
30638: CALL_OW 255
30642: ARRAY
30643: IN
30644: IFFALSE 30669
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30646: LD_ADDR_EXP 71
30650: PUSH
30651: LD_EXP 71
30655: PPUSH
30656: LD_VAR 0 1
30660: PPUSH
30661: LD_INT 0
30663: PPUSH
30664: CALL 31305 0 3
30668: ST_TO_ADDR
// end ; end ;
30669: PPOPN 1
30671: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30672: LD_EXP 39
30676: PUSH
30677: LD_VAR 0 2
30681: PPUSH
30682: CALL_OW 255
30686: ARRAY
30687: IFFALSE 30859
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30689: LD_VAR 0 2
30693: PUSH
30694: LD_EXP 68
30698: PUSH
30699: LD_VAR 0 2
30703: PPUSH
30704: CALL_OW 255
30708: ARRAY
30709: IN
30710: PUSH
30711: LD_VAR 0 1
30715: PPUSH
30716: CALL_OW 266
30720: PUSH
30721: LD_INT 32
30723: PUSH
30724: LD_INT 31
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: IN
30731: AND
30732: IFFALSE 30832
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30734: LD_ADDR_EXP 68
30738: PUSH
30739: LD_EXP 68
30743: PPUSH
30744: LD_VAR 0 1
30748: PPUSH
30749: LD_INT 0
30751: PPUSH
30752: CALL 31305 0 3
30756: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30757: LD_ADDR_EXP 68
30761: PUSH
30762: LD_EXP 68
30766: PPUSH
30767: LD_VAR 0 2
30771: PPUSH
30772: LD_INT 0
30774: PPUSH
30775: CALL 31305 0 3
30779: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30780: LD_EXP 68
30784: PUSH
30785: LD_VAR 0 2
30789: PPUSH
30790: CALL_OW 255
30794: ARRAY
30795: PUSH
30796: LD_STRING 
30798: EQUAL
30799: IFFALSE 30832
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30801: LD_ADDR_EXP 68
30805: PUSH
30806: LD_EXP 68
30810: PPUSH
30811: LD_VAR 0 2
30815: PPUSH
30816: CALL_OW 255
30820: PPUSH
30821: LD_INT 1
30823: PPUSH
30824: LD_INT 0
30826: PPUSH
30827: CALL 31146 0 4
30831: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 266
30841: PUSH
30842: LD_INT 36
30844: IN
30845: IFFALSE 30859
// SetTag ( un , 0 ) ;
30847: LD_VAR 0 2
30851: PPUSH
30852: LD_INT 0
30854: PPUSH
30855: CALL_OW 109
// end ;
30859: PPOPN 2
30861: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30862: LD_EXP 39
30866: PUSH
30867: LD_VAR 0 1
30871: PPUSH
30872: CALL_OW 255
30876: ARRAY
30877: IFFALSE 30903
// begin if GetControl ( un ) = control_remote then
30879: LD_VAR 0 1
30883: PPUSH
30884: CALL_OW 263
30888: PUSH
30889: LD_INT 2
30891: EQUAL
30892: IFFALSE 30903
// ComUnlink ( un ) ;
30894: LD_VAR 0 1
30898: PPUSH
30899: CALL_OW 136
// end ;
30903: PPOPN 1
30905: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30906: LD_EXP 39
30910: PUSH
30911: LD_VAR 0 1
30915: PPUSH
30916: CALL_OW 255
30920: ARRAY
30921: IFFALSE 30950
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30923: LD_VAR 0 2
30927: PPUSH
30928: CALL_OW 264
30932: PUSH
30933: LD_INT 31
30935: IN
30936: IFFALSE 30950
// SetTag ( driver , 0 ) ;
30938: LD_VAR 0 1
30942: PPUSH
30943: LD_INT 0
30945: PPUSH
30946: CALL_OW 109
// end ;
30950: PPOPN 4
30952: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30953: LD_INT 0
30955: PPUSH
30956: PPUSH
30957: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30958: LD_ADDR_VAR 0 3
30962: PUSH
30963: LD_VAR 0 1
30967: PPUSH
30968: CALL_OW 269
30972: ST_TO_ADDR
// x := GetX ( building ) ;
30973: LD_ADDR_VAR 0 4
30977: PUSH
30978: LD_VAR 0 1
30982: PPUSH
30983: CALL_OW 250
30987: ST_TO_ADDR
// y := GetY ( building ) ;
30988: LD_ADDR_VAR 0 5
30992: PUSH
30993: LD_VAR 0 1
30997: PPUSH
30998: CALL_OW 251
31002: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
31003: LD_ADDR_EXP 43
31007: PUSH
31008: LD_EXP 43
31012: PPUSH
31013: LD_VAR 0 1
31017: PPUSH
31018: CALL_OW 255
31022: PPUSH
31023: LD_VAR 0 3
31027: PPUSH
31028: LD_VAR 0 4
31032: PUSH
31033: LD_VAR 0 5
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL 42067 0 4
31046: ST_TO_ADDR
// end ;
31047: PPOPN 5
31049: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31050: LD_VAR 0 1
31054: PUSH
31055: LD_EXP 30
31059: IN
31060: NOT
31061: IFFALSE 31109
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31063: LD_ADDR_EXP 30
31067: PUSH
31068: LD_EXP 30
31072: PPUSH
31073: LD_EXP 30
31077: PUSH
31078: LD_INT 1
31080: PLUS
31081: PPUSH
31082: LD_VAR 0 1
31086: PPUSH
31087: CALL_OW 2
31091: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31092: LD_STRING DestinationUnrechable. [unit: 
31094: PUSH
31095: LD_VAR 0 1
31099: STR
31100: PUSH
31101: LD_STRING ]
31103: STR
31104: PPUSH
31105: CALL 8055 0 1
// end ; end ;
31109: PPOPN 1
31111: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31112: LD_VAR 0 1
31116: PPUSH
31117: LD_VAR 0 2
31121: PPUSH
31122: LD_VAR 0 3
31126: PPUSH
31127: CALL 59189 0 3
// end ;
31131: PPOPN 3
31133: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31134: LD_VAR 0 1
31138: PPUSH
31139: CALL 59197 0 1
// end ; end_of_file
31143: PPOPN 1
31145: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31146: LD_INT 0
31148: PPUSH
31149: PPUSH
31150: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31151: LD_ADDR_VAR 0 7
31155: PUSH
31156: LD_VAR 0 1
31160: PUSH
31161: LD_VAR 0 2
31165: ARRAY
31166: PPUSH
31167: LD_VAR 0 3
31171: PPUSH
31172: LD_VAR 0 4
31176: PPUSH
31177: CALL_OW 1
31181: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31182: LD_ADDR_VAR 0 1
31186: PUSH
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_VAR 0 2
31196: PPUSH
31197: LD_VAR 0 7
31201: PPUSH
31202: CALL_OW 1
31206: ST_TO_ADDR
// result := tab ;
31207: LD_ADDR_VAR 0 5
31211: PUSH
31212: LD_VAR 0 1
31216: ST_TO_ADDR
// end ;
31217: LD_VAR 0 5
31221: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31222: LD_INT 0
31224: PPUSH
31225: PPUSH
31226: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31227: LD_ADDR_VAR 0 5
31231: PUSH
31232: LD_VAR 0 1
31236: PUSH
31237: LD_VAR 0 2
31241: PUSH
31242: LD_INT 1
31244: ARRAY
31245: ARRAY
31246: PPUSH
31247: LD_VAR 0 2
31251: PUSH
31252: LD_INT 2
31254: ARRAY
31255: PPUSH
31256: CALL_OW 3
31260: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31261: LD_ADDR_VAR 0 1
31265: PUSH
31266: LD_VAR 0 1
31270: PPUSH
31271: LD_VAR 0 2
31275: PUSH
31276: LD_INT 1
31278: ARRAY
31279: PPUSH
31280: LD_VAR 0 5
31284: PPUSH
31285: CALL_OW 1
31289: ST_TO_ADDR
// result := tab ;
31290: LD_ADDR_VAR 0 3
31294: PUSH
31295: LD_VAR 0 1
31299: ST_TO_ADDR
// end ;
31300: LD_VAR 0 3
31304: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31305: LD_INT 0
31307: PPUSH
31308: PPUSH
31309: PPUSH
31310: PPUSH
// i := 1 ;
31311: LD_ADDR_VAR 0 5
31315: PUSH
31316: LD_INT 1
31318: ST_TO_ADDR
// while ( i <= tab ) do
31319: LD_VAR 0 5
31323: PUSH
31324: LD_VAR 0 1
31328: LESSEQUAL
31329: IFFALSE 31704
// begin if not tab [ i ] then
31331: LD_VAR 0 1
31335: PUSH
31336: LD_VAR 0 5
31340: ARRAY
31341: NOT
31342: IFFALSE 31346
// break ;
31344: GO 31704
// if value in tab then
31346: LD_VAR 0 2
31350: PUSH
31351: LD_VAR 0 1
31355: IN
31356: IFFALSE 31469
// begin if not mode then
31358: LD_VAR 0 3
31362: NOT
31363: IFFALSE 31383
// tab := tab diff value else
31365: LD_ADDR_VAR 0 1
31369: PUSH
31370: LD_VAR 0 1
31374: PUSH
31375: LD_VAR 0 2
31379: DIFF
31380: ST_TO_ADDR
31381: GO 31445
// for j = 1 to tab do
31383: LD_ADDR_VAR 0 6
31387: PUSH
31388: DOUBLE
31389: LD_INT 1
31391: DEC
31392: ST_TO_ADDR
31393: LD_VAR 0 1
31397: PUSH
31398: FOR_TO
31399: IFFALSE 31443
// if tab [ j ] = value then
31401: LD_VAR 0 1
31405: PUSH
31406: LD_VAR 0 6
31410: ARRAY
31411: PUSH
31412: LD_VAR 0 2
31416: EQUAL
31417: IFFALSE 31441
// begin tab := Delete ( tab , j ) ;
31419: LD_ADDR_VAR 0 1
31423: PUSH
31424: LD_VAR 0 1
31428: PPUSH
31429: LD_VAR 0 6
31433: PPUSH
31434: CALL_OW 3
31438: ST_TO_ADDR
// break ;
31439: GO 31443
// end ;
31441: GO 31398
31443: POP
31444: POP
// i := i - 1 ;
31445: LD_ADDR_VAR 0 5
31449: PUSH
31450: LD_VAR 0 5
31454: PUSH
31455: LD_INT 1
31457: MINUS
31458: ST_TO_ADDR
// if mode then
31459: LD_VAR 0 3
31463: IFFALSE 31467
// break ;
31465: GO 31704
// end else
31467: GO 31688
// if tab [ i ] and value in tab [ i ] then
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: PUSH
31480: LD_VAR 0 2
31484: PUSH
31485: LD_VAR 0 1
31489: PUSH
31490: LD_VAR 0 5
31494: ARRAY
31495: IN
31496: AND
31497: IFFALSE 31688
// begin if not mode then
31499: LD_VAR 0 3
31503: NOT
31504: IFFALSE 31530
// tmp := tab [ i ] diff value else
31506: LD_ADDR_VAR 0 7
31510: PUSH
31511: LD_VAR 0 1
31515: PUSH
31516: LD_VAR 0 5
31520: ARRAY
31521: PUSH
31522: LD_VAR 0 2
31526: DIFF
31527: ST_TO_ADDR
31528: GO 31610
// for j = 1 to tab [ i ] do
31530: LD_ADDR_VAR 0 6
31534: PUSH
31535: DOUBLE
31536: LD_INT 1
31538: DEC
31539: ST_TO_ADDR
31540: LD_VAR 0 1
31544: PUSH
31545: LD_VAR 0 5
31549: ARRAY
31550: PUSH
31551: FOR_TO
31552: IFFALSE 31608
// if value = tab [ i ] [ j ] then
31554: LD_VAR 0 2
31558: PUSH
31559: LD_VAR 0 1
31563: PUSH
31564: LD_VAR 0 5
31568: ARRAY
31569: PUSH
31570: LD_VAR 0 6
31574: ARRAY
31575: EQUAL
31576: IFFALSE 31606
// begin tmp := Delete ( tab [ i ] , j ) ;
31578: LD_ADDR_VAR 0 7
31582: PUSH
31583: LD_VAR 0 1
31587: PUSH
31588: LD_VAR 0 5
31592: ARRAY
31593: PPUSH
31594: LD_VAR 0 6
31598: PPUSH
31599: CALL_OW 3
31603: ST_TO_ADDR
// break ;
31604: GO 31608
// end ;
31606: GO 31551
31608: POP
31609: POP
// if tmp = [ ] then
31610: LD_VAR 0 7
31614: PUSH
31615: EMPTY
31616: EQUAL
31617: IFFALSE 31641
// begin tab := Delete ( tab , i ) ;
31619: LD_ADDR_VAR 0 1
31623: PUSH
31624: LD_VAR 0 1
31628: PPUSH
31629: LD_VAR 0 5
31633: PPUSH
31634: CALL_OW 3
31638: ST_TO_ADDR
// end else
31639: GO 31666
// tab := Replace ( tab , i , tmp ) ;
31641: LD_ADDR_VAR 0 1
31645: PUSH
31646: LD_VAR 0 1
31650: PPUSH
31651: LD_VAR 0 5
31655: PPUSH
31656: LD_VAR 0 7
31660: PPUSH
31661: CALL_OW 1
31665: ST_TO_ADDR
// i := i - 1 ;
31666: LD_ADDR_VAR 0 5
31670: PUSH
31671: LD_VAR 0 5
31675: PUSH
31676: LD_INT 1
31678: MINUS
31679: ST_TO_ADDR
// if mode then
31680: LD_VAR 0 3
31684: IFFALSE 31688
// break ;
31686: GO 31704
// end ; i := i + 1 ;
31688: LD_ADDR_VAR 0 5
31692: PUSH
31693: LD_VAR 0 5
31697: PUSH
31698: LD_INT 1
31700: PLUS
31701: ST_TO_ADDR
// end ;
31702: GO 31319
// result := tab ;
31704: LD_ADDR_VAR 0 4
31708: PUSH
31709: LD_VAR 0 1
31713: ST_TO_ADDR
// end ;
31714: LD_VAR 0 4
31718: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31719: LD_INT 0
31721: PPUSH
31722: PPUSH
// for i = 1 to values do
31723: LD_ADDR_VAR 0 4
31727: PUSH
31728: DOUBLE
31729: LD_INT 1
31731: DEC
31732: ST_TO_ADDR
31733: LD_VAR 0 2
31737: PUSH
31738: FOR_TO
31739: IFFALSE 31772
// tab := Remove ( tab , values [ i ] , false ) ;
31741: LD_ADDR_VAR 0 1
31745: PUSH
31746: LD_VAR 0 1
31750: PPUSH
31751: LD_VAR 0 2
31755: PUSH
31756: LD_VAR 0 4
31760: ARRAY
31761: PPUSH
31762: LD_INT 0
31764: PPUSH
31765: CALL 31305 0 3
31769: ST_TO_ADDR
31770: GO 31738
31772: POP
31773: POP
// result := tab ;
31774: LD_ADDR_VAR 0 3
31778: PUSH
31779: LD_VAR 0 1
31783: ST_TO_ADDR
// end ;
31784: LD_VAR 0 3
31788: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31789: LD_INT 0
31791: PPUSH
31792: PPUSH
31793: PPUSH
// if not GetControl ( veh ) = control_manual then
31794: LD_VAR 0 1
31798: PPUSH
31799: CALL_OW 263
31803: PUSH
31804: LD_INT 1
31806: EQUAL
31807: NOT
31808: IFFALSE 31820
// result := false else
31810: LD_ADDR_VAR 0 2
31814: PUSH
31815: LD_INT 0
31817: ST_TO_ADDR
31818: GO 31965
// if veh in FilterAllUnits ( [ f_empty ] ) then
31820: LD_VAR 0 1
31824: PUSH
31825: LD_INT 58
31827: PUSH
31828: EMPTY
31829: LIST
31830: PPUSH
31831: CALL_OW 69
31835: IN
31836: IFFALSE 31848
// result := false else
31838: LD_ADDR_VAR 0 2
31842: PUSH
31843: LD_INT 0
31845: ST_TO_ADDR
31846: GO 31965
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31848: LD_ADDR_VAR 0 4
31852: PUSH
31853: LD_INT 22
31855: PUSH
31856: LD_VAR 0 1
31860: PPUSH
31861: CALL_OW 255
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 55
31872: PUSH
31873: EMPTY
31874: LIST
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PPUSH
31880: CALL_OW 69
31884: ST_TO_ADDR
// if not filter then
31885: LD_VAR 0 4
31889: NOT
31890: IFFALSE 31902
// result := false else
31892: LD_ADDR_VAR 0 2
31896: PUSH
31897: LD_INT 0
31899: ST_TO_ADDR
31900: GO 31965
// for i = 1 to filter do
31902: LD_ADDR_VAR 0 3
31906: PUSH
31907: DOUBLE
31908: LD_INT 1
31910: DEC
31911: ST_TO_ADDR
31912: LD_VAR 0 4
31916: PUSH
31917: FOR_TO
31918: IFFALSE 31963
// if IsDriver ( filter [ i ] ) = veh then
31920: LD_VAR 0 4
31924: PUSH
31925: LD_VAR 0 3
31929: ARRAY
31930: PPUSH
31931: CALL 98412 0 1
31935: PUSH
31936: LD_VAR 0 1
31940: EQUAL
31941: IFFALSE 31961
// begin result := filter [ i ] ;
31943: LD_ADDR_VAR 0 2
31947: PUSH
31948: LD_VAR 0 4
31952: PUSH
31953: LD_VAR 0 3
31957: ARRAY
31958: ST_TO_ADDR
// break ;
31959: GO 31963
// end ;
31961: GO 31917
31963: POP
31964: POP
// end ; end ;
31965: LD_VAR 0 2
31969: RET
// export function Compare ( val1 , val2 ) ; begin
31970: LD_INT 0
31972: PPUSH
// if val1 = val2 then
31973: LD_VAR 0 1
31977: PUSH
31978: LD_VAR 0 2
31982: EQUAL
31983: IFFALSE 31995
// result := true else
31985: LD_ADDR_VAR 0 3
31989: PUSH
31990: LD_INT 1
31992: ST_TO_ADDR
31993: GO 32003
// result := false ;
31995: LD_ADDR_VAR 0 3
31999: PUSH
32000: LD_INT 0
32002: ST_TO_ADDR
// end ;
32003: LD_VAR 0 3
32007: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32008: LD_INT 0
32010: PPUSH
32011: PPUSH
// result := false ;
32012: LD_ADDR_VAR 0 3
32016: PUSH
32017: LD_INT 0
32019: ST_TO_ADDR
// for j = 1 to e2 do
32020: LD_ADDR_VAR 0 4
32024: PUSH
32025: DOUBLE
32026: LD_INT 1
32028: DEC
32029: ST_TO_ADDR
32030: LD_VAR 0 2
32034: PUSH
32035: FOR_TO
32036: IFFALSE 32070
// if Compare ( e1 , e2 [ j ] ) then
32038: LD_VAR 0 1
32042: PPUSH
32043: LD_VAR 0 2
32047: PUSH
32048: LD_VAR 0 4
32052: ARRAY
32053: PPUSH
32054: CALL 31970 0 2
32058: IFFALSE 32068
// result := true ;
32060: LD_ADDR_VAR 0 3
32064: PUSH
32065: LD_INT 1
32067: ST_TO_ADDR
32068: GO 32035
32070: POP
32071: POP
// end ;
32072: LD_VAR 0 3
32076: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32077: LD_INT 0
32079: PPUSH
32080: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32081: LD_VAR 0 1
32085: PPUSH
32086: LD_STRING C
32088: PUSH
32089: LD_VAR 0 2
32093: PUSH
32094: LD_VAR 0 3
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: PUSH
32120: LD_STRING v
32122: PUSH
32123: LD_VAR 0 4
32127: PPUSH
32128: CALL_OW 250
32132: PUSH
32133: LD_VAR 0 4
32137: PPUSH
32138: CALL_OW 251
32142: PUSH
32143: LD_VAR 0 4
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PPUSH
32170: CALL_OW 446
// end ;
32174: LD_VAR 0 5
32178: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32179: LD_INT 0
32181: PPUSH
32182: PPUSH
32183: PPUSH
// linked := UnitsLinked ( unit ) ;
32184: LD_ADDR_VAR 0 4
32188: PUSH
32189: LD_VAR 0 1
32193: PPUSH
32194: CALL_OW 432
32198: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32199: LD_ADDR_VAR 0 3
32203: PUSH
32204: LD_VAR 0 1
32208: PPUSH
32209: LD_INT 3
32211: PPUSH
32212: CALL_OW 259
32216: ST_TO_ADDR
// if sk > linked then
32217: LD_VAR 0 3
32221: PUSH
32222: LD_VAR 0 4
32226: GREATER
32227: IFFALSE 32239
// result := true else
32229: LD_ADDR_VAR 0 2
32233: PUSH
32234: LD_INT 1
32236: ST_TO_ADDR
32237: GO 32247
// result := false ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 0
32246: ST_TO_ADDR
// end ;
32247: LD_VAR 0 2
32251: RET
// export function NotTask ( unit ) ; begin
32252: LD_INT 0
32254: PPUSH
// result := true ;
32255: LD_ADDR_VAR 0 2
32259: PUSH
32260: LD_INT 1
32262: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32263: LD_VAR 0 1
32267: PPUSH
32268: CALL_OW 437
32272: PUSH
32273: LD_VAR 0 1
32277: PPUSH
32278: CALL_OW 314
32282: OR
32283: IFFALSE 32293
// result := false ;
32285: LD_ADDR_VAR 0 2
32289: PUSH
32290: LD_INT 0
32292: ST_TO_ADDR
// end ;
32293: LD_VAR 0 2
32297: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32298: LD_INT 0
32300: PPUSH
32301: PPUSH
32302: PPUSH
32303: PPUSH
32304: PPUSH
// dist := 99999 ;
32305: LD_ADDR_VAR 0 7
32309: PUSH
32310: LD_INT 99999
32312: ST_TO_ADDR
// un := - 1 ;
32313: LD_ADDR_VAR 0 6
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: ST_TO_ADDR
// if units1 and units2 then
32322: LD_VAR 0 1
32326: PUSH
32327: LD_VAR 0 2
32331: AND
32332: IFFALSE 32420
// for i in units1 do
32334: LD_ADDR_VAR 0 4
32338: PUSH
32339: LD_VAR 0 1
32343: PUSH
32344: FOR_IN
32345: IFFALSE 32418
// for j in units2 do
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_VAR 0 2
32356: PUSH
32357: FOR_IN
32358: IFFALSE 32414
// if GetDistUnits ( i , j ) < dist then
32360: LD_VAR 0 4
32364: PPUSH
32365: LD_VAR 0 5
32369: PPUSH
32370: CALL_OW 296
32374: PUSH
32375: LD_VAR 0 7
32379: LESS
32380: IFFALSE 32412
// begin un := i ;
32382: LD_ADDR_VAR 0 6
32386: PUSH
32387: LD_VAR 0 4
32391: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32392: LD_ADDR_VAR 0 7
32396: PUSH
32397: LD_VAR 0 4
32401: PPUSH
32402: LD_VAR 0 5
32406: PPUSH
32407: CALL_OW 296
32411: ST_TO_ADDR
// end ;
32412: GO 32357
32414: POP
32415: POP
32416: GO 32344
32418: POP
32419: POP
// result := [ un , dist ] ;
32420: LD_ADDR_VAR 0 3
32424: PUSH
32425: LD_VAR 0 6
32429: PUSH
32430: LD_VAR 0 7
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: ST_TO_ADDR
// end ;
32439: LD_VAR 0 3
32443: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32444: LD_INT 0
32446: PPUSH
32447: PPUSH
32448: PPUSH
32449: PPUSH
32450: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32451: LD_VAR 0 1
32455: NOT
32456: PUSH
32457: LD_VAR 0 1
32461: PPUSH
32462: CALL_OW 256
32466: PUSH
32467: LD_INT 250
32469: LESS
32470: OR
32471: PUSH
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 314
32481: PUSH
32482: LD_VAR 0 1
32486: PPUSH
32487: CALL_OW 261
32491: PUSH
32492: LD_INT 20
32494: GREATER
32495: AND
32496: OR
32497: IFFALSE 32501
// exit ;
32499: GO 32875
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 261
32510: PUSH
32511: LD_INT 20
32513: LESS
32514: PUSH
32515: LD_VAR 0 1
32519: PPUSH
32520: CALL_OW 110
32524: PUSH
32525: LD_INT 21
32527: EQUAL
32528: NOT
32529: AND
32530: IFFALSE 32566
// begin ComStop ( bulldozer ) ;
32532: LD_VAR 0 1
32536: PPUSH
32537: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32541: LD_VAR 0 1
32545: PPUSH
32546: LD_INT 21
32548: PPUSH
32549: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32553: LD_VAR 0 1
32557: PPUSH
32558: CALL 26294 0 1
// exit ;
32562: GO 32875
// end else
32564: GO 32593
// if GetFuel ( bulldozer ) > 20 then
32566: LD_VAR 0 1
32570: PPUSH
32571: CALL_OW 261
32575: PUSH
32576: LD_INT 20
32578: GREATER
32579: IFFALSE 32593
// SetTag ( bulldozer , 0 ) ;
32581: LD_VAR 0 1
32585: PPUSH
32586: LD_INT 0
32588: PPUSH
32589: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32593: LD_ADDR_VAR 0 5
32597: PUSH
32598: LD_VAR 0 2
32602: PPUSH
32603: CALL_OW 353
32607: ST_TO_ADDR
// tmp := [ ] ;
32608: LD_ADDR_VAR 0 6
32612: PUSH
32613: EMPTY
32614: ST_TO_ADDR
// for i = 1 to list do
32615: LD_ADDR_VAR 0 4
32619: PUSH
32620: DOUBLE
32621: LD_INT 1
32623: DEC
32624: ST_TO_ADDR
32625: LD_VAR 0 5
32629: PUSH
32630: FOR_TO
32631: IFFALSE 32729
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32633: LD_VAR 0 5
32637: PUSH
32638: LD_VAR 0 4
32642: ARRAY
32643: PUSH
32644: LD_INT 1
32646: ARRAY
32647: PPUSH
32648: LD_VAR 0 5
32652: PUSH
32653: LD_VAR 0 4
32657: ARRAY
32658: PUSH
32659: LD_INT 2
32661: ARRAY
32662: PPUSH
32663: CALL_OW 554
32667: IFFALSE 32727
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32669: LD_ADDR_VAR 0 6
32673: PUSH
32674: LD_VAR 0 6
32678: PPUSH
32679: LD_VAR 0 6
32683: PUSH
32684: LD_INT 1
32686: PLUS
32687: PPUSH
32688: LD_VAR 0 5
32692: PUSH
32693: LD_VAR 0 4
32697: ARRAY
32698: PUSH
32699: LD_INT 1
32701: ARRAY
32702: PUSH
32703: LD_VAR 0 5
32707: PUSH
32708: LD_VAR 0 4
32712: ARRAY
32713: PUSH
32714: LD_INT 2
32716: ARRAY
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PPUSH
32722: CALL_OW 1
32726: ST_TO_ADDR
// end ;
32727: GO 32630
32729: POP
32730: POP
// ComStop ( bulldozer ) ;
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32740: LD_ADDR_VAR 0 7
32744: PUSH
32745: LD_VAR 0 1
32749: PPUSH
32750: CALL_OW 250
32754: PUSH
32755: LD_VAR 0 1
32759: PPUSH
32760: CALL_OW 251
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: ST_TO_ADDR
// for i = tmp downto 1 do
32769: LD_ADDR_VAR 0 4
32773: PUSH
32774: DOUBLE
32775: LD_VAR 0 6
32779: INC
32780: ST_TO_ADDR
32781: LD_INT 1
32783: PUSH
32784: FOR_DOWNTO
32785: IFFALSE 32873
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32787: LD_ADDR_VAR 0 7
32791: PUSH
32792: LD_VAR 0 7
32796: PUSH
32797: LD_INT 1
32799: ARRAY
32800: PPUSH
32801: LD_VAR 0 7
32805: PUSH
32806: LD_INT 2
32808: ARRAY
32809: PPUSH
32810: LD_VAR 0 6
32814: PPUSH
32815: CALL 32976 0 3
32819: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32820: LD_VAR 0 1
32824: PPUSH
32825: LD_VAR 0 7
32829: PUSH
32830: LD_INT 1
32832: ARRAY
32833: PPUSH
32834: LD_VAR 0 7
32838: PUSH
32839: LD_INT 2
32841: ARRAY
32842: PPUSH
32843: CALL 32880 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32847: LD_ADDR_VAR 0 6
32851: PUSH
32852: LD_VAR 0 6
32856: PPUSH
32857: LD_VAR 0 7
32861: PUSH
32862: LD_INT 3
32864: ARRAY
32865: PPUSH
32866: CALL_OW 3
32870: ST_TO_ADDR
// end ;
32871: GO 32784
32873: POP
32874: POP
// end ;
32875: LD_VAR 0 3
32879: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32880: LD_INT 0
32882: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32883: LD_VAR 0 2
32887: PPUSH
32888: LD_VAR 0 3
32892: PPUSH
32893: CALL_OW 351
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 554
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 488
32928: AND
32929: PUSH
32930: LD_VAR 0 2
32934: PPUSH
32935: LD_VAR 0 3
32939: PPUSH
32940: CALL_OW 428
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: EQUAL
32949: AND
32950: IFFALSE 32971
// AddComMoveXY ( bulldozer , x , y ) ;
32952: LD_VAR 0 1
32956: PPUSH
32957: LD_VAR 0 2
32961: PPUSH
32962: LD_VAR 0 3
32966: PPUSH
32967: CALL_OW 171
// end ;
32971: LD_VAR 0 4
32975: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32976: LD_INT 0
32978: PPUSH
32979: PPUSH
32980: PPUSH
32981: PPUSH
32982: PPUSH
32983: PPUSH
32984: PPUSH
// dist := 99999 ;
32985: LD_ADDR_VAR 0 6
32989: PUSH
32990: LD_INT 99999
32992: ST_TO_ADDR
// for i = 1 to list do
32993: LD_ADDR_VAR 0 5
32997: PUSH
32998: DOUBLE
32999: LD_INT 1
33001: DEC
33002: ST_TO_ADDR
33003: LD_VAR 0 3
33007: PUSH
33008: FOR_TO
33009: IFFALSE 33147
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33011: LD_ADDR_VAR 0 7
33015: PUSH
33016: LD_VAR 0 1
33020: PPUSH
33021: LD_VAR 0 2
33025: PPUSH
33026: LD_VAR 0 3
33030: PUSH
33031: LD_VAR 0 5
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: ARRAY
33040: PPUSH
33041: LD_VAR 0 3
33045: PUSH
33046: LD_VAR 0 5
33050: ARRAY
33051: PUSH
33052: LD_INT 2
33054: ARRAY
33055: PPUSH
33056: CALL_OW 298
33060: ST_TO_ADDR
// if d = 0 then
33061: LD_VAR 0 7
33065: PUSH
33066: LD_INT 0
33068: EQUAL
33069: IFFALSE 33073
// continue ;
33071: GO 33008
// if d < dist then
33073: LD_VAR 0 7
33077: PUSH
33078: LD_VAR 0 6
33082: LESS
33083: IFFALSE 33145
// begin _x := list [ i ] [ 1 ] ;
33085: LD_ADDR_VAR 0 8
33089: PUSH
33090: LD_VAR 0 3
33094: PUSH
33095: LD_VAR 0 5
33099: ARRAY
33100: PUSH
33101: LD_INT 1
33103: ARRAY
33104: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33105: LD_ADDR_VAR 0 9
33109: PUSH
33110: LD_VAR 0 3
33114: PUSH
33115: LD_VAR 0 5
33119: ARRAY
33120: PUSH
33121: LD_INT 2
33123: ARRAY
33124: ST_TO_ADDR
// _i := i ;
33125: LD_ADDR_VAR 0 10
33129: PUSH
33130: LD_VAR 0 5
33134: ST_TO_ADDR
// dist := d ;
33135: LD_ADDR_VAR 0 6
33139: PUSH
33140: LD_VAR 0 7
33144: ST_TO_ADDR
// end ; end ;
33145: GO 33008
33147: POP
33148: POP
// result := [ _x , _y , _i , dist ] ;
33149: LD_ADDR_VAR 0 4
33153: PUSH
33154: LD_VAR 0 8
33158: PUSH
33159: LD_VAR 0 9
33163: PUSH
33164: LD_VAR 0 10
33168: PUSH
33169: LD_VAR 0 6
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: ST_TO_ADDR
// end ;
33180: LD_VAR 0 4
33184: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33185: LD_INT 0
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
// for i = 1 to list do
33192: LD_ADDR_VAR 0 5
33196: PUSH
33197: DOUBLE
33198: LD_INT 1
33200: DEC
33201: ST_TO_ADDR
33202: LD_VAR 0 1
33206: PUSH
33207: FOR_TO
33208: IFFALSE 33522
// begin for j = list downto 2 do
33210: LD_ADDR_VAR 0 6
33214: PUSH
33215: DOUBLE
33216: LD_VAR 0 1
33220: INC
33221: ST_TO_ADDR
33222: LD_INT 2
33224: PUSH
33225: FOR_DOWNTO
33226: IFFALSE 33518
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33228: LD_VAR 0 2
33232: PPUSH
33233: LD_VAR 0 3
33237: PPUSH
33238: LD_VAR 0 1
33242: PUSH
33243: LD_VAR 0 6
33247: ARRAY
33248: PUSH
33249: LD_INT 1
33251: ARRAY
33252: PPUSH
33253: LD_VAR 0 1
33257: PUSH
33258: LD_VAR 0 6
33262: ARRAY
33263: PUSH
33264: LD_INT 2
33266: ARRAY
33267: PPUSH
33268: CALL_OW 298
33272: PUSH
33273: LD_VAR 0 2
33277: PPUSH
33278: LD_VAR 0 3
33282: PPUSH
33283: LD_VAR 0 1
33287: PUSH
33288: LD_VAR 0 6
33292: PUSH
33293: LD_INT 1
33295: MINUS
33296: ARRAY
33297: PUSH
33298: LD_INT 1
33300: ARRAY
33301: PPUSH
33302: LD_VAR 0 1
33306: PUSH
33307: LD_VAR 0 6
33311: PUSH
33312: LD_INT 1
33314: MINUS
33315: ARRAY
33316: PUSH
33317: LD_INT 2
33319: ARRAY
33320: PPUSH
33321: CALL_OW 298
33325: LESS
33326: IFFALSE 33516
// begin _x := list [ j ] [ 1 ] ;
33328: LD_ADDR_VAR 0 7
33332: PUSH
33333: LD_VAR 0 1
33337: PUSH
33338: LD_VAR 0 6
33342: ARRAY
33343: PUSH
33344: LD_INT 1
33346: ARRAY
33347: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33348: LD_ADDR_VAR 0 8
33352: PUSH
33353: LD_VAR 0 1
33357: PUSH
33358: LD_VAR 0 6
33362: ARRAY
33363: PUSH
33364: LD_INT 2
33366: ARRAY
33367: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33368: LD_ADDR_VAR 0 1
33372: PUSH
33373: LD_VAR 0 1
33377: PPUSH
33378: LD_VAR 0 6
33382: PPUSH
33383: LD_INT 1
33385: PPUSH
33386: LD_VAR 0 1
33390: PUSH
33391: LD_VAR 0 6
33395: PUSH
33396: LD_INT 1
33398: MINUS
33399: ARRAY
33400: PUSH
33401: LD_INT 1
33403: ARRAY
33404: PPUSH
33405: CALL 31146 0 4
33409: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33410: LD_ADDR_VAR 0 1
33414: PUSH
33415: LD_VAR 0 1
33419: PPUSH
33420: LD_VAR 0 6
33424: PPUSH
33425: LD_INT 2
33427: PPUSH
33428: LD_VAR 0 1
33432: PUSH
33433: LD_VAR 0 6
33437: PUSH
33438: LD_INT 1
33440: MINUS
33441: ARRAY
33442: PUSH
33443: LD_INT 2
33445: ARRAY
33446: PPUSH
33447: CALL 31146 0 4
33451: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33452: LD_ADDR_VAR 0 1
33456: PUSH
33457: LD_VAR 0 1
33461: PPUSH
33462: LD_VAR 0 6
33466: PUSH
33467: LD_INT 1
33469: MINUS
33470: PPUSH
33471: LD_INT 1
33473: PPUSH
33474: LD_VAR 0 7
33478: PPUSH
33479: CALL 31146 0 4
33483: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33484: LD_ADDR_VAR 0 1
33488: PUSH
33489: LD_VAR 0 1
33493: PPUSH
33494: LD_VAR 0 6
33498: PUSH
33499: LD_INT 1
33501: MINUS
33502: PPUSH
33503: LD_INT 2
33505: PPUSH
33506: LD_VAR 0 8
33510: PPUSH
33511: CALL 31146 0 4
33515: ST_TO_ADDR
// end ; end ;
33516: GO 33225
33518: POP
33519: POP
// end ;
33520: GO 33207
33522: POP
33523: POP
// result := list ;
33524: LD_ADDR_VAR 0 4
33528: PUSH
33529: LD_VAR 0 1
33533: ST_TO_ADDR
// end ;
33534: LD_VAR 0 4
33538: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33539: LD_INT 0
33541: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33542: LD_ADDR_VAR 0 5
33546: PUSH
33547: LD_VAR 0 1
33551: PPUSH
33552: LD_VAR 0 2
33556: PPUSH
33557: CALL_OW 546
33561: PUSH
33562: LD_INT 2
33564: ARRAY
33565: PUSH
33566: LD_VAR 0 3
33570: PPUSH
33571: LD_VAR 0 4
33575: PPUSH
33576: CALL_OW 546
33580: PUSH
33581: LD_INT 2
33583: ARRAY
33584: MINUS
33585: ST_TO_ADDR
// if result < 0 then
33586: LD_VAR 0 5
33590: PUSH
33591: LD_INT 0
33593: LESS
33594: IFFALSE 33611
// result := result * - 1 ;
33596: LD_ADDR_VAR 0 5
33600: PUSH
33601: LD_VAR 0 5
33605: PUSH
33606: LD_INT 1
33608: NEG
33609: MUL
33610: ST_TO_ADDR
// end ;
33611: LD_VAR 0 5
33615: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33616: LD_INT 0
33618: PPUSH
33619: PPUSH
// area = ListEnvironmentArea ( area ) ;
33620: LD_ADDR_VAR 0 2
33624: PUSH
33625: LD_VAR 0 2
33629: PPUSH
33630: CALL_OW 353
33634: ST_TO_ADDR
// if bulldozer > 0 then
33635: LD_VAR 0 1
33639: PUSH
33640: LD_INT 0
33642: GREATER
33643: IFFALSE 33754
// for i = area downto 1 do
33645: LD_ADDR_VAR 0 4
33649: PUSH
33650: DOUBLE
33651: LD_VAR 0 2
33655: INC
33656: ST_TO_ADDR
33657: LD_INT 1
33659: PUSH
33660: FOR_DOWNTO
33661: IFFALSE 33752
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33663: LD_VAR 0 2
33667: PUSH
33668: LD_VAR 0 4
33672: ARRAY
33673: PUSH
33674: LD_INT 1
33676: ARRAY
33677: PPUSH
33678: LD_VAR 0 2
33682: PUSH
33683: LD_VAR 0 4
33687: ARRAY
33688: PUSH
33689: LD_INT 2
33691: ARRAY
33692: PPUSH
33693: CALL_OW 351
33697: IFFALSE 33750
// if not HasTask ( bulldozer ) then
33699: LD_VAR 0 1
33703: PPUSH
33704: CALL_OW 314
33708: NOT
33709: IFFALSE 33750
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33711: LD_VAR 0 1
33715: PPUSH
33716: LD_VAR 0 2
33720: PUSH
33721: LD_VAR 0 4
33725: ARRAY
33726: PUSH
33727: LD_INT 1
33729: ARRAY
33730: PPUSH
33731: LD_VAR 0 2
33735: PUSH
33736: LD_VAR 0 4
33740: ARRAY
33741: PUSH
33742: LD_INT 2
33744: ARRAY
33745: PPUSH
33746: CALL_OW 171
33750: GO 33660
33752: POP
33753: POP
// end ;
33754: LD_VAR 0 3
33758: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33759: LD_INT 0
33761: PPUSH
33762: PPUSH
33763: PPUSH
33764: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33765: LD_ADDR_VAR 0 6
33769: PUSH
33770: LD_INT 22
33772: PUSH
33773: LD_VAR 0 1
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 21
33784: PUSH
33785: LD_VAR 0 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PPUSH
33798: CALL_OW 69
33802: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33803: LD_ADDR_VAR 0 7
33807: PUSH
33808: LD_VAR 0 3
33812: PPUSH
33813: LD_INT 22
33815: PUSH
33816: LD_VAR 0 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 21
33827: PUSH
33828: LD_VAR 0 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PPUSH
33841: CALL_OW 70
33845: ST_TO_ADDR
// if tmp and pom then
33846: LD_VAR 0 6
33850: PUSH
33851: LD_VAR 0 7
33855: AND
33856: IFFALSE 33876
// result := tmp diff pom else
33858: LD_ADDR_VAR 0 4
33862: PUSH
33863: LD_VAR 0 6
33867: PUSH
33868: LD_VAR 0 7
33872: DIFF
33873: ST_TO_ADDR
33874: GO 33884
// result := false ;
33876: LD_ADDR_VAR 0 4
33880: PUSH
33881: LD_INT 0
33883: ST_TO_ADDR
// end ;
33884: LD_VAR 0 4
33888: RET
// export function SavePosition ( unit ) ; begin
33889: LD_INT 0
33891: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33892: LD_VAR 0 1
33896: PPUSH
33897: LD_VAR 0 1
33901: PPUSH
33902: CALL_OW 250
33906: PPUSH
33907: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33911: LD_VAR 0 1
33915: PPUSH
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL_OW 251
33925: PPUSH
33926: CALL_OW 232
// end ;
33930: LD_VAR 0 2
33934: RET
// export function GetPosition ( unit ) ; begin
33935: LD_INT 0
33937: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33938: LD_ADDR_VAR 0 2
33942: PUSH
33943: LD_VAR 0 1
33947: PPUSH
33948: CALL_OW 252
33952: PUSH
33953: LD_VAR 0 1
33957: PPUSH
33958: CALL_OW 253
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: ST_TO_ADDR
// end ;
33967: LD_VAR 0 2
33971: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33972: LD_INT 0
33974: PPUSH
// if unit in unreachableList then
33975: LD_VAR 0 1
33979: PUSH
33980: LD_EXP 30
33984: IN
33985: IFFALSE 34003
// unreachableList := unreachableList diff unit ;
33987: LD_ADDR_EXP 30
33991: PUSH
33992: LD_EXP 30
33996: PUSH
33997: LD_VAR 0 1
34001: DIFF
34002: ST_TO_ADDR
// if ValidHex ( x , y ) then
34003: LD_VAR 0 2
34007: PPUSH
34008: LD_VAR 0 3
34012: PPUSH
34013: CALL_OW 488
34017: IFFALSE 34043
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34019: LD_VAR 0 1
34023: PPUSH
34024: LD_VAR 0 2
34028: PPUSH
34029: LD_VAR 0 3
34033: PPUSH
34034: CALL_OW 428
34038: PPUSH
34039: CALL_OW 115
// Wait ( 3 ) ;
34043: LD_INT 3
34045: PPUSH
34046: CALL_OW 67
// if unit in unreachableList then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 30
34059: IN
34060: IFFALSE 34072
// result := false else
34062: LD_ADDR_VAR 0 4
34066: PUSH
34067: LD_INT 0
34069: ST_TO_ADDR
34070: GO 34080
// result := true ;
34072: LD_ADDR_VAR 0 4
34076: PUSH
34077: LD_INT 1
34079: ST_TO_ADDR
// end ; end_of_file
34080: LD_VAR 0 4
34084: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34085: LD_EXP 31
34089: IFFALSE 34151
34091: GO 34093
34093: DISABLE
34094: LD_INT 0
34096: PPUSH
// begin enable ;
34097: ENABLE
// for i = 1 to mc_crates_list do
34098: LD_ADDR_VAR 0 1
34102: PUSH
34103: DOUBLE
34104: LD_INT 1
34106: DEC
34107: ST_TO_ADDR
34108: LD_EXP 32
34112: PUSH
34113: FOR_TO
34114: IFFALSE 34145
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34116: LD_EXP 32
34120: PUSH
34121: LD_VAR 0 1
34125: ARRAY
34126: PPUSH
34127: LD_INT 5
34129: PPUSH
34130: LD_INT 50
34132: PPUSH
34133: LD_INT 700
34135: PPUSH
34136: LD_INT 20
34138: PPUSH
34139: CALL 24501 0 5
34143: GO 34113
34145: POP
34146: POP
// MC_Game ( ) ;
34147: CALL 34154 0 0
// end ;
34151: PPOPN 1
34153: END
// export function MC_Game ( ) ; var i , side , un ; begin
34154: LD_INT 0
34156: PPUSH
34157: PPUSH
34158: PPUSH
34159: PPUSH
// if not isTest then
34160: LD_EXP 1
34164: NOT
34165: IFFALSE 34185
// MC_Show ( [ #tick , tick ] ) else
34167: LD_STRING #tick
34169: PUSH
34170: LD_OWVAR 1
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PPUSH
34179: CALL 8585 0 1
34183: GO 34194
// MC_Show ( debug_string ) ;
34185: LD_EXP 2
34189: PPUSH
34190: CALL 8585 0 1
// for side = 1 to 8 do
34194: LD_ADDR_VAR 0 3
34198: PUSH
34199: DOUBLE
34200: LD_INT 1
34202: DEC
34203: ST_TO_ADDR
34204: LD_INT 8
34206: PUSH
34207: FOR_TO
34208: IFFALSE 36208
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34210: LD_EXP 39
34214: PUSH
34215: LD_VAR 0 3
34219: ARRAY
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: PUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: EMPTY
34231: PPUSH
34232: CALL 11802 0 2
34236: PUSH
34237: LD_INT 0
34239: EQUAL
34240: OR
34241: IFFALSE 34245
// continue ;
34243: GO 34207
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34245: LD_VAR 0 3
34249: PPUSH
34250: LD_VAR 0 3
34254: PPUSH
34255: CALL 25022 0 1
34259: PPUSH
34260: CALL 36215 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34264: LD_EXP 71
34268: PUSH
34269: LD_VAR 0 3
34273: ARRAY
34274: PUSH
34275: LD_INT 1
34277: ARRAY
34278: PUSH
34279: LD_INT 0
34281: GREATER
34282: PUSH
34283: LD_EXP 69
34287: PUSH
34288: LD_VAR 0 3
34292: ARRAY
34293: PUSH
34294: LD_INT 1
34296: ARRAY
34297: PUSH
34298: LD_INT 0
34300: EQUAL
34301: AND
34302: PUSH
34303: LD_VAR 0 3
34307: PPUSH
34308: LD_INT 7
34310: PPUSH
34311: EMPTY
34312: PPUSH
34313: CALL 12370 0 3
34317: NOT
34318: AND
34319: IFFALSE 34356
// begin for i in MREG_Attackers [ side ] do
34321: LD_ADDR_VAR 0 2
34325: PUSH
34326: LD_EXP 71
34330: PUSH
34331: LD_VAR 0 3
34335: ARRAY
34336: PUSH
34337: FOR_IN
34338: IFFALSE 34354
// SetTag ( i , 7 ) ;
34340: LD_VAR 0 2
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: CALL_OW 109
34352: GO 34337
34354: POP
34355: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34356: LD_VAR 0 3
34360: PPUSH
34361: LD_INT 7
34363: PPUSH
34364: EMPTY
34365: PPUSH
34366: CALL 12370 0 3
34370: IFFALSE 34430
// begin if side = 1 then
34372: LD_VAR 0 3
34376: PUSH
34377: LD_INT 1
34379: EQUAL
34380: IFFALSE 34389
// RaiseSailEvent ( 101 ) ;
34382: LD_INT 101
34384: PPUSH
34385: CALL_OW 427
// if side = 4 then
34389: LD_VAR 0 3
34393: PUSH
34394: LD_INT 4
34396: EQUAL
34397: IFFALSE 34406
// RaiseSailEvent ( 102 ) ;
34399: LD_INT 102
34401: PPUSH
34402: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34406: LD_VAR 0 3
34410: PPUSH
34411: LD_VAR 0 3
34415: PPUSH
34416: LD_INT 7
34418: PPUSH
34419: EMPTY
34420: PPUSH
34421: CALL 12370 0 3
34425: PPUSH
34426: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34430: LD_VAR 0 3
34434: PPUSH
34435: CALL 18050 0 1
34439: PUSH
34440: LD_VAR 0 3
34444: PPUSH
34445: CALL 11706 0 1
34449: AND
34450: IFFALSE 34461
// MCL_Start ( side ) ;
34452: LD_VAR 0 3
34456: PPUSH
34457: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34461: LD_ADDR_EXP 35
34465: PUSH
34466: LD_EXP 35
34470: PPUSH
34471: LD_VAR 0 3
34475: PPUSH
34476: LD_VAR 0 3
34480: PPUSH
34481: CALL 19307 0 1
34485: PPUSH
34486: CALL_OW 1
34490: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34491: LD_ADDR_EXP 47
34495: PUSH
34496: LD_EXP 47
34500: PPUSH
34501: LD_VAR 0 3
34505: PPUSH
34506: LD_VAR 0 3
34510: PPUSH
34511: CALL 11120 0 1
34515: PPUSH
34516: CALL_OW 1
34520: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34521: LD_VAR 0 3
34525: PPUSH
34526: LD_INT 21
34528: PUSH
34529: LD_INT 2
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PPUSH
34536: CALL 11667 0 2
34540: IFFALSE 34551
// MCV_CheckStatus ( side ) ;
34542: LD_VAR 0 3
34546: PPUSH
34547: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34551: LD_VAR 0 3
34555: PPUSH
34556: LD_EXP 53
34560: PPUSH
34561: CALL 43015 0 2
34565: IFFALSE 34650
// begin for i = MREG_ToChangeClass downto 1 do
34567: LD_ADDR_VAR 0 2
34571: PUSH
34572: DOUBLE
34573: LD_EXP 53
34577: INC
34578: ST_TO_ADDR
34579: LD_INT 1
34581: PUSH
34582: FOR_DOWNTO
34583: IFFALSE 34648
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34585: LD_EXP 53
34589: PUSH
34590: LD_VAR 0 2
34594: ARRAY
34595: PUSH
34596: LD_INT 1
34598: ARRAY
34599: PUSH
34600: LD_VAR 0 3
34604: EQUAL
34605: IFFALSE 34646
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34607: LD_VAR 0 3
34611: PPUSH
34612: LD_EXP 53
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PUSH
34623: LD_INT 2
34625: ARRAY
34626: PPUSH
34627: LD_EXP 53
34631: PUSH
34632: LD_VAR 0 2
34636: ARRAY
34637: PUSH
34638: LD_INT 3
34640: ARRAY
34641: PPUSH
34642: CALL 16574 0 3
// end ; end ;
34646: GO 34582
34648: POP
34649: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34650: LD_INT 1
34652: PUSH
34653: LD_EXP 38
34657: PUSH
34658: LD_VAR 0 3
34662: ARRAY
34663: IN
34664: IFFALSE 34675
// begin MCN_TrainApe ( side ) ;
34666: LD_VAR 0 3
34670: PPUSH
34671: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_INT 30
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PPUSH
34690: CALL 11667 0 2
34694: IFFALSE 34868
// begin if MCF_Tag ( side , 10 , [ ] ) then
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12370 0 3
34710: IFFALSE 34757
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34712: LD_VAR 0 3
34716: PPUSH
34717: LD_INT 10
34719: PPUSH
34720: EMPTY
34721: PPUSH
34722: CALL 12370 0 3
34726: PPUSH
34727: LD_VAR 0 3
34731: PPUSH
34732: LD_INT 30
34734: PUSH
34735: LD_INT 3
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PPUSH
34742: CALL 11667 0 2
34746: PUSH
34747: LD_INT 1
34749: ARRAY
34750: PPUSH
34751: CALL_OW 168
// end else
34755: GO 34868
// if MREG_ToConstruct [ side ] then
34757: LD_EXP 51
34761: PUSH
34762: LD_VAR 0 3
34766: ARRAY
34767: IFFALSE 34868
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34769: LD_VAR 0 3
34773: PPUSH
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11667 0 2
34793: PUSH
34794: LD_INT 1
34796: ARRAY
34797: PPUSH
34798: LD_EXP 51
34802: PUSH
34803: LD_VAR 0 3
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PUSH
34813: LD_EXP 51
34817: PUSH
34818: LD_VAR 0 3
34822: ARRAY
34823: PUSH
34824: LD_INT 2
34826: ARRAY
34827: PUSH
34828: LD_EXP 51
34832: PUSH
34833: LD_VAR 0 3
34837: ARRAY
34838: PUSH
34839: LD_INT 3
34841: ARRAY
34842: PUSH
34843: LD_EXP 51
34847: PUSH
34848: LD_VAR 0 3
34852: ARRAY
34853: PUSH
34854: LD_INT 4
34856: ARRAY
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: PPUSH
34864: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34868: LD_VAR 0 3
34872: PPUSH
34873: LD_INT 30
34875: PUSH
34876: LD_INT 3
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PPUSH
34883: CALL 11667 0 2
34887: PUSH
34888: LD_VAR 0 3
34892: PPUSH
34893: LD_EXP 43
34897: PPUSH
34898: CALL 43015 0 2
34902: AND
34903: PUSH
34904: LD_INT 22
34906: PUSH
34907: LD_VAR 0 3
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: PUSH
34919: LD_INT 30
34921: PUSH
34922: LD_INT 33
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 30
34931: PUSH
34932: LD_INT 32
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 35
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: LIST
34958: PPUSH
34959: CALL_OW 69
34963: AND
34964: IFFALSE 34975
// MCV_Turret ( side ) ;
34966: LD_VAR 0 3
34970: PPUSH
34971: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34975: LD_EXP 42
34979: PUSH
34980: LD_VAR 0 3
34984: ARRAY
34985: PUSH
34986: LD_INT 1
34988: GREATER
34989: PUSH
34990: LD_VAR 0 3
34994: PPUSH
34995: CALL 25022 0 1
34999: PUSH
35000: LD_INT 0
35002: EQUAL
35003: AND
35004: IFFALSE 35166
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35006: LD_EXP 42
35010: PUSH
35011: LD_VAR 0 3
35015: ARRAY
35016: PUSH
35017: LD_INT 1
35019: ARRAY
35020: PPUSH
35021: CALL_OW 353
35025: IFFALSE 35063
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35027: LD_EXP 42
35031: PUSH
35032: LD_VAR 0 3
35036: ARRAY
35037: PUSH
35038: LD_INT 2
35040: ARRAY
35041: PPUSH
35042: LD_EXP 42
35046: PUSH
35047: LD_VAR 0 3
35051: ARRAY
35052: PUSH
35053: LD_INT 1
35055: ARRAY
35056: PPUSH
35057: CALL 32444 0 2
35061: GO 35166
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35063: LD_VAR 0 3
35067: PPUSH
35068: LD_INT 30
35070: PUSH
35071: LD_INT 3
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PPUSH
35078: CALL 11667 0 2
35082: IFFALSE 35166
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35084: LD_VAR 0 3
35088: PPUSH
35089: LD_INT 30
35091: PUSH
35092: LD_INT 3
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PPUSH
35099: CALL 11667 0 2
35103: PUSH
35104: LD_INT 1
35106: ARRAY
35107: PPUSH
35108: CALL_OW 461
35112: PUSH
35113: LD_INT 2
35115: EQUAL
35116: IFFALSE 35166
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35118: LD_EXP 42
35122: PUSH
35123: LD_VAR 0 3
35127: ARRAY
35128: PUSH
35129: LD_INT 2
35131: ARRAY
35132: PPUSH
35133: LD_INT 10
35135: PPUSH
35136: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35140: LD_ADDR_EXP 42
35144: PUSH
35145: LD_EXP 42
35149: PPUSH
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 0
35157: PUSH
35158: EMPTY
35159: LIST
35160: PPUSH
35161: CALL_OW 1
35165: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35166: LD_VAR 0 3
35170: PPUSH
35171: LD_INT 33
35173: PUSH
35174: LD_INT 2
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PPUSH
35181: CALL 11667 0 2
35185: IFFALSE 35225
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35187: LD_VAR 0 3
35191: PPUSH
35192: LD_VAR 0 3
35196: PPUSH
35197: LD_INT 33
35199: PUSH
35200: LD_INT 2
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PPUSH
35207: CALL 11667 0 2
35211: PUSH
35212: LD_INT 1
35214: ARRAY
35215: PPUSH
35216: CALL_OW 248
35220: PPUSH
35221: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35225: LD_EXP 47
35229: PUSH
35230: LD_VAR 0 3
35234: ARRAY
35235: IFFALSE 35248
// begin MCB_Repair ( side ) ;
35237: LD_VAR 0 3
35241: PPUSH
35242: CALL 11407 0 1
// end else
35246: GO 36161
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35248: LD_VAR 0 3
35252: PPUSH
35253: LD_EXP 49
35257: PPUSH
35258: CALL 43015 0 2
35262: PUSH
35263: LD_VAR 0 3
35267: PPUSH
35268: LD_EXP 40
35272: PPUSH
35273: CALL 43015 0 2
35277: AND
35278: IFFALSE 35486
// begin for i = 1 to MREG_ToUpLab do
35280: LD_ADDR_VAR 0 2
35284: PUSH
35285: DOUBLE
35286: LD_INT 1
35288: DEC
35289: ST_TO_ADDR
35290: LD_EXP 49
35294: PUSH
35295: FOR_TO
35296: IFFALSE 35482
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35298: LD_EXP 49
35302: PUSH
35303: LD_VAR 0 2
35307: ARRAY
35308: PUSH
35309: LD_INT 1
35311: ARRAY
35312: PUSH
35313: LD_VAR 0 3
35317: EQUAL
35318: IFFALSE 35480
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35320: LD_EXP 49
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: PUSH
35331: LD_INT 2
35333: ARRAY
35334: PUSH
35335: LD_EXP 49
35339: PUSH
35340: LD_VAR 0 2
35344: ARRAY
35345: PUSH
35346: LD_INT 3
35348: ARRAY
35349: AND
35350: IFFALSE 35478
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35352: LD_VAR 0 3
35356: PPUSH
35357: LD_EXP 49
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_INT 2
35370: ARRAY
35371: PPUSH
35372: LD_EXP 49
35376: PUSH
35377: LD_VAR 0 2
35381: ARRAY
35382: PUSH
35383: LD_INT 3
35385: ARRAY
35386: PPUSH
35387: CALL 8931 0 3
35391: IFFALSE 35478
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35393: LD_ADDR_EXP 49
35397: PUSH
35398: LD_EXP 49
35402: PPUSH
35403: LD_VAR 0 3
35407: PPUSH
35408: LD_EXP 49
35412: PUSH
35413: LD_VAR 0 2
35417: ARRAY
35418: PUSH
35419: LD_INT 2
35421: ARRAY
35422: PPUSH
35423: LD_EXP 49
35427: PUSH
35428: LD_VAR 0 2
35432: ARRAY
35433: PUSH
35434: LD_INT 3
35436: ARRAY
35437: PPUSH
35438: CALL 42067 0 4
35442: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35443: LD_ADDR_EXP 40
35447: PUSH
35448: LD_EXP 40
35452: PPUSH
35453: LD_VAR 0 3
35457: PPUSH
35458: LD_EXP 40
35462: PUSH
35463: LD_INT 1
35465: ARRAY
35466: PUSH
35467: LD_INT 2
35469: ARRAY
35470: PPUSH
35471: EMPTY
35472: PPUSH
35473: CALL 42067 0 4
35477: ST_TO_ADDR
// end ; break ;
35478: GO 35482
// end ;
35480: GO 35295
35482: POP
35483: POP
// end else
35484: GO 36161
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35486: LD_VAR 0 3
35490: PPUSH
35491: LD_EXP 48
35495: PPUSH
35496: CALL 43015 0 2
35500: IFFALSE 35574
// begin for i = 1 to MREG_ToUpdate do
35502: LD_ADDR_VAR 0 2
35506: PUSH
35507: DOUBLE
35508: LD_INT 1
35510: DEC
35511: ST_TO_ADDR
35512: LD_EXP 48
35516: PUSH
35517: FOR_TO
35518: IFFALSE 35570
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35520: LD_EXP 48
35524: PUSH
35525: LD_VAR 0 2
35529: ARRAY
35530: PUSH
35531: LD_INT 1
35533: ARRAY
35534: PUSH
35535: LD_VAR 0 3
35539: EQUAL
35540: IFFALSE 35568
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35542: LD_VAR 0 3
35546: PPUSH
35547: LD_EXP 48
35551: PUSH
35552: LD_VAR 0 2
35556: ARRAY
35557: PUSH
35558: LD_INT 2
35560: ARRAY
35561: PPUSH
35562: CALL 8767 0 2
// break ;
35566: GO 35570
// end ;
35568: GO 35517
35570: POP
35571: POP
// end else
35572: GO 36161
// if MCF_Get ( side , [ f_constructed ] ) then
35574: LD_VAR 0 3
35578: PPUSH
35579: LD_INT 57
35581: PUSH
35582: EMPTY
35583: LIST
35584: PPUSH
35585: CALL 11667 0 2
35589: IFFALSE 35622
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35591: LD_VAR 0 3
35595: PPUSH
35596: LD_VAR 0 3
35600: PPUSH
35601: LD_INT 57
35603: PUSH
35604: EMPTY
35605: LIST
35606: PPUSH
35607: CALL 11667 0 2
35611: PUSH
35612: LD_INT 1
35614: ARRAY
35615: PPUSH
35616: CALL 11011 0 2
35620: GO 36161
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35622: LD_VAR 0 3
35626: PPUSH
35627: LD_EXP 46
35631: PPUSH
35632: CALL 43015 0 2
35636: PUSH
35637: LD_VAR 0 3
35641: PPUSH
35642: CALL_OW 345
35646: NOT
35647: AND
35648: PUSH
35649: LD_VAR 0 3
35653: PPUSH
35654: CALL 25022 0 1
35658: PUSH
35659: LD_INT 0
35661: EQUAL
35662: AND
35663: IFFALSE 36062
// begin for i = 1 to MREG_ToBuild do
35665: LD_ADDR_VAR 0 2
35669: PUSH
35670: DOUBLE
35671: LD_INT 1
35673: DEC
35674: ST_TO_ADDR
35675: LD_EXP 46
35679: PUSH
35680: FOR_TO
35681: IFFALSE 36058
// if MREG_ToBuild [ i ] [ 1 ] = side then
35683: LD_EXP 46
35687: PUSH
35688: LD_VAR 0 2
35692: ARRAY
35693: PUSH
35694: LD_INT 1
35696: ARRAY
35697: PUSH
35698: LD_VAR 0 3
35702: EQUAL
35703: IFFALSE 36056
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35705: LD_OWVAR 84
35709: PUSH
35710: LD_EXP 46
35714: PUSH
35715: LD_VAR 0 2
35719: ARRAY
35720: PUSH
35721: LD_INT 3
35723: ARRAY
35724: PUSH
35725: LD_INT 1
35727: ARRAY
35728: PPUSH
35729: LD_EXP 46
35733: PUSH
35734: LD_VAR 0 2
35738: ARRAY
35739: PUSH
35740: LD_INT 3
35742: ARRAY
35743: PUSH
35744: LD_INT 2
35746: ARRAY
35747: PPUSH
35748: CALL_OW 351
35752: AND
35753: IFFALSE 35797
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35755: LD_EXP 46
35759: PUSH
35760: LD_VAR 0 2
35764: ARRAY
35765: PUSH
35766: LD_INT 3
35768: ARRAY
35769: PUSH
35770: LD_INT 1
35772: ARRAY
35773: PPUSH
35774: LD_EXP 46
35778: PUSH
35779: LD_VAR 0 2
35783: ARRAY
35784: PUSH
35785: LD_INT 3
35787: ARRAY
35788: PUSH
35789: LD_INT 2
35791: ARRAY
35792: PPUSH
35793: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35797: LD_EXP 46
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: PUSH
35808: LD_INT 2
35810: ARRAY
35811: PUSH
35812: LD_INT 0
35814: EQUAL
35815: IFFALSE 35885
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35817: LD_VAR 0 3
35821: PPUSH
35822: LD_EXP 46
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: PUSH
35833: LD_INT 3
35835: ARRAY
35836: PUSH
35837: LD_INT 1
35839: ARRAY
35840: PPUSH
35841: LD_EXP 46
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_INT 3
35854: ARRAY
35855: PUSH
35856: LD_INT 2
35858: ARRAY
35859: PPUSH
35860: LD_EXP 46
35864: PUSH
35865: LD_VAR 0 2
35869: ARRAY
35870: PUSH
35871: LD_INT 3
35873: ARRAY
35874: PUSH
35875: LD_INT 3
35877: ARRAY
35878: PPUSH
35879: CALL 8603 0 4
35883: GO 36054
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35885: LD_EXP 46
35889: PUSH
35890: LD_VAR 0 2
35894: ARRAY
35895: PUSH
35896: LD_INT 2
35898: ARRAY
35899: PUSH
35900: LD_INT 6
35902: EQUAL
35903: IFFALSE 35973
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35905: LD_VAR 0 3
35909: PPUSH
35910: LD_EXP 46
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PUSH
35921: LD_INT 3
35923: ARRAY
35924: PUSH
35925: LD_INT 1
35927: ARRAY
35928: PPUSH
35929: LD_EXP 46
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: PUSH
35940: LD_INT 3
35942: ARRAY
35943: PUSH
35944: LD_INT 2
35946: ARRAY
35947: PPUSH
35948: LD_EXP 46
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PUSH
35959: LD_INT 3
35961: ARRAY
35962: PUSH
35963: LD_INT 3
35965: ARRAY
35966: PPUSH
35967: CALL 8732 0 4
35971: GO 36054
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35973: LD_VAR 0 3
35977: PPUSH
35978: LD_EXP 46
35982: PUSH
35983: LD_VAR 0 2
35987: ARRAY
35988: PUSH
35989: LD_INT 2
35991: ARRAY
35992: PPUSH
35993: LD_EXP 46
35997: PUSH
35998: LD_VAR 0 2
36002: ARRAY
36003: PUSH
36004: LD_INT 3
36006: ARRAY
36007: PUSH
36008: LD_INT 1
36010: ARRAY
36011: PPUSH
36012: LD_EXP 46
36016: PUSH
36017: LD_VAR 0 2
36021: ARRAY
36022: PUSH
36023: LD_INT 3
36025: ARRAY
36026: PUSH
36027: LD_INT 2
36029: ARRAY
36030: PPUSH
36031: LD_EXP 46
36035: PUSH
36036: LD_VAR 0 2
36040: ARRAY
36041: PUSH
36042: LD_INT 3
36044: ARRAY
36045: PUSH
36046: LD_INT 3
36048: ARRAY
36049: PPUSH
36050: CALL 10236 0 5
// break ;
36054: GO 36058
// end ;
36056: GO 35680
36058: POP
36059: POP
// end else
36060: GO 36161
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36062: LD_VAR 0 3
36066: PPUSH
36067: LD_EXP 52
36071: PPUSH
36072: CALL 43015 0 2
36076: PUSH
36077: LD_VAR 0 3
36081: PPUSH
36082: CALL 25022 0 1
36086: PUSH
36087: LD_INT 0
36089: EQUAL
36090: AND
36091: IFFALSE 36161
// begin for i = 1 to MREG_ToDismantle do
36093: LD_ADDR_VAR 0 2
36097: PUSH
36098: DOUBLE
36099: LD_INT 1
36101: DEC
36102: ST_TO_ADDR
36103: LD_EXP 52
36107: PUSH
36108: FOR_TO
36109: IFFALSE 36159
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36111: LD_EXP 52
36115: PUSH
36116: LD_VAR 0 2
36120: ARRAY
36121: PUSH
36122: LD_INT 1
36124: ARRAY
36125: PUSH
36126: LD_VAR 0 3
36130: EQUAL
36131: IFFALSE 36157
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36133: LD_VAR 0 3
36137: PPUSH
36138: LD_EXP 52
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_INT 2
36151: ARRAY
36152: PPUSH
36153: CALL 10902 0 2
// end ;
36157: GO 36108
36159: POP
36160: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36161: LD_VAR 0 3
36165: PPUSH
36166: LD_INT 30
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PPUSH
36176: CALL 11667 0 2
36180: PUSH
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 25022 0 1
36190: PUSH
36191: LD_INT 0
36193: EQUAL
36194: AND
36195: IFFALSE 36206
// MCT_CollectCrates ( side ) ;
36197: LD_VAR 0 3
36201: PPUSH
36202: CALL 23961 0 1
// end ;
36206: GO 34207
36208: POP
36209: POP
// end ;
36210: LD_VAR 0 1
36214: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36215: LD_INT 0
36217: PPUSH
36218: PPUSH
36219: PPUSH
36220: PPUSH
36221: PPUSH
36222: PPUSH
36223: PPUSH
36224: PPUSH
36225: PPUSH
36226: PPUSH
36227: PPUSH
36228: PPUSH
36229: PPUSH
36230: PPUSH
36231: PPUSH
// all := MCF_All ( side , [ ] ) ;
36232: LD_ADDR_VAR 0 17
36236: PUSH
36237: LD_VAR 0 1
36241: PPUSH
36242: EMPTY
36243: PPUSH
36244: CALL 11802 0 2
36248: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36249: LD_ADDR_VAR 0 13
36253: PUSH
36254: LD_VAR 0 1
36258: PPUSH
36259: LD_INT 1
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL 11750 0 3
36268: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36269: LD_ADDR_VAR 0 14
36273: PUSH
36274: LD_VAR 0 1
36278: PPUSH
36279: LD_INT 2
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL 11750 0 3
36288: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36289: LD_ADDR_VAR 0 15
36293: PUSH
36294: LD_VAR 0 1
36298: PPUSH
36299: LD_INT 3
36301: PPUSH
36302: EMPTY
36303: PPUSH
36304: CALL 11750 0 3
36308: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36309: LD_ADDR_VAR 0 16
36313: PUSH
36314: LD_VAR 0 1
36318: PPUSH
36319: LD_INT 4
36321: PPUSH
36322: EMPTY
36323: PPUSH
36324: CALL 11750 0 3
36328: ST_TO_ADDR
// if mech then
36329: LD_VAR 0 15
36333: IFFALSE 36350
// mech := MCF_SortListDesc ( mech ) ;
36335: LD_ADDR_VAR 0 15
36339: PUSH
36340: LD_VAR 0 15
36344: PPUSH
36345: CALL 12916 0 1
36349: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36350: LD_EXP 56
36354: PUSH
36355: LD_VAR 0 1
36359: ARRAY
36360: PUSH
36361: LD_STRING 
36363: EQUAL
36364: NOT
36365: IFFALSE 36421
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36367: LD_EXP 56
36371: PUSH
36372: LD_VAR 0 1
36376: ARRAY
36377: PUSH
36378: LD_INT 1
36380: ARRAY
36381: PPUSH
36382: CALL_OW 257
36386: PUSH
36387: LD_INT 1
36389: EQUAL
36390: IFFALSE 36419
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36392: LD_VAR 0 1
36396: PPUSH
36397: LD_STRING ToArm
36399: PPUSH
36400: LD_EXP 56
36404: PUSH
36405: LD_VAR 0 1
36409: ARRAY
36410: PUSH
36411: LD_INT 1
36413: ARRAY
36414: PPUSH
36415: CALL 14546 0 3
// end else
36419: GO 36447
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36421: LD_ADDR_EXP 56
36425: PUSH
36426: LD_EXP 56
36430: PPUSH
36431: LD_VAR 0 1
36435: PPUSH
36436: LD_INT 1
36438: PPUSH
36439: LD_INT 0
36441: PPUSH
36442: CALL 31146 0 4
36446: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36447: LD_EXP 57
36451: PUSH
36452: LD_VAR 0 1
36456: ARRAY
36457: PUSH
36458: LD_STRING 
36460: EQUAL
36461: NOT
36462: IFFALSE 36518
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36464: LD_EXP 57
36468: PUSH
36469: LD_VAR 0 1
36473: ARRAY
36474: PUSH
36475: LD_INT 1
36477: ARRAY
36478: PPUSH
36479: CALL_OW 257
36483: PUSH
36484: LD_INT 2
36486: EQUAL
36487: IFFALSE 36516
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36489: LD_VAR 0 1
36493: PPUSH
36494: LD_STRING ToDep
36496: PPUSH
36497: LD_EXP 57
36501: PUSH
36502: LD_VAR 0 1
36506: ARRAY
36507: PUSH
36508: LD_INT 1
36510: ARRAY
36511: PPUSH
36512: CALL 14546 0 3
// end else
36516: GO 36544
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36518: LD_ADDR_EXP 57
36522: PUSH
36523: LD_EXP 57
36527: PPUSH
36528: LD_VAR 0 1
36532: PPUSH
36533: LD_INT 1
36535: PPUSH
36536: LD_INT 0
36538: PPUSH
36539: CALL 31146 0 4
36543: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36544: LD_EXP 55
36548: PUSH
36549: LD_VAR 0 1
36553: ARRAY
36554: PUSH
36555: LD_STRING 
36557: EQUAL
36558: NOT
36559: IFFALSE 36615
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36561: LD_EXP 55
36565: PUSH
36566: LD_VAR 0 1
36570: ARRAY
36571: PUSH
36572: LD_INT 1
36574: ARRAY
36575: PPUSH
36576: CALL_OW 257
36580: PUSH
36581: LD_INT 3
36583: EQUAL
36584: IFFALSE 36613
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36586: LD_VAR 0 1
36590: PPUSH
36591: LD_STRING ToFac
36593: PPUSH
36594: LD_EXP 55
36598: PUSH
36599: LD_VAR 0 1
36603: ARRAY
36604: PUSH
36605: LD_INT 1
36607: ARRAY
36608: PPUSH
36609: CALL 14546 0 3
// end else
36613: GO 36641
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36615: LD_ADDR_EXP 55
36619: PUSH
36620: LD_EXP 55
36624: PPUSH
36625: LD_VAR 0 1
36629: PPUSH
36630: LD_INT 1
36632: PPUSH
36633: LD_INT 0
36635: PPUSH
36636: CALL 31146 0 4
36640: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36641: LD_EXP 54
36645: PUSH
36646: LD_VAR 0 1
36650: ARRAY
36651: PUSH
36652: LD_STRING 
36654: EQUAL
36655: NOT
36656: IFFALSE 36712
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36658: LD_EXP 54
36662: PUSH
36663: LD_VAR 0 1
36667: ARRAY
36668: PUSH
36669: LD_INT 1
36671: ARRAY
36672: PPUSH
36673: CALL_OW 257
36677: PUSH
36678: LD_INT 4
36680: EQUAL
36681: IFFALSE 36710
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36683: LD_VAR 0 1
36687: PPUSH
36688: LD_STRING ToLab
36690: PPUSH
36691: LD_EXP 54
36695: PUSH
36696: LD_VAR 0 1
36700: ARRAY
36701: PUSH
36702: LD_INT 1
36704: ARRAY
36705: PPUSH
36706: CALL 14546 0 3
// end else
36710: GO 36738
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36712: LD_ADDR_EXP 54
36716: PUSH
36717: LD_EXP 54
36721: PPUSH
36722: LD_VAR 0 1
36726: PPUSH
36727: LD_INT 1
36729: PPUSH
36730: LD_INT 0
36732: PPUSH
36733: CALL 31146 0 4
36737: ST_TO_ADDR
// if mode = 0 then
36738: LD_VAR 0 2
36742: PUSH
36743: LD_INT 0
36745: EQUAL
36746: IFFALSE 38584
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36748: LD_VAR 0 1
36752: PPUSH
36753: LD_INT 30
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PPUSH
36763: CALL 11667 0 2
36767: PUSH
36768: LD_VAR 0 1
36772: PPUSH
36773: LD_INT 21
36775: PUSH
36776: LD_INT 3
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PPUSH
36783: CALL 11667 0 2
36787: PUSH
36788: LD_INT 1
36790: EQUAL
36791: AND
36792: IFFALSE 36857
// begin if all then
36794: LD_VAR 0 17
36798: IFFALSE 36855
// for i in ( all diff eng ) do
36800: LD_ADDR_VAR 0 4
36804: PUSH
36805: LD_VAR 0 17
36809: PUSH
36810: LD_VAR 0 14
36814: DIFF
36815: PUSH
36816: FOR_IN
36817: IFFALSE 36853
// if GetTag ( i ) = 0 then
36819: LD_VAR 0 4
36823: PPUSH
36824: CALL_OW 110
36828: PUSH
36829: LD_INT 0
36831: EQUAL
36832: IFFALSE 36851
// MCH_ChangeClass ( side , i , 2 ) ;
36834: LD_VAR 0 1
36838: PPUSH
36839: LD_VAR 0 4
36843: PPUSH
36844: LD_INT 2
36846: PPUSH
36847: CALL 16574 0 3
36851: GO 36816
36853: POP
36854: POP
// end else
36855: GO 37176
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36857: LD_VAR 0 13
36861: PUSH
36862: LD_EXP 56
36866: PUSH
36867: LD_VAR 0 1
36871: ARRAY
36872: PLUS
36873: PUSH
36874: LD_INT 22
36876: PUSH
36877: LD_VAR 0 1
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 30
36888: PUSH
36889: LD_INT 32
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PPUSH
36900: CALL_OW 69
36904: LESS
36905: IFFALSE 36930
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36907: LD_VAR 0 1
36911: PPUSH
36912: LD_VAR 0 14
36916: PUSH
36917: LD_INT 1
36919: ARRAY
36920: PPUSH
36921: LD_INT 1
36923: PPUSH
36924: CALL 16574 0 3
// end else
36928: GO 37176
// if sci < 6 and MCF_Lab ( side ) then
36930: LD_VAR 0 16
36934: PUSH
36935: LD_INT 6
36937: LESS
36938: PUSH
36939: LD_VAR 0 1
36943: PPUSH
36944: CALL 11706 0 1
36948: AND
36949: IFFALSE 37054
// begin if MREG_ToBunker [ side ] then
36951: LD_EXP 68
36955: PUSH
36956: LD_VAR 0 1
36960: ARRAY
36961: IFFALSE 36987
// tmp := sol diff MREG_ToBunker [ side ] else
36963: LD_ADDR_VAR 0 12
36967: PUSH
36968: LD_VAR 0 13
36972: PUSH
36973: LD_EXP 68
36977: PUSH
36978: LD_VAR 0 1
36982: ARRAY
36983: DIFF
36984: ST_TO_ADDR
36985: GO 36997
// tmp := sol ;
36987: LD_ADDR_VAR 0 12
36991: PUSH
36992: LD_VAR 0 13
36996: ST_TO_ADDR
// if tmp then
36997: LD_VAR 0 12
37001: IFFALSE 37052
// for i in tmp do
37003: LD_ADDR_VAR 0 4
37007: PUSH
37008: LD_VAR 0 12
37012: PUSH
37013: FOR_IN
37014: IFFALSE 37050
// if GetTag ( i ) = 0 then
37016: LD_VAR 0 4
37020: PPUSH
37021: CALL_OW 110
37025: PUSH
37026: LD_INT 0
37028: EQUAL
37029: IFFALSE 37048
// MCH_ChangeClass ( side , i , 4 ) ;
37031: LD_VAR 0 1
37035: PPUSH
37036: LD_VAR 0 4
37040: PPUSH
37041: LD_INT 4
37043: PPUSH
37044: CALL 16574 0 3
37048: GO 37013
37050: POP
37051: POP
// end else
37052: GO 37176
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37054: LD_VAR 0 1
37058: PPUSH
37059: LD_INT 30
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PPUSH
37069: CALL 11667 0 2
37073: IFFALSE 37176
// begin if MREG_ToBunker [ side ] then
37075: LD_EXP 68
37079: PUSH
37080: LD_VAR 0 1
37084: ARRAY
37085: IFFALSE 37111
// tmp := sol diff MREG_ToBunker [ side ] else
37087: LD_ADDR_VAR 0 12
37091: PUSH
37092: LD_VAR 0 13
37096: PUSH
37097: LD_EXP 68
37101: PUSH
37102: LD_VAR 0 1
37106: ARRAY
37107: DIFF
37108: ST_TO_ADDR
37109: GO 37121
// tmp := sol ;
37111: LD_ADDR_VAR 0 12
37115: PUSH
37116: LD_VAR 0 13
37120: ST_TO_ADDR
// if tmp then
37121: LD_VAR 0 12
37125: IFFALSE 37176
// for i in tmp do
37127: LD_ADDR_VAR 0 4
37131: PUSH
37132: LD_VAR 0 12
37136: PUSH
37137: FOR_IN
37138: IFFALSE 37174
// if GetTag ( i ) = 0 then
37140: LD_VAR 0 4
37144: PPUSH
37145: CALL_OW 110
37149: PUSH
37150: LD_INT 0
37152: EQUAL
37153: IFFALSE 37172
// MCH_ChangeClass ( side , i , 2 ) ;
37155: LD_VAR 0 1
37159: PPUSH
37160: LD_VAR 0 4
37164: PPUSH
37165: LD_INT 2
37167: PPUSH
37168: CALL 16574 0 3
37172: GO 37137
37174: POP
37175: POP
// end ; if MCF_Lab ( side ) then
37176: LD_VAR 0 1
37180: PPUSH
37181: CALL 11706 0 1
37185: IFFALSE 37725
// begin if MCL_GetTechList ( side ) then
37187: LD_VAR 0 1
37191: PPUSH
37192: CALL 18050 0 1
37196: IFFALSE 37322
// begin if MREG_ToLab [ side ] then
37198: LD_EXP 54
37202: PUSH
37203: LD_VAR 0 1
37207: ARRAY
37208: IFFALSE 37228
// k := MREG_ToLab [ side ] else
37210: LD_ADDR_VAR 0 8
37214: PUSH
37215: LD_EXP 54
37219: PUSH
37220: LD_VAR 0 1
37224: ARRAY
37225: ST_TO_ADDR
37226: GO 37236
// k := 0 ;
37228: LD_ADDR_VAR 0 8
37232: PUSH
37233: LD_INT 0
37235: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37236: LD_VAR 0 16
37240: PUSH
37241: LD_VAR 0 8
37245: PLUS
37246: PUSH
37247: LD_INT 6
37249: LESSEQUAL
37250: PUSH
37251: LD_VAR 0 17
37255: PUSH
37256: LD_INT 6
37258: GREATER
37259: AND
37260: IFFALSE 37276
// MCH_TrainScientist ( side , 1 ) else
37262: LD_VAR 0 1
37266: PPUSH
37267: LD_INT 1
37269: PPUSH
37270: CALL 16126 0 2
37274: GO 37320
// if all < 6 then
37276: LD_VAR 0 17
37280: PUSH
37281: LD_INT 6
37283: LESS
37284: IFFALSE 37320
// if sci + k < all / 2 then
37286: LD_VAR 0 16
37290: PUSH
37291: LD_VAR 0 8
37295: PLUS
37296: PUSH
37297: LD_VAR 0 17
37301: PUSH
37302: LD_INT 2
37304: DIVREAL
37305: LESS
37306: IFFALSE 37320
// MCH_TrainScientist ( side , 1 ) ;
37308: LD_VAR 0 1
37312: PPUSH
37313: LD_INT 1
37315: PPUSH
37316: CALL 16126 0 2
// end else
37320: GO 37398
// begin if sci > 2 then
37322: LD_VAR 0 16
37326: PUSH
37327: LD_INT 2
37329: GREATER
37330: IFFALSE 37398
// for i = sci downto 2 do
37332: LD_ADDR_VAR 0 4
37336: PUSH
37337: DOUBLE
37338: LD_VAR 0 16
37342: INC
37343: ST_TO_ADDR
37344: LD_INT 2
37346: PUSH
37347: FOR_DOWNTO
37348: IFFALSE 37396
// if GetTag ( sci [ i ] ) = 0 then
37350: LD_VAR 0 16
37354: PUSH
37355: LD_VAR 0 4
37359: ARRAY
37360: PPUSH
37361: CALL_OW 110
37365: PUSH
37366: LD_INT 0
37368: EQUAL
37369: IFFALSE 37394
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37371: LD_VAR 0 1
37375: PPUSH
37376: LD_VAR 0 16
37380: PUSH
37381: LD_VAR 0 4
37385: ARRAY
37386: PPUSH
37387: LD_INT 2
37389: PPUSH
37390: CALL 16574 0 3
37394: GO 37347
37396: POP
37397: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37398: LD_VAR 0 1
37402: PPUSH
37403: CALL 18050 0 1
37407: PUSH
37408: LD_VAR 0 1
37412: PPUSH
37413: CALL 11706 0 1
37417: AND
37418: PUSH
37419: LD_EXP 35
37423: PUSH
37424: LD_VAR 0 1
37428: ARRAY
37429: NOT
37430: AND
37431: IFFALSE 37725
// begin for j = 1 to MCF_Lab ( side ) do
37433: LD_ADDR_VAR 0 5
37437: PUSH
37438: DOUBLE
37439: LD_INT 1
37441: DEC
37442: ST_TO_ADDR
37443: LD_VAR 0 1
37447: PPUSH
37448: CALL 11706 0 1
37452: PUSH
37453: FOR_TO
37454: IFFALSE 37514
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37456: LD_VAR 0 1
37460: PPUSH
37461: CALL 11706 0 1
37465: PUSH
37466: LD_VAR 0 5
37470: ARRAY
37471: PPUSH
37472: CALL_OW 461
37476: PUSH
37477: LD_INT 3
37479: PUSH
37480: LD_INT 6
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: IN
37487: IFFALSE 37512
// begin b := MCF_Lab ( side ) [ j ] ;
37489: LD_ADDR_VAR 0 11
37493: PUSH
37494: LD_VAR 0 1
37498: PPUSH
37499: CALL 11706 0 1
37503: PUSH
37504: LD_VAR 0 5
37508: ARRAY
37509: ST_TO_ADDR
// break ;
37510: GO 37514
// end ;
37512: GO 37453
37514: POP
37515: POP
// if MCF_Class ( side , 4 , [ ] ) then
37516: LD_VAR 0 1
37520: PPUSH
37521: LD_INT 4
37523: PPUSH
37524: EMPTY
37525: PPUSH
37526: CALL 11750 0 3
37530: IFFALSE 37725
// for j in MCF_Class ( side , 4 , [ ] ) do
37532: LD_ADDR_VAR 0 5
37536: PUSH
37537: LD_VAR 0 1
37541: PPUSH
37542: LD_INT 4
37544: PPUSH
37545: EMPTY
37546: PPUSH
37547: CALL 11750 0 3
37551: PUSH
37552: FOR_IN
37553: IFFALSE 37723
// begin if GetTag ( j ) = 0 then
37555: LD_VAR 0 5
37559: PPUSH
37560: CALL_OW 110
37564: PUSH
37565: LD_INT 0
37567: EQUAL
37568: IFFALSE 37659
// begin if IsInUnit ( j ) and b then
37570: LD_VAR 0 5
37574: PPUSH
37575: CALL_OW 310
37579: PUSH
37580: LD_VAR 0 11
37584: AND
37585: IFFALSE 37633
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 310
37596: PPUSH
37597: CALL_OW 461
37601: PUSH
37602: LD_INT 2
37604: EQUAL
37605: PUSH
37606: LD_VAR 0 5
37610: PPUSH
37611: CALL_OW 310
37615: PUSH
37616: LD_VAR 0 11
37620: NONEQUAL
37621: AND
37622: IFFALSE 37633
// ComExitBuilding ( j ) ;
37624: LD_VAR 0 5
37628: PPUSH
37629: CALL_OW 122
// if not IsInUnit ( j ) then
37633: LD_VAR 0 5
37637: PPUSH
37638: CALL_OW 310
37642: NOT
37643: IFFALSE 37659
// ComEnterUnit ( j , b ) ;
37645: LD_VAR 0 5
37649: PPUSH
37650: LD_VAR 0 11
37654: PPUSH
37655: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37659: LD_INT 1
37661: PPUSH
37662: LD_VAR 0 5
37666: PPUSH
37667: CALL_OW 255
37671: PPUSH
37672: CALL_OW 321
37676: PUSH
37677: LD_INT 2
37679: EQUAL
37680: PUSH
37681: LD_VAR 0 5
37685: PPUSH
37686: CALL_OW 255
37690: PPUSH
37691: CALL 25022 0 1
37695: PUSH
37696: LD_INT 0
37698: EQUAL
37699: AND
37700: IFFALSE 37721
// MCN_Tame ( GetSide ( j ) , j ) ;
37702: LD_VAR 0 5
37706: PPUSH
37707: CALL_OW 255
37711: PPUSH
37712: LD_VAR 0 5
37716: PPUSH
37717: CALL 18569 0 2
// end ;
37721: GO 37552
37723: POP
37724: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37725: LD_VAR 0 1
37729: PPUSH
37730: LD_INT 30
37732: PUSH
37733: LD_INT 3
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PPUSH
37740: CALL 11667 0 2
37744: IFFALSE 38003
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37746: LD_ADDR_VAR 0 11
37750: PUSH
37751: LD_VAR 0 1
37755: PPUSH
37756: LD_INT 30
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PPUSH
37766: CALL 11667 0 2
37770: PUSH
37771: LD_INT 1
37773: ARRAY
37774: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37775: LD_ADDR_VAR 0 12
37779: PUSH
37780: LD_VAR 0 1
37784: PPUSH
37785: LD_INT 0
37787: PPUSH
37788: LD_INT 25
37790: PUSH
37791: LD_INT 3
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PPUSH
37798: CALL 12370 0 3
37802: ST_TO_ADDR
// for i = 1 to tmp do
37803: LD_ADDR_VAR 0 4
37807: PUSH
37808: DOUBLE
37809: LD_INT 1
37811: DEC
37812: ST_TO_ADDR
37813: LD_VAR 0 12
37817: PUSH
37818: FOR_TO
37819: IFFALSE 37879
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37821: LD_VAR 0 12
37825: PUSH
37826: LD_VAR 0 4
37830: ARRAY
37831: PPUSH
37832: CALL_OW 310
37836: NOT
37837: PUSH
37838: LD_VAR 0 12
37842: PUSH
37843: LD_VAR 0 4
37847: ARRAY
37848: PPUSH
37849: CALL_OW 314
37853: NOT
37854: AND
37855: IFFALSE 37877
// ComEnterUnit ( tmp [ i ] , b ) ;
37857: LD_VAR 0 12
37861: PUSH
37862: LD_VAR 0 4
37866: ARRAY
37867: PPUSH
37868: LD_VAR 0 11
37872: PPUSH
37873: CALL_OW 120
37877: GO 37818
37879: POP
37880: POP
// if MREG_ToFac [ side ] then
37881: LD_EXP 55
37885: PUSH
37886: LD_VAR 0 1
37890: ARRAY
37891: IFFALSE 37911
// k := MREG_ToFac [ side ] else
37893: LD_ADDR_VAR 0 8
37897: PUSH
37898: LD_EXP 55
37902: PUSH
37903: LD_VAR 0 1
37907: ARRAY
37908: ST_TO_ADDR
37909: GO 37919
// k := 0 ;
37911: LD_ADDR_VAR 0 8
37915: PUSH
37916: LD_INT 0
37918: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37919: LD_VAR 0 15
37923: PUSH
37924: LD_VAR 0 8
37928: PLUS
37929: PUSH
37930: LD_INT 6
37932: LESSEQUAL
37933: PUSH
37934: LD_VAR 0 17
37938: PUSH
37939: LD_INT 6
37941: GREATER
37942: AND
37943: IFFALSE 37959
// MCH_TrainMechanic ( side , 1 ) else
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 1
37952: PPUSH
37953: CALL 15868 0 2
37957: GO 38003
// if all < 6 then
37959: LD_VAR 0 17
37963: PUSH
37964: LD_INT 6
37966: LESS
37967: IFFALSE 38003
// if mech + k < all / 2 then
37969: LD_VAR 0 15
37973: PUSH
37974: LD_VAR 0 8
37978: PLUS
37979: PUSH
37980: LD_VAR 0 17
37984: PUSH
37985: LD_INT 2
37987: DIVREAL
37988: LESS
37989: IFFALSE 38003
// MCH_TrainMechanic ( side , 1 ) ;
37991: LD_VAR 0 1
37995: PPUSH
37996: LD_INT 1
37998: PPUSH
37999: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38003: LD_ADDR_VAR 0 10
38007: PUSH
38008: LD_VAR 0 1
38012: PPUSH
38013: LD_INT 30
38015: PUSH
38016: LD_INT 36
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PPUSH
38023: CALL 11667 0 2
38027: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38028: LD_VAR 0 10
38032: PUSH
38033: LD_VAR 0 15
38037: AND
38038: PUSH
38039: LD_VAR 0 1
38043: PPUSH
38044: LD_INT 3
38046: PPUSH
38047: EMPTY
38048: PPUSH
38049: CALL 11750 0 3
38053: AND
38054: IFFALSE 38212
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38056: LD_VAR 0 1
38060: PPUSH
38061: LD_INT 9
38063: PPUSH
38064: EMPTY
38065: PPUSH
38066: CALL 12370 0 3
38070: PUSH
38071: LD_INT 3
38073: LESS
38074: IFFALSE 38212
// begin if mech < 3 then
38076: LD_VAR 0 15
38080: PUSH
38081: LD_INT 3
38083: LESS
38084: IFFALSE 38098
// k := mech else
38086: LD_ADDR_VAR 0 8
38090: PUSH
38091: LD_VAR 0 15
38095: ST_TO_ADDR
38096: GO 38106
// k := 3 ;
38098: LD_ADDR_VAR 0 8
38102: PUSH
38103: LD_INT 3
38105: ST_TO_ADDR
// for j = 1 to k do
38106: LD_ADDR_VAR 0 5
38110: PUSH
38111: DOUBLE
38112: LD_INT 1
38114: DEC
38115: ST_TO_ADDR
38116: LD_VAR 0 8
38120: PUSH
38121: FOR_TO
38122: IFFALSE 38180
// if GetClass ( mech [ j ] ) = 3 then
38124: LD_VAR 0 15
38128: PUSH
38129: LD_VAR 0 5
38133: ARRAY
38134: PPUSH
38135: CALL_OW 257
38139: PUSH
38140: LD_INT 3
38142: EQUAL
38143: IFFALSE 38178
// begin SetTag ( mech [ j ] , 9 ) ;
38145: LD_VAR 0 15
38149: PUSH
38150: LD_VAR 0 5
38154: ARRAY
38155: PPUSH
38156: LD_INT 9
38158: PPUSH
38159: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38163: LD_VAR 0 15
38167: PUSH
38168: LD_VAR 0 5
38172: ARRAY
38173: PPUSH
38174: CALL_OW 122
// end ;
38178: GO 38121
38180: POP
38181: POP
// if mech < 6 + k then
38182: LD_VAR 0 15
38186: PUSH
38187: LD_INT 6
38189: PUSH
38190: LD_VAR 0 8
38194: PLUS
38195: LESS
38196: IFFALSE 38212
// MCH_TrainMechanic ( side , k ) ;
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_VAR 0 8
38207: PPUSH
38208: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38212: LD_VAR 0 1
38216: PPUSH
38217: LD_INT 9
38219: PPUSH
38220: EMPTY
38221: PPUSH
38222: CALL 12370 0 3
38226: IFFALSE 38317
// for j in MCF_Tag ( side , 9 , [ ] ) do
38228: LD_ADDR_VAR 0 5
38232: PUSH
38233: LD_VAR 0 1
38237: PPUSH
38238: LD_INT 9
38240: PPUSH
38241: EMPTY
38242: PPUSH
38243: CALL 12370 0 3
38247: PUSH
38248: FOR_IN
38249: IFFALSE 38315
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38251: LD_VAR 0 5
38255: PPUSH
38256: CALL_OW 310
38260: NOT
38261: PUSH
38262: LD_VAR 0 5
38266: PPUSH
38267: CALL 98412 0 1
38271: NOT
38272: AND
38273: IFFALSE 38313
// if ct then
38275: LD_VAR 0 10
38279: IFFALSE 38301
// ComEnterUnit ( j , ct [ 1 ] ) else
38281: LD_VAR 0 5
38285: PPUSH
38286: LD_VAR 0 10
38290: PUSH
38291: LD_INT 1
38293: ARRAY
38294: PPUSH
38295: CALL_OW 120
38299: GO 38313
// SetTag ( j , 0 ) ;
38301: LD_VAR 0 5
38305: PPUSH
38306: LD_INT 0
38308: PPUSH
38309: CALL_OW 109
38313: GO 38248
38315: POP
38316: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38317: LD_INT 1
38319: PPUSH
38320: LD_VAR 0 1
38324: PPUSH
38325: CALL_OW 321
38329: PUSH
38330: LD_INT 2
38332: EQUAL
38333: PUSH
38334: LD_EXP 35
38338: PUSH
38339: LD_VAR 0 1
38343: ARRAY
38344: NOT
38345: AND
38346: PUSH
38347: LD_VAR 0 1
38351: PPUSH
38352: LD_INT 4
38354: PPUSH
38355: EMPTY
38356: PPUSH
38357: CALL 11750 0 3
38361: AND
38362: IFFALSE 38410
// for j in MCF_Class ( side , 4 , [ ] ) do
38364: LD_ADDR_VAR 0 5
38368: PUSH
38369: LD_VAR 0 1
38373: PPUSH
38374: LD_INT 4
38376: PPUSH
38377: EMPTY
38378: PPUSH
38379: CALL 11750 0 3
38383: PUSH
38384: FOR_IN
38385: IFFALSE 38408
// MCN_Tame ( GetSide ( j ) , j ) ;
38387: LD_VAR 0 5
38391: PPUSH
38392: CALL_OW 255
38396: PPUSH
38397: LD_VAR 0 5
38401: PPUSH
38402: CALL 18569 0 2
38406: GO 38384
38408: POP
38409: POP
// if MREG_DefVeh [ side ] then
38410: LD_EXP 67
38414: PUSH
38415: LD_VAR 0 1
38419: ARRAY
38420: IFFALSE 38584
// begin for i in MREG_DefVeh [ side ] do
38422: LD_ADDR_VAR 0 4
38426: PUSH
38427: LD_EXP 67
38431: PUSH
38432: LD_VAR 0 1
38436: ARRAY
38437: PUSH
38438: FOR_IN
38439: IFFALSE 38492
// begin SetTag ( i , 0 ) ;
38441: LD_VAR 0 4
38445: PPUSH
38446: LD_INT 0
38448: PPUSH
38449: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38453: LD_VAR 0 4
38457: PPUSH
38458: LD_EXP 64
38462: PUSH
38463: LD_VAR 0 1
38467: ARRAY
38468: PPUSH
38469: CALL_OW 308
38473: NOT
38474: IFFALSE 38490
// MCV_Parking ( side , i ) ;
38476: LD_VAR 0 1
38480: PPUSH
38481: LD_VAR 0 4
38485: PPUSH
38486: CALL 25757 0 2
// end ;
38490: GO 38438
38492: POP
38493: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38494: LD_VAR 0 1
38498: PPUSH
38499: LD_INT 36
38501: PPUSH
38502: EMPTY
38503: PPUSH
38504: CALL 12370 0 3
38508: IFFALSE 38549
// for i in MCF_Tag ( side , 36 , [ ] ) do
38510: LD_ADDR_VAR 0 4
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: LD_INT 36
38522: PPUSH
38523: EMPTY
38524: PPUSH
38525: CALL 12370 0 3
38529: PUSH
38530: FOR_IN
38531: IFFALSE 38547
// SetTag ( i , 0 ) ;
38533: LD_VAR 0 4
38537: PPUSH
38538: LD_INT 0
38540: PPUSH
38541: CALL_OW 109
38545: GO 38530
38547: POP
38548: POP
// if MREG_DefMobActive [ side ] then
38549: LD_EXP 70
38553: PUSH
38554: LD_VAR 0 1
38558: ARRAY
38559: IFFALSE 38584
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38561: LD_ADDR_EXP 70
38565: PUSH
38566: LD_EXP 70
38570: PPUSH
38571: LD_VAR 0 1
38575: PPUSH
38576: LD_INT 0
38578: PPUSH
38579: CALL_OW 1
38583: ST_TO_ADDR
// end ; end ; if mode > 0 then
38584: LD_VAR 0 2
38588: PUSH
38589: LD_INT 0
38591: GREATER
38592: IFFALSE 40487
// begin if tick <= 15 15$00 then
38594: LD_OWVAR 1
38598: PUSH
38599: LD_INT 31500
38601: LESSEQUAL
38602: IFFALSE 38906
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38604: LD_VAR 0 13
38608: PUSH
38609: LD_VAR 0 1
38613: PPUSH
38614: CALL 25022 0 1
38618: PUSH
38619: LD_INT 4
38621: LESS
38622: AND
38623: IFFALSE 38734
// begin for i in sol do
38625: LD_ADDR_VAR 0 4
38629: PUSH
38630: LD_VAR 0 13
38634: PUSH
38635: FOR_IN
38636: IFFALSE 38732
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38638: LD_ADDR_VAR 0 8
38642: PUSH
38643: LD_VAR 0 1
38647: PPUSH
38648: CALL 25022 0 1
38652: PPUSH
38653: LD_VAR 0 4
38657: PPUSH
38658: CALL_OW 74
38662: ST_TO_ADDR
// if IsInUnit ( i ) then
38663: LD_VAR 0 4
38667: PPUSH
38668: CALL_OW 310
38672: IFFALSE 38683
// ComExitBuilding ( i ) ;
38674: LD_VAR 0 4
38678: PPUSH
38679: CALL_OW 122
// if not HasTask ( i ) and k then
38683: LD_VAR 0 4
38687: PPUSH
38688: CALL_OW 314
38692: NOT
38693: PUSH
38694: LD_VAR 0 8
38698: AND
38699: IFFALSE 38730
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38701: LD_VAR 0 4
38705: PPUSH
38706: LD_VAR 0 8
38710: PPUSH
38711: CALL_OW 250
38715: PPUSH
38716: LD_VAR 0 8
38720: PPUSH
38721: CALL_OW 251
38725: PPUSH
38726: CALL_OW 174
// end ;
38730: GO 38635
38732: POP
38733: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38734: LD_VAR 0 1
38738: PPUSH
38739: LD_INT 30
38741: PUSH
38742: LD_INT 5
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PPUSH
38749: CALL 11667 0 2
38753: IFFALSE 38904
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38755: LD_ADDR_VAR 0 11
38759: PUSH
38760: LD_VAR 0 1
38764: PPUSH
38765: LD_INT 30
38767: PUSH
38768: LD_INT 5
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PPUSH
38775: CALL 11667 0 2
38779: PUSH
38780: LD_INT 1
38782: ARRAY
38783: ST_TO_ADDR
// if mech then
38784: LD_VAR 0 15
38788: IFFALSE 38824
// for i in mech do
38790: LD_ADDR_VAR 0 4
38794: PUSH
38795: LD_VAR 0 15
38799: PUSH
38800: FOR_IN
38801: IFFALSE 38822
// MCH_ChangeClass ( side , i , 1 ) ;
38803: LD_VAR 0 1
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_INT 1
38815: PPUSH
38816: CALL 16574 0 3
38820: GO 38800
38822: POP
38823: POP
// if eng > 1 then
38824: LD_VAR 0 14
38828: PUSH
38829: LD_INT 1
38831: GREATER
38832: IFFALSE 38879
// for i = eng downto 2 do
38834: LD_ADDR_VAR 0 4
38838: PUSH
38839: DOUBLE
38840: LD_VAR 0 14
38844: INC
38845: ST_TO_ADDR
38846: LD_INT 2
38848: PUSH
38849: FOR_DOWNTO
38850: IFFALSE 38877
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38852: LD_VAR 0 1
38856: PPUSH
38857: LD_VAR 0 14
38861: PUSH
38862: LD_VAR 0 4
38866: ARRAY
38867: PPUSH
38868: LD_INT 1
38870: PPUSH
38871: CALL 16574 0 3
38875: GO 38849
38877: POP
38878: POP
// if UnitsInside ( b ) then
38879: LD_VAR 0 11
38883: PPUSH
38884: CALL_OW 313
38888: IFFALSE 38904
// ComExitBuilding ( UnitsInside ( b ) ) ;
38890: LD_VAR 0 11
38894: PPUSH
38895: CALL_OW 313
38899: PPUSH
38900: CALL_OW 122
// end ; end else
38904: GO 40487
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38906: LD_VAR 0 1
38910: PPUSH
38911: LD_INT 1
38913: PPUSH
38914: LD_EXP 65
38918: PUSH
38919: LD_VAR 0 1
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: ARRAY
38928: PPUSH
38929: CALL 33759 0 3
38933: IFFALSE 39072
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38935: LD_ADDR_VAR 0 12
38939: PUSH
38940: LD_VAR 0 1
38944: PPUSH
38945: LD_INT 21
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PPUSH
38955: CALL 11667 0 2
38959: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38960: LD_ADDR_VAR 0 11
38964: PUSH
38965: LD_VAR 0 1
38969: PPUSH
38970: LD_INT 30
38972: PUSH
38973: LD_INT 1
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PPUSH
38980: CALL 11667 0 2
38984: ST_TO_ADDR
// if b then
38985: LD_VAR 0 11
38989: IFFALSE 39072
// for i in tmp do
38991: LD_ADDR_VAR 0 4
38995: PUSH
38996: LD_VAR 0 12
39000: PUSH
39001: FOR_IN
39002: IFFALSE 39070
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39004: LD_VAR 0 4
39008: PPUSH
39009: LD_EXP 65
39013: PUSH
39014: LD_VAR 0 1
39018: ARRAY
39019: PUSH
39020: LD_INT 1
39022: ARRAY
39023: PPUSH
39024: CALL_OW 308
39028: NOT
39029: IFFALSE 39068
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39031: LD_VAR 0 4
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 250
39049: PPUSH
39050: LD_VAR 0 11
39054: PUSH
39055: LD_INT 1
39057: ARRAY
39058: PPUSH
39059: CALL_OW 251
39063: PPUSH
39064: CALL_OW 111
39068: GO 39001
39070: POP
39071: POP
// end ; if MREG_DefVeh [ side ] then
39072: LD_EXP 67
39076: PUSH
39077: LD_VAR 0 1
39081: ARRAY
39082: IFFALSE 39650
// begin tmp := [ ] ;
39084: LD_ADDR_VAR 0 12
39088: PUSH
39089: EMPTY
39090: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39091: LD_EXP 70
39095: PUSH
39096: LD_VAR 0 1
39100: ARRAY
39101: PUSH
39102: LD_INT 0
39104: EQUAL
39105: IFFALSE 39245
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39107: LD_ADDR_VAR 0 8
39111: PUSH
39112: LD_VAR 0 1
39116: PPUSH
39117: LD_INT 0
39119: PPUSH
39120: LD_INT 25
39122: PUSH
39123: LD_INT 3
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PPUSH
39130: CALL 12370 0 3
39134: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39135: LD_VAR 0 8
39139: PUSH
39140: LD_EXP 67
39144: PUSH
39145: LD_VAR 0 1
39149: ARRAY
39150: GREATER
39151: IFFALSE 39212
// begin for i = 1 to MREG_DefVeh [ side ] do
39153: LD_ADDR_VAR 0 4
39157: PUSH
39158: DOUBLE
39159: LD_INT 1
39161: DEC
39162: ST_TO_ADDR
39163: LD_EXP 67
39167: PUSH
39168: LD_VAR 0 1
39172: ARRAY
39173: PUSH
39174: FOR_TO
39175: IFFALSE 39208
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39177: LD_ADDR_VAR 0 12
39181: PUSH
39182: LD_VAR 0 12
39186: PPUSH
39187: LD_INT 1
39189: PPUSH
39190: LD_VAR 0 8
39194: PUSH
39195: LD_VAR 0 4
39199: ARRAY
39200: PPUSH
39201: CALL_OW 2
39205: ST_TO_ADDR
39206: GO 39174
39208: POP
39209: POP
// end else
39210: GO 39222
// tmp := k ;
39212: LD_ADDR_VAR 0 12
39216: PUSH
39217: LD_VAR 0 8
39221: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39222: LD_ADDR_EXP 70
39226: PUSH
39227: LD_EXP 70
39231: PPUSH
39232: LD_VAR 0 1
39236: PPUSH
39237: LD_INT 1
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39245: LD_ADDR_VAR 0 4
39249: PUSH
39250: LD_EXP 67
39254: PUSH
39255: LD_VAR 0 1
39259: ARRAY
39260: PUSH
39261: FOR_IN
39262: IFFALSE 39648
// begin if not GetDriver ( i ) then
39264: LD_VAR 0 4
39268: PPUSH
39269: CALL 31789 0 1
39273: NOT
39274: IFFALSE 39349
// begin if tmp then
39276: LD_VAR 0 12
39280: IFFALSE 39347
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39282: LD_VAR 0 12
39286: PUSH
39287: LD_INT 1
39289: ARRAY
39290: PPUSH
39291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39295: LD_VAR 0 12
39299: PUSH
39300: LD_INT 1
39302: ARRAY
39303: PPUSH
39304: LD_VAR 0 4
39308: PPUSH
39309: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39313: LD_VAR 0 12
39317: PUSH
39318: LD_INT 1
39320: ARRAY
39321: PPUSH
39322: LD_INT 36
39324: PPUSH
39325: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39329: LD_ADDR_VAR 0 12
39333: PUSH
39334: LD_VAR 0 12
39338: PPUSH
39339: LD_INT 1
39341: PPUSH
39342: CALL_OW 3
39346: ST_TO_ADDR
// end ; end else
39347: GO 39646
// begin if GetTag ( i ) = 0 then
39349: LD_VAR 0 4
39353: PPUSH
39354: CALL_OW 110
39358: PUSH
39359: LD_INT 0
39361: EQUAL
39362: IFFALSE 39378
// SetTag ( i , 31 ) else
39364: LD_VAR 0 4
39368: PPUSH
39369: LD_INT 31
39371: PPUSH
39372: CALL_OW 109
39376: GO 39646
// if GetTag ( i ) = 31 then
39378: LD_VAR 0 4
39382: PPUSH
39383: CALL_OW 110
39387: PUSH
39388: LD_INT 31
39390: EQUAL
39391: IFFALSE 39646
// begin if GetFuel ( i ) < 20 then
39393: LD_VAR 0 4
39397: PPUSH
39398: CALL_OW 261
39402: PUSH
39403: LD_INT 20
39405: LESS
39406: IFFALSE 39431
// begin SetTag ( i , 21 ) ;
39408: LD_VAR 0 4
39412: PPUSH
39413: LD_INT 21
39415: PPUSH
39416: CALL_OW 109
// MCV_Refuel ( i ) ;
39420: LD_VAR 0 4
39424: PPUSH
39425: CALL 26294 0 1
// continue ;
39429: GO 39261
// end ; if GetLives ( i ) < 700 then
39431: LD_VAR 0 4
39435: PPUSH
39436: CALL_OW 256
39440: PUSH
39441: LD_INT 700
39443: LESS
39444: IFFALSE 39556
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39446: LD_VAR 0 4
39450: PPUSH
39451: LD_EXP 58
39455: PUSH
39456: LD_VAR 0 1
39460: ARRAY
39461: PPUSH
39462: CALL_OW 308
39466: NOT
39467: IFFALSE 39491
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39469: LD_VAR 0 4
39473: PPUSH
39474: LD_EXP 58
39478: PUSH
39479: LD_VAR 0 1
39483: ARRAY
39484: PPUSH
39485: CALL_OW 113
39489: GO 39554
// if GetDriver ( i ) then
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31789 0 1
39500: IFFALSE 39554
// begin k := GetDriver ( i ) ;
39502: LD_ADDR_VAR 0 8
39506: PUSH
39507: LD_VAR 0 4
39511: PPUSH
39512: CALL 31789 0 1
39516: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39517: LD_VAR 0 8
39521: PPUSH
39522: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39540: LD_VAR 0 8
39544: PPUSH
39545: LD_VAR 0 4
39549: PPUSH
39550: CALL_OW 180
// end ; end else
39554: GO 39646
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39556: LD_ADDR_VAR 0 8
39560: PUSH
39561: LD_VAR 0 1
39565: PPUSH
39566: CALL 25022 0 1
39570: PPUSH
39571: LD_VAR 0 4
39575: PPUSH
39576: CALL_OW 74
39580: ST_TO_ADDR
// if k then
39581: LD_VAR 0 8
39585: IFFALSE 39603
// ComAttackUnit ( i , k ) else
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_VAR 0 8
39596: PPUSH
39597: CALL_OW 115
39601: GO 39646
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39603: LD_VAR 0 4
39607: PPUSH
39608: LD_EXP 58
39612: PUSH
39613: LD_VAR 0 1
39617: ARRAY
39618: PPUSH
39619: CALL_OW 308
39623: NOT
39624: IFFALSE 39646
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39626: LD_VAR 0 4
39630: PPUSH
39631: LD_EXP 58
39635: PUSH
39636: LD_VAR 0 1
39640: ARRAY
39641: PPUSH
39642: CALL_OW 113
// end ; end ; end ; end ;
39646: GO 39261
39648: POP
39649: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39650: LD_VAR 0 1
39654: PPUSH
39655: LD_INT 30
39657: PUSH
39658: LD_INT 5
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PPUSH
39665: CALL 11667 0 2
39669: IFFALSE 40487
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39671: LD_ADDR_VAR 0 11
39675: PUSH
39676: LD_VAR 0 1
39680: PPUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 5
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PPUSH
39691: CALL 11667 0 2
39695: PUSH
39696: LD_INT 1
39698: ARRAY
39699: ST_TO_ADDR
// if eng > 1 then
39700: LD_VAR 0 14
39704: PUSH
39705: LD_INT 1
39707: GREATER
39708: IFFALSE 39755
// for i = eng downto 2 do
39710: LD_ADDR_VAR 0 4
39714: PUSH
39715: DOUBLE
39716: LD_VAR 0 14
39720: INC
39721: ST_TO_ADDR
39722: LD_INT 2
39724: PUSH
39725: FOR_DOWNTO
39726: IFFALSE 39753
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39728: LD_VAR 0 1
39732: PPUSH
39733: LD_VAR 0 14
39737: PUSH
39738: LD_VAR 0 4
39742: ARRAY
39743: PPUSH
39744: LD_INT 1
39746: PPUSH
39747: CALL 16574 0 3
39751: GO 39725
39753: POP
39754: POP
// if sci > 1 then
39755: LD_VAR 0 16
39759: PUSH
39760: LD_INT 1
39762: GREATER
39763: IFFALSE 39810
// for i = sci downto 2 do
39765: LD_ADDR_VAR 0 4
39769: PUSH
39770: DOUBLE
39771: LD_VAR 0 16
39775: INC
39776: ST_TO_ADDR
39777: LD_INT 2
39779: PUSH
39780: FOR_DOWNTO
39781: IFFALSE 39808
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39783: LD_VAR 0 1
39787: PPUSH
39788: LD_VAR 0 16
39792: PUSH
39793: LD_VAR 0 4
39797: ARRAY
39798: PPUSH
39799: LD_INT 1
39801: PPUSH
39802: CALL 16574 0 3
39806: GO 39780
39808: POP
39809: POP
// if sol then
39810: LD_VAR 0 13
39814: IFFALSE 40487
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39816: LD_VAR 0 13
39820: PUSH
39821: LD_EXP 68
39825: PUSH
39826: LD_VAR 0 1
39830: ARRAY
39831: DIFF
39832: PUSH
39833: LD_INT 22
39835: PUSH
39836: LD_VAR 0 1
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 58
39847: PUSH
39848: EMPTY
39849: LIST
39850: PUSH
39851: LD_INT 2
39853: PUSH
39854: LD_INT 30
39856: PUSH
39857: LD_INT 32
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 30
39866: PUSH
39867: LD_INT 31
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: LIST
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: LIST
39883: PPUSH
39884: CALL_OW 69
39888: PUSH
39889: LD_INT 0
39891: EQUAL
39892: AND
39893: IFFALSE 40487
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39895: LD_ADDR_VAR 0 12
39899: PUSH
39900: LD_VAR 0 13
39904: PUSH
39905: LD_EXP 68
39909: PUSH
39910: LD_VAR 0 1
39914: ARRAY
39915: DIFF
39916: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39917: LD_VAR 0 1
39921: PPUSH
39922: LD_INT 30
39924: PUSH
39925: LD_INT 5
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PPUSH
39932: CALL 11667 0 2
39936: PUSH
39937: LD_INT 1
39939: GREATER
39940: IFFALSE 39971
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39942: LD_ADDR_VAR 0 8
39946: PUSH
39947: LD_VAR 0 1
39951: PPUSH
39952: LD_INT 30
39954: PUSH
39955: LD_INT 5
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PPUSH
39962: CALL 11667 0 2
39966: PUSH
39967: LD_INT 2
39969: ARRAY
39970: ST_TO_ADDR
// for j in tmp do
39971: LD_ADDR_VAR 0 5
39975: PUSH
39976: LD_VAR 0 12
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40485
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39984: LD_VAR 0 5
39988: PUSH
39989: LD_VAR 0 11
39993: PPUSH
39994: CALL_OW 313
39998: IN
39999: PUSH
40000: LD_VAR 0 11
40004: PPUSH
40005: CALL_OW 313
40009: PUSH
40010: LD_INT 6
40012: EQUAL
40013: AND
40014: PUSH
40015: LD_VAR 0 8
40019: AND
40020: PUSH
40021: LD_VAR 0 8
40025: PPUSH
40026: CALL_OW 313
40030: PUSH
40031: LD_INT 6
40033: LESS
40034: AND
40035: IFFALSE 40062
// begin ComExitBuilding ( j ) ;
40037: LD_VAR 0 5
40041: PPUSH
40042: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40046: LD_VAR 0 5
40050: PPUSH
40051: LD_VAR 0 8
40055: PPUSH
40056: CALL_OW 180
// continue ;
40060: GO 39981
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40062: LD_VAR 0 5
40066: PPUSH
40067: CALL_OW 314
40071: NOT
40072: PUSH
40073: LD_VAR 0 5
40077: PPUSH
40078: CALL_OW 110
40082: PUSH
40083: LD_INT 0
40085: EQUAL
40086: AND
40087: PUSH
40088: LD_VAR 0 5
40092: PPUSH
40093: CALL_OW 310
40097: NOT
40098: AND
40099: IFFALSE 40205
// begin if k then
40101: LD_VAR 0 8
40105: IFFALSE 40176
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40107: LD_VAR 0 8
40111: PPUSH
40112: CALL_OW 313
40116: PUSH
40117: LD_VAR 0 11
40121: PPUSH
40122: CALL_OW 313
40126: LESS
40127: IFFALSE 40145
// ComEnterUnit ( j , k ) else
40129: LD_VAR 0 5
40133: PPUSH
40134: LD_VAR 0 8
40138: PPUSH
40139: CALL_OW 120
40143: GO 40174
// if UnitsInside ( b ) < 6 then
40145: LD_VAR 0 11
40149: PPUSH
40150: CALL_OW 313
40154: PUSH
40155: LD_INT 6
40157: LESS
40158: IFFALSE 40174
// ComEnterUnit ( j , b ) ;
40160: LD_VAR 0 5
40164: PPUSH
40165: LD_VAR 0 11
40169: PPUSH
40170: CALL_OW 120
// end else
40174: GO 40205
// if UnitsInside ( b ) < 6 then
40176: LD_VAR 0 11
40180: PPUSH
40181: CALL_OW 313
40185: PUSH
40186: LD_INT 6
40188: LESS
40189: IFFALSE 40205
// ComEnterUnit ( j , b ) ;
40191: LD_VAR 0 5
40195: PPUSH
40196: LD_VAR 0 11
40200: PPUSH
40201: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40205: LD_VAR 0 5
40209: PUSH
40210: LD_VAR 0 1
40214: PPUSH
40215: LD_INT 54
40217: PUSH
40218: EMPTY
40219: LIST
40220: PPUSH
40221: CALL 11667 0 2
40225: IN
40226: PUSH
40227: LD_VAR 0 5
40231: PPUSH
40232: CALL_OW 257
40236: PUSH
40237: LD_INT 1
40239: EQUAL
40240: AND
40241: IFFALSE 40483
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40243: LD_EXP 62
40247: PUSH
40248: LD_VAR 0 1
40252: ARRAY
40253: PUSH
40254: LD_INT 1
40256: ARRAY
40257: PUSH
40258: LD_INT 12
40260: PPUSH
40261: LD_VAR 0 1
40265: PPUSH
40266: CALL_OW 321
40270: PUSH
40271: LD_INT 2
40273: EQUAL
40274: AND
40275: IFFALSE 40323
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40277: LD_VAR 0 1
40281: PPUSH
40282: LD_INT 5
40284: PPUSH
40285: EMPTY
40286: PPUSH
40287: CALL 11750 0 3
40291: PUSH
40292: LD_EXP 62
40296: PUSH
40297: LD_VAR 0 1
40301: ARRAY
40302: PUSH
40303: LD_INT 1
40305: ARRAY
40306: LESS
40307: IFFALSE 40323
// begin SetClass ( j , class_sniper ) ;
40309: LD_VAR 0 5
40313: PPUSH
40314: LD_INT 5
40316: PPUSH
40317: CALL_OW 336
// continue ;
40321: GO 39981
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40323: LD_EXP 62
40327: PUSH
40328: LD_VAR 0 1
40332: ARRAY
40333: PUSH
40334: LD_INT 2
40336: ARRAY
40337: PUSH
40338: LD_INT 41
40340: PPUSH
40341: LD_VAR 0 1
40345: PPUSH
40346: CALL_OW 321
40350: PUSH
40351: LD_INT 2
40353: EQUAL
40354: AND
40355: IFFALSE 40403
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40357: LD_VAR 0 1
40361: PPUSH
40362: LD_INT 8
40364: PPUSH
40365: EMPTY
40366: PPUSH
40367: CALL 11750 0 3
40371: PUSH
40372: LD_EXP 62
40376: PUSH
40377: LD_VAR 0 1
40381: ARRAY
40382: PUSH
40383: LD_INT 2
40385: ARRAY
40386: LESS
40387: IFFALSE 40403
// begin SetClass ( j , class_mortar ) ;
40389: LD_VAR 0 5
40393: PPUSH
40394: LD_INT 8
40396: PPUSH
40397: CALL_OW 336
// continue ;
40401: GO 39981
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40403: LD_EXP 62
40407: PUSH
40408: LD_VAR 0 1
40412: ARRAY
40413: PUSH
40414: LD_INT 3
40416: ARRAY
40417: PUSH
40418: LD_INT 44
40420: PPUSH
40421: LD_VAR 0 1
40425: PPUSH
40426: CALL_OW 321
40430: PUSH
40431: LD_INT 2
40433: EQUAL
40434: AND
40435: IFFALSE 40483
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40437: LD_VAR 0 1
40441: PPUSH
40442: LD_INT 9
40444: PPUSH
40445: EMPTY
40446: PPUSH
40447: CALL 11750 0 3
40451: PUSH
40452: LD_EXP 62
40456: PUSH
40457: LD_VAR 0 1
40461: ARRAY
40462: PUSH
40463: LD_INT 3
40465: ARRAY
40466: LESS
40467: IFFALSE 40483
// begin SetClass ( j , class_bazooker ) ;
40469: LD_VAR 0 5
40473: PPUSH
40474: LD_INT 9
40476: PPUSH
40477: CALL_OW 336
// continue ;
40481: GO 39981
// end ; end ; end ;
40483: GO 39981
40485: POP
40486: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40487: LD_INT 22
40489: PUSH
40490: LD_VAR 0 1
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 58
40501: PUSH
40502: EMPTY
40503: LIST
40504: PUSH
40505: LD_INT 30
40507: PUSH
40508: LD_INT 32
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: LIST
40519: PPUSH
40520: CALL_OW 69
40524: IFFALSE 40674
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40526: LD_ADDR_VAR 0 12
40530: PUSH
40531: LD_INT 22
40533: PUSH
40534: LD_VAR 0 1
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 58
40545: PUSH
40546: EMPTY
40547: LIST
40548: PUSH
40549: LD_INT 30
40551: PUSH
40552: LD_INT 32
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: LIST
40563: PPUSH
40564: CALL_OW 69
40568: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40569: LD_ADDR_VAR 0 8
40573: PUSH
40574: LD_VAR 0 13
40578: PUSH
40579: LD_EXP 68
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: DIFF
40590: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40591: LD_VAR 0 12
40595: PUSH
40596: LD_INT 1
40598: ARRAY
40599: PPUSH
40600: CALL_OW 461
40604: PUSH
40605: LD_INT 2
40607: EQUAL
40608: PUSH
40609: LD_VAR 0 12
40613: PUSH
40614: LD_INT 1
40616: ARRAY
40617: PUSH
40618: LD_EXP 68
40622: PUSH
40623: LD_VAR 0 1
40627: ARRAY
40628: IN
40629: NOT
40630: AND
40631: PUSH
40632: LD_VAR 0 8
40636: AND
40637: IFFALSE 40674
// begin ComExitBuilding ( k [ 1 ] ) ;
40639: LD_VAR 0 8
40643: PUSH
40644: LD_INT 1
40646: ARRAY
40647: PPUSH
40648: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40652: LD_VAR 0 8
40656: PUSH
40657: LD_INT 1
40659: ARRAY
40660: PPUSH
40661: LD_VAR 0 12
40665: PUSH
40666: LD_INT 1
40668: ARRAY
40669: PPUSH
40670: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40674: LD_EXP 35
40678: PUSH
40679: LD_VAR 0 1
40683: ARRAY
40684: IFFALSE 40832
// begin if MCF_Class ( side , 4 , [ ] ) then
40686: LD_VAR 0 1
40690: PPUSH
40691: LD_INT 4
40693: PPUSH
40694: EMPTY
40695: PPUSH
40696: CALL 11750 0 3
40700: IFFALSE 40830
// for j in MCF_Class ( side , 4 , [ ] ) do
40702: LD_ADDR_VAR 0 5
40706: PUSH
40707: LD_VAR 0 1
40711: PPUSH
40712: LD_INT 4
40714: PPUSH
40715: EMPTY
40716: PPUSH
40717: CALL 11750 0 3
40721: PUSH
40722: FOR_IN
40723: IFFALSE 40828
// begin if not GetTag ( j ) = 4 then
40725: LD_VAR 0 5
40729: PPUSH
40730: CALL_OW 110
40734: PUSH
40735: LD_INT 4
40737: EQUAL
40738: NOT
40739: IFFALSE 40775
// begin SetTag ( j , 4 ) ;
40741: LD_VAR 0 5
40745: PPUSH
40746: LD_INT 4
40748: PPUSH
40749: CALL_OW 109
// if IsInUnit ( j ) then
40753: LD_VAR 0 5
40757: PPUSH
40758: CALL_OW 310
40762: IFFALSE 40773
// ComExitBuilding ( j ) ;
40764: LD_VAR 0 5
40768: PPUSH
40769: CALL_OW 122
// end else
40773: GO 40826
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40775: LD_VAR 0 5
40779: PPUSH
40780: LD_EXP 35
40784: PUSH
40785: LD_VAR 0 1
40789: ARRAY
40790: PUSH
40791: LD_INT 1
40793: ARRAY
40794: PPUSH
40795: CALL 98089 0 2
40799: NOT
40800: IFFALSE 40826
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40802: LD_VAR 0 5
40806: PPUSH
40807: LD_EXP 35
40811: PUSH
40812: LD_VAR 0 1
40816: ARRAY
40817: PUSH
40818: LD_INT 1
40820: ARRAY
40821: PPUSH
40822: CALL 19237 0 2
// end ;
40826: GO 40722
40828: POP
40829: POP
// end else
40830: GO 41064
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40832: LD_VAR 0 1
40836: PPUSH
40837: LD_INT 4
40839: PPUSH
40840: EMPTY
40841: PPUSH
40842: CALL 11750 0 3
40846: PUSH
40847: LD_VAR 0 1
40851: PPUSH
40852: LD_INT 4
40854: PPUSH
40855: EMPTY
40856: PPUSH
40857: CALL 12370 0 3
40861: AND
40862: IFFALSE 41064
// for j in MCF_Class ( side , 4 , [ ] ) do
40864: LD_ADDR_VAR 0 5
40868: PUSH
40869: LD_VAR 0 1
40873: PPUSH
40874: LD_INT 4
40876: PPUSH
40877: EMPTY
40878: PPUSH
40879: CALL 11750 0 3
40883: PUSH
40884: FOR_IN
40885: IFFALSE 41062
// begin if GetTag ( j ) = 4 then
40887: LD_VAR 0 5
40891: PPUSH
40892: CALL_OW 110
40896: PUSH
40897: LD_INT 4
40899: EQUAL
40900: IFFALSE 41060
// begin SetTag ( j , 0 ) ;
40902: LD_VAR 0 5
40906: PPUSH
40907: LD_INT 0
40909: PPUSH
40910: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40914: LD_VAR 0 1
40918: PPUSH
40919: CALL 11706 0 1
40923: PUSH
40924: LD_VAR 0 1
40928: PPUSH
40929: CALL 18050 0 1
40933: NOT
40934: AND
40935: IFFALSE 40960
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40937: LD_VAR 0 5
40941: PPUSH
40942: LD_VAR 0 1
40946: PPUSH
40947: CALL 11706 0 1
40951: PUSH
40952: LD_INT 1
40954: ARRAY
40955: PPUSH
40956: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40960: LD_VAR 0 1
40964: PPUSH
40965: CALL 11706 0 1
40969: NOT
40970: PUSH
40971: LD_VAR 0 1
40975: PPUSH
40976: LD_INT 30
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PPUSH
40986: CALL 11667 0 2
40990: AND
40991: IFFALSE 41060
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40993: LD_VAR 0 5
40997: PPUSH
40998: LD_VAR 0 1
41002: PPUSH
41003: LD_INT 30
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PPUSH
41013: CALL 11667 0 2
41017: PUSH
41018: LD_INT 1
41020: ARRAY
41021: PPUSH
41022: CALL_OW 250
41026: PPUSH
41027: LD_VAR 0 1
41031: PPUSH
41032: LD_INT 30
41034: PUSH
41035: LD_INT 1
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PPUSH
41042: CALL 11667 0 2
41046: PUSH
41047: LD_INT 1
41049: ARRAY
41050: PPUSH
41051: CALL_OW 251
41055: PPUSH
41056: CALL_OW 111
// end ; end ;
41060: GO 40884
41062: POP
41063: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41064: LD_VAR 0 1
41068: PPUSH
41069: LD_INT 3
41071: PPUSH
41072: EMPTY
41073: PPUSH
41074: CALL 11750 0 3
41078: PUSH
41079: LD_EXP 58
41083: PUSH
41084: LD_VAR 0 1
41088: ARRAY
41089: AND
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: LD_INT 6
41098: PPUSH
41099: EMPTY
41100: PPUSH
41101: CALL 12370 0 3
41105: AND
41106: IFFALSE 41637
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41108: LD_ADDR_VAR 0 6
41112: PUSH
41113: LD_EXP 58
41117: PUSH
41118: LD_VAR 0 1
41122: ARRAY
41123: PPUSH
41124: LD_INT 0
41126: PPUSH
41127: CALL_OW 517
41131: PUSH
41132: LD_INT 1
41134: ARRAY
41135: PUSH
41136: LD_INT 1
41138: ARRAY
41139: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41140: LD_ADDR_VAR 0 7
41144: PUSH
41145: LD_EXP 58
41149: PUSH
41150: LD_VAR 0 1
41154: ARRAY
41155: PPUSH
41156: LD_INT 0
41158: PPUSH
41159: CALL_OW 517
41163: PUSH
41164: LD_INT 2
41166: ARRAY
41167: PUSH
41168: LD_INT 1
41170: ARRAY
41171: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41172: LD_VAR 0 1
41176: PPUSH
41177: LD_INT 6
41179: PPUSH
41180: EMPTY
41181: PPUSH
41182: CALL 12370 0 3
41186: IFFALSE 41635
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41188: LD_ADDR_VAR 0 8
41192: PUSH
41193: LD_VAR 0 1
41197: PPUSH
41198: LD_INT 6
41200: PPUSH
41201: EMPTY
41202: PPUSH
41203: CALL 12370 0 3
41207: PUSH
41208: FOR_IN
41209: IFFALSE 41240
// if GetLives ( k ) = 1000 then
41211: LD_VAR 0 8
41215: PPUSH
41216: CALL_OW 256
41220: PUSH
41221: LD_INT 1000
41223: EQUAL
41224: IFFALSE 41238
// SetTag ( k , 0 ) ;
41226: LD_VAR 0 8
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: CALL_OW 109
41238: GO 41208
41240: POP
41241: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41242: LD_VAR 0 1
41246: PPUSH
41247: LD_INT 0
41249: PPUSH
41250: LD_INT 25
41252: PUSH
41253: LD_INT 3
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PPUSH
41260: CALL 12370 0 3
41264: IFFALSE 41328
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41266: LD_ADDR_VAR 0 8
41270: PUSH
41271: LD_VAR 0 4
41275: PPUSH
41276: LD_INT 0
41278: PPUSH
41279: LD_INT 25
41281: PUSH
41282: LD_INT 3
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PPUSH
41289: CALL 12370 0 3
41293: PUSH
41294: FOR_IN
41295: IFFALSE 41326
// if GetTag ( k ) = 0 then
41297: LD_VAR 0 8
41301: PPUSH
41302: CALL_OW 110
41306: PUSH
41307: LD_INT 0
41309: EQUAL
41310: IFFALSE 41324
// begin SetTag ( k , 8 ) ;
41312: LD_VAR 0 8
41316: PPUSH
41317: LD_INT 8
41319: PPUSH
41320: CALL_OW 109
// end ;
41324: GO 41294
41326: POP
41327: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41328: LD_VAR 0 1
41332: PPUSH
41333: LD_INT 6
41335: PPUSH
41336: LD_INT 92
41338: PUSH
41339: LD_VAR 0 6
41343: PUSH
41344: LD_VAR 0 7
41348: PUSH
41349: LD_INT 10
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: PPUSH
41358: CALL 12370 0 3
41362: IFFALSE 41486
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41364: LD_ADDR_VAR 0 5
41368: PUSH
41369: LD_VAR 0 4
41373: PPUSH
41374: LD_INT 6
41376: PPUSH
41377: LD_INT 92
41379: PUSH
41380: LD_VAR 0 6
41384: PUSH
41385: LD_VAR 0 7
41389: PUSH
41390: LD_INT 10
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: PPUSH
41399: CALL 12370 0 3
41403: PUSH
41404: FOR_IN
41405: IFFALSE 41484
// begin if not HasTask ( j ) and GetDriver ( j ) then
41407: LD_VAR 0 5
41411: PPUSH
41412: CALL_OW 314
41416: NOT
41417: PUSH
41418: LD_VAR 0 5
41422: PPUSH
41423: CALL 31789 0 1
41427: AND
41428: IFFALSE 41482
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31789 0 1
41439: PPUSH
41440: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41444: LD_VAR 0 5
41448: PPUSH
41449: CALL 31789 0 1
41453: PPUSH
41454: LD_VAR 0 5
41458: PPUSH
41459: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41463: LD_VAR 0 5
41467: PPUSH
41468: CALL 31789 0 1
41472: PPUSH
41473: LD_VAR 0 5
41477: PPUSH
41478: CALL_OW 180
// end ; end ;
41482: GO 41404
41484: POP
41485: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41486: LD_VAR 0 1
41490: PPUSH
41491: LD_INT 6
41493: PPUSH
41494: LD_INT 92
41496: PUSH
41497: LD_VAR 0 6
41501: PUSH
41502: LD_VAR 0 7
41506: PUSH
41507: LD_INT 10
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: PPUSH
41516: CALL 12370 0 3
41520: PUSH
41521: LD_VAR 0 1
41525: PPUSH
41526: LD_INT 8
41528: PPUSH
41529: EMPTY
41530: PPUSH
41531: CALL 12370 0 3
41535: AND
41536: IFFALSE 41635
// for j in MCF_Tag ( side , 8 , [ ] ) do
41538: LD_ADDR_VAR 0 5
41542: PUSH
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12370 0 3
41557: PUSH
41558: FOR_IN
41559: IFFALSE 41633
// begin if IsInUnit ( j ) then
41561: LD_VAR 0 5
41565: PPUSH
41566: CALL_OW 310
41570: IFFALSE 41583
// ComExitBuilding ( j ) else
41572: LD_VAR 0 5
41576: PPUSH
41577: CALL_OW 122
41581: GO 41631
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41583: LD_VAR 0 5
41587: PPUSH
41588: LD_VAR 0 1
41592: PPUSH
41593: LD_INT 6
41595: PPUSH
41596: LD_INT 92
41598: PUSH
41599: LD_VAR 0 6
41603: PUSH
41604: LD_VAR 0 7
41608: PUSH
41609: LD_INT 10
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: PPUSH
41618: CALL 12370 0 3
41622: PUSH
41623: LD_INT 1
41625: ARRAY
41626: PPUSH
41627: CALL_OW 129
// end ;
41631: GO 41558
41633: POP
41634: POP
// end ; end else
41635: GO 41692
// if MCF_Tag ( side , 8 , [ ] ) then
41637: LD_VAR 0 1
41641: PPUSH
41642: LD_INT 8
41644: PPUSH
41645: EMPTY
41646: PPUSH
41647: CALL 12370 0 3
41651: IFFALSE 41692
// for k in MCF_Tag ( side , 8 , [ ] ) do
41653: LD_ADDR_VAR 0 8
41657: PUSH
41658: LD_VAR 0 1
41662: PPUSH
41663: LD_INT 8
41665: PPUSH
41666: EMPTY
41667: PPUSH
41668: CALL 12370 0 3
41672: PUSH
41673: FOR_IN
41674: IFFALSE 41690
// SetTag ( k , 0 ) ;
41676: LD_VAR 0 8
41680: PPUSH
41681: LD_INT 0
41683: PPUSH
41684: CALL_OW 109
41688: GO 41673
41690: POP
41691: POP
// end ; end_of_file
41692: LD_VAR 0 3
41696: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41697: LD_INT 0
41699: PPUSH
// MREG_Game := [ ] ;
41700: LD_ADDR_EXP 33
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Crates := [ ] ;
41707: LD_ADDR_EXP 34
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_Heal := [ ] ;
41714: LD_ADDR_EXP 35
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_Tame := [ ] ;
41721: LD_ADDR_EXP 37
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41728: LD_ADDR_EXP 38
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41735: LD_ADDR_EXP 39
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_LabList := [ ] ;
41742: LD_ADDR_EXP 40
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41749: LD_ADDR_EXP 41
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41756: LD_ADDR_EXP 42
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41763: LD_ADDR_EXP 43
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41770: LD_ADDR_EXP 44
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_Status := [ ] ;
41777: LD_ADDR_EXP 45
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41784: LD_ADDR_EXP 46
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41791: LD_ADDR_EXP 47
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41798: LD_ADDR_EXP 48
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41805: LD_ADDR_EXP 49
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41812: LD_ADDR_EXP 50
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41819: LD_ADDR_EXP 51
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41826: LD_ADDR_EXP 52
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41833: LD_ADDR_EXP 53
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41840: LD_ADDR_EXP 54
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41847: LD_ADDR_EXP 55
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41854: LD_ADDR_EXP 56
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41861: LD_ADDR_EXP 57
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41868: LD_ADDR_EXP 61
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41875: LD_ADDR_EXP 62
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_Parking := [ ] ;
41882: LD_ADDR_EXP 58
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41889: LD_ADDR_EXP 59
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41896: LD_ADDR_EXP 63
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41903: LD_ADDR_EXP 64
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41910: LD_ADDR_EXP 65
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41917: LD_ADDR_EXP 67
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41924: LD_ADDR_EXP 68
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41931: LD_ADDR_EXP 69
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41938: LD_ADDR_EXP 71
41942: PUSH
41943: EMPTY
41944: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41945: LD_ADDR_EXP 70
41949: PUSH
41950: EMPTY
41951: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41952: LD_ADDR_EXP 72
41956: PUSH
41957: LD_INT 300
41959: PUSH
41960: LD_INT 100
41962: PUSH
41963: LD_INT 25
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: LIST
41970: ST_TO_ADDR
// end ;
41971: LD_VAR 0 1
41975: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41976: LD_INT 0
41978: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41979: LD_VAR 0 2
41983: PUSH
41984: LD_VAR 0 3
41988: PUSH
41989: LD_VAR 0 4
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: LIST
41998: PUSH
41999: LD_VAR 0 1
42003: IN
42004: IFFALSE 42018
// result := mreg_list else
42006: LD_ADDR_VAR 0 5
42010: PUSH
42011: LD_VAR 0 1
42015: ST_TO_ADDR
42016: GO 42052
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42018: LD_ADDR_VAR 0 1
42022: PUSH
42023: LD_VAR 0 1
42027: PUSH
42028: LD_VAR 0 2
42032: PUSH
42033: LD_VAR 0 3
42037: PUSH
42038: LD_VAR 0 4
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: ADD
42051: ST_TO_ADDR
// result := mreg_list ;
42052: LD_ADDR_VAR 0 5
42056: PUSH
42057: LD_VAR 0 1
42061: ST_TO_ADDR
// end ;
42062: LD_VAR 0 5
42066: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42067: LD_INT 0
42069: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42070: LD_VAR 0 2
42074: PUSH
42075: LD_VAR 0 3
42079: PUSH
42080: LD_VAR 0 4
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: LIST
42089: PUSH
42090: LD_VAR 0 1
42094: IN
42095: IFFALSE 42133
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42097: LD_ADDR_VAR 0 5
42101: PUSH
42102: LD_VAR 0 1
42106: PUSH
42107: LD_VAR 0 2
42111: PUSH
42112: LD_VAR 0 3
42116: PUSH
42117: LD_VAR 0 4
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: LIST
42126: PUSH
42127: EMPTY
42128: LIST
42129: DIFF
42130: ST_TO_ADDR
42131: GO 42143
// result := mreg_list ;
42133: LD_ADDR_VAR 0 5
42137: PUSH
42138: LD_VAR 0 1
42142: ST_TO_ADDR
// end ;
42143: LD_VAR 0 5
42147: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42148: LD_INT 0
42150: PPUSH
42151: PPUSH
42152: PPUSH
// for j = 1 to 8 do
42153: LD_ADDR_VAR 0 3
42157: PUSH
42158: DOUBLE
42159: LD_INT 1
42161: DEC
42162: ST_TO_ADDR
42163: LD_INT 8
42165: PUSH
42166: FOR_TO
42167: IFFALSE 43008
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42169: LD_VAR 0 3
42173: PPUSH
42174: LD_INT 51
42176: PUSH
42177: EMPTY
42178: LIST
42179: PPUSH
42180: CALL 11667 0 2
42184: PUSH
42185: LD_OWVAR 2
42189: PUSH
42190: LD_VAR 0 3
42194: EQUAL
42195: NOT
42196: AND
42197: IFFALSE 42215
// MREG_SidesList := MREG_SidesList ^ 1 else
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 1
42211: ADD
42212: ST_TO_ADDR
42213: GO 42229
// MREG_SidesList := MREG_SidesList ^ 0 ;
42215: LD_ADDR_EXP 39
42219: PUSH
42220: LD_EXP 39
42224: PUSH
42225: LD_INT 0
42227: ADD
42228: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42229: LD_VAR 0 3
42233: PPUSH
42234: LD_INT 2
42236: PUSH
42237: LD_INT 34
42239: PUSH
42240: LD_INT 12
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 34
42249: PUSH
42250: LD_INT 32
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 34
42259: PUSH
42260: LD_INT 51
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: PUSH
42273: EMPTY
42274: LIST
42275: PPUSH
42276: CALL 11968 0 2
42280: IFFALSE 42381
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42282: LD_ADDR_VAR 0 2
42286: PUSH
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 2
42294: PUSH
42295: LD_INT 34
42297: PUSH
42298: LD_INT 12
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 34
42307: PUSH
42308: LD_INT 32
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 34
42317: PUSH
42318: LD_INT 51
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: LIST
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PPUSH
42334: CALL 11968 0 2
42338: PUSH
42339: FOR_IN
42340: IFFALSE 42379
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42342: LD_ADDR_EXP 41
42346: PUSH
42347: LD_EXP 41
42351: PPUSH
42352: LD_VAR 0 3
42356: PPUSH
42357: LD_VAR 0 2
42361: PPUSH
42362: LD_VAR 0 2
42366: PPUSH
42367: CALL_OW 264
42371: PPUSH
42372: CALL 41976 0 4
42376: ST_TO_ADDR
42377: GO 42339
42379: POP
42380: POP
// if MCF_Class ( j , 4 , [ ] ) then
42381: LD_VAR 0 3
42385: PPUSH
42386: LD_INT 4
42388: PPUSH
42389: EMPTY
42390: PPUSH
42391: CALL 11750 0 3
42395: IFFALSE 42428
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42397: LD_ADDR_EXP 54
42401: PUSH
42402: LD_EXP 54
42406: PUSH
42407: LD_VAR 0 3
42411: PPUSH
42412: LD_INT 4
42414: PPUSH
42415: EMPTY
42416: PPUSH
42417: CALL 11750 0 3
42421: PUSH
42422: EMPTY
42423: LIST
42424: ADD
42425: ST_TO_ADDR
42426: GO 42445
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42428: LD_ADDR_EXP 54
42432: PUSH
42433: LD_EXP 54
42437: PUSH
42438: LD_INT 0
42440: PUSH
42441: EMPTY
42442: LIST
42443: ADD
42444: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42445: LD_VAR 0 3
42449: PPUSH
42450: LD_INT 3
42452: PPUSH
42453: EMPTY
42454: PPUSH
42455: CALL 11750 0 3
42459: IFFALSE 42492
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42461: LD_ADDR_EXP 55
42465: PUSH
42466: LD_EXP 55
42470: PUSH
42471: LD_VAR 0 3
42475: PPUSH
42476: LD_INT 3
42478: PPUSH
42479: EMPTY
42480: PPUSH
42481: CALL 11750 0 3
42485: PUSH
42486: EMPTY
42487: LIST
42488: ADD
42489: ST_TO_ADDR
42490: GO 42509
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42492: LD_ADDR_EXP 55
42496: PUSH
42497: LD_EXP 55
42501: PUSH
42502: LD_INT 0
42504: PUSH
42505: EMPTY
42506: LIST
42507: ADD
42508: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42509: LD_VAR 0 3
42513: PPUSH
42514: LD_INT 1
42516: PPUSH
42517: EMPTY
42518: PPUSH
42519: CALL 11750 0 3
42523: IFFALSE 42556
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42525: LD_ADDR_EXP 56
42529: PUSH
42530: LD_EXP 56
42534: PUSH
42535: LD_VAR 0 3
42539: PPUSH
42540: LD_INT 1
42542: PPUSH
42543: EMPTY
42544: PPUSH
42545: CALL 11750 0 3
42549: PUSH
42550: EMPTY
42551: LIST
42552: ADD
42553: ST_TO_ADDR
42554: GO 42573
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42556: LD_ADDR_EXP 56
42560: PUSH
42561: LD_EXP 56
42565: PUSH
42566: LD_INT 0
42568: PUSH
42569: EMPTY
42570: LIST
42571: ADD
42572: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42573: LD_VAR 0 3
42577: PPUSH
42578: LD_INT 2
42580: PPUSH
42581: EMPTY
42582: PPUSH
42583: CALL 11750 0 3
42587: IFFALSE 42620
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42589: LD_ADDR_EXP 57
42593: PUSH
42594: LD_EXP 57
42598: PUSH
42599: LD_VAR 0 3
42603: PPUSH
42604: LD_INT 2
42606: PPUSH
42607: EMPTY
42608: PPUSH
42609: CALL 11750 0 3
42613: PUSH
42614: EMPTY
42615: LIST
42616: ADD
42617: ST_TO_ADDR
42618: GO 42637
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42620: LD_ADDR_EXP 57
42624: PUSH
42625: LD_EXP 57
42629: PUSH
42630: LD_INT 0
42632: PUSH
42633: EMPTY
42634: LIST
42635: ADD
42636: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42637: LD_ADDR_EXP 47
42641: PUSH
42642: LD_EXP 47
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: ADD
42653: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42654: LD_ADDR_EXP 35
42658: PUSH
42659: LD_EXP 35
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: ADD
42670: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42671: LD_ADDR_EXP 37
42675: PUSH
42676: LD_EXP 37
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: EMPTY
42685: LIST
42686: ADD
42687: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42688: LD_ADDR_EXP 58
42692: PUSH
42693: LD_EXP 58
42697: PUSH
42698: LD_INT 0
42700: PUSH
42701: EMPTY
42702: LIST
42703: ADD
42704: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42705: LD_ADDR_EXP 59
42709: PUSH
42710: LD_EXP 59
42714: PUSH
42715: LD_INT 0
42717: PUSH
42718: EMPTY
42719: LIST
42720: ADD
42721: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42722: LD_ADDR_EXP 51
42726: PUSH
42727: LD_EXP 51
42731: PUSH
42732: LD_INT 0
42734: PUSH
42735: EMPTY
42736: LIST
42737: ADD
42738: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42739: LD_ADDR_EXP 38
42743: PUSH
42744: LD_EXP 38
42748: PUSH
42749: LD_INT 0
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: LD_INT 0
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42771: LD_ADDR_EXP 60
42775: PUSH
42776: LD_EXP 60
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: EMPTY
42791: LIST
42792: ADD
42793: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42794: LD_ADDR_EXP 61
42798: PUSH
42799: LD_EXP 61
42803: PUSH
42804: LD_INT 0
42806: PUSH
42807: EMPTY
42808: LIST
42809: PUSH
42810: EMPTY
42811: LIST
42812: ADD
42813: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42814: LD_ADDR_EXP 42
42818: PUSH
42819: LD_EXP 42
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: EMPTY
42828: LIST
42829: ADD
42830: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42831: LD_ADDR_EXP 63
42835: PUSH
42836: LD_EXP 63
42840: PUSH
42841: LD_INT 0
42843: PUSH
42844: EMPTY
42845: LIST
42846: ADD
42847: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42848: LD_ADDR_EXP 64
42852: PUSH
42853: LD_EXP 64
42857: PUSH
42858: LD_INT 0
42860: PUSH
42861: EMPTY
42862: LIST
42863: ADD
42864: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42865: LD_ADDR_EXP 65
42869: PUSH
42870: LD_EXP 65
42874: PUSH
42875: LD_INT 0
42877: PUSH
42878: EMPTY
42879: LIST
42880: ADD
42881: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42882: LD_ADDR_EXP 66
42886: PUSH
42887: LD_EXP 66
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: EMPTY
42896: LIST
42897: ADD
42898: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42899: LD_ADDR_EXP 67
42903: PUSH
42904: LD_EXP 67
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: EMPTY
42913: LIST
42914: ADD
42915: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42916: LD_ADDR_EXP 68
42920: PUSH
42921: LD_EXP 68
42925: PUSH
42926: LD_INT 0
42928: PUSH
42929: EMPTY
42930: LIST
42931: ADD
42932: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42933: LD_ADDR_EXP 69
42937: PUSH
42938: LD_EXP 69
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: EMPTY
42947: LIST
42948: ADD
42949: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42950: LD_ADDR_EXP 71
42954: PUSH
42955: LD_EXP 71
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: ADD
42966: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42967: LD_ADDR_EXP 70
42971: PUSH
42972: LD_EXP 70
42976: PUSH
42977: LD_INT 0
42979: ADD
42980: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42981: LD_ADDR_EXP 62
42985: PUSH
42986: LD_EXP 62
42990: PUSH
42991: LD_INT 0
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: LD_INT 0
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: LIST
43004: ADD
43005: ST_TO_ADDR
// end ;
43006: GO 42166
43008: POP
43009: POP
// end ;
43010: LD_VAR 0 1
43014: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43015: LD_INT 0
43017: PPUSH
43018: PPUSH
43019: PPUSH
// m := false ;
43020: LD_ADDR_VAR 0 5
43024: PUSH
43025: LD_INT 0
43027: ST_TO_ADDR
// for i = 1 to mreg do
43028: LD_ADDR_VAR 0 4
43032: PUSH
43033: DOUBLE
43034: LD_INT 1
43036: DEC
43037: ST_TO_ADDR
43038: LD_VAR 0 2
43042: PUSH
43043: FOR_TO
43044: IFFALSE 43080
// if mreg [ i ] [ 1 ] = side then
43046: LD_VAR 0 2
43050: PUSH
43051: LD_VAR 0 4
43055: ARRAY
43056: PUSH
43057: LD_INT 1
43059: ARRAY
43060: PUSH
43061: LD_VAR 0 1
43065: EQUAL
43066: IFFALSE 43078
// begin m := true ;
43068: LD_ADDR_VAR 0 5
43072: PUSH
43073: LD_INT 1
43075: ST_TO_ADDR
// break ;
43076: GO 43080
// end ;
43078: GO 43043
43080: POP
43081: POP
// result := m ;
43082: LD_ADDR_VAR 0 3
43086: PUSH
43087: LD_VAR 0 5
43091: ST_TO_ADDR
// end ;
43092: LD_VAR 0 3
43096: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43097: LD_INT 0
43099: PPUSH
43100: PPUSH
43101: PPUSH
// m := 0 ;
43102: LD_ADDR_VAR 0 5
43106: PUSH
43107: LD_INT 0
43109: ST_TO_ADDR
// for i = 1 to mreg do
43110: LD_ADDR_VAR 0 4
43114: PUSH
43115: DOUBLE
43116: LD_INT 1
43118: DEC
43119: ST_TO_ADDR
43120: LD_VAR 0 2
43124: PUSH
43125: FOR_TO
43126: IFFALSE 43166
// if mreg [ i ] [ 1 ] = side then
43128: LD_VAR 0 2
43132: PUSH
43133: LD_VAR 0 4
43137: ARRAY
43138: PUSH
43139: LD_INT 1
43141: ARRAY
43142: PUSH
43143: LD_VAR 0 1
43147: EQUAL
43148: IFFALSE 43164
// begin m := m + 1 ;
43150: LD_ADDR_VAR 0 5
43154: PUSH
43155: LD_VAR 0 5
43159: PUSH
43160: LD_INT 1
43162: PLUS
43163: ST_TO_ADDR
// end ;
43164: GO 43125
43166: POP
43167: POP
// result := m ;
43168: LD_ADDR_VAR 0 3
43172: PUSH
43173: LD_VAR 0 5
43177: ST_TO_ADDR
// end ;
43178: LD_VAR 0 3
43182: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43183: LD_INT 0
43185: PPUSH
43186: PPUSH
// result := 0 ;
43187: LD_ADDR_VAR 0 3
43191: PUSH
43192: LD_INT 0
43194: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43195: LD_ADDR_VAR 0 4
43199: PUSH
43200: DOUBLE
43201: LD_INT 1
43203: DEC
43204: ST_TO_ADDR
43205: LD_EXP 53
43209: PUSH
43210: FOR_TO
43211: IFFALSE 43273
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43213: LD_EXP 53
43217: PUSH
43218: LD_VAR 0 4
43222: ARRAY
43223: PUSH
43224: LD_INT 1
43226: ARRAY
43227: PUSH
43228: LD_VAR 0 1
43232: EQUAL
43233: PUSH
43234: LD_EXP 53
43238: PUSH
43239: LD_VAR 0 4
43243: ARRAY
43244: PUSH
43245: LD_INT 2
43247: ARRAY
43248: PUSH
43249: LD_VAR 0 2
43253: EQUAL
43254: AND
43255: IFFALSE 43271
// begin result := result + 1 ;
43257: LD_ADDR_VAR 0 3
43261: PUSH
43262: LD_VAR 0 3
43266: PUSH
43267: LD_INT 1
43269: PLUS
43270: ST_TO_ADDR
// end ;
43271: GO 43210
43273: POP
43274: POP
// end ; end_of_file
43275: LD_VAR 0 3
43279: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
43280: LD_INT 0
43282: PPUSH
// ar_miner := 81 ;
43283: LD_ADDR_EXP 80
43287: PUSH
43288: LD_INT 81
43290: ST_TO_ADDR
// ar_crane := 88 ;
43291: LD_ADDR_EXP 79
43295: PUSH
43296: LD_INT 88
43298: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43299: LD_ADDR_EXP 74
43303: PUSH
43304: LD_INT 89
43306: ST_TO_ADDR
// us_hack := 99 ;
43307: LD_ADDR_EXP 75
43311: PUSH
43312: LD_INT 99
43314: ST_TO_ADDR
// us_artillery := 97 ;
43315: LD_ADDR_EXP 76
43319: PUSH
43320: LD_INT 97
43322: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43323: LD_ADDR_EXP 77
43327: PUSH
43328: LD_INT 91
43330: ST_TO_ADDR
// ar_mortar := 92 ;
43331: LD_ADDR_EXP 78
43335: PUSH
43336: LD_INT 92
43338: ST_TO_ADDR
// ru_flamethrower := 93 ;
43339: LD_ADDR_EXP 81
43343: PUSH
43344: LD_INT 93
43346: ST_TO_ADDR
// ru_radar := 98 ;
43347: LD_ADDR_EXP 73
43351: PUSH
43352: LD_INT 98
43354: ST_TO_ADDR
// tech_Artillery := 80 ;
43355: LD_ADDR_EXP 82
43359: PUSH
43360: LD_INT 80
43362: ST_TO_ADDR
// tech_RadMat := 81 ;
43363: LD_ADDR_EXP 83
43367: PUSH
43368: LD_INT 81
43370: ST_TO_ADDR
// tech_BasicTools := 82 ;
43371: LD_ADDR_EXP 84
43375: PUSH
43376: LD_INT 82
43378: ST_TO_ADDR
// tech_Cargo := 83 ;
43379: LD_ADDR_EXP 85
43383: PUSH
43384: LD_INT 83
43386: ST_TO_ADDR
// tech_Track := 84 ;
43387: LD_ADDR_EXP 86
43391: PUSH
43392: LD_INT 84
43394: ST_TO_ADDR
// tech_Crane := 85 ;
43395: LD_ADDR_EXP 87
43399: PUSH
43400: LD_INT 85
43402: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43403: LD_ADDR_EXP 88
43407: PUSH
43408: LD_INT 86
43410: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43411: LD_ADDR_EXP 89
43415: PUSH
43416: LD_INT 87
43418: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
43419: LD_ADDR_EXP 90
43423: PUSH
43424: LD_INT 88
43426: ST_TO_ADDR
// end ;
43427: LD_VAR 0 1
43431: RET
// every 1 do
43432: GO 43434
43434: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43435: CALL 43280 0 0
43439: END
// every 0 0$1 do
43440: GO 43442
43442: DISABLE
// begin enable ;
43443: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43444: LD_STRING updateTimer(
43446: PUSH
43447: LD_OWVAR 1
43451: STR
43452: PUSH
43453: LD_STRING );
43455: STR
43456: PPUSH
43457: CALL_OW 559
// end ;
43461: END
// export function SOS_MapStart ( ) ; begin
43462: LD_INT 0
43464: PPUSH
// if streamModeActive then
43465: LD_EXP 91
43469: IFFALSE 43478
// DefineStreamItems ( true ) ;
43471: LD_INT 1
43473: PPUSH
43474: CALL 45132 0 1
// UpdateFactoryWaypoints ( ) ;
43478: CALL 57993 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43482: CALL 58250 0 0
// end ;
43486: LD_VAR 0 1
43490: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43491: LD_INT 0
43493: PPUSH
// if p2 = 100 then
43494: LD_VAR 0 2
43498: PUSH
43499: LD_INT 100
43501: EQUAL
43502: IFFALSE 44505
// begin if not StreamModeActive then
43504: LD_EXP 91
43508: NOT
43509: IFFALSE 43519
// StreamModeActive := true ;
43511: LD_ADDR_EXP 91
43515: PUSH
43516: LD_INT 1
43518: ST_TO_ADDR
// if p3 = 0 then
43519: LD_VAR 0 3
43523: PUSH
43524: LD_INT 0
43526: EQUAL
43527: IFFALSE 43533
// InitStreamMode ;
43529: CALL 44668 0 0
// if p3 = 1 then
43533: LD_VAR 0 3
43537: PUSH
43538: LD_INT 1
43540: EQUAL
43541: IFFALSE 43551
// sRocket := true ;
43543: LD_ADDR_EXP 96
43547: PUSH
43548: LD_INT 1
43550: ST_TO_ADDR
// if p3 = 2 then
43551: LD_VAR 0 3
43555: PUSH
43556: LD_INT 2
43558: EQUAL
43559: IFFALSE 43569
// sSpeed := true ;
43561: LD_ADDR_EXP 95
43565: PUSH
43566: LD_INT 1
43568: ST_TO_ADDR
// if p3 = 3 then
43569: LD_VAR 0 3
43573: PUSH
43574: LD_INT 3
43576: EQUAL
43577: IFFALSE 43587
// sEngine := true ;
43579: LD_ADDR_EXP 97
43583: PUSH
43584: LD_INT 1
43586: ST_TO_ADDR
// if p3 = 4 then
43587: LD_VAR 0 3
43591: PUSH
43592: LD_INT 4
43594: EQUAL
43595: IFFALSE 43605
// sSpec := true ;
43597: LD_ADDR_EXP 94
43601: PUSH
43602: LD_INT 1
43604: ST_TO_ADDR
// if p3 = 5 then
43605: LD_VAR 0 3
43609: PUSH
43610: LD_INT 5
43612: EQUAL
43613: IFFALSE 43623
// sLevel := true ;
43615: LD_ADDR_EXP 98
43619: PUSH
43620: LD_INT 1
43622: ST_TO_ADDR
// if p3 = 6 then
43623: LD_VAR 0 3
43627: PUSH
43628: LD_INT 6
43630: EQUAL
43631: IFFALSE 43641
// sArmoury := true ;
43633: LD_ADDR_EXP 99
43637: PUSH
43638: LD_INT 1
43640: ST_TO_ADDR
// if p3 = 7 then
43641: LD_VAR 0 3
43645: PUSH
43646: LD_INT 7
43648: EQUAL
43649: IFFALSE 43659
// sRadar := true ;
43651: LD_ADDR_EXP 100
43655: PUSH
43656: LD_INT 1
43658: ST_TO_ADDR
// if p3 = 8 then
43659: LD_VAR 0 3
43663: PUSH
43664: LD_INT 8
43666: EQUAL
43667: IFFALSE 43677
// sBunker := true ;
43669: LD_ADDR_EXP 101
43673: PUSH
43674: LD_INT 1
43676: ST_TO_ADDR
// if p3 = 9 then
43677: LD_VAR 0 3
43681: PUSH
43682: LD_INT 9
43684: EQUAL
43685: IFFALSE 43695
// sHack := true ;
43687: LD_ADDR_EXP 102
43691: PUSH
43692: LD_INT 1
43694: ST_TO_ADDR
// if p3 = 10 then
43695: LD_VAR 0 3
43699: PUSH
43700: LD_INT 10
43702: EQUAL
43703: IFFALSE 43713
// sFire := true ;
43705: LD_ADDR_EXP 103
43709: PUSH
43710: LD_INT 1
43712: ST_TO_ADDR
// if p3 = 11 then
43713: LD_VAR 0 3
43717: PUSH
43718: LD_INT 11
43720: EQUAL
43721: IFFALSE 43731
// sRefresh := true ;
43723: LD_ADDR_EXP 104
43727: PUSH
43728: LD_INT 1
43730: ST_TO_ADDR
// if p3 = 12 then
43731: LD_VAR 0 3
43735: PUSH
43736: LD_INT 12
43738: EQUAL
43739: IFFALSE 43749
// sExp := true ;
43741: LD_ADDR_EXP 105
43745: PUSH
43746: LD_INT 1
43748: ST_TO_ADDR
// if p3 = 13 then
43749: LD_VAR 0 3
43753: PUSH
43754: LD_INT 13
43756: EQUAL
43757: IFFALSE 43767
// sDepot := true ;
43759: LD_ADDR_EXP 106
43763: PUSH
43764: LD_INT 1
43766: ST_TO_ADDR
// if p3 = 14 then
43767: LD_VAR 0 3
43771: PUSH
43772: LD_INT 14
43774: EQUAL
43775: IFFALSE 43785
// sFlag := true ;
43777: LD_ADDR_EXP 107
43781: PUSH
43782: LD_INT 1
43784: ST_TO_ADDR
// if p3 = 15 then
43785: LD_VAR 0 3
43789: PUSH
43790: LD_INT 15
43792: EQUAL
43793: IFFALSE 43803
// sKamikadze := true ;
43795: LD_ADDR_EXP 115
43799: PUSH
43800: LD_INT 1
43802: ST_TO_ADDR
// if p3 = 16 then
43803: LD_VAR 0 3
43807: PUSH
43808: LD_INT 16
43810: EQUAL
43811: IFFALSE 43821
// sTroll := true ;
43813: LD_ADDR_EXP 116
43817: PUSH
43818: LD_INT 1
43820: ST_TO_ADDR
// if p3 = 17 then
43821: LD_VAR 0 3
43825: PUSH
43826: LD_INT 17
43828: EQUAL
43829: IFFALSE 43839
// sSlow := true ;
43831: LD_ADDR_EXP 117
43835: PUSH
43836: LD_INT 1
43838: ST_TO_ADDR
// if p3 = 18 then
43839: LD_VAR 0 3
43843: PUSH
43844: LD_INT 18
43846: EQUAL
43847: IFFALSE 43857
// sLack := true ;
43849: LD_ADDR_EXP 118
43853: PUSH
43854: LD_INT 1
43856: ST_TO_ADDR
// if p3 = 19 then
43857: LD_VAR 0 3
43861: PUSH
43862: LD_INT 19
43864: EQUAL
43865: IFFALSE 43875
// sTank := true ;
43867: LD_ADDR_EXP 120
43871: PUSH
43872: LD_INT 1
43874: ST_TO_ADDR
// if p3 = 20 then
43875: LD_VAR 0 3
43879: PUSH
43880: LD_INT 20
43882: EQUAL
43883: IFFALSE 43893
// sRemote := true ;
43885: LD_ADDR_EXP 121
43889: PUSH
43890: LD_INT 1
43892: ST_TO_ADDR
// if p3 = 21 then
43893: LD_VAR 0 3
43897: PUSH
43898: LD_INT 21
43900: EQUAL
43901: IFFALSE 43911
// sPowell := true ;
43903: LD_ADDR_EXP 122
43907: PUSH
43908: LD_INT 1
43910: ST_TO_ADDR
// if p3 = 22 then
43911: LD_VAR 0 3
43915: PUSH
43916: LD_INT 22
43918: EQUAL
43919: IFFALSE 43929
// sTeleport := true ;
43921: LD_ADDR_EXP 125
43925: PUSH
43926: LD_INT 1
43928: ST_TO_ADDR
// if p3 = 23 then
43929: LD_VAR 0 3
43933: PUSH
43934: LD_INT 23
43936: EQUAL
43937: IFFALSE 43947
// sOilTower := true ;
43939: LD_ADDR_EXP 127
43943: PUSH
43944: LD_INT 1
43946: ST_TO_ADDR
// if p3 = 24 then
43947: LD_VAR 0 3
43951: PUSH
43952: LD_INT 24
43954: EQUAL
43955: IFFALSE 43965
// sShovel := true ;
43957: LD_ADDR_EXP 128
43961: PUSH
43962: LD_INT 1
43964: ST_TO_ADDR
// if p3 = 25 then
43965: LD_VAR 0 3
43969: PUSH
43970: LD_INT 25
43972: EQUAL
43973: IFFALSE 43983
// sSheik := true ;
43975: LD_ADDR_EXP 129
43979: PUSH
43980: LD_INT 1
43982: ST_TO_ADDR
// if p3 = 26 then
43983: LD_VAR 0 3
43987: PUSH
43988: LD_INT 26
43990: EQUAL
43991: IFFALSE 44001
// sEarthquake := true ;
43993: LD_ADDR_EXP 131
43997: PUSH
43998: LD_INT 1
44000: ST_TO_ADDR
// if p3 = 27 then
44001: LD_VAR 0 3
44005: PUSH
44006: LD_INT 27
44008: EQUAL
44009: IFFALSE 44019
// sAI := true ;
44011: LD_ADDR_EXP 132
44015: PUSH
44016: LD_INT 1
44018: ST_TO_ADDR
// if p3 = 28 then
44019: LD_VAR 0 3
44023: PUSH
44024: LD_INT 28
44026: EQUAL
44027: IFFALSE 44037
// sCargo := true ;
44029: LD_ADDR_EXP 135
44033: PUSH
44034: LD_INT 1
44036: ST_TO_ADDR
// if p3 = 29 then
44037: LD_VAR 0 3
44041: PUSH
44042: LD_INT 29
44044: EQUAL
44045: IFFALSE 44055
// sDLaser := true ;
44047: LD_ADDR_EXP 136
44051: PUSH
44052: LD_INT 1
44054: ST_TO_ADDR
// if p3 = 30 then
44055: LD_VAR 0 3
44059: PUSH
44060: LD_INT 30
44062: EQUAL
44063: IFFALSE 44073
// sExchange := true ;
44065: LD_ADDR_EXP 137
44069: PUSH
44070: LD_INT 1
44072: ST_TO_ADDR
// if p3 = 31 then
44073: LD_VAR 0 3
44077: PUSH
44078: LD_INT 31
44080: EQUAL
44081: IFFALSE 44091
// sFac := true ;
44083: LD_ADDR_EXP 138
44087: PUSH
44088: LD_INT 1
44090: ST_TO_ADDR
// if p3 = 32 then
44091: LD_VAR 0 3
44095: PUSH
44096: LD_INT 32
44098: EQUAL
44099: IFFALSE 44109
// sPower := true ;
44101: LD_ADDR_EXP 139
44105: PUSH
44106: LD_INT 1
44108: ST_TO_ADDR
// if p3 = 33 then
44109: LD_VAR 0 3
44113: PUSH
44114: LD_INT 33
44116: EQUAL
44117: IFFALSE 44127
// sRandom := true ;
44119: LD_ADDR_EXP 140
44123: PUSH
44124: LD_INT 1
44126: ST_TO_ADDR
// if p3 = 34 then
44127: LD_VAR 0 3
44131: PUSH
44132: LD_INT 34
44134: EQUAL
44135: IFFALSE 44145
// sShield := true ;
44137: LD_ADDR_EXP 141
44141: PUSH
44142: LD_INT 1
44144: ST_TO_ADDR
// if p3 = 35 then
44145: LD_VAR 0 3
44149: PUSH
44150: LD_INT 35
44152: EQUAL
44153: IFFALSE 44163
// sTime := true ;
44155: LD_ADDR_EXP 142
44159: PUSH
44160: LD_INT 1
44162: ST_TO_ADDR
// if p3 = 36 then
44163: LD_VAR 0 3
44167: PUSH
44168: LD_INT 36
44170: EQUAL
44171: IFFALSE 44181
// sTools := true ;
44173: LD_ADDR_EXP 143
44177: PUSH
44178: LD_INT 1
44180: ST_TO_ADDR
// if p3 = 101 then
44181: LD_VAR 0 3
44185: PUSH
44186: LD_INT 101
44188: EQUAL
44189: IFFALSE 44199
// sSold := true ;
44191: LD_ADDR_EXP 108
44195: PUSH
44196: LD_INT 1
44198: ST_TO_ADDR
// if p3 = 102 then
44199: LD_VAR 0 3
44203: PUSH
44204: LD_INT 102
44206: EQUAL
44207: IFFALSE 44217
// sDiff := true ;
44209: LD_ADDR_EXP 109
44213: PUSH
44214: LD_INT 1
44216: ST_TO_ADDR
// if p3 = 103 then
44217: LD_VAR 0 3
44221: PUSH
44222: LD_INT 103
44224: EQUAL
44225: IFFALSE 44235
// sFog := true ;
44227: LD_ADDR_EXP 112
44231: PUSH
44232: LD_INT 1
44234: ST_TO_ADDR
// if p3 = 104 then
44235: LD_VAR 0 3
44239: PUSH
44240: LD_INT 104
44242: EQUAL
44243: IFFALSE 44253
// sReset := true ;
44245: LD_ADDR_EXP 113
44249: PUSH
44250: LD_INT 1
44252: ST_TO_ADDR
// if p3 = 105 then
44253: LD_VAR 0 3
44257: PUSH
44258: LD_INT 105
44260: EQUAL
44261: IFFALSE 44271
// sSun := true ;
44263: LD_ADDR_EXP 114
44267: PUSH
44268: LD_INT 1
44270: ST_TO_ADDR
// if p3 = 106 then
44271: LD_VAR 0 3
44275: PUSH
44276: LD_INT 106
44278: EQUAL
44279: IFFALSE 44289
// sTiger := true ;
44281: LD_ADDR_EXP 110
44285: PUSH
44286: LD_INT 1
44288: ST_TO_ADDR
// if p3 = 107 then
44289: LD_VAR 0 3
44293: PUSH
44294: LD_INT 107
44296: EQUAL
44297: IFFALSE 44307
// sBomb := true ;
44299: LD_ADDR_EXP 111
44303: PUSH
44304: LD_INT 1
44306: ST_TO_ADDR
// if p3 = 108 then
44307: LD_VAR 0 3
44311: PUSH
44312: LD_INT 108
44314: EQUAL
44315: IFFALSE 44325
// sWound := true ;
44317: LD_ADDR_EXP 119
44321: PUSH
44322: LD_INT 1
44324: ST_TO_ADDR
// if p3 = 109 then
44325: LD_VAR 0 3
44329: PUSH
44330: LD_INT 109
44332: EQUAL
44333: IFFALSE 44343
// sBetray := true ;
44335: LD_ADDR_EXP 123
44339: PUSH
44340: LD_INT 1
44342: ST_TO_ADDR
// if p3 = 110 then
44343: LD_VAR 0 3
44347: PUSH
44348: LD_INT 110
44350: EQUAL
44351: IFFALSE 44361
// sContamin := true ;
44353: LD_ADDR_EXP 124
44357: PUSH
44358: LD_INT 1
44360: ST_TO_ADDR
// if p3 = 111 then
44361: LD_VAR 0 3
44365: PUSH
44366: LD_INT 111
44368: EQUAL
44369: IFFALSE 44379
// sOil := true ;
44371: LD_ADDR_EXP 126
44375: PUSH
44376: LD_INT 1
44378: ST_TO_ADDR
// if p3 = 112 then
44379: LD_VAR 0 3
44383: PUSH
44384: LD_INT 112
44386: EQUAL
44387: IFFALSE 44397
// sStu := true ;
44389: LD_ADDR_EXP 130
44393: PUSH
44394: LD_INT 1
44396: ST_TO_ADDR
// if p3 = 113 then
44397: LD_VAR 0 3
44401: PUSH
44402: LD_INT 113
44404: EQUAL
44405: IFFALSE 44415
// sBazooka := true ;
44407: LD_ADDR_EXP 133
44411: PUSH
44412: LD_INT 1
44414: ST_TO_ADDR
// if p3 = 114 then
44415: LD_VAR 0 3
44419: PUSH
44420: LD_INT 114
44422: EQUAL
44423: IFFALSE 44433
// sMortar := true ;
44425: LD_ADDR_EXP 134
44429: PUSH
44430: LD_INT 1
44432: ST_TO_ADDR
// if p3 = 115 then
44433: LD_VAR 0 3
44437: PUSH
44438: LD_INT 115
44440: EQUAL
44441: IFFALSE 44451
// sRanger := true ;
44443: LD_ADDR_EXP 144
44447: PUSH
44448: LD_INT 1
44450: ST_TO_ADDR
// if p3 = 116 then
44451: LD_VAR 0 3
44455: PUSH
44456: LD_INT 116
44458: EQUAL
44459: IFFALSE 44469
// sComputer := true ;
44461: LD_ADDR_EXP 145
44465: PUSH
44466: LD_INT 1
44468: ST_TO_ADDR
// if p3 = 117 then
44469: LD_VAR 0 3
44473: PUSH
44474: LD_INT 117
44476: EQUAL
44477: IFFALSE 44487
// s30 := true ;
44479: LD_ADDR_EXP 146
44483: PUSH
44484: LD_INT 1
44486: ST_TO_ADDR
// if p3 = 118 then
44487: LD_VAR 0 3
44491: PUSH
44492: LD_INT 118
44494: EQUAL
44495: IFFALSE 44505
// s60 := true ;
44497: LD_ADDR_EXP 147
44501: PUSH
44502: LD_INT 1
44504: ST_TO_ADDR
// end ; if p2 = 101 then
44505: LD_VAR 0 2
44509: PUSH
44510: LD_INT 101
44512: EQUAL
44513: IFFALSE 44641
// begin case p3 of 1 :
44515: LD_VAR 0 3
44519: PUSH
44520: LD_INT 1
44522: DOUBLE
44523: EQUAL
44524: IFTRUE 44528
44526: GO 44535
44528: POP
// hHackUnlimitedResources ; 2 :
44529: CALL 56739 0 0
44533: GO 44641
44535: LD_INT 2
44537: DOUBLE
44538: EQUAL
44539: IFTRUE 44543
44541: GO 44550
44543: POP
// hHackSetLevel10 ; 3 :
44544: CALL 56872 0 0
44548: GO 44641
44550: LD_INT 3
44552: DOUBLE
44553: EQUAL
44554: IFTRUE 44558
44556: GO 44565
44558: POP
// hHackSetLevel10YourUnits ; 4 :
44559: CALL 56957 0 0
44563: GO 44641
44565: LD_INT 4
44567: DOUBLE
44568: EQUAL
44569: IFTRUE 44573
44571: GO 44580
44573: POP
// hHackInvincible ; 5 :
44574: CALL 57405 0 0
44578: GO 44641
44580: LD_INT 5
44582: DOUBLE
44583: EQUAL
44584: IFTRUE 44588
44586: GO 44595
44588: POP
// hHackInvisible ; 6 :
44589: CALL 57516 0 0
44593: GO 44641
44595: LD_INT 6
44597: DOUBLE
44598: EQUAL
44599: IFTRUE 44603
44601: GO 44610
44603: POP
// hHackChangeYourSide ; 7 :
44604: CALL 57573 0 0
44608: GO 44641
44610: LD_INT 7
44612: DOUBLE
44613: EQUAL
44614: IFTRUE 44618
44616: GO 44625
44618: POP
// hHackChangeUnitSide ; 8 :
44619: CALL 57615 0 0
44623: GO 44641
44625: LD_INT 8
44627: DOUBLE
44628: EQUAL
44629: IFTRUE 44633
44631: GO 44640
44633: POP
// hHackFog ; end ;
44634: CALL 57716 0 0
44638: GO 44641
44640: POP
// end ; end ;
44641: LD_VAR 0 7
44645: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44646: GO 44648
44648: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44649: LD_STRING initStreamRollete();
44651: PPUSH
44652: CALL_OW 559
// InitStreamMode ;
44656: CALL 44668 0 0
// DefineStreamItems ( false ) ;
44660: LD_INT 0
44662: PPUSH
44663: CALL 45132 0 1
// end ;
44667: END
// function InitStreamMode ; begin
44668: LD_INT 0
44670: PPUSH
// streamModeActive := false ;
44671: LD_ADDR_EXP 91
44675: PUSH
44676: LD_INT 0
44678: ST_TO_ADDR
// normalCounter := 36 ;
44679: LD_ADDR_EXP 92
44683: PUSH
44684: LD_INT 36
44686: ST_TO_ADDR
// hardcoreCounter := 18 ;
44687: LD_ADDR_EXP 93
44691: PUSH
44692: LD_INT 18
44694: ST_TO_ADDR
// sRocket := false ;
44695: LD_ADDR_EXP 96
44699: PUSH
44700: LD_INT 0
44702: ST_TO_ADDR
// sSpeed := false ;
44703: LD_ADDR_EXP 95
44707: PUSH
44708: LD_INT 0
44710: ST_TO_ADDR
// sEngine := false ;
44711: LD_ADDR_EXP 97
44715: PUSH
44716: LD_INT 0
44718: ST_TO_ADDR
// sSpec := false ;
44719: LD_ADDR_EXP 94
44723: PUSH
44724: LD_INT 0
44726: ST_TO_ADDR
// sLevel := false ;
44727: LD_ADDR_EXP 98
44731: PUSH
44732: LD_INT 0
44734: ST_TO_ADDR
// sArmoury := false ;
44735: LD_ADDR_EXP 99
44739: PUSH
44740: LD_INT 0
44742: ST_TO_ADDR
// sRadar := false ;
44743: LD_ADDR_EXP 100
44747: PUSH
44748: LD_INT 0
44750: ST_TO_ADDR
// sBunker := false ;
44751: LD_ADDR_EXP 101
44755: PUSH
44756: LD_INT 0
44758: ST_TO_ADDR
// sHack := false ;
44759: LD_ADDR_EXP 102
44763: PUSH
44764: LD_INT 0
44766: ST_TO_ADDR
// sFire := false ;
44767: LD_ADDR_EXP 103
44771: PUSH
44772: LD_INT 0
44774: ST_TO_ADDR
// sRefresh := false ;
44775: LD_ADDR_EXP 104
44779: PUSH
44780: LD_INT 0
44782: ST_TO_ADDR
// sExp := false ;
44783: LD_ADDR_EXP 105
44787: PUSH
44788: LD_INT 0
44790: ST_TO_ADDR
// sDepot := false ;
44791: LD_ADDR_EXP 106
44795: PUSH
44796: LD_INT 0
44798: ST_TO_ADDR
// sFlag := false ;
44799: LD_ADDR_EXP 107
44803: PUSH
44804: LD_INT 0
44806: ST_TO_ADDR
// sKamikadze := false ;
44807: LD_ADDR_EXP 115
44811: PUSH
44812: LD_INT 0
44814: ST_TO_ADDR
// sTroll := false ;
44815: LD_ADDR_EXP 116
44819: PUSH
44820: LD_INT 0
44822: ST_TO_ADDR
// sSlow := false ;
44823: LD_ADDR_EXP 117
44827: PUSH
44828: LD_INT 0
44830: ST_TO_ADDR
// sLack := false ;
44831: LD_ADDR_EXP 118
44835: PUSH
44836: LD_INT 0
44838: ST_TO_ADDR
// sTank := false ;
44839: LD_ADDR_EXP 120
44843: PUSH
44844: LD_INT 0
44846: ST_TO_ADDR
// sRemote := false ;
44847: LD_ADDR_EXP 121
44851: PUSH
44852: LD_INT 0
44854: ST_TO_ADDR
// sPowell := false ;
44855: LD_ADDR_EXP 122
44859: PUSH
44860: LD_INT 0
44862: ST_TO_ADDR
// sTeleport := false ;
44863: LD_ADDR_EXP 125
44867: PUSH
44868: LD_INT 0
44870: ST_TO_ADDR
// sOilTower := false ;
44871: LD_ADDR_EXP 127
44875: PUSH
44876: LD_INT 0
44878: ST_TO_ADDR
// sShovel := false ;
44879: LD_ADDR_EXP 128
44883: PUSH
44884: LD_INT 0
44886: ST_TO_ADDR
// sSheik := false ;
44887: LD_ADDR_EXP 129
44891: PUSH
44892: LD_INT 0
44894: ST_TO_ADDR
// sEarthquake := false ;
44895: LD_ADDR_EXP 131
44899: PUSH
44900: LD_INT 0
44902: ST_TO_ADDR
// sAI := false ;
44903: LD_ADDR_EXP 132
44907: PUSH
44908: LD_INT 0
44910: ST_TO_ADDR
// sCargo := false ;
44911: LD_ADDR_EXP 135
44915: PUSH
44916: LD_INT 0
44918: ST_TO_ADDR
// sDLaser := false ;
44919: LD_ADDR_EXP 136
44923: PUSH
44924: LD_INT 0
44926: ST_TO_ADDR
// sExchange := false ;
44927: LD_ADDR_EXP 137
44931: PUSH
44932: LD_INT 0
44934: ST_TO_ADDR
// sFac := false ;
44935: LD_ADDR_EXP 138
44939: PUSH
44940: LD_INT 0
44942: ST_TO_ADDR
// sPower := false ;
44943: LD_ADDR_EXP 139
44947: PUSH
44948: LD_INT 0
44950: ST_TO_ADDR
// sRandom := false ;
44951: LD_ADDR_EXP 140
44955: PUSH
44956: LD_INT 0
44958: ST_TO_ADDR
// sShield := false ;
44959: LD_ADDR_EXP 141
44963: PUSH
44964: LD_INT 0
44966: ST_TO_ADDR
// sTime := false ;
44967: LD_ADDR_EXP 142
44971: PUSH
44972: LD_INT 0
44974: ST_TO_ADDR
// sTools := false ;
44975: LD_ADDR_EXP 143
44979: PUSH
44980: LD_INT 0
44982: ST_TO_ADDR
// sSold := false ;
44983: LD_ADDR_EXP 108
44987: PUSH
44988: LD_INT 0
44990: ST_TO_ADDR
// sDiff := false ;
44991: LD_ADDR_EXP 109
44995: PUSH
44996: LD_INT 0
44998: ST_TO_ADDR
// sFog := false ;
44999: LD_ADDR_EXP 112
45003: PUSH
45004: LD_INT 0
45006: ST_TO_ADDR
// sReset := false ;
45007: LD_ADDR_EXP 113
45011: PUSH
45012: LD_INT 0
45014: ST_TO_ADDR
// sSun := false ;
45015: LD_ADDR_EXP 114
45019: PUSH
45020: LD_INT 0
45022: ST_TO_ADDR
// sTiger := false ;
45023: LD_ADDR_EXP 110
45027: PUSH
45028: LD_INT 0
45030: ST_TO_ADDR
// sBomb := false ;
45031: LD_ADDR_EXP 111
45035: PUSH
45036: LD_INT 0
45038: ST_TO_ADDR
// sWound := false ;
45039: LD_ADDR_EXP 119
45043: PUSH
45044: LD_INT 0
45046: ST_TO_ADDR
// sBetray := false ;
45047: LD_ADDR_EXP 123
45051: PUSH
45052: LD_INT 0
45054: ST_TO_ADDR
// sContamin := false ;
45055: LD_ADDR_EXP 124
45059: PUSH
45060: LD_INT 0
45062: ST_TO_ADDR
// sOil := false ;
45063: LD_ADDR_EXP 126
45067: PUSH
45068: LD_INT 0
45070: ST_TO_ADDR
// sStu := false ;
45071: LD_ADDR_EXP 130
45075: PUSH
45076: LD_INT 0
45078: ST_TO_ADDR
// sBazooka := false ;
45079: LD_ADDR_EXP 133
45083: PUSH
45084: LD_INT 0
45086: ST_TO_ADDR
// sMortar := false ;
45087: LD_ADDR_EXP 134
45091: PUSH
45092: LD_INT 0
45094: ST_TO_ADDR
// sRanger := false ;
45095: LD_ADDR_EXP 144
45099: PUSH
45100: LD_INT 0
45102: ST_TO_ADDR
// sComputer := false ;
45103: LD_ADDR_EXP 145
45107: PUSH
45108: LD_INT 0
45110: ST_TO_ADDR
// s30 := false ;
45111: LD_ADDR_EXP 146
45115: PUSH
45116: LD_INT 0
45118: ST_TO_ADDR
// s60 := false ;
45119: LD_ADDR_EXP 147
45123: PUSH
45124: LD_INT 0
45126: ST_TO_ADDR
// end ;
45127: LD_VAR 0 1
45131: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
45132: LD_INT 0
45134: PPUSH
45135: PPUSH
45136: PPUSH
45137: PPUSH
45138: PPUSH
45139: PPUSH
45140: PPUSH
// result := [ ] ;
45141: LD_ADDR_VAR 0 2
45145: PUSH
45146: EMPTY
45147: ST_TO_ADDR
// if campaign_id = 1 then
45148: LD_OWVAR 69
45152: PUSH
45153: LD_INT 1
45155: EQUAL
45156: IFFALSE 48322
// begin case mission_number of 1 :
45158: LD_OWVAR 70
45162: PUSH
45163: LD_INT 1
45165: DOUBLE
45166: EQUAL
45167: IFTRUE 45171
45169: GO 45247
45171: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45172: LD_ADDR_VAR 0 2
45176: PUSH
45177: LD_INT 2
45179: PUSH
45180: LD_INT 4
45182: PUSH
45183: LD_INT 11
45185: PUSH
45186: LD_INT 12
45188: PUSH
45189: LD_INT 15
45191: PUSH
45192: LD_INT 16
45194: PUSH
45195: LD_INT 22
45197: PUSH
45198: LD_INT 23
45200: PUSH
45201: LD_INT 26
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 101
45217: PUSH
45218: LD_INT 102
45220: PUSH
45221: LD_INT 106
45223: PUSH
45224: LD_INT 116
45226: PUSH
45227: LD_INT 117
45229: PUSH
45230: LD_INT 118
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: LIST
45237: LIST
45238: LIST
45239: LIST
45240: PUSH
45241: EMPTY
45242: LIST
45243: LIST
45244: ST_TO_ADDR
45245: GO 48320
45247: LD_INT 2
45249: DOUBLE
45250: EQUAL
45251: IFTRUE 45255
45253: GO 45339
45255: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45256: LD_ADDR_VAR 0 2
45260: PUSH
45261: LD_INT 2
45263: PUSH
45264: LD_INT 4
45266: PUSH
45267: LD_INT 11
45269: PUSH
45270: LD_INT 12
45272: PUSH
45273: LD_INT 15
45275: PUSH
45276: LD_INT 16
45278: PUSH
45279: LD_INT 22
45281: PUSH
45282: LD_INT 23
45284: PUSH
45285: LD_INT 26
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: LIST
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 101
45301: PUSH
45302: LD_INT 102
45304: PUSH
45305: LD_INT 105
45307: PUSH
45308: LD_INT 106
45310: PUSH
45311: LD_INT 108
45313: PUSH
45314: LD_INT 116
45316: PUSH
45317: LD_INT 117
45319: PUSH
45320: LD_INT 118
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: ST_TO_ADDR
45337: GO 48320
45339: LD_INT 3
45341: DOUBLE
45342: EQUAL
45343: IFTRUE 45347
45345: GO 45435
45347: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45348: LD_ADDR_VAR 0 2
45352: PUSH
45353: LD_INT 2
45355: PUSH
45356: LD_INT 4
45358: PUSH
45359: LD_INT 5
45361: PUSH
45362: LD_INT 11
45364: PUSH
45365: LD_INT 12
45367: PUSH
45368: LD_INT 15
45370: PUSH
45371: LD_INT 16
45373: PUSH
45374: LD_INT 22
45376: PUSH
45377: LD_INT 26
45379: PUSH
45380: LD_INT 36
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: LIST
45387: LIST
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: LIST
45394: PUSH
45395: LD_INT 101
45397: PUSH
45398: LD_INT 102
45400: PUSH
45401: LD_INT 105
45403: PUSH
45404: LD_INT 106
45406: PUSH
45407: LD_INT 108
45409: PUSH
45410: LD_INT 116
45412: PUSH
45413: LD_INT 117
45415: PUSH
45416: LD_INT 118
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: ST_TO_ADDR
45433: GO 48320
45435: LD_INT 4
45437: DOUBLE
45438: EQUAL
45439: IFTRUE 45443
45441: GO 45539
45443: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45444: LD_ADDR_VAR 0 2
45448: PUSH
45449: LD_INT 2
45451: PUSH
45452: LD_INT 4
45454: PUSH
45455: LD_INT 5
45457: PUSH
45458: LD_INT 8
45460: PUSH
45461: LD_INT 11
45463: PUSH
45464: LD_INT 12
45466: PUSH
45467: LD_INT 15
45469: PUSH
45470: LD_INT 16
45472: PUSH
45473: LD_INT 22
45475: PUSH
45476: LD_INT 23
45478: PUSH
45479: LD_INT 26
45481: PUSH
45482: LD_INT 36
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 101
45501: PUSH
45502: LD_INT 102
45504: PUSH
45505: LD_INT 105
45507: PUSH
45508: LD_INT 106
45510: PUSH
45511: LD_INT 108
45513: PUSH
45514: LD_INT 116
45516: PUSH
45517: LD_INT 117
45519: PUSH
45520: LD_INT 118
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: ST_TO_ADDR
45537: GO 48320
45539: LD_INT 5
45541: DOUBLE
45542: EQUAL
45543: IFTRUE 45547
45545: GO 45659
45547: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45548: LD_ADDR_VAR 0 2
45552: PUSH
45553: LD_INT 2
45555: PUSH
45556: LD_INT 4
45558: PUSH
45559: LD_INT 5
45561: PUSH
45562: LD_INT 6
45564: PUSH
45565: LD_INT 8
45567: PUSH
45568: LD_INT 11
45570: PUSH
45571: LD_INT 12
45573: PUSH
45574: LD_INT 15
45576: PUSH
45577: LD_INT 16
45579: PUSH
45580: LD_INT 22
45582: PUSH
45583: LD_INT 23
45585: PUSH
45586: LD_INT 25
45588: PUSH
45589: LD_INT 26
45591: PUSH
45592: LD_INT 36
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: LIST
45599: LIST
45600: LIST
45601: LIST
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 101
45613: PUSH
45614: LD_INT 102
45616: PUSH
45617: LD_INT 105
45619: PUSH
45620: LD_INT 106
45622: PUSH
45623: LD_INT 108
45625: PUSH
45626: LD_INT 109
45628: PUSH
45629: LD_INT 112
45631: PUSH
45632: LD_INT 116
45634: PUSH
45635: LD_INT 117
45637: PUSH
45638: LD_INT 118
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: ST_TO_ADDR
45657: GO 48320
45659: LD_INT 6
45661: DOUBLE
45662: EQUAL
45663: IFTRUE 45667
45665: GO 45799
45667: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45668: LD_ADDR_VAR 0 2
45672: PUSH
45673: LD_INT 2
45675: PUSH
45676: LD_INT 4
45678: PUSH
45679: LD_INT 5
45681: PUSH
45682: LD_INT 6
45684: PUSH
45685: LD_INT 8
45687: PUSH
45688: LD_INT 11
45690: PUSH
45691: LD_INT 12
45693: PUSH
45694: LD_INT 15
45696: PUSH
45697: LD_INT 16
45699: PUSH
45700: LD_INT 20
45702: PUSH
45703: LD_INT 21
45705: PUSH
45706: LD_INT 22
45708: PUSH
45709: LD_INT 23
45711: PUSH
45712: LD_INT 25
45714: PUSH
45715: LD_INT 26
45717: PUSH
45718: LD_INT 30
45720: PUSH
45721: LD_INT 31
45723: PUSH
45724: LD_INT 32
45726: PUSH
45727: LD_INT 36
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: LIST
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: PUSH
45751: LD_INT 101
45753: PUSH
45754: LD_INT 102
45756: PUSH
45757: LD_INT 105
45759: PUSH
45760: LD_INT 106
45762: PUSH
45763: LD_INT 108
45765: PUSH
45766: LD_INT 109
45768: PUSH
45769: LD_INT 112
45771: PUSH
45772: LD_INT 116
45774: PUSH
45775: LD_INT 117
45777: PUSH
45778: LD_INT 118
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: LIST
45785: LIST
45786: LIST
45787: LIST
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: ST_TO_ADDR
45797: GO 48320
45799: LD_INT 7
45801: DOUBLE
45802: EQUAL
45803: IFTRUE 45807
45805: GO 45919
45807: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45808: LD_ADDR_VAR 0 2
45812: PUSH
45813: LD_INT 2
45815: PUSH
45816: LD_INT 4
45818: PUSH
45819: LD_INT 5
45821: PUSH
45822: LD_INT 7
45824: PUSH
45825: LD_INT 11
45827: PUSH
45828: LD_INT 12
45830: PUSH
45831: LD_INT 15
45833: PUSH
45834: LD_INT 16
45836: PUSH
45837: LD_INT 20
45839: PUSH
45840: LD_INT 21
45842: PUSH
45843: LD_INT 22
45845: PUSH
45846: LD_INT 23
45848: PUSH
45849: LD_INT 25
45851: PUSH
45852: LD_INT 26
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 101
45873: PUSH
45874: LD_INT 102
45876: PUSH
45877: LD_INT 103
45879: PUSH
45880: LD_INT 105
45882: PUSH
45883: LD_INT 106
45885: PUSH
45886: LD_INT 108
45888: PUSH
45889: LD_INT 112
45891: PUSH
45892: LD_INT 116
45894: PUSH
45895: LD_INT 117
45897: PUSH
45898: LD_INT 118
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: LIST
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: ST_TO_ADDR
45917: GO 48320
45919: LD_INT 8
45921: DOUBLE
45922: EQUAL
45923: IFTRUE 45927
45925: GO 46067
45927: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45928: LD_ADDR_VAR 0 2
45932: PUSH
45933: LD_INT 2
45935: PUSH
45936: LD_INT 4
45938: PUSH
45939: LD_INT 5
45941: PUSH
45942: LD_INT 6
45944: PUSH
45945: LD_INT 7
45947: PUSH
45948: LD_INT 8
45950: PUSH
45951: LD_INT 11
45953: PUSH
45954: LD_INT 12
45956: PUSH
45957: LD_INT 15
45959: PUSH
45960: LD_INT 16
45962: PUSH
45963: LD_INT 20
45965: PUSH
45966: LD_INT 21
45968: PUSH
45969: LD_INT 22
45971: PUSH
45972: LD_INT 23
45974: PUSH
45975: LD_INT 25
45977: PUSH
45978: LD_INT 26
45980: PUSH
45981: LD_INT 30
45983: PUSH
45984: LD_INT 31
45986: PUSH
45987: LD_INT 32
45989: PUSH
45990: LD_INT 36
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: PUSH
46015: LD_INT 101
46017: PUSH
46018: LD_INT 102
46020: PUSH
46021: LD_INT 103
46023: PUSH
46024: LD_INT 105
46026: PUSH
46027: LD_INT 106
46029: PUSH
46030: LD_INT 108
46032: PUSH
46033: LD_INT 109
46035: PUSH
46036: LD_INT 112
46038: PUSH
46039: LD_INT 116
46041: PUSH
46042: LD_INT 117
46044: PUSH
46045: LD_INT 118
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: LIST
46059: LIST
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: ST_TO_ADDR
46065: GO 48320
46067: LD_INT 9
46069: DOUBLE
46070: EQUAL
46071: IFTRUE 46075
46073: GO 46223
46075: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
46076: LD_ADDR_VAR 0 2
46080: PUSH
46081: LD_INT 2
46083: PUSH
46084: LD_INT 4
46086: PUSH
46087: LD_INT 5
46089: PUSH
46090: LD_INT 6
46092: PUSH
46093: LD_INT 7
46095: PUSH
46096: LD_INT 8
46098: PUSH
46099: LD_INT 11
46101: PUSH
46102: LD_INT 12
46104: PUSH
46105: LD_INT 15
46107: PUSH
46108: LD_INT 16
46110: PUSH
46111: LD_INT 20
46113: PUSH
46114: LD_INT 21
46116: PUSH
46117: LD_INT 22
46119: PUSH
46120: LD_INT 23
46122: PUSH
46123: LD_INT 25
46125: PUSH
46126: LD_INT 26
46128: PUSH
46129: LD_INT 28
46131: PUSH
46132: LD_INT 30
46134: PUSH
46135: LD_INT 31
46137: PUSH
46138: LD_INT 32
46140: PUSH
46141: LD_INT 36
46143: PUSH
46144: EMPTY
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: PUSH
46167: LD_INT 101
46169: PUSH
46170: LD_INT 102
46172: PUSH
46173: LD_INT 103
46175: PUSH
46176: LD_INT 105
46178: PUSH
46179: LD_INT 106
46181: PUSH
46182: LD_INT 108
46184: PUSH
46185: LD_INT 109
46187: PUSH
46188: LD_INT 112
46190: PUSH
46191: LD_INT 114
46193: PUSH
46194: LD_INT 116
46196: PUSH
46197: LD_INT 117
46199: PUSH
46200: LD_INT 118
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: ST_TO_ADDR
46221: GO 48320
46223: LD_INT 10
46225: DOUBLE
46226: EQUAL
46227: IFTRUE 46231
46229: GO 46427
46231: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46232: LD_ADDR_VAR 0 2
46236: PUSH
46237: LD_INT 2
46239: PUSH
46240: LD_INT 4
46242: PUSH
46243: LD_INT 5
46245: PUSH
46246: LD_INT 6
46248: PUSH
46249: LD_INT 7
46251: PUSH
46252: LD_INT 8
46254: PUSH
46255: LD_INT 9
46257: PUSH
46258: LD_INT 10
46260: PUSH
46261: LD_INT 11
46263: PUSH
46264: LD_INT 12
46266: PUSH
46267: LD_INT 13
46269: PUSH
46270: LD_INT 14
46272: PUSH
46273: LD_INT 15
46275: PUSH
46276: LD_INT 16
46278: PUSH
46279: LD_INT 17
46281: PUSH
46282: LD_INT 18
46284: PUSH
46285: LD_INT 19
46287: PUSH
46288: LD_INT 20
46290: PUSH
46291: LD_INT 21
46293: PUSH
46294: LD_INT 22
46296: PUSH
46297: LD_INT 23
46299: PUSH
46300: LD_INT 24
46302: PUSH
46303: LD_INT 25
46305: PUSH
46306: LD_INT 26
46308: PUSH
46309: LD_INT 28
46311: PUSH
46312: LD_INT 30
46314: PUSH
46315: LD_INT 31
46317: PUSH
46318: LD_INT 32
46320: PUSH
46321: LD_INT 36
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: LIST
46334: LIST
46335: LIST
46336: LIST
46337: LIST
46338: LIST
46339: LIST
46340: LIST
46341: LIST
46342: LIST
46343: LIST
46344: LIST
46345: LIST
46346: LIST
46347: LIST
46348: LIST
46349: LIST
46350: LIST
46351: LIST
46352: LIST
46353: LIST
46354: PUSH
46355: LD_INT 101
46357: PUSH
46358: LD_INT 102
46360: PUSH
46361: LD_INT 103
46363: PUSH
46364: LD_INT 104
46366: PUSH
46367: LD_INT 105
46369: PUSH
46370: LD_INT 106
46372: PUSH
46373: LD_INT 107
46375: PUSH
46376: LD_INT 108
46378: PUSH
46379: LD_INT 109
46381: PUSH
46382: LD_INT 110
46384: PUSH
46385: LD_INT 111
46387: PUSH
46388: LD_INT 112
46390: PUSH
46391: LD_INT 114
46393: PUSH
46394: LD_INT 116
46396: PUSH
46397: LD_INT 117
46399: PUSH
46400: LD_INT 118
46402: PUSH
46403: EMPTY
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: PUSH
46421: EMPTY
46422: LIST
46423: LIST
46424: ST_TO_ADDR
46425: GO 48320
46427: LD_INT 11
46429: DOUBLE
46430: EQUAL
46431: IFTRUE 46435
46433: GO 46639
46435: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46436: LD_ADDR_VAR 0 2
46440: PUSH
46441: LD_INT 2
46443: PUSH
46444: LD_INT 3
46446: PUSH
46447: LD_INT 4
46449: PUSH
46450: LD_INT 5
46452: PUSH
46453: LD_INT 6
46455: PUSH
46456: LD_INT 7
46458: PUSH
46459: LD_INT 8
46461: PUSH
46462: LD_INT 9
46464: PUSH
46465: LD_INT 10
46467: PUSH
46468: LD_INT 11
46470: PUSH
46471: LD_INT 12
46473: PUSH
46474: LD_INT 13
46476: PUSH
46477: LD_INT 14
46479: PUSH
46480: LD_INT 15
46482: PUSH
46483: LD_INT 16
46485: PUSH
46486: LD_INT 17
46488: PUSH
46489: LD_INT 18
46491: PUSH
46492: LD_INT 19
46494: PUSH
46495: LD_INT 20
46497: PUSH
46498: LD_INT 21
46500: PUSH
46501: LD_INT 22
46503: PUSH
46504: LD_INT 23
46506: PUSH
46507: LD_INT 24
46509: PUSH
46510: LD_INT 25
46512: PUSH
46513: LD_INT 26
46515: PUSH
46516: LD_INT 28
46518: PUSH
46519: LD_INT 30
46521: PUSH
46522: LD_INT 31
46524: PUSH
46525: LD_INT 32
46527: PUSH
46528: LD_INT 34
46530: PUSH
46531: LD_INT 36
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: PUSH
46567: LD_INT 101
46569: PUSH
46570: LD_INT 102
46572: PUSH
46573: LD_INT 103
46575: PUSH
46576: LD_INT 104
46578: PUSH
46579: LD_INT 105
46581: PUSH
46582: LD_INT 106
46584: PUSH
46585: LD_INT 107
46587: PUSH
46588: LD_INT 108
46590: PUSH
46591: LD_INT 109
46593: PUSH
46594: LD_INT 110
46596: PUSH
46597: LD_INT 111
46599: PUSH
46600: LD_INT 112
46602: PUSH
46603: LD_INT 114
46605: PUSH
46606: LD_INT 116
46608: PUSH
46609: LD_INT 117
46611: PUSH
46612: LD_INT 118
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: PUSH
46633: EMPTY
46634: LIST
46635: LIST
46636: ST_TO_ADDR
46637: GO 48320
46639: LD_INT 12
46641: DOUBLE
46642: EQUAL
46643: IFTRUE 46647
46645: GO 46867
46647: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46648: LD_ADDR_VAR 0 2
46652: PUSH
46653: LD_INT 1
46655: PUSH
46656: LD_INT 2
46658: PUSH
46659: LD_INT 3
46661: PUSH
46662: LD_INT 4
46664: PUSH
46665: LD_INT 5
46667: PUSH
46668: LD_INT 6
46670: PUSH
46671: LD_INT 7
46673: PUSH
46674: LD_INT 8
46676: PUSH
46677: LD_INT 9
46679: PUSH
46680: LD_INT 10
46682: PUSH
46683: LD_INT 11
46685: PUSH
46686: LD_INT 12
46688: PUSH
46689: LD_INT 13
46691: PUSH
46692: LD_INT 14
46694: PUSH
46695: LD_INT 15
46697: PUSH
46698: LD_INT 16
46700: PUSH
46701: LD_INT 17
46703: PUSH
46704: LD_INT 18
46706: PUSH
46707: LD_INT 19
46709: PUSH
46710: LD_INT 20
46712: PUSH
46713: LD_INT 21
46715: PUSH
46716: LD_INT 22
46718: PUSH
46719: LD_INT 23
46721: PUSH
46722: LD_INT 24
46724: PUSH
46725: LD_INT 25
46727: PUSH
46728: LD_INT 26
46730: PUSH
46731: LD_INT 27
46733: PUSH
46734: LD_INT 28
46736: PUSH
46737: LD_INT 30
46739: PUSH
46740: LD_INT 31
46742: PUSH
46743: LD_INT 32
46745: PUSH
46746: LD_INT 33
46748: PUSH
46749: LD_INT 34
46751: PUSH
46752: LD_INT 36
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: LIST
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: LIST
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 101
46793: PUSH
46794: LD_INT 102
46796: PUSH
46797: LD_INT 103
46799: PUSH
46800: LD_INT 104
46802: PUSH
46803: LD_INT 105
46805: PUSH
46806: LD_INT 106
46808: PUSH
46809: LD_INT 107
46811: PUSH
46812: LD_INT 108
46814: PUSH
46815: LD_INT 109
46817: PUSH
46818: LD_INT 110
46820: PUSH
46821: LD_INT 111
46823: PUSH
46824: LD_INT 112
46826: PUSH
46827: LD_INT 113
46829: PUSH
46830: LD_INT 114
46832: PUSH
46833: LD_INT 116
46835: PUSH
46836: LD_INT 117
46838: PUSH
46839: LD_INT 118
46841: PUSH
46842: EMPTY
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: LIST
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: LIST
46857: LIST
46858: LIST
46859: LIST
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: ST_TO_ADDR
46865: GO 48320
46867: LD_INT 13
46869: DOUBLE
46870: EQUAL
46871: IFTRUE 46875
46873: GO 47083
46875: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46876: LD_ADDR_VAR 0 2
46880: PUSH
46881: LD_INT 1
46883: PUSH
46884: LD_INT 2
46886: PUSH
46887: LD_INT 3
46889: PUSH
46890: LD_INT 4
46892: PUSH
46893: LD_INT 5
46895: PUSH
46896: LD_INT 8
46898: PUSH
46899: LD_INT 9
46901: PUSH
46902: LD_INT 10
46904: PUSH
46905: LD_INT 11
46907: PUSH
46908: LD_INT 12
46910: PUSH
46911: LD_INT 14
46913: PUSH
46914: LD_INT 15
46916: PUSH
46917: LD_INT 16
46919: PUSH
46920: LD_INT 17
46922: PUSH
46923: LD_INT 18
46925: PUSH
46926: LD_INT 19
46928: PUSH
46929: LD_INT 20
46931: PUSH
46932: LD_INT 21
46934: PUSH
46935: LD_INT 22
46937: PUSH
46938: LD_INT 23
46940: PUSH
46941: LD_INT 24
46943: PUSH
46944: LD_INT 25
46946: PUSH
46947: LD_INT 26
46949: PUSH
46950: LD_INT 27
46952: PUSH
46953: LD_INT 28
46955: PUSH
46956: LD_INT 30
46958: PUSH
46959: LD_INT 31
46961: PUSH
46962: LD_INT 32
46964: PUSH
46965: LD_INT 33
46967: PUSH
46968: LD_INT 34
46970: PUSH
46971: LD_INT 36
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: PUSH
47007: LD_INT 101
47009: PUSH
47010: LD_INT 102
47012: PUSH
47013: LD_INT 103
47015: PUSH
47016: LD_INT 104
47018: PUSH
47019: LD_INT 105
47021: PUSH
47022: LD_INT 106
47024: PUSH
47025: LD_INT 107
47027: PUSH
47028: LD_INT 108
47030: PUSH
47031: LD_INT 109
47033: PUSH
47034: LD_INT 110
47036: PUSH
47037: LD_INT 111
47039: PUSH
47040: LD_INT 112
47042: PUSH
47043: LD_INT 113
47045: PUSH
47046: LD_INT 114
47048: PUSH
47049: LD_INT 116
47051: PUSH
47052: LD_INT 117
47054: PUSH
47055: LD_INT 118
47057: PUSH
47058: EMPTY
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: PUSH
47077: EMPTY
47078: LIST
47079: LIST
47080: ST_TO_ADDR
47081: GO 48320
47083: LD_INT 14
47085: DOUBLE
47086: EQUAL
47087: IFTRUE 47091
47089: GO 47315
47091: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
47092: LD_ADDR_VAR 0 2
47096: PUSH
47097: LD_INT 1
47099: PUSH
47100: LD_INT 2
47102: PUSH
47103: LD_INT 3
47105: PUSH
47106: LD_INT 4
47108: PUSH
47109: LD_INT 5
47111: PUSH
47112: LD_INT 6
47114: PUSH
47115: LD_INT 7
47117: PUSH
47118: LD_INT 8
47120: PUSH
47121: LD_INT 9
47123: PUSH
47124: LD_INT 10
47126: PUSH
47127: LD_INT 11
47129: PUSH
47130: LD_INT 12
47132: PUSH
47133: LD_INT 13
47135: PUSH
47136: LD_INT 14
47138: PUSH
47139: LD_INT 15
47141: PUSH
47142: LD_INT 16
47144: PUSH
47145: LD_INT 17
47147: PUSH
47148: LD_INT 18
47150: PUSH
47151: LD_INT 19
47153: PUSH
47154: LD_INT 20
47156: PUSH
47157: LD_INT 21
47159: PUSH
47160: LD_INT 22
47162: PUSH
47163: LD_INT 23
47165: PUSH
47166: LD_INT 24
47168: PUSH
47169: LD_INT 25
47171: PUSH
47172: LD_INT 26
47174: PUSH
47175: LD_INT 27
47177: PUSH
47178: LD_INT 28
47180: PUSH
47181: LD_INT 29
47183: PUSH
47184: LD_INT 30
47186: PUSH
47187: LD_INT 31
47189: PUSH
47190: LD_INT 32
47192: PUSH
47193: LD_INT 33
47195: PUSH
47196: LD_INT 34
47198: PUSH
47199: LD_INT 36
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 101
47241: PUSH
47242: LD_INT 102
47244: PUSH
47245: LD_INT 103
47247: PUSH
47248: LD_INT 104
47250: PUSH
47251: LD_INT 105
47253: PUSH
47254: LD_INT 106
47256: PUSH
47257: LD_INT 107
47259: PUSH
47260: LD_INT 108
47262: PUSH
47263: LD_INT 109
47265: PUSH
47266: LD_INT 110
47268: PUSH
47269: LD_INT 111
47271: PUSH
47272: LD_INT 112
47274: PUSH
47275: LD_INT 113
47277: PUSH
47278: LD_INT 114
47280: PUSH
47281: LD_INT 116
47283: PUSH
47284: LD_INT 117
47286: PUSH
47287: LD_INT 118
47289: PUSH
47290: EMPTY
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: PUSH
47309: EMPTY
47310: LIST
47311: LIST
47312: ST_TO_ADDR
47313: GO 48320
47315: LD_INT 15
47317: DOUBLE
47318: EQUAL
47319: IFTRUE 47323
47321: GO 47547
47323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47324: LD_ADDR_VAR 0 2
47328: PUSH
47329: LD_INT 1
47331: PUSH
47332: LD_INT 2
47334: PUSH
47335: LD_INT 3
47337: PUSH
47338: LD_INT 4
47340: PUSH
47341: LD_INT 5
47343: PUSH
47344: LD_INT 6
47346: PUSH
47347: LD_INT 7
47349: PUSH
47350: LD_INT 8
47352: PUSH
47353: LD_INT 9
47355: PUSH
47356: LD_INT 10
47358: PUSH
47359: LD_INT 11
47361: PUSH
47362: LD_INT 12
47364: PUSH
47365: LD_INT 13
47367: PUSH
47368: LD_INT 14
47370: PUSH
47371: LD_INT 15
47373: PUSH
47374: LD_INT 16
47376: PUSH
47377: LD_INT 17
47379: PUSH
47380: LD_INT 18
47382: PUSH
47383: LD_INT 19
47385: PUSH
47386: LD_INT 20
47388: PUSH
47389: LD_INT 21
47391: PUSH
47392: LD_INT 22
47394: PUSH
47395: LD_INT 23
47397: PUSH
47398: LD_INT 24
47400: PUSH
47401: LD_INT 25
47403: PUSH
47404: LD_INT 26
47406: PUSH
47407: LD_INT 27
47409: PUSH
47410: LD_INT 28
47412: PUSH
47413: LD_INT 29
47415: PUSH
47416: LD_INT 30
47418: PUSH
47419: LD_INT 31
47421: PUSH
47422: LD_INT 32
47424: PUSH
47425: LD_INT 33
47427: PUSH
47428: LD_INT 34
47430: PUSH
47431: LD_INT 36
47433: PUSH
47434: EMPTY
47435: LIST
47436: LIST
47437: LIST
47438: LIST
47439: LIST
47440: LIST
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 101
47473: PUSH
47474: LD_INT 102
47476: PUSH
47477: LD_INT 103
47479: PUSH
47480: LD_INT 104
47482: PUSH
47483: LD_INT 105
47485: PUSH
47486: LD_INT 106
47488: PUSH
47489: LD_INT 107
47491: PUSH
47492: LD_INT 108
47494: PUSH
47495: LD_INT 109
47497: PUSH
47498: LD_INT 110
47500: PUSH
47501: LD_INT 111
47503: PUSH
47504: LD_INT 112
47506: PUSH
47507: LD_INT 113
47509: PUSH
47510: LD_INT 114
47512: PUSH
47513: LD_INT 116
47515: PUSH
47516: LD_INT 117
47518: PUSH
47519: LD_INT 118
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: LIST
47537: LIST
47538: LIST
47539: LIST
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: ST_TO_ADDR
47545: GO 48320
47547: LD_INT 16
47549: DOUBLE
47550: EQUAL
47551: IFTRUE 47555
47553: GO 47691
47555: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47556: LD_ADDR_VAR 0 2
47560: PUSH
47561: LD_INT 2
47563: PUSH
47564: LD_INT 4
47566: PUSH
47567: LD_INT 5
47569: PUSH
47570: LD_INT 7
47572: PUSH
47573: LD_INT 11
47575: PUSH
47576: LD_INT 12
47578: PUSH
47579: LD_INT 15
47581: PUSH
47582: LD_INT 16
47584: PUSH
47585: LD_INT 20
47587: PUSH
47588: LD_INT 21
47590: PUSH
47591: LD_INT 22
47593: PUSH
47594: LD_INT 23
47596: PUSH
47597: LD_INT 25
47599: PUSH
47600: LD_INT 26
47602: PUSH
47603: LD_INT 30
47605: PUSH
47606: LD_INT 31
47608: PUSH
47609: LD_INT 32
47611: PUSH
47612: LD_INT 33
47614: PUSH
47615: LD_INT 34
47617: PUSH
47618: EMPTY
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: PUSH
47639: LD_INT 101
47641: PUSH
47642: LD_INT 102
47644: PUSH
47645: LD_INT 103
47647: PUSH
47648: LD_INT 106
47650: PUSH
47651: LD_INT 108
47653: PUSH
47654: LD_INT 112
47656: PUSH
47657: LD_INT 113
47659: PUSH
47660: LD_INT 114
47662: PUSH
47663: LD_INT 116
47665: PUSH
47666: LD_INT 117
47668: PUSH
47669: LD_INT 118
47671: PUSH
47672: EMPTY
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: PUSH
47685: EMPTY
47686: LIST
47687: LIST
47688: ST_TO_ADDR
47689: GO 48320
47691: LD_INT 17
47693: DOUBLE
47694: EQUAL
47695: IFTRUE 47699
47697: GO 47923
47699: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47700: LD_ADDR_VAR 0 2
47704: PUSH
47705: LD_INT 1
47707: PUSH
47708: LD_INT 2
47710: PUSH
47711: LD_INT 3
47713: PUSH
47714: LD_INT 4
47716: PUSH
47717: LD_INT 5
47719: PUSH
47720: LD_INT 6
47722: PUSH
47723: LD_INT 7
47725: PUSH
47726: LD_INT 8
47728: PUSH
47729: LD_INT 9
47731: PUSH
47732: LD_INT 10
47734: PUSH
47735: LD_INT 11
47737: PUSH
47738: LD_INT 12
47740: PUSH
47741: LD_INT 13
47743: PUSH
47744: LD_INT 14
47746: PUSH
47747: LD_INT 15
47749: PUSH
47750: LD_INT 16
47752: PUSH
47753: LD_INT 17
47755: PUSH
47756: LD_INT 18
47758: PUSH
47759: LD_INT 19
47761: PUSH
47762: LD_INT 20
47764: PUSH
47765: LD_INT 21
47767: PUSH
47768: LD_INT 22
47770: PUSH
47771: LD_INT 23
47773: PUSH
47774: LD_INT 24
47776: PUSH
47777: LD_INT 25
47779: PUSH
47780: LD_INT 26
47782: PUSH
47783: LD_INT 27
47785: PUSH
47786: LD_INT 28
47788: PUSH
47789: LD_INT 29
47791: PUSH
47792: LD_INT 30
47794: PUSH
47795: LD_INT 31
47797: PUSH
47798: LD_INT 32
47800: PUSH
47801: LD_INT 33
47803: PUSH
47804: LD_INT 34
47806: PUSH
47807: LD_INT 36
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: PUSH
47847: LD_INT 101
47849: PUSH
47850: LD_INT 102
47852: PUSH
47853: LD_INT 103
47855: PUSH
47856: LD_INT 104
47858: PUSH
47859: LD_INT 105
47861: PUSH
47862: LD_INT 106
47864: PUSH
47865: LD_INT 107
47867: PUSH
47868: LD_INT 108
47870: PUSH
47871: LD_INT 109
47873: PUSH
47874: LD_INT 110
47876: PUSH
47877: LD_INT 111
47879: PUSH
47880: LD_INT 112
47882: PUSH
47883: LD_INT 113
47885: PUSH
47886: LD_INT 114
47888: PUSH
47889: LD_INT 116
47891: PUSH
47892: LD_INT 117
47894: PUSH
47895: LD_INT 118
47897: PUSH
47898: EMPTY
47899: LIST
47900: LIST
47901: LIST
47902: LIST
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: LIST
47913: LIST
47914: LIST
47915: LIST
47916: PUSH
47917: EMPTY
47918: LIST
47919: LIST
47920: ST_TO_ADDR
47921: GO 48320
47923: LD_INT 18
47925: DOUBLE
47926: EQUAL
47927: IFTRUE 47931
47929: GO 48079
47931: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47932: LD_ADDR_VAR 0 2
47936: PUSH
47937: LD_INT 2
47939: PUSH
47940: LD_INT 4
47942: PUSH
47943: LD_INT 5
47945: PUSH
47946: LD_INT 7
47948: PUSH
47949: LD_INT 11
47951: PUSH
47952: LD_INT 12
47954: PUSH
47955: LD_INT 15
47957: PUSH
47958: LD_INT 16
47960: PUSH
47961: LD_INT 20
47963: PUSH
47964: LD_INT 21
47966: PUSH
47967: LD_INT 22
47969: PUSH
47970: LD_INT 23
47972: PUSH
47973: LD_INT 25
47975: PUSH
47976: LD_INT 26
47978: PUSH
47979: LD_INT 30
47981: PUSH
47982: LD_INT 31
47984: PUSH
47985: LD_INT 32
47987: PUSH
47988: LD_INT 33
47990: PUSH
47991: LD_INT 34
47993: PUSH
47994: LD_INT 35
47996: PUSH
47997: LD_INT 36
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: PUSH
48023: LD_INT 101
48025: PUSH
48026: LD_INT 102
48028: PUSH
48029: LD_INT 103
48031: PUSH
48032: LD_INT 106
48034: PUSH
48035: LD_INT 108
48037: PUSH
48038: LD_INT 112
48040: PUSH
48041: LD_INT 113
48043: PUSH
48044: LD_INT 114
48046: PUSH
48047: LD_INT 115
48049: PUSH
48050: LD_INT 116
48052: PUSH
48053: LD_INT 117
48055: PUSH
48056: LD_INT 118
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: LIST
48063: LIST
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: PUSH
48073: EMPTY
48074: LIST
48075: LIST
48076: ST_TO_ADDR
48077: GO 48320
48079: LD_INT 19
48081: DOUBLE
48082: EQUAL
48083: IFTRUE 48087
48085: GO 48319
48087: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
48088: LD_ADDR_VAR 0 2
48092: PUSH
48093: LD_INT 1
48095: PUSH
48096: LD_INT 2
48098: PUSH
48099: LD_INT 3
48101: PUSH
48102: LD_INT 4
48104: PUSH
48105: LD_INT 5
48107: PUSH
48108: LD_INT 6
48110: PUSH
48111: LD_INT 7
48113: PUSH
48114: LD_INT 8
48116: PUSH
48117: LD_INT 9
48119: PUSH
48120: LD_INT 10
48122: PUSH
48123: LD_INT 11
48125: PUSH
48126: LD_INT 12
48128: PUSH
48129: LD_INT 13
48131: PUSH
48132: LD_INT 14
48134: PUSH
48135: LD_INT 15
48137: PUSH
48138: LD_INT 16
48140: PUSH
48141: LD_INT 17
48143: PUSH
48144: LD_INT 18
48146: PUSH
48147: LD_INT 19
48149: PUSH
48150: LD_INT 20
48152: PUSH
48153: LD_INT 21
48155: PUSH
48156: LD_INT 22
48158: PUSH
48159: LD_INT 23
48161: PUSH
48162: LD_INT 24
48164: PUSH
48165: LD_INT 25
48167: PUSH
48168: LD_INT 26
48170: PUSH
48171: LD_INT 27
48173: PUSH
48174: LD_INT 28
48176: PUSH
48177: LD_INT 29
48179: PUSH
48180: LD_INT 30
48182: PUSH
48183: LD_INT 31
48185: PUSH
48186: LD_INT 32
48188: PUSH
48189: LD_INT 33
48191: PUSH
48192: LD_INT 34
48194: PUSH
48195: LD_INT 35
48197: PUSH
48198: LD_INT 36
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: LIST
48213: LIST
48214: LIST
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: PUSH
48239: LD_INT 101
48241: PUSH
48242: LD_INT 102
48244: PUSH
48245: LD_INT 103
48247: PUSH
48248: LD_INT 104
48250: PUSH
48251: LD_INT 105
48253: PUSH
48254: LD_INT 106
48256: PUSH
48257: LD_INT 107
48259: PUSH
48260: LD_INT 108
48262: PUSH
48263: LD_INT 109
48265: PUSH
48266: LD_INT 110
48268: PUSH
48269: LD_INT 111
48271: PUSH
48272: LD_INT 112
48274: PUSH
48275: LD_INT 113
48277: PUSH
48278: LD_INT 114
48280: PUSH
48281: LD_INT 115
48283: PUSH
48284: LD_INT 116
48286: PUSH
48287: LD_INT 117
48289: PUSH
48290: LD_INT 118
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: LIST
48299: LIST
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: LIST
48306: LIST
48307: LIST
48308: LIST
48309: LIST
48310: LIST
48311: LIST
48312: PUSH
48313: EMPTY
48314: LIST
48315: LIST
48316: ST_TO_ADDR
48317: GO 48320
48319: POP
// end else
48320: GO 48551
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48322: LD_ADDR_VAR 0 2
48326: PUSH
48327: LD_INT 1
48329: PUSH
48330: LD_INT 2
48332: PUSH
48333: LD_INT 3
48335: PUSH
48336: LD_INT 4
48338: PUSH
48339: LD_INT 5
48341: PUSH
48342: LD_INT 6
48344: PUSH
48345: LD_INT 7
48347: PUSH
48348: LD_INT 8
48350: PUSH
48351: LD_INT 9
48353: PUSH
48354: LD_INT 10
48356: PUSH
48357: LD_INT 11
48359: PUSH
48360: LD_INT 12
48362: PUSH
48363: LD_INT 13
48365: PUSH
48366: LD_INT 14
48368: PUSH
48369: LD_INT 15
48371: PUSH
48372: LD_INT 16
48374: PUSH
48375: LD_INT 17
48377: PUSH
48378: LD_INT 18
48380: PUSH
48381: LD_INT 19
48383: PUSH
48384: LD_INT 20
48386: PUSH
48387: LD_INT 21
48389: PUSH
48390: LD_INT 22
48392: PUSH
48393: LD_INT 23
48395: PUSH
48396: LD_INT 24
48398: PUSH
48399: LD_INT 25
48401: PUSH
48402: LD_INT 26
48404: PUSH
48405: LD_INT 27
48407: PUSH
48408: LD_INT 28
48410: PUSH
48411: LD_INT 29
48413: PUSH
48414: LD_INT 30
48416: PUSH
48417: LD_INT 31
48419: PUSH
48420: LD_INT 32
48422: PUSH
48423: LD_INT 33
48425: PUSH
48426: LD_INT 34
48428: PUSH
48429: LD_INT 35
48431: PUSH
48432: LD_INT 36
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: LIST
48458: LIST
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: LIST
48466: LIST
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: PUSH
48473: LD_INT 101
48475: PUSH
48476: LD_INT 102
48478: PUSH
48479: LD_INT 103
48481: PUSH
48482: LD_INT 104
48484: PUSH
48485: LD_INT 105
48487: PUSH
48488: LD_INT 106
48490: PUSH
48491: LD_INT 107
48493: PUSH
48494: LD_INT 108
48496: PUSH
48497: LD_INT 109
48499: PUSH
48500: LD_INT 110
48502: PUSH
48503: LD_INT 111
48505: PUSH
48506: LD_INT 112
48508: PUSH
48509: LD_INT 113
48511: PUSH
48512: LD_INT 114
48514: PUSH
48515: LD_INT 115
48517: PUSH
48518: LD_INT 116
48520: PUSH
48521: LD_INT 117
48523: PUSH
48524: LD_INT 118
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: LIST
48531: LIST
48532: LIST
48533: LIST
48534: LIST
48535: LIST
48536: LIST
48537: LIST
48538: LIST
48539: LIST
48540: LIST
48541: LIST
48542: LIST
48543: LIST
48544: LIST
48545: LIST
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: ST_TO_ADDR
// if result then
48551: LD_VAR 0 2
48555: IFFALSE 49341
// begin normal :=  ;
48557: LD_ADDR_VAR 0 5
48561: PUSH
48562: LD_STRING 
48564: ST_TO_ADDR
// hardcore :=  ;
48565: LD_ADDR_VAR 0 6
48569: PUSH
48570: LD_STRING 
48572: ST_TO_ADDR
// active :=  ;
48573: LD_ADDR_VAR 0 7
48577: PUSH
48578: LD_STRING 
48580: ST_TO_ADDR
// for i = 1 to normalCounter do
48581: LD_ADDR_VAR 0 8
48585: PUSH
48586: DOUBLE
48587: LD_INT 1
48589: DEC
48590: ST_TO_ADDR
48591: LD_EXP 92
48595: PUSH
48596: FOR_TO
48597: IFFALSE 48698
// begin tmp := 0 ;
48599: LD_ADDR_VAR 0 3
48603: PUSH
48604: LD_STRING 0
48606: ST_TO_ADDR
// if result [ 1 ] then
48607: LD_VAR 0 2
48611: PUSH
48612: LD_INT 1
48614: ARRAY
48615: IFFALSE 48680
// if result [ 1 ] [ 1 ] = i then
48617: LD_VAR 0 2
48621: PUSH
48622: LD_INT 1
48624: ARRAY
48625: PUSH
48626: LD_INT 1
48628: ARRAY
48629: PUSH
48630: LD_VAR 0 8
48634: EQUAL
48635: IFFALSE 48680
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48637: LD_ADDR_VAR 0 2
48641: PUSH
48642: LD_VAR 0 2
48646: PPUSH
48647: LD_INT 1
48649: PPUSH
48650: LD_VAR 0 2
48654: PUSH
48655: LD_INT 1
48657: ARRAY
48658: PPUSH
48659: LD_INT 1
48661: PPUSH
48662: CALL_OW 3
48666: PPUSH
48667: CALL_OW 1
48671: ST_TO_ADDR
// tmp := 1 ;
48672: LD_ADDR_VAR 0 3
48676: PUSH
48677: LD_STRING 1
48679: ST_TO_ADDR
// end ; normal := normal & tmp ;
48680: LD_ADDR_VAR 0 5
48684: PUSH
48685: LD_VAR 0 5
48689: PUSH
48690: LD_VAR 0 3
48694: STR
48695: ST_TO_ADDR
// end ;
48696: GO 48596
48698: POP
48699: POP
// for i = 1 to hardcoreCounter do
48700: LD_ADDR_VAR 0 8
48704: PUSH
48705: DOUBLE
48706: LD_INT 1
48708: DEC
48709: ST_TO_ADDR
48710: LD_EXP 93
48714: PUSH
48715: FOR_TO
48716: IFFALSE 48821
// begin tmp := 0 ;
48718: LD_ADDR_VAR 0 3
48722: PUSH
48723: LD_STRING 0
48725: ST_TO_ADDR
// if result [ 2 ] then
48726: LD_VAR 0 2
48730: PUSH
48731: LD_INT 2
48733: ARRAY
48734: IFFALSE 48803
// if result [ 2 ] [ 1 ] = 100 + i then
48736: LD_VAR 0 2
48740: PUSH
48741: LD_INT 2
48743: ARRAY
48744: PUSH
48745: LD_INT 1
48747: ARRAY
48748: PUSH
48749: LD_INT 100
48751: PUSH
48752: LD_VAR 0 8
48756: PLUS
48757: EQUAL
48758: IFFALSE 48803
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48760: LD_ADDR_VAR 0 2
48764: PUSH
48765: LD_VAR 0 2
48769: PPUSH
48770: LD_INT 2
48772: PPUSH
48773: LD_VAR 0 2
48777: PUSH
48778: LD_INT 2
48780: ARRAY
48781: PPUSH
48782: LD_INT 1
48784: PPUSH
48785: CALL_OW 3
48789: PPUSH
48790: CALL_OW 1
48794: ST_TO_ADDR
// tmp := 1 ;
48795: LD_ADDR_VAR 0 3
48799: PUSH
48800: LD_STRING 1
48802: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48803: LD_ADDR_VAR 0 6
48807: PUSH
48808: LD_VAR 0 6
48812: PUSH
48813: LD_VAR 0 3
48817: STR
48818: ST_TO_ADDR
// end ;
48819: GO 48715
48821: POP
48822: POP
// if isGameLoad then
48823: LD_VAR 0 1
48827: IFFALSE 49302
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48829: LD_ADDR_VAR 0 4
48833: PUSH
48834: LD_EXP 96
48838: PUSH
48839: LD_EXP 95
48843: PUSH
48844: LD_EXP 97
48848: PUSH
48849: LD_EXP 94
48853: PUSH
48854: LD_EXP 98
48858: PUSH
48859: LD_EXP 99
48863: PUSH
48864: LD_EXP 100
48868: PUSH
48869: LD_EXP 101
48873: PUSH
48874: LD_EXP 102
48878: PUSH
48879: LD_EXP 103
48883: PUSH
48884: LD_EXP 104
48888: PUSH
48889: LD_EXP 105
48893: PUSH
48894: LD_EXP 106
48898: PUSH
48899: LD_EXP 107
48903: PUSH
48904: LD_EXP 115
48908: PUSH
48909: LD_EXP 116
48913: PUSH
48914: LD_EXP 117
48918: PUSH
48919: LD_EXP 118
48923: PUSH
48924: LD_EXP 120
48928: PUSH
48929: LD_EXP 121
48933: PUSH
48934: LD_EXP 122
48938: PUSH
48939: LD_EXP 125
48943: PUSH
48944: LD_EXP 127
48948: PUSH
48949: LD_EXP 128
48953: PUSH
48954: LD_EXP 129
48958: PUSH
48959: LD_EXP 131
48963: PUSH
48964: LD_EXP 132
48968: PUSH
48969: LD_EXP 135
48973: PUSH
48974: LD_EXP 136
48978: PUSH
48979: LD_EXP 137
48983: PUSH
48984: LD_EXP 138
48988: PUSH
48989: LD_EXP 139
48993: PUSH
48994: LD_EXP 140
48998: PUSH
48999: LD_EXP 141
49003: PUSH
49004: LD_EXP 142
49008: PUSH
49009: LD_EXP 143
49013: PUSH
49014: LD_EXP 108
49018: PUSH
49019: LD_EXP 109
49023: PUSH
49024: LD_EXP 112
49028: PUSH
49029: LD_EXP 113
49033: PUSH
49034: LD_EXP 114
49038: PUSH
49039: LD_EXP 110
49043: PUSH
49044: LD_EXP 111
49048: PUSH
49049: LD_EXP 119
49053: PUSH
49054: LD_EXP 123
49058: PUSH
49059: LD_EXP 124
49063: PUSH
49064: LD_EXP 126
49068: PUSH
49069: LD_EXP 130
49073: PUSH
49074: LD_EXP 133
49078: PUSH
49079: LD_EXP 134
49083: PUSH
49084: LD_EXP 144
49088: PUSH
49089: LD_EXP 145
49093: PUSH
49094: LD_EXP 146
49098: PUSH
49099: LD_EXP 147
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: ST_TO_ADDR
// tmp :=  ;
49160: LD_ADDR_VAR 0 3
49164: PUSH
49165: LD_STRING 
49167: ST_TO_ADDR
// for i = 1 to normalCounter do
49168: LD_ADDR_VAR 0 8
49172: PUSH
49173: DOUBLE
49174: LD_INT 1
49176: DEC
49177: ST_TO_ADDR
49178: LD_EXP 92
49182: PUSH
49183: FOR_TO
49184: IFFALSE 49220
// begin if flags [ i ] then
49186: LD_VAR 0 4
49190: PUSH
49191: LD_VAR 0 8
49195: ARRAY
49196: IFFALSE 49218
// tmp := tmp & i & ; ;
49198: LD_ADDR_VAR 0 3
49202: PUSH
49203: LD_VAR 0 3
49207: PUSH
49208: LD_VAR 0 8
49212: STR
49213: PUSH
49214: LD_STRING ;
49216: STR
49217: ST_TO_ADDR
// end ;
49218: GO 49183
49220: POP
49221: POP
// for i = 1 to hardcoreCounter do
49222: LD_ADDR_VAR 0 8
49226: PUSH
49227: DOUBLE
49228: LD_INT 1
49230: DEC
49231: ST_TO_ADDR
49232: LD_EXP 93
49236: PUSH
49237: FOR_TO
49238: IFFALSE 49284
// begin if flags [ normalCounter + i ] then
49240: LD_VAR 0 4
49244: PUSH
49245: LD_EXP 92
49249: PUSH
49250: LD_VAR 0 8
49254: PLUS
49255: ARRAY
49256: IFFALSE 49282
// tmp := tmp & ( 100 + i ) & ; ;
49258: LD_ADDR_VAR 0 3
49262: PUSH
49263: LD_VAR 0 3
49267: PUSH
49268: LD_INT 100
49270: PUSH
49271: LD_VAR 0 8
49275: PLUS
49276: STR
49277: PUSH
49278: LD_STRING ;
49280: STR
49281: ST_TO_ADDR
// end ;
49282: GO 49237
49284: POP
49285: POP
// if tmp then
49286: LD_VAR 0 3
49290: IFFALSE 49302
// active := tmp ;
49292: LD_ADDR_VAR 0 7
49296: PUSH
49297: LD_VAR 0 3
49301: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49302: LD_STRING getStreamItemsFromMission("
49304: PUSH
49305: LD_VAR 0 5
49309: STR
49310: PUSH
49311: LD_STRING ","
49313: STR
49314: PUSH
49315: LD_VAR 0 6
49319: STR
49320: PUSH
49321: LD_STRING ","
49323: STR
49324: PUSH
49325: LD_VAR 0 7
49329: STR
49330: PUSH
49331: LD_STRING ")
49333: STR
49334: PPUSH
49335: CALL_OW 559
// end else
49339: GO 49348
// ToLua ( getStreamItemsFromMission("","","") ) ;
49341: LD_STRING getStreamItemsFromMission("","","")
49343: PPUSH
49344: CALL_OW 559
// end ;
49348: LD_VAR 0 2
49352: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49353: LD_EXP 91
49357: PUSH
49358: LD_EXP 96
49362: AND
49363: IFFALSE 49487
49365: GO 49367
49367: DISABLE
49368: LD_INT 0
49370: PPUSH
49371: PPUSH
// begin enable ;
49372: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49373: LD_ADDR_VAR 0 2
49377: PUSH
49378: LD_INT 22
49380: PUSH
49381: LD_OWVAR 2
49385: PUSH
49386: EMPTY
49387: LIST
49388: LIST
49389: PUSH
49390: LD_INT 2
49392: PUSH
49393: LD_INT 34
49395: PUSH
49396: LD_INT 7
49398: PUSH
49399: EMPTY
49400: LIST
49401: LIST
49402: PUSH
49403: LD_INT 34
49405: PUSH
49406: LD_INT 45
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PUSH
49413: LD_INT 34
49415: PUSH
49416: LD_INT 28
49418: PUSH
49419: EMPTY
49420: LIST
49421: LIST
49422: PUSH
49423: LD_INT 34
49425: PUSH
49426: LD_INT 47
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PUSH
49433: EMPTY
49434: LIST
49435: LIST
49436: LIST
49437: LIST
49438: LIST
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: PPUSH
49444: CALL_OW 69
49448: ST_TO_ADDR
// if not tmp then
49449: LD_VAR 0 2
49453: NOT
49454: IFFALSE 49458
// exit ;
49456: GO 49487
// for i in tmp do
49458: LD_ADDR_VAR 0 1
49462: PUSH
49463: LD_VAR 0 2
49467: PUSH
49468: FOR_IN
49469: IFFALSE 49485
// begin SetLives ( i , 0 ) ;
49471: LD_VAR 0 1
49475: PPUSH
49476: LD_INT 0
49478: PPUSH
49479: CALL_OW 234
// end ;
49483: GO 49468
49485: POP
49486: POP
// end ;
49487: PPOPN 2
49489: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49490: LD_EXP 91
49494: PUSH
49495: LD_EXP 97
49499: AND
49500: IFFALSE 49584
49502: GO 49504
49504: DISABLE
49505: LD_INT 0
49507: PPUSH
49508: PPUSH
// begin enable ;
49509: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49510: LD_ADDR_VAR 0 2
49514: PUSH
49515: LD_INT 22
49517: PUSH
49518: LD_OWVAR 2
49522: PUSH
49523: EMPTY
49524: LIST
49525: LIST
49526: PUSH
49527: LD_INT 32
49529: PUSH
49530: LD_INT 3
49532: PUSH
49533: EMPTY
49534: LIST
49535: LIST
49536: PUSH
49537: EMPTY
49538: LIST
49539: LIST
49540: PPUSH
49541: CALL_OW 69
49545: ST_TO_ADDR
// if not tmp then
49546: LD_VAR 0 2
49550: NOT
49551: IFFALSE 49555
// exit ;
49553: GO 49584
// for i in tmp do
49555: LD_ADDR_VAR 0 1
49559: PUSH
49560: LD_VAR 0 2
49564: PUSH
49565: FOR_IN
49566: IFFALSE 49582
// begin SetLives ( i , 0 ) ;
49568: LD_VAR 0 1
49572: PPUSH
49573: LD_INT 0
49575: PPUSH
49576: CALL_OW 234
// end ;
49580: GO 49565
49582: POP
49583: POP
// end ;
49584: PPOPN 2
49586: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49587: LD_EXP 91
49591: PUSH
49592: LD_EXP 94
49596: AND
49597: IFFALSE 49690
49599: GO 49601
49601: DISABLE
49602: LD_INT 0
49604: PPUSH
// begin enable ;
49605: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49606: LD_ADDR_VAR 0 1
49610: PUSH
49611: LD_INT 22
49613: PUSH
49614: LD_OWVAR 2
49618: PUSH
49619: EMPTY
49620: LIST
49621: LIST
49622: PUSH
49623: LD_INT 2
49625: PUSH
49626: LD_INT 25
49628: PUSH
49629: LD_INT 5
49631: PUSH
49632: EMPTY
49633: LIST
49634: LIST
49635: PUSH
49636: LD_INT 25
49638: PUSH
49639: LD_INT 9
49641: PUSH
49642: EMPTY
49643: LIST
49644: LIST
49645: PUSH
49646: LD_INT 25
49648: PUSH
49649: LD_INT 8
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: PUSH
49656: EMPTY
49657: LIST
49658: LIST
49659: LIST
49660: LIST
49661: PUSH
49662: EMPTY
49663: LIST
49664: LIST
49665: PPUSH
49666: CALL_OW 69
49670: PUSH
49671: FOR_IN
49672: IFFALSE 49688
// begin SetClass ( i , 1 ) ;
49674: LD_VAR 0 1
49678: PPUSH
49679: LD_INT 1
49681: PPUSH
49682: CALL_OW 336
// end ;
49686: GO 49671
49688: POP
49689: POP
// end ;
49690: PPOPN 1
49692: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49693: LD_EXP 91
49697: PUSH
49698: LD_EXP 95
49702: AND
49703: PUSH
49704: LD_OWVAR 65
49708: PUSH
49709: LD_INT 7
49711: LESS
49712: AND
49713: IFFALSE 49727
49715: GO 49717
49717: DISABLE
// begin enable ;
49718: ENABLE
// game_speed := 7 ;
49719: LD_ADDR_OWVAR 65
49723: PUSH
49724: LD_INT 7
49726: ST_TO_ADDR
// end ;
49727: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49728: LD_EXP 91
49732: PUSH
49733: LD_EXP 98
49737: AND
49738: IFFALSE 49940
49740: GO 49742
49742: DISABLE
49743: LD_INT 0
49745: PPUSH
49746: PPUSH
49747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49748: LD_ADDR_VAR 0 3
49752: PUSH
49753: LD_INT 81
49755: PUSH
49756: LD_OWVAR 2
49760: PUSH
49761: EMPTY
49762: LIST
49763: LIST
49764: PUSH
49765: LD_INT 21
49767: PUSH
49768: LD_INT 1
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PPUSH
49779: CALL_OW 69
49783: ST_TO_ADDR
// if not tmp then
49784: LD_VAR 0 3
49788: NOT
49789: IFFALSE 49793
// exit ;
49791: GO 49940
// if tmp > 5 then
49793: LD_VAR 0 3
49797: PUSH
49798: LD_INT 5
49800: GREATER
49801: IFFALSE 49813
// k := 5 else
49803: LD_ADDR_VAR 0 2
49807: PUSH
49808: LD_INT 5
49810: ST_TO_ADDR
49811: GO 49823
// k := tmp ;
49813: LD_ADDR_VAR 0 2
49817: PUSH
49818: LD_VAR 0 3
49822: ST_TO_ADDR
// for i := 1 to k do
49823: LD_ADDR_VAR 0 1
49827: PUSH
49828: DOUBLE
49829: LD_INT 1
49831: DEC
49832: ST_TO_ADDR
49833: LD_VAR 0 2
49837: PUSH
49838: FOR_TO
49839: IFFALSE 49938
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49841: LD_VAR 0 3
49845: PUSH
49846: LD_VAR 0 1
49850: ARRAY
49851: PPUSH
49852: LD_VAR 0 1
49856: PUSH
49857: LD_INT 4
49859: MOD
49860: PUSH
49861: LD_INT 1
49863: PLUS
49864: PPUSH
49865: CALL_OW 259
49869: PUSH
49870: LD_INT 10
49872: LESS
49873: IFFALSE 49936
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49875: LD_VAR 0 3
49879: PUSH
49880: LD_VAR 0 1
49884: ARRAY
49885: PPUSH
49886: LD_VAR 0 1
49890: PUSH
49891: LD_INT 4
49893: MOD
49894: PUSH
49895: LD_INT 1
49897: PLUS
49898: PPUSH
49899: LD_VAR 0 3
49903: PUSH
49904: LD_VAR 0 1
49908: ARRAY
49909: PPUSH
49910: LD_VAR 0 1
49914: PUSH
49915: LD_INT 4
49917: MOD
49918: PUSH
49919: LD_INT 1
49921: PLUS
49922: PPUSH
49923: CALL_OW 259
49927: PUSH
49928: LD_INT 1
49930: PLUS
49931: PPUSH
49932: CALL_OW 237
49936: GO 49838
49938: POP
49939: POP
// end ;
49940: PPOPN 3
49942: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49943: LD_EXP 91
49947: PUSH
49948: LD_EXP 99
49952: AND
49953: IFFALSE 49973
49955: GO 49957
49957: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49958: LD_INT 4
49960: PPUSH
49961: LD_OWVAR 2
49965: PPUSH
49966: LD_INT 0
49968: PPUSH
49969: CALL_OW 324
49973: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49974: LD_EXP 91
49978: PUSH
49979: LD_EXP 128
49983: AND
49984: IFFALSE 50004
49986: GO 49988
49988: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49989: LD_INT 19
49991: PPUSH
49992: LD_OWVAR 2
49996: PPUSH
49997: LD_INT 0
49999: PPUSH
50000: CALL_OW 324
50004: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
50005: LD_EXP 91
50009: PUSH
50010: LD_EXP 100
50014: AND
50015: IFFALSE 50117
50017: GO 50019
50019: DISABLE
50020: LD_INT 0
50022: PPUSH
50023: PPUSH
// begin enable ;
50024: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
50025: LD_ADDR_VAR 0 2
50029: PUSH
50030: LD_INT 22
50032: PUSH
50033: LD_OWVAR 2
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: PUSH
50042: LD_INT 2
50044: PUSH
50045: LD_INT 34
50047: PUSH
50048: LD_INT 11
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: LD_INT 34
50057: PUSH
50058: LD_INT 30
50060: PUSH
50061: EMPTY
50062: LIST
50063: LIST
50064: PUSH
50065: EMPTY
50066: LIST
50067: LIST
50068: LIST
50069: PUSH
50070: EMPTY
50071: LIST
50072: LIST
50073: PPUSH
50074: CALL_OW 69
50078: ST_TO_ADDR
// if not tmp then
50079: LD_VAR 0 2
50083: NOT
50084: IFFALSE 50088
// exit ;
50086: GO 50117
// for i in tmp do
50088: LD_ADDR_VAR 0 1
50092: PUSH
50093: LD_VAR 0 2
50097: PUSH
50098: FOR_IN
50099: IFFALSE 50115
// begin SetLives ( i , 0 ) ;
50101: LD_VAR 0 1
50105: PPUSH
50106: LD_INT 0
50108: PPUSH
50109: CALL_OW 234
// end ;
50113: GO 50098
50115: POP
50116: POP
// end ;
50117: PPOPN 2
50119: END
// every 0 0$1 trigger StreamModeActive and sBunker do
50120: LD_EXP 91
50124: PUSH
50125: LD_EXP 101
50129: AND
50130: IFFALSE 50150
50132: GO 50134
50134: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
50135: LD_INT 32
50137: PPUSH
50138: LD_OWVAR 2
50142: PPUSH
50143: LD_INT 0
50145: PPUSH
50146: CALL_OW 324
50150: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
50151: LD_EXP 91
50155: PUSH
50156: LD_EXP 102
50160: AND
50161: IFFALSE 50342
50163: GO 50165
50165: DISABLE
50166: LD_INT 0
50168: PPUSH
50169: PPUSH
50170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50171: LD_ADDR_VAR 0 2
50175: PUSH
50176: LD_INT 22
50178: PUSH
50179: LD_OWVAR 2
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: LD_INT 33
50190: PUSH
50191: LD_INT 3
50193: PUSH
50194: EMPTY
50195: LIST
50196: LIST
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PPUSH
50202: CALL_OW 69
50206: ST_TO_ADDR
// if not tmp then
50207: LD_VAR 0 2
50211: NOT
50212: IFFALSE 50216
// exit ;
50214: GO 50342
// side := 0 ;
50216: LD_ADDR_VAR 0 3
50220: PUSH
50221: LD_INT 0
50223: ST_TO_ADDR
// for i := 1 to 8 do
50224: LD_ADDR_VAR 0 1
50228: PUSH
50229: DOUBLE
50230: LD_INT 1
50232: DEC
50233: ST_TO_ADDR
50234: LD_INT 8
50236: PUSH
50237: FOR_TO
50238: IFFALSE 50286
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50240: LD_OWVAR 2
50244: PUSH
50245: LD_VAR 0 1
50249: NONEQUAL
50250: PUSH
50251: LD_OWVAR 2
50255: PPUSH
50256: LD_VAR 0 1
50260: PPUSH
50261: CALL_OW 81
50265: PUSH
50266: LD_INT 2
50268: EQUAL
50269: AND
50270: IFFALSE 50284
// begin side := i ;
50272: LD_ADDR_VAR 0 3
50276: PUSH
50277: LD_VAR 0 1
50281: ST_TO_ADDR
// break ;
50282: GO 50286
// end ;
50284: GO 50237
50286: POP
50287: POP
// if not side then
50288: LD_VAR 0 3
50292: NOT
50293: IFFALSE 50297
// exit ;
50295: GO 50342
// for i := 1 to tmp do
50297: LD_ADDR_VAR 0 1
50301: PUSH
50302: DOUBLE
50303: LD_INT 1
50305: DEC
50306: ST_TO_ADDR
50307: LD_VAR 0 2
50311: PUSH
50312: FOR_TO
50313: IFFALSE 50340
// if Prob ( 60 ) then
50315: LD_INT 60
50317: PPUSH
50318: CALL_OW 13
50322: IFFALSE 50338
// SetSide ( i , side ) ;
50324: LD_VAR 0 1
50328: PPUSH
50329: LD_VAR 0 3
50333: PPUSH
50334: CALL_OW 235
50338: GO 50312
50340: POP
50341: POP
// end ;
50342: PPOPN 3
50344: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50345: LD_EXP 91
50349: PUSH
50350: LD_EXP 104
50354: AND
50355: IFFALSE 50474
50357: GO 50359
50359: DISABLE
50360: LD_INT 0
50362: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50363: LD_ADDR_VAR 0 1
50367: PUSH
50368: LD_INT 22
50370: PUSH
50371: LD_OWVAR 2
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: PUSH
50380: LD_INT 21
50382: PUSH
50383: LD_INT 1
50385: PUSH
50386: EMPTY
50387: LIST
50388: LIST
50389: PUSH
50390: LD_INT 3
50392: PUSH
50393: LD_INT 23
50395: PUSH
50396: LD_INT 0
50398: PUSH
50399: EMPTY
50400: LIST
50401: LIST
50402: PUSH
50403: EMPTY
50404: LIST
50405: LIST
50406: PUSH
50407: EMPTY
50408: LIST
50409: LIST
50410: LIST
50411: PPUSH
50412: CALL_OW 69
50416: PUSH
50417: FOR_IN
50418: IFFALSE 50472
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50420: LD_VAR 0 1
50424: PPUSH
50425: CALL_OW 257
50429: PUSH
50430: LD_INT 1
50432: PUSH
50433: LD_INT 2
50435: PUSH
50436: LD_INT 3
50438: PUSH
50439: LD_INT 4
50441: PUSH
50442: EMPTY
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: IN
50448: IFFALSE 50470
// SetClass ( un , rand ( 1 , 4 ) ) ;
50450: LD_VAR 0 1
50454: PPUSH
50455: LD_INT 1
50457: PPUSH
50458: LD_INT 4
50460: PPUSH
50461: CALL_OW 12
50465: PPUSH
50466: CALL_OW 336
50470: GO 50417
50472: POP
50473: POP
// end ;
50474: PPOPN 1
50476: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50477: LD_EXP 91
50481: PUSH
50482: LD_EXP 103
50486: AND
50487: IFFALSE 50566
50489: GO 50491
50491: DISABLE
50492: LD_INT 0
50494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50495: LD_ADDR_VAR 0 1
50499: PUSH
50500: LD_INT 22
50502: PUSH
50503: LD_OWVAR 2
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: PUSH
50512: LD_INT 21
50514: PUSH
50515: LD_INT 3
50517: PUSH
50518: EMPTY
50519: LIST
50520: LIST
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: PPUSH
50526: CALL_OW 69
50530: ST_TO_ADDR
// if not tmp then
50531: LD_VAR 0 1
50535: NOT
50536: IFFALSE 50540
// exit ;
50538: GO 50566
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50540: LD_VAR 0 1
50544: PUSH
50545: LD_INT 1
50547: PPUSH
50548: LD_VAR 0 1
50552: PPUSH
50553: CALL_OW 12
50557: ARRAY
50558: PPUSH
50559: LD_INT 100
50561: PPUSH
50562: CALL_OW 234
// end ;
50566: PPOPN 1
50568: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50569: LD_EXP 91
50573: PUSH
50574: LD_EXP 105
50578: AND
50579: IFFALSE 50677
50581: GO 50583
50583: DISABLE
50584: LD_INT 0
50586: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50587: LD_ADDR_VAR 0 1
50591: PUSH
50592: LD_INT 22
50594: PUSH
50595: LD_OWVAR 2
50599: PUSH
50600: EMPTY
50601: LIST
50602: LIST
50603: PUSH
50604: LD_INT 21
50606: PUSH
50607: LD_INT 1
50609: PUSH
50610: EMPTY
50611: LIST
50612: LIST
50613: PUSH
50614: EMPTY
50615: LIST
50616: LIST
50617: PPUSH
50618: CALL_OW 69
50622: ST_TO_ADDR
// if not tmp then
50623: LD_VAR 0 1
50627: NOT
50628: IFFALSE 50632
// exit ;
50630: GO 50677
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50632: LD_VAR 0 1
50636: PUSH
50637: LD_INT 1
50639: PPUSH
50640: LD_VAR 0 1
50644: PPUSH
50645: CALL_OW 12
50649: ARRAY
50650: PPUSH
50651: LD_INT 1
50653: PPUSH
50654: LD_INT 4
50656: PPUSH
50657: CALL_OW 12
50661: PPUSH
50662: LD_INT 3000
50664: PPUSH
50665: LD_INT 9000
50667: PPUSH
50668: CALL_OW 12
50672: PPUSH
50673: CALL_OW 492
// end ;
50677: PPOPN 1
50679: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50680: LD_EXP 91
50684: PUSH
50685: LD_EXP 106
50689: AND
50690: IFFALSE 50710
50692: GO 50694
50694: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50695: LD_INT 1
50697: PPUSH
50698: LD_OWVAR 2
50702: PPUSH
50703: LD_INT 0
50705: PPUSH
50706: CALL_OW 324
50710: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50711: LD_EXP 91
50715: PUSH
50716: LD_EXP 107
50720: AND
50721: IFFALSE 50804
50723: GO 50725
50725: DISABLE
50726: LD_INT 0
50728: PPUSH
50729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50730: LD_ADDR_VAR 0 2
50734: PUSH
50735: LD_INT 22
50737: PUSH
50738: LD_OWVAR 2
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PUSH
50747: LD_INT 21
50749: PUSH
50750: LD_INT 3
50752: PUSH
50753: EMPTY
50754: LIST
50755: LIST
50756: PUSH
50757: EMPTY
50758: LIST
50759: LIST
50760: PPUSH
50761: CALL_OW 69
50765: ST_TO_ADDR
// if not tmp then
50766: LD_VAR 0 2
50770: NOT
50771: IFFALSE 50775
// exit ;
50773: GO 50804
// for i in tmp do
50775: LD_ADDR_VAR 0 1
50779: PUSH
50780: LD_VAR 0 2
50784: PUSH
50785: FOR_IN
50786: IFFALSE 50802
// SetBLevel ( i , 10 ) ;
50788: LD_VAR 0 1
50792: PPUSH
50793: LD_INT 10
50795: PPUSH
50796: CALL_OW 241
50800: GO 50785
50802: POP
50803: POP
// end ;
50804: PPOPN 2
50806: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50807: LD_EXP 91
50811: PUSH
50812: LD_EXP 108
50816: AND
50817: IFFALSE 50928
50819: GO 50821
50821: DISABLE
50822: LD_INT 0
50824: PPUSH
50825: PPUSH
50826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50827: LD_ADDR_VAR 0 3
50831: PUSH
50832: LD_INT 22
50834: PUSH
50835: LD_OWVAR 2
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PUSH
50844: LD_INT 25
50846: PUSH
50847: LD_INT 1
50849: PUSH
50850: EMPTY
50851: LIST
50852: LIST
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PPUSH
50858: CALL_OW 69
50862: ST_TO_ADDR
// if not tmp then
50863: LD_VAR 0 3
50867: NOT
50868: IFFALSE 50872
// exit ;
50870: GO 50928
// un := tmp [ rand ( 1 , tmp ) ] ;
50872: LD_ADDR_VAR 0 2
50876: PUSH
50877: LD_VAR 0 3
50881: PUSH
50882: LD_INT 1
50884: PPUSH
50885: LD_VAR 0 3
50889: PPUSH
50890: CALL_OW 12
50894: ARRAY
50895: ST_TO_ADDR
// if Crawls ( un ) then
50896: LD_VAR 0 2
50900: PPUSH
50901: CALL_OW 318
50905: IFFALSE 50916
// ComWalk ( un ) ;
50907: LD_VAR 0 2
50911: PPUSH
50912: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50916: LD_VAR 0 2
50920: PPUSH
50921: LD_INT 5
50923: PPUSH
50924: CALL_OW 336
// end ;
50928: PPOPN 3
50930: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50931: LD_EXP 91
50935: PUSH
50936: LD_EXP 109
50940: AND
50941: PUSH
50942: LD_OWVAR 67
50946: PUSH
50947: LD_INT 4
50949: LESS
50950: AND
50951: IFFALSE 50970
50953: GO 50955
50955: DISABLE
// begin Difficulty := Difficulty + 1 ;
50956: LD_ADDR_OWVAR 67
50960: PUSH
50961: LD_OWVAR 67
50965: PUSH
50966: LD_INT 1
50968: PLUS
50969: ST_TO_ADDR
// end ;
50970: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50971: LD_EXP 91
50975: PUSH
50976: LD_EXP 110
50980: AND
50981: IFFALSE 51084
50983: GO 50985
50985: DISABLE
50986: LD_INT 0
50988: PPUSH
// begin for i := 1 to 5 do
50989: LD_ADDR_VAR 0 1
50993: PUSH
50994: DOUBLE
50995: LD_INT 1
50997: DEC
50998: ST_TO_ADDR
50999: LD_INT 5
51001: PUSH
51002: FOR_TO
51003: IFFALSE 51082
// begin uc_nation := nation_nature ;
51005: LD_ADDR_OWVAR 21
51009: PUSH
51010: LD_INT 0
51012: ST_TO_ADDR
// uc_side := 0 ;
51013: LD_ADDR_OWVAR 20
51017: PUSH
51018: LD_INT 0
51020: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51021: LD_ADDR_OWVAR 29
51025: PUSH
51026: LD_INT 12
51028: PUSH
51029: LD_INT 12
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: ST_TO_ADDR
// hc_agressivity := 20 ;
51036: LD_ADDR_OWVAR 35
51040: PUSH
51041: LD_INT 20
51043: ST_TO_ADDR
// hc_class := class_tiger ;
51044: LD_ADDR_OWVAR 28
51048: PUSH
51049: LD_INT 14
51051: ST_TO_ADDR
// hc_gallery :=  ;
51052: LD_ADDR_OWVAR 33
51056: PUSH
51057: LD_STRING 
51059: ST_TO_ADDR
// hc_name :=  ;
51060: LD_ADDR_OWVAR 26
51064: PUSH
51065: LD_STRING 
51067: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
51068: CALL_OW 44
51072: PPUSH
51073: LD_INT 0
51075: PPUSH
51076: CALL_OW 51
// end ;
51080: GO 51002
51082: POP
51083: POP
// end ;
51084: PPOPN 1
51086: END
// every 0 0$1 trigger StreamModeActive and sBomb do
51087: LD_EXP 91
51091: PUSH
51092: LD_EXP 111
51096: AND
51097: IFFALSE 51106
51099: GO 51101
51101: DISABLE
// StreamSibBomb ;
51102: CALL 51107 0 0
51106: END
// export function StreamSibBomb ; var i , x , y ; begin
51107: LD_INT 0
51109: PPUSH
51110: PPUSH
51111: PPUSH
51112: PPUSH
// result := false ;
51113: LD_ADDR_VAR 0 1
51117: PUSH
51118: LD_INT 0
51120: ST_TO_ADDR
// for i := 1 to 16 do
51121: LD_ADDR_VAR 0 2
51125: PUSH
51126: DOUBLE
51127: LD_INT 1
51129: DEC
51130: ST_TO_ADDR
51131: LD_INT 16
51133: PUSH
51134: FOR_TO
51135: IFFALSE 51334
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51137: LD_ADDR_VAR 0 3
51141: PUSH
51142: LD_INT 10
51144: PUSH
51145: LD_INT 20
51147: PUSH
51148: LD_INT 30
51150: PUSH
51151: LD_INT 40
51153: PUSH
51154: LD_INT 50
51156: PUSH
51157: LD_INT 60
51159: PUSH
51160: LD_INT 70
51162: PUSH
51163: LD_INT 80
51165: PUSH
51166: LD_INT 90
51168: PUSH
51169: LD_INT 100
51171: PUSH
51172: LD_INT 110
51174: PUSH
51175: LD_INT 120
51177: PUSH
51178: LD_INT 130
51180: PUSH
51181: LD_INT 140
51183: PUSH
51184: LD_INT 150
51186: PUSH
51187: EMPTY
51188: LIST
51189: LIST
51190: LIST
51191: LIST
51192: LIST
51193: LIST
51194: LIST
51195: LIST
51196: LIST
51197: LIST
51198: LIST
51199: LIST
51200: LIST
51201: LIST
51202: LIST
51203: PUSH
51204: LD_INT 1
51206: PPUSH
51207: LD_INT 15
51209: PPUSH
51210: CALL_OW 12
51214: ARRAY
51215: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51216: LD_ADDR_VAR 0 4
51220: PUSH
51221: LD_INT 10
51223: PUSH
51224: LD_INT 20
51226: PUSH
51227: LD_INT 30
51229: PUSH
51230: LD_INT 40
51232: PUSH
51233: LD_INT 50
51235: PUSH
51236: LD_INT 60
51238: PUSH
51239: LD_INT 70
51241: PUSH
51242: LD_INT 80
51244: PUSH
51245: LD_INT 90
51247: PUSH
51248: LD_INT 100
51250: PUSH
51251: LD_INT 110
51253: PUSH
51254: LD_INT 120
51256: PUSH
51257: LD_INT 130
51259: PUSH
51260: LD_INT 140
51262: PUSH
51263: LD_INT 150
51265: PUSH
51266: EMPTY
51267: LIST
51268: LIST
51269: LIST
51270: LIST
51271: LIST
51272: LIST
51273: LIST
51274: LIST
51275: LIST
51276: LIST
51277: LIST
51278: LIST
51279: LIST
51280: LIST
51281: LIST
51282: PUSH
51283: LD_INT 1
51285: PPUSH
51286: LD_INT 15
51288: PPUSH
51289: CALL_OW 12
51293: ARRAY
51294: ST_TO_ADDR
// if ValidHex ( x , y ) then
51295: LD_VAR 0 3
51299: PPUSH
51300: LD_VAR 0 4
51304: PPUSH
51305: CALL_OW 488
51309: IFFALSE 51332
// begin result := [ x , y ] ;
51311: LD_ADDR_VAR 0 1
51315: PUSH
51316: LD_VAR 0 3
51320: PUSH
51321: LD_VAR 0 4
51325: PUSH
51326: EMPTY
51327: LIST
51328: LIST
51329: ST_TO_ADDR
// break ;
51330: GO 51334
// end ; end ;
51332: GO 51134
51334: POP
51335: POP
// if result then
51336: LD_VAR 0 1
51340: IFFALSE 51400
// begin ToLua ( playSibBomb() ) ;
51342: LD_STRING playSibBomb()
51344: PPUSH
51345: CALL_OW 559
// wait ( 0 0$14 ) ;
51349: LD_INT 490
51351: PPUSH
51352: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51356: LD_VAR 0 1
51360: PUSH
51361: LD_INT 1
51363: ARRAY
51364: PPUSH
51365: LD_VAR 0 1
51369: PUSH
51370: LD_INT 2
51372: ARRAY
51373: PPUSH
51374: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51378: LD_VAR 0 1
51382: PUSH
51383: LD_INT 1
51385: ARRAY
51386: PPUSH
51387: LD_VAR 0 1
51391: PUSH
51392: LD_INT 2
51394: ARRAY
51395: PPUSH
51396: CALL_OW 429
// end ; end ;
51400: LD_VAR 0 1
51404: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51405: LD_EXP 91
51409: PUSH
51410: LD_EXP 113
51414: AND
51415: IFFALSE 51427
51417: GO 51419
51419: DISABLE
// YouLost (  ) ;
51420: LD_STRING 
51422: PPUSH
51423: CALL_OW 104
51427: END
// every 0 0$1 trigger StreamModeActive and sFog do
51428: LD_EXP 91
51432: PUSH
51433: LD_EXP 112
51437: AND
51438: IFFALSE 51452
51440: GO 51442
51442: DISABLE
// FogOff ( your_side ) ;
51443: LD_OWVAR 2
51447: PPUSH
51448: CALL_OW 344
51452: END
// every 0 0$1 trigger StreamModeActive and sSun do
51453: LD_EXP 91
51457: PUSH
51458: LD_EXP 114
51462: AND
51463: IFFALSE 51491
51465: GO 51467
51467: DISABLE
// begin solar_recharge_percent := 0 ;
51468: LD_ADDR_OWVAR 79
51472: PUSH
51473: LD_INT 0
51475: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51476: LD_INT 10500
51478: PPUSH
51479: CALL_OW 67
// solar_recharge_percent := 100 ;
51483: LD_ADDR_OWVAR 79
51487: PUSH
51488: LD_INT 100
51490: ST_TO_ADDR
// end ;
51491: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51492: LD_EXP 91
51496: PUSH
51497: LD_EXP 115
51501: AND
51502: IFFALSE 51741
51504: GO 51506
51506: DISABLE
51507: LD_INT 0
51509: PPUSH
51510: PPUSH
51511: PPUSH
// begin tmp := [ ] ;
51512: LD_ADDR_VAR 0 3
51516: PUSH
51517: EMPTY
51518: ST_TO_ADDR
// for i := 1 to 6 do
51519: LD_ADDR_VAR 0 1
51523: PUSH
51524: DOUBLE
51525: LD_INT 1
51527: DEC
51528: ST_TO_ADDR
51529: LD_INT 6
51531: PUSH
51532: FOR_TO
51533: IFFALSE 51638
// begin uc_nation := nation_nature ;
51535: LD_ADDR_OWVAR 21
51539: PUSH
51540: LD_INT 0
51542: ST_TO_ADDR
// uc_side := 0 ;
51543: LD_ADDR_OWVAR 20
51547: PUSH
51548: LD_INT 0
51550: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51551: LD_ADDR_OWVAR 29
51555: PUSH
51556: LD_INT 12
51558: PUSH
51559: LD_INT 12
51561: PUSH
51562: EMPTY
51563: LIST
51564: LIST
51565: ST_TO_ADDR
// hc_agressivity := 20 ;
51566: LD_ADDR_OWVAR 35
51570: PUSH
51571: LD_INT 20
51573: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51574: LD_ADDR_OWVAR 28
51578: PUSH
51579: LD_INT 17
51581: ST_TO_ADDR
// hc_gallery :=  ;
51582: LD_ADDR_OWVAR 33
51586: PUSH
51587: LD_STRING 
51589: ST_TO_ADDR
// hc_name :=  ;
51590: LD_ADDR_OWVAR 26
51594: PUSH
51595: LD_STRING 
51597: ST_TO_ADDR
// un := CreateHuman ;
51598: LD_ADDR_VAR 0 2
51602: PUSH
51603: CALL_OW 44
51607: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51608: LD_VAR 0 2
51612: PPUSH
51613: LD_INT 1
51615: PPUSH
51616: CALL_OW 51
// tmp := tmp ^ un ;
51620: LD_ADDR_VAR 0 3
51624: PUSH
51625: LD_VAR 0 3
51629: PUSH
51630: LD_VAR 0 2
51634: ADD
51635: ST_TO_ADDR
// end ;
51636: GO 51532
51638: POP
51639: POP
// repeat wait ( 0 0$1 ) ;
51640: LD_INT 35
51642: PPUSH
51643: CALL_OW 67
// for un in tmp do
51647: LD_ADDR_VAR 0 2
51651: PUSH
51652: LD_VAR 0 3
51656: PUSH
51657: FOR_IN
51658: IFFALSE 51732
// begin if IsDead ( un ) then
51660: LD_VAR 0 2
51664: PPUSH
51665: CALL_OW 301
51669: IFFALSE 51689
// begin tmp := tmp diff un ;
51671: LD_ADDR_VAR 0 3
51675: PUSH
51676: LD_VAR 0 3
51680: PUSH
51681: LD_VAR 0 2
51685: DIFF
51686: ST_TO_ADDR
// continue ;
51687: GO 51657
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51689: LD_VAR 0 2
51693: PPUSH
51694: LD_INT 3
51696: PUSH
51697: LD_INT 22
51699: PUSH
51700: LD_INT 0
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: PUSH
51707: EMPTY
51708: LIST
51709: LIST
51710: PPUSH
51711: CALL_OW 69
51715: PPUSH
51716: LD_VAR 0 2
51720: PPUSH
51721: CALL_OW 74
51725: PPUSH
51726: CALL_OW 115
// end ;
51730: GO 51657
51732: POP
51733: POP
// until not tmp ;
51734: LD_VAR 0 3
51738: NOT
51739: IFFALSE 51640
// end ;
51741: PPOPN 3
51743: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51744: LD_EXP 91
51748: PUSH
51749: LD_EXP 116
51753: AND
51754: IFFALSE 51808
51756: GO 51758
51758: DISABLE
// begin ToLua ( displayTroll(); ) ;
51759: LD_STRING displayTroll();
51761: PPUSH
51762: CALL_OW 559
// wait ( 3 3$00 ) ;
51766: LD_INT 6300
51768: PPUSH
51769: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51773: LD_STRING hideTroll();
51775: PPUSH
51776: CALL_OW 559
// wait ( 1 1$00 ) ;
51780: LD_INT 2100
51782: PPUSH
51783: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51787: LD_STRING displayTroll();
51789: PPUSH
51790: CALL_OW 559
// wait ( 1 1$00 ) ;
51794: LD_INT 2100
51796: PPUSH
51797: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51801: LD_STRING hideTroll();
51803: PPUSH
51804: CALL_OW 559
// end ;
51808: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51809: LD_EXP 91
51813: PUSH
51814: LD_EXP 117
51818: AND
51819: IFFALSE 51882
51821: GO 51823
51823: DISABLE
51824: LD_INT 0
51826: PPUSH
// begin p := 0 ;
51827: LD_ADDR_VAR 0 1
51831: PUSH
51832: LD_INT 0
51834: ST_TO_ADDR
// repeat game_speed := 1 ;
51835: LD_ADDR_OWVAR 65
51839: PUSH
51840: LD_INT 1
51842: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51843: LD_INT 35
51845: PPUSH
51846: CALL_OW 67
// p := p + 1 ;
51850: LD_ADDR_VAR 0 1
51854: PUSH
51855: LD_VAR 0 1
51859: PUSH
51860: LD_INT 1
51862: PLUS
51863: ST_TO_ADDR
// until p >= 60 ;
51864: LD_VAR 0 1
51868: PUSH
51869: LD_INT 60
51871: GREATEREQUAL
51872: IFFALSE 51835
// game_speed := 4 ;
51874: LD_ADDR_OWVAR 65
51878: PUSH
51879: LD_INT 4
51881: ST_TO_ADDR
// end ;
51882: PPOPN 1
51884: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51885: LD_EXP 91
51889: PUSH
51890: LD_EXP 118
51894: AND
51895: IFFALSE 52041
51897: GO 51899
51899: DISABLE
51900: LD_INT 0
51902: PPUSH
51903: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51904: LD_ADDR_VAR 0 1
51908: PUSH
51909: LD_INT 22
51911: PUSH
51912: LD_OWVAR 2
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PUSH
51921: LD_INT 2
51923: PUSH
51924: LD_INT 30
51926: PUSH
51927: LD_INT 0
51929: PUSH
51930: EMPTY
51931: LIST
51932: LIST
51933: PUSH
51934: LD_INT 30
51936: PUSH
51937: LD_INT 1
51939: PUSH
51940: EMPTY
51941: LIST
51942: LIST
51943: PUSH
51944: EMPTY
51945: LIST
51946: LIST
51947: LIST
51948: PUSH
51949: EMPTY
51950: LIST
51951: LIST
51952: PPUSH
51953: CALL_OW 69
51957: ST_TO_ADDR
// if not depot then
51958: LD_VAR 0 1
51962: NOT
51963: IFFALSE 51967
// exit ;
51965: GO 52041
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51967: LD_ADDR_VAR 0 2
51971: PUSH
51972: LD_VAR 0 1
51976: PUSH
51977: LD_INT 1
51979: PPUSH
51980: LD_VAR 0 1
51984: PPUSH
51985: CALL_OW 12
51989: ARRAY
51990: PPUSH
51991: CALL_OW 274
51995: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51996: LD_VAR 0 2
52000: PPUSH
52001: LD_INT 1
52003: PPUSH
52004: LD_INT 0
52006: PPUSH
52007: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
52011: LD_VAR 0 2
52015: PPUSH
52016: LD_INT 2
52018: PPUSH
52019: LD_INT 0
52021: PPUSH
52022: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
52026: LD_VAR 0 2
52030: PPUSH
52031: LD_INT 3
52033: PPUSH
52034: LD_INT 0
52036: PPUSH
52037: CALL_OW 277
// end ;
52041: PPOPN 2
52043: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
52044: LD_EXP 91
52048: PUSH
52049: LD_EXP 119
52053: AND
52054: IFFALSE 52151
52056: GO 52058
52058: DISABLE
52059: LD_INT 0
52061: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
52062: LD_ADDR_VAR 0 1
52066: PUSH
52067: LD_INT 22
52069: PUSH
52070: LD_OWVAR 2
52074: PUSH
52075: EMPTY
52076: LIST
52077: LIST
52078: PUSH
52079: LD_INT 21
52081: PUSH
52082: LD_INT 1
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: PUSH
52089: LD_INT 3
52091: PUSH
52092: LD_INT 23
52094: PUSH
52095: LD_INT 0
52097: PUSH
52098: EMPTY
52099: LIST
52100: LIST
52101: PUSH
52102: EMPTY
52103: LIST
52104: LIST
52105: PUSH
52106: EMPTY
52107: LIST
52108: LIST
52109: LIST
52110: PPUSH
52111: CALL_OW 69
52115: ST_TO_ADDR
// if not tmp then
52116: LD_VAR 0 1
52120: NOT
52121: IFFALSE 52125
// exit ;
52123: GO 52151
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
52125: LD_VAR 0 1
52129: PUSH
52130: LD_INT 1
52132: PPUSH
52133: LD_VAR 0 1
52137: PPUSH
52138: CALL_OW 12
52142: ARRAY
52143: PPUSH
52144: LD_INT 200
52146: PPUSH
52147: CALL_OW 234
// end ;
52151: PPOPN 1
52153: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
52154: LD_EXP 91
52158: PUSH
52159: LD_EXP 120
52163: AND
52164: IFFALSE 52243
52166: GO 52168
52168: DISABLE
52169: LD_INT 0
52171: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52172: LD_ADDR_VAR 0 1
52176: PUSH
52177: LD_INT 22
52179: PUSH
52180: LD_OWVAR 2
52184: PUSH
52185: EMPTY
52186: LIST
52187: LIST
52188: PUSH
52189: LD_INT 21
52191: PUSH
52192: LD_INT 2
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: PUSH
52199: EMPTY
52200: LIST
52201: LIST
52202: PPUSH
52203: CALL_OW 69
52207: ST_TO_ADDR
// if not tmp then
52208: LD_VAR 0 1
52212: NOT
52213: IFFALSE 52217
// exit ;
52215: GO 52243
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52217: LD_VAR 0 1
52221: PUSH
52222: LD_INT 1
52224: PPUSH
52225: LD_VAR 0 1
52229: PPUSH
52230: CALL_OW 12
52234: ARRAY
52235: PPUSH
52236: LD_INT 60
52238: PPUSH
52239: CALL_OW 234
// end ;
52243: PPOPN 1
52245: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52246: LD_EXP 91
52250: PUSH
52251: LD_EXP 121
52255: AND
52256: IFFALSE 52355
52258: GO 52260
52260: DISABLE
52261: LD_INT 0
52263: PPUSH
52264: PPUSH
// begin enable ;
52265: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52266: LD_ADDR_VAR 0 1
52270: PUSH
52271: LD_INT 22
52273: PUSH
52274: LD_OWVAR 2
52278: PUSH
52279: EMPTY
52280: LIST
52281: LIST
52282: PUSH
52283: LD_INT 61
52285: PUSH
52286: EMPTY
52287: LIST
52288: PUSH
52289: LD_INT 33
52291: PUSH
52292: LD_INT 2
52294: PUSH
52295: EMPTY
52296: LIST
52297: LIST
52298: PUSH
52299: EMPTY
52300: LIST
52301: LIST
52302: LIST
52303: PPUSH
52304: CALL_OW 69
52308: ST_TO_ADDR
// if not tmp then
52309: LD_VAR 0 1
52313: NOT
52314: IFFALSE 52318
// exit ;
52316: GO 52355
// for i in tmp do
52318: LD_ADDR_VAR 0 2
52322: PUSH
52323: LD_VAR 0 1
52327: PUSH
52328: FOR_IN
52329: IFFALSE 52353
// if IsControledBy ( i ) then
52331: LD_VAR 0 2
52335: PPUSH
52336: CALL_OW 312
52340: IFFALSE 52351
// ComUnlink ( i ) ;
52342: LD_VAR 0 2
52346: PPUSH
52347: CALL_OW 136
52351: GO 52328
52353: POP
52354: POP
// end ;
52355: PPOPN 2
52357: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52358: LD_EXP 91
52362: PUSH
52363: LD_EXP 122
52367: AND
52368: IFFALSE 52508
52370: GO 52372
52372: DISABLE
52373: LD_INT 0
52375: PPUSH
52376: PPUSH
// begin ToLua ( displayPowell(); ) ;
52377: LD_STRING displayPowell();
52379: PPUSH
52380: CALL_OW 559
// uc_side := 0 ;
52384: LD_ADDR_OWVAR 20
52388: PUSH
52389: LD_INT 0
52391: ST_TO_ADDR
// uc_nation := 2 ;
52392: LD_ADDR_OWVAR 21
52396: PUSH
52397: LD_INT 2
52399: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52400: LD_ADDR_OWVAR 37
52404: PUSH
52405: LD_INT 14
52407: ST_TO_ADDR
// vc_engine := engine_siberite ;
52408: LD_ADDR_OWVAR 39
52412: PUSH
52413: LD_INT 3
52415: ST_TO_ADDR
// vc_control := control_apeman ;
52416: LD_ADDR_OWVAR 38
52420: PUSH
52421: LD_INT 5
52423: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52424: LD_ADDR_OWVAR 40
52428: PUSH
52429: LD_INT 29
52431: ST_TO_ADDR
// un := CreateVehicle ;
52432: LD_ADDR_VAR 0 2
52436: PUSH
52437: CALL_OW 45
52441: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52442: LD_VAR 0 2
52446: PPUSH
52447: LD_INT 1
52449: PPUSH
52450: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52454: LD_INT 35
52456: PPUSH
52457: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52461: LD_VAR 0 2
52465: PPUSH
52466: LD_INT 22
52468: PUSH
52469: LD_OWVAR 2
52473: PUSH
52474: EMPTY
52475: LIST
52476: LIST
52477: PPUSH
52478: CALL_OW 69
52482: PPUSH
52483: LD_VAR 0 2
52487: PPUSH
52488: CALL_OW 74
52492: PPUSH
52493: CALL_OW 115
// until IsDead ( un ) ;
52497: LD_VAR 0 2
52501: PPUSH
52502: CALL_OW 301
52506: IFFALSE 52454
// end ;
52508: PPOPN 2
52510: END
// every 0 0$1 trigger StreamModeActive and sStu do
52511: LD_EXP 91
52515: PUSH
52516: LD_EXP 130
52520: AND
52521: IFFALSE 52537
52523: GO 52525
52525: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52526: LD_STRING displayStucuk();
52528: PPUSH
52529: CALL_OW 559
// ResetFog ;
52533: CALL_OW 335
// end ;
52537: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52538: LD_EXP 91
52542: PUSH
52543: LD_EXP 123
52547: AND
52548: IFFALSE 52689
52550: GO 52552
52552: DISABLE
52553: LD_INT 0
52555: PPUSH
52556: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52557: LD_ADDR_VAR 0 2
52561: PUSH
52562: LD_INT 22
52564: PUSH
52565: LD_OWVAR 2
52569: PUSH
52570: EMPTY
52571: LIST
52572: LIST
52573: PUSH
52574: LD_INT 21
52576: PUSH
52577: LD_INT 1
52579: PUSH
52580: EMPTY
52581: LIST
52582: LIST
52583: PUSH
52584: EMPTY
52585: LIST
52586: LIST
52587: PPUSH
52588: CALL_OW 69
52592: ST_TO_ADDR
// if not tmp then
52593: LD_VAR 0 2
52597: NOT
52598: IFFALSE 52602
// exit ;
52600: GO 52689
// un := tmp [ rand ( 1 , tmp ) ] ;
52602: LD_ADDR_VAR 0 1
52606: PUSH
52607: LD_VAR 0 2
52611: PUSH
52612: LD_INT 1
52614: PPUSH
52615: LD_VAR 0 2
52619: PPUSH
52620: CALL_OW 12
52624: ARRAY
52625: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52626: LD_VAR 0 1
52630: PPUSH
52631: LD_INT 0
52633: PPUSH
52634: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52638: LD_VAR 0 1
52642: PPUSH
52643: LD_OWVAR 3
52647: PUSH
52648: LD_VAR 0 1
52652: DIFF
52653: PPUSH
52654: LD_VAR 0 1
52658: PPUSH
52659: CALL_OW 74
52663: PPUSH
52664: CALL_OW 115
// wait ( 0 0$20 ) ;
52668: LD_INT 700
52670: PPUSH
52671: CALL_OW 67
// SetSide ( un , your_side ) ;
52675: LD_VAR 0 1
52679: PPUSH
52680: LD_OWVAR 2
52684: PPUSH
52685: CALL_OW 235
// end ;
52689: PPOPN 2
52691: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52692: LD_EXP 91
52696: PUSH
52697: LD_EXP 124
52701: AND
52702: IFFALSE 52808
52704: GO 52706
52706: DISABLE
52707: LD_INT 0
52709: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52710: LD_ADDR_VAR 0 1
52714: PUSH
52715: LD_INT 22
52717: PUSH
52718: LD_OWVAR 2
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: PUSH
52727: LD_INT 2
52729: PUSH
52730: LD_INT 30
52732: PUSH
52733: LD_INT 0
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: PUSH
52740: LD_INT 30
52742: PUSH
52743: LD_INT 1
52745: PUSH
52746: EMPTY
52747: LIST
52748: LIST
52749: PUSH
52750: EMPTY
52751: LIST
52752: LIST
52753: LIST
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PPUSH
52759: CALL_OW 69
52763: ST_TO_ADDR
// if not depot then
52764: LD_VAR 0 1
52768: NOT
52769: IFFALSE 52773
// exit ;
52771: GO 52808
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52773: LD_VAR 0 1
52777: PUSH
52778: LD_INT 1
52780: ARRAY
52781: PPUSH
52782: CALL_OW 250
52786: PPUSH
52787: LD_VAR 0 1
52791: PUSH
52792: LD_INT 1
52794: ARRAY
52795: PPUSH
52796: CALL_OW 251
52800: PPUSH
52801: LD_INT 70
52803: PPUSH
52804: CALL_OW 495
// end ;
52808: PPOPN 1
52810: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52811: LD_EXP 91
52815: PUSH
52816: LD_EXP 125
52820: AND
52821: IFFALSE 53032
52823: GO 52825
52825: DISABLE
52826: LD_INT 0
52828: PPUSH
52829: PPUSH
52830: PPUSH
52831: PPUSH
52832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52833: LD_ADDR_VAR 0 5
52837: PUSH
52838: LD_INT 22
52840: PUSH
52841: LD_OWVAR 2
52845: PUSH
52846: EMPTY
52847: LIST
52848: LIST
52849: PUSH
52850: LD_INT 21
52852: PUSH
52853: LD_INT 1
52855: PUSH
52856: EMPTY
52857: LIST
52858: LIST
52859: PUSH
52860: EMPTY
52861: LIST
52862: LIST
52863: PPUSH
52864: CALL_OW 69
52868: ST_TO_ADDR
// if not tmp then
52869: LD_VAR 0 5
52873: NOT
52874: IFFALSE 52878
// exit ;
52876: GO 53032
// for i in tmp do
52878: LD_ADDR_VAR 0 1
52882: PUSH
52883: LD_VAR 0 5
52887: PUSH
52888: FOR_IN
52889: IFFALSE 53030
// begin d := rand ( 0 , 5 ) ;
52891: LD_ADDR_VAR 0 4
52895: PUSH
52896: LD_INT 0
52898: PPUSH
52899: LD_INT 5
52901: PPUSH
52902: CALL_OW 12
52906: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52907: LD_ADDR_VAR 0 2
52911: PUSH
52912: LD_VAR 0 1
52916: PPUSH
52917: CALL_OW 250
52921: PPUSH
52922: LD_VAR 0 4
52926: PPUSH
52927: LD_INT 3
52929: PPUSH
52930: LD_INT 12
52932: PPUSH
52933: CALL_OW 12
52937: PPUSH
52938: CALL_OW 272
52942: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52943: LD_ADDR_VAR 0 3
52947: PUSH
52948: LD_VAR 0 1
52952: PPUSH
52953: CALL_OW 251
52957: PPUSH
52958: LD_VAR 0 4
52962: PPUSH
52963: LD_INT 3
52965: PPUSH
52966: LD_INT 12
52968: PPUSH
52969: CALL_OW 12
52973: PPUSH
52974: CALL_OW 273
52978: ST_TO_ADDR
// if ValidHex ( x , y ) then
52979: LD_VAR 0 2
52983: PPUSH
52984: LD_VAR 0 3
52988: PPUSH
52989: CALL_OW 488
52993: IFFALSE 53028
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52995: LD_VAR 0 1
52999: PPUSH
53000: LD_VAR 0 2
53004: PPUSH
53005: LD_VAR 0 3
53009: PPUSH
53010: LD_INT 3
53012: PPUSH
53013: LD_INT 6
53015: PPUSH
53016: CALL_OW 12
53020: PPUSH
53021: LD_INT 1
53023: PPUSH
53024: CALL_OW 483
// end ;
53028: GO 52888
53030: POP
53031: POP
// end ;
53032: PPOPN 5
53034: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
53035: LD_EXP 91
53039: PUSH
53040: LD_EXP 126
53044: AND
53045: IFFALSE 53139
53047: GO 53049
53049: DISABLE
53050: LD_INT 0
53052: PPUSH
53053: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
53054: LD_ADDR_VAR 0 2
53058: PUSH
53059: LD_INT 22
53061: PUSH
53062: LD_OWVAR 2
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: PUSH
53071: LD_INT 32
53073: PUSH
53074: LD_INT 1
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: PUSH
53081: LD_INT 21
53083: PUSH
53084: LD_INT 2
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: PUSH
53091: EMPTY
53092: LIST
53093: LIST
53094: LIST
53095: PPUSH
53096: CALL_OW 69
53100: ST_TO_ADDR
// if not tmp then
53101: LD_VAR 0 2
53105: NOT
53106: IFFALSE 53110
// exit ;
53108: GO 53139
// for i in tmp do
53110: LD_ADDR_VAR 0 1
53114: PUSH
53115: LD_VAR 0 2
53119: PUSH
53120: FOR_IN
53121: IFFALSE 53137
// SetFuel ( i , 0 ) ;
53123: LD_VAR 0 1
53127: PPUSH
53128: LD_INT 0
53130: PPUSH
53131: CALL_OW 240
53135: GO 53120
53137: POP
53138: POP
// end ;
53139: PPOPN 2
53141: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
53142: LD_EXP 91
53146: PUSH
53147: LD_EXP 127
53151: AND
53152: IFFALSE 53218
53154: GO 53156
53156: DISABLE
53157: LD_INT 0
53159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53160: LD_ADDR_VAR 0 1
53164: PUSH
53165: LD_INT 22
53167: PUSH
53168: LD_OWVAR 2
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: PUSH
53177: LD_INT 30
53179: PUSH
53180: LD_INT 29
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: EMPTY
53188: LIST
53189: LIST
53190: PPUSH
53191: CALL_OW 69
53195: ST_TO_ADDR
// if not tmp then
53196: LD_VAR 0 1
53200: NOT
53201: IFFALSE 53205
// exit ;
53203: GO 53218
// DestroyUnit ( tmp [ 1 ] ) ;
53205: LD_VAR 0 1
53209: PUSH
53210: LD_INT 1
53212: ARRAY
53213: PPUSH
53214: CALL_OW 65
// end ;
53218: PPOPN 1
53220: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53221: LD_EXP 91
53225: PUSH
53226: LD_EXP 129
53230: AND
53231: IFFALSE 53360
53233: GO 53235
53235: DISABLE
53236: LD_INT 0
53238: PPUSH
// begin uc_side := 0 ;
53239: LD_ADDR_OWVAR 20
53243: PUSH
53244: LD_INT 0
53246: ST_TO_ADDR
// uc_nation := nation_arabian ;
53247: LD_ADDR_OWVAR 21
53251: PUSH
53252: LD_INT 2
53254: ST_TO_ADDR
// hc_gallery :=  ;
53255: LD_ADDR_OWVAR 33
53259: PUSH
53260: LD_STRING 
53262: ST_TO_ADDR
// hc_name :=  ;
53263: LD_ADDR_OWVAR 26
53267: PUSH
53268: LD_STRING 
53270: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53271: LD_INT 1
53273: PPUSH
53274: LD_INT 11
53276: PPUSH
53277: LD_INT 10
53279: PPUSH
53280: CALL_OW 380
// un := CreateHuman ;
53284: LD_ADDR_VAR 0 1
53288: PUSH
53289: CALL_OW 44
53293: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53294: LD_VAR 0 1
53298: PPUSH
53299: LD_INT 1
53301: PPUSH
53302: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53306: LD_INT 35
53308: PPUSH
53309: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53313: LD_VAR 0 1
53317: PPUSH
53318: LD_INT 22
53320: PUSH
53321: LD_OWVAR 2
53325: PUSH
53326: EMPTY
53327: LIST
53328: LIST
53329: PPUSH
53330: CALL_OW 69
53334: PPUSH
53335: LD_VAR 0 1
53339: PPUSH
53340: CALL_OW 74
53344: PPUSH
53345: CALL_OW 115
// until IsDead ( un ) ;
53349: LD_VAR 0 1
53353: PPUSH
53354: CALL_OW 301
53358: IFFALSE 53306
// end ;
53360: PPOPN 1
53362: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53363: LD_EXP 91
53367: PUSH
53368: LD_EXP 131
53372: AND
53373: IFFALSE 53385
53375: GO 53377
53377: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53378: LD_STRING earthquake(getX(game), 0, 32)
53380: PPUSH
53381: CALL_OW 559
53385: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53386: LD_EXP 91
53390: PUSH
53391: LD_EXP 132
53395: AND
53396: IFFALSE 53487
53398: GO 53400
53400: DISABLE
53401: LD_INT 0
53403: PPUSH
// begin enable ;
53404: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53405: LD_ADDR_VAR 0 1
53409: PUSH
53410: LD_INT 22
53412: PUSH
53413: LD_OWVAR 2
53417: PUSH
53418: EMPTY
53419: LIST
53420: LIST
53421: PUSH
53422: LD_INT 21
53424: PUSH
53425: LD_INT 2
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: PUSH
53432: LD_INT 33
53434: PUSH
53435: LD_INT 3
53437: PUSH
53438: EMPTY
53439: LIST
53440: LIST
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: LIST
53446: PPUSH
53447: CALL_OW 69
53451: ST_TO_ADDR
// if not tmp then
53452: LD_VAR 0 1
53456: NOT
53457: IFFALSE 53461
// exit ;
53459: GO 53487
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53461: LD_VAR 0 1
53465: PUSH
53466: LD_INT 1
53468: PPUSH
53469: LD_VAR 0 1
53473: PPUSH
53474: CALL_OW 12
53478: ARRAY
53479: PPUSH
53480: LD_INT 1
53482: PPUSH
53483: CALL_OW 234
// end ;
53487: PPOPN 1
53489: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53490: LD_EXP 91
53494: PUSH
53495: LD_EXP 133
53499: AND
53500: IFFALSE 53641
53502: GO 53504
53504: DISABLE
53505: LD_INT 0
53507: PPUSH
53508: PPUSH
53509: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53510: LD_ADDR_VAR 0 3
53514: PUSH
53515: LD_INT 22
53517: PUSH
53518: LD_OWVAR 2
53522: PUSH
53523: EMPTY
53524: LIST
53525: LIST
53526: PUSH
53527: LD_INT 25
53529: PUSH
53530: LD_INT 1
53532: PUSH
53533: EMPTY
53534: LIST
53535: LIST
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PPUSH
53541: CALL_OW 69
53545: ST_TO_ADDR
// if not tmp then
53546: LD_VAR 0 3
53550: NOT
53551: IFFALSE 53555
// exit ;
53553: GO 53641
// un := tmp [ rand ( 1 , tmp ) ] ;
53555: LD_ADDR_VAR 0 2
53559: PUSH
53560: LD_VAR 0 3
53564: PUSH
53565: LD_INT 1
53567: PPUSH
53568: LD_VAR 0 3
53572: PPUSH
53573: CALL_OW 12
53577: ARRAY
53578: ST_TO_ADDR
// if Crawls ( un ) then
53579: LD_VAR 0 2
53583: PPUSH
53584: CALL_OW 318
53588: IFFALSE 53599
// ComWalk ( un ) ;
53590: LD_VAR 0 2
53594: PPUSH
53595: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53599: LD_VAR 0 2
53603: PPUSH
53604: LD_INT 9
53606: PPUSH
53607: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53611: LD_INT 28
53613: PPUSH
53614: LD_OWVAR 2
53618: PPUSH
53619: LD_INT 2
53621: PPUSH
53622: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53626: LD_INT 29
53628: PPUSH
53629: LD_OWVAR 2
53633: PPUSH
53634: LD_INT 2
53636: PPUSH
53637: CALL_OW 322
// end ;
53641: PPOPN 3
53643: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53644: LD_EXP 91
53648: PUSH
53649: LD_EXP 134
53653: AND
53654: IFFALSE 53765
53656: GO 53658
53658: DISABLE
53659: LD_INT 0
53661: PPUSH
53662: PPUSH
53663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53664: LD_ADDR_VAR 0 3
53668: PUSH
53669: LD_INT 22
53671: PUSH
53672: LD_OWVAR 2
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: PUSH
53681: LD_INT 25
53683: PUSH
53684: LD_INT 1
53686: PUSH
53687: EMPTY
53688: LIST
53689: LIST
53690: PUSH
53691: EMPTY
53692: LIST
53693: LIST
53694: PPUSH
53695: CALL_OW 69
53699: ST_TO_ADDR
// if not tmp then
53700: LD_VAR 0 3
53704: NOT
53705: IFFALSE 53709
// exit ;
53707: GO 53765
// un := tmp [ rand ( 1 , tmp ) ] ;
53709: LD_ADDR_VAR 0 2
53713: PUSH
53714: LD_VAR 0 3
53718: PUSH
53719: LD_INT 1
53721: PPUSH
53722: LD_VAR 0 3
53726: PPUSH
53727: CALL_OW 12
53731: ARRAY
53732: ST_TO_ADDR
// if Crawls ( un ) then
53733: LD_VAR 0 2
53737: PPUSH
53738: CALL_OW 318
53742: IFFALSE 53753
// ComWalk ( un ) ;
53744: LD_VAR 0 2
53748: PPUSH
53749: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53753: LD_VAR 0 2
53757: PPUSH
53758: LD_INT 8
53760: PPUSH
53761: CALL_OW 336
// end ;
53765: PPOPN 3
53767: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53768: LD_EXP 91
53772: PUSH
53773: LD_EXP 135
53777: AND
53778: IFFALSE 53922
53780: GO 53782
53782: DISABLE
53783: LD_INT 0
53785: PPUSH
53786: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53787: LD_ADDR_VAR 0 2
53791: PUSH
53792: LD_INT 22
53794: PUSH
53795: LD_OWVAR 2
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: PUSH
53804: LD_INT 21
53806: PUSH
53807: LD_INT 2
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PUSH
53814: LD_INT 2
53816: PUSH
53817: LD_INT 34
53819: PUSH
53820: LD_INT 12
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PUSH
53827: LD_INT 34
53829: PUSH
53830: LD_INT 51
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: PUSH
53837: LD_INT 34
53839: PUSH
53840: LD_INT 32
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: PUSH
53847: EMPTY
53848: LIST
53849: LIST
53850: LIST
53851: LIST
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: LIST
53857: PPUSH
53858: CALL_OW 69
53862: ST_TO_ADDR
// if not tmp then
53863: LD_VAR 0 2
53867: NOT
53868: IFFALSE 53872
// exit ;
53870: GO 53922
// for i in tmp do
53872: LD_ADDR_VAR 0 1
53876: PUSH
53877: LD_VAR 0 2
53881: PUSH
53882: FOR_IN
53883: IFFALSE 53920
// if GetCargo ( i , mat_artifact ) = 0 then
53885: LD_VAR 0 1
53889: PPUSH
53890: LD_INT 4
53892: PPUSH
53893: CALL_OW 289
53897: PUSH
53898: LD_INT 0
53900: EQUAL
53901: IFFALSE 53918
// SetCargo ( i , mat_siberit , 100 ) ;
53903: LD_VAR 0 1
53907: PPUSH
53908: LD_INT 3
53910: PPUSH
53911: LD_INT 100
53913: PPUSH
53914: CALL_OW 290
53918: GO 53882
53920: POP
53921: POP
// end ;
53922: PPOPN 2
53924: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53925: LD_EXP 91
53929: PUSH
53930: LD_EXP 136
53934: AND
53935: IFFALSE 54118
53937: GO 53939
53939: DISABLE
53940: LD_INT 0
53942: PPUSH
53943: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53944: LD_ADDR_VAR 0 2
53948: PUSH
53949: LD_INT 22
53951: PUSH
53952: LD_OWVAR 2
53956: PUSH
53957: EMPTY
53958: LIST
53959: LIST
53960: PPUSH
53961: CALL_OW 69
53965: ST_TO_ADDR
// if not tmp then
53966: LD_VAR 0 2
53970: NOT
53971: IFFALSE 53975
// exit ;
53973: GO 54118
// for i := 1 to 2 do
53975: LD_ADDR_VAR 0 1
53979: PUSH
53980: DOUBLE
53981: LD_INT 1
53983: DEC
53984: ST_TO_ADDR
53985: LD_INT 2
53987: PUSH
53988: FOR_TO
53989: IFFALSE 54116
// begin uc_side := your_side ;
53991: LD_ADDR_OWVAR 20
53995: PUSH
53996: LD_OWVAR 2
54000: ST_TO_ADDR
// uc_nation := nation_american ;
54001: LD_ADDR_OWVAR 21
54005: PUSH
54006: LD_INT 1
54008: ST_TO_ADDR
// vc_chassis := us_morphling ;
54009: LD_ADDR_OWVAR 37
54013: PUSH
54014: LD_INT 5
54016: ST_TO_ADDR
// vc_engine := engine_siberite ;
54017: LD_ADDR_OWVAR 39
54021: PUSH
54022: LD_INT 3
54024: ST_TO_ADDR
// vc_control := control_computer ;
54025: LD_ADDR_OWVAR 38
54029: PUSH
54030: LD_INT 3
54032: ST_TO_ADDR
// vc_weapon := us_double_laser ;
54033: LD_ADDR_OWVAR 40
54037: PUSH
54038: LD_INT 10
54040: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
54041: LD_VAR 0 2
54045: PUSH
54046: LD_INT 1
54048: ARRAY
54049: PPUSH
54050: CALL_OW 310
54054: NOT
54055: IFFALSE 54102
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
54057: CALL_OW 45
54061: PPUSH
54062: LD_VAR 0 2
54066: PUSH
54067: LD_INT 1
54069: ARRAY
54070: PPUSH
54071: CALL_OW 250
54075: PPUSH
54076: LD_VAR 0 2
54080: PUSH
54081: LD_INT 1
54083: ARRAY
54084: PPUSH
54085: CALL_OW 251
54089: PPUSH
54090: LD_INT 12
54092: PPUSH
54093: LD_INT 1
54095: PPUSH
54096: CALL_OW 50
54100: GO 54114
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
54102: CALL_OW 45
54106: PPUSH
54107: LD_INT 1
54109: PPUSH
54110: CALL_OW 51
// end ;
54114: GO 53988
54116: POP
54117: POP
// end ;
54118: PPOPN 2
54120: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
54121: LD_EXP 91
54125: PUSH
54126: LD_EXP 137
54130: AND
54131: IFFALSE 54353
54133: GO 54135
54135: DISABLE
54136: LD_INT 0
54138: PPUSH
54139: PPUSH
54140: PPUSH
54141: PPUSH
54142: PPUSH
54143: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54144: LD_ADDR_VAR 0 6
54148: PUSH
54149: LD_INT 22
54151: PUSH
54152: LD_OWVAR 2
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: PUSH
54161: LD_INT 21
54163: PUSH
54164: LD_INT 1
54166: PUSH
54167: EMPTY
54168: LIST
54169: LIST
54170: PUSH
54171: LD_INT 3
54173: PUSH
54174: LD_INT 23
54176: PUSH
54177: LD_INT 0
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: PUSH
54184: EMPTY
54185: LIST
54186: LIST
54187: PUSH
54188: EMPTY
54189: LIST
54190: LIST
54191: LIST
54192: PPUSH
54193: CALL_OW 69
54197: ST_TO_ADDR
// if not tmp then
54198: LD_VAR 0 6
54202: NOT
54203: IFFALSE 54207
// exit ;
54205: GO 54353
// s1 := rand ( 1 , 4 ) ;
54207: LD_ADDR_VAR 0 2
54211: PUSH
54212: LD_INT 1
54214: PPUSH
54215: LD_INT 4
54217: PPUSH
54218: CALL_OW 12
54222: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54223: LD_ADDR_VAR 0 4
54227: PUSH
54228: LD_VAR 0 6
54232: PUSH
54233: LD_INT 1
54235: ARRAY
54236: PPUSH
54237: LD_VAR 0 2
54241: PPUSH
54242: CALL_OW 259
54246: ST_TO_ADDR
// if s1 = 1 then
54247: LD_VAR 0 2
54251: PUSH
54252: LD_INT 1
54254: EQUAL
54255: IFFALSE 54275
// s2 := rand ( 2 , 4 ) else
54257: LD_ADDR_VAR 0 3
54261: PUSH
54262: LD_INT 2
54264: PPUSH
54265: LD_INT 4
54267: PPUSH
54268: CALL_OW 12
54272: ST_TO_ADDR
54273: GO 54283
// s2 := 1 ;
54275: LD_ADDR_VAR 0 3
54279: PUSH
54280: LD_INT 1
54282: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54283: LD_ADDR_VAR 0 5
54287: PUSH
54288: LD_VAR 0 6
54292: PUSH
54293: LD_INT 1
54295: ARRAY
54296: PPUSH
54297: LD_VAR 0 3
54301: PPUSH
54302: CALL_OW 259
54306: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54307: LD_VAR 0 6
54311: PUSH
54312: LD_INT 1
54314: ARRAY
54315: PPUSH
54316: LD_VAR 0 2
54320: PPUSH
54321: LD_VAR 0 5
54325: PPUSH
54326: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54330: LD_VAR 0 6
54334: PUSH
54335: LD_INT 1
54337: ARRAY
54338: PPUSH
54339: LD_VAR 0 3
54343: PPUSH
54344: LD_VAR 0 4
54348: PPUSH
54349: CALL_OW 237
// end ;
54353: PPOPN 6
54355: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54356: LD_EXP 91
54360: PUSH
54361: LD_EXP 138
54365: AND
54366: IFFALSE 54445
54368: GO 54370
54370: DISABLE
54371: LD_INT 0
54373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54374: LD_ADDR_VAR 0 1
54378: PUSH
54379: LD_INT 22
54381: PUSH
54382: LD_OWVAR 2
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: PUSH
54391: LD_INT 30
54393: PUSH
54394: LD_INT 3
54396: PUSH
54397: EMPTY
54398: LIST
54399: LIST
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PPUSH
54405: CALL_OW 69
54409: ST_TO_ADDR
// if not tmp then
54410: LD_VAR 0 1
54414: NOT
54415: IFFALSE 54419
// exit ;
54417: GO 54445
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54419: LD_VAR 0 1
54423: PUSH
54424: LD_INT 1
54426: PPUSH
54427: LD_VAR 0 1
54431: PPUSH
54432: CALL_OW 12
54436: ARRAY
54437: PPUSH
54438: LD_INT 1
54440: PPUSH
54441: CALL_OW 234
// end ;
54445: PPOPN 1
54447: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54448: LD_EXP 91
54452: PUSH
54453: LD_EXP 139
54457: AND
54458: IFFALSE 54570
54460: GO 54462
54462: DISABLE
54463: LD_INT 0
54465: PPUSH
54466: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54467: LD_ADDR_VAR 0 2
54471: PUSH
54472: LD_INT 22
54474: PUSH
54475: LD_OWVAR 2
54479: PUSH
54480: EMPTY
54481: LIST
54482: LIST
54483: PUSH
54484: LD_INT 2
54486: PUSH
54487: LD_INT 30
54489: PUSH
54490: LD_INT 27
54492: PUSH
54493: EMPTY
54494: LIST
54495: LIST
54496: PUSH
54497: LD_INT 30
54499: PUSH
54500: LD_INT 26
54502: PUSH
54503: EMPTY
54504: LIST
54505: LIST
54506: PUSH
54507: LD_INT 30
54509: PUSH
54510: LD_INT 28
54512: PUSH
54513: EMPTY
54514: LIST
54515: LIST
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: LIST
54521: LIST
54522: PUSH
54523: EMPTY
54524: LIST
54525: LIST
54526: PPUSH
54527: CALL_OW 69
54531: ST_TO_ADDR
// if not tmp then
54532: LD_VAR 0 2
54536: NOT
54537: IFFALSE 54541
// exit ;
54539: GO 54570
// for i in tmp do
54541: LD_ADDR_VAR 0 1
54545: PUSH
54546: LD_VAR 0 2
54550: PUSH
54551: FOR_IN
54552: IFFALSE 54568
// SetLives ( i , 1 ) ;
54554: LD_VAR 0 1
54558: PPUSH
54559: LD_INT 1
54561: PPUSH
54562: CALL_OW 234
54566: GO 54551
54568: POP
54569: POP
// end ;
54570: PPOPN 2
54572: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54573: LD_EXP 91
54577: PUSH
54578: LD_EXP 140
54582: AND
54583: IFFALSE 54870
54585: GO 54587
54587: DISABLE
54588: LD_INT 0
54590: PPUSH
54591: PPUSH
54592: PPUSH
// begin i := rand ( 1 , 7 ) ;
54593: LD_ADDR_VAR 0 1
54597: PUSH
54598: LD_INT 1
54600: PPUSH
54601: LD_INT 7
54603: PPUSH
54604: CALL_OW 12
54608: ST_TO_ADDR
// case i of 1 :
54609: LD_VAR 0 1
54613: PUSH
54614: LD_INT 1
54616: DOUBLE
54617: EQUAL
54618: IFTRUE 54622
54620: GO 54632
54622: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54623: LD_STRING earthquake(getX(game), 0, 32)
54625: PPUSH
54626: CALL_OW 559
54630: GO 54870
54632: LD_INT 2
54634: DOUBLE
54635: EQUAL
54636: IFTRUE 54640
54638: GO 54654
54640: POP
// begin ToLua ( displayStucuk(); ) ;
54641: LD_STRING displayStucuk();
54643: PPUSH
54644: CALL_OW 559
// ResetFog ;
54648: CALL_OW 335
// end ; 3 :
54652: GO 54870
54654: LD_INT 3
54656: DOUBLE
54657: EQUAL
54658: IFTRUE 54662
54660: GO 54766
54662: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54663: LD_ADDR_VAR 0 2
54667: PUSH
54668: LD_INT 22
54670: PUSH
54671: LD_OWVAR 2
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: PUSH
54680: LD_INT 25
54682: PUSH
54683: LD_INT 1
54685: PUSH
54686: EMPTY
54687: LIST
54688: LIST
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: PPUSH
54694: CALL_OW 69
54698: ST_TO_ADDR
// if not tmp then
54699: LD_VAR 0 2
54703: NOT
54704: IFFALSE 54708
// exit ;
54706: GO 54870
// un := tmp [ rand ( 1 , tmp ) ] ;
54708: LD_ADDR_VAR 0 3
54712: PUSH
54713: LD_VAR 0 2
54717: PUSH
54718: LD_INT 1
54720: PPUSH
54721: LD_VAR 0 2
54725: PPUSH
54726: CALL_OW 12
54730: ARRAY
54731: ST_TO_ADDR
// if Crawls ( un ) then
54732: LD_VAR 0 3
54736: PPUSH
54737: CALL_OW 318
54741: IFFALSE 54752
// ComWalk ( un ) ;
54743: LD_VAR 0 3
54747: PPUSH
54748: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54752: LD_VAR 0 3
54756: PPUSH
54757: LD_INT 8
54759: PPUSH
54760: CALL_OW 336
// end ; 4 :
54764: GO 54870
54766: LD_INT 4
54768: DOUBLE
54769: EQUAL
54770: IFTRUE 54774
54772: GO 54848
54774: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54775: LD_ADDR_VAR 0 2
54779: PUSH
54780: LD_INT 22
54782: PUSH
54783: LD_OWVAR 2
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: PUSH
54792: LD_INT 30
54794: PUSH
54795: LD_INT 29
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: PUSH
54802: EMPTY
54803: LIST
54804: LIST
54805: PPUSH
54806: CALL_OW 69
54810: ST_TO_ADDR
// if not tmp then
54811: LD_VAR 0 2
54815: NOT
54816: IFFALSE 54820
// exit ;
54818: GO 54870
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54820: LD_VAR 0 2
54824: PUSH
54825: LD_INT 1
54827: ARRAY
54828: PPUSH
54829: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54833: LD_VAR 0 2
54837: PUSH
54838: LD_INT 1
54840: ARRAY
54841: PPUSH
54842: CALL_OW 65
// end ; 5 .. 7 :
54846: GO 54870
54848: LD_INT 5
54850: DOUBLE
54851: GREATEREQUAL
54852: IFFALSE 54860
54854: LD_INT 7
54856: DOUBLE
54857: LESSEQUAL
54858: IFTRUE 54862
54860: GO 54869
54862: POP
// StreamSibBomb ; end ;
54863: CALL 51107 0 0
54867: GO 54870
54869: POP
// end ;
54870: PPOPN 3
54872: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54873: LD_EXP 91
54877: PUSH
54878: LD_EXP 141
54882: AND
54883: IFFALSE 55039
54885: GO 54887
54887: DISABLE
54888: LD_INT 0
54890: PPUSH
54891: PPUSH
54892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54893: LD_ADDR_VAR 0 2
54897: PUSH
54898: LD_INT 81
54900: PUSH
54901: LD_OWVAR 2
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: PUSH
54910: LD_INT 2
54912: PUSH
54913: LD_INT 21
54915: PUSH
54916: LD_INT 1
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: PUSH
54923: LD_INT 21
54925: PUSH
54926: LD_INT 2
54928: PUSH
54929: EMPTY
54930: LIST
54931: LIST
54932: PUSH
54933: EMPTY
54934: LIST
54935: LIST
54936: LIST
54937: PUSH
54938: EMPTY
54939: LIST
54940: LIST
54941: PPUSH
54942: CALL_OW 69
54946: ST_TO_ADDR
// if not tmp then
54947: LD_VAR 0 2
54951: NOT
54952: IFFALSE 54956
// exit ;
54954: GO 55039
// p := 0 ;
54956: LD_ADDR_VAR 0 3
54960: PUSH
54961: LD_INT 0
54963: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54964: LD_INT 35
54966: PPUSH
54967: CALL_OW 67
// p := p + 1 ;
54971: LD_ADDR_VAR 0 3
54975: PUSH
54976: LD_VAR 0 3
54980: PUSH
54981: LD_INT 1
54983: PLUS
54984: ST_TO_ADDR
// for i in tmp do
54985: LD_ADDR_VAR 0 1
54989: PUSH
54990: LD_VAR 0 2
54994: PUSH
54995: FOR_IN
54996: IFFALSE 55027
// if GetLives ( i ) < 1000 then
54998: LD_VAR 0 1
55002: PPUSH
55003: CALL_OW 256
55007: PUSH
55008: LD_INT 1000
55010: LESS
55011: IFFALSE 55025
// SetLives ( i , 1000 ) ;
55013: LD_VAR 0 1
55017: PPUSH
55018: LD_INT 1000
55020: PPUSH
55021: CALL_OW 234
55025: GO 54995
55027: POP
55028: POP
// until p > 20 ;
55029: LD_VAR 0 3
55033: PUSH
55034: LD_INT 20
55036: GREATER
55037: IFFALSE 54964
// end ;
55039: PPOPN 3
55041: END
// every 0 0$1 trigger StreamModeActive and sTime do
55042: LD_EXP 91
55046: PUSH
55047: LD_EXP 142
55051: AND
55052: IFFALSE 55087
55054: GO 55056
55056: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
55057: LD_INT 28
55059: PPUSH
55060: LD_OWVAR 2
55064: PPUSH
55065: LD_INT 2
55067: PPUSH
55068: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
55072: LD_INT 30
55074: PPUSH
55075: LD_OWVAR 2
55079: PPUSH
55080: LD_INT 2
55082: PPUSH
55083: CALL_OW 322
// end ;
55087: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
55088: LD_EXP 91
55092: PUSH
55093: LD_EXP 143
55097: AND
55098: IFFALSE 55219
55100: GO 55102
55102: DISABLE
55103: LD_INT 0
55105: PPUSH
55106: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
55107: LD_ADDR_VAR 0 2
55111: PUSH
55112: LD_INT 22
55114: PUSH
55115: LD_OWVAR 2
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: PUSH
55124: LD_INT 21
55126: PUSH
55127: LD_INT 1
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: PUSH
55134: LD_INT 3
55136: PUSH
55137: LD_INT 23
55139: PUSH
55140: LD_INT 0
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: PUSH
55151: EMPTY
55152: LIST
55153: LIST
55154: LIST
55155: PPUSH
55156: CALL_OW 69
55160: ST_TO_ADDR
// if not tmp then
55161: LD_VAR 0 2
55165: NOT
55166: IFFALSE 55170
// exit ;
55168: GO 55219
// for i in tmp do
55170: LD_ADDR_VAR 0 1
55174: PUSH
55175: LD_VAR 0 2
55179: PUSH
55180: FOR_IN
55181: IFFALSE 55217
// begin if Crawls ( i ) then
55183: LD_VAR 0 1
55187: PPUSH
55188: CALL_OW 318
55192: IFFALSE 55203
// ComWalk ( i ) ;
55194: LD_VAR 0 1
55198: PPUSH
55199: CALL_OW 138
// SetClass ( i , 2 ) ;
55203: LD_VAR 0 1
55207: PPUSH
55208: LD_INT 2
55210: PPUSH
55211: CALL_OW 336
// end ;
55215: GO 55180
55217: POP
55218: POP
// end ;
55219: PPOPN 2
55221: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55222: LD_EXP 91
55226: PUSH
55227: LD_EXP 144
55231: AND
55232: IFFALSE 55520
55234: GO 55236
55236: DISABLE
55237: LD_INT 0
55239: PPUSH
55240: PPUSH
55241: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55242: LD_OWVAR 2
55246: PPUSH
55247: LD_INT 9
55249: PPUSH
55250: LD_INT 1
55252: PPUSH
55253: LD_INT 1
55255: PPUSH
55256: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55260: LD_INT 9
55262: PPUSH
55263: LD_OWVAR 2
55267: PPUSH
55268: CALL_OW 343
// uc_side := 9 ;
55272: LD_ADDR_OWVAR 20
55276: PUSH
55277: LD_INT 9
55279: ST_TO_ADDR
// uc_nation := 2 ;
55280: LD_ADDR_OWVAR 21
55284: PUSH
55285: LD_INT 2
55287: ST_TO_ADDR
// hc_name := Dark Warrior ;
55288: LD_ADDR_OWVAR 26
55292: PUSH
55293: LD_STRING Dark Warrior
55295: ST_TO_ADDR
// hc_gallery :=  ;
55296: LD_ADDR_OWVAR 33
55300: PUSH
55301: LD_STRING 
55303: ST_TO_ADDR
// hc_noskilllimit := true ;
55304: LD_ADDR_OWVAR 76
55308: PUSH
55309: LD_INT 1
55311: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55312: LD_ADDR_OWVAR 31
55316: PUSH
55317: LD_INT 30
55319: PUSH
55320: LD_INT 30
55322: PUSH
55323: LD_INT 30
55325: PUSH
55326: LD_INT 30
55328: PUSH
55329: EMPTY
55330: LIST
55331: LIST
55332: LIST
55333: LIST
55334: ST_TO_ADDR
// un := CreateHuman ;
55335: LD_ADDR_VAR 0 3
55339: PUSH
55340: CALL_OW 44
55344: ST_TO_ADDR
// hc_noskilllimit := false ;
55345: LD_ADDR_OWVAR 76
55349: PUSH
55350: LD_INT 0
55352: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55353: LD_VAR 0 3
55357: PPUSH
55358: LD_INT 1
55360: PPUSH
55361: CALL_OW 51
// ToLua ( playRanger() ) ;
55365: LD_STRING playRanger()
55367: PPUSH
55368: CALL_OW 559
// p := 0 ;
55372: LD_ADDR_VAR 0 2
55376: PUSH
55377: LD_INT 0
55379: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55380: LD_INT 35
55382: PPUSH
55383: CALL_OW 67
// p := p + 1 ;
55387: LD_ADDR_VAR 0 2
55391: PUSH
55392: LD_VAR 0 2
55396: PUSH
55397: LD_INT 1
55399: PLUS
55400: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55401: LD_VAR 0 3
55405: PPUSH
55406: CALL_OW 256
55410: PUSH
55411: LD_INT 1000
55413: LESS
55414: IFFALSE 55428
// SetLives ( un , 1000 ) ;
55416: LD_VAR 0 3
55420: PPUSH
55421: LD_INT 1000
55423: PPUSH
55424: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55428: LD_VAR 0 3
55432: PPUSH
55433: LD_INT 81
55435: PUSH
55436: LD_OWVAR 2
55440: PUSH
55441: EMPTY
55442: LIST
55443: LIST
55444: PUSH
55445: LD_INT 91
55447: PUSH
55448: LD_VAR 0 3
55452: PUSH
55453: LD_INT 30
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: LIST
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: PPUSH
55465: CALL_OW 69
55469: PPUSH
55470: LD_VAR 0 3
55474: PPUSH
55475: CALL_OW 74
55479: PPUSH
55480: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55484: LD_VAR 0 2
55488: PUSH
55489: LD_INT 80
55491: GREATER
55492: PUSH
55493: LD_VAR 0 3
55497: PPUSH
55498: CALL_OW 301
55502: OR
55503: IFFALSE 55380
// if un then
55505: LD_VAR 0 3
55509: IFFALSE 55520
// RemoveUnit ( un ) ;
55511: LD_VAR 0 3
55515: PPUSH
55516: CALL_OW 64
// end ;
55520: PPOPN 3
55522: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55523: LD_EXP 145
55527: IFFALSE 55643
55529: GO 55531
55531: DISABLE
55532: LD_INT 0
55534: PPUSH
55535: PPUSH
55536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55537: LD_ADDR_VAR 0 2
55541: PUSH
55542: LD_INT 81
55544: PUSH
55545: LD_OWVAR 2
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: PUSH
55554: LD_INT 21
55556: PUSH
55557: LD_INT 1
55559: PUSH
55560: EMPTY
55561: LIST
55562: LIST
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: PPUSH
55568: CALL_OW 69
55572: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55573: LD_STRING playComputer()
55575: PPUSH
55576: CALL_OW 559
// if not tmp then
55580: LD_VAR 0 2
55584: NOT
55585: IFFALSE 55589
// exit ;
55587: GO 55643
// for i in tmp do
55589: LD_ADDR_VAR 0 1
55593: PUSH
55594: LD_VAR 0 2
55598: PUSH
55599: FOR_IN
55600: IFFALSE 55641
// for j := 1 to 4 do
55602: LD_ADDR_VAR 0 3
55606: PUSH
55607: DOUBLE
55608: LD_INT 1
55610: DEC
55611: ST_TO_ADDR
55612: LD_INT 4
55614: PUSH
55615: FOR_TO
55616: IFFALSE 55637
// SetSkill ( i , j , 10 ) ;
55618: LD_VAR 0 1
55622: PPUSH
55623: LD_VAR 0 3
55627: PPUSH
55628: LD_INT 10
55630: PPUSH
55631: CALL_OW 237
55635: GO 55615
55637: POP
55638: POP
55639: GO 55599
55641: POP
55642: POP
// end ;
55643: PPOPN 3
55645: END
// every 0 0$1 trigger s30 do var i , tmp ;
55646: LD_EXP 146
55650: IFFALSE 55719
55652: GO 55654
55654: DISABLE
55655: LD_INT 0
55657: PPUSH
55658: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55659: LD_ADDR_VAR 0 2
55663: PUSH
55664: LD_INT 22
55666: PUSH
55667: LD_OWVAR 2
55671: PUSH
55672: EMPTY
55673: LIST
55674: LIST
55675: PPUSH
55676: CALL_OW 69
55680: ST_TO_ADDR
// if not tmp then
55681: LD_VAR 0 2
55685: NOT
55686: IFFALSE 55690
// exit ;
55688: GO 55719
// for i in tmp do
55690: LD_ADDR_VAR 0 1
55694: PUSH
55695: LD_VAR 0 2
55699: PUSH
55700: FOR_IN
55701: IFFALSE 55717
// SetLives ( i , 300 ) ;
55703: LD_VAR 0 1
55707: PPUSH
55708: LD_INT 300
55710: PPUSH
55711: CALL_OW 234
55715: GO 55700
55717: POP
55718: POP
// end ;
55719: PPOPN 2
55721: END
// every 0 0$1 trigger s60 do var i , tmp ;
55722: LD_EXP 147
55726: IFFALSE 55795
55728: GO 55730
55730: DISABLE
55731: LD_INT 0
55733: PPUSH
55734: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55735: LD_ADDR_VAR 0 2
55739: PUSH
55740: LD_INT 22
55742: PUSH
55743: LD_OWVAR 2
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: PPUSH
55752: CALL_OW 69
55756: ST_TO_ADDR
// if not tmp then
55757: LD_VAR 0 2
55761: NOT
55762: IFFALSE 55766
// exit ;
55764: GO 55795
// for i in tmp do
55766: LD_ADDR_VAR 0 1
55770: PUSH
55771: LD_VAR 0 2
55775: PUSH
55776: FOR_IN
55777: IFFALSE 55793
// SetLives ( i , 600 ) ;
55779: LD_VAR 0 1
55783: PPUSH
55784: LD_INT 600
55786: PPUSH
55787: CALL_OW 234
55791: GO 55776
55793: POP
55794: POP
// end ;
55795: PPOPN 2
55797: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55798: LD_INT 0
55800: PPUSH
// case cmd of 301 :
55801: LD_VAR 0 1
55805: PUSH
55806: LD_INT 301
55808: DOUBLE
55809: EQUAL
55810: IFTRUE 55814
55812: GO 55846
55814: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55815: LD_VAR 0 6
55819: PPUSH
55820: LD_VAR 0 7
55824: PPUSH
55825: LD_VAR 0 8
55829: PPUSH
55830: LD_VAR 0 4
55834: PPUSH
55835: LD_VAR 0 5
55839: PPUSH
55840: CALL 57047 0 5
55844: GO 55967
55846: LD_INT 302
55848: DOUBLE
55849: EQUAL
55850: IFTRUE 55854
55852: GO 55891
55854: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55855: LD_VAR 0 6
55859: PPUSH
55860: LD_VAR 0 7
55864: PPUSH
55865: LD_VAR 0 8
55869: PPUSH
55870: LD_VAR 0 9
55874: PPUSH
55875: LD_VAR 0 4
55879: PPUSH
55880: LD_VAR 0 5
55884: PPUSH
55885: CALL 57138 0 6
55889: GO 55967
55891: LD_INT 303
55893: DOUBLE
55894: EQUAL
55895: IFTRUE 55899
55897: GO 55936
55899: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55900: LD_VAR 0 6
55904: PPUSH
55905: LD_VAR 0 7
55909: PPUSH
55910: LD_VAR 0 8
55914: PPUSH
55915: LD_VAR 0 9
55919: PPUSH
55920: LD_VAR 0 4
55924: PPUSH
55925: LD_VAR 0 5
55929: PPUSH
55930: CALL 55972 0 6
55934: GO 55967
55936: LD_INT 304
55938: DOUBLE
55939: EQUAL
55940: IFTRUE 55944
55942: GO 55966
55944: POP
// hHackTeleport ( unit , x , y ) ; end ;
55945: LD_VAR 0 2
55949: PPUSH
55950: LD_VAR 0 4
55954: PPUSH
55955: LD_VAR 0 5
55959: PPUSH
55960: CALL 57731 0 3
55964: GO 55967
55966: POP
// end ;
55967: LD_VAR 0 12
55971: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55972: LD_INT 0
55974: PPUSH
55975: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55976: LD_VAR 0 1
55980: PUSH
55981: LD_INT 1
55983: LESS
55984: PUSH
55985: LD_VAR 0 1
55989: PUSH
55990: LD_INT 3
55992: GREATER
55993: OR
55994: PUSH
55995: LD_VAR 0 5
55999: PPUSH
56000: LD_VAR 0 6
56004: PPUSH
56005: CALL_OW 428
56009: OR
56010: IFFALSE 56014
// exit ;
56012: GO 56734
// uc_side := your_side ;
56014: LD_ADDR_OWVAR 20
56018: PUSH
56019: LD_OWVAR 2
56023: ST_TO_ADDR
// uc_nation := nation ;
56024: LD_ADDR_OWVAR 21
56028: PUSH
56029: LD_VAR 0 1
56033: ST_TO_ADDR
// bc_level = 1 ;
56034: LD_ADDR_OWVAR 43
56038: PUSH
56039: LD_INT 1
56041: ST_TO_ADDR
// case btype of 1 :
56042: LD_VAR 0 2
56046: PUSH
56047: LD_INT 1
56049: DOUBLE
56050: EQUAL
56051: IFTRUE 56055
56053: GO 56066
56055: POP
// bc_type := b_depot ; 2 :
56056: LD_ADDR_OWVAR 42
56060: PUSH
56061: LD_INT 0
56063: ST_TO_ADDR
56064: GO 56678
56066: LD_INT 2
56068: DOUBLE
56069: EQUAL
56070: IFTRUE 56074
56072: GO 56085
56074: POP
// bc_type := b_warehouse ; 3 :
56075: LD_ADDR_OWVAR 42
56079: PUSH
56080: LD_INT 1
56082: ST_TO_ADDR
56083: GO 56678
56085: LD_INT 3
56087: DOUBLE
56088: EQUAL
56089: IFTRUE 56093
56091: GO 56104
56093: POP
// bc_type := b_lab ; 4 .. 9 :
56094: LD_ADDR_OWVAR 42
56098: PUSH
56099: LD_INT 6
56101: ST_TO_ADDR
56102: GO 56678
56104: LD_INT 4
56106: DOUBLE
56107: GREATEREQUAL
56108: IFFALSE 56116
56110: LD_INT 9
56112: DOUBLE
56113: LESSEQUAL
56114: IFTRUE 56118
56116: GO 56170
56118: POP
// begin bc_type := b_lab_half ;
56119: LD_ADDR_OWVAR 42
56123: PUSH
56124: LD_INT 7
56126: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
56127: LD_ADDR_OWVAR 44
56131: PUSH
56132: LD_INT 10
56134: PUSH
56135: LD_INT 11
56137: PUSH
56138: LD_INT 12
56140: PUSH
56141: LD_INT 15
56143: PUSH
56144: LD_INT 14
56146: PUSH
56147: LD_INT 13
56149: PUSH
56150: EMPTY
56151: LIST
56152: LIST
56153: LIST
56154: LIST
56155: LIST
56156: LIST
56157: PUSH
56158: LD_VAR 0 2
56162: PUSH
56163: LD_INT 3
56165: MINUS
56166: ARRAY
56167: ST_TO_ADDR
// end ; 10 .. 13 :
56168: GO 56678
56170: LD_INT 10
56172: DOUBLE
56173: GREATEREQUAL
56174: IFFALSE 56182
56176: LD_INT 13
56178: DOUBLE
56179: LESSEQUAL
56180: IFTRUE 56184
56182: GO 56261
56184: POP
// begin bc_type := b_lab_full ;
56185: LD_ADDR_OWVAR 42
56189: PUSH
56190: LD_INT 8
56192: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56193: LD_ADDR_OWVAR 44
56197: PUSH
56198: LD_INT 10
56200: PUSH
56201: LD_INT 12
56203: PUSH
56204: LD_INT 14
56206: PUSH
56207: LD_INT 13
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: LIST
56214: LIST
56215: PUSH
56216: LD_VAR 0 2
56220: PUSH
56221: LD_INT 9
56223: MINUS
56224: ARRAY
56225: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56226: LD_ADDR_OWVAR 45
56230: PUSH
56231: LD_INT 11
56233: PUSH
56234: LD_INT 15
56236: PUSH
56237: LD_INT 12
56239: PUSH
56240: LD_INT 15
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: LIST
56247: LIST
56248: PUSH
56249: LD_VAR 0 2
56253: PUSH
56254: LD_INT 9
56256: MINUS
56257: ARRAY
56258: ST_TO_ADDR
// end ; 14 :
56259: GO 56678
56261: LD_INT 14
56263: DOUBLE
56264: EQUAL
56265: IFTRUE 56269
56267: GO 56280
56269: POP
// bc_type := b_workshop ; 15 :
56270: LD_ADDR_OWVAR 42
56274: PUSH
56275: LD_INT 2
56277: ST_TO_ADDR
56278: GO 56678
56280: LD_INT 15
56282: DOUBLE
56283: EQUAL
56284: IFTRUE 56288
56286: GO 56299
56288: POP
// bc_type := b_factory ; 16 :
56289: LD_ADDR_OWVAR 42
56293: PUSH
56294: LD_INT 3
56296: ST_TO_ADDR
56297: GO 56678
56299: LD_INT 16
56301: DOUBLE
56302: EQUAL
56303: IFTRUE 56307
56305: GO 56318
56307: POP
// bc_type := b_ext_gun ; 17 :
56308: LD_ADDR_OWVAR 42
56312: PUSH
56313: LD_INT 17
56315: ST_TO_ADDR
56316: GO 56678
56318: LD_INT 17
56320: DOUBLE
56321: EQUAL
56322: IFTRUE 56326
56324: GO 56354
56326: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56327: LD_ADDR_OWVAR 42
56331: PUSH
56332: LD_INT 19
56334: PUSH
56335: LD_INT 23
56337: PUSH
56338: LD_INT 19
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: LIST
56345: PUSH
56346: LD_VAR 0 1
56350: ARRAY
56351: ST_TO_ADDR
56352: GO 56678
56354: LD_INT 18
56356: DOUBLE
56357: EQUAL
56358: IFTRUE 56362
56360: GO 56373
56362: POP
// bc_type := b_ext_radar ; 19 :
56363: LD_ADDR_OWVAR 42
56367: PUSH
56368: LD_INT 20
56370: ST_TO_ADDR
56371: GO 56678
56373: LD_INT 19
56375: DOUBLE
56376: EQUAL
56377: IFTRUE 56381
56379: GO 56392
56381: POP
// bc_type := b_ext_radio ; 20 :
56382: LD_ADDR_OWVAR 42
56386: PUSH
56387: LD_INT 22
56389: ST_TO_ADDR
56390: GO 56678
56392: LD_INT 20
56394: DOUBLE
56395: EQUAL
56396: IFTRUE 56400
56398: GO 56411
56400: POP
// bc_type := b_ext_siberium ; 21 :
56401: LD_ADDR_OWVAR 42
56405: PUSH
56406: LD_INT 21
56408: ST_TO_ADDR
56409: GO 56678
56411: LD_INT 21
56413: DOUBLE
56414: EQUAL
56415: IFTRUE 56419
56417: GO 56430
56419: POP
// bc_type := b_ext_computer ; 22 :
56420: LD_ADDR_OWVAR 42
56424: PUSH
56425: LD_INT 24
56427: ST_TO_ADDR
56428: GO 56678
56430: LD_INT 22
56432: DOUBLE
56433: EQUAL
56434: IFTRUE 56438
56436: GO 56449
56438: POP
// bc_type := b_ext_track ; 23 :
56439: LD_ADDR_OWVAR 42
56443: PUSH
56444: LD_INT 16
56446: ST_TO_ADDR
56447: GO 56678
56449: LD_INT 23
56451: DOUBLE
56452: EQUAL
56453: IFTRUE 56457
56455: GO 56468
56457: POP
// bc_type := b_ext_laser ; 24 :
56458: LD_ADDR_OWVAR 42
56462: PUSH
56463: LD_INT 25
56465: ST_TO_ADDR
56466: GO 56678
56468: LD_INT 24
56470: DOUBLE
56471: EQUAL
56472: IFTRUE 56476
56474: GO 56487
56476: POP
// bc_type := b_control_tower ; 25 :
56477: LD_ADDR_OWVAR 42
56481: PUSH
56482: LD_INT 36
56484: ST_TO_ADDR
56485: GO 56678
56487: LD_INT 25
56489: DOUBLE
56490: EQUAL
56491: IFTRUE 56495
56493: GO 56506
56495: POP
// bc_type := b_breastwork ; 26 :
56496: LD_ADDR_OWVAR 42
56500: PUSH
56501: LD_INT 31
56503: ST_TO_ADDR
56504: GO 56678
56506: LD_INT 26
56508: DOUBLE
56509: EQUAL
56510: IFTRUE 56514
56512: GO 56525
56514: POP
// bc_type := b_bunker ; 27 :
56515: LD_ADDR_OWVAR 42
56519: PUSH
56520: LD_INT 32
56522: ST_TO_ADDR
56523: GO 56678
56525: LD_INT 27
56527: DOUBLE
56528: EQUAL
56529: IFTRUE 56533
56531: GO 56544
56533: POP
// bc_type := b_turret ; 28 :
56534: LD_ADDR_OWVAR 42
56538: PUSH
56539: LD_INT 33
56541: ST_TO_ADDR
56542: GO 56678
56544: LD_INT 28
56546: DOUBLE
56547: EQUAL
56548: IFTRUE 56552
56550: GO 56563
56552: POP
// bc_type := b_armoury ; 29 :
56553: LD_ADDR_OWVAR 42
56557: PUSH
56558: LD_INT 4
56560: ST_TO_ADDR
56561: GO 56678
56563: LD_INT 29
56565: DOUBLE
56566: EQUAL
56567: IFTRUE 56571
56569: GO 56582
56571: POP
// bc_type := b_barracks ; 30 :
56572: LD_ADDR_OWVAR 42
56576: PUSH
56577: LD_INT 5
56579: ST_TO_ADDR
56580: GO 56678
56582: LD_INT 30
56584: DOUBLE
56585: EQUAL
56586: IFTRUE 56590
56588: GO 56601
56590: POP
// bc_type := b_solar_power ; 31 :
56591: LD_ADDR_OWVAR 42
56595: PUSH
56596: LD_INT 27
56598: ST_TO_ADDR
56599: GO 56678
56601: LD_INT 31
56603: DOUBLE
56604: EQUAL
56605: IFTRUE 56609
56607: GO 56620
56609: POP
// bc_type := b_oil_power ; 32 :
56610: LD_ADDR_OWVAR 42
56614: PUSH
56615: LD_INT 26
56617: ST_TO_ADDR
56618: GO 56678
56620: LD_INT 32
56622: DOUBLE
56623: EQUAL
56624: IFTRUE 56628
56626: GO 56639
56628: POP
// bc_type := b_siberite_power ; 33 :
56629: LD_ADDR_OWVAR 42
56633: PUSH
56634: LD_INT 28
56636: ST_TO_ADDR
56637: GO 56678
56639: LD_INT 33
56641: DOUBLE
56642: EQUAL
56643: IFTRUE 56647
56645: GO 56658
56647: POP
// bc_type := b_oil_mine ; 34 :
56648: LD_ADDR_OWVAR 42
56652: PUSH
56653: LD_INT 29
56655: ST_TO_ADDR
56656: GO 56678
56658: LD_INT 34
56660: DOUBLE
56661: EQUAL
56662: IFTRUE 56666
56664: GO 56677
56666: POP
// bc_type := b_siberite_mine ; end ;
56667: LD_ADDR_OWVAR 42
56671: PUSH
56672: LD_INT 30
56674: ST_TO_ADDR
56675: GO 56678
56677: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56678: LD_ADDR_VAR 0 8
56682: PUSH
56683: LD_VAR 0 5
56687: PPUSH
56688: LD_VAR 0 6
56692: PPUSH
56693: LD_VAR 0 3
56697: PPUSH
56698: CALL_OW 47
56702: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56703: LD_OWVAR 42
56707: PUSH
56708: LD_INT 32
56710: PUSH
56711: LD_INT 33
56713: PUSH
56714: EMPTY
56715: LIST
56716: LIST
56717: IN
56718: IFFALSE 56734
// PlaceWeaponTurret ( b , weapon ) ;
56720: LD_VAR 0 8
56724: PPUSH
56725: LD_VAR 0 4
56729: PPUSH
56730: CALL_OW 431
// end ;
56734: LD_VAR 0 7
56738: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56739: LD_INT 0
56741: PPUSH
56742: PPUSH
56743: PPUSH
56744: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56745: LD_ADDR_VAR 0 4
56749: PUSH
56750: LD_INT 22
56752: PUSH
56753: LD_OWVAR 2
56757: PUSH
56758: EMPTY
56759: LIST
56760: LIST
56761: PUSH
56762: LD_INT 2
56764: PUSH
56765: LD_INT 30
56767: PUSH
56768: LD_INT 0
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: PUSH
56775: LD_INT 30
56777: PUSH
56778: LD_INT 1
56780: PUSH
56781: EMPTY
56782: LIST
56783: LIST
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: LIST
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PPUSH
56794: CALL_OW 69
56798: ST_TO_ADDR
// if not tmp then
56799: LD_VAR 0 4
56803: NOT
56804: IFFALSE 56808
// exit ;
56806: GO 56867
// for i in tmp do
56808: LD_ADDR_VAR 0 2
56812: PUSH
56813: LD_VAR 0 4
56817: PUSH
56818: FOR_IN
56819: IFFALSE 56865
// for j = 1 to 3 do
56821: LD_ADDR_VAR 0 3
56825: PUSH
56826: DOUBLE
56827: LD_INT 1
56829: DEC
56830: ST_TO_ADDR
56831: LD_INT 3
56833: PUSH
56834: FOR_TO
56835: IFFALSE 56861
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56837: LD_VAR 0 2
56841: PPUSH
56842: CALL_OW 274
56846: PPUSH
56847: LD_VAR 0 3
56851: PPUSH
56852: LD_INT 99999
56854: PPUSH
56855: CALL_OW 277
56859: GO 56834
56861: POP
56862: POP
56863: GO 56818
56865: POP
56866: POP
// end ;
56867: LD_VAR 0 1
56871: RET
// export function hHackSetLevel10 ; var i , j ; begin
56872: LD_INT 0
56874: PPUSH
56875: PPUSH
56876: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56877: LD_ADDR_VAR 0 2
56881: PUSH
56882: LD_INT 21
56884: PUSH
56885: LD_INT 1
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: PPUSH
56892: CALL_OW 69
56896: PUSH
56897: FOR_IN
56898: IFFALSE 56950
// if IsSelected ( i ) then
56900: LD_VAR 0 2
56904: PPUSH
56905: CALL_OW 306
56909: IFFALSE 56948
// begin for j := 1 to 4 do
56911: LD_ADDR_VAR 0 3
56915: PUSH
56916: DOUBLE
56917: LD_INT 1
56919: DEC
56920: ST_TO_ADDR
56921: LD_INT 4
56923: PUSH
56924: FOR_TO
56925: IFFALSE 56946
// SetSkill ( i , j , 10 ) ;
56927: LD_VAR 0 2
56931: PPUSH
56932: LD_VAR 0 3
56936: PPUSH
56937: LD_INT 10
56939: PPUSH
56940: CALL_OW 237
56944: GO 56924
56946: POP
56947: POP
// end ;
56948: GO 56897
56950: POP
56951: POP
// end ;
56952: LD_VAR 0 1
56956: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56957: LD_INT 0
56959: PPUSH
56960: PPUSH
56961: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56962: LD_ADDR_VAR 0 2
56966: PUSH
56967: LD_INT 22
56969: PUSH
56970: LD_OWVAR 2
56974: PUSH
56975: EMPTY
56976: LIST
56977: LIST
56978: PUSH
56979: LD_INT 21
56981: PUSH
56982: LD_INT 1
56984: PUSH
56985: EMPTY
56986: LIST
56987: LIST
56988: PUSH
56989: EMPTY
56990: LIST
56991: LIST
56992: PPUSH
56993: CALL_OW 69
56997: PUSH
56998: FOR_IN
56999: IFFALSE 57040
// begin for j := 1 to 4 do
57001: LD_ADDR_VAR 0 3
57005: PUSH
57006: DOUBLE
57007: LD_INT 1
57009: DEC
57010: ST_TO_ADDR
57011: LD_INT 4
57013: PUSH
57014: FOR_TO
57015: IFFALSE 57036
// SetSkill ( i , j , 10 ) ;
57017: LD_VAR 0 2
57021: PPUSH
57022: LD_VAR 0 3
57026: PPUSH
57027: LD_INT 10
57029: PPUSH
57030: CALL_OW 237
57034: GO 57014
57036: POP
57037: POP
// end ;
57038: GO 56998
57040: POP
57041: POP
// end ;
57042: LD_VAR 0 1
57046: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
57047: LD_INT 0
57049: PPUSH
// uc_side := your_side ;
57050: LD_ADDR_OWVAR 20
57054: PUSH
57055: LD_OWVAR 2
57059: ST_TO_ADDR
// uc_nation := nation ;
57060: LD_ADDR_OWVAR 21
57064: PUSH
57065: LD_VAR 0 1
57069: ST_TO_ADDR
// InitHc ;
57070: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
57074: LD_INT 0
57076: PPUSH
57077: LD_VAR 0 2
57081: PPUSH
57082: LD_VAR 0 3
57086: PPUSH
57087: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
57091: LD_VAR 0 4
57095: PPUSH
57096: LD_VAR 0 5
57100: PPUSH
57101: CALL_OW 428
57105: PUSH
57106: LD_INT 0
57108: EQUAL
57109: IFFALSE 57133
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
57111: CALL_OW 44
57115: PPUSH
57116: LD_VAR 0 4
57120: PPUSH
57121: LD_VAR 0 5
57125: PPUSH
57126: LD_INT 1
57128: PPUSH
57129: CALL_OW 48
// end ;
57133: LD_VAR 0 6
57137: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
57138: LD_INT 0
57140: PPUSH
57141: PPUSH
// uc_side := your_side ;
57142: LD_ADDR_OWVAR 20
57146: PUSH
57147: LD_OWVAR 2
57151: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
57152: LD_VAR 0 1
57156: PUSH
57157: LD_INT 1
57159: PUSH
57160: LD_INT 2
57162: PUSH
57163: LD_INT 3
57165: PUSH
57166: LD_INT 4
57168: PUSH
57169: LD_INT 5
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: LIST
57176: LIST
57177: LIST
57178: IN
57179: IFFALSE 57191
// uc_nation := nation_american else
57181: LD_ADDR_OWVAR 21
57185: PUSH
57186: LD_INT 1
57188: ST_TO_ADDR
57189: GO 57234
// if chassis in [ 11 , 12 , 13 , 14 ] then
57191: LD_VAR 0 1
57195: PUSH
57196: LD_INT 11
57198: PUSH
57199: LD_INT 12
57201: PUSH
57202: LD_INT 13
57204: PUSH
57205: LD_INT 14
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: LIST
57212: LIST
57213: IN
57214: IFFALSE 57226
// uc_nation := nation_arabian else
57216: LD_ADDR_OWVAR 21
57220: PUSH
57221: LD_INT 2
57223: ST_TO_ADDR
57224: GO 57234
// uc_nation := nation_russian ;
57226: LD_ADDR_OWVAR 21
57230: PUSH
57231: LD_INT 3
57233: ST_TO_ADDR
// vc_chassis := chassis ;
57234: LD_ADDR_OWVAR 37
57238: PUSH
57239: LD_VAR 0 1
57243: ST_TO_ADDR
// vc_engine := engine ;
57244: LD_ADDR_OWVAR 39
57248: PUSH
57249: LD_VAR 0 2
57253: ST_TO_ADDR
// vc_control := control ;
57254: LD_ADDR_OWVAR 38
57258: PUSH
57259: LD_VAR 0 3
57263: ST_TO_ADDR
// vc_weapon := weapon ;
57264: LD_ADDR_OWVAR 40
57268: PUSH
57269: LD_VAR 0 4
57273: ST_TO_ADDR
// un := CreateVehicle ;
57274: LD_ADDR_VAR 0 8
57278: PUSH
57279: CALL_OW 45
57283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57284: LD_VAR 0 8
57288: PPUSH
57289: LD_INT 0
57291: PPUSH
57292: LD_INT 5
57294: PPUSH
57295: CALL_OW 12
57299: PPUSH
57300: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57304: LD_VAR 0 8
57308: PPUSH
57309: LD_VAR 0 5
57313: PPUSH
57314: LD_VAR 0 6
57318: PPUSH
57319: LD_INT 1
57321: PPUSH
57322: CALL_OW 48
// end ;
57326: LD_VAR 0 7
57330: RET
// export hInvincible ; every 1 do
57331: GO 57333
57333: DISABLE
// hInvincible := [ ] ;
57334: LD_ADDR_EXP 148
57338: PUSH
57339: EMPTY
57340: ST_TO_ADDR
57341: END
// every 10 do var i ;
57342: GO 57344
57344: DISABLE
57345: LD_INT 0
57347: PPUSH
// begin enable ;
57348: ENABLE
// if not hInvincible then
57349: LD_EXP 148
57353: NOT
57354: IFFALSE 57358
// exit ;
57356: GO 57402
// for i in hInvincible do
57358: LD_ADDR_VAR 0 1
57362: PUSH
57363: LD_EXP 148
57367: PUSH
57368: FOR_IN
57369: IFFALSE 57400
// if GetLives ( i ) < 1000 then
57371: LD_VAR 0 1
57375: PPUSH
57376: CALL_OW 256
57380: PUSH
57381: LD_INT 1000
57383: LESS
57384: IFFALSE 57398
// SetLives ( i , 1000 ) ;
57386: LD_VAR 0 1
57390: PPUSH
57391: LD_INT 1000
57393: PPUSH
57394: CALL_OW 234
57398: GO 57368
57400: POP
57401: POP
// end ;
57402: PPOPN 1
57404: END
// export function hHackInvincible ; var i ; begin
57405: LD_INT 0
57407: PPUSH
57408: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57409: LD_ADDR_VAR 0 2
57413: PUSH
57414: LD_INT 2
57416: PUSH
57417: LD_INT 21
57419: PUSH
57420: LD_INT 1
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: PUSH
57427: LD_INT 21
57429: PUSH
57430: LD_INT 2
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: EMPTY
57438: LIST
57439: LIST
57440: LIST
57441: PPUSH
57442: CALL_OW 69
57446: PUSH
57447: FOR_IN
57448: IFFALSE 57509
// if IsSelected ( i ) then
57450: LD_VAR 0 2
57454: PPUSH
57455: CALL_OW 306
57459: IFFALSE 57507
// begin if i in hInvincible then
57461: LD_VAR 0 2
57465: PUSH
57466: LD_EXP 148
57470: IN
57471: IFFALSE 57491
// hInvincible := hInvincible diff i else
57473: LD_ADDR_EXP 148
57477: PUSH
57478: LD_EXP 148
57482: PUSH
57483: LD_VAR 0 2
57487: DIFF
57488: ST_TO_ADDR
57489: GO 57507
// hInvincible := hInvincible union i ;
57491: LD_ADDR_EXP 148
57495: PUSH
57496: LD_EXP 148
57500: PUSH
57501: LD_VAR 0 2
57505: UNION
57506: ST_TO_ADDR
// end ;
57507: GO 57447
57509: POP
57510: POP
// end ;
57511: LD_VAR 0 1
57515: RET
// export function hHackInvisible ; var i , j ; begin
57516: LD_INT 0
57518: PPUSH
57519: PPUSH
57520: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57521: LD_ADDR_VAR 0 2
57525: PUSH
57526: LD_INT 21
57528: PUSH
57529: LD_INT 1
57531: PUSH
57532: EMPTY
57533: LIST
57534: LIST
57535: PPUSH
57536: CALL_OW 69
57540: PUSH
57541: FOR_IN
57542: IFFALSE 57566
// if IsSelected ( i ) then
57544: LD_VAR 0 2
57548: PPUSH
57549: CALL_OW 306
57553: IFFALSE 57564
// ComForceInvisible ( i ) ;
57555: LD_VAR 0 2
57559: PPUSH
57560: CALL_OW 496
57564: GO 57541
57566: POP
57567: POP
// end ;
57568: LD_VAR 0 1
57572: RET
// export function hHackChangeYourSide ; begin
57573: LD_INT 0
57575: PPUSH
// if your_side = 8 then
57576: LD_OWVAR 2
57580: PUSH
57581: LD_INT 8
57583: EQUAL
57584: IFFALSE 57596
// your_side := 0 else
57586: LD_ADDR_OWVAR 2
57590: PUSH
57591: LD_INT 0
57593: ST_TO_ADDR
57594: GO 57610
// your_side := your_side + 1 ;
57596: LD_ADDR_OWVAR 2
57600: PUSH
57601: LD_OWVAR 2
57605: PUSH
57606: LD_INT 1
57608: PLUS
57609: ST_TO_ADDR
// end ;
57610: LD_VAR 0 1
57614: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57615: LD_INT 0
57617: PPUSH
57618: PPUSH
57619: PPUSH
// for i in all_units do
57620: LD_ADDR_VAR 0 2
57624: PUSH
57625: LD_OWVAR 3
57629: PUSH
57630: FOR_IN
57631: IFFALSE 57709
// if IsSelected ( i ) then
57633: LD_VAR 0 2
57637: PPUSH
57638: CALL_OW 306
57642: IFFALSE 57707
// begin j := GetSide ( i ) ;
57644: LD_ADDR_VAR 0 3
57648: PUSH
57649: LD_VAR 0 2
57653: PPUSH
57654: CALL_OW 255
57658: ST_TO_ADDR
// if j = 8 then
57659: LD_VAR 0 3
57663: PUSH
57664: LD_INT 8
57666: EQUAL
57667: IFFALSE 57679
// j := 0 else
57669: LD_ADDR_VAR 0 3
57673: PUSH
57674: LD_INT 0
57676: ST_TO_ADDR
57677: GO 57693
// j := j + 1 ;
57679: LD_ADDR_VAR 0 3
57683: PUSH
57684: LD_VAR 0 3
57688: PUSH
57689: LD_INT 1
57691: PLUS
57692: ST_TO_ADDR
// SetSide ( i , j ) ;
57693: LD_VAR 0 2
57697: PPUSH
57698: LD_VAR 0 3
57702: PPUSH
57703: CALL_OW 235
// end ;
57707: GO 57630
57709: POP
57710: POP
// end ;
57711: LD_VAR 0 1
57715: RET
// export function hHackFog ; begin
57716: LD_INT 0
57718: PPUSH
// FogOff ( true ) ;
57719: LD_INT 1
57721: PPUSH
57722: CALL_OW 344
// end ;
57726: LD_VAR 0 1
57730: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57731: LD_INT 0
57733: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57734: LD_VAR 0 1
57738: PPUSH
57739: LD_VAR 0 2
57743: PPUSH
57744: LD_VAR 0 3
57748: PPUSH
57749: LD_INT 1
57751: PPUSH
57752: LD_INT 1
57754: PPUSH
57755: CALL_OW 483
// CenterOnXY ( x , y ) ;
57759: LD_VAR 0 2
57763: PPUSH
57764: LD_VAR 0 3
57768: PPUSH
57769: CALL_OW 84
// end ;
57773: LD_VAR 0 4
57777: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57778: LD_INT 0
57780: PPUSH
57781: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57782: LD_VAR 0 1
57786: NOT
57787: PUSH
57788: LD_VAR 0 2
57792: PPUSH
57793: LD_VAR 0 3
57797: PPUSH
57798: CALL_OW 488
57802: NOT
57803: OR
57804: PUSH
57805: LD_VAR 0 1
57809: PPUSH
57810: CALL_OW 266
57814: PUSH
57815: LD_INT 3
57817: NONEQUAL
57818: PUSH
57819: LD_VAR 0 1
57823: PPUSH
57824: CALL_OW 247
57828: PUSH
57829: LD_INT 1
57831: EQUAL
57832: NOT
57833: AND
57834: OR
57835: IFFALSE 57839
// exit ;
57837: GO 57988
// if GetType ( factory ) = unit_human then
57839: LD_VAR 0 1
57843: PPUSH
57844: CALL_OW 247
57848: PUSH
57849: LD_INT 1
57851: EQUAL
57852: IFFALSE 57869
// factory := IsInUnit ( factory ) ;
57854: LD_ADDR_VAR 0 1
57858: PUSH
57859: LD_VAR 0 1
57863: PPUSH
57864: CALL_OW 310
57868: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57869: LD_VAR 0 1
57873: PPUSH
57874: CALL_OW 266
57878: PUSH
57879: LD_INT 3
57881: NONEQUAL
57882: IFFALSE 57886
// exit ;
57884: GO 57988
// if HexInfo ( x , y ) = factory then
57886: LD_VAR 0 2
57890: PPUSH
57891: LD_VAR 0 3
57895: PPUSH
57896: CALL_OW 428
57900: PUSH
57901: LD_VAR 0 1
57905: EQUAL
57906: IFFALSE 57933
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57908: LD_ADDR_EXP 149
57912: PUSH
57913: LD_EXP 149
57917: PPUSH
57918: LD_VAR 0 1
57922: PPUSH
57923: LD_INT 0
57925: PPUSH
57926: CALL_OW 1
57930: ST_TO_ADDR
57931: GO 57984
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57933: LD_ADDR_EXP 149
57937: PUSH
57938: LD_EXP 149
57942: PPUSH
57943: LD_VAR 0 1
57947: PPUSH
57948: LD_VAR 0 1
57952: PPUSH
57953: CALL_OW 255
57957: PUSH
57958: LD_VAR 0 1
57962: PUSH
57963: LD_VAR 0 2
57967: PUSH
57968: LD_VAR 0 3
57972: PUSH
57973: EMPTY
57974: LIST
57975: LIST
57976: LIST
57977: LIST
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57984: CALL 57993 0 0
// end ;
57988: LD_VAR 0 4
57992: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57993: LD_INT 0
57995: PPUSH
57996: PPUSH
57997: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57998: LD_STRING resetFactoryWaypoint();
58000: PPUSH
58001: CALL_OW 559
// if factoryWaypoints then
58005: LD_EXP 149
58009: IFFALSE 58135
// begin list := PrepareArray ( factoryWaypoints ) ;
58011: LD_ADDR_VAR 0 3
58015: PUSH
58016: LD_EXP 149
58020: PPUSH
58021: CALL 104567 0 1
58025: ST_TO_ADDR
// for i := 1 to list do
58026: LD_ADDR_VAR 0 2
58030: PUSH
58031: DOUBLE
58032: LD_INT 1
58034: DEC
58035: ST_TO_ADDR
58036: LD_VAR 0 3
58040: PUSH
58041: FOR_TO
58042: IFFALSE 58133
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58044: LD_STRING setFactoryWaypointXY(
58046: PUSH
58047: LD_VAR 0 3
58051: PUSH
58052: LD_VAR 0 2
58056: ARRAY
58057: PUSH
58058: LD_INT 1
58060: ARRAY
58061: STR
58062: PUSH
58063: LD_STRING ,
58065: STR
58066: PUSH
58067: LD_VAR 0 3
58071: PUSH
58072: LD_VAR 0 2
58076: ARRAY
58077: PUSH
58078: LD_INT 2
58080: ARRAY
58081: STR
58082: PUSH
58083: LD_STRING ,
58085: STR
58086: PUSH
58087: LD_VAR 0 3
58091: PUSH
58092: LD_VAR 0 2
58096: ARRAY
58097: PUSH
58098: LD_INT 3
58100: ARRAY
58101: STR
58102: PUSH
58103: LD_STRING ,
58105: STR
58106: PUSH
58107: LD_VAR 0 3
58111: PUSH
58112: LD_VAR 0 2
58116: ARRAY
58117: PUSH
58118: LD_INT 4
58120: ARRAY
58121: STR
58122: PUSH
58123: LD_STRING )
58125: STR
58126: PPUSH
58127: CALL_OW 559
58131: GO 58041
58133: POP
58134: POP
// end ; end ;
58135: LD_VAR 0 1
58139: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
58140: LD_INT 0
58142: PPUSH
// if HexInfo ( x , y ) = warehouse then
58143: LD_VAR 0 2
58147: PPUSH
58148: LD_VAR 0 3
58152: PPUSH
58153: CALL_OW 428
58157: PUSH
58158: LD_VAR 0 1
58162: EQUAL
58163: IFFALSE 58190
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58165: LD_ADDR_EXP 150
58169: PUSH
58170: LD_EXP 150
58174: PPUSH
58175: LD_VAR 0 1
58179: PPUSH
58180: LD_INT 0
58182: PPUSH
58183: CALL_OW 1
58187: ST_TO_ADDR
58188: GO 58241
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58190: LD_ADDR_EXP 150
58194: PUSH
58195: LD_EXP 150
58199: PPUSH
58200: LD_VAR 0 1
58204: PPUSH
58205: LD_VAR 0 1
58209: PPUSH
58210: CALL_OW 255
58214: PUSH
58215: LD_VAR 0 1
58219: PUSH
58220: LD_VAR 0 2
58224: PUSH
58225: LD_VAR 0 3
58229: PUSH
58230: EMPTY
58231: LIST
58232: LIST
58233: LIST
58234: LIST
58235: PPUSH
58236: CALL_OW 1
58240: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58241: CALL 58250 0 0
// end ;
58245: LD_VAR 0 4
58249: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58250: LD_INT 0
58252: PPUSH
58253: PPUSH
58254: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58255: LD_STRING resetWarehouseGatheringPoints();
58257: PPUSH
58258: CALL_OW 559
// if warehouseGatheringPoints then
58262: LD_EXP 150
58266: IFFALSE 58392
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58268: LD_ADDR_VAR 0 3
58272: PUSH
58273: LD_EXP 150
58277: PPUSH
58278: CALL 104567 0 1
58282: ST_TO_ADDR
// for i := 1 to list do
58283: LD_ADDR_VAR 0 2
58287: PUSH
58288: DOUBLE
58289: LD_INT 1
58291: DEC
58292: ST_TO_ADDR
58293: LD_VAR 0 3
58297: PUSH
58298: FOR_TO
58299: IFFALSE 58390
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58301: LD_STRING setWarehouseGatheringPointXY(
58303: PUSH
58304: LD_VAR 0 3
58308: PUSH
58309: LD_VAR 0 2
58313: ARRAY
58314: PUSH
58315: LD_INT 1
58317: ARRAY
58318: STR
58319: PUSH
58320: LD_STRING ,
58322: STR
58323: PUSH
58324: LD_VAR 0 3
58328: PUSH
58329: LD_VAR 0 2
58333: ARRAY
58334: PUSH
58335: LD_INT 2
58337: ARRAY
58338: STR
58339: PUSH
58340: LD_STRING ,
58342: STR
58343: PUSH
58344: LD_VAR 0 3
58348: PUSH
58349: LD_VAR 0 2
58353: ARRAY
58354: PUSH
58355: LD_INT 3
58357: ARRAY
58358: STR
58359: PUSH
58360: LD_STRING ,
58362: STR
58363: PUSH
58364: LD_VAR 0 3
58368: PUSH
58369: LD_VAR 0 2
58373: ARRAY
58374: PUSH
58375: LD_INT 4
58377: ARRAY
58378: STR
58379: PUSH
58380: LD_STRING )
58382: STR
58383: PPUSH
58384: CALL_OW 559
58388: GO 58298
58390: POP
58391: POP
// end ; end ;
58392: LD_VAR 0 1
58396: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58397: LD_EXP 150
58401: IFFALSE 59088
58403: GO 58405
58405: DISABLE
58406: LD_INT 0
58408: PPUSH
58409: PPUSH
58410: PPUSH
58411: PPUSH
58412: PPUSH
58413: PPUSH
58414: PPUSH
58415: PPUSH
58416: PPUSH
// begin enable ;
58417: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58418: LD_ADDR_VAR 0 3
58422: PUSH
58423: LD_EXP 150
58427: PPUSH
58428: CALL 104567 0 1
58432: ST_TO_ADDR
// if not list then
58433: LD_VAR 0 3
58437: NOT
58438: IFFALSE 58442
// exit ;
58440: GO 59088
// for i := 1 to list do
58442: LD_ADDR_VAR 0 1
58446: PUSH
58447: DOUBLE
58448: LD_INT 1
58450: DEC
58451: ST_TO_ADDR
58452: LD_VAR 0 3
58456: PUSH
58457: FOR_TO
58458: IFFALSE 59086
// begin depot := list [ i ] [ 2 ] ;
58460: LD_ADDR_VAR 0 8
58464: PUSH
58465: LD_VAR 0 3
58469: PUSH
58470: LD_VAR 0 1
58474: ARRAY
58475: PUSH
58476: LD_INT 2
58478: ARRAY
58479: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58480: LD_ADDR_VAR 0 5
58484: PUSH
58485: LD_VAR 0 3
58489: PUSH
58490: LD_VAR 0 1
58494: ARRAY
58495: PUSH
58496: LD_INT 1
58498: ARRAY
58499: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58500: LD_VAR 0 8
58504: PPUSH
58505: CALL_OW 301
58509: PUSH
58510: LD_VAR 0 5
58514: PUSH
58515: LD_VAR 0 8
58519: PPUSH
58520: CALL_OW 255
58524: NONEQUAL
58525: OR
58526: IFFALSE 58555
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58528: LD_ADDR_EXP 150
58532: PUSH
58533: LD_EXP 150
58537: PPUSH
58538: LD_VAR 0 8
58542: PPUSH
58543: LD_INT 0
58545: PPUSH
58546: CALL_OW 1
58550: ST_TO_ADDR
// exit ;
58551: POP
58552: POP
58553: GO 59088
// end ; x := list [ i ] [ 3 ] ;
58555: LD_ADDR_VAR 0 6
58559: PUSH
58560: LD_VAR 0 3
58564: PUSH
58565: LD_VAR 0 1
58569: ARRAY
58570: PUSH
58571: LD_INT 3
58573: ARRAY
58574: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58575: LD_ADDR_VAR 0 7
58579: PUSH
58580: LD_VAR 0 3
58584: PUSH
58585: LD_VAR 0 1
58589: ARRAY
58590: PUSH
58591: LD_INT 4
58593: ARRAY
58594: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58595: LD_ADDR_VAR 0 9
58599: PUSH
58600: LD_VAR 0 6
58604: PPUSH
58605: LD_VAR 0 7
58609: PPUSH
58610: LD_INT 16
58612: PPUSH
58613: CALL 103151 0 3
58617: ST_TO_ADDR
// if not cratesNearbyPoint then
58618: LD_VAR 0 9
58622: NOT
58623: IFFALSE 58629
// exit ;
58625: POP
58626: POP
58627: GO 59088
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58629: LD_ADDR_VAR 0 4
58633: PUSH
58634: LD_INT 22
58636: PUSH
58637: LD_VAR 0 5
58641: PUSH
58642: EMPTY
58643: LIST
58644: LIST
58645: PUSH
58646: LD_INT 3
58648: PUSH
58649: LD_INT 60
58651: PUSH
58652: EMPTY
58653: LIST
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PUSH
58659: LD_INT 91
58661: PUSH
58662: LD_VAR 0 8
58666: PUSH
58667: LD_INT 6
58669: PUSH
58670: EMPTY
58671: LIST
58672: LIST
58673: LIST
58674: PUSH
58675: LD_INT 2
58677: PUSH
58678: LD_INT 25
58680: PUSH
58681: LD_INT 2
58683: PUSH
58684: EMPTY
58685: LIST
58686: LIST
58687: PUSH
58688: LD_INT 25
58690: PUSH
58691: LD_INT 16
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: PUSH
58698: EMPTY
58699: LIST
58700: LIST
58701: LIST
58702: PUSH
58703: EMPTY
58704: LIST
58705: LIST
58706: LIST
58707: LIST
58708: PPUSH
58709: CALL_OW 69
58713: PUSH
58714: LD_VAR 0 8
58718: PPUSH
58719: CALL_OW 313
58723: PPUSH
58724: LD_INT 3
58726: PUSH
58727: LD_INT 60
58729: PUSH
58730: EMPTY
58731: LIST
58732: PUSH
58733: EMPTY
58734: LIST
58735: LIST
58736: PUSH
58737: LD_INT 2
58739: PUSH
58740: LD_INT 25
58742: PUSH
58743: LD_INT 2
58745: PUSH
58746: EMPTY
58747: LIST
58748: LIST
58749: PUSH
58750: LD_INT 25
58752: PUSH
58753: LD_INT 16
58755: PUSH
58756: EMPTY
58757: LIST
58758: LIST
58759: PUSH
58760: EMPTY
58761: LIST
58762: LIST
58763: LIST
58764: PUSH
58765: EMPTY
58766: LIST
58767: LIST
58768: PPUSH
58769: CALL_OW 72
58773: UNION
58774: ST_TO_ADDR
// if tmp then
58775: LD_VAR 0 4
58779: IFFALSE 58859
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58781: LD_ADDR_VAR 0 4
58785: PUSH
58786: LD_VAR 0 4
58790: PPUSH
58791: LD_INT 3
58793: PPUSH
58794: CALL 101118 0 2
58798: ST_TO_ADDR
// for j in tmp do
58799: LD_ADDR_VAR 0 2
58803: PUSH
58804: LD_VAR 0 4
58808: PUSH
58809: FOR_IN
58810: IFFALSE 58853
// begin if IsInUnit ( j ) then
58812: LD_VAR 0 2
58816: PPUSH
58817: CALL_OW 310
58821: IFFALSE 58832
// ComExit ( j ) ;
58823: LD_VAR 0 2
58827: PPUSH
58828: CALL 101201 0 1
// AddComCollect ( j , x , y ) ;
58832: LD_VAR 0 2
58836: PPUSH
58837: LD_VAR 0 6
58841: PPUSH
58842: LD_VAR 0 7
58846: PPUSH
58847: CALL_OW 177
// end ;
58851: GO 58809
58853: POP
58854: POP
// exit ;
58855: POP
58856: POP
58857: GO 59088
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58859: LD_ADDR_VAR 0 4
58863: PUSH
58864: LD_INT 22
58866: PUSH
58867: LD_VAR 0 5
58871: PUSH
58872: EMPTY
58873: LIST
58874: LIST
58875: PUSH
58876: LD_INT 91
58878: PUSH
58879: LD_VAR 0 8
58883: PUSH
58884: LD_INT 8
58886: PUSH
58887: EMPTY
58888: LIST
58889: LIST
58890: LIST
58891: PUSH
58892: LD_INT 2
58894: PUSH
58895: LD_INT 34
58897: PUSH
58898: LD_INT 12
58900: PUSH
58901: EMPTY
58902: LIST
58903: LIST
58904: PUSH
58905: LD_INT 34
58907: PUSH
58908: LD_INT 51
58910: PUSH
58911: EMPTY
58912: LIST
58913: LIST
58914: PUSH
58915: LD_INT 34
58917: PUSH
58918: LD_INT 32
58920: PUSH
58921: EMPTY
58922: LIST
58923: LIST
58924: PUSH
58925: LD_INT 34
58927: PUSH
58928: LD_EXP 74
58932: PUSH
58933: EMPTY
58934: LIST
58935: LIST
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: LIST
58941: LIST
58942: LIST
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: LIST
58948: PPUSH
58949: CALL_OW 69
58953: ST_TO_ADDR
// if tmp then
58954: LD_VAR 0 4
58958: IFFALSE 59084
// begin for j in tmp do
58960: LD_ADDR_VAR 0 2
58964: PUSH
58965: LD_VAR 0 4
58969: PUSH
58970: FOR_IN
58971: IFFALSE 59082
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58973: LD_VAR 0 2
58977: PPUSH
58978: CALL_OW 262
58982: PUSH
58983: LD_INT 3
58985: EQUAL
58986: PUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: CALL_OW 261
58996: PUSH
58997: LD_INT 20
58999: GREATER
59000: OR
59001: PUSH
59002: LD_VAR 0 2
59006: PPUSH
59007: CALL_OW 314
59011: NOT
59012: AND
59013: PUSH
59014: LD_VAR 0 2
59018: PPUSH
59019: CALL_OW 263
59023: PUSH
59024: LD_INT 1
59026: NONEQUAL
59027: PUSH
59028: LD_VAR 0 2
59032: PPUSH
59033: CALL_OW 311
59037: OR
59038: AND
59039: IFFALSE 59080
// begin ComCollect ( j , x , y ) ;
59041: LD_VAR 0 2
59045: PPUSH
59046: LD_VAR 0 6
59050: PPUSH
59051: LD_VAR 0 7
59055: PPUSH
59056: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
59060: LD_VAR 0 2
59064: PPUSH
59065: LD_VAR 0 8
59069: PPUSH
59070: CALL_OW 172
// exit ;
59074: POP
59075: POP
59076: POP
59077: POP
59078: GO 59088
// end ;
59080: GO 58970
59082: POP
59083: POP
// end ; end ;
59084: GO 58457
59086: POP
59087: POP
// end ; end_of_file
59088: PPOPN 9
59090: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
59091: LD_INT 0
59093: PPUSH
59094: PPUSH
59095: PPUSH
59096: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
59097: LD_VAR 0 1
59101: PPUSH
59102: CALL_OW 264
59106: PUSH
59107: LD_EXP 77
59111: EQUAL
59112: IFFALSE 59184
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
59114: LD_INT 68
59116: PPUSH
59117: LD_VAR 0 1
59121: PPUSH
59122: CALL_OW 255
59126: PPUSH
59127: CALL_OW 321
59131: PUSH
59132: LD_INT 2
59134: EQUAL
59135: IFFALSE 59147
// eff := 70 else
59137: LD_ADDR_VAR 0 4
59141: PUSH
59142: LD_INT 70
59144: ST_TO_ADDR
59145: GO 59155
// eff := 30 ;
59147: LD_ADDR_VAR 0 4
59151: PUSH
59152: LD_INT 30
59154: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
59155: LD_VAR 0 1
59159: PPUSH
59160: CALL_OW 250
59164: PPUSH
59165: LD_VAR 0 1
59169: PPUSH
59170: CALL_OW 251
59174: PPUSH
59175: LD_VAR 0 4
59179: PPUSH
59180: CALL_OW 495
// end ; end ;
59184: LD_VAR 0 2
59188: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59189: LD_INT 0
59191: PPUSH
// end ;
59192: LD_VAR 0 4
59196: RET
// export function SOS_Command ( cmd ) ; begin
59197: LD_INT 0
59199: PPUSH
// end ;
59200: LD_VAR 0 2
59204: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59205: LD_INT 0
59207: PPUSH
// end ;
59208: LD_VAR 0 6
59212: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59213: LD_INT 0
59215: PPUSH
59216: PPUSH
// if not vehicle or not factory then
59217: LD_VAR 0 1
59221: NOT
59222: PUSH
59223: LD_VAR 0 2
59227: NOT
59228: OR
59229: IFFALSE 59233
// exit ;
59231: GO 59464
// if factoryWaypoints >= factory then
59233: LD_EXP 149
59237: PUSH
59238: LD_VAR 0 2
59242: GREATEREQUAL
59243: IFFALSE 59464
// if factoryWaypoints [ factory ] then
59245: LD_EXP 149
59249: PUSH
59250: LD_VAR 0 2
59254: ARRAY
59255: IFFALSE 59464
// begin if GetControl ( vehicle ) = control_manual then
59257: LD_VAR 0 1
59261: PPUSH
59262: CALL_OW 263
59266: PUSH
59267: LD_INT 1
59269: EQUAL
59270: IFFALSE 59351
// begin driver := IsDrivenBy ( vehicle ) ;
59272: LD_ADDR_VAR 0 4
59276: PUSH
59277: LD_VAR 0 1
59281: PPUSH
59282: CALL_OW 311
59286: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59287: LD_VAR 0 4
59291: PPUSH
59292: LD_EXP 149
59296: PUSH
59297: LD_VAR 0 2
59301: ARRAY
59302: PUSH
59303: LD_INT 3
59305: ARRAY
59306: PPUSH
59307: LD_EXP 149
59311: PUSH
59312: LD_VAR 0 2
59316: ARRAY
59317: PUSH
59318: LD_INT 4
59320: ARRAY
59321: PPUSH
59322: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59326: LD_VAR 0 4
59330: PPUSH
59331: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59335: LD_VAR 0 4
59339: PPUSH
59340: LD_VAR 0 2
59344: PPUSH
59345: CALL_OW 180
// end else
59349: GO 59464
// if GetControl ( vehicle ) = control_remote then
59351: LD_VAR 0 1
59355: PPUSH
59356: CALL_OW 263
59360: PUSH
59361: LD_INT 2
59363: EQUAL
59364: IFFALSE 59425
// begin wait ( 0 0$2 ) ;
59366: LD_INT 70
59368: PPUSH
59369: CALL_OW 67
// if Connect ( vehicle ) then
59373: LD_VAR 0 1
59377: PPUSH
59378: CALL 71512 0 1
59382: IFFALSE 59423
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59384: LD_VAR 0 1
59388: PPUSH
59389: LD_EXP 149
59393: PUSH
59394: LD_VAR 0 2
59398: ARRAY
59399: PUSH
59400: LD_INT 3
59402: ARRAY
59403: PPUSH
59404: LD_EXP 149
59408: PUSH
59409: LD_VAR 0 2
59413: ARRAY
59414: PUSH
59415: LD_INT 4
59417: ARRAY
59418: PPUSH
59419: CALL_OW 171
// end else
59423: GO 59464
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59425: LD_VAR 0 1
59429: PPUSH
59430: LD_EXP 149
59434: PUSH
59435: LD_VAR 0 2
59439: ARRAY
59440: PUSH
59441: LD_INT 3
59443: ARRAY
59444: PPUSH
59445: LD_EXP 149
59449: PUSH
59450: LD_VAR 0 2
59454: ARRAY
59455: PUSH
59456: LD_INT 4
59458: ARRAY
59459: PPUSH
59460: CALL_OW 171
// end ; end ;
59464: LD_VAR 0 3
59468: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59469: LD_INT 0
59471: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59472: LD_VAR 0 1
59476: PUSH
59477: LD_INT 250
59479: EQUAL
59480: PUSH
59481: LD_VAR 0 2
59485: PPUSH
59486: CALL_OW 264
59490: PUSH
59491: LD_EXP 80
59495: EQUAL
59496: AND
59497: IFFALSE 59518
// MinerPlaceMine ( unit , x , y ) ;
59499: LD_VAR 0 2
59503: PPUSH
59504: LD_VAR 0 4
59508: PPUSH
59509: LD_VAR 0 5
59513: PPUSH
59514: CALL 61917 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59518: LD_VAR 0 1
59522: PUSH
59523: LD_INT 251
59525: EQUAL
59526: PUSH
59527: LD_VAR 0 2
59531: PPUSH
59532: CALL_OW 264
59536: PUSH
59537: LD_EXP 80
59541: EQUAL
59542: AND
59543: IFFALSE 59564
// MinerDetonateMine ( unit , x , y ) ;
59545: LD_VAR 0 2
59549: PPUSH
59550: LD_VAR 0 4
59554: PPUSH
59555: LD_VAR 0 5
59559: PPUSH
59560: CALL 62194 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59564: LD_VAR 0 1
59568: PUSH
59569: LD_INT 252
59571: EQUAL
59572: PUSH
59573: LD_VAR 0 2
59577: PPUSH
59578: CALL_OW 264
59582: PUSH
59583: LD_EXP 80
59587: EQUAL
59588: AND
59589: IFFALSE 59610
// MinerCreateMinefield ( unit , x , y ) ;
59591: LD_VAR 0 2
59595: PPUSH
59596: LD_VAR 0 4
59600: PPUSH
59601: LD_VAR 0 5
59605: PPUSH
59606: CALL 62611 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59610: LD_VAR 0 1
59614: PUSH
59615: LD_INT 253
59617: EQUAL
59618: PUSH
59619: LD_VAR 0 2
59623: PPUSH
59624: CALL_OW 257
59628: PUSH
59629: LD_INT 5
59631: EQUAL
59632: AND
59633: IFFALSE 59654
// ComBinocular ( unit , x , y ) ;
59635: LD_VAR 0 2
59639: PPUSH
59640: LD_VAR 0 4
59644: PPUSH
59645: LD_VAR 0 5
59649: PPUSH
59650: CALL 62982 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59654: LD_VAR 0 1
59658: PUSH
59659: LD_INT 254
59661: EQUAL
59662: PUSH
59663: LD_VAR 0 2
59667: PPUSH
59668: CALL_OW 264
59672: PUSH
59673: LD_EXP 75
59677: EQUAL
59678: AND
59679: PUSH
59680: LD_VAR 0 3
59684: PPUSH
59685: CALL_OW 263
59689: PUSH
59690: LD_INT 3
59692: EQUAL
59693: AND
59694: IFFALSE 59710
// HackDestroyVehicle ( unit , selectedUnit ) ;
59696: LD_VAR 0 2
59700: PPUSH
59701: LD_VAR 0 3
59705: PPUSH
59706: CALL 61277 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59710: LD_VAR 0 1
59714: PUSH
59715: LD_INT 255
59717: EQUAL
59718: PUSH
59719: LD_VAR 0 2
59723: PPUSH
59724: CALL_OW 264
59728: PUSH
59729: LD_INT 14
59731: PUSH
59732: LD_INT 53
59734: PUSH
59735: EMPTY
59736: LIST
59737: LIST
59738: IN
59739: AND
59740: PUSH
59741: LD_VAR 0 4
59745: PPUSH
59746: LD_VAR 0 5
59750: PPUSH
59751: CALL_OW 488
59755: AND
59756: IFFALSE 59780
// CutTreeXYR ( unit , x , y , 12 ) ;
59758: LD_VAR 0 2
59762: PPUSH
59763: LD_VAR 0 4
59767: PPUSH
59768: LD_VAR 0 5
59772: PPUSH
59773: LD_INT 12
59775: PPUSH
59776: CALL 59843 0 4
// if cmd = 256 then
59780: LD_VAR 0 1
59784: PUSH
59785: LD_INT 256
59787: EQUAL
59788: IFFALSE 59809
// SetFactoryWaypoint ( unit , x , y ) ;
59790: LD_VAR 0 2
59794: PPUSH
59795: LD_VAR 0 4
59799: PPUSH
59800: LD_VAR 0 5
59804: PPUSH
59805: CALL 57778 0 3
// if cmd = 257 then
59809: LD_VAR 0 1
59813: PUSH
59814: LD_INT 257
59816: EQUAL
59817: IFFALSE 59838
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59819: LD_VAR 0 2
59823: PPUSH
59824: LD_VAR 0 4
59828: PPUSH
59829: LD_VAR 0 5
59833: PPUSH
59834: CALL 58140 0 3
// end ;
59838: LD_VAR 0 6
59842: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59843: LD_INT 0
59845: PPUSH
59846: PPUSH
59847: PPUSH
59848: PPUSH
59849: PPUSH
59850: PPUSH
59851: PPUSH
59852: PPUSH
59853: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59854: LD_VAR 0 1
59858: NOT
59859: PUSH
59860: LD_VAR 0 2
59864: PPUSH
59865: LD_VAR 0 3
59869: PPUSH
59870: CALL_OW 488
59874: NOT
59875: OR
59876: PUSH
59877: LD_VAR 0 4
59881: NOT
59882: OR
59883: IFFALSE 59887
// exit ;
59885: GO 60227
// list := [ ] ;
59887: LD_ADDR_VAR 0 13
59891: PUSH
59892: EMPTY
59893: ST_TO_ADDR
// if x - r < 0 then
59894: LD_VAR 0 2
59898: PUSH
59899: LD_VAR 0 4
59903: MINUS
59904: PUSH
59905: LD_INT 0
59907: LESS
59908: IFFALSE 59920
// min_x := 0 else
59910: LD_ADDR_VAR 0 7
59914: PUSH
59915: LD_INT 0
59917: ST_TO_ADDR
59918: GO 59936
// min_x := x - r ;
59920: LD_ADDR_VAR 0 7
59924: PUSH
59925: LD_VAR 0 2
59929: PUSH
59930: LD_VAR 0 4
59934: MINUS
59935: ST_TO_ADDR
// if y - r < 0 then
59936: LD_VAR 0 3
59940: PUSH
59941: LD_VAR 0 4
59945: MINUS
59946: PUSH
59947: LD_INT 0
59949: LESS
59950: IFFALSE 59962
// min_y := 0 else
59952: LD_ADDR_VAR 0 8
59956: PUSH
59957: LD_INT 0
59959: ST_TO_ADDR
59960: GO 59978
// min_y := y - r ;
59962: LD_ADDR_VAR 0 8
59966: PUSH
59967: LD_VAR 0 3
59971: PUSH
59972: LD_VAR 0 4
59976: MINUS
59977: ST_TO_ADDR
// max_x := x + r ;
59978: LD_ADDR_VAR 0 9
59982: PUSH
59983: LD_VAR 0 2
59987: PUSH
59988: LD_VAR 0 4
59992: PLUS
59993: ST_TO_ADDR
// max_y := y + r ;
59994: LD_ADDR_VAR 0 10
59998: PUSH
59999: LD_VAR 0 3
60003: PUSH
60004: LD_VAR 0 4
60008: PLUS
60009: ST_TO_ADDR
// for _x = min_x to max_x do
60010: LD_ADDR_VAR 0 11
60014: PUSH
60015: DOUBLE
60016: LD_VAR 0 7
60020: DEC
60021: ST_TO_ADDR
60022: LD_VAR 0 9
60026: PUSH
60027: FOR_TO
60028: IFFALSE 60145
// for _y = min_y to max_y do
60030: LD_ADDR_VAR 0 12
60034: PUSH
60035: DOUBLE
60036: LD_VAR 0 8
60040: DEC
60041: ST_TO_ADDR
60042: LD_VAR 0 10
60046: PUSH
60047: FOR_TO
60048: IFFALSE 60141
// begin if not ValidHex ( _x , _y ) then
60050: LD_VAR 0 11
60054: PPUSH
60055: LD_VAR 0 12
60059: PPUSH
60060: CALL_OW 488
60064: NOT
60065: IFFALSE 60069
// continue ;
60067: GO 60047
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
60069: LD_VAR 0 11
60073: PPUSH
60074: LD_VAR 0 12
60078: PPUSH
60079: CALL_OW 351
60083: PUSH
60084: LD_VAR 0 11
60088: PPUSH
60089: LD_VAR 0 12
60093: PPUSH
60094: CALL_OW 554
60098: AND
60099: IFFALSE 60139
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
60101: LD_ADDR_VAR 0 13
60105: PUSH
60106: LD_VAR 0 13
60110: PPUSH
60111: LD_VAR 0 13
60115: PUSH
60116: LD_INT 1
60118: PLUS
60119: PPUSH
60120: LD_VAR 0 11
60124: PUSH
60125: LD_VAR 0 12
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PPUSH
60134: CALL_OW 2
60138: ST_TO_ADDR
// end ;
60139: GO 60047
60141: POP
60142: POP
60143: GO 60027
60145: POP
60146: POP
// if not list then
60147: LD_VAR 0 13
60151: NOT
60152: IFFALSE 60156
// exit ;
60154: GO 60227
// for i in list do
60156: LD_ADDR_VAR 0 6
60160: PUSH
60161: LD_VAR 0 13
60165: PUSH
60166: FOR_IN
60167: IFFALSE 60225
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
60169: LD_VAR 0 1
60173: PPUSH
60174: LD_STRING M
60176: PUSH
60177: LD_VAR 0 6
60181: PUSH
60182: LD_INT 1
60184: ARRAY
60185: PUSH
60186: LD_VAR 0 6
60190: PUSH
60191: LD_INT 2
60193: ARRAY
60194: PUSH
60195: LD_INT 0
60197: PUSH
60198: LD_INT 0
60200: PUSH
60201: LD_INT 0
60203: PUSH
60204: LD_INT 0
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: LIST
60211: LIST
60212: LIST
60213: LIST
60214: LIST
60215: PUSH
60216: EMPTY
60217: LIST
60218: PPUSH
60219: CALL_OW 447
60223: GO 60166
60225: POP
60226: POP
// end ;
60227: LD_VAR 0 5
60231: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60232: LD_EXP 152
60236: NOT
60237: IFFALSE 60287
60239: GO 60241
60241: DISABLE
// begin initHack := true ;
60242: LD_ADDR_EXP 152
60246: PUSH
60247: LD_INT 1
60249: ST_TO_ADDR
// hackTanks := [ ] ;
60250: LD_ADDR_EXP 153
60254: PUSH
60255: EMPTY
60256: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60257: LD_ADDR_EXP 154
60261: PUSH
60262: EMPTY
60263: ST_TO_ADDR
// hackLimit := 3 ;
60264: LD_ADDR_EXP 155
60268: PUSH
60269: LD_INT 3
60271: ST_TO_ADDR
// hackDist := 12 ;
60272: LD_ADDR_EXP 156
60276: PUSH
60277: LD_INT 12
60279: ST_TO_ADDR
// hackCounter := [ ] ;
60280: LD_ADDR_EXP 157
60284: PUSH
60285: EMPTY
60286: ST_TO_ADDR
// end ;
60287: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60288: LD_EXP 152
60292: PUSH
60293: LD_INT 34
60295: PUSH
60296: LD_EXP 75
60300: PUSH
60301: EMPTY
60302: LIST
60303: LIST
60304: PPUSH
60305: CALL_OW 69
60309: AND
60310: IFFALSE 60565
60312: GO 60314
60314: DISABLE
60315: LD_INT 0
60317: PPUSH
60318: PPUSH
// begin enable ;
60319: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60320: LD_ADDR_VAR 0 1
60324: PUSH
60325: LD_INT 34
60327: PUSH
60328: LD_EXP 75
60332: PUSH
60333: EMPTY
60334: LIST
60335: LIST
60336: PPUSH
60337: CALL_OW 69
60341: PUSH
60342: FOR_IN
60343: IFFALSE 60563
// begin if not i in hackTanks then
60345: LD_VAR 0 1
60349: PUSH
60350: LD_EXP 153
60354: IN
60355: NOT
60356: IFFALSE 60439
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60358: LD_ADDR_EXP 153
60362: PUSH
60363: LD_EXP 153
60367: PPUSH
60368: LD_EXP 153
60372: PUSH
60373: LD_INT 1
60375: PLUS
60376: PPUSH
60377: LD_VAR 0 1
60381: PPUSH
60382: CALL_OW 1
60386: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60387: LD_ADDR_EXP 154
60391: PUSH
60392: LD_EXP 154
60396: PPUSH
60397: LD_EXP 154
60401: PUSH
60402: LD_INT 1
60404: PLUS
60405: PPUSH
60406: EMPTY
60407: PPUSH
60408: CALL_OW 1
60412: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60413: LD_ADDR_EXP 157
60417: PUSH
60418: LD_EXP 157
60422: PPUSH
60423: LD_EXP 157
60427: PUSH
60428: LD_INT 1
60430: PLUS
60431: PPUSH
60432: EMPTY
60433: PPUSH
60434: CALL_OW 1
60438: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60439: LD_VAR 0 1
60443: PPUSH
60444: CALL_OW 302
60448: NOT
60449: IFFALSE 60462
// begin HackUnlinkAll ( i ) ;
60451: LD_VAR 0 1
60455: PPUSH
60456: CALL 60568 0 1
// continue ;
60460: GO 60342
// end ; HackCheckCapturedStatus ( i ) ;
60462: LD_VAR 0 1
60466: PPUSH
60467: CALL 61011 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60471: LD_ADDR_VAR 0 2
60475: PUSH
60476: LD_INT 81
60478: PUSH
60479: LD_VAR 0 1
60483: PPUSH
60484: CALL_OW 255
60488: PUSH
60489: EMPTY
60490: LIST
60491: LIST
60492: PUSH
60493: LD_INT 33
60495: PUSH
60496: LD_INT 3
60498: PUSH
60499: EMPTY
60500: LIST
60501: LIST
60502: PUSH
60503: LD_INT 91
60505: PUSH
60506: LD_VAR 0 1
60510: PUSH
60511: LD_EXP 156
60515: PUSH
60516: EMPTY
60517: LIST
60518: LIST
60519: LIST
60520: PUSH
60521: LD_INT 50
60523: PUSH
60524: EMPTY
60525: LIST
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: LIST
60531: LIST
60532: PPUSH
60533: CALL_OW 69
60537: ST_TO_ADDR
// if not tmp then
60538: LD_VAR 0 2
60542: NOT
60543: IFFALSE 60547
// continue ;
60545: GO 60342
// HackLink ( i , tmp ) ;
60547: LD_VAR 0 1
60551: PPUSH
60552: LD_VAR 0 2
60556: PPUSH
60557: CALL 60704 0 2
// end ;
60561: GO 60342
60563: POP
60564: POP
// end ;
60565: PPOPN 2
60567: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60568: LD_INT 0
60570: PPUSH
60571: PPUSH
60572: PPUSH
// if not hack in hackTanks then
60573: LD_VAR 0 1
60577: PUSH
60578: LD_EXP 153
60582: IN
60583: NOT
60584: IFFALSE 60588
// exit ;
60586: GO 60699
// index := GetElementIndex ( hackTanks , hack ) ;
60588: LD_ADDR_VAR 0 4
60592: PUSH
60593: LD_EXP 153
60597: PPUSH
60598: LD_VAR 0 1
60602: PPUSH
60603: CALL 68326 0 2
60607: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60608: LD_EXP 154
60612: PUSH
60613: LD_VAR 0 4
60617: ARRAY
60618: IFFALSE 60699
// begin for i in hackTanksCaptured [ index ] do
60620: LD_ADDR_VAR 0 3
60624: PUSH
60625: LD_EXP 154
60629: PUSH
60630: LD_VAR 0 4
60634: ARRAY
60635: PUSH
60636: FOR_IN
60637: IFFALSE 60663
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60639: LD_VAR 0 3
60643: PUSH
60644: LD_INT 1
60646: ARRAY
60647: PPUSH
60648: LD_VAR 0 3
60652: PUSH
60653: LD_INT 2
60655: ARRAY
60656: PPUSH
60657: CALL_OW 235
60661: GO 60636
60663: POP
60664: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60665: LD_ADDR_EXP 154
60669: PUSH
60670: LD_EXP 154
60674: PPUSH
60675: LD_VAR 0 4
60679: PPUSH
60680: EMPTY
60681: PPUSH
60682: CALL_OW 1
60686: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60687: LD_VAR 0 1
60691: PPUSH
60692: LD_INT 0
60694: PPUSH
60695: CALL_OW 505
// end ; end ;
60699: LD_VAR 0 2
60703: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60704: LD_INT 0
60706: PPUSH
60707: PPUSH
60708: PPUSH
// if not hack in hackTanks or not vehicles then
60709: LD_VAR 0 1
60713: PUSH
60714: LD_EXP 153
60718: IN
60719: NOT
60720: PUSH
60721: LD_VAR 0 2
60725: NOT
60726: OR
60727: IFFALSE 60731
// exit ;
60729: GO 61006
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60731: LD_ADDR_VAR 0 2
60735: PUSH
60736: LD_VAR 0 1
60740: PPUSH
60741: LD_VAR 0 2
60745: PPUSH
60746: LD_INT 1
60748: PPUSH
60749: LD_INT 1
60751: PPUSH
60752: CALL 68976 0 4
60756: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60757: LD_ADDR_VAR 0 5
60761: PUSH
60762: LD_EXP 153
60766: PPUSH
60767: LD_VAR 0 1
60771: PPUSH
60772: CALL 68326 0 2
60776: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60777: LD_EXP 154
60781: PUSH
60782: LD_VAR 0 5
60786: ARRAY
60787: PUSH
60788: LD_EXP 155
60792: LESS
60793: IFFALSE 60982
// begin for i := 1 to vehicles do
60795: LD_ADDR_VAR 0 4
60799: PUSH
60800: DOUBLE
60801: LD_INT 1
60803: DEC
60804: ST_TO_ADDR
60805: LD_VAR 0 2
60809: PUSH
60810: FOR_TO
60811: IFFALSE 60980
// begin if hackTanksCaptured [ index ] = hackLimit then
60813: LD_EXP 154
60817: PUSH
60818: LD_VAR 0 5
60822: ARRAY
60823: PUSH
60824: LD_EXP 155
60828: EQUAL
60829: IFFALSE 60833
// break ;
60831: GO 60980
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60833: LD_ADDR_EXP 157
60837: PUSH
60838: LD_EXP 157
60842: PPUSH
60843: LD_VAR 0 5
60847: PPUSH
60848: LD_EXP 157
60852: PUSH
60853: LD_VAR 0 5
60857: ARRAY
60858: PUSH
60859: LD_INT 1
60861: PLUS
60862: PPUSH
60863: CALL_OW 1
60867: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60868: LD_ADDR_EXP 154
60872: PUSH
60873: LD_EXP 154
60877: PPUSH
60878: LD_VAR 0 5
60882: PUSH
60883: LD_EXP 154
60887: PUSH
60888: LD_VAR 0 5
60892: ARRAY
60893: PUSH
60894: LD_INT 1
60896: PLUS
60897: PUSH
60898: EMPTY
60899: LIST
60900: LIST
60901: PPUSH
60902: LD_VAR 0 2
60906: PUSH
60907: LD_VAR 0 4
60911: ARRAY
60912: PUSH
60913: LD_VAR 0 2
60917: PUSH
60918: LD_VAR 0 4
60922: ARRAY
60923: PPUSH
60924: CALL_OW 255
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PPUSH
60933: CALL 68541 0 3
60937: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60938: LD_VAR 0 2
60942: PUSH
60943: LD_VAR 0 4
60947: ARRAY
60948: PPUSH
60949: LD_VAR 0 1
60953: PPUSH
60954: CALL_OW 255
60958: PPUSH
60959: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60963: LD_VAR 0 2
60967: PUSH
60968: LD_VAR 0 4
60972: ARRAY
60973: PPUSH
60974: CALL_OW 141
// end ;
60978: GO 60810
60980: POP
60981: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60982: LD_VAR 0 1
60986: PPUSH
60987: LD_EXP 154
60991: PUSH
60992: LD_VAR 0 5
60996: ARRAY
60997: PUSH
60998: LD_INT 0
61000: PLUS
61001: PPUSH
61002: CALL_OW 505
// end ;
61006: LD_VAR 0 3
61010: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
61011: LD_INT 0
61013: PPUSH
61014: PPUSH
61015: PPUSH
61016: PPUSH
// if not hack in hackTanks then
61017: LD_VAR 0 1
61021: PUSH
61022: LD_EXP 153
61026: IN
61027: NOT
61028: IFFALSE 61032
// exit ;
61030: GO 61272
// index := GetElementIndex ( hackTanks , hack ) ;
61032: LD_ADDR_VAR 0 4
61036: PUSH
61037: LD_EXP 153
61041: PPUSH
61042: LD_VAR 0 1
61046: PPUSH
61047: CALL 68326 0 2
61051: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
61052: LD_ADDR_VAR 0 3
61056: PUSH
61057: DOUBLE
61058: LD_EXP 154
61062: PUSH
61063: LD_VAR 0 4
61067: ARRAY
61068: INC
61069: ST_TO_ADDR
61070: LD_INT 1
61072: PUSH
61073: FOR_DOWNTO
61074: IFFALSE 61246
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
61076: LD_ADDR_VAR 0 5
61080: PUSH
61081: LD_EXP 154
61085: PUSH
61086: LD_VAR 0 4
61090: ARRAY
61091: PUSH
61092: LD_VAR 0 3
61096: ARRAY
61097: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
61098: LD_VAR 0 5
61102: PUSH
61103: LD_INT 1
61105: ARRAY
61106: PPUSH
61107: CALL_OW 302
61111: NOT
61112: PUSH
61113: LD_VAR 0 5
61117: PUSH
61118: LD_INT 1
61120: ARRAY
61121: PPUSH
61122: CALL_OW 255
61126: PUSH
61127: LD_VAR 0 1
61131: PPUSH
61132: CALL_OW 255
61136: NONEQUAL
61137: OR
61138: IFFALSE 61244
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
61140: LD_VAR 0 5
61144: PUSH
61145: LD_INT 1
61147: ARRAY
61148: PPUSH
61149: CALL_OW 305
61153: PUSH
61154: LD_VAR 0 5
61158: PUSH
61159: LD_INT 1
61161: ARRAY
61162: PPUSH
61163: CALL_OW 255
61167: PUSH
61168: LD_VAR 0 1
61172: PPUSH
61173: CALL_OW 255
61177: EQUAL
61178: AND
61179: IFFALSE 61203
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61181: LD_VAR 0 5
61185: PUSH
61186: LD_INT 1
61188: ARRAY
61189: PPUSH
61190: LD_VAR 0 5
61194: PUSH
61195: LD_INT 2
61197: ARRAY
61198: PPUSH
61199: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61203: LD_ADDR_EXP 154
61207: PUSH
61208: LD_EXP 154
61212: PPUSH
61213: LD_VAR 0 4
61217: PPUSH
61218: LD_EXP 154
61222: PUSH
61223: LD_VAR 0 4
61227: ARRAY
61228: PPUSH
61229: LD_VAR 0 3
61233: PPUSH
61234: CALL_OW 3
61238: PPUSH
61239: CALL_OW 1
61243: ST_TO_ADDR
// end ; end ;
61244: GO 61073
61246: POP
61247: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61248: LD_VAR 0 1
61252: PPUSH
61253: LD_EXP 154
61257: PUSH
61258: LD_VAR 0 4
61262: ARRAY
61263: PUSH
61264: LD_INT 0
61266: PLUS
61267: PPUSH
61268: CALL_OW 505
// end ;
61272: LD_VAR 0 2
61276: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61277: LD_INT 0
61279: PPUSH
61280: PPUSH
61281: PPUSH
61282: PPUSH
// if not hack in hackTanks then
61283: LD_VAR 0 1
61287: PUSH
61288: LD_EXP 153
61292: IN
61293: NOT
61294: IFFALSE 61298
// exit ;
61296: GO 61383
// index := GetElementIndex ( hackTanks , hack ) ;
61298: LD_ADDR_VAR 0 5
61302: PUSH
61303: LD_EXP 153
61307: PPUSH
61308: LD_VAR 0 1
61312: PPUSH
61313: CALL 68326 0 2
61317: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61318: LD_ADDR_VAR 0 4
61322: PUSH
61323: DOUBLE
61324: LD_INT 1
61326: DEC
61327: ST_TO_ADDR
61328: LD_EXP 154
61332: PUSH
61333: LD_VAR 0 5
61337: ARRAY
61338: PUSH
61339: FOR_TO
61340: IFFALSE 61381
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61342: LD_EXP 154
61346: PUSH
61347: LD_VAR 0 5
61351: ARRAY
61352: PUSH
61353: LD_VAR 0 4
61357: ARRAY
61358: PUSH
61359: LD_INT 1
61361: ARRAY
61362: PUSH
61363: LD_VAR 0 2
61367: EQUAL
61368: IFFALSE 61379
// KillUnit ( vehicle ) ;
61370: LD_VAR 0 2
61374: PPUSH
61375: CALL_OW 66
61379: GO 61339
61381: POP
61382: POP
// end ;
61383: LD_VAR 0 3
61387: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61388: LD_EXP 158
61392: NOT
61393: IFFALSE 61428
61395: GO 61397
61397: DISABLE
// begin initMiner := true ;
61398: LD_ADDR_EXP 158
61402: PUSH
61403: LD_INT 1
61405: ST_TO_ADDR
// minersList := [ ] ;
61406: LD_ADDR_EXP 159
61410: PUSH
61411: EMPTY
61412: ST_TO_ADDR
// minerMinesList := [ ] ;
61413: LD_ADDR_EXP 160
61417: PUSH
61418: EMPTY
61419: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61420: LD_ADDR_EXP 161
61424: PUSH
61425: LD_INT 5
61427: ST_TO_ADDR
// end ;
61428: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61429: LD_EXP 158
61433: PUSH
61434: LD_INT 34
61436: PUSH
61437: LD_EXP 80
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: PPUSH
61446: CALL_OW 69
61450: AND
61451: IFFALSE 61914
61453: GO 61455
61455: DISABLE
61456: LD_INT 0
61458: PPUSH
61459: PPUSH
61460: PPUSH
61461: PPUSH
// begin enable ;
61462: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61463: LD_ADDR_VAR 0 1
61467: PUSH
61468: LD_INT 34
61470: PUSH
61471: LD_EXP 80
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PPUSH
61480: CALL_OW 69
61484: PUSH
61485: FOR_IN
61486: IFFALSE 61558
// begin if not i in minersList then
61488: LD_VAR 0 1
61492: PUSH
61493: LD_EXP 159
61497: IN
61498: NOT
61499: IFFALSE 61556
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61501: LD_ADDR_EXP 159
61505: PUSH
61506: LD_EXP 159
61510: PPUSH
61511: LD_EXP 159
61515: PUSH
61516: LD_INT 1
61518: PLUS
61519: PPUSH
61520: LD_VAR 0 1
61524: PPUSH
61525: CALL_OW 1
61529: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61530: LD_ADDR_EXP 160
61534: PUSH
61535: LD_EXP 160
61539: PPUSH
61540: LD_EXP 160
61544: PUSH
61545: LD_INT 1
61547: PLUS
61548: PPUSH
61549: EMPTY
61550: PPUSH
61551: CALL_OW 1
61555: ST_TO_ADDR
// end end ;
61556: GO 61485
61558: POP
61559: POP
// for i := minerMinesList downto 1 do
61560: LD_ADDR_VAR 0 1
61564: PUSH
61565: DOUBLE
61566: LD_EXP 160
61570: INC
61571: ST_TO_ADDR
61572: LD_INT 1
61574: PUSH
61575: FOR_DOWNTO
61576: IFFALSE 61912
// begin if IsLive ( minersList [ i ] ) then
61578: LD_EXP 159
61582: PUSH
61583: LD_VAR 0 1
61587: ARRAY
61588: PPUSH
61589: CALL_OW 300
61593: IFFALSE 61621
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61595: LD_EXP 159
61599: PUSH
61600: LD_VAR 0 1
61604: ARRAY
61605: PPUSH
61606: LD_EXP 160
61610: PUSH
61611: LD_VAR 0 1
61615: ARRAY
61616: PPUSH
61617: CALL_OW 505
// if not minerMinesList [ i ] then
61621: LD_EXP 160
61625: PUSH
61626: LD_VAR 0 1
61630: ARRAY
61631: NOT
61632: IFFALSE 61636
// continue ;
61634: GO 61575
// for j := minerMinesList [ i ] downto 1 do
61636: LD_ADDR_VAR 0 2
61640: PUSH
61641: DOUBLE
61642: LD_EXP 160
61646: PUSH
61647: LD_VAR 0 1
61651: ARRAY
61652: INC
61653: ST_TO_ADDR
61654: LD_INT 1
61656: PUSH
61657: FOR_DOWNTO
61658: IFFALSE 61908
// begin side := GetSide ( minersList [ i ] ) ;
61660: LD_ADDR_VAR 0 3
61664: PUSH
61665: LD_EXP 159
61669: PUSH
61670: LD_VAR 0 1
61674: ARRAY
61675: PPUSH
61676: CALL_OW 255
61680: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61681: LD_ADDR_VAR 0 4
61685: PUSH
61686: LD_EXP 160
61690: PUSH
61691: LD_VAR 0 1
61695: ARRAY
61696: PUSH
61697: LD_VAR 0 2
61701: ARRAY
61702: PUSH
61703: LD_INT 1
61705: ARRAY
61706: PPUSH
61707: LD_EXP 160
61711: PUSH
61712: LD_VAR 0 1
61716: ARRAY
61717: PUSH
61718: LD_VAR 0 2
61722: ARRAY
61723: PUSH
61724: LD_INT 2
61726: ARRAY
61727: PPUSH
61728: CALL_OW 428
61732: ST_TO_ADDR
// if not tmp then
61733: LD_VAR 0 4
61737: NOT
61738: IFFALSE 61742
// continue ;
61740: GO 61657
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61742: LD_VAR 0 4
61746: PUSH
61747: LD_INT 81
61749: PUSH
61750: LD_VAR 0 3
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: PPUSH
61759: CALL_OW 69
61763: IN
61764: PUSH
61765: LD_EXP 160
61769: PUSH
61770: LD_VAR 0 1
61774: ARRAY
61775: PUSH
61776: LD_VAR 0 2
61780: ARRAY
61781: PUSH
61782: LD_INT 1
61784: ARRAY
61785: PPUSH
61786: LD_EXP 160
61790: PUSH
61791: LD_VAR 0 1
61795: ARRAY
61796: PUSH
61797: LD_VAR 0 2
61801: ARRAY
61802: PUSH
61803: LD_INT 2
61805: ARRAY
61806: PPUSH
61807: CALL_OW 458
61811: AND
61812: IFFALSE 61906
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61814: LD_EXP 160
61818: PUSH
61819: LD_VAR 0 1
61823: ARRAY
61824: PUSH
61825: LD_VAR 0 2
61829: ARRAY
61830: PUSH
61831: LD_INT 1
61833: ARRAY
61834: PPUSH
61835: LD_EXP 160
61839: PUSH
61840: LD_VAR 0 1
61844: ARRAY
61845: PUSH
61846: LD_VAR 0 2
61850: ARRAY
61851: PUSH
61852: LD_INT 2
61854: ARRAY
61855: PPUSH
61856: LD_VAR 0 3
61860: PPUSH
61861: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61865: LD_ADDR_EXP 160
61869: PUSH
61870: LD_EXP 160
61874: PPUSH
61875: LD_VAR 0 1
61879: PPUSH
61880: LD_EXP 160
61884: PUSH
61885: LD_VAR 0 1
61889: ARRAY
61890: PPUSH
61891: LD_VAR 0 2
61895: PPUSH
61896: CALL_OW 3
61900: PPUSH
61901: CALL_OW 1
61905: ST_TO_ADDR
// end ; end ;
61906: GO 61657
61908: POP
61909: POP
// end ;
61910: GO 61575
61912: POP
61913: POP
// end ;
61914: PPOPN 4
61916: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61917: LD_INT 0
61919: PPUSH
61920: PPUSH
// result := false ;
61921: LD_ADDR_VAR 0 4
61925: PUSH
61926: LD_INT 0
61928: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61929: LD_VAR 0 1
61933: PPUSH
61934: CALL_OW 264
61938: PUSH
61939: LD_EXP 80
61943: EQUAL
61944: NOT
61945: IFFALSE 61949
// exit ;
61947: GO 62189
// index := GetElementIndex ( minersList , unit ) ;
61949: LD_ADDR_VAR 0 5
61953: PUSH
61954: LD_EXP 159
61958: PPUSH
61959: LD_VAR 0 1
61963: PPUSH
61964: CALL 68326 0 2
61968: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61969: LD_EXP 160
61973: PUSH
61974: LD_VAR 0 5
61978: ARRAY
61979: PUSH
61980: LD_EXP 161
61984: GREATEREQUAL
61985: IFFALSE 61989
// exit ;
61987: GO 62189
// ComMoveXY ( unit , x , y ) ;
61989: LD_VAR 0 1
61993: PPUSH
61994: LD_VAR 0 2
61998: PPUSH
61999: LD_VAR 0 3
62003: PPUSH
62004: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62008: LD_INT 35
62010: PPUSH
62011: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
62015: LD_VAR 0 1
62019: PPUSH
62020: LD_VAR 0 2
62024: PPUSH
62025: LD_VAR 0 3
62029: PPUSH
62030: CALL 99612 0 3
62034: NOT
62035: PUSH
62036: LD_VAR 0 1
62040: PPUSH
62041: CALL_OW 314
62045: AND
62046: IFFALSE 62050
// exit ;
62048: GO 62189
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
62050: LD_VAR 0 2
62054: PPUSH
62055: LD_VAR 0 3
62059: PPUSH
62060: CALL_OW 428
62064: PUSH
62065: LD_VAR 0 1
62069: EQUAL
62070: PUSH
62071: LD_VAR 0 1
62075: PPUSH
62076: CALL_OW 314
62080: NOT
62081: AND
62082: IFFALSE 62008
// PlaySoundXY ( x , y , PlantMine ) ;
62084: LD_VAR 0 2
62088: PPUSH
62089: LD_VAR 0 3
62093: PPUSH
62094: LD_STRING PlantMine
62096: PPUSH
62097: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
62101: LD_VAR 0 2
62105: PPUSH
62106: LD_VAR 0 3
62110: PPUSH
62111: LD_VAR 0 1
62115: PPUSH
62116: CALL_OW 255
62120: PPUSH
62121: LD_INT 0
62123: PPUSH
62124: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
62128: LD_ADDR_EXP 160
62132: PUSH
62133: LD_EXP 160
62137: PPUSH
62138: LD_VAR 0 5
62142: PUSH
62143: LD_EXP 160
62147: PUSH
62148: LD_VAR 0 5
62152: ARRAY
62153: PUSH
62154: LD_INT 1
62156: PLUS
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PPUSH
62162: LD_VAR 0 2
62166: PUSH
62167: LD_VAR 0 3
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: PPUSH
62176: CALL 68541 0 3
62180: ST_TO_ADDR
// result := true ;
62181: LD_ADDR_VAR 0 4
62185: PUSH
62186: LD_INT 1
62188: ST_TO_ADDR
// end ;
62189: LD_VAR 0 4
62193: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62194: LD_INT 0
62196: PPUSH
62197: PPUSH
62198: PPUSH
// if not unit in minersList then
62199: LD_VAR 0 1
62203: PUSH
62204: LD_EXP 159
62208: IN
62209: NOT
62210: IFFALSE 62214
// exit ;
62212: GO 62606
// index := GetElementIndex ( minersList , unit ) ;
62214: LD_ADDR_VAR 0 6
62218: PUSH
62219: LD_EXP 159
62223: PPUSH
62224: LD_VAR 0 1
62228: PPUSH
62229: CALL 68326 0 2
62233: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62234: LD_ADDR_VAR 0 5
62238: PUSH
62239: DOUBLE
62240: LD_EXP 160
62244: PUSH
62245: LD_VAR 0 6
62249: ARRAY
62250: INC
62251: ST_TO_ADDR
62252: LD_INT 1
62254: PUSH
62255: FOR_DOWNTO
62256: IFFALSE 62417
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62258: LD_EXP 160
62262: PUSH
62263: LD_VAR 0 6
62267: ARRAY
62268: PUSH
62269: LD_VAR 0 5
62273: ARRAY
62274: PUSH
62275: LD_INT 1
62277: ARRAY
62278: PUSH
62279: LD_VAR 0 2
62283: EQUAL
62284: PUSH
62285: LD_EXP 160
62289: PUSH
62290: LD_VAR 0 6
62294: ARRAY
62295: PUSH
62296: LD_VAR 0 5
62300: ARRAY
62301: PUSH
62302: LD_INT 2
62304: ARRAY
62305: PUSH
62306: LD_VAR 0 3
62310: EQUAL
62311: AND
62312: IFFALSE 62415
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62314: LD_EXP 160
62318: PUSH
62319: LD_VAR 0 6
62323: ARRAY
62324: PUSH
62325: LD_VAR 0 5
62329: ARRAY
62330: PUSH
62331: LD_INT 1
62333: ARRAY
62334: PPUSH
62335: LD_EXP 160
62339: PUSH
62340: LD_VAR 0 6
62344: ARRAY
62345: PUSH
62346: LD_VAR 0 5
62350: ARRAY
62351: PUSH
62352: LD_INT 2
62354: ARRAY
62355: PPUSH
62356: LD_VAR 0 1
62360: PPUSH
62361: CALL_OW 255
62365: PPUSH
62366: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62370: LD_ADDR_EXP 160
62374: PUSH
62375: LD_EXP 160
62379: PPUSH
62380: LD_VAR 0 6
62384: PPUSH
62385: LD_EXP 160
62389: PUSH
62390: LD_VAR 0 6
62394: ARRAY
62395: PPUSH
62396: LD_VAR 0 5
62400: PPUSH
62401: CALL_OW 3
62405: PPUSH
62406: CALL_OW 1
62410: ST_TO_ADDR
// exit ;
62411: POP
62412: POP
62413: GO 62606
// end ; end ;
62415: GO 62255
62417: POP
62418: POP
// for i := minerMinesList [ index ] downto 1 do
62419: LD_ADDR_VAR 0 5
62423: PUSH
62424: DOUBLE
62425: LD_EXP 160
62429: PUSH
62430: LD_VAR 0 6
62434: ARRAY
62435: INC
62436: ST_TO_ADDR
62437: LD_INT 1
62439: PUSH
62440: FOR_DOWNTO
62441: IFFALSE 62604
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62443: LD_EXP 160
62447: PUSH
62448: LD_VAR 0 6
62452: ARRAY
62453: PUSH
62454: LD_VAR 0 5
62458: ARRAY
62459: PUSH
62460: LD_INT 1
62462: ARRAY
62463: PPUSH
62464: LD_EXP 160
62468: PUSH
62469: LD_VAR 0 6
62473: ARRAY
62474: PUSH
62475: LD_VAR 0 5
62479: ARRAY
62480: PUSH
62481: LD_INT 2
62483: ARRAY
62484: PPUSH
62485: LD_VAR 0 2
62489: PPUSH
62490: LD_VAR 0 3
62494: PPUSH
62495: CALL_OW 298
62499: PUSH
62500: LD_INT 6
62502: LESS
62503: IFFALSE 62602
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62505: LD_EXP 160
62509: PUSH
62510: LD_VAR 0 6
62514: ARRAY
62515: PUSH
62516: LD_VAR 0 5
62520: ARRAY
62521: PUSH
62522: LD_INT 1
62524: ARRAY
62525: PPUSH
62526: LD_EXP 160
62530: PUSH
62531: LD_VAR 0 6
62535: ARRAY
62536: PUSH
62537: LD_VAR 0 5
62541: ARRAY
62542: PUSH
62543: LD_INT 2
62545: ARRAY
62546: PPUSH
62547: LD_VAR 0 1
62551: PPUSH
62552: CALL_OW 255
62556: PPUSH
62557: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62561: LD_ADDR_EXP 160
62565: PUSH
62566: LD_EXP 160
62570: PPUSH
62571: LD_VAR 0 6
62575: PPUSH
62576: LD_EXP 160
62580: PUSH
62581: LD_VAR 0 6
62585: ARRAY
62586: PPUSH
62587: LD_VAR 0 5
62591: PPUSH
62592: CALL_OW 3
62596: PPUSH
62597: CALL_OW 1
62601: ST_TO_ADDR
// end ; end ;
62602: GO 62440
62604: POP
62605: POP
// end ;
62606: LD_VAR 0 4
62610: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62611: LD_INT 0
62613: PPUSH
62614: PPUSH
62615: PPUSH
62616: PPUSH
62617: PPUSH
62618: PPUSH
62619: PPUSH
62620: PPUSH
62621: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62622: LD_VAR 0 1
62626: PPUSH
62627: CALL_OW 264
62631: PUSH
62632: LD_EXP 80
62636: EQUAL
62637: NOT
62638: PUSH
62639: LD_VAR 0 1
62643: PUSH
62644: LD_EXP 159
62648: IN
62649: NOT
62650: OR
62651: IFFALSE 62655
// exit ;
62653: GO 62977
// index := GetElementIndex ( minersList , unit ) ;
62655: LD_ADDR_VAR 0 6
62659: PUSH
62660: LD_EXP 159
62664: PPUSH
62665: LD_VAR 0 1
62669: PPUSH
62670: CALL 68326 0 2
62674: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62675: LD_ADDR_VAR 0 8
62679: PUSH
62680: LD_EXP 161
62684: PUSH
62685: LD_EXP 160
62689: PUSH
62690: LD_VAR 0 6
62694: ARRAY
62695: MINUS
62696: ST_TO_ADDR
// if not minesFreeAmount then
62697: LD_VAR 0 8
62701: NOT
62702: IFFALSE 62706
// exit ;
62704: GO 62977
// tmp := [ ] ;
62706: LD_ADDR_VAR 0 7
62710: PUSH
62711: EMPTY
62712: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62713: LD_ADDR_VAR 0 5
62717: PUSH
62718: DOUBLE
62719: LD_INT 1
62721: DEC
62722: ST_TO_ADDR
62723: LD_VAR 0 8
62727: PUSH
62728: FOR_TO
62729: IFFALSE 62924
// begin _d := rand ( 0 , 5 ) ;
62731: LD_ADDR_VAR 0 11
62735: PUSH
62736: LD_INT 0
62738: PPUSH
62739: LD_INT 5
62741: PPUSH
62742: CALL_OW 12
62746: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62747: LD_ADDR_VAR 0 12
62751: PUSH
62752: LD_INT 2
62754: PPUSH
62755: LD_INT 6
62757: PPUSH
62758: CALL_OW 12
62762: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62763: LD_ADDR_VAR 0 9
62767: PUSH
62768: LD_VAR 0 2
62772: PPUSH
62773: LD_VAR 0 11
62777: PPUSH
62778: LD_VAR 0 12
62782: PPUSH
62783: CALL_OW 272
62787: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62788: LD_ADDR_VAR 0 10
62792: PUSH
62793: LD_VAR 0 3
62797: PPUSH
62798: LD_VAR 0 11
62802: PPUSH
62803: LD_VAR 0 12
62807: PPUSH
62808: CALL_OW 273
62812: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62813: LD_VAR 0 9
62817: PPUSH
62818: LD_VAR 0 10
62822: PPUSH
62823: CALL_OW 488
62827: PUSH
62828: LD_VAR 0 9
62832: PUSH
62833: LD_VAR 0 10
62837: PUSH
62838: EMPTY
62839: LIST
62840: LIST
62841: PUSH
62842: LD_VAR 0 7
62846: IN
62847: NOT
62848: AND
62849: PUSH
62850: LD_VAR 0 9
62854: PPUSH
62855: LD_VAR 0 10
62859: PPUSH
62860: CALL_OW 458
62864: NOT
62865: AND
62866: IFFALSE 62908
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62868: LD_ADDR_VAR 0 7
62872: PUSH
62873: LD_VAR 0 7
62877: PPUSH
62878: LD_VAR 0 7
62882: PUSH
62883: LD_INT 1
62885: PLUS
62886: PPUSH
62887: LD_VAR 0 9
62891: PUSH
62892: LD_VAR 0 10
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PPUSH
62901: CALL_OW 1
62905: ST_TO_ADDR
62906: GO 62922
// i := i - 1 ;
62908: LD_ADDR_VAR 0 5
62912: PUSH
62913: LD_VAR 0 5
62917: PUSH
62918: LD_INT 1
62920: MINUS
62921: ST_TO_ADDR
// end ;
62922: GO 62728
62924: POP
62925: POP
// for i in tmp do
62926: LD_ADDR_VAR 0 5
62930: PUSH
62931: LD_VAR 0 7
62935: PUSH
62936: FOR_IN
62937: IFFALSE 62975
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62939: LD_VAR 0 1
62943: PPUSH
62944: LD_VAR 0 5
62948: PUSH
62949: LD_INT 1
62951: ARRAY
62952: PPUSH
62953: LD_VAR 0 5
62957: PUSH
62958: LD_INT 2
62960: ARRAY
62961: PPUSH
62962: CALL 61917 0 3
62966: NOT
62967: IFFALSE 62973
// exit ;
62969: POP
62970: POP
62971: GO 62977
62973: GO 62936
62975: POP
62976: POP
// end ;
62977: LD_VAR 0 4
62981: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62982: LD_INT 0
62984: PPUSH
62985: PPUSH
62986: PPUSH
62987: PPUSH
62988: PPUSH
62989: PPUSH
62990: PPUSH
// if not GetClass ( unit ) = class_sniper then
62991: LD_VAR 0 1
62995: PPUSH
62996: CALL_OW 257
63000: PUSH
63001: LD_INT 5
63003: EQUAL
63004: NOT
63005: IFFALSE 63009
// exit ;
63007: GO 63397
// dist := 8 ;
63009: LD_ADDR_VAR 0 5
63013: PUSH
63014: LD_INT 8
63016: ST_TO_ADDR
// viewRange := 12 ;
63017: LD_ADDR_VAR 0 7
63021: PUSH
63022: LD_INT 12
63024: ST_TO_ADDR
// side := GetSide ( unit ) ;
63025: LD_ADDR_VAR 0 6
63029: PUSH
63030: LD_VAR 0 1
63034: PPUSH
63035: CALL_OW 255
63039: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
63040: LD_INT 61
63042: PPUSH
63043: LD_VAR 0 6
63047: PPUSH
63048: CALL_OW 321
63052: PUSH
63053: LD_INT 2
63055: EQUAL
63056: IFFALSE 63066
// viewRange := 16 ;
63058: LD_ADDR_VAR 0 7
63062: PUSH
63063: LD_INT 16
63065: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
63066: LD_VAR 0 1
63070: PPUSH
63071: LD_VAR 0 2
63075: PPUSH
63076: LD_VAR 0 3
63080: PPUSH
63081: CALL_OW 297
63085: PUSH
63086: LD_VAR 0 5
63090: GREATER
63091: IFFALSE 63170
// begin ComMoveXY ( unit , x , y ) ;
63093: LD_VAR 0 1
63097: PPUSH
63098: LD_VAR 0 2
63102: PPUSH
63103: LD_VAR 0 3
63107: PPUSH
63108: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
63112: LD_INT 35
63114: PPUSH
63115: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
63119: LD_VAR 0 1
63123: PPUSH
63124: LD_VAR 0 2
63128: PPUSH
63129: LD_VAR 0 3
63133: PPUSH
63134: CALL 99612 0 3
63138: NOT
63139: IFFALSE 63143
// exit ;
63141: GO 63397
// until GetDistUnitXY ( unit , x , y ) < dist ;
63143: LD_VAR 0 1
63147: PPUSH
63148: LD_VAR 0 2
63152: PPUSH
63153: LD_VAR 0 3
63157: PPUSH
63158: CALL_OW 297
63162: PUSH
63163: LD_VAR 0 5
63167: LESS
63168: IFFALSE 63112
// end ; ComTurnXY ( unit , x , y ) ;
63170: LD_VAR 0 1
63174: PPUSH
63175: LD_VAR 0 2
63179: PPUSH
63180: LD_VAR 0 3
63184: PPUSH
63185: CALL_OW 118
// wait ( 5 ) ;
63189: LD_INT 5
63191: PPUSH
63192: CALL_OW 67
// _d := GetDir ( unit ) ;
63196: LD_ADDR_VAR 0 10
63200: PUSH
63201: LD_VAR 0 1
63205: PPUSH
63206: CALL_OW 254
63210: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63211: LD_ADDR_VAR 0 8
63215: PUSH
63216: LD_VAR 0 1
63220: PPUSH
63221: CALL_OW 250
63225: PPUSH
63226: LD_VAR 0 10
63230: PPUSH
63231: LD_VAR 0 5
63235: PPUSH
63236: CALL_OW 272
63240: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63241: LD_ADDR_VAR 0 9
63245: PUSH
63246: LD_VAR 0 1
63250: PPUSH
63251: CALL_OW 251
63255: PPUSH
63256: LD_VAR 0 10
63260: PPUSH
63261: LD_VAR 0 5
63265: PPUSH
63266: CALL_OW 273
63270: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63271: LD_VAR 0 8
63275: PPUSH
63276: LD_VAR 0 9
63280: PPUSH
63281: CALL_OW 488
63285: NOT
63286: IFFALSE 63290
// exit ;
63288: GO 63397
// ComAnimCustom ( unit , 1 ) ;
63290: LD_VAR 0 1
63294: PPUSH
63295: LD_INT 1
63297: PPUSH
63298: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63302: LD_VAR 0 8
63306: PPUSH
63307: LD_VAR 0 9
63311: PPUSH
63312: LD_VAR 0 6
63316: PPUSH
63317: LD_VAR 0 7
63321: PPUSH
63322: CALL_OW 330
// repeat wait ( 1 ) ;
63326: LD_INT 1
63328: PPUSH
63329: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63333: LD_VAR 0 1
63337: PPUSH
63338: CALL_OW 316
63342: PUSH
63343: LD_VAR 0 1
63347: PPUSH
63348: CALL_OW 314
63352: OR
63353: PUSH
63354: LD_VAR 0 1
63358: PPUSH
63359: CALL_OW 302
63363: NOT
63364: OR
63365: PUSH
63366: LD_VAR 0 1
63370: PPUSH
63371: CALL_OW 301
63375: OR
63376: IFFALSE 63326
// RemoveSeeing ( _x , _y , side ) ;
63378: LD_VAR 0 8
63382: PPUSH
63383: LD_VAR 0 9
63387: PPUSH
63388: LD_VAR 0 6
63392: PPUSH
63393: CALL_OW 331
// end ; end_of_file
63397: LD_VAR 0 4
63401: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63402: LD_INT 0
63404: PPUSH
63405: PPUSH
// if exist_mode then
63406: LD_VAR 0 2
63410: IFFALSE 63435
// unit := CreateCharacter ( prefix & ident ) else
63412: LD_ADDR_VAR 0 5
63416: PUSH
63417: LD_VAR 0 3
63421: PUSH
63422: LD_VAR 0 1
63426: STR
63427: PPUSH
63428: CALL_OW 34
63432: ST_TO_ADDR
63433: GO 63450
// unit := NewCharacter ( ident ) ;
63435: LD_ADDR_VAR 0 5
63439: PUSH
63440: LD_VAR 0 1
63444: PPUSH
63445: CALL_OW 25
63449: ST_TO_ADDR
// result := unit ;
63450: LD_ADDR_VAR 0 4
63454: PUSH
63455: LD_VAR 0 5
63459: ST_TO_ADDR
// end ;
63460: LD_VAR 0 4
63464: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63465: LD_INT 0
63467: PPUSH
63468: PPUSH
// if not side or not nation then
63469: LD_VAR 0 1
63473: NOT
63474: PUSH
63475: LD_VAR 0 2
63479: NOT
63480: OR
63481: IFFALSE 63485
// exit ;
63483: GO 64253
// case nation of nation_american :
63485: LD_VAR 0 2
63489: PUSH
63490: LD_INT 1
63492: DOUBLE
63493: EQUAL
63494: IFTRUE 63498
63496: GO 63712
63498: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63499: LD_ADDR_VAR 0 4
63503: PUSH
63504: LD_INT 35
63506: PUSH
63507: LD_INT 45
63509: PUSH
63510: LD_INT 46
63512: PUSH
63513: LD_INT 47
63515: PUSH
63516: LD_INT 82
63518: PUSH
63519: LD_INT 83
63521: PUSH
63522: LD_INT 84
63524: PUSH
63525: LD_INT 85
63527: PUSH
63528: LD_INT 86
63530: PUSH
63531: LD_INT 1
63533: PUSH
63534: LD_INT 2
63536: PUSH
63537: LD_INT 6
63539: PUSH
63540: LD_INT 15
63542: PUSH
63543: LD_INT 16
63545: PUSH
63546: LD_INT 7
63548: PUSH
63549: LD_INT 12
63551: PUSH
63552: LD_INT 13
63554: PUSH
63555: LD_INT 10
63557: PUSH
63558: LD_INT 14
63560: PUSH
63561: LD_INT 20
63563: PUSH
63564: LD_INT 21
63566: PUSH
63567: LD_INT 22
63569: PUSH
63570: LD_INT 25
63572: PUSH
63573: LD_INT 32
63575: PUSH
63576: LD_INT 27
63578: PUSH
63579: LD_INT 36
63581: PUSH
63582: LD_INT 69
63584: PUSH
63585: LD_INT 39
63587: PUSH
63588: LD_INT 34
63590: PUSH
63591: LD_INT 40
63593: PUSH
63594: LD_INT 48
63596: PUSH
63597: LD_INT 49
63599: PUSH
63600: LD_INT 50
63602: PUSH
63603: LD_INT 51
63605: PUSH
63606: LD_INT 52
63608: PUSH
63609: LD_INT 53
63611: PUSH
63612: LD_INT 54
63614: PUSH
63615: LD_INT 55
63617: PUSH
63618: LD_INT 56
63620: PUSH
63621: LD_INT 57
63623: PUSH
63624: LD_INT 58
63626: PUSH
63627: LD_INT 59
63629: PUSH
63630: LD_INT 60
63632: PUSH
63633: LD_INT 61
63635: PUSH
63636: LD_INT 62
63638: PUSH
63639: LD_INT 80
63641: PUSH
63642: LD_INT 82
63644: PUSH
63645: LD_INT 83
63647: PUSH
63648: LD_INT 84
63650: PUSH
63651: LD_INT 85
63653: PUSH
63654: LD_INT 86
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: LIST
63665: LIST
63666: LIST
63667: LIST
63668: LIST
63669: LIST
63670: LIST
63671: LIST
63672: LIST
63673: LIST
63674: LIST
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: LIST
63683: LIST
63684: LIST
63685: LIST
63686: LIST
63687: LIST
63688: LIST
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: LIST
63706: LIST
63707: LIST
63708: LIST
63709: ST_TO_ADDR
63710: GO 64177
63712: LD_INT 2
63714: DOUBLE
63715: EQUAL
63716: IFTRUE 63720
63718: GO 63946
63720: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
63721: LD_ADDR_VAR 0 4
63725: PUSH
63726: LD_INT 35
63728: PUSH
63729: LD_INT 45
63731: PUSH
63732: LD_INT 46
63734: PUSH
63735: LD_INT 47
63737: PUSH
63738: LD_INT 82
63740: PUSH
63741: LD_INT 83
63743: PUSH
63744: LD_INT 84
63746: PUSH
63747: LD_INT 85
63749: PUSH
63750: LD_INT 87
63752: PUSH
63753: LD_INT 70
63755: PUSH
63756: LD_INT 1
63758: PUSH
63759: LD_INT 11
63761: PUSH
63762: LD_INT 3
63764: PUSH
63765: LD_INT 4
63767: PUSH
63768: LD_INT 5
63770: PUSH
63771: LD_INT 6
63773: PUSH
63774: LD_INT 15
63776: PUSH
63777: LD_INT 18
63779: PUSH
63780: LD_INT 7
63782: PUSH
63783: LD_INT 17
63785: PUSH
63786: LD_INT 8
63788: PUSH
63789: LD_INT 20
63791: PUSH
63792: LD_INT 21
63794: PUSH
63795: LD_INT 22
63797: PUSH
63798: LD_INT 72
63800: PUSH
63801: LD_INT 26
63803: PUSH
63804: LD_INT 69
63806: PUSH
63807: LD_INT 39
63809: PUSH
63810: LD_INT 40
63812: PUSH
63813: LD_INT 41
63815: PUSH
63816: LD_INT 42
63818: PUSH
63819: LD_INT 43
63821: PUSH
63822: LD_INT 48
63824: PUSH
63825: LD_INT 49
63827: PUSH
63828: LD_INT 50
63830: PUSH
63831: LD_INT 51
63833: PUSH
63834: LD_INT 52
63836: PUSH
63837: LD_INT 53
63839: PUSH
63840: LD_INT 54
63842: PUSH
63843: LD_INT 55
63845: PUSH
63846: LD_INT 56
63848: PUSH
63849: LD_INT 60
63851: PUSH
63852: LD_INT 61
63854: PUSH
63855: LD_INT 62
63857: PUSH
63858: LD_INT 66
63860: PUSH
63861: LD_INT 67
63863: PUSH
63864: LD_INT 68
63866: PUSH
63867: LD_INT 81
63869: PUSH
63870: LD_INT 82
63872: PUSH
63873: LD_INT 83
63875: PUSH
63876: LD_INT 84
63878: PUSH
63879: LD_INT 85
63881: PUSH
63882: LD_INT 87
63884: PUSH
63885: LD_INT 88
63887: PUSH
63888: EMPTY
63889: LIST
63890: LIST
63891: LIST
63892: LIST
63893: LIST
63894: LIST
63895: LIST
63896: LIST
63897: LIST
63898: LIST
63899: LIST
63900: LIST
63901: LIST
63902: LIST
63903: LIST
63904: LIST
63905: LIST
63906: LIST
63907: LIST
63908: LIST
63909: LIST
63910: LIST
63911: LIST
63912: LIST
63913: LIST
63914: LIST
63915: LIST
63916: LIST
63917: LIST
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: ST_TO_ADDR
63944: GO 64177
63946: LD_INT 3
63948: DOUBLE
63949: EQUAL
63950: IFTRUE 63954
63952: GO 64176
63954: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
63955: LD_ADDR_VAR 0 4
63959: PUSH
63960: LD_INT 46
63962: PUSH
63963: LD_INT 47
63965: PUSH
63966: LD_INT 1
63968: PUSH
63969: LD_INT 2
63971: PUSH
63972: LD_INT 82
63974: PUSH
63975: LD_INT 83
63977: PUSH
63978: LD_INT 84
63980: PUSH
63981: LD_INT 85
63983: PUSH
63984: LD_INT 86
63986: PUSH
63987: LD_INT 11
63989: PUSH
63990: LD_INT 9
63992: PUSH
63993: LD_INT 20
63995: PUSH
63996: LD_INT 19
63998: PUSH
63999: LD_INT 21
64001: PUSH
64002: LD_INT 24
64004: PUSH
64005: LD_INT 22
64007: PUSH
64008: LD_INT 25
64010: PUSH
64011: LD_INT 28
64013: PUSH
64014: LD_INT 29
64016: PUSH
64017: LD_INT 30
64019: PUSH
64020: LD_INT 31
64022: PUSH
64023: LD_INT 37
64025: PUSH
64026: LD_INT 38
64028: PUSH
64029: LD_INT 32
64031: PUSH
64032: LD_INT 27
64034: PUSH
64035: LD_INT 33
64037: PUSH
64038: LD_INT 69
64040: PUSH
64041: LD_INT 39
64043: PUSH
64044: LD_INT 34
64046: PUSH
64047: LD_INT 40
64049: PUSH
64050: LD_INT 71
64052: PUSH
64053: LD_INT 23
64055: PUSH
64056: LD_INT 44
64058: PUSH
64059: LD_INT 48
64061: PUSH
64062: LD_INT 49
64064: PUSH
64065: LD_INT 50
64067: PUSH
64068: LD_INT 51
64070: PUSH
64071: LD_INT 52
64073: PUSH
64074: LD_INT 53
64076: PUSH
64077: LD_INT 54
64079: PUSH
64080: LD_INT 55
64082: PUSH
64083: LD_INT 56
64085: PUSH
64086: LD_INT 57
64088: PUSH
64089: LD_INT 58
64091: PUSH
64092: LD_INT 59
64094: PUSH
64095: LD_INT 63
64097: PUSH
64098: LD_INT 64
64100: PUSH
64101: LD_INT 65
64103: PUSH
64104: LD_INT 82
64106: PUSH
64107: LD_INT 83
64109: PUSH
64110: LD_INT 84
64112: PUSH
64113: LD_INT 85
64115: PUSH
64116: LD_INT 86
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: LIST
64149: LIST
64150: LIST
64151: LIST
64152: LIST
64153: LIST
64154: LIST
64155: LIST
64156: LIST
64157: LIST
64158: LIST
64159: LIST
64160: LIST
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: LIST
64166: LIST
64167: LIST
64168: LIST
64169: LIST
64170: LIST
64171: LIST
64172: LIST
64173: ST_TO_ADDR
64174: GO 64177
64176: POP
// if state > - 1 and state < 3 then
64177: LD_VAR 0 3
64181: PUSH
64182: LD_INT 1
64184: NEG
64185: GREATER
64186: PUSH
64187: LD_VAR 0 3
64191: PUSH
64192: LD_INT 3
64194: LESS
64195: AND
64196: IFFALSE 64253
// for i in result do
64198: LD_ADDR_VAR 0 5
64202: PUSH
64203: LD_VAR 0 4
64207: PUSH
64208: FOR_IN
64209: IFFALSE 64251
// if GetTech ( i , side ) <> state then
64211: LD_VAR 0 5
64215: PPUSH
64216: LD_VAR 0 1
64220: PPUSH
64221: CALL_OW 321
64225: PUSH
64226: LD_VAR 0 3
64230: NONEQUAL
64231: IFFALSE 64249
// result := result diff i ;
64233: LD_ADDR_VAR 0 4
64237: PUSH
64238: LD_VAR 0 4
64242: PUSH
64243: LD_VAR 0 5
64247: DIFF
64248: ST_TO_ADDR
64249: GO 64208
64251: POP
64252: POP
// end ;
64253: LD_VAR 0 4
64257: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64258: LD_INT 0
64260: PPUSH
64261: PPUSH
64262: PPUSH
// result := true ;
64263: LD_ADDR_VAR 0 3
64267: PUSH
64268: LD_INT 1
64270: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64271: LD_ADDR_VAR 0 5
64275: PUSH
64276: LD_VAR 0 2
64280: PPUSH
64281: CALL_OW 480
64285: ST_TO_ADDR
// if not tmp then
64286: LD_VAR 0 5
64290: NOT
64291: IFFALSE 64295
// exit ;
64293: GO 64344
// for i in tmp do
64295: LD_ADDR_VAR 0 4
64299: PUSH
64300: LD_VAR 0 5
64304: PUSH
64305: FOR_IN
64306: IFFALSE 64342
// if GetTech ( i , side ) <> state_researched then
64308: LD_VAR 0 4
64312: PPUSH
64313: LD_VAR 0 1
64317: PPUSH
64318: CALL_OW 321
64322: PUSH
64323: LD_INT 2
64325: NONEQUAL
64326: IFFALSE 64340
// begin result := false ;
64328: LD_ADDR_VAR 0 3
64332: PUSH
64333: LD_INT 0
64335: ST_TO_ADDR
// exit ;
64336: POP
64337: POP
64338: GO 64344
// end ;
64340: GO 64305
64342: POP
64343: POP
// end ;
64344: LD_VAR 0 3
64348: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64349: LD_INT 0
64351: PPUSH
64352: PPUSH
64353: PPUSH
64354: PPUSH
64355: PPUSH
64356: PPUSH
64357: PPUSH
64358: PPUSH
64359: PPUSH
64360: PPUSH
64361: PPUSH
64362: PPUSH
64363: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64364: LD_VAR 0 1
64368: NOT
64369: PUSH
64370: LD_VAR 0 1
64374: PPUSH
64375: CALL_OW 257
64379: PUSH
64380: LD_INT 9
64382: NONEQUAL
64383: OR
64384: IFFALSE 64388
// exit ;
64386: GO 64961
// side := GetSide ( unit ) ;
64388: LD_ADDR_VAR 0 9
64392: PUSH
64393: LD_VAR 0 1
64397: PPUSH
64398: CALL_OW 255
64402: ST_TO_ADDR
// tech_space := tech_spacanom ;
64403: LD_ADDR_VAR 0 12
64407: PUSH
64408: LD_INT 29
64410: ST_TO_ADDR
// tech_time := tech_taurad ;
64411: LD_ADDR_VAR 0 13
64415: PUSH
64416: LD_INT 28
64418: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64419: LD_ADDR_VAR 0 11
64423: PUSH
64424: LD_VAR 0 1
64428: PPUSH
64429: CALL_OW 310
64433: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64434: LD_VAR 0 11
64438: PPUSH
64439: CALL_OW 247
64443: PUSH
64444: LD_INT 2
64446: EQUAL
64447: IFFALSE 64451
// exit ;
64449: GO 64961
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64451: LD_ADDR_VAR 0 8
64455: PUSH
64456: LD_INT 81
64458: PUSH
64459: LD_VAR 0 9
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: PUSH
64468: LD_INT 3
64470: PUSH
64471: LD_INT 21
64473: PUSH
64474: LD_INT 3
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: PPUSH
64489: CALL_OW 69
64493: ST_TO_ADDR
// if not tmp then
64494: LD_VAR 0 8
64498: NOT
64499: IFFALSE 64503
// exit ;
64501: GO 64961
// if in_unit then
64503: LD_VAR 0 11
64507: IFFALSE 64531
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64509: LD_ADDR_VAR 0 10
64513: PUSH
64514: LD_VAR 0 8
64518: PPUSH
64519: LD_VAR 0 11
64523: PPUSH
64524: CALL_OW 74
64528: ST_TO_ADDR
64529: GO 64551
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64531: LD_ADDR_VAR 0 10
64535: PUSH
64536: LD_VAR 0 8
64540: PPUSH
64541: LD_VAR 0 1
64545: PPUSH
64546: CALL_OW 74
64550: ST_TO_ADDR
// if not enemy then
64551: LD_VAR 0 10
64555: NOT
64556: IFFALSE 64560
// exit ;
64558: GO 64961
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64560: LD_VAR 0 11
64564: PUSH
64565: LD_VAR 0 11
64569: PPUSH
64570: LD_VAR 0 10
64574: PPUSH
64575: CALL_OW 296
64579: PUSH
64580: LD_INT 13
64582: GREATER
64583: AND
64584: PUSH
64585: LD_VAR 0 1
64589: PPUSH
64590: LD_VAR 0 10
64594: PPUSH
64595: CALL_OW 296
64599: PUSH
64600: LD_INT 12
64602: GREATER
64603: OR
64604: IFFALSE 64608
// exit ;
64606: GO 64961
// missile := [ 1 ] ;
64608: LD_ADDR_VAR 0 14
64612: PUSH
64613: LD_INT 1
64615: PUSH
64616: EMPTY
64617: LIST
64618: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64619: LD_VAR 0 9
64623: PPUSH
64624: LD_VAR 0 12
64628: PPUSH
64629: CALL_OW 325
64633: IFFALSE 64662
// missile := Replace ( missile , missile + 1 , 2 ) ;
64635: LD_ADDR_VAR 0 14
64639: PUSH
64640: LD_VAR 0 14
64644: PPUSH
64645: LD_VAR 0 14
64649: PUSH
64650: LD_INT 1
64652: PLUS
64653: PPUSH
64654: LD_INT 2
64656: PPUSH
64657: CALL_OW 1
64661: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64662: LD_VAR 0 9
64666: PPUSH
64667: LD_VAR 0 13
64671: PPUSH
64672: CALL_OW 325
64676: PUSH
64677: LD_VAR 0 10
64681: PPUSH
64682: CALL_OW 255
64686: PPUSH
64687: LD_VAR 0 13
64691: PPUSH
64692: CALL_OW 325
64696: NOT
64697: AND
64698: IFFALSE 64727
// missile := Replace ( missile , missile + 1 , 3 ) ;
64700: LD_ADDR_VAR 0 14
64704: PUSH
64705: LD_VAR 0 14
64709: PPUSH
64710: LD_VAR 0 14
64714: PUSH
64715: LD_INT 1
64717: PLUS
64718: PPUSH
64719: LD_INT 3
64721: PPUSH
64722: CALL_OW 1
64726: ST_TO_ADDR
// if missile < 2 then
64727: LD_VAR 0 14
64731: PUSH
64732: LD_INT 2
64734: LESS
64735: IFFALSE 64739
// exit ;
64737: GO 64961
// x := GetX ( enemy ) ;
64739: LD_ADDR_VAR 0 4
64743: PUSH
64744: LD_VAR 0 10
64748: PPUSH
64749: CALL_OW 250
64753: ST_TO_ADDR
// y := GetY ( enemy ) ;
64754: LD_ADDR_VAR 0 5
64758: PUSH
64759: LD_VAR 0 10
64763: PPUSH
64764: CALL_OW 251
64768: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64769: LD_ADDR_VAR 0 6
64773: PUSH
64774: LD_VAR 0 4
64778: PUSH
64779: LD_INT 1
64781: NEG
64782: PPUSH
64783: LD_INT 1
64785: PPUSH
64786: CALL_OW 12
64790: PLUS
64791: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64792: LD_ADDR_VAR 0 7
64796: PUSH
64797: LD_VAR 0 5
64801: PUSH
64802: LD_INT 1
64804: NEG
64805: PPUSH
64806: LD_INT 1
64808: PPUSH
64809: CALL_OW 12
64813: PLUS
64814: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64815: LD_VAR 0 6
64819: PPUSH
64820: LD_VAR 0 7
64824: PPUSH
64825: CALL_OW 488
64829: NOT
64830: IFFALSE 64852
// begin _x := x ;
64832: LD_ADDR_VAR 0 6
64836: PUSH
64837: LD_VAR 0 4
64841: ST_TO_ADDR
// _y := y ;
64842: LD_ADDR_VAR 0 7
64846: PUSH
64847: LD_VAR 0 5
64851: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64852: LD_ADDR_VAR 0 3
64856: PUSH
64857: LD_INT 1
64859: PPUSH
64860: LD_VAR 0 14
64864: PPUSH
64865: CALL_OW 12
64869: ST_TO_ADDR
// case i of 1 :
64870: LD_VAR 0 3
64874: PUSH
64875: LD_INT 1
64877: DOUBLE
64878: EQUAL
64879: IFTRUE 64883
64881: GO 64900
64883: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64884: LD_VAR 0 1
64888: PPUSH
64889: LD_VAR 0 10
64893: PPUSH
64894: CALL_OW 115
64898: GO 64961
64900: LD_INT 2
64902: DOUBLE
64903: EQUAL
64904: IFTRUE 64908
64906: GO 64930
64908: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64909: LD_VAR 0 1
64913: PPUSH
64914: LD_VAR 0 6
64918: PPUSH
64919: LD_VAR 0 7
64923: PPUSH
64924: CALL_OW 153
64928: GO 64961
64930: LD_INT 3
64932: DOUBLE
64933: EQUAL
64934: IFTRUE 64938
64936: GO 64960
64938: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64939: LD_VAR 0 1
64943: PPUSH
64944: LD_VAR 0 6
64948: PPUSH
64949: LD_VAR 0 7
64953: PPUSH
64954: CALL_OW 154
64958: GO 64961
64960: POP
// end ;
64961: LD_VAR 0 2
64965: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64966: LD_INT 0
64968: PPUSH
64969: PPUSH
64970: PPUSH
64971: PPUSH
64972: PPUSH
64973: PPUSH
// if not unit or not building then
64974: LD_VAR 0 1
64978: NOT
64979: PUSH
64980: LD_VAR 0 2
64984: NOT
64985: OR
64986: IFFALSE 64990
// exit ;
64988: GO 65148
// x := GetX ( building ) ;
64990: LD_ADDR_VAR 0 5
64994: PUSH
64995: LD_VAR 0 2
64999: PPUSH
65000: CALL_OW 250
65004: ST_TO_ADDR
// y := GetY ( building ) ;
65005: LD_ADDR_VAR 0 6
65009: PUSH
65010: LD_VAR 0 2
65014: PPUSH
65015: CALL_OW 251
65019: ST_TO_ADDR
// for i = 0 to 5 do
65020: LD_ADDR_VAR 0 4
65024: PUSH
65025: DOUBLE
65026: LD_INT 0
65028: DEC
65029: ST_TO_ADDR
65030: LD_INT 5
65032: PUSH
65033: FOR_TO
65034: IFFALSE 65146
// begin _x := ShiftX ( x , i , 3 ) ;
65036: LD_ADDR_VAR 0 7
65040: PUSH
65041: LD_VAR 0 5
65045: PPUSH
65046: LD_VAR 0 4
65050: PPUSH
65051: LD_INT 3
65053: PPUSH
65054: CALL_OW 272
65058: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65059: LD_ADDR_VAR 0 8
65063: PUSH
65064: LD_VAR 0 6
65068: PPUSH
65069: LD_VAR 0 4
65073: PPUSH
65074: LD_INT 3
65076: PPUSH
65077: CALL_OW 273
65081: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65082: LD_VAR 0 7
65086: PPUSH
65087: LD_VAR 0 8
65091: PPUSH
65092: CALL_OW 488
65096: NOT
65097: IFFALSE 65101
// continue ;
65099: GO 65033
// if HexInfo ( _x , _y ) = 0 then
65101: LD_VAR 0 7
65105: PPUSH
65106: LD_VAR 0 8
65110: PPUSH
65111: CALL_OW 428
65115: PUSH
65116: LD_INT 0
65118: EQUAL
65119: IFFALSE 65144
// begin ComMoveXY ( unit , _x , _y ) ;
65121: LD_VAR 0 1
65125: PPUSH
65126: LD_VAR 0 7
65130: PPUSH
65131: LD_VAR 0 8
65135: PPUSH
65136: CALL_OW 111
// exit ;
65140: POP
65141: POP
65142: GO 65148
// end ; end ;
65144: GO 65033
65146: POP
65147: POP
// end ;
65148: LD_VAR 0 3
65152: RET
// export function ScanBase ( side , base_area ) ; begin
65153: LD_INT 0
65155: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65156: LD_ADDR_VAR 0 3
65160: PUSH
65161: LD_VAR 0 2
65165: PPUSH
65166: LD_INT 81
65168: PUSH
65169: LD_VAR 0 1
65173: PUSH
65174: EMPTY
65175: LIST
65176: LIST
65177: PPUSH
65178: CALL_OW 70
65182: ST_TO_ADDR
// end ;
65183: LD_VAR 0 3
65187: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65188: LD_INT 0
65190: PPUSH
65191: PPUSH
65192: PPUSH
65193: PPUSH
// result := false ;
65194: LD_ADDR_VAR 0 2
65198: PUSH
65199: LD_INT 0
65201: ST_TO_ADDR
// side := GetSide ( unit ) ;
65202: LD_ADDR_VAR 0 3
65206: PUSH
65207: LD_VAR 0 1
65211: PPUSH
65212: CALL_OW 255
65216: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65217: LD_ADDR_VAR 0 4
65221: PUSH
65222: LD_VAR 0 1
65226: PPUSH
65227: CALL_OW 248
65231: ST_TO_ADDR
// case nat of 1 :
65232: LD_VAR 0 4
65236: PUSH
65237: LD_INT 1
65239: DOUBLE
65240: EQUAL
65241: IFTRUE 65245
65243: GO 65256
65245: POP
// tech := tech_lassight ; 2 :
65246: LD_ADDR_VAR 0 5
65250: PUSH
65251: LD_INT 12
65253: ST_TO_ADDR
65254: GO 65295
65256: LD_INT 2
65258: DOUBLE
65259: EQUAL
65260: IFTRUE 65264
65262: GO 65275
65264: POP
// tech := tech_mortar ; 3 :
65265: LD_ADDR_VAR 0 5
65269: PUSH
65270: LD_INT 41
65272: ST_TO_ADDR
65273: GO 65295
65275: LD_INT 3
65277: DOUBLE
65278: EQUAL
65279: IFTRUE 65283
65281: GO 65294
65283: POP
// tech := tech_bazooka ; end ;
65284: LD_ADDR_VAR 0 5
65288: PUSH
65289: LD_INT 44
65291: ST_TO_ADDR
65292: GO 65295
65294: POP
// if Researched ( side , tech ) then
65295: LD_VAR 0 3
65299: PPUSH
65300: LD_VAR 0 5
65304: PPUSH
65305: CALL_OW 325
65309: IFFALSE 65336
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65311: LD_ADDR_VAR 0 2
65315: PUSH
65316: LD_INT 5
65318: PUSH
65319: LD_INT 8
65321: PUSH
65322: LD_INT 9
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: LIST
65329: PUSH
65330: LD_VAR 0 4
65334: ARRAY
65335: ST_TO_ADDR
// end ;
65336: LD_VAR 0 2
65340: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65341: LD_INT 0
65343: PPUSH
65344: PPUSH
65345: PPUSH
// if not mines then
65346: LD_VAR 0 2
65350: NOT
65351: IFFALSE 65355
// exit ;
65353: GO 65499
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65355: LD_ADDR_VAR 0 5
65359: PUSH
65360: LD_INT 81
65362: PUSH
65363: LD_VAR 0 1
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PUSH
65372: LD_INT 3
65374: PUSH
65375: LD_INT 21
65377: PUSH
65378: LD_INT 3
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: PUSH
65385: EMPTY
65386: LIST
65387: LIST
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PPUSH
65393: CALL_OW 69
65397: ST_TO_ADDR
// for i in mines do
65398: LD_ADDR_VAR 0 4
65402: PUSH
65403: LD_VAR 0 2
65407: PUSH
65408: FOR_IN
65409: IFFALSE 65497
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65411: LD_VAR 0 4
65415: PUSH
65416: LD_INT 1
65418: ARRAY
65419: PPUSH
65420: LD_VAR 0 4
65424: PUSH
65425: LD_INT 2
65427: ARRAY
65428: PPUSH
65429: CALL_OW 458
65433: NOT
65434: IFFALSE 65438
// continue ;
65436: GO 65408
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65438: LD_VAR 0 4
65442: PUSH
65443: LD_INT 1
65445: ARRAY
65446: PPUSH
65447: LD_VAR 0 4
65451: PUSH
65452: LD_INT 2
65454: ARRAY
65455: PPUSH
65456: CALL_OW 428
65460: PUSH
65461: LD_VAR 0 5
65465: IN
65466: IFFALSE 65495
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65468: LD_VAR 0 4
65472: PUSH
65473: LD_INT 1
65475: ARRAY
65476: PPUSH
65477: LD_VAR 0 4
65481: PUSH
65482: LD_INT 2
65484: ARRAY
65485: PPUSH
65486: LD_VAR 0 1
65490: PPUSH
65491: CALL_OW 456
// end ;
65495: GO 65408
65497: POP
65498: POP
// end ;
65499: LD_VAR 0 3
65503: RET
// export function Count ( array ) ; var i ; begin
65504: LD_INT 0
65506: PPUSH
65507: PPUSH
// result := 0 ;
65508: LD_ADDR_VAR 0 2
65512: PUSH
65513: LD_INT 0
65515: ST_TO_ADDR
// for i in array do
65516: LD_ADDR_VAR 0 3
65520: PUSH
65521: LD_VAR 0 1
65525: PUSH
65526: FOR_IN
65527: IFFALSE 65551
// if i then
65529: LD_VAR 0 3
65533: IFFALSE 65549
// result := result + 1 ;
65535: LD_ADDR_VAR 0 2
65539: PUSH
65540: LD_VAR 0 2
65544: PUSH
65545: LD_INT 1
65547: PLUS
65548: ST_TO_ADDR
65549: GO 65526
65551: POP
65552: POP
// end ;
65553: LD_VAR 0 2
65557: RET
// export function IsEmpty ( building ) ; begin
65558: LD_INT 0
65560: PPUSH
// if not building then
65561: LD_VAR 0 1
65565: NOT
65566: IFFALSE 65570
// exit ;
65568: GO 65613
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65570: LD_ADDR_VAR 0 2
65574: PUSH
65575: LD_VAR 0 1
65579: PUSH
65580: LD_INT 22
65582: PUSH
65583: LD_VAR 0 1
65587: PPUSH
65588: CALL_OW 255
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 58
65599: PUSH
65600: EMPTY
65601: LIST
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PPUSH
65607: CALL_OW 69
65611: IN
65612: ST_TO_ADDR
// end ;
65613: LD_VAR 0 2
65617: RET
// export function IsNotFull ( building ) ; var places ; begin
65618: LD_INT 0
65620: PPUSH
65621: PPUSH
// if not building then
65622: LD_VAR 0 1
65626: NOT
65627: IFFALSE 65631
// exit ;
65629: GO 65802
// result := false ;
65631: LD_ADDR_VAR 0 2
65635: PUSH
65636: LD_INT 0
65638: ST_TO_ADDR
// places := 0 ;
65639: LD_ADDR_VAR 0 3
65643: PUSH
65644: LD_INT 0
65646: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
65647: LD_VAR 0 1
65651: PPUSH
65652: CALL_OW 266
65656: PUSH
65657: LD_INT 0
65659: DOUBLE
65660: EQUAL
65661: IFTRUE 65719
65663: LD_INT 1
65665: DOUBLE
65666: EQUAL
65667: IFTRUE 65719
65669: LD_INT 6
65671: DOUBLE
65672: EQUAL
65673: IFTRUE 65719
65675: LD_INT 7
65677: DOUBLE
65678: EQUAL
65679: IFTRUE 65719
65681: LD_INT 8
65683: DOUBLE
65684: EQUAL
65685: IFTRUE 65719
65687: LD_INT 4
65689: DOUBLE
65690: EQUAL
65691: IFTRUE 65719
65693: LD_INT 5
65695: DOUBLE
65696: EQUAL
65697: IFTRUE 65719
65699: LD_INT 2
65701: DOUBLE
65702: EQUAL
65703: IFTRUE 65719
65705: LD_INT 3
65707: DOUBLE
65708: EQUAL
65709: IFTRUE 65719
65711: LD_INT 35
65713: DOUBLE
65714: EQUAL
65715: IFTRUE 65719
65717: GO 65730
65719: POP
// places := 6 ; b_bunker , b_breastwork :
65720: LD_ADDR_VAR 0 3
65724: PUSH
65725: LD_INT 6
65727: ST_TO_ADDR
65728: GO 65775
65730: LD_INT 32
65732: DOUBLE
65733: EQUAL
65734: IFTRUE 65744
65736: LD_INT 31
65738: DOUBLE
65739: EQUAL
65740: IFTRUE 65744
65742: GO 65755
65744: POP
// places := 1 ; b_control_tower :
65745: LD_ADDR_VAR 0 3
65749: PUSH
65750: LD_INT 1
65752: ST_TO_ADDR
65753: GO 65775
65755: LD_INT 36
65757: DOUBLE
65758: EQUAL
65759: IFTRUE 65763
65761: GO 65774
65763: POP
// places := 3 ; end ;
65764: LD_ADDR_VAR 0 3
65768: PUSH
65769: LD_INT 3
65771: ST_TO_ADDR
65772: GO 65775
65774: POP
// if places then
65775: LD_VAR 0 3
65779: IFFALSE 65802
// result := UnitsInside ( building ) < places ;
65781: LD_ADDR_VAR 0 2
65785: PUSH
65786: LD_VAR 0 1
65790: PPUSH
65791: CALL_OW 313
65795: PUSH
65796: LD_VAR 0 3
65800: LESS
65801: ST_TO_ADDR
// end ;
65802: LD_VAR 0 2
65806: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65807: LD_INT 0
65809: PPUSH
65810: PPUSH
65811: PPUSH
65812: PPUSH
// tmp := [ ] ;
65813: LD_ADDR_VAR 0 3
65817: PUSH
65818: EMPTY
65819: ST_TO_ADDR
// list := [ ] ;
65820: LD_ADDR_VAR 0 5
65824: PUSH
65825: EMPTY
65826: ST_TO_ADDR
// for i = 16 to 25 do
65827: LD_ADDR_VAR 0 4
65831: PUSH
65832: DOUBLE
65833: LD_INT 16
65835: DEC
65836: ST_TO_ADDR
65837: LD_INT 25
65839: PUSH
65840: FOR_TO
65841: IFFALSE 65914
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65843: LD_ADDR_VAR 0 3
65847: PUSH
65848: LD_VAR 0 3
65852: PUSH
65853: LD_INT 22
65855: PUSH
65856: LD_VAR 0 1
65860: PPUSH
65861: CALL_OW 255
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 91
65872: PUSH
65873: LD_VAR 0 1
65877: PUSH
65878: LD_INT 6
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 30
65888: PUSH
65889: LD_VAR 0 4
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: LIST
65902: PUSH
65903: EMPTY
65904: LIST
65905: PPUSH
65906: CALL_OW 69
65910: ADD
65911: ST_TO_ADDR
65912: GO 65840
65914: POP
65915: POP
// for i = 1 to tmp do
65916: LD_ADDR_VAR 0 4
65920: PUSH
65921: DOUBLE
65922: LD_INT 1
65924: DEC
65925: ST_TO_ADDR
65926: LD_VAR 0 3
65930: PUSH
65931: FOR_TO
65932: IFFALSE 66020
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65934: LD_ADDR_VAR 0 5
65938: PUSH
65939: LD_VAR 0 5
65943: PUSH
65944: LD_VAR 0 3
65948: PUSH
65949: LD_VAR 0 4
65953: ARRAY
65954: PPUSH
65955: CALL_OW 266
65959: PUSH
65960: LD_VAR 0 3
65964: PUSH
65965: LD_VAR 0 4
65969: ARRAY
65970: PPUSH
65971: CALL_OW 250
65975: PUSH
65976: LD_VAR 0 3
65980: PUSH
65981: LD_VAR 0 4
65985: ARRAY
65986: PPUSH
65987: CALL_OW 251
65991: PUSH
65992: LD_VAR 0 3
65996: PUSH
65997: LD_VAR 0 4
66001: ARRAY
66002: PPUSH
66003: CALL_OW 254
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: LIST
66012: LIST
66013: PUSH
66014: EMPTY
66015: LIST
66016: ADD
66017: ST_TO_ADDR
66018: GO 65931
66020: POP
66021: POP
// result := list ;
66022: LD_ADDR_VAR 0 2
66026: PUSH
66027: LD_VAR 0 5
66031: ST_TO_ADDR
// end ;
66032: LD_VAR 0 2
66036: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
66037: LD_INT 0
66039: PPUSH
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
// if not factory then
66046: LD_VAR 0 1
66050: NOT
66051: IFFALSE 66055
// exit ;
66053: GO 66648
// if control = control_apeman then
66055: LD_VAR 0 4
66059: PUSH
66060: LD_INT 5
66062: EQUAL
66063: IFFALSE 66172
// begin tmp := UnitsInside ( factory ) ;
66065: LD_ADDR_VAR 0 8
66069: PUSH
66070: LD_VAR 0 1
66074: PPUSH
66075: CALL_OW 313
66079: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
66080: LD_VAR 0 8
66084: PPUSH
66085: LD_INT 25
66087: PUSH
66088: LD_INT 12
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PPUSH
66095: CALL_OW 72
66099: NOT
66100: IFFALSE 66110
// control := control_manual ;
66102: LD_ADDR_VAR 0 4
66106: PUSH
66107: LD_INT 1
66109: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
66110: LD_ADDR_VAR 0 8
66114: PUSH
66115: LD_VAR 0 1
66119: PPUSH
66120: CALL 65807 0 1
66124: ST_TO_ADDR
// if tmp then
66125: LD_VAR 0 8
66129: IFFALSE 66172
// begin for i in tmp do
66131: LD_ADDR_VAR 0 7
66135: PUSH
66136: LD_VAR 0 8
66140: PUSH
66141: FOR_IN
66142: IFFALSE 66170
// if i [ 1 ] = b_ext_radio then
66144: LD_VAR 0 7
66148: PUSH
66149: LD_INT 1
66151: ARRAY
66152: PUSH
66153: LD_INT 22
66155: EQUAL
66156: IFFALSE 66168
// begin control := control_remote ;
66158: LD_ADDR_VAR 0 4
66162: PUSH
66163: LD_INT 2
66165: ST_TO_ADDR
// break ;
66166: GO 66170
// end ;
66168: GO 66141
66170: POP
66171: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66172: LD_VAR 0 1
66176: PPUSH
66177: LD_VAR 0 2
66181: PPUSH
66182: LD_VAR 0 3
66186: PPUSH
66187: LD_VAR 0 4
66191: PPUSH
66192: LD_VAR 0 5
66196: PPUSH
66197: CALL_OW 448
66201: IFFALSE 66236
// begin result := [ chassis , engine , control , weapon ] ;
66203: LD_ADDR_VAR 0 6
66207: PUSH
66208: LD_VAR 0 2
66212: PUSH
66213: LD_VAR 0 3
66217: PUSH
66218: LD_VAR 0 4
66222: PUSH
66223: LD_VAR 0 5
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: ST_TO_ADDR
// exit ;
66234: GO 66648
// end ; _chassis := AvailableChassisList ( factory ) ;
66236: LD_ADDR_VAR 0 9
66240: PUSH
66241: LD_VAR 0 1
66245: PPUSH
66246: CALL_OW 475
66250: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66251: LD_ADDR_VAR 0 11
66255: PUSH
66256: LD_VAR 0 1
66260: PPUSH
66261: CALL_OW 476
66265: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66266: LD_ADDR_VAR 0 12
66270: PUSH
66271: LD_VAR 0 1
66275: PPUSH
66276: CALL_OW 477
66280: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66281: LD_ADDR_VAR 0 10
66285: PUSH
66286: LD_VAR 0 1
66290: PPUSH
66291: CALL_OW 478
66295: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66296: LD_VAR 0 9
66300: NOT
66301: PUSH
66302: LD_VAR 0 11
66306: NOT
66307: OR
66308: PUSH
66309: LD_VAR 0 12
66313: NOT
66314: OR
66315: PUSH
66316: LD_VAR 0 10
66320: NOT
66321: OR
66322: IFFALSE 66357
// begin result := [ chassis , engine , control , weapon ] ;
66324: LD_ADDR_VAR 0 6
66328: PUSH
66329: LD_VAR 0 2
66333: PUSH
66334: LD_VAR 0 3
66338: PUSH
66339: LD_VAR 0 4
66343: PUSH
66344: LD_VAR 0 5
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: LIST
66353: LIST
66354: ST_TO_ADDR
// exit ;
66355: GO 66648
// end ; if not chassis in _chassis then
66357: LD_VAR 0 2
66361: PUSH
66362: LD_VAR 0 9
66366: IN
66367: NOT
66368: IFFALSE 66394
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66370: LD_ADDR_VAR 0 2
66374: PUSH
66375: LD_VAR 0 9
66379: PUSH
66380: LD_INT 1
66382: PPUSH
66383: LD_VAR 0 9
66387: PPUSH
66388: CALL_OW 12
66392: ARRAY
66393: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66394: LD_VAR 0 2
66398: PPUSH
66399: LD_VAR 0 3
66403: PPUSH
66404: CALL 66653 0 2
66408: NOT
66409: IFFALSE 66468
// repeat engine := _engine [ 1 ] ;
66411: LD_ADDR_VAR 0 3
66415: PUSH
66416: LD_VAR 0 11
66420: PUSH
66421: LD_INT 1
66423: ARRAY
66424: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66425: LD_ADDR_VAR 0 11
66429: PUSH
66430: LD_VAR 0 11
66434: PPUSH
66435: LD_INT 1
66437: PPUSH
66438: CALL_OW 3
66442: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66443: LD_VAR 0 2
66447: PPUSH
66448: LD_VAR 0 3
66452: PPUSH
66453: CALL 66653 0 2
66457: PUSH
66458: LD_VAR 0 11
66462: PUSH
66463: EMPTY
66464: EQUAL
66465: OR
66466: IFFALSE 66411
// if not control in _control then
66468: LD_VAR 0 4
66472: PUSH
66473: LD_VAR 0 12
66477: IN
66478: NOT
66479: IFFALSE 66505
// control := _control [ rand ( 1 , _control ) ] ;
66481: LD_ADDR_VAR 0 4
66485: PUSH
66486: LD_VAR 0 12
66490: PUSH
66491: LD_INT 1
66493: PPUSH
66494: LD_VAR 0 12
66498: PPUSH
66499: CALL_OW 12
66503: ARRAY
66504: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66505: LD_VAR 0 2
66509: PPUSH
66510: LD_VAR 0 5
66514: PPUSH
66515: CALL 66873 0 2
66519: NOT
66520: IFFALSE 66579
// repeat weapon := _weapon [ 1 ] ;
66522: LD_ADDR_VAR 0 5
66526: PUSH
66527: LD_VAR 0 10
66531: PUSH
66532: LD_INT 1
66534: ARRAY
66535: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66536: LD_ADDR_VAR 0 10
66540: PUSH
66541: LD_VAR 0 10
66545: PPUSH
66546: LD_INT 1
66548: PPUSH
66549: CALL_OW 3
66553: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66554: LD_VAR 0 2
66558: PPUSH
66559: LD_VAR 0 5
66563: PPUSH
66564: CALL 66873 0 2
66568: PUSH
66569: LD_VAR 0 10
66573: PUSH
66574: EMPTY
66575: EQUAL
66576: OR
66577: IFFALSE 66522
// result := [ ] ;
66579: LD_ADDR_VAR 0 6
66583: PUSH
66584: EMPTY
66585: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66586: LD_VAR 0 1
66590: PPUSH
66591: LD_VAR 0 2
66595: PPUSH
66596: LD_VAR 0 3
66600: PPUSH
66601: LD_VAR 0 4
66605: PPUSH
66606: LD_VAR 0 5
66610: PPUSH
66611: CALL_OW 448
66615: IFFALSE 66648
// result := [ chassis , engine , control , weapon ] ;
66617: LD_ADDR_VAR 0 6
66621: PUSH
66622: LD_VAR 0 2
66626: PUSH
66627: LD_VAR 0 3
66631: PUSH
66632: LD_VAR 0 4
66636: PUSH
66637: LD_VAR 0 5
66641: PUSH
66642: EMPTY
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: ST_TO_ADDR
// end ;
66648: LD_VAR 0 6
66652: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66653: LD_INT 0
66655: PPUSH
// if not chassis or not engine then
66656: LD_VAR 0 1
66660: NOT
66661: PUSH
66662: LD_VAR 0 2
66666: NOT
66667: OR
66668: IFFALSE 66672
// exit ;
66670: GO 66868
// case engine of engine_solar :
66672: LD_VAR 0 2
66676: PUSH
66677: LD_INT 2
66679: DOUBLE
66680: EQUAL
66681: IFTRUE 66685
66683: GO 66723
66685: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66686: LD_ADDR_VAR 0 3
66690: PUSH
66691: LD_INT 11
66693: PUSH
66694: LD_INT 12
66696: PUSH
66697: LD_INT 13
66699: PUSH
66700: LD_INT 14
66702: PUSH
66703: LD_INT 1
66705: PUSH
66706: LD_INT 2
66708: PUSH
66709: LD_INT 3
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: ST_TO_ADDR
66721: GO 66852
66723: LD_INT 1
66725: DOUBLE
66726: EQUAL
66727: IFTRUE 66731
66729: GO 66793
66731: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66732: LD_ADDR_VAR 0 3
66736: PUSH
66737: LD_INT 11
66739: PUSH
66740: LD_INT 12
66742: PUSH
66743: LD_INT 13
66745: PUSH
66746: LD_INT 14
66748: PUSH
66749: LD_INT 1
66751: PUSH
66752: LD_INT 2
66754: PUSH
66755: LD_INT 3
66757: PUSH
66758: LD_INT 4
66760: PUSH
66761: LD_INT 5
66763: PUSH
66764: LD_INT 21
66766: PUSH
66767: LD_INT 23
66769: PUSH
66770: LD_INT 22
66772: PUSH
66773: LD_INT 24
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: LIST
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: LIST
66787: LIST
66788: LIST
66789: LIST
66790: ST_TO_ADDR
66791: GO 66852
66793: LD_INT 3
66795: DOUBLE
66796: EQUAL
66797: IFTRUE 66801
66799: GO 66851
66801: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66802: LD_ADDR_VAR 0 3
66806: PUSH
66807: LD_INT 13
66809: PUSH
66810: LD_INT 14
66812: PUSH
66813: LD_INT 2
66815: PUSH
66816: LD_INT 3
66818: PUSH
66819: LD_INT 4
66821: PUSH
66822: LD_INT 5
66824: PUSH
66825: LD_INT 21
66827: PUSH
66828: LD_INT 22
66830: PUSH
66831: LD_INT 23
66833: PUSH
66834: LD_INT 24
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: LIST
66847: LIST
66848: ST_TO_ADDR
66849: GO 66852
66851: POP
// result := ( chassis in result ) ;
66852: LD_ADDR_VAR 0 3
66856: PUSH
66857: LD_VAR 0 1
66861: PUSH
66862: LD_VAR 0 3
66866: IN
66867: ST_TO_ADDR
// end ;
66868: LD_VAR 0 3
66872: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66873: LD_INT 0
66875: PPUSH
// if not chassis or not weapon then
66876: LD_VAR 0 1
66880: NOT
66881: PUSH
66882: LD_VAR 0 2
66886: NOT
66887: OR
66888: IFFALSE 66892
// exit ;
66890: GO 67954
// case weapon of us_machine_gun :
66892: LD_VAR 0 2
66896: PUSH
66897: LD_INT 2
66899: DOUBLE
66900: EQUAL
66901: IFTRUE 66905
66903: GO 66935
66905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66906: LD_ADDR_VAR 0 3
66910: PUSH
66911: LD_INT 1
66913: PUSH
66914: LD_INT 2
66916: PUSH
66917: LD_INT 3
66919: PUSH
66920: LD_INT 4
66922: PUSH
66923: LD_INT 5
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: ST_TO_ADDR
66933: GO 67938
66935: LD_INT 3
66937: DOUBLE
66938: EQUAL
66939: IFTRUE 66943
66941: GO 66973
66943: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66944: LD_ADDR_VAR 0 3
66948: PUSH
66949: LD_INT 1
66951: PUSH
66952: LD_INT 2
66954: PUSH
66955: LD_INT 3
66957: PUSH
66958: LD_INT 4
66960: PUSH
66961: LD_INT 5
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: ST_TO_ADDR
66971: GO 67938
66973: LD_INT 11
66975: DOUBLE
66976: EQUAL
66977: IFTRUE 66981
66979: GO 67011
66981: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66982: LD_ADDR_VAR 0 3
66986: PUSH
66987: LD_INT 1
66989: PUSH
66990: LD_INT 2
66992: PUSH
66993: LD_INT 3
66995: PUSH
66996: LD_INT 4
66998: PUSH
66999: LD_INT 5
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: ST_TO_ADDR
67009: GO 67938
67011: LD_INT 4
67013: DOUBLE
67014: EQUAL
67015: IFTRUE 67019
67017: GO 67045
67019: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
67020: LD_ADDR_VAR 0 3
67024: PUSH
67025: LD_INT 2
67027: PUSH
67028: LD_INT 3
67030: PUSH
67031: LD_INT 4
67033: PUSH
67034: LD_INT 5
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: LIST
67041: LIST
67042: ST_TO_ADDR
67043: GO 67938
67045: LD_INT 5
67047: DOUBLE
67048: EQUAL
67049: IFTRUE 67053
67051: GO 67079
67053: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
67054: LD_ADDR_VAR 0 3
67058: PUSH
67059: LD_INT 2
67061: PUSH
67062: LD_INT 3
67064: PUSH
67065: LD_INT 4
67067: PUSH
67068: LD_INT 5
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: LIST
67075: LIST
67076: ST_TO_ADDR
67077: GO 67938
67079: LD_INT 9
67081: DOUBLE
67082: EQUAL
67083: IFTRUE 67087
67085: GO 67113
67087: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
67088: LD_ADDR_VAR 0 3
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: LD_INT 3
67098: PUSH
67099: LD_INT 4
67101: PUSH
67102: LD_INT 5
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: ST_TO_ADDR
67111: GO 67938
67113: LD_INT 7
67115: DOUBLE
67116: EQUAL
67117: IFTRUE 67121
67119: GO 67147
67121: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
67122: LD_ADDR_VAR 0 3
67126: PUSH
67127: LD_INT 2
67129: PUSH
67130: LD_INT 3
67132: PUSH
67133: LD_INT 4
67135: PUSH
67136: LD_INT 5
67138: PUSH
67139: EMPTY
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: ST_TO_ADDR
67145: GO 67938
67147: LD_INT 12
67149: DOUBLE
67150: EQUAL
67151: IFTRUE 67155
67153: GO 67181
67155: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
67156: LD_ADDR_VAR 0 3
67160: PUSH
67161: LD_INT 2
67163: PUSH
67164: LD_INT 3
67166: PUSH
67167: LD_INT 4
67169: PUSH
67170: LD_INT 5
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: LIST
67177: LIST
67178: ST_TO_ADDR
67179: GO 67938
67181: LD_INT 13
67183: DOUBLE
67184: EQUAL
67185: IFTRUE 67189
67187: GO 67215
67189: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67190: LD_ADDR_VAR 0 3
67194: PUSH
67195: LD_INT 2
67197: PUSH
67198: LD_INT 3
67200: PUSH
67201: LD_INT 4
67203: PUSH
67204: LD_INT 5
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: ST_TO_ADDR
67213: GO 67938
67215: LD_INT 14
67217: DOUBLE
67218: EQUAL
67219: IFTRUE 67223
67221: GO 67241
67223: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67224: LD_ADDR_VAR 0 3
67228: PUSH
67229: LD_INT 4
67231: PUSH
67232: LD_INT 5
67234: PUSH
67235: EMPTY
67236: LIST
67237: LIST
67238: ST_TO_ADDR
67239: GO 67938
67241: LD_INT 6
67243: DOUBLE
67244: EQUAL
67245: IFTRUE 67249
67247: GO 67267
67249: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67250: LD_ADDR_VAR 0 3
67254: PUSH
67255: LD_INT 4
67257: PUSH
67258: LD_INT 5
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: ST_TO_ADDR
67265: GO 67938
67267: LD_INT 10
67269: DOUBLE
67270: EQUAL
67271: IFTRUE 67275
67273: GO 67293
67275: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67276: LD_ADDR_VAR 0 3
67280: PUSH
67281: LD_INT 4
67283: PUSH
67284: LD_INT 5
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: ST_TO_ADDR
67291: GO 67938
67293: LD_INT 22
67295: DOUBLE
67296: EQUAL
67297: IFTRUE 67301
67299: GO 67327
67301: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67302: LD_ADDR_VAR 0 3
67306: PUSH
67307: LD_INT 11
67309: PUSH
67310: LD_INT 12
67312: PUSH
67313: LD_INT 13
67315: PUSH
67316: LD_INT 14
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: LIST
67323: LIST
67324: ST_TO_ADDR
67325: GO 67938
67327: LD_INT 23
67329: DOUBLE
67330: EQUAL
67331: IFTRUE 67335
67333: GO 67361
67335: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67336: LD_ADDR_VAR 0 3
67340: PUSH
67341: LD_INT 11
67343: PUSH
67344: LD_INT 12
67346: PUSH
67347: LD_INT 13
67349: PUSH
67350: LD_INT 14
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: LIST
67357: LIST
67358: ST_TO_ADDR
67359: GO 67938
67361: LD_INT 24
67363: DOUBLE
67364: EQUAL
67365: IFTRUE 67369
67367: GO 67395
67369: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67370: LD_ADDR_VAR 0 3
67374: PUSH
67375: LD_INT 11
67377: PUSH
67378: LD_INT 12
67380: PUSH
67381: LD_INT 13
67383: PUSH
67384: LD_INT 14
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: ST_TO_ADDR
67393: GO 67938
67395: LD_INT 30
67397: DOUBLE
67398: EQUAL
67399: IFTRUE 67403
67401: GO 67429
67403: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67404: LD_ADDR_VAR 0 3
67408: PUSH
67409: LD_INT 11
67411: PUSH
67412: LD_INT 12
67414: PUSH
67415: LD_INT 13
67417: PUSH
67418: LD_INT 14
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: ST_TO_ADDR
67427: GO 67938
67429: LD_INT 25
67431: DOUBLE
67432: EQUAL
67433: IFTRUE 67437
67435: GO 67455
67437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67438: LD_ADDR_VAR 0 3
67442: PUSH
67443: LD_INT 13
67445: PUSH
67446: LD_INT 14
67448: PUSH
67449: EMPTY
67450: LIST
67451: LIST
67452: ST_TO_ADDR
67453: GO 67938
67455: LD_INT 27
67457: DOUBLE
67458: EQUAL
67459: IFTRUE 67463
67461: GO 67481
67463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67464: LD_ADDR_VAR 0 3
67468: PUSH
67469: LD_INT 13
67471: PUSH
67472: LD_INT 14
67474: PUSH
67475: EMPTY
67476: LIST
67477: LIST
67478: ST_TO_ADDR
67479: GO 67938
67481: LD_EXP 78
67485: DOUBLE
67486: EQUAL
67487: IFTRUE 67491
67489: GO 67517
67491: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67492: LD_ADDR_VAR 0 3
67496: PUSH
67497: LD_INT 11
67499: PUSH
67500: LD_INT 12
67502: PUSH
67503: LD_INT 13
67505: PUSH
67506: LD_INT 14
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: LIST
67513: LIST
67514: ST_TO_ADDR
67515: GO 67938
67517: LD_INT 28
67519: DOUBLE
67520: EQUAL
67521: IFTRUE 67525
67523: GO 67543
67525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67526: LD_ADDR_VAR 0 3
67530: PUSH
67531: LD_INT 13
67533: PUSH
67534: LD_INT 14
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: ST_TO_ADDR
67541: GO 67938
67543: LD_INT 29
67545: DOUBLE
67546: EQUAL
67547: IFTRUE 67551
67549: GO 67569
67551: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67552: LD_ADDR_VAR 0 3
67556: PUSH
67557: LD_INT 13
67559: PUSH
67560: LD_INT 14
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: ST_TO_ADDR
67567: GO 67938
67569: LD_INT 31
67571: DOUBLE
67572: EQUAL
67573: IFTRUE 67577
67575: GO 67595
67577: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67578: LD_ADDR_VAR 0 3
67582: PUSH
67583: LD_INT 13
67585: PUSH
67586: LD_INT 14
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: ST_TO_ADDR
67593: GO 67938
67595: LD_INT 26
67597: DOUBLE
67598: EQUAL
67599: IFTRUE 67603
67601: GO 67621
67603: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67604: LD_ADDR_VAR 0 3
67608: PUSH
67609: LD_INT 13
67611: PUSH
67612: LD_INT 14
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: ST_TO_ADDR
67619: GO 67938
67621: LD_INT 42
67623: DOUBLE
67624: EQUAL
67625: IFTRUE 67629
67627: GO 67655
67629: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67630: LD_ADDR_VAR 0 3
67634: PUSH
67635: LD_INT 21
67637: PUSH
67638: LD_INT 22
67640: PUSH
67641: LD_INT 23
67643: PUSH
67644: LD_INT 24
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: ST_TO_ADDR
67653: GO 67938
67655: LD_INT 43
67657: DOUBLE
67658: EQUAL
67659: IFTRUE 67663
67661: GO 67689
67663: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67664: LD_ADDR_VAR 0 3
67668: PUSH
67669: LD_INT 21
67671: PUSH
67672: LD_INT 22
67674: PUSH
67675: LD_INT 23
67677: PUSH
67678: LD_INT 24
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: ST_TO_ADDR
67687: GO 67938
67689: LD_INT 44
67691: DOUBLE
67692: EQUAL
67693: IFTRUE 67697
67695: GO 67723
67697: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67698: LD_ADDR_VAR 0 3
67702: PUSH
67703: LD_INT 21
67705: PUSH
67706: LD_INT 22
67708: PUSH
67709: LD_INT 23
67711: PUSH
67712: LD_INT 24
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: ST_TO_ADDR
67721: GO 67938
67723: LD_INT 45
67725: DOUBLE
67726: EQUAL
67727: IFTRUE 67731
67729: GO 67757
67731: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67732: LD_ADDR_VAR 0 3
67736: PUSH
67737: LD_INT 21
67739: PUSH
67740: LD_INT 22
67742: PUSH
67743: LD_INT 23
67745: PUSH
67746: LD_INT 24
67748: PUSH
67749: EMPTY
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: ST_TO_ADDR
67755: GO 67938
67757: LD_INT 49
67759: DOUBLE
67760: EQUAL
67761: IFTRUE 67765
67763: GO 67791
67765: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67766: LD_ADDR_VAR 0 3
67770: PUSH
67771: LD_INT 21
67773: PUSH
67774: LD_INT 22
67776: PUSH
67777: LD_INT 23
67779: PUSH
67780: LD_INT 24
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: LIST
67787: LIST
67788: ST_TO_ADDR
67789: GO 67938
67791: LD_INT 51
67793: DOUBLE
67794: EQUAL
67795: IFTRUE 67799
67797: GO 67825
67799: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67800: LD_ADDR_VAR 0 3
67804: PUSH
67805: LD_INT 21
67807: PUSH
67808: LD_INT 22
67810: PUSH
67811: LD_INT 23
67813: PUSH
67814: LD_INT 24
67816: PUSH
67817: EMPTY
67818: LIST
67819: LIST
67820: LIST
67821: LIST
67822: ST_TO_ADDR
67823: GO 67938
67825: LD_INT 52
67827: DOUBLE
67828: EQUAL
67829: IFTRUE 67833
67831: GO 67859
67833: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67834: LD_ADDR_VAR 0 3
67838: PUSH
67839: LD_INT 21
67841: PUSH
67842: LD_INT 22
67844: PUSH
67845: LD_INT 23
67847: PUSH
67848: LD_INT 24
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: ST_TO_ADDR
67857: GO 67938
67859: LD_INT 53
67861: DOUBLE
67862: EQUAL
67863: IFTRUE 67867
67865: GO 67885
67867: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67868: LD_ADDR_VAR 0 3
67872: PUSH
67873: LD_INT 23
67875: PUSH
67876: LD_INT 24
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: ST_TO_ADDR
67883: GO 67938
67885: LD_INT 46
67887: DOUBLE
67888: EQUAL
67889: IFTRUE 67893
67891: GO 67911
67893: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67894: LD_ADDR_VAR 0 3
67898: PUSH
67899: LD_INT 23
67901: PUSH
67902: LD_INT 24
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: ST_TO_ADDR
67909: GO 67938
67911: LD_INT 47
67913: DOUBLE
67914: EQUAL
67915: IFTRUE 67919
67917: GO 67937
67919: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67920: LD_ADDR_VAR 0 3
67924: PUSH
67925: LD_INT 23
67927: PUSH
67928: LD_INT 24
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: ST_TO_ADDR
67935: GO 67938
67937: POP
// result := ( chassis in result ) ;
67938: LD_ADDR_VAR 0 3
67942: PUSH
67943: LD_VAR 0 1
67947: PUSH
67948: LD_VAR 0 3
67952: IN
67953: ST_TO_ADDR
// end ;
67954: LD_VAR 0 3
67958: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67959: LD_INT 0
67961: PPUSH
67962: PPUSH
67963: PPUSH
67964: PPUSH
67965: PPUSH
67966: PPUSH
67967: PPUSH
// result := array ;
67968: LD_ADDR_VAR 0 5
67972: PUSH
67973: LD_VAR 0 1
67977: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67978: LD_VAR 0 1
67982: NOT
67983: PUSH
67984: LD_VAR 0 2
67988: NOT
67989: OR
67990: PUSH
67991: LD_VAR 0 3
67995: NOT
67996: OR
67997: PUSH
67998: LD_VAR 0 2
68002: PUSH
68003: LD_VAR 0 1
68007: GREATER
68008: OR
68009: PUSH
68010: LD_VAR 0 3
68014: PUSH
68015: LD_VAR 0 1
68019: GREATER
68020: OR
68021: IFFALSE 68025
// exit ;
68023: GO 68321
// if direction then
68025: LD_VAR 0 4
68029: IFFALSE 68093
// begin d := 1 ;
68031: LD_ADDR_VAR 0 9
68035: PUSH
68036: LD_INT 1
68038: ST_TO_ADDR
// if i_from > i_to then
68039: LD_VAR 0 2
68043: PUSH
68044: LD_VAR 0 3
68048: GREATER
68049: IFFALSE 68075
// length := ( array - i_from ) + i_to else
68051: LD_ADDR_VAR 0 11
68055: PUSH
68056: LD_VAR 0 1
68060: PUSH
68061: LD_VAR 0 2
68065: MINUS
68066: PUSH
68067: LD_VAR 0 3
68071: PLUS
68072: ST_TO_ADDR
68073: GO 68091
// length := i_to - i_from ;
68075: LD_ADDR_VAR 0 11
68079: PUSH
68080: LD_VAR 0 3
68084: PUSH
68085: LD_VAR 0 2
68089: MINUS
68090: ST_TO_ADDR
// end else
68091: GO 68154
// begin d := - 1 ;
68093: LD_ADDR_VAR 0 9
68097: PUSH
68098: LD_INT 1
68100: NEG
68101: ST_TO_ADDR
// if i_from > i_to then
68102: LD_VAR 0 2
68106: PUSH
68107: LD_VAR 0 3
68111: GREATER
68112: IFFALSE 68132
// length := i_from - i_to else
68114: LD_ADDR_VAR 0 11
68118: PUSH
68119: LD_VAR 0 2
68123: PUSH
68124: LD_VAR 0 3
68128: MINUS
68129: ST_TO_ADDR
68130: GO 68154
// length := ( array - i_to ) + i_from ;
68132: LD_ADDR_VAR 0 11
68136: PUSH
68137: LD_VAR 0 1
68141: PUSH
68142: LD_VAR 0 3
68146: MINUS
68147: PUSH
68148: LD_VAR 0 2
68152: PLUS
68153: ST_TO_ADDR
// end ; if not length then
68154: LD_VAR 0 11
68158: NOT
68159: IFFALSE 68163
// exit ;
68161: GO 68321
// tmp := array ;
68163: LD_ADDR_VAR 0 10
68167: PUSH
68168: LD_VAR 0 1
68172: ST_TO_ADDR
// for i = 1 to length do
68173: LD_ADDR_VAR 0 6
68177: PUSH
68178: DOUBLE
68179: LD_INT 1
68181: DEC
68182: ST_TO_ADDR
68183: LD_VAR 0 11
68187: PUSH
68188: FOR_TO
68189: IFFALSE 68309
// begin for j = 1 to array do
68191: LD_ADDR_VAR 0 7
68195: PUSH
68196: DOUBLE
68197: LD_INT 1
68199: DEC
68200: ST_TO_ADDR
68201: LD_VAR 0 1
68205: PUSH
68206: FOR_TO
68207: IFFALSE 68295
// begin k := j + d ;
68209: LD_ADDR_VAR 0 8
68213: PUSH
68214: LD_VAR 0 7
68218: PUSH
68219: LD_VAR 0 9
68223: PLUS
68224: ST_TO_ADDR
// if k > array then
68225: LD_VAR 0 8
68229: PUSH
68230: LD_VAR 0 1
68234: GREATER
68235: IFFALSE 68245
// k := 1 ;
68237: LD_ADDR_VAR 0 8
68241: PUSH
68242: LD_INT 1
68244: ST_TO_ADDR
// if not k then
68245: LD_VAR 0 8
68249: NOT
68250: IFFALSE 68262
// k := array ;
68252: LD_ADDR_VAR 0 8
68256: PUSH
68257: LD_VAR 0 1
68261: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68262: LD_ADDR_VAR 0 10
68266: PUSH
68267: LD_VAR 0 10
68271: PPUSH
68272: LD_VAR 0 8
68276: PPUSH
68277: LD_VAR 0 1
68281: PUSH
68282: LD_VAR 0 7
68286: ARRAY
68287: PPUSH
68288: CALL_OW 1
68292: ST_TO_ADDR
// end ;
68293: GO 68206
68295: POP
68296: POP
// array := tmp ;
68297: LD_ADDR_VAR 0 1
68301: PUSH
68302: LD_VAR 0 10
68306: ST_TO_ADDR
// end ;
68307: GO 68188
68309: POP
68310: POP
// result := array ;
68311: LD_ADDR_VAR 0 5
68315: PUSH
68316: LD_VAR 0 1
68320: ST_TO_ADDR
// end ;
68321: LD_VAR 0 5
68325: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68326: LD_INT 0
68328: PPUSH
68329: PPUSH
// result := 0 ;
68330: LD_ADDR_VAR 0 3
68334: PUSH
68335: LD_INT 0
68337: ST_TO_ADDR
// if not array or not value in array then
68338: LD_VAR 0 1
68342: NOT
68343: PUSH
68344: LD_VAR 0 2
68348: PUSH
68349: LD_VAR 0 1
68353: IN
68354: NOT
68355: OR
68356: IFFALSE 68360
// exit ;
68358: GO 68414
// for i = 1 to array do
68360: LD_ADDR_VAR 0 4
68364: PUSH
68365: DOUBLE
68366: LD_INT 1
68368: DEC
68369: ST_TO_ADDR
68370: LD_VAR 0 1
68374: PUSH
68375: FOR_TO
68376: IFFALSE 68412
// if value = array [ i ] then
68378: LD_VAR 0 2
68382: PUSH
68383: LD_VAR 0 1
68387: PUSH
68388: LD_VAR 0 4
68392: ARRAY
68393: EQUAL
68394: IFFALSE 68410
// begin result := i ;
68396: LD_ADDR_VAR 0 3
68400: PUSH
68401: LD_VAR 0 4
68405: ST_TO_ADDR
// exit ;
68406: POP
68407: POP
68408: GO 68414
// end ;
68410: GO 68375
68412: POP
68413: POP
// end ;
68414: LD_VAR 0 3
68418: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68419: LD_INT 0
68421: PPUSH
// vc_chassis := chassis ;
68422: LD_ADDR_OWVAR 37
68426: PUSH
68427: LD_VAR 0 1
68431: ST_TO_ADDR
// vc_engine := engine ;
68432: LD_ADDR_OWVAR 39
68436: PUSH
68437: LD_VAR 0 2
68441: ST_TO_ADDR
// vc_control := control ;
68442: LD_ADDR_OWVAR 38
68446: PUSH
68447: LD_VAR 0 3
68451: ST_TO_ADDR
// vc_weapon := weapon ;
68452: LD_ADDR_OWVAR 40
68456: PUSH
68457: LD_VAR 0 4
68461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68462: LD_ADDR_OWVAR 41
68466: PUSH
68467: LD_VAR 0 5
68471: ST_TO_ADDR
// end ;
68472: LD_VAR 0 6
68476: RET
// export function WantPlant ( unit ) ; var task ; begin
68477: LD_INT 0
68479: PPUSH
68480: PPUSH
// result := false ;
68481: LD_ADDR_VAR 0 2
68485: PUSH
68486: LD_INT 0
68488: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68489: LD_ADDR_VAR 0 3
68493: PUSH
68494: LD_VAR 0 1
68498: PPUSH
68499: CALL_OW 437
68503: ST_TO_ADDR
// if task then
68504: LD_VAR 0 3
68508: IFFALSE 68536
// if task [ 1 ] [ 1 ] = p then
68510: LD_VAR 0 3
68514: PUSH
68515: LD_INT 1
68517: ARRAY
68518: PUSH
68519: LD_INT 1
68521: ARRAY
68522: PUSH
68523: LD_STRING p
68525: EQUAL
68526: IFFALSE 68536
// result := true ;
68528: LD_ADDR_VAR 0 2
68532: PUSH
68533: LD_INT 1
68535: ST_TO_ADDR
// end ;
68536: LD_VAR 0 2
68540: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68541: LD_INT 0
68543: PPUSH
68544: PPUSH
68545: PPUSH
68546: PPUSH
// if pos < 1 then
68547: LD_VAR 0 2
68551: PUSH
68552: LD_INT 1
68554: LESS
68555: IFFALSE 68559
// exit ;
68557: GO 68862
// if pos = 1 then
68559: LD_VAR 0 2
68563: PUSH
68564: LD_INT 1
68566: EQUAL
68567: IFFALSE 68600
// result := Replace ( arr , pos [ 1 ] , value ) else
68569: LD_ADDR_VAR 0 4
68573: PUSH
68574: LD_VAR 0 1
68578: PPUSH
68579: LD_VAR 0 2
68583: PUSH
68584: LD_INT 1
68586: ARRAY
68587: PPUSH
68588: LD_VAR 0 3
68592: PPUSH
68593: CALL_OW 1
68597: ST_TO_ADDR
68598: GO 68862
// begin tmp := arr ;
68600: LD_ADDR_VAR 0 6
68604: PUSH
68605: LD_VAR 0 1
68609: ST_TO_ADDR
// s_arr := [ tmp ] ;
68610: LD_ADDR_VAR 0 7
68614: PUSH
68615: LD_VAR 0 6
68619: PUSH
68620: EMPTY
68621: LIST
68622: ST_TO_ADDR
// for i = 1 to pos - 1 do
68623: LD_ADDR_VAR 0 5
68627: PUSH
68628: DOUBLE
68629: LD_INT 1
68631: DEC
68632: ST_TO_ADDR
68633: LD_VAR 0 2
68637: PUSH
68638: LD_INT 1
68640: MINUS
68641: PUSH
68642: FOR_TO
68643: IFFALSE 68688
// begin tmp := tmp [ pos [ i ] ] ;
68645: LD_ADDR_VAR 0 6
68649: PUSH
68650: LD_VAR 0 6
68654: PUSH
68655: LD_VAR 0 2
68659: PUSH
68660: LD_VAR 0 5
68664: ARRAY
68665: ARRAY
68666: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68667: LD_ADDR_VAR 0 7
68671: PUSH
68672: LD_VAR 0 7
68676: PUSH
68677: LD_VAR 0 6
68681: PUSH
68682: EMPTY
68683: LIST
68684: ADD
68685: ST_TO_ADDR
// end ;
68686: GO 68642
68688: POP
68689: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68690: LD_ADDR_VAR 0 6
68694: PUSH
68695: LD_VAR 0 6
68699: PPUSH
68700: LD_VAR 0 2
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: PPUSH
68711: LD_VAR 0 3
68715: PPUSH
68716: CALL_OW 1
68720: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68721: LD_ADDR_VAR 0 7
68725: PUSH
68726: LD_VAR 0 7
68730: PPUSH
68731: LD_VAR 0 7
68735: PPUSH
68736: LD_VAR 0 6
68740: PPUSH
68741: CALL_OW 1
68745: ST_TO_ADDR
// for i = s_arr downto 2 do
68746: LD_ADDR_VAR 0 5
68750: PUSH
68751: DOUBLE
68752: LD_VAR 0 7
68756: INC
68757: ST_TO_ADDR
68758: LD_INT 2
68760: PUSH
68761: FOR_DOWNTO
68762: IFFALSE 68846
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68764: LD_ADDR_VAR 0 6
68768: PUSH
68769: LD_VAR 0 7
68773: PUSH
68774: LD_VAR 0 5
68778: PUSH
68779: LD_INT 1
68781: MINUS
68782: ARRAY
68783: PPUSH
68784: LD_VAR 0 2
68788: PUSH
68789: LD_VAR 0 5
68793: PUSH
68794: LD_INT 1
68796: MINUS
68797: ARRAY
68798: PPUSH
68799: LD_VAR 0 7
68803: PUSH
68804: LD_VAR 0 5
68808: ARRAY
68809: PPUSH
68810: CALL_OW 1
68814: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68815: LD_ADDR_VAR 0 7
68819: PUSH
68820: LD_VAR 0 7
68824: PPUSH
68825: LD_VAR 0 5
68829: PUSH
68830: LD_INT 1
68832: MINUS
68833: PPUSH
68834: LD_VAR 0 6
68838: PPUSH
68839: CALL_OW 1
68843: ST_TO_ADDR
// end ;
68844: GO 68761
68846: POP
68847: POP
// result := s_arr [ 1 ] ;
68848: LD_ADDR_VAR 0 4
68852: PUSH
68853: LD_VAR 0 7
68857: PUSH
68858: LD_INT 1
68860: ARRAY
68861: ST_TO_ADDR
// end ; end ;
68862: LD_VAR 0 4
68866: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68867: LD_INT 0
68869: PPUSH
68870: PPUSH
// if not list then
68871: LD_VAR 0 1
68875: NOT
68876: IFFALSE 68880
// exit ;
68878: GO 68971
// i := list [ pos1 ] ;
68880: LD_ADDR_VAR 0 5
68884: PUSH
68885: LD_VAR 0 1
68889: PUSH
68890: LD_VAR 0 2
68894: ARRAY
68895: ST_TO_ADDR
// if not i then
68896: LD_VAR 0 5
68900: NOT
68901: IFFALSE 68905
// exit ;
68903: GO 68971
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68905: LD_ADDR_VAR 0 1
68909: PUSH
68910: LD_VAR 0 1
68914: PPUSH
68915: LD_VAR 0 2
68919: PPUSH
68920: LD_VAR 0 1
68924: PUSH
68925: LD_VAR 0 3
68929: ARRAY
68930: PPUSH
68931: CALL_OW 1
68935: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68936: LD_ADDR_VAR 0 1
68940: PUSH
68941: LD_VAR 0 1
68945: PPUSH
68946: LD_VAR 0 3
68950: PPUSH
68951: LD_VAR 0 5
68955: PPUSH
68956: CALL_OW 1
68960: ST_TO_ADDR
// result := list ;
68961: LD_ADDR_VAR 0 4
68965: PUSH
68966: LD_VAR 0 1
68970: ST_TO_ADDR
// end ;
68971: LD_VAR 0 4
68975: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68976: LD_INT 0
68978: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68979: LD_ADDR_VAR 0 5
68983: PUSH
68984: LD_VAR 0 1
68988: PPUSH
68989: CALL_OW 250
68993: PPUSH
68994: LD_VAR 0 1
68998: PPUSH
68999: CALL_OW 251
69003: PPUSH
69004: LD_VAR 0 2
69008: PPUSH
69009: LD_VAR 0 3
69013: PPUSH
69014: LD_VAR 0 4
69018: PPUSH
69019: CALL 69029 0 5
69023: ST_TO_ADDR
// end ;
69024: LD_VAR 0 5
69028: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
69029: LD_INT 0
69031: PPUSH
69032: PPUSH
69033: PPUSH
69034: PPUSH
// if not list then
69035: LD_VAR 0 3
69039: NOT
69040: IFFALSE 69044
// exit ;
69042: GO 69432
// result := [ ] ;
69044: LD_ADDR_VAR 0 6
69048: PUSH
69049: EMPTY
69050: ST_TO_ADDR
// for i in list do
69051: LD_ADDR_VAR 0 7
69055: PUSH
69056: LD_VAR 0 3
69060: PUSH
69061: FOR_IN
69062: IFFALSE 69264
// begin tmp := GetDistUnitXY ( i , x , y ) ;
69064: LD_ADDR_VAR 0 9
69068: PUSH
69069: LD_VAR 0 7
69073: PPUSH
69074: LD_VAR 0 1
69078: PPUSH
69079: LD_VAR 0 2
69083: PPUSH
69084: CALL_OW 297
69088: ST_TO_ADDR
// if not result then
69089: LD_VAR 0 6
69093: NOT
69094: IFFALSE 69120
// result := [ [ i , tmp ] ] else
69096: LD_ADDR_VAR 0 6
69100: PUSH
69101: LD_VAR 0 7
69105: PUSH
69106: LD_VAR 0 9
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: EMPTY
69116: LIST
69117: ST_TO_ADDR
69118: GO 69262
// begin if result [ result ] [ 2 ] < tmp then
69120: LD_VAR 0 6
69124: PUSH
69125: LD_VAR 0 6
69129: ARRAY
69130: PUSH
69131: LD_INT 2
69133: ARRAY
69134: PUSH
69135: LD_VAR 0 9
69139: LESS
69140: IFFALSE 69182
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
69142: LD_ADDR_VAR 0 6
69146: PUSH
69147: LD_VAR 0 6
69151: PPUSH
69152: LD_VAR 0 6
69156: PUSH
69157: LD_INT 1
69159: PLUS
69160: PPUSH
69161: LD_VAR 0 7
69165: PUSH
69166: LD_VAR 0 9
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PPUSH
69175: CALL_OW 2
69179: ST_TO_ADDR
69180: GO 69262
// for j = 1 to result do
69182: LD_ADDR_VAR 0 8
69186: PUSH
69187: DOUBLE
69188: LD_INT 1
69190: DEC
69191: ST_TO_ADDR
69192: LD_VAR 0 6
69196: PUSH
69197: FOR_TO
69198: IFFALSE 69260
// begin if tmp < result [ j ] [ 2 ] then
69200: LD_VAR 0 9
69204: PUSH
69205: LD_VAR 0 6
69209: PUSH
69210: LD_VAR 0 8
69214: ARRAY
69215: PUSH
69216: LD_INT 2
69218: ARRAY
69219: LESS
69220: IFFALSE 69258
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69222: LD_ADDR_VAR 0 6
69226: PUSH
69227: LD_VAR 0 6
69231: PPUSH
69232: LD_VAR 0 8
69236: PPUSH
69237: LD_VAR 0 7
69241: PUSH
69242: LD_VAR 0 9
69246: PUSH
69247: EMPTY
69248: LIST
69249: LIST
69250: PPUSH
69251: CALL_OW 2
69255: ST_TO_ADDR
// break ;
69256: GO 69260
// end ; end ;
69258: GO 69197
69260: POP
69261: POP
// end ; end ;
69262: GO 69061
69264: POP
69265: POP
// if result and not asc then
69266: LD_VAR 0 6
69270: PUSH
69271: LD_VAR 0 4
69275: NOT
69276: AND
69277: IFFALSE 69352
// begin tmp := result ;
69279: LD_ADDR_VAR 0 9
69283: PUSH
69284: LD_VAR 0 6
69288: ST_TO_ADDR
// for i = tmp downto 1 do
69289: LD_ADDR_VAR 0 7
69293: PUSH
69294: DOUBLE
69295: LD_VAR 0 9
69299: INC
69300: ST_TO_ADDR
69301: LD_INT 1
69303: PUSH
69304: FOR_DOWNTO
69305: IFFALSE 69350
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69307: LD_ADDR_VAR 0 6
69311: PUSH
69312: LD_VAR 0 6
69316: PPUSH
69317: LD_VAR 0 9
69321: PUSH
69322: LD_VAR 0 7
69326: MINUS
69327: PUSH
69328: LD_INT 1
69330: PLUS
69331: PPUSH
69332: LD_VAR 0 9
69336: PUSH
69337: LD_VAR 0 7
69341: ARRAY
69342: PPUSH
69343: CALL_OW 1
69347: ST_TO_ADDR
69348: GO 69304
69350: POP
69351: POP
// end ; tmp := [ ] ;
69352: LD_ADDR_VAR 0 9
69356: PUSH
69357: EMPTY
69358: ST_TO_ADDR
// if mode then
69359: LD_VAR 0 5
69363: IFFALSE 69432
// begin for i = 1 to result do
69365: LD_ADDR_VAR 0 7
69369: PUSH
69370: DOUBLE
69371: LD_INT 1
69373: DEC
69374: ST_TO_ADDR
69375: LD_VAR 0 6
69379: PUSH
69380: FOR_TO
69381: IFFALSE 69420
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69383: LD_ADDR_VAR 0 9
69387: PUSH
69388: LD_VAR 0 9
69392: PPUSH
69393: LD_VAR 0 7
69397: PPUSH
69398: LD_VAR 0 6
69402: PUSH
69403: LD_VAR 0 7
69407: ARRAY
69408: PUSH
69409: LD_INT 1
69411: ARRAY
69412: PPUSH
69413: CALL_OW 1
69417: ST_TO_ADDR
69418: GO 69380
69420: POP
69421: POP
// result := tmp ;
69422: LD_ADDR_VAR 0 6
69426: PUSH
69427: LD_VAR 0 9
69431: ST_TO_ADDR
// end ; end ;
69432: LD_VAR 0 6
69436: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69437: LD_INT 0
69439: PPUSH
69440: PPUSH
69441: PPUSH
69442: PPUSH
69443: PPUSH
69444: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69445: LD_ADDR_VAR 0 5
69449: PUSH
69450: LD_INT 0
69452: PUSH
69453: LD_INT 0
69455: PUSH
69456: LD_INT 0
69458: PUSH
69459: EMPTY
69460: PUSH
69461: EMPTY
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: ST_TO_ADDR
// if not x or not y then
69467: LD_VAR 0 2
69471: NOT
69472: PUSH
69473: LD_VAR 0 3
69477: NOT
69478: OR
69479: IFFALSE 69483
// exit ;
69481: GO 71135
// if not range then
69483: LD_VAR 0 4
69487: NOT
69488: IFFALSE 69498
// range := 10 ;
69490: LD_ADDR_VAR 0 4
69494: PUSH
69495: LD_INT 10
69497: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69498: LD_ADDR_VAR 0 8
69502: PUSH
69503: LD_INT 81
69505: PUSH
69506: LD_VAR 0 1
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: LD_INT 92
69517: PUSH
69518: LD_VAR 0 2
69522: PUSH
69523: LD_VAR 0 3
69527: PUSH
69528: LD_VAR 0 4
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 3
69541: PUSH
69542: LD_INT 21
69544: PUSH
69545: LD_INT 3
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: LIST
69560: PPUSH
69561: CALL_OW 69
69565: ST_TO_ADDR
// if not tmp then
69566: LD_VAR 0 8
69570: NOT
69571: IFFALSE 69575
// exit ;
69573: GO 71135
// for i in tmp do
69575: LD_ADDR_VAR 0 6
69579: PUSH
69580: LD_VAR 0 8
69584: PUSH
69585: FOR_IN
69586: IFFALSE 71110
// begin points := [ 0 , 0 , 0 ] ;
69588: LD_ADDR_VAR 0 9
69592: PUSH
69593: LD_INT 0
69595: PUSH
69596: LD_INT 0
69598: PUSH
69599: LD_INT 0
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: LIST
69606: ST_TO_ADDR
// bpoints := 1 ;
69607: LD_ADDR_VAR 0 10
69611: PUSH
69612: LD_INT 1
69614: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69615: LD_VAR 0 6
69619: PPUSH
69620: CALL_OW 247
69624: PUSH
69625: LD_INT 1
69627: DOUBLE
69628: EQUAL
69629: IFTRUE 69633
69631: GO 70211
69633: POP
// begin if GetClass ( i ) = 1 then
69634: LD_VAR 0 6
69638: PPUSH
69639: CALL_OW 257
69643: PUSH
69644: LD_INT 1
69646: EQUAL
69647: IFFALSE 69668
// points := [ 10 , 5 , 3 ] ;
69649: LD_ADDR_VAR 0 9
69653: PUSH
69654: LD_INT 10
69656: PUSH
69657: LD_INT 5
69659: PUSH
69660: LD_INT 3
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: LIST
69667: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69668: LD_VAR 0 6
69672: PPUSH
69673: CALL_OW 257
69677: PUSH
69678: LD_INT 2
69680: PUSH
69681: LD_INT 3
69683: PUSH
69684: LD_INT 4
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: LIST
69691: IN
69692: IFFALSE 69713
// points := [ 3 , 2 , 1 ] ;
69694: LD_ADDR_VAR 0 9
69698: PUSH
69699: LD_INT 3
69701: PUSH
69702: LD_INT 2
69704: PUSH
69705: LD_INT 1
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: LIST
69712: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69713: LD_VAR 0 6
69717: PPUSH
69718: CALL_OW 257
69722: PUSH
69723: LD_INT 5
69725: EQUAL
69726: IFFALSE 69747
// points := [ 130 , 5 , 2 ] ;
69728: LD_ADDR_VAR 0 9
69732: PUSH
69733: LD_INT 130
69735: PUSH
69736: LD_INT 5
69738: PUSH
69739: LD_INT 2
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: LIST
69746: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69747: LD_VAR 0 6
69751: PPUSH
69752: CALL_OW 257
69756: PUSH
69757: LD_INT 8
69759: EQUAL
69760: IFFALSE 69781
// points := [ 35 , 35 , 30 ] ;
69762: LD_ADDR_VAR 0 9
69766: PUSH
69767: LD_INT 35
69769: PUSH
69770: LD_INT 35
69772: PUSH
69773: LD_INT 30
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: LIST
69780: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69781: LD_VAR 0 6
69785: PPUSH
69786: CALL_OW 257
69790: PUSH
69791: LD_INT 9
69793: EQUAL
69794: IFFALSE 69815
// points := [ 20 , 55 , 40 ] ;
69796: LD_ADDR_VAR 0 9
69800: PUSH
69801: LD_INT 20
69803: PUSH
69804: LD_INT 55
69806: PUSH
69807: LD_INT 40
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: LIST
69814: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69815: LD_VAR 0 6
69819: PPUSH
69820: CALL_OW 257
69824: PUSH
69825: LD_INT 12
69827: PUSH
69828: LD_INT 16
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: IN
69835: IFFALSE 69856
// points := [ 5 , 3 , 2 ] ;
69837: LD_ADDR_VAR 0 9
69841: PUSH
69842: LD_INT 5
69844: PUSH
69845: LD_INT 3
69847: PUSH
69848: LD_INT 2
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: LIST
69855: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69856: LD_VAR 0 6
69860: PPUSH
69861: CALL_OW 257
69865: PUSH
69866: LD_INT 17
69868: EQUAL
69869: IFFALSE 69890
// points := [ 100 , 50 , 75 ] ;
69871: LD_ADDR_VAR 0 9
69875: PUSH
69876: LD_INT 100
69878: PUSH
69879: LD_INT 50
69881: PUSH
69882: LD_INT 75
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: LIST
69889: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69890: LD_VAR 0 6
69894: PPUSH
69895: CALL_OW 257
69899: PUSH
69900: LD_INT 15
69902: EQUAL
69903: IFFALSE 69924
// points := [ 10 , 5 , 3 ] ;
69905: LD_ADDR_VAR 0 9
69909: PUSH
69910: LD_INT 10
69912: PUSH
69913: LD_INT 5
69915: PUSH
69916: LD_INT 3
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: LIST
69923: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69924: LD_VAR 0 6
69928: PPUSH
69929: CALL_OW 257
69933: PUSH
69934: LD_INT 14
69936: EQUAL
69937: IFFALSE 69958
// points := [ 10 , 0 , 0 ] ;
69939: LD_ADDR_VAR 0 9
69943: PUSH
69944: LD_INT 10
69946: PUSH
69947: LD_INT 0
69949: PUSH
69950: LD_INT 0
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: LIST
69957: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69958: LD_VAR 0 6
69962: PPUSH
69963: CALL_OW 257
69967: PUSH
69968: LD_INT 11
69970: EQUAL
69971: IFFALSE 69992
// points := [ 30 , 10 , 5 ] ;
69973: LD_ADDR_VAR 0 9
69977: PUSH
69978: LD_INT 30
69980: PUSH
69981: LD_INT 10
69983: PUSH
69984: LD_INT 5
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: LIST
69991: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69992: LD_VAR 0 1
69996: PPUSH
69997: LD_INT 5
69999: PPUSH
70000: CALL_OW 321
70004: PUSH
70005: LD_INT 2
70007: EQUAL
70008: IFFALSE 70025
// bpoints := bpoints * 1.8 ;
70010: LD_ADDR_VAR 0 10
70014: PUSH
70015: LD_VAR 0 10
70019: PUSH
70020: LD_REAL  1.80000000000000E+0000
70023: MUL
70024: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
70025: LD_VAR 0 6
70029: PPUSH
70030: CALL_OW 257
70034: PUSH
70035: LD_INT 1
70037: PUSH
70038: LD_INT 2
70040: PUSH
70041: LD_INT 3
70043: PUSH
70044: LD_INT 4
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: IN
70053: PUSH
70054: LD_VAR 0 1
70058: PPUSH
70059: LD_INT 51
70061: PPUSH
70062: CALL_OW 321
70066: PUSH
70067: LD_INT 2
70069: EQUAL
70070: AND
70071: IFFALSE 70088
// bpoints := bpoints * 1.2 ;
70073: LD_ADDR_VAR 0 10
70077: PUSH
70078: LD_VAR 0 10
70082: PUSH
70083: LD_REAL  1.20000000000000E+0000
70086: MUL
70087: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
70088: LD_VAR 0 6
70092: PPUSH
70093: CALL_OW 257
70097: PUSH
70098: LD_INT 5
70100: PUSH
70101: LD_INT 7
70103: PUSH
70104: LD_INT 9
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: LIST
70111: IN
70112: PUSH
70113: LD_VAR 0 1
70117: PPUSH
70118: LD_INT 52
70120: PPUSH
70121: CALL_OW 321
70125: PUSH
70126: LD_INT 2
70128: EQUAL
70129: AND
70130: IFFALSE 70147
// bpoints := bpoints * 1.5 ;
70132: LD_ADDR_VAR 0 10
70136: PUSH
70137: LD_VAR 0 10
70141: PUSH
70142: LD_REAL  1.50000000000000E+0000
70145: MUL
70146: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
70147: LD_VAR 0 1
70151: PPUSH
70152: LD_INT 66
70154: PPUSH
70155: CALL_OW 321
70159: PUSH
70160: LD_INT 2
70162: EQUAL
70163: IFFALSE 70180
// bpoints := bpoints * 1.1 ;
70165: LD_ADDR_VAR 0 10
70169: PUSH
70170: LD_VAR 0 10
70174: PUSH
70175: LD_REAL  1.10000000000000E+0000
70178: MUL
70179: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
70180: LD_ADDR_VAR 0 10
70184: PUSH
70185: LD_VAR 0 10
70189: PUSH
70190: LD_VAR 0 6
70194: PPUSH
70195: LD_INT 1
70197: PPUSH
70198: CALL_OW 259
70202: PUSH
70203: LD_REAL  1.15000000000000E+0000
70206: MUL
70207: MUL
70208: ST_TO_ADDR
// end ; unit_vehicle :
70209: GO 71039
70211: LD_INT 2
70213: DOUBLE
70214: EQUAL
70215: IFTRUE 70219
70217: GO 71027
70219: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70220: LD_VAR 0 6
70224: PPUSH
70225: CALL_OW 264
70229: PUSH
70230: LD_INT 2
70232: PUSH
70233: LD_INT 42
70235: PUSH
70236: LD_INT 24
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: LIST
70243: IN
70244: IFFALSE 70265
// points := [ 25 , 5 , 3 ] ;
70246: LD_ADDR_VAR 0 9
70250: PUSH
70251: LD_INT 25
70253: PUSH
70254: LD_INT 5
70256: PUSH
70257: LD_INT 3
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: LIST
70264: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70265: LD_VAR 0 6
70269: PPUSH
70270: CALL_OW 264
70274: PUSH
70275: LD_INT 4
70277: PUSH
70278: LD_INT 43
70280: PUSH
70281: LD_INT 25
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: LIST
70288: IN
70289: IFFALSE 70310
// points := [ 40 , 15 , 5 ] ;
70291: LD_ADDR_VAR 0 9
70295: PUSH
70296: LD_INT 40
70298: PUSH
70299: LD_INT 15
70301: PUSH
70302: LD_INT 5
70304: PUSH
70305: EMPTY
70306: LIST
70307: LIST
70308: LIST
70309: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70310: LD_VAR 0 6
70314: PPUSH
70315: CALL_OW 264
70319: PUSH
70320: LD_INT 3
70322: PUSH
70323: LD_INT 23
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: IN
70330: IFFALSE 70351
// points := [ 7 , 25 , 8 ] ;
70332: LD_ADDR_VAR 0 9
70336: PUSH
70337: LD_INT 7
70339: PUSH
70340: LD_INT 25
70342: PUSH
70343: LD_INT 8
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: LIST
70350: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70351: LD_VAR 0 6
70355: PPUSH
70356: CALL_OW 264
70360: PUSH
70361: LD_INT 5
70363: PUSH
70364: LD_INT 27
70366: PUSH
70367: LD_INT 44
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: LIST
70374: IN
70375: IFFALSE 70396
// points := [ 14 , 50 , 16 ] ;
70377: LD_ADDR_VAR 0 9
70381: PUSH
70382: LD_INT 14
70384: PUSH
70385: LD_INT 50
70387: PUSH
70388: LD_INT 16
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: LIST
70395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70396: LD_VAR 0 6
70400: PPUSH
70401: CALL_OW 264
70405: PUSH
70406: LD_INT 6
70408: PUSH
70409: LD_INT 46
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: IN
70416: IFFALSE 70437
// points := [ 32 , 120 , 70 ] ;
70418: LD_ADDR_VAR 0 9
70422: PUSH
70423: LD_INT 32
70425: PUSH
70426: LD_INT 120
70428: PUSH
70429: LD_INT 70
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: LIST
70436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
70437: LD_VAR 0 6
70441: PPUSH
70442: CALL_OW 264
70446: PUSH
70447: LD_INT 7
70449: PUSH
70450: LD_INT 28
70452: PUSH
70453: LD_INT 45
70455: PUSH
70456: LD_EXP 78
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: IN
70467: IFFALSE 70488
// points := [ 35 , 20 , 45 ] ;
70469: LD_ADDR_VAR 0 9
70473: PUSH
70474: LD_INT 35
70476: PUSH
70477: LD_INT 20
70479: PUSH
70480: LD_INT 45
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: LIST
70487: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70488: LD_VAR 0 6
70492: PPUSH
70493: CALL_OW 264
70497: PUSH
70498: LD_INT 47
70500: PUSH
70501: EMPTY
70502: LIST
70503: IN
70504: IFFALSE 70525
// points := [ 67 , 45 , 75 ] ;
70506: LD_ADDR_VAR 0 9
70510: PUSH
70511: LD_INT 67
70513: PUSH
70514: LD_INT 45
70516: PUSH
70517: LD_INT 75
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: LIST
70524: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70525: LD_VAR 0 6
70529: PPUSH
70530: CALL_OW 264
70534: PUSH
70535: LD_INT 26
70537: PUSH
70538: EMPTY
70539: LIST
70540: IN
70541: IFFALSE 70562
// points := [ 120 , 30 , 80 ] ;
70543: LD_ADDR_VAR 0 9
70547: PUSH
70548: LD_INT 120
70550: PUSH
70551: LD_INT 30
70553: PUSH
70554: LD_INT 80
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: LIST
70561: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70562: LD_VAR 0 6
70566: PPUSH
70567: CALL_OW 264
70571: PUSH
70572: LD_INT 22
70574: PUSH
70575: EMPTY
70576: LIST
70577: IN
70578: IFFALSE 70599
// points := [ 40 , 1 , 1 ] ;
70580: LD_ADDR_VAR 0 9
70584: PUSH
70585: LD_INT 40
70587: PUSH
70588: LD_INT 1
70590: PUSH
70591: LD_INT 1
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: LIST
70598: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70599: LD_VAR 0 6
70603: PPUSH
70604: CALL_OW 264
70608: PUSH
70609: LD_INT 29
70611: PUSH
70612: EMPTY
70613: LIST
70614: IN
70615: IFFALSE 70636
// points := [ 70 , 200 , 400 ] ;
70617: LD_ADDR_VAR 0 9
70621: PUSH
70622: LD_INT 70
70624: PUSH
70625: LD_INT 200
70627: PUSH
70628: LD_INT 400
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: LIST
70635: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70636: LD_VAR 0 6
70640: PPUSH
70641: CALL_OW 264
70645: PUSH
70646: LD_INT 14
70648: PUSH
70649: LD_INT 53
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: IN
70656: IFFALSE 70677
// points := [ 40 , 10 , 20 ] ;
70658: LD_ADDR_VAR 0 9
70662: PUSH
70663: LD_INT 40
70665: PUSH
70666: LD_INT 10
70668: PUSH
70669: LD_INT 20
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: LIST
70676: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70677: LD_VAR 0 6
70681: PPUSH
70682: CALL_OW 264
70686: PUSH
70687: LD_INT 9
70689: PUSH
70690: EMPTY
70691: LIST
70692: IN
70693: IFFALSE 70714
// points := [ 5 , 70 , 20 ] ;
70695: LD_ADDR_VAR 0 9
70699: PUSH
70700: LD_INT 5
70702: PUSH
70703: LD_INT 70
70705: PUSH
70706: LD_INT 20
70708: PUSH
70709: EMPTY
70710: LIST
70711: LIST
70712: LIST
70713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70714: LD_VAR 0 6
70718: PPUSH
70719: CALL_OW 264
70723: PUSH
70724: LD_INT 10
70726: PUSH
70727: EMPTY
70728: LIST
70729: IN
70730: IFFALSE 70751
// points := [ 35 , 110 , 70 ] ;
70732: LD_ADDR_VAR 0 9
70736: PUSH
70737: LD_INT 35
70739: PUSH
70740: LD_INT 110
70742: PUSH
70743: LD_INT 70
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: LIST
70750: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70751: LD_VAR 0 6
70755: PPUSH
70756: CALL_OW 265
70760: PUSH
70761: LD_INT 25
70763: EQUAL
70764: IFFALSE 70785
// points := [ 80 , 65 , 100 ] ;
70766: LD_ADDR_VAR 0 9
70770: PUSH
70771: LD_INT 80
70773: PUSH
70774: LD_INT 65
70776: PUSH
70777: LD_INT 100
70779: PUSH
70780: EMPTY
70781: LIST
70782: LIST
70783: LIST
70784: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70785: LD_VAR 0 6
70789: PPUSH
70790: CALL_OW 263
70794: PUSH
70795: LD_INT 1
70797: EQUAL
70798: IFFALSE 70833
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70800: LD_ADDR_VAR 0 10
70804: PUSH
70805: LD_VAR 0 10
70809: PUSH
70810: LD_VAR 0 6
70814: PPUSH
70815: CALL_OW 311
70819: PPUSH
70820: LD_INT 3
70822: PPUSH
70823: CALL_OW 259
70827: PUSH
70828: LD_INT 4
70830: MUL
70831: MUL
70832: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70833: LD_VAR 0 6
70837: PPUSH
70838: CALL_OW 263
70842: PUSH
70843: LD_INT 2
70845: EQUAL
70846: IFFALSE 70897
// begin j := IsControledBy ( i ) ;
70848: LD_ADDR_VAR 0 7
70852: PUSH
70853: LD_VAR 0 6
70857: PPUSH
70858: CALL_OW 312
70862: ST_TO_ADDR
// if j then
70863: LD_VAR 0 7
70867: IFFALSE 70897
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70869: LD_ADDR_VAR 0 10
70873: PUSH
70874: LD_VAR 0 10
70878: PUSH
70879: LD_VAR 0 7
70883: PPUSH
70884: LD_INT 3
70886: PPUSH
70887: CALL_OW 259
70891: PUSH
70892: LD_INT 3
70894: MUL
70895: MUL
70896: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70897: LD_VAR 0 6
70901: PPUSH
70902: CALL_OW 264
70906: PUSH
70907: LD_INT 5
70909: PUSH
70910: LD_INT 6
70912: PUSH
70913: LD_INT 46
70915: PUSH
70916: LD_INT 44
70918: PUSH
70919: LD_INT 47
70921: PUSH
70922: LD_INT 45
70924: PUSH
70925: LD_INT 28
70927: PUSH
70928: LD_INT 7
70930: PUSH
70931: LD_INT 27
70933: PUSH
70934: LD_INT 29
70936: PUSH
70937: EMPTY
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: IN
70949: PUSH
70950: LD_VAR 0 1
70954: PPUSH
70955: LD_INT 52
70957: PPUSH
70958: CALL_OW 321
70962: PUSH
70963: LD_INT 2
70965: EQUAL
70966: AND
70967: IFFALSE 70984
// bpoints := bpoints * 1.2 ;
70969: LD_ADDR_VAR 0 10
70973: PUSH
70974: LD_VAR 0 10
70978: PUSH
70979: LD_REAL  1.20000000000000E+0000
70982: MUL
70983: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70984: LD_VAR 0 6
70988: PPUSH
70989: CALL_OW 264
70993: PUSH
70994: LD_INT 6
70996: PUSH
70997: LD_INT 46
70999: PUSH
71000: LD_INT 47
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: LIST
71007: IN
71008: IFFALSE 71025
// bpoints := bpoints * 1.2 ;
71010: LD_ADDR_VAR 0 10
71014: PUSH
71015: LD_VAR 0 10
71019: PUSH
71020: LD_REAL  1.20000000000000E+0000
71023: MUL
71024: ST_TO_ADDR
// end ; unit_building :
71025: GO 71039
71027: LD_INT 3
71029: DOUBLE
71030: EQUAL
71031: IFTRUE 71035
71033: GO 71038
71035: POP
// ; end ;
71036: GO 71039
71038: POP
// for j = 1 to 3 do
71039: LD_ADDR_VAR 0 7
71043: PUSH
71044: DOUBLE
71045: LD_INT 1
71047: DEC
71048: ST_TO_ADDR
71049: LD_INT 3
71051: PUSH
71052: FOR_TO
71053: IFFALSE 71106
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
71055: LD_ADDR_VAR 0 5
71059: PUSH
71060: LD_VAR 0 5
71064: PPUSH
71065: LD_VAR 0 7
71069: PPUSH
71070: LD_VAR 0 5
71074: PUSH
71075: LD_VAR 0 7
71079: ARRAY
71080: PUSH
71081: LD_VAR 0 9
71085: PUSH
71086: LD_VAR 0 7
71090: ARRAY
71091: PUSH
71092: LD_VAR 0 10
71096: MUL
71097: PLUS
71098: PPUSH
71099: CALL_OW 1
71103: ST_TO_ADDR
71104: GO 71052
71106: POP
71107: POP
// end ;
71108: GO 69585
71110: POP
71111: POP
// result := Replace ( result , 4 , tmp ) ;
71112: LD_ADDR_VAR 0 5
71116: PUSH
71117: LD_VAR 0 5
71121: PPUSH
71122: LD_INT 4
71124: PPUSH
71125: LD_VAR 0 8
71129: PPUSH
71130: CALL_OW 1
71134: ST_TO_ADDR
// end ;
71135: LD_VAR 0 5
71139: RET
// export function DangerAtRange ( unit , range ) ; begin
71140: LD_INT 0
71142: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
71143: LD_ADDR_VAR 0 3
71147: PUSH
71148: LD_VAR 0 1
71152: PPUSH
71153: CALL_OW 255
71157: PPUSH
71158: LD_VAR 0 1
71162: PPUSH
71163: CALL_OW 250
71167: PPUSH
71168: LD_VAR 0 1
71172: PPUSH
71173: CALL_OW 251
71177: PPUSH
71178: LD_VAR 0 2
71182: PPUSH
71183: CALL 69437 0 4
71187: ST_TO_ADDR
// end ;
71188: LD_VAR 0 3
71192: RET
// export function DangerInArea ( side , area ) ; begin
71193: LD_INT 0
71195: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71196: LD_ADDR_VAR 0 3
71200: PUSH
71201: LD_VAR 0 2
71205: PPUSH
71206: LD_INT 81
71208: PUSH
71209: LD_VAR 0 1
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: PPUSH
71218: CALL_OW 70
71222: ST_TO_ADDR
// end ;
71223: LD_VAR 0 3
71227: RET
// export function IsExtension ( b ) ; begin
71228: LD_INT 0
71230: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71231: LD_ADDR_VAR 0 2
71235: PUSH
71236: LD_VAR 0 1
71240: PUSH
71241: LD_INT 23
71243: PUSH
71244: LD_INT 20
71246: PUSH
71247: LD_INT 22
71249: PUSH
71250: LD_INT 17
71252: PUSH
71253: LD_INT 24
71255: PUSH
71256: LD_INT 21
71258: PUSH
71259: LD_INT 19
71261: PUSH
71262: LD_INT 16
71264: PUSH
71265: LD_INT 25
71267: PUSH
71268: LD_INT 18
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: LIST
71282: IN
71283: ST_TO_ADDR
// end ;
71284: LD_VAR 0 2
71288: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71289: LD_INT 0
71291: PPUSH
71292: PPUSH
71293: PPUSH
// result := [ ] ;
71294: LD_ADDR_VAR 0 4
71298: PUSH
71299: EMPTY
71300: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71301: LD_ADDR_VAR 0 5
71305: PUSH
71306: LD_VAR 0 2
71310: PPUSH
71311: LD_INT 21
71313: PUSH
71314: LD_INT 3
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PPUSH
71321: CALL_OW 70
71325: ST_TO_ADDR
// if not tmp then
71326: LD_VAR 0 5
71330: NOT
71331: IFFALSE 71335
// exit ;
71333: GO 71399
// if checkLink then
71335: LD_VAR 0 3
71339: IFFALSE 71389
// begin for i in tmp do
71341: LD_ADDR_VAR 0 6
71345: PUSH
71346: LD_VAR 0 5
71350: PUSH
71351: FOR_IN
71352: IFFALSE 71387
// if GetBase ( i ) <> base then
71354: LD_VAR 0 6
71358: PPUSH
71359: CALL_OW 274
71363: PUSH
71364: LD_VAR 0 1
71368: NONEQUAL
71369: IFFALSE 71385
// ComLinkToBase ( base , i ) ;
71371: LD_VAR 0 1
71375: PPUSH
71376: LD_VAR 0 6
71380: PPUSH
71381: CALL_OW 169
71385: GO 71351
71387: POP
71388: POP
// end ; result := tmp ;
71389: LD_ADDR_VAR 0 4
71393: PUSH
71394: LD_VAR 0 5
71398: ST_TO_ADDR
// end ;
71399: LD_VAR 0 4
71403: RET
// export function ComComplete ( units , b ) ; var i ; begin
71404: LD_INT 0
71406: PPUSH
71407: PPUSH
// if not units then
71408: LD_VAR 0 1
71412: NOT
71413: IFFALSE 71417
// exit ;
71415: GO 71507
// for i in units do
71417: LD_ADDR_VAR 0 4
71421: PUSH
71422: LD_VAR 0 1
71426: PUSH
71427: FOR_IN
71428: IFFALSE 71505
// if BuildingStatus ( b ) = bs_build then
71430: LD_VAR 0 2
71434: PPUSH
71435: CALL_OW 461
71439: PUSH
71440: LD_INT 1
71442: EQUAL
71443: IFFALSE 71503
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71445: LD_VAR 0 4
71449: PPUSH
71450: LD_STRING h
71452: PUSH
71453: LD_VAR 0 2
71457: PPUSH
71458: CALL_OW 250
71462: PUSH
71463: LD_VAR 0 2
71467: PPUSH
71468: CALL_OW 251
71472: PUSH
71473: LD_VAR 0 2
71477: PUSH
71478: LD_INT 0
71480: PUSH
71481: LD_INT 0
71483: PUSH
71484: LD_INT 0
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: PUSH
71496: EMPTY
71497: LIST
71498: PPUSH
71499: CALL_OW 446
71503: GO 71427
71505: POP
71506: POP
// end ;
71507: LD_VAR 0 3
71511: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71512: LD_INT 0
71514: PPUSH
71515: PPUSH
71516: PPUSH
71517: PPUSH
71518: PPUSH
71519: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
71520: LD_VAR 0 1
71524: NOT
71525: PUSH
71526: LD_VAR 0 1
71530: PPUSH
71531: CALL_OW 263
71535: PUSH
71536: LD_INT 2
71538: NONEQUAL
71539: OR
71540: IFFALSE 71544
// exit ;
71542: GO 71860
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71544: LD_ADDR_VAR 0 6
71548: PUSH
71549: LD_INT 22
71551: PUSH
71552: LD_VAR 0 1
71556: PPUSH
71557: CALL_OW 255
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 2
71568: PUSH
71569: LD_INT 30
71571: PUSH
71572: LD_INT 36
71574: PUSH
71575: EMPTY
71576: LIST
71577: LIST
71578: PUSH
71579: LD_INT 34
71581: PUSH
71582: LD_INT 31
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: LIST
71593: PUSH
71594: EMPTY
71595: LIST
71596: LIST
71597: PPUSH
71598: CALL_OW 69
71602: ST_TO_ADDR
// if not tmp then
71603: LD_VAR 0 6
71607: NOT
71608: IFFALSE 71612
// exit ;
71610: GO 71860
// result := [ ] ;
71612: LD_ADDR_VAR 0 2
71616: PUSH
71617: EMPTY
71618: ST_TO_ADDR
// for i in tmp do
71619: LD_ADDR_VAR 0 3
71623: PUSH
71624: LD_VAR 0 6
71628: PUSH
71629: FOR_IN
71630: IFFALSE 71701
// begin t := UnitsInside ( i ) ;
71632: LD_ADDR_VAR 0 4
71636: PUSH
71637: LD_VAR 0 3
71641: PPUSH
71642: CALL_OW 313
71646: ST_TO_ADDR
// if t then
71647: LD_VAR 0 4
71651: IFFALSE 71699
// for j in t do
71653: LD_ADDR_VAR 0 7
71657: PUSH
71658: LD_VAR 0 4
71662: PUSH
71663: FOR_IN
71664: IFFALSE 71697
// result := Replace ( result , result + 1 , j ) ;
71666: LD_ADDR_VAR 0 2
71670: PUSH
71671: LD_VAR 0 2
71675: PPUSH
71676: LD_VAR 0 2
71680: PUSH
71681: LD_INT 1
71683: PLUS
71684: PPUSH
71685: LD_VAR 0 7
71689: PPUSH
71690: CALL_OW 1
71694: ST_TO_ADDR
71695: GO 71663
71697: POP
71698: POP
// end ;
71699: GO 71629
71701: POP
71702: POP
// if not result then
71703: LD_VAR 0 2
71707: NOT
71708: IFFALSE 71712
// exit ;
71710: GO 71860
// mech := result [ 1 ] ;
71712: LD_ADDR_VAR 0 5
71716: PUSH
71717: LD_VAR 0 2
71721: PUSH
71722: LD_INT 1
71724: ARRAY
71725: ST_TO_ADDR
// if result > 1 then
71726: LD_VAR 0 2
71730: PUSH
71731: LD_INT 1
71733: GREATER
71734: IFFALSE 71846
// begin for i = 2 to result do
71736: LD_ADDR_VAR 0 3
71740: PUSH
71741: DOUBLE
71742: LD_INT 2
71744: DEC
71745: ST_TO_ADDR
71746: LD_VAR 0 2
71750: PUSH
71751: FOR_TO
71752: IFFALSE 71844
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71754: LD_ADDR_VAR 0 4
71758: PUSH
71759: LD_VAR 0 2
71763: PUSH
71764: LD_VAR 0 3
71768: ARRAY
71769: PPUSH
71770: LD_INT 3
71772: PPUSH
71773: CALL_OW 259
71777: PUSH
71778: LD_VAR 0 2
71782: PUSH
71783: LD_VAR 0 3
71787: ARRAY
71788: PPUSH
71789: CALL_OW 432
71793: MINUS
71794: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71795: LD_VAR 0 4
71799: PUSH
71800: LD_VAR 0 5
71804: PPUSH
71805: LD_INT 3
71807: PPUSH
71808: CALL_OW 259
71812: PUSH
71813: LD_VAR 0 5
71817: PPUSH
71818: CALL_OW 432
71822: MINUS
71823: GREATEREQUAL
71824: IFFALSE 71842
// mech := result [ i ] ;
71826: LD_ADDR_VAR 0 5
71830: PUSH
71831: LD_VAR 0 2
71835: PUSH
71836: LD_VAR 0 3
71840: ARRAY
71841: ST_TO_ADDR
// end ;
71842: GO 71751
71844: POP
71845: POP
// end ; ComLinkTo ( vehicle , mech ) ;
71846: LD_VAR 0 1
71850: PPUSH
71851: LD_VAR 0 5
71855: PPUSH
71856: CALL_OW 135
// end ;
71860: LD_VAR 0 2
71864: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71865: LD_INT 0
71867: PPUSH
71868: PPUSH
71869: PPUSH
71870: PPUSH
71871: PPUSH
71872: PPUSH
71873: PPUSH
71874: PPUSH
71875: PPUSH
71876: PPUSH
71877: PPUSH
71878: PPUSH
71879: PPUSH
// result := [ ] ;
71880: LD_ADDR_VAR 0 7
71884: PUSH
71885: EMPTY
71886: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71887: LD_VAR 0 1
71891: PPUSH
71892: CALL_OW 266
71896: PUSH
71897: LD_INT 0
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: IN
71907: NOT
71908: IFFALSE 71912
// exit ;
71910: GO 73546
// if name then
71912: LD_VAR 0 3
71916: IFFALSE 71932
// SetBName ( base_dep , name ) ;
71918: LD_VAR 0 1
71922: PPUSH
71923: LD_VAR 0 3
71927: PPUSH
71928: CALL_OW 500
// base := GetBase ( base_dep ) ;
71932: LD_ADDR_VAR 0 15
71936: PUSH
71937: LD_VAR 0 1
71941: PPUSH
71942: CALL_OW 274
71946: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71947: LD_ADDR_VAR 0 16
71951: PUSH
71952: LD_VAR 0 1
71956: PPUSH
71957: CALL_OW 255
71961: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71962: LD_ADDR_VAR 0 17
71966: PUSH
71967: LD_VAR 0 1
71971: PPUSH
71972: CALL_OW 248
71976: ST_TO_ADDR
// if sources then
71977: LD_VAR 0 5
71981: IFFALSE 72028
// for i = 1 to 3 do
71983: LD_ADDR_VAR 0 8
71987: PUSH
71988: DOUBLE
71989: LD_INT 1
71991: DEC
71992: ST_TO_ADDR
71993: LD_INT 3
71995: PUSH
71996: FOR_TO
71997: IFFALSE 72026
// AddResourceType ( base , i , sources [ i ] ) ;
71999: LD_VAR 0 15
72003: PPUSH
72004: LD_VAR 0 8
72008: PPUSH
72009: LD_VAR 0 5
72013: PUSH
72014: LD_VAR 0 8
72018: ARRAY
72019: PPUSH
72020: CALL_OW 276
72024: GO 71996
72026: POP
72027: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
72028: LD_ADDR_VAR 0 18
72032: PUSH
72033: LD_VAR 0 15
72037: PPUSH
72038: LD_VAR 0 2
72042: PPUSH
72043: LD_INT 1
72045: PPUSH
72046: CALL 71289 0 3
72050: ST_TO_ADDR
// InitHc ;
72051: CALL_OW 19
// InitUc ;
72055: CALL_OW 18
// uc_side := side ;
72059: LD_ADDR_OWVAR 20
72063: PUSH
72064: LD_VAR 0 16
72068: ST_TO_ADDR
// uc_nation := nation ;
72069: LD_ADDR_OWVAR 21
72073: PUSH
72074: LD_VAR 0 17
72078: ST_TO_ADDR
// if buildings then
72079: LD_VAR 0 18
72083: IFFALSE 73405
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
72085: LD_ADDR_VAR 0 19
72089: PUSH
72090: LD_VAR 0 18
72094: PPUSH
72095: LD_INT 2
72097: PUSH
72098: LD_INT 30
72100: PUSH
72101: LD_INT 29
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 30
72110: PUSH
72111: LD_INT 30
72113: PUSH
72114: EMPTY
72115: LIST
72116: LIST
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: LIST
72122: PPUSH
72123: CALL_OW 72
72127: ST_TO_ADDR
// if tmp then
72128: LD_VAR 0 19
72132: IFFALSE 72180
// for i in tmp do
72134: LD_ADDR_VAR 0 8
72138: PUSH
72139: LD_VAR 0 19
72143: PUSH
72144: FOR_IN
72145: IFFALSE 72178
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
72147: LD_VAR 0 8
72151: PPUSH
72152: CALL_OW 250
72156: PPUSH
72157: LD_VAR 0 8
72161: PPUSH
72162: CALL_OW 251
72166: PPUSH
72167: LD_VAR 0 16
72171: PPUSH
72172: CALL_OW 441
72176: GO 72144
72178: POP
72179: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
72180: LD_VAR 0 18
72184: PPUSH
72185: LD_INT 2
72187: PUSH
72188: LD_INT 30
72190: PUSH
72191: LD_INT 32
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 30
72200: PUSH
72201: LD_INT 33
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: LIST
72212: PPUSH
72213: CALL_OW 72
72217: IFFALSE 72305
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72219: LD_ADDR_VAR 0 8
72223: PUSH
72224: LD_VAR 0 18
72228: PPUSH
72229: LD_INT 2
72231: PUSH
72232: LD_INT 30
72234: PUSH
72235: LD_INT 32
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 30
72244: PUSH
72245: LD_INT 33
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: LIST
72256: PPUSH
72257: CALL_OW 72
72261: PUSH
72262: FOR_IN
72263: IFFALSE 72303
// begin if not GetBWeapon ( i ) then
72265: LD_VAR 0 8
72269: PPUSH
72270: CALL_OW 269
72274: NOT
72275: IFFALSE 72301
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72277: LD_VAR 0 8
72281: PPUSH
72282: LD_VAR 0 8
72286: PPUSH
72287: LD_VAR 0 2
72291: PPUSH
72292: CALL 73551 0 2
72296: PPUSH
72297: CALL_OW 431
// end ;
72301: GO 72262
72303: POP
72304: POP
// end ; for i = 1 to personel do
72305: LD_ADDR_VAR 0 8
72309: PUSH
72310: DOUBLE
72311: LD_INT 1
72313: DEC
72314: ST_TO_ADDR
72315: LD_VAR 0 6
72319: PUSH
72320: FOR_TO
72321: IFFALSE 73385
// begin if i > 4 then
72323: LD_VAR 0 8
72327: PUSH
72328: LD_INT 4
72330: GREATER
72331: IFFALSE 72335
// break ;
72333: GO 73385
// case i of 1 :
72335: LD_VAR 0 8
72339: PUSH
72340: LD_INT 1
72342: DOUBLE
72343: EQUAL
72344: IFTRUE 72348
72346: GO 72428
72348: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72349: LD_ADDR_VAR 0 12
72353: PUSH
72354: LD_VAR 0 18
72358: PPUSH
72359: LD_INT 22
72361: PUSH
72362: LD_VAR 0 16
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 58
72373: PUSH
72374: EMPTY
72375: LIST
72376: PUSH
72377: LD_INT 2
72379: PUSH
72380: LD_INT 30
72382: PUSH
72383: LD_INT 32
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: PUSH
72390: LD_INT 30
72392: PUSH
72393: LD_INT 4
72395: PUSH
72396: EMPTY
72397: LIST
72398: LIST
72399: PUSH
72400: LD_INT 30
72402: PUSH
72403: LD_INT 5
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: LIST
72420: PPUSH
72421: CALL_OW 72
72425: ST_TO_ADDR
72426: GO 72650
72428: LD_INT 2
72430: DOUBLE
72431: EQUAL
72432: IFTRUE 72436
72434: GO 72498
72436: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72437: LD_ADDR_VAR 0 12
72441: PUSH
72442: LD_VAR 0 18
72446: PPUSH
72447: LD_INT 22
72449: PUSH
72450: LD_VAR 0 16
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 2
72461: PUSH
72462: LD_INT 30
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: PUSH
72472: LD_INT 30
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: LIST
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PPUSH
72491: CALL_OW 72
72495: ST_TO_ADDR
72496: GO 72650
72498: LD_INT 3
72500: DOUBLE
72501: EQUAL
72502: IFTRUE 72506
72504: GO 72568
72506: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72507: LD_ADDR_VAR 0 12
72511: PUSH
72512: LD_VAR 0 18
72516: PPUSH
72517: LD_INT 22
72519: PUSH
72520: LD_VAR 0 16
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 2
72531: PUSH
72532: LD_INT 30
72534: PUSH
72535: LD_INT 2
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 30
72544: PUSH
72545: LD_INT 3
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: LIST
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PPUSH
72561: CALL_OW 72
72565: ST_TO_ADDR
72566: GO 72650
72568: LD_INT 4
72570: DOUBLE
72571: EQUAL
72572: IFTRUE 72576
72574: GO 72649
72576: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72577: LD_ADDR_VAR 0 12
72581: PUSH
72582: LD_VAR 0 18
72586: PPUSH
72587: LD_INT 22
72589: PUSH
72590: LD_VAR 0 16
72594: PUSH
72595: EMPTY
72596: LIST
72597: LIST
72598: PUSH
72599: LD_INT 2
72601: PUSH
72602: LD_INT 30
72604: PUSH
72605: LD_INT 6
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 30
72614: PUSH
72615: LD_INT 7
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: PUSH
72622: LD_INT 30
72624: PUSH
72625: LD_INT 8
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PPUSH
72642: CALL_OW 72
72646: ST_TO_ADDR
72647: GO 72650
72649: POP
// if i = 1 then
72650: LD_VAR 0 8
72654: PUSH
72655: LD_INT 1
72657: EQUAL
72658: IFFALSE 72769
// begin tmp := [ ] ;
72660: LD_ADDR_VAR 0 19
72664: PUSH
72665: EMPTY
72666: ST_TO_ADDR
// for j in f do
72667: LD_ADDR_VAR 0 9
72671: PUSH
72672: LD_VAR 0 12
72676: PUSH
72677: FOR_IN
72678: IFFALSE 72751
// if GetBType ( j ) = b_bunker then
72680: LD_VAR 0 9
72684: PPUSH
72685: CALL_OW 266
72689: PUSH
72690: LD_INT 32
72692: EQUAL
72693: IFFALSE 72720
// tmp := Insert ( tmp , 1 , j ) else
72695: LD_ADDR_VAR 0 19
72699: PUSH
72700: LD_VAR 0 19
72704: PPUSH
72705: LD_INT 1
72707: PPUSH
72708: LD_VAR 0 9
72712: PPUSH
72713: CALL_OW 2
72717: ST_TO_ADDR
72718: GO 72749
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72720: LD_ADDR_VAR 0 19
72724: PUSH
72725: LD_VAR 0 19
72729: PPUSH
72730: LD_VAR 0 19
72734: PUSH
72735: LD_INT 1
72737: PLUS
72738: PPUSH
72739: LD_VAR 0 9
72743: PPUSH
72744: CALL_OW 2
72748: ST_TO_ADDR
72749: GO 72677
72751: POP
72752: POP
// if tmp then
72753: LD_VAR 0 19
72757: IFFALSE 72769
// f := tmp ;
72759: LD_ADDR_VAR 0 12
72763: PUSH
72764: LD_VAR 0 19
72768: ST_TO_ADDR
// end ; x := personel [ i ] ;
72769: LD_ADDR_VAR 0 13
72773: PUSH
72774: LD_VAR 0 6
72778: PUSH
72779: LD_VAR 0 8
72783: ARRAY
72784: ST_TO_ADDR
// if x = - 1 then
72785: LD_VAR 0 13
72789: PUSH
72790: LD_INT 1
72792: NEG
72793: EQUAL
72794: IFFALSE 73003
// begin for j in f do
72796: LD_ADDR_VAR 0 9
72800: PUSH
72801: LD_VAR 0 12
72805: PUSH
72806: FOR_IN
72807: IFFALSE 72999
// repeat InitHc ;
72809: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72813: LD_VAR 0 9
72817: PPUSH
72818: CALL_OW 266
72822: PUSH
72823: LD_INT 5
72825: EQUAL
72826: IFFALSE 72896
// begin if UnitsInside ( j ) < 3 then
72828: LD_VAR 0 9
72832: PPUSH
72833: CALL_OW 313
72837: PUSH
72838: LD_INT 3
72840: LESS
72841: IFFALSE 72877
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72843: LD_INT 0
72845: PPUSH
72846: LD_INT 5
72848: PUSH
72849: LD_INT 8
72851: PUSH
72852: LD_INT 9
72854: PUSH
72855: EMPTY
72856: LIST
72857: LIST
72858: LIST
72859: PUSH
72860: LD_VAR 0 17
72864: ARRAY
72865: PPUSH
72866: LD_VAR 0 4
72870: PPUSH
72871: CALL_OW 380
72875: GO 72894
// PrepareHuman ( false , i , skill ) ;
72877: LD_INT 0
72879: PPUSH
72880: LD_VAR 0 8
72884: PPUSH
72885: LD_VAR 0 4
72889: PPUSH
72890: CALL_OW 380
// end else
72894: GO 72913
// PrepareHuman ( false , i , skill ) ;
72896: LD_INT 0
72898: PPUSH
72899: LD_VAR 0 8
72903: PPUSH
72904: LD_VAR 0 4
72908: PPUSH
72909: CALL_OW 380
// un := CreateHuman ;
72913: LD_ADDR_VAR 0 14
72917: PUSH
72918: CALL_OW 44
72922: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72923: LD_ADDR_VAR 0 7
72927: PUSH
72928: LD_VAR 0 7
72932: PPUSH
72933: LD_INT 1
72935: PPUSH
72936: LD_VAR 0 14
72940: PPUSH
72941: CALL_OW 2
72945: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72946: LD_VAR 0 14
72950: PPUSH
72951: LD_VAR 0 9
72955: PPUSH
72956: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72960: LD_VAR 0 9
72964: PPUSH
72965: CALL_OW 313
72969: PUSH
72970: LD_INT 6
72972: EQUAL
72973: PUSH
72974: LD_VAR 0 9
72978: PPUSH
72979: CALL_OW 266
72983: PUSH
72984: LD_INT 32
72986: PUSH
72987: LD_INT 31
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: IN
72994: OR
72995: IFFALSE 72809
72997: GO 72806
72999: POP
73000: POP
// end else
73001: GO 73383
// for j = 1 to x do
73003: LD_ADDR_VAR 0 9
73007: PUSH
73008: DOUBLE
73009: LD_INT 1
73011: DEC
73012: ST_TO_ADDR
73013: LD_VAR 0 13
73017: PUSH
73018: FOR_TO
73019: IFFALSE 73381
// begin InitHc ;
73021: CALL_OW 19
// if not f then
73025: LD_VAR 0 12
73029: NOT
73030: IFFALSE 73119
// begin PrepareHuman ( false , i , skill ) ;
73032: LD_INT 0
73034: PPUSH
73035: LD_VAR 0 8
73039: PPUSH
73040: LD_VAR 0 4
73044: PPUSH
73045: CALL_OW 380
// un := CreateHuman ;
73049: LD_ADDR_VAR 0 14
73053: PUSH
73054: CALL_OW 44
73058: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73059: LD_ADDR_VAR 0 7
73063: PUSH
73064: LD_VAR 0 7
73068: PPUSH
73069: LD_INT 1
73071: PPUSH
73072: LD_VAR 0 14
73076: PPUSH
73077: CALL_OW 2
73081: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73082: LD_VAR 0 14
73086: PPUSH
73087: LD_VAR 0 1
73091: PPUSH
73092: CALL_OW 250
73096: PPUSH
73097: LD_VAR 0 1
73101: PPUSH
73102: CALL_OW 251
73106: PPUSH
73107: LD_INT 10
73109: PPUSH
73110: LD_INT 0
73112: PPUSH
73113: CALL_OW 50
// continue ;
73117: GO 73018
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
73119: LD_VAR 0 12
73123: PUSH
73124: LD_INT 1
73126: ARRAY
73127: PPUSH
73128: CALL_OW 313
73132: PUSH
73133: LD_VAR 0 12
73137: PUSH
73138: LD_INT 1
73140: ARRAY
73141: PPUSH
73142: CALL_OW 266
73146: PUSH
73147: LD_INT 32
73149: PUSH
73150: LD_INT 31
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: IN
73157: AND
73158: PUSH
73159: LD_VAR 0 12
73163: PUSH
73164: LD_INT 1
73166: ARRAY
73167: PPUSH
73168: CALL_OW 313
73172: PUSH
73173: LD_INT 6
73175: EQUAL
73176: OR
73177: IFFALSE 73197
// f := Delete ( f , 1 ) ;
73179: LD_ADDR_VAR 0 12
73183: PUSH
73184: LD_VAR 0 12
73188: PPUSH
73189: LD_INT 1
73191: PPUSH
73192: CALL_OW 3
73196: ST_TO_ADDR
// if not f then
73197: LD_VAR 0 12
73201: NOT
73202: IFFALSE 73220
// begin x := x + 2 ;
73204: LD_ADDR_VAR 0 13
73208: PUSH
73209: LD_VAR 0 13
73213: PUSH
73214: LD_INT 2
73216: PLUS
73217: ST_TO_ADDR
// continue ;
73218: GO 73018
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73220: LD_VAR 0 12
73224: PUSH
73225: LD_INT 1
73227: ARRAY
73228: PPUSH
73229: CALL_OW 266
73233: PUSH
73234: LD_INT 5
73236: EQUAL
73237: IFFALSE 73311
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73239: LD_VAR 0 12
73243: PUSH
73244: LD_INT 1
73246: ARRAY
73247: PPUSH
73248: CALL_OW 313
73252: PUSH
73253: LD_INT 3
73255: LESS
73256: IFFALSE 73292
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73258: LD_INT 0
73260: PPUSH
73261: LD_INT 5
73263: PUSH
73264: LD_INT 8
73266: PUSH
73267: LD_INT 9
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: LIST
73274: PUSH
73275: LD_VAR 0 17
73279: ARRAY
73280: PPUSH
73281: LD_VAR 0 4
73285: PPUSH
73286: CALL_OW 380
73290: GO 73309
// PrepareHuman ( false , i , skill ) ;
73292: LD_INT 0
73294: PPUSH
73295: LD_VAR 0 8
73299: PPUSH
73300: LD_VAR 0 4
73304: PPUSH
73305: CALL_OW 380
// end else
73309: GO 73328
// PrepareHuman ( false , i , skill ) ;
73311: LD_INT 0
73313: PPUSH
73314: LD_VAR 0 8
73318: PPUSH
73319: LD_VAR 0 4
73323: PPUSH
73324: CALL_OW 380
// un := CreateHuman ;
73328: LD_ADDR_VAR 0 14
73332: PUSH
73333: CALL_OW 44
73337: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73338: LD_ADDR_VAR 0 7
73342: PUSH
73343: LD_VAR 0 7
73347: PPUSH
73348: LD_INT 1
73350: PPUSH
73351: LD_VAR 0 14
73355: PPUSH
73356: CALL_OW 2
73360: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73361: LD_VAR 0 14
73365: PPUSH
73366: LD_VAR 0 12
73370: PUSH
73371: LD_INT 1
73373: ARRAY
73374: PPUSH
73375: CALL_OW 52
// end ;
73379: GO 73018
73381: POP
73382: POP
// end ;
73383: GO 72320
73385: POP
73386: POP
// result := result ^ buildings ;
73387: LD_ADDR_VAR 0 7
73391: PUSH
73392: LD_VAR 0 7
73396: PUSH
73397: LD_VAR 0 18
73401: ADD
73402: ST_TO_ADDR
// end else
73403: GO 73546
// begin for i = 1 to personel do
73405: LD_ADDR_VAR 0 8
73409: PUSH
73410: DOUBLE
73411: LD_INT 1
73413: DEC
73414: ST_TO_ADDR
73415: LD_VAR 0 6
73419: PUSH
73420: FOR_TO
73421: IFFALSE 73544
// begin if i > 4 then
73423: LD_VAR 0 8
73427: PUSH
73428: LD_INT 4
73430: GREATER
73431: IFFALSE 73435
// break ;
73433: GO 73544
// x := personel [ i ] ;
73435: LD_ADDR_VAR 0 13
73439: PUSH
73440: LD_VAR 0 6
73444: PUSH
73445: LD_VAR 0 8
73449: ARRAY
73450: ST_TO_ADDR
// if x = - 1 then
73451: LD_VAR 0 13
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: EQUAL
73460: IFFALSE 73464
// continue ;
73462: GO 73420
// PrepareHuman ( false , i , skill ) ;
73464: LD_INT 0
73466: PPUSH
73467: LD_VAR 0 8
73471: PPUSH
73472: LD_VAR 0 4
73476: PPUSH
73477: CALL_OW 380
// un := CreateHuman ;
73481: LD_ADDR_VAR 0 14
73485: PUSH
73486: CALL_OW 44
73490: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73491: LD_VAR 0 14
73495: PPUSH
73496: LD_VAR 0 1
73500: PPUSH
73501: CALL_OW 250
73505: PPUSH
73506: LD_VAR 0 1
73510: PPUSH
73511: CALL_OW 251
73515: PPUSH
73516: LD_INT 10
73518: PPUSH
73519: LD_INT 0
73521: PPUSH
73522: CALL_OW 50
// result := result ^ un ;
73526: LD_ADDR_VAR 0 7
73530: PUSH
73531: LD_VAR 0 7
73535: PUSH
73536: LD_VAR 0 14
73540: ADD
73541: ST_TO_ADDR
// end ;
73542: GO 73420
73544: POP
73545: POP
// end ; end ;
73546: LD_VAR 0 7
73550: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73551: LD_INT 0
73553: PPUSH
73554: PPUSH
73555: PPUSH
73556: PPUSH
73557: PPUSH
73558: PPUSH
73559: PPUSH
73560: PPUSH
73561: PPUSH
73562: PPUSH
73563: PPUSH
73564: PPUSH
73565: PPUSH
73566: PPUSH
73567: PPUSH
73568: PPUSH
// result := false ;
73569: LD_ADDR_VAR 0 3
73573: PUSH
73574: LD_INT 0
73576: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73577: LD_VAR 0 1
73581: NOT
73582: PUSH
73583: LD_VAR 0 1
73587: PPUSH
73588: CALL_OW 266
73592: PUSH
73593: LD_INT 32
73595: PUSH
73596: LD_INT 33
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: IN
73603: NOT
73604: OR
73605: IFFALSE 73609
// exit ;
73607: GO 74718
// nat := GetNation ( tower ) ;
73609: LD_ADDR_VAR 0 12
73613: PUSH
73614: LD_VAR 0 1
73618: PPUSH
73619: CALL_OW 248
73623: ST_TO_ADDR
// side := GetSide ( tower ) ;
73624: LD_ADDR_VAR 0 16
73628: PUSH
73629: LD_VAR 0 1
73633: PPUSH
73634: CALL_OW 255
73638: ST_TO_ADDR
// x := GetX ( tower ) ;
73639: LD_ADDR_VAR 0 10
73643: PUSH
73644: LD_VAR 0 1
73648: PPUSH
73649: CALL_OW 250
73653: ST_TO_ADDR
// y := GetY ( tower ) ;
73654: LD_ADDR_VAR 0 11
73658: PUSH
73659: LD_VAR 0 1
73663: PPUSH
73664: CALL_OW 251
73668: ST_TO_ADDR
// if not x or not y then
73669: LD_VAR 0 10
73673: NOT
73674: PUSH
73675: LD_VAR 0 11
73679: NOT
73680: OR
73681: IFFALSE 73685
// exit ;
73683: GO 74718
// weapon := 0 ;
73685: LD_ADDR_VAR 0 18
73689: PUSH
73690: LD_INT 0
73692: ST_TO_ADDR
// fac_list := [ ] ;
73693: LD_ADDR_VAR 0 17
73697: PUSH
73698: EMPTY
73699: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
73700: LD_ADDR_VAR 0 6
73704: PUSH
73705: LD_VAR 0 1
73709: PPUSH
73710: CALL_OW 274
73714: PPUSH
73715: LD_VAR 0 2
73719: PPUSH
73720: LD_INT 0
73722: PPUSH
73723: CALL 71289 0 3
73727: PPUSH
73728: LD_INT 30
73730: PUSH
73731: LD_INT 3
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PPUSH
73738: CALL_OW 72
73742: ST_TO_ADDR
// if not factories then
73743: LD_VAR 0 6
73747: NOT
73748: IFFALSE 73752
// exit ;
73750: GO 74718
// for i in factories do
73752: LD_ADDR_VAR 0 8
73756: PUSH
73757: LD_VAR 0 6
73761: PUSH
73762: FOR_IN
73763: IFFALSE 73788
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73765: LD_ADDR_VAR 0 17
73769: PUSH
73770: LD_VAR 0 17
73774: PUSH
73775: LD_VAR 0 8
73779: PPUSH
73780: CALL_OW 478
73784: UNION
73785: ST_TO_ADDR
73786: GO 73762
73788: POP
73789: POP
// if not fac_list then
73790: LD_VAR 0 17
73794: NOT
73795: IFFALSE 73799
// exit ;
73797: GO 74718
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73799: LD_ADDR_VAR 0 5
73803: PUSH
73804: LD_INT 4
73806: PUSH
73807: LD_INT 5
73809: PUSH
73810: LD_INT 9
73812: PUSH
73813: LD_INT 10
73815: PUSH
73816: LD_INT 6
73818: PUSH
73819: LD_INT 7
73821: PUSH
73822: LD_INT 11
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 27
73836: PUSH
73837: LD_INT 28
73839: PUSH
73840: LD_INT 26
73842: PUSH
73843: LD_INT 30
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: LIST
73850: LIST
73851: PUSH
73852: LD_INT 43
73854: PUSH
73855: LD_INT 44
73857: PUSH
73858: LD_INT 46
73860: PUSH
73861: LD_INT 45
73863: PUSH
73864: LD_INT 47
73866: PUSH
73867: LD_INT 49
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: LIST
73882: PUSH
73883: LD_VAR 0 12
73887: ARRAY
73888: ST_TO_ADDR
// list := list isect fac_list ;
73889: LD_ADDR_VAR 0 5
73893: PUSH
73894: LD_VAR 0 5
73898: PUSH
73899: LD_VAR 0 17
73903: ISECT
73904: ST_TO_ADDR
// if not list then
73905: LD_VAR 0 5
73909: NOT
73910: IFFALSE 73914
// exit ;
73912: GO 74718
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73914: LD_VAR 0 12
73918: PUSH
73919: LD_INT 3
73921: EQUAL
73922: PUSH
73923: LD_INT 49
73925: PUSH
73926: LD_VAR 0 5
73930: IN
73931: AND
73932: PUSH
73933: LD_INT 31
73935: PPUSH
73936: LD_VAR 0 16
73940: PPUSH
73941: CALL_OW 321
73945: PUSH
73946: LD_INT 2
73948: EQUAL
73949: AND
73950: IFFALSE 74010
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73952: LD_INT 22
73954: PUSH
73955: LD_VAR 0 16
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 35
73966: PUSH
73967: LD_INT 49
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 91
73976: PUSH
73977: LD_VAR 0 1
73981: PUSH
73982: LD_INT 10
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: LIST
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: LIST
73994: PPUSH
73995: CALL_OW 69
73999: NOT
74000: IFFALSE 74010
// weapon := ru_time_lapser ;
74002: LD_ADDR_VAR 0 18
74006: PUSH
74007: LD_INT 49
74009: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
74010: LD_VAR 0 12
74014: PUSH
74015: LD_INT 1
74017: PUSH
74018: LD_INT 2
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: IN
74025: PUSH
74026: LD_INT 11
74028: PUSH
74029: LD_VAR 0 5
74033: IN
74034: PUSH
74035: LD_INT 30
74037: PUSH
74038: LD_VAR 0 5
74042: IN
74043: OR
74044: AND
74045: PUSH
74046: LD_INT 6
74048: PPUSH
74049: LD_VAR 0 16
74053: PPUSH
74054: CALL_OW 321
74058: PUSH
74059: LD_INT 2
74061: EQUAL
74062: AND
74063: IFFALSE 74228
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
74065: LD_INT 22
74067: PUSH
74068: LD_VAR 0 16
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 2
74079: PUSH
74080: LD_INT 35
74082: PUSH
74083: LD_INT 11
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 35
74092: PUSH
74093: LD_INT 30
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: EMPTY
74101: LIST
74102: LIST
74103: LIST
74104: PUSH
74105: LD_INT 91
74107: PUSH
74108: LD_VAR 0 1
74112: PUSH
74113: LD_INT 18
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: LIST
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: LIST
74125: PPUSH
74126: CALL_OW 69
74130: NOT
74131: PUSH
74132: LD_INT 22
74134: PUSH
74135: LD_VAR 0 16
74139: PUSH
74140: EMPTY
74141: LIST
74142: LIST
74143: PUSH
74144: LD_INT 2
74146: PUSH
74147: LD_INT 30
74149: PUSH
74150: LD_INT 32
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: LD_INT 30
74159: PUSH
74160: LD_INT 33
74162: PUSH
74163: EMPTY
74164: LIST
74165: LIST
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 91
74174: PUSH
74175: LD_VAR 0 1
74179: PUSH
74180: LD_INT 12
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: LIST
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: LIST
74192: PUSH
74193: EMPTY
74194: LIST
74195: PPUSH
74196: CALL_OW 69
74200: PUSH
74201: LD_INT 2
74203: GREATER
74204: AND
74205: IFFALSE 74228
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74207: LD_ADDR_VAR 0 18
74211: PUSH
74212: LD_INT 11
74214: PUSH
74215: LD_INT 30
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_VAR 0 12
74226: ARRAY
74227: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74228: LD_VAR 0 18
74232: NOT
74233: PUSH
74234: LD_INT 40
74236: PPUSH
74237: LD_VAR 0 16
74241: PPUSH
74242: CALL_OW 321
74246: PUSH
74247: LD_INT 2
74249: EQUAL
74250: AND
74251: PUSH
74252: LD_INT 7
74254: PUSH
74255: LD_VAR 0 5
74259: IN
74260: PUSH
74261: LD_INT 28
74263: PUSH
74264: LD_VAR 0 5
74268: IN
74269: OR
74270: PUSH
74271: LD_INT 45
74273: PUSH
74274: LD_VAR 0 5
74278: IN
74279: OR
74280: AND
74281: IFFALSE 74535
// begin hex := GetHexInfo ( x , y ) ;
74283: LD_ADDR_VAR 0 4
74287: PUSH
74288: LD_VAR 0 10
74292: PPUSH
74293: LD_VAR 0 11
74297: PPUSH
74298: CALL_OW 546
74302: ST_TO_ADDR
// if hex [ 1 ] then
74303: LD_VAR 0 4
74307: PUSH
74308: LD_INT 1
74310: ARRAY
74311: IFFALSE 74315
// exit ;
74313: GO 74718
// height := hex [ 2 ] ;
74315: LD_ADDR_VAR 0 15
74319: PUSH
74320: LD_VAR 0 4
74324: PUSH
74325: LD_INT 2
74327: ARRAY
74328: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74329: LD_ADDR_VAR 0 14
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: LD_INT 2
74339: PUSH
74340: LD_INT 3
74342: PUSH
74343: LD_INT 5
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: ST_TO_ADDR
// for i in tmp do
74352: LD_ADDR_VAR 0 8
74356: PUSH
74357: LD_VAR 0 14
74361: PUSH
74362: FOR_IN
74363: IFFALSE 74533
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74365: LD_ADDR_VAR 0 9
74369: PUSH
74370: LD_VAR 0 10
74374: PPUSH
74375: LD_VAR 0 8
74379: PPUSH
74380: LD_INT 5
74382: PPUSH
74383: CALL_OW 272
74387: PUSH
74388: LD_VAR 0 11
74392: PPUSH
74393: LD_VAR 0 8
74397: PPUSH
74398: LD_INT 5
74400: PPUSH
74401: CALL_OW 273
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74410: LD_VAR 0 9
74414: PUSH
74415: LD_INT 1
74417: ARRAY
74418: PPUSH
74419: LD_VAR 0 9
74423: PUSH
74424: LD_INT 2
74426: ARRAY
74427: PPUSH
74428: CALL_OW 488
74432: IFFALSE 74531
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74434: LD_ADDR_VAR 0 4
74438: PUSH
74439: LD_VAR 0 9
74443: PUSH
74444: LD_INT 1
74446: ARRAY
74447: PPUSH
74448: LD_VAR 0 9
74452: PUSH
74453: LD_INT 2
74455: ARRAY
74456: PPUSH
74457: CALL_OW 546
74461: ST_TO_ADDR
// if hex [ 1 ] then
74462: LD_VAR 0 4
74466: PUSH
74467: LD_INT 1
74469: ARRAY
74470: IFFALSE 74474
// continue ;
74472: GO 74362
// h := hex [ 2 ] ;
74474: LD_ADDR_VAR 0 13
74478: PUSH
74479: LD_VAR 0 4
74483: PUSH
74484: LD_INT 2
74486: ARRAY
74487: ST_TO_ADDR
// if h + 7 < height then
74488: LD_VAR 0 13
74492: PUSH
74493: LD_INT 7
74495: PLUS
74496: PUSH
74497: LD_VAR 0 15
74501: LESS
74502: IFFALSE 74531
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74504: LD_ADDR_VAR 0 18
74508: PUSH
74509: LD_INT 7
74511: PUSH
74512: LD_INT 28
74514: PUSH
74515: LD_INT 45
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: LIST
74522: PUSH
74523: LD_VAR 0 12
74527: ARRAY
74528: ST_TO_ADDR
// break ;
74529: GO 74533
// end ; end ; end ;
74531: GO 74362
74533: POP
74534: POP
// end ; if not weapon then
74535: LD_VAR 0 18
74539: NOT
74540: IFFALSE 74600
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74542: LD_ADDR_VAR 0 5
74546: PUSH
74547: LD_VAR 0 5
74551: PUSH
74552: LD_INT 11
74554: PUSH
74555: LD_INT 30
74557: PUSH
74558: LD_INT 49
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: LIST
74565: DIFF
74566: ST_TO_ADDR
// if not list then
74567: LD_VAR 0 5
74571: NOT
74572: IFFALSE 74576
// exit ;
74574: GO 74718
// weapon := list [ rand ( 1 , list ) ] ;
74576: LD_ADDR_VAR 0 18
74580: PUSH
74581: LD_VAR 0 5
74585: PUSH
74586: LD_INT 1
74588: PPUSH
74589: LD_VAR 0 5
74593: PPUSH
74594: CALL_OW 12
74598: ARRAY
74599: ST_TO_ADDR
// end ; if weapon then
74600: LD_VAR 0 18
74604: IFFALSE 74718
// begin tmp := CostOfWeapon ( weapon ) ;
74606: LD_ADDR_VAR 0 14
74610: PUSH
74611: LD_VAR 0 18
74615: PPUSH
74616: CALL_OW 451
74620: ST_TO_ADDR
// j := GetBase ( tower ) ;
74621: LD_ADDR_VAR 0 9
74625: PUSH
74626: LD_VAR 0 1
74630: PPUSH
74631: CALL_OW 274
74635: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74636: LD_VAR 0 9
74640: PPUSH
74641: LD_INT 1
74643: PPUSH
74644: CALL_OW 275
74648: PUSH
74649: LD_VAR 0 14
74653: PUSH
74654: LD_INT 1
74656: ARRAY
74657: GREATEREQUAL
74658: PUSH
74659: LD_VAR 0 9
74663: PPUSH
74664: LD_INT 2
74666: PPUSH
74667: CALL_OW 275
74671: PUSH
74672: LD_VAR 0 14
74676: PUSH
74677: LD_INT 2
74679: ARRAY
74680: GREATEREQUAL
74681: AND
74682: PUSH
74683: LD_VAR 0 9
74687: PPUSH
74688: LD_INT 3
74690: PPUSH
74691: CALL_OW 275
74695: PUSH
74696: LD_VAR 0 14
74700: PUSH
74701: LD_INT 3
74703: ARRAY
74704: GREATEREQUAL
74705: AND
74706: IFFALSE 74718
// result := weapon ;
74708: LD_ADDR_VAR 0 3
74712: PUSH
74713: LD_VAR 0 18
74717: ST_TO_ADDR
// end ; end ;
74718: LD_VAR 0 3
74722: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74723: LD_INT 0
74725: PPUSH
74726: PPUSH
// result := true ;
74727: LD_ADDR_VAR 0 3
74731: PUSH
74732: LD_INT 1
74734: ST_TO_ADDR
// if array1 = array2 then
74735: LD_VAR 0 1
74739: PUSH
74740: LD_VAR 0 2
74744: EQUAL
74745: IFFALSE 74805
// begin for i = 1 to array1 do
74747: LD_ADDR_VAR 0 4
74751: PUSH
74752: DOUBLE
74753: LD_INT 1
74755: DEC
74756: ST_TO_ADDR
74757: LD_VAR 0 1
74761: PUSH
74762: FOR_TO
74763: IFFALSE 74801
// if array1 [ i ] <> array2 [ i ] then
74765: LD_VAR 0 1
74769: PUSH
74770: LD_VAR 0 4
74774: ARRAY
74775: PUSH
74776: LD_VAR 0 2
74780: PUSH
74781: LD_VAR 0 4
74785: ARRAY
74786: NONEQUAL
74787: IFFALSE 74799
// begin result := false ;
74789: LD_ADDR_VAR 0 3
74793: PUSH
74794: LD_INT 0
74796: ST_TO_ADDR
// break ;
74797: GO 74801
// end ;
74799: GO 74762
74801: POP
74802: POP
// end else
74803: GO 74813
// result := false ;
74805: LD_ADDR_VAR 0 3
74809: PUSH
74810: LD_INT 0
74812: ST_TO_ADDR
// end ;
74813: LD_VAR 0 3
74817: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
74818: LD_INT 0
74820: PPUSH
74821: PPUSH
// if not array1 or not array2 then
74822: LD_VAR 0 1
74826: NOT
74827: PUSH
74828: LD_VAR 0 2
74832: NOT
74833: OR
74834: IFFALSE 74838
// exit ;
74836: GO 74902
// result := true ;
74838: LD_ADDR_VAR 0 3
74842: PUSH
74843: LD_INT 1
74845: ST_TO_ADDR
// for i = 1 to array1 do
74846: LD_ADDR_VAR 0 4
74850: PUSH
74851: DOUBLE
74852: LD_INT 1
74854: DEC
74855: ST_TO_ADDR
74856: LD_VAR 0 1
74860: PUSH
74861: FOR_TO
74862: IFFALSE 74900
// if array1 [ i ] <> array2 [ i ] then
74864: LD_VAR 0 1
74868: PUSH
74869: LD_VAR 0 4
74873: ARRAY
74874: PUSH
74875: LD_VAR 0 2
74879: PUSH
74880: LD_VAR 0 4
74884: ARRAY
74885: NONEQUAL
74886: IFFALSE 74898
// begin result := false ;
74888: LD_ADDR_VAR 0 3
74892: PUSH
74893: LD_INT 0
74895: ST_TO_ADDR
// break ;
74896: GO 74900
// end ;
74898: GO 74861
74900: POP
74901: POP
// end ;
74902: LD_VAR 0 3
74906: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74907: LD_INT 0
74909: PPUSH
74910: PPUSH
74911: PPUSH
// pom := GetBase ( fac ) ;
74912: LD_ADDR_VAR 0 5
74916: PUSH
74917: LD_VAR 0 1
74921: PPUSH
74922: CALL_OW 274
74926: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74927: LD_ADDR_VAR 0 4
74931: PUSH
74932: LD_VAR 0 2
74936: PUSH
74937: LD_INT 1
74939: ARRAY
74940: PPUSH
74941: LD_VAR 0 2
74945: PUSH
74946: LD_INT 2
74948: ARRAY
74949: PPUSH
74950: LD_VAR 0 2
74954: PUSH
74955: LD_INT 3
74957: ARRAY
74958: PPUSH
74959: LD_VAR 0 2
74963: PUSH
74964: LD_INT 4
74966: ARRAY
74967: PPUSH
74968: CALL_OW 449
74972: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74973: LD_ADDR_VAR 0 3
74977: PUSH
74978: LD_VAR 0 5
74982: PPUSH
74983: LD_INT 1
74985: PPUSH
74986: CALL_OW 275
74990: PUSH
74991: LD_VAR 0 4
74995: PUSH
74996: LD_INT 1
74998: ARRAY
74999: GREATEREQUAL
75000: PUSH
75001: LD_VAR 0 5
75005: PPUSH
75006: LD_INT 2
75008: PPUSH
75009: CALL_OW 275
75013: PUSH
75014: LD_VAR 0 4
75018: PUSH
75019: LD_INT 2
75021: ARRAY
75022: GREATEREQUAL
75023: AND
75024: PUSH
75025: LD_VAR 0 5
75029: PPUSH
75030: LD_INT 3
75032: PPUSH
75033: CALL_OW 275
75037: PUSH
75038: LD_VAR 0 4
75042: PUSH
75043: LD_INT 3
75045: ARRAY
75046: GREATEREQUAL
75047: AND
75048: ST_TO_ADDR
// end ;
75049: LD_VAR 0 3
75053: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
75054: LD_INT 0
75056: PPUSH
75057: PPUSH
75058: PPUSH
75059: PPUSH
// pom := GetBase ( building ) ;
75060: LD_ADDR_VAR 0 3
75064: PUSH
75065: LD_VAR 0 1
75069: PPUSH
75070: CALL_OW 274
75074: ST_TO_ADDR
// if not pom then
75075: LD_VAR 0 3
75079: NOT
75080: IFFALSE 75084
// exit ;
75082: GO 75254
// btype := GetBType ( building ) ;
75084: LD_ADDR_VAR 0 5
75088: PUSH
75089: LD_VAR 0 1
75093: PPUSH
75094: CALL_OW 266
75098: ST_TO_ADDR
// if btype = b_armoury then
75099: LD_VAR 0 5
75103: PUSH
75104: LD_INT 4
75106: EQUAL
75107: IFFALSE 75117
// btype := b_barracks ;
75109: LD_ADDR_VAR 0 5
75113: PUSH
75114: LD_INT 5
75116: ST_TO_ADDR
// if btype = b_depot then
75117: LD_VAR 0 5
75121: PUSH
75122: LD_INT 0
75124: EQUAL
75125: IFFALSE 75135
// btype := b_warehouse ;
75127: LD_ADDR_VAR 0 5
75131: PUSH
75132: LD_INT 1
75134: ST_TO_ADDR
// if btype = b_workshop then
75135: LD_VAR 0 5
75139: PUSH
75140: LD_INT 2
75142: EQUAL
75143: IFFALSE 75153
// btype := b_factory ;
75145: LD_ADDR_VAR 0 5
75149: PUSH
75150: LD_INT 3
75152: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75153: LD_ADDR_VAR 0 4
75157: PUSH
75158: LD_VAR 0 5
75162: PPUSH
75163: LD_VAR 0 1
75167: PPUSH
75168: CALL_OW 248
75172: PPUSH
75173: CALL_OW 450
75177: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75178: LD_ADDR_VAR 0 2
75182: PUSH
75183: LD_VAR 0 3
75187: PPUSH
75188: LD_INT 1
75190: PPUSH
75191: CALL_OW 275
75195: PUSH
75196: LD_VAR 0 4
75200: PUSH
75201: LD_INT 1
75203: ARRAY
75204: GREATEREQUAL
75205: PUSH
75206: LD_VAR 0 3
75210: PPUSH
75211: LD_INT 2
75213: PPUSH
75214: CALL_OW 275
75218: PUSH
75219: LD_VAR 0 4
75223: PUSH
75224: LD_INT 2
75226: ARRAY
75227: GREATEREQUAL
75228: AND
75229: PUSH
75230: LD_VAR 0 3
75234: PPUSH
75235: LD_INT 3
75237: PPUSH
75238: CALL_OW 275
75242: PUSH
75243: LD_VAR 0 4
75247: PUSH
75248: LD_INT 3
75250: ARRAY
75251: GREATEREQUAL
75252: AND
75253: ST_TO_ADDR
// end ;
75254: LD_VAR 0 2
75258: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75259: LD_INT 0
75261: PPUSH
75262: PPUSH
75263: PPUSH
// pom := GetBase ( building ) ;
75264: LD_ADDR_VAR 0 4
75268: PUSH
75269: LD_VAR 0 1
75273: PPUSH
75274: CALL_OW 274
75278: ST_TO_ADDR
// if not pom then
75279: LD_VAR 0 4
75283: NOT
75284: IFFALSE 75288
// exit ;
75286: GO 75389
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75288: LD_ADDR_VAR 0 5
75292: PUSH
75293: LD_VAR 0 2
75297: PPUSH
75298: LD_VAR 0 1
75302: PPUSH
75303: CALL_OW 248
75307: PPUSH
75308: CALL_OW 450
75312: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75313: LD_ADDR_VAR 0 3
75317: PUSH
75318: LD_VAR 0 4
75322: PPUSH
75323: LD_INT 1
75325: PPUSH
75326: CALL_OW 275
75330: PUSH
75331: LD_VAR 0 5
75335: PUSH
75336: LD_INT 1
75338: ARRAY
75339: GREATEREQUAL
75340: PUSH
75341: LD_VAR 0 4
75345: PPUSH
75346: LD_INT 2
75348: PPUSH
75349: CALL_OW 275
75353: PUSH
75354: LD_VAR 0 5
75358: PUSH
75359: LD_INT 2
75361: ARRAY
75362: GREATEREQUAL
75363: AND
75364: PUSH
75365: LD_VAR 0 4
75369: PPUSH
75370: LD_INT 3
75372: PPUSH
75373: CALL_OW 275
75377: PUSH
75378: LD_VAR 0 5
75382: PUSH
75383: LD_INT 3
75385: ARRAY
75386: GREATEREQUAL
75387: AND
75388: ST_TO_ADDR
// end ;
75389: LD_VAR 0 3
75393: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75394: LD_INT 0
75396: PPUSH
75397: PPUSH
75398: PPUSH
75399: PPUSH
75400: PPUSH
75401: PPUSH
75402: PPUSH
75403: PPUSH
75404: PPUSH
75405: PPUSH
75406: PPUSH
// result := false ;
75407: LD_ADDR_VAR 0 8
75411: PUSH
75412: LD_INT 0
75414: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
75415: LD_VAR 0 5
75419: NOT
75420: PUSH
75421: LD_VAR 0 1
75425: NOT
75426: OR
75427: PUSH
75428: LD_VAR 0 2
75432: NOT
75433: OR
75434: PUSH
75435: LD_VAR 0 3
75439: NOT
75440: OR
75441: IFFALSE 75445
// exit ;
75443: GO 76259
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
75445: LD_ADDR_VAR 0 14
75449: PUSH
75450: LD_VAR 0 1
75454: PPUSH
75455: LD_VAR 0 2
75459: PPUSH
75460: LD_VAR 0 3
75464: PPUSH
75465: LD_VAR 0 4
75469: PPUSH
75470: LD_VAR 0 5
75474: PUSH
75475: LD_INT 1
75477: ARRAY
75478: PPUSH
75479: CALL_OW 248
75483: PPUSH
75484: LD_INT 0
75486: PPUSH
75487: CALL 77496 0 6
75491: ST_TO_ADDR
// if not hexes then
75492: LD_VAR 0 14
75496: NOT
75497: IFFALSE 75501
// exit ;
75499: GO 76259
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75501: LD_ADDR_VAR 0 17
75505: PUSH
75506: LD_VAR 0 5
75510: PPUSH
75511: LD_INT 22
75513: PUSH
75514: LD_VAR 0 13
75518: PPUSH
75519: CALL_OW 255
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 2
75530: PUSH
75531: LD_INT 30
75533: PUSH
75534: LD_INT 0
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 30
75543: PUSH
75544: LD_INT 1
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: LIST
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PPUSH
75560: CALL_OW 72
75564: ST_TO_ADDR
// for i = 1 to hexes do
75565: LD_ADDR_VAR 0 9
75569: PUSH
75570: DOUBLE
75571: LD_INT 1
75573: DEC
75574: ST_TO_ADDR
75575: LD_VAR 0 14
75579: PUSH
75580: FOR_TO
75581: IFFALSE 76257
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75583: LD_ADDR_VAR 0 13
75587: PUSH
75588: LD_VAR 0 14
75592: PUSH
75593: LD_VAR 0 9
75597: ARRAY
75598: PUSH
75599: LD_INT 1
75601: ARRAY
75602: PPUSH
75603: LD_VAR 0 14
75607: PUSH
75608: LD_VAR 0 9
75612: ARRAY
75613: PUSH
75614: LD_INT 2
75616: ARRAY
75617: PPUSH
75618: CALL_OW 428
75622: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75623: LD_VAR 0 14
75627: PUSH
75628: LD_VAR 0 9
75632: ARRAY
75633: PUSH
75634: LD_INT 1
75636: ARRAY
75637: PPUSH
75638: LD_VAR 0 14
75642: PUSH
75643: LD_VAR 0 9
75647: ARRAY
75648: PUSH
75649: LD_INT 2
75651: ARRAY
75652: PPUSH
75653: CALL_OW 351
75657: PUSH
75658: LD_VAR 0 14
75662: PUSH
75663: LD_VAR 0 9
75667: ARRAY
75668: PUSH
75669: LD_INT 1
75671: ARRAY
75672: PPUSH
75673: LD_VAR 0 14
75677: PUSH
75678: LD_VAR 0 9
75682: ARRAY
75683: PUSH
75684: LD_INT 2
75686: ARRAY
75687: PPUSH
75688: CALL_OW 488
75692: NOT
75693: OR
75694: PUSH
75695: LD_VAR 0 13
75699: PPUSH
75700: CALL_OW 247
75704: PUSH
75705: LD_INT 3
75707: EQUAL
75708: OR
75709: IFFALSE 75715
// exit ;
75711: POP
75712: POP
75713: GO 76259
// if not tmp then
75715: LD_VAR 0 13
75719: NOT
75720: IFFALSE 75724
// continue ;
75722: GO 75580
// result := true ;
75724: LD_ADDR_VAR 0 8
75728: PUSH
75729: LD_INT 1
75731: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
75732: LD_VAR 0 6
75736: PUSH
75737: LD_VAR 0 13
75741: PPUSH
75742: CALL_OW 247
75746: PUSH
75747: LD_INT 2
75749: EQUAL
75750: AND
75751: PUSH
75752: LD_VAR 0 13
75756: PPUSH
75757: CALL_OW 263
75761: PUSH
75762: LD_INT 1
75764: EQUAL
75765: AND
75766: IFFALSE 75930
// begin if IsDrivenBy ( tmp ) then
75768: LD_VAR 0 13
75772: PPUSH
75773: CALL_OW 311
75777: IFFALSE 75781
// continue ;
75779: GO 75580
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
75781: LD_VAR 0 6
75785: PPUSH
75786: LD_INT 3
75788: PUSH
75789: LD_INT 60
75791: PUSH
75792: EMPTY
75793: LIST
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 3
75801: PUSH
75802: LD_INT 55
75804: PUSH
75805: EMPTY
75806: LIST
75807: PUSH
75808: EMPTY
75809: LIST
75810: LIST
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PPUSH
75816: CALL_OW 72
75820: IFFALSE 75928
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
75822: LD_ADDR_VAR 0 18
75826: PUSH
75827: LD_VAR 0 6
75831: PPUSH
75832: LD_INT 3
75834: PUSH
75835: LD_INT 60
75837: PUSH
75838: EMPTY
75839: LIST
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 3
75847: PUSH
75848: LD_INT 55
75850: PUSH
75851: EMPTY
75852: LIST
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PPUSH
75862: CALL_OW 72
75866: PUSH
75867: LD_INT 1
75869: ARRAY
75870: ST_TO_ADDR
// if IsInUnit ( driver ) then
75871: LD_VAR 0 18
75875: PPUSH
75876: CALL_OW 310
75880: IFFALSE 75891
// ComExit ( driver ) ;
75882: LD_VAR 0 18
75886: PPUSH
75887: CALL 101201 0 1
// AddComEnterUnit ( driver , tmp ) ;
75891: LD_VAR 0 18
75895: PPUSH
75896: LD_VAR 0 13
75900: PPUSH
75901: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
75905: LD_VAR 0 18
75909: PPUSH
75910: LD_VAR 0 7
75914: PPUSH
75915: CALL_OW 173
// AddComExitVehicle ( driver ) ;
75919: LD_VAR 0 18
75923: PPUSH
75924: CALL_OW 181
// end ; continue ;
75928: GO 75580
// end ; if not cleaners or not tmp in cleaners then
75930: LD_VAR 0 6
75934: NOT
75935: PUSH
75936: LD_VAR 0 13
75940: PUSH
75941: LD_VAR 0 6
75945: IN
75946: NOT
75947: OR
75948: IFFALSE 76255
// begin if dep then
75950: LD_VAR 0 17
75954: IFFALSE 76090
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75956: LD_ADDR_VAR 0 16
75960: PUSH
75961: LD_VAR 0 17
75965: PUSH
75966: LD_INT 1
75968: ARRAY
75969: PPUSH
75970: CALL_OW 250
75974: PPUSH
75975: LD_VAR 0 17
75979: PUSH
75980: LD_INT 1
75982: ARRAY
75983: PPUSH
75984: CALL_OW 254
75988: PPUSH
75989: LD_INT 5
75991: PPUSH
75992: CALL_OW 272
75996: PUSH
75997: LD_VAR 0 17
76001: PUSH
76002: LD_INT 1
76004: ARRAY
76005: PPUSH
76006: CALL_OW 251
76010: PPUSH
76011: LD_VAR 0 17
76015: PUSH
76016: LD_INT 1
76018: ARRAY
76019: PPUSH
76020: CALL_OW 254
76024: PPUSH
76025: LD_INT 5
76027: PPUSH
76028: CALL_OW 273
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76037: LD_VAR 0 16
76041: PUSH
76042: LD_INT 1
76044: ARRAY
76045: PPUSH
76046: LD_VAR 0 16
76050: PUSH
76051: LD_INT 2
76053: ARRAY
76054: PPUSH
76055: CALL_OW 488
76059: IFFALSE 76090
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76061: LD_VAR 0 13
76065: PPUSH
76066: LD_VAR 0 16
76070: PUSH
76071: LD_INT 1
76073: ARRAY
76074: PPUSH
76075: LD_VAR 0 16
76079: PUSH
76080: LD_INT 2
76082: ARRAY
76083: PPUSH
76084: CALL_OW 111
// continue ;
76088: GO 75580
// end ; end ; r := GetDir ( tmp ) ;
76090: LD_ADDR_VAR 0 15
76094: PUSH
76095: LD_VAR 0 13
76099: PPUSH
76100: CALL_OW 254
76104: ST_TO_ADDR
// if r = 5 then
76105: LD_VAR 0 15
76109: PUSH
76110: LD_INT 5
76112: EQUAL
76113: IFFALSE 76123
// r := 0 ;
76115: LD_ADDR_VAR 0 15
76119: PUSH
76120: LD_INT 0
76122: ST_TO_ADDR
// for j = r to 5 do
76123: LD_ADDR_VAR 0 10
76127: PUSH
76128: DOUBLE
76129: LD_VAR 0 15
76133: DEC
76134: ST_TO_ADDR
76135: LD_INT 5
76137: PUSH
76138: FOR_TO
76139: IFFALSE 76253
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76141: LD_ADDR_VAR 0 11
76145: PUSH
76146: LD_VAR 0 13
76150: PPUSH
76151: CALL_OW 250
76155: PPUSH
76156: LD_VAR 0 10
76160: PPUSH
76161: LD_INT 2
76163: PPUSH
76164: CALL_OW 272
76168: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76169: LD_ADDR_VAR 0 12
76173: PUSH
76174: LD_VAR 0 13
76178: PPUSH
76179: CALL_OW 251
76183: PPUSH
76184: LD_VAR 0 10
76188: PPUSH
76189: LD_INT 2
76191: PPUSH
76192: CALL_OW 273
76196: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76197: LD_VAR 0 11
76201: PPUSH
76202: LD_VAR 0 12
76206: PPUSH
76207: CALL_OW 488
76211: PUSH
76212: LD_VAR 0 11
76216: PPUSH
76217: LD_VAR 0 12
76221: PPUSH
76222: CALL_OW 428
76226: NOT
76227: AND
76228: IFFALSE 76251
// begin ComMoveXY ( tmp , _x , _y ) ;
76230: LD_VAR 0 13
76234: PPUSH
76235: LD_VAR 0 11
76239: PPUSH
76240: LD_VAR 0 12
76244: PPUSH
76245: CALL_OW 111
// break ;
76249: GO 76253
// end ; end ;
76251: GO 76138
76253: POP
76254: POP
// end ; end ;
76255: GO 75580
76257: POP
76258: POP
// end ;
76259: LD_VAR 0 8
76263: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76264: LD_INT 0
76266: PPUSH
// result := true ;
76267: LD_ADDR_VAR 0 3
76271: PUSH
76272: LD_INT 1
76274: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76275: LD_VAR 0 2
76279: PUSH
76280: LD_INT 24
76282: DOUBLE
76283: EQUAL
76284: IFTRUE 76294
76286: LD_INT 33
76288: DOUBLE
76289: EQUAL
76290: IFTRUE 76294
76292: GO 76319
76294: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76295: LD_ADDR_VAR 0 3
76299: PUSH
76300: LD_INT 32
76302: PPUSH
76303: LD_VAR 0 1
76307: PPUSH
76308: CALL_OW 321
76312: PUSH
76313: LD_INT 2
76315: EQUAL
76316: ST_TO_ADDR
76317: GO 76639
76319: LD_INT 20
76321: DOUBLE
76322: EQUAL
76323: IFTRUE 76327
76325: GO 76352
76327: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76328: LD_ADDR_VAR 0 3
76332: PUSH
76333: LD_INT 6
76335: PPUSH
76336: LD_VAR 0 1
76340: PPUSH
76341: CALL_OW 321
76345: PUSH
76346: LD_INT 2
76348: EQUAL
76349: ST_TO_ADDR
76350: GO 76639
76352: LD_INT 22
76354: DOUBLE
76355: EQUAL
76356: IFTRUE 76366
76358: LD_INT 36
76360: DOUBLE
76361: EQUAL
76362: IFTRUE 76366
76364: GO 76391
76366: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76367: LD_ADDR_VAR 0 3
76371: PUSH
76372: LD_INT 15
76374: PPUSH
76375: LD_VAR 0 1
76379: PPUSH
76380: CALL_OW 321
76384: PUSH
76385: LD_INT 2
76387: EQUAL
76388: ST_TO_ADDR
76389: GO 76639
76391: LD_INT 30
76393: DOUBLE
76394: EQUAL
76395: IFTRUE 76399
76397: GO 76424
76399: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76400: LD_ADDR_VAR 0 3
76404: PUSH
76405: LD_INT 20
76407: PPUSH
76408: LD_VAR 0 1
76412: PPUSH
76413: CALL_OW 321
76417: PUSH
76418: LD_INT 2
76420: EQUAL
76421: ST_TO_ADDR
76422: GO 76639
76424: LD_INT 28
76426: DOUBLE
76427: EQUAL
76428: IFTRUE 76438
76430: LD_INT 21
76432: DOUBLE
76433: EQUAL
76434: IFTRUE 76438
76436: GO 76463
76438: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
76439: LD_ADDR_VAR 0 3
76443: PUSH
76444: LD_INT 21
76446: PPUSH
76447: LD_VAR 0 1
76451: PPUSH
76452: CALL_OW 321
76456: PUSH
76457: LD_INT 2
76459: EQUAL
76460: ST_TO_ADDR
76461: GO 76639
76463: LD_INT 16
76465: DOUBLE
76466: EQUAL
76467: IFTRUE 76471
76469: GO 76498
76471: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
76472: LD_ADDR_VAR 0 3
76476: PUSH
76477: LD_EXP 86
76481: PPUSH
76482: LD_VAR 0 1
76486: PPUSH
76487: CALL_OW 321
76491: PUSH
76492: LD_INT 2
76494: EQUAL
76495: ST_TO_ADDR
76496: GO 76639
76498: LD_INT 19
76500: DOUBLE
76501: EQUAL
76502: IFTRUE 76512
76504: LD_INT 23
76506: DOUBLE
76507: EQUAL
76508: IFTRUE 76512
76510: GO 76539
76512: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
76513: LD_ADDR_VAR 0 3
76517: PUSH
76518: LD_EXP 85
76522: PPUSH
76523: LD_VAR 0 1
76527: PPUSH
76528: CALL_OW 321
76532: PUSH
76533: LD_INT 2
76535: EQUAL
76536: ST_TO_ADDR
76537: GO 76639
76539: LD_INT 17
76541: DOUBLE
76542: EQUAL
76543: IFTRUE 76547
76545: GO 76572
76547: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
76548: LD_ADDR_VAR 0 3
76552: PUSH
76553: LD_INT 39
76555: PPUSH
76556: LD_VAR 0 1
76560: PPUSH
76561: CALL_OW 321
76565: PUSH
76566: LD_INT 2
76568: EQUAL
76569: ST_TO_ADDR
76570: GO 76639
76572: LD_INT 18
76574: DOUBLE
76575: EQUAL
76576: IFTRUE 76580
76578: GO 76605
76580: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
76581: LD_ADDR_VAR 0 3
76585: PUSH
76586: LD_INT 40
76588: PPUSH
76589: LD_VAR 0 1
76593: PPUSH
76594: CALL_OW 321
76598: PUSH
76599: LD_INT 2
76601: EQUAL
76602: ST_TO_ADDR
76603: GO 76639
76605: LD_INT 27
76607: DOUBLE
76608: EQUAL
76609: IFTRUE 76613
76611: GO 76638
76613: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
76614: LD_ADDR_VAR 0 3
76618: PUSH
76619: LD_INT 35
76621: PPUSH
76622: LD_VAR 0 1
76626: PPUSH
76627: CALL_OW 321
76631: PUSH
76632: LD_INT 2
76634: EQUAL
76635: ST_TO_ADDR
76636: GO 76639
76638: POP
// end ;
76639: LD_VAR 0 3
76643: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
76644: LD_INT 0
76646: PPUSH
76647: PPUSH
76648: PPUSH
76649: PPUSH
76650: PPUSH
76651: PPUSH
76652: PPUSH
76653: PPUSH
76654: PPUSH
76655: PPUSH
76656: PPUSH
// result := false ;
76657: LD_ADDR_VAR 0 6
76661: PUSH
76662: LD_INT 0
76664: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76665: LD_VAR 0 1
76669: NOT
76670: PUSH
76671: LD_VAR 0 1
76675: PPUSH
76676: CALL_OW 266
76680: PUSH
76681: LD_INT 0
76683: PUSH
76684: LD_INT 1
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: IN
76691: NOT
76692: OR
76693: PUSH
76694: LD_VAR 0 2
76698: NOT
76699: OR
76700: PUSH
76701: LD_VAR 0 5
76705: PUSH
76706: LD_INT 0
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: LD_INT 2
76714: PUSH
76715: LD_INT 3
76717: PUSH
76718: LD_INT 4
76720: PUSH
76721: LD_INT 5
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: LIST
76728: LIST
76729: LIST
76730: LIST
76731: IN
76732: NOT
76733: OR
76734: PUSH
76735: LD_VAR 0 3
76739: PPUSH
76740: LD_VAR 0 4
76744: PPUSH
76745: CALL_OW 488
76749: NOT
76750: OR
76751: IFFALSE 76755
// exit ;
76753: GO 77491
// side := GetSide ( depot ) ;
76755: LD_ADDR_VAR 0 9
76759: PUSH
76760: LD_VAR 0 1
76764: PPUSH
76765: CALL_OW 255
76769: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
76770: LD_VAR 0 9
76774: PPUSH
76775: LD_VAR 0 2
76779: PPUSH
76780: CALL 76264 0 2
76784: NOT
76785: IFFALSE 76789
// exit ;
76787: GO 77491
// pom := GetBase ( depot ) ;
76789: LD_ADDR_VAR 0 10
76793: PUSH
76794: LD_VAR 0 1
76798: PPUSH
76799: CALL_OW 274
76803: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
76804: LD_ADDR_VAR 0 11
76808: PUSH
76809: LD_VAR 0 2
76813: PPUSH
76814: LD_VAR 0 1
76818: PPUSH
76819: CALL_OW 248
76823: PPUSH
76824: CALL_OW 450
76828: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76829: LD_VAR 0 10
76833: PPUSH
76834: LD_INT 1
76836: PPUSH
76837: CALL_OW 275
76841: PUSH
76842: LD_VAR 0 11
76846: PUSH
76847: LD_INT 1
76849: ARRAY
76850: GREATEREQUAL
76851: PUSH
76852: LD_VAR 0 10
76856: PPUSH
76857: LD_INT 2
76859: PPUSH
76860: CALL_OW 275
76864: PUSH
76865: LD_VAR 0 11
76869: PUSH
76870: LD_INT 2
76872: ARRAY
76873: GREATEREQUAL
76874: AND
76875: PUSH
76876: LD_VAR 0 10
76880: PPUSH
76881: LD_INT 3
76883: PPUSH
76884: CALL_OW 275
76888: PUSH
76889: LD_VAR 0 11
76893: PUSH
76894: LD_INT 3
76896: ARRAY
76897: GREATEREQUAL
76898: AND
76899: NOT
76900: IFFALSE 76904
// exit ;
76902: GO 77491
// if GetBType ( depot ) = b_depot then
76904: LD_VAR 0 1
76908: PPUSH
76909: CALL_OW 266
76913: PUSH
76914: LD_INT 0
76916: EQUAL
76917: IFFALSE 76929
// dist := 28 else
76919: LD_ADDR_VAR 0 14
76923: PUSH
76924: LD_INT 28
76926: ST_TO_ADDR
76927: GO 76937
// dist := 36 ;
76929: LD_ADDR_VAR 0 14
76933: PUSH
76934: LD_INT 36
76936: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
76937: LD_VAR 0 1
76941: PPUSH
76942: LD_VAR 0 3
76946: PPUSH
76947: LD_VAR 0 4
76951: PPUSH
76952: CALL_OW 297
76956: PUSH
76957: LD_VAR 0 14
76961: GREATER
76962: IFFALSE 76966
// exit ;
76964: GO 77491
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
76966: LD_ADDR_VAR 0 12
76970: PUSH
76971: LD_VAR 0 2
76975: PPUSH
76976: LD_VAR 0 3
76980: PPUSH
76981: LD_VAR 0 4
76985: PPUSH
76986: LD_VAR 0 5
76990: PPUSH
76991: LD_VAR 0 1
76995: PPUSH
76996: CALL_OW 248
77000: PPUSH
77001: LD_INT 0
77003: PPUSH
77004: CALL 77496 0 6
77008: ST_TO_ADDR
// if not hexes then
77009: LD_VAR 0 12
77013: NOT
77014: IFFALSE 77018
// exit ;
77016: GO 77491
// hex := GetHexInfo ( x , y ) ;
77018: LD_ADDR_VAR 0 15
77022: PUSH
77023: LD_VAR 0 3
77027: PPUSH
77028: LD_VAR 0 4
77032: PPUSH
77033: CALL_OW 546
77037: ST_TO_ADDR
// if hex [ 1 ] then
77038: LD_VAR 0 15
77042: PUSH
77043: LD_INT 1
77045: ARRAY
77046: IFFALSE 77050
// exit ;
77048: GO 77491
// height := hex [ 2 ] ;
77050: LD_ADDR_VAR 0 13
77054: PUSH
77055: LD_VAR 0 15
77059: PUSH
77060: LD_INT 2
77062: ARRAY
77063: ST_TO_ADDR
// for i = 1 to hexes do
77064: LD_ADDR_VAR 0 7
77068: PUSH
77069: DOUBLE
77070: LD_INT 1
77072: DEC
77073: ST_TO_ADDR
77074: LD_VAR 0 12
77078: PUSH
77079: FOR_TO
77080: IFFALSE 77410
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77082: LD_VAR 0 12
77086: PUSH
77087: LD_VAR 0 7
77091: ARRAY
77092: PUSH
77093: LD_INT 1
77095: ARRAY
77096: PPUSH
77097: LD_VAR 0 12
77101: PUSH
77102: LD_VAR 0 7
77106: ARRAY
77107: PUSH
77108: LD_INT 2
77110: ARRAY
77111: PPUSH
77112: CALL_OW 488
77116: NOT
77117: PUSH
77118: LD_VAR 0 12
77122: PUSH
77123: LD_VAR 0 7
77127: ARRAY
77128: PUSH
77129: LD_INT 1
77131: ARRAY
77132: PPUSH
77133: LD_VAR 0 12
77137: PUSH
77138: LD_VAR 0 7
77142: ARRAY
77143: PUSH
77144: LD_INT 2
77146: ARRAY
77147: PPUSH
77148: CALL_OW 428
77152: PUSH
77153: LD_INT 0
77155: GREATER
77156: OR
77157: PUSH
77158: LD_VAR 0 12
77162: PUSH
77163: LD_VAR 0 7
77167: ARRAY
77168: PUSH
77169: LD_INT 1
77171: ARRAY
77172: PPUSH
77173: LD_VAR 0 12
77177: PUSH
77178: LD_VAR 0 7
77182: ARRAY
77183: PUSH
77184: LD_INT 2
77186: ARRAY
77187: PPUSH
77188: CALL_OW 351
77192: OR
77193: IFFALSE 77199
// exit ;
77195: POP
77196: POP
77197: GO 77491
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77199: LD_ADDR_VAR 0 8
77203: PUSH
77204: LD_VAR 0 12
77208: PUSH
77209: LD_VAR 0 7
77213: ARRAY
77214: PUSH
77215: LD_INT 1
77217: ARRAY
77218: PPUSH
77219: LD_VAR 0 12
77223: PUSH
77224: LD_VAR 0 7
77228: ARRAY
77229: PUSH
77230: LD_INT 2
77232: ARRAY
77233: PPUSH
77234: CALL_OW 546
77238: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77239: LD_VAR 0 8
77243: PUSH
77244: LD_INT 1
77246: ARRAY
77247: PUSH
77248: LD_VAR 0 8
77252: PUSH
77253: LD_INT 2
77255: ARRAY
77256: PUSH
77257: LD_VAR 0 13
77261: PUSH
77262: LD_INT 2
77264: PLUS
77265: GREATER
77266: OR
77267: PUSH
77268: LD_VAR 0 8
77272: PUSH
77273: LD_INT 2
77275: ARRAY
77276: PUSH
77277: LD_VAR 0 13
77281: PUSH
77282: LD_INT 2
77284: MINUS
77285: LESS
77286: OR
77287: PUSH
77288: LD_VAR 0 8
77292: PUSH
77293: LD_INT 3
77295: ARRAY
77296: PUSH
77297: LD_INT 0
77299: PUSH
77300: LD_INT 8
77302: PUSH
77303: LD_INT 9
77305: PUSH
77306: LD_INT 10
77308: PUSH
77309: LD_INT 11
77311: PUSH
77312: LD_INT 12
77314: PUSH
77315: LD_INT 13
77317: PUSH
77318: LD_INT 16
77320: PUSH
77321: LD_INT 17
77323: PUSH
77324: LD_INT 18
77326: PUSH
77327: LD_INT 19
77329: PUSH
77330: LD_INT 20
77332: PUSH
77333: LD_INT 21
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: LIST
77340: LIST
77341: LIST
77342: LIST
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: LIST
77348: LIST
77349: LIST
77350: IN
77351: NOT
77352: OR
77353: PUSH
77354: LD_VAR 0 8
77358: PUSH
77359: LD_INT 5
77361: ARRAY
77362: NOT
77363: OR
77364: PUSH
77365: LD_VAR 0 8
77369: PUSH
77370: LD_INT 6
77372: ARRAY
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: LD_INT 2
77379: PUSH
77380: LD_INT 7
77382: PUSH
77383: LD_INT 9
77385: PUSH
77386: LD_INT 10
77388: PUSH
77389: LD_INT 11
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: IN
77400: NOT
77401: OR
77402: IFFALSE 77408
// exit ;
77404: POP
77405: POP
77406: GO 77491
// end ;
77408: GO 77079
77410: POP
77411: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77412: LD_VAR 0 9
77416: PPUSH
77417: LD_VAR 0 3
77421: PPUSH
77422: LD_VAR 0 4
77426: PPUSH
77427: LD_INT 20
77429: PPUSH
77430: CALL 69437 0 4
77434: PUSH
77435: LD_INT 4
77437: ARRAY
77438: IFFALSE 77442
// exit ;
77440: GO 77491
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77442: LD_VAR 0 2
77446: PUSH
77447: LD_INT 29
77449: PUSH
77450: LD_INT 30
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: IN
77457: PUSH
77458: LD_VAR 0 3
77462: PPUSH
77463: LD_VAR 0 4
77467: PPUSH
77468: LD_VAR 0 9
77472: PPUSH
77473: CALL_OW 440
77477: NOT
77478: AND
77479: IFFALSE 77483
// exit ;
77481: GO 77491
// result := true ;
77483: LD_ADDR_VAR 0 6
77487: PUSH
77488: LD_INT 1
77490: ST_TO_ADDR
// end ;
77491: LD_VAR 0 6
77495: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
77496: LD_INT 0
77498: PPUSH
77499: PPUSH
77500: PPUSH
77501: PPUSH
77502: PPUSH
77503: PPUSH
77504: PPUSH
77505: PPUSH
77506: PPUSH
77507: PPUSH
77508: PPUSH
77509: PPUSH
77510: PPUSH
77511: PPUSH
77512: PPUSH
77513: PPUSH
77514: PPUSH
77515: PPUSH
77516: PPUSH
77517: PPUSH
77518: PPUSH
77519: PPUSH
77520: PPUSH
77521: PPUSH
77522: PPUSH
77523: PPUSH
77524: PPUSH
77525: PPUSH
77526: PPUSH
77527: PPUSH
77528: PPUSH
77529: PPUSH
77530: PPUSH
77531: PPUSH
77532: PPUSH
77533: PPUSH
77534: PPUSH
77535: PPUSH
77536: PPUSH
77537: PPUSH
77538: PPUSH
77539: PPUSH
77540: PPUSH
77541: PPUSH
77542: PPUSH
77543: PPUSH
77544: PPUSH
77545: PPUSH
77546: PPUSH
77547: PPUSH
77548: PPUSH
77549: PPUSH
77550: PPUSH
77551: PPUSH
77552: PPUSH
77553: PPUSH
77554: PPUSH
77555: PPUSH
// result = [ ] ;
77556: LD_ADDR_VAR 0 7
77560: PUSH
77561: EMPTY
77562: ST_TO_ADDR
// temp_list = [ ] ;
77563: LD_ADDR_VAR 0 9
77567: PUSH
77568: EMPTY
77569: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77570: LD_VAR 0 4
77574: PUSH
77575: LD_INT 0
77577: PUSH
77578: LD_INT 1
77580: PUSH
77581: LD_INT 2
77583: PUSH
77584: LD_INT 3
77586: PUSH
77587: LD_INT 4
77589: PUSH
77590: LD_INT 5
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: IN
77601: NOT
77602: PUSH
77603: LD_VAR 0 1
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: LD_INT 1
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: IN
77618: PUSH
77619: LD_VAR 0 5
77623: PUSH
77624: LD_INT 1
77626: PUSH
77627: LD_INT 2
77629: PUSH
77630: LD_INT 3
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: LIST
77637: IN
77638: NOT
77639: AND
77640: OR
77641: IFFALSE 77645
// exit ;
77643: GO 96036
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77645: LD_VAR 0 1
77649: PUSH
77650: LD_INT 6
77652: PUSH
77653: LD_INT 7
77655: PUSH
77656: LD_INT 8
77658: PUSH
77659: LD_INT 13
77661: PUSH
77662: LD_INT 12
77664: PUSH
77665: LD_INT 15
77667: PUSH
77668: LD_INT 11
77670: PUSH
77671: LD_INT 14
77673: PUSH
77674: LD_INT 10
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: IN
77688: IFFALSE 77698
// btype = b_lab ;
77690: LD_ADDR_VAR 0 1
77694: PUSH
77695: LD_INT 6
77697: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77698: LD_VAR 0 6
77702: PUSH
77703: LD_INT 0
77705: PUSH
77706: LD_INT 1
77708: PUSH
77709: LD_INT 2
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: LIST
77716: IN
77717: NOT
77718: PUSH
77719: LD_VAR 0 1
77723: PUSH
77724: LD_INT 0
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: LD_INT 2
77732: PUSH
77733: LD_INT 3
77735: PUSH
77736: LD_INT 6
77738: PUSH
77739: LD_INT 36
77741: PUSH
77742: LD_INT 4
77744: PUSH
77745: LD_INT 5
77747: PUSH
77748: LD_INT 31
77750: PUSH
77751: LD_INT 32
77753: PUSH
77754: LD_INT 33
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: IN
77770: NOT
77771: PUSH
77772: LD_VAR 0 6
77776: PUSH
77777: LD_INT 1
77779: EQUAL
77780: AND
77781: OR
77782: PUSH
77783: LD_VAR 0 1
77787: PUSH
77788: LD_INT 2
77790: PUSH
77791: LD_INT 3
77793: PUSH
77794: EMPTY
77795: LIST
77796: LIST
77797: IN
77798: NOT
77799: PUSH
77800: LD_VAR 0 6
77804: PUSH
77805: LD_INT 2
77807: EQUAL
77808: AND
77809: OR
77810: IFFALSE 77820
// mode = 0 ;
77812: LD_ADDR_VAR 0 6
77816: PUSH
77817: LD_INT 0
77819: ST_TO_ADDR
// case mode of 0 :
77820: LD_VAR 0 6
77824: PUSH
77825: LD_INT 0
77827: DOUBLE
77828: EQUAL
77829: IFTRUE 77833
77831: GO 89286
77833: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77834: LD_ADDR_VAR 0 11
77838: PUSH
77839: LD_INT 0
77841: PUSH
77842: LD_INT 0
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 0
77851: PUSH
77852: LD_INT 1
77854: NEG
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PUSH
77860: LD_INT 1
77862: PUSH
77863: LD_INT 0
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 1
77872: PUSH
77873: LD_INT 1
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 0
77882: PUSH
77883: LD_INT 1
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: LD_INT 0
77896: PUSH
77897: EMPTY
77898: LIST
77899: LIST
77900: PUSH
77901: LD_INT 1
77903: NEG
77904: PUSH
77905: LD_INT 1
77907: NEG
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: PUSH
77913: LD_INT 1
77915: NEG
77916: PUSH
77917: LD_INT 2
77919: NEG
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 0
77927: PUSH
77928: LD_INT 2
77930: NEG
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: PUSH
77936: LD_INT 1
77938: PUSH
77939: LD_INT 1
77941: NEG
77942: PUSH
77943: EMPTY
77944: LIST
77945: LIST
77946: PUSH
77947: LD_INT 1
77949: PUSH
77950: LD_INT 2
77952: PUSH
77953: EMPTY
77954: LIST
77955: LIST
77956: PUSH
77957: LD_INT 0
77959: PUSH
77960: LD_INT 2
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 1
77969: NEG
77970: PUSH
77971: LD_INT 1
77973: PUSH
77974: EMPTY
77975: LIST
77976: LIST
77977: PUSH
77978: LD_INT 1
77980: PUSH
77981: LD_INT 3
77983: PUSH
77984: EMPTY
77985: LIST
77986: LIST
77987: PUSH
77988: LD_INT 0
77990: PUSH
77991: LD_INT 3
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 1
78000: NEG
78001: PUSH
78002: LD_INT 2
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: LIST
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78027: LD_ADDR_VAR 0 12
78031: PUSH
78032: LD_INT 0
78034: PUSH
78035: LD_INT 0
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 0
78044: PUSH
78045: LD_INT 1
78047: NEG
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 1
78055: PUSH
78056: LD_INT 0
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 1
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 0
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 1
78085: NEG
78086: PUSH
78087: LD_INT 0
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: LD_INT 1
78096: NEG
78097: PUSH
78098: LD_INT 1
78100: NEG
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 1
78108: PUSH
78109: LD_INT 1
78111: NEG
78112: PUSH
78113: EMPTY
78114: LIST
78115: LIST
78116: PUSH
78117: LD_INT 2
78119: PUSH
78120: LD_INT 0
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 2
78129: PUSH
78130: LD_INT 1
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 1
78139: NEG
78140: PUSH
78141: LD_INT 1
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 2
78150: NEG
78151: PUSH
78152: LD_INT 0
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 2
78161: NEG
78162: PUSH
78163: LD_INT 1
78165: NEG
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 2
78173: NEG
78174: PUSH
78175: LD_INT 1
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 3
78184: NEG
78185: PUSH
78186: LD_INT 0
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 3
78195: NEG
78196: PUSH
78197: LD_INT 1
78199: NEG
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78223: LD_ADDR_VAR 0 13
78227: PUSH
78228: LD_INT 0
78230: PUSH
78231: LD_INT 0
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 0
78240: PUSH
78241: LD_INT 1
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 1
78251: PUSH
78252: LD_INT 0
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 1
78261: PUSH
78262: LD_INT 1
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 0
78271: PUSH
78272: LD_INT 1
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 1
78281: NEG
78282: PUSH
78283: LD_INT 0
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 1
78292: NEG
78293: PUSH
78294: LD_INT 1
78296: NEG
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 1
78304: NEG
78305: PUSH
78306: LD_INT 2
78308: NEG
78309: PUSH
78310: EMPTY
78311: LIST
78312: LIST
78313: PUSH
78314: LD_INT 2
78316: PUSH
78317: LD_INT 1
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 2
78326: PUSH
78327: LD_INT 2
78329: PUSH
78330: EMPTY
78331: LIST
78332: LIST
78333: PUSH
78334: LD_INT 1
78336: PUSH
78337: LD_INT 2
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: PUSH
78344: LD_INT 2
78346: NEG
78347: PUSH
78348: LD_INT 1
78350: NEG
78351: PUSH
78352: EMPTY
78353: LIST
78354: LIST
78355: PUSH
78356: LD_INT 2
78358: NEG
78359: PUSH
78360: LD_INT 2
78362: NEG
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 2
78370: NEG
78371: PUSH
78372: LD_INT 3
78374: NEG
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: LD_INT 3
78382: NEG
78383: PUSH
78384: LD_INT 2
78386: NEG
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 3
78394: NEG
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78422: LD_ADDR_VAR 0 14
78426: PUSH
78427: LD_INT 0
78429: PUSH
78430: LD_INT 0
78432: PUSH
78433: EMPTY
78434: LIST
78435: LIST
78436: PUSH
78437: LD_INT 0
78439: PUSH
78440: LD_INT 1
78442: NEG
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: PUSH
78448: LD_INT 1
78450: PUSH
78451: LD_INT 0
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 1
78460: PUSH
78461: LD_INT 1
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: PUSH
78468: LD_INT 0
78470: PUSH
78471: LD_INT 1
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 1
78480: NEG
78481: PUSH
78482: LD_INT 0
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: NEG
78492: PUSH
78493: LD_INT 1
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 1
78503: NEG
78504: PUSH
78505: LD_INT 2
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 0
78515: PUSH
78516: LD_INT 2
78518: NEG
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PUSH
78524: LD_INT 1
78526: PUSH
78527: LD_INT 1
78529: NEG
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 1
78537: PUSH
78538: LD_INT 2
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: LD_INT 0
78547: PUSH
78548: LD_INT 2
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: PUSH
78555: LD_INT 1
78557: NEG
78558: PUSH
78559: LD_INT 1
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: PUSH
78566: LD_INT 1
78568: NEG
78569: PUSH
78570: LD_INT 3
78572: NEG
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 0
78580: PUSH
78581: LD_INT 3
78583: NEG
78584: PUSH
78585: EMPTY
78586: LIST
78587: LIST
78588: PUSH
78589: LD_INT 1
78591: PUSH
78592: LD_INT 2
78594: NEG
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78618: LD_ADDR_VAR 0 15
78622: PUSH
78623: LD_INT 0
78625: PUSH
78626: LD_INT 0
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PUSH
78633: LD_INT 0
78635: PUSH
78636: LD_INT 1
78638: NEG
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: PUSH
78644: LD_INT 1
78646: PUSH
78647: LD_INT 0
78649: PUSH
78650: EMPTY
78651: LIST
78652: LIST
78653: PUSH
78654: LD_INT 1
78656: PUSH
78657: LD_INT 1
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 0
78666: PUSH
78667: LD_INT 1
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 1
78676: NEG
78677: PUSH
78678: LD_INT 0
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: LD_INT 1
78687: NEG
78688: PUSH
78689: LD_INT 1
78691: NEG
78692: PUSH
78693: EMPTY
78694: LIST
78695: LIST
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: LD_INT 1
78702: NEG
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: PUSH
78708: LD_INT 2
78710: PUSH
78711: LD_INT 0
78713: PUSH
78714: EMPTY
78715: LIST
78716: LIST
78717: PUSH
78718: LD_INT 2
78720: PUSH
78721: LD_INT 1
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: LD_INT 1
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 2
78741: NEG
78742: PUSH
78743: LD_INT 0
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PUSH
78750: LD_INT 2
78752: NEG
78753: PUSH
78754: LD_INT 1
78756: NEG
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: LD_INT 2
78764: PUSH
78765: LD_INT 1
78767: NEG
78768: PUSH
78769: EMPTY
78770: LIST
78771: LIST
78772: PUSH
78773: LD_INT 3
78775: PUSH
78776: LD_INT 0
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 3
78785: PUSH
78786: LD_INT 1
78788: PUSH
78789: EMPTY
78790: LIST
78791: LIST
78792: PUSH
78793: EMPTY
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78811: LD_ADDR_VAR 0 16
78815: PUSH
78816: LD_INT 0
78818: PUSH
78819: LD_INT 0
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: LD_INT 0
78828: PUSH
78829: LD_INT 1
78831: NEG
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 1
78839: PUSH
78840: LD_INT 0
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 1
78849: PUSH
78850: LD_INT 1
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 0
78859: PUSH
78860: LD_INT 1
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 1
78869: NEG
78870: PUSH
78871: LD_INT 0
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 1
78880: NEG
78881: PUSH
78882: LD_INT 1
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 1
78892: NEG
78893: PUSH
78894: LD_INT 2
78896: NEG
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 2
78904: PUSH
78905: LD_INT 1
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 2
78914: PUSH
78915: LD_INT 2
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 1
78924: PUSH
78925: LD_INT 2
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 2
78934: NEG
78935: PUSH
78936: LD_INT 1
78938: NEG
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 2
78946: NEG
78947: PUSH
78948: LD_INT 2
78950: NEG
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: PUSH
78956: LD_INT 3
78958: PUSH
78959: LD_INT 2
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 3
78968: PUSH
78969: LD_INT 3
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PUSH
78976: LD_INT 2
78978: PUSH
78979: LD_INT 3
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79004: LD_ADDR_VAR 0 17
79008: PUSH
79009: LD_INT 0
79011: PUSH
79012: LD_INT 0
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 0
79021: PUSH
79022: LD_INT 1
79024: NEG
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 1
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 1
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 0
79052: PUSH
79053: LD_INT 1
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 1
79062: NEG
79063: PUSH
79064: LD_INT 0
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 1
79073: NEG
79074: PUSH
79075: LD_INT 1
79077: NEG
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: LD_INT 2
79089: NEG
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 0
79097: PUSH
79098: LD_INT 2
79100: NEG
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 1
79108: PUSH
79109: LD_INT 1
79111: NEG
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 2
79119: PUSH
79120: LD_INT 0
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 2
79129: PUSH
79130: LD_INT 1
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 2
79139: PUSH
79140: LD_INT 2
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: LD_INT 1
79149: PUSH
79150: LD_INT 2
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 0
79159: PUSH
79160: LD_INT 2
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: NEG
79170: PUSH
79171: LD_INT 1
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 2
79180: NEG
79181: PUSH
79182: LD_INT 0
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 2
79191: NEG
79192: PUSH
79193: LD_INT 1
79195: NEG
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 2
79203: NEG
79204: PUSH
79205: LD_INT 2
79207: NEG
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: LIST
79233: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79234: LD_ADDR_VAR 0 18
79238: PUSH
79239: LD_INT 0
79241: PUSH
79242: LD_INT 0
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 0
79251: PUSH
79252: LD_INT 1
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: LD_INT 1
79262: PUSH
79263: LD_INT 0
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 1
79272: PUSH
79273: LD_INT 1
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 0
79282: PUSH
79283: LD_INT 1
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 1
79292: NEG
79293: PUSH
79294: LD_INT 0
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 1
79303: NEG
79304: PUSH
79305: LD_INT 1
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 1
79315: NEG
79316: PUSH
79317: LD_INT 2
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 0
79327: PUSH
79328: LD_INT 2
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 2
79349: PUSH
79350: LD_INT 0
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 2
79359: PUSH
79360: LD_INT 1
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 2
79369: PUSH
79370: LD_INT 2
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 1
79379: PUSH
79380: LD_INT 2
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 0
79389: PUSH
79390: LD_INT 2
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 1
79399: NEG
79400: PUSH
79401: LD_INT 1
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: LD_INT 2
79410: NEG
79411: PUSH
79412: LD_INT 0
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 2
79421: NEG
79422: PUSH
79423: LD_INT 1
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: LD_INT 2
79433: NEG
79434: PUSH
79435: LD_INT 2
79437: NEG
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79464: LD_ADDR_VAR 0 19
79468: PUSH
79469: LD_INT 0
79471: PUSH
79472: LD_INT 0
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 0
79481: PUSH
79482: LD_INT 1
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: PUSH
79493: LD_INT 0
79495: PUSH
79496: EMPTY
79497: LIST
79498: LIST
79499: PUSH
79500: LD_INT 1
79502: PUSH
79503: LD_INT 1
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: LD_INT 1
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 1
79522: NEG
79523: PUSH
79524: LD_INT 0
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 1
79533: NEG
79534: PUSH
79535: LD_INT 1
79537: NEG
79538: PUSH
79539: EMPTY
79540: LIST
79541: LIST
79542: PUSH
79543: LD_INT 1
79545: NEG
79546: PUSH
79547: LD_INT 2
79549: NEG
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 0
79557: PUSH
79558: LD_INT 2
79560: NEG
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: LD_INT 1
79568: PUSH
79569: LD_INT 1
79571: NEG
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 2
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 2
79589: PUSH
79590: LD_INT 1
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 2
79599: PUSH
79600: LD_INT 2
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: LD_INT 1
79609: PUSH
79610: LD_INT 2
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 0
79619: PUSH
79620: LD_INT 2
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 1
79629: NEG
79630: PUSH
79631: LD_INT 1
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 2
79640: NEG
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 2
79651: NEG
79652: PUSH
79653: LD_INT 1
79655: NEG
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 2
79663: NEG
79664: PUSH
79665: LD_INT 2
79667: NEG
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: LIST
79693: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79694: LD_ADDR_VAR 0 20
79698: PUSH
79699: LD_INT 0
79701: PUSH
79702: LD_INT 0
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 0
79711: PUSH
79712: LD_INT 1
79714: NEG
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 1
79722: PUSH
79723: LD_INT 0
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 1
79732: PUSH
79733: LD_INT 1
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: LD_INT 0
79742: PUSH
79743: LD_INT 1
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 1
79752: NEG
79753: PUSH
79754: LD_INT 0
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: LD_INT 1
79763: NEG
79764: PUSH
79765: LD_INT 1
79767: NEG
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: LD_INT 1
79775: NEG
79776: PUSH
79777: LD_INT 2
79779: NEG
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 0
79787: PUSH
79788: LD_INT 2
79790: NEG
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 2
79809: PUSH
79810: LD_INT 0
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 2
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: PUSH
79827: LD_INT 2
79829: PUSH
79830: LD_INT 2
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 1
79839: PUSH
79840: LD_INT 2
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 0
79849: PUSH
79850: LD_INT 2
79852: PUSH
79853: EMPTY
79854: LIST
79855: LIST
79856: PUSH
79857: LD_INT 1
79859: NEG
79860: PUSH
79861: LD_INT 1
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 2
79870: NEG
79871: PUSH
79872: LD_INT 0
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 2
79881: NEG
79882: PUSH
79883: LD_INT 1
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 2
79893: NEG
79894: PUSH
79895: LD_INT 2
79897: NEG
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79924: LD_ADDR_VAR 0 21
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: LD_INT 0
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 0
79941: PUSH
79942: LD_INT 1
79944: NEG
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 1
79952: PUSH
79953: LD_INT 0
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 1
79962: PUSH
79963: LD_INT 1
79965: PUSH
79966: EMPTY
79967: LIST
79968: LIST
79969: PUSH
79970: LD_INT 0
79972: PUSH
79973: LD_INT 1
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: LD_INT 0
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 1
79993: NEG
79994: PUSH
79995: LD_INT 1
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: LD_INT 1
80005: NEG
80006: PUSH
80007: LD_INT 2
80009: NEG
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 0
80017: PUSH
80018: LD_INT 2
80020: NEG
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: LD_INT 1
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: PUSH
80040: LD_INT 0
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 2
80049: PUSH
80050: LD_INT 1
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 2
80059: PUSH
80060: LD_INT 2
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: LD_INT 2
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 2
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 1
80089: NEG
80090: PUSH
80091: LD_INT 1
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 2
80100: NEG
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 2
80111: NEG
80112: PUSH
80113: LD_INT 1
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 2
80123: NEG
80124: PUSH
80125: LD_INT 2
80127: NEG
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80154: LD_ADDR_VAR 0 22
80158: PUSH
80159: LD_INT 0
80161: PUSH
80162: LD_INT 0
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 0
80171: PUSH
80172: LD_INT 1
80174: NEG
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PUSH
80180: LD_INT 1
80182: PUSH
80183: LD_INT 0
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: LD_INT 1
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 1
80212: NEG
80213: PUSH
80214: LD_INT 0
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: NEG
80224: PUSH
80225: LD_INT 1
80227: NEG
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 1
80235: NEG
80236: PUSH
80237: LD_INT 2
80239: NEG
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 0
80247: PUSH
80248: LD_INT 2
80250: NEG
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 1
80258: PUSH
80259: LD_INT 1
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 2
80269: PUSH
80270: LD_INT 0
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 2
80279: PUSH
80280: LD_INT 1
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 2
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 1
80299: PUSH
80300: LD_INT 2
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 0
80309: PUSH
80310: LD_INT 2
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 1
80319: NEG
80320: PUSH
80321: LD_INT 1
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 2
80330: NEG
80331: PUSH
80332: LD_INT 0
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 2
80341: NEG
80342: PUSH
80343: LD_INT 1
80345: NEG
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 2
80353: NEG
80354: PUSH
80355: LD_INT 2
80357: NEG
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80384: LD_ADDR_VAR 0 23
80388: PUSH
80389: LD_INT 0
80391: PUSH
80392: LD_INT 0
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 0
80401: PUSH
80402: LD_INT 1
80404: NEG
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: LD_INT 0
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 1
80422: PUSH
80423: LD_INT 1
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 0
80432: PUSH
80433: LD_INT 1
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 1
80442: NEG
80443: PUSH
80444: LD_INT 0
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: LD_INT 1
80457: NEG
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 1
80465: NEG
80466: PUSH
80467: LD_INT 2
80469: NEG
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 0
80477: PUSH
80478: LD_INT 2
80480: NEG
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 1
80488: PUSH
80489: LD_INT 1
80491: NEG
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 2
80499: PUSH
80500: LD_INT 0
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 2
80509: PUSH
80510: LD_INT 1
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 2
80519: PUSH
80520: LD_INT 2
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 1
80529: PUSH
80530: LD_INT 2
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 0
80539: PUSH
80540: LD_INT 2
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 1
80549: NEG
80550: PUSH
80551: LD_INT 1
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 2
80560: NEG
80561: PUSH
80562: LD_INT 0
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 2
80571: NEG
80572: PUSH
80573: LD_INT 1
80575: NEG
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 2
80583: NEG
80584: PUSH
80585: LD_INT 2
80587: NEG
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 2
80595: NEG
80596: PUSH
80597: LD_INT 3
80599: NEG
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 1
80607: NEG
80608: PUSH
80609: LD_INT 3
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: LD_INT 2
80622: NEG
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 2
80630: PUSH
80631: LD_INT 1
80633: NEG
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: LIST
80653: LIST
80654: LIST
80655: LIST
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80664: LD_ADDR_VAR 0 24
80668: PUSH
80669: LD_INT 0
80671: PUSH
80672: LD_INT 0
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: PUSH
80679: LD_INT 0
80681: PUSH
80682: LD_INT 1
80684: NEG
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 1
80692: PUSH
80693: LD_INT 0
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 1
80702: PUSH
80703: LD_INT 1
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 0
80712: PUSH
80713: LD_INT 1
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 1
80722: NEG
80723: PUSH
80724: LD_INT 0
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: LD_INT 1
80733: NEG
80734: PUSH
80735: LD_INT 1
80737: NEG
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 1
80745: NEG
80746: PUSH
80747: LD_INT 2
80749: NEG
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: LD_INT 0
80757: PUSH
80758: LD_INT 2
80760: NEG
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 1
80768: PUSH
80769: LD_INT 1
80771: NEG
80772: PUSH
80773: EMPTY
80774: LIST
80775: LIST
80776: PUSH
80777: LD_INT 2
80779: PUSH
80780: LD_INT 0
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 2
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 2
80799: PUSH
80800: LD_INT 2
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 1
80809: PUSH
80810: LD_INT 2
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 0
80819: PUSH
80820: LD_INT 2
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 1
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 2
80840: NEG
80841: PUSH
80842: LD_INT 0
80844: PUSH
80845: EMPTY
80846: LIST
80847: LIST
80848: PUSH
80849: LD_INT 2
80851: NEG
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 2
80863: NEG
80864: PUSH
80865: LD_INT 2
80867: NEG
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 1
80875: PUSH
80876: LD_INT 2
80878: NEG
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 2
80886: PUSH
80887: LD_INT 1
80889: NEG
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: LD_INT 3
80897: PUSH
80898: LD_INT 1
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 3
80907: PUSH
80908: LD_INT 2
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80940: LD_ADDR_VAR 0 25
80944: PUSH
80945: LD_INT 0
80947: PUSH
80948: LD_INT 0
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: LD_INT 1
80960: NEG
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: LD_INT 1
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: EMPTY
80973: LIST
80974: LIST
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: LD_INT 1
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: LD_INT 1
80998: NEG
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: NEG
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: LD_INT 2
81025: NEG
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 0
81033: PUSH
81034: LD_INT 2
81036: NEG
81037: PUSH
81038: EMPTY
81039: LIST
81040: LIST
81041: PUSH
81042: LD_INT 1
81044: PUSH
81045: LD_INT 1
81047: NEG
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 2
81055: PUSH
81056: LD_INT 0
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 2
81065: PUSH
81066: LD_INT 1
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 2
81075: PUSH
81076: LD_INT 2
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: LD_INT 2
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: LD_INT 2
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 1
81105: NEG
81106: PUSH
81107: LD_INT 1
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 2
81116: NEG
81117: PUSH
81118: LD_INT 0
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 2
81127: NEG
81128: PUSH
81129: LD_INT 1
81131: NEG
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 2
81139: NEG
81140: PUSH
81141: LD_INT 2
81143: NEG
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 3
81151: PUSH
81152: LD_INT 1
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 3
81161: PUSH
81162: LD_INT 2
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 2
81171: PUSH
81172: LD_INT 3
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 1
81181: PUSH
81182: LD_INT 3
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: LIST
81208: LIST
81209: LIST
81210: LIST
81211: LIST
81212: LIST
81213: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81214: LD_ADDR_VAR 0 26
81218: PUSH
81219: LD_INT 0
81221: PUSH
81222: LD_INT 0
81224: PUSH
81225: EMPTY
81226: LIST
81227: LIST
81228: PUSH
81229: LD_INT 0
81231: PUSH
81232: LD_INT 1
81234: NEG
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 1
81242: PUSH
81243: LD_INT 0
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 1
81252: PUSH
81253: LD_INT 1
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 0
81262: PUSH
81263: LD_INT 1
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 1
81272: NEG
81273: PUSH
81274: LD_INT 0
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 1
81283: NEG
81284: PUSH
81285: LD_INT 1
81287: NEG
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 1
81295: NEG
81296: PUSH
81297: LD_INT 2
81299: NEG
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 0
81307: PUSH
81308: LD_INT 2
81310: NEG
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: LD_INT 1
81318: PUSH
81319: LD_INT 1
81321: NEG
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 2
81329: PUSH
81330: LD_INT 0
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 2
81339: PUSH
81340: LD_INT 1
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 2
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 1
81359: PUSH
81360: LD_INT 2
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 0
81369: PUSH
81370: LD_INT 2
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 1
81379: NEG
81380: PUSH
81381: LD_INT 1
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 2
81390: NEG
81391: PUSH
81392: LD_INT 0
81394: PUSH
81395: EMPTY
81396: LIST
81397: LIST
81398: PUSH
81399: LD_INT 2
81401: NEG
81402: PUSH
81403: LD_INT 1
81405: NEG
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 2
81413: NEG
81414: PUSH
81415: LD_INT 2
81417: NEG
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 2
81425: PUSH
81426: LD_INT 3
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 1
81435: PUSH
81436: LD_INT 3
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 1
81445: NEG
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: EMPTY
81451: LIST
81452: LIST
81453: PUSH
81454: LD_INT 2
81456: NEG
81457: PUSH
81458: LD_INT 1
81460: PUSH
81461: EMPTY
81462: LIST
81463: LIST
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81490: LD_ADDR_VAR 0 27
81494: PUSH
81495: LD_INT 0
81497: PUSH
81498: LD_INT 0
81500: PUSH
81501: EMPTY
81502: LIST
81503: LIST
81504: PUSH
81505: LD_INT 0
81507: PUSH
81508: LD_INT 1
81510: NEG
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 1
81518: PUSH
81519: LD_INT 0
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 1
81528: PUSH
81529: LD_INT 1
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: LD_INT 0
81538: PUSH
81539: LD_INT 1
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: PUSH
81546: LD_INT 1
81548: NEG
81549: PUSH
81550: LD_INT 0
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 1
81559: NEG
81560: PUSH
81561: LD_INT 1
81563: NEG
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 1
81571: NEG
81572: PUSH
81573: LD_INT 2
81575: NEG
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: PUSH
81581: LD_INT 0
81583: PUSH
81584: LD_INT 2
81586: NEG
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 1
81594: PUSH
81595: LD_INT 1
81597: NEG
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 2
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 2
81615: PUSH
81616: LD_INT 1
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 2
81625: PUSH
81626: LD_INT 2
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 1
81635: PUSH
81636: LD_INT 2
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 0
81645: PUSH
81646: LD_INT 2
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: LD_INT 1
81655: NEG
81656: PUSH
81657: LD_INT 1
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 2
81666: NEG
81667: PUSH
81668: LD_INT 0
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 2
81677: NEG
81678: PUSH
81679: LD_INT 1
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 2
81689: NEG
81690: PUSH
81691: LD_INT 2
81693: NEG
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 1
81701: NEG
81702: PUSH
81703: LD_INT 2
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 2
81712: NEG
81713: PUSH
81714: LD_INT 1
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 3
81723: NEG
81724: PUSH
81725: LD_INT 1
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 3
81735: NEG
81736: PUSH
81737: LD_INT 2
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81770: LD_ADDR_VAR 0 28
81774: PUSH
81775: LD_INT 0
81777: PUSH
81778: LD_INT 0
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 0
81787: PUSH
81788: LD_INT 1
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 1
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 1
81808: PUSH
81809: LD_INT 1
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 0
81818: PUSH
81819: LD_INT 1
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 1
81828: NEG
81829: PUSH
81830: LD_INT 0
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 1
81839: NEG
81840: PUSH
81841: LD_INT 1
81843: NEG
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PUSH
81849: LD_INT 1
81851: NEG
81852: PUSH
81853: LD_INT 2
81855: NEG
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 0
81863: PUSH
81864: LD_INT 2
81866: NEG
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 1
81874: PUSH
81875: LD_INT 1
81877: NEG
81878: PUSH
81879: EMPTY
81880: LIST
81881: LIST
81882: PUSH
81883: LD_INT 2
81885: PUSH
81886: LD_INT 0
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 2
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 2
81905: PUSH
81906: LD_INT 2
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 1
81915: PUSH
81916: LD_INT 2
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 0
81925: PUSH
81926: LD_INT 2
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 1
81935: NEG
81936: PUSH
81937: LD_INT 1
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 2
81946: NEG
81947: PUSH
81948: LD_INT 0
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 2
81957: NEG
81958: PUSH
81959: LD_INT 1
81961: NEG
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 2
81969: NEG
81970: PUSH
81971: LD_INT 2
81973: NEG
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: LD_INT 3
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 1
81993: NEG
81994: PUSH
81995: LD_INT 3
81997: NEG
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 3
82005: NEG
82006: PUSH
82007: LD_INT 1
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 3
82017: NEG
82018: PUSH
82019: LD_INT 2
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82052: LD_ADDR_VAR 0 29
82056: PUSH
82057: LD_INT 0
82059: PUSH
82060: LD_INT 0
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 0
82069: PUSH
82070: LD_INT 1
82072: NEG
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 1
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 1
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 0
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 1
82110: NEG
82111: PUSH
82112: LD_INT 0
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: NEG
82122: PUSH
82123: LD_INT 1
82125: NEG
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: LD_INT 2
82137: NEG
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 0
82145: PUSH
82146: LD_INT 2
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 1
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 2
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 1
82187: PUSH
82188: LD_INT 2
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 0
82197: PUSH
82198: LD_INT 2
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 1
82207: NEG
82208: PUSH
82209: LD_INT 1
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 2
82218: NEG
82219: PUSH
82220: LD_INT 1
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 2
82230: NEG
82231: PUSH
82232: LD_INT 2
82234: NEG
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 2
82242: NEG
82243: PUSH
82244: LD_INT 3
82246: NEG
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 2
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 3
82265: PUSH
82266: LD_INT 1
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 1
82275: PUSH
82276: LD_INT 3
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 1
82285: NEG
82286: PUSH
82287: LD_INT 2
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 3
82296: NEG
82297: PUSH
82298: LD_INT 2
82300: NEG
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82331: LD_ADDR_VAR 0 30
82335: PUSH
82336: LD_INT 0
82338: PUSH
82339: LD_INT 0
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PUSH
82346: LD_INT 0
82348: PUSH
82349: LD_INT 1
82351: NEG
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 1
82359: PUSH
82360: LD_INT 0
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 1
82369: PUSH
82370: LD_INT 1
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 0
82379: PUSH
82380: LD_INT 1
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: LD_INT 0
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 1
82400: NEG
82401: PUSH
82402: LD_INT 1
82404: NEG
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 1
82412: NEG
82413: PUSH
82414: LD_INT 2
82416: NEG
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: LD_INT 2
82427: NEG
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 1
82435: PUSH
82436: LD_INT 1
82438: NEG
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 2
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 2
82456: PUSH
82457: LD_INT 1
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 2
82466: PUSH
82467: LD_INT 2
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 1
82476: PUSH
82477: LD_INT 2
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 1
82486: NEG
82487: PUSH
82488: LD_INT 1
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 2
82497: NEG
82498: PUSH
82499: LD_INT 0
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 2
82508: NEG
82509: PUSH
82510: LD_INT 1
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 1
82520: NEG
82521: PUSH
82522: LD_INT 3
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: LD_INT 2
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 3
82543: PUSH
82544: LD_INT 2
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: LD_INT 3
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 2
82563: NEG
82564: PUSH
82565: LD_INT 1
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 3
82574: NEG
82575: PUSH
82576: LD_INT 1
82578: NEG
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82609: LD_ADDR_VAR 0 31
82613: PUSH
82614: LD_INT 0
82616: PUSH
82617: LD_INT 0
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: LD_INT 0
82626: PUSH
82627: LD_INT 1
82629: NEG
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 1
82637: PUSH
82638: LD_INT 0
82640: PUSH
82641: EMPTY
82642: LIST
82643: LIST
82644: PUSH
82645: LD_INT 1
82647: PUSH
82648: LD_INT 1
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 0
82657: PUSH
82658: LD_INT 1
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 1
82667: NEG
82668: PUSH
82669: LD_INT 0
82671: PUSH
82672: EMPTY
82673: LIST
82674: LIST
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: LD_INT 1
82682: NEG
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PUSH
82688: LD_INT 1
82690: NEG
82691: PUSH
82692: LD_INT 2
82694: NEG
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 1
82702: PUSH
82703: LD_INT 1
82705: NEG
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: PUSH
82711: LD_INT 2
82713: PUSH
82714: LD_INT 0
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 2
82723: PUSH
82724: LD_INT 1
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 2
82733: PUSH
82734: LD_INT 2
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 1
82743: PUSH
82744: LD_INT 2
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 0
82753: PUSH
82754: LD_INT 2
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 1
82763: NEG
82764: PUSH
82765: LD_INT 1
82767: PUSH
82768: EMPTY
82769: LIST
82770: LIST
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: LD_INT 1
82778: NEG
82779: PUSH
82780: EMPTY
82781: LIST
82782: LIST
82783: PUSH
82784: LD_INT 2
82786: NEG
82787: PUSH
82788: LD_INT 2
82790: NEG
82791: PUSH
82792: EMPTY
82793: LIST
82794: LIST
82795: PUSH
82796: LD_INT 2
82798: NEG
82799: PUSH
82800: LD_INT 3
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 2
82810: PUSH
82811: LD_INT 1
82813: NEG
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 3
82821: PUSH
82822: LD_INT 1
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 1
82831: PUSH
82832: LD_INT 3
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 1
82841: NEG
82842: PUSH
82843: LD_INT 2
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 3
82852: NEG
82853: PUSH
82854: LD_INT 2
82856: NEG
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82887: LD_ADDR_VAR 0 32
82891: PUSH
82892: LD_INT 0
82894: PUSH
82895: LD_INT 0
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 0
82904: PUSH
82905: LD_INT 1
82907: NEG
82908: PUSH
82909: EMPTY
82910: LIST
82911: LIST
82912: PUSH
82913: LD_INT 1
82915: PUSH
82916: LD_INT 0
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 1
82925: PUSH
82926: LD_INT 1
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 0
82935: PUSH
82936: LD_INT 1
82938: PUSH
82939: EMPTY
82940: LIST
82941: LIST
82942: PUSH
82943: LD_INT 1
82945: NEG
82946: PUSH
82947: LD_INT 0
82949: PUSH
82950: EMPTY
82951: LIST
82952: LIST
82953: PUSH
82954: LD_INT 1
82956: NEG
82957: PUSH
82958: LD_INT 1
82960: NEG
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 1
82968: NEG
82969: PUSH
82970: LD_INT 2
82972: NEG
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 0
82980: PUSH
82981: LD_INT 2
82983: NEG
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 1
82991: PUSH
82992: LD_INT 1
82994: NEG
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 2
83002: PUSH
83003: LD_INT 1
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 2
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: PUSH
83023: LD_INT 2
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 0
83032: PUSH
83033: LD_INT 2
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 1
83042: NEG
83043: PUSH
83044: LD_INT 1
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 2
83053: NEG
83054: PUSH
83055: LD_INT 0
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 2
83064: NEG
83065: PUSH
83066: LD_INT 1
83068: NEG
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 1
83076: NEG
83077: PUSH
83078: LD_INT 3
83080: NEG
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: PUSH
83089: LD_INT 2
83091: NEG
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 3
83099: PUSH
83100: LD_INT 2
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 2
83109: PUSH
83110: LD_INT 3
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: NEG
83120: PUSH
83121: LD_INT 1
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 3
83130: NEG
83131: PUSH
83132: LD_INT 1
83134: NEG
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83165: LD_ADDR_VAR 0 33
83169: PUSH
83170: LD_INT 0
83172: PUSH
83173: LD_INT 0
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 1
83193: PUSH
83194: LD_INT 0
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 1
83203: PUSH
83204: LD_INT 1
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 0
83213: PUSH
83214: LD_INT 1
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 1
83223: NEG
83224: PUSH
83225: LD_INT 0
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: PUSH
83232: LD_INT 1
83234: NEG
83235: PUSH
83236: LD_INT 1
83238: NEG
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: LD_INT 1
83246: NEG
83247: PUSH
83248: LD_INT 2
83250: NEG
83251: PUSH
83252: EMPTY
83253: LIST
83254: LIST
83255: PUSH
83256: LD_INT 1
83258: PUSH
83259: LD_INT 1
83261: NEG
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 2
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: PUSH
83277: LD_INT 2
83279: PUSH
83280: LD_INT 1
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 1
83289: PUSH
83290: LD_INT 2
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 0
83299: PUSH
83300: LD_INT 2
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 1
83309: NEG
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 2
83320: NEG
83321: PUSH
83322: LD_INT 0
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 2
83331: NEG
83332: PUSH
83333: LD_INT 1
83335: NEG
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 2
83343: NEG
83344: PUSH
83345: LD_INT 2
83347: NEG
83348: PUSH
83349: EMPTY
83350: LIST
83351: LIST
83352: PUSH
83353: LD_INT 2
83355: NEG
83356: PUSH
83357: LD_INT 3
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 1
83370: NEG
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 3
83378: PUSH
83379: LD_INT 1
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 1
83388: PUSH
83389: LD_INT 3
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 1
83398: NEG
83399: PUSH
83400: LD_INT 2
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 3
83409: NEG
83410: PUSH
83411: LD_INT 2
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: LIST
83423: LIST
83424: LIST
83425: LIST
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83444: LD_ADDR_VAR 0 34
83448: PUSH
83449: LD_INT 0
83451: PUSH
83452: LD_INT 0
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: LD_INT 1
83464: NEG
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 1
83472: PUSH
83473: LD_INT 0
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 1
83482: PUSH
83483: LD_INT 1
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 0
83492: PUSH
83493: LD_INT 1
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 1
83502: NEG
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 1
83513: NEG
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 1
83525: NEG
83526: PUSH
83527: LD_INT 2
83529: NEG
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 0
83537: PUSH
83538: LD_INT 2
83540: NEG
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 1
83548: PUSH
83549: LD_INT 1
83551: NEG
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: PUSH
83560: LD_INT 1
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 2
83569: PUSH
83570: LD_INT 2
83572: PUSH
83573: EMPTY
83574: LIST
83575: LIST
83576: PUSH
83577: LD_INT 1
83579: PUSH
83580: LD_INT 2
83582: PUSH
83583: EMPTY
83584: LIST
83585: LIST
83586: PUSH
83587: LD_INT 1
83589: NEG
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: PUSH
83598: LD_INT 2
83600: NEG
83601: PUSH
83602: LD_INT 0
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 2
83611: NEG
83612: PUSH
83613: LD_INT 1
83615: NEG
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 2
83623: NEG
83624: PUSH
83625: LD_INT 2
83627: NEG
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PUSH
83633: LD_INT 1
83635: NEG
83636: PUSH
83637: LD_INT 3
83639: NEG
83640: PUSH
83641: EMPTY
83642: LIST
83643: LIST
83644: PUSH
83645: LD_INT 1
83647: PUSH
83648: LD_INT 2
83650: NEG
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 3
83658: PUSH
83659: LD_INT 2
83661: PUSH
83662: EMPTY
83663: LIST
83664: LIST
83665: PUSH
83666: LD_INT 2
83668: PUSH
83669: LD_INT 3
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 2
83678: NEG
83679: PUSH
83680: LD_INT 1
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 3
83689: NEG
83690: PUSH
83691: LD_INT 1
83693: NEG
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83724: LD_ADDR_VAR 0 35
83728: PUSH
83729: LD_INT 0
83731: PUSH
83732: LD_INT 0
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 0
83741: PUSH
83742: LD_INT 1
83744: NEG
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_INT 1
83752: PUSH
83753: LD_INT 0
83755: PUSH
83756: EMPTY
83757: LIST
83758: LIST
83759: PUSH
83760: LD_INT 1
83762: PUSH
83763: LD_INT 1
83765: PUSH
83766: EMPTY
83767: LIST
83768: LIST
83769: PUSH
83770: LD_INT 0
83772: PUSH
83773: LD_INT 1
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: PUSH
83780: LD_INT 1
83782: NEG
83783: PUSH
83784: LD_INT 0
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PUSH
83791: LD_INT 1
83793: NEG
83794: PUSH
83795: LD_INT 1
83797: NEG
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 2
83805: PUSH
83806: LD_INT 1
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 2
83815: NEG
83816: PUSH
83817: LD_INT 1
83819: NEG
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83836: LD_ADDR_VAR 0 36
83840: PUSH
83841: LD_INT 0
83843: PUSH
83844: LD_INT 0
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 0
83853: PUSH
83854: LD_INT 1
83856: NEG
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 1
83864: PUSH
83865: LD_INT 0
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: PUSH
83872: LD_INT 1
83874: PUSH
83875: LD_INT 1
83877: PUSH
83878: EMPTY
83879: LIST
83880: LIST
83881: PUSH
83882: LD_INT 0
83884: PUSH
83885: LD_INT 1
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 1
83894: NEG
83895: PUSH
83896: LD_INT 0
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: PUSH
83903: LD_INT 1
83905: NEG
83906: PUSH
83907: LD_INT 1
83909: NEG
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 1
83917: NEG
83918: PUSH
83919: LD_INT 2
83921: NEG
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 1
83929: PUSH
83930: LD_INT 2
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83948: LD_ADDR_VAR 0 37
83952: PUSH
83953: LD_INT 0
83955: PUSH
83956: LD_INT 0
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 0
83965: PUSH
83966: LD_INT 1
83968: NEG
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 1
83976: PUSH
83977: LD_INT 0
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 1
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 0
83996: PUSH
83997: LD_INT 1
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 1
84006: NEG
84007: PUSH
84008: LD_INT 0
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PUSH
84015: LD_INT 1
84017: NEG
84018: PUSH
84019: LD_INT 1
84021: NEG
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 1
84029: PUSH
84030: LD_INT 1
84032: NEG
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 1
84040: NEG
84041: PUSH
84042: LD_INT 1
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: LIST
84053: LIST
84054: LIST
84055: LIST
84056: LIST
84057: LIST
84058: LIST
84059: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84060: LD_ADDR_VAR 0 38
84064: PUSH
84065: LD_INT 0
84067: PUSH
84068: LD_INT 0
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 0
84077: PUSH
84078: LD_INT 1
84080: NEG
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 1
84088: PUSH
84089: LD_INT 0
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 1
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 0
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: PUSH
84116: LD_INT 1
84118: NEG
84119: PUSH
84120: LD_INT 0
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 1
84129: NEG
84130: PUSH
84131: LD_INT 1
84133: NEG
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 2
84141: PUSH
84142: LD_INT 1
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 2
84151: NEG
84152: PUSH
84153: LD_INT 1
84155: NEG
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84172: LD_ADDR_VAR 0 39
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: LD_INT 0
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 0
84189: PUSH
84190: LD_INT 1
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: LD_INT 0
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 1
84210: PUSH
84211: LD_INT 1
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: LD_INT 0
84220: PUSH
84221: LD_INT 1
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 1
84230: NEG
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 1
84241: NEG
84242: PUSH
84243: LD_INT 1
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 1
84253: NEG
84254: PUSH
84255: LD_INT 2
84257: NEG
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: LD_INT 2
84268: PUSH
84269: EMPTY
84270: LIST
84271: LIST
84272: PUSH
84273: EMPTY
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84284: LD_ADDR_VAR 0 40
84288: PUSH
84289: LD_INT 0
84291: PUSH
84292: LD_INT 0
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 0
84301: PUSH
84302: LD_INT 1
84304: NEG
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: PUSH
84310: LD_INT 1
84312: PUSH
84313: LD_INT 0
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: LD_INT 1
84322: PUSH
84323: LD_INT 1
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PUSH
84330: LD_INT 0
84332: PUSH
84333: LD_INT 1
84335: PUSH
84336: EMPTY
84337: LIST
84338: LIST
84339: PUSH
84340: LD_INT 1
84342: NEG
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: LD_INT 1
84357: NEG
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 1
84365: PUSH
84366: LD_INT 1
84368: NEG
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: LD_INT 1
84376: NEG
84377: PUSH
84378: LD_INT 1
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84396: LD_ADDR_VAR 0 41
84400: PUSH
84401: LD_INT 0
84403: PUSH
84404: LD_INT 0
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: PUSH
84411: LD_INT 0
84413: PUSH
84414: LD_INT 1
84416: NEG
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 1
84424: PUSH
84425: LD_INT 0
84427: PUSH
84428: EMPTY
84429: LIST
84430: LIST
84431: PUSH
84432: LD_INT 1
84434: PUSH
84435: LD_INT 1
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: LD_INT 1
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PUSH
84452: LD_INT 1
84454: NEG
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 1
84465: NEG
84466: PUSH
84467: LD_INT 1
84469: NEG
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 1
84477: NEG
84478: PUSH
84479: LD_INT 2
84481: NEG
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 1
84489: PUSH
84490: LD_INT 1
84492: NEG
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: PUSH
84498: LD_INT 2
84500: PUSH
84501: LD_INT 0
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: PUSH
84508: LD_INT 2
84510: PUSH
84511: LD_INT 1
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: LD_INT 2
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 1
84530: PUSH
84531: LD_INT 2
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 1
84540: NEG
84541: PUSH
84542: LD_INT 1
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 2
84551: NEG
84552: PUSH
84553: LD_INT 0
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 2
84562: NEG
84563: PUSH
84564: LD_INT 1
84566: NEG
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 2
84574: NEG
84575: PUSH
84576: LD_INT 2
84578: NEG
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 2
84586: NEG
84587: PUSH
84588: LD_INT 3
84590: NEG
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 2
84598: PUSH
84599: LD_INT 1
84601: NEG
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 3
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 3
84619: PUSH
84620: LD_INT 1
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 3
84629: PUSH
84630: LD_INT 2
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 3
84639: PUSH
84640: LD_INT 3
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 2
84649: PUSH
84650: LD_INT 3
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 2
84659: NEG
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 3
84670: NEG
84671: PUSH
84672: LD_INT 0
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 3
84681: NEG
84682: PUSH
84683: LD_INT 1
84685: NEG
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 3
84693: NEG
84694: PUSH
84695: LD_INT 2
84697: NEG
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 3
84705: NEG
84706: PUSH
84707: LD_INT 3
84709: NEG
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: LIST
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84746: LD_ADDR_VAR 0 42
84750: PUSH
84751: LD_INT 0
84753: PUSH
84754: LD_INT 0
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 0
84763: PUSH
84764: LD_INT 1
84766: NEG
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 1
84774: PUSH
84775: LD_INT 0
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 1
84784: PUSH
84785: LD_INT 1
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 0
84794: PUSH
84795: LD_INT 1
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 1
84804: NEG
84805: PUSH
84806: LD_INT 0
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 1
84815: NEG
84816: PUSH
84817: LD_INT 1
84819: NEG
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 1
84827: NEG
84828: PUSH
84829: LD_INT 2
84831: NEG
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 0
84839: PUSH
84840: LD_INT 2
84842: NEG
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: PUSH
84851: LD_INT 1
84853: NEG
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 2
84861: PUSH
84862: LD_INT 1
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 2
84871: PUSH
84872: LD_INT 2
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 1
84881: PUSH
84882: LD_INT 2
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: LD_INT 2
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 1
84901: NEG
84902: PUSH
84903: LD_INT 1
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 2
84912: NEG
84913: PUSH
84914: LD_INT 1
84916: NEG
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 2
84924: NEG
84925: PUSH
84926: LD_INT 2
84928: NEG
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 2
84936: NEG
84937: PUSH
84938: LD_INT 3
84940: NEG
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 1
84948: NEG
84949: PUSH
84950: LD_INT 3
84952: NEG
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PUSH
84958: LD_INT 0
84960: PUSH
84961: LD_INT 3
84963: NEG
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: LD_INT 1
84971: PUSH
84972: LD_INT 2
84974: NEG
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 3
84982: PUSH
84983: LD_INT 2
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 3
84992: PUSH
84993: LD_INT 3
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 2
85002: PUSH
85003: LD_INT 3
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 1
85012: PUSH
85013: LD_INT 3
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 0
85022: PUSH
85023: LD_INT 3
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: NEG
85033: PUSH
85034: LD_INT 2
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 3
85043: NEG
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 3
85055: NEG
85056: PUSH
85057: LD_INT 3
85059: NEG
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85096: LD_ADDR_VAR 0 43
85100: PUSH
85101: LD_INT 0
85103: PUSH
85104: LD_INT 0
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 0
85113: PUSH
85114: LD_INT 1
85116: NEG
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 1
85124: PUSH
85125: LD_INT 0
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 1
85134: PUSH
85135: LD_INT 1
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: LD_INT 1
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: LD_INT 0
85158: PUSH
85159: EMPTY
85160: LIST
85161: LIST
85162: PUSH
85163: LD_INT 1
85165: NEG
85166: PUSH
85167: LD_INT 1
85169: NEG
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 1
85177: NEG
85178: PUSH
85179: LD_INT 2
85181: NEG
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 0
85189: PUSH
85190: LD_INT 2
85192: NEG
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 1
85200: PUSH
85201: LD_INT 1
85203: NEG
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 2
85211: PUSH
85212: LD_INT 0
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: PUSH
85219: LD_INT 2
85221: PUSH
85222: LD_INT 1
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: PUSH
85229: LD_INT 1
85231: PUSH
85232: LD_INT 2
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 0
85241: PUSH
85242: LD_INT 2
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 1
85251: NEG
85252: PUSH
85253: LD_INT 1
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: LD_INT 2
85262: NEG
85263: PUSH
85264: LD_INT 0
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: PUSH
85271: LD_INT 2
85273: NEG
85274: PUSH
85275: LD_INT 1
85277: NEG
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 1
85285: NEG
85286: PUSH
85287: LD_INT 3
85289: NEG
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 0
85297: PUSH
85298: LD_INT 3
85300: NEG
85301: PUSH
85302: EMPTY
85303: LIST
85304: LIST
85305: PUSH
85306: LD_INT 1
85308: PUSH
85309: LD_INT 2
85311: NEG
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: PUSH
85317: LD_INT 2
85319: PUSH
85320: LD_INT 1
85322: NEG
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 3
85330: PUSH
85331: LD_INT 0
85333: PUSH
85334: EMPTY
85335: LIST
85336: LIST
85337: PUSH
85338: LD_INT 3
85340: PUSH
85341: LD_INT 1
85343: PUSH
85344: EMPTY
85345: LIST
85346: LIST
85347: PUSH
85348: LD_INT 1
85350: PUSH
85351: LD_INT 3
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 0
85360: PUSH
85361: LD_INT 3
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 1
85370: NEG
85371: PUSH
85372: LD_INT 2
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 2
85381: NEG
85382: PUSH
85383: LD_INT 1
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 3
85392: NEG
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 3
85403: NEG
85404: PUSH
85405: LD_INT 1
85407: NEG
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: PUSH
85413: EMPTY
85414: LIST
85415: LIST
85416: LIST
85417: LIST
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: LIST
85439: LIST
85440: LIST
85441: LIST
85442: LIST
85443: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85444: LD_ADDR_VAR 0 44
85448: PUSH
85449: LD_INT 0
85451: PUSH
85452: LD_INT 0
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: PUSH
85459: LD_INT 0
85461: PUSH
85462: LD_INT 1
85464: NEG
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 1
85472: PUSH
85473: LD_INT 0
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 1
85482: PUSH
85483: LD_INT 1
85485: PUSH
85486: EMPTY
85487: LIST
85488: LIST
85489: PUSH
85490: LD_INT 0
85492: PUSH
85493: LD_INT 1
85495: PUSH
85496: EMPTY
85497: LIST
85498: LIST
85499: PUSH
85500: LD_INT 1
85502: NEG
85503: PUSH
85504: LD_INT 0
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 1
85513: NEG
85514: PUSH
85515: LD_INT 1
85517: NEG
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: LD_INT 2
85529: NEG
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PUSH
85535: LD_INT 1
85537: PUSH
85538: LD_INT 1
85540: NEG
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 2
85548: PUSH
85549: LD_INT 0
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: PUSH
85556: LD_INT 2
85558: PUSH
85559: LD_INT 1
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 2
85568: PUSH
85569: LD_INT 2
85571: PUSH
85572: EMPTY
85573: LIST
85574: LIST
85575: PUSH
85576: LD_INT 1
85578: PUSH
85579: LD_INT 2
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: NEG
85589: PUSH
85590: LD_INT 1
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 2
85599: NEG
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: PUSH
85608: LD_INT 2
85610: NEG
85611: PUSH
85612: LD_INT 1
85614: NEG
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 2
85622: NEG
85623: PUSH
85624: LD_INT 2
85626: NEG
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 2
85634: NEG
85635: PUSH
85636: LD_INT 3
85638: NEG
85639: PUSH
85640: EMPTY
85641: LIST
85642: LIST
85643: PUSH
85644: LD_INT 2
85646: PUSH
85647: LD_INT 1
85649: NEG
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: LD_INT 3
85657: PUSH
85658: LD_INT 0
85660: PUSH
85661: EMPTY
85662: LIST
85663: LIST
85664: PUSH
85665: LD_INT 3
85667: PUSH
85668: LD_INT 1
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 3
85677: PUSH
85678: LD_INT 2
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 3
85687: PUSH
85688: LD_INT 3
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 2
85697: PUSH
85698: LD_INT 3
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 2
85707: NEG
85708: PUSH
85709: LD_INT 1
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 3
85718: NEG
85719: PUSH
85720: LD_INT 0
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 3
85729: NEG
85730: PUSH
85731: LD_INT 1
85733: NEG
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 3
85741: NEG
85742: PUSH
85743: LD_INT 2
85745: NEG
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 3
85753: NEG
85754: PUSH
85755: LD_INT 3
85757: NEG
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85794: LD_ADDR_VAR 0 45
85798: PUSH
85799: LD_INT 0
85801: PUSH
85802: LD_INT 0
85804: PUSH
85805: EMPTY
85806: LIST
85807: LIST
85808: PUSH
85809: LD_INT 0
85811: PUSH
85812: LD_INT 1
85814: NEG
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: PUSH
85823: LD_INT 0
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 1
85832: PUSH
85833: LD_INT 1
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: LD_INT 1
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 1
85852: NEG
85853: PUSH
85854: LD_INT 0
85856: PUSH
85857: EMPTY
85858: LIST
85859: LIST
85860: PUSH
85861: LD_INT 1
85863: NEG
85864: PUSH
85865: LD_INT 1
85867: NEG
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 1
85875: NEG
85876: PUSH
85877: LD_INT 2
85879: NEG
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 0
85887: PUSH
85888: LD_INT 2
85890: NEG
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 1
85898: PUSH
85899: LD_INT 1
85901: NEG
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 2
85909: PUSH
85910: LD_INT 1
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 2
85919: PUSH
85920: LD_INT 2
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 1
85929: PUSH
85930: LD_INT 2
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: LD_INT 2
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_INT 1
85949: NEG
85950: PUSH
85951: LD_INT 1
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 2
85960: NEG
85961: PUSH
85962: LD_INT 1
85964: NEG
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 2
85972: NEG
85973: PUSH
85974: LD_INT 2
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 2
85984: NEG
85985: PUSH
85986: LD_INT 3
85988: NEG
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 1
85996: NEG
85997: PUSH
85998: LD_INT 3
86000: NEG
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 0
86008: PUSH
86009: LD_INT 3
86011: NEG
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 1
86019: PUSH
86020: LD_INT 2
86022: NEG
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: LD_INT 3
86030: PUSH
86031: LD_INT 2
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 3
86040: PUSH
86041: LD_INT 3
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 2
86050: PUSH
86051: LD_INT 3
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 1
86060: PUSH
86061: LD_INT 3
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 0
86070: PUSH
86071: LD_INT 3
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 1
86080: NEG
86081: PUSH
86082: LD_INT 2
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 3
86091: NEG
86092: PUSH
86093: LD_INT 2
86095: NEG
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PUSH
86101: LD_INT 3
86103: NEG
86104: PUSH
86105: LD_INT 3
86107: NEG
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: EMPTY
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: LIST
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86144: LD_ADDR_VAR 0 46
86148: PUSH
86149: LD_INT 0
86151: PUSH
86152: LD_INT 0
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 0
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: LD_INT 1
86172: PUSH
86173: LD_INT 0
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: PUSH
86180: LD_INT 1
86182: PUSH
86183: LD_INT 1
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: LD_INT 1
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 1
86213: NEG
86214: PUSH
86215: LD_INT 1
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 1
86225: NEG
86226: PUSH
86227: LD_INT 2
86229: NEG
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 0
86237: PUSH
86238: LD_INT 2
86240: NEG
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 1
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 2
86259: PUSH
86260: LD_INT 0
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: LD_INT 2
86269: PUSH
86270: LD_INT 1
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 1
86279: PUSH
86280: LD_INT 2
86282: PUSH
86283: EMPTY
86284: LIST
86285: LIST
86286: PUSH
86287: LD_INT 0
86289: PUSH
86290: LD_INT 2
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 1
86299: NEG
86300: PUSH
86301: LD_INT 1
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: LD_INT 2
86310: NEG
86311: PUSH
86312: LD_INT 0
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 2
86321: NEG
86322: PUSH
86323: LD_INT 1
86325: NEG
86326: PUSH
86327: EMPTY
86328: LIST
86329: LIST
86330: PUSH
86331: LD_INT 1
86333: NEG
86334: PUSH
86335: LD_INT 3
86337: NEG
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 0
86345: PUSH
86346: LD_INT 3
86348: NEG
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 1
86356: PUSH
86357: LD_INT 2
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 2
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 3
86378: PUSH
86379: LD_INT 0
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 3
86388: PUSH
86389: LD_INT 1
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 1
86398: PUSH
86399: LD_INT 3
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 0
86408: PUSH
86409: LD_INT 3
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 1
86418: NEG
86419: PUSH
86420: LD_INT 2
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PUSH
86427: LD_INT 2
86429: NEG
86430: PUSH
86431: LD_INT 1
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 3
86440: NEG
86441: PUSH
86442: LD_INT 0
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 3
86451: NEG
86452: PUSH
86453: LD_INT 1
86455: NEG
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: LIST
86475: LIST
86476: LIST
86477: LIST
86478: LIST
86479: LIST
86480: LIST
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86492: LD_ADDR_VAR 0 47
86496: PUSH
86497: LD_INT 0
86499: PUSH
86500: LD_INT 0
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 0
86509: PUSH
86510: LD_INT 1
86512: NEG
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 1
86520: PUSH
86521: LD_INT 0
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 1
86530: PUSH
86531: LD_INT 1
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: LD_INT 1
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 1
86550: NEG
86551: PUSH
86552: LD_INT 0
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 1
86561: NEG
86562: PUSH
86563: LD_INT 1
86565: NEG
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 1
86573: NEG
86574: PUSH
86575: LD_INT 2
86577: NEG
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 0
86585: PUSH
86586: LD_INT 2
86588: NEG
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 1
86596: PUSH
86597: LD_INT 1
86599: NEG
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: LD_INT 2
86607: NEG
86608: PUSH
86609: LD_INT 1
86611: NEG
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 2
86619: NEG
86620: PUSH
86621: LD_INT 2
86623: NEG
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: EMPTY
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86643: LD_ADDR_VAR 0 48
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: LD_INT 0
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: PUSH
86658: LD_INT 0
86660: PUSH
86661: LD_INT 1
86663: NEG
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 1
86671: PUSH
86672: LD_INT 0
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: PUSH
86679: LD_INT 1
86681: PUSH
86682: LD_INT 1
86684: PUSH
86685: EMPTY
86686: LIST
86687: LIST
86688: PUSH
86689: LD_INT 0
86691: PUSH
86692: LD_INT 1
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: PUSH
86699: LD_INT 1
86701: NEG
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 1
86712: NEG
86713: PUSH
86714: LD_INT 1
86716: NEG
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 1
86724: NEG
86725: PUSH
86726: LD_INT 2
86728: NEG
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: LD_INT 0
86736: PUSH
86737: LD_INT 2
86739: NEG
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 1
86747: PUSH
86748: LD_INT 1
86750: NEG
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 2
86758: PUSH
86759: LD_INT 0
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 2
86768: PUSH
86769: LD_INT 1
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: EMPTY
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86790: LD_ADDR_VAR 0 49
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: LD_INT 0
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 0
86807: PUSH
86808: LD_INT 1
86810: NEG
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 1
86818: PUSH
86819: LD_INT 0
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: LD_INT 1
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 0
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 1
86848: NEG
86849: PUSH
86850: LD_INT 0
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 1
86859: NEG
86860: PUSH
86861: LD_INT 1
86863: NEG
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: LD_INT 1
86874: NEG
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: LD_INT 2
86882: PUSH
86883: LD_INT 0
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 2
86892: PUSH
86893: LD_INT 1
86895: PUSH
86896: EMPTY
86897: LIST
86898: LIST
86899: PUSH
86900: LD_INT 2
86902: PUSH
86903: LD_INT 2
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 1
86912: PUSH
86913: LD_INT 2
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86934: LD_ADDR_VAR 0 50
86938: PUSH
86939: LD_INT 0
86941: PUSH
86942: LD_INT 0
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 0
86951: PUSH
86952: LD_INT 1
86954: NEG
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 1
86962: PUSH
86963: LD_INT 0
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: PUSH
86973: LD_INT 1
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 0
86982: PUSH
86983: LD_INT 1
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 1
86992: NEG
86993: PUSH
86994: LD_INT 0
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 1
87003: NEG
87004: PUSH
87005: LD_INT 1
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 2
87015: PUSH
87016: LD_INT 1
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 2
87025: PUSH
87026: LD_INT 2
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 1
87035: PUSH
87036: LD_INT 2
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: LD_INT 0
87045: PUSH
87046: LD_INT 2
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 1
87055: NEG
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87078: LD_ADDR_VAR 0 51
87082: PUSH
87083: LD_INT 0
87085: PUSH
87086: LD_INT 0
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 0
87095: PUSH
87096: LD_INT 1
87098: NEG
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: PUSH
87104: LD_INT 1
87106: PUSH
87107: LD_INT 0
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 1
87116: PUSH
87117: LD_INT 1
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: LD_INT 1
87129: PUSH
87130: EMPTY
87131: LIST
87132: LIST
87133: PUSH
87134: LD_INT 1
87136: NEG
87137: PUSH
87138: LD_INT 0
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 1
87147: NEG
87148: PUSH
87149: LD_INT 1
87151: NEG
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: PUSH
87157: LD_INT 1
87159: PUSH
87160: LD_INT 2
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: LD_INT 2
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: LD_INT 1
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PUSH
87188: LD_INT 2
87190: NEG
87191: PUSH
87192: LD_INT 0
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 2
87201: NEG
87202: PUSH
87203: LD_INT 1
87205: NEG
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87225: LD_ADDR_VAR 0 52
87229: PUSH
87230: LD_INT 0
87232: PUSH
87233: LD_INT 0
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 0
87242: PUSH
87243: LD_INT 1
87245: NEG
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: LD_INT 1
87253: PUSH
87254: LD_INT 0
87256: PUSH
87257: EMPTY
87258: LIST
87259: LIST
87260: PUSH
87261: LD_INT 1
87263: PUSH
87264: LD_INT 1
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: LD_INT 1
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PUSH
87281: LD_INT 1
87283: NEG
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 1
87294: NEG
87295: PUSH
87296: LD_INT 1
87298: NEG
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 2
87310: NEG
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: NEG
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 2
87329: NEG
87330: PUSH
87331: LD_INT 0
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 2
87340: NEG
87341: PUSH
87342: LD_INT 1
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 2
87352: NEG
87353: PUSH
87354: LD_INT 2
87356: NEG
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: LIST
87366: LIST
87367: LIST
87368: LIST
87369: LIST
87370: LIST
87371: LIST
87372: LIST
87373: LIST
87374: LIST
87375: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87376: LD_ADDR_VAR 0 53
87380: PUSH
87381: LD_INT 0
87383: PUSH
87384: LD_INT 0
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 0
87393: PUSH
87394: LD_INT 1
87396: NEG
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: PUSH
87402: LD_INT 1
87404: PUSH
87405: LD_INT 0
87407: PUSH
87408: EMPTY
87409: LIST
87410: LIST
87411: PUSH
87412: LD_INT 1
87414: PUSH
87415: LD_INT 1
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: LD_INT 1
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PUSH
87432: LD_INT 1
87434: NEG
87435: PUSH
87436: LD_INT 0
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: LD_INT 1
87445: NEG
87446: PUSH
87447: LD_INT 1
87449: NEG
87450: PUSH
87451: EMPTY
87452: LIST
87453: LIST
87454: PUSH
87455: LD_INT 1
87457: NEG
87458: PUSH
87459: LD_INT 2
87461: NEG
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 0
87469: PUSH
87470: LD_INT 2
87472: NEG
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 1
87480: PUSH
87481: LD_INT 1
87483: NEG
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: PUSH
87489: LD_INT 2
87491: PUSH
87492: LD_INT 0
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 2
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: PUSH
87509: LD_INT 2
87511: PUSH
87512: LD_INT 2
87514: PUSH
87515: EMPTY
87516: LIST
87517: LIST
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: LD_INT 2
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: LD_INT 0
87531: PUSH
87532: LD_INT 2
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 1
87541: NEG
87542: PUSH
87543: LD_INT 1
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 2
87552: NEG
87553: PUSH
87554: LD_INT 0
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 2
87563: NEG
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 2
87575: NEG
87576: PUSH
87577: LD_INT 2
87579: NEG
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: LIST
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87606: LD_ADDR_VAR 0 54
87610: PUSH
87611: LD_INT 0
87613: PUSH
87614: LD_INT 0
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 0
87623: PUSH
87624: LD_INT 1
87626: NEG
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 1
87634: PUSH
87635: LD_INT 0
87637: PUSH
87638: EMPTY
87639: LIST
87640: LIST
87641: PUSH
87642: LD_INT 1
87644: PUSH
87645: LD_INT 1
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 0
87654: PUSH
87655: LD_INT 1
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 1
87664: NEG
87665: PUSH
87666: LD_INT 0
87668: PUSH
87669: EMPTY
87670: LIST
87671: LIST
87672: PUSH
87673: LD_INT 1
87675: NEG
87676: PUSH
87677: LD_INT 1
87679: NEG
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: LD_INT 1
87687: NEG
87688: PUSH
87689: LD_INT 2
87691: NEG
87692: PUSH
87693: EMPTY
87694: LIST
87695: LIST
87696: PUSH
87697: LD_INT 0
87699: PUSH
87700: LD_INT 2
87702: NEG
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 2
87721: PUSH
87722: LD_INT 0
87724: PUSH
87725: EMPTY
87726: LIST
87727: LIST
87728: PUSH
87729: LD_INT 2
87731: PUSH
87732: LD_INT 1
87734: PUSH
87735: EMPTY
87736: LIST
87737: LIST
87738: PUSH
87739: LD_INT 2
87741: PUSH
87742: LD_INT 2
87744: PUSH
87745: EMPTY
87746: LIST
87747: LIST
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: LD_INT 2
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 0
87761: PUSH
87762: LD_INT 2
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 1
87771: NEG
87772: PUSH
87773: LD_INT 1
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 2
87782: NEG
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 2
87793: NEG
87794: PUSH
87795: LD_INT 1
87797: NEG
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 2
87805: NEG
87806: PUSH
87807: LD_INT 2
87809: NEG
87810: PUSH
87811: EMPTY
87812: LIST
87813: LIST
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87836: LD_ADDR_VAR 0 55
87840: PUSH
87841: LD_INT 0
87843: PUSH
87844: LD_INT 0
87846: PUSH
87847: EMPTY
87848: LIST
87849: LIST
87850: PUSH
87851: LD_INT 0
87853: PUSH
87854: LD_INT 1
87856: NEG
87857: PUSH
87858: EMPTY
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 1
87864: PUSH
87865: LD_INT 0
87867: PUSH
87868: EMPTY
87869: LIST
87870: LIST
87871: PUSH
87872: LD_INT 1
87874: PUSH
87875: LD_INT 1
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_INT 1
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PUSH
87892: LD_INT 1
87894: NEG
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: PUSH
87903: LD_INT 1
87905: NEG
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 1
87917: NEG
87918: PUSH
87919: LD_INT 2
87921: NEG
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: LD_INT 2
87932: NEG
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 1
87940: PUSH
87941: LD_INT 1
87943: NEG
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 2
87951: PUSH
87952: LD_INT 0
87954: PUSH
87955: EMPTY
87956: LIST
87957: LIST
87958: PUSH
87959: LD_INT 2
87961: PUSH
87962: LD_INT 1
87964: PUSH
87965: EMPTY
87966: LIST
87967: LIST
87968: PUSH
87969: LD_INT 2
87971: PUSH
87972: LD_INT 2
87974: PUSH
87975: EMPTY
87976: LIST
87977: LIST
87978: PUSH
87979: LD_INT 1
87981: PUSH
87982: LD_INT 2
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 0
87991: PUSH
87992: LD_INT 2
87994: PUSH
87995: EMPTY
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 1
88001: NEG
88002: PUSH
88003: LD_INT 1
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 2
88012: NEG
88013: PUSH
88014: LD_INT 0
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 2
88023: NEG
88024: PUSH
88025: LD_INT 1
88027: NEG
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: PUSH
88033: LD_INT 2
88035: NEG
88036: PUSH
88037: LD_INT 2
88039: NEG
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88066: LD_ADDR_VAR 0 56
88070: PUSH
88071: LD_INT 0
88073: PUSH
88074: LD_INT 0
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 0
88083: PUSH
88084: LD_INT 1
88086: NEG
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: PUSH
88092: LD_INT 1
88094: PUSH
88095: LD_INT 0
88097: PUSH
88098: EMPTY
88099: LIST
88100: LIST
88101: PUSH
88102: LD_INT 1
88104: PUSH
88105: LD_INT 1
88107: PUSH
88108: EMPTY
88109: LIST
88110: LIST
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: LD_INT 1
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 1
88124: NEG
88125: PUSH
88126: LD_INT 0
88128: PUSH
88129: EMPTY
88130: LIST
88131: LIST
88132: PUSH
88133: LD_INT 1
88135: NEG
88136: PUSH
88137: LD_INT 1
88139: NEG
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 1
88147: NEG
88148: PUSH
88149: LD_INT 2
88151: NEG
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 0
88159: PUSH
88160: LD_INT 2
88162: NEG
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 1
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 2
88181: PUSH
88182: LD_INT 0
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: PUSH
88189: LD_INT 2
88191: PUSH
88192: LD_INT 1
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PUSH
88199: LD_INT 2
88201: PUSH
88202: LD_INT 2
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: LD_INT 2
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 0
88221: PUSH
88222: LD_INT 2
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: LD_INT 1
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 2
88242: NEG
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 2
88253: NEG
88254: PUSH
88255: LD_INT 1
88257: NEG
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 2
88265: NEG
88266: PUSH
88267: LD_INT 2
88269: NEG
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88296: LD_ADDR_VAR 0 57
88300: PUSH
88301: LD_INT 0
88303: PUSH
88304: LD_INT 0
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 0
88313: PUSH
88314: LD_INT 1
88316: NEG
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 1
88324: PUSH
88325: LD_INT 0
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: LD_INT 1
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: LD_INT 1
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 1
88354: NEG
88355: PUSH
88356: LD_INT 0
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 1
88365: NEG
88366: PUSH
88367: LD_INT 1
88369: NEG
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 1
88377: NEG
88378: PUSH
88379: LD_INT 2
88381: NEG
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 0
88389: PUSH
88390: LD_INT 2
88392: NEG
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 1
88400: PUSH
88401: LD_INT 1
88403: NEG
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 2
88411: PUSH
88412: LD_INT 0
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 2
88421: PUSH
88422: LD_INT 1
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: PUSH
88429: LD_INT 2
88431: PUSH
88432: LD_INT 2
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: PUSH
88439: LD_INT 1
88441: PUSH
88442: LD_INT 2
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: PUSH
88449: LD_INT 0
88451: PUSH
88452: LD_INT 2
88454: PUSH
88455: EMPTY
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 1
88461: NEG
88462: PUSH
88463: LD_INT 1
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 2
88472: NEG
88473: PUSH
88474: LD_INT 0
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 2
88483: NEG
88484: PUSH
88485: LD_INT 1
88487: NEG
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 2
88495: NEG
88496: PUSH
88497: LD_INT 2
88499: NEG
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88526: LD_ADDR_VAR 0 58
88530: PUSH
88531: LD_INT 0
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 0
88543: PUSH
88544: LD_INT 1
88546: NEG
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: PUSH
88552: LD_INT 1
88554: PUSH
88555: LD_INT 0
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 1
88564: PUSH
88565: LD_INT 1
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 0
88574: PUSH
88575: LD_INT 1
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: PUSH
88582: LD_INT 1
88584: NEG
88585: PUSH
88586: LD_INT 0
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 1
88595: NEG
88596: PUSH
88597: LD_INT 1
88599: NEG
88600: PUSH
88601: EMPTY
88602: LIST
88603: LIST
88604: PUSH
88605: LD_INT 1
88607: NEG
88608: PUSH
88609: LD_INT 2
88611: NEG
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: LD_INT 2
88622: NEG
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 1
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 2
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 2
88661: PUSH
88662: LD_INT 2
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: LD_INT 1
88671: PUSH
88672: LD_INT 2
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 0
88681: PUSH
88682: LD_INT 2
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 1
88691: NEG
88692: PUSH
88693: LD_INT 1
88695: PUSH
88696: EMPTY
88697: LIST
88698: LIST
88699: PUSH
88700: LD_INT 2
88702: NEG
88703: PUSH
88704: LD_INT 0
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 2
88713: NEG
88714: PUSH
88715: LD_INT 1
88717: NEG
88718: PUSH
88719: EMPTY
88720: LIST
88721: LIST
88722: PUSH
88723: LD_INT 2
88725: NEG
88726: PUSH
88727: LD_INT 2
88729: NEG
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88756: LD_ADDR_VAR 0 59
88760: PUSH
88761: LD_INT 0
88763: PUSH
88764: LD_INT 0
88766: PUSH
88767: EMPTY
88768: LIST
88769: LIST
88770: PUSH
88771: LD_INT 0
88773: PUSH
88774: LD_INT 1
88776: NEG
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 1
88784: PUSH
88785: LD_INT 0
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 1
88794: PUSH
88795: LD_INT 1
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 0
88804: PUSH
88805: LD_INT 1
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 1
88814: NEG
88815: PUSH
88816: LD_INT 0
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: PUSH
88823: LD_INT 1
88825: NEG
88826: PUSH
88827: LD_INT 1
88829: NEG
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88844: LD_ADDR_VAR 0 60
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: LD_INT 0
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 0
88861: PUSH
88862: LD_INT 1
88864: NEG
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 1
88872: PUSH
88873: LD_INT 0
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: PUSH
88883: LD_INT 1
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 0
88892: PUSH
88893: LD_INT 1
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: NEG
88903: PUSH
88904: LD_INT 0
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 1
88913: NEG
88914: PUSH
88915: LD_INT 1
88917: NEG
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88932: LD_ADDR_VAR 0 61
88936: PUSH
88937: LD_INT 0
88939: PUSH
88940: LD_INT 0
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 0
88949: PUSH
88950: LD_INT 1
88952: NEG
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 1
88960: PUSH
88961: LD_INT 0
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: PUSH
88968: LD_INT 1
88970: PUSH
88971: LD_INT 1
88973: PUSH
88974: EMPTY
88975: LIST
88976: LIST
88977: PUSH
88978: LD_INT 0
88980: PUSH
88981: LD_INT 1
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 1
88990: NEG
88991: PUSH
88992: LD_INT 0
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: NEG
89002: PUSH
89003: LD_INT 1
89005: NEG
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89020: LD_ADDR_VAR 0 62
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: LD_INT 0
89030: PUSH
89031: EMPTY
89032: LIST
89033: LIST
89034: PUSH
89035: LD_INT 0
89037: PUSH
89038: LD_INT 1
89040: NEG
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: PUSH
89046: LD_INT 1
89048: PUSH
89049: LD_INT 0
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 1
89058: PUSH
89059: LD_INT 1
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: PUSH
89066: LD_INT 0
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: LD_INT 1
89078: NEG
89079: PUSH
89080: LD_INT 0
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 1
89089: NEG
89090: PUSH
89091: LD_INT 1
89093: NEG
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: EMPTY
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89108: LD_ADDR_VAR 0 63
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: LD_INT 0
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 0
89125: PUSH
89126: LD_INT 1
89128: NEG
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 1
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 1
89146: PUSH
89147: LD_INT 1
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: LD_INT 1
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: LD_INT 0
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 1
89177: NEG
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: EMPTY
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89196: LD_ADDR_VAR 0 64
89200: PUSH
89201: LD_INT 0
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 0
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: PUSH
89225: LD_INT 0
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: LD_INT 1
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: LD_INT 0
89244: PUSH
89245: LD_INT 1
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 1
89254: NEG
89255: PUSH
89256: LD_INT 0
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 1
89265: NEG
89266: PUSH
89267: LD_INT 1
89269: NEG
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: ST_TO_ADDR
// end ; 1 :
89284: GO 95181
89286: LD_INT 1
89288: DOUBLE
89289: EQUAL
89290: IFTRUE 89294
89292: GO 91917
89294: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89295: LD_ADDR_VAR 0 11
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: LD_INT 3
89306: NEG
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: PUSH
89312: LD_INT 0
89314: PUSH
89315: LD_INT 3
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: LD_INT 2
89328: NEG
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: LIST
89338: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89339: LD_ADDR_VAR 0 12
89343: PUSH
89344: LD_INT 2
89346: PUSH
89347: LD_INT 1
89349: NEG
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: LD_INT 3
89357: PUSH
89358: LD_INT 0
89360: PUSH
89361: EMPTY
89362: LIST
89363: LIST
89364: PUSH
89365: LD_INT 3
89367: PUSH
89368: LD_INT 1
89370: PUSH
89371: EMPTY
89372: LIST
89373: LIST
89374: PUSH
89375: EMPTY
89376: LIST
89377: LIST
89378: LIST
89379: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89380: LD_ADDR_VAR 0 13
89384: PUSH
89385: LD_INT 3
89387: PUSH
89388: LD_INT 2
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: PUSH
89395: LD_INT 3
89397: PUSH
89398: LD_INT 3
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 2
89407: PUSH
89408: LD_INT 3
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: LIST
89419: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89420: LD_ADDR_VAR 0 14
89424: PUSH
89425: LD_INT 1
89427: PUSH
89428: LD_INT 3
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 0
89437: PUSH
89438: LD_INT 3
89440: PUSH
89441: EMPTY
89442: LIST
89443: LIST
89444: PUSH
89445: LD_INT 1
89447: NEG
89448: PUSH
89449: LD_INT 2
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: LIST
89460: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89461: LD_ADDR_VAR 0 15
89465: PUSH
89466: LD_INT 2
89468: NEG
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 3
89479: NEG
89480: PUSH
89481: LD_INT 0
89483: PUSH
89484: EMPTY
89485: LIST
89486: LIST
89487: PUSH
89488: LD_INT 3
89490: NEG
89491: PUSH
89492: LD_INT 1
89494: NEG
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: LIST
89504: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89505: LD_ADDR_VAR 0 16
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: LD_INT 3
89516: NEG
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 3
89524: NEG
89525: PUSH
89526: LD_INT 2
89528: NEG
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: PUSH
89534: LD_INT 3
89536: NEG
89537: PUSH
89538: LD_INT 3
89540: NEG
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: LIST
89550: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89551: LD_ADDR_VAR 0 17
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: LD_INT 3
89562: NEG
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: LD_INT 3
89573: NEG
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 1
89581: PUSH
89582: LD_INT 2
89584: NEG
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: LIST
89594: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89595: LD_ADDR_VAR 0 18
89599: PUSH
89600: LD_INT 2
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 3
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 3
89623: PUSH
89624: LD_INT 1
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: LIST
89635: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89636: LD_ADDR_VAR 0 19
89640: PUSH
89641: LD_INT 3
89643: PUSH
89644: LD_INT 2
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 3
89653: PUSH
89654: LD_INT 3
89656: PUSH
89657: EMPTY
89658: LIST
89659: LIST
89660: PUSH
89661: LD_INT 2
89663: PUSH
89664: LD_INT 3
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: LIST
89675: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89676: LD_ADDR_VAR 0 20
89680: PUSH
89681: LD_INT 1
89683: PUSH
89684: LD_INT 3
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 0
89693: PUSH
89694: LD_INT 3
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: PUSH
89701: LD_INT 1
89703: NEG
89704: PUSH
89705: LD_INT 2
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: LIST
89716: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89717: LD_ADDR_VAR 0 21
89721: PUSH
89722: LD_INT 2
89724: NEG
89725: PUSH
89726: LD_INT 1
89728: PUSH
89729: EMPTY
89730: LIST
89731: LIST
89732: PUSH
89733: LD_INT 3
89735: NEG
89736: PUSH
89737: LD_INT 0
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 3
89746: NEG
89747: PUSH
89748: LD_INT 1
89750: NEG
89751: PUSH
89752: EMPTY
89753: LIST
89754: LIST
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: LIST
89760: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89761: LD_ADDR_VAR 0 22
89765: PUSH
89766: LD_INT 2
89768: NEG
89769: PUSH
89770: LD_INT 3
89772: NEG
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 3
89780: NEG
89781: PUSH
89782: LD_INT 2
89784: NEG
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 3
89792: NEG
89793: PUSH
89794: LD_INT 3
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: EMPTY
89803: LIST
89804: LIST
89805: LIST
89806: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89807: LD_ADDR_VAR 0 23
89811: PUSH
89812: LD_INT 0
89814: PUSH
89815: LD_INT 3
89817: NEG
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 1
89825: NEG
89826: PUSH
89827: LD_INT 4
89829: NEG
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: LD_INT 3
89840: NEG
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: EMPTY
89847: LIST
89848: LIST
89849: LIST
89850: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89851: LD_ADDR_VAR 0 24
89855: PUSH
89856: LD_INT 3
89858: PUSH
89859: LD_INT 0
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: LD_INT 3
89868: PUSH
89869: LD_INT 1
89871: NEG
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 4
89879: PUSH
89880: LD_INT 1
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: LIST
89891: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89892: LD_ADDR_VAR 0 25
89896: PUSH
89897: LD_INT 3
89899: PUSH
89900: LD_INT 3
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 4
89909: PUSH
89910: LD_INT 3
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 3
89919: PUSH
89920: LD_INT 4
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: EMPTY
89928: LIST
89929: LIST
89930: LIST
89931: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89932: LD_ADDR_VAR 0 26
89936: PUSH
89937: LD_INT 0
89939: PUSH
89940: LD_INT 3
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: LD_INT 4
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PUSH
89957: LD_INT 1
89959: NEG
89960: PUSH
89961: LD_INT 3
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: LIST
89972: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89973: LD_ADDR_VAR 0 27
89977: PUSH
89978: LD_INT 3
89980: NEG
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 3
89991: NEG
89992: PUSH
89993: LD_INT 1
89995: PUSH
89996: EMPTY
89997: LIST
89998: LIST
89999: PUSH
90000: LD_INT 4
90002: NEG
90003: PUSH
90004: LD_INT 1
90006: NEG
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: LIST
90016: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90017: LD_ADDR_VAR 0 28
90021: PUSH
90022: LD_INT 3
90024: NEG
90025: PUSH
90026: LD_INT 3
90028: NEG
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 3
90036: NEG
90037: PUSH
90038: LD_INT 4
90040: NEG
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 4
90048: NEG
90049: PUSH
90050: LD_INT 3
90052: NEG
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: LIST
90062: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90063: LD_ADDR_VAR 0 29
90067: PUSH
90068: LD_INT 1
90070: NEG
90071: PUSH
90072: LD_INT 3
90074: NEG
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: LD_INT 0
90082: PUSH
90083: LD_INT 3
90085: NEG
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 1
90093: PUSH
90094: LD_INT 2
90096: NEG
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 1
90104: NEG
90105: PUSH
90106: LD_INT 4
90108: NEG
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 0
90116: PUSH
90117: LD_INT 4
90119: NEG
90120: PUSH
90121: EMPTY
90122: LIST
90123: LIST
90124: PUSH
90125: LD_INT 1
90127: PUSH
90128: LD_INT 3
90130: NEG
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: LD_INT 5
90142: NEG
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: PUSH
90148: LD_INT 0
90150: PUSH
90151: LD_INT 5
90153: NEG
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 1
90161: PUSH
90162: LD_INT 4
90164: NEG
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 1
90172: NEG
90173: PUSH
90174: LD_INT 6
90176: NEG
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PUSH
90182: LD_INT 0
90184: PUSH
90185: LD_INT 6
90187: NEG
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: LD_INT 1
90195: PUSH
90196: LD_INT 5
90198: NEG
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: EMPTY
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90218: LD_ADDR_VAR 0 30
90222: PUSH
90223: LD_INT 2
90225: PUSH
90226: LD_INT 1
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 3
90236: PUSH
90237: LD_INT 0
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 3
90246: PUSH
90247: LD_INT 1
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 3
90256: PUSH
90257: LD_INT 1
90259: NEG
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 4
90267: PUSH
90268: LD_INT 0
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: LD_INT 4
90277: PUSH
90278: LD_INT 1
90280: PUSH
90281: EMPTY
90282: LIST
90283: LIST
90284: PUSH
90285: LD_INT 4
90287: PUSH
90288: LD_INT 1
90290: NEG
90291: PUSH
90292: EMPTY
90293: LIST
90294: LIST
90295: PUSH
90296: LD_INT 5
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 5
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 5
90318: PUSH
90319: LD_INT 1
90321: NEG
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: LD_INT 6
90329: PUSH
90330: LD_INT 0
90332: PUSH
90333: EMPTY
90334: LIST
90335: LIST
90336: PUSH
90337: LD_INT 6
90339: PUSH
90340: LD_INT 1
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: LIST
90360: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90361: LD_ADDR_VAR 0 31
90365: PUSH
90366: LD_INT 3
90368: PUSH
90369: LD_INT 2
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 3
90378: PUSH
90379: LD_INT 3
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 2
90388: PUSH
90389: LD_INT 3
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 4
90398: PUSH
90399: LD_INT 3
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 4
90408: PUSH
90409: LD_INT 4
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 3
90418: PUSH
90419: LD_INT 4
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 5
90428: PUSH
90429: LD_INT 4
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: PUSH
90436: LD_INT 5
90438: PUSH
90439: LD_INT 5
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PUSH
90446: LD_INT 4
90448: PUSH
90449: LD_INT 5
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: PUSH
90456: LD_INT 6
90458: PUSH
90459: LD_INT 5
90461: PUSH
90462: EMPTY
90463: LIST
90464: LIST
90465: PUSH
90466: LD_INT 6
90468: PUSH
90469: LD_INT 6
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 5
90478: PUSH
90479: LD_INT 6
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90500: LD_ADDR_VAR 0 32
90504: PUSH
90505: LD_INT 1
90507: PUSH
90508: LD_INT 3
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: LD_INT 3
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 1
90527: NEG
90528: PUSH
90529: LD_INT 2
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 1
90538: PUSH
90539: LD_INT 4
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: LD_INT 4
90551: PUSH
90552: EMPTY
90553: LIST
90554: LIST
90555: PUSH
90556: LD_INT 1
90558: NEG
90559: PUSH
90560: LD_INT 3
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 1
90569: PUSH
90570: LD_INT 5
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 0
90579: PUSH
90580: LD_INT 5
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: LD_INT 1
90589: NEG
90590: PUSH
90591: LD_INT 4
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: PUSH
90598: LD_INT 1
90600: PUSH
90601: LD_INT 6
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 0
90610: PUSH
90611: LD_INT 6
90613: PUSH
90614: EMPTY
90615: LIST
90616: LIST
90617: PUSH
90618: LD_INT 1
90620: NEG
90621: PUSH
90622: LD_INT 5
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: EMPTY
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90643: LD_ADDR_VAR 0 33
90647: PUSH
90648: LD_INT 2
90650: NEG
90651: PUSH
90652: LD_INT 1
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 3
90661: NEG
90662: PUSH
90663: LD_INT 0
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PUSH
90670: LD_INT 3
90672: NEG
90673: PUSH
90674: LD_INT 1
90676: NEG
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 3
90684: NEG
90685: PUSH
90686: LD_INT 1
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 4
90695: NEG
90696: PUSH
90697: LD_INT 0
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 4
90706: NEG
90707: PUSH
90708: LD_INT 1
90710: NEG
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 4
90718: NEG
90719: PUSH
90720: LD_INT 1
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 5
90729: NEG
90730: PUSH
90731: LD_INT 0
90733: PUSH
90734: EMPTY
90735: LIST
90736: LIST
90737: PUSH
90738: LD_INT 5
90740: NEG
90741: PUSH
90742: LD_INT 1
90744: NEG
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 5
90752: NEG
90753: PUSH
90754: LD_INT 1
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PUSH
90761: LD_INT 6
90763: NEG
90764: PUSH
90765: LD_INT 0
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 6
90774: NEG
90775: PUSH
90776: LD_INT 1
90778: NEG
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: EMPTY
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90798: LD_ADDR_VAR 0 34
90802: PUSH
90803: LD_INT 2
90805: NEG
90806: PUSH
90807: LD_INT 3
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 3
90817: NEG
90818: PUSH
90819: LD_INT 2
90821: NEG
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: LD_INT 3
90829: NEG
90830: PUSH
90831: LD_INT 3
90833: NEG
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: LD_INT 3
90841: NEG
90842: PUSH
90843: LD_INT 4
90845: NEG
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 4
90853: NEG
90854: PUSH
90855: LD_INT 3
90857: NEG
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 4
90865: NEG
90866: PUSH
90867: LD_INT 4
90869: NEG
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: LD_INT 4
90877: NEG
90878: PUSH
90879: LD_INT 5
90881: NEG
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: PUSH
90887: LD_INT 5
90889: NEG
90890: PUSH
90891: LD_INT 4
90893: NEG
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 5
90901: NEG
90902: PUSH
90903: LD_INT 5
90905: NEG
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 5
90913: NEG
90914: PUSH
90915: LD_INT 6
90917: NEG
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 6
90925: NEG
90926: PUSH
90927: LD_INT 5
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 6
90937: NEG
90938: PUSH
90939: LD_INT 6
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: EMPTY
90948: LIST
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90961: LD_ADDR_VAR 0 41
90965: PUSH
90966: LD_INT 0
90968: PUSH
90969: LD_INT 2
90971: NEG
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 1
90979: NEG
90980: PUSH
90981: LD_INT 3
90983: NEG
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 1
90991: PUSH
90992: LD_INT 2
90994: NEG
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: PUSH
91000: EMPTY
91001: LIST
91002: LIST
91003: LIST
91004: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91005: LD_ADDR_VAR 0 42
91009: PUSH
91010: LD_INT 2
91012: PUSH
91013: LD_INT 0
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: LD_INT 2
91022: PUSH
91023: LD_INT 1
91025: NEG
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PUSH
91031: LD_INT 3
91033: PUSH
91034: LD_INT 1
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: LIST
91045: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91046: LD_ADDR_VAR 0 43
91050: PUSH
91051: LD_INT 2
91053: PUSH
91054: LD_INT 2
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: PUSH
91061: LD_INT 3
91063: PUSH
91064: LD_INT 2
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: LD_INT 2
91073: PUSH
91074: LD_INT 3
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: LIST
91085: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91086: LD_ADDR_VAR 0 44
91090: PUSH
91091: LD_INT 0
91093: PUSH
91094: LD_INT 2
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 1
91103: PUSH
91104: LD_INT 3
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 1
91113: NEG
91114: PUSH
91115: LD_INT 2
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: LIST
91126: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91127: LD_ADDR_VAR 0 45
91131: PUSH
91132: LD_INT 2
91134: NEG
91135: PUSH
91136: LD_INT 0
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 2
91145: NEG
91146: PUSH
91147: LD_INT 1
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: LD_INT 3
91156: NEG
91157: PUSH
91158: LD_INT 1
91160: NEG
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: LIST
91170: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91171: LD_ADDR_VAR 0 46
91175: PUSH
91176: LD_INT 2
91178: NEG
91179: PUSH
91180: LD_INT 2
91182: NEG
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: LD_INT 2
91190: NEG
91191: PUSH
91192: LD_INT 3
91194: NEG
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 3
91202: NEG
91203: PUSH
91204: LD_INT 2
91206: NEG
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: LIST
91216: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91217: LD_ADDR_VAR 0 47
91221: PUSH
91222: LD_INT 2
91224: NEG
91225: PUSH
91226: LD_INT 3
91228: NEG
91229: PUSH
91230: EMPTY
91231: LIST
91232: LIST
91233: PUSH
91234: LD_INT 1
91236: NEG
91237: PUSH
91238: LD_INT 3
91240: NEG
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91250: LD_ADDR_VAR 0 48
91254: PUSH
91255: LD_INT 1
91257: PUSH
91258: LD_INT 2
91260: NEG
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: PUSH
91266: LD_INT 2
91268: PUSH
91269: LD_INT 1
91271: NEG
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91281: LD_ADDR_VAR 0 49
91285: PUSH
91286: LD_INT 3
91288: PUSH
91289: LD_INT 1
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 3
91298: PUSH
91299: LD_INT 2
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: EMPTY
91307: LIST
91308: LIST
91309: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91310: LD_ADDR_VAR 0 50
91314: PUSH
91315: LD_INT 2
91317: PUSH
91318: LD_INT 3
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 1
91327: PUSH
91328: LD_INT 3
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91339: LD_ADDR_VAR 0 51
91343: PUSH
91344: LD_INT 1
91346: NEG
91347: PUSH
91348: LD_INT 2
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 2
91357: NEG
91358: PUSH
91359: LD_INT 1
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91370: LD_ADDR_VAR 0 52
91374: PUSH
91375: LD_INT 3
91377: NEG
91378: PUSH
91379: LD_INT 1
91381: NEG
91382: PUSH
91383: EMPTY
91384: LIST
91385: LIST
91386: PUSH
91387: LD_INT 3
91389: NEG
91390: PUSH
91391: LD_INT 2
91393: NEG
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91403: LD_ADDR_VAR 0 53
91407: PUSH
91408: LD_INT 1
91410: NEG
91411: PUSH
91412: LD_INT 3
91414: NEG
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: PUSH
91420: LD_INT 0
91422: PUSH
91423: LD_INT 3
91425: NEG
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: PUSH
91431: LD_INT 1
91433: PUSH
91434: LD_INT 2
91436: NEG
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: LIST
91446: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91447: LD_ADDR_VAR 0 54
91451: PUSH
91452: LD_INT 2
91454: PUSH
91455: LD_INT 1
91457: NEG
91458: PUSH
91459: EMPTY
91460: LIST
91461: LIST
91462: PUSH
91463: LD_INT 3
91465: PUSH
91466: LD_INT 0
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: PUSH
91473: LD_INT 3
91475: PUSH
91476: LD_INT 1
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: LIST
91487: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91488: LD_ADDR_VAR 0 55
91492: PUSH
91493: LD_INT 3
91495: PUSH
91496: LD_INT 2
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 3
91505: PUSH
91506: LD_INT 3
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 2
91515: PUSH
91516: LD_INT 3
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: LIST
91527: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91528: LD_ADDR_VAR 0 56
91532: PUSH
91533: LD_INT 1
91535: PUSH
91536: LD_INT 3
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 0
91545: PUSH
91546: LD_INT 3
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 1
91555: NEG
91556: PUSH
91557: LD_INT 2
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: EMPTY
91565: LIST
91566: LIST
91567: LIST
91568: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91569: LD_ADDR_VAR 0 57
91573: PUSH
91574: LD_INT 2
91576: NEG
91577: PUSH
91578: LD_INT 1
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 3
91587: NEG
91588: PUSH
91589: LD_INT 0
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: PUSH
91596: LD_INT 3
91598: NEG
91599: PUSH
91600: LD_INT 1
91602: NEG
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: LIST
91612: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91613: LD_ADDR_VAR 0 58
91617: PUSH
91618: LD_INT 2
91620: NEG
91621: PUSH
91622: LD_INT 3
91624: NEG
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 3
91632: NEG
91633: PUSH
91634: LD_INT 2
91636: NEG
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 3
91644: NEG
91645: PUSH
91646: LD_INT 3
91648: NEG
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: EMPTY
91655: LIST
91656: LIST
91657: LIST
91658: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91659: LD_ADDR_VAR 0 59
91663: PUSH
91664: LD_INT 1
91666: NEG
91667: PUSH
91668: LD_INT 2
91670: NEG
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 0
91678: PUSH
91679: LD_INT 2
91681: NEG
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 1
91689: PUSH
91690: LD_INT 1
91692: NEG
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: LIST
91702: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91703: LD_ADDR_VAR 0 60
91707: PUSH
91708: LD_INT 1
91710: PUSH
91711: LD_INT 1
91713: NEG
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: PUSH
91719: LD_INT 2
91721: PUSH
91722: LD_INT 0
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 2
91731: PUSH
91732: LD_INT 1
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: LIST
91743: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91744: LD_ADDR_VAR 0 61
91748: PUSH
91749: LD_INT 2
91751: PUSH
91752: LD_INT 1
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: PUSH
91759: LD_INT 2
91761: PUSH
91762: LD_INT 2
91764: PUSH
91765: EMPTY
91766: LIST
91767: LIST
91768: PUSH
91769: LD_INT 1
91771: PUSH
91772: LD_INT 2
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: LIST
91783: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91784: LD_ADDR_VAR 0 62
91788: PUSH
91789: LD_INT 1
91791: PUSH
91792: LD_INT 2
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 0
91801: PUSH
91802: LD_INT 2
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 1
91811: NEG
91812: PUSH
91813: LD_INT 1
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: LIST
91824: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91825: LD_ADDR_VAR 0 63
91829: PUSH
91830: LD_INT 1
91832: NEG
91833: PUSH
91834: LD_INT 1
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PUSH
91841: LD_INT 2
91843: NEG
91844: PUSH
91845: LD_INT 0
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 2
91854: NEG
91855: PUSH
91856: LD_INT 1
91858: NEG
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: LIST
91868: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91869: LD_ADDR_VAR 0 64
91873: PUSH
91874: LD_INT 1
91876: NEG
91877: PUSH
91878: LD_INT 2
91880: NEG
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 2
91888: NEG
91889: PUSH
91890: LD_INT 1
91892: NEG
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 2
91900: NEG
91901: PUSH
91902: LD_INT 2
91904: NEG
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: EMPTY
91911: LIST
91912: LIST
91913: LIST
91914: ST_TO_ADDR
// end ; 2 :
91915: GO 95181
91917: LD_INT 2
91919: DOUBLE
91920: EQUAL
91921: IFTRUE 91925
91923: GO 95180
91925: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91926: LD_ADDR_VAR 0 29
91930: PUSH
91931: LD_INT 4
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 4
91943: PUSH
91944: LD_INT 1
91946: NEG
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 5
91954: PUSH
91955: LD_INT 0
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 5
91964: PUSH
91965: LD_INT 1
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 4
91974: PUSH
91975: LD_INT 1
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 3
91984: PUSH
91985: LD_INT 0
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 3
91994: PUSH
91995: LD_INT 1
91997: NEG
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: PUSH
92003: LD_INT 3
92005: PUSH
92006: LD_INT 2
92008: NEG
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 5
92016: PUSH
92017: LD_INT 2
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: LD_INT 3
92026: PUSH
92027: LD_INT 3
92029: PUSH
92030: EMPTY
92031: LIST
92032: LIST
92033: PUSH
92034: LD_INT 3
92036: PUSH
92037: LD_INT 2
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 4
92046: PUSH
92047: LD_INT 3
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: LD_INT 4
92056: PUSH
92057: LD_INT 4
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 3
92066: PUSH
92067: LD_INT 4
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 2
92076: PUSH
92077: LD_INT 3
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: LD_INT 2
92086: PUSH
92087: LD_INT 2
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 4
92096: PUSH
92097: LD_INT 2
92099: PUSH
92100: EMPTY
92101: LIST
92102: LIST
92103: PUSH
92104: LD_INT 2
92106: PUSH
92107: LD_INT 4
92109: PUSH
92110: EMPTY
92111: LIST
92112: LIST
92113: PUSH
92114: LD_INT 0
92116: PUSH
92117: LD_INT 4
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: PUSH
92124: LD_INT 0
92126: PUSH
92127: LD_INT 3
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 1
92136: PUSH
92137: LD_INT 4
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 1
92146: PUSH
92147: LD_INT 5
92149: PUSH
92150: EMPTY
92151: LIST
92152: LIST
92153: PUSH
92154: LD_INT 0
92156: PUSH
92157: LD_INT 5
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 1
92166: NEG
92167: PUSH
92168: LD_INT 4
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 1
92177: NEG
92178: PUSH
92179: LD_INT 3
92181: PUSH
92182: EMPTY
92183: LIST
92184: LIST
92185: PUSH
92186: LD_INT 2
92188: PUSH
92189: LD_INT 5
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 2
92198: NEG
92199: PUSH
92200: LD_INT 3
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 3
92209: NEG
92210: PUSH
92211: LD_INT 0
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: PUSH
92218: LD_INT 3
92220: NEG
92221: PUSH
92222: LD_INT 1
92224: NEG
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 2
92232: NEG
92233: PUSH
92234: LD_INT 0
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: LD_INT 2
92243: NEG
92244: PUSH
92245: LD_INT 1
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: LD_INT 3
92254: NEG
92255: PUSH
92256: LD_INT 1
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: PUSH
92263: LD_INT 4
92265: NEG
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 4
92276: NEG
92277: PUSH
92278: LD_INT 1
92280: NEG
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 4
92288: NEG
92289: PUSH
92290: LD_INT 2
92292: NEG
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: LD_INT 2
92300: NEG
92301: PUSH
92302: LD_INT 2
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 4
92311: NEG
92312: PUSH
92313: LD_INT 4
92315: NEG
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: LD_INT 4
92323: NEG
92324: PUSH
92325: LD_INT 5
92327: NEG
92328: PUSH
92329: EMPTY
92330: LIST
92331: LIST
92332: PUSH
92333: LD_INT 3
92335: NEG
92336: PUSH
92337: LD_INT 4
92339: NEG
92340: PUSH
92341: EMPTY
92342: LIST
92343: LIST
92344: PUSH
92345: LD_INT 3
92347: NEG
92348: PUSH
92349: LD_INT 3
92351: NEG
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 4
92359: NEG
92360: PUSH
92361: LD_INT 3
92363: NEG
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: LD_INT 5
92371: NEG
92372: PUSH
92373: LD_INT 4
92375: NEG
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: PUSH
92381: LD_INT 5
92383: NEG
92384: PUSH
92385: LD_INT 5
92387: NEG
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 3
92395: NEG
92396: PUSH
92397: LD_INT 5
92399: NEG
92400: PUSH
92401: EMPTY
92402: LIST
92403: LIST
92404: PUSH
92405: LD_INT 5
92407: NEG
92408: PUSH
92409: LD_INT 3
92411: NEG
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92464: LD_ADDR_VAR 0 30
92468: PUSH
92469: LD_INT 4
92471: PUSH
92472: LD_INT 4
92474: PUSH
92475: EMPTY
92476: LIST
92477: LIST
92478: PUSH
92479: LD_INT 4
92481: PUSH
92482: LD_INT 3
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 5
92491: PUSH
92492: LD_INT 4
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: LD_INT 5
92501: PUSH
92502: LD_INT 5
92504: PUSH
92505: EMPTY
92506: LIST
92507: LIST
92508: PUSH
92509: LD_INT 4
92511: PUSH
92512: LD_INT 5
92514: PUSH
92515: EMPTY
92516: LIST
92517: LIST
92518: PUSH
92519: LD_INT 3
92521: PUSH
92522: LD_INT 4
92524: PUSH
92525: EMPTY
92526: LIST
92527: LIST
92528: PUSH
92529: LD_INT 3
92531: PUSH
92532: LD_INT 3
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 5
92541: PUSH
92542: LD_INT 3
92544: PUSH
92545: EMPTY
92546: LIST
92547: LIST
92548: PUSH
92549: LD_INT 3
92551: PUSH
92552: LD_INT 5
92554: PUSH
92555: EMPTY
92556: LIST
92557: LIST
92558: PUSH
92559: LD_INT 0
92561: PUSH
92562: LD_INT 3
92564: PUSH
92565: EMPTY
92566: LIST
92567: LIST
92568: PUSH
92569: LD_INT 0
92571: PUSH
92572: LD_INT 2
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: PUSH
92579: LD_INT 1
92581: PUSH
92582: LD_INT 3
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PUSH
92589: LD_INT 1
92591: PUSH
92592: LD_INT 4
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: LD_INT 0
92601: PUSH
92602: LD_INT 4
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 1
92611: NEG
92612: PUSH
92613: LD_INT 3
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: LD_INT 1
92622: NEG
92623: PUSH
92624: LD_INT 2
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: LD_INT 2
92633: PUSH
92634: LD_INT 4
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 2
92643: NEG
92644: PUSH
92645: LD_INT 2
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 4
92654: NEG
92655: PUSH
92656: LD_INT 0
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 4
92665: NEG
92666: PUSH
92667: LD_INT 1
92669: NEG
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 3
92677: NEG
92678: PUSH
92679: LD_INT 0
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 3
92688: NEG
92689: PUSH
92690: LD_INT 1
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 4
92699: NEG
92700: PUSH
92701: LD_INT 1
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 5
92710: NEG
92711: PUSH
92712: LD_INT 0
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PUSH
92719: LD_INT 5
92721: NEG
92722: PUSH
92723: LD_INT 1
92725: NEG
92726: PUSH
92727: EMPTY
92728: LIST
92729: LIST
92730: PUSH
92731: LD_INT 5
92733: NEG
92734: PUSH
92735: LD_INT 2
92737: NEG
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 3
92745: NEG
92746: PUSH
92747: LD_INT 2
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 3
92756: NEG
92757: PUSH
92758: LD_INT 3
92760: NEG
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: LD_INT 3
92768: NEG
92769: PUSH
92770: LD_INT 4
92772: NEG
92773: PUSH
92774: EMPTY
92775: LIST
92776: LIST
92777: PUSH
92778: LD_INT 2
92780: NEG
92781: PUSH
92782: LD_INT 3
92784: NEG
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: PUSH
92790: LD_INT 2
92792: NEG
92793: PUSH
92794: LD_INT 2
92796: NEG
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 3
92804: NEG
92805: PUSH
92806: LD_INT 2
92808: NEG
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 4
92816: NEG
92817: PUSH
92818: LD_INT 3
92820: NEG
92821: PUSH
92822: EMPTY
92823: LIST
92824: LIST
92825: PUSH
92826: LD_INT 4
92828: NEG
92829: PUSH
92830: LD_INT 4
92832: NEG
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 2
92840: NEG
92841: PUSH
92842: LD_INT 4
92844: NEG
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: PUSH
92850: LD_INT 4
92852: NEG
92853: PUSH
92854: LD_INT 2
92856: NEG
92857: PUSH
92858: EMPTY
92859: LIST
92860: LIST
92861: PUSH
92862: LD_INT 0
92864: PUSH
92865: LD_INT 4
92867: NEG
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: PUSH
92873: LD_INT 0
92875: PUSH
92876: LD_INT 5
92878: NEG
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 1
92886: PUSH
92887: LD_INT 4
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 1
92897: PUSH
92898: LD_INT 3
92900: NEG
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 0
92908: PUSH
92909: LD_INT 3
92911: NEG
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 1
92919: NEG
92920: PUSH
92921: LD_INT 4
92923: NEG
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 1
92931: NEG
92932: PUSH
92933: LD_INT 5
92935: NEG
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 2
92943: PUSH
92944: LD_INT 3
92946: NEG
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: PUSH
92952: LD_INT 2
92954: NEG
92955: PUSH
92956: LD_INT 5
92958: NEG
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93011: LD_ADDR_VAR 0 31
93015: PUSH
93016: LD_INT 0
93018: PUSH
93019: LD_INT 4
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: PUSH
93026: LD_INT 0
93028: PUSH
93029: LD_INT 3
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: PUSH
93036: LD_INT 1
93038: PUSH
93039: LD_INT 4
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 1
93048: PUSH
93049: LD_INT 5
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 0
93058: PUSH
93059: LD_INT 5
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 1
93068: NEG
93069: PUSH
93070: LD_INT 4
93072: PUSH
93073: EMPTY
93074: LIST
93075: LIST
93076: PUSH
93077: LD_INT 1
93079: NEG
93080: PUSH
93081: LD_INT 3
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: PUSH
93088: LD_INT 2
93090: PUSH
93091: LD_INT 5
93093: PUSH
93094: EMPTY
93095: LIST
93096: LIST
93097: PUSH
93098: LD_INT 2
93100: NEG
93101: PUSH
93102: LD_INT 3
93104: PUSH
93105: EMPTY
93106: LIST
93107: LIST
93108: PUSH
93109: LD_INT 3
93111: NEG
93112: PUSH
93113: LD_INT 0
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: PUSH
93120: LD_INT 3
93122: NEG
93123: PUSH
93124: LD_INT 1
93126: NEG
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: PUSH
93132: LD_INT 2
93134: NEG
93135: PUSH
93136: LD_INT 0
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: PUSH
93143: LD_INT 2
93145: NEG
93146: PUSH
93147: LD_INT 1
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 3
93156: NEG
93157: PUSH
93158: LD_INT 1
93160: PUSH
93161: EMPTY
93162: LIST
93163: LIST
93164: PUSH
93165: LD_INT 4
93167: NEG
93168: PUSH
93169: LD_INT 0
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 4
93178: NEG
93179: PUSH
93180: LD_INT 1
93182: NEG
93183: PUSH
93184: EMPTY
93185: LIST
93186: LIST
93187: PUSH
93188: LD_INT 4
93190: NEG
93191: PUSH
93192: LD_INT 2
93194: NEG
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: LD_INT 2
93202: NEG
93203: PUSH
93204: LD_INT 2
93206: PUSH
93207: EMPTY
93208: LIST
93209: LIST
93210: PUSH
93211: LD_INT 4
93213: NEG
93214: PUSH
93215: LD_INT 4
93217: NEG
93218: PUSH
93219: EMPTY
93220: LIST
93221: LIST
93222: PUSH
93223: LD_INT 4
93225: NEG
93226: PUSH
93227: LD_INT 5
93229: NEG
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: PUSH
93235: LD_INT 3
93237: NEG
93238: PUSH
93239: LD_INT 4
93241: NEG
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 3
93249: NEG
93250: PUSH
93251: LD_INT 3
93253: NEG
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 4
93261: NEG
93262: PUSH
93263: LD_INT 3
93265: NEG
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: PUSH
93271: LD_INT 5
93273: NEG
93274: PUSH
93275: LD_INT 4
93277: NEG
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 5
93285: NEG
93286: PUSH
93287: LD_INT 5
93289: NEG
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 3
93297: NEG
93298: PUSH
93299: LD_INT 5
93301: NEG
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: LD_INT 5
93309: NEG
93310: PUSH
93311: LD_INT 3
93313: NEG
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 0
93321: PUSH
93322: LD_INT 3
93324: NEG
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 0
93332: PUSH
93333: LD_INT 4
93335: NEG
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: PUSH
93341: LD_INT 1
93343: PUSH
93344: LD_INT 3
93346: NEG
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 1
93354: PUSH
93355: LD_INT 2
93357: NEG
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 0
93365: PUSH
93366: LD_INT 2
93368: NEG
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 1
93376: NEG
93377: PUSH
93378: LD_INT 3
93380: NEG
93381: PUSH
93382: EMPTY
93383: LIST
93384: LIST
93385: PUSH
93386: LD_INT 1
93388: NEG
93389: PUSH
93390: LD_INT 4
93392: NEG
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 2
93400: PUSH
93401: LD_INT 2
93403: NEG
93404: PUSH
93405: EMPTY
93406: LIST
93407: LIST
93408: PUSH
93409: LD_INT 2
93411: NEG
93412: PUSH
93413: LD_INT 4
93415: NEG
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 4
93423: PUSH
93424: LD_INT 0
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 4
93433: PUSH
93434: LD_INT 1
93436: NEG
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 5
93444: PUSH
93445: LD_INT 0
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: LD_INT 5
93454: PUSH
93455: LD_INT 1
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 4
93464: PUSH
93465: LD_INT 1
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: LD_INT 3
93474: PUSH
93475: LD_INT 0
93477: PUSH
93478: EMPTY
93479: LIST
93480: LIST
93481: PUSH
93482: LD_INT 3
93484: PUSH
93485: LD_INT 1
93487: NEG
93488: PUSH
93489: EMPTY
93490: LIST
93491: LIST
93492: PUSH
93493: LD_INT 3
93495: PUSH
93496: LD_INT 2
93498: NEG
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: LD_INT 5
93506: PUSH
93507: LD_INT 2
93509: PUSH
93510: EMPTY
93511: LIST
93512: LIST
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: LIST
93534: LIST
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93561: LD_ADDR_VAR 0 32
93565: PUSH
93566: LD_INT 4
93568: NEG
93569: PUSH
93570: LD_INT 0
93572: PUSH
93573: EMPTY
93574: LIST
93575: LIST
93576: PUSH
93577: LD_INT 4
93579: NEG
93580: PUSH
93581: LD_INT 1
93583: NEG
93584: PUSH
93585: EMPTY
93586: LIST
93587: LIST
93588: PUSH
93589: LD_INT 3
93591: NEG
93592: PUSH
93593: LD_INT 0
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: PUSH
93600: LD_INT 3
93602: NEG
93603: PUSH
93604: LD_INT 1
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 4
93613: NEG
93614: PUSH
93615: LD_INT 1
93617: PUSH
93618: EMPTY
93619: LIST
93620: LIST
93621: PUSH
93622: LD_INT 5
93624: NEG
93625: PUSH
93626: LD_INT 0
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PUSH
93633: LD_INT 5
93635: NEG
93636: PUSH
93637: LD_INT 1
93639: NEG
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 5
93647: NEG
93648: PUSH
93649: LD_INT 2
93651: NEG
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 3
93659: NEG
93660: PUSH
93661: LD_INT 2
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 3
93670: NEG
93671: PUSH
93672: LD_INT 3
93674: NEG
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 3
93682: NEG
93683: PUSH
93684: LD_INT 4
93686: NEG
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 2
93694: NEG
93695: PUSH
93696: LD_INT 3
93698: NEG
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 2
93706: NEG
93707: PUSH
93708: LD_INT 2
93710: NEG
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: LD_INT 3
93718: NEG
93719: PUSH
93720: LD_INT 2
93722: NEG
93723: PUSH
93724: EMPTY
93725: LIST
93726: LIST
93727: PUSH
93728: LD_INT 4
93730: NEG
93731: PUSH
93732: LD_INT 3
93734: NEG
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 4
93742: NEG
93743: PUSH
93744: LD_INT 4
93746: NEG
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 2
93754: NEG
93755: PUSH
93756: LD_INT 4
93758: NEG
93759: PUSH
93760: EMPTY
93761: LIST
93762: LIST
93763: PUSH
93764: LD_INT 4
93766: NEG
93767: PUSH
93768: LD_INT 2
93770: NEG
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: PUSH
93776: LD_INT 0
93778: PUSH
93779: LD_INT 4
93781: NEG
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: PUSH
93787: LD_INT 0
93789: PUSH
93790: LD_INT 5
93792: NEG
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 1
93800: PUSH
93801: LD_INT 4
93803: NEG
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 1
93811: PUSH
93812: LD_INT 3
93814: NEG
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 0
93822: PUSH
93823: LD_INT 3
93825: NEG
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 1
93833: NEG
93834: PUSH
93835: LD_INT 4
93837: NEG
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 1
93845: NEG
93846: PUSH
93847: LD_INT 5
93849: NEG
93850: PUSH
93851: EMPTY
93852: LIST
93853: LIST
93854: PUSH
93855: LD_INT 2
93857: PUSH
93858: LD_INT 3
93860: NEG
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 2
93868: NEG
93869: PUSH
93870: LD_INT 5
93872: NEG
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 3
93880: PUSH
93881: LD_INT 0
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 3
93890: PUSH
93891: LD_INT 1
93893: NEG
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 4
93901: PUSH
93902: LD_INT 0
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 4
93911: PUSH
93912: LD_INT 1
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: LD_INT 3
93921: PUSH
93922: LD_INT 1
93924: PUSH
93925: EMPTY
93926: LIST
93927: LIST
93928: PUSH
93929: LD_INT 2
93931: PUSH
93932: LD_INT 0
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PUSH
93939: LD_INT 2
93941: PUSH
93942: LD_INT 1
93944: NEG
93945: PUSH
93946: EMPTY
93947: LIST
93948: LIST
93949: PUSH
93950: LD_INT 2
93952: PUSH
93953: LD_INT 2
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: LD_INT 4
93963: PUSH
93964: LD_INT 2
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PUSH
93971: LD_INT 4
93973: PUSH
93974: LD_INT 4
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 4
93983: PUSH
93984: LD_INT 3
93986: PUSH
93987: EMPTY
93988: LIST
93989: LIST
93990: PUSH
93991: LD_INT 5
93993: PUSH
93994: LD_INT 4
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 5
94003: PUSH
94004: LD_INT 5
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 4
94013: PUSH
94014: LD_INT 5
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 3
94023: PUSH
94024: LD_INT 4
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: PUSH
94031: LD_INT 3
94033: PUSH
94034: LD_INT 3
94036: PUSH
94037: EMPTY
94038: LIST
94039: LIST
94040: PUSH
94041: LD_INT 5
94043: PUSH
94044: LD_INT 3
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 3
94053: PUSH
94054: LD_INT 5
94056: PUSH
94057: EMPTY
94058: LIST
94059: LIST
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: LIST
94097: LIST
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94108: LD_ADDR_VAR 0 33
94112: PUSH
94113: LD_INT 4
94115: NEG
94116: PUSH
94117: LD_INT 4
94119: NEG
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 4
94127: NEG
94128: PUSH
94129: LD_INT 5
94131: NEG
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PUSH
94137: LD_INT 3
94139: NEG
94140: PUSH
94141: LD_INT 4
94143: NEG
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: PUSH
94149: LD_INT 3
94151: NEG
94152: PUSH
94153: LD_INT 3
94155: NEG
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 4
94163: NEG
94164: PUSH
94165: LD_INT 3
94167: NEG
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: LD_INT 5
94175: NEG
94176: PUSH
94177: LD_INT 4
94179: NEG
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 5
94187: NEG
94188: PUSH
94189: LD_INT 5
94191: NEG
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 3
94199: NEG
94200: PUSH
94201: LD_INT 5
94203: NEG
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 5
94211: NEG
94212: PUSH
94213: LD_INT 3
94215: NEG
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 0
94223: PUSH
94224: LD_INT 3
94226: NEG
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: LD_INT 0
94234: PUSH
94235: LD_INT 4
94237: NEG
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 1
94245: PUSH
94246: LD_INT 3
94248: NEG
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 1
94256: PUSH
94257: LD_INT 2
94259: NEG
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 0
94267: PUSH
94268: LD_INT 2
94270: NEG
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 1
94278: NEG
94279: PUSH
94280: LD_INT 3
94282: NEG
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 1
94290: NEG
94291: PUSH
94292: LD_INT 4
94294: NEG
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_INT 2
94302: PUSH
94303: LD_INT 2
94305: NEG
94306: PUSH
94307: EMPTY
94308: LIST
94309: LIST
94310: PUSH
94311: LD_INT 2
94313: NEG
94314: PUSH
94315: LD_INT 4
94317: NEG
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: PUSH
94323: LD_INT 4
94325: PUSH
94326: LD_INT 0
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 4
94335: PUSH
94336: LD_INT 1
94338: NEG
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 5
94346: PUSH
94347: LD_INT 0
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 5
94356: PUSH
94357: LD_INT 1
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 4
94366: PUSH
94367: LD_INT 1
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: LD_INT 3
94376: PUSH
94377: LD_INT 0
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 3
94386: PUSH
94387: LD_INT 1
94389: NEG
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 3
94397: PUSH
94398: LD_INT 2
94400: NEG
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: LD_INT 5
94408: PUSH
94409: LD_INT 2
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: PUSH
94416: LD_INT 3
94418: PUSH
94419: LD_INT 3
94421: PUSH
94422: EMPTY
94423: LIST
94424: LIST
94425: PUSH
94426: LD_INT 3
94428: PUSH
94429: LD_INT 2
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 4
94438: PUSH
94439: LD_INT 3
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 4
94448: PUSH
94449: LD_INT 4
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: LD_INT 3
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: EMPTY
94463: LIST
94464: LIST
94465: PUSH
94466: LD_INT 2
94468: PUSH
94469: LD_INT 3
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: PUSH
94476: LD_INT 2
94478: PUSH
94479: LD_INT 2
94481: PUSH
94482: EMPTY
94483: LIST
94484: LIST
94485: PUSH
94486: LD_INT 4
94488: PUSH
94489: LD_INT 2
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: PUSH
94496: LD_INT 2
94498: PUSH
94499: LD_INT 4
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 0
94508: PUSH
94509: LD_INT 4
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 0
94518: PUSH
94519: LD_INT 3
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 1
94528: PUSH
94529: LD_INT 4
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PUSH
94536: LD_INT 1
94538: PUSH
94539: LD_INT 5
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 0
94548: PUSH
94549: LD_INT 5
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: PUSH
94556: LD_INT 1
94558: NEG
94559: PUSH
94560: LD_INT 4
94562: PUSH
94563: EMPTY
94564: LIST
94565: LIST
94566: PUSH
94567: LD_INT 1
94569: NEG
94570: PUSH
94571: LD_INT 3
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 2
94580: PUSH
94581: LD_INT 5
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 2
94590: NEG
94591: PUSH
94592: LD_INT 3
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94646: LD_ADDR_VAR 0 34
94650: PUSH
94651: LD_INT 0
94653: PUSH
94654: LD_INT 4
94656: NEG
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 0
94664: PUSH
94665: LD_INT 5
94667: NEG
94668: PUSH
94669: EMPTY
94670: LIST
94671: LIST
94672: PUSH
94673: LD_INT 1
94675: PUSH
94676: LD_INT 4
94678: NEG
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 1
94686: PUSH
94687: LD_INT 3
94689: NEG
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: LD_INT 0
94697: PUSH
94698: LD_INT 3
94700: NEG
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: PUSH
94706: LD_INT 1
94708: NEG
94709: PUSH
94710: LD_INT 4
94712: NEG
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 1
94720: NEG
94721: PUSH
94722: LD_INT 5
94724: NEG
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 2
94732: PUSH
94733: LD_INT 3
94735: NEG
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 2
94743: NEG
94744: PUSH
94745: LD_INT 5
94747: NEG
94748: PUSH
94749: EMPTY
94750: LIST
94751: LIST
94752: PUSH
94753: LD_INT 3
94755: PUSH
94756: LD_INT 0
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 3
94765: PUSH
94766: LD_INT 1
94768: NEG
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 4
94776: PUSH
94777: LD_INT 0
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: PUSH
94784: LD_INT 4
94786: PUSH
94787: LD_INT 1
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 3
94796: PUSH
94797: LD_INT 1
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 2
94806: PUSH
94807: LD_INT 0
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 2
94816: PUSH
94817: LD_INT 1
94819: NEG
94820: PUSH
94821: EMPTY
94822: LIST
94823: LIST
94824: PUSH
94825: LD_INT 2
94827: PUSH
94828: LD_INT 2
94830: NEG
94831: PUSH
94832: EMPTY
94833: LIST
94834: LIST
94835: PUSH
94836: LD_INT 4
94838: PUSH
94839: LD_INT 2
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: PUSH
94846: LD_INT 4
94848: PUSH
94849: LD_INT 4
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 4
94858: PUSH
94859: LD_INT 3
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 5
94868: PUSH
94869: LD_INT 4
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 5
94878: PUSH
94879: LD_INT 5
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: LD_INT 4
94888: PUSH
94889: LD_INT 5
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 3
94898: PUSH
94899: LD_INT 4
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PUSH
94906: LD_INT 3
94908: PUSH
94909: LD_INT 3
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 5
94918: PUSH
94919: LD_INT 3
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 3
94928: PUSH
94929: LD_INT 5
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 0
94938: PUSH
94939: LD_INT 3
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 0
94948: PUSH
94949: LD_INT 2
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 1
94958: PUSH
94959: LD_INT 3
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 1
94968: PUSH
94969: LD_INT 4
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 0
94978: PUSH
94979: LD_INT 4
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 1
94988: NEG
94989: PUSH
94990: LD_INT 3
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: LD_INT 1
94999: NEG
95000: PUSH
95001: LD_INT 2
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 2
95010: PUSH
95011: LD_INT 4
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 2
95020: NEG
95021: PUSH
95022: LD_INT 2
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: PUSH
95029: LD_INT 4
95031: NEG
95032: PUSH
95033: LD_INT 0
95035: PUSH
95036: EMPTY
95037: LIST
95038: LIST
95039: PUSH
95040: LD_INT 4
95042: NEG
95043: PUSH
95044: LD_INT 1
95046: NEG
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PUSH
95052: LD_INT 3
95054: NEG
95055: PUSH
95056: LD_INT 0
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 3
95065: NEG
95066: PUSH
95067: LD_INT 1
95069: PUSH
95070: EMPTY
95071: LIST
95072: LIST
95073: PUSH
95074: LD_INT 4
95076: NEG
95077: PUSH
95078: LD_INT 1
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: PUSH
95085: LD_INT 5
95087: NEG
95088: PUSH
95089: LD_INT 0
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 5
95098: NEG
95099: PUSH
95100: LD_INT 1
95102: NEG
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 5
95110: NEG
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 3
95122: NEG
95123: PUSH
95124: LD_INT 2
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: EMPTY
95132: LIST
95133: LIST
95134: LIST
95135: LIST
95136: LIST
95137: LIST
95138: LIST
95139: LIST
95140: LIST
95141: LIST
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: LIST
95152: LIST
95153: LIST
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: ST_TO_ADDR
// end ; end ;
95178: GO 95181
95180: POP
// case btype of b_depot , b_warehouse :
95181: LD_VAR 0 1
95185: PUSH
95186: LD_INT 0
95188: DOUBLE
95189: EQUAL
95190: IFTRUE 95200
95192: LD_INT 1
95194: DOUBLE
95195: EQUAL
95196: IFTRUE 95200
95198: GO 95401
95200: POP
// case nation of nation_american :
95201: LD_VAR 0 5
95205: PUSH
95206: LD_INT 1
95208: DOUBLE
95209: EQUAL
95210: IFTRUE 95214
95212: GO 95270
95214: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95215: LD_ADDR_VAR 0 9
95219: PUSH
95220: LD_VAR 0 11
95224: PUSH
95225: LD_VAR 0 12
95229: PUSH
95230: LD_VAR 0 13
95234: PUSH
95235: LD_VAR 0 14
95239: PUSH
95240: LD_VAR 0 15
95244: PUSH
95245: LD_VAR 0 16
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: PUSH
95258: LD_VAR 0 4
95262: PUSH
95263: LD_INT 1
95265: PLUS
95266: ARRAY
95267: ST_TO_ADDR
95268: GO 95399
95270: LD_INT 2
95272: DOUBLE
95273: EQUAL
95274: IFTRUE 95278
95276: GO 95334
95278: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95279: LD_ADDR_VAR 0 9
95283: PUSH
95284: LD_VAR 0 17
95288: PUSH
95289: LD_VAR 0 18
95293: PUSH
95294: LD_VAR 0 19
95298: PUSH
95299: LD_VAR 0 20
95303: PUSH
95304: LD_VAR 0 21
95308: PUSH
95309: LD_VAR 0 22
95313: PUSH
95314: EMPTY
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: PUSH
95322: LD_VAR 0 4
95326: PUSH
95327: LD_INT 1
95329: PLUS
95330: ARRAY
95331: ST_TO_ADDR
95332: GO 95399
95334: LD_INT 3
95336: DOUBLE
95337: EQUAL
95338: IFTRUE 95342
95340: GO 95398
95342: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95343: LD_ADDR_VAR 0 9
95347: PUSH
95348: LD_VAR 0 23
95352: PUSH
95353: LD_VAR 0 24
95357: PUSH
95358: LD_VAR 0 25
95362: PUSH
95363: LD_VAR 0 26
95367: PUSH
95368: LD_VAR 0 27
95372: PUSH
95373: LD_VAR 0 28
95377: PUSH
95378: EMPTY
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: PUSH
95386: LD_VAR 0 4
95390: PUSH
95391: LD_INT 1
95393: PLUS
95394: ARRAY
95395: ST_TO_ADDR
95396: GO 95399
95398: POP
95399: GO 95954
95401: LD_INT 2
95403: DOUBLE
95404: EQUAL
95405: IFTRUE 95415
95407: LD_INT 3
95409: DOUBLE
95410: EQUAL
95411: IFTRUE 95415
95413: GO 95471
95415: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95416: LD_ADDR_VAR 0 9
95420: PUSH
95421: LD_VAR 0 29
95425: PUSH
95426: LD_VAR 0 30
95430: PUSH
95431: LD_VAR 0 31
95435: PUSH
95436: LD_VAR 0 32
95440: PUSH
95441: LD_VAR 0 33
95445: PUSH
95446: LD_VAR 0 34
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: PUSH
95459: LD_VAR 0 4
95463: PUSH
95464: LD_INT 1
95466: PLUS
95467: ARRAY
95468: ST_TO_ADDR
95469: GO 95954
95471: LD_INT 16
95473: DOUBLE
95474: EQUAL
95475: IFTRUE 95533
95477: LD_INT 17
95479: DOUBLE
95480: EQUAL
95481: IFTRUE 95533
95483: LD_INT 18
95485: DOUBLE
95486: EQUAL
95487: IFTRUE 95533
95489: LD_INT 19
95491: DOUBLE
95492: EQUAL
95493: IFTRUE 95533
95495: LD_INT 22
95497: DOUBLE
95498: EQUAL
95499: IFTRUE 95533
95501: LD_INT 20
95503: DOUBLE
95504: EQUAL
95505: IFTRUE 95533
95507: LD_INT 21
95509: DOUBLE
95510: EQUAL
95511: IFTRUE 95533
95513: LD_INT 23
95515: DOUBLE
95516: EQUAL
95517: IFTRUE 95533
95519: LD_INT 24
95521: DOUBLE
95522: EQUAL
95523: IFTRUE 95533
95525: LD_INT 25
95527: DOUBLE
95528: EQUAL
95529: IFTRUE 95533
95531: GO 95589
95533: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95534: LD_ADDR_VAR 0 9
95538: PUSH
95539: LD_VAR 0 35
95543: PUSH
95544: LD_VAR 0 36
95548: PUSH
95549: LD_VAR 0 37
95553: PUSH
95554: LD_VAR 0 38
95558: PUSH
95559: LD_VAR 0 39
95563: PUSH
95564: LD_VAR 0 40
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: PUSH
95577: LD_VAR 0 4
95581: PUSH
95582: LD_INT 1
95584: PLUS
95585: ARRAY
95586: ST_TO_ADDR
95587: GO 95954
95589: LD_INT 6
95591: DOUBLE
95592: EQUAL
95593: IFTRUE 95645
95595: LD_INT 7
95597: DOUBLE
95598: EQUAL
95599: IFTRUE 95645
95601: LD_INT 8
95603: DOUBLE
95604: EQUAL
95605: IFTRUE 95645
95607: LD_INT 13
95609: DOUBLE
95610: EQUAL
95611: IFTRUE 95645
95613: LD_INT 12
95615: DOUBLE
95616: EQUAL
95617: IFTRUE 95645
95619: LD_INT 15
95621: DOUBLE
95622: EQUAL
95623: IFTRUE 95645
95625: LD_INT 11
95627: DOUBLE
95628: EQUAL
95629: IFTRUE 95645
95631: LD_INT 14
95633: DOUBLE
95634: EQUAL
95635: IFTRUE 95645
95637: LD_INT 10
95639: DOUBLE
95640: EQUAL
95641: IFTRUE 95645
95643: GO 95701
95645: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
95646: LD_ADDR_VAR 0 9
95650: PUSH
95651: LD_VAR 0 41
95655: PUSH
95656: LD_VAR 0 42
95660: PUSH
95661: LD_VAR 0 43
95665: PUSH
95666: LD_VAR 0 44
95670: PUSH
95671: LD_VAR 0 45
95675: PUSH
95676: LD_VAR 0 46
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: PUSH
95689: LD_VAR 0 4
95693: PUSH
95694: LD_INT 1
95696: PLUS
95697: ARRAY
95698: ST_TO_ADDR
95699: GO 95954
95701: LD_INT 36
95703: DOUBLE
95704: EQUAL
95705: IFTRUE 95709
95707: GO 95765
95709: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95710: LD_ADDR_VAR 0 9
95714: PUSH
95715: LD_VAR 0 47
95719: PUSH
95720: LD_VAR 0 48
95724: PUSH
95725: LD_VAR 0 49
95729: PUSH
95730: LD_VAR 0 50
95734: PUSH
95735: LD_VAR 0 51
95739: PUSH
95740: LD_VAR 0 52
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: PUSH
95753: LD_VAR 0 4
95757: PUSH
95758: LD_INT 1
95760: PLUS
95761: ARRAY
95762: ST_TO_ADDR
95763: GO 95954
95765: LD_INT 4
95767: DOUBLE
95768: EQUAL
95769: IFTRUE 95791
95771: LD_INT 5
95773: DOUBLE
95774: EQUAL
95775: IFTRUE 95791
95777: LD_INT 34
95779: DOUBLE
95780: EQUAL
95781: IFTRUE 95791
95783: LD_INT 37
95785: DOUBLE
95786: EQUAL
95787: IFTRUE 95791
95789: GO 95847
95791: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95792: LD_ADDR_VAR 0 9
95796: PUSH
95797: LD_VAR 0 53
95801: PUSH
95802: LD_VAR 0 54
95806: PUSH
95807: LD_VAR 0 55
95811: PUSH
95812: LD_VAR 0 56
95816: PUSH
95817: LD_VAR 0 57
95821: PUSH
95822: LD_VAR 0 58
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: PUSH
95835: LD_VAR 0 4
95839: PUSH
95840: LD_INT 1
95842: PLUS
95843: ARRAY
95844: ST_TO_ADDR
95845: GO 95954
95847: LD_INT 31
95849: DOUBLE
95850: EQUAL
95851: IFTRUE 95897
95853: LD_INT 32
95855: DOUBLE
95856: EQUAL
95857: IFTRUE 95897
95859: LD_INT 33
95861: DOUBLE
95862: EQUAL
95863: IFTRUE 95897
95865: LD_INT 27
95867: DOUBLE
95868: EQUAL
95869: IFTRUE 95897
95871: LD_INT 26
95873: DOUBLE
95874: EQUAL
95875: IFTRUE 95897
95877: LD_INT 28
95879: DOUBLE
95880: EQUAL
95881: IFTRUE 95897
95883: LD_INT 29
95885: DOUBLE
95886: EQUAL
95887: IFTRUE 95897
95889: LD_INT 30
95891: DOUBLE
95892: EQUAL
95893: IFTRUE 95897
95895: GO 95953
95897: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
95898: LD_ADDR_VAR 0 9
95902: PUSH
95903: LD_VAR 0 59
95907: PUSH
95908: LD_VAR 0 60
95912: PUSH
95913: LD_VAR 0 61
95917: PUSH
95918: LD_VAR 0 62
95922: PUSH
95923: LD_VAR 0 63
95927: PUSH
95928: LD_VAR 0 64
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: PUSH
95941: LD_VAR 0 4
95945: PUSH
95946: LD_INT 1
95948: PLUS
95949: ARRAY
95950: ST_TO_ADDR
95951: GO 95954
95953: POP
// temp_list2 = [ ] ;
95954: LD_ADDR_VAR 0 10
95958: PUSH
95959: EMPTY
95960: ST_TO_ADDR
// for i in temp_list do
95961: LD_ADDR_VAR 0 8
95965: PUSH
95966: LD_VAR 0 9
95970: PUSH
95971: FOR_IN
95972: IFFALSE 96024
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95974: LD_ADDR_VAR 0 10
95978: PUSH
95979: LD_VAR 0 10
95983: PUSH
95984: LD_VAR 0 8
95988: PUSH
95989: LD_INT 1
95991: ARRAY
95992: PUSH
95993: LD_VAR 0 2
95997: PLUS
95998: PUSH
95999: LD_VAR 0 8
96003: PUSH
96004: LD_INT 2
96006: ARRAY
96007: PUSH
96008: LD_VAR 0 3
96012: PLUS
96013: PUSH
96014: EMPTY
96015: LIST
96016: LIST
96017: PUSH
96018: EMPTY
96019: LIST
96020: ADD
96021: ST_TO_ADDR
96022: GO 95971
96024: POP
96025: POP
// result = temp_list2 ;
96026: LD_ADDR_VAR 0 7
96030: PUSH
96031: LD_VAR 0 10
96035: ST_TO_ADDR
// end ;
96036: LD_VAR 0 7
96040: RET
// export function EnemyInRange ( unit , dist ) ; begin
96041: LD_INT 0
96043: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96044: LD_ADDR_VAR 0 3
96048: PUSH
96049: LD_VAR 0 1
96053: PPUSH
96054: CALL_OW 255
96058: PPUSH
96059: LD_VAR 0 1
96063: PPUSH
96064: CALL_OW 250
96068: PPUSH
96069: LD_VAR 0 1
96073: PPUSH
96074: CALL_OW 251
96078: PPUSH
96079: LD_VAR 0 2
96083: PPUSH
96084: CALL 69437 0 4
96088: PUSH
96089: LD_INT 4
96091: ARRAY
96092: ST_TO_ADDR
// end ;
96093: LD_VAR 0 3
96097: RET
// export function PlayerSeeMe ( unit ) ; begin
96098: LD_INT 0
96100: PPUSH
// result := See ( your_side , unit ) ;
96101: LD_ADDR_VAR 0 2
96105: PUSH
96106: LD_OWVAR 2
96110: PPUSH
96111: LD_VAR 0 1
96115: PPUSH
96116: CALL_OW 292
96120: ST_TO_ADDR
// end ;
96121: LD_VAR 0 2
96125: RET
// export function ReverseDir ( unit ) ; begin
96126: LD_INT 0
96128: PPUSH
// if not unit then
96129: LD_VAR 0 1
96133: NOT
96134: IFFALSE 96138
// exit ;
96136: GO 96161
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96138: LD_ADDR_VAR 0 2
96142: PUSH
96143: LD_VAR 0 1
96147: PPUSH
96148: CALL_OW 254
96152: PUSH
96153: LD_INT 3
96155: PLUS
96156: PUSH
96157: LD_INT 6
96159: MOD
96160: ST_TO_ADDR
// end ;
96161: LD_VAR 0 2
96165: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96166: LD_INT 0
96168: PPUSH
96169: PPUSH
96170: PPUSH
96171: PPUSH
96172: PPUSH
// if not hexes then
96173: LD_VAR 0 2
96177: NOT
96178: IFFALSE 96182
// exit ;
96180: GO 96330
// dist := 9999 ;
96182: LD_ADDR_VAR 0 5
96186: PUSH
96187: LD_INT 9999
96189: ST_TO_ADDR
// for i = 1 to hexes do
96190: LD_ADDR_VAR 0 4
96194: PUSH
96195: DOUBLE
96196: LD_INT 1
96198: DEC
96199: ST_TO_ADDR
96200: LD_VAR 0 2
96204: PUSH
96205: FOR_TO
96206: IFFALSE 96318
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96208: LD_VAR 0 1
96212: PPUSH
96213: LD_VAR 0 2
96217: PUSH
96218: LD_VAR 0 4
96222: ARRAY
96223: PUSH
96224: LD_INT 1
96226: ARRAY
96227: PPUSH
96228: LD_VAR 0 2
96232: PUSH
96233: LD_VAR 0 4
96237: ARRAY
96238: PUSH
96239: LD_INT 2
96241: ARRAY
96242: PPUSH
96243: CALL_OW 297
96247: PUSH
96248: LD_VAR 0 5
96252: LESS
96253: IFFALSE 96316
// begin hex := hexes [ i ] ;
96255: LD_ADDR_VAR 0 7
96259: PUSH
96260: LD_VAR 0 2
96264: PUSH
96265: LD_VAR 0 4
96269: ARRAY
96270: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96271: LD_ADDR_VAR 0 5
96275: PUSH
96276: LD_VAR 0 1
96280: PPUSH
96281: LD_VAR 0 2
96285: PUSH
96286: LD_VAR 0 4
96290: ARRAY
96291: PUSH
96292: LD_INT 1
96294: ARRAY
96295: PPUSH
96296: LD_VAR 0 2
96300: PUSH
96301: LD_VAR 0 4
96305: ARRAY
96306: PUSH
96307: LD_INT 2
96309: ARRAY
96310: PPUSH
96311: CALL_OW 297
96315: ST_TO_ADDR
// end ; end ;
96316: GO 96205
96318: POP
96319: POP
// result := hex ;
96320: LD_ADDR_VAR 0 3
96324: PUSH
96325: LD_VAR 0 7
96329: ST_TO_ADDR
// end ;
96330: LD_VAR 0 3
96334: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96335: LD_INT 0
96337: PPUSH
96338: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96339: LD_VAR 0 1
96343: NOT
96344: PUSH
96345: LD_VAR 0 1
96349: PUSH
96350: LD_INT 21
96352: PUSH
96353: LD_INT 2
96355: PUSH
96356: EMPTY
96357: LIST
96358: LIST
96359: PUSH
96360: LD_INT 23
96362: PUSH
96363: LD_INT 2
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PPUSH
96374: CALL_OW 69
96378: IN
96379: NOT
96380: OR
96381: IFFALSE 96385
// exit ;
96383: GO 96432
// for i = 1 to 3 do
96385: LD_ADDR_VAR 0 3
96389: PUSH
96390: DOUBLE
96391: LD_INT 1
96393: DEC
96394: ST_TO_ADDR
96395: LD_INT 3
96397: PUSH
96398: FOR_TO
96399: IFFALSE 96430
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96401: LD_VAR 0 1
96405: PPUSH
96406: CALL_OW 250
96410: PPUSH
96411: LD_VAR 0 1
96415: PPUSH
96416: CALL_OW 251
96420: PPUSH
96421: LD_INT 1
96423: PPUSH
96424: CALL_OW 453
96428: GO 96398
96430: POP
96431: POP
// end ;
96432: LD_VAR 0 2
96436: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96437: LD_INT 0
96439: PPUSH
96440: PPUSH
96441: PPUSH
96442: PPUSH
96443: PPUSH
96444: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96445: LD_VAR 0 1
96449: NOT
96450: PUSH
96451: LD_VAR 0 2
96455: NOT
96456: OR
96457: PUSH
96458: LD_VAR 0 1
96462: PPUSH
96463: CALL_OW 314
96467: OR
96468: IFFALSE 96472
// exit ;
96470: GO 96913
// x := GetX ( enemy_unit ) ;
96472: LD_ADDR_VAR 0 7
96476: PUSH
96477: LD_VAR 0 2
96481: PPUSH
96482: CALL_OW 250
96486: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96487: LD_ADDR_VAR 0 8
96491: PUSH
96492: LD_VAR 0 2
96496: PPUSH
96497: CALL_OW 251
96501: ST_TO_ADDR
// if not x or not y then
96502: LD_VAR 0 7
96506: NOT
96507: PUSH
96508: LD_VAR 0 8
96512: NOT
96513: OR
96514: IFFALSE 96518
// exit ;
96516: GO 96913
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96518: LD_ADDR_VAR 0 6
96522: PUSH
96523: LD_VAR 0 7
96527: PPUSH
96528: LD_INT 0
96530: PPUSH
96531: LD_INT 4
96533: PPUSH
96534: CALL_OW 272
96538: PUSH
96539: LD_VAR 0 8
96543: PPUSH
96544: LD_INT 0
96546: PPUSH
96547: LD_INT 4
96549: PPUSH
96550: CALL_OW 273
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: LD_VAR 0 7
96563: PPUSH
96564: LD_INT 1
96566: PPUSH
96567: LD_INT 4
96569: PPUSH
96570: CALL_OW 272
96574: PUSH
96575: LD_VAR 0 8
96579: PPUSH
96580: LD_INT 1
96582: PPUSH
96583: LD_INT 4
96585: PPUSH
96586: CALL_OW 273
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: LD_VAR 0 7
96599: PPUSH
96600: LD_INT 2
96602: PPUSH
96603: LD_INT 4
96605: PPUSH
96606: CALL_OW 272
96610: PUSH
96611: LD_VAR 0 8
96615: PPUSH
96616: LD_INT 2
96618: PPUSH
96619: LD_INT 4
96621: PPUSH
96622: CALL_OW 273
96626: PUSH
96627: EMPTY
96628: LIST
96629: LIST
96630: PUSH
96631: LD_VAR 0 7
96635: PPUSH
96636: LD_INT 3
96638: PPUSH
96639: LD_INT 4
96641: PPUSH
96642: CALL_OW 272
96646: PUSH
96647: LD_VAR 0 8
96651: PPUSH
96652: LD_INT 3
96654: PPUSH
96655: LD_INT 4
96657: PPUSH
96658: CALL_OW 273
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: LD_VAR 0 7
96671: PPUSH
96672: LD_INT 4
96674: PPUSH
96675: LD_INT 4
96677: PPUSH
96678: CALL_OW 272
96682: PUSH
96683: LD_VAR 0 8
96687: PPUSH
96688: LD_INT 4
96690: PPUSH
96691: LD_INT 4
96693: PPUSH
96694: CALL_OW 273
96698: PUSH
96699: EMPTY
96700: LIST
96701: LIST
96702: PUSH
96703: LD_VAR 0 7
96707: PPUSH
96708: LD_INT 5
96710: PPUSH
96711: LD_INT 4
96713: PPUSH
96714: CALL_OW 272
96718: PUSH
96719: LD_VAR 0 8
96723: PPUSH
96724: LD_INT 5
96726: PPUSH
96727: LD_INT 4
96729: PPUSH
96730: CALL_OW 273
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: ST_TO_ADDR
// for i = tmp downto 1 do
96747: LD_ADDR_VAR 0 4
96751: PUSH
96752: DOUBLE
96753: LD_VAR 0 6
96757: INC
96758: ST_TO_ADDR
96759: LD_INT 1
96761: PUSH
96762: FOR_DOWNTO
96763: IFFALSE 96864
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96765: LD_VAR 0 6
96769: PUSH
96770: LD_VAR 0 4
96774: ARRAY
96775: PUSH
96776: LD_INT 1
96778: ARRAY
96779: PPUSH
96780: LD_VAR 0 6
96784: PUSH
96785: LD_VAR 0 4
96789: ARRAY
96790: PUSH
96791: LD_INT 2
96793: ARRAY
96794: PPUSH
96795: CALL_OW 488
96799: NOT
96800: PUSH
96801: LD_VAR 0 6
96805: PUSH
96806: LD_VAR 0 4
96810: ARRAY
96811: PUSH
96812: LD_INT 1
96814: ARRAY
96815: PPUSH
96816: LD_VAR 0 6
96820: PUSH
96821: LD_VAR 0 4
96825: ARRAY
96826: PUSH
96827: LD_INT 2
96829: ARRAY
96830: PPUSH
96831: CALL_OW 428
96835: PUSH
96836: LD_INT 0
96838: NONEQUAL
96839: OR
96840: IFFALSE 96862
// tmp := Delete ( tmp , i ) ;
96842: LD_ADDR_VAR 0 6
96846: PUSH
96847: LD_VAR 0 6
96851: PPUSH
96852: LD_VAR 0 4
96856: PPUSH
96857: CALL_OW 3
96861: ST_TO_ADDR
96862: GO 96762
96864: POP
96865: POP
// j := GetClosestHex ( unit , tmp ) ;
96866: LD_ADDR_VAR 0 5
96870: PUSH
96871: LD_VAR 0 1
96875: PPUSH
96876: LD_VAR 0 6
96880: PPUSH
96881: CALL 96166 0 2
96885: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96886: LD_VAR 0 1
96890: PPUSH
96891: LD_VAR 0 5
96895: PUSH
96896: LD_INT 1
96898: ARRAY
96899: PPUSH
96900: LD_VAR 0 5
96904: PUSH
96905: LD_INT 2
96907: ARRAY
96908: PPUSH
96909: CALL_OW 111
// end ;
96913: LD_VAR 0 3
96917: RET
// export function PrepareApemanSoldier ( ) ; begin
96918: LD_INT 0
96920: PPUSH
// uc_nation := 0 ;
96921: LD_ADDR_OWVAR 21
96925: PUSH
96926: LD_INT 0
96928: ST_TO_ADDR
// hc_sex := sex_male ;
96929: LD_ADDR_OWVAR 27
96933: PUSH
96934: LD_INT 1
96936: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
96937: LD_ADDR_OWVAR 28
96941: PUSH
96942: LD_INT 15
96944: ST_TO_ADDR
// hc_gallery :=  ;
96945: LD_ADDR_OWVAR 33
96949: PUSH
96950: LD_STRING 
96952: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96953: LD_ADDR_OWVAR 31
96957: PUSH
96958: LD_INT 0
96960: PPUSH
96961: LD_INT 3
96963: PPUSH
96964: CALL_OW 12
96968: PUSH
96969: LD_INT 0
96971: PPUSH
96972: LD_INT 3
96974: PPUSH
96975: CALL_OW 12
96979: PUSH
96980: LD_INT 0
96982: PUSH
96983: LD_INT 0
96985: PUSH
96986: EMPTY
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: ST_TO_ADDR
// end ;
96992: LD_VAR 0 1
96996: RET
// export function PrepareApemanEngineer ( ) ; begin
96997: LD_INT 0
96999: PPUSH
// uc_nation := 0 ;
97000: LD_ADDR_OWVAR 21
97004: PUSH
97005: LD_INT 0
97007: ST_TO_ADDR
// hc_sex := sex_male ;
97008: LD_ADDR_OWVAR 27
97012: PUSH
97013: LD_INT 1
97015: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
97016: LD_ADDR_OWVAR 28
97020: PUSH
97021: LD_INT 16
97023: ST_TO_ADDR
// hc_gallery :=  ;
97024: LD_ADDR_OWVAR 33
97028: PUSH
97029: LD_STRING 
97031: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97032: LD_ADDR_OWVAR 31
97036: PUSH
97037: LD_INT 0
97039: PPUSH
97040: LD_INT 3
97042: PPUSH
97043: CALL_OW 12
97047: PUSH
97048: LD_INT 0
97050: PPUSH
97051: LD_INT 3
97053: PPUSH
97054: CALL_OW 12
97058: PUSH
97059: LD_INT 0
97061: PUSH
97062: LD_INT 0
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: ST_TO_ADDR
// end ;
97071: LD_VAR 0 1
97075: RET
// export function PrepareApeman ( agressivity ) ; begin
97076: LD_INT 0
97078: PPUSH
// uc_side := 0 ;
97079: LD_ADDR_OWVAR 20
97083: PUSH
97084: LD_INT 0
97086: ST_TO_ADDR
// uc_nation := 0 ;
97087: LD_ADDR_OWVAR 21
97091: PUSH
97092: LD_INT 0
97094: ST_TO_ADDR
// hc_sex := sex_male ;
97095: LD_ADDR_OWVAR 27
97099: PUSH
97100: LD_INT 1
97102: ST_TO_ADDR
// hc_class := class_apeman ;
97103: LD_ADDR_OWVAR 28
97107: PUSH
97108: LD_INT 12
97110: ST_TO_ADDR
// hc_gallery :=  ;
97111: LD_ADDR_OWVAR 33
97115: PUSH
97116: LD_STRING 
97118: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97119: LD_ADDR_OWVAR 35
97123: PUSH
97124: LD_VAR 0 1
97128: NEG
97129: PPUSH
97130: LD_VAR 0 1
97134: PPUSH
97135: CALL_OW 12
97139: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
97140: LD_ADDR_OWVAR 31
97144: PUSH
97145: LD_INT 0
97147: PPUSH
97148: LD_INT 3
97150: PPUSH
97151: CALL_OW 12
97155: PUSH
97156: LD_INT 0
97158: PPUSH
97159: LD_INT 3
97161: PPUSH
97162: CALL_OW 12
97166: PUSH
97167: LD_INT 0
97169: PUSH
97170: LD_INT 0
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: LIST
97177: LIST
97178: ST_TO_ADDR
// end ;
97179: LD_VAR 0 2
97183: RET
// export function PrepareTiger ( agressivity ) ; begin
97184: LD_INT 0
97186: PPUSH
// uc_side := 0 ;
97187: LD_ADDR_OWVAR 20
97191: PUSH
97192: LD_INT 0
97194: ST_TO_ADDR
// uc_nation := 0 ;
97195: LD_ADDR_OWVAR 21
97199: PUSH
97200: LD_INT 0
97202: ST_TO_ADDR
// hc_class := class_tiger ;
97203: LD_ADDR_OWVAR 28
97207: PUSH
97208: LD_INT 14
97210: ST_TO_ADDR
// hc_gallery :=  ;
97211: LD_ADDR_OWVAR 33
97215: PUSH
97216: LD_STRING 
97218: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97219: LD_ADDR_OWVAR 35
97223: PUSH
97224: LD_VAR 0 1
97228: NEG
97229: PPUSH
97230: LD_VAR 0 1
97234: PPUSH
97235: CALL_OW 12
97239: ST_TO_ADDR
// end ;
97240: LD_VAR 0 2
97244: RET
// export function PrepareEnchidna ( ) ; begin
97245: LD_INT 0
97247: PPUSH
// uc_side := 0 ;
97248: LD_ADDR_OWVAR 20
97252: PUSH
97253: LD_INT 0
97255: ST_TO_ADDR
// uc_nation := 0 ;
97256: LD_ADDR_OWVAR 21
97260: PUSH
97261: LD_INT 0
97263: ST_TO_ADDR
// hc_class := class_baggie ;
97264: LD_ADDR_OWVAR 28
97268: PUSH
97269: LD_INT 13
97271: ST_TO_ADDR
// hc_gallery :=  ;
97272: LD_ADDR_OWVAR 33
97276: PUSH
97277: LD_STRING 
97279: ST_TO_ADDR
// end ;
97280: LD_VAR 0 1
97284: RET
// export function PrepareFrog ( ) ; begin
97285: LD_INT 0
97287: PPUSH
// uc_side := 0 ;
97288: LD_ADDR_OWVAR 20
97292: PUSH
97293: LD_INT 0
97295: ST_TO_ADDR
// uc_nation := 0 ;
97296: LD_ADDR_OWVAR 21
97300: PUSH
97301: LD_INT 0
97303: ST_TO_ADDR
// hc_class := class_frog ;
97304: LD_ADDR_OWVAR 28
97308: PUSH
97309: LD_INT 19
97311: ST_TO_ADDR
// hc_gallery :=  ;
97312: LD_ADDR_OWVAR 33
97316: PUSH
97317: LD_STRING 
97319: ST_TO_ADDR
// end ;
97320: LD_VAR 0 1
97324: RET
// export function PrepareFish ( ) ; begin
97325: LD_INT 0
97327: PPUSH
// uc_side := 0 ;
97328: LD_ADDR_OWVAR 20
97332: PUSH
97333: LD_INT 0
97335: ST_TO_ADDR
// uc_nation := 0 ;
97336: LD_ADDR_OWVAR 21
97340: PUSH
97341: LD_INT 0
97343: ST_TO_ADDR
// hc_class := class_fish ;
97344: LD_ADDR_OWVAR 28
97348: PUSH
97349: LD_INT 20
97351: ST_TO_ADDR
// hc_gallery :=  ;
97352: LD_ADDR_OWVAR 33
97356: PUSH
97357: LD_STRING 
97359: ST_TO_ADDR
// end ;
97360: LD_VAR 0 1
97364: RET
// export function PrepareBird ( ) ; begin
97365: LD_INT 0
97367: PPUSH
// uc_side := 0 ;
97368: LD_ADDR_OWVAR 20
97372: PUSH
97373: LD_INT 0
97375: ST_TO_ADDR
// uc_nation := 0 ;
97376: LD_ADDR_OWVAR 21
97380: PUSH
97381: LD_INT 0
97383: ST_TO_ADDR
// hc_class := class_phororhacos ;
97384: LD_ADDR_OWVAR 28
97388: PUSH
97389: LD_INT 18
97391: ST_TO_ADDR
// hc_gallery :=  ;
97392: LD_ADDR_OWVAR 33
97396: PUSH
97397: LD_STRING 
97399: ST_TO_ADDR
// end ;
97400: LD_VAR 0 1
97404: RET
// export function PrepareHorse ( ) ; begin
97405: LD_INT 0
97407: PPUSH
// uc_side := 0 ;
97408: LD_ADDR_OWVAR 20
97412: PUSH
97413: LD_INT 0
97415: ST_TO_ADDR
// uc_nation := 0 ;
97416: LD_ADDR_OWVAR 21
97420: PUSH
97421: LD_INT 0
97423: ST_TO_ADDR
// hc_class := class_horse ;
97424: LD_ADDR_OWVAR 28
97428: PUSH
97429: LD_INT 21
97431: ST_TO_ADDR
// hc_gallery :=  ;
97432: LD_ADDR_OWVAR 33
97436: PUSH
97437: LD_STRING 
97439: ST_TO_ADDR
// end ;
97440: LD_VAR 0 1
97444: RET
// export function PrepareMastodont ( ) ; begin
97445: LD_INT 0
97447: PPUSH
// uc_side := 0 ;
97448: LD_ADDR_OWVAR 20
97452: PUSH
97453: LD_INT 0
97455: ST_TO_ADDR
// uc_nation := 0 ;
97456: LD_ADDR_OWVAR 21
97460: PUSH
97461: LD_INT 0
97463: ST_TO_ADDR
// vc_chassis := class_mastodont ;
97464: LD_ADDR_OWVAR 37
97468: PUSH
97469: LD_INT 31
97471: ST_TO_ADDR
// vc_control := control_rider ;
97472: LD_ADDR_OWVAR 38
97476: PUSH
97477: LD_INT 4
97479: ST_TO_ADDR
// end ;
97480: LD_VAR 0 1
97484: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97485: LD_INT 0
97487: PPUSH
97488: PPUSH
97489: PPUSH
// uc_side = 0 ;
97490: LD_ADDR_OWVAR 20
97494: PUSH
97495: LD_INT 0
97497: ST_TO_ADDR
// uc_nation = 0 ;
97498: LD_ADDR_OWVAR 21
97502: PUSH
97503: LD_INT 0
97505: ST_TO_ADDR
// InitHc_All ( ) ;
97506: CALL_OW 584
// InitVc ;
97510: CALL_OW 20
// if mastodonts then
97514: LD_VAR 0 6
97518: IFFALSE 97585
// for i = 1 to mastodonts do
97520: LD_ADDR_VAR 0 11
97524: PUSH
97525: DOUBLE
97526: LD_INT 1
97528: DEC
97529: ST_TO_ADDR
97530: LD_VAR 0 6
97534: PUSH
97535: FOR_TO
97536: IFFALSE 97583
// begin vc_chassis := 31 ;
97538: LD_ADDR_OWVAR 37
97542: PUSH
97543: LD_INT 31
97545: ST_TO_ADDR
// vc_control := control_rider ;
97546: LD_ADDR_OWVAR 38
97550: PUSH
97551: LD_INT 4
97553: ST_TO_ADDR
// animal := CreateVehicle ;
97554: LD_ADDR_VAR 0 12
97558: PUSH
97559: CALL_OW 45
97563: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97564: LD_VAR 0 12
97568: PPUSH
97569: LD_VAR 0 8
97573: PPUSH
97574: LD_INT 0
97576: PPUSH
97577: CALL 99720 0 3
// end ;
97581: GO 97535
97583: POP
97584: POP
// if horses then
97585: LD_VAR 0 5
97589: IFFALSE 97656
// for i = 1 to horses do
97591: LD_ADDR_VAR 0 11
97595: PUSH
97596: DOUBLE
97597: LD_INT 1
97599: DEC
97600: ST_TO_ADDR
97601: LD_VAR 0 5
97605: PUSH
97606: FOR_TO
97607: IFFALSE 97654
// begin hc_class := 21 ;
97609: LD_ADDR_OWVAR 28
97613: PUSH
97614: LD_INT 21
97616: ST_TO_ADDR
// hc_gallery :=  ;
97617: LD_ADDR_OWVAR 33
97621: PUSH
97622: LD_STRING 
97624: ST_TO_ADDR
// animal := CreateHuman ;
97625: LD_ADDR_VAR 0 12
97629: PUSH
97630: CALL_OW 44
97634: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97635: LD_VAR 0 12
97639: PPUSH
97640: LD_VAR 0 8
97644: PPUSH
97645: LD_INT 0
97647: PPUSH
97648: CALL 99720 0 3
// end ;
97652: GO 97606
97654: POP
97655: POP
// if birds then
97656: LD_VAR 0 1
97660: IFFALSE 97727
// for i = 1 to birds do
97662: LD_ADDR_VAR 0 11
97666: PUSH
97667: DOUBLE
97668: LD_INT 1
97670: DEC
97671: ST_TO_ADDR
97672: LD_VAR 0 1
97676: PUSH
97677: FOR_TO
97678: IFFALSE 97725
// begin hc_class = 18 ;
97680: LD_ADDR_OWVAR 28
97684: PUSH
97685: LD_INT 18
97687: ST_TO_ADDR
// hc_gallery =  ;
97688: LD_ADDR_OWVAR 33
97692: PUSH
97693: LD_STRING 
97695: ST_TO_ADDR
// animal := CreateHuman ;
97696: LD_ADDR_VAR 0 12
97700: PUSH
97701: CALL_OW 44
97705: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97706: LD_VAR 0 12
97710: PPUSH
97711: LD_VAR 0 8
97715: PPUSH
97716: LD_INT 0
97718: PPUSH
97719: CALL 99720 0 3
// end ;
97723: GO 97677
97725: POP
97726: POP
// if tigers then
97727: LD_VAR 0 2
97731: IFFALSE 97815
// for i = 1 to tigers do
97733: LD_ADDR_VAR 0 11
97737: PUSH
97738: DOUBLE
97739: LD_INT 1
97741: DEC
97742: ST_TO_ADDR
97743: LD_VAR 0 2
97747: PUSH
97748: FOR_TO
97749: IFFALSE 97813
// begin hc_class = class_tiger ;
97751: LD_ADDR_OWVAR 28
97755: PUSH
97756: LD_INT 14
97758: ST_TO_ADDR
// hc_gallery =  ;
97759: LD_ADDR_OWVAR 33
97763: PUSH
97764: LD_STRING 
97766: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97767: LD_ADDR_OWVAR 35
97771: PUSH
97772: LD_INT 7
97774: NEG
97775: PPUSH
97776: LD_INT 7
97778: PPUSH
97779: CALL_OW 12
97783: ST_TO_ADDR
// animal := CreateHuman ;
97784: LD_ADDR_VAR 0 12
97788: PUSH
97789: CALL_OW 44
97793: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97794: LD_VAR 0 12
97798: PPUSH
97799: LD_VAR 0 8
97803: PPUSH
97804: LD_INT 0
97806: PPUSH
97807: CALL 99720 0 3
// end ;
97811: GO 97748
97813: POP
97814: POP
// if apemans then
97815: LD_VAR 0 3
97819: IFFALSE 97942
// for i = 1 to apemans do
97821: LD_ADDR_VAR 0 11
97825: PUSH
97826: DOUBLE
97827: LD_INT 1
97829: DEC
97830: ST_TO_ADDR
97831: LD_VAR 0 3
97835: PUSH
97836: FOR_TO
97837: IFFALSE 97940
// begin hc_class = class_apeman ;
97839: LD_ADDR_OWVAR 28
97843: PUSH
97844: LD_INT 12
97846: ST_TO_ADDR
// hc_gallery =  ;
97847: LD_ADDR_OWVAR 33
97851: PUSH
97852: LD_STRING 
97854: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
97855: LD_ADDR_OWVAR 35
97859: PUSH
97860: LD_INT 2
97862: NEG
97863: PPUSH
97864: LD_INT 2
97866: PPUSH
97867: CALL_OW 12
97871: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97872: LD_ADDR_OWVAR 31
97876: PUSH
97877: LD_INT 1
97879: PPUSH
97880: LD_INT 3
97882: PPUSH
97883: CALL_OW 12
97887: PUSH
97888: LD_INT 1
97890: PPUSH
97891: LD_INT 3
97893: PPUSH
97894: CALL_OW 12
97898: PUSH
97899: LD_INT 0
97901: PUSH
97902: LD_INT 0
97904: PUSH
97905: EMPTY
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: ST_TO_ADDR
// animal := CreateHuman ;
97911: LD_ADDR_VAR 0 12
97915: PUSH
97916: CALL_OW 44
97920: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97921: LD_VAR 0 12
97925: PPUSH
97926: LD_VAR 0 8
97930: PPUSH
97931: LD_INT 0
97933: PPUSH
97934: CALL 99720 0 3
// end ;
97938: GO 97836
97940: POP
97941: POP
// if enchidnas then
97942: LD_VAR 0 4
97946: IFFALSE 98013
// for i = 1 to enchidnas do
97948: LD_ADDR_VAR 0 11
97952: PUSH
97953: DOUBLE
97954: LD_INT 1
97956: DEC
97957: ST_TO_ADDR
97958: LD_VAR 0 4
97962: PUSH
97963: FOR_TO
97964: IFFALSE 98011
// begin hc_class = 13 ;
97966: LD_ADDR_OWVAR 28
97970: PUSH
97971: LD_INT 13
97973: ST_TO_ADDR
// hc_gallery =  ;
97974: LD_ADDR_OWVAR 33
97978: PUSH
97979: LD_STRING 
97981: ST_TO_ADDR
// animal := CreateHuman ;
97982: LD_ADDR_VAR 0 12
97986: PUSH
97987: CALL_OW 44
97991: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97992: LD_VAR 0 12
97996: PPUSH
97997: LD_VAR 0 8
98001: PPUSH
98002: LD_INT 0
98004: PPUSH
98005: CALL 99720 0 3
// end ;
98009: GO 97963
98011: POP
98012: POP
// if fishes then
98013: LD_VAR 0 7
98017: IFFALSE 98084
// for i = 1 to fishes do
98019: LD_ADDR_VAR 0 11
98023: PUSH
98024: DOUBLE
98025: LD_INT 1
98027: DEC
98028: ST_TO_ADDR
98029: LD_VAR 0 7
98033: PUSH
98034: FOR_TO
98035: IFFALSE 98082
// begin hc_class = 20 ;
98037: LD_ADDR_OWVAR 28
98041: PUSH
98042: LD_INT 20
98044: ST_TO_ADDR
// hc_gallery =  ;
98045: LD_ADDR_OWVAR 33
98049: PUSH
98050: LD_STRING 
98052: ST_TO_ADDR
// animal := CreateHuman ;
98053: LD_ADDR_VAR 0 12
98057: PUSH
98058: CALL_OW 44
98062: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98063: LD_VAR 0 12
98067: PPUSH
98068: LD_VAR 0 9
98072: PPUSH
98073: LD_INT 0
98075: PPUSH
98076: CALL 99720 0 3
// end ;
98080: GO 98034
98082: POP
98083: POP
// end ;
98084: LD_VAR 0 10
98088: RET
// export function WantHeal ( sci , unit ) ; begin
98089: LD_INT 0
98091: PPUSH
// if GetTaskList ( sci ) > 0 then
98092: LD_VAR 0 1
98096: PPUSH
98097: CALL_OW 437
98101: PUSH
98102: LD_INT 0
98104: GREATER
98105: IFFALSE 98175
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98107: LD_VAR 0 1
98111: PPUSH
98112: CALL_OW 437
98116: PUSH
98117: LD_INT 1
98119: ARRAY
98120: PUSH
98121: LD_INT 1
98123: ARRAY
98124: PUSH
98125: LD_STRING l
98127: EQUAL
98128: PUSH
98129: LD_VAR 0 1
98133: PPUSH
98134: CALL_OW 437
98138: PUSH
98139: LD_INT 1
98141: ARRAY
98142: PUSH
98143: LD_INT 4
98145: ARRAY
98146: PUSH
98147: LD_VAR 0 2
98151: EQUAL
98152: AND
98153: IFFALSE 98165
// result := true else
98155: LD_ADDR_VAR 0 3
98159: PUSH
98160: LD_INT 1
98162: ST_TO_ADDR
98163: GO 98173
// result := false ;
98165: LD_ADDR_VAR 0 3
98169: PUSH
98170: LD_INT 0
98172: ST_TO_ADDR
// end else
98173: GO 98183
// result := false ;
98175: LD_ADDR_VAR 0 3
98179: PUSH
98180: LD_INT 0
98182: ST_TO_ADDR
// end ;
98183: LD_VAR 0 3
98187: RET
// export function HealTarget ( sci ) ; begin
98188: LD_INT 0
98190: PPUSH
// if not sci then
98191: LD_VAR 0 1
98195: NOT
98196: IFFALSE 98200
// exit ;
98198: GO 98265
// result := 0 ;
98200: LD_ADDR_VAR 0 2
98204: PUSH
98205: LD_INT 0
98207: ST_TO_ADDR
// if GetTaskList ( sci ) then
98208: LD_VAR 0 1
98212: PPUSH
98213: CALL_OW 437
98217: IFFALSE 98265
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98219: LD_VAR 0 1
98223: PPUSH
98224: CALL_OW 437
98228: PUSH
98229: LD_INT 1
98231: ARRAY
98232: PUSH
98233: LD_INT 1
98235: ARRAY
98236: PUSH
98237: LD_STRING l
98239: EQUAL
98240: IFFALSE 98265
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98242: LD_ADDR_VAR 0 2
98246: PUSH
98247: LD_VAR 0 1
98251: PPUSH
98252: CALL_OW 437
98256: PUSH
98257: LD_INT 1
98259: ARRAY
98260: PUSH
98261: LD_INT 4
98263: ARRAY
98264: ST_TO_ADDR
// end ;
98265: LD_VAR 0 2
98269: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98270: LD_INT 0
98272: PPUSH
98273: PPUSH
98274: PPUSH
98275: PPUSH
// if not base_units then
98276: LD_VAR 0 1
98280: NOT
98281: IFFALSE 98285
// exit ;
98283: GO 98372
// result := false ;
98285: LD_ADDR_VAR 0 2
98289: PUSH
98290: LD_INT 0
98292: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98293: LD_ADDR_VAR 0 5
98297: PUSH
98298: LD_VAR 0 1
98302: PPUSH
98303: LD_INT 21
98305: PUSH
98306: LD_INT 3
98308: PUSH
98309: EMPTY
98310: LIST
98311: LIST
98312: PPUSH
98313: CALL_OW 72
98317: ST_TO_ADDR
// if not tmp then
98318: LD_VAR 0 5
98322: NOT
98323: IFFALSE 98327
// exit ;
98325: GO 98372
// for i in tmp do
98327: LD_ADDR_VAR 0 3
98331: PUSH
98332: LD_VAR 0 5
98336: PUSH
98337: FOR_IN
98338: IFFALSE 98370
// begin result := EnemyInRange ( i , 22 ) ;
98340: LD_ADDR_VAR 0 2
98344: PUSH
98345: LD_VAR 0 3
98349: PPUSH
98350: LD_INT 22
98352: PPUSH
98353: CALL 96041 0 2
98357: ST_TO_ADDR
// if result then
98358: LD_VAR 0 2
98362: IFFALSE 98368
// exit ;
98364: POP
98365: POP
98366: GO 98372
// end ;
98368: GO 98337
98370: POP
98371: POP
// end ;
98372: LD_VAR 0 2
98376: RET
// export function FilterByTag ( units , tag ) ; begin
98377: LD_INT 0
98379: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
98380: LD_ADDR_VAR 0 3
98384: PUSH
98385: LD_VAR 0 1
98389: PPUSH
98390: LD_INT 120
98392: PUSH
98393: LD_VAR 0 2
98397: PUSH
98398: EMPTY
98399: LIST
98400: LIST
98401: PPUSH
98402: CALL_OW 72
98406: ST_TO_ADDR
// end ;
98407: LD_VAR 0 3
98411: RET
// export function IsDriver ( un ) ; begin
98412: LD_INT 0
98414: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98415: LD_ADDR_VAR 0 2
98419: PUSH
98420: LD_VAR 0 1
98424: PUSH
98425: LD_INT 55
98427: PUSH
98428: EMPTY
98429: LIST
98430: PPUSH
98431: CALL_OW 69
98435: IN
98436: ST_TO_ADDR
// end ;
98437: LD_VAR 0 2
98441: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98442: LD_INT 0
98444: PPUSH
98445: PPUSH
// list := [ ] ;
98446: LD_ADDR_VAR 0 5
98450: PUSH
98451: EMPTY
98452: ST_TO_ADDR
// case d of 0 :
98453: LD_VAR 0 3
98457: PUSH
98458: LD_INT 0
98460: DOUBLE
98461: EQUAL
98462: IFTRUE 98466
98464: GO 98599
98466: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98467: LD_ADDR_VAR 0 5
98471: PUSH
98472: LD_VAR 0 1
98476: PUSH
98477: LD_INT 4
98479: MINUS
98480: PUSH
98481: LD_VAR 0 2
98485: PUSH
98486: LD_INT 4
98488: MINUS
98489: PUSH
98490: LD_INT 2
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: LIST
98497: PUSH
98498: LD_VAR 0 1
98502: PUSH
98503: LD_INT 3
98505: MINUS
98506: PUSH
98507: LD_VAR 0 2
98511: PUSH
98512: LD_INT 1
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: LIST
98519: PUSH
98520: LD_VAR 0 1
98524: PUSH
98525: LD_INT 4
98527: PLUS
98528: PUSH
98529: LD_VAR 0 2
98533: PUSH
98534: LD_INT 4
98536: PUSH
98537: EMPTY
98538: LIST
98539: LIST
98540: LIST
98541: PUSH
98542: LD_VAR 0 1
98546: PUSH
98547: LD_INT 3
98549: PLUS
98550: PUSH
98551: LD_VAR 0 2
98555: PUSH
98556: LD_INT 3
98558: PLUS
98559: PUSH
98560: LD_INT 5
98562: PUSH
98563: EMPTY
98564: LIST
98565: LIST
98566: LIST
98567: PUSH
98568: LD_VAR 0 1
98572: PUSH
98573: LD_VAR 0 2
98577: PUSH
98578: LD_INT 4
98580: PLUS
98581: PUSH
98582: LD_INT 0
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: LIST
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: LIST
98594: LIST
98595: LIST
98596: ST_TO_ADDR
// end ; 1 :
98597: GO 99297
98599: LD_INT 1
98601: DOUBLE
98602: EQUAL
98603: IFTRUE 98607
98605: GO 98740
98607: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98608: LD_ADDR_VAR 0 5
98612: PUSH
98613: LD_VAR 0 1
98617: PUSH
98618: LD_VAR 0 2
98622: PUSH
98623: LD_INT 4
98625: MINUS
98626: PUSH
98627: LD_INT 3
98629: PUSH
98630: EMPTY
98631: LIST
98632: LIST
98633: LIST
98634: PUSH
98635: LD_VAR 0 1
98639: PUSH
98640: LD_INT 3
98642: MINUS
98643: PUSH
98644: LD_VAR 0 2
98648: PUSH
98649: LD_INT 3
98651: MINUS
98652: PUSH
98653: LD_INT 2
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: LIST
98660: PUSH
98661: LD_VAR 0 1
98665: PUSH
98666: LD_INT 4
98668: MINUS
98669: PUSH
98670: LD_VAR 0 2
98674: PUSH
98675: LD_INT 1
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: LIST
98682: PUSH
98683: LD_VAR 0 1
98687: PUSH
98688: LD_VAR 0 2
98692: PUSH
98693: LD_INT 3
98695: PLUS
98696: PUSH
98697: LD_INT 0
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: LIST
98704: PUSH
98705: LD_VAR 0 1
98709: PUSH
98710: LD_INT 4
98712: PLUS
98713: PUSH
98714: LD_VAR 0 2
98718: PUSH
98719: LD_INT 4
98721: PLUS
98722: PUSH
98723: LD_INT 5
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: LIST
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: ST_TO_ADDR
// end ; 2 :
98738: GO 99297
98740: LD_INT 2
98742: DOUBLE
98743: EQUAL
98744: IFTRUE 98748
98746: GO 98877
98748: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98749: LD_ADDR_VAR 0 5
98753: PUSH
98754: LD_VAR 0 1
98758: PUSH
98759: LD_VAR 0 2
98763: PUSH
98764: LD_INT 3
98766: MINUS
98767: PUSH
98768: LD_INT 3
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: LIST
98775: PUSH
98776: LD_VAR 0 1
98780: PUSH
98781: LD_INT 4
98783: PLUS
98784: PUSH
98785: LD_VAR 0 2
98789: PUSH
98790: LD_INT 4
98792: PUSH
98793: EMPTY
98794: LIST
98795: LIST
98796: LIST
98797: PUSH
98798: LD_VAR 0 1
98802: PUSH
98803: LD_VAR 0 2
98807: PUSH
98808: LD_INT 4
98810: PLUS
98811: PUSH
98812: LD_INT 0
98814: PUSH
98815: EMPTY
98816: LIST
98817: LIST
98818: LIST
98819: PUSH
98820: LD_VAR 0 1
98824: PUSH
98825: LD_INT 3
98827: MINUS
98828: PUSH
98829: LD_VAR 0 2
98833: PUSH
98834: LD_INT 1
98836: PUSH
98837: EMPTY
98838: LIST
98839: LIST
98840: LIST
98841: PUSH
98842: LD_VAR 0 1
98846: PUSH
98847: LD_INT 4
98849: MINUS
98850: PUSH
98851: LD_VAR 0 2
98855: PUSH
98856: LD_INT 4
98858: MINUS
98859: PUSH
98860: LD_INT 2
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: LIST
98867: PUSH
98868: EMPTY
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: ST_TO_ADDR
// end ; 3 :
98875: GO 99297
98877: LD_INT 3
98879: DOUBLE
98880: EQUAL
98881: IFTRUE 98885
98883: GO 99018
98885: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
98886: LD_ADDR_VAR 0 5
98890: PUSH
98891: LD_VAR 0 1
98895: PUSH
98896: LD_INT 3
98898: PLUS
98899: PUSH
98900: LD_VAR 0 2
98904: PUSH
98905: LD_INT 4
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: LIST
98912: PUSH
98913: LD_VAR 0 1
98917: PUSH
98918: LD_INT 4
98920: PLUS
98921: PUSH
98922: LD_VAR 0 2
98926: PUSH
98927: LD_INT 4
98929: PLUS
98930: PUSH
98931: LD_INT 5
98933: PUSH
98934: EMPTY
98935: LIST
98936: LIST
98937: LIST
98938: PUSH
98939: LD_VAR 0 1
98943: PUSH
98944: LD_INT 4
98946: MINUS
98947: PUSH
98948: LD_VAR 0 2
98952: PUSH
98953: LD_INT 1
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: LIST
98960: PUSH
98961: LD_VAR 0 1
98965: PUSH
98966: LD_VAR 0 2
98970: PUSH
98971: LD_INT 4
98973: MINUS
98974: PUSH
98975: LD_INT 3
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: LIST
98982: PUSH
98983: LD_VAR 0 1
98987: PUSH
98988: LD_INT 3
98990: MINUS
98991: PUSH
98992: LD_VAR 0 2
98996: PUSH
98997: LD_INT 3
98999: MINUS
99000: PUSH
99001: LD_INT 2
99003: PUSH
99004: EMPTY
99005: LIST
99006: LIST
99007: LIST
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: LIST
99013: LIST
99014: LIST
99015: ST_TO_ADDR
// end ; 4 :
99016: GO 99297
99018: LD_INT 4
99020: DOUBLE
99021: EQUAL
99022: IFTRUE 99026
99024: GO 99159
99026: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99027: LD_ADDR_VAR 0 5
99031: PUSH
99032: LD_VAR 0 1
99036: PUSH
99037: LD_VAR 0 2
99041: PUSH
99042: LD_INT 4
99044: PLUS
99045: PUSH
99046: LD_INT 0
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: LIST
99053: PUSH
99054: LD_VAR 0 1
99058: PUSH
99059: LD_INT 3
99061: PLUS
99062: PUSH
99063: LD_VAR 0 2
99067: PUSH
99068: LD_INT 3
99070: PLUS
99071: PUSH
99072: LD_INT 5
99074: PUSH
99075: EMPTY
99076: LIST
99077: LIST
99078: LIST
99079: PUSH
99080: LD_VAR 0 1
99084: PUSH
99085: LD_INT 4
99087: PLUS
99088: PUSH
99089: LD_VAR 0 2
99093: PUSH
99094: LD_INT 4
99096: PUSH
99097: EMPTY
99098: LIST
99099: LIST
99100: LIST
99101: PUSH
99102: LD_VAR 0 1
99106: PUSH
99107: LD_VAR 0 2
99111: PUSH
99112: LD_INT 3
99114: MINUS
99115: PUSH
99116: LD_INT 3
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: LIST
99123: PUSH
99124: LD_VAR 0 1
99128: PUSH
99129: LD_INT 4
99131: MINUS
99132: PUSH
99133: LD_VAR 0 2
99137: PUSH
99138: LD_INT 4
99140: MINUS
99141: PUSH
99142: LD_INT 2
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: LIST
99149: PUSH
99150: EMPTY
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: ST_TO_ADDR
// end ; 5 :
99157: GO 99297
99159: LD_INT 5
99161: DOUBLE
99162: EQUAL
99163: IFTRUE 99167
99165: GO 99296
99167: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99168: LD_ADDR_VAR 0 5
99172: PUSH
99173: LD_VAR 0 1
99177: PUSH
99178: LD_INT 4
99180: MINUS
99181: PUSH
99182: LD_VAR 0 2
99186: PUSH
99187: LD_INT 1
99189: PUSH
99190: EMPTY
99191: LIST
99192: LIST
99193: LIST
99194: PUSH
99195: LD_VAR 0 1
99199: PUSH
99200: LD_VAR 0 2
99204: PUSH
99205: LD_INT 4
99207: MINUS
99208: PUSH
99209: LD_INT 3
99211: PUSH
99212: EMPTY
99213: LIST
99214: LIST
99215: LIST
99216: PUSH
99217: LD_VAR 0 1
99221: PUSH
99222: LD_INT 4
99224: PLUS
99225: PUSH
99226: LD_VAR 0 2
99230: PUSH
99231: LD_INT 4
99233: PLUS
99234: PUSH
99235: LD_INT 5
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: LIST
99242: PUSH
99243: LD_VAR 0 1
99247: PUSH
99248: LD_INT 3
99250: PLUS
99251: PUSH
99252: LD_VAR 0 2
99256: PUSH
99257: LD_INT 4
99259: PUSH
99260: EMPTY
99261: LIST
99262: LIST
99263: LIST
99264: PUSH
99265: LD_VAR 0 1
99269: PUSH
99270: LD_VAR 0 2
99274: PUSH
99275: LD_INT 3
99277: PLUS
99278: PUSH
99279: LD_INT 0
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: LIST
99286: PUSH
99287: EMPTY
99288: LIST
99289: LIST
99290: LIST
99291: LIST
99292: LIST
99293: ST_TO_ADDR
// end ; end ;
99294: GO 99297
99296: POP
// result := list ;
99297: LD_ADDR_VAR 0 4
99301: PUSH
99302: LD_VAR 0 5
99306: ST_TO_ADDR
// end ;
99307: LD_VAR 0 4
99311: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99312: LD_INT 0
99314: PPUSH
99315: PPUSH
99316: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99317: LD_VAR 0 1
99321: NOT
99322: PUSH
99323: LD_VAR 0 2
99327: PUSH
99328: LD_INT 1
99330: PUSH
99331: LD_INT 2
99333: PUSH
99334: LD_INT 3
99336: PUSH
99337: LD_INT 4
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: IN
99346: NOT
99347: OR
99348: IFFALSE 99352
// exit ;
99350: GO 99444
// tmp := [ ] ;
99352: LD_ADDR_VAR 0 5
99356: PUSH
99357: EMPTY
99358: ST_TO_ADDR
// for i in units do
99359: LD_ADDR_VAR 0 4
99363: PUSH
99364: LD_VAR 0 1
99368: PUSH
99369: FOR_IN
99370: IFFALSE 99413
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99372: LD_ADDR_VAR 0 5
99376: PUSH
99377: LD_VAR 0 5
99381: PPUSH
99382: LD_VAR 0 5
99386: PUSH
99387: LD_INT 1
99389: PLUS
99390: PPUSH
99391: LD_VAR 0 4
99395: PPUSH
99396: LD_VAR 0 2
99400: PPUSH
99401: CALL_OW 259
99405: PPUSH
99406: CALL_OW 2
99410: ST_TO_ADDR
99411: GO 99369
99413: POP
99414: POP
// if not tmp then
99415: LD_VAR 0 5
99419: NOT
99420: IFFALSE 99424
// exit ;
99422: GO 99444
// result := SortListByListDesc ( units , tmp ) ;
99424: LD_ADDR_VAR 0 3
99428: PUSH
99429: LD_VAR 0 1
99433: PPUSH
99434: LD_VAR 0 5
99438: PPUSH
99439: CALL_OW 77
99443: ST_TO_ADDR
// end ;
99444: LD_VAR 0 3
99448: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99449: LD_INT 0
99451: PPUSH
99452: PPUSH
99453: PPUSH
// result := false ;
99454: LD_ADDR_VAR 0 3
99458: PUSH
99459: LD_INT 0
99461: ST_TO_ADDR
// x := GetX ( building ) ;
99462: LD_ADDR_VAR 0 4
99466: PUSH
99467: LD_VAR 0 2
99471: PPUSH
99472: CALL_OW 250
99476: ST_TO_ADDR
// y := GetY ( building ) ;
99477: LD_ADDR_VAR 0 5
99481: PUSH
99482: LD_VAR 0 2
99486: PPUSH
99487: CALL_OW 251
99491: ST_TO_ADDR
// if not building or not x or not y then
99492: LD_VAR 0 2
99496: NOT
99497: PUSH
99498: LD_VAR 0 4
99502: NOT
99503: OR
99504: PUSH
99505: LD_VAR 0 5
99509: NOT
99510: OR
99511: IFFALSE 99515
// exit ;
99513: GO 99607
// if GetTaskList ( unit ) then
99515: LD_VAR 0 1
99519: PPUSH
99520: CALL_OW 437
99524: IFFALSE 99607
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99526: LD_STRING e
99528: PUSH
99529: LD_VAR 0 1
99533: PPUSH
99534: CALL_OW 437
99538: PUSH
99539: LD_INT 1
99541: ARRAY
99542: PUSH
99543: LD_INT 1
99545: ARRAY
99546: EQUAL
99547: PUSH
99548: LD_VAR 0 4
99552: PUSH
99553: LD_VAR 0 1
99557: PPUSH
99558: CALL_OW 437
99562: PUSH
99563: LD_INT 1
99565: ARRAY
99566: PUSH
99567: LD_INT 2
99569: ARRAY
99570: EQUAL
99571: AND
99572: PUSH
99573: LD_VAR 0 5
99577: PUSH
99578: LD_VAR 0 1
99582: PPUSH
99583: CALL_OW 437
99587: PUSH
99588: LD_INT 1
99590: ARRAY
99591: PUSH
99592: LD_INT 3
99594: ARRAY
99595: EQUAL
99596: AND
99597: IFFALSE 99607
// result := true end ;
99599: LD_ADDR_VAR 0 3
99603: PUSH
99604: LD_INT 1
99606: ST_TO_ADDR
// end ;
99607: LD_VAR 0 3
99611: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99612: LD_INT 0
99614: PPUSH
// result := false ;
99615: LD_ADDR_VAR 0 4
99619: PUSH
99620: LD_INT 0
99622: ST_TO_ADDR
// if GetTaskList ( unit ) then
99623: LD_VAR 0 1
99627: PPUSH
99628: CALL_OW 437
99632: IFFALSE 99715
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99634: LD_STRING M
99636: PUSH
99637: LD_VAR 0 1
99641: PPUSH
99642: CALL_OW 437
99646: PUSH
99647: LD_INT 1
99649: ARRAY
99650: PUSH
99651: LD_INT 1
99653: ARRAY
99654: EQUAL
99655: PUSH
99656: LD_VAR 0 2
99660: PUSH
99661: LD_VAR 0 1
99665: PPUSH
99666: CALL_OW 437
99670: PUSH
99671: LD_INT 1
99673: ARRAY
99674: PUSH
99675: LD_INT 2
99677: ARRAY
99678: EQUAL
99679: AND
99680: PUSH
99681: LD_VAR 0 3
99685: PUSH
99686: LD_VAR 0 1
99690: PPUSH
99691: CALL_OW 437
99695: PUSH
99696: LD_INT 1
99698: ARRAY
99699: PUSH
99700: LD_INT 3
99702: ARRAY
99703: EQUAL
99704: AND
99705: IFFALSE 99715
// result := true ;
99707: LD_ADDR_VAR 0 4
99711: PUSH
99712: LD_INT 1
99714: ST_TO_ADDR
// end ; end ;
99715: LD_VAR 0 4
99719: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99720: LD_INT 0
99722: PPUSH
99723: PPUSH
99724: PPUSH
99725: PPUSH
// if not unit or not area then
99726: LD_VAR 0 1
99730: NOT
99731: PUSH
99732: LD_VAR 0 2
99736: NOT
99737: OR
99738: IFFALSE 99742
// exit ;
99740: GO 99906
// tmp := AreaToList ( area , i ) ;
99742: LD_ADDR_VAR 0 6
99746: PUSH
99747: LD_VAR 0 2
99751: PPUSH
99752: LD_VAR 0 5
99756: PPUSH
99757: CALL_OW 517
99761: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99762: LD_ADDR_VAR 0 5
99766: PUSH
99767: DOUBLE
99768: LD_INT 1
99770: DEC
99771: ST_TO_ADDR
99772: LD_VAR 0 6
99776: PUSH
99777: LD_INT 1
99779: ARRAY
99780: PUSH
99781: FOR_TO
99782: IFFALSE 99904
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99784: LD_ADDR_VAR 0 7
99788: PUSH
99789: LD_VAR 0 6
99793: PUSH
99794: LD_INT 1
99796: ARRAY
99797: PUSH
99798: LD_VAR 0 5
99802: ARRAY
99803: PUSH
99804: LD_VAR 0 6
99808: PUSH
99809: LD_INT 2
99811: ARRAY
99812: PUSH
99813: LD_VAR 0 5
99817: ARRAY
99818: PUSH
99819: EMPTY
99820: LIST
99821: LIST
99822: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99823: LD_VAR 0 7
99827: PUSH
99828: LD_INT 1
99830: ARRAY
99831: PPUSH
99832: LD_VAR 0 7
99836: PUSH
99837: LD_INT 2
99839: ARRAY
99840: PPUSH
99841: CALL_OW 428
99845: PUSH
99846: LD_INT 0
99848: EQUAL
99849: IFFALSE 99902
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99851: LD_VAR 0 1
99855: PPUSH
99856: LD_VAR 0 7
99860: PUSH
99861: LD_INT 1
99863: ARRAY
99864: PPUSH
99865: LD_VAR 0 7
99869: PUSH
99870: LD_INT 2
99872: ARRAY
99873: PPUSH
99874: LD_VAR 0 3
99878: PPUSH
99879: CALL_OW 48
// result := IsPlaced ( unit ) ;
99883: LD_ADDR_VAR 0 4
99887: PUSH
99888: LD_VAR 0 1
99892: PPUSH
99893: CALL_OW 305
99897: ST_TO_ADDR
// exit ;
99898: POP
99899: POP
99900: GO 99906
// end ; end ;
99902: GO 99781
99904: POP
99905: POP
// end ;
99906: LD_VAR 0 4
99910: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99911: LD_INT 0
99913: PPUSH
99914: PPUSH
99915: PPUSH
// if not side or side > 8 then
99916: LD_VAR 0 1
99920: NOT
99921: PUSH
99922: LD_VAR 0 1
99926: PUSH
99927: LD_INT 8
99929: GREATER
99930: OR
99931: IFFALSE 99935
// exit ;
99933: GO 100122
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99935: LD_ADDR_VAR 0 4
99939: PUSH
99940: LD_INT 22
99942: PUSH
99943: LD_VAR 0 1
99947: PUSH
99948: EMPTY
99949: LIST
99950: LIST
99951: PUSH
99952: LD_INT 21
99954: PUSH
99955: LD_INT 3
99957: PUSH
99958: EMPTY
99959: LIST
99960: LIST
99961: PUSH
99962: EMPTY
99963: LIST
99964: LIST
99965: PPUSH
99966: CALL_OW 69
99970: ST_TO_ADDR
// if not tmp then
99971: LD_VAR 0 4
99975: NOT
99976: IFFALSE 99980
// exit ;
99978: GO 100122
// enable_addtolog := true ;
99980: LD_ADDR_OWVAR 81
99984: PUSH
99985: LD_INT 1
99987: ST_TO_ADDR
// AddToLog ( [ ) ;
99988: LD_STRING [
99990: PPUSH
99991: CALL_OW 561
// for i in tmp do
99995: LD_ADDR_VAR 0 3
99999: PUSH
100000: LD_VAR 0 4
100004: PUSH
100005: FOR_IN
100006: IFFALSE 100113
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100008: LD_STRING [
100010: PUSH
100011: LD_VAR 0 3
100015: PPUSH
100016: CALL_OW 266
100020: STR
100021: PUSH
100022: LD_STRING , 
100024: STR
100025: PUSH
100026: LD_VAR 0 3
100030: PPUSH
100031: CALL_OW 250
100035: STR
100036: PUSH
100037: LD_STRING , 
100039: STR
100040: PUSH
100041: LD_VAR 0 3
100045: PPUSH
100046: CALL_OW 251
100050: STR
100051: PUSH
100052: LD_STRING , 
100054: STR
100055: PUSH
100056: LD_VAR 0 3
100060: PPUSH
100061: CALL_OW 254
100065: STR
100066: PUSH
100067: LD_STRING , 
100069: STR
100070: PUSH
100071: LD_VAR 0 3
100075: PPUSH
100076: LD_INT 1
100078: PPUSH
100079: CALL_OW 268
100083: STR
100084: PUSH
100085: LD_STRING , 
100087: STR
100088: PUSH
100089: LD_VAR 0 3
100093: PPUSH
100094: LD_INT 2
100096: PPUSH
100097: CALL_OW 268
100101: STR
100102: PUSH
100103: LD_STRING ],
100105: STR
100106: PPUSH
100107: CALL_OW 561
// end ;
100111: GO 100005
100113: POP
100114: POP
// AddToLog ( ]; ) ;
100115: LD_STRING ];
100117: PPUSH
100118: CALL_OW 561
// end ;
100122: LD_VAR 0 2
100126: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100127: LD_INT 0
100129: PPUSH
100130: PPUSH
100131: PPUSH
100132: PPUSH
100133: PPUSH
// if not area or not rate or not max then
100134: LD_VAR 0 1
100138: NOT
100139: PUSH
100140: LD_VAR 0 2
100144: NOT
100145: OR
100146: PUSH
100147: LD_VAR 0 4
100151: NOT
100152: OR
100153: IFFALSE 100157
// exit ;
100155: GO 100346
// while 1 do
100157: LD_INT 1
100159: IFFALSE 100346
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100161: LD_ADDR_VAR 0 9
100165: PUSH
100166: LD_VAR 0 1
100170: PPUSH
100171: LD_INT 1
100173: PPUSH
100174: CALL_OW 287
100178: PUSH
100179: LD_INT 10
100181: MUL
100182: ST_TO_ADDR
// r := rate / 10 ;
100183: LD_ADDR_VAR 0 7
100187: PUSH
100188: LD_VAR 0 2
100192: PUSH
100193: LD_INT 10
100195: DIVREAL
100196: ST_TO_ADDR
// time := 1 1$00 ;
100197: LD_ADDR_VAR 0 8
100201: PUSH
100202: LD_INT 2100
100204: ST_TO_ADDR
// if amount < min then
100205: LD_VAR 0 9
100209: PUSH
100210: LD_VAR 0 3
100214: LESS
100215: IFFALSE 100233
// r := r * 2 else
100217: LD_ADDR_VAR 0 7
100221: PUSH
100222: LD_VAR 0 7
100226: PUSH
100227: LD_INT 2
100229: MUL
100230: ST_TO_ADDR
100231: GO 100259
// if amount > max then
100233: LD_VAR 0 9
100237: PUSH
100238: LD_VAR 0 4
100242: GREATER
100243: IFFALSE 100259
// r := r / 2 ;
100245: LD_ADDR_VAR 0 7
100249: PUSH
100250: LD_VAR 0 7
100254: PUSH
100255: LD_INT 2
100257: DIVREAL
100258: ST_TO_ADDR
// time := time / r ;
100259: LD_ADDR_VAR 0 8
100263: PUSH
100264: LD_VAR 0 8
100268: PUSH
100269: LD_VAR 0 7
100273: DIVREAL
100274: ST_TO_ADDR
// if time < 0 then
100275: LD_VAR 0 8
100279: PUSH
100280: LD_INT 0
100282: LESS
100283: IFFALSE 100300
// time := time * - 1 ;
100285: LD_ADDR_VAR 0 8
100289: PUSH
100290: LD_VAR 0 8
100294: PUSH
100295: LD_INT 1
100297: NEG
100298: MUL
100299: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100300: LD_VAR 0 8
100304: PUSH
100305: LD_INT 35
100307: PPUSH
100308: LD_INT 875
100310: PPUSH
100311: CALL_OW 12
100315: PLUS
100316: PPUSH
100317: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100321: LD_INT 1
100323: PPUSH
100324: LD_INT 5
100326: PPUSH
100327: CALL_OW 12
100331: PPUSH
100332: LD_VAR 0 1
100336: PPUSH
100337: LD_INT 1
100339: PPUSH
100340: CALL_OW 55
// end ;
100344: GO 100157
// end ;
100346: LD_VAR 0 5
100350: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100351: LD_INT 0
100353: PPUSH
100354: PPUSH
100355: PPUSH
100356: PPUSH
100357: PPUSH
100358: PPUSH
100359: PPUSH
100360: PPUSH
// if not turrets or not factories then
100361: LD_VAR 0 1
100365: NOT
100366: PUSH
100367: LD_VAR 0 2
100371: NOT
100372: OR
100373: IFFALSE 100377
// exit ;
100375: GO 100684
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100377: LD_ADDR_VAR 0 10
100381: PUSH
100382: LD_INT 5
100384: PUSH
100385: LD_INT 6
100387: PUSH
100388: EMPTY
100389: LIST
100390: LIST
100391: PUSH
100392: LD_INT 2
100394: PUSH
100395: LD_INT 4
100397: PUSH
100398: EMPTY
100399: LIST
100400: LIST
100401: PUSH
100402: LD_INT 3
100404: PUSH
100405: LD_INT 5
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: LIST
100416: PUSH
100417: LD_INT 24
100419: PUSH
100420: LD_INT 25
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PUSH
100427: LD_INT 23
100429: PUSH
100430: LD_INT 27
100432: PUSH
100433: EMPTY
100434: LIST
100435: LIST
100436: PUSH
100437: EMPTY
100438: LIST
100439: LIST
100440: PUSH
100441: LD_INT 42
100443: PUSH
100444: LD_INT 43
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PUSH
100451: LD_INT 44
100453: PUSH
100454: LD_INT 46
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: PUSH
100461: LD_INT 45
100463: PUSH
100464: LD_INT 47
100466: PUSH
100467: EMPTY
100468: LIST
100469: LIST
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: LIST
100475: PUSH
100476: EMPTY
100477: LIST
100478: LIST
100479: LIST
100480: ST_TO_ADDR
// result := [ ] ;
100481: LD_ADDR_VAR 0 3
100485: PUSH
100486: EMPTY
100487: ST_TO_ADDR
// for i in turrets do
100488: LD_ADDR_VAR 0 4
100492: PUSH
100493: LD_VAR 0 1
100497: PUSH
100498: FOR_IN
100499: IFFALSE 100682
// begin nat := GetNation ( i ) ;
100501: LD_ADDR_VAR 0 7
100505: PUSH
100506: LD_VAR 0 4
100510: PPUSH
100511: CALL_OW 248
100515: ST_TO_ADDR
// weapon := 0 ;
100516: LD_ADDR_VAR 0 8
100520: PUSH
100521: LD_INT 0
100523: ST_TO_ADDR
// if not nat then
100524: LD_VAR 0 7
100528: NOT
100529: IFFALSE 100533
// continue ;
100531: GO 100498
// for j in list [ nat ] do
100533: LD_ADDR_VAR 0 5
100537: PUSH
100538: LD_VAR 0 10
100542: PUSH
100543: LD_VAR 0 7
100547: ARRAY
100548: PUSH
100549: FOR_IN
100550: IFFALSE 100591
// if GetBWeapon ( i ) = j [ 1 ] then
100552: LD_VAR 0 4
100556: PPUSH
100557: CALL_OW 269
100561: PUSH
100562: LD_VAR 0 5
100566: PUSH
100567: LD_INT 1
100569: ARRAY
100570: EQUAL
100571: IFFALSE 100589
// begin weapon := j [ 2 ] ;
100573: LD_ADDR_VAR 0 8
100577: PUSH
100578: LD_VAR 0 5
100582: PUSH
100583: LD_INT 2
100585: ARRAY
100586: ST_TO_ADDR
// break ;
100587: GO 100591
// end ;
100589: GO 100549
100591: POP
100592: POP
// if not weapon then
100593: LD_VAR 0 8
100597: NOT
100598: IFFALSE 100602
// continue ;
100600: GO 100498
// for k in factories do
100602: LD_ADDR_VAR 0 6
100606: PUSH
100607: LD_VAR 0 2
100611: PUSH
100612: FOR_IN
100613: IFFALSE 100678
// begin weapons := AvailableWeaponList ( k ) ;
100615: LD_ADDR_VAR 0 9
100619: PUSH
100620: LD_VAR 0 6
100624: PPUSH
100625: CALL_OW 478
100629: ST_TO_ADDR
// if not weapons then
100630: LD_VAR 0 9
100634: NOT
100635: IFFALSE 100639
// continue ;
100637: GO 100612
// if weapon in weapons then
100639: LD_VAR 0 8
100643: PUSH
100644: LD_VAR 0 9
100648: IN
100649: IFFALSE 100676
// begin result := [ i , weapon ] ;
100651: LD_ADDR_VAR 0 3
100655: PUSH
100656: LD_VAR 0 4
100660: PUSH
100661: LD_VAR 0 8
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: ST_TO_ADDR
// exit ;
100670: POP
100671: POP
100672: POP
100673: POP
100674: GO 100684
// end ; end ;
100676: GO 100612
100678: POP
100679: POP
// end ;
100680: GO 100498
100682: POP
100683: POP
// end ;
100684: LD_VAR 0 3
100688: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100689: LD_INT 0
100691: PPUSH
// if not side or side > 8 then
100692: LD_VAR 0 3
100696: NOT
100697: PUSH
100698: LD_VAR 0 3
100702: PUSH
100703: LD_INT 8
100705: GREATER
100706: OR
100707: IFFALSE 100711
// exit ;
100709: GO 100770
// if not range then
100711: LD_VAR 0 4
100715: NOT
100716: IFFALSE 100727
// range := - 12 ;
100718: LD_ADDR_VAR 0 4
100722: PUSH
100723: LD_INT 12
100725: NEG
100726: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100727: LD_VAR 0 1
100731: PPUSH
100732: LD_VAR 0 2
100736: PPUSH
100737: LD_VAR 0 3
100741: PPUSH
100742: LD_VAR 0 4
100746: PPUSH
100747: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100751: LD_VAR 0 1
100755: PPUSH
100756: LD_VAR 0 2
100760: PPUSH
100761: LD_VAR 0 3
100765: PPUSH
100766: CALL_OW 331
// end ;
100770: LD_VAR 0 5
100774: RET
// export function Video ( mode ) ; begin
100775: LD_INT 0
100777: PPUSH
// ingame_video = mode ;
100778: LD_ADDR_OWVAR 52
100782: PUSH
100783: LD_VAR 0 1
100787: ST_TO_ADDR
// interface_hidden = mode ;
100788: LD_ADDR_OWVAR 54
100792: PUSH
100793: LD_VAR 0 1
100797: ST_TO_ADDR
// end ;
100798: LD_VAR 0 2
100802: RET
// export function Join ( array , element ) ; begin
100803: LD_INT 0
100805: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100806: LD_ADDR_VAR 0 3
100810: PUSH
100811: LD_VAR 0 1
100815: PPUSH
100816: LD_VAR 0 1
100820: PUSH
100821: LD_INT 1
100823: PLUS
100824: PPUSH
100825: LD_VAR 0 2
100829: PPUSH
100830: CALL_OW 1
100834: ST_TO_ADDR
// end ;
100835: LD_VAR 0 3
100839: RET
// export function JoinUnion ( array , element ) ; begin
100840: LD_INT 0
100842: PPUSH
// result := array union element ;
100843: LD_ADDR_VAR 0 3
100847: PUSH
100848: LD_VAR 0 1
100852: PUSH
100853: LD_VAR 0 2
100857: UNION
100858: ST_TO_ADDR
// end ;
100859: LD_VAR 0 3
100863: RET
// export function GetBehemoths ( side ) ; begin
100864: LD_INT 0
100866: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
100867: LD_ADDR_VAR 0 2
100871: PUSH
100872: LD_INT 22
100874: PUSH
100875: LD_VAR 0 1
100879: PUSH
100880: EMPTY
100881: LIST
100882: LIST
100883: PUSH
100884: LD_INT 31
100886: PUSH
100887: LD_INT 25
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PUSH
100894: EMPTY
100895: LIST
100896: LIST
100897: PPUSH
100898: CALL_OW 69
100902: ST_TO_ADDR
// end ;
100903: LD_VAR 0 2
100907: RET
// export function Shuffle ( array ) ; var i , index ; begin
100908: LD_INT 0
100910: PPUSH
100911: PPUSH
100912: PPUSH
// result := [ ] ;
100913: LD_ADDR_VAR 0 2
100917: PUSH
100918: EMPTY
100919: ST_TO_ADDR
// if not array then
100920: LD_VAR 0 1
100924: NOT
100925: IFFALSE 100929
// exit ;
100927: GO 101028
// Randomize ;
100929: CALL_OW 10
// for i = array downto 1 do
100933: LD_ADDR_VAR 0 3
100937: PUSH
100938: DOUBLE
100939: LD_VAR 0 1
100943: INC
100944: ST_TO_ADDR
100945: LD_INT 1
100947: PUSH
100948: FOR_DOWNTO
100949: IFFALSE 101026
// begin index := rand ( 1 , array ) ;
100951: LD_ADDR_VAR 0 4
100955: PUSH
100956: LD_INT 1
100958: PPUSH
100959: LD_VAR 0 1
100963: PPUSH
100964: CALL_OW 12
100968: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
100969: LD_ADDR_VAR 0 2
100973: PUSH
100974: LD_VAR 0 2
100978: PPUSH
100979: LD_VAR 0 2
100983: PUSH
100984: LD_INT 1
100986: PLUS
100987: PPUSH
100988: LD_VAR 0 1
100992: PUSH
100993: LD_VAR 0 4
100997: ARRAY
100998: PPUSH
100999: CALL_OW 2
101003: ST_TO_ADDR
// array := Delete ( array , index ) ;
101004: LD_ADDR_VAR 0 1
101008: PUSH
101009: LD_VAR 0 1
101013: PPUSH
101014: LD_VAR 0 4
101018: PPUSH
101019: CALL_OW 3
101023: ST_TO_ADDR
// end ;
101024: GO 100948
101026: POP
101027: POP
// end ;
101028: LD_VAR 0 2
101032: RET
// export function GetBaseMaterials ( base ) ; begin
101033: LD_INT 0
101035: PPUSH
// result := [ 0 , 0 , 0 ] ;
101036: LD_ADDR_VAR 0 2
101040: PUSH
101041: LD_INT 0
101043: PUSH
101044: LD_INT 0
101046: PUSH
101047: LD_INT 0
101049: PUSH
101050: EMPTY
101051: LIST
101052: LIST
101053: LIST
101054: ST_TO_ADDR
// if not base then
101055: LD_VAR 0 1
101059: NOT
101060: IFFALSE 101064
// exit ;
101062: GO 101113
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101064: LD_ADDR_VAR 0 2
101068: PUSH
101069: LD_VAR 0 1
101073: PPUSH
101074: LD_INT 1
101076: PPUSH
101077: CALL_OW 275
101081: PUSH
101082: LD_VAR 0 1
101086: PPUSH
101087: LD_INT 2
101089: PPUSH
101090: CALL_OW 275
101094: PUSH
101095: LD_VAR 0 1
101099: PPUSH
101100: LD_INT 3
101102: PPUSH
101103: CALL_OW 275
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: LIST
101112: ST_TO_ADDR
// end ;
101113: LD_VAR 0 2
101117: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101118: LD_INT 0
101120: PPUSH
101121: PPUSH
// result := array ;
101122: LD_ADDR_VAR 0 3
101126: PUSH
101127: LD_VAR 0 1
101131: ST_TO_ADDR
// if size >= result then
101132: LD_VAR 0 2
101136: PUSH
101137: LD_VAR 0 3
101141: GREATEREQUAL
101142: IFFALSE 101146
// exit ;
101144: GO 101196
// if size then
101146: LD_VAR 0 2
101150: IFFALSE 101196
// for i := array downto size do
101152: LD_ADDR_VAR 0 4
101156: PUSH
101157: DOUBLE
101158: LD_VAR 0 1
101162: INC
101163: ST_TO_ADDR
101164: LD_VAR 0 2
101168: PUSH
101169: FOR_DOWNTO
101170: IFFALSE 101194
// result := Delete ( result , result ) ;
101172: LD_ADDR_VAR 0 3
101176: PUSH
101177: LD_VAR 0 3
101181: PPUSH
101182: LD_VAR 0 3
101186: PPUSH
101187: CALL_OW 3
101191: ST_TO_ADDR
101192: GO 101169
101194: POP
101195: POP
// end ;
101196: LD_VAR 0 3
101200: RET
// export function ComExit ( unit ) ; var tmp ; begin
101201: LD_INT 0
101203: PPUSH
101204: PPUSH
// if not IsInUnit ( unit ) then
101205: LD_VAR 0 1
101209: PPUSH
101210: CALL_OW 310
101214: NOT
101215: IFFALSE 101219
// exit ;
101217: GO 101279
// tmp := IsInUnit ( unit ) ;
101219: LD_ADDR_VAR 0 3
101223: PUSH
101224: LD_VAR 0 1
101228: PPUSH
101229: CALL_OW 310
101233: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101234: LD_VAR 0 3
101238: PPUSH
101239: CALL_OW 247
101243: PUSH
101244: LD_INT 2
101246: EQUAL
101247: IFFALSE 101260
// ComExitVehicle ( unit ) else
101249: LD_VAR 0 1
101253: PPUSH
101254: CALL_OW 121
101258: GO 101269
// ComExitBuilding ( unit ) ;
101260: LD_VAR 0 1
101264: PPUSH
101265: CALL_OW 122
// result := tmp ;
101269: LD_ADDR_VAR 0 2
101273: PUSH
101274: LD_VAR 0 3
101278: ST_TO_ADDR
// end ;
101279: LD_VAR 0 2
101283: RET
// export function ComExitAll ( units ) ; var i ; begin
101284: LD_INT 0
101286: PPUSH
101287: PPUSH
// if not units then
101288: LD_VAR 0 1
101292: NOT
101293: IFFALSE 101297
// exit ;
101295: GO 101323
// for i in units do
101297: LD_ADDR_VAR 0 3
101301: PUSH
101302: LD_VAR 0 1
101306: PUSH
101307: FOR_IN
101308: IFFALSE 101321
// ComExit ( i ) ;
101310: LD_VAR 0 3
101314: PPUSH
101315: CALL 101201 0 1
101319: GO 101307
101321: POP
101322: POP
// end ;
101323: LD_VAR 0 2
101327: RET
// export function ResetHc ; begin
101328: LD_INT 0
101330: PPUSH
// InitHc ;
101331: CALL_OW 19
// hc_importance := 0 ;
101335: LD_ADDR_OWVAR 32
101339: PUSH
101340: LD_INT 0
101342: ST_TO_ADDR
// end ;
101343: LD_VAR 0 1
101347: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101348: LD_INT 0
101350: PPUSH
101351: PPUSH
101352: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101353: LD_ADDR_VAR 0 6
101357: PUSH
101358: LD_VAR 0 1
101362: PUSH
101363: LD_VAR 0 3
101367: PLUS
101368: PUSH
101369: LD_INT 2
101371: DIV
101372: ST_TO_ADDR
// if _x < 0 then
101373: LD_VAR 0 6
101377: PUSH
101378: LD_INT 0
101380: LESS
101381: IFFALSE 101398
// _x := _x * - 1 ;
101383: LD_ADDR_VAR 0 6
101387: PUSH
101388: LD_VAR 0 6
101392: PUSH
101393: LD_INT 1
101395: NEG
101396: MUL
101397: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101398: LD_ADDR_VAR 0 7
101402: PUSH
101403: LD_VAR 0 2
101407: PUSH
101408: LD_VAR 0 4
101412: PLUS
101413: PUSH
101414: LD_INT 2
101416: DIV
101417: ST_TO_ADDR
// if _y < 0 then
101418: LD_VAR 0 7
101422: PUSH
101423: LD_INT 0
101425: LESS
101426: IFFALSE 101443
// _y := _y * - 1 ;
101428: LD_ADDR_VAR 0 7
101432: PUSH
101433: LD_VAR 0 7
101437: PUSH
101438: LD_INT 1
101440: NEG
101441: MUL
101442: ST_TO_ADDR
// result := [ _x , _y ] ;
101443: LD_ADDR_VAR 0 5
101447: PUSH
101448: LD_VAR 0 6
101452: PUSH
101453: LD_VAR 0 7
101457: PUSH
101458: EMPTY
101459: LIST
101460: LIST
101461: ST_TO_ADDR
// end ;
101462: LD_VAR 0 5
101466: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101467: LD_INT 0
101469: PPUSH
101470: PPUSH
101471: PPUSH
101472: PPUSH
// task := GetTaskList ( unit ) ;
101473: LD_ADDR_VAR 0 7
101477: PUSH
101478: LD_VAR 0 1
101482: PPUSH
101483: CALL_OW 437
101487: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101488: LD_VAR 0 7
101492: NOT
101493: PUSH
101494: LD_VAR 0 1
101498: PPUSH
101499: LD_VAR 0 2
101503: PPUSH
101504: CALL_OW 308
101508: NOT
101509: AND
101510: IFFALSE 101514
// exit ;
101512: GO 101632
// if IsInArea ( unit , area ) then
101514: LD_VAR 0 1
101518: PPUSH
101519: LD_VAR 0 2
101523: PPUSH
101524: CALL_OW 308
101528: IFFALSE 101546
// begin ComMoveToArea ( unit , goAway ) ;
101530: LD_VAR 0 1
101534: PPUSH
101535: LD_VAR 0 3
101539: PPUSH
101540: CALL_OW 113
// exit ;
101544: GO 101632
// end ; if task [ 1 ] [ 1 ] <> M then
101546: LD_VAR 0 7
101550: PUSH
101551: LD_INT 1
101553: ARRAY
101554: PUSH
101555: LD_INT 1
101557: ARRAY
101558: PUSH
101559: LD_STRING M
101561: NONEQUAL
101562: IFFALSE 101566
// exit ;
101564: GO 101632
// x := task [ 1 ] [ 2 ] ;
101566: LD_ADDR_VAR 0 5
101570: PUSH
101571: LD_VAR 0 7
101575: PUSH
101576: LD_INT 1
101578: ARRAY
101579: PUSH
101580: LD_INT 2
101582: ARRAY
101583: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101584: LD_ADDR_VAR 0 6
101588: PUSH
101589: LD_VAR 0 7
101593: PUSH
101594: LD_INT 1
101596: ARRAY
101597: PUSH
101598: LD_INT 3
101600: ARRAY
101601: ST_TO_ADDR
// if InArea ( x , y , area ) then
101602: LD_VAR 0 5
101606: PPUSH
101607: LD_VAR 0 6
101611: PPUSH
101612: LD_VAR 0 2
101616: PPUSH
101617: CALL_OW 309
101621: IFFALSE 101632
// ComStop ( unit ) ;
101623: LD_VAR 0 1
101627: PPUSH
101628: CALL_OW 141
// end ;
101632: LD_VAR 0 4
101636: RET
// export function Abs ( value ) ; begin
101637: LD_INT 0
101639: PPUSH
// result := value ;
101640: LD_ADDR_VAR 0 2
101644: PUSH
101645: LD_VAR 0 1
101649: ST_TO_ADDR
// if value < 0 then
101650: LD_VAR 0 1
101654: PUSH
101655: LD_INT 0
101657: LESS
101658: IFFALSE 101675
// result := value * - 1 ;
101660: LD_ADDR_VAR 0 2
101664: PUSH
101665: LD_VAR 0 1
101669: PUSH
101670: LD_INT 1
101672: NEG
101673: MUL
101674: ST_TO_ADDR
// end ;
101675: LD_VAR 0 2
101679: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101680: LD_INT 0
101682: PPUSH
101683: PPUSH
101684: PPUSH
101685: PPUSH
101686: PPUSH
101687: PPUSH
101688: PPUSH
101689: PPUSH
// if not unit or not building then
101690: LD_VAR 0 1
101694: NOT
101695: PUSH
101696: LD_VAR 0 2
101700: NOT
101701: OR
101702: IFFALSE 101706
// exit ;
101704: GO 101932
// x := GetX ( building ) ;
101706: LD_ADDR_VAR 0 4
101710: PUSH
101711: LD_VAR 0 2
101715: PPUSH
101716: CALL_OW 250
101720: ST_TO_ADDR
// y := GetY ( building ) ;
101721: LD_ADDR_VAR 0 6
101725: PUSH
101726: LD_VAR 0 2
101730: PPUSH
101731: CALL_OW 251
101735: ST_TO_ADDR
// d := GetDir ( building ) ;
101736: LD_ADDR_VAR 0 8
101740: PUSH
101741: LD_VAR 0 2
101745: PPUSH
101746: CALL_OW 254
101750: ST_TO_ADDR
// r := 4 ;
101751: LD_ADDR_VAR 0 9
101755: PUSH
101756: LD_INT 4
101758: ST_TO_ADDR
// for i := 1 to 5 do
101759: LD_ADDR_VAR 0 10
101763: PUSH
101764: DOUBLE
101765: LD_INT 1
101767: DEC
101768: ST_TO_ADDR
101769: LD_INT 5
101771: PUSH
101772: FOR_TO
101773: IFFALSE 101930
// begin _x := ShiftX ( x , d , r + i ) ;
101775: LD_ADDR_VAR 0 5
101779: PUSH
101780: LD_VAR 0 4
101784: PPUSH
101785: LD_VAR 0 8
101789: PPUSH
101790: LD_VAR 0 9
101794: PUSH
101795: LD_VAR 0 10
101799: PLUS
101800: PPUSH
101801: CALL_OW 272
101805: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
101806: LD_ADDR_VAR 0 7
101810: PUSH
101811: LD_VAR 0 6
101815: PPUSH
101816: LD_VAR 0 8
101820: PPUSH
101821: LD_VAR 0 9
101825: PUSH
101826: LD_VAR 0 10
101830: PLUS
101831: PPUSH
101832: CALL_OW 273
101836: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
101837: LD_VAR 0 5
101841: PPUSH
101842: LD_VAR 0 7
101846: PPUSH
101847: CALL_OW 488
101851: PUSH
101852: LD_VAR 0 5
101856: PPUSH
101857: LD_VAR 0 7
101861: PPUSH
101862: CALL_OW 428
101866: PPUSH
101867: CALL_OW 247
101871: PUSH
101872: LD_INT 3
101874: PUSH
101875: LD_INT 2
101877: PUSH
101878: EMPTY
101879: LIST
101880: LIST
101881: IN
101882: NOT
101883: AND
101884: IFFALSE 101928
// begin ComMoveXY ( unit , _x , _y ) ;
101886: LD_VAR 0 1
101890: PPUSH
101891: LD_VAR 0 5
101895: PPUSH
101896: LD_VAR 0 7
101900: PPUSH
101901: CALL_OW 111
// result := [ _x , _y ] ;
101905: LD_ADDR_VAR 0 3
101909: PUSH
101910: LD_VAR 0 5
101914: PUSH
101915: LD_VAR 0 7
101919: PUSH
101920: EMPTY
101921: LIST
101922: LIST
101923: ST_TO_ADDR
// exit ;
101924: POP
101925: POP
101926: GO 101932
// end ; end ;
101928: GO 101772
101930: POP
101931: POP
// end ;
101932: LD_VAR 0 3
101936: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
101937: LD_INT 0
101939: PPUSH
101940: PPUSH
101941: PPUSH
// result := 0 ;
101942: LD_ADDR_VAR 0 3
101946: PUSH
101947: LD_INT 0
101949: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
101950: LD_VAR 0 1
101954: PUSH
101955: LD_INT 0
101957: LESS
101958: PUSH
101959: LD_VAR 0 1
101963: PUSH
101964: LD_INT 8
101966: GREATER
101967: OR
101968: PUSH
101969: LD_VAR 0 2
101973: PUSH
101974: LD_INT 0
101976: LESS
101977: OR
101978: PUSH
101979: LD_VAR 0 2
101983: PUSH
101984: LD_INT 8
101986: GREATER
101987: OR
101988: IFFALSE 101992
// exit ;
101990: GO 102067
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
101992: LD_ADDR_VAR 0 4
101996: PUSH
101997: LD_INT 22
101999: PUSH
102000: LD_VAR 0 2
102004: PUSH
102005: EMPTY
102006: LIST
102007: LIST
102008: PPUSH
102009: CALL_OW 69
102013: PUSH
102014: FOR_IN
102015: IFFALSE 102065
// begin un := UnitShoot ( i ) ;
102017: LD_ADDR_VAR 0 5
102021: PUSH
102022: LD_VAR 0 4
102026: PPUSH
102027: CALL_OW 504
102031: ST_TO_ADDR
// if GetSide ( un ) = side1 then
102032: LD_VAR 0 5
102036: PPUSH
102037: CALL_OW 255
102041: PUSH
102042: LD_VAR 0 1
102046: EQUAL
102047: IFFALSE 102063
// begin result := un ;
102049: LD_ADDR_VAR 0 3
102053: PUSH
102054: LD_VAR 0 5
102058: ST_TO_ADDR
// exit ;
102059: POP
102060: POP
102061: GO 102067
// end ; end ;
102063: GO 102014
102065: POP
102066: POP
// end ;
102067: LD_VAR 0 3
102071: RET
// export function GetCargoBay ( units ) ; begin
102072: LD_INT 0
102074: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
102075: LD_ADDR_VAR 0 2
102079: PUSH
102080: LD_VAR 0 1
102084: PPUSH
102085: LD_INT 2
102087: PUSH
102088: LD_INT 34
102090: PUSH
102091: LD_INT 12
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: LD_INT 34
102100: PUSH
102101: LD_INT 51
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PUSH
102108: LD_INT 34
102110: PUSH
102111: LD_INT 32
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: PUSH
102118: LD_INT 34
102120: PUSH
102121: LD_EXP 74
102125: PUSH
102126: EMPTY
102127: LIST
102128: LIST
102129: PUSH
102130: EMPTY
102131: LIST
102132: LIST
102133: LIST
102134: LIST
102135: LIST
102136: PPUSH
102137: CALL_OW 72
102141: ST_TO_ADDR
// end ;
102142: LD_VAR 0 2
102146: RET
// export function Negate ( value ) ; begin
102147: LD_INT 0
102149: PPUSH
// result := not value ;
102150: LD_ADDR_VAR 0 2
102154: PUSH
102155: LD_VAR 0 1
102159: NOT
102160: ST_TO_ADDR
// end ;
102161: LD_VAR 0 2
102165: RET
// export function Inc ( value ) ; begin
102166: LD_INT 0
102168: PPUSH
// result := value + 1 ;
102169: LD_ADDR_VAR 0 2
102173: PUSH
102174: LD_VAR 0 1
102178: PUSH
102179: LD_INT 1
102181: PLUS
102182: ST_TO_ADDR
// end ;
102183: LD_VAR 0 2
102187: RET
// export function Dec ( value ) ; begin
102188: LD_INT 0
102190: PPUSH
// result := value - 1 ;
102191: LD_ADDR_VAR 0 2
102195: PUSH
102196: LD_VAR 0 1
102200: PUSH
102201: LD_INT 1
102203: MINUS
102204: ST_TO_ADDR
// end ;
102205: LD_VAR 0 2
102209: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
102210: LD_INT 0
102212: PPUSH
102213: PPUSH
102214: PPUSH
102215: PPUSH
102216: PPUSH
102217: PPUSH
102218: PPUSH
102219: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102220: LD_VAR 0 1
102224: PPUSH
102225: LD_VAR 0 2
102229: PPUSH
102230: CALL_OW 488
102234: NOT
102235: PUSH
102236: LD_VAR 0 3
102240: PPUSH
102241: LD_VAR 0 4
102245: PPUSH
102246: CALL_OW 488
102250: NOT
102251: OR
102252: IFFALSE 102265
// begin result := - 1 ;
102254: LD_ADDR_VAR 0 5
102258: PUSH
102259: LD_INT 1
102261: NEG
102262: ST_TO_ADDR
// exit ;
102263: GO 102500
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102265: LD_ADDR_VAR 0 12
102269: PUSH
102270: LD_VAR 0 1
102274: PPUSH
102275: LD_VAR 0 2
102279: PPUSH
102280: LD_VAR 0 3
102284: PPUSH
102285: LD_VAR 0 4
102289: PPUSH
102290: CALL 101348 0 4
102294: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102295: LD_ADDR_VAR 0 11
102299: PUSH
102300: LD_VAR 0 1
102304: PPUSH
102305: LD_VAR 0 2
102309: PPUSH
102310: LD_VAR 0 12
102314: PUSH
102315: LD_INT 1
102317: ARRAY
102318: PPUSH
102319: LD_VAR 0 12
102323: PUSH
102324: LD_INT 2
102326: ARRAY
102327: PPUSH
102328: CALL_OW 298
102332: ST_TO_ADDR
// distance := 9999 ;
102333: LD_ADDR_VAR 0 10
102337: PUSH
102338: LD_INT 9999
102340: ST_TO_ADDR
// for i := 0 to 5 do
102341: LD_ADDR_VAR 0 6
102345: PUSH
102346: DOUBLE
102347: LD_INT 0
102349: DEC
102350: ST_TO_ADDR
102351: LD_INT 5
102353: PUSH
102354: FOR_TO
102355: IFFALSE 102498
// begin _x := ShiftX ( x1 , i , centerDist ) ;
102357: LD_ADDR_VAR 0 7
102361: PUSH
102362: LD_VAR 0 1
102366: PPUSH
102367: LD_VAR 0 6
102371: PPUSH
102372: LD_VAR 0 11
102376: PPUSH
102377: CALL_OW 272
102381: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
102382: LD_ADDR_VAR 0 8
102386: PUSH
102387: LD_VAR 0 2
102391: PPUSH
102392: LD_VAR 0 6
102396: PPUSH
102397: LD_VAR 0 11
102401: PPUSH
102402: CALL_OW 273
102406: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102407: LD_VAR 0 7
102411: PPUSH
102412: LD_VAR 0 8
102416: PPUSH
102417: CALL_OW 488
102421: NOT
102422: IFFALSE 102426
// continue ;
102424: GO 102354
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
102426: LD_ADDR_VAR 0 9
102430: PUSH
102431: LD_VAR 0 12
102435: PUSH
102436: LD_INT 1
102438: ARRAY
102439: PPUSH
102440: LD_VAR 0 12
102444: PUSH
102445: LD_INT 2
102447: ARRAY
102448: PPUSH
102449: LD_VAR 0 7
102453: PPUSH
102454: LD_VAR 0 8
102458: PPUSH
102459: CALL_OW 298
102463: ST_TO_ADDR
// if tmp < distance then
102464: LD_VAR 0 9
102468: PUSH
102469: LD_VAR 0 10
102473: LESS
102474: IFFALSE 102496
// begin result := i ;
102476: LD_ADDR_VAR 0 5
102480: PUSH
102481: LD_VAR 0 6
102485: ST_TO_ADDR
// distance := tmp ;
102486: LD_ADDR_VAR 0 10
102490: PUSH
102491: LD_VAR 0 9
102495: ST_TO_ADDR
// end ; end ;
102496: GO 102354
102498: POP
102499: POP
// end ;
102500: LD_VAR 0 5
102504: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102505: LD_INT 0
102507: PPUSH
102508: PPUSH
// if not driver or not IsInUnit ( driver ) then
102509: LD_VAR 0 1
102513: NOT
102514: PUSH
102515: LD_VAR 0 1
102519: PPUSH
102520: CALL_OW 310
102524: NOT
102525: OR
102526: IFFALSE 102530
// exit ;
102528: GO 102620
// vehicle := IsInUnit ( driver ) ;
102530: LD_ADDR_VAR 0 3
102534: PUSH
102535: LD_VAR 0 1
102539: PPUSH
102540: CALL_OW 310
102544: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102545: LD_VAR 0 1
102549: PPUSH
102550: LD_STRING \
102552: PUSH
102553: LD_INT 0
102555: PUSH
102556: LD_INT 0
102558: PUSH
102559: LD_INT 0
102561: PUSH
102562: LD_INT 0
102564: PUSH
102565: LD_INT 0
102567: PUSH
102568: LD_INT 0
102570: PUSH
102571: EMPTY
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: LIST
102578: LIST
102579: PUSH
102580: LD_STRING E
102582: PUSH
102583: LD_INT 0
102585: PUSH
102586: LD_INT 0
102588: PUSH
102589: LD_VAR 0 3
102593: PUSH
102594: LD_INT 0
102596: PUSH
102597: LD_INT 0
102599: PUSH
102600: LD_INT 0
102602: PUSH
102603: EMPTY
102604: LIST
102605: LIST
102606: LIST
102607: LIST
102608: LIST
102609: LIST
102610: LIST
102611: PUSH
102612: EMPTY
102613: LIST
102614: LIST
102615: PPUSH
102616: CALL_OW 446
// end ;
102620: LD_VAR 0 2
102624: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102625: LD_INT 0
102627: PPUSH
102628: PPUSH
// if not driver or not IsInUnit ( driver ) then
102629: LD_VAR 0 1
102633: NOT
102634: PUSH
102635: LD_VAR 0 1
102639: PPUSH
102640: CALL_OW 310
102644: NOT
102645: OR
102646: IFFALSE 102650
// exit ;
102648: GO 102740
// vehicle := IsInUnit ( driver ) ;
102650: LD_ADDR_VAR 0 3
102654: PUSH
102655: LD_VAR 0 1
102659: PPUSH
102660: CALL_OW 310
102664: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102665: LD_VAR 0 1
102669: PPUSH
102670: LD_STRING \
102672: PUSH
102673: LD_INT 0
102675: PUSH
102676: LD_INT 0
102678: PUSH
102679: LD_INT 0
102681: PUSH
102682: LD_INT 0
102684: PUSH
102685: LD_INT 0
102687: PUSH
102688: LD_INT 0
102690: PUSH
102691: EMPTY
102692: LIST
102693: LIST
102694: LIST
102695: LIST
102696: LIST
102697: LIST
102698: LIST
102699: PUSH
102700: LD_STRING E
102702: PUSH
102703: LD_INT 0
102705: PUSH
102706: LD_INT 0
102708: PUSH
102709: LD_VAR 0 3
102713: PUSH
102714: LD_INT 0
102716: PUSH
102717: LD_INT 0
102719: PUSH
102720: LD_INT 0
102722: PUSH
102723: EMPTY
102724: LIST
102725: LIST
102726: LIST
102727: LIST
102728: LIST
102729: LIST
102730: LIST
102731: PUSH
102732: EMPTY
102733: LIST
102734: LIST
102735: PPUSH
102736: CALL_OW 447
// end ;
102740: LD_VAR 0 2
102744: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
102745: LD_INT 0
102747: PPUSH
102748: PPUSH
102749: PPUSH
// tmp := [ ] ;
102750: LD_ADDR_VAR 0 5
102754: PUSH
102755: EMPTY
102756: ST_TO_ADDR
// for i in units do
102757: LD_ADDR_VAR 0 4
102761: PUSH
102762: LD_VAR 0 1
102766: PUSH
102767: FOR_IN
102768: IFFALSE 102806
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
102770: LD_ADDR_VAR 0 5
102774: PUSH
102775: LD_VAR 0 5
102779: PPUSH
102780: LD_VAR 0 5
102784: PUSH
102785: LD_INT 1
102787: PLUS
102788: PPUSH
102789: LD_VAR 0 4
102793: PPUSH
102794: CALL_OW 256
102798: PPUSH
102799: CALL_OW 2
102803: ST_TO_ADDR
102804: GO 102767
102806: POP
102807: POP
// if not tmp then
102808: LD_VAR 0 5
102812: NOT
102813: IFFALSE 102817
// exit ;
102815: GO 102865
// if asc then
102817: LD_VAR 0 2
102821: IFFALSE 102845
// result := SortListByListAsc ( units , tmp ) else
102823: LD_ADDR_VAR 0 3
102827: PUSH
102828: LD_VAR 0 1
102832: PPUSH
102833: LD_VAR 0 5
102837: PPUSH
102838: CALL_OW 76
102842: ST_TO_ADDR
102843: GO 102865
// result := SortListByListDesc ( units , tmp ) ;
102845: LD_ADDR_VAR 0 3
102849: PUSH
102850: LD_VAR 0 1
102854: PPUSH
102855: LD_VAR 0 5
102859: PPUSH
102860: CALL_OW 77
102864: ST_TO_ADDR
// end ;
102865: LD_VAR 0 3
102869: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
102870: LD_INT 0
102872: PPUSH
102873: PPUSH
// task := GetTaskList ( mech ) ;
102874: LD_ADDR_VAR 0 4
102878: PUSH
102879: LD_VAR 0 1
102883: PPUSH
102884: CALL_OW 437
102888: ST_TO_ADDR
// if not task then
102889: LD_VAR 0 4
102893: NOT
102894: IFFALSE 102898
// exit ;
102896: GO 102940
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
102898: LD_ADDR_VAR 0 3
102902: PUSH
102903: LD_VAR 0 4
102907: PUSH
102908: LD_INT 1
102910: ARRAY
102911: PUSH
102912: LD_INT 1
102914: ARRAY
102915: PUSH
102916: LD_STRING r
102918: EQUAL
102919: PUSH
102920: LD_VAR 0 4
102924: PUSH
102925: LD_INT 1
102927: ARRAY
102928: PUSH
102929: LD_INT 4
102931: ARRAY
102932: PUSH
102933: LD_VAR 0 2
102937: EQUAL
102938: AND
102939: ST_TO_ADDR
// end ;
102940: LD_VAR 0 3
102944: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
102945: LD_INT 0
102947: PPUSH
// SetDir ( unit , d ) ;
102948: LD_VAR 0 1
102952: PPUSH
102953: LD_VAR 0 4
102957: PPUSH
102958: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
102962: LD_VAR 0 1
102966: PPUSH
102967: LD_VAR 0 2
102971: PPUSH
102972: LD_VAR 0 3
102976: PPUSH
102977: LD_VAR 0 5
102981: PPUSH
102982: CALL_OW 48
// end ;
102986: LD_VAR 0 6
102990: RET
// export function ToNaturalNumber ( number ) ; begin
102991: LD_INT 0
102993: PPUSH
// result := number div 1 ;
102994: LD_ADDR_VAR 0 2
102998: PUSH
102999: LD_VAR 0 1
103003: PUSH
103004: LD_INT 1
103006: DIV
103007: ST_TO_ADDR
// if number < 0 then
103008: LD_VAR 0 1
103012: PUSH
103013: LD_INT 0
103015: LESS
103016: IFFALSE 103026
// result := 0 ;
103018: LD_ADDR_VAR 0 2
103022: PUSH
103023: LD_INT 0
103025: ST_TO_ADDR
// end ;
103026: LD_VAR 0 2
103030: RET
// export function SortByClass ( units , class ) ; var un ; begin
103031: LD_INT 0
103033: PPUSH
103034: PPUSH
// if not units or not class then
103035: LD_VAR 0 1
103039: NOT
103040: PUSH
103041: LD_VAR 0 2
103045: NOT
103046: OR
103047: IFFALSE 103051
// exit ;
103049: GO 103146
// result := [ ] ;
103051: LD_ADDR_VAR 0 3
103055: PUSH
103056: EMPTY
103057: ST_TO_ADDR
// for un in units do
103058: LD_ADDR_VAR 0 4
103062: PUSH
103063: LD_VAR 0 1
103067: PUSH
103068: FOR_IN
103069: IFFALSE 103144
// if GetClass ( un ) = class then
103071: LD_VAR 0 4
103075: PPUSH
103076: CALL_OW 257
103080: PUSH
103081: LD_VAR 0 2
103085: EQUAL
103086: IFFALSE 103113
// result := Insert ( result , 1 , un ) else
103088: LD_ADDR_VAR 0 3
103092: PUSH
103093: LD_VAR 0 3
103097: PPUSH
103098: LD_INT 1
103100: PPUSH
103101: LD_VAR 0 4
103105: PPUSH
103106: CALL_OW 2
103110: ST_TO_ADDR
103111: GO 103142
// result := Replace ( result , result + 1 , un ) ;
103113: LD_ADDR_VAR 0 3
103117: PUSH
103118: LD_VAR 0 3
103122: PPUSH
103123: LD_VAR 0 3
103127: PUSH
103128: LD_INT 1
103130: PLUS
103131: PPUSH
103132: LD_VAR 0 4
103136: PPUSH
103137: CALL_OW 1
103141: ST_TO_ADDR
103142: GO 103068
103144: POP
103145: POP
// end ;
103146: LD_VAR 0 3
103150: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
103151: LD_INT 0
103153: PPUSH
103154: PPUSH
103155: PPUSH
103156: PPUSH
103157: PPUSH
103158: PPUSH
103159: PPUSH
// result := [ ] ;
103160: LD_ADDR_VAR 0 4
103164: PUSH
103165: EMPTY
103166: ST_TO_ADDR
// if x - r < 0 then
103167: LD_VAR 0 1
103171: PUSH
103172: LD_VAR 0 3
103176: MINUS
103177: PUSH
103178: LD_INT 0
103180: LESS
103181: IFFALSE 103193
// min_x := 0 else
103183: LD_ADDR_VAR 0 8
103187: PUSH
103188: LD_INT 0
103190: ST_TO_ADDR
103191: GO 103209
// min_x := x - r ;
103193: LD_ADDR_VAR 0 8
103197: PUSH
103198: LD_VAR 0 1
103202: PUSH
103203: LD_VAR 0 3
103207: MINUS
103208: ST_TO_ADDR
// if y - r < 0 then
103209: LD_VAR 0 2
103213: PUSH
103214: LD_VAR 0 3
103218: MINUS
103219: PUSH
103220: LD_INT 0
103222: LESS
103223: IFFALSE 103235
// min_y := 0 else
103225: LD_ADDR_VAR 0 7
103229: PUSH
103230: LD_INT 0
103232: ST_TO_ADDR
103233: GO 103251
// min_y := y - r ;
103235: LD_ADDR_VAR 0 7
103239: PUSH
103240: LD_VAR 0 2
103244: PUSH
103245: LD_VAR 0 3
103249: MINUS
103250: ST_TO_ADDR
// max_x := x + r ;
103251: LD_ADDR_VAR 0 9
103255: PUSH
103256: LD_VAR 0 1
103260: PUSH
103261: LD_VAR 0 3
103265: PLUS
103266: ST_TO_ADDR
// max_y := y + r ;
103267: LD_ADDR_VAR 0 10
103271: PUSH
103272: LD_VAR 0 2
103276: PUSH
103277: LD_VAR 0 3
103281: PLUS
103282: ST_TO_ADDR
// for _x = min_x to max_x do
103283: LD_ADDR_VAR 0 5
103287: PUSH
103288: DOUBLE
103289: LD_VAR 0 8
103293: DEC
103294: ST_TO_ADDR
103295: LD_VAR 0 9
103299: PUSH
103300: FOR_TO
103301: IFFALSE 103402
// for _y = min_y to max_y do
103303: LD_ADDR_VAR 0 6
103307: PUSH
103308: DOUBLE
103309: LD_VAR 0 7
103313: DEC
103314: ST_TO_ADDR
103315: LD_VAR 0 10
103319: PUSH
103320: FOR_TO
103321: IFFALSE 103398
// begin if not ValidHex ( _x , _y ) then
103323: LD_VAR 0 5
103327: PPUSH
103328: LD_VAR 0 6
103332: PPUSH
103333: CALL_OW 488
103337: NOT
103338: IFFALSE 103342
// continue ;
103340: GO 103320
// if GetResourceTypeXY ( _x , _y ) then
103342: LD_VAR 0 5
103346: PPUSH
103347: LD_VAR 0 6
103351: PPUSH
103352: CALL_OW 283
103356: IFFALSE 103396
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
103358: LD_ADDR_VAR 0 4
103362: PUSH
103363: LD_VAR 0 4
103367: PPUSH
103368: LD_VAR 0 4
103372: PUSH
103373: LD_INT 1
103375: PLUS
103376: PPUSH
103377: LD_VAR 0 5
103381: PUSH
103382: LD_VAR 0 6
103386: PUSH
103387: EMPTY
103388: LIST
103389: LIST
103390: PPUSH
103391: CALL_OW 1
103395: ST_TO_ADDR
// end ;
103396: GO 103320
103398: POP
103399: POP
103400: GO 103300
103402: POP
103403: POP
// end ;
103404: LD_VAR 0 4
103408: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
103409: LD_INT 0
103411: PPUSH
103412: PPUSH
103413: PPUSH
103414: PPUSH
103415: PPUSH
103416: PPUSH
103417: PPUSH
103418: PPUSH
// if not units then
103419: LD_VAR 0 1
103423: NOT
103424: IFFALSE 103428
// exit ;
103426: GO 103954
// result := UnitFilter ( units , [ f_ok ] ) ;
103428: LD_ADDR_VAR 0 3
103432: PUSH
103433: LD_VAR 0 1
103437: PPUSH
103438: LD_INT 50
103440: PUSH
103441: EMPTY
103442: LIST
103443: PPUSH
103444: CALL_OW 72
103448: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
103449: LD_ADDR_VAR 0 8
103453: PUSH
103454: LD_VAR 0 1
103458: PUSH
103459: LD_INT 1
103461: ARRAY
103462: PPUSH
103463: CALL_OW 255
103467: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
103468: LD_ADDR_VAR 0 10
103472: PUSH
103473: LD_INT 29
103475: PUSH
103476: LD_EXP 77
103480: PUSH
103481: LD_INT 49
103483: PUSH
103484: EMPTY
103485: LIST
103486: LIST
103487: LIST
103488: ST_TO_ADDR
// if not result then
103489: LD_VAR 0 3
103493: NOT
103494: IFFALSE 103498
// exit ;
103496: GO 103954
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
103498: LD_ADDR_VAR 0 5
103502: PUSH
103503: LD_INT 81
103505: PUSH
103506: LD_VAR 0 8
103510: PUSH
103511: EMPTY
103512: LIST
103513: LIST
103514: PPUSH
103515: CALL_OW 69
103519: ST_TO_ADDR
// for i in result do
103520: LD_ADDR_VAR 0 4
103524: PUSH
103525: LD_VAR 0 3
103529: PUSH
103530: FOR_IN
103531: IFFALSE 103952
// begin tag := GetTag ( i ) + 1 ;
103533: LD_ADDR_VAR 0 9
103537: PUSH
103538: LD_VAR 0 4
103542: PPUSH
103543: CALL_OW 110
103547: PUSH
103548: LD_INT 1
103550: PLUS
103551: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
103552: LD_ADDR_VAR 0 7
103556: PUSH
103557: LD_VAR 0 4
103561: PPUSH
103562: CALL_OW 250
103566: PPUSH
103567: LD_VAR 0 4
103571: PPUSH
103572: CALL_OW 251
103576: PPUSH
103577: LD_INT 6
103579: PPUSH
103580: CALL 103151 0 3
103584: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
103585: LD_VAR 0 4
103589: PPUSH
103590: CALL_OW 247
103594: PUSH
103595: LD_INT 2
103597: EQUAL
103598: PUSH
103599: LD_VAR 0 7
103603: AND
103604: PUSH
103605: LD_VAR 0 4
103609: PPUSH
103610: CALL_OW 264
103614: PUSH
103615: LD_VAR 0 10
103619: IN
103620: NOT
103621: AND
103622: IFFALSE 103661
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
103624: LD_VAR 0 4
103628: PPUSH
103629: LD_VAR 0 7
103633: PUSH
103634: LD_INT 1
103636: ARRAY
103637: PUSH
103638: LD_INT 1
103640: ARRAY
103641: PPUSH
103642: LD_VAR 0 7
103646: PUSH
103647: LD_INT 1
103649: ARRAY
103650: PUSH
103651: LD_INT 2
103653: ARRAY
103654: PPUSH
103655: CALL_OW 116
103659: GO 103950
// if path > tag then
103661: LD_VAR 0 2
103665: PUSH
103666: LD_VAR 0 9
103670: GREATER
103671: IFFALSE 103879
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
103673: LD_ADDR_VAR 0 6
103677: PUSH
103678: LD_VAR 0 5
103682: PPUSH
103683: LD_INT 91
103685: PUSH
103686: LD_VAR 0 4
103690: PUSH
103691: LD_INT 8
103693: PUSH
103694: EMPTY
103695: LIST
103696: LIST
103697: LIST
103698: PPUSH
103699: CALL_OW 72
103703: ST_TO_ADDR
// if nearEnemy then
103704: LD_VAR 0 6
103708: IFFALSE 103777
// begin if GetWeapon ( i ) = ru_time_lapser then
103710: LD_VAR 0 4
103714: PPUSH
103715: CALL_OW 264
103719: PUSH
103720: LD_INT 49
103722: EQUAL
103723: IFFALSE 103751
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
103725: LD_VAR 0 4
103729: PPUSH
103730: LD_VAR 0 6
103734: PPUSH
103735: LD_VAR 0 4
103739: PPUSH
103740: CALL_OW 74
103744: PPUSH
103745: CALL_OW 112
103749: GO 103775
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
103751: LD_VAR 0 4
103755: PPUSH
103756: LD_VAR 0 6
103760: PPUSH
103761: LD_VAR 0 4
103765: PPUSH
103766: CALL_OW 74
103770: PPUSH
103771: CALL_OW 115
// end else
103775: GO 103877
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
103777: LD_VAR 0 4
103781: PPUSH
103782: LD_VAR 0 2
103786: PUSH
103787: LD_VAR 0 9
103791: ARRAY
103792: PUSH
103793: LD_INT 1
103795: ARRAY
103796: PPUSH
103797: LD_VAR 0 2
103801: PUSH
103802: LD_VAR 0 9
103806: ARRAY
103807: PUSH
103808: LD_INT 2
103810: ARRAY
103811: PPUSH
103812: CALL_OW 297
103816: PUSH
103817: LD_INT 6
103819: GREATER
103820: IFFALSE 103863
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
103822: LD_VAR 0 4
103826: PPUSH
103827: LD_VAR 0 2
103831: PUSH
103832: LD_VAR 0 9
103836: ARRAY
103837: PUSH
103838: LD_INT 1
103840: ARRAY
103841: PPUSH
103842: LD_VAR 0 2
103846: PUSH
103847: LD_VAR 0 9
103851: ARRAY
103852: PUSH
103853: LD_INT 2
103855: ARRAY
103856: PPUSH
103857: CALL_OW 114
103861: GO 103877
// SetTag ( i , tag ) ;
103863: LD_VAR 0 4
103867: PPUSH
103868: LD_VAR 0 9
103872: PPUSH
103873: CALL_OW 109
// end else
103877: GO 103950
// if enemy then
103879: LD_VAR 0 5
103883: IFFALSE 103950
// begin if GetWeapon ( i ) = ru_time_lapser then
103885: LD_VAR 0 4
103889: PPUSH
103890: CALL_OW 264
103894: PUSH
103895: LD_INT 49
103897: EQUAL
103898: IFFALSE 103926
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103900: LD_VAR 0 4
103904: PPUSH
103905: LD_VAR 0 5
103909: PPUSH
103910: LD_VAR 0 4
103914: PPUSH
103915: CALL_OW 74
103919: PPUSH
103920: CALL_OW 112
103924: GO 103950
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
103926: LD_VAR 0 4
103930: PPUSH
103931: LD_VAR 0 5
103935: PPUSH
103936: LD_VAR 0 4
103940: PPUSH
103941: CALL_OW 74
103945: PPUSH
103946: CALL_OW 115
// end ; end ;
103950: GO 103530
103952: POP
103953: POP
// end ;
103954: LD_VAR 0 3
103958: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
103959: LD_INT 0
103961: PPUSH
103962: PPUSH
103963: PPUSH
// if not unit or IsInUnit ( unit ) then
103964: LD_VAR 0 1
103968: NOT
103969: PUSH
103970: LD_VAR 0 1
103974: PPUSH
103975: CALL_OW 310
103979: OR
103980: IFFALSE 103984
// exit ;
103982: GO 104075
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
103984: LD_ADDR_VAR 0 4
103988: PUSH
103989: LD_VAR 0 1
103993: PPUSH
103994: CALL_OW 250
103998: PPUSH
103999: LD_VAR 0 2
104003: PPUSH
104004: LD_INT 1
104006: PPUSH
104007: CALL_OW 272
104011: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
104012: LD_ADDR_VAR 0 5
104016: PUSH
104017: LD_VAR 0 1
104021: PPUSH
104022: CALL_OW 251
104026: PPUSH
104027: LD_VAR 0 2
104031: PPUSH
104032: LD_INT 1
104034: PPUSH
104035: CALL_OW 273
104039: ST_TO_ADDR
// if ValidHex ( x , y ) then
104040: LD_VAR 0 4
104044: PPUSH
104045: LD_VAR 0 5
104049: PPUSH
104050: CALL_OW 488
104054: IFFALSE 104075
// ComTurnXY ( unit , x , y ) ;
104056: LD_VAR 0 1
104060: PPUSH
104061: LD_VAR 0 4
104065: PPUSH
104066: LD_VAR 0 5
104070: PPUSH
104071: CALL_OW 118
// end ;
104075: LD_VAR 0 3
104079: RET
// export function SeeUnits ( side , units ) ; var i ; begin
104080: LD_INT 0
104082: PPUSH
104083: PPUSH
// result := false ;
104084: LD_ADDR_VAR 0 3
104088: PUSH
104089: LD_INT 0
104091: ST_TO_ADDR
// if not units then
104092: LD_VAR 0 2
104096: NOT
104097: IFFALSE 104101
// exit ;
104099: GO 104146
// for i in units do
104101: LD_ADDR_VAR 0 4
104105: PUSH
104106: LD_VAR 0 2
104110: PUSH
104111: FOR_IN
104112: IFFALSE 104144
// if See ( side , i ) then
104114: LD_VAR 0 1
104118: PPUSH
104119: LD_VAR 0 4
104123: PPUSH
104124: CALL_OW 292
104128: IFFALSE 104142
// begin result := true ;
104130: LD_ADDR_VAR 0 3
104134: PUSH
104135: LD_INT 1
104137: ST_TO_ADDR
// exit ;
104138: POP
104139: POP
104140: GO 104146
// end ;
104142: GO 104111
104144: POP
104145: POP
// end ;
104146: LD_VAR 0 3
104150: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
104151: LD_INT 0
104153: PPUSH
104154: PPUSH
104155: PPUSH
104156: PPUSH
// if not unit or not points then
104157: LD_VAR 0 1
104161: NOT
104162: PUSH
104163: LD_VAR 0 2
104167: NOT
104168: OR
104169: IFFALSE 104173
// exit ;
104171: GO 104263
// dist := 99999 ;
104173: LD_ADDR_VAR 0 5
104177: PUSH
104178: LD_INT 99999
104180: ST_TO_ADDR
// for i in points do
104181: LD_ADDR_VAR 0 4
104185: PUSH
104186: LD_VAR 0 2
104190: PUSH
104191: FOR_IN
104192: IFFALSE 104261
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
104194: LD_ADDR_VAR 0 6
104198: PUSH
104199: LD_VAR 0 1
104203: PPUSH
104204: LD_VAR 0 4
104208: PUSH
104209: LD_INT 1
104211: ARRAY
104212: PPUSH
104213: LD_VAR 0 4
104217: PUSH
104218: LD_INT 2
104220: ARRAY
104221: PPUSH
104222: CALL_OW 297
104226: ST_TO_ADDR
// if tmpDist < dist then
104227: LD_VAR 0 6
104231: PUSH
104232: LD_VAR 0 5
104236: LESS
104237: IFFALSE 104259
// begin result := i ;
104239: LD_ADDR_VAR 0 3
104243: PUSH
104244: LD_VAR 0 4
104248: ST_TO_ADDR
// dist := tmpDist ;
104249: LD_ADDR_VAR 0 5
104253: PUSH
104254: LD_VAR 0 6
104258: ST_TO_ADDR
// end ; end ;
104259: GO 104191
104261: POP
104262: POP
// end ;
104263: LD_VAR 0 3
104267: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104268: LD_INT 0
104270: PPUSH
// uc_side := side ;
104271: LD_ADDR_OWVAR 20
104275: PUSH
104276: LD_VAR 0 1
104280: ST_TO_ADDR
// uc_nation := 3 ;
104281: LD_ADDR_OWVAR 21
104285: PUSH
104286: LD_INT 3
104288: ST_TO_ADDR
// vc_chassis := 25 ;
104289: LD_ADDR_OWVAR 37
104293: PUSH
104294: LD_INT 25
104296: ST_TO_ADDR
// vc_engine := engine_siberite ;
104297: LD_ADDR_OWVAR 39
104301: PUSH
104302: LD_INT 3
104304: ST_TO_ADDR
// vc_control := control_computer ;
104305: LD_ADDR_OWVAR 38
104309: PUSH
104310: LD_INT 3
104312: ST_TO_ADDR
// vc_weapon := 59 ;
104313: LD_ADDR_OWVAR 40
104317: PUSH
104318: LD_INT 59
104320: ST_TO_ADDR
// result := CreateVehicle ;
104321: LD_ADDR_VAR 0 5
104325: PUSH
104326: CALL_OW 45
104330: ST_TO_ADDR
// SetDir ( result , d ) ;
104331: LD_VAR 0 5
104335: PPUSH
104336: LD_VAR 0 4
104340: PPUSH
104341: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
104345: LD_VAR 0 5
104349: PPUSH
104350: LD_VAR 0 2
104354: PPUSH
104355: LD_VAR 0 3
104359: PPUSH
104360: LD_INT 0
104362: PPUSH
104363: CALL_OW 48
// end ;
104367: LD_VAR 0 5
104371: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
104372: LD_INT 0
104374: PPUSH
104375: PPUSH
104376: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
104377: LD_ADDR_VAR 0 2
104381: PUSH
104382: LD_INT 0
104384: PUSH
104385: LD_INT 0
104387: PUSH
104388: LD_INT 0
104390: PUSH
104391: LD_INT 0
104393: PUSH
104394: EMPTY
104395: LIST
104396: LIST
104397: LIST
104398: LIST
104399: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
104400: LD_VAR 0 1
104404: NOT
104405: PUSH
104406: LD_VAR 0 1
104410: PPUSH
104411: CALL_OW 264
104415: PUSH
104416: LD_INT 12
104418: PUSH
104419: LD_INT 51
104421: PUSH
104422: LD_INT 32
104424: PUSH
104425: LD_EXP 74
104429: PUSH
104430: EMPTY
104431: LIST
104432: LIST
104433: LIST
104434: LIST
104435: IN
104436: NOT
104437: OR
104438: IFFALSE 104442
// exit ;
104440: GO 104540
// for i := 1 to 3 do
104442: LD_ADDR_VAR 0 3
104446: PUSH
104447: DOUBLE
104448: LD_INT 1
104450: DEC
104451: ST_TO_ADDR
104452: LD_INT 3
104454: PUSH
104455: FOR_TO
104456: IFFALSE 104538
// begin tmp := GetCargo ( cargo , i ) ;
104458: LD_ADDR_VAR 0 4
104462: PUSH
104463: LD_VAR 0 1
104467: PPUSH
104468: LD_VAR 0 3
104472: PPUSH
104473: CALL_OW 289
104477: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
104478: LD_ADDR_VAR 0 2
104482: PUSH
104483: LD_VAR 0 2
104487: PPUSH
104488: LD_VAR 0 3
104492: PPUSH
104493: LD_VAR 0 4
104497: PPUSH
104498: CALL_OW 1
104502: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
104503: LD_ADDR_VAR 0 2
104507: PUSH
104508: LD_VAR 0 2
104512: PPUSH
104513: LD_INT 4
104515: PPUSH
104516: LD_VAR 0 2
104520: PUSH
104521: LD_INT 4
104523: ARRAY
104524: PUSH
104525: LD_VAR 0 4
104529: PLUS
104530: PPUSH
104531: CALL_OW 1
104535: ST_TO_ADDR
// end ;
104536: GO 104455
104538: POP
104539: POP
// end ;
104540: LD_VAR 0 2
104544: RET
// export function Length ( array ) ; begin
104545: LD_INT 0
104547: PPUSH
// result := array + 0 ;
104548: LD_ADDR_VAR 0 2
104552: PUSH
104553: LD_VAR 0 1
104557: PUSH
104558: LD_INT 0
104560: PLUS
104561: ST_TO_ADDR
// end ;
104562: LD_VAR 0 2
104566: RET
// export function PrepareArray ( array ) ; begin
104567: LD_INT 0
104569: PPUSH
// result := array diff 0 ;
104570: LD_ADDR_VAR 0 2
104574: PUSH
104575: LD_VAR 0 1
104579: PUSH
104580: LD_INT 0
104582: DIFF
104583: ST_TO_ADDR
// if not result [ 1 ] then
104584: LD_VAR 0 2
104588: PUSH
104589: LD_INT 1
104591: ARRAY
104592: NOT
104593: IFFALSE 104613
// result := Delete ( result , 1 ) ;
104595: LD_ADDR_VAR 0 2
104599: PUSH
104600: LD_VAR 0 2
104604: PPUSH
104605: LD_INT 1
104607: PPUSH
104608: CALL_OW 3
104612: ST_TO_ADDR
// end ; end_of_file
104613: LD_VAR 0 2
104617: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
104618: LD_VAR 0 1
104622: PUSH
104623: LD_INT 200
104625: DOUBLE
104626: GREATEREQUAL
104627: IFFALSE 104635
104629: LD_INT 299
104631: DOUBLE
104632: LESSEQUAL
104633: IFTRUE 104637
104635: GO 104669
104637: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
104638: LD_VAR 0 1
104642: PPUSH
104643: LD_VAR 0 2
104647: PPUSH
104648: LD_VAR 0 3
104652: PPUSH
104653: LD_VAR 0 4
104657: PPUSH
104658: LD_VAR 0 5
104662: PPUSH
104663: CALL 59469 0 5
104667: GO 104746
104669: LD_INT 300
104671: DOUBLE
104672: GREATEREQUAL
104673: IFFALSE 104681
104675: LD_INT 399
104677: DOUBLE
104678: LESSEQUAL
104679: IFTRUE 104683
104681: GO 104745
104683: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
104684: LD_VAR 0 1
104688: PPUSH
104689: LD_VAR 0 2
104693: PPUSH
104694: LD_VAR 0 3
104698: PPUSH
104699: LD_VAR 0 4
104703: PPUSH
104704: LD_VAR 0 5
104708: PPUSH
104709: LD_VAR 0 6
104713: PPUSH
104714: LD_VAR 0 7
104718: PPUSH
104719: LD_VAR 0 8
104723: PPUSH
104724: LD_VAR 0 9
104728: PPUSH
104729: LD_VAR 0 10
104733: PPUSH
104734: LD_VAR 0 11
104738: PPUSH
104739: CALL 55798 0 11
104743: GO 104746
104745: POP
// end ;
104746: PPOPN 11
104748: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
104749: LD_VAR 0 1
104753: PPUSH
104754: LD_VAR 0 2
104758: PPUSH
104759: LD_VAR 0 3
104763: PPUSH
104764: LD_VAR 0 4
104768: PPUSH
104769: LD_VAR 0 5
104773: PPUSH
104774: CALL 59205 0 5
// end ; end_of_file
104778: PPOPN 5
104780: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
104781: LD_VAR 0 1
104785: PPUSH
104786: LD_VAR 0 2
104790: PPUSH
104791: LD_VAR 0 3
104795: PPUSH
104796: LD_VAR 0 4
104800: PPUSH
104801: LD_VAR 0 5
104805: PPUSH
104806: LD_VAR 0 6
104810: PPUSH
104811: CALL 43491 0 6
// end ;
104815: PPOPN 6
104817: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
104818: LD_INT 0
104820: PPUSH
// begin if not units then
104821: LD_VAR 0 1
104825: NOT
104826: IFFALSE 104830
// exit ;
104828: GO 104830
// end ;
104830: PPOPN 7
104832: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
104833: CALL 43462 0 0
// end ;
104837: PPOPN 1
104839: END
