// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7711 0 0
// InitGlobalVar ;
  45: CALL 1511 0 0
// InitAction ;
  49: CALL 4641 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 275 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 275 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 31
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4880 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
  87: LD_INT 4
  89: PPUSH
  90: LD_INT 1
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_STRING jakes
  98: PPUSH
  99: LD_INT 4
 101: PUSH
 102: LD_INT 5
 104: PUSH
 105: LD_INT 6
 107: PUSH
 108: EMPTY
 109: LIST
 110: LIST
 111: LIST
 112: PUSH
 113: LD_OWVAR 67
 117: ARRAY
 118: PPUSH
 119: LD_INT 21
 121: PPUSH
 122: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 126: LD_INT 3
 128: PPUSH
 129: LD_INT 3
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 2973 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 142: LD_INT 1
 144: PPUSH
 145: LD_INT 1
 147: PPUSH
 148: LD_INT 3
 150: PPUSH
 151: LD_STRING sylvia
 153: PPUSH
 154: LD_INT 4
 156: PUSH
 157: LD_INT 5
 159: PUSH
 160: LD_INT 6
 162: PUSH
 163: EMPTY
 164: LIST
 165: LIST
 166: LIST
 167: PUSH
 168: LD_OWVAR 67
 172: ARRAY
 173: PPUSH
 174: LD_INT 21
 176: PPUSH
 177: CALL 2600 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 181: LD_INT 3
 183: PPUSH
 184: LD_INT 3
 186: PPUSH
 187: LD_INT 0
 189: PPUSH
 190: LD_INT 3
 192: PPUSH
 193: CALL 2973 0 4
// MC_Registry ( ) ;
 197: CALL 41697 0 0
// MC_RegistryInit ( ) ;
 201: CALL 42148 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 205: LD_ADDR_EXP 32
 209: PUSH
 210: LD_INT 4
 212: PUSH
 213: LD_INT 5
 215: PUSH
 216: LD_INT 10
 218: PUSH
 219: EMPTY
 220: LIST
 221: LIST
 222: LIST
 223: ST_TO_ADDR
// if Difficulty > 1 then
 224: LD_OWVAR 67
 228: PUSH
 229: LD_INT 1
 231: GREATER
 232: IFFALSE 247
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 234: LD_INT 58
 236: PPUSH
 237: LD_INT 8
 239: PPUSH
 240: LD_INT 2
 242: PPUSH
 243: CALL_OW 322
// if Difficulty > 2 then
 247: LD_OWVAR 67
 251: PUSH
 252: LD_INT 2
 254: GREATER
 255: IFFALSE 270
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 257: LD_INT 59
 259: PPUSH
 260: LD_INT 8
 262: PPUSH
 263: LD_INT 2
 265: PPUSH
 266: CALL_OW 322
// end ;
 270: LD_VAR 0 1
 274: RET
// function MC_SetStrategy ( side ) ; begin
 275: LD_INT 0
 277: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 278: LD_INT 3500
 280: PPUSH
 281: LD_INT 500
 283: PPUSH
 284: LD_INT 0
 286: PPUSH
 287: CALL 21451 0 3
// case side of 1 :
 291: LD_VAR 0 1
 295: PUSH
 296: LD_INT 1
 298: DOUBLE
 299: EQUAL
 300: IFTRUE 304
 302: GO 907
 304: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 1
 310: PPUSH
 311: LD_INT 4
 313: PUSH
 314: EMPTY
 315: LIST
 316: PPUSH
 317: CALL 21387 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 321: LD_INT 13
 323: PPUSH
 324: LD_INT 5
 326: PPUSH
 327: LD_INT 1
 329: PPUSH
 330: CALL 18380 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 334: LD_INT 1
 336: PPUSH
 337: LD_INT 6
 339: PPUSH
 340: CALL 21287 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 344: LD_INT 1
 346: PPUSH
 347: LD_INT 8
 349: PPUSH
 350: CALL 22301 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 354: LD_INT 1
 356: PPUSH
 357: LD_INT 22
 359: PUSH
 360: LD_INT 17
 362: PUSH
 363: LD_INT 2
 365: PUSH
 366: LD_INT 57
 368: PUSH
 369: LD_INT 8
 371: PUSH
 372: LD_INT 2
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL 21528 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 387: LD_INT 1
 389: PPUSH
 390: LD_INT 3
 392: PPUSH
 393: CALL 21321 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 397: LD_INT 1
 399: PPUSH
 400: LD_INT 0
 402: PUSH
 403: LD_INT 1
 405: PUSH
 406: LD_INT 0
 408: PUSH
 409: LD_INT 0
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PPUSH
 418: CALL 21354 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 422: LD_INT 1
 424: PPUSH
 425: LD_INT 48
 427: PUSH
 428: LD_INT 49
 430: PUSH
 431: LD_INT 46
 433: PUSH
 434: LD_INT 47
 436: PUSH
 437: LD_INT 35
 439: PUSH
 440: LD_INT 45
 442: PUSH
 443: LD_INT 1
 445: PUSH
 446: LD_INT 50
 448: PUSH
 449: LD_INT 2
 451: PUSH
 452: LD_INT 51
 454: PUSH
 455: LD_INT 52
 457: PUSH
 458: LD_INT 69
 460: PUSH
 461: LD_INT 39
 463: PUSH
 464: LD_INT 60
 466: PUSH
 467: LD_INT 61
 469: PUSH
 470: LD_INT 12
 472: PUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 15
 478: PUSH
 479: LD_INT 53
 481: PUSH
 482: LD_INT 40
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 18159 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 511: LD_INT 1
 513: PPUSH
 514: LD_INT 4
 516: PPUSH
 517: LD_INT 0
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL 22209 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 35
 532: PUSH
 533: LD_INT 9
 535: PUSH
 536: LD_INT 3
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: PPUSH
 544: CALL 20466 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 548: LD_INT 1
 550: PPUSH
 551: LD_INT 54
 553: PUSH
 554: LD_INT 19
 556: PUSH
 557: LD_INT 4
 559: PUSH
 560: EMPTY
 561: LIST
 562: LIST
 563: LIST
 564: PPUSH
 565: CALL 21041 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 34
 574: PUSH
 575: LD_INT 20
 577: PUSH
 578: LD_INT 0
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: PPUSH
 586: CALL 21041 0 2
// MCS_Mine ( 1 ) ;
 590: LD_INT 1
 592: PPUSH
 593: CALL 20838 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 597: LD_INT 1
 599: PPUSH
 600: LD_INT 29
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: LD_INT 2
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: LIST
 613: PPUSH
 614: LD_INT 10
 616: PUSH
 617: LD_INT 15
 619: PUSH
 620: EMPTY
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 20502 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 628: LD_INT 1
 630: PPUSH
 631: LD_INT 15
 633: PUSH
 634: LD_INT 8
 636: PUSH
 637: LD_INT 2
 639: PUSH
 640: LD_INT 14
 642: PUSH
 643: LD_INT 5
 645: PUSH
 646: LD_INT 2
 648: PUSH
 649: LD_INT 39
 651: PUSH
 652: LD_INT 12
 654: PUSH
 655: LD_INT 0
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: LIST
 667: LIST
 668: PPUSH
 669: LD_INT 27
 671: PUSH
 672: LD_INT 27
 674: PUSH
 675: LD_INT 26
 677: PUSH
 678: EMPTY
 679: LIST
 680: LIST
 681: LIST
 682: PPUSH
 683: CALL 20678 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 687: LD_INT 1
 689: PPUSH
 690: LD_INT 32
 692: PPUSH
 693: LD_INT 18
 695: PUSH
 696: LD_INT 13
 698: PUSH
 699: LD_INT 0
 701: PUSH
 702: LD_INT 38
 704: PUSH
 705: LD_INT 22
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 50
 713: PUSH
 714: LD_INT 6
 716: PUSH
 717: LD_INT 4
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: LIST
 730: PPUSH
 731: LD_INT 7
 733: PUSH
 734: LD_INT 5
 736: PUSH
 737: LD_INT 5
 739: PUSH
 740: EMPTY
 741: LIST
 742: LIST
 743: LIST
 744: PPUSH
 745: CALL 19962 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 23
 754: PUSH
 755: LD_INT 8
 757: PUSH
 758: LD_INT 2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: PPUSH
 766: LD_INT 17
 768: PUSH
 769: LD_INT 19
 771: PUSH
 772: LD_INT 22
 774: PUSH
 775: LD_INT 16
 777: PUSH
 778: LD_INT 18
 780: PUSH
 781: EMPTY
 782: LIST
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PPUSH
 788: CALL 20576 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 792: LD_INT 1
 794: PPUSH
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 40
 800: PUSH
 801: LD_INT 4
 803: PUSH
 804: LD_INT 3
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: PPUSH
 812: CALL 21077 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 816: LD_INT 1
 818: PPUSH
 819: LD_INT 14
 821: PPUSH
 822: LD_INT 15
 824: PPUSH
 825: LD_INT 59
 827: PUSH
 828: LD_INT 20
 830: PUSH
 831: LD_INT 52
 833: PUSH
 834: LD_INT 5
 836: PUSH
 837: LD_INT 30
 839: PUSH
 840: LD_INT 29
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: PPUSH
 851: LD_INT 3
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 1
 859: PUSH
 860: LD_INT 4
 862: PUSH
 863: LD_INT 3
 865: PUSH
 866: LD_INT 1
 868: PUSH
 869: LD_INT 1
 871: PUSH
 872: LD_INT 5
 874: PUSH
 875: LD_INT 3
 877: PUSH
 878: LD_INT 1
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 5
 886: PUSH
 887: EMPTY
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PPUSH
 901: CALL 21817 0 5
// end ; 4 :
 905: GO 1506
 907: LD_INT 4
 909: DOUBLE
 910: EQUAL
 911: IFTRUE 915
 913: GO 1505
 915: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 916: LD_INT 4
 918: PPUSH
 919: LD_INT 1
 921: PPUSH
 922: LD_INT 5
 924: PUSH
 925: EMPTY
 926: LIST
 927: PPUSH
 928: CALL 21387 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 932: LD_INT 12
 934: PPUSH
 935: LD_INT 5
 937: PPUSH
 938: LD_INT 1
 940: PPUSH
 941: CALL 18380 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 945: LD_INT 4
 947: PPUSH
 948: LD_INT 7
 950: PPUSH
 951: CALL 21287 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 955: LD_INT 4
 957: PPUSH
 958: LD_INT 72
 960: PUSH
 961: LD_INT 136
 963: PUSH
 964: LD_INT 2
 966: PUSH
 967: LD_INT 111
 969: PUSH
 970: LD_INT 162
 972: PUSH
 973: LD_INT 2
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: LIST
 982: LIST
 983: PPUSH
 984: CALL 21528 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_tech3 , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
 988: LD_INT 4
 990: PPUSH
 991: LD_INT 48
 993: PUSH
 994: LD_INT 49
 996: PUSH
 997: LD_INT 46
 999: PUSH
1000: LD_INT 47
1002: PUSH
1003: LD_INT 35
1005: PUSH
1006: LD_INT 45
1008: PUSH
1009: LD_INT 50
1011: PUSH
1012: LD_INT 51
1014: PUSH
1015: LD_INT 52
1017: PUSH
1018: LD_INT 69
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 60
1026: PUSH
1027: LD_INT 61
1029: PUSH
1030: LD_INT 12
1032: PUSH
1033: LD_INT 6
1035: PUSH
1036: LD_INT 15
1038: PUSH
1039: LD_INT 53
1041: PUSH
1042: LD_INT 34
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PPUSH
1065: CALL 18159 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1069: LD_INT 4
1071: PPUSH
1072: LD_INT 4
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: LD_INT 0
1080: PPUSH
1081: CALL 22209 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1085: LD_INT 4
1087: PPUSH
1088: LD_INT 86
1090: PUSH
1091: LD_INT 146
1093: PUSH
1094: LD_INT 1
1096: PUSH
1097: EMPTY
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 20466 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 106
1111: PUSH
1112: LD_INT 149
1114: PUSH
1115: LD_INT 4
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: PPUSH
1123: CALL 21041 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1127: LD_INT 4
1129: PPUSH
1130: LD_INT 84
1132: PUSH
1133: LD_INT 134
1135: PUSH
1136: LD_INT 2
1138: PUSH
1139: EMPTY
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 21041 0 2
// MCS_Mine ( 4 ) ;
1148: LD_INT 4
1150: PPUSH
1151: CALL 20838 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 97
1160: PUSH
1161: LD_INT 163
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PPUSH
1172: LD_INT 10
1174: PUSH
1175: LD_INT 15
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20502 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 95
1191: PUSH
1192: LD_INT 166
1194: PUSH
1195: LD_INT 0
1197: PUSH
1198: LD_INT 82
1200: PUSH
1201: LD_INT 156
1203: PUSH
1204: LD_INT 2
1206: PUSH
1207: LD_INT 76
1209: PUSH
1210: LD_INT 146
1212: PUSH
1213: LD_INT 2
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PPUSH
1227: LD_INT 27
1229: PUSH
1230: LD_INT 26
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PPUSH
1237: CALL 20678 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1241: LD_INT 4
1243: PPUSH
1244: LD_INT 32
1246: PPUSH
1247: LD_INT 109
1249: PUSH
1250: LD_INT 155
1252: PUSH
1253: LD_INT 4
1255: PUSH
1256: LD_INT 103
1258: PUSH
1259: LD_INT 143
1261: PUSH
1262: LD_INT 4
1264: PUSH
1265: LD_INT 75
1267: PUSH
1268: LD_INT 133
1270: PUSH
1271: LD_INT 2
1273: PUSH
1274: LD_INT 88
1276: PUSH
1277: LD_INT 133
1279: PUSH
1280: LD_INT 2
1282: PUSH
1283: EMPTY
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PPUSH
1297: LD_INT 4
1299: PUSH
1300: LD_INT 6
1302: PUSH
1303: LD_INT 5
1305: PUSH
1306: LD_INT 6
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: PPUSH
1315: CALL 19962 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 87
1324: PUSH
1325: LD_INT 153
1327: PUSH
1328: LD_INT 1
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: LIST
1335: PPUSH
1336: LD_INT 17
1338: PUSH
1339: LD_INT 19
1341: PUSH
1342: LD_INT 22
1344: PUSH
1345: LD_INT 16
1347: PUSH
1348: EMPTY
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: PPUSH
1354: CALL 20576 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1358: LD_INT 4
1360: PPUSH
1361: LD_INT 1
1363: PPUSH
1364: LD_INT 105
1366: PUSH
1367: LD_INT 160
1369: PUSH
1370: LD_INT 5
1372: PUSH
1373: EMPTY
1374: LIST
1375: LIST
1376: LIST
1377: PPUSH
1378: CALL 21077 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 , 89 , 155 , 86 , 164 , 98 , 164 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 11
1387: PPUSH
1388: LD_INT 16
1390: PPUSH
1391: LD_INT 69
1393: PUSH
1394: LD_INT 126
1396: PUSH
1397: LD_INT 80
1399: PUSH
1400: LD_INT 126
1402: PUSH
1403: LD_INT 108
1405: PUSH
1406: LD_INT 142
1408: PUSH
1409: LD_INT 118
1411: PUSH
1412: LD_INT 161
1414: PUSH
1415: LD_INT 89
1417: PUSH
1418: LD_INT 155
1420: PUSH
1421: LD_INT 86
1423: PUSH
1424: LD_INT 164
1426: PUSH
1427: LD_INT 98
1429: PUSH
1430: LD_INT 164
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: PPUSH
1449: LD_INT 3
1451: PUSH
1452: LD_INT 1
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 4
1460: PUSH
1461: LD_INT 3
1463: PUSH
1464: LD_INT 1
1466: PUSH
1467: LD_INT 1
1469: PUSH
1470: LD_INT 5
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 1
1481: PUSH
1482: LD_INT 5
1484: PUSH
1485: EMPTY
1486: LIST
1487: LIST
1488: LIST
1489: LIST
1490: LIST
1491: LIST
1492: LIST
1493: LIST
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PPUSH
1499: CALL 21817 0 5
// end ; end ;
1503: GO 1506
1505: POP
// end ;
1506: LD_VAR 0 2
1510: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1511: LD_INT 0
1513: PPUSH
// dialog_north := true ;
1514: LD_ADDR_EXP 6
1518: PUSH
1519: LD_INT 1
1521: ST_TO_ADDR
// dialog_south := true ;
1522: LD_ADDR_EXP 7
1526: PUSH
1527: LD_INT 1
1529: ST_TO_ADDR
// dialog_popov := true ;
1530: LD_ADDR_EXP 8
1534: PUSH
1535: LD_INT 1
1537: ST_TO_ADDR
// dialog_trans := true ;
1538: LD_ADDR_EXP 9
1542: PUSH
1543: LD_INT 1
1545: ST_TO_ADDR
// call := true ;
1546: LD_ADDR_EXP 11
1550: PUSH
1551: LD_INT 1
1553: ST_TO_ADDR
// pink_attack := false ;
1554: LD_ADDR_EXP 12
1558: PUSH
1559: LD_INT 0
1561: ST_TO_ADDR
// alfa_support := false ;
1562: LD_ADDR_EXP 13
1566: PUSH
1567: LD_INT 0
1569: ST_TO_ADDR
// alfa_north_triggered := false ;
1570: LD_ADDR_EXP 14
1574: PUSH
1575: LD_INT 0
1577: ST_TO_ADDR
// alfa_south_triggered := false ;
1578: LD_ADDR_EXP 15
1582: PUSH
1583: LD_INT 0
1585: ST_TO_ADDR
// player_loss := 0 ;
1586: LD_ADDR_EXP 10
1590: PUSH
1591: LD_INT 0
1593: ST_TO_ADDR
// callUsed := false ;
1594: LD_ADDR_EXP 3
1598: PUSH
1599: LD_INT 0
1601: ST_TO_ADDR
// end ;
1602: LD_VAR 0 1
1606: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1607: LD_INT 8
1609: PPUSH
1610: CALL_OW 353
1614: PUSH
1615: LD_INT 0
1617: EQUAL
1618: IFFALSE 1653
1620: GO 1622
1622: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1623: LD_INT 1
1625: PPUSH
1626: LD_INT 32
1628: PPUSH
1629: LD_INT 50
1631: PUSH
1632: LD_INT 10
1634: PUSH
1635: LD_INT 4
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: LD_INT 7
1645: PUSH
1646: EMPTY
1647: LIST
1648: PPUSH
1649: CALL 19962 0 4
// end ;
1653: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1654: LD_INT 1
1656: PPUSH
1657: LD_INT 30
1659: PUSH
1660: LD_INT 3
1662: PUSH
1663: EMPTY
1664: LIST
1665: LIST
1666: PPUSH
1667: CALL 11667 0 2
1671: IFFALSE 1765
1673: GO 1675
1675: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 3
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 4
1690: PUSH
1691: LD_INT 3
1693: PUSH
1694: LD_INT 1
1696: PUSH
1697: LD_INT 2
1699: PUSH
1700: LD_INT 5
1702: PUSH
1703: LD_INT 3
1705: PUSH
1706: LD_INT 1
1708: PUSH
1709: LD_INT 2
1711: PUSH
1712: LD_INT 5
1714: PUSH
1715: LD_INT 3
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 7
1726: PUSH
1727: LD_INT 3
1729: PUSH
1730: LD_INT 1
1732: PUSH
1733: LD_INT 2
1735: PUSH
1736: LD_INT 7
1738: PUSH
1739: EMPTY
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: LIST
1747: LIST
1748: LIST
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: LIST
1755: LIST
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PPUSH
1761: CALL 22035 0 2
// end ;
1765: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1766: LD_INT 4
1768: PPUSH
1769: LD_INT 30
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PPUSH
1779: CALL 11667 0 2
1783: IFFALSE 1877
1785: GO 1787
1787: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1788: LD_INT 4
1790: PPUSH
1791: LD_INT 3
1793: PUSH
1794: LD_INT 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 3
1805: PUSH
1806: LD_INT 1
1808: PUSH
1809: LD_INT 2
1811: PUSH
1812: LD_INT 5
1814: PUSH
1815: LD_INT 3
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 5
1826: PUSH
1827: LD_INT 4
1829: PUSH
1830: LD_INT 1
1832: PUSH
1833: LD_INT 2
1835: PUSH
1836: LD_INT 6
1838: PUSH
1839: LD_INT 4
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: LD_INT 6
1850: PUSH
1851: EMPTY
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PPUSH
1873: CALL 22035 0 2
// end ;
1877: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1878: LD_INT 1
1880: PPUSH
1881: LD_INT 30
1883: PUSH
1884: LD_INT 3
1886: PUSH
1887: EMPTY
1888: LIST
1889: LIST
1890: PPUSH
1891: CALL 11667 0 2
1895: PUSH
1896: LD_EXP 69
1900: PUSH
1901: LD_INT 1
1903: ARRAY
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 0
1911: EQUAL
1912: AND
1913: IFFALSE 2024
1915: GO 1917
1917: DISABLE
// begin enable ;
1918: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1919: LD_INT 1
1921: PPUSH
1922: LD_INT 3
1924: PUSH
1925: LD_INT 1
1927: PUSH
1928: LD_INT 2
1930: PUSH
1931: LD_INT 4
1933: PUSH
1934: LD_INT 3
1936: PUSH
1937: LD_INT 1
1939: PUSH
1940: LD_INT 2
1942: PUSH
1943: LD_INT 5
1945: PUSH
1946: LD_INT 3
1948: PUSH
1949: LD_INT 1
1951: PUSH
1952: LD_INT 2
1954: PUSH
1955: LD_INT 5
1957: PUSH
1958: LD_INT 3
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 2
1966: PUSH
1967: LD_INT 7
1969: PUSH
1970: LD_INT 3
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 7
1981: PUSH
1982: LD_INT 4
1984: PUSH
1985: LD_INT 1
1987: PUSH
1988: LD_INT 2
1990: PUSH
1991: LD_INT 7
1993: PUSH
1994: EMPTY
1995: LIST
1996: LIST
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL 22035 0 2
// end ;
2024: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2025: LD_INT 4
2027: PPUSH
2028: LD_INT 30
2030: PUSH
2031: LD_INT 3
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PPUSH
2038: CALL 11667 0 2
2042: PUSH
2043: LD_EXP 69
2047: PUSH
2048: LD_INT 4
2050: ARRAY
2051: PUSH
2052: LD_INT 1
2054: ARRAY
2055: PUSH
2056: LD_INT 0
2058: EQUAL
2059: AND
2060: IFFALSE 2171
2062: GO 2064
2064: DISABLE
// begin enable ;
2065: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2066: LD_INT 4
2068: PPUSH
2069: LD_INT 3
2071: PUSH
2072: LD_INT 1
2074: PUSH
2075: LD_INT 2
2077: PUSH
2078: LD_INT 4
2080: PUSH
2081: LD_INT 3
2083: PUSH
2084: LD_INT 1
2086: PUSH
2087: LD_INT 2
2089: PUSH
2090: LD_INT 5
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 1
2098: PUSH
2099: LD_INT 2
2101: PUSH
2102: LD_INT 5
2104: PUSH
2105: LD_INT 4
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 6
2116: PUSH
2117: LD_INT 4
2119: PUSH
2120: LD_INT 1
2122: PUSH
2123: LD_INT 2
2125: PUSH
2126: LD_INT 6
2128: PUSH
2129: LD_INT 3
2131: PUSH
2132: LD_INT 1
2134: PUSH
2135: LD_INT 2
2137: PUSH
2138: LD_INT 5
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: LIST
2145: LIST
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: LIST
2159: LIST
2160: LIST
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL 22035 0 2
// end ;
2171: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2172: LD_EXP 12
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 6
2182: PUSH
2183: EMPTY
2184: LIST
2185: LIST
2186: PUSH
2187: LD_INT 21
2189: PUSH
2190: LD_INT 2
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 3
2199: PUSH
2200: LD_INT 34
2202: PUSH
2203: LD_INT 51
2205: PUSH
2206: EMPTY
2207: LIST
2208: LIST
2209: PUSH
2210: EMPTY
2211: LIST
2212: LIST
2213: PUSH
2214: EMPTY
2215: LIST
2216: LIST
2217: LIST
2218: PPUSH
2219: CALL_OW 69
2223: AND
2224: IFFALSE 2353
2226: GO 2228
2228: DISABLE
2229: LD_INT 0
2231: PPUSH
// begin enable ;
2232: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2233: LD_ADDR_VAR 0 1
2237: PUSH
2238: LD_INT 22
2240: PUSH
2241: LD_INT 6
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: PUSH
2248: LD_INT 21
2250: PUSH
2251: LD_INT 2
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 3
2260: PUSH
2261: LD_INT 34
2263: PUSH
2264: LD_INT 51
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: PUSH
2271: EMPTY
2272: LIST
2273: LIST
2274: PUSH
2275: EMPTY
2276: LIST
2277: LIST
2278: LIST
2279: PPUSH
2280: CALL_OW 69
2284: PUSH
2285: FOR_IN
2286: IFFALSE 2351
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2288: LD_VAR 0 1
2292: PPUSH
2293: CALL_OW 314
2297: NOT
2298: PUSH
2299: LD_VAR 0 1
2303: PPUSH
2304: CALL_OW 256
2308: PUSH
2309: LD_INT 250
2311: GREATER
2312: AND
2313: IFFALSE 2349
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2315: LD_VAR 0 1
2319: PPUSH
2320: LD_INT 81
2322: PUSH
2323: LD_INT 6
2325: PUSH
2326: EMPTY
2327: LIST
2328: LIST
2329: PPUSH
2330: CALL_OW 69
2334: PPUSH
2335: LD_VAR 0 1
2339: PPUSH
2340: CALL_OW 74
2344: PPUSH
2345: CALL_OW 115
2349: GO 2285
2351: POP
2352: POP
// end ;
2353: PPOPN 1
2355: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2356: LD_EXP 12
2360: PUSH
2361: LD_INT 22
2363: PUSH
2364: LD_INT 6
2366: PUSH
2367: EMPTY
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 21
2373: PUSH
2374: LD_INT 2
2376: PUSH
2377: EMPTY
2378: LIST
2379: LIST
2380: PUSH
2381: LD_INT 3
2383: PUSH
2384: LD_INT 34
2386: PUSH
2387: LD_INT 51
2389: PUSH
2390: EMPTY
2391: LIST
2392: LIST
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: PUSH
2398: EMPTY
2399: LIST
2400: LIST
2401: LIST
2402: PPUSH
2403: CALL_OW 69
2407: PUSH
2408: LD_INT 0
2410: EQUAL
2411: AND
2412: IFFALSE 2426
2414: GO 2416
2416: DISABLE
// begin enable ;
2417: ENABLE
// pink_attack := false ;
2418: LD_ADDR_EXP 12
2422: PUSH
2423: LD_INT 0
2425: ST_TO_ADDR
// end ;
2426: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2427: LD_EXP 13
2431: PUSH
2432: LD_INT 22
2434: PUSH
2435: LD_INT 8
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: PPUSH
2442: CALL_OW 69
2446: AND
2447: IFFALSE 2558
2449: GO 2451
2451: DISABLE
2452: LD_INT 0
2454: PPUSH
// begin enable ;
2455: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2456: LD_ADDR_VAR 0 1
2460: PUSH
2461: LD_INT 22
2463: PUSH
2464: LD_INT 8
2466: PUSH
2467: EMPTY
2468: LIST
2469: LIST
2470: PUSH
2471: LD_INT 21
2473: PUSH
2474: LD_INT 2
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PPUSH
2485: CALL_OW 69
2489: PUSH
2490: FOR_IN
2491: IFFALSE 2556
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2493: LD_VAR 0 1
2497: PPUSH
2498: CALL_OW 314
2502: NOT
2503: PUSH
2504: LD_VAR 0 1
2508: PPUSH
2509: CALL_OW 256
2513: PUSH
2514: LD_INT 250
2516: GREATER
2517: AND
2518: IFFALSE 2554
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2520: LD_VAR 0 1
2524: PPUSH
2525: LD_INT 81
2527: PUSH
2528: LD_INT 8
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PPUSH
2535: CALL_OW 69
2539: PPUSH
2540: LD_VAR 0 1
2544: PPUSH
2545: CALL_OW 74
2549: PPUSH
2550: CALL_OW 115
2554: GO 2490
2556: POP
2557: POP
// end ;
2558: PPOPN 1
2560: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2561: LD_EXP 13
2565: PUSH
2566: LD_INT 22
2568: PUSH
2569: LD_INT 8
2571: PUSH
2572: EMPTY
2573: LIST
2574: LIST
2575: PPUSH
2576: CALL_OW 69
2580: PUSH
2581: LD_INT 0
2583: EQUAL
2584: AND
2585: IFFALSE 2599
2587: GO 2589
2589: DISABLE
// begin enable ;
2590: ENABLE
// alfa_support := false ;
2591: LD_ADDR_EXP 13
2595: PUSH
2596: LD_INT 0
2598: ST_TO_ADDR
// end ; end_of_file
2599: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2600: LD_INT 0
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// uc_side := side ;
2606: LD_ADDR_OWVAR 20
2610: PUSH
2611: LD_VAR 0 1
2615: ST_TO_ADDR
// uc_nation := nat ;
2616: LD_ADDR_OWVAR 21
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// team := [ ] ;
2626: LD_ADDR_VAR 0 10
2630: PUSH
2631: EMPTY
2632: ST_TO_ADDR
// hc_importance := 100 ;
2633: LD_ADDR_OWVAR 32
2637: PUSH
2638: LD_INT 100
2640: ST_TO_ADDR
// case commander of jakes :
2641: LD_VAR 0 4
2645: PUSH
2646: LD_STRING jakes
2648: DOUBLE
2649: EQUAL
2650: IFTRUE 2654
2652: GO 2731
2654: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2655: LD_INT 1
2657: PPUSH
2658: LD_INT 1
2660: PPUSH
2661: LD_VAR 0 5
2665: PPUSH
2666: CALL_OW 380
// hc_gallery := pkremaster ;
2670: LD_ADDR_OWVAR 33
2674: PUSH
2675: LD_STRING pkremaster
2677: ST_TO_ADDR
// hc_face_number := 12 ;
2678: LD_ADDR_OWVAR 34
2682: PUSH
2683: LD_INT 12
2685: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2686: LD_ADDR_OWVAR 26
2690: PUSH
2691: LD_STRING Jan van Jakes
2693: ST_TO_ADDR
// houten := CreateHuman ;
2694: LD_ADDR_EXP 4
2698: PUSH
2699: CALL_OW 44
2703: ST_TO_ADDR
// LogHuman ( houten ) ;
2704: LD_EXP 4
2708: PPUSH
2709: CALL 7930 0 1
// team := team ^ houten ;
2713: LD_ADDR_VAR 0 10
2717: PUSH
2718: LD_VAR 0 10
2722: PUSH
2723: LD_EXP 4
2727: ADD
2728: ST_TO_ADDR
// end ; sylvia :
2729: GO 2817
2731: LD_STRING sylvia
2733: DOUBLE
2734: EQUAL
2735: IFTRUE 2739
2737: GO 2816
2739: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2740: LD_INT 2
2742: PPUSH
2743: LD_INT 1
2745: PPUSH
2746: LD_VAR 0 5
2750: PPUSH
2751: CALL_OW 380
// hc_gallery := pkremaster ;
2755: LD_ADDR_OWVAR 33
2759: PUSH
2760: LD_STRING pkremaster
2762: ST_TO_ADDR
// hc_face_number := 13 ;
2763: LD_ADDR_OWVAR 34
2767: PUSH
2768: LD_INT 13
2770: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2771: LD_ADDR_OWVAR 26
2775: PUSH
2776: LD_STRING Sylvia Johnson
2778: ST_TO_ADDR
// brown := CreateHuman ;
2779: LD_ADDR_EXP 5
2783: PUSH
2784: CALL_OW 44
2788: ST_TO_ADDR
// LogHuman ( brown ) ;
2789: LD_EXP 5
2793: PPUSH
2794: CALL 7930 0 1
// team := team ^ brown ;
2798: LD_ADDR_VAR 0 10
2802: PUSH
2803: LD_VAR 0 10
2807: PUSH
2808: LD_EXP 5
2812: ADD
2813: ST_TO_ADDR
// end ; end ;
2814: GO 2817
2816: POP
// hc_gallery :=  ;
2817: LD_ADDR_OWVAR 33
2821: PUSH
2822: LD_STRING 
2824: ST_TO_ADDR
// hc_name :=  ;
2825: LD_ADDR_OWVAR 26
2829: PUSH
2830: LD_STRING 
2832: ST_TO_ADDR
// hc_importance := 0 ;
2833: LD_ADDR_OWVAR 32
2837: PUSH
2838: LD_INT 0
2840: ST_TO_ADDR
// for i = 1 to num do
2841: LD_ADDR_VAR 0 8
2845: PUSH
2846: DOUBLE
2847: LD_INT 1
2849: DEC
2850: ST_TO_ADDR
2851: LD_VAR 0 6
2855: PUSH
2856: FOR_TO
2857: IFFALSE 2921
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2859: LD_INT 0
2861: PPUSH
2862: LD_VAR 0 8
2866: PUSH
2867: LD_INT 4
2869: MOD
2870: PUSH
2871: LD_INT 1
2873: PLUS
2874: PPUSH
2875: LD_VAR 0 5
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 9
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// LogHuman ( un ) ;
2894: LD_VAR 0 9
2898: PPUSH
2899: CALL 7930 0 1
// team := team ^ un ;
2903: LD_ADDR_VAR 0 10
2907: PUSH
2908: LD_VAR 0 10
2912: PUSH
2913: LD_VAR 0 9
2917: ADD
2918: ST_TO_ADDR
// end ;
2919: GO 2856
2921: POP
2922: POP
// for i = 1 to team do
2923: LD_ADDR_VAR 0 8
2927: PUSH
2928: DOUBLE
2929: LD_INT 1
2931: DEC
2932: ST_TO_ADDR
2933: LD_VAR 0 10
2937: PUSH
2938: FOR_TO
2939: IFFALSE 2966
// PlaceUnitArea ( team [ i ] , area , false ) ;
2941: LD_VAR 0 10
2945: PUSH
2946: LD_VAR 0 8
2950: ARRAY
2951: PPUSH
2952: LD_VAR 0 3
2956: PPUSH
2957: LD_INT 0
2959: PPUSH
2960: CALL_OW 49
2964: GO 2938
2966: POP
2967: POP
// end ;
2968: LD_VAR 0 7
2972: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
2973: LD_INT 0
2975: PPUSH
2976: PPUSH
// for i = 1 to n1 do
2977: LD_ADDR_VAR 0 6
2981: PUSH
2982: DOUBLE
2983: LD_INT 1
2985: DEC
2986: ST_TO_ADDR
2987: LD_VAR 0 1
2991: PUSH
2992: FOR_TO
2993: IFFALSE 3015
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
2995: LD_INT 1
2997: PPUSH
2998: LD_INT 1
3000: PPUSH
3001: LD_VAR 0 4
3005: PPUSH
3006: LD_INT 0
3008: PPUSH
3009: CALL_OW 59
3013: GO 2992
3015: POP
3016: POP
// for i = 1 to n2 do
3017: LD_ADDR_VAR 0 6
3021: PUSH
3022: DOUBLE
3023: LD_INT 1
3025: DEC
3026: ST_TO_ADDR
3027: LD_VAR 0 2
3031: PUSH
3032: FOR_TO
3033: IFFALSE 3055
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3035: LD_INT 2
3037: PPUSH
3038: LD_INT 1
3040: PPUSH
3041: LD_VAR 0 4
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 59
3053: GO 3032
3055: POP
3056: POP
// for i = 1 to n3 do
3057: LD_ADDR_VAR 0 6
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_VAR 0 3
3071: PUSH
3072: FOR_TO
3073: IFFALSE 3095
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3075: LD_INT 3
3077: PPUSH
3078: LD_INT 1
3080: PPUSH
3081: LD_VAR 0 4
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 59
3093: GO 3072
3095: POP
3096: POP
// end ; end_of_file
3097: LD_VAR 0 5
3101: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3102: LD_INT 0
3104: PPUSH
3105: PPUSH
3106: PPUSH
3107: PPUSH
3108: PPUSH
3109: PPUSH
// uc_side := your_side ;
3110: LD_ADDR_OWVAR 20
3114: PUSH
3115: LD_OWVAR 2
3119: ST_TO_ADDR
// uc_nation := nation_russian ;
3120: LD_ADDR_OWVAR 21
3124: PUSH
3125: LD_INT 3
3127: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3128: LD_ADDR_EXP 18
3132: PUSH
3133: LD_STRING Gladkov
3135: PPUSH
3136: CALL_OW 25
3140: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3141: LD_ADDR_EXP 19
3145: PUSH
3146: LD_STRING Davidov
3148: PPUSH
3149: CALL_OW 25
3153: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3154: LD_ADDR_EXP 20
3158: PUSH
3159: LD_STRING Burlak
3161: PPUSH
3162: CALL_OW 25
3166: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3167: LD_ADDR_EXP 21
3171: PUSH
3172: LD_STRING Stolypin
3174: PPUSH
3175: CALL_OW 25
3179: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3180: LD_ADDR_EXP 16
3184: PUSH
3185: LD_EXP 18
3189: PUSH
3190: LD_EXP 19
3194: PUSH
3195: LD_EXP 20
3199: PUSH
3200: LD_EXP 21
3204: PUSH
3205: EMPTY
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3211: LD_ADDR_EXP 23
3215: PUSH
3216: LD_EXP 16
3220: PUSH
3221: LD_VAR 0 1
3225: ARRAY
3226: ST_TO_ADDR
// team := [ ] ;
3227: LD_ADDR_VAR 0 6
3231: PUSH
3232: EMPTY
3233: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3234: LD_ADDR_VAR 0 4
3238: PUSH
3239: LD_INT 4
3241: PUSH
3242: LD_INT 3
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_OWVAR 67
3257: ARRAY
3258: ST_TO_ADDR
// uc_side := 3 ;
3259: LD_ADDR_OWVAR 20
3263: PUSH
3264: LD_INT 3
3266: ST_TO_ADDR
// uc_nation := 3 ;
3267: LD_ADDR_OWVAR 21
3271: PUSH
3272: LD_INT 3
3274: ST_TO_ADDR
// hc_gallery :=  ;
3275: LD_ADDR_OWVAR 33
3279: PUSH
3280: LD_STRING 
3282: ST_TO_ADDR
// hc_name :=  ;
3283: LD_ADDR_OWVAR 26
3287: PUSH
3288: LD_STRING 
3290: ST_TO_ADDR
// hc_importance := 0 ;
3291: LD_ADDR_OWVAR 32
3295: PUSH
3296: LD_INT 0
3298: ST_TO_ADDR
// case player_com of gladkov :
3299: LD_EXP 23
3303: PUSH
3304: LD_EXP 18
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3459
3314: POP
// begin for i = 1 to 10 do
3315: LD_ADDR_VAR 0 3
3319: PUSH
3320: DOUBLE
3321: LD_INT 1
3323: DEC
3324: ST_TO_ADDR
3325: LD_INT 10
3327: PUSH
3328: FOR_TO
3329: IFFALSE 3368
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3331: LD_INT 0
3333: PPUSH
3334: LD_INT 1
3336: PPUSH
3337: LD_VAR 0 4
3341: PUSH
3342: LD_INT 1
3344: PLUS
3345: PPUSH
3346: CALL_OW 380
// team := team ^ CreateHuman ;
3350: LD_ADDR_VAR 0 6
3354: PUSH
3355: LD_VAR 0 6
3359: PUSH
3360: CALL_OW 44
3364: ADD
3365: ST_TO_ADDR
// end ;
3366: GO 3328
3368: POP
3369: POP
// for i = 1 to 15 do
3370: LD_ADDR_VAR 0 3
3374: PUSH
3375: DOUBLE
3376: LD_INT 1
3378: DEC
3379: ST_TO_ADDR
3380: LD_INT 15
3382: PUSH
3383: FOR_TO
3384: IFFALSE 3429
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3386: LD_INT 0
3388: PPUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MOD
3397: PUSH
3398: LD_INT 2
3400: PLUS
3401: PPUSH
3402: LD_VAR 0 4
3406: PPUSH
3407: CALL_OW 380
// team := team ^ CreateHuman ;
3411: LD_ADDR_VAR 0 6
3415: PUSH
3416: LD_VAR 0 6
3420: PUSH
3421: CALL_OW 44
3425: ADD
3426: ST_TO_ADDR
// end ;
3427: GO 3383
3429: POP
3430: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3431: LD_INT 44
3433: PPUSH
3434: LD_INT 3
3436: PPUSH
3437: LD_INT 1
3439: PPUSH
3440: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3444: LD_INT 34
3446: PPUSH
3447: LD_INT 3
3449: PPUSH
3450: LD_INT 1
3452: PPUSH
3453: CALL_OW 322
// end ; davidov :
3457: GO 4360
3459: LD_EXP 19
3463: DOUBLE
3464: EQUAL
3465: IFTRUE 3469
3467: GO 3762
3469: POP
// begin for i = 1 to 10 do
3470: LD_ADDR_VAR 0 3
3474: PUSH
3475: DOUBLE
3476: LD_INT 1
3478: DEC
3479: ST_TO_ADDR
3480: LD_INT 10
3482: PUSH
3483: FOR_TO
3484: IFFALSE 3523
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3486: LD_INT 0
3488: PPUSH
3489: LD_INT 4
3491: PPUSH
3492: LD_VAR 0 4
3496: PUSH
3497: LD_INT 1
3499: PLUS
3500: PPUSH
3501: CALL_OW 380
// team := team ^ CreateHuman ;
3505: LD_ADDR_VAR 0 6
3509: PUSH
3510: LD_VAR 0 6
3514: PUSH
3515: CALL_OW 44
3519: ADD
3520: ST_TO_ADDR
// end ;
3521: GO 3483
3523: POP
3524: POP
// for i = 1 to 15 do
3525: LD_ADDR_VAR 0 3
3529: PUSH
3530: DOUBLE
3531: LD_INT 1
3533: DEC
3534: ST_TO_ADDR
3535: LD_INT 15
3537: PUSH
3538: FOR_TO
3539: IFFALSE 3584
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3541: LD_INT 0
3543: PPUSH
3544: LD_VAR 0 3
3548: PUSH
3549: LD_INT 3
3551: MOD
3552: PUSH
3553: LD_INT 1
3555: PLUS
3556: PPUSH
3557: LD_VAR 0 4
3561: PPUSH
3562: CALL_OW 380
// team := team ^ CreateHuman ;
3566: LD_ADDR_VAR 0 6
3570: PUSH
3571: LD_VAR 0 6
3575: PUSH
3576: CALL_OW 44
3580: ADD
3581: ST_TO_ADDR
// end ;
3582: GO 3538
3584: POP
3585: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3586: LD_INT 34
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 1
3594: PPUSH
3595: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3599: LD_INT 32
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3612: LD_INT 27
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: LD_INT 1
3620: PPUSH
3621: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3625: LD_INT 30
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3638: LD_INT 63
3640: PPUSH
3641: LD_INT 3
3643: PPUSH
3644: LD_INT 1
3646: PPUSH
3647: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3651: LD_INT 57
3653: PPUSH
3654: LD_INT 3
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3664: LD_INT 58
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 1
3672: PPUSH
3673: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3677: LD_INT 8
3679: PPUSH
3680: LD_INT 3
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3690: LD_INT 12
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3703: LD_INT 14
3705: PPUSH
3706: LD_INT 3
3708: PPUSH
3709: LD_INT 1
3711: PPUSH
3712: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3716: LD_INT 24
3718: PPUSH
3719: LD_INT 3
3721: PPUSH
3722: LD_INT 1
3724: PPUSH
3725: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3729: LD_INT 33
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: LD_INT 1
3737: PPUSH
3738: CALL_OW 324
// SetResourceType ( GetBase ( player_depot ) , 3 , 20 ) ;
3742: LD_INT 1
3744: PPUSH
3745: CALL_OW 274
3749: PPUSH
3750: LD_INT 3
3752: PPUSH
3753: LD_INT 20
3755: PPUSH
3756: CALL_OW 277
// end ; gorki :
3760: GO 4360
3762: LD_EXP 20
3766: DOUBLE
3767: EQUAL
3768: IFTRUE 3772
3770: GO 4053
3772: POP
// begin for i = 1 to 10 do
3773: LD_ADDR_VAR 0 3
3777: PUSH
3778: DOUBLE
3779: LD_INT 1
3781: DEC
3782: ST_TO_ADDR
3783: LD_INT 10
3785: PUSH
3786: FOR_TO
3787: IFFALSE 3841
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3789: LD_INT 0
3791: PPUSH
3792: LD_INT 3
3794: PPUSH
3795: LD_VAR 0 4
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: PPUSH
3804: CALL_OW 380
// team := team ^ CreateHuman ;
3808: LD_ADDR_VAR 0 6
3812: PUSH
3813: LD_VAR 0 6
3817: PUSH
3818: CALL_OW 44
3822: ADD
3823: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3824: LD_VAR 0 6
3828: PUSH
3829: LD_VAR 0 6
3833: ARRAY
3834: PPUSH
3835: CALL 7930 0 1
// end ;
3839: GO 3786
3841: POP
3842: POP
// for i = 1 to 15 do
3843: LD_ADDR_VAR 0 3
3847: PUSH
3848: DOUBLE
3849: LD_INT 1
3851: DEC
3852: ST_TO_ADDR
3853: LD_INT 15
3855: PUSH
3856: FOR_TO
3857: IFFALSE 3930
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 1
3864: PUSH
3865: LD_INT 2
3867: PUSH
3868: LD_INT 4
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 1
3878: PPUSH
3879: LD_INT 3
3881: PPUSH
3882: CALL_OW 12
3886: ARRAY
3887: PPUSH
3888: LD_VAR 0 4
3892: PPUSH
3893: CALL_OW 380
// team := team ^ CreateHuman ;
3897: LD_ADDR_VAR 0 6
3901: PUSH
3902: LD_VAR 0 6
3906: PUSH
3907: CALL_OW 44
3911: ADD
3912: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3913: LD_VAR 0 6
3917: PUSH
3918: LD_VAR 0 6
3922: ARRAY
3923: PPUSH
3924: CALL 7930 0 1
// end ;
3928: GO 3856
3930: POP
3931: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3932: LD_INT 40
3934: PPUSH
3935: LD_INT 3
3937: PPUSH
3938: LD_INT 1
3940: PPUSH
3941: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3945: LD_INT 34
3947: PPUSH
3948: LD_INT 3
3950: PPUSH
3951: LD_INT 1
3953: PPUSH
3954: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3958: LD_INT 18
3960: PPUSH
3961: LD_INT 3
3963: PPUSH
3964: LD_INT 1
3966: PPUSH
3967: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3971: LD_ADDR_OWVAR 37
3975: PUSH
3976: LD_INT 22
3978: ST_TO_ADDR
// vc_engine := engine_combustion ;
3979: LD_ADDR_OWVAR 39
3983: PUSH
3984: LD_INT 1
3986: ST_TO_ADDR
// vc_control := control_manual ;
3987: LD_ADDR_OWVAR 38
3991: PUSH
3992: LD_INT 1
3994: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3995: LD_ADDR_OWVAR 40
3999: PUSH
4000: LD_INT 45
4002: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4003: LD_ADDR_OWVAR 41
4007: PUSH
4008: LD_INT 3
4010: ST_TO_ADDR
// veh := CreateVehicle ;
4011: LD_ADDR_VAR 0 7
4015: PUSH
4016: CALL_OW 45
4020: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4021: LD_VAR 0 7
4025: PPUSH
4026: LD_INT 1
4028: PPUSH
4029: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4033: LD_VAR 0 7
4037: PPUSH
4038: LD_INT 107
4040: PPUSH
4041: LD_INT 83
4043: PPUSH
4044: LD_INT 0
4046: PPUSH
4047: CALL_OW 48
// end ; stolypin :
4051: GO 4360
4053: LD_EXP 21
4057: DOUBLE
4058: EQUAL
4059: IFTRUE 4063
4061: GO 4359
4063: POP
// begin for i = 1 to 10 do
4064: LD_ADDR_VAR 0 3
4068: PUSH
4069: DOUBLE
4070: LD_INT 1
4072: DEC
4073: ST_TO_ADDR
4074: LD_INT 10
4076: PUSH
4077: FOR_TO
4078: IFFALSE 4117
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4080: LD_INT 0
4082: PPUSH
4083: LD_INT 2
4085: PPUSH
4086: LD_VAR 0 4
4090: PUSH
4091: LD_INT 1
4093: PLUS
4094: PPUSH
4095: CALL_OW 380
// team := team ^ CreateHuman ;
4099: LD_ADDR_VAR 0 6
4103: PUSH
4104: LD_VAR 0 6
4108: PUSH
4109: CALL_OW 44
4113: ADD
4114: ST_TO_ADDR
// end ;
4115: GO 4077
4117: POP
4118: POP
// for i = 1 to 15 do
4119: LD_ADDR_VAR 0 3
4123: PUSH
4124: DOUBLE
4125: LD_INT 1
4127: DEC
4128: ST_TO_ADDR
4129: LD_INT 15
4131: PUSH
4132: FOR_TO
4133: IFFALSE 4191
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4135: LD_INT 0
4137: PPUSH
4138: LD_INT 1
4140: PUSH
4141: LD_INT 3
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: EMPTY
4148: LIST
4149: LIST
4150: LIST
4151: PUSH
4152: LD_INT 1
4154: PPUSH
4155: LD_INT 3
4157: PPUSH
4158: CALL_OW 12
4162: ARRAY
4163: PPUSH
4164: LD_VAR 0 4
4168: PPUSH
4169: CALL_OW 380
// team := team ^ CreateHuman ;
4173: LD_ADDR_VAR 0 6
4177: PUSH
4178: LD_VAR 0 6
4182: PUSH
4183: CALL_OW 44
4187: ADD
4188: ST_TO_ADDR
// end ;
4189: GO 4132
4191: POP
4192: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4193: LD_INT 34
4195: PPUSH
4196: LD_INT 3
4198: PPUSH
4199: LD_INT 1
4201: PPUSH
4202: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4206: LD_ADDR_OWVAR 37
4210: PUSH
4211: LD_INT 22
4213: ST_TO_ADDR
// vc_engine := engine_combustion ;
4214: LD_ADDR_OWVAR 39
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// vc_control := control_manual ;
4222: LD_ADDR_OWVAR 38
4226: PUSH
4227: LD_INT 1
4229: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4230: LD_ADDR_OWVAR 40
4234: PUSH
4235: LD_INT 51
4237: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4238: LD_ADDR_OWVAR 41
4242: PUSH
4243: LD_INT 30
4245: ST_TO_ADDR
// veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 7
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4256: LD_VAR 0 7
4260: PPUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 100
4266: PPUSH
4267: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4271: LD_VAR 0 7
4275: PPUSH
4276: LD_INT 107
4278: PPUSH
4279: LD_INT 83
4281: PPUSH
4282: LD_INT 0
4284: PPUSH
4285: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4289: LD_ADDR_OWVAR 37
4293: PUSH
4294: LD_INT 22
4296: ST_TO_ADDR
// vc_engine := engine_combustion ;
4297: LD_ADDR_OWVAR 39
4301: PUSH
4302: LD_INT 1
4304: ST_TO_ADDR
// vc_control := control_manual ;
4305: LD_ADDR_OWVAR 38
4309: PUSH
4310: LD_INT 1
4312: ST_TO_ADDR
// vc_weapon := ru_crane ;
4313: LD_ADDR_OWVAR 40
4317: PUSH
4318: LD_INT 52
4320: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4321: LD_ADDR_OWVAR 41
4325: PUSH
4326: LD_INT 30
4328: ST_TO_ADDR
// veh := CreateVehicle ;
4329: LD_ADDR_VAR 0 7
4333: PUSH
4334: CALL_OW 45
4338: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4339: LD_VAR 0 7
4343: PPUSH
4344: LD_INT 115
4346: PPUSH
4347: LD_INT 96
4349: PPUSH
4350: LD_INT 0
4352: PPUSH
4353: CALL_OW 48
// end ; end ;
4357: GO 4360
4359: POP
// if isTest then
4360: LD_EXP 1
4364: IFFALSE 4378
// tmp := team else
4366: LD_ADDR_VAR 0 5
4370: PUSH
4371: LD_VAR 0 6
4375: ST_TO_ADDR
4376: GO 4469
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , class_engineer , class_mechanic , class_scientistic ] ) ;
4378: LD_ADDR_VAR 0 5
4382: PUSH
4383: LD_STRING text
4385: PPUSH
4386: LD_INT 10
4388: PUSH
4389: LD_INT 9
4391: PUSH
4392: LD_INT 8
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: PPUSH
4406: LD_INT 10
4408: PUSH
4409: LD_INT 9
4411: PUSH
4412: LD_INT 8
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PUSH
4420: LD_OWVAR 67
4424: ARRAY
4425: PPUSH
4426: LD_INT -2
4428: PUSH
4429: LD_INT -5
4431: PUSH
4432: LD_INT -3
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_VAR 0 6
4444: ADD
4445: PPUSH
4446: LD_INT 1
4448: PUSH
4449: LD_INT 2
4451: PUSH
4452: LD_INT 3
4454: PUSH
4455: LD_INT 4
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PPUSH
4464: CALL_OW 42
4468: ST_TO_ADDR
// SetDir ( player_com , 4 ) ;
4469: LD_EXP 23
4473: PPUSH
4474: LD_INT 4
4476: PPUSH
4477: CALL_OW 233
// PlaceUnitArea ( player_com , east_arr , false ) ;
4481: LD_EXP 23
4485: PPUSH
4486: LD_INT 18
4488: PPUSH
4489: LD_INT 0
4491: PPUSH
4492: CALL_OW 49
// ComHold ( player_com ) ;
4496: LD_EXP 23
4500: PPUSH
4501: CALL_OW 140
// for i in tmp do
4505: LD_ADDR_VAR 0 3
4509: PUSH
4510: LD_VAR 0 5
4514: PUSH
4515: FOR_IN
4516: IFFALSE 4532
// SetSide ( i , 6 ) ;
4518: LD_VAR 0 3
4522: PPUSH
4523: LD_INT 6
4525: PPUSH
4526: CALL_OW 235
4530: GO 4515
4532: POP
4533: POP
// for i = 1 to 4 do
4534: LD_ADDR_VAR 0 3
4538: PUSH
4539: DOUBLE
4540: LD_INT 1
4542: DEC
4543: ST_TO_ADDR
4544: LD_INT 4
4546: PUSH
4547: FOR_TO
4548: IFFALSE 4611
// begin SetDir ( tmp [ 1 ] , 4 ) ;
4550: LD_VAR 0 5
4554: PUSH
4555: LD_INT 1
4557: ARRAY
4558: PPUSH
4559: LD_INT 4
4561: PPUSH
4562: CALL_OW 233
// PlaceUnitXYR ( tmp [ 1 ] , 104 , 88 , 3 , false ) ;
4566: LD_VAR 0 5
4570: PUSH
4571: LD_INT 1
4573: ARRAY
4574: PPUSH
4575: LD_INT 104
4577: PPUSH
4578: LD_INT 88
4580: PPUSH
4581: LD_INT 3
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: CALL_OW 50
// tmp := Delete ( tmp , 1 ) ;
4591: LD_ADDR_VAR 0 5
4595: PUSH
4596: LD_VAR 0 5
4600: PPUSH
4601: LD_INT 1
4603: PPUSH
4604: CALL_OW 3
4608: ST_TO_ADDR
// end ;
4609: GO 4547
4611: POP
4612: POP
// player_squad := tmp ;
4613: LD_ADDR_EXP 22
4617: PUSH
4618: LD_VAR 0 5
4622: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4623: LD_INT 17
4625: PPUSH
4626: LD_INT 5
4628: PPUSH
4629: LD_INT 1
4631: PPUSH
4632: CALL 18380 0 3
// end ;
4636: LD_VAR 0 2
4640: RET
// export Popov ; export function InitAction ; var commander ; begin
4641: LD_INT 0
4643: PPUSH
4644: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4645: LD_INT 6
4647: PPUSH
4648: LD_INT 3
4650: PPUSH
4651: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4655: LD_INT 1
4657: PPUSH
4658: LD_INT 1
4660: PPUSH
4661: CALL_OW 86
// uc_side := 6 ;
4665: LD_ADDR_OWVAR 20
4669: PUSH
4670: LD_INT 6
4672: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4673: LD_ADDR_EXP 24
4677: PUSH
4678: LD_STRING Popov
4680: PPUSH
4681: CALL_OW 25
4685: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4686: LD_ADDR_OWVAR 67
4690: PUSH
4691: LD_INT 0
4693: PPUSH
4694: CALL_OW 426
4698: ST_TO_ADDR
// if not Difficulty then
4699: LD_OWVAR 67
4703: NOT
4704: IFFALSE 4714
// Difficulty := 2 ;
4706: LD_ADDR_OWVAR 67
4710: PUSH
4711: LD_INT 2
4713: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4714: LD_ADDR_VAR 0 2
4718: PUSH
4719: LD_INT 1
4721: PPUSH
4722: CALL_OW 426
4726: ST_TO_ADDR
// if not commander then
4727: LD_VAR 0 2
4731: NOT
4732: IFFALSE 4742
// commander := 1 ;
4734: LD_ADDR_VAR 0 2
4738: PUSH
4739: LD_INT 1
4741: ST_TO_ADDR
// InitCommanders ( commander ) ;
4742: LD_VAR 0 2
4746: PPUSH
4747: CALL 3102 0 1
// end ;
4751: LD_VAR 0 1
4755: RET
// every 1 1$45 trigger player_squad do var i ;
4756: LD_EXP 22
4760: IFFALSE 4877
4762: GO 4764
4764: DISABLE
4765: LD_INT 0
4767: PPUSH
// begin enable ;
4768: ENABLE
// for i := 1 to 3 do
4769: LD_ADDR_VAR 0 1
4773: PUSH
4774: DOUBLE
4775: LD_INT 1
4777: DEC
4778: ST_TO_ADDR
4779: LD_INT 3
4781: PUSH
4782: FOR_TO
4783: IFFALSE 4875
// begin if player_squad < i then
4785: LD_EXP 22
4789: PUSH
4790: LD_VAR 0 1
4794: LESS
4795: IFFALSE 4801
// exit ;
4797: POP
4798: POP
4799: GO 4877
// PlaceUnitArea ( player_squad [ 1 ] , east_arr , false ) ;
4801: LD_EXP 22
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PPUSH
4810: LD_INT 18
4812: PPUSH
4813: LD_INT 0
4815: PPUSH
4816: CALL_OW 49
// ComMoveXY ( player_squad [ 1 ] , 107 , 88 ) ;
4820: LD_EXP 22
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 107
4831: PPUSH
4832: LD_INT 88
4834: PPUSH
4835: CALL_OW 111
// SetSide ( player_squad [ 1 ] , 3 ) ;
4839: LD_EXP 22
4843: PUSH
4844: LD_INT 1
4846: ARRAY
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 235
// player_squad := Delete ( player_squad , 1 ) ;
4855: LD_ADDR_EXP 22
4859: PUSH
4860: LD_EXP 22
4864: PPUSH
4865: LD_INT 1
4867: PPUSH
4868: CALL_OW 3
4872: ST_TO_ADDR
// end ;
4873: GO 4782
4875: POP
4876: POP
// end ;
4877: PPOPN 1
4879: END
// export function Dialog ; var i ; begin
4880: LD_INT 0
4882: PPUSH
4883: PPUSH
// if not isTest then
4884: LD_EXP 1
4888: NOT
4889: IFFALSE 4911
// case query ( task ) of 1 :
4891: LD_STRING task
4893: PPUSH
4894: CALL_OW 97
4898: PUSH
4899: LD_INT 1
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 4910
4907: POP
// ; end ;
4908: GO 4911
4910: POP
// PlaceSeeing ( 105 , 84 , 3 , - 30 ) ;
4911: LD_INT 105
4913: PPUSH
4914: LD_INT 84
4916: PPUSH
4917: LD_INT 3
4919: PPUSH
4920: LD_INT 30
4922: NEG
4923: PPUSH
4924: CALL_OW 330
// RemoveSeeing ( 105 , 84 , 3 ) ;
4928: LD_INT 105
4930: PPUSH
4931: LD_INT 84
4933: PPUSH
4934: LD_INT 3
4936: PPUSH
4937: CALL_OW 331
// InGameOn ;
4941: CALL_OW 8
// CenterNowOnXY ( 128 , 64 ) ;
4945: LD_INT 128
4947: PPUSH
4948: LD_INT 64
4950: PPUSH
4951: CALL_OW 86
// if isTest then
4955: LD_EXP 1
4959: IFFALSE 4969
// dialogue_skipped := true ;
4961: LD_ADDR_OWVAR 59
4965: PUSH
4966: LD_INT 1
4968: ST_TO_ADDR
// SayRadio ( Popov , DR1 ) ;
4969: LD_EXP 24
4973: PPUSH
4974: LD_STRING DR1
4976: PPUSH
4977: CALL_OW 94
// SayRadio ( Popov , DR2 ) ;
4981: LD_EXP 24
4985: PPUSH
4986: LD_STRING DR2
4988: PPUSH
4989: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
4993: LD_EXP 24
4997: PPUSH
4998: LD_STRING DR3
5000: PPUSH
5001: CALL_OW 94
// InGameOff ;
5005: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5009: LD_STRING C1
5011: PPUSH
5012: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
5016: LD_INT 35
5018: PPUSH
5019: CALL_OW 67
// until FilterUnitsInArea ( gaidar_base , [ f_side , 3 ] ) ;
5023: LD_INT 9
5025: PPUSH
5026: LD_INT 22
5028: PUSH
5029: LD_INT 3
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 70
5040: IFFALSE 5016
// for i in FilterUnitsInArea ( gaidar_base , [ f_side , 6 ] ) do
5042: LD_ADDR_VAR 0 2
5046: PUSH
5047: LD_INT 9
5049: PPUSH
5050: LD_INT 22
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: EMPTY
5057: LIST
5058: LIST
5059: PPUSH
5060: CALL_OW 70
5064: PUSH
5065: FOR_IN
5066: IFFALSE 5082
// SetSide ( i , 3 ) ;
5068: LD_VAR 0 2
5072: PPUSH
5073: LD_INT 3
5075: PPUSH
5076: CALL_OW 235
5080: GO 5065
5082: POP
5083: POP
// if not isTest then
5084: LD_EXP 1
5088: NOT
5089: IFFALSE 5111
// case query ( support ) of 1 :
5091: LD_STRING support
5093: PPUSH
5094: CALL_OW 97
5098: PUSH
5099: LD_INT 1
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5110
5107: POP
// ; end ;
5108: GO 5111
5110: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5111: LD_INT 3
5113: PPUSH
5114: LD_INT 12
5116: PPUSH
5117: LD_INT 2
5119: PPUSH
5120: LD_INT 22
5122: PUSH
5123: LD_INT 3
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: LD_INT 30
5132: PUSH
5133: LD_INT 0
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: EMPTY
5141: LIST
5142: LIST
5143: PPUSH
5144: CALL_OW 69
5148: PUSH
5149: LD_INT 1
5151: ARRAY
5152: PPUSH
5153: CALL_OW 468
// if player_com = stolypin then
5157: LD_EXP 23
5161: PUSH
5162: LD_EXP 21
5166: EQUAL
5167: IFFALSE 5196
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5169: LD_INT 18
5171: PPUSH
5172: LD_INT 3
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: LD_INT 2
5180: PUSH
5181: EMPTY
5182: LIST
5183: LIST
5184: LIST
5185: PUSH
5186: LD_OWVAR 67
5190: ARRAY
5191: PPUSH
5192: CALL 6608 0 2
// end ;
5196: LD_VAR 0 1
5200: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5201: LD_EXP 11
5205: PUSH
5206: LD_OWVAR 1
5210: PUSH
5211: LD_INT 31500
5213: LESS
5214: AND
5215: IFFALSE 5383
// case query ( call1 ) of 1 :
5217: LD_STRING call1
5219: PPUSH
5220: CALL_OW 97
5224: PUSH
5225: LD_INT 1
5227: DOUBLE
5228: EQUAL
5229: IFTRUE 5233
5231: GO 5371
5233: POP
// begin callUsed := true ;
5234: LD_ADDR_EXP 3
5238: PUSH
5239: LD_INT 1
5241: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5242: LD_INT 3
5244: PPUSH
5245: LD_INT 12
5247: PPUSH
5248: LD_INT 1
5250: PPUSH
5251: LD_INT 1
5253: PPUSH
5254: CALL_OW 468
// call := false ;
5258: LD_ADDR_EXP 11
5262: PUSH
5263: LD_INT 0
5265: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5266: LD_EXP 24
5270: PPUSH
5271: LD_STRING DR6
5273: PPUSH
5274: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5278: LD_INT 6300
5280: PPUSH
5281: LD_INT 8400
5283: PPUSH
5284: CALL_OW 12
5288: PPUSH
5289: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5293: LD_INT 18
5295: PUSH
5296: LD_INT 19
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_INT 2
5308: PPUSH
5309: CALL_OW 12
5313: ARRAY
5314: PPUSH
5315: LD_INT 1
5317: PPUSH
5318: LD_INT 2
5320: PPUSH
5321: CALL_OW 12
5325: PPUSH
5326: CALL 6608 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5330: LD_INT 25200
5332: PPUSH
5333: LD_INT 35700
5335: PPUSH
5336: CALL_OW 12
5340: PPUSH
5341: CALL_OW 67
// call := true ;
5345: LD_ADDR_EXP 11
5349: PUSH
5350: LD_INT 1
5352: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5353: LD_INT 3
5355: PPUSH
5356: LD_INT 12
5358: PPUSH
5359: LD_INT 2
5361: PPUSH
5362: LD_INT 1
5364: PPUSH
5365: CALL_OW 468
// end ; 2 :
5369: GO 5383
5371: LD_INT 2
5373: DOUBLE
5374: EQUAL
5375: IFTRUE 5379
5377: GO 5382
5379: POP
// ; end ;
5380: GO 5383
5382: POP
// if call and tick >= 15 15$00 then
5383: LD_EXP 11
5387: PUSH
5388: LD_OWVAR 1
5392: PUSH
5393: LD_INT 31500
5395: GREATEREQUAL
5396: AND
5397: IFFALSE 5836
// case query ( call2 ) of 1 :
5399: LD_STRING call2
5401: PPUSH
5402: CALL_OW 97
5406: PUSH
5407: LD_INT 1
5409: DOUBLE
5410: EQUAL
5411: IFTRUE 5415
5413: GO 5657
5415: POP
// begin callUsed := true ;
5416: LD_ADDR_EXP 3
5420: PUSH
5421: LD_INT 1
5423: ST_TO_ADDR
// call := false ;
5424: LD_ADDR_EXP 11
5428: PUSH
5429: LD_INT 0
5431: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5432: LD_INT 1
5434: PPUSH
5435: LD_INT 21
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PPUSH
5445: CALL 11667 0 2
5449: PUSH
5450: LD_INT 4
5452: PPUSH
5453: LD_INT 21
5455: PUSH
5456: LD_INT 3
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: PPUSH
5463: CALL 11667 0 2
5467: AND
5468: IFFALSE 5516
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5470: LD_INT 18
5472: PUSH
5473: LD_INT 19
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 1
5482: PPUSH
5483: LD_INT 2
5485: PPUSH
5486: CALL_OW 12
5490: ARRAY
5491: PPUSH
5492: LD_INT 5
5494: PUSH
5495: LD_INT 4
5497: PUSH
5498: LD_INT 4
5500: PUSH
5501: EMPTY
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: LD_OWVAR 67
5510: ARRAY
5511: PPUSH
5512: CALL 6369 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 21
5521: PUSH
5522: LD_INT 3
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL 11667 0 2
5533: PUSH
5534: LD_INT 0
5536: EQUAL
5537: IFFALSE 5566
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5539: LD_INT 19
5541: PPUSH
5542: LD_INT 5
5544: PUSH
5545: LD_INT 4
5547: PUSH
5548: LD_INT 3
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: LIST
5555: PUSH
5556: LD_OWVAR 67
5560: ARRAY
5561: PPUSH
5562: CALL 6369 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5566: LD_INT 4
5568: PPUSH
5569: LD_INT 21
5571: PUSH
5572: LD_INT 3
5574: PUSH
5575: EMPTY
5576: LIST
5577: LIST
5578: PPUSH
5579: CALL 11667 0 2
5583: PUSH
5584: LD_INT 0
5586: EQUAL
5587: IFFALSE 5616
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5589: LD_INT 18
5591: PPUSH
5592: LD_INT 5
5594: PUSH
5595: LD_INT 4
5597: PUSH
5598: LD_INT 4
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: PUSH
5606: LD_OWVAR 67
5610: ARRAY
5611: PPUSH
5612: CALL 6369 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5616: LD_INT 10500
5618: PPUSH
5619: LD_INT 23100
5621: PPUSH
5622: CALL_OW 12
5626: PPUSH
5627: CALL_OW 67
// call := true ;
5631: LD_ADDR_EXP 11
5635: PUSH
5636: LD_INT 1
5638: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5639: LD_INT 3
5641: PPUSH
5642: LD_INT 12
5644: PPUSH
5645: LD_INT 2
5647: PPUSH
5648: LD_INT 1
5650: PPUSH
5651: CALL_OW 468
// end ; 2 :
5655: GO 5836
5657: LD_INT 2
5659: DOUBLE
5660: EQUAL
5661: IFTRUE 5665
5663: GO 5824
5665: POP
// begin callUsed := true ;
5666: LD_ADDR_EXP 3
5670: PUSH
5671: LD_INT 1
5673: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5674: LD_INT 3
5676: PPUSH
5677: LD_INT 12
5679: PPUSH
5680: LD_INT 1
5682: PPUSH
5683: LD_INT 1
5685: PPUSH
5686: CALL_OW 468
// call := false ;
5690: LD_ADDR_EXP 11
5694: PUSH
5695: LD_INT 0
5697: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5698: LD_EXP 24
5702: PPUSH
5703: LD_STRING DR6
5705: PPUSH
5706: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5710: LD_INT 6300
5712: PPUSH
5713: LD_INT 8400
5715: PPUSH
5716: CALL_OW 12
5720: PPUSH
5721: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5725: LD_INT 18
5727: PUSH
5728: LD_INT 19
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PUSH
5735: LD_INT 1
5737: PPUSH
5738: LD_INT 2
5740: PPUSH
5741: CALL_OW 12
5745: ARRAY
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: LD_OWVAR 67
5765: ARRAY
5766: PUSH
5767: LD_INT 0
5769: PPUSH
5770: LD_INT 1
5772: PPUSH
5773: CALL_OW 12
5777: MINUS
5778: PPUSH
5779: CALL 6608 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5783: LD_INT 35700
5785: PPUSH
5786: LD_INT 44100
5788: PPUSH
5789: CALL_OW 12
5793: PPUSH
5794: CALL_OW 67
// call := true ;
5798: LD_ADDR_EXP 11
5802: PUSH
5803: LD_INT 1
5805: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5806: LD_INT 3
5808: PPUSH
5809: LD_INT 12
5811: PPUSH
5812: LD_INT 2
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL_OW 468
// end ; 3 :
5822: GO 5836
5824: LD_INT 3
5826: DOUBLE
5827: EQUAL
5828: IFTRUE 5832
5830: GO 5835
5832: POP
// ; end ;
5833: GO 5836
5835: POP
// end ;
5836: PPOPN 4
5838: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5839: LD_INT 22
5841: PUSH
5842: LD_INT 1
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 21
5851: PUSH
5852: LD_INT 1
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PPUSH
5863: CALL_OW 69
5867: PUSH
5868: LD_INT 0
5870: EQUAL
5871: PUSH
5872: LD_INT 22
5874: PUSH
5875: LD_INT 4
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 21
5884: PUSH
5885: LD_INT 1
5887: PUSH
5888: EMPTY
5889: LIST
5890: LIST
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PPUSH
5896: CALL_OW 69
5900: PUSH
5901: LD_INT 0
5903: EQUAL
5904: AND
5905: IFFALSE 6209
5907: GO 5909
5909: DISABLE
// begin DialogueOn ;
5910: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5914: LD_EXP 24
5918: PPUSH
5919: LD_STRING DR7
5921: PPUSH
5922: CALL_OW 94
// case player_com of Gorki :
5926: LD_EXP 23
5930: PUSH
5931: LD_EXP 20
5935: DOUBLE
5936: EQUAL
5937: IFTRUE 5941
5939: GO 5951
5941: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5942: LD_STRING ACH_GORKI
5944: PPUSH
5945: CALL_OW 543
5949: GO 6012
5951: LD_EXP 21
5955: DOUBLE
5956: EQUAL
5957: IFTRUE 5961
5959: GO 5971
5961: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
5962: LD_STRING ACH_STOLYP
5964: PPUSH
5965: CALL_OW 543
5969: GO 6012
5971: LD_EXP 19
5975: DOUBLE
5976: EQUAL
5977: IFTRUE 5981
5979: GO 5991
5981: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
5982: LD_STRING ACH_DAVIDOV
5984: PPUSH
5985: CALL_OW 543
5989: GO 6012
5991: LD_EXP 18
5995: DOUBLE
5996: EQUAL
5997: IFTRUE 6001
5999: GO 6011
6001: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6002: LD_STRING ACH_GLADKOV
6004: PPUSH
6005: CALL_OW 543
6009: GO 6012
6011: POP
// if not callUsed then
6012: LD_EXP 3
6016: NOT
6017: IFFALSE 6026
// SetAchievement ( ACH_NOSUPP ) ;
6019: LD_STRING ACH_NOSUPP
6021: PPUSH
6022: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6026: LD_OWVAR 1
6030: PUSH
6031: LD_INT 116550
6033: PUSH
6034: LD_INT 95550
6036: PUSH
6037: LD_INT 89250
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_OWVAR 67
6049: ARRAY
6050: LESS
6051: IFFALSE 6065
// AddMedal ( med1 , 1 ) else
6053: LD_STRING med1
6055: PPUSH
6056: LD_INT 1
6058: PPUSH
6059: CALL_OW 101
6063: GO 6076
// AddMedal ( med1 , - 1 ) ;
6065: LD_STRING med1
6067: PPUSH
6068: LD_INT 1
6070: NEG
6071: PPUSH
6072: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6076: LD_INT 81
6078: PUSH
6079: LD_INT 3
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PUSH
6086: LD_INT 21
6088: PUSH
6089: LD_INT 3
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: PPUSH
6100: CALL_OW 69
6104: PUSH
6105: LD_INT 0
6107: EQUAL
6108: IFFALSE 6122
// AddMedal ( med3 , 1 ) else
6110: LD_STRING med3
6112: PPUSH
6113: LD_INT 1
6115: PPUSH
6116: CALL_OW 101
6120: GO 6133
// AddMedal ( med3 , - 1 ) ;
6122: LD_STRING med3
6124: PPUSH
6125: LD_INT 1
6127: NEG
6128: PPUSH
6129: CALL_OW 101
// if player_loss = 0 then
6133: LD_EXP 10
6137: PUSH
6138: LD_INT 0
6140: EQUAL
6141: IFFALSE 6155
// AddMedal ( med2 , 1 ) else
6143: LD_STRING med2
6145: PPUSH
6146: LD_INT 1
6148: PPUSH
6149: CALL_OW 101
6153: GO 6198
// if player_loss > 0 and player_loss < 3 then
6155: LD_EXP 10
6159: PUSH
6160: LD_INT 0
6162: GREATER
6163: PUSH
6164: LD_EXP 10
6168: PUSH
6169: LD_INT 3
6171: LESS
6172: AND
6173: IFFALSE 6187
// AddMedal ( med2 , 2 ) else
6175: LD_STRING med2
6177: PPUSH
6178: LD_INT 2
6180: PPUSH
6181: CALL_OW 101
6185: GO 6198
// AddMedal ( med2 , - 1 ) ;
6187: LD_STRING med2
6189: PPUSH
6190: LD_INT 1
6192: NEG
6193: PPUSH
6194: CALL_OW 101
// GiveMedals ( MAIN ) ;
6198: LD_STRING MAIN
6200: PPUSH
6201: CALL_OW 102
// YouWin ;
6205: CALL_OW 103
// end ;
6209: END
// every 0 0$01 trigger IsDead ( player_com ) do
6210: LD_EXP 23
6214: PPUSH
6215: CALL_OW 301
6219: IFFALSE 6286
6221: GO 6223
6223: DISABLE
// begin if IsLive ( Houten ) then
6224: LD_EXP 4
6228: PPUSH
6229: CALL_OW 300
6233: IFFALSE 6249
// SayRadio ( Houten , DJ5 ) else
6235: LD_EXP 4
6239: PPUSH
6240: LD_STRING DJ5
6242: PPUSH
6243: CALL_OW 94
6247: GO 6272
// if IsLive ( Brown ) then
6249: LD_EXP 5
6253: PPUSH
6254: CALL_OW 300
6258: IFFALSE 6272
// SayRadio ( Brown , DS5 ) ;
6260: LD_EXP 5
6264: PPUSH
6265: LD_STRING DS5
6267: PPUSH
6268: CALL_OW 94
// Wait ( 0 0$01 ) ;
6272: LD_INT 35
6274: PPUSH
6275: CALL_OW 67
// YouLost ( dead ) ;
6279: LD_STRING dead
6281: PPUSH
6282: CALL_OW 104
// end ;
6286: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6287: LD_INT 1
6289: PPUSH
6290: CALL_OW 301
6294: PUSH
6295: LD_EXP 1
6299: NOT
6300: AND
6301: IFFALSE 6368
6303: GO 6305
6305: DISABLE
// begin if IsLive ( Brown ) then
6306: LD_EXP 5
6310: PPUSH
6311: CALL_OW 300
6315: IFFALSE 6331
// SayRadio ( Brown , DS5 ) else
6317: LD_EXP 5
6321: PPUSH
6322: LD_STRING DS5
6324: PPUSH
6325: CALL_OW 94
6329: GO 6354
// if IsLive ( Houten ) then
6331: LD_EXP 4
6335: PPUSH
6336: CALL_OW 300
6340: IFFALSE 6354
// SayRadio ( Houten , DJ5 ) ;
6342: LD_EXP 4
6346: PPUSH
6347: LD_STRING DJ5
6349: PPUSH
6350: CALL_OW 94
// Wait ( 0 0$01 ) ;
6354: LD_INT 35
6356: PPUSH
6357: CALL_OW 67
// YouLost ( depot ) ;
6361: LD_STRING depot
6363: PPUSH
6364: CALL_OW 104
// end ;
6368: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6369: LD_INT 0
6371: PPUSH
6372: PPUSH
6373: PPUSH
// for i = 1 to n do
6374: LD_ADDR_VAR 0 4
6378: PUSH
6379: DOUBLE
6380: LD_INT 1
6382: DEC
6383: ST_TO_ADDR
6384: LD_VAR 0 2
6388: PUSH
6389: FOR_TO
6390: IFFALSE 6593
// begin uc_side := 6 ;
6392: LD_ADDR_OWVAR 20
6396: PUSH
6397: LD_INT 6
6399: ST_TO_ADDR
// uc_nation := 3 ;
6400: LD_ADDR_OWVAR 21
6404: PUSH
6405: LD_INT 3
6407: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6408: LD_ADDR_OWVAR 37
6412: PUSH
6413: LD_INT 23
6415: PUSH
6416: LD_INT 22
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ARRAY
6434: ST_TO_ADDR
// vc_control := control_computer ;
6435: LD_ADDR_OWVAR 38
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// vc_engine := engine_siberite ;
6443: LD_ADDR_OWVAR 39
6447: PUSH
6448: LD_INT 3
6450: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6451: LD_ADDR_OWVAR 40
6455: PUSH
6456: LD_INT 43
6458: PUSH
6459: LD_INT 44
6461: PUSH
6462: LD_INT 44
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 1
6472: PPUSH
6473: LD_INT 3
6475: PPUSH
6476: CALL_OW 12
6480: ARRAY
6481: ST_TO_ADDR
// un := CreateVehicle ;
6482: LD_ADDR_VAR 0 5
6486: PUSH
6487: CALL_OW 45
6491: ST_TO_ADDR
// case area of east_arr :
6492: LD_VAR 0 1
6496: PUSH
6497: LD_INT 18
6499: DOUBLE
6500: EQUAL
6501: IFTRUE 6505
6503: GO 6540
6505: POP
// begin PlaceUnitArea ( un , area , false ) ;
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6523: LD_VAR 0 5
6527: PPUSH
6528: LD_INT 79
6530: PPUSH
6531: LD_INT 33
6533: PPUSH
6534: CALL_OW 111
// end ; south_arr :
6538: GO 6584
6540: LD_INT 19
6542: DOUBLE
6543: EQUAL
6544: IFTRUE 6548
6546: GO 6583
6548: POP
// begin PlaceUnitArea ( un , area , false ) ;
6549: LD_VAR 0 5
6553: PPUSH
6554: LD_VAR 0 1
6558: PPUSH
6559: LD_INT 0
6561: PPUSH
6562: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6566: LD_VAR 0 5
6570: PPUSH
6571: LD_INT 131
6573: PPUSH
6574: LD_INT 148
6576: PPUSH
6577: CALL_OW 111
// end ; end ;
6581: GO 6584
6583: POP
// Wait ( 0 0$02 ) ;
6584: LD_INT 70
6586: PPUSH
6587: CALL_OW 67
// end ;
6591: GO 6389
6593: POP
6594: POP
// pink_attack := true ;
6595: LD_ADDR_EXP 12
6599: PUSH
6600: LD_INT 1
6602: ST_TO_ADDR
// end ;
6603: LD_VAR 0 3
6607: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6608: LD_INT 0
6610: PPUSH
6611: PPUSH
6612: PPUSH
// for i = 1 to n do
6613: LD_ADDR_VAR 0 4
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6855
// begin uc_side := 6 ;
6631: LD_ADDR_OWVAR 20
6635: PUSH
6636: LD_INT 6
6638: ST_TO_ADDR
// uc_nation := 3 ;
6639: LD_ADDR_OWVAR 21
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6647: LD_INT 0
6649: PPUSH
6650: LD_INT 3
6652: PPUSH
6653: LD_INT 4
6655: PPUSH
6656: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6660: LD_ADDR_OWVAR 37
6664: PUSH
6665: LD_INT 22
6667: ST_TO_ADDR
// vc_control := control_manual ;
6668: LD_ADDR_OWVAR 38
6672: PUSH
6673: LD_INT 1
6675: ST_TO_ADDR
// vc_engine := engine_combustion ;
6676: LD_ADDR_OWVAR 39
6680: PUSH
6681: LD_INT 1
6683: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6684: LD_ADDR_OWVAR 40
6688: PUSH
6689: LD_INT 51
6691: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6692: LD_ADDR_OWVAR 41
6696: PUSH
6697: LD_INT 50
6699: ST_TO_ADDR
// un := CreateVehicle ;
6700: LD_ADDR_VAR 0 5
6704: PUSH
6705: CALL_OW 45
6709: ST_TO_ADDR
// case area of east_arr :
6710: LD_VAR 0 1
6714: PUSH
6715: LD_INT 18
6717: DOUBLE
6718: EQUAL
6719: IFTRUE 6723
6721: GO 6738
6723: POP
// SetDir ( un , 4 ) ; south_arr :
6724: LD_VAR 0 5
6728: PPUSH
6729: LD_INT 4
6731: PPUSH
6732: CALL_OW 233
6736: GO 6762
6738: LD_INT 19
6740: DOUBLE
6741: EQUAL
6742: IFTRUE 6746
6744: GO 6761
6746: POP
// SetDir ( un , 5 ) ; end ;
6747: LD_VAR 0 5
6751: PPUSH
6752: LD_INT 5
6754: PPUSH
6755: CALL_OW 233
6759: GO 6762
6761: POP
// PlaceUnitArea ( un , area , false ) ;
6762: LD_VAR 0 5
6766: PPUSH
6767: LD_VAR 0 1
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6779: CALL_OW 44
6783: PPUSH
6784: LD_VAR 0 5
6788: PPUSH
6789: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6793: LD_VAR 0 5
6797: PPUSH
6798: LD_INT 1
6800: PPUSH
6801: LD_INT 100
6803: PPUSH
6804: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6808: LD_VAR 0 5
6812: PPUSH
6813: LD_INT 106
6815: PPUSH
6816: LD_INT 88
6818: PPUSH
6819: CALL_OW 111
// AddComUnload ( un ) ;
6823: LD_VAR 0 5
6827: PPUSH
6828: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6832: LD_VAR 0 5
6836: PPUSH
6837: LD_VAR 0 1
6841: PPUSH
6842: CALL_OW 173
// Wait ( 0 0$02 ) ;
6846: LD_INT 70
6848: PPUSH
6849: CALL_OW 67
// end ;
6853: GO 6628
6855: POP
6856: POP
// Wait ( 0 0$05 ) ;
6857: LD_INT 175
6859: PPUSH
6860: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6864: LD_INT 6
6866: PPUSH
6867: LD_INT 34
6869: PUSH
6870: LD_INT 51
6872: PUSH
6873: EMPTY
6874: LIST
6875: LIST
6876: PPUSH
6877: CALL 11667 0 2
6881: IFFALSE 7069
// begin wait ( 0 0$01 ) ;
6883: LD_INT 35
6885: PPUSH
6886: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_INT 6
6897: PPUSH
6898: LD_INT 34
6900: PUSH
6901: LD_INT 51
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL 11667 0 2
6912: PUSH
6913: FOR_IN
6914: IFFALSE 7065
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6916: LD_VAR 0 4
6920: PPUSH
6921: LD_INT 9
6923: PPUSH
6924: CALL_OW 308
6928: PUSH
6929: LD_VAR 0 4
6933: PPUSH
6934: CALL 31789 0 1
6938: PPUSH
6939: CALL_OW 258
6943: PUSH
6944: LD_INT 1
6946: EQUAL
6947: AND
6948: PUSH
6949: LD_EXP 9
6953: AND
6954: IFFALSE 6981
// begin Say ( GetDriver ( i ) , Dtran ) ;
6956: LD_VAR 0 4
6960: PPUSH
6961: CALL 31789 0 1
6965: PPUSH
6966: LD_STRING Dtran
6968: PPUSH
6969: CALL_OW 88
// dialog_trans := false ;
6973: LD_ADDR_EXP 9
6977: PUSH
6978: LD_INT 0
6980: ST_TO_ADDR
// end ; if IsIdle ( i ) then
6981: LD_VAR 0 4
6985: PPUSH
6986: CALL_OW 316
6990: IFFALSE 7006
// ComMoveToArea ( i , area ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_VAR 0 1
7001: PPUSH
7002: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_VAR 0 1
7015: PPUSH
7016: CALL_OW 308
7020: PUSH
7021: LD_VAR 0 4
7025: PPUSH
7026: LD_INT 1
7028: PPUSH
7029: CALL_OW 289
7033: PUSH
7034: LD_INT 0
7036: EQUAL
7037: AND
7038: IFFALSE 7063
// begin RemoveUnit ( GetDriver ( i ) ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: CALL 31789 0 1
7049: PPUSH
7050: CALL_OW 64
// RemoveUnit ( i ) ;
7054: LD_VAR 0 4
7058: PPUSH
7059: CALL_OW 64
// end ; end ;
7063: GO 6913
7065: POP
7066: POP
// end ;
7067: GO 6864
// end ;
7069: LD_VAR 0 3
7073: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7074: LD_INT 0
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
// if isTest then
7080: LD_EXP 1
7084: IFFALSE 7088
// exit ;
7086: GO 7533
// for i = 1 to n do
7088: LD_ADDR_VAR 0 4
7092: PUSH
7093: DOUBLE
7094: LD_INT 1
7096: DEC
7097: ST_TO_ADDR
7098: LD_VAR 0 2
7102: PUSH
7103: FOR_TO
7104: IFFALSE 7392
// begin uc_side := 8 ;
7106: LD_ADDR_OWVAR 20
7110: PUSH
7111: LD_INT 8
7113: ST_TO_ADDR
// uc_nation := 1 ;
7114: LD_ADDR_OWVAR 21
7118: PUSH
7119: LD_INT 1
7121: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7122: LD_ADDR_VAR 0 6
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: LD_INT 4
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: LD_INT 1
7143: PPUSH
7144: LD_OWVAR 67
7148: PPUSH
7149: CALL_OW 12
7153: ARRAY
7154: ST_TO_ADDR
// vc_chassis := ch ;
7155: LD_ADDR_OWVAR 37
7159: PUSH
7160: LD_VAR 0 6
7164: ST_TO_ADDR
// vc_control := control_computer ;
7165: LD_ADDR_OWVAR 38
7169: PUSH
7170: LD_INT 3
7172: ST_TO_ADDR
// vc_engine := engine_combustion ;
7173: LD_ADDR_OWVAR 39
7177: PUSH
7178: LD_INT 1
7180: ST_TO_ADDR
// if tick < [ 20 20$00 , 16 16$00 , 14 14$00 ] [ Difficulty ] then
7181: LD_OWVAR 1
7185: PUSH
7186: LD_INT 42000
7188: PUSH
7189: LD_INT 33600
7191: PUSH
7192: LD_INT 29400
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: LESS
7206: IFFALSE 7237
// vc_weapon := [ us_light_gun , us_double_gun ] [ rand ( 1 , 2 ) ] else
7208: LD_ADDR_OWVAR 40
7212: PUSH
7213: LD_INT 3
7215: PUSH
7216: LD_INT 5
7218: PUSH
7219: EMPTY
7220: LIST
7221: LIST
7222: PUSH
7223: LD_INT 1
7225: PPUSH
7226: LD_INT 2
7228: PPUSH
7229: CALL_OW 12
7233: ARRAY
7234: ST_TO_ADDR
7235: GO 7333
// if ch = us_medium_tracked then
7237: LD_VAR 0 6
7241: PUSH
7242: LD_INT 3
7244: EQUAL
7245: IFFALSE 7292
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7247: LD_ADDR_OWVAR 40
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: LD_INT 4
7257: PUSH
7258: LD_INT 5
7260: PUSH
7261: LD_INT 7
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: PUSH
7270: LD_OWVAR 67
7274: PPUSH
7275: LD_OWVAR 67
7279: PUSH
7280: LD_INT 1
7282: PLUS
7283: PPUSH
7284: CALL_OW 12
7288: ARRAY
7289: ST_TO_ADDR
7290: GO 7333
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7292: LD_ADDR_OWVAR 40
7296: PUSH
7297: LD_INT 5
7299: PUSH
7300: LD_INT 6
7302: PUSH
7303: LD_INT 7
7305: PUSH
7306: LD_INT 7
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_INT 1
7317: PPUSH
7318: LD_OWVAR 67
7322: PUSH
7323: LD_INT 1
7325: PLUS
7326: PPUSH
7327: CALL_OW 12
7331: ARRAY
7332: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7333: LD_ADDR_OWVAR 41
7337: PUSH
7338: LD_INT 70
7340: ST_TO_ADDR
// un := CreateVehicle ;
7341: LD_ADDR_VAR 0 5
7345: PUSH
7346: CALL_OW 45
7350: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7351: LD_VAR 0 5
7355: PPUSH
7356: LD_VAR 0 1
7360: PPUSH
7361: LD_INT 0
7363: PPUSH
7364: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7368: LD_VAR 0 5
7372: PPUSH
7373: LD_INT 65
7375: PPUSH
7376: LD_INT 9
7378: PPUSH
7379: CALL_OW 111
// Wait ( 0 0$02 ) ;
7383: LD_INT 70
7385: PPUSH
7386: CALL_OW 67
// end ;
7390: GO 7103
7392: POP
7393: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7394: LD_INT 90
7396: PUSH
7397: LD_INT 80
7399: PUSH
7400: LD_INT 70
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PUSH
7408: LD_OWVAR 67
7412: ARRAY
7413: PPUSH
7414: CALL_OW 13
7418: IFFALSE 7525
// begin uc_side := 8 ;
7420: LD_ADDR_OWVAR 20
7424: PUSH
7425: LD_INT 8
7427: ST_TO_ADDR
// uc_nation := 1 ;
7428: LD_ADDR_OWVAR 21
7432: PUSH
7433: LD_INT 1
7435: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7436: LD_ADDR_OWVAR 37
7440: PUSH
7441: LD_INT 4
7443: ST_TO_ADDR
// vc_control := control_computer ;
7444: LD_ADDR_OWVAR 38
7448: PUSH
7449: LD_INT 3
7451: ST_TO_ADDR
// vc_engine := engine_combustion ;
7452: LD_ADDR_OWVAR 39
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7460: LD_ADDR_OWVAR 40
7464: PUSH
7465: LD_INT 14
7467: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7468: LD_ADDR_OWVAR 41
7472: PUSH
7473: LD_INT 70
7475: ST_TO_ADDR
// un := CreateVehicle ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: CALL_OW 45
7485: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7486: LD_VAR 0 5
7490: PPUSH
7491: LD_VAR 0 1
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7503: LD_VAR 0 5
7507: PPUSH
7508: LD_INT 65
7510: PPUSH
7511: LD_INT 9
7513: PPUSH
7514: CALL_OW 111
// Wait ( 0 0$02 ) ;
7518: LD_INT 70
7520: PPUSH
7521: CALL_OW 67
// end ; alfa_support := true ;
7525: LD_ADDR_EXP 13
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// end ;
7533: LD_VAR 0 3
7537: RET
// every 0 0$01 trigger tick > [ 12 12$00 , 11 11$00 , 10 10$00 ] [ Difficulty ] do var n ;
7538: LD_OWVAR 1
7542: PUSH
7543: LD_INT 25200
7545: PUSH
7546: LD_INT 23100
7548: PUSH
7549: LD_INT 21000
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_OWVAR 67
7561: ARRAY
7562: GREATER
7563: IFFALSE 7708
7565: GO 7567
7567: DISABLE
7568: LD_INT 0
7570: PPUSH
// begin n := [ 3 , 4 , 5 ] [ Difficulty ] ;
7571: LD_ADDR_VAR 0 1
7575: PUSH
7576: LD_INT 3
7578: PUSH
7579: LD_INT 4
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PUSH
7590: LD_OWVAR 67
7594: ARRAY
7595: ST_TO_ADDR
// repeat wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7596: LD_INT 1050
7598: PPUSH
7599: LD_INT 4200
7601: PPUSH
7602: CALL_OW 12
7606: PPUSH
7607: CALL_OW 67
// PrepareAlfaAttack ( north_arr , n ) ;
7611: LD_INT 20
7613: PPUSH
7614: LD_VAR 0 1
7618: PPUSH
7619: CALL 7074 0 2
// if FilterAllUnits ( [ f_side , 8 ] ) then
7623: LD_INT 22
7625: PUSH
7626: LD_INT 8
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PPUSH
7633: CALL_OW 69
7637: IFFALSE 7651
// SayRadio ( Popov , DR5 ) ;
7639: LD_EXP 24
7643: PPUSH
7644: LD_STRING DR5
7646: PPUSH
7647: CALL_OW 94
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7651: LD_INT 8400
7653: PPUSH
7654: LD_INT 12600
7656: PPUSH
7657: CALL_OW 12
7661: PPUSH
7662: CALL_OW 67
// n := n + 1 ;
7666: LD_ADDR_VAR 0 1
7670: PUSH
7671: LD_VAR 0 1
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: ST_TO_ADDR
// if n > 9 then
7680: LD_VAR 0 1
7684: PUSH
7685: LD_INT 9
7687: GREATER
7688: IFFALSE 7698
// n := 9 ;
7690: LD_ADDR_VAR 0 1
7694: PUSH
7695: LD_INT 9
7697: ST_TO_ADDR
// until tick >= 120 120$00 ;
7698: LD_OWVAR 1
7702: PUSH
7703: LD_INT 252000
7705: GREATEREQUAL
7706: IFFALSE 7596
// end ; end_of_file
7708: PPOPN 1
7710: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7711: LD_INT 0
7713: PPUSH
// enable_addtolog := isTest ;
7714: LD_ADDR_OWVAR 81
7718: PUSH
7719: LD_EXP 1
7723: ST_TO_ADDR
// lines_break_limit := 5 ;
7724: LD_ADDR_EXP 26
7728: PUSH
7729: LD_INT 5
7731: ST_TO_ADDR
// lines_break_type := --- ;
7732: LD_ADDR_EXP 27
7736: PUSH
7737: LD_STRING ---
7739: ST_TO_ADDR
// lines_counter := 0 ;
7740: LD_ADDR_EXP 25
7744: PUSH
7745: LD_INT 0
7747: ST_TO_ADDR
// show_line_index := true ;
7748: LD_ADDR_EXP 28
7752: PUSH
7753: LD_INT 1
7755: ST_TO_ADDR
// tick_log := true ;
7756: LD_ADDR_EXP 29
7760: PUSH
7761: LD_INT 1
7763: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7764: LD_STRING ----------SAND OF SIBERIA LOG----------
7766: PPUSH
7767: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7771: LD_STRING Map Name: 
7773: PUSH
7774: LD_OWVAR 68
7778: STR
7779: PPUSH
7780: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7784: LD_STRING Map Number: 
7786: PUSH
7787: LD_OWVAR 70
7791: STR
7792: PPUSH
7793: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7797: LD_STRING Difficulty: 
7799: PUSH
7800: LD_OWVAR 67
7804: STR
7805: PPUSH
7806: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7810: LD_STRING ---------------------------------------
7812: PPUSH
7813: CALL_OW 561
// end ;
7817: LD_VAR 0 1
7821: RET
// function Log ( text ) ; begin
7822: LD_INT 0
7824: PPUSH
// if show_line_index then
7825: LD_EXP 28
7829: IFFALSE 7841
// result := lines_counter ;
7831: LD_ADDR_VAR 0 2
7835: PUSH
7836: LD_EXP 25
7840: ST_TO_ADDR
// if tick_log then
7841: LD_EXP 29
7845: IFFALSE 7871
// result := result &  T:  & tick &   ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 2
7856: PUSH
7857: LD_STRING  T: 
7859: STR
7860: PUSH
7861: LD_OWVAR 1
7865: STR
7866: PUSH
7867: LD_STRING  
7869: STR
7870: ST_TO_ADDR
// AddToLog ( result & text ) ;
7871: LD_VAR 0 2
7875: PUSH
7876: LD_VAR 0 1
7880: STR
7881: PPUSH
7882: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7886: LD_ADDR_EXP 25
7890: PUSH
7891: LD_EXP 25
7895: PUSH
7896: LD_INT 1
7898: PLUS
7899: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7900: LD_EXP 25
7904: PUSH
7905: LD_EXP 26
7909: MOD
7910: PUSH
7911: LD_INT 0
7913: EQUAL
7914: IFFALSE 7925
// AddToLog ( lines_break_type ) ;
7916: LD_EXP 27
7920: PPUSH
7921: CALL_OW 561
// end ;
7925: LD_VAR 0 2
7929: RET
// export function LogHuman ( id ) ; begin
7930: LD_INT 0
7932: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7933: LD_STRING Human Created. id: 
7935: PUSH
7936: LD_VAR 0 1
7940: STR
7941: PUSH
7942: LD_STRING ; side: 
7944: STR
7945: PUSH
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 255
7955: STR
7956: PUSH
7957: LD_STRING ; class: 
7959: STR
7960: PUSH
7961: LD_VAR 0 1
7965: PPUSH
7966: CALL_OW 257
7970: STR
7971: PUSH
7972: LD_STRING ; 
7974: STR
7975: PPUSH
7976: CALL 7822 0 1
// end ;
7980: LD_VAR 0 2
7984: RET
// export function LogVeh ( id ) ; begin
7985: LD_INT 0
7987: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7988: LD_STRING Vehicle Created. id: 
7990: PUSH
7991: LD_VAR 0 1
7995: STR
7996: PUSH
7997: LD_STRING ; side: 
7999: STR
8000: PUSH
8001: LD_VAR 0 1
8005: PPUSH
8006: CALL_OW 255
8010: STR
8011: PUSH
8012: LD_STRING ; nation: 
8014: STR
8015: PUSH
8016: LD_VAR 0 1
8020: PPUSH
8021: CALL_OW 248
8025: STR
8026: PUSH
8027: LD_STRING ; weapon: 
8029: STR
8030: PUSH
8031: LD_VAR 0 1
8035: PPUSH
8036: CALL_OW 264
8040: STR
8041: PUSH
8042: LD_STRING ; 
8044: STR
8045: PPUSH
8046: CALL 7822 0 1
// end ;
8050: LD_VAR 0 2
8054: RET
// export function LogEvent ( event ) ; begin
8055: LD_INT 0
8057: PPUSH
// Log ( Event Executed. id:  & event ) ;
8058: LD_STRING Event Executed. id: 
8060: PUSH
8061: LD_VAR 0 1
8065: STR
8066: PPUSH
8067: CALL 7822 0 1
// end ; end_of_file
8071: LD_VAR 0 2
8075: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8076: LD_INT 0
8078: PPUSH
8079: PPUSH
8080: PPUSH
8081: PPUSH
8082: PPUSH
8083: PPUSH
8084: PPUSH
8085: PPUSH
// if unit then
8086: LD_VAR 0 1
8090: IFFALSE 8490
// begin if mode = 0 then
8092: LD_VAR 0 3
8096: PUSH
8097: LD_INT 0
8099: EQUAL
8100: IFFALSE 8248
// begin if coords then
8102: LD_VAR 0 2
8106: IFFALSE 8246
// while ( coords > 1 ) do
8108: LD_VAR 0 2
8112: PUSH
8113: LD_INT 1
8115: GREATER
8116: IFFALSE 8246
// if not HasTask ( unit ) then
8118: LD_VAR 0 1
8122: PPUSH
8123: CALL_OW 314
8127: NOT
8128: IFFALSE 8244
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8130: LD_VAR 0 1
8134: PPUSH
8135: LD_VAR 0 2
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 2
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PPUSH
8153: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8157: LD_INT 35
8159: PPUSH
8160: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 250
8173: PUSH
8174: LD_VAR 0 2
8178: PUSH
8179: LD_INT 1
8181: ARRAY
8182: EQUAL
8183: PUSH
8184: LD_VAR 0 1
8188: PPUSH
8189: CALL_OW 251
8193: PUSH
8194: LD_VAR 0 2
8198: PUSH
8199: LD_INT 2
8201: ARRAY
8202: EQUAL
8203: AND
8204: IFFALSE 8157
// for i = 1 to 2 do
8206: LD_ADDR_VAR 0 5
8210: PUSH
8211: DOUBLE
8212: LD_INT 1
8214: DEC
8215: ST_TO_ADDR
8216: LD_INT 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8242
// coords := Delete ( coords , 1 ) ;
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 2
8231: PPUSH
8232: LD_INT 1
8234: PPUSH
8235: CALL_OW 3
8239: ST_TO_ADDR
8240: GO 8219
8242: POP
8243: POP
// end ;
8244: GO 8108
// end else
8246: GO 8490
// begin if coords then
8248: LD_VAR 0 2
8252: IFFALSE 8490
// begin x := GetX ( unit ) ;
8254: LD_ADDR_VAR 0 6
8258: PUSH
8259: LD_VAR 0 1
8263: PPUSH
8264: CALL_OW 250
8268: ST_TO_ADDR
// y := GetY ( unit ) ;
8269: LD_ADDR_VAR 0 7
8273: PUSH
8274: LD_VAR 0 1
8278: PPUSH
8279: CALL_OW 251
8283: ST_TO_ADDR
// while ( coords > 1 ) do
8284: LD_VAR 0 2
8288: PUSH
8289: LD_INT 1
8291: GREATER
8292: IFFALSE 8490
// begin Wait ( 0 0$0.3 ) ;
8294: LD_INT 10
8296: PPUSH
8297: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8301: LD_VAR 0 1
8305: PPUSH
8306: CALL_OW 255
8310: PPUSH
8311: LD_VAR 0 1
8315: PPUSH
8316: CALL_OW 250
8320: PPUSH
8321: LD_VAR 0 1
8325: PPUSH
8326: CALL_OW 251
8330: PPUSH
8331: LD_INT 14
8333: PPUSH
8334: CALL 22837 0 4
8338: IFFALSE 8369
// begin ComMoveXY ( unit , x , y ) ;
8340: LD_VAR 0 1
8344: PPUSH
8345: LD_VAR 0 6
8349: PPUSH
8350: LD_VAR 0 7
8354: PPUSH
8355: CALL_OW 111
// result := false ;
8359: LD_ADDR_VAR 0 4
8363: PUSH
8364: LD_INT 0
8366: ST_TO_ADDR
// end else
8367: GO 8408
// if not HasTask ( unit ) then
8369: LD_VAR 0 1
8373: PPUSH
8374: CALL_OW 314
8378: NOT
8379: IFFALSE 8408
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8381: LD_VAR 0 1
8385: PPUSH
8386: LD_VAR 0 2
8390: PUSH
8391: LD_INT 1
8393: ARRAY
8394: PPUSH
8395: LD_VAR 0 2
8399: PUSH
8400: LD_INT 2
8402: ARRAY
8403: PPUSH
8404: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8408: LD_VAR 0 1
8412: PPUSH
8413: CALL_OW 250
8417: PUSH
8418: LD_VAR 0 2
8422: PUSH
8423: LD_INT 1
8425: ARRAY
8426: EQUAL
8427: PUSH
8428: LD_VAR 0 1
8432: PPUSH
8433: CALL_OW 251
8437: PUSH
8438: LD_VAR 0 2
8442: PUSH
8443: LD_INT 2
8445: ARRAY
8446: EQUAL
8447: AND
8448: IFFALSE 8488
// for i = 1 to 2 do
8450: LD_ADDR_VAR 0 5
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_INT 2
8462: PUSH
8463: FOR_TO
8464: IFFALSE 8486
// coords := Delete ( coords , 1 ) ;
8466: LD_ADDR_VAR 0 2
8470: PUSH
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_INT 1
8478: PPUSH
8479: CALL_OW 3
8483: ST_TO_ADDR
8484: GO 8463
8486: POP
8487: POP
// end ;
8488: GO 8284
// end ; end ; end ; result := true ;
8490: LD_ADDR_VAR 0 4
8494: PUSH
8495: LD_INT 1
8497: ST_TO_ADDR
// end ;
8498: LD_VAR 0 4
8502: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8503: LD_INT 0
8505: PPUSH
8506: PPUSH
8507: PPUSH
// if not units then
8508: LD_VAR 0 2
8512: NOT
8513: IFFALSE 8517
// exit ;
8515: GO 8580
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8517: LD_ADDR_VAR 0 5
8521: PUSH
8522: LD_INT 81
8524: PUSH
8525: LD_VAR 0 1
8529: PUSH
8530: EMPTY
8531: LIST
8532: LIST
8533: PPUSH
8534: CALL_OW 69
8538: ST_TO_ADDR
// for i in units do
8539: LD_ADDR_VAR 0 4
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: FOR_IN
8550: IFFALSE 8578
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8552: LD_VAR 0 4
8556: PPUSH
8557: LD_VAR 0 5
8561: PPUSH
8562: LD_VAR 0 4
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// end ;
8576: GO 8549
8578: POP
8579: POP
// end ;
8580: LD_VAR 0 3
8584: RET
// export function MC_Show ( string ) ; begin
8585: LD_INT 0
8587: PPUSH
// display_strings := string ;
8588: LD_ADDR_OWVAR 47
8592: PUSH
8593: LD_VAR 0 1
8597: ST_TO_ADDR
// end ; end_of_file
8598: LD_VAR 0 2
8602: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8603: LD_INT 0
8605: PPUSH
8606: PPUSH
8607: PPUSH
8608: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8609: LD_ADDR_VAR 0 8
8613: PUSH
8614: LD_VAR 0 1
8618: PPUSH
8619: LD_INT 2
8621: PPUSH
8622: EMPTY
8623: PPUSH
8624: CALL 11750 0 3
8628: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8629: LD_VAR 0 8
8633: PUSH
8634: LD_VAR 0 2
8638: PPUSH
8639: LD_VAR 0 3
8643: PPUSH
8644: CALL_OW 428
8648: PUSH
8649: LD_INT 0
8651: EQUAL
8652: AND
8653: IFFALSE 8727
// for i = 1 to plist do
8655: LD_ADDR_VAR 0 6
8659: PUSH
8660: DOUBLE
8661: LD_INT 1
8663: DEC
8664: ST_TO_ADDR
8665: LD_VAR 0 8
8669: PUSH
8670: FOR_TO
8671: IFFALSE 8725
// if NotTask ( plist [ i ] ) then
8673: LD_VAR 0 8
8677: PUSH
8678: LD_VAR 0 6
8682: ARRAY
8683: PPUSH
8684: CALL 32252 0 1
8688: IFFALSE 8723
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8690: LD_VAR 0 8
8694: PUSH
8695: LD_VAR 0 6
8699: ARRAY
8700: PPUSH
8701: LD_INT 0
8703: PPUSH
8704: LD_VAR 0 2
8708: PPUSH
8709: LD_VAR 0 3
8713: PPUSH
8714: LD_VAR 0 4
8718: PPUSH
8719: CALL_OW 145
// end ;
8723: GO 8670
8725: POP
8726: POP
// end ;
8727: LD_VAR 0 5
8731: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8732: LD_INT 0
8734: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8735: LD_VAR 0 1
8739: PPUSH
8740: LD_INT 6
8742: PPUSH
8743: LD_VAR 0 2
8747: PPUSH
8748: LD_VAR 0 3
8752: PPUSH
8753: LD_VAR 0 4
8757: PPUSH
8758: CALL 10236 0 5
// end ;
8762: LD_VAR 0 5
8766: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8767: LD_INT 0
8769: PPUSH
8770: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8771: LD_ADDR_VAR 0 4
8775: PUSH
8776: LD_INT 22
8778: PUSH
8779: LD_VAR 0 1
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 2
8790: PUSH
8791: LD_INT 30
8793: PUSH
8794: LD_INT 0
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 30
8803: PUSH
8804: LD_INT 1
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: LIST
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: EMPTY
8821: LIST
8822: PPUSH
8823: CALL_OW 69
8827: PPUSH
8828: LD_VAR 0 2
8832: PPUSH
8833: CALL_OW 250
8837: PPUSH
8838: LD_VAR 0 2
8842: PPUSH
8843: CALL_OW 251
8847: PPUSH
8848: CALL_OW 73
8852: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8853: LD_VAR 0 4
8857: PPUSH
8858: LD_VAR 0 2
8862: PPUSH
8863: CALL 10525 0 2
8867: IFFALSE 8926
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8869: LD_VAR 0 1
8873: PPUSH
8874: LD_INT 30
8876: PUSH
8877: LD_VAR 0 2
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PPUSH
8886: CALL 11667 0 2
8890: PUSH
8891: LD_INT 1
8893: ARRAY
8894: PPUSH
8895: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8899: LD_ADDR_EXP 48
8903: PUSH
8904: LD_EXP 48
8908: PPUSH
8909: LD_VAR 0 1
8913: PPUSH
8914: LD_VAR 0 2
8918: PPUSH
8919: EMPTY
8920: PPUSH
8921: CALL 42067 0 4
8925: ST_TO_ADDR
// end ; end ;
8926: LD_VAR 0 3
8930: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8931: LD_INT 0
8933: PPUSH
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// result := false ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 0
8946: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8947: LD_VAR 0 1
8951: PPUSH
8952: LD_EXP 40
8956: PPUSH
8957: CALL 43015 0 2
8961: IFFALSE 9174
// for i = 1 to MREG_LabList do
8963: LD_ADDR_VAR 0 5
8967: PUSH
8968: DOUBLE
8969: LD_INT 1
8971: DEC
8972: ST_TO_ADDR
8973: LD_EXP 40
8977: PUSH
8978: FOR_TO
8979: IFFALSE 9172
// begin if MREG_LabList [ i ] [ 1 ] = side then
8981: LD_EXP 40
8985: PUSH
8986: LD_VAR 0 5
8990: ARRAY
8991: PUSH
8992: LD_INT 1
8994: ARRAY
8995: PUSH
8996: LD_VAR 0 1
9000: EQUAL
9001: IFFALSE 9170
// begin lab := MREG_LabList [ i ] [ 2 ] ;
9003: LD_ADDR_VAR 0 7
9007: PUSH
9008: LD_EXP 40
9012: PUSH
9013: LD_VAR 0 5
9017: ARRAY
9018: PUSH
9019: LD_INT 2
9021: ARRAY
9022: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
9023: LD_ADDR_VAR 0 9
9027: PUSH
9028: LD_INT 22
9030: PUSH
9031: LD_VAR 0 1
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: LD_INT 2
9042: PUSH
9043: LD_INT 30
9045: PUSH
9046: LD_INT 0
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: PUSH
9053: LD_INT 30
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: EMPTY
9069: LIST
9070: LIST
9071: PUSH
9072: EMPTY
9073: LIST
9074: PPUSH
9075: CALL_OW 69
9079: PPUSH
9080: LD_VAR 0 7
9084: PPUSH
9085: CALL_OW 250
9089: PPUSH
9090: LD_VAR 0 7
9094: PPUSH
9095: CALL_OW 251
9099: PPUSH
9100: CALL_OW 73
9104: ST_TO_ADDR
// if dep then
9105: LD_VAR 0 9
9109: IFFALSE 9168
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9111: LD_VAR 0 9
9115: PPUSH
9116: LD_VAR 0 2
9120: PPUSH
9121: LD_VAR 0 3
9125: PPUSH
9126: CALL 10641 0 3
9130: IFFALSE 9168
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9132: LD_VAR 0 7
9136: PPUSH
9137: LD_VAR 0 2
9141: PPUSH
9142: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9146: LD_VAR 0 7
9150: PPUSH
9151: LD_VAR 0 3
9155: PPUSH
9156: CALL_OW 207
// result := true ;
9160: LD_ADDR_VAR 0 4
9164: PUSH
9165: LD_INT 1
9167: ST_TO_ADDR
// end ; end ; break ;
9168: GO 9172
// end ; end ;
9170: GO 8978
9172: POP
9173: POP
// end ;
9174: LD_VAR 0 4
9178: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9179: LD_INT 0
9181: PPUSH
9182: PPUSH
9183: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9184: LD_ADDR_VAR 0 7
9188: PUSH
9189: LD_VAR 0 2
9193: PPUSH
9194: LD_VAR 0 3
9198: PPUSH
9199: LD_VAR 0 4
9203: PPUSH
9204: CALL 9366 0 3
9208: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9209: LD_ADDR_EXP 46
9213: PUSH
9214: LD_EXP 46
9218: PPUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: LD_INT 2
9226: PPUSH
9227: LD_VAR 0 2
9231: PUSH
9232: LD_VAR 0 3
9236: PUSH
9237: LD_VAR 0 4
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL 41976 0 4
9251: ST_TO_ADDR
// if ext_list then
9252: LD_VAR 0 5
9256: IFFALSE 9361
// for i = 1 to ext_list do
9258: LD_ADDR_VAR 0 8
9262: PUSH
9263: DOUBLE
9264: LD_INT 1
9266: DEC
9267: ST_TO_ADDR
9268: LD_VAR 0 5
9272: PUSH
9273: FOR_TO
9274: IFFALSE 9359
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9276: LD_ADDR_EXP 46
9280: PUSH
9281: LD_EXP 46
9285: PPUSH
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_VAR 0 5
9295: PUSH
9296: LD_VAR 0 8
9300: ARRAY
9301: PPUSH
9302: LD_VAR 0 7
9306: PUSH
9307: LD_VAR 0 8
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PUSH
9317: LD_VAR 0 7
9321: PUSH
9322: LD_VAR 0 8
9326: ARRAY
9327: PUSH
9328: LD_INT 2
9330: ARRAY
9331: PUSH
9332: LD_VAR 0 7
9336: PUSH
9337: LD_VAR 0 8
9341: ARRAY
9342: PUSH
9343: LD_INT 3
9345: ARRAY
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PPUSH
9352: CALL 41976 0 4
9356: ST_TO_ADDR
9357: GO 9273
9359: POP
9360: POP
// end ;
9361: LD_VAR 0 6
9365: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9366: LD_INT 0
9368: PPUSH
9369: PPUSH
// list := [ ] ;
9370: LD_ADDR_VAR 0 5
9374: PUSH
9375: EMPTY
9376: ST_TO_ADDR
// case d of 0 :
9377: LD_VAR 0 3
9381: PUSH
9382: LD_INT 0
9384: DOUBLE
9385: EQUAL
9386: IFTRUE 9390
9388: GO 9523
9390: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9391: LD_ADDR_VAR 0 5
9395: PUSH
9396: LD_VAR 0 1
9400: PUSH
9401: LD_INT 4
9403: MINUS
9404: PUSH
9405: LD_VAR 0 2
9409: PUSH
9410: LD_INT 4
9412: MINUS
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: LIST
9421: PUSH
9422: LD_VAR 0 1
9426: PUSH
9427: LD_INT 3
9429: MINUS
9430: PUSH
9431: LD_VAR 0 2
9435: PUSH
9436: LD_INT 1
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: LIST
9443: PUSH
9444: LD_VAR 0 1
9448: PUSH
9449: LD_INT 4
9451: PLUS
9452: PUSH
9453: LD_VAR 0 2
9457: PUSH
9458: LD_INT 4
9460: PUSH
9461: EMPTY
9462: LIST
9463: LIST
9464: LIST
9465: PUSH
9466: LD_VAR 0 1
9470: PUSH
9471: LD_INT 3
9473: PLUS
9474: PUSH
9475: LD_VAR 0 2
9479: PUSH
9480: LD_INT 3
9482: PLUS
9483: PUSH
9484: LD_INT 5
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_VAR 0 1
9496: PUSH
9497: LD_VAR 0 2
9501: PUSH
9502: LD_INT 4
9504: PLUS
9505: PUSH
9506: LD_INT 0
9508: PUSH
9509: EMPTY
9510: LIST
9511: LIST
9512: LIST
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: LIST
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// end ; 1 :
9521: GO 10221
9523: LD_INT 1
9525: DOUBLE
9526: EQUAL
9527: IFTRUE 9531
9529: GO 9664
9531: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9532: LD_ADDR_VAR 0 5
9536: PUSH
9537: LD_VAR 0 1
9541: PUSH
9542: LD_VAR 0 2
9546: PUSH
9547: LD_INT 4
9549: MINUS
9550: PUSH
9551: LD_INT 3
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: LIST
9558: PUSH
9559: LD_VAR 0 1
9563: PUSH
9564: LD_INT 3
9566: MINUS
9567: PUSH
9568: LD_VAR 0 2
9572: PUSH
9573: LD_INT 3
9575: MINUS
9576: PUSH
9577: LD_INT 2
9579: PUSH
9580: EMPTY
9581: LIST
9582: LIST
9583: LIST
9584: PUSH
9585: LD_VAR 0 1
9589: PUSH
9590: LD_INT 4
9592: MINUS
9593: PUSH
9594: LD_VAR 0 2
9598: PUSH
9599: LD_INT 1
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: LIST
9606: PUSH
9607: LD_VAR 0 1
9611: PUSH
9612: LD_VAR 0 2
9616: PUSH
9617: LD_INT 3
9619: PLUS
9620: PUSH
9621: LD_INT 0
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_VAR 0 1
9633: PUSH
9634: LD_INT 4
9636: PLUS
9637: PUSH
9638: LD_VAR 0 2
9642: PUSH
9643: LD_INT 4
9645: PLUS
9646: PUSH
9647: LD_INT 5
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// end ; 2 :
9662: GO 10221
9664: LD_INT 2
9666: DOUBLE
9667: EQUAL
9668: IFTRUE 9672
9670: GO 9801
9672: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9673: LD_ADDR_VAR 0 5
9677: PUSH
9678: LD_VAR 0 1
9682: PUSH
9683: LD_VAR 0 2
9687: PUSH
9688: LD_INT 3
9690: MINUS
9691: PUSH
9692: LD_INT 3
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: PUSH
9700: LD_VAR 0 1
9704: PUSH
9705: LD_INT 4
9707: PLUS
9708: PUSH
9709: LD_VAR 0 2
9713: PUSH
9714: LD_INT 4
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: LIST
9721: PUSH
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 4
9734: PLUS
9735: PUSH
9736: LD_INT 0
9738: PUSH
9739: EMPTY
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: LD_VAR 0 1
9748: PUSH
9749: LD_INT 3
9751: MINUS
9752: PUSH
9753: LD_VAR 0 2
9757: PUSH
9758: LD_INT 1
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PUSH
9766: LD_VAR 0 1
9770: PUSH
9771: LD_INT 4
9773: MINUS
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: LD_INT 4
9782: MINUS
9783: PUSH
9784: LD_INT 2
9786: PUSH
9787: EMPTY
9788: LIST
9789: LIST
9790: LIST
9791: PUSH
9792: EMPTY
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: ST_TO_ADDR
// end ; 3 :
9799: GO 10221
9801: LD_INT 3
9803: DOUBLE
9804: EQUAL
9805: IFTRUE 9809
9807: GO 9942
9809: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9810: LD_ADDR_VAR 0 5
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_INT 3
9822: PLUS
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_INT 4
9844: PLUS
9845: PUSH
9846: LD_VAR 0 2
9850: PUSH
9851: LD_INT 4
9853: PLUS
9854: PUSH
9855: LD_INT 5
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: LIST
9862: PUSH
9863: LD_VAR 0 1
9867: PUSH
9868: LD_INT 4
9870: MINUS
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: LD_INT 1
9879: PUSH
9880: EMPTY
9881: LIST
9882: LIST
9883: LIST
9884: PUSH
9885: LD_VAR 0 1
9889: PUSH
9890: LD_VAR 0 2
9894: PUSH
9895: LD_INT 4
9897: MINUS
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: LIST
9906: PUSH
9907: LD_VAR 0 1
9911: PUSH
9912: LD_INT 3
9914: MINUS
9915: PUSH
9916: LD_VAR 0 2
9920: PUSH
9921: LD_INT 3
9923: MINUS
9924: PUSH
9925: LD_INT 2
9927: PUSH
9928: EMPTY
9929: LIST
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: LIST
9938: LIST
9939: ST_TO_ADDR
// end ; 4 :
9940: GO 10221
9942: LD_INT 4
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 10083
9950: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9951: LD_ADDR_VAR 0 5
9955: PUSH
9956: LD_VAR 0 1
9960: PUSH
9961: LD_VAR 0 2
9965: PUSH
9966: LD_INT 4
9968: PLUS
9969: PUSH
9970: LD_INT 0
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_VAR 0 1
9982: PUSH
9983: LD_INT 3
9985: PLUS
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_INT 3
9994: PLUS
9995: PUSH
9996: LD_INT 5
9998: PUSH
9999: EMPTY
10000: LIST
10001: LIST
10002: LIST
10003: PUSH
10004: LD_VAR 0 1
10008: PUSH
10009: LD_INT 3
10011: PLUS
10012: PUSH
10013: LD_VAR 0 2
10017: PUSH
10018: LD_INT 4
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: LIST
10025: PUSH
10026: LD_VAR 0 1
10030: PUSH
10031: LD_VAR 0 2
10035: PUSH
10036: LD_INT 3
10038: MINUS
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: PUSH
10048: LD_VAR 0 1
10052: PUSH
10053: LD_INT 4
10055: MINUS
10056: PUSH
10057: LD_VAR 0 2
10061: PUSH
10062: LD_INT 4
10064: MINUS
10065: PUSH
10066: LD_INT 2
10068: PUSH
10069: EMPTY
10070: LIST
10071: LIST
10072: LIST
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: ST_TO_ADDR
// end ; 5 :
10081: GO 10221
10083: LD_INT 5
10085: DOUBLE
10086: EQUAL
10087: IFTRUE 10091
10089: GO 10220
10091: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10092: LD_ADDR_VAR 0 5
10096: PUSH
10097: LD_VAR 0 1
10101: PUSH
10102: LD_INT 4
10104: MINUS
10105: PUSH
10106: LD_VAR 0 2
10110: PUSH
10111: LD_INT 1
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: PUSH
10119: LD_VAR 0 1
10123: PUSH
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 4
10131: MINUS
10132: PUSH
10133: LD_INT 3
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: LIST
10140: PUSH
10141: LD_VAR 0 1
10145: PUSH
10146: LD_INT 4
10148: PLUS
10149: PUSH
10150: LD_VAR 0 2
10154: PUSH
10155: LD_INT 4
10157: PLUS
10158: PUSH
10159: LD_INT 5
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_VAR 0 1
10171: PUSH
10172: LD_INT 3
10174: PLUS
10175: PUSH
10176: LD_VAR 0 2
10180: PUSH
10181: LD_INT 4
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PUSH
10189: LD_VAR 0 1
10193: PUSH
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 3
10201: PLUS
10202: PUSH
10203: LD_INT 0
10205: PUSH
10206: EMPTY
10207: LIST
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: ST_TO_ADDR
// end ; end ;
10218: GO 10221
10220: POP
// result := list ;
10221: LD_ADDR_VAR 0 4
10225: PUSH
10226: LD_VAR 0 5
10230: ST_TO_ADDR
// end ;
10231: LD_VAR 0 4
10235: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10236: LD_INT 0
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10243: LD_ADDR_VAR 0 10
10247: PUSH
10248: LD_VAR 0 1
10252: PPUSH
10253: LD_INT 2
10255: PPUSH
10256: EMPTY
10257: PPUSH
10258: CALL 11750 0 3
10262: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10263: LD_ADDR_VAR 0 9
10267: PUSH
10268: LD_INT 22
10270: PUSH
10271: LD_VAR 0 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: LD_INT 30
10285: PUSH
10286: LD_INT 0
10288: PUSH
10289: EMPTY
10290: LIST
10291: LIST
10292: PUSH
10293: LD_INT 30
10295: PUSH
10296: LD_INT 1
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: PUSH
10303: EMPTY
10304: LIST
10305: LIST
10306: LIST
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: PPUSH
10315: CALL_OW 69
10319: PPUSH
10320: LD_VAR 0 3
10324: PPUSH
10325: LD_VAR 0 4
10329: PPUSH
10330: CALL_OW 73
10334: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10335: LD_ADDR_VAR 0 8
10339: PUSH
10340: LD_VAR 0 9
10344: PPUSH
10345: LD_VAR 0 2
10349: PPUSH
10350: CALL 10525 0 2
10354: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10355: LD_VAR 0 10
10359: PUSH
10360: LD_VAR 0 8
10364: AND
10365: PUSH
10366: LD_VAR 0 9
10370: PPUSH
10371: LD_VAR 0 3
10375: PPUSH
10376: LD_VAR 0 4
10380: PPUSH
10381: CALL_OW 297
10385: PUSH
10386: LD_INT 26
10388: LESSEQUAL
10389: AND
10390: PUSH
10391: LD_VAR 0 3
10395: PPUSH
10396: LD_VAR 0 4
10400: PPUSH
10401: CALL_OW 428
10405: PUSH
10406: LD_INT 0
10408: EQUAL
10409: AND
10410: IFFALSE 10520
// for i = 1 to plist do
10412: LD_ADDR_VAR 0 7
10416: PUSH
10417: DOUBLE
10418: LD_INT 1
10420: DEC
10421: ST_TO_ADDR
10422: LD_VAR 0 10
10426: PUSH
10427: FOR_TO
10428: IFFALSE 10518
// if IsInUnit ( plist [ i ] ) then
10430: LD_VAR 0 10
10434: PUSH
10435: LD_VAR 0 7
10439: ARRAY
10440: PPUSH
10441: CALL_OW 310
10445: IFFALSE 10464
// ComExitBuilding ( plist [ i ] ) else
10447: LD_VAR 0 10
10451: PUSH
10452: LD_VAR 0 7
10456: ARRAY
10457: PPUSH
10458: CALL_OW 122
10462: GO 10516
// if NotTask ( plist [ i ] ) then
10464: LD_VAR 0 10
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PPUSH
10475: CALL 32252 0 1
10479: IFFALSE 10516
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10481: LD_VAR 0 10
10485: PUSH
10486: LD_VAR 0 7
10490: ARRAY
10491: PPUSH
10492: LD_VAR 0 2
10496: PPUSH
10497: LD_VAR 0 3
10501: PPUSH
10502: LD_VAR 0 4
10506: PPUSH
10507: LD_VAR 0 5
10511: PPUSH
10512: CALL_OW 145
// end ;
10516: GO 10427
10518: POP
10519: POP
// end ;
10520: LD_VAR 0 6
10524: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10525: LD_INT 0
10527: PPUSH
10528: PPUSH
10529: PPUSH
// pom := GetBase ( bdepot ) ;
10530: LD_ADDR_VAR 0 4
10534: PUSH
10535: LD_VAR 0 1
10539: PPUSH
10540: CALL_OW 274
10544: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10545: LD_ADDR_VAR 0 5
10549: PUSH
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL_OW 248
10564: PPUSH
10565: CALL_OW 450
10569: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10570: LD_VAR 0 4
10574: PPUSH
10575: LD_INT 1
10577: PPUSH
10578: CALL_OW 275
10582: PUSH
10583: LD_VAR 0 5
10587: PUSH
10588: LD_INT 1
10590: ARRAY
10591: GREATEREQUAL
10592: PUSH
10593: LD_VAR 0 4
10597: PPUSH
10598: LD_INT 3
10600: PPUSH
10601: CALL_OW 275
10605: PUSH
10606: LD_VAR 0 5
10610: PUSH
10611: LD_INT 3
10613: ARRAY
10614: GREATEREQUAL
10615: AND
10616: IFFALSE 10628
// result := true else
10618: LD_ADDR_VAR 0 3
10622: PUSH
10623: LD_INT 1
10625: ST_TO_ADDR
10626: GO 10636
// result := false ;
10628: LD_ADDR_VAR 0 3
10632: PUSH
10633: LD_INT 0
10635: ST_TO_ADDR
// end ;
10636: LD_VAR 0 3
10640: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10641: LD_INT 0
10643: PPUSH
10644: PPUSH
10645: PPUSH
10646: PPUSH
10647: PPUSH
// pom := GetBase ( bdepot ) ;
10648: LD_ADDR_VAR 0 5
10652: PUSH
10653: LD_VAR 0 1
10657: PPUSH
10658: CALL_OW 274
10662: ST_TO_ADDR
// cost := [ ] ;
10663: LD_ADDR_VAR 0 8
10667: PUSH
10668: EMPTY
10669: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10670: LD_ADDR_VAR 0 6
10674: PUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 1
10684: PPUSH
10685: CALL_OW 248
10689: PPUSH
10690: CALL_OW 450
10694: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10695: LD_ADDR_VAR 0 7
10699: PUSH
10700: LD_VAR 0 3
10704: PPUSH
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 248
10714: PPUSH
10715: CALL_OW 450
10719: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10720: LD_ADDR_VAR 0 8
10724: PUSH
10725: LD_VAR 0 8
10729: PPUSH
10730: LD_INT 1
10732: PPUSH
10733: LD_VAR 0 6
10737: PUSH
10738: LD_INT 1
10740: ARRAY
10741: PUSH
10742: LD_VAR 0 7
10746: PUSH
10747: LD_INT 1
10749: ARRAY
10750: PLUS
10751: PPUSH
10752: CALL_OW 1
10756: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10757: LD_ADDR_VAR 0 8
10761: PUSH
10762: LD_VAR 0 8
10766: PPUSH
10767: LD_INT 2
10769: PPUSH
10770: LD_VAR 0 6
10774: PUSH
10775: LD_INT 2
10777: ARRAY
10778: PUSH
10779: LD_VAR 0 7
10783: PUSH
10784: LD_INT 2
10786: ARRAY
10787: PLUS
10788: PPUSH
10789: CALL_OW 1
10793: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10794: LD_ADDR_VAR 0 8
10798: PUSH
10799: LD_VAR 0 8
10803: PPUSH
10804: LD_INT 3
10806: PPUSH
10807: LD_VAR 0 6
10811: PUSH
10812: LD_INT 3
10814: ARRAY
10815: PUSH
10816: LD_VAR 0 7
10820: PUSH
10821: LD_INT 3
10823: ARRAY
10824: PLUS
10825: PPUSH
10826: CALL_OW 1
10830: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10831: LD_VAR 0 5
10835: PPUSH
10836: LD_INT 1
10838: PPUSH
10839: CALL_OW 275
10843: PUSH
10844: LD_VAR 0 8
10848: PUSH
10849: LD_INT 1
10851: ARRAY
10852: GREATEREQUAL
10853: PUSH
10854: LD_VAR 0 5
10858: PPUSH
10859: LD_INT 3
10861: PPUSH
10862: CALL_OW 275
10866: PUSH
10867: LD_VAR 0 8
10871: PUSH
10872: LD_INT 3
10874: ARRAY
10875: GREATEREQUAL
10876: AND
10877: IFFALSE 10889
// result := true else
10879: LD_ADDR_VAR 0 4
10883: PUSH
10884: LD_INT 1
10886: ST_TO_ADDR
10887: GO 10897
// result := false ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_INT 0
10896: ST_TO_ADDR
// end ;
10897: LD_VAR 0 4
10901: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10902: LD_INT 0
10904: PPUSH
10905: PPUSH
10906: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10907: LD_ADDR_VAR 0 5
10911: PUSH
10912: LD_VAR 0 1
10916: PPUSH
10917: LD_INT 2
10919: PPUSH
10920: EMPTY
10921: PPUSH
10922: CALL 11750 0 3
10926: ST_TO_ADDR
// if unit and plist then
10927: LD_VAR 0 2
10931: PUSH
10932: LD_VAR 0 5
10936: AND
10937: IFFALSE 10998
// for i = 1 to plist do
10939: LD_ADDR_VAR 0 4
10943: PUSH
10944: DOUBLE
10945: LD_INT 1
10947: DEC
10948: ST_TO_ADDR
10949: LD_VAR 0 5
10953: PUSH
10954: FOR_TO
10955: IFFALSE 10996
// if NotTask ( plist [ i ] ) then
10957: LD_VAR 0 5
10961: PUSH
10962: LD_VAR 0 4
10966: ARRAY
10967: PPUSH
10968: CALL 32252 0 1
10972: IFFALSE 10994
// ComDismantle ( plist [ i ] , unit ) ;
10974: LD_VAR 0 5
10978: PUSH
10979: LD_VAR 0 4
10983: ARRAY
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL_OW 167
10994: GO 10954
10996: POP
10997: POP
// result := true ;
10998: LD_ADDR_VAR 0 3
11002: PUSH
11003: LD_INT 1
11005: ST_TO_ADDR
// end ;
11006: LD_VAR 0 3
11010: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
11011: LD_INT 0
11013: PPUSH
11014: PPUSH
11015: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
11016: LD_ADDR_VAR 0 5
11020: PUSH
11021: LD_VAR 0 1
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: EMPTY
11030: PPUSH
11031: CALL 11750 0 3
11035: ST_TO_ADDR
// if unit and plist then
11036: LD_VAR 0 2
11040: PUSH
11041: LD_VAR 0 5
11045: AND
11046: IFFALSE 11107
// for i = 1 to plist do
11048: LD_ADDR_VAR 0 4
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_VAR 0 5
11062: PUSH
11063: FOR_TO
11064: IFFALSE 11105
// if NotTask ( plist [ i ] ) then
11066: LD_VAR 0 5
11070: PUSH
11071: LD_VAR 0 4
11075: ARRAY
11076: PPUSH
11077: CALL 32252 0 1
11081: IFFALSE 11103
// ComComplete ( plist [ i ] , unit ) ;
11083: LD_VAR 0 5
11087: PUSH
11088: LD_VAR 0 4
11092: ARRAY
11093: PPUSH
11094: LD_VAR 0 2
11098: PPUSH
11099: CALL 71216 0 2
11103: GO 11063
11105: POP
11106: POP
// result := true ;
11107: LD_ADDR_VAR 0 3
11111: PUSH
11112: LD_INT 1
11114: ST_TO_ADDR
// end ;
11115: LD_VAR 0 3
11119: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11120: LD_INT 0
11122: PPUSH
11123: PPUSH
11124: PPUSH
11125: PPUSH
11126: PPUSH
11127: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11128: LD_ADDR_VAR 0 5
11132: PUSH
11133: LD_INT 22
11135: PUSH
11136: LD_VAR 0 1
11140: PUSH
11141: EMPTY
11142: LIST
11143: LIST
11144: PUSH
11145: LD_INT 21
11147: PUSH
11148: LD_INT 3
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 57
11160: PUSH
11161: EMPTY
11162: LIST
11163: PUSH
11164: EMPTY
11165: LIST
11166: LIST
11167: PUSH
11168: LD_INT 3
11170: PUSH
11171: LD_INT 24
11173: PUSH
11174: LD_INT 1000
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PUSH
11181: EMPTY
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// r := [ ] ;
11196: LD_ADDR_VAR 0 6
11200: PUSH
11201: EMPTY
11202: ST_TO_ADDR
// if not tmp then
11203: LD_VAR 0 5
11207: NOT
11208: IFFALSE 11214
// exit else
11210: GO 11402
11212: GO 11382
// begin r := [ tmp [ 1 ] ] ;
11214: LD_ADDR_VAR 0 6
11218: PUSH
11219: LD_VAR 0 5
11223: PUSH
11224: LD_INT 1
11226: ARRAY
11227: PUSH
11228: EMPTY
11229: LIST
11230: ST_TO_ADDR
// for i = 2 to tmp do
11231: LD_ADDR_VAR 0 3
11235: PUSH
11236: DOUBLE
11237: LD_INT 2
11239: DEC
11240: ST_TO_ADDR
11241: LD_VAR 0 5
11245: PUSH
11246: FOR_TO
11247: IFFALSE 11380
// begin m := false ;
11249: LD_ADDR_VAR 0 7
11253: PUSH
11254: LD_INT 0
11256: ST_TO_ADDR
// for j = 1 to r do
11257: LD_ADDR_VAR 0 4
11261: PUSH
11262: DOUBLE
11263: LD_INT 1
11265: DEC
11266: ST_TO_ADDR
11267: LD_VAR 0 6
11271: PUSH
11272: FOR_TO
11273: IFFALSE 11347
// if GetLives ( tmp [ i ] ) < r [ j ] then
11275: LD_VAR 0 5
11279: PUSH
11280: LD_VAR 0 3
11284: ARRAY
11285: PPUSH
11286: CALL_OW 256
11290: PUSH
11291: LD_VAR 0 6
11295: PUSH
11296: LD_VAR 0 4
11300: ARRAY
11301: LESS
11302: IFFALSE 11345
// begin r := Insert ( r , j , tmp [ i ] ) ;
11304: LD_ADDR_VAR 0 6
11308: PUSH
11309: LD_VAR 0 6
11313: PPUSH
11314: LD_VAR 0 4
11318: PPUSH
11319: LD_VAR 0 5
11323: PUSH
11324: LD_VAR 0 3
11328: ARRAY
11329: PPUSH
11330: CALL_OW 2
11334: ST_TO_ADDR
// m := true ;
11335: LD_ADDR_VAR 0 7
11339: PUSH
11340: LD_INT 1
11342: ST_TO_ADDR
// break ;
11343: GO 11347
// end ;
11345: GO 11272
11347: POP
11348: POP
// if not m then
11349: LD_VAR 0 7
11353: NOT
11354: IFFALSE 11378
// r := r ^ tmp [ i ] ;
11356: LD_ADDR_VAR 0 6
11360: PUSH
11361: LD_VAR 0 6
11365: PUSH
11366: LD_VAR 0 5
11370: PUSH
11371: LD_VAR 0 3
11375: ARRAY
11376: ADD
11377: ST_TO_ADDR
// end ;
11378: GO 11246
11380: POP
11381: POP
// end ; if r then
11382: LD_VAR 0 6
11386: IFFALSE 11400
// result := r else
11388: LD_ADDR_VAR 0 2
11392: PUSH
11393: LD_VAR 0 6
11397: ST_TO_ADDR
11398: GO 11402
// exit ;
11400: GO 11402
// end ;
11402: LD_VAR 0 2
11406: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11407: LD_INT 0
11409: PPUSH
11410: PPUSH
11411: PPUSH
11412: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11413: LD_ADDR_VAR 0 5
11417: PUSH
11418: LD_INT 22
11420: PUSH
11421: LD_VAR 0 1
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 2
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 2
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 16
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 34
11455: PUSH
11456: LD_INT 13
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 34
11465: PUSH
11466: LD_INT 52
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: EMPTY
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 650
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 69
11499: ST_TO_ADDR
// p := 1 ;
11500: LD_ADDR_VAR 0 4
11504: PUSH
11505: LD_INT 1
11507: ST_TO_ADDR
// for i = 1 to repairs do
11508: LD_ADDR_VAR 0 3
11512: PUSH
11513: DOUBLE
11514: LD_INT 1
11516: DEC
11517: ST_TO_ADDR
11518: LD_VAR 0 5
11522: PUSH
11523: FOR_TO
11524: IFFALSE 11660
// begin if IsInUnit ( repairs [ i ] ) then
11526: LD_VAR 0 5
11530: PUSH
11531: LD_VAR 0 3
11535: ARRAY
11536: PPUSH
11537: CALL_OW 310
11541: IFFALSE 11560
// ComExitBuilding ( repairs [ i ] ) else
11543: LD_VAR 0 5
11547: PUSH
11548: LD_VAR 0 3
11552: ARRAY
11553: PPUSH
11554: CALL_OW 122
11558: GO 11658
// if not HasTask ( repairs [ i ] ) then
11560: LD_VAR 0 5
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PPUSH
11571: CALL_OW 314
11575: NOT
11576: IFFALSE 11658
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11578: LD_VAR 0 5
11582: PUSH
11583: LD_VAR 0 3
11587: ARRAY
11588: PPUSH
11589: LD_EXP 47
11593: PUSH
11594: LD_VAR 0 1
11598: ARRAY
11599: PUSH
11600: LD_VAR 0 4
11604: ARRAY
11605: PPUSH
11606: CALL_OW 130
// if i mod 3 = 0 then
11610: LD_VAR 0 3
11614: PUSH
11615: LD_INT 3
11617: MOD
11618: PUSH
11619: LD_INT 0
11621: EQUAL
11622: IFFALSE 11638
// p := p + 1 ;
11624: LD_ADDR_VAR 0 4
11628: PUSH
11629: LD_VAR 0 4
11633: PUSH
11634: LD_INT 1
11636: PLUS
11637: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11638: LD_EXP 47
11642: PUSH
11643: LD_VAR 0 1
11647: ARRAY
11648: PUSH
11649: LD_VAR 0 4
11653: LESS
11654: IFFALSE 11658
// break ;
11656: GO 11660
// end ; end ;
11658: GO 11523
11660: POP
11661: POP
// end ; end_of_file
11662: LD_VAR 0 2
11666: RET
// export function MCF_Get ( side , filter ) ; begin
11667: LD_INT 0
11669: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_INT 22
11677: PUSH
11678: LD_VAR 0 1
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: PUSH
11687: LD_VAR 0 2
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PPUSH
11696: CALL_OW 69
11700: ST_TO_ADDR
// end ;
11701: LD_VAR 0 3
11705: RET
// export function MCF_Lab ( side ) ; begin
11706: LD_INT 0
11708: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11709: LD_ADDR_VAR 0 2
11713: PUSH
11714: LD_INT 22
11716: PUSH
11717: LD_VAR 0 1
11721: PUSH
11722: EMPTY
11723: LIST
11724: LIST
11725: PUSH
11726: LD_INT 30
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: PPUSH
11740: CALL_OW 69
11744: ST_TO_ADDR
// end ;
11745: LD_VAR 0 2
11749: RET
// export function MCF_Class ( side , class , filter ) ; begin
11750: LD_INT 0
11752: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 22
11760: PUSH
11761: LD_VAR 0 1
11765: PUSH
11766: EMPTY
11767: LIST
11768: LIST
11769: PUSH
11770: LD_INT 25
11772: PUSH
11773: LD_VAR 0 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 3
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: LIST
11791: PPUSH
11792: CALL_OW 69
11796: ST_TO_ADDR
// end ;
11797: LD_VAR 0 4
11801: RET
// export function MCF_All ( side , filter ) ; begin
11802: LD_INT 0
11804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11805: LD_ADDR_VAR 0 3
11809: PUSH
11810: LD_INT 22
11812: PUSH
11813: LD_VAR 0 1
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: LD_INT 2
11824: PUSH
11825: LD_INT 25
11827: PUSH
11828: LD_INT 1
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 25
11837: PUSH
11838: LD_INT 2
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PUSH
11845: LD_INT 25
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: PUSH
11872: LD_VAR 0 2
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: LIST
11881: PPUSH
11882: CALL_OW 69
11886: ST_TO_ADDR
// end ;
11887: LD_VAR 0 3
11891: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11892: LD_INT 0
11894: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11895: LD_ADDR_VAR 0 4
11899: PUSH
11900: LD_INT 22
11902: PUSH
11903: LD_VAR 0 1
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: PUSH
11912: LD_INT 92
11914: PUSH
11915: LD_VAR 0 2
11919: PUSH
11920: LD_INT 1
11922: ARRAY
11923: PUSH
11924: LD_VAR 0 2
11928: PUSH
11929: LD_INT 2
11931: ARRAY
11932: PUSH
11933: LD_VAR 0 2
11937: PUSH
11938: LD_INT 3
11940: ARRAY
11941: PUSH
11942: EMPTY
11943: LIST
11944: LIST
11945: LIST
11946: LIST
11947: PUSH
11948: LD_VAR 0 3
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: PPUSH
11958: CALL_OW 69
11962: ST_TO_ADDR
// end ;
11963: LD_VAR 0 4
11967: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11968: LD_INT 0
11970: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11971: LD_ADDR_VAR 0 3
11975: PUSH
11976: LD_INT 22
11978: PUSH
11979: LD_VAR 0 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 21
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: LD_VAR 0 2
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: ST_TO_ADDR
// end ;
12013: LD_VAR 0 3
12017: RET
// export function MCF_Cargo ( side ) ; begin
12018: LD_INT 0
12020: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
12021: LD_ADDR_VAR 0 2
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 34
12036: PUSH
12037: LD_INT 12
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 34
12046: PUSH
12047: LD_INT 32
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 34
12056: PUSH
12057: LD_INT 51
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: EMPTY
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PPUSH
12070: CALL 11968 0 2
12074: ST_TO_ADDR
// end ;
12075: LD_VAR 0 2
12079: RET
// export function MCF_Ape ( side ) ; begin
12080: LD_INT 0
12082: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12083: LD_ADDR_VAR 0 2
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: LD_INT 2
12102: PUSH
12103: LD_INT 25
12105: PUSH
12106: LD_INT 12
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 15
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 25
12125: PUSH
12126: LD_INT 16
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 25
12135: PUSH
12136: LD_INT 17
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: PUSH
12150: EMPTY
12151: LIST
12152: LIST
12153: PPUSH
12154: CALL_OW 69
12158: ST_TO_ADDR
// end ;
12159: LD_VAR 0 2
12163: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12164: LD_INT 0
12166: PPUSH
12167: PPUSH
12168: PPUSH
12169: PPUSH
// result := [ ] ;
12170: LD_ADDR_VAR 0 3
12174: PUSH
12175: EMPTY
12176: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12177: LD_ADDR_VAR 0 4
12181: PUSH
12182: LD_VAR 0 1
12186: PPUSH
12187: CALL 12080 0 1
12191: ST_TO_ADDR
// case type of 0 , normal :
12192: LD_VAR 0 2
12196: PUSH
12197: LD_INT 0
12199: DOUBLE
12200: EQUAL
12201: IFTRUE 12211
12203: LD_STRING normal
12205: DOUBLE
12206: EQUAL
12207: IFTRUE 12211
12209: GO 12222
12211: POP
// cl := class_apeman ; 1 , soldier :
12212: LD_ADDR_VAR 0 5
12216: PUSH
12217: LD_INT 12
12219: ST_TO_ADDR
12220: GO 12298
12222: LD_INT 1
12224: DOUBLE
12225: EQUAL
12226: IFTRUE 12236
12228: LD_STRING soldier
12230: DOUBLE
12231: EQUAL
12232: IFTRUE 12236
12234: GO 12247
12236: POP
// cl := class_apeman_soldier ; 2 , engineer :
12237: LD_ADDR_VAR 0 5
12241: PUSH
12242: LD_INT 15
12244: ST_TO_ADDR
12245: GO 12298
12247: LD_INT 2
12249: DOUBLE
12250: EQUAL
12251: IFTRUE 12261
12253: LD_STRING engineer
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12272
12261: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_INT 16
12269: ST_TO_ADDR
12270: GO 12298
12272: LD_INT 3
12274: DOUBLE
12275: EQUAL
12276: IFTRUE 12286
12278: LD_STRING kamikaze
12280: DOUBLE
12281: EQUAL
12282: IFTRUE 12286
12284: GO 12297
12286: POP
// cl := class_apeman_kamikaze ; end ;
12287: LD_ADDR_VAR 0 5
12291: PUSH
12292: LD_INT 17
12294: ST_TO_ADDR
12295: GO 12298
12297: POP
// for i = 1 to tmp do
12298: LD_ADDR_VAR 0 6
12302: PUSH
12303: DOUBLE
12304: LD_INT 1
12306: DEC
12307: ST_TO_ADDR
12308: LD_VAR 0 4
12312: PUSH
12313: FOR_TO
12314: IFFALSE 12363
// if GetClass ( tmp [ i ] ) = cl then
12316: LD_VAR 0 4
12320: PUSH
12321: LD_VAR 0 6
12325: ARRAY
12326: PPUSH
12327: CALL_OW 257
12331: PUSH
12332: LD_VAR 0 5
12336: EQUAL
12337: IFFALSE 12361
// result := result ^ tmp [ i ] ;
12339: LD_ADDR_VAR 0 3
12343: PUSH
12344: LD_VAR 0 3
12348: PUSH
12349: LD_VAR 0 4
12353: PUSH
12354: LD_VAR 0 6
12358: ARRAY
12359: ADD
12360: ST_TO_ADDR
12361: GO 12313
12363: POP
12364: POP
// end ;
12365: LD_VAR 0 3
12369: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12370: LD_INT 0
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12376: LD_ADDR_VAR 0 5
12380: PUSH
12381: LD_INT 22
12383: PUSH
12384: LD_VAR 0 1
12388: PUSH
12389: EMPTY
12390: LIST
12391: LIST
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PPUSH
12402: CALL_OW 69
12406: ST_TO_ADDR
// r := [ ] ;
12407: LD_ADDR_VAR 0 6
12411: PUSH
12412: EMPTY
12413: ST_TO_ADDR
// if tmp then
12414: LD_VAR 0 5
12418: IFFALSE 12487
// for i = 1 to tmp do
12420: LD_ADDR_VAR 0 7
12424: PUSH
12425: DOUBLE
12426: LD_INT 1
12428: DEC
12429: ST_TO_ADDR
12430: LD_VAR 0 5
12434: PUSH
12435: FOR_TO
12436: IFFALSE 12485
// if GetTag ( tmp [ i ] ) = tag then
12438: LD_VAR 0 5
12442: PUSH
12443: LD_VAR 0 7
12447: ARRAY
12448: PPUSH
12449: CALL_OW 110
12453: PUSH
12454: LD_VAR 0 2
12458: EQUAL
12459: IFFALSE 12483
// r := r ^ tmp [ i ] ;
12461: LD_ADDR_VAR 0 6
12465: PUSH
12466: LD_VAR 0 6
12470: PUSH
12471: LD_VAR 0 5
12475: PUSH
12476: LD_VAR 0 7
12480: ARRAY
12481: ADD
12482: ST_TO_ADDR
12483: GO 12435
12485: POP
12486: POP
// result := r ;
12487: LD_ADDR_VAR 0 4
12491: PUSH
12492: LD_VAR 0 6
12496: ST_TO_ADDR
// end ;
12497: LD_VAR 0 4
12501: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12502: LD_INT 0
12504: PPUSH
12505: PPUSH
12506: PPUSH
// tmp := plist ;
12507: LD_ADDR_VAR 0 5
12511: PUSH
12512: LD_VAR 0 2
12516: ST_TO_ADDR
// if tmp then
12517: LD_VAR 0 5
12521: IFFALSE 12598
// begin for i = 1 to tmp do
12523: LD_ADDR_VAR 0 6
12527: PUSH
12528: DOUBLE
12529: LD_INT 1
12531: DEC
12532: ST_TO_ADDR
12533: LD_VAR 0 5
12537: PUSH
12538: FOR_TO
12539: IFFALSE 12586
// if GetTag ( tmp [ i ] ) <> tag then
12541: LD_VAR 0 5
12545: PUSH
12546: LD_VAR 0 6
12550: ARRAY
12551: PPUSH
12552: CALL_OW 110
12556: PUSH
12557: LD_VAR 0 3
12561: NONEQUAL
12562: IFFALSE 12584
// SetTag ( tmp [ i ] , tag ) ;
12564: LD_VAR 0 5
12568: PUSH
12569: LD_VAR 0 6
12573: ARRAY
12574: PPUSH
12575: LD_VAR 0 3
12579: PPUSH
12580: CALL_OW 109
12584: GO 12538
12586: POP
12587: POP
// result := true ;
12588: LD_ADDR_VAR 0 4
12592: PUSH
12593: LD_INT 1
12595: ST_TO_ADDR
// end else
12596: GO 12606
// result := false ;
12598: LD_ADDR_VAR 0 4
12602: PUSH
12603: LD_INT 0
12605: ST_TO_ADDR
// end ;
12606: LD_VAR 0 4
12610: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12611: LD_INT 0
12613: PPUSH
12614: PPUSH
12615: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12616: LD_ADDR_VAR 0 4
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: EMPTY
12632: PPUSH
12633: CALL 12370 0 3
12637: ST_TO_ADDR
// if tmp then
12638: LD_VAR 0 4
12642: IFFALSE 12694
// begin for i = 1 to tmp do
12644: LD_ADDR_VAR 0 5
12648: PUSH
12649: DOUBLE
12650: LD_INT 1
12652: DEC
12653: ST_TO_ADDR
12654: LD_VAR 0 4
12658: PUSH
12659: FOR_TO
12660: IFFALSE 12682
// SetTag ( tmp [ i ] , 0 ) ;
12662: LD_VAR 0 4
12666: PUSH
12667: LD_VAR 0 5
12671: ARRAY
12672: PPUSH
12673: LD_INT 0
12675: PPUSH
12676: CALL_OW 109
12680: GO 12659
12682: POP
12683: POP
// result := true ;
12684: LD_ADDR_VAR 0 3
12688: PUSH
12689: LD_INT 1
12691: ST_TO_ADDR
// end else
12692: GO 12702
// result := false ;
12694: LD_ADDR_VAR 0 3
12698: PUSH
12699: LD_INT 0
12701: ST_TO_ADDR
// end ;
12702: LD_VAR 0 3
12706: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12707: LD_INT 0
12709: PPUSH
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// sort_list := [ ] ;
12714: LD_ADDR_VAR 0 5
12718: PUSH
12719: EMPTY
12720: ST_TO_ADDR
// for i = 1 to list do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: DOUBLE
12727: LD_INT 1
12729: DEC
12730: ST_TO_ADDR
12731: LD_VAR 0 1
12735: PUSH
12736: FOR_TO
12737: IFFALSE 12899
// begin if i = 1 then
12739: LD_VAR 0 3
12743: PUSH
12744: LD_INT 1
12746: EQUAL
12747: IFFALSE 12773
// sort_list := sort_list ^ list [ i ] else
12749: LD_ADDR_VAR 0 5
12753: PUSH
12754: LD_VAR 0 5
12758: PUSH
12759: LD_VAR 0 1
12763: PUSH
12764: LD_VAR 0 3
12768: ARRAY
12769: ADD
12770: ST_TO_ADDR
12771: GO 12897
// begin for j = 1 to sort_list do
12773: LD_ADDR_VAR 0 4
12777: PUSH
12778: DOUBLE
12779: LD_INT 1
12781: DEC
12782: ST_TO_ADDR
12783: LD_VAR 0 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12866
// begin add := false ;
12791: LD_ADDR_VAR 0 6
12795: PUSH
12796: LD_INT 0
12798: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12799: LD_VAR 0 1
12803: PUSH
12804: LD_VAR 0 3
12808: ARRAY
12809: PUSH
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: LESS
12821: IFFALSE 12864
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12823: LD_ADDR_VAR 0 5
12827: PUSH
12828: LD_VAR 0 5
12832: PPUSH
12833: LD_VAR 0 4
12837: PPUSH
12838: LD_VAR 0 1
12842: PUSH
12843: LD_VAR 0 3
12847: ARRAY
12848: PPUSH
12849: CALL_OW 2
12853: ST_TO_ADDR
// add := true ;
12854: LD_ADDR_VAR 0 6
12858: PUSH
12859: LD_INT 1
12861: ST_TO_ADDR
// break ;
12862: GO 12866
// end ; end ;
12864: GO 12788
12866: POP
12867: POP
// if not add then
12868: LD_VAR 0 6
12872: NOT
12873: IFFALSE 12897
// sort_list := sort_list ^ list [ i ] ;
12875: LD_ADDR_VAR 0 5
12879: PUSH
12880: LD_VAR 0 5
12884: PUSH
12885: LD_VAR 0 1
12889: PUSH
12890: LD_VAR 0 3
12894: ARRAY
12895: ADD
12896: ST_TO_ADDR
// end ; end ;
12897: GO 12736
12899: POP
12900: POP
// result := sort_list ;
12901: LD_ADDR_VAR 0 2
12905: PUSH
12906: LD_VAR 0 5
12910: ST_TO_ADDR
// end ;
12911: LD_VAR 0 2
12915: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12916: LD_INT 0
12918: PPUSH
12919: PPUSH
12920: PPUSH
12921: PPUSH
12922: PPUSH
// sort_list := [ ] ;
12923: LD_ADDR_VAR 0 5
12927: PUSH
12928: EMPTY
12929: ST_TO_ADDR
// for i = 1 to list do
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: DOUBLE
12936: LD_INT 1
12938: DEC
12939: ST_TO_ADDR
12940: LD_VAR 0 1
12944: PUSH
12945: FOR_TO
12946: IFFALSE 13108
// begin if i = 1 then
12948: LD_VAR 0 3
12952: PUSH
12953: LD_INT 1
12955: EQUAL
12956: IFFALSE 12982
// sort_list := sort_list ^ list [ i ] else
12958: LD_ADDR_VAR 0 5
12962: PUSH
12963: LD_VAR 0 5
12967: PUSH
12968: LD_VAR 0 1
12972: PUSH
12973: LD_VAR 0 3
12977: ARRAY
12978: ADD
12979: ST_TO_ADDR
12980: GO 13106
// begin for j = 1 to sort_list do
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: DOUBLE
12988: LD_INT 1
12990: DEC
12991: ST_TO_ADDR
12992: LD_VAR 0 5
12996: PUSH
12997: FOR_TO
12998: IFFALSE 13075
// begin add := false ;
13000: LD_ADDR_VAR 0 6
13004: PUSH
13005: LD_INT 0
13007: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
13008: LD_VAR 0 1
13012: PUSH
13013: LD_VAR 0 3
13017: ARRAY
13018: PUSH
13019: LD_VAR 0 5
13023: PUSH
13024: LD_VAR 0 4
13028: ARRAY
13029: GREATER
13030: IFFALSE 13073
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
13032: LD_ADDR_VAR 0 5
13036: PUSH
13037: LD_VAR 0 5
13041: PPUSH
13042: LD_VAR 0 4
13046: PPUSH
13047: LD_VAR 0 1
13051: PUSH
13052: LD_VAR 0 3
13056: ARRAY
13057: PPUSH
13058: CALL_OW 2
13062: ST_TO_ADDR
// add := true ;
13063: LD_ADDR_VAR 0 6
13067: PUSH
13068: LD_INT 1
13070: ST_TO_ADDR
// break ;
13071: GO 13075
// end ; end ;
13073: GO 12997
13075: POP
13076: POP
// if not add then
13077: LD_VAR 0 6
13081: NOT
13082: IFFALSE 13106
// sort_list := sort_list ^ list [ i ] ;
13084: LD_ADDR_VAR 0 5
13088: PUSH
13089: LD_VAR 0 5
13093: PUSH
13094: LD_VAR 0 1
13098: PUSH
13099: LD_VAR 0 3
13103: ARRAY
13104: ADD
13105: ST_TO_ADDR
// end ; end ;
13106: GO 12945
13108: POP
13109: POP
// result := sort_list ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_VAR 0 5
13119: ST_TO_ADDR
// end ;
13120: LD_VAR 0 2
13124: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13125: LD_INT 0
13127: PPUSH
13128: PPUSH
13129: PPUSH
13130: PPUSH
13131: PPUSH
13132: PPUSH
// tmp := [ ] ;
13133: LD_ADDR_VAR 0 8
13137: PUSH
13138: EMPTY
13139: ST_TO_ADDR
// r := [ ] ;
13140: LD_ADDR_VAR 0 7
13144: PUSH
13145: EMPTY
13146: ST_TO_ADDR
// add := false ;
13147: LD_ADDR_VAR 0 9
13151: PUSH
13152: LD_INT 0
13154: ST_TO_ADDR
// if plist then
13155: LD_VAR 0 2
13159: IFFALSE 13235
// begin for i = 1 to plist do
13161: LD_ADDR_VAR 0 5
13165: PUSH
13166: DOUBLE
13167: LD_INT 1
13169: DEC
13170: ST_TO_ADDR
13171: LD_VAR 0 2
13175: PUSH
13176: FOR_TO
13177: IFFALSE 13231
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13179: LD_ADDR_VAR 0 8
13183: PUSH
13184: LD_VAR 0 8
13188: PUSH
13189: LD_VAR 0 2
13193: PUSH
13194: LD_VAR 0 5
13198: ARRAY
13199: PUSH
13200: LD_VAR 0 2
13204: PUSH
13205: LD_VAR 0 5
13209: ARRAY
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: CALL_OW 259
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PUSH
13225: EMPTY
13226: LIST
13227: ADD
13228: ST_TO_ADDR
// end ;
13229: GO 13176
13231: POP
13232: POP
// end else
13233: GO 13243
// result := false ;
13235: LD_ADDR_VAR 0 4
13239: PUSH
13240: LD_INT 0
13242: ST_TO_ADDR
// if tmp then
13243: LD_VAR 0 8
13247: IFFALSE 13421
// begin r := r ^ [ tmp [ 1 ] ] ;
13249: LD_ADDR_VAR 0 7
13253: PUSH
13254: LD_VAR 0 7
13258: PUSH
13259: LD_VAR 0 8
13263: PUSH
13264: LD_INT 1
13266: ARRAY
13267: PUSH
13268: EMPTY
13269: LIST
13270: ADD
13271: ST_TO_ADDR
// for i = 2 to tmp do
13272: LD_ADDR_VAR 0 5
13276: PUSH
13277: DOUBLE
13278: LD_INT 2
13280: DEC
13281: ST_TO_ADDR
13282: LD_VAR 0 8
13286: PUSH
13287: FOR_TO
13288: IFFALSE 13419
// begin for j = 1 to r do
13290: LD_ADDR_VAR 0 6
13294: PUSH
13295: DOUBLE
13296: LD_INT 1
13298: DEC
13299: ST_TO_ADDR
13300: LD_VAR 0 7
13304: PUSH
13305: FOR_TO
13306: IFFALSE 13383
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13308: LD_VAR 0 8
13312: PUSH
13313: LD_VAR 0 5
13317: ARRAY
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PUSH
13323: LD_VAR 0 7
13327: PUSH
13328: LD_VAR 0 6
13332: ARRAY
13333: PUSH
13334: LD_INT 2
13336: ARRAY
13337: LESS
13338: IFFALSE 13381
// begin r := Insert ( r , j , tmp [ i ] ) ;
13340: LD_ADDR_VAR 0 7
13344: PUSH
13345: LD_VAR 0 7
13349: PPUSH
13350: LD_VAR 0 6
13354: PPUSH
13355: LD_VAR 0 8
13359: PUSH
13360: LD_VAR 0 5
13364: ARRAY
13365: PPUSH
13366: CALL_OW 2
13370: ST_TO_ADDR
// add := true ;
13371: LD_ADDR_VAR 0 9
13375: PUSH
13376: LD_INT 1
13378: ST_TO_ADDR
// break ;
13379: GO 13383
// end ; end ;
13381: GO 13305
13383: POP
13384: POP
// if not add then
13385: LD_VAR 0 9
13389: NOT
13390: IFFALSE 13417
// r := r ^ [ tmp [ i ] ] ;
13392: LD_ADDR_VAR 0 7
13396: PUSH
13397: LD_VAR 0 7
13401: PUSH
13402: LD_VAR 0 8
13406: PUSH
13407: LD_VAR 0 5
13411: ARRAY
13412: PUSH
13413: EMPTY
13414: LIST
13415: ADD
13416: ST_TO_ADDR
// end ;
13417: GO 13287
13419: POP
13420: POP
// end ; result := r ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_VAR 0 7
13430: ST_TO_ADDR
// end ;
13431: LD_VAR 0 4
13435: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13436: LD_INT 0
13438: PPUSH
13439: PPUSH
13440: PPUSH
13441: PPUSH
13442: PPUSH
13443: PPUSH
// tmp := [ ] ;
13444: LD_ADDR_VAR 0 8
13448: PUSH
13449: EMPTY
13450: ST_TO_ADDR
// r := [ ] ;
13451: LD_ADDR_VAR 0 7
13455: PUSH
13456: EMPTY
13457: ST_TO_ADDR
// add := false ;
13458: LD_ADDR_VAR 0 9
13462: PUSH
13463: LD_INT 0
13465: ST_TO_ADDR
// if plist then
13466: LD_VAR 0 2
13470: IFFALSE 13546
// begin for i = 1 to plist do
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: DOUBLE
13478: LD_INT 1
13480: DEC
13481: ST_TO_ADDR
13482: LD_VAR 0 2
13486: PUSH
13487: FOR_TO
13488: IFFALSE 13542
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13490: LD_ADDR_VAR 0 8
13494: PUSH
13495: LD_VAR 0 8
13499: PUSH
13500: LD_VAR 0 2
13504: PUSH
13505: LD_VAR 0 5
13509: ARRAY
13510: PUSH
13511: LD_VAR 0 2
13515: PUSH
13516: LD_VAR 0 5
13520: ARRAY
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: CALL_OW 259
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: EMPTY
13537: LIST
13538: ADD
13539: ST_TO_ADDR
// end ;
13540: GO 13487
13542: POP
13543: POP
// end else
13544: GO 13554
// result := false ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// if tmp then
13554: LD_VAR 0 8
13558: IFFALSE 13732
// begin r := r ^ [ tmp [ 1 ] ] ;
13560: LD_ADDR_VAR 0 7
13564: PUSH
13565: LD_VAR 0 7
13569: PUSH
13570: LD_VAR 0 8
13574: PUSH
13575: LD_INT 1
13577: ARRAY
13578: PUSH
13579: EMPTY
13580: LIST
13581: ADD
13582: ST_TO_ADDR
// for i = 2 to tmp do
13583: LD_ADDR_VAR 0 5
13587: PUSH
13588: DOUBLE
13589: LD_INT 2
13591: DEC
13592: ST_TO_ADDR
13593: LD_VAR 0 8
13597: PUSH
13598: FOR_TO
13599: IFFALSE 13730
// begin for j = 1 to r do
13601: LD_ADDR_VAR 0 6
13605: PUSH
13606: DOUBLE
13607: LD_INT 1
13609: DEC
13610: ST_TO_ADDR
13611: LD_VAR 0 7
13615: PUSH
13616: FOR_TO
13617: IFFALSE 13694
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13619: LD_VAR 0 8
13623: PUSH
13624: LD_VAR 0 5
13628: ARRAY
13629: PUSH
13630: LD_INT 2
13632: ARRAY
13633: PUSH
13634: LD_VAR 0 7
13638: PUSH
13639: LD_VAR 0 6
13643: ARRAY
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: GREATER
13649: IFFALSE 13692
// begin r := Insert ( r , j , tmp [ i ] ) ;
13651: LD_ADDR_VAR 0 7
13655: PUSH
13656: LD_VAR 0 7
13660: PPUSH
13661: LD_VAR 0 6
13665: PPUSH
13666: LD_VAR 0 8
13670: PUSH
13671: LD_VAR 0 5
13675: ARRAY
13676: PPUSH
13677: CALL_OW 2
13681: ST_TO_ADDR
// add := true ;
13682: LD_ADDR_VAR 0 9
13686: PUSH
13687: LD_INT 1
13689: ST_TO_ADDR
// break ;
13690: GO 13694
// end ; end ;
13692: GO 13616
13694: POP
13695: POP
// if not add then
13696: LD_VAR 0 9
13700: NOT
13701: IFFALSE 13728
// r := r ^ [ tmp [ i ] ] ;
13703: LD_ADDR_VAR 0 7
13707: PUSH
13708: LD_VAR 0 7
13712: PUSH
13713: LD_VAR 0 8
13717: PUSH
13718: LD_VAR 0 5
13722: ARRAY
13723: PUSH
13724: EMPTY
13725: LIST
13726: ADD
13727: ST_TO_ADDR
// end ;
13728: GO 13598
13730: POP
13731: POP
// end ; result := r ;
13732: LD_ADDR_VAR 0 4
13736: PUSH
13737: LD_VAR 0 7
13741: ST_TO_ADDR
// end ;
13742: LD_VAR 0 4
13746: RET
// export function MCF_Clear ( side ) ; var i ; begin
13747: LD_INT 0
13749: PPUSH
13750: PPUSH
// for i = 1 to 100 do
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: DOUBLE
13757: LD_INT 1
13759: DEC
13760: ST_TO_ADDR
13761: LD_INT 100
13763: PUSH
13764: FOR_TO
13765: IFFALSE 13801
// if MCF_Tag ( side , i , [ ] ) then
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 3
13776: PPUSH
13777: EMPTY
13778: PPUSH
13779: CALL 12370 0 3
13783: IFFALSE 13799
// MCF_ClearTag ( side , i ) ;
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 3
13794: PPUSH
13795: CALL 12611 0 2
13799: GO 13764
13801: POP
13802: POP
// result := true ;
13803: LD_ADDR_VAR 0 2
13807: PUSH
13808: LD_INT 1
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 2
13815: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13816: LD_INT 0
13818: PPUSH
13819: PPUSH
13820: PPUSH
// for i = 1 to plist do
13821: LD_ADDR_VAR 0 4
13825: PUSH
13826: DOUBLE
13827: LD_INT 1
13829: DEC
13830: ST_TO_ADDR
13831: LD_VAR 0 1
13835: PUSH
13836: FOR_TO
13837: IFFALSE 13886
// if MCF_HasClass ( plist [ i ] ) = n then
13839: LD_VAR 0 1
13843: PUSH
13844: LD_VAR 0 4
13848: ARRAY
13849: PPUSH
13850: CALL 14373 0 1
13854: PUSH
13855: LD_VAR 0 2
13859: EQUAL
13860: IFFALSE 13884
// tmp := tmp ^ plist [ i ] ;
13862: LD_ADDR_VAR 0 5
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_VAR 0 1
13876: PUSH
13877: LD_VAR 0 4
13881: ARRAY
13882: ADD
13883: ST_TO_ADDR
13884: GO 13836
13886: POP
13887: POP
// result := tmp ;
13888: LD_ADDR_VAR 0 3
13892: PUSH
13893: LD_VAR 0 5
13897: ST_TO_ADDR
// end ;
13898: LD_VAR 0 3
13902: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// if mreg = ToArm then
13908: LD_VAR 0 2
13912: PUSH
13913: LD_STRING ToArm
13915: EQUAL
13916: IFFALSE 14021
// begin tmp := MREG_ToArm [ side ] ;
13918: LD_ADDR_VAR 0 6
13922: PUSH
13923: LD_EXP 56
13927: PUSH
13928: LD_VAR 0 1
13932: ARRAY
13933: ST_TO_ADDR
// if tmp = 0 then
13934: LD_VAR 0 6
13938: PUSH
13939: LD_INT 0
13941: EQUAL
13942: IFFALSE 13948
// exit else
13944: GO 14368
13946: GO 14021
// begin for i = MREG_ToArm [ side ] downto n do
13948: LD_ADDR_VAR 0 5
13952: PUSH
13953: DOUBLE
13954: LD_EXP 56
13958: PUSH
13959: LD_VAR 0 1
13963: ARRAY
13964: INC
13965: ST_TO_ADDR
13966: LD_VAR 0 3
13970: PUSH
13971: FOR_DOWNTO
13972: IFFALSE 13994
// tmp := Delete ( tmp , 1 ) ;
13974: LD_ADDR_VAR 0 6
13978: PUSH
13979: LD_VAR 0 6
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 3
13991: ST_TO_ADDR
13992: GO 13971
13994: POP
13995: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13996: LD_ADDR_EXP 56
14000: PUSH
14001: LD_EXP 56
14005: PPUSH
14006: LD_VAR 0 1
14010: PPUSH
14011: LD_VAR 0 6
14015: PPUSH
14016: CALL_OW 1
14020: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
14021: LD_VAR 0 2
14025: PUSH
14026: LD_STRING ToDep
14028: EQUAL
14029: IFFALSE 14134
// begin tmp := MREG_ToDep [ side ] ;
14031: LD_ADDR_VAR 0 6
14035: PUSH
14036: LD_EXP 57
14040: PUSH
14041: LD_VAR 0 1
14045: ARRAY
14046: ST_TO_ADDR
// if tmp = 0 then
14047: LD_VAR 0 6
14051: PUSH
14052: LD_INT 0
14054: EQUAL
14055: IFFALSE 14061
// exit else
14057: GO 14368
14059: GO 14134
// begin for i = MREG_ToDep [ side ] downto n do
14061: LD_ADDR_VAR 0 5
14065: PUSH
14066: DOUBLE
14067: LD_EXP 57
14071: PUSH
14072: LD_VAR 0 1
14076: ARRAY
14077: INC
14078: ST_TO_ADDR
14079: LD_VAR 0 3
14083: PUSH
14084: FOR_DOWNTO
14085: IFFALSE 14107
// tmp := Delete ( tmp , 1 ) ;
14087: LD_ADDR_VAR 0 6
14091: PUSH
14092: LD_VAR 0 6
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 3
14104: ST_TO_ADDR
14105: GO 14084
14107: POP
14108: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14109: LD_ADDR_EXP 57
14113: PUSH
14114: LD_EXP 57
14118: PPUSH
14119: LD_VAR 0 1
14123: PPUSH
14124: LD_VAR 0 6
14128: PPUSH
14129: CALL_OW 1
14133: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14134: LD_VAR 0 2
14138: PUSH
14139: LD_STRING ToFac
14141: EQUAL
14142: IFFALSE 14247
// begin tmp := MREG_ToFac [ side ] ;
14144: LD_ADDR_VAR 0 6
14148: PUSH
14149: LD_EXP 55
14153: PUSH
14154: LD_VAR 0 1
14158: ARRAY
14159: ST_TO_ADDR
// if tmp = 0 then
14160: LD_VAR 0 6
14164: PUSH
14165: LD_INT 0
14167: EQUAL
14168: IFFALSE 14174
// exit else
14170: GO 14368
14172: GO 14247
// begin for i = MREG_ToFac [ side ] downto n do
14174: LD_ADDR_VAR 0 5
14178: PUSH
14179: DOUBLE
14180: LD_EXP 55
14184: PUSH
14185: LD_VAR 0 1
14189: ARRAY
14190: INC
14191: ST_TO_ADDR
14192: LD_VAR 0 3
14196: PUSH
14197: FOR_DOWNTO
14198: IFFALSE 14220
// tmp := Delete ( tmp , 1 ) ;
14200: LD_ADDR_VAR 0 6
14204: PUSH
14205: LD_VAR 0 6
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: CALL_OW 3
14217: ST_TO_ADDR
14218: GO 14197
14220: POP
14221: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14222: LD_ADDR_EXP 55
14226: PUSH
14227: LD_EXP 55
14231: PPUSH
14232: LD_VAR 0 1
14236: PPUSH
14237: LD_VAR 0 6
14241: PPUSH
14242: CALL_OW 1
14246: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14247: LD_VAR 0 2
14251: PUSH
14252: LD_STRING ToLab
14254: EQUAL
14255: IFFALSE 14360
// begin tmp := MREG_ToLab [ side ] ;
14257: LD_ADDR_VAR 0 6
14261: PUSH
14262: LD_EXP 54
14266: PUSH
14267: LD_VAR 0 1
14271: ARRAY
14272: ST_TO_ADDR
// if tmp = 0 then
14273: LD_VAR 0 6
14277: PUSH
14278: LD_INT 0
14280: EQUAL
14281: IFFALSE 14287
// exit else
14283: GO 14368
14285: GO 14360
// begin for i = MREG_ToLab [ side ] downto n do
14287: LD_ADDR_VAR 0 5
14291: PUSH
14292: DOUBLE
14293: LD_EXP 54
14297: PUSH
14298: LD_VAR 0 1
14302: ARRAY
14303: INC
14304: ST_TO_ADDR
14305: LD_VAR 0 3
14309: PUSH
14310: FOR_DOWNTO
14311: IFFALSE 14333
// tmp := Delete ( tmp , 1 ) ;
14313: LD_ADDR_VAR 0 6
14317: PUSH
14318: LD_VAR 0 6
14322: PPUSH
14323: LD_INT 1
14325: PPUSH
14326: CALL_OW 3
14330: ST_TO_ADDR
14331: GO 14310
14333: POP
14334: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14335: LD_ADDR_EXP 54
14339: PUSH
14340: LD_EXP 54
14344: PPUSH
14345: LD_VAR 0 1
14349: PPUSH
14350: LD_VAR 0 6
14354: PPUSH
14355: CALL_OW 1
14359: ST_TO_ADDR
// end ; end ; result := true ;
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_INT 1
14367: ST_TO_ADDR
// end ;
14368: LD_VAR 0 4
14372: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14373: LD_INT 0
14375: PPUSH
14376: PPUSH
14377: PPUSH
// side := GetSide ( unit ) ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_VAR 0 1
14387: PPUSH
14388: CALL_OW 255
14392: ST_TO_ADDR
// tmp := 0 ;
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 0
14400: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14401: LD_VAR 0 1
14405: PUSH
14406: LD_EXP 56
14410: PUSH
14411: LD_VAR 0 4
14415: ARRAY
14416: IN
14417: IFFALSE 14427
// tmp := 1 ;
14419: LD_ADDR_VAR 0 3
14423: PUSH
14424: LD_INT 1
14426: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14427: LD_VAR 0 1
14431: PUSH
14432: LD_EXP 57
14436: PUSH
14437: LD_VAR 0 4
14441: ARRAY
14442: IN
14443: IFFALSE 14453
// tmp := 2 ;
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 2
14452: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14453: LD_VAR 0 1
14457: PUSH
14458: LD_EXP 55
14462: PUSH
14463: LD_VAR 0 4
14467: ARRAY
14468: IN
14469: IFFALSE 14479
// tmp := 3 ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 3
14478: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14479: LD_VAR 0 1
14483: PUSH
14484: LD_EXP 54
14488: PUSH
14489: LD_VAR 0 4
14493: ARRAY
14494: IN
14495: IFFALSE 14505
// tmp := 4 ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: LD_INT 4
14504: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_EXP 68
14514: PUSH
14515: LD_VAR 0 4
14519: ARRAY
14520: IN
14521: IFFALSE 14531
// tmp := 5 ;
14523: LD_ADDR_VAR 0 3
14527: PUSH
14528: LD_INT 5
14530: ST_TO_ADDR
// result := tmp ;
14531: LD_ADDR_VAR 0 2
14535: PUSH
14536: LD_VAR 0 3
14540: ST_TO_ADDR
// end ;
14541: LD_VAR 0 2
14545: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14546: LD_INT 0
14548: PPUSH
14549: PPUSH
// if mreg = ToArm then
14550: LD_VAR 0 2
14554: PUSH
14555: LD_STRING ToArm
14557: EQUAL
14558: IFFALSE 14647
// for i = MREG_ToArm [ side ] downto 1 do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_EXP 56
14570: PUSH
14571: LD_VAR 0 1
14575: ARRAY
14576: INC
14577: ST_TO_ADDR
14578: LD_INT 1
14580: PUSH
14581: FOR_DOWNTO
14582: IFFALSE 14645
// if MREG_ToArm [ side ] [ i ] = unit then
14584: LD_EXP 56
14588: PUSH
14589: LD_VAR 0 1
14593: ARRAY
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PUSH
14601: LD_VAR 0 3
14605: EQUAL
14606: IFFALSE 14643
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14608: LD_ADDR_EXP 56
14612: PUSH
14613: LD_EXP 56
14617: PPUSH
14618: LD_EXP 56
14622: PUSH
14623: LD_VAR 0 1
14627: ARRAY
14628: PUSH
14629: LD_VAR 0 5
14633: ARRAY
14634: PPUSH
14635: LD_INT 1
14637: PPUSH
14638: CALL 31305 0 3
14642: ST_TO_ADDR
// end ;
14643: GO 14581
14645: POP
14646: POP
// if mreg = ToDep then
14647: LD_VAR 0 2
14651: PUSH
14652: LD_STRING ToDep
14654: EQUAL
14655: IFFALSE 14744
// for i = MREG_ToDep [ side ] downto 1 do
14657: LD_ADDR_VAR 0 5
14661: PUSH
14662: DOUBLE
14663: LD_EXP 57
14667: PUSH
14668: LD_VAR 0 1
14672: ARRAY
14673: INC
14674: ST_TO_ADDR
14675: LD_INT 1
14677: PUSH
14678: FOR_DOWNTO
14679: IFFALSE 14742
// if MREG_ToDep [ side ] [ i ] = unit then
14681: LD_EXP 57
14685: PUSH
14686: LD_VAR 0 1
14690: ARRAY
14691: PUSH
14692: LD_VAR 0 5
14696: ARRAY
14697: PUSH
14698: LD_VAR 0 3
14702: EQUAL
14703: IFFALSE 14740
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14705: LD_ADDR_EXP 57
14709: PUSH
14710: LD_EXP 57
14714: PPUSH
14715: LD_EXP 57
14719: PUSH
14720: LD_VAR 0 1
14724: ARRAY
14725: PUSH
14726: LD_VAR 0 5
14730: ARRAY
14731: PPUSH
14732: LD_INT 1
14734: PPUSH
14735: CALL 31305 0 3
14739: ST_TO_ADDR
// end ;
14740: GO 14678
14742: POP
14743: POP
// if mreg = ToFac then
14744: LD_VAR 0 2
14748: PUSH
14749: LD_STRING ToFac
14751: EQUAL
14752: IFFALSE 14841
// for i = MREG_ToFac [ side ] downto 1 do
14754: LD_ADDR_VAR 0 5
14758: PUSH
14759: DOUBLE
14760: LD_EXP 55
14764: PUSH
14765: LD_VAR 0 1
14769: ARRAY
14770: INC
14771: ST_TO_ADDR
14772: LD_INT 1
14774: PUSH
14775: FOR_DOWNTO
14776: IFFALSE 14839
// if MREG_ToFac [ side ] [ i ] = unit then
14778: LD_EXP 55
14782: PUSH
14783: LD_VAR 0 1
14787: ARRAY
14788: PUSH
14789: LD_VAR 0 5
14793: ARRAY
14794: PUSH
14795: LD_VAR 0 3
14799: EQUAL
14800: IFFALSE 14837
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14802: LD_ADDR_EXP 55
14806: PUSH
14807: LD_EXP 55
14811: PPUSH
14812: LD_EXP 55
14816: PUSH
14817: LD_VAR 0 1
14821: ARRAY
14822: PUSH
14823: LD_VAR 0 5
14827: ARRAY
14828: PPUSH
14829: LD_INT 1
14831: PPUSH
14832: CALL 31305 0 3
14836: ST_TO_ADDR
// end ;
14837: GO 14775
14839: POP
14840: POP
// if mreg = ToLab then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_STRING ToLab
14848: EQUAL
14849: IFFALSE 14938
// for i = MREG_ToLab [ side ] downto 1 do
14851: LD_ADDR_VAR 0 5
14855: PUSH
14856: DOUBLE
14857: LD_EXP 54
14861: PUSH
14862: LD_VAR 0 1
14866: ARRAY
14867: INC
14868: ST_TO_ADDR
14869: LD_INT 1
14871: PUSH
14872: FOR_DOWNTO
14873: IFFALSE 14936
// if MREG_ToLab [ side ] [ i ] = unit then
14875: LD_EXP 54
14879: PUSH
14880: LD_VAR 0 1
14884: ARRAY
14885: PUSH
14886: LD_VAR 0 5
14890: ARRAY
14891: PUSH
14892: LD_VAR 0 3
14896: EQUAL
14897: IFFALSE 14934
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14899: LD_ADDR_EXP 54
14903: PUSH
14904: LD_EXP 54
14908: PPUSH
14909: LD_EXP 54
14913: PUSH
14914: LD_VAR 0 1
14918: ARRAY
14919: PUSH
14920: LD_VAR 0 5
14924: ARRAY
14925: PPUSH
14926: LD_INT 1
14928: PPUSH
14929: CALL 31305 0 3
14933: ST_TO_ADDR
// end ;
14934: GO 14872
14936: POP
14937: POP
// end ;
14938: LD_VAR 0 4
14942: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14943: LD_INT 0
14945: PPUSH
14946: PPUSH
// result := false ;
14947: LD_ADDR_VAR 0 2
14951: PUSH
14952: LD_INT 0
14954: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14955: LD_ADDR_VAR 0 3
14959: PUSH
14960: DOUBLE
14961: LD_INT 1
14963: DEC
14964: ST_TO_ADDR
14965: LD_EXP 46
14969: PUSH
14970: FOR_TO
14971: IFFALSE 15035
// if MREG_ToBuild [ i ] [ 1 ] = side then
14973: LD_EXP 46
14977: PUSH
14978: LD_VAR 0 3
14982: ARRAY
14983: PUSH
14984: LD_INT 1
14986: ARRAY
14987: PUSH
14988: LD_VAR 0 1
14992: EQUAL
14993: IFFALSE 15033
// begin if MREG_ToBuild [ i ] [ 1 ] then
14995: LD_EXP 46
14999: PUSH
15000: LD_VAR 0 3
15004: ARRAY
15005: PUSH
15006: LD_INT 1
15008: ARRAY
15009: IFFALSE 15033
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
15011: LD_ADDR_VAR 0 2
15015: PUSH
15016: LD_EXP 46
15020: PUSH
15021: LD_VAR 0 3
15025: ARRAY
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: ST_TO_ADDR
// break ;
15031: GO 15035
// end ; end ;
15033: GO 14970
15035: POP
15036: POP
// for i = 1 to MREG_ToRepair do
15037: LD_ADDR_VAR 0 3
15041: PUSH
15042: DOUBLE
15043: LD_INT 1
15045: DEC
15046: ST_TO_ADDR
15047: LD_EXP 47
15051: PUSH
15052: FOR_TO
15053: IFFALSE 15117
// if MREG_ToRepair [ i ] [ 1 ] = side then
15055: LD_EXP 47
15059: PUSH
15060: LD_VAR 0 3
15064: ARRAY
15065: PUSH
15066: LD_INT 1
15068: ARRAY
15069: PUSH
15070: LD_VAR 0 1
15074: EQUAL
15075: IFFALSE 15115
// begin if MREG_ToRepair [ i ] [ 1 ] then
15077: LD_EXP 47
15081: PUSH
15082: LD_VAR 0 3
15086: ARRAY
15087: PUSH
15088: LD_INT 1
15090: ARRAY
15091: IFFALSE 15115
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15093: LD_ADDR_VAR 0 2
15097: PUSH
15098: LD_EXP 47
15102: PUSH
15103: LD_VAR 0 3
15107: ARRAY
15108: PUSH
15109: LD_INT 1
15111: ARRAY
15112: ST_TO_ADDR
// break ;
15113: GO 15117
// end ; end ;
15115: GO 15052
15117: POP
15118: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15119: LD_VAR 0 1
15123: PPUSH
15124: LD_INT 57
15126: PUSH
15127: EMPTY
15128: LIST
15129: PPUSH
15130: CALL 11667 0 2
15134: IFFALSE 15161
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15136: LD_ADDR_VAR 0 2
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 57
15148: PUSH
15149: EMPTY
15150: LIST
15151: PPUSH
15152: CALL 11667 0 2
15156: PUSH
15157: LD_INT 1
15159: ARRAY
15160: ST_TO_ADDR
// end ;
15161: LD_VAR 0 2
15165: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15166: LD_INT 0
15168: PPUSH
15169: PPUSH
15170: PPUSH
15171: PPUSH
15172: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15173: LD_ADDR_VAR 0 6
15177: PUSH
15178: LD_VAR 0 1
15182: PPUSH
15183: LD_INT 21
15185: PUSH
15186: LD_INT 3
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PPUSH
15193: CALL 11667 0 2
15197: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15198: LD_ADDR_VAR 0 7
15202: PUSH
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_INT 81
15210: PUSH
15211: LD_VAR 0 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL 11667 0 2
15224: ST_TO_ADDR
// if not enemy then
15225: LD_VAR 0 7
15229: NOT
15230: IFFALSE 15242
// result := false else
15232: LD_ADDR_VAR 0 3
15236: PUSH
15237: LD_INT 0
15239: ST_TO_ADDR
15240: GO 15296
// begin scan := NearestUnit ( b , enemy ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 6
15251: PPUSH
15252: LD_VAR 0 7
15256: PPUSH
15257: CALL 32298 0 2
15261: ST_TO_ADDR
// if scan [ 2 ] < dist then
15262: LD_VAR 0 5
15266: PUSH
15267: LD_INT 2
15269: ARRAY
15270: PUSH
15271: LD_VAR 0 2
15275: LESS
15276: IFFALSE 15288
// result := true else
15278: LD_ADDR_VAR 0 3
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
15286: GO 15296
// result := false ;
15288: LD_ADDR_VAR 0 3
15292: PUSH
15293: LD_INT 0
15295: ST_TO_ADDR
// end ; end ;
15296: LD_VAR 0 3
15300: RET
// export function MCF_Info ( ) ; begin
15301: LD_INT 0
15303: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15304: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15306: PUSH
15307: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15309: ADD
15310: PUSH
15311: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15313: ADD
15314: PUSH
15315: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15317: ADD
15318: PUSH
15319: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15321: ADD
15322: PUSH
15323: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15325: ADD
15326: PUSH
15327: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15329: ADD
15330: PUSH
15331: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15333: ADD
15334: PUSH
15335: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15337: ADD
15338: PUSH
15339: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15341: ADD
15342: PPUSH
15343: CALL 8585 0 1
// end ; end_of_file
15347: LD_VAR 0 1
15351: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15352: LD_INT 0
15354: PPUSH
15355: PPUSH
15356: PPUSH
15357: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15358: LD_ADDR_VAR 0 5
15362: PUSH
15363: LD_VAR 0 1
15367: PPUSH
15368: LD_INT 2
15370: PUSH
15371: LD_INT 25
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 25
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: LD_INT 25
15393: PUSH
15394: LD_INT 4
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: EMPTY
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: PPUSH
15407: CALL 11667 0 2
15411: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15412: LD_ADDR_VAR 0 5
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_INT 0
15424: PPUSH
15425: CALL 13816 0 2
15429: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15430: LD_ADDR_VAR 0 6
15434: PUSH
15435: LD_VAR 0 1
15439: PPUSH
15440: LD_VAR 0 5
15444: PPUSH
15445: LD_INT 1
15447: PPUSH
15448: CALL 13436 0 3
15452: ST_TO_ADDR
// if n > sk then
15453: LD_VAR 0 2
15457: PUSH
15458: LD_VAR 0 6
15462: GREATER
15463: IFFALSE 15475
// n := sk ;
15465: LD_ADDR_VAR 0 2
15469: PUSH
15470: LD_VAR 0 6
15474: ST_TO_ADDR
// for i = 1 to n do
15475: LD_ADDR_VAR 0 4
15479: PUSH
15480: DOUBLE
15481: LD_INT 1
15483: DEC
15484: ST_TO_ADDR
15485: LD_VAR 0 2
15489: PUSH
15490: FOR_TO
15491: IFFALSE 15603
// if ( sk [ i ] [ 1 ] ) <> 0 then
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 4
15502: ARRAY
15503: PUSH
15504: LD_INT 1
15506: ARRAY
15507: PUSH
15508: LD_INT 0
15510: NONEQUAL
15511: IFFALSE 15601
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15513: LD_ADDR_EXP 53
15517: PUSH
15518: LD_EXP 53
15522: PPUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_VAR 0 6
15532: PUSH
15533: LD_VAR 0 4
15537: ARRAY
15538: PUSH
15539: LD_INT 1
15541: ARRAY
15542: PPUSH
15543: LD_INT 1
15545: PPUSH
15546: CALL 41976 0 4
15550: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15551: LD_ADDR_EXP 56
15555: PUSH
15556: LD_EXP 56
15560: PPUSH
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_EXP 56
15570: PUSH
15571: LD_VAR 0 1
15575: ARRAY
15576: PUSH
15577: LD_INT 1
15579: PLUS
15580: PPUSH
15581: LD_VAR 0 6
15585: PUSH
15586: LD_VAR 0 4
15590: ARRAY
15591: PUSH
15592: LD_INT 1
15594: ARRAY
15595: PPUSH
15596: CALL 31146 0 4
15600: ST_TO_ADDR
// end ;
15601: GO 15490
15603: POP
15604: POP
// end ;
15605: LD_VAR 0 3
15609: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15610: LD_INT 0
15612: PPUSH
15613: PPUSH
15614: PPUSH
15615: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15616: LD_ADDR_VAR 0 5
15620: PUSH
15621: LD_VAR 0 1
15625: PPUSH
15626: LD_INT 2
15628: PUSH
15629: LD_INT 25
15631: PUSH
15632: LD_INT 1
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: PUSH
15639: LD_INT 25
15641: PUSH
15642: LD_INT 3
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: PUSH
15649: LD_INT 25
15651: PUSH
15652: LD_INT 4
15654: PUSH
15655: EMPTY
15656: LIST
15657: LIST
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: PPUSH
15665: CALL 11667 0 2
15669: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15670: LD_ADDR_VAR 0 5
15674: PUSH
15675: LD_VAR 0 5
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL 13816 0 2
15687: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15688: LD_ADDR_VAR 0 6
15692: PUSH
15693: LD_VAR 0 1
15697: PPUSH
15698: LD_VAR 0 5
15702: PPUSH
15703: LD_INT 2
15705: PPUSH
15706: CALL 13436 0 3
15710: ST_TO_ADDR
// if n > sk then
15711: LD_VAR 0 2
15715: PUSH
15716: LD_VAR 0 6
15720: GREATER
15721: IFFALSE 15733
// n := sk ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_VAR 0 6
15732: ST_TO_ADDR
// for i = 1 to n do
15733: LD_ADDR_VAR 0 4
15737: PUSH
15738: DOUBLE
15739: LD_INT 1
15741: DEC
15742: ST_TO_ADDR
15743: LD_VAR 0 2
15747: PUSH
15748: FOR_TO
15749: IFFALSE 15861
// if ( sk [ i ] [ 1 ] ) <> 0 then
15751: LD_VAR 0 6
15755: PUSH
15756: LD_VAR 0 4
15760: ARRAY
15761: PUSH
15762: LD_INT 1
15764: ARRAY
15765: PUSH
15766: LD_INT 0
15768: NONEQUAL
15769: IFFALSE 15859
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15771: LD_ADDR_EXP 53
15775: PUSH
15776: LD_EXP 53
15780: PPUSH
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_VAR 0 6
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: LD_INT 2
15803: PPUSH
15804: CALL 41976 0 4
15808: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15809: LD_ADDR_EXP 57
15813: PUSH
15814: LD_EXP 57
15818: PPUSH
15819: LD_VAR 0 1
15823: PPUSH
15824: LD_EXP 57
15828: PUSH
15829: LD_VAR 0 1
15833: ARRAY
15834: PUSH
15835: LD_INT 1
15837: PLUS
15838: PPUSH
15839: LD_VAR 0 6
15843: PUSH
15844: LD_VAR 0 4
15848: ARRAY
15849: PUSH
15850: LD_INT 1
15852: ARRAY
15853: PPUSH
15854: CALL 31146 0 4
15858: ST_TO_ADDR
// end ;
15859: GO 15748
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15868: LD_INT 0
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_VAR 0 1
15883: PPUSH
15884: LD_INT 2
15886: PUSH
15887: LD_INT 25
15889: PUSH
15890: LD_INT 1
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PUSH
15897: LD_INT 25
15899: PUSH
15900: LD_INT 2
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PUSH
15907: LD_INT 25
15909: PUSH
15910: LD_INT 4
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: LIST
15921: LIST
15922: PPUSH
15923: CALL 11667 0 2
15927: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15928: LD_ADDR_VAR 0 5
15932: PUSH
15933: LD_VAR 0 5
15937: PPUSH
15938: LD_INT 0
15940: PPUSH
15941: CALL 13816 0 2
15945: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15946: LD_ADDR_VAR 0 6
15950: PUSH
15951: LD_VAR 0 1
15955: PPUSH
15956: LD_VAR 0 5
15960: PPUSH
15961: LD_INT 3
15963: PPUSH
15964: CALL 13436 0 3
15968: ST_TO_ADDR
// if n > sk then
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 6
15978: GREATER
15979: IFFALSE 15991
// n := sk ;
15981: LD_ADDR_VAR 0 2
15985: PUSH
15986: LD_VAR 0 6
15990: ST_TO_ADDR
// for i = 1 to n do
15991: LD_ADDR_VAR 0 4
15995: PUSH
15996: DOUBLE
15997: LD_INT 1
15999: DEC
16000: ST_TO_ADDR
16001: LD_VAR 0 2
16005: PUSH
16006: FOR_TO
16007: IFFALSE 16119
// if ( sk [ i ] [ 1 ] ) <> 0 then
16009: LD_VAR 0 6
16013: PUSH
16014: LD_VAR 0 4
16018: ARRAY
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: PUSH
16024: LD_INT 0
16026: NONEQUAL
16027: IFFALSE 16117
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
16029: LD_ADDR_EXP 53
16033: PUSH
16034: LD_EXP 53
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: LD_VAR 0 6
16048: PUSH
16049: LD_VAR 0 4
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PPUSH
16059: LD_INT 3
16061: PPUSH
16062: CALL 41976 0 4
16066: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16067: LD_ADDR_EXP 55
16071: PUSH
16072: LD_EXP 55
16076: PPUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_EXP 55
16086: PUSH
16087: LD_VAR 0 1
16091: ARRAY
16092: PUSH
16093: LD_INT 1
16095: PLUS
16096: PPUSH
16097: LD_VAR 0 6
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: PUSH
16108: LD_INT 1
16110: ARRAY
16111: PPUSH
16112: CALL 31146 0 4
16116: ST_TO_ADDR
// end ;
16117: GO 16006
16119: POP
16120: POP
// end ;
16121: LD_VAR 0 3
16125: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_VAR 0 1
16141: PPUSH
16142: LD_INT 2
16144: PUSH
16145: LD_INT 25
16147: PUSH
16148: LD_INT 1
16150: PUSH
16151: EMPTY
16152: LIST
16153: LIST
16154: PUSH
16155: LD_INT 25
16157: PUSH
16158: LD_INT 2
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL 11667 0 2
16174: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16175: LD_ADDR_VAR 0 5
16179: PUSH
16180: LD_VAR 0 5
16184: PPUSH
16185: LD_INT 0
16187: PPUSH
16188: CALL 13816 0 2
16192: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16193: LD_ADDR_VAR 0 6
16197: PUSH
16198: LD_VAR 0 1
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: LD_INT 4
16210: PPUSH
16211: CALL 13436 0 3
16215: ST_TO_ADDR
// if n > sk then
16216: LD_VAR 0 2
16220: PUSH
16221: LD_VAR 0 6
16225: GREATER
16226: IFFALSE 16238
// n := sk ;
16228: LD_ADDR_VAR 0 2
16232: PUSH
16233: LD_VAR 0 6
16237: ST_TO_ADDR
// for i = 1 to n do
16238: LD_ADDR_VAR 0 4
16242: PUSH
16243: DOUBLE
16244: LD_INT 1
16246: DEC
16247: ST_TO_ADDR
16248: LD_VAR 0 2
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16366
// if ( sk [ i ] [ 1 ] ) <> 0 then
16256: LD_VAR 0 6
16260: PUSH
16261: LD_VAR 0 4
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_INT 0
16273: NONEQUAL
16274: IFFALSE 16364
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16276: LD_ADDR_EXP 53
16280: PUSH
16281: LD_EXP 53
16285: PPUSH
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 6
16295: PUSH
16296: LD_VAR 0 4
16300: ARRAY
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_INT 4
16308: PPUSH
16309: CALL 41976 0 4
16313: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16314: LD_ADDR_EXP 54
16318: PUSH
16319: LD_EXP 54
16323: PPUSH
16324: LD_VAR 0 1
16328: PPUSH
16329: LD_EXP 54
16333: PUSH
16334: LD_VAR 0 1
16338: ARRAY
16339: PUSH
16340: LD_INT 1
16342: PLUS
16343: PPUSH
16344: LD_VAR 0 6
16348: PUSH
16349: LD_VAR 0 4
16353: ARRAY
16354: PUSH
16355: LD_INT 1
16357: ARRAY
16358: PPUSH
16359: CALL 31146 0 4
16363: ST_TO_ADDR
// end ;
16364: GO 16253
16366: POP
16367: POP
// end ;
16368: LD_VAR 0 3
16372: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16373: LD_INT 0
16375: PPUSH
16376: PPUSH
16377: PPUSH
16378: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16379: LD_ADDR_VAR 0 6
16383: PUSH
16384: LD_VAR 0 1
16388: PPUSH
16389: LD_INT 2
16391: PUSH
16392: LD_INT 25
16394: PUSH
16395: LD_INT 1
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 2
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 3
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: PPUSH
16439: CALL 11667 0 2
16443: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16444: LD_ADDR_VAR 0 6
16448: PUSH
16449: LD_VAR 0 6
16453: PPUSH
16454: LD_INT 0
16456: PPUSH
16457: CALL 13816 0 2
16461: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16462: LD_ADDR_VAR 0 7
16466: PUSH
16467: LD_VAR 0 1
16471: PPUSH
16472: LD_VAR 0 6
16476: PPUSH
16477: LD_INT 1
16479: PPUSH
16480: CALL 13436 0 3
16484: ST_TO_ADDR
// if n > sk then
16485: LD_VAR 0 2
16489: PUSH
16490: LD_VAR 0 7
16494: GREATER
16495: IFFALSE 16507
// n := sk ;
16497: LD_ADDR_VAR 0 2
16501: PUSH
16502: LD_VAR 0 7
16506: ST_TO_ADDR
// for i = 1 to n do
16507: LD_ADDR_VAR 0 5
16511: PUSH
16512: DOUBLE
16513: LD_INT 1
16515: DEC
16516: ST_TO_ADDR
16517: LD_VAR 0 2
16521: PUSH
16522: FOR_TO
16523: IFFALSE 16567
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16525: LD_ADDR_EXP 53
16529: PUSH
16530: LD_EXP 53
16534: PPUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 7
16544: PUSH
16545: LD_VAR 0 5
16549: ARRAY
16550: PUSH
16551: LD_INT 1
16553: ARRAY
16554: PPUSH
16555: LD_VAR 0 3
16559: PPUSH
16560: CALL 41976 0 4
16564: ST_TO_ADDR
// end ;
16565: GO 16522
16567: POP
16568: POP
// end ;
16569: LD_VAR 0 4
16573: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16574: LD_INT 0
16576: PPUSH
16577: PPUSH
16578: PPUSH
// b := false ;
16579: LD_ADDR_VAR 0 6
16583: PUSH
16584: LD_INT 0
16586: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16587: LD_VAR 0 3
16591: PUSH
16592: LD_INT 1
16594: PUSH
16595: LD_INT 9
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: LD_INT 8
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: LIST
16609: IN
16610: IFFALSE 16698
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_INT 2
16619: PUSH
16620: LD_INT 30
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: LD_INT 30
16632: PUSH
16633: LD_INT 5
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: LIST
16644: PPUSH
16645: CALL 11667 0 2
16649: IFFALSE 16698
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16651: LD_ADDR_VAR 0 6
16655: PUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_INT 2
16663: PUSH
16664: LD_INT 30
16666: PUSH
16667: LD_INT 4
16669: PUSH
16670: EMPTY
16671: LIST
16672: LIST
16673: PUSH
16674: LD_INT 30
16676: PUSH
16677: LD_INT 5
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: LIST
16688: PPUSH
16689: CALL 11667 0 2
16693: PUSH
16694: LD_INT 1
16696: ARRAY
16697: ST_TO_ADDR
// if class = class_engineer then
16698: LD_VAR 0 3
16702: PUSH
16703: LD_INT 2
16705: EQUAL
16706: IFFALSE 16794
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16708: LD_VAR 0 1
16712: PPUSH
16713: LD_INT 2
16715: PUSH
16716: LD_INT 30
16718: PUSH
16719: LD_INT 0
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: LD_INT 30
16728: PUSH
16729: LD_INT 1
16731: PUSH
16732: EMPTY
16733: LIST
16734: LIST
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: LIST
16740: PPUSH
16741: CALL 11667 0 2
16745: IFFALSE 16794
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16747: LD_ADDR_VAR 0 6
16751: PUSH
16752: LD_VAR 0 1
16756: PPUSH
16757: LD_INT 2
16759: PUSH
16760: LD_INT 30
16762: PUSH
16763: LD_INT 0
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: PUSH
16770: LD_INT 30
16772: PUSH
16773: LD_INT 1
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: EMPTY
16781: LIST
16782: LIST
16783: LIST
16784: PPUSH
16785: CALL 11667 0 2
16789: PUSH
16790: LD_INT 1
16792: ARRAY
16793: ST_TO_ADDR
// if class = class_mechanic then
16794: LD_VAR 0 3
16798: PUSH
16799: LD_INT 3
16801: EQUAL
16802: IFFALSE 16872
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16804: LD_VAR 0 1
16808: PPUSH
16809: LD_INT 30
16811: PUSH
16812: LD_INT 3
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PPUSH
16819: CALL 11667 0 2
16823: IFFALSE 16872
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16825: LD_ADDR_VAR 0 6
16829: PUSH
16830: LD_VAR 0 1
16834: PPUSH
16835: LD_INT 2
16837: PUSH
16838: LD_INT 30
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: PUSH
16848: LD_INT 30
16850: PUSH
16851: LD_INT 3
16853: PUSH
16854: EMPTY
16855: LIST
16856: LIST
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: LIST
16862: PPUSH
16863: CALL 11667 0 2
16867: PUSH
16868: LD_INT 1
16870: ARRAY
16871: ST_TO_ADDR
// if class = class_scientistic then
16872: LD_VAR 0 3
16876: PUSH
16877: LD_INT 4
16879: EQUAL
16880: IFFALSE 16990
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16882: LD_VAR 0 1
16886: PPUSH
16887: LD_INT 2
16889: PUSH
16890: LD_INT 30
16892: PUSH
16893: LD_INT 6
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 30
16902: PUSH
16903: LD_INT 7
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 30
16912: PUSH
16913: LD_INT 8
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL 11667 0 2
16930: IFFALSE 16990
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_INT 2
16944: PUSH
16945: LD_INT 30
16947: PUSH
16948: LD_INT 6
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: PUSH
16955: LD_INT 30
16957: PUSH
16958: LD_INT 7
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 30
16967: PUSH
16968: LD_INT 8
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: PPUSH
16981: CALL 11667 0 2
16985: PUSH
16986: LD_INT 1
16988: ARRAY
16989: ST_TO_ADDR
// if GetClass ( unit ) = class then
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 257
16999: PUSH
17000: LD_VAR 0 3
17004: EQUAL
17005: IFFALSE 17039
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
17007: LD_ADDR_EXP 53
17011: PUSH
17012: LD_EXP 53
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: LD_VAR 0 2
17026: PPUSH
17027: LD_VAR 0 3
17031: PPUSH
17032: CALL 42067 0 4
17036: ST_TO_ADDR
// end else
17037: GO 17132
// if b then
17039: LD_VAR 0 6
17043: IFFALSE 17124
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
17045: LD_VAR 0 2
17049: PPUSH
17050: CALL_OW 310
17054: PUSH
17055: LD_VAR 0 2
17059: PPUSH
17060: CALL_OW 310
17064: PUSH
17065: LD_VAR 0 6
17069: NONEQUAL
17070: AND
17071: IFFALSE 17082
// ComExitBuilding ( unit ) ;
17073: LD_VAR 0 2
17077: PPUSH
17078: CALL_OW 122
// if not IsInUnit ( unit ) then
17082: LD_VAR 0 2
17086: PPUSH
17087: CALL_OW 310
17091: NOT
17092: IFFALSE 17108
// ComEnterUnit ( unit , b ) ;
17094: LD_VAR 0 2
17098: PPUSH
17099: LD_VAR 0 6
17103: PPUSH
17104: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17108: LD_VAR 0 2
17112: PPUSH
17113: LD_VAR 0 3
17117: PPUSH
17118: CALL_OW 183
// end else
17122: GO 17132
// result := false ;
17124: LD_ADDR_VAR 0 4
17128: PUSH
17129: LD_INT 0
17131: ST_TO_ADDR
// end ; end_of_file
17132: LD_VAR 0 4
17136: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17137: LD_INT 0
17139: PPUSH
17140: PPUSH
17141: PPUSH
17142: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17143: LD_ADDR_VAR 0 5
17147: PUSH
17148: LD_INT 35
17150: PUSH
17151: LD_INT 45
17153: PUSH
17154: LD_INT 46
17156: PUSH
17157: LD_INT 47
17159: PUSH
17160: LD_INT 1
17162: PUSH
17163: LD_INT 2
17165: PUSH
17166: LD_INT 48
17168: PUSH
17169: LD_INT 49
17171: PUSH
17172: LD_INT 50
17174: PUSH
17175: LD_INT 20
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: LIST
17182: LIST
17183: LIST
17184: LIST
17185: LIST
17186: LIST
17187: LIST
17188: LIST
17189: ST_TO_ADDR
// if MCF_Lab ( side ) then
17190: LD_VAR 0 1
17194: PPUSH
17195: CALL 11706 0 1
17199: IFFALSE 17438
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL 11706 0 1
17210: PUSH
17211: LD_INT 1
17213: ARRAY
17214: PPUSH
17215: CALL_OW 461
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: IFFALSE 17362
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17225: LD_VAR 0 1
17229: PPUSH
17230: CALL 11706 0 1
17234: PUSH
17235: LD_INT 1
17237: ARRAY
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL 17534 0 2
17248: IFFALSE 17275
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL 11706 0 1
17259: PUSH
17260: LD_INT 1
17262: ARRAY
17263: PPUSH
17264: LD_VAR 0 2
17268: PPUSH
17269: CALL_OW 124
17273: GO 17362
// if MCF_Lab ( side ) > 1 then
17275: LD_VAR 0 1
17279: PPUSH
17280: CALL 11706 0 1
17284: PUSH
17285: LD_INT 1
17287: GREATER
17288: IFFALSE 17362
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 11706 0 1
17299: PUSH
17300: LD_INT 2
17302: ARRAY
17303: PPUSH
17304: CALL_OW 461
17308: PUSH
17309: LD_INT 2
17311: EQUAL
17312: IFFALSE 17362
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17314: LD_VAR 0 1
17318: PPUSH
17319: CALL 11706 0 1
17323: PUSH
17324: LD_INT 2
17326: ARRAY
17327: PPUSH
17328: LD_VAR 0 2
17332: PPUSH
17333: CALL 17534 0 2
17337: IFFALSE 17362
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17339: LD_VAR 0 1
17343: PPUSH
17344: CALL 11706 0 1
17348: PUSH
17349: LD_INT 2
17351: ARRAY
17352: PPUSH
17353: LD_VAR 0 2
17357: PPUSH
17358: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17362: LD_VAR 0 2
17366: PUSH
17367: LD_INT 2
17369: PUSH
17370: LD_INT 11
17372: PUSH
17373: LD_INT 4
17375: PUSH
17376: LD_INT 3
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: IN
17385: IFFALSE 17438
// begin for lab in MCF_Lab ( side ) do
17387: LD_ADDR_VAR 0 6
17391: PUSH
17392: LD_VAR 0 1
17396: PPUSH
17397: CALL 11706 0 1
17401: PUSH
17402: FOR_IN
17403: IFFALSE 17436
// if BuildingStatus ( lab ) = bs_need_ape then
17405: LD_VAR 0 6
17409: PPUSH
17410: CALL_OW 461
17414: PUSH
17415: LD_INT 10
17417: EQUAL
17418: IFFALSE 17434
// MCL_ResTame ( side , lab ) ;
17420: LD_VAR 0 1
17424: PPUSH
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL 17659 0 2
17434: GO 17402
17436: POP
17437: POP
// end ; end ; end ;
17438: LD_VAR 0 3
17442: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17443: LD_INT 0
17445: PPUSH
17446: PPUSH
// tmp := [ ] ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: EMPTY
17453: ST_TO_ADDR
// if not lab then
17454: LD_VAR 0 1
17458: NOT
17459: IFFALSE 17471
// result := false else
17461: LD_ADDR_VAR 0 2
17465: PUSH
17466: LD_INT 0
17468: ST_TO_ADDR
17469: GO 17529
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 3
17480: PUSH
17481: LD_VAR 0 1
17485: PPUSH
17486: LD_INT 1
17488: PPUSH
17489: CALL_OW 268
17493: ADD
17494: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17495: LD_ADDR_VAR 0 3
17499: PUSH
17500: LD_VAR 0 3
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: LD_INT 2
17512: PPUSH
17513: CALL_OW 268
17517: ADD
17518: ST_TO_ADDR
// result := tmp ;
17519: LD_ADDR_VAR 0 2
17523: PUSH
17524: LD_VAR 0 3
17528: ST_TO_ADDR
// end ; end ;
17529: LD_VAR 0 2
17533: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17534: LD_INT 0
17536: PPUSH
17537: PPUSH
17538: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17539: LD_ADDR_VAR 0 5
17543: PUSH
17544: LD_INT 35
17546: PUSH
17547: LD_INT 45
17549: PUSH
17550: LD_INT 46
17552: PUSH
17553: LD_INT 47
17555: PUSH
17556: LD_INT 1
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: LD_INT 48
17564: PUSH
17565: LD_INT 49
17567: PUSH
17568: LD_INT 50
17570: PUSH
17571: LD_INT 20
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: ST_TO_ADDR
// if lab then
17586: LD_VAR 0 1
17590: IFFALSE 17646
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17592: LD_VAR 0 2
17596: PUSH
17597: LD_VAR 0 5
17601: IN
17602: PUSH
17603: LD_VAR 0 2
17607: PPUSH
17608: CALL_OW 481
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL 17443 0 1
17622: IN
17623: OR
17624: IFFALSE 17636
// result := true else
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: ST_TO_ADDR
17634: GO 17644
// result := false ;
17636: LD_ADDR_VAR 0 3
17640: PUSH
17641: LD_INT 0
17643: ST_TO_ADDR
// end else
17644: GO 17654
// result := false ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: LD_INT 0
17653: ST_TO_ADDR
// end ;
17654: LD_VAR 0 3
17658: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17659: LD_INT 0
17661: PPUSH
17662: PPUSH
17663: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17664: LD_ADDR_VAR 0 4
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: LD_INT 171
17676: PPUSH
17677: EMPTY
17678: PPUSH
17679: CALL 12370 0 3
17683: ST_TO_ADDR
// if not ape then
17684: LD_VAR 0 4
17688: NOT
17689: IFFALSE 17721
// if MCF_Ape ( side ) then
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL 12080 0 1
17700: IFFALSE 17721
// ape := MCF_Ape ( side ) [ 1 ] ;
17702: LD_ADDR_VAR 0 4
17706: PUSH
17707: LD_VAR 0 1
17711: PPUSH
17712: CALL 12080 0 1
17716: PUSH
17717: LD_INT 1
17719: ARRAY
17720: ST_TO_ADDR
// if ape then
17721: LD_VAR 0 4
17725: IFFALSE 17776
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17727: LD_VAR 0 4
17731: PUSH
17732: LD_INT 1
17734: ARRAY
17735: PPUSH
17736: CALL_OW 310
17740: PUSH
17741: LD_VAR 0 4
17745: PUSH
17746: LD_INT 1
17748: ARRAY
17749: PPUSH
17750: CALL_OW 310
17754: PUSH
17755: LD_VAR 0 2
17759: NONEQUAL
17760: AND
17761: IFFALSE 17776
// ComExitBuilding ( ape [ 1 ] ) ;
17763: LD_VAR 0 4
17767: PUSH
17768: LD_INT 1
17770: ARRAY
17771: PPUSH
17772: CALL_OW 122
// if not lab then
17776: LD_VAR 0 2
17780: NOT
17781: IFFALSE 17787
// exit else
17783: GO 17935
17785: GO 17895
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17787: LD_VAR 0 1
17791: PPUSH
17792: LD_INT 16
17794: PPUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PPUSH
17805: CALL 12370 0 3
17809: PUSH
17810: LD_INT 0
17812: EQUAL
17813: PUSH
17814: LD_VAR 0 2
17818: PPUSH
17819: CALL_OW 313
17823: PUSH
17824: LD_INT 6
17826: EQUAL
17827: AND
17828: IFFALSE 17895
// begin tmp := UnitsInside ( lab ) ;
17830: LD_ADDR_VAR 0 5
17834: PUSH
17835: LD_VAR 0 2
17839: PPUSH
17840: CALL_OW 313
17844: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17845: LD_VAR 0 5
17849: PUSH
17850: LD_VAR 0 5
17854: ARRAY
17855: PPUSH
17856: LD_INT 16
17858: PPUSH
17859: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 5
17872: ARRAY
17873: PPUSH
17874: CALL_OW 310
17878: IFFALSE 17895
// ComExitBuilding ( tmp [ tmp ] ) ;
17880: LD_VAR 0 5
17884: PUSH
17885: LD_VAR 0 5
17889: ARRAY
17890: PPUSH
17891: CALL_OW 122
// end ; if ape then
17895: LD_VAR 0 4
17899: IFFALSE 17935
// if not IsInUnit ( ape [ 1 ] ) then
17901: LD_VAR 0 4
17905: PUSH
17906: LD_INT 1
17908: ARRAY
17909: PPUSH
17910: CALL_OW 310
17914: NOT
17915: IFFALSE 17935
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17917: LD_VAR 0 4
17921: PUSH
17922: LD_INT 1
17924: ARRAY
17925: PPUSH
17926: LD_VAR 0 2
17930: PPUSH
17931: CALL_OW 120
// end ;
17935: LD_VAR 0 3
17939: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17940: LD_INT 0
17942: PPUSH
17943: PPUSH
17944: PPUSH
// result := false ;
17945: LD_ADDR_VAR 0 2
17949: PUSH
17950: LD_INT 0
17952: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17953: LD_ADDR_VAR 0 3
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: CALL 18050 0 1
17967: ST_TO_ADDR
// if techs then
17968: LD_VAR 0 3
17972: IFFALSE 18002
// if techs [ 2 ] then
17974: LD_VAR 0 3
17978: PUSH
17979: LD_INT 2
17981: ARRAY
17982: IFFALSE 17994
// result := true else
17984: LD_ADDR_VAR 0 2
17988: PUSH
17989: LD_INT 1
17991: ST_TO_ADDR
17992: GO 18002
// result := false ;
17994: LD_ADDR_VAR 0 2
17998: PUSH
17999: LD_INT 0
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 2
18006: RET
// export function MCL_Start ( side ) ; var i ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// if MCL_GetTechList ( side ) then
18011: LD_VAR 0 1
18015: PPUSH
18016: CALL 18050 0 1
18020: IFFALSE 18045
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: LD_VAR 0 1
18031: PPUSH
18032: CALL 18050 0 1
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: CALL 17137 0 2
// end ;
18045: LD_VAR 0 2
18049: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
18050: LD_INT 0
18052: PPUSH
18053: PPUSH
18054: PPUSH
// if MREG_ToRes then
18055: LD_EXP 50
18059: IFFALSE 18144
// for i = 1 to MREG_ToRes do
18061: LD_ADDR_VAR 0 3
18065: PUSH
18066: DOUBLE
18067: LD_INT 1
18069: DEC
18070: ST_TO_ADDR
18071: LD_EXP 50
18075: PUSH
18076: FOR_TO
18077: IFFALSE 18142
// if MREG_ToRes [ i ] [ 1 ] = side then
18079: LD_EXP 50
18083: PUSH
18084: LD_VAR 0 3
18088: ARRAY
18089: PUSH
18090: LD_INT 1
18092: ARRAY
18093: PUSH
18094: LD_VAR 0 1
18098: EQUAL
18099: IFFALSE 18140
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18101: LD_ADDR_VAR 0 4
18105: PUSH
18106: LD_VAR 0 4
18110: PPUSH
18111: LD_VAR 0 4
18115: PUSH
18116: LD_INT 1
18118: PLUS
18119: PPUSH
18120: LD_EXP 50
18124: PUSH
18125: LD_VAR 0 3
18129: ARRAY
18130: PUSH
18131: LD_INT 2
18133: ARRAY
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
// end ;
18140: GO 18076
18142: POP
18143: POP
// result := techs ;
18144: LD_ADDR_VAR 0 2
18148: PUSH
18149: LD_VAR 0 4
18153: ST_TO_ADDR
// end ;
18154: LD_VAR 0 2
18158: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18159: LD_INT 0
18161: PPUSH
18162: PPUSH
// for i = 1 to tech_list do
18163: LD_ADDR_VAR 0 4
18167: PUSH
18168: DOUBLE
18169: LD_INT 1
18171: DEC
18172: ST_TO_ADDR
18173: LD_VAR 0 2
18177: PUSH
18178: FOR_TO
18179: IFFALSE 18233
// if not tech_list [ i ] = 20 then
18181: LD_VAR 0 2
18185: PUSH
18186: LD_VAR 0 4
18190: ARRAY
18191: PUSH
18192: LD_INT 20
18194: EQUAL
18195: NOT
18196: IFFALSE 18231
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18198: LD_ADDR_EXP 50
18202: PUSH
18203: LD_EXP 50
18207: PPUSH
18208: LD_VAR 0 1
18212: PPUSH
18213: LD_VAR 0 2
18217: PUSH
18218: LD_VAR 0 4
18222: ARRAY
18223: PPUSH
18224: EMPTY
18225: PPUSH
18226: CALL 41976 0 4
18230: ST_TO_ADDR
18231: GO 18178
18233: POP
18234: POP
// result := true ;
18235: LD_ADDR_VAR 0 3
18239: PUSH
18240: LD_INT 1
18242: ST_TO_ADDR
// end ;
18243: LD_VAR 0 3
18247: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18248: LD_INT 0
18250: PPUSH
18251: PPUSH
// for i = MREG_ToRes downto 1 do
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: DOUBLE
18258: LD_EXP 50
18262: INC
18263: ST_TO_ADDR
18264: LD_INT 1
18266: PUSH
18267: FOR_DOWNTO
18268: IFFALSE 18314
// if MREG_ToRes [ i ] [ 1 ] = side then
18270: LD_EXP 50
18274: PUSH
18275: LD_VAR 0 3
18279: ARRAY
18280: PUSH
18281: LD_INT 1
18283: ARRAY
18284: PUSH
18285: LD_VAR 0 1
18289: EQUAL
18290: IFFALSE 18312
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18292: LD_ADDR_EXP 50
18296: PUSH
18297: LD_EXP 50
18301: PPUSH
18302: LD_VAR 0 3
18306: PPUSH
18307: CALL_OW 3
18311: ST_TO_ADDR
18312: GO 18267
18314: POP
18315: POP
// result := true ;
18316: LD_ADDR_VAR 0 2
18320: PUSH
18321: LD_INT 1
18323: ST_TO_ADDR
// end ;
18324: LD_VAR 0 2
18328: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18329: LD_INT 0
18331: PPUSH
// result := GetTechProgress ( side , tech ) ;
18332: LD_ADDR_VAR 0 3
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: LD_VAR 0 2
18346: PPUSH
18347: CALL_OW 326
18351: ST_TO_ADDR
// end ;
18352: LD_VAR 0 3
18356: RET
// export function MCL_Require ( tech ) ; begin
18357: LD_INT 0
18359: PPUSH
// result := GetTechTechsReq ( tech ) ;
18360: LD_ADDR_VAR 0 2
18364: PUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 480
18374: ST_TO_ADDR
// end ; end_of_file
18375: LD_VAR 0 2
18379: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// uc_side := 0 ;
18385: LD_ADDR_OWVAR 20
18389: PUSH
18390: LD_INT 0
18392: ST_TO_ADDR
// uc_nation := 0 ;
18393: LD_ADDR_OWVAR 21
18397: PUSH
18398: LD_INT 0
18400: ST_TO_ADDR
// for i = 1 to n do
18401: LD_ADDR_VAR 0 5
18405: PUSH
18406: DOUBLE
18407: LD_INT 1
18409: DEC
18410: ST_TO_ADDR
18411: LD_VAR 0 2
18415: PUSH
18416: FOR_TO
18417: IFFALSE 18562
// begin hc_importance := 0 ;
18419: LD_ADDR_OWVAR 32
18423: PUSH
18424: LD_INT 0
18426: ST_TO_ADDR
// hc_gallery :=  ;
18427: LD_ADDR_OWVAR 33
18431: PUSH
18432: LD_STRING 
18434: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18435: LD_ADDR_OWVAR 35
18439: PUSH
18440: LD_VAR 0 3
18444: PUSH
18445: LD_INT 20
18447: MINUS
18448: PPUSH
18449: LD_VAR 0 3
18453: PUSH
18454: LD_INT 20
18456: PLUS
18457: PPUSH
18458: CALL_OW 12
18462: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18463: LD_ADDR_OWVAR 31
18467: PUSH
18468: LD_INT 0
18470: PPUSH
18471: LD_INT 2
18473: PPUSH
18474: CALL_OW 12
18478: PUSH
18479: LD_INT 0
18481: PUSH
18482: LD_INT 0
18484: PUSH
18485: LD_INT 0
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18494: LD_ADDR_OWVAR 30
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 0
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 0
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: LIST
18515: LIST
18516: ST_TO_ADDR
// hc_name :=  ;
18517: LD_ADDR_OWVAR 26
18521: PUSH
18522: LD_STRING 
18524: ST_TO_ADDR
// hc_class := class_apeman ;
18525: LD_ADDR_OWVAR 28
18529: PUSH
18530: LD_INT 12
18532: ST_TO_ADDR
// ape := CreateHuman ;
18533: LD_ADDR_VAR 0 6
18537: PUSH
18538: CALL_OW 44
18542: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18543: LD_VAR 0 6
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: LD_INT 0
18555: PPUSH
18556: CALL_OW 49
// end ;
18560: GO 18416
18562: POP
18563: POP
// end ;
18564: LD_VAR 0 4
18568: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18569: LD_INT 0
18571: PPUSH
18572: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18573: LD_VAR 0 1
18577: PPUSH
18578: CALL 12080 0 1
18582: PUSH
18583: LD_EXP 37
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: GREATEREQUAL
18594: IFFALSE 18771
// begin if GetTag ( unit ) = 17 then
18596: LD_VAR 0 2
18600: PPUSH
18601: CALL_OW 110
18605: PUSH
18606: LD_INT 17
18608: EQUAL
18609: IFFALSE 18769
// begin SetTag ( unit , 0 ) ;
18611: LD_VAR 0 2
18615: PPUSH
18616: LD_INT 0
18618: PPUSH
18619: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18623: LD_VAR 0 1
18627: PPUSH
18628: CALL 11706 0 1
18632: PUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: CALL 18050 0 1
18642: NOT
18643: AND
18644: IFFALSE 18669
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL 11706 0 1
18660: PUSH
18661: LD_INT 1
18663: ARRAY
18664: PPUSH
18665: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL 11706 0 1
18678: NOT
18679: PUSH
18680: LD_VAR 0 1
18684: PPUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 1
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL 11667 0 2
18699: AND
18700: IFFALSE 18769
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18702: LD_VAR 0 2
18706: PPUSH
18707: LD_VAR 0 1
18711: PPUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PPUSH
18722: CALL 11667 0 2
18726: PUSH
18727: LD_INT 1
18729: ARRAY
18730: PPUSH
18731: CALL_OW 250
18735: PPUSH
18736: LD_VAR 0 1
18740: PPUSH
18741: LD_INT 30
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: PPUSH
18751: CALL 11667 0 2
18755: PUSH
18756: LD_INT 1
18758: ARRAY
18759: PPUSH
18760: CALL_OW 251
18764: PPUSH
18765: CALL_OW 111
// end ; end else
18769: GO 18955
// if GetClass ( unit ) <> 4 then
18771: LD_VAR 0 2
18775: PPUSH
18776: CALL_OW 257
18780: PUSH
18781: LD_INT 4
18783: NONEQUAL
18784: IFFALSE 18790
// exit else
18786: GO 18955
18788: GO 18955
// if GetTag ( unit ) = 0 then
18790: LD_VAR 0 2
18794: PPUSH
18795: CALL_OW 110
18799: PUSH
18800: LD_INT 0
18802: EQUAL
18803: IFFALSE 18819
// SetTag ( unit , 17 ) else
18805: LD_VAR 0 2
18809: PPUSH
18810: LD_INT 17
18812: PPUSH
18813: CALL_OW 109
18817: GO 18955
// begin if IsInUnit ( unit ) then
18819: LD_VAR 0 2
18823: PPUSH
18824: CALL_OW 310
18828: IFFALSE 18839
// ComExitBuilding ( unit ) ;
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 122
// Wait ( 1 ) ;
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18846: LD_ADDR_VAR 0 4
18850: PUSH
18851: LD_INT 22
18853: PUSH
18854: LD_INT 0
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PUSH
18861: LD_INT 25
18863: PUSH
18864: LD_INT 12
18866: PUSH
18867: EMPTY
18868: LIST
18869: LIST
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PPUSH
18875: CALL_OW 69
18879: PPUSH
18880: LD_VAR 0 2
18884: PPUSH
18885: CALL_OW 74
18889: ST_TO_ADDR
// if not ape then
18890: LD_VAR 0 4
18894: NOT
18895: IFFALSE 18901
// exit else
18897: GO 18955
18899: GO 18910
// ComHold ( ape ) ;
18901: LD_VAR 0 4
18905: PPUSH
18906: CALL_OW 140
// if not HasTask ( unit ) then
18910: LD_VAR 0 2
18914: PPUSH
18915: CALL_OW 314
18919: NOT
18920: IFFALSE 18953
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18922: LD_VAR 0 2
18926: PPUSH
18927: LD_VAR 0 4
18931: PPUSH
18932: CALL_OW 250
18936: PPUSH
18937: LD_VAR 0 4
18941: PPUSH
18942: CALL_OW 251
18946: PPUSH
18947: CALL_OW 131
18951: GO 18955
// exit ;
18953: GO 18955
// end ; end ;
18955: LD_VAR 0 3
18959: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18960: LD_INT 0
18962: PPUSH
18963: PPUSH
18964: PPUSH
18965: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18966: LD_ADDR_VAR 0 4
18970: PUSH
18971: LD_EXP 38
18975: PUSH
18976: LD_VAR 0 1
18980: ARRAY
18981: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18982: LD_ADDR_VAR 0 5
18986: PUSH
18987: LD_VAR 0 1
18991: PPUSH
18992: LD_STRING normal
18994: PPUSH
18995: CALL 12164 0 2
18999: ST_TO_ADDR
// if apes then
19000: LD_VAR 0 5
19004: IFFALSE 19232
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
19006: LD_INT 2
19008: PPUSH
19009: LD_VAR 0 1
19013: PPUSH
19014: CALL_OW 321
19018: PUSH
19019: LD_INT 2
19021: EQUAL
19022: PUSH
19023: LD_VAR 0 4
19027: PUSH
19028: LD_INT 2
19030: ARRAY
19031: PUSH
19032: LD_INT 1
19034: EQUAL
19035: AND
19036: PUSH
19037: LD_VAR 0 1
19041: PPUSH
19042: LD_STRING engineer
19044: PPUSH
19045: CALL 12164 0 2
19049: PUSH
19050: LD_INT 3
19052: LESS
19053: AND
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_INT 30
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: PPUSH
19070: CALL 11667 0 2
19074: AND
19075: IFFALSE 19129
// begin for i in apes do
19077: LD_ADDR_VAR 0 3
19081: PUSH
19082: LD_VAR 0 5
19086: PUSH
19087: FOR_IN
19088: IFFALSE 19125
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19090: LD_VAR 0 3
19094: PPUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: LD_INT 30
19102: PUSH
19103: LD_INT 1
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PPUSH
19110: CALL 11667 0 2
19114: PUSH
19115: LD_INT 1
19117: ARRAY
19118: PPUSH
19119: CALL_OW 120
// end ;
19123: GO 19087
19125: POP
19126: POP
// end else
19127: GO 19232
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19129: LD_INT 11
19131: PPUSH
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 321
19141: PUSH
19142: LD_INT 2
19144: EQUAL
19145: PUSH
19146: LD_VAR 0 4
19150: PUSH
19151: LD_INT 1
19153: ARRAY
19154: PUSH
19155: LD_INT 1
19157: EQUAL
19158: AND
19159: PUSH
19160: LD_VAR 0 1
19164: PPUSH
19165: LD_INT 30
19167: PUSH
19168: LD_INT 5
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PPUSH
19175: CALL 11667 0 2
19179: AND
19180: IFFALSE 19232
// begin for i in apes do
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_VAR 0 5
19191: PUSH
19192: FOR_IN
19193: IFFALSE 19230
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19195: LD_VAR 0 3
19199: PPUSH
19200: LD_VAR 0 1
19204: PPUSH
19205: LD_INT 30
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PPUSH
19215: CALL 11667 0 2
19219: PUSH
19220: LD_INT 1
19222: ARRAY
19223: PPUSH
19224: CALL_OW 120
// end ;
19228: GO 19192
19230: POP
19231: POP
// end ; end ; end ; end_of_file
19232: LD_VAR 0 2
19236: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19237: LD_INT 0
19239: PPUSH
19240: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19241: LD_VAR 0 1
19245: PPUSH
19246: CALL_OW 257
19250: PUSH
19251: LD_INT 4
19253: EQUAL
19254: NOT
19255: PUSH
19256: LD_VAR 0 2
19260: NOT
19261: OR
19262: IFFALSE 19268
// exit else
19264: GO 19302
19266: GO 19302
// if not GetTag ( unit ) = 4 then
19268: LD_VAR 0 1
19272: PPUSH
19273: CALL_OW 110
19277: PUSH
19278: LD_INT 4
19280: EQUAL
19281: NOT
19282: IFFALSE 19288
// exit else
19284: GO 19302
19286: GO 19302
// ComHeal ( unit , target ) ;
19288: LD_VAR 0 1
19292: PPUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: CALL_OW 128
// end ;
19302: LD_VAR 0 3
19306: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19316: LD_ADDR_VAR 0 5
19320: PUSH
19321: LD_INT 22
19323: PUSH
19324: LD_VAR 0 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 1
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: LD_INT 3
19345: PUSH
19346: LD_INT 55
19348: PUSH
19349: EMPTY
19350: LIST
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 3
19358: PUSH
19359: LD_INT 54
19361: PUSH
19362: EMPTY
19363: LIST
19364: PUSH
19365: EMPTY
19366: LIST
19367: LIST
19368: PUSH
19369: LD_INT 3
19371: PUSH
19372: LD_INT 24
19374: PUSH
19375: LD_INT 1000
19377: PUSH
19378: EMPTY
19379: LIST
19380: LIST
19381: PUSH
19382: EMPTY
19383: LIST
19384: LIST
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: PPUSH
19393: CALL_OW 69
19397: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19398: LD_ADDR_VAR 0 8
19402: PUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 30
19410: PUSH
19411: LD_INT 1
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: PPUSH
19418: CALL 11667 0 2
19422: ST_TO_ADDR
// r := [ ] ;
19423: LD_ADDR_VAR 0 6
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19430: LD_VAR 0 1
19434: PPUSH
19435: LD_INT 5
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL 12370 0 3
19444: IFFALSE 19500
// for j in MCF_Tag ( side , 5 , [ ] ) do
19446: LD_ADDR_VAR 0 4
19450: PUSH
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: EMPTY
19460: PPUSH
19461: CALL 12370 0 3
19465: PUSH
19466: FOR_IN
19467: IFFALSE 19498
// if GetLives ( j ) = 1000 then
19469: LD_VAR 0 4
19473: PPUSH
19474: CALL_OW 256
19478: PUSH
19479: LD_INT 1000
19481: EQUAL
19482: IFFALSE 19496
// SetTag ( j , 0 ) ;
19484: LD_VAR 0 4
19488: PPUSH
19489: LD_INT 0
19491: PPUSH
19492: CALL_OW 109
19496: GO 19466
19498: POP
19499: POP
// if tmp then
19500: LD_VAR 0 5
19504: IFFALSE 19833
// begin r := [ tmp [ 1 ] ] ;
19506: LD_ADDR_VAR 0 6
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: ARRAY
19519: PUSH
19520: EMPTY
19521: LIST
19522: ST_TO_ADDR
// for i = 2 to tmp do
19523: LD_ADDR_VAR 0 3
19527: PUSH
19528: DOUBLE
19529: LD_INT 2
19531: DEC
19532: ST_TO_ADDR
19533: LD_VAR 0 5
19537: PUSH
19538: FOR_TO
19539: IFFALSE 19831
// begin m := false ;
19541: LD_ADDR_VAR 0 7
19545: PUSH
19546: LD_INT 0
19548: ST_TO_ADDR
// if d then
19549: LD_VAR 0 8
19553: IFFALSE 19708
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19555: LD_VAR 0 5
19559: PUSH
19560: LD_VAR 0 3
19564: ARRAY
19565: PPUSH
19566: CALL_OW 256
19570: PUSH
19571: LD_INT 650
19573: LESS
19574: PUSH
19575: LD_VAR 0 5
19579: PUSH
19580: LD_VAR 0 3
19584: ARRAY
19585: PPUSH
19586: LD_VAR 0 8
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: CALL_OW 250
19599: PPUSH
19600: LD_VAR 0 8
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: CALL_OW 251
19613: PPUSH
19614: CALL_OW 297
19618: PUSH
19619: LD_INT 10
19621: GREATER
19622: AND
19623: IFFALSE 19708
// begin if not GetTag ( tmp [ i ] ) = 5 then
19625: LD_VAR 0 5
19629: PUSH
19630: LD_VAR 0 3
19634: ARRAY
19635: PPUSH
19636: CALL_OW 110
19640: PUSH
19641: LD_INT 5
19643: EQUAL
19644: NOT
19645: IFFALSE 19665
// SetTag ( tmp [ i ] , 5 ) ;
19647: LD_VAR 0 5
19651: PUSH
19652: LD_VAR 0 3
19656: ARRAY
19657: PPUSH
19658: LD_INT 5
19660: PPUSH
19661: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19665: LD_VAR 0 5
19669: PUSH
19670: LD_VAR 0 3
19674: ARRAY
19675: PPUSH
19676: LD_VAR 0 8
19680: PUSH
19681: LD_INT 1
19683: ARRAY
19684: PPUSH
19685: CALL_OW 250
19689: PPUSH
19690: LD_VAR 0 8
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: CALL_OW 251
19703: PPUSH
19704: CALL_OW 111
// end ; for j = 1 to r do
19708: LD_ADDR_VAR 0 4
19712: PUSH
19713: DOUBLE
19714: LD_INT 1
19716: DEC
19717: ST_TO_ADDR
19718: LD_VAR 0 6
19722: PUSH
19723: FOR_TO
19724: IFFALSE 19798
// if GetLives ( tmp [ i ] ) < r [ j ] then
19726: LD_VAR 0 5
19730: PUSH
19731: LD_VAR 0 3
19735: ARRAY
19736: PPUSH
19737: CALL_OW 256
19741: PUSH
19742: LD_VAR 0 6
19746: PUSH
19747: LD_VAR 0 4
19751: ARRAY
19752: LESS
19753: IFFALSE 19796
// begin r := Insert ( r , j , tmp [ i ] ) ;
19755: LD_ADDR_VAR 0 6
19759: PUSH
19760: LD_VAR 0 6
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: LD_VAR 0 5
19774: PUSH
19775: LD_VAR 0 3
19779: ARRAY
19780: PPUSH
19781: CALL_OW 2
19785: ST_TO_ADDR
// m := true ;
19786: LD_ADDR_VAR 0 7
19790: PUSH
19791: LD_INT 1
19793: ST_TO_ADDR
// break ;
19794: GO 19798
// end ;
19796: GO 19723
19798: POP
19799: POP
// if not m then
19800: LD_VAR 0 7
19804: NOT
19805: IFFALSE 19829
// r := r ^ tmp [ i ] ;
19807: LD_ADDR_VAR 0 6
19811: PUSH
19812: LD_VAR 0 6
19816: PUSH
19817: LD_VAR 0 5
19821: PUSH
19822: LD_VAR 0 3
19826: ARRAY
19827: ADD
19828: ST_TO_ADDR
// end ;
19829: GO 19538
19831: POP
19832: POP
// end ; result := r end ; end_of_file
19833: LD_ADDR_VAR 0 2
19837: PUSH
19838: LD_VAR 0 6
19842: ST_TO_ADDR
19843: LD_VAR 0 2
19847: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19848: LD_INT 0
19850: PPUSH
19851: PPUSH
19852: PPUSH
// pom := GetBase ( bdepot ) ;
19853: LD_ADDR_VAR 0 3
19857: PUSH
19858: LD_VAR 0 1
19862: PPUSH
19863: CALL_OW 274
19867: ST_TO_ADDR
// sor := [ ] ;
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: EMPTY
19874: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19875: LD_ADDR_VAR 0 4
19879: PUSH
19880: LD_VAR 0 4
19884: PUSH
19885: LD_VAR 0 3
19889: PPUSH
19890: LD_INT 1
19892: PPUSH
19893: CALL_OW 275
19897: ADD
19898: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19899: LD_ADDR_VAR 0 4
19903: PUSH
19904: LD_VAR 0 4
19908: PUSH
19909: LD_VAR 0 3
19913: PPUSH
19914: LD_INT 2
19916: PPUSH
19917: CALL_OW 275
19921: ADD
19922: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19923: LD_ADDR_VAR 0 4
19927: PUSH
19928: LD_VAR 0 4
19932: PUSH
19933: LD_VAR 0 3
19937: PPUSH
19938: LD_INT 3
19940: PPUSH
19941: CALL_OW 275
19945: ADD
19946: ST_TO_ADDR
// result := sor ;
19947: LD_ADDR_VAR 0 2
19951: PUSH
19952: LD_VAR 0 4
19956: ST_TO_ADDR
// end ;
19957: LD_VAR 0 2
19961: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19962: LD_INT 0
19964: PPUSH
19965: PPUSH
// while ( coord_list ) do
19966: LD_VAR 0 3
19970: IFFALSE 20144
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19972: LD_ADDR_EXP 46
19976: PUSH
19977: LD_EXP 46
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: LD_VAR 0 2
19991: PPUSH
19992: LD_VAR 0 3
19996: PUSH
19997: LD_INT 1
19999: ARRAY
20000: PUSH
20001: LD_VAR 0 3
20005: PUSH
20006: LD_INT 2
20008: ARRAY
20009: PUSH
20010: LD_VAR 0 3
20014: PUSH
20015: LD_INT 3
20017: ARRAY
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL 41976 0 4
20028: ST_TO_ADDR
// if weapon_list then
20029: LD_VAR 0 4
20033: IFFALSE 20104
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20035: LD_ADDR_EXP 43
20039: PUSH
20040: LD_EXP 43
20044: PPUSH
20045: LD_VAR 0 1
20049: PPUSH
20050: LD_VAR 0 4
20054: PUSH
20055: LD_INT 1
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 3
20063: PUSH
20064: LD_INT 1
20066: ARRAY
20067: PUSH
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 2
20075: ARRAY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PPUSH
20081: CALL 41976 0 4
20085: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20086: LD_ADDR_VAR 0 4
20090: PUSH
20091: LD_VAR 0 4
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: CALL_OW 3
20103: ST_TO_ADDR
// end ; for i = 1 to 3 do
20104: LD_ADDR_VAR 0 6
20108: PUSH
20109: DOUBLE
20110: LD_INT 1
20112: DEC
20113: ST_TO_ADDR
20114: LD_INT 3
20116: PUSH
20117: FOR_TO
20118: IFFALSE 20140
// coord_list := Delete ( coord_list , 1 ) ;
20120: LD_ADDR_VAR 0 3
20124: PUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_INT 1
20132: PPUSH
20133: CALL_OW 3
20137: ST_TO_ADDR
20138: GO 20117
20140: POP
20141: POP
// end ;
20142: GO 19966
// result := true ;
20144: LD_ADDR_VAR 0 5
20148: PUSH
20149: LD_INT 1
20151: ST_TO_ADDR
// end ;
20152: LD_VAR 0 5
20156: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20157: LD_INT 0
20159: PPUSH
20160: PPUSH
// if not weapon_list then
20161: LD_VAR 0 3
20165: NOT
20166: IFFALSE 20170
// exit ;
20168: GO 20285
// while ( coord_list ) do
20170: LD_VAR 0 2
20174: IFFALSE 20285
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20176: LD_ADDR_EXP 43
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: LD_VAR 0 1
20190: PPUSH
20191: LD_VAR 0 3
20195: PUSH
20196: LD_INT 1
20198: ARRAY
20199: PPUSH
20200: LD_VAR 0 2
20204: PUSH
20205: LD_INT 1
20207: ARRAY
20208: PUSH
20209: LD_VAR 0 2
20213: PUSH
20214: LD_INT 2
20216: ARRAY
20217: PUSH
20218: EMPTY
20219: LIST
20220: LIST
20221: PPUSH
20222: CALL 41976 0 4
20226: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20227: LD_ADDR_VAR 0 3
20231: PUSH
20232: LD_VAR 0 3
20236: PPUSH
20237: LD_INT 1
20239: PPUSH
20240: CALL_OW 3
20244: ST_TO_ADDR
// for i = 1 to 2 do
20245: LD_ADDR_VAR 0 5
20249: PUSH
20250: DOUBLE
20251: LD_INT 1
20253: DEC
20254: ST_TO_ADDR
20255: LD_INT 2
20257: PUSH
20258: FOR_TO
20259: IFFALSE 20281
// coord_list := Delete ( coord_list , 1 ) ;
20261: LD_ADDR_VAR 0 2
20265: PUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 1
20273: PPUSH
20274: CALL_OW 3
20278: ST_TO_ADDR
20279: GO 20258
20281: POP
20282: POP
// end ;
20283: GO 20170
// end ;
20285: LD_VAR 0 4
20289: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20290: LD_INT 0
20292: PPUSH
20293: PPUSH
// while ( coord_list ) do
20294: LD_VAR 0 2
20298: IFFALSE 20453
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 2
20313: PUSH
20314: LD_INT 2
20316: ARRAY
20317: PPUSH
20318: CALL_OW 428
20322: IFFALSE 20413
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: PPUSH
20333: LD_VAR 0 2
20337: PUSH
20338: LD_INT 2
20340: ARRAY
20341: PPUSH
20342: CALL_OW 428
20346: PPUSH
20347: CALL_OW 266
20351: PUSH
20352: LD_INT 31
20354: PUSH
20355: LD_INT 32
20357: PUSH
20358: LD_INT 33
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: IN
20366: IFFALSE 20413
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20368: LD_ADDR_EXP 52
20372: PUSH
20373: LD_EXP 52
20377: PPUSH
20378: LD_VAR 0 1
20382: PPUSH
20383: LD_VAR 0 2
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: LD_VAR 0 2
20396: PUSH
20397: LD_INT 2
20399: ARRAY
20400: PPUSH
20401: CALL_OW 428
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL 41976 0 4
20412: ST_TO_ADDR
// for i = 1 to 3 do
20413: LD_ADDR_VAR 0 4
20417: PUSH
20418: DOUBLE
20419: LD_INT 1
20421: DEC
20422: ST_TO_ADDR
20423: LD_INT 3
20425: PUSH
20426: FOR_TO
20427: IFFALSE 20449
// coord_list := Delete ( coord_list , 1 ) ;
20429: LD_ADDR_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: PPUSH
20439: LD_INT 1
20441: PPUSH
20442: CALL_OW 3
20446: ST_TO_ADDR
20447: GO 20426
20449: POP
20450: POP
// end ;
20451: GO 20294
// result := true ;
20453: LD_ADDR_VAR 0 3
20457: PUSH
20458: LD_INT 1
20460: ST_TO_ADDR
// end ;
20461: LD_VAR 0 3
20465: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20466: LD_INT 0
20468: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20469: LD_ADDR_EXP 46
20473: PUSH
20474: LD_EXP 46
20478: PPUSH
20479: LD_VAR 0 1
20483: PPUSH
20484: LD_INT 0
20486: PPUSH
20487: LD_VAR 0 2
20491: PPUSH
20492: CALL 41976 0 4
20496: ST_TO_ADDR
// end ;
20497: LD_VAR 0 3
20501: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20502: LD_INT 0
20504: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20505: LD_ADDR_EXP 46
20509: PUSH
20510: LD_EXP 46
20514: PPUSH
20515: LD_VAR 0 1
20519: PPUSH
20520: LD_INT 6
20522: PPUSH
20523: LD_VAR 0 2
20527: PPUSH
20528: CALL 41976 0 4
20532: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20533: LD_ADDR_EXP 49
20537: PUSH
20538: LD_EXP 49
20542: PPUSH
20543: LD_VAR 0 1
20547: PPUSH
20548: LD_VAR 0 3
20552: PUSH
20553: LD_INT 1
20555: ARRAY
20556: PPUSH
20557: LD_VAR 0 3
20561: PUSH
20562: LD_INT 2
20564: ARRAY
20565: PPUSH
20566: CALL 41976 0 4
20570: ST_TO_ADDR
// end ;
20571: LD_VAR 0 4
20575: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if ext_list > 5 then
20580: LD_VAR 0 3
20584: PUSH
20585: LD_INT 5
20587: GREATER
20588: IFFALSE 20632
// for i = 6 to ext_list do
20590: LD_ADDR_VAR 0 5
20594: PUSH
20595: DOUBLE
20596: LD_INT 6
20598: DEC
20599: ST_TO_ADDR
20600: LD_VAR 0 3
20604: PUSH
20605: FOR_TO
20606: IFFALSE 20630
// ext_list := Delete ( ext_list , ext_list ) ;
20608: LD_ADDR_VAR 0 3
20612: PUSH
20613: LD_VAR 0 3
20617: PPUSH
20618: LD_VAR 0 3
20622: PPUSH
20623: CALL_OW 3
20627: ST_TO_ADDR
20628: GO 20605
20630: POP
20631: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20632: LD_VAR 0 1
20636: PPUSH
20637: LD_VAR 0 2
20641: PUSH
20642: LD_INT 1
20644: ARRAY
20645: PPUSH
20646: LD_VAR 0 2
20650: PUSH
20651: LD_INT 2
20653: ARRAY
20654: PPUSH
20655: LD_VAR 0 2
20659: PUSH
20660: LD_INT 3
20662: ARRAY
20663: PPUSH
20664: LD_VAR 0 3
20668: PPUSH
20669: CALL 9179 0 5
// end ;
20673: LD_VAR 0 4
20677: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20678: LD_INT 0
20680: PPUSH
20681: PPUSH
20682: PPUSH
// p := 1 ;
20683: LD_ADDR_VAR 0 6
20687: PUSH
20688: LD_INT 1
20690: ST_TO_ADDR
// if type_list = [ ] then
20691: LD_VAR 0 3
20695: PUSH
20696: EMPTY
20697: EQUAL
20698: IFFALSE 20708
// type_list := b_oil_power ;
20700: LD_ADDR_VAR 0 3
20704: PUSH
20705: LD_INT 26
20707: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: DOUBLE
20714: LD_INT 1
20716: DEC
20717: ST_TO_ADDR
20718: LD_VAR 0 2
20722: PUSH
20723: LD_INT 3
20725: DIVREAL
20726: PUSH
20727: FOR_TO
20728: IFFALSE 20831
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20730: LD_ADDR_EXP 46
20734: PUSH
20735: LD_EXP 46
20739: PPUSH
20740: LD_VAR 0 1
20744: PPUSH
20745: LD_VAR 0 3
20749: PUSH
20750: LD_INT 1
20752: PPUSH
20753: LD_VAR 0 3
20757: PPUSH
20758: CALL_OW 12
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 2
20768: PUSH
20769: LD_VAR 0 6
20773: ARRAY
20774: PUSH
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 6
20784: PUSH
20785: LD_INT 1
20787: PLUS
20788: ARRAY
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_VAR 0 6
20799: PUSH
20800: LD_INT 2
20802: PLUS
20803: ARRAY
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL 41976 0 4
20814: ST_TO_ADDR
// p := p + 3 ;
20815: LD_ADDR_VAR 0 6
20819: PUSH
20820: LD_VAR 0 6
20824: PUSH
20825: LD_INT 3
20827: PLUS
20828: ST_TO_ADDR
// end ;
20829: GO 20727
20831: POP
20832: POP
// end ;
20833: LD_VAR 0 4
20837: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20838: LD_INT 0
20840: PPUSH
20841: PPUSH
20842: PPUSH
20843: PPUSH
// if not MREG_Deposit [ side ] then
20844: LD_EXP 61
20848: PUSH
20849: LD_VAR 0 1
20853: ARRAY
20854: NOT
20855: IFFALSE 20859
// exit ;
20857: GO 21036
// p := 1 ;
20859: LD_ADDR_VAR 0 4
20863: PUSH
20864: LD_INT 1
20866: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20867: LD_ADDR_VAR 0 3
20871: PUSH
20872: DOUBLE
20873: LD_INT 1
20875: DEC
20876: ST_TO_ADDR
20877: LD_EXP 61
20881: PUSH
20882: LD_VAR 0 1
20886: ARRAY
20887: PUSH
20888: LD_INT 3
20890: DIVREAL
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20895: LD_EXP 61
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PUSH
20906: LD_VAR 0 4
20910: PUSH
20911: LD_INT 2
20913: PLUS
20914: ARRAY
20915: PUSH
20916: LD_INT 2
20918: EQUAL
20919: IFFALSE 20931
// b := b_oil_mine else
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: LD_INT 29
20928: ST_TO_ADDR
20929: GO 20939
// b := b_siberite_mine ;
20931: LD_ADDR_VAR 0 5
20935: PUSH
20936: LD_INT 30
20938: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20939: LD_ADDR_EXP 46
20943: PUSH
20944: LD_EXP 46
20948: PPUSH
20949: LD_VAR 0 1
20953: PPUSH
20954: LD_VAR 0 5
20958: PPUSH
20959: LD_EXP 61
20963: PUSH
20964: LD_VAR 0 1
20968: ARRAY
20969: PUSH
20970: LD_VAR 0 4
20974: ARRAY
20975: PUSH
20976: LD_EXP 61
20980: PUSH
20981: LD_VAR 0 1
20985: ARRAY
20986: PUSH
20987: LD_VAR 0 4
20991: PUSH
20992: LD_INT 1
20994: PLUS
20995: ARRAY
20996: PUSH
20997: LD_INT 0
20999: PPUSH
21000: LD_INT 5
21002: PPUSH
21003: CALL_OW 12
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: PPUSH
21013: CALL 41976 0 4
21017: ST_TO_ADDR
// p := p + 3 ;
21018: LD_ADDR_VAR 0 4
21022: PUSH
21023: LD_VAR 0 4
21027: PUSH
21028: LD_INT 3
21030: PLUS
21031: ST_TO_ADDR
// end ;
21032: GO 20892
21034: POP
21035: POP
// end ;
21036: LD_VAR 0 2
21040: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
21041: LD_INT 0
21043: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
21044: LD_ADDR_EXP 46
21048: PUSH
21049: LD_EXP 46
21053: PPUSH
21054: LD_VAR 0 1
21058: PPUSH
21059: LD_INT 4
21061: PPUSH
21062: LD_VAR 0 2
21066: PPUSH
21067: CALL 41976 0 4
21071: ST_TO_ADDR
// end ;
21072: LD_VAR 0 3
21076: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
21077: LD_INT 0
21079: PPUSH
// case nation of 1 , us :
21080: LD_VAR 0 2
21084: PUSH
21085: LD_INT 1
21087: DOUBLE
21088: EQUAL
21089: IFTRUE 21099
21091: LD_STRING us
21093: DOUBLE
21094: EQUAL
21095: IFTRUE 21099
21097: GO 21130
21099: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21100: LD_ADDR_EXP 46
21104: PUSH
21105: LD_EXP 46
21109: PPUSH
21110: LD_VAR 0 1
21114: PPUSH
21115: LD_INT 36
21117: PPUSH
21118: LD_VAR 0 3
21122: PPUSH
21123: CALL 41976 0 4
21127: ST_TO_ADDR
21128: GO 21181
21130: LD_INT 2
21132: DOUBLE
21133: EQUAL
21134: IFTRUE 21144
21136: LD_STRING ar
21138: DOUBLE
21139: EQUAL
21140: IFTRUE 21144
21142: GO 21180
21144: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21145: LD_ADDR_EXP 46
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: LD_INT 14
21157: PUSH
21158: LD_INT 2
21160: PUSH
21161: LD_INT 1
21163: PUSH
21164: LD_INT 31
21166: PUSH
21167: EMPTY
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL 21186 0 2
21177: ST_TO_ADDR
21178: GO 21181
21180: POP
// end ;
21181: LD_VAR 0 4
21185: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21186: LD_INT 0
21188: PPUSH
21189: PPUSH
// for i = 1 to list do
21190: LD_ADDR_VAR 0 4
21194: PUSH
21195: DOUBLE
21196: LD_INT 1
21198: DEC
21199: ST_TO_ADDR
21200: LD_VAR 0 2
21204: PUSH
21205: FOR_TO
21206: IFFALSE 21256
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21208: LD_ADDR_EXP 51
21212: PUSH
21213: LD_EXP 51
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: LD_EXP 51
21227: PUSH
21228: LD_VAR 0 1
21232: ARRAY
21233: PUSH
21234: LD_INT 1
21236: PLUS
21237: PPUSH
21238: LD_VAR 0 2
21242: PUSH
21243: LD_VAR 0 4
21247: ARRAY
21248: PPUSH
21249: CALL 31146 0 4
21253: ST_TO_ADDR
21254: GO 21205
21256: POP
21257: POP
// end ;
21258: LD_VAR 0 3
21262: RET
// export function MCS_GetVehicleList ( side ) ; begin
21263: LD_INT 0
21265: PPUSH
// result := MREG_ToConstruct [ side ] ;
21266: LD_ADDR_VAR 0 2
21270: PUSH
21271: LD_EXP 51
21275: PUSH
21276: LD_VAR 0 1
21280: ARRAY
21281: ST_TO_ADDR
// end ;
21282: LD_VAR 0 2
21286: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21287: LD_INT 0
21289: PPUSH
21290: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21291: LD_ADDR_EXP 58
21295: PUSH
21296: LD_EXP 58
21300: PPUSH
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_VAR 0 2
21310: PPUSH
21311: CALL_OW 1
21315: ST_TO_ADDR
// end ;
21316: LD_VAR 0 3
21320: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21321: LD_INT 0
21323: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21324: LD_ADDR_EXP 37
21328: PUSH
21329: LD_EXP 37
21333: PPUSH
21334: LD_VAR 0 1
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// end ;
21349: LD_VAR 0 3
21353: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21354: LD_INT 0
21356: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21357: LD_ADDR_EXP 38
21361: PUSH
21362: LD_EXP 38
21366: PPUSH
21367: LD_VAR 0 1
21371: PPUSH
21372: LD_VAR 0 2
21376: PPUSH
21377: CALL_OW 1
21381: ST_TO_ADDR
// end ;
21382: LD_VAR 0 3
21386: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21387: LD_INT 0
21389: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21390: LD_ADDR_EXP 60
21394: PUSH
21395: LD_EXP 60
21399: PPUSH
21400: LD_VAR 0 1
21404: PPUSH
21405: LD_INT 1
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: CALL 31146 0 4
21417: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21418: LD_ADDR_EXP 60
21422: PUSH
21423: LD_EXP 60
21427: PPUSH
21428: LD_VAR 0 1
21432: PPUSH
21433: LD_INT 2
21435: PPUSH
21436: LD_VAR 0 3
21440: PPUSH
21441: CALL 31146 0 4
21445: ST_TO_ADDR
// end ;
21446: LD_VAR 0 4
21450: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21451: LD_INT 0
21453: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21454: LD_ADDR_EXP 72
21458: PUSH
21459: LD_EXP 72
21463: PPUSH
21464: LD_INT 1
21466: PPUSH
21467: LD_VAR 0 1
21471: PPUSH
21472: CALL_OW 1
21476: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21477: LD_ADDR_EXP 72
21481: PUSH
21482: LD_EXP 72
21486: PPUSH
21487: LD_INT 2
21489: PPUSH
21490: LD_VAR 0 2
21494: PPUSH
21495: CALL_OW 1
21499: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21500: LD_ADDR_EXP 72
21504: PUSH
21505: LD_EXP 72
21509: PPUSH
21510: LD_INT 3
21512: PPUSH
21513: LD_VAR 0 3
21517: PPUSH
21518: CALL_OW 1
21522: ST_TO_ADDR
// end ;
21523: LD_VAR 0 4
21527: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21528: LD_INT 0
21530: PPUSH
21531: PPUSH
21532: PPUSH
// if not side or not list then
21533: LD_VAR 0 1
21537: NOT
21538: PUSH
21539: LD_VAR 0 2
21543: NOT
21544: OR
21545: IFFALSE 21549
// exit ;
21547: GO 21717
// SetTech ( 20 , side , state_researched ) ;
21549: LD_INT 20
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: LD_INT 2
21559: PPUSH
21560: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21564: LD_ADDR_EXP 61
21568: PUSH
21569: LD_EXP 61
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: LD_VAR 0 2
21583: PPUSH
21584: CALL_OW 2
21588: ST_TO_ADDR
// p := 1 ;
21589: LD_ADDR_VAR 0 5
21593: PUSH
21594: LD_INT 1
21596: ST_TO_ADDR
// for i = 1 to list / 3 do
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: DOUBLE
21603: LD_INT 1
21605: DEC
21606: ST_TO_ADDR
21607: LD_VAR 0 2
21611: PUSH
21612: LD_INT 3
21614: DIVREAL
21615: PUSH
21616: FOR_TO
21617: IFFALSE 21715
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21619: LD_VAR 0 2
21623: PUSH
21624: LD_VAR 0 5
21628: ARRAY
21629: PPUSH
21630: LD_VAR 0 2
21634: PUSH
21635: LD_VAR 0 5
21639: PUSH
21640: LD_INT 1
21642: PLUS
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 2
21649: PUSH
21650: LD_VAR 0 5
21654: PUSH
21655: LD_INT 2
21657: PLUS
21658: ARRAY
21659: PPUSH
21660: CALL 22419 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21664: LD_VAR 0 2
21668: PUSH
21669: LD_VAR 0 5
21673: ARRAY
21674: PPUSH
21675: LD_VAR 0 2
21679: PUSH
21680: LD_VAR 0 5
21684: PUSH
21685: LD_INT 1
21687: PLUS
21688: ARRAY
21689: PPUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: CALL_OW 441
// p := p + 3 ;
21699: LD_ADDR_VAR 0 5
21703: PUSH
21704: LD_VAR 0 5
21708: PUSH
21709: LD_INT 3
21711: PLUS
21712: ST_TO_ADDR
// end ;
21713: GO 21616
21715: POP
21716: POP
// end ;
21717: LD_VAR 0 3
21721: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
// if nat = nation_arabian then
21726: LD_VAR 0 2
21730: PUSH
21731: LD_INT 2
21733: EQUAL
21734: IFFALSE 21740
// exit else
21736: GO 21812
21738: GO 21798
// if nat = nation_american then
21740: LD_VAR 0 2
21744: PUSH
21745: LD_INT 1
21747: EQUAL
21748: IFFALSE 21775
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21750: LD_ADDR_VAR 0 4
21754: PUSH
21755: LD_INT 4
21757: PUSH
21758: LD_INT 3
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 8
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21798
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21775: LD_ADDR_VAR 0 4
21779: PUSH
21780: LD_INT 24
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: LD_INT 48
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: LIST
21797: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21798: LD_VAR 0 1
21802: PPUSH
21803: LD_VAR 0 4
21807: PPUSH
21808: CALL 21186 0 2
// end ;
21812: LD_VAR 0 3
21816: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21817: LD_INT 0
21819: PPUSH
21820: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21821: LD_ADDR_EXP 63
21825: PUSH
21826: LD_EXP 63
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: LD_INT 1
21838: PPUSH
21839: LD_VAR 0 4
21843: PPUSH
21844: CALL 31146 0 4
21848: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21849: LD_ADDR_EXP 64
21853: PUSH
21854: LD_EXP 64
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_INT 1
21866: PPUSH
21867: LD_VAR 0 2
21871: PPUSH
21872: CALL 31146 0 4
21876: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21877: LD_ADDR_EXP 65
21881: PUSH
21882: LD_EXP 65
21886: PPUSH
21887: LD_VAR 0 1
21891: PPUSH
21892: LD_INT 1
21894: PPUSH
21895: LD_VAR 0 3
21899: PPUSH
21900: CALL 31146 0 4
21904: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21905: LD_ADDR_EXP 66
21909: PUSH
21910: LD_EXP 66
21914: PPUSH
21915: LD_VAR 0 1
21919: PPUSH
21920: LD_INT 1
21922: PPUSH
21923: LD_VAR 0 5
21927: PPUSH
21928: CALL 31146 0 4
21932: ST_TO_ADDR
// while squad do
21933: LD_VAR 0 5
21937: IFFALSE 22030
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21939: LD_VAR 0 1
21943: PPUSH
21944: LD_VAR 0 5
21948: PUSH
21949: LD_INT 1
21951: ARRAY
21952: PUSH
21953: LD_VAR 0 5
21957: PUSH
21958: LD_INT 2
21960: ARRAY
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 3
21969: ARRAY
21970: PUSH
21971: LD_VAR 0 5
21975: PUSH
21976: LD_INT 4
21978: ARRAY
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: PPUSH
21986: CALL 21186 0 2
// for i = 1 to 4 do
21990: LD_ADDR_VAR 0 7
21994: PUSH
21995: DOUBLE
21996: LD_INT 1
21998: DEC
21999: ST_TO_ADDR
22000: LD_INT 4
22002: PUSH
22003: FOR_TO
22004: IFFALSE 22026
// squad := Delete ( squad , 1 ) ;
22006: LD_ADDR_VAR 0 5
22010: PUSH
22011: LD_VAR 0 5
22015: PPUSH
22016: LD_INT 1
22018: PPUSH
22019: CALL_OW 3
22023: ST_TO_ADDR
22024: GO 22003
22026: POP
22027: POP
// end ;
22028: GO 21933
// end ;
22030: LD_VAR 0 6
22034: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
22035: LD_INT 0
22037: PPUSH
22038: PPUSH
// for i = 1 to squad do
22039: LD_ADDR_VAR 0 4
22043: PUSH
22044: DOUBLE
22045: LD_INT 1
22047: DEC
22048: ST_TO_ADDR
22049: LD_VAR 0 2
22053: PUSH
22054: FOR_TO
22055: IFFALSE 22105
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
22057: LD_ADDR_EXP 69
22061: PUSH
22062: LD_EXP 69
22066: PPUSH
22067: LD_VAR 0 1
22071: PPUSH
22072: LD_EXP 69
22076: PUSH
22077: LD_VAR 0 1
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: PLUS
22086: PPUSH
22087: LD_VAR 0 2
22091: PUSH
22092: LD_VAR 0 4
22096: ARRAY
22097: PPUSH
22098: CALL 31146 0 4
22102: ST_TO_ADDR
22103: GO 22054
22105: POP
22106: POP
// while squad do
22107: LD_VAR 0 2
22111: IFFALSE 22204
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_VAR 0 2
22122: PUSH
22123: LD_INT 1
22125: ARRAY
22126: PUSH
22127: LD_VAR 0 2
22131: PUSH
22132: LD_INT 2
22134: ARRAY
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 3
22143: ARRAY
22144: PUSH
22145: LD_VAR 0 2
22149: PUSH
22150: LD_INT 4
22152: ARRAY
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: LIST
22158: LIST
22159: PPUSH
22160: CALL 21186 0 2
// for i = 1 to 4 do
22164: LD_ADDR_VAR 0 4
22168: PUSH
22169: DOUBLE
22170: LD_INT 1
22172: DEC
22173: ST_TO_ADDR
22174: LD_INT 4
22176: PUSH
22177: FOR_TO
22178: IFFALSE 22200
// squad := Delete ( squad , 1 ) ;
22180: LD_ADDR_VAR 0 2
22184: PUSH
22185: LD_VAR 0 2
22189: PPUSH
22190: LD_INT 1
22192: PPUSH
22193: CALL_OW 3
22197: ST_TO_ADDR
22198: GO 22177
22200: POP
22201: POP
// end ;
22202: GO 22107
// end ;
22204: LD_VAR 0 3
22208: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22209: LD_INT 0
22211: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22212: LD_ADDR_EXP 62
22216: PUSH
22217: LD_EXP 62
22221: PPUSH
22222: LD_VAR 0 1
22226: PPUSH
22227: LD_INT 1
22229: PPUSH
22230: LD_VAR 0 2
22234: PPUSH
22235: CALL 31146 0 4
22239: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22240: LD_ADDR_EXP 62
22244: PUSH
22245: LD_EXP 62
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: LD_INT 2
22257: PPUSH
22258: LD_VAR 0 3
22262: PPUSH
22263: CALL 31146 0 4
22267: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22268: LD_ADDR_EXP 62
22272: PUSH
22273: LD_EXP 62
22277: PPUSH
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 3
22285: PPUSH
22286: LD_VAR 0 4
22290: PPUSH
22291: CALL 31146 0 4
22295: ST_TO_ADDR
// end ; end_of_file
22296: LD_VAR 0 5
22300: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22301: LD_INT 0
22303: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22304: LD_ADDR_EXP 42
22308: PUSH
22309: LD_EXP 42
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: LD_VAR 0 2
22326: PPUSH
22327: CALL 31146 0 4
22331: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22332: LD_VAR 0 1
22336: PPUSH
22337: EMPTY
22338: PPUSH
22339: CALL 11802 0 2
22343: PUSH
22344: LD_INT 1
22346: ARRAY
22347: PPUSH
22348: CALL_OW 248
22352: PUSH
22353: LD_INT 1
22355: EQUAL
22356: IFFALSE 22387
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22358: LD_VAR 0 1
22362: PPUSH
22363: LD_INT 4
22365: PUSH
22366: LD_INT 1
22368: PUSH
22369: LD_INT 1
22371: PUSH
22372: LD_INT 14
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: LIST
22379: LIST
22380: PPUSH
22381: CALL 21186 0 2
22385: GO 22414
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22387: LD_VAR 0 1
22391: PPUSH
22392: LD_INT 24
22394: PUSH
22395: LD_INT 1
22397: PUSH
22398: LD_INT 1
22400: PUSH
22401: LD_INT 53
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: PPUSH
22410: CALL 21186 0 2
// end ;
22414: LD_VAR 0 3
22418: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22419: LD_INT 0
22421: PPUSH
// CreateDepositXY ( x , y , t ) ;
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: LD_VAR 0 3
22436: PPUSH
22437: CALL_OW 62
// end ;
22441: LD_VAR 0 4
22445: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22446: LD_INT 0
22448: PPUSH
22449: PPUSH
// c := 1 ;
22450: LD_ADDR_VAR 0 5
22454: PUSH
22455: LD_INT 1
22457: ST_TO_ADDR
// case color of red :
22458: LD_VAR 0 3
22462: PUSH
22463: LD_STRING red
22465: DOUBLE
22466: EQUAL
22467: IFTRUE 22471
22469: GO 22482
22471: POP
// c = 1 ; dark-green :
22472: LD_ADDR_VAR 0 5
22476: PUSH
22477: LD_INT 1
22479: ST_TO_ADDR
22480: GO 22768
22482: LD_STRING dark-green
22484: DOUBLE
22485: EQUAL
22486: IFTRUE 22490
22488: GO 22501
22490: POP
// c = 2 ; purple :
22491: LD_ADDR_VAR 0 5
22495: PUSH
22496: LD_INT 2
22498: ST_TO_ADDR
22499: GO 22768
22501: LD_STRING purple
22503: DOUBLE
22504: EQUAL
22505: IFTRUE 22509
22507: GO 22520
22509: POP
// c = 3 ; aqua :
22510: LD_ADDR_VAR 0 5
22514: PUSH
22515: LD_INT 3
22517: ST_TO_ADDR
22518: GO 22768
22520: LD_STRING aqua
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22528
22526: GO 22539
22528: POP
// c = 4 ; grey :
22529: LD_ADDR_VAR 0 5
22533: PUSH
22534: LD_INT 4
22536: ST_TO_ADDR
22537: GO 22768
22539: LD_STRING grey
22541: DOUBLE
22542: EQUAL
22543: IFTRUE 22547
22545: GO 22558
22547: POP
// c = 5 ; lime :
22548: LD_ADDR_VAR 0 5
22552: PUSH
22553: LD_INT 5
22555: ST_TO_ADDR
22556: GO 22768
22558: LD_STRING lime
22560: DOUBLE
22561: EQUAL
22562: IFTRUE 22566
22564: GO 22577
22566: POP
// c = 6 ; tan :
22567: LD_ADDR_VAR 0 5
22571: PUSH
22572: LD_INT 6
22574: ST_TO_ADDR
22575: GO 22768
22577: LD_STRING tan
22579: DOUBLE
22580: EQUAL
22581: IFTRUE 22585
22583: GO 22596
22585: POP
// c = 7 ; pink :
22586: LD_ADDR_VAR 0 5
22590: PUSH
22591: LD_INT 7
22593: ST_TO_ADDR
22594: GO 22768
22596: LD_STRING pink
22598: DOUBLE
22599: EQUAL
22600: IFTRUE 22604
22602: GO 22615
22604: POP
// c = 8 ; green :
22605: LD_ADDR_VAR 0 5
22609: PUSH
22610: LD_INT 8
22612: ST_TO_ADDR
22613: GO 22768
22615: LD_STRING green
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22634
22623: POP
// c = 9 ; blue :
22624: LD_ADDR_VAR 0 5
22628: PUSH
22629: LD_INT 9
22631: ST_TO_ADDR
22632: GO 22768
22634: LD_STRING blue
22636: DOUBLE
22637: EQUAL
22638: IFTRUE 22642
22640: GO 22653
22642: POP
// c = 10 ; yellow :
22643: LD_ADDR_VAR 0 5
22647: PUSH
22648: LD_INT 10
22650: ST_TO_ADDR
22651: GO 22768
22653: LD_STRING yellow
22655: DOUBLE
22656: EQUAL
22657: IFTRUE 22661
22659: GO 22672
22661: POP
// c = 11 ; brown :
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: LD_INT 11
22669: ST_TO_ADDR
22670: GO 22768
22672: LD_STRING brown
22674: DOUBLE
22675: EQUAL
22676: IFTRUE 22680
22678: GO 22691
22680: POP
// c = 12 ; black :
22681: LD_ADDR_VAR 0 5
22685: PUSH
22686: LD_INT 12
22688: ST_TO_ADDR
22689: GO 22768
22691: LD_STRING black
22693: DOUBLE
22694: EQUAL
22695: IFTRUE 22699
22697: GO 22710
22699: POP
// c = 13 ; aqua2 :
22700: LD_ADDR_VAR 0 5
22704: PUSH
22705: LD_INT 13
22707: ST_TO_ADDR
22708: GO 22768
22710: LD_STRING aqua2
22712: DOUBLE
22713: EQUAL
22714: IFTRUE 22718
22716: GO 22729
22718: POP
// c = 14 ; orange :
22719: LD_ADDR_VAR 0 5
22723: PUSH
22724: LD_INT 14
22726: ST_TO_ADDR
22727: GO 22768
22729: LD_STRING orange
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22737
22735: GO 22748
22737: POP
// c = 15 ; white :
22738: LD_ADDR_VAR 0 5
22742: PUSH
22743: LD_INT 15
22745: ST_TO_ADDR
22746: GO 22768
22748: LD_STRING white
22750: DOUBLE
22751: EQUAL
22752: IFTRUE 22756
22754: GO 22767
22756: POP
// c = 16 ; end ;
22757: LD_ADDR_VAR 0 5
22761: PUSH
22762: LD_INT 16
22764: ST_TO_ADDR
22765: GO 22768
22767: POP
// if HexInfo ( x , y ) = 0 then
22768: LD_VAR 0 1
22772: PPUSH
22773: LD_VAR 0 2
22777: PPUSH
22778: CALL_OW 428
22782: PUSH
22783: LD_INT 0
22785: EQUAL
22786: IFFALSE 22810
// PlaceEnvironment ( x , y , 58 , c ) ;
22788: LD_VAR 0 1
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_INT 58
22800: PPUSH
22801: LD_VAR 0 5
22805: PPUSH
22806: CALL_OW 349
// end ;
22810: LD_VAR 0 4
22814: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22815: LD_INT 0
22817: PPUSH
// RemoveEnvironment ( x , y ) ;
22818: LD_VAR 0 1
22822: PPUSH
22823: LD_VAR 0 2
22827: PPUSH
22828: CALL_OW 347
// end ;
22832: LD_VAR 0 3
22836: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22837: LD_INT 0
22839: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22840: LD_ADDR_VAR 0 5
22844: PUSH
22845: LD_INT 81
22847: PUSH
22848: LD_VAR 0 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_VAR 0 2
22864: PUSH
22865: LD_VAR 0 3
22869: PUSH
22870: LD_VAR 0 4
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: PPUSH
22885: CALL_OW 69
22889: ST_TO_ADDR
// end ;
22890: LD_VAR 0 5
22894: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22895: LD_INT 0
22897: PPUSH
22898: PPUSH
22899: PPUSH
22900: PPUSH
22901: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_INT 81
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 255
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PPUSH
22924: CALL_OW 69
22928: PPUSH
22929: LD_VAR 0 1
22933: PPUSH
22934: CALL_OW 74
22938: PPUSH
22939: CALL_OW 119
// dir := GetDir ( un ) ;
22943: LD_ADDR_VAR 0 4
22947: PUSH
22948: LD_VAR 0 1
22952: PPUSH
22953: CALL_OW 254
22957: ST_TO_ADDR
// dir := dir - 3 ;
22958: LD_ADDR_VAR 0 4
22962: PUSH
22963: LD_VAR 0 4
22967: PUSH
22968: LD_INT 3
22970: MINUS
22971: ST_TO_ADDR
// if dir < 0 then
22972: LD_VAR 0 4
22976: PUSH
22977: LD_INT 0
22979: LESS
22980: IFFALSE 22996
// dir := dir + 6 ;
22982: LD_ADDR_VAR 0 4
22986: PUSH
22987: LD_VAR 0 4
22991: PUSH
22992: LD_INT 6
22994: PLUS
22995: ST_TO_ADDR
// while true do
22996: LD_INT 1
22998: IFFALSE 23495
// begin coord_dist := 3 ;
23000: LD_ADDR_VAR 0 3
23004: PUSH
23005: LD_INT 3
23007: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23008: LD_ADDR_VAR 0 5
23012: PUSH
23013: LD_VAR 0 1
23017: PPUSH
23018: CALL_OW 250
23022: PPUSH
23023: LD_VAR 0 4
23027: PPUSH
23028: LD_VAR 0 3
23032: PPUSH
23033: CALL_OW 272
23037: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: CALL_OW 251
23052: PPUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_VAR 0 3
23062: PPUSH
23063: CALL_OW 273
23067: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
23068: LD_VAR 0 1
23072: PPUSH
23073: CALL_OW 255
23077: PPUSH
23078: LD_VAR 0 1
23082: PPUSH
23083: CALL_OW 250
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 251
23097: PPUSH
23098: LD_INT 14
23100: PPUSH
23101: CALL 22837 0 4
23105: PUSH
23106: LD_VAR 0 5
23110: PPUSH
23111: LD_VAR 0 6
23115: PPUSH
23116: CALL_OW 351
23120: OR
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 6
23131: PPUSH
23132: CALL_OW 488
23136: PUSH
23137: LD_INT 0
23139: EQUAL
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PPUSH
23147: LD_VAR 0 6
23151: PPUSH
23152: CALL_OW 546
23156: PUSH
23157: LD_INT 1
23159: EQUAL
23160: OR
23161: PUSH
23162: LD_VAR 0 5
23166: PPUSH
23167: LD_VAR 0 6
23171: PPUSH
23172: CALL_OW 428
23176: PUSH
23177: LD_INT 0
23179: NONEQUAL
23180: OR
23181: IFFALSE 23409
// begin repeat begin Wait ( 0 0$0.3 ) ;
23183: LD_INT 10
23185: PPUSH
23186: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23190: LD_ADDR_VAR 0 3
23194: PUSH
23195: LD_VAR 0 3
23199: PUSH
23200: LD_INT 1
23202: PLUS
23203: ST_TO_ADDR
// dir := dir + 1 ;
23204: LD_ADDR_VAR 0 4
23208: PUSH
23209: LD_VAR 0 4
23213: PUSH
23214: LD_INT 1
23216: PLUS
23217: ST_TO_ADDR
// if dir > 5 then
23218: LD_VAR 0 4
23222: PUSH
23223: LD_INT 5
23225: GREATER
23226: IFFALSE 23236
// dir = 0 ;
23228: LD_ADDR_VAR 0 4
23232: PUSH
23233: LD_INT 0
23235: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23236: LD_ADDR_VAR 0 5
23240: PUSH
23241: LD_VAR 0 1
23245: PPUSH
23246: CALL_OW 250
23250: PPUSH
23251: LD_VAR 0 4
23255: PPUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 272
23265: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23266: LD_ADDR_VAR 0 6
23270: PUSH
23271: LD_VAR 0 1
23275: PPUSH
23276: CALL_OW 251
23280: PPUSH
23281: LD_VAR 0 4
23285: PPUSH
23286: LD_VAR 0 3
23290: PPUSH
23291: CALL_OW 273
23295: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23296: LD_VAR 0 1
23300: PPUSH
23301: CALL_OW 255
23305: PPUSH
23306: LD_VAR 0 1
23310: PPUSH
23311: CALL_OW 250
23315: PPUSH
23316: LD_VAR 0 1
23320: PPUSH
23321: CALL_OW 251
23325: PPUSH
23326: LD_INT 14
23328: PPUSH
23329: CALL 22837 0 4
23333: NOT
23334: PUSH
23335: LD_VAR 0 5
23339: PPUSH
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 351
23349: NOT
23350: AND
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 6
23361: PPUSH
23362: CALL_OW 488
23366: AND
23367: PUSH
23368: LD_VAR 0 5
23372: PPUSH
23373: LD_VAR 0 6
23377: PPUSH
23378: CALL_OW 546
23382: PUSH
23383: LD_INT 0
23385: EQUAL
23386: AND
23387: PUSH
23388: LD_VAR 0 5
23392: PPUSH
23393: LD_VAR 0 6
23397: PPUSH
23398: CALL_OW 428
23402: PUSH
23403: LD_INT 0
23405: EQUAL
23406: AND
23407: IFFALSE 23183
// end ; ComMoveXY ( un , x , y ) ;
23409: LD_VAR 0 1
23413: PPUSH
23414: LD_VAR 0 5
23418: PPUSH
23419: LD_VAR 0 6
23423: PPUSH
23424: CALL_OW 111
// Wait ( 0 0$1 ) ;
23428: LD_INT 35
23430: PPUSH
23431: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23435: LD_VAR 0 1
23439: PPUSH
23440: LD_INT 81
23442: PUSH
23443: LD_VAR 0 1
23447: PPUSH
23448: CALL_OW 255
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PPUSH
23457: CALL_OW 69
23461: PPUSH
23462: LD_VAR 0 1
23466: PPUSH
23467: CALL_OW 74
23471: PPUSH
23472: CALL_OW 296
23476: PUSH
23477: LD_INT 14
23479: GREATEREQUAL
23480: IFFALSE 23493
// begin ComStop ( un ) ;
23482: LD_VAR 0 1
23486: PPUSH
23487: CALL_OW 141
// break ;
23491: GO 23495
// end ; end ;
23493: GO 22996
// end ;
23495: LD_VAR 0 2
23499: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23500: LD_INT 0
23502: PPUSH
23503: PPUSH
23504: PPUSH
23505: PPUSH
23506: PPUSH
23507: PPUSH
23508: PPUSH
23509: PPUSH
// x := GetX ( unit ) ;
23510: LD_ADDR_VAR 0 3
23514: PUSH
23515: LD_VAR 0 1
23519: PPUSH
23520: CALL_OW 250
23524: ST_TO_ADDR
// y := GetY ( unit ) ;
23525: LD_ADDR_VAR 0 4
23529: PUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: CALL_OW 251
23539: ST_TO_ADDR
// i := 0 ;
23540: LD_ADDR_VAR 0 8
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23548: LD_VAR 0 1
23552: PPUSH
23553: LD_INT 81
23555: PUSH
23556: LD_VAR 0 1
23560: PPUSH
23561: CALL_OW 255
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PPUSH
23570: CALL_OW 69
23574: PPUSH
23575: LD_VAR 0 1
23579: PPUSH
23580: CALL_OW 74
23584: PPUSH
23585: CALL_OW 119
// dir := GetDir ( unit ) ;
23589: LD_ADDR_VAR 0 7
23593: PUSH
23594: LD_VAR 0 1
23598: PPUSH
23599: CALL_OW 254
23603: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 0
23611: PPUSH
23612: LD_INT 1
23614: PPUSH
23615: CALL_OW 12
23619: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23620: LD_INT 10
23622: PPUSH
23623: CALL_OW 67
// if mode then
23627: LD_VAR 0 9
23631: IFFALSE 23649
// dir := dir + 1 else
23633: LD_ADDR_VAR 0 7
23637: PUSH
23638: LD_VAR 0 7
23642: PUSH
23643: LD_INT 1
23645: PLUS
23646: ST_TO_ADDR
23647: GO 23663
// dir := dir - 1 ;
23649: LD_ADDR_VAR 0 7
23653: PUSH
23654: LD_VAR 0 7
23658: PUSH
23659: LD_INT 1
23661: MINUS
23662: ST_TO_ADDR
// if ( dir < 0 ) then
23663: LD_VAR 0 7
23667: PUSH
23668: LD_INT 0
23670: LESS
23671: IFFALSE 23681
// dir := 5 ;
23673: LD_ADDR_VAR 0 7
23677: PUSH
23678: LD_INT 5
23680: ST_TO_ADDR
// if ( dir > 5 ) then
23681: LD_VAR 0 7
23685: PUSH
23686: LD_INT 5
23688: GREATER
23689: IFFALSE 23699
// dir := 0 ;
23691: LD_ADDR_VAR 0 7
23695: PUSH
23696: LD_INT 0
23698: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23699: LD_ADDR_VAR 0 5
23703: PUSH
23704: LD_VAR 0 3
23708: PPUSH
23709: LD_VAR 0 7
23713: PPUSH
23714: LD_INT 4
23716: PPUSH
23717: CALL_OW 272
23721: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23722: LD_ADDR_VAR 0 6
23726: PUSH
23727: LD_VAR 0 4
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_INT 4
23739: PPUSH
23740: CALL_OW 273
23744: ST_TO_ADDR
// i := i + 1 ;
23745: LD_ADDR_VAR 0 8
23749: PUSH
23750: LD_VAR 0 8
23754: PUSH
23755: LD_INT 1
23757: PLUS
23758: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23759: LD_VAR 0 1
23763: PPUSH
23764: CALL_OW 255
23768: PPUSH
23769: LD_VAR 0 5
23773: PPUSH
23774: LD_VAR 0 6
23778: PPUSH
23779: LD_INT 14
23781: PPUSH
23782: CALL 22837 0 4
23786: PUSH
23787: LD_INT 0
23789: EQUAL
23790: PUSH
23791: LD_VAR 0 5
23795: PPUSH
23796: LD_VAR 0 6
23800: PPUSH
23801: CALL_OW 546
23805: PUSH
23806: LD_INT 0
23808: EQUAL
23809: AND
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 6
23820: PPUSH
23821: CALL_OW 428
23825: PUSH
23826: LD_INT 0
23828: EQUAL
23829: AND
23830: IFFALSE 23834
// break ;
23832: GO 23844
// end until i > 4 ;
23834: LD_VAR 0 8
23838: PUSH
23839: LD_INT 4
23841: GREATER
23842: IFFALSE 23620
// if x2 and y2 then
23844: LD_VAR 0 5
23848: PUSH
23849: LD_VAR 0 6
23853: AND
23854: IFFALSE 23877
// result := [ x2 , y2 ] else
23856: LD_ADDR_VAR 0 2
23860: PUSH
23861: LD_VAR 0 5
23865: PUSH
23866: LD_VAR 0 6
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: ST_TO_ADDR
23875: GO 23906
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23877: LD_ADDR_VAR 0 2
23881: PUSH
23882: LD_VAR 0 1
23886: PPUSH
23887: CALL_OW 250
23891: PUSH
23892: LD_VAR 0 1
23896: PPUSH
23897: CALL_OW 251
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: ST_TO_ADDR
// end ;
23906: LD_VAR 0 2
23910: RET
// export function MCT_Hex ( x , y ) ; begin
23911: LD_INT 0
23913: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23914: LD_ADDR_VAR 0 3
23918: PUSH
23919: LD_VAR 0 1
23923: PPUSH
23924: LD_VAR 0 2
23928: PPUSH
23929: CALL_OW 546
23933: PUSH
23934: LD_VAR 0 1
23938: PPUSH
23939: LD_VAR 0 2
23943: PPUSH
23944: CALL_OW 428
23948: PUSH
23949: EMPTY
23950: LIST
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: ST_TO_ADDR
// end ;
23956: LD_VAR 0 3
23960: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23961: LD_INT 0
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23976: LD_ADDR_VAR 0 10
23980: PUSH
23981: LD_EXP 60
23985: PUSH
23986: LD_VAR 0 1
23990: ARRAY
23991: PUSH
23992: LD_INT 1
23994: ARRAY
23995: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23996: LD_ADDR_VAR 0 11
24000: PUSH
24001: LD_EXP 60
24005: PUSH
24006: LD_VAR 0 1
24010: ARRAY
24011: PUSH
24012: LD_INT 2
24014: ARRAY
24015: ST_TO_ADDR
// collectors := [ ] ;
24016: LD_ADDR_VAR 0 12
24020: PUSH
24021: EMPTY
24022: ST_TO_ADDR
// is_cargo := false ;
24023: LD_ADDR_VAR 0 13
24027: PUSH
24028: LD_INT 0
24030: ST_TO_ADDR
// if isTest then
24031: LD_EXP 1
24035: IFFALSE 24041
// TimerStart ( ) ;
24037: CALL_OW 548
// if MCF_Cargo ( side ) then
24041: LD_VAR 0 1
24045: PPUSH
24046: CALL 12018 0 1
24050: IFFALSE 24077
// begin collectors := MCF_Cargo ( side ) ;
24052: LD_ADDR_VAR 0 12
24056: PUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: CALL 12018 0 1
24066: ST_TO_ADDR
// is_cargo := true ;
24067: LD_ADDR_VAR 0 13
24071: PUSH
24072: LD_INT 1
24074: ST_TO_ADDR
// end else
24075: GO 24226
// begin if MCF_ApeSpec ( side , engineer ) then
24077: LD_VAR 0 1
24081: PPUSH
24082: LD_STRING engineer
24084: PPUSH
24085: CALL 12164 0 2
24089: IFFALSE 24109
// collectors := MCF_ApeSpec ( side , engineer ) ;
24091: LD_ADDR_VAR 0 12
24095: PUSH
24096: LD_VAR 0 1
24100: PPUSH
24101: LD_STRING engineer
24103: PPUSH
24104: CALL 12164 0 2
24108: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24109: LD_VAR 0 1
24113: PPUSH
24114: LD_INT 2
24116: PPUSH
24117: EMPTY
24118: PPUSH
24119: CALL 11750 0 3
24123: IFFALSE 24226
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24125: LD_ADDR_VAR 0 7
24129: PUSH
24130: LD_VAR 0 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL 11750 0 3
24144: ST_TO_ADDR
// if z > 5 then
24145: LD_VAR 0 7
24149: PUSH
24150: LD_INT 5
24152: GREATER
24153: IFFALSE 24165
// t1 := 5 else
24155: LD_ADDR_VAR 0 8
24159: PUSH
24160: LD_INT 5
24162: ST_TO_ADDR
24163: GO 24175
// t1 := z ;
24165: LD_ADDR_VAR 0 8
24169: PUSH
24170: LD_VAR 0 7
24174: ST_TO_ADDR
// for t2 = 1 to t1 do
24175: LD_ADDR_VAR 0 9
24179: PUSH
24180: DOUBLE
24181: LD_INT 1
24183: DEC
24184: ST_TO_ADDR
24185: LD_VAR 0 8
24189: PUSH
24190: FOR_TO
24191: IFFALSE 24224
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24193: LD_ADDR_VAR 0 12
24197: PUSH
24198: LD_VAR 0 12
24202: PPUSH
24203: LD_INT 1
24205: PPUSH
24206: LD_VAR 0 7
24210: PUSH
24211: LD_VAR 0 9
24215: ARRAY
24216: PPUSH
24217: CALL_OW 2
24221: ST_TO_ADDR
24222: GO 24190
24224: POP
24225: POP
// end ; end ; if not mode then
24226: LD_VAR 0 10
24230: NOT
24231: IFFALSE 24237
// exit else
24233: GO 24496
24235: GO 24496
// begin if collectors then
24237: LD_VAR 0 12
24241: IFFALSE 24496
// for i in areas do
24243: LD_ADDR_VAR 0 3
24247: PUSH
24248: LD_VAR 0 11
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24494
// if GetListOfCratesInArea ( i ) then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 435
24265: IFFALSE 24492
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24267: LD_ADDR_VAR 0 5
24271: PUSH
24272: LD_VAR 0 3
24276: PPUSH
24277: CALL_OW 435
24281: PUSH
24282: LD_INT 1
24284: ARRAY
24285: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24286: LD_ADDR_VAR 0 6
24290: PUSH
24291: LD_VAR 0 3
24295: PPUSH
24296: CALL_OW 435
24300: PUSH
24301: LD_INT 2
24303: ARRAY
24304: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24305: LD_VAR 0 13
24309: PUSH
24310: LD_VAR 0 12
24314: PUSH
24315: LD_INT 1
24317: ARRAY
24318: PPUSH
24319: CALL_OW 110
24323: PUSH
24324: LD_INT 0
24326: EQUAL
24327: AND
24328: IFFALSE 24390
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24330: LD_VAR 0 12
24334: PUSH
24335: LD_INT 1
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_INT 1
24352: ARRAY
24353: PPUSH
24354: CALL_OW 110
24358: PUSH
24359: LD_INT 0
24361: EQUAL
24362: AND
24363: IFFALSE 24388
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24365: LD_VAR 0 12
24369: PUSH
24370: LD_INT 1
24372: ARRAY
24373: PPUSH
24374: LD_VAR 0 5
24378: PPUSH
24379: LD_VAR 0 6
24383: PPUSH
24384: CALL_OW 117
// end ; end else
24388: GO 24476
// begin for j = 1 to collectors do
24390: LD_ADDR_VAR 0 4
24394: PUSH
24395: DOUBLE
24396: LD_INT 1
24398: DEC
24399: ST_TO_ADDR
24400: LD_VAR 0 12
24404: PUSH
24405: FOR_TO
24406: IFFALSE 24474
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24408: LD_VAR 0 12
24412: PUSH
24413: LD_VAR 0 4
24417: ARRAY
24418: PPUSH
24419: CALL_OW 314
24423: NOT
24424: PUSH
24425: LD_VAR 0 12
24429: PUSH
24430: LD_VAR 0 4
24434: ARRAY
24435: PPUSH
24436: CALL_OW 110
24440: PUSH
24441: LD_INT 0
24443: EQUAL
24444: AND
24445: IFFALSE 24472
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24447: LD_VAR 0 12
24451: PUSH
24452: LD_VAR 0 4
24456: ARRAY
24457: PPUSH
24458: LD_VAR 0 5
24462: PPUSH
24463: LD_VAR 0 6
24467: PPUSH
24468: CALL 24867 0 3
// end ;
24472: GO 24405
24474: POP
24475: POP
// end ; if isTest then
24476: LD_EXP 1
24480: IFFALSE 24492
// begin debug_time := TimerEnd ( ) ;
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: CALL_OW 549
24491: ST_TO_ADDR
// end ; end ;
24492: GO 24253
24494: POP
24495: POP
// end ; end ;
24496: LD_VAR 0 2
24500: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24501: LD_INT 0
24503: PPUSH
24504: PPUSH
24505: PPUSH
24506: PPUSH
24507: PPUSH
24508: PPUSH
// if not area then
24509: LD_VAR 0 1
24513: NOT
24514: IFFALSE 24520
// exit else
24516: GO 24782
24518: GO 24782
// if tick mod interval = 0 and Prob ( percent ) then
24520: LD_OWVAR 1
24524: PUSH
24525: LD_VAR 0 4
24529: MOD
24530: PUSH
24531: LD_INT 0
24533: EQUAL
24534: PUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: CALL_OW 13
24544: AND
24545: IFFALSE 24782
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24547: LD_VAR 0 1
24551: PPUSH
24552: CALL_OW 435
24556: PUSH
24557: LD_VAR 0 5
24561: LESS
24562: PUSH
24563: LD_VAR 0 5
24567: PUSH
24568: LD_INT 0
24570: EQUAL
24571: OR
24572: IFFALSE 24782
// begin Randomize ;
24574: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24578: LD_ADDR_VAR 0 7
24582: PUSH
24583: LD_INT 1
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: CALL_OW 12
24595: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 1
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL_OW 517
24613: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24614: LD_ADDR_VAR 0 8
24618: PUSH
24619: LD_INT 1
24621: PPUSH
24622: LD_VAR 0 9
24626: PUSH
24627: LD_INT 1
24629: ARRAY
24630: PPUSH
24631: CALL_OW 12
24635: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24636: LD_VAR 0 9
24640: PUSH
24641: LD_INT 1
24643: ARRAY
24644: PUSH
24645: LD_VAR 0 8
24649: ARRAY
24650: PPUSH
24651: LD_VAR 0 9
24655: PUSH
24656: LD_INT 2
24658: ARRAY
24659: PUSH
24660: LD_VAR 0 8
24664: ARRAY
24665: PPUSH
24666: CALL_OW 428
24670: PUSH
24671: LD_INT 0
24673: GREATER
24674: PUSH
24675: LD_VAR 0 9
24679: PUSH
24680: LD_INT 1
24682: ARRAY
24683: PUSH
24684: LD_VAR 0 8
24688: ARRAY
24689: PPUSH
24690: LD_VAR 0 9
24694: PUSH
24695: LD_INT 2
24697: ARRAY
24698: PUSH
24699: LD_VAR 0 8
24703: ARRAY
24704: PPUSH
24705: CALL_OW 284
24709: PUSH
24710: LD_INT 0
24712: GREATER
24713: AND
24714: IFFALSE 24740
// c := Rand ( 1 , tmp [ 1 ] ) ;
24716: LD_ADDR_VAR 0 8
24720: PUSH
24721: LD_INT 1
24723: PPUSH
24724: LD_VAR 0 9
24728: PUSH
24729: LD_INT 1
24731: ARRAY
24732: PPUSH
24733: CALL_OW 12
24737: ST_TO_ADDR
24738: GO 24636
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24740: LD_VAR 0 7
24744: PPUSH
24745: LD_VAR 0 9
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PUSH
24754: LD_VAR 0 8
24758: ARRAY
24759: PPUSH
24760: LD_VAR 0 9
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: PUSH
24769: LD_VAR 0 8
24773: ARRAY
24774: PPUSH
24775: LD_INT 1
24777: PPUSH
24778: CALL_OW 54
// end ; end ; end ;
24782: LD_VAR 0 6
24786: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
// if not MREG_Crates then
24791: LD_EXP 34
24795: NOT
24796: IFFALSE 24800
// exit ;
24798: GO 24862
// for i = MREG_Crates downto 1 do
24800: LD_ADDR_VAR 0 2
24804: PUSH
24805: DOUBLE
24806: LD_EXP 34
24810: INC
24811: ST_TO_ADDR
24812: LD_INT 1
24814: PUSH
24815: FOR_DOWNTO
24816: IFFALSE 24860
// if MREG_Crates [ i ] [ 3 ] = 0 then
24818: LD_EXP 34
24822: PUSH
24823: LD_VAR 0 2
24827: ARRAY
24828: PUSH
24829: LD_INT 3
24831: ARRAY
24832: PUSH
24833: LD_INT 0
24835: EQUAL
24836: IFFALSE 24858
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24838: LD_ADDR_EXP 34
24842: PUSH
24843: LD_EXP 34
24847: PPUSH
24848: LD_VAR 0 2
24852: PPUSH
24853: CALL_OW 3
24857: ST_TO_ADDR
24858: GO 24815
24860: POP
24861: POP
// end ;
24862: LD_VAR 0 1
24866: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24867: LD_INT 0
24869: PPUSH
24870: PPUSH
24871: PPUSH
24872: PPUSH
// if not unit then
24873: LD_VAR 0 1
24877: NOT
24878: IFFALSE 24882
// exit ;
24880: GO 25017
// if HasTask ( unit ) or not CanCarry ( unit ) then
24882: LD_VAR 0 1
24886: PPUSH
24887: CALL_OW 314
24891: PUSH
24892: LD_VAR 0 1
24896: PPUSH
24897: CALL_OW 280
24901: NOT
24902: OR
24903: IFFALSE 24907
// exit ;
24905: GO 25017
// side := GetSide ( unit ) ;
24907: LD_ADDR_VAR 0 6
24911: PUSH
24912: LD_VAR 0 1
24916: PPUSH
24917: CALL_OW 255
24921: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24922: LD_ADDR_VAR 0 7
24926: PUSH
24927: LD_VAR 0 6
24931: PPUSH
24932: LD_INT 30
24934: PUSH
24935: LD_INT 1
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PPUSH
24942: CALL 11667 0 2
24946: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24947: LD_VAR 0 1
24951: PPUSH
24952: CALL_OW 281
24956: PUSH
24957: LD_VAR 0 7
24961: NOT
24962: OR
24963: IFFALSE 24969
// exit else
24965: GO 25017
24967: GO 25017
// if GetResourceAmountXY ( x , y ) then
24969: LD_VAR 0 2
24973: PPUSH
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 284
24983: IFFALSE 25015
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24985: LD_VAR 0 1
24989: PPUSH
24990: LD_VAR 0 2
24994: PPUSH
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 1
25007: ARRAY
25008: PPUSH
25009: CALL 32077 0 4
// end else
25013: GO 25017
// exit ;
25015: GO 25017
// end ;
25017: LD_VAR 0 4
25021: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
25022: LD_INT 0
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
// result := [ ] ;
25029: LD_ADDR_VAR 0 2
25033: PUSH
25034: EMPTY
25035: ST_TO_ADDR
// p := 1 ;
25036: LD_ADDR_VAR 0 4
25040: PUSH
25041: LD_INT 1
25043: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
25044: LD_ADDR_VAR 0 3
25048: PUSH
25049: DOUBLE
25050: LD_INT 1
25052: DEC
25053: ST_TO_ADDR
25054: LD_EXP 63
25058: PUSH
25059: LD_VAR 0 1
25063: ARRAY
25064: PUSH
25065: LD_INT 1
25067: ARRAY
25068: PUSH
25069: LD_INT 2
25071: DIVREAL
25072: PUSH
25073: FOR_TO
25074: IFFALSE 25198
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
25076: LD_ADDR_VAR 0 5
25080: PUSH
25081: LD_INT 81
25083: PUSH
25084: LD_VAR 0 1
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 92
25095: PUSH
25096: LD_EXP 63
25100: PUSH
25101: LD_VAR 0 1
25105: ARRAY
25106: PUSH
25107: LD_INT 1
25109: ARRAY
25110: PUSH
25111: LD_VAR 0 4
25115: ARRAY
25116: PUSH
25117: LD_EXP 63
25121: PUSH
25122: LD_VAR 0 1
25126: ARRAY
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PUSH
25132: LD_VAR 0 4
25136: PUSH
25137: LD_INT 1
25139: PLUS
25140: ARRAY
25141: PUSH
25142: LD_INT 12
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: LIST
25149: LIST
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PPUSH
25155: CALL_OW 69
25159: ST_TO_ADDR
// if tmp then
25160: LD_VAR 0 5
25164: IFFALSE 25182
// result := result union tmp ;
25166: LD_ADDR_VAR 0 2
25170: PUSH
25171: LD_VAR 0 2
25175: PUSH
25176: LD_VAR 0 5
25180: UNION
25181: ST_TO_ADDR
// p := p + 2 ;
25182: LD_ADDR_VAR 0 4
25186: PUSH
25187: LD_VAR 0 4
25191: PUSH
25192: LD_INT 2
25194: PLUS
25195: ST_TO_ADDR
// end ;
25196: GO 25073
25198: POP
25199: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25200: LD_EXP 64
25204: PUSH
25205: LD_VAR 0 1
25209: ARRAY
25210: PPUSH
25211: LD_INT 81
25213: PUSH
25214: LD_VAR 0 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PPUSH
25223: CALL_OW 70
25227: IFFALSE 25268
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25229: LD_ADDR_VAR 0 2
25233: PUSH
25234: LD_VAR 0 2
25238: PUSH
25239: LD_EXP 64
25243: PUSH
25244: LD_VAR 0 1
25248: ARRAY
25249: PPUSH
25250: LD_INT 81
25252: PUSH
25253: LD_VAR 0 1
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 70
25266: UNION
25267: ST_TO_ADDR
// end ; end_of_file
25268: LD_VAR 0 2
25272: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25273: LD_INT 0
25275: PPUSH
25276: PPUSH
25277: PPUSH
// pom := GetBase ( fac ) ;
25278: LD_ADDR_VAR 0 5
25282: PUSH
25283: LD_VAR 0 1
25287: PPUSH
25288: CALL_OW 274
25292: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 2
25302: PUSH
25303: LD_INT 1
25305: ARRAY
25306: PPUSH
25307: LD_VAR 0 2
25311: PUSH
25312: LD_INT 2
25314: ARRAY
25315: PPUSH
25316: LD_VAR 0 2
25320: PUSH
25321: LD_INT 3
25323: ARRAY
25324: PPUSH
25325: LD_VAR 0 2
25329: PUSH
25330: LD_INT 4
25332: ARRAY
25333: PPUSH
25334: CALL_OW 449
25338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_VAR 0 5
25348: PPUSH
25349: LD_INT 1
25351: PPUSH
25352: CALL_OW 275
25356: PUSH
25357: LD_VAR 0 4
25361: PUSH
25362: LD_INT 1
25364: ARRAY
25365: GREATEREQUAL
25366: PUSH
25367: LD_VAR 0 5
25371: PPUSH
25372: LD_INT 2
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 4
25384: PUSH
25385: LD_INT 2
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: PUSH
25391: LD_VAR 0 5
25395: PPUSH
25396: LD_INT 3
25398: PPUSH
25399: CALL_OW 275
25403: PUSH
25404: LD_VAR 0 4
25408: PUSH
25409: LD_INT 3
25411: ARRAY
25412: GREATEREQUAL
25413: AND
25414: ST_TO_ADDR
// end ;
25415: LD_VAR 0 3
25419: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25420: LD_INT 0
25422: PPUSH
25423: PPUSH
25424: PPUSH
// result := false ;
25425: LD_ADDR_VAR 0 3
25429: PUSH
25430: LD_INT 0
25432: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25433: LD_ADDR_VAR 0 4
25437: PUSH
25438: LD_EXP 51
25442: PUSH
25443: LD_VAR 0 1
25447: ARRAY
25448: ST_TO_ADDR
// if tmp then
25449: LD_VAR 0 4
25453: IFFALSE 25507
// for i = 1 to tmp do
25455: LD_ADDR_VAR 0 5
25459: PUSH
25460: DOUBLE
25461: LD_INT 1
25463: DEC
25464: ST_TO_ADDR
25465: LD_VAR 0 4
25469: PUSH
25470: FOR_TO
25471: IFFALSE 25505
// if component = tmp [ i ] then
25473: LD_VAR 0 2
25477: PUSH
25478: LD_VAR 0 4
25482: PUSH
25483: LD_VAR 0 5
25487: ARRAY
25488: EQUAL
25489: IFFALSE 25503
// begin result := true ;
25491: LD_ADDR_VAR 0 3
25495: PUSH
25496: LD_INT 1
25498: ST_TO_ADDR
// exit ;
25499: POP
25500: POP
25501: GO 25507
// end ;
25503: GO 25470
25505: POP
25506: POP
// end ;
25507: LD_VAR 0 3
25511: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25512: LD_INT 0
25514: PPUSH
25515: PPUSH
25516: PPUSH
// result := false ;
25517: LD_ADDR_VAR 0 4
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// if fac then
25525: LD_VAR 0 2
25529: IFFALSE 25752
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25531: LD_VAR 0 2
25535: PPUSH
25536: LD_VAR 0 3
25540: PPUSH
25541: CALL 25273 0 2
25545: PUSH
25546: LD_VAR 0 2
25550: PPUSH
25551: CALL_OW 461
25555: PUSH
25556: LD_INT 2
25558: EQUAL
25559: AND
25560: PUSH
25561: LD_VAR 0 2
25565: PPUSH
25566: LD_VAR 0 3
25570: PUSH
25571: LD_INT 1
25573: ARRAY
25574: PPUSH
25575: LD_VAR 0 3
25579: PUSH
25580: LD_INT 2
25582: ARRAY
25583: PPUSH
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 3
25591: ARRAY
25592: PPUSH
25593: LD_VAR 0 3
25597: PUSH
25598: LD_INT 4
25600: ARRAY
25601: PPUSH
25602: CALL_OW 448
25606: AND
25607: IFFALSE 25752
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25609: LD_VAR 0 2
25613: PPUSH
25614: LD_VAR 0 3
25618: PUSH
25619: LD_INT 1
25621: ARRAY
25622: PPUSH
25623: LD_VAR 0 3
25627: PUSH
25628: LD_INT 2
25630: ARRAY
25631: PPUSH
25632: LD_VAR 0 3
25636: PUSH
25637: LD_INT 3
25639: ARRAY
25640: PPUSH
25641: LD_VAR 0 3
25645: PUSH
25646: LD_INT 4
25648: ARRAY
25649: PPUSH
25650: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25654: LD_ADDR_VAR 0 6
25658: PUSH
25659: LD_EXP 51
25663: PUSH
25664: LD_VAR 0 1
25668: ARRAY
25669: ST_TO_ADDR
// for i = 4 downto 1 do
25670: LD_ADDR_VAR 0 5
25674: PUSH
25675: DOUBLE
25676: LD_INT 4
25678: INC
25679: ST_TO_ADDR
25680: LD_INT 1
25682: PUSH
25683: FOR_DOWNTO
25684: IFFALSE 25717
// tab := Remove ( tab , list [ i ] , true ) ;
25686: LD_ADDR_VAR 0 6
25690: PUSH
25691: LD_VAR 0 6
25695: PPUSH
25696: LD_VAR 0 3
25700: PUSH
25701: LD_VAR 0 5
25705: ARRAY
25706: PPUSH
25707: LD_INT 1
25709: PPUSH
25710: CALL 31305 0 3
25714: ST_TO_ADDR
25715: GO 25683
25717: POP
25718: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25719: LD_ADDR_EXP 51
25723: PUSH
25724: LD_EXP 51
25728: PPUSH
25729: LD_VAR 0 1
25733: PPUSH
25734: LD_VAR 0 6
25738: PPUSH
25739: CALL_OW 1
25743: ST_TO_ADDR
// result := true ;
25744: LD_ADDR_VAR 0 4
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// end ; end ; end ;
25752: LD_VAR 0 4
25756: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25757: LD_INT 0
25759: PPUSH
25760: PPUSH
// if not veh then
25761: LD_VAR 0 2
25765: NOT
25766: IFFALSE 25770
// exit ;
25768: GO 25944
// if MREG_Parking [ side ] then
25770: LD_EXP 58
25774: PUSH
25775: LD_VAR 0 1
25779: ARRAY
25780: IFFALSE 25944
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 58
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: NOT
25803: IFFALSE 25944
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25805: LD_VAR 0 2
25809: PPUSH
25810: LD_EXP 58
25814: PUSH
25815: LD_VAR 0 1
25819: ARRAY
25820: PPUSH
25821: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25825: LD_VAR 0 2
25829: PPUSH
25830: CALL_OW 263
25834: PUSH
25835: LD_INT 1
25837: EQUAL
25838: IFFALSE 25944
// begin i := GetDriver ( veh ) ;
25840: LD_ADDR_VAR 0 4
25844: PUSH
25845: LD_VAR 0 2
25849: PPUSH
25850: CALL 31789 0 1
25854: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25855: LD_INT 35
25857: PPUSH
25858: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25862: LD_VAR 0 2
25866: PPUSH
25867: LD_EXP 58
25871: PUSH
25872: LD_VAR 0 1
25876: ARRAY
25877: PPUSH
25878: CALL_OW 308
25882: PUSH
25883: LD_VAR 0 2
25887: PPUSH
25888: CALL_OW 301
25892: OR
25893: IFFALSE 25855
// ComExitVehicle ( i ) ;
25895: LD_VAR 0 4
25899: PPUSH
25900: CALL_OW 121
// Wait ( 1 ) ;
25904: LD_INT 1
25906: PPUSH
25907: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25911: LD_VAR 0 4
25915: PPUSH
25916: LD_VAR 0 1
25920: PPUSH
25921: LD_INT 30
25923: PUSH
25924: LD_INT 3
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PPUSH
25931: CALL 11667 0 2
25935: PUSH
25936: LD_INT 1
25938: ARRAY
25939: PPUSH
25940: CALL_OW 180
// end ; end ; end ;
25944: LD_VAR 0 3
25948: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25949: LD_INT 0
25951: PPUSH
25952: PPUSH
25953: PPUSH
25954: PPUSH
25955: PPUSH
25956: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25957: LD_VAR 0 1
25961: PPUSH
25962: LD_INT 30
25964: PUSH
25965: LD_INT 3
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PPUSH
25972: CALL 11667 0 2
25976: IFFALSE 26160
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25978: LD_VAR 0 1
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL 11667 0 2
25997: PUSH
25998: LD_INT 1
26000: ARRAY
26001: PPUSH
26002: CALL_OW 461
26006: PUSH
26007: LD_INT 2
26009: EQUAL
26010: IFFALSE 26160
// begin for i = 1 to MREG_TurretWeapon do
26012: LD_ADDR_VAR 0 3
26016: PUSH
26017: DOUBLE
26018: LD_INT 1
26020: DEC
26021: ST_TO_ADDR
26022: LD_EXP 43
26026: PUSH
26027: FOR_TO
26028: IFFALSE 26158
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
26030: LD_EXP 43
26034: PUSH
26035: LD_VAR 0 3
26039: ARRAY
26040: PUSH
26041: LD_INT 1
26043: ARRAY
26044: PUSH
26045: LD_VAR 0 1
26049: EQUAL
26050: IFFALSE 26156
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
26052: LD_ADDR_VAR 0 5
26056: PUSH
26057: LD_EXP 43
26061: PUSH
26062: LD_VAR 0 3
26066: ARRAY
26067: PUSH
26068: LD_INT 2
26070: ARRAY
26071: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
26072: LD_ADDR_VAR 0 6
26076: PUSH
26077: LD_EXP 43
26081: PUSH
26082: LD_VAR 0 3
26086: ARRAY
26087: PUSH
26088: LD_INT 3
26090: ARRAY
26091: PUSH
26092: LD_INT 1
26094: ARRAY
26095: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26096: LD_ADDR_VAR 0 7
26100: PUSH
26101: LD_EXP 43
26105: PUSH
26106: LD_VAR 0 3
26110: ARRAY
26111: PUSH
26112: LD_INT 3
26114: ARRAY
26115: PUSH
26116: LD_INT 2
26118: ARRAY
26119: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26120: LD_ADDR_VAR 0 4
26124: PUSH
26125: LD_VAR 0 6
26129: PPUSH
26130: LD_VAR 0 7
26134: PPUSH
26135: CALL_OW 428
26139: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26140: LD_VAR 0 4
26144: PPUSH
26145: LD_VAR 0 5
26149: PPUSH
26150: CALL_OW 148
// break ;
26154: GO 26158
// end ;
26156: GO 26027
26158: POP
26159: POP
// end ; end ;
26160: LD_VAR 0 2
26164: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26165: LD_INT 0
26167: PPUSH
26168: PPUSH
26169: PPUSH
26170: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26171: LD_ADDR_VAR 0 4
26175: PUSH
26176: LD_VAR 0 1
26180: PPUSH
26181: LD_INT 32
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PPUSH
26191: CALL 11667 0 2
26195: ST_TO_ADDR
// if not tmp then
26196: LD_VAR 0 4
26200: NOT
26201: IFFALSE 26207
// exit else
26203: GO 26289
26205: GO 26289
// begin for i = 1 to tmp do
26207: LD_ADDR_VAR 0 3
26211: PUSH
26212: DOUBLE
26213: LD_INT 1
26215: DEC
26216: ST_TO_ADDR
26217: LD_VAR 0 4
26221: PUSH
26222: FOR_TO
26223: IFFALSE 26287
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26225: LD_VAR 0 4
26229: PUSH
26230: LD_VAR 0 3
26234: ARRAY
26235: PPUSH
26236: CALL_OW 261
26240: PUSH
26241: LD_INT 20
26243: LESS
26244: PUSH
26245: LD_VAR 0 4
26249: PUSH
26250: LD_VAR 0 3
26254: ARRAY
26255: PPUSH
26256: CALL_OW 110
26260: PUSH
26261: LD_INT 0
26263: EQUAL
26264: AND
26265: IFFALSE 26285
// begin SetTag ( tmp [ i ] , 21 ) ;
26267: LD_VAR 0 4
26271: PUSH
26272: LD_VAR 0 3
26276: ARRAY
26277: PPUSH
26278: LD_INT 21
26280: PPUSH
26281: CALL_OW 109
// end ;
26285: GO 26222
26287: POP
26288: POP
// end ; end ;
26289: LD_VAR 0 2
26293: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26294: LD_INT 0
26296: PPUSH
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
// if not unit then
26301: LD_VAR 0 1
26305: NOT
26306: IFFALSE 26310
// exit ;
26308: GO 26498
// side := GetSide ( unit ) ;
26310: LD_ADDR_VAR 0 3
26314: PUSH
26315: LD_VAR 0 1
26319: PPUSH
26320: CALL_OW 255
26324: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26325: LD_ADDR_VAR 0 5
26329: PUSH
26330: LD_VAR 0 3
26334: PPUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 3
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 30
26360: PUSH
26361: LD_INT 29
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PPUSH
26374: CALL 11667 0 2
26378: ST_TO_ADDR
// if not b then
26379: LD_VAR 0 5
26383: NOT
26384: IFFALSE 26388
// exit ;
26386: GO 26498
// if GetTag ( unit ) = 21 then
26388: LD_VAR 0 1
26392: PPUSH
26393: CALL_OW 110
26397: PUSH
26398: LD_INT 21
26400: EQUAL
26401: IFFALSE 26498
// begin c := NearestUnitToUnit ( b , unit ) ;
26403: LD_ADDR_VAR 0 6
26407: PUSH
26408: LD_VAR 0 5
26412: PPUSH
26413: LD_VAR 0 1
26417: PPUSH
26418: CALL_OW 74
26422: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26423: LD_VAR 0 1
26427: PPUSH
26428: LD_VAR 0 6
26432: PPUSH
26433: CALL_OW 250
26437: PPUSH
26438: LD_VAR 0 6
26442: PPUSH
26443: CALL_OW 251
26447: PPUSH
26448: CALL_OW 297
26452: PUSH
26453: LD_INT 6
26455: GREATER
26456: IFFALSE 26474
// ComMoveUnit ( unit , c ) else
26458: LD_VAR 0 1
26462: PPUSH
26463: LD_VAR 0 6
26467: PPUSH
26468: CALL_OW 112
26472: GO 26498
// begin SetFuel ( unit , 100 ) ;
26474: LD_VAR 0 1
26478: PPUSH
26479: LD_INT 100
26481: PPUSH
26482: CALL_OW 240
// SetTag ( unit , 0 ) ;
26486: LD_VAR 0 1
26490: PPUSH
26491: LD_INT 0
26493: PPUSH
26494: CALL_OW 109
// end ; end ; end ;
26498: LD_VAR 0 2
26502: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
26508: PPUSH
26509: PPUSH
26510: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26511: LD_ADDR_VAR 0 7
26515: PUSH
26516: LD_VAR 0 1
26520: PPUSH
26521: LD_INT 33
26523: PUSH
26524: LD_INT 2
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 3
26533: PUSH
26534: LD_INT 61
26536: PUSH
26537: EMPTY
26538: LIST
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PPUSH
26548: CALL 11667 0 2
26552: ST_TO_ADDR
// if not vehs then
26553: LD_VAR 0 7
26557: NOT
26558: IFFALSE 26562
// exit ;
26560: GO 26847
// if nation = 1 then
26562: LD_VAR 0 2
26566: PUSH
26567: LD_INT 1
26569: EQUAL
26570: IFFALSE 26740
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26572: LD_VAR 0 1
26576: PPUSH
26577: LD_INT 30
26579: PUSH
26580: LD_INT 36
26582: PUSH
26583: EMPTY
26584: LIST
26585: LIST
26586: PPUSH
26587: CALL 11667 0 2
26591: NOT
26592: IFFALSE 26598
// exit else
26594: GO 26847
26596: GO 26738
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26598: LD_ADDR_VAR 0 5
26602: PUSH
26603: LD_VAR 0 1
26607: PPUSH
26608: LD_INT 30
26610: PUSH
26611: LD_INT 36
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PPUSH
26618: CALL 11667 0 2
26622: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26623: LD_ADDR_VAR 0 6
26627: PUSH
26628: LD_VAR 0 5
26632: PUSH
26633: LD_INT 1
26635: ARRAY
26636: PPUSH
26637: CALL_OW 313
26641: ST_TO_ADDR
// for i = vehs downto 1 do
26642: LD_ADDR_VAR 0 4
26646: PUSH
26647: DOUBLE
26648: LD_VAR 0 7
26652: INC
26653: ST_TO_ADDR
26654: LD_INT 1
26656: PUSH
26657: FOR_DOWNTO
26658: IFFALSE 26736
// begin if not IsControledBy ( vehs [ i ] ) then
26660: LD_VAR 0 7
26664: PUSH
26665: LD_VAR 0 4
26669: ARRAY
26670: PPUSH
26671: CALL_OW 312
26675: NOT
26676: IFFALSE 26734
// begin tmp := MCV_RemoteDriver ( oper ) ;
26678: LD_ADDR_VAR 0 8
26682: PUSH
26683: LD_VAR 0 6
26687: PPUSH
26688: CALL 26852 0 1
26692: ST_TO_ADDR
// if not tmp then
26693: LD_VAR 0 8
26697: NOT
26698: IFFALSE 26706
// exit else
26700: POP
26701: POP
26702: GO 26847
26704: GO 26734
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26706: LD_VAR 0 7
26710: PUSH
26711: LD_VAR 0 4
26715: ARRAY
26716: PPUSH
26717: LD_VAR 0 8
26721: PUSH
26722: LD_INT 1
26724: ARRAY
26725: PUSH
26726: LD_INT 1
26728: ARRAY
26729: PPUSH
26730: CALL_OW 135
// end ; end ;
26734: GO 26657
26736: POP
26737: POP
// end ; end else
26738: GO 26847
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26740: LD_VAR 0 1
26744: PPUSH
26745: LD_INT 34
26747: PUSH
26748: LD_INT 31
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PPUSH
26755: CALL 11667 0 2
26759: NOT
26760: IFFALSE 26766
// exit else
26762: GO 26847
26764: GO 26847
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: LD_INT 34
26778: PUSH
26779: LD_INT 31
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL 11667 0 2
26790: ST_TO_ADDR
// oper := [ ] ;
26791: LD_ADDR_VAR 0 6
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to ct do
26798: LD_ADDR_VAR 0 4
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 5
26812: PUSH
26813: FOR_TO
26814: IFFALSE 26845
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26816: LD_ADDR_VAR 0 6
26820: PUSH
26821: LD_VAR 0 6
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 4
26835: ARRAY
26836: PPUSH
26837: CALL 31789 0 1
26841: ADD
26842: ST_TO_ADDR
26843: GO 26813
26845: POP
26846: POP
// end ; end ; end ;
26847: LD_VAR 0 3
26851: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26852: LD_INT 0
26854: PPUSH
26855: PPUSH
26856: PPUSH
26857: PPUSH
26858: PPUSH
26859: PPUSH
// if not drivers then
26860: LD_VAR 0 1
26864: NOT
26865: IFFALSE 26871
// exit else
26867: GO 27151
26869: GO 27151
// begin linked := [ ] ;
26871: LD_ADDR_VAR 0 5
26875: PUSH
26876: EMPTY
26877: ST_TO_ADDR
// for i = 1 to drivers do
26878: LD_ADDR_VAR 0 3
26882: PUSH
26883: DOUBLE
26884: LD_INT 1
26886: DEC
26887: ST_TO_ADDR
26888: LD_VAR 0 1
26892: PUSH
26893: FOR_TO
26894: IFFALSE 27139
// begin if CanControl ( drivers [ i ] ) then
26896: LD_VAR 0 1
26900: PUSH
26901: LD_VAR 0 3
26905: ARRAY
26906: PPUSH
26907: CALL 32179 0 1
26911: IFFALSE 27137
// if i > 1 then
26913: LD_VAR 0 3
26917: PUSH
26918: LD_INT 1
26920: GREATER
26921: IFFALSE 27098
// begin m := false ;
26923: LD_ADDR_VAR 0 6
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26931: LD_ADDR_VAR 0 7
26935: PUSH
26936: LD_VAR 0 1
26940: PUSH
26941: LD_VAR 0 3
26945: ARRAY
26946: PPUSH
26947: CALL_OW 432
26951: ST_TO_ADDR
// for j = 1 to linked do
26952: LD_ADDR_VAR 0 4
26956: PUSH
26957: DOUBLE
26958: LD_INT 1
26960: DEC
26961: ST_TO_ADDR
26962: LD_VAR 0 5
26966: PUSH
26967: FOR_TO
26968: IFFALSE 27042
// begin if l < linked [ j ] [ 2 ] then
26970: LD_VAR 0 7
26974: PUSH
26975: LD_VAR 0 5
26979: PUSH
26980: LD_VAR 0 4
26984: ARRAY
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: LESS
26990: IFFALSE 27040
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26992: LD_ADDR_VAR 0 5
26996: PUSH
26997: LD_VAR 0 5
27001: PPUSH
27002: LD_INT 1
27004: PPUSH
27005: LD_VAR 0 1
27009: PUSH
27010: LD_VAR 0 3
27014: ARRAY
27015: PUSH
27016: LD_VAR 0 7
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PPUSH
27025: CALL_OW 2
27029: ST_TO_ADDR
// m := true ;
27030: LD_ADDR_VAR 0 6
27034: PUSH
27035: LD_INT 1
27037: ST_TO_ADDR
// break ;
27038: GO 27042
// end ; end ;
27040: GO 26967
27042: POP
27043: POP
// if not m then
27044: LD_VAR 0 6
27048: NOT
27049: IFFALSE 27096
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27051: LD_ADDR_VAR 0 5
27055: PUSH
27056: LD_VAR 0 5
27060: PUSH
27061: LD_VAR 0 1
27065: PUSH
27066: LD_VAR 0 3
27070: ARRAY
27071: PUSH
27072: LD_VAR 0 1
27076: PUSH
27077: LD_VAR 0 3
27081: ARRAY
27082: PPUSH
27083: CALL_OW 432
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: EMPTY
27093: LIST
27094: ADD
27095: ST_TO_ADDR
// end else
27096: GO 27137
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27098: LD_ADDR_VAR 0 5
27102: PUSH
27103: LD_VAR 0 1
27107: PUSH
27108: LD_VAR 0 3
27112: ARRAY
27113: PUSH
27114: LD_VAR 0 1
27118: PUSH
27119: LD_VAR 0 3
27123: ARRAY
27124: PPUSH
27125: CALL_OW 432
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: EMPTY
27135: LIST
27136: ST_TO_ADDR
// end ;
27137: GO 26893
27139: POP
27140: POP
// result := linked ;
27141: LD_ADDR_VAR 0 2
27145: PUSH
27146: LD_VAR 0 5
27150: ST_TO_ADDR
// end ; end ;
27151: LD_VAR 0 2
27155: RET
// export function MCV_ToRepair ( unit ) ; begin
27156: LD_INT 0
27158: PPUSH
// if not unit then
27159: LD_VAR 0 1
27163: NOT
27164: IFFALSE 27168
// exit ;
27166: GO 27199
// SetTag ( unit , 6 ) ;
27168: LD_VAR 0 1
27172: PPUSH
27173: LD_INT 6
27175: PPUSH
27176: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27180: LD_VAR 0 1
27184: PPUSH
27185: CALL_OW 255
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL 25757 0 2
// end ;
27199: LD_VAR 0 2
27203: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27204: LD_INT 0
27206: PPUSH
27207: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27208: LD_VAR 0 1
27212: PPUSH
27213: LD_INT 6
27215: PPUSH
27216: EMPTY
27217: PPUSH
27218: CALL 12370 0 3
27222: IFFALSE 27315
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27224: LD_ADDR_VAR 0 3
27228: PUSH
27229: DOUBLE
27230: LD_VAR 0 1
27234: PPUSH
27235: LD_INT 6
27237: PPUSH
27238: EMPTY
27239: PPUSH
27240: CALL 12370 0 3
27244: INC
27245: ST_TO_ADDR
27246: LD_INT 1
27248: PUSH
27249: FOR_DOWNTO
27250: IFFALSE 27313
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27252: LD_VAR 0 1
27256: PPUSH
27257: LD_INT 6
27259: PPUSH
27260: EMPTY
27261: PPUSH
27262: CALL 12370 0 3
27266: PUSH
27267: LD_VAR 0 3
27271: ARRAY
27272: PPUSH
27273: CALL_OW 256
27277: PUSH
27278: LD_INT 1000
27280: EQUAL
27281: IFFALSE 27311
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27283: LD_VAR 0 1
27287: PPUSH
27288: LD_INT 6
27290: PPUSH
27291: EMPTY
27292: PPUSH
27293: CALL 12370 0 3
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: LD_INT 0
27306: PPUSH
27307: CALL_OW 109
27311: GO 27249
27313: POP
27314: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27315: LD_VAR 0 1
27319: PPUSH
27320: LD_INT 10
27322: PPUSH
27323: EMPTY
27324: PPUSH
27325: CALL 12370 0 3
27329: IFFALSE 27446
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27331: LD_ADDR_VAR 0 3
27335: PUSH
27336: DOUBLE
27337: LD_VAR 0 1
27341: PPUSH
27342: LD_INT 10
27344: PPUSH
27345: EMPTY
27346: PPUSH
27347: CALL 12370 0 3
27351: INC
27352: ST_TO_ADDR
27353: LD_INT 1
27355: PUSH
27356: FOR_DOWNTO
27357: IFFALSE 27444
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_INT 10
27366: PPUSH
27367: EMPTY
27368: PPUSH
27369: CALL 12370 0 3
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PPUSH
27380: CALL_OW 302
27384: NOT
27385: PUSH
27386: LD_VAR 0 1
27390: PPUSH
27391: LD_INT 10
27393: PPUSH
27394: EMPTY
27395: PPUSH
27396: CALL 12370 0 3
27400: PUSH
27401: LD_VAR 0 3
27405: ARRAY
27406: PPUSH
27407: CALL_OW 301
27411: OR
27412: IFFALSE 27442
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27414: LD_VAR 0 1
27418: PPUSH
27419: LD_INT 10
27421: PPUSH
27422: EMPTY
27423: PPUSH
27424: CALL 12370 0 3
27428: PUSH
27429: LD_VAR 0 3
27433: ARRAY
27434: PPUSH
27435: LD_INT 0
27437: PPUSH
27438: CALL_OW 109
27442: GO 27356
27444: POP
27445: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27446: LD_ADDR_VAR 0 3
27450: PUSH
27451: LD_VAR 0 1
27455: PPUSH
27456: EMPTY
27457: PPUSH
27458: CALL 11968 0 2
27462: PUSH
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 7
27470: PPUSH
27471: EMPTY
27472: PPUSH
27473: CALL 12370 0 3
27477: DIFF
27478: PUSH
27479: FOR_IN
27480: IFFALSE 27524
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27482: LD_VAR 0 3
27486: PPUSH
27487: CALL_OW 256
27491: PUSH
27492: LD_INT 650
27494: LESS
27495: PUSH
27496: LD_VAR 0 3
27500: PPUSH
27501: CALL_OW 110
27505: PUSH
27506: LD_INT 6
27508: EQUAL
27509: NOT
27510: AND
27511: IFFALSE 27522
// MCV_ToRepair ( i ) ;
27513: LD_VAR 0 3
27517: PPUSH
27518: CALL 27156 0 1
27522: GO 27479
27524: POP
27525: POP
// end ; end_of_file end_of_file
27526: LD_VAR 0 2
27530: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27531: LD_STRING SAILEvent [
27533: PUSH
27534: LD_VAR 0 1
27538: STR
27539: PUSH
27540: LD_STRING ]
27542: STR
27543: PPUSH
27544: CALL 8055 0 1
// if event = 101 and dialog_north then
27548: LD_VAR 0 1
27552: PUSH
27553: LD_INT 101
27555: EQUAL
27556: PUSH
27557: LD_EXP 6
27561: AND
27562: IFFALSE 27626
// begin dialog_north := false ;
27564: LD_ADDR_EXP 6
27568: PUSH
27569: LD_INT 0
27571: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27572: LD_EXP 5
27576: PPUSH
27577: LD_STRING DS1
27579: PUSH
27580: LD_STRING DS2
27582: PUSH
27583: LD_STRING DS3
27585: PUSH
27586: LD_STRING DS6
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 1
27597: PPUSH
27598: LD_INT 4
27600: PPUSH
27601: CALL_OW 12
27605: ARRAY
27606: PPUSH
27607: CALL_OW 94
// Wait ( 4 4$00 ) ;
27611: LD_INT 8400
27613: PPUSH
27614: CALL_OW 67
// dialog_north := true ;
27618: LD_ADDR_EXP 6
27622: PUSH
27623: LD_INT 1
27625: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27626: LD_VAR 0 1
27630: PUSH
27631: LD_INT 102
27633: EQUAL
27634: PUSH
27635: LD_EXP 7
27639: AND
27640: IFFALSE 27700
// begin dialog_south := false ;
27642: LD_ADDR_EXP 7
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27650: LD_EXP 4
27654: PPUSH
27655: LD_STRING DJ1
27657: PUSH
27658: LD_STRING DJ4
27660: PUSH
27661: LD_STRING DJ6
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 1
27671: PPUSH
27672: LD_INT 3
27674: PPUSH
27675: CALL_OW 12
27679: ARRAY
27680: PPUSH
27681: CALL_OW 94
// Wait ( 4 4$00 ) ;
27685: LD_INT 8400
27687: PPUSH
27688: CALL_OW 67
// dialog_south := true ;
27692: LD_ADDR_EXP 7
27696: PUSH
27697: LD_INT 1
27699: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27700: LD_VAR 0 1
27704: PUSH
27705: LD_INT 104
27707: EQUAL
27708: PUSH
27709: LD_EXP 8
27713: AND
27714: IFFALSE 27736
// begin dialog_popov := false ;
27716: LD_ADDR_EXP 8
27720: PUSH
27721: LD_INT 0
27723: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27724: LD_EXP 24
27728: PPUSH
27729: LD_STRING DR4
27731: PPUSH
27732: CALL_OW 94
// end ; end ;
27736: PPOPN 1
27738: END
// on BuildingStarted ( b , unit ) do var side , i ;
27739: LD_INT 0
27741: PPUSH
27742: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27743: LD_EXP 39
27747: PUSH
27748: LD_VAR 0 1
27752: PPUSH
27753: CALL_OW 255
27757: ARRAY
27758: IFFALSE 27936
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27760: LD_STRING BuildingStarted [side: 
27762: PUSH
27763: LD_VAR 0 1
27767: PPUSH
27768: CALL_OW 255
27772: STR
27773: PUSH
27774: LD_STRING ; btype: 
27776: STR
27777: PUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL_OW 266
27787: STR
27788: PUSH
27789: LD_STRING ; unit: 
27791: STR
27792: PUSH
27793: LD_VAR 0 2
27797: STR
27798: PUSH
27799: LD_STRING ]
27801: STR
27802: PPUSH
27803: CALL 8055 0 1
// side := GetSide ( b ) ;
27807: LD_ADDR_VAR 0 3
27811: PUSH
27812: LD_VAR 0 1
27816: PPUSH
27817: CALL_OW 255
27821: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27822: LD_VAR 0 3
27826: PPUSH
27827: LD_INT 21
27829: PUSH
27830: LD_INT 3
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PPUSH
27837: CALL 11667 0 2
27841: PUSH
27842: LD_INT 1
27844: EQUAL
27845: IFFALSE 27936
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27847: LD_ADDR_VAR 0 4
27851: PUSH
27852: LD_VAR 0 3
27856: PPUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PPUSH
27867: CALL 11667 0 2
27871: PUSH
27872: LD_VAR 0 3
27876: PPUSH
27877: LD_INT 2
27879: PPUSH
27880: EMPTY
27881: PPUSH
27882: CALL 11750 0 3
27886: DIFF
27887: PUSH
27888: FOR_IN
27889: IFFALSE 27934
// if not HasTask ( i ) then
27891: LD_VAR 0 4
27895: PPUSH
27896: CALL_OW 314
27900: NOT
27901: IFFALSE 27932
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27903: LD_VAR 0 4
27907: PPUSH
27908: LD_VAR 0 1
27912: PPUSH
27913: CALL_OW 250
27917: PPUSH
27918: LD_VAR 0 1
27922: PPUSH
27923: CALL_OW 251
27927: PPUSH
27928: CALL_OW 111
27932: GO 27888
27934: POP
27935: POP
// end ;
27936: PPOPN 4
27938: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27939: LD_EXP 39
27943: PUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 255
27953: ARRAY
27954: IFFALSE 28323
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27956: LD_STRING BuildingComplete [side: 
27958: PUSH
27959: LD_VAR 0 1
27963: PPUSH
27964: CALL_OW 255
27968: STR
27969: PUSH
27970: LD_STRING ; btype: 
27972: STR
27973: PUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 266
27983: STR
27984: PUSH
27985: LD_STRING ]
27987: STR
27988: PPUSH
27989: CALL 8055 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27993: LD_ADDR_EXP 46
27997: PUSH
27998: LD_EXP 46
28002: PPUSH
28003: LD_VAR 0 1
28007: PPUSH
28008: CALL_OW 255
28012: PPUSH
28013: LD_VAR 0 1
28017: PPUSH
28018: CALL_OW 266
28022: PPUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 250
28032: PUSH
28033: LD_VAR 0 1
28037: PPUSH
28038: CALL_OW 251
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 254
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: LIST
28057: PPUSH
28058: CALL 42067 0 4
28062: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 266
28072: PUSH
28073: LD_INT 6
28075: EQUAL
28076: IFFALSE 28110
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
28078: LD_ADDR_EXP 40
28082: PUSH
28083: LD_EXP 40
28087: PPUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 255
28097: PPUSH
28098: LD_VAR 0 1
28102: PPUSH
28103: EMPTY
28104: PPUSH
28105: CALL 41976 0 4
28109: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28110: LD_VAR 0 1
28114: PPUSH
28115: CALL_OW 266
28119: PUSH
28120: LD_INT 0
28122: EQUAL
28123: IFFALSE 28233
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28125: LD_ADDR_EXP 48
28129: PUSH
28130: LD_EXP 48
28134: PPUSH
28135: LD_VAR 0 1
28139: PPUSH
28140: CALL_OW 255
28144: PPUSH
28145: LD_INT 0
28147: PPUSH
28148: EMPTY
28149: PPUSH
28150: CALL 41976 0 4
28154: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 274
28164: PPUSH
28165: LD_INT 1
28167: PPUSH
28168: LD_EXP 72
28172: PUSH
28173: LD_INT 1
28175: ARRAY
28176: PPUSH
28177: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28181: LD_VAR 0 1
28185: PPUSH
28186: CALL_OW 274
28190: PPUSH
28191: LD_INT 2
28193: PPUSH
28194: LD_EXP 72
28198: PUSH
28199: LD_INT 2
28201: ARRAY
28202: PPUSH
28203: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28207: LD_VAR 0 1
28211: PPUSH
28212: CALL_OW 274
28216: PPUSH
28217: LD_INT 3
28219: PPUSH
28220: LD_EXP 72
28224: PUSH
28225: LD_INT 3
28227: ARRAY
28228: PPUSH
28229: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28233: LD_VAR 0 1
28237: PPUSH
28238: CALL_OW 266
28242: PUSH
28243: LD_INT 2
28245: EQUAL
28246: IFFALSE 28278
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28248: LD_ADDR_EXP 48
28252: PUSH
28253: LD_EXP 48
28257: PPUSH
28258: LD_VAR 0 1
28262: PPUSH
28263: CALL_OW 255
28267: PPUSH
28268: LD_INT 2
28270: PPUSH
28271: EMPTY
28272: PPUSH
28273: CALL 41976 0 4
28277: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28278: LD_VAR 0 1
28282: PPUSH
28283: CALL_OW 266
28287: PUSH
28288: LD_INT 4
28290: EQUAL
28291: IFFALSE 28323
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28293: LD_ADDR_EXP 48
28297: PUSH
28298: LD_EXP 48
28302: PPUSH
28303: LD_VAR 0 1
28307: PPUSH
28308: CALL_OW 255
28312: PPUSH
28313: LD_INT 4
28315: PPUSH
28316: EMPTY
28317: PPUSH
28318: CALL 41976 0 4
28322: ST_TO_ADDR
// end ;
28323: PPOPN 1
28325: END
// on ResearchComplete ( tech , lab ) do var i ;
28326: LD_INT 0
28328: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28329: LD_EXP 39
28333: PUSH
28334: LD_VAR 0 2
28338: PPUSH
28339: CALL_OW 255
28343: ARRAY
28344: IFFALSE 28628
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28346: LD_STRING ResearchComplete [side: 
28348: PUSH
28349: LD_VAR 0 2
28353: PPUSH
28354: CALL_OW 255
28358: PPUSH
28359: CALL_OW 255
28363: STR
28364: PUSH
28365: LD_STRING ; tech:
28367: STR
28368: PUSH
28369: LD_VAR 0 1
28373: STR
28374: PUSH
28375: LD_STRING ]
28377: STR
28378: PPUSH
28379: CALL 8055 0 1
// for i = 1 to MREG_ToRes do
28383: LD_ADDR_VAR 0 3
28387: PUSH
28388: DOUBLE
28389: LD_INT 1
28391: DEC
28392: ST_TO_ADDR
28393: LD_EXP 50
28397: PUSH
28398: FOR_TO
28399: IFFALSE 28486
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28401: LD_EXP 50
28405: PUSH
28406: LD_VAR 0 3
28410: ARRAY
28411: PUSH
28412: LD_INT 1
28414: ARRAY
28415: PUSH
28416: LD_VAR 0 2
28420: PPUSH
28421: CALL_OW 255
28425: EQUAL
28426: PUSH
28427: LD_EXP 50
28431: PUSH
28432: LD_VAR 0 3
28436: ARRAY
28437: PUSH
28438: LD_INT 2
28440: ARRAY
28441: PUSH
28442: LD_VAR 0 1
28446: EQUAL
28447: AND
28448: IFFALSE 28484
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28450: LD_ADDR_EXP 50
28454: PUSH
28455: LD_EXP 50
28459: PPUSH
28460: LD_VAR 0 2
28464: PPUSH
28465: CALL_OW 255
28469: PPUSH
28470: LD_VAR 0 1
28474: PPUSH
28475: EMPTY
28476: PPUSH
28477: CALL 42067 0 4
28481: ST_TO_ADDR
// break ;
28482: GO 28486
// end ;
28484: GO 28398
28486: POP
28487: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 4
28501: PUSH
28502: LD_INT 3
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: IN
28511: IFFALSE 28628
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28513: LD_ADDR_VAR 0 3
28517: PUSH
28518: LD_VAR 0 2
28522: PPUSH
28523: CALL_OW 255
28527: PPUSH
28528: LD_INT 16
28530: PPUSH
28531: LD_INT 25
28533: PUSH
28534: LD_INT 4
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PPUSH
28541: CALL 12370 0 3
28545: ST_TO_ADDR
// if i then
28546: LD_VAR 0 3
28550: IFFALSE 28568
// SetTag ( i [ 1 ] , 0 ) ;
28552: LD_VAR 0 3
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: PPUSH
28561: LD_INT 0
28563: PPUSH
28564: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28568: LD_ADDR_VAR 0 3
28572: PUSH
28573: LD_VAR 0 2
28577: PPUSH
28578: CALL_OW 255
28582: PPUSH
28583: LD_INT 171
28585: PPUSH
28586: EMPTY
28587: PPUSH
28588: CALL 12370 0 3
28592: ST_TO_ADDR
// if i then
28593: LD_VAR 0 3
28597: IFFALSE 28628
// begin SetTag ( i [ 1 ] , 0 ) ;
28599: LD_VAR 0 3
28603: PUSH
28604: LD_INT 1
28606: ARRAY
28607: PPUSH
28608: LD_INT 0
28610: PPUSH
28611: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28615: LD_VAR 0 3
28619: PUSH
28620: LD_INT 1
28622: ARRAY
28623: PPUSH
28624: CALL_OW 122
// end ; end ; end ;
28628: PPOPN 3
28630: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28631: LD_INT 0
28633: PPUSH
28634: PPUSH
28635: PPUSH
28636: PPUSH
28637: PPUSH
28638: PPUSH
28639: PPUSH
// begin SOS_VehicleConstructed ( veh , b ) ;
28640: LD_VAR 0 1
28644: PPUSH
28645: LD_VAR 0 2
28649: PPUSH
28650: CALL 59049 0 2
// if MREG_SidesList [ GetSide ( b ) ] then
28654: LD_EXP 39
28658: PUSH
28659: LD_VAR 0 2
28663: PPUSH
28664: CALL_OW 255
28668: ARRAY
28669: IFFALSE 29396
// begin side := GetSide ( veh ) ;
28671: LD_ADDR_VAR 0 4
28675: PUSH
28676: LD_VAR 0 1
28680: PPUSH
28681: CALL_OW 255
28685: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28686: LD_ADDR_VAR 0 6
28690: PUSH
28691: LD_VAR 0 1
28695: PPUSH
28696: CALL_OW 265
28700: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28701: LD_ADDR_VAR 0 7
28705: PUSH
28706: LD_VAR 0 1
28710: PPUSH
28711: CALL_OW 262
28715: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28716: LD_ADDR_VAR 0 8
28720: PUSH
28721: LD_VAR 0 1
28725: PPUSH
28726: CALL_OW 263
28730: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28731: LD_ADDR_VAR 0 9
28735: PUSH
28736: LD_VAR 0 1
28740: PPUSH
28741: CALL_OW 264
28745: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28746: LD_STRING VehicleConstructed [side: 
28748: PUSH
28749: LD_VAR 0 4
28753: STR
28754: PUSH
28755: LD_STRING ; id:
28757: STR
28758: PUSH
28759: LD_VAR 0 1
28763: STR
28764: PUSH
28765: LD_STRING ; components: [
28767: STR
28768: PUSH
28769: LD_VAR 0 6
28773: STR
28774: PUSH
28775: LD_STRING , 
28777: STR
28778: PUSH
28779: LD_VAR 0 7
28783: STR
28784: PUSH
28785: LD_STRING , 
28787: STR
28788: PUSH
28789: LD_VAR 0 8
28793: STR
28794: PUSH
28795: LD_STRING , 
28797: STR
28798: PUSH
28799: LD_VAR 0 9
28803: STR
28804: PUSH
28805: LD_STRING ]]
28807: STR
28808: PPUSH
28809: CALL 8055 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28813: LD_VAR 0 1
28817: PPUSH
28818: CALL_OW 264
28822: PUSH
28823: LD_INT 13
28825: PUSH
28826: LD_INT 12
28828: PUSH
28829: LD_INT 14
28831: PUSH
28832: LD_INT 51
28834: PUSH
28835: LD_INT 53
28837: PUSH
28838: LD_INT 52
28840: PUSH
28841: LD_INT 32
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: IN
28853: NOT
28854: IFFALSE 28896
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28856: LD_ADDR_EXP 59
28860: PUSH
28861: LD_EXP 59
28865: PPUSH
28866: LD_VAR 0 4
28870: PPUSH
28871: LD_EXP 59
28875: PUSH
28876: LD_VAR 0 4
28880: ARRAY
28881: PUSH
28882: LD_INT 1
28884: PLUS
28885: PPUSH
28886: LD_VAR 0 1
28890: PPUSH
28891: CALL 31146 0 4
28895: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28896: LD_VAR 0 1
28900: PPUSH
28901: CALL_OW 264
28905: PUSH
28906: LD_INT 31
28908: EQUAL
28909: IFFALSE 28928
// SetTag ( GetDriver ( veh ) , 9 ) ;
28911: LD_VAR 0 1
28915: PPUSH
28916: CALL 31789 0 1
28920: PPUSH
28921: LD_INT 9
28923: PPUSH
28924: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28928: LD_VAR 0 1
28932: PPUSH
28933: CALL_OW 264
28937: PUSH
28938: LD_INT 14
28940: PUSH
28941: LD_INT 53
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: IN
28948: IFFALSE 28985
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28950: LD_ADDR_EXP 42
28954: PUSH
28955: LD_EXP 42
28959: PPUSH
28960: LD_VAR 0 1
28964: PPUSH
28965: CALL_OW 255
28969: PPUSH
28970: LD_INT 2
28972: PPUSH
28973: LD_VAR 0 1
28977: PPUSH
28978: CALL 31146 0 4
28982: ST_TO_ADDR
// exit ;
28983: GO 29396
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28985: LD_VAR 0 1
28989: PPUSH
28990: CALL_OW 265
28994: PUSH
28995: LD_EXP 66
28999: PUSH
29000: LD_VAR 0 4
29004: ARRAY
29005: PUSH
29006: LD_INT 1
29008: ARRAY
29009: IN
29010: PUSH
29011: LD_VAR 0 1
29015: PPUSH
29016: CALL_OW 262
29020: PUSH
29021: LD_EXP 66
29025: PUSH
29026: LD_VAR 0 4
29030: ARRAY
29031: PUSH
29032: LD_INT 1
29034: ARRAY
29035: IN
29036: AND
29037: PUSH
29038: LD_VAR 0 1
29042: PPUSH
29043: CALL_OW 263
29047: PUSH
29048: LD_EXP 66
29052: PUSH
29053: LD_VAR 0 4
29057: ARRAY
29058: PUSH
29059: LD_INT 1
29061: ARRAY
29062: IN
29063: AND
29064: PUSH
29065: LD_VAR 0 1
29069: PPUSH
29070: CALL_OW 264
29074: PUSH
29075: LD_EXP 66
29079: PUSH
29080: LD_VAR 0 4
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: IN
29090: AND
29091: IFFALSE 29135
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
29093: LD_ADDR_EXP 67
29097: PUSH
29098: LD_EXP 67
29102: PPUSH
29103: LD_VAR 0 4
29107: PPUSH
29108: LD_EXP 67
29112: PUSH
29113: LD_VAR 0 4
29117: ARRAY
29118: PUSH
29119: LD_INT 1
29121: PLUS
29122: PPUSH
29123: LD_VAR 0 1
29127: PPUSH
29128: CALL 31146 0 4
29132: ST_TO_ADDR
// exit ;
29133: GO 29396
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29135: LD_VAR 0 6
29139: PUSH
29140: LD_EXP 69
29144: PUSH
29145: LD_VAR 0 4
29149: ARRAY
29150: PUSH
29151: LD_INT 1
29153: ARRAY
29154: EQUAL
29155: PUSH
29156: LD_VAR 0 7
29160: PUSH
29161: LD_EXP 69
29165: PUSH
29166: LD_VAR 0 4
29170: ARRAY
29171: PUSH
29172: LD_INT 2
29174: ARRAY
29175: EQUAL
29176: AND
29177: PUSH
29178: LD_VAR 0 8
29182: PUSH
29183: LD_EXP 69
29187: PUSH
29188: LD_VAR 0 4
29192: ARRAY
29193: PUSH
29194: LD_INT 3
29196: ARRAY
29197: EQUAL
29198: AND
29199: PUSH
29200: LD_VAR 0 9
29204: PUSH
29205: LD_EXP 69
29209: PUSH
29210: LD_VAR 0 4
29214: ARRAY
29215: PUSH
29216: LD_INT 4
29218: ARRAY
29219: EQUAL
29220: AND
29221: IFFALSE 29377
// begin tmp := MREG_ToAttack [ side ] ;
29223: LD_ADDR_VAR 0 5
29227: PUSH
29228: LD_EXP 69
29232: PUSH
29233: LD_VAR 0 4
29237: ARRAY
29238: ST_TO_ADDR
// for i = 1 to 4 do
29239: LD_ADDR_VAR 0 3
29243: PUSH
29244: DOUBLE
29245: LD_INT 1
29247: DEC
29248: ST_TO_ADDR
29249: LD_INT 4
29251: PUSH
29252: FOR_TO
29253: IFFALSE 29275
// tmp := Delete ( tmp , 1 ) ;
29255: LD_ADDR_VAR 0 5
29259: PUSH
29260: LD_VAR 0 5
29264: PPUSH
29265: LD_INT 1
29267: PPUSH
29268: CALL_OW 3
29272: ST_TO_ADDR
29273: GO 29252
29275: POP
29276: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29277: LD_ADDR_EXP 69
29281: PUSH
29282: LD_EXP 69
29286: PPUSH
29287: LD_VAR 0 4
29291: PPUSH
29292: LD_VAR 0 5
29296: PPUSH
29297: CALL_OW 1
29301: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29302: LD_ADDR_EXP 71
29306: PUSH
29307: LD_EXP 71
29311: PPUSH
29312: LD_VAR 0 4
29316: PPUSH
29317: LD_EXP 71
29321: PUSH
29322: LD_VAR 0 4
29326: ARRAY
29327: PUSH
29328: LD_INT 1
29330: PLUS
29331: PPUSH
29332: LD_VAR 0 1
29336: PPUSH
29337: CALL 31146 0 4
29341: ST_TO_ADDR
// if tmp = 0 then
29342: LD_VAR 0 5
29346: PUSH
29347: LD_INT 0
29349: EQUAL
29350: IFFALSE 29375
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29352: LD_ADDR_EXP 69
29356: PUSH
29357: LD_EXP 69
29361: PPUSH
29362: LD_VAR 0 4
29366: PPUSH
29367: LD_INT 0
29369: PPUSH
29370: CALL_OW 1
29374: ST_TO_ADDR
// exit ;
29375: GO 29396
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29377: LD_VAR 0 1
29381: PPUSH
29382: CALL_OW 255
29386: PPUSH
29387: LD_VAR 0 1
29391: PPUSH
29392: CALL 25757 0 2
// end ; end ;
29396: PPOPN 9
29398: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29399: LD_EXP 39
29403: PUSH
29404: LD_VAR 0 2
29408: PPUSH
29409: CALL_OW 255
29413: ARRAY
29414: IFFALSE 29646
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29416: LD_STRING ApemanTamed [side: 
29418: PUSH
29419: LD_VAR 0 2
29423: PPUSH
29424: CALL_OW 255
29428: STR
29429: PUSH
29430: LD_STRING ; sci: 
29432: STR
29433: PUSH
29434: LD_VAR 0 2
29438: STR
29439: PUSH
29440: LD_STRING ; ape: 
29442: STR
29443: PUSH
29444: LD_VAR 0 1
29448: STR
29449: PUSH
29450: LD_STRING ]
29452: STR
29453: PPUSH
29454: CALL 8055 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29458: LD_INT 11
29460: PPUSH
29461: LD_VAR 0 2
29465: PPUSH
29466: CALL_OW 255
29470: PPUSH
29471: CALL_OW 321
29475: PUSH
29476: LD_INT 2
29478: EQUAL
29479: NOT
29480: PUSH
29481: LD_INT 2
29483: PPUSH
29484: LD_VAR 0 2
29488: PPUSH
29489: CALL_OW 255
29493: PPUSH
29494: CALL_OW 321
29498: PUSH
29499: LD_INT 2
29501: EQUAL
29502: NOT
29503: OR
29504: PUSH
29505: LD_VAR 0 2
29509: PPUSH
29510: CALL_OW 255
29514: PPUSH
29515: LD_INT 171
29517: PPUSH
29518: EMPTY
29519: PPUSH
29520: CALL 12370 0 3
29524: PUSH
29525: LD_INT 0
29527: EQUAL
29528: AND
29529: IFFALSE 29543
// begin SetTag ( ape , 171 ) ;
29531: LD_VAR 0 1
29535: PPUSH
29536: LD_INT 171
29538: PPUSH
29539: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29543: LD_VAR 0 2
29547: PPUSH
29548: CALL_OW 255
29552: PPUSH
29553: LD_INT 30
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PPUSH
29563: CALL 11667 0 2
29567: IFFALSE 29646
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29569: LD_VAR 0 1
29573: PPUSH
29574: LD_VAR 0 2
29578: PPUSH
29579: CALL_OW 255
29583: PPUSH
29584: LD_INT 30
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PPUSH
29594: CALL 11667 0 2
29598: PUSH
29599: LD_INT 1
29601: ARRAY
29602: PPUSH
29603: CALL_OW 250
29607: PPUSH
29608: LD_VAR 0 2
29612: PPUSH
29613: CALL_OW 255
29617: PPUSH
29618: LD_INT 30
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PPUSH
29628: CALL 11667 0 2
29632: PUSH
29633: LD_INT 1
29635: ARRAY
29636: PPUSH
29637: CALL_OW 251
29641: PPUSH
29642: CALL_OW 111
// end ;
29646: PPOPN 2
29648: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29649: LD_EXP 39
29653: PUSH
29654: LD_VAR 0 1
29658: PPUSH
29659: CALL_OW 255
29663: ARRAY
29664: IFFALSE 29942
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29666: LD_VAR 0 2
29670: PUSH
29671: LD_VAR 0 2
29675: PPUSH
29676: CALL_OW 255
29680: PPUSH
29681: CALL 12080 0 1
29685: IN
29686: IFFALSE 29827
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29688: LD_VAR 0 1
29692: PPUSH
29693: CALL_OW 266
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: IN
29708: IFFALSE 29738
// begin Wait ( 0 0$0.3 ) ;
29710: LD_INT 10
29712: PPUSH
29713: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29717: LD_VAR 0 2
29721: PPUSH
29722: LD_INT 16
29724: PPUSH
29725: CALL_OW 336
// ComExitBuilding ( un ) ;
29729: LD_VAR 0 2
29733: PPUSH
29734: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29738: LD_VAR 0 1
29742: PPUSH
29743: CALL_OW 266
29747: PUSH
29748: LD_INT 4
29750: PUSH
29751: LD_INT 5
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: IN
29758: IFFALSE 29827
// begin Wait ( 0 0$0.3 ) ;
29760: LD_INT 10
29762: PPUSH
29763: CALL_OW 67
// if GetTag ( un ) = 0 then
29767: LD_VAR 0 2
29771: PPUSH
29772: CALL_OW 110
29776: PUSH
29777: LD_INT 0
29779: EQUAL
29780: IFFALSE 29796
// SetClass ( un , class_apeman_soldier ) else
29782: LD_VAR 0 2
29786: PPUSH
29787: LD_INT 15
29789: PPUSH
29790: CALL_OW 336
29794: GO 29827
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29796: LD_INT 3
29798: PPUSH
29799: LD_VAR 0 2
29803: PPUSH
29804: CALL_OW 255
29808: PPUSH
29809: CALL_OW 321
29813: IFFALSE 29827
// SetClass ( un , class_apeman_kamikaze ) ;
29815: LD_VAR 0 2
29819: PPUSH
29820: LD_INT 17
29822: PPUSH
29823: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29827: LD_VAR 0 1
29831: PPUSH
29832: CALL_OW 266
29836: PUSH
29837: LD_INT 32
29839: EQUAL
29840: IFFALSE 29942
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29842: LD_ADDR_EXP 68
29846: PUSH
29847: LD_EXP 68
29851: PPUSH
29852: LD_VAR 0 1
29856: PPUSH
29857: CALL_OW 255
29861: PPUSH
29862: LD_EXP 68
29866: PUSH
29867: LD_VAR 0 1
29871: PPUSH
29872: CALL_OW 255
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: PLUS
29881: PPUSH
29882: LD_VAR 0 1
29886: PPUSH
29887: CALL 31146 0 4
29891: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29892: LD_ADDR_EXP 68
29896: PUSH
29897: LD_EXP 68
29901: PPUSH
29902: LD_VAR 0 1
29906: PPUSH
29907: CALL_OW 255
29911: PPUSH
29912: LD_EXP 68
29916: PUSH
29917: LD_VAR 0 1
29921: PPUSH
29922: CALL_OW 255
29926: ARRAY
29927: PUSH
29928: LD_INT 1
29930: PLUS
29931: PPUSH
29932: LD_VAR 0 2
29936: PPUSH
29937: CALL 31146 0 4
29941: ST_TO_ADDR
// end ; end ;
29942: PPOPN 2
29944: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29945: LD_VAR 0 1
29949: PPUSH
29950: CALL 58929 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29954: LD_VAR 0 1
29958: PUSH
29959: LD_INT 22
29961: PUSH
29962: LD_INT 3
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 23
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 21
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PPUSH
29994: CALL_OW 69
29998: IN
29999: IFFALSE 30015
// player_loss := player_loss + 1 ;
30001: LD_ADDR_EXP 10
30005: PUSH
30006: LD_EXP 10
30010: PUSH
30011: LD_INT 1
30013: PLUS
30014: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
30015: LD_VAR 0 1
30019: PUSH
30020: LD_INT 22
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 21
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PPUSH
30044: CALL_OW 69
30048: IN
30049: PUSH
30050: LD_EXP 14
30054: NOT
30055: AND
30056: IFFALSE 30119
// begin alfa_north_triggered := true ;
30058: LD_ADDR_EXP 14
30062: PUSH
30063: LD_INT 1
30065: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
30066: LD_EXP 5
30070: PPUSH
30071: LD_STRING DS4
30073: PPUSH
30074: CALL_OW 94
// Wait ( 1 1$25 ) ;
30078: LD_INT 2975
30080: PPUSH
30081: CALL_OW 67
// if not isTest then
30085: LD_EXP 1
30089: NOT
30090: IFFALSE 30119
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30092: LD_INT 20
30094: PPUSH
30095: LD_INT 5
30097: PUSH
30098: LD_INT 6
30100: PUSH
30101: LD_INT 7
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: LIST
30108: PUSH
30109: LD_OWVAR 67
30113: ARRAY
30114: PPUSH
30115: CALL 7074 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30119: LD_VAR 0 1
30123: PUSH
30124: LD_INT 22
30126: PUSH
30127: LD_INT 4
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 21
30136: PUSH
30137: LD_INT 3
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PPUSH
30148: CALL_OW 69
30152: IN
30153: PUSH
30154: LD_EXP 15
30158: NOT
30159: AND
30160: IFFALSE 30223
// begin alfa_south_triggered := true ;
30162: LD_ADDR_EXP 15
30166: PUSH
30167: LD_INT 1
30169: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30170: LD_EXP 4
30174: PPUSH
30175: LD_STRING DJ3
30177: PPUSH
30178: CALL_OW 94
// Wait ( 0 0$45 ) ;
30182: LD_INT 1575
30184: PPUSH
30185: CALL_OW 67
// if not isTest then
30189: LD_EXP 1
30193: NOT
30194: IFFALSE 30223
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30196: LD_INT 20
30198: PPUSH
30199: LD_INT 5
30201: PUSH
30202: LD_INT 6
30204: PUSH
30205: LD_INT 7
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: LIST
30212: PUSH
30213: LD_OWVAR 67
30217: ARRAY
30218: PPUSH
30219: CALL 7074 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30223: LD_VAR 0 1
30227: PPUSH
30228: CALL_OW 266
30232: PUSH
30233: LD_INT 1
30235: EQUAL
30236: PUSH
30237: LD_VAR 0 1
30241: PPUSH
30242: CALL_OW 255
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: LD_INT 4
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: IN
30257: AND
30258: IFFALSE 30267
// RaiseSailEvent ( 104 ) ;
30260: LD_INT 104
30262: PPUSH
30263: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30267: LD_EXP 39
30271: PUSH
30272: LD_VAR 0 1
30276: PPUSH
30277: CALL_OW 255
30281: ARRAY
30282: IFFALSE 30669
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30284: LD_STRING UnitDestroyed [side 
30286: PUSH
30287: LD_VAR 0 1
30291: PPUSH
30292: CALL_OW 255
30296: STR
30297: PUSH
30298: LD_STRING ; id: 
30300: STR
30301: PUSH
30302: LD_VAR 0 1
30306: STR
30307: PUSH
30308: LD_STRING ; type: 
30310: STR
30311: PUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL_OW 247
30321: STR
30322: PUSH
30323: LD_STRING ]
30325: STR
30326: PPUSH
30327: CALL 8055 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30331: LD_VAR 0 1
30335: PUSH
30336: LD_VAR 0 1
30340: PPUSH
30341: CALL_OW 255
30345: PPUSH
30346: LD_INT 21
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PPUSH
30356: CALL 11667 0 2
30360: IN
30361: IFFALSE 30517
// begin if MCF_HasClass ( un ) then
30363: LD_VAR 0 1
30367: PPUSH
30368: CALL 14373 0 1
30372: IFFALSE 30517
// case MCF_HasClass ( un ) of 1 :
30374: LD_VAR 0 1
30378: PPUSH
30379: CALL 14373 0 1
30383: PUSH
30384: LD_INT 1
30386: DOUBLE
30387: EQUAL
30388: IFTRUE 30392
30390: GO 30417
30392: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30393: LD_VAR 0 1
30397: PPUSH
30398: CALL_OW 255
30402: PPUSH
30403: LD_STRING ToArm
30405: PPUSH
30406: LD_VAR 0 1
30410: PPUSH
30411: CALL 14546 0 3
30415: GO 30517
30417: LD_INT 2
30419: DOUBLE
30420: EQUAL
30421: IFTRUE 30425
30423: GO 30450
30425: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30426: LD_VAR 0 1
30430: PPUSH
30431: CALL_OW 255
30435: PPUSH
30436: LD_STRING ToDep
30438: PPUSH
30439: LD_VAR 0 1
30443: PPUSH
30444: CALL 14546 0 3
30448: GO 30517
30450: LD_INT 3
30452: DOUBLE
30453: EQUAL
30454: IFTRUE 30458
30456: GO 30483
30458: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30459: LD_VAR 0 1
30463: PPUSH
30464: CALL_OW 255
30468: PPUSH
30469: LD_STRING ToFac
30471: PPUSH
30472: LD_VAR 0 1
30476: PPUSH
30477: CALL 14546 0 3
30481: GO 30517
30483: LD_INT 4
30485: DOUBLE
30486: EQUAL
30487: IFTRUE 30491
30489: GO 30516
30491: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30492: LD_VAR 0 1
30496: PPUSH
30497: CALL_OW 255
30501: PPUSH
30502: LD_STRING ToLab
30504: PPUSH
30505: LD_VAR 0 1
30509: PPUSH
30510: CALL 14546 0 3
30514: GO 30517
30516: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30517: LD_VAR 0 1
30521: PUSH
30522: LD_EXP 67
30526: PUSH
30527: LD_VAR 0 1
30531: PPUSH
30532: CALL_OW 255
30536: ARRAY
30537: IN
30538: IFFALSE 30623
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30540: LD_ADDR_EXP 67
30544: PUSH
30545: LD_EXP 67
30549: PPUSH
30550: LD_VAR 0 1
30554: PPUSH
30555: LD_INT 0
30557: PPUSH
30558: CALL 31305 0 3
30562: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30563: LD_VAR 0 1
30567: PPUSH
30568: CALL_OW 255
30572: PPUSH
30573: LD_VAR 0 1
30577: PPUSH
30578: CALL_OW 265
30582: PUSH
30583: LD_VAR 0 1
30587: PPUSH
30588: CALL_OW 262
30592: PUSH
30593: LD_VAR 0 1
30597: PPUSH
30598: CALL_OW 263
30602: PUSH
30603: LD_VAR 0 1
30607: PPUSH
30608: CALL_OW 264
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: PPUSH
30619: CALL 21186 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30623: LD_VAR 0 1
30627: PUSH
30628: LD_EXP 71
30632: PUSH
30633: LD_VAR 0 1
30637: PPUSH
30638: CALL_OW 255
30642: ARRAY
30643: IN
30644: IFFALSE 30669
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30646: LD_ADDR_EXP 71
30650: PUSH
30651: LD_EXP 71
30655: PPUSH
30656: LD_VAR 0 1
30660: PPUSH
30661: LD_INT 0
30663: PPUSH
30664: CALL 31305 0 3
30668: ST_TO_ADDR
// end ; end ;
30669: PPOPN 1
30671: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30672: LD_EXP 39
30676: PUSH
30677: LD_VAR 0 2
30681: PPUSH
30682: CALL_OW 255
30686: ARRAY
30687: IFFALSE 30859
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30689: LD_VAR 0 2
30693: PUSH
30694: LD_EXP 68
30698: PUSH
30699: LD_VAR 0 2
30703: PPUSH
30704: CALL_OW 255
30708: ARRAY
30709: IN
30710: PUSH
30711: LD_VAR 0 1
30715: PPUSH
30716: CALL_OW 266
30720: PUSH
30721: LD_INT 32
30723: PUSH
30724: LD_INT 31
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: IN
30731: AND
30732: IFFALSE 30832
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30734: LD_ADDR_EXP 68
30738: PUSH
30739: LD_EXP 68
30743: PPUSH
30744: LD_VAR 0 1
30748: PPUSH
30749: LD_INT 0
30751: PPUSH
30752: CALL 31305 0 3
30756: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30757: LD_ADDR_EXP 68
30761: PUSH
30762: LD_EXP 68
30766: PPUSH
30767: LD_VAR 0 2
30771: PPUSH
30772: LD_INT 0
30774: PPUSH
30775: CALL 31305 0 3
30779: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30780: LD_EXP 68
30784: PUSH
30785: LD_VAR 0 2
30789: PPUSH
30790: CALL_OW 255
30794: ARRAY
30795: PUSH
30796: LD_STRING 
30798: EQUAL
30799: IFFALSE 30832
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30801: LD_ADDR_EXP 68
30805: PUSH
30806: LD_EXP 68
30810: PPUSH
30811: LD_VAR 0 2
30815: PPUSH
30816: CALL_OW 255
30820: PPUSH
30821: LD_INT 1
30823: PPUSH
30824: LD_INT 0
30826: PPUSH
30827: CALL 31146 0 4
30831: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30832: LD_VAR 0 1
30836: PPUSH
30837: CALL_OW 266
30841: PUSH
30842: LD_INT 36
30844: IN
30845: IFFALSE 30859
// SetTag ( un , 0 ) ;
30847: LD_VAR 0 2
30851: PPUSH
30852: LD_INT 0
30854: PPUSH
30855: CALL_OW 109
// end ;
30859: PPOPN 2
30861: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30862: LD_EXP 39
30866: PUSH
30867: LD_VAR 0 1
30871: PPUSH
30872: CALL_OW 255
30876: ARRAY
30877: IFFALSE 30903
// begin if GetControl ( un ) = control_remote then
30879: LD_VAR 0 1
30883: PPUSH
30884: CALL_OW 263
30888: PUSH
30889: LD_INT 2
30891: EQUAL
30892: IFFALSE 30903
// ComUnlink ( un ) ;
30894: LD_VAR 0 1
30898: PPUSH
30899: CALL_OW 136
// end ;
30903: PPOPN 1
30905: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30906: LD_EXP 39
30910: PUSH
30911: LD_VAR 0 1
30915: PPUSH
30916: CALL_OW 255
30920: ARRAY
30921: IFFALSE 30950
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30923: LD_VAR 0 2
30927: PPUSH
30928: CALL_OW 264
30932: PUSH
30933: LD_INT 31
30935: IN
30936: IFFALSE 30950
// SetTag ( driver , 0 ) ;
30938: LD_VAR 0 1
30942: PPUSH
30943: LD_INT 0
30945: PPUSH
30946: CALL_OW 109
// end ;
30950: PPOPN 4
30952: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30953: LD_INT 0
30955: PPUSH
30956: PPUSH
30957: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30958: LD_ADDR_VAR 0 3
30962: PUSH
30963: LD_VAR 0 1
30967: PPUSH
30968: CALL_OW 269
30972: ST_TO_ADDR
// x := GetX ( building ) ;
30973: LD_ADDR_VAR 0 4
30977: PUSH
30978: LD_VAR 0 1
30982: PPUSH
30983: CALL_OW 250
30987: ST_TO_ADDR
// y := GetY ( building ) ;
30988: LD_ADDR_VAR 0 5
30992: PUSH
30993: LD_VAR 0 1
30997: PPUSH
30998: CALL_OW 251
31002: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
31003: LD_ADDR_EXP 43
31007: PUSH
31008: LD_EXP 43
31012: PPUSH
31013: LD_VAR 0 1
31017: PPUSH
31018: CALL_OW 255
31022: PPUSH
31023: LD_VAR 0 3
31027: PPUSH
31028: LD_VAR 0 4
31032: PUSH
31033: LD_VAR 0 5
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PPUSH
31042: CALL 42067 0 4
31046: ST_TO_ADDR
// end ;
31047: PPOPN 5
31049: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
31050: LD_VAR 0 1
31054: PUSH
31055: LD_EXP 30
31059: IN
31060: NOT
31061: IFFALSE 31109
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
31063: LD_ADDR_EXP 30
31067: PUSH
31068: LD_EXP 30
31072: PPUSH
31073: LD_EXP 30
31077: PUSH
31078: LD_INT 1
31080: PLUS
31081: PPUSH
31082: LD_VAR 0 1
31086: PPUSH
31087: CALL_OW 2
31091: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
31092: LD_STRING DestinationUnrechable. [unit: 
31094: PUSH
31095: LD_VAR 0 1
31099: STR
31100: PUSH
31101: LD_STRING ]
31103: STR
31104: PPUSH
31105: CALL 8055 0 1
// end ; end ;
31109: PPOPN 1
31111: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31112: LD_VAR 0 1
31116: PPUSH
31117: LD_VAR 0 2
31121: PPUSH
31122: LD_VAR 0 3
31126: PPUSH
31127: CALL 59025 0 3
// end ;
31131: PPOPN 3
31133: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31134: LD_VAR 0 1
31138: PPUSH
31139: CALL 59033 0 1
// end ; end_of_file
31143: PPOPN 1
31145: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31146: LD_INT 0
31148: PPUSH
31149: PPUSH
31150: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31151: LD_ADDR_VAR 0 7
31155: PUSH
31156: LD_VAR 0 1
31160: PUSH
31161: LD_VAR 0 2
31165: ARRAY
31166: PPUSH
31167: LD_VAR 0 3
31171: PPUSH
31172: LD_VAR 0 4
31176: PPUSH
31177: CALL_OW 1
31181: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31182: LD_ADDR_VAR 0 1
31186: PUSH
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_VAR 0 2
31196: PPUSH
31197: LD_VAR 0 7
31201: PPUSH
31202: CALL_OW 1
31206: ST_TO_ADDR
// result := tab ;
31207: LD_ADDR_VAR 0 5
31211: PUSH
31212: LD_VAR 0 1
31216: ST_TO_ADDR
// end ;
31217: LD_VAR 0 5
31221: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31222: LD_INT 0
31224: PPUSH
31225: PPUSH
31226: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31227: LD_ADDR_VAR 0 5
31231: PUSH
31232: LD_VAR 0 1
31236: PUSH
31237: LD_VAR 0 2
31241: PUSH
31242: LD_INT 1
31244: ARRAY
31245: ARRAY
31246: PPUSH
31247: LD_VAR 0 2
31251: PUSH
31252: LD_INT 2
31254: ARRAY
31255: PPUSH
31256: CALL_OW 3
31260: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31261: LD_ADDR_VAR 0 1
31265: PUSH
31266: LD_VAR 0 1
31270: PPUSH
31271: LD_VAR 0 2
31275: PUSH
31276: LD_INT 1
31278: ARRAY
31279: PPUSH
31280: LD_VAR 0 5
31284: PPUSH
31285: CALL_OW 1
31289: ST_TO_ADDR
// result := tab ;
31290: LD_ADDR_VAR 0 3
31294: PUSH
31295: LD_VAR 0 1
31299: ST_TO_ADDR
// end ;
31300: LD_VAR 0 3
31304: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31305: LD_INT 0
31307: PPUSH
31308: PPUSH
31309: PPUSH
31310: PPUSH
// i := 1 ;
31311: LD_ADDR_VAR 0 5
31315: PUSH
31316: LD_INT 1
31318: ST_TO_ADDR
// while ( i <= tab ) do
31319: LD_VAR 0 5
31323: PUSH
31324: LD_VAR 0 1
31328: LESSEQUAL
31329: IFFALSE 31704
// begin if not tab [ i ] then
31331: LD_VAR 0 1
31335: PUSH
31336: LD_VAR 0 5
31340: ARRAY
31341: NOT
31342: IFFALSE 31346
// break ;
31344: GO 31704
// if value in tab then
31346: LD_VAR 0 2
31350: PUSH
31351: LD_VAR 0 1
31355: IN
31356: IFFALSE 31469
// begin if not mode then
31358: LD_VAR 0 3
31362: NOT
31363: IFFALSE 31383
// tab := tab diff value else
31365: LD_ADDR_VAR 0 1
31369: PUSH
31370: LD_VAR 0 1
31374: PUSH
31375: LD_VAR 0 2
31379: DIFF
31380: ST_TO_ADDR
31381: GO 31445
// for j = 1 to tab do
31383: LD_ADDR_VAR 0 6
31387: PUSH
31388: DOUBLE
31389: LD_INT 1
31391: DEC
31392: ST_TO_ADDR
31393: LD_VAR 0 1
31397: PUSH
31398: FOR_TO
31399: IFFALSE 31443
// if tab [ j ] = value then
31401: LD_VAR 0 1
31405: PUSH
31406: LD_VAR 0 6
31410: ARRAY
31411: PUSH
31412: LD_VAR 0 2
31416: EQUAL
31417: IFFALSE 31441
// begin tab := Delete ( tab , j ) ;
31419: LD_ADDR_VAR 0 1
31423: PUSH
31424: LD_VAR 0 1
31428: PPUSH
31429: LD_VAR 0 6
31433: PPUSH
31434: CALL_OW 3
31438: ST_TO_ADDR
// break ;
31439: GO 31443
// end ;
31441: GO 31398
31443: POP
31444: POP
// i := i - 1 ;
31445: LD_ADDR_VAR 0 5
31449: PUSH
31450: LD_VAR 0 5
31454: PUSH
31455: LD_INT 1
31457: MINUS
31458: ST_TO_ADDR
// if mode then
31459: LD_VAR 0 3
31463: IFFALSE 31467
// break ;
31465: GO 31704
// end else
31467: GO 31688
// if tab [ i ] and value in tab [ i ] then
31469: LD_VAR 0 1
31473: PUSH
31474: LD_VAR 0 5
31478: ARRAY
31479: PUSH
31480: LD_VAR 0 2
31484: PUSH
31485: LD_VAR 0 1
31489: PUSH
31490: LD_VAR 0 5
31494: ARRAY
31495: IN
31496: AND
31497: IFFALSE 31688
// begin if not mode then
31499: LD_VAR 0 3
31503: NOT
31504: IFFALSE 31530
// tmp := tab [ i ] diff value else
31506: LD_ADDR_VAR 0 7
31510: PUSH
31511: LD_VAR 0 1
31515: PUSH
31516: LD_VAR 0 5
31520: ARRAY
31521: PUSH
31522: LD_VAR 0 2
31526: DIFF
31527: ST_TO_ADDR
31528: GO 31610
// for j = 1 to tab [ i ] do
31530: LD_ADDR_VAR 0 6
31534: PUSH
31535: DOUBLE
31536: LD_INT 1
31538: DEC
31539: ST_TO_ADDR
31540: LD_VAR 0 1
31544: PUSH
31545: LD_VAR 0 5
31549: ARRAY
31550: PUSH
31551: FOR_TO
31552: IFFALSE 31608
// if value = tab [ i ] [ j ] then
31554: LD_VAR 0 2
31558: PUSH
31559: LD_VAR 0 1
31563: PUSH
31564: LD_VAR 0 5
31568: ARRAY
31569: PUSH
31570: LD_VAR 0 6
31574: ARRAY
31575: EQUAL
31576: IFFALSE 31606
// begin tmp := Delete ( tab [ i ] , j ) ;
31578: LD_ADDR_VAR 0 7
31582: PUSH
31583: LD_VAR 0 1
31587: PUSH
31588: LD_VAR 0 5
31592: ARRAY
31593: PPUSH
31594: LD_VAR 0 6
31598: PPUSH
31599: CALL_OW 3
31603: ST_TO_ADDR
// break ;
31604: GO 31608
// end ;
31606: GO 31551
31608: POP
31609: POP
// if tmp = [ ] then
31610: LD_VAR 0 7
31614: PUSH
31615: EMPTY
31616: EQUAL
31617: IFFALSE 31641
// begin tab := Delete ( tab , i ) ;
31619: LD_ADDR_VAR 0 1
31623: PUSH
31624: LD_VAR 0 1
31628: PPUSH
31629: LD_VAR 0 5
31633: PPUSH
31634: CALL_OW 3
31638: ST_TO_ADDR
// end else
31639: GO 31666
// tab := Replace ( tab , i , tmp ) ;
31641: LD_ADDR_VAR 0 1
31645: PUSH
31646: LD_VAR 0 1
31650: PPUSH
31651: LD_VAR 0 5
31655: PPUSH
31656: LD_VAR 0 7
31660: PPUSH
31661: CALL_OW 1
31665: ST_TO_ADDR
// i := i - 1 ;
31666: LD_ADDR_VAR 0 5
31670: PUSH
31671: LD_VAR 0 5
31675: PUSH
31676: LD_INT 1
31678: MINUS
31679: ST_TO_ADDR
// if mode then
31680: LD_VAR 0 3
31684: IFFALSE 31688
// break ;
31686: GO 31704
// end ; i := i + 1 ;
31688: LD_ADDR_VAR 0 5
31692: PUSH
31693: LD_VAR 0 5
31697: PUSH
31698: LD_INT 1
31700: PLUS
31701: ST_TO_ADDR
// end ;
31702: GO 31319
// result := tab ;
31704: LD_ADDR_VAR 0 4
31708: PUSH
31709: LD_VAR 0 1
31713: ST_TO_ADDR
// end ;
31714: LD_VAR 0 4
31718: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31719: LD_INT 0
31721: PPUSH
31722: PPUSH
// for i = 1 to values do
31723: LD_ADDR_VAR 0 4
31727: PUSH
31728: DOUBLE
31729: LD_INT 1
31731: DEC
31732: ST_TO_ADDR
31733: LD_VAR 0 2
31737: PUSH
31738: FOR_TO
31739: IFFALSE 31772
// tab := Remove ( tab , values [ i ] , false ) ;
31741: LD_ADDR_VAR 0 1
31745: PUSH
31746: LD_VAR 0 1
31750: PPUSH
31751: LD_VAR 0 2
31755: PUSH
31756: LD_VAR 0 4
31760: ARRAY
31761: PPUSH
31762: LD_INT 0
31764: PPUSH
31765: CALL 31305 0 3
31769: ST_TO_ADDR
31770: GO 31738
31772: POP
31773: POP
// result := tab ;
31774: LD_ADDR_VAR 0 3
31778: PUSH
31779: LD_VAR 0 1
31783: ST_TO_ADDR
// end ;
31784: LD_VAR 0 3
31788: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31789: LD_INT 0
31791: PPUSH
31792: PPUSH
31793: PPUSH
// if not GetControl ( veh ) = control_manual then
31794: LD_VAR 0 1
31798: PPUSH
31799: CALL_OW 263
31803: PUSH
31804: LD_INT 1
31806: EQUAL
31807: NOT
31808: IFFALSE 31820
// result := false else
31810: LD_ADDR_VAR 0 2
31814: PUSH
31815: LD_INT 0
31817: ST_TO_ADDR
31818: GO 31965
// if veh in FilterAllUnits ( [ f_empty ] ) then
31820: LD_VAR 0 1
31824: PUSH
31825: LD_INT 58
31827: PUSH
31828: EMPTY
31829: LIST
31830: PPUSH
31831: CALL_OW 69
31835: IN
31836: IFFALSE 31848
// result := false else
31838: LD_ADDR_VAR 0 2
31842: PUSH
31843: LD_INT 0
31845: ST_TO_ADDR
31846: GO 31965
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31848: LD_ADDR_VAR 0 4
31852: PUSH
31853: LD_INT 22
31855: PUSH
31856: LD_VAR 0 1
31860: PPUSH
31861: CALL_OW 255
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 55
31872: PUSH
31873: EMPTY
31874: LIST
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PPUSH
31880: CALL_OW 69
31884: ST_TO_ADDR
// if not filter then
31885: LD_VAR 0 4
31889: NOT
31890: IFFALSE 31902
// result := false else
31892: LD_ADDR_VAR 0 2
31896: PUSH
31897: LD_INT 0
31899: ST_TO_ADDR
31900: GO 31965
// for i = 1 to filter do
31902: LD_ADDR_VAR 0 3
31906: PUSH
31907: DOUBLE
31908: LD_INT 1
31910: DEC
31911: ST_TO_ADDR
31912: LD_VAR 0 4
31916: PUSH
31917: FOR_TO
31918: IFFALSE 31963
// if IsDriver ( filter [ i ] ) = veh then
31920: LD_VAR 0 4
31924: PUSH
31925: LD_VAR 0 3
31929: ARRAY
31930: PPUSH
31931: CALL 98203 0 1
31935: PUSH
31936: LD_VAR 0 1
31940: EQUAL
31941: IFFALSE 31961
// begin result := filter [ i ] ;
31943: LD_ADDR_VAR 0 2
31947: PUSH
31948: LD_VAR 0 4
31952: PUSH
31953: LD_VAR 0 3
31957: ARRAY
31958: ST_TO_ADDR
// break ;
31959: GO 31963
// end ;
31961: GO 31917
31963: POP
31964: POP
// end ; end ;
31965: LD_VAR 0 2
31969: RET
// export function Compare ( val1 , val2 ) ; begin
31970: LD_INT 0
31972: PPUSH
// if val1 = val2 then
31973: LD_VAR 0 1
31977: PUSH
31978: LD_VAR 0 2
31982: EQUAL
31983: IFFALSE 31995
// result := true else
31985: LD_ADDR_VAR 0 3
31989: PUSH
31990: LD_INT 1
31992: ST_TO_ADDR
31993: GO 32003
// result := false ;
31995: LD_ADDR_VAR 0 3
31999: PUSH
32000: LD_INT 0
32002: ST_TO_ADDR
// end ;
32003: LD_VAR 0 3
32007: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
32008: LD_INT 0
32010: PPUSH
32011: PPUSH
// result := false ;
32012: LD_ADDR_VAR 0 3
32016: PUSH
32017: LD_INT 0
32019: ST_TO_ADDR
// for j = 1 to e2 do
32020: LD_ADDR_VAR 0 4
32024: PUSH
32025: DOUBLE
32026: LD_INT 1
32028: DEC
32029: ST_TO_ADDR
32030: LD_VAR 0 2
32034: PUSH
32035: FOR_TO
32036: IFFALSE 32070
// if Compare ( e1 , e2 [ j ] ) then
32038: LD_VAR 0 1
32042: PPUSH
32043: LD_VAR 0 2
32047: PUSH
32048: LD_VAR 0 4
32052: ARRAY
32053: PPUSH
32054: CALL 31970 0 2
32058: IFFALSE 32068
// result := true ;
32060: LD_ADDR_VAR 0 3
32064: PUSH
32065: LD_INT 1
32067: ST_TO_ADDR
32068: GO 32035
32070: POP
32071: POP
// end ;
32072: LD_VAR 0 3
32076: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
32077: LD_INT 0
32079: PPUSH
32080: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
32081: LD_VAR 0 1
32085: PPUSH
32086: LD_STRING C
32088: PUSH
32089: LD_VAR 0 2
32093: PUSH
32094: LD_VAR 0 3
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: PUSH
32120: LD_STRING v
32122: PUSH
32123: LD_VAR 0 4
32127: PPUSH
32128: CALL_OW 250
32132: PUSH
32133: LD_VAR 0 4
32137: PPUSH
32138: CALL_OW 251
32142: PUSH
32143: LD_VAR 0 4
32147: PUSH
32148: LD_INT 0
32150: PUSH
32151: LD_INT 0
32153: PUSH
32154: LD_INT 0
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PPUSH
32170: CALL_OW 446
// end ;
32174: LD_VAR 0 5
32178: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32179: LD_INT 0
32181: PPUSH
32182: PPUSH
32183: PPUSH
// linked := UnitsLinked ( unit ) ;
32184: LD_ADDR_VAR 0 4
32188: PUSH
32189: LD_VAR 0 1
32193: PPUSH
32194: CALL_OW 432
32198: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32199: LD_ADDR_VAR 0 3
32203: PUSH
32204: LD_VAR 0 1
32208: PPUSH
32209: LD_INT 3
32211: PPUSH
32212: CALL_OW 259
32216: ST_TO_ADDR
// if sk > linked then
32217: LD_VAR 0 3
32221: PUSH
32222: LD_VAR 0 4
32226: GREATER
32227: IFFALSE 32239
// result := true else
32229: LD_ADDR_VAR 0 2
32233: PUSH
32234: LD_INT 1
32236: ST_TO_ADDR
32237: GO 32247
// result := false ;
32239: LD_ADDR_VAR 0 2
32243: PUSH
32244: LD_INT 0
32246: ST_TO_ADDR
// end ;
32247: LD_VAR 0 2
32251: RET
// export function NotTask ( unit ) ; begin
32252: LD_INT 0
32254: PPUSH
// result := true ;
32255: LD_ADDR_VAR 0 2
32259: PUSH
32260: LD_INT 1
32262: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32263: LD_VAR 0 1
32267: PPUSH
32268: CALL_OW 437
32272: PUSH
32273: LD_VAR 0 1
32277: PPUSH
32278: CALL_OW 314
32282: OR
32283: IFFALSE 32293
// result := false ;
32285: LD_ADDR_VAR 0 2
32289: PUSH
32290: LD_INT 0
32292: ST_TO_ADDR
// end ;
32293: LD_VAR 0 2
32297: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32298: LD_INT 0
32300: PPUSH
32301: PPUSH
32302: PPUSH
32303: PPUSH
32304: PPUSH
// dist := 99999 ;
32305: LD_ADDR_VAR 0 7
32309: PUSH
32310: LD_INT 99999
32312: ST_TO_ADDR
// un := - 1 ;
32313: LD_ADDR_VAR 0 6
32317: PUSH
32318: LD_INT 1
32320: NEG
32321: ST_TO_ADDR
// if units1 and units2 then
32322: LD_VAR 0 1
32326: PUSH
32327: LD_VAR 0 2
32331: AND
32332: IFFALSE 32420
// for i in units1 do
32334: LD_ADDR_VAR 0 4
32338: PUSH
32339: LD_VAR 0 1
32343: PUSH
32344: FOR_IN
32345: IFFALSE 32418
// for j in units2 do
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_VAR 0 2
32356: PUSH
32357: FOR_IN
32358: IFFALSE 32414
// if GetDistUnits ( i , j ) < dist then
32360: LD_VAR 0 4
32364: PPUSH
32365: LD_VAR 0 5
32369: PPUSH
32370: CALL_OW 296
32374: PUSH
32375: LD_VAR 0 7
32379: LESS
32380: IFFALSE 32412
// begin un := i ;
32382: LD_ADDR_VAR 0 6
32386: PUSH
32387: LD_VAR 0 4
32391: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32392: LD_ADDR_VAR 0 7
32396: PUSH
32397: LD_VAR 0 4
32401: PPUSH
32402: LD_VAR 0 5
32406: PPUSH
32407: CALL_OW 296
32411: ST_TO_ADDR
// end ;
32412: GO 32357
32414: POP
32415: POP
32416: GO 32344
32418: POP
32419: POP
// result := [ un , dist ] ;
32420: LD_ADDR_VAR 0 3
32424: PUSH
32425: LD_VAR 0 6
32429: PUSH
32430: LD_VAR 0 7
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: ST_TO_ADDR
// end ;
32439: LD_VAR 0 3
32443: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32444: LD_INT 0
32446: PPUSH
32447: PPUSH
32448: PPUSH
32449: PPUSH
32450: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32451: LD_VAR 0 1
32455: NOT
32456: PUSH
32457: LD_VAR 0 1
32461: PPUSH
32462: CALL_OW 256
32466: PUSH
32467: LD_INT 250
32469: LESS
32470: OR
32471: PUSH
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 314
32481: PUSH
32482: LD_VAR 0 1
32486: PPUSH
32487: CALL_OW 261
32491: PUSH
32492: LD_INT 20
32494: GREATER
32495: AND
32496: OR
32497: IFFALSE 32501
// exit ;
32499: GO 32875
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32501: LD_VAR 0 1
32505: PPUSH
32506: CALL_OW 261
32510: PUSH
32511: LD_INT 20
32513: LESS
32514: PUSH
32515: LD_VAR 0 1
32519: PPUSH
32520: CALL_OW 110
32524: PUSH
32525: LD_INT 21
32527: EQUAL
32528: NOT
32529: AND
32530: IFFALSE 32566
// begin ComStop ( bulldozer ) ;
32532: LD_VAR 0 1
32536: PPUSH
32537: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32541: LD_VAR 0 1
32545: PPUSH
32546: LD_INT 21
32548: PPUSH
32549: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32553: LD_VAR 0 1
32557: PPUSH
32558: CALL 26294 0 1
// exit ;
32562: GO 32875
// end else
32564: GO 32593
// if GetFuel ( bulldozer ) > 20 then
32566: LD_VAR 0 1
32570: PPUSH
32571: CALL_OW 261
32575: PUSH
32576: LD_INT 20
32578: GREATER
32579: IFFALSE 32593
// SetTag ( bulldozer , 0 ) ;
32581: LD_VAR 0 1
32585: PPUSH
32586: LD_INT 0
32588: PPUSH
32589: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32593: LD_ADDR_VAR 0 5
32597: PUSH
32598: LD_VAR 0 2
32602: PPUSH
32603: CALL_OW 353
32607: ST_TO_ADDR
// tmp := [ ] ;
32608: LD_ADDR_VAR 0 6
32612: PUSH
32613: EMPTY
32614: ST_TO_ADDR
// for i = 1 to list do
32615: LD_ADDR_VAR 0 4
32619: PUSH
32620: DOUBLE
32621: LD_INT 1
32623: DEC
32624: ST_TO_ADDR
32625: LD_VAR 0 5
32629: PUSH
32630: FOR_TO
32631: IFFALSE 32729
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32633: LD_VAR 0 5
32637: PUSH
32638: LD_VAR 0 4
32642: ARRAY
32643: PUSH
32644: LD_INT 1
32646: ARRAY
32647: PPUSH
32648: LD_VAR 0 5
32652: PUSH
32653: LD_VAR 0 4
32657: ARRAY
32658: PUSH
32659: LD_INT 2
32661: ARRAY
32662: PPUSH
32663: CALL_OW 554
32667: IFFALSE 32727
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32669: LD_ADDR_VAR 0 6
32673: PUSH
32674: LD_VAR 0 6
32678: PPUSH
32679: LD_VAR 0 6
32683: PUSH
32684: LD_INT 1
32686: PLUS
32687: PPUSH
32688: LD_VAR 0 5
32692: PUSH
32693: LD_VAR 0 4
32697: ARRAY
32698: PUSH
32699: LD_INT 1
32701: ARRAY
32702: PUSH
32703: LD_VAR 0 5
32707: PUSH
32708: LD_VAR 0 4
32712: ARRAY
32713: PUSH
32714: LD_INT 2
32716: ARRAY
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PPUSH
32722: CALL_OW 1
32726: ST_TO_ADDR
// end ;
32727: GO 32630
32729: POP
32730: POP
// ComStop ( bulldozer ) ;
32731: LD_VAR 0 1
32735: PPUSH
32736: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32740: LD_ADDR_VAR 0 7
32744: PUSH
32745: LD_VAR 0 1
32749: PPUSH
32750: CALL_OW 250
32754: PUSH
32755: LD_VAR 0 1
32759: PPUSH
32760: CALL_OW 251
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: ST_TO_ADDR
// for i = tmp downto 1 do
32769: LD_ADDR_VAR 0 4
32773: PUSH
32774: DOUBLE
32775: LD_VAR 0 6
32779: INC
32780: ST_TO_ADDR
32781: LD_INT 1
32783: PUSH
32784: FOR_DOWNTO
32785: IFFALSE 32873
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32787: LD_ADDR_VAR 0 7
32791: PUSH
32792: LD_VAR 0 7
32796: PUSH
32797: LD_INT 1
32799: ARRAY
32800: PPUSH
32801: LD_VAR 0 7
32805: PUSH
32806: LD_INT 2
32808: ARRAY
32809: PPUSH
32810: LD_VAR 0 6
32814: PPUSH
32815: CALL 32976 0 3
32819: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32820: LD_VAR 0 1
32824: PPUSH
32825: LD_VAR 0 7
32829: PUSH
32830: LD_INT 1
32832: ARRAY
32833: PPUSH
32834: LD_VAR 0 7
32838: PUSH
32839: LD_INT 2
32841: ARRAY
32842: PPUSH
32843: CALL 32880 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32847: LD_ADDR_VAR 0 6
32851: PUSH
32852: LD_VAR 0 6
32856: PPUSH
32857: LD_VAR 0 7
32861: PUSH
32862: LD_INT 3
32864: ARRAY
32865: PPUSH
32866: CALL_OW 3
32870: ST_TO_ADDR
// end ;
32871: GO 32784
32873: POP
32874: POP
// end ;
32875: LD_VAR 0 3
32879: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32880: LD_INT 0
32882: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32883: LD_VAR 0 2
32887: PPUSH
32888: LD_VAR 0 3
32892: PPUSH
32893: CALL_OW 351
32897: PUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: LD_VAR 0 3
32907: PPUSH
32908: CALL_OW 554
32912: AND
32913: PUSH
32914: LD_VAR 0 2
32918: PPUSH
32919: LD_VAR 0 3
32923: PPUSH
32924: CALL_OW 488
32928: AND
32929: PUSH
32930: LD_VAR 0 2
32934: PPUSH
32935: LD_VAR 0 3
32939: PPUSH
32940: CALL_OW 428
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: EQUAL
32949: AND
32950: IFFALSE 32971
// AddComMoveXY ( bulldozer , x , y ) ;
32952: LD_VAR 0 1
32956: PPUSH
32957: LD_VAR 0 2
32961: PPUSH
32962: LD_VAR 0 3
32966: PPUSH
32967: CALL_OW 171
// end ;
32971: LD_VAR 0 4
32975: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32976: LD_INT 0
32978: PPUSH
32979: PPUSH
32980: PPUSH
32981: PPUSH
32982: PPUSH
32983: PPUSH
32984: PPUSH
// dist := 99999 ;
32985: LD_ADDR_VAR 0 6
32989: PUSH
32990: LD_INT 99999
32992: ST_TO_ADDR
// for i = 1 to list do
32993: LD_ADDR_VAR 0 5
32997: PUSH
32998: DOUBLE
32999: LD_INT 1
33001: DEC
33002: ST_TO_ADDR
33003: LD_VAR 0 3
33007: PUSH
33008: FOR_TO
33009: IFFALSE 33147
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
33011: LD_ADDR_VAR 0 7
33015: PUSH
33016: LD_VAR 0 1
33020: PPUSH
33021: LD_VAR 0 2
33025: PPUSH
33026: LD_VAR 0 3
33030: PUSH
33031: LD_VAR 0 5
33035: ARRAY
33036: PUSH
33037: LD_INT 1
33039: ARRAY
33040: PPUSH
33041: LD_VAR 0 3
33045: PUSH
33046: LD_VAR 0 5
33050: ARRAY
33051: PUSH
33052: LD_INT 2
33054: ARRAY
33055: PPUSH
33056: CALL_OW 298
33060: ST_TO_ADDR
// if d = 0 then
33061: LD_VAR 0 7
33065: PUSH
33066: LD_INT 0
33068: EQUAL
33069: IFFALSE 33073
// continue ;
33071: GO 33008
// if d < dist then
33073: LD_VAR 0 7
33077: PUSH
33078: LD_VAR 0 6
33082: LESS
33083: IFFALSE 33145
// begin _x := list [ i ] [ 1 ] ;
33085: LD_ADDR_VAR 0 8
33089: PUSH
33090: LD_VAR 0 3
33094: PUSH
33095: LD_VAR 0 5
33099: ARRAY
33100: PUSH
33101: LD_INT 1
33103: ARRAY
33104: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33105: LD_ADDR_VAR 0 9
33109: PUSH
33110: LD_VAR 0 3
33114: PUSH
33115: LD_VAR 0 5
33119: ARRAY
33120: PUSH
33121: LD_INT 2
33123: ARRAY
33124: ST_TO_ADDR
// _i := i ;
33125: LD_ADDR_VAR 0 10
33129: PUSH
33130: LD_VAR 0 5
33134: ST_TO_ADDR
// dist := d ;
33135: LD_ADDR_VAR 0 6
33139: PUSH
33140: LD_VAR 0 7
33144: ST_TO_ADDR
// end ; end ;
33145: GO 33008
33147: POP
33148: POP
// result := [ _x , _y , _i , dist ] ;
33149: LD_ADDR_VAR 0 4
33153: PUSH
33154: LD_VAR 0 8
33158: PUSH
33159: LD_VAR 0 9
33163: PUSH
33164: LD_VAR 0 10
33168: PUSH
33169: LD_VAR 0 6
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: ST_TO_ADDR
// end ;
33180: LD_VAR 0 4
33184: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33185: LD_INT 0
33187: PPUSH
33188: PPUSH
33189: PPUSH
33190: PPUSH
33191: PPUSH
// for i = 1 to list do
33192: LD_ADDR_VAR 0 5
33196: PUSH
33197: DOUBLE
33198: LD_INT 1
33200: DEC
33201: ST_TO_ADDR
33202: LD_VAR 0 1
33206: PUSH
33207: FOR_TO
33208: IFFALSE 33522
// begin for j = list downto 2 do
33210: LD_ADDR_VAR 0 6
33214: PUSH
33215: DOUBLE
33216: LD_VAR 0 1
33220: INC
33221: ST_TO_ADDR
33222: LD_INT 2
33224: PUSH
33225: FOR_DOWNTO
33226: IFFALSE 33518
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33228: LD_VAR 0 2
33232: PPUSH
33233: LD_VAR 0 3
33237: PPUSH
33238: LD_VAR 0 1
33242: PUSH
33243: LD_VAR 0 6
33247: ARRAY
33248: PUSH
33249: LD_INT 1
33251: ARRAY
33252: PPUSH
33253: LD_VAR 0 1
33257: PUSH
33258: LD_VAR 0 6
33262: ARRAY
33263: PUSH
33264: LD_INT 2
33266: ARRAY
33267: PPUSH
33268: CALL_OW 298
33272: PUSH
33273: LD_VAR 0 2
33277: PPUSH
33278: LD_VAR 0 3
33282: PPUSH
33283: LD_VAR 0 1
33287: PUSH
33288: LD_VAR 0 6
33292: PUSH
33293: LD_INT 1
33295: MINUS
33296: ARRAY
33297: PUSH
33298: LD_INT 1
33300: ARRAY
33301: PPUSH
33302: LD_VAR 0 1
33306: PUSH
33307: LD_VAR 0 6
33311: PUSH
33312: LD_INT 1
33314: MINUS
33315: ARRAY
33316: PUSH
33317: LD_INT 2
33319: ARRAY
33320: PPUSH
33321: CALL_OW 298
33325: LESS
33326: IFFALSE 33516
// begin _x := list [ j ] [ 1 ] ;
33328: LD_ADDR_VAR 0 7
33332: PUSH
33333: LD_VAR 0 1
33337: PUSH
33338: LD_VAR 0 6
33342: ARRAY
33343: PUSH
33344: LD_INT 1
33346: ARRAY
33347: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33348: LD_ADDR_VAR 0 8
33352: PUSH
33353: LD_VAR 0 1
33357: PUSH
33358: LD_VAR 0 6
33362: ARRAY
33363: PUSH
33364: LD_INT 2
33366: ARRAY
33367: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33368: LD_ADDR_VAR 0 1
33372: PUSH
33373: LD_VAR 0 1
33377: PPUSH
33378: LD_VAR 0 6
33382: PPUSH
33383: LD_INT 1
33385: PPUSH
33386: LD_VAR 0 1
33390: PUSH
33391: LD_VAR 0 6
33395: PUSH
33396: LD_INT 1
33398: MINUS
33399: ARRAY
33400: PUSH
33401: LD_INT 1
33403: ARRAY
33404: PPUSH
33405: CALL 31146 0 4
33409: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33410: LD_ADDR_VAR 0 1
33414: PUSH
33415: LD_VAR 0 1
33419: PPUSH
33420: LD_VAR 0 6
33424: PPUSH
33425: LD_INT 2
33427: PPUSH
33428: LD_VAR 0 1
33432: PUSH
33433: LD_VAR 0 6
33437: PUSH
33438: LD_INT 1
33440: MINUS
33441: ARRAY
33442: PUSH
33443: LD_INT 2
33445: ARRAY
33446: PPUSH
33447: CALL 31146 0 4
33451: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33452: LD_ADDR_VAR 0 1
33456: PUSH
33457: LD_VAR 0 1
33461: PPUSH
33462: LD_VAR 0 6
33466: PUSH
33467: LD_INT 1
33469: MINUS
33470: PPUSH
33471: LD_INT 1
33473: PPUSH
33474: LD_VAR 0 7
33478: PPUSH
33479: CALL 31146 0 4
33483: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33484: LD_ADDR_VAR 0 1
33488: PUSH
33489: LD_VAR 0 1
33493: PPUSH
33494: LD_VAR 0 6
33498: PUSH
33499: LD_INT 1
33501: MINUS
33502: PPUSH
33503: LD_INT 2
33505: PPUSH
33506: LD_VAR 0 8
33510: PPUSH
33511: CALL 31146 0 4
33515: ST_TO_ADDR
// end ; end ;
33516: GO 33225
33518: POP
33519: POP
// end ;
33520: GO 33207
33522: POP
33523: POP
// result := list ;
33524: LD_ADDR_VAR 0 4
33528: PUSH
33529: LD_VAR 0 1
33533: ST_TO_ADDR
// end ;
33534: LD_VAR 0 4
33538: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33539: LD_INT 0
33541: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33542: LD_ADDR_VAR 0 5
33546: PUSH
33547: LD_VAR 0 1
33551: PPUSH
33552: LD_VAR 0 2
33556: PPUSH
33557: CALL_OW 546
33561: PUSH
33562: LD_INT 2
33564: ARRAY
33565: PUSH
33566: LD_VAR 0 3
33570: PPUSH
33571: LD_VAR 0 4
33575: PPUSH
33576: CALL_OW 546
33580: PUSH
33581: LD_INT 2
33583: ARRAY
33584: MINUS
33585: ST_TO_ADDR
// if result < 0 then
33586: LD_VAR 0 5
33590: PUSH
33591: LD_INT 0
33593: LESS
33594: IFFALSE 33611
// result := result * - 1 ;
33596: LD_ADDR_VAR 0 5
33600: PUSH
33601: LD_VAR 0 5
33605: PUSH
33606: LD_INT 1
33608: NEG
33609: MUL
33610: ST_TO_ADDR
// end ;
33611: LD_VAR 0 5
33615: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33616: LD_INT 0
33618: PPUSH
33619: PPUSH
// area = ListEnvironmentArea ( area ) ;
33620: LD_ADDR_VAR 0 2
33624: PUSH
33625: LD_VAR 0 2
33629: PPUSH
33630: CALL_OW 353
33634: ST_TO_ADDR
// if bulldozer > 0 then
33635: LD_VAR 0 1
33639: PUSH
33640: LD_INT 0
33642: GREATER
33643: IFFALSE 33754
// for i = area downto 1 do
33645: LD_ADDR_VAR 0 4
33649: PUSH
33650: DOUBLE
33651: LD_VAR 0 2
33655: INC
33656: ST_TO_ADDR
33657: LD_INT 1
33659: PUSH
33660: FOR_DOWNTO
33661: IFFALSE 33752
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33663: LD_VAR 0 2
33667: PUSH
33668: LD_VAR 0 4
33672: ARRAY
33673: PUSH
33674: LD_INT 1
33676: ARRAY
33677: PPUSH
33678: LD_VAR 0 2
33682: PUSH
33683: LD_VAR 0 4
33687: ARRAY
33688: PUSH
33689: LD_INT 2
33691: ARRAY
33692: PPUSH
33693: CALL_OW 351
33697: IFFALSE 33750
// if not HasTask ( bulldozer ) then
33699: LD_VAR 0 1
33703: PPUSH
33704: CALL_OW 314
33708: NOT
33709: IFFALSE 33750
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33711: LD_VAR 0 1
33715: PPUSH
33716: LD_VAR 0 2
33720: PUSH
33721: LD_VAR 0 4
33725: ARRAY
33726: PUSH
33727: LD_INT 1
33729: ARRAY
33730: PPUSH
33731: LD_VAR 0 2
33735: PUSH
33736: LD_VAR 0 4
33740: ARRAY
33741: PUSH
33742: LD_INT 2
33744: ARRAY
33745: PPUSH
33746: CALL_OW 171
33750: GO 33660
33752: POP
33753: POP
// end ;
33754: LD_VAR 0 3
33758: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33759: LD_INT 0
33761: PPUSH
33762: PPUSH
33763: PPUSH
33764: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33765: LD_ADDR_VAR 0 6
33769: PUSH
33770: LD_INT 22
33772: PUSH
33773: LD_VAR 0 1
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 21
33784: PUSH
33785: LD_VAR 0 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PPUSH
33798: CALL_OW 69
33802: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33803: LD_ADDR_VAR 0 7
33807: PUSH
33808: LD_VAR 0 3
33812: PPUSH
33813: LD_INT 22
33815: PUSH
33816: LD_VAR 0 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 21
33827: PUSH
33828: LD_VAR 0 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PPUSH
33841: CALL_OW 70
33845: ST_TO_ADDR
// if tmp and pom then
33846: LD_VAR 0 6
33850: PUSH
33851: LD_VAR 0 7
33855: AND
33856: IFFALSE 33876
// result := tmp diff pom else
33858: LD_ADDR_VAR 0 4
33862: PUSH
33863: LD_VAR 0 6
33867: PUSH
33868: LD_VAR 0 7
33872: DIFF
33873: ST_TO_ADDR
33874: GO 33884
// result := false ;
33876: LD_ADDR_VAR 0 4
33880: PUSH
33881: LD_INT 0
33883: ST_TO_ADDR
// end ;
33884: LD_VAR 0 4
33888: RET
// export function SavePosition ( unit ) ; begin
33889: LD_INT 0
33891: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33892: LD_VAR 0 1
33896: PPUSH
33897: LD_VAR 0 1
33901: PPUSH
33902: CALL_OW 250
33906: PPUSH
33907: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33911: LD_VAR 0 1
33915: PPUSH
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL_OW 251
33925: PPUSH
33926: CALL_OW 232
// end ;
33930: LD_VAR 0 2
33934: RET
// export function GetPosition ( unit ) ; begin
33935: LD_INT 0
33937: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33938: LD_ADDR_VAR 0 2
33942: PUSH
33943: LD_VAR 0 1
33947: PPUSH
33948: CALL_OW 252
33952: PUSH
33953: LD_VAR 0 1
33957: PPUSH
33958: CALL_OW 253
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: ST_TO_ADDR
// end ;
33967: LD_VAR 0 2
33971: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33972: LD_INT 0
33974: PPUSH
// if unit in unreachableList then
33975: LD_VAR 0 1
33979: PUSH
33980: LD_EXP 30
33984: IN
33985: IFFALSE 34003
// unreachableList := unreachableList diff unit ;
33987: LD_ADDR_EXP 30
33991: PUSH
33992: LD_EXP 30
33996: PUSH
33997: LD_VAR 0 1
34001: DIFF
34002: ST_TO_ADDR
// if ValidHex ( x , y ) then
34003: LD_VAR 0 2
34007: PPUSH
34008: LD_VAR 0 3
34012: PPUSH
34013: CALL_OW 488
34017: IFFALSE 34043
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
34019: LD_VAR 0 1
34023: PPUSH
34024: LD_VAR 0 2
34028: PPUSH
34029: LD_VAR 0 3
34033: PPUSH
34034: CALL_OW 428
34038: PPUSH
34039: CALL_OW 115
// Wait ( 3 ) ;
34043: LD_INT 3
34045: PPUSH
34046: CALL_OW 67
// if unit in unreachableList then
34050: LD_VAR 0 1
34054: PUSH
34055: LD_EXP 30
34059: IN
34060: IFFALSE 34072
// result := false else
34062: LD_ADDR_VAR 0 4
34066: PUSH
34067: LD_INT 0
34069: ST_TO_ADDR
34070: GO 34080
// result := true ;
34072: LD_ADDR_VAR 0 4
34076: PUSH
34077: LD_INT 1
34079: ST_TO_ADDR
// end ; end_of_file
34080: LD_VAR 0 4
34084: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
34085: LD_EXP 31
34089: IFFALSE 34151
34091: GO 34093
34093: DISABLE
34094: LD_INT 0
34096: PPUSH
// begin enable ;
34097: ENABLE
// for i = 1 to mc_crates_list do
34098: LD_ADDR_VAR 0 1
34102: PUSH
34103: DOUBLE
34104: LD_INT 1
34106: DEC
34107: ST_TO_ADDR
34108: LD_EXP 32
34112: PUSH
34113: FOR_TO
34114: IFFALSE 34145
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34116: LD_EXP 32
34120: PUSH
34121: LD_VAR 0 1
34125: ARRAY
34126: PPUSH
34127: LD_INT 5
34129: PPUSH
34130: LD_INT 50
34132: PPUSH
34133: LD_INT 700
34135: PPUSH
34136: LD_INT 20
34138: PPUSH
34139: CALL 24501 0 5
34143: GO 34113
34145: POP
34146: POP
// MC_Game ( ) ;
34147: CALL 34154 0 0
// end ;
34151: PPOPN 1
34153: END
// export function MC_Game ( ) ; var i , side , un ; begin
34154: LD_INT 0
34156: PPUSH
34157: PPUSH
34158: PPUSH
34159: PPUSH
// if not isTest then
34160: LD_EXP 1
34164: NOT
34165: IFFALSE 34185
// MC_Show ( [ #tick , tick ] ) else
34167: LD_STRING #tick
34169: PUSH
34170: LD_OWVAR 1
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PPUSH
34179: CALL 8585 0 1
34183: GO 34194
// MC_Show ( debug_string ) ;
34185: LD_EXP 2
34189: PPUSH
34190: CALL 8585 0 1
// for side = 1 to 8 do
34194: LD_ADDR_VAR 0 3
34198: PUSH
34199: DOUBLE
34200: LD_INT 1
34202: DEC
34203: ST_TO_ADDR
34204: LD_INT 8
34206: PUSH
34207: FOR_TO
34208: IFFALSE 36208
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34210: LD_EXP 39
34214: PUSH
34215: LD_VAR 0 3
34219: ARRAY
34220: PUSH
34221: LD_INT 0
34223: EQUAL
34224: PUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: EMPTY
34231: PPUSH
34232: CALL 11802 0 2
34236: PUSH
34237: LD_INT 0
34239: EQUAL
34240: OR
34241: IFFALSE 34245
// continue ;
34243: GO 34207
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34245: LD_VAR 0 3
34249: PPUSH
34250: LD_VAR 0 3
34254: PPUSH
34255: CALL 25022 0 1
34259: PPUSH
34260: CALL 36215 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34264: LD_EXP 71
34268: PUSH
34269: LD_VAR 0 3
34273: ARRAY
34274: PUSH
34275: LD_INT 1
34277: ARRAY
34278: PUSH
34279: LD_INT 0
34281: GREATER
34282: PUSH
34283: LD_EXP 69
34287: PUSH
34288: LD_VAR 0 3
34292: ARRAY
34293: PUSH
34294: LD_INT 1
34296: ARRAY
34297: PUSH
34298: LD_INT 0
34300: EQUAL
34301: AND
34302: PUSH
34303: LD_VAR 0 3
34307: PPUSH
34308: LD_INT 7
34310: PPUSH
34311: EMPTY
34312: PPUSH
34313: CALL 12370 0 3
34317: NOT
34318: AND
34319: IFFALSE 34356
// begin for i in MREG_Attackers [ side ] do
34321: LD_ADDR_VAR 0 2
34325: PUSH
34326: LD_EXP 71
34330: PUSH
34331: LD_VAR 0 3
34335: ARRAY
34336: PUSH
34337: FOR_IN
34338: IFFALSE 34354
// SetTag ( i , 7 ) ;
34340: LD_VAR 0 2
34344: PPUSH
34345: LD_INT 7
34347: PPUSH
34348: CALL_OW 109
34352: GO 34337
34354: POP
34355: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34356: LD_VAR 0 3
34360: PPUSH
34361: LD_INT 7
34363: PPUSH
34364: EMPTY
34365: PPUSH
34366: CALL 12370 0 3
34370: IFFALSE 34430
// begin if side = 1 then
34372: LD_VAR 0 3
34376: PUSH
34377: LD_INT 1
34379: EQUAL
34380: IFFALSE 34389
// RaiseSailEvent ( 101 ) ;
34382: LD_INT 101
34384: PPUSH
34385: CALL_OW 427
// if side = 4 then
34389: LD_VAR 0 3
34393: PUSH
34394: LD_INT 4
34396: EQUAL
34397: IFFALSE 34406
// RaiseSailEvent ( 102 ) ;
34399: LD_INT 102
34401: PPUSH
34402: CALL_OW 427
// MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34406: LD_VAR 0 3
34410: PPUSH
34411: LD_VAR 0 3
34415: PPUSH
34416: LD_INT 7
34418: PPUSH
34419: EMPTY
34420: PPUSH
34421: CALL 12370 0 3
34425: PPUSH
34426: CALL 8503 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34430: LD_VAR 0 3
34434: PPUSH
34435: CALL 18050 0 1
34439: PUSH
34440: LD_VAR 0 3
34444: PPUSH
34445: CALL 11706 0 1
34449: AND
34450: IFFALSE 34461
// MCL_Start ( side ) ;
34452: LD_VAR 0 3
34456: PPUSH
34457: CALL 18007 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34461: LD_ADDR_EXP 35
34465: PUSH
34466: LD_EXP 35
34470: PPUSH
34471: LD_VAR 0 3
34475: PPUSH
34476: LD_VAR 0 3
34480: PPUSH
34481: CALL 19307 0 1
34485: PPUSH
34486: CALL_OW 1
34490: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34491: LD_ADDR_EXP 47
34495: PUSH
34496: LD_EXP 47
34500: PPUSH
34501: LD_VAR 0 3
34505: PPUSH
34506: LD_VAR 0 3
34510: PPUSH
34511: CALL 11120 0 1
34515: PPUSH
34516: CALL_OW 1
34520: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34521: LD_VAR 0 3
34525: PPUSH
34526: LD_INT 21
34528: PUSH
34529: LD_INT 2
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PPUSH
34536: CALL 11667 0 2
34540: IFFALSE 34551
// MCV_CheckStatus ( side ) ;
34542: LD_VAR 0 3
34546: PPUSH
34547: CALL 27204 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34551: LD_VAR 0 3
34555: PPUSH
34556: LD_EXP 53
34560: PPUSH
34561: CALL 43015 0 2
34565: IFFALSE 34650
// begin for i = MREG_ToChangeClass downto 1 do
34567: LD_ADDR_VAR 0 2
34571: PUSH
34572: DOUBLE
34573: LD_EXP 53
34577: INC
34578: ST_TO_ADDR
34579: LD_INT 1
34581: PUSH
34582: FOR_DOWNTO
34583: IFFALSE 34648
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34585: LD_EXP 53
34589: PUSH
34590: LD_VAR 0 2
34594: ARRAY
34595: PUSH
34596: LD_INT 1
34598: ARRAY
34599: PUSH
34600: LD_VAR 0 3
34604: EQUAL
34605: IFFALSE 34646
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34607: LD_VAR 0 3
34611: PPUSH
34612: LD_EXP 53
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PUSH
34623: LD_INT 2
34625: ARRAY
34626: PPUSH
34627: LD_EXP 53
34631: PUSH
34632: LD_VAR 0 2
34636: ARRAY
34637: PUSH
34638: LD_INT 3
34640: ARRAY
34641: PPUSH
34642: CALL 16574 0 3
// end ; end ;
34646: GO 34582
34648: POP
34649: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34650: LD_INT 1
34652: PUSH
34653: LD_EXP 38
34657: PUSH
34658: LD_VAR 0 3
34662: ARRAY
34663: IN
34664: IFFALSE 34675
// begin MCN_TrainApe ( side ) ;
34666: LD_VAR 0 3
34670: PPUSH
34671: CALL 18960 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_INT 30
34682: PUSH
34683: LD_INT 3
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PPUSH
34690: CALL 11667 0 2
34694: IFFALSE 34868
// begin if MCF_Tag ( side , 10 , [ ] ) then
34696: LD_VAR 0 3
34700: PPUSH
34701: LD_INT 10
34703: PPUSH
34704: EMPTY
34705: PPUSH
34706: CALL 12370 0 3
34710: IFFALSE 34757
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34712: LD_VAR 0 3
34716: PPUSH
34717: LD_INT 10
34719: PPUSH
34720: EMPTY
34721: PPUSH
34722: CALL 12370 0 3
34726: PPUSH
34727: LD_VAR 0 3
34731: PPUSH
34732: LD_INT 30
34734: PUSH
34735: LD_INT 3
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PPUSH
34742: CALL 11667 0 2
34746: PUSH
34747: LD_INT 1
34749: ARRAY
34750: PPUSH
34751: CALL_OW 168
// end else
34755: GO 34868
// if MREG_ToConstruct [ side ] then
34757: LD_EXP 51
34761: PUSH
34762: LD_VAR 0 3
34766: ARRAY
34767: IFFALSE 34868
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34769: LD_VAR 0 3
34773: PPUSH
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11667 0 2
34793: PUSH
34794: LD_INT 1
34796: ARRAY
34797: PPUSH
34798: LD_EXP 51
34802: PUSH
34803: LD_VAR 0 3
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PUSH
34813: LD_EXP 51
34817: PUSH
34818: LD_VAR 0 3
34822: ARRAY
34823: PUSH
34824: LD_INT 2
34826: ARRAY
34827: PUSH
34828: LD_EXP 51
34832: PUSH
34833: LD_VAR 0 3
34837: ARRAY
34838: PUSH
34839: LD_INT 3
34841: ARRAY
34842: PUSH
34843: LD_EXP 51
34847: PUSH
34848: LD_VAR 0 3
34852: ARRAY
34853: PUSH
34854: LD_INT 4
34856: ARRAY
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: PPUSH
34864: CALL 25512 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34868: LD_VAR 0 3
34872: PPUSH
34873: LD_INT 30
34875: PUSH
34876: LD_INT 3
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PPUSH
34883: CALL 11667 0 2
34887: PUSH
34888: LD_VAR 0 3
34892: PPUSH
34893: LD_EXP 43
34897: PPUSH
34898: CALL 43015 0 2
34902: AND
34903: PUSH
34904: LD_INT 22
34906: PUSH
34907: LD_VAR 0 3
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 2
34918: PUSH
34919: LD_INT 30
34921: PUSH
34922: LD_INT 33
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 30
34931: PUSH
34932: LD_INT 32
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 35
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: LIST
34958: PPUSH
34959: CALL_OW 69
34963: AND
34964: IFFALSE 34975
// MCV_Turret ( side ) ;
34966: LD_VAR 0 3
34970: PPUSH
34971: CALL 25949 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34975: LD_EXP 42
34979: PUSH
34980: LD_VAR 0 3
34984: ARRAY
34985: PUSH
34986: LD_INT 1
34988: GREATER
34989: PUSH
34990: LD_VAR 0 3
34994: PPUSH
34995: CALL 25022 0 1
34999: PUSH
35000: LD_INT 0
35002: EQUAL
35003: AND
35004: IFFALSE 35166
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
35006: LD_EXP 42
35010: PUSH
35011: LD_VAR 0 3
35015: ARRAY
35016: PUSH
35017: LD_INT 1
35019: ARRAY
35020: PPUSH
35021: CALL_OW 353
35025: IFFALSE 35063
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
35027: LD_EXP 42
35031: PUSH
35032: LD_VAR 0 3
35036: ARRAY
35037: PUSH
35038: LD_INT 2
35040: ARRAY
35041: PPUSH
35042: LD_EXP 42
35046: PUSH
35047: LD_VAR 0 3
35051: ARRAY
35052: PUSH
35053: LD_INT 1
35055: ARRAY
35056: PPUSH
35057: CALL 32444 0 2
35061: GO 35166
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
35063: LD_VAR 0 3
35067: PPUSH
35068: LD_INT 30
35070: PUSH
35071: LD_INT 3
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PPUSH
35078: CALL 11667 0 2
35082: IFFALSE 35166
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
35084: LD_VAR 0 3
35088: PPUSH
35089: LD_INT 30
35091: PUSH
35092: LD_INT 3
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PPUSH
35099: CALL 11667 0 2
35103: PUSH
35104: LD_INT 1
35106: ARRAY
35107: PPUSH
35108: CALL_OW 461
35112: PUSH
35113: LD_INT 2
35115: EQUAL
35116: IFFALSE 35166
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35118: LD_EXP 42
35122: PUSH
35123: LD_VAR 0 3
35127: ARRAY
35128: PUSH
35129: LD_INT 2
35131: ARRAY
35132: PPUSH
35133: LD_INT 10
35135: PPUSH
35136: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35140: LD_ADDR_EXP 42
35144: PUSH
35145: LD_EXP 42
35149: PPUSH
35150: LD_VAR 0 3
35154: PPUSH
35155: LD_INT 0
35157: PUSH
35158: EMPTY
35159: LIST
35160: PPUSH
35161: CALL_OW 1
35165: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35166: LD_VAR 0 3
35170: PPUSH
35171: LD_INT 33
35173: PUSH
35174: LD_INT 2
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PPUSH
35181: CALL 11667 0 2
35185: IFFALSE 35225
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35187: LD_VAR 0 3
35191: PPUSH
35192: LD_VAR 0 3
35196: PPUSH
35197: LD_INT 33
35199: PUSH
35200: LD_INT 2
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PPUSH
35207: CALL 11667 0 2
35211: PUSH
35212: LD_INT 1
35214: ARRAY
35215: PPUSH
35216: CALL_OW 248
35220: PPUSH
35221: CALL 26503 0 2
// if MREG_ToRepair [ side ] then
35225: LD_EXP 47
35229: PUSH
35230: LD_VAR 0 3
35234: ARRAY
35235: IFFALSE 35248
// begin MCB_Repair ( side ) ;
35237: LD_VAR 0 3
35241: PPUSH
35242: CALL 11407 0 1
// end else
35246: GO 36161
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35248: LD_VAR 0 3
35252: PPUSH
35253: LD_EXP 49
35257: PPUSH
35258: CALL 43015 0 2
35262: PUSH
35263: LD_VAR 0 3
35267: PPUSH
35268: LD_EXP 40
35272: PPUSH
35273: CALL 43015 0 2
35277: AND
35278: IFFALSE 35486
// begin for i = 1 to MREG_ToUpLab do
35280: LD_ADDR_VAR 0 2
35284: PUSH
35285: DOUBLE
35286: LD_INT 1
35288: DEC
35289: ST_TO_ADDR
35290: LD_EXP 49
35294: PUSH
35295: FOR_TO
35296: IFFALSE 35482
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35298: LD_EXP 49
35302: PUSH
35303: LD_VAR 0 2
35307: ARRAY
35308: PUSH
35309: LD_INT 1
35311: ARRAY
35312: PUSH
35313: LD_VAR 0 3
35317: EQUAL
35318: IFFALSE 35480
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35320: LD_EXP 49
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: PUSH
35331: LD_INT 2
35333: ARRAY
35334: PUSH
35335: LD_EXP 49
35339: PUSH
35340: LD_VAR 0 2
35344: ARRAY
35345: PUSH
35346: LD_INT 3
35348: ARRAY
35349: AND
35350: IFFALSE 35478
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35352: LD_VAR 0 3
35356: PPUSH
35357: LD_EXP 49
35361: PUSH
35362: LD_VAR 0 2
35366: ARRAY
35367: PUSH
35368: LD_INT 2
35370: ARRAY
35371: PPUSH
35372: LD_EXP 49
35376: PUSH
35377: LD_VAR 0 2
35381: ARRAY
35382: PUSH
35383: LD_INT 3
35385: ARRAY
35386: PPUSH
35387: CALL 8931 0 3
35391: IFFALSE 35478
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35393: LD_ADDR_EXP 49
35397: PUSH
35398: LD_EXP 49
35402: PPUSH
35403: LD_VAR 0 3
35407: PPUSH
35408: LD_EXP 49
35412: PUSH
35413: LD_VAR 0 2
35417: ARRAY
35418: PUSH
35419: LD_INT 2
35421: ARRAY
35422: PPUSH
35423: LD_EXP 49
35427: PUSH
35428: LD_VAR 0 2
35432: ARRAY
35433: PUSH
35434: LD_INT 3
35436: ARRAY
35437: PPUSH
35438: CALL 42067 0 4
35442: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35443: LD_ADDR_EXP 40
35447: PUSH
35448: LD_EXP 40
35452: PPUSH
35453: LD_VAR 0 3
35457: PPUSH
35458: LD_EXP 40
35462: PUSH
35463: LD_INT 1
35465: ARRAY
35466: PUSH
35467: LD_INT 2
35469: ARRAY
35470: PPUSH
35471: EMPTY
35472: PPUSH
35473: CALL 42067 0 4
35477: ST_TO_ADDR
// end ; break ;
35478: GO 35482
// end ;
35480: GO 35295
35482: POP
35483: POP
// end else
35484: GO 36161
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35486: LD_VAR 0 3
35490: PPUSH
35491: LD_EXP 48
35495: PPUSH
35496: CALL 43015 0 2
35500: IFFALSE 35574
// begin for i = 1 to MREG_ToUpdate do
35502: LD_ADDR_VAR 0 2
35506: PUSH
35507: DOUBLE
35508: LD_INT 1
35510: DEC
35511: ST_TO_ADDR
35512: LD_EXP 48
35516: PUSH
35517: FOR_TO
35518: IFFALSE 35570
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35520: LD_EXP 48
35524: PUSH
35525: LD_VAR 0 2
35529: ARRAY
35530: PUSH
35531: LD_INT 1
35533: ARRAY
35534: PUSH
35535: LD_VAR 0 3
35539: EQUAL
35540: IFFALSE 35568
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35542: LD_VAR 0 3
35546: PPUSH
35547: LD_EXP 48
35551: PUSH
35552: LD_VAR 0 2
35556: ARRAY
35557: PUSH
35558: LD_INT 2
35560: ARRAY
35561: PPUSH
35562: CALL 8767 0 2
// break ;
35566: GO 35570
// end ;
35568: GO 35517
35570: POP
35571: POP
// end else
35572: GO 36161
// if MCF_Get ( side , [ f_constructed ] ) then
35574: LD_VAR 0 3
35578: PPUSH
35579: LD_INT 57
35581: PUSH
35582: EMPTY
35583: LIST
35584: PPUSH
35585: CALL 11667 0 2
35589: IFFALSE 35622
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35591: LD_VAR 0 3
35595: PPUSH
35596: LD_VAR 0 3
35600: PPUSH
35601: LD_INT 57
35603: PUSH
35604: EMPTY
35605: LIST
35606: PPUSH
35607: CALL 11667 0 2
35611: PUSH
35612: LD_INT 1
35614: ARRAY
35615: PPUSH
35616: CALL 11011 0 2
35620: GO 36161
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35622: LD_VAR 0 3
35626: PPUSH
35627: LD_EXP 46
35631: PPUSH
35632: CALL 43015 0 2
35636: PUSH
35637: LD_VAR 0 3
35641: PPUSH
35642: CALL_OW 345
35646: NOT
35647: AND
35648: PUSH
35649: LD_VAR 0 3
35653: PPUSH
35654: CALL 25022 0 1
35658: PUSH
35659: LD_INT 0
35661: EQUAL
35662: AND
35663: IFFALSE 36062
// begin for i = 1 to MREG_ToBuild do
35665: LD_ADDR_VAR 0 2
35669: PUSH
35670: DOUBLE
35671: LD_INT 1
35673: DEC
35674: ST_TO_ADDR
35675: LD_EXP 46
35679: PUSH
35680: FOR_TO
35681: IFFALSE 36058
// if MREG_ToBuild [ i ] [ 1 ] = side then
35683: LD_EXP 46
35687: PUSH
35688: LD_VAR 0 2
35692: ARRAY
35693: PUSH
35694: LD_INT 1
35696: ARRAY
35697: PUSH
35698: LD_VAR 0 3
35702: EQUAL
35703: IFFALSE 36056
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35705: LD_OWVAR 84
35709: PUSH
35710: LD_EXP 46
35714: PUSH
35715: LD_VAR 0 2
35719: ARRAY
35720: PUSH
35721: LD_INT 3
35723: ARRAY
35724: PUSH
35725: LD_INT 1
35727: ARRAY
35728: PPUSH
35729: LD_EXP 46
35733: PUSH
35734: LD_VAR 0 2
35738: ARRAY
35739: PUSH
35740: LD_INT 3
35742: ARRAY
35743: PUSH
35744: LD_INT 2
35746: ARRAY
35747: PPUSH
35748: CALL_OW 351
35752: AND
35753: IFFALSE 35797
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35755: LD_EXP 46
35759: PUSH
35760: LD_VAR 0 2
35764: ARRAY
35765: PUSH
35766: LD_INT 3
35768: ARRAY
35769: PUSH
35770: LD_INT 1
35772: ARRAY
35773: PPUSH
35774: LD_EXP 46
35778: PUSH
35779: LD_VAR 0 2
35783: ARRAY
35784: PUSH
35785: LD_INT 3
35787: ARRAY
35788: PUSH
35789: LD_INT 2
35791: ARRAY
35792: PPUSH
35793: CALL 22815 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35797: LD_EXP 46
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: PUSH
35808: LD_INT 2
35810: ARRAY
35811: PUSH
35812: LD_INT 0
35814: EQUAL
35815: IFFALSE 35885
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35817: LD_VAR 0 3
35821: PPUSH
35822: LD_EXP 46
35826: PUSH
35827: LD_VAR 0 2
35831: ARRAY
35832: PUSH
35833: LD_INT 3
35835: ARRAY
35836: PUSH
35837: LD_INT 1
35839: ARRAY
35840: PPUSH
35841: LD_EXP 46
35845: PUSH
35846: LD_VAR 0 2
35850: ARRAY
35851: PUSH
35852: LD_INT 3
35854: ARRAY
35855: PUSH
35856: LD_INT 2
35858: ARRAY
35859: PPUSH
35860: LD_EXP 46
35864: PUSH
35865: LD_VAR 0 2
35869: ARRAY
35870: PUSH
35871: LD_INT 3
35873: ARRAY
35874: PUSH
35875: LD_INT 3
35877: ARRAY
35878: PPUSH
35879: CALL 8603 0 4
35883: GO 36054
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35885: LD_EXP 46
35889: PUSH
35890: LD_VAR 0 2
35894: ARRAY
35895: PUSH
35896: LD_INT 2
35898: ARRAY
35899: PUSH
35900: LD_INT 6
35902: EQUAL
35903: IFFALSE 35973
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35905: LD_VAR 0 3
35909: PPUSH
35910: LD_EXP 46
35914: PUSH
35915: LD_VAR 0 2
35919: ARRAY
35920: PUSH
35921: LD_INT 3
35923: ARRAY
35924: PUSH
35925: LD_INT 1
35927: ARRAY
35928: PPUSH
35929: LD_EXP 46
35933: PUSH
35934: LD_VAR 0 2
35938: ARRAY
35939: PUSH
35940: LD_INT 3
35942: ARRAY
35943: PUSH
35944: LD_INT 2
35946: ARRAY
35947: PPUSH
35948: LD_EXP 46
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PUSH
35959: LD_INT 3
35961: ARRAY
35962: PUSH
35963: LD_INT 3
35965: ARRAY
35966: PPUSH
35967: CALL 8732 0 4
35971: GO 36054
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35973: LD_VAR 0 3
35977: PPUSH
35978: LD_EXP 46
35982: PUSH
35983: LD_VAR 0 2
35987: ARRAY
35988: PUSH
35989: LD_INT 2
35991: ARRAY
35992: PPUSH
35993: LD_EXP 46
35997: PUSH
35998: LD_VAR 0 2
36002: ARRAY
36003: PUSH
36004: LD_INT 3
36006: ARRAY
36007: PUSH
36008: LD_INT 1
36010: ARRAY
36011: PPUSH
36012: LD_EXP 46
36016: PUSH
36017: LD_VAR 0 2
36021: ARRAY
36022: PUSH
36023: LD_INT 3
36025: ARRAY
36026: PUSH
36027: LD_INT 2
36029: ARRAY
36030: PPUSH
36031: LD_EXP 46
36035: PUSH
36036: LD_VAR 0 2
36040: ARRAY
36041: PUSH
36042: LD_INT 3
36044: ARRAY
36045: PUSH
36046: LD_INT 3
36048: ARRAY
36049: PPUSH
36050: CALL 10236 0 5
// break ;
36054: GO 36058
// end ;
36056: GO 35680
36058: POP
36059: POP
// end else
36060: GO 36161
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
36062: LD_VAR 0 3
36066: PPUSH
36067: LD_EXP 52
36071: PPUSH
36072: CALL 43015 0 2
36076: PUSH
36077: LD_VAR 0 3
36081: PPUSH
36082: CALL 25022 0 1
36086: PUSH
36087: LD_INT 0
36089: EQUAL
36090: AND
36091: IFFALSE 36161
// begin for i = 1 to MREG_ToDismantle do
36093: LD_ADDR_VAR 0 2
36097: PUSH
36098: DOUBLE
36099: LD_INT 1
36101: DEC
36102: ST_TO_ADDR
36103: LD_EXP 52
36107: PUSH
36108: FOR_TO
36109: IFFALSE 36159
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36111: LD_EXP 52
36115: PUSH
36116: LD_VAR 0 2
36120: ARRAY
36121: PUSH
36122: LD_INT 1
36124: ARRAY
36125: PUSH
36126: LD_VAR 0 3
36130: EQUAL
36131: IFFALSE 36157
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36133: LD_VAR 0 3
36137: PPUSH
36138: LD_EXP 52
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_INT 2
36151: ARRAY
36152: PPUSH
36153: CALL 10902 0 2
// end ;
36157: GO 36108
36159: POP
36160: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36161: LD_VAR 0 3
36165: PPUSH
36166: LD_INT 30
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PPUSH
36176: CALL 11667 0 2
36180: PUSH
36181: LD_VAR 0 3
36185: PPUSH
36186: CALL 25022 0 1
36190: PUSH
36191: LD_INT 0
36193: EQUAL
36194: AND
36195: IFFALSE 36206
// MCT_CollectCrates ( side ) ;
36197: LD_VAR 0 3
36201: PPUSH
36202: CALL 23961 0 1
// end ;
36206: GO 34207
36208: POP
36209: POP
// end ;
36210: LD_VAR 0 1
36214: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36215: LD_INT 0
36217: PPUSH
36218: PPUSH
36219: PPUSH
36220: PPUSH
36221: PPUSH
36222: PPUSH
36223: PPUSH
36224: PPUSH
36225: PPUSH
36226: PPUSH
36227: PPUSH
36228: PPUSH
36229: PPUSH
36230: PPUSH
36231: PPUSH
// all := MCF_All ( side , [ ] ) ;
36232: LD_ADDR_VAR 0 17
36236: PUSH
36237: LD_VAR 0 1
36241: PPUSH
36242: EMPTY
36243: PPUSH
36244: CALL 11802 0 2
36248: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36249: LD_ADDR_VAR 0 13
36253: PUSH
36254: LD_VAR 0 1
36258: PPUSH
36259: LD_INT 1
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL 11750 0 3
36268: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36269: LD_ADDR_VAR 0 14
36273: PUSH
36274: LD_VAR 0 1
36278: PPUSH
36279: LD_INT 2
36281: PPUSH
36282: EMPTY
36283: PPUSH
36284: CALL 11750 0 3
36288: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36289: LD_ADDR_VAR 0 15
36293: PUSH
36294: LD_VAR 0 1
36298: PPUSH
36299: LD_INT 3
36301: PPUSH
36302: EMPTY
36303: PPUSH
36304: CALL 11750 0 3
36308: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36309: LD_ADDR_VAR 0 16
36313: PUSH
36314: LD_VAR 0 1
36318: PPUSH
36319: LD_INT 4
36321: PPUSH
36322: EMPTY
36323: PPUSH
36324: CALL 11750 0 3
36328: ST_TO_ADDR
// if mech then
36329: LD_VAR 0 15
36333: IFFALSE 36350
// mech := MCF_SortListDesc ( mech ) ;
36335: LD_ADDR_VAR 0 15
36339: PUSH
36340: LD_VAR 0 15
36344: PPUSH
36345: CALL 12916 0 1
36349: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36350: LD_EXP 56
36354: PUSH
36355: LD_VAR 0 1
36359: ARRAY
36360: PUSH
36361: LD_STRING 
36363: EQUAL
36364: NOT
36365: IFFALSE 36421
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36367: LD_EXP 56
36371: PUSH
36372: LD_VAR 0 1
36376: ARRAY
36377: PUSH
36378: LD_INT 1
36380: ARRAY
36381: PPUSH
36382: CALL_OW 257
36386: PUSH
36387: LD_INT 1
36389: EQUAL
36390: IFFALSE 36419
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36392: LD_VAR 0 1
36396: PPUSH
36397: LD_STRING ToArm
36399: PPUSH
36400: LD_EXP 56
36404: PUSH
36405: LD_VAR 0 1
36409: ARRAY
36410: PUSH
36411: LD_INT 1
36413: ARRAY
36414: PPUSH
36415: CALL 14546 0 3
// end else
36419: GO 36447
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36421: LD_ADDR_EXP 56
36425: PUSH
36426: LD_EXP 56
36430: PPUSH
36431: LD_VAR 0 1
36435: PPUSH
36436: LD_INT 1
36438: PPUSH
36439: LD_INT 0
36441: PPUSH
36442: CALL 31146 0 4
36446: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36447: LD_EXP 57
36451: PUSH
36452: LD_VAR 0 1
36456: ARRAY
36457: PUSH
36458: LD_STRING 
36460: EQUAL
36461: NOT
36462: IFFALSE 36518
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36464: LD_EXP 57
36468: PUSH
36469: LD_VAR 0 1
36473: ARRAY
36474: PUSH
36475: LD_INT 1
36477: ARRAY
36478: PPUSH
36479: CALL_OW 257
36483: PUSH
36484: LD_INT 2
36486: EQUAL
36487: IFFALSE 36516
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36489: LD_VAR 0 1
36493: PPUSH
36494: LD_STRING ToDep
36496: PPUSH
36497: LD_EXP 57
36501: PUSH
36502: LD_VAR 0 1
36506: ARRAY
36507: PUSH
36508: LD_INT 1
36510: ARRAY
36511: PPUSH
36512: CALL 14546 0 3
// end else
36516: GO 36544
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36518: LD_ADDR_EXP 57
36522: PUSH
36523: LD_EXP 57
36527: PPUSH
36528: LD_VAR 0 1
36532: PPUSH
36533: LD_INT 1
36535: PPUSH
36536: LD_INT 0
36538: PPUSH
36539: CALL 31146 0 4
36543: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36544: LD_EXP 55
36548: PUSH
36549: LD_VAR 0 1
36553: ARRAY
36554: PUSH
36555: LD_STRING 
36557: EQUAL
36558: NOT
36559: IFFALSE 36615
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36561: LD_EXP 55
36565: PUSH
36566: LD_VAR 0 1
36570: ARRAY
36571: PUSH
36572: LD_INT 1
36574: ARRAY
36575: PPUSH
36576: CALL_OW 257
36580: PUSH
36581: LD_INT 3
36583: EQUAL
36584: IFFALSE 36613
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36586: LD_VAR 0 1
36590: PPUSH
36591: LD_STRING ToFac
36593: PPUSH
36594: LD_EXP 55
36598: PUSH
36599: LD_VAR 0 1
36603: ARRAY
36604: PUSH
36605: LD_INT 1
36607: ARRAY
36608: PPUSH
36609: CALL 14546 0 3
// end else
36613: GO 36641
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36615: LD_ADDR_EXP 55
36619: PUSH
36620: LD_EXP 55
36624: PPUSH
36625: LD_VAR 0 1
36629: PPUSH
36630: LD_INT 1
36632: PPUSH
36633: LD_INT 0
36635: PPUSH
36636: CALL 31146 0 4
36640: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36641: LD_EXP 54
36645: PUSH
36646: LD_VAR 0 1
36650: ARRAY
36651: PUSH
36652: LD_STRING 
36654: EQUAL
36655: NOT
36656: IFFALSE 36712
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36658: LD_EXP 54
36662: PUSH
36663: LD_VAR 0 1
36667: ARRAY
36668: PUSH
36669: LD_INT 1
36671: ARRAY
36672: PPUSH
36673: CALL_OW 257
36677: PUSH
36678: LD_INT 4
36680: EQUAL
36681: IFFALSE 36710
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36683: LD_VAR 0 1
36687: PPUSH
36688: LD_STRING ToLab
36690: PPUSH
36691: LD_EXP 54
36695: PUSH
36696: LD_VAR 0 1
36700: ARRAY
36701: PUSH
36702: LD_INT 1
36704: ARRAY
36705: PPUSH
36706: CALL 14546 0 3
// end else
36710: GO 36738
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36712: LD_ADDR_EXP 54
36716: PUSH
36717: LD_EXP 54
36721: PPUSH
36722: LD_VAR 0 1
36726: PPUSH
36727: LD_INT 1
36729: PPUSH
36730: LD_INT 0
36732: PPUSH
36733: CALL 31146 0 4
36737: ST_TO_ADDR
// if mode = 0 then
36738: LD_VAR 0 2
36742: PUSH
36743: LD_INT 0
36745: EQUAL
36746: IFFALSE 38584
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36748: LD_VAR 0 1
36752: PPUSH
36753: LD_INT 30
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PPUSH
36763: CALL 11667 0 2
36767: PUSH
36768: LD_VAR 0 1
36772: PPUSH
36773: LD_INT 21
36775: PUSH
36776: LD_INT 3
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PPUSH
36783: CALL 11667 0 2
36787: PUSH
36788: LD_INT 1
36790: EQUAL
36791: AND
36792: IFFALSE 36857
// begin if all then
36794: LD_VAR 0 17
36798: IFFALSE 36855
// for i in ( all diff eng ) do
36800: LD_ADDR_VAR 0 4
36804: PUSH
36805: LD_VAR 0 17
36809: PUSH
36810: LD_VAR 0 14
36814: DIFF
36815: PUSH
36816: FOR_IN
36817: IFFALSE 36853
// if GetTag ( i ) = 0 then
36819: LD_VAR 0 4
36823: PPUSH
36824: CALL_OW 110
36828: PUSH
36829: LD_INT 0
36831: EQUAL
36832: IFFALSE 36851
// MCH_ChangeClass ( side , i , 2 ) ;
36834: LD_VAR 0 1
36838: PPUSH
36839: LD_VAR 0 4
36843: PPUSH
36844: LD_INT 2
36846: PPUSH
36847: CALL 16574 0 3
36851: GO 36816
36853: POP
36854: POP
// end else
36855: GO 37176
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36857: LD_VAR 0 13
36861: PUSH
36862: LD_EXP 56
36866: PUSH
36867: LD_VAR 0 1
36871: ARRAY
36872: PLUS
36873: PUSH
36874: LD_INT 22
36876: PUSH
36877: LD_VAR 0 1
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 30
36888: PUSH
36889: LD_INT 32
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PPUSH
36900: CALL_OW 69
36904: LESS
36905: IFFALSE 36930
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36907: LD_VAR 0 1
36911: PPUSH
36912: LD_VAR 0 14
36916: PUSH
36917: LD_INT 1
36919: ARRAY
36920: PPUSH
36921: LD_INT 1
36923: PPUSH
36924: CALL 16574 0 3
// end else
36928: GO 37176
// if sci < 6 and MCF_Lab ( side ) then
36930: LD_VAR 0 16
36934: PUSH
36935: LD_INT 6
36937: LESS
36938: PUSH
36939: LD_VAR 0 1
36943: PPUSH
36944: CALL 11706 0 1
36948: AND
36949: IFFALSE 37054
// begin if MREG_ToBunker [ side ] then
36951: LD_EXP 68
36955: PUSH
36956: LD_VAR 0 1
36960: ARRAY
36961: IFFALSE 36987
// tmp := sol diff MREG_ToBunker [ side ] else
36963: LD_ADDR_VAR 0 12
36967: PUSH
36968: LD_VAR 0 13
36972: PUSH
36973: LD_EXP 68
36977: PUSH
36978: LD_VAR 0 1
36982: ARRAY
36983: DIFF
36984: ST_TO_ADDR
36985: GO 36997
// tmp := sol ;
36987: LD_ADDR_VAR 0 12
36991: PUSH
36992: LD_VAR 0 13
36996: ST_TO_ADDR
// if tmp then
36997: LD_VAR 0 12
37001: IFFALSE 37052
// for i in tmp do
37003: LD_ADDR_VAR 0 4
37007: PUSH
37008: LD_VAR 0 12
37012: PUSH
37013: FOR_IN
37014: IFFALSE 37050
// if GetTag ( i ) = 0 then
37016: LD_VAR 0 4
37020: PPUSH
37021: CALL_OW 110
37025: PUSH
37026: LD_INT 0
37028: EQUAL
37029: IFFALSE 37048
// MCH_ChangeClass ( side , i , 4 ) ;
37031: LD_VAR 0 1
37035: PPUSH
37036: LD_VAR 0 4
37040: PPUSH
37041: LD_INT 4
37043: PPUSH
37044: CALL 16574 0 3
37048: GO 37013
37050: POP
37051: POP
// end else
37052: GO 37176
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
37054: LD_VAR 0 1
37058: PPUSH
37059: LD_INT 30
37061: PUSH
37062: LD_INT 1
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PPUSH
37069: CALL 11667 0 2
37073: IFFALSE 37176
// begin if MREG_ToBunker [ side ] then
37075: LD_EXP 68
37079: PUSH
37080: LD_VAR 0 1
37084: ARRAY
37085: IFFALSE 37111
// tmp := sol diff MREG_ToBunker [ side ] else
37087: LD_ADDR_VAR 0 12
37091: PUSH
37092: LD_VAR 0 13
37096: PUSH
37097: LD_EXP 68
37101: PUSH
37102: LD_VAR 0 1
37106: ARRAY
37107: DIFF
37108: ST_TO_ADDR
37109: GO 37121
// tmp := sol ;
37111: LD_ADDR_VAR 0 12
37115: PUSH
37116: LD_VAR 0 13
37120: ST_TO_ADDR
// if tmp then
37121: LD_VAR 0 12
37125: IFFALSE 37176
// for i in tmp do
37127: LD_ADDR_VAR 0 4
37131: PUSH
37132: LD_VAR 0 12
37136: PUSH
37137: FOR_IN
37138: IFFALSE 37174
// if GetTag ( i ) = 0 then
37140: LD_VAR 0 4
37144: PPUSH
37145: CALL_OW 110
37149: PUSH
37150: LD_INT 0
37152: EQUAL
37153: IFFALSE 37172
// MCH_ChangeClass ( side , i , 2 ) ;
37155: LD_VAR 0 1
37159: PPUSH
37160: LD_VAR 0 4
37164: PPUSH
37165: LD_INT 2
37167: PPUSH
37168: CALL 16574 0 3
37172: GO 37137
37174: POP
37175: POP
// end ; if MCF_Lab ( side ) then
37176: LD_VAR 0 1
37180: PPUSH
37181: CALL 11706 0 1
37185: IFFALSE 37725
// begin if MCL_GetTechList ( side ) then
37187: LD_VAR 0 1
37191: PPUSH
37192: CALL 18050 0 1
37196: IFFALSE 37322
// begin if MREG_ToLab [ side ] then
37198: LD_EXP 54
37202: PUSH
37203: LD_VAR 0 1
37207: ARRAY
37208: IFFALSE 37228
// k := MREG_ToLab [ side ] else
37210: LD_ADDR_VAR 0 8
37214: PUSH
37215: LD_EXP 54
37219: PUSH
37220: LD_VAR 0 1
37224: ARRAY
37225: ST_TO_ADDR
37226: GO 37236
// k := 0 ;
37228: LD_ADDR_VAR 0 8
37232: PUSH
37233: LD_INT 0
37235: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37236: LD_VAR 0 16
37240: PUSH
37241: LD_VAR 0 8
37245: PLUS
37246: PUSH
37247: LD_INT 6
37249: LESSEQUAL
37250: PUSH
37251: LD_VAR 0 17
37255: PUSH
37256: LD_INT 6
37258: GREATER
37259: AND
37260: IFFALSE 37276
// MCH_TrainScientist ( side , 1 ) else
37262: LD_VAR 0 1
37266: PPUSH
37267: LD_INT 1
37269: PPUSH
37270: CALL 16126 0 2
37274: GO 37320
// if all < 6 then
37276: LD_VAR 0 17
37280: PUSH
37281: LD_INT 6
37283: LESS
37284: IFFALSE 37320
// if sci + k < all / 2 then
37286: LD_VAR 0 16
37290: PUSH
37291: LD_VAR 0 8
37295: PLUS
37296: PUSH
37297: LD_VAR 0 17
37301: PUSH
37302: LD_INT 2
37304: DIVREAL
37305: LESS
37306: IFFALSE 37320
// MCH_TrainScientist ( side , 1 ) ;
37308: LD_VAR 0 1
37312: PPUSH
37313: LD_INT 1
37315: PPUSH
37316: CALL 16126 0 2
// end else
37320: GO 37398
// begin if sci > 2 then
37322: LD_VAR 0 16
37326: PUSH
37327: LD_INT 2
37329: GREATER
37330: IFFALSE 37398
// for i = sci downto 2 do
37332: LD_ADDR_VAR 0 4
37336: PUSH
37337: DOUBLE
37338: LD_VAR 0 16
37342: INC
37343: ST_TO_ADDR
37344: LD_INT 2
37346: PUSH
37347: FOR_DOWNTO
37348: IFFALSE 37396
// if GetTag ( sci [ i ] ) = 0 then
37350: LD_VAR 0 16
37354: PUSH
37355: LD_VAR 0 4
37359: ARRAY
37360: PPUSH
37361: CALL_OW 110
37365: PUSH
37366: LD_INT 0
37368: EQUAL
37369: IFFALSE 37394
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37371: LD_VAR 0 1
37375: PPUSH
37376: LD_VAR 0 16
37380: PUSH
37381: LD_VAR 0 4
37385: ARRAY
37386: PPUSH
37387: LD_INT 2
37389: PPUSH
37390: CALL 16574 0 3
37394: GO 37347
37396: POP
37397: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37398: LD_VAR 0 1
37402: PPUSH
37403: CALL 18050 0 1
37407: PUSH
37408: LD_VAR 0 1
37412: PPUSH
37413: CALL 11706 0 1
37417: AND
37418: PUSH
37419: LD_EXP 35
37423: PUSH
37424: LD_VAR 0 1
37428: ARRAY
37429: NOT
37430: AND
37431: IFFALSE 37725
// begin for j = 1 to MCF_Lab ( side ) do
37433: LD_ADDR_VAR 0 5
37437: PUSH
37438: DOUBLE
37439: LD_INT 1
37441: DEC
37442: ST_TO_ADDR
37443: LD_VAR 0 1
37447: PPUSH
37448: CALL 11706 0 1
37452: PUSH
37453: FOR_TO
37454: IFFALSE 37514
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37456: LD_VAR 0 1
37460: PPUSH
37461: CALL 11706 0 1
37465: PUSH
37466: LD_VAR 0 5
37470: ARRAY
37471: PPUSH
37472: CALL_OW 461
37476: PUSH
37477: LD_INT 3
37479: PUSH
37480: LD_INT 6
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: IN
37487: IFFALSE 37512
// begin b := MCF_Lab ( side ) [ j ] ;
37489: LD_ADDR_VAR 0 11
37493: PUSH
37494: LD_VAR 0 1
37498: PPUSH
37499: CALL 11706 0 1
37503: PUSH
37504: LD_VAR 0 5
37508: ARRAY
37509: ST_TO_ADDR
// break ;
37510: GO 37514
// end ;
37512: GO 37453
37514: POP
37515: POP
// if MCF_Class ( side , 4 , [ ] ) then
37516: LD_VAR 0 1
37520: PPUSH
37521: LD_INT 4
37523: PPUSH
37524: EMPTY
37525: PPUSH
37526: CALL 11750 0 3
37530: IFFALSE 37725
// for j in MCF_Class ( side , 4 , [ ] ) do
37532: LD_ADDR_VAR 0 5
37536: PUSH
37537: LD_VAR 0 1
37541: PPUSH
37542: LD_INT 4
37544: PPUSH
37545: EMPTY
37546: PPUSH
37547: CALL 11750 0 3
37551: PUSH
37552: FOR_IN
37553: IFFALSE 37723
// begin if GetTag ( j ) = 0 then
37555: LD_VAR 0 5
37559: PPUSH
37560: CALL_OW 110
37564: PUSH
37565: LD_INT 0
37567: EQUAL
37568: IFFALSE 37659
// begin if IsInUnit ( j ) and b then
37570: LD_VAR 0 5
37574: PPUSH
37575: CALL_OW 310
37579: PUSH
37580: LD_VAR 0 11
37584: AND
37585: IFFALSE 37633
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 310
37596: PPUSH
37597: CALL_OW 461
37601: PUSH
37602: LD_INT 2
37604: EQUAL
37605: PUSH
37606: LD_VAR 0 5
37610: PPUSH
37611: CALL_OW 310
37615: PUSH
37616: LD_VAR 0 11
37620: NONEQUAL
37621: AND
37622: IFFALSE 37633
// ComExitBuilding ( j ) ;
37624: LD_VAR 0 5
37628: PPUSH
37629: CALL_OW 122
// if not IsInUnit ( j ) then
37633: LD_VAR 0 5
37637: PPUSH
37638: CALL_OW 310
37642: NOT
37643: IFFALSE 37659
// ComEnterUnit ( j , b ) ;
37645: LD_VAR 0 5
37649: PPUSH
37650: LD_VAR 0 11
37654: PPUSH
37655: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37659: LD_INT 1
37661: PPUSH
37662: LD_VAR 0 5
37666: PPUSH
37667: CALL_OW 255
37671: PPUSH
37672: CALL_OW 321
37676: PUSH
37677: LD_INT 2
37679: EQUAL
37680: PUSH
37681: LD_VAR 0 5
37685: PPUSH
37686: CALL_OW 255
37690: PPUSH
37691: CALL 25022 0 1
37695: PUSH
37696: LD_INT 0
37698: EQUAL
37699: AND
37700: IFFALSE 37721
// MCN_Tame ( GetSide ( j ) , j ) ;
37702: LD_VAR 0 5
37706: PPUSH
37707: CALL_OW 255
37711: PPUSH
37712: LD_VAR 0 5
37716: PPUSH
37717: CALL 18569 0 2
// end ;
37721: GO 37552
37723: POP
37724: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37725: LD_VAR 0 1
37729: PPUSH
37730: LD_INT 30
37732: PUSH
37733: LD_INT 3
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PPUSH
37740: CALL 11667 0 2
37744: IFFALSE 38003
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37746: LD_ADDR_VAR 0 11
37750: PUSH
37751: LD_VAR 0 1
37755: PPUSH
37756: LD_INT 30
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PPUSH
37766: CALL 11667 0 2
37770: PUSH
37771: LD_INT 1
37773: ARRAY
37774: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37775: LD_ADDR_VAR 0 12
37779: PUSH
37780: LD_VAR 0 1
37784: PPUSH
37785: LD_INT 0
37787: PPUSH
37788: LD_INT 25
37790: PUSH
37791: LD_INT 3
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PPUSH
37798: CALL 12370 0 3
37802: ST_TO_ADDR
// for i = 1 to tmp do
37803: LD_ADDR_VAR 0 4
37807: PUSH
37808: DOUBLE
37809: LD_INT 1
37811: DEC
37812: ST_TO_ADDR
37813: LD_VAR 0 12
37817: PUSH
37818: FOR_TO
37819: IFFALSE 37879
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37821: LD_VAR 0 12
37825: PUSH
37826: LD_VAR 0 4
37830: ARRAY
37831: PPUSH
37832: CALL_OW 310
37836: NOT
37837: PUSH
37838: LD_VAR 0 12
37842: PUSH
37843: LD_VAR 0 4
37847: ARRAY
37848: PPUSH
37849: CALL_OW 314
37853: NOT
37854: AND
37855: IFFALSE 37877
// ComEnterUnit ( tmp [ i ] , b ) ;
37857: LD_VAR 0 12
37861: PUSH
37862: LD_VAR 0 4
37866: ARRAY
37867: PPUSH
37868: LD_VAR 0 11
37872: PPUSH
37873: CALL_OW 120
37877: GO 37818
37879: POP
37880: POP
// if MREG_ToFac [ side ] then
37881: LD_EXP 55
37885: PUSH
37886: LD_VAR 0 1
37890: ARRAY
37891: IFFALSE 37911
// k := MREG_ToFac [ side ] else
37893: LD_ADDR_VAR 0 8
37897: PUSH
37898: LD_EXP 55
37902: PUSH
37903: LD_VAR 0 1
37907: ARRAY
37908: ST_TO_ADDR
37909: GO 37919
// k := 0 ;
37911: LD_ADDR_VAR 0 8
37915: PUSH
37916: LD_INT 0
37918: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37919: LD_VAR 0 15
37923: PUSH
37924: LD_VAR 0 8
37928: PLUS
37929: PUSH
37930: LD_INT 6
37932: LESSEQUAL
37933: PUSH
37934: LD_VAR 0 17
37938: PUSH
37939: LD_INT 6
37941: GREATER
37942: AND
37943: IFFALSE 37959
// MCH_TrainMechanic ( side , 1 ) else
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 1
37952: PPUSH
37953: CALL 15868 0 2
37957: GO 38003
// if all < 6 then
37959: LD_VAR 0 17
37963: PUSH
37964: LD_INT 6
37966: LESS
37967: IFFALSE 38003
// if mech + k < all / 2 then
37969: LD_VAR 0 15
37973: PUSH
37974: LD_VAR 0 8
37978: PLUS
37979: PUSH
37980: LD_VAR 0 17
37984: PUSH
37985: LD_INT 2
37987: DIVREAL
37988: LESS
37989: IFFALSE 38003
// MCH_TrainMechanic ( side , 1 ) ;
37991: LD_VAR 0 1
37995: PPUSH
37996: LD_INT 1
37998: PPUSH
37999: CALL 15868 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
38003: LD_ADDR_VAR 0 10
38007: PUSH
38008: LD_VAR 0 1
38012: PPUSH
38013: LD_INT 30
38015: PUSH
38016: LD_INT 36
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PPUSH
38023: CALL 11667 0 2
38027: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
38028: LD_VAR 0 10
38032: PUSH
38033: LD_VAR 0 15
38037: AND
38038: PUSH
38039: LD_VAR 0 1
38043: PPUSH
38044: LD_INT 3
38046: PPUSH
38047: EMPTY
38048: PPUSH
38049: CALL 11750 0 3
38053: AND
38054: IFFALSE 38212
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
38056: LD_VAR 0 1
38060: PPUSH
38061: LD_INT 9
38063: PPUSH
38064: EMPTY
38065: PPUSH
38066: CALL 12370 0 3
38070: PUSH
38071: LD_INT 3
38073: LESS
38074: IFFALSE 38212
// begin if mech < 3 then
38076: LD_VAR 0 15
38080: PUSH
38081: LD_INT 3
38083: LESS
38084: IFFALSE 38098
// k := mech else
38086: LD_ADDR_VAR 0 8
38090: PUSH
38091: LD_VAR 0 15
38095: ST_TO_ADDR
38096: GO 38106
// k := 3 ;
38098: LD_ADDR_VAR 0 8
38102: PUSH
38103: LD_INT 3
38105: ST_TO_ADDR
// for j = 1 to k do
38106: LD_ADDR_VAR 0 5
38110: PUSH
38111: DOUBLE
38112: LD_INT 1
38114: DEC
38115: ST_TO_ADDR
38116: LD_VAR 0 8
38120: PUSH
38121: FOR_TO
38122: IFFALSE 38180
// if GetClass ( mech [ j ] ) = 3 then
38124: LD_VAR 0 15
38128: PUSH
38129: LD_VAR 0 5
38133: ARRAY
38134: PPUSH
38135: CALL_OW 257
38139: PUSH
38140: LD_INT 3
38142: EQUAL
38143: IFFALSE 38178
// begin SetTag ( mech [ j ] , 9 ) ;
38145: LD_VAR 0 15
38149: PUSH
38150: LD_VAR 0 5
38154: ARRAY
38155: PPUSH
38156: LD_INT 9
38158: PPUSH
38159: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38163: LD_VAR 0 15
38167: PUSH
38168: LD_VAR 0 5
38172: ARRAY
38173: PPUSH
38174: CALL_OW 122
// end ;
38178: GO 38121
38180: POP
38181: POP
// if mech < 6 + k then
38182: LD_VAR 0 15
38186: PUSH
38187: LD_INT 6
38189: PUSH
38190: LD_VAR 0 8
38194: PLUS
38195: LESS
38196: IFFALSE 38212
// MCH_TrainMechanic ( side , k ) ;
38198: LD_VAR 0 1
38202: PPUSH
38203: LD_VAR 0 8
38207: PPUSH
38208: CALL 15868 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38212: LD_VAR 0 1
38216: PPUSH
38217: LD_INT 9
38219: PPUSH
38220: EMPTY
38221: PPUSH
38222: CALL 12370 0 3
38226: IFFALSE 38317
// for j in MCF_Tag ( side , 9 , [ ] ) do
38228: LD_ADDR_VAR 0 5
38232: PUSH
38233: LD_VAR 0 1
38237: PPUSH
38238: LD_INT 9
38240: PPUSH
38241: EMPTY
38242: PPUSH
38243: CALL 12370 0 3
38247: PUSH
38248: FOR_IN
38249: IFFALSE 38315
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38251: LD_VAR 0 5
38255: PPUSH
38256: CALL_OW 310
38260: NOT
38261: PUSH
38262: LD_VAR 0 5
38266: PPUSH
38267: CALL 98203 0 1
38271: NOT
38272: AND
38273: IFFALSE 38313
// if ct then
38275: LD_VAR 0 10
38279: IFFALSE 38301
// ComEnterUnit ( j , ct [ 1 ] ) else
38281: LD_VAR 0 5
38285: PPUSH
38286: LD_VAR 0 10
38290: PUSH
38291: LD_INT 1
38293: ARRAY
38294: PPUSH
38295: CALL_OW 120
38299: GO 38313
// SetTag ( j , 0 ) ;
38301: LD_VAR 0 5
38305: PPUSH
38306: LD_INT 0
38308: PPUSH
38309: CALL_OW 109
38313: GO 38248
38315: POP
38316: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38317: LD_INT 1
38319: PPUSH
38320: LD_VAR 0 1
38324: PPUSH
38325: CALL_OW 321
38329: PUSH
38330: LD_INT 2
38332: EQUAL
38333: PUSH
38334: LD_EXP 35
38338: PUSH
38339: LD_VAR 0 1
38343: ARRAY
38344: NOT
38345: AND
38346: PUSH
38347: LD_VAR 0 1
38351: PPUSH
38352: LD_INT 4
38354: PPUSH
38355: EMPTY
38356: PPUSH
38357: CALL 11750 0 3
38361: AND
38362: IFFALSE 38410
// for j in MCF_Class ( side , 4 , [ ] ) do
38364: LD_ADDR_VAR 0 5
38368: PUSH
38369: LD_VAR 0 1
38373: PPUSH
38374: LD_INT 4
38376: PPUSH
38377: EMPTY
38378: PPUSH
38379: CALL 11750 0 3
38383: PUSH
38384: FOR_IN
38385: IFFALSE 38408
// MCN_Tame ( GetSide ( j ) , j ) ;
38387: LD_VAR 0 5
38391: PPUSH
38392: CALL_OW 255
38396: PPUSH
38397: LD_VAR 0 5
38401: PPUSH
38402: CALL 18569 0 2
38406: GO 38384
38408: POP
38409: POP
// if MREG_DefVeh [ side ] then
38410: LD_EXP 67
38414: PUSH
38415: LD_VAR 0 1
38419: ARRAY
38420: IFFALSE 38584
// begin for i in MREG_DefVeh [ side ] do
38422: LD_ADDR_VAR 0 4
38426: PUSH
38427: LD_EXP 67
38431: PUSH
38432: LD_VAR 0 1
38436: ARRAY
38437: PUSH
38438: FOR_IN
38439: IFFALSE 38492
// begin SetTag ( i , 0 ) ;
38441: LD_VAR 0 4
38445: PPUSH
38446: LD_INT 0
38448: PPUSH
38449: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38453: LD_VAR 0 4
38457: PPUSH
38458: LD_EXP 64
38462: PUSH
38463: LD_VAR 0 1
38467: ARRAY
38468: PPUSH
38469: CALL_OW 308
38473: NOT
38474: IFFALSE 38490
// MCV_Parking ( side , i ) ;
38476: LD_VAR 0 1
38480: PPUSH
38481: LD_VAR 0 4
38485: PPUSH
38486: CALL 25757 0 2
// end ;
38490: GO 38438
38492: POP
38493: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38494: LD_VAR 0 1
38498: PPUSH
38499: LD_INT 36
38501: PPUSH
38502: EMPTY
38503: PPUSH
38504: CALL 12370 0 3
38508: IFFALSE 38549
// for i in MCF_Tag ( side , 36 , [ ] ) do
38510: LD_ADDR_VAR 0 4
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: LD_INT 36
38522: PPUSH
38523: EMPTY
38524: PPUSH
38525: CALL 12370 0 3
38529: PUSH
38530: FOR_IN
38531: IFFALSE 38547
// SetTag ( i , 0 ) ;
38533: LD_VAR 0 4
38537: PPUSH
38538: LD_INT 0
38540: PPUSH
38541: CALL_OW 109
38545: GO 38530
38547: POP
38548: POP
// if MREG_DefMobActive [ side ] then
38549: LD_EXP 70
38553: PUSH
38554: LD_VAR 0 1
38558: ARRAY
38559: IFFALSE 38584
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38561: LD_ADDR_EXP 70
38565: PUSH
38566: LD_EXP 70
38570: PPUSH
38571: LD_VAR 0 1
38575: PPUSH
38576: LD_INT 0
38578: PPUSH
38579: CALL_OW 1
38583: ST_TO_ADDR
// end ; end ; if mode > 0 then
38584: LD_VAR 0 2
38588: PUSH
38589: LD_INT 0
38591: GREATER
38592: IFFALSE 40487
// begin if tick <= 15 15$00 then
38594: LD_OWVAR 1
38598: PUSH
38599: LD_INT 31500
38601: LESSEQUAL
38602: IFFALSE 38906
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38604: LD_VAR 0 13
38608: PUSH
38609: LD_VAR 0 1
38613: PPUSH
38614: CALL 25022 0 1
38618: PUSH
38619: LD_INT 4
38621: LESS
38622: AND
38623: IFFALSE 38734
// begin for i in sol do
38625: LD_ADDR_VAR 0 4
38629: PUSH
38630: LD_VAR 0 13
38634: PUSH
38635: FOR_IN
38636: IFFALSE 38732
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38638: LD_ADDR_VAR 0 8
38642: PUSH
38643: LD_VAR 0 1
38647: PPUSH
38648: CALL 25022 0 1
38652: PPUSH
38653: LD_VAR 0 4
38657: PPUSH
38658: CALL_OW 74
38662: ST_TO_ADDR
// if IsInUnit ( i ) then
38663: LD_VAR 0 4
38667: PPUSH
38668: CALL_OW 310
38672: IFFALSE 38683
// ComExitBuilding ( i ) ;
38674: LD_VAR 0 4
38678: PPUSH
38679: CALL_OW 122
// if not HasTask ( i ) and k then
38683: LD_VAR 0 4
38687: PPUSH
38688: CALL_OW 314
38692: NOT
38693: PUSH
38694: LD_VAR 0 8
38698: AND
38699: IFFALSE 38730
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38701: LD_VAR 0 4
38705: PPUSH
38706: LD_VAR 0 8
38710: PPUSH
38711: CALL_OW 250
38715: PPUSH
38716: LD_VAR 0 8
38720: PPUSH
38721: CALL_OW 251
38725: PPUSH
38726: CALL_OW 174
// end ;
38730: GO 38635
38732: POP
38733: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38734: LD_VAR 0 1
38738: PPUSH
38739: LD_INT 30
38741: PUSH
38742: LD_INT 5
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PPUSH
38749: CALL 11667 0 2
38753: IFFALSE 38904
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38755: LD_ADDR_VAR 0 11
38759: PUSH
38760: LD_VAR 0 1
38764: PPUSH
38765: LD_INT 30
38767: PUSH
38768: LD_INT 5
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PPUSH
38775: CALL 11667 0 2
38779: PUSH
38780: LD_INT 1
38782: ARRAY
38783: ST_TO_ADDR
// if mech then
38784: LD_VAR 0 15
38788: IFFALSE 38824
// for i in mech do
38790: LD_ADDR_VAR 0 4
38794: PUSH
38795: LD_VAR 0 15
38799: PUSH
38800: FOR_IN
38801: IFFALSE 38822
// MCH_ChangeClass ( side , i , 1 ) ;
38803: LD_VAR 0 1
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_INT 1
38815: PPUSH
38816: CALL 16574 0 3
38820: GO 38800
38822: POP
38823: POP
// if eng > 1 then
38824: LD_VAR 0 14
38828: PUSH
38829: LD_INT 1
38831: GREATER
38832: IFFALSE 38879
// for i = eng downto 2 do
38834: LD_ADDR_VAR 0 4
38838: PUSH
38839: DOUBLE
38840: LD_VAR 0 14
38844: INC
38845: ST_TO_ADDR
38846: LD_INT 2
38848: PUSH
38849: FOR_DOWNTO
38850: IFFALSE 38877
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38852: LD_VAR 0 1
38856: PPUSH
38857: LD_VAR 0 14
38861: PUSH
38862: LD_VAR 0 4
38866: ARRAY
38867: PPUSH
38868: LD_INT 1
38870: PPUSH
38871: CALL 16574 0 3
38875: GO 38849
38877: POP
38878: POP
// if UnitsInside ( b ) then
38879: LD_VAR 0 11
38883: PPUSH
38884: CALL_OW 313
38888: IFFALSE 38904
// ComExitBuilding ( UnitsInside ( b ) ) ;
38890: LD_VAR 0 11
38894: PPUSH
38895: CALL_OW 313
38899: PPUSH
38900: CALL_OW 122
// end ; end else
38904: GO 40487
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38906: LD_VAR 0 1
38910: PPUSH
38911: LD_INT 1
38913: PPUSH
38914: LD_EXP 65
38918: PUSH
38919: LD_VAR 0 1
38923: ARRAY
38924: PUSH
38925: LD_INT 1
38927: ARRAY
38928: PPUSH
38929: CALL 33759 0 3
38933: IFFALSE 39072
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38935: LD_ADDR_VAR 0 12
38939: PUSH
38940: LD_VAR 0 1
38944: PPUSH
38945: LD_INT 21
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PPUSH
38955: CALL 11667 0 2
38959: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38960: LD_ADDR_VAR 0 11
38964: PUSH
38965: LD_VAR 0 1
38969: PPUSH
38970: LD_INT 30
38972: PUSH
38973: LD_INT 1
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PPUSH
38980: CALL 11667 0 2
38984: ST_TO_ADDR
// if b then
38985: LD_VAR 0 11
38989: IFFALSE 39072
// for i in tmp do
38991: LD_ADDR_VAR 0 4
38995: PUSH
38996: LD_VAR 0 12
39000: PUSH
39001: FOR_IN
39002: IFFALSE 39070
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
39004: LD_VAR 0 4
39008: PPUSH
39009: LD_EXP 65
39013: PUSH
39014: LD_VAR 0 1
39018: ARRAY
39019: PUSH
39020: LD_INT 1
39022: ARRAY
39023: PPUSH
39024: CALL_OW 308
39028: NOT
39029: IFFALSE 39068
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
39031: LD_VAR 0 4
39035: PPUSH
39036: LD_VAR 0 11
39040: PUSH
39041: LD_INT 1
39043: ARRAY
39044: PPUSH
39045: CALL_OW 250
39049: PPUSH
39050: LD_VAR 0 11
39054: PUSH
39055: LD_INT 1
39057: ARRAY
39058: PPUSH
39059: CALL_OW 251
39063: PPUSH
39064: CALL_OW 111
39068: GO 39001
39070: POP
39071: POP
// end ; if MREG_DefVeh [ side ] then
39072: LD_EXP 67
39076: PUSH
39077: LD_VAR 0 1
39081: ARRAY
39082: IFFALSE 39650
// begin tmp := [ ] ;
39084: LD_ADDR_VAR 0 12
39088: PUSH
39089: EMPTY
39090: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
39091: LD_EXP 70
39095: PUSH
39096: LD_VAR 0 1
39100: ARRAY
39101: PUSH
39102: LD_INT 0
39104: EQUAL
39105: IFFALSE 39245
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39107: LD_ADDR_VAR 0 8
39111: PUSH
39112: LD_VAR 0 1
39116: PPUSH
39117: LD_INT 0
39119: PPUSH
39120: LD_INT 25
39122: PUSH
39123: LD_INT 3
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PPUSH
39130: CALL 12370 0 3
39134: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39135: LD_VAR 0 8
39139: PUSH
39140: LD_EXP 67
39144: PUSH
39145: LD_VAR 0 1
39149: ARRAY
39150: GREATER
39151: IFFALSE 39212
// begin for i = 1 to MREG_DefVeh [ side ] do
39153: LD_ADDR_VAR 0 4
39157: PUSH
39158: DOUBLE
39159: LD_INT 1
39161: DEC
39162: ST_TO_ADDR
39163: LD_EXP 67
39167: PUSH
39168: LD_VAR 0 1
39172: ARRAY
39173: PUSH
39174: FOR_TO
39175: IFFALSE 39208
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39177: LD_ADDR_VAR 0 12
39181: PUSH
39182: LD_VAR 0 12
39186: PPUSH
39187: LD_INT 1
39189: PPUSH
39190: LD_VAR 0 8
39194: PUSH
39195: LD_VAR 0 4
39199: ARRAY
39200: PPUSH
39201: CALL_OW 2
39205: ST_TO_ADDR
39206: GO 39174
39208: POP
39209: POP
// end else
39210: GO 39222
// tmp := k ;
39212: LD_ADDR_VAR 0 12
39216: PUSH
39217: LD_VAR 0 8
39221: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39222: LD_ADDR_EXP 70
39226: PUSH
39227: LD_EXP 70
39231: PPUSH
39232: LD_VAR 0 1
39236: PPUSH
39237: LD_INT 1
39239: PPUSH
39240: CALL_OW 1
39244: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39245: LD_ADDR_VAR 0 4
39249: PUSH
39250: LD_EXP 67
39254: PUSH
39255: LD_VAR 0 1
39259: ARRAY
39260: PUSH
39261: FOR_IN
39262: IFFALSE 39648
// begin if not GetDriver ( i ) then
39264: LD_VAR 0 4
39268: PPUSH
39269: CALL 31789 0 1
39273: NOT
39274: IFFALSE 39349
// begin if tmp then
39276: LD_VAR 0 12
39280: IFFALSE 39347
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39282: LD_VAR 0 12
39286: PUSH
39287: LD_INT 1
39289: ARRAY
39290: PPUSH
39291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39295: LD_VAR 0 12
39299: PUSH
39300: LD_INT 1
39302: ARRAY
39303: PPUSH
39304: LD_VAR 0 4
39308: PPUSH
39309: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39313: LD_VAR 0 12
39317: PUSH
39318: LD_INT 1
39320: ARRAY
39321: PPUSH
39322: LD_INT 36
39324: PPUSH
39325: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39329: LD_ADDR_VAR 0 12
39333: PUSH
39334: LD_VAR 0 12
39338: PPUSH
39339: LD_INT 1
39341: PPUSH
39342: CALL_OW 3
39346: ST_TO_ADDR
// end ; end else
39347: GO 39646
// begin if GetTag ( i ) = 0 then
39349: LD_VAR 0 4
39353: PPUSH
39354: CALL_OW 110
39358: PUSH
39359: LD_INT 0
39361: EQUAL
39362: IFFALSE 39378
// SetTag ( i , 31 ) else
39364: LD_VAR 0 4
39368: PPUSH
39369: LD_INT 31
39371: PPUSH
39372: CALL_OW 109
39376: GO 39646
// if GetTag ( i ) = 31 then
39378: LD_VAR 0 4
39382: PPUSH
39383: CALL_OW 110
39387: PUSH
39388: LD_INT 31
39390: EQUAL
39391: IFFALSE 39646
// begin if GetFuel ( i ) < 20 then
39393: LD_VAR 0 4
39397: PPUSH
39398: CALL_OW 261
39402: PUSH
39403: LD_INT 20
39405: LESS
39406: IFFALSE 39431
// begin SetTag ( i , 21 ) ;
39408: LD_VAR 0 4
39412: PPUSH
39413: LD_INT 21
39415: PPUSH
39416: CALL_OW 109
// MCV_Refuel ( i ) ;
39420: LD_VAR 0 4
39424: PPUSH
39425: CALL 26294 0 1
// continue ;
39429: GO 39261
// end ; if GetLives ( i ) < 700 then
39431: LD_VAR 0 4
39435: PPUSH
39436: CALL_OW 256
39440: PUSH
39441: LD_INT 700
39443: LESS
39444: IFFALSE 39556
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39446: LD_VAR 0 4
39450: PPUSH
39451: LD_EXP 58
39455: PUSH
39456: LD_VAR 0 1
39460: ARRAY
39461: PPUSH
39462: CALL_OW 308
39466: NOT
39467: IFFALSE 39491
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39469: LD_VAR 0 4
39473: PPUSH
39474: LD_EXP 58
39478: PUSH
39479: LD_VAR 0 1
39483: ARRAY
39484: PPUSH
39485: CALL_OW 113
39489: GO 39554
// if GetDriver ( i ) then
39491: LD_VAR 0 4
39495: PPUSH
39496: CALL 31789 0 1
39500: IFFALSE 39554
// begin k := GetDriver ( i ) ;
39502: LD_ADDR_VAR 0 8
39506: PUSH
39507: LD_VAR 0 4
39511: PPUSH
39512: CALL 31789 0 1
39516: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39517: LD_VAR 0 8
39521: PPUSH
39522: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39526: LD_VAR 0 8
39530: PPUSH
39531: LD_VAR 0 4
39535: PPUSH
39536: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39540: LD_VAR 0 8
39544: PPUSH
39545: LD_VAR 0 4
39549: PPUSH
39550: CALL_OW 180
// end ; end else
39554: GO 39646
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39556: LD_ADDR_VAR 0 8
39560: PUSH
39561: LD_VAR 0 1
39565: PPUSH
39566: CALL 25022 0 1
39570: PPUSH
39571: LD_VAR 0 4
39575: PPUSH
39576: CALL_OW 74
39580: ST_TO_ADDR
// if k then
39581: LD_VAR 0 8
39585: IFFALSE 39603
// ComAttackUnit ( i , k ) else
39587: LD_VAR 0 4
39591: PPUSH
39592: LD_VAR 0 8
39596: PPUSH
39597: CALL_OW 115
39601: GO 39646
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39603: LD_VAR 0 4
39607: PPUSH
39608: LD_EXP 58
39612: PUSH
39613: LD_VAR 0 1
39617: ARRAY
39618: PPUSH
39619: CALL_OW 308
39623: NOT
39624: IFFALSE 39646
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39626: LD_VAR 0 4
39630: PPUSH
39631: LD_EXP 58
39635: PUSH
39636: LD_VAR 0 1
39640: ARRAY
39641: PPUSH
39642: CALL_OW 113
// end ; end ; end ; end ;
39646: GO 39261
39648: POP
39649: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39650: LD_VAR 0 1
39654: PPUSH
39655: LD_INT 30
39657: PUSH
39658: LD_INT 5
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PPUSH
39665: CALL 11667 0 2
39669: IFFALSE 40487
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39671: LD_ADDR_VAR 0 11
39675: PUSH
39676: LD_VAR 0 1
39680: PPUSH
39681: LD_INT 30
39683: PUSH
39684: LD_INT 5
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PPUSH
39691: CALL 11667 0 2
39695: PUSH
39696: LD_INT 1
39698: ARRAY
39699: ST_TO_ADDR
// if eng > 1 then
39700: LD_VAR 0 14
39704: PUSH
39705: LD_INT 1
39707: GREATER
39708: IFFALSE 39755
// for i = eng downto 2 do
39710: LD_ADDR_VAR 0 4
39714: PUSH
39715: DOUBLE
39716: LD_VAR 0 14
39720: INC
39721: ST_TO_ADDR
39722: LD_INT 2
39724: PUSH
39725: FOR_DOWNTO
39726: IFFALSE 39753
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39728: LD_VAR 0 1
39732: PPUSH
39733: LD_VAR 0 14
39737: PUSH
39738: LD_VAR 0 4
39742: ARRAY
39743: PPUSH
39744: LD_INT 1
39746: PPUSH
39747: CALL 16574 0 3
39751: GO 39725
39753: POP
39754: POP
// if sci > 1 then
39755: LD_VAR 0 16
39759: PUSH
39760: LD_INT 1
39762: GREATER
39763: IFFALSE 39810
// for i = sci downto 2 do
39765: LD_ADDR_VAR 0 4
39769: PUSH
39770: DOUBLE
39771: LD_VAR 0 16
39775: INC
39776: ST_TO_ADDR
39777: LD_INT 2
39779: PUSH
39780: FOR_DOWNTO
39781: IFFALSE 39808
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39783: LD_VAR 0 1
39787: PPUSH
39788: LD_VAR 0 16
39792: PUSH
39793: LD_VAR 0 4
39797: ARRAY
39798: PPUSH
39799: LD_INT 1
39801: PPUSH
39802: CALL 16574 0 3
39806: GO 39780
39808: POP
39809: POP
// if sol then
39810: LD_VAR 0 13
39814: IFFALSE 40487
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39816: LD_VAR 0 13
39820: PUSH
39821: LD_EXP 68
39825: PUSH
39826: LD_VAR 0 1
39830: ARRAY
39831: DIFF
39832: PUSH
39833: LD_INT 22
39835: PUSH
39836: LD_VAR 0 1
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 58
39847: PUSH
39848: EMPTY
39849: LIST
39850: PUSH
39851: LD_INT 2
39853: PUSH
39854: LD_INT 30
39856: PUSH
39857: LD_INT 32
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 30
39866: PUSH
39867: LD_INT 31
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: LIST
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: LIST
39883: PPUSH
39884: CALL_OW 69
39888: PUSH
39889: LD_INT 0
39891: EQUAL
39892: AND
39893: IFFALSE 40487
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39895: LD_ADDR_VAR 0 12
39899: PUSH
39900: LD_VAR 0 13
39904: PUSH
39905: LD_EXP 68
39909: PUSH
39910: LD_VAR 0 1
39914: ARRAY
39915: DIFF
39916: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39917: LD_VAR 0 1
39921: PPUSH
39922: LD_INT 30
39924: PUSH
39925: LD_INT 5
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PPUSH
39932: CALL 11667 0 2
39936: PUSH
39937: LD_INT 1
39939: GREATER
39940: IFFALSE 39971
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39942: LD_ADDR_VAR 0 8
39946: PUSH
39947: LD_VAR 0 1
39951: PPUSH
39952: LD_INT 30
39954: PUSH
39955: LD_INT 5
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PPUSH
39962: CALL 11667 0 2
39966: PUSH
39967: LD_INT 2
39969: ARRAY
39970: ST_TO_ADDR
// for j in tmp do
39971: LD_ADDR_VAR 0 5
39975: PUSH
39976: LD_VAR 0 12
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40485
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39984: LD_VAR 0 5
39988: PUSH
39989: LD_VAR 0 11
39993: PPUSH
39994: CALL_OW 313
39998: IN
39999: PUSH
40000: LD_VAR 0 11
40004: PPUSH
40005: CALL_OW 313
40009: PUSH
40010: LD_INT 6
40012: EQUAL
40013: AND
40014: PUSH
40015: LD_VAR 0 8
40019: AND
40020: PUSH
40021: LD_VAR 0 8
40025: PPUSH
40026: CALL_OW 313
40030: PUSH
40031: LD_INT 6
40033: LESS
40034: AND
40035: IFFALSE 40062
// begin ComExitBuilding ( j ) ;
40037: LD_VAR 0 5
40041: PPUSH
40042: CALL_OW 122
// AddComEnterunit ( j , k ) ;
40046: LD_VAR 0 5
40050: PPUSH
40051: LD_VAR 0 8
40055: PPUSH
40056: CALL_OW 180
// continue ;
40060: GO 39981
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
40062: LD_VAR 0 5
40066: PPUSH
40067: CALL_OW 314
40071: NOT
40072: PUSH
40073: LD_VAR 0 5
40077: PPUSH
40078: CALL_OW 110
40082: PUSH
40083: LD_INT 0
40085: EQUAL
40086: AND
40087: PUSH
40088: LD_VAR 0 5
40092: PPUSH
40093: CALL_OW 310
40097: NOT
40098: AND
40099: IFFALSE 40205
// begin if k then
40101: LD_VAR 0 8
40105: IFFALSE 40176
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40107: LD_VAR 0 8
40111: PPUSH
40112: CALL_OW 313
40116: PUSH
40117: LD_VAR 0 11
40121: PPUSH
40122: CALL_OW 313
40126: LESS
40127: IFFALSE 40145
// ComEnterUnit ( j , k ) else
40129: LD_VAR 0 5
40133: PPUSH
40134: LD_VAR 0 8
40138: PPUSH
40139: CALL_OW 120
40143: GO 40174
// if UnitsInside ( b ) < 6 then
40145: LD_VAR 0 11
40149: PPUSH
40150: CALL_OW 313
40154: PUSH
40155: LD_INT 6
40157: LESS
40158: IFFALSE 40174
// ComEnterUnit ( j , b ) ;
40160: LD_VAR 0 5
40164: PPUSH
40165: LD_VAR 0 11
40169: PPUSH
40170: CALL_OW 120
// end else
40174: GO 40205
// if UnitsInside ( b ) < 6 then
40176: LD_VAR 0 11
40180: PPUSH
40181: CALL_OW 313
40185: PUSH
40186: LD_INT 6
40188: LESS
40189: IFFALSE 40205
// ComEnterUnit ( j , b ) ;
40191: LD_VAR 0 5
40195: PPUSH
40196: LD_VAR 0 11
40200: PPUSH
40201: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40205: LD_VAR 0 5
40209: PUSH
40210: LD_VAR 0 1
40214: PPUSH
40215: LD_INT 54
40217: PUSH
40218: EMPTY
40219: LIST
40220: PPUSH
40221: CALL 11667 0 2
40225: IN
40226: PUSH
40227: LD_VAR 0 5
40231: PPUSH
40232: CALL_OW 257
40236: PUSH
40237: LD_INT 1
40239: EQUAL
40240: AND
40241: IFFALSE 40483
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40243: LD_EXP 62
40247: PUSH
40248: LD_VAR 0 1
40252: ARRAY
40253: PUSH
40254: LD_INT 1
40256: ARRAY
40257: PUSH
40258: LD_INT 12
40260: PPUSH
40261: LD_VAR 0 1
40265: PPUSH
40266: CALL_OW 321
40270: PUSH
40271: LD_INT 2
40273: EQUAL
40274: AND
40275: IFFALSE 40323
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40277: LD_VAR 0 1
40281: PPUSH
40282: LD_INT 5
40284: PPUSH
40285: EMPTY
40286: PPUSH
40287: CALL 11750 0 3
40291: PUSH
40292: LD_EXP 62
40296: PUSH
40297: LD_VAR 0 1
40301: ARRAY
40302: PUSH
40303: LD_INT 1
40305: ARRAY
40306: LESS
40307: IFFALSE 40323
// begin SetClass ( j , class_sniper ) ;
40309: LD_VAR 0 5
40313: PPUSH
40314: LD_INT 5
40316: PPUSH
40317: CALL_OW 336
// continue ;
40321: GO 39981
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40323: LD_EXP 62
40327: PUSH
40328: LD_VAR 0 1
40332: ARRAY
40333: PUSH
40334: LD_INT 2
40336: ARRAY
40337: PUSH
40338: LD_INT 41
40340: PPUSH
40341: LD_VAR 0 1
40345: PPUSH
40346: CALL_OW 321
40350: PUSH
40351: LD_INT 2
40353: EQUAL
40354: AND
40355: IFFALSE 40403
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40357: LD_VAR 0 1
40361: PPUSH
40362: LD_INT 8
40364: PPUSH
40365: EMPTY
40366: PPUSH
40367: CALL 11750 0 3
40371: PUSH
40372: LD_EXP 62
40376: PUSH
40377: LD_VAR 0 1
40381: ARRAY
40382: PUSH
40383: LD_INT 2
40385: ARRAY
40386: LESS
40387: IFFALSE 40403
// begin SetClass ( j , class_mortar ) ;
40389: LD_VAR 0 5
40393: PPUSH
40394: LD_INT 8
40396: PPUSH
40397: CALL_OW 336
// continue ;
40401: GO 39981
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40403: LD_EXP 62
40407: PUSH
40408: LD_VAR 0 1
40412: ARRAY
40413: PUSH
40414: LD_INT 3
40416: ARRAY
40417: PUSH
40418: LD_INT 44
40420: PPUSH
40421: LD_VAR 0 1
40425: PPUSH
40426: CALL_OW 321
40430: PUSH
40431: LD_INT 2
40433: EQUAL
40434: AND
40435: IFFALSE 40483
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40437: LD_VAR 0 1
40441: PPUSH
40442: LD_INT 9
40444: PPUSH
40445: EMPTY
40446: PPUSH
40447: CALL 11750 0 3
40451: PUSH
40452: LD_EXP 62
40456: PUSH
40457: LD_VAR 0 1
40461: ARRAY
40462: PUSH
40463: LD_INT 3
40465: ARRAY
40466: LESS
40467: IFFALSE 40483
// begin SetClass ( j , class_bazooker ) ;
40469: LD_VAR 0 5
40473: PPUSH
40474: LD_INT 9
40476: PPUSH
40477: CALL_OW 336
// continue ;
40481: GO 39981
// end ; end ; end ;
40483: GO 39981
40485: POP
40486: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40487: LD_INT 22
40489: PUSH
40490: LD_VAR 0 1
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 58
40501: PUSH
40502: EMPTY
40503: LIST
40504: PUSH
40505: LD_INT 30
40507: PUSH
40508: LD_INT 32
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: LIST
40519: PPUSH
40520: CALL_OW 69
40524: IFFALSE 40674
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40526: LD_ADDR_VAR 0 12
40530: PUSH
40531: LD_INT 22
40533: PUSH
40534: LD_VAR 0 1
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 58
40545: PUSH
40546: EMPTY
40547: LIST
40548: PUSH
40549: LD_INT 30
40551: PUSH
40552: LD_INT 32
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: LIST
40563: PPUSH
40564: CALL_OW 69
40568: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40569: LD_ADDR_VAR 0 8
40573: PUSH
40574: LD_VAR 0 13
40578: PUSH
40579: LD_EXP 68
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: DIFF
40590: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40591: LD_VAR 0 12
40595: PUSH
40596: LD_INT 1
40598: ARRAY
40599: PPUSH
40600: CALL_OW 461
40604: PUSH
40605: LD_INT 2
40607: EQUAL
40608: PUSH
40609: LD_VAR 0 12
40613: PUSH
40614: LD_INT 1
40616: ARRAY
40617: PUSH
40618: LD_EXP 68
40622: PUSH
40623: LD_VAR 0 1
40627: ARRAY
40628: IN
40629: NOT
40630: AND
40631: PUSH
40632: LD_VAR 0 8
40636: AND
40637: IFFALSE 40674
// begin ComExitBuilding ( k [ 1 ] ) ;
40639: LD_VAR 0 8
40643: PUSH
40644: LD_INT 1
40646: ARRAY
40647: PPUSH
40648: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40652: LD_VAR 0 8
40656: PUSH
40657: LD_INT 1
40659: ARRAY
40660: PPUSH
40661: LD_VAR 0 12
40665: PUSH
40666: LD_INT 1
40668: ARRAY
40669: PPUSH
40670: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40674: LD_EXP 35
40678: PUSH
40679: LD_VAR 0 1
40683: ARRAY
40684: IFFALSE 40832
// begin if MCF_Class ( side , 4 , [ ] ) then
40686: LD_VAR 0 1
40690: PPUSH
40691: LD_INT 4
40693: PPUSH
40694: EMPTY
40695: PPUSH
40696: CALL 11750 0 3
40700: IFFALSE 40830
// for j in MCF_Class ( side , 4 , [ ] ) do
40702: LD_ADDR_VAR 0 5
40706: PUSH
40707: LD_VAR 0 1
40711: PPUSH
40712: LD_INT 4
40714: PPUSH
40715: EMPTY
40716: PPUSH
40717: CALL 11750 0 3
40721: PUSH
40722: FOR_IN
40723: IFFALSE 40828
// begin if not GetTag ( j ) = 4 then
40725: LD_VAR 0 5
40729: PPUSH
40730: CALL_OW 110
40734: PUSH
40735: LD_INT 4
40737: EQUAL
40738: NOT
40739: IFFALSE 40775
// begin SetTag ( j , 4 ) ;
40741: LD_VAR 0 5
40745: PPUSH
40746: LD_INT 4
40748: PPUSH
40749: CALL_OW 109
// if IsInUnit ( j ) then
40753: LD_VAR 0 5
40757: PPUSH
40758: CALL_OW 310
40762: IFFALSE 40773
// ComExitBuilding ( j ) ;
40764: LD_VAR 0 5
40768: PPUSH
40769: CALL_OW 122
// end else
40773: GO 40826
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40775: LD_VAR 0 5
40779: PPUSH
40780: LD_EXP 35
40784: PUSH
40785: LD_VAR 0 1
40789: ARRAY
40790: PUSH
40791: LD_INT 1
40793: ARRAY
40794: PPUSH
40795: CALL 97880 0 2
40799: NOT
40800: IFFALSE 40826
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40802: LD_VAR 0 5
40806: PPUSH
40807: LD_EXP 35
40811: PUSH
40812: LD_VAR 0 1
40816: ARRAY
40817: PUSH
40818: LD_INT 1
40820: ARRAY
40821: PPUSH
40822: CALL 19237 0 2
// end ;
40826: GO 40722
40828: POP
40829: POP
// end else
40830: GO 41064
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40832: LD_VAR 0 1
40836: PPUSH
40837: LD_INT 4
40839: PPUSH
40840: EMPTY
40841: PPUSH
40842: CALL 11750 0 3
40846: PUSH
40847: LD_VAR 0 1
40851: PPUSH
40852: LD_INT 4
40854: PPUSH
40855: EMPTY
40856: PPUSH
40857: CALL 12370 0 3
40861: AND
40862: IFFALSE 41064
// for j in MCF_Class ( side , 4 , [ ] ) do
40864: LD_ADDR_VAR 0 5
40868: PUSH
40869: LD_VAR 0 1
40873: PPUSH
40874: LD_INT 4
40876: PPUSH
40877: EMPTY
40878: PPUSH
40879: CALL 11750 0 3
40883: PUSH
40884: FOR_IN
40885: IFFALSE 41062
// begin if GetTag ( j ) = 4 then
40887: LD_VAR 0 5
40891: PPUSH
40892: CALL_OW 110
40896: PUSH
40897: LD_INT 4
40899: EQUAL
40900: IFFALSE 41060
// begin SetTag ( j , 0 ) ;
40902: LD_VAR 0 5
40906: PPUSH
40907: LD_INT 0
40909: PPUSH
40910: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40914: LD_VAR 0 1
40918: PPUSH
40919: CALL 11706 0 1
40923: PUSH
40924: LD_VAR 0 1
40928: PPUSH
40929: CALL 18050 0 1
40933: NOT
40934: AND
40935: IFFALSE 40960
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40937: LD_VAR 0 5
40941: PPUSH
40942: LD_VAR 0 1
40946: PPUSH
40947: CALL 11706 0 1
40951: PUSH
40952: LD_INT 1
40954: ARRAY
40955: PPUSH
40956: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40960: LD_VAR 0 1
40964: PPUSH
40965: CALL 11706 0 1
40969: NOT
40970: PUSH
40971: LD_VAR 0 1
40975: PPUSH
40976: LD_INT 30
40978: PUSH
40979: LD_INT 1
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PPUSH
40986: CALL 11667 0 2
40990: AND
40991: IFFALSE 41060
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40993: LD_VAR 0 5
40997: PPUSH
40998: LD_VAR 0 1
41002: PPUSH
41003: LD_INT 30
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PPUSH
41013: CALL 11667 0 2
41017: PUSH
41018: LD_INT 1
41020: ARRAY
41021: PPUSH
41022: CALL_OW 250
41026: PPUSH
41027: LD_VAR 0 1
41031: PPUSH
41032: LD_INT 30
41034: PUSH
41035: LD_INT 1
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PPUSH
41042: CALL 11667 0 2
41046: PUSH
41047: LD_INT 1
41049: ARRAY
41050: PPUSH
41051: CALL_OW 251
41055: PPUSH
41056: CALL_OW 111
// end ; end ;
41060: GO 40884
41062: POP
41063: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
41064: LD_VAR 0 1
41068: PPUSH
41069: LD_INT 3
41071: PPUSH
41072: EMPTY
41073: PPUSH
41074: CALL 11750 0 3
41078: PUSH
41079: LD_EXP 58
41083: PUSH
41084: LD_VAR 0 1
41088: ARRAY
41089: AND
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: LD_INT 6
41098: PPUSH
41099: EMPTY
41100: PPUSH
41101: CALL 12370 0 3
41105: AND
41106: IFFALSE 41637
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41108: LD_ADDR_VAR 0 6
41112: PUSH
41113: LD_EXP 58
41117: PUSH
41118: LD_VAR 0 1
41122: ARRAY
41123: PPUSH
41124: LD_INT 0
41126: PPUSH
41127: CALL_OW 517
41131: PUSH
41132: LD_INT 1
41134: ARRAY
41135: PUSH
41136: LD_INT 1
41138: ARRAY
41139: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41140: LD_ADDR_VAR 0 7
41144: PUSH
41145: LD_EXP 58
41149: PUSH
41150: LD_VAR 0 1
41154: ARRAY
41155: PPUSH
41156: LD_INT 0
41158: PPUSH
41159: CALL_OW 517
41163: PUSH
41164: LD_INT 2
41166: ARRAY
41167: PUSH
41168: LD_INT 1
41170: ARRAY
41171: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41172: LD_VAR 0 1
41176: PPUSH
41177: LD_INT 6
41179: PPUSH
41180: EMPTY
41181: PPUSH
41182: CALL 12370 0 3
41186: IFFALSE 41635
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41188: LD_ADDR_VAR 0 8
41192: PUSH
41193: LD_VAR 0 1
41197: PPUSH
41198: LD_INT 6
41200: PPUSH
41201: EMPTY
41202: PPUSH
41203: CALL 12370 0 3
41207: PUSH
41208: FOR_IN
41209: IFFALSE 41240
// if GetLives ( k ) = 1000 then
41211: LD_VAR 0 8
41215: PPUSH
41216: CALL_OW 256
41220: PUSH
41221: LD_INT 1000
41223: EQUAL
41224: IFFALSE 41238
// SetTag ( k , 0 ) ;
41226: LD_VAR 0 8
41230: PPUSH
41231: LD_INT 0
41233: PPUSH
41234: CALL_OW 109
41238: GO 41208
41240: POP
41241: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41242: LD_VAR 0 1
41246: PPUSH
41247: LD_INT 0
41249: PPUSH
41250: LD_INT 25
41252: PUSH
41253: LD_INT 3
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PPUSH
41260: CALL 12370 0 3
41264: IFFALSE 41328
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41266: LD_ADDR_VAR 0 8
41270: PUSH
41271: LD_VAR 0 4
41275: PPUSH
41276: LD_INT 0
41278: PPUSH
41279: LD_INT 25
41281: PUSH
41282: LD_INT 3
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PPUSH
41289: CALL 12370 0 3
41293: PUSH
41294: FOR_IN
41295: IFFALSE 41326
// if GetTag ( k ) = 0 then
41297: LD_VAR 0 8
41301: PPUSH
41302: CALL_OW 110
41306: PUSH
41307: LD_INT 0
41309: EQUAL
41310: IFFALSE 41324
// begin SetTag ( k , 8 ) ;
41312: LD_VAR 0 8
41316: PPUSH
41317: LD_INT 8
41319: PPUSH
41320: CALL_OW 109
// end ;
41324: GO 41294
41326: POP
41327: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41328: LD_VAR 0 1
41332: PPUSH
41333: LD_INT 6
41335: PPUSH
41336: LD_INT 92
41338: PUSH
41339: LD_VAR 0 6
41343: PUSH
41344: LD_VAR 0 7
41348: PUSH
41349: LD_INT 10
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: PPUSH
41358: CALL 12370 0 3
41362: IFFALSE 41486
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41364: LD_ADDR_VAR 0 5
41368: PUSH
41369: LD_VAR 0 4
41373: PPUSH
41374: LD_INT 6
41376: PPUSH
41377: LD_INT 92
41379: PUSH
41380: LD_VAR 0 6
41384: PUSH
41385: LD_VAR 0 7
41389: PUSH
41390: LD_INT 10
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: PPUSH
41399: CALL 12370 0 3
41403: PUSH
41404: FOR_IN
41405: IFFALSE 41484
// begin if not HasTask ( j ) and GetDriver ( j ) then
41407: LD_VAR 0 5
41411: PPUSH
41412: CALL_OW 314
41416: NOT
41417: PUSH
41418: LD_VAR 0 5
41422: PPUSH
41423: CALL 31789 0 1
41427: AND
41428: IFFALSE 41482
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41430: LD_VAR 0 5
41434: PPUSH
41435: CALL 31789 0 1
41439: PPUSH
41440: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41444: LD_VAR 0 5
41448: PPUSH
41449: CALL 31789 0 1
41453: PPUSH
41454: LD_VAR 0 5
41458: PPUSH
41459: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41463: LD_VAR 0 5
41467: PPUSH
41468: CALL 31789 0 1
41472: PPUSH
41473: LD_VAR 0 5
41477: PPUSH
41478: CALL_OW 180
// end ; end ;
41482: GO 41404
41484: POP
41485: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41486: LD_VAR 0 1
41490: PPUSH
41491: LD_INT 6
41493: PPUSH
41494: LD_INT 92
41496: PUSH
41497: LD_VAR 0 6
41501: PUSH
41502: LD_VAR 0 7
41506: PUSH
41507: LD_INT 10
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: PPUSH
41516: CALL 12370 0 3
41520: PUSH
41521: LD_VAR 0 1
41525: PPUSH
41526: LD_INT 8
41528: PPUSH
41529: EMPTY
41530: PPUSH
41531: CALL 12370 0 3
41535: AND
41536: IFFALSE 41635
// for j in MCF_Tag ( side , 8 , [ ] ) do
41538: LD_ADDR_VAR 0 5
41542: PUSH
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12370 0 3
41557: PUSH
41558: FOR_IN
41559: IFFALSE 41633
// begin if IsInUnit ( j ) then
41561: LD_VAR 0 5
41565: PPUSH
41566: CALL_OW 310
41570: IFFALSE 41583
// ComExitBuilding ( j ) else
41572: LD_VAR 0 5
41576: PPUSH
41577: CALL_OW 122
41581: GO 41631
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41583: LD_VAR 0 5
41587: PPUSH
41588: LD_VAR 0 1
41592: PPUSH
41593: LD_INT 6
41595: PPUSH
41596: LD_INT 92
41598: PUSH
41599: LD_VAR 0 6
41603: PUSH
41604: LD_VAR 0 7
41608: PUSH
41609: LD_INT 10
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: PPUSH
41618: CALL 12370 0 3
41622: PUSH
41623: LD_INT 1
41625: ARRAY
41626: PPUSH
41627: CALL_OW 129
// end ;
41631: GO 41558
41633: POP
41634: POP
// end ; end else
41635: GO 41692
// if MCF_Tag ( side , 8 , [ ] ) then
41637: LD_VAR 0 1
41641: PPUSH
41642: LD_INT 8
41644: PPUSH
41645: EMPTY
41646: PPUSH
41647: CALL 12370 0 3
41651: IFFALSE 41692
// for k in MCF_Tag ( side , 8 , [ ] ) do
41653: LD_ADDR_VAR 0 8
41657: PUSH
41658: LD_VAR 0 1
41662: PPUSH
41663: LD_INT 8
41665: PPUSH
41666: EMPTY
41667: PPUSH
41668: CALL 12370 0 3
41672: PUSH
41673: FOR_IN
41674: IFFALSE 41690
// SetTag ( k , 0 ) ;
41676: LD_VAR 0 8
41680: PPUSH
41681: LD_INT 0
41683: PPUSH
41684: CALL_OW 109
41688: GO 41673
41690: POP
41691: POP
// end ; end_of_file
41692: LD_VAR 0 3
41696: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41697: LD_INT 0
41699: PPUSH
// MREG_Game := [ ] ;
41700: LD_ADDR_EXP 33
41704: PUSH
41705: EMPTY
41706: ST_TO_ADDR
// MREG_Crates := [ ] ;
41707: LD_ADDR_EXP 34
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// MREG_Heal := [ ] ;
41714: LD_ADDR_EXP 35
41718: PUSH
41719: EMPTY
41720: ST_TO_ADDR
// MREG_Tame := [ ] ;
41721: LD_ADDR_EXP 37
41725: PUSH
41726: EMPTY
41727: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41728: LD_ADDR_EXP 38
41732: PUSH
41733: EMPTY
41734: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41735: LD_ADDR_EXP 39
41739: PUSH
41740: EMPTY
41741: ST_TO_ADDR
// MREG_LabList := [ ] ;
41742: LD_ADDR_EXP 40
41746: PUSH
41747: EMPTY
41748: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41749: LD_ADDR_EXP 41
41753: PUSH
41754: EMPTY
41755: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41756: LD_ADDR_EXP 42
41760: PUSH
41761: EMPTY
41762: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41763: LD_ADDR_EXP 43
41767: PUSH
41768: EMPTY
41769: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41770: LD_ADDR_EXP 44
41774: PUSH
41775: EMPTY
41776: ST_TO_ADDR
// MREG_Status := [ ] ;
41777: LD_ADDR_EXP 45
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41784: LD_ADDR_EXP 46
41788: PUSH
41789: EMPTY
41790: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41791: LD_ADDR_EXP 47
41795: PUSH
41796: EMPTY
41797: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41798: LD_ADDR_EXP 48
41802: PUSH
41803: EMPTY
41804: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41805: LD_ADDR_EXP 49
41809: PUSH
41810: EMPTY
41811: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41812: LD_ADDR_EXP 50
41816: PUSH
41817: EMPTY
41818: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41819: LD_ADDR_EXP 51
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41826: LD_ADDR_EXP 52
41830: PUSH
41831: EMPTY
41832: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41833: LD_ADDR_EXP 53
41837: PUSH
41838: EMPTY
41839: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41840: LD_ADDR_EXP 54
41844: PUSH
41845: EMPTY
41846: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41847: LD_ADDR_EXP 55
41851: PUSH
41852: EMPTY
41853: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41854: LD_ADDR_EXP 56
41858: PUSH
41859: EMPTY
41860: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41861: LD_ADDR_EXP 57
41865: PUSH
41866: EMPTY
41867: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41868: LD_ADDR_EXP 61
41872: PUSH
41873: EMPTY
41874: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41875: LD_ADDR_EXP 62
41879: PUSH
41880: EMPTY
41881: ST_TO_ADDR
// MREG_Parking := [ ] ;
41882: LD_ADDR_EXP 58
41886: PUSH
41887: EMPTY
41888: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41889: LD_ADDR_EXP 59
41893: PUSH
41894: EMPTY
41895: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41896: LD_ADDR_EXP 63
41900: PUSH
41901: EMPTY
41902: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41903: LD_ADDR_EXP 64
41907: PUSH
41908: EMPTY
41909: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41910: LD_ADDR_EXP 65
41914: PUSH
41915: EMPTY
41916: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41917: LD_ADDR_EXP 67
41921: PUSH
41922: EMPTY
41923: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41924: LD_ADDR_EXP 68
41928: PUSH
41929: EMPTY
41930: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41931: LD_ADDR_EXP 69
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41938: LD_ADDR_EXP 71
41942: PUSH
41943: EMPTY
41944: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41945: LD_ADDR_EXP 70
41949: PUSH
41950: EMPTY
41951: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41952: LD_ADDR_EXP 72
41956: PUSH
41957: LD_INT 300
41959: PUSH
41960: LD_INT 100
41962: PUSH
41963: LD_INT 25
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: LIST
41970: ST_TO_ADDR
// end ;
41971: LD_VAR 0 1
41975: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41976: LD_INT 0
41978: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41979: LD_VAR 0 2
41983: PUSH
41984: LD_VAR 0 3
41988: PUSH
41989: LD_VAR 0 4
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: LIST
41998: PUSH
41999: LD_VAR 0 1
42003: IN
42004: IFFALSE 42018
// result := mreg_list else
42006: LD_ADDR_VAR 0 5
42010: PUSH
42011: LD_VAR 0 1
42015: ST_TO_ADDR
42016: GO 42052
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
42018: LD_ADDR_VAR 0 1
42022: PUSH
42023: LD_VAR 0 1
42027: PUSH
42028: LD_VAR 0 2
42032: PUSH
42033: LD_VAR 0 3
42037: PUSH
42038: LD_VAR 0 4
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: ADD
42051: ST_TO_ADDR
// result := mreg_list ;
42052: LD_ADDR_VAR 0 5
42056: PUSH
42057: LD_VAR 0 1
42061: ST_TO_ADDR
// end ;
42062: LD_VAR 0 5
42066: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
42067: LD_INT 0
42069: PPUSH
// if [ side , unit , mreg ] in mreg_list then
42070: LD_VAR 0 2
42074: PUSH
42075: LD_VAR 0 3
42079: PUSH
42080: LD_VAR 0 4
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: LIST
42089: PUSH
42090: LD_VAR 0 1
42094: IN
42095: IFFALSE 42133
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42097: LD_ADDR_VAR 0 5
42101: PUSH
42102: LD_VAR 0 1
42106: PUSH
42107: LD_VAR 0 2
42111: PUSH
42112: LD_VAR 0 3
42116: PUSH
42117: LD_VAR 0 4
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: LIST
42126: PUSH
42127: EMPTY
42128: LIST
42129: DIFF
42130: ST_TO_ADDR
42131: GO 42143
// result := mreg_list ;
42133: LD_ADDR_VAR 0 5
42137: PUSH
42138: LD_VAR 0 1
42142: ST_TO_ADDR
// end ;
42143: LD_VAR 0 5
42147: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42148: LD_INT 0
42150: PPUSH
42151: PPUSH
42152: PPUSH
// for j = 1 to 8 do
42153: LD_ADDR_VAR 0 3
42157: PUSH
42158: DOUBLE
42159: LD_INT 1
42161: DEC
42162: ST_TO_ADDR
42163: LD_INT 8
42165: PUSH
42166: FOR_TO
42167: IFFALSE 43008
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42169: LD_VAR 0 3
42173: PPUSH
42174: LD_INT 51
42176: PUSH
42177: EMPTY
42178: LIST
42179: PPUSH
42180: CALL 11667 0 2
42184: PUSH
42185: LD_OWVAR 2
42189: PUSH
42190: LD_VAR 0 3
42194: EQUAL
42195: NOT
42196: AND
42197: IFFALSE 42215
// MREG_SidesList := MREG_SidesList ^ 1 else
42199: LD_ADDR_EXP 39
42203: PUSH
42204: LD_EXP 39
42208: PUSH
42209: LD_INT 1
42211: ADD
42212: ST_TO_ADDR
42213: GO 42229
// MREG_SidesList := MREG_SidesList ^ 0 ;
42215: LD_ADDR_EXP 39
42219: PUSH
42220: LD_EXP 39
42224: PUSH
42225: LD_INT 0
42227: ADD
42228: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42229: LD_VAR 0 3
42233: PPUSH
42234: LD_INT 2
42236: PUSH
42237: LD_INT 34
42239: PUSH
42240: LD_INT 12
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 34
42249: PUSH
42250: LD_INT 32
42252: PUSH
42253: EMPTY
42254: LIST
42255: LIST
42256: PUSH
42257: LD_INT 34
42259: PUSH
42260: LD_INT 51
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: LIST
42271: LIST
42272: PUSH
42273: EMPTY
42274: LIST
42275: PPUSH
42276: CALL 11968 0 2
42280: IFFALSE 42381
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42282: LD_ADDR_VAR 0 2
42286: PUSH
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 2
42294: PUSH
42295: LD_INT 34
42297: PUSH
42298: LD_INT 12
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 34
42307: PUSH
42308: LD_INT 32
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 34
42317: PUSH
42318: LD_INT 51
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: LIST
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PPUSH
42334: CALL 11968 0 2
42338: PUSH
42339: FOR_IN
42340: IFFALSE 42379
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42342: LD_ADDR_EXP 41
42346: PUSH
42347: LD_EXP 41
42351: PPUSH
42352: LD_VAR 0 3
42356: PPUSH
42357: LD_VAR 0 2
42361: PPUSH
42362: LD_VAR 0 2
42366: PPUSH
42367: CALL_OW 264
42371: PPUSH
42372: CALL 41976 0 4
42376: ST_TO_ADDR
42377: GO 42339
42379: POP
42380: POP
// if MCF_Class ( j , 4 , [ ] ) then
42381: LD_VAR 0 3
42385: PPUSH
42386: LD_INT 4
42388: PPUSH
42389: EMPTY
42390: PPUSH
42391: CALL 11750 0 3
42395: IFFALSE 42428
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42397: LD_ADDR_EXP 54
42401: PUSH
42402: LD_EXP 54
42406: PUSH
42407: LD_VAR 0 3
42411: PPUSH
42412: LD_INT 4
42414: PPUSH
42415: EMPTY
42416: PPUSH
42417: CALL 11750 0 3
42421: PUSH
42422: EMPTY
42423: LIST
42424: ADD
42425: ST_TO_ADDR
42426: GO 42445
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42428: LD_ADDR_EXP 54
42432: PUSH
42433: LD_EXP 54
42437: PUSH
42438: LD_INT 0
42440: PUSH
42441: EMPTY
42442: LIST
42443: ADD
42444: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42445: LD_VAR 0 3
42449: PPUSH
42450: LD_INT 3
42452: PPUSH
42453: EMPTY
42454: PPUSH
42455: CALL 11750 0 3
42459: IFFALSE 42492
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42461: LD_ADDR_EXP 55
42465: PUSH
42466: LD_EXP 55
42470: PUSH
42471: LD_VAR 0 3
42475: PPUSH
42476: LD_INT 3
42478: PPUSH
42479: EMPTY
42480: PPUSH
42481: CALL 11750 0 3
42485: PUSH
42486: EMPTY
42487: LIST
42488: ADD
42489: ST_TO_ADDR
42490: GO 42509
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42492: LD_ADDR_EXP 55
42496: PUSH
42497: LD_EXP 55
42501: PUSH
42502: LD_INT 0
42504: PUSH
42505: EMPTY
42506: LIST
42507: ADD
42508: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42509: LD_VAR 0 3
42513: PPUSH
42514: LD_INT 1
42516: PPUSH
42517: EMPTY
42518: PPUSH
42519: CALL 11750 0 3
42523: IFFALSE 42556
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42525: LD_ADDR_EXP 56
42529: PUSH
42530: LD_EXP 56
42534: PUSH
42535: LD_VAR 0 3
42539: PPUSH
42540: LD_INT 1
42542: PPUSH
42543: EMPTY
42544: PPUSH
42545: CALL 11750 0 3
42549: PUSH
42550: EMPTY
42551: LIST
42552: ADD
42553: ST_TO_ADDR
42554: GO 42573
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42556: LD_ADDR_EXP 56
42560: PUSH
42561: LD_EXP 56
42565: PUSH
42566: LD_INT 0
42568: PUSH
42569: EMPTY
42570: LIST
42571: ADD
42572: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42573: LD_VAR 0 3
42577: PPUSH
42578: LD_INT 2
42580: PPUSH
42581: EMPTY
42582: PPUSH
42583: CALL 11750 0 3
42587: IFFALSE 42620
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42589: LD_ADDR_EXP 57
42593: PUSH
42594: LD_EXP 57
42598: PUSH
42599: LD_VAR 0 3
42603: PPUSH
42604: LD_INT 2
42606: PPUSH
42607: EMPTY
42608: PPUSH
42609: CALL 11750 0 3
42613: PUSH
42614: EMPTY
42615: LIST
42616: ADD
42617: ST_TO_ADDR
42618: GO 42637
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42620: LD_ADDR_EXP 57
42624: PUSH
42625: LD_EXP 57
42629: PUSH
42630: LD_INT 0
42632: PUSH
42633: EMPTY
42634: LIST
42635: ADD
42636: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42637: LD_ADDR_EXP 47
42641: PUSH
42642: LD_EXP 47
42646: PUSH
42647: LD_INT 0
42649: PUSH
42650: EMPTY
42651: LIST
42652: ADD
42653: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42654: LD_ADDR_EXP 35
42658: PUSH
42659: LD_EXP 35
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: ADD
42670: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42671: LD_ADDR_EXP 37
42675: PUSH
42676: LD_EXP 37
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: EMPTY
42685: LIST
42686: ADD
42687: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42688: LD_ADDR_EXP 58
42692: PUSH
42693: LD_EXP 58
42697: PUSH
42698: LD_INT 0
42700: PUSH
42701: EMPTY
42702: LIST
42703: ADD
42704: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42705: LD_ADDR_EXP 59
42709: PUSH
42710: LD_EXP 59
42714: PUSH
42715: LD_INT 0
42717: PUSH
42718: EMPTY
42719: LIST
42720: ADD
42721: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42722: LD_ADDR_EXP 51
42726: PUSH
42727: LD_EXP 51
42731: PUSH
42732: LD_INT 0
42734: PUSH
42735: EMPTY
42736: LIST
42737: ADD
42738: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42739: LD_ADDR_EXP 38
42743: PUSH
42744: LD_EXP 38
42748: PUSH
42749: LD_INT 0
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: LD_INT 0
42757: PUSH
42758: LD_INT 0
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42771: LD_ADDR_EXP 60
42775: PUSH
42776: LD_EXP 60
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: EMPTY
42791: LIST
42792: ADD
42793: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42794: LD_ADDR_EXP 61
42798: PUSH
42799: LD_EXP 61
42803: PUSH
42804: LD_INT 0
42806: PUSH
42807: EMPTY
42808: LIST
42809: PUSH
42810: EMPTY
42811: LIST
42812: ADD
42813: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42814: LD_ADDR_EXP 42
42818: PUSH
42819: LD_EXP 42
42823: PUSH
42824: LD_INT 0
42826: PUSH
42827: EMPTY
42828: LIST
42829: ADD
42830: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42831: LD_ADDR_EXP 63
42835: PUSH
42836: LD_EXP 63
42840: PUSH
42841: LD_INT 0
42843: PUSH
42844: EMPTY
42845: LIST
42846: ADD
42847: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42848: LD_ADDR_EXP 64
42852: PUSH
42853: LD_EXP 64
42857: PUSH
42858: LD_INT 0
42860: PUSH
42861: EMPTY
42862: LIST
42863: ADD
42864: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42865: LD_ADDR_EXP 65
42869: PUSH
42870: LD_EXP 65
42874: PUSH
42875: LD_INT 0
42877: PUSH
42878: EMPTY
42879: LIST
42880: ADD
42881: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42882: LD_ADDR_EXP 66
42886: PUSH
42887: LD_EXP 66
42891: PUSH
42892: LD_INT 0
42894: PUSH
42895: EMPTY
42896: LIST
42897: ADD
42898: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42899: LD_ADDR_EXP 67
42903: PUSH
42904: LD_EXP 67
42908: PUSH
42909: LD_INT 0
42911: PUSH
42912: EMPTY
42913: LIST
42914: ADD
42915: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42916: LD_ADDR_EXP 68
42920: PUSH
42921: LD_EXP 68
42925: PUSH
42926: LD_INT 0
42928: PUSH
42929: EMPTY
42930: LIST
42931: ADD
42932: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42933: LD_ADDR_EXP 69
42937: PUSH
42938: LD_EXP 69
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: EMPTY
42947: LIST
42948: ADD
42949: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42950: LD_ADDR_EXP 71
42954: PUSH
42955: LD_EXP 71
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: ADD
42966: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42967: LD_ADDR_EXP 70
42971: PUSH
42972: LD_EXP 70
42976: PUSH
42977: LD_INT 0
42979: ADD
42980: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42981: LD_ADDR_EXP 62
42985: PUSH
42986: LD_EXP 62
42990: PUSH
42991: LD_INT 0
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: LD_INT 0
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: LIST
43004: ADD
43005: ST_TO_ADDR
// end ;
43006: GO 42166
43008: POP
43009: POP
// end ;
43010: LD_VAR 0 1
43014: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
43015: LD_INT 0
43017: PPUSH
43018: PPUSH
43019: PPUSH
// m := false ;
43020: LD_ADDR_VAR 0 5
43024: PUSH
43025: LD_INT 0
43027: ST_TO_ADDR
// for i = 1 to mreg do
43028: LD_ADDR_VAR 0 4
43032: PUSH
43033: DOUBLE
43034: LD_INT 1
43036: DEC
43037: ST_TO_ADDR
43038: LD_VAR 0 2
43042: PUSH
43043: FOR_TO
43044: IFFALSE 43080
// if mreg [ i ] [ 1 ] = side then
43046: LD_VAR 0 2
43050: PUSH
43051: LD_VAR 0 4
43055: ARRAY
43056: PUSH
43057: LD_INT 1
43059: ARRAY
43060: PUSH
43061: LD_VAR 0 1
43065: EQUAL
43066: IFFALSE 43078
// begin m := true ;
43068: LD_ADDR_VAR 0 5
43072: PUSH
43073: LD_INT 1
43075: ST_TO_ADDR
// break ;
43076: GO 43080
// end ;
43078: GO 43043
43080: POP
43081: POP
// result := m ;
43082: LD_ADDR_VAR 0 3
43086: PUSH
43087: LD_VAR 0 5
43091: ST_TO_ADDR
// end ;
43092: LD_VAR 0 3
43096: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43097: LD_INT 0
43099: PPUSH
43100: PPUSH
43101: PPUSH
// m := 0 ;
43102: LD_ADDR_VAR 0 5
43106: PUSH
43107: LD_INT 0
43109: ST_TO_ADDR
// for i = 1 to mreg do
43110: LD_ADDR_VAR 0 4
43114: PUSH
43115: DOUBLE
43116: LD_INT 1
43118: DEC
43119: ST_TO_ADDR
43120: LD_VAR 0 2
43124: PUSH
43125: FOR_TO
43126: IFFALSE 43166
// if mreg [ i ] [ 1 ] = side then
43128: LD_VAR 0 2
43132: PUSH
43133: LD_VAR 0 4
43137: ARRAY
43138: PUSH
43139: LD_INT 1
43141: ARRAY
43142: PUSH
43143: LD_VAR 0 1
43147: EQUAL
43148: IFFALSE 43164
// begin m := m + 1 ;
43150: LD_ADDR_VAR 0 5
43154: PUSH
43155: LD_VAR 0 5
43159: PUSH
43160: LD_INT 1
43162: PLUS
43163: ST_TO_ADDR
// end ;
43164: GO 43125
43166: POP
43167: POP
// result := m ;
43168: LD_ADDR_VAR 0 3
43172: PUSH
43173: LD_VAR 0 5
43177: ST_TO_ADDR
// end ;
43178: LD_VAR 0 3
43182: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43183: LD_INT 0
43185: PPUSH
43186: PPUSH
// result := 0 ;
43187: LD_ADDR_VAR 0 3
43191: PUSH
43192: LD_INT 0
43194: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43195: LD_ADDR_VAR 0 4
43199: PUSH
43200: DOUBLE
43201: LD_INT 1
43203: DEC
43204: ST_TO_ADDR
43205: LD_EXP 53
43209: PUSH
43210: FOR_TO
43211: IFFALSE 43273
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43213: LD_EXP 53
43217: PUSH
43218: LD_VAR 0 4
43222: ARRAY
43223: PUSH
43224: LD_INT 1
43226: ARRAY
43227: PUSH
43228: LD_VAR 0 1
43232: EQUAL
43233: PUSH
43234: LD_EXP 53
43238: PUSH
43239: LD_VAR 0 4
43243: ARRAY
43244: PUSH
43245: LD_INT 2
43247: ARRAY
43248: PUSH
43249: LD_VAR 0 2
43253: EQUAL
43254: AND
43255: IFFALSE 43271
// begin result := result + 1 ;
43257: LD_ADDR_VAR 0 3
43261: PUSH
43262: LD_VAR 0 3
43266: PUSH
43267: LD_INT 1
43269: PLUS
43270: ST_TO_ADDR
// end ;
43271: GO 43210
43273: POP
43274: POP
// end ; end_of_file end_of_file
43275: LD_VAR 0 3
43279: RET
// every 0 0$1 do
43280: GO 43282
43282: DISABLE
// begin enable ;
43283: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
43284: LD_STRING updateTimer(
43286: PUSH
43287: LD_OWVAR 1
43291: STR
43292: PUSH
43293: LD_STRING );
43295: STR
43296: PPUSH
43297: CALL_OW 559
// end ;
43301: END
// export function SOS_MapStart ( ) ; begin
43302: LD_INT 0
43304: PPUSH
// if streamModeActive then
43305: LD_EXP 73
43309: IFFALSE 43318
// DefineStreamItems ( true ) ;
43311: LD_INT 1
43313: PPUSH
43314: CALL 44972 0 1
// UpdateFactoryWaypoints ( ) ;
43318: CALL 57833 0 0
// UpdateWarehouseGatheringPoints ( ) ;
43322: CALL 58090 0 0
// end ;
43326: LD_VAR 0 1
43330: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
43331: LD_INT 0
43333: PPUSH
// if p2 = 100 then
43334: LD_VAR 0 2
43338: PUSH
43339: LD_INT 100
43341: EQUAL
43342: IFFALSE 44345
// begin if not StreamModeActive then
43344: LD_EXP 73
43348: NOT
43349: IFFALSE 43359
// StreamModeActive := true ;
43351: LD_ADDR_EXP 73
43355: PUSH
43356: LD_INT 1
43358: ST_TO_ADDR
// if p3 = 0 then
43359: LD_VAR 0 3
43363: PUSH
43364: LD_INT 0
43366: EQUAL
43367: IFFALSE 43373
// InitStreamMode ;
43369: CALL 44508 0 0
// if p3 = 1 then
43373: LD_VAR 0 3
43377: PUSH
43378: LD_INT 1
43380: EQUAL
43381: IFFALSE 43391
// sRocket := true ;
43383: LD_ADDR_EXP 78
43387: PUSH
43388: LD_INT 1
43390: ST_TO_ADDR
// if p3 = 2 then
43391: LD_VAR 0 3
43395: PUSH
43396: LD_INT 2
43398: EQUAL
43399: IFFALSE 43409
// sSpeed := true ;
43401: LD_ADDR_EXP 77
43405: PUSH
43406: LD_INT 1
43408: ST_TO_ADDR
// if p3 = 3 then
43409: LD_VAR 0 3
43413: PUSH
43414: LD_INT 3
43416: EQUAL
43417: IFFALSE 43427
// sEngine := true ;
43419: LD_ADDR_EXP 79
43423: PUSH
43424: LD_INT 1
43426: ST_TO_ADDR
// if p3 = 4 then
43427: LD_VAR 0 3
43431: PUSH
43432: LD_INT 4
43434: EQUAL
43435: IFFALSE 43445
// sSpec := true ;
43437: LD_ADDR_EXP 76
43441: PUSH
43442: LD_INT 1
43444: ST_TO_ADDR
// if p3 = 5 then
43445: LD_VAR 0 3
43449: PUSH
43450: LD_INT 5
43452: EQUAL
43453: IFFALSE 43463
// sLevel := true ;
43455: LD_ADDR_EXP 80
43459: PUSH
43460: LD_INT 1
43462: ST_TO_ADDR
// if p3 = 6 then
43463: LD_VAR 0 3
43467: PUSH
43468: LD_INT 6
43470: EQUAL
43471: IFFALSE 43481
// sArmoury := true ;
43473: LD_ADDR_EXP 81
43477: PUSH
43478: LD_INT 1
43480: ST_TO_ADDR
// if p3 = 7 then
43481: LD_VAR 0 3
43485: PUSH
43486: LD_INT 7
43488: EQUAL
43489: IFFALSE 43499
// sRadar := true ;
43491: LD_ADDR_EXP 82
43495: PUSH
43496: LD_INT 1
43498: ST_TO_ADDR
// if p3 = 8 then
43499: LD_VAR 0 3
43503: PUSH
43504: LD_INT 8
43506: EQUAL
43507: IFFALSE 43517
// sBunker := true ;
43509: LD_ADDR_EXP 83
43513: PUSH
43514: LD_INT 1
43516: ST_TO_ADDR
// if p3 = 9 then
43517: LD_VAR 0 3
43521: PUSH
43522: LD_INT 9
43524: EQUAL
43525: IFFALSE 43535
// sHack := true ;
43527: LD_ADDR_EXP 84
43531: PUSH
43532: LD_INT 1
43534: ST_TO_ADDR
// if p3 = 10 then
43535: LD_VAR 0 3
43539: PUSH
43540: LD_INT 10
43542: EQUAL
43543: IFFALSE 43553
// sFire := true ;
43545: LD_ADDR_EXP 85
43549: PUSH
43550: LD_INT 1
43552: ST_TO_ADDR
// if p3 = 11 then
43553: LD_VAR 0 3
43557: PUSH
43558: LD_INT 11
43560: EQUAL
43561: IFFALSE 43571
// sRefresh := true ;
43563: LD_ADDR_EXP 86
43567: PUSH
43568: LD_INT 1
43570: ST_TO_ADDR
// if p3 = 12 then
43571: LD_VAR 0 3
43575: PUSH
43576: LD_INT 12
43578: EQUAL
43579: IFFALSE 43589
// sExp := true ;
43581: LD_ADDR_EXP 87
43585: PUSH
43586: LD_INT 1
43588: ST_TO_ADDR
// if p3 = 13 then
43589: LD_VAR 0 3
43593: PUSH
43594: LD_INT 13
43596: EQUAL
43597: IFFALSE 43607
// sDepot := true ;
43599: LD_ADDR_EXP 88
43603: PUSH
43604: LD_INT 1
43606: ST_TO_ADDR
// if p3 = 14 then
43607: LD_VAR 0 3
43611: PUSH
43612: LD_INT 14
43614: EQUAL
43615: IFFALSE 43625
// sFlag := true ;
43617: LD_ADDR_EXP 89
43621: PUSH
43622: LD_INT 1
43624: ST_TO_ADDR
// if p3 = 15 then
43625: LD_VAR 0 3
43629: PUSH
43630: LD_INT 15
43632: EQUAL
43633: IFFALSE 43643
// sKamikadze := true ;
43635: LD_ADDR_EXP 97
43639: PUSH
43640: LD_INT 1
43642: ST_TO_ADDR
// if p3 = 16 then
43643: LD_VAR 0 3
43647: PUSH
43648: LD_INT 16
43650: EQUAL
43651: IFFALSE 43661
// sTroll := true ;
43653: LD_ADDR_EXP 98
43657: PUSH
43658: LD_INT 1
43660: ST_TO_ADDR
// if p3 = 17 then
43661: LD_VAR 0 3
43665: PUSH
43666: LD_INT 17
43668: EQUAL
43669: IFFALSE 43679
// sSlow := true ;
43671: LD_ADDR_EXP 99
43675: PUSH
43676: LD_INT 1
43678: ST_TO_ADDR
// if p3 = 18 then
43679: LD_VAR 0 3
43683: PUSH
43684: LD_INT 18
43686: EQUAL
43687: IFFALSE 43697
// sLack := true ;
43689: LD_ADDR_EXP 100
43693: PUSH
43694: LD_INT 1
43696: ST_TO_ADDR
// if p3 = 19 then
43697: LD_VAR 0 3
43701: PUSH
43702: LD_INT 19
43704: EQUAL
43705: IFFALSE 43715
// sTank := true ;
43707: LD_ADDR_EXP 102
43711: PUSH
43712: LD_INT 1
43714: ST_TO_ADDR
// if p3 = 20 then
43715: LD_VAR 0 3
43719: PUSH
43720: LD_INT 20
43722: EQUAL
43723: IFFALSE 43733
// sRemote := true ;
43725: LD_ADDR_EXP 103
43729: PUSH
43730: LD_INT 1
43732: ST_TO_ADDR
// if p3 = 21 then
43733: LD_VAR 0 3
43737: PUSH
43738: LD_INT 21
43740: EQUAL
43741: IFFALSE 43751
// sPowell := true ;
43743: LD_ADDR_EXP 104
43747: PUSH
43748: LD_INT 1
43750: ST_TO_ADDR
// if p3 = 22 then
43751: LD_VAR 0 3
43755: PUSH
43756: LD_INT 22
43758: EQUAL
43759: IFFALSE 43769
// sTeleport := true ;
43761: LD_ADDR_EXP 107
43765: PUSH
43766: LD_INT 1
43768: ST_TO_ADDR
// if p3 = 23 then
43769: LD_VAR 0 3
43773: PUSH
43774: LD_INT 23
43776: EQUAL
43777: IFFALSE 43787
// sOilTower := true ;
43779: LD_ADDR_EXP 109
43783: PUSH
43784: LD_INT 1
43786: ST_TO_ADDR
// if p3 = 24 then
43787: LD_VAR 0 3
43791: PUSH
43792: LD_INT 24
43794: EQUAL
43795: IFFALSE 43805
// sShovel := true ;
43797: LD_ADDR_EXP 110
43801: PUSH
43802: LD_INT 1
43804: ST_TO_ADDR
// if p3 = 25 then
43805: LD_VAR 0 3
43809: PUSH
43810: LD_INT 25
43812: EQUAL
43813: IFFALSE 43823
// sSheik := true ;
43815: LD_ADDR_EXP 111
43819: PUSH
43820: LD_INT 1
43822: ST_TO_ADDR
// if p3 = 26 then
43823: LD_VAR 0 3
43827: PUSH
43828: LD_INT 26
43830: EQUAL
43831: IFFALSE 43841
// sEarthquake := true ;
43833: LD_ADDR_EXP 113
43837: PUSH
43838: LD_INT 1
43840: ST_TO_ADDR
// if p3 = 27 then
43841: LD_VAR 0 3
43845: PUSH
43846: LD_INT 27
43848: EQUAL
43849: IFFALSE 43859
// sAI := true ;
43851: LD_ADDR_EXP 114
43855: PUSH
43856: LD_INT 1
43858: ST_TO_ADDR
// if p3 = 28 then
43859: LD_VAR 0 3
43863: PUSH
43864: LD_INT 28
43866: EQUAL
43867: IFFALSE 43877
// sCargo := true ;
43869: LD_ADDR_EXP 117
43873: PUSH
43874: LD_INT 1
43876: ST_TO_ADDR
// if p3 = 29 then
43877: LD_VAR 0 3
43881: PUSH
43882: LD_INT 29
43884: EQUAL
43885: IFFALSE 43895
// sDLaser := true ;
43887: LD_ADDR_EXP 118
43891: PUSH
43892: LD_INT 1
43894: ST_TO_ADDR
// if p3 = 30 then
43895: LD_VAR 0 3
43899: PUSH
43900: LD_INT 30
43902: EQUAL
43903: IFFALSE 43913
// sExchange := true ;
43905: LD_ADDR_EXP 119
43909: PUSH
43910: LD_INT 1
43912: ST_TO_ADDR
// if p3 = 31 then
43913: LD_VAR 0 3
43917: PUSH
43918: LD_INT 31
43920: EQUAL
43921: IFFALSE 43931
// sFac := true ;
43923: LD_ADDR_EXP 120
43927: PUSH
43928: LD_INT 1
43930: ST_TO_ADDR
// if p3 = 32 then
43931: LD_VAR 0 3
43935: PUSH
43936: LD_INT 32
43938: EQUAL
43939: IFFALSE 43949
// sPower := true ;
43941: LD_ADDR_EXP 121
43945: PUSH
43946: LD_INT 1
43948: ST_TO_ADDR
// if p3 = 33 then
43949: LD_VAR 0 3
43953: PUSH
43954: LD_INT 33
43956: EQUAL
43957: IFFALSE 43967
// sRandom := true ;
43959: LD_ADDR_EXP 122
43963: PUSH
43964: LD_INT 1
43966: ST_TO_ADDR
// if p3 = 34 then
43967: LD_VAR 0 3
43971: PUSH
43972: LD_INT 34
43974: EQUAL
43975: IFFALSE 43985
// sShield := true ;
43977: LD_ADDR_EXP 123
43981: PUSH
43982: LD_INT 1
43984: ST_TO_ADDR
// if p3 = 35 then
43985: LD_VAR 0 3
43989: PUSH
43990: LD_INT 35
43992: EQUAL
43993: IFFALSE 44003
// sTime := true ;
43995: LD_ADDR_EXP 124
43999: PUSH
44000: LD_INT 1
44002: ST_TO_ADDR
// if p3 = 36 then
44003: LD_VAR 0 3
44007: PUSH
44008: LD_INT 36
44010: EQUAL
44011: IFFALSE 44021
// sTools := true ;
44013: LD_ADDR_EXP 125
44017: PUSH
44018: LD_INT 1
44020: ST_TO_ADDR
// if p3 = 101 then
44021: LD_VAR 0 3
44025: PUSH
44026: LD_INT 101
44028: EQUAL
44029: IFFALSE 44039
// sSold := true ;
44031: LD_ADDR_EXP 90
44035: PUSH
44036: LD_INT 1
44038: ST_TO_ADDR
// if p3 = 102 then
44039: LD_VAR 0 3
44043: PUSH
44044: LD_INT 102
44046: EQUAL
44047: IFFALSE 44057
// sDiff := true ;
44049: LD_ADDR_EXP 91
44053: PUSH
44054: LD_INT 1
44056: ST_TO_ADDR
// if p3 = 103 then
44057: LD_VAR 0 3
44061: PUSH
44062: LD_INT 103
44064: EQUAL
44065: IFFALSE 44075
// sFog := true ;
44067: LD_ADDR_EXP 94
44071: PUSH
44072: LD_INT 1
44074: ST_TO_ADDR
// if p3 = 104 then
44075: LD_VAR 0 3
44079: PUSH
44080: LD_INT 104
44082: EQUAL
44083: IFFALSE 44093
// sReset := true ;
44085: LD_ADDR_EXP 95
44089: PUSH
44090: LD_INT 1
44092: ST_TO_ADDR
// if p3 = 105 then
44093: LD_VAR 0 3
44097: PUSH
44098: LD_INT 105
44100: EQUAL
44101: IFFALSE 44111
// sSun := true ;
44103: LD_ADDR_EXP 96
44107: PUSH
44108: LD_INT 1
44110: ST_TO_ADDR
// if p3 = 106 then
44111: LD_VAR 0 3
44115: PUSH
44116: LD_INT 106
44118: EQUAL
44119: IFFALSE 44129
// sTiger := true ;
44121: LD_ADDR_EXP 92
44125: PUSH
44126: LD_INT 1
44128: ST_TO_ADDR
// if p3 = 107 then
44129: LD_VAR 0 3
44133: PUSH
44134: LD_INT 107
44136: EQUAL
44137: IFFALSE 44147
// sBomb := true ;
44139: LD_ADDR_EXP 93
44143: PUSH
44144: LD_INT 1
44146: ST_TO_ADDR
// if p3 = 108 then
44147: LD_VAR 0 3
44151: PUSH
44152: LD_INT 108
44154: EQUAL
44155: IFFALSE 44165
// sWound := true ;
44157: LD_ADDR_EXP 101
44161: PUSH
44162: LD_INT 1
44164: ST_TO_ADDR
// if p3 = 109 then
44165: LD_VAR 0 3
44169: PUSH
44170: LD_INT 109
44172: EQUAL
44173: IFFALSE 44183
// sBetray := true ;
44175: LD_ADDR_EXP 105
44179: PUSH
44180: LD_INT 1
44182: ST_TO_ADDR
// if p3 = 110 then
44183: LD_VAR 0 3
44187: PUSH
44188: LD_INT 110
44190: EQUAL
44191: IFFALSE 44201
// sContamin := true ;
44193: LD_ADDR_EXP 106
44197: PUSH
44198: LD_INT 1
44200: ST_TO_ADDR
// if p3 = 111 then
44201: LD_VAR 0 3
44205: PUSH
44206: LD_INT 111
44208: EQUAL
44209: IFFALSE 44219
// sOil := true ;
44211: LD_ADDR_EXP 108
44215: PUSH
44216: LD_INT 1
44218: ST_TO_ADDR
// if p3 = 112 then
44219: LD_VAR 0 3
44223: PUSH
44224: LD_INT 112
44226: EQUAL
44227: IFFALSE 44237
// sStu := true ;
44229: LD_ADDR_EXP 112
44233: PUSH
44234: LD_INT 1
44236: ST_TO_ADDR
// if p3 = 113 then
44237: LD_VAR 0 3
44241: PUSH
44242: LD_INT 113
44244: EQUAL
44245: IFFALSE 44255
// sBazooka := true ;
44247: LD_ADDR_EXP 115
44251: PUSH
44252: LD_INT 1
44254: ST_TO_ADDR
// if p3 = 114 then
44255: LD_VAR 0 3
44259: PUSH
44260: LD_INT 114
44262: EQUAL
44263: IFFALSE 44273
// sMortar := true ;
44265: LD_ADDR_EXP 116
44269: PUSH
44270: LD_INT 1
44272: ST_TO_ADDR
// if p3 = 115 then
44273: LD_VAR 0 3
44277: PUSH
44278: LD_INT 115
44280: EQUAL
44281: IFFALSE 44291
// sRanger := true ;
44283: LD_ADDR_EXP 126
44287: PUSH
44288: LD_INT 1
44290: ST_TO_ADDR
// if p3 = 116 then
44291: LD_VAR 0 3
44295: PUSH
44296: LD_INT 116
44298: EQUAL
44299: IFFALSE 44309
// sComputer := true ;
44301: LD_ADDR_EXP 127
44305: PUSH
44306: LD_INT 1
44308: ST_TO_ADDR
// if p3 = 117 then
44309: LD_VAR 0 3
44313: PUSH
44314: LD_INT 117
44316: EQUAL
44317: IFFALSE 44327
// s30 := true ;
44319: LD_ADDR_EXP 128
44323: PUSH
44324: LD_INT 1
44326: ST_TO_ADDR
// if p3 = 118 then
44327: LD_VAR 0 3
44331: PUSH
44332: LD_INT 118
44334: EQUAL
44335: IFFALSE 44345
// s60 := true ;
44337: LD_ADDR_EXP 129
44341: PUSH
44342: LD_INT 1
44344: ST_TO_ADDR
// end ; if p2 = 101 then
44345: LD_VAR 0 2
44349: PUSH
44350: LD_INT 101
44352: EQUAL
44353: IFFALSE 44481
// begin case p3 of 1 :
44355: LD_VAR 0 3
44359: PUSH
44360: LD_INT 1
44362: DOUBLE
44363: EQUAL
44364: IFTRUE 44368
44366: GO 44375
44368: POP
// hHackUnlimitedResources ; 2 :
44369: CALL 56579 0 0
44373: GO 44481
44375: LD_INT 2
44377: DOUBLE
44378: EQUAL
44379: IFTRUE 44383
44381: GO 44390
44383: POP
// hHackSetLevel10 ; 3 :
44384: CALL 56712 0 0
44388: GO 44481
44390: LD_INT 3
44392: DOUBLE
44393: EQUAL
44394: IFTRUE 44398
44396: GO 44405
44398: POP
// hHackSetLevel10YourUnits ; 4 :
44399: CALL 56797 0 0
44403: GO 44481
44405: LD_INT 4
44407: DOUBLE
44408: EQUAL
44409: IFTRUE 44413
44411: GO 44420
44413: POP
// hHackInvincible ; 5 :
44414: CALL 57245 0 0
44418: GO 44481
44420: LD_INT 5
44422: DOUBLE
44423: EQUAL
44424: IFTRUE 44428
44426: GO 44435
44428: POP
// hHackInvisible ; 6 :
44429: CALL 57356 0 0
44433: GO 44481
44435: LD_INT 6
44437: DOUBLE
44438: EQUAL
44439: IFTRUE 44443
44441: GO 44450
44443: POP
// hHackChangeYourSide ; 7 :
44444: CALL 57413 0 0
44448: GO 44481
44450: LD_INT 7
44452: DOUBLE
44453: EQUAL
44454: IFTRUE 44458
44456: GO 44465
44458: POP
// hHackChangeUnitSide ; 8 :
44459: CALL 57455 0 0
44463: GO 44481
44465: LD_INT 8
44467: DOUBLE
44468: EQUAL
44469: IFTRUE 44473
44471: GO 44480
44473: POP
// hHackFog ; end ;
44474: CALL 57556 0 0
44478: GO 44481
44480: POP
// end ; end ;
44481: LD_VAR 0 7
44485: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
44486: GO 44488
44488: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44489: LD_STRING initStreamRollete();
44491: PPUSH
44492: CALL_OW 559
// InitStreamMode ;
44496: CALL 44508 0 0
// DefineStreamItems ( false ) ;
44500: LD_INT 0
44502: PPUSH
44503: CALL 44972 0 1
// end ;
44507: END
// function InitStreamMode ; begin
44508: LD_INT 0
44510: PPUSH
// streamModeActive := false ;
44511: LD_ADDR_EXP 73
44515: PUSH
44516: LD_INT 0
44518: ST_TO_ADDR
// normalCounter := 36 ;
44519: LD_ADDR_EXP 74
44523: PUSH
44524: LD_INT 36
44526: ST_TO_ADDR
// hardcoreCounter := 18 ;
44527: LD_ADDR_EXP 75
44531: PUSH
44532: LD_INT 18
44534: ST_TO_ADDR
// sRocket := false ;
44535: LD_ADDR_EXP 78
44539: PUSH
44540: LD_INT 0
44542: ST_TO_ADDR
// sSpeed := false ;
44543: LD_ADDR_EXP 77
44547: PUSH
44548: LD_INT 0
44550: ST_TO_ADDR
// sEngine := false ;
44551: LD_ADDR_EXP 79
44555: PUSH
44556: LD_INT 0
44558: ST_TO_ADDR
// sSpec := false ;
44559: LD_ADDR_EXP 76
44563: PUSH
44564: LD_INT 0
44566: ST_TO_ADDR
// sLevel := false ;
44567: LD_ADDR_EXP 80
44571: PUSH
44572: LD_INT 0
44574: ST_TO_ADDR
// sArmoury := false ;
44575: LD_ADDR_EXP 81
44579: PUSH
44580: LD_INT 0
44582: ST_TO_ADDR
// sRadar := false ;
44583: LD_ADDR_EXP 82
44587: PUSH
44588: LD_INT 0
44590: ST_TO_ADDR
// sBunker := false ;
44591: LD_ADDR_EXP 83
44595: PUSH
44596: LD_INT 0
44598: ST_TO_ADDR
// sHack := false ;
44599: LD_ADDR_EXP 84
44603: PUSH
44604: LD_INT 0
44606: ST_TO_ADDR
// sFire := false ;
44607: LD_ADDR_EXP 85
44611: PUSH
44612: LD_INT 0
44614: ST_TO_ADDR
// sRefresh := false ;
44615: LD_ADDR_EXP 86
44619: PUSH
44620: LD_INT 0
44622: ST_TO_ADDR
// sExp := false ;
44623: LD_ADDR_EXP 87
44627: PUSH
44628: LD_INT 0
44630: ST_TO_ADDR
// sDepot := false ;
44631: LD_ADDR_EXP 88
44635: PUSH
44636: LD_INT 0
44638: ST_TO_ADDR
// sFlag := false ;
44639: LD_ADDR_EXP 89
44643: PUSH
44644: LD_INT 0
44646: ST_TO_ADDR
// sKamikadze := false ;
44647: LD_ADDR_EXP 97
44651: PUSH
44652: LD_INT 0
44654: ST_TO_ADDR
// sTroll := false ;
44655: LD_ADDR_EXP 98
44659: PUSH
44660: LD_INT 0
44662: ST_TO_ADDR
// sSlow := false ;
44663: LD_ADDR_EXP 99
44667: PUSH
44668: LD_INT 0
44670: ST_TO_ADDR
// sLack := false ;
44671: LD_ADDR_EXP 100
44675: PUSH
44676: LD_INT 0
44678: ST_TO_ADDR
// sTank := false ;
44679: LD_ADDR_EXP 102
44683: PUSH
44684: LD_INT 0
44686: ST_TO_ADDR
// sRemote := false ;
44687: LD_ADDR_EXP 103
44691: PUSH
44692: LD_INT 0
44694: ST_TO_ADDR
// sPowell := false ;
44695: LD_ADDR_EXP 104
44699: PUSH
44700: LD_INT 0
44702: ST_TO_ADDR
// sTeleport := false ;
44703: LD_ADDR_EXP 107
44707: PUSH
44708: LD_INT 0
44710: ST_TO_ADDR
// sOilTower := false ;
44711: LD_ADDR_EXP 109
44715: PUSH
44716: LD_INT 0
44718: ST_TO_ADDR
// sShovel := false ;
44719: LD_ADDR_EXP 110
44723: PUSH
44724: LD_INT 0
44726: ST_TO_ADDR
// sSheik := false ;
44727: LD_ADDR_EXP 111
44731: PUSH
44732: LD_INT 0
44734: ST_TO_ADDR
// sEarthquake := false ;
44735: LD_ADDR_EXP 113
44739: PUSH
44740: LD_INT 0
44742: ST_TO_ADDR
// sAI := false ;
44743: LD_ADDR_EXP 114
44747: PUSH
44748: LD_INT 0
44750: ST_TO_ADDR
// sCargo := false ;
44751: LD_ADDR_EXP 117
44755: PUSH
44756: LD_INT 0
44758: ST_TO_ADDR
// sDLaser := false ;
44759: LD_ADDR_EXP 118
44763: PUSH
44764: LD_INT 0
44766: ST_TO_ADDR
// sExchange := false ;
44767: LD_ADDR_EXP 119
44771: PUSH
44772: LD_INT 0
44774: ST_TO_ADDR
// sFac := false ;
44775: LD_ADDR_EXP 120
44779: PUSH
44780: LD_INT 0
44782: ST_TO_ADDR
// sPower := false ;
44783: LD_ADDR_EXP 121
44787: PUSH
44788: LD_INT 0
44790: ST_TO_ADDR
// sRandom := false ;
44791: LD_ADDR_EXP 122
44795: PUSH
44796: LD_INT 0
44798: ST_TO_ADDR
// sShield := false ;
44799: LD_ADDR_EXP 123
44803: PUSH
44804: LD_INT 0
44806: ST_TO_ADDR
// sTime := false ;
44807: LD_ADDR_EXP 124
44811: PUSH
44812: LD_INT 0
44814: ST_TO_ADDR
// sTools := false ;
44815: LD_ADDR_EXP 125
44819: PUSH
44820: LD_INT 0
44822: ST_TO_ADDR
// sSold := false ;
44823: LD_ADDR_EXP 90
44827: PUSH
44828: LD_INT 0
44830: ST_TO_ADDR
// sDiff := false ;
44831: LD_ADDR_EXP 91
44835: PUSH
44836: LD_INT 0
44838: ST_TO_ADDR
// sFog := false ;
44839: LD_ADDR_EXP 94
44843: PUSH
44844: LD_INT 0
44846: ST_TO_ADDR
// sReset := false ;
44847: LD_ADDR_EXP 95
44851: PUSH
44852: LD_INT 0
44854: ST_TO_ADDR
// sSun := false ;
44855: LD_ADDR_EXP 96
44859: PUSH
44860: LD_INT 0
44862: ST_TO_ADDR
// sTiger := false ;
44863: LD_ADDR_EXP 92
44867: PUSH
44868: LD_INT 0
44870: ST_TO_ADDR
// sBomb := false ;
44871: LD_ADDR_EXP 93
44875: PUSH
44876: LD_INT 0
44878: ST_TO_ADDR
// sWound := false ;
44879: LD_ADDR_EXP 101
44883: PUSH
44884: LD_INT 0
44886: ST_TO_ADDR
// sBetray := false ;
44887: LD_ADDR_EXP 105
44891: PUSH
44892: LD_INT 0
44894: ST_TO_ADDR
// sContamin := false ;
44895: LD_ADDR_EXP 106
44899: PUSH
44900: LD_INT 0
44902: ST_TO_ADDR
// sOil := false ;
44903: LD_ADDR_EXP 108
44907: PUSH
44908: LD_INT 0
44910: ST_TO_ADDR
// sStu := false ;
44911: LD_ADDR_EXP 112
44915: PUSH
44916: LD_INT 0
44918: ST_TO_ADDR
// sBazooka := false ;
44919: LD_ADDR_EXP 115
44923: PUSH
44924: LD_INT 0
44926: ST_TO_ADDR
// sMortar := false ;
44927: LD_ADDR_EXP 116
44931: PUSH
44932: LD_INT 0
44934: ST_TO_ADDR
// sRanger := false ;
44935: LD_ADDR_EXP 126
44939: PUSH
44940: LD_INT 0
44942: ST_TO_ADDR
// sComputer := false ;
44943: LD_ADDR_EXP 127
44947: PUSH
44948: LD_INT 0
44950: ST_TO_ADDR
// s30 := false ;
44951: LD_ADDR_EXP 128
44955: PUSH
44956: LD_INT 0
44958: ST_TO_ADDR
// s60 := false ;
44959: LD_ADDR_EXP 129
44963: PUSH
44964: LD_INT 0
44966: ST_TO_ADDR
// end ;
44967: LD_VAR 0 1
44971: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
44972: LD_INT 0
44974: PPUSH
44975: PPUSH
44976: PPUSH
44977: PPUSH
44978: PPUSH
44979: PPUSH
44980: PPUSH
// result := [ ] ;
44981: LD_ADDR_VAR 0 2
44985: PUSH
44986: EMPTY
44987: ST_TO_ADDR
// if campaign_id = 1 then
44988: LD_OWVAR 69
44992: PUSH
44993: LD_INT 1
44995: EQUAL
44996: IFFALSE 48162
// begin case mission_number of 1 :
44998: LD_OWVAR 70
45002: PUSH
45003: LD_INT 1
45005: DOUBLE
45006: EQUAL
45007: IFTRUE 45011
45009: GO 45087
45011: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
45012: LD_ADDR_VAR 0 2
45016: PUSH
45017: LD_INT 2
45019: PUSH
45020: LD_INT 4
45022: PUSH
45023: LD_INT 11
45025: PUSH
45026: LD_INT 12
45028: PUSH
45029: LD_INT 15
45031: PUSH
45032: LD_INT 16
45034: PUSH
45035: LD_INT 22
45037: PUSH
45038: LD_INT 23
45040: PUSH
45041: LD_INT 26
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: LIST
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 101
45057: PUSH
45058: LD_INT 102
45060: PUSH
45061: LD_INT 106
45063: PUSH
45064: LD_INT 116
45066: PUSH
45067: LD_INT 117
45069: PUSH
45070: LD_INT 118
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: ST_TO_ADDR
45085: GO 48160
45087: LD_INT 2
45089: DOUBLE
45090: EQUAL
45091: IFTRUE 45095
45093: GO 45179
45095: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
45096: LD_ADDR_VAR 0 2
45100: PUSH
45101: LD_INT 2
45103: PUSH
45104: LD_INT 4
45106: PUSH
45107: LD_INT 11
45109: PUSH
45110: LD_INT 12
45112: PUSH
45113: LD_INT 15
45115: PUSH
45116: LD_INT 16
45118: PUSH
45119: LD_INT 22
45121: PUSH
45122: LD_INT 23
45124: PUSH
45125: LD_INT 26
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: PUSH
45139: LD_INT 101
45141: PUSH
45142: LD_INT 102
45144: PUSH
45145: LD_INT 105
45147: PUSH
45148: LD_INT 106
45150: PUSH
45151: LD_INT 108
45153: PUSH
45154: LD_INT 116
45156: PUSH
45157: LD_INT 117
45159: PUSH
45160: LD_INT 118
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: ST_TO_ADDR
45177: GO 48160
45179: LD_INT 3
45181: DOUBLE
45182: EQUAL
45183: IFTRUE 45187
45185: GO 45275
45187: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
45188: LD_ADDR_VAR 0 2
45192: PUSH
45193: LD_INT 2
45195: PUSH
45196: LD_INT 4
45198: PUSH
45199: LD_INT 5
45201: PUSH
45202: LD_INT 11
45204: PUSH
45205: LD_INT 12
45207: PUSH
45208: LD_INT 15
45210: PUSH
45211: LD_INT 16
45213: PUSH
45214: LD_INT 22
45216: PUSH
45217: LD_INT 26
45219: PUSH
45220: LD_INT 36
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: LIST
45227: LIST
45228: LIST
45229: LIST
45230: LIST
45231: LIST
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 101
45237: PUSH
45238: LD_INT 102
45240: PUSH
45241: LD_INT 105
45243: PUSH
45244: LD_INT 106
45246: PUSH
45247: LD_INT 108
45249: PUSH
45250: LD_INT 116
45252: PUSH
45253: LD_INT 117
45255: PUSH
45256: LD_INT 118
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: ST_TO_ADDR
45273: GO 48160
45275: LD_INT 4
45277: DOUBLE
45278: EQUAL
45279: IFTRUE 45283
45281: GO 45379
45283: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
45284: LD_ADDR_VAR 0 2
45288: PUSH
45289: LD_INT 2
45291: PUSH
45292: LD_INT 4
45294: PUSH
45295: LD_INT 5
45297: PUSH
45298: LD_INT 8
45300: PUSH
45301: LD_INT 11
45303: PUSH
45304: LD_INT 12
45306: PUSH
45307: LD_INT 15
45309: PUSH
45310: LD_INT 16
45312: PUSH
45313: LD_INT 22
45315: PUSH
45316: LD_INT 23
45318: PUSH
45319: LD_INT 26
45321: PUSH
45322: LD_INT 36
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: PUSH
45339: LD_INT 101
45341: PUSH
45342: LD_INT 102
45344: PUSH
45345: LD_INT 105
45347: PUSH
45348: LD_INT 106
45350: PUSH
45351: LD_INT 108
45353: PUSH
45354: LD_INT 116
45356: PUSH
45357: LD_INT 117
45359: PUSH
45360: LD_INT 118
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: ST_TO_ADDR
45377: GO 48160
45379: LD_INT 5
45381: DOUBLE
45382: EQUAL
45383: IFTRUE 45387
45385: GO 45499
45387: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
45388: LD_ADDR_VAR 0 2
45392: PUSH
45393: LD_INT 2
45395: PUSH
45396: LD_INT 4
45398: PUSH
45399: LD_INT 5
45401: PUSH
45402: LD_INT 6
45404: PUSH
45405: LD_INT 8
45407: PUSH
45408: LD_INT 11
45410: PUSH
45411: LD_INT 12
45413: PUSH
45414: LD_INT 15
45416: PUSH
45417: LD_INT 16
45419: PUSH
45420: LD_INT 22
45422: PUSH
45423: LD_INT 23
45425: PUSH
45426: LD_INT 25
45428: PUSH
45429: LD_INT 26
45431: PUSH
45432: LD_INT 36
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 101
45453: PUSH
45454: LD_INT 102
45456: PUSH
45457: LD_INT 105
45459: PUSH
45460: LD_INT 106
45462: PUSH
45463: LD_INT 108
45465: PUSH
45466: LD_INT 109
45468: PUSH
45469: LD_INT 112
45471: PUSH
45472: LD_INT 116
45474: PUSH
45475: LD_INT 117
45477: PUSH
45478: LD_INT 118
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: ST_TO_ADDR
45497: GO 48160
45499: LD_INT 6
45501: DOUBLE
45502: EQUAL
45503: IFTRUE 45507
45505: GO 45639
45507: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
45508: LD_ADDR_VAR 0 2
45512: PUSH
45513: LD_INT 2
45515: PUSH
45516: LD_INT 4
45518: PUSH
45519: LD_INT 5
45521: PUSH
45522: LD_INT 6
45524: PUSH
45525: LD_INT 8
45527: PUSH
45528: LD_INT 11
45530: PUSH
45531: LD_INT 12
45533: PUSH
45534: LD_INT 15
45536: PUSH
45537: LD_INT 16
45539: PUSH
45540: LD_INT 20
45542: PUSH
45543: LD_INT 21
45545: PUSH
45546: LD_INT 22
45548: PUSH
45549: LD_INT 23
45551: PUSH
45552: LD_INT 25
45554: PUSH
45555: LD_INT 26
45557: PUSH
45558: LD_INT 30
45560: PUSH
45561: LD_INT 31
45563: PUSH
45564: LD_INT 32
45566: PUSH
45567: LD_INT 36
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 101
45593: PUSH
45594: LD_INT 102
45596: PUSH
45597: LD_INT 105
45599: PUSH
45600: LD_INT 106
45602: PUSH
45603: LD_INT 108
45605: PUSH
45606: LD_INT 109
45608: PUSH
45609: LD_INT 112
45611: PUSH
45612: LD_INT 116
45614: PUSH
45615: LD_INT 117
45617: PUSH
45618: LD_INT 118
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: ST_TO_ADDR
45637: GO 48160
45639: LD_INT 7
45641: DOUBLE
45642: EQUAL
45643: IFTRUE 45647
45645: GO 45759
45647: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
45648: LD_ADDR_VAR 0 2
45652: PUSH
45653: LD_INT 2
45655: PUSH
45656: LD_INT 4
45658: PUSH
45659: LD_INT 5
45661: PUSH
45662: LD_INT 7
45664: PUSH
45665: LD_INT 11
45667: PUSH
45668: LD_INT 12
45670: PUSH
45671: LD_INT 15
45673: PUSH
45674: LD_INT 16
45676: PUSH
45677: LD_INT 20
45679: PUSH
45680: LD_INT 21
45682: PUSH
45683: LD_INT 22
45685: PUSH
45686: LD_INT 23
45688: PUSH
45689: LD_INT 25
45691: PUSH
45692: LD_INT 26
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 101
45713: PUSH
45714: LD_INT 102
45716: PUSH
45717: LD_INT 103
45719: PUSH
45720: LD_INT 105
45722: PUSH
45723: LD_INT 106
45725: PUSH
45726: LD_INT 108
45728: PUSH
45729: LD_INT 112
45731: PUSH
45732: LD_INT 116
45734: PUSH
45735: LD_INT 117
45737: PUSH
45738: LD_INT 118
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: LIST
45745: LIST
45746: LIST
45747: LIST
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: ST_TO_ADDR
45757: GO 48160
45759: LD_INT 8
45761: DOUBLE
45762: EQUAL
45763: IFTRUE 45767
45765: GO 45907
45767: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
45768: LD_ADDR_VAR 0 2
45772: PUSH
45773: LD_INT 2
45775: PUSH
45776: LD_INT 4
45778: PUSH
45779: LD_INT 5
45781: PUSH
45782: LD_INT 6
45784: PUSH
45785: LD_INT 7
45787: PUSH
45788: LD_INT 8
45790: PUSH
45791: LD_INT 11
45793: PUSH
45794: LD_INT 12
45796: PUSH
45797: LD_INT 15
45799: PUSH
45800: LD_INT 16
45802: PUSH
45803: LD_INT 20
45805: PUSH
45806: LD_INT 21
45808: PUSH
45809: LD_INT 22
45811: PUSH
45812: LD_INT 23
45814: PUSH
45815: LD_INT 25
45817: PUSH
45818: LD_INT 26
45820: PUSH
45821: LD_INT 30
45823: PUSH
45824: LD_INT 31
45826: PUSH
45827: LD_INT 32
45829: PUSH
45830: LD_INT 36
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: PUSH
45855: LD_INT 101
45857: PUSH
45858: LD_INT 102
45860: PUSH
45861: LD_INT 103
45863: PUSH
45864: LD_INT 105
45866: PUSH
45867: LD_INT 106
45869: PUSH
45870: LD_INT 108
45872: PUSH
45873: LD_INT 109
45875: PUSH
45876: LD_INT 112
45878: PUSH
45879: LD_INT 116
45881: PUSH
45882: LD_INT 117
45884: PUSH
45885: LD_INT 118
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: ST_TO_ADDR
45905: GO 48160
45907: LD_INT 9
45909: DOUBLE
45910: EQUAL
45911: IFTRUE 45915
45913: GO 46063
45915: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
45916: LD_ADDR_VAR 0 2
45920: PUSH
45921: LD_INT 2
45923: PUSH
45924: LD_INT 4
45926: PUSH
45927: LD_INT 5
45929: PUSH
45930: LD_INT 6
45932: PUSH
45933: LD_INT 7
45935: PUSH
45936: LD_INT 8
45938: PUSH
45939: LD_INT 11
45941: PUSH
45942: LD_INT 12
45944: PUSH
45945: LD_INT 15
45947: PUSH
45948: LD_INT 16
45950: PUSH
45951: LD_INT 20
45953: PUSH
45954: LD_INT 21
45956: PUSH
45957: LD_INT 22
45959: PUSH
45960: LD_INT 23
45962: PUSH
45963: LD_INT 25
45965: PUSH
45966: LD_INT 26
45968: PUSH
45969: LD_INT 28
45971: PUSH
45972: LD_INT 30
45974: PUSH
45975: LD_INT 31
45977: PUSH
45978: LD_INT 32
45980: PUSH
45981: LD_INT 36
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: PUSH
46007: LD_INT 101
46009: PUSH
46010: LD_INT 102
46012: PUSH
46013: LD_INT 103
46015: PUSH
46016: LD_INT 105
46018: PUSH
46019: LD_INT 106
46021: PUSH
46022: LD_INT 108
46024: PUSH
46025: LD_INT 109
46027: PUSH
46028: LD_INT 112
46030: PUSH
46031: LD_INT 114
46033: PUSH
46034: LD_INT 116
46036: PUSH
46037: LD_INT 117
46039: PUSH
46040: LD_INT 118
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: ST_TO_ADDR
46061: GO 48160
46063: LD_INT 10
46065: DOUBLE
46066: EQUAL
46067: IFTRUE 46071
46069: GO 46267
46071: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
46072: LD_ADDR_VAR 0 2
46076: PUSH
46077: LD_INT 2
46079: PUSH
46080: LD_INT 4
46082: PUSH
46083: LD_INT 5
46085: PUSH
46086: LD_INT 6
46088: PUSH
46089: LD_INT 7
46091: PUSH
46092: LD_INT 8
46094: PUSH
46095: LD_INT 9
46097: PUSH
46098: LD_INT 10
46100: PUSH
46101: LD_INT 11
46103: PUSH
46104: LD_INT 12
46106: PUSH
46107: LD_INT 13
46109: PUSH
46110: LD_INT 14
46112: PUSH
46113: LD_INT 15
46115: PUSH
46116: LD_INT 16
46118: PUSH
46119: LD_INT 17
46121: PUSH
46122: LD_INT 18
46124: PUSH
46125: LD_INT 19
46127: PUSH
46128: LD_INT 20
46130: PUSH
46131: LD_INT 21
46133: PUSH
46134: LD_INT 22
46136: PUSH
46137: LD_INT 23
46139: PUSH
46140: LD_INT 24
46142: PUSH
46143: LD_INT 25
46145: PUSH
46146: LD_INT 26
46148: PUSH
46149: LD_INT 28
46151: PUSH
46152: LD_INT 30
46154: PUSH
46155: LD_INT 31
46157: PUSH
46158: LD_INT 32
46160: PUSH
46161: LD_INT 36
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: PUSH
46195: LD_INT 101
46197: PUSH
46198: LD_INT 102
46200: PUSH
46201: LD_INT 103
46203: PUSH
46204: LD_INT 104
46206: PUSH
46207: LD_INT 105
46209: PUSH
46210: LD_INT 106
46212: PUSH
46213: LD_INT 107
46215: PUSH
46216: LD_INT 108
46218: PUSH
46219: LD_INT 109
46221: PUSH
46222: LD_INT 110
46224: PUSH
46225: LD_INT 111
46227: PUSH
46228: LD_INT 112
46230: PUSH
46231: LD_INT 114
46233: PUSH
46234: LD_INT 116
46236: PUSH
46237: LD_INT 117
46239: PUSH
46240: LD_INT 118
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: LIST
46247: LIST
46248: LIST
46249: LIST
46250: LIST
46251: LIST
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: ST_TO_ADDR
46265: GO 48160
46267: LD_INT 11
46269: DOUBLE
46270: EQUAL
46271: IFTRUE 46275
46273: GO 46479
46275: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
46276: LD_ADDR_VAR 0 2
46280: PUSH
46281: LD_INT 2
46283: PUSH
46284: LD_INT 3
46286: PUSH
46287: LD_INT 4
46289: PUSH
46290: LD_INT 5
46292: PUSH
46293: LD_INT 6
46295: PUSH
46296: LD_INT 7
46298: PUSH
46299: LD_INT 8
46301: PUSH
46302: LD_INT 9
46304: PUSH
46305: LD_INT 10
46307: PUSH
46308: LD_INT 11
46310: PUSH
46311: LD_INT 12
46313: PUSH
46314: LD_INT 13
46316: PUSH
46317: LD_INT 14
46319: PUSH
46320: LD_INT 15
46322: PUSH
46323: LD_INT 16
46325: PUSH
46326: LD_INT 17
46328: PUSH
46329: LD_INT 18
46331: PUSH
46332: LD_INT 19
46334: PUSH
46335: LD_INT 20
46337: PUSH
46338: LD_INT 21
46340: PUSH
46341: LD_INT 22
46343: PUSH
46344: LD_INT 23
46346: PUSH
46347: LD_INT 24
46349: PUSH
46350: LD_INT 25
46352: PUSH
46353: LD_INT 26
46355: PUSH
46356: LD_INT 28
46358: PUSH
46359: LD_INT 30
46361: PUSH
46362: LD_INT 31
46364: PUSH
46365: LD_INT 32
46367: PUSH
46368: LD_INT 34
46370: PUSH
46371: LD_INT 36
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: PUSH
46407: LD_INT 101
46409: PUSH
46410: LD_INT 102
46412: PUSH
46413: LD_INT 103
46415: PUSH
46416: LD_INT 104
46418: PUSH
46419: LD_INT 105
46421: PUSH
46422: LD_INT 106
46424: PUSH
46425: LD_INT 107
46427: PUSH
46428: LD_INT 108
46430: PUSH
46431: LD_INT 109
46433: PUSH
46434: LD_INT 110
46436: PUSH
46437: LD_INT 111
46439: PUSH
46440: LD_INT 112
46442: PUSH
46443: LD_INT 114
46445: PUSH
46446: LD_INT 116
46448: PUSH
46449: LD_INT 117
46451: PUSH
46452: LD_INT 118
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: LIST
46464: LIST
46465: LIST
46466: LIST
46467: LIST
46468: LIST
46469: LIST
46470: LIST
46471: LIST
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: ST_TO_ADDR
46477: GO 48160
46479: LD_INT 12
46481: DOUBLE
46482: EQUAL
46483: IFTRUE 46487
46485: GO 46707
46487: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
46488: LD_ADDR_VAR 0 2
46492: PUSH
46493: LD_INT 1
46495: PUSH
46496: LD_INT 2
46498: PUSH
46499: LD_INT 3
46501: PUSH
46502: LD_INT 4
46504: PUSH
46505: LD_INT 5
46507: PUSH
46508: LD_INT 6
46510: PUSH
46511: LD_INT 7
46513: PUSH
46514: LD_INT 8
46516: PUSH
46517: LD_INT 9
46519: PUSH
46520: LD_INT 10
46522: PUSH
46523: LD_INT 11
46525: PUSH
46526: LD_INT 12
46528: PUSH
46529: LD_INT 13
46531: PUSH
46532: LD_INT 14
46534: PUSH
46535: LD_INT 15
46537: PUSH
46538: LD_INT 16
46540: PUSH
46541: LD_INT 17
46543: PUSH
46544: LD_INT 18
46546: PUSH
46547: LD_INT 19
46549: PUSH
46550: LD_INT 20
46552: PUSH
46553: LD_INT 21
46555: PUSH
46556: LD_INT 22
46558: PUSH
46559: LD_INT 23
46561: PUSH
46562: LD_INT 24
46564: PUSH
46565: LD_INT 25
46567: PUSH
46568: LD_INT 26
46570: PUSH
46571: LD_INT 27
46573: PUSH
46574: LD_INT 28
46576: PUSH
46577: LD_INT 30
46579: PUSH
46580: LD_INT 31
46582: PUSH
46583: LD_INT 32
46585: PUSH
46586: LD_INT 33
46588: PUSH
46589: LD_INT 34
46591: PUSH
46592: LD_INT 36
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: PUSH
46631: LD_INT 101
46633: PUSH
46634: LD_INT 102
46636: PUSH
46637: LD_INT 103
46639: PUSH
46640: LD_INT 104
46642: PUSH
46643: LD_INT 105
46645: PUSH
46646: LD_INT 106
46648: PUSH
46649: LD_INT 107
46651: PUSH
46652: LD_INT 108
46654: PUSH
46655: LD_INT 109
46657: PUSH
46658: LD_INT 110
46660: PUSH
46661: LD_INT 111
46663: PUSH
46664: LD_INT 112
46666: PUSH
46667: LD_INT 113
46669: PUSH
46670: LD_INT 114
46672: PUSH
46673: LD_INT 116
46675: PUSH
46676: LD_INT 117
46678: PUSH
46679: LD_INT 118
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: PUSH
46701: EMPTY
46702: LIST
46703: LIST
46704: ST_TO_ADDR
46705: GO 48160
46707: LD_INT 13
46709: DOUBLE
46710: EQUAL
46711: IFTRUE 46715
46713: GO 46923
46715: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
46716: LD_ADDR_VAR 0 2
46720: PUSH
46721: LD_INT 1
46723: PUSH
46724: LD_INT 2
46726: PUSH
46727: LD_INT 3
46729: PUSH
46730: LD_INT 4
46732: PUSH
46733: LD_INT 5
46735: PUSH
46736: LD_INT 8
46738: PUSH
46739: LD_INT 9
46741: PUSH
46742: LD_INT 10
46744: PUSH
46745: LD_INT 11
46747: PUSH
46748: LD_INT 12
46750: PUSH
46751: LD_INT 14
46753: PUSH
46754: LD_INT 15
46756: PUSH
46757: LD_INT 16
46759: PUSH
46760: LD_INT 17
46762: PUSH
46763: LD_INT 18
46765: PUSH
46766: LD_INT 19
46768: PUSH
46769: LD_INT 20
46771: PUSH
46772: LD_INT 21
46774: PUSH
46775: LD_INT 22
46777: PUSH
46778: LD_INT 23
46780: PUSH
46781: LD_INT 24
46783: PUSH
46784: LD_INT 25
46786: PUSH
46787: LD_INT 26
46789: PUSH
46790: LD_INT 27
46792: PUSH
46793: LD_INT 28
46795: PUSH
46796: LD_INT 30
46798: PUSH
46799: LD_INT 31
46801: PUSH
46802: LD_INT 32
46804: PUSH
46805: LD_INT 33
46807: PUSH
46808: LD_INT 34
46810: PUSH
46811: LD_INT 36
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 101
46849: PUSH
46850: LD_INT 102
46852: PUSH
46853: LD_INT 103
46855: PUSH
46856: LD_INT 104
46858: PUSH
46859: LD_INT 105
46861: PUSH
46862: LD_INT 106
46864: PUSH
46865: LD_INT 107
46867: PUSH
46868: LD_INT 108
46870: PUSH
46871: LD_INT 109
46873: PUSH
46874: LD_INT 110
46876: PUSH
46877: LD_INT 111
46879: PUSH
46880: LD_INT 112
46882: PUSH
46883: LD_INT 113
46885: PUSH
46886: LD_INT 114
46888: PUSH
46889: LD_INT 116
46891: PUSH
46892: LD_INT 117
46894: PUSH
46895: LD_INT 118
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: ST_TO_ADDR
46921: GO 48160
46923: LD_INT 14
46925: DOUBLE
46926: EQUAL
46927: IFTRUE 46931
46929: GO 47155
46931: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
46932: LD_ADDR_VAR 0 2
46936: PUSH
46937: LD_INT 1
46939: PUSH
46940: LD_INT 2
46942: PUSH
46943: LD_INT 3
46945: PUSH
46946: LD_INT 4
46948: PUSH
46949: LD_INT 5
46951: PUSH
46952: LD_INT 6
46954: PUSH
46955: LD_INT 7
46957: PUSH
46958: LD_INT 8
46960: PUSH
46961: LD_INT 9
46963: PUSH
46964: LD_INT 10
46966: PUSH
46967: LD_INT 11
46969: PUSH
46970: LD_INT 12
46972: PUSH
46973: LD_INT 13
46975: PUSH
46976: LD_INT 14
46978: PUSH
46979: LD_INT 15
46981: PUSH
46982: LD_INT 16
46984: PUSH
46985: LD_INT 17
46987: PUSH
46988: LD_INT 18
46990: PUSH
46991: LD_INT 19
46993: PUSH
46994: LD_INT 20
46996: PUSH
46997: LD_INT 21
46999: PUSH
47000: LD_INT 22
47002: PUSH
47003: LD_INT 23
47005: PUSH
47006: LD_INT 24
47008: PUSH
47009: LD_INT 25
47011: PUSH
47012: LD_INT 26
47014: PUSH
47015: LD_INT 27
47017: PUSH
47018: LD_INT 28
47020: PUSH
47021: LD_INT 29
47023: PUSH
47024: LD_INT 30
47026: PUSH
47027: LD_INT 31
47029: PUSH
47030: LD_INT 32
47032: PUSH
47033: LD_INT 33
47035: PUSH
47036: LD_INT 34
47038: PUSH
47039: LD_INT 36
47041: PUSH
47042: EMPTY
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: PUSH
47079: LD_INT 101
47081: PUSH
47082: LD_INT 102
47084: PUSH
47085: LD_INT 103
47087: PUSH
47088: LD_INT 104
47090: PUSH
47091: LD_INT 105
47093: PUSH
47094: LD_INT 106
47096: PUSH
47097: LD_INT 107
47099: PUSH
47100: LD_INT 108
47102: PUSH
47103: LD_INT 109
47105: PUSH
47106: LD_INT 110
47108: PUSH
47109: LD_INT 111
47111: PUSH
47112: LD_INT 112
47114: PUSH
47115: LD_INT 113
47117: PUSH
47118: LD_INT 114
47120: PUSH
47121: LD_INT 116
47123: PUSH
47124: LD_INT 117
47126: PUSH
47127: LD_INT 118
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: LIST
47134: LIST
47135: LIST
47136: LIST
47137: LIST
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: PUSH
47149: EMPTY
47150: LIST
47151: LIST
47152: ST_TO_ADDR
47153: GO 48160
47155: LD_INT 15
47157: DOUBLE
47158: EQUAL
47159: IFTRUE 47163
47161: GO 47387
47163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
47164: LD_ADDR_VAR 0 2
47168: PUSH
47169: LD_INT 1
47171: PUSH
47172: LD_INT 2
47174: PUSH
47175: LD_INT 3
47177: PUSH
47178: LD_INT 4
47180: PUSH
47181: LD_INT 5
47183: PUSH
47184: LD_INT 6
47186: PUSH
47187: LD_INT 7
47189: PUSH
47190: LD_INT 8
47192: PUSH
47193: LD_INT 9
47195: PUSH
47196: LD_INT 10
47198: PUSH
47199: LD_INT 11
47201: PUSH
47202: LD_INT 12
47204: PUSH
47205: LD_INT 13
47207: PUSH
47208: LD_INT 14
47210: PUSH
47211: LD_INT 15
47213: PUSH
47214: LD_INT 16
47216: PUSH
47217: LD_INT 17
47219: PUSH
47220: LD_INT 18
47222: PUSH
47223: LD_INT 19
47225: PUSH
47226: LD_INT 20
47228: PUSH
47229: LD_INT 21
47231: PUSH
47232: LD_INT 22
47234: PUSH
47235: LD_INT 23
47237: PUSH
47238: LD_INT 24
47240: PUSH
47241: LD_INT 25
47243: PUSH
47244: LD_INT 26
47246: PUSH
47247: LD_INT 27
47249: PUSH
47250: LD_INT 28
47252: PUSH
47253: LD_INT 29
47255: PUSH
47256: LD_INT 30
47258: PUSH
47259: LD_INT 31
47261: PUSH
47262: LD_INT 32
47264: PUSH
47265: LD_INT 33
47267: PUSH
47268: LD_INT 34
47270: PUSH
47271: LD_INT 36
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 101
47313: PUSH
47314: LD_INT 102
47316: PUSH
47317: LD_INT 103
47319: PUSH
47320: LD_INT 104
47322: PUSH
47323: LD_INT 105
47325: PUSH
47326: LD_INT 106
47328: PUSH
47329: LD_INT 107
47331: PUSH
47332: LD_INT 108
47334: PUSH
47335: LD_INT 109
47337: PUSH
47338: LD_INT 110
47340: PUSH
47341: LD_INT 111
47343: PUSH
47344: LD_INT 112
47346: PUSH
47347: LD_INT 113
47349: PUSH
47350: LD_INT 114
47352: PUSH
47353: LD_INT 116
47355: PUSH
47356: LD_INT 117
47358: PUSH
47359: LD_INT 118
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: LIST
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: ST_TO_ADDR
47385: GO 48160
47387: LD_INT 16
47389: DOUBLE
47390: EQUAL
47391: IFTRUE 47395
47393: GO 47531
47395: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
47396: LD_ADDR_VAR 0 2
47400: PUSH
47401: LD_INT 2
47403: PUSH
47404: LD_INT 4
47406: PUSH
47407: LD_INT 5
47409: PUSH
47410: LD_INT 7
47412: PUSH
47413: LD_INT 11
47415: PUSH
47416: LD_INT 12
47418: PUSH
47419: LD_INT 15
47421: PUSH
47422: LD_INT 16
47424: PUSH
47425: LD_INT 20
47427: PUSH
47428: LD_INT 21
47430: PUSH
47431: LD_INT 22
47433: PUSH
47434: LD_INT 23
47436: PUSH
47437: LD_INT 25
47439: PUSH
47440: LD_INT 26
47442: PUSH
47443: LD_INT 30
47445: PUSH
47446: LD_INT 31
47448: PUSH
47449: LD_INT 32
47451: PUSH
47452: LD_INT 33
47454: PUSH
47455: LD_INT 34
47457: PUSH
47458: EMPTY
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: PUSH
47479: LD_INT 101
47481: PUSH
47482: LD_INT 102
47484: PUSH
47485: LD_INT 103
47487: PUSH
47488: LD_INT 106
47490: PUSH
47491: LD_INT 108
47493: PUSH
47494: LD_INT 112
47496: PUSH
47497: LD_INT 113
47499: PUSH
47500: LD_INT 114
47502: PUSH
47503: LD_INT 116
47505: PUSH
47506: LD_INT 117
47508: PUSH
47509: LD_INT 118
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: LIST
47523: LIST
47524: PUSH
47525: EMPTY
47526: LIST
47527: LIST
47528: ST_TO_ADDR
47529: GO 48160
47531: LD_INT 17
47533: DOUBLE
47534: EQUAL
47535: IFTRUE 47539
47537: GO 47763
47539: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
47540: LD_ADDR_VAR 0 2
47544: PUSH
47545: LD_INT 1
47547: PUSH
47548: LD_INT 2
47550: PUSH
47551: LD_INT 3
47553: PUSH
47554: LD_INT 4
47556: PUSH
47557: LD_INT 5
47559: PUSH
47560: LD_INT 6
47562: PUSH
47563: LD_INT 7
47565: PUSH
47566: LD_INT 8
47568: PUSH
47569: LD_INT 9
47571: PUSH
47572: LD_INT 10
47574: PUSH
47575: LD_INT 11
47577: PUSH
47578: LD_INT 12
47580: PUSH
47581: LD_INT 13
47583: PUSH
47584: LD_INT 14
47586: PUSH
47587: LD_INT 15
47589: PUSH
47590: LD_INT 16
47592: PUSH
47593: LD_INT 17
47595: PUSH
47596: LD_INT 18
47598: PUSH
47599: LD_INT 19
47601: PUSH
47602: LD_INT 20
47604: PUSH
47605: LD_INT 21
47607: PUSH
47608: LD_INT 22
47610: PUSH
47611: LD_INT 23
47613: PUSH
47614: LD_INT 24
47616: PUSH
47617: LD_INT 25
47619: PUSH
47620: LD_INT 26
47622: PUSH
47623: LD_INT 27
47625: PUSH
47626: LD_INT 28
47628: PUSH
47629: LD_INT 29
47631: PUSH
47632: LD_INT 30
47634: PUSH
47635: LD_INT 31
47637: PUSH
47638: LD_INT 32
47640: PUSH
47641: LD_INT 33
47643: PUSH
47644: LD_INT 34
47646: PUSH
47647: LD_INT 36
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: LIST
47654: LIST
47655: LIST
47656: LIST
47657: LIST
47658: LIST
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: LIST
47683: LIST
47684: LIST
47685: LIST
47686: PUSH
47687: LD_INT 101
47689: PUSH
47690: LD_INT 102
47692: PUSH
47693: LD_INT 103
47695: PUSH
47696: LD_INT 104
47698: PUSH
47699: LD_INT 105
47701: PUSH
47702: LD_INT 106
47704: PUSH
47705: LD_INT 107
47707: PUSH
47708: LD_INT 108
47710: PUSH
47711: LD_INT 109
47713: PUSH
47714: LD_INT 110
47716: PUSH
47717: LD_INT 111
47719: PUSH
47720: LD_INT 112
47722: PUSH
47723: LD_INT 113
47725: PUSH
47726: LD_INT 114
47728: PUSH
47729: LD_INT 116
47731: PUSH
47732: LD_INT 117
47734: PUSH
47735: LD_INT 118
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: ST_TO_ADDR
47761: GO 48160
47763: LD_INT 18
47765: DOUBLE
47766: EQUAL
47767: IFTRUE 47771
47769: GO 47919
47771: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
47772: LD_ADDR_VAR 0 2
47776: PUSH
47777: LD_INT 2
47779: PUSH
47780: LD_INT 4
47782: PUSH
47783: LD_INT 5
47785: PUSH
47786: LD_INT 7
47788: PUSH
47789: LD_INT 11
47791: PUSH
47792: LD_INT 12
47794: PUSH
47795: LD_INT 15
47797: PUSH
47798: LD_INT 16
47800: PUSH
47801: LD_INT 20
47803: PUSH
47804: LD_INT 21
47806: PUSH
47807: LD_INT 22
47809: PUSH
47810: LD_INT 23
47812: PUSH
47813: LD_INT 25
47815: PUSH
47816: LD_INT 26
47818: PUSH
47819: LD_INT 30
47821: PUSH
47822: LD_INT 31
47824: PUSH
47825: LD_INT 32
47827: PUSH
47828: LD_INT 33
47830: PUSH
47831: LD_INT 34
47833: PUSH
47834: LD_INT 35
47836: PUSH
47837: LD_INT 36
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: LIST
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: PUSH
47863: LD_INT 101
47865: PUSH
47866: LD_INT 102
47868: PUSH
47869: LD_INT 103
47871: PUSH
47872: LD_INT 106
47874: PUSH
47875: LD_INT 108
47877: PUSH
47878: LD_INT 112
47880: PUSH
47881: LD_INT 113
47883: PUSH
47884: LD_INT 114
47886: PUSH
47887: LD_INT 115
47889: PUSH
47890: LD_INT 116
47892: PUSH
47893: LD_INT 117
47895: PUSH
47896: LD_INT 118
47898: PUSH
47899: EMPTY
47900: LIST
47901: LIST
47902: LIST
47903: LIST
47904: LIST
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: LIST
47912: PUSH
47913: EMPTY
47914: LIST
47915: LIST
47916: ST_TO_ADDR
47917: GO 48160
47919: LD_INT 19
47921: DOUBLE
47922: EQUAL
47923: IFTRUE 47927
47925: GO 48159
47927: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
47928: LD_ADDR_VAR 0 2
47932: PUSH
47933: LD_INT 1
47935: PUSH
47936: LD_INT 2
47938: PUSH
47939: LD_INT 3
47941: PUSH
47942: LD_INT 4
47944: PUSH
47945: LD_INT 5
47947: PUSH
47948: LD_INT 6
47950: PUSH
47951: LD_INT 7
47953: PUSH
47954: LD_INT 8
47956: PUSH
47957: LD_INT 9
47959: PUSH
47960: LD_INT 10
47962: PUSH
47963: LD_INT 11
47965: PUSH
47966: LD_INT 12
47968: PUSH
47969: LD_INT 13
47971: PUSH
47972: LD_INT 14
47974: PUSH
47975: LD_INT 15
47977: PUSH
47978: LD_INT 16
47980: PUSH
47981: LD_INT 17
47983: PUSH
47984: LD_INT 18
47986: PUSH
47987: LD_INT 19
47989: PUSH
47990: LD_INT 20
47992: PUSH
47993: LD_INT 21
47995: PUSH
47996: LD_INT 22
47998: PUSH
47999: LD_INT 23
48001: PUSH
48002: LD_INT 24
48004: PUSH
48005: LD_INT 25
48007: PUSH
48008: LD_INT 26
48010: PUSH
48011: LD_INT 27
48013: PUSH
48014: LD_INT 28
48016: PUSH
48017: LD_INT 29
48019: PUSH
48020: LD_INT 30
48022: PUSH
48023: LD_INT 31
48025: PUSH
48026: LD_INT 32
48028: PUSH
48029: LD_INT 33
48031: PUSH
48032: LD_INT 34
48034: PUSH
48035: LD_INT 35
48037: PUSH
48038: LD_INT 36
48040: PUSH
48041: EMPTY
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: LIST
48058: LIST
48059: LIST
48060: LIST
48061: LIST
48062: LIST
48063: LIST
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: PUSH
48079: LD_INT 101
48081: PUSH
48082: LD_INT 102
48084: PUSH
48085: LD_INT 103
48087: PUSH
48088: LD_INT 104
48090: PUSH
48091: LD_INT 105
48093: PUSH
48094: LD_INT 106
48096: PUSH
48097: LD_INT 107
48099: PUSH
48100: LD_INT 108
48102: PUSH
48103: LD_INT 109
48105: PUSH
48106: LD_INT 110
48108: PUSH
48109: LD_INT 111
48111: PUSH
48112: LD_INT 112
48114: PUSH
48115: LD_INT 113
48117: PUSH
48118: LD_INT 114
48120: PUSH
48121: LD_INT 115
48123: PUSH
48124: LD_INT 116
48126: PUSH
48127: LD_INT 117
48129: PUSH
48130: LD_INT 118
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: ST_TO_ADDR
48157: GO 48160
48159: POP
// end else
48160: GO 48391
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
48162: LD_ADDR_VAR 0 2
48166: PUSH
48167: LD_INT 1
48169: PUSH
48170: LD_INT 2
48172: PUSH
48173: LD_INT 3
48175: PUSH
48176: LD_INT 4
48178: PUSH
48179: LD_INT 5
48181: PUSH
48182: LD_INT 6
48184: PUSH
48185: LD_INT 7
48187: PUSH
48188: LD_INT 8
48190: PUSH
48191: LD_INT 9
48193: PUSH
48194: LD_INT 10
48196: PUSH
48197: LD_INT 11
48199: PUSH
48200: LD_INT 12
48202: PUSH
48203: LD_INT 13
48205: PUSH
48206: LD_INT 14
48208: PUSH
48209: LD_INT 15
48211: PUSH
48212: LD_INT 16
48214: PUSH
48215: LD_INT 17
48217: PUSH
48218: LD_INT 18
48220: PUSH
48221: LD_INT 19
48223: PUSH
48224: LD_INT 20
48226: PUSH
48227: LD_INT 21
48229: PUSH
48230: LD_INT 22
48232: PUSH
48233: LD_INT 23
48235: PUSH
48236: LD_INT 24
48238: PUSH
48239: LD_INT 25
48241: PUSH
48242: LD_INT 26
48244: PUSH
48245: LD_INT 27
48247: PUSH
48248: LD_INT 28
48250: PUSH
48251: LD_INT 29
48253: PUSH
48254: LD_INT 30
48256: PUSH
48257: LD_INT 31
48259: PUSH
48260: LD_INT 32
48262: PUSH
48263: LD_INT 33
48265: PUSH
48266: LD_INT 34
48268: PUSH
48269: LD_INT 35
48271: PUSH
48272: LD_INT 36
48274: PUSH
48275: EMPTY
48276: LIST
48277: LIST
48278: LIST
48279: LIST
48280: LIST
48281: LIST
48282: LIST
48283: LIST
48284: LIST
48285: LIST
48286: LIST
48287: LIST
48288: LIST
48289: LIST
48290: LIST
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: LIST
48299: LIST
48300: LIST
48301: LIST
48302: LIST
48303: LIST
48304: LIST
48305: LIST
48306: LIST
48307: LIST
48308: LIST
48309: LIST
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 101
48315: PUSH
48316: LD_INT 102
48318: PUSH
48319: LD_INT 103
48321: PUSH
48322: LD_INT 104
48324: PUSH
48325: LD_INT 105
48327: PUSH
48328: LD_INT 106
48330: PUSH
48331: LD_INT 107
48333: PUSH
48334: LD_INT 108
48336: PUSH
48337: LD_INT 109
48339: PUSH
48340: LD_INT 110
48342: PUSH
48343: LD_INT 111
48345: PUSH
48346: LD_INT 112
48348: PUSH
48349: LD_INT 113
48351: PUSH
48352: LD_INT 114
48354: PUSH
48355: LD_INT 115
48357: PUSH
48358: LD_INT 116
48360: PUSH
48361: LD_INT 117
48363: PUSH
48364: LD_INT 118
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: ST_TO_ADDR
// if result then
48391: LD_VAR 0 2
48395: IFFALSE 49181
// begin normal :=  ;
48397: LD_ADDR_VAR 0 5
48401: PUSH
48402: LD_STRING 
48404: ST_TO_ADDR
// hardcore :=  ;
48405: LD_ADDR_VAR 0 6
48409: PUSH
48410: LD_STRING 
48412: ST_TO_ADDR
// active :=  ;
48413: LD_ADDR_VAR 0 7
48417: PUSH
48418: LD_STRING 
48420: ST_TO_ADDR
// for i = 1 to normalCounter do
48421: LD_ADDR_VAR 0 8
48425: PUSH
48426: DOUBLE
48427: LD_INT 1
48429: DEC
48430: ST_TO_ADDR
48431: LD_EXP 74
48435: PUSH
48436: FOR_TO
48437: IFFALSE 48538
// begin tmp := 0 ;
48439: LD_ADDR_VAR 0 3
48443: PUSH
48444: LD_STRING 0
48446: ST_TO_ADDR
// if result [ 1 ] then
48447: LD_VAR 0 2
48451: PUSH
48452: LD_INT 1
48454: ARRAY
48455: IFFALSE 48520
// if result [ 1 ] [ 1 ] = i then
48457: LD_VAR 0 2
48461: PUSH
48462: LD_INT 1
48464: ARRAY
48465: PUSH
48466: LD_INT 1
48468: ARRAY
48469: PUSH
48470: LD_VAR 0 8
48474: EQUAL
48475: IFFALSE 48520
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48477: LD_ADDR_VAR 0 2
48481: PUSH
48482: LD_VAR 0 2
48486: PPUSH
48487: LD_INT 1
48489: PPUSH
48490: LD_VAR 0 2
48494: PUSH
48495: LD_INT 1
48497: ARRAY
48498: PPUSH
48499: LD_INT 1
48501: PPUSH
48502: CALL_OW 3
48506: PPUSH
48507: CALL_OW 1
48511: ST_TO_ADDR
// tmp := 1 ;
48512: LD_ADDR_VAR 0 3
48516: PUSH
48517: LD_STRING 1
48519: ST_TO_ADDR
// end ; normal := normal & tmp ;
48520: LD_ADDR_VAR 0 5
48524: PUSH
48525: LD_VAR 0 5
48529: PUSH
48530: LD_VAR 0 3
48534: STR
48535: ST_TO_ADDR
// end ;
48536: GO 48436
48538: POP
48539: POP
// for i = 1 to hardcoreCounter do
48540: LD_ADDR_VAR 0 8
48544: PUSH
48545: DOUBLE
48546: LD_INT 1
48548: DEC
48549: ST_TO_ADDR
48550: LD_EXP 75
48554: PUSH
48555: FOR_TO
48556: IFFALSE 48661
// begin tmp := 0 ;
48558: LD_ADDR_VAR 0 3
48562: PUSH
48563: LD_STRING 0
48565: ST_TO_ADDR
// if result [ 2 ] then
48566: LD_VAR 0 2
48570: PUSH
48571: LD_INT 2
48573: ARRAY
48574: IFFALSE 48643
// if result [ 2 ] [ 1 ] = 100 + i then
48576: LD_VAR 0 2
48580: PUSH
48581: LD_INT 2
48583: ARRAY
48584: PUSH
48585: LD_INT 1
48587: ARRAY
48588: PUSH
48589: LD_INT 100
48591: PUSH
48592: LD_VAR 0 8
48596: PLUS
48597: EQUAL
48598: IFFALSE 48643
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48600: LD_ADDR_VAR 0 2
48604: PUSH
48605: LD_VAR 0 2
48609: PPUSH
48610: LD_INT 2
48612: PPUSH
48613: LD_VAR 0 2
48617: PUSH
48618: LD_INT 2
48620: ARRAY
48621: PPUSH
48622: LD_INT 1
48624: PPUSH
48625: CALL_OW 3
48629: PPUSH
48630: CALL_OW 1
48634: ST_TO_ADDR
// tmp := 1 ;
48635: LD_ADDR_VAR 0 3
48639: PUSH
48640: LD_STRING 1
48642: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48643: LD_ADDR_VAR 0 6
48647: PUSH
48648: LD_VAR 0 6
48652: PUSH
48653: LD_VAR 0 3
48657: STR
48658: ST_TO_ADDR
// end ;
48659: GO 48555
48661: POP
48662: POP
// if isGameLoad then
48663: LD_VAR 0 1
48667: IFFALSE 49142
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
48669: LD_ADDR_VAR 0 4
48673: PUSH
48674: LD_EXP 78
48678: PUSH
48679: LD_EXP 77
48683: PUSH
48684: LD_EXP 79
48688: PUSH
48689: LD_EXP 76
48693: PUSH
48694: LD_EXP 80
48698: PUSH
48699: LD_EXP 81
48703: PUSH
48704: LD_EXP 82
48708: PUSH
48709: LD_EXP 83
48713: PUSH
48714: LD_EXP 84
48718: PUSH
48719: LD_EXP 85
48723: PUSH
48724: LD_EXP 86
48728: PUSH
48729: LD_EXP 87
48733: PUSH
48734: LD_EXP 88
48738: PUSH
48739: LD_EXP 89
48743: PUSH
48744: LD_EXP 97
48748: PUSH
48749: LD_EXP 98
48753: PUSH
48754: LD_EXP 99
48758: PUSH
48759: LD_EXP 100
48763: PUSH
48764: LD_EXP 102
48768: PUSH
48769: LD_EXP 103
48773: PUSH
48774: LD_EXP 104
48778: PUSH
48779: LD_EXP 107
48783: PUSH
48784: LD_EXP 109
48788: PUSH
48789: LD_EXP 110
48793: PUSH
48794: LD_EXP 111
48798: PUSH
48799: LD_EXP 113
48803: PUSH
48804: LD_EXP 114
48808: PUSH
48809: LD_EXP 117
48813: PUSH
48814: LD_EXP 118
48818: PUSH
48819: LD_EXP 119
48823: PUSH
48824: LD_EXP 120
48828: PUSH
48829: LD_EXP 121
48833: PUSH
48834: LD_EXP 122
48838: PUSH
48839: LD_EXP 123
48843: PUSH
48844: LD_EXP 124
48848: PUSH
48849: LD_EXP 125
48853: PUSH
48854: LD_EXP 90
48858: PUSH
48859: LD_EXP 91
48863: PUSH
48864: LD_EXP 94
48868: PUSH
48869: LD_EXP 95
48873: PUSH
48874: LD_EXP 96
48878: PUSH
48879: LD_EXP 92
48883: PUSH
48884: LD_EXP 93
48888: PUSH
48889: LD_EXP 101
48893: PUSH
48894: LD_EXP 105
48898: PUSH
48899: LD_EXP 106
48903: PUSH
48904: LD_EXP 108
48908: PUSH
48909: LD_EXP 112
48913: PUSH
48914: LD_EXP 115
48918: PUSH
48919: LD_EXP 116
48923: PUSH
48924: LD_EXP 126
48928: PUSH
48929: LD_EXP 127
48933: PUSH
48934: LD_EXP 128
48938: PUSH
48939: LD_EXP 129
48943: PUSH
48944: EMPTY
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: LIST
48960: LIST
48961: LIST
48962: LIST
48963: LIST
48964: LIST
48965: LIST
48966: LIST
48967: LIST
48968: LIST
48969: LIST
48970: LIST
48971: LIST
48972: LIST
48973: LIST
48974: LIST
48975: LIST
48976: LIST
48977: LIST
48978: LIST
48979: LIST
48980: LIST
48981: LIST
48982: LIST
48983: LIST
48984: LIST
48985: LIST
48986: LIST
48987: LIST
48988: LIST
48989: LIST
48990: LIST
48991: LIST
48992: LIST
48993: LIST
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: LIST
48999: ST_TO_ADDR
// tmp :=  ;
49000: LD_ADDR_VAR 0 3
49004: PUSH
49005: LD_STRING 
49007: ST_TO_ADDR
// for i = 1 to normalCounter do
49008: LD_ADDR_VAR 0 8
49012: PUSH
49013: DOUBLE
49014: LD_INT 1
49016: DEC
49017: ST_TO_ADDR
49018: LD_EXP 74
49022: PUSH
49023: FOR_TO
49024: IFFALSE 49060
// begin if flags [ i ] then
49026: LD_VAR 0 4
49030: PUSH
49031: LD_VAR 0 8
49035: ARRAY
49036: IFFALSE 49058
// tmp := tmp & i & ; ;
49038: LD_ADDR_VAR 0 3
49042: PUSH
49043: LD_VAR 0 3
49047: PUSH
49048: LD_VAR 0 8
49052: STR
49053: PUSH
49054: LD_STRING ;
49056: STR
49057: ST_TO_ADDR
// end ;
49058: GO 49023
49060: POP
49061: POP
// for i = 1 to hardcoreCounter do
49062: LD_ADDR_VAR 0 8
49066: PUSH
49067: DOUBLE
49068: LD_INT 1
49070: DEC
49071: ST_TO_ADDR
49072: LD_EXP 75
49076: PUSH
49077: FOR_TO
49078: IFFALSE 49124
// begin if flags [ normalCounter + i ] then
49080: LD_VAR 0 4
49084: PUSH
49085: LD_EXP 74
49089: PUSH
49090: LD_VAR 0 8
49094: PLUS
49095: ARRAY
49096: IFFALSE 49122
// tmp := tmp & ( 100 + i ) & ; ;
49098: LD_ADDR_VAR 0 3
49102: PUSH
49103: LD_VAR 0 3
49107: PUSH
49108: LD_INT 100
49110: PUSH
49111: LD_VAR 0 8
49115: PLUS
49116: STR
49117: PUSH
49118: LD_STRING ;
49120: STR
49121: ST_TO_ADDR
// end ;
49122: GO 49077
49124: POP
49125: POP
// if tmp then
49126: LD_VAR 0 3
49130: IFFALSE 49142
// active := tmp ;
49132: LD_ADDR_VAR 0 7
49136: PUSH
49137: LD_VAR 0 3
49141: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
49142: LD_STRING getStreamItemsFromMission("
49144: PUSH
49145: LD_VAR 0 5
49149: STR
49150: PUSH
49151: LD_STRING ","
49153: STR
49154: PUSH
49155: LD_VAR 0 6
49159: STR
49160: PUSH
49161: LD_STRING ","
49163: STR
49164: PUSH
49165: LD_VAR 0 7
49169: STR
49170: PUSH
49171: LD_STRING ")
49173: STR
49174: PPUSH
49175: CALL_OW 559
// end else
49179: GO 49188
// ToLua ( getStreamItemsFromMission("","","") ) ;
49181: LD_STRING getStreamItemsFromMission("","","")
49183: PPUSH
49184: CALL_OW 559
// end ;
49188: LD_VAR 0 2
49192: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
49193: LD_EXP 73
49197: PUSH
49198: LD_EXP 78
49202: AND
49203: IFFALSE 49327
49205: GO 49207
49207: DISABLE
49208: LD_INT 0
49210: PPUSH
49211: PPUSH
// begin enable ;
49212: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
49213: LD_ADDR_VAR 0 2
49217: PUSH
49218: LD_INT 22
49220: PUSH
49221: LD_OWVAR 2
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: PUSH
49230: LD_INT 2
49232: PUSH
49233: LD_INT 34
49235: PUSH
49236: LD_INT 7
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: PUSH
49243: LD_INT 34
49245: PUSH
49246: LD_INT 45
49248: PUSH
49249: EMPTY
49250: LIST
49251: LIST
49252: PUSH
49253: LD_INT 34
49255: PUSH
49256: LD_INT 28
49258: PUSH
49259: EMPTY
49260: LIST
49261: LIST
49262: PUSH
49263: LD_INT 34
49265: PUSH
49266: LD_INT 47
49268: PUSH
49269: EMPTY
49270: LIST
49271: LIST
49272: PUSH
49273: EMPTY
49274: LIST
49275: LIST
49276: LIST
49277: LIST
49278: LIST
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: PPUSH
49284: CALL_OW 69
49288: ST_TO_ADDR
// if not tmp then
49289: LD_VAR 0 2
49293: NOT
49294: IFFALSE 49298
// exit ;
49296: GO 49327
// for i in tmp do
49298: LD_ADDR_VAR 0 1
49302: PUSH
49303: LD_VAR 0 2
49307: PUSH
49308: FOR_IN
49309: IFFALSE 49325
// begin SetLives ( i , 0 ) ;
49311: LD_VAR 0 1
49315: PPUSH
49316: LD_INT 0
49318: PPUSH
49319: CALL_OW 234
// end ;
49323: GO 49308
49325: POP
49326: POP
// end ;
49327: PPOPN 2
49329: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
49330: LD_EXP 73
49334: PUSH
49335: LD_EXP 79
49339: AND
49340: IFFALSE 49424
49342: GO 49344
49344: DISABLE
49345: LD_INT 0
49347: PPUSH
49348: PPUSH
// begin enable ;
49349: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
49350: LD_ADDR_VAR 0 2
49354: PUSH
49355: LD_INT 22
49357: PUSH
49358: LD_OWVAR 2
49362: PUSH
49363: EMPTY
49364: LIST
49365: LIST
49366: PUSH
49367: LD_INT 32
49369: PUSH
49370: LD_INT 3
49372: PUSH
49373: EMPTY
49374: LIST
49375: LIST
49376: PUSH
49377: EMPTY
49378: LIST
49379: LIST
49380: PPUSH
49381: CALL_OW 69
49385: ST_TO_ADDR
// if not tmp then
49386: LD_VAR 0 2
49390: NOT
49391: IFFALSE 49395
// exit ;
49393: GO 49424
// for i in tmp do
49395: LD_ADDR_VAR 0 1
49399: PUSH
49400: LD_VAR 0 2
49404: PUSH
49405: FOR_IN
49406: IFFALSE 49422
// begin SetLives ( i , 0 ) ;
49408: LD_VAR 0 1
49412: PPUSH
49413: LD_INT 0
49415: PPUSH
49416: CALL_OW 234
// end ;
49420: GO 49405
49422: POP
49423: POP
// end ;
49424: PPOPN 2
49426: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
49427: LD_EXP 73
49431: PUSH
49432: LD_EXP 76
49436: AND
49437: IFFALSE 49530
49439: GO 49441
49441: DISABLE
49442: LD_INT 0
49444: PPUSH
// begin enable ;
49445: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
49446: LD_ADDR_VAR 0 1
49450: PUSH
49451: LD_INT 22
49453: PUSH
49454: LD_OWVAR 2
49458: PUSH
49459: EMPTY
49460: LIST
49461: LIST
49462: PUSH
49463: LD_INT 2
49465: PUSH
49466: LD_INT 25
49468: PUSH
49469: LD_INT 5
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: PUSH
49476: LD_INT 25
49478: PUSH
49479: LD_INT 9
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 25
49488: PUSH
49489: LD_INT 8
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: LIST
49500: LIST
49501: PUSH
49502: EMPTY
49503: LIST
49504: LIST
49505: PPUSH
49506: CALL_OW 69
49510: PUSH
49511: FOR_IN
49512: IFFALSE 49528
// begin SetClass ( i , 1 ) ;
49514: LD_VAR 0 1
49518: PPUSH
49519: LD_INT 1
49521: PPUSH
49522: CALL_OW 336
// end ;
49526: GO 49511
49528: POP
49529: POP
// end ;
49530: PPOPN 1
49532: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
49533: LD_EXP 73
49537: PUSH
49538: LD_EXP 77
49542: AND
49543: PUSH
49544: LD_OWVAR 65
49548: PUSH
49549: LD_INT 7
49551: LESS
49552: AND
49553: IFFALSE 49567
49555: GO 49557
49557: DISABLE
// begin enable ;
49558: ENABLE
// game_speed := 7 ;
49559: LD_ADDR_OWVAR 65
49563: PUSH
49564: LD_INT 7
49566: ST_TO_ADDR
// end ;
49567: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
49568: LD_EXP 73
49572: PUSH
49573: LD_EXP 80
49577: AND
49578: IFFALSE 49780
49580: GO 49582
49582: DISABLE
49583: LD_INT 0
49585: PPUSH
49586: PPUSH
49587: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
49588: LD_ADDR_VAR 0 3
49592: PUSH
49593: LD_INT 81
49595: PUSH
49596: LD_OWVAR 2
49600: PUSH
49601: EMPTY
49602: LIST
49603: LIST
49604: PUSH
49605: LD_INT 21
49607: PUSH
49608: LD_INT 1
49610: PUSH
49611: EMPTY
49612: LIST
49613: LIST
49614: PUSH
49615: EMPTY
49616: LIST
49617: LIST
49618: PPUSH
49619: CALL_OW 69
49623: ST_TO_ADDR
// if not tmp then
49624: LD_VAR 0 3
49628: NOT
49629: IFFALSE 49633
// exit ;
49631: GO 49780
// if tmp > 5 then
49633: LD_VAR 0 3
49637: PUSH
49638: LD_INT 5
49640: GREATER
49641: IFFALSE 49653
// k := 5 else
49643: LD_ADDR_VAR 0 2
49647: PUSH
49648: LD_INT 5
49650: ST_TO_ADDR
49651: GO 49663
// k := tmp ;
49653: LD_ADDR_VAR 0 2
49657: PUSH
49658: LD_VAR 0 3
49662: ST_TO_ADDR
// for i := 1 to k do
49663: LD_ADDR_VAR 0 1
49667: PUSH
49668: DOUBLE
49669: LD_INT 1
49671: DEC
49672: ST_TO_ADDR
49673: LD_VAR 0 2
49677: PUSH
49678: FOR_TO
49679: IFFALSE 49778
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
49681: LD_VAR 0 3
49685: PUSH
49686: LD_VAR 0 1
49690: ARRAY
49691: PPUSH
49692: LD_VAR 0 1
49696: PUSH
49697: LD_INT 4
49699: MOD
49700: PUSH
49701: LD_INT 1
49703: PLUS
49704: PPUSH
49705: CALL_OW 259
49709: PUSH
49710: LD_INT 10
49712: LESS
49713: IFFALSE 49776
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
49715: LD_VAR 0 3
49719: PUSH
49720: LD_VAR 0 1
49724: ARRAY
49725: PPUSH
49726: LD_VAR 0 1
49730: PUSH
49731: LD_INT 4
49733: MOD
49734: PUSH
49735: LD_INT 1
49737: PLUS
49738: PPUSH
49739: LD_VAR 0 3
49743: PUSH
49744: LD_VAR 0 1
49748: ARRAY
49749: PPUSH
49750: LD_VAR 0 1
49754: PUSH
49755: LD_INT 4
49757: MOD
49758: PUSH
49759: LD_INT 1
49761: PLUS
49762: PPUSH
49763: CALL_OW 259
49767: PUSH
49768: LD_INT 1
49770: PLUS
49771: PPUSH
49772: CALL_OW 237
49776: GO 49678
49778: POP
49779: POP
// end ;
49780: PPOPN 3
49782: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
49783: LD_EXP 73
49787: PUSH
49788: LD_EXP 81
49792: AND
49793: IFFALSE 49813
49795: GO 49797
49797: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
49798: LD_INT 4
49800: PPUSH
49801: LD_OWVAR 2
49805: PPUSH
49806: LD_INT 0
49808: PPUSH
49809: CALL_OW 324
49813: END
// every 0 0$1 trigger StreamModeActive and sShovel do
49814: LD_EXP 73
49818: PUSH
49819: LD_EXP 110
49823: AND
49824: IFFALSE 49844
49826: GO 49828
49828: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
49829: LD_INT 19
49831: PPUSH
49832: LD_OWVAR 2
49836: PPUSH
49837: LD_INT 0
49839: PPUSH
49840: CALL_OW 324
49844: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49845: LD_EXP 73
49849: PUSH
49850: LD_EXP 82
49854: AND
49855: IFFALSE 49957
49857: GO 49859
49859: DISABLE
49860: LD_INT 0
49862: PPUSH
49863: PPUSH
// begin enable ;
49864: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49865: LD_ADDR_VAR 0 2
49869: PUSH
49870: LD_INT 22
49872: PUSH
49873: LD_OWVAR 2
49877: PUSH
49878: EMPTY
49879: LIST
49880: LIST
49881: PUSH
49882: LD_INT 2
49884: PUSH
49885: LD_INT 34
49887: PUSH
49888: LD_INT 11
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 34
49897: PUSH
49898: LD_INT 30
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: EMPTY
49906: LIST
49907: LIST
49908: LIST
49909: PUSH
49910: EMPTY
49911: LIST
49912: LIST
49913: PPUSH
49914: CALL_OW 69
49918: ST_TO_ADDR
// if not tmp then
49919: LD_VAR 0 2
49923: NOT
49924: IFFALSE 49928
// exit ;
49926: GO 49957
// for i in tmp do
49928: LD_ADDR_VAR 0 1
49932: PUSH
49933: LD_VAR 0 2
49937: PUSH
49938: FOR_IN
49939: IFFALSE 49955
// begin SetLives ( i , 0 ) ;
49941: LD_VAR 0 1
49945: PPUSH
49946: LD_INT 0
49948: PPUSH
49949: CALL_OW 234
// end ;
49953: GO 49938
49955: POP
49956: POP
// end ;
49957: PPOPN 2
49959: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49960: LD_EXP 73
49964: PUSH
49965: LD_EXP 83
49969: AND
49970: IFFALSE 49990
49972: GO 49974
49974: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49975: LD_INT 32
49977: PPUSH
49978: LD_OWVAR 2
49982: PPUSH
49983: LD_INT 0
49985: PPUSH
49986: CALL_OW 324
49990: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49991: LD_EXP 73
49995: PUSH
49996: LD_EXP 84
50000: AND
50001: IFFALSE 50182
50003: GO 50005
50005: DISABLE
50006: LD_INT 0
50008: PPUSH
50009: PPUSH
50010: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
50011: LD_ADDR_VAR 0 2
50015: PUSH
50016: LD_INT 22
50018: PUSH
50019: LD_OWVAR 2
50023: PUSH
50024: EMPTY
50025: LIST
50026: LIST
50027: PUSH
50028: LD_INT 33
50030: PUSH
50031: LD_INT 3
50033: PUSH
50034: EMPTY
50035: LIST
50036: LIST
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: PPUSH
50042: CALL_OW 69
50046: ST_TO_ADDR
// if not tmp then
50047: LD_VAR 0 2
50051: NOT
50052: IFFALSE 50056
// exit ;
50054: GO 50182
// side := 0 ;
50056: LD_ADDR_VAR 0 3
50060: PUSH
50061: LD_INT 0
50063: ST_TO_ADDR
// for i := 1 to 8 do
50064: LD_ADDR_VAR 0 1
50068: PUSH
50069: DOUBLE
50070: LD_INT 1
50072: DEC
50073: ST_TO_ADDR
50074: LD_INT 8
50076: PUSH
50077: FOR_TO
50078: IFFALSE 50126
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
50080: LD_OWVAR 2
50084: PUSH
50085: LD_VAR 0 1
50089: NONEQUAL
50090: PUSH
50091: LD_OWVAR 2
50095: PPUSH
50096: LD_VAR 0 1
50100: PPUSH
50101: CALL_OW 81
50105: PUSH
50106: LD_INT 2
50108: EQUAL
50109: AND
50110: IFFALSE 50124
// begin side := i ;
50112: LD_ADDR_VAR 0 3
50116: PUSH
50117: LD_VAR 0 1
50121: ST_TO_ADDR
// break ;
50122: GO 50126
// end ;
50124: GO 50077
50126: POP
50127: POP
// if not side then
50128: LD_VAR 0 3
50132: NOT
50133: IFFALSE 50137
// exit ;
50135: GO 50182
// for i := 1 to tmp do
50137: LD_ADDR_VAR 0 1
50141: PUSH
50142: DOUBLE
50143: LD_INT 1
50145: DEC
50146: ST_TO_ADDR
50147: LD_VAR 0 2
50151: PUSH
50152: FOR_TO
50153: IFFALSE 50180
// if Prob ( 60 ) then
50155: LD_INT 60
50157: PPUSH
50158: CALL_OW 13
50162: IFFALSE 50178
// SetSide ( i , side ) ;
50164: LD_VAR 0 1
50168: PPUSH
50169: LD_VAR 0 3
50173: PPUSH
50174: CALL_OW 235
50178: GO 50152
50180: POP
50181: POP
// end ;
50182: PPOPN 3
50184: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
50185: LD_EXP 73
50189: PUSH
50190: LD_EXP 86
50194: AND
50195: IFFALSE 50314
50197: GO 50199
50199: DISABLE
50200: LD_INT 0
50202: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
50203: LD_ADDR_VAR 0 1
50207: PUSH
50208: LD_INT 22
50210: PUSH
50211: LD_OWVAR 2
50215: PUSH
50216: EMPTY
50217: LIST
50218: LIST
50219: PUSH
50220: LD_INT 21
50222: PUSH
50223: LD_INT 1
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: LD_INT 3
50232: PUSH
50233: LD_INT 23
50235: PUSH
50236: LD_INT 0
50238: PUSH
50239: EMPTY
50240: LIST
50241: LIST
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PUSH
50247: EMPTY
50248: LIST
50249: LIST
50250: LIST
50251: PPUSH
50252: CALL_OW 69
50256: PUSH
50257: FOR_IN
50258: IFFALSE 50312
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
50260: LD_VAR 0 1
50264: PPUSH
50265: CALL_OW 257
50269: PUSH
50270: LD_INT 1
50272: PUSH
50273: LD_INT 2
50275: PUSH
50276: LD_INT 3
50278: PUSH
50279: LD_INT 4
50281: PUSH
50282: EMPTY
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: IN
50288: IFFALSE 50310
// SetClass ( un , rand ( 1 , 4 ) ) ;
50290: LD_VAR 0 1
50294: PPUSH
50295: LD_INT 1
50297: PPUSH
50298: LD_INT 4
50300: PPUSH
50301: CALL_OW 12
50305: PPUSH
50306: CALL_OW 336
50310: GO 50257
50312: POP
50313: POP
// end ;
50314: PPOPN 1
50316: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
50317: LD_EXP 73
50321: PUSH
50322: LD_EXP 85
50326: AND
50327: IFFALSE 50406
50329: GO 50331
50331: DISABLE
50332: LD_INT 0
50334: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50335: LD_ADDR_VAR 0 1
50339: PUSH
50340: LD_INT 22
50342: PUSH
50343: LD_OWVAR 2
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 21
50354: PUSH
50355: LD_INT 3
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: EMPTY
50363: LIST
50364: LIST
50365: PPUSH
50366: CALL_OW 69
50370: ST_TO_ADDR
// if not tmp then
50371: LD_VAR 0 1
50375: NOT
50376: IFFALSE 50380
// exit ;
50378: GO 50406
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
50380: LD_VAR 0 1
50384: PUSH
50385: LD_INT 1
50387: PPUSH
50388: LD_VAR 0 1
50392: PPUSH
50393: CALL_OW 12
50397: ARRAY
50398: PPUSH
50399: LD_INT 100
50401: PPUSH
50402: CALL_OW 234
// end ;
50406: PPOPN 1
50408: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
50409: LD_EXP 73
50413: PUSH
50414: LD_EXP 87
50418: AND
50419: IFFALSE 50517
50421: GO 50423
50423: DISABLE
50424: LD_INT 0
50426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
50427: LD_ADDR_VAR 0 1
50431: PUSH
50432: LD_INT 22
50434: PUSH
50435: LD_OWVAR 2
50439: PUSH
50440: EMPTY
50441: LIST
50442: LIST
50443: PUSH
50444: LD_INT 21
50446: PUSH
50447: LD_INT 1
50449: PUSH
50450: EMPTY
50451: LIST
50452: LIST
50453: PUSH
50454: EMPTY
50455: LIST
50456: LIST
50457: PPUSH
50458: CALL_OW 69
50462: ST_TO_ADDR
// if not tmp then
50463: LD_VAR 0 1
50467: NOT
50468: IFFALSE 50472
// exit ;
50470: GO 50517
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
50472: LD_VAR 0 1
50476: PUSH
50477: LD_INT 1
50479: PPUSH
50480: LD_VAR 0 1
50484: PPUSH
50485: CALL_OW 12
50489: ARRAY
50490: PPUSH
50491: LD_INT 1
50493: PPUSH
50494: LD_INT 4
50496: PPUSH
50497: CALL_OW 12
50501: PPUSH
50502: LD_INT 3000
50504: PPUSH
50505: LD_INT 9000
50507: PPUSH
50508: CALL_OW 12
50512: PPUSH
50513: CALL_OW 492
// end ;
50517: PPOPN 1
50519: END
// every 0 0$1 trigger StreamModeActive and sDepot do
50520: LD_EXP 73
50524: PUSH
50525: LD_EXP 88
50529: AND
50530: IFFALSE 50550
50532: GO 50534
50534: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
50535: LD_INT 1
50537: PPUSH
50538: LD_OWVAR 2
50542: PPUSH
50543: LD_INT 0
50545: PPUSH
50546: CALL_OW 324
50550: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
50551: LD_EXP 73
50555: PUSH
50556: LD_EXP 89
50560: AND
50561: IFFALSE 50644
50563: GO 50565
50565: DISABLE
50566: LD_INT 0
50568: PPUSH
50569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
50570: LD_ADDR_VAR 0 2
50574: PUSH
50575: LD_INT 22
50577: PUSH
50578: LD_OWVAR 2
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: PUSH
50587: LD_INT 21
50589: PUSH
50590: LD_INT 3
50592: PUSH
50593: EMPTY
50594: LIST
50595: LIST
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: PPUSH
50601: CALL_OW 69
50605: ST_TO_ADDR
// if not tmp then
50606: LD_VAR 0 2
50610: NOT
50611: IFFALSE 50615
// exit ;
50613: GO 50644
// for i in tmp do
50615: LD_ADDR_VAR 0 1
50619: PUSH
50620: LD_VAR 0 2
50624: PUSH
50625: FOR_IN
50626: IFFALSE 50642
// SetBLevel ( i , 10 ) ;
50628: LD_VAR 0 1
50632: PPUSH
50633: LD_INT 10
50635: PPUSH
50636: CALL_OW 241
50640: GO 50625
50642: POP
50643: POP
// end ;
50644: PPOPN 2
50646: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
50647: LD_EXP 73
50651: PUSH
50652: LD_EXP 90
50656: AND
50657: IFFALSE 50768
50659: GO 50661
50661: DISABLE
50662: LD_INT 0
50664: PPUSH
50665: PPUSH
50666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
50667: LD_ADDR_VAR 0 3
50671: PUSH
50672: LD_INT 22
50674: PUSH
50675: LD_OWVAR 2
50679: PUSH
50680: EMPTY
50681: LIST
50682: LIST
50683: PUSH
50684: LD_INT 25
50686: PUSH
50687: LD_INT 1
50689: PUSH
50690: EMPTY
50691: LIST
50692: LIST
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PPUSH
50698: CALL_OW 69
50702: ST_TO_ADDR
// if not tmp then
50703: LD_VAR 0 3
50707: NOT
50708: IFFALSE 50712
// exit ;
50710: GO 50768
// un := tmp [ rand ( 1 , tmp ) ] ;
50712: LD_ADDR_VAR 0 2
50716: PUSH
50717: LD_VAR 0 3
50721: PUSH
50722: LD_INT 1
50724: PPUSH
50725: LD_VAR 0 3
50729: PPUSH
50730: CALL_OW 12
50734: ARRAY
50735: ST_TO_ADDR
// if Crawls ( un ) then
50736: LD_VAR 0 2
50740: PPUSH
50741: CALL_OW 318
50745: IFFALSE 50756
// ComWalk ( un ) ;
50747: LD_VAR 0 2
50751: PPUSH
50752: CALL_OW 138
// SetClass ( un , class_sniper ) ;
50756: LD_VAR 0 2
50760: PPUSH
50761: LD_INT 5
50763: PPUSH
50764: CALL_OW 336
// end ;
50768: PPOPN 3
50770: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
50771: LD_EXP 73
50775: PUSH
50776: LD_EXP 91
50780: AND
50781: PUSH
50782: LD_OWVAR 67
50786: PUSH
50787: LD_INT 4
50789: LESS
50790: AND
50791: IFFALSE 50810
50793: GO 50795
50795: DISABLE
// begin Difficulty := Difficulty + 1 ;
50796: LD_ADDR_OWVAR 67
50800: PUSH
50801: LD_OWVAR 67
50805: PUSH
50806: LD_INT 1
50808: PLUS
50809: ST_TO_ADDR
// end ;
50810: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
50811: LD_EXP 73
50815: PUSH
50816: LD_EXP 92
50820: AND
50821: IFFALSE 50924
50823: GO 50825
50825: DISABLE
50826: LD_INT 0
50828: PPUSH
// begin for i := 1 to 5 do
50829: LD_ADDR_VAR 0 1
50833: PUSH
50834: DOUBLE
50835: LD_INT 1
50837: DEC
50838: ST_TO_ADDR
50839: LD_INT 5
50841: PUSH
50842: FOR_TO
50843: IFFALSE 50922
// begin uc_nation := nation_nature ;
50845: LD_ADDR_OWVAR 21
50849: PUSH
50850: LD_INT 0
50852: ST_TO_ADDR
// uc_side := 0 ;
50853: LD_ADDR_OWVAR 20
50857: PUSH
50858: LD_INT 0
50860: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50861: LD_ADDR_OWVAR 29
50865: PUSH
50866: LD_INT 12
50868: PUSH
50869: LD_INT 12
50871: PUSH
50872: EMPTY
50873: LIST
50874: LIST
50875: ST_TO_ADDR
// hc_agressivity := 20 ;
50876: LD_ADDR_OWVAR 35
50880: PUSH
50881: LD_INT 20
50883: ST_TO_ADDR
// hc_class := class_tiger ;
50884: LD_ADDR_OWVAR 28
50888: PUSH
50889: LD_INT 14
50891: ST_TO_ADDR
// hc_gallery :=  ;
50892: LD_ADDR_OWVAR 33
50896: PUSH
50897: LD_STRING 
50899: ST_TO_ADDR
// hc_name :=  ;
50900: LD_ADDR_OWVAR 26
50904: PUSH
50905: LD_STRING 
50907: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50908: CALL_OW 44
50912: PPUSH
50913: LD_INT 0
50915: PPUSH
50916: CALL_OW 51
// end ;
50920: GO 50842
50922: POP
50923: POP
// end ;
50924: PPOPN 1
50926: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50927: LD_EXP 73
50931: PUSH
50932: LD_EXP 93
50936: AND
50937: IFFALSE 50946
50939: GO 50941
50941: DISABLE
// StreamSibBomb ;
50942: CALL 50947 0 0
50946: END
// export function StreamSibBomb ; var i , x , y ; begin
50947: LD_INT 0
50949: PPUSH
50950: PPUSH
50951: PPUSH
50952: PPUSH
// result := false ;
50953: LD_ADDR_VAR 0 1
50957: PUSH
50958: LD_INT 0
50960: ST_TO_ADDR
// for i := 1 to 16 do
50961: LD_ADDR_VAR 0 2
50965: PUSH
50966: DOUBLE
50967: LD_INT 1
50969: DEC
50970: ST_TO_ADDR
50971: LD_INT 16
50973: PUSH
50974: FOR_TO
50975: IFFALSE 51174
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50977: LD_ADDR_VAR 0 3
50981: PUSH
50982: LD_INT 10
50984: PUSH
50985: LD_INT 20
50987: PUSH
50988: LD_INT 30
50990: PUSH
50991: LD_INT 40
50993: PUSH
50994: LD_INT 50
50996: PUSH
50997: LD_INT 60
50999: PUSH
51000: LD_INT 70
51002: PUSH
51003: LD_INT 80
51005: PUSH
51006: LD_INT 90
51008: PUSH
51009: LD_INT 100
51011: PUSH
51012: LD_INT 110
51014: PUSH
51015: LD_INT 120
51017: PUSH
51018: LD_INT 130
51020: PUSH
51021: LD_INT 140
51023: PUSH
51024: LD_INT 150
51026: PUSH
51027: EMPTY
51028: LIST
51029: LIST
51030: LIST
51031: LIST
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: LIST
51043: PUSH
51044: LD_INT 1
51046: PPUSH
51047: LD_INT 15
51049: PPUSH
51050: CALL_OW 12
51054: ARRAY
51055: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
51056: LD_ADDR_VAR 0 4
51060: PUSH
51061: LD_INT 10
51063: PUSH
51064: LD_INT 20
51066: PUSH
51067: LD_INT 30
51069: PUSH
51070: LD_INT 40
51072: PUSH
51073: LD_INT 50
51075: PUSH
51076: LD_INT 60
51078: PUSH
51079: LD_INT 70
51081: PUSH
51082: LD_INT 80
51084: PUSH
51085: LD_INT 90
51087: PUSH
51088: LD_INT 100
51090: PUSH
51091: LD_INT 110
51093: PUSH
51094: LD_INT 120
51096: PUSH
51097: LD_INT 130
51099: PUSH
51100: LD_INT 140
51102: PUSH
51103: LD_INT 150
51105: PUSH
51106: EMPTY
51107: LIST
51108: LIST
51109: LIST
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: PUSH
51123: LD_INT 1
51125: PPUSH
51126: LD_INT 15
51128: PPUSH
51129: CALL_OW 12
51133: ARRAY
51134: ST_TO_ADDR
// if ValidHex ( x , y ) then
51135: LD_VAR 0 3
51139: PPUSH
51140: LD_VAR 0 4
51144: PPUSH
51145: CALL_OW 488
51149: IFFALSE 51172
// begin result := [ x , y ] ;
51151: LD_ADDR_VAR 0 1
51155: PUSH
51156: LD_VAR 0 3
51160: PUSH
51161: LD_VAR 0 4
51165: PUSH
51166: EMPTY
51167: LIST
51168: LIST
51169: ST_TO_ADDR
// break ;
51170: GO 51174
// end ; end ;
51172: GO 50974
51174: POP
51175: POP
// if result then
51176: LD_VAR 0 1
51180: IFFALSE 51240
// begin ToLua ( playSibBomb() ) ;
51182: LD_STRING playSibBomb()
51184: PPUSH
51185: CALL_OW 559
// wait ( 0 0$14 ) ;
51189: LD_INT 490
51191: PPUSH
51192: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
51196: LD_VAR 0 1
51200: PUSH
51201: LD_INT 1
51203: ARRAY
51204: PPUSH
51205: LD_VAR 0 1
51209: PUSH
51210: LD_INT 2
51212: ARRAY
51213: PPUSH
51214: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
51218: LD_VAR 0 1
51222: PUSH
51223: LD_INT 1
51225: ARRAY
51226: PPUSH
51227: LD_VAR 0 1
51231: PUSH
51232: LD_INT 2
51234: ARRAY
51235: PPUSH
51236: CALL_OW 429
// end ; end ;
51240: LD_VAR 0 1
51244: RET
// every 0 0$1 trigger StreamModeActive and sReset do
51245: LD_EXP 73
51249: PUSH
51250: LD_EXP 95
51254: AND
51255: IFFALSE 51267
51257: GO 51259
51259: DISABLE
// YouLost (  ) ;
51260: LD_STRING 
51262: PPUSH
51263: CALL_OW 104
51267: END
// every 0 0$1 trigger StreamModeActive and sFog do
51268: LD_EXP 73
51272: PUSH
51273: LD_EXP 94
51277: AND
51278: IFFALSE 51292
51280: GO 51282
51282: DISABLE
// FogOff ( your_side ) ;
51283: LD_OWVAR 2
51287: PPUSH
51288: CALL_OW 344
51292: END
// every 0 0$1 trigger StreamModeActive and sSun do
51293: LD_EXP 73
51297: PUSH
51298: LD_EXP 96
51302: AND
51303: IFFALSE 51331
51305: GO 51307
51307: DISABLE
// begin solar_recharge_percent := 0 ;
51308: LD_ADDR_OWVAR 79
51312: PUSH
51313: LD_INT 0
51315: ST_TO_ADDR
// wait ( 5 5$00 ) ;
51316: LD_INT 10500
51318: PPUSH
51319: CALL_OW 67
// solar_recharge_percent := 100 ;
51323: LD_ADDR_OWVAR 79
51327: PUSH
51328: LD_INT 100
51330: ST_TO_ADDR
// end ;
51331: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
51332: LD_EXP 73
51336: PUSH
51337: LD_EXP 97
51341: AND
51342: IFFALSE 51581
51344: GO 51346
51346: DISABLE
51347: LD_INT 0
51349: PPUSH
51350: PPUSH
51351: PPUSH
// begin tmp := [ ] ;
51352: LD_ADDR_VAR 0 3
51356: PUSH
51357: EMPTY
51358: ST_TO_ADDR
// for i := 1 to 6 do
51359: LD_ADDR_VAR 0 1
51363: PUSH
51364: DOUBLE
51365: LD_INT 1
51367: DEC
51368: ST_TO_ADDR
51369: LD_INT 6
51371: PUSH
51372: FOR_TO
51373: IFFALSE 51478
// begin uc_nation := nation_nature ;
51375: LD_ADDR_OWVAR 21
51379: PUSH
51380: LD_INT 0
51382: ST_TO_ADDR
// uc_side := 0 ;
51383: LD_ADDR_OWVAR 20
51387: PUSH
51388: LD_INT 0
51390: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51391: LD_ADDR_OWVAR 29
51395: PUSH
51396: LD_INT 12
51398: PUSH
51399: LD_INT 12
51401: PUSH
51402: EMPTY
51403: LIST
51404: LIST
51405: ST_TO_ADDR
// hc_agressivity := 20 ;
51406: LD_ADDR_OWVAR 35
51410: PUSH
51411: LD_INT 20
51413: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
51414: LD_ADDR_OWVAR 28
51418: PUSH
51419: LD_INT 17
51421: ST_TO_ADDR
// hc_gallery :=  ;
51422: LD_ADDR_OWVAR 33
51426: PUSH
51427: LD_STRING 
51429: ST_TO_ADDR
// hc_name :=  ;
51430: LD_ADDR_OWVAR 26
51434: PUSH
51435: LD_STRING 
51437: ST_TO_ADDR
// un := CreateHuman ;
51438: LD_ADDR_VAR 0 2
51442: PUSH
51443: CALL_OW 44
51447: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
51448: LD_VAR 0 2
51452: PPUSH
51453: LD_INT 1
51455: PPUSH
51456: CALL_OW 51
// tmp := tmp ^ un ;
51460: LD_ADDR_VAR 0 3
51464: PUSH
51465: LD_VAR 0 3
51469: PUSH
51470: LD_VAR 0 2
51474: ADD
51475: ST_TO_ADDR
// end ;
51476: GO 51372
51478: POP
51479: POP
// repeat wait ( 0 0$1 ) ;
51480: LD_INT 35
51482: PPUSH
51483: CALL_OW 67
// for un in tmp do
51487: LD_ADDR_VAR 0 2
51491: PUSH
51492: LD_VAR 0 3
51496: PUSH
51497: FOR_IN
51498: IFFALSE 51572
// begin if IsDead ( un ) then
51500: LD_VAR 0 2
51504: PPUSH
51505: CALL_OW 301
51509: IFFALSE 51529
// begin tmp := tmp diff un ;
51511: LD_ADDR_VAR 0 3
51515: PUSH
51516: LD_VAR 0 3
51520: PUSH
51521: LD_VAR 0 2
51525: DIFF
51526: ST_TO_ADDR
// continue ;
51527: GO 51497
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
51529: LD_VAR 0 2
51533: PPUSH
51534: LD_INT 3
51536: PUSH
51537: LD_INT 22
51539: PUSH
51540: LD_INT 0
51542: PUSH
51543: EMPTY
51544: LIST
51545: LIST
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: PPUSH
51551: CALL_OW 69
51555: PPUSH
51556: LD_VAR 0 2
51560: PPUSH
51561: CALL_OW 74
51565: PPUSH
51566: CALL_OW 115
// end ;
51570: GO 51497
51572: POP
51573: POP
// until not tmp ;
51574: LD_VAR 0 3
51578: NOT
51579: IFFALSE 51480
// end ;
51581: PPOPN 3
51583: END
// every 0 0$1 trigger StreamModeActive and sTroll do
51584: LD_EXP 73
51588: PUSH
51589: LD_EXP 98
51593: AND
51594: IFFALSE 51648
51596: GO 51598
51598: DISABLE
// begin ToLua ( displayTroll(); ) ;
51599: LD_STRING displayTroll();
51601: PPUSH
51602: CALL_OW 559
// wait ( 3 3$00 ) ;
51606: LD_INT 6300
51608: PPUSH
51609: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51613: LD_STRING hideTroll();
51615: PPUSH
51616: CALL_OW 559
// wait ( 1 1$00 ) ;
51620: LD_INT 2100
51622: PPUSH
51623: CALL_OW 67
// ToLua ( displayTroll(); ) ;
51627: LD_STRING displayTroll();
51629: PPUSH
51630: CALL_OW 559
// wait ( 1 1$00 ) ;
51634: LD_INT 2100
51636: PPUSH
51637: CALL_OW 67
// ToLua ( hideTroll(); ) ;
51641: LD_STRING hideTroll();
51643: PPUSH
51644: CALL_OW 559
// end ;
51648: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
51649: LD_EXP 73
51653: PUSH
51654: LD_EXP 99
51658: AND
51659: IFFALSE 51722
51661: GO 51663
51663: DISABLE
51664: LD_INT 0
51666: PPUSH
// begin p := 0 ;
51667: LD_ADDR_VAR 0 1
51671: PUSH
51672: LD_INT 0
51674: ST_TO_ADDR
// repeat game_speed := 1 ;
51675: LD_ADDR_OWVAR 65
51679: PUSH
51680: LD_INT 1
51682: ST_TO_ADDR
// wait ( 0 0$1 ) ;
51683: LD_INT 35
51685: PPUSH
51686: CALL_OW 67
// p := p + 1 ;
51690: LD_ADDR_VAR 0 1
51694: PUSH
51695: LD_VAR 0 1
51699: PUSH
51700: LD_INT 1
51702: PLUS
51703: ST_TO_ADDR
// until p >= 60 ;
51704: LD_VAR 0 1
51708: PUSH
51709: LD_INT 60
51711: GREATEREQUAL
51712: IFFALSE 51675
// game_speed := 4 ;
51714: LD_ADDR_OWVAR 65
51718: PUSH
51719: LD_INT 4
51721: ST_TO_ADDR
// end ;
51722: PPOPN 1
51724: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
51725: LD_EXP 73
51729: PUSH
51730: LD_EXP 100
51734: AND
51735: IFFALSE 51881
51737: GO 51739
51739: DISABLE
51740: LD_INT 0
51742: PPUSH
51743: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51744: LD_ADDR_VAR 0 1
51748: PUSH
51749: LD_INT 22
51751: PUSH
51752: LD_OWVAR 2
51756: PUSH
51757: EMPTY
51758: LIST
51759: LIST
51760: PUSH
51761: LD_INT 2
51763: PUSH
51764: LD_INT 30
51766: PUSH
51767: LD_INT 0
51769: PUSH
51770: EMPTY
51771: LIST
51772: LIST
51773: PUSH
51774: LD_INT 30
51776: PUSH
51777: LD_INT 1
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: PUSH
51784: EMPTY
51785: LIST
51786: LIST
51787: LIST
51788: PUSH
51789: EMPTY
51790: LIST
51791: LIST
51792: PPUSH
51793: CALL_OW 69
51797: ST_TO_ADDR
// if not depot then
51798: LD_VAR 0 1
51802: NOT
51803: IFFALSE 51807
// exit ;
51805: GO 51881
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
51807: LD_ADDR_VAR 0 2
51811: PUSH
51812: LD_VAR 0 1
51816: PUSH
51817: LD_INT 1
51819: PPUSH
51820: LD_VAR 0 1
51824: PPUSH
51825: CALL_OW 12
51829: ARRAY
51830: PPUSH
51831: CALL_OW 274
51835: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51836: LD_VAR 0 2
51840: PPUSH
51841: LD_INT 1
51843: PPUSH
51844: LD_INT 0
51846: PPUSH
51847: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51851: LD_VAR 0 2
51855: PPUSH
51856: LD_INT 2
51858: PPUSH
51859: LD_INT 0
51861: PPUSH
51862: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51866: LD_VAR 0 2
51870: PPUSH
51871: LD_INT 3
51873: PPUSH
51874: LD_INT 0
51876: PPUSH
51877: CALL_OW 277
// end ;
51881: PPOPN 2
51883: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51884: LD_EXP 73
51888: PUSH
51889: LD_EXP 101
51893: AND
51894: IFFALSE 51991
51896: GO 51898
51898: DISABLE
51899: LD_INT 0
51901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51902: LD_ADDR_VAR 0 1
51906: PUSH
51907: LD_INT 22
51909: PUSH
51910: LD_OWVAR 2
51914: PUSH
51915: EMPTY
51916: LIST
51917: LIST
51918: PUSH
51919: LD_INT 21
51921: PUSH
51922: LD_INT 1
51924: PUSH
51925: EMPTY
51926: LIST
51927: LIST
51928: PUSH
51929: LD_INT 3
51931: PUSH
51932: LD_INT 23
51934: PUSH
51935: LD_INT 0
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: PUSH
51942: EMPTY
51943: LIST
51944: LIST
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: LIST
51950: PPUSH
51951: CALL_OW 69
51955: ST_TO_ADDR
// if not tmp then
51956: LD_VAR 0 1
51960: NOT
51961: IFFALSE 51965
// exit ;
51963: GO 51991
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51965: LD_VAR 0 1
51969: PUSH
51970: LD_INT 1
51972: PPUSH
51973: LD_VAR 0 1
51977: PPUSH
51978: CALL_OW 12
51982: ARRAY
51983: PPUSH
51984: LD_INT 200
51986: PPUSH
51987: CALL_OW 234
// end ;
51991: PPOPN 1
51993: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51994: LD_EXP 73
51998: PUSH
51999: LD_EXP 102
52003: AND
52004: IFFALSE 52083
52006: GO 52008
52008: DISABLE
52009: LD_INT 0
52011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
52012: LD_ADDR_VAR 0 1
52016: PUSH
52017: LD_INT 22
52019: PUSH
52020: LD_OWVAR 2
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: PUSH
52029: LD_INT 21
52031: PUSH
52032: LD_INT 2
52034: PUSH
52035: EMPTY
52036: LIST
52037: LIST
52038: PUSH
52039: EMPTY
52040: LIST
52041: LIST
52042: PPUSH
52043: CALL_OW 69
52047: ST_TO_ADDR
// if not tmp then
52048: LD_VAR 0 1
52052: NOT
52053: IFFALSE 52057
// exit ;
52055: GO 52083
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
52057: LD_VAR 0 1
52061: PUSH
52062: LD_INT 1
52064: PPUSH
52065: LD_VAR 0 1
52069: PPUSH
52070: CALL_OW 12
52074: ARRAY
52075: PPUSH
52076: LD_INT 60
52078: PPUSH
52079: CALL_OW 234
// end ;
52083: PPOPN 1
52085: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
52086: LD_EXP 73
52090: PUSH
52091: LD_EXP 103
52095: AND
52096: IFFALSE 52195
52098: GO 52100
52100: DISABLE
52101: LD_INT 0
52103: PPUSH
52104: PPUSH
// begin enable ;
52105: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
52106: LD_ADDR_VAR 0 1
52110: PUSH
52111: LD_INT 22
52113: PUSH
52114: LD_OWVAR 2
52118: PUSH
52119: EMPTY
52120: LIST
52121: LIST
52122: PUSH
52123: LD_INT 61
52125: PUSH
52126: EMPTY
52127: LIST
52128: PUSH
52129: LD_INT 33
52131: PUSH
52132: LD_INT 2
52134: PUSH
52135: EMPTY
52136: LIST
52137: LIST
52138: PUSH
52139: EMPTY
52140: LIST
52141: LIST
52142: LIST
52143: PPUSH
52144: CALL_OW 69
52148: ST_TO_ADDR
// if not tmp then
52149: LD_VAR 0 1
52153: NOT
52154: IFFALSE 52158
// exit ;
52156: GO 52195
// for i in tmp do
52158: LD_ADDR_VAR 0 2
52162: PUSH
52163: LD_VAR 0 1
52167: PUSH
52168: FOR_IN
52169: IFFALSE 52193
// if IsControledBy ( i ) then
52171: LD_VAR 0 2
52175: PPUSH
52176: CALL_OW 312
52180: IFFALSE 52191
// ComUnlink ( i ) ;
52182: LD_VAR 0 2
52186: PPUSH
52187: CALL_OW 136
52191: GO 52168
52193: POP
52194: POP
// end ;
52195: PPOPN 2
52197: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
52198: LD_EXP 73
52202: PUSH
52203: LD_EXP 104
52207: AND
52208: IFFALSE 52348
52210: GO 52212
52212: DISABLE
52213: LD_INT 0
52215: PPUSH
52216: PPUSH
// begin ToLua ( displayPowell(); ) ;
52217: LD_STRING displayPowell();
52219: PPUSH
52220: CALL_OW 559
// uc_side := 0 ;
52224: LD_ADDR_OWVAR 20
52228: PUSH
52229: LD_INT 0
52231: ST_TO_ADDR
// uc_nation := 2 ;
52232: LD_ADDR_OWVAR 21
52236: PUSH
52237: LD_INT 2
52239: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
52240: LD_ADDR_OWVAR 37
52244: PUSH
52245: LD_INT 14
52247: ST_TO_ADDR
// vc_engine := engine_siberite ;
52248: LD_ADDR_OWVAR 39
52252: PUSH
52253: LD_INT 3
52255: ST_TO_ADDR
// vc_control := control_apeman ;
52256: LD_ADDR_OWVAR 38
52260: PUSH
52261: LD_INT 5
52263: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
52264: LD_ADDR_OWVAR 40
52268: PUSH
52269: LD_INT 29
52271: ST_TO_ADDR
// un := CreateVehicle ;
52272: LD_ADDR_VAR 0 2
52276: PUSH
52277: CALL_OW 45
52281: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52282: LD_VAR 0 2
52286: PPUSH
52287: LD_INT 1
52289: PPUSH
52290: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52294: LD_INT 35
52296: PPUSH
52297: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52301: LD_VAR 0 2
52305: PPUSH
52306: LD_INT 22
52308: PUSH
52309: LD_OWVAR 2
52313: PUSH
52314: EMPTY
52315: LIST
52316: LIST
52317: PPUSH
52318: CALL_OW 69
52322: PPUSH
52323: LD_VAR 0 2
52327: PPUSH
52328: CALL_OW 74
52332: PPUSH
52333: CALL_OW 115
// until IsDead ( un ) ;
52337: LD_VAR 0 2
52341: PPUSH
52342: CALL_OW 301
52346: IFFALSE 52294
// end ;
52348: PPOPN 2
52350: END
// every 0 0$1 trigger StreamModeActive and sStu do
52351: LD_EXP 73
52355: PUSH
52356: LD_EXP 112
52360: AND
52361: IFFALSE 52377
52363: GO 52365
52365: DISABLE
// begin ToLua ( displayStucuk(); ) ;
52366: LD_STRING displayStucuk();
52368: PPUSH
52369: CALL_OW 559
// ResetFog ;
52373: CALL_OW 335
// end ;
52377: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
52378: LD_EXP 73
52382: PUSH
52383: LD_EXP 105
52387: AND
52388: IFFALSE 52529
52390: GO 52392
52392: DISABLE
52393: LD_INT 0
52395: PPUSH
52396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52397: LD_ADDR_VAR 0 2
52401: PUSH
52402: LD_INT 22
52404: PUSH
52405: LD_OWVAR 2
52409: PUSH
52410: EMPTY
52411: LIST
52412: LIST
52413: PUSH
52414: LD_INT 21
52416: PUSH
52417: LD_INT 1
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: PUSH
52424: EMPTY
52425: LIST
52426: LIST
52427: PPUSH
52428: CALL_OW 69
52432: ST_TO_ADDR
// if not tmp then
52433: LD_VAR 0 2
52437: NOT
52438: IFFALSE 52442
// exit ;
52440: GO 52529
// un := tmp [ rand ( 1 , tmp ) ] ;
52442: LD_ADDR_VAR 0 1
52446: PUSH
52447: LD_VAR 0 2
52451: PUSH
52452: LD_INT 1
52454: PPUSH
52455: LD_VAR 0 2
52459: PPUSH
52460: CALL_OW 12
52464: ARRAY
52465: ST_TO_ADDR
// SetSide ( un , 0 ) ;
52466: LD_VAR 0 1
52470: PPUSH
52471: LD_INT 0
52473: PPUSH
52474: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
52478: LD_VAR 0 1
52482: PPUSH
52483: LD_OWVAR 3
52487: PUSH
52488: LD_VAR 0 1
52492: DIFF
52493: PPUSH
52494: LD_VAR 0 1
52498: PPUSH
52499: CALL_OW 74
52503: PPUSH
52504: CALL_OW 115
// wait ( 0 0$20 ) ;
52508: LD_INT 700
52510: PPUSH
52511: CALL_OW 67
// SetSide ( un , your_side ) ;
52515: LD_VAR 0 1
52519: PPUSH
52520: LD_OWVAR 2
52524: PPUSH
52525: CALL_OW 235
// end ;
52529: PPOPN 2
52531: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
52532: LD_EXP 73
52536: PUSH
52537: LD_EXP 106
52541: AND
52542: IFFALSE 52648
52544: GO 52546
52546: DISABLE
52547: LD_INT 0
52549: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
52550: LD_ADDR_VAR 0 1
52554: PUSH
52555: LD_INT 22
52557: PUSH
52558: LD_OWVAR 2
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: PUSH
52567: LD_INT 2
52569: PUSH
52570: LD_INT 30
52572: PUSH
52573: LD_INT 0
52575: PUSH
52576: EMPTY
52577: LIST
52578: LIST
52579: PUSH
52580: LD_INT 30
52582: PUSH
52583: LD_INT 1
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: LIST
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: PPUSH
52599: CALL_OW 69
52603: ST_TO_ADDR
// if not depot then
52604: LD_VAR 0 1
52608: NOT
52609: IFFALSE 52613
// exit ;
52611: GO 52648
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
52613: LD_VAR 0 1
52617: PUSH
52618: LD_INT 1
52620: ARRAY
52621: PPUSH
52622: CALL_OW 250
52626: PPUSH
52627: LD_VAR 0 1
52631: PUSH
52632: LD_INT 1
52634: ARRAY
52635: PPUSH
52636: CALL_OW 251
52640: PPUSH
52641: LD_INT 70
52643: PPUSH
52644: CALL_OW 495
// end ;
52648: PPOPN 1
52650: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
52651: LD_EXP 73
52655: PUSH
52656: LD_EXP 107
52660: AND
52661: IFFALSE 52872
52663: GO 52665
52665: DISABLE
52666: LD_INT 0
52668: PPUSH
52669: PPUSH
52670: PPUSH
52671: PPUSH
52672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
52673: LD_ADDR_VAR 0 5
52677: PUSH
52678: LD_INT 22
52680: PUSH
52681: LD_OWVAR 2
52685: PUSH
52686: EMPTY
52687: LIST
52688: LIST
52689: PUSH
52690: LD_INT 21
52692: PUSH
52693: LD_INT 1
52695: PUSH
52696: EMPTY
52697: LIST
52698: LIST
52699: PUSH
52700: EMPTY
52701: LIST
52702: LIST
52703: PPUSH
52704: CALL_OW 69
52708: ST_TO_ADDR
// if not tmp then
52709: LD_VAR 0 5
52713: NOT
52714: IFFALSE 52718
// exit ;
52716: GO 52872
// for i in tmp do
52718: LD_ADDR_VAR 0 1
52722: PUSH
52723: LD_VAR 0 5
52727: PUSH
52728: FOR_IN
52729: IFFALSE 52870
// begin d := rand ( 0 , 5 ) ;
52731: LD_ADDR_VAR 0 4
52735: PUSH
52736: LD_INT 0
52738: PPUSH
52739: LD_INT 5
52741: PPUSH
52742: CALL_OW 12
52746: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
52747: LD_ADDR_VAR 0 2
52751: PUSH
52752: LD_VAR 0 1
52756: PPUSH
52757: CALL_OW 250
52761: PPUSH
52762: LD_VAR 0 4
52766: PPUSH
52767: LD_INT 3
52769: PPUSH
52770: LD_INT 12
52772: PPUSH
52773: CALL_OW 12
52777: PPUSH
52778: CALL_OW 272
52782: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
52783: LD_ADDR_VAR 0 3
52787: PUSH
52788: LD_VAR 0 1
52792: PPUSH
52793: CALL_OW 251
52797: PPUSH
52798: LD_VAR 0 4
52802: PPUSH
52803: LD_INT 3
52805: PPUSH
52806: LD_INT 12
52808: PPUSH
52809: CALL_OW 12
52813: PPUSH
52814: CALL_OW 273
52818: ST_TO_ADDR
// if ValidHex ( x , y ) then
52819: LD_VAR 0 2
52823: PPUSH
52824: LD_VAR 0 3
52828: PPUSH
52829: CALL_OW 488
52833: IFFALSE 52868
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52835: LD_VAR 0 1
52839: PPUSH
52840: LD_VAR 0 2
52844: PPUSH
52845: LD_VAR 0 3
52849: PPUSH
52850: LD_INT 3
52852: PPUSH
52853: LD_INT 6
52855: PPUSH
52856: CALL_OW 12
52860: PPUSH
52861: LD_INT 1
52863: PPUSH
52864: CALL_OW 483
// end ;
52868: GO 52728
52870: POP
52871: POP
// end ;
52872: PPOPN 5
52874: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52875: LD_EXP 73
52879: PUSH
52880: LD_EXP 108
52884: AND
52885: IFFALSE 52979
52887: GO 52889
52889: DISABLE
52890: LD_INT 0
52892: PPUSH
52893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52894: LD_ADDR_VAR 0 2
52898: PUSH
52899: LD_INT 22
52901: PUSH
52902: LD_OWVAR 2
52906: PUSH
52907: EMPTY
52908: LIST
52909: LIST
52910: PUSH
52911: LD_INT 32
52913: PUSH
52914: LD_INT 1
52916: PUSH
52917: EMPTY
52918: LIST
52919: LIST
52920: PUSH
52921: LD_INT 21
52923: PUSH
52924: LD_INT 2
52926: PUSH
52927: EMPTY
52928: LIST
52929: LIST
52930: PUSH
52931: EMPTY
52932: LIST
52933: LIST
52934: LIST
52935: PPUSH
52936: CALL_OW 69
52940: ST_TO_ADDR
// if not tmp then
52941: LD_VAR 0 2
52945: NOT
52946: IFFALSE 52950
// exit ;
52948: GO 52979
// for i in tmp do
52950: LD_ADDR_VAR 0 1
52954: PUSH
52955: LD_VAR 0 2
52959: PUSH
52960: FOR_IN
52961: IFFALSE 52977
// SetFuel ( i , 0 ) ;
52963: LD_VAR 0 1
52967: PPUSH
52968: LD_INT 0
52970: PPUSH
52971: CALL_OW 240
52975: GO 52960
52977: POP
52978: POP
// end ;
52979: PPOPN 2
52981: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52982: LD_EXP 73
52986: PUSH
52987: LD_EXP 109
52991: AND
52992: IFFALSE 53058
52994: GO 52996
52996: DISABLE
52997: LD_INT 0
52999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53000: LD_ADDR_VAR 0 1
53004: PUSH
53005: LD_INT 22
53007: PUSH
53008: LD_OWVAR 2
53012: PUSH
53013: EMPTY
53014: LIST
53015: LIST
53016: PUSH
53017: LD_INT 30
53019: PUSH
53020: LD_INT 29
53022: PUSH
53023: EMPTY
53024: LIST
53025: LIST
53026: PUSH
53027: EMPTY
53028: LIST
53029: LIST
53030: PPUSH
53031: CALL_OW 69
53035: ST_TO_ADDR
// if not tmp then
53036: LD_VAR 0 1
53040: NOT
53041: IFFALSE 53045
// exit ;
53043: GO 53058
// DestroyUnit ( tmp [ 1 ] ) ;
53045: LD_VAR 0 1
53049: PUSH
53050: LD_INT 1
53052: ARRAY
53053: PPUSH
53054: CALL_OW 65
// end ;
53058: PPOPN 1
53060: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
53061: LD_EXP 73
53065: PUSH
53066: LD_EXP 111
53070: AND
53071: IFFALSE 53200
53073: GO 53075
53075: DISABLE
53076: LD_INT 0
53078: PPUSH
// begin uc_side := 0 ;
53079: LD_ADDR_OWVAR 20
53083: PUSH
53084: LD_INT 0
53086: ST_TO_ADDR
// uc_nation := nation_arabian ;
53087: LD_ADDR_OWVAR 21
53091: PUSH
53092: LD_INT 2
53094: ST_TO_ADDR
// hc_gallery :=  ;
53095: LD_ADDR_OWVAR 33
53099: PUSH
53100: LD_STRING 
53102: ST_TO_ADDR
// hc_name :=  ;
53103: LD_ADDR_OWVAR 26
53107: PUSH
53108: LD_STRING 
53110: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
53111: LD_INT 1
53113: PPUSH
53114: LD_INT 11
53116: PPUSH
53117: LD_INT 10
53119: PPUSH
53120: CALL_OW 380
// un := CreateHuman ;
53124: LD_ADDR_VAR 0 1
53128: PUSH
53129: CALL_OW 44
53133: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
53134: LD_VAR 0 1
53138: PPUSH
53139: LD_INT 1
53141: PPUSH
53142: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
53146: LD_INT 35
53148: PPUSH
53149: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
53153: LD_VAR 0 1
53157: PPUSH
53158: LD_INT 22
53160: PUSH
53161: LD_OWVAR 2
53165: PUSH
53166: EMPTY
53167: LIST
53168: LIST
53169: PPUSH
53170: CALL_OW 69
53174: PPUSH
53175: LD_VAR 0 1
53179: PPUSH
53180: CALL_OW 74
53184: PPUSH
53185: CALL_OW 115
// until IsDead ( un ) ;
53189: LD_VAR 0 1
53193: PPUSH
53194: CALL_OW 301
53198: IFFALSE 53146
// end ;
53200: PPOPN 1
53202: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
53203: LD_EXP 73
53207: PUSH
53208: LD_EXP 113
53212: AND
53213: IFFALSE 53225
53215: GO 53217
53217: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
53218: LD_STRING earthquake(getX(game), 0, 32)
53220: PPUSH
53221: CALL_OW 559
53225: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
53226: LD_EXP 73
53230: PUSH
53231: LD_EXP 114
53235: AND
53236: IFFALSE 53327
53238: GO 53240
53240: DISABLE
53241: LD_INT 0
53243: PPUSH
// begin enable ;
53244: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
53245: LD_ADDR_VAR 0 1
53249: PUSH
53250: LD_INT 22
53252: PUSH
53253: LD_OWVAR 2
53257: PUSH
53258: EMPTY
53259: LIST
53260: LIST
53261: PUSH
53262: LD_INT 21
53264: PUSH
53265: LD_INT 2
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: PUSH
53272: LD_INT 33
53274: PUSH
53275: LD_INT 3
53277: PUSH
53278: EMPTY
53279: LIST
53280: LIST
53281: PUSH
53282: EMPTY
53283: LIST
53284: LIST
53285: LIST
53286: PPUSH
53287: CALL_OW 69
53291: ST_TO_ADDR
// if not tmp then
53292: LD_VAR 0 1
53296: NOT
53297: IFFALSE 53301
// exit ;
53299: GO 53327
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53301: LD_VAR 0 1
53305: PUSH
53306: LD_INT 1
53308: PPUSH
53309: LD_VAR 0 1
53313: PPUSH
53314: CALL_OW 12
53318: ARRAY
53319: PPUSH
53320: LD_INT 1
53322: PPUSH
53323: CALL_OW 234
// end ;
53327: PPOPN 1
53329: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
53330: LD_EXP 73
53334: PUSH
53335: LD_EXP 115
53339: AND
53340: IFFALSE 53481
53342: GO 53344
53344: DISABLE
53345: LD_INT 0
53347: PPUSH
53348: PPUSH
53349: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53350: LD_ADDR_VAR 0 3
53354: PUSH
53355: LD_INT 22
53357: PUSH
53358: LD_OWVAR 2
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: PUSH
53367: LD_INT 25
53369: PUSH
53370: LD_INT 1
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: PUSH
53377: EMPTY
53378: LIST
53379: LIST
53380: PPUSH
53381: CALL_OW 69
53385: ST_TO_ADDR
// if not tmp then
53386: LD_VAR 0 3
53390: NOT
53391: IFFALSE 53395
// exit ;
53393: GO 53481
// un := tmp [ rand ( 1 , tmp ) ] ;
53395: LD_ADDR_VAR 0 2
53399: PUSH
53400: LD_VAR 0 3
53404: PUSH
53405: LD_INT 1
53407: PPUSH
53408: LD_VAR 0 3
53412: PPUSH
53413: CALL_OW 12
53417: ARRAY
53418: ST_TO_ADDR
// if Crawls ( un ) then
53419: LD_VAR 0 2
53423: PPUSH
53424: CALL_OW 318
53428: IFFALSE 53439
// ComWalk ( un ) ;
53430: LD_VAR 0 2
53434: PPUSH
53435: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
53439: LD_VAR 0 2
53443: PPUSH
53444: LD_INT 9
53446: PPUSH
53447: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
53451: LD_INT 28
53453: PPUSH
53454: LD_OWVAR 2
53458: PPUSH
53459: LD_INT 2
53461: PPUSH
53462: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
53466: LD_INT 29
53468: PPUSH
53469: LD_OWVAR 2
53473: PPUSH
53474: LD_INT 2
53476: PPUSH
53477: CALL_OW 322
// end ;
53481: PPOPN 3
53483: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
53484: LD_EXP 73
53488: PUSH
53489: LD_EXP 116
53493: AND
53494: IFFALSE 53605
53496: GO 53498
53498: DISABLE
53499: LD_INT 0
53501: PPUSH
53502: PPUSH
53503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53504: LD_ADDR_VAR 0 3
53508: PUSH
53509: LD_INT 22
53511: PUSH
53512: LD_OWVAR 2
53516: PUSH
53517: EMPTY
53518: LIST
53519: LIST
53520: PUSH
53521: LD_INT 25
53523: PUSH
53524: LD_INT 1
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: PPUSH
53535: CALL_OW 69
53539: ST_TO_ADDR
// if not tmp then
53540: LD_VAR 0 3
53544: NOT
53545: IFFALSE 53549
// exit ;
53547: GO 53605
// un := tmp [ rand ( 1 , tmp ) ] ;
53549: LD_ADDR_VAR 0 2
53553: PUSH
53554: LD_VAR 0 3
53558: PUSH
53559: LD_INT 1
53561: PPUSH
53562: LD_VAR 0 3
53566: PPUSH
53567: CALL_OW 12
53571: ARRAY
53572: ST_TO_ADDR
// if Crawls ( un ) then
53573: LD_VAR 0 2
53577: PPUSH
53578: CALL_OW 318
53582: IFFALSE 53593
// ComWalk ( un ) ;
53584: LD_VAR 0 2
53588: PPUSH
53589: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53593: LD_VAR 0 2
53597: PPUSH
53598: LD_INT 8
53600: PPUSH
53601: CALL_OW 336
// end ;
53605: PPOPN 3
53607: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
53608: LD_EXP 73
53612: PUSH
53613: LD_EXP 117
53617: AND
53618: IFFALSE 53762
53620: GO 53622
53622: DISABLE
53623: LD_INT 0
53625: PPUSH
53626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
53627: LD_ADDR_VAR 0 2
53631: PUSH
53632: LD_INT 22
53634: PUSH
53635: LD_OWVAR 2
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: PUSH
53644: LD_INT 21
53646: PUSH
53647: LD_INT 2
53649: PUSH
53650: EMPTY
53651: LIST
53652: LIST
53653: PUSH
53654: LD_INT 2
53656: PUSH
53657: LD_INT 34
53659: PUSH
53660: LD_INT 12
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PUSH
53667: LD_INT 34
53669: PUSH
53670: LD_INT 51
53672: PUSH
53673: EMPTY
53674: LIST
53675: LIST
53676: PUSH
53677: LD_INT 34
53679: PUSH
53680: LD_INT 32
53682: PUSH
53683: EMPTY
53684: LIST
53685: LIST
53686: PUSH
53687: EMPTY
53688: LIST
53689: LIST
53690: LIST
53691: LIST
53692: PUSH
53693: EMPTY
53694: LIST
53695: LIST
53696: LIST
53697: PPUSH
53698: CALL_OW 69
53702: ST_TO_ADDR
// if not tmp then
53703: LD_VAR 0 2
53707: NOT
53708: IFFALSE 53712
// exit ;
53710: GO 53762
// for i in tmp do
53712: LD_ADDR_VAR 0 1
53716: PUSH
53717: LD_VAR 0 2
53721: PUSH
53722: FOR_IN
53723: IFFALSE 53760
// if GetCargo ( i , mat_artifact ) = 0 then
53725: LD_VAR 0 1
53729: PPUSH
53730: LD_INT 4
53732: PPUSH
53733: CALL_OW 289
53737: PUSH
53738: LD_INT 0
53740: EQUAL
53741: IFFALSE 53758
// SetCargo ( i , mat_siberit , 100 ) ;
53743: LD_VAR 0 1
53747: PPUSH
53748: LD_INT 3
53750: PPUSH
53751: LD_INT 100
53753: PPUSH
53754: CALL_OW 290
53758: GO 53722
53760: POP
53761: POP
// end ;
53762: PPOPN 2
53764: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
53765: LD_EXP 73
53769: PUSH
53770: LD_EXP 118
53774: AND
53775: IFFALSE 53958
53777: GO 53779
53779: DISABLE
53780: LD_INT 0
53782: PPUSH
53783: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
53784: LD_ADDR_VAR 0 2
53788: PUSH
53789: LD_INT 22
53791: PUSH
53792: LD_OWVAR 2
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PPUSH
53801: CALL_OW 69
53805: ST_TO_ADDR
// if not tmp then
53806: LD_VAR 0 2
53810: NOT
53811: IFFALSE 53815
// exit ;
53813: GO 53958
// for i := 1 to 2 do
53815: LD_ADDR_VAR 0 1
53819: PUSH
53820: DOUBLE
53821: LD_INT 1
53823: DEC
53824: ST_TO_ADDR
53825: LD_INT 2
53827: PUSH
53828: FOR_TO
53829: IFFALSE 53956
// begin uc_side := your_side ;
53831: LD_ADDR_OWVAR 20
53835: PUSH
53836: LD_OWVAR 2
53840: ST_TO_ADDR
// uc_nation := nation_american ;
53841: LD_ADDR_OWVAR 21
53845: PUSH
53846: LD_INT 1
53848: ST_TO_ADDR
// vc_chassis := us_morphling ;
53849: LD_ADDR_OWVAR 37
53853: PUSH
53854: LD_INT 5
53856: ST_TO_ADDR
// vc_engine := engine_siberite ;
53857: LD_ADDR_OWVAR 39
53861: PUSH
53862: LD_INT 3
53864: ST_TO_ADDR
// vc_control := control_computer ;
53865: LD_ADDR_OWVAR 38
53869: PUSH
53870: LD_INT 3
53872: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53873: LD_ADDR_OWVAR 40
53877: PUSH
53878: LD_INT 10
53880: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53881: LD_VAR 0 2
53885: PUSH
53886: LD_INT 1
53888: ARRAY
53889: PPUSH
53890: CALL_OW 310
53894: NOT
53895: IFFALSE 53942
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53897: CALL_OW 45
53901: PPUSH
53902: LD_VAR 0 2
53906: PUSH
53907: LD_INT 1
53909: ARRAY
53910: PPUSH
53911: CALL_OW 250
53915: PPUSH
53916: LD_VAR 0 2
53920: PUSH
53921: LD_INT 1
53923: ARRAY
53924: PPUSH
53925: CALL_OW 251
53929: PPUSH
53930: LD_INT 12
53932: PPUSH
53933: LD_INT 1
53935: PPUSH
53936: CALL_OW 50
53940: GO 53954
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53942: CALL_OW 45
53946: PPUSH
53947: LD_INT 1
53949: PPUSH
53950: CALL_OW 51
// end ;
53954: GO 53828
53956: POP
53957: POP
// end ;
53958: PPOPN 2
53960: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53961: LD_EXP 73
53965: PUSH
53966: LD_EXP 119
53970: AND
53971: IFFALSE 54193
53973: GO 53975
53975: DISABLE
53976: LD_INT 0
53978: PPUSH
53979: PPUSH
53980: PPUSH
53981: PPUSH
53982: PPUSH
53983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53984: LD_ADDR_VAR 0 6
53988: PUSH
53989: LD_INT 22
53991: PUSH
53992: LD_OWVAR 2
53996: PUSH
53997: EMPTY
53998: LIST
53999: LIST
54000: PUSH
54001: LD_INT 21
54003: PUSH
54004: LD_INT 1
54006: PUSH
54007: EMPTY
54008: LIST
54009: LIST
54010: PUSH
54011: LD_INT 3
54013: PUSH
54014: LD_INT 23
54016: PUSH
54017: LD_INT 0
54019: PUSH
54020: EMPTY
54021: LIST
54022: LIST
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PUSH
54028: EMPTY
54029: LIST
54030: LIST
54031: LIST
54032: PPUSH
54033: CALL_OW 69
54037: ST_TO_ADDR
// if not tmp then
54038: LD_VAR 0 6
54042: NOT
54043: IFFALSE 54047
// exit ;
54045: GO 54193
// s1 := rand ( 1 , 4 ) ;
54047: LD_ADDR_VAR 0 2
54051: PUSH
54052: LD_INT 1
54054: PPUSH
54055: LD_INT 4
54057: PPUSH
54058: CALL_OW 12
54062: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
54063: LD_ADDR_VAR 0 4
54067: PUSH
54068: LD_VAR 0 6
54072: PUSH
54073: LD_INT 1
54075: ARRAY
54076: PPUSH
54077: LD_VAR 0 2
54081: PPUSH
54082: CALL_OW 259
54086: ST_TO_ADDR
// if s1 = 1 then
54087: LD_VAR 0 2
54091: PUSH
54092: LD_INT 1
54094: EQUAL
54095: IFFALSE 54115
// s2 := rand ( 2 , 4 ) else
54097: LD_ADDR_VAR 0 3
54101: PUSH
54102: LD_INT 2
54104: PPUSH
54105: LD_INT 4
54107: PPUSH
54108: CALL_OW 12
54112: ST_TO_ADDR
54113: GO 54123
// s2 := 1 ;
54115: LD_ADDR_VAR 0 3
54119: PUSH
54120: LD_INT 1
54122: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
54123: LD_ADDR_VAR 0 5
54127: PUSH
54128: LD_VAR 0 6
54132: PUSH
54133: LD_INT 1
54135: ARRAY
54136: PPUSH
54137: LD_VAR 0 3
54141: PPUSH
54142: CALL_OW 259
54146: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
54147: LD_VAR 0 6
54151: PUSH
54152: LD_INT 1
54154: ARRAY
54155: PPUSH
54156: LD_VAR 0 2
54160: PPUSH
54161: LD_VAR 0 5
54165: PPUSH
54166: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
54170: LD_VAR 0 6
54174: PUSH
54175: LD_INT 1
54177: ARRAY
54178: PPUSH
54179: LD_VAR 0 3
54183: PPUSH
54184: LD_VAR 0 4
54188: PPUSH
54189: CALL_OW 237
// end ;
54193: PPOPN 6
54195: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
54196: LD_EXP 73
54200: PUSH
54201: LD_EXP 120
54205: AND
54206: IFFALSE 54285
54208: GO 54210
54210: DISABLE
54211: LD_INT 0
54213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
54214: LD_ADDR_VAR 0 1
54218: PUSH
54219: LD_INT 22
54221: PUSH
54222: LD_OWVAR 2
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PUSH
54231: LD_INT 30
54233: PUSH
54234: LD_INT 3
54236: PUSH
54237: EMPTY
54238: LIST
54239: LIST
54240: PUSH
54241: EMPTY
54242: LIST
54243: LIST
54244: PPUSH
54245: CALL_OW 69
54249: ST_TO_ADDR
// if not tmp then
54250: LD_VAR 0 1
54254: NOT
54255: IFFALSE 54259
// exit ;
54257: GO 54285
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
54259: LD_VAR 0 1
54263: PUSH
54264: LD_INT 1
54266: PPUSH
54267: LD_VAR 0 1
54271: PPUSH
54272: CALL_OW 12
54276: ARRAY
54277: PPUSH
54278: LD_INT 1
54280: PPUSH
54281: CALL_OW 234
// end ;
54285: PPOPN 1
54287: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
54288: LD_EXP 73
54292: PUSH
54293: LD_EXP 121
54297: AND
54298: IFFALSE 54410
54300: GO 54302
54302: DISABLE
54303: LD_INT 0
54305: PPUSH
54306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
54307: LD_ADDR_VAR 0 2
54311: PUSH
54312: LD_INT 22
54314: PUSH
54315: LD_OWVAR 2
54319: PUSH
54320: EMPTY
54321: LIST
54322: LIST
54323: PUSH
54324: LD_INT 2
54326: PUSH
54327: LD_INT 30
54329: PUSH
54330: LD_INT 27
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: PUSH
54337: LD_INT 30
54339: PUSH
54340: LD_INT 26
54342: PUSH
54343: EMPTY
54344: LIST
54345: LIST
54346: PUSH
54347: LD_INT 30
54349: PUSH
54350: LD_INT 28
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: LIST
54361: LIST
54362: PUSH
54363: EMPTY
54364: LIST
54365: LIST
54366: PPUSH
54367: CALL_OW 69
54371: ST_TO_ADDR
// if not tmp then
54372: LD_VAR 0 2
54376: NOT
54377: IFFALSE 54381
// exit ;
54379: GO 54410
// for i in tmp do
54381: LD_ADDR_VAR 0 1
54385: PUSH
54386: LD_VAR 0 2
54390: PUSH
54391: FOR_IN
54392: IFFALSE 54408
// SetLives ( i , 1 ) ;
54394: LD_VAR 0 1
54398: PPUSH
54399: LD_INT 1
54401: PPUSH
54402: CALL_OW 234
54406: GO 54391
54408: POP
54409: POP
// end ;
54410: PPOPN 2
54412: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
54413: LD_EXP 73
54417: PUSH
54418: LD_EXP 122
54422: AND
54423: IFFALSE 54710
54425: GO 54427
54427: DISABLE
54428: LD_INT 0
54430: PPUSH
54431: PPUSH
54432: PPUSH
// begin i := rand ( 1 , 7 ) ;
54433: LD_ADDR_VAR 0 1
54437: PUSH
54438: LD_INT 1
54440: PPUSH
54441: LD_INT 7
54443: PPUSH
54444: CALL_OW 12
54448: ST_TO_ADDR
// case i of 1 :
54449: LD_VAR 0 1
54453: PUSH
54454: LD_INT 1
54456: DOUBLE
54457: EQUAL
54458: IFTRUE 54462
54460: GO 54472
54462: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
54463: LD_STRING earthquake(getX(game), 0, 32)
54465: PPUSH
54466: CALL_OW 559
54470: GO 54710
54472: LD_INT 2
54474: DOUBLE
54475: EQUAL
54476: IFTRUE 54480
54478: GO 54494
54480: POP
// begin ToLua ( displayStucuk(); ) ;
54481: LD_STRING displayStucuk();
54483: PPUSH
54484: CALL_OW 559
// ResetFog ;
54488: CALL_OW 335
// end ; 3 :
54492: GO 54710
54494: LD_INT 3
54496: DOUBLE
54497: EQUAL
54498: IFTRUE 54502
54500: GO 54606
54502: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
54503: LD_ADDR_VAR 0 2
54507: PUSH
54508: LD_INT 22
54510: PUSH
54511: LD_OWVAR 2
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: PUSH
54520: LD_INT 25
54522: PUSH
54523: LD_INT 1
54525: PUSH
54526: EMPTY
54527: LIST
54528: LIST
54529: PUSH
54530: EMPTY
54531: LIST
54532: LIST
54533: PPUSH
54534: CALL_OW 69
54538: ST_TO_ADDR
// if not tmp then
54539: LD_VAR 0 2
54543: NOT
54544: IFFALSE 54548
// exit ;
54546: GO 54710
// un := tmp [ rand ( 1 , tmp ) ] ;
54548: LD_ADDR_VAR 0 3
54552: PUSH
54553: LD_VAR 0 2
54557: PUSH
54558: LD_INT 1
54560: PPUSH
54561: LD_VAR 0 2
54565: PPUSH
54566: CALL_OW 12
54570: ARRAY
54571: ST_TO_ADDR
// if Crawls ( un ) then
54572: LD_VAR 0 3
54576: PPUSH
54577: CALL_OW 318
54581: IFFALSE 54592
// ComWalk ( un ) ;
54583: LD_VAR 0 3
54587: PPUSH
54588: CALL_OW 138
// SetClass ( un , class_mortar ) ;
54592: LD_VAR 0 3
54596: PPUSH
54597: LD_INT 8
54599: PPUSH
54600: CALL_OW 336
// end ; 4 :
54604: GO 54710
54606: LD_INT 4
54608: DOUBLE
54609: EQUAL
54610: IFTRUE 54614
54612: GO 54688
54614: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
54615: LD_ADDR_VAR 0 2
54619: PUSH
54620: LD_INT 22
54622: PUSH
54623: LD_OWVAR 2
54627: PUSH
54628: EMPTY
54629: LIST
54630: LIST
54631: PUSH
54632: LD_INT 30
54634: PUSH
54635: LD_INT 29
54637: PUSH
54638: EMPTY
54639: LIST
54640: LIST
54641: PUSH
54642: EMPTY
54643: LIST
54644: LIST
54645: PPUSH
54646: CALL_OW 69
54650: ST_TO_ADDR
// if not tmp then
54651: LD_VAR 0 2
54655: NOT
54656: IFFALSE 54660
// exit ;
54658: GO 54710
// CenterNowOnUnits ( tmp [ 1 ] ) ;
54660: LD_VAR 0 2
54664: PUSH
54665: LD_INT 1
54667: ARRAY
54668: PPUSH
54669: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
54673: LD_VAR 0 2
54677: PUSH
54678: LD_INT 1
54680: ARRAY
54681: PPUSH
54682: CALL_OW 65
// end ; 5 .. 7 :
54686: GO 54710
54688: LD_INT 5
54690: DOUBLE
54691: GREATEREQUAL
54692: IFFALSE 54700
54694: LD_INT 7
54696: DOUBLE
54697: LESSEQUAL
54698: IFTRUE 54702
54700: GO 54709
54702: POP
// StreamSibBomb ; end ;
54703: CALL 50947 0 0
54707: GO 54710
54709: POP
// end ;
54710: PPOPN 3
54712: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
54713: LD_EXP 73
54717: PUSH
54718: LD_EXP 123
54722: AND
54723: IFFALSE 54879
54725: GO 54727
54727: DISABLE
54728: LD_INT 0
54730: PPUSH
54731: PPUSH
54732: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
54733: LD_ADDR_VAR 0 2
54737: PUSH
54738: LD_INT 81
54740: PUSH
54741: LD_OWVAR 2
54745: PUSH
54746: EMPTY
54747: LIST
54748: LIST
54749: PUSH
54750: LD_INT 2
54752: PUSH
54753: LD_INT 21
54755: PUSH
54756: LD_INT 1
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: LD_INT 21
54765: PUSH
54766: LD_INT 2
54768: PUSH
54769: EMPTY
54770: LIST
54771: LIST
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: LIST
54777: PUSH
54778: EMPTY
54779: LIST
54780: LIST
54781: PPUSH
54782: CALL_OW 69
54786: ST_TO_ADDR
// if not tmp then
54787: LD_VAR 0 2
54791: NOT
54792: IFFALSE 54796
// exit ;
54794: GO 54879
// p := 0 ;
54796: LD_ADDR_VAR 0 3
54800: PUSH
54801: LD_INT 0
54803: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54804: LD_INT 35
54806: PPUSH
54807: CALL_OW 67
// p := p + 1 ;
54811: LD_ADDR_VAR 0 3
54815: PUSH
54816: LD_VAR 0 3
54820: PUSH
54821: LD_INT 1
54823: PLUS
54824: ST_TO_ADDR
// for i in tmp do
54825: LD_ADDR_VAR 0 1
54829: PUSH
54830: LD_VAR 0 2
54834: PUSH
54835: FOR_IN
54836: IFFALSE 54867
// if GetLives ( i ) < 1000 then
54838: LD_VAR 0 1
54842: PPUSH
54843: CALL_OW 256
54847: PUSH
54848: LD_INT 1000
54850: LESS
54851: IFFALSE 54865
// SetLives ( i , 1000 ) ;
54853: LD_VAR 0 1
54857: PPUSH
54858: LD_INT 1000
54860: PPUSH
54861: CALL_OW 234
54865: GO 54835
54867: POP
54868: POP
// until p > 20 ;
54869: LD_VAR 0 3
54873: PUSH
54874: LD_INT 20
54876: GREATER
54877: IFFALSE 54804
// end ;
54879: PPOPN 3
54881: END
// every 0 0$1 trigger StreamModeActive and sTime do
54882: LD_EXP 73
54886: PUSH
54887: LD_EXP 124
54891: AND
54892: IFFALSE 54927
54894: GO 54896
54896: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54897: LD_INT 28
54899: PPUSH
54900: LD_OWVAR 2
54904: PPUSH
54905: LD_INT 2
54907: PPUSH
54908: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54912: LD_INT 30
54914: PPUSH
54915: LD_OWVAR 2
54919: PPUSH
54920: LD_INT 2
54922: PPUSH
54923: CALL_OW 322
// end ;
54927: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54928: LD_EXP 73
54932: PUSH
54933: LD_EXP 125
54937: AND
54938: IFFALSE 55059
54940: GO 54942
54942: DISABLE
54943: LD_INT 0
54945: PPUSH
54946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54947: LD_ADDR_VAR 0 2
54951: PUSH
54952: LD_INT 22
54954: PUSH
54955: LD_OWVAR 2
54959: PUSH
54960: EMPTY
54961: LIST
54962: LIST
54963: PUSH
54964: LD_INT 21
54966: PUSH
54967: LD_INT 1
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: PUSH
54974: LD_INT 3
54976: PUSH
54977: LD_INT 23
54979: PUSH
54980: LD_INT 0
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PUSH
54991: EMPTY
54992: LIST
54993: LIST
54994: LIST
54995: PPUSH
54996: CALL_OW 69
55000: ST_TO_ADDR
// if not tmp then
55001: LD_VAR 0 2
55005: NOT
55006: IFFALSE 55010
// exit ;
55008: GO 55059
// for i in tmp do
55010: LD_ADDR_VAR 0 1
55014: PUSH
55015: LD_VAR 0 2
55019: PUSH
55020: FOR_IN
55021: IFFALSE 55057
// begin if Crawls ( i ) then
55023: LD_VAR 0 1
55027: PPUSH
55028: CALL_OW 318
55032: IFFALSE 55043
// ComWalk ( i ) ;
55034: LD_VAR 0 1
55038: PPUSH
55039: CALL_OW 138
// SetClass ( i , 2 ) ;
55043: LD_VAR 0 1
55047: PPUSH
55048: LD_INT 2
55050: PPUSH
55051: CALL_OW 336
// end ;
55055: GO 55020
55057: POP
55058: POP
// end ;
55059: PPOPN 2
55061: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
55062: LD_EXP 73
55066: PUSH
55067: LD_EXP 126
55071: AND
55072: IFFALSE 55360
55074: GO 55076
55076: DISABLE
55077: LD_INT 0
55079: PPUSH
55080: PPUSH
55081: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
55082: LD_OWVAR 2
55086: PPUSH
55087: LD_INT 9
55089: PPUSH
55090: LD_INT 1
55092: PPUSH
55093: LD_INT 1
55095: PPUSH
55096: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
55100: LD_INT 9
55102: PPUSH
55103: LD_OWVAR 2
55107: PPUSH
55108: CALL_OW 343
// uc_side := 9 ;
55112: LD_ADDR_OWVAR 20
55116: PUSH
55117: LD_INT 9
55119: ST_TO_ADDR
// uc_nation := 2 ;
55120: LD_ADDR_OWVAR 21
55124: PUSH
55125: LD_INT 2
55127: ST_TO_ADDR
// hc_name := Dark Warrior ;
55128: LD_ADDR_OWVAR 26
55132: PUSH
55133: LD_STRING Dark Warrior
55135: ST_TO_ADDR
// hc_gallery :=  ;
55136: LD_ADDR_OWVAR 33
55140: PUSH
55141: LD_STRING 
55143: ST_TO_ADDR
// hc_noskilllimit := true ;
55144: LD_ADDR_OWVAR 76
55148: PUSH
55149: LD_INT 1
55151: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
55152: LD_ADDR_OWVAR 31
55156: PUSH
55157: LD_INT 30
55159: PUSH
55160: LD_INT 30
55162: PUSH
55163: LD_INT 30
55165: PUSH
55166: LD_INT 30
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: LIST
55173: LIST
55174: ST_TO_ADDR
// un := CreateHuman ;
55175: LD_ADDR_VAR 0 3
55179: PUSH
55180: CALL_OW 44
55184: ST_TO_ADDR
// hc_noskilllimit := false ;
55185: LD_ADDR_OWVAR 76
55189: PUSH
55190: LD_INT 0
55192: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
55193: LD_VAR 0 3
55197: PPUSH
55198: LD_INT 1
55200: PPUSH
55201: CALL_OW 51
// ToLua ( playRanger() ) ;
55205: LD_STRING playRanger()
55207: PPUSH
55208: CALL_OW 559
// p := 0 ;
55212: LD_ADDR_VAR 0 2
55216: PUSH
55217: LD_INT 0
55219: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55220: LD_INT 35
55222: PPUSH
55223: CALL_OW 67
// p := p + 1 ;
55227: LD_ADDR_VAR 0 2
55231: PUSH
55232: LD_VAR 0 2
55236: PUSH
55237: LD_INT 1
55239: PLUS
55240: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
55241: LD_VAR 0 3
55245: PPUSH
55246: CALL_OW 256
55250: PUSH
55251: LD_INT 1000
55253: LESS
55254: IFFALSE 55268
// SetLives ( un , 1000 ) ;
55256: LD_VAR 0 3
55260: PPUSH
55261: LD_INT 1000
55263: PPUSH
55264: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
55268: LD_VAR 0 3
55272: PPUSH
55273: LD_INT 81
55275: PUSH
55276: LD_OWVAR 2
55280: PUSH
55281: EMPTY
55282: LIST
55283: LIST
55284: PUSH
55285: LD_INT 91
55287: PUSH
55288: LD_VAR 0 3
55292: PUSH
55293: LD_INT 30
55295: PUSH
55296: EMPTY
55297: LIST
55298: LIST
55299: LIST
55300: PUSH
55301: EMPTY
55302: LIST
55303: LIST
55304: PPUSH
55305: CALL_OW 69
55309: PPUSH
55310: LD_VAR 0 3
55314: PPUSH
55315: CALL_OW 74
55319: PPUSH
55320: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
55324: LD_VAR 0 2
55328: PUSH
55329: LD_INT 80
55331: GREATER
55332: PUSH
55333: LD_VAR 0 3
55337: PPUSH
55338: CALL_OW 301
55342: OR
55343: IFFALSE 55220
// if un then
55345: LD_VAR 0 3
55349: IFFALSE 55360
// RemoveUnit ( un ) ;
55351: LD_VAR 0 3
55355: PPUSH
55356: CALL_OW 64
// end ;
55360: PPOPN 3
55362: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
55363: LD_EXP 127
55367: IFFALSE 55483
55369: GO 55371
55371: DISABLE
55372: LD_INT 0
55374: PPUSH
55375: PPUSH
55376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
55377: LD_ADDR_VAR 0 2
55381: PUSH
55382: LD_INT 81
55384: PUSH
55385: LD_OWVAR 2
55389: PUSH
55390: EMPTY
55391: LIST
55392: LIST
55393: PUSH
55394: LD_INT 21
55396: PUSH
55397: LD_INT 1
55399: PUSH
55400: EMPTY
55401: LIST
55402: LIST
55403: PUSH
55404: EMPTY
55405: LIST
55406: LIST
55407: PPUSH
55408: CALL_OW 69
55412: ST_TO_ADDR
// ToLua ( playComputer() ) ;
55413: LD_STRING playComputer()
55415: PPUSH
55416: CALL_OW 559
// if not tmp then
55420: LD_VAR 0 2
55424: NOT
55425: IFFALSE 55429
// exit ;
55427: GO 55483
// for i in tmp do
55429: LD_ADDR_VAR 0 1
55433: PUSH
55434: LD_VAR 0 2
55438: PUSH
55439: FOR_IN
55440: IFFALSE 55481
// for j := 1 to 4 do
55442: LD_ADDR_VAR 0 3
55446: PUSH
55447: DOUBLE
55448: LD_INT 1
55450: DEC
55451: ST_TO_ADDR
55452: LD_INT 4
55454: PUSH
55455: FOR_TO
55456: IFFALSE 55477
// SetSkill ( i , j , 10 ) ;
55458: LD_VAR 0 1
55462: PPUSH
55463: LD_VAR 0 3
55467: PPUSH
55468: LD_INT 10
55470: PPUSH
55471: CALL_OW 237
55475: GO 55455
55477: POP
55478: POP
55479: GO 55439
55481: POP
55482: POP
// end ;
55483: PPOPN 3
55485: END
// every 0 0$1 trigger s30 do var i , tmp ;
55486: LD_EXP 128
55490: IFFALSE 55559
55492: GO 55494
55494: DISABLE
55495: LD_INT 0
55497: PPUSH
55498: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55499: LD_ADDR_VAR 0 2
55503: PUSH
55504: LD_INT 22
55506: PUSH
55507: LD_OWVAR 2
55511: PUSH
55512: EMPTY
55513: LIST
55514: LIST
55515: PPUSH
55516: CALL_OW 69
55520: ST_TO_ADDR
// if not tmp then
55521: LD_VAR 0 2
55525: NOT
55526: IFFALSE 55530
// exit ;
55528: GO 55559
// for i in tmp do
55530: LD_ADDR_VAR 0 1
55534: PUSH
55535: LD_VAR 0 2
55539: PUSH
55540: FOR_IN
55541: IFFALSE 55557
// SetLives ( i , 300 ) ;
55543: LD_VAR 0 1
55547: PPUSH
55548: LD_INT 300
55550: PPUSH
55551: CALL_OW 234
55555: GO 55540
55557: POP
55558: POP
// end ;
55559: PPOPN 2
55561: END
// every 0 0$1 trigger s60 do var i , tmp ;
55562: LD_EXP 129
55566: IFFALSE 55635
55568: GO 55570
55570: DISABLE
55571: LD_INT 0
55573: PPUSH
55574: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
55575: LD_ADDR_VAR 0 2
55579: PUSH
55580: LD_INT 22
55582: PUSH
55583: LD_OWVAR 2
55587: PUSH
55588: EMPTY
55589: LIST
55590: LIST
55591: PPUSH
55592: CALL_OW 69
55596: ST_TO_ADDR
// if not tmp then
55597: LD_VAR 0 2
55601: NOT
55602: IFFALSE 55606
// exit ;
55604: GO 55635
// for i in tmp do
55606: LD_ADDR_VAR 0 1
55610: PUSH
55611: LD_VAR 0 2
55615: PUSH
55616: FOR_IN
55617: IFFALSE 55633
// SetLives ( i , 600 ) ;
55619: LD_VAR 0 1
55623: PPUSH
55624: LD_INT 600
55626: PPUSH
55627: CALL_OW 234
55631: GO 55616
55633: POP
55634: POP
// end ;
55635: PPOPN 2
55637: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
55638: LD_INT 0
55640: PPUSH
// case cmd of 301 :
55641: LD_VAR 0 1
55645: PUSH
55646: LD_INT 301
55648: DOUBLE
55649: EQUAL
55650: IFTRUE 55654
55652: GO 55686
55654: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
55655: LD_VAR 0 6
55659: PPUSH
55660: LD_VAR 0 7
55664: PPUSH
55665: LD_VAR 0 8
55669: PPUSH
55670: LD_VAR 0 4
55674: PPUSH
55675: LD_VAR 0 5
55679: PPUSH
55680: CALL 56887 0 5
55684: GO 55807
55686: LD_INT 302
55688: DOUBLE
55689: EQUAL
55690: IFTRUE 55694
55692: GO 55731
55694: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
55695: LD_VAR 0 6
55699: PPUSH
55700: LD_VAR 0 7
55704: PPUSH
55705: LD_VAR 0 8
55709: PPUSH
55710: LD_VAR 0 9
55714: PPUSH
55715: LD_VAR 0 4
55719: PPUSH
55720: LD_VAR 0 5
55724: PPUSH
55725: CALL 56978 0 6
55729: GO 55807
55731: LD_INT 303
55733: DOUBLE
55734: EQUAL
55735: IFTRUE 55739
55737: GO 55776
55739: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
55740: LD_VAR 0 6
55744: PPUSH
55745: LD_VAR 0 7
55749: PPUSH
55750: LD_VAR 0 8
55754: PPUSH
55755: LD_VAR 0 9
55759: PPUSH
55760: LD_VAR 0 4
55764: PPUSH
55765: LD_VAR 0 5
55769: PPUSH
55770: CALL 55812 0 6
55774: GO 55807
55776: LD_INT 304
55778: DOUBLE
55779: EQUAL
55780: IFTRUE 55784
55782: GO 55806
55784: POP
// hHackTeleport ( unit , x , y ) ; end ;
55785: LD_VAR 0 2
55789: PPUSH
55790: LD_VAR 0 4
55794: PPUSH
55795: LD_VAR 0 5
55799: PPUSH
55800: CALL 57571 0 3
55804: GO 55807
55806: POP
// end ;
55807: LD_VAR 0 12
55811: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
55812: LD_INT 0
55814: PPUSH
55815: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
55816: LD_VAR 0 1
55820: PUSH
55821: LD_INT 1
55823: LESS
55824: PUSH
55825: LD_VAR 0 1
55829: PUSH
55830: LD_INT 3
55832: GREATER
55833: OR
55834: PUSH
55835: LD_VAR 0 5
55839: PPUSH
55840: LD_VAR 0 6
55844: PPUSH
55845: CALL_OW 428
55849: OR
55850: IFFALSE 55854
// exit ;
55852: GO 56574
// uc_side := your_side ;
55854: LD_ADDR_OWVAR 20
55858: PUSH
55859: LD_OWVAR 2
55863: ST_TO_ADDR
// uc_nation := nation ;
55864: LD_ADDR_OWVAR 21
55868: PUSH
55869: LD_VAR 0 1
55873: ST_TO_ADDR
// bc_level = 1 ;
55874: LD_ADDR_OWVAR 43
55878: PUSH
55879: LD_INT 1
55881: ST_TO_ADDR
// case btype of 1 :
55882: LD_VAR 0 2
55886: PUSH
55887: LD_INT 1
55889: DOUBLE
55890: EQUAL
55891: IFTRUE 55895
55893: GO 55906
55895: POP
// bc_type := b_depot ; 2 :
55896: LD_ADDR_OWVAR 42
55900: PUSH
55901: LD_INT 0
55903: ST_TO_ADDR
55904: GO 56518
55906: LD_INT 2
55908: DOUBLE
55909: EQUAL
55910: IFTRUE 55914
55912: GO 55925
55914: POP
// bc_type := b_warehouse ; 3 :
55915: LD_ADDR_OWVAR 42
55919: PUSH
55920: LD_INT 1
55922: ST_TO_ADDR
55923: GO 56518
55925: LD_INT 3
55927: DOUBLE
55928: EQUAL
55929: IFTRUE 55933
55931: GO 55944
55933: POP
// bc_type := b_lab ; 4 .. 9 :
55934: LD_ADDR_OWVAR 42
55938: PUSH
55939: LD_INT 6
55941: ST_TO_ADDR
55942: GO 56518
55944: LD_INT 4
55946: DOUBLE
55947: GREATEREQUAL
55948: IFFALSE 55956
55950: LD_INT 9
55952: DOUBLE
55953: LESSEQUAL
55954: IFTRUE 55958
55956: GO 56010
55958: POP
// begin bc_type := b_lab_half ;
55959: LD_ADDR_OWVAR 42
55963: PUSH
55964: LD_INT 7
55966: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
55967: LD_ADDR_OWVAR 44
55971: PUSH
55972: LD_INT 10
55974: PUSH
55975: LD_INT 11
55977: PUSH
55978: LD_INT 12
55980: PUSH
55981: LD_INT 15
55983: PUSH
55984: LD_INT 14
55986: PUSH
55987: LD_INT 13
55989: PUSH
55990: EMPTY
55991: LIST
55992: LIST
55993: LIST
55994: LIST
55995: LIST
55996: LIST
55997: PUSH
55998: LD_VAR 0 2
56002: PUSH
56003: LD_INT 3
56005: MINUS
56006: ARRAY
56007: ST_TO_ADDR
// end ; 10 .. 13 :
56008: GO 56518
56010: LD_INT 10
56012: DOUBLE
56013: GREATEREQUAL
56014: IFFALSE 56022
56016: LD_INT 13
56018: DOUBLE
56019: LESSEQUAL
56020: IFTRUE 56024
56022: GO 56101
56024: POP
// begin bc_type := b_lab_full ;
56025: LD_ADDR_OWVAR 42
56029: PUSH
56030: LD_INT 8
56032: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
56033: LD_ADDR_OWVAR 44
56037: PUSH
56038: LD_INT 10
56040: PUSH
56041: LD_INT 12
56043: PUSH
56044: LD_INT 14
56046: PUSH
56047: LD_INT 13
56049: PUSH
56050: EMPTY
56051: LIST
56052: LIST
56053: LIST
56054: LIST
56055: PUSH
56056: LD_VAR 0 2
56060: PUSH
56061: LD_INT 9
56063: MINUS
56064: ARRAY
56065: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
56066: LD_ADDR_OWVAR 45
56070: PUSH
56071: LD_INT 11
56073: PUSH
56074: LD_INT 15
56076: PUSH
56077: LD_INT 12
56079: PUSH
56080: LD_INT 15
56082: PUSH
56083: EMPTY
56084: LIST
56085: LIST
56086: LIST
56087: LIST
56088: PUSH
56089: LD_VAR 0 2
56093: PUSH
56094: LD_INT 9
56096: MINUS
56097: ARRAY
56098: ST_TO_ADDR
// end ; 14 :
56099: GO 56518
56101: LD_INT 14
56103: DOUBLE
56104: EQUAL
56105: IFTRUE 56109
56107: GO 56120
56109: POP
// bc_type := b_workshop ; 15 :
56110: LD_ADDR_OWVAR 42
56114: PUSH
56115: LD_INT 2
56117: ST_TO_ADDR
56118: GO 56518
56120: LD_INT 15
56122: DOUBLE
56123: EQUAL
56124: IFTRUE 56128
56126: GO 56139
56128: POP
// bc_type := b_factory ; 16 :
56129: LD_ADDR_OWVAR 42
56133: PUSH
56134: LD_INT 3
56136: ST_TO_ADDR
56137: GO 56518
56139: LD_INT 16
56141: DOUBLE
56142: EQUAL
56143: IFTRUE 56147
56145: GO 56158
56147: POP
// bc_type := b_ext_gun ; 17 :
56148: LD_ADDR_OWVAR 42
56152: PUSH
56153: LD_INT 17
56155: ST_TO_ADDR
56156: GO 56518
56158: LD_INT 17
56160: DOUBLE
56161: EQUAL
56162: IFTRUE 56166
56164: GO 56194
56166: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
56167: LD_ADDR_OWVAR 42
56171: PUSH
56172: LD_INT 19
56174: PUSH
56175: LD_INT 23
56177: PUSH
56178: LD_INT 19
56180: PUSH
56181: EMPTY
56182: LIST
56183: LIST
56184: LIST
56185: PUSH
56186: LD_VAR 0 1
56190: ARRAY
56191: ST_TO_ADDR
56192: GO 56518
56194: LD_INT 18
56196: DOUBLE
56197: EQUAL
56198: IFTRUE 56202
56200: GO 56213
56202: POP
// bc_type := b_ext_radar ; 19 :
56203: LD_ADDR_OWVAR 42
56207: PUSH
56208: LD_INT 20
56210: ST_TO_ADDR
56211: GO 56518
56213: LD_INT 19
56215: DOUBLE
56216: EQUAL
56217: IFTRUE 56221
56219: GO 56232
56221: POP
// bc_type := b_ext_radio ; 20 :
56222: LD_ADDR_OWVAR 42
56226: PUSH
56227: LD_INT 22
56229: ST_TO_ADDR
56230: GO 56518
56232: LD_INT 20
56234: DOUBLE
56235: EQUAL
56236: IFTRUE 56240
56238: GO 56251
56240: POP
// bc_type := b_ext_siberium ; 21 :
56241: LD_ADDR_OWVAR 42
56245: PUSH
56246: LD_INT 21
56248: ST_TO_ADDR
56249: GO 56518
56251: LD_INT 21
56253: DOUBLE
56254: EQUAL
56255: IFTRUE 56259
56257: GO 56270
56259: POP
// bc_type := b_ext_computer ; 22 :
56260: LD_ADDR_OWVAR 42
56264: PUSH
56265: LD_INT 24
56267: ST_TO_ADDR
56268: GO 56518
56270: LD_INT 22
56272: DOUBLE
56273: EQUAL
56274: IFTRUE 56278
56276: GO 56289
56278: POP
// bc_type := b_ext_track ; 23 :
56279: LD_ADDR_OWVAR 42
56283: PUSH
56284: LD_INT 16
56286: ST_TO_ADDR
56287: GO 56518
56289: LD_INT 23
56291: DOUBLE
56292: EQUAL
56293: IFTRUE 56297
56295: GO 56308
56297: POP
// bc_type := b_ext_laser ; 24 :
56298: LD_ADDR_OWVAR 42
56302: PUSH
56303: LD_INT 25
56305: ST_TO_ADDR
56306: GO 56518
56308: LD_INT 24
56310: DOUBLE
56311: EQUAL
56312: IFTRUE 56316
56314: GO 56327
56316: POP
// bc_type := b_control_tower ; 25 :
56317: LD_ADDR_OWVAR 42
56321: PUSH
56322: LD_INT 36
56324: ST_TO_ADDR
56325: GO 56518
56327: LD_INT 25
56329: DOUBLE
56330: EQUAL
56331: IFTRUE 56335
56333: GO 56346
56335: POP
// bc_type := b_breastwork ; 26 :
56336: LD_ADDR_OWVAR 42
56340: PUSH
56341: LD_INT 31
56343: ST_TO_ADDR
56344: GO 56518
56346: LD_INT 26
56348: DOUBLE
56349: EQUAL
56350: IFTRUE 56354
56352: GO 56365
56354: POP
// bc_type := b_bunker ; 27 :
56355: LD_ADDR_OWVAR 42
56359: PUSH
56360: LD_INT 32
56362: ST_TO_ADDR
56363: GO 56518
56365: LD_INT 27
56367: DOUBLE
56368: EQUAL
56369: IFTRUE 56373
56371: GO 56384
56373: POP
// bc_type := b_turret ; 28 :
56374: LD_ADDR_OWVAR 42
56378: PUSH
56379: LD_INT 33
56381: ST_TO_ADDR
56382: GO 56518
56384: LD_INT 28
56386: DOUBLE
56387: EQUAL
56388: IFTRUE 56392
56390: GO 56403
56392: POP
// bc_type := b_armoury ; 29 :
56393: LD_ADDR_OWVAR 42
56397: PUSH
56398: LD_INT 4
56400: ST_TO_ADDR
56401: GO 56518
56403: LD_INT 29
56405: DOUBLE
56406: EQUAL
56407: IFTRUE 56411
56409: GO 56422
56411: POP
// bc_type := b_barracks ; 30 :
56412: LD_ADDR_OWVAR 42
56416: PUSH
56417: LD_INT 5
56419: ST_TO_ADDR
56420: GO 56518
56422: LD_INT 30
56424: DOUBLE
56425: EQUAL
56426: IFTRUE 56430
56428: GO 56441
56430: POP
// bc_type := b_solar_power ; 31 :
56431: LD_ADDR_OWVAR 42
56435: PUSH
56436: LD_INT 27
56438: ST_TO_ADDR
56439: GO 56518
56441: LD_INT 31
56443: DOUBLE
56444: EQUAL
56445: IFTRUE 56449
56447: GO 56460
56449: POP
// bc_type := b_oil_power ; 32 :
56450: LD_ADDR_OWVAR 42
56454: PUSH
56455: LD_INT 26
56457: ST_TO_ADDR
56458: GO 56518
56460: LD_INT 32
56462: DOUBLE
56463: EQUAL
56464: IFTRUE 56468
56466: GO 56479
56468: POP
// bc_type := b_siberite_power ; 33 :
56469: LD_ADDR_OWVAR 42
56473: PUSH
56474: LD_INT 28
56476: ST_TO_ADDR
56477: GO 56518
56479: LD_INT 33
56481: DOUBLE
56482: EQUAL
56483: IFTRUE 56487
56485: GO 56498
56487: POP
// bc_type := b_oil_mine ; 34 :
56488: LD_ADDR_OWVAR 42
56492: PUSH
56493: LD_INT 29
56495: ST_TO_ADDR
56496: GO 56518
56498: LD_INT 34
56500: DOUBLE
56501: EQUAL
56502: IFTRUE 56506
56504: GO 56517
56506: POP
// bc_type := b_siberite_mine ; end ;
56507: LD_ADDR_OWVAR 42
56511: PUSH
56512: LD_INT 30
56514: ST_TO_ADDR
56515: GO 56518
56517: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
56518: LD_ADDR_VAR 0 8
56522: PUSH
56523: LD_VAR 0 5
56527: PPUSH
56528: LD_VAR 0 6
56532: PPUSH
56533: LD_VAR 0 3
56537: PPUSH
56538: CALL_OW 47
56542: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
56543: LD_OWVAR 42
56547: PUSH
56548: LD_INT 32
56550: PUSH
56551: LD_INT 33
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: IN
56558: IFFALSE 56574
// PlaceWeaponTurret ( b , weapon ) ;
56560: LD_VAR 0 8
56564: PPUSH
56565: LD_VAR 0 4
56569: PPUSH
56570: CALL_OW 431
// end ;
56574: LD_VAR 0 7
56578: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
56579: LD_INT 0
56581: PPUSH
56582: PPUSH
56583: PPUSH
56584: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
56585: LD_ADDR_VAR 0 4
56589: PUSH
56590: LD_INT 22
56592: PUSH
56593: LD_OWVAR 2
56597: PUSH
56598: EMPTY
56599: LIST
56600: LIST
56601: PUSH
56602: LD_INT 2
56604: PUSH
56605: LD_INT 30
56607: PUSH
56608: LD_INT 0
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: PUSH
56615: LD_INT 30
56617: PUSH
56618: LD_INT 1
56620: PUSH
56621: EMPTY
56622: LIST
56623: LIST
56624: PUSH
56625: EMPTY
56626: LIST
56627: LIST
56628: LIST
56629: PUSH
56630: EMPTY
56631: LIST
56632: LIST
56633: PPUSH
56634: CALL_OW 69
56638: ST_TO_ADDR
// if not tmp then
56639: LD_VAR 0 4
56643: NOT
56644: IFFALSE 56648
// exit ;
56646: GO 56707
// for i in tmp do
56648: LD_ADDR_VAR 0 2
56652: PUSH
56653: LD_VAR 0 4
56657: PUSH
56658: FOR_IN
56659: IFFALSE 56705
// for j = 1 to 3 do
56661: LD_ADDR_VAR 0 3
56665: PUSH
56666: DOUBLE
56667: LD_INT 1
56669: DEC
56670: ST_TO_ADDR
56671: LD_INT 3
56673: PUSH
56674: FOR_TO
56675: IFFALSE 56701
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
56677: LD_VAR 0 2
56681: PPUSH
56682: CALL_OW 274
56686: PPUSH
56687: LD_VAR 0 3
56691: PPUSH
56692: LD_INT 99999
56694: PPUSH
56695: CALL_OW 277
56699: GO 56674
56701: POP
56702: POP
56703: GO 56658
56705: POP
56706: POP
// end ;
56707: LD_VAR 0 1
56711: RET
// export function hHackSetLevel10 ; var i , j ; begin
56712: LD_INT 0
56714: PPUSH
56715: PPUSH
56716: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56717: LD_ADDR_VAR 0 2
56721: PUSH
56722: LD_INT 21
56724: PUSH
56725: LD_INT 1
56727: PUSH
56728: EMPTY
56729: LIST
56730: LIST
56731: PPUSH
56732: CALL_OW 69
56736: PUSH
56737: FOR_IN
56738: IFFALSE 56790
// if IsSelected ( i ) then
56740: LD_VAR 0 2
56744: PPUSH
56745: CALL_OW 306
56749: IFFALSE 56788
// begin for j := 1 to 4 do
56751: LD_ADDR_VAR 0 3
56755: PUSH
56756: DOUBLE
56757: LD_INT 1
56759: DEC
56760: ST_TO_ADDR
56761: LD_INT 4
56763: PUSH
56764: FOR_TO
56765: IFFALSE 56786
// SetSkill ( i , j , 10 ) ;
56767: LD_VAR 0 2
56771: PPUSH
56772: LD_VAR 0 3
56776: PPUSH
56777: LD_INT 10
56779: PPUSH
56780: CALL_OW 237
56784: GO 56764
56786: POP
56787: POP
// end ;
56788: GO 56737
56790: POP
56791: POP
// end ;
56792: LD_VAR 0 1
56796: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
56797: LD_INT 0
56799: PPUSH
56800: PPUSH
56801: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
56802: LD_ADDR_VAR 0 2
56806: PUSH
56807: LD_INT 22
56809: PUSH
56810: LD_OWVAR 2
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: PUSH
56819: LD_INT 21
56821: PUSH
56822: LD_INT 1
56824: PUSH
56825: EMPTY
56826: LIST
56827: LIST
56828: PUSH
56829: EMPTY
56830: LIST
56831: LIST
56832: PPUSH
56833: CALL_OW 69
56837: PUSH
56838: FOR_IN
56839: IFFALSE 56880
// begin for j := 1 to 4 do
56841: LD_ADDR_VAR 0 3
56845: PUSH
56846: DOUBLE
56847: LD_INT 1
56849: DEC
56850: ST_TO_ADDR
56851: LD_INT 4
56853: PUSH
56854: FOR_TO
56855: IFFALSE 56876
// SetSkill ( i , j , 10 ) ;
56857: LD_VAR 0 2
56861: PPUSH
56862: LD_VAR 0 3
56866: PPUSH
56867: LD_INT 10
56869: PPUSH
56870: CALL_OW 237
56874: GO 56854
56876: POP
56877: POP
// end ;
56878: GO 56838
56880: POP
56881: POP
// end ;
56882: LD_VAR 0 1
56886: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
56887: LD_INT 0
56889: PPUSH
// uc_side := your_side ;
56890: LD_ADDR_OWVAR 20
56894: PUSH
56895: LD_OWVAR 2
56899: ST_TO_ADDR
// uc_nation := nation ;
56900: LD_ADDR_OWVAR 21
56904: PUSH
56905: LD_VAR 0 1
56909: ST_TO_ADDR
// InitHc ;
56910: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
56914: LD_INT 0
56916: PPUSH
56917: LD_VAR 0 2
56921: PPUSH
56922: LD_VAR 0 3
56926: PPUSH
56927: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
56931: LD_VAR 0 4
56935: PPUSH
56936: LD_VAR 0 5
56940: PPUSH
56941: CALL_OW 428
56945: PUSH
56946: LD_INT 0
56948: EQUAL
56949: IFFALSE 56973
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
56951: CALL_OW 44
56955: PPUSH
56956: LD_VAR 0 4
56960: PPUSH
56961: LD_VAR 0 5
56965: PPUSH
56966: LD_INT 1
56968: PPUSH
56969: CALL_OW 48
// end ;
56973: LD_VAR 0 6
56977: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
56978: LD_INT 0
56980: PPUSH
56981: PPUSH
// uc_side := your_side ;
56982: LD_ADDR_OWVAR 20
56986: PUSH
56987: LD_OWVAR 2
56991: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
56992: LD_VAR 0 1
56996: PUSH
56997: LD_INT 1
56999: PUSH
57000: LD_INT 2
57002: PUSH
57003: LD_INT 3
57005: PUSH
57006: LD_INT 4
57008: PUSH
57009: LD_INT 5
57011: PUSH
57012: EMPTY
57013: LIST
57014: LIST
57015: LIST
57016: LIST
57017: LIST
57018: IN
57019: IFFALSE 57031
// uc_nation := nation_american else
57021: LD_ADDR_OWVAR 21
57025: PUSH
57026: LD_INT 1
57028: ST_TO_ADDR
57029: GO 57074
// if chassis in [ 11 , 12 , 13 , 14 ] then
57031: LD_VAR 0 1
57035: PUSH
57036: LD_INT 11
57038: PUSH
57039: LD_INT 12
57041: PUSH
57042: LD_INT 13
57044: PUSH
57045: LD_INT 14
57047: PUSH
57048: EMPTY
57049: LIST
57050: LIST
57051: LIST
57052: LIST
57053: IN
57054: IFFALSE 57066
// uc_nation := nation_arabian else
57056: LD_ADDR_OWVAR 21
57060: PUSH
57061: LD_INT 2
57063: ST_TO_ADDR
57064: GO 57074
// uc_nation := nation_russian ;
57066: LD_ADDR_OWVAR 21
57070: PUSH
57071: LD_INT 3
57073: ST_TO_ADDR
// vc_chassis := chassis ;
57074: LD_ADDR_OWVAR 37
57078: PUSH
57079: LD_VAR 0 1
57083: ST_TO_ADDR
// vc_engine := engine ;
57084: LD_ADDR_OWVAR 39
57088: PUSH
57089: LD_VAR 0 2
57093: ST_TO_ADDR
// vc_control := control ;
57094: LD_ADDR_OWVAR 38
57098: PUSH
57099: LD_VAR 0 3
57103: ST_TO_ADDR
// vc_weapon := weapon ;
57104: LD_ADDR_OWVAR 40
57108: PUSH
57109: LD_VAR 0 4
57113: ST_TO_ADDR
// un := CreateVehicle ;
57114: LD_ADDR_VAR 0 8
57118: PUSH
57119: CALL_OW 45
57123: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
57124: LD_VAR 0 8
57128: PPUSH
57129: LD_INT 0
57131: PPUSH
57132: LD_INT 5
57134: PPUSH
57135: CALL_OW 12
57139: PPUSH
57140: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
57144: LD_VAR 0 8
57148: PPUSH
57149: LD_VAR 0 5
57153: PPUSH
57154: LD_VAR 0 6
57158: PPUSH
57159: LD_INT 1
57161: PPUSH
57162: CALL_OW 48
// end ;
57166: LD_VAR 0 7
57170: RET
// export hInvincible ; every 1 do
57171: GO 57173
57173: DISABLE
// hInvincible := [ ] ;
57174: LD_ADDR_EXP 130
57178: PUSH
57179: EMPTY
57180: ST_TO_ADDR
57181: END
// every 10 do var i ;
57182: GO 57184
57184: DISABLE
57185: LD_INT 0
57187: PPUSH
// begin enable ;
57188: ENABLE
// if not hInvincible then
57189: LD_EXP 130
57193: NOT
57194: IFFALSE 57198
// exit ;
57196: GO 57242
// for i in hInvincible do
57198: LD_ADDR_VAR 0 1
57202: PUSH
57203: LD_EXP 130
57207: PUSH
57208: FOR_IN
57209: IFFALSE 57240
// if GetLives ( i ) < 1000 then
57211: LD_VAR 0 1
57215: PPUSH
57216: CALL_OW 256
57220: PUSH
57221: LD_INT 1000
57223: LESS
57224: IFFALSE 57238
// SetLives ( i , 1000 ) ;
57226: LD_VAR 0 1
57230: PPUSH
57231: LD_INT 1000
57233: PPUSH
57234: CALL_OW 234
57238: GO 57208
57240: POP
57241: POP
// end ;
57242: PPOPN 1
57244: END
// export function hHackInvincible ; var i ; begin
57245: LD_INT 0
57247: PPUSH
57248: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
57249: LD_ADDR_VAR 0 2
57253: PUSH
57254: LD_INT 2
57256: PUSH
57257: LD_INT 21
57259: PUSH
57260: LD_INT 1
57262: PUSH
57263: EMPTY
57264: LIST
57265: LIST
57266: PUSH
57267: LD_INT 21
57269: PUSH
57270: LD_INT 2
57272: PUSH
57273: EMPTY
57274: LIST
57275: LIST
57276: PUSH
57277: EMPTY
57278: LIST
57279: LIST
57280: LIST
57281: PPUSH
57282: CALL_OW 69
57286: PUSH
57287: FOR_IN
57288: IFFALSE 57349
// if IsSelected ( i ) then
57290: LD_VAR 0 2
57294: PPUSH
57295: CALL_OW 306
57299: IFFALSE 57347
// begin if i in hInvincible then
57301: LD_VAR 0 2
57305: PUSH
57306: LD_EXP 130
57310: IN
57311: IFFALSE 57331
// hInvincible := hInvincible diff i else
57313: LD_ADDR_EXP 130
57317: PUSH
57318: LD_EXP 130
57322: PUSH
57323: LD_VAR 0 2
57327: DIFF
57328: ST_TO_ADDR
57329: GO 57347
// hInvincible := hInvincible union i ;
57331: LD_ADDR_EXP 130
57335: PUSH
57336: LD_EXP 130
57340: PUSH
57341: LD_VAR 0 2
57345: UNION
57346: ST_TO_ADDR
// end ;
57347: GO 57287
57349: POP
57350: POP
// end ;
57351: LD_VAR 0 1
57355: RET
// export function hHackInvisible ; var i , j ; begin
57356: LD_INT 0
57358: PPUSH
57359: PPUSH
57360: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
57361: LD_ADDR_VAR 0 2
57365: PUSH
57366: LD_INT 21
57368: PUSH
57369: LD_INT 1
57371: PUSH
57372: EMPTY
57373: LIST
57374: LIST
57375: PPUSH
57376: CALL_OW 69
57380: PUSH
57381: FOR_IN
57382: IFFALSE 57406
// if IsSelected ( i ) then
57384: LD_VAR 0 2
57388: PPUSH
57389: CALL_OW 306
57393: IFFALSE 57404
// ComForceInvisible ( i ) ;
57395: LD_VAR 0 2
57399: PPUSH
57400: CALL_OW 496
57404: GO 57381
57406: POP
57407: POP
// end ;
57408: LD_VAR 0 1
57412: RET
// export function hHackChangeYourSide ; begin
57413: LD_INT 0
57415: PPUSH
// if your_side = 8 then
57416: LD_OWVAR 2
57420: PUSH
57421: LD_INT 8
57423: EQUAL
57424: IFFALSE 57436
// your_side := 0 else
57426: LD_ADDR_OWVAR 2
57430: PUSH
57431: LD_INT 0
57433: ST_TO_ADDR
57434: GO 57450
// your_side := your_side + 1 ;
57436: LD_ADDR_OWVAR 2
57440: PUSH
57441: LD_OWVAR 2
57445: PUSH
57446: LD_INT 1
57448: PLUS
57449: ST_TO_ADDR
// end ;
57450: LD_VAR 0 1
57454: RET
// export function hHackChangeUnitSide ; var i , j ; begin
57455: LD_INT 0
57457: PPUSH
57458: PPUSH
57459: PPUSH
// for i in all_units do
57460: LD_ADDR_VAR 0 2
57464: PUSH
57465: LD_OWVAR 3
57469: PUSH
57470: FOR_IN
57471: IFFALSE 57549
// if IsSelected ( i ) then
57473: LD_VAR 0 2
57477: PPUSH
57478: CALL_OW 306
57482: IFFALSE 57547
// begin j := GetSide ( i ) ;
57484: LD_ADDR_VAR 0 3
57488: PUSH
57489: LD_VAR 0 2
57493: PPUSH
57494: CALL_OW 255
57498: ST_TO_ADDR
// if j = 8 then
57499: LD_VAR 0 3
57503: PUSH
57504: LD_INT 8
57506: EQUAL
57507: IFFALSE 57519
// j := 0 else
57509: LD_ADDR_VAR 0 3
57513: PUSH
57514: LD_INT 0
57516: ST_TO_ADDR
57517: GO 57533
// j := j + 1 ;
57519: LD_ADDR_VAR 0 3
57523: PUSH
57524: LD_VAR 0 3
57528: PUSH
57529: LD_INT 1
57531: PLUS
57532: ST_TO_ADDR
// SetSide ( i , j ) ;
57533: LD_VAR 0 2
57537: PPUSH
57538: LD_VAR 0 3
57542: PPUSH
57543: CALL_OW 235
// end ;
57547: GO 57470
57549: POP
57550: POP
// end ;
57551: LD_VAR 0 1
57555: RET
// export function hHackFog ; begin
57556: LD_INT 0
57558: PPUSH
// FogOff ( true ) ;
57559: LD_INT 1
57561: PPUSH
57562: CALL_OW 344
// end ;
57566: LD_VAR 0 1
57570: RET
// export function hHackTeleport ( unit , x , y ) ; begin
57571: LD_INT 0
57573: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
57574: LD_VAR 0 1
57578: PPUSH
57579: LD_VAR 0 2
57583: PPUSH
57584: LD_VAR 0 3
57588: PPUSH
57589: LD_INT 1
57591: PPUSH
57592: LD_INT 1
57594: PPUSH
57595: CALL_OW 483
// CenterOnXY ( x , y ) ;
57599: LD_VAR 0 2
57603: PPUSH
57604: LD_VAR 0 3
57608: PPUSH
57609: CALL_OW 84
// end ;
57613: LD_VAR 0 4
57617: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
57618: LD_INT 0
57620: PPUSH
57621: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
57622: LD_VAR 0 1
57626: NOT
57627: PUSH
57628: LD_VAR 0 2
57632: PPUSH
57633: LD_VAR 0 3
57637: PPUSH
57638: CALL_OW 488
57642: NOT
57643: OR
57644: PUSH
57645: LD_VAR 0 1
57649: PPUSH
57650: CALL_OW 266
57654: PUSH
57655: LD_INT 3
57657: NONEQUAL
57658: PUSH
57659: LD_VAR 0 1
57663: PPUSH
57664: CALL_OW 247
57668: PUSH
57669: LD_INT 1
57671: EQUAL
57672: NOT
57673: AND
57674: OR
57675: IFFALSE 57679
// exit ;
57677: GO 57828
// if GetType ( factory ) = unit_human then
57679: LD_VAR 0 1
57683: PPUSH
57684: CALL_OW 247
57688: PUSH
57689: LD_INT 1
57691: EQUAL
57692: IFFALSE 57709
// factory := IsInUnit ( factory ) ;
57694: LD_ADDR_VAR 0 1
57698: PUSH
57699: LD_VAR 0 1
57703: PPUSH
57704: CALL_OW 310
57708: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
57709: LD_VAR 0 1
57713: PPUSH
57714: CALL_OW 266
57718: PUSH
57719: LD_INT 3
57721: NONEQUAL
57722: IFFALSE 57726
// exit ;
57724: GO 57828
// if HexInfo ( x , y ) = factory then
57726: LD_VAR 0 2
57730: PPUSH
57731: LD_VAR 0 3
57735: PPUSH
57736: CALL_OW 428
57740: PUSH
57741: LD_VAR 0 1
57745: EQUAL
57746: IFFALSE 57773
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
57748: LD_ADDR_EXP 131
57752: PUSH
57753: LD_EXP 131
57757: PPUSH
57758: LD_VAR 0 1
57762: PPUSH
57763: LD_INT 0
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
57771: GO 57824
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
57773: LD_ADDR_EXP 131
57777: PUSH
57778: LD_EXP 131
57782: PPUSH
57783: LD_VAR 0 1
57787: PPUSH
57788: LD_VAR 0 1
57792: PPUSH
57793: CALL_OW 255
57797: PUSH
57798: LD_VAR 0 1
57802: PUSH
57803: LD_VAR 0 2
57807: PUSH
57808: LD_VAR 0 3
57812: PUSH
57813: EMPTY
57814: LIST
57815: LIST
57816: LIST
57817: LIST
57818: PPUSH
57819: CALL_OW 1
57823: ST_TO_ADDR
// UpdateFactoryWaypoints ;
57824: CALL 57833 0 0
// end ;
57828: LD_VAR 0 4
57832: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
57833: LD_INT 0
57835: PPUSH
57836: PPUSH
57837: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
57838: LD_STRING resetFactoryWaypoint();
57840: PPUSH
57841: CALL_OW 559
// if factoryWaypoints then
57845: LD_EXP 131
57849: IFFALSE 57975
// begin list := PrepareArray ( factoryWaypoints ) ;
57851: LD_ADDR_VAR 0 3
57855: PUSH
57856: LD_EXP 131
57860: PPUSH
57861: CALL 104352 0 1
57865: ST_TO_ADDR
// for i := 1 to list do
57866: LD_ADDR_VAR 0 2
57870: PUSH
57871: DOUBLE
57872: LD_INT 1
57874: DEC
57875: ST_TO_ADDR
57876: LD_VAR 0 3
57880: PUSH
57881: FOR_TO
57882: IFFALSE 57973
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
57884: LD_STRING setFactoryWaypointXY(
57886: PUSH
57887: LD_VAR 0 3
57891: PUSH
57892: LD_VAR 0 2
57896: ARRAY
57897: PUSH
57898: LD_INT 1
57900: ARRAY
57901: STR
57902: PUSH
57903: LD_STRING ,
57905: STR
57906: PUSH
57907: LD_VAR 0 3
57911: PUSH
57912: LD_VAR 0 2
57916: ARRAY
57917: PUSH
57918: LD_INT 2
57920: ARRAY
57921: STR
57922: PUSH
57923: LD_STRING ,
57925: STR
57926: PUSH
57927: LD_VAR 0 3
57931: PUSH
57932: LD_VAR 0 2
57936: ARRAY
57937: PUSH
57938: LD_INT 3
57940: ARRAY
57941: STR
57942: PUSH
57943: LD_STRING ,
57945: STR
57946: PUSH
57947: LD_VAR 0 3
57951: PUSH
57952: LD_VAR 0 2
57956: ARRAY
57957: PUSH
57958: LD_INT 4
57960: ARRAY
57961: STR
57962: PUSH
57963: LD_STRING )
57965: STR
57966: PPUSH
57967: CALL_OW 559
57971: GO 57881
57973: POP
57974: POP
// end ; end ;
57975: LD_VAR 0 1
57979: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
57980: LD_INT 0
57982: PPUSH
// if HexInfo ( x , y ) = warehouse then
57983: LD_VAR 0 2
57987: PPUSH
57988: LD_VAR 0 3
57992: PPUSH
57993: CALL_OW 428
57997: PUSH
57998: LD_VAR 0 1
58002: EQUAL
58003: IFFALSE 58030
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
58005: LD_ADDR_EXP 132
58009: PUSH
58010: LD_EXP 132
58014: PPUSH
58015: LD_VAR 0 1
58019: PPUSH
58020: LD_INT 0
58022: PPUSH
58023: CALL_OW 1
58027: ST_TO_ADDR
58028: GO 58081
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
58030: LD_ADDR_EXP 132
58034: PUSH
58035: LD_EXP 132
58039: PPUSH
58040: LD_VAR 0 1
58044: PPUSH
58045: LD_VAR 0 1
58049: PPUSH
58050: CALL_OW 255
58054: PUSH
58055: LD_VAR 0 1
58059: PUSH
58060: LD_VAR 0 2
58064: PUSH
58065: LD_VAR 0 3
58069: PUSH
58070: EMPTY
58071: LIST
58072: LIST
58073: LIST
58074: LIST
58075: PPUSH
58076: CALL_OW 1
58080: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
58081: CALL 58090 0 0
// end ;
58085: LD_VAR 0 4
58089: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
58090: LD_INT 0
58092: PPUSH
58093: PPUSH
58094: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
58095: LD_STRING resetWarehouseGatheringPoints();
58097: PPUSH
58098: CALL_OW 559
// if warehouseGatheringPoints then
58102: LD_EXP 132
58106: IFFALSE 58232
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
58108: LD_ADDR_VAR 0 3
58112: PUSH
58113: LD_EXP 132
58117: PPUSH
58118: CALL 104352 0 1
58122: ST_TO_ADDR
// for i := 1 to list do
58123: LD_ADDR_VAR 0 2
58127: PUSH
58128: DOUBLE
58129: LD_INT 1
58131: DEC
58132: ST_TO_ADDR
58133: LD_VAR 0 3
58137: PUSH
58138: FOR_TO
58139: IFFALSE 58230
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
58141: LD_STRING setWarehouseGatheringPointXY(
58143: PUSH
58144: LD_VAR 0 3
58148: PUSH
58149: LD_VAR 0 2
58153: ARRAY
58154: PUSH
58155: LD_INT 1
58157: ARRAY
58158: STR
58159: PUSH
58160: LD_STRING ,
58162: STR
58163: PUSH
58164: LD_VAR 0 3
58168: PUSH
58169: LD_VAR 0 2
58173: ARRAY
58174: PUSH
58175: LD_INT 2
58177: ARRAY
58178: STR
58179: PUSH
58180: LD_STRING ,
58182: STR
58183: PUSH
58184: LD_VAR 0 3
58188: PUSH
58189: LD_VAR 0 2
58193: ARRAY
58194: PUSH
58195: LD_INT 3
58197: ARRAY
58198: STR
58199: PUSH
58200: LD_STRING ,
58202: STR
58203: PUSH
58204: LD_VAR 0 3
58208: PUSH
58209: LD_VAR 0 2
58213: ARRAY
58214: PUSH
58215: LD_INT 4
58217: ARRAY
58218: STR
58219: PUSH
58220: LD_STRING )
58222: STR
58223: PPUSH
58224: CALL_OW 559
58228: GO 58138
58230: POP
58231: POP
// end ; end ;
58232: LD_VAR 0 1
58236: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
58237: LD_EXP 132
58241: IFFALSE 58926
58243: GO 58245
58245: DISABLE
58246: LD_INT 0
58248: PPUSH
58249: PPUSH
58250: PPUSH
58251: PPUSH
58252: PPUSH
58253: PPUSH
58254: PPUSH
58255: PPUSH
58256: PPUSH
// begin enable ;
58257: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
58258: LD_ADDR_VAR 0 3
58262: PUSH
58263: LD_EXP 132
58267: PPUSH
58268: CALL 104352 0 1
58272: ST_TO_ADDR
// if not list then
58273: LD_VAR 0 3
58277: NOT
58278: IFFALSE 58282
// exit ;
58280: GO 58926
// for i := 1 to list do
58282: LD_ADDR_VAR 0 1
58286: PUSH
58287: DOUBLE
58288: LD_INT 1
58290: DEC
58291: ST_TO_ADDR
58292: LD_VAR 0 3
58296: PUSH
58297: FOR_TO
58298: IFFALSE 58924
// begin depot := list [ i ] [ 2 ] ;
58300: LD_ADDR_VAR 0 8
58304: PUSH
58305: LD_VAR 0 3
58309: PUSH
58310: LD_VAR 0 1
58314: ARRAY
58315: PUSH
58316: LD_INT 2
58318: ARRAY
58319: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
58320: LD_ADDR_VAR 0 5
58324: PUSH
58325: LD_VAR 0 3
58329: PUSH
58330: LD_VAR 0 1
58334: ARRAY
58335: PUSH
58336: LD_INT 1
58338: ARRAY
58339: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
58340: LD_VAR 0 8
58344: PPUSH
58345: CALL_OW 301
58349: PUSH
58350: LD_VAR 0 5
58354: PUSH
58355: LD_VAR 0 8
58359: PPUSH
58360: CALL_OW 255
58364: NONEQUAL
58365: OR
58366: IFFALSE 58395
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
58368: LD_ADDR_EXP 132
58372: PUSH
58373: LD_EXP 132
58377: PPUSH
58378: LD_VAR 0 8
58382: PPUSH
58383: LD_INT 0
58385: PPUSH
58386: CALL_OW 1
58390: ST_TO_ADDR
// exit ;
58391: POP
58392: POP
58393: GO 58926
// end ; x := list [ i ] [ 3 ] ;
58395: LD_ADDR_VAR 0 6
58399: PUSH
58400: LD_VAR 0 3
58404: PUSH
58405: LD_VAR 0 1
58409: ARRAY
58410: PUSH
58411: LD_INT 3
58413: ARRAY
58414: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
58415: LD_ADDR_VAR 0 7
58419: PUSH
58420: LD_VAR 0 3
58424: PUSH
58425: LD_VAR 0 1
58429: ARRAY
58430: PUSH
58431: LD_INT 4
58433: ARRAY
58434: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
58435: LD_ADDR_VAR 0 9
58439: PUSH
58440: LD_VAR 0 6
58444: PPUSH
58445: LD_VAR 0 7
58449: PPUSH
58450: LD_INT 16
58452: PPUSH
58453: CALL 102940 0 3
58457: ST_TO_ADDR
// if not cratesNearbyPoint then
58458: LD_VAR 0 9
58462: NOT
58463: IFFALSE 58469
// exit ;
58465: POP
58466: POP
58467: GO 58926
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
58469: LD_ADDR_VAR 0 4
58473: PUSH
58474: LD_INT 22
58476: PUSH
58477: LD_VAR 0 5
58481: PUSH
58482: EMPTY
58483: LIST
58484: LIST
58485: PUSH
58486: LD_INT 3
58488: PUSH
58489: LD_INT 60
58491: PUSH
58492: EMPTY
58493: LIST
58494: PUSH
58495: EMPTY
58496: LIST
58497: LIST
58498: PUSH
58499: LD_INT 91
58501: PUSH
58502: LD_VAR 0 8
58506: PUSH
58507: LD_INT 6
58509: PUSH
58510: EMPTY
58511: LIST
58512: LIST
58513: LIST
58514: PUSH
58515: LD_INT 2
58517: PUSH
58518: LD_INT 25
58520: PUSH
58521: LD_INT 2
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: PUSH
58528: LD_INT 25
58530: PUSH
58531: LD_INT 16
58533: PUSH
58534: EMPTY
58535: LIST
58536: LIST
58537: PUSH
58538: EMPTY
58539: LIST
58540: LIST
58541: LIST
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: LIST
58547: LIST
58548: PPUSH
58549: CALL_OW 69
58553: PUSH
58554: LD_VAR 0 8
58558: PPUSH
58559: CALL_OW 313
58563: PPUSH
58564: LD_INT 3
58566: PUSH
58567: LD_INT 60
58569: PUSH
58570: EMPTY
58571: LIST
58572: PUSH
58573: EMPTY
58574: LIST
58575: LIST
58576: PUSH
58577: LD_INT 2
58579: PUSH
58580: LD_INT 25
58582: PUSH
58583: LD_INT 2
58585: PUSH
58586: EMPTY
58587: LIST
58588: LIST
58589: PUSH
58590: LD_INT 25
58592: PUSH
58593: LD_INT 16
58595: PUSH
58596: EMPTY
58597: LIST
58598: LIST
58599: PUSH
58600: EMPTY
58601: LIST
58602: LIST
58603: LIST
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: PPUSH
58609: CALL_OW 72
58613: UNION
58614: ST_TO_ADDR
// if tmp then
58615: LD_VAR 0 4
58619: IFFALSE 58699
// begin tmp := ShrinkArray ( tmp , 3 ) ;
58621: LD_ADDR_VAR 0 4
58625: PUSH
58626: LD_VAR 0 4
58630: PPUSH
58631: LD_INT 3
58633: PPUSH
58634: CALL 100909 0 2
58638: ST_TO_ADDR
// for j in tmp do
58639: LD_ADDR_VAR 0 2
58643: PUSH
58644: LD_VAR 0 4
58648: PUSH
58649: FOR_IN
58650: IFFALSE 58693
// begin if IsInUnit ( j ) then
58652: LD_VAR 0 2
58656: PPUSH
58657: CALL_OW 310
58661: IFFALSE 58672
// ComExit ( j ) ;
58663: LD_VAR 0 2
58667: PPUSH
58668: CALL 100992 0 1
// AddComCollect ( j , x , y ) ;
58672: LD_VAR 0 2
58676: PPUSH
58677: LD_VAR 0 6
58681: PPUSH
58682: LD_VAR 0 7
58686: PPUSH
58687: CALL_OW 177
// end ;
58691: GO 58649
58693: POP
58694: POP
// exit ;
58695: POP
58696: POP
58697: GO 58926
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
58699: LD_ADDR_VAR 0 4
58703: PUSH
58704: LD_INT 22
58706: PUSH
58707: LD_VAR 0 5
58711: PUSH
58712: EMPTY
58713: LIST
58714: LIST
58715: PUSH
58716: LD_INT 91
58718: PUSH
58719: LD_VAR 0 8
58723: PUSH
58724: LD_INT 8
58726: PUSH
58727: EMPTY
58728: LIST
58729: LIST
58730: LIST
58731: PUSH
58732: LD_INT 2
58734: PUSH
58735: LD_INT 34
58737: PUSH
58738: LD_INT 12
58740: PUSH
58741: EMPTY
58742: LIST
58743: LIST
58744: PUSH
58745: LD_INT 34
58747: PUSH
58748: LD_INT 51
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: PUSH
58755: LD_INT 34
58757: PUSH
58758: LD_INT 32
58760: PUSH
58761: EMPTY
58762: LIST
58763: LIST
58764: PUSH
58765: LD_INT 34
58767: PUSH
58768: LD_INT 89
58770: PUSH
58771: EMPTY
58772: LIST
58773: LIST
58774: PUSH
58775: EMPTY
58776: LIST
58777: LIST
58778: LIST
58779: LIST
58780: LIST
58781: PUSH
58782: EMPTY
58783: LIST
58784: LIST
58785: LIST
58786: PPUSH
58787: CALL_OW 69
58791: ST_TO_ADDR
// if tmp then
58792: LD_VAR 0 4
58796: IFFALSE 58922
// begin for j in tmp do
58798: LD_ADDR_VAR 0 2
58802: PUSH
58803: LD_VAR 0 4
58807: PUSH
58808: FOR_IN
58809: IFFALSE 58920
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
58811: LD_VAR 0 2
58815: PPUSH
58816: CALL_OW 262
58820: PUSH
58821: LD_INT 3
58823: EQUAL
58824: PUSH
58825: LD_VAR 0 2
58829: PPUSH
58830: CALL_OW 261
58834: PUSH
58835: LD_INT 20
58837: GREATER
58838: OR
58839: PUSH
58840: LD_VAR 0 2
58844: PPUSH
58845: CALL_OW 314
58849: NOT
58850: AND
58851: PUSH
58852: LD_VAR 0 2
58856: PPUSH
58857: CALL_OW 263
58861: PUSH
58862: LD_INT 1
58864: NONEQUAL
58865: PUSH
58866: LD_VAR 0 2
58870: PPUSH
58871: CALL_OW 311
58875: OR
58876: AND
58877: IFFALSE 58918
// begin ComCollect ( j , x , y ) ;
58879: LD_VAR 0 2
58883: PPUSH
58884: LD_VAR 0 6
58888: PPUSH
58889: LD_VAR 0 7
58893: PPUSH
58894: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
58898: LD_VAR 0 2
58902: PPUSH
58903: LD_VAR 0 8
58907: PPUSH
58908: CALL_OW 172
// exit ;
58912: POP
58913: POP
58914: POP
58915: POP
58916: GO 58926
// end ;
58918: GO 58808
58920: POP
58921: POP
// end ; end ;
58922: GO 58297
58924: POP
58925: POP
// end ; end_of_file
58926: PPOPN 9
58928: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
58929: LD_INT 0
58931: PPUSH
58932: PPUSH
58933: PPUSH
58934: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
58935: LD_VAR 0 1
58939: PPUSH
58940: CALL_OW 264
58944: PUSH
58945: LD_INT 91
58947: EQUAL
58948: IFFALSE 59020
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
58950: LD_INT 68
58952: PPUSH
58953: LD_VAR 0 1
58957: PPUSH
58958: CALL_OW 255
58962: PPUSH
58963: CALL_OW 321
58967: PUSH
58968: LD_INT 2
58970: EQUAL
58971: IFFALSE 58983
// eff := 70 else
58973: LD_ADDR_VAR 0 4
58977: PUSH
58978: LD_INT 70
58980: ST_TO_ADDR
58981: GO 58991
// eff := 30 ;
58983: LD_ADDR_VAR 0 4
58987: PUSH
58988: LD_INT 30
58990: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
58991: LD_VAR 0 1
58995: PPUSH
58996: CALL_OW 250
59000: PPUSH
59001: LD_VAR 0 1
59005: PPUSH
59006: CALL_OW 251
59010: PPUSH
59011: LD_VAR 0 4
59015: PPUSH
59016: CALL_OW 495
// end ; end ;
59020: LD_VAR 0 2
59024: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
59025: LD_INT 0
59027: PPUSH
// end ;
59028: LD_VAR 0 4
59032: RET
// export function SOS_Command ( cmd ) ; begin
59033: LD_INT 0
59035: PPUSH
// end ;
59036: LD_VAR 0 2
59040: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
59041: LD_INT 0
59043: PPUSH
// end ;
59044: LD_VAR 0 6
59048: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
59049: LD_INT 0
59051: PPUSH
59052: PPUSH
// if not vehicle or not factory then
59053: LD_VAR 0 1
59057: NOT
59058: PUSH
59059: LD_VAR 0 2
59063: NOT
59064: OR
59065: IFFALSE 59069
// exit ;
59067: GO 59300
// if factoryWaypoints >= factory then
59069: LD_EXP 131
59073: PUSH
59074: LD_VAR 0 2
59078: GREATEREQUAL
59079: IFFALSE 59300
// if factoryWaypoints [ factory ] then
59081: LD_EXP 131
59085: PUSH
59086: LD_VAR 0 2
59090: ARRAY
59091: IFFALSE 59300
// begin if GetControl ( vehicle ) = control_manual then
59093: LD_VAR 0 1
59097: PPUSH
59098: CALL_OW 263
59102: PUSH
59103: LD_INT 1
59105: EQUAL
59106: IFFALSE 59187
// begin driver := IsDrivenBy ( vehicle ) ;
59108: LD_ADDR_VAR 0 4
59112: PUSH
59113: LD_VAR 0 1
59117: PPUSH
59118: CALL_OW 311
59122: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59123: LD_VAR 0 4
59127: PPUSH
59128: LD_EXP 131
59132: PUSH
59133: LD_VAR 0 2
59137: ARRAY
59138: PUSH
59139: LD_INT 3
59141: ARRAY
59142: PPUSH
59143: LD_EXP 131
59147: PUSH
59148: LD_VAR 0 2
59152: ARRAY
59153: PUSH
59154: LD_INT 4
59156: ARRAY
59157: PPUSH
59158: CALL_OW 171
// AddComExitVehicle ( driver ) ;
59162: LD_VAR 0 4
59166: PPUSH
59167: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
59171: LD_VAR 0 4
59175: PPUSH
59176: LD_VAR 0 2
59180: PPUSH
59181: CALL_OW 180
// end else
59185: GO 59300
// if GetControl ( vehicle ) = control_remote then
59187: LD_VAR 0 1
59191: PPUSH
59192: CALL_OW 263
59196: PUSH
59197: LD_INT 2
59199: EQUAL
59200: IFFALSE 59261
// begin wait ( 0 0$2 ) ;
59202: LD_INT 70
59204: PPUSH
59205: CALL_OW 67
// if Connect ( vehicle ) then
59209: LD_VAR 0 1
59213: PPUSH
59214: CALL 71324 0 1
59218: IFFALSE 59259
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59220: LD_VAR 0 1
59224: PPUSH
59225: LD_EXP 131
59229: PUSH
59230: LD_VAR 0 2
59234: ARRAY
59235: PUSH
59236: LD_INT 3
59238: ARRAY
59239: PPUSH
59240: LD_EXP 131
59244: PUSH
59245: LD_VAR 0 2
59249: ARRAY
59250: PUSH
59251: LD_INT 4
59253: ARRAY
59254: PPUSH
59255: CALL_OW 171
// end else
59259: GO 59300
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
59261: LD_VAR 0 1
59265: PPUSH
59266: LD_EXP 131
59270: PUSH
59271: LD_VAR 0 2
59275: ARRAY
59276: PUSH
59277: LD_INT 3
59279: ARRAY
59280: PPUSH
59281: LD_EXP 131
59285: PUSH
59286: LD_VAR 0 2
59290: ARRAY
59291: PUSH
59292: LD_INT 4
59294: ARRAY
59295: PPUSH
59296: CALL_OW 171
// end ; end ;
59300: LD_VAR 0 3
59304: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
59305: LD_INT 0
59307: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
59308: LD_VAR 0 1
59312: PUSH
59313: LD_INT 250
59315: EQUAL
59316: PUSH
59317: LD_VAR 0 2
59321: PPUSH
59322: CALL_OW 264
59326: PUSH
59327: LD_INT 81
59329: EQUAL
59330: AND
59331: IFFALSE 59352
// MinerPlaceMine ( unit , x , y ) ;
59333: LD_VAR 0 2
59337: PPUSH
59338: LD_VAR 0 4
59342: PPUSH
59343: LD_VAR 0 5
59347: PPUSH
59348: CALL 61737 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
59352: LD_VAR 0 1
59356: PUSH
59357: LD_INT 251
59359: EQUAL
59360: PUSH
59361: LD_VAR 0 2
59365: PPUSH
59366: CALL_OW 264
59370: PUSH
59371: LD_INT 81
59373: EQUAL
59374: AND
59375: IFFALSE 59396
// MinerDetonateMine ( unit , x , y ) ;
59377: LD_VAR 0 2
59381: PPUSH
59382: LD_VAR 0 4
59386: PPUSH
59387: LD_VAR 0 5
59391: PPUSH
59392: CALL 62012 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
59396: LD_VAR 0 1
59400: PUSH
59401: LD_INT 252
59403: EQUAL
59404: PUSH
59405: LD_VAR 0 2
59409: PPUSH
59410: CALL_OW 264
59414: PUSH
59415: LD_INT 81
59417: EQUAL
59418: AND
59419: IFFALSE 59440
// MinerCreateMinefield ( unit , x , y ) ;
59421: LD_VAR 0 2
59425: PPUSH
59426: LD_VAR 0 4
59430: PPUSH
59431: LD_VAR 0 5
59435: PPUSH
59436: CALL 62429 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
59440: LD_VAR 0 1
59444: PUSH
59445: LD_INT 253
59447: EQUAL
59448: PUSH
59449: LD_VAR 0 2
59453: PPUSH
59454: CALL_OW 257
59458: PUSH
59459: LD_INT 5
59461: EQUAL
59462: AND
59463: IFFALSE 59484
// ComBinocular ( unit , x , y ) ;
59465: LD_VAR 0 2
59469: PPUSH
59470: LD_VAR 0 4
59474: PPUSH
59475: LD_VAR 0 5
59479: PPUSH
59480: CALL 62798 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
59484: LD_VAR 0 1
59488: PUSH
59489: LD_INT 254
59491: EQUAL
59492: PUSH
59493: LD_VAR 0 2
59497: PPUSH
59498: CALL_OW 264
59502: PUSH
59503: LD_INT 99
59505: EQUAL
59506: AND
59507: PUSH
59508: LD_VAR 0 3
59512: PPUSH
59513: CALL_OW 263
59517: PUSH
59518: LD_INT 3
59520: EQUAL
59521: AND
59522: IFFALSE 59538
// HackDestroyVehicle ( unit , selectedUnit ) ;
59524: LD_VAR 0 2
59528: PPUSH
59529: LD_VAR 0 3
59533: PPUSH
59534: CALL 61101 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
59538: LD_VAR 0 1
59542: PUSH
59543: LD_INT 255
59545: EQUAL
59546: PUSH
59547: LD_VAR 0 2
59551: PPUSH
59552: CALL_OW 264
59556: PUSH
59557: LD_INT 14
59559: PUSH
59560: LD_INT 53
59562: PUSH
59563: EMPTY
59564: LIST
59565: LIST
59566: IN
59567: AND
59568: PUSH
59569: LD_VAR 0 4
59573: PPUSH
59574: LD_VAR 0 5
59578: PPUSH
59579: CALL_OW 488
59583: AND
59584: IFFALSE 59608
// CutTreeXYR ( unit , x , y , 12 ) ;
59586: LD_VAR 0 2
59590: PPUSH
59591: LD_VAR 0 4
59595: PPUSH
59596: LD_VAR 0 5
59600: PPUSH
59601: LD_INT 12
59603: PPUSH
59604: CALL 59671 0 4
// if cmd = 256 then
59608: LD_VAR 0 1
59612: PUSH
59613: LD_INT 256
59615: EQUAL
59616: IFFALSE 59637
// SetFactoryWaypoint ( unit , x , y ) ;
59618: LD_VAR 0 2
59622: PPUSH
59623: LD_VAR 0 4
59627: PPUSH
59628: LD_VAR 0 5
59632: PPUSH
59633: CALL 57618 0 3
// if cmd = 257 then
59637: LD_VAR 0 1
59641: PUSH
59642: LD_INT 257
59644: EQUAL
59645: IFFALSE 59666
// SetWarehouseGatheringPoint ( unit , x , y ) ;
59647: LD_VAR 0 2
59651: PPUSH
59652: LD_VAR 0 4
59656: PPUSH
59657: LD_VAR 0 5
59661: PPUSH
59662: CALL 57980 0 3
// end ;
59666: LD_VAR 0 6
59670: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
59671: LD_INT 0
59673: PPUSH
59674: PPUSH
59675: PPUSH
59676: PPUSH
59677: PPUSH
59678: PPUSH
59679: PPUSH
59680: PPUSH
59681: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
59682: LD_VAR 0 1
59686: NOT
59687: PUSH
59688: LD_VAR 0 2
59692: PPUSH
59693: LD_VAR 0 3
59697: PPUSH
59698: CALL_OW 488
59702: NOT
59703: OR
59704: PUSH
59705: LD_VAR 0 4
59709: NOT
59710: OR
59711: IFFALSE 59715
// exit ;
59713: GO 60055
// list := [ ] ;
59715: LD_ADDR_VAR 0 13
59719: PUSH
59720: EMPTY
59721: ST_TO_ADDR
// if x - r < 0 then
59722: LD_VAR 0 2
59726: PUSH
59727: LD_VAR 0 4
59731: MINUS
59732: PUSH
59733: LD_INT 0
59735: LESS
59736: IFFALSE 59748
// min_x := 0 else
59738: LD_ADDR_VAR 0 7
59742: PUSH
59743: LD_INT 0
59745: ST_TO_ADDR
59746: GO 59764
// min_x := x - r ;
59748: LD_ADDR_VAR 0 7
59752: PUSH
59753: LD_VAR 0 2
59757: PUSH
59758: LD_VAR 0 4
59762: MINUS
59763: ST_TO_ADDR
// if y - r < 0 then
59764: LD_VAR 0 3
59768: PUSH
59769: LD_VAR 0 4
59773: MINUS
59774: PUSH
59775: LD_INT 0
59777: LESS
59778: IFFALSE 59790
// min_y := 0 else
59780: LD_ADDR_VAR 0 8
59784: PUSH
59785: LD_INT 0
59787: ST_TO_ADDR
59788: GO 59806
// min_y := y - r ;
59790: LD_ADDR_VAR 0 8
59794: PUSH
59795: LD_VAR 0 3
59799: PUSH
59800: LD_VAR 0 4
59804: MINUS
59805: ST_TO_ADDR
// max_x := x + r ;
59806: LD_ADDR_VAR 0 9
59810: PUSH
59811: LD_VAR 0 2
59815: PUSH
59816: LD_VAR 0 4
59820: PLUS
59821: ST_TO_ADDR
// max_y := y + r ;
59822: LD_ADDR_VAR 0 10
59826: PUSH
59827: LD_VAR 0 3
59831: PUSH
59832: LD_VAR 0 4
59836: PLUS
59837: ST_TO_ADDR
// for _x = min_x to max_x do
59838: LD_ADDR_VAR 0 11
59842: PUSH
59843: DOUBLE
59844: LD_VAR 0 7
59848: DEC
59849: ST_TO_ADDR
59850: LD_VAR 0 9
59854: PUSH
59855: FOR_TO
59856: IFFALSE 59973
// for _y = min_y to max_y do
59858: LD_ADDR_VAR 0 12
59862: PUSH
59863: DOUBLE
59864: LD_VAR 0 8
59868: DEC
59869: ST_TO_ADDR
59870: LD_VAR 0 10
59874: PUSH
59875: FOR_TO
59876: IFFALSE 59969
// begin if not ValidHex ( _x , _y ) then
59878: LD_VAR 0 11
59882: PPUSH
59883: LD_VAR 0 12
59887: PPUSH
59888: CALL_OW 488
59892: NOT
59893: IFFALSE 59897
// continue ;
59895: GO 59875
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
59897: LD_VAR 0 11
59901: PPUSH
59902: LD_VAR 0 12
59906: PPUSH
59907: CALL_OW 351
59911: PUSH
59912: LD_VAR 0 11
59916: PPUSH
59917: LD_VAR 0 12
59921: PPUSH
59922: CALL_OW 554
59926: AND
59927: IFFALSE 59967
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
59929: LD_ADDR_VAR 0 13
59933: PUSH
59934: LD_VAR 0 13
59938: PPUSH
59939: LD_VAR 0 13
59943: PUSH
59944: LD_INT 1
59946: PLUS
59947: PPUSH
59948: LD_VAR 0 11
59952: PUSH
59953: LD_VAR 0 12
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: PPUSH
59962: CALL_OW 2
59966: ST_TO_ADDR
// end ;
59967: GO 59875
59969: POP
59970: POP
59971: GO 59855
59973: POP
59974: POP
// if not list then
59975: LD_VAR 0 13
59979: NOT
59980: IFFALSE 59984
// exit ;
59982: GO 60055
// for i in list do
59984: LD_ADDR_VAR 0 6
59988: PUSH
59989: LD_VAR 0 13
59993: PUSH
59994: FOR_IN
59995: IFFALSE 60053
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
59997: LD_VAR 0 1
60001: PPUSH
60002: LD_STRING M
60004: PUSH
60005: LD_VAR 0 6
60009: PUSH
60010: LD_INT 1
60012: ARRAY
60013: PUSH
60014: LD_VAR 0 6
60018: PUSH
60019: LD_INT 2
60021: ARRAY
60022: PUSH
60023: LD_INT 0
60025: PUSH
60026: LD_INT 0
60028: PUSH
60029: LD_INT 0
60031: PUSH
60032: LD_INT 0
60034: PUSH
60035: EMPTY
60036: LIST
60037: LIST
60038: LIST
60039: LIST
60040: LIST
60041: LIST
60042: LIST
60043: PUSH
60044: EMPTY
60045: LIST
60046: PPUSH
60047: CALL_OW 447
60051: GO 59994
60053: POP
60054: POP
// end ;
60055: LD_VAR 0 5
60059: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
60060: LD_EXP 134
60064: NOT
60065: IFFALSE 60115
60067: GO 60069
60069: DISABLE
// begin initHack := true ;
60070: LD_ADDR_EXP 134
60074: PUSH
60075: LD_INT 1
60077: ST_TO_ADDR
// hackTanks := [ ] ;
60078: LD_ADDR_EXP 135
60082: PUSH
60083: EMPTY
60084: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
60085: LD_ADDR_EXP 136
60089: PUSH
60090: EMPTY
60091: ST_TO_ADDR
// hackLimit := 3 ;
60092: LD_ADDR_EXP 137
60096: PUSH
60097: LD_INT 3
60099: ST_TO_ADDR
// hackDist := 12 ;
60100: LD_ADDR_EXP 138
60104: PUSH
60105: LD_INT 12
60107: ST_TO_ADDR
// hackCounter := [ ] ;
60108: LD_ADDR_EXP 139
60112: PUSH
60113: EMPTY
60114: ST_TO_ADDR
// end ;
60115: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
60116: LD_EXP 134
60120: PUSH
60121: LD_INT 34
60123: PUSH
60124: LD_INT 99
60126: PUSH
60127: EMPTY
60128: LIST
60129: LIST
60130: PPUSH
60131: CALL_OW 69
60135: AND
60136: IFFALSE 60389
60138: GO 60140
60140: DISABLE
60141: LD_INT 0
60143: PPUSH
60144: PPUSH
// begin enable ;
60145: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
60146: LD_ADDR_VAR 0 1
60150: PUSH
60151: LD_INT 34
60153: PUSH
60154: LD_INT 99
60156: PUSH
60157: EMPTY
60158: LIST
60159: LIST
60160: PPUSH
60161: CALL_OW 69
60165: PUSH
60166: FOR_IN
60167: IFFALSE 60387
// begin if not i in hackTanks then
60169: LD_VAR 0 1
60173: PUSH
60174: LD_EXP 135
60178: IN
60179: NOT
60180: IFFALSE 60263
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
60182: LD_ADDR_EXP 135
60186: PUSH
60187: LD_EXP 135
60191: PPUSH
60192: LD_EXP 135
60196: PUSH
60197: LD_INT 1
60199: PLUS
60200: PPUSH
60201: LD_VAR 0 1
60205: PPUSH
60206: CALL_OW 1
60210: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
60211: LD_ADDR_EXP 136
60215: PUSH
60216: LD_EXP 136
60220: PPUSH
60221: LD_EXP 136
60225: PUSH
60226: LD_INT 1
60228: PLUS
60229: PPUSH
60230: EMPTY
60231: PPUSH
60232: CALL_OW 1
60236: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
60237: LD_ADDR_EXP 139
60241: PUSH
60242: LD_EXP 139
60246: PPUSH
60247: LD_EXP 139
60251: PUSH
60252: LD_INT 1
60254: PLUS
60255: PPUSH
60256: EMPTY
60257: PPUSH
60258: CALL_OW 1
60262: ST_TO_ADDR
// end ; if not IsOk ( i ) then
60263: LD_VAR 0 1
60267: PPUSH
60268: CALL_OW 302
60272: NOT
60273: IFFALSE 60286
// begin HackUnlinkAll ( i ) ;
60275: LD_VAR 0 1
60279: PPUSH
60280: CALL 60392 0 1
// continue ;
60284: GO 60166
// end ; HackCheckCapturedStatus ( i ) ;
60286: LD_VAR 0 1
60290: PPUSH
60291: CALL 60835 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
60295: LD_ADDR_VAR 0 2
60299: PUSH
60300: LD_INT 81
60302: PUSH
60303: LD_VAR 0 1
60307: PPUSH
60308: CALL_OW 255
60312: PUSH
60313: EMPTY
60314: LIST
60315: LIST
60316: PUSH
60317: LD_INT 33
60319: PUSH
60320: LD_INT 3
60322: PUSH
60323: EMPTY
60324: LIST
60325: LIST
60326: PUSH
60327: LD_INT 91
60329: PUSH
60330: LD_VAR 0 1
60334: PUSH
60335: LD_EXP 138
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: LIST
60344: PUSH
60345: LD_INT 50
60347: PUSH
60348: EMPTY
60349: LIST
60350: PUSH
60351: EMPTY
60352: LIST
60353: LIST
60354: LIST
60355: LIST
60356: PPUSH
60357: CALL_OW 69
60361: ST_TO_ADDR
// if not tmp then
60362: LD_VAR 0 2
60366: NOT
60367: IFFALSE 60371
// continue ;
60369: GO 60166
// HackLink ( i , tmp ) ;
60371: LD_VAR 0 1
60375: PPUSH
60376: LD_VAR 0 2
60380: PPUSH
60381: CALL 60528 0 2
// end ;
60385: GO 60166
60387: POP
60388: POP
// end ;
60389: PPOPN 2
60391: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
60392: LD_INT 0
60394: PPUSH
60395: PPUSH
60396: PPUSH
// if not hack in hackTanks then
60397: LD_VAR 0 1
60401: PUSH
60402: LD_EXP 135
60406: IN
60407: NOT
60408: IFFALSE 60412
// exit ;
60410: GO 60523
// index := GetElementIndex ( hackTanks , hack ) ;
60412: LD_ADDR_VAR 0 4
60416: PUSH
60417: LD_EXP 135
60421: PPUSH
60422: LD_VAR 0 1
60426: PPUSH
60427: CALL 68140 0 2
60431: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
60432: LD_EXP 136
60436: PUSH
60437: LD_VAR 0 4
60441: ARRAY
60442: IFFALSE 60523
// begin for i in hackTanksCaptured [ index ] do
60444: LD_ADDR_VAR 0 3
60448: PUSH
60449: LD_EXP 136
60453: PUSH
60454: LD_VAR 0 4
60458: ARRAY
60459: PUSH
60460: FOR_IN
60461: IFFALSE 60487
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
60463: LD_VAR 0 3
60467: PUSH
60468: LD_INT 1
60470: ARRAY
60471: PPUSH
60472: LD_VAR 0 3
60476: PUSH
60477: LD_INT 2
60479: ARRAY
60480: PPUSH
60481: CALL_OW 235
60485: GO 60460
60487: POP
60488: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
60489: LD_ADDR_EXP 136
60493: PUSH
60494: LD_EXP 136
60498: PPUSH
60499: LD_VAR 0 4
60503: PPUSH
60504: EMPTY
60505: PPUSH
60506: CALL_OW 1
60510: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
60511: LD_VAR 0 1
60515: PPUSH
60516: LD_INT 0
60518: PPUSH
60519: CALL_OW 505
// end ; end ;
60523: LD_VAR 0 2
60527: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
60528: LD_INT 0
60530: PPUSH
60531: PPUSH
60532: PPUSH
// if not hack in hackTanks or not vehicles then
60533: LD_VAR 0 1
60537: PUSH
60538: LD_EXP 135
60542: IN
60543: NOT
60544: PUSH
60545: LD_VAR 0 2
60549: NOT
60550: OR
60551: IFFALSE 60555
// exit ;
60553: GO 60830
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
60555: LD_ADDR_VAR 0 2
60559: PUSH
60560: LD_VAR 0 1
60564: PPUSH
60565: LD_VAR 0 2
60569: PPUSH
60570: LD_INT 1
60572: PPUSH
60573: LD_INT 1
60575: PPUSH
60576: CALL 68790 0 4
60580: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
60581: LD_ADDR_VAR 0 5
60585: PUSH
60586: LD_EXP 135
60590: PPUSH
60591: LD_VAR 0 1
60595: PPUSH
60596: CALL 68140 0 2
60600: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
60601: LD_EXP 136
60605: PUSH
60606: LD_VAR 0 5
60610: ARRAY
60611: PUSH
60612: LD_EXP 137
60616: LESS
60617: IFFALSE 60806
// begin for i := 1 to vehicles do
60619: LD_ADDR_VAR 0 4
60623: PUSH
60624: DOUBLE
60625: LD_INT 1
60627: DEC
60628: ST_TO_ADDR
60629: LD_VAR 0 2
60633: PUSH
60634: FOR_TO
60635: IFFALSE 60804
// begin if hackTanksCaptured [ index ] = hackLimit then
60637: LD_EXP 136
60641: PUSH
60642: LD_VAR 0 5
60646: ARRAY
60647: PUSH
60648: LD_EXP 137
60652: EQUAL
60653: IFFALSE 60657
// break ;
60655: GO 60804
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
60657: LD_ADDR_EXP 139
60661: PUSH
60662: LD_EXP 139
60666: PPUSH
60667: LD_VAR 0 5
60671: PPUSH
60672: LD_EXP 139
60676: PUSH
60677: LD_VAR 0 5
60681: ARRAY
60682: PUSH
60683: LD_INT 1
60685: PLUS
60686: PPUSH
60687: CALL_OW 1
60691: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
60692: LD_ADDR_EXP 136
60696: PUSH
60697: LD_EXP 136
60701: PPUSH
60702: LD_VAR 0 5
60706: PUSH
60707: LD_EXP 136
60711: PUSH
60712: LD_VAR 0 5
60716: ARRAY
60717: PUSH
60718: LD_INT 1
60720: PLUS
60721: PUSH
60722: EMPTY
60723: LIST
60724: LIST
60725: PPUSH
60726: LD_VAR 0 2
60730: PUSH
60731: LD_VAR 0 4
60735: ARRAY
60736: PUSH
60737: LD_VAR 0 2
60741: PUSH
60742: LD_VAR 0 4
60746: ARRAY
60747: PPUSH
60748: CALL_OW 255
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: PPUSH
60757: CALL 68355 0 3
60761: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
60762: LD_VAR 0 2
60766: PUSH
60767: LD_VAR 0 4
60771: ARRAY
60772: PPUSH
60773: LD_VAR 0 1
60777: PPUSH
60778: CALL_OW 255
60782: PPUSH
60783: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
60787: LD_VAR 0 2
60791: PUSH
60792: LD_VAR 0 4
60796: ARRAY
60797: PPUSH
60798: CALL_OW 141
// end ;
60802: GO 60634
60804: POP
60805: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
60806: LD_VAR 0 1
60810: PPUSH
60811: LD_EXP 136
60815: PUSH
60816: LD_VAR 0 5
60820: ARRAY
60821: PUSH
60822: LD_INT 0
60824: PLUS
60825: PPUSH
60826: CALL_OW 505
// end ;
60830: LD_VAR 0 3
60834: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
60835: LD_INT 0
60837: PPUSH
60838: PPUSH
60839: PPUSH
60840: PPUSH
// if not hack in hackTanks then
60841: LD_VAR 0 1
60845: PUSH
60846: LD_EXP 135
60850: IN
60851: NOT
60852: IFFALSE 60856
// exit ;
60854: GO 61096
// index := GetElementIndex ( hackTanks , hack ) ;
60856: LD_ADDR_VAR 0 4
60860: PUSH
60861: LD_EXP 135
60865: PPUSH
60866: LD_VAR 0 1
60870: PPUSH
60871: CALL 68140 0 2
60875: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
60876: LD_ADDR_VAR 0 3
60880: PUSH
60881: DOUBLE
60882: LD_EXP 136
60886: PUSH
60887: LD_VAR 0 4
60891: ARRAY
60892: INC
60893: ST_TO_ADDR
60894: LD_INT 1
60896: PUSH
60897: FOR_DOWNTO
60898: IFFALSE 61070
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
60900: LD_ADDR_VAR 0 5
60904: PUSH
60905: LD_EXP 136
60909: PUSH
60910: LD_VAR 0 4
60914: ARRAY
60915: PUSH
60916: LD_VAR 0 3
60920: ARRAY
60921: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
60922: LD_VAR 0 5
60926: PUSH
60927: LD_INT 1
60929: ARRAY
60930: PPUSH
60931: CALL_OW 302
60935: NOT
60936: PUSH
60937: LD_VAR 0 5
60941: PUSH
60942: LD_INT 1
60944: ARRAY
60945: PPUSH
60946: CALL_OW 255
60950: PUSH
60951: LD_VAR 0 1
60955: PPUSH
60956: CALL_OW 255
60960: NONEQUAL
60961: OR
60962: IFFALSE 61068
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
60964: LD_VAR 0 5
60968: PUSH
60969: LD_INT 1
60971: ARRAY
60972: PPUSH
60973: CALL_OW 305
60977: PUSH
60978: LD_VAR 0 5
60982: PUSH
60983: LD_INT 1
60985: ARRAY
60986: PPUSH
60987: CALL_OW 255
60991: PUSH
60992: LD_VAR 0 1
60996: PPUSH
60997: CALL_OW 255
61001: EQUAL
61002: AND
61003: IFFALSE 61027
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
61005: LD_VAR 0 5
61009: PUSH
61010: LD_INT 1
61012: ARRAY
61013: PPUSH
61014: LD_VAR 0 5
61018: PUSH
61019: LD_INT 2
61021: ARRAY
61022: PPUSH
61023: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
61027: LD_ADDR_EXP 136
61031: PUSH
61032: LD_EXP 136
61036: PPUSH
61037: LD_VAR 0 4
61041: PPUSH
61042: LD_EXP 136
61046: PUSH
61047: LD_VAR 0 4
61051: ARRAY
61052: PPUSH
61053: LD_VAR 0 3
61057: PPUSH
61058: CALL_OW 3
61062: PPUSH
61063: CALL_OW 1
61067: ST_TO_ADDR
// end ; end ;
61068: GO 60897
61070: POP
61071: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
61072: LD_VAR 0 1
61076: PPUSH
61077: LD_EXP 136
61081: PUSH
61082: LD_VAR 0 4
61086: ARRAY
61087: PUSH
61088: LD_INT 0
61090: PLUS
61091: PPUSH
61092: CALL_OW 505
// end ;
61096: LD_VAR 0 2
61100: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
61101: LD_INT 0
61103: PPUSH
61104: PPUSH
61105: PPUSH
61106: PPUSH
// if not hack in hackTanks then
61107: LD_VAR 0 1
61111: PUSH
61112: LD_EXP 135
61116: IN
61117: NOT
61118: IFFALSE 61122
// exit ;
61120: GO 61207
// index := GetElementIndex ( hackTanks , hack ) ;
61122: LD_ADDR_VAR 0 5
61126: PUSH
61127: LD_EXP 135
61131: PPUSH
61132: LD_VAR 0 1
61136: PPUSH
61137: CALL 68140 0 2
61141: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
61142: LD_ADDR_VAR 0 4
61146: PUSH
61147: DOUBLE
61148: LD_INT 1
61150: DEC
61151: ST_TO_ADDR
61152: LD_EXP 136
61156: PUSH
61157: LD_VAR 0 5
61161: ARRAY
61162: PUSH
61163: FOR_TO
61164: IFFALSE 61205
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
61166: LD_EXP 136
61170: PUSH
61171: LD_VAR 0 5
61175: ARRAY
61176: PUSH
61177: LD_VAR 0 4
61181: ARRAY
61182: PUSH
61183: LD_INT 1
61185: ARRAY
61186: PUSH
61187: LD_VAR 0 2
61191: EQUAL
61192: IFFALSE 61203
// KillUnit ( vehicle ) ;
61194: LD_VAR 0 2
61198: PPUSH
61199: CALL_OW 66
61203: GO 61163
61205: POP
61206: POP
// end ;
61207: LD_VAR 0 3
61211: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
61212: LD_EXP 140
61216: NOT
61217: IFFALSE 61252
61219: GO 61221
61221: DISABLE
// begin initMiner := true ;
61222: LD_ADDR_EXP 140
61226: PUSH
61227: LD_INT 1
61229: ST_TO_ADDR
// minersList := [ ] ;
61230: LD_ADDR_EXP 141
61234: PUSH
61235: EMPTY
61236: ST_TO_ADDR
// minerMinesList := [ ] ;
61237: LD_ADDR_EXP 142
61241: PUSH
61242: EMPTY
61243: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
61244: LD_ADDR_EXP 143
61248: PUSH
61249: LD_INT 5
61251: ST_TO_ADDR
// end ;
61252: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
61253: LD_EXP 140
61257: PUSH
61258: LD_INT 34
61260: PUSH
61261: LD_INT 81
61263: PUSH
61264: EMPTY
61265: LIST
61266: LIST
61267: PPUSH
61268: CALL_OW 69
61272: AND
61273: IFFALSE 61734
61275: GO 61277
61277: DISABLE
61278: LD_INT 0
61280: PPUSH
61281: PPUSH
61282: PPUSH
61283: PPUSH
// begin enable ;
61284: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
61285: LD_ADDR_VAR 0 1
61289: PUSH
61290: LD_INT 34
61292: PUSH
61293: LD_INT 81
61295: PUSH
61296: EMPTY
61297: LIST
61298: LIST
61299: PPUSH
61300: CALL_OW 69
61304: PUSH
61305: FOR_IN
61306: IFFALSE 61378
// begin if not i in minersList then
61308: LD_VAR 0 1
61312: PUSH
61313: LD_EXP 141
61317: IN
61318: NOT
61319: IFFALSE 61376
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
61321: LD_ADDR_EXP 141
61325: PUSH
61326: LD_EXP 141
61330: PPUSH
61331: LD_EXP 141
61335: PUSH
61336: LD_INT 1
61338: PLUS
61339: PPUSH
61340: LD_VAR 0 1
61344: PPUSH
61345: CALL_OW 1
61349: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
61350: LD_ADDR_EXP 142
61354: PUSH
61355: LD_EXP 142
61359: PPUSH
61360: LD_EXP 142
61364: PUSH
61365: LD_INT 1
61367: PLUS
61368: PPUSH
61369: EMPTY
61370: PPUSH
61371: CALL_OW 1
61375: ST_TO_ADDR
// end end ;
61376: GO 61305
61378: POP
61379: POP
// for i := minerMinesList downto 1 do
61380: LD_ADDR_VAR 0 1
61384: PUSH
61385: DOUBLE
61386: LD_EXP 142
61390: INC
61391: ST_TO_ADDR
61392: LD_INT 1
61394: PUSH
61395: FOR_DOWNTO
61396: IFFALSE 61732
// begin if IsLive ( minersList [ i ] ) then
61398: LD_EXP 141
61402: PUSH
61403: LD_VAR 0 1
61407: ARRAY
61408: PPUSH
61409: CALL_OW 300
61413: IFFALSE 61441
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
61415: LD_EXP 141
61419: PUSH
61420: LD_VAR 0 1
61424: ARRAY
61425: PPUSH
61426: LD_EXP 142
61430: PUSH
61431: LD_VAR 0 1
61435: ARRAY
61436: PPUSH
61437: CALL_OW 505
// if not minerMinesList [ i ] then
61441: LD_EXP 142
61445: PUSH
61446: LD_VAR 0 1
61450: ARRAY
61451: NOT
61452: IFFALSE 61456
// continue ;
61454: GO 61395
// for j := minerMinesList [ i ] downto 1 do
61456: LD_ADDR_VAR 0 2
61460: PUSH
61461: DOUBLE
61462: LD_EXP 142
61466: PUSH
61467: LD_VAR 0 1
61471: ARRAY
61472: INC
61473: ST_TO_ADDR
61474: LD_INT 1
61476: PUSH
61477: FOR_DOWNTO
61478: IFFALSE 61728
// begin side := GetSide ( minersList [ i ] ) ;
61480: LD_ADDR_VAR 0 3
61484: PUSH
61485: LD_EXP 141
61489: PUSH
61490: LD_VAR 0 1
61494: ARRAY
61495: PPUSH
61496: CALL_OW 255
61500: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
61501: LD_ADDR_VAR 0 4
61505: PUSH
61506: LD_EXP 142
61510: PUSH
61511: LD_VAR 0 1
61515: ARRAY
61516: PUSH
61517: LD_VAR 0 2
61521: ARRAY
61522: PUSH
61523: LD_INT 1
61525: ARRAY
61526: PPUSH
61527: LD_EXP 142
61531: PUSH
61532: LD_VAR 0 1
61536: ARRAY
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PUSH
61544: LD_INT 2
61546: ARRAY
61547: PPUSH
61548: CALL_OW 428
61552: ST_TO_ADDR
// if not tmp then
61553: LD_VAR 0 4
61557: NOT
61558: IFFALSE 61562
// continue ;
61560: GO 61477
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
61562: LD_VAR 0 4
61566: PUSH
61567: LD_INT 81
61569: PUSH
61570: LD_VAR 0 3
61574: PUSH
61575: EMPTY
61576: LIST
61577: LIST
61578: PPUSH
61579: CALL_OW 69
61583: IN
61584: PUSH
61585: LD_EXP 142
61589: PUSH
61590: LD_VAR 0 1
61594: ARRAY
61595: PUSH
61596: LD_VAR 0 2
61600: ARRAY
61601: PUSH
61602: LD_INT 1
61604: ARRAY
61605: PPUSH
61606: LD_EXP 142
61610: PUSH
61611: LD_VAR 0 1
61615: ARRAY
61616: PUSH
61617: LD_VAR 0 2
61621: ARRAY
61622: PUSH
61623: LD_INT 2
61625: ARRAY
61626: PPUSH
61627: CALL_OW 458
61631: AND
61632: IFFALSE 61726
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
61634: LD_EXP 142
61638: PUSH
61639: LD_VAR 0 1
61643: ARRAY
61644: PUSH
61645: LD_VAR 0 2
61649: ARRAY
61650: PUSH
61651: LD_INT 1
61653: ARRAY
61654: PPUSH
61655: LD_EXP 142
61659: PUSH
61660: LD_VAR 0 1
61664: ARRAY
61665: PUSH
61666: LD_VAR 0 2
61670: ARRAY
61671: PUSH
61672: LD_INT 2
61674: ARRAY
61675: PPUSH
61676: LD_VAR 0 3
61680: PPUSH
61681: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
61685: LD_ADDR_EXP 142
61689: PUSH
61690: LD_EXP 142
61694: PPUSH
61695: LD_VAR 0 1
61699: PPUSH
61700: LD_EXP 142
61704: PUSH
61705: LD_VAR 0 1
61709: ARRAY
61710: PPUSH
61711: LD_VAR 0 2
61715: PPUSH
61716: CALL_OW 3
61720: PPUSH
61721: CALL_OW 1
61725: ST_TO_ADDR
// end ; end ;
61726: GO 61477
61728: POP
61729: POP
// end ;
61730: GO 61395
61732: POP
61733: POP
// end ;
61734: PPOPN 4
61736: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
61737: LD_INT 0
61739: PPUSH
61740: PPUSH
// result := false ;
61741: LD_ADDR_VAR 0 4
61745: PUSH
61746: LD_INT 0
61748: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
61749: LD_VAR 0 1
61753: PPUSH
61754: CALL_OW 264
61758: PUSH
61759: LD_INT 81
61761: EQUAL
61762: NOT
61763: IFFALSE 61767
// exit ;
61765: GO 62007
// index := GetElementIndex ( minersList , unit ) ;
61767: LD_ADDR_VAR 0 5
61771: PUSH
61772: LD_EXP 141
61776: PPUSH
61777: LD_VAR 0 1
61781: PPUSH
61782: CALL 68140 0 2
61786: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
61787: LD_EXP 142
61791: PUSH
61792: LD_VAR 0 5
61796: ARRAY
61797: PUSH
61798: LD_EXP 143
61802: GREATEREQUAL
61803: IFFALSE 61807
// exit ;
61805: GO 62007
// ComMoveXY ( unit , x , y ) ;
61807: LD_VAR 0 1
61811: PPUSH
61812: LD_VAR 0 2
61816: PPUSH
61817: LD_VAR 0 3
61821: PPUSH
61822: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
61826: LD_INT 35
61828: PPUSH
61829: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
61833: LD_VAR 0 1
61837: PPUSH
61838: LD_VAR 0 2
61842: PPUSH
61843: LD_VAR 0 3
61847: PPUSH
61848: CALL 99403 0 3
61852: NOT
61853: PUSH
61854: LD_VAR 0 1
61858: PPUSH
61859: CALL_OW 314
61863: AND
61864: IFFALSE 61868
// exit ;
61866: GO 62007
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
61868: LD_VAR 0 2
61872: PPUSH
61873: LD_VAR 0 3
61877: PPUSH
61878: CALL_OW 428
61882: PUSH
61883: LD_VAR 0 1
61887: EQUAL
61888: PUSH
61889: LD_VAR 0 1
61893: PPUSH
61894: CALL_OW 314
61898: NOT
61899: AND
61900: IFFALSE 61826
// PlaySoundXY ( x , y , PlantMine ) ;
61902: LD_VAR 0 2
61906: PPUSH
61907: LD_VAR 0 3
61911: PPUSH
61912: LD_STRING PlantMine
61914: PPUSH
61915: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
61919: LD_VAR 0 2
61923: PPUSH
61924: LD_VAR 0 3
61928: PPUSH
61929: LD_VAR 0 1
61933: PPUSH
61934: CALL_OW 255
61938: PPUSH
61939: LD_INT 0
61941: PPUSH
61942: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
61946: LD_ADDR_EXP 142
61950: PUSH
61951: LD_EXP 142
61955: PPUSH
61956: LD_VAR 0 5
61960: PUSH
61961: LD_EXP 142
61965: PUSH
61966: LD_VAR 0 5
61970: ARRAY
61971: PUSH
61972: LD_INT 1
61974: PLUS
61975: PUSH
61976: EMPTY
61977: LIST
61978: LIST
61979: PPUSH
61980: LD_VAR 0 2
61984: PUSH
61985: LD_VAR 0 3
61989: PUSH
61990: EMPTY
61991: LIST
61992: LIST
61993: PPUSH
61994: CALL 68355 0 3
61998: ST_TO_ADDR
// result := true ;
61999: LD_ADDR_VAR 0 4
62003: PUSH
62004: LD_INT 1
62006: ST_TO_ADDR
// end ;
62007: LD_VAR 0 4
62011: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
62012: LD_INT 0
62014: PPUSH
62015: PPUSH
62016: PPUSH
// if not unit in minersList then
62017: LD_VAR 0 1
62021: PUSH
62022: LD_EXP 141
62026: IN
62027: NOT
62028: IFFALSE 62032
// exit ;
62030: GO 62424
// index := GetElementIndex ( minersList , unit ) ;
62032: LD_ADDR_VAR 0 6
62036: PUSH
62037: LD_EXP 141
62041: PPUSH
62042: LD_VAR 0 1
62046: PPUSH
62047: CALL 68140 0 2
62051: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
62052: LD_ADDR_VAR 0 5
62056: PUSH
62057: DOUBLE
62058: LD_EXP 142
62062: PUSH
62063: LD_VAR 0 6
62067: ARRAY
62068: INC
62069: ST_TO_ADDR
62070: LD_INT 1
62072: PUSH
62073: FOR_DOWNTO
62074: IFFALSE 62235
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
62076: LD_EXP 142
62080: PUSH
62081: LD_VAR 0 6
62085: ARRAY
62086: PUSH
62087: LD_VAR 0 5
62091: ARRAY
62092: PUSH
62093: LD_INT 1
62095: ARRAY
62096: PUSH
62097: LD_VAR 0 2
62101: EQUAL
62102: PUSH
62103: LD_EXP 142
62107: PUSH
62108: LD_VAR 0 6
62112: ARRAY
62113: PUSH
62114: LD_VAR 0 5
62118: ARRAY
62119: PUSH
62120: LD_INT 2
62122: ARRAY
62123: PUSH
62124: LD_VAR 0 3
62128: EQUAL
62129: AND
62130: IFFALSE 62233
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62132: LD_EXP 142
62136: PUSH
62137: LD_VAR 0 6
62141: ARRAY
62142: PUSH
62143: LD_VAR 0 5
62147: ARRAY
62148: PUSH
62149: LD_INT 1
62151: ARRAY
62152: PPUSH
62153: LD_EXP 142
62157: PUSH
62158: LD_VAR 0 6
62162: ARRAY
62163: PUSH
62164: LD_VAR 0 5
62168: ARRAY
62169: PUSH
62170: LD_INT 2
62172: ARRAY
62173: PPUSH
62174: LD_VAR 0 1
62178: PPUSH
62179: CALL_OW 255
62183: PPUSH
62184: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62188: LD_ADDR_EXP 142
62192: PUSH
62193: LD_EXP 142
62197: PPUSH
62198: LD_VAR 0 6
62202: PPUSH
62203: LD_EXP 142
62207: PUSH
62208: LD_VAR 0 6
62212: ARRAY
62213: PPUSH
62214: LD_VAR 0 5
62218: PPUSH
62219: CALL_OW 3
62223: PPUSH
62224: CALL_OW 1
62228: ST_TO_ADDR
// exit ;
62229: POP
62230: POP
62231: GO 62424
// end ; end ;
62233: GO 62073
62235: POP
62236: POP
// for i := minerMinesList [ index ] downto 1 do
62237: LD_ADDR_VAR 0 5
62241: PUSH
62242: DOUBLE
62243: LD_EXP 142
62247: PUSH
62248: LD_VAR 0 6
62252: ARRAY
62253: INC
62254: ST_TO_ADDR
62255: LD_INT 1
62257: PUSH
62258: FOR_DOWNTO
62259: IFFALSE 62422
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
62261: LD_EXP 142
62265: PUSH
62266: LD_VAR 0 6
62270: ARRAY
62271: PUSH
62272: LD_VAR 0 5
62276: ARRAY
62277: PUSH
62278: LD_INT 1
62280: ARRAY
62281: PPUSH
62282: LD_EXP 142
62286: PUSH
62287: LD_VAR 0 6
62291: ARRAY
62292: PUSH
62293: LD_VAR 0 5
62297: ARRAY
62298: PUSH
62299: LD_INT 2
62301: ARRAY
62302: PPUSH
62303: LD_VAR 0 2
62307: PPUSH
62308: LD_VAR 0 3
62312: PPUSH
62313: CALL_OW 298
62317: PUSH
62318: LD_INT 6
62320: LESS
62321: IFFALSE 62420
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
62323: LD_EXP 142
62327: PUSH
62328: LD_VAR 0 6
62332: ARRAY
62333: PUSH
62334: LD_VAR 0 5
62338: ARRAY
62339: PUSH
62340: LD_INT 1
62342: ARRAY
62343: PPUSH
62344: LD_EXP 142
62348: PUSH
62349: LD_VAR 0 6
62353: ARRAY
62354: PUSH
62355: LD_VAR 0 5
62359: ARRAY
62360: PUSH
62361: LD_INT 2
62363: ARRAY
62364: PPUSH
62365: LD_VAR 0 1
62369: PPUSH
62370: CALL_OW 255
62374: PPUSH
62375: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
62379: LD_ADDR_EXP 142
62383: PUSH
62384: LD_EXP 142
62388: PPUSH
62389: LD_VAR 0 6
62393: PPUSH
62394: LD_EXP 142
62398: PUSH
62399: LD_VAR 0 6
62403: ARRAY
62404: PPUSH
62405: LD_VAR 0 5
62409: PPUSH
62410: CALL_OW 3
62414: PPUSH
62415: CALL_OW 1
62419: ST_TO_ADDR
// end ; end ;
62420: GO 62258
62422: POP
62423: POP
// end ;
62424: LD_VAR 0 4
62428: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
62429: LD_INT 0
62431: PPUSH
62432: PPUSH
62433: PPUSH
62434: PPUSH
62435: PPUSH
62436: PPUSH
62437: PPUSH
62438: PPUSH
62439: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
62440: LD_VAR 0 1
62444: PPUSH
62445: CALL_OW 264
62449: PUSH
62450: LD_INT 81
62452: EQUAL
62453: NOT
62454: PUSH
62455: LD_VAR 0 1
62459: PUSH
62460: LD_EXP 141
62464: IN
62465: NOT
62466: OR
62467: IFFALSE 62471
// exit ;
62469: GO 62793
// index := GetElementIndex ( minersList , unit ) ;
62471: LD_ADDR_VAR 0 6
62475: PUSH
62476: LD_EXP 141
62480: PPUSH
62481: LD_VAR 0 1
62485: PPUSH
62486: CALL 68140 0 2
62490: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
62491: LD_ADDR_VAR 0 8
62495: PUSH
62496: LD_EXP 143
62500: PUSH
62501: LD_EXP 142
62505: PUSH
62506: LD_VAR 0 6
62510: ARRAY
62511: MINUS
62512: ST_TO_ADDR
// if not minesFreeAmount then
62513: LD_VAR 0 8
62517: NOT
62518: IFFALSE 62522
// exit ;
62520: GO 62793
// tmp := [ ] ;
62522: LD_ADDR_VAR 0 7
62526: PUSH
62527: EMPTY
62528: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
62529: LD_ADDR_VAR 0 5
62533: PUSH
62534: DOUBLE
62535: LD_INT 1
62537: DEC
62538: ST_TO_ADDR
62539: LD_VAR 0 8
62543: PUSH
62544: FOR_TO
62545: IFFALSE 62740
// begin _d := rand ( 0 , 5 ) ;
62547: LD_ADDR_VAR 0 11
62551: PUSH
62552: LD_INT 0
62554: PPUSH
62555: LD_INT 5
62557: PPUSH
62558: CALL_OW 12
62562: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
62563: LD_ADDR_VAR 0 12
62567: PUSH
62568: LD_INT 2
62570: PPUSH
62571: LD_INT 6
62573: PPUSH
62574: CALL_OW 12
62578: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
62579: LD_ADDR_VAR 0 9
62583: PUSH
62584: LD_VAR 0 2
62588: PPUSH
62589: LD_VAR 0 11
62593: PPUSH
62594: LD_VAR 0 12
62598: PPUSH
62599: CALL_OW 272
62603: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
62604: LD_ADDR_VAR 0 10
62608: PUSH
62609: LD_VAR 0 3
62613: PPUSH
62614: LD_VAR 0 11
62618: PPUSH
62619: LD_VAR 0 12
62623: PPUSH
62624: CALL_OW 273
62628: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
62629: LD_VAR 0 9
62633: PPUSH
62634: LD_VAR 0 10
62638: PPUSH
62639: CALL_OW 488
62643: PUSH
62644: LD_VAR 0 9
62648: PUSH
62649: LD_VAR 0 10
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PUSH
62658: LD_VAR 0 7
62662: IN
62663: NOT
62664: AND
62665: PUSH
62666: LD_VAR 0 9
62670: PPUSH
62671: LD_VAR 0 10
62675: PPUSH
62676: CALL_OW 458
62680: NOT
62681: AND
62682: IFFALSE 62724
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
62684: LD_ADDR_VAR 0 7
62688: PUSH
62689: LD_VAR 0 7
62693: PPUSH
62694: LD_VAR 0 7
62698: PUSH
62699: LD_INT 1
62701: PLUS
62702: PPUSH
62703: LD_VAR 0 9
62707: PUSH
62708: LD_VAR 0 10
62712: PUSH
62713: EMPTY
62714: LIST
62715: LIST
62716: PPUSH
62717: CALL_OW 1
62721: ST_TO_ADDR
62722: GO 62738
// i := i - 1 ;
62724: LD_ADDR_VAR 0 5
62728: PUSH
62729: LD_VAR 0 5
62733: PUSH
62734: LD_INT 1
62736: MINUS
62737: ST_TO_ADDR
// end ;
62738: GO 62544
62740: POP
62741: POP
// for i in tmp do
62742: LD_ADDR_VAR 0 5
62746: PUSH
62747: LD_VAR 0 7
62751: PUSH
62752: FOR_IN
62753: IFFALSE 62791
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
62755: LD_VAR 0 1
62759: PPUSH
62760: LD_VAR 0 5
62764: PUSH
62765: LD_INT 1
62767: ARRAY
62768: PPUSH
62769: LD_VAR 0 5
62773: PUSH
62774: LD_INT 2
62776: ARRAY
62777: PPUSH
62778: CALL 61737 0 3
62782: NOT
62783: IFFALSE 62789
// exit ;
62785: POP
62786: POP
62787: GO 62793
62789: GO 62752
62791: POP
62792: POP
// end ;
62793: LD_VAR 0 4
62797: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
62798: LD_INT 0
62800: PPUSH
62801: PPUSH
62802: PPUSH
62803: PPUSH
62804: PPUSH
62805: PPUSH
62806: PPUSH
// if not GetClass ( unit ) = class_sniper then
62807: LD_VAR 0 1
62811: PPUSH
62812: CALL_OW 257
62816: PUSH
62817: LD_INT 5
62819: EQUAL
62820: NOT
62821: IFFALSE 62825
// exit ;
62823: GO 63213
// dist := 8 ;
62825: LD_ADDR_VAR 0 5
62829: PUSH
62830: LD_INT 8
62832: ST_TO_ADDR
// viewRange := 12 ;
62833: LD_ADDR_VAR 0 7
62837: PUSH
62838: LD_INT 12
62840: ST_TO_ADDR
// side := GetSide ( unit ) ;
62841: LD_ADDR_VAR 0 6
62845: PUSH
62846: LD_VAR 0 1
62850: PPUSH
62851: CALL_OW 255
62855: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
62856: LD_INT 61
62858: PPUSH
62859: LD_VAR 0 6
62863: PPUSH
62864: CALL_OW 321
62868: PUSH
62869: LD_INT 2
62871: EQUAL
62872: IFFALSE 62882
// viewRange := 16 ;
62874: LD_ADDR_VAR 0 7
62878: PUSH
62879: LD_INT 16
62881: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
62882: LD_VAR 0 1
62886: PPUSH
62887: LD_VAR 0 2
62891: PPUSH
62892: LD_VAR 0 3
62896: PPUSH
62897: CALL_OW 297
62901: PUSH
62902: LD_VAR 0 5
62906: GREATER
62907: IFFALSE 62986
// begin ComMoveXY ( unit , x , y ) ;
62909: LD_VAR 0 1
62913: PPUSH
62914: LD_VAR 0 2
62918: PPUSH
62919: LD_VAR 0 3
62923: PPUSH
62924: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
62928: LD_INT 35
62930: PPUSH
62931: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
62935: LD_VAR 0 1
62939: PPUSH
62940: LD_VAR 0 2
62944: PPUSH
62945: LD_VAR 0 3
62949: PPUSH
62950: CALL 99403 0 3
62954: NOT
62955: IFFALSE 62959
// exit ;
62957: GO 63213
// until GetDistUnitXY ( unit , x , y ) < dist ;
62959: LD_VAR 0 1
62963: PPUSH
62964: LD_VAR 0 2
62968: PPUSH
62969: LD_VAR 0 3
62973: PPUSH
62974: CALL_OW 297
62978: PUSH
62979: LD_VAR 0 5
62983: LESS
62984: IFFALSE 62928
// end ; ComTurnXY ( unit , x , y ) ;
62986: LD_VAR 0 1
62990: PPUSH
62991: LD_VAR 0 2
62995: PPUSH
62996: LD_VAR 0 3
63000: PPUSH
63001: CALL_OW 118
// wait ( 5 ) ;
63005: LD_INT 5
63007: PPUSH
63008: CALL_OW 67
// _d := GetDir ( unit ) ;
63012: LD_ADDR_VAR 0 10
63016: PUSH
63017: LD_VAR 0 1
63021: PPUSH
63022: CALL_OW 254
63026: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
63027: LD_ADDR_VAR 0 8
63031: PUSH
63032: LD_VAR 0 1
63036: PPUSH
63037: CALL_OW 250
63041: PPUSH
63042: LD_VAR 0 10
63046: PPUSH
63047: LD_VAR 0 5
63051: PPUSH
63052: CALL_OW 272
63056: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
63057: LD_ADDR_VAR 0 9
63061: PUSH
63062: LD_VAR 0 1
63066: PPUSH
63067: CALL_OW 251
63071: PPUSH
63072: LD_VAR 0 10
63076: PPUSH
63077: LD_VAR 0 5
63081: PPUSH
63082: CALL_OW 273
63086: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
63087: LD_VAR 0 8
63091: PPUSH
63092: LD_VAR 0 9
63096: PPUSH
63097: CALL_OW 488
63101: NOT
63102: IFFALSE 63106
// exit ;
63104: GO 63213
// ComAnimCustom ( unit , 1 ) ;
63106: LD_VAR 0 1
63110: PPUSH
63111: LD_INT 1
63113: PPUSH
63114: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
63118: LD_VAR 0 8
63122: PPUSH
63123: LD_VAR 0 9
63127: PPUSH
63128: LD_VAR 0 6
63132: PPUSH
63133: LD_VAR 0 7
63137: PPUSH
63138: CALL_OW 330
// repeat wait ( 1 ) ;
63142: LD_INT 1
63144: PPUSH
63145: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
63149: LD_VAR 0 1
63153: PPUSH
63154: CALL_OW 316
63158: PUSH
63159: LD_VAR 0 1
63163: PPUSH
63164: CALL_OW 314
63168: OR
63169: PUSH
63170: LD_VAR 0 1
63174: PPUSH
63175: CALL_OW 302
63179: NOT
63180: OR
63181: PUSH
63182: LD_VAR 0 1
63186: PPUSH
63187: CALL_OW 301
63191: OR
63192: IFFALSE 63142
// RemoveSeeing ( _x , _y , side ) ;
63194: LD_VAR 0 8
63198: PPUSH
63199: LD_VAR 0 9
63203: PPUSH
63204: LD_VAR 0 6
63208: PPUSH
63209: CALL_OW 331
// end ; end_of_file
63213: LD_VAR 0 4
63217: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63218: LD_INT 0
63220: PPUSH
63221: PPUSH
// if exist_mode then
63222: LD_VAR 0 2
63226: IFFALSE 63251
// unit := CreateCharacter ( prefix & ident ) else
63228: LD_ADDR_VAR 0 5
63232: PUSH
63233: LD_VAR 0 3
63237: PUSH
63238: LD_VAR 0 1
63242: STR
63243: PPUSH
63244: CALL_OW 34
63248: ST_TO_ADDR
63249: GO 63266
// unit := NewCharacter ( ident ) ;
63251: LD_ADDR_VAR 0 5
63255: PUSH
63256: LD_VAR 0 1
63260: PPUSH
63261: CALL_OW 25
63265: ST_TO_ADDR
// result := unit ;
63266: LD_ADDR_VAR 0 4
63270: PUSH
63271: LD_VAR 0 5
63275: ST_TO_ADDR
// end ;
63276: LD_VAR 0 4
63280: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63281: LD_INT 0
63283: PPUSH
63284: PPUSH
// if not side or not nation then
63285: LD_VAR 0 1
63289: NOT
63290: PUSH
63291: LD_VAR 0 2
63295: NOT
63296: OR
63297: IFFALSE 63301
// exit ;
63299: GO 64069
// case nation of nation_american :
63301: LD_VAR 0 2
63305: PUSH
63306: LD_INT 1
63308: DOUBLE
63309: EQUAL
63310: IFTRUE 63314
63312: GO 63528
63314: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
63315: LD_ADDR_VAR 0 4
63319: PUSH
63320: LD_INT 35
63322: PUSH
63323: LD_INT 45
63325: PUSH
63326: LD_INT 46
63328: PUSH
63329: LD_INT 47
63331: PUSH
63332: LD_INT 82
63334: PUSH
63335: LD_INT 83
63337: PUSH
63338: LD_INT 84
63340: PUSH
63341: LD_INT 85
63343: PUSH
63344: LD_INT 86
63346: PUSH
63347: LD_INT 1
63349: PUSH
63350: LD_INT 2
63352: PUSH
63353: LD_INT 6
63355: PUSH
63356: LD_INT 15
63358: PUSH
63359: LD_INT 16
63361: PUSH
63362: LD_INT 7
63364: PUSH
63365: LD_INT 12
63367: PUSH
63368: LD_INT 13
63370: PUSH
63371: LD_INT 10
63373: PUSH
63374: LD_INT 14
63376: PUSH
63377: LD_INT 20
63379: PUSH
63380: LD_INT 21
63382: PUSH
63383: LD_INT 22
63385: PUSH
63386: LD_INT 25
63388: PUSH
63389: LD_INT 32
63391: PUSH
63392: LD_INT 27
63394: PUSH
63395: LD_INT 36
63397: PUSH
63398: LD_INT 69
63400: PUSH
63401: LD_INT 39
63403: PUSH
63404: LD_INT 34
63406: PUSH
63407: LD_INT 40
63409: PUSH
63410: LD_INT 48
63412: PUSH
63413: LD_INT 49
63415: PUSH
63416: LD_INT 50
63418: PUSH
63419: LD_INT 51
63421: PUSH
63422: LD_INT 52
63424: PUSH
63425: LD_INT 53
63427: PUSH
63428: LD_INT 54
63430: PUSH
63431: LD_INT 55
63433: PUSH
63434: LD_INT 56
63436: PUSH
63437: LD_INT 57
63439: PUSH
63440: LD_INT 58
63442: PUSH
63443: LD_INT 59
63445: PUSH
63446: LD_INT 60
63448: PUSH
63449: LD_INT 61
63451: PUSH
63452: LD_INT 62
63454: PUSH
63455: LD_INT 80
63457: PUSH
63458: LD_INT 82
63460: PUSH
63461: LD_INT 83
63463: PUSH
63464: LD_INT 84
63466: PUSH
63467: LD_INT 85
63469: PUSH
63470: LD_INT 86
63472: PUSH
63473: EMPTY
63474: LIST
63475: LIST
63476: LIST
63477: LIST
63478: LIST
63479: LIST
63480: LIST
63481: LIST
63482: LIST
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: LIST
63491: LIST
63492: LIST
63493: LIST
63494: LIST
63495: LIST
63496: LIST
63497: LIST
63498: LIST
63499: LIST
63500: LIST
63501: LIST
63502: LIST
63503: LIST
63504: LIST
63505: LIST
63506: LIST
63507: LIST
63508: LIST
63509: LIST
63510: LIST
63511: LIST
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: LIST
63518: LIST
63519: LIST
63520: LIST
63521: LIST
63522: LIST
63523: LIST
63524: LIST
63525: ST_TO_ADDR
63526: GO 63993
63528: LD_INT 2
63530: DOUBLE
63531: EQUAL
63532: IFTRUE 63536
63534: GO 63762
63536: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
63537: LD_ADDR_VAR 0 4
63541: PUSH
63542: LD_INT 35
63544: PUSH
63545: LD_INT 45
63547: PUSH
63548: LD_INT 46
63550: PUSH
63551: LD_INT 47
63553: PUSH
63554: LD_INT 82
63556: PUSH
63557: LD_INT 83
63559: PUSH
63560: LD_INT 84
63562: PUSH
63563: LD_INT 85
63565: PUSH
63566: LD_INT 87
63568: PUSH
63569: LD_INT 70
63571: PUSH
63572: LD_INT 1
63574: PUSH
63575: LD_INT 11
63577: PUSH
63578: LD_INT 3
63580: PUSH
63581: LD_INT 4
63583: PUSH
63584: LD_INT 5
63586: PUSH
63587: LD_INT 6
63589: PUSH
63590: LD_INT 15
63592: PUSH
63593: LD_INT 18
63595: PUSH
63596: LD_INT 7
63598: PUSH
63599: LD_INT 17
63601: PUSH
63602: LD_INT 8
63604: PUSH
63605: LD_INT 20
63607: PUSH
63608: LD_INT 21
63610: PUSH
63611: LD_INT 22
63613: PUSH
63614: LD_INT 72
63616: PUSH
63617: LD_INT 26
63619: PUSH
63620: LD_INT 69
63622: PUSH
63623: LD_INT 39
63625: PUSH
63626: LD_INT 40
63628: PUSH
63629: LD_INT 41
63631: PUSH
63632: LD_INT 42
63634: PUSH
63635: LD_INT 43
63637: PUSH
63638: LD_INT 48
63640: PUSH
63641: LD_INT 49
63643: PUSH
63644: LD_INT 50
63646: PUSH
63647: LD_INT 51
63649: PUSH
63650: LD_INT 52
63652: PUSH
63653: LD_INT 53
63655: PUSH
63656: LD_INT 54
63658: PUSH
63659: LD_INT 55
63661: PUSH
63662: LD_INT 56
63664: PUSH
63665: LD_INT 60
63667: PUSH
63668: LD_INT 61
63670: PUSH
63671: LD_INT 62
63673: PUSH
63674: LD_INT 66
63676: PUSH
63677: LD_INT 67
63679: PUSH
63680: LD_INT 68
63682: PUSH
63683: LD_INT 81
63685: PUSH
63686: LD_INT 82
63688: PUSH
63689: LD_INT 83
63691: PUSH
63692: LD_INT 84
63694: PUSH
63695: LD_INT 85
63697: PUSH
63698: LD_INT 87
63700: PUSH
63701: LD_INT 88
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: LIST
63708: LIST
63709: LIST
63710: LIST
63711: LIST
63712: LIST
63713: LIST
63714: LIST
63715: LIST
63716: LIST
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: LIST
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: LIST
63727: LIST
63728: LIST
63729: LIST
63730: LIST
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: LIST
63742: LIST
63743: LIST
63744: LIST
63745: LIST
63746: LIST
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: LIST
63752: LIST
63753: LIST
63754: LIST
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: ST_TO_ADDR
63760: GO 63993
63762: LD_INT 3
63764: DOUBLE
63765: EQUAL
63766: IFTRUE 63770
63768: GO 63992
63770: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
63771: LD_ADDR_VAR 0 4
63775: PUSH
63776: LD_INT 46
63778: PUSH
63779: LD_INT 47
63781: PUSH
63782: LD_INT 1
63784: PUSH
63785: LD_INT 2
63787: PUSH
63788: LD_INT 82
63790: PUSH
63791: LD_INT 83
63793: PUSH
63794: LD_INT 84
63796: PUSH
63797: LD_INT 85
63799: PUSH
63800: LD_INT 86
63802: PUSH
63803: LD_INT 11
63805: PUSH
63806: LD_INT 9
63808: PUSH
63809: LD_INT 20
63811: PUSH
63812: LD_INT 19
63814: PUSH
63815: LD_INT 21
63817: PUSH
63818: LD_INT 24
63820: PUSH
63821: LD_INT 22
63823: PUSH
63824: LD_INT 25
63826: PUSH
63827: LD_INT 28
63829: PUSH
63830: LD_INT 29
63832: PUSH
63833: LD_INT 30
63835: PUSH
63836: LD_INT 31
63838: PUSH
63839: LD_INT 37
63841: PUSH
63842: LD_INT 38
63844: PUSH
63845: LD_INT 32
63847: PUSH
63848: LD_INT 27
63850: PUSH
63851: LD_INT 33
63853: PUSH
63854: LD_INT 69
63856: PUSH
63857: LD_INT 39
63859: PUSH
63860: LD_INT 34
63862: PUSH
63863: LD_INT 40
63865: PUSH
63866: LD_INT 71
63868: PUSH
63869: LD_INT 23
63871: PUSH
63872: LD_INT 44
63874: PUSH
63875: LD_INT 48
63877: PUSH
63878: LD_INT 49
63880: PUSH
63881: LD_INT 50
63883: PUSH
63884: LD_INT 51
63886: PUSH
63887: LD_INT 52
63889: PUSH
63890: LD_INT 53
63892: PUSH
63893: LD_INT 54
63895: PUSH
63896: LD_INT 55
63898: PUSH
63899: LD_INT 56
63901: PUSH
63902: LD_INT 57
63904: PUSH
63905: LD_INT 58
63907: PUSH
63908: LD_INT 59
63910: PUSH
63911: LD_INT 63
63913: PUSH
63914: LD_INT 64
63916: PUSH
63917: LD_INT 65
63919: PUSH
63920: LD_INT 82
63922: PUSH
63923: LD_INT 83
63925: PUSH
63926: LD_INT 84
63928: PUSH
63929: LD_INT 85
63931: PUSH
63932: LD_INT 86
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: LIST
63961: LIST
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: LIST
63970: LIST
63971: LIST
63972: LIST
63973: LIST
63974: LIST
63975: LIST
63976: LIST
63977: LIST
63978: LIST
63979: LIST
63980: LIST
63981: LIST
63982: LIST
63983: LIST
63984: LIST
63985: LIST
63986: LIST
63987: LIST
63988: LIST
63989: ST_TO_ADDR
63990: GO 63993
63992: POP
// if state > - 1 and state < 3 then
63993: LD_VAR 0 3
63997: PUSH
63998: LD_INT 1
64000: NEG
64001: GREATER
64002: PUSH
64003: LD_VAR 0 3
64007: PUSH
64008: LD_INT 3
64010: LESS
64011: AND
64012: IFFALSE 64069
// for i in result do
64014: LD_ADDR_VAR 0 5
64018: PUSH
64019: LD_VAR 0 4
64023: PUSH
64024: FOR_IN
64025: IFFALSE 64067
// if GetTech ( i , side ) <> state then
64027: LD_VAR 0 5
64031: PPUSH
64032: LD_VAR 0 1
64036: PPUSH
64037: CALL_OW 321
64041: PUSH
64042: LD_VAR 0 3
64046: NONEQUAL
64047: IFFALSE 64065
// result := result diff i ;
64049: LD_ADDR_VAR 0 4
64053: PUSH
64054: LD_VAR 0 4
64058: PUSH
64059: LD_VAR 0 5
64063: DIFF
64064: ST_TO_ADDR
64065: GO 64024
64067: POP
64068: POP
// end ;
64069: LD_VAR 0 4
64073: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64074: LD_INT 0
64076: PPUSH
64077: PPUSH
64078: PPUSH
// result := true ;
64079: LD_ADDR_VAR 0 3
64083: PUSH
64084: LD_INT 1
64086: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64087: LD_ADDR_VAR 0 5
64091: PUSH
64092: LD_VAR 0 2
64096: PPUSH
64097: CALL_OW 480
64101: ST_TO_ADDR
// if not tmp then
64102: LD_VAR 0 5
64106: NOT
64107: IFFALSE 64111
// exit ;
64109: GO 64160
// for i in tmp do
64111: LD_ADDR_VAR 0 4
64115: PUSH
64116: LD_VAR 0 5
64120: PUSH
64121: FOR_IN
64122: IFFALSE 64158
// if GetTech ( i , side ) <> state_researched then
64124: LD_VAR 0 4
64128: PPUSH
64129: LD_VAR 0 1
64133: PPUSH
64134: CALL_OW 321
64138: PUSH
64139: LD_INT 2
64141: NONEQUAL
64142: IFFALSE 64156
// begin result := false ;
64144: LD_ADDR_VAR 0 3
64148: PUSH
64149: LD_INT 0
64151: ST_TO_ADDR
// exit ;
64152: POP
64153: POP
64154: GO 64160
// end ;
64156: GO 64121
64158: POP
64159: POP
// end ;
64160: LD_VAR 0 3
64164: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64165: LD_INT 0
64167: PPUSH
64168: PPUSH
64169: PPUSH
64170: PPUSH
64171: PPUSH
64172: PPUSH
64173: PPUSH
64174: PPUSH
64175: PPUSH
64176: PPUSH
64177: PPUSH
64178: PPUSH
64179: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64180: LD_VAR 0 1
64184: NOT
64185: PUSH
64186: LD_VAR 0 1
64190: PPUSH
64191: CALL_OW 257
64195: PUSH
64196: LD_INT 9
64198: NONEQUAL
64199: OR
64200: IFFALSE 64204
// exit ;
64202: GO 64777
// side := GetSide ( unit ) ;
64204: LD_ADDR_VAR 0 9
64208: PUSH
64209: LD_VAR 0 1
64213: PPUSH
64214: CALL_OW 255
64218: ST_TO_ADDR
// tech_space := tech_spacanom ;
64219: LD_ADDR_VAR 0 12
64223: PUSH
64224: LD_INT 29
64226: ST_TO_ADDR
// tech_time := tech_taurad ;
64227: LD_ADDR_VAR 0 13
64231: PUSH
64232: LD_INT 28
64234: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64235: LD_ADDR_VAR 0 11
64239: PUSH
64240: LD_VAR 0 1
64244: PPUSH
64245: CALL_OW 310
64249: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64250: LD_VAR 0 11
64254: PPUSH
64255: CALL_OW 247
64259: PUSH
64260: LD_INT 2
64262: EQUAL
64263: IFFALSE 64267
// exit ;
64265: GO 64777
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64267: LD_ADDR_VAR 0 8
64271: PUSH
64272: LD_INT 81
64274: PUSH
64275: LD_VAR 0 9
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 3
64286: PUSH
64287: LD_INT 21
64289: PUSH
64290: LD_INT 3
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: EMPTY
64298: LIST
64299: LIST
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: PPUSH
64305: CALL_OW 69
64309: ST_TO_ADDR
// if not tmp then
64310: LD_VAR 0 8
64314: NOT
64315: IFFALSE 64319
// exit ;
64317: GO 64777
// if in_unit then
64319: LD_VAR 0 11
64323: IFFALSE 64347
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64325: LD_ADDR_VAR 0 10
64329: PUSH
64330: LD_VAR 0 8
64334: PPUSH
64335: LD_VAR 0 11
64339: PPUSH
64340: CALL_OW 74
64344: ST_TO_ADDR
64345: GO 64367
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64347: LD_ADDR_VAR 0 10
64351: PUSH
64352: LD_VAR 0 8
64356: PPUSH
64357: LD_VAR 0 1
64361: PPUSH
64362: CALL_OW 74
64366: ST_TO_ADDR
// if not enemy then
64367: LD_VAR 0 10
64371: NOT
64372: IFFALSE 64376
// exit ;
64374: GO 64777
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64376: LD_VAR 0 11
64380: PUSH
64381: LD_VAR 0 11
64385: PPUSH
64386: LD_VAR 0 10
64390: PPUSH
64391: CALL_OW 296
64395: PUSH
64396: LD_INT 13
64398: GREATER
64399: AND
64400: PUSH
64401: LD_VAR 0 1
64405: PPUSH
64406: LD_VAR 0 10
64410: PPUSH
64411: CALL_OW 296
64415: PUSH
64416: LD_INT 12
64418: GREATER
64419: OR
64420: IFFALSE 64424
// exit ;
64422: GO 64777
// missile := [ 1 ] ;
64424: LD_ADDR_VAR 0 14
64428: PUSH
64429: LD_INT 1
64431: PUSH
64432: EMPTY
64433: LIST
64434: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64435: LD_VAR 0 9
64439: PPUSH
64440: LD_VAR 0 12
64444: PPUSH
64445: CALL_OW 325
64449: IFFALSE 64478
// missile := Replace ( missile , missile + 1 , 2 ) ;
64451: LD_ADDR_VAR 0 14
64455: PUSH
64456: LD_VAR 0 14
64460: PPUSH
64461: LD_VAR 0 14
64465: PUSH
64466: LD_INT 1
64468: PLUS
64469: PPUSH
64470: LD_INT 2
64472: PPUSH
64473: CALL_OW 1
64477: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64478: LD_VAR 0 9
64482: PPUSH
64483: LD_VAR 0 13
64487: PPUSH
64488: CALL_OW 325
64492: PUSH
64493: LD_VAR 0 10
64497: PPUSH
64498: CALL_OW 255
64502: PPUSH
64503: LD_VAR 0 13
64507: PPUSH
64508: CALL_OW 325
64512: NOT
64513: AND
64514: IFFALSE 64543
// missile := Replace ( missile , missile + 1 , 3 ) ;
64516: LD_ADDR_VAR 0 14
64520: PUSH
64521: LD_VAR 0 14
64525: PPUSH
64526: LD_VAR 0 14
64530: PUSH
64531: LD_INT 1
64533: PLUS
64534: PPUSH
64535: LD_INT 3
64537: PPUSH
64538: CALL_OW 1
64542: ST_TO_ADDR
// if missile < 2 then
64543: LD_VAR 0 14
64547: PUSH
64548: LD_INT 2
64550: LESS
64551: IFFALSE 64555
// exit ;
64553: GO 64777
// x := GetX ( enemy ) ;
64555: LD_ADDR_VAR 0 4
64559: PUSH
64560: LD_VAR 0 10
64564: PPUSH
64565: CALL_OW 250
64569: ST_TO_ADDR
// y := GetY ( enemy ) ;
64570: LD_ADDR_VAR 0 5
64574: PUSH
64575: LD_VAR 0 10
64579: PPUSH
64580: CALL_OW 251
64584: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64585: LD_ADDR_VAR 0 6
64589: PUSH
64590: LD_VAR 0 4
64594: PUSH
64595: LD_INT 1
64597: NEG
64598: PPUSH
64599: LD_INT 1
64601: PPUSH
64602: CALL_OW 12
64606: PLUS
64607: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64608: LD_ADDR_VAR 0 7
64612: PUSH
64613: LD_VAR 0 5
64617: PUSH
64618: LD_INT 1
64620: NEG
64621: PPUSH
64622: LD_INT 1
64624: PPUSH
64625: CALL_OW 12
64629: PLUS
64630: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64631: LD_VAR 0 6
64635: PPUSH
64636: LD_VAR 0 7
64640: PPUSH
64641: CALL_OW 488
64645: NOT
64646: IFFALSE 64668
// begin _x := x ;
64648: LD_ADDR_VAR 0 6
64652: PUSH
64653: LD_VAR 0 4
64657: ST_TO_ADDR
// _y := y ;
64658: LD_ADDR_VAR 0 7
64662: PUSH
64663: LD_VAR 0 5
64667: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64668: LD_ADDR_VAR 0 3
64672: PUSH
64673: LD_INT 1
64675: PPUSH
64676: LD_VAR 0 14
64680: PPUSH
64681: CALL_OW 12
64685: ST_TO_ADDR
// case i of 1 :
64686: LD_VAR 0 3
64690: PUSH
64691: LD_INT 1
64693: DOUBLE
64694: EQUAL
64695: IFTRUE 64699
64697: GO 64716
64699: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64700: LD_VAR 0 1
64704: PPUSH
64705: LD_VAR 0 10
64709: PPUSH
64710: CALL_OW 115
64714: GO 64777
64716: LD_INT 2
64718: DOUBLE
64719: EQUAL
64720: IFTRUE 64724
64722: GO 64746
64724: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64725: LD_VAR 0 1
64729: PPUSH
64730: LD_VAR 0 6
64734: PPUSH
64735: LD_VAR 0 7
64739: PPUSH
64740: CALL_OW 153
64744: GO 64777
64746: LD_INT 3
64748: DOUBLE
64749: EQUAL
64750: IFTRUE 64754
64752: GO 64776
64754: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64755: LD_VAR 0 1
64759: PPUSH
64760: LD_VAR 0 6
64764: PPUSH
64765: LD_VAR 0 7
64769: PPUSH
64770: CALL_OW 154
64774: GO 64777
64776: POP
// end ;
64777: LD_VAR 0 2
64781: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64782: LD_INT 0
64784: PPUSH
64785: PPUSH
64786: PPUSH
64787: PPUSH
64788: PPUSH
64789: PPUSH
// if not unit or not building then
64790: LD_VAR 0 1
64794: NOT
64795: PUSH
64796: LD_VAR 0 2
64800: NOT
64801: OR
64802: IFFALSE 64806
// exit ;
64804: GO 64964
// x := GetX ( building ) ;
64806: LD_ADDR_VAR 0 5
64810: PUSH
64811: LD_VAR 0 2
64815: PPUSH
64816: CALL_OW 250
64820: ST_TO_ADDR
// y := GetY ( building ) ;
64821: LD_ADDR_VAR 0 6
64825: PUSH
64826: LD_VAR 0 2
64830: PPUSH
64831: CALL_OW 251
64835: ST_TO_ADDR
// for i = 0 to 5 do
64836: LD_ADDR_VAR 0 4
64840: PUSH
64841: DOUBLE
64842: LD_INT 0
64844: DEC
64845: ST_TO_ADDR
64846: LD_INT 5
64848: PUSH
64849: FOR_TO
64850: IFFALSE 64962
// begin _x := ShiftX ( x , i , 3 ) ;
64852: LD_ADDR_VAR 0 7
64856: PUSH
64857: LD_VAR 0 5
64861: PPUSH
64862: LD_VAR 0 4
64866: PPUSH
64867: LD_INT 3
64869: PPUSH
64870: CALL_OW 272
64874: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64875: LD_ADDR_VAR 0 8
64879: PUSH
64880: LD_VAR 0 6
64884: PPUSH
64885: LD_VAR 0 4
64889: PPUSH
64890: LD_INT 3
64892: PPUSH
64893: CALL_OW 273
64897: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64898: LD_VAR 0 7
64902: PPUSH
64903: LD_VAR 0 8
64907: PPUSH
64908: CALL_OW 488
64912: NOT
64913: IFFALSE 64917
// continue ;
64915: GO 64849
// if HexInfo ( _x , _y ) = 0 then
64917: LD_VAR 0 7
64921: PPUSH
64922: LD_VAR 0 8
64926: PPUSH
64927: CALL_OW 428
64931: PUSH
64932: LD_INT 0
64934: EQUAL
64935: IFFALSE 64960
// begin ComMoveXY ( unit , _x , _y ) ;
64937: LD_VAR 0 1
64941: PPUSH
64942: LD_VAR 0 7
64946: PPUSH
64947: LD_VAR 0 8
64951: PPUSH
64952: CALL_OW 111
// exit ;
64956: POP
64957: POP
64958: GO 64964
// end ; end ;
64960: GO 64849
64962: POP
64963: POP
// end ;
64964: LD_VAR 0 3
64968: RET
// export function ScanBase ( side , base_area ) ; begin
64969: LD_INT 0
64971: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64972: LD_ADDR_VAR 0 3
64976: PUSH
64977: LD_VAR 0 2
64981: PPUSH
64982: LD_INT 81
64984: PUSH
64985: LD_VAR 0 1
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PPUSH
64994: CALL_OW 70
64998: ST_TO_ADDR
// end ;
64999: LD_VAR 0 3
65003: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
65004: LD_INT 0
65006: PPUSH
65007: PPUSH
65008: PPUSH
65009: PPUSH
// result := false ;
65010: LD_ADDR_VAR 0 2
65014: PUSH
65015: LD_INT 0
65017: ST_TO_ADDR
// side := GetSide ( unit ) ;
65018: LD_ADDR_VAR 0 3
65022: PUSH
65023: LD_VAR 0 1
65027: PPUSH
65028: CALL_OW 255
65032: ST_TO_ADDR
// nat := GetNation ( unit ) ;
65033: LD_ADDR_VAR 0 4
65037: PUSH
65038: LD_VAR 0 1
65042: PPUSH
65043: CALL_OW 248
65047: ST_TO_ADDR
// case nat of 1 :
65048: LD_VAR 0 4
65052: PUSH
65053: LD_INT 1
65055: DOUBLE
65056: EQUAL
65057: IFTRUE 65061
65059: GO 65072
65061: POP
// tech := tech_lassight ; 2 :
65062: LD_ADDR_VAR 0 5
65066: PUSH
65067: LD_INT 12
65069: ST_TO_ADDR
65070: GO 65111
65072: LD_INT 2
65074: DOUBLE
65075: EQUAL
65076: IFTRUE 65080
65078: GO 65091
65080: POP
// tech := tech_mortar ; 3 :
65081: LD_ADDR_VAR 0 5
65085: PUSH
65086: LD_INT 41
65088: ST_TO_ADDR
65089: GO 65111
65091: LD_INT 3
65093: DOUBLE
65094: EQUAL
65095: IFTRUE 65099
65097: GO 65110
65099: POP
// tech := tech_bazooka ; end ;
65100: LD_ADDR_VAR 0 5
65104: PUSH
65105: LD_INT 44
65107: ST_TO_ADDR
65108: GO 65111
65110: POP
// if Researched ( side , tech ) then
65111: LD_VAR 0 3
65115: PPUSH
65116: LD_VAR 0 5
65120: PPUSH
65121: CALL_OW 325
65125: IFFALSE 65152
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
65127: LD_ADDR_VAR 0 2
65131: PUSH
65132: LD_INT 5
65134: PUSH
65135: LD_INT 8
65137: PUSH
65138: LD_INT 9
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: LIST
65145: PUSH
65146: LD_VAR 0 4
65150: ARRAY
65151: ST_TO_ADDR
// end ;
65152: LD_VAR 0 2
65156: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
65157: LD_INT 0
65159: PPUSH
65160: PPUSH
65161: PPUSH
// if not mines then
65162: LD_VAR 0 2
65166: NOT
65167: IFFALSE 65171
// exit ;
65169: GO 65315
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65171: LD_ADDR_VAR 0 5
65175: PUSH
65176: LD_INT 81
65178: PUSH
65179: LD_VAR 0 1
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: PUSH
65188: LD_INT 3
65190: PUSH
65191: LD_INT 21
65193: PUSH
65194: LD_INT 3
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PPUSH
65209: CALL_OW 69
65213: ST_TO_ADDR
// for i in mines do
65214: LD_ADDR_VAR 0 4
65218: PUSH
65219: LD_VAR 0 2
65223: PUSH
65224: FOR_IN
65225: IFFALSE 65313
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
65227: LD_VAR 0 4
65231: PUSH
65232: LD_INT 1
65234: ARRAY
65235: PPUSH
65236: LD_VAR 0 4
65240: PUSH
65241: LD_INT 2
65243: ARRAY
65244: PPUSH
65245: CALL_OW 458
65249: NOT
65250: IFFALSE 65254
// continue ;
65252: GO 65224
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
65254: LD_VAR 0 4
65258: PUSH
65259: LD_INT 1
65261: ARRAY
65262: PPUSH
65263: LD_VAR 0 4
65267: PUSH
65268: LD_INT 2
65270: ARRAY
65271: PPUSH
65272: CALL_OW 428
65276: PUSH
65277: LD_VAR 0 5
65281: IN
65282: IFFALSE 65311
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
65284: LD_VAR 0 4
65288: PUSH
65289: LD_INT 1
65291: ARRAY
65292: PPUSH
65293: LD_VAR 0 4
65297: PUSH
65298: LD_INT 2
65300: ARRAY
65301: PPUSH
65302: LD_VAR 0 1
65306: PPUSH
65307: CALL_OW 456
// end ;
65311: GO 65224
65313: POP
65314: POP
// end ;
65315: LD_VAR 0 3
65319: RET
// export function Count ( array ) ; var i ; begin
65320: LD_INT 0
65322: PPUSH
65323: PPUSH
// result := 0 ;
65324: LD_ADDR_VAR 0 2
65328: PUSH
65329: LD_INT 0
65331: ST_TO_ADDR
// for i in array do
65332: LD_ADDR_VAR 0 3
65336: PUSH
65337: LD_VAR 0 1
65341: PUSH
65342: FOR_IN
65343: IFFALSE 65367
// if i then
65345: LD_VAR 0 3
65349: IFFALSE 65365
// result := result + 1 ;
65351: LD_ADDR_VAR 0 2
65355: PUSH
65356: LD_VAR 0 2
65360: PUSH
65361: LD_INT 1
65363: PLUS
65364: ST_TO_ADDR
65365: GO 65342
65367: POP
65368: POP
// end ;
65369: LD_VAR 0 2
65373: RET
// export function IsEmpty ( building ) ; begin
65374: LD_INT 0
65376: PPUSH
// if not building then
65377: LD_VAR 0 1
65381: NOT
65382: IFFALSE 65386
// exit ;
65384: GO 65429
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
65386: LD_ADDR_VAR 0 2
65390: PUSH
65391: LD_VAR 0 1
65395: PUSH
65396: LD_INT 22
65398: PUSH
65399: LD_VAR 0 1
65403: PPUSH
65404: CALL_OW 255
65408: PUSH
65409: EMPTY
65410: LIST
65411: LIST
65412: PUSH
65413: LD_INT 58
65415: PUSH
65416: EMPTY
65417: LIST
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PPUSH
65423: CALL_OW 69
65427: IN
65428: ST_TO_ADDR
// end ;
65429: LD_VAR 0 2
65433: RET
// export function IsNotFull ( building ) ; var places ; begin
65434: LD_INT 0
65436: PPUSH
65437: PPUSH
// if not building then
65438: LD_VAR 0 1
65442: NOT
65443: IFFALSE 65447
// exit ;
65445: GO 65618
// result := false ;
65447: LD_ADDR_VAR 0 2
65451: PUSH
65452: LD_INT 0
65454: ST_TO_ADDR
// places := 0 ;
65455: LD_ADDR_VAR 0 3
65459: PUSH
65460: LD_INT 0
65462: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
65463: LD_VAR 0 1
65467: PPUSH
65468: CALL_OW 266
65472: PUSH
65473: LD_INT 0
65475: DOUBLE
65476: EQUAL
65477: IFTRUE 65535
65479: LD_INT 1
65481: DOUBLE
65482: EQUAL
65483: IFTRUE 65535
65485: LD_INT 6
65487: DOUBLE
65488: EQUAL
65489: IFTRUE 65535
65491: LD_INT 7
65493: DOUBLE
65494: EQUAL
65495: IFTRUE 65535
65497: LD_INT 8
65499: DOUBLE
65500: EQUAL
65501: IFTRUE 65535
65503: LD_INT 4
65505: DOUBLE
65506: EQUAL
65507: IFTRUE 65535
65509: LD_INT 5
65511: DOUBLE
65512: EQUAL
65513: IFTRUE 65535
65515: LD_INT 2
65517: DOUBLE
65518: EQUAL
65519: IFTRUE 65535
65521: LD_INT 3
65523: DOUBLE
65524: EQUAL
65525: IFTRUE 65535
65527: LD_INT 35
65529: DOUBLE
65530: EQUAL
65531: IFTRUE 65535
65533: GO 65546
65535: POP
// places := 6 ; b_bunker , b_breastwork :
65536: LD_ADDR_VAR 0 3
65540: PUSH
65541: LD_INT 6
65543: ST_TO_ADDR
65544: GO 65591
65546: LD_INT 32
65548: DOUBLE
65549: EQUAL
65550: IFTRUE 65560
65552: LD_INT 31
65554: DOUBLE
65555: EQUAL
65556: IFTRUE 65560
65558: GO 65571
65560: POP
// places := 1 ; b_control_tower :
65561: LD_ADDR_VAR 0 3
65565: PUSH
65566: LD_INT 1
65568: ST_TO_ADDR
65569: GO 65591
65571: LD_INT 36
65573: DOUBLE
65574: EQUAL
65575: IFTRUE 65579
65577: GO 65590
65579: POP
// places := 3 ; end ;
65580: LD_ADDR_VAR 0 3
65584: PUSH
65585: LD_INT 3
65587: ST_TO_ADDR
65588: GO 65591
65590: POP
// if places then
65591: LD_VAR 0 3
65595: IFFALSE 65618
// result := UnitsInside ( building ) < places ;
65597: LD_ADDR_VAR 0 2
65601: PUSH
65602: LD_VAR 0 1
65606: PPUSH
65607: CALL_OW 313
65611: PUSH
65612: LD_VAR 0 3
65616: LESS
65617: ST_TO_ADDR
// end ;
65618: LD_VAR 0 2
65622: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
65623: LD_INT 0
65625: PPUSH
65626: PPUSH
65627: PPUSH
65628: PPUSH
// tmp := [ ] ;
65629: LD_ADDR_VAR 0 3
65633: PUSH
65634: EMPTY
65635: ST_TO_ADDR
// list := [ ] ;
65636: LD_ADDR_VAR 0 5
65640: PUSH
65641: EMPTY
65642: ST_TO_ADDR
// for i = 16 to 25 do
65643: LD_ADDR_VAR 0 4
65647: PUSH
65648: DOUBLE
65649: LD_INT 16
65651: DEC
65652: ST_TO_ADDR
65653: LD_INT 25
65655: PUSH
65656: FOR_TO
65657: IFFALSE 65730
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
65659: LD_ADDR_VAR 0 3
65663: PUSH
65664: LD_VAR 0 3
65668: PUSH
65669: LD_INT 22
65671: PUSH
65672: LD_VAR 0 1
65676: PPUSH
65677: CALL_OW 255
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: LD_INT 91
65688: PUSH
65689: LD_VAR 0 1
65693: PUSH
65694: LD_INT 6
65696: PUSH
65697: EMPTY
65698: LIST
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 30
65704: PUSH
65705: LD_VAR 0 4
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: LIST
65718: PUSH
65719: EMPTY
65720: LIST
65721: PPUSH
65722: CALL_OW 69
65726: ADD
65727: ST_TO_ADDR
65728: GO 65656
65730: POP
65731: POP
// for i = 1 to tmp do
65732: LD_ADDR_VAR 0 4
65736: PUSH
65737: DOUBLE
65738: LD_INT 1
65740: DEC
65741: ST_TO_ADDR
65742: LD_VAR 0 3
65746: PUSH
65747: FOR_TO
65748: IFFALSE 65836
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
65750: LD_ADDR_VAR 0 5
65754: PUSH
65755: LD_VAR 0 5
65759: PUSH
65760: LD_VAR 0 3
65764: PUSH
65765: LD_VAR 0 4
65769: ARRAY
65770: PPUSH
65771: CALL_OW 266
65775: PUSH
65776: LD_VAR 0 3
65780: PUSH
65781: LD_VAR 0 4
65785: ARRAY
65786: PPUSH
65787: CALL_OW 250
65791: PUSH
65792: LD_VAR 0 3
65796: PUSH
65797: LD_VAR 0 4
65801: ARRAY
65802: PPUSH
65803: CALL_OW 251
65807: PUSH
65808: LD_VAR 0 3
65812: PUSH
65813: LD_VAR 0 4
65817: ARRAY
65818: PPUSH
65819: CALL_OW 254
65823: PUSH
65824: EMPTY
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: PUSH
65830: EMPTY
65831: LIST
65832: ADD
65833: ST_TO_ADDR
65834: GO 65747
65836: POP
65837: POP
// result := list ;
65838: LD_ADDR_VAR 0 2
65842: PUSH
65843: LD_VAR 0 5
65847: ST_TO_ADDR
// end ;
65848: LD_VAR 0 2
65852: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
65853: LD_INT 0
65855: PPUSH
65856: PPUSH
65857: PPUSH
65858: PPUSH
65859: PPUSH
65860: PPUSH
65861: PPUSH
// if not factory then
65862: LD_VAR 0 1
65866: NOT
65867: IFFALSE 65871
// exit ;
65869: GO 66464
// if control = control_apeman then
65871: LD_VAR 0 4
65875: PUSH
65876: LD_INT 5
65878: EQUAL
65879: IFFALSE 65988
// begin tmp := UnitsInside ( factory ) ;
65881: LD_ADDR_VAR 0 8
65885: PUSH
65886: LD_VAR 0 1
65890: PPUSH
65891: CALL_OW 313
65895: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
65896: LD_VAR 0 8
65900: PPUSH
65901: LD_INT 25
65903: PUSH
65904: LD_INT 12
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PPUSH
65911: CALL_OW 72
65915: NOT
65916: IFFALSE 65926
// control := control_manual ;
65918: LD_ADDR_VAR 0 4
65922: PUSH
65923: LD_INT 1
65925: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
65926: LD_ADDR_VAR 0 8
65930: PUSH
65931: LD_VAR 0 1
65935: PPUSH
65936: CALL 65623 0 1
65940: ST_TO_ADDR
// if tmp then
65941: LD_VAR 0 8
65945: IFFALSE 65988
// begin for i in tmp do
65947: LD_ADDR_VAR 0 7
65951: PUSH
65952: LD_VAR 0 8
65956: PUSH
65957: FOR_IN
65958: IFFALSE 65986
// if i [ 1 ] = b_ext_radio then
65960: LD_VAR 0 7
65964: PUSH
65965: LD_INT 1
65967: ARRAY
65968: PUSH
65969: LD_INT 22
65971: EQUAL
65972: IFFALSE 65984
// begin control := control_remote ;
65974: LD_ADDR_VAR 0 4
65978: PUSH
65979: LD_INT 2
65981: ST_TO_ADDR
// break ;
65982: GO 65986
// end ;
65984: GO 65957
65986: POP
65987: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
65988: LD_VAR 0 1
65992: PPUSH
65993: LD_VAR 0 2
65997: PPUSH
65998: LD_VAR 0 3
66002: PPUSH
66003: LD_VAR 0 4
66007: PPUSH
66008: LD_VAR 0 5
66012: PPUSH
66013: CALL_OW 448
66017: IFFALSE 66052
// begin result := [ chassis , engine , control , weapon ] ;
66019: LD_ADDR_VAR 0 6
66023: PUSH
66024: LD_VAR 0 2
66028: PUSH
66029: LD_VAR 0 3
66033: PUSH
66034: LD_VAR 0 4
66038: PUSH
66039: LD_VAR 0 5
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: ST_TO_ADDR
// exit ;
66050: GO 66464
// end ; _chassis := AvailableChassisList ( factory ) ;
66052: LD_ADDR_VAR 0 9
66056: PUSH
66057: LD_VAR 0 1
66061: PPUSH
66062: CALL_OW 475
66066: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
66067: LD_ADDR_VAR 0 11
66071: PUSH
66072: LD_VAR 0 1
66076: PPUSH
66077: CALL_OW 476
66081: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
66082: LD_ADDR_VAR 0 12
66086: PUSH
66087: LD_VAR 0 1
66091: PPUSH
66092: CALL_OW 477
66096: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
66097: LD_ADDR_VAR 0 10
66101: PUSH
66102: LD_VAR 0 1
66106: PPUSH
66107: CALL_OW 478
66111: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
66112: LD_VAR 0 9
66116: NOT
66117: PUSH
66118: LD_VAR 0 11
66122: NOT
66123: OR
66124: PUSH
66125: LD_VAR 0 12
66129: NOT
66130: OR
66131: PUSH
66132: LD_VAR 0 10
66136: NOT
66137: OR
66138: IFFALSE 66173
// begin result := [ chassis , engine , control , weapon ] ;
66140: LD_ADDR_VAR 0 6
66144: PUSH
66145: LD_VAR 0 2
66149: PUSH
66150: LD_VAR 0 3
66154: PUSH
66155: LD_VAR 0 4
66159: PUSH
66160: LD_VAR 0 5
66164: PUSH
66165: EMPTY
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: ST_TO_ADDR
// exit ;
66171: GO 66464
// end ; if not chassis in _chassis then
66173: LD_VAR 0 2
66177: PUSH
66178: LD_VAR 0 9
66182: IN
66183: NOT
66184: IFFALSE 66210
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
66186: LD_ADDR_VAR 0 2
66190: PUSH
66191: LD_VAR 0 9
66195: PUSH
66196: LD_INT 1
66198: PPUSH
66199: LD_VAR 0 9
66203: PPUSH
66204: CALL_OW 12
66208: ARRAY
66209: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
66210: LD_VAR 0 2
66214: PPUSH
66215: LD_VAR 0 3
66219: PPUSH
66220: CALL 66469 0 2
66224: NOT
66225: IFFALSE 66284
// repeat engine := _engine [ 1 ] ;
66227: LD_ADDR_VAR 0 3
66231: PUSH
66232: LD_VAR 0 11
66236: PUSH
66237: LD_INT 1
66239: ARRAY
66240: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
66241: LD_ADDR_VAR 0 11
66245: PUSH
66246: LD_VAR 0 11
66250: PPUSH
66251: LD_INT 1
66253: PPUSH
66254: CALL_OW 3
66258: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
66259: LD_VAR 0 2
66263: PPUSH
66264: LD_VAR 0 3
66268: PPUSH
66269: CALL 66469 0 2
66273: PUSH
66274: LD_VAR 0 11
66278: PUSH
66279: EMPTY
66280: EQUAL
66281: OR
66282: IFFALSE 66227
// if not control in _control then
66284: LD_VAR 0 4
66288: PUSH
66289: LD_VAR 0 12
66293: IN
66294: NOT
66295: IFFALSE 66321
// control := _control [ rand ( 1 , _control ) ] ;
66297: LD_ADDR_VAR 0 4
66301: PUSH
66302: LD_VAR 0 12
66306: PUSH
66307: LD_INT 1
66309: PPUSH
66310: LD_VAR 0 12
66314: PPUSH
66315: CALL_OW 12
66319: ARRAY
66320: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
66321: LD_VAR 0 2
66325: PPUSH
66326: LD_VAR 0 5
66330: PPUSH
66331: CALL 66689 0 2
66335: NOT
66336: IFFALSE 66395
// repeat weapon := _weapon [ 1 ] ;
66338: LD_ADDR_VAR 0 5
66342: PUSH
66343: LD_VAR 0 10
66347: PUSH
66348: LD_INT 1
66350: ARRAY
66351: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
66352: LD_ADDR_VAR 0 10
66356: PUSH
66357: LD_VAR 0 10
66361: PPUSH
66362: LD_INT 1
66364: PPUSH
66365: CALL_OW 3
66369: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
66370: LD_VAR 0 2
66374: PPUSH
66375: LD_VAR 0 5
66379: PPUSH
66380: CALL 66689 0 2
66384: PUSH
66385: LD_VAR 0 10
66389: PUSH
66390: EMPTY
66391: EQUAL
66392: OR
66393: IFFALSE 66338
// result := [ ] ;
66395: LD_ADDR_VAR 0 6
66399: PUSH
66400: EMPTY
66401: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
66402: LD_VAR 0 1
66406: PPUSH
66407: LD_VAR 0 2
66411: PPUSH
66412: LD_VAR 0 3
66416: PPUSH
66417: LD_VAR 0 4
66421: PPUSH
66422: LD_VAR 0 5
66426: PPUSH
66427: CALL_OW 448
66431: IFFALSE 66464
// result := [ chassis , engine , control , weapon ] ;
66433: LD_ADDR_VAR 0 6
66437: PUSH
66438: LD_VAR 0 2
66442: PUSH
66443: LD_VAR 0 3
66447: PUSH
66448: LD_VAR 0 4
66452: PUSH
66453: LD_VAR 0 5
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: LIST
66462: LIST
66463: ST_TO_ADDR
// end ;
66464: LD_VAR 0 6
66468: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
66469: LD_INT 0
66471: PPUSH
// if not chassis or not engine then
66472: LD_VAR 0 1
66476: NOT
66477: PUSH
66478: LD_VAR 0 2
66482: NOT
66483: OR
66484: IFFALSE 66488
// exit ;
66486: GO 66684
// case engine of engine_solar :
66488: LD_VAR 0 2
66492: PUSH
66493: LD_INT 2
66495: DOUBLE
66496: EQUAL
66497: IFTRUE 66501
66499: GO 66539
66501: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
66502: LD_ADDR_VAR 0 3
66506: PUSH
66507: LD_INT 11
66509: PUSH
66510: LD_INT 12
66512: PUSH
66513: LD_INT 13
66515: PUSH
66516: LD_INT 14
66518: PUSH
66519: LD_INT 1
66521: PUSH
66522: LD_INT 2
66524: PUSH
66525: LD_INT 3
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: ST_TO_ADDR
66537: GO 66668
66539: LD_INT 1
66541: DOUBLE
66542: EQUAL
66543: IFTRUE 66547
66545: GO 66609
66547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
66548: LD_ADDR_VAR 0 3
66552: PUSH
66553: LD_INT 11
66555: PUSH
66556: LD_INT 12
66558: PUSH
66559: LD_INT 13
66561: PUSH
66562: LD_INT 14
66564: PUSH
66565: LD_INT 1
66567: PUSH
66568: LD_INT 2
66570: PUSH
66571: LD_INT 3
66573: PUSH
66574: LD_INT 4
66576: PUSH
66577: LD_INT 5
66579: PUSH
66580: LD_INT 21
66582: PUSH
66583: LD_INT 23
66585: PUSH
66586: LD_INT 22
66588: PUSH
66589: LD_INT 24
66591: PUSH
66592: EMPTY
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: LIST
66600: LIST
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: ST_TO_ADDR
66607: GO 66668
66609: LD_INT 3
66611: DOUBLE
66612: EQUAL
66613: IFTRUE 66617
66615: GO 66667
66617: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
66618: LD_ADDR_VAR 0 3
66622: PUSH
66623: LD_INT 13
66625: PUSH
66626: LD_INT 14
66628: PUSH
66629: LD_INT 2
66631: PUSH
66632: LD_INT 3
66634: PUSH
66635: LD_INT 4
66637: PUSH
66638: LD_INT 5
66640: PUSH
66641: LD_INT 21
66643: PUSH
66644: LD_INT 22
66646: PUSH
66647: LD_INT 23
66649: PUSH
66650: LD_INT 24
66652: PUSH
66653: EMPTY
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: LIST
66663: LIST
66664: ST_TO_ADDR
66665: GO 66668
66667: POP
// result := ( chassis in result ) ;
66668: LD_ADDR_VAR 0 3
66672: PUSH
66673: LD_VAR 0 1
66677: PUSH
66678: LD_VAR 0 3
66682: IN
66683: ST_TO_ADDR
// end ;
66684: LD_VAR 0 3
66688: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
66689: LD_INT 0
66691: PPUSH
// if not chassis or not weapon then
66692: LD_VAR 0 1
66696: NOT
66697: PUSH
66698: LD_VAR 0 2
66702: NOT
66703: OR
66704: IFFALSE 66708
// exit ;
66706: GO 67768
// case weapon of us_machine_gun :
66708: LD_VAR 0 2
66712: PUSH
66713: LD_INT 2
66715: DOUBLE
66716: EQUAL
66717: IFTRUE 66721
66719: GO 66751
66721: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
66722: LD_ADDR_VAR 0 3
66726: PUSH
66727: LD_INT 1
66729: PUSH
66730: LD_INT 2
66732: PUSH
66733: LD_INT 3
66735: PUSH
66736: LD_INT 4
66738: PUSH
66739: LD_INT 5
66741: PUSH
66742: EMPTY
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: ST_TO_ADDR
66749: GO 67752
66751: LD_INT 3
66753: DOUBLE
66754: EQUAL
66755: IFTRUE 66759
66757: GO 66789
66759: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
66760: LD_ADDR_VAR 0 3
66764: PUSH
66765: LD_INT 1
66767: PUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 3
66773: PUSH
66774: LD_INT 4
66776: PUSH
66777: LD_INT 5
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: LIST
66786: ST_TO_ADDR
66787: GO 67752
66789: LD_INT 11
66791: DOUBLE
66792: EQUAL
66793: IFTRUE 66797
66795: GO 66827
66797: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
66798: LD_ADDR_VAR 0 3
66802: PUSH
66803: LD_INT 1
66805: PUSH
66806: LD_INT 2
66808: PUSH
66809: LD_INT 3
66811: PUSH
66812: LD_INT 4
66814: PUSH
66815: LD_INT 5
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: ST_TO_ADDR
66825: GO 67752
66827: LD_INT 4
66829: DOUBLE
66830: EQUAL
66831: IFTRUE 66835
66833: GO 66861
66835: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
66836: LD_ADDR_VAR 0 3
66840: PUSH
66841: LD_INT 2
66843: PUSH
66844: LD_INT 3
66846: PUSH
66847: LD_INT 4
66849: PUSH
66850: LD_INT 5
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: LIST
66857: LIST
66858: ST_TO_ADDR
66859: GO 67752
66861: LD_INT 5
66863: DOUBLE
66864: EQUAL
66865: IFTRUE 66869
66867: GO 66895
66869: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
66870: LD_ADDR_VAR 0 3
66874: PUSH
66875: LD_INT 2
66877: PUSH
66878: LD_INT 3
66880: PUSH
66881: LD_INT 4
66883: PUSH
66884: LD_INT 5
66886: PUSH
66887: EMPTY
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: ST_TO_ADDR
66893: GO 67752
66895: LD_INT 9
66897: DOUBLE
66898: EQUAL
66899: IFTRUE 66903
66901: GO 66929
66903: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
66904: LD_ADDR_VAR 0 3
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: LD_INT 3
66914: PUSH
66915: LD_INT 4
66917: PUSH
66918: LD_INT 5
66920: PUSH
66921: EMPTY
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: ST_TO_ADDR
66927: GO 67752
66929: LD_INT 7
66931: DOUBLE
66932: EQUAL
66933: IFTRUE 66937
66935: GO 66963
66937: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
66938: LD_ADDR_VAR 0 3
66942: PUSH
66943: LD_INT 2
66945: PUSH
66946: LD_INT 3
66948: PUSH
66949: LD_INT 4
66951: PUSH
66952: LD_INT 5
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: ST_TO_ADDR
66961: GO 67752
66963: LD_INT 12
66965: DOUBLE
66966: EQUAL
66967: IFTRUE 66971
66969: GO 66997
66971: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
66972: LD_ADDR_VAR 0 3
66976: PUSH
66977: LD_INT 2
66979: PUSH
66980: LD_INT 3
66982: PUSH
66983: LD_INT 4
66985: PUSH
66986: LD_INT 5
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: ST_TO_ADDR
66995: GO 67752
66997: LD_INT 13
66999: DOUBLE
67000: EQUAL
67001: IFTRUE 67005
67003: GO 67031
67005: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
67006: LD_ADDR_VAR 0 3
67010: PUSH
67011: LD_INT 2
67013: PUSH
67014: LD_INT 3
67016: PUSH
67017: LD_INT 4
67019: PUSH
67020: LD_INT 5
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: ST_TO_ADDR
67029: GO 67752
67031: LD_INT 14
67033: DOUBLE
67034: EQUAL
67035: IFTRUE 67039
67037: GO 67057
67039: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
67040: LD_ADDR_VAR 0 3
67044: PUSH
67045: LD_INT 4
67047: PUSH
67048: LD_INT 5
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: ST_TO_ADDR
67055: GO 67752
67057: LD_INT 6
67059: DOUBLE
67060: EQUAL
67061: IFTRUE 67065
67063: GO 67083
67065: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
67066: LD_ADDR_VAR 0 3
67070: PUSH
67071: LD_INT 4
67073: PUSH
67074: LD_INT 5
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: ST_TO_ADDR
67081: GO 67752
67083: LD_INT 10
67085: DOUBLE
67086: EQUAL
67087: IFTRUE 67091
67089: GO 67109
67091: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
67092: LD_ADDR_VAR 0 3
67096: PUSH
67097: LD_INT 4
67099: PUSH
67100: LD_INT 5
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: ST_TO_ADDR
67107: GO 67752
67109: LD_INT 22
67111: DOUBLE
67112: EQUAL
67113: IFTRUE 67117
67115: GO 67143
67117: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
67118: LD_ADDR_VAR 0 3
67122: PUSH
67123: LD_INT 11
67125: PUSH
67126: LD_INT 12
67128: PUSH
67129: LD_INT 13
67131: PUSH
67132: LD_INT 14
67134: PUSH
67135: EMPTY
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: ST_TO_ADDR
67141: GO 67752
67143: LD_INT 23
67145: DOUBLE
67146: EQUAL
67147: IFTRUE 67151
67149: GO 67177
67151: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
67152: LD_ADDR_VAR 0 3
67156: PUSH
67157: LD_INT 11
67159: PUSH
67160: LD_INT 12
67162: PUSH
67163: LD_INT 13
67165: PUSH
67166: LD_INT 14
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: LIST
67173: LIST
67174: ST_TO_ADDR
67175: GO 67752
67177: LD_INT 24
67179: DOUBLE
67180: EQUAL
67181: IFTRUE 67185
67183: GO 67211
67185: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
67186: LD_ADDR_VAR 0 3
67190: PUSH
67191: LD_INT 11
67193: PUSH
67194: LD_INT 12
67196: PUSH
67197: LD_INT 13
67199: PUSH
67200: LD_INT 14
67202: PUSH
67203: EMPTY
67204: LIST
67205: LIST
67206: LIST
67207: LIST
67208: ST_TO_ADDR
67209: GO 67752
67211: LD_INT 30
67213: DOUBLE
67214: EQUAL
67215: IFTRUE 67219
67217: GO 67245
67219: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
67220: LD_ADDR_VAR 0 3
67224: PUSH
67225: LD_INT 11
67227: PUSH
67228: LD_INT 12
67230: PUSH
67231: LD_INT 13
67233: PUSH
67234: LD_INT 14
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: LIST
67241: LIST
67242: ST_TO_ADDR
67243: GO 67752
67245: LD_INT 25
67247: DOUBLE
67248: EQUAL
67249: IFTRUE 67253
67251: GO 67271
67253: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
67254: LD_ADDR_VAR 0 3
67258: PUSH
67259: LD_INT 13
67261: PUSH
67262: LD_INT 14
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: ST_TO_ADDR
67269: GO 67752
67271: LD_INT 27
67273: DOUBLE
67274: EQUAL
67275: IFTRUE 67279
67277: GO 67297
67279: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
67280: LD_ADDR_VAR 0 3
67284: PUSH
67285: LD_INT 13
67287: PUSH
67288: LD_INT 14
67290: PUSH
67291: EMPTY
67292: LIST
67293: LIST
67294: ST_TO_ADDR
67295: GO 67752
67297: LD_INT 92
67299: DOUBLE
67300: EQUAL
67301: IFTRUE 67305
67303: GO 67331
67305: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
67306: LD_ADDR_VAR 0 3
67310: PUSH
67311: LD_INT 11
67313: PUSH
67314: LD_INT 12
67316: PUSH
67317: LD_INT 13
67319: PUSH
67320: LD_INT 14
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: LIST
67327: LIST
67328: ST_TO_ADDR
67329: GO 67752
67331: LD_INT 28
67333: DOUBLE
67334: EQUAL
67335: IFTRUE 67339
67337: GO 67357
67339: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
67340: LD_ADDR_VAR 0 3
67344: PUSH
67345: LD_INT 13
67347: PUSH
67348: LD_INT 14
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: ST_TO_ADDR
67355: GO 67752
67357: LD_INT 29
67359: DOUBLE
67360: EQUAL
67361: IFTRUE 67365
67363: GO 67383
67365: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
67366: LD_ADDR_VAR 0 3
67370: PUSH
67371: LD_INT 13
67373: PUSH
67374: LD_INT 14
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: ST_TO_ADDR
67381: GO 67752
67383: LD_INT 31
67385: DOUBLE
67386: EQUAL
67387: IFTRUE 67391
67389: GO 67409
67391: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
67392: LD_ADDR_VAR 0 3
67396: PUSH
67397: LD_INT 13
67399: PUSH
67400: LD_INT 14
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: ST_TO_ADDR
67407: GO 67752
67409: LD_INT 26
67411: DOUBLE
67412: EQUAL
67413: IFTRUE 67417
67415: GO 67435
67417: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
67418: LD_ADDR_VAR 0 3
67422: PUSH
67423: LD_INT 13
67425: PUSH
67426: LD_INT 14
67428: PUSH
67429: EMPTY
67430: LIST
67431: LIST
67432: ST_TO_ADDR
67433: GO 67752
67435: LD_INT 42
67437: DOUBLE
67438: EQUAL
67439: IFTRUE 67443
67441: GO 67469
67443: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
67444: LD_ADDR_VAR 0 3
67448: PUSH
67449: LD_INT 21
67451: PUSH
67452: LD_INT 22
67454: PUSH
67455: LD_INT 23
67457: PUSH
67458: LD_INT 24
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: ST_TO_ADDR
67467: GO 67752
67469: LD_INT 43
67471: DOUBLE
67472: EQUAL
67473: IFTRUE 67477
67475: GO 67503
67477: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
67478: LD_ADDR_VAR 0 3
67482: PUSH
67483: LD_INT 21
67485: PUSH
67486: LD_INT 22
67488: PUSH
67489: LD_INT 23
67491: PUSH
67492: LD_INT 24
67494: PUSH
67495: EMPTY
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: ST_TO_ADDR
67501: GO 67752
67503: LD_INT 44
67505: DOUBLE
67506: EQUAL
67507: IFTRUE 67511
67509: GO 67537
67511: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
67512: LD_ADDR_VAR 0 3
67516: PUSH
67517: LD_INT 21
67519: PUSH
67520: LD_INT 22
67522: PUSH
67523: LD_INT 23
67525: PUSH
67526: LD_INT 24
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: ST_TO_ADDR
67535: GO 67752
67537: LD_INT 45
67539: DOUBLE
67540: EQUAL
67541: IFTRUE 67545
67543: GO 67571
67545: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
67546: LD_ADDR_VAR 0 3
67550: PUSH
67551: LD_INT 21
67553: PUSH
67554: LD_INT 22
67556: PUSH
67557: LD_INT 23
67559: PUSH
67560: LD_INT 24
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: ST_TO_ADDR
67569: GO 67752
67571: LD_INT 49
67573: DOUBLE
67574: EQUAL
67575: IFTRUE 67579
67577: GO 67605
67579: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
67580: LD_ADDR_VAR 0 3
67584: PUSH
67585: LD_INT 21
67587: PUSH
67588: LD_INT 22
67590: PUSH
67591: LD_INT 23
67593: PUSH
67594: LD_INT 24
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: ST_TO_ADDR
67603: GO 67752
67605: LD_INT 51
67607: DOUBLE
67608: EQUAL
67609: IFTRUE 67613
67611: GO 67639
67613: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
67614: LD_ADDR_VAR 0 3
67618: PUSH
67619: LD_INT 21
67621: PUSH
67622: LD_INT 22
67624: PUSH
67625: LD_INT 23
67627: PUSH
67628: LD_INT 24
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: ST_TO_ADDR
67637: GO 67752
67639: LD_INT 52
67641: DOUBLE
67642: EQUAL
67643: IFTRUE 67647
67645: GO 67673
67647: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
67648: LD_ADDR_VAR 0 3
67652: PUSH
67653: LD_INT 21
67655: PUSH
67656: LD_INT 22
67658: PUSH
67659: LD_INT 23
67661: PUSH
67662: LD_INT 24
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: LIST
67669: LIST
67670: ST_TO_ADDR
67671: GO 67752
67673: LD_INT 53
67675: DOUBLE
67676: EQUAL
67677: IFTRUE 67681
67679: GO 67699
67681: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
67682: LD_ADDR_VAR 0 3
67686: PUSH
67687: LD_INT 23
67689: PUSH
67690: LD_INT 24
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: ST_TO_ADDR
67697: GO 67752
67699: LD_INT 46
67701: DOUBLE
67702: EQUAL
67703: IFTRUE 67707
67705: GO 67725
67707: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
67708: LD_ADDR_VAR 0 3
67712: PUSH
67713: LD_INT 23
67715: PUSH
67716: LD_INT 24
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: ST_TO_ADDR
67723: GO 67752
67725: LD_INT 47
67727: DOUBLE
67728: EQUAL
67729: IFTRUE 67733
67731: GO 67751
67733: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67734: LD_ADDR_VAR 0 3
67738: PUSH
67739: LD_INT 23
67741: PUSH
67742: LD_INT 24
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: ST_TO_ADDR
67749: GO 67752
67751: POP
// result := ( chassis in result ) ;
67752: LD_ADDR_VAR 0 3
67756: PUSH
67757: LD_VAR 0 1
67761: PUSH
67762: LD_VAR 0 3
67766: IN
67767: ST_TO_ADDR
// end ;
67768: LD_VAR 0 3
67772: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
67773: LD_INT 0
67775: PPUSH
67776: PPUSH
67777: PPUSH
67778: PPUSH
67779: PPUSH
67780: PPUSH
67781: PPUSH
// result := array ;
67782: LD_ADDR_VAR 0 5
67786: PUSH
67787: LD_VAR 0 1
67791: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
67792: LD_VAR 0 1
67796: NOT
67797: PUSH
67798: LD_VAR 0 2
67802: NOT
67803: OR
67804: PUSH
67805: LD_VAR 0 3
67809: NOT
67810: OR
67811: PUSH
67812: LD_VAR 0 2
67816: PUSH
67817: LD_VAR 0 1
67821: GREATER
67822: OR
67823: PUSH
67824: LD_VAR 0 3
67828: PUSH
67829: LD_VAR 0 1
67833: GREATER
67834: OR
67835: IFFALSE 67839
// exit ;
67837: GO 68135
// if direction then
67839: LD_VAR 0 4
67843: IFFALSE 67907
// begin d := 1 ;
67845: LD_ADDR_VAR 0 9
67849: PUSH
67850: LD_INT 1
67852: ST_TO_ADDR
// if i_from > i_to then
67853: LD_VAR 0 2
67857: PUSH
67858: LD_VAR 0 3
67862: GREATER
67863: IFFALSE 67889
// length := ( array - i_from ) + i_to else
67865: LD_ADDR_VAR 0 11
67869: PUSH
67870: LD_VAR 0 1
67874: PUSH
67875: LD_VAR 0 2
67879: MINUS
67880: PUSH
67881: LD_VAR 0 3
67885: PLUS
67886: ST_TO_ADDR
67887: GO 67905
// length := i_to - i_from ;
67889: LD_ADDR_VAR 0 11
67893: PUSH
67894: LD_VAR 0 3
67898: PUSH
67899: LD_VAR 0 2
67903: MINUS
67904: ST_TO_ADDR
// end else
67905: GO 67968
// begin d := - 1 ;
67907: LD_ADDR_VAR 0 9
67911: PUSH
67912: LD_INT 1
67914: NEG
67915: ST_TO_ADDR
// if i_from > i_to then
67916: LD_VAR 0 2
67920: PUSH
67921: LD_VAR 0 3
67925: GREATER
67926: IFFALSE 67946
// length := i_from - i_to else
67928: LD_ADDR_VAR 0 11
67932: PUSH
67933: LD_VAR 0 2
67937: PUSH
67938: LD_VAR 0 3
67942: MINUS
67943: ST_TO_ADDR
67944: GO 67968
// length := ( array - i_to ) + i_from ;
67946: LD_ADDR_VAR 0 11
67950: PUSH
67951: LD_VAR 0 1
67955: PUSH
67956: LD_VAR 0 3
67960: MINUS
67961: PUSH
67962: LD_VAR 0 2
67966: PLUS
67967: ST_TO_ADDR
// end ; if not length then
67968: LD_VAR 0 11
67972: NOT
67973: IFFALSE 67977
// exit ;
67975: GO 68135
// tmp := array ;
67977: LD_ADDR_VAR 0 10
67981: PUSH
67982: LD_VAR 0 1
67986: ST_TO_ADDR
// for i = 1 to length do
67987: LD_ADDR_VAR 0 6
67991: PUSH
67992: DOUBLE
67993: LD_INT 1
67995: DEC
67996: ST_TO_ADDR
67997: LD_VAR 0 11
68001: PUSH
68002: FOR_TO
68003: IFFALSE 68123
// begin for j = 1 to array do
68005: LD_ADDR_VAR 0 7
68009: PUSH
68010: DOUBLE
68011: LD_INT 1
68013: DEC
68014: ST_TO_ADDR
68015: LD_VAR 0 1
68019: PUSH
68020: FOR_TO
68021: IFFALSE 68109
// begin k := j + d ;
68023: LD_ADDR_VAR 0 8
68027: PUSH
68028: LD_VAR 0 7
68032: PUSH
68033: LD_VAR 0 9
68037: PLUS
68038: ST_TO_ADDR
// if k > array then
68039: LD_VAR 0 8
68043: PUSH
68044: LD_VAR 0 1
68048: GREATER
68049: IFFALSE 68059
// k := 1 ;
68051: LD_ADDR_VAR 0 8
68055: PUSH
68056: LD_INT 1
68058: ST_TO_ADDR
// if not k then
68059: LD_VAR 0 8
68063: NOT
68064: IFFALSE 68076
// k := array ;
68066: LD_ADDR_VAR 0 8
68070: PUSH
68071: LD_VAR 0 1
68075: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
68076: LD_ADDR_VAR 0 10
68080: PUSH
68081: LD_VAR 0 10
68085: PPUSH
68086: LD_VAR 0 8
68090: PPUSH
68091: LD_VAR 0 1
68095: PUSH
68096: LD_VAR 0 7
68100: ARRAY
68101: PPUSH
68102: CALL_OW 1
68106: ST_TO_ADDR
// end ;
68107: GO 68020
68109: POP
68110: POP
// array := tmp ;
68111: LD_ADDR_VAR 0 1
68115: PUSH
68116: LD_VAR 0 10
68120: ST_TO_ADDR
// end ;
68121: GO 68002
68123: POP
68124: POP
// result := array ;
68125: LD_ADDR_VAR 0 5
68129: PUSH
68130: LD_VAR 0 1
68134: ST_TO_ADDR
// end ;
68135: LD_VAR 0 5
68139: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
68140: LD_INT 0
68142: PPUSH
68143: PPUSH
// result := 0 ;
68144: LD_ADDR_VAR 0 3
68148: PUSH
68149: LD_INT 0
68151: ST_TO_ADDR
// if not array or not value in array then
68152: LD_VAR 0 1
68156: NOT
68157: PUSH
68158: LD_VAR 0 2
68162: PUSH
68163: LD_VAR 0 1
68167: IN
68168: NOT
68169: OR
68170: IFFALSE 68174
// exit ;
68172: GO 68228
// for i = 1 to array do
68174: LD_ADDR_VAR 0 4
68178: PUSH
68179: DOUBLE
68180: LD_INT 1
68182: DEC
68183: ST_TO_ADDR
68184: LD_VAR 0 1
68188: PUSH
68189: FOR_TO
68190: IFFALSE 68226
// if value = array [ i ] then
68192: LD_VAR 0 2
68196: PUSH
68197: LD_VAR 0 1
68201: PUSH
68202: LD_VAR 0 4
68206: ARRAY
68207: EQUAL
68208: IFFALSE 68224
// begin result := i ;
68210: LD_ADDR_VAR 0 3
68214: PUSH
68215: LD_VAR 0 4
68219: ST_TO_ADDR
// exit ;
68220: POP
68221: POP
68222: GO 68228
// end ;
68224: GO 68189
68226: POP
68227: POP
// end ;
68228: LD_VAR 0 3
68232: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
68233: LD_INT 0
68235: PPUSH
// vc_chassis := chassis ;
68236: LD_ADDR_OWVAR 37
68240: PUSH
68241: LD_VAR 0 1
68245: ST_TO_ADDR
// vc_engine := engine ;
68246: LD_ADDR_OWVAR 39
68250: PUSH
68251: LD_VAR 0 2
68255: ST_TO_ADDR
// vc_control := control ;
68256: LD_ADDR_OWVAR 38
68260: PUSH
68261: LD_VAR 0 3
68265: ST_TO_ADDR
// vc_weapon := weapon ;
68266: LD_ADDR_OWVAR 40
68270: PUSH
68271: LD_VAR 0 4
68275: ST_TO_ADDR
// vc_fuel_battery := fuel ;
68276: LD_ADDR_OWVAR 41
68280: PUSH
68281: LD_VAR 0 5
68285: ST_TO_ADDR
// end ;
68286: LD_VAR 0 6
68290: RET
// export function WantPlant ( unit ) ; var task ; begin
68291: LD_INT 0
68293: PPUSH
68294: PPUSH
// result := false ;
68295: LD_ADDR_VAR 0 2
68299: PUSH
68300: LD_INT 0
68302: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
68303: LD_ADDR_VAR 0 3
68307: PUSH
68308: LD_VAR 0 1
68312: PPUSH
68313: CALL_OW 437
68317: ST_TO_ADDR
// if task then
68318: LD_VAR 0 3
68322: IFFALSE 68350
// if task [ 1 ] [ 1 ] = p then
68324: LD_VAR 0 3
68328: PUSH
68329: LD_INT 1
68331: ARRAY
68332: PUSH
68333: LD_INT 1
68335: ARRAY
68336: PUSH
68337: LD_STRING p
68339: EQUAL
68340: IFFALSE 68350
// result := true ;
68342: LD_ADDR_VAR 0 2
68346: PUSH
68347: LD_INT 1
68349: ST_TO_ADDR
// end ;
68350: LD_VAR 0 2
68354: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
68355: LD_INT 0
68357: PPUSH
68358: PPUSH
68359: PPUSH
68360: PPUSH
// if pos < 1 then
68361: LD_VAR 0 2
68365: PUSH
68366: LD_INT 1
68368: LESS
68369: IFFALSE 68373
// exit ;
68371: GO 68676
// if pos = 1 then
68373: LD_VAR 0 2
68377: PUSH
68378: LD_INT 1
68380: EQUAL
68381: IFFALSE 68414
// result := Replace ( arr , pos [ 1 ] , value ) else
68383: LD_ADDR_VAR 0 4
68387: PUSH
68388: LD_VAR 0 1
68392: PPUSH
68393: LD_VAR 0 2
68397: PUSH
68398: LD_INT 1
68400: ARRAY
68401: PPUSH
68402: LD_VAR 0 3
68406: PPUSH
68407: CALL_OW 1
68411: ST_TO_ADDR
68412: GO 68676
// begin tmp := arr ;
68414: LD_ADDR_VAR 0 6
68418: PUSH
68419: LD_VAR 0 1
68423: ST_TO_ADDR
// s_arr := [ tmp ] ;
68424: LD_ADDR_VAR 0 7
68428: PUSH
68429: LD_VAR 0 6
68433: PUSH
68434: EMPTY
68435: LIST
68436: ST_TO_ADDR
// for i = 1 to pos - 1 do
68437: LD_ADDR_VAR 0 5
68441: PUSH
68442: DOUBLE
68443: LD_INT 1
68445: DEC
68446: ST_TO_ADDR
68447: LD_VAR 0 2
68451: PUSH
68452: LD_INT 1
68454: MINUS
68455: PUSH
68456: FOR_TO
68457: IFFALSE 68502
// begin tmp := tmp [ pos [ i ] ] ;
68459: LD_ADDR_VAR 0 6
68463: PUSH
68464: LD_VAR 0 6
68468: PUSH
68469: LD_VAR 0 2
68473: PUSH
68474: LD_VAR 0 5
68478: ARRAY
68479: ARRAY
68480: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
68481: LD_ADDR_VAR 0 7
68485: PUSH
68486: LD_VAR 0 7
68490: PUSH
68491: LD_VAR 0 6
68495: PUSH
68496: EMPTY
68497: LIST
68498: ADD
68499: ST_TO_ADDR
// end ;
68500: GO 68456
68502: POP
68503: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
68504: LD_ADDR_VAR 0 6
68508: PUSH
68509: LD_VAR 0 6
68513: PPUSH
68514: LD_VAR 0 2
68518: PUSH
68519: LD_VAR 0 2
68523: ARRAY
68524: PPUSH
68525: LD_VAR 0 3
68529: PPUSH
68530: CALL_OW 1
68534: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
68535: LD_ADDR_VAR 0 7
68539: PUSH
68540: LD_VAR 0 7
68544: PPUSH
68545: LD_VAR 0 7
68549: PPUSH
68550: LD_VAR 0 6
68554: PPUSH
68555: CALL_OW 1
68559: ST_TO_ADDR
// for i = s_arr downto 2 do
68560: LD_ADDR_VAR 0 5
68564: PUSH
68565: DOUBLE
68566: LD_VAR 0 7
68570: INC
68571: ST_TO_ADDR
68572: LD_INT 2
68574: PUSH
68575: FOR_DOWNTO
68576: IFFALSE 68660
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
68578: LD_ADDR_VAR 0 6
68582: PUSH
68583: LD_VAR 0 7
68587: PUSH
68588: LD_VAR 0 5
68592: PUSH
68593: LD_INT 1
68595: MINUS
68596: ARRAY
68597: PPUSH
68598: LD_VAR 0 2
68602: PUSH
68603: LD_VAR 0 5
68607: PUSH
68608: LD_INT 1
68610: MINUS
68611: ARRAY
68612: PPUSH
68613: LD_VAR 0 7
68617: PUSH
68618: LD_VAR 0 5
68622: ARRAY
68623: PPUSH
68624: CALL_OW 1
68628: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
68629: LD_ADDR_VAR 0 7
68633: PUSH
68634: LD_VAR 0 7
68638: PPUSH
68639: LD_VAR 0 5
68643: PUSH
68644: LD_INT 1
68646: MINUS
68647: PPUSH
68648: LD_VAR 0 6
68652: PPUSH
68653: CALL_OW 1
68657: ST_TO_ADDR
// end ;
68658: GO 68575
68660: POP
68661: POP
// result := s_arr [ 1 ] ;
68662: LD_ADDR_VAR 0 4
68666: PUSH
68667: LD_VAR 0 7
68671: PUSH
68672: LD_INT 1
68674: ARRAY
68675: ST_TO_ADDR
// end ; end ;
68676: LD_VAR 0 4
68680: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
68681: LD_INT 0
68683: PPUSH
68684: PPUSH
// if not list then
68685: LD_VAR 0 1
68689: NOT
68690: IFFALSE 68694
// exit ;
68692: GO 68785
// i := list [ pos1 ] ;
68694: LD_ADDR_VAR 0 5
68698: PUSH
68699: LD_VAR 0 1
68703: PUSH
68704: LD_VAR 0 2
68708: ARRAY
68709: ST_TO_ADDR
// if not i then
68710: LD_VAR 0 5
68714: NOT
68715: IFFALSE 68719
// exit ;
68717: GO 68785
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
68719: LD_ADDR_VAR 0 1
68723: PUSH
68724: LD_VAR 0 1
68728: PPUSH
68729: LD_VAR 0 2
68733: PPUSH
68734: LD_VAR 0 1
68738: PUSH
68739: LD_VAR 0 3
68743: ARRAY
68744: PPUSH
68745: CALL_OW 1
68749: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
68750: LD_ADDR_VAR 0 1
68754: PUSH
68755: LD_VAR 0 1
68759: PPUSH
68760: LD_VAR 0 3
68764: PPUSH
68765: LD_VAR 0 5
68769: PPUSH
68770: CALL_OW 1
68774: ST_TO_ADDR
// result := list ;
68775: LD_ADDR_VAR 0 4
68779: PUSH
68780: LD_VAR 0 1
68784: ST_TO_ADDR
// end ;
68785: LD_VAR 0 4
68789: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
68790: LD_INT 0
68792: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
68793: LD_ADDR_VAR 0 5
68797: PUSH
68798: LD_VAR 0 1
68802: PPUSH
68803: CALL_OW 250
68807: PPUSH
68808: LD_VAR 0 1
68812: PPUSH
68813: CALL_OW 251
68817: PPUSH
68818: LD_VAR 0 2
68822: PPUSH
68823: LD_VAR 0 3
68827: PPUSH
68828: LD_VAR 0 4
68832: PPUSH
68833: CALL 68843 0 5
68837: ST_TO_ADDR
// end ;
68838: LD_VAR 0 5
68842: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
68843: LD_INT 0
68845: PPUSH
68846: PPUSH
68847: PPUSH
68848: PPUSH
// if not list then
68849: LD_VAR 0 3
68853: NOT
68854: IFFALSE 68858
// exit ;
68856: GO 69246
// result := [ ] ;
68858: LD_ADDR_VAR 0 6
68862: PUSH
68863: EMPTY
68864: ST_TO_ADDR
// for i in list do
68865: LD_ADDR_VAR 0 7
68869: PUSH
68870: LD_VAR 0 3
68874: PUSH
68875: FOR_IN
68876: IFFALSE 69078
// begin tmp := GetDistUnitXY ( i , x , y ) ;
68878: LD_ADDR_VAR 0 9
68882: PUSH
68883: LD_VAR 0 7
68887: PPUSH
68888: LD_VAR 0 1
68892: PPUSH
68893: LD_VAR 0 2
68897: PPUSH
68898: CALL_OW 297
68902: ST_TO_ADDR
// if not result then
68903: LD_VAR 0 6
68907: NOT
68908: IFFALSE 68934
// result := [ [ i , tmp ] ] else
68910: LD_ADDR_VAR 0 6
68914: PUSH
68915: LD_VAR 0 7
68919: PUSH
68920: LD_VAR 0 9
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: EMPTY
68930: LIST
68931: ST_TO_ADDR
68932: GO 69076
// begin if result [ result ] [ 2 ] < tmp then
68934: LD_VAR 0 6
68938: PUSH
68939: LD_VAR 0 6
68943: ARRAY
68944: PUSH
68945: LD_INT 2
68947: ARRAY
68948: PUSH
68949: LD_VAR 0 9
68953: LESS
68954: IFFALSE 68996
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
68956: LD_ADDR_VAR 0 6
68960: PUSH
68961: LD_VAR 0 6
68965: PPUSH
68966: LD_VAR 0 6
68970: PUSH
68971: LD_INT 1
68973: PLUS
68974: PPUSH
68975: LD_VAR 0 7
68979: PUSH
68980: LD_VAR 0 9
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PPUSH
68989: CALL_OW 2
68993: ST_TO_ADDR
68994: GO 69076
// for j = 1 to result do
68996: LD_ADDR_VAR 0 8
69000: PUSH
69001: DOUBLE
69002: LD_INT 1
69004: DEC
69005: ST_TO_ADDR
69006: LD_VAR 0 6
69010: PUSH
69011: FOR_TO
69012: IFFALSE 69074
// begin if tmp < result [ j ] [ 2 ] then
69014: LD_VAR 0 9
69018: PUSH
69019: LD_VAR 0 6
69023: PUSH
69024: LD_VAR 0 8
69028: ARRAY
69029: PUSH
69030: LD_INT 2
69032: ARRAY
69033: LESS
69034: IFFALSE 69072
// begin result := Insert ( result , j , [ i , tmp ] ) ;
69036: LD_ADDR_VAR 0 6
69040: PUSH
69041: LD_VAR 0 6
69045: PPUSH
69046: LD_VAR 0 8
69050: PPUSH
69051: LD_VAR 0 7
69055: PUSH
69056: LD_VAR 0 9
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PPUSH
69065: CALL_OW 2
69069: ST_TO_ADDR
// break ;
69070: GO 69074
// end ; end ;
69072: GO 69011
69074: POP
69075: POP
// end ; end ;
69076: GO 68875
69078: POP
69079: POP
// if result and not asc then
69080: LD_VAR 0 6
69084: PUSH
69085: LD_VAR 0 4
69089: NOT
69090: AND
69091: IFFALSE 69166
// begin tmp := result ;
69093: LD_ADDR_VAR 0 9
69097: PUSH
69098: LD_VAR 0 6
69102: ST_TO_ADDR
// for i = tmp downto 1 do
69103: LD_ADDR_VAR 0 7
69107: PUSH
69108: DOUBLE
69109: LD_VAR 0 9
69113: INC
69114: ST_TO_ADDR
69115: LD_INT 1
69117: PUSH
69118: FOR_DOWNTO
69119: IFFALSE 69164
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
69121: LD_ADDR_VAR 0 6
69125: PUSH
69126: LD_VAR 0 6
69130: PPUSH
69131: LD_VAR 0 9
69135: PUSH
69136: LD_VAR 0 7
69140: MINUS
69141: PUSH
69142: LD_INT 1
69144: PLUS
69145: PPUSH
69146: LD_VAR 0 9
69150: PUSH
69151: LD_VAR 0 7
69155: ARRAY
69156: PPUSH
69157: CALL_OW 1
69161: ST_TO_ADDR
69162: GO 69118
69164: POP
69165: POP
// end ; tmp := [ ] ;
69166: LD_ADDR_VAR 0 9
69170: PUSH
69171: EMPTY
69172: ST_TO_ADDR
// if mode then
69173: LD_VAR 0 5
69177: IFFALSE 69246
// begin for i = 1 to result do
69179: LD_ADDR_VAR 0 7
69183: PUSH
69184: DOUBLE
69185: LD_INT 1
69187: DEC
69188: ST_TO_ADDR
69189: LD_VAR 0 6
69193: PUSH
69194: FOR_TO
69195: IFFALSE 69234
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
69197: LD_ADDR_VAR 0 9
69201: PUSH
69202: LD_VAR 0 9
69206: PPUSH
69207: LD_VAR 0 7
69211: PPUSH
69212: LD_VAR 0 6
69216: PUSH
69217: LD_VAR 0 7
69221: ARRAY
69222: PUSH
69223: LD_INT 1
69225: ARRAY
69226: PPUSH
69227: CALL_OW 1
69231: ST_TO_ADDR
69232: GO 69194
69234: POP
69235: POP
// result := tmp ;
69236: LD_ADDR_VAR 0 6
69240: PUSH
69241: LD_VAR 0 9
69245: ST_TO_ADDR
// end ; end ;
69246: LD_VAR 0 6
69250: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
69251: LD_INT 0
69253: PPUSH
69254: PPUSH
69255: PPUSH
69256: PPUSH
69257: PPUSH
69258: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
69259: LD_ADDR_VAR 0 5
69263: PUSH
69264: LD_INT 0
69266: PUSH
69267: LD_INT 0
69269: PUSH
69270: LD_INT 0
69272: PUSH
69273: EMPTY
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: LIST
69279: LIST
69280: ST_TO_ADDR
// if not x or not y then
69281: LD_VAR 0 2
69285: NOT
69286: PUSH
69287: LD_VAR 0 3
69291: NOT
69292: OR
69293: IFFALSE 69297
// exit ;
69295: GO 70947
// if not range then
69297: LD_VAR 0 4
69301: NOT
69302: IFFALSE 69312
// range := 10 ;
69304: LD_ADDR_VAR 0 4
69308: PUSH
69309: LD_INT 10
69311: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69312: LD_ADDR_VAR 0 8
69316: PUSH
69317: LD_INT 81
69319: PUSH
69320: LD_VAR 0 1
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 92
69331: PUSH
69332: LD_VAR 0 2
69336: PUSH
69337: LD_VAR 0 3
69341: PUSH
69342: LD_VAR 0 4
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 3
69355: PUSH
69356: LD_INT 21
69358: PUSH
69359: LD_INT 3
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: EMPTY
69367: LIST
69368: LIST
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: LIST
69374: PPUSH
69375: CALL_OW 69
69379: ST_TO_ADDR
// if not tmp then
69380: LD_VAR 0 8
69384: NOT
69385: IFFALSE 69389
// exit ;
69387: GO 70947
// for i in tmp do
69389: LD_ADDR_VAR 0 6
69393: PUSH
69394: LD_VAR 0 8
69398: PUSH
69399: FOR_IN
69400: IFFALSE 70922
// begin points := [ 0 , 0 , 0 ] ;
69402: LD_ADDR_VAR 0 9
69406: PUSH
69407: LD_INT 0
69409: PUSH
69410: LD_INT 0
69412: PUSH
69413: LD_INT 0
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: LIST
69420: ST_TO_ADDR
// bpoints := 1 ;
69421: LD_ADDR_VAR 0 10
69425: PUSH
69426: LD_INT 1
69428: ST_TO_ADDR
// case GetType ( i ) of unit_human :
69429: LD_VAR 0 6
69433: PPUSH
69434: CALL_OW 247
69438: PUSH
69439: LD_INT 1
69441: DOUBLE
69442: EQUAL
69443: IFTRUE 69447
69445: GO 70025
69447: POP
// begin if GetClass ( i ) = 1 then
69448: LD_VAR 0 6
69452: PPUSH
69453: CALL_OW 257
69457: PUSH
69458: LD_INT 1
69460: EQUAL
69461: IFFALSE 69482
// points := [ 10 , 5 , 3 ] ;
69463: LD_ADDR_VAR 0 9
69467: PUSH
69468: LD_INT 10
69470: PUSH
69471: LD_INT 5
69473: PUSH
69474: LD_INT 3
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: LIST
69481: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
69482: LD_VAR 0 6
69486: PPUSH
69487: CALL_OW 257
69491: PUSH
69492: LD_INT 2
69494: PUSH
69495: LD_INT 3
69497: PUSH
69498: LD_INT 4
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: LIST
69505: IN
69506: IFFALSE 69527
// points := [ 3 , 2 , 1 ] ;
69508: LD_ADDR_VAR 0 9
69512: PUSH
69513: LD_INT 3
69515: PUSH
69516: LD_INT 2
69518: PUSH
69519: LD_INT 1
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: LIST
69526: ST_TO_ADDR
// if GetClass ( i ) = 5 then
69527: LD_VAR 0 6
69531: PPUSH
69532: CALL_OW 257
69536: PUSH
69537: LD_INT 5
69539: EQUAL
69540: IFFALSE 69561
// points := [ 130 , 5 , 2 ] ;
69542: LD_ADDR_VAR 0 9
69546: PUSH
69547: LD_INT 130
69549: PUSH
69550: LD_INT 5
69552: PUSH
69553: LD_INT 2
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: LIST
69560: ST_TO_ADDR
// if GetClass ( i ) = 8 then
69561: LD_VAR 0 6
69565: PPUSH
69566: CALL_OW 257
69570: PUSH
69571: LD_INT 8
69573: EQUAL
69574: IFFALSE 69595
// points := [ 35 , 35 , 30 ] ;
69576: LD_ADDR_VAR 0 9
69580: PUSH
69581: LD_INT 35
69583: PUSH
69584: LD_INT 35
69586: PUSH
69587: LD_INT 30
69589: PUSH
69590: EMPTY
69591: LIST
69592: LIST
69593: LIST
69594: ST_TO_ADDR
// if GetClass ( i ) = 9 then
69595: LD_VAR 0 6
69599: PPUSH
69600: CALL_OW 257
69604: PUSH
69605: LD_INT 9
69607: EQUAL
69608: IFFALSE 69629
// points := [ 20 , 55 , 40 ] ;
69610: LD_ADDR_VAR 0 9
69614: PUSH
69615: LD_INT 20
69617: PUSH
69618: LD_INT 55
69620: PUSH
69621: LD_INT 40
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: LIST
69628: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
69629: LD_VAR 0 6
69633: PPUSH
69634: CALL_OW 257
69638: PUSH
69639: LD_INT 12
69641: PUSH
69642: LD_INT 16
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: IN
69649: IFFALSE 69670
// points := [ 5 , 3 , 2 ] ;
69651: LD_ADDR_VAR 0 9
69655: PUSH
69656: LD_INT 5
69658: PUSH
69659: LD_INT 3
69661: PUSH
69662: LD_INT 2
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: LIST
69669: ST_TO_ADDR
// if GetClass ( i ) = 17 then
69670: LD_VAR 0 6
69674: PPUSH
69675: CALL_OW 257
69679: PUSH
69680: LD_INT 17
69682: EQUAL
69683: IFFALSE 69704
// points := [ 100 , 50 , 75 ] ;
69685: LD_ADDR_VAR 0 9
69689: PUSH
69690: LD_INT 100
69692: PUSH
69693: LD_INT 50
69695: PUSH
69696: LD_INT 75
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: LIST
69703: ST_TO_ADDR
// if GetClass ( i ) = 15 then
69704: LD_VAR 0 6
69708: PPUSH
69709: CALL_OW 257
69713: PUSH
69714: LD_INT 15
69716: EQUAL
69717: IFFALSE 69738
// points := [ 10 , 5 , 3 ] ;
69719: LD_ADDR_VAR 0 9
69723: PUSH
69724: LD_INT 10
69726: PUSH
69727: LD_INT 5
69729: PUSH
69730: LD_INT 3
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: LIST
69737: ST_TO_ADDR
// if GetClass ( i ) = 14 then
69738: LD_VAR 0 6
69742: PPUSH
69743: CALL_OW 257
69747: PUSH
69748: LD_INT 14
69750: EQUAL
69751: IFFALSE 69772
// points := [ 10 , 0 , 0 ] ;
69753: LD_ADDR_VAR 0 9
69757: PUSH
69758: LD_INT 10
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: LD_INT 0
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: LIST
69771: ST_TO_ADDR
// if GetClass ( i ) = 11 then
69772: LD_VAR 0 6
69776: PPUSH
69777: CALL_OW 257
69781: PUSH
69782: LD_INT 11
69784: EQUAL
69785: IFFALSE 69806
// points := [ 30 , 10 , 5 ] ;
69787: LD_ADDR_VAR 0 9
69791: PUSH
69792: LD_INT 30
69794: PUSH
69795: LD_INT 10
69797: PUSH
69798: LD_INT 5
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: LIST
69805: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
69806: LD_VAR 0 1
69810: PPUSH
69811: LD_INT 5
69813: PPUSH
69814: CALL_OW 321
69818: PUSH
69819: LD_INT 2
69821: EQUAL
69822: IFFALSE 69839
// bpoints := bpoints * 1.8 ;
69824: LD_ADDR_VAR 0 10
69828: PUSH
69829: LD_VAR 0 10
69833: PUSH
69834: LD_REAL  1.80000000000000E+0000
69837: MUL
69838: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
69839: LD_VAR 0 6
69843: PPUSH
69844: CALL_OW 257
69848: PUSH
69849: LD_INT 1
69851: PUSH
69852: LD_INT 2
69854: PUSH
69855: LD_INT 3
69857: PUSH
69858: LD_INT 4
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: IN
69867: PUSH
69868: LD_VAR 0 1
69872: PPUSH
69873: LD_INT 51
69875: PPUSH
69876: CALL_OW 321
69880: PUSH
69881: LD_INT 2
69883: EQUAL
69884: AND
69885: IFFALSE 69902
// bpoints := bpoints * 1.2 ;
69887: LD_ADDR_VAR 0 10
69891: PUSH
69892: LD_VAR 0 10
69896: PUSH
69897: LD_REAL  1.20000000000000E+0000
69900: MUL
69901: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
69902: LD_VAR 0 6
69906: PPUSH
69907: CALL_OW 257
69911: PUSH
69912: LD_INT 5
69914: PUSH
69915: LD_INT 7
69917: PUSH
69918: LD_INT 9
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: LIST
69925: IN
69926: PUSH
69927: LD_VAR 0 1
69931: PPUSH
69932: LD_INT 52
69934: PPUSH
69935: CALL_OW 321
69939: PUSH
69940: LD_INT 2
69942: EQUAL
69943: AND
69944: IFFALSE 69961
// bpoints := bpoints * 1.5 ;
69946: LD_ADDR_VAR 0 10
69950: PUSH
69951: LD_VAR 0 10
69955: PUSH
69956: LD_REAL  1.50000000000000E+0000
69959: MUL
69960: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
69961: LD_VAR 0 1
69965: PPUSH
69966: LD_INT 66
69968: PPUSH
69969: CALL_OW 321
69973: PUSH
69974: LD_INT 2
69976: EQUAL
69977: IFFALSE 69994
// bpoints := bpoints * 1.1 ;
69979: LD_ADDR_VAR 0 10
69983: PUSH
69984: LD_VAR 0 10
69988: PUSH
69989: LD_REAL  1.10000000000000E+0000
69992: MUL
69993: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
69994: LD_ADDR_VAR 0 10
69998: PUSH
69999: LD_VAR 0 10
70003: PUSH
70004: LD_VAR 0 6
70008: PPUSH
70009: LD_INT 1
70011: PPUSH
70012: CALL_OW 259
70016: PUSH
70017: LD_REAL  1.15000000000000E+0000
70020: MUL
70021: MUL
70022: ST_TO_ADDR
// end ; unit_vehicle :
70023: GO 70851
70025: LD_INT 2
70027: DOUBLE
70028: EQUAL
70029: IFTRUE 70033
70031: GO 70839
70033: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
70034: LD_VAR 0 6
70038: PPUSH
70039: CALL_OW 264
70043: PUSH
70044: LD_INT 2
70046: PUSH
70047: LD_INT 42
70049: PUSH
70050: LD_INT 24
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: LIST
70057: IN
70058: IFFALSE 70079
// points := [ 25 , 5 , 3 ] ;
70060: LD_ADDR_VAR 0 9
70064: PUSH
70065: LD_INT 25
70067: PUSH
70068: LD_INT 5
70070: PUSH
70071: LD_INT 3
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: LIST
70078: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
70079: LD_VAR 0 6
70083: PPUSH
70084: CALL_OW 264
70088: PUSH
70089: LD_INT 4
70091: PUSH
70092: LD_INT 43
70094: PUSH
70095: LD_INT 25
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: LIST
70102: IN
70103: IFFALSE 70124
// points := [ 40 , 15 , 5 ] ;
70105: LD_ADDR_VAR 0 9
70109: PUSH
70110: LD_INT 40
70112: PUSH
70113: LD_INT 15
70115: PUSH
70116: LD_INT 5
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: LIST
70123: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
70124: LD_VAR 0 6
70128: PPUSH
70129: CALL_OW 264
70133: PUSH
70134: LD_INT 3
70136: PUSH
70137: LD_INT 23
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: IN
70144: IFFALSE 70165
// points := [ 7 , 25 , 8 ] ;
70146: LD_ADDR_VAR 0 9
70150: PUSH
70151: LD_INT 7
70153: PUSH
70154: LD_INT 25
70156: PUSH
70157: LD_INT 8
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: LIST
70164: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
70165: LD_VAR 0 6
70169: PPUSH
70170: CALL_OW 264
70174: PUSH
70175: LD_INT 5
70177: PUSH
70178: LD_INT 27
70180: PUSH
70181: LD_INT 44
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: LIST
70188: IN
70189: IFFALSE 70210
// points := [ 14 , 50 , 16 ] ;
70191: LD_ADDR_VAR 0 9
70195: PUSH
70196: LD_INT 14
70198: PUSH
70199: LD_INT 50
70201: PUSH
70202: LD_INT 16
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: LIST
70209: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
70210: LD_VAR 0 6
70214: PPUSH
70215: CALL_OW 264
70219: PUSH
70220: LD_INT 6
70222: PUSH
70223: LD_INT 46
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: IN
70230: IFFALSE 70251
// points := [ 32 , 120 , 70 ] ;
70232: LD_ADDR_VAR 0 9
70236: PUSH
70237: LD_INT 32
70239: PUSH
70240: LD_INT 120
70242: PUSH
70243: LD_INT 70
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: LIST
70250: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
70251: LD_VAR 0 6
70255: PPUSH
70256: CALL_OW 264
70260: PUSH
70261: LD_INT 7
70263: PUSH
70264: LD_INT 28
70266: PUSH
70267: LD_INT 45
70269: PUSH
70270: LD_INT 92
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: IN
70279: IFFALSE 70300
// points := [ 35 , 20 , 45 ] ;
70281: LD_ADDR_VAR 0 9
70285: PUSH
70286: LD_INT 35
70288: PUSH
70289: LD_INT 20
70291: PUSH
70292: LD_INT 45
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: LIST
70299: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
70300: LD_VAR 0 6
70304: PPUSH
70305: CALL_OW 264
70309: PUSH
70310: LD_INT 47
70312: PUSH
70313: EMPTY
70314: LIST
70315: IN
70316: IFFALSE 70337
// points := [ 67 , 45 , 75 ] ;
70318: LD_ADDR_VAR 0 9
70322: PUSH
70323: LD_INT 67
70325: PUSH
70326: LD_INT 45
70328: PUSH
70329: LD_INT 75
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: LIST
70336: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
70337: LD_VAR 0 6
70341: PPUSH
70342: CALL_OW 264
70346: PUSH
70347: LD_INT 26
70349: PUSH
70350: EMPTY
70351: LIST
70352: IN
70353: IFFALSE 70374
// points := [ 120 , 30 , 80 ] ;
70355: LD_ADDR_VAR 0 9
70359: PUSH
70360: LD_INT 120
70362: PUSH
70363: LD_INT 30
70365: PUSH
70366: LD_INT 80
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: LIST
70373: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
70374: LD_VAR 0 6
70378: PPUSH
70379: CALL_OW 264
70383: PUSH
70384: LD_INT 22
70386: PUSH
70387: EMPTY
70388: LIST
70389: IN
70390: IFFALSE 70411
// points := [ 40 , 1 , 1 ] ;
70392: LD_ADDR_VAR 0 9
70396: PUSH
70397: LD_INT 40
70399: PUSH
70400: LD_INT 1
70402: PUSH
70403: LD_INT 1
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: LIST
70410: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
70411: LD_VAR 0 6
70415: PPUSH
70416: CALL_OW 264
70420: PUSH
70421: LD_INT 29
70423: PUSH
70424: EMPTY
70425: LIST
70426: IN
70427: IFFALSE 70448
// points := [ 70 , 200 , 400 ] ;
70429: LD_ADDR_VAR 0 9
70433: PUSH
70434: LD_INT 70
70436: PUSH
70437: LD_INT 200
70439: PUSH
70440: LD_INT 400
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: LIST
70447: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
70448: LD_VAR 0 6
70452: PPUSH
70453: CALL_OW 264
70457: PUSH
70458: LD_INT 14
70460: PUSH
70461: LD_INT 53
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: IN
70468: IFFALSE 70489
// points := [ 40 , 10 , 20 ] ;
70470: LD_ADDR_VAR 0 9
70474: PUSH
70475: LD_INT 40
70477: PUSH
70478: LD_INT 10
70480: PUSH
70481: LD_INT 20
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: LIST
70488: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
70489: LD_VAR 0 6
70493: PPUSH
70494: CALL_OW 264
70498: PUSH
70499: LD_INT 9
70501: PUSH
70502: EMPTY
70503: LIST
70504: IN
70505: IFFALSE 70526
// points := [ 5 , 70 , 20 ] ;
70507: LD_ADDR_VAR 0 9
70511: PUSH
70512: LD_INT 5
70514: PUSH
70515: LD_INT 70
70517: PUSH
70518: LD_INT 20
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: LIST
70525: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
70526: LD_VAR 0 6
70530: PPUSH
70531: CALL_OW 264
70535: PUSH
70536: LD_INT 10
70538: PUSH
70539: EMPTY
70540: LIST
70541: IN
70542: IFFALSE 70563
// points := [ 35 , 110 , 70 ] ;
70544: LD_ADDR_VAR 0 9
70548: PUSH
70549: LD_INT 35
70551: PUSH
70552: LD_INT 110
70554: PUSH
70555: LD_INT 70
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: LIST
70562: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
70563: LD_VAR 0 6
70567: PPUSH
70568: CALL_OW 265
70572: PUSH
70573: LD_INT 25
70575: EQUAL
70576: IFFALSE 70597
// points := [ 80 , 65 , 100 ] ;
70578: LD_ADDR_VAR 0 9
70582: PUSH
70583: LD_INT 80
70585: PUSH
70586: LD_INT 65
70588: PUSH
70589: LD_INT 100
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: LIST
70596: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
70597: LD_VAR 0 6
70601: PPUSH
70602: CALL_OW 263
70606: PUSH
70607: LD_INT 1
70609: EQUAL
70610: IFFALSE 70645
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
70612: LD_ADDR_VAR 0 10
70616: PUSH
70617: LD_VAR 0 10
70621: PUSH
70622: LD_VAR 0 6
70626: PPUSH
70627: CALL_OW 311
70631: PPUSH
70632: LD_INT 3
70634: PPUSH
70635: CALL_OW 259
70639: PUSH
70640: LD_INT 4
70642: MUL
70643: MUL
70644: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
70645: LD_VAR 0 6
70649: PPUSH
70650: CALL_OW 263
70654: PUSH
70655: LD_INT 2
70657: EQUAL
70658: IFFALSE 70709
// begin j := IsControledBy ( i ) ;
70660: LD_ADDR_VAR 0 7
70664: PUSH
70665: LD_VAR 0 6
70669: PPUSH
70670: CALL_OW 312
70674: ST_TO_ADDR
// if j then
70675: LD_VAR 0 7
70679: IFFALSE 70709
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
70681: LD_ADDR_VAR 0 10
70685: PUSH
70686: LD_VAR 0 10
70690: PUSH
70691: LD_VAR 0 7
70695: PPUSH
70696: LD_INT 3
70698: PPUSH
70699: CALL_OW 259
70703: PUSH
70704: LD_INT 3
70706: MUL
70707: MUL
70708: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
70709: LD_VAR 0 6
70713: PPUSH
70714: CALL_OW 264
70718: PUSH
70719: LD_INT 5
70721: PUSH
70722: LD_INT 6
70724: PUSH
70725: LD_INT 46
70727: PUSH
70728: LD_INT 44
70730: PUSH
70731: LD_INT 47
70733: PUSH
70734: LD_INT 45
70736: PUSH
70737: LD_INT 28
70739: PUSH
70740: LD_INT 7
70742: PUSH
70743: LD_INT 27
70745: PUSH
70746: LD_INT 29
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: IN
70761: PUSH
70762: LD_VAR 0 1
70766: PPUSH
70767: LD_INT 52
70769: PPUSH
70770: CALL_OW 321
70774: PUSH
70775: LD_INT 2
70777: EQUAL
70778: AND
70779: IFFALSE 70796
// bpoints := bpoints * 1.2 ;
70781: LD_ADDR_VAR 0 10
70785: PUSH
70786: LD_VAR 0 10
70790: PUSH
70791: LD_REAL  1.20000000000000E+0000
70794: MUL
70795: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
70796: LD_VAR 0 6
70800: PPUSH
70801: CALL_OW 264
70805: PUSH
70806: LD_INT 6
70808: PUSH
70809: LD_INT 46
70811: PUSH
70812: LD_INT 47
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: LIST
70819: IN
70820: IFFALSE 70837
// bpoints := bpoints * 1.2 ;
70822: LD_ADDR_VAR 0 10
70826: PUSH
70827: LD_VAR 0 10
70831: PUSH
70832: LD_REAL  1.20000000000000E+0000
70835: MUL
70836: ST_TO_ADDR
// end ; unit_building :
70837: GO 70851
70839: LD_INT 3
70841: DOUBLE
70842: EQUAL
70843: IFTRUE 70847
70845: GO 70850
70847: POP
// ; end ;
70848: GO 70851
70850: POP
// for j = 1 to 3 do
70851: LD_ADDR_VAR 0 7
70855: PUSH
70856: DOUBLE
70857: LD_INT 1
70859: DEC
70860: ST_TO_ADDR
70861: LD_INT 3
70863: PUSH
70864: FOR_TO
70865: IFFALSE 70918
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
70867: LD_ADDR_VAR 0 5
70871: PUSH
70872: LD_VAR 0 5
70876: PPUSH
70877: LD_VAR 0 7
70881: PPUSH
70882: LD_VAR 0 5
70886: PUSH
70887: LD_VAR 0 7
70891: ARRAY
70892: PUSH
70893: LD_VAR 0 9
70897: PUSH
70898: LD_VAR 0 7
70902: ARRAY
70903: PUSH
70904: LD_VAR 0 10
70908: MUL
70909: PLUS
70910: PPUSH
70911: CALL_OW 1
70915: ST_TO_ADDR
70916: GO 70864
70918: POP
70919: POP
// end ;
70920: GO 69399
70922: POP
70923: POP
// result := Replace ( result , 4 , tmp ) ;
70924: LD_ADDR_VAR 0 5
70928: PUSH
70929: LD_VAR 0 5
70933: PPUSH
70934: LD_INT 4
70936: PPUSH
70937: LD_VAR 0 8
70941: PPUSH
70942: CALL_OW 1
70946: ST_TO_ADDR
// end ;
70947: LD_VAR 0 5
70951: RET
// export function DangerAtRange ( unit , range ) ; begin
70952: LD_INT 0
70954: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
70955: LD_ADDR_VAR 0 3
70959: PUSH
70960: LD_VAR 0 1
70964: PPUSH
70965: CALL_OW 255
70969: PPUSH
70970: LD_VAR 0 1
70974: PPUSH
70975: CALL_OW 250
70979: PPUSH
70980: LD_VAR 0 1
70984: PPUSH
70985: CALL_OW 251
70989: PPUSH
70990: LD_VAR 0 2
70994: PPUSH
70995: CALL 69251 0 4
70999: ST_TO_ADDR
// end ;
71000: LD_VAR 0 3
71004: RET
// export function DangerInArea ( side , area ) ; begin
71005: LD_INT 0
71007: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
71008: LD_ADDR_VAR 0 3
71012: PUSH
71013: LD_VAR 0 2
71017: PPUSH
71018: LD_INT 81
71020: PUSH
71021: LD_VAR 0 1
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PPUSH
71030: CALL_OW 70
71034: ST_TO_ADDR
// end ;
71035: LD_VAR 0 3
71039: RET
// export function IsExtension ( b ) ; begin
71040: LD_INT 0
71042: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
71043: LD_ADDR_VAR 0 2
71047: PUSH
71048: LD_VAR 0 1
71052: PUSH
71053: LD_INT 23
71055: PUSH
71056: LD_INT 20
71058: PUSH
71059: LD_INT 22
71061: PUSH
71062: LD_INT 17
71064: PUSH
71065: LD_INT 24
71067: PUSH
71068: LD_INT 21
71070: PUSH
71071: LD_INT 19
71073: PUSH
71074: LD_INT 16
71076: PUSH
71077: LD_INT 25
71079: PUSH
71080: LD_INT 18
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: IN
71095: ST_TO_ADDR
// end ;
71096: LD_VAR 0 2
71100: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
71101: LD_INT 0
71103: PPUSH
71104: PPUSH
71105: PPUSH
// result := [ ] ;
71106: LD_ADDR_VAR 0 4
71110: PUSH
71111: EMPTY
71112: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
71113: LD_ADDR_VAR 0 5
71117: PUSH
71118: LD_VAR 0 2
71122: PPUSH
71123: LD_INT 21
71125: PUSH
71126: LD_INT 3
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PPUSH
71133: CALL_OW 70
71137: ST_TO_ADDR
// if not tmp then
71138: LD_VAR 0 5
71142: NOT
71143: IFFALSE 71147
// exit ;
71145: GO 71211
// if checkLink then
71147: LD_VAR 0 3
71151: IFFALSE 71201
// begin for i in tmp do
71153: LD_ADDR_VAR 0 6
71157: PUSH
71158: LD_VAR 0 5
71162: PUSH
71163: FOR_IN
71164: IFFALSE 71199
// if GetBase ( i ) <> base then
71166: LD_VAR 0 6
71170: PPUSH
71171: CALL_OW 274
71175: PUSH
71176: LD_VAR 0 1
71180: NONEQUAL
71181: IFFALSE 71197
// ComLinkToBase ( base , i ) ;
71183: LD_VAR 0 1
71187: PPUSH
71188: LD_VAR 0 6
71192: PPUSH
71193: CALL_OW 169
71197: GO 71163
71199: POP
71200: POP
// end ; result := tmp ;
71201: LD_ADDR_VAR 0 4
71205: PUSH
71206: LD_VAR 0 5
71210: ST_TO_ADDR
// end ;
71211: LD_VAR 0 4
71215: RET
// export function ComComplete ( units , b ) ; var i ; begin
71216: LD_INT 0
71218: PPUSH
71219: PPUSH
// if not units then
71220: LD_VAR 0 1
71224: NOT
71225: IFFALSE 71229
// exit ;
71227: GO 71319
// for i in units do
71229: LD_ADDR_VAR 0 4
71233: PUSH
71234: LD_VAR 0 1
71238: PUSH
71239: FOR_IN
71240: IFFALSE 71317
// if BuildingStatus ( b ) = bs_build then
71242: LD_VAR 0 2
71246: PPUSH
71247: CALL_OW 461
71251: PUSH
71252: LD_INT 1
71254: EQUAL
71255: IFFALSE 71315
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
71257: LD_VAR 0 4
71261: PPUSH
71262: LD_STRING h
71264: PUSH
71265: LD_VAR 0 2
71269: PPUSH
71270: CALL_OW 250
71274: PUSH
71275: LD_VAR 0 2
71279: PPUSH
71280: CALL_OW 251
71284: PUSH
71285: LD_VAR 0 2
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: LD_INT 0
71295: PUSH
71296: LD_INT 0
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: PUSH
71308: EMPTY
71309: LIST
71310: PPUSH
71311: CALL_OW 446
71315: GO 71239
71317: POP
71318: POP
// end ;
71319: LD_VAR 0 3
71323: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
71324: LD_INT 0
71326: PPUSH
71327: PPUSH
71328: PPUSH
71329: PPUSH
71330: PPUSH
71331: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
71332: LD_VAR 0 1
71336: NOT
71337: PUSH
71338: LD_VAR 0 1
71342: PPUSH
71343: CALL_OW 263
71347: PUSH
71348: LD_INT 2
71350: NONEQUAL
71351: OR
71352: IFFALSE 71356
// exit ;
71354: GO 71672
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
71356: LD_ADDR_VAR 0 6
71360: PUSH
71361: LD_INT 22
71363: PUSH
71364: LD_VAR 0 1
71368: PPUSH
71369: CALL_OW 255
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 2
71380: PUSH
71381: LD_INT 30
71383: PUSH
71384: LD_INT 36
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 34
71393: PUSH
71394: LD_INT 31
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: EMPTY
71402: LIST
71403: LIST
71404: LIST
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PPUSH
71410: CALL_OW 69
71414: ST_TO_ADDR
// if not tmp then
71415: LD_VAR 0 6
71419: NOT
71420: IFFALSE 71424
// exit ;
71422: GO 71672
// result := [ ] ;
71424: LD_ADDR_VAR 0 2
71428: PUSH
71429: EMPTY
71430: ST_TO_ADDR
// for i in tmp do
71431: LD_ADDR_VAR 0 3
71435: PUSH
71436: LD_VAR 0 6
71440: PUSH
71441: FOR_IN
71442: IFFALSE 71513
// begin t := UnitsInside ( i ) ;
71444: LD_ADDR_VAR 0 4
71448: PUSH
71449: LD_VAR 0 3
71453: PPUSH
71454: CALL_OW 313
71458: ST_TO_ADDR
// if t then
71459: LD_VAR 0 4
71463: IFFALSE 71511
// for j in t do
71465: LD_ADDR_VAR 0 7
71469: PUSH
71470: LD_VAR 0 4
71474: PUSH
71475: FOR_IN
71476: IFFALSE 71509
// result := Replace ( result , result + 1 , j ) ;
71478: LD_ADDR_VAR 0 2
71482: PUSH
71483: LD_VAR 0 2
71487: PPUSH
71488: LD_VAR 0 2
71492: PUSH
71493: LD_INT 1
71495: PLUS
71496: PPUSH
71497: LD_VAR 0 7
71501: PPUSH
71502: CALL_OW 1
71506: ST_TO_ADDR
71507: GO 71475
71509: POP
71510: POP
// end ;
71511: GO 71441
71513: POP
71514: POP
// if not result then
71515: LD_VAR 0 2
71519: NOT
71520: IFFALSE 71524
// exit ;
71522: GO 71672
// mech := result [ 1 ] ;
71524: LD_ADDR_VAR 0 5
71528: PUSH
71529: LD_VAR 0 2
71533: PUSH
71534: LD_INT 1
71536: ARRAY
71537: ST_TO_ADDR
// if result > 1 then
71538: LD_VAR 0 2
71542: PUSH
71543: LD_INT 1
71545: GREATER
71546: IFFALSE 71658
// begin for i = 2 to result do
71548: LD_ADDR_VAR 0 3
71552: PUSH
71553: DOUBLE
71554: LD_INT 2
71556: DEC
71557: ST_TO_ADDR
71558: LD_VAR 0 2
71562: PUSH
71563: FOR_TO
71564: IFFALSE 71656
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
71566: LD_ADDR_VAR 0 4
71570: PUSH
71571: LD_VAR 0 2
71575: PUSH
71576: LD_VAR 0 3
71580: ARRAY
71581: PPUSH
71582: LD_INT 3
71584: PPUSH
71585: CALL_OW 259
71589: PUSH
71590: LD_VAR 0 2
71594: PUSH
71595: LD_VAR 0 3
71599: ARRAY
71600: PPUSH
71601: CALL_OW 432
71605: MINUS
71606: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
71607: LD_VAR 0 4
71611: PUSH
71612: LD_VAR 0 5
71616: PPUSH
71617: LD_INT 3
71619: PPUSH
71620: CALL_OW 259
71624: PUSH
71625: LD_VAR 0 5
71629: PPUSH
71630: CALL_OW 432
71634: MINUS
71635: GREATEREQUAL
71636: IFFALSE 71654
// mech := result [ i ] ;
71638: LD_ADDR_VAR 0 5
71642: PUSH
71643: LD_VAR 0 2
71647: PUSH
71648: LD_VAR 0 3
71652: ARRAY
71653: ST_TO_ADDR
// end ;
71654: GO 71563
71656: POP
71657: POP
// end ; ComLinkTo ( vehicle , mech ) ;
71658: LD_VAR 0 1
71662: PPUSH
71663: LD_VAR 0 5
71667: PPUSH
71668: CALL_OW 135
// end ;
71672: LD_VAR 0 2
71676: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
71677: LD_INT 0
71679: PPUSH
71680: PPUSH
71681: PPUSH
71682: PPUSH
71683: PPUSH
71684: PPUSH
71685: PPUSH
71686: PPUSH
71687: PPUSH
71688: PPUSH
71689: PPUSH
71690: PPUSH
71691: PPUSH
// result := [ ] ;
71692: LD_ADDR_VAR 0 7
71696: PUSH
71697: EMPTY
71698: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
71699: LD_VAR 0 1
71703: PPUSH
71704: CALL_OW 266
71708: PUSH
71709: LD_INT 0
71711: PUSH
71712: LD_INT 1
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: IN
71719: NOT
71720: IFFALSE 71724
// exit ;
71722: GO 73358
// if name then
71724: LD_VAR 0 3
71728: IFFALSE 71744
// SetBName ( base_dep , name ) ;
71730: LD_VAR 0 1
71734: PPUSH
71735: LD_VAR 0 3
71739: PPUSH
71740: CALL_OW 500
// base := GetBase ( base_dep ) ;
71744: LD_ADDR_VAR 0 15
71748: PUSH
71749: LD_VAR 0 1
71753: PPUSH
71754: CALL_OW 274
71758: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
71759: LD_ADDR_VAR 0 16
71763: PUSH
71764: LD_VAR 0 1
71768: PPUSH
71769: CALL_OW 255
71773: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
71774: LD_ADDR_VAR 0 17
71778: PUSH
71779: LD_VAR 0 1
71783: PPUSH
71784: CALL_OW 248
71788: ST_TO_ADDR
// if sources then
71789: LD_VAR 0 5
71793: IFFALSE 71840
// for i = 1 to 3 do
71795: LD_ADDR_VAR 0 8
71799: PUSH
71800: DOUBLE
71801: LD_INT 1
71803: DEC
71804: ST_TO_ADDR
71805: LD_INT 3
71807: PUSH
71808: FOR_TO
71809: IFFALSE 71838
// AddResourceType ( base , i , sources [ i ] ) ;
71811: LD_VAR 0 15
71815: PPUSH
71816: LD_VAR 0 8
71820: PPUSH
71821: LD_VAR 0 5
71825: PUSH
71826: LD_VAR 0 8
71830: ARRAY
71831: PPUSH
71832: CALL_OW 276
71836: GO 71808
71838: POP
71839: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
71840: LD_ADDR_VAR 0 18
71844: PUSH
71845: LD_VAR 0 15
71849: PPUSH
71850: LD_VAR 0 2
71854: PPUSH
71855: LD_INT 1
71857: PPUSH
71858: CALL 71101 0 3
71862: ST_TO_ADDR
// InitHc ;
71863: CALL_OW 19
// InitUc ;
71867: CALL_OW 18
// uc_side := side ;
71871: LD_ADDR_OWVAR 20
71875: PUSH
71876: LD_VAR 0 16
71880: ST_TO_ADDR
// uc_nation := nation ;
71881: LD_ADDR_OWVAR 21
71885: PUSH
71886: LD_VAR 0 17
71890: ST_TO_ADDR
// if buildings then
71891: LD_VAR 0 18
71895: IFFALSE 73217
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
71897: LD_ADDR_VAR 0 19
71901: PUSH
71902: LD_VAR 0 18
71906: PPUSH
71907: LD_INT 2
71909: PUSH
71910: LD_INT 30
71912: PUSH
71913: LD_INT 29
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: LD_INT 30
71922: PUSH
71923: LD_INT 30
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: LIST
71934: PPUSH
71935: CALL_OW 72
71939: ST_TO_ADDR
// if tmp then
71940: LD_VAR 0 19
71944: IFFALSE 71992
// for i in tmp do
71946: LD_ADDR_VAR 0 8
71950: PUSH
71951: LD_VAR 0 19
71955: PUSH
71956: FOR_IN
71957: IFFALSE 71990
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
71959: LD_VAR 0 8
71963: PPUSH
71964: CALL_OW 250
71968: PPUSH
71969: LD_VAR 0 8
71973: PPUSH
71974: CALL_OW 251
71978: PPUSH
71979: LD_VAR 0 16
71983: PPUSH
71984: CALL_OW 441
71988: GO 71956
71990: POP
71991: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
71992: LD_VAR 0 18
71996: PPUSH
71997: LD_INT 2
71999: PUSH
72000: LD_INT 30
72002: PUSH
72003: LD_INT 32
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: LD_INT 30
72012: PUSH
72013: LD_INT 33
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: LIST
72024: PPUSH
72025: CALL_OW 72
72029: IFFALSE 72117
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
72031: LD_ADDR_VAR 0 8
72035: PUSH
72036: LD_VAR 0 18
72040: PPUSH
72041: LD_INT 2
72043: PUSH
72044: LD_INT 30
72046: PUSH
72047: LD_INT 32
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 30
72056: PUSH
72057: LD_INT 33
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: LIST
72068: PPUSH
72069: CALL_OW 72
72073: PUSH
72074: FOR_IN
72075: IFFALSE 72115
// begin if not GetBWeapon ( i ) then
72077: LD_VAR 0 8
72081: PPUSH
72082: CALL_OW 269
72086: NOT
72087: IFFALSE 72113
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
72089: LD_VAR 0 8
72093: PPUSH
72094: LD_VAR 0 8
72098: PPUSH
72099: LD_VAR 0 2
72103: PPUSH
72104: CALL 73363 0 2
72108: PPUSH
72109: CALL_OW 431
// end ;
72113: GO 72074
72115: POP
72116: POP
// end ; for i = 1 to personel do
72117: LD_ADDR_VAR 0 8
72121: PUSH
72122: DOUBLE
72123: LD_INT 1
72125: DEC
72126: ST_TO_ADDR
72127: LD_VAR 0 6
72131: PUSH
72132: FOR_TO
72133: IFFALSE 73197
// begin if i > 4 then
72135: LD_VAR 0 8
72139: PUSH
72140: LD_INT 4
72142: GREATER
72143: IFFALSE 72147
// break ;
72145: GO 73197
// case i of 1 :
72147: LD_VAR 0 8
72151: PUSH
72152: LD_INT 1
72154: DOUBLE
72155: EQUAL
72156: IFTRUE 72160
72158: GO 72240
72160: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
72161: LD_ADDR_VAR 0 12
72165: PUSH
72166: LD_VAR 0 18
72170: PPUSH
72171: LD_INT 22
72173: PUSH
72174: LD_VAR 0 16
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 58
72185: PUSH
72186: EMPTY
72187: LIST
72188: PUSH
72189: LD_INT 2
72191: PUSH
72192: LD_INT 30
72194: PUSH
72195: LD_INT 32
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: LD_INT 30
72204: PUSH
72205: LD_INT 4
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 30
72214: PUSH
72215: LD_INT 5
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: LIST
72232: PPUSH
72233: CALL_OW 72
72237: ST_TO_ADDR
72238: GO 72462
72240: LD_INT 2
72242: DOUBLE
72243: EQUAL
72244: IFTRUE 72248
72246: GO 72310
72248: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
72249: LD_ADDR_VAR 0 12
72253: PUSH
72254: LD_VAR 0 18
72258: PPUSH
72259: LD_INT 22
72261: PUSH
72262: LD_VAR 0 16
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 2
72273: PUSH
72274: LD_INT 30
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 30
72286: PUSH
72287: LD_INT 1
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: LIST
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PPUSH
72303: CALL_OW 72
72307: ST_TO_ADDR
72308: GO 72462
72310: LD_INT 3
72312: DOUBLE
72313: EQUAL
72314: IFTRUE 72318
72316: GO 72380
72318: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
72319: LD_ADDR_VAR 0 12
72323: PUSH
72324: LD_VAR 0 18
72328: PPUSH
72329: LD_INT 22
72331: PUSH
72332: LD_VAR 0 16
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 2
72343: PUSH
72344: LD_INT 30
72346: PUSH
72347: LD_INT 2
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 30
72356: PUSH
72357: LD_INT 3
72359: PUSH
72360: EMPTY
72361: LIST
72362: LIST
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: LIST
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PPUSH
72373: CALL_OW 72
72377: ST_TO_ADDR
72378: GO 72462
72380: LD_INT 4
72382: DOUBLE
72383: EQUAL
72384: IFTRUE 72388
72386: GO 72461
72388: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
72389: LD_ADDR_VAR 0 12
72393: PUSH
72394: LD_VAR 0 18
72398: PPUSH
72399: LD_INT 22
72401: PUSH
72402: LD_VAR 0 16
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: LD_INT 2
72413: PUSH
72414: LD_INT 30
72416: PUSH
72417: LD_INT 6
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 30
72426: PUSH
72427: LD_INT 7
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 30
72436: PUSH
72437: LD_INT 8
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PPUSH
72454: CALL_OW 72
72458: ST_TO_ADDR
72459: GO 72462
72461: POP
// if i = 1 then
72462: LD_VAR 0 8
72466: PUSH
72467: LD_INT 1
72469: EQUAL
72470: IFFALSE 72581
// begin tmp := [ ] ;
72472: LD_ADDR_VAR 0 19
72476: PUSH
72477: EMPTY
72478: ST_TO_ADDR
// for j in f do
72479: LD_ADDR_VAR 0 9
72483: PUSH
72484: LD_VAR 0 12
72488: PUSH
72489: FOR_IN
72490: IFFALSE 72563
// if GetBType ( j ) = b_bunker then
72492: LD_VAR 0 9
72496: PPUSH
72497: CALL_OW 266
72501: PUSH
72502: LD_INT 32
72504: EQUAL
72505: IFFALSE 72532
// tmp := Insert ( tmp , 1 , j ) else
72507: LD_ADDR_VAR 0 19
72511: PUSH
72512: LD_VAR 0 19
72516: PPUSH
72517: LD_INT 1
72519: PPUSH
72520: LD_VAR 0 9
72524: PPUSH
72525: CALL_OW 2
72529: ST_TO_ADDR
72530: GO 72561
// tmp := Insert ( tmp , tmp + 1 , j ) ;
72532: LD_ADDR_VAR 0 19
72536: PUSH
72537: LD_VAR 0 19
72541: PPUSH
72542: LD_VAR 0 19
72546: PUSH
72547: LD_INT 1
72549: PLUS
72550: PPUSH
72551: LD_VAR 0 9
72555: PPUSH
72556: CALL_OW 2
72560: ST_TO_ADDR
72561: GO 72489
72563: POP
72564: POP
// if tmp then
72565: LD_VAR 0 19
72569: IFFALSE 72581
// f := tmp ;
72571: LD_ADDR_VAR 0 12
72575: PUSH
72576: LD_VAR 0 19
72580: ST_TO_ADDR
// end ; x := personel [ i ] ;
72581: LD_ADDR_VAR 0 13
72585: PUSH
72586: LD_VAR 0 6
72590: PUSH
72591: LD_VAR 0 8
72595: ARRAY
72596: ST_TO_ADDR
// if x = - 1 then
72597: LD_VAR 0 13
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: EQUAL
72606: IFFALSE 72815
// begin for j in f do
72608: LD_ADDR_VAR 0 9
72612: PUSH
72613: LD_VAR 0 12
72617: PUSH
72618: FOR_IN
72619: IFFALSE 72811
// repeat InitHc ;
72621: CALL_OW 19
// if GetBType ( j ) = b_barracks then
72625: LD_VAR 0 9
72629: PPUSH
72630: CALL_OW 266
72634: PUSH
72635: LD_INT 5
72637: EQUAL
72638: IFFALSE 72708
// begin if UnitsInside ( j ) < 3 then
72640: LD_VAR 0 9
72644: PPUSH
72645: CALL_OW 313
72649: PUSH
72650: LD_INT 3
72652: LESS
72653: IFFALSE 72689
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
72655: LD_INT 0
72657: PPUSH
72658: LD_INT 5
72660: PUSH
72661: LD_INT 8
72663: PUSH
72664: LD_INT 9
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: LIST
72671: PUSH
72672: LD_VAR 0 17
72676: ARRAY
72677: PPUSH
72678: LD_VAR 0 4
72682: PPUSH
72683: CALL_OW 380
72687: GO 72706
// PrepareHuman ( false , i , skill ) ;
72689: LD_INT 0
72691: PPUSH
72692: LD_VAR 0 8
72696: PPUSH
72697: LD_VAR 0 4
72701: PPUSH
72702: CALL_OW 380
// end else
72706: GO 72725
// PrepareHuman ( false , i , skill ) ;
72708: LD_INT 0
72710: PPUSH
72711: LD_VAR 0 8
72715: PPUSH
72716: LD_VAR 0 4
72720: PPUSH
72721: CALL_OW 380
// un := CreateHuman ;
72725: LD_ADDR_VAR 0 14
72729: PUSH
72730: CALL_OW 44
72734: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72735: LD_ADDR_VAR 0 7
72739: PUSH
72740: LD_VAR 0 7
72744: PPUSH
72745: LD_INT 1
72747: PPUSH
72748: LD_VAR 0 14
72752: PPUSH
72753: CALL_OW 2
72757: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
72758: LD_VAR 0 14
72762: PPUSH
72763: LD_VAR 0 9
72767: PPUSH
72768: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
72772: LD_VAR 0 9
72776: PPUSH
72777: CALL_OW 313
72781: PUSH
72782: LD_INT 6
72784: EQUAL
72785: PUSH
72786: LD_VAR 0 9
72790: PPUSH
72791: CALL_OW 266
72795: PUSH
72796: LD_INT 32
72798: PUSH
72799: LD_INT 31
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: IN
72806: OR
72807: IFFALSE 72621
72809: GO 72618
72811: POP
72812: POP
// end else
72813: GO 73195
// for j = 1 to x do
72815: LD_ADDR_VAR 0 9
72819: PUSH
72820: DOUBLE
72821: LD_INT 1
72823: DEC
72824: ST_TO_ADDR
72825: LD_VAR 0 13
72829: PUSH
72830: FOR_TO
72831: IFFALSE 73193
// begin InitHc ;
72833: CALL_OW 19
// if not f then
72837: LD_VAR 0 12
72841: NOT
72842: IFFALSE 72931
// begin PrepareHuman ( false , i , skill ) ;
72844: LD_INT 0
72846: PPUSH
72847: LD_VAR 0 8
72851: PPUSH
72852: LD_VAR 0 4
72856: PPUSH
72857: CALL_OW 380
// un := CreateHuman ;
72861: LD_ADDR_VAR 0 14
72865: PUSH
72866: CALL_OW 44
72870: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
72871: LD_ADDR_VAR 0 7
72875: PUSH
72876: LD_VAR 0 7
72880: PPUSH
72881: LD_INT 1
72883: PPUSH
72884: LD_VAR 0 14
72888: PPUSH
72889: CALL_OW 2
72893: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
72894: LD_VAR 0 14
72898: PPUSH
72899: LD_VAR 0 1
72903: PPUSH
72904: CALL_OW 250
72908: PPUSH
72909: LD_VAR 0 1
72913: PPUSH
72914: CALL_OW 251
72918: PPUSH
72919: LD_INT 10
72921: PPUSH
72922: LD_INT 0
72924: PPUSH
72925: CALL_OW 50
// continue ;
72929: GO 72830
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
72931: LD_VAR 0 12
72935: PUSH
72936: LD_INT 1
72938: ARRAY
72939: PPUSH
72940: CALL_OW 313
72944: PUSH
72945: LD_VAR 0 12
72949: PUSH
72950: LD_INT 1
72952: ARRAY
72953: PPUSH
72954: CALL_OW 266
72958: PUSH
72959: LD_INT 32
72961: PUSH
72962: LD_INT 31
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: IN
72969: AND
72970: PUSH
72971: LD_VAR 0 12
72975: PUSH
72976: LD_INT 1
72978: ARRAY
72979: PPUSH
72980: CALL_OW 313
72984: PUSH
72985: LD_INT 6
72987: EQUAL
72988: OR
72989: IFFALSE 73009
// f := Delete ( f , 1 ) ;
72991: LD_ADDR_VAR 0 12
72995: PUSH
72996: LD_VAR 0 12
73000: PPUSH
73001: LD_INT 1
73003: PPUSH
73004: CALL_OW 3
73008: ST_TO_ADDR
// if not f then
73009: LD_VAR 0 12
73013: NOT
73014: IFFALSE 73032
// begin x := x + 2 ;
73016: LD_ADDR_VAR 0 13
73020: PUSH
73021: LD_VAR 0 13
73025: PUSH
73026: LD_INT 2
73028: PLUS
73029: ST_TO_ADDR
// continue ;
73030: GO 72830
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
73032: LD_VAR 0 12
73036: PUSH
73037: LD_INT 1
73039: ARRAY
73040: PPUSH
73041: CALL_OW 266
73045: PUSH
73046: LD_INT 5
73048: EQUAL
73049: IFFALSE 73123
// begin if UnitsInside ( f [ 1 ] ) < 3 then
73051: LD_VAR 0 12
73055: PUSH
73056: LD_INT 1
73058: ARRAY
73059: PPUSH
73060: CALL_OW 313
73064: PUSH
73065: LD_INT 3
73067: LESS
73068: IFFALSE 73104
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73070: LD_INT 0
73072: PPUSH
73073: LD_INT 5
73075: PUSH
73076: LD_INT 8
73078: PUSH
73079: LD_INT 9
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: LIST
73086: PUSH
73087: LD_VAR 0 17
73091: ARRAY
73092: PPUSH
73093: LD_VAR 0 4
73097: PPUSH
73098: CALL_OW 380
73102: GO 73121
// PrepareHuman ( false , i , skill ) ;
73104: LD_INT 0
73106: PPUSH
73107: LD_VAR 0 8
73111: PPUSH
73112: LD_VAR 0 4
73116: PPUSH
73117: CALL_OW 380
// end else
73121: GO 73140
// PrepareHuman ( false , i , skill ) ;
73123: LD_INT 0
73125: PPUSH
73126: LD_VAR 0 8
73130: PPUSH
73131: LD_VAR 0 4
73135: PPUSH
73136: CALL_OW 380
// un := CreateHuman ;
73140: LD_ADDR_VAR 0 14
73144: PUSH
73145: CALL_OW 44
73149: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73150: LD_ADDR_VAR 0 7
73154: PUSH
73155: LD_VAR 0 7
73159: PPUSH
73160: LD_INT 1
73162: PPUSH
73163: LD_VAR 0 14
73167: PPUSH
73168: CALL_OW 2
73172: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
73173: LD_VAR 0 14
73177: PPUSH
73178: LD_VAR 0 12
73182: PUSH
73183: LD_INT 1
73185: ARRAY
73186: PPUSH
73187: CALL_OW 52
// end ;
73191: GO 72830
73193: POP
73194: POP
// end ;
73195: GO 72132
73197: POP
73198: POP
// result := result ^ buildings ;
73199: LD_ADDR_VAR 0 7
73203: PUSH
73204: LD_VAR 0 7
73208: PUSH
73209: LD_VAR 0 18
73213: ADD
73214: ST_TO_ADDR
// end else
73215: GO 73358
// begin for i = 1 to personel do
73217: LD_ADDR_VAR 0 8
73221: PUSH
73222: DOUBLE
73223: LD_INT 1
73225: DEC
73226: ST_TO_ADDR
73227: LD_VAR 0 6
73231: PUSH
73232: FOR_TO
73233: IFFALSE 73356
// begin if i > 4 then
73235: LD_VAR 0 8
73239: PUSH
73240: LD_INT 4
73242: GREATER
73243: IFFALSE 73247
// break ;
73245: GO 73356
// x := personel [ i ] ;
73247: LD_ADDR_VAR 0 13
73251: PUSH
73252: LD_VAR 0 6
73256: PUSH
73257: LD_VAR 0 8
73261: ARRAY
73262: ST_TO_ADDR
// if x = - 1 then
73263: LD_VAR 0 13
73267: PUSH
73268: LD_INT 1
73270: NEG
73271: EQUAL
73272: IFFALSE 73276
// continue ;
73274: GO 73232
// PrepareHuman ( false , i , skill ) ;
73276: LD_INT 0
73278: PPUSH
73279: LD_VAR 0 8
73283: PPUSH
73284: LD_VAR 0 4
73288: PPUSH
73289: CALL_OW 380
// un := CreateHuman ;
73293: LD_ADDR_VAR 0 14
73297: PUSH
73298: CALL_OW 44
73302: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
73303: LD_VAR 0 14
73307: PPUSH
73308: LD_VAR 0 1
73312: PPUSH
73313: CALL_OW 250
73317: PPUSH
73318: LD_VAR 0 1
73322: PPUSH
73323: CALL_OW 251
73327: PPUSH
73328: LD_INT 10
73330: PPUSH
73331: LD_INT 0
73333: PPUSH
73334: CALL_OW 50
// result := result ^ un ;
73338: LD_ADDR_VAR 0 7
73342: PUSH
73343: LD_VAR 0 7
73347: PUSH
73348: LD_VAR 0 14
73352: ADD
73353: ST_TO_ADDR
// end ;
73354: GO 73232
73356: POP
73357: POP
// end ; end ;
73358: LD_VAR 0 7
73362: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
73363: LD_INT 0
73365: PPUSH
73366: PPUSH
73367: PPUSH
73368: PPUSH
73369: PPUSH
73370: PPUSH
73371: PPUSH
73372: PPUSH
73373: PPUSH
73374: PPUSH
73375: PPUSH
73376: PPUSH
73377: PPUSH
73378: PPUSH
73379: PPUSH
73380: PPUSH
// result := false ;
73381: LD_ADDR_VAR 0 3
73385: PUSH
73386: LD_INT 0
73388: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
73389: LD_VAR 0 1
73393: NOT
73394: PUSH
73395: LD_VAR 0 1
73399: PPUSH
73400: CALL_OW 266
73404: PUSH
73405: LD_INT 32
73407: PUSH
73408: LD_INT 33
73410: PUSH
73411: EMPTY
73412: LIST
73413: LIST
73414: IN
73415: NOT
73416: OR
73417: IFFALSE 73421
// exit ;
73419: GO 74530
// nat := GetNation ( tower ) ;
73421: LD_ADDR_VAR 0 12
73425: PUSH
73426: LD_VAR 0 1
73430: PPUSH
73431: CALL_OW 248
73435: ST_TO_ADDR
// side := GetSide ( tower ) ;
73436: LD_ADDR_VAR 0 16
73440: PUSH
73441: LD_VAR 0 1
73445: PPUSH
73446: CALL_OW 255
73450: ST_TO_ADDR
// x := GetX ( tower ) ;
73451: LD_ADDR_VAR 0 10
73455: PUSH
73456: LD_VAR 0 1
73460: PPUSH
73461: CALL_OW 250
73465: ST_TO_ADDR
// y := GetY ( tower ) ;
73466: LD_ADDR_VAR 0 11
73470: PUSH
73471: LD_VAR 0 1
73475: PPUSH
73476: CALL_OW 251
73480: ST_TO_ADDR
// if not x or not y then
73481: LD_VAR 0 10
73485: NOT
73486: PUSH
73487: LD_VAR 0 11
73491: NOT
73492: OR
73493: IFFALSE 73497
// exit ;
73495: GO 74530
// weapon := 0 ;
73497: LD_ADDR_VAR 0 18
73501: PUSH
73502: LD_INT 0
73504: ST_TO_ADDR
// fac_list := [ ] ;
73505: LD_ADDR_VAR 0 17
73509: PUSH
73510: EMPTY
73511: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
73512: LD_ADDR_VAR 0 6
73516: PUSH
73517: LD_VAR 0 1
73521: PPUSH
73522: CALL_OW 274
73526: PPUSH
73527: LD_VAR 0 2
73531: PPUSH
73532: LD_INT 0
73534: PPUSH
73535: CALL 71101 0 3
73539: PPUSH
73540: LD_INT 30
73542: PUSH
73543: LD_INT 3
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PPUSH
73550: CALL_OW 72
73554: ST_TO_ADDR
// if not factories then
73555: LD_VAR 0 6
73559: NOT
73560: IFFALSE 73564
// exit ;
73562: GO 74530
// for i in factories do
73564: LD_ADDR_VAR 0 8
73568: PUSH
73569: LD_VAR 0 6
73573: PUSH
73574: FOR_IN
73575: IFFALSE 73600
// fac_list := fac_list union AvailableWeaponList ( i ) ;
73577: LD_ADDR_VAR 0 17
73581: PUSH
73582: LD_VAR 0 17
73586: PUSH
73587: LD_VAR 0 8
73591: PPUSH
73592: CALL_OW 478
73596: UNION
73597: ST_TO_ADDR
73598: GO 73574
73600: POP
73601: POP
// if not fac_list then
73602: LD_VAR 0 17
73606: NOT
73607: IFFALSE 73611
// exit ;
73609: GO 74530
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
73611: LD_ADDR_VAR 0 5
73615: PUSH
73616: LD_INT 4
73618: PUSH
73619: LD_INT 5
73621: PUSH
73622: LD_INT 9
73624: PUSH
73625: LD_INT 10
73627: PUSH
73628: LD_INT 6
73630: PUSH
73631: LD_INT 7
73633: PUSH
73634: LD_INT 11
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: LIST
73641: LIST
73642: LIST
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 27
73648: PUSH
73649: LD_INT 28
73651: PUSH
73652: LD_INT 26
73654: PUSH
73655: LD_INT 30
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: LIST
73662: LIST
73663: PUSH
73664: LD_INT 43
73666: PUSH
73667: LD_INT 44
73669: PUSH
73670: LD_INT 46
73672: PUSH
73673: LD_INT 45
73675: PUSH
73676: LD_INT 47
73678: PUSH
73679: LD_INT 49
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: LIST
73686: LIST
73687: LIST
73688: LIST
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: LIST
73694: PUSH
73695: LD_VAR 0 12
73699: ARRAY
73700: ST_TO_ADDR
// list := list isect fac_list ;
73701: LD_ADDR_VAR 0 5
73705: PUSH
73706: LD_VAR 0 5
73710: PUSH
73711: LD_VAR 0 17
73715: ISECT
73716: ST_TO_ADDR
// if not list then
73717: LD_VAR 0 5
73721: NOT
73722: IFFALSE 73726
// exit ;
73724: GO 74530
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
73726: LD_VAR 0 12
73730: PUSH
73731: LD_INT 3
73733: EQUAL
73734: PUSH
73735: LD_INT 49
73737: PUSH
73738: LD_VAR 0 5
73742: IN
73743: AND
73744: PUSH
73745: LD_INT 31
73747: PPUSH
73748: LD_VAR 0 16
73752: PPUSH
73753: CALL_OW 321
73757: PUSH
73758: LD_INT 2
73760: EQUAL
73761: AND
73762: IFFALSE 73822
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
73764: LD_INT 22
73766: PUSH
73767: LD_VAR 0 16
73771: PUSH
73772: EMPTY
73773: LIST
73774: LIST
73775: PUSH
73776: LD_INT 35
73778: PUSH
73779: LD_INT 49
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 91
73788: PUSH
73789: LD_VAR 0 1
73793: PUSH
73794: LD_INT 10
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: LIST
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: LIST
73806: PPUSH
73807: CALL_OW 69
73811: NOT
73812: IFFALSE 73822
// weapon := ru_time_lapser ;
73814: LD_ADDR_VAR 0 18
73818: PUSH
73819: LD_INT 49
73821: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
73822: LD_VAR 0 12
73826: PUSH
73827: LD_INT 1
73829: PUSH
73830: LD_INT 2
73832: PUSH
73833: EMPTY
73834: LIST
73835: LIST
73836: IN
73837: PUSH
73838: LD_INT 11
73840: PUSH
73841: LD_VAR 0 5
73845: IN
73846: PUSH
73847: LD_INT 30
73849: PUSH
73850: LD_VAR 0 5
73854: IN
73855: OR
73856: AND
73857: PUSH
73858: LD_INT 6
73860: PPUSH
73861: LD_VAR 0 16
73865: PPUSH
73866: CALL_OW 321
73870: PUSH
73871: LD_INT 2
73873: EQUAL
73874: AND
73875: IFFALSE 74040
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
73877: LD_INT 22
73879: PUSH
73880: LD_VAR 0 16
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 2
73891: PUSH
73892: LD_INT 35
73894: PUSH
73895: LD_INT 11
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 35
73904: PUSH
73905: LD_INT 30
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: EMPTY
73913: LIST
73914: LIST
73915: LIST
73916: PUSH
73917: LD_INT 91
73919: PUSH
73920: LD_VAR 0 1
73924: PUSH
73925: LD_INT 18
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: LIST
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: LIST
73937: PPUSH
73938: CALL_OW 69
73942: NOT
73943: PUSH
73944: LD_INT 22
73946: PUSH
73947: LD_VAR 0 16
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: LD_INT 30
73961: PUSH
73962: LD_INT 32
73964: PUSH
73965: EMPTY
73966: LIST
73967: LIST
73968: PUSH
73969: LD_INT 30
73971: PUSH
73972: LD_INT 33
73974: PUSH
73975: EMPTY
73976: LIST
73977: LIST
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 91
73986: PUSH
73987: LD_VAR 0 1
73991: PUSH
73992: LD_INT 12
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: LIST
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: LIST
74004: PUSH
74005: EMPTY
74006: LIST
74007: PPUSH
74008: CALL_OW 69
74012: PUSH
74013: LD_INT 2
74015: GREATER
74016: AND
74017: IFFALSE 74040
// weapon := [ us_radar , ar_radar ] [ nat ] ;
74019: LD_ADDR_VAR 0 18
74023: PUSH
74024: LD_INT 11
74026: PUSH
74027: LD_INT 30
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_VAR 0 12
74038: ARRAY
74039: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
74040: LD_VAR 0 18
74044: NOT
74045: PUSH
74046: LD_INT 40
74048: PPUSH
74049: LD_VAR 0 16
74053: PPUSH
74054: CALL_OW 321
74058: PUSH
74059: LD_INT 2
74061: EQUAL
74062: AND
74063: PUSH
74064: LD_INT 7
74066: PUSH
74067: LD_VAR 0 5
74071: IN
74072: PUSH
74073: LD_INT 28
74075: PUSH
74076: LD_VAR 0 5
74080: IN
74081: OR
74082: PUSH
74083: LD_INT 45
74085: PUSH
74086: LD_VAR 0 5
74090: IN
74091: OR
74092: AND
74093: IFFALSE 74347
// begin hex := GetHexInfo ( x , y ) ;
74095: LD_ADDR_VAR 0 4
74099: PUSH
74100: LD_VAR 0 10
74104: PPUSH
74105: LD_VAR 0 11
74109: PPUSH
74110: CALL_OW 546
74114: ST_TO_ADDR
// if hex [ 1 ] then
74115: LD_VAR 0 4
74119: PUSH
74120: LD_INT 1
74122: ARRAY
74123: IFFALSE 74127
// exit ;
74125: GO 74530
// height := hex [ 2 ] ;
74127: LD_ADDR_VAR 0 15
74131: PUSH
74132: LD_VAR 0 4
74136: PUSH
74137: LD_INT 2
74139: ARRAY
74140: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
74141: LD_ADDR_VAR 0 14
74145: PUSH
74146: LD_INT 0
74148: PUSH
74149: LD_INT 2
74151: PUSH
74152: LD_INT 3
74154: PUSH
74155: LD_INT 5
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: LIST
74162: LIST
74163: ST_TO_ADDR
// for i in tmp do
74164: LD_ADDR_VAR 0 8
74168: PUSH
74169: LD_VAR 0 14
74173: PUSH
74174: FOR_IN
74175: IFFALSE 74345
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
74177: LD_ADDR_VAR 0 9
74181: PUSH
74182: LD_VAR 0 10
74186: PPUSH
74187: LD_VAR 0 8
74191: PPUSH
74192: LD_INT 5
74194: PPUSH
74195: CALL_OW 272
74199: PUSH
74200: LD_VAR 0 11
74204: PPUSH
74205: LD_VAR 0 8
74209: PPUSH
74210: LD_INT 5
74212: PPUSH
74213: CALL_OW 273
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74222: LD_VAR 0 9
74226: PUSH
74227: LD_INT 1
74229: ARRAY
74230: PPUSH
74231: LD_VAR 0 9
74235: PUSH
74236: LD_INT 2
74238: ARRAY
74239: PPUSH
74240: CALL_OW 488
74244: IFFALSE 74343
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
74246: LD_ADDR_VAR 0 4
74250: PUSH
74251: LD_VAR 0 9
74255: PUSH
74256: LD_INT 1
74258: ARRAY
74259: PPUSH
74260: LD_VAR 0 9
74264: PUSH
74265: LD_INT 2
74267: ARRAY
74268: PPUSH
74269: CALL_OW 546
74273: ST_TO_ADDR
// if hex [ 1 ] then
74274: LD_VAR 0 4
74278: PUSH
74279: LD_INT 1
74281: ARRAY
74282: IFFALSE 74286
// continue ;
74284: GO 74174
// h := hex [ 2 ] ;
74286: LD_ADDR_VAR 0 13
74290: PUSH
74291: LD_VAR 0 4
74295: PUSH
74296: LD_INT 2
74298: ARRAY
74299: ST_TO_ADDR
// if h + 7 < height then
74300: LD_VAR 0 13
74304: PUSH
74305: LD_INT 7
74307: PLUS
74308: PUSH
74309: LD_VAR 0 15
74313: LESS
74314: IFFALSE 74343
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
74316: LD_ADDR_VAR 0 18
74320: PUSH
74321: LD_INT 7
74323: PUSH
74324: LD_INT 28
74326: PUSH
74327: LD_INT 45
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: LIST
74334: PUSH
74335: LD_VAR 0 12
74339: ARRAY
74340: ST_TO_ADDR
// break ;
74341: GO 74345
// end ; end ; end ;
74343: GO 74174
74345: POP
74346: POP
// end ; if not weapon then
74347: LD_VAR 0 18
74351: NOT
74352: IFFALSE 74412
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
74354: LD_ADDR_VAR 0 5
74358: PUSH
74359: LD_VAR 0 5
74363: PUSH
74364: LD_INT 11
74366: PUSH
74367: LD_INT 30
74369: PUSH
74370: LD_INT 49
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: LIST
74377: DIFF
74378: ST_TO_ADDR
// if not list then
74379: LD_VAR 0 5
74383: NOT
74384: IFFALSE 74388
// exit ;
74386: GO 74530
// weapon := list [ rand ( 1 , list ) ] ;
74388: LD_ADDR_VAR 0 18
74392: PUSH
74393: LD_VAR 0 5
74397: PUSH
74398: LD_INT 1
74400: PPUSH
74401: LD_VAR 0 5
74405: PPUSH
74406: CALL_OW 12
74410: ARRAY
74411: ST_TO_ADDR
// end ; if weapon then
74412: LD_VAR 0 18
74416: IFFALSE 74530
// begin tmp := CostOfWeapon ( weapon ) ;
74418: LD_ADDR_VAR 0 14
74422: PUSH
74423: LD_VAR 0 18
74427: PPUSH
74428: CALL_OW 451
74432: ST_TO_ADDR
// j := GetBase ( tower ) ;
74433: LD_ADDR_VAR 0 9
74437: PUSH
74438: LD_VAR 0 1
74442: PPUSH
74443: CALL_OW 274
74447: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
74448: LD_VAR 0 9
74452: PPUSH
74453: LD_INT 1
74455: PPUSH
74456: CALL_OW 275
74460: PUSH
74461: LD_VAR 0 14
74465: PUSH
74466: LD_INT 1
74468: ARRAY
74469: GREATEREQUAL
74470: PUSH
74471: LD_VAR 0 9
74475: PPUSH
74476: LD_INT 2
74478: PPUSH
74479: CALL_OW 275
74483: PUSH
74484: LD_VAR 0 14
74488: PUSH
74489: LD_INT 2
74491: ARRAY
74492: GREATEREQUAL
74493: AND
74494: PUSH
74495: LD_VAR 0 9
74499: PPUSH
74500: LD_INT 3
74502: PPUSH
74503: CALL_OW 275
74507: PUSH
74508: LD_VAR 0 14
74512: PUSH
74513: LD_INT 3
74515: ARRAY
74516: GREATEREQUAL
74517: AND
74518: IFFALSE 74530
// result := weapon ;
74520: LD_ADDR_VAR 0 3
74524: PUSH
74525: LD_VAR 0 18
74529: ST_TO_ADDR
// end ; end ;
74530: LD_VAR 0 3
74534: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
74535: LD_INT 0
74537: PPUSH
74538: PPUSH
// result := true ;
74539: LD_ADDR_VAR 0 3
74543: PUSH
74544: LD_INT 1
74546: ST_TO_ADDR
// if array1 = array2 then
74547: LD_VAR 0 1
74551: PUSH
74552: LD_VAR 0 2
74556: EQUAL
74557: IFFALSE 74617
// begin for i = 1 to array1 do
74559: LD_ADDR_VAR 0 4
74563: PUSH
74564: DOUBLE
74565: LD_INT 1
74567: DEC
74568: ST_TO_ADDR
74569: LD_VAR 0 1
74573: PUSH
74574: FOR_TO
74575: IFFALSE 74613
// if array1 [ i ] <> array2 [ i ] then
74577: LD_VAR 0 1
74581: PUSH
74582: LD_VAR 0 4
74586: ARRAY
74587: PUSH
74588: LD_VAR 0 2
74592: PUSH
74593: LD_VAR 0 4
74597: ARRAY
74598: NONEQUAL
74599: IFFALSE 74611
// begin result := false ;
74601: LD_ADDR_VAR 0 3
74605: PUSH
74606: LD_INT 0
74608: ST_TO_ADDR
// break ;
74609: GO 74613
// end ;
74611: GO 74574
74613: POP
74614: POP
// end else
74615: GO 74625
// result := false ;
74617: LD_ADDR_VAR 0 3
74621: PUSH
74622: LD_INT 0
74624: ST_TO_ADDR
// end ;
74625: LD_VAR 0 3
74629: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
74630: LD_INT 0
74632: PPUSH
74633: PPUSH
// if not array1 or not array2 then
74634: LD_VAR 0 1
74638: NOT
74639: PUSH
74640: LD_VAR 0 2
74644: NOT
74645: OR
74646: IFFALSE 74650
// exit ;
74648: GO 74714
// result := true ;
74650: LD_ADDR_VAR 0 3
74654: PUSH
74655: LD_INT 1
74657: ST_TO_ADDR
// for i = 1 to array1 do
74658: LD_ADDR_VAR 0 4
74662: PUSH
74663: DOUBLE
74664: LD_INT 1
74666: DEC
74667: ST_TO_ADDR
74668: LD_VAR 0 1
74672: PUSH
74673: FOR_TO
74674: IFFALSE 74712
// if array1 [ i ] <> array2 [ i ] then
74676: LD_VAR 0 1
74680: PUSH
74681: LD_VAR 0 4
74685: ARRAY
74686: PUSH
74687: LD_VAR 0 2
74691: PUSH
74692: LD_VAR 0 4
74696: ARRAY
74697: NONEQUAL
74698: IFFALSE 74710
// begin result := false ;
74700: LD_ADDR_VAR 0 3
74704: PUSH
74705: LD_INT 0
74707: ST_TO_ADDR
// break ;
74708: GO 74712
// end ;
74710: GO 74673
74712: POP
74713: POP
// end ;
74714: LD_VAR 0 3
74718: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
74719: LD_INT 0
74721: PPUSH
74722: PPUSH
74723: PPUSH
// pom := GetBase ( fac ) ;
74724: LD_ADDR_VAR 0 5
74728: PUSH
74729: LD_VAR 0 1
74733: PPUSH
74734: CALL_OW 274
74738: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
74739: LD_ADDR_VAR 0 4
74743: PUSH
74744: LD_VAR 0 2
74748: PUSH
74749: LD_INT 1
74751: ARRAY
74752: PPUSH
74753: LD_VAR 0 2
74757: PUSH
74758: LD_INT 2
74760: ARRAY
74761: PPUSH
74762: LD_VAR 0 2
74766: PUSH
74767: LD_INT 3
74769: ARRAY
74770: PPUSH
74771: LD_VAR 0 2
74775: PUSH
74776: LD_INT 4
74778: ARRAY
74779: PPUSH
74780: CALL_OW 449
74784: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74785: LD_ADDR_VAR 0 3
74789: PUSH
74790: LD_VAR 0 5
74794: PPUSH
74795: LD_INT 1
74797: PPUSH
74798: CALL_OW 275
74802: PUSH
74803: LD_VAR 0 4
74807: PUSH
74808: LD_INT 1
74810: ARRAY
74811: GREATEREQUAL
74812: PUSH
74813: LD_VAR 0 5
74817: PPUSH
74818: LD_INT 2
74820: PPUSH
74821: CALL_OW 275
74825: PUSH
74826: LD_VAR 0 4
74830: PUSH
74831: LD_INT 2
74833: ARRAY
74834: GREATEREQUAL
74835: AND
74836: PUSH
74837: LD_VAR 0 5
74841: PPUSH
74842: LD_INT 3
74844: PPUSH
74845: CALL_OW 275
74849: PUSH
74850: LD_VAR 0 4
74854: PUSH
74855: LD_INT 3
74857: ARRAY
74858: GREATEREQUAL
74859: AND
74860: ST_TO_ADDR
// end ;
74861: LD_VAR 0 3
74865: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
74866: LD_INT 0
74868: PPUSH
74869: PPUSH
74870: PPUSH
74871: PPUSH
// pom := GetBase ( building ) ;
74872: LD_ADDR_VAR 0 3
74876: PUSH
74877: LD_VAR 0 1
74881: PPUSH
74882: CALL_OW 274
74886: ST_TO_ADDR
// if not pom then
74887: LD_VAR 0 3
74891: NOT
74892: IFFALSE 74896
// exit ;
74894: GO 75066
// btype := GetBType ( building ) ;
74896: LD_ADDR_VAR 0 5
74900: PUSH
74901: LD_VAR 0 1
74905: PPUSH
74906: CALL_OW 266
74910: ST_TO_ADDR
// if btype = b_armoury then
74911: LD_VAR 0 5
74915: PUSH
74916: LD_INT 4
74918: EQUAL
74919: IFFALSE 74929
// btype := b_barracks ;
74921: LD_ADDR_VAR 0 5
74925: PUSH
74926: LD_INT 5
74928: ST_TO_ADDR
// if btype = b_depot then
74929: LD_VAR 0 5
74933: PUSH
74934: LD_INT 0
74936: EQUAL
74937: IFFALSE 74947
// btype := b_warehouse ;
74939: LD_ADDR_VAR 0 5
74943: PUSH
74944: LD_INT 1
74946: ST_TO_ADDR
// if btype = b_workshop then
74947: LD_VAR 0 5
74951: PUSH
74952: LD_INT 2
74954: EQUAL
74955: IFFALSE 74965
// btype := b_factory ;
74957: LD_ADDR_VAR 0 5
74961: PUSH
74962: LD_INT 3
74964: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
74965: LD_ADDR_VAR 0 4
74969: PUSH
74970: LD_VAR 0 5
74974: PPUSH
74975: LD_VAR 0 1
74979: PPUSH
74980: CALL_OW 248
74984: PPUSH
74985: CALL_OW 450
74989: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
74990: LD_ADDR_VAR 0 2
74994: PUSH
74995: LD_VAR 0 3
74999: PPUSH
75000: LD_INT 1
75002: PPUSH
75003: CALL_OW 275
75007: PUSH
75008: LD_VAR 0 4
75012: PUSH
75013: LD_INT 1
75015: ARRAY
75016: GREATEREQUAL
75017: PUSH
75018: LD_VAR 0 3
75022: PPUSH
75023: LD_INT 2
75025: PPUSH
75026: CALL_OW 275
75030: PUSH
75031: LD_VAR 0 4
75035: PUSH
75036: LD_INT 2
75038: ARRAY
75039: GREATEREQUAL
75040: AND
75041: PUSH
75042: LD_VAR 0 3
75046: PPUSH
75047: LD_INT 3
75049: PPUSH
75050: CALL_OW 275
75054: PUSH
75055: LD_VAR 0 4
75059: PUSH
75060: LD_INT 3
75062: ARRAY
75063: GREATEREQUAL
75064: AND
75065: ST_TO_ADDR
// end ;
75066: LD_VAR 0 2
75070: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
75071: LD_INT 0
75073: PPUSH
75074: PPUSH
75075: PPUSH
// pom := GetBase ( building ) ;
75076: LD_ADDR_VAR 0 4
75080: PUSH
75081: LD_VAR 0 1
75085: PPUSH
75086: CALL_OW 274
75090: ST_TO_ADDR
// if not pom then
75091: LD_VAR 0 4
75095: NOT
75096: IFFALSE 75100
// exit ;
75098: GO 75201
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
75100: LD_ADDR_VAR 0 5
75104: PUSH
75105: LD_VAR 0 2
75109: PPUSH
75110: LD_VAR 0 1
75114: PPUSH
75115: CALL_OW 248
75119: PPUSH
75120: CALL_OW 450
75124: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75125: LD_ADDR_VAR 0 3
75129: PUSH
75130: LD_VAR 0 4
75134: PPUSH
75135: LD_INT 1
75137: PPUSH
75138: CALL_OW 275
75142: PUSH
75143: LD_VAR 0 5
75147: PUSH
75148: LD_INT 1
75150: ARRAY
75151: GREATEREQUAL
75152: PUSH
75153: LD_VAR 0 4
75157: PPUSH
75158: LD_INT 2
75160: PPUSH
75161: CALL_OW 275
75165: PUSH
75166: LD_VAR 0 5
75170: PUSH
75171: LD_INT 2
75173: ARRAY
75174: GREATEREQUAL
75175: AND
75176: PUSH
75177: LD_VAR 0 4
75181: PPUSH
75182: LD_INT 3
75184: PPUSH
75185: CALL_OW 275
75189: PUSH
75190: LD_VAR 0 5
75194: PUSH
75195: LD_INT 3
75197: ARRAY
75198: GREATEREQUAL
75199: AND
75200: ST_TO_ADDR
// end ;
75201: LD_VAR 0 3
75205: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
75206: LD_INT 0
75208: PPUSH
75209: PPUSH
75210: PPUSH
75211: PPUSH
75212: PPUSH
75213: PPUSH
75214: PPUSH
75215: PPUSH
75216: PPUSH
75217: PPUSH
75218: PPUSH
// result := false ;
75219: LD_ADDR_VAR 0 8
75223: PUSH
75224: LD_INT 0
75226: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
75227: LD_VAR 0 5
75231: NOT
75232: PUSH
75233: LD_VAR 0 1
75237: NOT
75238: OR
75239: PUSH
75240: LD_VAR 0 2
75244: NOT
75245: OR
75246: PUSH
75247: LD_VAR 0 3
75251: NOT
75252: OR
75253: IFFALSE 75257
// exit ;
75255: GO 76071
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
75257: LD_ADDR_VAR 0 14
75261: PUSH
75262: LD_VAR 0 1
75266: PPUSH
75267: LD_VAR 0 2
75271: PPUSH
75272: LD_VAR 0 3
75276: PPUSH
75277: LD_VAR 0 4
75281: PPUSH
75282: LD_VAR 0 5
75286: PUSH
75287: LD_INT 1
75289: ARRAY
75290: PPUSH
75291: CALL_OW 248
75295: PPUSH
75296: LD_INT 0
75298: PPUSH
75299: CALL 77304 0 6
75303: ST_TO_ADDR
// if not hexes then
75304: LD_VAR 0 14
75308: NOT
75309: IFFALSE 75313
// exit ;
75311: GO 76071
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
75313: LD_ADDR_VAR 0 17
75317: PUSH
75318: LD_VAR 0 5
75322: PPUSH
75323: LD_INT 22
75325: PUSH
75326: LD_VAR 0 13
75330: PPUSH
75331: CALL_OW 255
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 2
75342: PUSH
75343: LD_INT 30
75345: PUSH
75346: LD_INT 0
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: LD_INT 30
75355: PUSH
75356: LD_INT 1
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: LIST
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PPUSH
75372: CALL_OW 72
75376: ST_TO_ADDR
// for i = 1 to hexes do
75377: LD_ADDR_VAR 0 9
75381: PUSH
75382: DOUBLE
75383: LD_INT 1
75385: DEC
75386: ST_TO_ADDR
75387: LD_VAR 0 14
75391: PUSH
75392: FOR_TO
75393: IFFALSE 76069
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
75395: LD_ADDR_VAR 0 13
75399: PUSH
75400: LD_VAR 0 14
75404: PUSH
75405: LD_VAR 0 9
75409: ARRAY
75410: PUSH
75411: LD_INT 1
75413: ARRAY
75414: PPUSH
75415: LD_VAR 0 14
75419: PUSH
75420: LD_VAR 0 9
75424: ARRAY
75425: PUSH
75426: LD_INT 2
75428: ARRAY
75429: PPUSH
75430: CALL_OW 428
75434: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
75435: LD_VAR 0 14
75439: PUSH
75440: LD_VAR 0 9
75444: ARRAY
75445: PUSH
75446: LD_INT 1
75448: ARRAY
75449: PPUSH
75450: LD_VAR 0 14
75454: PUSH
75455: LD_VAR 0 9
75459: ARRAY
75460: PUSH
75461: LD_INT 2
75463: ARRAY
75464: PPUSH
75465: CALL_OW 351
75469: PUSH
75470: LD_VAR 0 14
75474: PUSH
75475: LD_VAR 0 9
75479: ARRAY
75480: PUSH
75481: LD_INT 1
75483: ARRAY
75484: PPUSH
75485: LD_VAR 0 14
75489: PUSH
75490: LD_VAR 0 9
75494: ARRAY
75495: PUSH
75496: LD_INT 2
75498: ARRAY
75499: PPUSH
75500: CALL_OW 488
75504: NOT
75505: OR
75506: PUSH
75507: LD_VAR 0 13
75511: PPUSH
75512: CALL_OW 247
75516: PUSH
75517: LD_INT 3
75519: EQUAL
75520: OR
75521: IFFALSE 75527
// exit ;
75523: POP
75524: POP
75525: GO 76071
// if not tmp then
75527: LD_VAR 0 13
75531: NOT
75532: IFFALSE 75536
// continue ;
75534: GO 75392
// result := true ;
75536: LD_ADDR_VAR 0 8
75540: PUSH
75541: LD_INT 1
75543: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
75544: LD_VAR 0 6
75548: PUSH
75549: LD_VAR 0 13
75553: PPUSH
75554: CALL_OW 247
75558: PUSH
75559: LD_INT 2
75561: EQUAL
75562: AND
75563: PUSH
75564: LD_VAR 0 13
75568: PPUSH
75569: CALL_OW 263
75573: PUSH
75574: LD_INT 1
75576: EQUAL
75577: AND
75578: IFFALSE 75742
// begin if IsDrivenBy ( tmp ) then
75580: LD_VAR 0 13
75584: PPUSH
75585: CALL_OW 311
75589: IFFALSE 75593
// continue ;
75591: GO 75392
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
75593: LD_VAR 0 6
75597: PPUSH
75598: LD_INT 3
75600: PUSH
75601: LD_INT 60
75603: PUSH
75604: EMPTY
75605: LIST
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: LD_INT 3
75613: PUSH
75614: LD_INT 55
75616: PUSH
75617: EMPTY
75618: LIST
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PPUSH
75628: CALL_OW 72
75632: IFFALSE 75740
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
75634: LD_ADDR_VAR 0 18
75638: PUSH
75639: LD_VAR 0 6
75643: PPUSH
75644: LD_INT 3
75646: PUSH
75647: LD_INT 60
75649: PUSH
75650: EMPTY
75651: LIST
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: PUSH
75657: LD_INT 3
75659: PUSH
75660: LD_INT 55
75662: PUSH
75663: EMPTY
75664: LIST
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PPUSH
75674: CALL_OW 72
75678: PUSH
75679: LD_INT 1
75681: ARRAY
75682: ST_TO_ADDR
// if IsInUnit ( driver ) then
75683: LD_VAR 0 18
75687: PPUSH
75688: CALL_OW 310
75692: IFFALSE 75703
// ComExit ( driver ) ;
75694: LD_VAR 0 18
75698: PPUSH
75699: CALL 100992 0 1
// AddComEnterUnit ( driver , tmp ) ;
75703: LD_VAR 0 18
75707: PPUSH
75708: LD_VAR 0 13
75712: PPUSH
75713: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
75717: LD_VAR 0 18
75721: PPUSH
75722: LD_VAR 0 7
75726: PPUSH
75727: CALL_OW 173
// AddComExitVehicle ( driver ) ;
75731: LD_VAR 0 18
75735: PPUSH
75736: CALL_OW 181
// end ; continue ;
75740: GO 75392
// end ; if not cleaners or not tmp in cleaners then
75742: LD_VAR 0 6
75746: NOT
75747: PUSH
75748: LD_VAR 0 13
75752: PUSH
75753: LD_VAR 0 6
75757: IN
75758: NOT
75759: OR
75760: IFFALSE 76067
// begin if dep then
75762: LD_VAR 0 17
75766: IFFALSE 75902
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
75768: LD_ADDR_VAR 0 16
75772: PUSH
75773: LD_VAR 0 17
75777: PUSH
75778: LD_INT 1
75780: ARRAY
75781: PPUSH
75782: CALL_OW 250
75786: PPUSH
75787: LD_VAR 0 17
75791: PUSH
75792: LD_INT 1
75794: ARRAY
75795: PPUSH
75796: CALL_OW 254
75800: PPUSH
75801: LD_INT 5
75803: PPUSH
75804: CALL_OW 272
75808: PUSH
75809: LD_VAR 0 17
75813: PUSH
75814: LD_INT 1
75816: ARRAY
75817: PPUSH
75818: CALL_OW 251
75822: PPUSH
75823: LD_VAR 0 17
75827: PUSH
75828: LD_INT 1
75830: ARRAY
75831: PPUSH
75832: CALL_OW 254
75836: PPUSH
75837: LD_INT 5
75839: PPUSH
75840: CALL_OW 273
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
75849: LD_VAR 0 16
75853: PUSH
75854: LD_INT 1
75856: ARRAY
75857: PPUSH
75858: LD_VAR 0 16
75862: PUSH
75863: LD_INT 2
75865: ARRAY
75866: PPUSH
75867: CALL_OW 488
75871: IFFALSE 75902
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
75873: LD_VAR 0 13
75877: PPUSH
75878: LD_VAR 0 16
75882: PUSH
75883: LD_INT 1
75885: ARRAY
75886: PPUSH
75887: LD_VAR 0 16
75891: PUSH
75892: LD_INT 2
75894: ARRAY
75895: PPUSH
75896: CALL_OW 111
// continue ;
75900: GO 75392
// end ; end ; r := GetDir ( tmp ) ;
75902: LD_ADDR_VAR 0 15
75906: PUSH
75907: LD_VAR 0 13
75911: PPUSH
75912: CALL_OW 254
75916: ST_TO_ADDR
// if r = 5 then
75917: LD_VAR 0 15
75921: PUSH
75922: LD_INT 5
75924: EQUAL
75925: IFFALSE 75935
// r := 0 ;
75927: LD_ADDR_VAR 0 15
75931: PUSH
75932: LD_INT 0
75934: ST_TO_ADDR
// for j = r to 5 do
75935: LD_ADDR_VAR 0 10
75939: PUSH
75940: DOUBLE
75941: LD_VAR 0 15
75945: DEC
75946: ST_TO_ADDR
75947: LD_INT 5
75949: PUSH
75950: FOR_TO
75951: IFFALSE 76065
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
75953: LD_ADDR_VAR 0 11
75957: PUSH
75958: LD_VAR 0 13
75962: PPUSH
75963: CALL_OW 250
75967: PPUSH
75968: LD_VAR 0 10
75972: PPUSH
75973: LD_INT 2
75975: PPUSH
75976: CALL_OW 272
75980: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
75981: LD_ADDR_VAR 0 12
75985: PUSH
75986: LD_VAR 0 13
75990: PPUSH
75991: CALL_OW 251
75995: PPUSH
75996: LD_VAR 0 10
76000: PPUSH
76001: LD_INT 2
76003: PPUSH
76004: CALL_OW 273
76008: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76009: LD_VAR 0 11
76013: PPUSH
76014: LD_VAR 0 12
76018: PPUSH
76019: CALL_OW 488
76023: PUSH
76024: LD_VAR 0 11
76028: PPUSH
76029: LD_VAR 0 12
76033: PPUSH
76034: CALL_OW 428
76038: NOT
76039: AND
76040: IFFALSE 76063
// begin ComMoveXY ( tmp , _x , _y ) ;
76042: LD_VAR 0 13
76046: PPUSH
76047: LD_VAR 0 11
76051: PPUSH
76052: LD_VAR 0 12
76056: PPUSH
76057: CALL_OW 111
// break ;
76061: GO 76065
// end ; end ;
76063: GO 75950
76065: POP
76066: POP
// end ; end ;
76067: GO 75392
76069: POP
76070: POP
// end ;
76071: LD_VAR 0 8
76075: RET
// export function BuildingTechInvented ( side , btype ) ; begin
76076: LD_INT 0
76078: PPUSH
// result := true ;
76079: LD_ADDR_VAR 0 3
76083: PUSH
76084: LD_INT 1
76086: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
76087: LD_VAR 0 2
76091: PUSH
76092: LD_INT 24
76094: DOUBLE
76095: EQUAL
76096: IFTRUE 76106
76098: LD_INT 33
76100: DOUBLE
76101: EQUAL
76102: IFTRUE 76106
76104: GO 76131
76106: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
76107: LD_ADDR_VAR 0 3
76111: PUSH
76112: LD_INT 32
76114: PPUSH
76115: LD_VAR 0 1
76119: PPUSH
76120: CALL_OW 321
76124: PUSH
76125: LD_INT 2
76127: EQUAL
76128: ST_TO_ADDR
76129: GO 76447
76131: LD_INT 20
76133: DOUBLE
76134: EQUAL
76135: IFTRUE 76139
76137: GO 76164
76139: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
76140: LD_ADDR_VAR 0 3
76144: PUSH
76145: LD_INT 6
76147: PPUSH
76148: LD_VAR 0 1
76152: PPUSH
76153: CALL_OW 321
76157: PUSH
76158: LD_INT 2
76160: EQUAL
76161: ST_TO_ADDR
76162: GO 76447
76164: LD_INT 22
76166: DOUBLE
76167: EQUAL
76168: IFTRUE 76178
76170: LD_INT 36
76172: DOUBLE
76173: EQUAL
76174: IFTRUE 76178
76176: GO 76203
76178: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
76179: LD_ADDR_VAR 0 3
76183: PUSH
76184: LD_INT 15
76186: PPUSH
76187: LD_VAR 0 1
76191: PPUSH
76192: CALL_OW 321
76196: PUSH
76197: LD_INT 2
76199: EQUAL
76200: ST_TO_ADDR
76201: GO 76447
76203: LD_INT 30
76205: DOUBLE
76206: EQUAL
76207: IFTRUE 76211
76209: GO 76236
76211: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
76212: LD_ADDR_VAR 0 3
76216: PUSH
76217: LD_INT 20
76219: PPUSH
76220: LD_VAR 0 1
76224: PPUSH
76225: CALL_OW 321
76229: PUSH
76230: LD_INT 2
76232: EQUAL
76233: ST_TO_ADDR
76234: GO 76447
76236: LD_INT 28
76238: DOUBLE
76239: EQUAL
76240: IFTRUE 76250
76242: LD_INT 21
76244: DOUBLE
76245: EQUAL
76246: IFTRUE 76250
76248: GO 76275
76250: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
76251: LD_ADDR_VAR 0 3
76255: PUSH
76256: LD_INT 21
76258: PPUSH
76259: LD_VAR 0 1
76263: PPUSH
76264: CALL_OW 321
76268: PUSH
76269: LD_INT 2
76271: EQUAL
76272: ST_TO_ADDR
76273: GO 76447
76275: LD_INT 16
76277: DOUBLE
76278: EQUAL
76279: IFTRUE 76283
76281: GO 76308
76283: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
76284: LD_ADDR_VAR 0 3
76288: PUSH
76289: LD_INT 84
76291: PPUSH
76292: LD_VAR 0 1
76296: PPUSH
76297: CALL_OW 321
76301: PUSH
76302: LD_INT 2
76304: EQUAL
76305: ST_TO_ADDR
76306: GO 76447
76308: LD_INT 19
76310: DOUBLE
76311: EQUAL
76312: IFTRUE 76322
76314: LD_INT 23
76316: DOUBLE
76317: EQUAL
76318: IFTRUE 76322
76320: GO 76347
76322: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
76323: LD_ADDR_VAR 0 3
76327: PUSH
76328: LD_INT 83
76330: PPUSH
76331: LD_VAR 0 1
76335: PPUSH
76336: CALL_OW 321
76340: PUSH
76341: LD_INT 2
76343: EQUAL
76344: ST_TO_ADDR
76345: GO 76447
76347: LD_INT 17
76349: DOUBLE
76350: EQUAL
76351: IFTRUE 76355
76353: GO 76380
76355: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
76356: LD_ADDR_VAR 0 3
76360: PUSH
76361: LD_INT 39
76363: PPUSH
76364: LD_VAR 0 1
76368: PPUSH
76369: CALL_OW 321
76373: PUSH
76374: LD_INT 2
76376: EQUAL
76377: ST_TO_ADDR
76378: GO 76447
76380: LD_INT 18
76382: DOUBLE
76383: EQUAL
76384: IFTRUE 76388
76386: GO 76413
76388: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
76389: LD_ADDR_VAR 0 3
76393: PUSH
76394: LD_INT 40
76396: PPUSH
76397: LD_VAR 0 1
76401: PPUSH
76402: CALL_OW 321
76406: PUSH
76407: LD_INT 2
76409: EQUAL
76410: ST_TO_ADDR
76411: GO 76447
76413: LD_INT 27
76415: DOUBLE
76416: EQUAL
76417: IFTRUE 76421
76419: GO 76446
76421: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
76422: LD_ADDR_VAR 0 3
76426: PUSH
76427: LD_INT 35
76429: PPUSH
76430: LD_VAR 0 1
76434: PPUSH
76435: CALL_OW 321
76439: PUSH
76440: LD_INT 2
76442: EQUAL
76443: ST_TO_ADDR
76444: GO 76447
76446: POP
// end ;
76447: LD_VAR 0 3
76451: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
76452: LD_INT 0
76454: PPUSH
76455: PPUSH
76456: PPUSH
76457: PPUSH
76458: PPUSH
76459: PPUSH
76460: PPUSH
76461: PPUSH
76462: PPUSH
76463: PPUSH
76464: PPUSH
// result := false ;
76465: LD_ADDR_VAR 0 6
76469: PUSH
76470: LD_INT 0
76472: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
76473: LD_VAR 0 1
76477: NOT
76478: PUSH
76479: LD_VAR 0 1
76483: PPUSH
76484: CALL_OW 266
76488: PUSH
76489: LD_INT 0
76491: PUSH
76492: LD_INT 1
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: IN
76499: NOT
76500: OR
76501: PUSH
76502: LD_VAR 0 2
76506: NOT
76507: OR
76508: PUSH
76509: LD_VAR 0 5
76513: PUSH
76514: LD_INT 0
76516: PUSH
76517: LD_INT 1
76519: PUSH
76520: LD_INT 2
76522: PUSH
76523: LD_INT 3
76525: PUSH
76526: LD_INT 4
76528: PUSH
76529: LD_INT 5
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: IN
76540: NOT
76541: OR
76542: PUSH
76543: LD_VAR 0 3
76547: PPUSH
76548: LD_VAR 0 4
76552: PPUSH
76553: CALL_OW 488
76557: NOT
76558: OR
76559: IFFALSE 76563
// exit ;
76561: GO 77299
// side := GetSide ( depot ) ;
76563: LD_ADDR_VAR 0 9
76567: PUSH
76568: LD_VAR 0 1
76572: PPUSH
76573: CALL_OW 255
76577: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
76578: LD_VAR 0 9
76582: PPUSH
76583: LD_VAR 0 2
76587: PPUSH
76588: CALL 76076 0 2
76592: NOT
76593: IFFALSE 76597
// exit ;
76595: GO 77299
// pom := GetBase ( depot ) ;
76597: LD_ADDR_VAR 0 10
76601: PUSH
76602: LD_VAR 0 1
76606: PPUSH
76607: CALL_OW 274
76611: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
76612: LD_ADDR_VAR 0 11
76616: PUSH
76617: LD_VAR 0 2
76621: PPUSH
76622: LD_VAR 0 1
76626: PPUSH
76627: CALL_OW 248
76631: PPUSH
76632: CALL_OW 450
76636: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
76637: LD_VAR 0 10
76641: PPUSH
76642: LD_INT 1
76644: PPUSH
76645: CALL_OW 275
76649: PUSH
76650: LD_VAR 0 11
76654: PUSH
76655: LD_INT 1
76657: ARRAY
76658: GREATEREQUAL
76659: PUSH
76660: LD_VAR 0 10
76664: PPUSH
76665: LD_INT 2
76667: PPUSH
76668: CALL_OW 275
76672: PUSH
76673: LD_VAR 0 11
76677: PUSH
76678: LD_INT 2
76680: ARRAY
76681: GREATEREQUAL
76682: AND
76683: PUSH
76684: LD_VAR 0 10
76688: PPUSH
76689: LD_INT 3
76691: PPUSH
76692: CALL_OW 275
76696: PUSH
76697: LD_VAR 0 11
76701: PUSH
76702: LD_INT 3
76704: ARRAY
76705: GREATEREQUAL
76706: AND
76707: NOT
76708: IFFALSE 76712
// exit ;
76710: GO 77299
// if GetBType ( depot ) = b_depot then
76712: LD_VAR 0 1
76716: PPUSH
76717: CALL_OW 266
76721: PUSH
76722: LD_INT 0
76724: EQUAL
76725: IFFALSE 76737
// dist := 28 else
76727: LD_ADDR_VAR 0 14
76731: PUSH
76732: LD_INT 28
76734: ST_TO_ADDR
76735: GO 76745
// dist := 36 ;
76737: LD_ADDR_VAR 0 14
76741: PUSH
76742: LD_INT 36
76744: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
76745: LD_VAR 0 1
76749: PPUSH
76750: LD_VAR 0 3
76754: PPUSH
76755: LD_VAR 0 4
76759: PPUSH
76760: CALL_OW 297
76764: PUSH
76765: LD_VAR 0 14
76769: GREATER
76770: IFFALSE 76774
// exit ;
76772: GO 77299
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
76774: LD_ADDR_VAR 0 12
76778: PUSH
76779: LD_VAR 0 2
76783: PPUSH
76784: LD_VAR 0 3
76788: PPUSH
76789: LD_VAR 0 4
76793: PPUSH
76794: LD_VAR 0 5
76798: PPUSH
76799: LD_VAR 0 1
76803: PPUSH
76804: CALL_OW 248
76808: PPUSH
76809: LD_INT 0
76811: PPUSH
76812: CALL 77304 0 6
76816: ST_TO_ADDR
// if not hexes then
76817: LD_VAR 0 12
76821: NOT
76822: IFFALSE 76826
// exit ;
76824: GO 77299
// hex := GetHexInfo ( x , y ) ;
76826: LD_ADDR_VAR 0 15
76830: PUSH
76831: LD_VAR 0 3
76835: PPUSH
76836: LD_VAR 0 4
76840: PPUSH
76841: CALL_OW 546
76845: ST_TO_ADDR
// if hex [ 1 ] then
76846: LD_VAR 0 15
76850: PUSH
76851: LD_INT 1
76853: ARRAY
76854: IFFALSE 76858
// exit ;
76856: GO 77299
// height := hex [ 2 ] ;
76858: LD_ADDR_VAR 0 13
76862: PUSH
76863: LD_VAR 0 15
76867: PUSH
76868: LD_INT 2
76870: ARRAY
76871: ST_TO_ADDR
// for i = 1 to hexes do
76872: LD_ADDR_VAR 0 7
76876: PUSH
76877: DOUBLE
76878: LD_INT 1
76880: DEC
76881: ST_TO_ADDR
76882: LD_VAR 0 12
76886: PUSH
76887: FOR_TO
76888: IFFALSE 77218
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
76890: LD_VAR 0 12
76894: PUSH
76895: LD_VAR 0 7
76899: ARRAY
76900: PUSH
76901: LD_INT 1
76903: ARRAY
76904: PPUSH
76905: LD_VAR 0 12
76909: PUSH
76910: LD_VAR 0 7
76914: ARRAY
76915: PUSH
76916: LD_INT 2
76918: ARRAY
76919: PPUSH
76920: CALL_OW 488
76924: NOT
76925: PUSH
76926: LD_VAR 0 12
76930: PUSH
76931: LD_VAR 0 7
76935: ARRAY
76936: PUSH
76937: LD_INT 1
76939: ARRAY
76940: PPUSH
76941: LD_VAR 0 12
76945: PUSH
76946: LD_VAR 0 7
76950: ARRAY
76951: PUSH
76952: LD_INT 2
76954: ARRAY
76955: PPUSH
76956: CALL_OW 428
76960: PUSH
76961: LD_INT 0
76963: GREATER
76964: OR
76965: PUSH
76966: LD_VAR 0 12
76970: PUSH
76971: LD_VAR 0 7
76975: ARRAY
76976: PUSH
76977: LD_INT 1
76979: ARRAY
76980: PPUSH
76981: LD_VAR 0 12
76985: PUSH
76986: LD_VAR 0 7
76990: ARRAY
76991: PUSH
76992: LD_INT 2
76994: ARRAY
76995: PPUSH
76996: CALL_OW 351
77000: OR
77001: IFFALSE 77007
// exit ;
77003: POP
77004: POP
77005: GO 77299
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77007: LD_ADDR_VAR 0 8
77011: PUSH
77012: LD_VAR 0 12
77016: PUSH
77017: LD_VAR 0 7
77021: ARRAY
77022: PUSH
77023: LD_INT 1
77025: ARRAY
77026: PPUSH
77027: LD_VAR 0 12
77031: PUSH
77032: LD_VAR 0 7
77036: ARRAY
77037: PUSH
77038: LD_INT 2
77040: ARRAY
77041: PPUSH
77042: CALL_OW 546
77046: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77047: LD_VAR 0 8
77051: PUSH
77052: LD_INT 1
77054: ARRAY
77055: PUSH
77056: LD_VAR 0 8
77060: PUSH
77061: LD_INT 2
77063: ARRAY
77064: PUSH
77065: LD_VAR 0 13
77069: PUSH
77070: LD_INT 2
77072: PLUS
77073: GREATER
77074: OR
77075: PUSH
77076: LD_VAR 0 8
77080: PUSH
77081: LD_INT 2
77083: ARRAY
77084: PUSH
77085: LD_VAR 0 13
77089: PUSH
77090: LD_INT 2
77092: MINUS
77093: LESS
77094: OR
77095: PUSH
77096: LD_VAR 0 8
77100: PUSH
77101: LD_INT 3
77103: ARRAY
77104: PUSH
77105: LD_INT 0
77107: PUSH
77108: LD_INT 8
77110: PUSH
77111: LD_INT 9
77113: PUSH
77114: LD_INT 10
77116: PUSH
77117: LD_INT 11
77119: PUSH
77120: LD_INT 12
77122: PUSH
77123: LD_INT 13
77125: PUSH
77126: LD_INT 16
77128: PUSH
77129: LD_INT 17
77131: PUSH
77132: LD_INT 18
77134: PUSH
77135: LD_INT 19
77137: PUSH
77138: LD_INT 20
77140: PUSH
77141: LD_INT 21
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: LIST
77155: LIST
77156: LIST
77157: LIST
77158: IN
77159: NOT
77160: OR
77161: PUSH
77162: LD_VAR 0 8
77166: PUSH
77167: LD_INT 5
77169: ARRAY
77170: NOT
77171: OR
77172: PUSH
77173: LD_VAR 0 8
77177: PUSH
77178: LD_INT 6
77180: ARRAY
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: LD_INT 2
77187: PUSH
77188: LD_INT 7
77190: PUSH
77191: LD_INT 9
77193: PUSH
77194: LD_INT 10
77196: PUSH
77197: LD_INT 11
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: IN
77208: NOT
77209: OR
77210: IFFALSE 77216
// exit ;
77212: POP
77213: POP
77214: GO 77299
// end ;
77216: GO 76887
77218: POP
77219: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77220: LD_VAR 0 9
77224: PPUSH
77225: LD_VAR 0 3
77229: PPUSH
77230: LD_VAR 0 4
77234: PPUSH
77235: LD_INT 20
77237: PPUSH
77238: CALL 69251 0 4
77242: PUSH
77243: LD_INT 4
77245: ARRAY
77246: IFFALSE 77250
// exit ;
77248: GO 77299
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77250: LD_VAR 0 2
77254: PUSH
77255: LD_INT 29
77257: PUSH
77258: LD_INT 30
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: IN
77265: PUSH
77266: LD_VAR 0 3
77270: PPUSH
77271: LD_VAR 0 4
77275: PPUSH
77276: LD_VAR 0 9
77280: PPUSH
77281: CALL_OW 440
77285: NOT
77286: AND
77287: IFFALSE 77291
// exit ;
77289: GO 77299
// result := true ;
77291: LD_ADDR_VAR 0 6
77295: PUSH
77296: LD_INT 1
77298: ST_TO_ADDR
// end ;
77299: LD_VAR 0 6
77303: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
77304: LD_INT 0
77306: PPUSH
77307: PPUSH
77308: PPUSH
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
77325: PPUSH
77326: PPUSH
77327: PPUSH
77328: PPUSH
77329: PPUSH
77330: PPUSH
77331: PPUSH
77332: PPUSH
77333: PPUSH
77334: PPUSH
77335: PPUSH
77336: PPUSH
77337: PPUSH
77338: PPUSH
77339: PPUSH
77340: PPUSH
77341: PPUSH
77342: PPUSH
77343: PPUSH
77344: PPUSH
77345: PPUSH
77346: PPUSH
77347: PPUSH
77348: PPUSH
77349: PPUSH
77350: PPUSH
77351: PPUSH
77352: PPUSH
77353: PPUSH
77354: PPUSH
77355: PPUSH
77356: PPUSH
77357: PPUSH
77358: PPUSH
77359: PPUSH
77360: PPUSH
77361: PPUSH
77362: PPUSH
77363: PPUSH
// result = [ ] ;
77364: LD_ADDR_VAR 0 7
77368: PUSH
77369: EMPTY
77370: ST_TO_ADDR
// temp_list = [ ] ;
77371: LD_ADDR_VAR 0 9
77375: PUSH
77376: EMPTY
77377: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77378: LD_VAR 0 4
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: LD_INT 2
77391: PUSH
77392: LD_INT 3
77394: PUSH
77395: LD_INT 4
77397: PUSH
77398: LD_INT 5
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: LIST
77408: IN
77409: NOT
77410: PUSH
77411: LD_VAR 0 1
77415: PUSH
77416: LD_INT 0
77418: PUSH
77419: LD_INT 1
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: IN
77426: PUSH
77427: LD_VAR 0 5
77431: PUSH
77432: LD_INT 1
77434: PUSH
77435: LD_INT 2
77437: PUSH
77438: LD_INT 3
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: LIST
77445: IN
77446: NOT
77447: AND
77448: OR
77449: IFFALSE 77453
// exit ;
77451: GO 95844
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
77453: LD_VAR 0 1
77457: PUSH
77458: LD_INT 6
77460: PUSH
77461: LD_INT 7
77463: PUSH
77464: LD_INT 8
77466: PUSH
77467: LD_INT 13
77469: PUSH
77470: LD_INT 12
77472: PUSH
77473: LD_INT 15
77475: PUSH
77476: LD_INT 11
77478: PUSH
77479: LD_INT 14
77481: PUSH
77482: LD_INT 10
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: IN
77496: IFFALSE 77506
// btype = b_lab ;
77498: LD_ADDR_VAR 0 1
77502: PUSH
77503: LD_INT 6
77505: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
77506: LD_VAR 0 6
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: LD_INT 1
77516: PUSH
77517: LD_INT 2
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: LIST
77524: IN
77525: NOT
77526: PUSH
77527: LD_VAR 0 1
77531: PUSH
77532: LD_INT 0
77534: PUSH
77535: LD_INT 1
77537: PUSH
77538: LD_INT 2
77540: PUSH
77541: LD_INT 3
77543: PUSH
77544: LD_INT 6
77546: PUSH
77547: LD_INT 36
77549: PUSH
77550: LD_INT 4
77552: PUSH
77553: LD_INT 5
77555: PUSH
77556: LD_INT 31
77558: PUSH
77559: LD_INT 32
77561: PUSH
77562: LD_INT 33
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: LIST
77569: LIST
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: IN
77578: NOT
77579: PUSH
77580: LD_VAR 0 6
77584: PUSH
77585: LD_INT 1
77587: EQUAL
77588: AND
77589: OR
77590: PUSH
77591: LD_VAR 0 1
77595: PUSH
77596: LD_INT 2
77598: PUSH
77599: LD_INT 3
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: IN
77606: NOT
77607: PUSH
77608: LD_VAR 0 6
77612: PUSH
77613: LD_INT 2
77615: EQUAL
77616: AND
77617: OR
77618: IFFALSE 77628
// mode = 0 ;
77620: LD_ADDR_VAR 0 6
77624: PUSH
77625: LD_INT 0
77627: ST_TO_ADDR
// case mode of 0 :
77628: LD_VAR 0 6
77632: PUSH
77633: LD_INT 0
77635: DOUBLE
77636: EQUAL
77637: IFTRUE 77641
77639: GO 89094
77641: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77642: LD_ADDR_VAR 0 11
77646: PUSH
77647: LD_INT 0
77649: PUSH
77650: LD_INT 0
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 0
77659: PUSH
77660: LD_INT 1
77662: NEG
77663: PUSH
77664: EMPTY
77665: LIST
77666: LIST
77667: PUSH
77668: LD_INT 1
77670: PUSH
77671: LD_INT 0
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 1
77680: PUSH
77681: LD_INT 1
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 0
77690: PUSH
77691: LD_INT 1
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 1
77700: NEG
77701: PUSH
77702: LD_INT 0
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 1
77711: NEG
77712: PUSH
77713: LD_INT 1
77715: NEG
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 1
77723: NEG
77724: PUSH
77725: LD_INT 2
77727: NEG
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 0
77735: PUSH
77736: LD_INT 2
77738: NEG
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: LD_INT 1
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: PUSH
77755: LD_INT 1
77757: PUSH
77758: LD_INT 2
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 0
77767: PUSH
77768: LD_INT 2
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 1
77777: NEG
77778: PUSH
77779: LD_INT 1
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 1
77788: PUSH
77789: LD_INT 3
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 0
77798: PUSH
77799: LD_INT 3
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 1
77808: NEG
77809: PUSH
77810: LD_INT 2
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: LIST
77821: LIST
77822: LIST
77823: LIST
77824: LIST
77825: LIST
77826: LIST
77827: LIST
77828: LIST
77829: LIST
77830: LIST
77831: LIST
77832: LIST
77833: LIST
77834: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77835: LD_ADDR_VAR 0 12
77839: PUSH
77840: LD_INT 0
77842: PUSH
77843: LD_INT 0
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 0
77852: PUSH
77853: LD_INT 1
77855: NEG
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 1
77863: PUSH
77864: LD_INT 0
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 1
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 0
77883: PUSH
77884: LD_INT 1
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: LD_INT 1
77893: NEG
77894: PUSH
77895: LD_INT 0
77897: PUSH
77898: EMPTY
77899: LIST
77900: LIST
77901: PUSH
77902: LD_INT 1
77904: NEG
77905: PUSH
77906: LD_INT 1
77908: NEG
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: PUSH
77914: LD_INT 1
77916: PUSH
77917: LD_INT 1
77919: NEG
77920: PUSH
77921: EMPTY
77922: LIST
77923: LIST
77924: PUSH
77925: LD_INT 2
77927: PUSH
77928: LD_INT 0
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: LD_INT 2
77937: PUSH
77938: LD_INT 1
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: LD_INT 1
77947: NEG
77948: PUSH
77949: LD_INT 1
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: LD_INT 2
77958: NEG
77959: PUSH
77960: LD_INT 0
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: PUSH
77967: LD_INT 2
77969: NEG
77970: PUSH
77971: LD_INT 1
77973: NEG
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 2
77981: NEG
77982: PUSH
77983: LD_INT 1
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 3
77992: NEG
77993: PUSH
77994: LD_INT 0
77996: PUSH
77997: EMPTY
77998: LIST
77999: LIST
78000: PUSH
78001: LD_INT 3
78003: NEG
78004: PUSH
78005: LD_INT 1
78007: NEG
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: LIST
78017: LIST
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: LIST
78024: LIST
78025: LIST
78026: LIST
78027: LIST
78028: LIST
78029: LIST
78030: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78031: LD_ADDR_VAR 0 13
78035: PUSH
78036: LD_INT 0
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 0
78048: PUSH
78049: LD_INT 1
78051: NEG
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 1
78059: PUSH
78060: LD_INT 0
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 1
78069: PUSH
78070: LD_INT 1
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: LD_INT 0
78079: PUSH
78080: LD_INT 1
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 1
78089: NEG
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 1
78100: NEG
78101: PUSH
78102: LD_INT 1
78104: NEG
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 1
78112: NEG
78113: PUSH
78114: LD_INT 2
78116: NEG
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 2
78124: PUSH
78125: LD_INT 1
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: LD_INT 2
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 1
78144: PUSH
78145: LD_INT 2
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: LD_INT 2
78154: NEG
78155: PUSH
78156: LD_INT 1
78158: NEG
78159: PUSH
78160: EMPTY
78161: LIST
78162: LIST
78163: PUSH
78164: LD_INT 2
78166: NEG
78167: PUSH
78168: LD_INT 2
78170: NEG
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 2
78178: NEG
78179: PUSH
78180: LD_INT 3
78182: NEG
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 3
78190: NEG
78191: PUSH
78192: LD_INT 2
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 3
78202: NEG
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78230: LD_ADDR_VAR 0 14
78234: PUSH
78235: LD_INT 0
78237: PUSH
78238: LD_INT 0
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 0
78247: PUSH
78248: LD_INT 1
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: PUSH
78259: LD_INT 0
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 1
78268: PUSH
78269: LD_INT 1
78271: PUSH
78272: EMPTY
78273: LIST
78274: LIST
78275: PUSH
78276: LD_INT 0
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 1
78288: NEG
78289: PUSH
78290: LD_INT 0
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 1
78299: NEG
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 1
78311: NEG
78312: PUSH
78313: LD_INT 2
78315: NEG
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 0
78323: PUSH
78324: LD_INT 2
78326: NEG
78327: PUSH
78328: EMPTY
78329: LIST
78330: LIST
78331: PUSH
78332: LD_INT 1
78334: PUSH
78335: LD_INT 1
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 1
78345: PUSH
78346: LD_INT 2
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: LD_INT 2
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 1
78365: NEG
78366: PUSH
78367: LD_INT 1
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: LD_INT 3
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 0
78388: PUSH
78389: LD_INT 3
78391: NEG
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 1
78399: PUSH
78400: LD_INT 2
78402: NEG
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78426: LD_ADDR_VAR 0 15
78430: PUSH
78431: LD_INT 0
78433: PUSH
78434: LD_INT 0
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 0
78443: PUSH
78444: LD_INT 1
78446: NEG
78447: PUSH
78448: EMPTY
78449: LIST
78450: LIST
78451: PUSH
78452: LD_INT 1
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: LD_INT 1
78464: PUSH
78465: LD_INT 1
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 0
78474: PUSH
78475: LD_INT 1
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 1
78484: NEG
78485: PUSH
78486: LD_INT 0
78488: PUSH
78489: EMPTY
78490: LIST
78491: LIST
78492: PUSH
78493: LD_INT 1
78495: NEG
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 1
78507: PUSH
78508: LD_INT 1
78510: NEG
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 2
78518: PUSH
78519: LD_INT 0
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 2
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 1
78538: NEG
78539: PUSH
78540: LD_INT 1
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 2
78549: NEG
78550: PUSH
78551: LD_INT 0
78553: PUSH
78554: EMPTY
78555: LIST
78556: LIST
78557: PUSH
78558: LD_INT 2
78560: NEG
78561: PUSH
78562: LD_INT 1
78564: NEG
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: LD_INT 2
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 3
78583: PUSH
78584: LD_INT 0
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: PUSH
78591: LD_INT 3
78593: PUSH
78594: LD_INT 1
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: LIST
78618: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78619: LD_ADDR_VAR 0 16
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: LD_INT 0
78629: PUSH
78630: EMPTY
78631: LIST
78632: LIST
78633: PUSH
78634: LD_INT 0
78636: PUSH
78637: LD_INT 1
78639: NEG
78640: PUSH
78641: EMPTY
78642: LIST
78643: LIST
78644: PUSH
78645: LD_INT 1
78647: PUSH
78648: LD_INT 0
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: PUSH
78655: LD_INT 1
78657: PUSH
78658: LD_INT 1
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 0
78667: PUSH
78668: LD_INT 1
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: LD_INT 1
78677: NEG
78678: PUSH
78679: LD_INT 0
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PUSH
78686: LD_INT 1
78688: NEG
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: LD_INT 1
78700: NEG
78701: PUSH
78702: LD_INT 2
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 2
78712: PUSH
78713: LD_INT 1
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 2
78722: PUSH
78723: LD_INT 2
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 1
78732: PUSH
78733: LD_INT 2
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 2
78742: NEG
78743: PUSH
78744: LD_INT 1
78746: NEG
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 2
78754: NEG
78755: PUSH
78756: LD_INT 2
78758: NEG
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 3
78766: PUSH
78767: LD_INT 2
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 3
78776: PUSH
78777: LD_INT 3
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 2
78786: PUSH
78787: LD_INT 3
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78812: LD_ADDR_VAR 0 17
78816: PUSH
78817: LD_INT 0
78819: PUSH
78820: LD_INT 0
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 0
78829: PUSH
78830: LD_INT 1
78832: NEG
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 1
78840: PUSH
78841: LD_INT 0
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 1
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 0
78860: PUSH
78861: LD_INT 1
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 1
78870: NEG
78871: PUSH
78872: LD_INT 0
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: LD_INT 1
78885: NEG
78886: PUSH
78887: EMPTY
78888: LIST
78889: LIST
78890: PUSH
78891: LD_INT 1
78893: NEG
78894: PUSH
78895: LD_INT 2
78897: NEG
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 0
78905: PUSH
78906: LD_INT 2
78908: NEG
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 1
78916: PUSH
78917: LD_INT 1
78919: NEG
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 2
78927: PUSH
78928: LD_INT 0
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 2
78937: PUSH
78938: LD_INT 1
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PUSH
78945: LD_INT 2
78947: PUSH
78948: LD_INT 2
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 1
78957: PUSH
78958: LD_INT 2
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 0
78967: PUSH
78968: LD_INT 2
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: LD_INT 1
78977: NEG
78978: PUSH
78979: LD_INT 1
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 2
78988: NEG
78989: PUSH
78990: LD_INT 0
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PUSH
78997: LD_INT 2
78999: NEG
79000: PUSH
79001: LD_INT 1
79003: NEG
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 2
79011: NEG
79012: PUSH
79013: LD_INT 2
79015: NEG
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: LIST
79041: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79042: LD_ADDR_VAR 0 18
79046: PUSH
79047: LD_INT 0
79049: PUSH
79050: LD_INT 0
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 0
79059: PUSH
79060: LD_INT 1
79062: NEG
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: PUSH
79068: LD_INT 1
79070: PUSH
79071: LD_INT 0
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PUSH
79078: LD_INT 1
79080: PUSH
79081: LD_INT 1
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 0
79090: PUSH
79091: LD_INT 1
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PUSH
79098: LD_INT 1
79100: NEG
79101: PUSH
79102: LD_INT 0
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: PUSH
79109: LD_INT 1
79111: NEG
79112: PUSH
79113: LD_INT 1
79115: NEG
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 1
79123: NEG
79124: PUSH
79125: LD_INT 2
79127: NEG
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 0
79135: PUSH
79136: LD_INT 2
79138: NEG
79139: PUSH
79140: EMPTY
79141: LIST
79142: LIST
79143: PUSH
79144: LD_INT 1
79146: PUSH
79147: LD_INT 1
79149: NEG
79150: PUSH
79151: EMPTY
79152: LIST
79153: LIST
79154: PUSH
79155: LD_INT 2
79157: PUSH
79158: LD_INT 0
79160: PUSH
79161: EMPTY
79162: LIST
79163: LIST
79164: PUSH
79165: LD_INT 2
79167: PUSH
79168: LD_INT 1
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 2
79177: PUSH
79178: LD_INT 2
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 1
79187: PUSH
79188: LD_INT 2
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: LD_INT 0
79197: PUSH
79198: LD_INT 2
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: LD_INT 1
79207: NEG
79208: PUSH
79209: LD_INT 1
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PUSH
79216: LD_INT 2
79218: NEG
79219: PUSH
79220: LD_INT 0
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 2
79229: NEG
79230: PUSH
79231: LD_INT 1
79233: NEG
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: NEG
79242: PUSH
79243: LD_INT 2
79245: NEG
79246: PUSH
79247: EMPTY
79248: LIST
79249: LIST
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: LIST
79255: LIST
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: LIST
79270: LIST
79271: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79272: LD_ADDR_VAR 0 19
79276: PUSH
79277: LD_INT 0
79279: PUSH
79280: LD_INT 0
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 0
79289: PUSH
79290: LD_INT 1
79292: NEG
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: PUSH
79298: LD_INT 1
79300: PUSH
79301: LD_INT 0
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 1
79310: PUSH
79311: LD_INT 1
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 0
79320: PUSH
79321: LD_INT 1
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 1
79330: NEG
79331: PUSH
79332: LD_INT 0
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 1
79341: NEG
79342: PUSH
79343: LD_INT 1
79345: NEG
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: PUSH
79351: LD_INT 1
79353: NEG
79354: PUSH
79355: LD_INT 2
79357: NEG
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 0
79365: PUSH
79366: LD_INT 2
79368: NEG
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 1
79376: PUSH
79377: LD_INT 1
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 0
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 2
79397: PUSH
79398: LD_INT 1
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 2
79407: PUSH
79408: LD_INT 2
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 1
79417: PUSH
79418: LD_INT 2
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 0
79427: PUSH
79428: LD_INT 2
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 1
79437: NEG
79438: PUSH
79439: LD_INT 1
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 2
79448: NEG
79449: PUSH
79450: LD_INT 0
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 2
79459: NEG
79460: PUSH
79461: LD_INT 1
79463: NEG
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 2
79471: NEG
79472: PUSH
79473: LD_INT 2
79475: NEG
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: LIST
79495: LIST
79496: LIST
79497: LIST
79498: LIST
79499: LIST
79500: LIST
79501: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79502: LD_ADDR_VAR 0 20
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: LD_INT 0
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 0
79519: PUSH
79520: LD_INT 1
79522: NEG
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 1
79530: PUSH
79531: LD_INT 0
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: LD_INT 1
79543: PUSH
79544: EMPTY
79545: LIST
79546: LIST
79547: PUSH
79548: LD_INT 0
79550: PUSH
79551: LD_INT 1
79553: PUSH
79554: EMPTY
79555: LIST
79556: LIST
79557: PUSH
79558: LD_INT 1
79560: NEG
79561: PUSH
79562: LD_INT 0
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: PUSH
79569: LD_INT 1
79571: NEG
79572: PUSH
79573: LD_INT 1
79575: NEG
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PUSH
79581: LD_INT 1
79583: NEG
79584: PUSH
79585: LD_INT 2
79587: NEG
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 0
79595: PUSH
79596: LD_INT 2
79598: NEG
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: PUSH
79604: LD_INT 1
79606: PUSH
79607: LD_INT 1
79609: NEG
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: LD_INT 2
79617: PUSH
79618: LD_INT 0
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 2
79627: PUSH
79628: LD_INT 1
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 2
79637: PUSH
79638: LD_INT 2
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: LD_INT 2
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 0
79657: PUSH
79658: LD_INT 2
79660: PUSH
79661: EMPTY
79662: LIST
79663: LIST
79664: PUSH
79665: LD_INT 1
79667: NEG
79668: PUSH
79669: LD_INT 1
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PUSH
79676: LD_INT 2
79678: NEG
79679: PUSH
79680: LD_INT 0
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: PUSH
79687: LD_INT 2
79689: NEG
79690: PUSH
79691: LD_INT 1
79693: NEG
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 2
79701: NEG
79702: PUSH
79703: LD_INT 2
79705: NEG
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: EMPTY
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: LIST
79717: LIST
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: LIST
79730: LIST
79731: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79732: LD_ADDR_VAR 0 21
79736: PUSH
79737: LD_INT 0
79739: PUSH
79740: LD_INT 0
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 0
79749: PUSH
79750: LD_INT 1
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 1
79760: PUSH
79761: LD_INT 0
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: LD_INT 1
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: LD_INT 1
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 1
79790: NEG
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: NEG
79802: PUSH
79803: LD_INT 1
79805: NEG
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: LD_INT 1
79813: NEG
79814: PUSH
79815: LD_INT 2
79817: NEG
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: LD_INT 0
79825: PUSH
79826: LD_INT 2
79828: NEG
79829: PUSH
79830: EMPTY
79831: LIST
79832: LIST
79833: PUSH
79834: LD_INT 1
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PUSH
79845: LD_INT 2
79847: PUSH
79848: LD_INT 0
79850: PUSH
79851: EMPTY
79852: LIST
79853: LIST
79854: PUSH
79855: LD_INT 2
79857: PUSH
79858: LD_INT 1
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: PUSH
79865: LD_INT 2
79867: PUSH
79868: LD_INT 2
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 1
79877: PUSH
79878: LD_INT 2
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 0
79887: PUSH
79888: LD_INT 2
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PUSH
79895: LD_INT 1
79897: NEG
79898: PUSH
79899: LD_INT 1
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 2
79908: NEG
79909: PUSH
79910: LD_INT 0
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 2
79919: NEG
79920: PUSH
79921: LD_INT 1
79923: NEG
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: PUSH
79929: LD_INT 2
79931: NEG
79932: PUSH
79933: LD_INT 2
79935: NEG
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79962: LD_ADDR_VAR 0 22
79966: PUSH
79967: LD_INT 0
79969: PUSH
79970: LD_INT 0
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 0
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: LD_INT 0
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 1
80000: PUSH
80001: LD_INT 1
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 0
80010: PUSH
80011: LD_INT 1
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 1
80020: NEG
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 1
80031: NEG
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 1
80043: NEG
80044: PUSH
80045: LD_INT 2
80047: NEG
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: LD_INT 2
80058: NEG
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 1
80066: PUSH
80067: LD_INT 1
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 2
80077: PUSH
80078: LD_INT 0
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 2
80087: PUSH
80088: LD_INT 1
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 2
80097: PUSH
80098: LD_INT 2
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 1
80107: PUSH
80108: LD_INT 2
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 0
80117: PUSH
80118: LD_INT 2
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 1
80127: NEG
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 2
80138: NEG
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 2
80149: NEG
80150: PUSH
80151: LD_INT 1
80153: NEG
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 2
80161: NEG
80162: PUSH
80163: LD_INT 2
80165: NEG
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80192: LD_ADDR_VAR 0 23
80196: PUSH
80197: LD_INT 0
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 0
80209: PUSH
80210: LD_INT 1
80212: NEG
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 1
80220: PUSH
80221: LD_INT 0
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 1
80230: PUSH
80231: LD_INT 1
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 0
80240: PUSH
80241: LD_INT 1
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 1
80250: NEG
80251: PUSH
80252: LD_INT 0
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 1
80261: NEG
80262: PUSH
80263: LD_INT 1
80265: NEG
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: LD_INT 2
80277: NEG
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: LD_INT 2
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 1
80296: PUSH
80297: LD_INT 1
80299: NEG
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 2
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: EMPTY
80312: LIST
80313: LIST
80314: PUSH
80315: LD_INT 2
80317: PUSH
80318: LD_INT 1
80320: PUSH
80321: EMPTY
80322: LIST
80323: LIST
80324: PUSH
80325: LD_INT 2
80327: PUSH
80328: LD_INT 2
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 1
80337: PUSH
80338: LD_INT 2
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 0
80347: PUSH
80348: LD_INT 2
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 1
80357: NEG
80358: PUSH
80359: LD_INT 1
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 2
80368: NEG
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 2
80379: NEG
80380: PUSH
80381: LD_INT 1
80383: NEG
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 2
80391: NEG
80392: PUSH
80393: LD_INT 2
80395: NEG
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 2
80403: NEG
80404: PUSH
80405: LD_INT 3
80407: NEG
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: NEG
80416: PUSH
80417: LD_INT 3
80419: NEG
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 1
80427: PUSH
80428: LD_INT 2
80430: NEG
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 2
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: EMPTY
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
80472: LD_ADDR_VAR 0 24
80476: PUSH
80477: LD_INT 0
80479: PUSH
80480: LD_INT 0
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 0
80489: PUSH
80490: LD_INT 1
80492: NEG
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 1
80500: PUSH
80501: LD_INT 0
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 1
80510: PUSH
80511: LD_INT 1
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 0
80520: PUSH
80521: LD_INT 1
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 1
80530: NEG
80531: PUSH
80532: LD_INT 0
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: NEG
80542: PUSH
80543: LD_INT 1
80545: NEG
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 1
80553: NEG
80554: PUSH
80555: LD_INT 2
80557: NEG
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: LD_INT 0
80565: PUSH
80566: LD_INT 2
80568: NEG
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 1
80576: PUSH
80577: LD_INT 1
80579: NEG
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 2
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 2
80597: PUSH
80598: LD_INT 1
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 2
80607: PUSH
80608: LD_INT 2
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: LD_INT 2
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: LD_INT 2
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 1
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 2
80648: NEG
80649: PUSH
80650: LD_INT 0
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 2
80659: NEG
80660: PUSH
80661: LD_INT 1
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 2
80671: NEG
80672: PUSH
80673: LD_INT 2
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 1
80683: PUSH
80684: LD_INT 2
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 2
80694: PUSH
80695: LD_INT 1
80697: NEG
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 3
80705: PUSH
80706: LD_INT 1
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 3
80715: PUSH
80716: LD_INT 2
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
80748: LD_ADDR_VAR 0 25
80752: PUSH
80753: LD_INT 0
80755: PUSH
80756: LD_INT 0
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 0
80765: PUSH
80766: LD_INT 1
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 1
80776: PUSH
80777: LD_INT 0
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 1
80786: PUSH
80787: LD_INT 1
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 0
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 1
80806: NEG
80807: PUSH
80808: LD_INT 0
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 1
80817: NEG
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 2
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 0
80841: PUSH
80842: LD_INT 2
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: PUSH
80861: LD_INT 2
80863: PUSH
80864: LD_INT 0
80866: PUSH
80867: EMPTY
80868: LIST
80869: LIST
80870: PUSH
80871: LD_INT 2
80873: PUSH
80874: LD_INT 1
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 2
80883: PUSH
80884: LD_INT 2
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: LD_INT 1
80893: PUSH
80894: LD_INT 2
80896: PUSH
80897: EMPTY
80898: LIST
80899: LIST
80900: PUSH
80901: LD_INT 0
80903: PUSH
80904: LD_INT 2
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 1
80913: NEG
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 2
80924: NEG
80925: PUSH
80926: LD_INT 0
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 2
80935: NEG
80936: PUSH
80937: LD_INT 1
80939: NEG
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 2
80947: NEG
80948: PUSH
80949: LD_INT 2
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 3
80959: PUSH
80960: LD_INT 1
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 3
80969: PUSH
80970: LD_INT 2
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 2
80979: PUSH
80980: LD_INT 3
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 1
80989: PUSH
80990: LD_INT 3
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: LIST
81013: LIST
81014: LIST
81015: LIST
81016: LIST
81017: LIST
81018: LIST
81019: LIST
81020: LIST
81021: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81022: LD_ADDR_VAR 0 26
81026: PUSH
81027: LD_INT 0
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 0
81039: PUSH
81040: LD_INT 1
81042: NEG
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 1
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: PUSH
81061: LD_INT 1
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 0
81070: PUSH
81071: LD_INT 1
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: NEG
81081: PUSH
81082: LD_INT 0
81084: PUSH
81085: EMPTY
81086: LIST
81087: LIST
81088: PUSH
81089: LD_INT 1
81091: NEG
81092: PUSH
81093: LD_INT 1
81095: NEG
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 1
81103: NEG
81104: PUSH
81105: LD_INT 2
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 0
81115: PUSH
81116: LD_INT 2
81118: NEG
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 1
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: PUSH
81138: LD_INT 0
81140: PUSH
81141: EMPTY
81142: LIST
81143: LIST
81144: PUSH
81145: LD_INT 2
81147: PUSH
81148: LD_INT 1
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 2
81157: PUSH
81158: LD_INT 2
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 1
81167: PUSH
81168: LD_INT 2
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: LD_INT 2
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 1
81187: NEG
81188: PUSH
81189: LD_INT 1
81191: PUSH
81192: EMPTY
81193: LIST
81194: LIST
81195: PUSH
81196: LD_INT 2
81198: NEG
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 2
81209: NEG
81210: PUSH
81211: LD_INT 1
81213: NEG
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 2
81221: NEG
81222: PUSH
81223: LD_INT 2
81225: NEG
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 2
81233: PUSH
81234: LD_INT 3
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 1
81243: PUSH
81244: LD_INT 3
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PUSH
81251: LD_INT 1
81253: NEG
81254: PUSH
81255: LD_INT 2
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 2
81264: NEG
81265: PUSH
81266: LD_INT 1
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: LIST
81289: LIST
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81298: LD_ADDR_VAR 0 27
81302: PUSH
81303: LD_INT 0
81305: PUSH
81306: LD_INT 0
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: LD_INT 0
81315: PUSH
81316: LD_INT 1
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: LD_INT 0
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 1
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 1
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 1
81356: NEG
81357: PUSH
81358: LD_INT 0
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 1
81367: NEG
81368: PUSH
81369: LD_INT 1
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 1
81379: NEG
81380: PUSH
81381: LD_INT 2
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 0
81391: PUSH
81392: LD_INT 2
81394: NEG
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: LD_INT 1
81405: NEG
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 2
81413: PUSH
81414: LD_INT 0
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 2
81423: PUSH
81424: LD_INT 1
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 2
81433: PUSH
81434: LD_INT 2
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: LD_INT 2
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 0
81453: PUSH
81454: LD_INT 2
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 1
81463: NEG
81464: PUSH
81465: LD_INT 1
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 2
81474: NEG
81475: PUSH
81476: LD_INT 0
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 2
81485: NEG
81486: PUSH
81487: LD_INT 1
81489: NEG
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: PUSH
81495: LD_INT 2
81497: NEG
81498: PUSH
81499: LD_INT 2
81501: NEG
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 1
81509: NEG
81510: PUSH
81511: LD_INT 2
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 2
81520: NEG
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 3
81531: NEG
81532: PUSH
81533: LD_INT 1
81535: NEG
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: LD_INT 3
81543: NEG
81544: PUSH
81545: LD_INT 2
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: LIST
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81578: LD_ADDR_VAR 0 28
81582: PUSH
81583: LD_INT 0
81585: PUSH
81586: LD_INT 0
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: PUSH
81593: LD_INT 0
81595: PUSH
81596: LD_INT 1
81598: NEG
81599: PUSH
81600: EMPTY
81601: LIST
81602: LIST
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 1
81616: PUSH
81617: LD_INT 1
81619: PUSH
81620: EMPTY
81621: LIST
81622: LIST
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: LD_INT 1
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: LD_INT 1
81636: NEG
81637: PUSH
81638: LD_INT 0
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: LD_INT 1
81647: NEG
81648: PUSH
81649: LD_INT 1
81651: NEG
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: PUSH
81657: LD_INT 1
81659: NEG
81660: PUSH
81661: LD_INT 2
81663: NEG
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 0
81671: PUSH
81672: LD_INT 2
81674: NEG
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 1
81682: PUSH
81683: LD_INT 1
81685: NEG
81686: PUSH
81687: EMPTY
81688: LIST
81689: LIST
81690: PUSH
81691: LD_INT 2
81693: PUSH
81694: LD_INT 0
81696: PUSH
81697: EMPTY
81698: LIST
81699: LIST
81700: PUSH
81701: LD_INT 2
81703: PUSH
81704: LD_INT 1
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: PUSH
81711: LD_INT 2
81713: PUSH
81714: LD_INT 2
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 1
81723: PUSH
81724: LD_INT 2
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 0
81733: PUSH
81734: LD_INT 2
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 1
81743: NEG
81744: PUSH
81745: LD_INT 1
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 2
81754: NEG
81755: PUSH
81756: LD_INT 0
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 2
81765: NEG
81766: PUSH
81767: LD_INT 1
81769: NEG
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 2
81777: NEG
81778: PUSH
81779: LD_INT 2
81781: NEG
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 2
81789: NEG
81790: PUSH
81791: LD_INT 3
81793: NEG
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 1
81801: NEG
81802: PUSH
81803: LD_INT 3
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 3
81813: NEG
81814: PUSH
81815: LD_INT 1
81817: NEG
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 3
81825: NEG
81826: PUSH
81827: LD_INT 2
81829: NEG
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: LIST
81839: LIST
81840: LIST
81841: LIST
81842: LIST
81843: LIST
81844: LIST
81845: LIST
81846: LIST
81847: LIST
81848: LIST
81849: LIST
81850: LIST
81851: LIST
81852: LIST
81853: LIST
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
81860: LD_ADDR_VAR 0 29
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: LD_INT 0
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 0
81877: PUSH
81878: LD_INT 1
81880: NEG
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 1
81888: PUSH
81889: LD_INT 0
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: LD_INT 1
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 0
81908: PUSH
81909: LD_INT 1
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 1
81918: NEG
81919: PUSH
81920: LD_INT 0
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 1
81929: NEG
81930: PUSH
81931: LD_INT 1
81933: NEG
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 1
81941: NEG
81942: PUSH
81943: LD_INT 2
81945: NEG
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: LD_INT 2
81956: NEG
81957: PUSH
81958: EMPTY
81959: LIST
81960: LIST
81961: PUSH
81962: LD_INT 1
81964: PUSH
81965: LD_INT 1
81967: NEG
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_INT 2
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 2
81985: PUSH
81986: LD_INT 1
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: LD_INT 2
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 0
82005: PUSH
82006: LD_INT 2
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 2
82026: NEG
82027: PUSH
82028: LD_INT 1
82030: NEG
82031: PUSH
82032: EMPTY
82033: LIST
82034: LIST
82035: PUSH
82036: LD_INT 2
82038: NEG
82039: PUSH
82040: LD_INT 2
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 2
82050: NEG
82051: PUSH
82052: LD_INT 3
82054: NEG
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 2
82062: PUSH
82063: LD_INT 1
82065: NEG
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 3
82073: PUSH
82074: LD_INT 1
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: LD_INT 3
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: NEG
82094: PUSH
82095: LD_INT 2
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 3
82104: NEG
82105: PUSH
82106: LD_INT 2
82108: NEG
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: LIST
82118: LIST
82119: LIST
82120: LIST
82121: LIST
82122: LIST
82123: LIST
82124: LIST
82125: LIST
82126: LIST
82127: LIST
82128: LIST
82129: LIST
82130: LIST
82131: LIST
82132: LIST
82133: LIST
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82139: LD_ADDR_VAR 0 30
82143: PUSH
82144: LD_INT 0
82146: PUSH
82147: LD_INT 0
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: LD_INT 0
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 1
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 1
82177: PUSH
82178: LD_INT 1
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 0
82187: PUSH
82188: LD_INT 1
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 1
82197: NEG
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 1
82208: NEG
82209: PUSH
82210: LD_INT 1
82212: NEG
82213: PUSH
82214: EMPTY
82215: LIST
82216: LIST
82217: PUSH
82218: LD_INT 1
82220: NEG
82221: PUSH
82222: LD_INT 2
82224: NEG
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: LD_INT 2
82235: NEG
82236: PUSH
82237: EMPTY
82238: LIST
82239: LIST
82240: PUSH
82241: LD_INT 1
82243: PUSH
82244: LD_INT 1
82246: NEG
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 2
82254: PUSH
82255: LD_INT 0
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 2
82264: PUSH
82265: LD_INT 1
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 2
82274: PUSH
82275: LD_INT 2
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 1
82284: PUSH
82285: LD_INT 2
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 1
82294: NEG
82295: PUSH
82296: LD_INT 1
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 2
82305: NEG
82306: PUSH
82307: LD_INT 0
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 2
82316: NEG
82317: PUSH
82318: LD_INT 1
82320: NEG
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 1
82328: NEG
82329: PUSH
82330: LD_INT 3
82332: NEG
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PUSH
82338: LD_INT 1
82340: PUSH
82341: LD_INT 2
82343: NEG
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 3
82351: PUSH
82352: LD_INT 2
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 2
82361: PUSH
82362: LD_INT 3
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: LD_INT 2
82371: NEG
82372: PUSH
82373: LD_INT 1
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 3
82382: NEG
82383: PUSH
82384: LD_INT 1
82386: NEG
82387: PUSH
82388: EMPTY
82389: LIST
82390: LIST
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: LIST
82406: LIST
82407: LIST
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82417: LD_ADDR_VAR 0 31
82421: PUSH
82422: LD_INT 0
82424: PUSH
82425: LD_INT 0
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 1
82445: PUSH
82446: LD_INT 0
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: LD_INT 1
82455: PUSH
82456: LD_INT 1
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 0
82465: PUSH
82466: LD_INT 1
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 1
82475: NEG
82476: PUSH
82477: LD_INT 0
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 1
82486: NEG
82487: PUSH
82488: LD_INT 1
82490: NEG
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 1
82498: NEG
82499: PUSH
82500: LD_INT 2
82502: NEG
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: PUSH
82511: LD_INT 1
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 2
82531: PUSH
82532: LD_INT 1
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 2
82541: PUSH
82542: LD_INT 2
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 1
82551: PUSH
82552: LD_INT 2
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 0
82561: PUSH
82562: LD_INT 2
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: LD_INT 1
82586: NEG
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 2
82594: NEG
82595: PUSH
82596: LD_INT 2
82598: NEG
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 2
82606: NEG
82607: PUSH
82608: LD_INT 3
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 2
82618: PUSH
82619: LD_INT 1
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 3
82629: PUSH
82630: LD_INT 1
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 1
82639: PUSH
82640: LD_INT 3
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 1
82649: NEG
82650: PUSH
82651: LD_INT 2
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 3
82660: NEG
82661: PUSH
82662: LD_INT 2
82664: NEG
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: EMPTY
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: LIST
82679: LIST
82680: LIST
82681: LIST
82682: LIST
82683: LIST
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82695: LD_ADDR_VAR 0 32
82699: PUSH
82700: LD_INT 0
82702: PUSH
82703: LD_INT 0
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 0
82712: PUSH
82713: LD_INT 1
82715: NEG
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 1
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 1
82733: PUSH
82734: LD_INT 1
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 0
82743: PUSH
82744: LD_INT 1
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 1
82753: NEG
82754: PUSH
82755: LD_INT 0
82757: PUSH
82758: EMPTY
82759: LIST
82760: LIST
82761: PUSH
82762: LD_INT 1
82764: NEG
82765: PUSH
82766: LD_INT 1
82768: NEG
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PUSH
82774: LD_INT 1
82776: NEG
82777: PUSH
82778: LD_INT 2
82780: NEG
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 0
82788: PUSH
82789: LD_INT 2
82791: NEG
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 1
82799: PUSH
82800: LD_INT 1
82802: NEG
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: PUSH
82808: LD_INT 2
82810: PUSH
82811: LD_INT 1
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: PUSH
82818: LD_INT 2
82820: PUSH
82821: LD_INT 2
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 1
82830: PUSH
82831: LD_INT 2
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 0
82840: PUSH
82841: LD_INT 2
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 1
82850: NEG
82851: PUSH
82852: LD_INT 1
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 2
82861: NEG
82862: PUSH
82863: LD_INT 0
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 2
82872: NEG
82873: PUSH
82874: LD_INT 1
82876: NEG
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: LD_INT 3
82888: NEG
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 1
82896: PUSH
82897: LD_INT 2
82899: NEG
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: PUSH
82905: LD_INT 3
82907: PUSH
82908: LD_INT 2
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 2
82917: PUSH
82918: LD_INT 3
82920: PUSH
82921: EMPTY
82922: LIST
82923: LIST
82924: PUSH
82925: LD_INT 2
82927: NEG
82928: PUSH
82929: LD_INT 1
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 3
82938: NEG
82939: PUSH
82940: LD_INT 1
82942: NEG
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: LIST
82952: LIST
82953: LIST
82954: LIST
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: LIST
82962: LIST
82963: LIST
82964: LIST
82965: LIST
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: LIST
82972: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82973: LD_ADDR_VAR 0 33
82977: PUSH
82978: LD_INT 0
82980: PUSH
82981: LD_INT 0
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 0
82990: PUSH
82991: LD_INT 1
82993: NEG
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 1
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: LD_INT 1
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 0
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: LD_INT 0
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 1
83042: NEG
83043: PUSH
83044: LD_INT 1
83046: NEG
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: LD_INT 1
83054: NEG
83055: PUSH
83056: LD_INT 2
83058: NEG
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: PUSH
83067: LD_INT 1
83069: NEG
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 2
83077: PUSH
83078: LD_INT 0
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 2
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 1
83097: PUSH
83098: LD_INT 2
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: PUSH
83105: LD_INT 0
83107: PUSH
83108: LD_INT 2
83110: PUSH
83111: EMPTY
83112: LIST
83113: LIST
83114: PUSH
83115: LD_INT 1
83117: NEG
83118: PUSH
83119: LD_INT 1
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: PUSH
83126: LD_INT 2
83128: NEG
83129: PUSH
83130: LD_INT 0
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 2
83139: NEG
83140: PUSH
83141: LD_INT 1
83143: NEG
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 2
83151: NEG
83152: PUSH
83153: LD_INT 2
83155: NEG
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 2
83163: NEG
83164: PUSH
83165: LD_INT 3
83167: NEG
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 2
83175: PUSH
83176: LD_INT 1
83178: NEG
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 3
83186: PUSH
83187: LD_INT 1
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 1
83196: PUSH
83197: LD_INT 3
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 1
83206: NEG
83207: PUSH
83208: LD_INT 2
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 3
83217: NEG
83218: PUSH
83219: LD_INT 2
83221: NEG
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83252: LD_ADDR_VAR 0 34
83256: PUSH
83257: LD_INT 0
83259: PUSH
83260: LD_INT 0
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: PUSH
83267: LD_INT 0
83269: PUSH
83270: LD_INT 1
83272: NEG
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 1
83280: PUSH
83281: LD_INT 0
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: LD_INT 1
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 1
83310: NEG
83311: PUSH
83312: LD_INT 0
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: LD_INT 1
83325: NEG
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 1
83333: NEG
83334: PUSH
83335: LD_INT 2
83337: NEG
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PUSH
83343: LD_INT 0
83345: PUSH
83346: LD_INT 2
83348: NEG
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 1
83356: PUSH
83357: LD_INT 1
83359: NEG
83360: PUSH
83361: EMPTY
83362: LIST
83363: LIST
83364: PUSH
83365: LD_INT 2
83367: PUSH
83368: LD_INT 1
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: PUSH
83375: LD_INT 2
83377: PUSH
83378: LD_INT 2
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: LD_INT 1
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 1
83397: NEG
83398: PUSH
83399: LD_INT 1
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 2
83408: NEG
83409: PUSH
83410: LD_INT 0
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 2
83419: NEG
83420: PUSH
83421: LD_INT 1
83423: NEG
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: PUSH
83429: LD_INT 2
83431: NEG
83432: PUSH
83433: LD_INT 2
83435: NEG
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PUSH
83441: LD_INT 1
83443: NEG
83444: PUSH
83445: LD_INT 3
83447: NEG
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 1
83455: PUSH
83456: LD_INT 2
83458: NEG
83459: PUSH
83460: EMPTY
83461: LIST
83462: LIST
83463: PUSH
83464: LD_INT 3
83466: PUSH
83467: LD_INT 2
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 2
83476: PUSH
83477: LD_INT 3
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 2
83486: NEG
83487: PUSH
83488: LD_INT 1
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 3
83497: NEG
83498: PUSH
83499: LD_INT 1
83501: NEG
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: LIST
83511: LIST
83512: LIST
83513: LIST
83514: LIST
83515: LIST
83516: LIST
83517: LIST
83518: LIST
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83532: LD_ADDR_VAR 0 35
83536: PUSH
83537: LD_INT 0
83539: PUSH
83540: LD_INT 0
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: PUSH
83547: LD_INT 0
83549: PUSH
83550: LD_INT 1
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 1
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 1
83570: PUSH
83571: LD_INT 1
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 0
83580: PUSH
83581: LD_INT 1
83583: PUSH
83584: EMPTY
83585: LIST
83586: LIST
83587: PUSH
83588: LD_INT 1
83590: NEG
83591: PUSH
83592: LD_INT 0
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 1
83601: NEG
83602: PUSH
83603: LD_INT 1
83605: NEG
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 2
83613: PUSH
83614: LD_INT 1
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 2
83623: NEG
83624: PUSH
83625: LD_INT 1
83627: NEG
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83644: LD_ADDR_VAR 0 36
83648: PUSH
83649: LD_INT 0
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 0
83661: PUSH
83662: LD_INT 1
83664: NEG
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 1
83672: PUSH
83673: LD_INT 0
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 1
83682: PUSH
83683: LD_INT 1
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 0
83692: PUSH
83693: LD_INT 1
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 1
83702: NEG
83703: PUSH
83704: LD_INT 0
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 1
83713: NEG
83714: PUSH
83715: LD_INT 1
83717: NEG
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 1
83725: NEG
83726: PUSH
83727: LD_INT 2
83729: NEG
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 1
83737: PUSH
83738: LD_INT 2
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: LIST
83755: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
83756: LD_ADDR_VAR 0 37
83760: PUSH
83761: LD_INT 0
83763: PUSH
83764: LD_INT 0
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: LD_INT 0
83773: PUSH
83774: LD_INT 1
83776: NEG
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 1
83784: PUSH
83785: LD_INT 0
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 1
83794: PUSH
83795: LD_INT 1
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 0
83804: PUSH
83805: LD_INT 1
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 1
83814: NEG
83815: PUSH
83816: LD_INT 0
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 1
83825: NEG
83826: PUSH
83827: LD_INT 1
83829: NEG
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 1
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 1
83848: NEG
83849: PUSH
83850: LD_INT 1
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
83868: LD_ADDR_VAR 0 38
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: LD_INT 0
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 0
83885: PUSH
83886: LD_INT 1
83888: NEG
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 1
83896: PUSH
83897: LD_INT 0
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 1
83906: PUSH
83907: LD_INT 1
83909: PUSH
83910: EMPTY
83911: LIST
83912: LIST
83913: PUSH
83914: LD_INT 0
83916: PUSH
83917: LD_INT 1
83919: PUSH
83920: EMPTY
83921: LIST
83922: LIST
83923: PUSH
83924: LD_INT 1
83926: NEG
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 1
83937: NEG
83938: PUSH
83939: LD_INT 1
83941: NEG
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 2
83949: PUSH
83950: LD_INT 1
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 2
83959: NEG
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
83980: LD_ADDR_VAR 0 39
83984: PUSH
83985: LD_INT 0
83987: PUSH
83988: LD_INT 0
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 0
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: PUSH
84009: LD_INT 0
84011: PUSH
84012: EMPTY
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 1
84018: PUSH
84019: LD_INT 1
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: LD_INT 1
84031: PUSH
84032: EMPTY
84033: LIST
84034: LIST
84035: PUSH
84036: LD_INT 1
84038: NEG
84039: PUSH
84040: LD_INT 0
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: LD_INT 1
84053: NEG
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 1
84061: NEG
84062: PUSH
84063: LD_INT 2
84065: NEG
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: PUSH
84071: LD_INT 1
84073: PUSH
84074: LD_INT 2
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: EMPTY
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84092: LD_ADDR_VAR 0 40
84096: PUSH
84097: LD_INT 0
84099: PUSH
84100: LD_INT 0
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: PUSH
84107: LD_INT 0
84109: PUSH
84110: LD_INT 1
84112: NEG
84113: PUSH
84114: EMPTY
84115: LIST
84116: LIST
84117: PUSH
84118: LD_INT 1
84120: PUSH
84121: LD_INT 0
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: PUSH
84128: LD_INT 1
84130: PUSH
84131: LD_INT 1
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: LD_INT 1
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 1
84150: NEG
84151: PUSH
84152: LD_INT 0
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 1
84161: NEG
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: PUSH
84174: LD_INT 1
84176: NEG
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 1
84184: NEG
84185: PUSH
84186: LD_INT 1
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: LIST
84197: LIST
84198: LIST
84199: LIST
84200: LIST
84201: LIST
84202: LIST
84203: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84204: LD_ADDR_VAR 0 41
84208: PUSH
84209: LD_INT 0
84211: PUSH
84212: LD_INT 0
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 0
84221: PUSH
84222: LD_INT 1
84224: NEG
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PUSH
84230: LD_INT 1
84232: PUSH
84233: LD_INT 0
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: LD_INT 1
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 0
84252: PUSH
84253: LD_INT 1
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: NEG
84263: PUSH
84264: LD_INT 0
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 1
84273: NEG
84274: PUSH
84275: LD_INT 1
84277: NEG
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 1
84285: NEG
84286: PUSH
84287: LD_INT 2
84289: NEG
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 1
84297: PUSH
84298: LD_INT 1
84300: NEG
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 2
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 2
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: LD_INT 2
84328: PUSH
84329: LD_INT 2
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 1
84338: PUSH
84339: LD_INT 2
84341: PUSH
84342: EMPTY
84343: LIST
84344: LIST
84345: PUSH
84346: LD_INT 1
84348: NEG
84349: PUSH
84350: LD_INT 1
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: LD_INT 2
84359: NEG
84360: PUSH
84361: LD_INT 0
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 2
84370: NEG
84371: PUSH
84372: LD_INT 1
84374: NEG
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: LD_INT 2
84382: NEG
84383: PUSH
84384: LD_INT 2
84386: NEG
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 2
84394: NEG
84395: PUSH
84396: LD_INT 3
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: PUSH
84407: LD_INT 1
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 3
84417: PUSH
84418: LD_INT 0
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 3
84427: PUSH
84428: LD_INT 1
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 3
84437: PUSH
84438: LD_INT 2
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 3
84447: PUSH
84448: LD_INT 3
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 2
84457: PUSH
84458: LD_INT 3
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: EMPTY
84473: LIST
84474: LIST
84475: PUSH
84476: LD_INT 3
84478: NEG
84479: PUSH
84480: LD_INT 0
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 3
84489: NEG
84490: PUSH
84491: LD_INT 1
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 3
84501: NEG
84502: PUSH
84503: LD_INT 2
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 3
84513: NEG
84514: PUSH
84515: LD_INT 3
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: LIST
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84554: LD_ADDR_VAR 0 42
84558: PUSH
84559: LD_INT 0
84561: PUSH
84562: LD_INT 0
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 0
84571: PUSH
84572: LD_INT 1
84574: NEG
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 1
84582: PUSH
84583: LD_INT 0
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 1
84592: PUSH
84593: LD_INT 1
84595: PUSH
84596: EMPTY
84597: LIST
84598: LIST
84599: PUSH
84600: LD_INT 0
84602: PUSH
84603: LD_INT 1
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PUSH
84610: LD_INT 1
84612: NEG
84613: PUSH
84614: LD_INT 0
84616: PUSH
84617: EMPTY
84618: LIST
84619: LIST
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: LD_INT 1
84627: NEG
84628: PUSH
84629: EMPTY
84630: LIST
84631: LIST
84632: PUSH
84633: LD_INT 1
84635: NEG
84636: PUSH
84637: LD_INT 2
84639: NEG
84640: PUSH
84641: EMPTY
84642: LIST
84643: LIST
84644: PUSH
84645: LD_INT 0
84647: PUSH
84648: LD_INT 2
84650: NEG
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: PUSH
84656: LD_INT 1
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PUSH
84667: LD_INT 2
84669: PUSH
84670: LD_INT 1
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: PUSH
84677: LD_INT 2
84679: PUSH
84680: LD_INT 2
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: PUSH
84690: LD_INT 2
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 0
84699: PUSH
84700: LD_INT 2
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 1
84709: NEG
84710: PUSH
84711: LD_INT 1
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: PUSH
84718: LD_INT 2
84720: NEG
84721: PUSH
84722: LD_INT 1
84724: NEG
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 2
84732: NEG
84733: PUSH
84734: LD_INT 2
84736: NEG
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: PUSH
84742: LD_INT 2
84744: NEG
84745: PUSH
84746: LD_INT 3
84748: NEG
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: PUSH
84754: LD_INT 1
84756: NEG
84757: PUSH
84758: LD_INT 3
84760: NEG
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 0
84768: PUSH
84769: LD_INT 3
84771: NEG
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: PUSH
84777: LD_INT 1
84779: PUSH
84780: LD_INT 2
84782: NEG
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PUSH
84788: LD_INT 3
84790: PUSH
84791: LD_INT 2
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: PUSH
84798: LD_INT 3
84800: PUSH
84801: LD_INT 3
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_INT 2
84810: PUSH
84811: LD_INT 3
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: LD_INT 3
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 0
84830: PUSH
84831: LD_INT 3
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: LD_INT 1
84840: NEG
84841: PUSH
84842: LD_INT 2
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PUSH
84849: LD_INT 3
84851: NEG
84852: PUSH
84853: LD_INT 2
84855: NEG
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: PUSH
84861: LD_INT 3
84863: NEG
84864: PUSH
84865: LD_INT 3
84867: NEG
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: LIST
84882: LIST
84883: LIST
84884: LIST
84885: LIST
84886: LIST
84887: LIST
84888: LIST
84889: LIST
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
84904: LD_ADDR_VAR 0 43
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: LD_INT 0
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 0
84921: PUSH
84922: LD_INT 1
84924: NEG
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: LD_INT 0
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 1
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: LD_INT 1
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 1
84962: NEG
84963: PUSH
84964: LD_INT 0
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: LD_INT 1
84977: NEG
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 1
84985: NEG
84986: PUSH
84987: LD_INT 2
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 0
84997: PUSH
84998: LD_INT 2
85000: NEG
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: PUSH
85009: LD_INT 1
85011: NEG
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 2
85019: PUSH
85020: LD_INT 0
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 2
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 1
85039: PUSH
85040: LD_INT 2
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 0
85049: PUSH
85050: LD_INT 2
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 1
85059: NEG
85060: PUSH
85061: LD_INT 1
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 2
85070: NEG
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 2
85081: NEG
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: LD_INT 3
85097: NEG
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 0
85105: PUSH
85106: LD_INT 3
85108: NEG
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: LD_INT 2
85119: NEG
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 2
85127: PUSH
85128: LD_INT 1
85130: NEG
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 3
85138: PUSH
85139: LD_INT 0
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 3
85148: PUSH
85149: LD_INT 1
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 1
85158: PUSH
85159: LD_INT 3
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 0
85168: PUSH
85169: LD_INT 3
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 1
85178: NEG
85179: PUSH
85180: LD_INT 2
85182: PUSH
85183: EMPTY
85184: LIST
85185: LIST
85186: PUSH
85187: LD_INT 2
85189: NEG
85190: PUSH
85191: LD_INT 1
85193: PUSH
85194: EMPTY
85195: LIST
85196: LIST
85197: PUSH
85198: LD_INT 3
85200: NEG
85201: PUSH
85202: LD_INT 0
85204: PUSH
85205: EMPTY
85206: LIST
85207: LIST
85208: PUSH
85209: LD_INT 3
85211: NEG
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: LIST
85251: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85252: LD_ADDR_VAR 0 44
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: LD_INT 0
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 0
85269: PUSH
85270: LD_INT 1
85272: NEG
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 1
85280: PUSH
85281: LD_INT 0
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: PUSH
85291: LD_INT 1
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 0
85300: PUSH
85301: LD_INT 1
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 1
85310: NEG
85311: PUSH
85312: LD_INT 0
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 1
85321: NEG
85322: PUSH
85323: LD_INT 1
85325: NEG
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: LD_INT 2
85337: NEG
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 1
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 2
85356: PUSH
85357: LD_INT 0
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 2
85366: PUSH
85367: LD_INT 1
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 2
85376: PUSH
85377: LD_INT 2
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 1
85386: PUSH
85387: LD_INT 2
85389: PUSH
85390: EMPTY
85391: LIST
85392: LIST
85393: PUSH
85394: LD_INT 1
85396: NEG
85397: PUSH
85398: LD_INT 1
85400: PUSH
85401: EMPTY
85402: LIST
85403: LIST
85404: PUSH
85405: LD_INT 2
85407: NEG
85408: PUSH
85409: LD_INT 0
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 2
85418: NEG
85419: PUSH
85420: LD_INT 1
85422: NEG
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: NEG
85431: PUSH
85432: LD_INT 2
85434: NEG
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 2
85442: NEG
85443: PUSH
85444: LD_INT 3
85446: NEG
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 2
85454: PUSH
85455: LD_INT 1
85457: NEG
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PUSH
85463: LD_INT 3
85465: PUSH
85466: LD_INT 0
85468: PUSH
85469: EMPTY
85470: LIST
85471: LIST
85472: PUSH
85473: LD_INT 3
85475: PUSH
85476: LD_INT 1
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 3
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 3
85495: PUSH
85496: LD_INT 3
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 2
85505: PUSH
85506: LD_INT 3
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 2
85515: NEG
85516: PUSH
85517: LD_INT 1
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: LD_INT 3
85526: NEG
85527: PUSH
85528: LD_INT 0
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PUSH
85535: LD_INT 3
85537: NEG
85538: PUSH
85539: LD_INT 1
85541: NEG
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: PUSH
85547: LD_INT 3
85549: NEG
85550: PUSH
85551: LD_INT 2
85553: NEG
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 3
85561: NEG
85562: PUSH
85563: LD_INT 3
85565: NEG
85566: PUSH
85567: EMPTY
85568: LIST
85569: LIST
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: LIST
85584: LIST
85585: LIST
85586: LIST
85587: LIST
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85602: LD_ADDR_VAR 0 45
85606: PUSH
85607: LD_INT 0
85609: PUSH
85610: LD_INT 0
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 0
85619: PUSH
85620: LD_INT 1
85622: NEG
85623: PUSH
85624: EMPTY
85625: LIST
85626: LIST
85627: PUSH
85628: LD_INT 1
85630: PUSH
85631: LD_INT 0
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 1
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 0
85650: PUSH
85651: LD_INT 1
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PUSH
85658: LD_INT 1
85660: NEG
85661: PUSH
85662: LD_INT 0
85664: PUSH
85665: EMPTY
85666: LIST
85667: LIST
85668: PUSH
85669: LD_INT 1
85671: NEG
85672: PUSH
85673: LD_INT 1
85675: NEG
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 1
85683: NEG
85684: PUSH
85685: LD_INT 2
85687: NEG
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 0
85695: PUSH
85696: LD_INT 2
85698: NEG
85699: PUSH
85700: EMPTY
85701: LIST
85702: LIST
85703: PUSH
85704: LD_INT 1
85706: PUSH
85707: LD_INT 1
85709: NEG
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 2
85717: PUSH
85718: LD_INT 1
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 2
85727: PUSH
85728: LD_INT 2
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 1
85737: PUSH
85738: LD_INT 2
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: PUSH
85745: LD_INT 0
85747: PUSH
85748: LD_INT 2
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: PUSH
85755: LD_INT 1
85757: NEG
85758: PUSH
85759: LD_INT 1
85761: PUSH
85762: EMPTY
85763: LIST
85764: LIST
85765: PUSH
85766: LD_INT 2
85768: NEG
85769: PUSH
85770: LD_INT 1
85772: NEG
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 2
85780: NEG
85781: PUSH
85782: LD_INT 2
85784: NEG
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 2
85792: NEG
85793: PUSH
85794: LD_INT 3
85796: NEG
85797: PUSH
85798: EMPTY
85799: LIST
85800: LIST
85801: PUSH
85802: LD_INT 1
85804: NEG
85805: PUSH
85806: LD_INT 3
85808: NEG
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 0
85816: PUSH
85817: LD_INT 3
85819: NEG
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 1
85827: PUSH
85828: LD_INT 2
85830: NEG
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: PUSH
85836: LD_INT 3
85838: PUSH
85839: LD_INT 2
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 3
85848: PUSH
85849: LD_INT 3
85851: PUSH
85852: EMPTY
85853: LIST
85854: LIST
85855: PUSH
85856: LD_INT 2
85858: PUSH
85859: LD_INT 3
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 1
85868: PUSH
85869: LD_INT 3
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: LD_INT 0
85878: PUSH
85879: LD_INT 3
85881: PUSH
85882: EMPTY
85883: LIST
85884: LIST
85885: PUSH
85886: LD_INT 1
85888: NEG
85889: PUSH
85890: LD_INT 2
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: LD_INT 3
85899: NEG
85900: PUSH
85901: LD_INT 2
85903: NEG
85904: PUSH
85905: EMPTY
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 3
85911: NEG
85912: PUSH
85913: LD_INT 3
85915: NEG
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85952: LD_ADDR_VAR 0 46
85956: PUSH
85957: LD_INT 0
85959: PUSH
85960: LD_INT 0
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 0
85969: PUSH
85970: LD_INT 1
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: LD_INT 0
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 1
85990: PUSH
85991: LD_INT 1
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 0
86000: PUSH
86001: LD_INT 1
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 1
86010: NEG
86011: PUSH
86012: LD_INT 0
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 1
86021: NEG
86022: PUSH
86023: LD_INT 1
86025: NEG
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 1
86033: NEG
86034: PUSH
86035: LD_INT 2
86037: NEG
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 0
86045: PUSH
86046: LD_INT 2
86048: NEG
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 1
86056: PUSH
86057: LD_INT 1
86059: NEG
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 2
86067: PUSH
86068: LD_INT 0
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 2
86077: PUSH
86078: LD_INT 1
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: LD_INT 2
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 2
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 1
86107: NEG
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 2
86118: NEG
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 2
86129: NEG
86130: PUSH
86131: LD_INT 1
86133: NEG
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: LD_INT 3
86145: NEG
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 0
86153: PUSH
86154: LD_INT 3
86156: NEG
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 1
86164: PUSH
86165: LD_INT 2
86167: NEG
86168: PUSH
86169: EMPTY
86170: LIST
86171: LIST
86172: PUSH
86173: LD_INT 2
86175: PUSH
86176: LD_INT 1
86178: NEG
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PUSH
86184: LD_INT 3
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 3
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: LD_INT 3
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 0
86216: PUSH
86217: LD_INT 3
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 1
86226: NEG
86227: PUSH
86228: LD_INT 2
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 2
86237: NEG
86238: PUSH
86239: LD_INT 1
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 3
86248: NEG
86249: PUSH
86250: LD_INT 0
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 3
86259: NEG
86260: PUSH
86261: LD_INT 1
86263: NEG
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: LIST
86283: LIST
86284: LIST
86285: LIST
86286: LIST
86287: LIST
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86300: LD_ADDR_VAR 0 47
86304: PUSH
86305: LD_INT 0
86307: PUSH
86308: LD_INT 0
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 0
86317: PUSH
86318: LD_INT 1
86320: NEG
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 1
86328: PUSH
86329: LD_INT 0
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 1
86338: PUSH
86339: LD_INT 1
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 0
86348: PUSH
86349: LD_INT 1
86351: PUSH
86352: EMPTY
86353: LIST
86354: LIST
86355: PUSH
86356: LD_INT 1
86358: NEG
86359: PUSH
86360: LD_INT 0
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 1
86369: NEG
86370: PUSH
86371: LD_INT 1
86373: NEG
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: LD_INT 1
86381: NEG
86382: PUSH
86383: LD_INT 2
86385: NEG
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 0
86393: PUSH
86394: LD_INT 2
86396: NEG
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 1
86404: PUSH
86405: LD_INT 1
86407: NEG
86408: PUSH
86409: EMPTY
86410: LIST
86411: LIST
86412: PUSH
86413: LD_INT 2
86415: NEG
86416: PUSH
86417: LD_INT 1
86419: NEG
86420: PUSH
86421: EMPTY
86422: LIST
86423: LIST
86424: PUSH
86425: LD_INT 2
86427: NEG
86428: PUSH
86429: LD_INT 2
86431: NEG
86432: PUSH
86433: EMPTY
86434: LIST
86435: LIST
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
86451: LD_ADDR_VAR 0 48
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 0
86468: PUSH
86469: LD_INT 1
86471: NEG
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 0
86499: PUSH
86500: LD_INT 1
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 1
86509: NEG
86510: PUSH
86511: LD_INT 0
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 1
86520: NEG
86521: PUSH
86522: LD_INT 1
86524: NEG
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: NEG
86533: PUSH
86534: LD_INT 2
86536: NEG
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 0
86544: PUSH
86545: LD_INT 2
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 1
86555: PUSH
86556: LD_INT 1
86558: NEG
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: LD_INT 2
86566: PUSH
86567: LD_INT 0
86569: PUSH
86570: EMPTY
86571: LIST
86572: LIST
86573: PUSH
86574: LD_INT 2
86576: PUSH
86577: LD_INT 1
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: LIST
86595: LIST
86596: LIST
86597: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
86598: LD_ADDR_VAR 0 49
86602: PUSH
86603: LD_INT 0
86605: PUSH
86606: LD_INT 0
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 0
86615: PUSH
86616: LD_INT 1
86618: NEG
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 1
86626: PUSH
86627: LD_INT 0
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: LD_INT 1
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: PUSH
86644: LD_INT 0
86646: PUSH
86647: LD_INT 1
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: LD_INT 0
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: LD_INT 1
86667: NEG
86668: PUSH
86669: LD_INT 1
86671: NEG
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 1
86679: PUSH
86680: LD_INT 1
86682: NEG
86683: PUSH
86684: EMPTY
86685: LIST
86686: LIST
86687: PUSH
86688: LD_INT 2
86690: PUSH
86691: LD_INT 0
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 2
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: PUSH
86711: LD_INT 2
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 1
86720: PUSH
86721: LD_INT 2
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: LIST
86732: LIST
86733: LIST
86734: LIST
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: LIST
86741: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
86742: LD_ADDR_VAR 0 50
86746: PUSH
86747: LD_INT 0
86749: PUSH
86750: LD_INT 0
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 0
86759: PUSH
86760: LD_INT 1
86762: NEG
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 1
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 1
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: EMPTY
86785: LIST
86786: LIST
86787: PUSH
86788: LD_INT 0
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: PUSH
86798: LD_INT 1
86800: NEG
86801: PUSH
86802: LD_INT 0
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 1
86811: NEG
86812: PUSH
86813: LD_INT 1
86815: NEG
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 2
86823: PUSH
86824: LD_INT 1
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 2
86833: PUSH
86834: LD_INT 2
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: LD_INT 2
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 0
86853: PUSH
86854: LD_INT 2
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 1
86863: NEG
86864: PUSH
86865: LD_INT 1
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
86886: LD_ADDR_VAR 0 51
86890: PUSH
86891: LD_INT 0
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: LD_INT 0
86903: PUSH
86904: LD_INT 1
86906: NEG
86907: PUSH
86908: EMPTY
86909: LIST
86910: LIST
86911: PUSH
86912: LD_INT 1
86914: PUSH
86915: LD_INT 0
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: PUSH
86922: LD_INT 1
86924: PUSH
86925: LD_INT 1
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: LD_INT 0
86934: PUSH
86935: LD_INT 1
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: PUSH
86942: LD_INT 1
86944: NEG
86945: PUSH
86946: LD_INT 0
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: LD_INT 1
86955: NEG
86956: PUSH
86957: LD_INT 1
86959: NEG
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 1
86967: PUSH
86968: LD_INT 2
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 0
86977: PUSH
86978: LD_INT 2
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: LD_INT 1
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 2
86998: NEG
86999: PUSH
87000: LD_INT 0
87002: PUSH
87003: EMPTY
87004: LIST
87005: LIST
87006: PUSH
87007: LD_INT 2
87009: NEG
87010: PUSH
87011: LD_INT 1
87013: NEG
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87033: LD_ADDR_VAR 0 52
87037: PUSH
87038: LD_INT 0
87040: PUSH
87041: LD_INT 0
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: LD_INT 1
87053: NEG
87054: PUSH
87055: EMPTY
87056: LIST
87057: LIST
87058: PUSH
87059: LD_INT 1
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 1
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 0
87081: PUSH
87082: LD_INT 1
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 1
87091: NEG
87092: PUSH
87093: LD_INT 0
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: LD_INT 1
87102: NEG
87103: PUSH
87104: LD_INT 1
87106: NEG
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: LD_INT 2
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 1
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 2
87137: NEG
87138: PUSH
87139: LD_INT 0
87141: PUSH
87142: EMPTY
87143: LIST
87144: LIST
87145: PUSH
87146: LD_INT 2
87148: NEG
87149: PUSH
87150: LD_INT 1
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 2
87160: NEG
87161: PUSH
87162: LD_INT 2
87164: NEG
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87184: LD_ADDR_VAR 0 53
87188: PUSH
87189: LD_INT 0
87191: PUSH
87192: LD_INT 0
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: LD_INT 1
87204: NEG
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 1
87212: PUSH
87213: LD_INT 0
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: PUSH
87223: LD_INT 1
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 0
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 1
87242: NEG
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: EMPTY
87248: LIST
87249: LIST
87250: PUSH
87251: LD_INT 1
87253: NEG
87254: PUSH
87255: LD_INT 1
87257: NEG
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: PUSH
87263: LD_INT 1
87265: NEG
87266: PUSH
87267: LD_INT 2
87269: NEG
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 0
87277: PUSH
87278: LD_INT 2
87280: NEG
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 1
87288: PUSH
87289: LD_INT 1
87291: NEG
87292: PUSH
87293: EMPTY
87294: LIST
87295: LIST
87296: PUSH
87297: LD_INT 2
87299: PUSH
87300: LD_INT 0
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PUSH
87307: LD_INT 2
87309: PUSH
87310: LD_INT 1
87312: PUSH
87313: EMPTY
87314: LIST
87315: LIST
87316: PUSH
87317: LD_INT 2
87319: PUSH
87320: LD_INT 2
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 0
87339: PUSH
87340: LD_INT 2
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: LD_INT 1
87349: NEG
87350: PUSH
87351: LD_INT 1
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 2
87360: NEG
87361: PUSH
87362: LD_INT 0
87364: PUSH
87365: EMPTY
87366: LIST
87367: LIST
87368: PUSH
87369: LD_INT 2
87371: NEG
87372: PUSH
87373: LD_INT 1
87375: NEG
87376: PUSH
87377: EMPTY
87378: LIST
87379: LIST
87380: PUSH
87381: LD_INT 2
87383: NEG
87384: PUSH
87385: LD_INT 2
87387: NEG
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: EMPTY
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87414: LD_ADDR_VAR 0 54
87418: PUSH
87419: LD_INT 0
87421: PUSH
87422: LD_INT 0
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 0
87431: PUSH
87432: LD_INT 1
87434: NEG
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 1
87442: PUSH
87443: LD_INT 0
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 1
87452: PUSH
87453: LD_INT 1
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 0
87462: PUSH
87463: LD_INT 1
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 1
87472: NEG
87473: PUSH
87474: LD_INT 0
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 1
87483: NEG
87484: PUSH
87485: LD_INT 1
87487: NEG
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 1
87495: NEG
87496: PUSH
87497: LD_INT 2
87499: NEG
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 0
87507: PUSH
87508: LD_INT 2
87510: NEG
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 1
87518: PUSH
87519: LD_INT 1
87521: NEG
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PUSH
87527: LD_INT 2
87529: PUSH
87530: LD_INT 0
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PUSH
87537: LD_INT 2
87539: PUSH
87540: LD_INT 1
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: PUSH
87547: LD_INT 2
87549: PUSH
87550: LD_INT 2
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 1
87559: PUSH
87560: LD_INT 2
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 0
87569: PUSH
87570: LD_INT 2
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 1
87579: NEG
87580: PUSH
87581: LD_INT 1
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 2
87590: NEG
87591: PUSH
87592: LD_INT 0
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 2
87601: NEG
87602: PUSH
87603: LD_INT 1
87605: NEG
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 2
87613: NEG
87614: PUSH
87615: LD_INT 2
87617: NEG
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87644: LD_ADDR_VAR 0 55
87648: PUSH
87649: LD_INT 0
87651: PUSH
87652: LD_INT 0
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: LD_INT 1
87664: NEG
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: LD_INT 0
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: PUSH
87683: LD_INT 1
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: PUSH
87690: LD_INT 0
87692: PUSH
87693: LD_INT 1
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: PUSH
87700: LD_INT 1
87702: NEG
87703: PUSH
87704: LD_INT 0
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: LD_INT 1
87717: NEG
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 1
87725: NEG
87726: PUSH
87727: LD_INT 2
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 0
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: LD_INT 1
87748: PUSH
87749: LD_INT 1
87751: NEG
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: PUSH
87757: LD_INT 2
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 2
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: LD_INT 2
87779: PUSH
87780: LD_INT 2
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 1
87789: PUSH
87790: LD_INT 2
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 0
87799: PUSH
87800: LD_INT 2
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 1
87809: NEG
87810: PUSH
87811: LD_INT 1
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: LD_INT 2
87820: NEG
87821: PUSH
87822: LD_INT 0
87824: PUSH
87825: EMPTY
87826: LIST
87827: LIST
87828: PUSH
87829: LD_INT 2
87831: NEG
87832: PUSH
87833: LD_INT 1
87835: NEG
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 2
87843: NEG
87844: PUSH
87845: LD_INT 2
87847: NEG
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87874: LD_ADDR_VAR 0 56
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: LD_INT 0
87891: PUSH
87892: LD_INT 1
87894: NEG
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PUSH
87900: LD_INT 1
87902: PUSH
87903: LD_INT 0
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 1
87912: PUSH
87913: LD_INT 1
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: LD_INT 0
87922: PUSH
87923: LD_INT 1
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 1
87932: NEG
87933: PUSH
87934: LD_INT 0
87936: PUSH
87937: EMPTY
87938: LIST
87939: LIST
87940: PUSH
87941: LD_INT 1
87943: NEG
87944: PUSH
87945: LD_INT 1
87947: NEG
87948: PUSH
87949: EMPTY
87950: LIST
87951: LIST
87952: PUSH
87953: LD_INT 1
87955: NEG
87956: PUSH
87957: LD_INT 2
87959: NEG
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: LD_INT 2
87970: NEG
87971: PUSH
87972: EMPTY
87973: LIST
87974: LIST
87975: PUSH
87976: LD_INT 1
87978: PUSH
87979: LD_INT 1
87981: NEG
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PUSH
87987: LD_INT 2
87989: PUSH
87990: LD_INT 0
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 2
87999: PUSH
88000: LD_INT 1
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: LD_INT 2
88009: PUSH
88010: LD_INT 2
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: LD_INT 1
88019: PUSH
88020: LD_INT 2
88022: PUSH
88023: EMPTY
88024: LIST
88025: LIST
88026: PUSH
88027: LD_INT 0
88029: PUSH
88030: LD_INT 2
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 1
88039: NEG
88040: PUSH
88041: LD_INT 1
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: PUSH
88048: LD_INT 2
88050: NEG
88051: PUSH
88052: LD_INT 0
88054: PUSH
88055: EMPTY
88056: LIST
88057: LIST
88058: PUSH
88059: LD_INT 2
88061: NEG
88062: PUSH
88063: LD_INT 1
88065: NEG
88066: PUSH
88067: EMPTY
88068: LIST
88069: LIST
88070: PUSH
88071: LD_INT 2
88073: NEG
88074: PUSH
88075: LD_INT 2
88077: NEG
88078: PUSH
88079: EMPTY
88080: LIST
88081: LIST
88082: PUSH
88083: EMPTY
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88104: LD_ADDR_VAR 0 57
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 0
88121: PUSH
88122: LD_INT 1
88124: NEG
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: PUSH
88133: LD_INT 0
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: LD_INT 1
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: NEG
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: LD_INT 1
88177: NEG
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 2
88189: NEG
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 0
88197: PUSH
88198: LD_INT 2
88200: NEG
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 1
88208: PUSH
88209: LD_INT 1
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 2
88219: PUSH
88220: LD_INT 0
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 2
88229: PUSH
88230: LD_INT 1
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 2
88239: PUSH
88240: LD_INT 2
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: PUSH
88250: LD_INT 2
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 0
88259: PUSH
88260: LD_INT 2
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 1
88269: NEG
88270: PUSH
88271: LD_INT 1
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 2
88280: NEG
88281: PUSH
88282: LD_INT 0
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PUSH
88289: LD_INT 2
88291: NEG
88292: PUSH
88293: LD_INT 1
88295: NEG
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 2
88303: NEG
88304: PUSH
88305: LD_INT 2
88307: NEG
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: EMPTY
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88334: LD_ADDR_VAR 0 58
88338: PUSH
88339: LD_INT 0
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: EMPTY
88346: LIST
88347: LIST
88348: PUSH
88349: LD_INT 0
88351: PUSH
88352: LD_INT 1
88354: NEG
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 1
88362: PUSH
88363: LD_INT 0
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 1
88372: PUSH
88373: LD_INT 1
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: PUSH
88380: LD_INT 0
88382: PUSH
88383: LD_INT 1
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: PUSH
88390: LD_INT 1
88392: NEG
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 1
88403: NEG
88404: PUSH
88405: LD_INT 1
88407: NEG
88408: PUSH
88409: EMPTY
88410: LIST
88411: LIST
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: LD_INT 2
88419: NEG
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 2
88430: NEG
88431: PUSH
88432: EMPTY
88433: LIST
88434: LIST
88435: PUSH
88436: LD_INT 1
88438: PUSH
88439: LD_INT 1
88441: NEG
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: PUSH
88447: LD_INT 2
88449: PUSH
88450: LD_INT 0
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: PUSH
88457: LD_INT 2
88459: PUSH
88460: LD_INT 1
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: LD_INT 2
88469: PUSH
88470: LD_INT 2
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 1
88479: PUSH
88480: LD_INT 2
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 0
88489: PUSH
88490: LD_INT 2
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 1
88499: NEG
88500: PUSH
88501: LD_INT 1
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 2
88510: NEG
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 2
88521: NEG
88522: PUSH
88523: LD_INT 1
88525: NEG
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 2
88533: NEG
88534: PUSH
88535: LD_INT 2
88537: NEG
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88564: LD_ADDR_VAR 0 59
88568: PUSH
88569: LD_INT 0
88571: PUSH
88572: LD_INT 0
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 0
88581: PUSH
88582: LD_INT 1
88584: NEG
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 1
88592: PUSH
88593: LD_INT 0
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: LD_INT 1
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 0
88612: PUSH
88613: LD_INT 1
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 1
88622: NEG
88623: PUSH
88624: LD_INT 0
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: LD_INT 1
88637: NEG
88638: PUSH
88639: EMPTY
88640: LIST
88641: LIST
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88652: LD_ADDR_VAR 0 60
88656: PUSH
88657: LD_INT 0
88659: PUSH
88660: LD_INT 0
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: LD_INT 1
88672: NEG
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 1
88680: PUSH
88681: LD_INT 0
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: PUSH
88688: LD_INT 1
88690: PUSH
88691: LD_INT 1
88693: PUSH
88694: EMPTY
88695: LIST
88696: LIST
88697: PUSH
88698: LD_INT 0
88700: PUSH
88701: LD_INT 1
88703: PUSH
88704: EMPTY
88705: LIST
88706: LIST
88707: PUSH
88708: LD_INT 1
88710: NEG
88711: PUSH
88712: LD_INT 0
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 1
88721: NEG
88722: PUSH
88723: LD_INT 1
88725: NEG
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: PUSH
88731: EMPTY
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88740: LD_ADDR_VAR 0 61
88744: PUSH
88745: LD_INT 0
88747: PUSH
88748: LD_INT 0
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: PUSH
88755: LD_INT 0
88757: PUSH
88758: LD_INT 1
88760: NEG
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: PUSH
88766: LD_INT 1
88768: PUSH
88769: LD_INT 0
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: LD_INT 1
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: LD_INT 1
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 1
88798: NEG
88799: PUSH
88800: LD_INT 0
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 1
88809: NEG
88810: PUSH
88811: LD_INT 1
88813: NEG
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: EMPTY
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88828: LD_ADDR_VAR 0 62
88832: PUSH
88833: LD_INT 0
88835: PUSH
88836: LD_INT 0
88838: PUSH
88839: EMPTY
88840: LIST
88841: LIST
88842: PUSH
88843: LD_INT 0
88845: PUSH
88846: LD_INT 1
88848: NEG
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 1
88856: PUSH
88857: LD_INT 0
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: PUSH
88864: LD_INT 1
88866: PUSH
88867: LD_INT 1
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: LD_INT 1
88879: PUSH
88880: EMPTY
88881: LIST
88882: LIST
88883: PUSH
88884: LD_INT 1
88886: NEG
88887: PUSH
88888: LD_INT 0
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 1
88897: NEG
88898: PUSH
88899: LD_INT 1
88901: NEG
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
88916: LD_ADDR_VAR 0 63
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: LD_INT 0
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 0
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: PUSH
88942: LD_INT 1
88944: PUSH
88945: LD_INT 0
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 1
88954: PUSH
88955: LD_INT 1
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 0
88964: PUSH
88965: LD_INT 1
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 1
88974: NEG
88975: PUSH
88976: LD_INT 0
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 1
88985: NEG
88986: PUSH
88987: LD_INT 1
88989: NEG
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: LIST
88999: LIST
89000: LIST
89001: LIST
89002: LIST
89003: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89004: LD_ADDR_VAR 0 64
89008: PUSH
89009: LD_INT 0
89011: PUSH
89012: LD_INT 0
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: LD_INT 1
89024: NEG
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 1
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: LD_INT 1
89045: PUSH
89046: EMPTY
89047: LIST
89048: LIST
89049: PUSH
89050: LD_INT 0
89052: PUSH
89053: LD_INT 1
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: PUSH
89071: LD_INT 1
89073: NEG
89074: PUSH
89075: LD_INT 1
89077: NEG
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: ST_TO_ADDR
// end ; 1 :
89092: GO 94989
89094: LD_INT 1
89096: DOUBLE
89097: EQUAL
89098: IFTRUE 89102
89100: GO 91725
89102: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89103: LD_ADDR_VAR 0 11
89107: PUSH
89108: LD_INT 1
89110: NEG
89111: PUSH
89112: LD_INT 3
89114: NEG
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 0
89122: PUSH
89123: LD_INT 3
89125: NEG
89126: PUSH
89127: EMPTY
89128: LIST
89129: LIST
89130: PUSH
89131: LD_INT 1
89133: PUSH
89134: LD_INT 2
89136: NEG
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: LIST
89146: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89147: LD_ADDR_VAR 0 12
89151: PUSH
89152: LD_INT 2
89154: PUSH
89155: LD_INT 1
89157: NEG
89158: PUSH
89159: EMPTY
89160: LIST
89161: LIST
89162: PUSH
89163: LD_INT 3
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: EMPTY
89170: LIST
89171: LIST
89172: PUSH
89173: LD_INT 3
89175: PUSH
89176: LD_INT 1
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: LIST
89187: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89188: LD_ADDR_VAR 0 13
89192: PUSH
89193: LD_INT 3
89195: PUSH
89196: LD_INT 2
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 3
89205: PUSH
89206: LD_INT 3
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 2
89215: PUSH
89216: LD_INT 3
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: LIST
89227: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89228: LD_ADDR_VAR 0 14
89232: PUSH
89233: LD_INT 1
89235: PUSH
89236: LD_INT 3
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 0
89245: PUSH
89246: LD_INT 3
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 1
89255: NEG
89256: PUSH
89257: LD_INT 2
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: LIST
89268: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89269: LD_ADDR_VAR 0 15
89273: PUSH
89274: LD_INT 2
89276: NEG
89277: PUSH
89278: LD_INT 1
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 3
89287: NEG
89288: PUSH
89289: LD_INT 0
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 3
89298: NEG
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: EMPTY
89309: LIST
89310: LIST
89311: LIST
89312: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89313: LD_ADDR_VAR 0 16
89317: PUSH
89318: LD_INT 2
89320: NEG
89321: PUSH
89322: LD_INT 3
89324: NEG
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PUSH
89330: LD_INT 3
89332: NEG
89333: PUSH
89334: LD_INT 2
89336: NEG
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 3
89344: NEG
89345: PUSH
89346: LD_INT 3
89348: NEG
89349: PUSH
89350: EMPTY
89351: LIST
89352: LIST
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: LIST
89358: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89359: LD_ADDR_VAR 0 17
89363: PUSH
89364: LD_INT 1
89366: NEG
89367: PUSH
89368: LD_INT 3
89370: NEG
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 0
89378: PUSH
89379: LD_INT 3
89381: NEG
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 1
89389: PUSH
89390: LD_INT 2
89392: NEG
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: LIST
89402: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89403: LD_ADDR_VAR 0 18
89407: PUSH
89408: LD_INT 2
89410: PUSH
89411: LD_INT 1
89413: NEG
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 3
89421: PUSH
89422: LD_INT 0
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 3
89431: PUSH
89432: LD_INT 1
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: LIST
89443: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89444: LD_ADDR_VAR 0 19
89448: PUSH
89449: LD_INT 3
89451: PUSH
89452: LD_INT 2
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 3
89461: PUSH
89462: LD_INT 3
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 2
89471: PUSH
89472: LD_INT 3
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: EMPTY
89480: LIST
89481: LIST
89482: LIST
89483: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89484: LD_ADDR_VAR 0 20
89488: PUSH
89489: LD_INT 1
89491: PUSH
89492: LD_INT 3
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 0
89501: PUSH
89502: LD_INT 3
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 1
89511: NEG
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: EMPTY
89521: LIST
89522: LIST
89523: LIST
89524: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89525: LD_ADDR_VAR 0 21
89529: PUSH
89530: LD_INT 2
89532: NEG
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 3
89543: NEG
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 3
89554: NEG
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: LIST
89568: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89569: LD_ADDR_VAR 0 22
89573: PUSH
89574: LD_INT 2
89576: NEG
89577: PUSH
89578: LD_INT 3
89580: NEG
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: LD_INT 3
89588: NEG
89589: PUSH
89590: LD_INT 2
89592: NEG
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 3
89600: NEG
89601: PUSH
89602: LD_INT 3
89604: NEG
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: LIST
89614: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
89615: LD_ADDR_VAR 0 23
89619: PUSH
89620: LD_INT 0
89622: PUSH
89623: LD_INT 3
89625: NEG
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 1
89633: NEG
89634: PUSH
89635: LD_INT 4
89637: NEG
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 1
89645: PUSH
89646: LD_INT 3
89648: NEG
89649: PUSH
89650: EMPTY
89651: LIST
89652: LIST
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: LIST
89658: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
89659: LD_ADDR_VAR 0 24
89663: PUSH
89664: LD_INT 3
89666: PUSH
89667: LD_INT 0
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 3
89676: PUSH
89677: LD_INT 1
89679: NEG
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: LD_INT 4
89687: PUSH
89688: LD_INT 1
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: LIST
89699: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
89700: LD_ADDR_VAR 0 25
89704: PUSH
89705: LD_INT 3
89707: PUSH
89708: LD_INT 3
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: LD_INT 4
89717: PUSH
89718: LD_INT 3
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: PUSH
89725: LD_INT 3
89727: PUSH
89728: LD_INT 4
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: LIST
89739: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
89740: LD_ADDR_VAR 0 26
89744: PUSH
89745: LD_INT 0
89747: PUSH
89748: LD_INT 3
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: LD_INT 4
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: LD_INT 3
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: LIST
89780: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
89781: LD_ADDR_VAR 0 27
89785: PUSH
89786: LD_INT 3
89788: NEG
89789: PUSH
89790: LD_INT 0
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 3
89799: NEG
89800: PUSH
89801: LD_INT 1
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 4
89810: NEG
89811: PUSH
89812: LD_INT 1
89814: NEG
89815: PUSH
89816: EMPTY
89817: LIST
89818: LIST
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: LIST
89824: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
89825: LD_ADDR_VAR 0 28
89829: PUSH
89830: LD_INT 3
89832: NEG
89833: PUSH
89834: LD_INT 3
89836: NEG
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 3
89844: NEG
89845: PUSH
89846: LD_INT 4
89848: NEG
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 4
89856: NEG
89857: PUSH
89858: LD_INT 3
89860: NEG
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: LIST
89870: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
89871: LD_ADDR_VAR 0 29
89875: PUSH
89876: LD_INT 1
89878: NEG
89879: PUSH
89880: LD_INT 3
89882: NEG
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 0
89890: PUSH
89891: LD_INT 3
89893: NEG
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: PUSH
89899: LD_INT 1
89901: PUSH
89902: LD_INT 2
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 1
89912: NEG
89913: PUSH
89914: LD_INT 4
89916: NEG
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 0
89924: PUSH
89925: LD_INT 4
89927: NEG
89928: PUSH
89929: EMPTY
89930: LIST
89931: LIST
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: LD_INT 3
89938: NEG
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: LD_INT 5
89950: NEG
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 0
89958: PUSH
89959: LD_INT 5
89961: NEG
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 1
89969: PUSH
89970: LD_INT 4
89972: NEG
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: LD_INT 1
89980: NEG
89981: PUSH
89982: LD_INT 6
89984: NEG
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: LD_INT 0
89992: PUSH
89993: LD_INT 6
89995: NEG
89996: PUSH
89997: EMPTY
89998: LIST
89999: LIST
90000: PUSH
90001: LD_INT 1
90003: PUSH
90004: LD_INT 5
90006: NEG
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90026: LD_ADDR_VAR 0 30
90030: PUSH
90031: LD_INT 2
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 3
90044: PUSH
90045: LD_INT 0
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 3
90054: PUSH
90055: LD_INT 1
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 3
90064: PUSH
90065: LD_INT 1
90067: NEG
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 4
90075: PUSH
90076: LD_INT 0
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 4
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 4
90095: PUSH
90096: LD_INT 1
90098: NEG
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 5
90106: PUSH
90107: LD_INT 0
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 5
90116: PUSH
90117: LD_INT 1
90119: PUSH
90120: EMPTY
90121: LIST
90122: LIST
90123: PUSH
90124: LD_INT 5
90126: PUSH
90127: LD_INT 1
90129: NEG
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: LD_INT 6
90137: PUSH
90138: LD_INT 0
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: PUSH
90145: LD_INT 6
90147: PUSH
90148: LD_INT 1
90150: PUSH
90151: EMPTY
90152: LIST
90153: LIST
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90169: LD_ADDR_VAR 0 31
90173: PUSH
90174: LD_INT 3
90176: PUSH
90177: LD_INT 2
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 3
90186: PUSH
90187: LD_INT 3
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: PUSH
90194: LD_INT 2
90196: PUSH
90197: LD_INT 3
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 4
90206: PUSH
90207: LD_INT 3
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 4
90216: PUSH
90217: LD_INT 4
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PUSH
90224: LD_INT 3
90226: PUSH
90227: LD_INT 4
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 5
90236: PUSH
90237: LD_INT 4
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 5
90246: PUSH
90247: LD_INT 5
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 4
90256: PUSH
90257: LD_INT 5
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 6
90266: PUSH
90267: LD_INT 5
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 6
90276: PUSH
90277: LD_INT 6
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 5
90286: PUSH
90287: LD_INT 6
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: EMPTY
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90308: LD_ADDR_VAR 0 32
90312: PUSH
90313: LD_INT 1
90315: PUSH
90316: LD_INT 3
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 0
90325: PUSH
90326: LD_INT 3
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 1
90335: NEG
90336: PUSH
90337: LD_INT 2
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: LD_INT 4
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 0
90356: PUSH
90357: LD_INT 4
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: PUSH
90364: LD_INT 1
90366: NEG
90367: PUSH
90368: LD_INT 3
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: LD_INT 1
90377: PUSH
90378: LD_INT 5
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 0
90387: PUSH
90388: LD_INT 5
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: PUSH
90395: LD_INT 1
90397: NEG
90398: PUSH
90399: LD_INT 4
90401: PUSH
90402: EMPTY
90403: LIST
90404: LIST
90405: PUSH
90406: LD_INT 1
90408: PUSH
90409: LD_INT 6
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: PUSH
90416: LD_INT 0
90418: PUSH
90419: LD_INT 6
90421: PUSH
90422: EMPTY
90423: LIST
90424: LIST
90425: PUSH
90426: LD_INT 1
90428: NEG
90429: PUSH
90430: LD_INT 5
90432: PUSH
90433: EMPTY
90434: LIST
90435: LIST
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
90451: LD_ADDR_VAR 0 33
90455: PUSH
90456: LD_INT 2
90458: NEG
90459: PUSH
90460: LD_INT 1
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: PUSH
90467: LD_INT 3
90469: NEG
90470: PUSH
90471: LD_INT 0
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: PUSH
90478: LD_INT 3
90480: NEG
90481: PUSH
90482: LD_INT 1
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 3
90492: NEG
90493: PUSH
90494: LD_INT 1
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 4
90503: NEG
90504: PUSH
90505: LD_INT 0
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 4
90514: NEG
90515: PUSH
90516: LD_INT 1
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 4
90526: NEG
90527: PUSH
90528: LD_INT 1
90530: PUSH
90531: EMPTY
90532: LIST
90533: LIST
90534: PUSH
90535: LD_INT 5
90537: NEG
90538: PUSH
90539: LD_INT 0
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 5
90548: NEG
90549: PUSH
90550: LD_INT 1
90552: NEG
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 5
90560: NEG
90561: PUSH
90562: LD_INT 1
90564: PUSH
90565: EMPTY
90566: LIST
90567: LIST
90568: PUSH
90569: LD_INT 6
90571: NEG
90572: PUSH
90573: LD_INT 0
90575: PUSH
90576: EMPTY
90577: LIST
90578: LIST
90579: PUSH
90580: LD_INT 6
90582: NEG
90583: PUSH
90584: LD_INT 1
90586: NEG
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
90606: LD_ADDR_VAR 0 34
90610: PUSH
90611: LD_INT 2
90613: NEG
90614: PUSH
90615: LD_INT 3
90617: NEG
90618: PUSH
90619: EMPTY
90620: LIST
90621: LIST
90622: PUSH
90623: LD_INT 3
90625: NEG
90626: PUSH
90627: LD_INT 2
90629: NEG
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PUSH
90635: LD_INT 3
90637: NEG
90638: PUSH
90639: LD_INT 3
90641: NEG
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: LD_INT 3
90649: NEG
90650: PUSH
90651: LD_INT 4
90653: NEG
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 4
90661: NEG
90662: PUSH
90663: LD_INT 3
90665: NEG
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 4
90673: NEG
90674: PUSH
90675: LD_INT 4
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 4
90685: NEG
90686: PUSH
90687: LD_INT 5
90689: NEG
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 5
90697: NEG
90698: PUSH
90699: LD_INT 4
90701: NEG
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: LD_INT 5
90709: NEG
90710: PUSH
90711: LD_INT 5
90713: NEG
90714: PUSH
90715: EMPTY
90716: LIST
90717: LIST
90718: PUSH
90719: LD_INT 5
90721: NEG
90722: PUSH
90723: LD_INT 6
90725: NEG
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 6
90733: NEG
90734: PUSH
90735: LD_INT 5
90737: NEG
90738: PUSH
90739: EMPTY
90740: LIST
90741: LIST
90742: PUSH
90743: LD_INT 6
90745: NEG
90746: PUSH
90747: LD_INT 6
90749: NEG
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
90769: LD_ADDR_VAR 0 41
90773: PUSH
90774: LD_INT 0
90776: PUSH
90777: LD_INT 2
90779: NEG
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 1
90787: NEG
90788: PUSH
90789: LD_INT 3
90791: NEG
90792: PUSH
90793: EMPTY
90794: LIST
90795: LIST
90796: PUSH
90797: LD_INT 1
90799: PUSH
90800: LD_INT 2
90802: NEG
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: LIST
90812: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
90813: LD_ADDR_VAR 0 42
90817: PUSH
90818: LD_INT 2
90820: PUSH
90821: LD_INT 0
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 2
90830: PUSH
90831: LD_INT 1
90833: NEG
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: LD_INT 3
90841: PUSH
90842: LD_INT 1
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: LIST
90853: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
90854: LD_ADDR_VAR 0 43
90858: PUSH
90859: LD_INT 2
90861: PUSH
90862: LD_INT 2
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 3
90871: PUSH
90872: LD_INT 2
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 2
90881: PUSH
90882: LD_INT 3
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: LIST
90893: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
90894: LD_ADDR_VAR 0 44
90898: PUSH
90899: LD_INT 0
90901: PUSH
90902: LD_INT 2
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: LD_INT 1
90911: PUSH
90912: LD_INT 3
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: LD_INT 2
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: LIST
90934: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90935: LD_ADDR_VAR 0 45
90939: PUSH
90940: LD_INT 2
90942: NEG
90943: PUSH
90944: LD_INT 0
90946: PUSH
90947: EMPTY
90948: LIST
90949: LIST
90950: PUSH
90951: LD_INT 2
90953: NEG
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 3
90964: NEG
90965: PUSH
90966: LD_INT 1
90968: NEG
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: LIST
90978: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
90979: LD_ADDR_VAR 0 46
90983: PUSH
90984: LD_INT 2
90986: NEG
90987: PUSH
90988: LD_INT 2
90990: NEG
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 2
90998: NEG
90999: PUSH
91000: LD_INT 3
91002: NEG
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 3
91010: NEG
91011: PUSH
91012: LD_INT 2
91014: NEG
91015: PUSH
91016: EMPTY
91017: LIST
91018: LIST
91019: PUSH
91020: EMPTY
91021: LIST
91022: LIST
91023: LIST
91024: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91025: LD_ADDR_VAR 0 47
91029: PUSH
91030: LD_INT 2
91032: NEG
91033: PUSH
91034: LD_INT 3
91036: NEG
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 1
91044: NEG
91045: PUSH
91046: LD_INT 3
91048: NEG
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91058: LD_ADDR_VAR 0 48
91062: PUSH
91063: LD_INT 1
91065: PUSH
91066: LD_INT 2
91068: NEG
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: PUSH
91074: LD_INT 2
91076: PUSH
91077: LD_INT 1
91079: NEG
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91089: LD_ADDR_VAR 0 49
91093: PUSH
91094: LD_INT 3
91096: PUSH
91097: LD_INT 1
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 3
91106: PUSH
91107: LD_INT 2
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: EMPTY
91115: LIST
91116: LIST
91117: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91118: LD_ADDR_VAR 0 50
91122: PUSH
91123: LD_INT 2
91125: PUSH
91126: LD_INT 3
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 1
91135: PUSH
91136: LD_INT 3
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91147: LD_ADDR_VAR 0 51
91151: PUSH
91152: LD_INT 1
91154: NEG
91155: PUSH
91156: LD_INT 2
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 2
91165: NEG
91166: PUSH
91167: LD_INT 1
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91178: LD_ADDR_VAR 0 52
91182: PUSH
91183: LD_INT 3
91185: NEG
91186: PUSH
91187: LD_INT 1
91189: NEG
91190: PUSH
91191: EMPTY
91192: LIST
91193: LIST
91194: PUSH
91195: LD_INT 3
91197: NEG
91198: PUSH
91199: LD_INT 2
91201: NEG
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91211: LD_ADDR_VAR 0 53
91215: PUSH
91216: LD_INT 1
91218: NEG
91219: PUSH
91220: LD_INT 3
91222: NEG
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 0
91230: PUSH
91231: LD_INT 3
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 1
91241: PUSH
91242: LD_INT 2
91244: NEG
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: LIST
91254: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91255: LD_ADDR_VAR 0 54
91259: PUSH
91260: LD_INT 2
91262: PUSH
91263: LD_INT 1
91265: NEG
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 3
91273: PUSH
91274: LD_INT 0
91276: PUSH
91277: EMPTY
91278: LIST
91279: LIST
91280: PUSH
91281: LD_INT 3
91283: PUSH
91284: LD_INT 1
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: LIST
91295: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91296: LD_ADDR_VAR 0 55
91300: PUSH
91301: LD_INT 3
91303: PUSH
91304: LD_INT 2
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 3
91313: PUSH
91314: LD_INT 3
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 2
91323: PUSH
91324: LD_INT 3
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: LIST
91335: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91336: LD_ADDR_VAR 0 56
91340: PUSH
91341: LD_INT 1
91343: PUSH
91344: LD_INT 3
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 0
91353: PUSH
91354: LD_INT 3
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 1
91363: NEG
91364: PUSH
91365: LD_INT 2
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: LIST
91376: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91377: LD_ADDR_VAR 0 57
91381: PUSH
91382: LD_INT 2
91384: NEG
91385: PUSH
91386: LD_INT 1
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 3
91395: NEG
91396: PUSH
91397: LD_INT 0
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: PUSH
91404: LD_INT 3
91406: NEG
91407: PUSH
91408: LD_INT 1
91410: NEG
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: LIST
91420: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91421: LD_ADDR_VAR 0 58
91425: PUSH
91426: LD_INT 2
91428: NEG
91429: PUSH
91430: LD_INT 3
91432: NEG
91433: PUSH
91434: EMPTY
91435: LIST
91436: LIST
91437: PUSH
91438: LD_INT 3
91440: NEG
91441: PUSH
91442: LD_INT 2
91444: NEG
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 3
91452: NEG
91453: PUSH
91454: LD_INT 3
91456: NEG
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: LIST
91466: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
91467: LD_ADDR_VAR 0 59
91471: PUSH
91472: LD_INT 1
91474: NEG
91475: PUSH
91476: LD_INT 2
91478: NEG
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: PUSH
91484: LD_INT 0
91486: PUSH
91487: LD_INT 2
91489: NEG
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 1
91497: PUSH
91498: LD_INT 1
91500: NEG
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: LIST
91510: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91511: LD_ADDR_VAR 0 60
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: LD_INT 1
91521: NEG
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: PUSH
91527: LD_INT 2
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: EMPTY
91534: LIST
91535: LIST
91536: PUSH
91537: LD_INT 2
91539: PUSH
91540: LD_INT 1
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: LIST
91551: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
91552: LD_ADDR_VAR 0 61
91556: PUSH
91557: LD_INT 2
91559: PUSH
91560: LD_INT 1
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: LD_INT 2
91569: PUSH
91570: LD_INT 2
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: LD_INT 1
91579: PUSH
91580: LD_INT 2
91582: PUSH
91583: EMPTY
91584: LIST
91585: LIST
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: LIST
91591: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
91592: LD_ADDR_VAR 0 62
91596: PUSH
91597: LD_INT 1
91599: PUSH
91600: LD_INT 2
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: PUSH
91607: LD_INT 0
91609: PUSH
91610: LD_INT 2
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: PUSH
91617: LD_INT 1
91619: NEG
91620: PUSH
91621: LD_INT 1
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: LIST
91632: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
91633: LD_ADDR_VAR 0 63
91637: PUSH
91638: LD_INT 1
91640: NEG
91641: PUSH
91642: LD_INT 1
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: PUSH
91649: LD_INT 2
91651: NEG
91652: PUSH
91653: LD_INT 0
91655: PUSH
91656: EMPTY
91657: LIST
91658: LIST
91659: PUSH
91660: LD_INT 2
91662: NEG
91663: PUSH
91664: LD_INT 1
91666: NEG
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: LIST
91676: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91677: LD_ADDR_VAR 0 64
91681: PUSH
91682: LD_INT 1
91684: NEG
91685: PUSH
91686: LD_INT 2
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 2
91696: NEG
91697: PUSH
91698: LD_INT 1
91700: NEG
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 2
91708: NEG
91709: PUSH
91710: LD_INT 2
91712: NEG
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: LIST
91722: ST_TO_ADDR
// end ; 2 :
91723: GO 94989
91725: LD_INT 2
91727: DOUBLE
91728: EQUAL
91729: IFTRUE 91733
91731: GO 94988
91733: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
91734: LD_ADDR_VAR 0 29
91738: PUSH
91739: LD_INT 4
91741: PUSH
91742: LD_INT 0
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PUSH
91749: LD_INT 4
91751: PUSH
91752: LD_INT 1
91754: NEG
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: PUSH
91760: LD_INT 5
91762: PUSH
91763: LD_INT 0
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: PUSH
91770: LD_INT 5
91772: PUSH
91773: LD_INT 1
91775: PUSH
91776: EMPTY
91777: LIST
91778: LIST
91779: PUSH
91780: LD_INT 4
91782: PUSH
91783: LD_INT 1
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: PUSH
91790: LD_INT 3
91792: PUSH
91793: LD_INT 0
91795: PUSH
91796: EMPTY
91797: LIST
91798: LIST
91799: PUSH
91800: LD_INT 3
91802: PUSH
91803: LD_INT 1
91805: NEG
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: LD_INT 3
91813: PUSH
91814: LD_INT 2
91816: NEG
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 5
91824: PUSH
91825: LD_INT 2
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 3
91834: PUSH
91835: LD_INT 3
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 3
91844: PUSH
91845: LD_INT 2
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 4
91854: PUSH
91855: LD_INT 3
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 4
91864: PUSH
91865: LD_INT 4
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 3
91874: PUSH
91875: LD_INT 4
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: LD_INT 2
91884: PUSH
91885: LD_INT 3
91887: PUSH
91888: EMPTY
91889: LIST
91890: LIST
91891: PUSH
91892: LD_INT 2
91894: PUSH
91895: LD_INT 2
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: LD_INT 4
91904: PUSH
91905: LD_INT 2
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: LD_INT 2
91914: PUSH
91915: LD_INT 4
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 0
91924: PUSH
91925: LD_INT 4
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 0
91934: PUSH
91935: LD_INT 3
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 1
91944: PUSH
91945: LD_INT 4
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 1
91954: PUSH
91955: LD_INT 5
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 0
91964: PUSH
91965: LD_INT 5
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 1
91974: NEG
91975: PUSH
91976: LD_INT 4
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 1
91985: NEG
91986: PUSH
91987: LD_INT 3
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 2
91996: PUSH
91997: LD_INT 5
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 2
92006: NEG
92007: PUSH
92008: LD_INT 3
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 3
92017: NEG
92018: PUSH
92019: LD_INT 0
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: LD_INT 3
92028: NEG
92029: PUSH
92030: LD_INT 1
92032: NEG
92033: PUSH
92034: EMPTY
92035: LIST
92036: LIST
92037: PUSH
92038: LD_INT 2
92040: NEG
92041: PUSH
92042: LD_INT 0
92044: PUSH
92045: EMPTY
92046: LIST
92047: LIST
92048: PUSH
92049: LD_INT 2
92051: NEG
92052: PUSH
92053: LD_INT 1
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PUSH
92060: LD_INT 3
92062: NEG
92063: PUSH
92064: LD_INT 1
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: PUSH
92071: LD_INT 4
92073: NEG
92074: PUSH
92075: LD_INT 0
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: PUSH
92082: LD_INT 4
92084: NEG
92085: PUSH
92086: LD_INT 1
92088: NEG
92089: PUSH
92090: EMPTY
92091: LIST
92092: LIST
92093: PUSH
92094: LD_INT 4
92096: NEG
92097: PUSH
92098: LD_INT 2
92100: NEG
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 2
92108: NEG
92109: PUSH
92110: LD_INT 2
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 4
92119: NEG
92120: PUSH
92121: LD_INT 4
92123: NEG
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 4
92131: NEG
92132: PUSH
92133: LD_INT 5
92135: NEG
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PUSH
92141: LD_INT 3
92143: NEG
92144: PUSH
92145: LD_INT 4
92147: NEG
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: LD_INT 3
92155: NEG
92156: PUSH
92157: LD_INT 3
92159: NEG
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 4
92167: NEG
92168: PUSH
92169: LD_INT 3
92171: NEG
92172: PUSH
92173: EMPTY
92174: LIST
92175: LIST
92176: PUSH
92177: LD_INT 5
92179: NEG
92180: PUSH
92181: LD_INT 4
92183: NEG
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: PUSH
92189: LD_INT 5
92191: NEG
92192: PUSH
92193: LD_INT 5
92195: NEG
92196: PUSH
92197: EMPTY
92198: LIST
92199: LIST
92200: PUSH
92201: LD_INT 3
92203: NEG
92204: PUSH
92205: LD_INT 5
92207: NEG
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 5
92215: NEG
92216: PUSH
92217: LD_INT 3
92219: NEG
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92272: LD_ADDR_VAR 0 30
92276: PUSH
92277: LD_INT 4
92279: PUSH
92280: LD_INT 4
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 4
92289: PUSH
92290: LD_INT 3
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: LD_INT 5
92299: PUSH
92300: LD_INT 4
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 5
92309: PUSH
92310: LD_INT 5
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 4
92319: PUSH
92320: LD_INT 5
92322: PUSH
92323: EMPTY
92324: LIST
92325: LIST
92326: PUSH
92327: LD_INT 3
92329: PUSH
92330: LD_INT 4
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 3
92339: PUSH
92340: LD_INT 3
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 5
92349: PUSH
92350: LD_INT 3
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 3
92359: PUSH
92360: LD_INT 5
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 0
92369: PUSH
92370: LD_INT 3
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 0
92379: PUSH
92380: LD_INT 2
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 1
92389: PUSH
92390: LD_INT 3
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 1
92399: PUSH
92400: LD_INT 4
92402: PUSH
92403: EMPTY
92404: LIST
92405: LIST
92406: PUSH
92407: LD_INT 0
92409: PUSH
92410: LD_INT 4
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: LD_INT 1
92419: NEG
92420: PUSH
92421: LD_INT 3
92423: PUSH
92424: EMPTY
92425: LIST
92426: LIST
92427: PUSH
92428: LD_INT 1
92430: NEG
92431: PUSH
92432: LD_INT 2
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: PUSH
92439: LD_INT 2
92441: PUSH
92442: LD_INT 4
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: LD_INT 2
92451: NEG
92452: PUSH
92453: LD_INT 2
92455: PUSH
92456: EMPTY
92457: LIST
92458: LIST
92459: PUSH
92460: LD_INT 4
92462: NEG
92463: PUSH
92464: LD_INT 0
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 4
92473: NEG
92474: PUSH
92475: LD_INT 1
92477: NEG
92478: PUSH
92479: EMPTY
92480: LIST
92481: LIST
92482: PUSH
92483: LD_INT 3
92485: NEG
92486: PUSH
92487: LD_INT 0
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 3
92496: NEG
92497: PUSH
92498: LD_INT 1
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 4
92507: NEG
92508: PUSH
92509: LD_INT 1
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 5
92518: NEG
92519: PUSH
92520: LD_INT 0
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 5
92529: NEG
92530: PUSH
92531: LD_INT 1
92533: NEG
92534: PUSH
92535: EMPTY
92536: LIST
92537: LIST
92538: PUSH
92539: LD_INT 5
92541: NEG
92542: PUSH
92543: LD_INT 2
92545: NEG
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 3
92553: NEG
92554: PUSH
92555: LD_INT 2
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 3
92564: NEG
92565: PUSH
92566: LD_INT 3
92568: NEG
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 3
92576: NEG
92577: PUSH
92578: LD_INT 4
92580: NEG
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 2
92588: NEG
92589: PUSH
92590: LD_INT 3
92592: NEG
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: PUSH
92598: LD_INT 2
92600: NEG
92601: PUSH
92602: LD_INT 2
92604: NEG
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: PUSH
92610: LD_INT 3
92612: NEG
92613: PUSH
92614: LD_INT 2
92616: NEG
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 4
92624: NEG
92625: PUSH
92626: LD_INT 3
92628: NEG
92629: PUSH
92630: EMPTY
92631: LIST
92632: LIST
92633: PUSH
92634: LD_INT 4
92636: NEG
92637: PUSH
92638: LD_INT 4
92640: NEG
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 2
92648: NEG
92649: PUSH
92650: LD_INT 4
92652: NEG
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: PUSH
92658: LD_INT 4
92660: NEG
92661: PUSH
92662: LD_INT 2
92664: NEG
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 0
92672: PUSH
92673: LD_INT 4
92675: NEG
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: PUSH
92681: LD_INT 0
92683: PUSH
92684: LD_INT 5
92686: NEG
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: PUSH
92692: LD_INT 1
92694: PUSH
92695: LD_INT 4
92697: NEG
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: PUSH
92703: LD_INT 1
92705: PUSH
92706: LD_INT 3
92708: NEG
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 0
92716: PUSH
92717: LD_INT 3
92719: NEG
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PUSH
92725: LD_INT 1
92727: NEG
92728: PUSH
92729: LD_INT 4
92731: NEG
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 1
92739: NEG
92740: PUSH
92741: LD_INT 5
92743: NEG
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 2
92751: PUSH
92752: LD_INT 3
92754: NEG
92755: PUSH
92756: EMPTY
92757: LIST
92758: LIST
92759: PUSH
92760: LD_INT 2
92762: NEG
92763: PUSH
92764: LD_INT 5
92766: NEG
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: LIST
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
92819: LD_ADDR_VAR 0 31
92823: PUSH
92824: LD_INT 0
92826: PUSH
92827: LD_INT 4
92829: PUSH
92830: EMPTY
92831: LIST
92832: LIST
92833: PUSH
92834: LD_INT 0
92836: PUSH
92837: LD_INT 3
92839: PUSH
92840: EMPTY
92841: LIST
92842: LIST
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: LD_INT 4
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 1
92856: PUSH
92857: LD_INT 5
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: PUSH
92864: LD_INT 0
92866: PUSH
92867: LD_INT 5
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: PUSH
92874: LD_INT 1
92876: NEG
92877: PUSH
92878: LD_INT 4
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 1
92887: NEG
92888: PUSH
92889: LD_INT 3
92891: PUSH
92892: EMPTY
92893: LIST
92894: LIST
92895: PUSH
92896: LD_INT 2
92898: PUSH
92899: LD_INT 5
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 2
92908: NEG
92909: PUSH
92910: LD_INT 3
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 3
92919: NEG
92920: PUSH
92921: LD_INT 0
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 3
92930: NEG
92931: PUSH
92932: LD_INT 1
92934: NEG
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 2
92942: NEG
92943: PUSH
92944: LD_INT 0
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 2
92953: NEG
92954: PUSH
92955: LD_INT 1
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 3
92964: NEG
92965: PUSH
92966: LD_INT 1
92968: PUSH
92969: EMPTY
92970: LIST
92971: LIST
92972: PUSH
92973: LD_INT 4
92975: NEG
92976: PUSH
92977: LD_INT 0
92979: PUSH
92980: EMPTY
92981: LIST
92982: LIST
92983: PUSH
92984: LD_INT 4
92986: NEG
92987: PUSH
92988: LD_INT 1
92990: NEG
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 4
92998: NEG
92999: PUSH
93000: LD_INT 2
93002: NEG
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 2
93010: NEG
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 4
93021: NEG
93022: PUSH
93023: LD_INT 4
93025: NEG
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 4
93033: NEG
93034: PUSH
93035: LD_INT 5
93037: NEG
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 3
93045: NEG
93046: PUSH
93047: LD_INT 4
93049: NEG
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 3
93057: NEG
93058: PUSH
93059: LD_INT 3
93061: NEG
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 4
93069: NEG
93070: PUSH
93071: LD_INT 3
93073: NEG
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: PUSH
93079: LD_INT 5
93081: NEG
93082: PUSH
93083: LD_INT 4
93085: NEG
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 5
93093: NEG
93094: PUSH
93095: LD_INT 5
93097: NEG
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 3
93105: NEG
93106: PUSH
93107: LD_INT 5
93109: NEG
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: LD_INT 5
93117: NEG
93118: PUSH
93119: LD_INT 3
93121: NEG
93122: PUSH
93123: EMPTY
93124: LIST
93125: LIST
93126: PUSH
93127: LD_INT 0
93129: PUSH
93130: LD_INT 3
93132: NEG
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: PUSH
93138: LD_INT 0
93140: PUSH
93141: LD_INT 4
93143: NEG
93144: PUSH
93145: EMPTY
93146: LIST
93147: LIST
93148: PUSH
93149: LD_INT 1
93151: PUSH
93152: LD_INT 3
93154: NEG
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 1
93162: PUSH
93163: LD_INT 2
93165: NEG
93166: PUSH
93167: EMPTY
93168: LIST
93169: LIST
93170: PUSH
93171: LD_INT 0
93173: PUSH
93174: LD_INT 2
93176: NEG
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 1
93184: NEG
93185: PUSH
93186: LD_INT 3
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 1
93196: NEG
93197: PUSH
93198: LD_INT 4
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 2
93208: PUSH
93209: LD_INT 2
93211: NEG
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 2
93219: NEG
93220: PUSH
93221: LD_INT 4
93223: NEG
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 4
93231: PUSH
93232: LD_INT 0
93234: PUSH
93235: EMPTY
93236: LIST
93237: LIST
93238: PUSH
93239: LD_INT 4
93241: PUSH
93242: LD_INT 1
93244: NEG
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 5
93252: PUSH
93253: LD_INT 0
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 5
93262: PUSH
93263: LD_INT 1
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 4
93272: PUSH
93273: LD_INT 1
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 3
93282: PUSH
93283: LD_INT 0
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 3
93292: PUSH
93293: LD_INT 1
93295: NEG
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 3
93303: PUSH
93304: LD_INT 2
93306: NEG
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 5
93314: PUSH
93315: LD_INT 2
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93369: LD_ADDR_VAR 0 32
93373: PUSH
93374: LD_INT 4
93376: NEG
93377: PUSH
93378: LD_INT 0
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 4
93387: NEG
93388: PUSH
93389: LD_INT 1
93391: NEG
93392: PUSH
93393: EMPTY
93394: LIST
93395: LIST
93396: PUSH
93397: LD_INT 3
93399: NEG
93400: PUSH
93401: LD_INT 0
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 3
93410: NEG
93411: PUSH
93412: LD_INT 1
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: PUSH
93419: LD_INT 4
93421: NEG
93422: PUSH
93423: LD_INT 1
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 5
93432: NEG
93433: PUSH
93434: LD_INT 0
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 5
93443: NEG
93444: PUSH
93445: LD_INT 1
93447: NEG
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 5
93455: NEG
93456: PUSH
93457: LD_INT 2
93459: NEG
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 3
93467: NEG
93468: PUSH
93469: LD_INT 2
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 3
93478: NEG
93479: PUSH
93480: LD_INT 3
93482: NEG
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 3
93490: NEG
93491: PUSH
93492: LD_INT 4
93494: NEG
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 2
93502: NEG
93503: PUSH
93504: LD_INT 3
93506: NEG
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 2
93514: NEG
93515: PUSH
93516: LD_INT 2
93518: NEG
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: LD_INT 3
93526: NEG
93527: PUSH
93528: LD_INT 2
93530: NEG
93531: PUSH
93532: EMPTY
93533: LIST
93534: LIST
93535: PUSH
93536: LD_INT 4
93538: NEG
93539: PUSH
93540: LD_INT 3
93542: NEG
93543: PUSH
93544: EMPTY
93545: LIST
93546: LIST
93547: PUSH
93548: LD_INT 4
93550: NEG
93551: PUSH
93552: LD_INT 4
93554: NEG
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 2
93562: NEG
93563: PUSH
93564: LD_INT 4
93566: NEG
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: LD_INT 4
93574: NEG
93575: PUSH
93576: LD_INT 2
93578: NEG
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: LD_INT 0
93586: PUSH
93587: LD_INT 4
93589: NEG
93590: PUSH
93591: EMPTY
93592: LIST
93593: LIST
93594: PUSH
93595: LD_INT 0
93597: PUSH
93598: LD_INT 5
93600: NEG
93601: PUSH
93602: EMPTY
93603: LIST
93604: LIST
93605: PUSH
93606: LD_INT 1
93608: PUSH
93609: LD_INT 4
93611: NEG
93612: PUSH
93613: EMPTY
93614: LIST
93615: LIST
93616: PUSH
93617: LD_INT 1
93619: PUSH
93620: LD_INT 3
93622: NEG
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PUSH
93628: LD_INT 0
93630: PUSH
93631: LD_INT 3
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 1
93641: NEG
93642: PUSH
93643: LD_INT 4
93645: NEG
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 1
93653: NEG
93654: PUSH
93655: LD_INT 5
93657: NEG
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 2
93665: PUSH
93666: LD_INT 3
93668: NEG
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 2
93676: NEG
93677: PUSH
93678: LD_INT 5
93680: NEG
93681: PUSH
93682: EMPTY
93683: LIST
93684: LIST
93685: PUSH
93686: LD_INT 3
93688: PUSH
93689: LD_INT 0
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PUSH
93696: LD_INT 3
93698: PUSH
93699: LD_INT 1
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 4
93709: PUSH
93710: LD_INT 0
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 4
93719: PUSH
93720: LD_INT 1
93722: PUSH
93723: EMPTY
93724: LIST
93725: LIST
93726: PUSH
93727: LD_INT 3
93729: PUSH
93730: LD_INT 1
93732: PUSH
93733: EMPTY
93734: LIST
93735: LIST
93736: PUSH
93737: LD_INT 2
93739: PUSH
93740: LD_INT 0
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 2
93749: PUSH
93750: LD_INT 1
93752: NEG
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 2
93760: PUSH
93761: LD_INT 2
93763: NEG
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 4
93771: PUSH
93772: LD_INT 2
93774: PUSH
93775: EMPTY
93776: LIST
93777: LIST
93778: PUSH
93779: LD_INT 4
93781: PUSH
93782: LD_INT 4
93784: PUSH
93785: EMPTY
93786: LIST
93787: LIST
93788: PUSH
93789: LD_INT 4
93791: PUSH
93792: LD_INT 3
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: PUSH
93799: LD_INT 5
93801: PUSH
93802: LD_INT 4
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 5
93811: PUSH
93812: LD_INT 5
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 4
93821: PUSH
93822: LD_INT 5
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 3
93831: PUSH
93832: LD_INT 4
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 3
93841: PUSH
93842: LD_INT 3
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 5
93851: PUSH
93852: LD_INT 3
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: PUSH
93859: LD_INT 3
93861: PUSH
93862: LD_INT 5
93864: PUSH
93865: EMPTY
93866: LIST
93867: LIST
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
93916: LD_ADDR_VAR 0 33
93920: PUSH
93921: LD_INT 4
93923: NEG
93924: PUSH
93925: LD_INT 4
93927: NEG
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 4
93935: NEG
93936: PUSH
93937: LD_INT 5
93939: NEG
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PUSH
93945: LD_INT 3
93947: NEG
93948: PUSH
93949: LD_INT 4
93951: NEG
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 3
93959: NEG
93960: PUSH
93961: LD_INT 3
93963: NEG
93964: PUSH
93965: EMPTY
93966: LIST
93967: LIST
93968: PUSH
93969: LD_INT 4
93971: NEG
93972: PUSH
93973: LD_INT 3
93975: NEG
93976: PUSH
93977: EMPTY
93978: LIST
93979: LIST
93980: PUSH
93981: LD_INT 5
93983: NEG
93984: PUSH
93985: LD_INT 4
93987: NEG
93988: PUSH
93989: EMPTY
93990: LIST
93991: LIST
93992: PUSH
93993: LD_INT 5
93995: NEG
93996: PUSH
93997: LD_INT 5
93999: NEG
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: PUSH
94005: LD_INT 3
94007: NEG
94008: PUSH
94009: LD_INT 5
94011: NEG
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 5
94019: NEG
94020: PUSH
94021: LD_INT 3
94023: NEG
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 0
94031: PUSH
94032: LD_INT 3
94034: NEG
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 0
94042: PUSH
94043: LD_INT 4
94045: NEG
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 1
94053: PUSH
94054: LD_INT 3
94056: NEG
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: PUSH
94062: LD_INT 1
94064: PUSH
94065: LD_INT 2
94067: NEG
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 0
94075: PUSH
94076: LD_INT 2
94078: NEG
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 1
94086: NEG
94087: PUSH
94088: LD_INT 3
94090: NEG
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 1
94098: NEG
94099: PUSH
94100: LD_INT 4
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 2
94110: PUSH
94111: LD_INT 2
94113: NEG
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 2
94121: NEG
94122: PUSH
94123: LD_INT 4
94125: NEG
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 4
94133: PUSH
94134: LD_INT 0
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: PUSH
94141: LD_INT 4
94143: PUSH
94144: LD_INT 1
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 5
94154: PUSH
94155: LD_INT 0
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 5
94164: PUSH
94165: LD_INT 1
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 4
94174: PUSH
94175: LD_INT 1
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 3
94184: PUSH
94185: LD_INT 0
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 3
94194: PUSH
94195: LD_INT 1
94197: NEG
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 3
94205: PUSH
94206: LD_INT 2
94208: NEG
94209: PUSH
94210: EMPTY
94211: LIST
94212: LIST
94213: PUSH
94214: LD_INT 5
94216: PUSH
94217: LD_INT 2
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 3
94226: PUSH
94227: LD_INT 3
94229: PUSH
94230: EMPTY
94231: LIST
94232: LIST
94233: PUSH
94234: LD_INT 3
94236: PUSH
94237: LD_INT 2
94239: PUSH
94240: EMPTY
94241: LIST
94242: LIST
94243: PUSH
94244: LD_INT 4
94246: PUSH
94247: LD_INT 3
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 4
94256: PUSH
94257: LD_INT 4
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_INT 3
94266: PUSH
94267: LD_INT 4
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: PUSH
94274: LD_INT 2
94276: PUSH
94277: LD_INT 3
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PUSH
94284: LD_INT 2
94286: PUSH
94287: LD_INT 2
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 4
94296: PUSH
94297: LD_INT 2
94299: PUSH
94300: EMPTY
94301: LIST
94302: LIST
94303: PUSH
94304: LD_INT 2
94306: PUSH
94307: LD_INT 4
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 0
94316: PUSH
94317: LD_INT 4
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: PUSH
94324: LD_INT 0
94326: PUSH
94327: LD_INT 3
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: PUSH
94334: LD_INT 1
94336: PUSH
94337: LD_INT 4
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 1
94346: PUSH
94347: LD_INT 5
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 0
94356: PUSH
94357: LD_INT 5
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 1
94366: NEG
94367: PUSH
94368: LD_INT 4
94370: PUSH
94371: EMPTY
94372: LIST
94373: LIST
94374: PUSH
94375: LD_INT 1
94377: NEG
94378: PUSH
94379: LD_INT 3
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: LD_INT 2
94388: PUSH
94389: LD_INT 5
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 2
94398: NEG
94399: PUSH
94400: LD_INT 3
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: LIST
94452: LIST
94453: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
94454: LD_ADDR_VAR 0 34
94458: PUSH
94459: LD_INT 0
94461: PUSH
94462: LD_INT 4
94464: NEG
94465: PUSH
94466: EMPTY
94467: LIST
94468: LIST
94469: PUSH
94470: LD_INT 0
94472: PUSH
94473: LD_INT 5
94475: NEG
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 1
94483: PUSH
94484: LD_INT 4
94486: NEG
94487: PUSH
94488: EMPTY
94489: LIST
94490: LIST
94491: PUSH
94492: LD_INT 1
94494: PUSH
94495: LD_INT 3
94497: NEG
94498: PUSH
94499: EMPTY
94500: LIST
94501: LIST
94502: PUSH
94503: LD_INT 0
94505: PUSH
94506: LD_INT 3
94508: NEG
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: LD_INT 1
94516: NEG
94517: PUSH
94518: LD_INT 4
94520: NEG
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 1
94528: NEG
94529: PUSH
94530: LD_INT 5
94532: NEG
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 2
94540: PUSH
94541: LD_INT 3
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 2
94551: NEG
94552: PUSH
94553: LD_INT 5
94555: NEG
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 3
94563: PUSH
94564: LD_INT 0
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 3
94573: PUSH
94574: LD_INT 1
94576: NEG
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 4
94584: PUSH
94585: LD_INT 0
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 4
94594: PUSH
94595: LD_INT 1
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: LD_INT 3
94604: PUSH
94605: LD_INT 1
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 2
94614: PUSH
94615: LD_INT 0
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: PUSH
94622: LD_INT 2
94624: PUSH
94625: LD_INT 1
94627: NEG
94628: PUSH
94629: EMPTY
94630: LIST
94631: LIST
94632: PUSH
94633: LD_INT 2
94635: PUSH
94636: LD_INT 2
94638: NEG
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 4
94646: PUSH
94647: LD_INT 2
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 4
94656: PUSH
94657: LD_INT 4
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 4
94666: PUSH
94667: LD_INT 3
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: LD_INT 5
94676: PUSH
94677: LD_INT 4
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 5
94686: PUSH
94687: LD_INT 5
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 4
94696: PUSH
94697: LD_INT 5
94699: PUSH
94700: EMPTY
94701: LIST
94702: LIST
94703: PUSH
94704: LD_INT 3
94706: PUSH
94707: LD_INT 4
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: PUSH
94714: LD_INT 3
94716: PUSH
94717: LD_INT 3
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: PUSH
94724: LD_INT 5
94726: PUSH
94727: LD_INT 3
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 3
94736: PUSH
94737: LD_INT 5
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 0
94746: PUSH
94747: LD_INT 3
94749: PUSH
94750: EMPTY
94751: LIST
94752: LIST
94753: PUSH
94754: LD_INT 0
94756: PUSH
94757: LD_INT 2
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 1
94766: PUSH
94767: LD_INT 3
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 1
94776: PUSH
94777: LD_INT 4
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: PUSH
94784: LD_INT 0
94786: PUSH
94787: LD_INT 4
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 1
94796: NEG
94797: PUSH
94798: LD_INT 3
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: PUSH
94805: LD_INT 1
94807: NEG
94808: PUSH
94809: LD_INT 2
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 2
94818: PUSH
94819: LD_INT 4
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 2
94828: NEG
94829: PUSH
94830: LD_INT 2
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: PUSH
94837: LD_INT 4
94839: NEG
94840: PUSH
94841: LD_INT 0
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 4
94850: NEG
94851: PUSH
94852: LD_INT 1
94854: NEG
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 3
94862: NEG
94863: PUSH
94864: LD_INT 0
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PUSH
94871: LD_INT 3
94873: NEG
94874: PUSH
94875: LD_INT 1
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 4
94884: NEG
94885: PUSH
94886: LD_INT 1
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 5
94895: NEG
94896: PUSH
94897: LD_INT 0
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 5
94906: NEG
94907: PUSH
94908: LD_INT 1
94910: NEG
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 5
94918: NEG
94919: PUSH
94920: LD_INT 2
94922: NEG
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 3
94930: NEG
94931: PUSH
94932: LD_INT 2
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: ST_TO_ADDR
// end ; end ;
94986: GO 94989
94988: POP
// case btype of b_depot , b_warehouse :
94989: LD_VAR 0 1
94993: PUSH
94994: LD_INT 0
94996: DOUBLE
94997: EQUAL
94998: IFTRUE 95008
95000: LD_INT 1
95002: DOUBLE
95003: EQUAL
95004: IFTRUE 95008
95006: GO 95209
95008: POP
// case nation of nation_american :
95009: LD_VAR 0 5
95013: PUSH
95014: LD_INT 1
95016: DOUBLE
95017: EQUAL
95018: IFTRUE 95022
95020: GO 95078
95022: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
95023: LD_ADDR_VAR 0 9
95027: PUSH
95028: LD_VAR 0 11
95032: PUSH
95033: LD_VAR 0 12
95037: PUSH
95038: LD_VAR 0 13
95042: PUSH
95043: LD_VAR 0 14
95047: PUSH
95048: LD_VAR 0 15
95052: PUSH
95053: LD_VAR 0 16
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: PUSH
95066: LD_VAR 0 4
95070: PUSH
95071: LD_INT 1
95073: PLUS
95074: ARRAY
95075: ST_TO_ADDR
95076: GO 95207
95078: LD_INT 2
95080: DOUBLE
95081: EQUAL
95082: IFTRUE 95086
95084: GO 95142
95086: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
95087: LD_ADDR_VAR 0 9
95091: PUSH
95092: LD_VAR 0 17
95096: PUSH
95097: LD_VAR 0 18
95101: PUSH
95102: LD_VAR 0 19
95106: PUSH
95107: LD_VAR 0 20
95111: PUSH
95112: LD_VAR 0 21
95116: PUSH
95117: LD_VAR 0 22
95121: PUSH
95122: EMPTY
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: PUSH
95130: LD_VAR 0 4
95134: PUSH
95135: LD_INT 1
95137: PLUS
95138: ARRAY
95139: ST_TO_ADDR
95140: GO 95207
95142: LD_INT 3
95144: DOUBLE
95145: EQUAL
95146: IFTRUE 95150
95148: GO 95206
95150: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95151: LD_ADDR_VAR 0 9
95155: PUSH
95156: LD_VAR 0 23
95160: PUSH
95161: LD_VAR 0 24
95165: PUSH
95166: LD_VAR 0 25
95170: PUSH
95171: LD_VAR 0 26
95175: PUSH
95176: LD_VAR 0 27
95180: PUSH
95181: LD_VAR 0 28
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: PUSH
95194: LD_VAR 0 4
95198: PUSH
95199: LD_INT 1
95201: PLUS
95202: ARRAY
95203: ST_TO_ADDR
95204: GO 95207
95206: POP
95207: GO 95762
95209: LD_INT 2
95211: DOUBLE
95212: EQUAL
95213: IFTRUE 95223
95215: LD_INT 3
95217: DOUBLE
95218: EQUAL
95219: IFTRUE 95223
95221: GO 95279
95223: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95224: LD_ADDR_VAR 0 9
95228: PUSH
95229: LD_VAR 0 29
95233: PUSH
95234: LD_VAR 0 30
95238: PUSH
95239: LD_VAR 0 31
95243: PUSH
95244: LD_VAR 0 32
95248: PUSH
95249: LD_VAR 0 33
95253: PUSH
95254: LD_VAR 0 34
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: PUSH
95267: LD_VAR 0 4
95271: PUSH
95272: LD_INT 1
95274: PLUS
95275: ARRAY
95276: ST_TO_ADDR
95277: GO 95762
95279: LD_INT 16
95281: DOUBLE
95282: EQUAL
95283: IFTRUE 95341
95285: LD_INT 17
95287: DOUBLE
95288: EQUAL
95289: IFTRUE 95341
95291: LD_INT 18
95293: DOUBLE
95294: EQUAL
95295: IFTRUE 95341
95297: LD_INT 19
95299: DOUBLE
95300: EQUAL
95301: IFTRUE 95341
95303: LD_INT 22
95305: DOUBLE
95306: EQUAL
95307: IFTRUE 95341
95309: LD_INT 20
95311: DOUBLE
95312: EQUAL
95313: IFTRUE 95341
95315: LD_INT 21
95317: DOUBLE
95318: EQUAL
95319: IFTRUE 95341
95321: LD_INT 23
95323: DOUBLE
95324: EQUAL
95325: IFTRUE 95341
95327: LD_INT 24
95329: DOUBLE
95330: EQUAL
95331: IFTRUE 95341
95333: LD_INT 25
95335: DOUBLE
95336: EQUAL
95337: IFTRUE 95341
95339: GO 95397
95341: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95342: LD_ADDR_VAR 0 9
95346: PUSH
95347: LD_VAR 0 35
95351: PUSH
95352: LD_VAR 0 36
95356: PUSH
95357: LD_VAR 0 37
95361: PUSH
95362: LD_VAR 0 38
95366: PUSH
95367: LD_VAR 0 39
95371: PUSH
95372: LD_VAR 0 40
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: PUSH
95385: LD_VAR 0 4
95389: PUSH
95390: LD_INT 1
95392: PLUS
95393: ARRAY
95394: ST_TO_ADDR
95395: GO 95762
95397: LD_INT 6
95399: DOUBLE
95400: EQUAL
95401: IFTRUE 95453
95403: LD_INT 7
95405: DOUBLE
95406: EQUAL
95407: IFTRUE 95453
95409: LD_INT 8
95411: DOUBLE
95412: EQUAL
95413: IFTRUE 95453
95415: LD_INT 13
95417: DOUBLE
95418: EQUAL
95419: IFTRUE 95453
95421: LD_INT 12
95423: DOUBLE
95424: EQUAL
95425: IFTRUE 95453
95427: LD_INT 15
95429: DOUBLE
95430: EQUAL
95431: IFTRUE 95453
95433: LD_INT 11
95435: DOUBLE
95436: EQUAL
95437: IFTRUE 95453
95439: LD_INT 14
95441: DOUBLE
95442: EQUAL
95443: IFTRUE 95453
95445: LD_INT 10
95447: DOUBLE
95448: EQUAL
95449: IFTRUE 95453
95451: GO 95509
95453: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
95454: LD_ADDR_VAR 0 9
95458: PUSH
95459: LD_VAR 0 41
95463: PUSH
95464: LD_VAR 0 42
95468: PUSH
95469: LD_VAR 0 43
95473: PUSH
95474: LD_VAR 0 44
95478: PUSH
95479: LD_VAR 0 45
95483: PUSH
95484: LD_VAR 0 46
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: PUSH
95497: LD_VAR 0 4
95501: PUSH
95502: LD_INT 1
95504: PLUS
95505: ARRAY
95506: ST_TO_ADDR
95507: GO 95762
95509: LD_INT 36
95511: DOUBLE
95512: EQUAL
95513: IFTRUE 95517
95515: GO 95573
95517: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
95518: LD_ADDR_VAR 0 9
95522: PUSH
95523: LD_VAR 0 47
95527: PUSH
95528: LD_VAR 0 48
95532: PUSH
95533: LD_VAR 0 49
95537: PUSH
95538: LD_VAR 0 50
95542: PUSH
95543: LD_VAR 0 51
95547: PUSH
95548: LD_VAR 0 52
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: PUSH
95561: LD_VAR 0 4
95565: PUSH
95566: LD_INT 1
95568: PLUS
95569: ARRAY
95570: ST_TO_ADDR
95571: GO 95762
95573: LD_INT 4
95575: DOUBLE
95576: EQUAL
95577: IFTRUE 95599
95579: LD_INT 5
95581: DOUBLE
95582: EQUAL
95583: IFTRUE 95599
95585: LD_INT 34
95587: DOUBLE
95588: EQUAL
95589: IFTRUE 95599
95591: LD_INT 37
95593: DOUBLE
95594: EQUAL
95595: IFTRUE 95599
95597: GO 95655
95599: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
95600: LD_ADDR_VAR 0 9
95604: PUSH
95605: LD_VAR 0 53
95609: PUSH
95610: LD_VAR 0 54
95614: PUSH
95615: LD_VAR 0 55
95619: PUSH
95620: LD_VAR 0 56
95624: PUSH
95625: LD_VAR 0 57
95629: PUSH
95630: LD_VAR 0 58
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: PUSH
95643: LD_VAR 0 4
95647: PUSH
95648: LD_INT 1
95650: PLUS
95651: ARRAY
95652: ST_TO_ADDR
95653: GO 95762
95655: LD_INT 31
95657: DOUBLE
95658: EQUAL
95659: IFTRUE 95705
95661: LD_INT 32
95663: DOUBLE
95664: EQUAL
95665: IFTRUE 95705
95667: LD_INT 33
95669: DOUBLE
95670: EQUAL
95671: IFTRUE 95705
95673: LD_INT 27
95675: DOUBLE
95676: EQUAL
95677: IFTRUE 95705
95679: LD_INT 26
95681: DOUBLE
95682: EQUAL
95683: IFTRUE 95705
95685: LD_INT 28
95687: DOUBLE
95688: EQUAL
95689: IFTRUE 95705
95691: LD_INT 29
95693: DOUBLE
95694: EQUAL
95695: IFTRUE 95705
95697: LD_INT 30
95699: DOUBLE
95700: EQUAL
95701: IFTRUE 95705
95703: GO 95761
95705: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
95706: LD_ADDR_VAR 0 9
95710: PUSH
95711: LD_VAR 0 59
95715: PUSH
95716: LD_VAR 0 60
95720: PUSH
95721: LD_VAR 0 61
95725: PUSH
95726: LD_VAR 0 62
95730: PUSH
95731: LD_VAR 0 63
95735: PUSH
95736: LD_VAR 0 64
95740: PUSH
95741: EMPTY
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: PUSH
95749: LD_VAR 0 4
95753: PUSH
95754: LD_INT 1
95756: PLUS
95757: ARRAY
95758: ST_TO_ADDR
95759: GO 95762
95761: POP
// temp_list2 = [ ] ;
95762: LD_ADDR_VAR 0 10
95766: PUSH
95767: EMPTY
95768: ST_TO_ADDR
// for i in temp_list do
95769: LD_ADDR_VAR 0 8
95773: PUSH
95774: LD_VAR 0 9
95778: PUSH
95779: FOR_IN
95780: IFFALSE 95832
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
95782: LD_ADDR_VAR 0 10
95786: PUSH
95787: LD_VAR 0 10
95791: PUSH
95792: LD_VAR 0 8
95796: PUSH
95797: LD_INT 1
95799: ARRAY
95800: PUSH
95801: LD_VAR 0 2
95805: PLUS
95806: PUSH
95807: LD_VAR 0 8
95811: PUSH
95812: LD_INT 2
95814: ARRAY
95815: PUSH
95816: LD_VAR 0 3
95820: PLUS
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: EMPTY
95827: LIST
95828: ADD
95829: ST_TO_ADDR
95830: GO 95779
95832: POP
95833: POP
// result = temp_list2 ;
95834: LD_ADDR_VAR 0 7
95838: PUSH
95839: LD_VAR 0 10
95843: ST_TO_ADDR
// end ;
95844: LD_VAR 0 7
95848: RET
// export function EnemyInRange ( unit , dist ) ; begin
95849: LD_INT 0
95851: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
95852: LD_ADDR_VAR 0 3
95856: PUSH
95857: LD_VAR 0 1
95861: PPUSH
95862: CALL_OW 255
95866: PPUSH
95867: LD_VAR 0 1
95871: PPUSH
95872: CALL_OW 250
95876: PPUSH
95877: LD_VAR 0 1
95881: PPUSH
95882: CALL_OW 251
95886: PPUSH
95887: LD_VAR 0 2
95891: PPUSH
95892: CALL 69251 0 4
95896: PUSH
95897: LD_INT 4
95899: ARRAY
95900: ST_TO_ADDR
// end ;
95901: LD_VAR 0 3
95905: RET
// export function PlayerSeeMe ( unit ) ; begin
95906: LD_INT 0
95908: PPUSH
// result := See ( your_side , unit ) ;
95909: LD_ADDR_VAR 0 2
95913: PUSH
95914: LD_OWVAR 2
95918: PPUSH
95919: LD_VAR 0 1
95923: PPUSH
95924: CALL_OW 292
95928: ST_TO_ADDR
// end ;
95929: LD_VAR 0 2
95933: RET
// export function ReverseDir ( unit ) ; begin
95934: LD_INT 0
95936: PPUSH
// if not unit then
95937: LD_VAR 0 1
95941: NOT
95942: IFFALSE 95946
// exit ;
95944: GO 95969
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
95946: LD_ADDR_VAR 0 2
95950: PUSH
95951: LD_VAR 0 1
95955: PPUSH
95956: CALL_OW 254
95960: PUSH
95961: LD_INT 3
95963: PLUS
95964: PUSH
95965: LD_INT 6
95967: MOD
95968: ST_TO_ADDR
// end ;
95969: LD_VAR 0 2
95973: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
95974: LD_INT 0
95976: PPUSH
95977: PPUSH
95978: PPUSH
95979: PPUSH
95980: PPUSH
95981: PPUSH
// if not unit or not hexes then
95982: LD_VAR 0 1
95986: NOT
95987: PUSH
95988: LD_VAR 0 2
95992: NOT
95993: OR
95994: IFFALSE 95998
// exit ;
95996: GO 96121
// dist := 9999 ;
95998: LD_ADDR_VAR 0 5
96002: PUSH
96003: LD_INT 9999
96005: ST_TO_ADDR
// for i = 1 to hexes do
96006: LD_ADDR_VAR 0 4
96010: PUSH
96011: DOUBLE
96012: LD_INT 1
96014: DEC
96015: ST_TO_ADDR
96016: LD_VAR 0 2
96020: PUSH
96021: FOR_TO
96022: IFFALSE 96109
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96024: LD_ADDR_VAR 0 6
96028: PUSH
96029: LD_VAR 0 1
96033: PPUSH
96034: LD_VAR 0 2
96038: PUSH
96039: LD_VAR 0 4
96043: ARRAY
96044: PUSH
96045: LD_INT 1
96047: ARRAY
96048: PPUSH
96049: LD_VAR 0 2
96053: PUSH
96054: LD_VAR 0 4
96058: ARRAY
96059: PUSH
96060: LD_INT 2
96062: ARRAY
96063: PPUSH
96064: CALL_OW 297
96068: ST_TO_ADDR
// if tdist < dist then
96069: LD_VAR 0 6
96073: PUSH
96074: LD_VAR 0 5
96078: LESS
96079: IFFALSE 96107
// begin hex := hexes [ i ] ;
96081: LD_ADDR_VAR 0 8
96085: PUSH
96086: LD_VAR 0 2
96090: PUSH
96091: LD_VAR 0 4
96095: ARRAY
96096: ST_TO_ADDR
// dist := tdist ;
96097: LD_ADDR_VAR 0 5
96101: PUSH
96102: LD_VAR 0 6
96106: ST_TO_ADDR
// end ; end ;
96107: GO 96021
96109: POP
96110: POP
// result := hex ;
96111: LD_ADDR_VAR 0 3
96115: PUSH
96116: LD_VAR 0 8
96120: ST_TO_ADDR
// end ;
96121: LD_VAR 0 3
96125: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96126: LD_INT 0
96128: PPUSH
96129: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96130: LD_VAR 0 1
96134: NOT
96135: PUSH
96136: LD_VAR 0 1
96140: PUSH
96141: LD_INT 21
96143: PUSH
96144: LD_INT 2
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: LD_INT 23
96153: PUSH
96154: LD_INT 2
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PPUSH
96165: CALL_OW 69
96169: IN
96170: NOT
96171: OR
96172: IFFALSE 96176
// exit ;
96174: GO 96223
// for i = 1 to 3 do
96176: LD_ADDR_VAR 0 3
96180: PUSH
96181: DOUBLE
96182: LD_INT 1
96184: DEC
96185: ST_TO_ADDR
96186: LD_INT 3
96188: PUSH
96189: FOR_TO
96190: IFFALSE 96221
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96192: LD_VAR 0 1
96196: PPUSH
96197: CALL_OW 250
96201: PPUSH
96202: LD_VAR 0 1
96206: PPUSH
96207: CALL_OW 251
96211: PPUSH
96212: LD_INT 1
96214: PPUSH
96215: CALL_OW 453
96219: GO 96189
96221: POP
96222: POP
// end ;
96223: LD_VAR 0 2
96227: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96228: LD_INT 0
96230: PPUSH
96231: PPUSH
96232: PPUSH
96233: PPUSH
96234: PPUSH
96235: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96236: LD_VAR 0 1
96240: NOT
96241: PUSH
96242: LD_VAR 0 2
96246: NOT
96247: OR
96248: PUSH
96249: LD_VAR 0 1
96253: PPUSH
96254: CALL_OW 314
96258: OR
96259: IFFALSE 96263
// exit ;
96261: GO 96704
// x := GetX ( enemy_unit ) ;
96263: LD_ADDR_VAR 0 7
96267: PUSH
96268: LD_VAR 0 2
96272: PPUSH
96273: CALL_OW 250
96277: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96278: LD_ADDR_VAR 0 8
96282: PUSH
96283: LD_VAR 0 2
96287: PPUSH
96288: CALL_OW 251
96292: ST_TO_ADDR
// if not x or not y then
96293: LD_VAR 0 7
96297: NOT
96298: PUSH
96299: LD_VAR 0 8
96303: NOT
96304: OR
96305: IFFALSE 96309
// exit ;
96307: GO 96704
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96309: LD_ADDR_VAR 0 6
96313: PUSH
96314: LD_VAR 0 7
96318: PPUSH
96319: LD_INT 0
96321: PPUSH
96322: LD_INT 4
96324: PPUSH
96325: CALL_OW 272
96329: PUSH
96330: LD_VAR 0 8
96334: PPUSH
96335: LD_INT 0
96337: PPUSH
96338: LD_INT 4
96340: PPUSH
96341: CALL_OW 273
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: PUSH
96350: LD_VAR 0 7
96354: PPUSH
96355: LD_INT 1
96357: PPUSH
96358: LD_INT 4
96360: PPUSH
96361: CALL_OW 272
96365: PUSH
96366: LD_VAR 0 8
96370: PPUSH
96371: LD_INT 1
96373: PPUSH
96374: LD_INT 4
96376: PPUSH
96377: CALL_OW 273
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_VAR 0 7
96390: PPUSH
96391: LD_INT 2
96393: PPUSH
96394: LD_INT 4
96396: PPUSH
96397: CALL_OW 272
96401: PUSH
96402: LD_VAR 0 8
96406: PPUSH
96407: LD_INT 2
96409: PPUSH
96410: LD_INT 4
96412: PPUSH
96413: CALL_OW 273
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: LD_VAR 0 7
96426: PPUSH
96427: LD_INT 3
96429: PPUSH
96430: LD_INT 4
96432: PPUSH
96433: CALL_OW 272
96437: PUSH
96438: LD_VAR 0 8
96442: PPUSH
96443: LD_INT 3
96445: PPUSH
96446: LD_INT 4
96448: PPUSH
96449: CALL_OW 273
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: PUSH
96458: LD_VAR 0 7
96462: PPUSH
96463: LD_INT 4
96465: PPUSH
96466: LD_INT 4
96468: PPUSH
96469: CALL_OW 272
96473: PUSH
96474: LD_VAR 0 8
96478: PPUSH
96479: LD_INT 4
96481: PPUSH
96482: LD_INT 4
96484: PPUSH
96485: CALL_OW 273
96489: PUSH
96490: EMPTY
96491: LIST
96492: LIST
96493: PUSH
96494: LD_VAR 0 7
96498: PPUSH
96499: LD_INT 5
96501: PPUSH
96502: LD_INT 4
96504: PPUSH
96505: CALL_OW 272
96509: PUSH
96510: LD_VAR 0 8
96514: PPUSH
96515: LD_INT 5
96517: PPUSH
96518: LD_INT 4
96520: PPUSH
96521: CALL_OW 273
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: ST_TO_ADDR
// for i = tmp downto 1 do
96538: LD_ADDR_VAR 0 4
96542: PUSH
96543: DOUBLE
96544: LD_VAR 0 6
96548: INC
96549: ST_TO_ADDR
96550: LD_INT 1
96552: PUSH
96553: FOR_DOWNTO
96554: IFFALSE 96655
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
96556: LD_VAR 0 6
96560: PUSH
96561: LD_VAR 0 4
96565: ARRAY
96566: PUSH
96567: LD_INT 1
96569: ARRAY
96570: PPUSH
96571: LD_VAR 0 6
96575: PUSH
96576: LD_VAR 0 4
96580: ARRAY
96581: PUSH
96582: LD_INT 2
96584: ARRAY
96585: PPUSH
96586: CALL_OW 488
96590: NOT
96591: PUSH
96592: LD_VAR 0 6
96596: PUSH
96597: LD_VAR 0 4
96601: ARRAY
96602: PUSH
96603: LD_INT 1
96605: ARRAY
96606: PPUSH
96607: LD_VAR 0 6
96611: PUSH
96612: LD_VAR 0 4
96616: ARRAY
96617: PUSH
96618: LD_INT 2
96620: ARRAY
96621: PPUSH
96622: CALL_OW 428
96626: PUSH
96627: LD_INT 0
96629: NONEQUAL
96630: OR
96631: IFFALSE 96653
// tmp := Delete ( tmp , i ) ;
96633: LD_ADDR_VAR 0 6
96637: PUSH
96638: LD_VAR 0 6
96642: PPUSH
96643: LD_VAR 0 4
96647: PPUSH
96648: CALL_OW 3
96652: ST_TO_ADDR
96653: GO 96553
96655: POP
96656: POP
// j := GetClosestHex ( unit , tmp ) ;
96657: LD_ADDR_VAR 0 5
96661: PUSH
96662: LD_VAR 0 1
96666: PPUSH
96667: LD_VAR 0 6
96671: PPUSH
96672: CALL 95974 0 2
96676: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
96677: LD_VAR 0 1
96681: PPUSH
96682: LD_VAR 0 5
96686: PUSH
96687: LD_INT 1
96689: ARRAY
96690: PPUSH
96691: LD_VAR 0 5
96695: PUSH
96696: LD_INT 2
96698: ARRAY
96699: PPUSH
96700: CALL_OW 111
// end ;
96704: LD_VAR 0 3
96708: RET
// export function PrepareApemanSoldier ( ) ; begin
96709: LD_INT 0
96711: PPUSH
// uc_nation := 0 ;
96712: LD_ADDR_OWVAR 21
96716: PUSH
96717: LD_INT 0
96719: ST_TO_ADDR
// hc_sex := sex_male ;
96720: LD_ADDR_OWVAR 27
96724: PUSH
96725: LD_INT 1
96727: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
96728: LD_ADDR_OWVAR 28
96732: PUSH
96733: LD_INT 15
96735: ST_TO_ADDR
// hc_gallery :=  ;
96736: LD_ADDR_OWVAR 33
96740: PUSH
96741: LD_STRING 
96743: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96744: LD_ADDR_OWVAR 31
96748: PUSH
96749: LD_INT 0
96751: PPUSH
96752: LD_INT 3
96754: PPUSH
96755: CALL_OW 12
96759: PUSH
96760: LD_INT 0
96762: PPUSH
96763: LD_INT 3
96765: PPUSH
96766: CALL_OW 12
96770: PUSH
96771: LD_INT 0
96773: PUSH
96774: LD_INT 0
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: ST_TO_ADDR
// end ;
96783: LD_VAR 0 1
96787: RET
// export function PrepareApemanEngineer ( ) ; begin
96788: LD_INT 0
96790: PPUSH
// uc_nation := 0 ;
96791: LD_ADDR_OWVAR 21
96795: PUSH
96796: LD_INT 0
96798: ST_TO_ADDR
// hc_sex := sex_male ;
96799: LD_ADDR_OWVAR 27
96803: PUSH
96804: LD_INT 1
96806: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
96807: LD_ADDR_OWVAR 28
96811: PUSH
96812: LD_INT 16
96814: ST_TO_ADDR
// hc_gallery :=  ;
96815: LD_ADDR_OWVAR 33
96819: PUSH
96820: LD_STRING 
96822: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96823: LD_ADDR_OWVAR 31
96827: PUSH
96828: LD_INT 0
96830: PPUSH
96831: LD_INT 3
96833: PPUSH
96834: CALL_OW 12
96838: PUSH
96839: LD_INT 0
96841: PPUSH
96842: LD_INT 3
96844: PPUSH
96845: CALL_OW 12
96849: PUSH
96850: LD_INT 0
96852: PUSH
96853: LD_INT 0
96855: PUSH
96856: EMPTY
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: ST_TO_ADDR
// end ;
96862: LD_VAR 0 1
96866: RET
// export function PrepareApeman ( agressivity ) ; begin
96867: LD_INT 0
96869: PPUSH
// uc_side := 0 ;
96870: LD_ADDR_OWVAR 20
96874: PUSH
96875: LD_INT 0
96877: ST_TO_ADDR
// uc_nation := 0 ;
96878: LD_ADDR_OWVAR 21
96882: PUSH
96883: LD_INT 0
96885: ST_TO_ADDR
// hc_sex := sex_male ;
96886: LD_ADDR_OWVAR 27
96890: PUSH
96891: LD_INT 1
96893: ST_TO_ADDR
// hc_class := class_apeman ;
96894: LD_ADDR_OWVAR 28
96898: PUSH
96899: LD_INT 12
96901: ST_TO_ADDR
// hc_gallery :=  ;
96902: LD_ADDR_OWVAR 33
96906: PUSH
96907: LD_STRING 
96909: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
96910: LD_ADDR_OWVAR 35
96914: PUSH
96915: LD_VAR 0 1
96919: NEG
96920: PPUSH
96921: LD_VAR 0 1
96925: PPUSH
96926: CALL_OW 12
96930: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
96931: LD_ADDR_OWVAR 31
96935: PUSH
96936: LD_INT 0
96938: PPUSH
96939: LD_INT 3
96941: PPUSH
96942: CALL_OW 12
96946: PUSH
96947: LD_INT 0
96949: PPUSH
96950: LD_INT 3
96952: PPUSH
96953: CALL_OW 12
96957: PUSH
96958: LD_INT 0
96960: PUSH
96961: LD_INT 0
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: ST_TO_ADDR
// end ;
96970: LD_VAR 0 2
96974: RET
// export function PrepareTiger ( agressivity ) ; begin
96975: LD_INT 0
96977: PPUSH
// uc_side := 0 ;
96978: LD_ADDR_OWVAR 20
96982: PUSH
96983: LD_INT 0
96985: ST_TO_ADDR
// uc_nation := 0 ;
96986: LD_ADDR_OWVAR 21
96990: PUSH
96991: LD_INT 0
96993: ST_TO_ADDR
// hc_class := class_tiger ;
96994: LD_ADDR_OWVAR 28
96998: PUSH
96999: LD_INT 14
97001: ST_TO_ADDR
// hc_gallery :=  ;
97002: LD_ADDR_OWVAR 33
97006: PUSH
97007: LD_STRING 
97009: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
97010: LD_ADDR_OWVAR 35
97014: PUSH
97015: LD_VAR 0 1
97019: NEG
97020: PPUSH
97021: LD_VAR 0 1
97025: PPUSH
97026: CALL_OW 12
97030: ST_TO_ADDR
// end ;
97031: LD_VAR 0 2
97035: RET
// export function PrepareEnchidna ( ) ; begin
97036: LD_INT 0
97038: PPUSH
// uc_side := 0 ;
97039: LD_ADDR_OWVAR 20
97043: PUSH
97044: LD_INT 0
97046: ST_TO_ADDR
// uc_nation := 0 ;
97047: LD_ADDR_OWVAR 21
97051: PUSH
97052: LD_INT 0
97054: ST_TO_ADDR
// hc_class := class_baggie ;
97055: LD_ADDR_OWVAR 28
97059: PUSH
97060: LD_INT 13
97062: ST_TO_ADDR
// hc_gallery :=  ;
97063: LD_ADDR_OWVAR 33
97067: PUSH
97068: LD_STRING 
97070: ST_TO_ADDR
// end ;
97071: LD_VAR 0 1
97075: RET
// export function PrepareFrog ( ) ; begin
97076: LD_INT 0
97078: PPUSH
// uc_side := 0 ;
97079: LD_ADDR_OWVAR 20
97083: PUSH
97084: LD_INT 0
97086: ST_TO_ADDR
// uc_nation := 0 ;
97087: LD_ADDR_OWVAR 21
97091: PUSH
97092: LD_INT 0
97094: ST_TO_ADDR
// hc_class := class_frog ;
97095: LD_ADDR_OWVAR 28
97099: PUSH
97100: LD_INT 19
97102: ST_TO_ADDR
// hc_gallery :=  ;
97103: LD_ADDR_OWVAR 33
97107: PUSH
97108: LD_STRING 
97110: ST_TO_ADDR
// end ;
97111: LD_VAR 0 1
97115: RET
// export function PrepareFish ( ) ; begin
97116: LD_INT 0
97118: PPUSH
// uc_side := 0 ;
97119: LD_ADDR_OWVAR 20
97123: PUSH
97124: LD_INT 0
97126: ST_TO_ADDR
// uc_nation := 0 ;
97127: LD_ADDR_OWVAR 21
97131: PUSH
97132: LD_INT 0
97134: ST_TO_ADDR
// hc_class := class_fish ;
97135: LD_ADDR_OWVAR 28
97139: PUSH
97140: LD_INT 20
97142: ST_TO_ADDR
// hc_gallery :=  ;
97143: LD_ADDR_OWVAR 33
97147: PUSH
97148: LD_STRING 
97150: ST_TO_ADDR
// end ;
97151: LD_VAR 0 1
97155: RET
// export function PrepareBird ( ) ; begin
97156: LD_INT 0
97158: PPUSH
// uc_side := 0 ;
97159: LD_ADDR_OWVAR 20
97163: PUSH
97164: LD_INT 0
97166: ST_TO_ADDR
// uc_nation := 0 ;
97167: LD_ADDR_OWVAR 21
97171: PUSH
97172: LD_INT 0
97174: ST_TO_ADDR
// hc_class := class_phororhacos ;
97175: LD_ADDR_OWVAR 28
97179: PUSH
97180: LD_INT 18
97182: ST_TO_ADDR
// hc_gallery :=  ;
97183: LD_ADDR_OWVAR 33
97187: PUSH
97188: LD_STRING 
97190: ST_TO_ADDR
// end ;
97191: LD_VAR 0 1
97195: RET
// export function PrepareHorse ( ) ; begin
97196: LD_INT 0
97198: PPUSH
// uc_side := 0 ;
97199: LD_ADDR_OWVAR 20
97203: PUSH
97204: LD_INT 0
97206: ST_TO_ADDR
// uc_nation := 0 ;
97207: LD_ADDR_OWVAR 21
97211: PUSH
97212: LD_INT 0
97214: ST_TO_ADDR
// hc_class := class_horse ;
97215: LD_ADDR_OWVAR 28
97219: PUSH
97220: LD_INT 21
97222: ST_TO_ADDR
// hc_gallery :=  ;
97223: LD_ADDR_OWVAR 33
97227: PUSH
97228: LD_STRING 
97230: ST_TO_ADDR
// end ;
97231: LD_VAR 0 1
97235: RET
// export function PrepareMastodont ( ) ; begin
97236: LD_INT 0
97238: PPUSH
// uc_side := 0 ;
97239: LD_ADDR_OWVAR 20
97243: PUSH
97244: LD_INT 0
97246: ST_TO_ADDR
// uc_nation := 0 ;
97247: LD_ADDR_OWVAR 21
97251: PUSH
97252: LD_INT 0
97254: ST_TO_ADDR
// vc_chassis := class_mastodont ;
97255: LD_ADDR_OWVAR 37
97259: PUSH
97260: LD_INT 31
97262: ST_TO_ADDR
// vc_control := control_rider ;
97263: LD_ADDR_OWVAR 38
97267: PUSH
97268: LD_INT 4
97270: ST_TO_ADDR
// end ;
97271: LD_VAR 0 1
97275: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97276: LD_INT 0
97278: PPUSH
97279: PPUSH
97280: PPUSH
// uc_side = 0 ;
97281: LD_ADDR_OWVAR 20
97285: PUSH
97286: LD_INT 0
97288: ST_TO_ADDR
// uc_nation = 0 ;
97289: LD_ADDR_OWVAR 21
97293: PUSH
97294: LD_INT 0
97296: ST_TO_ADDR
// InitHc_All ( ) ;
97297: CALL_OW 584
// InitVc ;
97301: CALL_OW 20
// if mastodonts then
97305: LD_VAR 0 6
97309: IFFALSE 97376
// for i = 1 to mastodonts do
97311: LD_ADDR_VAR 0 11
97315: PUSH
97316: DOUBLE
97317: LD_INT 1
97319: DEC
97320: ST_TO_ADDR
97321: LD_VAR 0 6
97325: PUSH
97326: FOR_TO
97327: IFFALSE 97374
// begin vc_chassis := 31 ;
97329: LD_ADDR_OWVAR 37
97333: PUSH
97334: LD_INT 31
97336: ST_TO_ADDR
// vc_control := control_rider ;
97337: LD_ADDR_OWVAR 38
97341: PUSH
97342: LD_INT 4
97344: ST_TO_ADDR
// animal := CreateVehicle ;
97345: LD_ADDR_VAR 0 12
97349: PUSH
97350: CALL_OW 45
97354: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97355: LD_VAR 0 12
97359: PPUSH
97360: LD_VAR 0 8
97364: PPUSH
97365: LD_INT 0
97367: PPUSH
97368: CALL 99511 0 3
// end ;
97372: GO 97326
97374: POP
97375: POP
// if horses then
97376: LD_VAR 0 5
97380: IFFALSE 97447
// for i = 1 to horses do
97382: LD_ADDR_VAR 0 11
97386: PUSH
97387: DOUBLE
97388: LD_INT 1
97390: DEC
97391: ST_TO_ADDR
97392: LD_VAR 0 5
97396: PUSH
97397: FOR_TO
97398: IFFALSE 97445
// begin hc_class := 21 ;
97400: LD_ADDR_OWVAR 28
97404: PUSH
97405: LD_INT 21
97407: ST_TO_ADDR
// hc_gallery :=  ;
97408: LD_ADDR_OWVAR 33
97412: PUSH
97413: LD_STRING 
97415: ST_TO_ADDR
// animal := CreateHuman ;
97416: LD_ADDR_VAR 0 12
97420: PUSH
97421: CALL_OW 44
97425: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97426: LD_VAR 0 12
97430: PPUSH
97431: LD_VAR 0 8
97435: PPUSH
97436: LD_INT 0
97438: PPUSH
97439: CALL 99511 0 3
// end ;
97443: GO 97397
97445: POP
97446: POP
// if birds then
97447: LD_VAR 0 1
97451: IFFALSE 97518
// for i = 1 to birds do
97453: LD_ADDR_VAR 0 11
97457: PUSH
97458: DOUBLE
97459: LD_INT 1
97461: DEC
97462: ST_TO_ADDR
97463: LD_VAR 0 1
97467: PUSH
97468: FOR_TO
97469: IFFALSE 97516
// begin hc_class = 18 ;
97471: LD_ADDR_OWVAR 28
97475: PUSH
97476: LD_INT 18
97478: ST_TO_ADDR
// hc_gallery =  ;
97479: LD_ADDR_OWVAR 33
97483: PUSH
97484: LD_STRING 
97486: ST_TO_ADDR
// animal := CreateHuman ;
97487: LD_ADDR_VAR 0 12
97491: PUSH
97492: CALL_OW 44
97496: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97497: LD_VAR 0 12
97501: PPUSH
97502: LD_VAR 0 8
97506: PPUSH
97507: LD_INT 0
97509: PPUSH
97510: CALL 99511 0 3
// end ;
97514: GO 97468
97516: POP
97517: POP
// if tigers then
97518: LD_VAR 0 2
97522: IFFALSE 97606
// for i = 1 to tigers do
97524: LD_ADDR_VAR 0 11
97528: PUSH
97529: DOUBLE
97530: LD_INT 1
97532: DEC
97533: ST_TO_ADDR
97534: LD_VAR 0 2
97538: PUSH
97539: FOR_TO
97540: IFFALSE 97604
// begin hc_class = class_tiger ;
97542: LD_ADDR_OWVAR 28
97546: PUSH
97547: LD_INT 14
97549: ST_TO_ADDR
// hc_gallery =  ;
97550: LD_ADDR_OWVAR 33
97554: PUSH
97555: LD_STRING 
97557: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97558: LD_ADDR_OWVAR 35
97562: PUSH
97563: LD_INT 7
97565: NEG
97566: PPUSH
97567: LD_INT 7
97569: PPUSH
97570: CALL_OW 12
97574: ST_TO_ADDR
// animal := CreateHuman ;
97575: LD_ADDR_VAR 0 12
97579: PUSH
97580: CALL_OW 44
97584: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97585: LD_VAR 0 12
97589: PPUSH
97590: LD_VAR 0 8
97594: PPUSH
97595: LD_INT 0
97597: PPUSH
97598: CALL 99511 0 3
// end ;
97602: GO 97539
97604: POP
97605: POP
// if apemans then
97606: LD_VAR 0 3
97610: IFFALSE 97733
// for i = 1 to apemans do
97612: LD_ADDR_VAR 0 11
97616: PUSH
97617: DOUBLE
97618: LD_INT 1
97620: DEC
97621: ST_TO_ADDR
97622: LD_VAR 0 3
97626: PUSH
97627: FOR_TO
97628: IFFALSE 97731
// begin hc_class = class_apeman ;
97630: LD_ADDR_OWVAR 28
97634: PUSH
97635: LD_INT 12
97637: ST_TO_ADDR
// hc_gallery =  ;
97638: LD_ADDR_OWVAR 33
97642: PUSH
97643: LD_STRING 
97645: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
97646: LD_ADDR_OWVAR 35
97650: PUSH
97651: LD_INT 2
97653: NEG
97654: PPUSH
97655: LD_INT 2
97657: PPUSH
97658: CALL_OW 12
97662: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97663: LD_ADDR_OWVAR 31
97667: PUSH
97668: LD_INT 1
97670: PPUSH
97671: LD_INT 3
97673: PPUSH
97674: CALL_OW 12
97678: PUSH
97679: LD_INT 1
97681: PPUSH
97682: LD_INT 3
97684: PPUSH
97685: CALL_OW 12
97689: PUSH
97690: LD_INT 0
97692: PUSH
97693: LD_INT 0
97695: PUSH
97696: EMPTY
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: ST_TO_ADDR
// animal := CreateHuman ;
97702: LD_ADDR_VAR 0 12
97706: PUSH
97707: CALL_OW 44
97711: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97712: LD_VAR 0 12
97716: PPUSH
97717: LD_VAR 0 8
97721: PPUSH
97722: LD_INT 0
97724: PPUSH
97725: CALL 99511 0 3
// end ;
97729: GO 97627
97731: POP
97732: POP
// if enchidnas then
97733: LD_VAR 0 4
97737: IFFALSE 97804
// for i = 1 to enchidnas do
97739: LD_ADDR_VAR 0 11
97743: PUSH
97744: DOUBLE
97745: LD_INT 1
97747: DEC
97748: ST_TO_ADDR
97749: LD_VAR 0 4
97753: PUSH
97754: FOR_TO
97755: IFFALSE 97802
// begin hc_class = 13 ;
97757: LD_ADDR_OWVAR 28
97761: PUSH
97762: LD_INT 13
97764: ST_TO_ADDR
// hc_gallery =  ;
97765: LD_ADDR_OWVAR 33
97769: PUSH
97770: LD_STRING 
97772: ST_TO_ADDR
// animal := CreateHuman ;
97773: LD_ADDR_VAR 0 12
97777: PUSH
97778: CALL_OW 44
97782: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97783: LD_VAR 0 12
97787: PPUSH
97788: LD_VAR 0 8
97792: PPUSH
97793: LD_INT 0
97795: PPUSH
97796: CALL 99511 0 3
// end ;
97800: GO 97754
97802: POP
97803: POP
// if fishes then
97804: LD_VAR 0 7
97808: IFFALSE 97875
// for i = 1 to fishes do
97810: LD_ADDR_VAR 0 11
97814: PUSH
97815: DOUBLE
97816: LD_INT 1
97818: DEC
97819: ST_TO_ADDR
97820: LD_VAR 0 7
97824: PUSH
97825: FOR_TO
97826: IFFALSE 97873
// begin hc_class = 20 ;
97828: LD_ADDR_OWVAR 28
97832: PUSH
97833: LD_INT 20
97835: ST_TO_ADDR
// hc_gallery =  ;
97836: LD_ADDR_OWVAR 33
97840: PUSH
97841: LD_STRING 
97843: ST_TO_ADDR
// animal := CreateHuman ;
97844: LD_ADDR_VAR 0 12
97848: PUSH
97849: CALL_OW 44
97853: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97854: LD_VAR 0 12
97858: PPUSH
97859: LD_VAR 0 9
97863: PPUSH
97864: LD_INT 0
97866: PPUSH
97867: CALL 99511 0 3
// end ;
97871: GO 97825
97873: POP
97874: POP
// end ;
97875: LD_VAR 0 10
97879: RET
// export function WantHeal ( sci , unit ) ; begin
97880: LD_INT 0
97882: PPUSH
// if GetTaskList ( sci ) > 0 then
97883: LD_VAR 0 1
97887: PPUSH
97888: CALL_OW 437
97892: PUSH
97893: LD_INT 0
97895: GREATER
97896: IFFALSE 97966
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
97898: LD_VAR 0 1
97902: PPUSH
97903: CALL_OW 437
97907: PUSH
97908: LD_INT 1
97910: ARRAY
97911: PUSH
97912: LD_INT 1
97914: ARRAY
97915: PUSH
97916: LD_STRING l
97918: EQUAL
97919: PUSH
97920: LD_VAR 0 1
97924: PPUSH
97925: CALL_OW 437
97929: PUSH
97930: LD_INT 1
97932: ARRAY
97933: PUSH
97934: LD_INT 4
97936: ARRAY
97937: PUSH
97938: LD_VAR 0 2
97942: EQUAL
97943: AND
97944: IFFALSE 97956
// result := true else
97946: LD_ADDR_VAR 0 3
97950: PUSH
97951: LD_INT 1
97953: ST_TO_ADDR
97954: GO 97964
// result := false ;
97956: LD_ADDR_VAR 0 3
97960: PUSH
97961: LD_INT 0
97963: ST_TO_ADDR
// end else
97964: GO 97974
// result := false ;
97966: LD_ADDR_VAR 0 3
97970: PUSH
97971: LD_INT 0
97973: ST_TO_ADDR
// end ;
97974: LD_VAR 0 3
97978: RET
// export function HealTarget ( sci ) ; begin
97979: LD_INT 0
97981: PPUSH
// if not sci then
97982: LD_VAR 0 1
97986: NOT
97987: IFFALSE 97991
// exit ;
97989: GO 98056
// result := 0 ;
97991: LD_ADDR_VAR 0 2
97995: PUSH
97996: LD_INT 0
97998: ST_TO_ADDR
// if GetTaskList ( sci ) then
97999: LD_VAR 0 1
98003: PPUSH
98004: CALL_OW 437
98008: IFFALSE 98056
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98010: LD_VAR 0 1
98014: PPUSH
98015: CALL_OW 437
98019: PUSH
98020: LD_INT 1
98022: ARRAY
98023: PUSH
98024: LD_INT 1
98026: ARRAY
98027: PUSH
98028: LD_STRING l
98030: EQUAL
98031: IFFALSE 98056
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98033: LD_ADDR_VAR 0 2
98037: PUSH
98038: LD_VAR 0 1
98042: PPUSH
98043: CALL_OW 437
98047: PUSH
98048: LD_INT 1
98050: ARRAY
98051: PUSH
98052: LD_INT 4
98054: ARRAY
98055: ST_TO_ADDR
// end ;
98056: LD_VAR 0 2
98060: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98061: LD_INT 0
98063: PPUSH
98064: PPUSH
98065: PPUSH
98066: PPUSH
// if not base_units then
98067: LD_VAR 0 1
98071: NOT
98072: IFFALSE 98076
// exit ;
98074: GO 98163
// result := false ;
98076: LD_ADDR_VAR 0 2
98080: PUSH
98081: LD_INT 0
98083: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98084: LD_ADDR_VAR 0 5
98088: PUSH
98089: LD_VAR 0 1
98093: PPUSH
98094: LD_INT 21
98096: PUSH
98097: LD_INT 3
98099: PUSH
98100: EMPTY
98101: LIST
98102: LIST
98103: PPUSH
98104: CALL_OW 72
98108: ST_TO_ADDR
// if not tmp then
98109: LD_VAR 0 5
98113: NOT
98114: IFFALSE 98118
// exit ;
98116: GO 98163
// for i in tmp do
98118: LD_ADDR_VAR 0 3
98122: PUSH
98123: LD_VAR 0 5
98127: PUSH
98128: FOR_IN
98129: IFFALSE 98161
// begin result := EnemyInRange ( i , 22 ) ;
98131: LD_ADDR_VAR 0 2
98135: PUSH
98136: LD_VAR 0 3
98140: PPUSH
98141: LD_INT 22
98143: PPUSH
98144: CALL 95849 0 2
98148: ST_TO_ADDR
// if result then
98149: LD_VAR 0 2
98153: IFFALSE 98159
// exit ;
98155: POP
98156: POP
98157: GO 98163
// end ;
98159: GO 98128
98161: POP
98162: POP
// end ;
98163: LD_VAR 0 2
98167: RET
// export function FilterByTag ( units , tag ) ; begin
98168: LD_INT 0
98170: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
98171: LD_ADDR_VAR 0 3
98175: PUSH
98176: LD_VAR 0 1
98180: PPUSH
98181: LD_INT 120
98183: PUSH
98184: LD_VAR 0 2
98188: PUSH
98189: EMPTY
98190: LIST
98191: LIST
98192: PPUSH
98193: CALL_OW 72
98197: ST_TO_ADDR
// end ;
98198: LD_VAR 0 3
98202: RET
// export function IsDriver ( un ) ; begin
98203: LD_INT 0
98205: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98206: LD_ADDR_VAR 0 2
98210: PUSH
98211: LD_VAR 0 1
98215: PUSH
98216: LD_INT 55
98218: PUSH
98219: EMPTY
98220: LIST
98221: PPUSH
98222: CALL_OW 69
98226: IN
98227: ST_TO_ADDR
// end ;
98228: LD_VAR 0 2
98232: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98233: LD_INT 0
98235: PPUSH
98236: PPUSH
// list := [ ] ;
98237: LD_ADDR_VAR 0 5
98241: PUSH
98242: EMPTY
98243: ST_TO_ADDR
// case d of 0 :
98244: LD_VAR 0 3
98248: PUSH
98249: LD_INT 0
98251: DOUBLE
98252: EQUAL
98253: IFTRUE 98257
98255: GO 98390
98257: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98258: LD_ADDR_VAR 0 5
98262: PUSH
98263: LD_VAR 0 1
98267: PUSH
98268: LD_INT 4
98270: MINUS
98271: PUSH
98272: LD_VAR 0 2
98276: PUSH
98277: LD_INT 4
98279: MINUS
98280: PUSH
98281: LD_INT 2
98283: PUSH
98284: EMPTY
98285: LIST
98286: LIST
98287: LIST
98288: PUSH
98289: LD_VAR 0 1
98293: PUSH
98294: LD_INT 3
98296: MINUS
98297: PUSH
98298: LD_VAR 0 2
98302: PUSH
98303: LD_INT 1
98305: PUSH
98306: EMPTY
98307: LIST
98308: LIST
98309: LIST
98310: PUSH
98311: LD_VAR 0 1
98315: PUSH
98316: LD_INT 4
98318: PLUS
98319: PUSH
98320: LD_VAR 0 2
98324: PUSH
98325: LD_INT 4
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: LIST
98332: PUSH
98333: LD_VAR 0 1
98337: PUSH
98338: LD_INT 3
98340: PLUS
98341: PUSH
98342: LD_VAR 0 2
98346: PUSH
98347: LD_INT 3
98349: PLUS
98350: PUSH
98351: LD_INT 5
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: LIST
98358: PUSH
98359: LD_VAR 0 1
98363: PUSH
98364: LD_VAR 0 2
98368: PUSH
98369: LD_INT 4
98371: PLUS
98372: PUSH
98373: LD_INT 0
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: LIST
98380: PUSH
98381: EMPTY
98382: LIST
98383: LIST
98384: LIST
98385: LIST
98386: LIST
98387: ST_TO_ADDR
// end ; 1 :
98388: GO 99088
98390: LD_INT 1
98392: DOUBLE
98393: EQUAL
98394: IFTRUE 98398
98396: GO 98531
98398: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98399: LD_ADDR_VAR 0 5
98403: PUSH
98404: LD_VAR 0 1
98408: PUSH
98409: LD_VAR 0 2
98413: PUSH
98414: LD_INT 4
98416: MINUS
98417: PUSH
98418: LD_INT 3
98420: PUSH
98421: EMPTY
98422: LIST
98423: LIST
98424: LIST
98425: PUSH
98426: LD_VAR 0 1
98430: PUSH
98431: LD_INT 3
98433: MINUS
98434: PUSH
98435: LD_VAR 0 2
98439: PUSH
98440: LD_INT 3
98442: MINUS
98443: PUSH
98444: LD_INT 2
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: LIST
98451: PUSH
98452: LD_VAR 0 1
98456: PUSH
98457: LD_INT 4
98459: MINUS
98460: PUSH
98461: LD_VAR 0 2
98465: PUSH
98466: LD_INT 1
98468: PUSH
98469: EMPTY
98470: LIST
98471: LIST
98472: LIST
98473: PUSH
98474: LD_VAR 0 1
98478: PUSH
98479: LD_VAR 0 2
98483: PUSH
98484: LD_INT 3
98486: PLUS
98487: PUSH
98488: LD_INT 0
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: LIST
98495: PUSH
98496: LD_VAR 0 1
98500: PUSH
98501: LD_INT 4
98503: PLUS
98504: PUSH
98505: LD_VAR 0 2
98509: PUSH
98510: LD_INT 4
98512: PLUS
98513: PUSH
98514: LD_INT 5
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: LIST
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: ST_TO_ADDR
// end ; 2 :
98529: GO 99088
98531: LD_INT 2
98533: DOUBLE
98534: EQUAL
98535: IFTRUE 98539
98537: GO 98668
98539: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
98540: LD_ADDR_VAR 0 5
98544: PUSH
98545: LD_VAR 0 1
98549: PUSH
98550: LD_VAR 0 2
98554: PUSH
98555: LD_INT 3
98557: MINUS
98558: PUSH
98559: LD_INT 3
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: LIST
98566: PUSH
98567: LD_VAR 0 1
98571: PUSH
98572: LD_INT 4
98574: PLUS
98575: PUSH
98576: LD_VAR 0 2
98580: PUSH
98581: LD_INT 4
98583: PUSH
98584: EMPTY
98585: LIST
98586: LIST
98587: LIST
98588: PUSH
98589: LD_VAR 0 1
98593: PUSH
98594: LD_VAR 0 2
98598: PUSH
98599: LD_INT 4
98601: PLUS
98602: PUSH
98603: LD_INT 0
98605: PUSH
98606: EMPTY
98607: LIST
98608: LIST
98609: LIST
98610: PUSH
98611: LD_VAR 0 1
98615: PUSH
98616: LD_INT 3
98618: MINUS
98619: PUSH
98620: LD_VAR 0 2
98624: PUSH
98625: LD_INT 1
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: LIST
98632: PUSH
98633: LD_VAR 0 1
98637: PUSH
98638: LD_INT 4
98640: MINUS
98641: PUSH
98642: LD_VAR 0 2
98646: PUSH
98647: LD_INT 4
98649: MINUS
98650: PUSH
98651: LD_INT 2
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: LIST
98658: PUSH
98659: EMPTY
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: LIST
98665: ST_TO_ADDR
// end ; 3 :
98666: GO 99088
98668: LD_INT 3
98670: DOUBLE
98671: EQUAL
98672: IFTRUE 98676
98674: GO 98809
98676: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
98677: LD_ADDR_VAR 0 5
98681: PUSH
98682: LD_VAR 0 1
98686: PUSH
98687: LD_INT 3
98689: PLUS
98690: PUSH
98691: LD_VAR 0 2
98695: PUSH
98696: LD_INT 4
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: LIST
98703: PUSH
98704: LD_VAR 0 1
98708: PUSH
98709: LD_INT 4
98711: PLUS
98712: PUSH
98713: LD_VAR 0 2
98717: PUSH
98718: LD_INT 4
98720: PLUS
98721: PUSH
98722: LD_INT 5
98724: PUSH
98725: EMPTY
98726: LIST
98727: LIST
98728: LIST
98729: PUSH
98730: LD_VAR 0 1
98734: PUSH
98735: LD_INT 4
98737: MINUS
98738: PUSH
98739: LD_VAR 0 2
98743: PUSH
98744: LD_INT 1
98746: PUSH
98747: EMPTY
98748: LIST
98749: LIST
98750: LIST
98751: PUSH
98752: LD_VAR 0 1
98756: PUSH
98757: LD_VAR 0 2
98761: PUSH
98762: LD_INT 4
98764: MINUS
98765: PUSH
98766: LD_INT 3
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: LIST
98773: PUSH
98774: LD_VAR 0 1
98778: PUSH
98779: LD_INT 3
98781: MINUS
98782: PUSH
98783: LD_VAR 0 2
98787: PUSH
98788: LD_INT 3
98790: MINUS
98791: PUSH
98792: LD_INT 2
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: LIST
98799: PUSH
98800: EMPTY
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: ST_TO_ADDR
// end ; 4 :
98807: GO 99088
98809: LD_INT 4
98811: DOUBLE
98812: EQUAL
98813: IFTRUE 98817
98815: GO 98950
98817: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
98818: LD_ADDR_VAR 0 5
98822: PUSH
98823: LD_VAR 0 1
98827: PUSH
98828: LD_VAR 0 2
98832: PUSH
98833: LD_INT 4
98835: PLUS
98836: PUSH
98837: LD_INT 0
98839: PUSH
98840: EMPTY
98841: LIST
98842: LIST
98843: LIST
98844: PUSH
98845: LD_VAR 0 1
98849: PUSH
98850: LD_INT 3
98852: PLUS
98853: PUSH
98854: LD_VAR 0 2
98858: PUSH
98859: LD_INT 3
98861: PLUS
98862: PUSH
98863: LD_INT 5
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: LIST
98870: PUSH
98871: LD_VAR 0 1
98875: PUSH
98876: LD_INT 4
98878: PLUS
98879: PUSH
98880: LD_VAR 0 2
98884: PUSH
98885: LD_INT 4
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: LIST
98892: PUSH
98893: LD_VAR 0 1
98897: PUSH
98898: LD_VAR 0 2
98902: PUSH
98903: LD_INT 3
98905: MINUS
98906: PUSH
98907: LD_INT 3
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: LIST
98914: PUSH
98915: LD_VAR 0 1
98919: PUSH
98920: LD_INT 4
98922: MINUS
98923: PUSH
98924: LD_VAR 0 2
98928: PUSH
98929: LD_INT 4
98931: MINUS
98932: PUSH
98933: LD_INT 2
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: LIST
98940: PUSH
98941: EMPTY
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: ST_TO_ADDR
// end ; 5 :
98948: GO 99088
98950: LD_INT 5
98952: DOUBLE
98953: EQUAL
98954: IFTRUE 98958
98956: GO 99087
98958: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
98959: LD_ADDR_VAR 0 5
98963: PUSH
98964: LD_VAR 0 1
98968: PUSH
98969: LD_INT 4
98971: MINUS
98972: PUSH
98973: LD_VAR 0 2
98977: PUSH
98978: LD_INT 1
98980: PUSH
98981: EMPTY
98982: LIST
98983: LIST
98984: LIST
98985: PUSH
98986: LD_VAR 0 1
98990: PUSH
98991: LD_VAR 0 2
98995: PUSH
98996: LD_INT 4
98998: MINUS
98999: PUSH
99000: LD_INT 3
99002: PUSH
99003: EMPTY
99004: LIST
99005: LIST
99006: LIST
99007: PUSH
99008: LD_VAR 0 1
99012: PUSH
99013: LD_INT 4
99015: PLUS
99016: PUSH
99017: LD_VAR 0 2
99021: PUSH
99022: LD_INT 4
99024: PLUS
99025: PUSH
99026: LD_INT 5
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: LIST
99033: PUSH
99034: LD_VAR 0 1
99038: PUSH
99039: LD_INT 3
99041: PLUS
99042: PUSH
99043: LD_VAR 0 2
99047: PUSH
99048: LD_INT 4
99050: PUSH
99051: EMPTY
99052: LIST
99053: LIST
99054: LIST
99055: PUSH
99056: LD_VAR 0 1
99060: PUSH
99061: LD_VAR 0 2
99065: PUSH
99066: LD_INT 3
99068: PLUS
99069: PUSH
99070: LD_INT 0
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: LIST
99077: PUSH
99078: EMPTY
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: ST_TO_ADDR
// end ; end ;
99085: GO 99088
99087: POP
// result := list ;
99088: LD_ADDR_VAR 0 4
99092: PUSH
99093: LD_VAR 0 5
99097: ST_TO_ADDR
// end ;
99098: LD_VAR 0 4
99102: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99103: LD_INT 0
99105: PPUSH
99106: PPUSH
99107: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99108: LD_VAR 0 1
99112: NOT
99113: PUSH
99114: LD_VAR 0 2
99118: PUSH
99119: LD_INT 1
99121: PUSH
99122: LD_INT 2
99124: PUSH
99125: LD_INT 3
99127: PUSH
99128: LD_INT 4
99130: PUSH
99131: EMPTY
99132: LIST
99133: LIST
99134: LIST
99135: LIST
99136: IN
99137: NOT
99138: OR
99139: IFFALSE 99143
// exit ;
99141: GO 99235
// tmp := [ ] ;
99143: LD_ADDR_VAR 0 5
99147: PUSH
99148: EMPTY
99149: ST_TO_ADDR
// for i in units do
99150: LD_ADDR_VAR 0 4
99154: PUSH
99155: LD_VAR 0 1
99159: PUSH
99160: FOR_IN
99161: IFFALSE 99204
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99163: LD_ADDR_VAR 0 5
99167: PUSH
99168: LD_VAR 0 5
99172: PPUSH
99173: LD_VAR 0 5
99177: PUSH
99178: LD_INT 1
99180: PLUS
99181: PPUSH
99182: LD_VAR 0 4
99186: PPUSH
99187: LD_VAR 0 2
99191: PPUSH
99192: CALL_OW 259
99196: PPUSH
99197: CALL_OW 2
99201: ST_TO_ADDR
99202: GO 99160
99204: POP
99205: POP
// if not tmp then
99206: LD_VAR 0 5
99210: NOT
99211: IFFALSE 99215
// exit ;
99213: GO 99235
// result := SortListByListDesc ( units , tmp ) ;
99215: LD_ADDR_VAR 0 3
99219: PUSH
99220: LD_VAR 0 1
99224: PPUSH
99225: LD_VAR 0 5
99229: PPUSH
99230: CALL_OW 77
99234: ST_TO_ADDR
// end ;
99235: LD_VAR 0 3
99239: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99240: LD_INT 0
99242: PPUSH
99243: PPUSH
99244: PPUSH
// result := false ;
99245: LD_ADDR_VAR 0 3
99249: PUSH
99250: LD_INT 0
99252: ST_TO_ADDR
// x := GetX ( building ) ;
99253: LD_ADDR_VAR 0 4
99257: PUSH
99258: LD_VAR 0 2
99262: PPUSH
99263: CALL_OW 250
99267: ST_TO_ADDR
// y := GetY ( building ) ;
99268: LD_ADDR_VAR 0 5
99272: PUSH
99273: LD_VAR 0 2
99277: PPUSH
99278: CALL_OW 251
99282: ST_TO_ADDR
// if not building or not x or not y then
99283: LD_VAR 0 2
99287: NOT
99288: PUSH
99289: LD_VAR 0 4
99293: NOT
99294: OR
99295: PUSH
99296: LD_VAR 0 5
99300: NOT
99301: OR
99302: IFFALSE 99306
// exit ;
99304: GO 99398
// if GetTaskList ( unit ) then
99306: LD_VAR 0 1
99310: PPUSH
99311: CALL_OW 437
99315: IFFALSE 99398
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99317: LD_STRING e
99319: PUSH
99320: LD_VAR 0 1
99324: PPUSH
99325: CALL_OW 437
99329: PUSH
99330: LD_INT 1
99332: ARRAY
99333: PUSH
99334: LD_INT 1
99336: ARRAY
99337: EQUAL
99338: PUSH
99339: LD_VAR 0 4
99343: PUSH
99344: LD_VAR 0 1
99348: PPUSH
99349: CALL_OW 437
99353: PUSH
99354: LD_INT 1
99356: ARRAY
99357: PUSH
99358: LD_INT 2
99360: ARRAY
99361: EQUAL
99362: AND
99363: PUSH
99364: LD_VAR 0 5
99368: PUSH
99369: LD_VAR 0 1
99373: PPUSH
99374: CALL_OW 437
99378: PUSH
99379: LD_INT 1
99381: ARRAY
99382: PUSH
99383: LD_INT 3
99385: ARRAY
99386: EQUAL
99387: AND
99388: IFFALSE 99398
// result := true end ;
99390: LD_ADDR_VAR 0 3
99394: PUSH
99395: LD_INT 1
99397: ST_TO_ADDR
// end ;
99398: LD_VAR 0 3
99402: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
99403: LD_INT 0
99405: PPUSH
// result := false ;
99406: LD_ADDR_VAR 0 4
99410: PUSH
99411: LD_INT 0
99413: ST_TO_ADDR
// if GetTaskList ( unit ) then
99414: LD_VAR 0 1
99418: PPUSH
99419: CALL_OW 437
99423: IFFALSE 99506
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99425: LD_STRING M
99427: PUSH
99428: LD_VAR 0 1
99432: PPUSH
99433: CALL_OW 437
99437: PUSH
99438: LD_INT 1
99440: ARRAY
99441: PUSH
99442: LD_INT 1
99444: ARRAY
99445: EQUAL
99446: PUSH
99447: LD_VAR 0 2
99451: PUSH
99452: LD_VAR 0 1
99456: PPUSH
99457: CALL_OW 437
99461: PUSH
99462: LD_INT 1
99464: ARRAY
99465: PUSH
99466: LD_INT 2
99468: ARRAY
99469: EQUAL
99470: AND
99471: PUSH
99472: LD_VAR 0 3
99476: PUSH
99477: LD_VAR 0 1
99481: PPUSH
99482: CALL_OW 437
99486: PUSH
99487: LD_INT 1
99489: ARRAY
99490: PUSH
99491: LD_INT 3
99493: ARRAY
99494: EQUAL
99495: AND
99496: IFFALSE 99506
// result := true ;
99498: LD_ADDR_VAR 0 4
99502: PUSH
99503: LD_INT 1
99505: ST_TO_ADDR
// end ; end ;
99506: LD_VAR 0 4
99510: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99511: LD_INT 0
99513: PPUSH
99514: PPUSH
99515: PPUSH
99516: PPUSH
// if not unit or not area then
99517: LD_VAR 0 1
99521: NOT
99522: PUSH
99523: LD_VAR 0 2
99527: NOT
99528: OR
99529: IFFALSE 99533
// exit ;
99531: GO 99697
// tmp := AreaToList ( area , i ) ;
99533: LD_ADDR_VAR 0 6
99537: PUSH
99538: LD_VAR 0 2
99542: PPUSH
99543: LD_VAR 0 5
99547: PPUSH
99548: CALL_OW 517
99552: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99553: LD_ADDR_VAR 0 5
99557: PUSH
99558: DOUBLE
99559: LD_INT 1
99561: DEC
99562: ST_TO_ADDR
99563: LD_VAR 0 6
99567: PUSH
99568: LD_INT 1
99570: ARRAY
99571: PUSH
99572: FOR_TO
99573: IFFALSE 99695
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99575: LD_ADDR_VAR 0 7
99579: PUSH
99580: LD_VAR 0 6
99584: PUSH
99585: LD_INT 1
99587: ARRAY
99588: PUSH
99589: LD_VAR 0 5
99593: ARRAY
99594: PUSH
99595: LD_VAR 0 6
99599: PUSH
99600: LD_INT 2
99602: ARRAY
99603: PUSH
99604: LD_VAR 0 5
99608: ARRAY
99609: PUSH
99610: EMPTY
99611: LIST
99612: LIST
99613: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99614: LD_VAR 0 7
99618: PUSH
99619: LD_INT 1
99621: ARRAY
99622: PPUSH
99623: LD_VAR 0 7
99627: PUSH
99628: LD_INT 2
99630: ARRAY
99631: PPUSH
99632: CALL_OW 428
99636: PUSH
99637: LD_INT 0
99639: EQUAL
99640: IFFALSE 99693
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
99642: LD_VAR 0 1
99646: PPUSH
99647: LD_VAR 0 7
99651: PUSH
99652: LD_INT 1
99654: ARRAY
99655: PPUSH
99656: LD_VAR 0 7
99660: PUSH
99661: LD_INT 2
99663: ARRAY
99664: PPUSH
99665: LD_VAR 0 3
99669: PPUSH
99670: CALL_OW 48
// result := IsPlaced ( unit ) ;
99674: LD_ADDR_VAR 0 4
99678: PUSH
99679: LD_VAR 0 1
99683: PPUSH
99684: CALL_OW 305
99688: ST_TO_ADDR
// exit ;
99689: POP
99690: POP
99691: GO 99697
// end ; end ;
99693: GO 99572
99695: POP
99696: POP
// end ;
99697: LD_VAR 0 4
99701: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
99702: LD_INT 0
99704: PPUSH
99705: PPUSH
99706: PPUSH
// if not side or side > 8 then
99707: LD_VAR 0 1
99711: NOT
99712: PUSH
99713: LD_VAR 0 1
99717: PUSH
99718: LD_INT 8
99720: GREATER
99721: OR
99722: IFFALSE 99726
// exit ;
99724: GO 99913
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
99726: LD_ADDR_VAR 0 4
99730: PUSH
99731: LD_INT 22
99733: PUSH
99734: LD_VAR 0 1
99738: PUSH
99739: EMPTY
99740: LIST
99741: LIST
99742: PUSH
99743: LD_INT 21
99745: PUSH
99746: LD_INT 3
99748: PUSH
99749: EMPTY
99750: LIST
99751: LIST
99752: PUSH
99753: EMPTY
99754: LIST
99755: LIST
99756: PPUSH
99757: CALL_OW 69
99761: ST_TO_ADDR
// if not tmp then
99762: LD_VAR 0 4
99766: NOT
99767: IFFALSE 99771
// exit ;
99769: GO 99913
// enable_addtolog := true ;
99771: LD_ADDR_OWVAR 81
99775: PUSH
99776: LD_INT 1
99778: ST_TO_ADDR
// AddToLog ( [ ) ;
99779: LD_STRING [
99781: PPUSH
99782: CALL_OW 561
// for i in tmp do
99786: LD_ADDR_VAR 0 3
99790: PUSH
99791: LD_VAR 0 4
99795: PUSH
99796: FOR_IN
99797: IFFALSE 99904
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
99799: LD_STRING [
99801: PUSH
99802: LD_VAR 0 3
99806: PPUSH
99807: CALL_OW 266
99811: STR
99812: PUSH
99813: LD_STRING , 
99815: STR
99816: PUSH
99817: LD_VAR 0 3
99821: PPUSH
99822: CALL_OW 250
99826: STR
99827: PUSH
99828: LD_STRING , 
99830: STR
99831: PUSH
99832: LD_VAR 0 3
99836: PPUSH
99837: CALL_OW 251
99841: STR
99842: PUSH
99843: LD_STRING , 
99845: STR
99846: PUSH
99847: LD_VAR 0 3
99851: PPUSH
99852: CALL_OW 254
99856: STR
99857: PUSH
99858: LD_STRING , 
99860: STR
99861: PUSH
99862: LD_VAR 0 3
99866: PPUSH
99867: LD_INT 1
99869: PPUSH
99870: CALL_OW 268
99874: STR
99875: PUSH
99876: LD_STRING , 
99878: STR
99879: PUSH
99880: LD_VAR 0 3
99884: PPUSH
99885: LD_INT 2
99887: PPUSH
99888: CALL_OW 268
99892: STR
99893: PUSH
99894: LD_STRING ],
99896: STR
99897: PPUSH
99898: CALL_OW 561
// end ;
99902: GO 99796
99904: POP
99905: POP
// AddToLog ( ]; ) ;
99906: LD_STRING ];
99908: PPUSH
99909: CALL_OW 561
// end ;
99913: LD_VAR 0 2
99917: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
99918: LD_INT 0
99920: PPUSH
99921: PPUSH
99922: PPUSH
99923: PPUSH
99924: PPUSH
// if not area or not rate or not max then
99925: LD_VAR 0 1
99929: NOT
99930: PUSH
99931: LD_VAR 0 2
99935: NOT
99936: OR
99937: PUSH
99938: LD_VAR 0 4
99942: NOT
99943: OR
99944: IFFALSE 99948
// exit ;
99946: GO 100137
// while 1 do
99948: LD_INT 1
99950: IFFALSE 100137
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
99952: LD_ADDR_VAR 0 9
99956: PUSH
99957: LD_VAR 0 1
99961: PPUSH
99962: LD_INT 1
99964: PPUSH
99965: CALL_OW 287
99969: PUSH
99970: LD_INT 10
99972: MUL
99973: ST_TO_ADDR
// r := rate / 10 ;
99974: LD_ADDR_VAR 0 7
99978: PUSH
99979: LD_VAR 0 2
99983: PUSH
99984: LD_INT 10
99986: DIVREAL
99987: ST_TO_ADDR
// time := 1 1$00 ;
99988: LD_ADDR_VAR 0 8
99992: PUSH
99993: LD_INT 2100
99995: ST_TO_ADDR
// if amount < min then
99996: LD_VAR 0 9
100000: PUSH
100001: LD_VAR 0 3
100005: LESS
100006: IFFALSE 100024
// r := r * 2 else
100008: LD_ADDR_VAR 0 7
100012: PUSH
100013: LD_VAR 0 7
100017: PUSH
100018: LD_INT 2
100020: MUL
100021: ST_TO_ADDR
100022: GO 100050
// if amount > max then
100024: LD_VAR 0 9
100028: PUSH
100029: LD_VAR 0 4
100033: GREATER
100034: IFFALSE 100050
// r := r / 2 ;
100036: LD_ADDR_VAR 0 7
100040: PUSH
100041: LD_VAR 0 7
100045: PUSH
100046: LD_INT 2
100048: DIVREAL
100049: ST_TO_ADDR
// time := time / r ;
100050: LD_ADDR_VAR 0 8
100054: PUSH
100055: LD_VAR 0 8
100059: PUSH
100060: LD_VAR 0 7
100064: DIVREAL
100065: ST_TO_ADDR
// if time < 0 then
100066: LD_VAR 0 8
100070: PUSH
100071: LD_INT 0
100073: LESS
100074: IFFALSE 100091
// time := time * - 1 ;
100076: LD_ADDR_VAR 0 8
100080: PUSH
100081: LD_VAR 0 8
100085: PUSH
100086: LD_INT 1
100088: NEG
100089: MUL
100090: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
100091: LD_VAR 0 8
100095: PUSH
100096: LD_INT 35
100098: PPUSH
100099: LD_INT 875
100101: PPUSH
100102: CALL_OW 12
100106: PLUS
100107: PPUSH
100108: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100112: LD_INT 1
100114: PPUSH
100115: LD_INT 5
100117: PPUSH
100118: CALL_OW 12
100122: PPUSH
100123: LD_VAR 0 1
100127: PPUSH
100128: LD_INT 1
100130: PPUSH
100131: CALL_OW 55
// end ;
100135: GO 99948
// end ;
100137: LD_VAR 0 5
100141: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100142: LD_INT 0
100144: PPUSH
100145: PPUSH
100146: PPUSH
100147: PPUSH
100148: PPUSH
100149: PPUSH
100150: PPUSH
100151: PPUSH
// if not turrets or not factories then
100152: LD_VAR 0 1
100156: NOT
100157: PUSH
100158: LD_VAR 0 2
100162: NOT
100163: OR
100164: IFFALSE 100168
// exit ;
100166: GO 100475
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100168: LD_ADDR_VAR 0 10
100172: PUSH
100173: LD_INT 5
100175: PUSH
100176: LD_INT 6
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: PUSH
100183: LD_INT 2
100185: PUSH
100186: LD_INT 4
100188: PUSH
100189: EMPTY
100190: LIST
100191: LIST
100192: PUSH
100193: LD_INT 3
100195: PUSH
100196: LD_INT 5
100198: PUSH
100199: EMPTY
100200: LIST
100201: LIST
100202: PUSH
100203: EMPTY
100204: LIST
100205: LIST
100206: LIST
100207: PUSH
100208: LD_INT 24
100210: PUSH
100211: LD_INT 25
100213: PUSH
100214: EMPTY
100215: LIST
100216: LIST
100217: PUSH
100218: LD_INT 23
100220: PUSH
100221: LD_INT 27
100223: PUSH
100224: EMPTY
100225: LIST
100226: LIST
100227: PUSH
100228: EMPTY
100229: LIST
100230: LIST
100231: PUSH
100232: LD_INT 42
100234: PUSH
100235: LD_INT 43
100237: PUSH
100238: EMPTY
100239: LIST
100240: LIST
100241: PUSH
100242: LD_INT 44
100244: PUSH
100245: LD_INT 46
100247: PUSH
100248: EMPTY
100249: LIST
100250: LIST
100251: PUSH
100252: LD_INT 45
100254: PUSH
100255: LD_INT 47
100257: PUSH
100258: EMPTY
100259: LIST
100260: LIST
100261: PUSH
100262: EMPTY
100263: LIST
100264: LIST
100265: LIST
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: LIST
100271: ST_TO_ADDR
// result := [ ] ;
100272: LD_ADDR_VAR 0 3
100276: PUSH
100277: EMPTY
100278: ST_TO_ADDR
// for i in turrets do
100279: LD_ADDR_VAR 0 4
100283: PUSH
100284: LD_VAR 0 1
100288: PUSH
100289: FOR_IN
100290: IFFALSE 100473
// begin nat := GetNation ( i ) ;
100292: LD_ADDR_VAR 0 7
100296: PUSH
100297: LD_VAR 0 4
100301: PPUSH
100302: CALL_OW 248
100306: ST_TO_ADDR
// weapon := 0 ;
100307: LD_ADDR_VAR 0 8
100311: PUSH
100312: LD_INT 0
100314: ST_TO_ADDR
// if not nat then
100315: LD_VAR 0 7
100319: NOT
100320: IFFALSE 100324
// continue ;
100322: GO 100289
// for j in list [ nat ] do
100324: LD_ADDR_VAR 0 5
100328: PUSH
100329: LD_VAR 0 10
100333: PUSH
100334: LD_VAR 0 7
100338: ARRAY
100339: PUSH
100340: FOR_IN
100341: IFFALSE 100382
// if GetBWeapon ( i ) = j [ 1 ] then
100343: LD_VAR 0 4
100347: PPUSH
100348: CALL_OW 269
100352: PUSH
100353: LD_VAR 0 5
100357: PUSH
100358: LD_INT 1
100360: ARRAY
100361: EQUAL
100362: IFFALSE 100380
// begin weapon := j [ 2 ] ;
100364: LD_ADDR_VAR 0 8
100368: PUSH
100369: LD_VAR 0 5
100373: PUSH
100374: LD_INT 2
100376: ARRAY
100377: ST_TO_ADDR
// break ;
100378: GO 100382
// end ;
100380: GO 100340
100382: POP
100383: POP
// if not weapon then
100384: LD_VAR 0 8
100388: NOT
100389: IFFALSE 100393
// continue ;
100391: GO 100289
// for k in factories do
100393: LD_ADDR_VAR 0 6
100397: PUSH
100398: LD_VAR 0 2
100402: PUSH
100403: FOR_IN
100404: IFFALSE 100469
// begin weapons := AvailableWeaponList ( k ) ;
100406: LD_ADDR_VAR 0 9
100410: PUSH
100411: LD_VAR 0 6
100415: PPUSH
100416: CALL_OW 478
100420: ST_TO_ADDR
// if not weapons then
100421: LD_VAR 0 9
100425: NOT
100426: IFFALSE 100430
// continue ;
100428: GO 100403
// if weapon in weapons then
100430: LD_VAR 0 8
100434: PUSH
100435: LD_VAR 0 9
100439: IN
100440: IFFALSE 100467
// begin result := [ i , weapon ] ;
100442: LD_ADDR_VAR 0 3
100446: PUSH
100447: LD_VAR 0 4
100451: PUSH
100452: LD_VAR 0 8
100456: PUSH
100457: EMPTY
100458: LIST
100459: LIST
100460: ST_TO_ADDR
// exit ;
100461: POP
100462: POP
100463: POP
100464: POP
100465: GO 100475
// end ; end ;
100467: GO 100403
100469: POP
100470: POP
// end ;
100471: GO 100289
100473: POP
100474: POP
// end ;
100475: LD_VAR 0 3
100479: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100480: LD_INT 0
100482: PPUSH
// if not side or side > 8 then
100483: LD_VAR 0 3
100487: NOT
100488: PUSH
100489: LD_VAR 0 3
100493: PUSH
100494: LD_INT 8
100496: GREATER
100497: OR
100498: IFFALSE 100502
// exit ;
100500: GO 100561
// if not range then
100502: LD_VAR 0 4
100506: NOT
100507: IFFALSE 100518
// range := - 12 ;
100509: LD_ADDR_VAR 0 4
100513: PUSH
100514: LD_INT 12
100516: NEG
100517: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100518: LD_VAR 0 1
100522: PPUSH
100523: LD_VAR 0 2
100527: PPUSH
100528: LD_VAR 0 3
100532: PPUSH
100533: LD_VAR 0 4
100537: PPUSH
100538: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100542: LD_VAR 0 1
100546: PPUSH
100547: LD_VAR 0 2
100551: PPUSH
100552: LD_VAR 0 3
100556: PPUSH
100557: CALL_OW 331
// end ;
100561: LD_VAR 0 5
100565: RET
// export function Video ( mode ) ; begin
100566: LD_INT 0
100568: PPUSH
// ingame_video = mode ;
100569: LD_ADDR_OWVAR 52
100573: PUSH
100574: LD_VAR 0 1
100578: ST_TO_ADDR
// interface_hidden = mode ;
100579: LD_ADDR_OWVAR 54
100583: PUSH
100584: LD_VAR 0 1
100588: ST_TO_ADDR
// end ;
100589: LD_VAR 0 2
100593: RET
// export function Join ( array , element ) ; begin
100594: LD_INT 0
100596: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100597: LD_ADDR_VAR 0 3
100601: PUSH
100602: LD_VAR 0 1
100606: PPUSH
100607: LD_VAR 0 1
100611: PUSH
100612: LD_INT 1
100614: PLUS
100615: PPUSH
100616: LD_VAR 0 2
100620: PPUSH
100621: CALL_OW 1
100625: ST_TO_ADDR
// end ;
100626: LD_VAR 0 3
100630: RET
// export function JoinUnion ( array , element ) ; begin
100631: LD_INT 0
100633: PPUSH
// result := array union element ;
100634: LD_ADDR_VAR 0 3
100638: PUSH
100639: LD_VAR 0 1
100643: PUSH
100644: LD_VAR 0 2
100648: UNION
100649: ST_TO_ADDR
// end ;
100650: LD_VAR 0 3
100654: RET
// export function GetBehemoths ( side ) ; begin
100655: LD_INT 0
100657: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
100658: LD_ADDR_VAR 0 2
100662: PUSH
100663: LD_INT 22
100665: PUSH
100666: LD_VAR 0 1
100670: PUSH
100671: EMPTY
100672: LIST
100673: LIST
100674: PUSH
100675: LD_INT 31
100677: PUSH
100678: LD_INT 25
100680: PUSH
100681: EMPTY
100682: LIST
100683: LIST
100684: PUSH
100685: EMPTY
100686: LIST
100687: LIST
100688: PPUSH
100689: CALL_OW 69
100693: ST_TO_ADDR
// end ;
100694: LD_VAR 0 2
100698: RET
// export function Shuffle ( array ) ; var i , index ; begin
100699: LD_INT 0
100701: PPUSH
100702: PPUSH
100703: PPUSH
// result := [ ] ;
100704: LD_ADDR_VAR 0 2
100708: PUSH
100709: EMPTY
100710: ST_TO_ADDR
// if not array then
100711: LD_VAR 0 1
100715: NOT
100716: IFFALSE 100720
// exit ;
100718: GO 100819
// Randomize ;
100720: CALL_OW 10
// for i = array downto 1 do
100724: LD_ADDR_VAR 0 3
100728: PUSH
100729: DOUBLE
100730: LD_VAR 0 1
100734: INC
100735: ST_TO_ADDR
100736: LD_INT 1
100738: PUSH
100739: FOR_DOWNTO
100740: IFFALSE 100817
// begin index := rand ( 1 , array ) ;
100742: LD_ADDR_VAR 0 4
100746: PUSH
100747: LD_INT 1
100749: PPUSH
100750: LD_VAR 0 1
100754: PPUSH
100755: CALL_OW 12
100759: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
100760: LD_ADDR_VAR 0 2
100764: PUSH
100765: LD_VAR 0 2
100769: PPUSH
100770: LD_VAR 0 2
100774: PUSH
100775: LD_INT 1
100777: PLUS
100778: PPUSH
100779: LD_VAR 0 1
100783: PUSH
100784: LD_VAR 0 4
100788: ARRAY
100789: PPUSH
100790: CALL_OW 2
100794: ST_TO_ADDR
// array := Delete ( array , index ) ;
100795: LD_ADDR_VAR 0 1
100799: PUSH
100800: LD_VAR 0 1
100804: PPUSH
100805: LD_VAR 0 4
100809: PPUSH
100810: CALL_OW 3
100814: ST_TO_ADDR
// end ;
100815: GO 100739
100817: POP
100818: POP
// end ;
100819: LD_VAR 0 2
100823: RET
// export function GetBaseMaterials ( base ) ; begin
100824: LD_INT 0
100826: PPUSH
// result := [ 0 , 0 , 0 ] ;
100827: LD_ADDR_VAR 0 2
100831: PUSH
100832: LD_INT 0
100834: PUSH
100835: LD_INT 0
100837: PUSH
100838: LD_INT 0
100840: PUSH
100841: EMPTY
100842: LIST
100843: LIST
100844: LIST
100845: ST_TO_ADDR
// if not base then
100846: LD_VAR 0 1
100850: NOT
100851: IFFALSE 100855
// exit ;
100853: GO 100904
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
100855: LD_ADDR_VAR 0 2
100859: PUSH
100860: LD_VAR 0 1
100864: PPUSH
100865: LD_INT 1
100867: PPUSH
100868: CALL_OW 275
100872: PUSH
100873: LD_VAR 0 1
100877: PPUSH
100878: LD_INT 2
100880: PPUSH
100881: CALL_OW 275
100885: PUSH
100886: LD_VAR 0 1
100890: PPUSH
100891: LD_INT 3
100893: PPUSH
100894: CALL_OW 275
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: LIST
100903: ST_TO_ADDR
// end ;
100904: LD_VAR 0 2
100908: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
100909: LD_INT 0
100911: PPUSH
100912: PPUSH
// result := array ;
100913: LD_ADDR_VAR 0 3
100917: PUSH
100918: LD_VAR 0 1
100922: ST_TO_ADDR
// if size >= result then
100923: LD_VAR 0 2
100927: PUSH
100928: LD_VAR 0 3
100932: GREATEREQUAL
100933: IFFALSE 100937
// exit ;
100935: GO 100987
// if size then
100937: LD_VAR 0 2
100941: IFFALSE 100987
// for i := array downto size do
100943: LD_ADDR_VAR 0 4
100947: PUSH
100948: DOUBLE
100949: LD_VAR 0 1
100953: INC
100954: ST_TO_ADDR
100955: LD_VAR 0 2
100959: PUSH
100960: FOR_DOWNTO
100961: IFFALSE 100985
// result := Delete ( result , result ) ;
100963: LD_ADDR_VAR 0 3
100967: PUSH
100968: LD_VAR 0 3
100972: PPUSH
100973: LD_VAR 0 3
100977: PPUSH
100978: CALL_OW 3
100982: ST_TO_ADDR
100983: GO 100960
100985: POP
100986: POP
// end ;
100987: LD_VAR 0 3
100991: RET
// export function ComExit ( unit ) ; var tmp ; begin
100992: LD_INT 0
100994: PPUSH
100995: PPUSH
// if not IsInUnit ( unit ) then
100996: LD_VAR 0 1
101000: PPUSH
101001: CALL_OW 310
101005: NOT
101006: IFFALSE 101010
// exit ;
101008: GO 101070
// tmp := IsInUnit ( unit ) ;
101010: LD_ADDR_VAR 0 3
101014: PUSH
101015: LD_VAR 0 1
101019: PPUSH
101020: CALL_OW 310
101024: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101025: LD_VAR 0 3
101029: PPUSH
101030: CALL_OW 247
101034: PUSH
101035: LD_INT 2
101037: EQUAL
101038: IFFALSE 101051
// ComExitVehicle ( unit ) else
101040: LD_VAR 0 1
101044: PPUSH
101045: CALL_OW 121
101049: GO 101060
// ComExitBuilding ( unit ) ;
101051: LD_VAR 0 1
101055: PPUSH
101056: CALL_OW 122
// result := tmp ;
101060: LD_ADDR_VAR 0 2
101064: PUSH
101065: LD_VAR 0 3
101069: ST_TO_ADDR
// end ;
101070: LD_VAR 0 2
101074: RET
// export function ComExitAll ( units ) ; var i ; begin
101075: LD_INT 0
101077: PPUSH
101078: PPUSH
// if not units then
101079: LD_VAR 0 1
101083: NOT
101084: IFFALSE 101088
// exit ;
101086: GO 101114
// for i in units do
101088: LD_ADDR_VAR 0 3
101092: PUSH
101093: LD_VAR 0 1
101097: PUSH
101098: FOR_IN
101099: IFFALSE 101112
// ComExit ( i ) ;
101101: LD_VAR 0 3
101105: PPUSH
101106: CALL 100992 0 1
101110: GO 101098
101112: POP
101113: POP
// end ;
101114: LD_VAR 0 2
101118: RET
// export function ResetHc ; begin
101119: LD_INT 0
101121: PPUSH
// InitHc ;
101122: CALL_OW 19
// hc_importance := 0 ;
101126: LD_ADDR_OWVAR 32
101130: PUSH
101131: LD_INT 0
101133: ST_TO_ADDR
// end ;
101134: LD_VAR 0 1
101138: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
101139: LD_INT 0
101141: PPUSH
101142: PPUSH
101143: PPUSH
// _x := ( x1 + x2 ) div 2 ;
101144: LD_ADDR_VAR 0 6
101148: PUSH
101149: LD_VAR 0 1
101153: PUSH
101154: LD_VAR 0 3
101158: PLUS
101159: PUSH
101160: LD_INT 2
101162: DIV
101163: ST_TO_ADDR
// if _x < 0 then
101164: LD_VAR 0 6
101168: PUSH
101169: LD_INT 0
101171: LESS
101172: IFFALSE 101189
// _x := _x * - 1 ;
101174: LD_ADDR_VAR 0 6
101178: PUSH
101179: LD_VAR 0 6
101183: PUSH
101184: LD_INT 1
101186: NEG
101187: MUL
101188: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
101189: LD_ADDR_VAR 0 7
101193: PUSH
101194: LD_VAR 0 2
101198: PUSH
101199: LD_VAR 0 4
101203: PLUS
101204: PUSH
101205: LD_INT 2
101207: DIV
101208: ST_TO_ADDR
// if _y < 0 then
101209: LD_VAR 0 7
101213: PUSH
101214: LD_INT 0
101216: LESS
101217: IFFALSE 101234
// _y := _y * - 1 ;
101219: LD_ADDR_VAR 0 7
101223: PUSH
101224: LD_VAR 0 7
101228: PUSH
101229: LD_INT 1
101231: NEG
101232: MUL
101233: ST_TO_ADDR
// result := [ _x , _y ] ;
101234: LD_ADDR_VAR 0 5
101238: PUSH
101239: LD_VAR 0 6
101243: PUSH
101244: LD_VAR 0 7
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: ST_TO_ADDR
// end ;
101253: LD_VAR 0 5
101257: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
101258: LD_INT 0
101260: PPUSH
101261: PPUSH
101262: PPUSH
101263: PPUSH
// task := GetTaskList ( unit ) ;
101264: LD_ADDR_VAR 0 7
101268: PUSH
101269: LD_VAR 0 1
101273: PPUSH
101274: CALL_OW 437
101278: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
101279: LD_VAR 0 7
101283: NOT
101284: PUSH
101285: LD_VAR 0 1
101289: PPUSH
101290: LD_VAR 0 2
101294: PPUSH
101295: CALL_OW 308
101299: NOT
101300: AND
101301: IFFALSE 101305
// exit ;
101303: GO 101423
// if IsInArea ( unit , area ) then
101305: LD_VAR 0 1
101309: PPUSH
101310: LD_VAR 0 2
101314: PPUSH
101315: CALL_OW 308
101319: IFFALSE 101337
// begin ComMoveToArea ( unit , goAway ) ;
101321: LD_VAR 0 1
101325: PPUSH
101326: LD_VAR 0 3
101330: PPUSH
101331: CALL_OW 113
// exit ;
101335: GO 101423
// end ; if task [ 1 ] [ 1 ] <> M then
101337: LD_VAR 0 7
101341: PUSH
101342: LD_INT 1
101344: ARRAY
101345: PUSH
101346: LD_INT 1
101348: ARRAY
101349: PUSH
101350: LD_STRING M
101352: NONEQUAL
101353: IFFALSE 101357
// exit ;
101355: GO 101423
// x := task [ 1 ] [ 2 ] ;
101357: LD_ADDR_VAR 0 5
101361: PUSH
101362: LD_VAR 0 7
101366: PUSH
101367: LD_INT 1
101369: ARRAY
101370: PUSH
101371: LD_INT 2
101373: ARRAY
101374: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
101375: LD_ADDR_VAR 0 6
101379: PUSH
101380: LD_VAR 0 7
101384: PUSH
101385: LD_INT 1
101387: ARRAY
101388: PUSH
101389: LD_INT 3
101391: ARRAY
101392: ST_TO_ADDR
// if InArea ( x , y , area ) then
101393: LD_VAR 0 5
101397: PPUSH
101398: LD_VAR 0 6
101402: PPUSH
101403: LD_VAR 0 2
101407: PPUSH
101408: CALL_OW 309
101412: IFFALSE 101423
// ComStop ( unit ) ;
101414: LD_VAR 0 1
101418: PPUSH
101419: CALL_OW 141
// end ;
101423: LD_VAR 0 4
101427: RET
// export function Abs ( value ) ; begin
101428: LD_INT 0
101430: PPUSH
// result := value ;
101431: LD_ADDR_VAR 0 2
101435: PUSH
101436: LD_VAR 0 1
101440: ST_TO_ADDR
// if value < 0 then
101441: LD_VAR 0 1
101445: PUSH
101446: LD_INT 0
101448: LESS
101449: IFFALSE 101466
// result := value * - 1 ;
101451: LD_ADDR_VAR 0 2
101455: PUSH
101456: LD_VAR 0 1
101460: PUSH
101461: LD_INT 1
101463: NEG
101464: MUL
101465: ST_TO_ADDR
// end ;
101466: LD_VAR 0 2
101470: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
101471: LD_INT 0
101473: PPUSH
101474: PPUSH
101475: PPUSH
101476: PPUSH
101477: PPUSH
101478: PPUSH
101479: PPUSH
101480: PPUSH
// if not unit or not building then
101481: LD_VAR 0 1
101485: NOT
101486: PUSH
101487: LD_VAR 0 2
101491: NOT
101492: OR
101493: IFFALSE 101497
// exit ;
101495: GO 101723
// x := GetX ( building ) ;
101497: LD_ADDR_VAR 0 4
101501: PUSH
101502: LD_VAR 0 2
101506: PPUSH
101507: CALL_OW 250
101511: ST_TO_ADDR
// y := GetY ( building ) ;
101512: LD_ADDR_VAR 0 6
101516: PUSH
101517: LD_VAR 0 2
101521: PPUSH
101522: CALL_OW 251
101526: ST_TO_ADDR
// d := GetDir ( building ) ;
101527: LD_ADDR_VAR 0 8
101531: PUSH
101532: LD_VAR 0 2
101536: PPUSH
101537: CALL_OW 254
101541: ST_TO_ADDR
// r := 4 ;
101542: LD_ADDR_VAR 0 9
101546: PUSH
101547: LD_INT 4
101549: ST_TO_ADDR
// for i := 1 to 5 do
101550: LD_ADDR_VAR 0 10
101554: PUSH
101555: DOUBLE
101556: LD_INT 1
101558: DEC
101559: ST_TO_ADDR
101560: LD_INT 5
101562: PUSH
101563: FOR_TO
101564: IFFALSE 101721
// begin _x := ShiftX ( x , d , r + i ) ;
101566: LD_ADDR_VAR 0 5
101570: PUSH
101571: LD_VAR 0 4
101575: PPUSH
101576: LD_VAR 0 8
101580: PPUSH
101581: LD_VAR 0 9
101585: PUSH
101586: LD_VAR 0 10
101590: PLUS
101591: PPUSH
101592: CALL_OW 272
101596: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
101597: LD_ADDR_VAR 0 7
101601: PUSH
101602: LD_VAR 0 6
101606: PPUSH
101607: LD_VAR 0 8
101611: PPUSH
101612: LD_VAR 0 9
101616: PUSH
101617: LD_VAR 0 10
101621: PLUS
101622: PPUSH
101623: CALL_OW 273
101627: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
101628: LD_VAR 0 5
101632: PPUSH
101633: LD_VAR 0 7
101637: PPUSH
101638: CALL_OW 488
101642: PUSH
101643: LD_VAR 0 5
101647: PPUSH
101648: LD_VAR 0 7
101652: PPUSH
101653: CALL_OW 428
101657: PPUSH
101658: CALL_OW 247
101662: PUSH
101663: LD_INT 3
101665: PUSH
101666: LD_INT 2
101668: PUSH
101669: EMPTY
101670: LIST
101671: LIST
101672: IN
101673: NOT
101674: AND
101675: IFFALSE 101719
// begin ComMoveXY ( unit , _x , _y ) ;
101677: LD_VAR 0 1
101681: PPUSH
101682: LD_VAR 0 5
101686: PPUSH
101687: LD_VAR 0 7
101691: PPUSH
101692: CALL_OW 111
// result := [ _x , _y ] ;
101696: LD_ADDR_VAR 0 3
101700: PUSH
101701: LD_VAR 0 5
101705: PUSH
101706: LD_VAR 0 7
101710: PUSH
101711: EMPTY
101712: LIST
101713: LIST
101714: ST_TO_ADDR
// exit ;
101715: POP
101716: POP
101717: GO 101723
// end ; end ;
101719: GO 101563
101721: POP
101722: POP
// end ;
101723: LD_VAR 0 3
101727: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
101728: LD_INT 0
101730: PPUSH
101731: PPUSH
101732: PPUSH
// result := 0 ;
101733: LD_ADDR_VAR 0 3
101737: PUSH
101738: LD_INT 0
101740: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
101741: LD_VAR 0 1
101745: PUSH
101746: LD_INT 0
101748: LESS
101749: PUSH
101750: LD_VAR 0 1
101754: PUSH
101755: LD_INT 8
101757: GREATER
101758: OR
101759: PUSH
101760: LD_VAR 0 2
101764: PUSH
101765: LD_INT 0
101767: LESS
101768: OR
101769: PUSH
101770: LD_VAR 0 2
101774: PUSH
101775: LD_INT 8
101777: GREATER
101778: OR
101779: IFFALSE 101783
// exit ;
101781: GO 101858
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
101783: LD_ADDR_VAR 0 4
101787: PUSH
101788: LD_INT 22
101790: PUSH
101791: LD_VAR 0 2
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: PPUSH
101800: CALL_OW 69
101804: PUSH
101805: FOR_IN
101806: IFFALSE 101856
// begin un := UnitShoot ( i ) ;
101808: LD_ADDR_VAR 0 5
101812: PUSH
101813: LD_VAR 0 4
101817: PPUSH
101818: CALL_OW 504
101822: ST_TO_ADDR
// if GetSide ( un ) = side1 then
101823: LD_VAR 0 5
101827: PPUSH
101828: CALL_OW 255
101832: PUSH
101833: LD_VAR 0 1
101837: EQUAL
101838: IFFALSE 101854
// begin result := un ;
101840: LD_ADDR_VAR 0 3
101844: PUSH
101845: LD_VAR 0 5
101849: ST_TO_ADDR
// exit ;
101850: POP
101851: POP
101852: GO 101858
// end ; end ;
101854: GO 101805
101856: POP
101857: POP
// end ;
101858: LD_VAR 0 3
101862: RET
// export function GetCargoBay ( units ) ; begin
101863: LD_INT 0
101865: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
101866: LD_ADDR_VAR 0 2
101870: PUSH
101871: LD_VAR 0 1
101875: PPUSH
101876: LD_INT 2
101878: PUSH
101879: LD_INT 34
101881: PUSH
101882: LD_INT 12
101884: PUSH
101885: EMPTY
101886: LIST
101887: LIST
101888: PUSH
101889: LD_INT 34
101891: PUSH
101892: LD_INT 51
101894: PUSH
101895: EMPTY
101896: LIST
101897: LIST
101898: PUSH
101899: LD_INT 34
101901: PUSH
101902: LD_INT 32
101904: PUSH
101905: EMPTY
101906: LIST
101907: LIST
101908: PUSH
101909: LD_INT 34
101911: PUSH
101912: LD_INT 89
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: EMPTY
101920: LIST
101921: LIST
101922: LIST
101923: LIST
101924: LIST
101925: PPUSH
101926: CALL_OW 72
101930: ST_TO_ADDR
// end ;
101931: LD_VAR 0 2
101935: RET
// export function Negate ( value ) ; begin
101936: LD_INT 0
101938: PPUSH
// result := not value ;
101939: LD_ADDR_VAR 0 2
101943: PUSH
101944: LD_VAR 0 1
101948: NOT
101949: ST_TO_ADDR
// end ;
101950: LD_VAR 0 2
101954: RET
// export function Inc ( value ) ; begin
101955: LD_INT 0
101957: PPUSH
// result := value + 1 ;
101958: LD_ADDR_VAR 0 2
101962: PUSH
101963: LD_VAR 0 1
101967: PUSH
101968: LD_INT 1
101970: PLUS
101971: ST_TO_ADDR
// end ;
101972: LD_VAR 0 2
101976: RET
// export function Dec ( value ) ; begin
101977: LD_INT 0
101979: PPUSH
// result := value - 1 ;
101980: LD_ADDR_VAR 0 2
101984: PUSH
101985: LD_VAR 0 1
101989: PUSH
101990: LD_INT 1
101992: MINUS
101993: ST_TO_ADDR
// end ;
101994: LD_VAR 0 2
101998: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
101999: LD_INT 0
102001: PPUSH
102002: PPUSH
102003: PPUSH
102004: PPUSH
102005: PPUSH
102006: PPUSH
102007: PPUSH
102008: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
102009: LD_VAR 0 1
102013: PPUSH
102014: LD_VAR 0 2
102018: PPUSH
102019: CALL_OW 488
102023: NOT
102024: PUSH
102025: LD_VAR 0 3
102029: PPUSH
102030: LD_VAR 0 4
102034: PPUSH
102035: CALL_OW 488
102039: NOT
102040: OR
102041: IFFALSE 102054
// begin result := - 1 ;
102043: LD_ADDR_VAR 0 5
102047: PUSH
102048: LD_INT 1
102050: NEG
102051: ST_TO_ADDR
// exit ;
102052: GO 102289
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
102054: LD_ADDR_VAR 0 12
102058: PUSH
102059: LD_VAR 0 1
102063: PPUSH
102064: LD_VAR 0 2
102068: PPUSH
102069: LD_VAR 0 3
102073: PPUSH
102074: LD_VAR 0 4
102078: PPUSH
102079: CALL 101139 0 4
102083: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
102084: LD_ADDR_VAR 0 11
102088: PUSH
102089: LD_VAR 0 1
102093: PPUSH
102094: LD_VAR 0 2
102098: PPUSH
102099: LD_VAR 0 12
102103: PUSH
102104: LD_INT 1
102106: ARRAY
102107: PPUSH
102108: LD_VAR 0 12
102112: PUSH
102113: LD_INT 2
102115: ARRAY
102116: PPUSH
102117: CALL_OW 298
102121: ST_TO_ADDR
// distance := 9999 ;
102122: LD_ADDR_VAR 0 10
102126: PUSH
102127: LD_INT 9999
102129: ST_TO_ADDR
// for i := 0 to 5 do
102130: LD_ADDR_VAR 0 6
102134: PUSH
102135: DOUBLE
102136: LD_INT 0
102138: DEC
102139: ST_TO_ADDR
102140: LD_INT 5
102142: PUSH
102143: FOR_TO
102144: IFFALSE 102287
// begin _x := ShiftX ( x1 , i , centerDist ) ;
102146: LD_ADDR_VAR 0 7
102150: PUSH
102151: LD_VAR 0 1
102155: PPUSH
102156: LD_VAR 0 6
102160: PPUSH
102161: LD_VAR 0 11
102165: PPUSH
102166: CALL_OW 272
102170: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
102171: LD_ADDR_VAR 0 8
102175: PUSH
102176: LD_VAR 0 2
102180: PPUSH
102181: LD_VAR 0 6
102185: PPUSH
102186: LD_VAR 0 11
102190: PPUSH
102191: CALL_OW 273
102195: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102196: LD_VAR 0 7
102200: PPUSH
102201: LD_VAR 0 8
102205: PPUSH
102206: CALL_OW 488
102210: NOT
102211: IFFALSE 102215
// continue ;
102213: GO 102143
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
102215: LD_ADDR_VAR 0 9
102219: PUSH
102220: LD_VAR 0 12
102224: PUSH
102225: LD_INT 1
102227: ARRAY
102228: PPUSH
102229: LD_VAR 0 12
102233: PUSH
102234: LD_INT 2
102236: ARRAY
102237: PPUSH
102238: LD_VAR 0 7
102242: PPUSH
102243: LD_VAR 0 8
102247: PPUSH
102248: CALL_OW 298
102252: ST_TO_ADDR
// if tmp < distance then
102253: LD_VAR 0 9
102257: PUSH
102258: LD_VAR 0 10
102262: LESS
102263: IFFALSE 102285
// begin result := i ;
102265: LD_ADDR_VAR 0 5
102269: PUSH
102270: LD_VAR 0 6
102274: ST_TO_ADDR
// distance := tmp ;
102275: LD_ADDR_VAR 0 10
102279: PUSH
102280: LD_VAR 0 9
102284: ST_TO_ADDR
// end ; end ;
102285: GO 102143
102287: POP
102288: POP
// end ;
102289: LD_VAR 0 5
102293: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102294: LD_INT 0
102296: PPUSH
102297: PPUSH
// if not driver or not IsInUnit ( driver ) then
102298: LD_VAR 0 1
102302: NOT
102303: PUSH
102304: LD_VAR 0 1
102308: PPUSH
102309: CALL_OW 310
102313: NOT
102314: OR
102315: IFFALSE 102319
// exit ;
102317: GO 102409
// vehicle := IsInUnit ( driver ) ;
102319: LD_ADDR_VAR 0 3
102323: PUSH
102324: LD_VAR 0 1
102328: PPUSH
102329: CALL_OW 310
102333: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102334: LD_VAR 0 1
102338: PPUSH
102339: LD_STRING \
102341: PUSH
102342: LD_INT 0
102344: PUSH
102345: LD_INT 0
102347: PUSH
102348: LD_INT 0
102350: PUSH
102351: LD_INT 0
102353: PUSH
102354: LD_INT 0
102356: PUSH
102357: LD_INT 0
102359: PUSH
102360: EMPTY
102361: LIST
102362: LIST
102363: LIST
102364: LIST
102365: LIST
102366: LIST
102367: LIST
102368: PUSH
102369: LD_STRING E
102371: PUSH
102372: LD_INT 0
102374: PUSH
102375: LD_INT 0
102377: PUSH
102378: LD_VAR 0 3
102382: PUSH
102383: LD_INT 0
102385: PUSH
102386: LD_INT 0
102388: PUSH
102389: LD_INT 0
102391: PUSH
102392: EMPTY
102393: LIST
102394: LIST
102395: LIST
102396: LIST
102397: LIST
102398: LIST
102399: LIST
102400: PUSH
102401: EMPTY
102402: LIST
102403: LIST
102404: PPUSH
102405: CALL_OW 446
// end ;
102409: LD_VAR 0 2
102413: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
102414: LD_INT 0
102416: PPUSH
102417: PPUSH
// if not driver or not IsInUnit ( driver ) then
102418: LD_VAR 0 1
102422: NOT
102423: PUSH
102424: LD_VAR 0 1
102428: PPUSH
102429: CALL_OW 310
102433: NOT
102434: OR
102435: IFFALSE 102439
// exit ;
102437: GO 102529
// vehicle := IsInUnit ( driver ) ;
102439: LD_ADDR_VAR 0 3
102443: PUSH
102444: LD_VAR 0 1
102448: PPUSH
102449: CALL_OW 310
102453: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
102454: LD_VAR 0 1
102458: PPUSH
102459: LD_STRING \
102461: PUSH
102462: LD_INT 0
102464: PUSH
102465: LD_INT 0
102467: PUSH
102468: LD_INT 0
102470: PUSH
102471: LD_INT 0
102473: PUSH
102474: LD_INT 0
102476: PUSH
102477: LD_INT 0
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: LIST
102484: LIST
102485: LIST
102486: LIST
102487: LIST
102488: PUSH
102489: LD_STRING E
102491: PUSH
102492: LD_INT 0
102494: PUSH
102495: LD_INT 0
102497: PUSH
102498: LD_VAR 0 3
102502: PUSH
102503: LD_INT 0
102505: PUSH
102506: LD_INT 0
102508: PUSH
102509: LD_INT 0
102511: PUSH
102512: EMPTY
102513: LIST
102514: LIST
102515: LIST
102516: LIST
102517: LIST
102518: LIST
102519: LIST
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: PPUSH
102525: CALL_OW 447
// end ;
102529: LD_VAR 0 2
102533: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
102534: LD_INT 0
102536: PPUSH
102537: PPUSH
102538: PPUSH
// tmp := [ ] ;
102539: LD_ADDR_VAR 0 5
102543: PUSH
102544: EMPTY
102545: ST_TO_ADDR
// for i in units do
102546: LD_ADDR_VAR 0 4
102550: PUSH
102551: LD_VAR 0 1
102555: PUSH
102556: FOR_IN
102557: IFFALSE 102595
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
102559: LD_ADDR_VAR 0 5
102563: PUSH
102564: LD_VAR 0 5
102568: PPUSH
102569: LD_VAR 0 5
102573: PUSH
102574: LD_INT 1
102576: PLUS
102577: PPUSH
102578: LD_VAR 0 4
102582: PPUSH
102583: CALL_OW 256
102587: PPUSH
102588: CALL_OW 2
102592: ST_TO_ADDR
102593: GO 102556
102595: POP
102596: POP
// if not tmp then
102597: LD_VAR 0 5
102601: NOT
102602: IFFALSE 102606
// exit ;
102604: GO 102654
// if asc then
102606: LD_VAR 0 2
102610: IFFALSE 102634
// result := SortListByListAsc ( units , tmp ) else
102612: LD_ADDR_VAR 0 3
102616: PUSH
102617: LD_VAR 0 1
102621: PPUSH
102622: LD_VAR 0 5
102626: PPUSH
102627: CALL_OW 76
102631: ST_TO_ADDR
102632: GO 102654
// result := SortListByListDesc ( units , tmp ) ;
102634: LD_ADDR_VAR 0 3
102638: PUSH
102639: LD_VAR 0 1
102643: PPUSH
102644: LD_VAR 0 5
102648: PPUSH
102649: CALL_OW 77
102653: ST_TO_ADDR
// end ;
102654: LD_VAR 0 3
102658: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
102659: LD_INT 0
102661: PPUSH
102662: PPUSH
// task := GetTaskList ( mech ) ;
102663: LD_ADDR_VAR 0 4
102667: PUSH
102668: LD_VAR 0 1
102672: PPUSH
102673: CALL_OW 437
102677: ST_TO_ADDR
// if not task then
102678: LD_VAR 0 4
102682: NOT
102683: IFFALSE 102687
// exit ;
102685: GO 102729
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
102687: LD_ADDR_VAR 0 3
102691: PUSH
102692: LD_VAR 0 4
102696: PUSH
102697: LD_INT 1
102699: ARRAY
102700: PUSH
102701: LD_INT 1
102703: ARRAY
102704: PUSH
102705: LD_STRING r
102707: EQUAL
102708: PUSH
102709: LD_VAR 0 4
102713: PUSH
102714: LD_INT 1
102716: ARRAY
102717: PUSH
102718: LD_INT 4
102720: ARRAY
102721: PUSH
102722: LD_VAR 0 2
102726: EQUAL
102727: AND
102728: ST_TO_ADDR
// end ;
102729: LD_VAR 0 3
102733: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
102734: LD_INT 0
102736: PPUSH
// SetDir ( unit , d ) ;
102737: LD_VAR 0 1
102741: PPUSH
102742: LD_VAR 0 4
102746: PPUSH
102747: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
102751: LD_VAR 0 1
102755: PPUSH
102756: LD_VAR 0 2
102760: PPUSH
102761: LD_VAR 0 3
102765: PPUSH
102766: LD_VAR 0 5
102770: PPUSH
102771: CALL_OW 48
// end ;
102775: LD_VAR 0 6
102779: RET
// export function ToNaturalNumber ( number ) ; begin
102780: LD_INT 0
102782: PPUSH
// result := number div 1 ;
102783: LD_ADDR_VAR 0 2
102787: PUSH
102788: LD_VAR 0 1
102792: PUSH
102793: LD_INT 1
102795: DIV
102796: ST_TO_ADDR
// if number < 0 then
102797: LD_VAR 0 1
102801: PUSH
102802: LD_INT 0
102804: LESS
102805: IFFALSE 102815
// result := 0 ;
102807: LD_ADDR_VAR 0 2
102811: PUSH
102812: LD_INT 0
102814: ST_TO_ADDR
// end ;
102815: LD_VAR 0 2
102819: RET
// export function SortByClass ( units , class ) ; var un ; begin
102820: LD_INT 0
102822: PPUSH
102823: PPUSH
// if not units or not class then
102824: LD_VAR 0 1
102828: NOT
102829: PUSH
102830: LD_VAR 0 2
102834: NOT
102835: OR
102836: IFFALSE 102840
// exit ;
102838: GO 102935
// result := [ ] ;
102840: LD_ADDR_VAR 0 3
102844: PUSH
102845: EMPTY
102846: ST_TO_ADDR
// for un in units do
102847: LD_ADDR_VAR 0 4
102851: PUSH
102852: LD_VAR 0 1
102856: PUSH
102857: FOR_IN
102858: IFFALSE 102933
// if GetClass ( un ) = class then
102860: LD_VAR 0 4
102864: PPUSH
102865: CALL_OW 257
102869: PUSH
102870: LD_VAR 0 2
102874: EQUAL
102875: IFFALSE 102902
// result := Insert ( result , 1 , un ) else
102877: LD_ADDR_VAR 0 3
102881: PUSH
102882: LD_VAR 0 3
102886: PPUSH
102887: LD_INT 1
102889: PPUSH
102890: LD_VAR 0 4
102894: PPUSH
102895: CALL_OW 2
102899: ST_TO_ADDR
102900: GO 102931
// result := Replace ( result , result + 1 , un ) ;
102902: LD_ADDR_VAR 0 3
102906: PUSH
102907: LD_VAR 0 3
102911: PPUSH
102912: LD_VAR 0 3
102916: PUSH
102917: LD_INT 1
102919: PLUS
102920: PPUSH
102921: LD_VAR 0 4
102925: PPUSH
102926: CALL_OW 1
102930: ST_TO_ADDR
102931: GO 102857
102933: POP
102934: POP
// end ;
102935: LD_VAR 0 3
102939: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
102940: LD_INT 0
102942: PPUSH
102943: PPUSH
102944: PPUSH
102945: PPUSH
102946: PPUSH
102947: PPUSH
102948: PPUSH
// result := [ ] ;
102949: LD_ADDR_VAR 0 4
102953: PUSH
102954: EMPTY
102955: ST_TO_ADDR
// if x - r < 0 then
102956: LD_VAR 0 1
102960: PUSH
102961: LD_VAR 0 3
102965: MINUS
102966: PUSH
102967: LD_INT 0
102969: LESS
102970: IFFALSE 102982
// min_x := 0 else
102972: LD_ADDR_VAR 0 8
102976: PUSH
102977: LD_INT 0
102979: ST_TO_ADDR
102980: GO 102998
// min_x := x - r ;
102982: LD_ADDR_VAR 0 8
102986: PUSH
102987: LD_VAR 0 1
102991: PUSH
102992: LD_VAR 0 3
102996: MINUS
102997: ST_TO_ADDR
// if y - r < 0 then
102998: LD_VAR 0 2
103002: PUSH
103003: LD_VAR 0 3
103007: MINUS
103008: PUSH
103009: LD_INT 0
103011: LESS
103012: IFFALSE 103024
// min_y := 0 else
103014: LD_ADDR_VAR 0 7
103018: PUSH
103019: LD_INT 0
103021: ST_TO_ADDR
103022: GO 103040
// min_y := y - r ;
103024: LD_ADDR_VAR 0 7
103028: PUSH
103029: LD_VAR 0 2
103033: PUSH
103034: LD_VAR 0 3
103038: MINUS
103039: ST_TO_ADDR
// max_x := x + r ;
103040: LD_ADDR_VAR 0 9
103044: PUSH
103045: LD_VAR 0 1
103049: PUSH
103050: LD_VAR 0 3
103054: PLUS
103055: ST_TO_ADDR
// max_y := y + r ;
103056: LD_ADDR_VAR 0 10
103060: PUSH
103061: LD_VAR 0 2
103065: PUSH
103066: LD_VAR 0 3
103070: PLUS
103071: ST_TO_ADDR
// for _x = min_x to max_x do
103072: LD_ADDR_VAR 0 5
103076: PUSH
103077: DOUBLE
103078: LD_VAR 0 8
103082: DEC
103083: ST_TO_ADDR
103084: LD_VAR 0 9
103088: PUSH
103089: FOR_TO
103090: IFFALSE 103191
// for _y = min_y to max_y do
103092: LD_ADDR_VAR 0 6
103096: PUSH
103097: DOUBLE
103098: LD_VAR 0 7
103102: DEC
103103: ST_TO_ADDR
103104: LD_VAR 0 10
103108: PUSH
103109: FOR_TO
103110: IFFALSE 103187
// begin if not ValidHex ( _x , _y ) then
103112: LD_VAR 0 5
103116: PPUSH
103117: LD_VAR 0 6
103121: PPUSH
103122: CALL_OW 488
103126: NOT
103127: IFFALSE 103131
// continue ;
103129: GO 103109
// if GetResourceTypeXY ( _x , _y ) then
103131: LD_VAR 0 5
103135: PPUSH
103136: LD_VAR 0 6
103140: PPUSH
103141: CALL_OW 283
103145: IFFALSE 103185
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
103147: LD_ADDR_VAR 0 4
103151: PUSH
103152: LD_VAR 0 4
103156: PPUSH
103157: LD_VAR 0 4
103161: PUSH
103162: LD_INT 1
103164: PLUS
103165: PPUSH
103166: LD_VAR 0 5
103170: PUSH
103171: LD_VAR 0 6
103175: PUSH
103176: EMPTY
103177: LIST
103178: LIST
103179: PPUSH
103180: CALL_OW 1
103184: ST_TO_ADDR
// end ;
103185: GO 103109
103187: POP
103188: POP
103189: GO 103089
103191: POP
103192: POP
// end ;
103193: LD_VAR 0 4
103197: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
103198: LD_INT 0
103200: PPUSH
103201: PPUSH
103202: PPUSH
103203: PPUSH
103204: PPUSH
103205: PPUSH
103206: PPUSH
103207: PPUSH
// if not units then
103208: LD_VAR 0 1
103212: NOT
103213: IFFALSE 103217
// exit ;
103215: GO 103741
// result := UnitFilter ( units , [ f_ok ] ) ;
103217: LD_ADDR_VAR 0 3
103221: PUSH
103222: LD_VAR 0 1
103226: PPUSH
103227: LD_INT 50
103229: PUSH
103230: EMPTY
103231: LIST
103232: PPUSH
103233: CALL_OW 72
103237: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
103238: LD_ADDR_VAR 0 8
103242: PUSH
103243: LD_VAR 0 1
103247: PUSH
103248: LD_INT 1
103250: ARRAY
103251: PPUSH
103252: CALL_OW 255
103256: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
103257: LD_ADDR_VAR 0 10
103261: PUSH
103262: LD_INT 29
103264: PUSH
103265: LD_INT 91
103267: PUSH
103268: LD_INT 49
103270: PUSH
103271: EMPTY
103272: LIST
103273: LIST
103274: LIST
103275: ST_TO_ADDR
// if not result then
103276: LD_VAR 0 3
103280: NOT
103281: IFFALSE 103285
// exit ;
103283: GO 103741
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
103285: LD_ADDR_VAR 0 5
103289: PUSH
103290: LD_INT 81
103292: PUSH
103293: LD_VAR 0 8
103297: PUSH
103298: EMPTY
103299: LIST
103300: LIST
103301: PPUSH
103302: CALL_OW 69
103306: ST_TO_ADDR
// for i in result do
103307: LD_ADDR_VAR 0 4
103311: PUSH
103312: LD_VAR 0 3
103316: PUSH
103317: FOR_IN
103318: IFFALSE 103739
// begin tag := GetTag ( i ) + 1 ;
103320: LD_ADDR_VAR 0 9
103324: PUSH
103325: LD_VAR 0 4
103329: PPUSH
103330: CALL_OW 110
103334: PUSH
103335: LD_INT 1
103337: PLUS
103338: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
103339: LD_ADDR_VAR 0 7
103343: PUSH
103344: LD_VAR 0 4
103348: PPUSH
103349: CALL_OW 250
103353: PPUSH
103354: LD_VAR 0 4
103358: PPUSH
103359: CALL_OW 251
103363: PPUSH
103364: LD_INT 6
103366: PPUSH
103367: CALL 102940 0 3
103371: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
103372: LD_VAR 0 4
103376: PPUSH
103377: CALL_OW 247
103381: PUSH
103382: LD_INT 2
103384: EQUAL
103385: PUSH
103386: LD_VAR 0 7
103390: AND
103391: PUSH
103392: LD_VAR 0 4
103396: PPUSH
103397: CALL_OW 264
103401: PUSH
103402: LD_VAR 0 10
103406: IN
103407: NOT
103408: AND
103409: IFFALSE 103448
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
103411: LD_VAR 0 4
103415: PPUSH
103416: LD_VAR 0 7
103420: PUSH
103421: LD_INT 1
103423: ARRAY
103424: PUSH
103425: LD_INT 1
103427: ARRAY
103428: PPUSH
103429: LD_VAR 0 7
103433: PUSH
103434: LD_INT 1
103436: ARRAY
103437: PUSH
103438: LD_INT 2
103440: ARRAY
103441: PPUSH
103442: CALL_OW 116
103446: GO 103737
// if path > tag then
103448: LD_VAR 0 2
103452: PUSH
103453: LD_VAR 0 9
103457: GREATER
103458: IFFALSE 103666
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
103460: LD_ADDR_VAR 0 6
103464: PUSH
103465: LD_VAR 0 5
103469: PPUSH
103470: LD_INT 91
103472: PUSH
103473: LD_VAR 0 4
103477: PUSH
103478: LD_INT 8
103480: PUSH
103481: EMPTY
103482: LIST
103483: LIST
103484: LIST
103485: PPUSH
103486: CALL_OW 72
103490: ST_TO_ADDR
// if nearEnemy then
103491: LD_VAR 0 6
103495: IFFALSE 103564
// begin if GetWeapon ( i ) = ru_time_lapser then
103497: LD_VAR 0 4
103501: PPUSH
103502: CALL_OW 264
103506: PUSH
103507: LD_INT 49
103509: EQUAL
103510: IFFALSE 103538
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
103512: LD_VAR 0 4
103516: PPUSH
103517: LD_VAR 0 6
103521: PPUSH
103522: LD_VAR 0 4
103526: PPUSH
103527: CALL_OW 74
103531: PPUSH
103532: CALL_OW 112
103536: GO 103562
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
103538: LD_VAR 0 4
103542: PPUSH
103543: LD_VAR 0 6
103547: PPUSH
103548: LD_VAR 0 4
103552: PPUSH
103553: CALL_OW 74
103557: PPUSH
103558: CALL_OW 115
// end else
103562: GO 103664
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
103564: LD_VAR 0 4
103568: PPUSH
103569: LD_VAR 0 2
103573: PUSH
103574: LD_VAR 0 9
103578: ARRAY
103579: PUSH
103580: LD_INT 1
103582: ARRAY
103583: PPUSH
103584: LD_VAR 0 2
103588: PUSH
103589: LD_VAR 0 9
103593: ARRAY
103594: PUSH
103595: LD_INT 2
103597: ARRAY
103598: PPUSH
103599: CALL_OW 297
103603: PUSH
103604: LD_INT 6
103606: GREATER
103607: IFFALSE 103650
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
103609: LD_VAR 0 4
103613: PPUSH
103614: LD_VAR 0 2
103618: PUSH
103619: LD_VAR 0 9
103623: ARRAY
103624: PUSH
103625: LD_INT 1
103627: ARRAY
103628: PPUSH
103629: LD_VAR 0 2
103633: PUSH
103634: LD_VAR 0 9
103638: ARRAY
103639: PUSH
103640: LD_INT 2
103642: ARRAY
103643: PPUSH
103644: CALL_OW 114
103648: GO 103664
// SetTag ( i , tag ) ;
103650: LD_VAR 0 4
103654: PPUSH
103655: LD_VAR 0 9
103659: PPUSH
103660: CALL_OW 109
// end else
103664: GO 103737
// if enemy then
103666: LD_VAR 0 5
103670: IFFALSE 103737
// begin if GetWeapon ( i ) = ru_time_lapser then
103672: LD_VAR 0 4
103676: PPUSH
103677: CALL_OW 264
103681: PUSH
103682: LD_INT 49
103684: EQUAL
103685: IFFALSE 103713
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103687: LD_VAR 0 4
103691: PPUSH
103692: LD_VAR 0 5
103696: PPUSH
103697: LD_VAR 0 4
103701: PPUSH
103702: CALL_OW 74
103706: PPUSH
103707: CALL_OW 112
103711: GO 103737
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
103713: LD_VAR 0 4
103717: PPUSH
103718: LD_VAR 0 5
103722: PPUSH
103723: LD_VAR 0 4
103727: PPUSH
103728: CALL_OW 74
103732: PPUSH
103733: CALL_OW 115
// end ; end ;
103737: GO 103317
103739: POP
103740: POP
// end ;
103741: LD_VAR 0 3
103745: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
103746: LD_INT 0
103748: PPUSH
103749: PPUSH
103750: PPUSH
// if not unit or IsInUnit ( unit ) then
103751: LD_VAR 0 1
103755: NOT
103756: PUSH
103757: LD_VAR 0 1
103761: PPUSH
103762: CALL_OW 310
103766: OR
103767: IFFALSE 103771
// exit ;
103769: GO 103862
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
103771: LD_ADDR_VAR 0 4
103775: PUSH
103776: LD_VAR 0 1
103780: PPUSH
103781: CALL_OW 250
103785: PPUSH
103786: LD_VAR 0 2
103790: PPUSH
103791: LD_INT 1
103793: PPUSH
103794: CALL_OW 272
103798: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
103799: LD_ADDR_VAR 0 5
103803: PUSH
103804: LD_VAR 0 1
103808: PPUSH
103809: CALL_OW 251
103813: PPUSH
103814: LD_VAR 0 2
103818: PPUSH
103819: LD_INT 1
103821: PPUSH
103822: CALL_OW 273
103826: ST_TO_ADDR
// if ValidHex ( x , y ) then
103827: LD_VAR 0 4
103831: PPUSH
103832: LD_VAR 0 5
103836: PPUSH
103837: CALL_OW 488
103841: IFFALSE 103862
// ComTurnXY ( unit , x , y ) ;
103843: LD_VAR 0 1
103847: PPUSH
103848: LD_VAR 0 4
103852: PPUSH
103853: LD_VAR 0 5
103857: PPUSH
103858: CALL_OW 118
// end ;
103862: LD_VAR 0 3
103866: RET
// export function SeeUnits ( side , units ) ; var i ; begin
103867: LD_INT 0
103869: PPUSH
103870: PPUSH
// result := false ;
103871: LD_ADDR_VAR 0 3
103875: PUSH
103876: LD_INT 0
103878: ST_TO_ADDR
// if not units then
103879: LD_VAR 0 2
103883: NOT
103884: IFFALSE 103888
// exit ;
103886: GO 103933
// for i in units do
103888: LD_ADDR_VAR 0 4
103892: PUSH
103893: LD_VAR 0 2
103897: PUSH
103898: FOR_IN
103899: IFFALSE 103931
// if See ( side , i ) then
103901: LD_VAR 0 1
103905: PPUSH
103906: LD_VAR 0 4
103910: PPUSH
103911: CALL_OW 292
103915: IFFALSE 103929
// begin result := true ;
103917: LD_ADDR_VAR 0 3
103921: PUSH
103922: LD_INT 1
103924: ST_TO_ADDR
// exit ;
103925: POP
103926: POP
103927: GO 103933
// end ;
103929: GO 103898
103931: POP
103932: POP
// end ;
103933: LD_VAR 0 3
103937: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
103938: LD_INT 0
103940: PPUSH
103941: PPUSH
103942: PPUSH
103943: PPUSH
// if not unit or not points then
103944: LD_VAR 0 1
103948: NOT
103949: PUSH
103950: LD_VAR 0 2
103954: NOT
103955: OR
103956: IFFALSE 103960
// exit ;
103958: GO 104050
// dist := 99999 ;
103960: LD_ADDR_VAR 0 5
103964: PUSH
103965: LD_INT 99999
103967: ST_TO_ADDR
// for i in points do
103968: LD_ADDR_VAR 0 4
103972: PUSH
103973: LD_VAR 0 2
103977: PUSH
103978: FOR_IN
103979: IFFALSE 104048
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
103981: LD_ADDR_VAR 0 6
103985: PUSH
103986: LD_VAR 0 1
103990: PPUSH
103991: LD_VAR 0 4
103995: PUSH
103996: LD_INT 1
103998: ARRAY
103999: PPUSH
104000: LD_VAR 0 4
104004: PUSH
104005: LD_INT 2
104007: ARRAY
104008: PPUSH
104009: CALL_OW 297
104013: ST_TO_ADDR
// if tmpDist < dist then
104014: LD_VAR 0 6
104018: PUSH
104019: LD_VAR 0 5
104023: LESS
104024: IFFALSE 104046
// begin result := i ;
104026: LD_ADDR_VAR 0 3
104030: PUSH
104031: LD_VAR 0 4
104035: ST_TO_ADDR
// dist := tmpDist ;
104036: LD_ADDR_VAR 0 5
104040: PUSH
104041: LD_VAR 0 6
104045: ST_TO_ADDR
// end ; end ;
104046: GO 103978
104048: POP
104049: POP
// end ;
104050: LD_VAR 0 3
104054: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
104055: LD_INT 0
104057: PPUSH
// uc_side := side ;
104058: LD_ADDR_OWVAR 20
104062: PUSH
104063: LD_VAR 0 1
104067: ST_TO_ADDR
// uc_nation := 3 ;
104068: LD_ADDR_OWVAR 21
104072: PUSH
104073: LD_INT 3
104075: ST_TO_ADDR
// vc_chassis := 25 ;
104076: LD_ADDR_OWVAR 37
104080: PUSH
104081: LD_INT 25
104083: ST_TO_ADDR
// vc_engine := engine_siberite ;
104084: LD_ADDR_OWVAR 39
104088: PUSH
104089: LD_INT 3
104091: ST_TO_ADDR
// vc_control := control_computer ;
104092: LD_ADDR_OWVAR 38
104096: PUSH
104097: LD_INT 3
104099: ST_TO_ADDR
// vc_weapon := 59 ;
104100: LD_ADDR_OWVAR 40
104104: PUSH
104105: LD_INT 59
104107: ST_TO_ADDR
// result := CreateVehicle ;
104108: LD_ADDR_VAR 0 5
104112: PUSH
104113: CALL_OW 45
104117: ST_TO_ADDR
// SetDir ( result , d ) ;
104118: LD_VAR 0 5
104122: PPUSH
104123: LD_VAR 0 4
104127: PPUSH
104128: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
104132: LD_VAR 0 5
104136: PPUSH
104137: LD_VAR 0 2
104141: PPUSH
104142: LD_VAR 0 3
104146: PPUSH
104147: LD_INT 0
104149: PPUSH
104150: CALL_OW 48
// end ;
104154: LD_VAR 0 5
104158: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
104159: LD_INT 0
104161: PPUSH
104162: PPUSH
104163: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
104164: LD_ADDR_VAR 0 2
104168: PUSH
104169: LD_INT 0
104171: PUSH
104172: LD_INT 0
104174: PUSH
104175: LD_INT 0
104177: PUSH
104178: LD_INT 0
104180: PUSH
104181: EMPTY
104182: LIST
104183: LIST
104184: LIST
104185: LIST
104186: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
104187: LD_VAR 0 1
104191: NOT
104192: PUSH
104193: LD_VAR 0 1
104197: PPUSH
104198: CALL_OW 264
104202: PUSH
104203: LD_INT 12
104205: PUSH
104206: LD_INT 51
104208: PUSH
104209: LD_INT 32
104211: PUSH
104212: LD_INT 89
104214: PUSH
104215: EMPTY
104216: LIST
104217: LIST
104218: LIST
104219: LIST
104220: IN
104221: NOT
104222: OR
104223: IFFALSE 104227
// exit ;
104225: GO 104325
// for i := 1 to 3 do
104227: LD_ADDR_VAR 0 3
104231: PUSH
104232: DOUBLE
104233: LD_INT 1
104235: DEC
104236: ST_TO_ADDR
104237: LD_INT 3
104239: PUSH
104240: FOR_TO
104241: IFFALSE 104323
// begin tmp := GetCargo ( cargo , i ) ;
104243: LD_ADDR_VAR 0 4
104247: PUSH
104248: LD_VAR 0 1
104252: PPUSH
104253: LD_VAR 0 3
104257: PPUSH
104258: CALL_OW 289
104262: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
104263: LD_ADDR_VAR 0 2
104267: PUSH
104268: LD_VAR 0 2
104272: PPUSH
104273: LD_VAR 0 3
104277: PPUSH
104278: LD_VAR 0 4
104282: PPUSH
104283: CALL_OW 1
104287: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
104288: LD_ADDR_VAR 0 2
104292: PUSH
104293: LD_VAR 0 2
104297: PPUSH
104298: LD_INT 4
104300: PPUSH
104301: LD_VAR 0 2
104305: PUSH
104306: LD_INT 4
104308: ARRAY
104309: PUSH
104310: LD_VAR 0 4
104314: PLUS
104315: PPUSH
104316: CALL_OW 1
104320: ST_TO_ADDR
// end ;
104321: GO 104240
104323: POP
104324: POP
// end ;
104325: LD_VAR 0 2
104329: RET
// export function Length ( array ) ; begin
104330: LD_INT 0
104332: PPUSH
// result := array + 0 ;
104333: LD_ADDR_VAR 0 2
104337: PUSH
104338: LD_VAR 0 1
104342: PUSH
104343: LD_INT 0
104345: PLUS
104346: ST_TO_ADDR
// end ;
104347: LD_VAR 0 2
104351: RET
// export function PrepareArray ( array ) ; begin
104352: LD_INT 0
104354: PPUSH
// result := array diff 0 ;
104355: LD_ADDR_VAR 0 2
104359: PUSH
104360: LD_VAR 0 1
104364: PUSH
104365: LD_INT 0
104367: DIFF
104368: ST_TO_ADDR
// if not result [ 1 ] then
104369: LD_VAR 0 2
104373: PUSH
104374: LD_INT 1
104376: ARRAY
104377: NOT
104378: IFFALSE 104398
// result := Delete ( result , 1 ) ;
104380: LD_ADDR_VAR 0 2
104384: PUSH
104385: LD_VAR 0 2
104389: PPUSH
104390: LD_INT 1
104392: PPUSH
104393: CALL_OW 3
104397: ST_TO_ADDR
// end ; end_of_file
104398: LD_VAR 0 2
104402: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
104403: LD_VAR 0 1
104407: PUSH
104408: LD_INT 200
104410: DOUBLE
104411: GREATEREQUAL
104412: IFFALSE 104420
104414: LD_INT 299
104416: DOUBLE
104417: LESSEQUAL
104418: IFTRUE 104422
104420: GO 104454
104422: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
104423: LD_VAR 0 1
104427: PPUSH
104428: LD_VAR 0 2
104432: PPUSH
104433: LD_VAR 0 3
104437: PPUSH
104438: LD_VAR 0 4
104442: PPUSH
104443: LD_VAR 0 5
104447: PPUSH
104448: CALL 59305 0 5
104452: GO 104531
104454: LD_INT 300
104456: DOUBLE
104457: GREATEREQUAL
104458: IFFALSE 104466
104460: LD_INT 399
104462: DOUBLE
104463: LESSEQUAL
104464: IFTRUE 104468
104466: GO 104530
104468: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
104469: LD_VAR 0 1
104473: PPUSH
104474: LD_VAR 0 2
104478: PPUSH
104479: LD_VAR 0 3
104483: PPUSH
104484: LD_VAR 0 4
104488: PPUSH
104489: LD_VAR 0 5
104493: PPUSH
104494: LD_VAR 0 6
104498: PPUSH
104499: LD_VAR 0 7
104503: PPUSH
104504: LD_VAR 0 8
104508: PPUSH
104509: LD_VAR 0 9
104513: PPUSH
104514: LD_VAR 0 10
104518: PPUSH
104519: LD_VAR 0 11
104523: PPUSH
104524: CALL 55638 0 11
104528: GO 104531
104530: POP
// end ;
104531: PPOPN 11
104533: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
104534: LD_VAR 0 1
104538: PPUSH
104539: LD_VAR 0 2
104543: PPUSH
104544: LD_VAR 0 3
104548: PPUSH
104549: LD_VAR 0 4
104553: PPUSH
104554: LD_VAR 0 5
104558: PPUSH
104559: CALL 59041 0 5
// end ; end_of_file
104563: PPOPN 5
104565: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
104566: LD_VAR 0 1
104570: PPUSH
104571: LD_VAR 0 2
104575: PPUSH
104576: LD_VAR 0 3
104580: PPUSH
104581: LD_VAR 0 4
104585: PPUSH
104586: LD_VAR 0 5
104590: PPUSH
104591: LD_VAR 0 6
104595: PPUSH
104596: CALL 43331 0 6
// end ;
104600: PPOPN 6
104602: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
104603: LD_INT 0
104605: PPUSH
// begin if not units then
104606: LD_VAR 0 1
104610: NOT
104611: IFFALSE 104615
// exit ;
104613: GO 104615
// end ;
104615: PPOPN 7
104617: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
104618: CALL 43302 0 0
// end ;
104622: PPOPN 1
104624: END
