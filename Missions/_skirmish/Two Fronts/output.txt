// starting begin isTest := false ;
   0: LD_ADDR_EXP 1
   4: PUSH
   5: LD_INT 0
   7: ST_TO_ADDR
// mission_name := TwoFronts ;
   8: LD_ADDR_OWVAR 68
  12: PUSH
  13: LD_STRING TwoFronts
  15: ST_TO_ADDR
// mission_number := 6 ;
  16: LD_ADDR_OWVAR 70
  20: PUSH
  21: LD_INT 6
  23: ST_TO_ADDR
// RandomizeAll ;
  24: CALL_OW 11
// ResetFog ;
  28: CALL_OW 335
// FogOff ( isTest ) ;
  32: LD_EXP 1
  36: PPUSH
  37: CALL_OW 344
// LogInit ( ) ;
  41: CALL 7640 0 0
// InitGlobalVar ;
  45: CALL 1546 0 0
// InitAction ;
  49: CALL 4617 0 0
// InitGame ;
  53: CALL 84 0 0
// MC_SetStrategy ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL 291 0 1
// MC_SetStrategy ( 4 ) ;
  64: LD_INT 4
  66: PPUSH
  67: CALL 291 0 1
// mc_game_live := 1 ;
  71: LD_ADDR_EXP 33
  75: PUSH
  76: LD_INT 1
  78: ST_TO_ADDR
// Dialog ;
  79: CALL 4916 0 0
// end ;
  83: END
// function InitGame ; begin
  84: LD_INT 0
  86: PPUSH
// Resources ( 5 , 0 , 2 , gaidar_base ) ;
  87: LD_INT 5
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 2
  95: PPUSH
  96: LD_INT 9
  98: PPUSH
  99: CALL 3008 0 4
// PrepareSquad ( 4 , 1 , houten_base , jakes , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 103: LD_INT 4
 105: PPUSH
 106: LD_INT 1
 108: PPUSH
 109: LD_INT 2
 111: PPUSH
 112: LD_STRING jakes
 114: PPUSH
 115: LD_INT 4
 117: PUSH
 118: LD_INT 5
 120: PUSH
 121: LD_INT 6
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 21
 137: PPUSH
 138: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , houten_base ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 3
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: LD_INT 2
 153: PPUSH
 154: CALL 3008 0 4
// PrepareSquad ( 1 , 1 , brown_base , sylvia , [ 4 , 5 , 6 ] [ Difficulty ] , 21 ) ;
 158: LD_INT 1
 160: PPUSH
 161: LD_INT 1
 163: PPUSH
 164: LD_INT 3
 166: PPUSH
 167: LD_STRING sylvia
 169: PPUSH
 170: LD_INT 4
 172: PUSH
 173: LD_INT 5
 175: PUSH
 176: LD_INT 6
 178: PUSH
 179: EMPTY
 180: LIST
 181: LIST
 182: LIST
 183: PUSH
 184: LD_OWVAR 67
 188: ARRAY
 189: PPUSH
 190: LD_INT 21
 192: PPUSH
 193: CALL 2635 0 6
// Resources ( 3 , 3 , 0 , brown_base ) ;
 197: LD_INT 3
 199: PPUSH
 200: LD_INT 3
 202: PPUSH
 203: LD_INT 0
 205: PPUSH
 206: LD_INT 3
 208: PPUSH
 209: CALL 3008 0 4
// MC_Registry ( ) ;
 213: CALL 41603 0 0
// MC_RegistryInit ( ) ;
 217: CALL 42054 0 0
// mc_crates_list := [ brown_crates , houten_crates , gaidar_crates ] ;
 221: LD_ADDR_EXP 34
 225: PUSH
 226: LD_INT 4
 228: PUSH
 229: LD_INT 5
 231: PUSH
 232: LD_INT 10
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// if Difficulty > 1 then
 240: LD_OWVAR 67
 244: PUSH
 245: LD_INT 1
 247: GREATER
 248: IFFALSE 263
// SetTech ( tech_comp2 , 8 , state_researched ) ;
 250: LD_INT 58
 252: PPUSH
 253: LD_INT 8
 255: PPUSH
 256: LD_INT 2
 258: PPUSH
 259: CALL_OW 322
// if Difficulty > 2 then
 263: LD_OWVAR 67
 267: PUSH
 268: LD_INT 2
 270: GREATER
 271: IFFALSE 286
// SetTech ( tech_comp3 , 8 , state_researched ) ;
 273: LD_INT 59
 275: PPUSH
 276: LD_INT 8
 278: PPUSH
 279: LD_INT 2
 281: PPUSH
 282: CALL_OW 322
// end ;
 286: LD_VAR 0 1
 290: RET
// function MC_SetStrategy ( side ) ; begin
 291: LD_INT 0
 293: PPUSH
// MCS_SetResourcesBonus ( 3500 , 500 , 0 ) ;
 294: LD_INT 3500
 296: PPUSH
 297: LD_INT 500
 299: PPUSH
 300: LD_INT 0
 302: PPUSH
 303: CALL 21371 0 3
// case side of 1 :
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 1
 314: DOUBLE
 315: EQUAL
 316: IFTRUE 320
 318: GO 923
 320: POP
// begin MCS_Collector ( 1 , 1 , [ brown_crates ] ) ;
 321: LD_INT 1
 323: PPUSH
 324: LD_INT 1
 326: PPUSH
 327: LD_INT 4
 329: PUSH
 330: EMPTY
 331: LIST
 332: PPUSH
 333: CALL 21307 0 3
// MCN_AddApes ( ape_north , 5 , 1 ) ;
 337: LD_INT 13
 339: PPUSH
 340: LD_INT 5
 342: PPUSH
 343: LD_INT 1
 345: PPUSH
 346: CALL 18300 0 3
// MCS_SetParking ( 1 , brown_parking ) ;
 350: LD_INT 1
 352: PPUSH
 353: LD_INT 6
 355: PPUSH
 356: CALL 21207 0 2
// MCT_CutTreeArea ( 1 , brown_tree ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 8
 365: PPUSH
 366: CALL 22221 0 2
// MCS_CreateDeposits ( 1 , [ 22 , 17 , 2 , 57 , 8 , 2 ] ) ;
 370: LD_INT 1
 372: PPUSH
 373: LD_INT 22
 375: PUSH
 376: LD_INT 17
 378: PUSH
 379: LD_INT 2
 381: PUSH
 382: LD_INT 57
 384: PUSH
 385: LD_INT 8
 387: PUSH
 388: LD_INT 2
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: LIST
 398: PPUSH
 399: CALL 21448 0 2
// MCS_ApeLimit ( 1 , 3 ) ;
 403: LD_INT 1
 405: PPUSH
 406: LD_INT 3
 408: PPUSH
 409: CALL 21241 0 2
// MCS_ApeOptions ( 1 , [ 0 , 1 , 0 , 0 ] ) ;
 413: LD_INT 1
 415: PPUSH
 416: LD_INT 0
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 0
 424: PUSH
 425: LD_INT 0
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PPUSH
 434: CALL 21274 0 2
// MCL_SetTechList ( 1 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_rocket ] ) ;
 438: LD_INT 1
 440: PPUSH
 441: LD_INT 48
 443: PUSH
 444: LD_INT 49
 446: PUSH
 447: LD_INT 46
 449: PUSH
 450: LD_INT 47
 452: PUSH
 453: LD_INT 35
 455: PUSH
 456: LD_INT 45
 458: PUSH
 459: LD_INT 1
 461: PUSH
 462: LD_INT 50
 464: PUSH
 465: LD_INT 2
 467: PUSH
 468: LD_INT 51
 470: PUSH
 471: LD_INT 52
 473: PUSH
 474: LD_INT 69
 476: PUSH
 477: LD_INT 39
 479: PUSH
 480: LD_INT 60
 482: PUSH
 483: LD_INT 61
 485: PUSH
 486: LD_INT 12
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 15
 494: PUSH
 495: LD_INT 53
 497: PUSH
 498: LD_INT 40
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PPUSH
 523: CALL 18079 0 2
// MCS_SetSpecClass ( 1 , 4 , 0 , 0 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 4
 532: PPUSH
 533: LD_INT 0
 535: PPUSH
 536: LD_INT 0
 538: PPUSH
 539: CALL 22129 0 4
// MCS_Depot ( 1 , [ 35 , 9 , 3 ] ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 35
 548: PUSH
 549: LD_INT 9
 551: PUSH
 552: LD_INT 3
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: PPUSH
 560: CALL 20386 0 2
// MCS_Barracks ( 1 , [ 54 , 19 , 4 ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 54
 569: PUSH
 570: LD_INT 19
 572: PUSH
 573: LD_INT 4
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: PPUSH
 581: CALL 20961 0 2
// MCS_Barracks ( 1 , [ 34 , 20 , 0 ] ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 34
 590: PUSH
 591: LD_INT 20
 593: PUSH
 594: LD_INT 0
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: PPUSH
 602: CALL 20961 0 2
// MCS_Mine ( 1 ) ;
 606: LD_INT 1
 608: PPUSH
 609: CALL 20758 0 1
// MCS_Lab ( 1 , [ 29 , 5 , 2 ] , [ b_lab_weapon , b_lab_opto ] ) ;
 613: LD_INT 1
 615: PPUSH
 616: LD_INT 29
 618: PUSH
 619: LD_INT 5
 621: PUSH
 622: LD_INT 2
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: PPUSH
 630: LD_INT 10
 632: PUSH
 633: LD_INT 15
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: PPUSH
 640: CALL 20422 0 3
// MCS_PowerPlants ( 1 , [ 15 , 8 , 2 , 14 , 5 , 2 , 39 , 12 , 0 ] , [ b_solar_power , b_solar_power , b_oil_power ] ) ;
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 15
 649: PUSH
 650: LD_INT 8
 652: PUSH
 653: LD_INT 2
 655: PUSH
 656: LD_INT 14
 658: PUSH
 659: LD_INT 5
 661: PUSH
 662: LD_INT 2
 664: PUSH
 665: LD_INT 39
 667: PUSH
 668: LD_INT 12
 670: PUSH
 671: LD_INT 0
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: LD_INT 27
 687: PUSH
 688: LD_INT 27
 690: PUSH
 691: LD_INT 26
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: PPUSH
 699: CALL 20598 0 3
// MCS_AddFortification ( 1 , b_bunker , [ 18 , 13 , 0 , 38 , 22 , 5 , 50 , 6 , 4 ] , [ us_rocket_launcher , us_double_gun , us_double_gun ] ) ;
 703: LD_INT 1
 705: PPUSH
 706: LD_INT 32
 708: PPUSH
 709: LD_INT 18
 711: PUSH
 712: LD_INT 13
 714: PUSH
 715: LD_INT 0
 717: PUSH
 718: LD_INT 38
 720: PUSH
 721: LD_INT 22
 723: PUSH
 724: LD_INT 5
 726: PUSH
 727: LD_INT 50
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 4
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: PPUSH
 747: LD_INT 7
 749: PUSH
 750: LD_INT 5
 752: PUSH
 753: LD_INT 5
 755: PUSH
 756: EMPTY
 757: LIST
 758: LIST
 759: LIST
 760: PPUSH
 761: CALL 19882 0 4
// MCS_Factory ( 1 , [ 23 , 8 , 2 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track , b_ext_rocket ] ) ;
 765: LD_INT 1
 767: PPUSH
 768: LD_INT 23
 770: PUSH
 771: LD_INT 8
 773: PUSH
 774: LD_INT 2
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: PPUSH
 782: LD_INT 17
 784: PUSH
 785: LD_INT 19
 787: PUSH
 788: LD_INT 22
 790: PUSH
 791: LD_INT 16
 793: PUSH
 794: LD_INT 18
 796: PUSH
 797: EMPTY
 798: LIST
 799: LIST
 800: LIST
 801: LIST
 802: LIST
 803: PPUSH
 804: CALL 20496 0 3
// MCS_ControlTower ( 1 , 1 , [ 40 , 4 , 3 ] ) ;
 808: LD_INT 1
 810: PPUSH
 811: LD_INT 1
 813: PPUSH
 814: LD_INT 40
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: EMPTY
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 20997 0 3
// MCS_SetDefence ( 1 , def_brown , def_brown_dontleave , [ 59 , 20 , 52 , 5 , 30 , 29 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
 832: LD_INT 1
 834: PPUSH
 835: LD_INT 14
 837: PPUSH
 838: LD_INT 15
 840: PPUSH
 841: LD_INT 59
 843: PUSH
 844: LD_INT 20
 846: PUSH
 847: LD_INT 52
 849: PUSH
 850: LD_INT 5
 852: PUSH
 853: LD_INT 30
 855: PUSH
 856: LD_INT 29
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: PPUSH
 867: LD_INT 3
 869: PUSH
 870: LD_INT 1
 872: PUSH
 873: LD_INT 1
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: LD_INT 3
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 5
 890: PUSH
 891: LD_INT 3
 893: PUSH
 894: LD_INT 1
 896: PUSH
 897: LD_INT 1
 899: PUSH
 900: LD_INT 5
 902: PUSH
 903: EMPTY
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 21737 0 5
// end ; 4 :
 921: GO 1541
 923: LD_INT 4
 925: DOUBLE
 926: EQUAL
 927: IFTRUE 931
 929: GO 1540
 931: POP
// begin MCS_Collector ( 4 , 1 , [ houten_crates ] ) ;
 932: LD_INT 4
 934: PPUSH
 935: LD_INT 1
 937: PPUSH
 938: LD_INT 5
 940: PUSH
 941: EMPTY
 942: LIST
 943: PPUSH
 944: CALL 21307 0 3
// MCN_AddApes ( ape_south , 5 , 1 ) ;
 948: LD_INT 12
 950: PPUSH
 951: LD_INT 5
 953: PPUSH
 954: LD_INT 1
 956: PPUSH
 957: CALL 18300 0 3
// MCS_SetParking ( 4 , houten_parking ) ;
 961: LD_INT 4
 963: PPUSH
 964: LD_INT 7
 966: PPUSH
 967: CALL 21207 0 2
// MCS_CreateDeposits ( 4 , [ 72 , 136 , 2 , 111 , 162 , 2 ] ) ;
 971: LD_INT 4
 973: PPUSH
 974: LD_INT 72
 976: PUSH
 977: LD_INT 136
 979: PUSH
 980: LD_INT 2
 982: PUSH
 983: LD_INT 111
 985: PUSH
 986: LD_INT 162
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PPUSH
1000: CALL 21448 0 2
// MCS_ApeLimit ( 4 , 3 ) ;
1004: LD_INT 4
1006: PPUSH
1007: LD_INT 3
1009: PPUSH
1010: CALL 21241 0 2
// MCS_ApeOptions ( 4 , [ 0 , 1 , 0 , 0 ] ) ;
1014: LD_INT 4
1016: PPUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 1
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 21274 0 2
// MCL_SetTechList ( 4 , [ tech_tech1 , tech_tech2 , tech_oilpow , tech_oileng , tech_solpow , tech_soleng , tech_apelang , tech_tech3 , tech_apepsych , tech_weap1 , tech_weap2 , tech_gatling , tech_gun , tech_opto1 , tech_opto2 , tech_lassight , tech_radar , tech_remcont , tech_weap3 , tech_advmet ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 48
1044: PUSH
1045: LD_INT 49
1047: PUSH
1048: LD_INT 46
1050: PUSH
1051: LD_INT 47
1053: PUSH
1054: LD_INT 35
1056: PUSH
1057: LD_INT 45
1059: PUSH
1060: LD_INT 1
1062: PUSH
1063: LD_INT 50
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 51
1071: PUSH
1072: LD_INT 52
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 39
1080: PUSH
1081: LD_INT 60
1083: PUSH
1084: LD_INT 61
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 6
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: LD_INT 53
1098: PUSH
1099: LD_INT 34
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PPUSH
1124: CALL 18079 0 2
// MCS_SetSpecClass ( 4 , 4 , 0 , 0 ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 4
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: LD_INT 0
1139: PPUSH
1140: CALL 22129 0 4
// MCS_Depot ( 4 , [ 86 , 146 , 1 ] ) ;
1144: LD_INT 4
1146: PPUSH
1147: LD_INT 86
1149: PUSH
1150: LD_INT 146
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: PPUSH
1161: CALL 20386 0 2
// MCS_Barracks ( 4 , [ 106 , 149 , 4 ] ) ;
1165: LD_INT 4
1167: PPUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 149
1173: PUSH
1174: LD_INT 4
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 20961 0 2
// MCS_Barracks ( 4 , [ 84 , 134 , 2 ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 134
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: PPUSH
1203: CALL 20961 0 2
// MCS_Mine ( 4 ) ;
1207: LD_INT 4
1209: PPUSH
1210: CALL 20758 0 1
// MCS_Lab ( 4 , [ 97 , 163 , 0 ] , [ b_lab_weapon , b_lab_opto ] ) ;
1214: LD_INT 4
1216: PPUSH
1217: LD_INT 97
1219: PUSH
1220: LD_INT 163
1222: PUSH
1223: LD_INT 0
1225: PUSH
1226: EMPTY
1227: LIST
1228: LIST
1229: LIST
1230: PPUSH
1231: LD_INT 10
1233: PUSH
1234: LD_INT 15
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: PPUSH
1241: CALL 20422 0 3
// MCS_PowerPlants ( 4 , [ 95 , 166 , 0 , 82 , 156 , 2 , 76 , 146 , 2 ] , [ b_solar_power , b_oil_power ] ) ;
1245: LD_INT 4
1247: PPUSH
1248: LD_INT 95
1250: PUSH
1251: LD_INT 166
1253: PUSH
1254: LD_INT 0
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 156
1262: PUSH
1263: LD_INT 2
1265: PUSH
1266: LD_INT 76
1268: PUSH
1269: LD_INT 146
1271: PUSH
1272: LD_INT 2
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: LIST
1281: LIST
1282: LIST
1283: LIST
1284: LIST
1285: PPUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 26
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL 20598 0 3
// MCS_AddFortification ( 4 , b_bunker , [ 109 , 155 , 4 , 103 , 143 , 4 , 75 , 133 , 2 , 88 , 133 , 2 ] , [ us_gatling_gun , us_heavy_gun , us_double_gun , us_heavy_gun ] ) ;
1300: LD_INT 4
1302: PPUSH
1303: LD_INT 32
1305: PPUSH
1306: LD_INT 109
1308: PUSH
1309: LD_INT 155
1311: PUSH
1312: LD_INT 4
1314: PUSH
1315: LD_INT 103
1317: PUSH
1318: LD_INT 143
1320: PUSH
1321: LD_INT 4
1323: PUSH
1324: LD_INT 75
1326: PUSH
1327: LD_INT 133
1329: PUSH
1330: LD_INT 2
1332: PUSH
1333: LD_INT 88
1335: PUSH
1336: LD_INT 133
1338: PUSH
1339: LD_INT 2
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: LD_INT 4
1358: PUSH
1359: LD_INT 6
1361: PUSH
1362: LD_INT 5
1364: PUSH
1365: LD_INT 6
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: PPUSH
1374: CALL 19882 0 4
// MCS_Factory ( 4 , [ 87 , 153 , 1 ] , [ b_ext_gun , b_ext_noncombat , b_ext_radio , b_ext_track ] ) ;
1378: LD_INT 4
1380: PPUSH
1381: LD_INT 87
1383: PUSH
1384: LD_INT 153
1386: PUSH
1387: LD_INT 1
1389: PUSH
1390: EMPTY
1391: LIST
1392: LIST
1393: LIST
1394: PPUSH
1395: LD_INT 17
1397: PUSH
1398: LD_INT 19
1400: PUSH
1401: LD_INT 22
1403: PUSH
1404: LD_INT 16
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: PPUSH
1413: CALL 20496 0 3
// MCS_ControlTower ( 4 , 1 , [ 105 , 160 , 5 ] ) ;
1417: LD_INT 4
1419: PPUSH
1420: LD_INT 1
1422: PPUSH
1423: LD_INT 105
1425: PUSH
1426: LD_INT 160
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 20997 0 3
// MCS_SetDefence ( 4 , def_houten , def_houten_dontleave , [ 69 , 126 , 80 , 126 , 108 , 142 , 118 , 161 ] , [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun , us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ) ;
1441: LD_INT 4
1443: PPUSH
1444: LD_INT 11
1446: PPUSH
1447: LD_INT 16
1449: PPUSH
1450: LD_INT 69
1452: PUSH
1453: LD_INT 126
1455: PUSH
1456: LD_INT 80
1458: PUSH
1459: LD_INT 126
1461: PUSH
1462: LD_INT 108
1464: PUSH
1465: LD_INT 142
1467: PUSH
1468: LD_INT 118
1470: PUSH
1471: LD_INT 161
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PPUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 4
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 1
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 5
1507: PUSH
1508: LD_INT 3
1510: PUSH
1511: LD_INT 1
1513: PUSH
1514: LD_INT 1
1516: PUSH
1517: LD_INT 5
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: LIST
1530: LIST
1531: LIST
1532: LIST
1533: PPUSH
1534: CALL 21737 0 5
// end ; end ;
1538: GO 1541
1540: POP
// end ;
1541: LD_VAR 0 2
1545: RET
// export isTest , debug_string , callUsed ; export houten , brown ; export dialog_north , dialog_south , dialog_popov , dialog_trans , player_loss ; export player_depot , call , pink_attack , alfa_support , alfa_north_triggered , alfa_south_triggered ; function InitGlobalVar ; begin
1546: LD_INT 0
1548: PPUSH
// dialog_north := true ;
1549: LD_ADDR_EXP 6
1553: PUSH
1554: LD_INT 1
1556: ST_TO_ADDR
// dialog_south := true ;
1557: LD_ADDR_EXP 7
1561: PUSH
1562: LD_INT 1
1564: ST_TO_ADDR
// dialog_popov := true ;
1565: LD_ADDR_EXP 8
1569: PUSH
1570: LD_INT 1
1572: ST_TO_ADDR
// dialog_trans := true ;
1573: LD_ADDR_EXP 9
1577: PUSH
1578: LD_INT 1
1580: ST_TO_ADDR
// call := true ;
1581: LD_ADDR_EXP 12
1585: PUSH
1586: LD_INT 1
1588: ST_TO_ADDR
// pink_attack := false ;
1589: LD_ADDR_EXP 13
1593: PUSH
1594: LD_INT 0
1596: ST_TO_ADDR
// alfa_support := false ;
1597: LD_ADDR_EXP 14
1601: PUSH
1602: LD_INT 0
1604: ST_TO_ADDR
// alfa_north_triggered := false ;
1605: LD_ADDR_EXP 15
1609: PUSH
1610: LD_INT 0
1612: ST_TO_ADDR
// alfa_south_triggered := false ;
1613: LD_ADDR_EXP 16
1617: PUSH
1618: LD_INT 0
1620: ST_TO_ADDR
// player_loss := 0 ;
1621: LD_ADDR_EXP 10
1625: PUSH
1626: LD_INT 0
1628: ST_TO_ADDR
// callUsed := false ;
1629: LD_ADDR_EXP 3
1633: PUSH
1634: LD_INT 0
1636: ST_TO_ADDR
// end ;
1637: LD_VAR 0 1
1641: RET
// every 0 0$10 trigger ListEnvironmentArea ( brown_tree ) = 0 do
1642: LD_INT 8
1644: PPUSH
1645: CALL_OW 353
1649: PUSH
1650: LD_INT 0
1652: EQUAL
1653: IFFALSE 1688
1655: GO 1657
1657: DISABLE
// begin MCS_AddFortification ( 1 , b_bunker , [ 50 , 10 , 4 ] , [ us_rocket_launcher ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 32
1663: PPUSH
1664: LD_INT 50
1666: PUSH
1667: LD_INT 10
1669: PUSH
1670: LD_INT 4
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: PPUSH
1678: LD_INT 7
1680: PUSH
1681: EMPTY
1682: LIST
1683: PPUSH
1684: CALL 19882 0 4
// end ;
1688: END
// every 10 10$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) do
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 30
1694: PUSH
1695: LD_INT 3
1697: PUSH
1698: EMPTY
1699: LIST
1700: LIST
1701: PPUSH
1702: CALL 11587 0 2
1706: IFFALSE 1800
1708: GO 1710
1710: DISABLE
// begin MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1711: LD_INT 1
1713: PPUSH
1714: LD_INT 3
1716: PUSH
1717: LD_INT 1
1719: PUSH
1720: LD_INT 2
1722: PUSH
1723: LD_INT 4
1725: PUSH
1726: LD_INT 3
1728: PUSH
1729: LD_INT 1
1731: PUSH
1732: LD_INT 2
1734: PUSH
1735: LD_INT 5
1737: PUSH
1738: LD_INT 3
1740: PUSH
1741: LD_INT 1
1743: PUSH
1744: LD_INT 2
1746: PUSH
1747: LD_INT 5
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 1
1755: PUSH
1756: LD_INT 2
1758: PUSH
1759: LD_INT 7
1761: PUSH
1762: LD_INT 3
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: LD_INT 2
1770: PUSH
1771: LD_INT 7
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PPUSH
1796: CALL 21955 0 2
// end ;
1800: END
// every 10 10$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) do
1801: LD_INT 4
1803: PPUSH
1804: LD_INT 30
1806: PUSH
1807: LD_INT 3
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PPUSH
1814: CALL 11587 0 2
1818: IFFALSE 1912
1820: GO 1822
1822: DISABLE
// begin MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ) ;
1823: LD_INT 4
1825: PPUSH
1826: LD_INT 3
1828: PUSH
1829: LD_INT 1
1831: PUSH
1832: LD_INT 2
1834: PUSH
1835: LD_INT 4
1837: PUSH
1838: LD_INT 3
1840: PUSH
1841: LD_INT 1
1843: PUSH
1844: LD_INT 2
1846: PUSH
1847: LD_INT 5
1849: PUSH
1850: LD_INT 3
1852: PUSH
1853: LD_INT 1
1855: PUSH
1856: LD_INT 2
1858: PUSH
1859: LD_INT 5
1861: PUSH
1862: LD_INT 4
1864: PUSH
1865: LD_INT 1
1867: PUSH
1868: LD_INT 2
1870: PUSH
1871: LD_INT 6
1873: PUSH
1874: LD_INT 4
1876: PUSH
1877: LD_INT 1
1879: PUSH
1880: LD_INT 2
1882: PUSH
1883: LD_INT 6
1885: PUSH
1886: EMPTY
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: PPUSH
1908: CALL 21955 0 2
// end ;
1912: END
// every 5 5$00 trigger MCF_Get ( 1 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 1 ] [ 1 ] = 0 do
1913: LD_INT 1
1915: PPUSH
1916: LD_INT 30
1918: PUSH
1919: LD_INT 3
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: PPUSH
1926: CALL 11587 0 2
1930: PUSH
1931: LD_EXP 71
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PUSH
1940: LD_INT 1
1942: ARRAY
1943: PUSH
1944: LD_INT 0
1946: EQUAL
1947: AND
1948: IFFALSE 2059
1950: GO 1952
1952: DISABLE
// begin enable ;
1953: ENABLE
// MCS_PrepareAttack ( 1 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher , us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] ) ;
1954: LD_INT 1
1956: PPUSH
1957: LD_INT 3
1959: PUSH
1960: LD_INT 1
1962: PUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 4
1968: PUSH
1969: LD_INT 3
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 5
1980: PUSH
1981: LD_INT 3
1983: PUSH
1984: LD_INT 1
1986: PUSH
1987: LD_INT 2
1989: PUSH
1990: LD_INT 5
1992: PUSH
1993: LD_INT 3
1995: PUSH
1996: LD_INT 1
1998: PUSH
1999: LD_INT 2
2001: PUSH
2002: LD_INT 7
2004: PUSH
2005: LD_INT 3
2007: PUSH
2008: LD_INT 1
2010: PUSH
2011: LD_INT 2
2013: PUSH
2014: LD_INT 7
2016: PUSH
2017: LD_INT 4
2019: PUSH
2020: LD_INT 1
2022: PUSH
2023: LD_INT 2
2025: PUSH
2026: LD_INT 7
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: PPUSH
2055: CALL 21955 0 2
// end ;
2059: END
// every 5 5$00 trigger MCF_Get ( 4 , [ f_btype , b_factory ] ) and MREG_ToAttack [ 4 ] [ 1 ] = 0 do
2060: LD_INT 4
2062: PPUSH
2063: LD_INT 30
2065: PUSH
2066: LD_INT 3
2068: PUSH
2069: EMPTY
2070: LIST
2071: LIST
2072: PPUSH
2073: CALL 11587 0 2
2077: PUSH
2078: LD_EXP 71
2082: PUSH
2083: LD_INT 4
2085: ARRAY
2086: PUSH
2087: LD_INT 1
2089: ARRAY
2090: PUSH
2091: LD_INT 0
2093: EQUAL
2094: AND
2095: IFFALSE 2206
2097: GO 2099
2099: DISABLE
// begin enable ;
2100: ENABLE
// MCS_PrepareAttack ( 4 , [ us_medium_tracked , engine_combustion , control_remote , us_gatling_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun , us_medium_tracked , engine_combustion , control_remote , us_double_gun ] ) ;
2101: LD_INT 4
2103: PPUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 1
2109: PUSH
2110: LD_INT 2
2112: PUSH
2113: LD_INT 4
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: LD_INT 1
2121: PUSH
2122: LD_INT 2
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 1
2133: PUSH
2134: LD_INT 2
2136: PUSH
2137: LD_INT 5
2139: PUSH
2140: LD_INT 4
2142: PUSH
2143: LD_INT 1
2145: PUSH
2146: LD_INT 2
2148: PUSH
2149: LD_INT 6
2151: PUSH
2152: LD_INT 4
2154: PUSH
2155: LD_INT 1
2157: PUSH
2158: LD_INT 2
2160: PUSH
2161: LD_INT 6
2163: PUSH
2164: LD_INT 3
2166: PUSH
2167: LD_INT 1
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: LD_INT 5
2175: PUSH
2176: EMPTY
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 21955 0 2
// end ;
2206: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do var i ;
2207: LD_EXP 13
2211: PUSH
2212: LD_INT 22
2214: PUSH
2215: LD_INT 6
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: PUSH
2222: LD_INT 21
2224: PUSH
2225: LD_INT 2
2227: PUSH
2228: EMPTY
2229: LIST
2230: LIST
2231: PUSH
2232: LD_INT 3
2234: PUSH
2235: LD_INT 34
2237: PUSH
2238: LD_INT 51
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: LIST
2253: PPUSH
2254: CALL_OW 69
2258: AND
2259: IFFALSE 2388
2261: GO 2263
2263: DISABLE
2264: LD_INT 0
2266: PPUSH
// begin enable ;
2267: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) do
2268: LD_ADDR_VAR 0 1
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: LD_INT 6
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: PUSH
2283: LD_INT 21
2285: PUSH
2286: LD_INT 2
2288: PUSH
2289: EMPTY
2290: LIST
2291: LIST
2292: PUSH
2293: LD_INT 3
2295: PUSH
2296: LD_INT 34
2298: PUSH
2299: LD_INT 51
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: EMPTY
2307: LIST
2308: LIST
2309: PUSH
2310: EMPTY
2311: LIST
2312: LIST
2313: LIST
2314: PPUSH
2315: CALL_OW 69
2319: PUSH
2320: FOR_IN
2321: IFFALSE 2386
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2323: LD_VAR 0 1
2327: PPUSH
2328: CALL_OW 314
2332: NOT
2333: PUSH
2334: LD_VAR 0 1
2338: PPUSH
2339: CALL_OW 256
2343: PUSH
2344: LD_INT 250
2346: GREATER
2347: AND
2348: IFFALSE 2384
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
2350: LD_VAR 0 1
2354: PPUSH
2355: LD_INT 81
2357: PUSH
2358: LD_INT 6
2360: PUSH
2361: EMPTY
2362: LIST
2363: LIST
2364: PPUSH
2365: CALL_OW 69
2369: PPUSH
2370: LD_VAR 0 1
2374: PPUSH
2375: CALL_OW 74
2379: PPUSH
2380: CALL_OW 115
2384: GO 2320
2386: POP
2387: POP
// end ;
2388: PPOPN 1
2390: END
// every 0 0$01 trigger pink_attack and FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] ] ) = 0 do
2391: LD_EXP 13
2395: PUSH
2396: LD_INT 22
2398: PUSH
2399: LD_INT 6
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: PUSH
2406: LD_INT 21
2408: PUSH
2409: LD_INT 2
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: PUSH
2416: LD_INT 3
2418: PUSH
2419: LD_INT 34
2421: PUSH
2422: LD_INT 51
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: PUSH
2433: EMPTY
2434: LIST
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PUSH
2443: LD_INT 0
2445: EQUAL
2446: AND
2447: IFFALSE 2461
2449: GO 2451
2451: DISABLE
// begin enable ;
2452: ENABLE
// pink_attack := false ;
2453: LD_ADDR_EXP 13
2457: PUSH
2458: LD_INT 0
2460: ST_TO_ADDR
// end ;
2461: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) do var i ;
2462: LD_EXP 14
2466: PUSH
2467: LD_INT 22
2469: PUSH
2470: LD_INT 8
2472: PUSH
2473: EMPTY
2474: LIST
2475: LIST
2476: PPUSH
2477: CALL_OW 69
2481: AND
2482: IFFALSE 2593
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
// begin enable ;
2490: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
2491: LD_ADDR_VAR 0 1
2495: PUSH
2496: LD_INT 22
2498: PUSH
2499: LD_INT 8
2501: PUSH
2502: EMPTY
2503: LIST
2504: LIST
2505: PUSH
2506: LD_INT 21
2508: PUSH
2509: LD_INT 2
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 69
2524: PUSH
2525: FOR_IN
2526: IFFALSE 2591
// if not HasTask ( i ) and GetLives ( i ) > 250 then
2528: LD_VAR 0 1
2532: PPUSH
2533: CALL_OW 314
2537: NOT
2538: PUSH
2539: LD_VAR 0 1
2543: PPUSH
2544: CALL_OW 256
2548: PUSH
2549: LD_INT 250
2551: GREATER
2552: AND
2553: IFFALSE 2589
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
2555: LD_VAR 0 1
2559: PPUSH
2560: LD_INT 81
2562: PUSH
2563: LD_INT 8
2565: PUSH
2566: EMPTY
2567: LIST
2568: LIST
2569: PPUSH
2570: CALL_OW 69
2574: PPUSH
2575: LD_VAR 0 1
2579: PPUSH
2580: CALL_OW 74
2584: PPUSH
2585: CALL_OW 115
2589: GO 2525
2591: POP
2592: POP
// end ;
2593: PPOPN 1
2595: END
// every 0 0$01 trigger alfa_support and FilterAllUnits ( [ f_side , 8 ] ) = 0 do
2596: LD_EXP 14
2600: PUSH
2601: LD_INT 22
2603: PUSH
2604: LD_INT 8
2606: PUSH
2607: EMPTY
2608: LIST
2609: LIST
2610: PPUSH
2611: CALL_OW 69
2615: PUSH
2616: LD_INT 0
2618: EQUAL
2619: AND
2620: IFFALSE 2634
2622: GO 2624
2624: DISABLE
// begin enable ;
2625: ENABLE
// alfa_support := false ;
2626: LD_ADDR_EXP 14
2630: PUSH
2631: LD_INT 0
2633: ST_TO_ADDR
// end ; end_of_file
2634: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team ; begin
2635: LD_INT 0
2637: PPUSH
2638: PPUSH
2639: PPUSH
2640: PPUSH
// uc_side := side ;
2641: LD_ADDR_OWVAR 20
2645: PUSH
2646: LD_VAR 0 1
2650: ST_TO_ADDR
// uc_nation := nat ;
2651: LD_ADDR_OWVAR 21
2655: PUSH
2656: LD_VAR 0 2
2660: ST_TO_ADDR
// team := [ ] ;
2661: LD_ADDR_VAR 0 10
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// hc_importance := 100 ;
2668: LD_ADDR_OWVAR 32
2672: PUSH
2673: LD_INT 100
2675: ST_TO_ADDR
// case commander of jakes :
2676: LD_VAR 0 4
2680: PUSH
2681: LD_STRING jakes
2683: DOUBLE
2684: EQUAL
2685: IFTRUE 2689
2687: GO 2766
2689: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
2690: LD_INT 1
2692: PPUSH
2693: LD_INT 1
2695: PPUSH
2696: LD_VAR 0 5
2700: PPUSH
2701: CALL_OW 380
// hc_gallery := pkremaster ;
2705: LD_ADDR_OWVAR 33
2709: PUSH
2710: LD_STRING pkremaster
2712: ST_TO_ADDR
// hc_face_number := 12 ;
2713: LD_ADDR_OWVAR 34
2717: PUSH
2718: LD_INT 12
2720: ST_TO_ADDR
// hc_name := Jan van Jakes ;
2721: LD_ADDR_OWVAR 26
2725: PUSH
2726: LD_STRING Jan van Jakes
2728: ST_TO_ADDR
// houten := CreateHuman ;
2729: LD_ADDR_EXP 4
2733: PUSH
2734: CALL_OW 44
2738: ST_TO_ADDR
// LogHuman ( houten ) ;
2739: LD_EXP 4
2743: PPUSH
2744: CALL 7859 0 1
// team := team ^ houten ;
2748: LD_ADDR_VAR 0 10
2752: PUSH
2753: LD_VAR 0 10
2757: PUSH
2758: LD_EXP 4
2762: ADD
2763: ST_TO_ADDR
// end ; sylvia :
2764: GO 2852
2766: LD_STRING sylvia
2768: DOUBLE
2769: EQUAL
2770: IFTRUE 2774
2772: GO 2851
2774: POP
// begin PrepareHuman ( sex_female , class_soldier , skill ) ;
2775: LD_INT 2
2777: PPUSH
2778: LD_INT 1
2780: PPUSH
2781: LD_VAR 0 5
2785: PPUSH
2786: CALL_OW 380
// hc_gallery := pkremaster ;
2790: LD_ADDR_OWVAR 33
2794: PUSH
2795: LD_STRING pkremaster
2797: ST_TO_ADDR
// hc_face_number := 13 ;
2798: LD_ADDR_OWVAR 34
2802: PUSH
2803: LD_INT 13
2805: ST_TO_ADDR
// hc_name := Sylvia Johnson ;
2806: LD_ADDR_OWVAR 26
2810: PUSH
2811: LD_STRING Sylvia Johnson
2813: ST_TO_ADDR
// brown := CreateHuman ;
2814: LD_ADDR_EXP 5
2818: PUSH
2819: CALL_OW 44
2823: ST_TO_ADDR
// LogHuman ( brown ) ;
2824: LD_EXP 5
2828: PPUSH
2829: CALL 7859 0 1
// team := team ^ brown ;
2833: LD_ADDR_VAR 0 10
2837: PUSH
2838: LD_VAR 0 10
2842: PUSH
2843: LD_EXP 5
2847: ADD
2848: ST_TO_ADDR
// end ; end ;
2849: GO 2852
2851: POP
// hc_gallery :=  ;
2852: LD_ADDR_OWVAR 33
2856: PUSH
2857: LD_STRING 
2859: ST_TO_ADDR
// hc_name :=  ;
2860: LD_ADDR_OWVAR 26
2864: PUSH
2865: LD_STRING 
2867: ST_TO_ADDR
// hc_importance := 0 ;
2868: LD_ADDR_OWVAR 32
2872: PUSH
2873: LD_INT 0
2875: ST_TO_ADDR
// for i = 1 to num do
2876: LD_ADDR_VAR 0 8
2880: PUSH
2881: DOUBLE
2882: LD_INT 1
2884: DEC
2885: ST_TO_ADDR
2886: LD_VAR 0 6
2890: PUSH
2891: FOR_TO
2892: IFFALSE 2956
// begin PrepareHuman ( false , ( i mod 4 ) + 1 , skill ) ;
2894: LD_INT 0
2896: PPUSH
2897: LD_VAR 0 8
2901: PUSH
2902: LD_INT 4
2904: MOD
2905: PUSH
2906: LD_INT 1
2908: PLUS
2909: PPUSH
2910: LD_VAR 0 5
2914: PPUSH
2915: CALL_OW 380
// un := CreateHuman ;
2919: LD_ADDR_VAR 0 9
2923: PUSH
2924: CALL_OW 44
2928: ST_TO_ADDR
// LogHuman ( un ) ;
2929: LD_VAR 0 9
2933: PPUSH
2934: CALL 7859 0 1
// team := team ^ un ;
2938: LD_ADDR_VAR 0 10
2942: PUSH
2943: LD_VAR 0 10
2947: PUSH
2948: LD_VAR 0 9
2952: ADD
2953: ST_TO_ADDR
// end ;
2954: GO 2891
2956: POP
2957: POP
// for i = 1 to team do
2958: LD_ADDR_VAR 0 8
2962: PUSH
2963: DOUBLE
2964: LD_INT 1
2966: DEC
2967: ST_TO_ADDR
2968: LD_VAR 0 10
2972: PUSH
2973: FOR_TO
2974: IFFALSE 3001
// PlaceUnitArea ( team [ i ] , area , false ) ;
2976: LD_VAR 0 10
2980: PUSH
2981: LD_VAR 0 8
2985: ARRAY
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_INT 0
2994: PPUSH
2995: CALL_OW 49
2999: GO 2973
3001: POP
3002: POP
// end ;
3003: LD_VAR 0 7
3007: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
3008: LD_INT 0
3010: PPUSH
3011: PPUSH
// for i = 1 to n1 do
3012: LD_ADDR_VAR 0 6
3016: PUSH
3017: DOUBLE
3018: LD_INT 1
3020: DEC
3021: ST_TO_ADDR
3022: LD_VAR 0 1
3026: PUSH
3027: FOR_TO
3028: IFFALSE 3050
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
3030: LD_INT 1
3032: PPUSH
3033: LD_INT 1
3035: PPUSH
3036: LD_VAR 0 4
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 59
3048: GO 3027
3050: POP
3051: POP
// for i = 1 to n2 do
3052: LD_ADDR_VAR 0 6
3056: PUSH
3057: DOUBLE
3058: LD_INT 1
3060: DEC
3061: ST_TO_ADDR
3062: LD_VAR 0 2
3066: PUSH
3067: FOR_TO
3068: IFFALSE 3090
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
3070: LD_INT 2
3072: PPUSH
3073: LD_INT 1
3075: PPUSH
3076: LD_VAR 0 4
3080: PPUSH
3081: LD_INT 0
3083: PPUSH
3084: CALL_OW 59
3088: GO 3067
3090: POP
3091: POP
// for i = 1 to n3 do
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: DOUBLE
3098: LD_INT 1
3100: DEC
3101: ST_TO_ADDR
3102: LD_VAR 0 3
3106: PUSH
3107: FOR_TO
3108: IFFALSE 3130
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
3110: LD_INT 3
3112: PPUSH
3113: LD_INT 1
3115: PPUSH
3116: LD_VAR 0 4
3120: PPUSH
3121: LD_INT 0
3123: PPUSH
3124: CALL_OW 59
3128: GO 3107
3130: POP
3131: POP
// end ; end_of_file
3132: LD_VAR 0 5
3136: RET
// export commanders , player , gladkov , davidov , gorki , stolypin , player_squad , pl_counter , player_com ; export function InitCommanders ( commander ) ; var i , skill , tmp , team , veh ; begin
3137: LD_INT 0
3139: PPUSH
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
// uc_side := your_side ;
3145: LD_ADDR_OWVAR 20
3149: PUSH
3150: LD_OWVAR 2
3154: ST_TO_ADDR
// uc_nation := nation_russian ;
3155: LD_ADDR_OWVAR 21
3159: PUSH
3160: LD_INT 3
3162: ST_TO_ADDR
// gladkov := NewCharacter ( Gladkov ) ;
3163: LD_ADDR_EXP 19
3167: PUSH
3168: LD_STRING Gladkov
3170: PPUSH
3171: CALL_OW 25
3175: ST_TO_ADDR
// davidov := NewCharacter ( Davidov ) ;
3176: LD_ADDR_EXP 20
3180: PUSH
3181: LD_STRING Davidov
3183: PPUSH
3184: CALL_OW 25
3188: ST_TO_ADDR
// gorki := NewCharacter ( Burlak ) ;
3189: LD_ADDR_EXP 21
3193: PUSH
3194: LD_STRING Burlak
3196: PPUSH
3197: CALL_OW 25
3201: ST_TO_ADDR
// stolypin := NewCharacter ( Stolypin ) ;
3202: LD_ADDR_EXP 22
3206: PUSH
3207: LD_STRING Stolypin
3209: PPUSH
3210: CALL_OW 25
3214: ST_TO_ADDR
// commanders := [ gladkov , davidov , gorki , stolypin ] ;
3215: LD_ADDR_EXP 17
3219: PUSH
3220: LD_EXP 19
3224: PUSH
3225: LD_EXP 20
3229: PUSH
3230: LD_EXP 21
3234: PUSH
3235: LD_EXP 22
3239: PUSH
3240: EMPTY
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: ST_TO_ADDR
// player_com := commanders [ commander ] ;
3246: LD_ADDR_EXP 25
3250: PUSH
3251: LD_EXP 17
3255: PUSH
3256: LD_VAR 0 1
3260: ARRAY
3261: ST_TO_ADDR
// team := [ ] ;
3262: LD_ADDR_VAR 0 6
3266: PUSH
3267: EMPTY
3268: ST_TO_ADDR
// skill := [ 4 , 3 , 3 ] [ Difficulty ] ;
3269: LD_ADDR_VAR 0 4
3273: PUSH
3274: LD_INT 4
3276: PUSH
3277: LD_INT 3
3279: PUSH
3280: LD_INT 3
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: PUSH
3288: LD_OWVAR 67
3292: ARRAY
3293: ST_TO_ADDR
// hc_gallery :=  ;
3294: LD_ADDR_OWVAR 33
3298: PUSH
3299: LD_STRING 
3301: ST_TO_ADDR
// hc_name :=  ;
3302: LD_ADDR_OWVAR 26
3306: PUSH
3307: LD_STRING 
3309: ST_TO_ADDR
// hc_importance := 0 ;
3310: LD_ADDR_OWVAR 32
3314: PUSH
3315: LD_INT 0
3317: ST_TO_ADDR
// case player_com of gladkov :
3318: LD_EXP 25
3322: PUSH
3323: LD_EXP 19
3327: DOUBLE
3328: EQUAL
3329: IFTRUE 3333
3331: GO 3478
3333: POP
// begin for i = 1 to 10 do
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: DOUBLE
3340: LD_INT 1
3342: DEC
3343: ST_TO_ADDR
3344: LD_INT 10
3346: PUSH
3347: FOR_TO
3348: IFFALSE 3387
// begin PrepareHuman ( false , 1 , skill + 1 ) ;
3350: LD_INT 0
3352: PPUSH
3353: LD_INT 1
3355: PPUSH
3356: LD_VAR 0 4
3360: PUSH
3361: LD_INT 1
3363: PLUS
3364: PPUSH
3365: CALL_OW 380
// team := team ^ CreateHuman ;
3369: LD_ADDR_VAR 0 6
3373: PUSH
3374: LD_VAR 0 6
3378: PUSH
3379: CALL_OW 44
3383: ADD
3384: ST_TO_ADDR
// end ;
3385: GO 3347
3387: POP
3388: POP
// for i = 1 to 15 do
3389: LD_ADDR_VAR 0 3
3393: PUSH
3394: DOUBLE
3395: LD_INT 1
3397: DEC
3398: ST_TO_ADDR
3399: LD_INT 15
3401: PUSH
3402: FOR_TO
3403: IFFALSE 3448
// begin PrepareHuman ( false , ( i mod 3 ) + 2 , skill ) ;
3405: LD_INT 0
3407: PPUSH
3408: LD_VAR 0 3
3412: PUSH
3413: LD_INT 3
3415: MOD
3416: PUSH
3417: LD_INT 2
3419: PLUS
3420: PPUSH
3421: LD_VAR 0 4
3425: PPUSH
3426: CALL_OW 380
// team := team ^ CreateHuman ;
3430: LD_ADDR_VAR 0 6
3434: PUSH
3435: LD_VAR 0 6
3439: PUSH
3440: CALL_OW 44
3444: ADD
3445: ST_TO_ADDR
// end ;
3446: GO 3402
3448: POP
3449: POP
// SetTech ( tech_bazooka , 3 , state_enabled ) ;
3450: LD_INT 44
3452: PPUSH
3453: LD_INT 3
3455: PPUSH
3456: LD_INT 1
3458: PPUSH
3459: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3463: LD_INT 34
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: LD_INT 1
3471: PPUSH
3472: CALL_OW 322
// end ; davidov :
3476: GO 4361
3478: LD_EXP 20
3482: DOUBLE
3483: EQUAL
3484: IFTRUE 3488
3486: GO 3763
3488: POP
// begin for i = 1 to 10 do
3489: LD_ADDR_VAR 0 3
3493: PUSH
3494: DOUBLE
3495: LD_INT 1
3497: DEC
3498: ST_TO_ADDR
3499: LD_INT 10
3501: PUSH
3502: FOR_TO
3503: IFFALSE 3542
// begin PrepareHuman ( false , 4 , skill + 1 ) ;
3505: LD_INT 0
3507: PPUSH
3508: LD_INT 4
3510: PPUSH
3511: LD_VAR 0 4
3515: PUSH
3516: LD_INT 1
3518: PLUS
3519: PPUSH
3520: CALL_OW 380
// team := team ^ CreateHuman ;
3524: LD_ADDR_VAR 0 6
3528: PUSH
3529: LD_VAR 0 6
3533: PUSH
3534: CALL_OW 44
3538: ADD
3539: ST_TO_ADDR
// end ;
3540: GO 3502
3542: POP
3543: POP
// for i = 1 to 15 do
3544: LD_ADDR_VAR 0 3
3548: PUSH
3549: DOUBLE
3550: LD_INT 1
3552: DEC
3553: ST_TO_ADDR
3554: LD_INT 15
3556: PUSH
3557: FOR_TO
3558: IFFALSE 3603
// begin PrepareHuman ( false , ( i mod 3 ) + 1 , skill ) ;
3560: LD_INT 0
3562: PPUSH
3563: LD_VAR 0 3
3567: PUSH
3568: LD_INT 3
3570: MOD
3571: PUSH
3572: LD_INT 1
3574: PLUS
3575: PPUSH
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 380
// team := team ^ CreateHuman ;
3585: LD_ADDR_VAR 0 6
3589: PUSH
3590: LD_VAR 0 6
3594: PUSH
3595: CALL_OW 44
3599: ADD
3600: ST_TO_ADDR
// end ;
3601: GO 3557
3603: POP
3604: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3605: LD_INT 34
3607: PPUSH
3608: LD_INT 3
3610: PPUSH
3611: LD_INT 1
3613: PPUSH
3614: CALL_OW 322
// SetTech ( tech_ai , 3 , state_enabled ) ;
3618: LD_INT 32
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: CALL_OW 322
// SetTech ( tech_advai , 3 , state_enabled ) ;
3631: LD_INT 27
3633: PPUSH
3634: LD_INT 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: CALL_OW 322
// SetTech ( 30 , 3 , state_enabled ) ;
3644: LD_INT 30
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL_OW 322
// SetTech ( 63 , 3 , state_enabled ) ;
3657: LD_INT 63
3659: PPUSH
3660: LD_INT 3
3662: PPUSH
3663: LD_INT 1
3665: PPUSH
3666: CALL_OW 322
// SetTech ( tech_comp1 , 3 , state_enabled ) ;
3670: LD_INT 57
3672: PPUSH
3673: LD_INT 3
3675: PPUSH
3676: LD_INT 1
3678: PPUSH
3679: CALL_OW 322
// SetTech ( tech_comp2 , 3 , state_enabled ) ;
3683: LD_INT 58
3685: PPUSH
3686: LD_INT 3
3688: PPUSH
3689: LD_INT 1
3691: PPUSH
3692: CALL_OW 322
// SetRestrict ( b_lab_full , 3 , state_enabled ) ;
3696: LD_INT 8
3698: PPUSH
3699: LD_INT 3
3701: PPUSH
3702: LD_INT 1
3704: PPUSH
3705: CALL_OW 324
// SetRestrict ( b_lab_computer , 3 , state_enabled ) ;
3709: LD_INT 12
3711: PPUSH
3712: LD_INT 3
3714: PPUSH
3715: LD_INT 1
3717: PPUSH
3718: CALL_OW 324
// SetRestrict ( b_lab_spacetime , 3 , state_enabled ) ;
3722: LD_INT 14
3724: PPUSH
3725: LD_INT 3
3727: PPUSH
3728: LD_INT 1
3730: PPUSH
3731: CALL_OW 324
// SetRestrict ( b_ext_computer , 3 , state_enabled ) ;
3735: LD_INT 24
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 1
3743: PPUSH
3744: CALL_OW 324
// SetRestrict ( b_turret , 3 , state_enabled ) ;
3748: LD_INT 33
3750: PPUSH
3751: LD_INT 3
3753: PPUSH
3754: LD_INT 1
3756: PPUSH
3757: CALL_OW 324
// end ; gorki :
3761: GO 4361
3763: LD_EXP 21
3767: DOUBLE
3768: EQUAL
3769: IFTRUE 3773
3771: GO 4054
3773: POP
// begin for i = 1 to 10 do
3774: LD_ADDR_VAR 0 3
3778: PUSH
3779: DOUBLE
3780: LD_INT 1
3782: DEC
3783: ST_TO_ADDR
3784: LD_INT 10
3786: PUSH
3787: FOR_TO
3788: IFFALSE 3842
// begin PrepareHuman ( false , 3 , skill + 1 ) ;
3790: LD_INT 0
3792: PPUSH
3793: LD_INT 3
3795: PPUSH
3796: LD_VAR 0 4
3800: PUSH
3801: LD_INT 1
3803: PLUS
3804: PPUSH
3805: CALL_OW 380
// team := team ^ CreateHuman ;
3809: LD_ADDR_VAR 0 6
3813: PUSH
3814: LD_VAR 0 6
3818: PUSH
3819: CALL_OW 44
3823: ADD
3824: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3825: LD_VAR 0 6
3829: PUSH
3830: LD_VAR 0 6
3834: ARRAY
3835: PPUSH
3836: CALL 7859 0 1
// end ;
3840: GO 3787
3842: POP
3843: POP
// for i = 1 to 15 do
3844: LD_ADDR_VAR 0 3
3848: PUSH
3849: DOUBLE
3850: LD_INT 1
3852: DEC
3853: ST_TO_ADDR
3854: LD_INT 15
3856: PUSH
3857: FOR_TO
3858: IFFALSE 3931
// begin PrepareHuman ( false , [ 1 , 2 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
3860: LD_INT 0
3862: PPUSH
3863: LD_INT 1
3865: PUSH
3866: LD_INT 2
3868: PUSH
3869: LD_INT 4
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 1
3879: PPUSH
3880: LD_INT 3
3882: PPUSH
3883: CALL_OW 12
3887: ARRAY
3888: PPUSH
3889: LD_VAR 0 4
3893: PPUSH
3894: CALL_OW 380
// team := team ^ CreateHuman ;
3898: LD_ADDR_VAR 0 6
3902: PUSH
3903: LD_VAR 0 6
3907: PUSH
3908: CALL_OW 44
3912: ADD
3913: ST_TO_ADDR
// LogHuman ( team [ team ] ) ;
3914: LD_VAR 0 6
3918: PUSH
3919: LD_VAR 0 6
3923: ARRAY
3924: PPUSH
3925: CALL 7859 0 1
// end ;
3929: GO 3857
3931: POP
3932: POP
// SetTech ( tech_rocket , 3 , state_enabled ) ;
3933: LD_INT 40
3935: PPUSH
3936: LD_INT 3
3938: PPUSH
3939: LD_INT 1
3941: PPUSH
3942: CALL_OW 322
// SetTech ( tech_advmet , 3 , state_enabled ) ;
3946: LD_INT 34
3948: PPUSH
3949: LD_INT 3
3951: PPUSH
3952: LD_INT 1
3954: PPUSH
3955: CALL_OW 322
// SetRestrict ( b_ext_rocket , 3 , state_enabled ) ;
3959: LD_INT 18
3961: PPUSH
3962: LD_INT 3
3964: PPUSH
3965: LD_INT 1
3967: PPUSH
3968: CALL_OW 324
// vc_chassis := ru_medium_tracked ;
3972: LD_ADDR_OWVAR 37
3976: PUSH
3977: LD_INT 22
3979: ST_TO_ADDR
// vc_engine := engine_combustion ;
3980: LD_ADDR_OWVAR 39
3984: PUSH
3985: LD_INT 1
3987: ST_TO_ADDR
// vc_control := control_manual ;
3988: LD_ADDR_OWVAR 38
3992: PUSH
3993: LD_INT 1
3995: ST_TO_ADDR
// vc_weapon := ru_rocket_launcher ;
3996: LD_ADDR_OWVAR 40
4000: PUSH
4001: LD_INT 45
4003: ST_TO_ADDR
// vc_fuel_battery := 3 ;
4004: LD_ADDR_OWVAR 41
4008: PUSH
4009: LD_INT 3
4011: ST_TO_ADDR
// veh := CreateVehicle ;
4012: LD_ADDR_VAR 0 7
4016: PUSH
4017: CALL_OW 45
4021: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
4022: LD_VAR 0 7
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 242
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4034: LD_VAR 0 7
4038: PPUSH
4039: LD_INT 107
4041: PPUSH
4042: LD_INT 83
4044: PPUSH
4045: LD_INT 0
4047: PPUSH
4048: CALL_OW 48
// end ; stolypin :
4052: GO 4361
4054: LD_EXP 22
4058: DOUBLE
4059: EQUAL
4060: IFTRUE 4064
4062: GO 4360
4064: POP
// begin for i = 1 to 10 do
4065: LD_ADDR_VAR 0 3
4069: PUSH
4070: DOUBLE
4071: LD_INT 1
4073: DEC
4074: ST_TO_ADDR
4075: LD_INT 10
4077: PUSH
4078: FOR_TO
4079: IFFALSE 4118
// begin PrepareHuman ( false , 2 , skill + 1 ) ;
4081: LD_INT 0
4083: PPUSH
4084: LD_INT 2
4086: PPUSH
4087: LD_VAR 0 4
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: CALL_OW 380
// team := team ^ CreateHuman ;
4100: LD_ADDR_VAR 0 6
4104: PUSH
4105: LD_VAR 0 6
4109: PUSH
4110: CALL_OW 44
4114: ADD
4115: ST_TO_ADDR
// end ;
4116: GO 4078
4118: POP
4119: POP
// for i = 1 to 15 do
4120: LD_ADDR_VAR 0 3
4124: PUSH
4125: DOUBLE
4126: LD_INT 1
4128: DEC
4129: ST_TO_ADDR
4130: LD_INT 15
4132: PUSH
4133: FOR_TO
4134: IFFALSE 4192
// begin PrepareHuman ( false , [ 1 , 3 , 4 ] [ Rand ( 1 , 3 ) ] , skill ) ;
4136: LD_INT 0
4138: PPUSH
4139: LD_INT 1
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: LD_INT 4
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PUSH
4153: LD_INT 1
4155: PPUSH
4156: LD_INT 3
4158: PPUSH
4159: CALL_OW 12
4163: ARRAY
4164: PPUSH
4165: LD_VAR 0 4
4169: PPUSH
4170: CALL_OW 380
// team := team ^ CreateHuman ;
4174: LD_ADDR_VAR 0 6
4178: PUSH
4179: LD_VAR 0 6
4183: PUSH
4184: CALL_OW 44
4188: ADD
4189: ST_TO_ADDR
// end ;
4190: GO 4133
4192: POP
4193: POP
// SetTech ( tech_advmet , 3 , state_enabled ) ;
4194: LD_INT 34
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: CALL_OW 322
// vc_chassis := ru_medium_tracked ;
4207: LD_ADDR_OWVAR 37
4211: PUSH
4212: LD_INT 22
4214: ST_TO_ADDR
// vc_engine := engine_combustion ;
4215: LD_ADDR_OWVAR 39
4219: PUSH
4220: LD_INT 1
4222: ST_TO_ADDR
// vc_control := control_manual ;
4223: LD_ADDR_OWVAR 38
4227: PUSH
4228: LD_INT 1
4230: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
4231: LD_ADDR_OWVAR 40
4235: PUSH
4236: LD_INT 51
4238: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4239: LD_ADDR_OWVAR 41
4243: PUSH
4244: LD_INT 30
4246: ST_TO_ADDR
// veh := CreateVehicle ;
4247: LD_ADDR_VAR 0 7
4251: PUSH
4252: CALL_OW 45
4256: ST_TO_ADDR
// SetCargo ( veh , 1 , 100 ) ;
4257: LD_VAR 0 7
4261: PPUSH
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 100
4267: PPUSH
4268: CALL_OW 290
// PlaceUnitXY ( veh , 107 , 83 , false ) ;
4272: LD_VAR 0 7
4276: PPUSH
4277: LD_INT 107
4279: PPUSH
4280: LD_INT 83
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: CALL_OW 48
// vc_chassis := ru_medium_tracked ;
4290: LD_ADDR_OWVAR 37
4294: PUSH
4295: LD_INT 22
4297: ST_TO_ADDR
// vc_engine := engine_combustion ;
4298: LD_ADDR_OWVAR 39
4302: PUSH
4303: LD_INT 1
4305: ST_TO_ADDR
// vc_control := control_manual ;
4306: LD_ADDR_OWVAR 38
4310: PUSH
4311: LD_INT 1
4313: ST_TO_ADDR
// vc_weapon := ru_crane ;
4314: LD_ADDR_OWVAR 40
4318: PUSH
4319: LD_INT 52
4321: ST_TO_ADDR
// vc_fuel_battery := 30 ;
4322: LD_ADDR_OWVAR 41
4326: PUSH
4327: LD_INT 30
4329: ST_TO_ADDR
// veh := CreateVehicle ;
4330: LD_ADDR_VAR 0 7
4334: PUSH
4335: CALL_OW 45
4339: ST_TO_ADDR
// PlaceUnitXY ( veh , 115 , 96 , false ) ;
4340: LD_VAR 0 7
4344: PPUSH
4345: LD_INT 115
4347: PPUSH
4348: LD_INT 96
4350: PPUSH
4351: LD_INT 0
4353: PPUSH
4354: CALL_OW 48
// end ; end ;
4358: GO 4361
4360: POP
// if isTest then
4361: LD_EXP 1
4365: IFFALSE 4379
// tmp := team else
4367: LD_ADDR_VAR 0 5
4371: PUSH
4372: LD_VAR 0 6
4376: ST_TO_ADDR
4377: GO 4477
// tmp := CharacterSelection ( text , [ 10 , 9 , 8 ] [ Difficulty ] , [ 10 , 9 , 8 ] [ Difficulty ] , [ sel_not_hired , sel_change_class , sel_changeable ] ^ team , [ class_soldier , [ class_engineer , 1 ] , class_mechanic , class_scientistic ] ) ;
4379: LD_ADDR_VAR 0 5
4383: PUSH
4384: LD_STRING text
4386: PPUSH
4387: LD_INT 10
4389: PUSH
4390: LD_INT 9
4392: PUSH
4393: LD_INT 8
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: LIST
4400: PUSH
4401: LD_OWVAR 67
4405: ARRAY
4406: PPUSH
4407: LD_INT 10
4409: PUSH
4410: LD_INT 9
4412: PUSH
4413: LD_INT 8
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: LD_OWVAR 67
4425: ARRAY
4426: PPUSH
4427: LD_INT -2
4429: PUSH
4430: LD_INT -5
4432: PUSH
4433: LD_INT -3
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: PUSH
4441: LD_VAR 0 6
4445: ADD
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 2
4452: PUSH
4453: LD_INT 1
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 3
4462: PUSH
4463: LD_INT 4
4465: PUSH
4466: EMPTY
4467: LIST
4468: LIST
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 42
4476: ST_TO_ADDR
// PlaceUnitArea ( player_com , gaidar_base , false ) ;
4477: LD_EXP 25
4481: PPUSH
4482: LD_INT 9
4484: PPUSH
4485: LD_INT 0
4487: PPUSH
4488: CALL_OW 49
// SetClass ( tmp [ 1 ] , 2 ) ;
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 1
4499: ARRAY
4500: PPUSH
4501: LD_INT 2
4503: PPUSH
4504: CALL_OW 336
// for i = 1 to tmp do
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: DOUBLE
4514: LD_INT 1
4516: DEC
4517: ST_TO_ADDR
4518: LD_VAR 0 5
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4579
// if i < 4 then
4526: LD_VAR 0 3
4530: PUSH
4531: LD_INT 4
4533: LESS
4534: IFFALSE 4559
// PlaceUnitArea ( tmp [ i ] , gaidar_base , false ) else
4536: LD_VAR 0 5
4540: PUSH
4541: LD_VAR 0 3
4545: ARRAY
4546: PPUSH
4547: LD_INT 9
4549: PPUSH
4550: LD_INT 0
4552: PPUSH
4553: CALL_OW 49
4557: GO 4577
// SetSide ( tmp [ i ] , 6 ) ;
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: ARRAY
4569: PPUSH
4570: LD_INT 6
4572: PPUSH
4573: CALL_OW 235
4577: GO 4523
4579: POP
4580: POP
// player_squad := tmp ;
4581: LD_ADDR_EXP 23
4585: PUSH
4586: LD_VAR 0 5
4590: ST_TO_ADDR
// pl_counter := 4 ;
4591: LD_ADDR_EXP 24
4595: PUSH
4596: LD_INT 4
4598: ST_TO_ADDR
// MCN_AddApes ( ape_east , 5 , 1 ) ;
4599: LD_INT 17
4601: PPUSH
4602: LD_INT 5
4604: PPUSH
4605: LD_INT 1
4607: PPUSH
4608: CALL 18300 0 3
// end ;
4612: LD_VAR 0 2
4616: RET
// export Popov ; export function InitAction ; var commander ; begin
4617: LD_INT 0
4619: PPUSH
4620: PPUSH
// ChangeSideFog ( 6 , 3 ) ;
4621: LD_INT 6
4623: PPUSH
4624: LD_INT 3
4626: PPUSH
4627: CALL_OW 343
// CenterNowOnXY ( 1 , 1 ) ;
4631: LD_INT 1
4633: PPUSH
4634: LD_INT 1
4636: PPUSH
4637: CALL_OW 86
// uc_side := 6 ;
4641: LD_ADDR_OWVAR 20
4645: PUSH
4646: LD_INT 6
4648: ST_TO_ADDR
// Popov := NewCharacter ( Popov ) ;
4649: LD_ADDR_EXP 26
4653: PUSH
4654: LD_STRING Popov
4656: PPUSH
4657: CALL_OW 25
4661: ST_TO_ADDR
// Difficulty := GetMultiplayerSetting ( 0 ) ;
4662: LD_ADDR_OWVAR 67
4666: PUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 426
4674: ST_TO_ADDR
// if not Difficulty then
4675: LD_OWVAR 67
4679: NOT
4680: IFFALSE 4690
// Difficulty := 2 ;
4682: LD_ADDR_OWVAR 67
4686: PUSH
4687: LD_INT 2
4689: ST_TO_ADDR
// commander := GetMultiplayerSetting ( 1 ) ;
4690: LD_ADDR_VAR 0 2
4694: PUSH
4695: LD_INT 1
4697: PPUSH
4698: CALL_OW 426
4702: ST_TO_ADDR
// if not commander then
4703: LD_VAR 0 2
4707: NOT
4708: IFFALSE 4718
// commander := 1 ;
4710: LD_ADDR_VAR 0 2
4714: PUSH
4715: LD_INT 1
4717: ST_TO_ADDR
// InitCommanders ( commander ) ;
4718: LD_VAR 0 2
4722: PPUSH
4723: CALL 3137 0 1
// end ;
4727: LD_VAR 0 1
4731: RET
// every 1 1$45 trigger pl_counter < 12 do var i ;
4732: LD_EXP 24
4736: PUSH
4737: LD_INT 12
4739: LESS
4740: IFFALSE 4913
4742: GO 4744
4744: DISABLE
4745: LD_INT 0
4747: PPUSH
// begin enable ;
4748: ENABLE
// for i = pl_counter to pl_counter + 2 do
4749: LD_ADDR_VAR 0 1
4753: PUSH
4754: DOUBLE
4755: LD_EXP 24
4759: DEC
4760: ST_TO_ADDR
4761: LD_EXP 24
4765: PUSH
4766: LD_INT 2
4768: PLUS
4769: PUSH
4770: FOR_TO
4771: IFFALSE 4817
// begin PlaceUnitArea ( player_squad [ i ] , east_arr , false ) ;
4773: LD_EXP 23
4777: PUSH
4778: LD_VAR 0 1
4782: ARRAY
4783: PPUSH
4784: LD_INT 18
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: CALL_OW 49
// ComMoveXY ( player_squad [ i ] , 107 , 88 ) ;
4794: LD_EXP 23
4798: PUSH
4799: LD_VAR 0 1
4803: ARRAY
4804: PPUSH
4805: LD_INT 107
4807: PPUSH
4808: LD_INT 88
4810: PPUSH
4811: CALL_OW 111
// end ;
4815: GO 4770
4817: POP
4818: POP
// for i = pl_counter to pl_counter + 2 do
4819: LD_ADDR_VAR 0 1
4823: PUSH
4824: DOUBLE
4825: LD_EXP 24
4829: DEC
4830: ST_TO_ADDR
4831: LD_EXP 24
4835: PUSH
4836: LD_INT 2
4838: PLUS
4839: PUSH
4840: FOR_TO
4841: IFFALSE 4897
// begin repeat wait ( 0 0$01 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until GetDistUnitXY ( player_squad [ i ] , 107 , 88 ) < 6 ;
4850: LD_EXP 23
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: LD_INT 107
4863: PPUSH
4864: LD_INT 88
4866: PPUSH
4867: CALL_OW 297
4871: PUSH
4872: LD_INT 6
4874: LESS
4875: IFFALSE 4843
// SetSide ( player_squad [ i ] , 3 ) ;
4877: LD_EXP 23
4881: PUSH
4882: LD_VAR 0 1
4886: ARRAY
4887: PPUSH
4888: LD_INT 3
4890: PPUSH
4891: CALL_OW 235
// end ;
4895: GO 4840
4897: POP
4898: POP
// pl_counter := pl_counter + 3 ;
4899: LD_ADDR_EXP 24
4903: PUSH
4904: LD_EXP 24
4908: PUSH
4909: LD_INT 3
4911: PLUS
4912: ST_TO_ADDR
// end ;
4913: PPOPN 1
4915: END
// export function Dialog ; begin
4916: LD_INT 0
4918: PPUSH
// if not isTest then
4919: LD_EXP 1
4923: NOT
4924: IFFALSE 4946
// case query ( task ) of 1 :
4926: LD_STRING task
4928: PPUSH
4929: CALL_OW 97
4933: PUSH
4934: LD_INT 1
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// InGameOn ;
4946: CALL_OW 8
// CenterNowOnXY ( 107 , 84 ) ;
4950: LD_INT 107
4952: PPUSH
4953: LD_INT 84
4955: PPUSH
4956: CALL_OW 86
// if isTest then
4960: LD_EXP 1
4964: IFFALSE 4974
// dialogue_skipped := true ;
4966: LD_ADDR_OWVAR 59
4970: PUSH
4971: LD_INT 1
4973: ST_TO_ADDR
// player_depot := ComBuild ( player_squad [ 1 ] , b_depot , 96 , 79 , 2 ) ;
4974: LD_ADDR_EXP 11
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_INT 1
4986: ARRAY
4987: PPUSH
4988: LD_INT 0
4990: PPUSH
4991: LD_INT 96
4993: PPUSH
4994: LD_INT 79
4996: PPUSH
4997: LD_INT 2
4999: PPUSH
5000: CALL_OW 145
5004: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
5005: LD_INT 35
5007: PPUSH
5008: CALL_OW 67
// SayRadio ( Popov , DR1 ) ;
5012: LD_EXP 26
5016: PPUSH
5017: LD_STRING DR1
5019: PPUSH
5020: CALL_OW 94
// Wait ( 0 0$01 ) ;
5024: LD_INT 35
5026: PPUSH
5027: CALL_OW 67
// SayRadio ( Popov , DR2 ) ;
5031: LD_EXP 26
5035: PPUSH
5036: LD_STRING DR2
5038: PPUSH
5039: CALL_OW 94
// SayRadio ( Popov , DR3 ) ;
5043: LD_EXP 26
5047: PPUSH
5048: LD_STRING DR3
5050: PPUSH
5051: CALL_OW 94
// repeat Wait ( 0 0$01 ) ;
5055: LD_INT 35
5057: PPUSH
5058: CALL_OW 67
// until MCF_Get ( 3 , [ f_btype , b_depot ] ) or isTest ;
5062: LD_INT 3
5064: PPUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 0
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL 11587 0 2
5079: PUSH
5080: LD_EXP 1
5084: OR
5085: IFFALSE 5055
// InGameOff ;
5087: CALL_OW 9
// ChangeMissionObjectives ( C1 ) ;
5091: LD_STRING C1
5093: PPUSH
5094: CALL_OW 337
// repeat Wait ( 0 0$01 ) ;
5098: LD_INT 35
5100: PPUSH
5101: CALL_OW 67
// until BuildingStatus ( player_depot ) = bs_idle ;
5105: LD_EXP 11
5109: PPUSH
5110: CALL_OW 461
5114: PUSH
5115: LD_INT 2
5117: EQUAL
5118: IFFALSE 5098
// if not isTest then
5120: LD_EXP 1
5124: NOT
5125: IFFALSE 5147
// case query ( support ) of 1 :
5127: LD_STRING support
5129: PPUSH
5130: CALL_OW 97
5134: PUSH
5135: LD_INT 1
5137: DOUBLE
5138: EQUAL
5139: IFTRUE 5143
5141: GO 5146
5143: POP
// ; end ;
5144: GO 5147
5146: POP
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
5147: LD_INT 3
5149: PPUSH
5150: LD_INT 12
5152: PPUSH
5153: LD_INT 2
5155: PPUSH
5156: LD_INT 22
5158: PUSH
5159: LD_INT 3
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: LD_INT 30
5168: PUSH
5169: LD_INT 0
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 69
5184: PUSH
5185: LD_INT 1
5187: ARRAY
5188: PPUSH
5189: CALL_OW 468
// if player_com = stolypin then
5193: LD_EXP 25
5197: PUSH
5198: LD_EXP 22
5202: EQUAL
5203: IFFALSE 5232
// PrepareConvoy ( east_arr , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
5205: LD_INT 18
5207: PPUSH
5208: LD_INT 3
5210: PUSH
5211: LD_INT 3
5213: PUSH
5214: LD_INT 2
5216: PUSH
5217: EMPTY
5218: LIST
5219: LIST
5220: LIST
5221: PUSH
5222: LD_OWVAR 67
5226: ARRAY
5227: PPUSH
5228: CALL 6656 0 2
// end ;
5232: LD_VAR 0 1
5236: RET
// on ArtifactUsed ( side , button_type , x , y ) do begin if call and tick < 15 15$00 then
5237: LD_EXP 12
5241: PUSH
5242: LD_OWVAR 1
5246: PUSH
5247: LD_INT 31500
5249: LESS
5250: AND
5251: IFFALSE 5423
// case query ( call1 ) of 1 :
5253: LD_STRING call1
5255: PPUSH
5256: CALL_OW 97
5260: PUSH
5261: LD_INT 1
5263: DOUBLE
5264: EQUAL
5265: IFTRUE 5269
5267: GO 5411
5269: POP
// begin callUsed := true ;
5270: LD_ADDR_EXP 3
5274: PUSH
5275: LD_INT 1
5277: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5278: LD_INT 3
5280: PPUSH
5281: LD_INT 12
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: LD_EXP 11
5291: PPUSH
5292: CALL_OW 468
// call := false ;
5296: LD_ADDR_EXP 12
5300: PUSH
5301: LD_INT 0
5303: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5304: LD_EXP 26
5308: PPUSH
5309: LD_STRING DR6
5311: PPUSH
5312: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5316: LD_INT 6300
5318: PPUSH
5319: LD_INT 8400
5321: PPUSH
5322: CALL_OW 12
5326: PPUSH
5327: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , Rand ( 1 , 2 ) ) ;
5331: LD_INT 18
5333: PUSH
5334: LD_INT 19
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 1
5343: PPUSH
5344: LD_INT 2
5346: PPUSH
5347: CALL_OW 12
5351: ARRAY
5352: PPUSH
5353: LD_INT 1
5355: PPUSH
5356: LD_INT 2
5358: PPUSH
5359: CALL_OW 12
5363: PPUSH
5364: CALL 6656 0 2
// Wait ( Rand ( 12 12$00 , 17 17$00 ) ) ;
5368: LD_INT 25200
5370: PPUSH
5371: LD_INT 35700
5373: PPUSH
5374: CALL_OW 12
5378: PPUSH
5379: CALL_OW 67
// call := true ;
5383: LD_ADDR_EXP 12
5387: PUSH
5388: LD_INT 1
5390: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 12
5396: PPUSH
5397: LD_INT 2
5399: PPUSH
5400: LD_EXP 11
5404: PPUSH
5405: CALL_OW 468
// end ; 2 :
5409: GO 5423
5411: LD_INT 2
5413: DOUBLE
5414: EQUAL
5415: IFTRUE 5419
5417: GO 5422
5419: POP
// ; end ;
5420: GO 5423
5422: POP
// if call and tick >= 15 15$00 then
5423: LD_EXP 12
5427: PUSH
5428: LD_OWVAR 1
5432: PUSH
5433: LD_INT 31500
5435: GREATEREQUAL
5436: AND
5437: IFFALSE 5882
// case query ( call2 ) of 1 :
5439: LD_STRING call2
5441: PPUSH
5442: CALL_OW 97
5446: PUSH
5447: LD_INT 1
5449: DOUBLE
5450: EQUAL
5451: IFTRUE 5455
5453: GO 5699
5455: POP
// begin callUsed := true ;
5456: LD_ADDR_EXP 3
5460: PUSH
5461: LD_INT 1
5463: ST_TO_ADDR
// call := false ;
5464: LD_ADDR_EXP 12
5468: PUSH
5469: LD_INT 0
5471: ST_TO_ADDR
// if MCF_Get ( 1 , [ f_type , unit_building ] ) and MCF_Get ( 4 , [ f_type , unit_building ] ) then
5472: LD_INT 1
5474: PPUSH
5475: LD_INT 21
5477: PUSH
5478: LD_INT 3
5480: PUSH
5481: EMPTY
5482: LIST
5483: LIST
5484: PPUSH
5485: CALL 11587 0 2
5489: PUSH
5490: LD_INT 4
5492: PPUSH
5493: LD_INT 21
5495: PUSH
5496: LD_INT 3
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PPUSH
5503: CALL 11587 0 2
5507: AND
5508: IFFALSE 5556
// PrepareAttack ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5510: LD_INT 18
5512: PUSH
5513: LD_INT 19
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PUSH
5520: LD_INT 1
5522: PPUSH
5523: LD_INT 2
5525: PPUSH
5526: CALL_OW 12
5530: ARRAY
5531: PPUSH
5532: LD_INT 5
5534: PUSH
5535: LD_INT 4
5537: PUSH
5538: LD_INT 4
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_OWVAR 67
5550: ARRAY
5551: PPUSH
5552: CALL 6417 0 2
// if MCF_Get ( 1 , [ f_type , unit_building ] ) = 0 then
5556: LD_INT 1
5558: PPUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 3
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PPUSH
5569: CALL 11587 0 2
5573: PUSH
5574: LD_INT 0
5576: EQUAL
5577: IFFALSE 5606
// PrepareAttack ( south_arr , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
5579: LD_INT 19
5581: PPUSH
5582: LD_INT 5
5584: PUSH
5585: LD_INT 4
5587: PUSH
5588: LD_INT 3
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: LIST
5595: PUSH
5596: LD_OWVAR 67
5600: ARRAY
5601: PPUSH
5602: CALL 6417 0 2
// if MCF_Get ( 4 , [ f_type , unit_building ] ) = 0 then
5606: LD_INT 4
5608: PPUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 3
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL 11587 0 2
5623: PUSH
5624: LD_INT 0
5626: EQUAL
5627: IFFALSE 5656
// PrepareAttack ( east_arr , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
5629: LD_INT 18
5631: PPUSH
5632: LD_INT 5
5634: PUSH
5635: LD_INT 4
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: LIST
5645: PUSH
5646: LD_OWVAR 67
5650: ARRAY
5651: PPUSH
5652: CALL 6417 0 2
// Wait ( Rand ( 5 5$00 , 11 11$00 ) ) ;
5656: LD_INT 10500
5658: PPUSH
5659: LD_INT 23100
5661: PPUSH
5662: CALL_OW 12
5666: PPUSH
5667: CALL_OW 67
// call := true ;
5671: LD_ADDR_EXP 12
5675: PUSH
5676: LD_INT 1
5678: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5679: LD_INT 3
5681: PPUSH
5682: LD_INT 12
5684: PPUSH
5685: LD_INT 2
5687: PPUSH
5688: LD_EXP 11
5692: PPUSH
5693: CALL_OW 468
// end ; 2 :
5697: GO 5882
5699: LD_INT 2
5701: DOUBLE
5702: EQUAL
5703: IFTRUE 5707
5705: GO 5870
5707: POP
// begin callUsed := true ;
5708: LD_ADDR_EXP 3
5712: PUSH
5713: LD_INT 1
5715: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_gray , player_depot ) ;
5716: LD_INT 3
5718: PPUSH
5719: LD_INT 12
5721: PPUSH
5722: LD_INT 1
5724: PPUSH
5725: LD_EXP 11
5729: PPUSH
5730: CALL_OW 468
// call := false ;
5734: LD_ADDR_EXP 12
5738: PUSH
5739: LD_INT 0
5741: ST_TO_ADDR
// SayRadio ( Popov , DR6 ) ;
5742: LD_EXP 26
5746: PPUSH
5747: LD_STRING DR6
5749: PPUSH
5750: CALL_OW 94
// Wait ( Rand ( 3 3$00 , 4 4$00 ) ) ;
5754: LD_INT 6300
5756: PPUSH
5757: LD_INT 8400
5759: PPUSH
5760: CALL_OW 12
5764: PPUSH
5765: CALL_OW 67
// PrepareConvoy ( [ east_arr , south_arr ] [ Rand ( 1 , 2 ) ] , [ 3 , 2 , 2 ] [ Difficulty ] - Rand ( 0 , 1 ) ) ;
5769: LD_INT 18
5771: PUSH
5772: LD_INT 19
5774: PUSH
5775: EMPTY
5776: LIST
5777: LIST
5778: PUSH
5779: LD_INT 1
5781: PPUSH
5782: LD_INT 2
5784: PPUSH
5785: CALL_OW 12
5789: ARRAY
5790: PPUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 2
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_OWVAR 67
5809: ARRAY
5810: PUSH
5811: LD_INT 0
5813: PPUSH
5814: LD_INT 1
5816: PPUSH
5817: CALL_OW 12
5821: MINUS
5822: PPUSH
5823: CALL 6656 0 2
// Wait ( Rand ( 17 17$00 , 21 21$00 ) ) ;
5827: LD_INT 35700
5829: PPUSH
5830: LD_INT 44100
5832: PPUSH
5833: CALL_OW 12
5837: PPUSH
5838: CALL_OW 67
// call := true ;
5842: LD_ADDR_EXP 12
5846: PUSH
5847: LD_INT 1
5849: ST_TO_ADDR
// SetArtifactUse ( 3 , art_use_exclamation , art_instant , player_depot ) ;
5850: LD_INT 3
5852: PPUSH
5853: LD_INT 12
5855: PPUSH
5856: LD_INT 2
5858: PPUSH
5859: LD_EXP 11
5863: PPUSH
5864: CALL_OW 468
// end ; 3 :
5868: GO 5882
5870: LD_INT 3
5872: DOUBLE
5873: EQUAL
5874: IFTRUE 5878
5876: GO 5881
5878: POP
// ; end ;
5879: GO 5882
5881: POP
// end ;
5882: PPOPN 4
5884: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) = 0 do
5885: LD_INT 22
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 69
5913: PUSH
5914: LD_INT 0
5916: EQUAL
5917: PUSH
5918: LD_INT 22
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: PUSH
5928: LD_INT 21
5930: PUSH
5931: LD_INT 1
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: PPUSH
5942: CALL_OW 69
5946: PUSH
5947: LD_INT 0
5949: EQUAL
5950: AND
5951: IFFALSE 6255
5953: GO 5955
5955: DISABLE
// begin DialogueOn ;
5956: CALL_OW 6
// SayRadio ( Popov , DR7 ) ;
5960: LD_EXP 26
5964: PPUSH
5965: LD_STRING DR7
5967: PPUSH
5968: CALL_OW 94
// case player_com of Gorki :
5972: LD_EXP 25
5976: PUSH
5977: LD_EXP 21
5981: DOUBLE
5982: EQUAL
5983: IFTRUE 5987
5985: GO 5997
5987: POP
// SetAchievement ( ACH_GORKI ) ; Stolypin :
5988: LD_STRING ACH_GORKI
5990: PPUSH
5991: CALL_OW 543
5995: GO 6058
5997: LD_EXP 22
6001: DOUBLE
6002: EQUAL
6003: IFTRUE 6007
6005: GO 6017
6007: POP
// SetAchievement ( ACH_STOLYP ) ; Davidov :
6008: LD_STRING ACH_STOLYP
6010: PPUSH
6011: CALL_OW 543
6015: GO 6058
6017: LD_EXP 20
6021: DOUBLE
6022: EQUAL
6023: IFTRUE 6027
6025: GO 6037
6027: POP
// SetAchievement ( ACH_DAVIDOV ) ; Gladkov :
6028: LD_STRING ACH_DAVIDOV
6030: PPUSH
6031: CALL_OW 543
6035: GO 6058
6037: LD_EXP 19
6041: DOUBLE
6042: EQUAL
6043: IFTRUE 6047
6045: GO 6057
6047: POP
// SetAchievement ( ACH_GLADKOV ) ; end ;
6048: LD_STRING ACH_GLADKOV
6050: PPUSH
6051: CALL_OW 543
6055: GO 6058
6057: POP
// if not callUsed then
6058: LD_EXP 3
6062: NOT
6063: IFFALSE 6072
// SetAchievement ( ACH_NOSUPP ) ;
6065: LD_STRING ACH_NOSUPP
6067: PPUSH
6068: CALL_OW 543
// if ( tick < [ 55 55$30 , 45 45$30 , 42 42$30 ] [ Difficulty ] ) then
6072: LD_OWVAR 1
6076: PUSH
6077: LD_INT 116550
6079: PUSH
6080: LD_INT 95550
6082: PUSH
6083: LD_INT 89250
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: PUSH
6091: LD_OWVAR 67
6095: ARRAY
6096: LESS
6097: IFFALSE 6111
// AddMedal ( med1 , 1 ) else
6099: LD_STRING med1
6101: PPUSH
6102: LD_INT 1
6104: PPUSH
6105: CALL_OW 101
6109: GO 6122
// AddMedal ( med1 , - 1 ) ;
6111: LD_STRING med1
6113: PPUSH
6114: LD_INT 1
6116: NEG
6117: PPUSH
6118: CALL_OW 101
// if FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_type , unit_building ] ] ) = 0 then
6122: LD_INT 81
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 21
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PUSH
6151: LD_INT 0
6153: EQUAL
6154: IFFALSE 6168
// AddMedal ( med3 , 1 ) else
6156: LD_STRING med3
6158: PPUSH
6159: LD_INT 1
6161: PPUSH
6162: CALL_OW 101
6166: GO 6179
// AddMedal ( med3 , - 1 ) ;
6168: LD_STRING med3
6170: PPUSH
6171: LD_INT 1
6173: NEG
6174: PPUSH
6175: CALL_OW 101
// if player_loss = 0 then
6179: LD_EXP 10
6183: PUSH
6184: LD_INT 0
6186: EQUAL
6187: IFFALSE 6201
// AddMedal ( med2 , 1 ) else
6189: LD_STRING med2
6191: PPUSH
6192: LD_INT 1
6194: PPUSH
6195: CALL_OW 101
6199: GO 6244
// if player_loss > 0 and player_loss < 3 then
6201: LD_EXP 10
6205: PUSH
6206: LD_INT 0
6208: GREATER
6209: PUSH
6210: LD_EXP 10
6214: PUSH
6215: LD_INT 3
6217: LESS
6218: AND
6219: IFFALSE 6233
// AddMedal ( med2 , 2 ) else
6221: LD_STRING med2
6223: PPUSH
6224: LD_INT 2
6226: PPUSH
6227: CALL_OW 101
6231: GO 6244
// AddMedal ( med2 , - 1 ) ;
6233: LD_STRING med2
6235: PPUSH
6236: LD_INT 1
6238: NEG
6239: PPUSH
6240: CALL_OW 101
// GiveMedals ( MAIN ) ;
6244: LD_STRING MAIN
6246: PPUSH
6247: CALL_OW 102
// YouWin ;
6251: CALL_OW 103
// end ;
6255: END
// every 0 0$01 trigger IsDead ( player_com ) do
6256: LD_EXP 25
6260: PPUSH
6261: CALL_OW 301
6265: IFFALSE 6332
6267: GO 6269
6269: DISABLE
// begin if IsLive ( Houten ) then
6270: LD_EXP 4
6274: PPUSH
6275: CALL_OW 300
6279: IFFALSE 6295
// SayRadio ( Houten , DJ5 ) else
6281: LD_EXP 4
6285: PPUSH
6286: LD_STRING DJ5
6288: PPUSH
6289: CALL_OW 94
6293: GO 6318
// if IsLive ( Brown ) then
6295: LD_EXP 5
6299: PPUSH
6300: CALL_OW 300
6304: IFFALSE 6318
// SayRadio ( Brown , DS5 ) ;
6306: LD_EXP 5
6310: PPUSH
6311: LD_STRING DS5
6313: PPUSH
6314: CALL_OW 94
// Wait ( 0 0$01 ) ;
6318: LD_INT 35
6320: PPUSH
6321: CALL_OW 67
// YouLost ( dead ) ;
6325: LD_STRING dead
6327: PPUSH
6328: CALL_OW 104
// end ;
6332: END
// every 0 0$01 trigger IsDead ( player_depot ) and not isTest do
6333: LD_EXP 11
6337: PPUSH
6338: CALL_OW 301
6342: PUSH
6343: LD_EXP 1
6347: NOT
6348: AND
6349: IFFALSE 6416
6351: GO 6353
6353: DISABLE
// begin if IsLive ( Brown ) then
6354: LD_EXP 5
6358: PPUSH
6359: CALL_OW 300
6363: IFFALSE 6379
// SayRadio ( Brown , DS5 ) else
6365: LD_EXP 5
6369: PPUSH
6370: LD_STRING DS5
6372: PPUSH
6373: CALL_OW 94
6377: GO 6402
// if IsLive ( Houten ) then
6379: LD_EXP 4
6383: PPUSH
6384: CALL_OW 300
6388: IFFALSE 6402
// SayRadio ( Houten , DJ5 ) ;
6390: LD_EXP 4
6394: PPUSH
6395: LD_STRING DJ5
6397: PPUSH
6398: CALL_OW 94
// Wait ( 0 0$01 ) ;
6402: LD_INT 35
6404: PPUSH
6405: CALL_OW 67
// YouLost ( depot ) ;
6409: LD_STRING depot
6411: PPUSH
6412: CALL_OW 104
// end ;
6416: END
// export function PrepareAttack ( area , n ) ; var i , un ; begin
6417: LD_INT 0
6419: PPUSH
6420: PPUSH
6421: PPUSH
// for i = 1 to n do
6422: LD_ADDR_VAR 0 4
6426: PUSH
6427: DOUBLE
6428: LD_INT 1
6430: DEC
6431: ST_TO_ADDR
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_TO
6438: IFFALSE 6641
// begin uc_side := 6 ;
6440: LD_ADDR_OWVAR 20
6444: PUSH
6445: LD_INT 6
6447: ST_TO_ADDR
// uc_nation := 3 ;
6448: LD_ADDR_OWVAR 21
6452: PUSH
6453: LD_INT 3
6455: ST_TO_ADDR
// vc_chassis := [ ru_heavy_wheeled , ru_medium_tracked ] [ Rand ( 1 , 2 ) ] ;
6456: LD_ADDR_OWVAR 37
6460: PUSH
6461: LD_INT 23
6463: PUSH
6464: LD_INT 22
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: PUSH
6471: LD_INT 1
6473: PPUSH
6474: LD_INT 2
6476: PPUSH
6477: CALL_OW 12
6481: ARRAY
6482: ST_TO_ADDR
// vc_control := control_computer ;
6483: LD_ADDR_OWVAR 38
6487: PUSH
6488: LD_INT 3
6490: ST_TO_ADDR
// vc_engine := engine_siberite ;
6491: LD_ADDR_OWVAR 39
6495: PUSH
6496: LD_INT 3
6498: ST_TO_ADDR
// vc_weapon := [ ru_gatling_gun , ru_gun , ru_gun ] [ Rand ( 1 , 3 ) ] ;
6499: LD_ADDR_OWVAR 40
6503: PUSH
6504: LD_INT 43
6506: PUSH
6507: LD_INT 44
6509: PUSH
6510: LD_INT 44
6512: PUSH
6513: EMPTY
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: LD_INT 1
6520: PPUSH
6521: LD_INT 3
6523: PPUSH
6524: CALL_OW 12
6528: ARRAY
6529: ST_TO_ADDR
// un := CreateVehicle ;
6530: LD_ADDR_VAR 0 5
6534: PUSH
6535: CALL_OW 45
6539: ST_TO_ADDR
// case area of east_arr :
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 18
6547: DOUBLE
6548: EQUAL
6549: IFTRUE 6553
6551: GO 6588
6553: POP
// begin PlaceUnitArea ( un , area , false ) ;
6554: LD_VAR 0 5
6558: PPUSH
6559: LD_VAR 0 1
6563: PPUSH
6564: LD_INT 0
6566: PPUSH
6567: CALL_OW 49
// ComMoveXY ( un , 79 , 33 ) ;
6571: LD_VAR 0 5
6575: PPUSH
6576: LD_INT 79
6578: PPUSH
6579: LD_INT 33
6581: PPUSH
6582: CALL_OW 111
// end ; south_arr :
6586: GO 6632
6588: LD_INT 19
6590: DOUBLE
6591: EQUAL
6592: IFTRUE 6596
6594: GO 6631
6596: POP
// begin PlaceUnitArea ( un , area , false ) ;
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 1
6606: PPUSH
6607: LD_INT 0
6609: PPUSH
6610: CALL_OW 49
// ComMoveXY ( un , 131 , 148 ) ;
6614: LD_VAR 0 5
6618: PPUSH
6619: LD_INT 131
6621: PPUSH
6622: LD_INT 148
6624: PPUSH
6625: CALL_OW 111
// end ; end ;
6629: GO 6632
6631: POP
// Wait ( 0 0$02 ) ;
6632: LD_INT 70
6634: PPUSH
6635: CALL_OW 67
// end ;
6639: GO 6437
6641: POP
6642: POP
// pink_attack := true ;
6643: LD_ADDR_EXP 13
6647: PUSH
6648: LD_INT 1
6650: ST_TO_ADDR
// end ;
6651: LD_VAR 0 3
6655: RET
// export function PrepareConvoy ( area , n ) ; var i , un ; begin
6656: LD_INT 0
6658: PPUSH
6659: PPUSH
6660: PPUSH
// for i = 1 to n do
6661: LD_ADDR_VAR 0 4
6665: PUSH
6666: DOUBLE
6667: LD_INT 1
6669: DEC
6670: ST_TO_ADDR
6671: LD_VAR 0 2
6675: PUSH
6676: FOR_TO
6677: IFFALSE 6903
// begin uc_side := 6 ;
6679: LD_ADDR_OWVAR 20
6683: PUSH
6684: LD_INT 6
6686: ST_TO_ADDR
// uc_nation := 3 ;
6687: LD_ADDR_OWVAR 21
6691: PUSH
6692: LD_INT 3
6694: ST_TO_ADDR
// PrepareHuman ( false , 3 , 4 ) ;
6695: LD_INT 0
6697: PPUSH
6698: LD_INT 3
6700: PPUSH
6701: LD_INT 4
6703: PPUSH
6704: CALL_OW 380
// vc_chassis := ru_medium_tracked ;
6708: LD_ADDR_OWVAR 37
6712: PUSH
6713: LD_INT 22
6715: ST_TO_ADDR
// vc_control := control_manual ;
6716: LD_ADDR_OWVAR 38
6720: PUSH
6721: LD_INT 1
6723: ST_TO_ADDR
// vc_engine := engine_combustion ;
6724: LD_ADDR_OWVAR 39
6728: PUSH
6729: LD_INT 1
6731: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
6732: LD_ADDR_OWVAR 40
6736: PUSH
6737: LD_INT 51
6739: ST_TO_ADDR
// vc_fuel_battery := 50 ;
6740: LD_ADDR_OWVAR 41
6744: PUSH
6745: LD_INT 50
6747: ST_TO_ADDR
// un := CreateVehicle ;
6748: LD_ADDR_VAR 0 5
6752: PUSH
6753: CALL_OW 45
6757: ST_TO_ADDR
// case area of east_arr :
6758: LD_VAR 0 1
6762: PUSH
6763: LD_INT 18
6765: DOUBLE
6766: EQUAL
6767: IFTRUE 6771
6769: GO 6786
6771: POP
// SetDir ( un , 4 ) ; south_arr :
6772: LD_VAR 0 5
6776: PPUSH
6777: LD_INT 4
6779: PPUSH
6780: CALL_OW 233
6784: GO 6810
6786: LD_INT 19
6788: DOUBLE
6789: EQUAL
6790: IFTRUE 6794
6792: GO 6809
6794: POP
// SetDir ( un , 5 ) ; end ;
6795: LD_VAR 0 5
6799: PPUSH
6800: LD_INT 5
6802: PPUSH
6803: CALL_OW 233
6807: GO 6810
6809: POP
// PlaceUnitArea ( un , area , false ) ;
6810: LD_VAR 0 5
6814: PPUSH
6815: LD_VAR 0 1
6819: PPUSH
6820: LD_INT 0
6822: PPUSH
6823: CALL_OW 49
// PlaceHumanInUnit ( CreateHuman , un ) ;
6827: CALL_OW 44
6831: PPUSH
6832: LD_VAR 0 5
6836: PPUSH
6837: CALL_OW 52
// SetCargo ( un , mat_cans , 100 ) ;
6841: LD_VAR 0 5
6845: PPUSH
6846: LD_INT 1
6848: PPUSH
6849: LD_INT 100
6851: PPUSH
6852: CALL_OW 290
// ComMoveXY ( un , 106 , 88 ) ;
6856: LD_VAR 0 5
6860: PPUSH
6861: LD_INT 106
6863: PPUSH
6864: LD_INT 88
6866: PPUSH
6867: CALL_OW 111
// AddComUnload ( un ) ;
6871: LD_VAR 0 5
6875: PPUSH
6876: CALL_OW 219
// AddComMoveToArea ( un , area ) ;
6880: LD_VAR 0 5
6884: PPUSH
6885: LD_VAR 0 1
6889: PPUSH
6890: CALL_OW 173
// Wait ( 0 0$02 ) ;
6894: LD_INT 70
6896: PPUSH
6897: CALL_OW 67
// end ;
6901: GO 6676
6903: POP
6904: POP
// Wait ( 0 0$05 ) ;
6905: LD_INT 175
6907: PPUSH
6908: CALL_OW 67
// while ( MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) ) do
6912: LD_INT 6
6914: PPUSH
6915: LD_INT 34
6917: PUSH
6918: LD_INT 51
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: PPUSH
6925: CALL 11587 0 2
6929: IFFALSE 7117
// begin wait ( 0 0$01 ) ;
6931: LD_INT 35
6933: PPUSH
6934: CALL_OW 67
// for i in MCF_Get ( 6 , [ f_weapon , ru_cargo_bay ] ) do
6938: LD_ADDR_VAR 0 4
6942: PUSH
6943: LD_INT 6
6945: PPUSH
6946: LD_INT 34
6948: PUSH
6949: LD_INT 51
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: CALL 11587 0 2
6960: PUSH
6961: FOR_IN
6962: IFFALSE 7113
// begin if IsInArea ( i , gaidar_base ) and GetSex ( GetDriver ( i ) ) = sex_male and dialog_trans then
6964: LD_VAR 0 4
6968: PPUSH
6969: LD_INT 9
6971: PPUSH
6972: CALL_OW 308
6976: PUSH
6977: LD_VAR 0 4
6981: PPUSH
6982: CALL 31695 0 1
6986: PPUSH
6987: CALL_OW 258
6991: PUSH
6992: LD_INT 1
6994: EQUAL
6995: AND
6996: PUSH
6997: LD_EXP 9
7001: AND
7002: IFFALSE 7029
// begin Say ( GetDriver ( i ) , Dtran ) ;
7004: LD_VAR 0 4
7008: PPUSH
7009: CALL 31695 0 1
7013: PPUSH
7014: LD_STRING Dtran
7016: PPUSH
7017: CALL_OW 88
// dialog_trans := false ;
7021: LD_ADDR_EXP 9
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// end ; if IsIdle ( i ) then
7029: LD_VAR 0 4
7033: PPUSH
7034: CALL_OW 316
7038: IFFALSE 7054
// ComMoveToArea ( i , area ) ;
7040: LD_VAR 0 4
7044: PPUSH
7045: LD_VAR 0 1
7049: PPUSH
7050: CALL_OW 113
// if IsInArea ( i , area ) and GetCargo ( i , mat_cans ) = 0 then
7054: LD_VAR 0 4
7058: PPUSH
7059: LD_VAR 0 1
7063: PPUSH
7064: CALL_OW 308
7068: PUSH
7069: LD_VAR 0 4
7073: PPUSH
7074: LD_INT 1
7076: PPUSH
7077: CALL_OW 289
7081: PUSH
7082: LD_INT 0
7084: EQUAL
7085: AND
7086: IFFALSE 7111
// begin RemoveUnit ( GetDriver ( i ) ) ;
7088: LD_VAR 0 4
7092: PPUSH
7093: CALL 31695 0 1
7097: PPUSH
7098: CALL_OW 64
// RemoveUnit ( i ) ;
7102: LD_VAR 0 4
7106: PPUSH
7107: CALL_OW 64
// end ; end ;
7111: GO 6961
7113: POP
7114: POP
// end ;
7115: GO 6912
// end ;
7117: LD_VAR 0 3
7121: RET
// export function PrepareAlfaAttack ( area , n ) ; var i , un , ch ; begin
7122: LD_INT 0
7124: PPUSH
7125: PPUSH
7126: PPUSH
7127: PPUSH
// if isTest then
7128: LD_EXP 1
7132: IFFALSE 7136
// exit ;
7134: GO 7525
// for i = 1 to n do
7136: LD_ADDR_VAR 0 4
7140: PUSH
7141: DOUBLE
7142: LD_INT 1
7144: DEC
7145: ST_TO_ADDR
7146: LD_VAR 0 2
7150: PUSH
7151: FOR_TO
7152: IFFALSE 7384
// begin uc_side := 8 ;
7154: LD_ADDR_OWVAR 20
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// uc_nation := 1 ;
7162: LD_ADDR_OWVAR 21
7166: PUSH
7167: LD_INT 1
7169: ST_TO_ADDR
// ch := [ us_medium_tracked , us_heavy_tracked , us_heavy_tracked ] [ Rand ( 1 , Difficulty ) ] ;
7170: LD_ADDR_VAR 0 6
7174: PUSH
7175: LD_INT 3
7177: PUSH
7178: LD_INT 4
7180: PUSH
7181: LD_INT 4
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: PUSH
7189: LD_INT 1
7191: PPUSH
7192: LD_OWVAR 67
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// vc_chassis := ch ;
7203: LD_ADDR_OWVAR 37
7207: PUSH
7208: LD_VAR 0 6
7212: ST_TO_ADDR
// vc_control := control_computer ;
7213: LD_ADDR_OWVAR 38
7217: PUSH
7218: LD_INT 3
7220: ST_TO_ADDR
// vc_engine := engine_combustion ;
7221: LD_ADDR_OWVAR 39
7225: PUSH
7226: LD_INT 1
7228: ST_TO_ADDR
// if ch = us_medium_tracked then
7229: LD_VAR 0 6
7233: PUSH
7234: LD_INT 3
7236: EQUAL
7237: IFFALSE 7284
// vc_weapon := [ us_light_gun , us_gatling_gun , us_double_gun , us_rocket_launcher ] [ Rand ( Difficulty , Difficulty + 1 ) ] else
7239: LD_ADDR_OWVAR 40
7243: PUSH
7244: LD_INT 3
7246: PUSH
7247: LD_INT 4
7249: PUSH
7250: LD_INT 5
7252: PUSH
7253: LD_INT 7
7255: PUSH
7256: EMPTY
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: PPUSH
7267: LD_OWVAR 67
7271: PUSH
7272: LD_INT 1
7274: PLUS
7275: PPUSH
7276: CALL_OW 12
7280: ARRAY
7281: ST_TO_ADDR
7282: GO 7325
// vc_weapon := [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_rocket_launcher ] [ Rand ( 1 , Difficulty + 1 ) ] ;
7284: LD_ADDR_OWVAR 40
7288: PUSH
7289: LD_INT 5
7291: PUSH
7292: LD_INT 6
7294: PUSH
7295: LD_INT 7
7297: PUSH
7298: LD_INT 7
7300: PUSH
7301: EMPTY
7302: LIST
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_INT 1
7309: PPUSH
7310: LD_OWVAR 67
7314: PUSH
7315: LD_INT 1
7317: PLUS
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7325: LD_ADDR_OWVAR 41
7329: PUSH
7330: LD_INT 70
7332: ST_TO_ADDR
// un := CreateVehicle ;
7333: LD_ADDR_VAR 0 5
7337: PUSH
7338: CALL_OW 45
7342: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7343: LD_VAR 0 5
7347: PPUSH
7348: LD_VAR 0 1
7352: PPUSH
7353: LD_INT 0
7355: PPUSH
7356: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7360: LD_VAR 0 5
7364: PPUSH
7365: LD_INT 65
7367: PPUSH
7368: LD_INT 9
7370: PPUSH
7371: CALL_OW 111
// Wait ( 0 0$02 ) ;
7375: LD_INT 70
7377: PPUSH
7378: CALL_OW 67
// end ;
7382: GO 7151
7384: POP
7385: POP
// if Prob ( [ 90 , 80 , 70 ] [ Difficulty ] ) then
7386: LD_INT 90
7388: PUSH
7389: LD_INT 80
7391: PUSH
7392: LD_INT 70
7394: PUSH
7395: EMPTY
7396: LIST
7397: LIST
7398: LIST
7399: PUSH
7400: LD_OWVAR 67
7404: ARRAY
7405: PPUSH
7406: CALL_OW 13
7410: IFFALSE 7517
// begin uc_side := 8 ;
7412: LD_ADDR_OWVAR 20
7416: PUSH
7417: LD_INT 8
7419: ST_TO_ADDR
// uc_nation := 1 ;
7420: LD_ADDR_OWVAR 21
7424: PUSH
7425: LD_INT 1
7427: ST_TO_ADDR
// vc_chassis := us_heavy_tracked ;
7428: LD_ADDR_OWVAR 37
7432: PUSH
7433: LD_INT 4
7435: ST_TO_ADDR
// vc_control := control_computer ;
7436: LD_ADDR_OWVAR 38
7440: PUSH
7441: LD_INT 3
7443: ST_TO_ADDR
// vc_engine := engine_combustion ;
7444: LD_ADDR_OWVAR 39
7448: PUSH
7449: LD_INT 1
7451: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7452: LD_ADDR_OWVAR 40
7456: PUSH
7457: LD_INT 14
7459: ST_TO_ADDR
// vc_fuel_battery := 70 ;
7460: LD_ADDR_OWVAR 41
7464: PUSH
7465: LD_INT 70
7467: ST_TO_ADDR
// un := CreateVehicle ;
7468: LD_ADDR_VAR 0 5
7472: PUSH
7473: CALL_OW 45
7477: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
7478: LD_VAR 0 5
7482: PPUSH
7483: LD_VAR 0 1
7487: PPUSH
7488: LD_INT 0
7490: PPUSH
7491: CALL_OW 49
// ComMoveXY ( un , 65 , 9 ) ;
7495: LD_VAR 0 5
7499: PPUSH
7500: LD_INT 65
7502: PPUSH
7503: LD_INT 9
7505: PPUSH
7506: CALL_OW 111
// Wait ( 0 0$02 ) ;
7510: LD_INT 70
7512: PPUSH
7513: CALL_OW 67
// end ; alfa_support := true ;
7517: LD_ADDR_EXP 14
7521: PUSH
7522: LD_INT 1
7524: ST_TO_ADDR
// end ;
7525: LD_VAR 0 3
7529: RET
// every 0 0$01 trigger tick > [ 10 10$00 , 9 9$00 , 8 8$00 ] [ Difficulty ] do
7530: LD_OWVAR 1
7534: PUSH
7535: LD_INT 21000
7537: PUSH
7538: LD_INT 18900
7540: PUSH
7541: LD_INT 16800
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: LIST
7548: PUSH
7549: LD_OWVAR 67
7553: ARRAY
7554: GREATER
7555: IFFALSE 7639
7557: GO 7559
7559: DISABLE
// begin repeat SayRadio ( Popov , DR5 ) ;
7560: LD_EXP 26
7564: PPUSH
7565: LD_STRING DR5
7567: PPUSH
7568: CALL_OW 94
// wait ( Rand ( 0 0$30 , 2 2$00 ) ) ;
7572: LD_INT 1050
7574: PPUSH
7575: LD_INT 4200
7577: PPUSH
7578: CALL_OW 12
7582: PPUSH
7583: CALL_OW 67
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 8 ] [ Difficulty ] ) ;
7587: LD_INT 20
7589: PPUSH
7590: LD_INT 5
7592: PUSH
7593: LD_INT 6
7595: PUSH
7596: LD_INT 8
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: PUSH
7604: LD_OWVAR 67
7608: ARRAY
7609: PPUSH
7610: CALL 7122 0 2
// wait ( rand ( 4 4$00 , 6 6$00 ) ) ;
7614: LD_INT 8400
7616: PPUSH
7617: LD_INT 12600
7619: PPUSH
7620: CALL_OW 12
7624: PPUSH
7625: CALL_OW 67
// until tick >= 120 120$00 ;
7629: LD_OWVAR 1
7633: PUSH
7634: LD_INT 252000
7636: GREATEREQUAL
7637: IFFALSE 7560
// end ; end_of_file
7639: END
// export lines_counter , lines_break_limit , lines_break_type , show_line_index , tick_log ; export function LogInit ( ) ; begin
7640: LD_INT 0
7642: PPUSH
// enable_addtolog := isTest ;
7643: LD_ADDR_OWVAR 81
7647: PUSH
7648: LD_EXP 1
7652: ST_TO_ADDR
// lines_break_limit := 5 ;
7653: LD_ADDR_EXP 28
7657: PUSH
7658: LD_INT 5
7660: ST_TO_ADDR
// lines_break_type := --- ;
7661: LD_ADDR_EXP 29
7665: PUSH
7666: LD_STRING ---
7668: ST_TO_ADDR
// lines_counter := 0 ;
7669: LD_ADDR_EXP 27
7673: PUSH
7674: LD_INT 0
7676: ST_TO_ADDR
// show_line_index := true ;
7677: LD_ADDR_EXP 30
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// tick_log := true ;
7685: LD_ADDR_EXP 31
7689: PUSH
7690: LD_INT 1
7692: ST_TO_ADDR
// AddToLog ( ----------SAND OF SIBERIA LOG---------- ) ;
7693: LD_STRING ----------SAND OF SIBERIA LOG----------
7695: PPUSH
7696: CALL_OW 561
// AddToLog ( Map Name:  & mission_name ) ;
7700: LD_STRING Map Name: 
7702: PUSH
7703: LD_OWVAR 68
7707: STR
7708: PPUSH
7709: CALL_OW 561
// AddToLog ( Map Number:  & mission_number ) ;
7713: LD_STRING Map Number: 
7715: PUSH
7716: LD_OWVAR 70
7720: STR
7721: PPUSH
7722: CALL_OW 561
// AddToLog ( Difficulty:  & Difficulty ) ;
7726: LD_STRING Difficulty: 
7728: PUSH
7729: LD_OWVAR 67
7733: STR
7734: PPUSH
7735: CALL_OW 561
// AddToLog ( --------------------------------------- ) ;
7739: LD_STRING ---------------------------------------
7741: PPUSH
7742: CALL_OW 561
// end ;
7746: LD_VAR 0 1
7750: RET
// function Log ( text ) ; begin
7751: LD_INT 0
7753: PPUSH
// if show_line_index then
7754: LD_EXP 30
7758: IFFALSE 7770
// result := lines_counter ;
7760: LD_ADDR_VAR 0 2
7764: PUSH
7765: LD_EXP 27
7769: ST_TO_ADDR
// if tick_log then
7770: LD_EXP 31
7774: IFFALSE 7800
// result := result &  T:  & tick &   ;
7776: LD_ADDR_VAR 0 2
7780: PUSH
7781: LD_VAR 0 2
7785: PUSH
7786: LD_STRING  T: 
7788: STR
7789: PUSH
7790: LD_OWVAR 1
7794: STR
7795: PUSH
7796: LD_STRING  
7798: STR
7799: ST_TO_ADDR
// AddToLog ( result & text ) ;
7800: LD_VAR 0 2
7804: PUSH
7805: LD_VAR 0 1
7809: STR
7810: PPUSH
7811: CALL_OW 561
// lines_counter := lines_counter + 1 ;
7815: LD_ADDR_EXP 27
7819: PUSH
7820: LD_EXP 27
7824: PUSH
7825: LD_INT 1
7827: PLUS
7828: ST_TO_ADDR
// if lines_counter mod lines_break_limit = 0 then
7829: LD_EXP 27
7833: PUSH
7834: LD_EXP 28
7838: MOD
7839: PUSH
7840: LD_INT 0
7842: EQUAL
7843: IFFALSE 7854
// AddToLog ( lines_break_type ) ;
7845: LD_EXP 29
7849: PPUSH
7850: CALL_OW 561
// end ;
7854: LD_VAR 0 2
7858: RET
// export function LogHuman ( id ) ; begin
7859: LD_INT 0
7861: PPUSH
// Log ( Human Created. id:  & id & ; side:  & GetSide ( id ) & ; class:  & GetClass ( id ) & ;  ) ;
7862: LD_STRING Human Created. id: 
7864: PUSH
7865: LD_VAR 0 1
7869: STR
7870: PUSH
7871: LD_STRING ; side: 
7873: STR
7874: PUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 255
7884: STR
7885: PUSH
7886: LD_STRING ; class: 
7888: STR
7889: PUSH
7890: LD_VAR 0 1
7894: PPUSH
7895: CALL_OW 257
7899: STR
7900: PUSH
7901: LD_STRING ; 
7903: STR
7904: PPUSH
7905: CALL 7751 0 1
// end ;
7909: LD_VAR 0 2
7913: RET
// export function LogVeh ( id ) ; begin
7914: LD_INT 0
7916: PPUSH
// Log ( Vehicle Created. id:  & id & ; side:  & GetSide ( id ) & ; nation:  & GetNation ( id ) & ; weapon:  & GetWeapon ( id ) & ;  ) ;
7917: LD_STRING Vehicle Created. id: 
7919: PUSH
7920: LD_VAR 0 1
7924: STR
7925: PUSH
7926: LD_STRING ; side: 
7928: STR
7929: PUSH
7930: LD_VAR 0 1
7934: PPUSH
7935: CALL_OW 255
7939: STR
7940: PUSH
7941: LD_STRING ; nation: 
7943: STR
7944: PUSH
7945: LD_VAR 0 1
7949: PPUSH
7950: CALL_OW 248
7954: STR
7955: PUSH
7956: LD_STRING ; weapon: 
7958: STR
7959: PUSH
7960: LD_VAR 0 1
7964: PPUSH
7965: CALL_OW 264
7969: STR
7970: PUSH
7971: LD_STRING ; 
7973: STR
7974: PPUSH
7975: CALL 7751 0 1
// end ;
7979: LD_VAR 0 2
7983: RET
// export function LogEvent ( event ) ; begin
7984: LD_INT 0
7986: PPUSH
// Log ( Event Executed. id:  & event ) ;
7987: LD_STRING Event Executed. id: 
7989: PUSH
7990: LD_VAR 0 1
7994: STR
7995: PPUSH
7996: CALL 7751 0 1
// end ; end_of_file
8000: LD_VAR 0 2
8004: RET
// export function MC_Move ( unit , coords , mode ) ; var i , x , y , x2 , y2 , d , r ; begin
8005: LD_INT 0
8007: PPUSH
8008: PPUSH
8009: PPUSH
8010: PPUSH
8011: PPUSH
8012: PPUSH
8013: PPUSH
8014: PPUSH
// if unit then
8015: LD_VAR 0 1
8019: IFFALSE 8419
// begin if mode = 0 then
8021: LD_VAR 0 3
8025: PUSH
8026: LD_INT 0
8028: EQUAL
8029: IFFALSE 8177
// begin if coords then
8031: LD_VAR 0 2
8035: IFFALSE 8175
// while ( coords > 1 ) do
8037: LD_VAR 0 2
8041: PUSH
8042: LD_INT 1
8044: GREATER
8045: IFFALSE 8175
// if not HasTask ( unit ) then
8047: LD_VAR 0 1
8051: PPUSH
8052: CALL_OW 314
8056: NOT
8057: IFFALSE 8173
// begin ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8059: LD_VAR 0 1
8063: PPUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 1
8071: ARRAY
8072: PPUSH
8073: LD_VAR 0 2
8077: PUSH
8078: LD_INT 2
8080: ARRAY
8081: PPUSH
8082: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
8086: LD_INT 35
8088: PPUSH
8089: CALL_OW 67
// until GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ;
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 250
8102: PUSH
8103: LD_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ARRAY
8111: EQUAL
8112: PUSH
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 251
8122: PUSH
8123: LD_VAR 0 2
8127: PUSH
8128: LD_INT 2
8130: ARRAY
8131: EQUAL
8132: AND
8133: IFFALSE 8086
// for i = 1 to 2 do
8135: LD_ADDR_VAR 0 5
8139: PUSH
8140: DOUBLE
8141: LD_INT 1
8143: DEC
8144: ST_TO_ADDR
8145: LD_INT 2
8147: PUSH
8148: FOR_TO
8149: IFFALSE 8171
// coords := Delete ( coords , 1 ) ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: LD_INT 1
8163: PPUSH
8164: CALL_OW 3
8168: ST_TO_ADDR
8169: GO 8148
8171: POP
8172: POP
// end ;
8173: GO 8037
// end else
8175: GO 8419
// begin if coords then
8177: LD_VAR 0 2
8181: IFFALSE 8419
// begin x := GetX ( unit ) ;
8183: LD_ADDR_VAR 0 6
8187: PUSH
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 250
8197: ST_TO_ADDR
// y := GetY ( unit ) ;
8198: LD_ADDR_VAR 0 7
8202: PUSH
8203: LD_VAR 0 1
8207: PPUSH
8208: CALL_OW 251
8212: ST_TO_ADDR
// while ( coords > 1 ) do
8213: LD_VAR 0 2
8217: PUSH
8218: LD_INT 1
8220: GREATER
8221: IFFALSE 8419
// begin Wait ( 0 0$0.3 ) ;
8223: LD_INT 10
8225: PPUSH
8226: CALL_OW 67
// if MCT_Enemy ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , 14 ) then
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 255
8239: PPUSH
8240: LD_VAR 0 1
8244: PPUSH
8245: CALL_OW 250
8249: PPUSH
8250: LD_VAR 0 1
8254: PPUSH
8255: CALL_OW 251
8259: PPUSH
8260: LD_INT 14
8262: PPUSH
8263: CALL 22757 0 4
8267: IFFALSE 8298
// begin ComMoveXY ( unit , x , y ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_VAR 0 6
8278: PPUSH
8279: LD_VAR 0 7
8283: PPUSH
8284: CALL_OW 111
// result := false ;
8288: LD_ADDR_VAR 0 4
8292: PUSH
8293: LD_INT 0
8295: ST_TO_ADDR
// end else
8296: GO 8337
// if not HasTask ( unit ) then
8298: LD_VAR 0 1
8302: PPUSH
8303: CALL_OW 314
8307: NOT
8308: IFFALSE 8337
// ComMoveXY ( unit , coords [ 1 ] , coords [ 2 ] ) ;
8310: LD_VAR 0 1
8314: PPUSH
8315: LD_VAR 0 2
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 2
8331: ARRAY
8332: PPUSH
8333: CALL_OW 111
// if ( GetX ( unit ) = coords [ 1 ] and GetY ( unit ) = coords [ 2 ] ) then
8337: LD_VAR 0 1
8341: PPUSH
8342: CALL_OW 250
8346: PUSH
8347: LD_VAR 0 2
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: EQUAL
8356: PUSH
8357: LD_VAR 0 1
8361: PPUSH
8362: CALL_OW 251
8366: PUSH
8367: LD_VAR 0 2
8371: PUSH
8372: LD_INT 2
8374: ARRAY
8375: EQUAL
8376: AND
8377: IFFALSE 8417
// for i = 1 to 2 do
8379: LD_ADDR_VAR 0 5
8383: PUSH
8384: DOUBLE
8385: LD_INT 1
8387: DEC
8388: ST_TO_ADDR
8389: LD_INT 2
8391: PUSH
8392: FOR_TO
8393: IFFALSE 8415
// coords := Delete ( coords , 1 ) ;
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 2
8404: PPUSH
8405: LD_INT 1
8407: PPUSH
8408: CALL_OW 3
8412: ST_TO_ADDR
8413: GO 8392
8415: POP
8416: POP
// end ;
8417: GO 8213
// end ; end ; end ; result := true ;
8419: LD_ADDR_VAR 0 4
8423: PUSH
8424: LD_INT 1
8426: ST_TO_ADDR
// end ;
8427: LD_VAR 0 4
8431: RET
// export function MC_Attack ( side , units ) ; var i , enemy ; begin
8432: LD_INT 0
8434: PPUSH
8435: PPUSH
8436: PPUSH
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
8437: LD_ADDR_VAR 0 5
8441: PUSH
8442: LD_INT 81
8444: PUSH
8445: LD_VAR 0 1
8449: PUSH
8450: EMPTY
8451: LIST
8452: LIST
8453: PPUSH
8454: CALL_OW 69
8458: ST_TO_ADDR
// for i in units do
8459: LD_ADDR_VAR 0 4
8463: PUSH
8464: LD_VAR 0 2
8468: PUSH
8469: FOR_IN
8470: IFFALSE 8498
// begin ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
8472: LD_VAR 0 4
8476: PPUSH
8477: LD_VAR 0 5
8481: PPUSH
8482: LD_VAR 0 4
8486: PPUSH
8487: CALL_OW 74
8491: PPUSH
8492: CALL_OW 115
// end ;
8496: GO 8469
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 3
8504: RET
// export function MC_Show ( string ) ; begin
8505: LD_INT 0
8507: PPUSH
// display_strings := string ;
8508: LD_ADDR_OWVAR 47
8512: PUSH
8513: LD_VAR 0 1
8517: ST_TO_ADDR
// end ; end_of_file
8518: LD_VAR 0 2
8522: RET
// export function MCB_Depot ( side , x , y , d ) ; var i , dep , plist ; begin
8523: LD_INT 0
8525: PPUSH
8526: PPUSH
8527: PPUSH
8528: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
8529: LD_ADDR_VAR 0 8
8533: PUSH
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 2
8541: PPUSH
8542: EMPTY
8543: PPUSH
8544: CALL 11670 0 3
8548: ST_TO_ADDR
// if plist and HexInfo ( x , y ) = 0 then
8549: LD_VAR 0 8
8553: PUSH
8554: LD_VAR 0 2
8558: PPUSH
8559: LD_VAR 0 3
8563: PPUSH
8564: CALL_OW 428
8568: PUSH
8569: LD_INT 0
8571: EQUAL
8572: AND
8573: IFFALSE 8647
// for i = 1 to plist do
8575: LD_ADDR_VAR 0 6
8579: PUSH
8580: DOUBLE
8581: LD_INT 1
8583: DEC
8584: ST_TO_ADDR
8585: LD_VAR 0 8
8589: PUSH
8590: FOR_TO
8591: IFFALSE 8645
// if NotTask ( plist [ i ] ) then
8593: LD_VAR 0 8
8597: PUSH
8598: LD_VAR 0 6
8602: ARRAY
8603: PPUSH
8604: CALL 32158 0 1
8608: IFFALSE 8643
// begin ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
8610: LD_VAR 0 8
8614: PUSH
8615: LD_VAR 0 6
8619: ARRAY
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: LD_VAR 0 2
8628: PPUSH
8629: LD_VAR 0 3
8633: PPUSH
8634: LD_VAR 0 4
8638: PPUSH
8639: CALL_OW 145
// end ;
8643: GO 8590
8645: POP
8646: POP
// end ;
8647: LD_VAR 0 5
8651: RET
// export function MCB_Lab ( side , x , y , d ) ; begin
8652: LD_INT 0
8654: PPUSH
// MCB_Build ( side , b_lab , x , y , d ) ;
8655: LD_VAR 0 1
8659: PPUSH
8660: LD_INT 6
8662: PPUSH
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_VAR 0 3
8672: PPUSH
8673: LD_VAR 0 4
8677: PPUSH
8678: CALL 10156 0 5
// end ;
8682: LD_VAR 0 5
8686: RET
// export function MCB_Upgrade ( side , b ) ; var dep ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( b ) , GetY ( b ) ) ;
8691: LD_ADDR_VAR 0 4
8695: PUSH
8696: LD_INT 22
8698: PUSH
8699: LD_VAR 0 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 30
8713: PUSH
8714: LD_INT 0
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 30
8723: PUSH
8724: LD_INT 1
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PUSH
8731: EMPTY
8732: LIST
8733: LIST
8734: LIST
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PUSH
8740: EMPTY
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: PPUSH
8748: LD_VAR 0 2
8752: PPUSH
8753: CALL_OW 250
8757: PPUSH
8758: LD_VAR 0 2
8762: PPUSH
8763: CALL_OW 251
8767: PPUSH
8768: CALL_OW 73
8772: ST_TO_ADDR
// if MCB_Cost ( dep , b ) then
8773: LD_VAR 0 4
8777: PPUSH
8778: LD_VAR 0 2
8782: PPUSH
8783: CALL 10445 0 2
8787: IFFALSE 8846
// begin ComUpgrade ( MCF_Get ( side , [ f_btype , b ] ) [ 1 ] ) ;
8789: LD_VAR 0 1
8793: PPUSH
8794: LD_INT 30
8796: PUSH
8797: LD_VAR 0 2
8801: PUSH
8802: EMPTY
8803: LIST
8804: LIST
8805: PPUSH
8806: CALL 11587 0 2
8810: PUSH
8811: LD_INT 1
8813: ARRAY
8814: PPUSH
8815: CALL_OW 146
// MREG_ToUpdate := MC_RegistryDelete ( MREG_ToUpdate , side , b , [ ] ) ;
8819: LD_ADDR_EXP 50
8823: PUSH
8824: LD_EXP 50
8828: PPUSH
8829: LD_VAR 0 1
8833: PPUSH
8834: LD_VAR 0 2
8838: PPUSH
8839: EMPTY
8840: PPUSH
8841: CALL 41973 0 4
8845: ST_TO_ADDR
// end ; end ;
8846: LD_VAR 0 3
8850: RET
// export function MCB_UpgradeLab ( side , lab_kind1 , lab_kind2 ) ; var i , j , lab , costs , dep ; begin
8851: LD_INT 0
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// result := false ;
8859: LD_ADDR_VAR 0 4
8863: PUSH
8864: LD_INT 0
8866: ST_TO_ADDR
// if MREG_ForSide ( side , MREG_LabList ) then
8867: LD_VAR 0 1
8871: PPUSH
8872: LD_EXP 42
8876: PPUSH
8877: CALL 42921 0 2
8881: IFFALSE 9094
// for i = 1 to MREG_LabList do
8883: LD_ADDR_VAR 0 5
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_EXP 42
8897: PUSH
8898: FOR_TO
8899: IFFALSE 9092
// begin if MREG_LabList [ i ] [ 1 ] = side then
8901: LD_EXP 42
8905: PUSH
8906: LD_VAR 0 5
8910: ARRAY
8911: PUSH
8912: LD_INT 1
8914: ARRAY
8915: PUSH
8916: LD_VAR 0 1
8920: EQUAL
8921: IFFALSE 9090
// begin lab := MREG_LabList [ i ] [ 2 ] ;
8923: LD_ADDR_VAR 0 7
8927: PUSH
8928: LD_EXP 42
8932: PUSH
8933: LD_VAR 0 5
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , GetX ( lab ) , GetY ( lab ) ) ;
8943: LD_ADDR_VAR 0 9
8947: PUSH
8948: LD_INT 22
8950: PUSH
8951: LD_VAR 0 1
8955: PUSH
8956: EMPTY
8957: LIST
8958: LIST
8959: PUSH
8960: LD_INT 2
8962: PUSH
8963: LD_INT 30
8965: PUSH
8966: LD_INT 0
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: PUSH
8973: LD_INT 30
8975: PUSH
8976: LD_INT 1
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: EMPTY
8984: LIST
8985: LIST
8986: LIST
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: EMPTY
8993: LIST
8994: PPUSH
8995: CALL_OW 69
8999: PPUSH
9000: LD_VAR 0 7
9004: PPUSH
9005: CALL_OW 250
9009: PPUSH
9010: LD_VAR 0 7
9014: PPUSH
9015: CALL_OW 251
9019: PPUSH
9020: CALL_OW 73
9024: ST_TO_ADDR
// if dep then
9025: LD_VAR 0 9
9029: IFFALSE 9088
// begin if MCB_LabCost ( dep , lab_kind1 , lab_kind2 ) then
9031: LD_VAR 0 9
9035: PPUSH
9036: LD_VAR 0 2
9040: PPUSH
9041: LD_VAR 0 3
9045: PPUSH
9046: CALL 10561 0 3
9050: IFFALSE 9088
// begin AddComUpgradeLab ( lab , lab_kind1 ) ;
9052: LD_VAR 0 7
9056: PPUSH
9057: LD_VAR 0 2
9061: PPUSH
9062: CALL_OW 207
// AddComUpgradeLab ( lab , lab_kind2 ) ;
9066: LD_VAR 0 7
9070: PPUSH
9071: LD_VAR 0 3
9075: PPUSH
9076: CALL_OW 207
// result := true ;
9080: LD_ADDR_VAR 0 4
9084: PUSH
9085: LD_INT 1
9087: ST_TO_ADDR
// end ; end ; break ;
9088: GO 9092
// end ; end ;
9090: GO 8898
9092: POP
9093: POP
// end ;
9094: LD_VAR 0 4
9098: RET
// export function MCB_Factory ( side , x , y , d , ext_list ) ; var ext , i ; begin
9099: LD_INT 0
9101: PPUSH
9102: PPUSH
9103: PPUSH
// ext := MCB_Extension ( x , y , d ) ;
9104: LD_ADDR_VAR 0 7
9108: PUSH
9109: LD_VAR 0 2
9113: PPUSH
9114: LD_VAR 0 3
9118: PPUSH
9119: LD_VAR 0 4
9123: PPUSH
9124: CALL 9286 0 3
9128: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_workshop , [ x , y , d ] ) ;
9129: LD_ADDR_EXP 48
9133: PUSH
9134: LD_EXP 48
9138: PPUSH
9139: LD_VAR 0 1
9143: PPUSH
9144: LD_INT 2
9146: PPUSH
9147: LD_VAR 0 2
9151: PUSH
9152: LD_VAR 0 3
9156: PUSH
9157: LD_VAR 0 4
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: PPUSH
9167: CALL 41882 0 4
9171: ST_TO_ADDR
// if ext_list then
9172: LD_VAR 0 5
9176: IFFALSE 9281
// for i = 1 to ext_list do
9178: LD_ADDR_VAR 0 8
9182: PUSH
9183: DOUBLE
9184: LD_INT 1
9186: DEC
9187: ST_TO_ADDR
9188: LD_VAR 0 5
9192: PUSH
9193: FOR_TO
9194: IFFALSE 9279
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , ext_list [ i ] , [ ext [ i ] [ 1 ] , ext [ i ] [ 2 ] , ext [ i ] [ 3 ] ] ) ;
9196: LD_ADDR_EXP 48
9200: PUSH
9201: LD_EXP 48
9205: PPUSH
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_VAR 0 5
9215: PUSH
9216: LD_VAR 0 8
9220: ARRAY
9221: PPUSH
9222: LD_VAR 0 7
9226: PUSH
9227: LD_VAR 0 8
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PUSH
9237: LD_VAR 0 7
9241: PUSH
9242: LD_VAR 0 8
9246: ARRAY
9247: PUSH
9248: LD_INT 2
9250: ARRAY
9251: PUSH
9252: LD_VAR 0 7
9256: PUSH
9257: LD_VAR 0 8
9261: ARRAY
9262: PUSH
9263: LD_INT 3
9265: ARRAY
9266: PUSH
9267: EMPTY
9268: LIST
9269: LIST
9270: LIST
9271: PPUSH
9272: CALL 41882 0 4
9276: ST_TO_ADDR
9277: GO 9193
9279: POP
9280: POP
// end ;
9281: LD_VAR 0 6
9285: RET
// export function MCB_Extension ( x , y , d ) ; var list ; begin
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
// list := [ ] ;
9290: LD_ADDR_VAR 0 5
9294: PUSH
9295: EMPTY
9296: ST_TO_ADDR
// case d of 0 :
9297: LD_VAR 0 3
9301: PUSH
9302: LD_INT 0
9304: DOUBLE
9305: EQUAL
9306: IFTRUE 9310
9308: GO 9443
9310: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
9311: LD_ADDR_VAR 0 5
9315: PUSH
9316: LD_VAR 0 1
9320: PUSH
9321: LD_INT 4
9323: MINUS
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: LD_INT 4
9332: MINUS
9333: PUSH
9334: LD_INT 2
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: LIST
9341: PUSH
9342: LD_VAR 0 1
9346: PUSH
9347: LD_INT 3
9349: MINUS
9350: PUSH
9351: LD_VAR 0 2
9355: PUSH
9356: LD_INT 1
9358: PUSH
9359: EMPTY
9360: LIST
9361: LIST
9362: LIST
9363: PUSH
9364: LD_VAR 0 1
9368: PUSH
9369: LD_INT 4
9371: PLUS
9372: PUSH
9373: LD_VAR 0 2
9377: PUSH
9378: LD_INT 4
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: LIST
9385: PUSH
9386: LD_VAR 0 1
9390: PUSH
9391: LD_INT 3
9393: PLUS
9394: PUSH
9395: LD_VAR 0 2
9399: PUSH
9400: LD_INT 3
9402: PLUS
9403: PUSH
9404: LD_INT 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: LIST
9411: PUSH
9412: LD_VAR 0 1
9416: PUSH
9417: LD_VAR 0 2
9421: PUSH
9422: LD_INT 4
9424: PLUS
9425: PUSH
9426: LD_INT 0
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: LIST
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: LIST
9438: LIST
9439: LIST
9440: ST_TO_ADDR
// end ; 1 :
9441: GO 10141
9443: LD_INT 1
9445: DOUBLE
9446: EQUAL
9447: IFTRUE 9451
9449: GO 9584
9451: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
9452: LD_ADDR_VAR 0 5
9456: PUSH
9457: LD_VAR 0 1
9461: PUSH
9462: LD_VAR 0 2
9466: PUSH
9467: LD_INT 4
9469: MINUS
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: PUSH
9479: LD_VAR 0 1
9483: PUSH
9484: LD_INT 3
9486: MINUS
9487: PUSH
9488: LD_VAR 0 2
9492: PUSH
9493: LD_INT 3
9495: MINUS
9496: PUSH
9497: LD_INT 2
9499: PUSH
9500: EMPTY
9501: LIST
9502: LIST
9503: LIST
9504: PUSH
9505: LD_VAR 0 1
9509: PUSH
9510: LD_INT 4
9512: MINUS
9513: PUSH
9514: LD_VAR 0 2
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: PUSH
9527: LD_VAR 0 1
9531: PUSH
9532: LD_VAR 0 2
9536: PUSH
9537: LD_INT 3
9539: PLUS
9540: PUSH
9541: LD_INT 0
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: LD_VAR 0 1
9553: PUSH
9554: LD_INT 4
9556: PLUS
9557: PUSH
9558: LD_VAR 0 2
9562: PUSH
9563: LD_INT 4
9565: PLUS
9566: PUSH
9567: LD_INT 5
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: ST_TO_ADDR
// end ; 2 :
9582: GO 10141
9584: LD_INT 2
9586: DOUBLE
9587: EQUAL
9588: IFTRUE 9592
9590: GO 9721
9592: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
9593: LD_ADDR_VAR 0 5
9597: PUSH
9598: LD_VAR 0 1
9602: PUSH
9603: LD_VAR 0 2
9607: PUSH
9608: LD_INT 3
9610: MINUS
9611: PUSH
9612: LD_INT 3
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_VAR 0 1
9624: PUSH
9625: LD_INT 4
9627: PLUS
9628: PUSH
9629: LD_VAR 0 2
9633: PUSH
9634: LD_INT 4
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: LIST
9641: PUSH
9642: LD_VAR 0 1
9646: PUSH
9647: LD_VAR 0 2
9651: PUSH
9652: LD_INT 4
9654: PLUS
9655: PUSH
9656: LD_INT 0
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: LD_VAR 0 1
9668: PUSH
9669: LD_INT 3
9671: MINUS
9672: PUSH
9673: LD_VAR 0 2
9677: PUSH
9678: LD_INT 1
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: PUSH
9686: LD_VAR 0 1
9690: PUSH
9691: LD_INT 4
9693: MINUS
9694: PUSH
9695: LD_VAR 0 2
9699: PUSH
9700: LD_INT 4
9702: MINUS
9703: PUSH
9704: LD_INT 2
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: LIST
9716: LIST
9717: LIST
9718: ST_TO_ADDR
// end ; 3 :
9719: GO 10141
9721: LD_INT 3
9723: DOUBLE
9724: EQUAL
9725: IFTRUE 9729
9727: GO 9862
9729: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
9730: LD_ADDR_VAR 0 5
9734: PUSH
9735: LD_VAR 0 1
9739: PUSH
9740: LD_INT 3
9742: PLUS
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: LIST
9756: PUSH
9757: LD_VAR 0 1
9761: PUSH
9762: LD_INT 4
9764: PLUS
9765: PUSH
9766: LD_VAR 0 2
9770: PUSH
9771: LD_INT 4
9773: PLUS
9774: PUSH
9775: LD_INT 5
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_VAR 0 1
9787: PUSH
9788: LD_INT 4
9790: MINUS
9791: PUSH
9792: LD_VAR 0 2
9796: PUSH
9797: LD_INT 1
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: LIST
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: LD_INT 4
9817: MINUS
9818: PUSH
9819: LD_INT 3
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: LIST
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_INT 3
9834: MINUS
9835: PUSH
9836: LD_VAR 0 2
9840: PUSH
9841: LD_INT 3
9843: MINUS
9844: PUSH
9845: LD_INT 2
9847: PUSH
9848: EMPTY
9849: LIST
9850: LIST
9851: LIST
9852: PUSH
9853: EMPTY
9854: LIST
9855: LIST
9856: LIST
9857: LIST
9858: LIST
9859: ST_TO_ADDR
// end ; 4 :
9860: GO 10141
9862: LD_INT 4
9864: DOUBLE
9865: EQUAL
9866: IFTRUE 9870
9868: GO 10003
9870: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
9871: LD_ADDR_VAR 0 5
9875: PUSH
9876: LD_VAR 0 1
9880: PUSH
9881: LD_VAR 0 2
9885: PUSH
9886: LD_INT 4
9888: PLUS
9889: PUSH
9890: LD_INT 0
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: PUSH
9898: LD_VAR 0 1
9902: PUSH
9903: LD_INT 3
9905: PLUS
9906: PUSH
9907: LD_VAR 0 2
9911: PUSH
9912: LD_INT 3
9914: PLUS
9915: PUSH
9916: LD_INT 5
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: LIST
9923: PUSH
9924: LD_VAR 0 1
9928: PUSH
9929: LD_INT 3
9931: PLUS
9932: PUSH
9933: LD_VAR 0 2
9937: PUSH
9938: LD_INT 4
9940: PUSH
9941: EMPTY
9942: LIST
9943: LIST
9944: LIST
9945: PUSH
9946: LD_VAR 0 1
9950: PUSH
9951: LD_VAR 0 2
9955: PUSH
9956: LD_INT 3
9958: MINUS
9959: PUSH
9960: LD_INT 3
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: PUSH
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 4
9975: MINUS
9976: PUSH
9977: LD_VAR 0 2
9981: PUSH
9982: LD_INT 4
9984: MINUS
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: LIST
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: LIST
9998: LIST
9999: LIST
10000: ST_TO_ADDR
// end ; 5 :
10001: GO 10141
10003: LD_INT 5
10005: DOUBLE
10006: EQUAL
10007: IFTRUE 10011
10009: GO 10140
10011: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
10012: LD_ADDR_VAR 0 5
10016: PUSH
10017: LD_VAR 0 1
10021: PUSH
10022: LD_INT 4
10024: MINUS
10025: PUSH
10026: LD_VAR 0 2
10030: PUSH
10031: LD_INT 1
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: LIST
10038: PUSH
10039: LD_VAR 0 1
10043: PUSH
10044: LD_VAR 0 2
10048: PUSH
10049: LD_INT 4
10051: MINUS
10052: PUSH
10053: LD_INT 3
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: LIST
10060: PUSH
10061: LD_VAR 0 1
10065: PUSH
10066: LD_INT 4
10068: PLUS
10069: PUSH
10070: LD_VAR 0 2
10074: PUSH
10075: LD_INT 4
10077: PLUS
10078: PUSH
10079: LD_INT 5
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: PUSH
10087: LD_VAR 0 1
10091: PUSH
10092: LD_INT 3
10094: PLUS
10095: PUSH
10096: LD_VAR 0 2
10100: PUSH
10101: LD_INT 4
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PUSH
10109: LD_VAR 0 1
10113: PUSH
10114: LD_VAR 0 2
10118: PUSH
10119: LD_INT 3
10121: PLUS
10122: PUSH
10123: LD_INT 0
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: ST_TO_ADDR
// end ; end ;
10138: GO 10141
10140: POP
// result := list ;
10141: LD_ADDR_VAR 0 4
10145: PUSH
10146: LD_VAR 0 5
10150: ST_TO_ADDR
// end ;
10151: LD_VAR 0 4
10155: RET
// export function MCB_Build ( side , btype , x , y , d ) ; var i , costs , dep , plist ; begin
10156: LD_INT 0
10158: PPUSH
10159: PPUSH
10160: PPUSH
10161: PPUSH
10162: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10163: LD_ADDR_VAR 0 10
10167: PUSH
10168: LD_VAR 0 1
10172: PPUSH
10173: LD_INT 2
10175: PPUSH
10176: EMPTY
10177: PPUSH
10178: CALL 11670 0 3
10182: ST_TO_ADDR
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
10183: LD_ADDR_VAR 0 9
10187: PUSH
10188: LD_INT 22
10190: PUSH
10191: LD_VAR 0 1
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: LD_INT 30
10205: PUSH
10206: LD_INT 0
10208: PUSH
10209: EMPTY
10210: LIST
10211: LIST
10212: PUSH
10213: LD_INT 30
10215: PUSH
10216: LD_INT 1
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: EMPTY
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: PPUSH
10235: CALL_OW 69
10239: PPUSH
10240: LD_VAR 0 3
10244: PPUSH
10245: LD_VAR 0 4
10249: PPUSH
10250: CALL_OW 73
10254: ST_TO_ADDR
// costs := MCB_Cost ( dep , btype ) ;
10255: LD_ADDR_VAR 0 8
10259: PUSH
10260: LD_VAR 0 9
10264: PPUSH
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL 10445 0 2
10274: ST_TO_ADDR
// if plist and costs and GetDistUnitXY ( dep , x , y ) <= 26 and HexInfo ( x , y ) = 0 then
10275: LD_VAR 0 10
10279: PUSH
10280: LD_VAR 0 8
10284: AND
10285: PUSH
10286: LD_VAR 0 9
10290: PPUSH
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_VAR 0 4
10300: PPUSH
10301: CALL_OW 297
10305: PUSH
10306: LD_INT 26
10308: LESSEQUAL
10309: AND
10310: PUSH
10311: LD_VAR 0 3
10315: PPUSH
10316: LD_VAR 0 4
10320: PPUSH
10321: CALL_OW 428
10325: PUSH
10326: LD_INT 0
10328: EQUAL
10329: AND
10330: IFFALSE 10440
// for i = 1 to plist do
10332: LD_ADDR_VAR 0 7
10336: PUSH
10337: DOUBLE
10338: LD_INT 1
10340: DEC
10341: ST_TO_ADDR
10342: LD_VAR 0 10
10346: PUSH
10347: FOR_TO
10348: IFFALSE 10438
// if IsInUnit ( plist [ i ] ) then
10350: LD_VAR 0 10
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PPUSH
10361: CALL_OW 310
10365: IFFALSE 10384
// ComExitBuilding ( plist [ i ] ) else
10367: LD_VAR 0 10
10371: PUSH
10372: LD_VAR 0 7
10376: ARRAY
10377: PPUSH
10378: CALL_OW 122
10382: GO 10436
// if NotTask ( plist [ i ] ) then
10384: LD_VAR 0 10
10388: PUSH
10389: LD_VAR 0 7
10393: ARRAY
10394: PPUSH
10395: CALL 32158 0 1
10399: IFFALSE 10436
// begin ComBuild ( plist [ i ] , btype , x , y , d ) ;
10401: LD_VAR 0 10
10405: PUSH
10406: LD_VAR 0 7
10410: ARRAY
10411: PPUSH
10412: LD_VAR 0 2
10416: PPUSH
10417: LD_VAR 0 3
10421: PPUSH
10422: LD_VAR 0 4
10426: PPUSH
10427: LD_VAR 0 5
10431: PPUSH
10432: CALL_OW 145
// end ;
10436: GO 10347
10438: POP
10439: POP
// end ;
10440: LD_VAR 0 6
10444: RET
// export function MCB_Cost ( bdepot , btype ) ; var pom , cost ; begin
10445: LD_INT 0
10447: PPUSH
10448: PPUSH
10449: PPUSH
// pom := GetBase ( bdepot ) ;
10450: LD_ADDR_VAR 0 4
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 274
10464: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
10465: LD_ADDR_VAR 0 5
10469: PUSH
10470: LD_VAR 0 2
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 248
10484: PPUSH
10485: CALL_OW 450
10489: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10490: LD_VAR 0 4
10494: PPUSH
10495: LD_INT 1
10497: PPUSH
10498: CALL_OW 275
10502: PUSH
10503: LD_VAR 0 5
10507: PUSH
10508: LD_INT 1
10510: ARRAY
10511: GREATEREQUAL
10512: PUSH
10513: LD_VAR 0 4
10517: PPUSH
10518: LD_INT 3
10520: PPUSH
10521: CALL_OW 275
10525: PUSH
10526: LD_VAR 0 5
10530: PUSH
10531: LD_INT 3
10533: ARRAY
10534: GREATEREQUAL
10535: AND
10536: IFFALSE 10548
// result := true else
10538: LD_ADDR_VAR 0 3
10542: PUSH
10543: LD_INT 1
10545: ST_TO_ADDR
10546: GO 10556
// result := false ;
10548: LD_ADDR_VAR 0 3
10552: PUSH
10553: LD_INT 0
10555: ST_TO_ADDR
// end ;
10556: LD_VAR 0 3
10560: RET
// export function MCB_LabCost ( bdepot , blab1 , blab2 ) ; var pom , cost1 , cost2 , cost ; begin
10561: LD_INT 0
10563: PPUSH
10564: PPUSH
10565: PPUSH
10566: PPUSH
10567: PPUSH
// pom := GetBase ( bdepot ) ;
10568: LD_ADDR_VAR 0 5
10572: PUSH
10573: LD_VAR 0 1
10577: PPUSH
10578: CALL_OW 274
10582: ST_TO_ADDR
// cost := [ ] ;
10583: LD_ADDR_VAR 0 8
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// cost1 := CostOfBuilding ( blab1 , GetNation ( bdepot ) ) ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_VAR 0 1
10604: PPUSH
10605: CALL_OW 248
10609: PPUSH
10610: CALL_OW 450
10614: ST_TO_ADDR
// cost2 := CostOfBuilding ( blab2 , GetNation ( bdepot ) ) ;
10615: LD_ADDR_VAR 0 7
10619: PUSH
10620: LD_VAR 0 3
10624: PPUSH
10625: LD_VAR 0 1
10629: PPUSH
10630: CALL_OW 248
10634: PPUSH
10635: CALL_OW 450
10639: ST_TO_ADDR
// cost := Replace ( cost , 1 , cost1 [ 1 ] + cost2 [ 1 ] ) ;
10640: LD_ADDR_VAR 0 8
10644: PUSH
10645: LD_VAR 0 8
10649: PPUSH
10650: LD_INT 1
10652: PPUSH
10653: LD_VAR 0 6
10657: PUSH
10658: LD_INT 1
10660: ARRAY
10661: PUSH
10662: LD_VAR 0 7
10666: PUSH
10667: LD_INT 1
10669: ARRAY
10670: PLUS
10671: PPUSH
10672: CALL_OW 1
10676: ST_TO_ADDR
// cost := Replace ( cost , 2 , cost1 [ 2 ] + cost2 [ 2 ] ) ;
10677: LD_ADDR_VAR 0 8
10681: PUSH
10682: LD_VAR 0 8
10686: PPUSH
10687: LD_INT 2
10689: PPUSH
10690: LD_VAR 0 6
10694: PUSH
10695: LD_INT 2
10697: ARRAY
10698: PUSH
10699: LD_VAR 0 7
10703: PUSH
10704: LD_INT 2
10706: ARRAY
10707: PLUS
10708: PPUSH
10709: CALL_OW 1
10713: ST_TO_ADDR
// cost := Replace ( cost , 3 , cost1 [ 3 ] + cost2 [ 3 ] ) ;
10714: LD_ADDR_VAR 0 8
10718: PUSH
10719: LD_VAR 0 8
10723: PPUSH
10724: LD_INT 3
10726: PPUSH
10727: LD_VAR 0 6
10731: PUSH
10732: LD_INT 3
10734: ARRAY
10735: PUSH
10736: LD_VAR 0 7
10740: PUSH
10741: LD_INT 3
10743: ARRAY
10744: PLUS
10745: PPUSH
10746: CALL_OW 1
10750: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
10751: LD_VAR 0 5
10755: PPUSH
10756: LD_INT 1
10758: PPUSH
10759: CALL_OW 275
10763: PUSH
10764: LD_VAR 0 8
10768: PUSH
10769: LD_INT 1
10771: ARRAY
10772: GREATEREQUAL
10773: PUSH
10774: LD_VAR 0 5
10778: PPUSH
10779: LD_INT 3
10781: PPUSH
10782: CALL_OW 275
10786: PUSH
10787: LD_VAR 0 8
10791: PUSH
10792: LD_INT 3
10794: ARRAY
10795: GREATEREQUAL
10796: AND
10797: IFFALSE 10809
// result := true else
10799: LD_ADDR_VAR 0 4
10803: PUSH
10804: LD_INT 1
10806: ST_TO_ADDR
10807: GO 10817
// result := false ;
10809: LD_ADDR_VAR 0 4
10813: PUSH
10814: LD_INT 0
10816: ST_TO_ADDR
// end ;
10817: LD_VAR 0 4
10821: RET
// export function MCB_Dismantle ( side , unit ) ; var i , plist ; begin
10822: LD_INT 0
10824: PPUSH
10825: PPUSH
10826: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10827: LD_ADDR_VAR 0 5
10831: PUSH
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_INT 2
10839: PPUSH
10840: EMPTY
10841: PPUSH
10842: CALL 11670 0 3
10846: ST_TO_ADDR
// if unit and plist then
10847: LD_VAR 0 2
10851: PUSH
10852: LD_VAR 0 5
10856: AND
10857: IFFALSE 10918
// for i = 1 to plist do
10859: LD_ADDR_VAR 0 4
10863: PUSH
10864: DOUBLE
10865: LD_INT 1
10867: DEC
10868: ST_TO_ADDR
10869: LD_VAR 0 5
10873: PUSH
10874: FOR_TO
10875: IFFALSE 10916
// if NotTask ( plist [ i ] ) then
10877: LD_VAR 0 5
10881: PUSH
10882: LD_VAR 0 4
10886: ARRAY
10887: PPUSH
10888: CALL 32158 0 1
10892: IFFALSE 10914
// ComDismantle ( plist [ i ] , unit ) ;
10894: LD_VAR 0 5
10898: PUSH
10899: LD_VAR 0 4
10903: ARRAY
10904: PPUSH
10905: LD_VAR 0 2
10909: PPUSH
10910: CALL_OW 167
10914: GO 10874
10916: POP
10917: POP
// result := true ;
10918: LD_ADDR_VAR 0 3
10922: PUSH
10923: LD_INT 1
10925: ST_TO_ADDR
// end ;
10926: LD_VAR 0 3
10930: RET
// export function MCB_Complete ( side , unit ) ; var i , plist ; begin
10931: LD_INT 0
10933: PPUSH
10934: PPUSH
10935: PPUSH
// plist := MCF_Class ( side , 2 , [ ] ) ;
10936: LD_ADDR_VAR 0 5
10940: PUSH
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_INT 2
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL 11670 0 3
10955: ST_TO_ADDR
// if unit and plist then
10956: LD_VAR 0 2
10960: PUSH
10961: LD_VAR 0 5
10965: AND
10966: IFFALSE 11027
// for i = 1 to plist do
10968: LD_ADDR_VAR 0 4
10972: PUSH
10973: DOUBLE
10974: LD_INT 1
10976: DEC
10977: ST_TO_ADDR
10978: LD_VAR 0 5
10982: PUSH
10983: FOR_TO
10984: IFFALSE 11025
// if NotTask ( plist [ i ] ) then
10986: LD_VAR 0 5
10990: PUSH
10991: LD_VAR 0 4
10995: ARRAY
10996: PPUSH
10997: CALL 32158 0 1
11001: IFFALSE 11023
// ComComplete ( plist [ i ] , unit ) ;
11003: LD_VAR 0 5
11007: PUSH
11008: LD_VAR 0 4
11012: ARRAY
11013: PPUSH
11014: LD_VAR 0 2
11018: PPUSH
11019: CALL 66079 0 2
11023: GO 10983
11025: POP
11026: POP
// result := true ;
11027: LD_ADDR_VAR 0 3
11031: PUSH
11032: LD_INT 1
11034: ST_TO_ADDR
// end ;
11035: LD_VAR 0 3
11039: RET
// export function MCB_FilterHLevel ( side ) ; var i , j , tmp , r , m ; begin
11040: LD_INT 0
11042: PPUSH
11043: PPUSH
11044: PPUSH
11045: PPUSH
11046: PPUSH
11047: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_VAR 0 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PUSH
11065: LD_INT 21
11067: PUSH
11068: LD_INT 3
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PUSH
11075: LD_INT 3
11077: PUSH
11078: LD_INT 57
11080: PUSH
11081: EMPTY
11082: LIST
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: LD_INT 24
11093: PUSH
11094: LD_INT 1000
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: PUSH
11105: EMPTY
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: ST_TO_ADDR
// r := [ ] ;
11116: LD_ADDR_VAR 0 6
11120: PUSH
11121: EMPTY
11122: ST_TO_ADDR
// if not tmp then
11123: LD_VAR 0 5
11127: NOT
11128: IFFALSE 11134
// exit else
11130: GO 11322
11132: GO 11302
// begin r := [ tmp [ 1 ] ] ;
11134: LD_ADDR_VAR 0 6
11138: PUSH
11139: LD_VAR 0 5
11143: PUSH
11144: LD_INT 1
11146: ARRAY
11147: PUSH
11148: EMPTY
11149: LIST
11150: ST_TO_ADDR
// for i = 2 to tmp do
11151: LD_ADDR_VAR 0 3
11155: PUSH
11156: DOUBLE
11157: LD_INT 2
11159: DEC
11160: ST_TO_ADDR
11161: LD_VAR 0 5
11165: PUSH
11166: FOR_TO
11167: IFFALSE 11300
// begin m := false ;
11169: LD_ADDR_VAR 0 7
11173: PUSH
11174: LD_INT 0
11176: ST_TO_ADDR
// for j = 1 to r do
11177: LD_ADDR_VAR 0 4
11181: PUSH
11182: DOUBLE
11183: LD_INT 1
11185: DEC
11186: ST_TO_ADDR
11187: LD_VAR 0 6
11191: PUSH
11192: FOR_TO
11193: IFFALSE 11267
// if GetLives ( tmp [ i ] ) < r [ j ] then
11195: LD_VAR 0 5
11199: PUSH
11200: LD_VAR 0 3
11204: ARRAY
11205: PPUSH
11206: CALL_OW 256
11210: PUSH
11211: LD_VAR 0 6
11215: PUSH
11216: LD_VAR 0 4
11220: ARRAY
11221: LESS
11222: IFFALSE 11265
// begin r := Insert ( r , j , tmp [ i ] ) ;
11224: LD_ADDR_VAR 0 6
11228: PUSH
11229: LD_VAR 0 6
11233: PPUSH
11234: LD_VAR 0 4
11238: PPUSH
11239: LD_VAR 0 5
11243: PUSH
11244: LD_VAR 0 3
11248: ARRAY
11249: PPUSH
11250: CALL_OW 2
11254: ST_TO_ADDR
// m := true ;
11255: LD_ADDR_VAR 0 7
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// break ;
11263: GO 11267
// end ;
11265: GO 11192
11267: POP
11268: POP
// if not m then
11269: LD_VAR 0 7
11273: NOT
11274: IFFALSE 11298
// r := r ^ tmp [ i ] ;
11276: LD_ADDR_VAR 0 6
11280: PUSH
11281: LD_VAR 0 6
11285: PUSH
11286: LD_VAR 0 5
11290: PUSH
11291: LD_VAR 0 3
11295: ARRAY
11296: ADD
11297: ST_TO_ADDR
// end ;
11298: GO 11166
11300: POP
11301: POP
// end ; if r then
11302: LD_VAR 0 6
11306: IFFALSE 11320
// result := r else
11308: LD_ADDR_VAR 0 2
11312: PUSH
11313: LD_VAR 0 6
11317: ST_TO_ADDR
11318: GO 11322
// exit ;
11320: GO 11322
// end ;
11322: LD_VAR 0 2
11326: RET
// export function MCB_Repair ( side ) ; var i , p , repairs ; begin
11327: LD_INT 0
11329: PPUSH
11330: PPUSH
11331: PPUSH
11332: PPUSH
// repairs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] , [ f_lives , 650 ] ] ) ;
11333: LD_ADDR_VAR 0 5
11337: PUSH
11338: LD_INT 22
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: LD_INT 25
11355: PUSH
11356: LD_INT 2
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: PUSH
11363: LD_INT 25
11365: PUSH
11366: LD_INT 16
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 34
11375: PUSH
11376: LD_INT 13
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: LD_INT 34
11385: PUSH
11386: LD_INT 52
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: PUSH
11393: EMPTY
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: LD_INT 24
11402: PUSH
11403: LD_INT 650
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: EMPTY
11411: LIST
11412: LIST
11413: LIST
11414: PPUSH
11415: CALL_OW 69
11419: ST_TO_ADDR
// p := 1 ;
11420: LD_ADDR_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: ST_TO_ADDR
// for i = 1 to repairs do
11428: LD_ADDR_VAR 0 3
11432: PUSH
11433: DOUBLE
11434: LD_INT 1
11436: DEC
11437: ST_TO_ADDR
11438: LD_VAR 0 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11580
// begin if IsInUnit ( repairs [ i ] ) then
11446: LD_VAR 0 5
11450: PUSH
11451: LD_VAR 0 3
11455: ARRAY
11456: PPUSH
11457: CALL_OW 310
11461: IFFALSE 11480
// ComExitBuilding ( repairs [ i ] ) else
11463: LD_VAR 0 5
11467: PUSH
11468: LD_VAR 0 3
11472: ARRAY
11473: PPUSH
11474: CALL_OW 122
11478: GO 11578
// if not HasTask ( repairs [ i ] ) then
11480: LD_VAR 0 5
11484: PUSH
11485: LD_VAR 0 3
11489: ARRAY
11490: PPUSH
11491: CALL_OW 314
11495: NOT
11496: IFFALSE 11578
// begin ComRepairBuilding ( repairs [ i ] , MREG_ToRepair [ side ] [ p ] ) ;
11498: LD_VAR 0 5
11502: PUSH
11503: LD_VAR 0 3
11507: ARRAY
11508: PPUSH
11509: LD_EXP 49
11513: PUSH
11514: LD_VAR 0 1
11518: ARRAY
11519: PUSH
11520: LD_VAR 0 4
11524: ARRAY
11525: PPUSH
11526: CALL_OW 130
// if i mod 3 = 0 then
11530: LD_VAR 0 3
11534: PUSH
11535: LD_INT 3
11537: MOD
11538: PUSH
11539: LD_INT 0
11541: EQUAL
11542: IFFALSE 11558
// p := p + 1 ;
11544: LD_ADDR_VAR 0 4
11548: PUSH
11549: LD_VAR 0 4
11553: PUSH
11554: LD_INT 1
11556: PLUS
11557: ST_TO_ADDR
// if MREG_ToRepair [ side ] < p then
11558: LD_EXP 49
11562: PUSH
11563: LD_VAR 0 1
11567: ARRAY
11568: PUSH
11569: LD_VAR 0 4
11573: LESS
11574: IFFALSE 11578
// break ;
11576: GO 11580
// end ; end ;
11578: GO 11443
11580: POP
11581: POP
// end ; end_of_file
11582: LD_VAR 0 2
11586: RET
// export function MCF_Get ( side , filter ) ; begin
11587: LD_INT 0
11589: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_INT 22
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_VAR 0 2
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// end ;
11621: LD_VAR 0 3
11625: RET
// export function MCF_Lab ( side ) ; begin
11626: LD_INT 0
11628: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_lab_full ] ] ) ;
11629: LD_ADDR_VAR 0 2
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_VAR 0 1
11641: PUSH
11642: EMPTY
11643: LIST
11644: LIST
11645: PUSH
11646: LD_INT 30
11648: PUSH
11649: LD_INT 8
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: EMPTY
11657: LIST
11658: LIST
11659: PPUSH
11660: CALL_OW 69
11664: ST_TO_ADDR
// end ;
11665: LD_VAR 0 2
11669: RET
// export function MCF_Class ( side , class , filter ) ; begin
11670: LD_INT 0
11672: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class ] , filter ] ) ;
11673: LD_ADDR_VAR 0 4
11677: PUSH
11678: LD_INT 22
11680: PUSH
11681: LD_VAR 0 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_VAR 0 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PUSH
11702: LD_VAR 0 3
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: PPUSH
11712: CALL_OW 69
11716: ST_TO_ADDR
// end ;
11717: LD_VAR 0 4
11721: RET
// export function MCF_All ( side , filter ) ; begin
11722: LD_INT 0
11724: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] , filter ] ) ;
11725: LD_ADDR_VAR 0 3
11729: PUSH
11730: LD_INT 22
11732: PUSH
11733: LD_VAR 0 1
11737: PUSH
11738: EMPTY
11739: LIST
11740: LIST
11741: PUSH
11742: LD_INT 2
11744: PUSH
11745: LD_INT 25
11747: PUSH
11748: LD_INT 1
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 25
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 25
11767: PUSH
11768: LD_INT 3
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: LD_INT 25
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: EMPTY
11782: LIST
11783: LIST
11784: PUSH
11785: EMPTY
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: PUSH
11792: LD_VAR 0 2
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: LIST
11801: PPUSH
11802: CALL_OW 69
11806: ST_TO_ADDR
// end ;
11807: LD_VAR 0 3
11811: RET
// export function MCF_Dist ( side , point , filter ) ; begin
11812: LD_INT 0
11814: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_distxy , point [ 1 ] , point [ 2 ] , point [ 3 ] ] , filter ] ) ;
11815: LD_ADDR_VAR 0 4
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_VAR 0 1
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: PUSH
11832: LD_INT 92
11834: PUSH
11835: LD_VAR 0 2
11839: PUSH
11840: LD_INT 1
11842: ARRAY
11843: PUSH
11844: LD_VAR 0 2
11848: PUSH
11849: LD_INT 2
11851: ARRAY
11852: PUSH
11853: LD_VAR 0 2
11857: PUSH
11858: LD_INT 3
11860: ARRAY
11861: PUSH
11862: EMPTY
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: PUSH
11868: LD_VAR 0 3
11872: PUSH
11873: EMPTY
11874: LIST
11875: LIST
11876: LIST
11877: PPUSH
11878: CALL_OW 69
11882: ST_TO_ADDR
// end ;
11883: LD_VAR 0 4
11887: RET
// export function MCF_Vehicle ( side , filter ) ; begin
11888: LD_INT 0
11890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] , filter ] ) ;
11891: LD_ADDR_VAR 0 3
11895: PUSH
11896: LD_INT 22
11898: PUSH
11899: LD_VAR 0 1
11903: PUSH
11904: EMPTY
11905: LIST
11906: LIST
11907: PUSH
11908: LD_INT 21
11910: PUSH
11911: LD_INT 2
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_VAR 0 2
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PPUSH
11928: CALL_OW 69
11932: ST_TO_ADDR
// end ;
11933: LD_VAR 0 3
11937: RET
// export function MCF_Cargo ( side ) ; begin
11938: LD_INT 0
11940: PPUSH
// result := MCF_Vehicle ( side , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ) ;
11941: LD_ADDR_VAR 0 2
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 2
11953: PUSH
11954: LD_INT 34
11956: PUSH
11957: LD_INT 12
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 34
11966: PUSH
11967: LD_INT 32
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: LD_INT 34
11976: PUSH
11977: LD_INT 51
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PPUSH
11990: CALL 11888 0 2
11994: ST_TO_ADDR
// end ;
11995: LD_VAR 0 2
11999: RET
// export function MCF_Ape ( side ) ; begin
12000: LD_INT 0
12002: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_kamikaze ] ] ] ) ;
12003: LD_ADDR_VAR 0 2
12007: PUSH
12008: LD_INT 22
12010: PUSH
12011: LD_VAR 0 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 2
12022: PUSH
12023: LD_INT 25
12025: PUSH
12026: LD_INT 12
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PUSH
12033: LD_INT 25
12035: PUSH
12036: LD_INT 15
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: PUSH
12043: LD_INT 25
12045: PUSH
12046: LD_INT 16
12048: PUSH
12049: EMPTY
12050: LIST
12051: LIST
12052: PUSH
12053: LD_INT 25
12055: PUSH
12056: LD_INT 17
12058: PUSH
12059: EMPTY
12060: LIST
12061: LIST
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: LIST
12067: LIST
12068: LIST
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PPUSH
12074: CALL_OW 69
12078: ST_TO_ADDR
// end ;
12079: LD_VAR 0 2
12083: RET
// export function MCF_ApeSpec ( side , type ) ; var tmp , cl , i ; begin
12084: LD_INT 0
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 3
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// tmp := MCF_Ape ( side ) ;
12097: LD_ADDR_VAR 0 4
12101: PUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL 12000 0 1
12111: ST_TO_ADDR
// case type of 0 , normal :
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: DOUBLE
12120: EQUAL
12121: IFTRUE 12131
12123: LD_STRING normal
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12142
12131: POP
// cl := class_apeman ; 1 , soldier :
12132: LD_ADDR_VAR 0 5
12136: PUSH
12137: LD_INT 12
12139: ST_TO_ADDR
12140: GO 12218
12142: LD_INT 1
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12156
12148: LD_STRING soldier
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12156
12154: GO 12167
12156: POP
// cl := class_apeman_soldier ; 2 , engineer :
12157: LD_ADDR_VAR 0 5
12161: PUSH
12162: LD_INT 15
12164: ST_TO_ADDR
12165: GO 12218
12167: LD_INT 2
12169: DOUBLE
12170: EQUAL
12171: IFTRUE 12181
12173: LD_STRING engineer
12175: DOUBLE
12176: EQUAL
12177: IFTRUE 12181
12179: GO 12192
12181: POP
// cl := class_apeman_engineer ; 3 , kamikaze :
12182: LD_ADDR_VAR 0 5
12186: PUSH
12187: LD_INT 16
12189: ST_TO_ADDR
12190: GO 12218
12192: LD_INT 3
12194: DOUBLE
12195: EQUAL
12196: IFTRUE 12206
12198: LD_STRING kamikaze
12200: DOUBLE
12201: EQUAL
12202: IFTRUE 12206
12204: GO 12217
12206: POP
// cl := class_apeman_kamikaze ; end ;
12207: LD_ADDR_VAR 0 5
12211: PUSH
12212: LD_INT 17
12214: ST_TO_ADDR
12215: GO 12218
12217: POP
// for i = 1 to tmp do
12218: LD_ADDR_VAR 0 6
12222: PUSH
12223: DOUBLE
12224: LD_INT 1
12226: DEC
12227: ST_TO_ADDR
12228: LD_VAR 0 4
12232: PUSH
12233: FOR_TO
12234: IFFALSE 12283
// if GetClass ( tmp [ i ] ) = cl then
12236: LD_VAR 0 4
12240: PUSH
12241: LD_VAR 0 6
12245: ARRAY
12246: PPUSH
12247: CALL_OW 257
12251: PUSH
12252: LD_VAR 0 5
12256: EQUAL
12257: IFFALSE 12281
// result := result ^ tmp [ i ] ;
12259: LD_ADDR_VAR 0 3
12263: PUSH
12264: LD_VAR 0 3
12268: PUSH
12269: LD_VAR 0 4
12273: PUSH
12274: LD_VAR 0 6
12278: ARRAY
12279: ADD
12280: ST_TO_ADDR
12281: GO 12233
12283: POP
12284: POP
// end ;
12285: LD_VAR 0 3
12289: RET
// export function MCF_Tag ( side , tag , filter ) ; var tmp , r , i ; begin
12290: LD_INT 0
12292: PPUSH
12293: PPUSH
12294: PPUSH
12295: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , filter ] ) ;
12296: LD_ADDR_VAR 0 5
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: PUSH
12313: LD_VAR 0 3
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PPUSH
12322: CALL_OW 69
12326: ST_TO_ADDR
// r := [ ] ;
12327: LD_ADDR_VAR 0 6
12331: PUSH
12332: EMPTY
12333: ST_TO_ADDR
// if tmp then
12334: LD_VAR 0 5
12338: IFFALSE 12407
// for i = 1 to tmp do
12340: LD_ADDR_VAR 0 7
12344: PUSH
12345: DOUBLE
12346: LD_INT 1
12348: DEC
12349: ST_TO_ADDR
12350: LD_VAR 0 5
12354: PUSH
12355: FOR_TO
12356: IFFALSE 12405
// if GetTag ( tmp [ i ] ) = tag then
12358: LD_VAR 0 5
12362: PUSH
12363: LD_VAR 0 7
12367: ARRAY
12368: PPUSH
12369: CALL_OW 110
12373: PUSH
12374: LD_VAR 0 2
12378: EQUAL
12379: IFFALSE 12403
// r := r ^ tmp [ i ] ;
12381: LD_ADDR_VAR 0 6
12385: PUSH
12386: LD_VAR 0 6
12390: PUSH
12391: LD_VAR 0 5
12395: PUSH
12396: LD_VAR 0 7
12400: ARRAY
12401: ADD
12402: ST_TO_ADDR
12403: GO 12355
12405: POP
12406: POP
// result := r ;
12407: LD_ADDR_VAR 0 4
12411: PUSH
12412: LD_VAR 0 6
12416: ST_TO_ADDR
// end ;
12417: LD_VAR 0 4
12421: RET
// export function MCF_SetTag ( side , plist , tag ) ; var tmp , i ; begin
12422: LD_INT 0
12424: PPUSH
12425: PPUSH
12426: PPUSH
// tmp := plist ;
12427: LD_ADDR_VAR 0 5
12431: PUSH
12432: LD_VAR 0 2
12436: ST_TO_ADDR
// if tmp then
12437: LD_VAR 0 5
12441: IFFALSE 12518
// begin for i = 1 to tmp do
12443: LD_ADDR_VAR 0 6
12447: PUSH
12448: DOUBLE
12449: LD_INT 1
12451: DEC
12452: ST_TO_ADDR
12453: LD_VAR 0 5
12457: PUSH
12458: FOR_TO
12459: IFFALSE 12506
// if GetTag ( tmp [ i ] ) <> tag then
12461: LD_VAR 0 5
12465: PUSH
12466: LD_VAR 0 6
12470: ARRAY
12471: PPUSH
12472: CALL_OW 110
12476: PUSH
12477: LD_VAR 0 3
12481: NONEQUAL
12482: IFFALSE 12504
// SetTag ( tmp [ i ] , tag ) ;
12484: LD_VAR 0 5
12488: PUSH
12489: LD_VAR 0 6
12493: ARRAY
12494: PPUSH
12495: LD_VAR 0 3
12499: PPUSH
12500: CALL_OW 109
12504: GO 12458
12506: POP
12507: POP
// result := true ;
12508: LD_ADDR_VAR 0 4
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// end else
12516: GO 12526
// result := false ;
12518: LD_ADDR_VAR 0 4
12522: PUSH
12523: LD_INT 0
12525: ST_TO_ADDR
// end ;
12526: LD_VAR 0 4
12530: RET
// export function MCF_ClearTag ( side , tag ) ; var tmp , i ; begin
12531: LD_INT 0
12533: PPUSH
12534: PPUSH
12535: PPUSH
// tmp := MCF_Tag ( side , tag , [ ] ) ;
12536: LD_ADDR_VAR 0 4
12540: PUSH
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 2
12550: PPUSH
12551: EMPTY
12552: PPUSH
12553: CALL 12290 0 3
12557: ST_TO_ADDR
// if tmp then
12558: LD_VAR 0 4
12562: IFFALSE 12614
// begin for i = 1 to tmp do
12564: LD_ADDR_VAR 0 5
12568: PUSH
12569: DOUBLE
12570: LD_INT 1
12572: DEC
12573: ST_TO_ADDR
12574: LD_VAR 0 4
12578: PUSH
12579: FOR_TO
12580: IFFALSE 12602
// SetTag ( tmp [ i ] , 0 ) ;
12582: LD_VAR 0 4
12586: PUSH
12587: LD_VAR 0 5
12591: ARRAY
12592: PPUSH
12593: LD_INT 0
12595: PPUSH
12596: CALL_OW 109
12600: GO 12579
12602: POP
12603: POP
// result := true ;
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 1
12611: ST_TO_ADDR
// end else
12612: GO 12622
// result := false ;
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: LD_INT 0
12621: ST_TO_ADDR
// end ;
12622: LD_VAR 0 3
12626: RET
// export function MCF_SortListAsc ( list ) ; var i , j , sort_list , add ; begin
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
12631: PPUSH
12632: PPUSH
12633: PPUSH
// sort_list := [ ] ;
12634: LD_ADDR_VAR 0 5
12638: PUSH
12639: EMPTY
12640: ST_TO_ADDR
// for i = 1 to list do
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: DOUBLE
12647: LD_INT 1
12649: DEC
12650: ST_TO_ADDR
12651: LD_VAR 0 1
12655: PUSH
12656: FOR_TO
12657: IFFALSE 12819
// begin if i = 1 then
12659: LD_VAR 0 3
12663: PUSH
12664: LD_INT 1
12666: EQUAL
12667: IFFALSE 12693
// sort_list := sort_list ^ list [ i ] else
12669: LD_ADDR_VAR 0 5
12673: PUSH
12674: LD_VAR 0 5
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: LD_VAR 0 3
12688: ARRAY
12689: ADD
12690: ST_TO_ADDR
12691: GO 12817
// begin for j = 1 to sort_list do
12693: LD_ADDR_VAR 0 4
12697: PUSH
12698: DOUBLE
12699: LD_INT 1
12701: DEC
12702: ST_TO_ADDR
12703: LD_VAR 0 5
12707: PUSH
12708: FOR_TO
12709: IFFALSE 12786
// begin add := false ;
12711: LD_ADDR_VAR 0 6
12715: PUSH
12716: LD_INT 0
12718: ST_TO_ADDR
// if list [ i ] < sort_list [ j ] then
12719: LD_VAR 0 1
12723: PUSH
12724: LD_VAR 0 3
12728: ARRAY
12729: PUSH
12730: LD_VAR 0 5
12734: PUSH
12735: LD_VAR 0 4
12739: ARRAY
12740: LESS
12741: IFFALSE 12784
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12743: LD_ADDR_VAR 0 5
12747: PUSH
12748: LD_VAR 0 5
12752: PPUSH
12753: LD_VAR 0 4
12757: PPUSH
12758: LD_VAR 0 1
12762: PUSH
12763: LD_VAR 0 3
12767: ARRAY
12768: PPUSH
12769: CALL_OW 2
12773: ST_TO_ADDR
// add := true ;
12774: LD_ADDR_VAR 0 6
12778: PUSH
12779: LD_INT 1
12781: ST_TO_ADDR
// break ;
12782: GO 12786
// end ; end ;
12784: GO 12708
12786: POP
12787: POP
// if not add then
12788: LD_VAR 0 6
12792: NOT
12793: IFFALSE 12817
// sort_list := sort_list ^ list [ i ] ;
12795: LD_ADDR_VAR 0 5
12799: PUSH
12800: LD_VAR 0 5
12804: PUSH
12805: LD_VAR 0 1
12809: PUSH
12810: LD_VAR 0 3
12814: ARRAY
12815: ADD
12816: ST_TO_ADDR
// end ; end ;
12817: GO 12656
12819: POP
12820: POP
// result := sort_list ;
12821: LD_ADDR_VAR 0 2
12825: PUSH
12826: LD_VAR 0 5
12830: ST_TO_ADDR
// end ;
12831: LD_VAR 0 2
12835: RET
// export function MCF_SortListDesc ( list ) ; var i , j , sort_list , add ; begin
12836: LD_INT 0
12838: PPUSH
12839: PPUSH
12840: PPUSH
12841: PPUSH
12842: PPUSH
// sort_list := [ ] ;
12843: LD_ADDR_VAR 0 5
12847: PUSH
12848: EMPTY
12849: ST_TO_ADDR
// for i = 1 to list do
12850: LD_ADDR_VAR 0 3
12854: PUSH
12855: DOUBLE
12856: LD_INT 1
12858: DEC
12859: ST_TO_ADDR
12860: LD_VAR 0 1
12864: PUSH
12865: FOR_TO
12866: IFFALSE 13028
// begin if i = 1 then
12868: LD_VAR 0 3
12872: PUSH
12873: LD_INT 1
12875: EQUAL
12876: IFFALSE 12902
// sort_list := sort_list ^ list [ i ] else
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_VAR 0 5
12887: PUSH
12888: LD_VAR 0 1
12892: PUSH
12893: LD_VAR 0 3
12897: ARRAY
12898: ADD
12899: ST_TO_ADDR
12900: GO 13026
// begin for j = 1 to sort_list do
12902: LD_ADDR_VAR 0 4
12906: PUSH
12907: DOUBLE
12908: LD_INT 1
12910: DEC
12911: ST_TO_ADDR
12912: LD_VAR 0 5
12916: PUSH
12917: FOR_TO
12918: IFFALSE 12995
// begin add := false ;
12920: LD_ADDR_VAR 0 6
12924: PUSH
12925: LD_INT 0
12927: ST_TO_ADDR
// if list [ i ] > sort_list [ j ] then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_VAR 0 3
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 5
12943: PUSH
12944: LD_VAR 0 4
12948: ARRAY
12949: GREATER
12950: IFFALSE 12993
// begin sort_list := Insert ( sort_list , j , list [ i ] ) ;
12952: LD_ADDR_VAR 0 5
12956: PUSH
12957: LD_VAR 0 5
12961: PPUSH
12962: LD_VAR 0 4
12966: PPUSH
12967: LD_VAR 0 1
12971: PUSH
12972: LD_VAR 0 3
12976: ARRAY
12977: PPUSH
12978: CALL_OW 2
12982: ST_TO_ADDR
// add := true ;
12983: LD_ADDR_VAR 0 6
12987: PUSH
12988: LD_INT 1
12990: ST_TO_ADDR
// break ;
12991: GO 12995
// end ; end ;
12993: GO 12917
12995: POP
12996: POP
// if not add then
12997: LD_VAR 0 6
13001: NOT
13002: IFFALSE 13026
// sort_list := sort_list ^ list [ i ] ;
13004: LD_ADDR_VAR 0 5
13008: PUSH
13009: LD_VAR 0 5
13013: PUSH
13014: LD_VAR 0 1
13018: PUSH
13019: LD_VAR 0 3
13023: ARRAY
13024: ADD
13025: ST_TO_ADDR
// end ; end ;
13026: GO 12865
13028: POP
13029: POP
// result := sort_list ;
13030: LD_ADDR_VAR 0 2
13034: PUSH
13035: LD_VAR 0 5
13039: ST_TO_ADDR
// end ;
13040: LD_VAR 0 2
13044: RET
// export function MCF_SortLevelAsc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13045: LD_INT 0
13047: PPUSH
13048: PPUSH
13049: PPUSH
13050: PPUSH
13051: PPUSH
13052: PPUSH
// tmp := [ ] ;
13053: LD_ADDR_VAR 0 8
13057: PUSH
13058: EMPTY
13059: ST_TO_ADDR
// r := [ ] ;
13060: LD_ADDR_VAR 0 7
13064: PUSH
13065: EMPTY
13066: ST_TO_ADDR
// add := false ;
13067: LD_ADDR_VAR 0 9
13071: PUSH
13072: LD_INT 0
13074: ST_TO_ADDR
// if plist then
13075: LD_VAR 0 2
13079: IFFALSE 13155
// begin for i = 1 to plist do
13081: LD_ADDR_VAR 0 5
13085: PUSH
13086: DOUBLE
13087: LD_INT 1
13089: DEC
13090: ST_TO_ADDR
13091: LD_VAR 0 2
13095: PUSH
13096: FOR_TO
13097: IFFALSE 13151
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13099: LD_ADDR_VAR 0 8
13103: PUSH
13104: LD_VAR 0 8
13108: PUSH
13109: LD_VAR 0 2
13113: PUSH
13114: LD_VAR 0 5
13118: ARRAY
13119: PUSH
13120: LD_VAR 0 2
13124: PUSH
13125: LD_VAR 0 5
13129: ARRAY
13130: PPUSH
13131: LD_VAR 0 3
13135: PPUSH
13136: CALL_OW 259
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: ADD
13148: ST_TO_ADDR
// end ;
13149: GO 13096
13151: POP
13152: POP
// end else
13153: GO 13163
// result := false ;
13155: LD_ADDR_VAR 0 4
13159: PUSH
13160: LD_INT 0
13162: ST_TO_ADDR
// if tmp then
13163: LD_VAR 0 8
13167: IFFALSE 13341
// begin r := r ^ [ tmp [ 1 ] ] ;
13169: LD_ADDR_VAR 0 7
13173: PUSH
13174: LD_VAR 0 7
13178: PUSH
13179: LD_VAR 0 8
13183: PUSH
13184: LD_INT 1
13186: ARRAY
13187: PUSH
13188: EMPTY
13189: LIST
13190: ADD
13191: ST_TO_ADDR
// for i = 2 to tmp do
13192: LD_ADDR_VAR 0 5
13196: PUSH
13197: DOUBLE
13198: LD_INT 2
13200: DEC
13201: ST_TO_ADDR
13202: LD_VAR 0 8
13206: PUSH
13207: FOR_TO
13208: IFFALSE 13339
// begin for j = 1 to r do
13210: LD_ADDR_VAR 0 6
13214: PUSH
13215: DOUBLE
13216: LD_INT 1
13218: DEC
13219: ST_TO_ADDR
13220: LD_VAR 0 7
13224: PUSH
13225: FOR_TO
13226: IFFALSE 13303
// begin if tmp [ i ] [ 2 ] < r [ j ] [ 2 ] then
13228: LD_VAR 0 8
13232: PUSH
13233: LD_VAR 0 5
13237: ARRAY
13238: PUSH
13239: LD_INT 2
13241: ARRAY
13242: PUSH
13243: LD_VAR 0 7
13247: PUSH
13248: LD_VAR 0 6
13252: ARRAY
13253: PUSH
13254: LD_INT 2
13256: ARRAY
13257: LESS
13258: IFFALSE 13301
// begin r := Insert ( r , j , tmp [ i ] ) ;
13260: LD_ADDR_VAR 0 7
13264: PUSH
13265: LD_VAR 0 7
13269: PPUSH
13270: LD_VAR 0 6
13274: PPUSH
13275: LD_VAR 0 8
13279: PUSH
13280: LD_VAR 0 5
13284: ARRAY
13285: PPUSH
13286: CALL_OW 2
13290: ST_TO_ADDR
// add := true ;
13291: LD_ADDR_VAR 0 9
13295: PUSH
13296: LD_INT 1
13298: ST_TO_ADDR
// break ;
13299: GO 13303
// end ; end ;
13301: GO 13225
13303: POP
13304: POP
// if not add then
13305: LD_VAR 0 9
13309: NOT
13310: IFFALSE 13337
// r := r ^ [ tmp [ i ] ] ;
13312: LD_ADDR_VAR 0 7
13316: PUSH
13317: LD_VAR 0 7
13321: PUSH
13322: LD_VAR 0 8
13326: PUSH
13327: LD_VAR 0 5
13331: ARRAY
13332: PUSH
13333: EMPTY
13334: LIST
13335: ADD
13336: ST_TO_ADDR
// end ;
13337: GO 13207
13339: POP
13340: POP
// end ; result := r ;
13341: LD_ADDR_VAR 0 4
13345: PUSH
13346: LD_VAR 0 7
13350: ST_TO_ADDR
// end ;
13351: LD_VAR 0 4
13355: RET
// export function MCF_SortLevelDesc ( side , plist , skill ) ; var i , j , r , tmp , add ; begin
13356: LD_INT 0
13358: PPUSH
13359: PPUSH
13360: PPUSH
13361: PPUSH
13362: PPUSH
13363: PPUSH
// tmp := [ ] ;
13364: LD_ADDR_VAR 0 8
13368: PUSH
13369: EMPTY
13370: ST_TO_ADDR
// r := [ ] ;
13371: LD_ADDR_VAR 0 7
13375: PUSH
13376: EMPTY
13377: ST_TO_ADDR
// add := false ;
13378: LD_ADDR_VAR 0 9
13382: PUSH
13383: LD_INT 0
13385: ST_TO_ADDR
// if plist then
13386: LD_VAR 0 2
13390: IFFALSE 13466
// begin for i = 1 to plist do
13392: LD_ADDR_VAR 0 5
13396: PUSH
13397: DOUBLE
13398: LD_INT 1
13400: DEC
13401: ST_TO_ADDR
13402: LD_VAR 0 2
13406: PUSH
13407: FOR_TO
13408: IFFALSE 13462
// begin tmp := tmp ^ [ [ plist [ i ] , GetSkill ( plist [ i ] , skill ) ] ] ;
13410: LD_ADDR_VAR 0 8
13414: PUSH
13415: LD_VAR 0 8
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_VAR 0 5
13429: ARRAY
13430: PUSH
13431: LD_VAR 0 2
13435: PUSH
13436: LD_VAR 0 5
13440: ARRAY
13441: PPUSH
13442: LD_VAR 0 3
13446: PPUSH
13447: CALL_OW 259
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: ADD
13459: ST_TO_ADDR
// end ;
13460: GO 13407
13462: POP
13463: POP
// end else
13464: GO 13474
// result := false ;
13466: LD_ADDR_VAR 0 4
13470: PUSH
13471: LD_INT 0
13473: ST_TO_ADDR
// if tmp then
13474: LD_VAR 0 8
13478: IFFALSE 13652
// begin r := r ^ [ tmp [ 1 ] ] ;
13480: LD_ADDR_VAR 0 7
13484: PUSH
13485: LD_VAR 0 7
13489: PUSH
13490: LD_VAR 0 8
13494: PUSH
13495: LD_INT 1
13497: ARRAY
13498: PUSH
13499: EMPTY
13500: LIST
13501: ADD
13502: ST_TO_ADDR
// for i = 2 to tmp do
13503: LD_ADDR_VAR 0 5
13507: PUSH
13508: DOUBLE
13509: LD_INT 2
13511: DEC
13512: ST_TO_ADDR
13513: LD_VAR 0 8
13517: PUSH
13518: FOR_TO
13519: IFFALSE 13650
// begin for j = 1 to r do
13521: LD_ADDR_VAR 0 6
13525: PUSH
13526: DOUBLE
13527: LD_INT 1
13529: DEC
13530: ST_TO_ADDR
13531: LD_VAR 0 7
13535: PUSH
13536: FOR_TO
13537: IFFALSE 13614
// begin if tmp [ i ] [ 2 ] > r [ j ] [ 2 ] then
13539: LD_VAR 0 8
13543: PUSH
13544: LD_VAR 0 5
13548: ARRAY
13549: PUSH
13550: LD_INT 2
13552: ARRAY
13553: PUSH
13554: LD_VAR 0 7
13558: PUSH
13559: LD_VAR 0 6
13563: ARRAY
13564: PUSH
13565: LD_INT 2
13567: ARRAY
13568: GREATER
13569: IFFALSE 13612
// begin r := Insert ( r , j , tmp [ i ] ) ;
13571: LD_ADDR_VAR 0 7
13575: PUSH
13576: LD_VAR 0 7
13580: PPUSH
13581: LD_VAR 0 6
13585: PPUSH
13586: LD_VAR 0 8
13590: PUSH
13591: LD_VAR 0 5
13595: ARRAY
13596: PPUSH
13597: CALL_OW 2
13601: ST_TO_ADDR
// add := true ;
13602: LD_ADDR_VAR 0 9
13606: PUSH
13607: LD_INT 1
13609: ST_TO_ADDR
// break ;
13610: GO 13614
// end ; end ;
13612: GO 13536
13614: POP
13615: POP
// if not add then
13616: LD_VAR 0 9
13620: NOT
13621: IFFALSE 13648
// r := r ^ [ tmp [ i ] ] ;
13623: LD_ADDR_VAR 0 7
13627: PUSH
13628: LD_VAR 0 7
13632: PUSH
13633: LD_VAR 0 8
13637: PUSH
13638: LD_VAR 0 5
13642: ARRAY
13643: PUSH
13644: EMPTY
13645: LIST
13646: ADD
13647: ST_TO_ADDR
// end ;
13648: GO 13518
13650: POP
13651: POP
// end ; result := r ;
13652: LD_ADDR_VAR 0 4
13656: PUSH
13657: LD_VAR 0 7
13661: ST_TO_ADDR
// end ;
13662: LD_VAR 0 4
13666: RET
// export function MCF_Clear ( side ) ; var i ; begin
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
// for i = 1 to 100 do
13671: LD_ADDR_VAR 0 3
13675: PUSH
13676: DOUBLE
13677: LD_INT 1
13679: DEC
13680: ST_TO_ADDR
13681: LD_INT 100
13683: PUSH
13684: FOR_TO
13685: IFFALSE 13721
// if MCF_Tag ( side , i , [ ] ) then
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 3
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL 12290 0 3
13703: IFFALSE 13719
// MCF_ClearTag ( side , i ) ;
13705: LD_VAR 0 1
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: CALL 12531 0 2
13719: GO 13684
13721: POP
13722: POP
// result := true ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_INT 1
13730: ST_TO_ADDR
// end ;
13731: LD_VAR 0 2
13735: RET
// export function MCF_NoClass ( plist , n ) ; var i , tmp ; begin
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
13740: PPUSH
// for i = 1 to plist do
13741: LD_ADDR_VAR 0 4
13745: PUSH
13746: DOUBLE
13747: LD_INT 1
13749: DEC
13750: ST_TO_ADDR
13751: LD_VAR 0 1
13755: PUSH
13756: FOR_TO
13757: IFFALSE 13806
// if MCF_HasClass ( plist [ i ] ) = n then
13759: LD_VAR 0 1
13763: PUSH
13764: LD_VAR 0 4
13768: ARRAY
13769: PPUSH
13770: CALL 14293 0 1
13774: PUSH
13775: LD_VAR 0 2
13779: EQUAL
13780: IFFALSE 13804
// tmp := tmp ^ plist [ i ] ;
13782: LD_ADDR_VAR 0 5
13786: PUSH
13787: LD_VAR 0 5
13791: PUSH
13792: LD_VAR 0 1
13796: PUSH
13797: LD_VAR 0 4
13801: ARRAY
13802: ADD
13803: ST_TO_ADDR
13804: GO 13756
13806: POP
13807: POP
// result := tmp ;
13808: LD_ADDR_VAR 0 3
13812: PUSH
13813: LD_VAR 0 5
13817: ST_TO_ADDR
// end ;
13818: LD_VAR 0 3
13822: RET
// export function MCF_RemoveClass ( side , mreg , n ) ; var i , tmp ; begin
13823: LD_INT 0
13825: PPUSH
13826: PPUSH
13827: PPUSH
// if mreg = ToArm then
13828: LD_VAR 0 2
13832: PUSH
13833: LD_STRING ToArm
13835: EQUAL
13836: IFFALSE 13941
// begin tmp := MREG_ToArm [ side ] ;
13838: LD_ADDR_VAR 0 6
13842: PUSH
13843: LD_EXP 58
13847: PUSH
13848: LD_VAR 0 1
13852: ARRAY
13853: ST_TO_ADDR
// if tmp = 0 then
13854: LD_VAR 0 6
13858: PUSH
13859: LD_INT 0
13861: EQUAL
13862: IFFALSE 13868
// exit else
13864: GO 14288
13866: GO 13941
// begin for i = MREG_ToArm [ side ] downto n do
13868: LD_ADDR_VAR 0 5
13872: PUSH
13873: DOUBLE
13874: LD_EXP 58
13878: PUSH
13879: LD_VAR 0 1
13883: ARRAY
13884: INC
13885: ST_TO_ADDR
13886: LD_VAR 0 3
13890: PUSH
13891: FOR_DOWNTO
13892: IFFALSE 13914
// tmp := Delete ( tmp , 1 ) ;
13894: LD_ADDR_VAR 0 6
13898: PUSH
13899: LD_VAR 0 6
13903: PPUSH
13904: LD_INT 1
13906: PPUSH
13907: CALL_OW 3
13911: ST_TO_ADDR
13912: GO 13891
13914: POP
13915: POP
// MREG_ToArm := Replace ( MREG_ToArm , side , tmp ) ;
13916: LD_ADDR_EXP 58
13920: PUSH
13921: LD_EXP 58
13925: PPUSH
13926: LD_VAR 0 1
13930: PPUSH
13931: LD_VAR 0 6
13935: PPUSH
13936: CALL_OW 1
13940: ST_TO_ADDR
// end ; end ; if mreg = ToDep then
13941: LD_VAR 0 2
13945: PUSH
13946: LD_STRING ToDep
13948: EQUAL
13949: IFFALSE 14054
// begin tmp := MREG_ToDep [ side ] ;
13951: LD_ADDR_VAR 0 6
13955: PUSH
13956: LD_EXP 59
13960: PUSH
13961: LD_VAR 0 1
13965: ARRAY
13966: ST_TO_ADDR
// if tmp = 0 then
13967: LD_VAR 0 6
13971: PUSH
13972: LD_INT 0
13974: EQUAL
13975: IFFALSE 13981
// exit else
13977: GO 14288
13979: GO 14054
// begin for i = MREG_ToDep [ side ] downto n do
13981: LD_ADDR_VAR 0 5
13985: PUSH
13986: DOUBLE
13987: LD_EXP 59
13991: PUSH
13992: LD_VAR 0 1
13996: ARRAY
13997: INC
13998: ST_TO_ADDR
13999: LD_VAR 0 3
14003: PUSH
14004: FOR_DOWNTO
14005: IFFALSE 14027
// tmp := Delete ( tmp , 1 ) ;
14007: LD_ADDR_VAR 0 6
14011: PUSH
14012: LD_VAR 0 6
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL_OW 3
14024: ST_TO_ADDR
14025: GO 14004
14027: POP
14028: POP
// MREG_ToDep := Replace ( MREG_ToDep , side , tmp ) ;
14029: LD_ADDR_EXP 59
14033: PUSH
14034: LD_EXP 59
14038: PPUSH
14039: LD_VAR 0 1
14043: PPUSH
14044: LD_VAR 0 6
14048: PPUSH
14049: CALL_OW 1
14053: ST_TO_ADDR
// end ; end ; if mreg = ToFac then
14054: LD_VAR 0 2
14058: PUSH
14059: LD_STRING ToFac
14061: EQUAL
14062: IFFALSE 14167
// begin tmp := MREG_ToFac [ side ] ;
14064: LD_ADDR_VAR 0 6
14068: PUSH
14069: LD_EXP 57
14073: PUSH
14074: LD_VAR 0 1
14078: ARRAY
14079: ST_TO_ADDR
// if tmp = 0 then
14080: LD_VAR 0 6
14084: PUSH
14085: LD_INT 0
14087: EQUAL
14088: IFFALSE 14094
// exit else
14090: GO 14288
14092: GO 14167
// begin for i = MREG_ToFac [ side ] downto n do
14094: LD_ADDR_VAR 0 5
14098: PUSH
14099: DOUBLE
14100: LD_EXP 57
14104: PUSH
14105: LD_VAR 0 1
14109: ARRAY
14110: INC
14111: ST_TO_ADDR
14112: LD_VAR 0 3
14116: PUSH
14117: FOR_DOWNTO
14118: IFFALSE 14140
// tmp := Delete ( tmp , 1 ) ;
14120: LD_ADDR_VAR 0 6
14124: PUSH
14125: LD_VAR 0 6
14129: PPUSH
14130: LD_INT 1
14132: PPUSH
14133: CALL_OW 3
14137: ST_TO_ADDR
14138: GO 14117
14140: POP
14141: POP
// MREG_ToFac := Replace ( MREG_ToFac , side , tmp ) ;
14142: LD_ADDR_EXP 57
14146: PUSH
14147: LD_EXP 57
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 6
14161: PPUSH
14162: CALL_OW 1
14166: ST_TO_ADDR
// end ; end ; if mreg = ToLab then
14167: LD_VAR 0 2
14171: PUSH
14172: LD_STRING ToLab
14174: EQUAL
14175: IFFALSE 14280
// begin tmp := MREG_ToLab [ side ] ;
14177: LD_ADDR_VAR 0 6
14181: PUSH
14182: LD_EXP 56
14186: PUSH
14187: LD_VAR 0 1
14191: ARRAY
14192: ST_TO_ADDR
// if tmp = 0 then
14193: LD_VAR 0 6
14197: PUSH
14198: LD_INT 0
14200: EQUAL
14201: IFFALSE 14207
// exit else
14203: GO 14288
14205: GO 14280
// begin for i = MREG_ToLab [ side ] downto n do
14207: LD_ADDR_VAR 0 5
14211: PUSH
14212: DOUBLE
14213: LD_EXP 56
14217: PUSH
14218: LD_VAR 0 1
14222: ARRAY
14223: INC
14224: ST_TO_ADDR
14225: LD_VAR 0 3
14229: PUSH
14230: FOR_DOWNTO
14231: IFFALSE 14253
// tmp := Delete ( tmp , 1 ) ;
14233: LD_ADDR_VAR 0 6
14237: PUSH
14238: LD_VAR 0 6
14242: PPUSH
14243: LD_INT 1
14245: PPUSH
14246: CALL_OW 3
14250: ST_TO_ADDR
14251: GO 14230
14253: POP
14254: POP
// MREG_ToLab := Replace ( MREG_ToLab , side , tmp ) ;
14255: LD_ADDR_EXP 56
14259: PUSH
14260: LD_EXP 56
14264: PPUSH
14265: LD_VAR 0 1
14269: PPUSH
14270: LD_VAR 0 6
14274: PPUSH
14275: CALL_OW 1
14279: ST_TO_ADDR
// end ; end ; result := true ;
14280: LD_ADDR_VAR 0 4
14284: PUSH
14285: LD_INT 1
14287: ST_TO_ADDR
// end ;
14288: LD_VAR 0 4
14292: RET
// export function MCF_HasClass ( unit ) ; var tmp , side ; begin
14293: LD_INT 0
14295: PPUSH
14296: PPUSH
14297: PPUSH
// side := GetSide ( unit ) ;
14298: LD_ADDR_VAR 0 4
14302: PUSH
14303: LD_VAR 0 1
14307: PPUSH
14308: CALL_OW 255
14312: ST_TO_ADDR
// tmp := 0 ;
14313: LD_ADDR_VAR 0 3
14317: PUSH
14318: LD_INT 0
14320: ST_TO_ADDR
// if unit in MREG_ToArm [ side ] then
14321: LD_VAR 0 1
14325: PUSH
14326: LD_EXP 58
14330: PUSH
14331: LD_VAR 0 4
14335: ARRAY
14336: IN
14337: IFFALSE 14347
// tmp := 1 ;
14339: LD_ADDR_VAR 0 3
14343: PUSH
14344: LD_INT 1
14346: ST_TO_ADDR
// if unit in MREG_ToDep [ side ] then
14347: LD_VAR 0 1
14351: PUSH
14352: LD_EXP 59
14356: PUSH
14357: LD_VAR 0 4
14361: ARRAY
14362: IN
14363: IFFALSE 14373
// tmp := 2 ;
14365: LD_ADDR_VAR 0 3
14369: PUSH
14370: LD_INT 2
14372: ST_TO_ADDR
// if unit in MREG_ToFac [ side ] then
14373: LD_VAR 0 1
14377: PUSH
14378: LD_EXP 57
14382: PUSH
14383: LD_VAR 0 4
14387: ARRAY
14388: IN
14389: IFFALSE 14399
// tmp := 3 ;
14391: LD_ADDR_VAR 0 3
14395: PUSH
14396: LD_INT 3
14398: ST_TO_ADDR
// if unit in MREG_ToLab [ side ] then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 56
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: IN
14415: IFFALSE 14425
// tmp := 4 ;
14417: LD_ADDR_VAR 0 3
14421: PUSH
14422: LD_INT 4
14424: ST_TO_ADDR
// if unit in MREG_ToBunker [ side ] then
14425: LD_VAR 0 1
14429: PUSH
14430: LD_EXP 70
14434: PUSH
14435: LD_VAR 0 4
14439: ARRAY
14440: IN
14441: IFFALSE 14451
// tmp := 5 ;
14443: LD_ADDR_VAR 0 3
14447: PUSH
14448: LD_INT 5
14450: ST_TO_ADDR
// result := tmp ;
14451: LD_ADDR_VAR 0 2
14455: PUSH
14456: LD_VAR 0 3
14460: ST_TO_ADDR
// end ;
14461: LD_VAR 0 2
14465: RET
// export function MCF_RemoveFromClass ( side , mreg , unit ) ; var i ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
// if mreg = ToArm then
14470: LD_VAR 0 2
14474: PUSH
14475: LD_STRING ToArm
14477: EQUAL
14478: IFFALSE 14567
// for i = MREG_ToArm [ side ] downto 1 do
14480: LD_ADDR_VAR 0 5
14484: PUSH
14485: DOUBLE
14486: LD_EXP 58
14490: PUSH
14491: LD_VAR 0 1
14495: ARRAY
14496: INC
14497: ST_TO_ADDR
14498: LD_INT 1
14500: PUSH
14501: FOR_DOWNTO
14502: IFFALSE 14565
// if MREG_ToArm [ side ] [ i ] = unit then
14504: LD_EXP 58
14508: PUSH
14509: LD_VAR 0 1
14513: ARRAY
14514: PUSH
14515: LD_VAR 0 5
14519: ARRAY
14520: PUSH
14521: LD_VAR 0 3
14525: EQUAL
14526: IFFALSE 14563
// begin MREG_ToArm := Remove ( MREG_ToArm , MREG_ToArm [ side ] [ i ] , true ) ;
14528: LD_ADDR_EXP 58
14532: PUSH
14533: LD_EXP 58
14537: PPUSH
14538: LD_EXP 58
14542: PUSH
14543: LD_VAR 0 1
14547: ARRAY
14548: PUSH
14549: LD_VAR 0 5
14553: ARRAY
14554: PPUSH
14555: LD_INT 1
14557: PPUSH
14558: CALL 31211 0 3
14562: ST_TO_ADDR
// end ;
14563: GO 14501
14565: POP
14566: POP
// if mreg = ToDep then
14567: LD_VAR 0 2
14571: PUSH
14572: LD_STRING ToDep
14574: EQUAL
14575: IFFALSE 14664
// for i = MREG_ToDep [ side ] downto 1 do
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: DOUBLE
14583: LD_EXP 59
14587: PUSH
14588: LD_VAR 0 1
14592: ARRAY
14593: INC
14594: ST_TO_ADDR
14595: LD_INT 1
14597: PUSH
14598: FOR_DOWNTO
14599: IFFALSE 14662
// if MREG_ToDep [ side ] [ i ] = unit then
14601: LD_EXP 59
14605: PUSH
14606: LD_VAR 0 1
14610: ARRAY
14611: PUSH
14612: LD_VAR 0 5
14616: ARRAY
14617: PUSH
14618: LD_VAR 0 3
14622: EQUAL
14623: IFFALSE 14660
// begin MREG_ToDep := Remove ( MREG_ToDep , MREG_ToDep [ side ] [ i ] , true ) ;
14625: LD_ADDR_EXP 59
14629: PUSH
14630: LD_EXP 59
14634: PPUSH
14635: LD_EXP 59
14639: PUSH
14640: LD_VAR 0 1
14644: ARRAY
14645: PUSH
14646: LD_VAR 0 5
14650: ARRAY
14651: PPUSH
14652: LD_INT 1
14654: PPUSH
14655: CALL 31211 0 3
14659: ST_TO_ADDR
// end ;
14660: GO 14598
14662: POP
14663: POP
// if mreg = ToFac then
14664: LD_VAR 0 2
14668: PUSH
14669: LD_STRING ToFac
14671: EQUAL
14672: IFFALSE 14761
// for i = MREG_ToFac [ side ] downto 1 do
14674: LD_ADDR_VAR 0 5
14678: PUSH
14679: DOUBLE
14680: LD_EXP 57
14684: PUSH
14685: LD_VAR 0 1
14689: ARRAY
14690: INC
14691: ST_TO_ADDR
14692: LD_INT 1
14694: PUSH
14695: FOR_DOWNTO
14696: IFFALSE 14759
// if MREG_ToFac [ side ] [ i ] = unit then
14698: LD_EXP 57
14702: PUSH
14703: LD_VAR 0 1
14707: ARRAY
14708: PUSH
14709: LD_VAR 0 5
14713: ARRAY
14714: PUSH
14715: LD_VAR 0 3
14719: EQUAL
14720: IFFALSE 14757
// begin MREG_ToFac := Remove ( MREG_ToFac , MREG_ToFac [ side ] [ i ] , true ) ;
14722: LD_ADDR_EXP 57
14726: PUSH
14727: LD_EXP 57
14731: PPUSH
14732: LD_EXP 57
14736: PUSH
14737: LD_VAR 0 1
14741: ARRAY
14742: PUSH
14743: LD_VAR 0 5
14747: ARRAY
14748: PPUSH
14749: LD_INT 1
14751: PPUSH
14752: CALL 31211 0 3
14756: ST_TO_ADDR
// end ;
14757: GO 14695
14759: POP
14760: POP
// if mreg = ToLab then
14761: LD_VAR 0 2
14765: PUSH
14766: LD_STRING ToLab
14768: EQUAL
14769: IFFALSE 14858
// for i = MREG_ToLab [ side ] downto 1 do
14771: LD_ADDR_VAR 0 5
14775: PUSH
14776: DOUBLE
14777: LD_EXP 56
14781: PUSH
14782: LD_VAR 0 1
14786: ARRAY
14787: INC
14788: ST_TO_ADDR
14789: LD_INT 1
14791: PUSH
14792: FOR_DOWNTO
14793: IFFALSE 14856
// if MREG_ToLab [ side ] [ i ] = unit then
14795: LD_EXP 56
14799: PUSH
14800: LD_VAR 0 1
14804: ARRAY
14805: PUSH
14806: LD_VAR 0 5
14810: ARRAY
14811: PUSH
14812: LD_VAR 0 3
14816: EQUAL
14817: IFFALSE 14854
// begin MREG_ToLab := Remove ( MREG_ToLab , MREG_ToLab [ side ] [ i ] , true ) ;
14819: LD_ADDR_EXP 56
14823: PUSH
14824: LD_EXP 56
14828: PPUSH
14829: LD_EXP 56
14833: PUSH
14834: LD_VAR 0 1
14838: ARRAY
14839: PUSH
14840: LD_VAR 0 5
14844: ARRAY
14845: PPUSH
14846: LD_INT 1
14848: PPUSH
14849: CALL 31211 0 3
14853: ST_TO_ADDR
// end ;
14854: GO 14792
14856: POP
14857: POP
// end ;
14858: LD_VAR 0 4
14862: RET
// export function MCF_UnfinishedBuilding ( side ) ; var i ; begin
14863: LD_INT 0
14865: PPUSH
14866: PPUSH
// result := false ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_INT 0
14874: ST_TO_ADDR
// for i = 1 to MREG_ToBuild do
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_EXP 48
14889: PUSH
14890: FOR_TO
14891: IFFALSE 14955
// if MREG_ToBuild [ i ] [ 1 ] = side then
14893: LD_EXP 48
14897: PUSH
14898: LD_VAR 0 3
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 1
14912: EQUAL
14913: IFFALSE 14953
// begin if MREG_ToBuild [ i ] [ 1 ] then
14915: LD_EXP 48
14919: PUSH
14920: LD_VAR 0 3
14924: ARRAY
14925: PUSH
14926: LD_INT 1
14928: ARRAY
14929: IFFALSE 14953
// begin result := MREG_ToBuild [ i ] [ 1 ] ;
14931: LD_ADDR_VAR 0 2
14935: PUSH
14936: LD_EXP 48
14940: PUSH
14941: LD_VAR 0 3
14945: ARRAY
14946: PUSH
14947: LD_INT 1
14949: ARRAY
14950: ST_TO_ADDR
// break ;
14951: GO 14955
// end ; end ;
14953: GO 14890
14955: POP
14956: POP
// for i = 1 to MREG_ToRepair do
14957: LD_ADDR_VAR 0 3
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 49
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15037
// if MREG_ToRepair [ i ] [ 1 ] = side then
14975: LD_EXP 49
14979: PUSH
14980: LD_VAR 0 3
14984: ARRAY
14985: PUSH
14986: LD_INT 1
14988: ARRAY
14989: PUSH
14990: LD_VAR 0 1
14994: EQUAL
14995: IFFALSE 15035
// begin if MREG_ToRepair [ i ] [ 1 ] then
14997: LD_EXP 49
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: PUSH
15008: LD_INT 1
15010: ARRAY
15011: IFFALSE 15035
// begin result := MREG_ToRepair [ i ] [ 1 ] ;
15013: LD_ADDR_VAR 0 2
15017: PUSH
15018: LD_EXP 49
15022: PUSH
15023: LD_VAR 0 3
15027: ARRAY
15028: PUSH
15029: LD_INT 1
15031: ARRAY
15032: ST_TO_ADDR
// break ;
15033: GO 15037
// end ; end ;
15035: GO 14972
15037: POP
15038: POP
// if MCF_Get ( side , [ f_constructed ] ) then
15039: LD_VAR 0 1
15043: PPUSH
15044: LD_INT 57
15046: PUSH
15047: EMPTY
15048: LIST
15049: PPUSH
15050: CALL 11587 0 2
15054: IFFALSE 15081
// result := MCF_Get ( side , [ f_constructed ] ) [ 1 ] ;
15056: LD_ADDR_VAR 0 2
15060: PUSH
15061: LD_VAR 0 1
15065: PPUSH
15066: LD_INT 57
15068: PUSH
15069: EMPTY
15070: LIST
15071: PPUSH
15072: CALL 11587 0 2
15076: PUSH
15077: LD_INT 1
15079: ARRAY
15080: ST_TO_ADDR
// end ;
15081: LD_VAR 0 2
15085: RET
// export function MCF_ScanTeren ( side , dist ) ; var i , scan , b , enemy ; begin
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
15090: PPUSH
15091: PPUSH
15092: PPUSH
// b := MCF_Get ( side , [ f_type , unit_building ] ) ;
15093: LD_ADDR_VAR 0 6
15097: PUSH
15098: LD_VAR 0 1
15102: PPUSH
15103: LD_INT 21
15105: PUSH
15106: LD_INT 3
15108: PUSH
15109: EMPTY
15110: LIST
15111: LIST
15112: PPUSH
15113: CALL 11587 0 2
15117: ST_TO_ADDR
// enemy := MCF_Get ( side , [ f_enemy , side ] ) ;
15118: LD_ADDR_VAR 0 7
15122: PUSH
15123: LD_VAR 0 1
15127: PPUSH
15128: LD_INT 81
15130: PUSH
15131: LD_VAR 0 1
15135: PUSH
15136: EMPTY
15137: LIST
15138: LIST
15139: PPUSH
15140: CALL 11587 0 2
15144: ST_TO_ADDR
// if not enemy then
15145: LD_VAR 0 7
15149: NOT
15150: IFFALSE 15162
// result := false else
15152: LD_ADDR_VAR 0 3
15156: PUSH
15157: LD_INT 0
15159: ST_TO_ADDR
15160: GO 15216
// begin scan := NearestUnit ( b , enemy ) ;
15162: LD_ADDR_VAR 0 5
15166: PUSH
15167: LD_VAR 0 6
15171: PPUSH
15172: LD_VAR 0 7
15176: PPUSH
15177: CALL 32204 0 2
15181: ST_TO_ADDR
// if scan [ 2 ] < dist then
15182: LD_VAR 0 5
15186: PUSH
15187: LD_INT 2
15189: ARRAY
15190: PUSH
15191: LD_VAR 0 2
15195: LESS
15196: IFFALSE 15208
// result := true else
15198: LD_ADDR_VAR 0 3
15202: PUSH
15203: LD_INT 1
15205: ST_TO_ADDR
15206: GO 15216
// result := false ;
15208: LD_ADDR_VAR 0 3
15212: PUSH
15213: LD_INT 0
15215: ST_TO_ADDR
// end ; end ;
15216: LD_VAR 0 3
15220: RET
// export function MCF_Info ( ) ; begin
15221: LD_INT 0
15223: PPUSH
// MC_Show ( MCF to zbir funkcji sucych do operacji na listach i filtrach: ^ - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw] ^ - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw] ^ - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek ^ - MCF_ClearTag -> Kasuje dany tag ^ - MCF_SortListAsc -> Sortuj list rosnco ^ - MCF_SortListDesc -> Sortuj list malejco ^ - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco ^ - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco ^ - MCF_Clear -> Kasuje wszystkie tagi ) ;
15224: LD_STRING MCF to zbir funkcji sucych do operacji na listach i filtrach:
15226: PUSH
15227: LD_STRING - MCF_Class -> Wywietla dan klas [moliwe doczenie dodatkowych filtrw]
15229: ADD
15230: PUSH
15231: LD_STRING - MCF_Tag -> Wywietla wszystkie jednostki z danymi tagiem [moliwe doczenie dodatkowych filtrw]
15233: ADD
15234: PUSH
15235: LD_STRING - MCF_SetTag -> Umoliwia nadanie tagu danej grupie jednostek
15237: ADD
15238: PUSH
15239: LD_STRING - MCF_ClearTag -> Kasuje dany tag
15241: ADD
15242: PUSH
15243: LD_STRING - MCF_SortListAsc -> Sortuj list rosnco
15245: ADD
15246: PUSH
15247: LD_STRING - MCF_SortListDesc -> Sortuj list malejco
15249: ADD
15250: PUSH
15251: LD_STRING - MCF_SortLevelAsc -> Sortuj dan grup jednnostek wg. danej umiejetnoci wg. poziomu rosnco
15253: ADD
15254: PUSH
15255: LD_STRING - MCF_SortLevelDesc -> Sortuj dan grup jednostek wg. danej umiejetnoci wg. poziomu malejco
15257: ADD
15258: PUSH
15259: LD_STRING - MCF_Clear -> Kasuje wszystkie tagi
15261: ADD
15262: PPUSH
15263: CALL 8505 0 1
// end ; end_of_file
15267: LD_VAR 0 1
15271: RET
// export function MCH_TrainSoldier ( side , n ) ; var i , tmp , sk ; begin
15272: LD_INT 0
15274: PPUSH
15275: PPUSH
15276: PPUSH
15277: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15278: LD_ADDR_VAR 0 5
15282: PUSH
15283: LD_VAR 0 1
15287: PPUSH
15288: LD_INT 2
15290: PUSH
15291: LD_INT 25
15293: PUSH
15294: LD_INT 2
15296: PUSH
15297: EMPTY
15298: LIST
15299: LIST
15300: PUSH
15301: LD_INT 25
15303: PUSH
15304: LD_INT 3
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: PUSH
15311: LD_INT 25
15313: PUSH
15314: LD_INT 4
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PPUSH
15327: CALL 11587 0 2
15331: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15332: LD_ADDR_VAR 0 5
15336: PUSH
15337: LD_VAR 0 5
15341: PPUSH
15342: LD_INT 0
15344: PPUSH
15345: CALL 13736 0 2
15349: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
15350: LD_ADDR_VAR 0 6
15354: PUSH
15355: LD_VAR 0 1
15359: PPUSH
15360: LD_VAR 0 5
15364: PPUSH
15365: LD_INT 1
15367: PPUSH
15368: CALL 13356 0 3
15372: ST_TO_ADDR
// if n > sk then
15373: LD_VAR 0 2
15377: PUSH
15378: LD_VAR 0 6
15382: GREATER
15383: IFFALSE 15395
// n := sk ;
15385: LD_ADDR_VAR 0 2
15389: PUSH
15390: LD_VAR 0 6
15394: ST_TO_ADDR
// for i = 1 to n do
15395: LD_ADDR_VAR 0 4
15399: PUSH
15400: DOUBLE
15401: LD_INT 1
15403: DEC
15404: ST_TO_ADDR
15405: LD_VAR 0 2
15409: PUSH
15410: FOR_TO
15411: IFFALSE 15523
// if ( sk [ i ] [ 1 ] ) <> 0 then
15413: LD_VAR 0 6
15417: PUSH
15418: LD_VAR 0 4
15422: ARRAY
15423: PUSH
15424: LD_INT 1
15426: ARRAY
15427: PUSH
15428: LD_INT 0
15430: NONEQUAL
15431: IFFALSE 15521
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 1 ) ;
15433: LD_ADDR_EXP 55
15437: PUSH
15438: LD_EXP 55
15442: PPUSH
15443: LD_VAR 0 1
15447: PPUSH
15448: LD_VAR 0 6
15452: PUSH
15453: LD_VAR 0 4
15457: ARRAY
15458: PUSH
15459: LD_INT 1
15461: ARRAY
15462: PPUSH
15463: LD_INT 1
15465: PPUSH
15466: CALL 41882 0 4
15470: ST_TO_ADDR
// MREG_ToArm := Replace2 ( MREG_ToArm , side , MREG_ToArm [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15471: LD_ADDR_EXP 58
15475: PUSH
15476: LD_EXP 58
15480: PPUSH
15481: LD_VAR 0 1
15485: PPUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PUSH
15497: LD_INT 1
15499: PLUS
15500: PPUSH
15501: LD_VAR 0 6
15505: PUSH
15506: LD_VAR 0 4
15510: ARRAY
15511: PUSH
15512: LD_INT 1
15514: ARRAY
15515: PPUSH
15516: CALL 31052 0 4
15520: ST_TO_ADDR
// end ;
15521: GO 15410
15523: POP
15524: POP
// end ;
15525: LD_VAR 0 3
15529: RET
// export function MCH_TrainEngineer ( side , n ) ; var i , tmp , sk ; begin
15530: LD_INT 0
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
15536: LD_ADDR_VAR 0 5
15540: PUSH
15541: LD_VAR 0 1
15545: PPUSH
15546: LD_INT 2
15548: PUSH
15549: LD_INT 25
15551: PUSH
15552: LD_INT 1
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PUSH
15559: LD_INT 25
15561: PUSH
15562: LD_INT 3
15564: PUSH
15565: EMPTY
15566: LIST
15567: LIST
15568: PUSH
15569: LD_INT 25
15571: PUSH
15572: LD_INT 4
15574: PUSH
15575: EMPTY
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: PPUSH
15585: CALL 11587 0 2
15589: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15590: LD_ADDR_VAR 0 5
15594: PUSH
15595: LD_VAR 0 5
15599: PPUSH
15600: LD_INT 0
15602: PPUSH
15603: CALL 13736 0 2
15607: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 2 ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: LD_VAR 0 5
15622: PPUSH
15623: LD_INT 2
15625: PPUSH
15626: CALL 13356 0 3
15630: ST_TO_ADDR
// if n > sk then
15631: LD_VAR 0 2
15635: PUSH
15636: LD_VAR 0 6
15640: GREATER
15641: IFFALSE 15653
// n := sk ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_VAR 0 6
15652: ST_TO_ADDR
// for i = 1 to n do
15653: LD_ADDR_VAR 0 4
15657: PUSH
15658: DOUBLE
15659: LD_INT 1
15661: DEC
15662: ST_TO_ADDR
15663: LD_VAR 0 2
15667: PUSH
15668: FOR_TO
15669: IFFALSE 15781
// if ( sk [ i ] [ 1 ] ) <> 0 then
15671: LD_VAR 0 6
15675: PUSH
15676: LD_VAR 0 4
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_INT 0
15688: NONEQUAL
15689: IFFALSE 15779
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 2 ) ;
15691: LD_ADDR_EXP 55
15695: PUSH
15696: LD_EXP 55
15700: PPUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: LD_VAR 0 6
15710: PUSH
15711: LD_VAR 0 4
15715: ARRAY
15716: PUSH
15717: LD_INT 1
15719: ARRAY
15720: PPUSH
15721: LD_INT 2
15723: PPUSH
15724: CALL 41882 0 4
15728: ST_TO_ADDR
// MREG_ToDep := Replace2 ( MREG_ToDep , side , MREG_ToDep [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15729: LD_ADDR_EXP 59
15733: PUSH
15734: LD_EXP 59
15738: PPUSH
15739: LD_VAR 0 1
15743: PPUSH
15744: LD_EXP 59
15748: PUSH
15749: LD_VAR 0 1
15753: ARRAY
15754: PUSH
15755: LD_INT 1
15757: PLUS
15758: PPUSH
15759: LD_VAR 0 6
15763: PUSH
15764: LD_VAR 0 4
15768: ARRAY
15769: PUSH
15770: LD_INT 1
15772: ARRAY
15773: PPUSH
15774: CALL 31052 0 4
15778: ST_TO_ADDR
// end ;
15779: GO 15668
15781: POP
15782: POP
// end ;
15783: LD_VAR 0 3
15787: RET
// export function MCH_TrainMechanic ( side , n ) ; var i , tmp , sk ; begin
15788: LD_INT 0
15790: PPUSH
15791: PPUSH
15792: PPUSH
15793: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ) ;
15794: LD_ADDR_VAR 0 5
15798: PUSH
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 2
15806: PUSH
15807: LD_INT 25
15809: PUSH
15810: LD_INT 1
15812: PUSH
15813: EMPTY
15814: LIST
15815: LIST
15816: PUSH
15817: LD_INT 25
15819: PUSH
15820: LD_INT 2
15822: PUSH
15823: EMPTY
15824: LIST
15825: LIST
15826: PUSH
15827: LD_INT 25
15829: PUSH
15830: LD_INT 4
15832: PUSH
15833: EMPTY
15834: LIST
15835: LIST
15836: PUSH
15837: EMPTY
15838: LIST
15839: LIST
15840: LIST
15841: LIST
15842: PPUSH
15843: CALL 11587 0 2
15847: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
15848: LD_ADDR_VAR 0 5
15852: PUSH
15853: LD_VAR 0 5
15857: PPUSH
15858: LD_INT 0
15860: PPUSH
15861: CALL 13736 0 2
15865: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 3 ) ;
15866: LD_ADDR_VAR 0 6
15870: PUSH
15871: LD_VAR 0 1
15875: PPUSH
15876: LD_VAR 0 5
15880: PPUSH
15881: LD_INT 3
15883: PPUSH
15884: CALL 13356 0 3
15888: ST_TO_ADDR
// if n > sk then
15889: LD_VAR 0 2
15893: PUSH
15894: LD_VAR 0 6
15898: GREATER
15899: IFFALSE 15911
// n := sk ;
15901: LD_ADDR_VAR 0 2
15905: PUSH
15906: LD_VAR 0 6
15910: ST_TO_ADDR
// for i = 1 to n do
15911: LD_ADDR_VAR 0 4
15915: PUSH
15916: DOUBLE
15917: LD_INT 1
15919: DEC
15920: ST_TO_ADDR
15921: LD_VAR 0 2
15925: PUSH
15926: FOR_TO
15927: IFFALSE 16039
// if ( sk [ i ] [ 1 ] ) <> 0 then
15929: LD_VAR 0 6
15933: PUSH
15934: LD_VAR 0 4
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PUSH
15944: LD_INT 0
15946: NONEQUAL
15947: IFFALSE 16037
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 3 ) ;
15949: LD_ADDR_EXP 55
15953: PUSH
15954: LD_EXP 55
15958: PPUSH
15959: LD_VAR 0 1
15963: PPUSH
15964: LD_VAR 0 6
15968: PUSH
15969: LD_VAR 0 4
15973: ARRAY
15974: PUSH
15975: LD_INT 1
15977: ARRAY
15978: PPUSH
15979: LD_INT 3
15981: PPUSH
15982: CALL 41882 0 4
15986: ST_TO_ADDR
// MREG_ToFac := Replace2 ( MREG_ToFac , side , MREG_ToFac [ side ] + 1 , sk [ i ] [ 1 ] ) ;
15987: LD_ADDR_EXP 57
15991: PUSH
15992: LD_EXP 57
15996: PPUSH
15997: LD_VAR 0 1
16001: PPUSH
16002: LD_EXP 57
16006: PUSH
16007: LD_VAR 0 1
16011: ARRAY
16012: PUSH
16013: LD_INT 1
16015: PLUS
16016: PPUSH
16017: LD_VAR 0 6
16021: PUSH
16022: LD_VAR 0 4
16026: ARRAY
16027: PUSH
16028: LD_INT 1
16030: ARRAY
16031: PPUSH
16032: CALL 31052 0 4
16036: ST_TO_ADDR
// end ;
16037: GO 15926
16039: POP
16040: POP
// end ;
16041: LD_VAR 0 3
16045: RET
// export function MCH_TrainScientist ( side , n ) ; var i , tmp , sk ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
16050: PPUSH
16051: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] ] ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_VAR 0 1
16061: PPUSH
16062: LD_INT 2
16064: PUSH
16065: LD_INT 25
16067: PUSH
16068: LD_INT 1
16070: PUSH
16071: EMPTY
16072: LIST
16073: LIST
16074: PUSH
16075: LD_INT 25
16077: PUSH
16078: LD_INT 2
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: LIST
16089: PPUSH
16090: CALL 11587 0 2
16094: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16095: LD_ADDR_VAR 0 5
16099: PUSH
16100: LD_VAR 0 5
16104: PPUSH
16105: LD_INT 0
16107: PPUSH
16108: CALL 13736 0 2
16112: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 4 ) ;
16113: LD_ADDR_VAR 0 6
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 5
16127: PPUSH
16128: LD_INT 4
16130: PPUSH
16131: CALL 13356 0 3
16135: ST_TO_ADDR
// if n > sk then
16136: LD_VAR 0 2
16140: PUSH
16141: LD_VAR 0 6
16145: GREATER
16146: IFFALSE 16158
// n := sk ;
16148: LD_ADDR_VAR 0 2
16152: PUSH
16153: LD_VAR 0 6
16157: ST_TO_ADDR
// for i = 1 to n do
16158: LD_ADDR_VAR 0 4
16162: PUSH
16163: DOUBLE
16164: LD_INT 1
16166: DEC
16167: ST_TO_ADDR
16168: LD_VAR 0 2
16172: PUSH
16173: FOR_TO
16174: IFFALSE 16286
// if ( sk [ i ] [ 1 ] ) <> 0 then
16176: LD_VAR 0 6
16180: PUSH
16181: LD_VAR 0 4
16185: ARRAY
16186: PUSH
16187: LD_INT 1
16189: ARRAY
16190: PUSH
16191: LD_INT 0
16193: NONEQUAL
16194: IFFALSE 16284
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , 4 ) ;
16196: LD_ADDR_EXP 55
16200: PUSH
16201: LD_EXP 55
16205: PPUSH
16206: LD_VAR 0 1
16210: PPUSH
16211: LD_VAR 0 6
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: LD_INT 4
16228: PPUSH
16229: CALL 41882 0 4
16233: ST_TO_ADDR
// MREG_ToLab := Replace2 ( MREG_ToLab , side , MREG_ToLab [ side ] + 1 , sk [ i ] [ 1 ] ) ;
16234: LD_ADDR_EXP 56
16238: PUSH
16239: LD_EXP 56
16243: PPUSH
16244: LD_VAR 0 1
16248: PPUSH
16249: LD_EXP 56
16253: PUSH
16254: LD_VAR 0 1
16258: ARRAY
16259: PUSH
16260: LD_INT 1
16262: PLUS
16263: PPUSH
16264: LD_VAR 0 6
16268: PUSH
16269: LD_VAR 0 4
16273: ARRAY
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL 31052 0 4
16283: ST_TO_ADDR
// end ;
16284: GO 16173
16286: POP
16287: POP
// end ;
16288: LD_VAR 0 3
16292: RET
// export function MCH_TrainSpec ( side , n , spec_class ) ; var i , tmp , sk ; begin
16293: LD_INT 0
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
// tmp := MCF_Get ( side , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
16299: LD_ADDR_VAR 0 6
16303: PUSH
16304: LD_VAR 0 1
16308: PPUSH
16309: LD_INT 2
16311: PUSH
16312: LD_INT 25
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PUSH
16322: LD_INT 25
16324: PUSH
16325: LD_INT 2
16327: PUSH
16328: EMPTY
16329: LIST
16330: LIST
16331: PUSH
16332: LD_INT 25
16334: PUSH
16335: LD_INT 3
16337: PUSH
16338: EMPTY
16339: LIST
16340: LIST
16341: PUSH
16342: LD_INT 25
16344: PUSH
16345: LD_INT 4
16347: PUSH
16348: EMPTY
16349: LIST
16350: LIST
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: PPUSH
16359: CALL 11587 0 2
16363: ST_TO_ADDR
// tmp := MCF_NoClass ( tmp , 0 ) ;
16364: LD_ADDR_VAR 0 6
16368: PUSH
16369: LD_VAR 0 6
16373: PPUSH
16374: LD_INT 0
16376: PPUSH
16377: CALL 13736 0 2
16381: ST_TO_ADDR
// sk := MCF_SortLevelDesc ( side , tmp , 1 ) ;
16382: LD_ADDR_VAR 0 7
16386: PUSH
16387: LD_VAR 0 1
16391: PPUSH
16392: LD_VAR 0 6
16396: PPUSH
16397: LD_INT 1
16399: PPUSH
16400: CALL 13356 0 3
16404: ST_TO_ADDR
// if n > sk then
16405: LD_VAR 0 2
16409: PUSH
16410: LD_VAR 0 7
16414: GREATER
16415: IFFALSE 16427
// n := sk ;
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: LD_VAR 0 7
16426: ST_TO_ADDR
// for i = 1 to n do
16427: LD_ADDR_VAR 0 5
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16487
// begin MREG_ToChangeClass := MC_RegistryUpdate ( MREG_ToChangeClass , side , sk [ i ] [ 1 ] , spec_class ) ;
16445: LD_ADDR_EXP 55
16449: PUSH
16450: LD_EXP 55
16454: PPUSH
16455: LD_VAR 0 1
16459: PPUSH
16460: LD_VAR 0 7
16464: PUSH
16465: LD_VAR 0 5
16469: ARRAY
16470: PUSH
16471: LD_INT 1
16473: ARRAY
16474: PPUSH
16475: LD_VAR 0 3
16479: PPUSH
16480: CALL 41882 0 4
16484: ST_TO_ADDR
// end ;
16485: GO 16442
16487: POP
16488: POP
// end ;
16489: LD_VAR 0 4
16493: RET
// export function MCH_ChangeClass ( side , unit , class ) ; var i , b ; begin
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// b := false ;
16499: LD_ADDR_VAR 0 6
16503: PUSH
16504: LD_INT 0
16506: ST_TO_ADDR
// if class in [ class_soldier , class_bazooker , class_sniper , class_mortar ] then
16507: LD_VAR 0 3
16511: PUSH
16512: LD_INT 1
16514: PUSH
16515: LD_INT 9
16517: PUSH
16518: LD_INT 5
16520: PUSH
16521: LD_INT 8
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: LIST
16528: LIST
16529: IN
16530: IFFALSE 16618
// if MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
16532: LD_VAR 0 1
16536: PPUSH
16537: LD_INT 2
16539: PUSH
16540: LD_INT 30
16542: PUSH
16543: LD_INT 4
16545: PUSH
16546: EMPTY
16547: LIST
16548: LIST
16549: PUSH
16550: LD_INT 30
16552: PUSH
16553: LD_INT 5
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: LIST
16564: PPUSH
16565: CALL 11587 0 2
16569: IFFALSE 16618
// b := MCF_Get ( side , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) [ 1 ] ;
16571: LD_ADDR_VAR 0 6
16575: PUSH
16576: LD_VAR 0 1
16580: PPUSH
16581: LD_INT 2
16583: PUSH
16584: LD_INT 30
16586: PUSH
16587: LD_INT 4
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 5
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: LIST
16608: PPUSH
16609: CALL 11587 0 2
16613: PUSH
16614: LD_INT 1
16616: ARRAY
16617: ST_TO_ADDR
// if class = class_engineer then
16618: LD_VAR 0 3
16622: PUSH
16623: LD_INT 2
16625: EQUAL
16626: IFFALSE 16714
// if MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
16628: LD_VAR 0 1
16632: PPUSH
16633: LD_INT 2
16635: PUSH
16636: LD_INT 30
16638: PUSH
16639: LD_INT 0
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: PUSH
16646: LD_INT 30
16648: PUSH
16649: LD_INT 1
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PPUSH
16661: CALL 11587 0 2
16665: IFFALSE 16714
// b := MCF_Get ( side , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ;
16667: LD_ADDR_VAR 0 6
16671: PUSH
16672: LD_VAR 0 1
16676: PPUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 30
16682: PUSH
16683: LD_INT 0
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: LD_INT 30
16692: PUSH
16693: LD_INT 1
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PPUSH
16705: CALL 11587 0 2
16709: PUSH
16710: LD_INT 1
16712: ARRAY
16713: ST_TO_ADDR
// if class = class_mechanic then
16714: LD_VAR 0 3
16718: PUSH
16719: LD_INT 3
16721: EQUAL
16722: IFFALSE 16792
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
16724: LD_VAR 0 1
16728: PPUSH
16729: LD_INT 30
16731: PUSH
16732: LD_INT 3
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: PPUSH
16739: CALL 11587 0 2
16743: IFFALSE 16792
// b := MCF_Get ( side , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
16745: LD_ADDR_VAR 0 6
16749: PUSH
16750: LD_VAR 0 1
16754: PPUSH
16755: LD_INT 2
16757: PUSH
16758: LD_INT 30
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PUSH
16768: LD_INT 30
16770: PUSH
16771: LD_INT 3
16773: PUSH
16774: EMPTY
16775: LIST
16776: LIST
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: PPUSH
16783: CALL 11587 0 2
16787: PUSH
16788: LD_INT 1
16790: ARRAY
16791: ST_TO_ADDR
// if class = class_scientistic then
16792: LD_VAR 0 3
16796: PUSH
16797: LD_INT 4
16799: EQUAL
16800: IFFALSE 16910
// if MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) then
16802: LD_VAR 0 1
16806: PPUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 30
16812: PUSH
16813: LD_INT 6
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 30
16822: PUSH
16823: LD_INT 7
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 30
16832: PUSH
16833: LD_INT 8
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL 11587 0 2
16850: IFFALSE 16910
// b := MCF_Get ( side , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ;
16852: LD_ADDR_VAR 0 6
16856: PUSH
16857: LD_VAR 0 1
16861: PPUSH
16862: LD_INT 2
16864: PUSH
16865: LD_INT 30
16867: PUSH
16868: LD_INT 6
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 30
16877: PUSH
16878: LD_INT 7
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: PUSH
16885: LD_INT 30
16887: PUSH
16888: LD_INT 8
16890: PUSH
16891: EMPTY
16892: LIST
16893: LIST
16894: PUSH
16895: EMPTY
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: PPUSH
16901: CALL 11587 0 2
16905: PUSH
16906: LD_INT 1
16908: ARRAY
16909: ST_TO_ADDR
// if GetClass ( unit ) = class then
16910: LD_VAR 0 2
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_VAR 0 3
16924: EQUAL
16925: IFFALSE 16959
// begin MREG_ToChangeClass := MC_RegistryDelete ( MREG_ToChangeClass , side , unit , class ) ;
16927: LD_ADDR_EXP 55
16931: PUSH
16932: LD_EXP 55
16936: PPUSH
16937: LD_VAR 0 1
16941: PPUSH
16942: LD_VAR 0 2
16946: PPUSH
16947: LD_VAR 0 3
16951: PPUSH
16952: CALL 41973 0 4
16956: ST_TO_ADDR
// end else
16957: GO 17052
// if b then
16959: LD_VAR 0 6
16963: IFFALSE 17044
// begin if IsInUnit ( unit ) and IsInUnit ( unit ) <> b then
16965: LD_VAR 0 2
16969: PPUSH
16970: CALL_OW 310
16974: PUSH
16975: LD_VAR 0 2
16979: PPUSH
16980: CALL_OW 310
16984: PUSH
16985: LD_VAR 0 6
16989: NONEQUAL
16990: AND
16991: IFFALSE 17002
// ComExitBuilding ( unit ) ;
16993: LD_VAR 0 2
16997: PPUSH
16998: CALL_OW 122
// if not IsInUnit ( unit ) then
17002: LD_VAR 0 2
17006: PPUSH
17007: CALL_OW 310
17011: NOT
17012: IFFALSE 17028
// ComEnterUnit ( unit , b ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 120
// AddComChangeProfession ( unit , class ) ;
17028: LD_VAR 0 2
17032: PPUSH
17033: LD_VAR 0 3
17037: PPUSH
17038: CALL_OW 183
// end else
17042: GO 17052
// result := false ;
17044: LD_ADDR_VAR 0 4
17048: PUSH
17049: LD_INT 0
17051: ST_TO_ADDR
// end ; end_of_file
17052: LD_VAR 0 4
17056: RET
// export function MCL_Research ( side , tech ) ; var i , basic_tech , lab ; begin
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
17061: PPUSH
17062: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17063: LD_ADDR_VAR 0 5
17067: PUSH
17068: LD_INT 35
17070: PUSH
17071: LD_INT 45
17073: PUSH
17074: LD_INT 46
17076: PUSH
17077: LD_INT 47
17079: PUSH
17080: LD_INT 1
17082: PUSH
17083: LD_INT 2
17085: PUSH
17086: LD_INT 48
17088: PUSH
17089: LD_INT 49
17091: PUSH
17092: LD_INT 50
17094: PUSH
17095: LD_INT 20
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: LIST
17102: LIST
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: LIST
17109: ST_TO_ADDR
// if MCF_Lab ( side ) then
17110: LD_VAR 0 1
17114: PPUSH
17115: CALL 11626 0 1
17119: IFFALSE 17358
// begin if BuildingStatus ( MCF_Lab ( side ) [ 1 ] ) = bs_idle then
17121: LD_VAR 0 1
17125: PPUSH
17126: CALL 11626 0 1
17130: PUSH
17131: LD_INT 1
17133: ARRAY
17134: PPUSH
17135: CALL_OW 461
17139: PUSH
17140: LD_INT 2
17142: EQUAL
17143: IFFALSE 17282
// begin if MCL_LabReq ( MCF_Lab ( side ) [ 1 ] , tech ) then
17145: LD_VAR 0 1
17149: PPUSH
17150: CALL 11626 0 1
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL 17454 0 2
17168: IFFALSE 17195
// ComResearch ( MCF_Lab ( side ) [ 1 ] , tech ) else
17170: LD_VAR 0 1
17174: PPUSH
17175: CALL 11626 0 1
17179: PUSH
17180: LD_INT 1
17182: ARRAY
17183: PPUSH
17184: LD_VAR 0 2
17188: PPUSH
17189: CALL_OW 124
17193: GO 17282
// if MCF_Lab ( side ) > 1 then
17195: LD_VAR 0 1
17199: PPUSH
17200: CALL 11626 0 1
17204: PUSH
17205: LD_INT 1
17207: GREATER
17208: IFFALSE 17282
// if BuildingStatus ( MCF_Lab ( side ) [ 2 ] ) = bs_idle then
17210: LD_VAR 0 1
17214: PPUSH
17215: CALL 11626 0 1
17219: PUSH
17220: LD_INT 2
17222: ARRAY
17223: PPUSH
17224: CALL_OW 461
17228: PUSH
17229: LD_INT 2
17231: EQUAL
17232: IFFALSE 17282
// if MCL_LabReq ( MCF_Lab ( side ) [ 2 ] , tech ) then
17234: LD_VAR 0 1
17238: PPUSH
17239: CALL 11626 0 1
17243: PUSH
17244: LD_INT 2
17246: ARRAY
17247: PPUSH
17248: LD_VAR 0 2
17252: PPUSH
17253: CALL 17454 0 2
17257: IFFALSE 17282
// ComResearch ( MCF_Lab ( side ) [ 2 ] , tech ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 11626 0 1
17268: PUSH
17269: LD_INT 2
17271: ARRAY
17272: PPUSH
17273: LD_VAR 0 2
17277: PPUSH
17278: CALL_OW 124
// end ; if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
17282: LD_VAR 0 2
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: LD_INT 11
17292: PUSH
17293: LD_INT 4
17295: PUSH
17296: LD_INT 3
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: IN
17305: IFFALSE 17358
// begin for lab in MCF_Lab ( side ) do
17307: LD_ADDR_VAR 0 6
17311: PUSH
17312: LD_VAR 0 1
17316: PPUSH
17317: CALL 11626 0 1
17321: PUSH
17322: FOR_IN
17323: IFFALSE 17356
// if BuildingStatus ( lab ) = bs_need_ape then
17325: LD_VAR 0 6
17329: PPUSH
17330: CALL_OW 461
17334: PUSH
17335: LD_INT 10
17337: EQUAL
17338: IFFALSE 17354
// MCL_ResTame ( side , lab ) ;
17340: LD_VAR 0 1
17344: PPUSH
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL 17579 0 2
17354: GO 17322
17356: POP
17357: POP
// end ; end ; end ;
17358: LD_VAR 0 3
17362: RET
// export function MCL_Kind ( lab ) ; var tmp ; begin
17363: LD_INT 0
17365: PPUSH
17366: PPUSH
// tmp := [ ] ;
17367: LD_ADDR_VAR 0 3
17371: PUSH
17372: EMPTY
17373: ST_TO_ADDR
// if not lab then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17391
// result := false else
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: LD_INT 0
17388: ST_TO_ADDR
17389: GO 17449
// begin tmp := tmp ^ GetLabKind ( lab , 1 ) ;
17391: LD_ADDR_VAR 0 3
17395: PUSH
17396: LD_VAR 0 3
17400: PUSH
17401: LD_VAR 0 1
17405: PPUSH
17406: LD_INT 1
17408: PPUSH
17409: CALL_OW 268
17413: ADD
17414: ST_TO_ADDR
// tmp := tmp ^ GetLabKind ( lab , 2 ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 3
17424: PUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: LD_INT 2
17432: PPUSH
17433: CALL_OW 268
17437: ADD
17438: ST_TO_ADDR
// result := tmp ;
17439: LD_ADDR_VAR 0 2
17443: PUSH
17444: LD_VAR 0 3
17448: ST_TO_ADDR
// end ; end ;
17449: LD_VAR 0 2
17453: RET
// export function MCL_LabReq ( lab , tech ) ; var i , basic_tech ; begin
17454: LD_INT 0
17456: PPUSH
17457: PPUSH
17458: PPUSH
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 35
17466: PUSH
17467: LD_INT 45
17469: PUSH
17470: LD_INT 46
17472: PUSH
17473: LD_INT 47
17475: PUSH
17476: LD_INT 1
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: LD_INT 48
17484: PUSH
17485: LD_INT 49
17487: PUSH
17488: LD_INT 50
17490: PUSH
17491: LD_INT 20
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: ST_TO_ADDR
// if lab then
17506: LD_VAR 0 1
17510: IFFALSE 17566
// begin if ( tech in basic_tech ) or ( GetTechLab ( tech ) in MCL_Kind ( lab ) ) then
17512: LD_VAR 0 2
17516: PUSH
17517: LD_VAR 0 5
17521: IN
17522: PUSH
17523: LD_VAR 0 2
17527: PPUSH
17528: CALL_OW 481
17532: PUSH
17533: LD_VAR 0 1
17537: PPUSH
17538: CALL 17363 0 1
17542: IN
17543: OR
17544: IFFALSE 17556
// result := true else
17546: LD_ADDR_VAR 0 3
17550: PUSH
17551: LD_INT 1
17553: ST_TO_ADDR
17554: GO 17564
// result := false ;
17556: LD_ADDR_VAR 0 3
17560: PUSH
17561: LD_INT 0
17563: ST_TO_ADDR
// end else
17564: GO 17574
// result := false ;
17566: LD_ADDR_VAR 0 3
17570: PUSH
17571: LD_INT 0
17573: ST_TO_ADDR
// end ;
17574: LD_VAR 0 3
17578: RET
// export function MCL_ResTame ( side , lab ) ; var ape , tmp ; begin
17579: LD_INT 0
17581: PPUSH
17582: PPUSH
17583: PPUSH
// ape := MCF_Tag ( side , 171 , [ ] ) ;
17584: LD_ADDR_VAR 0 4
17588: PUSH
17589: LD_VAR 0 1
17593: PPUSH
17594: LD_INT 171
17596: PPUSH
17597: EMPTY
17598: PPUSH
17599: CALL 12290 0 3
17603: ST_TO_ADDR
// if not ape then
17604: LD_VAR 0 4
17608: NOT
17609: IFFALSE 17641
// if MCF_Ape ( side ) then
17611: LD_VAR 0 1
17615: PPUSH
17616: CALL 12000 0 1
17620: IFFALSE 17641
// ape := MCF_Ape ( side ) [ 1 ] ;
17622: LD_ADDR_VAR 0 4
17626: PUSH
17627: LD_VAR 0 1
17631: PPUSH
17632: CALL 12000 0 1
17636: PUSH
17637: LD_INT 1
17639: ARRAY
17640: ST_TO_ADDR
// if ape then
17641: LD_VAR 0 4
17645: IFFALSE 17696
// if IsInUnit ( ape [ 1 ] ) and IsInUnit ( ape [ 1 ] ) <> lab then
17647: LD_VAR 0 4
17651: PUSH
17652: LD_INT 1
17654: ARRAY
17655: PPUSH
17656: CALL_OW 310
17660: PUSH
17661: LD_VAR 0 4
17665: PUSH
17666: LD_INT 1
17668: ARRAY
17669: PPUSH
17670: CALL_OW 310
17674: PUSH
17675: LD_VAR 0 2
17679: NONEQUAL
17680: AND
17681: IFFALSE 17696
// ComExitBuilding ( ape [ 1 ] ) ;
17683: LD_VAR 0 4
17687: PUSH
17688: LD_INT 1
17690: ARRAY
17691: PPUSH
17692: CALL_OW 122
// if not lab then
17696: LD_VAR 0 2
17700: NOT
17701: IFFALSE 17707
// exit else
17703: GO 17855
17705: GO 17815
// if MCF_Tag ( side , 16 , [ f_class , 4 ] ) = 0 and UnitsInside ( lab ) = 6 then
17707: LD_VAR 0 1
17711: PPUSH
17712: LD_INT 16
17714: PPUSH
17715: LD_INT 25
17717: PUSH
17718: LD_INT 4
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: PPUSH
17725: CALL 12290 0 3
17729: PUSH
17730: LD_INT 0
17732: EQUAL
17733: PUSH
17734: LD_VAR 0 2
17738: PPUSH
17739: CALL_OW 313
17743: PUSH
17744: LD_INT 6
17746: EQUAL
17747: AND
17748: IFFALSE 17815
// begin tmp := UnitsInside ( lab ) ;
17750: LD_ADDR_VAR 0 5
17754: PUSH
17755: LD_VAR 0 2
17759: PPUSH
17760: CALL_OW 313
17764: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 16 ) ;
17765: LD_VAR 0 5
17769: PUSH
17770: LD_VAR 0 5
17774: ARRAY
17775: PPUSH
17776: LD_INT 16
17778: PPUSH
17779: CALL_OW 109
// if IsInUnit ( tmp [ tmp ] ) then
17783: LD_VAR 0 5
17787: PUSH
17788: LD_VAR 0 5
17792: ARRAY
17793: PPUSH
17794: CALL_OW 310
17798: IFFALSE 17815
// ComExitBuilding ( tmp [ tmp ] ) ;
17800: LD_VAR 0 5
17804: PUSH
17805: LD_VAR 0 5
17809: ARRAY
17810: PPUSH
17811: CALL_OW 122
// end ; if ape then
17815: LD_VAR 0 4
17819: IFFALSE 17855
// if not IsInUnit ( ape [ 1 ] ) then
17821: LD_VAR 0 4
17825: PUSH
17826: LD_INT 1
17828: ARRAY
17829: PPUSH
17830: CALL_OW 310
17834: NOT
17835: IFFALSE 17855
// ComEnterUnit ( ape [ 1 ] , lab ) ;
17837: LD_VAR 0 4
17841: PUSH
17842: LD_INT 1
17844: ARRAY
17845: PPUSH
17846: LD_VAR 0 2
17850: PPUSH
17851: CALL_OW 120
// end ;
17855: LD_VAR 0 3
17859: RET
// export function MCL_HasNext ( side ) ; var techs , t ; begin
17860: LD_INT 0
17862: PPUSH
17863: PPUSH
17864: PPUSH
// result := false ;
17865: LD_ADDR_VAR 0 2
17869: PUSH
17870: LD_INT 0
17872: ST_TO_ADDR
// techs := MCL_GetTechList ( side ) ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 1
17882: PPUSH
17883: CALL 17970 0 1
17887: ST_TO_ADDR
// if techs then
17888: LD_VAR 0 3
17892: IFFALSE 17922
// if techs [ 2 ] then
17894: LD_VAR 0 3
17898: PUSH
17899: LD_INT 2
17901: ARRAY
17902: IFFALSE 17914
// result := true else
17904: LD_ADDR_VAR 0 2
17908: PUSH
17909: LD_INT 1
17911: ST_TO_ADDR
17912: GO 17922
// result := false ;
17914: LD_ADDR_VAR 0 2
17918: PUSH
17919: LD_INT 0
17921: ST_TO_ADDR
// end ;
17922: LD_VAR 0 2
17926: RET
// export function MCL_Start ( side ) ; var i ; begin
17927: LD_INT 0
17929: PPUSH
17930: PPUSH
// if MCL_GetTechList ( side ) then
17931: LD_VAR 0 1
17935: PPUSH
17936: CALL 17970 0 1
17940: IFFALSE 17965
// MCL_Research ( side , MCL_GetTechList ( side ) [ 1 ] ) ;
17942: LD_VAR 0 1
17946: PPUSH
17947: LD_VAR 0 1
17951: PPUSH
17952: CALL 17970 0 1
17956: PUSH
17957: LD_INT 1
17959: ARRAY
17960: PPUSH
17961: CALL 17057 0 2
// end ;
17965: LD_VAR 0 2
17969: RET
// export function MCL_GetTechList ( side ) ; var i , techs ; begin
17970: LD_INT 0
17972: PPUSH
17973: PPUSH
17974: PPUSH
// if MREG_ToRes then
17975: LD_EXP 52
17979: IFFALSE 18064
// for i = 1 to MREG_ToRes do
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: DOUBLE
17987: LD_INT 1
17989: DEC
17990: ST_TO_ADDR
17991: LD_EXP 52
17995: PUSH
17996: FOR_TO
17997: IFFALSE 18062
// if MREG_ToRes [ i ] [ 1 ] = side then
17999: LD_EXP 52
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PUSH
18010: LD_INT 1
18012: ARRAY
18013: PUSH
18014: LD_VAR 0 1
18018: EQUAL
18019: IFFALSE 18060
// begin techs := Replace ( techs , techs + 1 , MREG_ToRes [ i ] [ 2 ] ) ;
18021: LD_ADDR_VAR 0 4
18025: PUSH
18026: LD_VAR 0 4
18030: PPUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_INT 1
18038: PLUS
18039: PPUSH
18040: LD_EXP 52
18044: PUSH
18045: LD_VAR 0 3
18049: ARRAY
18050: PUSH
18051: LD_INT 2
18053: ARRAY
18054: PPUSH
18055: CALL_OW 1
18059: ST_TO_ADDR
// end ;
18060: GO 17996
18062: POP
18063: POP
// result := techs ;
18064: LD_ADDR_VAR 0 2
18068: PUSH
18069: LD_VAR 0 4
18073: ST_TO_ADDR
// end ;
18074: LD_VAR 0 2
18078: RET
// export function MCL_SetTechList ( side , tech_list ) ; var i ; begin
18079: LD_INT 0
18081: PPUSH
18082: PPUSH
// for i = 1 to tech_list do
18083: LD_ADDR_VAR 0 4
18087: PUSH
18088: DOUBLE
18089: LD_INT 1
18091: DEC
18092: ST_TO_ADDR
18093: LD_VAR 0 2
18097: PUSH
18098: FOR_TO
18099: IFFALSE 18153
// if not tech_list [ i ] = 20 then
18101: LD_VAR 0 2
18105: PUSH
18106: LD_VAR 0 4
18110: ARRAY
18111: PUSH
18112: LD_INT 20
18114: EQUAL
18115: NOT
18116: IFFALSE 18151
// MREG_ToRes := MC_RegistryUpdate ( MREG_ToRes , side , tech_list [ i ] , [ ] ) ;
18118: LD_ADDR_EXP 52
18122: PUSH
18123: LD_EXP 52
18127: PPUSH
18128: LD_VAR 0 1
18132: PPUSH
18133: LD_VAR 0 2
18137: PUSH
18138: LD_VAR 0 4
18142: ARRAY
18143: PPUSH
18144: EMPTY
18145: PPUSH
18146: CALL 41882 0 4
18150: ST_TO_ADDR
18151: GO 18098
18153: POP
18154: POP
// result := true ;
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: ST_TO_ADDR
// end ;
18163: LD_VAR 0 3
18167: RET
// export function MCL_ClearTechList ( side ) ; var i ; begin
18168: LD_INT 0
18170: PPUSH
18171: PPUSH
// for i = MREG_ToRes downto 1 do
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: DOUBLE
18178: LD_EXP 52
18182: INC
18183: ST_TO_ADDR
18184: LD_INT 1
18186: PUSH
18187: FOR_DOWNTO
18188: IFFALSE 18234
// if MREG_ToRes [ i ] [ 1 ] = side then
18190: LD_EXP 52
18194: PUSH
18195: LD_VAR 0 3
18199: ARRAY
18200: PUSH
18201: LD_INT 1
18203: ARRAY
18204: PUSH
18205: LD_VAR 0 1
18209: EQUAL
18210: IFFALSE 18232
// MREG_ToRes := Delete ( MREG_ToRes , i ) ;
18212: LD_ADDR_EXP 52
18216: PUSH
18217: LD_EXP 52
18221: PPUSH
18222: LD_VAR 0 3
18226: PPUSH
18227: CALL_OW 3
18231: ST_TO_ADDR
18232: GO 18187
18234: POP
18235: POP
// result := true ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 1
18243: ST_TO_ADDR
// end ;
18244: LD_VAR 0 2
18248: RET
// export function MCL_CheckTechProgress ( side , tech ) ; begin
18249: LD_INT 0
18251: PPUSH
// result := GetTechProgress ( side , tech ) ;
18252: LD_ADDR_VAR 0 3
18256: PUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: LD_VAR 0 2
18266: PPUSH
18267: CALL_OW 326
18271: ST_TO_ADDR
// end ;
18272: LD_VAR 0 3
18276: RET
// export function MCL_Require ( tech ) ; begin
18277: LD_INT 0
18279: PPUSH
// result := GetTechTechsReq ( tech ) ;
18280: LD_ADDR_VAR 0 2
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 480
18294: ST_TO_ADDR
// end ; end_of_file
18295: LD_VAR 0 2
18299: RET
// export function MCN_AddApes ( area , n , agr ) ; var i , ape ; begin
18300: LD_INT 0
18302: PPUSH
18303: PPUSH
18304: PPUSH
// uc_side := 0 ;
18305: LD_ADDR_OWVAR 20
18309: PUSH
18310: LD_INT 0
18312: ST_TO_ADDR
// uc_nation := 0 ;
18313: LD_ADDR_OWVAR 21
18317: PUSH
18318: LD_INT 0
18320: ST_TO_ADDR
// for i = 1 to n do
18321: LD_ADDR_VAR 0 5
18325: PUSH
18326: DOUBLE
18327: LD_INT 1
18329: DEC
18330: ST_TO_ADDR
18331: LD_VAR 0 2
18335: PUSH
18336: FOR_TO
18337: IFFALSE 18482
// begin hc_importance := 0 ;
18339: LD_ADDR_OWVAR 32
18343: PUSH
18344: LD_INT 0
18346: ST_TO_ADDR
// hc_gallery :=  ;
18347: LD_ADDR_OWVAR 33
18351: PUSH
18352: LD_STRING 
18354: ST_TO_ADDR
// hc_agressivity = Rand ( agr - 20 , agr + 20 ) ;
18355: LD_ADDR_OWVAR 35
18359: PUSH
18360: LD_VAR 0 3
18364: PUSH
18365: LD_INT 20
18367: MINUS
18368: PPUSH
18369: LD_VAR 0 3
18373: PUSH
18374: LD_INT 20
18376: PLUS
18377: PPUSH
18378: CALL_OW 12
18382: ST_TO_ADDR
// hc_skills := [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
18383: LD_ADDR_OWVAR 31
18387: PUSH
18388: LD_INT 0
18390: PPUSH
18391: LD_INT 2
18393: PPUSH
18394: CALL_OW 12
18398: PUSH
18399: LD_INT 0
18401: PUSH
18402: LD_INT 0
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: LIST
18412: LIST
18413: ST_TO_ADDR
// hc_basic_skills := [ 0 , 0 , 0 , 0 ] ;
18414: LD_ADDR_OWVAR 30
18418: PUSH
18419: LD_INT 0
18421: PUSH
18422: LD_INT 0
18424: PUSH
18425: LD_INT 0
18427: PUSH
18428: LD_INT 0
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: LIST
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// hc_class := class_apeman ;
18445: LD_ADDR_OWVAR 28
18449: PUSH
18450: LD_INT 12
18452: ST_TO_ADDR
// ape := CreateHuman ;
18453: LD_ADDR_VAR 0 6
18457: PUSH
18458: CALL_OW 44
18462: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
18463: LD_VAR 0 6
18467: PPUSH
18468: LD_VAR 0 1
18472: PPUSH
18473: LD_INT 0
18475: PPUSH
18476: CALL_OW 49
// end ;
18480: GO 18336
18482: POP
18483: POP
// end ;
18484: LD_VAR 0 4
18488: RET
// export function MCN_Tame ( side , unit ) ; var ape ; begin
18489: LD_INT 0
18491: PPUSH
18492: PPUSH
// if MCF_Ape ( side ) >= MREG_Tame [ side ] then
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL 12000 0 1
18502: PUSH
18503: LD_EXP 39
18507: PUSH
18508: LD_VAR 0 1
18512: ARRAY
18513: GREATEREQUAL
18514: IFFALSE 18691
// begin if GetTag ( unit ) = 17 then
18516: LD_VAR 0 2
18520: PPUSH
18521: CALL_OW 110
18525: PUSH
18526: LD_INT 17
18528: EQUAL
18529: IFFALSE 18689
// begin SetTag ( unit , 0 ) ;
18531: LD_VAR 0 2
18535: PPUSH
18536: LD_INT 0
18538: PPUSH
18539: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
18543: LD_VAR 0 1
18547: PPUSH
18548: CALL 11626 0 1
18552: PUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL 17970 0 1
18562: NOT
18563: AND
18564: IFFALSE 18589
// ComEnterUnit ( unit , MCF_Lab ( side ) [ 1 ] ) ;
18566: LD_VAR 0 2
18570: PPUSH
18571: LD_VAR 0 1
18575: PPUSH
18576: CALL 11626 0 1
18580: PUSH
18581: LD_INT 1
18583: ARRAY
18584: PPUSH
18585: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18589: LD_VAR 0 1
18593: PPUSH
18594: CALL 11626 0 1
18598: NOT
18599: PUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: LD_INT 30
18607: PUSH
18608: LD_INT 1
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PPUSH
18615: CALL 11587 0 2
18619: AND
18620: IFFALSE 18689
// ComMoveXY ( unit , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
18622: LD_VAR 0 2
18626: PPUSH
18627: LD_VAR 0 1
18631: PPUSH
18632: LD_INT 30
18634: PUSH
18635: LD_INT 1
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PPUSH
18642: CALL 11587 0 2
18646: PUSH
18647: LD_INT 1
18649: ARRAY
18650: PPUSH
18651: CALL_OW 250
18655: PPUSH
18656: LD_VAR 0 1
18660: PPUSH
18661: LD_INT 30
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PPUSH
18671: CALL 11587 0 2
18675: PUSH
18676: LD_INT 1
18678: ARRAY
18679: PPUSH
18680: CALL_OW 251
18684: PPUSH
18685: CALL_OW 111
// end ; end else
18689: GO 18875
// if GetClass ( unit ) <> 4 then
18691: LD_VAR 0 2
18695: PPUSH
18696: CALL_OW 257
18700: PUSH
18701: LD_INT 4
18703: NONEQUAL
18704: IFFALSE 18710
// exit else
18706: GO 18875
18708: GO 18875
// if GetTag ( unit ) = 0 then
18710: LD_VAR 0 2
18714: PPUSH
18715: CALL_OW 110
18719: PUSH
18720: LD_INT 0
18722: EQUAL
18723: IFFALSE 18739
// SetTag ( unit , 17 ) else
18725: LD_VAR 0 2
18729: PPUSH
18730: LD_INT 17
18732: PPUSH
18733: CALL_OW 109
18737: GO 18875
// begin if IsInUnit ( unit ) then
18739: LD_VAR 0 2
18743: PPUSH
18744: CALL_OW 310
18748: IFFALSE 18759
// ComExitBuilding ( unit ) ;
18750: LD_VAR 0 2
18754: PPUSH
18755: CALL_OW 122
// Wait ( 1 ) ;
18759: LD_INT 1
18761: PPUSH
18762: CALL_OW 67
// ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , unit ) ;
18766: LD_ADDR_VAR 0 4
18770: PUSH
18771: LD_INT 22
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 25
18783: PUSH
18784: LD_INT 12
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: PPUSH
18795: CALL_OW 69
18799: PPUSH
18800: LD_VAR 0 2
18804: PPUSH
18805: CALL_OW 74
18809: ST_TO_ADDR
// if not ape then
18810: LD_VAR 0 4
18814: NOT
18815: IFFALSE 18821
// exit else
18817: GO 18875
18819: GO 18830
// ComHold ( ape ) ;
18821: LD_VAR 0 4
18825: PPUSH
18826: CALL_OW 140
// if not HasTask ( unit ) then
18830: LD_VAR 0 2
18834: PPUSH
18835: CALL_OW 314
18839: NOT
18840: IFFALSE 18873
// ComTameXY ( unit , GetX ( ape ) , GetY ( ape ) ) else
18842: LD_VAR 0 2
18846: PPUSH
18847: LD_VAR 0 4
18851: PPUSH
18852: CALL_OW 250
18856: PPUSH
18857: LD_VAR 0 4
18861: PPUSH
18862: CALL_OW 251
18866: PPUSH
18867: CALL_OW 131
18871: GO 18875
// exit ;
18873: GO 18875
// end ; end ;
18875: LD_VAR 0 3
18879: RET
// export function MCN_TrainApe ( side ) ; var i , tmp , apes ; begin
18880: LD_INT 0
18882: PPUSH
18883: PPUSH
18884: PPUSH
18885: PPUSH
// tmp := MREG_ApeOptions [ side ] ;
18886: LD_ADDR_VAR 0 4
18890: PUSH
18891: LD_EXP 40
18895: PUSH
18896: LD_VAR 0 1
18900: ARRAY
18901: ST_TO_ADDR
// apes := MCF_ApeSpec ( side , normal ) ;
18902: LD_ADDR_VAR 0 5
18906: PUSH
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_STRING normal
18914: PPUSH
18915: CALL 12084 0 2
18919: ST_TO_ADDR
// if apes then
18920: LD_VAR 0 5
18924: IFFALSE 19152
// begin if GetTech ( tech_apepsych , side ) = state_researched and tmp [ 2 ] = 1 and MCF_ApeSpec ( side , engineer ) < 3 and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
18926: LD_INT 2
18928: PPUSH
18929: LD_VAR 0 1
18933: PPUSH
18934: CALL_OW 321
18938: PUSH
18939: LD_INT 2
18941: EQUAL
18942: PUSH
18943: LD_VAR 0 4
18947: PUSH
18948: LD_INT 2
18950: ARRAY
18951: PUSH
18952: LD_INT 1
18954: EQUAL
18955: AND
18956: PUSH
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_STRING engineer
18964: PPUSH
18965: CALL 12084 0 2
18969: PUSH
18970: LD_INT 3
18972: LESS
18973: AND
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 30
18982: PUSH
18983: LD_INT 1
18985: PUSH
18986: EMPTY
18987: LIST
18988: LIST
18989: PPUSH
18990: CALL 11587 0 2
18994: AND
18995: IFFALSE 19049
// begin for i in apes do
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 5
19006: PUSH
19007: FOR_IN
19008: IFFALSE 19045
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ;
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_VAR 0 1
19019: PPUSH
19020: LD_INT 30
19022: PUSH
19023: LD_INT 1
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL 11587 0 2
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: PPUSH
19039: CALL_OW 120
// end ;
19043: GO 19007
19045: POP
19046: POP
// end else
19047: GO 19152
// if GetTech ( tech_apeagres , side ) = state_researched and tmp [ 1 ] = 1 and MCF_Get ( side , [ f_btype , b_barracks ] ) then
19049: LD_INT 11
19051: PPUSH
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 321
19061: PUSH
19062: LD_INT 2
19064: EQUAL
19065: PUSH
19066: LD_VAR 0 4
19070: PUSH
19071: LD_INT 1
19073: ARRAY
19074: PUSH
19075: LD_INT 1
19077: EQUAL
19078: AND
19079: PUSH
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_INT 30
19087: PUSH
19088: LD_INT 5
19090: PUSH
19091: EMPTY
19092: LIST
19093: LIST
19094: PPUSH
19095: CALL 11587 0 2
19099: AND
19100: IFFALSE 19152
// begin for i in apes do
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19150
// begin ComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ) ;
19115: LD_VAR 0 3
19119: PPUSH
19120: LD_VAR 0 1
19124: PPUSH
19125: LD_INT 30
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PPUSH
19135: CALL 11587 0 2
19139: PUSH
19140: LD_INT 1
19142: ARRAY
19143: PPUSH
19144: CALL_OW 120
// end ;
19148: GO 19112
19150: POP
19151: POP
// end ; end ; end ; end_of_file
19152: LD_VAR 0 2
19156: RET
// export function MCP_Heal ( unit , target ) ; var i ; begin
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// if not GetClass ( unit ) = 4 or not target then
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 257
19170: PUSH
19171: LD_INT 4
19173: EQUAL
19174: NOT
19175: PUSH
19176: LD_VAR 0 2
19180: NOT
19181: OR
19182: IFFALSE 19188
// exit else
19184: GO 19222
19186: GO 19222
// if not GetTag ( unit ) = 4 then
19188: LD_VAR 0 1
19192: PPUSH
19193: CALL_OW 110
19197: PUSH
19198: LD_INT 4
19200: EQUAL
19201: NOT
19202: IFFALSE 19208
// exit else
19204: GO 19222
19206: GO 19222
// ComHeal ( unit , target ) ;
19208: LD_VAR 0 1
19212: PPUSH
19213: LD_VAR 0 2
19217: PPUSH
19218: CALL_OW 128
// end ;
19222: LD_VAR 0 3
19226: RET
// export function MCP_Filter ( side ) ; var i , j , tmp , r , m , d ; begin
19227: LD_INT 0
19229: PPUSH
19230: PPUSH
19231: PPUSH
19232: PPUSH
19233: PPUSH
19234: PPUSH
19235: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_driving ] ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
19236: LD_ADDR_VAR 0 5
19240: PUSH
19241: LD_INT 22
19243: PUSH
19244: LD_VAR 0 1
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 21
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 55
19268: PUSH
19269: EMPTY
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: PUSH
19276: LD_INT 3
19278: PUSH
19279: LD_INT 54
19281: PUSH
19282: EMPTY
19283: LIST
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 24
19294: PUSH
19295: LD_INT 1000
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: PUSH
19302: EMPTY
19303: LIST
19304: LIST
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: PPUSH
19313: CALL_OW 69
19317: ST_TO_ADDR
// d := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
19318: LD_ADDR_VAR 0 8
19322: PUSH
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_INT 30
19330: PUSH
19331: LD_INT 1
19333: PUSH
19334: EMPTY
19335: LIST
19336: LIST
19337: PPUSH
19338: CALL 11587 0 2
19342: ST_TO_ADDR
// r := [ ] ;
19343: LD_ADDR_VAR 0 6
19347: PUSH
19348: EMPTY
19349: ST_TO_ADDR
// if MCF_Tag ( side , 5 , [ ] ) then
19350: LD_VAR 0 1
19354: PPUSH
19355: LD_INT 5
19357: PPUSH
19358: EMPTY
19359: PPUSH
19360: CALL 12290 0 3
19364: IFFALSE 19420
// for j in MCF_Tag ( side , 5 , [ ] ) do
19366: LD_ADDR_VAR 0 4
19370: PUSH
19371: LD_VAR 0 1
19375: PPUSH
19376: LD_INT 5
19378: PPUSH
19379: EMPTY
19380: PPUSH
19381: CALL 12290 0 3
19385: PUSH
19386: FOR_IN
19387: IFFALSE 19418
// if GetLives ( j ) = 1000 then
19389: LD_VAR 0 4
19393: PPUSH
19394: CALL_OW 256
19398: PUSH
19399: LD_INT 1000
19401: EQUAL
19402: IFFALSE 19416
// SetTag ( j , 0 ) ;
19404: LD_VAR 0 4
19408: PPUSH
19409: LD_INT 0
19411: PPUSH
19412: CALL_OW 109
19416: GO 19386
19418: POP
19419: POP
// if tmp then
19420: LD_VAR 0 5
19424: IFFALSE 19753
// begin r := [ tmp [ 1 ] ] ;
19426: LD_ADDR_VAR 0 6
19430: PUSH
19431: LD_VAR 0 5
19435: PUSH
19436: LD_INT 1
19438: ARRAY
19439: PUSH
19440: EMPTY
19441: LIST
19442: ST_TO_ADDR
// for i = 2 to tmp do
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: DOUBLE
19449: LD_INT 2
19451: DEC
19452: ST_TO_ADDR
19453: LD_VAR 0 5
19457: PUSH
19458: FOR_TO
19459: IFFALSE 19751
// begin m := false ;
19461: LD_ADDR_VAR 0 7
19465: PUSH
19466: LD_INT 0
19468: ST_TO_ADDR
// if d then
19469: LD_VAR 0 8
19473: IFFALSE 19628
// if GetLives ( tmp [ i ] ) < 650 and GetDistUnitXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) > 10 then
19475: LD_VAR 0 5
19479: PUSH
19480: LD_VAR 0 3
19484: ARRAY
19485: PPUSH
19486: CALL_OW 256
19490: PUSH
19491: LD_INT 650
19493: LESS
19494: PUSH
19495: LD_VAR 0 5
19499: PUSH
19500: LD_VAR 0 3
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 8
19510: PUSH
19511: LD_INT 1
19513: ARRAY
19514: PPUSH
19515: CALL_OW 250
19519: PPUSH
19520: LD_VAR 0 8
19524: PUSH
19525: LD_INT 1
19527: ARRAY
19528: PPUSH
19529: CALL_OW 251
19533: PPUSH
19534: CALL_OW 297
19538: PUSH
19539: LD_INT 10
19541: GREATER
19542: AND
19543: IFFALSE 19628
// begin if not GetTag ( tmp [ i ] ) = 5 then
19545: LD_VAR 0 5
19549: PUSH
19550: LD_VAR 0 3
19554: ARRAY
19555: PPUSH
19556: CALL_OW 110
19560: PUSH
19561: LD_INT 5
19563: EQUAL
19564: NOT
19565: IFFALSE 19585
// SetTag ( tmp [ i ] , 5 ) ;
19567: LD_VAR 0 5
19571: PUSH
19572: LD_VAR 0 3
19576: ARRAY
19577: PPUSH
19578: LD_INT 5
19580: PPUSH
19581: CALL_OW 109
// ComMoveXY ( tmp [ i ] , GetX ( d [ 1 ] ) , GetY ( d [ 1 ] ) ) ;
19585: LD_VAR 0 5
19589: PUSH
19590: LD_VAR 0 3
19594: ARRAY
19595: PPUSH
19596: LD_VAR 0 8
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PPUSH
19605: CALL_OW 250
19609: PPUSH
19610: LD_VAR 0 8
19614: PUSH
19615: LD_INT 1
19617: ARRAY
19618: PPUSH
19619: CALL_OW 251
19623: PPUSH
19624: CALL_OW 111
// end ; for j = 1 to r do
19628: LD_ADDR_VAR 0 4
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19718
// if GetLives ( tmp [ i ] ) < r [ j ] then
19646: LD_VAR 0 5
19650: PUSH
19651: LD_VAR 0 3
19655: ARRAY
19656: PPUSH
19657: CALL_OW 256
19661: PUSH
19662: LD_VAR 0 6
19666: PUSH
19667: LD_VAR 0 4
19671: ARRAY
19672: LESS
19673: IFFALSE 19716
// begin r := Insert ( r , j , tmp [ i ] ) ;
19675: LD_ADDR_VAR 0 6
19679: PUSH
19680: LD_VAR 0 6
19684: PPUSH
19685: LD_VAR 0 4
19689: PPUSH
19690: LD_VAR 0 5
19694: PUSH
19695: LD_VAR 0 3
19699: ARRAY
19700: PPUSH
19701: CALL_OW 2
19705: ST_TO_ADDR
// m := true ;
19706: LD_ADDR_VAR 0 7
19710: PUSH
19711: LD_INT 1
19713: ST_TO_ADDR
// break ;
19714: GO 19718
// end ;
19716: GO 19643
19718: POP
19719: POP
// if not m then
19720: LD_VAR 0 7
19724: NOT
19725: IFFALSE 19749
// r := r ^ tmp [ i ] ;
19727: LD_ADDR_VAR 0 6
19731: PUSH
19732: LD_VAR 0 6
19736: PUSH
19737: LD_VAR 0 5
19741: PUSH
19742: LD_VAR 0 3
19746: ARRAY
19747: ADD
19748: ST_TO_ADDR
// end ;
19749: GO 19458
19751: POP
19752: POP
// end ; result := r end ; end_of_file
19753: LD_ADDR_VAR 0 2
19757: PUSH
19758: LD_VAR 0 6
19762: ST_TO_ADDR
19763: LD_VAR 0 2
19767: RET
// export function MCS_SourceDepot ( bdepot ) ; var pom , sor ; begin
19768: LD_INT 0
19770: PPUSH
19771: PPUSH
19772: PPUSH
// pom := GetBase ( bdepot ) ;
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_VAR 0 1
19782: PPUSH
19783: CALL_OW 274
19787: ST_TO_ADDR
// sor := [ ] ;
19788: LD_ADDR_VAR 0 4
19792: PUSH
19793: EMPTY
19794: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
19795: LD_ADDR_VAR 0 4
19799: PUSH
19800: LD_VAR 0 4
19804: PUSH
19805: LD_VAR 0 3
19809: PPUSH
19810: LD_INT 1
19812: PPUSH
19813: CALL_OW 275
19817: ADD
19818: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
19819: LD_ADDR_VAR 0 4
19823: PUSH
19824: LD_VAR 0 4
19828: PUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 275
19841: ADD
19842: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
19843: LD_ADDR_VAR 0 4
19847: PUSH
19848: LD_VAR 0 4
19852: PUSH
19853: LD_VAR 0 3
19857: PPUSH
19858: LD_INT 3
19860: PPUSH
19861: CALL_OW 275
19865: ADD
19866: ST_TO_ADDR
// result := sor ;
19867: LD_ADDR_VAR 0 2
19871: PUSH
19872: LD_VAR 0 4
19876: ST_TO_ADDR
// end ;
19877: LD_VAR 0 2
19881: RET
// export function MCS_AddFortification ( side , type , coord_list , weapon_list ) ; var i ; begin
19882: LD_INT 0
19884: PPUSH
19885: PPUSH
// while ( coord_list ) do
19886: LD_VAR 0 3
19890: IFFALSE 20064
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type , [ coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] ] ) ;
19892: LD_ADDR_EXP 48
19896: PUSH
19897: LD_EXP 48
19901: PPUSH
19902: LD_VAR 0 1
19906: PPUSH
19907: LD_VAR 0 2
19911: PPUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PUSH
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: PUSH
19930: LD_VAR 0 3
19934: PUSH
19935: LD_INT 3
19937: ARRAY
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: PPUSH
19944: CALL 41882 0 4
19948: ST_TO_ADDR
// if weapon_list then
19949: LD_VAR 0 4
19953: IFFALSE 20024
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
19955: LD_ADDR_EXP 45
19959: PUSH
19960: LD_EXP 45
19964: PPUSH
19965: LD_VAR 0 1
19969: PPUSH
19970: LD_VAR 0 4
19974: PUSH
19975: LD_INT 1
19977: ARRAY
19978: PPUSH
19979: LD_VAR 0 3
19983: PUSH
19984: LD_INT 1
19986: ARRAY
19987: PUSH
19988: LD_VAR 0 3
19992: PUSH
19993: LD_INT 2
19995: ARRAY
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PPUSH
20001: CALL 41882 0 4
20005: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 4
20015: PPUSH
20016: LD_INT 1
20018: PPUSH
20019: CALL_OW 3
20023: ST_TO_ADDR
// end ; for i = 1 to 3 do
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: DOUBLE
20030: LD_INT 1
20032: DEC
20033: ST_TO_ADDR
20034: LD_INT 3
20036: PUSH
20037: FOR_TO
20038: IFFALSE 20060
// coord_list := Delete ( coord_list , 1 ) ;
20040: LD_ADDR_VAR 0 3
20044: PUSH
20045: LD_VAR 0 3
20049: PPUSH
20050: LD_INT 1
20052: PPUSH
20053: CALL_OW 3
20057: ST_TO_ADDR
20058: GO 20037
20060: POP
20061: POP
// end ;
20062: GO 19886
// result := true ;
20064: LD_ADDR_VAR 0 5
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// end ;
20072: LD_VAR 0 5
20076: RET
// export function MCS_ChangeFortification ( side , coord_list , weapon_list ) ; var i ; begin
20077: LD_INT 0
20079: PPUSH
20080: PPUSH
// if not weapon_list then
20081: LD_VAR 0 3
20085: NOT
20086: IFFALSE 20090
// exit ;
20088: GO 20205
// while ( coord_list ) do
20090: LD_VAR 0 2
20094: IFFALSE 20205
// begin MREG_TurretWeapon := MC_RegistryUpdate ( MREG_TurretWeapon , side , weapon_list [ 1 ] , [ coord_list [ 1 ] , coord_list [ 2 ] ] ) ;
20096: LD_ADDR_EXP 45
20100: PUSH
20101: LD_EXP 45
20105: PPUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: LD_VAR 0 3
20115: PUSH
20116: LD_INT 1
20118: ARRAY
20119: PPUSH
20120: LD_VAR 0 2
20124: PUSH
20125: LD_INT 1
20127: ARRAY
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_INT 2
20136: ARRAY
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PPUSH
20142: CALL 41882 0 4
20146: ST_TO_ADDR
// weapon_list := Delete ( weapon_list , 1 ) ;
20147: LD_ADDR_VAR 0 3
20151: PUSH
20152: LD_VAR 0 3
20156: PPUSH
20157: LD_INT 1
20159: PPUSH
20160: CALL_OW 3
20164: ST_TO_ADDR
// for i = 1 to 2 do
20165: LD_ADDR_VAR 0 5
20169: PUSH
20170: DOUBLE
20171: LD_INT 1
20173: DEC
20174: ST_TO_ADDR
20175: LD_INT 2
20177: PUSH
20178: FOR_TO
20179: IFFALSE 20201
// coord_list := Delete ( coord_list , 1 ) ;
20181: LD_ADDR_VAR 0 2
20185: PUSH
20186: LD_VAR 0 2
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 3
20198: ST_TO_ADDR
20199: GO 20178
20201: POP
20202: POP
// end ;
20203: GO 20090
// end ;
20205: LD_VAR 0 4
20209: RET
// export function MCS_DeleteFortification ( side , coord_list ) ; var i ; begin
20210: LD_INT 0
20212: PPUSH
20213: PPUSH
// while ( coord_list ) do
20214: LD_VAR 0 2
20218: IFFALSE 20373
// begin if HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) then
20220: LD_VAR 0 2
20224: PUSH
20225: LD_INT 1
20227: ARRAY
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_INT 2
20236: ARRAY
20237: PPUSH
20238: CALL_OW 428
20242: IFFALSE 20333
// if GetBType ( HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) ) in [ b_breastwork , b_bunker , b_turret ] then
20244: LD_VAR 0 2
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_VAR 0 2
20257: PUSH
20258: LD_INT 2
20260: ARRAY
20261: PPUSH
20262: CALL_OW 428
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 31
20274: PUSH
20275: LD_INT 32
20277: PUSH
20278: LD_INT 33
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: IN
20286: IFFALSE 20333
// MREG_ToDismantle := MC_RegistryUpdate ( MREG_ToDismantle , side , HexInfo ( coord_list [ 1 ] , coord_list [ 2 ] ) , [ ] ) ;
20288: LD_ADDR_EXP 54
20292: PUSH
20293: LD_EXP 54
20297: PPUSH
20298: LD_VAR 0 1
20302: PPUSH
20303: LD_VAR 0 2
20307: PUSH
20308: LD_INT 1
20310: ARRAY
20311: PPUSH
20312: LD_VAR 0 2
20316: PUSH
20317: LD_INT 2
20319: ARRAY
20320: PPUSH
20321: CALL_OW 428
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL 41882 0 4
20332: ST_TO_ADDR
// for i = 1 to 3 do
20333: LD_ADDR_VAR 0 4
20337: PUSH
20338: DOUBLE
20339: LD_INT 1
20341: DEC
20342: ST_TO_ADDR
20343: LD_INT 3
20345: PUSH
20346: FOR_TO
20347: IFFALSE 20369
// coord_list := Delete ( coord_list , 1 ) ;
20349: LD_ADDR_VAR 0 2
20353: PUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: LD_INT 1
20361: PPUSH
20362: CALL_OW 3
20366: ST_TO_ADDR
20367: GO 20346
20369: POP
20370: POP
// end ;
20371: GO 20214
// result := true ;
20373: LD_ADDR_VAR 0 3
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// end ;
20381: LD_VAR 0 3
20385: RET
// export function MCS_Depot ( side , coord_list ) ; begin
20386: LD_INT 0
20388: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_depot , coord_list ) ;
20389: LD_ADDR_EXP 48
20393: PUSH
20394: LD_EXP 48
20398: PPUSH
20399: LD_VAR 0 1
20403: PPUSH
20404: LD_INT 0
20406: PPUSH
20407: LD_VAR 0 2
20411: PPUSH
20412: CALL 41882 0 4
20416: ST_TO_ADDR
// end ;
20417: LD_VAR 0 3
20421: RET
// export function MCS_Lab ( side , coord_list , lab_kind ) ; begin
20422: LD_INT 0
20424: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_lab , coord_list ) ;
20425: LD_ADDR_EXP 48
20429: PUSH
20430: LD_EXP 48
20434: PPUSH
20435: LD_VAR 0 1
20439: PPUSH
20440: LD_INT 6
20442: PPUSH
20443: LD_VAR 0 2
20447: PPUSH
20448: CALL 41882 0 4
20452: ST_TO_ADDR
// MREG_ToUpLab := MC_RegistryUpdate ( MREG_ToUpLab , side , lab_kind [ 1 ] , lab_kind [ 2 ] ) ;
20453: LD_ADDR_EXP 51
20457: PUSH
20458: LD_EXP 51
20462: PPUSH
20463: LD_VAR 0 1
20467: PPUSH
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 1
20475: ARRAY
20476: PPUSH
20477: LD_VAR 0 3
20481: PUSH
20482: LD_INT 2
20484: ARRAY
20485: PPUSH
20486: CALL 41882 0 4
20490: ST_TO_ADDR
// end ;
20491: LD_VAR 0 4
20495: RET
// export function MCS_Factory ( side , coord_list , ext_list ) ; var i ; begin
20496: LD_INT 0
20498: PPUSH
20499: PPUSH
// if ext_list > 5 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 5
20507: GREATER
20508: IFFALSE 20552
// for i = 6 to ext_list do
20510: LD_ADDR_VAR 0 5
20514: PUSH
20515: DOUBLE
20516: LD_INT 6
20518: DEC
20519: ST_TO_ADDR
20520: LD_VAR 0 3
20524: PUSH
20525: FOR_TO
20526: IFFALSE 20550
// ext_list := Delete ( ext_list , ext_list ) ;
20528: LD_ADDR_VAR 0 3
20532: PUSH
20533: LD_VAR 0 3
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: CALL_OW 3
20547: ST_TO_ADDR
20548: GO 20525
20550: POP
20551: POP
// MCB_Factory ( side , coord_list [ 1 ] , coord_list [ 2 ] , coord_list [ 3 ] , ext_list ) ;
20552: LD_VAR 0 1
20556: PPUSH
20557: LD_VAR 0 2
20561: PUSH
20562: LD_INT 1
20564: ARRAY
20565: PPUSH
20566: LD_VAR 0 2
20570: PUSH
20571: LD_INT 2
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PPUSH
20584: LD_VAR 0 3
20588: PPUSH
20589: CALL 9099 0 5
// end ;
20593: LD_VAR 0 4
20597: RET
// export function MCS_PowerPlants ( side , coord_list , type_list ) ; var i , p ; begin
20598: LD_INT 0
20600: PPUSH
20601: PPUSH
20602: PPUSH
// p := 1 ;
20603: LD_ADDR_VAR 0 6
20607: PUSH
20608: LD_INT 1
20610: ST_TO_ADDR
// if type_list = [ ] then
20611: LD_VAR 0 3
20615: PUSH
20616: EMPTY
20617: EQUAL
20618: IFFALSE 20628
// type_list := b_oil_power ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_INT 26
20627: ST_TO_ADDR
// for i = 1 to ( coord_list / 3 ) do
20628: LD_ADDR_VAR 0 5
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 2
20642: PUSH
20643: LD_INT 3
20645: DIVREAL
20646: PUSH
20647: FOR_TO
20648: IFFALSE 20751
// begin MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , type_list [ Rand ( 1 , type_list ) ] , [ coord_list [ p ] , coord_list [ p + 1 ] , coord_list [ p + 2 ] ] ) ;
20650: LD_ADDR_EXP 48
20654: PUSH
20655: LD_EXP 48
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 3
20669: PUSH
20670: LD_INT 1
20672: PPUSH
20673: LD_VAR 0 3
20677: PPUSH
20678: CALL_OW 12
20682: ARRAY
20683: PPUSH
20684: LD_VAR 0 2
20688: PUSH
20689: LD_VAR 0 6
20693: ARRAY
20694: PUSH
20695: LD_VAR 0 2
20699: PUSH
20700: LD_VAR 0 6
20704: PUSH
20705: LD_INT 1
20707: PLUS
20708: ARRAY
20709: PUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_VAR 0 6
20719: PUSH
20720: LD_INT 2
20722: PLUS
20723: ARRAY
20724: PUSH
20725: EMPTY
20726: LIST
20727: LIST
20728: LIST
20729: PPUSH
20730: CALL 41882 0 4
20734: ST_TO_ADDR
// p := p + 3 ;
20735: LD_ADDR_VAR 0 6
20739: PUSH
20740: LD_VAR 0 6
20744: PUSH
20745: LD_INT 3
20747: PLUS
20748: ST_TO_ADDR
// end ;
20749: GO 20647
20751: POP
20752: POP
// end ;
20753: LD_VAR 0 4
20757: RET
// export function MCS_Mine ( side ) ; var i , p , b ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not MREG_Deposit [ side ] then
20764: LD_EXP 63
20768: PUSH
20769: LD_VAR 0 1
20773: ARRAY
20774: NOT
20775: IFFALSE 20779
// exit ;
20777: GO 20956
// p := 1 ;
20779: LD_ADDR_VAR 0 4
20783: PUSH
20784: LD_INT 1
20786: ST_TO_ADDR
// for i = 1 to MREG_Deposit [ side ] / 3 do
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: DOUBLE
20793: LD_INT 1
20795: DEC
20796: ST_TO_ADDR
20797: LD_EXP 63
20801: PUSH
20802: LD_VAR 0 1
20806: ARRAY
20807: PUSH
20808: LD_INT 3
20810: DIVREAL
20811: PUSH
20812: FOR_TO
20813: IFFALSE 20954
// begin if MREG_Deposit [ side ] [ p + 2 ] = 2 then
20815: LD_EXP 63
20819: PUSH
20820: LD_VAR 0 1
20824: ARRAY
20825: PUSH
20826: LD_VAR 0 4
20830: PUSH
20831: LD_INT 2
20833: PLUS
20834: ARRAY
20835: PUSH
20836: LD_INT 2
20838: EQUAL
20839: IFFALSE 20851
// b := b_oil_mine else
20841: LD_ADDR_VAR 0 5
20845: PUSH
20846: LD_INT 29
20848: ST_TO_ADDR
20849: GO 20859
// b := b_siberite_mine ;
20851: LD_ADDR_VAR 0 5
20855: PUSH
20856: LD_INT 30
20858: ST_TO_ADDR
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b , [ MREG_Deposit [ side ] [ p ] , MREG_Deposit [ side ] [ p + 1 ] , Rand ( 0 , 5 ) ] ) ;
20859: LD_ADDR_EXP 48
20863: PUSH
20864: LD_EXP 48
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_VAR 0 5
20878: PPUSH
20879: LD_EXP 63
20883: PUSH
20884: LD_VAR 0 1
20888: ARRAY
20889: PUSH
20890: LD_VAR 0 4
20894: ARRAY
20895: PUSH
20896: LD_EXP 63
20900: PUSH
20901: LD_VAR 0 1
20905: ARRAY
20906: PUSH
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: ARRAY
20916: PUSH
20917: LD_INT 0
20919: PPUSH
20920: LD_INT 5
20922: PPUSH
20923: CALL_OW 12
20927: PUSH
20928: EMPTY
20929: LIST
20930: LIST
20931: LIST
20932: PPUSH
20933: CALL 41882 0 4
20937: ST_TO_ADDR
// p := p + 3 ;
20938: LD_ADDR_VAR 0 4
20942: PUSH
20943: LD_VAR 0 4
20947: PUSH
20948: LD_INT 3
20950: PLUS
20951: ST_TO_ADDR
// end ;
20952: GO 20812
20954: POP
20955: POP
// end ;
20956: LD_VAR 0 2
20960: RET
// export function MCS_Barracks ( side , coord_list ) ; begin
20961: LD_INT 0
20963: PPUSH
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_armoury , coord_list ) ;
20964: LD_ADDR_EXP 48
20968: PUSH
20969: LD_EXP 48
20973: PPUSH
20974: LD_VAR 0 1
20978: PPUSH
20979: LD_INT 4
20981: PPUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: CALL 41882 0 4
20991: ST_TO_ADDR
// end ;
20992: LD_VAR 0 3
20996: RET
// export function MCS_ControlTower ( side , nation , coord_list ) ; begin
20997: LD_INT 0
20999: PPUSH
// case nation of 1 , us :
21000: LD_VAR 0 2
21004: PUSH
21005: LD_INT 1
21007: DOUBLE
21008: EQUAL
21009: IFTRUE 21019
21011: LD_STRING us
21013: DOUBLE
21014: EQUAL
21015: IFTRUE 21019
21017: GO 21050
21019: POP
// MREG_ToBuild := MC_RegistryUpdate ( MREG_ToBuild , side , b_control_tower , coord_list ) ; 2 , ar :
21020: LD_ADDR_EXP 48
21024: PUSH
21025: LD_EXP 48
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_INT 36
21037: PPUSH
21038: LD_VAR 0 3
21042: PPUSH
21043: CALL 41882 0 4
21047: ST_TO_ADDR
21048: GO 21101
21050: LD_INT 2
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21064
21056: LD_STRING ar
21058: DOUBLE
21059: EQUAL
21060: IFTRUE 21064
21062: GO 21100
21064: POP
// MREG_ToBuild := MCS_AddVehicle ( side , [ ar_half_tracked , engine_solar , control_manual , ar_control_tower ] ) ; end ;
21065: LD_ADDR_EXP 48
21069: PUSH
21070: LD_VAR 0 1
21074: PPUSH
21075: LD_INT 14
21077: PUSH
21078: LD_INT 2
21080: PUSH
21081: LD_INT 1
21083: PUSH
21084: LD_INT 31
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: LIST
21091: LIST
21092: PPUSH
21093: CALL 21106 0 2
21097: ST_TO_ADDR
21098: GO 21101
21100: POP
// end ;
21101: LD_VAR 0 4
21105: RET
// export function MCS_AddVehicle ( side , list ) ; var i ; begin
21106: LD_INT 0
21108: PPUSH
21109: PPUSH
// for i = 1 to list do
21110: LD_ADDR_VAR 0 4
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 2
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21176
// MREG_ToConstruct := Replace2 ( MREG_ToConstruct , side , MREG_ToConstruct [ side ] + 1 , list [ i ] ) ;
21128: LD_ADDR_EXP 53
21132: PUSH
21133: LD_EXP 53
21137: PPUSH
21138: LD_VAR 0 1
21142: PPUSH
21143: LD_EXP 53
21147: PUSH
21148: LD_VAR 0 1
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: PLUS
21157: PPUSH
21158: LD_VAR 0 2
21162: PUSH
21163: LD_VAR 0 4
21167: ARRAY
21168: PPUSH
21169: CALL 31052 0 4
21173: ST_TO_ADDR
21174: GO 21125
21176: POP
21177: POP
// end ;
21178: LD_VAR 0 3
21182: RET
// export function MCS_GetVehicleList ( side ) ; begin
21183: LD_INT 0
21185: PPUSH
// result := MREG_ToConstruct [ side ] ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_EXP 53
21195: PUSH
21196: LD_VAR 0 1
21200: ARRAY
21201: ST_TO_ADDR
// end ;
21202: LD_VAR 0 2
21206: RET
// export function MCS_SetParking ( side , area ) ; var i ; begin
21207: LD_INT 0
21209: PPUSH
21210: PPUSH
// MREG_Parking := Replace ( MREG_Parking , side , area ) ;
21211: LD_ADDR_EXP 60
21215: PUSH
21216: LD_EXP 60
21220: PPUSH
21221: LD_VAR 0 1
21225: PPUSH
21226: LD_VAR 0 2
21230: PPUSH
21231: CALL_OW 1
21235: ST_TO_ADDR
// end ;
21236: LD_VAR 0 3
21240: RET
// export function MCS_ApeLimit ( side , limit ) ; begin
21241: LD_INT 0
21243: PPUSH
// MREG_Tame := Replace ( MREG_Tame , side , limit ) ;
21244: LD_ADDR_EXP 39
21248: PUSH
21249: LD_EXP 39
21253: PPUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: LD_VAR 0 2
21263: PPUSH
21264: CALL_OW 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 3
21273: RET
// export function MCS_ApeOptions ( side , options ) ; begin
21274: LD_INT 0
21276: PPUSH
// MREG_ApeOptions := Replace ( MREG_ApeOptions , side , options ) ;
21277: LD_ADDR_EXP 40
21281: PUSH
21282: LD_EXP 40
21286: PPUSH
21287: LD_VAR 0 1
21291: PPUSH
21292: LD_VAR 0 2
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 3
21306: RET
// export function MCS_Collector ( side , mode , areas ) ; begin
21307: LD_INT 0
21309: PPUSH
// MREG_Collect := Replace2 ( MREG_Collect , side , 1 , mode ) ;
21310: LD_ADDR_EXP 62
21314: PUSH
21315: LD_EXP 62
21319: PPUSH
21320: LD_VAR 0 1
21324: PPUSH
21325: LD_INT 1
21327: PPUSH
21328: LD_VAR 0 2
21332: PPUSH
21333: CALL 31052 0 4
21337: ST_TO_ADDR
// MREG_Collect := Replace2 ( MREG_Collect , side , 2 , areas ) ;
21338: LD_ADDR_EXP 62
21342: PUSH
21343: LD_EXP 62
21347: PPUSH
21348: LD_VAR 0 1
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: LD_VAR 0 3
21360: PPUSH
21361: CALL 31052 0 4
21365: ST_TO_ADDR
// end ;
21366: LD_VAR 0 4
21370: RET
// export function MCS_SetResourcesBonus ( crates , oil , sib ) ; begin
21371: LD_INT 0
21373: PPUSH
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 1 , crates ) ;
21374: LD_ADDR_EXP 74
21378: PUSH
21379: LD_EXP 74
21383: PPUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 2 , oil ) ;
21397: LD_ADDR_EXP 74
21401: PUSH
21402: LD_EXP 74
21406: PPUSH
21407: LD_INT 2
21409: PPUSH
21410: LD_VAR 0 2
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
// MREG_ResourcesBonus := Replace ( MREG_ResourcesBonus , 3 , sib ) ;
21420: LD_ADDR_EXP 74
21424: PUSH
21425: LD_EXP 74
21429: PPUSH
21430: LD_INT 3
21432: PPUSH
21433: LD_VAR 0 3
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// end ;
21443: LD_VAR 0 4
21447: RET
// export function MCS_CreateDeposits ( side , list ) ; var i , p ; begin
21448: LD_INT 0
21450: PPUSH
21451: PPUSH
21452: PPUSH
// if not side or not list then
21453: LD_VAR 0 1
21457: NOT
21458: PUSH
21459: LD_VAR 0 2
21463: NOT
21464: OR
21465: IFFALSE 21469
// exit ;
21467: GO 21637
// SetTech ( 20 , side , state_researched ) ;
21469: LD_INT 20
21471: PPUSH
21472: LD_VAR 0 1
21476: PPUSH
21477: LD_INT 2
21479: PPUSH
21480: CALL_OW 322
// MREG_Deposit := Insert ( MREG_Deposit , side , list ) ;
21484: LD_ADDR_EXP 63
21488: PUSH
21489: LD_EXP 63
21493: PPUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: LD_VAR 0 2
21503: PPUSH
21504: CALL_OW 2
21508: ST_TO_ADDR
// p := 1 ;
21509: LD_ADDR_VAR 0 5
21513: PUSH
21514: LD_INT 1
21516: ST_TO_ADDR
// for i = 1 to list / 3 do
21517: LD_ADDR_VAR 0 4
21521: PUSH
21522: DOUBLE
21523: LD_INT 1
21525: DEC
21526: ST_TO_ADDR
21527: LD_VAR 0 2
21531: PUSH
21532: LD_INT 3
21534: DIVREAL
21535: PUSH
21536: FOR_TO
21537: IFFALSE 21635
// begin MCT_CreateDepositXYT ( list [ p ] , list [ p + 1 ] , list [ p + 2 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_VAR 0 5
21548: ARRAY
21549: PPUSH
21550: LD_VAR 0 2
21554: PUSH
21555: LD_VAR 0 5
21559: PUSH
21560: LD_INT 1
21562: PLUS
21563: ARRAY
21564: PPUSH
21565: LD_VAR 0 2
21569: PUSH
21570: LD_VAR 0 5
21574: PUSH
21575: LD_INT 2
21577: PLUS
21578: ARRAY
21579: PPUSH
21580: CALL 22339 0 3
// SetResourceVisibility ( list [ p ] , list [ p + 1 ] , side ) ;
21584: LD_VAR 0 2
21588: PUSH
21589: LD_VAR 0 5
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 2
21599: PUSH
21600: LD_VAR 0 5
21604: PUSH
21605: LD_INT 1
21607: PLUS
21608: ARRAY
21609: PPUSH
21610: LD_VAR 0 1
21614: PPUSH
21615: CALL_OW 441
// p := p + 3 ;
21619: LD_ADDR_VAR 0 5
21623: PUSH
21624: LD_VAR 0 5
21628: PUSH
21629: LD_INT 3
21631: PLUS
21632: ST_TO_ADDR
// end ;
21633: GO 21536
21635: POP
21636: POP
// end ;
21637: LD_VAR 0 3
21641: RET
// export function MCS_SibBomb ( side , nat ) ; var list ; begin
21642: LD_INT 0
21644: PPUSH
21645: PPUSH
// if nat = nation_arabian then
21646: LD_VAR 0 2
21650: PUSH
21651: LD_INT 2
21653: EQUAL
21654: IFFALSE 21660
// exit else
21656: GO 21732
21658: GO 21718
// if nat = nation_american then
21660: LD_VAR 0 2
21664: PUSH
21665: LD_INT 1
21667: EQUAL
21668: IFFALSE 21695
// list := [ us_heavy_tracked , engine_siberite , control_manual , us_siberium_rocket ] else
21670: LD_ADDR_VAR 0 4
21674: PUSH
21675: LD_INT 4
21677: PUSH
21678: LD_INT 3
21680: PUSH
21681: LD_INT 1
21683: PUSH
21684: LD_INT 8
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: LIST
21692: ST_TO_ADDR
21693: GO 21718
// list := [ ru_heavy_tracked , engine_siberite , control_manual , ru_siberium_rocket ] ;
21695: LD_ADDR_VAR 0 4
21699: PUSH
21700: LD_INT 24
21702: PUSH
21703: LD_INT 3
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: LD_INT 48
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: ST_TO_ADDR
// MCS_AddVehicle ( side , list ) ;
21718: LD_VAR 0 1
21722: PPUSH
21723: LD_VAR 0 4
21727: PPUSH
21728: CALL 21106 0 2
// end ;
21732: LD_VAR 0 3
21736: RET
// export function MCS_SetDefence ( side , area , dont_leave_area , points , squad ) ; var i ; begin
21737: LD_INT 0
21739: PPUSH
21740: PPUSH
// MREG_DefPoints := Replace2 ( MREG_DefPoints , side , 1 , points ) ;
21741: LD_ADDR_EXP 65
21745: PUSH
21746: LD_EXP 65
21750: PPUSH
21751: LD_VAR 0 1
21755: PPUSH
21756: LD_INT 1
21758: PPUSH
21759: LD_VAR 0 4
21763: PPUSH
21764: CALL 31052 0 4
21768: ST_TO_ADDR
// MREG_DefArea := Replace2 ( MREG_DefArea , side , 1 , area ) ;
21769: LD_ADDR_EXP 66
21773: PUSH
21774: LD_EXP 66
21778: PPUSH
21779: LD_VAR 0 1
21783: PPUSH
21784: LD_INT 1
21786: PPUSH
21787: LD_VAR 0 2
21791: PPUSH
21792: CALL 31052 0 4
21796: ST_TO_ADDR
// MREG_DefDontLeave := Replace2 ( MREG_DefDontLeave , side , 1 , dont_leave_area ) ;
21797: LD_ADDR_EXP 67
21801: PUSH
21802: LD_EXP 67
21806: PPUSH
21807: LD_VAR 0 1
21811: PPUSH
21812: LD_INT 1
21814: PPUSH
21815: LD_VAR 0 3
21819: PPUSH
21820: CALL 31052 0 4
21824: ST_TO_ADDR
// MREG_DefSquad := Replace2 ( MREG_DefSquad , side , 1 , squad ) ;
21825: LD_ADDR_EXP 68
21829: PUSH
21830: LD_EXP 68
21834: PPUSH
21835: LD_VAR 0 1
21839: PPUSH
21840: LD_INT 1
21842: PPUSH
21843: LD_VAR 0 5
21847: PPUSH
21848: CALL 31052 0 4
21852: ST_TO_ADDR
// while squad do
21853: LD_VAR 0 5
21857: IFFALSE 21950
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
21859: LD_VAR 0 1
21863: PPUSH
21864: LD_VAR 0 5
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PUSH
21873: LD_VAR 0 5
21877: PUSH
21878: LD_INT 2
21880: ARRAY
21881: PUSH
21882: LD_VAR 0 5
21886: PUSH
21887: LD_INT 3
21889: ARRAY
21890: PUSH
21891: LD_VAR 0 5
21895: PUSH
21896: LD_INT 4
21898: ARRAY
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL 21106 0 2
// for i = 1 to 4 do
21910: LD_ADDR_VAR 0 7
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_INT 4
21922: PUSH
21923: FOR_TO
21924: IFFALSE 21946
// squad := Delete ( squad , 1 ) ;
21926: LD_ADDR_VAR 0 5
21930: PUSH
21931: LD_VAR 0 5
21935: PPUSH
21936: LD_INT 1
21938: PPUSH
21939: CALL_OW 3
21943: ST_TO_ADDR
21944: GO 21923
21946: POP
21947: POP
// end ;
21948: GO 21853
// end ;
21950: LD_VAR 0 6
21954: RET
// export function MCS_PrepareAttack ( side , squad ) ; var i ; begin
21955: LD_INT 0
21957: PPUSH
21958: PPUSH
// for i = 1 to squad do
21959: LD_ADDR_VAR 0 4
21963: PUSH
21964: DOUBLE
21965: LD_INT 1
21967: DEC
21968: ST_TO_ADDR
21969: LD_VAR 0 2
21973: PUSH
21974: FOR_TO
21975: IFFALSE 22025
// MREG_ToAttack := Replace2 ( MREG_ToAttack , side , MREG_ToAttack [ side ] + 1 , squad [ i ] ) ;
21977: LD_ADDR_EXP 71
21981: PUSH
21982: LD_EXP 71
21986: PPUSH
21987: LD_VAR 0 1
21991: PPUSH
21992: LD_EXP 71
21996: PUSH
21997: LD_VAR 0 1
22001: ARRAY
22002: PUSH
22003: LD_INT 1
22005: PLUS
22006: PPUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 4
22016: ARRAY
22017: PPUSH
22018: CALL 31052 0 4
22022: ST_TO_ADDR
22023: GO 21974
22025: POP
22026: POP
// while squad do
22027: LD_VAR 0 2
22031: IFFALSE 22124
// begin MCS_AddVehicle ( side , [ squad [ 1 ] , squad [ 2 ] , squad [ 3 ] , squad [ 4 ] ] ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_INT 1
22045: ARRAY
22046: PUSH
22047: LD_VAR 0 2
22051: PUSH
22052: LD_INT 2
22054: ARRAY
22055: PUSH
22056: LD_VAR 0 2
22060: PUSH
22061: LD_INT 3
22063: ARRAY
22064: PUSH
22065: LD_VAR 0 2
22069: PUSH
22070: LD_INT 4
22072: ARRAY
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: PPUSH
22080: CALL 21106 0 2
// for i = 1 to 4 do
22084: LD_ADDR_VAR 0 4
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_INT 4
22096: PUSH
22097: FOR_TO
22098: IFFALSE 22120
// squad := Delete ( squad , 1 ) ;
22100: LD_ADDR_VAR 0 2
22104: PUSH
22105: LD_VAR 0 2
22109: PPUSH
22110: LD_INT 1
22112: PPUSH
22113: CALL_OW 3
22117: ST_TO_ADDR
22118: GO 22097
22120: POP
22121: POP
// end ;
22122: GO 22027
// end ;
22124: LD_VAR 0 3
22128: RET
// export function MCS_SetSpecClass ( side , sniper_class , mortar_class , bazooker_class ) ; begin
22129: LD_INT 0
22131: PPUSH
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 1 , sniper_class ) ;
22132: LD_ADDR_EXP 64
22136: PUSH
22137: LD_EXP 64
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: LD_INT 1
22149: PPUSH
22150: LD_VAR 0 2
22154: PPUSH
22155: CALL 31052 0 4
22159: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 2 , mortar_class ) ;
22160: LD_ADDR_EXP 64
22164: PUSH
22165: LD_EXP 64
22169: PPUSH
22170: LD_VAR 0 1
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: LD_VAR 0 3
22182: PPUSH
22183: CALL 31052 0 4
22187: ST_TO_ADDR
// MREG_AllowClass := Replace2 ( MREG_AllowClass , side , 3 , bazooker_class ) ;
22188: LD_ADDR_EXP 64
22192: PUSH
22193: LD_EXP 64
22197: PPUSH
22198: LD_VAR 0 1
22202: PPUSH
22203: LD_INT 3
22205: PPUSH
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL 31052 0 4
22215: ST_TO_ADDR
// end ; end_of_file
22216: LD_VAR 0 5
22220: RET
// export function MCT_CutTreeArea ( side , area ) ; begin
22221: LD_INT 0
22223: PPUSH
// MREG_Bulldozer := Replace2 ( MREG_Bulldozer , side , 1 , area ) ;
22224: LD_ADDR_EXP 44
22228: PUSH
22229: LD_EXP 44
22233: PPUSH
22234: LD_VAR 0 1
22238: PPUSH
22239: LD_INT 1
22241: PPUSH
22242: LD_VAR 0 2
22246: PPUSH
22247: CALL 31052 0 4
22251: ST_TO_ADDR
// if GetNation ( MCF_All ( side , [ ] ) [ 1 ] ) = nation_american then
22252: LD_VAR 0 1
22256: PPUSH
22257: EMPTY
22258: PPUSH
22259: CALL 11722 0 2
22263: PUSH
22264: LD_INT 1
22266: ARRAY
22267: PPUSH
22268: CALL_OW 248
22272: PUSH
22273: LD_INT 1
22275: EQUAL
22276: IFFALSE 22307
// MCS_AddVehicle ( side , [ us_heavy_tracked , engine_combustion , control_manual , us_bulldozer ] ) else
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 4
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: LD_INT 1
22291: PUSH
22292: LD_INT 14
22294: PUSH
22295: EMPTY
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: PPUSH
22301: CALL 21106 0 2
22305: GO 22334
// MCS_AddVehicle ( side , [ ru_heavy_tracked , engine_combustion , control_manual , ru_bulldozer ] ) ;
22307: LD_VAR 0 1
22311: PPUSH
22312: LD_INT 24
22314: PUSH
22315: LD_INT 1
22317: PUSH
22318: LD_INT 1
22320: PUSH
22321: LD_INT 53
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL 21106 0 2
// end ;
22334: LD_VAR 0 3
22338: RET
// export function MCT_CreateDepositXYT ( x , y , t ) ; begin
22339: LD_INT 0
22341: PPUSH
// CreateDepositXY ( x , y , t ) ;
22342: LD_VAR 0 1
22346: PPUSH
22347: LD_VAR 0 2
22351: PPUSH
22352: LD_VAR 0 3
22356: PPUSH
22357: CALL_OW 62
// end ;
22361: LD_VAR 0 4
22365: RET
// export function MCT_MarkPlace ( x , y , color ) ; var c ; begin
22366: LD_INT 0
22368: PPUSH
22369: PPUSH
// c := 1 ;
22370: LD_ADDR_VAR 0 5
22374: PUSH
22375: LD_INT 1
22377: ST_TO_ADDR
// case color of red :
22378: LD_VAR 0 3
22382: PUSH
22383: LD_STRING red
22385: DOUBLE
22386: EQUAL
22387: IFTRUE 22391
22389: GO 22402
22391: POP
// c = 1 ; dark-green :
22392: LD_ADDR_VAR 0 5
22396: PUSH
22397: LD_INT 1
22399: ST_TO_ADDR
22400: GO 22688
22402: LD_STRING dark-green
22404: DOUBLE
22405: EQUAL
22406: IFTRUE 22410
22408: GO 22421
22410: POP
// c = 2 ; purple :
22411: LD_ADDR_VAR 0 5
22415: PUSH
22416: LD_INT 2
22418: ST_TO_ADDR
22419: GO 22688
22421: LD_STRING purple
22423: DOUBLE
22424: EQUAL
22425: IFTRUE 22429
22427: GO 22440
22429: POP
// c = 3 ; aqua :
22430: LD_ADDR_VAR 0 5
22434: PUSH
22435: LD_INT 3
22437: ST_TO_ADDR
22438: GO 22688
22440: LD_STRING aqua
22442: DOUBLE
22443: EQUAL
22444: IFTRUE 22448
22446: GO 22459
22448: POP
// c = 4 ; grey :
22449: LD_ADDR_VAR 0 5
22453: PUSH
22454: LD_INT 4
22456: ST_TO_ADDR
22457: GO 22688
22459: LD_STRING grey
22461: DOUBLE
22462: EQUAL
22463: IFTRUE 22467
22465: GO 22478
22467: POP
// c = 5 ; lime :
22468: LD_ADDR_VAR 0 5
22472: PUSH
22473: LD_INT 5
22475: ST_TO_ADDR
22476: GO 22688
22478: LD_STRING lime
22480: DOUBLE
22481: EQUAL
22482: IFTRUE 22486
22484: GO 22497
22486: POP
// c = 6 ; tan :
22487: LD_ADDR_VAR 0 5
22491: PUSH
22492: LD_INT 6
22494: ST_TO_ADDR
22495: GO 22688
22497: LD_STRING tan
22499: DOUBLE
22500: EQUAL
22501: IFTRUE 22505
22503: GO 22516
22505: POP
// c = 7 ; pink :
22506: LD_ADDR_VAR 0 5
22510: PUSH
22511: LD_INT 7
22513: ST_TO_ADDR
22514: GO 22688
22516: LD_STRING pink
22518: DOUBLE
22519: EQUAL
22520: IFTRUE 22524
22522: GO 22535
22524: POP
// c = 8 ; green :
22525: LD_ADDR_VAR 0 5
22529: PUSH
22530: LD_INT 8
22532: ST_TO_ADDR
22533: GO 22688
22535: LD_STRING green
22537: DOUBLE
22538: EQUAL
22539: IFTRUE 22543
22541: GO 22554
22543: POP
// c = 9 ; blue :
22544: LD_ADDR_VAR 0 5
22548: PUSH
22549: LD_INT 9
22551: ST_TO_ADDR
22552: GO 22688
22554: LD_STRING blue
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22573
22562: POP
// c = 10 ; yellow :
22563: LD_ADDR_VAR 0 5
22567: PUSH
22568: LD_INT 10
22570: ST_TO_ADDR
22571: GO 22688
22573: LD_STRING yellow
22575: DOUBLE
22576: EQUAL
22577: IFTRUE 22581
22579: GO 22592
22581: POP
// c = 11 ; brown :
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_INT 11
22589: ST_TO_ADDR
22590: GO 22688
22592: LD_STRING brown
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22600
22598: GO 22611
22600: POP
// c = 12 ; black :
22601: LD_ADDR_VAR 0 5
22605: PUSH
22606: LD_INT 12
22608: ST_TO_ADDR
22609: GO 22688
22611: LD_STRING black
22613: DOUBLE
22614: EQUAL
22615: IFTRUE 22619
22617: GO 22630
22619: POP
// c = 13 ; aqua2 :
22620: LD_ADDR_VAR 0 5
22624: PUSH
22625: LD_INT 13
22627: ST_TO_ADDR
22628: GO 22688
22630: LD_STRING aqua2
22632: DOUBLE
22633: EQUAL
22634: IFTRUE 22638
22636: GO 22649
22638: POP
// c = 14 ; orange :
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_INT 14
22646: ST_TO_ADDR
22647: GO 22688
22649: LD_STRING orange
22651: DOUBLE
22652: EQUAL
22653: IFTRUE 22657
22655: GO 22668
22657: POP
// c = 15 ; white :
22658: LD_ADDR_VAR 0 5
22662: PUSH
22663: LD_INT 15
22665: ST_TO_ADDR
22666: GO 22688
22668: LD_STRING white
22670: DOUBLE
22671: EQUAL
22672: IFTRUE 22676
22674: GO 22687
22676: POP
// c = 16 ; end ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_INT 16
22684: ST_TO_ADDR
22685: GO 22688
22687: POP
// if HexInfo ( x , y ) = 0 then
22688: LD_VAR 0 1
22692: PPUSH
22693: LD_VAR 0 2
22697: PPUSH
22698: CALL_OW 428
22702: PUSH
22703: LD_INT 0
22705: EQUAL
22706: IFFALSE 22730
// PlaceEnvironment ( x , y , 58 , c ) ;
22708: LD_VAR 0 1
22712: PPUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: LD_INT 58
22720: PPUSH
22721: LD_VAR 0 5
22725: PPUSH
22726: CALL_OW 349
// end ;
22730: LD_VAR 0 4
22734: RET
// export function MCT_RemovePlace ( x , y ) ; begin
22735: LD_INT 0
22737: PPUSH
// RemoveEnvironment ( x , y ) ;
22738: LD_VAR 0 1
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: CALL_OW 347
// end ;
22752: LD_VAR 0 3
22756: RET
// export function MCT_Enemy ( side , x , y , dist ) ; begin
22757: LD_INT 0
22759: PPUSH
// result := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , dist ] ] ) ;
22760: LD_ADDR_VAR 0 5
22764: PUSH
22765: LD_INT 81
22767: PUSH
22768: LD_VAR 0 1
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: LD_INT 92
22779: PUSH
22780: LD_VAR 0 2
22784: PUSH
22785: LD_VAR 0 3
22789: PUSH
22790: LD_VAR 0 4
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 69
22809: ST_TO_ADDR
// end ;
22810: LD_VAR 0 5
22814: RET
// export function MCT_Retreat ( un ) ; var coord_dist , dir , x , y ; begin
22815: LD_INT 0
22817: PPUSH
22818: PPUSH
22819: PPUSH
22820: PPUSH
22821: PPUSH
// ComTurnUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) ;
22822: LD_VAR 0 1
22826: PPUSH
22827: LD_INT 81
22829: PUSH
22830: LD_VAR 0 1
22834: PPUSH
22835: CALL_OW 255
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: PPUSH
22844: CALL_OW 69
22848: PPUSH
22849: LD_VAR 0 1
22853: PPUSH
22854: CALL_OW 74
22858: PPUSH
22859: CALL_OW 119
// dir := GetDir ( un ) ;
22863: LD_ADDR_VAR 0 4
22867: PUSH
22868: LD_VAR 0 1
22872: PPUSH
22873: CALL_OW 254
22877: ST_TO_ADDR
// dir := dir - 3 ;
22878: LD_ADDR_VAR 0 4
22882: PUSH
22883: LD_VAR 0 4
22887: PUSH
22888: LD_INT 3
22890: MINUS
22891: ST_TO_ADDR
// if dir < 0 then
22892: LD_VAR 0 4
22896: PUSH
22897: LD_INT 0
22899: LESS
22900: IFFALSE 22916
// dir := dir + 6 ;
22902: LD_ADDR_VAR 0 4
22906: PUSH
22907: LD_VAR 0 4
22911: PUSH
22912: LD_INT 6
22914: PLUS
22915: ST_TO_ADDR
// while true do
22916: LD_INT 1
22918: IFFALSE 23415
// begin coord_dist := 3 ;
22920: LD_ADDR_VAR 0 3
22924: PUSH
22925: LD_INT 3
22927: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
22928: LD_ADDR_VAR 0 5
22932: PUSH
22933: LD_VAR 0 1
22937: PPUSH
22938: CALL_OW 250
22942: PPUSH
22943: LD_VAR 0 4
22947: PPUSH
22948: LD_VAR 0 3
22952: PPUSH
22953: CALL_OW 272
22957: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
22958: LD_ADDR_VAR 0 6
22962: PUSH
22963: LD_VAR 0 1
22967: PPUSH
22968: CALL_OW 251
22972: PPUSH
22973: LD_VAR 0 4
22977: PPUSH
22978: LD_VAR 0 3
22982: PPUSH
22983: CALL_OW 273
22987: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) or IsEnvironment ( x , y ) or ValidHex ( x , y ) = 0 or GetHexInfo ( x , y ) = 1 or HexInfo ( x , y ) <> 0 then
22988: LD_VAR 0 1
22992: PPUSH
22993: CALL_OW 255
22997: PPUSH
22998: LD_VAR 0 1
23002: PPUSH
23003: CALL_OW 250
23007: PPUSH
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 251
23017: PPUSH
23018: LD_INT 14
23020: PPUSH
23021: CALL 22757 0 4
23025: PUSH
23026: LD_VAR 0 5
23030: PPUSH
23031: LD_VAR 0 6
23035: PPUSH
23036: CALL_OW 351
23040: OR
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 6
23051: PPUSH
23052: CALL_OW 488
23056: PUSH
23057: LD_INT 0
23059: EQUAL
23060: OR
23061: PUSH
23062: LD_VAR 0 5
23066: PPUSH
23067: LD_VAR 0 6
23071: PPUSH
23072: CALL_OW 546
23076: PUSH
23077: LD_INT 1
23079: EQUAL
23080: OR
23081: PUSH
23082: LD_VAR 0 5
23086: PPUSH
23087: LD_VAR 0 6
23091: PPUSH
23092: CALL_OW 428
23096: PUSH
23097: LD_INT 0
23099: NONEQUAL
23100: OR
23101: IFFALSE 23329
// begin repeat begin Wait ( 0 0$0.3 ) ;
23103: LD_INT 10
23105: PPUSH
23106: CALL_OW 67
// coord_dist := coord_dist + 1 ;
23110: LD_ADDR_VAR 0 3
23114: PUSH
23115: LD_VAR 0 3
23119: PUSH
23120: LD_INT 1
23122: PLUS
23123: ST_TO_ADDR
// dir := dir + 1 ;
23124: LD_ADDR_VAR 0 4
23128: PUSH
23129: LD_VAR 0 4
23133: PUSH
23134: LD_INT 1
23136: PLUS
23137: ST_TO_ADDR
// if dir > 5 then
23138: LD_VAR 0 4
23142: PUSH
23143: LD_INT 5
23145: GREATER
23146: IFFALSE 23156
// dir = 0 ;
23148: LD_ADDR_VAR 0 4
23152: PUSH
23153: LD_INT 0
23155: ST_TO_ADDR
// x := ShiftX ( GetX ( un ) , dir , coord_dist ) ;
23156: LD_ADDR_VAR 0 5
23160: PUSH
23161: LD_VAR 0 1
23165: PPUSH
23166: CALL_OW 250
23170: PPUSH
23171: LD_VAR 0 4
23175: PPUSH
23176: LD_VAR 0 3
23180: PPUSH
23181: CALL_OW 272
23185: ST_TO_ADDR
// y := ShiftY ( GetY ( un ) , dir , coord_dist ) ;
23186: LD_ADDR_VAR 0 6
23190: PUSH
23191: LD_VAR 0 1
23195: PPUSH
23196: CALL_OW 251
23200: PPUSH
23201: LD_VAR 0 4
23205: PPUSH
23206: LD_VAR 0 3
23210: PPUSH
23211: CALL_OW 273
23215: ST_TO_ADDR
// end until not MCT_Enemy ( GetSide ( un ) , GetX ( un ) , GetY ( un ) , 14 ) and not IsEnvironment ( x , y ) and ValidHex ( x , y ) and GetHexInfo ( x , y ) = 0 and HexInfo ( x , y ) = 0 ;
23216: LD_VAR 0 1
23220: PPUSH
23221: CALL_OW 255
23225: PPUSH
23226: LD_VAR 0 1
23230: PPUSH
23231: CALL_OW 250
23235: PPUSH
23236: LD_VAR 0 1
23240: PPUSH
23241: CALL_OW 251
23245: PPUSH
23246: LD_INT 14
23248: PPUSH
23249: CALL 22757 0 4
23253: NOT
23254: PUSH
23255: LD_VAR 0 5
23259: PPUSH
23260: LD_VAR 0 6
23264: PPUSH
23265: CALL_OW 351
23269: NOT
23270: AND
23271: PUSH
23272: LD_VAR 0 5
23276: PPUSH
23277: LD_VAR 0 6
23281: PPUSH
23282: CALL_OW 488
23286: AND
23287: PUSH
23288: LD_VAR 0 5
23292: PPUSH
23293: LD_VAR 0 6
23297: PPUSH
23298: CALL_OW 546
23302: PUSH
23303: LD_INT 0
23305: EQUAL
23306: AND
23307: PUSH
23308: LD_VAR 0 5
23312: PPUSH
23313: LD_VAR 0 6
23317: PPUSH
23318: CALL_OW 428
23322: PUSH
23323: LD_INT 0
23325: EQUAL
23326: AND
23327: IFFALSE 23103
// end ; ComMoveXY ( un , x , y ) ;
23329: LD_VAR 0 1
23333: PPUSH
23334: LD_VAR 0 5
23338: PPUSH
23339: LD_VAR 0 6
23343: PPUSH
23344: CALL_OW 111
// Wait ( 0 0$1 ) ;
23348: LD_INT 35
23350: PPUSH
23351: CALL_OW 67
// if GetDistUnits ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( un ) ] ) , un ) ) >= 14 then
23355: LD_VAR 0 1
23359: PPUSH
23360: LD_INT 81
23362: PUSH
23363: LD_VAR 0 1
23367: PPUSH
23368: CALL_OW 255
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PPUSH
23377: CALL_OW 69
23381: PPUSH
23382: LD_VAR 0 1
23386: PPUSH
23387: CALL_OW 74
23391: PPUSH
23392: CALL_OW 296
23396: PUSH
23397: LD_INT 14
23399: GREATEREQUAL
23400: IFFALSE 23413
// begin ComStop ( un ) ;
23402: LD_VAR 0 1
23406: PPUSH
23407: CALL_OW 141
// break ;
23411: GO 23415
// end ; end ;
23413: GO 22916
// end ;
23415: LD_VAR 0 2
23419: RET
// export function MCT_FindNewPath ( unit ) ; var x , y , x2 , y2 , dir , i , mode ; begin
23420: LD_INT 0
23422: PPUSH
23423: PPUSH
23424: PPUSH
23425: PPUSH
23426: PPUSH
23427: PPUSH
23428: PPUSH
23429: PPUSH
// x := GetX ( unit ) ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_VAR 0 1
23439: PPUSH
23440: CALL_OW 250
23444: ST_TO_ADDR
// y := GetY ( unit ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: CALL_OW 251
23459: ST_TO_ADDR
// i := 0 ;
23460: LD_ADDR_VAR 0 8
23464: PUSH
23465: LD_INT 0
23467: ST_TO_ADDR
// ComTurnUnit ( unit , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ) ;
23468: LD_VAR 0 1
23472: PPUSH
23473: LD_INT 81
23475: PUSH
23476: LD_VAR 0 1
23480: PPUSH
23481: CALL_OW 255
23485: PUSH
23486: EMPTY
23487: LIST
23488: LIST
23489: PPUSH
23490: CALL_OW 69
23494: PPUSH
23495: LD_VAR 0 1
23499: PPUSH
23500: CALL_OW 74
23504: PPUSH
23505: CALL_OW 119
// dir := GetDir ( unit ) ;
23509: LD_ADDR_VAR 0 7
23513: PUSH
23514: LD_VAR 0 1
23518: PPUSH
23519: CALL_OW 254
23523: ST_TO_ADDR
// mode := Rand ( 0 , 1 ) ;
23524: LD_ADDR_VAR 0 9
23528: PUSH
23529: LD_INT 0
23531: PPUSH
23532: LD_INT 1
23534: PPUSH
23535: CALL_OW 12
23539: ST_TO_ADDR
// repeat begin Wait ( 0 0$0.3 ) ;
23540: LD_INT 10
23542: PPUSH
23543: CALL_OW 67
// if mode then
23547: LD_VAR 0 9
23551: IFFALSE 23569
// dir := dir + 1 else
23553: LD_ADDR_VAR 0 7
23557: PUSH
23558: LD_VAR 0 7
23562: PUSH
23563: LD_INT 1
23565: PLUS
23566: ST_TO_ADDR
23567: GO 23583
// dir := dir - 1 ;
23569: LD_ADDR_VAR 0 7
23573: PUSH
23574: LD_VAR 0 7
23578: PUSH
23579: LD_INT 1
23581: MINUS
23582: ST_TO_ADDR
// if ( dir < 0 ) then
23583: LD_VAR 0 7
23587: PUSH
23588: LD_INT 0
23590: LESS
23591: IFFALSE 23601
// dir := 5 ;
23593: LD_ADDR_VAR 0 7
23597: PUSH
23598: LD_INT 5
23600: ST_TO_ADDR
// if ( dir > 5 ) then
23601: LD_VAR 0 7
23605: PUSH
23606: LD_INT 5
23608: GREATER
23609: IFFALSE 23619
// dir := 0 ;
23611: LD_ADDR_VAR 0 7
23615: PUSH
23616: LD_INT 0
23618: ST_TO_ADDR
// x2 := ShiftX ( x , dir , 4 ) ;
23619: LD_ADDR_VAR 0 5
23623: PUSH
23624: LD_VAR 0 3
23628: PPUSH
23629: LD_VAR 0 7
23633: PPUSH
23634: LD_INT 4
23636: PPUSH
23637: CALL_OW 272
23641: ST_TO_ADDR
// y2 := ShiftY ( y , dir , 4 ) ;
23642: LD_ADDR_VAR 0 6
23646: PUSH
23647: LD_VAR 0 4
23651: PPUSH
23652: LD_VAR 0 7
23656: PPUSH
23657: LD_INT 4
23659: PPUSH
23660: CALL_OW 273
23664: ST_TO_ADDR
// i := i + 1 ;
23665: LD_ADDR_VAR 0 8
23669: PUSH
23670: LD_VAR 0 8
23674: PUSH
23675: LD_INT 1
23677: PLUS
23678: ST_TO_ADDR
// if MCT_Enemy ( GetSide ( unit ) , x2 , y2 , 14 ) = false and GetHexInfo ( x2 , y2 ) = 0 and HexInfo ( x2 , y2 ) = 0 then
23679: LD_VAR 0 1
23683: PPUSH
23684: CALL_OW 255
23688: PPUSH
23689: LD_VAR 0 5
23693: PPUSH
23694: LD_VAR 0 6
23698: PPUSH
23699: LD_INT 14
23701: PPUSH
23702: CALL 22757 0 4
23706: PUSH
23707: LD_INT 0
23709: EQUAL
23710: PUSH
23711: LD_VAR 0 5
23715: PPUSH
23716: LD_VAR 0 6
23720: PPUSH
23721: CALL_OW 546
23725: PUSH
23726: LD_INT 0
23728: EQUAL
23729: AND
23730: PUSH
23731: LD_VAR 0 5
23735: PPUSH
23736: LD_VAR 0 6
23740: PPUSH
23741: CALL_OW 428
23745: PUSH
23746: LD_INT 0
23748: EQUAL
23749: AND
23750: IFFALSE 23754
// break ;
23752: GO 23764
// end until i > 4 ;
23754: LD_VAR 0 8
23758: PUSH
23759: LD_INT 4
23761: GREATER
23762: IFFALSE 23540
// if x2 and y2 then
23764: LD_VAR 0 5
23768: PUSH
23769: LD_VAR 0 6
23773: AND
23774: IFFALSE 23797
// result := [ x2 , y2 ] else
23776: LD_ADDR_VAR 0 2
23780: PUSH
23781: LD_VAR 0 5
23785: PUSH
23786: LD_VAR 0 6
23790: PUSH
23791: EMPTY
23792: LIST
23793: LIST
23794: ST_TO_ADDR
23795: GO 23826
// result := [ GetX ( unit ) , GetY ( unit ) ] ;
23797: LD_ADDR_VAR 0 2
23801: PUSH
23802: LD_VAR 0 1
23806: PPUSH
23807: CALL_OW 250
23811: PUSH
23812: LD_VAR 0 1
23816: PPUSH
23817: CALL_OW 251
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: ST_TO_ADDR
// end ;
23826: LD_VAR 0 2
23830: RET
// export function MCT_Hex ( x , y ) ; begin
23831: LD_INT 0
23833: PPUSH
// result := [ GetHexInfo ( x , y ) , [ HexInfo ( x , y ) ] ] ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_VAR 0 1
23843: PPUSH
23844: LD_VAR 0 2
23848: PPUSH
23849: CALL_OW 546
23853: PUSH
23854: LD_VAR 0 1
23858: PPUSH
23859: LD_VAR 0 2
23863: PPUSH
23864: CALL_OW 428
23868: PUSH
23869: EMPTY
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: ST_TO_ADDR
// end ;
23876: LD_VAR 0 3
23880: RET
// export function MCT_CollectCrates ( side ) ; var i , j , x , y , z , t1 , t2 , mode , areas , collectors , is_cargo , debug_time ; begin
23881: LD_INT 0
23883: PPUSH
23884: PPUSH
23885: PPUSH
23886: PPUSH
23887: PPUSH
23888: PPUSH
23889: PPUSH
23890: PPUSH
23891: PPUSH
23892: PPUSH
23893: PPUSH
23894: PPUSH
23895: PPUSH
// mode := MREG_Collect [ side ] [ 1 ] ;
23896: LD_ADDR_VAR 0 10
23900: PUSH
23901: LD_EXP 62
23905: PUSH
23906: LD_VAR 0 1
23910: ARRAY
23911: PUSH
23912: LD_INT 1
23914: ARRAY
23915: ST_TO_ADDR
// areas := MREG_Collect [ side ] [ 2 ] ;
23916: LD_ADDR_VAR 0 11
23920: PUSH
23921: LD_EXP 62
23925: PUSH
23926: LD_VAR 0 1
23930: ARRAY
23931: PUSH
23932: LD_INT 2
23934: ARRAY
23935: ST_TO_ADDR
// collectors := [ ] ;
23936: LD_ADDR_VAR 0 12
23940: PUSH
23941: EMPTY
23942: ST_TO_ADDR
// is_cargo := false ;
23943: LD_ADDR_VAR 0 13
23947: PUSH
23948: LD_INT 0
23950: ST_TO_ADDR
// if isTest then
23951: LD_EXP 1
23955: IFFALSE 23961
// TimerStart ( ) ;
23957: CALL_OW 548
// if MCF_Cargo ( side ) then
23961: LD_VAR 0 1
23965: PPUSH
23966: CALL 11938 0 1
23970: IFFALSE 23997
// begin collectors := MCF_Cargo ( side ) ;
23972: LD_ADDR_VAR 0 12
23976: PUSH
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL 11938 0 1
23986: ST_TO_ADDR
// is_cargo := true ;
23987: LD_ADDR_VAR 0 13
23991: PUSH
23992: LD_INT 1
23994: ST_TO_ADDR
// end else
23995: GO 24146
// begin if MCF_ApeSpec ( side , engineer ) then
23997: LD_VAR 0 1
24001: PPUSH
24002: LD_STRING engineer
24004: PPUSH
24005: CALL 12084 0 2
24009: IFFALSE 24029
// collectors := MCF_ApeSpec ( side , engineer ) ;
24011: LD_ADDR_VAR 0 12
24015: PUSH
24016: LD_VAR 0 1
24020: PPUSH
24021: LD_STRING engineer
24023: PPUSH
24024: CALL 12084 0 2
24028: ST_TO_ADDR
// if MCF_Class ( side , 2 , [ ] ) then
24029: LD_VAR 0 1
24033: PPUSH
24034: LD_INT 2
24036: PPUSH
24037: EMPTY
24038: PPUSH
24039: CALL 11670 0 3
24043: IFFALSE 24146
// begin z := MCF_Class ( side , 2 , [ ] ) ;
24045: LD_ADDR_VAR 0 7
24049: PUSH
24050: LD_VAR 0 1
24054: PPUSH
24055: LD_INT 2
24057: PPUSH
24058: EMPTY
24059: PPUSH
24060: CALL 11670 0 3
24064: ST_TO_ADDR
// if z > 5 then
24065: LD_VAR 0 7
24069: PUSH
24070: LD_INT 5
24072: GREATER
24073: IFFALSE 24085
// t1 := 5 else
24075: LD_ADDR_VAR 0 8
24079: PUSH
24080: LD_INT 5
24082: ST_TO_ADDR
24083: GO 24095
// t1 := z ;
24085: LD_ADDR_VAR 0 8
24089: PUSH
24090: LD_VAR 0 7
24094: ST_TO_ADDR
// for t2 = 1 to t1 do
24095: LD_ADDR_VAR 0 9
24099: PUSH
24100: DOUBLE
24101: LD_INT 1
24103: DEC
24104: ST_TO_ADDR
24105: LD_VAR 0 8
24109: PUSH
24110: FOR_TO
24111: IFFALSE 24144
// collectors := Insert ( collectors , 1 , z [ t2 ] ) ;
24113: LD_ADDR_VAR 0 12
24117: PUSH
24118: LD_VAR 0 12
24122: PPUSH
24123: LD_INT 1
24125: PPUSH
24126: LD_VAR 0 7
24130: PUSH
24131: LD_VAR 0 9
24135: ARRAY
24136: PPUSH
24137: CALL_OW 2
24141: ST_TO_ADDR
24142: GO 24110
24144: POP
24145: POP
// end ; end ; if not mode then
24146: LD_VAR 0 10
24150: NOT
24151: IFFALSE 24157
// exit else
24153: GO 24416
24155: GO 24416
// begin if collectors then
24157: LD_VAR 0 12
24161: IFFALSE 24416
// for i in areas do
24163: LD_ADDR_VAR 0 3
24167: PUSH
24168: LD_VAR 0 11
24172: PUSH
24173: FOR_IN
24174: IFFALSE 24414
// if GetListOfCratesInArea ( i ) then
24176: LD_VAR 0 3
24180: PPUSH
24181: CALL_OW 435
24185: IFFALSE 24412
// begin x := GetListOfCratesInArea ( i ) [ 1 ] ;
24187: LD_ADDR_VAR 0 5
24191: PUSH
24192: LD_VAR 0 3
24196: PPUSH
24197: CALL_OW 435
24201: PUSH
24202: LD_INT 1
24204: ARRAY
24205: ST_TO_ADDR
// y := GetListOfCratesInArea ( i ) [ 2 ] ;
24206: LD_ADDR_VAR 0 6
24210: PUSH
24211: LD_VAR 0 3
24215: PPUSH
24216: CALL_OW 435
24220: PUSH
24221: LD_INT 2
24223: ARRAY
24224: ST_TO_ADDR
// if is_cargo and GetTag ( collectors [ 1 ] ) = 0 then
24225: LD_VAR 0 13
24229: PUSH
24230: LD_VAR 0 12
24234: PUSH
24235: LD_INT 1
24237: ARRAY
24238: PPUSH
24239: CALL_OW 110
24243: PUSH
24244: LD_INT 0
24246: EQUAL
24247: AND
24248: IFFALSE 24310
// begin if not HasTask ( collectors [ 1 ] ) and GetTag ( collectors [ 1 ] ) = 0 then
24250: LD_VAR 0 12
24254: PUSH
24255: LD_INT 1
24257: ARRAY
24258: PPUSH
24259: CALL_OW 314
24263: NOT
24264: PUSH
24265: LD_VAR 0 12
24269: PUSH
24270: LD_INT 1
24272: ARRAY
24273: PPUSH
24274: CALL_OW 110
24278: PUSH
24279: LD_INT 0
24281: EQUAL
24282: AND
24283: IFFALSE 24308
// begin ComCollect ( collectors [ 1 ] , x , y ) ;
24285: LD_VAR 0 12
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 5
24298: PPUSH
24299: LD_VAR 0 6
24303: PPUSH
24304: CALL_OW 117
// end ; end else
24308: GO 24396
// begin for j = 1 to collectors do
24310: LD_ADDR_VAR 0 4
24314: PUSH
24315: DOUBLE
24316: LD_INT 1
24318: DEC
24319: ST_TO_ADDR
24320: LD_VAR 0 12
24324: PUSH
24325: FOR_TO
24326: IFFALSE 24394
// if not HasTask ( collectors [ j ] ) and GetTag ( collectors [ j ] ) = 0 then
24328: LD_VAR 0 12
24332: PUSH
24333: LD_VAR 0 4
24337: ARRAY
24338: PPUSH
24339: CALL_OW 314
24343: NOT
24344: PUSH
24345: LD_VAR 0 12
24349: PUSH
24350: LD_VAR 0 4
24354: ARRAY
24355: PPUSH
24356: CALL_OW 110
24360: PUSH
24361: LD_INT 0
24363: EQUAL
24364: AND
24365: IFFALSE 24392
// begin MCT_Collect ( collectors [ j ] , x , y ) ;
24367: LD_VAR 0 12
24371: PUSH
24372: LD_VAR 0 4
24376: ARRAY
24377: PPUSH
24378: LD_VAR 0 5
24382: PPUSH
24383: LD_VAR 0 6
24387: PPUSH
24388: CALL 24787 0 3
// end ;
24392: GO 24325
24394: POP
24395: POP
// end ; if isTest then
24396: LD_EXP 1
24400: IFFALSE 24412
// begin debug_time := TimerEnd ( ) ;
24402: LD_ADDR_VAR 0 14
24406: PUSH
24407: CALL_OW 549
24411: ST_TO_ADDR
// end ; end ;
24412: GO 24173
24414: POP
24415: POP
// end ; end ;
24416: LD_VAR 0 2
24420: RET
// export function MCT_Crates ( area , amount , percent , interval , limit ) ; var cr , c , tmp , x , y ; begin
24421: LD_INT 0
24423: PPUSH
24424: PPUSH
24425: PPUSH
24426: PPUSH
24427: PPUSH
24428: PPUSH
// if not area then
24429: LD_VAR 0 1
24433: NOT
24434: IFFALSE 24440
// exit else
24436: GO 24702
24438: GO 24702
// if tick mod interval = 0 and Prob ( percent ) then
24440: LD_OWVAR 1
24444: PUSH
24445: LD_VAR 0 4
24449: MOD
24450: PUSH
24451: LD_INT 0
24453: EQUAL
24454: PUSH
24455: LD_VAR 0 3
24459: PPUSH
24460: CALL_OW 13
24464: AND
24465: IFFALSE 24702
// begin if GetListOfCratesInArea ( area ) < limit or limit = 0 then
24467: LD_VAR 0 1
24471: PPUSH
24472: CALL_OW 435
24476: PUSH
24477: LD_VAR 0 5
24481: LESS
24482: PUSH
24483: LD_VAR 0 5
24487: PUSH
24488: LD_INT 0
24490: EQUAL
24491: OR
24492: IFFALSE 24702
// begin Randomize ;
24494: CALL_OW 10
// cr := Rand ( 1 , amount ) ;
24498: LD_ADDR_VAR 0 7
24502: PUSH
24503: LD_INT 1
24505: PPUSH
24506: LD_VAR 0 2
24510: PPUSH
24511: CALL_OW 12
24515: ST_TO_ADDR
// tmp := AreaToList ( area , 0 ) ;
24516: LD_ADDR_VAR 0 9
24520: PUSH
24521: LD_VAR 0 1
24525: PPUSH
24526: LD_INT 0
24528: PPUSH
24529: CALL_OW 517
24533: ST_TO_ADDR
// c := Rand ( 1 , tmp [ 1 ] ) ;
24534: LD_ADDR_VAR 0 8
24538: PUSH
24539: LD_INT 1
24541: PPUSH
24542: LD_VAR 0 9
24546: PUSH
24547: LD_INT 1
24549: ARRAY
24550: PPUSH
24551: CALL_OW 12
24555: ST_TO_ADDR
// while ( HexInfo ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 and GetResourceAmountXY ( tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] ) > 0 ) do
24556: LD_VAR 0 9
24560: PUSH
24561: LD_INT 1
24563: ARRAY
24564: PUSH
24565: LD_VAR 0 8
24569: ARRAY
24570: PPUSH
24571: LD_VAR 0 9
24575: PUSH
24576: LD_INT 2
24578: ARRAY
24579: PUSH
24580: LD_VAR 0 8
24584: ARRAY
24585: PPUSH
24586: CALL_OW 428
24590: PUSH
24591: LD_INT 0
24593: GREATER
24594: PUSH
24595: LD_VAR 0 9
24599: PUSH
24600: LD_INT 1
24602: ARRAY
24603: PUSH
24604: LD_VAR 0 8
24608: ARRAY
24609: PPUSH
24610: LD_VAR 0 9
24614: PUSH
24615: LD_INT 2
24617: ARRAY
24618: PUSH
24619: LD_VAR 0 8
24623: ARRAY
24624: PPUSH
24625: CALL_OW 284
24629: PUSH
24630: LD_INT 0
24632: GREATER
24633: AND
24634: IFFALSE 24660
// c := Rand ( 1 , tmp [ 1 ] ) ;
24636: LD_ADDR_VAR 0 8
24640: PUSH
24641: LD_INT 1
24643: PPUSH
24644: LD_VAR 0 9
24648: PUSH
24649: LD_INT 1
24651: ARRAY
24652: PPUSH
24653: CALL_OW 12
24657: ST_TO_ADDR
24658: GO 24556
// CreateCratesXY ( cr , tmp [ 1 ] [ c ] , tmp [ 2 ] [ c ] , true ) ;
24660: LD_VAR 0 7
24664: PPUSH
24665: LD_VAR 0 9
24669: PUSH
24670: LD_INT 1
24672: ARRAY
24673: PUSH
24674: LD_VAR 0 8
24678: ARRAY
24679: PPUSH
24680: LD_VAR 0 9
24684: PUSH
24685: LD_INT 2
24687: ARRAY
24688: PUSH
24689: LD_VAR 0 8
24693: ARRAY
24694: PPUSH
24695: LD_INT 1
24697: PPUSH
24698: CALL_OW 54
// end ; end ; end ;
24702: LD_VAR 0 6
24706: RET
// export function MCT_UpdateCratesList ( ) ; var i ; begin
24707: LD_INT 0
24709: PPUSH
24710: PPUSH
// if not MREG_Crates then
24711: LD_EXP 36
24715: NOT
24716: IFFALSE 24720
// exit ;
24718: GO 24782
// for i = MREG_Crates downto 1 do
24720: LD_ADDR_VAR 0 2
24724: PUSH
24725: DOUBLE
24726: LD_EXP 36
24730: INC
24731: ST_TO_ADDR
24732: LD_INT 1
24734: PUSH
24735: FOR_DOWNTO
24736: IFFALSE 24780
// if MREG_Crates [ i ] [ 3 ] = 0 then
24738: LD_EXP 36
24742: PUSH
24743: LD_VAR 0 2
24747: ARRAY
24748: PUSH
24749: LD_INT 3
24751: ARRAY
24752: PUSH
24753: LD_INT 0
24755: EQUAL
24756: IFFALSE 24778
// MREG_Crates := Delete ( MREG_Crates , i ) ;
24758: LD_ADDR_EXP 36
24762: PUSH
24763: LD_EXP 36
24767: PPUSH
24768: LD_VAR 0 2
24772: PPUSH
24773: CALL_OW 3
24777: ST_TO_ADDR
24778: GO 24735
24780: POP
24781: POP
// end ;
24782: LD_VAR 0 1
24786: RET
// export function MCT_Collect ( unit , x , y ) ; var i , side , dep ; begin
24787: LD_INT 0
24789: PPUSH
24790: PPUSH
24791: PPUSH
24792: PPUSH
// if not unit then
24793: LD_VAR 0 1
24797: NOT
24798: IFFALSE 24802
// exit ;
24800: GO 24937
// if HasTask ( unit ) or not CanCarry ( unit ) then
24802: LD_VAR 0 1
24806: PPUSH
24807: CALL_OW 314
24811: PUSH
24812: LD_VAR 0 1
24816: PPUSH
24817: CALL_OW 280
24821: NOT
24822: OR
24823: IFFALSE 24827
// exit ;
24825: GO 24937
// side := GetSide ( unit ) ;
24827: LD_ADDR_VAR 0 6
24831: PUSH
24832: LD_VAR 0 1
24836: PPUSH
24837: CALL_OW 255
24841: ST_TO_ADDR
// dep := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
24842: LD_ADDR_VAR 0 7
24846: PUSH
24847: LD_VAR 0 6
24851: PPUSH
24852: LD_INT 30
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PPUSH
24862: CALL 11587 0 2
24866: ST_TO_ADDR
// if Carry ( unit ) or not dep then
24867: LD_VAR 0 1
24871: PPUSH
24872: CALL_OW 281
24876: PUSH
24877: LD_VAR 0 7
24881: NOT
24882: OR
24883: IFFALSE 24889
// exit else
24885: GO 24937
24887: GO 24937
// if GetResourceAmountXY ( x , y ) then
24889: LD_VAR 0 2
24893: PPUSH
24894: LD_VAR 0 3
24898: PPUSH
24899: CALL_OW 284
24903: IFFALSE 24935
// begin ComTake ( unit , x , y , dep [ 1 ] ) ;
24905: LD_VAR 0 1
24909: PPUSH
24910: LD_VAR 0 2
24914: PPUSH
24915: LD_VAR 0 3
24919: PPUSH
24920: LD_VAR 0 7
24924: PUSH
24925: LD_INT 1
24927: ARRAY
24928: PPUSH
24929: CALL 31983 0 4
// end else
24933: GO 24937
// exit ;
24935: GO 24937
// end ;
24937: LD_VAR 0 4
24941: RET
// export function MCT_EnemyNearBase ( side ) ; var i , p , tmp , area ; begin
24942: LD_INT 0
24944: PPUSH
24945: PPUSH
24946: PPUSH
24947: PPUSH
24948: PPUSH
// result := [ ] ;
24949: LD_ADDR_VAR 0 2
24953: PUSH
24954: EMPTY
24955: ST_TO_ADDR
// p := 1 ;
24956: LD_ADDR_VAR 0 4
24960: PUSH
24961: LD_INT 1
24963: ST_TO_ADDR
// for i = 1 to ( MREG_DefPoints [ side ] [ 1 ] ) / 2 do
24964: LD_ADDR_VAR 0 3
24968: PUSH
24969: DOUBLE
24970: LD_INT 1
24972: DEC
24973: ST_TO_ADDR
24974: LD_EXP 65
24978: PUSH
24979: LD_VAR 0 1
24983: ARRAY
24984: PUSH
24985: LD_INT 1
24987: ARRAY
24988: PUSH
24989: LD_INT 2
24991: DIVREAL
24992: PUSH
24993: FOR_TO
24994: IFFALSE 25118
// begin tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , MREG_DefPoints [ side ] [ 1 ] [ p ] , MREG_DefPoints [ side ] [ 1 ] [ p + 1 ] , 12 ] ] ) ;
24996: LD_ADDR_VAR 0 5
25000: PUSH
25001: LD_INT 81
25003: PUSH
25004: LD_VAR 0 1
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_INT 92
25015: PUSH
25016: LD_EXP 65
25020: PUSH
25021: LD_VAR 0 1
25025: ARRAY
25026: PUSH
25027: LD_INT 1
25029: ARRAY
25030: PUSH
25031: LD_VAR 0 4
25035: ARRAY
25036: PUSH
25037: LD_EXP 65
25041: PUSH
25042: LD_VAR 0 1
25046: ARRAY
25047: PUSH
25048: LD_INT 1
25050: ARRAY
25051: PUSH
25052: LD_VAR 0 4
25056: PUSH
25057: LD_INT 1
25059: PLUS
25060: ARRAY
25061: PUSH
25062: LD_INT 12
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: LIST
25069: LIST
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PPUSH
25075: CALL_OW 69
25079: ST_TO_ADDR
// if tmp then
25080: LD_VAR 0 5
25084: IFFALSE 25102
// result := result union tmp ;
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_VAR 0 2
25095: PUSH
25096: LD_VAR 0 5
25100: UNION
25101: ST_TO_ADDR
// p := p + 2 ;
25102: LD_ADDR_VAR 0 4
25106: PUSH
25107: LD_VAR 0 4
25111: PUSH
25112: LD_INT 2
25114: PLUS
25115: ST_TO_ADDR
// end ;
25116: GO 24993
25118: POP
25119: POP
// if FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) then
25120: LD_EXP 66
25124: PUSH
25125: LD_VAR 0 1
25129: ARRAY
25130: PPUSH
25131: LD_INT 81
25133: PUSH
25134: LD_VAR 0 1
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PPUSH
25143: CALL_OW 70
25147: IFFALSE 25188
// result := result union FilterUnitsInArea ( MREG_DefArea [ side ] , [ f_enemy , side ] ) ;
25149: LD_ADDR_VAR 0 2
25153: PUSH
25154: LD_VAR 0 2
25158: PUSH
25159: LD_EXP 66
25163: PUSH
25164: LD_VAR 0 1
25168: ARRAY
25169: PPUSH
25170: LD_INT 81
25172: PUSH
25173: LD_VAR 0 1
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PPUSH
25182: CALL_OW 70
25186: UNION
25187: ST_TO_ADDR
// end ; end_of_file
25188: LD_VAR 0 2
25192: RET
// export function MCV_Cost ( fac , list ) ; var cost , pom ; begin
25193: LD_INT 0
25195: PPUSH
25196: PPUSH
25197: PPUSH
// pom := GetBase ( fac ) ;
25198: LD_ADDR_VAR 0 5
25202: PUSH
25203: LD_VAR 0 1
25207: PPUSH
25208: CALL_OW 274
25212: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25213: LD_ADDR_VAR 0 4
25217: PUSH
25218: LD_VAR 0 2
25222: PUSH
25223: LD_INT 1
25225: ARRAY
25226: PPUSH
25227: LD_VAR 0 2
25231: PUSH
25232: LD_INT 2
25234: ARRAY
25235: PPUSH
25236: LD_VAR 0 2
25240: PUSH
25241: LD_INT 3
25243: ARRAY
25244: PPUSH
25245: LD_VAR 0 2
25249: PUSH
25250: LD_INT 4
25252: ARRAY
25253: PPUSH
25254: CALL_OW 449
25258: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25259: LD_ADDR_VAR 0 3
25263: PUSH
25264: LD_VAR 0 5
25268: PPUSH
25269: LD_INT 1
25271: PPUSH
25272: CALL_OW 275
25276: PUSH
25277: LD_VAR 0 4
25281: PUSH
25282: LD_INT 1
25284: ARRAY
25285: GREATEREQUAL
25286: PUSH
25287: LD_VAR 0 5
25291: PPUSH
25292: LD_INT 2
25294: PPUSH
25295: CALL_OW 275
25299: PUSH
25300: LD_VAR 0 4
25304: PUSH
25305: LD_INT 2
25307: ARRAY
25308: GREATEREQUAL
25309: AND
25310: PUSH
25311: LD_VAR 0 5
25315: PPUSH
25316: LD_INT 3
25318: PPUSH
25319: CALL_OW 275
25323: PUSH
25324: LD_VAR 0 4
25328: PUSH
25329: LD_INT 3
25331: ARRAY
25332: GREATEREQUAL
25333: AND
25334: ST_TO_ADDR
// end ;
25335: LD_VAR 0 3
25339: RET
// export function MCV_InQueue ( side , component ) ; var tmp , i ; begin
25340: LD_INT 0
25342: PPUSH
25343: PPUSH
25344: PPUSH
// result := false ;
25345: LD_ADDR_VAR 0 3
25349: PUSH
25350: LD_INT 0
25352: ST_TO_ADDR
// tmp := MREG_ToConstruct [ side ] ;
25353: LD_ADDR_VAR 0 4
25357: PUSH
25358: LD_EXP 53
25362: PUSH
25363: LD_VAR 0 1
25367: ARRAY
25368: ST_TO_ADDR
// if tmp then
25369: LD_VAR 0 4
25373: IFFALSE 25427
// for i = 1 to tmp do
25375: LD_ADDR_VAR 0 5
25379: PUSH
25380: DOUBLE
25381: LD_INT 1
25383: DEC
25384: ST_TO_ADDR
25385: LD_VAR 0 4
25389: PUSH
25390: FOR_TO
25391: IFFALSE 25425
// if component = tmp [ i ] then
25393: LD_VAR 0 2
25397: PUSH
25398: LD_VAR 0 4
25402: PUSH
25403: LD_VAR 0 5
25407: ARRAY
25408: EQUAL
25409: IFFALSE 25423
// begin result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// exit ;
25419: POP
25420: POP
25421: GO 25427
// end ;
25423: GO 25390
25425: POP
25426: POP
// end ;
25427: LD_VAR 0 3
25431: RET
// export function MCV_Produce ( side , fac , list ) ; var i , tab ; begin
25432: LD_INT 0
25434: PPUSH
25435: PPUSH
25436: PPUSH
// result := false ;
25437: LD_ADDR_VAR 0 4
25441: PUSH
25442: LD_INT 0
25444: ST_TO_ADDR
// if fac then
25445: LD_VAR 0 2
25449: IFFALSE 25672
// begin if MCV_Cost ( fac , list ) and BuildingStatus ( fac ) = bs_idle and CanBeConstructed ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) then
25451: LD_VAR 0 2
25455: PPUSH
25456: LD_VAR 0 3
25460: PPUSH
25461: CALL 25193 0 2
25465: PUSH
25466: LD_VAR 0 2
25470: PPUSH
25471: CALL_OW 461
25475: PUSH
25476: LD_INT 2
25478: EQUAL
25479: AND
25480: PUSH
25481: LD_VAR 0 2
25485: PPUSH
25486: LD_VAR 0 3
25490: PUSH
25491: LD_INT 1
25493: ARRAY
25494: PPUSH
25495: LD_VAR 0 3
25499: PUSH
25500: LD_INT 2
25502: ARRAY
25503: PPUSH
25504: LD_VAR 0 3
25508: PUSH
25509: LD_INT 3
25511: ARRAY
25512: PPUSH
25513: LD_VAR 0 3
25517: PUSH
25518: LD_INT 4
25520: ARRAY
25521: PPUSH
25522: CALL_OW 448
25526: AND
25527: IFFALSE 25672
// begin ComConstruct ( fac , list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25529: LD_VAR 0 2
25533: PPUSH
25534: LD_VAR 0 3
25538: PUSH
25539: LD_INT 1
25541: ARRAY
25542: PPUSH
25543: LD_VAR 0 3
25547: PUSH
25548: LD_INT 2
25550: ARRAY
25551: PPUSH
25552: LD_VAR 0 3
25556: PUSH
25557: LD_INT 3
25559: ARRAY
25560: PPUSH
25561: LD_VAR 0 3
25565: PUSH
25566: LD_INT 4
25568: ARRAY
25569: PPUSH
25570: CALL_OW 125
// tab := MREG_ToConstruct [ side ] ;
25574: LD_ADDR_VAR 0 6
25578: PUSH
25579: LD_EXP 53
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: ST_TO_ADDR
// for i = 4 downto 1 do
25590: LD_ADDR_VAR 0 5
25594: PUSH
25595: DOUBLE
25596: LD_INT 4
25598: INC
25599: ST_TO_ADDR
25600: LD_INT 1
25602: PUSH
25603: FOR_DOWNTO
25604: IFFALSE 25637
// tab := Remove ( tab , list [ i ] , true ) ;
25606: LD_ADDR_VAR 0 6
25610: PUSH
25611: LD_VAR 0 6
25615: PPUSH
25616: LD_VAR 0 3
25620: PUSH
25621: LD_VAR 0 5
25625: ARRAY
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL 31211 0 3
25634: ST_TO_ADDR
25635: GO 25603
25637: POP
25638: POP
// MREG_ToConstruct := Replace ( MREG_ToConstruct , side , tab ) ;
25639: LD_ADDR_EXP 53
25643: PUSH
25644: LD_EXP 53
25648: PPUSH
25649: LD_VAR 0 1
25653: PPUSH
25654: LD_VAR 0 6
25658: PPUSH
25659: CALL_OW 1
25663: ST_TO_ADDR
// result := true ;
25664: LD_ADDR_VAR 0 4
25668: PUSH
25669: LD_INT 1
25671: ST_TO_ADDR
// end ; end ; end ;
25672: LD_VAR 0 4
25676: RET
// export function MCV_Parking ( side , veh ) ; var i ; begin
25677: LD_INT 0
25679: PPUSH
25680: PPUSH
// if not veh then
25681: LD_VAR 0 2
25685: NOT
25686: IFFALSE 25690
// exit ;
25688: GO 25864
// if MREG_Parking [ side ] then
25690: LD_EXP 60
25694: PUSH
25695: LD_VAR 0 1
25699: ARRAY
25700: IFFALSE 25864
// if not IsInArea ( veh , MREG_Parking [ side ] ) then
25702: LD_VAR 0 2
25706: PPUSH
25707: LD_EXP 60
25711: PUSH
25712: LD_VAR 0 1
25716: ARRAY
25717: PPUSH
25718: CALL_OW 308
25722: NOT
25723: IFFALSE 25864
// begin ComMoveToArea ( veh , MREG_Parking [ side ] ) ;
25725: LD_VAR 0 2
25729: PPUSH
25730: LD_EXP 60
25734: PUSH
25735: LD_VAR 0 1
25739: ARRAY
25740: PPUSH
25741: CALL_OW 113
// if GetControl ( veh ) = control_manual then
25745: LD_VAR 0 2
25749: PPUSH
25750: CALL_OW 263
25754: PUSH
25755: LD_INT 1
25757: EQUAL
25758: IFFALSE 25864
// begin i := GetDriver ( veh ) ;
25760: LD_ADDR_VAR 0 4
25764: PUSH
25765: LD_VAR 0 2
25769: PPUSH
25770: CALL 31695 0 1
25774: ST_TO_ADDR
// repeat Wait ( 0 0$01 ) ;
25775: LD_INT 35
25777: PPUSH
25778: CALL_OW 67
// until IsInArea ( veh , MREG_Parking [ side ] ) or IsDead ( veh ) ;
25782: LD_VAR 0 2
25786: PPUSH
25787: LD_EXP 60
25791: PUSH
25792: LD_VAR 0 1
25796: ARRAY
25797: PPUSH
25798: CALL_OW 308
25802: PUSH
25803: LD_VAR 0 2
25807: PPUSH
25808: CALL_OW 301
25812: OR
25813: IFFALSE 25775
// ComExitVehicle ( i ) ;
25815: LD_VAR 0 4
25819: PPUSH
25820: CALL_OW 121
// Wait ( 1 ) ;
25824: LD_INT 1
25826: PPUSH
25827: CALL_OW 67
// AddComEnterUnit ( i , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
25831: LD_VAR 0 4
25835: PPUSH
25836: LD_VAR 0 1
25840: PPUSH
25841: LD_INT 30
25843: PUSH
25844: LD_INT 3
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PPUSH
25851: CALL 11587 0 2
25855: PUSH
25856: LD_INT 1
25858: ARRAY
25859: PPUSH
25860: CALL_OW 180
// end ; end ; end ;
25864: LD_VAR 0 3
25868: RET
// export function MCV_Turret ( side ) ; var i , turret , weapon , x , y ; begin
25869: LD_INT 0
25871: PPUSH
25872: PPUSH
25873: PPUSH
25874: PPUSH
25875: PPUSH
25876: PPUSH
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
25877: LD_VAR 0 1
25881: PPUSH
25882: LD_INT 30
25884: PUSH
25885: LD_INT 3
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PPUSH
25892: CALL 11587 0 2
25896: IFFALSE 26080
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
25898: LD_VAR 0 1
25902: PPUSH
25903: LD_INT 30
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL 11587 0 2
25917: PUSH
25918: LD_INT 1
25920: ARRAY
25921: PPUSH
25922: CALL_OW 461
25926: PUSH
25927: LD_INT 2
25929: EQUAL
25930: IFFALSE 26080
// begin for i = 1 to MREG_TurretWeapon do
25932: LD_ADDR_VAR 0 3
25936: PUSH
25937: DOUBLE
25938: LD_INT 1
25940: DEC
25941: ST_TO_ADDR
25942: LD_EXP 45
25946: PUSH
25947: FOR_TO
25948: IFFALSE 26078
// if MREG_TurretWeapon [ i ] [ 1 ] = side then
25950: LD_EXP 45
25954: PUSH
25955: LD_VAR 0 3
25959: ARRAY
25960: PUSH
25961: LD_INT 1
25963: ARRAY
25964: PUSH
25965: LD_VAR 0 1
25969: EQUAL
25970: IFFALSE 26076
// begin weapon := MREG_TurretWeapon [ i ] [ 2 ] ;
25972: LD_ADDR_VAR 0 5
25976: PUSH
25977: LD_EXP 45
25981: PUSH
25982: LD_VAR 0 3
25986: ARRAY
25987: PUSH
25988: LD_INT 2
25990: ARRAY
25991: ST_TO_ADDR
// x := MREG_TurretWeapon [ i ] [ 3 ] [ 1 ] ;
25992: LD_ADDR_VAR 0 6
25996: PUSH
25997: LD_EXP 45
26001: PUSH
26002: LD_VAR 0 3
26006: ARRAY
26007: PUSH
26008: LD_INT 3
26010: ARRAY
26011: PUSH
26012: LD_INT 1
26014: ARRAY
26015: ST_TO_ADDR
// y := MREG_TurretWeapon [ i ] [ 3 ] [ 2 ] ;
26016: LD_ADDR_VAR 0 7
26020: PUSH
26021: LD_EXP 45
26025: PUSH
26026: LD_VAR 0 3
26030: ARRAY
26031: PUSH
26032: LD_INT 3
26034: ARRAY
26035: PUSH
26036: LD_INT 2
26038: ARRAY
26039: ST_TO_ADDR
// turret := HexInfo ( x , y ) ;
26040: LD_ADDR_VAR 0 4
26044: PUSH
26045: LD_VAR 0 6
26049: PPUSH
26050: LD_VAR 0 7
26054: PPUSH
26055: CALL_OW 428
26059: ST_TO_ADDR
// ComPlaceWeapon ( turret , weapon ) ;
26060: LD_VAR 0 4
26064: PPUSH
26065: LD_VAR 0 5
26069: PPUSH
26070: CALL_OW 148
// break ;
26074: GO 26078
// end ;
26076: GO 25947
26078: POP
26079: POP
// end ; end ;
26080: LD_VAR 0 2
26084: RET
// export function MCV_CheckFuel ( side ) ; var i , tmp , t ; begin
26085: LD_INT 0
26087: PPUSH
26088: PPUSH
26089: PPUSH
26090: PPUSH
// tmp := MCF_Get ( side , [ f_engine , engine_combustion ] ) ;
26091: LD_ADDR_VAR 0 4
26095: PUSH
26096: LD_VAR 0 1
26100: PPUSH
26101: LD_INT 32
26103: PUSH
26104: LD_INT 1
26106: PUSH
26107: EMPTY
26108: LIST
26109: LIST
26110: PPUSH
26111: CALL 11587 0 2
26115: ST_TO_ADDR
// if not tmp then
26116: LD_VAR 0 4
26120: NOT
26121: IFFALSE 26127
// exit else
26123: GO 26209
26125: GO 26209
// begin for i = 1 to tmp do
26127: LD_ADDR_VAR 0 3
26131: PUSH
26132: DOUBLE
26133: LD_INT 1
26135: DEC
26136: ST_TO_ADDR
26137: LD_VAR 0 4
26141: PUSH
26142: FOR_TO
26143: IFFALSE 26207
// if GetFuel ( tmp [ i ] ) < 20 and GetTag ( tmp [ i ] ) = 0 then
26145: LD_VAR 0 4
26149: PUSH
26150: LD_VAR 0 3
26154: ARRAY
26155: PPUSH
26156: CALL_OW 261
26160: PUSH
26161: LD_INT 20
26163: LESS
26164: PUSH
26165: LD_VAR 0 4
26169: PUSH
26170: LD_VAR 0 3
26174: ARRAY
26175: PPUSH
26176: CALL_OW 110
26180: PUSH
26181: LD_INT 0
26183: EQUAL
26184: AND
26185: IFFALSE 26205
// begin SetTag ( tmp [ i ] , 21 ) ;
26187: LD_VAR 0 4
26191: PUSH
26192: LD_VAR 0 3
26196: ARRAY
26197: PPUSH
26198: LD_INT 21
26200: PPUSH
26201: CALL_OW 109
// end ;
26205: GO 26142
26207: POP
26208: POP
// end ; end ;
26209: LD_VAR 0 2
26213: RET
// export function MCV_Refuel ( unit ) ; var side , i , b , c ; begin
26214: LD_INT 0
26216: PPUSH
26217: PPUSH
26218: PPUSH
26219: PPUSH
26220: PPUSH
// if not unit then
26221: LD_VAR 0 1
26225: NOT
26226: IFFALSE 26230
// exit ;
26228: GO 26418
// side := GetSide ( unit ) ;
26230: LD_ADDR_VAR 0 3
26234: PUSH
26235: LD_VAR 0 1
26239: PPUSH
26240: CALL_OW 255
26244: ST_TO_ADDR
// b := MCF_Get ( side , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_factory ] , [ f_btype , b_oil_mine ] ] ) ;
26245: LD_ADDR_VAR 0 5
26249: PUSH
26250: LD_VAR 0 3
26254: PPUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 3
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 30
26280: PUSH
26281: LD_INT 29
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: PPUSH
26294: CALL 11587 0 2
26298: ST_TO_ADDR
// if not b then
26299: LD_VAR 0 5
26303: NOT
26304: IFFALSE 26308
// exit ;
26306: GO 26418
// if GetTag ( unit ) = 21 then
26308: LD_VAR 0 1
26312: PPUSH
26313: CALL_OW 110
26317: PUSH
26318: LD_INT 21
26320: EQUAL
26321: IFFALSE 26418
// begin c := NearestUnitToUnit ( b , unit ) ;
26323: LD_ADDR_VAR 0 6
26327: PUSH
26328: LD_VAR 0 5
26332: PPUSH
26333: LD_VAR 0 1
26337: PPUSH
26338: CALL_OW 74
26342: ST_TO_ADDR
// if GetDistUnitXY ( unit , GetX ( c ) , GetY ( c ) ) > 6 then
26343: LD_VAR 0 1
26347: PPUSH
26348: LD_VAR 0 6
26352: PPUSH
26353: CALL_OW 250
26357: PPUSH
26358: LD_VAR 0 6
26362: PPUSH
26363: CALL_OW 251
26367: PPUSH
26368: CALL_OW 297
26372: PUSH
26373: LD_INT 6
26375: GREATER
26376: IFFALSE 26394
// ComMoveUnit ( unit , c ) else
26378: LD_VAR 0 1
26382: PPUSH
26383: LD_VAR 0 6
26387: PPUSH
26388: CALL_OW 112
26392: GO 26418
// begin SetFuel ( unit , 100 ) ;
26394: LD_VAR 0 1
26398: PPUSH
26399: LD_INT 100
26401: PPUSH
26402: CALL_OW 240
// SetTag ( unit , 0 ) ;
26406: LD_VAR 0 1
26410: PPUSH
26411: LD_INT 0
26413: PPUSH
26414: CALL_OW 109
// end ; end ; end ;
26418: LD_VAR 0 2
26422: RET
// export function MCV_RemoteControl ( side , nation ) ; var i , ct , oper , vehs , tmp ; begin
26423: LD_INT 0
26425: PPUSH
26426: PPUSH
26427: PPUSH
26428: PPUSH
26429: PPUSH
26430: PPUSH
// vehs := MCF_Get ( side , [ [ f_control , control_remote ] , [ f_not , [ f_linked ] ] ] ) ;
26431: LD_ADDR_VAR 0 7
26435: PUSH
26436: LD_VAR 0 1
26440: PPUSH
26441: LD_INT 33
26443: PUSH
26444: LD_INT 2
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 61
26456: PUSH
26457: EMPTY
26458: LIST
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PPUSH
26468: CALL 11587 0 2
26472: ST_TO_ADDR
// if not vehs then
26473: LD_VAR 0 7
26477: NOT
26478: IFFALSE 26482
// exit ;
26480: GO 26767
// if nation = 1 then
26482: LD_VAR 0 2
26486: PUSH
26487: LD_INT 1
26489: EQUAL
26490: IFFALSE 26660
// begin if not MCF_Get ( side , [ f_btype , b_control_tower ] ) then
26492: LD_VAR 0 1
26496: PPUSH
26497: LD_INT 30
26499: PUSH
26500: LD_INT 36
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL 11587 0 2
26511: NOT
26512: IFFALSE 26518
// exit else
26514: GO 26767
26516: GO 26658
// begin ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
26518: LD_ADDR_VAR 0 5
26522: PUSH
26523: LD_VAR 0 1
26527: PPUSH
26528: LD_INT 30
26530: PUSH
26531: LD_INT 36
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PPUSH
26538: CALL 11587 0 2
26542: ST_TO_ADDR
// oper := UnitsInside ( ct [ 1 ] ) ;
26543: LD_ADDR_VAR 0 6
26547: PUSH
26548: LD_VAR 0 5
26552: PUSH
26553: LD_INT 1
26555: ARRAY
26556: PPUSH
26557: CALL_OW 313
26561: ST_TO_ADDR
// for i = vehs downto 1 do
26562: LD_ADDR_VAR 0 4
26566: PUSH
26567: DOUBLE
26568: LD_VAR 0 7
26572: INC
26573: ST_TO_ADDR
26574: LD_INT 1
26576: PUSH
26577: FOR_DOWNTO
26578: IFFALSE 26656
// begin if not IsControledBy ( vehs [ i ] ) then
26580: LD_VAR 0 7
26584: PUSH
26585: LD_VAR 0 4
26589: ARRAY
26590: PPUSH
26591: CALL_OW 312
26595: NOT
26596: IFFALSE 26654
// begin tmp := MCV_RemoteDriver ( oper ) ;
26598: LD_ADDR_VAR 0 8
26602: PUSH
26603: LD_VAR 0 6
26607: PPUSH
26608: CALL 26772 0 1
26612: ST_TO_ADDR
// if not tmp then
26613: LD_VAR 0 8
26617: NOT
26618: IFFALSE 26626
// exit else
26620: POP
26621: POP
26622: GO 26767
26624: GO 26654
// ComLinkTo ( vehs [ i ] , tmp [ 1 ] [ 1 ] ) ;
26626: LD_VAR 0 7
26630: PUSH
26631: LD_VAR 0 4
26635: ARRAY
26636: PPUSH
26637: LD_VAR 0 8
26641: PUSH
26642: LD_INT 1
26644: ARRAY
26645: PUSH
26646: LD_INT 1
26648: ARRAY
26649: PPUSH
26650: CALL_OW 135
// end ; end ;
26654: GO 26577
26656: POP
26657: POP
// end ; end else
26658: GO 26767
// begin if not MCF_Get ( side , [ f_weapon , ar_control_tower ] ) then
26660: LD_VAR 0 1
26664: PPUSH
26665: LD_INT 34
26667: PUSH
26668: LD_INT 31
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PPUSH
26675: CALL 11587 0 2
26679: NOT
26680: IFFALSE 26686
// exit else
26682: GO 26767
26684: GO 26767
// begin ct := MCF_Get ( side , [ f_weapon , ar_control_tower ] ) ;
26686: LD_ADDR_VAR 0 5
26690: PUSH
26691: LD_VAR 0 1
26695: PPUSH
26696: LD_INT 34
26698: PUSH
26699: LD_INT 31
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PPUSH
26706: CALL 11587 0 2
26710: ST_TO_ADDR
// oper := [ ] ;
26711: LD_ADDR_VAR 0 6
26715: PUSH
26716: EMPTY
26717: ST_TO_ADDR
// for i = 1 to ct do
26718: LD_ADDR_VAR 0 4
26722: PUSH
26723: DOUBLE
26724: LD_INT 1
26726: DEC
26727: ST_TO_ADDR
26728: LD_VAR 0 5
26732: PUSH
26733: FOR_TO
26734: IFFALSE 26765
// oper := oper ^ GetDriver ( ct [ i ] ) ;
26736: LD_ADDR_VAR 0 6
26740: PUSH
26741: LD_VAR 0 6
26745: PUSH
26746: LD_VAR 0 5
26750: PUSH
26751: LD_VAR 0 4
26755: ARRAY
26756: PPUSH
26757: CALL 31695 0 1
26761: ADD
26762: ST_TO_ADDR
26763: GO 26733
26765: POP
26766: POP
// end ; end ; end ;
26767: LD_VAR 0 3
26771: RET
// export function MCV_RemoteDriver ( drivers ) ; var i , j , linked , m , l ; begin
26772: LD_INT 0
26774: PPUSH
26775: PPUSH
26776: PPUSH
26777: PPUSH
26778: PPUSH
26779: PPUSH
// if not drivers then
26780: LD_VAR 0 1
26784: NOT
26785: IFFALSE 26791
// exit else
26787: GO 27071
26789: GO 27071
// begin linked := [ ] ;
26791: LD_ADDR_VAR 0 5
26795: PUSH
26796: EMPTY
26797: ST_TO_ADDR
// for i = 1 to drivers do
26798: LD_ADDR_VAR 0 3
26802: PUSH
26803: DOUBLE
26804: LD_INT 1
26806: DEC
26807: ST_TO_ADDR
26808: LD_VAR 0 1
26812: PUSH
26813: FOR_TO
26814: IFFALSE 27059
// begin if CanControl ( drivers [ i ] ) then
26816: LD_VAR 0 1
26820: PUSH
26821: LD_VAR 0 3
26825: ARRAY
26826: PPUSH
26827: CALL 32085 0 1
26831: IFFALSE 27057
// if i > 1 then
26833: LD_VAR 0 3
26837: PUSH
26838: LD_INT 1
26840: GREATER
26841: IFFALSE 27018
// begin m := false ;
26843: LD_ADDR_VAR 0 6
26847: PUSH
26848: LD_INT 0
26850: ST_TO_ADDR
// l := UnitsLinked ( drivers [ i ] ) ;
26851: LD_ADDR_VAR 0 7
26855: PUSH
26856: LD_VAR 0 1
26860: PUSH
26861: LD_VAR 0 3
26865: ARRAY
26866: PPUSH
26867: CALL_OW 432
26871: ST_TO_ADDR
// for j = 1 to linked do
26872: LD_ADDR_VAR 0 4
26876: PUSH
26877: DOUBLE
26878: LD_INT 1
26880: DEC
26881: ST_TO_ADDR
26882: LD_VAR 0 5
26886: PUSH
26887: FOR_TO
26888: IFFALSE 26962
// begin if l < linked [ j ] [ 2 ] then
26890: LD_VAR 0 7
26894: PUSH
26895: LD_VAR 0 5
26899: PUSH
26900: LD_VAR 0 4
26904: ARRAY
26905: PUSH
26906: LD_INT 2
26908: ARRAY
26909: LESS
26910: IFFALSE 26960
// begin linked := Insert ( linked , 1 , [ drivers [ i ] , l ] ) ;
26912: LD_ADDR_VAR 0 5
26916: PUSH
26917: LD_VAR 0 5
26921: PPUSH
26922: LD_INT 1
26924: PPUSH
26925: LD_VAR 0 1
26929: PUSH
26930: LD_VAR 0 3
26934: ARRAY
26935: PUSH
26936: LD_VAR 0 7
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PPUSH
26945: CALL_OW 2
26949: ST_TO_ADDR
// m := true ;
26950: LD_ADDR_VAR 0 6
26954: PUSH
26955: LD_INT 1
26957: ST_TO_ADDR
// break ;
26958: GO 26962
// end ; end ;
26960: GO 26887
26962: POP
26963: POP
// if not m then
26964: LD_VAR 0 6
26968: NOT
26969: IFFALSE 27016
// linked := linked ^ [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
26971: LD_ADDR_VAR 0 5
26975: PUSH
26976: LD_VAR 0 5
26980: PUSH
26981: LD_VAR 0 1
26985: PUSH
26986: LD_VAR 0 3
26990: ARRAY
26991: PUSH
26992: LD_VAR 0 1
26996: PUSH
26997: LD_VAR 0 3
27001: ARRAY
27002: PPUSH
27003: CALL_OW 432
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: EMPTY
27013: LIST
27014: ADD
27015: ST_TO_ADDR
// end else
27016: GO 27057
// linked := [ [ drivers [ i ] , UnitsLinked ( drivers [ i ] ) ] ] ;
27018: LD_ADDR_VAR 0 5
27022: PUSH
27023: LD_VAR 0 1
27027: PUSH
27028: LD_VAR 0 3
27032: ARRAY
27033: PUSH
27034: LD_VAR 0 1
27038: PUSH
27039: LD_VAR 0 3
27043: ARRAY
27044: PPUSH
27045: CALL_OW 432
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: ST_TO_ADDR
// end ;
27057: GO 26813
27059: POP
27060: POP
// result := linked ;
27061: LD_ADDR_VAR 0 2
27065: PUSH
27066: LD_VAR 0 5
27070: ST_TO_ADDR
// end ; end ;
27071: LD_VAR 0 2
27075: RET
// export function MCV_ToRepair ( unit ) ; begin
27076: LD_INT 0
27078: PPUSH
// if not unit then
27079: LD_VAR 0 1
27083: NOT
27084: IFFALSE 27088
// exit ;
27086: GO 27119
// SetTag ( unit , 6 ) ;
27088: LD_VAR 0 1
27092: PPUSH
27093: LD_INT 6
27095: PPUSH
27096: CALL_OW 109
// MCV_Parking ( GetSide ( unit ) , unit ) ;
27100: LD_VAR 0 1
27104: PPUSH
27105: CALL_OW 255
27109: PPUSH
27110: LD_VAR 0 1
27114: PPUSH
27115: CALL 25677 0 2
// end ;
27119: LD_VAR 0 2
27123: RET
// export function MCV_CheckStatus ( side ) ; var i ; begin
27124: LD_INT 0
27126: PPUSH
27127: PPUSH
// if MCF_Tag ( side , 6 , [ ] ) then
27128: LD_VAR 0 1
27132: PPUSH
27133: LD_INT 6
27135: PPUSH
27136: EMPTY
27137: PPUSH
27138: CALL 12290 0 3
27142: IFFALSE 27235
// begin for i = MCF_Tag ( side , 6 , [ ] ) downto 1 do
27144: LD_ADDR_VAR 0 3
27148: PUSH
27149: DOUBLE
27150: LD_VAR 0 1
27154: PPUSH
27155: LD_INT 6
27157: PPUSH
27158: EMPTY
27159: PPUSH
27160: CALL 12290 0 3
27164: INC
27165: ST_TO_ADDR
27166: LD_INT 1
27168: PUSH
27169: FOR_DOWNTO
27170: IFFALSE 27233
// if GetLives ( MCF_Tag ( side , 6 , [ ] ) [ i ] ) = 1000 then
27172: LD_VAR 0 1
27176: PPUSH
27177: LD_INT 6
27179: PPUSH
27180: EMPTY
27181: PPUSH
27182: CALL 12290 0 3
27186: PUSH
27187: LD_VAR 0 3
27191: ARRAY
27192: PPUSH
27193: CALL_OW 256
27197: PUSH
27198: LD_INT 1000
27200: EQUAL
27201: IFFALSE 27231
// SetTag ( MCF_Tag ( side , 6 , [ ] ) [ i ] , 0 ) ;
27203: LD_VAR 0 1
27207: PPUSH
27208: LD_INT 6
27210: PPUSH
27211: EMPTY
27212: PPUSH
27213: CALL 12290 0 3
27217: PUSH
27218: LD_VAR 0 3
27222: ARRAY
27223: PPUSH
27224: LD_INT 0
27226: PPUSH
27227: CALL_OW 109
27231: GO 27169
27233: POP
27234: POP
// end ; if MCF_Tag ( side , 10 , [ ] ) then
27235: LD_VAR 0 1
27239: PPUSH
27240: LD_INT 10
27242: PPUSH
27243: EMPTY
27244: PPUSH
27245: CALL 12290 0 3
27249: IFFALSE 27366
// begin for i = MCF_Tag ( side , 10 , [ ] ) downto 1 do
27251: LD_ADDR_VAR 0 3
27255: PUSH
27256: DOUBLE
27257: LD_VAR 0 1
27261: PPUSH
27262: LD_INT 10
27264: PPUSH
27265: EMPTY
27266: PPUSH
27267: CALL 12290 0 3
27271: INC
27272: ST_TO_ADDR
27273: LD_INT 1
27275: PUSH
27276: FOR_DOWNTO
27277: IFFALSE 27364
// if not IsOk ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) or IsDead ( MCF_Tag ( side , 10 , [ ] ) [ i ] ) then
27279: LD_VAR 0 1
27283: PPUSH
27284: LD_INT 10
27286: PPUSH
27287: EMPTY
27288: PPUSH
27289: CALL 12290 0 3
27293: PUSH
27294: LD_VAR 0 3
27298: ARRAY
27299: PPUSH
27300: CALL_OW 302
27304: NOT
27305: PUSH
27306: LD_VAR 0 1
27310: PPUSH
27311: LD_INT 10
27313: PPUSH
27314: EMPTY
27315: PPUSH
27316: CALL 12290 0 3
27320: PUSH
27321: LD_VAR 0 3
27325: ARRAY
27326: PPUSH
27327: CALL_OW 301
27331: OR
27332: IFFALSE 27362
// SetTag ( MCF_Tag ( side , 10 , [ ] ) [ i ] , 0 ) ;
27334: LD_VAR 0 1
27338: PPUSH
27339: LD_INT 10
27341: PPUSH
27342: EMPTY
27343: PPUSH
27344: CALL 12290 0 3
27348: PUSH
27349: LD_VAR 0 3
27353: ARRAY
27354: PPUSH
27355: LD_INT 0
27357: PPUSH
27358: CALL_OW 109
27362: GO 27276
27364: POP
27365: POP
// end ; for i in MCF_Vehicle ( side , [ ] ) diff MCF_Tag ( side , 7 , [ ] ) do
27366: LD_ADDR_VAR 0 3
27370: PUSH
27371: LD_VAR 0 1
27375: PPUSH
27376: EMPTY
27377: PPUSH
27378: CALL 11888 0 2
27382: PUSH
27383: LD_VAR 0 1
27387: PPUSH
27388: LD_INT 7
27390: PPUSH
27391: EMPTY
27392: PPUSH
27393: CALL 12290 0 3
27397: DIFF
27398: PUSH
27399: FOR_IN
27400: IFFALSE 27444
// if GetLives ( i ) < 650 and not GetTag ( i ) = 6 then
27402: LD_VAR 0 3
27406: PPUSH
27407: CALL_OW 256
27411: PUSH
27412: LD_INT 650
27414: LESS
27415: PUSH
27416: LD_VAR 0 3
27420: PPUSH
27421: CALL_OW 110
27425: PUSH
27426: LD_INT 6
27428: EQUAL
27429: NOT
27430: AND
27431: IFFALSE 27442
// MCV_ToRepair ( i ) ;
27433: LD_VAR 0 3
27437: PPUSH
27438: CALL 27076 0 1
27442: GO 27399
27444: POP
27445: POP
// end ; end_of_file end_of_file
27446: LD_VAR 0 2
27450: RET
// on SailEvent ( event ) do begin LogEvent ( SAILEvent [ & event & ] ) ;
27451: LD_STRING SAILEvent [
27453: PUSH
27454: LD_VAR 0 1
27458: STR
27459: PUSH
27460: LD_STRING ]
27462: STR
27463: PPUSH
27464: CALL 7984 0 1
// if event = 101 and dialog_north then
27468: LD_VAR 0 1
27472: PUSH
27473: LD_INT 101
27475: EQUAL
27476: PUSH
27477: LD_EXP 6
27481: AND
27482: IFFALSE 27546
// begin dialog_north := false ;
27484: LD_ADDR_EXP 6
27488: PUSH
27489: LD_INT 0
27491: ST_TO_ADDR
// SayRadio ( Brown , [ DS1 , DS2 , DS3 , DS6 ] [ Rand ( 1 , 4 ) ] ) ;
27492: LD_EXP 5
27496: PPUSH
27497: LD_STRING DS1
27499: PUSH
27500: LD_STRING DS2
27502: PUSH
27503: LD_STRING DS3
27505: PUSH
27506: LD_STRING DS6
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: PUSH
27515: LD_INT 1
27517: PPUSH
27518: LD_INT 4
27520: PPUSH
27521: CALL_OW 12
27525: ARRAY
27526: PPUSH
27527: CALL_OW 94
// Wait ( 4 4$00 ) ;
27531: LD_INT 8400
27533: PPUSH
27534: CALL_OW 67
// dialog_north := true ;
27538: LD_ADDR_EXP 6
27542: PUSH
27543: LD_INT 1
27545: ST_TO_ADDR
// end ; if event = 102 and dialog_south then
27546: LD_VAR 0 1
27550: PUSH
27551: LD_INT 102
27553: EQUAL
27554: PUSH
27555: LD_EXP 7
27559: AND
27560: IFFALSE 27620
// begin dialog_south := false ;
27562: LD_ADDR_EXP 7
27566: PUSH
27567: LD_INT 0
27569: ST_TO_ADDR
// SayRadio ( Houten , [ DJ1 , DJ4 , DJ6 ] [ Rand ( 1 , 3 ) ] ) ;
27570: LD_EXP 4
27574: PPUSH
27575: LD_STRING DJ1
27577: PUSH
27578: LD_STRING DJ4
27580: PUSH
27581: LD_STRING DJ6
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PPUSH
27592: LD_INT 3
27594: PPUSH
27595: CALL_OW 12
27599: ARRAY
27600: PPUSH
27601: CALL_OW 94
// Wait ( 4 4$00 ) ;
27605: LD_INT 8400
27607: PPUSH
27608: CALL_OW 67
// dialog_south := true ;
27612: LD_ADDR_EXP 7
27616: PUSH
27617: LD_INT 1
27619: ST_TO_ADDR
// end ; if event = 104 and dialog_popov then
27620: LD_VAR 0 1
27624: PUSH
27625: LD_INT 104
27627: EQUAL
27628: PUSH
27629: LD_EXP 8
27633: AND
27634: IFFALSE 27656
// begin dialog_popov := false ;
27636: LD_ADDR_EXP 8
27640: PUSH
27641: LD_INT 0
27643: ST_TO_ADDR
// SayRadio ( Popov , DR4 ) ;
27644: LD_EXP 26
27648: PPUSH
27649: LD_STRING DR4
27651: PPUSH
27652: CALL_OW 94
// end ; end ;
27656: PPOPN 1
27658: END
// on BuildingStarted ( b , unit ) do var side , i ;
27659: LD_INT 0
27661: PPUSH
27662: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
27663: LD_EXP 41
27667: PUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 255
27677: ARRAY
27678: IFFALSE 27856
// begin LogEvent ( BuildingStarted [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ; unit:  & unit & ] ) ;
27680: LD_STRING BuildingStarted [side: 
27682: PUSH
27683: LD_VAR 0 1
27687: PPUSH
27688: CALL_OW 255
27692: STR
27693: PUSH
27694: LD_STRING ; btype: 
27696: STR
27697: PUSH
27698: LD_VAR 0 1
27702: PPUSH
27703: CALL_OW 266
27707: STR
27708: PUSH
27709: LD_STRING ; unit: 
27711: STR
27712: PUSH
27713: LD_VAR 0 2
27717: STR
27718: PUSH
27719: LD_STRING ]
27721: STR
27722: PPUSH
27723: CALL 7984 0 1
// side := GetSide ( b ) ;
27727: LD_ADDR_VAR 0 3
27731: PUSH
27732: LD_VAR 0 1
27736: PPUSH
27737: CALL_OW 255
27741: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
27742: LD_VAR 0 3
27746: PPUSH
27747: LD_INT 21
27749: PUSH
27750: LD_INT 3
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PPUSH
27757: CALL 11587 0 2
27761: PUSH
27762: LD_INT 1
27764: EQUAL
27765: IFFALSE 27856
// for i in MCF_Get ( side , [ f_type , unit_human ] ) diff MCF_Class ( side , 2 , [ ] ) do
27767: LD_ADDR_VAR 0 4
27771: PUSH
27772: LD_VAR 0 3
27776: PPUSH
27777: LD_INT 21
27779: PUSH
27780: LD_INT 1
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL 11587 0 2
27791: PUSH
27792: LD_VAR 0 3
27796: PPUSH
27797: LD_INT 2
27799: PPUSH
27800: EMPTY
27801: PPUSH
27802: CALL 11670 0 3
27806: DIFF
27807: PUSH
27808: FOR_IN
27809: IFFALSE 27854
// if not HasTask ( i ) then
27811: LD_VAR 0 4
27815: PPUSH
27816: CALL_OW 314
27820: NOT
27821: IFFALSE 27852
// ComMoveXY ( i , GetX ( b ) , GetY ( b ) ) ;
27823: LD_VAR 0 4
27827: PPUSH
27828: LD_VAR 0 1
27832: PPUSH
27833: CALL_OW 250
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 251
27847: PPUSH
27848: CALL_OW 111
27852: GO 27808
27854: POP
27855: POP
// end ;
27856: PPOPN 4
27858: END
// on BuildingComplete ( b ) do if MREG_SidesList [ GetSide ( b ) ] then
27859: LD_EXP 41
27863: PUSH
27864: LD_VAR 0 1
27868: PPUSH
27869: CALL_OW 255
27873: ARRAY
27874: IFFALSE 28243
// begin LogEvent ( BuildingComplete [side:  & GetSide ( b ) & ; btype:  & GetBType ( b ) & ] ) ;
27876: LD_STRING BuildingComplete [side: 
27878: PUSH
27879: LD_VAR 0 1
27883: PPUSH
27884: CALL_OW 255
27888: STR
27889: PUSH
27890: LD_STRING ; btype: 
27892: STR
27893: PUSH
27894: LD_VAR 0 1
27898: PPUSH
27899: CALL_OW 266
27903: STR
27904: PUSH
27905: LD_STRING ]
27907: STR
27908: PPUSH
27909: CALL 7984 0 1
// MREG_ToBuild := MC_RegistryDelete ( MREG_ToBuild , GetSide ( b ) , GetBType ( b ) , [ GetX ( b ) , GetY ( b ) , GetDir ( b ) ] ) ;
27913: LD_ADDR_EXP 48
27917: PUSH
27918: LD_EXP 48
27922: PPUSH
27923: LD_VAR 0 1
27927: PPUSH
27928: CALL_OW 255
27932: PPUSH
27933: LD_VAR 0 1
27937: PPUSH
27938: CALL_OW 266
27942: PPUSH
27943: LD_VAR 0 1
27947: PPUSH
27948: CALL_OW 250
27952: PUSH
27953: LD_VAR 0 1
27957: PPUSH
27958: CALL_OW 251
27962: PUSH
27963: LD_VAR 0 1
27967: PPUSH
27968: CALL_OW 254
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: PPUSH
27978: CALL 41973 0 4
27982: ST_TO_ADDR
// if GetBType ( b ) = b_lab then
27983: LD_VAR 0 1
27987: PPUSH
27988: CALL_OW 266
27992: PUSH
27993: LD_INT 6
27995: EQUAL
27996: IFFALSE 28030
// MREG_LabList := MC_RegistryUpdate ( MREG_LabList , GetSide ( b ) , b , [ ] ) ;
27998: LD_ADDR_EXP 42
28002: PUSH
28003: LD_EXP 42
28007: PPUSH
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 255
28017: PPUSH
28018: LD_VAR 0 1
28022: PPUSH
28023: EMPTY
28024: PPUSH
28025: CALL 41882 0 4
28029: ST_TO_ADDR
// if GetBType ( b ) = b_depot then
28030: LD_VAR 0 1
28034: PPUSH
28035: CALL_OW 266
28039: PUSH
28040: LD_INT 0
28042: EQUAL
28043: IFFALSE 28153
// begin MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_depot , [ ] ) ;
28045: LD_ADDR_EXP 50
28049: PUSH
28050: LD_EXP 50
28054: PPUSH
28055: LD_VAR 0 1
28059: PPUSH
28060: CALL_OW 255
28064: PPUSH
28065: LD_INT 0
28067: PPUSH
28068: EMPTY
28069: PPUSH
28070: CALL 41882 0 4
28074: ST_TO_ADDR
// SetResourceType ( GetBase ( b ) , 1 , MREG_ResourcesBonus [ 1 ] ) ;
28075: LD_VAR 0 1
28079: PPUSH
28080: CALL_OW 274
28084: PPUSH
28085: LD_INT 1
28087: PPUSH
28088: LD_EXP 74
28092: PUSH
28093: LD_INT 1
28095: ARRAY
28096: PPUSH
28097: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 2 , MREG_ResourcesBonus [ 2 ] ) ;
28101: LD_VAR 0 1
28105: PPUSH
28106: CALL_OW 274
28110: PPUSH
28111: LD_INT 2
28113: PPUSH
28114: LD_EXP 74
28118: PUSH
28119: LD_INT 2
28121: ARRAY
28122: PPUSH
28123: CALL_OW 277
// SetResourceType ( GetBase ( b ) , 3 , MREG_ResourcesBonus [ 3 ] ) ;
28127: LD_VAR 0 1
28131: PPUSH
28132: CALL_OW 274
28136: PPUSH
28137: LD_INT 3
28139: PPUSH
28140: LD_EXP 74
28144: PUSH
28145: LD_INT 3
28147: ARRAY
28148: PPUSH
28149: CALL_OW 277
// end ; if GetBType ( b ) = b_workshop then
28153: LD_VAR 0 1
28157: PPUSH
28158: CALL_OW 266
28162: PUSH
28163: LD_INT 2
28165: EQUAL
28166: IFFALSE 28198
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_workshop , [ ] ) ;
28168: LD_ADDR_EXP 50
28172: PUSH
28173: LD_EXP 50
28177: PPUSH
28178: LD_VAR 0 1
28182: PPUSH
28183: CALL_OW 255
28187: PPUSH
28188: LD_INT 2
28190: PPUSH
28191: EMPTY
28192: PPUSH
28193: CALL 41882 0 4
28197: ST_TO_ADDR
// if GetBType ( b ) = b_armoury then
28198: LD_VAR 0 1
28202: PPUSH
28203: CALL_OW 266
28207: PUSH
28208: LD_INT 4
28210: EQUAL
28211: IFFALSE 28243
// MREG_ToUpdate := MC_RegistryUpdate ( MREG_ToUpdate , GetSide ( b ) , b_armoury , [ ] ) ;
28213: LD_ADDR_EXP 50
28217: PUSH
28218: LD_EXP 50
28222: PPUSH
28223: LD_VAR 0 1
28227: PPUSH
28228: CALL_OW 255
28232: PPUSH
28233: LD_INT 4
28235: PPUSH
28236: EMPTY
28237: PPUSH
28238: CALL 41882 0 4
28242: ST_TO_ADDR
// end ;
28243: PPOPN 1
28245: END
// on ResearchComplete ( tech , lab ) do var i ;
28246: LD_INT 0
28248: PPUSH
// if MREG_SidesList [ GetSide ( lab ) ] then
28249: LD_EXP 41
28253: PUSH
28254: LD_VAR 0 2
28258: PPUSH
28259: CALL_OW 255
28263: ARRAY
28264: IFFALSE 28548
// begin LogEvent ( ResearchComplete [side:  & GetSide ( GetSide ( lab ) ) & ; tech: & tech & ] ) ;
28266: LD_STRING ResearchComplete [side: 
28268: PUSH
28269: LD_VAR 0 2
28273: PPUSH
28274: CALL_OW 255
28278: PPUSH
28279: CALL_OW 255
28283: STR
28284: PUSH
28285: LD_STRING ; tech:
28287: STR
28288: PUSH
28289: LD_VAR 0 1
28293: STR
28294: PUSH
28295: LD_STRING ]
28297: STR
28298: PPUSH
28299: CALL 7984 0 1
// for i = 1 to MREG_ToRes do
28303: LD_ADDR_VAR 0 3
28307: PUSH
28308: DOUBLE
28309: LD_INT 1
28311: DEC
28312: ST_TO_ADDR
28313: LD_EXP 52
28317: PUSH
28318: FOR_TO
28319: IFFALSE 28406
// if MREG_ToRes [ i ] [ 1 ] = GetSide ( lab ) and MREG_ToRes [ i ] [ 2 ] = tech then
28321: LD_EXP 52
28325: PUSH
28326: LD_VAR 0 3
28330: ARRAY
28331: PUSH
28332: LD_INT 1
28334: ARRAY
28335: PUSH
28336: LD_VAR 0 2
28340: PPUSH
28341: CALL_OW 255
28345: EQUAL
28346: PUSH
28347: LD_EXP 52
28351: PUSH
28352: LD_VAR 0 3
28356: ARRAY
28357: PUSH
28358: LD_INT 2
28360: ARRAY
28361: PUSH
28362: LD_VAR 0 1
28366: EQUAL
28367: AND
28368: IFFALSE 28404
// begin MREG_ToRes := MC_RegistryDelete ( MREG_ToRes , GetSide ( lab ) , tech , [ ] ) ;
28370: LD_ADDR_EXP 52
28374: PUSH
28375: LD_EXP 52
28379: PPUSH
28380: LD_VAR 0 2
28384: PPUSH
28385: CALL_OW 255
28389: PPUSH
28390: LD_VAR 0 1
28394: PPUSH
28395: EMPTY
28396: PPUSH
28397: CALL 41973 0 4
28401: ST_TO_ADDR
// break ;
28402: GO 28406
// end ;
28404: GO 28318
28406: POP
28407: POP
// if tech in [ tech_apepsych , tech_apeagres , tech_apebrain , tech_apeneural ] then
28408: LD_VAR 0 1
28412: PUSH
28413: LD_INT 2
28415: PUSH
28416: LD_INT 11
28418: PUSH
28419: LD_INT 4
28421: PUSH
28422: LD_INT 3
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: IN
28431: IFFALSE 28548
// begin i := MCF_Tag ( GetSide ( lab ) , 16 , [ f_class , 4 ] ) ;
28433: LD_ADDR_VAR 0 3
28437: PUSH
28438: LD_VAR 0 2
28442: PPUSH
28443: CALL_OW 255
28447: PPUSH
28448: LD_INT 16
28450: PPUSH
28451: LD_INT 25
28453: PUSH
28454: LD_INT 4
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PPUSH
28461: CALL 12290 0 3
28465: ST_TO_ADDR
// if i then
28466: LD_VAR 0 3
28470: IFFALSE 28488
// SetTag ( i [ 1 ] , 0 ) ;
28472: LD_VAR 0 3
28476: PUSH
28477: LD_INT 1
28479: ARRAY
28480: PPUSH
28481: LD_INT 0
28483: PPUSH
28484: CALL_OW 109
// i := MCF_Tag ( GetSide ( lab ) , 171 , [ ] ) ;
28488: LD_ADDR_VAR 0 3
28492: PUSH
28493: LD_VAR 0 2
28497: PPUSH
28498: CALL_OW 255
28502: PPUSH
28503: LD_INT 171
28505: PPUSH
28506: EMPTY
28507: PPUSH
28508: CALL 12290 0 3
28512: ST_TO_ADDR
// if i then
28513: LD_VAR 0 3
28517: IFFALSE 28548
// begin SetTag ( i [ 1 ] , 0 ) ;
28519: LD_VAR 0 3
28523: PUSH
28524: LD_INT 1
28526: ARRAY
28527: PPUSH
28528: LD_INT 0
28530: PPUSH
28531: CALL_OW 109
// ComExitBuilding ( i [ 1 ] ) ;
28535: LD_VAR 0 3
28539: PUSH
28540: LD_INT 1
28542: ARRAY
28543: PPUSH
28544: CALL_OW 122
// end ; end ; end ;
28548: PPOPN 3
28550: END
// on VehicleConstructed ( veh , b ) do var i , side , tmp , c1 , c2 , c3 , c4 ;
28551: LD_INT 0
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
28559: PPUSH
// if MREG_SidesList [ GetSide ( b ) ] then
28560: LD_EXP 41
28564: PUSH
28565: LD_VAR 0 2
28569: PPUSH
28570: CALL_OW 255
28574: ARRAY
28575: IFFALSE 29302
// begin side := GetSide ( veh ) ;
28577: LD_ADDR_VAR 0 4
28581: PUSH
28582: LD_VAR 0 1
28586: PPUSH
28587: CALL_OW 255
28591: ST_TO_ADDR
// c1 := GetChassis ( veh ) ;
28592: LD_ADDR_VAR 0 6
28596: PUSH
28597: LD_VAR 0 1
28601: PPUSH
28602: CALL_OW 265
28606: ST_TO_ADDR
// c2 := GetEngine ( veh ) ;
28607: LD_ADDR_VAR 0 7
28611: PUSH
28612: LD_VAR 0 1
28616: PPUSH
28617: CALL_OW 262
28621: ST_TO_ADDR
// c3 := GetControl ( veh ) ;
28622: LD_ADDR_VAR 0 8
28626: PUSH
28627: LD_VAR 0 1
28631: PPUSH
28632: CALL_OW 263
28636: ST_TO_ADDR
// c4 := GetWeapon ( veh ) ;
28637: LD_ADDR_VAR 0 9
28641: PUSH
28642: LD_VAR 0 1
28646: PPUSH
28647: CALL_OW 264
28651: ST_TO_ADDR
// LogEvent ( VehicleConstructed [side:  & side & ; id: & veh & ; components: [ & c1 & ,  & c2 & ,  & c3 & ,  & c4 & ]] ) ;
28652: LD_STRING VehicleConstructed [side: 
28654: PUSH
28655: LD_VAR 0 4
28659: STR
28660: PUSH
28661: LD_STRING ; id:
28663: STR
28664: PUSH
28665: LD_VAR 0 1
28669: STR
28670: PUSH
28671: LD_STRING ; components: [
28673: STR
28674: PUSH
28675: LD_VAR 0 6
28679: STR
28680: PUSH
28681: LD_STRING , 
28683: STR
28684: PUSH
28685: LD_VAR 0 7
28689: STR
28690: PUSH
28691: LD_STRING , 
28693: STR
28694: PUSH
28695: LD_VAR 0 8
28699: STR
28700: PUSH
28701: LD_STRING , 
28703: STR
28704: PUSH
28705: LD_VAR 0 9
28709: STR
28710: PUSH
28711: LD_STRING ]]
28713: STR
28714: PPUSH
28715: CALL 7984 0 1
// if not GetWeapon ( veh ) in [ us_crane , us_cargo_bay , us_bulldozer , ru_cargo_bay , ru_bulldozer , ru_crane , ar_cargo_bay ] then
28719: LD_VAR 0 1
28723: PPUSH
28724: CALL_OW 264
28728: PUSH
28729: LD_INT 13
28731: PUSH
28732: LD_INT 12
28734: PUSH
28735: LD_INT 14
28737: PUSH
28738: LD_INT 51
28740: PUSH
28741: LD_INT 53
28743: PUSH
28744: LD_INT 52
28746: PUSH
28747: LD_INT 32
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: IN
28759: NOT
28760: IFFALSE 28802
// MREG_VCombat := Replace2 ( MREG_VCombat , side , MREG_VCombat [ side ] + 1 , veh ) ;
28762: LD_ADDR_EXP 61
28766: PUSH
28767: LD_EXP 61
28771: PPUSH
28772: LD_VAR 0 4
28776: PPUSH
28777: LD_EXP 61
28781: PUSH
28782: LD_VAR 0 4
28786: ARRAY
28787: PUSH
28788: LD_INT 1
28790: PLUS
28791: PPUSH
28792: LD_VAR 0 1
28796: PPUSH
28797: CALL 31052 0 4
28801: ST_TO_ADDR
// if GetWeapon ( veh ) = ar_control_tower then
28802: LD_VAR 0 1
28806: PPUSH
28807: CALL_OW 264
28811: PUSH
28812: LD_INT 31
28814: EQUAL
28815: IFFALSE 28834
// SetTag ( GetDriver ( veh ) , 9 ) ;
28817: LD_VAR 0 1
28821: PPUSH
28822: CALL 31695 0 1
28826: PPUSH
28827: LD_INT 9
28829: PPUSH
28830: CALL_OW 109
// if GetWeapon ( veh ) in [ us_bulldozer , ru_bulldozer ] then
28834: LD_VAR 0 1
28838: PPUSH
28839: CALL_OW 264
28843: PUSH
28844: LD_INT 14
28846: PUSH
28847: LD_INT 53
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: IN
28854: IFFALSE 28891
// begin MREG_Bulldozer := Replace2 ( MREG_Bulldozer , GetSide ( veh ) , 2 , veh ) ;
28856: LD_ADDR_EXP 44
28860: PUSH
28861: LD_EXP 44
28865: PPUSH
28866: LD_VAR 0 1
28870: PPUSH
28871: CALL_OW 255
28875: PPUSH
28876: LD_INT 2
28878: PPUSH
28879: LD_VAR 0 1
28883: PPUSH
28884: CALL 31052 0 4
28888: ST_TO_ADDR
// exit ;
28889: GO 29302
// end ; if GetChassis ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetEngine ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetControl ( veh ) in MREG_DefSquad [ side ] [ 1 ] and GetWeapon ( veh ) in MREG_DefSquad [ side ] [ 1 ] then
28891: LD_VAR 0 1
28895: PPUSH
28896: CALL_OW 265
28900: PUSH
28901: LD_EXP 68
28905: PUSH
28906: LD_VAR 0 4
28910: ARRAY
28911: PUSH
28912: LD_INT 1
28914: ARRAY
28915: IN
28916: PUSH
28917: LD_VAR 0 1
28921: PPUSH
28922: CALL_OW 262
28926: PUSH
28927: LD_EXP 68
28931: PUSH
28932: LD_VAR 0 4
28936: ARRAY
28937: PUSH
28938: LD_INT 1
28940: ARRAY
28941: IN
28942: AND
28943: PUSH
28944: LD_VAR 0 1
28948: PPUSH
28949: CALL_OW 263
28953: PUSH
28954: LD_EXP 68
28958: PUSH
28959: LD_VAR 0 4
28963: ARRAY
28964: PUSH
28965: LD_INT 1
28967: ARRAY
28968: IN
28969: AND
28970: PUSH
28971: LD_VAR 0 1
28975: PPUSH
28976: CALL_OW 264
28980: PUSH
28981: LD_EXP 68
28985: PUSH
28986: LD_VAR 0 4
28990: ARRAY
28991: PUSH
28992: LD_INT 1
28994: ARRAY
28995: IN
28996: AND
28997: IFFALSE 29041
// begin MREG_DefVeh := Replace2 ( MREG_DefVeh , side , MREG_DefVeh [ side ] + 1 , veh ) ;
28999: LD_ADDR_EXP 69
29003: PUSH
29004: LD_EXP 69
29008: PPUSH
29009: LD_VAR 0 4
29013: PPUSH
29014: LD_EXP 69
29018: PUSH
29019: LD_VAR 0 4
29023: ARRAY
29024: PUSH
29025: LD_INT 1
29027: PLUS
29028: PPUSH
29029: LD_VAR 0 1
29033: PPUSH
29034: CALL 31052 0 4
29038: ST_TO_ADDR
// exit ;
29039: GO 29302
// end ; if ( c1 = MREG_ToAttack [ side ] [ 1 ] and c2 = MREG_ToAttack [ side ] [ 2 ] and c3 = MREG_ToAttack [ side ] [ 3 ] and c4 = MREG_ToAttack [ side ] [ 4 ] ) then
29041: LD_VAR 0 6
29045: PUSH
29046: LD_EXP 71
29050: PUSH
29051: LD_VAR 0 4
29055: ARRAY
29056: PUSH
29057: LD_INT 1
29059: ARRAY
29060: EQUAL
29061: PUSH
29062: LD_VAR 0 7
29066: PUSH
29067: LD_EXP 71
29071: PUSH
29072: LD_VAR 0 4
29076: ARRAY
29077: PUSH
29078: LD_INT 2
29080: ARRAY
29081: EQUAL
29082: AND
29083: PUSH
29084: LD_VAR 0 8
29088: PUSH
29089: LD_EXP 71
29093: PUSH
29094: LD_VAR 0 4
29098: ARRAY
29099: PUSH
29100: LD_INT 3
29102: ARRAY
29103: EQUAL
29104: AND
29105: PUSH
29106: LD_VAR 0 9
29110: PUSH
29111: LD_EXP 71
29115: PUSH
29116: LD_VAR 0 4
29120: ARRAY
29121: PUSH
29122: LD_INT 4
29124: ARRAY
29125: EQUAL
29126: AND
29127: IFFALSE 29283
// begin tmp := MREG_ToAttack [ side ] ;
29129: LD_ADDR_VAR 0 5
29133: PUSH
29134: LD_EXP 71
29138: PUSH
29139: LD_VAR 0 4
29143: ARRAY
29144: ST_TO_ADDR
// for i = 1 to 4 do
29145: LD_ADDR_VAR 0 3
29149: PUSH
29150: DOUBLE
29151: LD_INT 1
29153: DEC
29154: ST_TO_ADDR
29155: LD_INT 4
29157: PUSH
29158: FOR_TO
29159: IFFALSE 29181
// tmp := Delete ( tmp , 1 ) ;
29161: LD_ADDR_VAR 0 5
29165: PUSH
29166: LD_VAR 0 5
29170: PPUSH
29171: LD_INT 1
29173: PPUSH
29174: CALL_OW 3
29178: ST_TO_ADDR
29179: GO 29158
29181: POP
29182: POP
// MREG_ToAttack := Replace ( MREG_ToAttack , side , tmp ) ;
29183: LD_ADDR_EXP 71
29187: PUSH
29188: LD_EXP 71
29192: PPUSH
29193: LD_VAR 0 4
29197: PPUSH
29198: LD_VAR 0 5
29202: PPUSH
29203: CALL_OW 1
29207: ST_TO_ADDR
// MREG_Attackers := Replace2 ( MREG_Attackers , side , MREG_Attackers [ side ] + 1 , veh ) ;
29208: LD_ADDR_EXP 73
29212: PUSH
29213: LD_EXP 73
29217: PPUSH
29218: LD_VAR 0 4
29222: PPUSH
29223: LD_EXP 73
29227: PUSH
29228: LD_VAR 0 4
29232: ARRAY
29233: PUSH
29234: LD_INT 1
29236: PLUS
29237: PPUSH
29238: LD_VAR 0 1
29242: PPUSH
29243: CALL 31052 0 4
29247: ST_TO_ADDR
// if tmp = 0 then
29248: LD_VAR 0 5
29252: PUSH
29253: LD_INT 0
29255: EQUAL
29256: IFFALSE 29281
// MREG_ToAttack := Replace ( MREG_ToAttack , side , 0 ) ;
29258: LD_ADDR_EXP 71
29262: PUSH
29263: LD_EXP 71
29267: PPUSH
29268: LD_VAR 0 4
29272: PPUSH
29273: LD_INT 0
29275: PPUSH
29276: CALL_OW 1
29280: ST_TO_ADDR
// exit ;
29281: GO 29302
// end ; MCV_Parking ( GetSide ( veh ) , veh ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: CALL_OW 255
29292: PPUSH
29293: LD_VAR 0 1
29297: PPUSH
29298: CALL 25677 0 2
// end ;
29302: PPOPN 9
29304: END
// on ApemanTamed ( ape , unit ) do if MREG_SidesList [ GetSide ( unit ) ] then
29305: LD_EXP 41
29309: PUSH
29310: LD_VAR 0 2
29314: PPUSH
29315: CALL_OW 255
29319: ARRAY
29320: IFFALSE 29552
// begin LogEvent ( ApemanTamed [side:  & GetSide ( unit ) & ; sci:  & unit & ; ape:  & ape & ] ) ;
29322: LD_STRING ApemanTamed [side: 
29324: PUSH
29325: LD_VAR 0 2
29329: PPUSH
29330: CALL_OW 255
29334: STR
29335: PUSH
29336: LD_STRING ; sci: 
29338: STR
29339: PUSH
29340: LD_VAR 0 2
29344: STR
29345: PUSH
29346: LD_STRING ; ape: 
29348: STR
29349: PUSH
29350: LD_VAR 0 1
29354: STR
29355: PUSH
29356: LD_STRING ]
29358: STR
29359: PPUSH
29360: CALL 7984 0 1
// if ( not GetTech ( tech_apeagres , GetSide ( unit ) ) = state_researched or not GetTech ( tech_apepsych , GetSide ( unit ) ) = state_researched ) and MCF_Tag ( GetSide ( unit ) , 171 , [ ] ) = 0 then
29364: LD_INT 11
29366: PPUSH
29367: LD_VAR 0 2
29371: PPUSH
29372: CALL_OW 255
29376: PPUSH
29377: CALL_OW 321
29381: PUSH
29382: LD_INT 2
29384: EQUAL
29385: NOT
29386: PUSH
29387: LD_INT 2
29389: PPUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: CALL_OW 255
29399: PPUSH
29400: CALL_OW 321
29404: PUSH
29405: LD_INT 2
29407: EQUAL
29408: NOT
29409: OR
29410: PUSH
29411: LD_VAR 0 2
29415: PPUSH
29416: CALL_OW 255
29420: PPUSH
29421: LD_INT 171
29423: PPUSH
29424: EMPTY
29425: PPUSH
29426: CALL 12290 0 3
29430: PUSH
29431: LD_INT 0
29433: EQUAL
29434: AND
29435: IFFALSE 29449
// begin SetTag ( ape , 171 ) ;
29437: LD_VAR 0 1
29441: PPUSH
29442: LD_INT 171
29444: PPUSH
29445: CALL_OW 109
// end ; if MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) then
29449: LD_VAR 0 2
29453: PPUSH
29454: CALL_OW 255
29458: PPUSH
29459: LD_INT 30
29461: PUSH
29462: LD_INT 1
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PPUSH
29469: CALL 11587 0 2
29473: IFFALSE 29552
// ComMoveXY ( ape , GetX ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( GetSide ( unit ) , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
29475: LD_VAR 0 1
29479: PPUSH
29480: LD_VAR 0 2
29484: PPUSH
29485: CALL_OW 255
29489: PPUSH
29490: LD_INT 30
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PPUSH
29500: CALL 11587 0 2
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: CALL_OW 250
29513: PPUSH
29514: LD_VAR 0 2
29518: PPUSH
29519: CALL_OW 255
29523: PPUSH
29524: LD_INT 30
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PPUSH
29534: CALL 11587 0 2
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PPUSH
29543: CALL_OW 251
29547: PPUSH
29548: CALL_OW 111
// end ;
29552: PPOPN 2
29554: END
// on EnterBuilding ( b , un ) do if MREG_SidesList [ GetSide ( b ) ] then
29555: LD_EXP 41
29559: PUSH
29560: LD_VAR 0 1
29564: PPUSH
29565: CALL_OW 255
29569: ARRAY
29570: IFFALSE 29848
// begin if un in MCF_Ape ( GetSide ( un ) ) then
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 2
29581: PPUSH
29582: CALL_OW 255
29586: PPUSH
29587: CALL 12000 0 1
29591: IN
29592: IFFALSE 29733
// begin if GetBType ( b ) in [ b_depot , b_warehouse ] then
29594: LD_VAR 0 1
29598: PPUSH
29599: CALL_OW 266
29603: PUSH
29604: LD_INT 0
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: IN
29614: IFFALSE 29644
// begin Wait ( 0 0$0.3 ) ;
29616: LD_INT 10
29618: PPUSH
29619: CALL_OW 67
// SetClass ( un , class_apeman_engineer ) ;
29623: LD_VAR 0 2
29627: PPUSH
29628: LD_INT 16
29630: PPUSH
29631: CALL_OW 336
// ComExitBuilding ( un ) ;
29635: LD_VAR 0 2
29639: PPUSH
29640: CALL_OW 122
// end ; if GetBType ( b ) in [ b_armoury , b_barracks ] then
29644: LD_VAR 0 1
29648: PPUSH
29649: CALL_OW 266
29653: PUSH
29654: LD_INT 4
29656: PUSH
29657: LD_INT 5
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: IN
29664: IFFALSE 29733
// begin Wait ( 0 0$0.3 ) ;
29666: LD_INT 10
29668: PPUSH
29669: CALL_OW 67
// if GetTag ( un ) = 0 then
29673: LD_VAR 0 2
29677: PPUSH
29678: CALL_OW 110
29682: PUSH
29683: LD_INT 0
29685: EQUAL
29686: IFFALSE 29702
// SetClass ( un , class_apeman_soldier ) else
29688: LD_VAR 0 2
29692: PPUSH
29693: LD_INT 15
29695: PPUSH
29696: CALL_OW 336
29700: GO 29733
// if GetTech ( tech_apeneural , GetSide ( un ) ) then
29702: LD_INT 3
29704: PPUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: CALL_OW 255
29714: PPUSH
29715: CALL_OW 321
29719: IFFALSE 29733
// SetClass ( un , class_apeman_kamikaze ) ;
29721: LD_VAR 0 2
29725: PPUSH
29726: LD_INT 17
29728: PPUSH
29729: CALL_OW 336
// end ; end ; if GetBType ( b ) = b_bunker then
29733: LD_VAR 0 1
29737: PPUSH
29738: CALL_OW 266
29742: PUSH
29743: LD_INT 32
29745: EQUAL
29746: IFFALSE 29848
// begin MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , b ) ;
29748: LD_ADDR_EXP 70
29752: PUSH
29753: LD_EXP 70
29757: PPUSH
29758: LD_VAR 0 1
29762: PPUSH
29763: CALL_OW 255
29767: PPUSH
29768: LD_EXP 70
29772: PUSH
29773: LD_VAR 0 1
29777: PPUSH
29778: CALL_OW 255
29782: ARRAY
29783: PUSH
29784: LD_INT 1
29786: PLUS
29787: PPUSH
29788: LD_VAR 0 1
29792: PPUSH
29793: CALL 31052 0 4
29797: ST_TO_ADDR
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( b ) , MREG_ToBunker [ GetSide ( b ) ] + 1 , un ) ;
29798: LD_ADDR_EXP 70
29802: PUSH
29803: LD_EXP 70
29807: PPUSH
29808: LD_VAR 0 1
29812: PPUSH
29813: CALL_OW 255
29817: PPUSH
29818: LD_EXP 70
29822: PUSH
29823: LD_VAR 0 1
29827: PPUSH
29828: CALL_OW 255
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: PLUS
29837: PPUSH
29838: LD_VAR 0 2
29842: PPUSH
29843: CALL 31052 0 4
29847: ST_TO_ADDR
// end ; end ;
29848: PPOPN 2
29850: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
29851: LD_VAR 0 1
29855: PPUSH
29856: CALL 56489 0 1
// if un in FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_human ] ] ) then
29860: LD_VAR 0 1
29864: PUSH
29865: LD_INT 22
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 23
29877: PUSH
29878: LD_INT 3
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 21
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: LIST
29899: PPUSH
29900: CALL_OW 69
29904: IN
29905: IFFALSE 29921
// player_loss := player_loss + 1 ;
29907: LD_ADDR_EXP 10
29911: PUSH
29912: LD_EXP 10
29916: PUSH
29917: LD_INT 1
29919: PLUS
29920: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) and not alfa_north_triggered then
29921: LD_VAR 0 1
29925: PUSH
29926: LD_INT 22
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 21
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PPUSH
29950: CALL_OW 69
29954: IN
29955: PUSH
29956: LD_EXP 15
29960: NOT
29961: AND
29962: IFFALSE 30025
// begin alfa_north_triggered := true ;
29964: LD_ADDR_EXP 15
29968: PUSH
29969: LD_INT 1
29971: ST_TO_ADDR
// SayRadio ( Brown , DS4 ) ;
29972: LD_EXP 5
29976: PPUSH
29977: LD_STRING DS4
29979: PPUSH
29980: CALL_OW 94
// Wait ( 1 1$25 ) ;
29984: LD_INT 2975
29986: PPUSH
29987: CALL_OW 67
// if not isTest then
29991: LD_EXP 1
29995: NOT
29996: IFFALSE 30025
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
29998: LD_INT 20
30000: PPUSH
30001: LD_INT 5
30003: PUSH
30004: LD_INT 6
30006: PUSH
30007: LD_INT 7
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: PUSH
30015: LD_OWVAR 67
30019: ARRAY
30020: PPUSH
30021: CALL 7122 0 2
// end ; if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) and not alfa_south_triggered then
30025: LD_VAR 0 1
30029: PUSH
30030: LD_INT 22
30032: PUSH
30033: LD_INT 4
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 21
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PPUSH
30054: CALL_OW 69
30058: IN
30059: PUSH
30060: LD_EXP 16
30064: NOT
30065: AND
30066: IFFALSE 30129
// begin alfa_south_triggered := true ;
30068: LD_ADDR_EXP 16
30072: PUSH
30073: LD_INT 1
30075: ST_TO_ADDR
// SayRadio ( Houten , DJ3 ) ;
30076: LD_EXP 4
30080: PPUSH
30081: LD_STRING DJ3
30083: PPUSH
30084: CALL_OW 94
// Wait ( 0 0$45 ) ;
30088: LD_INT 1575
30090: PPUSH
30091: CALL_OW 67
// if not isTest then
30095: LD_EXP 1
30099: NOT
30100: IFFALSE 30129
// PrepareAlfaAttack ( north_arr , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
30102: LD_INT 20
30104: PPUSH
30105: LD_INT 5
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: LD_INT 7
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: LIST
30118: PUSH
30119: LD_OWVAR 67
30123: ARRAY
30124: PPUSH
30125: CALL 7122 0 2
// end ; if GetBType ( un ) = b_warehouse and GetSide ( un ) in [ 1 , 4 ] then
30129: LD_VAR 0 1
30133: PPUSH
30134: CALL_OW 266
30138: PUSH
30139: LD_INT 1
30141: EQUAL
30142: PUSH
30143: LD_VAR 0 1
30147: PPUSH
30148: CALL_OW 255
30152: PUSH
30153: LD_INT 1
30155: PUSH
30156: LD_INT 4
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: IN
30163: AND
30164: IFFALSE 30173
// RaiseSailEvent ( 104 ) ;
30166: LD_INT 104
30168: PPUSH
30169: CALL_OW 427
// if MREG_SidesList [ GetSide ( un ) ] then
30173: LD_EXP 41
30177: PUSH
30178: LD_VAR 0 1
30182: PPUSH
30183: CALL_OW 255
30187: ARRAY
30188: IFFALSE 30575
// begin LogEvent ( UnitDestroyed [side  & GetSide ( un ) & ; id:  & un & ; type:  & GetType ( un ) & ] ) ;
30190: LD_STRING UnitDestroyed [side 
30192: PUSH
30193: LD_VAR 0 1
30197: PPUSH
30198: CALL_OW 255
30202: STR
30203: PUSH
30204: LD_STRING ; id: 
30206: STR
30207: PUSH
30208: LD_VAR 0 1
30212: STR
30213: PUSH
30214: LD_STRING ; type: 
30216: STR
30217: PUSH
30218: LD_VAR 0 1
30222: PPUSH
30223: CALL_OW 247
30227: STR
30228: PUSH
30229: LD_STRING ]
30231: STR
30232: PPUSH
30233: CALL 7984 0 1
// if un in MCF_Get ( GetSide ( un ) , [ f_type , unit_human ] ) then
30237: LD_VAR 0 1
30241: PUSH
30242: LD_VAR 0 1
30246: PPUSH
30247: CALL_OW 255
30251: PPUSH
30252: LD_INT 21
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PPUSH
30262: CALL 11587 0 2
30266: IN
30267: IFFALSE 30423
// begin if MCF_HasClass ( un ) then
30269: LD_VAR 0 1
30273: PPUSH
30274: CALL 14293 0 1
30278: IFFALSE 30423
// case MCF_HasClass ( un ) of 1 :
30280: LD_VAR 0 1
30284: PPUSH
30285: CALL 14293 0 1
30289: PUSH
30290: LD_INT 1
30292: DOUBLE
30293: EQUAL
30294: IFTRUE 30298
30296: GO 30323
30298: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToArm , un ) ; 2 :
30299: LD_VAR 0 1
30303: PPUSH
30304: CALL_OW 255
30308: PPUSH
30309: LD_STRING ToArm
30311: PPUSH
30312: LD_VAR 0 1
30316: PPUSH
30317: CALL 14466 0 3
30321: GO 30423
30323: LD_INT 2
30325: DOUBLE
30326: EQUAL
30327: IFTRUE 30331
30329: GO 30356
30331: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToDep , un ) ; 3 :
30332: LD_VAR 0 1
30336: PPUSH
30337: CALL_OW 255
30341: PPUSH
30342: LD_STRING ToDep
30344: PPUSH
30345: LD_VAR 0 1
30349: PPUSH
30350: CALL 14466 0 3
30354: GO 30423
30356: LD_INT 3
30358: DOUBLE
30359: EQUAL
30360: IFTRUE 30364
30362: GO 30389
30364: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToFac , un ) ; 4 :
30365: LD_VAR 0 1
30369: PPUSH
30370: CALL_OW 255
30374: PPUSH
30375: LD_STRING ToFac
30377: PPUSH
30378: LD_VAR 0 1
30382: PPUSH
30383: CALL 14466 0 3
30387: GO 30423
30389: LD_INT 4
30391: DOUBLE
30392: EQUAL
30393: IFTRUE 30397
30395: GO 30422
30397: POP
// MCF_RemoveFromClass ( GetSide ( un ) , ToLab , un ) ; end ;
30398: LD_VAR 0 1
30402: PPUSH
30403: CALL_OW 255
30407: PPUSH
30408: LD_STRING ToLab
30410: PPUSH
30411: LD_VAR 0 1
30415: PPUSH
30416: CALL 14466 0 3
30420: GO 30423
30422: POP
// end ; if un in MREG_DefVeh [ GetSide ( un ) ] then
30423: LD_VAR 0 1
30427: PUSH
30428: LD_EXP 69
30432: PUSH
30433: LD_VAR 0 1
30437: PPUSH
30438: CALL_OW 255
30442: ARRAY
30443: IN
30444: IFFALSE 30529
// begin MREG_DefVeh := Remove ( MREG_DefVeh , un , false ) ;
30446: LD_ADDR_EXP 69
30450: PUSH
30451: LD_EXP 69
30455: PPUSH
30456: LD_VAR 0 1
30460: PPUSH
30461: LD_INT 0
30463: PPUSH
30464: CALL 31211 0 3
30468: ST_TO_ADDR
// MCS_AddVehicle ( GetSide ( un ) , [ GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ] ) ;
30469: LD_VAR 0 1
30473: PPUSH
30474: CALL_OW 255
30478: PPUSH
30479: LD_VAR 0 1
30483: PPUSH
30484: CALL_OW 265
30488: PUSH
30489: LD_VAR 0 1
30493: PPUSH
30494: CALL_OW 262
30498: PUSH
30499: LD_VAR 0 1
30503: PPUSH
30504: CALL_OW 263
30508: PUSH
30509: LD_VAR 0 1
30513: PPUSH
30514: CALL_OW 264
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: PPUSH
30525: CALL 21106 0 2
// end ; if un in MREG_Attackers [ GetSide ( un ) ] then
30529: LD_VAR 0 1
30533: PUSH
30534: LD_EXP 73
30538: PUSH
30539: LD_VAR 0 1
30543: PPUSH
30544: CALL_OW 255
30548: ARRAY
30549: IN
30550: IFFALSE 30575
// MREG_Attackers := Remove ( MREG_Attackers , un , false ) ;
30552: LD_ADDR_EXP 73
30556: PUSH
30557: LD_EXP 73
30561: PPUSH
30562: LD_VAR 0 1
30566: PPUSH
30567: LD_INT 0
30569: PPUSH
30570: CALL 31211 0 3
30574: ST_TO_ADDR
// end ; end ;
30575: PPOPN 1
30577: END
// on LeaveBuilding ( b , un ) do if MREG_SidesList [ GetSide ( un ) ] then
30578: LD_EXP 41
30582: PUSH
30583: LD_VAR 0 2
30587: PPUSH
30588: CALL_OW 255
30592: ARRAY
30593: IFFALSE 30765
// begin if un in MREG_ToBunker [ GetSide ( un ) ] and GetBType ( b ) in [ b_bunker , b_breastwork ] then
30595: LD_VAR 0 2
30599: PUSH
30600: LD_EXP 70
30604: PUSH
30605: LD_VAR 0 2
30609: PPUSH
30610: CALL_OW 255
30614: ARRAY
30615: IN
30616: PUSH
30617: LD_VAR 0 1
30621: PPUSH
30622: CALL_OW 266
30626: PUSH
30627: LD_INT 32
30629: PUSH
30630: LD_INT 31
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: IN
30637: AND
30638: IFFALSE 30738
// begin MREG_ToBunker := Remove ( MREG_ToBunker , b , false ) ;
30640: LD_ADDR_EXP 70
30644: PUSH
30645: LD_EXP 70
30649: PPUSH
30650: LD_VAR 0 1
30654: PPUSH
30655: LD_INT 0
30657: PPUSH
30658: CALL 31211 0 3
30662: ST_TO_ADDR
// MREG_ToBunker := Remove ( MREG_ToBunker , un , false ) ;
30663: LD_ADDR_EXP 70
30667: PUSH
30668: LD_EXP 70
30672: PPUSH
30673: LD_VAR 0 2
30677: PPUSH
30678: LD_INT 0
30680: PPUSH
30681: CALL 31211 0 3
30685: ST_TO_ADDR
// if MREG_ToBunker [ GetSide ( un ) ] =  then
30686: LD_EXP 70
30690: PUSH
30691: LD_VAR 0 2
30695: PPUSH
30696: CALL_OW 255
30700: ARRAY
30701: PUSH
30702: LD_STRING 
30704: EQUAL
30705: IFFALSE 30738
// MREG_ToBunker := Replace2 ( MREG_ToBunker , GetSide ( un ) , 1 , 0 ) ;
30707: LD_ADDR_EXP 70
30711: PUSH
30712: LD_EXP 70
30716: PPUSH
30717: LD_VAR 0 2
30721: PPUSH
30722: CALL_OW 255
30726: PPUSH
30727: LD_INT 1
30729: PPUSH
30730: LD_INT 0
30732: PPUSH
30733: CALL 31052 0 4
30737: ST_TO_ADDR
// end ; if GetBType ( b ) in b_control_tower then
30738: LD_VAR 0 1
30742: PPUSH
30743: CALL_OW 266
30747: PUSH
30748: LD_INT 36
30750: IN
30751: IFFALSE 30765
// SetTag ( un , 0 ) ;
30753: LD_VAR 0 2
30757: PPUSH
30758: LD_INT 0
30760: PPUSH
30761: CALL_OW 109
// end ;
30765: PPOPN 2
30767: END
// on UnitGoesToRed ( un ) do if MREG_SidesList [ GetSide ( un ) ] then
30768: LD_EXP 41
30772: PUSH
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 255
30782: ARRAY
30783: IFFALSE 30809
// begin if GetControl ( un ) = control_remote then
30785: LD_VAR 0 1
30789: PPUSH
30790: CALL_OW 263
30794: PUSH
30795: LD_INT 2
30797: EQUAL
30798: IFFALSE 30809
// ComUnlink ( un ) ;
30800: LD_VAR 0 1
30804: PPUSH
30805: CALL_OW 136
// end ;
30809: PPOPN 1
30811: END
// on EvacuateVehicle ( driver , vehicle , v , c ) do if MREG_SidesList [ GetSide ( driver ) ] then
30812: LD_EXP 41
30816: PUSH
30817: LD_VAR 0 1
30821: PPUSH
30822: CALL_OW 255
30826: ARRAY
30827: IFFALSE 30856
// begin if GetWeapon ( vehicle ) in ar_control_tower then
30829: LD_VAR 0 2
30833: PPUSH
30834: CALL_OW 264
30838: PUSH
30839: LD_INT 31
30841: IN
30842: IFFALSE 30856
// SetTag ( driver , 0 ) ;
30844: LD_VAR 0 1
30848: PPUSH
30849: LD_INT 0
30851: PPUSH
30852: CALL_OW 109
// end ;
30856: PPOPN 4
30858: END
// on WeaponPlaced ( building , factory ) do var weapon , x , y ;
30859: LD_INT 0
30861: PPUSH
30862: PPUSH
30863: PPUSH
// begin weapon := GetBWeapon ( building ) ;
30864: LD_ADDR_VAR 0 3
30868: PUSH
30869: LD_VAR 0 1
30873: PPUSH
30874: CALL_OW 269
30878: ST_TO_ADDR
// x := GetX ( building ) ;
30879: LD_ADDR_VAR 0 4
30883: PUSH
30884: LD_VAR 0 1
30888: PPUSH
30889: CALL_OW 250
30893: ST_TO_ADDR
// y := GetY ( building ) ;
30894: LD_ADDR_VAR 0 5
30898: PUSH
30899: LD_VAR 0 1
30903: PPUSH
30904: CALL_OW 251
30908: ST_TO_ADDR
// MREG_TurretWeapon := MC_RegistryDelete ( MREG_TurretWeapon , GetSide ( building ) , weapon , [ x , y ] ) ;
30909: LD_ADDR_EXP 45
30913: PUSH
30914: LD_EXP 45
30918: PPUSH
30919: LD_VAR 0 1
30923: PPUSH
30924: CALL_OW 255
30928: PPUSH
30929: LD_VAR 0 3
30933: PPUSH
30934: LD_VAR 0 4
30938: PUSH
30939: LD_VAR 0 5
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PPUSH
30948: CALL 41973 0 4
30952: ST_TO_ADDR
// end ;
30953: PPOPN 5
30955: END
// export unreachableList ; on DestinationUnreachable ( unit ) do begin if not unit in unreachableList then
30956: LD_VAR 0 1
30960: PUSH
30961: LD_EXP 32
30965: IN
30966: NOT
30967: IFFALSE 31015
// begin unreachableList := Insert ( unreachableList , unreachableList + 1 , unit ) ;
30969: LD_ADDR_EXP 32
30973: PUSH
30974: LD_EXP 32
30978: PPUSH
30979: LD_EXP 32
30983: PUSH
30984: LD_INT 1
30986: PLUS
30987: PPUSH
30988: LD_VAR 0 1
30992: PPUSH
30993: CALL_OW 2
30997: ST_TO_ADDR
// LogEvent ( DestinationUnrechable. [unit:  & unit & ] ) ;
30998: LD_STRING DestinationUnrechable. [unit: 
31000: PUSH
31001: LD_VAR 0 1
31005: STR
31006: PUSH
31007: LD_STRING ]
31009: STR
31010: PPUSH
31011: CALL 7984 0 1
// end ; end ;
31015: PPOPN 1
31017: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
31018: LD_VAR 0 1
31022: PPUSH
31023: LD_VAR 0 2
31027: PPUSH
31028: LD_VAR 0 3
31032: PPUSH
31033: CALL 56587 0 3
// end ;
31037: PPOPN 3
31039: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
31040: LD_VAR 0 1
31044: PPUSH
31045: CALL 56595 0 1
// end ; end_of_file
31049: PPOPN 1
31051: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
31052: LD_INT 0
31054: PPUSH
31055: PPUSH
31056: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
31057: LD_ADDR_VAR 0 7
31061: PUSH
31062: LD_VAR 0 1
31066: PUSH
31067: LD_VAR 0 2
31071: ARRAY
31072: PPUSH
31073: LD_VAR 0 3
31077: PPUSH
31078: LD_VAR 0 4
31082: PPUSH
31083: CALL_OW 1
31087: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
31088: LD_ADDR_VAR 0 1
31092: PUSH
31093: LD_VAR 0 1
31097: PPUSH
31098: LD_VAR 0 2
31102: PPUSH
31103: LD_VAR 0 7
31107: PPUSH
31108: CALL_OW 1
31112: ST_TO_ADDR
// result := tab ;
31113: LD_ADDR_VAR 0 5
31117: PUSH
31118: LD_VAR 0 1
31122: ST_TO_ADDR
// end ;
31123: LD_VAR 0 5
31127: RET
// export function Delete2 ( tab , pos ) ; var i , list ; begin
31128: LD_INT 0
31130: PPUSH
31131: PPUSH
31132: PPUSH
// list := Delete ( tab [ pos [ 1 ] ] , pos [ 2 ] ) ;
31133: LD_ADDR_VAR 0 5
31137: PUSH
31138: LD_VAR 0 1
31142: PUSH
31143: LD_VAR 0 2
31147: PUSH
31148: LD_INT 1
31150: ARRAY
31151: ARRAY
31152: PPUSH
31153: LD_VAR 0 2
31157: PUSH
31158: LD_INT 2
31160: ARRAY
31161: PPUSH
31162: CALL_OW 3
31166: ST_TO_ADDR
// tab := Replace ( tab , pos [ 1 ] , list ) ;
31167: LD_ADDR_VAR 0 1
31171: PUSH
31172: LD_VAR 0 1
31176: PPUSH
31177: LD_VAR 0 2
31181: PUSH
31182: LD_INT 1
31184: ARRAY
31185: PPUSH
31186: LD_VAR 0 5
31190: PPUSH
31191: CALL_OW 1
31195: ST_TO_ADDR
// result := tab ;
31196: LD_ADDR_VAR 0 3
31200: PUSH
31201: LD_VAR 0 1
31205: ST_TO_ADDR
// end ;
31206: LD_VAR 0 3
31210: RET
// export function Remove ( tab , value , mode ) ; var i , j , tmp ; begin
31211: LD_INT 0
31213: PPUSH
31214: PPUSH
31215: PPUSH
31216: PPUSH
// i := 1 ;
31217: LD_ADDR_VAR 0 5
31221: PUSH
31222: LD_INT 1
31224: ST_TO_ADDR
// while ( i <= tab ) do
31225: LD_VAR 0 5
31229: PUSH
31230: LD_VAR 0 1
31234: LESSEQUAL
31235: IFFALSE 31610
// begin if not tab [ i ] then
31237: LD_VAR 0 1
31241: PUSH
31242: LD_VAR 0 5
31246: ARRAY
31247: NOT
31248: IFFALSE 31252
// break ;
31250: GO 31610
// if value in tab then
31252: LD_VAR 0 2
31256: PUSH
31257: LD_VAR 0 1
31261: IN
31262: IFFALSE 31375
// begin if not mode then
31264: LD_VAR 0 3
31268: NOT
31269: IFFALSE 31289
// tab := tab diff value else
31271: LD_ADDR_VAR 0 1
31275: PUSH
31276: LD_VAR 0 1
31280: PUSH
31281: LD_VAR 0 2
31285: DIFF
31286: ST_TO_ADDR
31287: GO 31351
// for j = 1 to tab do
31289: LD_ADDR_VAR 0 6
31293: PUSH
31294: DOUBLE
31295: LD_INT 1
31297: DEC
31298: ST_TO_ADDR
31299: LD_VAR 0 1
31303: PUSH
31304: FOR_TO
31305: IFFALSE 31349
// if tab [ j ] = value then
31307: LD_VAR 0 1
31311: PUSH
31312: LD_VAR 0 6
31316: ARRAY
31317: PUSH
31318: LD_VAR 0 2
31322: EQUAL
31323: IFFALSE 31347
// begin tab := Delete ( tab , j ) ;
31325: LD_ADDR_VAR 0 1
31329: PUSH
31330: LD_VAR 0 1
31334: PPUSH
31335: LD_VAR 0 6
31339: PPUSH
31340: CALL_OW 3
31344: ST_TO_ADDR
// break ;
31345: GO 31349
// end ;
31347: GO 31304
31349: POP
31350: POP
// i := i - 1 ;
31351: LD_ADDR_VAR 0 5
31355: PUSH
31356: LD_VAR 0 5
31360: PUSH
31361: LD_INT 1
31363: MINUS
31364: ST_TO_ADDR
// if mode then
31365: LD_VAR 0 3
31369: IFFALSE 31373
// break ;
31371: GO 31610
// end else
31373: GO 31594
// if tab [ i ] and value in tab [ i ] then
31375: LD_VAR 0 1
31379: PUSH
31380: LD_VAR 0 5
31384: ARRAY
31385: PUSH
31386: LD_VAR 0 2
31390: PUSH
31391: LD_VAR 0 1
31395: PUSH
31396: LD_VAR 0 5
31400: ARRAY
31401: IN
31402: AND
31403: IFFALSE 31594
// begin if not mode then
31405: LD_VAR 0 3
31409: NOT
31410: IFFALSE 31436
// tmp := tab [ i ] diff value else
31412: LD_ADDR_VAR 0 7
31416: PUSH
31417: LD_VAR 0 1
31421: PUSH
31422: LD_VAR 0 5
31426: ARRAY
31427: PUSH
31428: LD_VAR 0 2
31432: DIFF
31433: ST_TO_ADDR
31434: GO 31516
// for j = 1 to tab [ i ] do
31436: LD_ADDR_VAR 0 6
31440: PUSH
31441: DOUBLE
31442: LD_INT 1
31444: DEC
31445: ST_TO_ADDR
31446: LD_VAR 0 1
31450: PUSH
31451: LD_VAR 0 5
31455: ARRAY
31456: PUSH
31457: FOR_TO
31458: IFFALSE 31514
// if value = tab [ i ] [ j ] then
31460: LD_VAR 0 2
31464: PUSH
31465: LD_VAR 0 1
31469: PUSH
31470: LD_VAR 0 5
31474: ARRAY
31475: PUSH
31476: LD_VAR 0 6
31480: ARRAY
31481: EQUAL
31482: IFFALSE 31512
// begin tmp := Delete ( tab [ i ] , j ) ;
31484: LD_ADDR_VAR 0 7
31488: PUSH
31489: LD_VAR 0 1
31493: PUSH
31494: LD_VAR 0 5
31498: ARRAY
31499: PPUSH
31500: LD_VAR 0 6
31504: PPUSH
31505: CALL_OW 3
31509: ST_TO_ADDR
// break ;
31510: GO 31514
// end ;
31512: GO 31457
31514: POP
31515: POP
// if tmp = [ ] then
31516: LD_VAR 0 7
31520: PUSH
31521: EMPTY
31522: EQUAL
31523: IFFALSE 31547
// begin tab := Delete ( tab , i ) ;
31525: LD_ADDR_VAR 0 1
31529: PUSH
31530: LD_VAR 0 1
31534: PPUSH
31535: LD_VAR 0 5
31539: PPUSH
31540: CALL_OW 3
31544: ST_TO_ADDR
// end else
31545: GO 31572
// tab := Replace ( tab , i , tmp ) ;
31547: LD_ADDR_VAR 0 1
31551: PUSH
31552: LD_VAR 0 1
31556: PPUSH
31557: LD_VAR 0 5
31561: PPUSH
31562: LD_VAR 0 7
31566: PPUSH
31567: CALL_OW 1
31571: ST_TO_ADDR
// i := i - 1 ;
31572: LD_ADDR_VAR 0 5
31576: PUSH
31577: LD_VAR 0 5
31581: PUSH
31582: LD_INT 1
31584: MINUS
31585: ST_TO_ADDR
// if mode then
31586: LD_VAR 0 3
31590: IFFALSE 31594
// break ;
31592: GO 31610
// end ; i := i + 1 ;
31594: LD_ADDR_VAR 0 5
31598: PUSH
31599: LD_VAR 0 5
31603: PUSH
31604: LD_INT 1
31606: PLUS
31607: ST_TO_ADDR
// end ;
31608: GO 31225
// result := tab ;
31610: LD_ADDR_VAR 0 4
31614: PUSH
31615: LD_VAR 0 1
31619: ST_TO_ADDR
// end ;
31620: LD_VAR 0 4
31624: RET
// export function RemoveAll ( tab , values ) ; var i ; begin
31625: LD_INT 0
31627: PPUSH
31628: PPUSH
// for i = 1 to values do
31629: LD_ADDR_VAR 0 4
31633: PUSH
31634: DOUBLE
31635: LD_INT 1
31637: DEC
31638: ST_TO_ADDR
31639: LD_VAR 0 2
31643: PUSH
31644: FOR_TO
31645: IFFALSE 31678
// tab := Remove ( tab , values [ i ] , false ) ;
31647: LD_ADDR_VAR 0 1
31651: PUSH
31652: LD_VAR 0 1
31656: PPUSH
31657: LD_VAR 0 2
31661: PUSH
31662: LD_VAR 0 4
31666: ARRAY
31667: PPUSH
31668: LD_INT 0
31670: PPUSH
31671: CALL 31211 0 3
31675: ST_TO_ADDR
31676: GO 31644
31678: POP
31679: POP
// result := tab ;
31680: LD_ADDR_VAR 0 3
31684: PUSH
31685: LD_VAR 0 1
31689: ST_TO_ADDR
// end ;
31690: LD_VAR 0 3
31694: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
31695: LD_INT 0
31697: PPUSH
31698: PPUSH
31699: PPUSH
// if not GetControl ( veh ) = control_manual then
31700: LD_VAR 0 1
31704: PPUSH
31705: CALL_OW 263
31709: PUSH
31710: LD_INT 1
31712: EQUAL
31713: NOT
31714: IFFALSE 31726
// result := false else
31716: LD_ADDR_VAR 0 2
31720: PUSH
31721: LD_INT 0
31723: ST_TO_ADDR
31724: GO 31871
// if veh in FilterAllUnits ( [ f_empty ] ) then
31726: LD_VAR 0 1
31730: PUSH
31731: LD_INT 58
31733: PUSH
31734: EMPTY
31735: LIST
31736: PPUSH
31737: CALL_OW 69
31741: IN
31742: IFFALSE 31754
// result := false else
31744: LD_ADDR_VAR 0 2
31748: PUSH
31749: LD_INT 0
31751: ST_TO_ADDR
31752: GO 31871
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
31754: LD_ADDR_VAR 0 4
31758: PUSH
31759: LD_INT 22
31761: PUSH
31762: LD_VAR 0 1
31766: PPUSH
31767: CALL_OW 255
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 55
31778: PUSH
31779: EMPTY
31780: LIST
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PPUSH
31786: CALL_OW 69
31790: ST_TO_ADDR
// if not filter then
31791: LD_VAR 0 4
31795: NOT
31796: IFFALSE 31808
// result := false else
31798: LD_ADDR_VAR 0 2
31802: PUSH
31803: LD_INT 0
31805: ST_TO_ADDR
31806: GO 31871
// for i = 1 to filter do
31808: LD_ADDR_VAR 0 3
31812: PUSH
31813: DOUBLE
31814: LD_INT 1
31816: DEC
31817: ST_TO_ADDR
31818: LD_VAR 0 4
31822: PUSH
31823: FOR_TO
31824: IFFALSE 31869
// if IsDriver ( filter [ i ] ) = veh then
31826: LD_VAR 0 4
31830: PUSH
31831: LD_VAR 0 3
31835: ARRAY
31836: PPUSH
31837: CALL 91877 0 1
31841: PUSH
31842: LD_VAR 0 1
31846: EQUAL
31847: IFFALSE 31867
// begin result := filter [ i ] ;
31849: LD_ADDR_VAR 0 2
31853: PUSH
31854: LD_VAR 0 4
31858: PUSH
31859: LD_VAR 0 3
31863: ARRAY
31864: ST_TO_ADDR
// break ;
31865: GO 31869
// end ;
31867: GO 31823
31869: POP
31870: POP
// end ; end ;
31871: LD_VAR 0 2
31875: RET
// export function Compare ( val1 , val2 ) ; begin
31876: LD_INT 0
31878: PPUSH
// if val1 = val2 then
31879: LD_VAR 0 1
31883: PUSH
31884: LD_VAR 0 2
31888: EQUAL
31889: IFFALSE 31901
// result := true else
31891: LD_ADDR_VAR 0 3
31895: PUSH
31896: LD_INT 1
31898: ST_TO_ADDR
31899: GO 31909
// result := false ;
31901: LD_ADDR_VAR 0 3
31905: PUSH
31906: LD_INT 0
31908: ST_TO_ADDR
// end ;
31909: LD_VAR 0 3
31913: RET
// export function Compare3 ( e1 , e2 ) ; var j ; begin
31914: LD_INT 0
31916: PPUSH
31917: PPUSH
// result := false ;
31918: LD_ADDR_VAR 0 3
31922: PUSH
31923: LD_INT 0
31925: ST_TO_ADDR
// for j = 1 to e2 do
31926: LD_ADDR_VAR 0 4
31930: PUSH
31931: DOUBLE
31932: LD_INT 1
31934: DEC
31935: ST_TO_ADDR
31936: LD_VAR 0 2
31940: PUSH
31941: FOR_TO
31942: IFFALSE 31976
// if Compare ( e1 , e2 [ j ] ) then
31944: LD_VAR 0 1
31948: PPUSH
31949: LD_VAR 0 2
31953: PUSH
31954: LD_VAR 0 4
31958: ARRAY
31959: PPUSH
31960: CALL 31876 0 2
31964: IFFALSE 31974
// result := true ;
31966: LD_ADDR_VAR 0 3
31970: PUSH
31971: LD_INT 1
31973: ST_TO_ADDR
31974: GO 31941
31976: POP
31977: POP
// end ;
31978: LD_VAR 0 3
31982: RET
// export function ComTake ( unit , x , y , dep ) ; var t ; begin
31983: LD_INT 0
31985: PPUSH
31986: PPUSH
// SetTaskList ( unit , [ [ C , x , y , 0 , 0 , 0 , 0 ] , [ v , GetX ( dep ) , GetY ( dep ) , dep , 0 , 0 , 0 ] ] ) ;
31987: LD_VAR 0 1
31991: PPUSH
31992: LD_STRING C
31994: PUSH
31995: LD_VAR 0 2
31999: PUSH
32000: LD_VAR 0 3
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 0
32010: PUSH
32011: LD_INT 0
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: PUSH
32026: LD_STRING v
32028: PUSH
32029: LD_VAR 0 4
32033: PPUSH
32034: CALL_OW 250
32038: PUSH
32039: LD_VAR 0 4
32043: PPUSH
32044: CALL_OW 251
32048: PUSH
32049: LD_VAR 0 4
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 0
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PPUSH
32076: CALL_OW 446
// end ;
32080: LD_VAR 0 5
32084: RET
// export function CanControl ( unit ) ; var sk , linked ; begin
32085: LD_INT 0
32087: PPUSH
32088: PPUSH
32089: PPUSH
// linked := UnitsLinked ( unit ) ;
32090: LD_ADDR_VAR 0 4
32094: PUSH
32095: LD_VAR 0 1
32099: PPUSH
32100: CALL_OW 432
32104: ST_TO_ADDR
// sk := GetSkill ( unit , 3 ) ;
32105: LD_ADDR_VAR 0 3
32109: PUSH
32110: LD_VAR 0 1
32114: PPUSH
32115: LD_INT 3
32117: PPUSH
32118: CALL_OW 259
32122: ST_TO_ADDR
// if sk > linked then
32123: LD_VAR 0 3
32127: PUSH
32128: LD_VAR 0 4
32132: GREATER
32133: IFFALSE 32145
// result := true else
32135: LD_ADDR_VAR 0 2
32139: PUSH
32140: LD_INT 1
32142: ST_TO_ADDR
32143: GO 32153
// result := false ;
32145: LD_ADDR_VAR 0 2
32149: PUSH
32150: LD_INT 0
32152: ST_TO_ADDR
// end ;
32153: LD_VAR 0 2
32157: RET
// export function NotTask ( unit ) ; begin
32158: LD_INT 0
32160: PPUSH
// result := true ;
32161: LD_ADDR_VAR 0 2
32165: PUSH
32166: LD_INT 1
32168: ST_TO_ADDR
// if GetTaskList ( unit ) or HasTask ( unit ) then
32169: LD_VAR 0 1
32173: PPUSH
32174: CALL_OW 437
32178: PUSH
32179: LD_VAR 0 1
32183: PPUSH
32184: CALL_OW 314
32188: OR
32189: IFFALSE 32199
// result := false ;
32191: LD_ADDR_VAR 0 2
32195: PUSH
32196: LD_INT 0
32198: ST_TO_ADDR
// end ;
32199: LD_VAR 0 2
32203: RET
// export function NearestUnit ( units1 , units2 ) ; var i , j , un , dist ; begin
32204: LD_INT 0
32206: PPUSH
32207: PPUSH
32208: PPUSH
32209: PPUSH
32210: PPUSH
// dist := 99999 ;
32211: LD_ADDR_VAR 0 7
32215: PUSH
32216: LD_INT 99999
32218: ST_TO_ADDR
// un := - 1 ;
32219: LD_ADDR_VAR 0 6
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: ST_TO_ADDR
// if units1 and units2 then
32228: LD_VAR 0 1
32232: PUSH
32233: LD_VAR 0 2
32237: AND
32238: IFFALSE 32326
// for i in units1 do
32240: LD_ADDR_VAR 0 4
32244: PUSH
32245: LD_VAR 0 1
32249: PUSH
32250: FOR_IN
32251: IFFALSE 32324
// for j in units2 do
32253: LD_ADDR_VAR 0 5
32257: PUSH
32258: LD_VAR 0 2
32262: PUSH
32263: FOR_IN
32264: IFFALSE 32320
// if GetDistUnits ( i , j ) < dist then
32266: LD_VAR 0 4
32270: PPUSH
32271: LD_VAR 0 5
32275: PPUSH
32276: CALL_OW 296
32280: PUSH
32281: LD_VAR 0 7
32285: LESS
32286: IFFALSE 32318
// begin un := i ;
32288: LD_ADDR_VAR 0 6
32292: PUSH
32293: LD_VAR 0 4
32297: ST_TO_ADDR
// dist := GetDistUnits ( i , j ) ;
32298: LD_ADDR_VAR 0 7
32302: PUSH
32303: LD_VAR 0 4
32307: PPUSH
32308: LD_VAR 0 5
32312: PPUSH
32313: CALL_OW 296
32317: ST_TO_ADDR
// end ;
32318: GO 32263
32320: POP
32321: POP
32322: GO 32250
32324: POP
32325: POP
// result := [ un , dist ] ;
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_VAR 0 6
32335: PUSH
32336: LD_VAR 0 7
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// end ;
32345: LD_VAR 0 3
32349: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i , list , tmp , hex ; begin
32350: LD_INT 0
32352: PPUSH
32353: PPUSH
32354: PPUSH
32355: PPUSH
32356: PPUSH
// if not bulldozer or GetLives ( bulldozer ) < 250 or ( HasTask ( bulldozer ) and GetFuel ( bulldozer ) > 20 ) then
32357: LD_VAR 0 1
32361: NOT
32362: PUSH
32363: LD_VAR 0 1
32367: PPUSH
32368: CALL_OW 256
32372: PUSH
32373: LD_INT 250
32375: LESS
32376: OR
32377: PUSH
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 314
32387: PUSH
32388: LD_VAR 0 1
32392: PPUSH
32393: CALL_OW 261
32397: PUSH
32398: LD_INT 20
32400: GREATER
32401: AND
32402: OR
32403: IFFALSE 32407
// exit ;
32405: GO 32781
// if GetFuel ( bulldozer ) < 20 and not GetTag ( bulldozer ) = 21 then
32407: LD_VAR 0 1
32411: PPUSH
32412: CALL_OW 261
32416: PUSH
32417: LD_INT 20
32419: LESS
32420: PUSH
32421: LD_VAR 0 1
32425: PPUSH
32426: CALL_OW 110
32430: PUSH
32431: LD_INT 21
32433: EQUAL
32434: NOT
32435: AND
32436: IFFALSE 32472
// begin ComStop ( bulldozer ) ;
32438: LD_VAR 0 1
32442: PPUSH
32443: CALL_OW 141
// SetTag ( bulldozer , 21 ) ;
32447: LD_VAR 0 1
32451: PPUSH
32452: LD_INT 21
32454: PPUSH
32455: CALL_OW 109
// MCV_Refuel ( bulldozer ) ;
32459: LD_VAR 0 1
32463: PPUSH
32464: CALL 26214 0 1
// exit ;
32468: GO 32781
// end else
32470: GO 32499
// if GetFuel ( bulldozer ) > 20 then
32472: LD_VAR 0 1
32476: PPUSH
32477: CALL_OW 261
32481: PUSH
32482: LD_INT 20
32484: GREATER
32485: IFFALSE 32499
// SetTag ( bulldozer , 0 ) ;
32487: LD_VAR 0 1
32491: PPUSH
32492: LD_INT 0
32494: PPUSH
32495: CALL_OW 109
// list := ListEnvironmentArea ( area ) ;
32499: LD_ADDR_VAR 0 5
32503: PUSH
32504: LD_VAR 0 2
32508: PPUSH
32509: CALL_OW 353
32513: ST_TO_ADDR
// tmp := [ ] ;
32514: LD_ADDR_VAR 0 6
32518: PUSH
32519: EMPTY
32520: ST_TO_ADDR
// for i = 1 to list do
32521: LD_ADDR_VAR 0 4
32525: PUSH
32526: DOUBLE
32527: LD_INT 1
32529: DEC
32530: ST_TO_ADDR
32531: LD_VAR 0 5
32535: PUSH
32536: FOR_TO
32537: IFFALSE 32635
// if IsEnvironmentDestroyable ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) then
32539: LD_VAR 0 5
32543: PUSH
32544: LD_VAR 0 4
32548: ARRAY
32549: PUSH
32550: LD_INT 1
32552: ARRAY
32553: PPUSH
32554: LD_VAR 0 5
32558: PUSH
32559: LD_VAR 0 4
32563: ARRAY
32564: PUSH
32565: LD_INT 2
32567: ARRAY
32568: PPUSH
32569: CALL_OW 554
32573: IFFALSE 32633
// begin tmp := Replace ( tmp , tmp + 1 , [ list [ i ] [ 1 ] , list [ i ] [ 2 ] ] ) ;
32575: LD_ADDR_VAR 0 6
32579: PUSH
32580: LD_VAR 0 6
32584: PPUSH
32585: LD_VAR 0 6
32589: PUSH
32590: LD_INT 1
32592: PLUS
32593: PPUSH
32594: LD_VAR 0 5
32598: PUSH
32599: LD_VAR 0 4
32603: ARRAY
32604: PUSH
32605: LD_INT 1
32607: ARRAY
32608: PUSH
32609: LD_VAR 0 5
32613: PUSH
32614: LD_VAR 0 4
32618: ARRAY
32619: PUSH
32620: LD_INT 2
32622: ARRAY
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PPUSH
32628: CALL_OW 1
32632: ST_TO_ADDR
// end ;
32633: GO 32536
32635: POP
32636: POP
// ComStop ( bulldozer ) ;
32637: LD_VAR 0 1
32641: PPUSH
32642: CALL_OW 141
// hex := [ GetX ( bulldozer ) , GetY ( bulldozer ) ] ;
32646: LD_ADDR_VAR 0 7
32650: PUSH
32651: LD_VAR 0 1
32655: PPUSH
32656: CALL_OW 250
32660: PUSH
32661: LD_VAR 0 1
32665: PPUSH
32666: CALL_OW 251
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: ST_TO_ADDR
// for i = tmp downto 1 do
32675: LD_ADDR_VAR 0 4
32679: PUSH
32680: DOUBLE
32681: LD_VAR 0 6
32685: INC
32686: ST_TO_ADDR
32687: LD_INT 1
32689: PUSH
32690: FOR_DOWNTO
32691: IFFALSE 32779
// begin hex := GetClosestPoint ( hex [ 1 ] , hex [ 2 ] , tmp ) ;
32693: LD_ADDR_VAR 0 7
32697: PUSH
32698: LD_VAR 0 7
32702: PUSH
32703: LD_INT 1
32705: ARRAY
32706: PPUSH
32707: LD_VAR 0 7
32711: PUSH
32712: LD_INT 2
32714: ARRAY
32715: PPUSH
32716: LD_VAR 0 6
32720: PPUSH
32721: CALL 32882 0 3
32725: ST_TO_ADDR
// AddComCutTreeOnHex ( bulldozer , hex [ 1 ] , hex [ 2 ] ) ;
32726: LD_VAR 0 1
32730: PPUSH
32731: LD_VAR 0 7
32735: PUSH
32736: LD_INT 1
32738: ARRAY
32739: PPUSH
32740: LD_VAR 0 7
32744: PUSH
32745: LD_INT 2
32747: ARRAY
32748: PPUSH
32749: CALL 32786 0 3
// tmp := Delete ( tmp , hex [ 3 ] ) ;
32753: LD_ADDR_VAR 0 6
32757: PUSH
32758: LD_VAR 0 6
32762: PPUSH
32763: LD_VAR 0 7
32767: PUSH
32768: LD_INT 3
32770: ARRAY
32771: PPUSH
32772: CALL_OW 3
32776: ST_TO_ADDR
// end ;
32777: GO 32690
32779: POP
32780: POP
// end ;
32781: LD_VAR 0 3
32785: RET
// export function AddComCutTreeOnHex ( bulldozer , x , y ) ; begin
32786: LD_INT 0
32788: PPUSH
// if IsEnvironment ( x , y ) and IsEnvironmentDestroyable ( x , y ) and ValidHex ( x , y ) and HexInfo ( x , y ) = - 1 then
32789: LD_VAR 0 2
32793: PPUSH
32794: LD_VAR 0 3
32798: PPUSH
32799: CALL_OW 351
32803: PUSH
32804: LD_VAR 0 2
32808: PPUSH
32809: LD_VAR 0 3
32813: PPUSH
32814: CALL_OW 554
32818: AND
32819: PUSH
32820: LD_VAR 0 2
32824: PPUSH
32825: LD_VAR 0 3
32829: PPUSH
32830: CALL_OW 488
32834: AND
32835: PUSH
32836: LD_VAR 0 2
32840: PPUSH
32841: LD_VAR 0 3
32845: PPUSH
32846: CALL_OW 428
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: EQUAL
32855: AND
32856: IFFALSE 32877
// AddComMoveXY ( bulldozer , x , y ) ;
32858: LD_VAR 0 1
32862: PPUSH
32863: LD_VAR 0 2
32867: PPUSH
32868: LD_VAR 0 3
32872: PPUSH
32873: CALL_OW 171
// end ;
32877: LD_VAR 0 4
32881: RET
// export function GetClosestPoint ( x , y , list ) ; var i , dist , d , _x , _y , _i ; begin
32882: LD_INT 0
32884: PPUSH
32885: PPUSH
32886: PPUSH
32887: PPUSH
32888: PPUSH
32889: PPUSH
32890: PPUSH
// dist := 99999 ;
32891: LD_ADDR_VAR 0 6
32895: PUSH
32896: LD_INT 99999
32898: ST_TO_ADDR
// for i = 1 to list do
32899: LD_ADDR_VAR 0 5
32903: PUSH
32904: DOUBLE
32905: LD_INT 1
32907: DEC
32908: ST_TO_ADDR
32909: LD_VAR 0 3
32913: PUSH
32914: FOR_TO
32915: IFFALSE 33053
// begin d := GetDistXY ( x , y , list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ;
32917: LD_ADDR_VAR 0 7
32921: PUSH
32922: LD_VAR 0 1
32926: PPUSH
32927: LD_VAR 0 2
32931: PPUSH
32932: LD_VAR 0 3
32936: PUSH
32937: LD_VAR 0 5
32941: ARRAY
32942: PUSH
32943: LD_INT 1
32945: ARRAY
32946: PPUSH
32947: LD_VAR 0 3
32951: PUSH
32952: LD_VAR 0 5
32956: ARRAY
32957: PUSH
32958: LD_INT 2
32960: ARRAY
32961: PPUSH
32962: CALL_OW 298
32966: ST_TO_ADDR
// if d = 0 then
32967: LD_VAR 0 7
32971: PUSH
32972: LD_INT 0
32974: EQUAL
32975: IFFALSE 32979
// continue ;
32977: GO 32914
// if d < dist then
32979: LD_VAR 0 7
32983: PUSH
32984: LD_VAR 0 6
32988: LESS
32989: IFFALSE 33051
// begin _x := list [ i ] [ 1 ] ;
32991: LD_ADDR_VAR 0 8
32995: PUSH
32996: LD_VAR 0 3
33000: PUSH
33001: LD_VAR 0 5
33005: ARRAY
33006: PUSH
33007: LD_INT 1
33009: ARRAY
33010: ST_TO_ADDR
// _y := list [ i ] [ 2 ] ;
33011: LD_ADDR_VAR 0 9
33015: PUSH
33016: LD_VAR 0 3
33020: PUSH
33021: LD_VAR 0 5
33025: ARRAY
33026: PUSH
33027: LD_INT 2
33029: ARRAY
33030: ST_TO_ADDR
// _i := i ;
33031: LD_ADDR_VAR 0 10
33035: PUSH
33036: LD_VAR 0 5
33040: ST_TO_ADDR
// dist := d ;
33041: LD_ADDR_VAR 0 6
33045: PUSH
33046: LD_VAR 0 7
33050: ST_TO_ADDR
// end ; end ;
33051: GO 32914
33053: POP
33054: POP
// result := [ _x , _y , _i , dist ] ;
33055: LD_ADDR_VAR 0 4
33059: PUSH
33060: LD_VAR 0 8
33064: PUSH
33065: LD_VAR 0 9
33069: PUSH
33070: LD_VAR 0 10
33074: PUSH
33075: LD_VAR 0 6
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// end ;
33086: LD_VAR 0 4
33090: RET
// export function SortListByDistance ( list , x , y ) ; var i , j , _x , _y ; begin
33091: LD_INT 0
33093: PPUSH
33094: PPUSH
33095: PPUSH
33096: PPUSH
33097: PPUSH
// for i = 1 to list do
33098: LD_ADDR_VAR 0 5
33102: PUSH
33103: DOUBLE
33104: LD_INT 1
33106: DEC
33107: ST_TO_ADDR
33108: LD_VAR 0 1
33112: PUSH
33113: FOR_TO
33114: IFFALSE 33428
// begin for j = list downto 2 do
33116: LD_ADDR_VAR 0 6
33120: PUSH
33121: DOUBLE
33122: LD_VAR 0 1
33126: INC
33127: ST_TO_ADDR
33128: LD_INT 2
33130: PUSH
33131: FOR_DOWNTO
33132: IFFALSE 33424
// begin if ( GetDistXY ( x , y , list [ j ] [ 1 ] , list [ j ] [ 2 ] ) < GetDistXY ( x , y , list [ j - 1 ] [ 1 ] , list [ j - 1 ] [ 2 ] ) ) then
33134: LD_VAR 0 2
33138: PPUSH
33139: LD_VAR 0 3
33143: PPUSH
33144: LD_VAR 0 1
33148: PUSH
33149: LD_VAR 0 6
33153: ARRAY
33154: PUSH
33155: LD_INT 1
33157: ARRAY
33158: PPUSH
33159: LD_VAR 0 1
33163: PUSH
33164: LD_VAR 0 6
33168: ARRAY
33169: PUSH
33170: LD_INT 2
33172: ARRAY
33173: PPUSH
33174: CALL_OW 298
33178: PUSH
33179: LD_VAR 0 2
33183: PPUSH
33184: LD_VAR 0 3
33188: PPUSH
33189: LD_VAR 0 1
33193: PUSH
33194: LD_VAR 0 6
33198: PUSH
33199: LD_INT 1
33201: MINUS
33202: ARRAY
33203: PUSH
33204: LD_INT 1
33206: ARRAY
33207: PPUSH
33208: LD_VAR 0 1
33212: PUSH
33213: LD_VAR 0 6
33217: PUSH
33218: LD_INT 1
33220: MINUS
33221: ARRAY
33222: PUSH
33223: LD_INT 2
33225: ARRAY
33226: PPUSH
33227: CALL_OW 298
33231: LESS
33232: IFFALSE 33422
// begin _x := list [ j ] [ 1 ] ;
33234: LD_ADDR_VAR 0 7
33238: PUSH
33239: LD_VAR 0 1
33243: PUSH
33244: LD_VAR 0 6
33248: ARRAY
33249: PUSH
33250: LD_INT 1
33252: ARRAY
33253: ST_TO_ADDR
// _y := list [ j ] [ 2 ] ;
33254: LD_ADDR_VAR 0 8
33258: PUSH
33259: LD_VAR 0 1
33263: PUSH
33264: LD_VAR 0 6
33268: ARRAY
33269: PUSH
33270: LD_INT 2
33272: ARRAY
33273: ST_TO_ADDR
// list := Replace2 ( list , j , 1 , list [ j - 1 ] [ 1 ] ) ;
33274: LD_ADDR_VAR 0 1
33278: PUSH
33279: LD_VAR 0 1
33283: PPUSH
33284: LD_VAR 0 6
33288: PPUSH
33289: LD_INT 1
33291: PPUSH
33292: LD_VAR 0 1
33296: PUSH
33297: LD_VAR 0 6
33301: PUSH
33302: LD_INT 1
33304: MINUS
33305: ARRAY
33306: PUSH
33307: LD_INT 1
33309: ARRAY
33310: PPUSH
33311: CALL 31052 0 4
33315: ST_TO_ADDR
// list := Replace2 ( list , j , 2 , list [ j - 1 ] [ 2 ] ) ;
33316: LD_ADDR_VAR 0 1
33320: PUSH
33321: LD_VAR 0 1
33325: PPUSH
33326: LD_VAR 0 6
33330: PPUSH
33331: LD_INT 2
33333: PPUSH
33334: LD_VAR 0 1
33338: PUSH
33339: LD_VAR 0 6
33343: PUSH
33344: LD_INT 1
33346: MINUS
33347: ARRAY
33348: PUSH
33349: LD_INT 2
33351: ARRAY
33352: PPUSH
33353: CALL 31052 0 4
33357: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 1 , _x ) ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_VAR 0 1
33367: PPUSH
33368: LD_VAR 0 6
33372: PUSH
33373: LD_INT 1
33375: MINUS
33376: PPUSH
33377: LD_INT 1
33379: PPUSH
33380: LD_VAR 0 7
33384: PPUSH
33385: CALL 31052 0 4
33389: ST_TO_ADDR
// list := Replace2 ( list , j - 1 , 2 , _y ) ;
33390: LD_ADDR_VAR 0 1
33394: PUSH
33395: LD_VAR 0 1
33399: PPUSH
33400: LD_VAR 0 6
33404: PUSH
33405: LD_INT 1
33407: MINUS
33408: PPUSH
33409: LD_INT 2
33411: PPUSH
33412: LD_VAR 0 8
33416: PPUSH
33417: CALL 31052 0 4
33421: ST_TO_ADDR
// end ; end ;
33422: GO 33131
33424: POP
33425: POP
// end ;
33426: GO 33113
33428: POP
33429: POP
// result := list ;
33430: LD_ADDR_VAR 0 4
33434: PUSH
33435: LD_VAR 0 1
33439: ST_TO_ADDR
// end ;
33440: LD_VAR 0 4
33444: RET
// export function CompareHexHeight ( x1 , y1 , x2 , y2 ) ; begin
33445: LD_INT 0
33447: PPUSH
// result := GetHexInfo ( x1 , y1 ) [ 2 ] - GetHexInfo ( x2 , y2 ) [ 2 ] ;
33448: LD_ADDR_VAR 0 5
33452: PUSH
33453: LD_VAR 0 1
33457: PPUSH
33458: LD_VAR 0 2
33462: PPUSH
33463: CALL_OW 546
33467: PUSH
33468: LD_INT 2
33470: ARRAY
33471: PUSH
33472: LD_VAR 0 3
33476: PPUSH
33477: LD_VAR 0 4
33481: PPUSH
33482: CALL_OW 546
33486: PUSH
33487: LD_INT 2
33489: ARRAY
33490: MINUS
33491: ST_TO_ADDR
// if result < 0 then
33492: LD_VAR 0 5
33496: PUSH
33497: LD_INT 0
33499: LESS
33500: IFFALSE 33517
// result := result * - 1 ;
33502: LD_ADDR_VAR 0 5
33506: PUSH
33507: LD_VAR 0 5
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: MUL
33516: ST_TO_ADDR
// end ;
33517: LD_VAR 0 5
33521: RET
// export function _CutTreeInArea ( bulldozer , area ) ; var i ; begin
33522: LD_INT 0
33524: PPUSH
33525: PPUSH
// area = ListEnvironmentArea ( area ) ;
33526: LD_ADDR_VAR 0 2
33530: PUSH
33531: LD_VAR 0 2
33535: PPUSH
33536: CALL_OW 353
33540: ST_TO_ADDR
// if bulldozer > 0 then
33541: LD_VAR 0 1
33545: PUSH
33546: LD_INT 0
33548: GREATER
33549: IFFALSE 33660
// for i = area downto 1 do
33551: LD_ADDR_VAR 0 4
33555: PUSH
33556: DOUBLE
33557: LD_VAR 0 2
33561: INC
33562: ST_TO_ADDR
33563: LD_INT 1
33565: PUSH
33566: FOR_DOWNTO
33567: IFFALSE 33658
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
33569: LD_VAR 0 2
33573: PUSH
33574: LD_VAR 0 4
33578: ARRAY
33579: PUSH
33580: LD_INT 1
33582: ARRAY
33583: PPUSH
33584: LD_VAR 0 2
33588: PUSH
33589: LD_VAR 0 4
33593: ARRAY
33594: PUSH
33595: LD_INT 2
33597: ARRAY
33598: PPUSH
33599: CALL_OW 351
33603: IFFALSE 33656
// if not HasTask ( bulldozer ) then
33605: LD_VAR 0 1
33609: PPUSH
33610: CALL_OW 314
33614: NOT
33615: IFFALSE 33656
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
33617: LD_VAR 0 1
33621: PPUSH
33622: LD_VAR 0 2
33626: PUSH
33627: LD_VAR 0 4
33631: ARRAY
33632: PUSH
33633: LD_INT 1
33635: ARRAY
33636: PPUSH
33637: LD_VAR 0 2
33641: PUSH
33642: LD_VAR 0 4
33646: ARRAY
33647: PUSH
33648: LD_INT 2
33650: ARRAY
33651: PPUSH
33652: CALL_OW 171
33656: GO 33566
33658: POP
33659: POP
// end ;
33660: LD_VAR 0 3
33664: RET
// export function GetUnitsOutOfArea ( side , type , area ) ; var i , tmp , pom ; begin
33665: LD_INT 0
33667: PPUSH
33668: PPUSH
33669: PPUSH
33670: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , type ] ] ) ;
33671: LD_ADDR_VAR 0 6
33675: PUSH
33676: LD_INT 22
33678: PUSH
33679: LD_VAR 0 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 21
33690: PUSH
33691: LD_VAR 0 2
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PPUSH
33704: CALL_OW 69
33708: ST_TO_ADDR
// pom := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , type ] ] ) ;
33709: LD_ADDR_VAR 0 7
33713: PUSH
33714: LD_VAR 0 3
33718: PPUSH
33719: LD_INT 22
33721: PUSH
33722: LD_VAR 0 1
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 21
33733: PUSH
33734: LD_VAR 0 2
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PPUSH
33747: CALL_OW 70
33751: ST_TO_ADDR
// if tmp and pom then
33752: LD_VAR 0 6
33756: PUSH
33757: LD_VAR 0 7
33761: AND
33762: IFFALSE 33782
// result := tmp diff pom else
33764: LD_ADDR_VAR 0 4
33768: PUSH
33769: LD_VAR 0 6
33773: PUSH
33774: LD_VAR 0 7
33778: DIFF
33779: ST_TO_ADDR
33780: GO 33790
// result := false ;
33782: LD_ADDR_VAR 0 4
33786: PUSH
33787: LD_INT 0
33789: ST_TO_ADDR
// end ;
33790: LD_VAR 0 4
33794: RET
// export function SavePosition ( unit ) ; begin
33795: LD_INT 0
33797: PPUSH
// SetRememberedX ( unit , GetX ( unit ) ) ;
33798: LD_VAR 0 1
33802: PPUSH
33803: LD_VAR 0 1
33807: PPUSH
33808: CALL_OW 250
33812: PPUSH
33813: CALL_OW 231
// SetRememberedY ( unit , GetY ( unit ) ) ;
33817: LD_VAR 0 1
33821: PPUSH
33822: LD_VAR 0 1
33826: PPUSH
33827: CALL_OW 251
33831: PPUSH
33832: CALL_OW 232
// end ;
33836: LD_VAR 0 2
33840: RET
// export function GetPosition ( unit ) ; begin
33841: LD_INT 0
33843: PPUSH
// result := [ GetRememberedX ( unit ) , GetRememberedY ( unit ) ] ;
33844: LD_ADDR_VAR 0 2
33848: PUSH
33849: LD_VAR 0 1
33853: PPUSH
33854: CALL_OW 252
33858: PUSH
33859: LD_VAR 0 1
33863: PPUSH
33864: CALL_OW 253
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: ST_TO_ADDR
// end ;
33873: LD_VAR 0 2
33877: RET
// export function DestinationReachable ( unit , x , y ) ; begin
33878: LD_INT 0
33880: PPUSH
// if unit in unreachableList then
33881: LD_VAR 0 1
33885: PUSH
33886: LD_EXP 32
33890: IN
33891: IFFALSE 33909
// unreachableList := unreachableList diff unit ;
33893: LD_ADDR_EXP 32
33897: PUSH
33898: LD_EXP 32
33902: PUSH
33903: LD_VAR 0 1
33907: DIFF
33908: ST_TO_ADDR
// if ValidHex ( x , y ) then
33909: LD_VAR 0 2
33913: PPUSH
33914: LD_VAR 0 3
33918: PPUSH
33919: CALL_OW 488
33923: IFFALSE 33949
// ComAttackUnit ( unit , HexInfo ( x , y ) ) ;
33925: LD_VAR 0 1
33929: PPUSH
33930: LD_VAR 0 2
33934: PPUSH
33935: LD_VAR 0 3
33939: PPUSH
33940: CALL_OW 428
33944: PPUSH
33945: CALL_OW 115
// Wait ( 3 ) ;
33949: LD_INT 3
33951: PPUSH
33952: CALL_OW 67
// if unit in unreachableList then
33956: LD_VAR 0 1
33960: PUSH
33961: LD_EXP 32
33965: IN
33966: IFFALSE 33978
// result := false else
33968: LD_ADDR_VAR 0 4
33972: PUSH
33973: LD_INT 0
33975: ST_TO_ADDR
33976: GO 33986
// result := true ;
33978: LD_ADDR_VAR 0 4
33982: PUSH
33983: LD_INT 1
33985: ST_TO_ADDR
// end ; end_of_file
33986: LD_VAR 0 4
33990: RET
// export mc_game_live , mc_crates_list ; every 0 0$01 trigger mc_game_live do var i ;
33991: LD_EXP 33
33995: IFFALSE 34057
33997: GO 33999
33999: DISABLE
34000: LD_INT 0
34002: PPUSH
// begin enable ;
34003: ENABLE
// for i = 1 to mc_crates_list do
34004: LD_ADDR_VAR 0 1
34008: PUSH
34009: DOUBLE
34010: LD_INT 1
34012: DEC
34013: ST_TO_ADDR
34014: LD_EXP 34
34018: PUSH
34019: FOR_TO
34020: IFFALSE 34051
// MCT_Crates ( mc_crates_list [ i ] , 5 , 50 , 0 0$20 , 20 ) ;
34022: LD_EXP 34
34026: PUSH
34027: LD_VAR 0 1
34031: ARRAY
34032: PPUSH
34033: LD_INT 5
34035: PPUSH
34036: LD_INT 50
34038: PPUSH
34039: LD_INT 700
34041: PPUSH
34042: LD_INT 20
34044: PPUSH
34045: CALL 24421 0 5
34049: GO 34019
34051: POP
34052: POP
// MC_Game ( ) ;
34053: CALL 34060 0 0
// end ;
34057: PPOPN 1
34059: END
// export function MC_Game ( ) ; var i , side , un ; begin
34060: LD_INT 0
34062: PPUSH
34063: PPUSH
34064: PPUSH
34065: PPUSH
// if not isTest then
34066: LD_EXP 1
34070: NOT
34071: IFFALSE 34091
// MC_Show ( [ #tick , tick ] ) else
34073: LD_STRING #tick
34075: PUSH
34076: LD_OWVAR 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PPUSH
34085: CALL 8505 0 1
34089: GO 34100
// MC_Show ( debug_string ) ;
34091: LD_EXP 2
34095: PPUSH
34096: CALL 8505 0 1
// for side = 1 to 8 do
34100: LD_ADDR_VAR 0 3
34104: PUSH
34105: DOUBLE
34106: LD_INT 1
34108: DEC
34109: ST_TO_ADDR
34110: LD_INT 8
34112: PUSH
34113: FOR_TO
34114: IFFALSE 36114
// begin if MREG_SidesList [ side ] = 0 or MCF_All ( side , [ ] ) = 0 then
34116: LD_EXP 41
34120: PUSH
34121: LD_VAR 0 3
34125: ARRAY
34126: PUSH
34127: LD_INT 0
34129: EQUAL
34130: PUSH
34131: LD_VAR 0 3
34135: PPUSH
34136: EMPTY
34137: PPUSH
34138: CALL 11722 0 2
34142: PUSH
34143: LD_INT 0
34145: EQUAL
34146: OR
34147: IFFALSE 34151
// continue ;
34149: GO 34113
// MC_ClassManager ( side , MCT_EnemyNearBase ( side ) ) ;
34151: LD_VAR 0 3
34155: PPUSH
34156: LD_VAR 0 3
34160: PPUSH
34161: CALL 24942 0 1
34165: PPUSH
34166: CALL 36121 0 2
// if MREG_Attackers [ side ] [ 1 ] > 0 and MREG_ToAttack [ side ] [ 1 ] = 0 and not MCF_Tag ( side , 7 , [ ] ) then
34170: LD_EXP 73
34174: PUSH
34175: LD_VAR 0 3
34179: ARRAY
34180: PUSH
34181: LD_INT 1
34183: ARRAY
34184: PUSH
34185: LD_INT 0
34187: GREATER
34188: PUSH
34189: LD_EXP 71
34193: PUSH
34194: LD_VAR 0 3
34198: ARRAY
34199: PUSH
34200: LD_INT 1
34202: ARRAY
34203: PUSH
34204: LD_INT 0
34206: EQUAL
34207: AND
34208: PUSH
34209: LD_VAR 0 3
34213: PPUSH
34214: LD_INT 7
34216: PPUSH
34217: EMPTY
34218: PPUSH
34219: CALL 12290 0 3
34223: NOT
34224: AND
34225: IFFALSE 34296
// begin if side = 1 then
34227: LD_VAR 0 3
34231: PUSH
34232: LD_INT 1
34234: EQUAL
34235: IFFALSE 34244
// RaiseSailEvent ( 101 ) ;
34237: LD_INT 101
34239: PPUSH
34240: CALL_OW 427
// if side = 4 then
34244: LD_VAR 0 3
34248: PUSH
34249: LD_INT 4
34251: EQUAL
34252: IFFALSE 34261
// RaiseSailEvent ( 102 ) ;
34254: LD_INT 102
34256: PPUSH
34257: CALL_OW 427
// for i in MREG_Attackers [ side ] do
34261: LD_ADDR_VAR 0 2
34265: PUSH
34266: LD_EXP 73
34270: PUSH
34271: LD_VAR 0 3
34275: ARRAY
34276: PUSH
34277: FOR_IN
34278: IFFALSE 34294
// SetTag ( i , 7 ) ;
34280: LD_VAR 0 2
34284: PPUSH
34285: LD_INT 7
34287: PPUSH
34288: CALL_OW 109
34292: GO 34277
34294: POP
34295: POP
// end ; if MCF_Tag ( side , 7 , [ ] ) then
34296: LD_VAR 0 3
34300: PPUSH
34301: LD_INT 7
34303: PPUSH
34304: EMPTY
34305: PPUSH
34306: CALL 12290 0 3
34310: IFFALSE 34336
// begin MC_Attack ( side , MCF_Tag ( side , 7 , [ ] ) ) ;
34312: LD_VAR 0 3
34316: PPUSH
34317: LD_VAR 0 3
34321: PPUSH
34322: LD_INT 7
34324: PPUSH
34325: EMPTY
34326: PPUSH
34327: CALL 12290 0 3
34331: PPUSH
34332: CALL 8432 0 2
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) then
34336: LD_VAR 0 3
34340: PPUSH
34341: CALL 17970 0 1
34345: PUSH
34346: LD_VAR 0 3
34350: PPUSH
34351: CALL 11626 0 1
34355: AND
34356: IFFALSE 34367
// MCL_Start ( side ) ;
34358: LD_VAR 0 3
34362: PPUSH
34363: CALL 17927 0 1
// MREG_Heal := Replace ( MREG_Heal , side , MCP_Filter ( side ) ) ;
34367: LD_ADDR_EXP 37
34371: PUSH
34372: LD_EXP 37
34376: PPUSH
34377: LD_VAR 0 3
34381: PPUSH
34382: LD_VAR 0 3
34386: PPUSH
34387: CALL 19227 0 1
34391: PPUSH
34392: CALL_OW 1
34396: ST_TO_ADDR
// MREG_ToRepair = Replace ( MREG_ToRepair , side , MCB_FilterHLevel ( side ) ) ;
34397: LD_ADDR_EXP 49
34401: PUSH
34402: LD_EXP 49
34406: PPUSH
34407: LD_VAR 0 3
34411: PPUSH
34412: LD_VAR 0 3
34416: PPUSH
34417: CALL 11040 0 1
34421: PPUSH
34422: CALL_OW 1
34426: ST_TO_ADDR
// if MCF_Get ( side , [ f_type , unit_vehicle ] ) then
34427: LD_VAR 0 3
34431: PPUSH
34432: LD_INT 21
34434: PUSH
34435: LD_INT 2
34437: PUSH
34438: EMPTY
34439: LIST
34440: LIST
34441: PPUSH
34442: CALL 11587 0 2
34446: IFFALSE 34457
// MCV_CheckStatus ( side ) ;
34448: LD_VAR 0 3
34452: PPUSH
34453: CALL 27124 0 1
// if MREG_ForSide ( side , MREG_ToChangeClass ) then
34457: LD_VAR 0 3
34461: PPUSH
34462: LD_EXP 55
34466: PPUSH
34467: CALL 42921 0 2
34471: IFFALSE 34556
// begin for i = MREG_ToChangeClass downto 1 do
34473: LD_ADDR_VAR 0 2
34477: PUSH
34478: DOUBLE
34479: LD_EXP 55
34483: INC
34484: ST_TO_ADDR
34485: LD_INT 1
34487: PUSH
34488: FOR_DOWNTO
34489: IFFALSE 34554
// begin if MREG_ToChangeClass [ i ] [ 1 ] = side then
34491: LD_EXP 55
34495: PUSH
34496: LD_VAR 0 2
34500: ARRAY
34501: PUSH
34502: LD_INT 1
34504: ARRAY
34505: PUSH
34506: LD_VAR 0 3
34510: EQUAL
34511: IFFALSE 34552
// begin MCH_ChangeClass ( side , MREG_ToChangeClass [ i ] [ 2 ] , MREG_ToChangeClass [ i ] [ 3 ] ) ;
34513: LD_VAR 0 3
34517: PPUSH
34518: LD_EXP 55
34522: PUSH
34523: LD_VAR 0 2
34527: ARRAY
34528: PUSH
34529: LD_INT 2
34531: ARRAY
34532: PPUSH
34533: LD_EXP 55
34537: PUSH
34538: LD_VAR 0 2
34542: ARRAY
34543: PUSH
34544: LD_INT 3
34546: ARRAY
34547: PPUSH
34548: CALL 16494 0 3
// end ; end ;
34552: GO 34488
34554: POP
34555: POP
// end ; if 1 in MREG_ApeOptions [ side ] then
34556: LD_INT 1
34558: PUSH
34559: LD_EXP 40
34563: PUSH
34564: LD_VAR 0 3
34568: ARRAY
34569: IN
34570: IFFALSE 34581
// begin MCN_TrainApe ( side ) ;
34572: LD_VAR 0 3
34576: PPUSH
34577: CALL 18880 0 1
// end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
34581: LD_VAR 0 3
34585: PPUSH
34586: LD_INT 30
34588: PUSH
34589: LD_INT 3
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PPUSH
34596: CALL 11587 0 2
34600: IFFALSE 34774
// begin if MCF_Tag ( side , 10 , [ ] ) then
34602: LD_VAR 0 3
34606: PPUSH
34607: LD_INT 10
34609: PPUSH
34610: EMPTY
34611: PPUSH
34612: CALL 12290 0 3
34616: IFFALSE 34663
// begin ComRecycle ( MCF_Tag ( side , 10 , [ ] ) , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) ;
34618: LD_VAR 0 3
34622: PPUSH
34623: LD_INT 10
34625: PPUSH
34626: EMPTY
34627: PPUSH
34628: CALL 12290 0 3
34632: PPUSH
34633: LD_VAR 0 3
34637: PPUSH
34638: LD_INT 30
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PPUSH
34648: CALL 11587 0 2
34652: PUSH
34653: LD_INT 1
34655: ARRAY
34656: PPUSH
34657: CALL_OW 168
// end else
34661: GO 34774
// if MREG_ToConstruct [ side ] then
34663: LD_EXP 53
34667: PUSH
34668: LD_VAR 0 3
34672: ARRAY
34673: IFFALSE 34774
// begin MCV_Produce ( side , MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] , [ MREG_ToConstruct [ side ] [ 1 ] , MREG_ToConstruct [ side ] [ 2 ] , MREG_ToConstruct [ side ] [ 3 ] , MREG_ToConstruct [ side ] [ 4 ] ] ) ;
34675: LD_VAR 0 3
34679: PPUSH
34680: LD_VAR 0 3
34684: PPUSH
34685: LD_INT 30
34687: PUSH
34688: LD_INT 3
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PPUSH
34695: CALL 11587 0 2
34699: PUSH
34700: LD_INT 1
34702: ARRAY
34703: PPUSH
34704: LD_EXP 53
34708: PUSH
34709: LD_VAR 0 3
34713: ARRAY
34714: PUSH
34715: LD_INT 1
34717: ARRAY
34718: PUSH
34719: LD_EXP 53
34723: PUSH
34724: LD_VAR 0 3
34728: ARRAY
34729: PUSH
34730: LD_INT 2
34732: ARRAY
34733: PUSH
34734: LD_EXP 53
34738: PUSH
34739: LD_VAR 0 3
34743: ARRAY
34744: PUSH
34745: LD_INT 3
34747: ARRAY
34748: PUSH
34749: LD_EXP 53
34753: PUSH
34754: LD_VAR 0 3
34758: ARRAY
34759: PUSH
34760: LD_INT 4
34762: ARRAY
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: PPUSH
34770: CALL 25432 0 3
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) and MREG_ForSide ( side , MREG_TurretWeapon ) and FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_turret ] , [ f_btype , b_bunker ] ] , [ f_bweapon , 0 ] ] ) then
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 30
34781: PUSH
34782: LD_INT 3
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PPUSH
34789: CALL 11587 0 2
34793: PUSH
34794: LD_VAR 0 3
34798: PPUSH
34799: LD_EXP 45
34803: PPUSH
34804: CALL 42921 0 2
34808: AND
34809: PUSH
34810: LD_INT 22
34812: PUSH
34813: LD_VAR 0 3
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: PUSH
34825: LD_INT 30
34827: PUSH
34828: LD_INT 33
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 30
34837: PUSH
34838: LD_INT 32
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 35
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: LIST
34864: PPUSH
34865: CALL_OW 69
34869: AND
34870: IFFALSE 34881
// MCV_Turret ( side ) ;
34872: LD_VAR 0 3
34876: PPUSH
34877: CALL 25869 0 1
// if MREG_Bulldozer [ side ] > 1 and MCT_EnemyNearBase ( side ) = 0 then
34881: LD_EXP 44
34885: PUSH
34886: LD_VAR 0 3
34890: ARRAY
34891: PUSH
34892: LD_INT 1
34894: GREATER
34895: PUSH
34896: LD_VAR 0 3
34900: PPUSH
34901: CALL 24942 0 1
34905: PUSH
34906: LD_INT 0
34908: EQUAL
34909: AND
34910: IFFALSE 35072
// begin if ListEnvironmentArea ( MREG_Bulldozer [ side ] [ 1 ] ) then
34912: LD_EXP 44
34916: PUSH
34917: LD_VAR 0 3
34921: ARRAY
34922: PUSH
34923: LD_INT 1
34925: ARRAY
34926: PPUSH
34927: CALL_OW 353
34931: IFFALSE 34969
// CutTreeInArea ( MREG_Bulldozer [ side ] [ 2 ] , MREG_Bulldozer [ side ] [ 1 ] ) else
34933: LD_EXP 44
34937: PUSH
34938: LD_VAR 0 3
34942: ARRAY
34943: PUSH
34944: LD_INT 2
34946: ARRAY
34947: PPUSH
34948: LD_EXP 44
34952: PUSH
34953: LD_VAR 0 3
34957: ARRAY
34958: PUSH
34959: LD_INT 1
34961: ARRAY
34962: PPUSH
34963: CALL 32350 0 2
34967: GO 35072
// if MCF_Get ( side , [ f_btype , b_factory ] ) then
34969: LD_VAR 0 3
34973: PPUSH
34974: LD_INT 30
34976: PUSH
34977: LD_INT 3
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: PPUSH
34984: CALL 11587 0 2
34988: IFFALSE 35072
// if BuildingStatus ( MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ) = bs_idle then
34990: LD_VAR 0 3
34994: PPUSH
34995: LD_INT 30
34997: PUSH
34998: LD_INT 3
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PPUSH
35005: CALL 11587 0 2
35009: PUSH
35010: LD_INT 1
35012: ARRAY
35013: PPUSH
35014: CALL_OW 461
35018: PUSH
35019: LD_INT 2
35021: EQUAL
35022: IFFALSE 35072
// begin SetTag ( MREG_Bulldozer [ side ] [ 2 ] , 10 ) ;
35024: LD_EXP 44
35028: PUSH
35029: LD_VAR 0 3
35033: ARRAY
35034: PUSH
35035: LD_INT 2
35037: ARRAY
35038: PPUSH
35039: LD_INT 10
35041: PPUSH
35042: CALL_OW 109
// MREG_Bulldozer := Replace ( MREG_Bulldozer , side , [ 0 ] ) ;
35046: LD_ADDR_EXP 44
35050: PUSH
35051: LD_EXP 44
35055: PPUSH
35056: LD_VAR 0 3
35060: PPUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: PPUSH
35067: CALL_OW 1
35071: ST_TO_ADDR
// end ; end ; if MCF_Get ( side , [ f_control , control_remote ] ) then
35072: LD_VAR 0 3
35076: PPUSH
35077: LD_INT 33
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PPUSH
35087: CALL 11587 0 2
35091: IFFALSE 35131
// MCV_RemoteControl ( side , GetNation ( MCF_Get ( side , [ f_control , control_remote ] ) [ 1 ] ) ) ;
35093: LD_VAR 0 3
35097: PPUSH
35098: LD_VAR 0 3
35102: PPUSH
35103: LD_INT 33
35105: PUSH
35106: LD_INT 2
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PPUSH
35113: CALL 11587 0 2
35117: PUSH
35118: LD_INT 1
35120: ARRAY
35121: PPUSH
35122: CALL_OW 248
35126: PPUSH
35127: CALL 26423 0 2
// if MREG_ToRepair [ side ] then
35131: LD_EXP 49
35135: PUSH
35136: LD_VAR 0 3
35140: ARRAY
35141: IFFALSE 35154
// begin MCB_Repair ( side ) ;
35143: LD_VAR 0 3
35147: PPUSH
35148: CALL 11327 0 1
// end else
35152: GO 36067
// if MREG_ForSide ( side , MREG_ToUpLab ) and MREG_ForSide ( side , MREG_LabList ) then
35154: LD_VAR 0 3
35158: PPUSH
35159: LD_EXP 51
35163: PPUSH
35164: CALL 42921 0 2
35168: PUSH
35169: LD_VAR 0 3
35173: PPUSH
35174: LD_EXP 42
35178: PPUSH
35179: CALL 42921 0 2
35183: AND
35184: IFFALSE 35392
// begin for i = 1 to MREG_ToUpLab do
35186: LD_ADDR_VAR 0 2
35190: PUSH
35191: DOUBLE
35192: LD_INT 1
35194: DEC
35195: ST_TO_ADDR
35196: LD_EXP 51
35200: PUSH
35201: FOR_TO
35202: IFFALSE 35388
// if MREG_ToUpLab [ i ] [ 1 ] = side then
35204: LD_EXP 51
35208: PUSH
35209: LD_VAR 0 2
35213: ARRAY
35214: PUSH
35215: LD_INT 1
35217: ARRAY
35218: PUSH
35219: LD_VAR 0 3
35223: EQUAL
35224: IFFALSE 35386
// begin if MREG_ToUpLab [ i ] [ 2 ] and MREG_ToUpLab [ i ] [ 3 ] then
35226: LD_EXP 51
35230: PUSH
35231: LD_VAR 0 2
35235: ARRAY
35236: PUSH
35237: LD_INT 2
35239: ARRAY
35240: PUSH
35241: LD_EXP 51
35245: PUSH
35246: LD_VAR 0 2
35250: ARRAY
35251: PUSH
35252: LD_INT 3
35254: ARRAY
35255: AND
35256: IFFALSE 35384
// if ( MCB_UpgradeLab ( side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ) then
35258: LD_VAR 0 3
35262: PPUSH
35263: LD_EXP 51
35267: PUSH
35268: LD_VAR 0 2
35272: ARRAY
35273: PUSH
35274: LD_INT 2
35276: ARRAY
35277: PPUSH
35278: LD_EXP 51
35282: PUSH
35283: LD_VAR 0 2
35287: ARRAY
35288: PUSH
35289: LD_INT 3
35291: ARRAY
35292: PPUSH
35293: CALL 8851 0 3
35297: IFFALSE 35384
// begin MREG_ToUpLab := MC_RegistryDelete ( MREG_ToUpLab , side , MREG_ToUpLab [ i ] [ 2 ] , MREG_ToUpLab [ i ] [ 3 ] ) ;
35299: LD_ADDR_EXP 51
35303: PUSH
35304: LD_EXP 51
35308: PPUSH
35309: LD_VAR 0 3
35313: PPUSH
35314: LD_EXP 51
35318: PUSH
35319: LD_VAR 0 2
35323: ARRAY
35324: PUSH
35325: LD_INT 2
35327: ARRAY
35328: PPUSH
35329: LD_EXP 51
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_INT 3
35342: ARRAY
35343: PPUSH
35344: CALL 41973 0 4
35348: ST_TO_ADDR
// MREG_LabList := MC_RegistryDelete ( MREG_LabList , side , MREG_LabList [ 1 ] [ 2 ] , [ ] ) ;
35349: LD_ADDR_EXP 42
35353: PUSH
35354: LD_EXP 42
35358: PPUSH
35359: LD_VAR 0 3
35363: PPUSH
35364: LD_EXP 42
35368: PUSH
35369: LD_INT 1
35371: ARRAY
35372: PUSH
35373: LD_INT 2
35375: ARRAY
35376: PPUSH
35377: EMPTY
35378: PPUSH
35379: CALL 41973 0 4
35383: ST_TO_ADDR
// end ; break ;
35384: GO 35388
// end ;
35386: GO 35201
35388: POP
35389: POP
// end else
35390: GO 36067
// if MREG_ForSide ( side , MREG_ToUpdate ) then
35392: LD_VAR 0 3
35396: PPUSH
35397: LD_EXP 50
35401: PPUSH
35402: CALL 42921 0 2
35406: IFFALSE 35480
// begin for i = 1 to MREG_ToUpdate do
35408: LD_ADDR_VAR 0 2
35412: PUSH
35413: DOUBLE
35414: LD_INT 1
35416: DEC
35417: ST_TO_ADDR
35418: LD_EXP 50
35422: PUSH
35423: FOR_TO
35424: IFFALSE 35476
// if MREG_ToUpdate [ i ] [ 1 ] = side then
35426: LD_EXP 50
35430: PUSH
35431: LD_VAR 0 2
35435: ARRAY
35436: PUSH
35437: LD_INT 1
35439: ARRAY
35440: PUSH
35441: LD_VAR 0 3
35445: EQUAL
35446: IFFALSE 35474
// begin MCB_Upgrade ( side , MREG_ToUpdate [ i ] [ 2 ] ) ;
35448: LD_VAR 0 3
35452: PPUSH
35453: LD_EXP 50
35457: PUSH
35458: LD_VAR 0 2
35462: ARRAY
35463: PUSH
35464: LD_INT 2
35466: ARRAY
35467: PPUSH
35468: CALL 8687 0 2
// break ;
35472: GO 35476
// end ;
35474: GO 35423
35476: POP
35477: POP
// end else
35478: GO 36067
// if MCF_Get ( side , [ f_constructed ] ) then
35480: LD_VAR 0 3
35484: PPUSH
35485: LD_INT 57
35487: PUSH
35488: EMPTY
35489: LIST
35490: PPUSH
35491: CALL 11587 0 2
35495: IFFALSE 35528
// MCB_Complete ( side , MCF_Get ( side , [ f_constructed ] ) [ 1 ] ) else
35497: LD_VAR 0 3
35501: PPUSH
35502: LD_VAR 0 3
35506: PPUSH
35507: LD_INT 57
35509: PUSH
35510: EMPTY
35511: LIST
35512: PPUSH
35513: CALL 11587 0 2
35517: PUSH
35518: LD_INT 1
35520: ARRAY
35521: PPUSH
35522: CALL 10931 0 2
35526: GO 36067
// if MREG_ForSide ( side , MREG_ToBuild ) and not BuildingsInProgress ( side ) and MCT_EnemyNearBase ( side ) = 0 then
35528: LD_VAR 0 3
35532: PPUSH
35533: LD_EXP 48
35537: PPUSH
35538: CALL 42921 0 2
35542: PUSH
35543: LD_VAR 0 3
35547: PPUSH
35548: CALL_OW 345
35552: NOT
35553: AND
35554: PUSH
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL 24942 0 1
35564: PUSH
35565: LD_INT 0
35567: EQUAL
35568: AND
35569: IFFALSE 35968
// begin for i = 1 to MREG_ToBuild do
35571: LD_ADDR_VAR 0 2
35575: PUSH
35576: DOUBLE
35577: LD_INT 1
35579: DEC
35580: ST_TO_ADDR
35581: LD_EXP 48
35585: PUSH
35586: FOR_TO
35587: IFFALSE 35964
// if MREG_ToBuild [ i ] [ 1 ] = side then
35589: LD_EXP 48
35593: PUSH
35594: LD_VAR 0 2
35598: ARRAY
35599: PUSH
35600: LD_INT 1
35602: ARRAY
35603: PUSH
35604: LD_VAR 0 3
35608: EQUAL
35609: IFFALSE 35962
// begin if isEditor and IsEnvironment ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) then
35611: LD_OWVAR 84
35615: PUSH
35616: LD_EXP 48
35620: PUSH
35621: LD_VAR 0 2
35625: ARRAY
35626: PUSH
35627: LD_INT 3
35629: ARRAY
35630: PUSH
35631: LD_INT 1
35633: ARRAY
35634: PPUSH
35635: LD_EXP 48
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 3
35648: ARRAY
35649: PUSH
35650: LD_INT 2
35652: ARRAY
35653: PPUSH
35654: CALL_OW 351
35658: AND
35659: IFFALSE 35703
// MCT_RemovePlace ( MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] ) ;
35661: LD_EXP 48
35665: PUSH
35666: LD_VAR 0 2
35670: ARRAY
35671: PUSH
35672: LD_INT 3
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PPUSH
35680: LD_EXP 48
35684: PUSH
35685: LD_VAR 0 2
35689: ARRAY
35690: PUSH
35691: LD_INT 3
35693: ARRAY
35694: PUSH
35695: LD_INT 2
35697: ARRAY
35698: PPUSH
35699: CALL 22735 0 2
// if MREG_ToBuild [ i ] [ 2 ] = b_depot then
35703: LD_EXP 48
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_INT 2
35716: ARRAY
35717: PUSH
35718: LD_INT 0
35720: EQUAL
35721: IFFALSE 35791
// MCB_Depot ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35723: LD_VAR 0 3
35727: PPUSH
35728: LD_EXP 48
35732: PUSH
35733: LD_VAR 0 2
35737: ARRAY
35738: PUSH
35739: LD_INT 3
35741: ARRAY
35742: PUSH
35743: LD_INT 1
35745: ARRAY
35746: PPUSH
35747: LD_EXP 48
35751: PUSH
35752: LD_VAR 0 2
35756: ARRAY
35757: PUSH
35758: LD_INT 3
35760: ARRAY
35761: PUSH
35762: LD_INT 2
35764: ARRAY
35765: PPUSH
35766: LD_EXP 48
35770: PUSH
35771: LD_VAR 0 2
35775: ARRAY
35776: PUSH
35777: LD_INT 3
35779: ARRAY
35780: PUSH
35781: LD_INT 3
35783: ARRAY
35784: PPUSH
35785: CALL 8523 0 4
35789: GO 35960
// if MREG_ToBuild [ i ] [ 2 ] = b_lab then
35791: LD_EXP 48
35795: PUSH
35796: LD_VAR 0 2
35800: ARRAY
35801: PUSH
35802: LD_INT 2
35804: ARRAY
35805: PUSH
35806: LD_INT 6
35808: EQUAL
35809: IFFALSE 35879
// MCB_Lab ( side , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) else
35811: LD_VAR 0 3
35815: PPUSH
35816: LD_EXP 48
35820: PUSH
35821: LD_VAR 0 2
35825: ARRAY
35826: PUSH
35827: LD_INT 3
35829: ARRAY
35830: PUSH
35831: LD_INT 1
35833: ARRAY
35834: PPUSH
35835: LD_EXP 48
35839: PUSH
35840: LD_VAR 0 2
35844: ARRAY
35845: PUSH
35846: LD_INT 3
35848: ARRAY
35849: PUSH
35850: LD_INT 2
35852: ARRAY
35853: PPUSH
35854: LD_EXP 48
35858: PUSH
35859: LD_VAR 0 2
35863: ARRAY
35864: PUSH
35865: LD_INT 3
35867: ARRAY
35868: PUSH
35869: LD_INT 3
35871: ARRAY
35872: PPUSH
35873: CALL 8652 0 4
35877: GO 35960
// MCB_Build ( side , MREG_ToBuild [ i ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 1 ] , MREG_ToBuild [ i ] [ 3 ] [ 2 ] , MREG_ToBuild [ i ] [ 3 ] [ 3 ] ) ;
35879: LD_VAR 0 3
35883: PPUSH
35884: LD_EXP 48
35888: PUSH
35889: LD_VAR 0 2
35893: ARRAY
35894: PUSH
35895: LD_INT 2
35897: ARRAY
35898: PPUSH
35899: LD_EXP 48
35903: PUSH
35904: LD_VAR 0 2
35908: ARRAY
35909: PUSH
35910: LD_INT 3
35912: ARRAY
35913: PUSH
35914: LD_INT 1
35916: ARRAY
35917: PPUSH
35918: LD_EXP 48
35922: PUSH
35923: LD_VAR 0 2
35927: ARRAY
35928: PUSH
35929: LD_INT 3
35931: ARRAY
35932: PUSH
35933: LD_INT 2
35935: ARRAY
35936: PPUSH
35937: LD_EXP 48
35941: PUSH
35942: LD_VAR 0 2
35946: ARRAY
35947: PUSH
35948: LD_INT 3
35950: ARRAY
35951: PUSH
35952: LD_INT 3
35954: ARRAY
35955: PPUSH
35956: CALL 10156 0 5
// break ;
35960: GO 35964
// end ;
35962: GO 35586
35964: POP
35965: POP
// end else
35966: GO 36067
// if MREG_ForSide ( side , MREG_ToDismantle ) and MCT_EnemyNearBase ( side ) = 0 then
35968: LD_VAR 0 3
35972: PPUSH
35973: LD_EXP 54
35977: PPUSH
35978: CALL 42921 0 2
35982: PUSH
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL 24942 0 1
35992: PUSH
35993: LD_INT 0
35995: EQUAL
35996: AND
35997: IFFALSE 36067
// begin for i = 1 to MREG_ToDismantle do
35999: LD_ADDR_VAR 0 2
36003: PUSH
36004: DOUBLE
36005: LD_INT 1
36007: DEC
36008: ST_TO_ADDR
36009: LD_EXP 54
36013: PUSH
36014: FOR_TO
36015: IFFALSE 36065
// if MREG_ToDismantle [ i ] [ 1 ] = side then
36017: LD_EXP 54
36021: PUSH
36022: LD_VAR 0 2
36026: ARRAY
36027: PUSH
36028: LD_INT 1
36030: ARRAY
36031: PUSH
36032: LD_VAR 0 3
36036: EQUAL
36037: IFFALSE 36063
// begin MCB_Dismantle ( side , MREG_ToDismantle [ i ] [ 2 ] ) ;
36039: LD_VAR 0 3
36043: PPUSH
36044: LD_EXP 54
36048: PUSH
36049: LD_VAR 0 2
36053: ARRAY
36054: PUSH
36055: LD_INT 2
36057: ARRAY
36058: PPUSH
36059: CALL 10822 0 2
// end ;
36063: GO 36014
36065: POP
36066: POP
// end ; if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCT_EnemyNearBase ( side ) = 0 then
36067: LD_VAR 0 3
36071: PPUSH
36072: LD_INT 30
36074: PUSH
36075: LD_INT 1
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PPUSH
36082: CALL 11587 0 2
36086: PUSH
36087: LD_VAR 0 3
36091: PPUSH
36092: CALL 24942 0 1
36096: PUSH
36097: LD_INT 0
36099: EQUAL
36100: AND
36101: IFFALSE 36112
// MCT_CollectCrates ( side ) ;
36103: LD_VAR 0 3
36107: PPUSH
36108: CALL 23881 0 1
// end ;
36112: GO 34113
36114: POP
36115: POP
// end ;
36116: LD_VAR 0 1
36120: RET
// export function MC_ClassManager ( side , mode ) ; var i , j , x , y , k , un , ct , b , tmp , sol , eng , mech , sci , all ; begin
36121: LD_INT 0
36123: PPUSH
36124: PPUSH
36125: PPUSH
36126: PPUSH
36127: PPUSH
36128: PPUSH
36129: PPUSH
36130: PPUSH
36131: PPUSH
36132: PPUSH
36133: PPUSH
36134: PPUSH
36135: PPUSH
36136: PPUSH
36137: PPUSH
// all := MCF_All ( side , [ ] ) ;
36138: LD_ADDR_VAR 0 17
36142: PUSH
36143: LD_VAR 0 1
36147: PPUSH
36148: EMPTY
36149: PPUSH
36150: CALL 11722 0 2
36154: ST_TO_ADDR
// sol := MCF_Class ( side , 1 , [ ] ) ;
36155: LD_ADDR_VAR 0 13
36159: PUSH
36160: LD_VAR 0 1
36164: PPUSH
36165: LD_INT 1
36167: PPUSH
36168: EMPTY
36169: PPUSH
36170: CALL 11670 0 3
36174: ST_TO_ADDR
// eng := MCF_Class ( side , 2 , [ ] ) ;
36175: LD_ADDR_VAR 0 14
36179: PUSH
36180: LD_VAR 0 1
36184: PPUSH
36185: LD_INT 2
36187: PPUSH
36188: EMPTY
36189: PPUSH
36190: CALL 11670 0 3
36194: ST_TO_ADDR
// mech := MCF_Class ( side , 3 , [ ] ) ;
36195: LD_ADDR_VAR 0 15
36199: PUSH
36200: LD_VAR 0 1
36204: PPUSH
36205: LD_INT 3
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL 11670 0 3
36214: ST_TO_ADDR
// sci := MCF_Class ( side , 4 , [ ] ) ;
36215: LD_ADDR_VAR 0 16
36219: PUSH
36220: LD_VAR 0 1
36224: PPUSH
36225: LD_INT 4
36227: PPUSH
36228: EMPTY
36229: PPUSH
36230: CALL 11670 0 3
36234: ST_TO_ADDR
// if mech then
36235: LD_VAR 0 15
36239: IFFALSE 36256
// mech := MCF_SortListDesc ( mech ) ;
36241: LD_ADDR_VAR 0 15
36245: PUSH
36246: LD_VAR 0 15
36250: PPUSH
36251: CALL 12836 0 1
36255: ST_TO_ADDR
// if not MREG_ToArm [ side ] =  then
36256: LD_EXP 58
36260: PUSH
36261: LD_VAR 0 1
36265: ARRAY
36266: PUSH
36267: LD_STRING 
36269: EQUAL
36270: NOT
36271: IFFALSE 36327
// begin if GetClass ( MREG_ToArm [ side ] [ 1 ] ) = class_soldier then
36273: LD_EXP 58
36277: PUSH
36278: LD_VAR 0 1
36282: ARRAY
36283: PUSH
36284: LD_INT 1
36286: ARRAY
36287: PPUSH
36288: CALL_OW 257
36292: PUSH
36293: LD_INT 1
36295: EQUAL
36296: IFFALSE 36325
// MCF_RemoveFromClass ( side , ToArm , MREG_ToArm [ side ] [ 1 ] ) ;
36298: LD_VAR 0 1
36302: PPUSH
36303: LD_STRING ToArm
36305: PPUSH
36306: LD_EXP 58
36310: PUSH
36311: LD_VAR 0 1
36315: ARRAY
36316: PUSH
36317: LD_INT 1
36319: ARRAY
36320: PPUSH
36321: CALL 14466 0 3
// end else
36325: GO 36353
// MREG_ToArm := Replace2 ( MREG_ToArm , side , 1 , 0 ) ;
36327: LD_ADDR_EXP 58
36331: PUSH
36332: LD_EXP 58
36336: PPUSH
36337: LD_VAR 0 1
36341: PPUSH
36342: LD_INT 1
36344: PPUSH
36345: LD_INT 0
36347: PPUSH
36348: CALL 31052 0 4
36352: ST_TO_ADDR
// if not MREG_ToDep [ side ] =  then
36353: LD_EXP 59
36357: PUSH
36358: LD_VAR 0 1
36362: ARRAY
36363: PUSH
36364: LD_STRING 
36366: EQUAL
36367: NOT
36368: IFFALSE 36424
// begin if GetClass ( MREG_ToDep [ side ] [ 1 ] ) = class_engineer then
36370: LD_EXP 59
36374: PUSH
36375: LD_VAR 0 1
36379: ARRAY
36380: PUSH
36381: LD_INT 1
36383: ARRAY
36384: PPUSH
36385: CALL_OW 257
36389: PUSH
36390: LD_INT 2
36392: EQUAL
36393: IFFALSE 36422
// MCF_RemoveFromClass ( side , ToDep , MREG_ToDep [ side ] [ 1 ] ) ;
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_STRING ToDep
36402: PPUSH
36403: LD_EXP 59
36407: PUSH
36408: LD_VAR 0 1
36412: ARRAY
36413: PUSH
36414: LD_INT 1
36416: ARRAY
36417: PPUSH
36418: CALL 14466 0 3
// end else
36422: GO 36450
// MREG_ToDep := Replace2 ( MREG_ToDep , side , 1 , 0 ) ;
36424: LD_ADDR_EXP 59
36428: PUSH
36429: LD_EXP 59
36433: PPUSH
36434: LD_VAR 0 1
36438: PPUSH
36439: LD_INT 1
36441: PPUSH
36442: LD_INT 0
36444: PPUSH
36445: CALL 31052 0 4
36449: ST_TO_ADDR
// if not MREG_ToFac [ side ] =  then
36450: LD_EXP 57
36454: PUSH
36455: LD_VAR 0 1
36459: ARRAY
36460: PUSH
36461: LD_STRING 
36463: EQUAL
36464: NOT
36465: IFFALSE 36521
// begin if GetClass ( MREG_ToFac [ side ] [ 1 ] ) = class_mechanic then
36467: LD_EXP 57
36471: PUSH
36472: LD_VAR 0 1
36476: ARRAY
36477: PUSH
36478: LD_INT 1
36480: ARRAY
36481: PPUSH
36482: CALL_OW 257
36486: PUSH
36487: LD_INT 3
36489: EQUAL
36490: IFFALSE 36519
// MCF_RemoveFromClass ( side , ToFac , MREG_ToFac [ side ] [ 1 ] ) ;
36492: LD_VAR 0 1
36496: PPUSH
36497: LD_STRING ToFac
36499: PPUSH
36500: LD_EXP 57
36504: PUSH
36505: LD_VAR 0 1
36509: ARRAY
36510: PUSH
36511: LD_INT 1
36513: ARRAY
36514: PPUSH
36515: CALL 14466 0 3
// end else
36519: GO 36547
// MREG_ToFac := Replace2 ( MREG_ToFac , side , 1 , 0 ) ;
36521: LD_ADDR_EXP 57
36525: PUSH
36526: LD_EXP 57
36530: PPUSH
36531: LD_VAR 0 1
36535: PPUSH
36536: LD_INT 1
36538: PPUSH
36539: LD_INT 0
36541: PPUSH
36542: CALL 31052 0 4
36546: ST_TO_ADDR
// if not MREG_ToLab [ side ] =  then
36547: LD_EXP 56
36551: PUSH
36552: LD_VAR 0 1
36556: ARRAY
36557: PUSH
36558: LD_STRING 
36560: EQUAL
36561: NOT
36562: IFFALSE 36618
// begin if GetClass ( MREG_ToLab [ side ] [ 1 ] ) = class_scientistic then
36564: LD_EXP 56
36568: PUSH
36569: LD_VAR 0 1
36573: ARRAY
36574: PUSH
36575: LD_INT 1
36577: ARRAY
36578: PPUSH
36579: CALL_OW 257
36583: PUSH
36584: LD_INT 4
36586: EQUAL
36587: IFFALSE 36616
// MCF_RemoveFromClass ( side , ToLab , MREG_ToLab [ side ] [ 1 ] ) ;
36589: LD_VAR 0 1
36593: PPUSH
36594: LD_STRING ToLab
36596: PPUSH
36597: LD_EXP 56
36601: PUSH
36602: LD_VAR 0 1
36606: ARRAY
36607: PUSH
36608: LD_INT 1
36610: ARRAY
36611: PPUSH
36612: CALL 14466 0 3
// end else
36616: GO 36644
// MREG_ToLab := Replace2 ( MREG_ToLab , side , 1 , 0 ) ;
36618: LD_ADDR_EXP 56
36622: PUSH
36623: LD_EXP 56
36627: PPUSH
36628: LD_VAR 0 1
36632: PPUSH
36633: LD_INT 1
36635: PPUSH
36636: LD_INT 0
36638: PPUSH
36639: CALL 31052 0 4
36643: ST_TO_ADDR
// if mode = 0 then
36644: LD_VAR 0 2
36648: PUSH
36649: LD_INT 0
36651: EQUAL
36652: IFFALSE 38490
// begin if MCF_Get ( side , [ f_btype , b_warehouse ] ) and MCF_Get ( side , [ f_type , unit_building ] ) = 1 then
36654: LD_VAR 0 1
36658: PPUSH
36659: LD_INT 30
36661: PUSH
36662: LD_INT 1
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PPUSH
36669: CALL 11587 0 2
36673: PUSH
36674: LD_VAR 0 1
36678: PPUSH
36679: LD_INT 21
36681: PUSH
36682: LD_INT 3
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PPUSH
36689: CALL 11587 0 2
36693: PUSH
36694: LD_INT 1
36696: EQUAL
36697: AND
36698: IFFALSE 36763
// begin if all then
36700: LD_VAR 0 17
36704: IFFALSE 36761
// for i in ( all diff eng ) do
36706: LD_ADDR_VAR 0 4
36710: PUSH
36711: LD_VAR 0 17
36715: PUSH
36716: LD_VAR 0 14
36720: DIFF
36721: PUSH
36722: FOR_IN
36723: IFFALSE 36759
// if GetTag ( i ) = 0 then
36725: LD_VAR 0 4
36729: PPUSH
36730: CALL_OW 110
36734: PUSH
36735: LD_INT 0
36737: EQUAL
36738: IFFALSE 36757
// MCH_ChangeClass ( side , i , 2 ) ;
36740: LD_VAR 0 1
36744: PPUSH
36745: LD_VAR 0 4
36749: PPUSH
36750: LD_INT 2
36752: PPUSH
36753: CALL 16494 0 3
36757: GO 36722
36759: POP
36760: POP
// end else
36761: GO 37082
// if ( sol + MREG_ToArm [ side ] ) < FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) then
36763: LD_VAR 0 13
36767: PUSH
36768: LD_EXP 58
36772: PUSH
36773: LD_VAR 0 1
36777: ARRAY
36778: PLUS
36779: PUSH
36780: LD_INT 22
36782: PUSH
36783: LD_VAR 0 1
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 30
36794: PUSH
36795: LD_INT 32
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PPUSH
36806: CALL_OW 69
36810: LESS
36811: IFFALSE 36836
// begin MCH_ChangeClass ( side , eng [ 1 ] , 1 ) ;
36813: LD_VAR 0 1
36817: PPUSH
36818: LD_VAR 0 14
36822: PUSH
36823: LD_INT 1
36825: ARRAY
36826: PPUSH
36827: LD_INT 1
36829: PPUSH
36830: CALL 16494 0 3
// end else
36834: GO 37082
// if sci < 6 and MCF_Lab ( side ) then
36836: LD_VAR 0 16
36840: PUSH
36841: LD_INT 6
36843: LESS
36844: PUSH
36845: LD_VAR 0 1
36849: PPUSH
36850: CALL 11626 0 1
36854: AND
36855: IFFALSE 36960
// begin if MREG_ToBunker [ side ] then
36857: LD_EXP 70
36861: PUSH
36862: LD_VAR 0 1
36866: ARRAY
36867: IFFALSE 36893
// tmp := sol diff MREG_ToBunker [ side ] else
36869: LD_ADDR_VAR 0 12
36873: PUSH
36874: LD_VAR 0 13
36878: PUSH
36879: LD_EXP 70
36883: PUSH
36884: LD_VAR 0 1
36888: ARRAY
36889: DIFF
36890: ST_TO_ADDR
36891: GO 36903
// tmp := sol ;
36893: LD_ADDR_VAR 0 12
36897: PUSH
36898: LD_VAR 0 13
36902: ST_TO_ADDR
// if tmp then
36903: LD_VAR 0 12
36907: IFFALSE 36958
// for i in tmp do
36909: LD_ADDR_VAR 0 4
36913: PUSH
36914: LD_VAR 0 12
36918: PUSH
36919: FOR_IN
36920: IFFALSE 36956
// if GetTag ( i ) = 0 then
36922: LD_VAR 0 4
36926: PPUSH
36927: CALL_OW 110
36931: PUSH
36932: LD_INT 0
36934: EQUAL
36935: IFFALSE 36954
// MCH_ChangeClass ( side , i , 4 ) ;
36937: LD_VAR 0 1
36941: PPUSH
36942: LD_VAR 0 4
36946: PPUSH
36947: LD_INT 4
36949: PPUSH
36950: CALL 16494 0 3
36954: GO 36919
36956: POP
36957: POP
// end else
36958: GO 37082
// if MCF_Get ( side , [ f_btype , b_warehouse ] ) then
36960: LD_VAR 0 1
36964: PPUSH
36965: LD_INT 30
36967: PUSH
36968: LD_INT 1
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: CALL 11587 0 2
36979: IFFALSE 37082
// begin if MREG_ToBunker [ side ] then
36981: LD_EXP 70
36985: PUSH
36986: LD_VAR 0 1
36990: ARRAY
36991: IFFALSE 37017
// tmp := sol diff MREG_ToBunker [ side ] else
36993: LD_ADDR_VAR 0 12
36997: PUSH
36998: LD_VAR 0 13
37002: PUSH
37003: LD_EXP 70
37007: PUSH
37008: LD_VAR 0 1
37012: ARRAY
37013: DIFF
37014: ST_TO_ADDR
37015: GO 37027
// tmp := sol ;
37017: LD_ADDR_VAR 0 12
37021: PUSH
37022: LD_VAR 0 13
37026: ST_TO_ADDR
// if tmp then
37027: LD_VAR 0 12
37031: IFFALSE 37082
// for i in tmp do
37033: LD_ADDR_VAR 0 4
37037: PUSH
37038: LD_VAR 0 12
37042: PUSH
37043: FOR_IN
37044: IFFALSE 37080
// if GetTag ( i ) = 0 then
37046: LD_VAR 0 4
37050: PPUSH
37051: CALL_OW 110
37055: PUSH
37056: LD_INT 0
37058: EQUAL
37059: IFFALSE 37078
// MCH_ChangeClass ( side , i , 2 ) ;
37061: LD_VAR 0 1
37065: PPUSH
37066: LD_VAR 0 4
37070: PPUSH
37071: LD_INT 2
37073: PPUSH
37074: CALL 16494 0 3
37078: GO 37043
37080: POP
37081: POP
// end ; if MCF_Lab ( side ) then
37082: LD_VAR 0 1
37086: PPUSH
37087: CALL 11626 0 1
37091: IFFALSE 37631
// begin if MCL_GetTechList ( side ) then
37093: LD_VAR 0 1
37097: PPUSH
37098: CALL 17970 0 1
37102: IFFALSE 37228
// begin if MREG_ToLab [ side ] then
37104: LD_EXP 56
37108: PUSH
37109: LD_VAR 0 1
37113: ARRAY
37114: IFFALSE 37134
// k := MREG_ToLab [ side ] else
37116: LD_ADDR_VAR 0 8
37120: PUSH
37121: LD_EXP 56
37125: PUSH
37126: LD_VAR 0 1
37130: ARRAY
37131: ST_TO_ADDR
37132: GO 37142
// k := 0 ;
37134: LD_ADDR_VAR 0 8
37138: PUSH
37139: LD_INT 0
37141: ST_TO_ADDR
// if sci + k <= 6 and all > 6 then
37142: LD_VAR 0 16
37146: PUSH
37147: LD_VAR 0 8
37151: PLUS
37152: PUSH
37153: LD_INT 6
37155: LESSEQUAL
37156: PUSH
37157: LD_VAR 0 17
37161: PUSH
37162: LD_INT 6
37164: GREATER
37165: AND
37166: IFFALSE 37182
// MCH_TrainScientist ( side , 1 ) else
37168: LD_VAR 0 1
37172: PPUSH
37173: LD_INT 1
37175: PPUSH
37176: CALL 16046 0 2
37180: GO 37226
// if all < 6 then
37182: LD_VAR 0 17
37186: PUSH
37187: LD_INT 6
37189: LESS
37190: IFFALSE 37226
// if sci + k < all / 2 then
37192: LD_VAR 0 16
37196: PUSH
37197: LD_VAR 0 8
37201: PLUS
37202: PUSH
37203: LD_VAR 0 17
37207: PUSH
37208: LD_INT 2
37210: DIVREAL
37211: LESS
37212: IFFALSE 37226
// MCH_TrainScientist ( side , 1 ) ;
37214: LD_VAR 0 1
37218: PPUSH
37219: LD_INT 1
37221: PPUSH
37222: CALL 16046 0 2
// end else
37226: GO 37304
// begin if sci > 2 then
37228: LD_VAR 0 16
37232: PUSH
37233: LD_INT 2
37235: GREATER
37236: IFFALSE 37304
// for i = sci downto 2 do
37238: LD_ADDR_VAR 0 4
37242: PUSH
37243: DOUBLE
37244: LD_VAR 0 16
37248: INC
37249: ST_TO_ADDR
37250: LD_INT 2
37252: PUSH
37253: FOR_DOWNTO
37254: IFFALSE 37302
// if GetTag ( sci [ i ] ) = 0 then
37256: LD_VAR 0 16
37260: PUSH
37261: LD_VAR 0 4
37265: ARRAY
37266: PPUSH
37267: CALL_OW 110
37271: PUSH
37272: LD_INT 0
37274: EQUAL
37275: IFFALSE 37300
// MCH_ChangeClass ( side , sci [ i ] , 2 ) ;
37277: LD_VAR 0 1
37281: PPUSH
37282: LD_VAR 0 16
37286: PUSH
37287: LD_VAR 0 4
37291: ARRAY
37292: PPUSH
37293: LD_INT 2
37295: PPUSH
37296: CALL 16494 0 3
37300: GO 37253
37302: POP
37303: POP
// end ; if MCL_GetTechList ( side ) and MCF_Lab ( side ) and not MREG_Heal [ side ] then
37304: LD_VAR 0 1
37308: PPUSH
37309: CALL 17970 0 1
37313: PUSH
37314: LD_VAR 0 1
37318: PPUSH
37319: CALL 11626 0 1
37323: AND
37324: PUSH
37325: LD_EXP 37
37329: PUSH
37330: LD_VAR 0 1
37334: ARRAY
37335: NOT
37336: AND
37337: IFFALSE 37631
// begin for j = 1 to MCF_Lab ( side ) do
37339: LD_ADDR_VAR 0 5
37343: PUSH
37344: DOUBLE
37345: LD_INT 1
37347: DEC
37348: ST_TO_ADDR
37349: LD_VAR 0 1
37353: PPUSH
37354: CALL 11626 0 1
37358: PUSH
37359: FOR_TO
37360: IFFALSE 37420
// if BuildingStatus ( MCF_Lab ( side ) [ j ] ) in [ bs_working , bs_need_people ] then
37362: LD_VAR 0 1
37366: PPUSH
37367: CALL 11626 0 1
37371: PUSH
37372: LD_VAR 0 5
37376: ARRAY
37377: PPUSH
37378: CALL_OW 461
37382: PUSH
37383: LD_INT 3
37385: PUSH
37386: LD_INT 6
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: IN
37393: IFFALSE 37418
// begin b := MCF_Lab ( side ) [ j ] ;
37395: LD_ADDR_VAR 0 11
37399: PUSH
37400: LD_VAR 0 1
37404: PPUSH
37405: CALL 11626 0 1
37409: PUSH
37410: LD_VAR 0 5
37414: ARRAY
37415: ST_TO_ADDR
// break ;
37416: GO 37420
// end ;
37418: GO 37359
37420: POP
37421: POP
// if MCF_Class ( side , 4 , [ ] ) then
37422: LD_VAR 0 1
37426: PPUSH
37427: LD_INT 4
37429: PPUSH
37430: EMPTY
37431: PPUSH
37432: CALL 11670 0 3
37436: IFFALSE 37631
// for j in MCF_Class ( side , 4 , [ ] ) do
37438: LD_ADDR_VAR 0 5
37442: PUSH
37443: LD_VAR 0 1
37447: PPUSH
37448: LD_INT 4
37450: PPUSH
37451: EMPTY
37452: PPUSH
37453: CALL 11670 0 3
37457: PUSH
37458: FOR_IN
37459: IFFALSE 37629
// begin if GetTag ( j ) = 0 then
37461: LD_VAR 0 5
37465: PPUSH
37466: CALL_OW 110
37470: PUSH
37471: LD_INT 0
37473: EQUAL
37474: IFFALSE 37565
// begin if IsInUnit ( j ) and b then
37476: LD_VAR 0 5
37480: PPUSH
37481: CALL_OW 310
37485: PUSH
37486: LD_VAR 0 11
37490: AND
37491: IFFALSE 37539
// if BuildingStatus ( IsInUnit ( j ) ) = bs_idle and IsInUnit ( j ) <> b then
37493: LD_VAR 0 5
37497: PPUSH
37498: CALL_OW 310
37502: PPUSH
37503: CALL_OW 461
37507: PUSH
37508: LD_INT 2
37510: EQUAL
37511: PUSH
37512: LD_VAR 0 5
37516: PPUSH
37517: CALL_OW 310
37521: PUSH
37522: LD_VAR 0 11
37526: NONEQUAL
37527: AND
37528: IFFALSE 37539
// ComExitBuilding ( j ) ;
37530: LD_VAR 0 5
37534: PPUSH
37535: CALL_OW 122
// if not IsInUnit ( j ) then
37539: LD_VAR 0 5
37543: PPUSH
37544: CALL_OW 310
37548: NOT
37549: IFFALSE 37565
// ComEnterUnit ( j , b ) ;
37551: LD_VAR 0 5
37555: PPUSH
37556: LD_VAR 0 11
37560: PPUSH
37561: CALL_OW 120
// end ; if GetTech ( tech_apelang , GetSide ( j ) ) = state_researched and MCT_EnemyNearBase ( GetSide ( j ) ) = 0 then
37565: LD_INT 1
37567: PPUSH
37568: LD_VAR 0 5
37572: PPUSH
37573: CALL_OW 255
37577: PPUSH
37578: CALL_OW 321
37582: PUSH
37583: LD_INT 2
37585: EQUAL
37586: PUSH
37587: LD_VAR 0 5
37591: PPUSH
37592: CALL_OW 255
37596: PPUSH
37597: CALL 24942 0 1
37601: PUSH
37602: LD_INT 0
37604: EQUAL
37605: AND
37606: IFFALSE 37627
// MCN_Tame ( GetSide ( j ) , j ) ;
37608: LD_VAR 0 5
37612: PPUSH
37613: CALL_OW 255
37617: PPUSH
37618: LD_VAR 0 5
37622: PPUSH
37623: CALL 18489 0 2
// end ;
37627: GO 37458
37629: POP
37630: POP
// end ; end ; if MCF_Get ( side , [ f_btype , b_factory ] ) then
37631: LD_VAR 0 1
37635: PPUSH
37636: LD_INT 30
37638: PUSH
37639: LD_INT 3
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PPUSH
37646: CALL 11587 0 2
37650: IFFALSE 37909
// begin b := MCF_Get ( side , [ f_btype , b_factory ] ) [ 1 ] ;
37652: LD_ADDR_VAR 0 11
37656: PUSH
37657: LD_VAR 0 1
37661: PPUSH
37662: LD_INT 30
37664: PUSH
37665: LD_INT 3
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PPUSH
37672: CALL 11587 0 2
37676: PUSH
37677: LD_INT 1
37679: ARRAY
37680: ST_TO_ADDR
// tmp := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
37681: LD_ADDR_VAR 0 12
37685: PUSH
37686: LD_VAR 0 1
37690: PPUSH
37691: LD_INT 0
37693: PPUSH
37694: LD_INT 25
37696: PUSH
37697: LD_INT 3
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PPUSH
37704: CALL 12290 0 3
37708: ST_TO_ADDR
// for i = 1 to tmp do
37709: LD_ADDR_VAR 0 4
37713: PUSH
37714: DOUBLE
37715: LD_INT 1
37717: DEC
37718: ST_TO_ADDR
37719: LD_VAR 0 12
37723: PUSH
37724: FOR_TO
37725: IFFALSE 37785
// if not IsInUnit ( tmp [ i ] ) and not HasTask ( tmp [ i ] ) then
37727: LD_VAR 0 12
37731: PUSH
37732: LD_VAR 0 4
37736: ARRAY
37737: PPUSH
37738: CALL_OW 310
37742: NOT
37743: PUSH
37744: LD_VAR 0 12
37748: PUSH
37749: LD_VAR 0 4
37753: ARRAY
37754: PPUSH
37755: CALL_OW 314
37759: NOT
37760: AND
37761: IFFALSE 37783
// ComEnterUnit ( tmp [ i ] , b ) ;
37763: LD_VAR 0 12
37767: PUSH
37768: LD_VAR 0 4
37772: ARRAY
37773: PPUSH
37774: LD_VAR 0 11
37778: PPUSH
37779: CALL_OW 120
37783: GO 37724
37785: POP
37786: POP
// if MREG_ToFac [ side ] then
37787: LD_EXP 57
37791: PUSH
37792: LD_VAR 0 1
37796: ARRAY
37797: IFFALSE 37817
// k := MREG_ToFac [ side ] else
37799: LD_ADDR_VAR 0 8
37803: PUSH
37804: LD_EXP 57
37808: PUSH
37809: LD_VAR 0 1
37813: ARRAY
37814: ST_TO_ADDR
37815: GO 37825
// k := 0 ;
37817: LD_ADDR_VAR 0 8
37821: PUSH
37822: LD_INT 0
37824: ST_TO_ADDR
// if mech + k <= 6 and all > 6 then
37825: LD_VAR 0 15
37829: PUSH
37830: LD_VAR 0 8
37834: PLUS
37835: PUSH
37836: LD_INT 6
37838: LESSEQUAL
37839: PUSH
37840: LD_VAR 0 17
37844: PUSH
37845: LD_INT 6
37847: GREATER
37848: AND
37849: IFFALSE 37865
// MCH_TrainMechanic ( side , 1 ) else
37851: LD_VAR 0 1
37855: PPUSH
37856: LD_INT 1
37858: PPUSH
37859: CALL 15788 0 2
37863: GO 37909
// if all < 6 then
37865: LD_VAR 0 17
37869: PUSH
37870: LD_INT 6
37872: LESS
37873: IFFALSE 37909
// if mech + k < all / 2 then
37875: LD_VAR 0 15
37879: PUSH
37880: LD_VAR 0 8
37884: PLUS
37885: PUSH
37886: LD_VAR 0 17
37890: PUSH
37891: LD_INT 2
37893: DIVREAL
37894: LESS
37895: IFFALSE 37909
// MCH_TrainMechanic ( side , 1 ) ;
37897: LD_VAR 0 1
37901: PPUSH
37902: LD_INT 1
37904: PPUSH
37905: CALL 15788 0 2
// end ; ct := MCF_Get ( side , [ f_btype , b_control_tower ] ) ;
37909: LD_ADDR_VAR 0 10
37913: PUSH
37914: LD_VAR 0 1
37918: PPUSH
37919: LD_INT 30
37921: PUSH
37922: LD_INT 36
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PPUSH
37929: CALL 11587 0 2
37933: ST_TO_ADDR
// if ct and mech and MCF_Class ( side , 3 , [ ] ) then
37934: LD_VAR 0 10
37938: PUSH
37939: LD_VAR 0 15
37943: AND
37944: PUSH
37945: LD_VAR 0 1
37949: PPUSH
37950: LD_INT 3
37952: PPUSH
37953: EMPTY
37954: PPUSH
37955: CALL 11670 0 3
37959: AND
37960: IFFALSE 38118
// if MCF_Tag ( side , 9 , [ ] ) < 3 then
37962: LD_VAR 0 1
37966: PPUSH
37967: LD_INT 9
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL 12290 0 3
37976: PUSH
37977: LD_INT 3
37979: LESS
37980: IFFALSE 38118
// begin if mech < 3 then
37982: LD_VAR 0 15
37986: PUSH
37987: LD_INT 3
37989: LESS
37990: IFFALSE 38004
// k := mech else
37992: LD_ADDR_VAR 0 8
37996: PUSH
37997: LD_VAR 0 15
38001: ST_TO_ADDR
38002: GO 38012
// k := 3 ;
38004: LD_ADDR_VAR 0 8
38008: PUSH
38009: LD_INT 3
38011: ST_TO_ADDR
// for j = 1 to k do
38012: LD_ADDR_VAR 0 5
38016: PUSH
38017: DOUBLE
38018: LD_INT 1
38020: DEC
38021: ST_TO_ADDR
38022: LD_VAR 0 8
38026: PUSH
38027: FOR_TO
38028: IFFALSE 38086
// if GetClass ( mech [ j ] ) = 3 then
38030: LD_VAR 0 15
38034: PUSH
38035: LD_VAR 0 5
38039: ARRAY
38040: PPUSH
38041: CALL_OW 257
38045: PUSH
38046: LD_INT 3
38048: EQUAL
38049: IFFALSE 38084
// begin SetTag ( mech [ j ] , 9 ) ;
38051: LD_VAR 0 15
38055: PUSH
38056: LD_VAR 0 5
38060: ARRAY
38061: PPUSH
38062: LD_INT 9
38064: PPUSH
38065: CALL_OW 109
// ComExitBuilding ( mech [ j ] ) ;
38069: LD_VAR 0 15
38073: PUSH
38074: LD_VAR 0 5
38078: ARRAY
38079: PPUSH
38080: CALL_OW 122
// end ;
38084: GO 38027
38086: POP
38087: POP
// if mech < 6 + k then
38088: LD_VAR 0 15
38092: PUSH
38093: LD_INT 6
38095: PUSH
38096: LD_VAR 0 8
38100: PLUS
38101: LESS
38102: IFFALSE 38118
// MCH_TrainMechanic ( side , k ) ;
38104: LD_VAR 0 1
38108: PPUSH
38109: LD_VAR 0 8
38113: PPUSH
38114: CALL 15788 0 2
// end ; if MCF_Tag ( side , 9 , [ ] ) then
38118: LD_VAR 0 1
38122: PPUSH
38123: LD_INT 9
38125: PPUSH
38126: EMPTY
38127: PPUSH
38128: CALL 12290 0 3
38132: IFFALSE 38223
// for j in MCF_Tag ( side , 9 , [ ] ) do
38134: LD_ADDR_VAR 0 5
38138: PUSH
38139: LD_VAR 0 1
38143: PPUSH
38144: LD_INT 9
38146: PPUSH
38147: EMPTY
38148: PPUSH
38149: CALL 12290 0 3
38153: PUSH
38154: FOR_IN
38155: IFFALSE 38221
// if not IsInUnit ( j ) and not IsDriver ( j ) then
38157: LD_VAR 0 5
38161: PPUSH
38162: CALL_OW 310
38166: NOT
38167: PUSH
38168: LD_VAR 0 5
38172: PPUSH
38173: CALL 91877 0 1
38177: NOT
38178: AND
38179: IFFALSE 38219
// if ct then
38181: LD_VAR 0 10
38185: IFFALSE 38207
// ComEnterUnit ( j , ct [ 1 ] ) else
38187: LD_VAR 0 5
38191: PPUSH
38192: LD_VAR 0 10
38196: PUSH
38197: LD_INT 1
38199: ARRAY
38200: PPUSH
38201: CALL_OW 120
38205: GO 38219
// SetTag ( j , 0 ) ;
38207: LD_VAR 0 5
38211: PPUSH
38212: LD_INT 0
38214: PPUSH
38215: CALL_OW 109
38219: GO 38154
38221: POP
38222: POP
// if GetTech ( tech_apelang , side ) = state_researched and not MREG_Heal [ side ] and MCF_Class ( side , 4 , [ ] ) then
38223: LD_INT 1
38225: PPUSH
38226: LD_VAR 0 1
38230: PPUSH
38231: CALL_OW 321
38235: PUSH
38236: LD_INT 2
38238: EQUAL
38239: PUSH
38240: LD_EXP 37
38244: PUSH
38245: LD_VAR 0 1
38249: ARRAY
38250: NOT
38251: AND
38252: PUSH
38253: LD_VAR 0 1
38257: PPUSH
38258: LD_INT 4
38260: PPUSH
38261: EMPTY
38262: PPUSH
38263: CALL 11670 0 3
38267: AND
38268: IFFALSE 38316
// for j in MCF_Class ( side , 4 , [ ] ) do
38270: LD_ADDR_VAR 0 5
38274: PUSH
38275: LD_VAR 0 1
38279: PPUSH
38280: LD_INT 4
38282: PPUSH
38283: EMPTY
38284: PPUSH
38285: CALL 11670 0 3
38289: PUSH
38290: FOR_IN
38291: IFFALSE 38314
// MCN_Tame ( GetSide ( j ) , j ) ;
38293: LD_VAR 0 5
38297: PPUSH
38298: CALL_OW 255
38302: PPUSH
38303: LD_VAR 0 5
38307: PPUSH
38308: CALL 18489 0 2
38312: GO 38290
38314: POP
38315: POP
// if MREG_DefVeh [ side ] then
38316: LD_EXP 69
38320: PUSH
38321: LD_VAR 0 1
38325: ARRAY
38326: IFFALSE 38490
// begin for i in MREG_DefVeh [ side ] do
38328: LD_ADDR_VAR 0 4
38332: PUSH
38333: LD_EXP 69
38337: PUSH
38338: LD_VAR 0 1
38342: ARRAY
38343: PUSH
38344: FOR_IN
38345: IFFALSE 38398
// begin SetTag ( i , 0 ) ;
38347: LD_VAR 0 4
38351: PPUSH
38352: LD_INT 0
38354: PPUSH
38355: CALL_OW 109
// if not IsInArea ( i , MREG_DefArea [ side ] ) then
38359: LD_VAR 0 4
38363: PPUSH
38364: LD_EXP 66
38368: PUSH
38369: LD_VAR 0 1
38373: ARRAY
38374: PPUSH
38375: CALL_OW 308
38379: NOT
38380: IFFALSE 38396
// MCV_Parking ( side , i ) ;
38382: LD_VAR 0 1
38386: PPUSH
38387: LD_VAR 0 4
38391: PPUSH
38392: CALL 25677 0 2
// end ;
38396: GO 38344
38398: POP
38399: POP
// if MCF_Tag ( side , 36 , [ ] ) then
38400: LD_VAR 0 1
38404: PPUSH
38405: LD_INT 36
38407: PPUSH
38408: EMPTY
38409: PPUSH
38410: CALL 12290 0 3
38414: IFFALSE 38455
// for i in MCF_Tag ( side , 36 , [ ] ) do
38416: LD_ADDR_VAR 0 4
38420: PUSH
38421: LD_VAR 0 1
38425: PPUSH
38426: LD_INT 36
38428: PPUSH
38429: EMPTY
38430: PPUSH
38431: CALL 12290 0 3
38435: PUSH
38436: FOR_IN
38437: IFFALSE 38453
// SetTag ( i , 0 ) ;
38439: LD_VAR 0 4
38443: PPUSH
38444: LD_INT 0
38446: PPUSH
38447: CALL_OW 109
38451: GO 38436
38453: POP
38454: POP
// if MREG_DefMobActive [ side ] then
38455: LD_EXP 72
38459: PUSH
38460: LD_VAR 0 1
38464: ARRAY
38465: IFFALSE 38490
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , false ) ;
38467: LD_ADDR_EXP 72
38471: PUSH
38472: LD_EXP 72
38476: PPUSH
38477: LD_VAR 0 1
38481: PPUSH
38482: LD_INT 0
38484: PPUSH
38485: CALL_OW 1
38489: ST_TO_ADDR
// end ; end ; if mode > 0 then
38490: LD_VAR 0 2
38494: PUSH
38495: LD_INT 0
38497: GREATER
38498: IFFALSE 40393
// begin if tick <= 15 15$00 then
38500: LD_OWVAR 1
38504: PUSH
38505: LD_INT 31500
38507: LESSEQUAL
38508: IFFALSE 38812
// begin if sol and MCT_EnemyNearBase ( side ) < 4 then
38510: LD_VAR 0 13
38514: PUSH
38515: LD_VAR 0 1
38519: PPUSH
38520: CALL 24942 0 1
38524: PUSH
38525: LD_INT 4
38527: LESS
38528: AND
38529: IFFALSE 38640
// begin for i in sol do
38531: LD_ADDR_VAR 0 4
38535: PUSH
38536: LD_VAR 0 13
38540: PUSH
38541: FOR_IN
38542: IFFALSE 38638
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
38544: LD_ADDR_VAR 0 8
38548: PUSH
38549: LD_VAR 0 1
38553: PPUSH
38554: CALL 24942 0 1
38558: PPUSH
38559: LD_VAR 0 4
38563: PPUSH
38564: CALL_OW 74
38568: ST_TO_ADDR
// if IsInUnit ( i ) then
38569: LD_VAR 0 4
38573: PPUSH
38574: CALL_OW 310
38578: IFFALSE 38589
// ComExitBuilding ( i ) ;
38580: LD_VAR 0 4
38584: PPUSH
38585: CALL_OW 122
// if not HasTask ( i ) and k then
38589: LD_VAR 0 4
38593: PPUSH
38594: CALL_OW 314
38598: NOT
38599: PUSH
38600: LD_VAR 0 8
38604: AND
38605: IFFALSE 38636
// AddComAgressiveMove ( i , GetX ( k ) , GetY ( k ) ) ;
38607: LD_VAR 0 4
38611: PPUSH
38612: LD_VAR 0 8
38616: PPUSH
38617: CALL_OW 250
38621: PPUSH
38622: LD_VAR 0 8
38626: PPUSH
38627: CALL_OW 251
38631: PPUSH
38632: CALL_OW 174
// end ;
38636: GO 38541
38638: POP
38639: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
38640: LD_VAR 0 1
38644: PPUSH
38645: LD_INT 30
38647: PUSH
38648: LD_INT 5
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PPUSH
38655: CALL 11587 0 2
38659: IFFALSE 38810
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
38661: LD_ADDR_VAR 0 11
38665: PUSH
38666: LD_VAR 0 1
38670: PPUSH
38671: LD_INT 30
38673: PUSH
38674: LD_INT 5
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PPUSH
38681: CALL 11587 0 2
38685: PUSH
38686: LD_INT 1
38688: ARRAY
38689: ST_TO_ADDR
// if mech then
38690: LD_VAR 0 15
38694: IFFALSE 38730
// for i in mech do
38696: LD_ADDR_VAR 0 4
38700: PUSH
38701: LD_VAR 0 15
38705: PUSH
38706: FOR_IN
38707: IFFALSE 38728
// MCH_ChangeClass ( side , i , 1 ) ;
38709: LD_VAR 0 1
38713: PPUSH
38714: LD_VAR 0 4
38718: PPUSH
38719: LD_INT 1
38721: PPUSH
38722: CALL 16494 0 3
38726: GO 38706
38728: POP
38729: POP
// if eng > 1 then
38730: LD_VAR 0 14
38734: PUSH
38735: LD_INT 1
38737: GREATER
38738: IFFALSE 38785
// for i = eng downto 2 do
38740: LD_ADDR_VAR 0 4
38744: PUSH
38745: DOUBLE
38746: LD_VAR 0 14
38750: INC
38751: ST_TO_ADDR
38752: LD_INT 2
38754: PUSH
38755: FOR_DOWNTO
38756: IFFALSE 38783
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
38758: LD_VAR 0 1
38762: PPUSH
38763: LD_VAR 0 14
38767: PUSH
38768: LD_VAR 0 4
38772: ARRAY
38773: PPUSH
38774: LD_INT 1
38776: PPUSH
38777: CALL 16494 0 3
38781: GO 38755
38783: POP
38784: POP
// if UnitsInside ( b ) then
38785: LD_VAR 0 11
38789: PPUSH
38790: CALL_OW 313
38794: IFFALSE 38810
// ComExitBuilding ( UnitsInside ( b ) ) ;
38796: LD_VAR 0 11
38800: PPUSH
38801: CALL_OW 313
38805: PPUSH
38806: CALL_OW 122
// end ; end else
38810: GO 40393
// begin if GetUnitsOutOfArea ( side , unit_human , MREG_DefDontLeave [ side ] [ 1 ] ) then
38812: LD_VAR 0 1
38816: PPUSH
38817: LD_INT 1
38819: PPUSH
38820: LD_EXP 67
38824: PUSH
38825: LD_VAR 0 1
38829: ARRAY
38830: PUSH
38831: LD_INT 1
38833: ARRAY
38834: PPUSH
38835: CALL 33665 0 3
38839: IFFALSE 38978
// begin tmp := MCF_Get ( side , [ f_type , unit_human ] ) ;
38841: LD_ADDR_VAR 0 12
38845: PUSH
38846: LD_VAR 0 1
38850: PPUSH
38851: LD_INT 21
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PPUSH
38861: CALL 11587 0 2
38865: ST_TO_ADDR
// b := MCF_Get ( side , [ f_btype , b_warehouse ] ) ;
38866: LD_ADDR_VAR 0 11
38870: PUSH
38871: LD_VAR 0 1
38875: PPUSH
38876: LD_INT 30
38878: PUSH
38879: LD_INT 1
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PPUSH
38886: CALL 11587 0 2
38890: ST_TO_ADDR
// if b then
38891: LD_VAR 0 11
38895: IFFALSE 38978
// for i in tmp do
38897: LD_ADDR_VAR 0 4
38901: PUSH
38902: LD_VAR 0 12
38906: PUSH
38907: FOR_IN
38908: IFFALSE 38976
// if not IsInArea ( i , MREG_DefDontLeave [ side ] [ 1 ] ) then
38910: LD_VAR 0 4
38914: PPUSH
38915: LD_EXP 67
38919: PUSH
38920: LD_VAR 0 1
38924: ARRAY
38925: PUSH
38926: LD_INT 1
38928: ARRAY
38929: PPUSH
38930: CALL_OW 308
38934: NOT
38935: IFFALSE 38974
// ComMoveXY ( i , GetX ( b [ 1 ] ) , GetY ( b [ 1 ] ) ) ;
38937: LD_VAR 0 4
38941: PPUSH
38942: LD_VAR 0 11
38946: PUSH
38947: LD_INT 1
38949: ARRAY
38950: PPUSH
38951: CALL_OW 250
38955: PPUSH
38956: LD_VAR 0 11
38960: PUSH
38961: LD_INT 1
38963: ARRAY
38964: PPUSH
38965: CALL_OW 251
38969: PPUSH
38970: CALL_OW 111
38974: GO 38907
38976: POP
38977: POP
// end ; if MREG_DefVeh [ side ] then
38978: LD_EXP 69
38982: PUSH
38983: LD_VAR 0 1
38987: ARRAY
38988: IFFALSE 39556
// begin tmp := [ ] ;
38990: LD_ADDR_VAR 0 12
38994: PUSH
38995: EMPTY
38996: ST_TO_ADDR
// if MREG_DefMobActive [ side ] = false then
38997: LD_EXP 72
39001: PUSH
39002: LD_VAR 0 1
39006: ARRAY
39007: PUSH
39008: LD_INT 0
39010: EQUAL
39011: IFFALSE 39151
// begin k := MCF_Tag ( side , 0 , [ f_class , 3 ] ) ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_VAR 0 1
39022: PPUSH
39023: LD_INT 0
39025: PPUSH
39026: LD_INT 25
39028: PUSH
39029: LD_INT 3
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PPUSH
39036: CALL 12290 0 3
39040: ST_TO_ADDR
// if k > MREG_DefVeh [ side ] then
39041: LD_VAR 0 8
39045: PUSH
39046: LD_EXP 69
39050: PUSH
39051: LD_VAR 0 1
39055: ARRAY
39056: GREATER
39057: IFFALSE 39118
// begin for i = 1 to MREG_DefVeh [ side ] do
39059: LD_ADDR_VAR 0 4
39063: PUSH
39064: DOUBLE
39065: LD_INT 1
39067: DEC
39068: ST_TO_ADDR
39069: LD_EXP 69
39073: PUSH
39074: LD_VAR 0 1
39078: ARRAY
39079: PUSH
39080: FOR_TO
39081: IFFALSE 39114
// tmp := Insert ( tmp , 1 , k [ i ] ) ;
39083: LD_ADDR_VAR 0 12
39087: PUSH
39088: LD_VAR 0 12
39092: PPUSH
39093: LD_INT 1
39095: PPUSH
39096: LD_VAR 0 8
39100: PUSH
39101: LD_VAR 0 4
39105: ARRAY
39106: PPUSH
39107: CALL_OW 2
39111: ST_TO_ADDR
39112: GO 39080
39114: POP
39115: POP
// end else
39116: GO 39128
// tmp := k ;
39118: LD_ADDR_VAR 0 12
39122: PUSH
39123: LD_VAR 0 8
39127: ST_TO_ADDR
// MREG_DefMobActive := Replace ( MREG_DefMobActive , side , true ) ;
39128: LD_ADDR_EXP 72
39132: PUSH
39133: LD_EXP 72
39137: PPUSH
39138: LD_VAR 0 1
39142: PPUSH
39143: LD_INT 1
39145: PPUSH
39146: CALL_OW 1
39150: ST_TO_ADDR
// end ; for i in MREG_DefVeh [ side ] do
39151: LD_ADDR_VAR 0 4
39155: PUSH
39156: LD_EXP 69
39160: PUSH
39161: LD_VAR 0 1
39165: ARRAY
39166: PUSH
39167: FOR_IN
39168: IFFALSE 39554
// begin if not GetDriver ( i ) then
39170: LD_VAR 0 4
39174: PPUSH
39175: CALL 31695 0 1
39179: NOT
39180: IFFALSE 39255
// begin if tmp then
39182: LD_VAR 0 12
39186: IFFALSE 39253
// begin ComExitBuilding ( tmp [ 1 ] ) ;
39188: LD_VAR 0 12
39192: PUSH
39193: LD_INT 1
39195: ARRAY
39196: PPUSH
39197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , i ) ;
39201: LD_VAR 0 12
39205: PUSH
39206: LD_INT 1
39208: ARRAY
39209: PPUSH
39210: LD_VAR 0 4
39214: PPUSH
39215: CALL_OW 180
// SetTag ( tmp [ 1 ] , 36 ) ;
39219: LD_VAR 0 12
39223: PUSH
39224: LD_INT 1
39226: ARRAY
39227: PPUSH
39228: LD_INT 36
39230: PPUSH
39231: CALL_OW 109
// tmp := Delete ( tmp , 1 ) ;
39235: LD_ADDR_VAR 0 12
39239: PUSH
39240: LD_VAR 0 12
39244: PPUSH
39245: LD_INT 1
39247: PPUSH
39248: CALL_OW 3
39252: ST_TO_ADDR
// end ; end else
39253: GO 39552
// begin if GetTag ( i ) = 0 then
39255: LD_VAR 0 4
39259: PPUSH
39260: CALL_OW 110
39264: PUSH
39265: LD_INT 0
39267: EQUAL
39268: IFFALSE 39284
// SetTag ( i , 31 ) else
39270: LD_VAR 0 4
39274: PPUSH
39275: LD_INT 31
39277: PPUSH
39278: CALL_OW 109
39282: GO 39552
// if GetTag ( i ) = 31 then
39284: LD_VAR 0 4
39288: PPUSH
39289: CALL_OW 110
39293: PUSH
39294: LD_INT 31
39296: EQUAL
39297: IFFALSE 39552
// begin if GetFuel ( i ) < 20 then
39299: LD_VAR 0 4
39303: PPUSH
39304: CALL_OW 261
39308: PUSH
39309: LD_INT 20
39311: LESS
39312: IFFALSE 39337
// begin SetTag ( i , 21 ) ;
39314: LD_VAR 0 4
39318: PPUSH
39319: LD_INT 21
39321: PPUSH
39322: CALL_OW 109
// MCV_Refuel ( i ) ;
39326: LD_VAR 0 4
39330: PPUSH
39331: CALL 26214 0 1
// continue ;
39335: GO 39167
// end ; if GetLives ( i ) < 700 then
39337: LD_VAR 0 4
39341: PPUSH
39342: CALL_OW 256
39346: PUSH
39347: LD_INT 700
39349: LESS
39350: IFFALSE 39462
// begin if not IsInArea ( i , MREG_Parking [ side ] ) then
39352: LD_VAR 0 4
39356: PPUSH
39357: LD_EXP 60
39361: PUSH
39362: LD_VAR 0 1
39366: ARRAY
39367: PPUSH
39368: CALL_OW 308
39372: NOT
39373: IFFALSE 39397
// ComMoveToArea ( i , MREG_Parking [ side ] ) else
39375: LD_VAR 0 4
39379: PPUSH
39380: LD_EXP 60
39384: PUSH
39385: LD_VAR 0 1
39389: ARRAY
39390: PPUSH
39391: CALL_OW 113
39395: GO 39460
// if GetDriver ( i ) then
39397: LD_VAR 0 4
39401: PPUSH
39402: CALL 31695 0 1
39406: IFFALSE 39460
// begin k := GetDriver ( i ) ;
39408: LD_ADDR_VAR 0 8
39412: PUSH
39413: LD_VAR 0 4
39417: PPUSH
39418: CALL 31695 0 1
39422: ST_TO_ADDR
// ComExitVehicle ( k ) ;
39423: LD_VAR 0 8
39427: PPUSH
39428: CALL_OW 121
// AddComRepairVehicle ( k , i ) ;
39432: LD_VAR 0 8
39436: PPUSH
39437: LD_VAR 0 4
39441: PPUSH
39442: CALL_OW 189
// AddComEnterUnit ( k , i ) ;
39446: LD_VAR 0 8
39450: PPUSH
39451: LD_VAR 0 4
39455: PPUSH
39456: CALL_OW 180
// end ; end else
39460: GO 39552
// begin k := NearestUnitToUnit ( MCT_EnemyNearBase ( side ) , i ) ;
39462: LD_ADDR_VAR 0 8
39466: PUSH
39467: LD_VAR 0 1
39471: PPUSH
39472: CALL 24942 0 1
39476: PPUSH
39477: LD_VAR 0 4
39481: PPUSH
39482: CALL_OW 74
39486: ST_TO_ADDR
// if k then
39487: LD_VAR 0 8
39491: IFFALSE 39509
// ComAttackUnit ( i , k ) else
39493: LD_VAR 0 4
39497: PPUSH
39498: LD_VAR 0 8
39502: PPUSH
39503: CALL_OW 115
39507: GO 39552
// if not IsInArea ( i , MREG_Parking [ side ] ) then
39509: LD_VAR 0 4
39513: PPUSH
39514: LD_EXP 60
39518: PUSH
39519: LD_VAR 0 1
39523: ARRAY
39524: PPUSH
39525: CALL_OW 308
39529: NOT
39530: IFFALSE 39552
// ComMoveToArea ( i , MREG_Parking [ side ] ) ;
39532: LD_VAR 0 4
39536: PPUSH
39537: LD_EXP 60
39541: PUSH
39542: LD_VAR 0 1
39546: ARRAY
39547: PPUSH
39548: CALL_OW 113
// end ; end ; end ; end ;
39552: GO 39167
39554: POP
39555: POP
// end ; if MCF_Get ( side , [ f_btype , b_barracks ] ) then
39556: LD_VAR 0 1
39560: PPUSH
39561: LD_INT 30
39563: PUSH
39564: LD_INT 5
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PPUSH
39571: CALL 11587 0 2
39575: IFFALSE 40393
// begin b := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 1 ] ;
39577: LD_ADDR_VAR 0 11
39581: PUSH
39582: LD_VAR 0 1
39586: PPUSH
39587: LD_INT 30
39589: PUSH
39590: LD_INT 5
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PPUSH
39597: CALL 11587 0 2
39601: PUSH
39602: LD_INT 1
39604: ARRAY
39605: ST_TO_ADDR
// if eng > 1 then
39606: LD_VAR 0 14
39610: PUSH
39611: LD_INT 1
39613: GREATER
39614: IFFALSE 39661
// for i = eng downto 2 do
39616: LD_ADDR_VAR 0 4
39620: PUSH
39621: DOUBLE
39622: LD_VAR 0 14
39626: INC
39627: ST_TO_ADDR
39628: LD_INT 2
39630: PUSH
39631: FOR_DOWNTO
39632: IFFALSE 39659
// MCH_ChangeClass ( side , eng [ i ] , 1 ) ;
39634: LD_VAR 0 1
39638: PPUSH
39639: LD_VAR 0 14
39643: PUSH
39644: LD_VAR 0 4
39648: ARRAY
39649: PPUSH
39650: LD_INT 1
39652: PPUSH
39653: CALL 16494 0 3
39657: GO 39631
39659: POP
39660: POP
// if sci > 1 then
39661: LD_VAR 0 16
39665: PUSH
39666: LD_INT 1
39668: GREATER
39669: IFFALSE 39716
// for i = sci downto 2 do
39671: LD_ADDR_VAR 0 4
39675: PUSH
39676: DOUBLE
39677: LD_VAR 0 16
39681: INC
39682: ST_TO_ADDR
39683: LD_INT 2
39685: PUSH
39686: FOR_DOWNTO
39687: IFFALSE 39714
// MCH_ChangeClass ( side , sci [ i ] , 1 ) ;
39689: LD_VAR 0 1
39693: PPUSH
39694: LD_VAR 0 16
39698: PUSH
39699: LD_VAR 0 4
39703: ARRAY
39704: PPUSH
39705: LD_INT 1
39707: PPUSH
39708: CALL 16494 0 3
39712: GO 39686
39714: POP
39715: POP
// if sol then
39716: LD_VAR 0 13
39720: IFFALSE 40393
// begin if sol diff MREG_ToBunker [ side ] and ( FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ] ) = 0 ) then
39722: LD_VAR 0 13
39726: PUSH
39727: LD_EXP 70
39731: PUSH
39732: LD_VAR 0 1
39736: ARRAY
39737: DIFF
39738: PUSH
39739: LD_INT 22
39741: PUSH
39742: LD_VAR 0 1
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: PUSH
39751: LD_INT 58
39753: PUSH
39754: EMPTY
39755: LIST
39756: PUSH
39757: LD_INT 2
39759: PUSH
39760: LD_INT 30
39762: PUSH
39763: LD_INT 32
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 30
39772: PUSH
39773: LD_INT 31
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: LIST
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: LIST
39789: PPUSH
39790: CALL_OW 69
39794: PUSH
39795: LD_INT 0
39797: EQUAL
39798: AND
39799: IFFALSE 40393
// begin tmp := sol diff MREG_ToBunker [ side ] ;
39801: LD_ADDR_VAR 0 12
39805: PUSH
39806: LD_VAR 0 13
39810: PUSH
39811: LD_EXP 70
39815: PUSH
39816: LD_VAR 0 1
39820: ARRAY
39821: DIFF
39822: ST_TO_ADDR
// if MCF_Get ( side , [ f_btype , b_barracks ] ) > 1 then
39823: LD_VAR 0 1
39827: PPUSH
39828: LD_INT 30
39830: PUSH
39831: LD_INT 5
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PPUSH
39838: CALL 11587 0 2
39842: PUSH
39843: LD_INT 1
39845: GREATER
39846: IFFALSE 39877
// k := MCF_Get ( side , [ f_btype , b_barracks ] ) [ 2 ] ;
39848: LD_ADDR_VAR 0 8
39852: PUSH
39853: LD_VAR 0 1
39857: PPUSH
39858: LD_INT 30
39860: PUSH
39861: LD_INT 5
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PPUSH
39868: CALL 11587 0 2
39872: PUSH
39873: LD_INT 2
39875: ARRAY
39876: ST_TO_ADDR
// for j in tmp do
39877: LD_ADDR_VAR 0 5
39881: PUSH
39882: LD_VAR 0 12
39886: PUSH
39887: FOR_IN
39888: IFFALSE 40391
// begin if j in UnitsInside ( b ) and UnitsInside ( b ) = 6 and k and UnitsInside ( k ) < 6 then
39890: LD_VAR 0 5
39894: PUSH
39895: LD_VAR 0 11
39899: PPUSH
39900: CALL_OW 313
39904: IN
39905: PUSH
39906: LD_VAR 0 11
39910: PPUSH
39911: CALL_OW 313
39915: PUSH
39916: LD_INT 6
39918: EQUAL
39919: AND
39920: PUSH
39921: LD_VAR 0 8
39925: AND
39926: PUSH
39927: LD_VAR 0 8
39931: PPUSH
39932: CALL_OW 313
39936: PUSH
39937: LD_INT 6
39939: LESS
39940: AND
39941: IFFALSE 39968
// begin ComExitBuilding ( j ) ;
39943: LD_VAR 0 5
39947: PPUSH
39948: CALL_OW 122
// AddComEnterunit ( j , k ) ;
39952: LD_VAR 0 5
39956: PPUSH
39957: LD_VAR 0 8
39961: PPUSH
39962: CALL_OW 180
// continue ;
39966: GO 39887
// end ; if not HasTask ( j ) and GetTag ( j ) = 0 and not IsInUnit ( j ) then
39968: LD_VAR 0 5
39972: PPUSH
39973: CALL_OW 314
39977: NOT
39978: PUSH
39979: LD_VAR 0 5
39983: PPUSH
39984: CALL_OW 110
39988: PUSH
39989: LD_INT 0
39991: EQUAL
39992: AND
39993: PUSH
39994: LD_VAR 0 5
39998: PPUSH
39999: CALL_OW 310
40003: NOT
40004: AND
40005: IFFALSE 40111
// begin if k then
40007: LD_VAR 0 8
40011: IFFALSE 40082
// begin if UnitsInside ( k ) < UnitsInside ( b ) then
40013: LD_VAR 0 8
40017: PPUSH
40018: CALL_OW 313
40022: PUSH
40023: LD_VAR 0 11
40027: PPUSH
40028: CALL_OW 313
40032: LESS
40033: IFFALSE 40051
// ComEnterUnit ( j , k ) else
40035: LD_VAR 0 5
40039: PPUSH
40040: LD_VAR 0 8
40044: PPUSH
40045: CALL_OW 120
40049: GO 40080
// if UnitsInside ( b ) < 6 then
40051: LD_VAR 0 11
40055: PPUSH
40056: CALL_OW 313
40060: PUSH
40061: LD_INT 6
40063: LESS
40064: IFFALSE 40080
// ComEnterUnit ( j , b ) ;
40066: LD_VAR 0 5
40070: PPUSH
40071: LD_VAR 0 11
40075: PPUSH
40076: CALL_OW 120
// end else
40080: GO 40111
// if UnitsInside ( b ) < 6 then
40082: LD_VAR 0 11
40086: PPUSH
40087: CALL_OW 313
40091: PUSH
40092: LD_INT 6
40094: LESS
40095: IFFALSE 40111
// ComEnterUnit ( j , b ) ;
40097: LD_VAR 0 5
40101: PPUSH
40102: LD_VAR 0 11
40106: PPUSH
40107: CALL_OW 120
// end ; if j in MCF_Get ( side , [ f_inside ] ) and GetClass ( j ) = 1 then
40111: LD_VAR 0 5
40115: PUSH
40116: LD_VAR 0 1
40120: PPUSH
40121: LD_INT 54
40123: PUSH
40124: EMPTY
40125: LIST
40126: PPUSH
40127: CALL 11587 0 2
40131: IN
40132: PUSH
40133: LD_VAR 0 5
40137: PPUSH
40138: CALL_OW 257
40142: PUSH
40143: LD_INT 1
40145: EQUAL
40146: AND
40147: IFFALSE 40389
// begin if MREG_AllowClass [ side ] [ 1 ] and GetTech ( 12 , side ) = state_researched then
40149: LD_EXP 64
40153: PUSH
40154: LD_VAR 0 1
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: PUSH
40164: LD_INT 12
40166: PPUSH
40167: LD_VAR 0 1
40171: PPUSH
40172: CALL_OW 321
40176: PUSH
40177: LD_INT 2
40179: EQUAL
40180: AND
40181: IFFALSE 40229
// if MCF_Class ( side , class_sniper , [ ] ) < MREG_AllowClass [ side ] [ 1 ] then
40183: LD_VAR 0 1
40187: PPUSH
40188: LD_INT 5
40190: PPUSH
40191: EMPTY
40192: PPUSH
40193: CALL 11670 0 3
40197: PUSH
40198: LD_EXP 64
40202: PUSH
40203: LD_VAR 0 1
40207: ARRAY
40208: PUSH
40209: LD_INT 1
40211: ARRAY
40212: LESS
40213: IFFALSE 40229
// begin SetClass ( j , class_sniper ) ;
40215: LD_VAR 0 5
40219: PPUSH
40220: LD_INT 5
40222: PPUSH
40223: CALL_OW 336
// continue ;
40227: GO 39887
// end ; if MREG_AllowClass [ side ] [ 2 ] and GetTech ( 41 , side ) = state_researched then
40229: LD_EXP 64
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PUSH
40240: LD_INT 2
40242: ARRAY
40243: PUSH
40244: LD_INT 41
40246: PPUSH
40247: LD_VAR 0 1
40251: PPUSH
40252: CALL_OW 321
40256: PUSH
40257: LD_INT 2
40259: EQUAL
40260: AND
40261: IFFALSE 40309
// if MCF_Class ( side , class_mortar , [ ] ) < MREG_AllowClass [ side ] [ 2 ] then
40263: LD_VAR 0 1
40267: PPUSH
40268: LD_INT 8
40270: PPUSH
40271: EMPTY
40272: PPUSH
40273: CALL 11670 0 3
40277: PUSH
40278: LD_EXP 64
40282: PUSH
40283: LD_VAR 0 1
40287: ARRAY
40288: PUSH
40289: LD_INT 2
40291: ARRAY
40292: LESS
40293: IFFALSE 40309
// begin SetClass ( j , class_mortar ) ;
40295: LD_VAR 0 5
40299: PPUSH
40300: LD_INT 8
40302: PPUSH
40303: CALL_OW 336
// continue ;
40307: GO 39887
// end ; if MREG_AllowClass [ side ] [ 3 ] and GetTech ( 44 , side ) = state_researched then
40309: LD_EXP 64
40313: PUSH
40314: LD_VAR 0 1
40318: ARRAY
40319: PUSH
40320: LD_INT 3
40322: ARRAY
40323: PUSH
40324: LD_INT 44
40326: PPUSH
40327: LD_VAR 0 1
40331: PPUSH
40332: CALL_OW 321
40336: PUSH
40337: LD_INT 2
40339: EQUAL
40340: AND
40341: IFFALSE 40389
// if MCF_Class ( side , class_bazooker , [ ] ) < MREG_AllowClass [ side ] [ 3 ] then
40343: LD_VAR 0 1
40347: PPUSH
40348: LD_INT 9
40350: PPUSH
40351: EMPTY
40352: PPUSH
40353: CALL 11670 0 3
40357: PUSH
40358: LD_EXP 64
40362: PUSH
40363: LD_VAR 0 1
40367: ARRAY
40368: PUSH
40369: LD_INT 3
40371: ARRAY
40372: LESS
40373: IFFALSE 40389
// begin SetClass ( j , class_bazooker ) ;
40375: LD_VAR 0 5
40379: PPUSH
40380: LD_INT 9
40382: PPUSH
40383: CALL_OW 336
// continue ;
40387: GO 39887
// end ; end ; end ;
40389: GO 39887
40391: POP
40392: POP
// end ; end ; end ; end ; end ; if FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) then
40393: LD_INT 22
40395: PUSH
40396: LD_VAR 0 1
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 58
40407: PUSH
40408: EMPTY
40409: LIST
40410: PUSH
40411: LD_INT 30
40413: PUSH
40414: LD_INT 32
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: PPUSH
40426: CALL_OW 69
40430: IFFALSE 40580
// begin tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_empty ] , [ f_btype , b_bunker ] ] ) ;
40432: LD_ADDR_VAR 0 12
40436: PUSH
40437: LD_INT 22
40439: PUSH
40440: LD_VAR 0 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 58
40451: PUSH
40452: EMPTY
40453: LIST
40454: PUSH
40455: LD_INT 30
40457: PUSH
40458: LD_INT 32
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: LIST
40469: PPUSH
40470: CALL_OW 69
40474: ST_TO_ADDR
// k := sol diff MREG_ToBunker [ side ] ;
40475: LD_ADDR_VAR 0 8
40479: PUSH
40480: LD_VAR 0 13
40484: PUSH
40485: LD_EXP 70
40489: PUSH
40490: LD_VAR 0 1
40494: ARRAY
40495: DIFF
40496: ST_TO_ADDR
// if BuildingStatus ( tmp [ 1 ] ) = bs_idle and ( not tmp [ 1 ] in MREG_ToBunker [ side ] ) and k then
40497: LD_VAR 0 12
40501: PUSH
40502: LD_INT 1
40504: ARRAY
40505: PPUSH
40506: CALL_OW 461
40510: PUSH
40511: LD_INT 2
40513: EQUAL
40514: PUSH
40515: LD_VAR 0 12
40519: PUSH
40520: LD_INT 1
40522: ARRAY
40523: PUSH
40524: LD_EXP 70
40528: PUSH
40529: LD_VAR 0 1
40533: ARRAY
40534: IN
40535: NOT
40536: AND
40537: PUSH
40538: LD_VAR 0 8
40542: AND
40543: IFFALSE 40580
// begin ComExitBuilding ( k [ 1 ] ) ;
40545: LD_VAR 0 8
40549: PUSH
40550: LD_INT 1
40552: ARRAY
40553: PPUSH
40554: CALL_OW 122
// AddComEnterUnit ( k [ 1 ] , tmp [ 1 ] ) ;
40558: LD_VAR 0 8
40562: PUSH
40563: LD_INT 1
40565: ARRAY
40566: PPUSH
40567: LD_VAR 0 12
40571: PUSH
40572: LD_INT 1
40574: ARRAY
40575: PPUSH
40576: CALL_OW 180
// end ; end ; if MREG_Heal [ side ] then
40580: LD_EXP 37
40584: PUSH
40585: LD_VAR 0 1
40589: ARRAY
40590: IFFALSE 40738
// begin if MCF_Class ( side , 4 , [ ] ) then
40592: LD_VAR 0 1
40596: PPUSH
40597: LD_INT 4
40599: PPUSH
40600: EMPTY
40601: PPUSH
40602: CALL 11670 0 3
40606: IFFALSE 40736
// for j in MCF_Class ( side , 4 , [ ] ) do
40608: LD_ADDR_VAR 0 5
40612: PUSH
40613: LD_VAR 0 1
40617: PPUSH
40618: LD_INT 4
40620: PPUSH
40621: EMPTY
40622: PPUSH
40623: CALL 11670 0 3
40627: PUSH
40628: FOR_IN
40629: IFFALSE 40734
// begin if not GetTag ( j ) = 4 then
40631: LD_VAR 0 5
40635: PPUSH
40636: CALL_OW 110
40640: PUSH
40641: LD_INT 4
40643: EQUAL
40644: NOT
40645: IFFALSE 40681
// begin SetTag ( j , 4 ) ;
40647: LD_VAR 0 5
40651: PPUSH
40652: LD_INT 4
40654: PPUSH
40655: CALL_OW 109
// if IsInUnit ( j ) then
40659: LD_VAR 0 5
40663: PPUSH
40664: CALL_OW 310
40668: IFFALSE 40679
// ComExitBuilding ( j ) ;
40670: LD_VAR 0 5
40674: PPUSH
40675: CALL_OW 122
// end else
40679: GO 40732
// if not WantHeal ( j , MREG_Heal [ side ] [ 1 ] ) then
40681: LD_VAR 0 5
40685: PPUSH
40686: LD_EXP 37
40690: PUSH
40691: LD_VAR 0 1
40695: ARRAY
40696: PUSH
40697: LD_INT 1
40699: ARRAY
40700: PPUSH
40701: CALL 91501 0 2
40705: NOT
40706: IFFALSE 40732
// MCP_Heal ( j , MREG_Heal [ side ] [ 1 ] ) ;
40708: LD_VAR 0 5
40712: PPUSH
40713: LD_EXP 37
40717: PUSH
40718: LD_VAR 0 1
40722: ARRAY
40723: PUSH
40724: LD_INT 1
40726: ARRAY
40727: PPUSH
40728: CALL 19157 0 2
// end ;
40732: GO 40628
40734: POP
40735: POP
// end else
40736: GO 40970
// begin if MCF_Class ( side , 4 , [ ] ) and MCF_Tag ( side , 4 , [ ] ) then
40738: LD_VAR 0 1
40742: PPUSH
40743: LD_INT 4
40745: PPUSH
40746: EMPTY
40747: PPUSH
40748: CALL 11670 0 3
40752: PUSH
40753: LD_VAR 0 1
40757: PPUSH
40758: LD_INT 4
40760: PPUSH
40761: EMPTY
40762: PPUSH
40763: CALL 12290 0 3
40767: AND
40768: IFFALSE 40970
// for j in MCF_Class ( side , 4 , [ ] ) do
40770: LD_ADDR_VAR 0 5
40774: PUSH
40775: LD_VAR 0 1
40779: PPUSH
40780: LD_INT 4
40782: PPUSH
40783: EMPTY
40784: PPUSH
40785: CALL 11670 0 3
40789: PUSH
40790: FOR_IN
40791: IFFALSE 40968
// begin if GetTag ( j ) = 4 then
40793: LD_VAR 0 5
40797: PPUSH
40798: CALL_OW 110
40802: PUSH
40803: LD_INT 4
40805: EQUAL
40806: IFFALSE 40966
// begin SetTag ( j , 0 ) ;
40808: LD_VAR 0 5
40812: PPUSH
40813: LD_INT 0
40815: PPUSH
40816: CALL_OW 109
// if MCF_Lab ( side ) and not MCL_GetTechList ( side ) then
40820: LD_VAR 0 1
40824: PPUSH
40825: CALL 11626 0 1
40829: PUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: CALL 17970 0 1
40839: NOT
40840: AND
40841: IFFALSE 40866
// ComEnterUnit ( j , MCF_Lab ( side ) [ 1 ] ) ;
40843: LD_VAR 0 5
40847: PPUSH
40848: LD_VAR 0 1
40852: PPUSH
40853: CALL 11626 0 1
40857: PUSH
40858: LD_INT 1
40860: ARRAY
40861: PPUSH
40862: CALL_OW 120
// if not MCF_Lab ( side ) and MCF_Get ( side , [ f_btype , b_warehouse ] ) then
40866: LD_VAR 0 1
40870: PPUSH
40871: CALL 11626 0 1
40875: NOT
40876: PUSH
40877: LD_VAR 0 1
40881: PPUSH
40882: LD_INT 30
40884: PUSH
40885: LD_INT 1
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PPUSH
40892: CALL 11587 0 2
40896: AND
40897: IFFALSE 40966
// ComMoveXY ( j , GetX ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) , GetY ( MCF_Get ( side , [ f_btype , b_warehouse ] ) [ 1 ] ) ) ;
40899: LD_VAR 0 5
40903: PPUSH
40904: LD_VAR 0 1
40908: PPUSH
40909: LD_INT 30
40911: PUSH
40912: LD_INT 1
40914: PUSH
40915: EMPTY
40916: LIST
40917: LIST
40918: PPUSH
40919: CALL 11587 0 2
40923: PUSH
40924: LD_INT 1
40926: ARRAY
40927: PPUSH
40928: CALL_OW 250
40932: PPUSH
40933: LD_VAR 0 1
40937: PPUSH
40938: LD_INT 30
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PPUSH
40948: CALL 11587 0 2
40952: PUSH
40953: LD_INT 1
40955: ARRAY
40956: PPUSH
40957: CALL_OW 251
40961: PPUSH
40962: CALL_OW 111
// end ; end ;
40966: GO 40790
40968: POP
40969: POP
// end ; if MCF_Class ( side , 3 , [ ] ) and MREG_Parking [ side ] and MCF_Tag ( side , 6 , [ ] ) then
40970: LD_VAR 0 1
40974: PPUSH
40975: LD_INT 3
40977: PPUSH
40978: EMPTY
40979: PPUSH
40980: CALL 11670 0 3
40984: PUSH
40985: LD_EXP 60
40989: PUSH
40990: LD_VAR 0 1
40994: ARRAY
40995: AND
40996: PUSH
40997: LD_VAR 0 1
41001: PPUSH
41002: LD_INT 6
41004: PPUSH
41005: EMPTY
41006: PPUSH
41007: CALL 12290 0 3
41011: AND
41012: IFFALSE 41543
// begin x := AreaToList ( MREG_Parking [ side ] , 0 ) [ 1 ] [ 1 ] ;
41014: LD_ADDR_VAR 0 6
41018: PUSH
41019: LD_EXP 60
41023: PUSH
41024: LD_VAR 0 1
41028: ARRAY
41029: PPUSH
41030: LD_INT 0
41032: PPUSH
41033: CALL_OW 517
41037: PUSH
41038: LD_INT 1
41040: ARRAY
41041: PUSH
41042: LD_INT 1
41044: ARRAY
41045: ST_TO_ADDR
// y := AreaToList ( MREG_Parking [ side ] , 0 ) [ 2 ] [ 1 ] ;
41046: LD_ADDR_VAR 0 7
41050: PUSH
41051: LD_EXP 60
41055: PUSH
41056: LD_VAR 0 1
41060: ARRAY
41061: PPUSH
41062: LD_INT 0
41064: PPUSH
41065: CALL_OW 517
41069: PUSH
41070: LD_INT 2
41072: ARRAY
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: ST_TO_ADDR
// if MCF_Tag ( side , 6 , [ ] ) then
41078: LD_VAR 0 1
41082: PPUSH
41083: LD_INT 6
41085: PPUSH
41086: EMPTY
41087: PPUSH
41088: CALL 12290 0 3
41092: IFFALSE 41541
// begin for k in MCF_Tag ( side , 6 , [ ] ) do
41094: LD_ADDR_VAR 0 8
41098: PUSH
41099: LD_VAR 0 1
41103: PPUSH
41104: LD_INT 6
41106: PPUSH
41107: EMPTY
41108: PPUSH
41109: CALL 12290 0 3
41113: PUSH
41114: FOR_IN
41115: IFFALSE 41146
// if GetLives ( k ) = 1000 then
41117: LD_VAR 0 8
41121: PPUSH
41122: CALL_OW 256
41126: PUSH
41127: LD_INT 1000
41129: EQUAL
41130: IFFALSE 41144
// SetTag ( k , 0 ) ;
41132: LD_VAR 0 8
41136: PPUSH
41137: LD_INT 0
41139: PPUSH
41140: CALL_OW 109
41144: GO 41114
41146: POP
41147: POP
// if MCF_Tag ( side , 0 , [ f_class , 3 ] ) then
41148: LD_VAR 0 1
41152: PPUSH
41153: LD_INT 0
41155: PPUSH
41156: LD_INT 25
41158: PUSH
41159: LD_INT 3
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PPUSH
41166: CALL 12290 0 3
41170: IFFALSE 41234
// begin for k in MCF_Tag ( i , 0 , [ f_class , 3 ] ) do
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_VAR 0 4
41181: PPUSH
41182: LD_INT 0
41184: PPUSH
41185: LD_INT 25
41187: PUSH
41188: LD_INT 3
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PPUSH
41195: CALL 12290 0 3
41199: PUSH
41200: FOR_IN
41201: IFFALSE 41232
// if GetTag ( k ) = 0 then
41203: LD_VAR 0 8
41207: PPUSH
41208: CALL_OW 110
41212: PUSH
41213: LD_INT 0
41215: EQUAL
41216: IFFALSE 41230
// begin SetTag ( k , 8 ) ;
41218: LD_VAR 0 8
41222: PPUSH
41223: LD_INT 8
41225: PPUSH
41226: CALL_OW 109
// end ;
41230: GO 41200
41232: POP
41233: POP
// end ; if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) then
41234: LD_VAR 0 1
41238: PPUSH
41239: LD_INT 6
41241: PPUSH
41242: LD_INT 92
41244: PUSH
41245: LD_VAR 0 6
41249: PUSH
41250: LD_VAR 0 7
41254: PUSH
41255: LD_INT 10
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: PPUSH
41264: CALL 12290 0 3
41268: IFFALSE 41392
// for j in MCF_Tag ( i , 6 , [ f_distxy , x , y , 10 ] ) do
41270: LD_ADDR_VAR 0 5
41274: PUSH
41275: LD_VAR 0 4
41279: PPUSH
41280: LD_INT 6
41282: PPUSH
41283: LD_INT 92
41285: PUSH
41286: LD_VAR 0 6
41290: PUSH
41291: LD_VAR 0 7
41295: PUSH
41296: LD_INT 10
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: LIST
41303: LIST
41304: PPUSH
41305: CALL 12290 0 3
41309: PUSH
41310: FOR_IN
41311: IFFALSE 41390
// begin if not HasTask ( j ) and GetDriver ( j ) then
41313: LD_VAR 0 5
41317: PPUSH
41318: CALL_OW 314
41322: NOT
41323: PUSH
41324: LD_VAR 0 5
41328: PPUSH
41329: CALL 31695 0 1
41333: AND
41334: IFFALSE 41388
// begin ComExitVehicle ( GetDriver ( j ) ) ;
41336: LD_VAR 0 5
41340: PPUSH
41341: CALL 31695 0 1
41345: PPUSH
41346: CALL_OW 121
// AddComRepairVehicle ( GetDriver ( j ) , j ) ;
41350: LD_VAR 0 5
41354: PPUSH
41355: CALL 31695 0 1
41359: PPUSH
41360: LD_VAR 0 5
41364: PPUSH
41365: CALL_OW 189
// AddComEnterUnit ( GetDriver ( j ) , j ) ;
41369: LD_VAR 0 5
41373: PPUSH
41374: CALL 31695 0 1
41378: PPUSH
41379: LD_VAR 0 5
41383: PPUSH
41384: CALL_OW 180
// end ; end ;
41388: GO 41310
41390: POP
41391: POP
// if MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) and MCF_Tag ( side , 8 , [ ] ) then
41392: LD_VAR 0 1
41396: PPUSH
41397: LD_INT 6
41399: PPUSH
41400: LD_INT 92
41402: PUSH
41403: LD_VAR 0 6
41407: PUSH
41408: LD_VAR 0 7
41412: PUSH
41413: LD_INT 10
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL 12290 0 3
41426: PUSH
41427: LD_VAR 0 1
41431: PPUSH
41432: LD_INT 8
41434: PPUSH
41435: EMPTY
41436: PPUSH
41437: CALL 12290 0 3
41441: AND
41442: IFFALSE 41541
// for j in MCF_Tag ( side , 8 , [ ] ) do
41444: LD_ADDR_VAR 0 5
41448: PUSH
41449: LD_VAR 0 1
41453: PPUSH
41454: LD_INT 8
41456: PPUSH
41457: EMPTY
41458: PPUSH
41459: CALL 12290 0 3
41463: PUSH
41464: FOR_IN
41465: IFFALSE 41539
// begin if IsInUnit ( j ) then
41467: LD_VAR 0 5
41471: PPUSH
41472: CALL_OW 310
41476: IFFALSE 41489
// ComExitBuilding ( j ) else
41478: LD_VAR 0 5
41482: PPUSH
41483: CALL_OW 122
41487: GO 41537
// ComRepairVehicle ( j , MCF_Tag ( side , 6 , [ f_distxy , x , y , 10 ] ) [ 1 ] ) ;
41489: LD_VAR 0 5
41493: PPUSH
41494: LD_VAR 0 1
41498: PPUSH
41499: LD_INT 6
41501: PPUSH
41502: LD_INT 92
41504: PUSH
41505: LD_VAR 0 6
41509: PUSH
41510: LD_VAR 0 7
41514: PUSH
41515: LD_INT 10
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: PPUSH
41524: CALL 12290 0 3
41528: PUSH
41529: LD_INT 1
41531: ARRAY
41532: PPUSH
41533: CALL_OW 129
// end ;
41537: GO 41464
41539: POP
41540: POP
// end ; end else
41541: GO 41598
// if MCF_Tag ( side , 8 , [ ] ) then
41543: LD_VAR 0 1
41547: PPUSH
41548: LD_INT 8
41550: PPUSH
41551: EMPTY
41552: PPUSH
41553: CALL 12290 0 3
41557: IFFALSE 41598
// for k in MCF_Tag ( side , 8 , [ ] ) do
41559: LD_ADDR_VAR 0 8
41563: PUSH
41564: LD_VAR 0 1
41568: PPUSH
41569: LD_INT 8
41571: PPUSH
41572: EMPTY
41573: PPUSH
41574: CALL 12290 0 3
41578: PUSH
41579: FOR_IN
41580: IFFALSE 41596
// SetTag ( k , 0 ) ;
41582: LD_VAR 0 8
41586: PPUSH
41587: LD_INT 0
41589: PPUSH
41590: CALL_OW 109
41594: GO 41579
41596: POP
41597: POP
// end ; end_of_file
41598: LD_VAR 0 3
41602: RET
// export MREG_Game , MREG_Crates , MREG_Heal , MREG_TamedApe , MREG_Tame , MREG_ApeOptions , MREG_SidesList , MREG_LabList , MREG_Cargo , MREG_Bulldozer , MREG_TurretWeapon , MREG_VehicleWeapon , MREG_Status , MREG_ToBuild , MREG_ToRepair , MREG_ToUpdate , MREG_ToUpLab , MREG_ToRes , MREG_ToConstruct , MREG_ToDismantle , MREG_ToChangeClass , MREG_ToLab , MREG_ToFac , MREG_ToArm , MREG_ToDep , MREG_Parking , MREG_VCombat , MREG_Collect , MREG_Deposit , MREG_AllowClass , MREG_DefPoints , MREG_DefArea , MREG_DefDontLeave , MREG_DefSquad , MREG_DefVeh , MREG_ToBunker , MREG_ToAttack , MREG_DefMobActive , MREG_Attackers , MREG_ResourcesBonus ; export function MC_Registry ( ) ; begin
41603: LD_INT 0
41605: PPUSH
// MREG_Game := [ ] ;
41606: LD_ADDR_EXP 35
41610: PUSH
41611: EMPTY
41612: ST_TO_ADDR
// MREG_Crates := [ ] ;
41613: LD_ADDR_EXP 36
41617: PUSH
41618: EMPTY
41619: ST_TO_ADDR
// MREG_Heal := [ ] ;
41620: LD_ADDR_EXP 37
41624: PUSH
41625: EMPTY
41626: ST_TO_ADDR
// MREG_Tame := [ ] ;
41627: LD_ADDR_EXP 39
41631: PUSH
41632: EMPTY
41633: ST_TO_ADDR
// MREG_ApeOptions := [ ] ;
41634: LD_ADDR_EXP 40
41638: PUSH
41639: EMPTY
41640: ST_TO_ADDR
// MREG_SidesList := [ ] ;
41641: LD_ADDR_EXP 41
41645: PUSH
41646: EMPTY
41647: ST_TO_ADDR
// MREG_LabList := [ ] ;
41648: LD_ADDR_EXP 42
41652: PUSH
41653: EMPTY
41654: ST_TO_ADDR
// MREG_Cargo := [ ] ;
41655: LD_ADDR_EXP 43
41659: PUSH
41660: EMPTY
41661: ST_TO_ADDR
// MREG_Bulldozer := [ ] ;
41662: LD_ADDR_EXP 44
41666: PUSH
41667: EMPTY
41668: ST_TO_ADDR
// MREG_TurretWeapon := [ ] ;
41669: LD_ADDR_EXP 45
41673: PUSH
41674: EMPTY
41675: ST_TO_ADDR
// MREG_VehicleWeapon := [ ] ;
41676: LD_ADDR_EXP 46
41680: PUSH
41681: EMPTY
41682: ST_TO_ADDR
// MREG_Status := [ ] ;
41683: LD_ADDR_EXP 47
41687: PUSH
41688: EMPTY
41689: ST_TO_ADDR
// MREG_ToBuild := [ ] ;
41690: LD_ADDR_EXP 48
41694: PUSH
41695: EMPTY
41696: ST_TO_ADDR
// MREG_ToRepair := [ ] ;
41697: LD_ADDR_EXP 49
41701: PUSH
41702: EMPTY
41703: ST_TO_ADDR
// MREG_ToUpdate := [ ] ;
41704: LD_ADDR_EXP 50
41708: PUSH
41709: EMPTY
41710: ST_TO_ADDR
// MREG_ToUpLab := [ ] ;
41711: LD_ADDR_EXP 51
41715: PUSH
41716: EMPTY
41717: ST_TO_ADDR
// MREG_ToRes := [ ] ;
41718: LD_ADDR_EXP 52
41722: PUSH
41723: EMPTY
41724: ST_TO_ADDR
// MREG_ToConstruct := [ ] ;
41725: LD_ADDR_EXP 53
41729: PUSH
41730: EMPTY
41731: ST_TO_ADDR
// MREG_ToDismantle := [ ] ;
41732: LD_ADDR_EXP 54
41736: PUSH
41737: EMPTY
41738: ST_TO_ADDR
// MREG_ToChangeClass := [ ] ;
41739: LD_ADDR_EXP 55
41743: PUSH
41744: EMPTY
41745: ST_TO_ADDR
// MREG_ToLab := [ ] ;
41746: LD_ADDR_EXP 56
41750: PUSH
41751: EMPTY
41752: ST_TO_ADDR
// MREG_ToFac := [ ] ;
41753: LD_ADDR_EXP 57
41757: PUSH
41758: EMPTY
41759: ST_TO_ADDR
// MREG_ToArm := [ ] ;
41760: LD_ADDR_EXP 58
41764: PUSH
41765: EMPTY
41766: ST_TO_ADDR
// MREG_ToDep := [ ] ;
41767: LD_ADDR_EXP 59
41771: PUSH
41772: EMPTY
41773: ST_TO_ADDR
// MREG_Deposit := [ ] ;
41774: LD_ADDR_EXP 63
41778: PUSH
41779: EMPTY
41780: ST_TO_ADDR
// MREG_AllowClass := [ ] ;
41781: LD_ADDR_EXP 64
41785: PUSH
41786: EMPTY
41787: ST_TO_ADDR
// MREG_Parking := [ ] ;
41788: LD_ADDR_EXP 60
41792: PUSH
41793: EMPTY
41794: ST_TO_ADDR
// MREG_VCombat := [ ] ;
41795: LD_ADDR_EXP 61
41799: PUSH
41800: EMPTY
41801: ST_TO_ADDR
// MREG_DefPoints := [ ] ;
41802: LD_ADDR_EXP 65
41806: PUSH
41807: EMPTY
41808: ST_TO_ADDR
// MREG_DefArea := [ ] ;
41809: LD_ADDR_EXP 66
41813: PUSH
41814: EMPTY
41815: ST_TO_ADDR
// MREG_DefDontLeave := [ ] ;
41816: LD_ADDR_EXP 67
41820: PUSH
41821: EMPTY
41822: ST_TO_ADDR
// MREG_DefVeh := [ ] ;
41823: LD_ADDR_EXP 69
41827: PUSH
41828: EMPTY
41829: ST_TO_ADDR
// MREG_ToBunker := [ ] ;
41830: LD_ADDR_EXP 70
41834: PUSH
41835: EMPTY
41836: ST_TO_ADDR
// MREG_ToAttack := [ ] ;
41837: LD_ADDR_EXP 71
41841: PUSH
41842: EMPTY
41843: ST_TO_ADDR
// MREG_Attackers := [ ] ;
41844: LD_ADDR_EXP 73
41848: PUSH
41849: EMPTY
41850: ST_TO_ADDR
// MREG_DefMobActive := [ ] ;
41851: LD_ADDR_EXP 72
41855: PUSH
41856: EMPTY
41857: ST_TO_ADDR
// MREG_ResourcesBonus := [ 300 , 100 , 25 ] ;
41858: LD_ADDR_EXP 74
41862: PUSH
41863: LD_INT 300
41865: PUSH
41866: LD_INT 100
41868: PUSH
41869: LD_INT 25
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: LIST
41876: ST_TO_ADDR
// end ;
41877: LD_VAR 0 1
41881: RET
// export function MC_RegistryUpdate ( mreg_list , side , unit , mreg ) ; begin
41882: LD_INT 0
41884: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41885: LD_VAR 0 2
41889: PUSH
41890: LD_VAR 0 3
41894: PUSH
41895: LD_VAR 0 4
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: PUSH
41905: LD_VAR 0 1
41909: IN
41910: IFFALSE 41924
// result := mreg_list else
41912: LD_ADDR_VAR 0 5
41916: PUSH
41917: LD_VAR 0 1
41921: ST_TO_ADDR
41922: GO 41958
// mreg_list := mreg_list ^ [ [ side , unit , mreg ] ] ;
41924: LD_ADDR_VAR 0 1
41928: PUSH
41929: LD_VAR 0 1
41933: PUSH
41934: LD_VAR 0 2
41938: PUSH
41939: LD_VAR 0 3
41943: PUSH
41944: LD_VAR 0 4
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: LIST
41953: PUSH
41954: EMPTY
41955: LIST
41956: ADD
41957: ST_TO_ADDR
// result := mreg_list ;
41958: LD_ADDR_VAR 0 5
41962: PUSH
41963: LD_VAR 0 1
41967: ST_TO_ADDR
// end ;
41968: LD_VAR 0 5
41972: RET
// export function MC_RegistryDelete ( mreg_list , side , unit , mreg ) ; begin
41973: LD_INT 0
41975: PPUSH
// if [ side , unit , mreg ] in mreg_list then
41976: LD_VAR 0 2
41980: PUSH
41981: LD_VAR 0 3
41985: PUSH
41986: LD_VAR 0 4
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: LIST
41995: PUSH
41996: LD_VAR 0 1
42000: IN
42001: IFFALSE 42039
// result := mreg_list diff [ [ side , unit , mreg ] ] else
42003: LD_ADDR_VAR 0 5
42007: PUSH
42008: LD_VAR 0 1
42012: PUSH
42013: LD_VAR 0 2
42017: PUSH
42018: LD_VAR 0 3
42022: PUSH
42023: LD_VAR 0 4
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: PUSH
42033: EMPTY
42034: LIST
42035: DIFF
42036: ST_TO_ADDR
42037: GO 42049
// result := mreg_list ;
42039: LD_ADDR_VAR 0 5
42043: PUSH
42044: LD_VAR 0 1
42048: ST_TO_ADDR
// end ;
42049: LD_VAR 0 5
42053: RET
// export function MC_RegistryInit ( ) ; var i , j ; begin
42054: LD_INT 0
42056: PPUSH
42057: PPUSH
42058: PPUSH
// for j = 1 to 8 do
42059: LD_ADDR_VAR 0 3
42063: PUSH
42064: DOUBLE
42065: LD_INT 1
42067: DEC
42068: ST_TO_ADDR
42069: LD_INT 8
42071: PUSH
42072: FOR_TO
42073: IFFALSE 42914
// begin if MCF_Get ( j , [ f_alive ] ) and not your_side = j then
42075: LD_VAR 0 3
42079: PPUSH
42080: LD_INT 51
42082: PUSH
42083: EMPTY
42084: LIST
42085: PPUSH
42086: CALL 11587 0 2
42090: PUSH
42091: LD_OWVAR 2
42095: PUSH
42096: LD_VAR 0 3
42100: EQUAL
42101: NOT
42102: AND
42103: IFFALSE 42121
// MREG_SidesList := MREG_SidesList ^ 1 else
42105: LD_ADDR_EXP 41
42109: PUSH
42110: LD_EXP 41
42114: PUSH
42115: LD_INT 1
42117: ADD
42118: ST_TO_ADDR
42119: GO 42135
// MREG_SidesList := MREG_SidesList ^ 0 ;
42121: LD_ADDR_EXP 41
42125: PUSH
42126: LD_EXP 41
42130: PUSH
42131: LD_INT 0
42133: ADD
42134: ST_TO_ADDR
// if MCF_Vehicle ( j , [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) then
42135: LD_VAR 0 3
42139: PPUSH
42140: LD_INT 2
42142: PUSH
42143: LD_INT 34
42145: PUSH
42146: LD_INT 12
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 34
42155: PUSH
42156: LD_INT 32
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 34
42165: PUSH
42166: LD_INT 51
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: PUSH
42179: EMPTY
42180: LIST
42181: PPUSH
42182: CALL 11888 0 2
42186: IFFALSE 42287
// for i in MCF_Vehicle ( j , [ f_or , [ [ f_weapon , us_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] ] ] ) do
42188: LD_ADDR_VAR 0 2
42192: PUSH
42193: LD_VAR 0 3
42197: PPUSH
42198: LD_INT 2
42200: PUSH
42201: LD_INT 34
42203: PUSH
42204: LD_INT 12
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 34
42213: PUSH
42214: LD_INT 32
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 34
42223: PUSH
42224: LD_INT 51
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: LIST
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PPUSH
42240: CALL 11888 0 2
42244: PUSH
42245: FOR_IN
42246: IFFALSE 42285
// MREG_Cargo := MC_RegistryUpdate ( MREG_Cargo , j , i , GetWeapon ( i ) ) ;
42248: LD_ADDR_EXP 43
42252: PUSH
42253: LD_EXP 43
42257: PPUSH
42258: LD_VAR 0 3
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: LD_VAR 0 2
42272: PPUSH
42273: CALL_OW 264
42277: PPUSH
42278: CALL 41882 0 4
42282: ST_TO_ADDR
42283: GO 42245
42285: POP
42286: POP
// if MCF_Class ( j , 4 , [ ] ) then
42287: LD_VAR 0 3
42291: PPUSH
42292: LD_INT 4
42294: PPUSH
42295: EMPTY
42296: PPUSH
42297: CALL 11670 0 3
42301: IFFALSE 42334
// MREG_ToLab := MREG_ToLab ^ [ MCF_Class ( j , 4 , [ ] ) ] else
42303: LD_ADDR_EXP 56
42307: PUSH
42308: LD_EXP 56
42312: PUSH
42313: LD_VAR 0 3
42317: PPUSH
42318: LD_INT 4
42320: PPUSH
42321: EMPTY
42322: PPUSH
42323: CALL 11670 0 3
42327: PUSH
42328: EMPTY
42329: LIST
42330: ADD
42331: ST_TO_ADDR
42332: GO 42351
// MREG_ToLab := MREG_ToLab ^ [ 0 ] ;
42334: LD_ADDR_EXP 56
42338: PUSH
42339: LD_EXP 56
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: EMPTY
42348: LIST
42349: ADD
42350: ST_TO_ADDR
// if MCF_Class ( j , 3 , [ ] ) then
42351: LD_VAR 0 3
42355: PPUSH
42356: LD_INT 3
42358: PPUSH
42359: EMPTY
42360: PPUSH
42361: CALL 11670 0 3
42365: IFFALSE 42398
// MREG_ToFac := MREG_ToFac ^ [ MCF_Class ( j , 3 , [ ] ) ] else
42367: LD_ADDR_EXP 57
42371: PUSH
42372: LD_EXP 57
42376: PUSH
42377: LD_VAR 0 3
42381: PPUSH
42382: LD_INT 3
42384: PPUSH
42385: EMPTY
42386: PPUSH
42387: CALL 11670 0 3
42391: PUSH
42392: EMPTY
42393: LIST
42394: ADD
42395: ST_TO_ADDR
42396: GO 42415
// MREG_ToFac := MREG_ToFac ^ [ 0 ] ;
42398: LD_ADDR_EXP 57
42402: PUSH
42403: LD_EXP 57
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: EMPTY
42412: LIST
42413: ADD
42414: ST_TO_ADDR
// if MCF_Class ( j , 1 , [ ] ) then
42415: LD_VAR 0 3
42419: PPUSH
42420: LD_INT 1
42422: PPUSH
42423: EMPTY
42424: PPUSH
42425: CALL 11670 0 3
42429: IFFALSE 42462
// MREG_ToArm := MREG_ToArm ^ [ MCF_Class ( j , 1 , [ ] ) ] else
42431: LD_ADDR_EXP 58
42435: PUSH
42436: LD_EXP 58
42440: PUSH
42441: LD_VAR 0 3
42445: PPUSH
42446: LD_INT 1
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL 11670 0 3
42455: PUSH
42456: EMPTY
42457: LIST
42458: ADD
42459: ST_TO_ADDR
42460: GO 42479
// MREG_ToArm := MREG_ToArm ^ [ 0 ] ;
42462: LD_ADDR_EXP 58
42466: PUSH
42467: LD_EXP 58
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: EMPTY
42476: LIST
42477: ADD
42478: ST_TO_ADDR
// if MCF_Class ( j , 2 , [ ] ) then
42479: LD_VAR 0 3
42483: PPUSH
42484: LD_INT 2
42486: PPUSH
42487: EMPTY
42488: PPUSH
42489: CALL 11670 0 3
42493: IFFALSE 42526
// MREG_ToDep := MREG_ToDep ^ [ MCF_Class ( j , 2 , [ ] ) ] else
42495: LD_ADDR_EXP 59
42499: PUSH
42500: LD_EXP 59
42504: PUSH
42505: LD_VAR 0 3
42509: PPUSH
42510: LD_INT 2
42512: PPUSH
42513: EMPTY
42514: PPUSH
42515: CALL 11670 0 3
42519: PUSH
42520: EMPTY
42521: LIST
42522: ADD
42523: ST_TO_ADDR
42524: GO 42543
// MREG_ToDep := MREG_ToDep ^ [ 0 ] ;
42526: LD_ADDR_EXP 59
42530: PUSH
42531: LD_EXP 59
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: ADD
42542: ST_TO_ADDR
// MREG_ToRepair := MREG_ToRepair ^ [ 0 ] ;
42543: LD_ADDR_EXP 49
42547: PUSH
42548: LD_EXP 49
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: EMPTY
42557: LIST
42558: ADD
42559: ST_TO_ADDR
// MREG_Heal := MREG_Heal ^ [ 0 ] ;
42560: LD_ADDR_EXP 37
42564: PUSH
42565: LD_EXP 37
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: EMPTY
42574: LIST
42575: ADD
42576: ST_TO_ADDR
// MREG_Tame := MREG_Tame ^ [ 0 ] ;
42577: LD_ADDR_EXP 39
42581: PUSH
42582: LD_EXP 39
42586: PUSH
42587: LD_INT 0
42589: PUSH
42590: EMPTY
42591: LIST
42592: ADD
42593: ST_TO_ADDR
// MREG_Parking := MREG_Parking ^ [ 0 ] ;
42594: LD_ADDR_EXP 60
42598: PUSH
42599: LD_EXP 60
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: EMPTY
42608: LIST
42609: ADD
42610: ST_TO_ADDR
// MREG_VCombat := MREG_VCombat ^ [ 0 ] ;
42611: LD_ADDR_EXP 61
42615: PUSH
42616: LD_EXP 61
42620: PUSH
42621: LD_INT 0
42623: PUSH
42624: EMPTY
42625: LIST
42626: ADD
42627: ST_TO_ADDR
// MREG_ToConstruct := MREG_ToConstruct ^ [ 0 ] ;
42628: LD_ADDR_EXP 53
42632: PUSH
42633: LD_EXP 53
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: ADD
42644: ST_TO_ADDR
// MREG_ApeOptions := MREG_ApeOptions ^ [ [ 0 , 0 , 0 , 0 ] ] ;
42645: LD_ADDR_EXP 40
42649: PUSH
42650: LD_EXP 40
42654: PUSH
42655: LD_INT 0
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: LD_INT 0
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: LIST
42671: LIST
42672: PUSH
42673: EMPTY
42674: LIST
42675: ADD
42676: ST_TO_ADDR
// MREG_Collect := MREG_Collect ^ [ [ 0 , [ ] ] ] ;
42677: LD_ADDR_EXP 62
42681: PUSH
42682: LD_EXP 62
42686: PUSH
42687: LD_INT 0
42689: PUSH
42690: EMPTY
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: EMPTY
42697: LIST
42698: ADD
42699: ST_TO_ADDR
// MREG_Deposit := MREG_Deposit ^ [ [ 0 ] ] ;
42700: LD_ADDR_EXP 63
42704: PUSH
42705: LD_EXP 63
42709: PUSH
42710: LD_INT 0
42712: PUSH
42713: EMPTY
42714: LIST
42715: PUSH
42716: EMPTY
42717: LIST
42718: ADD
42719: ST_TO_ADDR
// MREG_Bulldozer := MREG_Bulldozer ^ [ 0 ] ;
42720: LD_ADDR_EXP 44
42724: PUSH
42725: LD_EXP 44
42729: PUSH
42730: LD_INT 0
42732: PUSH
42733: EMPTY
42734: LIST
42735: ADD
42736: ST_TO_ADDR
// MREG_DefPoints := MREG_DefPoints ^ [ 0 ] ;
42737: LD_ADDR_EXP 65
42741: PUSH
42742: LD_EXP 65
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: EMPTY
42751: LIST
42752: ADD
42753: ST_TO_ADDR
// MREG_DefArea := MREG_DefArea ^ [ 0 ] ;
42754: LD_ADDR_EXP 66
42758: PUSH
42759: LD_EXP 66
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: EMPTY
42768: LIST
42769: ADD
42770: ST_TO_ADDR
// MREG_DefDontLeave := MREG_DefDontLeave ^ [ 0 ] ;
42771: LD_ADDR_EXP 67
42775: PUSH
42776: LD_EXP 67
42780: PUSH
42781: LD_INT 0
42783: PUSH
42784: EMPTY
42785: LIST
42786: ADD
42787: ST_TO_ADDR
// MREG_DefSquad := MREG_DefSquad ^ [ 0 ] ;
42788: LD_ADDR_EXP 68
42792: PUSH
42793: LD_EXP 68
42797: PUSH
42798: LD_INT 0
42800: PUSH
42801: EMPTY
42802: LIST
42803: ADD
42804: ST_TO_ADDR
// MREG_DefVeh := MREG_DefVeh ^ [ 0 ] ;
42805: LD_ADDR_EXP 69
42809: PUSH
42810: LD_EXP 69
42814: PUSH
42815: LD_INT 0
42817: PUSH
42818: EMPTY
42819: LIST
42820: ADD
42821: ST_TO_ADDR
// MREG_ToBunker := MREG_ToBunker ^ [ 0 ] ;
42822: LD_ADDR_EXP 70
42826: PUSH
42827: LD_EXP 70
42831: PUSH
42832: LD_INT 0
42834: PUSH
42835: EMPTY
42836: LIST
42837: ADD
42838: ST_TO_ADDR
// MREG_ToAttack := MREG_ToAttack ^ [ 0 ] ;
42839: LD_ADDR_EXP 71
42843: PUSH
42844: LD_EXP 71
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: ADD
42855: ST_TO_ADDR
// MREG_Attackers := MREG_Attackers ^ [ 0 ] ;
42856: LD_ADDR_EXP 73
42860: PUSH
42861: LD_EXP 73
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: EMPTY
42870: LIST
42871: ADD
42872: ST_TO_ADDR
// MREG_DefMobActive := MREG_DefMobActive ^ 0 ;
42873: LD_ADDR_EXP 72
42877: PUSH
42878: LD_EXP 72
42882: PUSH
42883: LD_INT 0
42885: ADD
42886: ST_TO_ADDR
// MREG_AllowClass := MREG_AllowClass ^ [ 0 , 0 , 0 ] ;
42887: LD_ADDR_EXP 64
42891: PUSH
42892: LD_EXP 64
42896: PUSH
42897: LD_INT 0
42899: PUSH
42900: LD_INT 0
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: LIST
42910: ADD
42911: ST_TO_ADDR
// end ;
42912: GO 42072
42914: POP
42915: POP
// end ;
42916: LD_VAR 0 1
42920: RET
// export function MREG_ForSide ( side , mreg ) ; var i , m ; begin
42921: LD_INT 0
42923: PPUSH
42924: PPUSH
42925: PPUSH
// m := false ;
42926: LD_ADDR_VAR 0 5
42930: PUSH
42931: LD_INT 0
42933: ST_TO_ADDR
// for i = 1 to mreg do
42934: LD_ADDR_VAR 0 4
42938: PUSH
42939: DOUBLE
42940: LD_INT 1
42942: DEC
42943: ST_TO_ADDR
42944: LD_VAR 0 2
42948: PUSH
42949: FOR_TO
42950: IFFALSE 42986
// if mreg [ i ] [ 1 ] = side then
42952: LD_VAR 0 2
42956: PUSH
42957: LD_VAR 0 4
42961: ARRAY
42962: PUSH
42963: LD_INT 1
42965: ARRAY
42966: PUSH
42967: LD_VAR 0 1
42971: EQUAL
42972: IFFALSE 42984
// begin m := true ;
42974: LD_ADDR_VAR 0 5
42978: PUSH
42979: LD_INT 1
42981: ST_TO_ADDR
// break ;
42982: GO 42986
// end ;
42984: GO 42949
42986: POP
42987: POP
// result := m ;
42988: LD_ADDR_VAR 0 3
42992: PUSH
42993: LD_VAR 0 5
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MREG_ForSideCount ( side , mreg ) ; var i , m ; begin
43003: LD_INT 0
43005: PPUSH
43006: PPUSH
43007: PPUSH
// m := 0 ;
43008: LD_ADDR_VAR 0 5
43012: PUSH
43013: LD_INT 0
43015: ST_TO_ADDR
// for i = 1 to mreg do
43016: LD_ADDR_VAR 0 4
43020: PUSH
43021: DOUBLE
43022: LD_INT 1
43024: DEC
43025: ST_TO_ADDR
43026: LD_VAR 0 2
43030: PUSH
43031: FOR_TO
43032: IFFALSE 43072
// if mreg [ i ] [ 1 ] = side then
43034: LD_VAR 0 2
43038: PUSH
43039: LD_VAR 0 4
43043: ARRAY
43044: PUSH
43045: LD_INT 1
43047: ARRAY
43048: PUSH
43049: LD_VAR 0 1
43053: EQUAL
43054: IFFALSE 43070
// begin m := m + 1 ;
43056: LD_ADDR_VAR 0 5
43060: PUSH
43061: LD_VAR 0 5
43065: PUSH
43066: LD_INT 1
43068: PLUS
43069: ST_TO_ADDR
// end ;
43070: GO 43031
43072: POP
43073: POP
// result := m ;
43074: LD_ADDR_VAR 0 3
43078: PUSH
43079: LD_VAR 0 5
43083: ST_TO_ADDR
// end ;
43084: LD_VAR 0 3
43088: RET
// export function MREG_CheckChangeClass ( side , class ) ; var i ; begin
43089: LD_INT 0
43091: PPUSH
43092: PPUSH
// result := 0 ;
43093: LD_ADDR_VAR 0 3
43097: PUSH
43098: LD_INT 0
43100: ST_TO_ADDR
// for i = 1 to MREG_ToChangeClass do
43101: LD_ADDR_VAR 0 4
43105: PUSH
43106: DOUBLE
43107: LD_INT 1
43109: DEC
43110: ST_TO_ADDR
43111: LD_EXP 55
43115: PUSH
43116: FOR_TO
43117: IFFALSE 43179
// if MREG_ToChangeClass [ i ] [ 1 ] = side and MREG_ToChangeClass [ i ] [ 2 ] = class then
43119: LD_EXP 55
43123: PUSH
43124: LD_VAR 0 4
43128: ARRAY
43129: PUSH
43130: LD_INT 1
43132: ARRAY
43133: PUSH
43134: LD_VAR 0 1
43138: EQUAL
43139: PUSH
43140: LD_EXP 55
43144: PUSH
43145: LD_VAR 0 4
43149: ARRAY
43150: PUSH
43151: LD_INT 2
43153: ARRAY
43154: PUSH
43155: LD_VAR 0 2
43159: EQUAL
43160: AND
43161: IFFALSE 43177
// begin result := result + 1 ;
43163: LD_ADDR_VAR 0 3
43167: PUSH
43168: LD_VAR 0 3
43172: PUSH
43173: LD_INT 1
43175: PLUS
43176: ST_TO_ADDR
// end ;
43177: GO 43116
43179: POP
43180: POP
// end ; end_of_file
43181: LD_VAR 0 3
43185: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
43186: LD_INT 0
43188: PPUSH
// ar_crane := 88 ;
43189: LD_ADDR_EXP 81
43193: PUSH
43194: LD_INT 88
43196: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
43197: LD_ADDR_EXP 76
43201: PUSH
43202: LD_INT 89
43204: ST_TO_ADDR
// us_hack := 99 ;
43205: LD_ADDR_EXP 77
43209: PUSH
43210: LD_INT 99
43212: ST_TO_ADDR
// us_artillery := 97 ;
43213: LD_ADDR_EXP 78
43217: PUSH
43218: LD_INT 97
43220: ST_TO_ADDR
// ar_bio_bomb := 91 ;
43221: LD_ADDR_EXP 79
43225: PUSH
43226: LD_INT 91
43228: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
43229: LD_ADDR_EXP 80
43233: PUSH
43234: LD_INT 92
43236: ST_TO_ADDR
// ru_radar := 98 ;
43237: LD_ADDR_EXP 75
43241: PUSH
43242: LD_INT 98
43244: ST_TO_ADDR
// tech_Artillery := 80 ;
43245: LD_ADDR_EXP 82
43249: PUSH
43250: LD_INT 80
43252: ST_TO_ADDR
// tech_RadMat := 81 ;
43253: LD_ADDR_EXP 83
43257: PUSH
43258: LD_INT 81
43260: ST_TO_ADDR
// tech_BasicTools := 82 ;
43261: LD_ADDR_EXP 84
43265: PUSH
43266: LD_INT 82
43268: ST_TO_ADDR
// tech_Cargo := 83 ;
43269: LD_ADDR_EXP 85
43273: PUSH
43274: LD_INT 83
43276: ST_TO_ADDR
// tech_Track := 84 ;
43277: LD_ADDR_EXP 86
43281: PUSH
43282: LD_INT 84
43284: ST_TO_ADDR
// tech_Crane := 85 ;
43285: LD_ADDR_EXP 87
43289: PUSH
43290: LD_INT 85
43292: ST_TO_ADDR
// tech_Bulldozer := 86 ;
43293: LD_ADDR_EXP 88
43297: PUSH
43298: LD_INT 86
43300: ST_TO_ADDR
// tech_Hovercraft := 87 ;
43301: LD_ADDR_EXP 89
43305: PUSH
43306: LD_INT 87
43308: ST_TO_ADDR
// end ;
43309: LD_VAR 0 1
43313: RET
// every 1 do
43314: GO 43316
43316: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
43317: CALL 43186 0 0
43321: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
43322: LD_VAR 0 2
43326: PUSH
43327: LD_INT 100
43329: EQUAL
43330: IFFALSE 44279
// begin if not StreamModeActive then
43332: LD_EXP 90
43336: NOT
43337: IFFALSE 43347
// StreamModeActive := true ;
43339: LD_ADDR_EXP 90
43343: PUSH
43344: LD_INT 1
43346: ST_TO_ADDR
// if p3 = 0 then
43347: LD_VAR 0 3
43351: PUSH
43352: LD_INT 0
43354: EQUAL
43355: IFFALSE 43361
// InitStreamMode ;
43357: CALL 44437 0 0
// if p3 = 1 then
43361: LD_VAR 0 3
43365: PUSH
43366: LD_INT 1
43368: EQUAL
43369: IFFALSE 43379
// sRocket := true ;
43371: LD_ADDR_EXP 95
43375: PUSH
43376: LD_INT 1
43378: ST_TO_ADDR
// if p3 = 2 then
43379: LD_VAR 0 3
43383: PUSH
43384: LD_INT 2
43386: EQUAL
43387: IFFALSE 43397
// sSpeed := true ;
43389: LD_ADDR_EXP 94
43393: PUSH
43394: LD_INT 1
43396: ST_TO_ADDR
// if p3 = 3 then
43397: LD_VAR 0 3
43401: PUSH
43402: LD_INT 3
43404: EQUAL
43405: IFFALSE 43415
// sEngine := true ;
43407: LD_ADDR_EXP 96
43411: PUSH
43412: LD_INT 1
43414: ST_TO_ADDR
// if p3 = 4 then
43415: LD_VAR 0 3
43419: PUSH
43420: LD_INT 4
43422: EQUAL
43423: IFFALSE 43433
// sSpec := true ;
43425: LD_ADDR_EXP 93
43429: PUSH
43430: LD_INT 1
43432: ST_TO_ADDR
// if p3 = 5 then
43433: LD_VAR 0 3
43437: PUSH
43438: LD_INT 5
43440: EQUAL
43441: IFFALSE 43451
// sLevel := true ;
43443: LD_ADDR_EXP 97
43447: PUSH
43448: LD_INT 1
43450: ST_TO_ADDR
// if p3 = 6 then
43451: LD_VAR 0 3
43455: PUSH
43456: LD_INT 6
43458: EQUAL
43459: IFFALSE 43469
// sArmoury := true ;
43461: LD_ADDR_EXP 98
43465: PUSH
43466: LD_INT 1
43468: ST_TO_ADDR
// if p3 = 7 then
43469: LD_VAR 0 3
43473: PUSH
43474: LD_INT 7
43476: EQUAL
43477: IFFALSE 43487
// sRadar := true ;
43479: LD_ADDR_EXP 99
43483: PUSH
43484: LD_INT 1
43486: ST_TO_ADDR
// if p3 = 8 then
43487: LD_VAR 0 3
43491: PUSH
43492: LD_INT 8
43494: EQUAL
43495: IFFALSE 43505
// sBunker := true ;
43497: LD_ADDR_EXP 100
43501: PUSH
43502: LD_INT 1
43504: ST_TO_ADDR
// if p3 = 9 then
43505: LD_VAR 0 3
43509: PUSH
43510: LD_INT 9
43512: EQUAL
43513: IFFALSE 43523
// sHack := true ;
43515: LD_ADDR_EXP 101
43519: PUSH
43520: LD_INT 1
43522: ST_TO_ADDR
// if p3 = 10 then
43523: LD_VAR 0 3
43527: PUSH
43528: LD_INT 10
43530: EQUAL
43531: IFFALSE 43541
// sFire := true ;
43533: LD_ADDR_EXP 102
43537: PUSH
43538: LD_INT 1
43540: ST_TO_ADDR
// if p3 = 11 then
43541: LD_VAR 0 3
43545: PUSH
43546: LD_INT 11
43548: EQUAL
43549: IFFALSE 43559
// sRefresh := true ;
43551: LD_ADDR_EXP 103
43555: PUSH
43556: LD_INT 1
43558: ST_TO_ADDR
// if p3 = 12 then
43559: LD_VAR 0 3
43563: PUSH
43564: LD_INT 12
43566: EQUAL
43567: IFFALSE 43577
// sExp := true ;
43569: LD_ADDR_EXP 104
43573: PUSH
43574: LD_INT 1
43576: ST_TO_ADDR
// if p3 = 13 then
43577: LD_VAR 0 3
43581: PUSH
43582: LD_INT 13
43584: EQUAL
43585: IFFALSE 43595
// sDepot := true ;
43587: LD_ADDR_EXP 105
43591: PUSH
43592: LD_INT 1
43594: ST_TO_ADDR
// if p3 = 14 then
43595: LD_VAR 0 3
43599: PUSH
43600: LD_INT 14
43602: EQUAL
43603: IFFALSE 43613
// sFlag := true ;
43605: LD_ADDR_EXP 106
43609: PUSH
43610: LD_INT 1
43612: ST_TO_ADDR
// if p3 = 15 then
43613: LD_VAR 0 3
43617: PUSH
43618: LD_INT 15
43620: EQUAL
43621: IFFALSE 43631
// sKamikadze := true ;
43623: LD_ADDR_EXP 114
43627: PUSH
43628: LD_INT 1
43630: ST_TO_ADDR
// if p3 = 16 then
43631: LD_VAR 0 3
43635: PUSH
43636: LD_INT 16
43638: EQUAL
43639: IFFALSE 43649
// sTroll := true ;
43641: LD_ADDR_EXP 115
43645: PUSH
43646: LD_INT 1
43648: ST_TO_ADDR
// if p3 = 17 then
43649: LD_VAR 0 3
43653: PUSH
43654: LD_INT 17
43656: EQUAL
43657: IFFALSE 43667
// sSlow := true ;
43659: LD_ADDR_EXP 116
43663: PUSH
43664: LD_INT 1
43666: ST_TO_ADDR
// if p3 = 18 then
43667: LD_VAR 0 3
43671: PUSH
43672: LD_INT 18
43674: EQUAL
43675: IFFALSE 43685
// sLack := true ;
43677: LD_ADDR_EXP 117
43681: PUSH
43682: LD_INT 1
43684: ST_TO_ADDR
// if p3 = 19 then
43685: LD_VAR 0 3
43689: PUSH
43690: LD_INT 19
43692: EQUAL
43693: IFFALSE 43703
// sTank := true ;
43695: LD_ADDR_EXP 119
43699: PUSH
43700: LD_INT 1
43702: ST_TO_ADDR
// if p3 = 20 then
43703: LD_VAR 0 3
43707: PUSH
43708: LD_INT 20
43710: EQUAL
43711: IFFALSE 43721
// sRemote := true ;
43713: LD_ADDR_EXP 120
43717: PUSH
43718: LD_INT 1
43720: ST_TO_ADDR
// if p3 = 21 then
43721: LD_VAR 0 3
43725: PUSH
43726: LD_INT 21
43728: EQUAL
43729: IFFALSE 43739
// sPowell := true ;
43731: LD_ADDR_EXP 121
43735: PUSH
43736: LD_INT 1
43738: ST_TO_ADDR
// if p3 = 22 then
43739: LD_VAR 0 3
43743: PUSH
43744: LD_INT 22
43746: EQUAL
43747: IFFALSE 43757
// sTeleport := true ;
43749: LD_ADDR_EXP 124
43753: PUSH
43754: LD_INT 1
43756: ST_TO_ADDR
// if p3 = 23 then
43757: LD_VAR 0 3
43761: PUSH
43762: LD_INT 23
43764: EQUAL
43765: IFFALSE 43775
// sOilTower := true ;
43767: LD_ADDR_EXP 126
43771: PUSH
43772: LD_INT 1
43774: ST_TO_ADDR
// if p3 = 24 then
43775: LD_VAR 0 3
43779: PUSH
43780: LD_INT 24
43782: EQUAL
43783: IFFALSE 43793
// sShovel := true ;
43785: LD_ADDR_EXP 127
43789: PUSH
43790: LD_INT 1
43792: ST_TO_ADDR
// if p3 = 25 then
43793: LD_VAR 0 3
43797: PUSH
43798: LD_INT 25
43800: EQUAL
43801: IFFALSE 43811
// sSheik := true ;
43803: LD_ADDR_EXP 128
43807: PUSH
43808: LD_INT 1
43810: ST_TO_ADDR
// if p3 = 26 then
43811: LD_VAR 0 3
43815: PUSH
43816: LD_INT 26
43818: EQUAL
43819: IFFALSE 43829
// sEarthquake := true ;
43821: LD_ADDR_EXP 130
43825: PUSH
43826: LD_INT 1
43828: ST_TO_ADDR
// if p3 = 27 then
43829: LD_VAR 0 3
43833: PUSH
43834: LD_INT 27
43836: EQUAL
43837: IFFALSE 43847
// sAI := true ;
43839: LD_ADDR_EXP 131
43843: PUSH
43844: LD_INT 1
43846: ST_TO_ADDR
// if p3 = 28 then
43847: LD_VAR 0 3
43851: PUSH
43852: LD_INT 28
43854: EQUAL
43855: IFFALSE 43865
// sCargo := true ;
43857: LD_ADDR_EXP 134
43861: PUSH
43862: LD_INT 1
43864: ST_TO_ADDR
// if p3 = 29 then
43865: LD_VAR 0 3
43869: PUSH
43870: LD_INT 29
43872: EQUAL
43873: IFFALSE 43883
// sDLaser := true ;
43875: LD_ADDR_EXP 135
43879: PUSH
43880: LD_INT 1
43882: ST_TO_ADDR
// if p3 = 30 then
43883: LD_VAR 0 3
43887: PUSH
43888: LD_INT 30
43890: EQUAL
43891: IFFALSE 43901
// sExchange := true ;
43893: LD_ADDR_EXP 136
43897: PUSH
43898: LD_INT 1
43900: ST_TO_ADDR
// if p3 = 31 then
43901: LD_VAR 0 3
43905: PUSH
43906: LD_INT 31
43908: EQUAL
43909: IFFALSE 43919
// sFac := true ;
43911: LD_ADDR_EXP 137
43915: PUSH
43916: LD_INT 1
43918: ST_TO_ADDR
// if p3 = 32 then
43919: LD_VAR 0 3
43923: PUSH
43924: LD_INT 32
43926: EQUAL
43927: IFFALSE 43937
// sPower := true ;
43929: LD_ADDR_EXP 138
43933: PUSH
43934: LD_INT 1
43936: ST_TO_ADDR
// if p3 = 33 then
43937: LD_VAR 0 3
43941: PUSH
43942: LD_INT 33
43944: EQUAL
43945: IFFALSE 43955
// sRandom := true ;
43947: LD_ADDR_EXP 139
43951: PUSH
43952: LD_INT 1
43954: ST_TO_ADDR
// if p3 = 34 then
43955: LD_VAR 0 3
43959: PUSH
43960: LD_INT 34
43962: EQUAL
43963: IFFALSE 43973
// sShield := true ;
43965: LD_ADDR_EXP 140
43969: PUSH
43970: LD_INT 1
43972: ST_TO_ADDR
// if p3 = 35 then
43973: LD_VAR 0 3
43977: PUSH
43978: LD_INT 35
43980: EQUAL
43981: IFFALSE 43991
// sTime := true ;
43983: LD_ADDR_EXP 141
43987: PUSH
43988: LD_INT 1
43990: ST_TO_ADDR
// if p3 = 36 then
43991: LD_VAR 0 3
43995: PUSH
43996: LD_INT 36
43998: EQUAL
43999: IFFALSE 44009
// sTools := true ;
44001: LD_ADDR_EXP 142
44005: PUSH
44006: LD_INT 1
44008: ST_TO_ADDR
// if p3 = 101 then
44009: LD_VAR 0 3
44013: PUSH
44014: LD_INT 101
44016: EQUAL
44017: IFFALSE 44027
// sSold := true ;
44019: LD_ADDR_EXP 107
44023: PUSH
44024: LD_INT 1
44026: ST_TO_ADDR
// if p3 = 102 then
44027: LD_VAR 0 3
44031: PUSH
44032: LD_INT 102
44034: EQUAL
44035: IFFALSE 44045
// sDiff := true ;
44037: LD_ADDR_EXP 108
44041: PUSH
44042: LD_INT 1
44044: ST_TO_ADDR
// if p3 = 103 then
44045: LD_VAR 0 3
44049: PUSH
44050: LD_INT 103
44052: EQUAL
44053: IFFALSE 44063
// sFog := true ;
44055: LD_ADDR_EXP 111
44059: PUSH
44060: LD_INT 1
44062: ST_TO_ADDR
// if p3 = 104 then
44063: LD_VAR 0 3
44067: PUSH
44068: LD_INT 104
44070: EQUAL
44071: IFFALSE 44081
// sReset := true ;
44073: LD_ADDR_EXP 112
44077: PUSH
44078: LD_INT 1
44080: ST_TO_ADDR
// if p3 = 105 then
44081: LD_VAR 0 3
44085: PUSH
44086: LD_INT 105
44088: EQUAL
44089: IFFALSE 44099
// sSun := true ;
44091: LD_ADDR_EXP 113
44095: PUSH
44096: LD_INT 1
44098: ST_TO_ADDR
// if p3 = 106 then
44099: LD_VAR 0 3
44103: PUSH
44104: LD_INT 106
44106: EQUAL
44107: IFFALSE 44117
// sTiger := true ;
44109: LD_ADDR_EXP 109
44113: PUSH
44114: LD_INT 1
44116: ST_TO_ADDR
// if p3 = 107 then
44117: LD_VAR 0 3
44121: PUSH
44122: LD_INT 107
44124: EQUAL
44125: IFFALSE 44135
// sBomb := true ;
44127: LD_ADDR_EXP 110
44131: PUSH
44132: LD_INT 1
44134: ST_TO_ADDR
// if p3 = 108 then
44135: LD_VAR 0 3
44139: PUSH
44140: LD_INT 108
44142: EQUAL
44143: IFFALSE 44153
// sWound := true ;
44145: LD_ADDR_EXP 118
44149: PUSH
44150: LD_INT 1
44152: ST_TO_ADDR
// if p3 = 109 then
44153: LD_VAR 0 3
44157: PUSH
44158: LD_INT 109
44160: EQUAL
44161: IFFALSE 44171
// sBetray := true ;
44163: LD_ADDR_EXP 122
44167: PUSH
44168: LD_INT 1
44170: ST_TO_ADDR
// if p3 = 110 then
44171: LD_VAR 0 3
44175: PUSH
44176: LD_INT 110
44178: EQUAL
44179: IFFALSE 44189
// sContamin := true ;
44181: LD_ADDR_EXP 123
44185: PUSH
44186: LD_INT 1
44188: ST_TO_ADDR
// if p3 = 111 then
44189: LD_VAR 0 3
44193: PUSH
44194: LD_INT 111
44196: EQUAL
44197: IFFALSE 44207
// sOil := true ;
44199: LD_ADDR_EXP 125
44203: PUSH
44204: LD_INT 1
44206: ST_TO_ADDR
// if p3 = 112 then
44207: LD_VAR 0 3
44211: PUSH
44212: LD_INT 112
44214: EQUAL
44215: IFFALSE 44225
// sStu := true ;
44217: LD_ADDR_EXP 129
44221: PUSH
44222: LD_INT 1
44224: ST_TO_ADDR
// if p3 = 113 then
44225: LD_VAR 0 3
44229: PUSH
44230: LD_INT 113
44232: EQUAL
44233: IFFALSE 44243
// sBazooka := true ;
44235: LD_ADDR_EXP 132
44239: PUSH
44240: LD_INT 1
44242: ST_TO_ADDR
// if p3 = 114 then
44243: LD_VAR 0 3
44247: PUSH
44248: LD_INT 114
44250: EQUAL
44251: IFFALSE 44261
// sMortar := true ;
44253: LD_ADDR_EXP 133
44257: PUSH
44258: LD_INT 1
44260: ST_TO_ADDR
// if p3 = 115 then
44261: LD_VAR 0 3
44265: PUSH
44266: LD_INT 115
44268: EQUAL
44269: IFFALSE 44279
// sRanger := true ;
44271: LD_ADDR_EXP 143
44275: PUSH
44276: LD_INT 1
44278: ST_TO_ADDR
// end ; if p2 = 101 then
44279: LD_VAR 0 2
44283: PUSH
44284: LD_INT 101
44286: EQUAL
44287: IFFALSE 44415
// begin case p3 of 1 :
44289: LD_VAR 0 3
44293: PUSH
44294: LD_INT 1
44296: DOUBLE
44297: EQUAL
44298: IFTRUE 44302
44300: GO 44309
44302: POP
// hHackUnlimitedResources ; 2 :
44303: CALL 55450 0 0
44307: GO 44415
44309: LD_INT 2
44311: DOUBLE
44312: EQUAL
44313: IFTRUE 44317
44315: GO 44324
44317: POP
// hHackSetLevel10 ; 3 :
44318: CALL 55583 0 0
44322: GO 44415
44324: LD_INT 3
44326: DOUBLE
44327: EQUAL
44328: IFTRUE 44332
44330: GO 44339
44332: POP
// hHackSetLevel10YourUnits ; 4 :
44333: CALL 55668 0 0
44337: GO 44415
44339: LD_INT 4
44341: DOUBLE
44342: EQUAL
44343: IFTRUE 44347
44345: GO 44354
44347: POP
// hHackInvincible ; 5 :
44348: CALL 56116 0 0
44352: GO 44415
44354: LD_INT 5
44356: DOUBLE
44357: EQUAL
44358: IFTRUE 44362
44360: GO 44369
44362: POP
// hHackInvisible ; 6 :
44363: CALL 56227 0 0
44367: GO 44415
44369: LD_INT 6
44371: DOUBLE
44372: EQUAL
44373: IFTRUE 44377
44375: GO 44384
44377: POP
// hHackChangeYourSide ; 7 :
44378: CALL 56284 0 0
44382: GO 44415
44384: LD_INT 7
44386: DOUBLE
44387: EQUAL
44388: IFTRUE 44392
44390: GO 44399
44392: POP
// hHackChangeUnitSide ; 8 :
44393: CALL 56326 0 0
44397: GO 44415
44399: LD_INT 8
44401: DOUBLE
44402: EQUAL
44403: IFTRUE 44407
44405: GO 44414
44407: POP
// hHackFog ; end ;
44408: CALL 56427 0 0
44412: GO 44415
44414: POP
// end ; end ;
44415: PPOPN 6
44417: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
44418: GO 44420
44420: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
44421: LD_STRING initStreamRollete();
44423: PPUSH
44424: CALL_OW 559
// InitStreamMode ;
44428: CALL 44437 0 0
// DefineStreamItems ( ) ;
44432: CALL 44877 0 0
// end ;
44436: END
// function InitStreamMode ; begin
44437: LD_INT 0
44439: PPUSH
// streamModeActive := false ;
44440: LD_ADDR_EXP 90
44444: PUSH
44445: LD_INT 0
44447: ST_TO_ADDR
// normalCounter := 36 ;
44448: LD_ADDR_EXP 91
44452: PUSH
44453: LD_INT 36
44455: ST_TO_ADDR
// hardcoreCounter := 16 ;
44456: LD_ADDR_EXP 92
44460: PUSH
44461: LD_INT 16
44463: ST_TO_ADDR
// sRocket := false ;
44464: LD_ADDR_EXP 95
44468: PUSH
44469: LD_INT 0
44471: ST_TO_ADDR
// sSpeed := false ;
44472: LD_ADDR_EXP 94
44476: PUSH
44477: LD_INT 0
44479: ST_TO_ADDR
// sEngine := false ;
44480: LD_ADDR_EXP 96
44484: PUSH
44485: LD_INT 0
44487: ST_TO_ADDR
// sSpec := false ;
44488: LD_ADDR_EXP 93
44492: PUSH
44493: LD_INT 0
44495: ST_TO_ADDR
// sLevel := false ;
44496: LD_ADDR_EXP 97
44500: PUSH
44501: LD_INT 0
44503: ST_TO_ADDR
// sArmoury := false ;
44504: LD_ADDR_EXP 98
44508: PUSH
44509: LD_INT 0
44511: ST_TO_ADDR
// sRadar := false ;
44512: LD_ADDR_EXP 99
44516: PUSH
44517: LD_INT 0
44519: ST_TO_ADDR
// sBunker := false ;
44520: LD_ADDR_EXP 100
44524: PUSH
44525: LD_INT 0
44527: ST_TO_ADDR
// sHack := false ;
44528: LD_ADDR_EXP 101
44532: PUSH
44533: LD_INT 0
44535: ST_TO_ADDR
// sFire := false ;
44536: LD_ADDR_EXP 102
44540: PUSH
44541: LD_INT 0
44543: ST_TO_ADDR
// sRefresh := false ;
44544: LD_ADDR_EXP 103
44548: PUSH
44549: LD_INT 0
44551: ST_TO_ADDR
// sExp := false ;
44552: LD_ADDR_EXP 104
44556: PUSH
44557: LD_INT 0
44559: ST_TO_ADDR
// sDepot := false ;
44560: LD_ADDR_EXP 105
44564: PUSH
44565: LD_INT 0
44567: ST_TO_ADDR
// sFlag := false ;
44568: LD_ADDR_EXP 106
44572: PUSH
44573: LD_INT 0
44575: ST_TO_ADDR
// sKamikadze := false ;
44576: LD_ADDR_EXP 114
44580: PUSH
44581: LD_INT 0
44583: ST_TO_ADDR
// sTroll := false ;
44584: LD_ADDR_EXP 115
44588: PUSH
44589: LD_INT 0
44591: ST_TO_ADDR
// sSlow := false ;
44592: LD_ADDR_EXP 116
44596: PUSH
44597: LD_INT 0
44599: ST_TO_ADDR
// sLack := false ;
44600: LD_ADDR_EXP 117
44604: PUSH
44605: LD_INT 0
44607: ST_TO_ADDR
// sTank := false ;
44608: LD_ADDR_EXP 119
44612: PUSH
44613: LD_INT 0
44615: ST_TO_ADDR
// sRemote := false ;
44616: LD_ADDR_EXP 120
44620: PUSH
44621: LD_INT 0
44623: ST_TO_ADDR
// sPowell := false ;
44624: LD_ADDR_EXP 121
44628: PUSH
44629: LD_INT 0
44631: ST_TO_ADDR
// sTeleport := false ;
44632: LD_ADDR_EXP 124
44636: PUSH
44637: LD_INT 0
44639: ST_TO_ADDR
// sOilTower := false ;
44640: LD_ADDR_EXP 126
44644: PUSH
44645: LD_INT 0
44647: ST_TO_ADDR
// sShovel := false ;
44648: LD_ADDR_EXP 127
44652: PUSH
44653: LD_INT 0
44655: ST_TO_ADDR
// sSheik := false ;
44656: LD_ADDR_EXP 128
44660: PUSH
44661: LD_INT 0
44663: ST_TO_ADDR
// sEarthquake := false ;
44664: LD_ADDR_EXP 130
44668: PUSH
44669: LD_INT 0
44671: ST_TO_ADDR
// sAI := false ;
44672: LD_ADDR_EXP 131
44676: PUSH
44677: LD_INT 0
44679: ST_TO_ADDR
// sCargo := false ;
44680: LD_ADDR_EXP 134
44684: PUSH
44685: LD_INT 0
44687: ST_TO_ADDR
// sDLaser := false ;
44688: LD_ADDR_EXP 135
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// sExchange := false ;
44696: LD_ADDR_EXP 136
44700: PUSH
44701: LD_INT 0
44703: ST_TO_ADDR
// sFac := false ;
44704: LD_ADDR_EXP 137
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// sPower := false ;
44712: LD_ADDR_EXP 138
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// sRandom := false ;
44720: LD_ADDR_EXP 139
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// sShield := false ;
44728: LD_ADDR_EXP 140
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// sTime := false ;
44736: LD_ADDR_EXP 141
44740: PUSH
44741: LD_INT 0
44743: ST_TO_ADDR
// sTools := false ;
44744: LD_ADDR_EXP 142
44748: PUSH
44749: LD_INT 0
44751: ST_TO_ADDR
// sSold := false ;
44752: LD_ADDR_EXP 107
44756: PUSH
44757: LD_INT 0
44759: ST_TO_ADDR
// sDiff := false ;
44760: LD_ADDR_EXP 108
44764: PUSH
44765: LD_INT 0
44767: ST_TO_ADDR
// sFog := false ;
44768: LD_ADDR_EXP 111
44772: PUSH
44773: LD_INT 0
44775: ST_TO_ADDR
// sReset := false ;
44776: LD_ADDR_EXP 112
44780: PUSH
44781: LD_INT 0
44783: ST_TO_ADDR
// sSun := false ;
44784: LD_ADDR_EXP 113
44788: PUSH
44789: LD_INT 0
44791: ST_TO_ADDR
// sTiger := false ;
44792: LD_ADDR_EXP 109
44796: PUSH
44797: LD_INT 0
44799: ST_TO_ADDR
// sBomb := false ;
44800: LD_ADDR_EXP 110
44804: PUSH
44805: LD_INT 0
44807: ST_TO_ADDR
// sWound := false ;
44808: LD_ADDR_EXP 118
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// sBetray := false ;
44816: LD_ADDR_EXP 122
44820: PUSH
44821: LD_INT 0
44823: ST_TO_ADDR
// sContamin := false ;
44824: LD_ADDR_EXP 123
44828: PUSH
44829: LD_INT 0
44831: ST_TO_ADDR
// sOil := false ;
44832: LD_ADDR_EXP 125
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// sStu := false ;
44840: LD_ADDR_EXP 129
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// sBazooka := false ;
44848: LD_ADDR_EXP 132
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// sMortar := false ;
44856: LD_ADDR_EXP 133
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// sRanger := false ;
44864: LD_ADDR_EXP 143
44868: PUSH
44869: LD_INT 0
44871: ST_TO_ADDR
// end ;
44872: LD_VAR 0 1
44876: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
44877: LD_INT 0
44879: PPUSH
44880: PPUSH
44881: PPUSH
44882: PPUSH
44883: PPUSH
// result := [ ] ;
44884: LD_ADDR_VAR 0 1
44888: PUSH
44889: EMPTY
44890: ST_TO_ADDR
// if campaign_id = 1 then
44891: LD_OWVAR 69
44895: PUSH
44896: LD_INT 1
44898: EQUAL
44899: IFFALSE 47837
// begin case mission_number of 1 :
44901: LD_OWVAR 70
44905: PUSH
44906: LD_INT 1
44908: DOUBLE
44909: EQUAL
44910: IFTRUE 44914
44912: GO 44978
44914: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
44915: LD_ADDR_VAR 0 1
44919: PUSH
44920: LD_INT 2
44922: PUSH
44923: LD_INT 4
44925: PUSH
44926: LD_INT 11
44928: PUSH
44929: LD_INT 12
44931: PUSH
44932: LD_INT 15
44934: PUSH
44935: LD_INT 16
44937: PUSH
44938: LD_INT 22
44940: PUSH
44941: LD_INT 23
44943: PUSH
44944: LD_INT 26
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 101
44960: PUSH
44961: LD_INT 102
44963: PUSH
44964: LD_INT 106
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: LIST
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: ST_TO_ADDR
44976: GO 47835
44978: LD_INT 2
44980: DOUBLE
44981: EQUAL
44982: IFTRUE 44986
44984: GO 45058
44986: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
44987: LD_ADDR_VAR 0 1
44991: PUSH
44992: LD_INT 2
44994: PUSH
44995: LD_INT 4
44997: PUSH
44998: LD_INT 11
45000: PUSH
45001: LD_INT 12
45003: PUSH
45004: LD_INT 15
45006: PUSH
45007: LD_INT 16
45009: PUSH
45010: LD_INT 22
45012: PUSH
45013: LD_INT 23
45015: PUSH
45016: LD_INT 26
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: LIST
45023: LIST
45024: LIST
45025: LIST
45026: LIST
45027: LIST
45028: LIST
45029: PUSH
45030: LD_INT 101
45032: PUSH
45033: LD_INT 102
45035: PUSH
45036: LD_INT 105
45038: PUSH
45039: LD_INT 106
45041: PUSH
45042: LD_INT 108
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: PUSH
45052: EMPTY
45053: LIST
45054: LIST
45055: ST_TO_ADDR
45056: GO 47835
45058: LD_INT 3
45060: DOUBLE
45061: EQUAL
45062: IFTRUE 45066
45064: GO 45142
45066: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
45067: LD_ADDR_VAR 0 1
45071: PUSH
45072: LD_INT 2
45074: PUSH
45075: LD_INT 4
45077: PUSH
45078: LD_INT 5
45080: PUSH
45081: LD_INT 11
45083: PUSH
45084: LD_INT 12
45086: PUSH
45087: LD_INT 15
45089: PUSH
45090: LD_INT 16
45092: PUSH
45093: LD_INT 22
45095: PUSH
45096: LD_INT 26
45098: PUSH
45099: LD_INT 36
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: LIST
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 101
45116: PUSH
45117: LD_INT 102
45119: PUSH
45120: LD_INT 105
45122: PUSH
45123: LD_INT 106
45125: PUSH
45126: LD_INT 108
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: ST_TO_ADDR
45140: GO 47835
45142: LD_INT 4
45144: DOUBLE
45145: EQUAL
45146: IFTRUE 45150
45148: GO 45234
45150: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
45151: LD_ADDR_VAR 0 1
45155: PUSH
45156: LD_INT 2
45158: PUSH
45159: LD_INT 4
45161: PUSH
45162: LD_INT 5
45164: PUSH
45165: LD_INT 8
45167: PUSH
45168: LD_INT 11
45170: PUSH
45171: LD_INT 12
45173: PUSH
45174: LD_INT 15
45176: PUSH
45177: LD_INT 16
45179: PUSH
45180: LD_INT 22
45182: PUSH
45183: LD_INT 23
45185: PUSH
45186: LD_INT 26
45188: PUSH
45189: LD_INT 36
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: LIST
45200: LIST
45201: LIST
45202: LIST
45203: LIST
45204: LIST
45205: PUSH
45206: LD_INT 101
45208: PUSH
45209: LD_INT 102
45211: PUSH
45212: LD_INT 105
45214: PUSH
45215: LD_INT 106
45217: PUSH
45218: LD_INT 108
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: LIST
45225: LIST
45226: LIST
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: ST_TO_ADDR
45232: GO 47835
45234: LD_INT 5
45236: DOUBLE
45237: EQUAL
45238: IFTRUE 45242
45240: GO 45342
45242: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
45243: LD_ADDR_VAR 0 1
45247: PUSH
45248: LD_INT 2
45250: PUSH
45251: LD_INT 4
45253: PUSH
45254: LD_INT 5
45256: PUSH
45257: LD_INT 6
45259: PUSH
45260: LD_INT 8
45262: PUSH
45263: LD_INT 11
45265: PUSH
45266: LD_INT 12
45268: PUSH
45269: LD_INT 15
45271: PUSH
45272: LD_INT 16
45274: PUSH
45275: LD_INT 22
45277: PUSH
45278: LD_INT 23
45280: PUSH
45281: LD_INT 25
45283: PUSH
45284: LD_INT 26
45286: PUSH
45287: LD_INT 36
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: PUSH
45306: LD_INT 101
45308: PUSH
45309: LD_INT 102
45311: PUSH
45312: LD_INT 105
45314: PUSH
45315: LD_INT 106
45317: PUSH
45318: LD_INT 108
45320: PUSH
45321: LD_INT 109
45323: PUSH
45324: LD_INT 112
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: ST_TO_ADDR
45340: GO 47835
45342: LD_INT 6
45344: DOUBLE
45345: EQUAL
45346: IFTRUE 45350
45348: GO 45470
45350: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
45351: LD_ADDR_VAR 0 1
45355: PUSH
45356: LD_INT 2
45358: PUSH
45359: LD_INT 4
45361: PUSH
45362: LD_INT 5
45364: PUSH
45365: LD_INT 6
45367: PUSH
45368: LD_INT 8
45370: PUSH
45371: LD_INT 11
45373: PUSH
45374: LD_INT 12
45376: PUSH
45377: LD_INT 15
45379: PUSH
45380: LD_INT 16
45382: PUSH
45383: LD_INT 20
45385: PUSH
45386: LD_INT 21
45388: PUSH
45389: LD_INT 22
45391: PUSH
45392: LD_INT 23
45394: PUSH
45395: LD_INT 25
45397: PUSH
45398: LD_INT 26
45400: PUSH
45401: LD_INT 30
45403: PUSH
45404: LD_INT 31
45406: PUSH
45407: LD_INT 32
45409: PUSH
45410: LD_INT 36
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: LIST
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 101
45436: PUSH
45437: LD_INT 102
45439: PUSH
45440: LD_INT 105
45442: PUSH
45443: LD_INT 106
45445: PUSH
45446: LD_INT 108
45448: PUSH
45449: LD_INT 109
45451: PUSH
45452: LD_INT 112
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: ST_TO_ADDR
45468: GO 47835
45470: LD_INT 7
45472: DOUBLE
45473: EQUAL
45474: IFTRUE 45478
45476: GO 45578
45478: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
45479: LD_ADDR_VAR 0 1
45483: PUSH
45484: LD_INT 2
45486: PUSH
45487: LD_INT 4
45489: PUSH
45490: LD_INT 5
45492: PUSH
45493: LD_INT 7
45495: PUSH
45496: LD_INT 11
45498: PUSH
45499: LD_INT 12
45501: PUSH
45502: LD_INT 15
45504: PUSH
45505: LD_INT 16
45507: PUSH
45508: LD_INT 20
45510: PUSH
45511: LD_INT 21
45513: PUSH
45514: LD_INT 22
45516: PUSH
45517: LD_INT 23
45519: PUSH
45520: LD_INT 25
45522: PUSH
45523: LD_INT 26
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 101
45544: PUSH
45545: LD_INT 102
45547: PUSH
45548: LD_INT 103
45550: PUSH
45551: LD_INT 105
45553: PUSH
45554: LD_INT 106
45556: PUSH
45557: LD_INT 108
45559: PUSH
45560: LD_INT 112
45562: PUSH
45563: EMPTY
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: ST_TO_ADDR
45576: GO 47835
45578: LD_INT 8
45580: DOUBLE
45581: EQUAL
45582: IFTRUE 45586
45584: GO 45714
45586: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
45587: LD_ADDR_VAR 0 1
45591: PUSH
45592: LD_INT 2
45594: PUSH
45595: LD_INT 4
45597: PUSH
45598: LD_INT 5
45600: PUSH
45601: LD_INT 6
45603: PUSH
45604: LD_INT 7
45606: PUSH
45607: LD_INT 8
45609: PUSH
45610: LD_INT 11
45612: PUSH
45613: LD_INT 12
45615: PUSH
45616: LD_INT 15
45618: PUSH
45619: LD_INT 16
45621: PUSH
45622: LD_INT 20
45624: PUSH
45625: LD_INT 21
45627: PUSH
45628: LD_INT 22
45630: PUSH
45631: LD_INT 23
45633: PUSH
45634: LD_INT 25
45636: PUSH
45637: LD_INT 26
45639: PUSH
45640: LD_INT 30
45642: PUSH
45643: LD_INT 31
45645: PUSH
45646: LD_INT 32
45648: PUSH
45649: LD_INT 36
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 101
45676: PUSH
45677: LD_INT 102
45679: PUSH
45680: LD_INT 103
45682: PUSH
45683: LD_INT 105
45685: PUSH
45686: LD_INT 106
45688: PUSH
45689: LD_INT 108
45691: PUSH
45692: LD_INT 109
45694: PUSH
45695: LD_INT 112
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: LIST
45702: LIST
45703: LIST
45704: LIST
45705: LIST
45706: LIST
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: ST_TO_ADDR
45712: GO 47835
45714: LD_INT 9
45716: DOUBLE
45717: EQUAL
45718: IFTRUE 45722
45720: GO 45858
45722: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
45723: LD_ADDR_VAR 0 1
45727: PUSH
45728: LD_INT 2
45730: PUSH
45731: LD_INT 4
45733: PUSH
45734: LD_INT 5
45736: PUSH
45737: LD_INT 6
45739: PUSH
45740: LD_INT 7
45742: PUSH
45743: LD_INT 8
45745: PUSH
45746: LD_INT 11
45748: PUSH
45749: LD_INT 12
45751: PUSH
45752: LD_INT 15
45754: PUSH
45755: LD_INT 16
45757: PUSH
45758: LD_INT 20
45760: PUSH
45761: LD_INT 21
45763: PUSH
45764: LD_INT 22
45766: PUSH
45767: LD_INT 23
45769: PUSH
45770: LD_INT 25
45772: PUSH
45773: LD_INT 26
45775: PUSH
45776: LD_INT 28
45778: PUSH
45779: LD_INT 30
45781: PUSH
45782: LD_INT 31
45784: PUSH
45785: LD_INT 32
45787: PUSH
45788: LD_INT 36
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: LIST
45810: LIST
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 101
45816: PUSH
45817: LD_INT 102
45819: PUSH
45820: LD_INT 103
45822: PUSH
45823: LD_INT 105
45825: PUSH
45826: LD_INT 106
45828: PUSH
45829: LD_INT 108
45831: PUSH
45832: LD_INT 109
45834: PUSH
45835: LD_INT 112
45837: PUSH
45838: LD_INT 114
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: ST_TO_ADDR
45856: GO 47835
45858: LD_INT 10
45860: DOUBLE
45861: EQUAL
45862: IFTRUE 45866
45864: GO 46050
45866: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
45867: LD_ADDR_VAR 0 1
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: LD_INT 4
45877: PUSH
45878: LD_INT 5
45880: PUSH
45881: LD_INT 6
45883: PUSH
45884: LD_INT 7
45886: PUSH
45887: LD_INT 8
45889: PUSH
45890: LD_INT 9
45892: PUSH
45893: LD_INT 10
45895: PUSH
45896: LD_INT 11
45898: PUSH
45899: LD_INT 12
45901: PUSH
45902: LD_INT 13
45904: PUSH
45905: LD_INT 14
45907: PUSH
45908: LD_INT 15
45910: PUSH
45911: LD_INT 16
45913: PUSH
45914: LD_INT 17
45916: PUSH
45917: LD_INT 18
45919: PUSH
45920: LD_INT 19
45922: PUSH
45923: LD_INT 20
45925: PUSH
45926: LD_INT 21
45928: PUSH
45929: LD_INT 22
45931: PUSH
45932: LD_INT 23
45934: PUSH
45935: LD_INT 24
45937: PUSH
45938: LD_INT 25
45940: PUSH
45941: LD_INT 26
45943: PUSH
45944: LD_INT 28
45946: PUSH
45947: LD_INT 30
45949: PUSH
45950: LD_INT 31
45952: PUSH
45953: LD_INT 32
45955: PUSH
45956: LD_INT 36
45958: PUSH
45959: EMPTY
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 101
45992: PUSH
45993: LD_INT 102
45995: PUSH
45996: LD_INT 103
45998: PUSH
45999: LD_INT 104
46001: PUSH
46002: LD_INT 105
46004: PUSH
46005: LD_INT 106
46007: PUSH
46008: LD_INT 107
46010: PUSH
46011: LD_INT 108
46013: PUSH
46014: LD_INT 109
46016: PUSH
46017: LD_INT 110
46019: PUSH
46020: LD_INT 111
46022: PUSH
46023: LD_INT 112
46025: PUSH
46026: LD_INT 114
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: ST_TO_ADDR
46048: GO 47835
46050: LD_INT 11
46052: DOUBLE
46053: EQUAL
46054: IFTRUE 46058
46056: GO 46250
46058: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
46059: LD_ADDR_VAR 0 1
46063: PUSH
46064: LD_INT 2
46066: PUSH
46067: LD_INT 3
46069: PUSH
46070: LD_INT 4
46072: PUSH
46073: LD_INT 5
46075: PUSH
46076: LD_INT 6
46078: PUSH
46079: LD_INT 7
46081: PUSH
46082: LD_INT 8
46084: PUSH
46085: LD_INT 9
46087: PUSH
46088: LD_INT 10
46090: PUSH
46091: LD_INT 11
46093: PUSH
46094: LD_INT 12
46096: PUSH
46097: LD_INT 13
46099: PUSH
46100: LD_INT 14
46102: PUSH
46103: LD_INT 15
46105: PUSH
46106: LD_INT 16
46108: PUSH
46109: LD_INT 17
46111: PUSH
46112: LD_INT 18
46114: PUSH
46115: LD_INT 19
46117: PUSH
46118: LD_INT 20
46120: PUSH
46121: LD_INT 21
46123: PUSH
46124: LD_INT 22
46126: PUSH
46127: LD_INT 23
46129: PUSH
46130: LD_INT 24
46132: PUSH
46133: LD_INT 25
46135: PUSH
46136: LD_INT 26
46138: PUSH
46139: LD_INT 28
46141: PUSH
46142: LD_INT 30
46144: PUSH
46145: LD_INT 31
46147: PUSH
46148: LD_INT 32
46150: PUSH
46151: LD_INT 34
46153: PUSH
46154: LD_INT 36
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 101
46192: PUSH
46193: LD_INT 102
46195: PUSH
46196: LD_INT 103
46198: PUSH
46199: LD_INT 104
46201: PUSH
46202: LD_INT 105
46204: PUSH
46205: LD_INT 106
46207: PUSH
46208: LD_INT 107
46210: PUSH
46211: LD_INT 108
46213: PUSH
46214: LD_INT 109
46216: PUSH
46217: LD_INT 110
46219: PUSH
46220: LD_INT 111
46222: PUSH
46223: LD_INT 112
46225: PUSH
46226: LD_INT 114
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: LIST
46242: LIST
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: ST_TO_ADDR
46248: GO 47835
46250: LD_INT 12
46252: DOUBLE
46253: EQUAL
46254: IFTRUE 46258
46256: GO 46466
46258: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
46259: LD_ADDR_VAR 0 1
46263: PUSH
46264: LD_INT 1
46266: PUSH
46267: LD_INT 2
46269: PUSH
46270: LD_INT 3
46272: PUSH
46273: LD_INT 4
46275: PUSH
46276: LD_INT 5
46278: PUSH
46279: LD_INT 6
46281: PUSH
46282: LD_INT 7
46284: PUSH
46285: LD_INT 8
46287: PUSH
46288: LD_INT 9
46290: PUSH
46291: LD_INT 10
46293: PUSH
46294: LD_INT 11
46296: PUSH
46297: LD_INT 12
46299: PUSH
46300: LD_INT 13
46302: PUSH
46303: LD_INT 14
46305: PUSH
46306: LD_INT 15
46308: PUSH
46309: LD_INT 16
46311: PUSH
46312: LD_INT 17
46314: PUSH
46315: LD_INT 18
46317: PUSH
46318: LD_INT 19
46320: PUSH
46321: LD_INT 20
46323: PUSH
46324: LD_INT 21
46326: PUSH
46327: LD_INT 22
46329: PUSH
46330: LD_INT 23
46332: PUSH
46333: LD_INT 24
46335: PUSH
46336: LD_INT 25
46338: PUSH
46339: LD_INT 26
46341: PUSH
46342: LD_INT 27
46344: PUSH
46345: LD_INT 28
46347: PUSH
46348: LD_INT 30
46350: PUSH
46351: LD_INT 31
46353: PUSH
46354: LD_INT 32
46356: PUSH
46357: LD_INT 33
46359: PUSH
46360: LD_INT 34
46362: PUSH
46363: LD_INT 36
46365: PUSH
46366: EMPTY
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: PUSH
46402: LD_INT 101
46404: PUSH
46405: LD_INT 102
46407: PUSH
46408: LD_INT 103
46410: PUSH
46411: LD_INT 104
46413: PUSH
46414: LD_INT 105
46416: PUSH
46417: LD_INT 106
46419: PUSH
46420: LD_INT 107
46422: PUSH
46423: LD_INT 108
46425: PUSH
46426: LD_INT 109
46428: PUSH
46429: LD_INT 110
46431: PUSH
46432: LD_INT 111
46434: PUSH
46435: LD_INT 112
46437: PUSH
46438: LD_INT 113
46440: PUSH
46441: LD_INT 114
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: ST_TO_ADDR
46464: GO 47835
46466: LD_INT 13
46468: DOUBLE
46469: EQUAL
46470: IFTRUE 46474
46472: GO 46670
46474: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
46475: LD_ADDR_VAR 0 1
46479: PUSH
46480: LD_INT 1
46482: PUSH
46483: LD_INT 2
46485: PUSH
46486: LD_INT 3
46488: PUSH
46489: LD_INT 4
46491: PUSH
46492: LD_INT 5
46494: PUSH
46495: LD_INT 8
46497: PUSH
46498: LD_INT 9
46500: PUSH
46501: LD_INT 10
46503: PUSH
46504: LD_INT 11
46506: PUSH
46507: LD_INT 12
46509: PUSH
46510: LD_INT 14
46512: PUSH
46513: LD_INT 15
46515: PUSH
46516: LD_INT 16
46518: PUSH
46519: LD_INT 17
46521: PUSH
46522: LD_INT 18
46524: PUSH
46525: LD_INT 19
46527: PUSH
46528: LD_INT 20
46530: PUSH
46531: LD_INT 21
46533: PUSH
46534: LD_INT 22
46536: PUSH
46537: LD_INT 23
46539: PUSH
46540: LD_INT 24
46542: PUSH
46543: LD_INT 25
46545: PUSH
46546: LD_INT 26
46548: PUSH
46549: LD_INT 27
46551: PUSH
46552: LD_INT 28
46554: PUSH
46555: LD_INT 30
46557: PUSH
46558: LD_INT 31
46560: PUSH
46561: LD_INT 32
46563: PUSH
46564: LD_INT 33
46566: PUSH
46567: LD_INT 34
46569: PUSH
46570: LD_INT 36
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: PUSH
46606: LD_INT 101
46608: PUSH
46609: LD_INT 102
46611: PUSH
46612: LD_INT 103
46614: PUSH
46615: LD_INT 104
46617: PUSH
46618: LD_INT 105
46620: PUSH
46621: LD_INT 106
46623: PUSH
46624: LD_INT 107
46626: PUSH
46627: LD_INT 108
46629: PUSH
46630: LD_INT 109
46632: PUSH
46633: LD_INT 110
46635: PUSH
46636: LD_INT 111
46638: PUSH
46639: LD_INT 112
46641: PUSH
46642: LD_INT 113
46644: PUSH
46645: LD_INT 114
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: ST_TO_ADDR
46668: GO 47835
46670: LD_INT 14
46672: DOUBLE
46673: EQUAL
46674: IFTRUE 46678
46676: GO 46890
46678: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
46679: LD_ADDR_VAR 0 1
46683: PUSH
46684: LD_INT 1
46686: PUSH
46687: LD_INT 2
46689: PUSH
46690: LD_INT 3
46692: PUSH
46693: LD_INT 4
46695: PUSH
46696: LD_INT 5
46698: PUSH
46699: LD_INT 6
46701: PUSH
46702: LD_INT 7
46704: PUSH
46705: LD_INT 8
46707: PUSH
46708: LD_INT 9
46710: PUSH
46711: LD_INT 10
46713: PUSH
46714: LD_INT 11
46716: PUSH
46717: LD_INT 12
46719: PUSH
46720: LD_INT 13
46722: PUSH
46723: LD_INT 14
46725: PUSH
46726: LD_INT 15
46728: PUSH
46729: LD_INT 16
46731: PUSH
46732: LD_INT 17
46734: PUSH
46735: LD_INT 18
46737: PUSH
46738: LD_INT 19
46740: PUSH
46741: LD_INT 20
46743: PUSH
46744: LD_INT 21
46746: PUSH
46747: LD_INT 22
46749: PUSH
46750: LD_INT 23
46752: PUSH
46753: LD_INT 24
46755: PUSH
46756: LD_INT 25
46758: PUSH
46759: LD_INT 26
46761: PUSH
46762: LD_INT 27
46764: PUSH
46765: LD_INT 28
46767: PUSH
46768: LD_INT 29
46770: PUSH
46771: LD_INT 30
46773: PUSH
46774: LD_INT 31
46776: PUSH
46777: LD_INT 32
46779: PUSH
46780: LD_INT 33
46782: PUSH
46783: LD_INT 34
46785: PUSH
46786: LD_INT 36
46788: PUSH
46789: EMPTY
46790: LIST
46791: LIST
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: LIST
46803: LIST
46804: LIST
46805: LIST
46806: LIST
46807: LIST
46808: LIST
46809: LIST
46810: LIST
46811: LIST
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: LIST
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: PUSH
46826: LD_INT 101
46828: PUSH
46829: LD_INT 102
46831: PUSH
46832: LD_INT 103
46834: PUSH
46835: LD_INT 104
46837: PUSH
46838: LD_INT 105
46840: PUSH
46841: LD_INT 106
46843: PUSH
46844: LD_INT 107
46846: PUSH
46847: LD_INT 108
46849: PUSH
46850: LD_INT 109
46852: PUSH
46853: LD_INT 110
46855: PUSH
46856: LD_INT 111
46858: PUSH
46859: LD_INT 112
46861: PUSH
46862: LD_INT 113
46864: PUSH
46865: LD_INT 114
46867: PUSH
46868: EMPTY
46869: LIST
46870: LIST
46871: LIST
46872: LIST
46873: LIST
46874: LIST
46875: LIST
46876: LIST
46877: LIST
46878: LIST
46879: LIST
46880: LIST
46881: LIST
46882: LIST
46883: PUSH
46884: EMPTY
46885: LIST
46886: LIST
46887: ST_TO_ADDR
46888: GO 47835
46890: LD_INT 15
46892: DOUBLE
46893: EQUAL
46894: IFTRUE 46898
46896: GO 47110
46898: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
46899: LD_ADDR_VAR 0 1
46903: PUSH
46904: LD_INT 1
46906: PUSH
46907: LD_INT 2
46909: PUSH
46910: LD_INT 3
46912: PUSH
46913: LD_INT 4
46915: PUSH
46916: LD_INT 5
46918: PUSH
46919: LD_INT 6
46921: PUSH
46922: LD_INT 7
46924: PUSH
46925: LD_INT 8
46927: PUSH
46928: LD_INT 9
46930: PUSH
46931: LD_INT 10
46933: PUSH
46934: LD_INT 11
46936: PUSH
46937: LD_INT 12
46939: PUSH
46940: LD_INT 13
46942: PUSH
46943: LD_INT 14
46945: PUSH
46946: LD_INT 15
46948: PUSH
46949: LD_INT 16
46951: PUSH
46952: LD_INT 17
46954: PUSH
46955: LD_INT 18
46957: PUSH
46958: LD_INT 19
46960: PUSH
46961: LD_INT 20
46963: PUSH
46964: LD_INT 21
46966: PUSH
46967: LD_INT 22
46969: PUSH
46970: LD_INT 23
46972: PUSH
46973: LD_INT 24
46975: PUSH
46976: LD_INT 25
46978: PUSH
46979: LD_INT 26
46981: PUSH
46982: LD_INT 27
46984: PUSH
46985: LD_INT 28
46987: PUSH
46988: LD_INT 29
46990: PUSH
46991: LD_INT 30
46993: PUSH
46994: LD_INT 31
46996: PUSH
46997: LD_INT 32
46999: PUSH
47000: LD_INT 33
47002: PUSH
47003: LD_INT 34
47005: PUSH
47006: LD_INT 36
47008: PUSH
47009: EMPTY
47010: LIST
47011: LIST
47012: LIST
47013: LIST
47014: LIST
47015: LIST
47016: LIST
47017: LIST
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: LIST
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: LIST
47043: LIST
47044: LIST
47045: PUSH
47046: LD_INT 101
47048: PUSH
47049: LD_INT 102
47051: PUSH
47052: LD_INT 103
47054: PUSH
47055: LD_INT 104
47057: PUSH
47058: LD_INT 105
47060: PUSH
47061: LD_INT 106
47063: PUSH
47064: LD_INT 107
47066: PUSH
47067: LD_INT 108
47069: PUSH
47070: LD_INT 109
47072: PUSH
47073: LD_INT 110
47075: PUSH
47076: LD_INT 111
47078: PUSH
47079: LD_INT 112
47081: PUSH
47082: LD_INT 113
47084: PUSH
47085: LD_INT 114
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: PUSH
47104: EMPTY
47105: LIST
47106: LIST
47107: ST_TO_ADDR
47108: GO 47835
47110: LD_INT 16
47112: DOUBLE
47113: EQUAL
47114: IFTRUE 47118
47116: GO 47242
47118: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
47119: LD_ADDR_VAR 0 1
47123: PUSH
47124: LD_INT 2
47126: PUSH
47127: LD_INT 4
47129: PUSH
47130: LD_INT 5
47132: PUSH
47133: LD_INT 7
47135: PUSH
47136: LD_INT 11
47138: PUSH
47139: LD_INT 12
47141: PUSH
47142: LD_INT 15
47144: PUSH
47145: LD_INT 16
47147: PUSH
47148: LD_INT 20
47150: PUSH
47151: LD_INT 21
47153: PUSH
47154: LD_INT 22
47156: PUSH
47157: LD_INT 23
47159: PUSH
47160: LD_INT 25
47162: PUSH
47163: LD_INT 26
47165: PUSH
47166: LD_INT 30
47168: PUSH
47169: LD_INT 31
47171: PUSH
47172: LD_INT 32
47174: PUSH
47175: LD_INT 33
47177: PUSH
47178: LD_INT 34
47180: PUSH
47181: EMPTY
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: PUSH
47202: LD_INT 101
47204: PUSH
47205: LD_INT 102
47207: PUSH
47208: LD_INT 103
47210: PUSH
47211: LD_INT 106
47213: PUSH
47214: LD_INT 108
47216: PUSH
47217: LD_INT 112
47219: PUSH
47220: LD_INT 113
47222: PUSH
47223: LD_INT 114
47225: PUSH
47226: EMPTY
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: PUSH
47236: EMPTY
47237: LIST
47238: LIST
47239: ST_TO_ADDR
47240: GO 47835
47242: LD_INT 17
47244: DOUBLE
47245: EQUAL
47246: IFTRUE 47250
47248: GO 47462
47250: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
47251: LD_ADDR_VAR 0 1
47255: PUSH
47256: LD_INT 1
47258: PUSH
47259: LD_INT 2
47261: PUSH
47262: LD_INT 3
47264: PUSH
47265: LD_INT 4
47267: PUSH
47268: LD_INT 5
47270: PUSH
47271: LD_INT 6
47273: PUSH
47274: LD_INT 7
47276: PUSH
47277: LD_INT 8
47279: PUSH
47280: LD_INT 9
47282: PUSH
47283: LD_INT 10
47285: PUSH
47286: LD_INT 11
47288: PUSH
47289: LD_INT 12
47291: PUSH
47292: LD_INT 13
47294: PUSH
47295: LD_INT 14
47297: PUSH
47298: LD_INT 15
47300: PUSH
47301: LD_INT 16
47303: PUSH
47304: LD_INT 17
47306: PUSH
47307: LD_INT 18
47309: PUSH
47310: LD_INT 19
47312: PUSH
47313: LD_INT 20
47315: PUSH
47316: LD_INT 21
47318: PUSH
47319: LD_INT 22
47321: PUSH
47322: LD_INT 23
47324: PUSH
47325: LD_INT 24
47327: PUSH
47328: LD_INT 25
47330: PUSH
47331: LD_INT 26
47333: PUSH
47334: LD_INT 27
47336: PUSH
47337: LD_INT 28
47339: PUSH
47340: LD_INT 29
47342: PUSH
47343: LD_INT 30
47345: PUSH
47346: LD_INT 31
47348: PUSH
47349: LD_INT 32
47351: PUSH
47352: LD_INT 33
47354: PUSH
47355: LD_INT 34
47357: PUSH
47358: LD_INT 36
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: LIST
47365: LIST
47366: LIST
47367: LIST
47368: LIST
47369: LIST
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: PUSH
47398: LD_INT 101
47400: PUSH
47401: LD_INT 102
47403: PUSH
47404: LD_INT 103
47406: PUSH
47407: LD_INT 104
47409: PUSH
47410: LD_INT 105
47412: PUSH
47413: LD_INT 106
47415: PUSH
47416: LD_INT 107
47418: PUSH
47419: LD_INT 108
47421: PUSH
47422: LD_INT 109
47424: PUSH
47425: LD_INT 110
47427: PUSH
47428: LD_INT 111
47430: PUSH
47431: LD_INT 112
47433: PUSH
47434: LD_INT 113
47436: PUSH
47437: LD_INT 114
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: ST_TO_ADDR
47460: GO 47835
47462: LD_INT 18
47464: DOUBLE
47465: EQUAL
47466: IFTRUE 47470
47468: GO 47606
47470: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
47471: LD_ADDR_VAR 0 1
47475: PUSH
47476: LD_INT 2
47478: PUSH
47479: LD_INT 4
47481: PUSH
47482: LD_INT 5
47484: PUSH
47485: LD_INT 7
47487: PUSH
47488: LD_INT 11
47490: PUSH
47491: LD_INT 12
47493: PUSH
47494: LD_INT 15
47496: PUSH
47497: LD_INT 16
47499: PUSH
47500: LD_INT 20
47502: PUSH
47503: LD_INT 21
47505: PUSH
47506: LD_INT 22
47508: PUSH
47509: LD_INT 23
47511: PUSH
47512: LD_INT 25
47514: PUSH
47515: LD_INT 26
47517: PUSH
47518: LD_INT 30
47520: PUSH
47521: LD_INT 31
47523: PUSH
47524: LD_INT 32
47526: PUSH
47527: LD_INT 33
47529: PUSH
47530: LD_INT 34
47532: PUSH
47533: LD_INT 35
47535: PUSH
47536: LD_INT 36
47538: PUSH
47539: EMPTY
47540: LIST
47541: LIST
47542: LIST
47543: LIST
47544: LIST
47545: LIST
47546: LIST
47547: LIST
47548: LIST
47549: LIST
47550: LIST
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: LIST
47561: PUSH
47562: LD_INT 101
47564: PUSH
47565: LD_INT 102
47567: PUSH
47568: LD_INT 103
47570: PUSH
47571: LD_INT 106
47573: PUSH
47574: LD_INT 108
47576: PUSH
47577: LD_INT 112
47579: PUSH
47580: LD_INT 113
47582: PUSH
47583: LD_INT 114
47585: PUSH
47586: LD_INT 115
47588: PUSH
47589: EMPTY
47590: LIST
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: LIST
47597: LIST
47598: LIST
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: ST_TO_ADDR
47604: GO 47835
47606: LD_INT 19
47608: DOUBLE
47609: EQUAL
47610: IFTRUE 47614
47612: GO 47834
47614: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
47615: LD_ADDR_VAR 0 1
47619: PUSH
47620: LD_INT 1
47622: PUSH
47623: LD_INT 2
47625: PUSH
47626: LD_INT 3
47628: PUSH
47629: LD_INT 4
47631: PUSH
47632: LD_INT 5
47634: PUSH
47635: LD_INT 6
47637: PUSH
47638: LD_INT 7
47640: PUSH
47641: LD_INT 8
47643: PUSH
47644: LD_INT 9
47646: PUSH
47647: LD_INT 10
47649: PUSH
47650: LD_INT 11
47652: PUSH
47653: LD_INT 12
47655: PUSH
47656: LD_INT 13
47658: PUSH
47659: LD_INT 14
47661: PUSH
47662: LD_INT 15
47664: PUSH
47665: LD_INT 16
47667: PUSH
47668: LD_INT 17
47670: PUSH
47671: LD_INT 18
47673: PUSH
47674: LD_INT 19
47676: PUSH
47677: LD_INT 20
47679: PUSH
47680: LD_INT 21
47682: PUSH
47683: LD_INT 22
47685: PUSH
47686: LD_INT 23
47688: PUSH
47689: LD_INT 24
47691: PUSH
47692: LD_INT 25
47694: PUSH
47695: LD_INT 26
47697: PUSH
47698: LD_INT 27
47700: PUSH
47701: LD_INT 28
47703: PUSH
47704: LD_INT 29
47706: PUSH
47707: LD_INT 30
47709: PUSH
47710: LD_INT 31
47712: PUSH
47713: LD_INT 32
47715: PUSH
47716: LD_INT 33
47718: PUSH
47719: LD_INT 34
47721: PUSH
47722: LD_INT 35
47724: PUSH
47725: LD_INT 36
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: LIST
47732: LIST
47733: LIST
47734: LIST
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: LIST
47746: LIST
47747: LIST
47748: LIST
47749: LIST
47750: LIST
47751: LIST
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: PUSH
47766: LD_INT 101
47768: PUSH
47769: LD_INT 102
47771: PUSH
47772: LD_INT 103
47774: PUSH
47775: LD_INT 104
47777: PUSH
47778: LD_INT 105
47780: PUSH
47781: LD_INT 106
47783: PUSH
47784: LD_INT 107
47786: PUSH
47787: LD_INT 108
47789: PUSH
47790: LD_INT 109
47792: PUSH
47793: LD_INT 110
47795: PUSH
47796: LD_INT 111
47798: PUSH
47799: LD_INT 112
47801: PUSH
47802: LD_INT 113
47804: PUSH
47805: LD_INT 114
47807: PUSH
47808: LD_INT 115
47810: PUSH
47811: EMPTY
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: ST_TO_ADDR
47832: GO 47835
47834: POP
// end else
47835: GO 48054
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
47837: LD_ADDR_VAR 0 1
47841: PUSH
47842: LD_INT 1
47844: PUSH
47845: LD_INT 2
47847: PUSH
47848: LD_INT 3
47850: PUSH
47851: LD_INT 4
47853: PUSH
47854: LD_INT 5
47856: PUSH
47857: LD_INT 6
47859: PUSH
47860: LD_INT 7
47862: PUSH
47863: LD_INT 8
47865: PUSH
47866: LD_INT 9
47868: PUSH
47869: LD_INT 10
47871: PUSH
47872: LD_INT 11
47874: PUSH
47875: LD_INT 12
47877: PUSH
47878: LD_INT 13
47880: PUSH
47881: LD_INT 14
47883: PUSH
47884: LD_INT 15
47886: PUSH
47887: LD_INT 16
47889: PUSH
47890: LD_INT 17
47892: PUSH
47893: LD_INT 18
47895: PUSH
47896: LD_INT 19
47898: PUSH
47899: LD_INT 20
47901: PUSH
47902: LD_INT 21
47904: PUSH
47905: LD_INT 22
47907: PUSH
47908: LD_INT 23
47910: PUSH
47911: LD_INT 24
47913: PUSH
47914: LD_INT 25
47916: PUSH
47917: LD_INT 26
47919: PUSH
47920: LD_INT 27
47922: PUSH
47923: LD_INT 28
47925: PUSH
47926: LD_INT 29
47928: PUSH
47929: LD_INT 30
47931: PUSH
47932: LD_INT 31
47934: PUSH
47935: LD_INT 32
47937: PUSH
47938: LD_INT 33
47940: PUSH
47941: LD_INT 34
47943: PUSH
47944: LD_INT 35
47946: PUSH
47947: LD_INT 36
47949: PUSH
47950: EMPTY
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: LIST
47974: LIST
47975: LIST
47976: LIST
47977: LIST
47978: LIST
47979: LIST
47980: LIST
47981: LIST
47982: LIST
47983: LIST
47984: LIST
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 101
47990: PUSH
47991: LD_INT 102
47993: PUSH
47994: LD_INT 103
47996: PUSH
47997: LD_INT 104
47999: PUSH
48000: LD_INT 105
48002: PUSH
48003: LD_INT 106
48005: PUSH
48006: LD_INT 107
48008: PUSH
48009: LD_INT 108
48011: PUSH
48012: LD_INT 109
48014: PUSH
48015: LD_INT 110
48017: PUSH
48018: LD_INT 111
48020: PUSH
48021: LD_INT 112
48023: PUSH
48024: LD_INT 113
48026: PUSH
48027: LD_INT 114
48029: PUSH
48030: LD_INT 115
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: LIST
48039: LIST
48040: LIST
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: ST_TO_ADDR
// if result then
48054: LD_VAR 0 1
48058: IFFALSE 48347
// begin normal :=  ;
48060: LD_ADDR_VAR 0 3
48064: PUSH
48065: LD_STRING 
48067: ST_TO_ADDR
// hardcore :=  ;
48068: LD_ADDR_VAR 0 4
48072: PUSH
48073: LD_STRING 
48075: ST_TO_ADDR
// for i = 1 to normalCounter do
48076: LD_ADDR_VAR 0 5
48080: PUSH
48081: DOUBLE
48082: LD_INT 1
48084: DEC
48085: ST_TO_ADDR
48086: LD_EXP 91
48090: PUSH
48091: FOR_TO
48092: IFFALSE 48193
// begin tmp := 0 ;
48094: LD_ADDR_VAR 0 2
48098: PUSH
48099: LD_STRING 0
48101: ST_TO_ADDR
// if result [ 1 ] then
48102: LD_VAR 0 1
48106: PUSH
48107: LD_INT 1
48109: ARRAY
48110: IFFALSE 48175
// if result [ 1 ] [ 1 ] = i then
48112: LD_VAR 0 1
48116: PUSH
48117: LD_INT 1
48119: ARRAY
48120: PUSH
48121: LD_INT 1
48123: ARRAY
48124: PUSH
48125: LD_VAR 0 5
48129: EQUAL
48130: IFFALSE 48175
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
48132: LD_ADDR_VAR 0 1
48136: PUSH
48137: LD_VAR 0 1
48141: PPUSH
48142: LD_INT 1
48144: PPUSH
48145: LD_VAR 0 1
48149: PUSH
48150: LD_INT 1
48152: ARRAY
48153: PPUSH
48154: LD_INT 1
48156: PPUSH
48157: CALL_OW 3
48161: PPUSH
48162: CALL_OW 1
48166: ST_TO_ADDR
// tmp := 1 ;
48167: LD_ADDR_VAR 0 2
48171: PUSH
48172: LD_STRING 1
48174: ST_TO_ADDR
// end ; normal := normal & tmp ;
48175: LD_ADDR_VAR 0 3
48179: PUSH
48180: LD_VAR 0 3
48184: PUSH
48185: LD_VAR 0 2
48189: STR
48190: ST_TO_ADDR
// end ;
48191: GO 48091
48193: POP
48194: POP
// for i = 1 to hardcoreCounter do
48195: LD_ADDR_VAR 0 5
48199: PUSH
48200: DOUBLE
48201: LD_INT 1
48203: DEC
48204: ST_TO_ADDR
48205: LD_EXP 92
48209: PUSH
48210: FOR_TO
48211: IFFALSE 48316
// begin tmp := 0 ;
48213: LD_ADDR_VAR 0 2
48217: PUSH
48218: LD_STRING 0
48220: ST_TO_ADDR
// if result [ 2 ] then
48221: LD_VAR 0 1
48225: PUSH
48226: LD_INT 2
48228: ARRAY
48229: IFFALSE 48298
// if result [ 2 ] [ 1 ] = 100 + i then
48231: LD_VAR 0 1
48235: PUSH
48236: LD_INT 2
48238: ARRAY
48239: PUSH
48240: LD_INT 1
48242: ARRAY
48243: PUSH
48244: LD_INT 100
48246: PUSH
48247: LD_VAR 0 5
48251: PLUS
48252: EQUAL
48253: IFFALSE 48298
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
48255: LD_ADDR_VAR 0 1
48259: PUSH
48260: LD_VAR 0 1
48264: PPUSH
48265: LD_INT 2
48267: PPUSH
48268: LD_VAR 0 1
48272: PUSH
48273: LD_INT 2
48275: ARRAY
48276: PPUSH
48277: LD_INT 1
48279: PPUSH
48280: CALL_OW 3
48284: PPUSH
48285: CALL_OW 1
48289: ST_TO_ADDR
// tmp := 1 ;
48290: LD_ADDR_VAR 0 2
48294: PUSH
48295: LD_STRING 1
48297: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
48298: LD_ADDR_VAR 0 4
48302: PUSH
48303: LD_VAR 0 4
48307: PUSH
48308: LD_VAR 0 2
48312: STR
48313: ST_TO_ADDR
// end ;
48314: GO 48210
48316: POP
48317: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
48318: LD_STRING getStreamItemsFromMission("
48320: PUSH
48321: LD_VAR 0 3
48325: STR
48326: PUSH
48327: LD_STRING ","
48329: STR
48330: PUSH
48331: LD_VAR 0 4
48335: STR
48336: PUSH
48337: LD_STRING ")
48339: STR
48340: PPUSH
48341: CALL_OW 559
// end else
48345: GO 48354
// ToLua ( getStreamItemsFromMission("","") ) ;
48347: LD_STRING getStreamItemsFromMission("","")
48349: PPUSH
48350: CALL_OW 559
// end ;
48354: LD_VAR 0 1
48358: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
48359: LD_EXP 90
48363: PUSH
48364: LD_EXP 95
48368: AND
48369: IFFALSE 48493
48371: GO 48373
48373: DISABLE
48374: LD_INT 0
48376: PPUSH
48377: PPUSH
// begin enable ;
48378: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
48379: LD_ADDR_VAR 0 2
48383: PUSH
48384: LD_INT 22
48386: PUSH
48387: LD_OWVAR 2
48391: PUSH
48392: EMPTY
48393: LIST
48394: LIST
48395: PUSH
48396: LD_INT 2
48398: PUSH
48399: LD_INT 34
48401: PUSH
48402: LD_INT 7
48404: PUSH
48405: EMPTY
48406: LIST
48407: LIST
48408: PUSH
48409: LD_INT 34
48411: PUSH
48412: LD_INT 45
48414: PUSH
48415: EMPTY
48416: LIST
48417: LIST
48418: PUSH
48419: LD_INT 34
48421: PUSH
48422: LD_INT 28
48424: PUSH
48425: EMPTY
48426: LIST
48427: LIST
48428: PUSH
48429: LD_INT 34
48431: PUSH
48432: LD_INT 47
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: PUSH
48446: EMPTY
48447: LIST
48448: LIST
48449: PPUSH
48450: CALL_OW 69
48454: ST_TO_ADDR
// if not tmp then
48455: LD_VAR 0 2
48459: NOT
48460: IFFALSE 48464
// exit ;
48462: GO 48493
// for i in tmp do
48464: LD_ADDR_VAR 0 1
48468: PUSH
48469: LD_VAR 0 2
48473: PUSH
48474: FOR_IN
48475: IFFALSE 48491
// begin SetLives ( i , 0 ) ;
48477: LD_VAR 0 1
48481: PPUSH
48482: LD_INT 0
48484: PPUSH
48485: CALL_OW 234
// end ;
48489: GO 48474
48491: POP
48492: POP
// end ;
48493: PPOPN 2
48495: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
48496: LD_EXP 90
48500: PUSH
48501: LD_EXP 96
48505: AND
48506: IFFALSE 48590
48508: GO 48510
48510: DISABLE
48511: LD_INT 0
48513: PPUSH
48514: PPUSH
// begin enable ;
48515: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
48516: LD_ADDR_VAR 0 2
48520: PUSH
48521: LD_INT 22
48523: PUSH
48524: LD_OWVAR 2
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: PUSH
48533: LD_INT 32
48535: PUSH
48536: LD_INT 3
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PUSH
48543: EMPTY
48544: LIST
48545: LIST
48546: PPUSH
48547: CALL_OW 69
48551: ST_TO_ADDR
// if not tmp then
48552: LD_VAR 0 2
48556: NOT
48557: IFFALSE 48561
// exit ;
48559: GO 48590
// for i in tmp do
48561: LD_ADDR_VAR 0 1
48565: PUSH
48566: LD_VAR 0 2
48570: PUSH
48571: FOR_IN
48572: IFFALSE 48588
// begin SetLives ( i , 0 ) ;
48574: LD_VAR 0 1
48578: PPUSH
48579: LD_INT 0
48581: PPUSH
48582: CALL_OW 234
// end ;
48586: GO 48571
48588: POP
48589: POP
// end ;
48590: PPOPN 2
48592: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
48593: LD_EXP 90
48597: PUSH
48598: LD_EXP 93
48602: AND
48603: IFFALSE 48696
48605: GO 48607
48607: DISABLE
48608: LD_INT 0
48610: PPUSH
// begin enable ;
48611: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
48612: LD_ADDR_VAR 0 1
48616: PUSH
48617: LD_INT 22
48619: PUSH
48620: LD_OWVAR 2
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: PUSH
48629: LD_INT 2
48631: PUSH
48632: LD_INT 25
48634: PUSH
48635: LD_INT 5
48637: PUSH
48638: EMPTY
48639: LIST
48640: LIST
48641: PUSH
48642: LD_INT 25
48644: PUSH
48645: LD_INT 9
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 25
48654: PUSH
48655: LD_INT 8
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: PUSH
48668: EMPTY
48669: LIST
48670: LIST
48671: PPUSH
48672: CALL_OW 69
48676: PUSH
48677: FOR_IN
48678: IFFALSE 48694
// begin SetClass ( i , 1 ) ;
48680: LD_VAR 0 1
48684: PPUSH
48685: LD_INT 1
48687: PPUSH
48688: CALL_OW 336
// end ;
48692: GO 48677
48694: POP
48695: POP
// end ;
48696: PPOPN 1
48698: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
48699: LD_EXP 90
48703: PUSH
48704: LD_EXP 94
48708: AND
48709: PUSH
48710: LD_OWVAR 65
48714: PUSH
48715: LD_INT 7
48717: LESS
48718: AND
48719: IFFALSE 48733
48721: GO 48723
48723: DISABLE
// begin enable ;
48724: ENABLE
// game_speed := 7 ;
48725: LD_ADDR_OWVAR 65
48729: PUSH
48730: LD_INT 7
48732: ST_TO_ADDR
// end ;
48733: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
48734: LD_EXP 90
48738: PUSH
48739: LD_EXP 97
48743: AND
48744: IFFALSE 48946
48746: GO 48748
48748: DISABLE
48749: LD_INT 0
48751: PPUSH
48752: PPUSH
48753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
48754: LD_ADDR_VAR 0 3
48758: PUSH
48759: LD_INT 81
48761: PUSH
48762: LD_OWVAR 2
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: PUSH
48771: LD_INT 21
48773: PUSH
48774: LD_INT 1
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: PUSH
48781: EMPTY
48782: LIST
48783: LIST
48784: PPUSH
48785: CALL_OW 69
48789: ST_TO_ADDR
// if not tmp then
48790: LD_VAR 0 3
48794: NOT
48795: IFFALSE 48799
// exit ;
48797: GO 48946
// if tmp > 5 then
48799: LD_VAR 0 3
48803: PUSH
48804: LD_INT 5
48806: GREATER
48807: IFFALSE 48819
// k := 5 else
48809: LD_ADDR_VAR 0 2
48813: PUSH
48814: LD_INT 5
48816: ST_TO_ADDR
48817: GO 48829
// k := tmp ;
48819: LD_ADDR_VAR 0 2
48823: PUSH
48824: LD_VAR 0 3
48828: ST_TO_ADDR
// for i := 1 to k do
48829: LD_ADDR_VAR 0 1
48833: PUSH
48834: DOUBLE
48835: LD_INT 1
48837: DEC
48838: ST_TO_ADDR
48839: LD_VAR 0 2
48843: PUSH
48844: FOR_TO
48845: IFFALSE 48944
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
48847: LD_VAR 0 3
48851: PUSH
48852: LD_VAR 0 1
48856: ARRAY
48857: PPUSH
48858: LD_VAR 0 1
48862: PUSH
48863: LD_INT 4
48865: MOD
48866: PUSH
48867: LD_INT 1
48869: PLUS
48870: PPUSH
48871: CALL_OW 259
48875: PUSH
48876: LD_INT 10
48878: LESS
48879: IFFALSE 48942
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
48881: LD_VAR 0 3
48885: PUSH
48886: LD_VAR 0 1
48890: ARRAY
48891: PPUSH
48892: LD_VAR 0 1
48896: PUSH
48897: LD_INT 4
48899: MOD
48900: PUSH
48901: LD_INT 1
48903: PLUS
48904: PPUSH
48905: LD_VAR 0 3
48909: PUSH
48910: LD_VAR 0 1
48914: ARRAY
48915: PPUSH
48916: LD_VAR 0 1
48920: PUSH
48921: LD_INT 4
48923: MOD
48924: PUSH
48925: LD_INT 1
48927: PLUS
48928: PPUSH
48929: CALL_OW 259
48933: PUSH
48934: LD_INT 1
48936: PLUS
48937: PPUSH
48938: CALL_OW 237
48942: GO 48844
48944: POP
48945: POP
// end ;
48946: PPOPN 3
48948: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
48949: LD_EXP 90
48953: PUSH
48954: LD_EXP 98
48958: AND
48959: IFFALSE 48979
48961: GO 48963
48963: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
48964: LD_INT 4
48966: PPUSH
48967: LD_OWVAR 2
48971: PPUSH
48972: LD_INT 0
48974: PPUSH
48975: CALL_OW 324
48979: END
// every 0 0$1 trigger StreamModeActive and sShovel do
48980: LD_EXP 90
48984: PUSH
48985: LD_EXP 127
48989: AND
48990: IFFALSE 49010
48992: GO 48994
48994: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
48995: LD_INT 19
48997: PPUSH
48998: LD_OWVAR 2
49002: PPUSH
49003: LD_INT 0
49005: PPUSH
49006: CALL_OW 324
49010: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
49011: LD_EXP 90
49015: PUSH
49016: LD_EXP 99
49020: AND
49021: IFFALSE 49123
49023: GO 49025
49025: DISABLE
49026: LD_INT 0
49028: PPUSH
49029: PPUSH
// begin enable ;
49030: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
49031: LD_ADDR_VAR 0 2
49035: PUSH
49036: LD_INT 22
49038: PUSH
49039: LD_OWVAR 2
49043: PUSH
49044: EMPTY
49045: LIST
49046: LIST
49047: PUSH
49048: LD_INT 2
49050: PUSH
49051: LD_INT 34
49053: PUSH
49054: LD_INT 11
49056: PUSH
49057: EMPTY
49058: LIST
49059: LIST
49060: PUSH
49061: LD_INT 34
49063: PUSH
49064: LD_INT 30
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: PUSH
49071: EMPTY
49072: LIST
49073: LIST
49074: LIST
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: PPUSH
49080: CALL_OW 69
49084: ST_TO_ADDR
// if not tmp then
49085: LD_VAR 0 2
49089: NOT
49090: IFFALSE 49094
// exit ;
49092: GO 49123
// for i in tmp do
49094: LD_ADDR_VAR 0 1
49098: PUSH
49099: LD_VAR 0 2
49103: PUSH
49104: FOR_IN
49105: IFFALSE 49121
// begin SetLives ( i , 0 ) ;
49107: LD_VAR 0 1
49111: PPUSH
49112: LD_INT 0
49114: PPUSH
49115: CALL_OW 234
// end ;
49119: GO 49104
49121: POP
49122: POP
// end ;
49123: PPOPN 2
49125: END
// every 0 0$1 trigger StreamModeActive and sBunker do
49126: LD_EXP 90
49130: PUSH
49131: LD_EXP 100
49135: AND
49136: IFFALSE 49156
49138: GO 49140
49140: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
49141: LD_INT 32
49143: PPUSH
49144: LD_OWVAR 2
49148: PPUSH
49149: LD_INT 0
49151: PPUSH
49152: CALL_OW 324
49156: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
49157: LD_EXP 90
49161: PUSH
49162: LD_EXP 101
49166: AND
49167: IFFALSE 49348
49169: GO 49171
49171: DISABLE
49172: LD_INT 0
49174: PPUSH
49175: PPUSH
49176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
49177: LD_ADDR_VAR 0 2
49181: PUSH
49182: LD_INT 22
49184: PUSH
49185: LD_OWVAR 2
49189: PUSH
49190: EMPTY
49191: LIST
49192: LIST
49193: PUSH
49194: LD_INT 33
49196: PUSH
49197: LD_INT 3
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PPUSH
49208: CALL_OW 69
49212: ST_TO_ADDR
// if not tmp then
49213: LD_VAR 0 2
49217: NOT
49218: IFFALSE 49222
// exit ;
49220: GO 49348
// side := 0 ;
49222: LD_ADDR_VAR 0 3
49226: PUSH
49227: LD_INT 0
49229: ST_TO_ADDR
// for i := 1 to 8 do
49230: LD_ADDR_VAR 0 1
49234: PUSH
49235: DOUBLE
49236: LD_INT 1
49238: DEC
49239: ST_TO_ADDR
49240: LD_INT 8
49242: PUSH
49243: FOR_TO
49244: IFFALSE 49292
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
49246: LD_OWVAR 2
49250: PUSH
49251: LD_VAR 0 1
49255: NONEQUAL
49256: PUSH
49257: LD_OWVAR 2
49261: PPUSH
49262: LD_VAR 0 1
49266: PPUSH
49267: CALL_OW 81
49271: PUSH
49272: LD_INT 2
49274: EQUAL
49275: AND
49276: IFFALSE 49290
// begin side := i ;
49278: LD_ADDR_VAR 0 3
49282: PUSH
49283: LD_VAR 0 1
49287: ST_TO_ADDR
// break ;
49288: GO 49292
// end ;
49290: GO 49243
49292: POP
49293: POP
// if not side then
49294: LD_VAR 0 3
49298: NOT
49299: IFFALSE 49303
// exit ;
49301: GO 49348
// for i := 1 to tmp do
49303: LD_ADDR_VAR 0 1
49307: PUSH
49308: DOUBLE
49309: LD_INT 1
49311: DEC
49312: ST_TO_ADDR
49313: LD_VAR 0 2
49317: PUSH
49318: FOR_TO
49319: IFFALSE 49346
// if Prob ( 60 ) then
49321: LD_INT 60
49323: PPUSH
49324: CALL_OW 13
49328: IFFALSE 49344
// SetSide ( i , side ) ;
49330: LD_VAR 0 1
49334: PPUSH
49335: LD_VAR 0 3
49339: PPUSH
49340: CALL_OW 235
49344: GO 49318
49346: POP
49347: POP
// end ;
49348: PPOPN 3
49350: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
49351: LD_EXP 90
49355: PUSH
49356: LD_EXP 103
49360: AND
49361: IFFALSE 49480
49363: GO 49365
49365: DISABLE
49366: LD_INT 0
49368: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
49369: LD_ADDR_VAR 0 1
49373: PUSH
49374: LD_INT 22
49376: PUSH
49377: LD_OWVAR 2
49381: PUSH
49382: EMPTY
49383: LIST
49384: LIST
49385: PUSH
49386: LD_INT 21
49388: PUSH
49389: LD_INT 1
49391: PUSH
49392: EMPTY
49393: LIST
49394: LIST
49395: PUSH
49396: LD_INT 3
49398: PUSH
49399: LD_INT 23
49401: PUSH
49402: LD_INT 0
49404: PUSH
49405: EMPTY
49406: LIST
49407: LIST
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: LIST
49417: PPUSH
49418: CALL_OW 69
49422: PUSH
49423: FOR_IN
49424: IFFALSE 49478
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
49426: LD_VAR 0 1
49430: PPUSH
49431: CALL_OW 257
49435: PUSH
49436: LD_INT 1
49438: PUSH
49439: LD_INT 2
49441: PUSH
49442: LD_INT 3
49444: PUSH
49445: LD_INT 4
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: IN
49454: IFFALSE 49476
// SetClass ( un , rand ( 1 , 4 ) ) ;
49456: LD_VAR 0 1
49460: PPUSH
49461: LD_INT 1
49463: PPUSH
49464: LD_INT 4
49466: PPUSH
49467: CALL_OW 12
49471: PPUSH
49472: CALL_OW 336
49476: GO 49423
49478: POP
49479: POP
// end ;
49480: PPOPN 1
49482: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
49483: LD_EXP 90
49487: PUSH
49488: LD_EXP 102
49492: AND
49493: IFFALSE 49572
49495: GO 49497
49497: DISABLE
49498: LD_INT 0
49500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49501: LD_ADDR_VAR 0 1
49505: PUSH
49506: LD_INT 22
49508: PUSH
49509: LD_OWVAR 2
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: LD_INT 21
49520: PUSH
49521: LD_INT 3
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: EMPTY
49529: LIST
49530: LIST
49531: PPUSH
49532: CALL_OW 69
49536: ST_TO_ADDR
// if not tmp then
49537: LD_VAR 0 1
49541: NOT
49542: IFFALSE 49546
// exit ;
49544: GO 49572
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
49546: LD_VAR 0 1
49550: PUSH
49551: LD_INT 1
49553: PPUSH
49554: LD_VAR 0 1
49558: PPUSH
49559: CALL_OW 12
49563: ARRAY
49564: PPUSH
49565: LD_INT 100
49567: PPUSH
49568: CALL_OW 234
// end ;
49572: PPOPN 1
49574: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
49575: LD_EXP 90
49579: PUSH
49580: LD_EXP 104
49584: AND
49585: IFFALSE 49683
49587: GO 49589
49589: DISABLE
49590: LD_INT 0
49592: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
49593: LD_ADDR_VAR 0 1
49597: PUSH
49598: LD_INT 22
49600: PUSH
49601: LD_OWVAR 2
49605: PUSH
49606: EMPTY
49607: LIST
49608: LIST
49609: PUSH
49610: LD_INT 21
49612: PUSH
49613: LD_INT 1
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PUSH
49620: EMPTY
49621: LIST
49622: LIST
49623: PPUSH
49624: CALL_OW 69
49628: ST_TO_ADDR
// if not tmp then
49629: LD_VAR 0 1
49633: NOT
49634: IFFALSE 49638
// exit ;
49636: GO 49683
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
49638: LD_VAR 0 1
49642: PUSH
49643: LD_INT 1
49645: PPUSH
49646: LD_VAR 0 1
49650: PPUSH
49651: CALL_OW 12
49655: ARRAY
49656: PPUSH
49657: LD_INT 1
49659: PPUSH
49660: LD_INT 4
49662: PPUSH
49663: CALL_OW 12
49667: PPUSH
49668: LD_INT 3000
49670: PPUSH
49671: LD_INT 9000
49673: PPUSH
49674: CALL_OW 12
49678: PPUSH
49679: CALL_OW 492
// end ;
49683: PPOPN 1
49685: END
// every 0 0$1 trigger StreamModeActive and sDepot do
49686: LD_EXP 90
49690: PUSH
49691: LD_EXP 105
49695: AND
49696: IFFALSE 49716
49698: GO 49700
49700: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
49701: LD_INT 1
49703: PPUSH
49704: LD_OWVAR 2
49708: PPUSH
49709: LD_INT 0
49711: PPUSH
49712: CALL_OW 324
49716: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
49717: LD_EXP 90
49721: PUSH
49722: LD_EXP 106
49726: AND
49727: IFFALSE 49810
49729: GO 49731
49731: DISABLE
49732: LD_INT 0
49734: PPUSH
49735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
49736: LD_ADDR_VAR 0 2
49740: PUSH
49741: LD_INT 22
49743: PUSH
49744: LD_OWVAR 2
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PUSH
49753: LD_INT 21
49755: PUSH
49756: LD_INT 3
49758: PUSH
49759: EMPTY
49760: LIST
49761: LIST
49762: PUSH
49763: EMPTY
49764: LIST
49765: LIST
49766: PPUSH
49767: CALL_OW 69
49771: ST_TO_ADDR
// if not tmp then
49772: LD_VAR 0 2
49776: NOT
49777: IFFALSE 49781
// exit ;
49779: GO 49810
// for i in tmp do
49781: LD_ADDR_VAR 0 1
49785: PUSH
49786: LD_VAR 0 2
49790: PUSH
49791: FOR_IN
49792: IFFALSE 49808
// SetBLevel ( i , 10 ) ;
49794: LD_VAR 0 1
49798: PPUSH
49799: LD_INT 10
49801: PPUSH
49802: CALL_OW 241
49806: GO 49791
49808: POP
49809: POP
// end ;
49810: PPOPN 2
49812: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
49813: LD_EXP 90
49817: PUSH
49818: LD_EXP 107
49822: AND
49823: IFFALSE 49934
49825: GO 49827
49827: DISABLE
49828: LD_INT 0
49830: PPUSH
49831: PPUSH
49832: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
49833: LD_ADDR_VAR 0 3
49837: PUSH
49838: LD_INT 22
49840: PUSH
49841: LD_OWVAR 2
49845: PUSH
49846: EMPTY
49847: LIST
49848: LIST
49849: PUSH
49850: LD_INT 25
49852: PUSH
49853: LD_INT 1
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PUSH
49860: EMPTY
49861: LIST
49862: LIST
49863: PPUSH
49864: CALL_OW 69
49868: ST_TO_ADDR
// if not tmp then
49869: LD_VAR 0 3
49873: NOT
49874: IFFALSE 49878
// exit ;
49876: GO 49934
// un := tmp [ rand ( 1 , tmp ) ] ;
49878: LD_ADDR_VAR 0 2
49882: PUSH
49883: LD_VAR 0 3
49887: PUSH
49888: LD_INT 1
49890: PPUSH
49891: LD_VAR 0 3
49895: PPUSH
49896: CALL_OW 12
49900: ARRAY
49901: ST_TO_ADDR
// if Crawls ( un ) then
49902: LD_VAR 0 2
49906: PPUSH
49907: CALL_OW 318
49911: IFFALSE 49922
// ComWalk ( un ) ;
49913: LD_VAR 0 2
49917: PPUSH
49918: CALL_OW 138
// SetClass ( un , class_sniper ) ;
49922: LD_VAR 0 2
49926: PPUSH
49927: LD_INT 5
49929: PPUSH
49930: CALL_OW 336
// end ;
49934: PPOPN 3
49936: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
49937: LD_EXP 90
49941: PUSH
49942: LD_EXP 108
49946: AND
49947: PUSH
49948: LD_OWVAR 67
49952: PUSH
49953: LD_INT 3
49955: LESS
49956: AND
49957: IFFALSE 49976
49959: GO 49961
49961: DISABLE
// Difficulty := Difficulty + 1 ;
49962: LD_ADDR_OWVAR 67
49966: PUSH
49967: LD_OWVAR 67
49971: PUSH
49972: LD_INT 1
49974: PLUS
49975: ST_TO_ADDR
49976: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
49977: LD_EXP 90
49981: PUSH
49982: LD_EXP 109
49986: AND
49987: IFFALSE 50090
49989: GO 49991
49991: DISABLE
49992: LD_INT 0
49994: PPUSH
// begin for i := 1 to 5 do
49995: LD_ADDR_VAR 0 1
49999: PUSH
50000: DOUBLE
50001: LD_INT 1
50003: DEC
50004: ST_TO_ADDR
50005: LD_INT 5
50007: PUSH
50008: FOR_TO
50009: IFFALSE 50088
// begin uc_nation := nation_nature ;
50011: LD_ADDR_OWVAR 21
50015: PUSH
50016: LD_INT 0
50018: ST_TO_ADDR
// uc_side := 0 ;
50019: LD_ADDR_OWVAR 20
50023: PUSH
50024: LD_INT 0
50026: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50027: LD_ADDR_OWVAR 29
50031: PUSH
50032: LD_INT 12
50034: PUSH
50035: LD_INT 12
50037: PUSH
50038: EMPTY
50039: LIST
50040: LIST
50041: ST_TO_ADDR
// hc_agressivity := 20 ;
50042: LD_ADDR_OWVAR 35
50046: PUSH
50047: LD_INT 20
50049: ST_TO_ADDR
// hc_class := class_tiger ;
50050: LD_ADDR_OWVAR 28
50054: PUSH
50055: LD_INT 14
50057: ST_TO_ADDR
// hc_gallery :=  ;
50058: LD_ADDR_OWVAR 33
50062: PUSH
50063: LD_STRING 
50065: ST_TO_ADDR
// hc_name :=  ;
50066: LD_ADDR_OWVAR 26
50070: PUSH
50071: LD_STRING 
50073: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
50074: CALL_OW 44
50078: PPUSH
50079: LD_INT 0
50081: PPUSH
50082: CALL_OW 51
// end ;
50086: GO 50008
50088: POP
50089: POP
// end ;
50090: PPOPN 1
50092: END
// every 0 0$1 trigger StreamModeActive and sBomb do
50093: LD_EXP 90
50097: PUSH
50098: LD_EXP 110
50102: AND
50103: IFFALSE 50112
50105: GO 50107
50107: DISABLE
// StreamSibBomb ;
50108: CALL 50113 0 0
50112: END
// export function StreamSibBomb ; var i , x , y ; begin
50113: LD_INT 0
50115: PPUSH
50116: PPUSH
50117: PPUSH
50118: PPUSH
// result := false ;
50119: LD_ADDR_VAR 0 1
50123: PUSH
50124: LD_INT 0
50126: ST_TO_ADDR
// for i := 1 to 16 do
50127: LD_ADDR_VAR 0 2
50131: PUSH
50132: DOUBLE
50133: LD_INT 1
50135: DEC
50136: ST_TO_ADDR
50137: LD_INT 16
50139: PUSH
50140: FOR_TO
50141: IFFALSE 50340
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50143: LD_ADDR_VAR 0 3
50147: PUSH
50148: LD_INT 10
50150: PUSH
50151: LD_INT 20
50153: PUSH
50154: LD_INT 30
50156: PUSH
50157: LD_INT 40
50159: PUSH
50160: LD_INT 50
50162: PUSH
50163: LD_INT 60
50165: PUSH
50166: LD_INT 70
50168: PUSH
50169: LD_INT 80
50171: PUSH
50172: LD_INT 90
50174: PUSH
50175: LD_INT 100
50177: PUSH
50178: LD_INT 110
50180: PUSH
50181: LD_INT 120
50183: PUSH
50184: LD_INT 130
50186: PUSH
50187: LD_INT 140
50189: PUSH
50190: LD_INT 150
50192: PUSH
50193: EMPTY
50194: LIST
50195: LIST
50196: LIST
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: LIST
50202: LIST
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: PUSH
50210: LD_INT 1
50212: PPUSH
50213: LD_INT 15
50215: PPUSH
50216: CALL_OW 12
50220: ARRAY
50221: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
50222: LD_ADDR_VAR 0 4
50226: PUSH
50227: LD_INT 10
50229: PUSH
50230: LD_INT 20
50232: PUSH
50233: LD_INT 30
50235: PUSH
50236: LD_INT 40
50238: PUSH
50239: LD_INT 50
50241: PUSH
50242: LD_INT 60
50244: PUSH
50245: LD_INT 70
50247: PUSH
50248: LD_INT 80
50250: PUSH
50251: LD_INT 90
50253: PUSH
50254: LD_INT 100
50256: PUSH
50257: LD_INT 110
50259: PUSH
50260: LD_INT 120
50262: PUSH
50263: LD_INT 130
50265: PUSH
50266: LD_INT 140
50268: PUSH
50269: LD_INT 150
50271: PUSH
50272: EMPTY
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: PUSH
50289: LD_INT 1
50291: PPUSH
50292: LD_INT 15
50294: PPUSH
50295: CALL_OW 12
50299: ARRAY
50300: ST_TO_ADDR
// if ValidHex ( x , y ) then
50301: LD_VAR 0 3
50305: PPUSH
50306: LD_VAR 0 4
50310: PPUSH
50311: CALL_OW 488
50315: IFFALSE 50338
// begin result := [ x , y ] ;
50317: LD_ADDR_VAR 0 1
50321: PUSH
50322: LD_VAR 0 3
50326: PUSH
50327: LD_VAR 0 4
50331: PUSH
50332: EMPTY
50333: LIST
50334: LIST
50335: ST_TO_ADDR
// break ;
50336: GO 50340
// end ; end ;
50338: GO 50140
50340: POP
50341: POP
// if result then
50342: LD_VAR 0 1
50346: IFFALSE 50406
// begin ToLua ( playSibBomb() ) ;
50348: LD_STRING playSibBomb()
50350: PPUSH
50351: CALL_OW 559
// wait ( 0 0$14 ) ;
50355: LD_INT 490
50357: PPUSH
50358: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
50362: LD_VAR 0 1
50366: PUSH
50367: LD_INT 1
50369: ARRAY
50370: PPUSH
50371: LD_VAR 0 1
50375: PUSH
50376: LD_INT 2
50378: ARRAY
50379: PPUSH
50380: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
50384: LD_VAR 0 1
50388: PUSH
50389: LD_INT 1
50391: ARRAY
50392: PPUSH
50393: LD_VAR 0 1
50397: PUSH
50398: LD_INT 2
50400: ARRAY
50401: PPUSH
50402: CALL_OW 429
// end ; end ;
50406: LD_VAR 0 1
50410: RET
// every 0 0$1 trigger StreamModeActive and sReset do
50411: LD_EXP 90
50415: PUSH
50416: LD_EXP 112
50420: AND
50421: IFFALSE 50433
50423: GO 50425
50425: DISABLE
// YouLost (  ) ;
50426: LD_STRING 
50428: PPUSH
50429: CALL_OW 104
50433: END
// every 0 0$1 trigger StreamModeActive and sFog do
50434: LD_EXP 90
50438: PUSH
50439: LD_EXP 111
50443: AND
50444: IFFALSE 50458
50446: GO 50448
50448: DISABLE
// FogOff ( your_side ) ;
50449: LD_OWVAR 2
50453: PPUSH
50454: CALL_OW 344
50458: END
// every 0 0$1 trigger StreamModeActive and sSun do
50459: LD_EXP 90
50463: PUSH
50464: LD_EXP 113
50468: AND
50469: IFFALSE 50497
50471: GO 50473
50473: DISABLE
// begin solar_recharge_percent := 0 ;
50474: LD_ADDR_OWVAR 79
50478: PUSH
50479: LD_INT 0
50481: ST_TO_ADDR
// wait ( 5 5$00 ) ;
50482: LD_INT 10500
50484: PPUSH
50485: CALL_OW 67
// solar_recharge_percent := 100 ;
50489: LD_ADDR_OWVAR 79
50493: PUSH
50494: LD_INT 100
50496: ST_TO_ADDR
// end ;
50497: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
50498: LD_EXP 90
50502: PUSH
50503: LD_EXP 114
50507: AND
50508: IFFALSE 50747
50510: GO 50512
50512: DISABLE
50513: LD_INT 0
50515: PPUSH
50516: PPUSH
50517: PPUSH
// begin tmp := [ ] ;
50518: LD_ADDR_VAR 0 3
50522: PUSH
50523: EMPTY
50524: ST_TO_ADDR
// for i := 1 to 6 do
50525: LD_ADDR_VAR 0 1
50529: PUSH
50530: DOUBLE
50531: LD_INT 1
50533: DEC
50534: ST_TO_ADDR
50535: LD_INT 6
50537: PUSH
50538: FOR_TO
50539: IFFALSE 50644
// begin uc_nation := nation_nature ;
50541: LD_ADDR_OWVAR 21
50545: PUSH
50546: LD_INT 0
50548: ST_TO_ADDR
// uc_side := 0 ;
50549: LD_ADDR_OWVAR 20
50553: PUSH
50554: LD_INT 0
50556: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
50557: LD_ADDR_OWVAR 29
50561: PUSH
50562: LD_INT 12
50564: PUSH
50565: LD_INT 12
50567: PUSH
50568: EMPTY
50569: LIST
50570: LIST
50571: ST_TO_ADDR
// hc_agressivity := 20 ;
50572: LD_ADDR_OWVAR 35
50576: PUSH
50577: LD_INT 20
50579: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
50580: LD_ADDR_OWVAR 28
50584: PUSH
50585: LD_INT 17
50587: ST_TO_ADDR
// hc_gallery :=  ;
50588: LD_ADDR_OWVAR 33
50592: PUSH
50593: LD_STRING 
50595: ST_TO_ADDR
// hc_name :=  ;
50596: LD_ADDR_OWVAR 26
50600: PUSH
50601: LD_STRING 
50603: ST_TO_ADDR
// un := CreateHuman ;
50604: LD_ADDR_VAR 0 2
50608: PUSH
50609: CALL_OW 44
50613: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
50614: LD_VAR 0 2
50618: PPUSH
50619: LD_INT 1
50621: PPUSH
50622: CALL_OW 51
// tmp := tmp ^ un ;
50626: LD_ADDR_VAR 0 3
50630: PUSH
50631: LD_VAR 0 3
50635: PUSH
50636: LD_VAR 0 2
50640: ADD
50641: ST_TO_ADDR
// end ;
50642: GO 50538
50644: POP
50645: POP
// repeat wait ( 0 0$1 ) ;
50646: LD_INT 35
50648: PPUSH
50649: CALL_OW 67
// for un in tmp do
50653: LD_ADDR_VAR 0 2
50657: PUSH
50658: LD_VAR 0 3
50662: PUSH
50663: FOR_IN
50664: IFFALSE 50738
// begin if IsDead ( un ) then
50666: LD_VAR 0 2
50670: PPUSH
50671: CALL_OW 301
50675: IFFALSE 50695
// begin tmp := tmp diff un ;
50677: LD_ADDR_VAR 0 3
50681: PUSH
50682: LD_VAR 0 3
50686: PUSH
50687: LD_VAR 0 2
50691: DIFF
50692: ST_TO_ADDR
// continue ;
50693: GO 50663
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
50695: LD_VAR 0 2
50699: PPUSH
50700: LD_INT 3
50702: PUSH
50703: LD_INT 22
50705: PUSH
50706: LD_INT 0
50708: PUSH
50709: EMPTY
50710: LIST
50711: LIST
50712: PUSH
50713: EMPTY
50714: LIST
50715: LIST
50716: PPUSH
50717: CALL_OW 69
50721: PPUSH
50722: LD_VAR 0 2
50726: PPUSH
50727: CALL_OW 74
50731: PPUSH
50732: CALL_OW 115
// end ;
50736: GO 50663
50738: POP
50739: POP
// until not tmp ;
50740: LD_VAR 0 3
50744: NOT
50745: IFFALSE 50646
// end ;
50747: PPOPN 3
50749: END
// every 0 0$1 trigger StreamModeActive and sTroll do
50750: LD_EXP 90
50754: PUSH
50755: LD_EXP 115
50759: AND
50760: IFFALSE 50814
50762: GO 50764
50764: DISABLE
// begin ToLua ( displayTroll(); ) ;
50765: LD_STRING displayTroll();
50767: PPUSH
50768: CALL_OW 559
// wait ( 3 3$00 ) ;
50772: LD_INT 6300
50774: PPUSH
50775: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50779: LD_STRING hideTroll();
50781: PPUSH
50782: CALL_OW 559
// wait ( 1 1$00 ) ;
50786: LD_INT 2100
50788: PPUSH
50789: CALL_OW 67
// ToLua ( displayTroll(); ) ;
50793: LD_STRING displayTroll();
50795: PPUSH
50796: CALL_OW 559
// wait ( 1 1$00 ) ;
50800: LD_INT 2100
50802: PPUSH
50803: CALL_OW 67
// ToLua ( hideTroll(); ) ;
50807: LD_STRING hideTroll();
50809: PPUSH
50810: CALL_OW 559
// end ;
50814: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
50815: LD_EXP 90
50819: PUSH
50820: LD_EXP 116
50824: AND
50825: IFFALSE 50888
50827: GO 50829
50829: DISABLE
50830: LD_INT 0
50832: PPUSH
// begin p := 0 ;
50833: LD_ADDR_VAR 0 1
50837: PUSH
50838: LD_INT 0
50840: ST_TO_ADDR
// repeat game_speed := 1 ;
50841: LD_ADDR_OWVAR 65
50845: PUSH
50846: LD_INT 1
50848: ST_TO_ADDR
// wait ( 0 0$1 ) ;
50849: LD_INT 35
50851: PPUSH
50852: CALL_OW 67
// p := p + 1 ;
50856: LD_ADDR_VAR 0 1
50860: PUSH
50861: LD_VAR 0 1
50865: PUSH
50866: LD_INT 1
50868: PLUS
50869: ST_TO_ADDR
// until p >= 60 ;
50870: LD_VAR 0 1
50874: PUSH
50875: LD_INT 60
50877: GREATEREQUAL
50878: IFFALSE 50841
// game_speed := 4 ;
50880: LD_ADDR_OWVAR 65
50884: PUSH
50885: LD_INT 4
50887: ST_TO_ADDR
// end ;
50888: PPOPN 1
50890: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
50891: LD_EXP 90
50895: PUSH
50896: LD_EXP 117
50900: AND
50901: IFFALSE 51047
50903: GO 50905
50905: DISABLE
50906: LD_INT 0
50908: PPUSH
50909: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
50910: LD_ADDR_VAR 0 1
50914: PUSH
50915: LD_INT 22
50917: PUSH
50918: LD_OWVAR 2
50922: PUSH
50923: EMPTY
50924: LIST
50925: LIST
50926: PUSH
50927: LD_INT 2
50929: PUSH
50930: LD_INT 30
50932: PUSH
50933: LD_INT 0
50935: PUSH
50936: EMPTY
50937: LIST
50938: LIST
50939: PUSH
50940: LD_INT 30
50942: PUSH
50943: LD_INT 1
50945: PUSH
50946: EMPTY
50947: LIST
50948: LIST
50949: PUSH
50950: EMPTY
50951: LIST
50952: LIST
50953: LIST
50954: PUSH
50955: EMPTY
50956: LIST
50957: LIST
50958: PPUSH
50959: CALL_OW 69
50963: ST_TO_ADDR
// if not depot then
50964: LD_VAR 0 1
50968: NOT
50969: IFFALSE 50973
// exit ;
50971: GO 51047
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
50973: LD_ADDR_VAR 0 2
50977: PUSH
50978: LD_VAR 0 1
50982: PUSH
50983: LD_INT 1
50985: PPUSH
50986: LD_VAR 0 1
50990: PPUSH
50991: CALL_OW 12
50995: ARRAY
50996: PPUSH
50997: CALL_OW 274
51001: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
51002: LD_VAR 0 2
51006: PPUSH
51007: LD_INT 1
51009: PPUSH
51010: LD_INT 0
51012: PPUSH
51013: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
51017: LD_VAR 0 2
51021: PPUSH
51022: LD_INT 2
51024: PPUSH
51025: LD_INT 0
51027: PPUSH
51028: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
51032: LD_VAR 0 2
51036: PPUSH
51037: LD_INT 3
51039: PPUSH
51040: LD_INT 0
51042: PPUSH
51043: CALL_OW 277
// end ;
51047: PPOPN 2
51049: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
51050: LD_EXP 90
51054: PUSH
51055: LD_EXP 118
51059: AND
51060: IFFALSE 51157
51062: GO 51064
51064: DISABLE
51065: LD_INT 0
51067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
51068: LD_ADDR_VAR 0 1
51072: PUSH
51073: LD_INT 22
51075: PUSH
51076: LD_OWVAR 2
51080: PUSH
51081: EMPTY
51082: LIST
51083: LIST
51084: PUSH
51085: LD_INT 21
51087: PUSH
51088: LD_INT 1
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: PUSH
51095: LD_INT 3
51097: PUSH
51098: LD_INT 23
51100: PUSH
51101: LD_INT 0
51103: PUSH
51104: EMPTY
51105: LIST
51106: LIST
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: LIST
51116: PPUSH
51117: CALL_OW 69
51121: ST_TO_ADDR
// if not tmp then
51122: LD_VAR 0 1
51126: NOT
51127: IFFALSE 51131
// exit ;
51129: GO 51157
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
51131: LD_VAR 0 1
51135: PUSH
51136: LD_INT 1
51138: PPUSH
51139: LD_VAR 0 1
51143: PPUSH
51144: CALL_OW 12
51148: ARRAY
51149: PPUSH
51150: LD_INT 200
51152: PPUSH
51153: CALL_OW 234
// end ;
51157: PPOPN 1
51159: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
51160: LD_EXP 90
51164: PUSH
51165: LD_EXP 119
51169: AND
51170: IFFALSE 51249
51172: GO 51174
51174: DISABLE
51175: LD_INT 0
51177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
51178: LD_ADDR_VAR 0 1
51182: PUSH
51183: LD_INT 22
51185: PUSH
51186: LD_OWVAR 2
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PUSH
51195: LD_INT 21
51197: PUSH
51198: LD_INT 2
51200: PUSH
51201: EMPTY
51202: LIST
51203: LIST
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PPUSH
51209: CALL_OW 69
51213: ST_TO_ADDR
// if not tmp then
51214: LD_VAR 0 1
51218: NOT
51219: IFFALSE 51223
// exit ;
51221: GO 51249
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
51223: LD_VAR 0 1
51227: PUSH
51228: LD_INT 1
51230: PPUSH
51231: LD_VAR 0 1
51235: PPUSH
51236: CALL_OW 12
51240: ARRAY
51241: PPUSH
51242: LD_INT 60
51244: PPUSH
51245: CALL_OW 234
// end ;
51249: PPOPN 1
51251: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
51252: LD_EXP 90
51256: PUSH
51257: LD_EXP 120
51261: AND
51262: IFFALSE 51361
51264: GO 51266
51266: DISABLE
51267: LD_INT 0
51269: PPUSH
51270: PPUSH
// begin enable ;
51271: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
51272: LD_ADDR_VAR 0 1
51276: PUSH
51277: LD_INT 22
51279: PUSH
51280: LD_OWVAR 2
51284: PUSH
51285: EMPTY
51286: LIST
51287: LIST
51288: PUSH
51289: LD_INT 61
51291: PUSH
51292: EMPTY
51293: LIST
51294: PUSH
51295: LD_INT 33
51297: PUSH
51298: LD_INT 2
51300: PUSH
51301: EMPTY
51302: LIST
51303: LIST
51304: PUSH
51305: EMPTY
51306: LIST
51307: LIST
51308: LIST
51309: PPUSH
51310: CALL_OW 69
51314: ST_TO_ADDR
// if not tmp then
51315: LD_VAR 0 1
51319: NOT
51320: IFFALSE 51324
// exit ;
51322: GO 51361
// for i in tmp do
51324: LD_ADDR_VAR 0 2
51328: PUSH
51329: LD_VAR 0 1
51333: PUSH
51334: FOR_IN
51335: IFFALSE 51359
// if IsControledBy ( i ) then
51337: LD_VAR 0 2
51341: PPUSH
51342: CALL_OW 312
51346: IFFALSE 51357
// ComUnlink ( i ) ;
51348: LD_VAR 0 2
51352: PPUSH
51353: CALL_OW 136
51357: GO 51334
51359: POP
51360: POP
// end ;
51361: PPOPN 2
51363: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
51364: LD_EXP 90
51368: PUSH
51369: LD_EXP 121
51373: AND
51374: IFFALSE 51514
51376: GO 51378
51378: DISABLE
51379: LD_INT 0
51381: PPUSH
51382: PPUSH
// begin ToLua ( displayPowell(); ) ;
51383: LD_STRING displayPowell();
51385: PPUSH
51386: CALL_OW 559
// uc_side := 0 ;
51390: LD_ADDR_OWVAR 20
51394: PUSH
51395: LD_INT 0
51397: ST_TO_ADDR
// uc_nation := 2 ;
51398: LD_ADDR_OWVAR 21
51402: PUSH
51403: LD_INT 2
51405: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
51406: LD_ADDR_OWVAR 37
51410: PUSH
51411: LD_INT 14
51413: ST_TO_ADDR
// vc_engine := engine_siberite ;
51414: LD_ADDR_OWVAR 39
51418: PUSH
51419: LD_INT 3
51421: ST_TO_ADDR
// vc_control := control_apeman ;
51422: LD_ADDR_OWVAR 38
51426: PUSH
51427: LD_INT 5
51429: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
51430: LD_ADDR_OWVAR 40
51434: PUSH
51435: LD_INT 29
51437: ST_TO_ADDR
// un := CreateVehicle ;
51438: LD_ADDR_VAR 0 2
51442: PUSH
51443: CALL_OW 45
51447: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
51448: LD_VAR 0 2
51452: PPUSH
51453: LD_INT 1
51455: PPUSH
51456: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
51460: LD_INT 35
51462: PPUSH
51463: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
51467: LD_VAR 0 2
51471: PPUSH
51472: LD_INT 22
51474: PUSH
51475: LD_OWVAR 2
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: PPUSH
51484: CALL_OW 69
51488: PPUSH
51489: LD_VAR 0 2
51493: PPUSH
51494: CALL_OW 74
51498: PPUSH
51499: CALL_OW 115
// until IsDead ( un ) ;
51503: LD_VAR 0 2
51507: PPUSH
51508: CALL_OW 301
51512: IFFALSE 51460
// end ;
51514: PPOPN 2
51516: END
// every 0 0$1 trigger StreamModeActive and sStu do
51517: LD_EXP 90
51521: PUSH
51522: LD_EXP 129
51526: AND
51527: IFFALSE 51543
51529: GO 51531
51531: DISABLE
// begin ToLua ( displayStucuk(); ) ;
51532: LD_STRING displayStucuk();
51534: PPUSH
51535: CALL_OW 559
// ResetFog ;
51539: CALL_OW 335
// end ;
51543: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
51544: LD_EXP 90
51548: PUSH
51549: LD_EXP 122
51553: AND
51554: IFFALSE 51695
51556: GO 51558
51558: DISABLE
51559: LD_INT 0
51561: PPUSH
51562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51563: LD_ADDR_VAR 0 2
51567: PUSH
51568: LD_INT 22
51570: PUSH
51571: LD_OWVAR 2
51575: PUSH
51576: EMPTY
51577: LIST
51578: LIST
51579: PUSH
51580: LD_INT 21
51582: PUSH
51583: LD_INT 1
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: PUSH
51590: EMPTY
51591: LIST
51592: LIST
51593: PPUSH
51594: CALL_OW 69
51598: ST_TO_ADDR
// if not tmp then
51599: LD_VAR 0 2
51603: NOT
51604: IFFALSE 51608
// exit ;
51606: GO 51695
// un := tmp [ rand ( 1 , tmp ) ] ;
51608: LD_ADDR_VAR 0 1
51612: PUSH
51613: LD_VAR 0 2
51617: PUSH
51618: LD_INT 1
51620: PPUSH
51621: LD_VAR 0 2
51625: PPUSH
51626: CALL_OW 12
51630: ARRAY
51631: ST_TO_ADDR
// SetSide ( un , 0 ) ;
51632: LD_VAR 0 1
51636: PPUSH
51637: LD_INT 0
51639: PPUSH
51640: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
51644: LD_VAR 0 1
51648: PPUSH
51649: LD_OWVAR 3
51653: PUSH
51654: LD_VAR 0 1
51658: DIFF
51659: PPUSH
51660: LD_VAR 0 1
51664: PPUSH
51665: CALL_OW 74
51669: PPUSH
51670: CALL_OW 115
// wait ( 0 0$20 ) ;
51674: LD_INT 700
51676: PPUSH
51677: CALL_OW 67
// SetSide ( un , your_side ) ;
51681: LD_VAR 0 1
51685: PPUSH
51686: LD_OWVAR 2
51690: PPUSH
51691: CALL_OW 235
// end ;
51695: PPOPN 2
51697: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
51698: LD_EXP 90
51702: PUSH
51703: LD_EXP 123
51707: AND
51708: IFFALSE 51814
51710: GO 51712
51712: DISABLE
51713: LD_INT 0
51715: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
51716: LD_ADDR_VAR 0 1
51720: PUSH
51721: LD_INT 22
51723: PUSH
51724: LD_OWVAR 2
51728: PUSH
51729: EMPTY
51730: LIST
51731: LIST
51732: PUSH
51733: LD_INT 2
51735: PUSH
51736: LD_INT 30
51738: PUSH
51739: LD_INT 0
51741: PUSH
51742: EMPTY
51743: LIST
51744: LIST
51745: PUSH
51746: LD_INT 30
51748: PUSH
51749: LD_INT 1
51751: PUSH
51752: EMPTY
51753: LIST
51754: LIST
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: PUSH
51761: EMPTY
51762: LIST
51763: LIST
51764: PPUSH
51765: CALL_OW 69
51769: ST_TO_ADDR
// if not depot then
51770: LD_VAR 0 1
51774: NOT
51775: IFFALSE 51779
// exit ;
51777: GO 51814
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
51779: LD_VAR 0 1
51783: PUSH
51784: LD_INT 1
51786: ARRAY
51787: PPUSH
51788: CALL_OW 250
51792: PPUSH
51793: LD_VAR 0 1
51797: PUSH
51798: LD_INT 1
51800: ARRAY
51801: PPUSH
51802: CALL_OW 251
51806: PPUSH
51807: LD_INT 70
51809: PPUSH
51810: CALL_OW 495
// end ;
51814: PPOPN 1
51816: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
51817: LD_EXP 90
51821: PUSH
51822: LD_EXP 124
51826: AND
51827: IFFALSE 52038
51829: GO 51831
51831: DISABLE
51832: LD_INT 0
51834: PPUSH
51835: PPUSH
51836: PPUSH
51837: PPUSH
51838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
51839: LD_ADDR_VAR 0 5
51843: PUSH
51844: LD_INT 22
51846: PUSH
51847: LD_OWVAR 2
51851: PUSH
51852: EMPTY
51853: LIST
51854: LIST
51855: PUSH
51856: LD_INT 21
51858: PUSH
51859: LD_INT 1
51861: PUSH
51862: EMPTY
51863: LIST
51864: LIST
51865: PUSH
51866: EMPTY
51867: LIST
51868: LIST
51869: PPUSH
51870: CALL_OW 69
51874: ST_TO_ADDR
// if not tmp then
51875: LD_VAR 0 5
51879: NOT
51880: IFFALSE 51884
// exit ;
51882: GO 52038
// for i in tmp do
51884: LD_ADDR_VAR 0 1
51888: PUSH
51889: LD_VAR 0 5
51893: PUSH
51894: FOR_IN
51895: IFFALSE 52036
// begin d := rand ( 0 , 5 ) ;
51897: LD_ADDR_VAR 0 4
51901: PUSH
51902: LD_INT 0
51904: PPUSH
51905: LD_INT 5
51907: PPUSH
51908: CALL_OW 12
51912: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
51913: LD_ADDR_VAR 0 2
51917: PUSH
51918: LD_VAR 0 1
51922: PPUSH
51923: CALL_OW 250
51927: PPUSH
51928: LD_VAR 0 4
51932: PPUSH
51933: LD_INT 3
51935: PPUSH
51936: LD_INT 12
51938: PPUSH
51939: CALL_OW 12
51943: PPUSH
51944: CALL_OW 272
51948: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
51949: LD_ADDR_VAR 0 3
51953: PUSH
51954: LD_VAR 0 1
51958: PPUSH
51959: CALL_OW 251
51963: PPUSH
51964: LD_VAR 0 4
51968: PPUSH
51969: LD_INT 3
51971: PPUSH
51972: LD_INT 12
51974: PPUSH
51975: CALL_OW 12
51979: PPUSH
51980: CALL_OW 273
51984: ST_TO_ADDR
// if ValidHex ( x , y ) then
51985: LD_VAR 0 2
51989: PPUSH
51990: LD_VAR 0 3
51994: PPUSH
51995: CALL_OW 488
51999: IFFALSE 52034
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
52001: LD_VAR 0 1
52005: PPUSH
52006: LD_VAR 0 2
52010: PPUSH
52011: LD_VAR 0 3
52015: PPUSH
52016: LD_INT 3
52018: PPUSH
52019: LD_INT 6
52021: PPUSH
52022: CALL_OW 12
52026: PPUSH
52027: LD_INT 1
52029: PPUSH
52030: CALL_OW 483
// end ;
52034: GO 51894
52036: POP
52037: POP
// end ;
52038: PPOPN 5
52040: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
52041: LD_EXP 90
52045: PUSH
52046: LD_EXP 125
52050: AND
52051: IFFALSE 52145
52053: GO 52055
52055: DISABLE
52056: LD_INT 0
52058: PPUSH
52059: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
52060: LD_ADDR_VAR 0 2
52064: PUSH
52065: LD_INT 22
52067: PUSH
52068: LD_OWVAR 2
52072: PUSH
52073: EMPTY
52074: LIST
52075: LIST
52076: PUSH
52077: LD_INT 32
52079: PUSH
52080: LD_INT 1
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PUSH
52087: LD_INT 21
52089: PUSH
52090: LD_INT 2
52092: PUSH
52093: EMPTY
52094: LIST
52095: LIST
52096: PUSH
52097: EMPTY
52098: LIST
52099: LIST
52100: LIST
52101: PPUSH
52102: CALL_OW 69
52106: ST_TO_ADDR
// if not tmp then
52107: LD_VAR 0 2
52111: NOT
52112: IFFALSE 52116
// exit ;
52114: GO 52145
// for i in tmp do
52116: LD_ADDR_VAR 0 1
52120: PUSH
52121: LD_VAR 0 2
52125: PUSH
52126: FOR_IN
52127: IFFALSE 52143
// SetFuel ( i , 0 ) ;
52129: LD_VAR 0 1
52133: PPUSH
52134: LD_INT 0
52136: PPUSH
52137: CALL_OW 240
52141: GO 52126
52143: POP
52144: POP
// end ;
52145: PPOPN 2
52147: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
52148: LD_EXP 90
52152: PUSH
52153: LD_EXP 126
52157: AND
52158: IFFALSE 52224
52160: GO 52162
52162: DISABLE
52163: LD_INT 0
52165: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
52166: LD_ADDR_VAR 0 1
52170: PUSH
52171: LD_INT 22
52173: PUSH
52174: LD_OWVAR 2
52178: PUSH
52179: EMPTY
52180: LIST
52181: LIST
52182: PUSH
52183: LD_INT 30
52185: PUSH
52186: LD_INT 29
52188: PUSH
52189: EMPTY
52190: LIST
52191: LIST
52192: PUSH
52193: EMPTY
52194: LIST
52195: LIST
52196: PPUSH
52197: CALL_OW 69
52201: ST_TO_ADDR
// if not tmp then
52202: LD_VAR 0 1
52206: NOT
52207: IFFALSE 52211
// exit ;
52209: GO 52224
// DestroyUnit ( tmp [ 1 ] ) ;
52211: LD_VAR 0 1
52215: PUSH
52216: LD_INT 1
52218: ARRAY
52219: PPUSH
52220: CALL_OW 65
// end ;
52224: PPOPN 1
52226: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
52227: LD_EXP 90
52231: PUSH
52232: LD_EXP 128
52236: AND
52237: IFFALSE 52366
52239: GO 52241
52241: DISABLE
52242: LD_INT 0
52244: PPUSH
// begin uc_side := 0 ;
52245: LD_ADDR_OWVAR 20
52249: PUSH
52250: LD_INT 0
52252: ST_TO_ADDR
// uc_nation := nation_arabian ;
52253: LD_ADDR_OWVAR 21
52257: PUSH
52258: LD_INT 2
52260: ST_TO_ADDR
// hc_gallery :=  ;
52261: LD_ADDR_OWVAR 33
52265: PUSH
52266: LD_STRING 
52268: ST_TO_ADDR
// hc_name :=  ;
52269: LD_ADDR_OWVAR 26
52273: PUSH
52274: LD_STRING 
52276: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
52277: LD_INT 1
52279: PPUSH
52280: LD_INT 11
52282: PPUSH
52283: LD_INT 10
52285: PPUSH
52286: CALL_OW 380
// un := CreateHuman ;
52290: LD_ADDR_VAR 0 1
52294: PUSH
52295: CALL_OW 44
52299: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
52300: LD_VAR 0 1
52304: PPUSH
52305: LD_INT 1
52307: PPUSH
52308: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
52312: LD_INT 35
52314: PPUSH
52315: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
52319: LD_VAR 0 1
52323: PPUSH
52324: LD_INT 22
52326: PUSH
52327: LD_OWVAR 2
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PPUSH
52336: CALL_OW 69
52340: PPUSH
52341: LD_VAR 0 1
52345: PPUSH
52346: CALL_OW 74
52350: PPUSH
52351: CALL_OW 115
// until IsDead ( un ) ;
52355: LD_VAR 0 1
52359: PPUSH
52360: CALL_OW 301
52364: IFFALSE 52312
// end ;
52366: PPOPN 1
52368: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
52369: LD_EXP 90
52373: PUSH
52374: LD_EXP 130
52378: AND
52379: IFFALSE 52391
52381: GO 52383
52383: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
52384: LD_STRING earthquake(getX(game), 0, 32)
52386: PPUSH
52387: CALL_OW 559
52391: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
52392: LD_EXP 90
52396: PUSH
52397: LD_EXP 131
52401: AND
52402: IFFALSE 52493
52404: GO 52406
52406: DISABLE
52407: LD_INT 0
52409: PPUSH
// begin enable ;
52410: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
52411: LD_ADDR_VAR 0 1
52415: PUSH
52416: LD_INT 22
52418: PUSH
52419: LD_OWVAR 2
52423: PUSH
52424: EMPTY
52425: LIST
52426: LIST
52427: PUSH
52428: LD_INT 21
52430: PUSH
52431: LD_INT 2
52433: PUSH
52434: EMPTY
52435: LIST
52436: LIST
52437: PUSH
52438: LD_INT 33
52440: PUSH
52441: LD_INT 3
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: PUSH
52448: EMPTY
52449: LIST
52450: LIST
52451: LIST
52452: PPUSH
52453: CALL_OW 69
52457: ST_TO_ADDR
// if not tmp then
52458: LD_VAR 0 1
52462: NOT
52463: IFFALSE 52467
// exit ;
52465: GO 52493
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
52467: LD_VAR 0 1
52471: PUSH
52472: LD_INT 1
52474: PPUSH
52475: LD_VAR 0 1
52479: PPUSH
52480: CALL_OW 12
52484: ARRAY
52485: PPUSH
52486: LD_INT 1
52488: PPUSH
52489: CALL_OW 234
// end ;
52493: PPOPN 1
52495: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
52496: LD_EXP 90
52500: PUSH
52501: LD_EXP 132
52505: AND
52506: IFFALSE 52647
52508: GO 52510
52510: DISABLE
52511: LD_INT 0
52513: PPUSH
52514: PPUSH
52515: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52516: LD_ADDR_VAR 0 3
52520: PUSH
52521: LD_INT 22
52523: PUSH
52524: LD_OWVAR 2
52528: PUSH
52529: EMPTY
52530: LIST
52531: LIST
52532: PUSH
52533: LD_INT 25
52535: PUSH
52536: LD_INT 1
52538: PUSH
52539: EMPTY
52540: LIST
52541: LIST
52542: PUSH
52543: EMPTY
52544: LIST
52545: LIST
52546: PPUSH
52547: CALL_OW 69
52551: ST_TO_ADDR
// if not tmp then
52552: LD_VAR 0 3
52556: NOT
52557: IFFALSE 52561
// exit ;
52559: GO 52647
// un := tmp [ rand ( 1 , tmp ) ] ;
52561: LD_ADDR_VAR 0 2
52565: PUSH
52566: LD_VAR 0 3
52570: PUSH
52571: LD_INT 1
52573: PPUSH
52574: LD_VAR 0 3
52578: PPUSH
52579: CALL_OW 12
52583: ARRAY
52584: ST_TO_ADDR
// if Crawls ( un ) then
52585: LD_VAR 0 2
52589: PPUSH
52590: CALL_OW 318
52594: IFFALSE 52605
// ComWalk ( un ) ;
52596: LD_VAR 0 2
52600: PPUSH
52601: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
52605: LD_VAR 0 2
52609: PPUSH
52610: LD_INT 9
52612: PPUSH
52613: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
52617: LD_INT 28
52619: PPUSH
52620: LD_OWVAR 2
52624: PPUSH
52625: LD_INT 2
52627: PPUSH
52628: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
52632: LD_INT 29
52634: PPUSH
52635: LD_OWVAR 2
52639: PPUSH
52640: LD_INT 2
52642: PPUSH
52643: CALL_OW 322
// end ;
52647: PPOPN 3
52649: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
52650: LD_EXP 90
52654: PUSH
52655: LD_EXP 133
52659: AND
52660: IFFALSE 52771
52662: GO 52664
52664: DISABLE
52665: LD_INT 0
52667: PPUSH
52668: PPUSH
52669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
52670: LD_ADDR_VAR 0 3
52674: PUSH
52675: LD_INT 22
52677: PUSH
52678: LD_OWVAR 2
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: PUSH
52687: LD_INT 25
52689: PUSH
52690: LD_INT 1
52692: PUSH
52693: EMPTY
52694: LIST
52695: LIST
52696: PUSH
52697: EMPTY
52698: LIST
52699: LIST
52700: PPUSH
52701: CALL_OW 69
52705: ST_TO_ADDR
// if not tmp then
52706: LD_VAR 0 3
52710: NOT
52711: IFFALSE 52715
// exit ;
52713: GO 52771
// un := tmp [ rand ( 1 , tmp ) ] ;
52715: LD_ADDR_VAR 0 2
52719: PUSH
52720: LD_VAR 0 3
52724: PUSH
52725: LD_INT 1
52727: PPUSH
52728: LD_VAR 0 3
52732: PPUSH
52733: CALL_OW 12
52737: ARRAY
52738: ST_TO_ADDR
// if Crawls ( un ) then
52739: LD_VAR 0 2
52743: PPUSH
52744: CALL_OW 318
52748: IFFALSE 52759
// ComWalk ( un ) ;
52750: LD_VAR 0 2
52754: PPUSH
52755: CALL_OW 138
// SetClass ( un , class_mortar ) ;
52759: LD_VAR 0 2
52763: PPUSH
52764: LD_INT 8
52766: PPUSH
52767: CALL_OW 336
// end ;
52771: PPOPN 3
52773: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
52774: LD_EXP 90
52778: PUSH
52779: LD_EXP 134
52783: AND
52784: IFFALSE 52928
52786: GO 52788
52788: DISABLE
52789: LD_INT 0
52791: PPUSH
52792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
52793: LD_ADDR_VAR 0 2
52797: PUSH
52798: LD_INT 22
52800: PUSH
52801: LD_OWVAR 2
52805: PUSH
52806: EMPTY
52807: LIST
52808: LIST
52809: PUSH
52810: LD_INT 21
52812: PUSH
52813: LD_INT 2
52815: PUSH
52816: EMPTY
52817: LIST
52818: LIST
52819: PUSH
52820: LD_INT 2
52822: PUSH
52823: LD_INT 34
52825: PUSH
52826: LD_INT 12
52828: PUSH
52829: EMPTY
52830: LIST
52831: LIST
52832: PUSH
52833: LD_INT 34
52835: PUSH
52836: LD_INT 51
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: PUSH
52843: LD_INT 34
52845: PUSH
52846: LD_INT 32
52848: PUSH
52849: EMPTY
52850: LIST
52851: LIST
52852: PUSH
52853: EMPTY
52854: LIST
52855: LIST
52856: LIST
52857: LIST
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: LIST
52863: PPUSH
52864: CALL_OW 69
52868: ST_TO_ADDR
// if not tmp then
52869: LD_VAR 0 2
52873: NOT
52874: IFFALSE 52878
// exit ;
52876: GO 52928
// for i in tmp do
52878: LD_ADDR_VAR 0 1
52882: PUSH
52883: LD_VAR 0 2
52887: PUSH
52888: FOR_IN
52889: IFFALSE 52926
// if GetCargo ( i , mat_artifact ) = 0 then
52891: LD_VAR 0 1
52895: PPUSH
52896: LD_INT 4
52898: PPUSH
52899: CALL_OW 289
52903: PUSH
52904: LD_INT 0
52906: EQUAL
52907: IFFALSE 52924
// SetCargo ( i , mat_siberit , 100 ) ;
52909: LD_VAR 0 1
52913: PPUSH
52914: LD_INT 3
52916: PPUSH
52917: LD_INT 100
52919: PPUSH
52920: CALL_OW 290
52924: GO 52888
52926: POP
52927: POP
// end ;
52928: PPOPN 2
52930: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
52931: LD_EXP 90
52935: PUSH
52936: LD_EXP 135
52940: AND
52941: IFFALSE 53124
52943: GO 52945
52945: DISABLE
52946: LD_INT 0
52948: PPUSH
52949: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
52950: LD_ADDR_VAR 0 2
52954: PUSH
52955: LD_INT 22
52957: PUSH
52958: LD_OWVAR 2
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: PPUSH
52967: CALL_OW 69
52971: ST_TO_ADDR
// if not tmp then
52972: LD_VAR 0 2
52976: NOT
52977: IFFALSE 52981
// exit ;
52979: GO 53124
// for i := 1 to 2 do
52981: LD_ADDR_VAR 0 1
52985: PUSH
52986: DOUBLE
52987: LD_INT 1
52989: DEC
52990: ST_TO_ADDR
52991: LD_INT 2
52993: PUSH
52994: FOR_TO
52995: IFFALSE 53122
// begin uc_side := your_side ;
52997: LD_ADDR_OWVAR 20
53001: PUSH
53002: LD_OWVAR 2
53006: ST_TO_ADDR
// uc_nation := nation_american ;
53007: LD_ADDR_OWVAR 21
53011: PUSH
53012: LD_INT 1
53014: ST_TO_ADDR
// vc_chassis := us_morphling ;
53015: LD_ADDR_OWVAR 37
53019: PUSH
53020: LD_INT 5
53022: ST_TO_ADDR
// vc_engine := engine_siberite ;
53023: LD_ADDR_OWVAR 39
53027: PUSH
53028: LD_INT 3
53030: ST_TO_ADDR
// vc_control := control_computer ;
53031: LD_ADDR_OWVAR 38
53035: PUSH
53036: LD_INT 3
53038: ST_TO_ADDR
// vc_weapon := us_double_laser ;
53039: LD_ADDR_OWVAR 40
53043: PUSH
53044: LD_INT 10
53046: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
53047: LD_VAR 0 2
53051: PUSH
53052: LD_INT 1
53054: ARRAY
53055: PPUSH
53056: CALL_OW 310
53060: NOT
53061: IFFALSE 53108
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
53063: CALL_OW 45
53067: PPUSH
53068: LD_VAR 0 2
53072: PUSH
53073: LD_INT 1
53075: ARRAY
53076: PPUSH
53077: CALL_OW 250
53081: PPUSH
53082: LD_VAR 0 2
53086: PUSH
53087: LD_INT 1
53089: ARRAY
53090: PPUSH
53091: CALL_OW 251
53095: PPUSH
53096: LD_INT 12
53098: PPUSH
53099: LD_INT 1
53101: PPUSH
53102: CALL_OW 50
53106: GO 53120
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
53108: CALL_OW 45
53112: PPUSH
53113: LD_INT 1
53115: PPUSH
53116: CALL_OW 51
// end ;
53120: GO 52994
53122: POP
53123: POP
// end ;
53124: PPOPN 2
53126: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
53127: LD_EXP 90
53131: PUSH
53132: LD_EXP 136
53136: AND
53137: IFFALSE 53359
53139: GO 53141
53141: DISABLE
53142: LD_INT 0
53144: PPUSH
53145: PPUSH
53146: PPUSH
53147: PPUSH
53148: PPUSH
53149: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
53150: LD_ADDR_VAR 0 6
53154: PUSH
53155: LD_INT 22
53157: PUSH
53158: LD_OWVAR 2
53162: PUSH
53163: EMPTY
53164: LIST
53165: LIST
53166: PUSH
53167: LD_INT 21
53169: PUSH
53170: LD_INT 1
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: PUSH
53177: LD_INT 3
53179: PUSH
53180: LD_INT 23
53182: PUSH
53183: LD_INT 0
53185: PUSH
53186: EMPTY
53187: LIST
53188: LIST
53189: PUSH
53190: EMPTY
53191: LIST
53192: LIST
53193: PUSH
53194: EMPTY
53195: LIST
53196: LIST
53197: LIST
53198: PPUSH
53199: CALL_OW 69
53203: ST_TO_ADDR
// if not tmp then
53204: LD_VAR 0 6
53208: NOT
53209: IFFALSE 53213
// exit ;
53211: GO 53359
// s1 := rand ( 1 , 4 ) ;
53213: LD_ADDR_VAR 0 2
53217: PUSH
53218: LD_INT 1
53220: PPUSH
53221: LD_INT 4
53223: PPUSH
53224: CALL_OW 12
53228: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
53229: LD_ADDR_VAR 0 4
53233: PUSH
53234: LD_VAR 0 6
53238: PUSH
53239: LD_INT 1
53241: ARRAY
53242: PPUSH
53243: LD_VAR 0 2
53247: PPUSH
53248: CALL_OW 259
53252: ST_TO_ADDR
// if s1 = 1 then
53253: LD_VAR 0 2
53257: PUSH
53258: LD_INT 1
53260: EQUAL
53261: IFFALSE 53281
// s2 := rand ( 2 , 4 ) else
53263: LD_ADDR_VAR 0 3
53267: PUSH
53268: LD_INT 2
53270: PPUSH
53271: LD_INT 4
53273: PPUSH
53274: CALL_OW 12
53278: ST_TO_ADDR
53279: GO 53289
// s2 := 1 ;
53281: LD_ADDR_VAR 0 3
53285: PUSH
53286: LD_INT 1
53288: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
53289: LD_ADDR_VAR 0 5
53293: PUSH
53294: LD_VAR 0 6
53298: PUSH
53299: LD_INT 1
53301: ARRAY
53302: PPUSH
53303: LD_VAR 0 3
53307: PPUSH
53308: CALL_OW 259
53312: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
53313: LD_VAR 0 6
53317: PUSH
53318: LD_INT 1
53320: ARRAY
53321: PPUSH
53322: LD_VAR 0 2
53326: PPUSH
53327: LD_VAR 0 5
53331: PPUSH
53332: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
53336: LD_VAR 0 6
53340: PUSH
53341: LD_INT 1
53343: ARRAY
53344: PPUSH
53345: LD_VAR 0 3
53349: PPUSH
53350: LD_VAR 0 4
53354: PPUSH
53355: CALL_OW 237
// end ;
53359: PPOPN 6
53361: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
53362: LD_EXP 90
53366: PUSH
53367: LD_EXP 137
53371: AND
53372: IFFALSE 53451
53374: GO 53376
53376: DISABLE
53377: LD_INT 0
53379: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
53380: LD_ADDR_VAR 0 1
53384: PUSH
53385: LD_INT 22
53387: PUSH
53388: LD_OWVAR 2
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: PUSH
53397: LD_INT 30
53399: PUSH
53400: LD_INT 3
53402: PUSH
53403: EMPTY
53404: LIST
53405: LIST
53406: PUSH
53407: EMPTY
53408: LIST
53409: LIST
53410: PPUSH
53411: CALL_OW 69
53415: ST_TO_ADDR
// if not tmp then
53416: LD_VAR 0 1
53420: NOT
53421: IFFALSE 53425
// exit ;
53423: GO 53451
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
53425: LD_VAR 0 1
53429: PUSH
53430: LD_INT 1
53432: PPUSH
53433: LD_VAR 0 1
53437: PPUSH
53438: CALL_OW 12
53442: ARRAY
53443: PPUSH
53444: LD_INT 1
53446: PPUSH
53447: CALL_OW 234
// end ;
53451: PPOPN 1
53453: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
53454: LD_EXP 90
53458: PUSH
53459: LD_EXP 138
53463: AND
53464: IFFALSE 53576
53466: GO 53468
53468: DISABLE
53469: LD_INT 0
53471: PPUSH
53472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
53473: LD_ADDR_VAR 0 2
53477: PUSH
53478: LD_INT 22
53480: PUSH
53481: LD_OWVAR 2
53485: PUSH
53486: EMPTY
53487: LIST
53488: LIST
53489: PUSH
53490: LD_INT 2
53492: PUSH
53493: LD_INT 30
53495: PUSH
53496: LD_INT 27
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: PUSH
53503: LD_INT 30
53505: PUSH
53506: LD_INT 26
53508: PUSH
53509: EMPTY
53510: LIST
53511: LIST
53512: PUSH
53513: LD_INT 30
53515: PUSH
53516: LD_INT 28
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: PUSH
53523: EMPTY
53524: LIST
53525: LIST
53526: LIST
53527: LIST
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: PPUSH
53533: CALL_OW 69
53537: ST_TO_ADDR
// if not tmp then
53538: LD_VAR 0 2
53542: NOT
53543: IFFALSE 53547
// exit ;
53545: GO 53576
// for i in tmp do
53547: LD_ADDR_VAR 0 1
53551: PUSH
53552: LD_VAR 0 2
53556: PUSH
53557: FOR_IN
53558: IFFALSE 53574
// SetLives ( i , 1 ) ;
53560: LD_VAR 0 1
53564: PPUSH
53565: LD_INT 1
53567: PPUSH
53568: CALL_OW 234
53572: GO 53557
53574: POP
53575: POP
// end ;
53576: PPOPN 2
53578: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
53579: LD_EXP 90
53583: PUSH
53584: LD_EXP 139
53588: AND
53589: IFFALSE 53863
53591: GO 53593
53593: DISABLE
53594: LD_INT 0
53596: PPUSH
53597: PPUSH
53598: PPUSH
// begin i := rand ( 1 , 7 ) ;
53599: LD_ADDR_VAR 0 1
53603: PUSH
53604: LD_INT 1
53606: PPUSH
53607: LD_INT 7
53609: PPUSH
53610: CALL_OW 12
53614: ST_TO_ADDR
// case i of 1 :
53615: LD_VAR 0 1
53619: PUSH
53620: LD_INT 1
53622: DOUBLE
53623: EQUAL
53624: IFTRUE 53628
53626: GO 53638
53628: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
53629: LD_STRING earthquake(getX(game), 0, 32)
53631: PPUSH
53632: CALL_OW 559
53636: GO 53863
53638: LD_INT 2
53640: DOUBLE
53641: EQUAL
53642: IFTRUE 53646
53644: GO 53660
53646: POP
// begin ToLua ( displayStucuk(); ) ;
53647: LD_STRING displayStucuk();
53649: PPUSH
53650: CALL_OW 559
// ResetFog ;
53654: CALL_OW 335
// end ; 3 :
53658: GO 53863
53660: LD_INT 3
53662: DOUBLE
53663: EQUAL
53664: IFTRUE 53668
53666: GO 53772
53668: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
53669: LD_ADDR_VAR 0 2
53673: PUSH
53674: LD_INT 22
53676: PUSH
53677: LD_OWVAR 2
53681: PUSH
53682: EMPTY
53683: LIST
53684: LIST
53685: PUSH
53686: LD_INT 25
53688: PUSH
53689: LD_INT 1
53691: PUSH
53692: EMPTY
53693: LIST
53694: LIST
53695: PUSH
53696: EMPTY
53697: LIST
53698: LIST
53699: PPUSH
53700: CALL_OW 69
53704: ST_TO_ADDR
// if not tmp then
53705: LD_VAR 0 2
53709: NOT
53710: IFFALSE 53714
// exit ;
53712: GO 53863
// un := tmp [ rand ( 1 , tmp ) ] ;
53714: LD_ADDR_VAR 0 3
53718: PUSH
53719: LD_VAR 0 2
53723: PUSH
53724: LD_INT 1
53726: PPUSH
53727: LD_VAR 0 2
53731: PPUSH
53732: CALL_OW 12
53736: ARRAY
53737: ST_TO_ADDR
// if Crawls ( un ) then
53738: LD_VAR 0 3
53742: PPUSH
53743: CALL_OW 318
53747: IFFALSE 53758
// ComWalk ( un ) ;
53749: LD_VAR 0 3
53753: PPUSH
53754: CALL_OW 138
// SetClass ( un , class_mortar ) ;
53758: LD_VAR 0 3
53762: PPUSH
53763: LD_INT 8
53765: PPUSH
53766: CALL_OW 336
// end ; 4 :
53770: GO 53863
53772: LD_INT 4
53774: DOUBLE
53775: EQUAL
53776: IFTRUE 53780
53778: GO 53841
53780: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
53781: LD_ADDR_VAR 0 2
53785: PUSH
53786: LD_INT 22
53788: PUSH
53789: LD_OWVAR 2
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: PUSH
53798: LD_INT 30
53800: PUSH
53801: LD_INT 29
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: PUSH
53808: EMPTY
53809: LIST
53810: LIST
53811: PPUSH
53812: CALL_OW 69
53816: ST_TO_ADDR
// if not tmp then
53817: LD_VAR 0 2
53821: NOT
53822: IFFALSE 53826
// exit ;
53824: GO 53863
// DestroyUnit ( tmp [ 1 ] ) ;
53826: LD_VAR 0 2
53830: PUSH
53831: LD_INT 1
53833: ARRAY
53834: PPUSH
53835: CALL_OW 65
// end ; 5 .. 7 :
53839: GO 53863
53841: LD_INT 5
53843: DOUBLE
53844: GREATEREQUAL
53845: IFFALSE 53853
53847: LD_INT 7
53849: DOUBLE
53850: LESSEQUAL
53851: IFTRUE 53855
53853: GO 53862
53855: POP
// StreamSibBomb ; end ;
53856: CALL 50113 0 0
53860: GO 53863
53862: POP
// end ;
53863: PPOPN 3
53865: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
53866: LD_EXP 90
53870: PUSH
53871: LD_EXP 140
53875: AND
53876: IFFALSE 54032
53878: GO 53880
53880: DISABLE
53881: LD_INT 0
53883: PPUSH
53884: PPUSH
53885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
53886: LD_ADDR_VAR 0 2
53890: PUSH
53891: LD_INT 81
53893: PUSH
53894: LD_OWVAR 2
53898: PUSH
53899: EMPTY
53900: LIST
53901: LIST
53902: PUSH
53903: LD_INT 2
53905: PUSH
53906: LD_INT 21
53908: PUSH
53909: LD_INT 1
53911: PUSH
53912: EMPTY
53913: LIST
53914: LIST
53915: PUSH
53916: LD_INT 21
53918: PUSH
53919: LD_INT 2
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: EMPTY
53932: LIST
53933: LIST
53934: PPUSH
53935: CALL_OW 69
53939: ST_TO_ADDR
// if not tmp then
53940: LD_VAR 0 2
53944: NOT
53945: IFFALSE 53949
// exit ;
53947: GO 54032
// p := 0 ;
53949: LD_ADDR_VAR 0 3
53953: PUSH
53954: LD_INT 0
53956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53957: LD_INT 35
53959: PPUSH
53960: CALL_OW 67
// p := p + 1 ;
53964: LD_ADDR_VAR 0 3
53968: PUSH
53969: LD_VAR 0 3
53973: PUSH
53974: LD_INT 1
53976: PLUS
53977: ST_TO_ADDR
// for i in tmp do
53978: LD_ADDR_VAR 0 1
53982: PUSH
53983: LD_VAR 0 2
53987: PUSH
53988: FOR_IN
53989: IFFALSE 54020
// if GetLives ( i ) < 1000 then
53991: LD_VAR 0 1
53995: PPUSH
53996: CALL_OW 256
54000: PUSH
54001: LD_INT 1000
54003: LESS
54004: IFFALSE 54018
// SetLives ( i , 1000 ) ;
54006: LD_VAR 0 1
54010: PPUSH
54011: LD_INT 1000
54013: PPUSH
54014: CALL_OW 234
54018: GO 53988
54020: POP
54021: POP
// until p > 20 ;
54022: LD_VAR 0 3
54026: PUSH
54027: LD_INT 20
54029: GREATER
54030: IFFALSE 53957
// end ;
54032: PPOPN 3
54034: END
// every 0 0$1 trigger StreamModeActive and sTime do
54035: LD_EXP 90
54039: PUSH
54040: LD_EXP 141
54044: AND
54045: IFFALSE 54080
54047: GO 54049
54049: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
54050: LD_INT 28
54052: PPUSH
54053: LD_OWVAR 2
54057: PPUSH
54058: LD_INT 2
54060: PPUSH
54061: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
54065: LD_INT 30
54067: PPUSH
54068: LD_OWVAR 2
54072: PPUSH
54073: LD_INT 2
54075: PPUSH
54076: CALL_OW 322
// end ;
54080: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
54081: LD_EXP 90
54085: PUSH
54086: LD_EXP 142
54090: AND
54091: IFFALSE 54212
54093: GO 54095
54095: DISABLE
54096: LD_INT 0
54098: PPUSH
54099: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
54100: LD_ADDR_VAR 0 2
54104: PUSH
54105: LD_INT 22
54107: PUSH
54108: LD_OWVAR 2
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: LD_INT 21
54119: PUSH
54120: LD_INT 1
54122: PUSH
54123: EMPTY
54124: LIST
54125: LIST
54126: PUSH
54127: LD_INT 3
54129: PUSH
54130: LD_INT 23
54132: PUSH
54133: LD_INT 0
54135: PUSH
54136: EMPTY
54137: LIST
54138: LIST
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: PUSH
54144: EMPTY
54145: LIST
54146: LIST
54147: LIST
54148: PPUSH
54149: CALL_OW 69
54153: ST_TO_ADDR
// if not tmp then
54154: LD_VAR 0 2
54158: NOT
54159: IFFALSE 54163
// exit ;
54161: GO 54212
// for i in tmp do
54163: LD_ADDR_VAR 0 1
54167: PUSH
54168: LD_VAR 0 2
54172: PUSH
54173: FOR_IN
54174: IFFALSE 54210
// begin if Crawls ( i ) then
54176: LD_VAR 0 1
54180: PPUSH
54181: CALL_OW 318
54185: IFFALSE 54196
// ComWalk ( i ) ;
54187: LD_VAR 0 1
54191: PPUSH
54192: CALL_OW 138
// SetClass ( i , 2 ) ;
54196: LD_VAR 0 1
54200: PPUSH
54201: LD_INT 2
54203: PPUSH
54204: CALL_OW 336
// end ;
54208: GO 54173
54210: POP
54211: POP
// end ;
54212: PPOPN 2
54214: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
54215: LD_EXP 90
54219: PUSH
54220: LD_EXP 143
54224: AND
54225: IFFALSE 54506
54227: GO 54229
54229: DISABLE
54230: LD_INT 0
54232: PPUSH
54233: PPUSH
54234: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
54235: LD_OWVAR 2
54239: PPUSH
54240: LD_INT 9
54242: PPUSH
54243: LD_INT 1
54245: PPUSH
54246: LD_INT 1
54248: PPUSH
54249: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
54253: LD_INT 9
54255: PPUSH
54256: LD_OWVAR 2
54260: PPUSH
54261: CALL_OW 343
// uc_side := 9 ;
54265: LD_ADDR_OWVAR 20
54269: PUSH
54270: LD_INT 9
54272: ST_TO_ADDR
// uc_nation := 2 ;
54273: LD_ADDR_OWVAR 21
54277: PUSH
54278: LD_INT 2
54280: ST_TO_ADDR
// hc_name := Dark Warrior ;
54281: LD_ADDR_OWVAR 26
54285: PUSH
54286: LD_STRING Dark Warrior
54288: ST_TO_ADDR
// hc_gallery :=  ;
54289: LD_ADDR_OWVAR 33
54293: PUSH
54294: LD_STRING 
54296: ST_TO_ADDR
// hc_noskilllimit := true ;
54297: LD_ADDR_OWVAR 76
54301: PUSH
54302: LD_INT 1
54304: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
54305: LD_ADDR_OWVAR 31
54309: PUSH
54310: LD_INT 30
54312: PUSH
54313: LD_INT 30
54315: PUSH
54316: LD_INT 30
54318: PUSH
54319: LD_INT 30
54321: PUSH
54322: EMPTY
54323: LIST
54324: LIST
54325: LIST
54326: LIST
54327: ST_TO_ADDR
// un := CreateHuman ;
54328: LD_ADDR_VAR 0 3
54332: PUSH
54333: CALL_OW 44
54337: ST_TO_ADDR
// hc_noskilllimit := false ;
54338: LD_ADDR_OWVAR 76
54342: PUSH
54343: LD_INT 0
54345: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
54346: LD_VAR 0 3
54350: PPUSH
54351: LD_INT 1
54353: PPUSH
54354: CALL_OW 51
// p := 0 ;
54358: LD_ADDR_VAR 0 2
54362: PUSH
54363: LD_INT 0
54365: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54366: LD_INT 35
54368: PPUSH
54369: CALL_OW 67
// p := p + 1 ;
54373: LD_ADDR_VAR 0 2
54377: PUSH
54378: LD_VAR 0 2
54382: PUSH
54383: LD_INT 1
54385: PLUS
54386: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
54387: LD_VAR 0 3
54391: PPUSH
54392: CALL_OW 256
54396: PUSH
54397: LD_INT 1000
54399: LESS
54400: IFFALSE 54414
// SetLives ( un , 1000 ) ;
54402: LD_VAR 0 3
54406: PPUSH
54407: LD_INT 1000
54409: PPUSH
54410: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
54414: LD_VAR 0 3
54418: PPUSH
54419: LD_INT 81
54421: PUSH
54422: LD_OWVAR 2
54426: PUSH
54427: EMPTY
54428: LIST
54429: LIST
54430: PUSH
54431: LD_INT 91
54433: PUSH
54434: LD_VAR 0 3
54438: PUSH
54439: LD_INT 30
54441: PUSH
54442: EMPTY
54443: LIST
54444: LIST
54445: LIST
54446: PUSH
54447: EMPTY
54448: LIST
54449: LIST
54450: PPUSH
54451: CALL_OW 69
54455: PPUSH
54456: LD_VAR 0 3
54460: PPUSH
54461: CALL_OW 74
54465: PPUSH
54466: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
54470: LD_VAR 0 2
54474: PUSH
54475: LD_INT 60
54477: GREATER
54478: PUSH
54479: LD_VAR 0 3
54483: PPUSH
54484: CALL_OW 301
54488: OR
54489: IFFALSE 54366
// if un then
54491: LD_VAR 0 3
54495: IFFALSE 54506
// RemoveUnit ( un ) ;
54497: LD_VAR 0 3
54501: PPUSH
54502: CALL_OW 64
// end ;
54506: PPOPN 3
54508: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
54509: LD_INT 0
54511: PPUSH
// case cmd of 301 :
54512: LD_VAR 0 1
54516: PUSH
54517: LD_INT 301
54519: DOUBLE
54520: EQUAL
54521: IFTRUE 54525
54523: GO 54557
54525: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
54526: LD_VAR 0 6
54530: PPUSH
54531: LD_VAR 0 7
54535: PPUSH
54536: LD_VAR 0 8
54540: PPUSH
54541: LD_VAR 0 4
54545: PPUSH
54546: LD_VAR 0 5
54550: PPUSH
54551: CALL 55758 0 5
54555: GO 54678
54557: LD_INT 302
54559: DOUBLE
54560: EQUAL
54561: IFTRUE 54565
54563: GO 54602
54565: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
54566: LD_VAR 0 6
54570: PPUSH
54571: LD_VAR 0 7
54575: PPUSH
54576: LD_VAR 0 8
54580: PPUSH
54581: LD_VAR 0 9
54585: PPUSH
54586: LD_VAR 0 4
54590: PPUSH
54591: LD_VAR 0 5
54595: PPUSH
54596: CALL 55849 0 6
54600: GO 54678
54602: LD_INT 303
54604: DOUBLE
54605: EQUAL
54606: IFTRUE 54610
54608: GO 54647
54610: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
54611: LD_VAR 0 6
54615: PPUSH
54616: LD_VAR 0 7
54620: PPUSH
54621: LD_VAR 0 8
54625: PPUSH
54626: LD_VAR 0 9
54630: PPUSH
54631: LD_VAR 0 4
54635: PPUSH
54636: LD_VAR 0 5
54640: PPUSH
54641: CALL 54683 0 6
54645: GO 54678
54647: LD_INT 304
54649: DOUBLE
54650: EQUAL
54651: IFTRUE 54655
54653: GO 54677
54655: POP
// hHackTeleport ( unit , x , y ) ; end ;
54656: LD_VAR 0 2
54660: PPUSH
54661: LD_VAR 0 4
54665: PPUSH
54666: LD_VAR 0 5
54670: PPUSH
54671: CALL 56442 0 3
54675: GO 54678
54677: POP
// end ;
54678: LD_VAR 0 12
54682: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
54683: LD_INT 0
54685: PPUSH
54686: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
54687: LD_VAR 0 1
54691: PUSH
54692: LD_INT 1
54694: LESS
54695: PUSH
54696: LD_VAR 0 1
54700: PUSH
54701: LD_INT 3
54703: GREATER
54704: OR
54705: PUSH
54706: LD_VAR 0 5
54710: PPUSH
54711: LD_VAR 0 6
54715: PPUSH
54716: CALL_OW 428
54720: OR
54721: IFFALSE 54725
// exit ;
54723: GO 55445
// uc_side := your_side ;
54725: LD_ADDR_OWVAR 20
54729: PUSH
54730: LD_OWVAR 2
54734: ST_TO_ADDR
// uc_nation := nation ;
54735: LD_ADDR_OWVAR 21
54739: PUSH
54740: LD_VAR 0 1
54744: ST_TO_ADDR
// bc_level = 1 ;
54745: LD_ADDR_OWVAR 43
54749: PUSH
54750: LD_INT 1
54752: ST_TO_ADDR
// case btype of 1 :
54753: LD_VAR 0 2
54757: PUSH
54758: LD_INT 1
54760: DOUBLE
54761: EQUAL
54762: IFTRUE 54766
54764: GO 54777
54766: POP
// bc_type := b_depot ; 2 :
54767: LD_ADDR_OWVAR 42
54771: PUSH
54772: LD_INT 0
54774: ST_TO_ADDR
54775: GO 55389
54777: LD_INT 2
54779: DOUBLE
54780: EQUAL
54781: IFTRUE 54785
54783: GO 54796
54785: POP
// bc_type := b_warehouse ; 3 :
54786: LD_ADDR_OWVAR 42
54790: PUSH
54791: LD_INT 1
54793: ST_TO_ADDR
54794: GO 55389
54796: LD_INT 3
54798: DOUBLE
54799: EQUAL
54800: IFTRUE 54804
54802: GO 54815
54804: POP
// bc_type := b_lab ; 4 .. 9 :
54805: LD_ADDR_OWVAR 42
54809: PUSH
54810: LD_INT 6
54812: ST_TO_ADDR
54813: GO 55389
54815: LD_INT 4
54817: DOUBLE
54818: GREATEREQUAL
54819: IFFALSE 54827
54821: LD_INT 9
54823: DOUBLE
54824: LESSEQUAL
54825: IFTRUE 54829
54827: GO 54881
54829: POP
// begin bc_type := b_lab_half ;
54830: LD_ADDR_OWVAR 42
54834: PUSH
54835: LD_INT 7
54837: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
54838: LD_ADDR_OWVAR 44
54842: PUSH
54843: LD_INT 10
54845: PUSH
54846: LD_INT 11
54848: PUSH
54849: LD_INT 12
54851: PUSH
54852: LD_INT 15
54854: PUSH
54855: LD_INT 14
54857: PUSH
54858: LD_INT 13
54860: PUSH
54861: EMPTY
54862: LIST
54863: LIST
54864: LIST
54865: LIST
54866: LIST
54867: LIST
54868: PUSH
54869: LD_VAR 0 2
54873: PUSH
54874: LD_INT 3
54876: MINUS
54877: ARRAY
54878: ST_TO_ADDR
// end ; 10 .. 13 :
54879: GO 55389
54881: LD_INT 10
54883: DOUBLE
54884: GREATEREQUAL
54885: IFFALSE 54893
54887: LD_INT 13
54889: DOUBLE
54890: LESSEQUAL
54891: IFTRUE 54895
54893: GO 54972
54895: POP
// begin bc_type := b_lab_full ;
54896: LD_ADDR_OWVAR 42
54900: PUSH
54901: LD_INT 8
54903: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
54904: LD_ADDR_OWVAR 44
54908: PUSH
54909: LD_INT 10
54911: PUSH
54912: LD_INT 12
54914: PUSH
54915: LD_INT 14
54917: PUSH
54918: LD_INT 13
54920: PUSH
54921: EMPTY
54922: LIST
54923: LIST
54924: LIST
54925: LIST
54926: PUSH
54927: LD_VAR 0 2
54931: PUSH
54932: LD_INT 9
54934: MINUS
54935: ARRAY
54936: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
54937: LD_ADDR_OWVAR 45
54941: PUSH
54942: LD_INT 11
54944: PUSH
54945: LD_INT 15
54947: PUSH
54948: LD_INT 12
54950: PUSH
54951: LD_INT 15
54953: PUSH
54954: EMPTY
54955: LIST
54956: LIST
54957: LIST
54958: LIST
54959: PUSH
54960: LD_VAR 0 2
54964: PUSH
54965: LD_INT 9
54967: MINUS
54968: ARRAY
54969: ST_TO_ADDR
// end ; 14 :
54970: GO 55389
54972: LD_INT 14
54974: DOUBLE
54975: EQUAL
54976: IFTRUE 54980
54978: GO 54991
54980: POP
// bc_type := b_workshop ; 15 :
54981: LD_ADDR_OWVAR 42
54985: PUSH
54986: LD_INT 2
54988: ST_TO_ADDR
54989: GO 55389
54991: LD_INT 15
54993: DOUBLE
54994: EQUAL
54995: IFTRUE 54999
54997: GO 55010
54999: POP
// bc_type := b_factory ; 16 :
55000: LD_ADDR_OWVAR 42
55004: PUSH
55005: LD_INT 3
55007: ST_TO_ADDR
55008: GO 55389
55010: LD_INT 16
55012: DOUBLE
55013: EQUAL
55014: IFTRUE 55018
55016: GO 55029
55018: POP
// bc_type := b_ext_gun ; 17 :
55019: LD_ADDR_OWVAR 42
55023: PUSH
55024: LD_INT 17
55026: ST_TO_ADDR
55027: GO 55389
55029: LD_INT 17
55031: DOUBLE
55032: EQUAL
55033: IFTRUE 55037
55035: GO 55065
55037: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
55038: LD_ADDR_OWVAR 42
55042: PUSH
55043: LD_INT 19
55045: PUSH
55046: LD_INT 23
55048: PUSH
55049: LD_INT 19
55051: PUSH
55052: EMPTY
55053: LIST
55054: LIST
55055: LIST
55056: PUSH
55057: LD_VAR 0 1
55061: ARRAY
55062: ST_TO_ADDR
55063: GO 55389
55065: LD_INT 18
55067: DOUBLE
55068: EQUAL
55069: IFTRUE 55073
55071: GO 55084
55073: POP
// bc_type := b_ext_radar ; 19 :
55074: LD_ADDR_OWVAR 42
55078: PUSH
55079: LD_INT 20
55081: ST_TO_ADDR
55082: GO 55389
55084: LD_INT 19
55086: DOUBLE
55087: EQUAL
55088: IFTRUE 55092
55090: GO 55103
55092: POP
// bc_type := b_ext_radio ; 20 :
55093: LD_ADDR_OWVAR 42
55097: PUSH
55098: LD_INT 22
55100: ST_TO_ADDR
55101: GO 55389
55103: LD_INT 20
55105: DOUBLE
55106: EQUAL
55107: IFTRUE 55111
55109: GO 55122
55111: POP
// bc_type := b_ext_siberium ; 21 :
55112: LD_ADDR_OWVAR 42
55116: PUSH
55117: LD_INT 21
55119: ST_TO_ADDR
55120: GO 55389
55122: LD_INT 21
55124: DOUBLE
55125: EQUAL
55126: IFTRUE 55130
55128: GO 55141
55130: POP
// bc_type := b_ext_computer ; 22 :
55131: LD_ADDR_OWVAR 42
55135: PUSH
55136: LD_INT 24
55138: ST_TO_ADDR
55139: GO 55389
55141: LD_INT 22
55143: DOUBLE
55144: EQUAL
55145: IFTRUE 55149
55147: GO 55160
55149: POP
// bc_type := b_ext_track ; 23 :
55150: LD_ADDR_OWVAR 42
55154: PUSH
55155: LD_INT 16
55157: ST_TO_ADDR
55158: GO 55389
55160: LD_INT 23
55162: DOUBLE
55163: EQUAL
55164: IFTRUE 55168
55166: GO 55179
55168: POP
// bc_type := b_ext_laser ; 24 :
55169: LD_ADDR_OWVAR 42
55173: PUSH
55174: LD_INT 25
55176: ST_TO_ADDR
55177: GO 55389
55179: LD_INT 24
55181: DOUBLE
55182: EQUAL
55183: IFTRUE 55187
55185: GO 55198
55187: POP
// bc_type := b_control_tower ; 25 :
55188: LD_ADDR_OWVAR 42
55192: PUSH
55193: LD_INT 36
55195: ST_TO_ADDR
55196: GO 55389
55198: LD_INT 25
55200: DOUBLE
55201: EQUAL
55202: IFTRUE 55206
55204: GO 55217
55206: POP
// bc_type := b_breastwork ; 26 :
55207: LD_ADDR_OWVAR 42
55211: PUSH
55212: LD_INT 31
55214: ST_TO_ADDR
55215: GO 55389
55217: LD_INT 26
55219: DOUBLE
55220: EQUAL
55221: IFTRUE 55225
55223: GO 55236
55225: POP
// bc_type := b_bunker ; 27 :
55226: LD_ADDR_OWVAR 42
55230: PUSH
55231: LD_INT 32
55233: ST_TO_ADDR
55234: GO 55389
55236: LD_INT 27
55238: DOUBLE
55239: EQUAL
55240: IFTRUE 55244
55242: GO 55255
55244: POP
// bc_type := b_turret ; 28 :
55245: LD_ADDR_OWVAR 42
55249: PUSH
55250: LD_INT 33
55252: ST_TO_ADDR
55253: GO 55389
55255: LD_INT 28
55257: DOUBLE
55258: EQUAL
55259: IFTRUE 55263
55261: GO 55274
55263: POP
// bc_type := b_armoury ; 29 :
55264: LD_ADDR_OWVAR 42
55268: PUSH
55269: LD_INT 4
55271: ST_TO_ADDR
55272: GO 55389
55274: LD_INT 29
55276: DOUBLE
55277: EQUAL
55278: IFTRUE 55282
55280: GO 55293
55282: POP
// bc_type := b_barracks ; 30 :
55283: LD_ADDR_OWVAR 42
55287: PUSH
55288: LD_INT 5
55290: ST_TO_ADDR
55291: GO 55389
55293: LD_INT 30
55295: DOUBLE
55296: EQUAL
55297: IFTRUE 55301
55299: GO 55312
55301: POP
// bc_type := b_solar_power ; 31 :
55302: LD_ADDR_OWVAR 42
55306: PUSH
55307: LD_INT 27
55309: ST_TO_ADDR
55310: GO 55389
55312: LD_INT 31
55314: DOUBLE
55315: EQUAL
55316: IFTRUE 55320
55318: GO 55331
55320: POP
// bc_type := b_oil_power ; 32 :
55321: LD_ADDR_OWVAR 42
55325: PUSH
55326: LD_INT 26
55328: ST_TO_ADDR
55329: GO 55389
55331: LD_INT 32
55333: DOUBLE
55334: EQUAL
55335: IFTRUE 55339
55337: GO 55350
55339: POP
// bc_type := b_siberite_power ; 33 :
55340: LD_ADDR_OWVAR 42
55344: PUSH
55345: LD_INT 28
55347: ST_TO_ADDR
55348: GO 55389
55350: LD_INT 33
55352: DOUBLE
55353: EQUAL
55354: IFTRUE 55358
55356: GO 55369
55358: POP
// bc_type := b_oil_mine ; 34 :
55359: LD_ADDR_OWVAR 42
55363: PUSH
55364: LD_INT 29
55366: ST_TO_ADDR
55367: GO 55389
55369: LD_INT 34
55371: DOUBLE
55372: EQUAL
55373: IFTRUE 55377
55375: GO 55388
55377: POP
// bc_type := b_siberite_mine ; end ;
55378: LD_ADDR_OWVAR 42
55382: PUSH
55383: LD_INT 30
55385: ST_TO_ADDR
55386: GO 55389
55388: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
55389: LD_ADDR_VAR 0 8
55393: PUSH
55394: LD_VAR 0 5
55398: PPUSH
55399: LD_VAR 0 6
55403: PPUSH
55404: LD_VAR 0 3
55408: PPUSH
55409: CALL_OW 47
55413: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
55414: LD_OWVAR 42
55418: PUSH
55419: LD_INT 32
55421: PUSH
55422: LD_INT 33
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: IN
55429: IFFALSE 55445
// PlaceWeaponTurret ( b , weapon ) ;
55431: LD_VAR 0 8
55435: PPUSH
55436: LD_VAR 0 4
55440: PPUSH
55441: CALL_OW 431
// end ;
55445: LD_VAR 0 7
55449: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
55450: LD_INT 0
55452: PPUSH
55453: PPUSH
55454: PPUSH
55455: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
55456: LD_ADDR_VAR 0 4
55460: PUSH
55461: LD_INT 22
55463: PUSH
55464: LD_OWVAR 2
55468: PUSH
55469: EMPTY
55470: LIST
55471: LIST
55472: PUSH
55473: LD_INT 2
55475: PUSH
55476: LD_INT 30
55478: PUSH
55479: LD_INT 0
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: PUSH
55486: LD_INT 30
55488: PUSH
55489: LD_INT 1
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: LIST
55500: PUSH
55501: EMPTY
55502: LIST
55503: LIST
55504: PPUSH
55505: CALL_OW 69
55509: ST_TO_ADDR
// if not tmp then
55510: LD_VAR 0 4
55514: NOT
55515: IFFALSE 55519
// exit ;
55517: GO 55578
// for i in tmp do
55519: LD_ADDR_VAR 0 2
55523: PUSH
55524: LD_VAR 0 4
55528: PUSH
55529: FOR_IN
55530: IFFALSE 55576
// for j = 1 to 3 do
55532: LD_ADDR_VAR 0 3
55536: PUSH
55537: DOUBLE
55538: LD_INT 1
55540: DEC
55541: ST_TO_ADDR
55542: LD_INT 3
55544: PUSH
55545: FOR_TO
55546: IFFALSE 55572
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
55548: LD_VAR 0 2
55552: PPUSH
55553: CALL_OW 274
55557: PPUSH
55558: LD_VAR 0 3
55562: PPUSH
55563: LD_INT 99999
55565: PPUSH
55566: CALL_OW 277
55570: GO 55545
55572: POP
55573: POP
55574: GO 55529
55576: POP
55577: POP
// end ;
55578: LD_VAR 0 1
55582: RET
// export function hHackSetLevel10 ; var i , j ; begin
55583: LD_INT 0
55585: PPUSH
55586: PPUSH
55587: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
55588: LD_ADDR_VAR 0 2
55592: PUSH
55593: LD_INT 21
55595: PUSH
55596: LD_INT 1
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: PPUSH
55603: CALL_OW 69
55607: PUSH
55608: FOR_IN
55609: IFFALSE 55661
// if IsSelected ( i ) then
55611: LD_VAR 0 2
55615: PPUSH
55616: CALL_OW 306
55620: IFFALSE 55659
// begin for j := 1 to 4 do
55622: LD_ADDR_VAR 0 3
55626: PUSH
55627: DOUBLE
55628: LD_INT 1
55630: DEC
55631: ST_TO_ADDR
55632: LD_INT 4
55634: PUSH
55635: FOR_TO
55636: IFFALSE 55657
// SetSkill ( i , j , 10 ) ;
55638: LD_VAR 0 2
55642: PPUSH
55643: LD_VAR 0 3
55647: PPUSH
55648: LD_INT 10
55650: PPUSH
55651: CALL_OW 237
55655: GO 55635
55657: POP
55658: POP
// end ;
55659: GO 55608
55661: POP
55662: POP
// end ;
55663: LD_VAR 0 1
55667: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
55668: LD_INT 0
55670: PPUSH
55671: PPUSH
55672: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
55673: LD_ADDR_VAR 0 2
55677: PUSH
55678: LD_INT 22
55680: PUSH
55681: LD_OWVAR 2
55685: PUSH
55686: EMPTY
55687: LIST
55688: LIST
55689: PUSH
55690: LD_INT 21
55692: PUSH
55693: LD_INT 1
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PUSH
55700: EMPTY
55701: LIST
55702: LIST
55703: PPUSH
55704: CALL_OW 69
55708: PUSH
55709: FOR_IN
55710: IFFALSE 55751
// begin for j := 1 to 4 do
55712: LD_ADDR_VAR 0 3
55716: PUSH
55717: DOUBLE
55718: LD_INT 1
55720: DEC
55721: ST_TO_ADDR
55722: LD_INT 4
55724: PUSH
55725: FOR_TO
55726: IFFALSE 55747
// SetSkill ( i , j , 10 ) ;
55728: LD_VAR 0 2
55732: PPUSH
55733: LD_VAR 0 3
55737: PPUSH
55738: LD_INT 10
55740: PPUSH
55741: CALL_OW 237
55745: GO 55725
55747: POP
55748: POP
// end ;
55749: GO 55709
55751: POP
55752: POP
// end ;
55753: LD_VAR 0 1
55757: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
55758: LD_INT 0
55760: PPUSH
// uc_side := your_side ;
55761: LD_ADDR_OWVAR 20
55765: PUSH
55766: LD_OWVAR 2
55770: ST_TO_ADDR
// uc_nation := nation ;
55771: LD_ADDR_OWVAR 21
55775: PUSH
55776: LD_VAR 0 1
55780: ST_TO_ADDR
// InitHc ;
55781: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
55785: LD_INT 0
55787: PPUSH
55788: LD_VAR 0 2
55792: PPUSH
55793: LD_VAR 0 3
55797: PPUSH
55798: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
55802: LD_VAR 0 4
55806: PPUSH
55807: LD_VAR 0 5
55811: PPUSH
55812: CALL_OW 428
55816: PUSH
55817: LD_INT 0
55819: EQUAL
55820: IFFALSE 55844
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
55822: CALL_OW 44
55826: PPUSH
55827: LD_VAR 0 4
55831: PPUSH
55832: LD_VAR 0 5
55836: PPUSH
55837: LD_INT 1
55839: PPUSH
55840: CALL_OW 48
// end ;
55844: LD_VAR 0 6
55848: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
55849: LD_INT 0
55851: PPUSH
55852: PPUSH
// uc_side := your_side ;
55853: LD_ADDR_OWVAR 20
55857: PUSH
55858: LD_OWVAR 2
55862: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
55863: LD_VAR 0 1
55867: PUSH
55868: LD_INT 1
55870: PUSH
55871: LD_INT 2
55873: PUSH
55874: LD_INT 3
55876: PUSH
55877: LD_INT 4
55879: PUSH
55880: LD_INT 5
55882: PUSH
55883: EMPTY
55884: LIST
55885: LIST
55886: LIST
55887: LIST
55888: LIST
55889: IN
55890: IFFALSE 55902
// uc_nation := nation_american else
55892: LD_ADDR_OWVAR 21
55896: PUSH
55897: LD_INT 1
55899: ST_TO_ADDR
55900: GO 55945
// if chassis in [ 11 , 12 , 13 , 14 ] then
55902: LD_VAR 0 1
55906: PUSH
55907: LD_INT 11
55909: PUSH
55910: LD_INT 12
55912: PUSH
55913: LD_INT 13
55915: PUSH
55916: LD_INT 14
55918: PUSH
55919: EMPTY
55920: LIST
55921: LIST
55922: LIST
55923: LIST
55924: IN
55925: IFFALSE 55937
// uc_nation := nation_arabian else
55927: LD_ADDR_OWVAR 21
55931: PUSH
55932: LD_INT 2
55934: ST_TO_ADDR
55935: GO 55945
// uc_nation := nation_russian ;
55937: LD_ADDR_OWVAR 21
55941: PUSH
55942: LD_INT 3
55944: ST_TO_ADDR
// vc_chassis := chassis ;
55945: LD_ADDR_OWVAR 37
55949: PUSH
55950: LD_VAR 0 1
55954: ST_TO_ADDR
// vc_engine := engine ;
55955: LD_ADDR_OWVAR 39
55959: PUSH
55960: LD_VAR 0 2
55964: ST_TO_ADDR
// vc_control := control ;
55965: LD_ADDR_OWVAR 38
55969: PUSH
55970: LD_VAR 0 3
55974: ST_TO_ADDR
// vc_weapon := weapon ;
55975: LD_ADDR_OWVAR 40
55979: PUSH
55980: LD_VAR 0 4
55984: ST_TO_ADDR
// un := CreateVehicle ;
55985: LD_ADDR_VAR 0 8
55989: PUSH
55990: CALL_OW 45
55994: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
55995: LD_VAR 0 8
55999: PPUSH
56000: LD_INT 0
56002: PPUSH
56003: LD_INT 5
56005: PPUSH
56006: CALL_OW 12
56010: PPUSH
56011: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
56015: LD_VAR 0 8
56019: PPUSH
56020: LD_VAR 0 5
56024: PPUSH
56025: LD_VAR 0 6
56029: PPUSH
56030: LD_INT 1
56032: PPUSH
56033: CALL_OW 48
// end ;
56037: LD_VAR 0 7
56041: RET
// export hInvincible ; every 1 do
56042: GO 56044
56044: DISABLE
// hInvincible := [ ] ;
56045: LD_ADDR_EXP 144
56049: PUSH
56050: EMPTY
56051: ST_TO_ADDR
56052: END
// every 10 do var i ;
56053: GO 56055
56055: DISABLE
56056: LD_INT 0
56058: PPUSH
// begin enable ;
56059: ENABLE
// if not hInvincible then
56060: LD_EXP 144
56064: NOT
56065: IFFALSE 56069
// exit ;
56067: GO 56113
// for i in hInvincible do
56069: LD_ADDR_VAR 0 1
56073: PUSH
56074: LD_EXP 144
56078: PUSH
56079: FOR_IN
56080: IFFALSE 56111
// if GetLives ( i ) < 1000 then
56082: LD_VAR 0 1
56086: PPUSH
56087: CALL_OW 256
56091: PUSH
56092: LD_INT 1000
56094: LESS
56095: IFFALSE 56109
// SetLives ( i , 1000 ) ;
56097: LD_VAR 0 1
56101: PPUSH
56102: LD_INT 1000
56104: PPUSH
56105: CALL_OW 234
56109: GO 56079
56111: POP
56112: POP
// end ;
56113: PPOPN 1
56115: END
// export function hHackInvincible ; var i ; begin
56116: LD_INT 0
56118: PPUSH
56119: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
56120: LD_ADDR_VAR 0 2
56124: PUSH
56125: LD_INT 2
56127: PUSH
56128: LD_INT 21
56130: PUSH
56131: LD_INT 1
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PUSH
56138: LD_INT 21
56140: PUSH
56141: LD_INT 2
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: LIST
56152: PPUSH
56153: CALL_OW 69
56157: PUSH
56158: FOR_IN
56159: IFFALSE 56220
// if IsSelected ( i ) then
56161: LD_VAR 0 2
56165: PPUSH
56166: CALL_OW 306
56170: IFFALSE 56218
// begin if i in hInvincible then
56172: LD_VAR 0 2
56176: PUSH
56177: LD_EXP 144
56181: IN
56182: IFFALSE 56202
// hInvincible := hInvincible diff i else
56184: LD_ADDR_EXP 144
56188: PUSH
56189: LD_EXP 144
56193: PUSH
56194: LD_VAR 0 2
56198: DIFF
56199: ST_TO_ADDR
56200: GO 56218
// hInvincible := hInvincible union i ;
56202: LD_ADDR_EXP 144
56206: PUSH
56207: LD_EXP 144
56211: PUSH
56212: LD_VAR 0 2
56216: UNION
56217: ST_TO_ADDR
// end ;
56218: GO 56158
56220: POP
56221: POP
// end ;
56222: LD_VAR 0 1
56226: RET
// export function hHackInvisible ; var i , j ; begin
56227: LD_INT 0
56229: PPUSH
56230: PPUSH
56231: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
56232: LD_ADDR_VAR 0 2
56236: PUSH
56237: LD_INT 21
56239: PUSH
56240: LD_INT 1
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PPUSH
56247: CALL_OW 69
56251: PUSH
56252: FOR_IN
56253: IFFALSE 56277
// if IsSelected ( i ) then
56255: LD_VAR 0 2
56259: PPUSH
56260: CALL_OW 306
56264: IFFALSE 56275
// ComForceInvisible ( i ) ;
56266: LD_VAR 0 2
56270: PPUSH
56271: CALL_OW 496
56275: GO 56252
56277: POP
56278: POP
// end ;
56279: LD_VAR 0 1
56283: RET
// export function hHackChangeYourSide ; begin
56284: LD_INT 0
56286: PPUSH
// if your_side = 8 then
56287: LD_OWVAR 2
56291: PUSH
56292: LD_INT 8
56294: EQUAL
56295: IFFALSE 56307
// your_side := 0 else
56297: LD_ADDR_OWVAR 2
56301: PUSH
56302: LD_INT 0
56304: ST_TO_ADDR
56305: GO 56321
// your_side := your_side + 1 ;
56307: LD_ADDR_OWVAR 2
56311: PUSH
56312: LD_OWVAR 2
56316: PUSH
56317: LD_INT 1
56319: PLUS
56320: ST_TO_ADDR
// end ;
56321: LD_VAR 0 1
56325: RET
// export function hHackChangeUnitSide ; var i , j ; begin
56326: LD_INT 0
56328: PPUSH
56329: PPUSH
56330: PPUSH
// for i in all_units do
56331: LD_ADDR_VAR 0 2
56335: PUSH
56336: LD_OWVAR 3
56340: PUSH
56341: FOR_IN
56342: IFFALSE 56420
// if IsSelected ( i ) then
56344: LD_VAR 0 2
56348: PPUSH
56349: CALL_OW 306
56353: IFFALSE 56418
// begin j := GetSide ( i ) ;
56355: LD_ADDR_VAR 0 3
56359: PUSH
56360: LD_VAR 0 2
56364: PPUSH
56365: CALL_OW 255
56369: ST_TO_ADDR
// if j = 8 then
56370: LD_VAR 0 3
56374: PUSH
56375: LD_INT 8
56377: EQUAL
56378: IFFALSE 56390
// j := 0 else
56380: LD_ADDR_VAR 0 3
56384: PUSH
56385: LD_INT 0
56387: ST_TO_ADDR
56388: GO 56404
// j := j + 1 ;
56390: LD_ADDR_VAR 0 3
56394: PUSH
56395: LD_VAR 0 3
56399: PUSH
56400: LD_INT 1
56402: PLUS
56403: ST_TO_ADDR
// SetSide ( i , j ) ;
56404: LD_VAR 0 2
56408: PPUSH
56409: LD_VAR 0 3
56413: PPUSH
56414: CALL_OW 235
// end ;
56418: GO 56341
56420: POP
56421: POP
// end ;
56422: LD_VAR 0 1
56426: RET
// export function hHackFog ; begin
56427: LD_INT 0
56429: PPUSH
// FogOff ( true ) ;
56430: LD_INT 1
56432: PPUSH
56433: CALL_OW 344
// end ;
56437: LD_VAR 0 1
56441: RET
// export function hHackTeleport ( unit , x , y ) ; begin
56442: LD_INT 0
56444: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
56445: LD_VAR 0 1
56449: PPUSH
56450: LD_VAR 0 2
56454: PPUSH
56455: LD_VAR 0 3
56459: PPUSH
56460: LD_INT 1
56462: PPUSH
56463: LD_INT 1
56465: PPUSH
56466: CALL_OW 483
// CenterOnXY ( x , y ) ;
56470: LD_VAR 0 2
56474: PPUSH
56475: LD_VAR 0 3
56479: PPUSH
56480: CALL_OW 84
// end ; end_of_file
56484: LD_VAR 0 4
56488: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
56489: LD_INT 0
56491: PPUSH
56492: PPUSH
56493: PPUSH
56494: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
56495: LD_VAR 0 1
56499: PPUSH
56500: CALL_OW 264
56504: PUSH
56505: LD_EXP 79
56509: EQUAL
56510: IFFALSE 56582
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
56512: LD_INT 68
56514: PPUSH
56515: LD_VAR 0 1
56519: PPUSH
56520: CALL_OW 255
56524: PPUSH
56525: CALL_OW 321
56529: PUSH
56530: LD_INT 2
56532: EQUAL
56533: IFFALSE 56545
// eff := 70 else
56535: LD_ADDR_VAR 0 4
56539: PUSH
56540: LD_INT 70
56542: ST_TO_ADDR
56543: GO 56553
// eff := 30 ;
56545: LD_ADDR_VAR 0 4
56549: PUSH
56550: LD_INT 30
56552: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
56553: LD_VAR 0 1
56557: PPUSH
56558: CALL_OW 250
56562: PPUSH
56563: LD_VAR 0 1
56567: PPUSH
56568: CALL_OW 251
56572: PPUSH
56573: LD_VAR 0 4
56577: PPUSH
56578: CALL_OW 495
// end ; end ;
56582: LD_VAR 0 2
56586: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
56587: LD_INT 0
56589: PPUSH
// end ;
56590: LD_VAR 0 4
56594: RET
// export function SOS_Command ( cmd ) ; begin
56595: LD_INT 0
56597: PPUSH
// end ;
56598: LD_VAR 0 2
56602: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
56603: LD_INT 0
56605: PPUSH
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
56606: LD_VAR 0 1
56610: PUSH
56611: LD_INT 254
56613: EQUAL
56614: PUSH
56615: LD_VAR 0 2
56619: PPUSH
56620: CALL_OW 264
56624: PUSH
56625: LD_EXP 77
56629: EQUAL
56630: AND
56631: PUSH
56632: LD_VAR 0 3
56636: PPUSH
56637: CALL_OW 263
56641: PUSH
56642: LD_INT 3
56644: EQUAL
56645: AND
56646: IFFALSE 56662
// HackDestroyVehicle ( unit , selectedUnit ) ;
56648: LD_VAR 0 2
56652: PPUSH
56653: LD_VAR 0 3
56657: PPUSH
56658: CALL 58171 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
56662: LD_VAR 0 1
56666: PUSH
56667: LD_INT 255
56669: EQUAL
56670: PUSH
56671: LD_VAR 0 2
56675: PPUSH
56676: CALL_OW 264
56680: PUSH
56681: LD_INT 14
56683: PUSH
56684: LD_INT 53
56686: PUSH
56687: EMPTY
56688: LIST
56689: LIST
56690: IN
56691: AND
56692: PUSH
56693: LD_VAR 0 4
56697: PPUSH
56698: LD_VAR 0 5
56702: PPUSH
56703: CALL_OW 488
56707: AND
56708: IFFALSE 56732
// CutTreeXYR ( unit , x , y , 12 ) ;
56710: LD_VAR 0 2
56714: PPUSH
56715: LD_VAR 0 4
56719: PPUSH
56720: LD_VAR 0 5
56724: PPUSH
56725: LD_INT 12
56727: PPUSH
56728: CALL 56737 0 4
// end ;
56732: LD_VAR 0 6
56736: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
56737: LD_INT 0
56739: PPUSH
56740: PPUSH
56741: PPUSH
56742: PPUSH
56743: PPUSH
56744: PPUSH
56745: PPUSH
56746: PPUSH
56747: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
56748: LD_VAR 0 1
56752: NOT
56753: PUSH
56754: LD_VAR 0 2
56758: PPUSH
56759: LD_VAR 0 3
56763: PPUSH
56764: CALL_OW 488
56768: NOT
56769: OR
56770: PUSH
56771: LD_VAR 0 4
56775: NOT
56776: OR
56777: IFFALSE 56781
// exit ;
56779: GO 57121
// list := [ ] ;
56781: LD_ADDR_VAR 0 13
56785: PUSH
56786: EMPTY
56787: ST_TO_ADDR
// if x - r < 0 then
56788: LD_VAR 0 2
56792: PUSH
56793: LD_VAR 0 4
56797: MINUS
56798: PUSH
56799: LD_INT 0
56801: LESS
56802: IFFALSE 56814
// min_x := 0 else
56804: LD_ADDR_VAR 0 7
56808: PUSH
56809: LD_INT 0
56811: ST_TO_ADDR
56812: GO 56830
// min_x := x - r ;
56814: LD_ADDR_VAR 0 7
56818: PUSH
56819: LD_VAR 0 2
56823: PUSH
56824: LD_VAR 0 4
56828: MINUS
56829: ST_TO_ADDR
// if y - r < 0 then
56830: LD_VAR 0 3
56834: PUSH
56835: LD_VAR 0 4
56839: MINUS
56840: PUSH
56841: LD_INT 0
56843: LESS
56844: IFFALSE 56856
// min_y := 0 else
56846: LD_ADDR_VAR 0 8
56850: PUSH
56851: LD_INT 0
56853: ST_TO_ADDR
56854: GO 56872
// min_y := y - r ;
56856: LD_ADDR_VAR 0 8
56860: PUSH
56861: LD_VAR 0 3
56865: PUSH
56866: LD_VAR 0 4
56870: MINUS
56871: ST_TO_ADDR
// max_x := x + r ;
56872: LD_ADDR_VAR 0 9
56876: PUSH
56877: LD_VAR 0 2
56881: PUSH
56882: LD_VAR 0 4
56886: PLUS
56887: ST_TO_ADDR
// max_y := y + r ;
56888: LD_ADDR_VAR 0 10
56892: PUSH
56893: LD_VAR 0 3
56897: PUSH
56898: LD_VAR 0 4
56902: PLUS
56903: ST_TO_ADDR
// for _x = min_x to max_x do
56904: LD_ADDR_VAR 0 11
56908: PUSH
56909: DOUBLE
56910: LD_VAR 0 7
56914: DEC
56915: ST_TO_ADDR
56916: LD_VAR 0 9
56920: PUSH
56921: FOR_TO
56922: IFFALSE 57039
// for _y = min_y to max_y do
56924: LD_ADDR_VAR 0 12
56928: PUSH
56929: DOUBLE
56930: LD_VAR 0 8
56934: DEC
56935: ST_TO_ADDR
56936: LD_VAR 0 10
56940: PUSH
56941: FOR_TO
56942: IFFALSE 57035
// begin if not ValidHex ( _x , _y ) then
56944: LD_VAR 0 11
56948: PPUSH
56949: LD_VAR 0 12
56953: PPUSH
56954: CALL_OW 488
56958: NOT
56959: IFFALSE 56963
// continue ;
56961: GO 56941
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
56963: LD_VAR 0 11
56967: PPUSH
56968: LD_VAR 0 12
56972: PPUSH
56973: CALL_OW 351
56977: PUSH
56978: LD_VAR 0 11
56982: PPUSH
56983: LD_VAR 0 12
56987: PPUSH
56988: CALL_OW 554
56992: AND
56993: IFFALSE 57033
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
56995: LD_ADDR_VAR 0 13
56999: PUSH
57000: LD_VAR 0 13
57004: PPUSH
57005: LD_VAR 0 13
57009: PUSH
57010: LD_INT 1
57012: PLUS
57013: PPUSH
57014: LD_VAR 0 11
57018: PUSH
57019: LD_VAR 0 12
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: PPUSH
57028: CALL_OW 2
57032: ST_TO_ADDR
// end ;
57033: GO 56941
57035: POP
57036: POP
57037: GO 56921
57039: POP
57040: POP
// if not list then
57041: LD_VAR 0 13
57045: NOT
57046: IFFALSE 57050
// exit ;
57048: GO 57121
// for i in list do
57050: LD_ADDR_VAR 0 6
57054: PUSH
57055: LD_VAR 0 13
57059: PUSH
57060: FOR_IN
57061: IFFALSE 57119
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
57063: LD_VAR 0 1
57067: PPUSH
57068: LD_STRING M
57070: PUSH
57071: LD_VAR 0 6
57075: PUSH
57076: LD_INT 1
57078: ARRAY
57079: PUSH
57080: LD_VAR 0 6
57084: PUSH
57085: LD_INT 2
57087: ARRAY
57088: PUSH
57089: LD_INT 0
57091: PUSH
57092: LD_INT 0
57094: PUSH
57095: LD_INT 0
57097: PUSH
57098: LD_INT 0
57100: PUSH
57101: EMPTY
57102: LIST
57103: LIST
57104: LIST
57105: LIST
57106: LIST
57107: LIST
57108: LIST
57109: PUSH
57110: EMPTY
57111: LIST
57112: PPUSH
57113: CALL_OW 447
57117: GO 57060
57119: POP
57120: POP
// end ;
57121: LD_VAR 0 5
57125: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
57126: LD_EXP 145
57130: NOT
57131: IFFALSE 57181
57133: GO 57135
57135: DISABLE
// begin initHack := true ;
57136: LD_ADDR_EXP 145
57140: PUSH
57141: LD_INT 1
57143: ST_TO_ADDR
// hackTanks := [ ] ;
57144: LD_ADDR_EXP 146
57148: PUSH
57149: EMPTY
57150: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
57151: LD_ADDR_EXP 147
57155: PUSH
57156: EMPTY
57157: ST_TO_ADDR
// hackLimit := 3 ;
57158: LD_ADDR_EXP 148
57162: PUSH
57163: LD_INT 3
57165: ST_TO_ADDR
// hackDist := 12 ;
57166: LD_ADDR_EXP 149
57170: PUSH
57171: LD_INT 12
57173: ST_TO_ADDR
// hackCounter := [ ] ;
57174: LD_ADDR_EXP 150
57178: PUSH
57179: EMPTY
57180: ST_TO_ADDR
// end ;
57181: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
57182: LD_EXP 145
57186: PUSH
57187: LD_INT 34
57189: PUSH
57190: LD_EXP 77
57194: PUSH
57195: EMPTY
57196: LIST
57197: LIST
57198: PPUSH
57199: CALL_OW 69
57203: AND
57204: IFFALSE 57459
57206: GO 57208
57208: DISABLE
57209: LD_INT 0
57211: PPUSH
57212: PPUSH
// begin enable ;
57213: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
57214: LD_ADDR_VAR 0 1
57218: PUSH
57219: LD_INT 34
57221: PUSH
57222: LD_EXP 77
57226: PUSH
57227: EMPTY
57228: LIST
57229: LIST
57230: PPUSH
57231: CALL_OW 69
57235: PUSH
57236: FOR_IN
57237: IFFALSE 57457
// begin if not i in hackTanks then
57239: LD_VAR 0 1
57243: PUSH
57244: LD_EXP 146
57248: IN
57249: NOT
57250: IFFALSE 57333
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
57252: LD_ADDR_EXP 146
57256: PUSH
57257: LD_EXP 146
57261: PPUSH
57262: LD_EXP 146
57266: PUSH
57267: LD_INT 1
57269: PLUS
57270: PPUSH
57271: LD_VAR 0 1
57275: PPUSH
57276: CALL_OW 1
57280: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
57281: LD_ADDR_EXP 147
57285: PUSH
57286: LD_EXP 147
57290: PPUSH
57291: LD_EXP 147
57295: PUSH
57296: LD_INT 1
57298: PLUS
57299: PPUSH
57300: EMPTY
57301: PPUSH
57302: CALL_OW 1
57306: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
57307: LD_ADDR_EXP 150
57311: PUSH
57312: LD_EXP 150
57316: PPUSH
57317: LD_EXP 150
57321: PUSH
57322: LD_INT 1
57324: PLUS
57325: PPUSH
57326: EMPTY
57327: PPUSH
57328: CALL_OW 1
57332: ST_TO_ADDR
// end ; if not IsOk ( i ) then
57333: LD_VAR 0 1
57337: PPUSH
57338: CALL_OW 302
57342: NOT
57343: IFFALSE 57356
// begin HackUnlinkAll ( i ) ;
57345: LD_VAR 0 1
57349: PPUSH
57350: CALL 57462 0 1
// continue ;
57354: GO 57236
// end ; HackCheckCapturedStatus ( i ) ;
57356: LD_VAR 0 1
57360: PPUSH
57361: CALL 57905 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
57365: LD_ADDR_VAR 0 2
57369: PUSH
57370: LD_INT 81
57372: PUSH
57373: LD_VAR 0 1
57377: PPUSH
57378: CALL_OW 255
57382: PUSH
57383: EMPTY
57384: LIST
57385: LIST
57386: PUSH
57387: LD_INT 33
57389: PUSH
57390: LD_INT 3
57392: PUSH
57393: EMPTY
57394: LIST
57395: LIST
57396: PUSH
57397: LD_INT 91
57399: PUSH
57400: LD_VAR 0 1
57404: PUSH
57405: LD_EXP 149
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: LIST
57414: PUSH
57415: LD_INT 50
57417: PUSH
57418: EMPTY
57419: LIST
57420: PUSH
57421: EMPTY
57422: LIST
57423: LIST
57424: LIST
57425: LIST
57426: PPUSH
57427: CALL_OW 69
57431: ST_TO_ADDR
// if not tmp then
57432: LD_VAR 0 2
57436: NOT
57437: IFFALSE 57441
// continue ;
57439: GO 57236
// HackLink ( i , tmp ) ;
57441: LD_VAR 0 1
57445: PPUSH
57446: LD_VAR 0 2
57450: PPUSH
57451: CALL 57598 0 2
// end ;
57455: GO 57236
57457: POP
57458: POP
// end ;
57459: PPOPN 2
57461: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
57462: LD_INT 0
57464: PPUSH
57465: PPUSH
57466: PPUSH
// if not hack in hackTanks then
57467: LD_VAR 0 1
57471: PUSH
57472: LD_EXP 146
57476: IN
57477: NOT
57478: IFFALSE 57482
// exit ;
57480: GO 57593
// index := GetElementIndex ( hackTanks , hack ) ;
57482: LD_ADDR_VAR 0 4
57486: PUSH
57487: LD_EXP 146
57491: PPUSH
57492: LD_VAR 0 1
57496: PPUSH
57497: CALL 63013 0 2
57501: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
57502: LD_EXP 147
57506: PUSH
57507: LD_VAR 0 4
57511: ARRAY
57512: IFFALSE 57593
// begin for i in hackTanksCaptured [ index ] do
57514: LD_ADDR_VAR 0 3
57518: PUSH
57519: LD_EXP 147
57523: PUSH
57524: LD_VAR 0 4
57528: ARRAY
57529: PUSH
57530: FOR_IN
57531: IFFALSE 57557
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
57533: LD_VAR 0 3
57537: PUSH
57538: LD_INT 1
57540: ARRAY
57541: PPUSH
57542: LD_VAR 0 3
57546: PUSH
57547: LD_INT 2
57549: ARRAY
57550: PPUSH
57551: CALL_OW 235
57555: GO 57530
57557: POP
57558: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
57559: LD_ADDR_EXP 147
57563: PUSH
57564: LD_EXP 147
57568: PPUSH
57569: LD_VAR 0 4
57573: PPUSH
57574: EMPTY
57575: PPUSH
57576: CALL_OW 1
57580: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
57581: LD_VAR 0 1
57585: PPUSH
57586: LD_INT 0
57588: PPUSH
57589: CALL_OW 505
// end ; end ;
57593: LD_VAR 0 2
57597: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
57598: LD_INT 0
57600: PPUSH
57601: PPUSH
57602: PPUSH
// if not hack in hackTanks or not vehicles then
57603: LD_VAR 0 1
57607: PUSH
57608: LD_EXP 146
57612: IN
57613: NOT
57614: PUSH
57615: LD_VAR 0 2
57619: NOT
57620: OR
57621: IFFALSE 57625
// exit ;
57623: GO 57900
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
57625: LD_ADDR_VAR 0 2
57629: PUSH
57630: LD_VAR 0 1
57634: PPUSH
57635: LD_VAR 0 2
57639: PPUSH
57640: LD_INT 1
57642: PPUSH
57643: LD_INT 1
57645: PPUSH
57646: CALL 63663 0 4
57650: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
57651: LD_ADDR_VAR 0 5
57655: PUSH
57656: LD_EXP 146
57660: PPUSH
57661: LD_VAR 0 1
57665: PPUSH
57666: CALL 63013 0 2
57670: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
57671: LD_EXP 147
57675: PUSH
57676: LD_VAR 0 5
57680: ARRAY
57681: PUSH
57682: LD_EXP 148
57686: LESS
57687: IFFALSE 57876
// begin for i := 1 to vehicles do
57689: LD_ADDR_VAR 0 4
57693: PUSH
57694: DOUBLE
57695: LD_INT 1
57697: DEC
57698: ST_TO_ADDR
57699: LD_VAR 0 2
57703: PUSH
57704: FOR_TO
57705: IFFALSE 57874
// begin if hackTanksCaptured [ index ] = hackLimit then
57707: LD_EXP 147
57711: PUSH
57712: LD_VAR 0 5
57716: ARRAY
57717: PUSH
57718: LD_EXP 148
57722: EQUAL
57723: IFFALSE 57727
// break ;
57725: GO 57874
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
57727: LD_ADDR_EXP 150
57731: PUSH
57732: LD_EXP 150
57736: PPUSH
57737: LD_VAR 0 5
57741: PPUSH
57742: LD_EXP 150
57746: PUSH
57747: LD_VAR 0 5
57751: ARRAY
57752: PUSH
57753: LD_INT 1
57755: PLUS
57756: PPUSH
57757: CALL_OW 1
57761: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
57762: LD_ADDR_EXP 147
57766: PUSH
57767: LD_EXP 147
57771: PPUSH
57772: LD_VAR 0 5
57776: PUSH
57777: LD_EXP 147
57781: PUSH
57782: LD_VAR 0 5
57786: ARRAY
57787: PUSH
57788: LD_INT 1
57790: PLUS
57791: PUSH
57792: EMPTY
57793: LIST
57794: LIST
57795: PPUSH
57796: LD_VAR 0 2
57800: PUSH
57801: LD_VAR 0 4
57805: ARRAY
57806: PUSH
57807: LD_VAR 0 2
57811: PUSH
57812: LD_VAR 0 4
57816: ARRAY
57817: PPUSH
57818: CALL_OW 255
57822: PUSH
57823: EMPTY
57824: LIST
57825: LIST
57826: PPUSH
57827: CALL 63228 0 3
57831: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
57832: LD_VAR 0 2
57836: PUSH
57837: LD_VAR 0 4
57841: ARRAY
57842: PPUSH
57843: LD_VAR 0 1
57847: PPUSH
57848: CALL_OW 255
57852: PPUSH
57853: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
57857: LD_VAR 0 2
57861: PUSH
57862: LD_VAR 0 4
57866: ARRAY
57867: PPUSH
57868: CALL_OW 141
// end ;
57872: GO 57704
57874: POP
57875: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
57876: LD_VAR 0 1
57880: PPUSH
57881: LD_EXP 147
57885: PUSH
57886: LD_VAR 0 5
57890: ARRAY
57891: PUSH
57892: LD_INT 0
57894: PLUS
57895: PPUSH
57896: CALL_OW 505
// end ;
57900: LD_VAR 0 3
57904: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
57905: LD_INT 0
57907: PPUSH
57908: PPUSH
57909: PPUSH
57910: PPUSH
// if not hack in hackTanks then
57911: LD_VAR 0 1
57915: PUSH
57916: LD_EXP 146
57920: IN
57921: NOT
57922: IFFALSE 57926
// exit ;
57924: GO 58166
// index := GetElementIndex ( hackTanks , hack ) ;
57926: LD_ADDR_VAR 0 4
57930: PUSH
57931: LD_EXP 146
57935: PPUSH
57936: LD_VAR 0 1
57940: PPUSH
57941: CALL 63013 0 2
57945: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
57946: LD_ADDR_VAR 0 3
57950: PUSH
57951: DOUBLE
57952: LD_EXP 147
57956: PUSH
57957: LD_VAR 0 4
57961: ARRAY
57962: INC
57963: ST_TO_ADDR
57964: LD_INT 1
57966: PUSH
57967: FOR_DOWNTO
57968: IFFALSE 58140
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
57970: LD_ADDR_VAR 0 5
57974: PUSH
57975: LD_EXP 147
57979: PUSH
57980: LD_VAR 0 4
57984: ARRAY
57985: PUSH
57986: LD_VAR 0 3
57990: ARRAY
57991: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
57992: LD_VAR 0 5
57996: PUSH
57997: LD_INT 1
57999: ARRAY
58000: PPUSH
58001: CALL_OW 302
58005: NOT
58006: PUSH
58007: LD_VAR 0 5
58011: PUSH
58012: LD_INT 1
58014: ARRAY
58015: PPUSH
58016: CALL_OW 255
58020: PUSH
58021: LD_VAR 0 1
58025: PPUSH
58026: CALL_OW 255
58030: NONEQUAL
58031: OR
58032: IFFALSE 58138
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
58034: LD_VAR 0 5
58038: PUSH
58039: LD_INT 1
58041: ARRAY
58042: PPUSH
58043: CALL_OW 305
58047: PUSH
58048: LD_VAR 0 5
58052: PUSH
58053: LD_INT 1
58055: ARRAY
58056: PPUSH
58057: CALL_OW 255
58061: PUSH
58062: LD_VAR 0 1
58066: PPUSH
58067: CALL_OW 255
58071: EQUAL
58072: AND
58073: IFFALSE 58097
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
58075: LD_VAR 0 5
58079: PUSH
58080: LD_INT 1
58082: ARRAY
58083: PPUSH
58084: LD_VAR 0 5
58088: PUSH
58089: LD_INT 2
58091: ARRAY
58092: PPUSH
58093: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
58097: LD_ADDR_EXP 147
58101: PUSH
58102: LD_EXP 147
58106: PPUSH
58107: LD_VAR 0 4
58111: PPUSH
58112: LD_EXP 147
58116: PUSH
58117: LD_VAR 0 4
58121: ARRAY
58122: PPUSH
58123: LD_VAR 0 3
58127: PPUSH
58128: CALL_OW 3
58132: PPUSH
58133: CALL_OW 1
58137: ST_TO_ADDR
// end ; end ;
58138: GO 57967
58140: POP
58141: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
58142: LD_VAR 0 1
58146: PPUSH
58147: LD_EXP 147
58151: PUSH
58152: LD_VAR 0 4
58156: ARRAY
58157: PUSH
58158: LD_INT 0
58160: PLUS
58161: PPUSH
58162: CALL_OW 505
// end ;
58166: LD_VAR 0 2
58170: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
58171: LD_INT 0
58173: PPUSH
58174: PPUSH
58175: PPUSH
58176: PPUSH
// if not hack in hackTanks then
58177: LD_VAR 0 1
58181: PUSH
58182: LD_EXP 146
58186: IN
58187: NOT
58188: IFFALSE 58192
// exit ;
58190: GO 58277
// index := GetElementIndex ( hackTanks , hack ) ;
58192: LD_ADDR_VAR 0 5
58196: PUSH
58197: LD_EXP 146
58201: PPUSH
58202: LD_VAR 0 1
58206: PPUSH
58207: CALL 63013 0 2
58211: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
58212: LD_ADDR_VAR 0 4
58216: PUSH
58217: DOUBLE
58218: LD_INT 1
58220: DEC
58221: ST_TO_ADDR
58222: LD_EXP 147
58226: PUSH
58227: LD_VAR 0 5
58231: ARRAY
58232: PUSH
58233: FOR_TO
58234: IFFALSE 58275
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
58236: LD_EXP 147
58240: PUSH
58241: LD_VAR 0 5
58245: ARRAY
58246: PUSH
58247: LD_VAR 0 4
58251: ARRAY
58252: PUSH
58253: LD_INT 1
58255: ARRAY
58256: PUSH
58257: LD_VAR 0 2
58261: EQUAL
58262: IFFALSE 58273
// KillUnit ( vehicle ) ;
58264: LD_VAR 0 2
58268: PPUSH
58269: CALL_OW 66
58273: GO 58233
58275: POP
58276: POP
// end ; end_of_file
58277: LD_VAR 0 3
58281: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
58282: LD_INT 0
58284: PPUSH
58285: PPUSH
// if exist_mode then
58286: LD_VAR 0 2
58290: IFFALSE 58315
// unit := CreateCharacter ( prefix & ident ) else
58292: LD_ADDR_VAR 0 5
58296: PUSH
58297: LD_VAR 0 3
58301: PUSH
58302: LD_VAR 0 1
58306: STR
58307: PPUSH
58308: CALL_OW 34
58312: ST_TO_ADDR
58313: GO 58330
// unit := NewCharacter ( ident ) ;
58315: LD_ADDR_VAR 0 5
58319: PUSH
58320: LD_VAR 0 1
58324: PPUSH
58325: CALL_OW 25
58329: ST_TO_ADDR
// result := unit ;
58330: LD_ADDR_VAR 0 4
58334: PUSH
58335: LD_VAR 0 5
58339: ST_TO_ADDR
// end ;
58340: LD_VAR 0 4
58344: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
58345: LD_INT 0
58347: PPUSH
58348: PPUSH
// if not side or not nation then
58349: LD_VAR 0 1
58353: NOT
58354: PUSH
58355: LD_VAR 0 2
58359: NOT
58360: OR
58361: IFFALSE 58365
// exit ;
58363: GO 59129
// case nation of nation_american :
58365: LD_VAR 0 2
58369: PUSH
58370: LD_INT 1
58372: DOUBLE
58373: EQUAL
58374: IFTRUE 58378
58376: GO 58592
58378: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
58379: LD_ADDR_VAR 0 4
58383: PUSH
58384: LD_INT 35
58386: PUSH
58387: LD_INT 45
58389: PUSH
58390: LD_INT 46
58392: PUSH
58393: LD_INT 47
58395: PUSH
58396: LD_INT 82
58398: PUSH
58399: LD_INT 83
58401: PUSH
58402: LD_INT 84
58404: PUSH
58405: LD_INT 85
58407: PUSH
58408: LD_INT 86
58410: PUSH
58411: LD_INT 1
58413: PUSH
58414: LD_INT 2
58416: PUSH
58417: LD_INT 6
58419: PUSH
58420: LD_INT 15
58422: PUSH
58423: LD_INT 16
58425: PUSH
58426: LD_INT 7
58428: PUSH
58429: LD_INT 12
58431: PUSH
58432: LD_INT 13
58434: PUSH
58435: LD_INT 10
58437: PUSH
58438: LD_INT 14
58440: PUSH
58441: LD_INT 20
58443: PUSH
58444: LD_INT 21
58446: PUSH
58447: LD_INT 22
58449: PUSH
58450: LD_INT 25
58452: PUSH
58453: LD_INT 32
58455: PUSH
58456: LD_INT 27
58458: PUSH
58459: LD_INT 36
58461: PUSH
58462: LD_INT 69
58464: PUSH
58465: LD_INT 39
58467: PUSH
58468: LD_INT 34
58470: PUSH
58471: LD_INT 40
58473: PUSH
58474: LD_INT 48
58476: PUSH
58477: LD_INT 49
58479: PUSH
58480: LD_INT 50
58482: PUSH
58483: LD_INT 51
58485: PUSH
58486: LD_INT 52
58488: PUSH
58489: LD_INT 53
58491: PUSH
58492: LD_INT 54
58494: PUSH
58495: LD_INT 55
58497: PUSH
58498: LD_INT 56
58500: PUSH
58501: LD_INT 57
58503: PUSH
58504: LD_INT 58
58506: PUSH
58507: LD_INT 59
58509: PUSH
58510: LD_INT 60
58512: PUSH
58513: LD_INT 61
58515: PUSH
58516: LD_INT 62
58518: PUSH
58519: LD_INT 80
58521: PUSH
58522: LD_INT 82
58524: PUSH
58525: LD_INT 83
58527: PUSH
58528: LD_INT 84
58530: PUSH
58531: LD_INT 85
58533: PUSH
58534: LD_INT 86
58536: PUSH
58537: EMPTY
58538: LIST
58539: LIST
58540: LIST
58541: LIST
58542: LIST
58543: LIST
58544: LIST
58545: LIST
58546: LIST
58547: LIST
58548: LIST
58549: LIST
58550: LIST
58551: LIST
58552: LIST
58553: LIST
58554: LIST
58555: LIST
58556: LIST
58557: LIST
58558: LIST
58559: LIST
58560: LIST
58561: LIST
58562: LIST
58563: LIST
58564: LIST
58565: LIST
58566: LIST
58567: LIST
58568: LIST
58569: LIST
58570: LIST
58571: LIST
58572: LIST
58573: LIST
58574: LIST
58575: LIST
58576: LIST
58577: LIST
58578: LIST
58579: LIST
58580: LIST
58581: LIST
58582: LIST
58583: LIST
58584: LIST
58585: LIST
58586: LIST
58587: LIST
58588: LIST
58589: ST_TO_ADDR
58590: GO 59053
58592: LD_INT 2
58594: DOUBLE
58595: EQUAL
58596: IFTRUE 58600
58598: GO 58822
58600: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
58601: LD_ADDR_VAR 0 4
58605: PUSH
58606: LD_INT 35
58608: PUSH
58609: LD_INT 45
58611: PUSH
58612: LD_INT 46
58614: PUSH
58615: LD_INT 47
58617: PUSH
58618: LD_INT 82
58620: PUSH
58621: LD_INT 83
58623: PUSH
58624: LD_INT 84
58626: PUSH
58627: LD_INT 85
58629: PUSH
58630: LD_INT 87
58632: PUSH
58633: LD_INT 70
58635: PUSH
58636: LD_INT 1
58638: PUSH
58639: LD_INT 11
58641: PUSH
58642: LD_INT 3
58644: PUSH
58645: LD_INT 4
58647: PUSH
58648: LD_INT 5
58650: PUSH
58651: LD_INT 6
58653: PUSH
58654: LD_INT 15
58656: PUSH
58657: LD_INT 18
58659: PUSH
58660: LD_INT 7
58662: PUSH
58663: LD_INT 17
58665: PUSH
58666: LD_INT 8
58668: PUSH
58669: LD_INT 20
58671: PUSH
58672: LD_INT 21
58674: PUSH
58675: LD_INT 22
58677: PUSH
58678: LD_INT 72
58680: PUSH
58681: LD_INT 26
58683: PUSH
58684: LD_INT 69
58686: PUSH
58687: LD_INT 39
58689: PUSH
58690: LD_INT 40
58692: PUSH
58693: LD_INT 41
58695: PUSH
58696: LD_INT 42
58698: PUSH
58699: LD_INT 43
58701: PUSH
58702: LD_INT 48
58704: PUSH
58705: LD_INT 49
58707: PUSH
58708: LD_INT 50
58710: PUSH
58711: LD_INT 51
58713: PUSH
58714: LD_INT 52
58716: PUSH
58717: LD_INT 53
58719: PUSH
58720: LD_INT 54
58722: PUSH
58723: LD_INT 55
58725: PUSH
58726: LD_INT 56
58728: PUSH
58729: LD_INT 60
58731: PUSH
58732: LD_INT 61
58734: PUSH
58735: LD_INT 62
58737: PUSH
58738: LD_INT 66
58740: PUSH
58741: LD_INT 67
58743: PUSH
58744: LD_INT 68
58746: PUSH
58747: LD_INT 81
58749: PUSH
58750: LD_INT 82
58752: PUSH
58753: LD_INT 83
58755: PUSH
58756: LD_INT 84
58758: PUSH
58759: LD_INT 85
58761: PUSH
58762: LD_INT 87
58764: PUSH
58765: EMPTY
58766: LIST
58767: LIST
58768: LIST
58769: LIST
58770: LIST
58771: LIST
58772: LIST
58773: LIST
58774: LIST
58775: LIST
58776: LIST
58777: LIST
58778: LIST
58779: LIST
58780: LIST
58781: LIST
58782: LIST
58783: LIST
58784: LIST
58785: LIST
58786: LIST
58787: LIST
58788: LIST
58789: LIST
58790: LIST
58791: LIST
58792: LIST
58793: LIST
58794: LIST
58795: LIST
58796: LIST
58797: LIST
58798: LIST
58799: LIST
58800: LIST
58801: LIST
58802: LIST
58803: LIST
58804: LIST
58805: LIST
58806: LIST
58807: LIST
58808: LIST
58809: LIST
58810: LIST
58811: LIST
58812: LIST
58813: LIST
58814: LIST
58815: LIST
58816: LIST
58817: LIST
58818: LIST
58819: ST_TO_ADDR
58820: GO 59053
58822: LD_INT 3
58824: DOUBLE
58825: EQUAL
58826: IFTRUE 58830
58828: GO 59052
58830: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
58831: LD_ADDR_VAR 0 4
58835: PUSH
58836: LD_INT 46
58838: PUSH
58839: LD_INT 47
58841: PUSH
58842: LD_INT 1
58844: PUSH
58845: LD_INT 2
58847: PUSH
58848: LD_INT 82
58850: PUSH
58851: LD_INT 83
58853: PUSH
58854: LD_INT 84
58856: PUSH
58857: LD_INT 85
58859: PUSH
58860: LD_INT 86
58862: PUSH
58863: LD_INT 11
58865: PUSH
58866: LD_INT 9
58868: PUSH
58869: LD_INT 20
58871: PUSH
58872: LD_INT 19
58874: PUSH
58875: LD_INT 21
58877: PUSH
58878: LD_INT 24
58880: PUSH
58881: LD_INT 22
58883: PUSH
58884: LD_INT 25
58886: PUSH
58887: LD_INT 28
58889: PUSH
58890: LD_INT 29
58892: PUSH
58893: LD_INT 30
58895: PUSH
58896: LD_INT 31
58898: PUSH
58899: LD_INT 37
58901: PUSH
58902: LD_INT 38
58904: PUSH
58905: LD_INT 32
58907: PUSH
58908: LD_INT 27
58910: PUSH
58911: LD_INT 33
58913: PUSH
58914: LD_INT 69
58916: PUSH
58917: LD_INT 39
58919: PUSH
58920: LD_INT 34
58922: PUSH
58923: LD_INT 40
58925: PUSH
58926: LD_INT 71
58928: PUSH
58929: LD_INT 23
58931: PUSH
58932: LD_INT 44
58934: PUSH
58935: LD_INT 48
58937: PUSH
58938: LD_INT 49
58940: PUSH
58941: LD_INT 50
58943: PUSH
58944: LD_INT 51
58946: PUSH
58947: LD_INT 52
58949: PUSH
58950: LD_INT 53
58952: PUSH
58953: LD_INT 54
58955: PUSH
58956: LD_INT 55
58958: PUSH
58959: LD_INT 56
58961: PUSH
58962: LD_INT 57
58964: PUSH
58965: LD_INT 58
58967: PUSH
58968: LD_INT 59
58970: PUSH
58971: LD_INT 63
58973: PUSH
58974: LD_INT 64
58976: PUSH
58977: LD_INT 65
58979: PUSH
58980: LD_INT 82
58982: PUSH
58983: LD_INT 83
58985: PUSH
58986: LD_INT 84
58988: PUSH
58989: LD_INT 85
58991: PUSH
58992: LD_INT 86
58994: PUSH
58995: EMPTY
58996: LIST
58997: LIST
58998: LIST
58999: LIST
59000: LIST
59001: LIST
59002: LIST
59003: LIST
59004: LIST
59005: LIST
59006: LIST
59007: LIST
59008: LIST
59009: LIST
59010: LIST
59011: LIST
59012: LIST
59013: LIST
59014: LIST
59015: LIST
59016: LIST
59017: LIST
59018: LIST
59019: LIST
59020: LIST
59021: LIST
59022: LIST
59023: LIST
59024: LIST
59025: LIST
59026: LIST
59027: LIST
59028: LIST
59029: LIST
59030: LIST
59031: LIST
59032: LIST
59033: LIST
59034: LIST
59035: LIST
59036: LIST
59037: LIST
59038: LIST
59039: LIST
59040: LIST
59041: LIST
59042: LIST
59043: LIST
59044: LIST
59045: LIST
59046: LIST
59047: LIST
59048: LIST
59049: ST_TO_ADDR
59050: GO 59053
59052: POP
// if state > - 1 and state < 3 then
59053: LD_VAR 0 3
59057: PUSH
59058: LD_INT 1
59060: NEG
59061: GREATER
59062: PUSH
59063: LD_VAR 0 3
59067: PUSH
59068: LD_INT 3
59070: LESS
59071: AND
59072: IFFALSE 59129
// for i in result do
59074: LD_ADDR_VAR 0 5
59078: PUSH
59079: LD_VAR 0 4
59083: PUSH
59084: FOR_IN
59085: IFFALSE 59127
// if GetTech ( i , side ) <> state then
59087: LD_VAR 0 5
59091: PPUSH
59092: LD_VAR 0 1
59096: PPUSH
59097: CALL_OW 321
59101: PUSH
59102: LD_VAR 0 3
59106: NONEQUAL
59107: IFFALSE 59125
// result := result diff i ;
59109: LD_ADDR_VAR 0 4
59113: PUSH
59114: LD_VAR 0 4
59118: PUSH
59119: LD_VAR 0 5
59123: DIFF
59124: ST_TO_ADDR
59125: GO 59084
59127: POP
59128: POP
// end ;
59129: LD_VAR 0 4
59133: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
59134: LD_INT 0
59136: PPUSH
59137: PPUSH
59138: PPUSH
// result := true ;
59139: LD_ADDR_VAR 0 3
59143: PUSH
59144: LD_INT 1
59146: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
59147: LD_ADDR_VAR 0 5
59151: PUSH
59152: LD_VAR 0 2
59156: PPUSH
59157: CALL_OW 480
59161: ST_TO_ADDR
// if not tmp then
59162: LD_VAR 0 5
59166: NOT
59167: IFFALSE 59171
// exit ;
59169: GO 59220
// for i in tmp do
59171: LD_ADDR_VAR 0 4
59175: PUSH
59176: LD_VAR 0 5
59180: PUSH
59181: FOR_IN
59182: IFFALSE 59218
// if GetTech ( i , side ) <> state_researched then
59184: LD_VAR 0 4
59188: PPUSH
59189: LD_VAR 0 1
59193: PPUSH
59194: CALL_OW 321
59198: PUSH
59199: LD_INT 2
59201: NONEQUAL
59202: IFFALSE 59216
// begin result := false ;
59204: LD_ADDR_VAR 0 3
59208: PUSH
59209: LD_INT 0
59211: ST_TO_ADDR
// exit ;
59212: POP
59213: POP
59214: GO 59220
// end ;
59216: GO 59181
59218: POP
59219: POP
// end ;
59220: LD_VAR 0 3
59224: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
59225: LD_INT 0
59227: PPUSH
59228: PPUSH
59229: PPUSH
59230: PPUSH
59231: PPUSH
59232: PPUSH
59233: PPUSH
59234: PPUSH
59235: PPUSH
59236: PPUSH
59237: PPUSH
59238: PPUSH
59239: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
59240: LD_VAR 0 1
59244: NOT
59245: PUSH
59246: LD_VAR 0 1
59250: PPUSH
59251: CALL_OW 257
59255: PUSH
59256: LD_INT 9
59258: NONEQUAL
59259: OR
59260: IFFALSE 59264
// exit ;
59262: GO 59837
// side := GetSide ( unit ) ;
59264: LD_ADDR_VAR 0 9
59268: PUSH
59269: LD_VAR 0 1
59273: PPUSH
59274: CALL_OW 255
59278: ST_TO_ADDR
// tech_space := tech_spacanom ;
59279: LD_ADDR_VAR 0 12
59283: PUSH
59284: LD_INT 29
59286: ST_TO_ADDR
// tech_time := tech_taurad ;
59287: LD_ADDR_VAR 0 13
59291: PUSH
59292: LD_INT 28
59294: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
59295: LD_ADDR_VAR 0 11
59299: PUSH
59300: LD_VAR 0 1
59304: PPUSH
59305: CALL_OW 310
59309: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
59310: LD_VAR 0 11
59314: PPUSH
59315: CALL_OW 247
59319: PUSH
59320: LD_INT 2
59322: EQUAL
59323: IFFALSE 59327
// exit ;
59325: GO 59837
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59327: LD_ADDR_VAR 0 8
59331: PUSH
59332: LD_INT 81
59334: PUSH
59335: LD_VAR 0 9
59339: PUSH
59340: EMPTY
59341: LIST
59342: LIST
59343: PUSH
59344: LD_INT 3
59346: PUSH
59347: LD_INT 21
59349: PUSH
59350: LD_INT 3
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: PUSH
59361: EMPTY
59362: LIST
59363: LIST
59364: PPUSH
59365: CALL_OW 69
59369: ST_TO_ADDR
// if not tmp then
59370: LD_VAR 0 8
59374: NOT
59375: IFFALSE 59379
// exit ;
59377: GO 59837
// if in_unit then
59379: LD_VAR 0 11
59383: IFFALSE 59407
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
59385: LD_ADDR_VAR 0 10
59389: PUSH
59390: LD_VAR 0 8
59394: PPUSH
59395: LD_VAR 0 11
59399: PPUSH
59400: CALL_OW 74
59404: ST_TO_ADDR
59405: GO 59427
// enemy := NearestUnitToUnit ( tmp , unit ) ;
59407: LD_ADDR_VAR 0 10
59411: PUSH
59412: LD_VAR 0 8
59416: PPUSH
59417: LD_VAR 0 1
59421: PPUSH
59422: CALL_OW 74
59426: ST_TO_ADDR
// if not enemy then
59427: LD_VAR 0 10
59431: NOT
59432: IFFALSE 59436
// exit ;
59434: GO 59837
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
59436: LD_VAR 0 11
59440: PUSH
59441: LD_VAR 0 11
59445: PPUSH
59446: LD_VAR 0 10
59450: PPUSH
59451: CALL_OW 296
59455: PUSH
59456: LD_INT 13
59458: GREATER
59459: AND
59460: PUSH
59461: LD_VAR 0 1
59465: PPUSH
59466: LD_VAR 0 10
59470: PPUSH
59471: CALL_OW 296
59475: PUSH
59476: LD_INT 12
59478: GREATER
59479: OR
59480: IFFALSE 59484
// exit ;
59482: GO 59837
// missile := [ 1 ] ;
59484: LD_ADDR_VAR 0 14
59488: PUSH
59489: LD_INT 1
59491: PUSH
59492: EMPTY
59493: LIST
59494: ST_TO_ADDR
// if Researched ( side , tech_space ) then
59495: LD_VAR 0 9
59499: PPUSH
59500: LD_VAR 0 12
59504: PPUSH
59505: CALL_OW 325
59509: IFFALSE 59538
// missile := Insert ( missile , missile + 1 , 2 ) ;
59511: LD_ADDR_VAR 0 14
59515: PUSH
59516: LD_VAR 0 14
59520: PPUSH
59521: LD_VAR 0 14
59525: PUSH
59526: LD_INT 1
59528: PLUS
59529: PPUSH
59530: LD_INT 2
59532: PPUSH
59533: CALL_OW 2
59537: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
59538: LD_VAR 0 9
59542: PPUSH
59543: LD_VAR 0 13
59547: PPUSH
59548: CALL_OW 325
59552: PUSH
59553: LD_VAR 0 10
59557: PPUSH
59558: CALL_OW 255
59562: PPUSH
59563: LD_VAR 0 13
59567: PPUSH
59568: CALL_OW 325
59572: NOT
59573: AND
59574: IFFALSE 59603
// missile := Insert ( missile , missile + 1 , 3 ) ;
59576: LD_ADDR_VAR 0 14
59580: PUSH
59581: LD_VAR 0 14
59585: PPUSH
59586: LD_VAR 0 14
59590: PUSH
59591: LD_INT 1
59593: PLUS
59594: PPUSH
59595: LD_INT 3
59597: PPUSH
59598: CALL_OW 2
59602: ST_TO_ADDR
// if missile < 2 then
59603: LD_VAR 0 14
59607: PUSH
59608: LD_INT 2
59610: LESS
59611: IFFALSE 59615
// exit ;
59613: GO 59837
// x := GetX ( enemy ) ;
59615: LD_ADDR_VAR 0 4
59619: PUSH
59620: LD_VAR 0 10
59624: PPUSH
59625: CALL_OW 250
59629: ST_TO_ADDR
// y := GetY ( enemy ) ;
59630: LD_ADDR_VAR 0 5
59634: PUSH
59635: LD_VAR 0 10
59639: PPUSH
59640: CALL_OW 251
59644: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
59645: LD_ADDR_VAR 0 6
59649: PUSH
59650: LD_VAR 0 4
59654: PUSH
59655: LD_INT 1
59657: NEG
59658: PPUSH
59659: LD_INT 1
59661: PPUSH
59662: CALL_OW 12
59666: PLUS
59667: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
59668: LD_ADDR_VAR 0 7
59672: PUSH
59673: LD_VAR 0 5
59677: PUSH
59678: LD_INT 1
59680: NEG
59681: PPUSH
59682: LD_INT 1
59684: PPUSH
59685: CALL_OW 12
59689: PLUS
59690: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59691: LD_VAR 0 6
59695: PPUSH
59696: LD_VAR 0 7
59700: PPUSH
59701: CALL_OW 488
59705: NOT
59706: IFFALSE 59728
// begin _x := x ;
59708: LD_ADDR_VAR 0 6
59712: PUSH
59713: LD_VAR 0 4
59717: ST_TO_ADDR
// _y := y ;
59718: LD_ADDR_VAR 0 7
59722: PUSH
59723: LD_VAR 0 5
59727: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
59728: LD_ADDR_VAR 0 3
59732: PUSH
59733: LD_INT 1
59735: PPUSH
59736: LD_VAR 0 14
59740: PPUSH
59741: CALL_OW 12
59745: ST_TO_ADDR
// case i of 1 :
59746: LD_VAR 0 3
59750: PUSH
59751: LD_INT 1
59753: DOUBLE
59754: EQUAL
59755: IFTRUE 59759
59757: GO 59776
59759: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
59760: LD_VAR 0 1
59764: PPUSH
59765: LD_VAR 0 10
59769: PPUSH
59770: CALL_OW 115
59774: GO 59837
59776: LD_INT 2
59778: DOUBLE
59779: EQUAL
59780: IFTRUE 59784
59782: GO 59806
59784: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
59785: LD_VAR 0 1
59789: PPUSH
59790: LD_VAR 0 6
59794: PPUSH
59795: LD_VAR 0 7
59799: PPUSH
59800: CALL_OW 153
59804: GO 59837
59806: LD_INT 3
59808: DOUBLE
59809: EQUAL
59810: IFTRUE 59814
59812: GO 59836
59814: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
59815: LD_VAR 0 1
59819: PPUSH
59820: LD_VAR 0 6
59824: PPUSH
59825: LD_VAR 0 7
59829: PPUSH
59830: CALL_OW 154
59834: GO 59837
59836: POP
// end ;
59837: LD_VAR 0 2
59841: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
59842: LD_INT 0
59844: PPUSH
59845: PPUSH
59846: PPUSH
59847: PPUSH
59848: PPUSH
59849: PPUSH
// if not unit or not building then
59850: LD_VAR 0 1
59854: NOT
59855: PUSH
59856: LD_VAR 0 2
59860: NOT
59861: OR
59862: IFFALSE 59866
// exit ;
59864: GO 60024
// x := GetX ( building ) ;
59866: LD_ADDR_VAR 0 5
59870: PUSH
59871: LD_VAR 0 2
59875: PPUSH
59876: CALL_OW 250
59880: ST_TO_ADDR
// y := GetY ( building ) ;
59881: LD_ADDR_VAR 0 6
59885: PUSH
59886: LD_VAR 0 2
59890: PPUSH
59891: CALL_OW 251
59895: ST_TO_ADDR
// for i = 0 to 5 do
59896: LD_ADDR_VAR 0 4
59900: PUSH
59901: DOUBLE
59902: LD_INT 0
59904: DEC
59905: ST_TO_ADDR
59906: LD_INT 5
59908: PUSH
59909: FOR_TO
59910: IFFALSE 60022
// begin _x := ShiftX ( x , i , 3 ) ;
59912: LD_ADDR_VAR 0 7
59916: PUSH
59917: LD_VAR 0 5
59921: PPUSH
59922: LD_VAR 0 4
59926: PPUSH
59927: LD_INT 3
59929: PPUSH
59930: CALL_OW 272
59934: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
59935: LD_ADDR_VAR 0 8
59939: PUSH
59940: LD_VAR 0 6
59944: PPUSH
59945: LD_VAR 0 4
59949: PPUSH
59950: LD_INT 3
59952: PPUSH
59953: CALL_OW 273
59957: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
59958: LD_VAR 0 7
59962: PPUSH
59963: LD_VAR 0 8
59967: PPUSH
59968: CALL_OW 488
59972: NOT
59973: IFFALSE 59977
// continue ;
59975: GO 59909
// if HexInfo ( _x , _y ) = 0 then
59977: LD_VAR 0 7
59981: PPUSH
59982: LD_VAR 0 8
59986: PPUSH
59987: CALL_OW 428
59991: PUSH
59992: LD_INT 0
59994: EQUAL
59995: IFFALSE 60020
// begin ComMoveXY ( unit , _x , _y ) ;
59997: LD_VAR 0 1
60001: PPUSH
60002: LD_VAR 0 7
60006: PPUSH
60007: LD_VAR 0 8
60011: PPUSH
60012: CALL_OW 111
// exit ;
60016: POP
60017: POP
60018: GO 60024
// end ; end ;
60020: GO 59909
60022: POP
60023: POP
// end ;
60024: LD_VAR 0 3
60028: RET
// export function ScanBase ( side , base_area ) ; begin
60029: LD_INT 0
60031: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
60032: LD_ADDR_VAR 0 3
60036: PUSH
60037: LD_VAR 0 2
60041: PPUSH
60042: LD_INT 81
60044: PUSH
60045: LD_VAR 0 1
60049: PUSH
60050: EMPTY
60051: LIST
60052: LIST
60053: PPUSH
60054: CALL_OW 70
60058: ST_TO_ADDR
// end ;
60059: LD_VAR 0 3
60063: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
60064: LD_INT 0
60066: PPUSH
60067: PPUSH
60068: PPUSH
60069: PPUSH
// result := false ;
60070: LD_ADDR_VAR 0 2
60074: PUSH
60075: LD_INT 0
60077: ST_TO_ADDR
// side := GetSide ( unit ) ;
60078: LD_ADDR_VAR 0 3
60082: PUSH
60083: LD_VAR 0 1
60087: PPUSH
60088: CALL_OW 255
60092: ST_TO_ADDR
// nat := GetNation ( unit ) ;
60093: LD_ADDR_VAR 0 4
60097: PUSH
60098: LD_VAR 0 1
60102: PPUSH
60103: CALL_OW 248
60107: ST_TO_ADDR
// case nat of 1 :
60108: LD_VAR 0 4
60112: PUSH
60113: LD_INT 1
60115: DOUBLE
60116: EQUAL
60117: IFTRUE 60121
60119: GO 60132
60121: POP
// tech := tech_lassight ; 2 :
60122: LD_ADDR_VAR 0 5
60126: PUSH
60127: LD_INT 12
60129: ST_TO_ADDR
60130: GO 60171
60132: LD_INT 2
60134: DOUBLE
60135: EQUAL
60136: IFTRUE 60140
60138: GO 60151
60140: POP
// tech := tech_mortar ; 3 :
60141: LD_ADDR_VAR 0 5
60145: PUSH
60146: LD_INT 41
60148: ST_TO_ADDR
60149: GO 60171
60151: LD_INT 3
60153: DOUBLE
60154: EQUAL
60155: IFTRUE 60159
60157: GO 60170
60159: POP
// tech := tech_bazooka ; end ;
60160: LD_ADDR_VAR 0 5
60164: PUSH
60165: LD_INT 44
60167: ST_TO_ADDR
60168: GO 60171
60170: POP
// if Researched ( side , tech ) then
60171: LD_VAR 0 3
60175: PPUSH
60176: LD_VAR 0 5
60180: PPUSH
60181: CALL_OW 325
60185: IFFALSE 60212
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
60187: LD_ADDR_VAR 0 2
60191: PUSH
60192: LD_INT 5
60194: PUSH
60195: LD_INT 8
60197: PUSH
60198: LD_INT 9
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: LIST
60205: PUSH
60206: LD_VAR 0 4
60210: ARRAY
60211: ST_TO_ADDR
// end ;
60212: LD_VAR 0 2
60216: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
60217: LD_INT 0
60219: PPUSH
60220: PPUSH
60221: PPUSH
// if not mines then
60222: LD_VAR 0 2
60226: NOT
60227: IFFALSE 60231
// exit ;
60229: GO 60375
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
60231: LD_ADDR_VAR 0 5
60235: PUSH
60236: LD_INT 81
60238: PUSH
60239: LD_VAR 0 1
60243: PUSH
60244: EMPTY
60245: LIST
60246: LIST
60247: PUSH
60248: LD_INT 3
60250: PUSH
60251: LD_INT 21
60253: PUSH
60254: LD_INT 3
60256: PUSH
60257: EMPTY
60258: LIST
60259: LIST
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: PUSH
60265: EMPTY
60266: LIST
60267: LIST
60268: PPUSH
60269: CALL_OW 69
60273: ST_TO_ADDR
// for i in mines do
60274: LD_ADDR_VAR 0 4
60278: PUSH
60279: LD_VAR 0 2
60283: PUSH
60284: FOR_IN
60285: IFFALSE 60373
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
60287: LD_VAR 0 4
60291: PUSH
60292: LD_INT 1
60294: ARRAY
60295: PPUSH
60296: LD_VAR 0 4
60300: PUSH
60301: LD_INT 2
60303: ARRAY
60304: PPUSH
60305: CALL_OW 458
60309: NOT
60310: IFFALSE 60314
// continue ;
60312: GO 60284
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
60314: LD_VAR 0 4
60318: PUSH
60319: LD_INT 1
60321: ARRAY
60322: PPUSH
60323: LD_VAR 0 4
60327: PUSH
60328: LD_INT 2
60330: ARRAY
60331: PPUSH
60332: CALL_OW 428
60336: PUSH
60337: LD_VAR 0 5
60341: IN
60342: IFFALSE 60371
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
60344: LD_VAR 0 4
60348: PUSH
60349: LD_INT 1
60351: ARRAY
60352: PPUSH
60353: LD_VAR 0 4
60357: PUSH
60358: LD_INT 2
60360: ARRAY
60361: PPUSH
60362: LD_VAR 0 1
60366: PPUSH
60367: CALL_OW 456
// end ;
60371: GO 60284
60373: POP
60374: POP
// end ;
60375: LD_VAR 0 3
60379: RET
// export function Count ( array ) ; var i ; begin
60380: LD_INT 0
60382: PPUSH
60383: PPUSH
// result := 0 ;
60384: LD_ADDR_VAR 0 2
60388: PUSH
60389: LD_INT 0
60391: ST_TO_ADDR
// for i in array do
60392: LD_ADDR_VAR 0 3
60396: PUSH
60397: LD_VAR 0 1
60401: PUSH
60402: FOR_IN
60403: IFFALSE 60427
// if i then
60405: LD_VAR 0 3
60409: IFFALSE 60425
// result := result + 1 ;
60411: LD_ADDR_VAR 0 2
60415: PUSH
60416: LD_VAR 0 2
60420: PUSH
60421: LD_INT 1
60423: PLUS
60424: ST_TO_ADDR
60425: GO 60402
60427: POP
60428: POP
// end ;
60429: LD_VAR 0 2
60433: RET
// export function IsEmpty ( building ) ; begin
60434: LD_INT 0
60436: PPUSH
// if not building then
60437: LD_VAR 0 1
60441: NOT
60442: IFFALSE 60446
// exit ;
60444: GO 60489
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
60446: LD_ADDR_VAR 0 2
60450: PUSH
60451: LD_VAR 0 1
60455: PUSH
60456: LD_INT 22
60458: PUSH
60459: LD_VAR 0 1
60463: PPUSH
60464: CALL_OW 255
60468: PUSH
60469: EMPTY
60470: LIST
60471: LIST
60472: PUSH
60473: LD_INT 58
60475: PUSH
60476: EMPTY
60477: LIST
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: PPUSH
60483: CALL_OW 69
60487: IN
60488: ST_TO_ADDR
// end ;
60489: LD_VAR 0 2
60493: RET
// export function IsNotFull ( building ) ; begin
60494: LD_INT 0
60496: PPUSH
// if not building then
60497: LD_VAR 0 1
60501: NOT
60502: IFFALSE 60506
// exit ;
60504: GO 60525
// result := UnitsInside ( building ) < 6 ;
60506: LD_ADDR_VAR 0 2
60510: PUSH
60511: LD_VAR 0 1
60515: PPUSH
60516: CALL_OW 313
60520: PUSH
60521: LD_INT 6
60523: LESS
60524: ST_TO_ADDR
// end ;
60525: LD_VAR 0 2
60529: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
60530: LD_INT 0
60532: PPUSH
60533: PPUSH
60534: PPUSH
60535: PPUSH
// tmp := [ ] ;
60536: LD_ADDR_VAR 0 3
60540: PUSH
60541: EMPTY
60542: ST_TO_ADDR
// list := [ ] ;
60543: LD_ADDR_VAR 0 5
60547: PUSH
60548: EMPTY
60549: ST_TO_ADDR
// for i = 16 to 25 do
60550: LD_ADDR_VAR 0 4
60554: PUSH
60555: DOUBLE
60556: LD_INT 16
60558: DEC
60559: ST_TO_ADDR
60560: LD_INT 25
60562: PUSH
60563: FOR_TO
60564: IFFALSE 60637
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
60566: LD_ADDR_VAR 0 3
60570: PUSH
60571: LD_VAR 0 3
60575: PUSH
60576: LD_INT 22
60578: PUSH
60579: LD_VAR 0 1
60583: PPUSH
60584: CALL_OW 255
60588: PUSH
60589: EMPTY
60590: LIST
60591: LIST
60592: PUSH
60593: LD_INT 91
60595: PUSH
60596: LD_VAR 0 1
60600: PUSH
60601: LD_INT 6
60603: PUSH
60604: EMPTY
60605: LIST
60606: LIST
60607: LIST
60608: PUSH
60609: LD_INT 30
60611: PUSH
60612: LD_VAR 0 4
60616: PUSH
60617: EMPTY
60618: LIST
60619: LIST
60620: PUSH
60621: EMPTY
60622: LIST
60623: LIST
60624: LIST
60625: PUSH
60626: EMPTY
60627: LIST
60628: PPUSH
60629: CALL_OW 69
60633: ADD
60634: ST_TO_ADDR
60635: GO 60563
60637: POP
60638: POP
// for i = 1 to tmp do
60639: LD_ADDR_VAR 0 4
60643: PUSH
60644: DOUBLE
60645: LD_INT 1
60647: DEC
60648: ST_TO_ADDR
60649: LD_VAR 0 3
60653: PUSH
60654: FOR_TO
60655: IFFALSE 60743
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
60657: LD_ADDR_VAR 0 5
60661: PUSH
60662: LD_VAR 0 5
60666: PUSH
60667: LD_VAR 0 3
60671: PUSH
60672: LD_VAR 0 4
60676: ARRAY
60677: PPUSH
60678: CALL_OW 266
60682: PUSH
60683: LD_VAR 0 3
60687: PUSH
60688: LD_VAR 0 4
60692: ARRAY
60693: PPUSH
60694: CALL_OW 250
60698: PUSH
60699: LD_VAR 0 3
60703: PUSH
60704: LD_VAR 0 4
60708: ARRAY
60709: PPUSH
60710: CALL_OW 251
60714: PUSH
60715: LD_VAR 0 3
60719: PUSH
60720: LD_VAR 0 4
60724: ARRAY
60725: PPUSH
60726: CALL_OW 254
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: LIST
60735: LIST
60736: PUSH
60737: EMPTY
60738: LIST
60739: ADD
60740: ST_TO_ADDR
60741: GO 60654
60743: POP
60744: POP
// result := list ;
60745: LD_ADDR_VAR 0 2
60749: PUSH
60750: LD_VAR 0 5
60754: ST_TO_ADDR
// end ;
60755: LD_VAR 0 2
60759: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
60760: LD_INT 0
60762: PPUSH
60763: PPUSH
60764: PPUSH
60765: PPUSH
60766: PPUSH
60767: PPUSH
60768: PPUSH
// if not factory then
60769: LD_VAR 0 1
60773: NOT
60774: IFFALSE 60778
// exit ;
60776: GO 61371
// if control = control_apeman then
60778: LD_VAR 0 4
60782: PUSH
60783: LD_INT 5
60785: EQUAL
60786: IFFALSE 60895
// begin tmp := UnitsInside ( factory ) ;
60788: LD_ADDR_VAR 0 8
60792: PUSH
60793: LD_VAR 0 1
60797: PPUSH
60798: CALL_OW 313
60802: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
60803: LD_VAR 0 8
60807: PPUSH
60808: LD_INT 25
60810: PUSH
60811: LD_INT 12
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: PPUSH
60818: CALL_OW 72
60822: NOT
60823: IFFALSE 60833
// control := control_manual ;
60825: LD_ADDR_VAR 0 4
60829: PUSH
60830: LD_INT 1
60832: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
60833: LD_ADDR_VAR 0 8
60837: PUSH
60838: LD_VAR 0 1
60842: PPUSH
60843: CALL 60530 0 1
60847: ST_TO_ADDR
// if tmp then
60848: LD_VAR 0 8
60852: IFFALSE 60895
// begin for i in tmp do
60854: LD_ADDR_VAR 0 7
60858: PUSH
60859: LD_VAR 0 8
60863: PUSH
60864: FOR_IN
60865: IFFALSE 60893
// if i [ 1 ] = b_ext_radio then
60867: LD_VAR 0 7
60871: PUSH
60872: LD_INT 1
60874: ARRAY
60875: PUSH
60876: LD_INT 22
60878: EQUAL
60879: IFFALSE 60891
// begin control := control_remote ;
60881: LD_ADDR_VAR 0 4
60885: PUSH
60886: LD_INT 2
60888: ST_TO_ADDR
// break ;
60889: GO 60893
// end ;
60891: GO 60864
60893: POP
60894: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
60895: LD_VAR 0 1
60899: PPUSH
60900: LD_VAR 0 2
60904: PPUSH
60905: LD_VAR 0 3
60909: PPUSH
60910: LD_VAR 0 4
60914: PPUSH
60915: LD_VAR 0 5
60919: PPUSH
60920: CALL_OW 448
60924: IFFALSE 60959
// begin result := [ chassis , engine , control , weapon ] ;
60926: LD_ADDR_VAR 0 6
60930: PUSH
60931: LD_VAR 0 2
60935: PUSH
60936: LD_VAR 0 3
60940: PUSH
60941: LD_VAR 0 4
60945: PUSH
60946: LD_VAR 0 5
60950: PUSH
60951: EMPTY
60952: LIST
60953: LIST
60954: LIST
60955: LIST
60956: ST_TO_ADDR
// exit ;
60957: GO 61371
// end ; _chassis := AvailableChassisList ( factory ) ;
60959: LD_ADDR_VAR 0 9
60963: PUSH
60964: LD_VAR 0 1
60968: PPUSH
60969: CALL_OW 475
60973: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
60974: LD_ADDR_VAR 0 11
60978: PUSH
60979: LD_VAR 0 1
60983: PPUSH
60984: CALL_OW 476
60988: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
60989: LD_ADDR_VAR 0 12
60993: PUSH
60994: LD_VAR 0 1
60998: PPUSH
60999: CALL_OW 477
61003: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
61004: LD_ADDR_VAR 0 10
61008: PUSH
61009: LD_VAR 0 1
61013: PPUSH
61014: CALL_OW 478
61018: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
61019: LD_VAR 0 9
61023: NOT
61024: PUSH
61025: LD_VAR 0 11
61029: NOT
61030: OR
61031: PUSH
61032: LD_VAR 0 12
61036: NOT
61037: OR
61038: PUSH
61039: LD_VAR 0 10
61043: NOT
61044: OR
61045: IFFALSE 61080
// begin result := [ chassis , engine , control , weapon ] ;
61047: LD_ADDR_VAR 0 6
61051: PUSH
61052: LD_VAR 0 2
61056: PUSH
61057: LD_VAR 0 3
61061: PUSH
61062: LD_VAR 0 4
61066: PUSH
61067: LD_VAR 0 5
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: LIST
61076: LIST
61077: ST_TO_ADDR
// exit ;
61078: GO 61371
// end ; if not chassis in _chassis then
61080: LD_VAR 0 2
61084: PUSH
61085: LD_VAR 0 9
61089: IN
61090: NOT
61091: IFFALSE 61117
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
61093: LD_ADDR_VAR 0 2
61097: PUSH
61098: LD_VAR 0 9
61102: PUSH
61103: LD_INT 1
61105: PPUSH
61106: LD_VAR 0 9
61110: PPUSH
61111: CALL_OW 12
61115: ARRAY
61116: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
61117: LD_VAR 0 2
61121: PPUSH
61122: LD_VAR 0 3
61126: PPUSH
61127: CALL 61376 0 2
61131: NOT
61132: IFFALSE 61191
// repeat engine := _engine [ 1 ] ;
61134: LD_ADDR_VAR 0 3
61138: PUSH
61139: LD_VAR 0 11
61143: PUSH
61144: LD_INT 1
61146: ARRAY
61147: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
61148: LD_ADDR_VAR 0 11
61152: PUSH
61153: LD_VAR 0 11
61157: PPUSH
61158: LD_INT 1
61160: PPUSH
61161: CALL_OW 3
61165: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
61166: LD_VAR 0 2
61170: PPUSH
61171: LD_VAR 0 3
61175: PPUSH
61176: CALL 61376 0 2
61180: PUSH
61181: LD_VAR 0 11
61185: PUSH
61186: EMPTY
61187: EQUAL
61188: OR
61189: IFFALSE 61134
// if not control in _control then
61191: LD_VAR 0 4
61195: PUSH
61196: LD_VAR 0 12
61200: IN
61201: NOT
61202: IFFALSE 61228
// control := _control [ rand ( 1 , _control ) ] ;
61204: LD_ADDR_VAR 0 4
61208: PUSH
61209: LD_VAR 0 12
61213: PUSH
61214: LD_INT 1
61216: PPUSH
61217: LD_VAR 0 12
61221: PPUSH
61222: CALL_OW 12
61226: ARRAY
61227: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
61228: LD_VAR 0 2
61232: PPUSH
61233: LD_VAR 0 5
61237: PPUSH
61238: CALL 61596 0 2
61242: NOT
61243: IFFALSE 61302
// repeat weapon := _weapon [ 1 ] ;
61245: LD_ADDR_VAR 0 5
61249: PUSH
61250: LD_VAR 0 10
61254: PUSH
61255: LD_INT 1
61257: ARRAY
61258: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
61259: LD_ADDR_VAR 0 10
61263: PUSH
61264: LD_VAR 0 10
61268: PPUSH
61269: LD_INT 1
61271: PPUSH
61272: CALL_OW 3
61276: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
61277: LD_VAR 0 2
61281: PPUSH
61282: LD_VAR 0 5
61286: PPUSH
61287: CALL 61596 0 2
61291: PUSH
61292: LD_VAR 0 10
61296: PUSH
61297: EMPTY
61298: EQUAL
61299: OR
61300: IFFALSE 61245
// result := [ ] ;
61302: LD_ADDR_VAR 0 6
61306: PUSH
61307: EMPTY
61308: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
61309: LD_VAR 0 1
61313: PPUSH
61314: LD_VAR 0 2
61318: PPUSH
61319: LD_VAR 0 3
61323: PPUSH
61324: LD_VAR 0 4
61328: PPUSH
61329: LD_VAR 0 5
61333: PPUSH
61334: CALL_OW 448
61338: IFFALSE 61371
// result := [ chassis , engine , control , weapon ] ;
61340: LD_ADDR_VAR 0 6
61344: PUSH
61345: LD_VAR 0 2
61349: PUSH
61350: LD_VAR 0 3
61354: PUSH
61355: LD_VAR 0 4
61359: PUSH
61360: LD_VAR 0 5
61364: PUSH
61365: EMPTY
61366: LIST
61367: LIST
61368: LIST
61369: LIST
61370: ST_TO_ADDR
// end ;
61371: LD_VAR 0 6
61375: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
61376: LD_INT 0
61378: PPUSH
// if not chassis or not engine then
61379: LD_VAR 0 1
61383: NOT
61384: PUSH
61385: LD_VAR 0 2
61389: NOT
61390: OR
61391: IFFALSE 61395
// exit ;
61393: GO 61591
// case engine of engine_solar :
61395: LD_VAR 0 2
61399: PUSH
61400: LD_INT 2
61402: DOUBLE
61403: EQUAL
61404: IFTRUE 61408
61406: GO 61446
61408: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
61409: LD_ADDR_VAR 0 3
61413: PUSH
61414: LD_INT 11
61416: PUSH
61417: LD_INT 12
61419: PUSH
61420: LD_INT 13
61422: PUSH
61423: LD_INT 14
61425: PUSH
61426: LD_INT 1
61428: PUSH
61429: LD_INT 2
61431: PUSH
61432: LD_INT 3
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: LIST
61439: LIST
61440: LIST
61441: LIST
61442: LIST
61443: ST_TO_ADDR
61444: GO 61575
61446: LD_INT 1
61448: DOUBLE
61449: EQUAL
61450: IFTRUE 61454
61452: GO 61516
61454: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
61455: LD_ADDR_VAR 0 3
61459: PUSH
61460: LD_INT 11
61462: PUSH
61463: LD_INT 12
61465: PUSH
61466: LD_INT 13
61468: PUSH
61469: LD_INT 14
61471: PUSH
61472: LD_INT 1
61474: PUSH
61475: LD_INT 2
61477: PUSH
61478: LD_INT 3
61480: PUSH
61481: LD_INT 4
61483: PUSH
61484: LD_INT 5
61486: PUSH
61487: LD_INT 21
61489: PUSH
61490: LD_INT 23
61492: PUSH
61493: LD_INT 22
61495: PUSH
61496: LD_INT 24
61498: PUSH
61499: EMPTY
61500: LIST
61501: LIST
61502: LIST
61503: LIST
61504: LIST
61505: LIST
61506: LIST
61507: LIST
61508: LIST
61509: LIST
61510: LIST
61511: LIST
61512: LIST
61513: ST_TO_ADDR
61514: GO 61575
61516: LD_INT 3
61518: DOUBLE
61519: EQUAL
61520: IFTRUE 61524
61522: GO 61574
61524: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
61525: LD_ADDR_VAR 0 3
61529: PUSH
61530: LD_INT 13
61532: PUSH
61533: LD_INT 14
61535: PUSH
61536: LD_INT 2
61538: PUSH
61539: LD_INT 3
61541: PUSH
61542: LD_INT 4
61544: PUSH
61545: LD_INT 5
61547: PUSH
61548: LD_INT 21
61550: PUSH
61551: LD_INT 22
61553: PUSH
61554: LD_INT 23
61556: PUSH
61557: LD_INT 24
61559: PUSH
61560: EMPTY
61561: LIST
61562: LIST
61563: LIST
61564: LIST
61565: LIST
61566: LIST
61567: LIST
61568: LIST
61569: LIST
61570: LIST
61571: ST_TO_ADDR
61572: GO 61575
61574: POP
// result := ( chassis in result ) ;
61575: LD_ADDR_VAR 0 3
61579: PUSH
61580: LD_VAR 0 1
61584: PUSH
61585: LD_VAR 0 3
61589: IN
61590: ST_TO_ADDR
// end ;
61591: LD_VAR 0 3
61595: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
61596: LD_INT 0
61598: PPUSH
// if not chassis or not weapon then
61599: LD_VAR 0 1
61603: NOT
61604: PUSH
61605: LD_VAR 0 2
61609: NOT
61610: OR
61611: IFFALSE 61615
// exit ;
61613: GO 62641
// case weapon of us_machine_gun :
61615: LD_VAR 0 2
61619: PUSH
61620: LD_INT 2
61622: DOUBLE
61623: EQUAL
61624: IFTRUE 61628
61626: GO 61658
61628: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
61629: LD_ADDR_VAR 0 3
61633: PUSH
61634: LD_INT 1
61636: PUSH
61637: LD_INT 2
61639: PUSH
61640: LD_INT 3
61642: PUSH
61643: LD_INT 4
61645: PUSH
61646: LD_INT 5
61648: PUSH
61649: EMPTY
61650: LIST
61651: LIST
61652: LIST
61653: LIST
61654: LIST
61655: ST_TO_ADDR
61656: GO 62625
61658: LD_INT 3
61660: DOUBLE
61661: EQUAL
61662: IFTRUE 61666
61664: GO 61696
61666: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
61667: LD_ADDR_VAR 0 3
61671: PUSH
61672: LD_INT 1
61674: PUSH
61675: LD_INT 2
61677: PUSH
61678: LD_INT 3
61680: PUSH
61681: LD_INT 4
61683: PUSH
61684: LD_INT 5
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: LIST
61691: LIST
61692: LIST
61693: ST_TO_ADDR
61694: GO 62625
61696: LD_INT 11
61698: DOUBLE
61699: EQUAL
61700: IFTRUE 61704
61702: GO 61734
61704: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
61705: LD_ADDR_VAR 0 3
61709: PUSH
61710: LD_INT 1
61712: PUSH
61713: LD_INT 2
61715: PUSH
61716: LD_INT 3
61718: PUSH
61719: LD_INT 4
61721: PUSH
61722: LD_INT 5
61724: PUSH
61725: EMPTY
61726: LIST
61727: LIST
61728: LIST
61729: LIST
61730: LIST
61731: ST_TO_ADDR
61732: GO 62625
61734: LD_INT 4
61736: DOUBLE
61737: EQUAL
61738: IFTRUE 61742
61740: GO 61768
61742: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
61743: LD_ADDR_VAR 0 3
61747: PUSH
61748: LD_INT 2
61750: PUSH
61751: LD_INT 3
61753: PUSH
61754: LD_INT 4
61756: PUSH
61757: LD_INT 5
61759: PUSH
61760: EMPTY
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: ST_TO_ADDR
61766: GO 62625
61768: LD_INT 5
61770: DOUBLE
61771: EQUAL
61772: IFTRUE 61776
61774: GO 61802
61776: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
61777: LD_ADDR_VAR 0 3
61781: PUSH
61782: LD_INT 2
61784: PUSH
61785: LD_INT 3
61787: PUSH
61788: LD_INT 4
61790: PUSH
61791: LD_INT 5
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: LIST
61798: LIST
61799: ST_TO_ADDR
61800: GO 62625
61802: LD_INT 9
61804: DOUBLE
61805: EQUAL
61806: IFTRUE 61810
61808: GO 61836
61810: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
61811: LD_ADDR_VAR 0 3
61815: PUSH
61816: LD_INT 2
61818: PUSH
61819: LD_INT 3
61821: PUSH
61822: LD_INT 4
61824: PUSH
61825: LD_INT 5
61827: PUSH
61828: EMPTY
61829: LIST
61830: LIST
61831: LIST
61832: LIST
61833: ST_TO_ADDR
61834: GO 62625
61836: LD_INT 7
61838: DOUBLE
61839: EQUAL
61840: IFTRUE 61844
61842: GO 61870
61844: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
61845: LD_ADDR_VAR 0 3
61849: PUSH
61850: LD_INT 2
61852: PUSH
61853: LD_INT 3
61855: PUSH
61856: LD_INT 4
61858: PUSH
61859: LD_INT 5
61861: PUSH
61862: EMPTY
61863: LIST
61864: LIST
61865: LIST
61866: LIST
61867: ST_TO_ADDR
61868: GO 62625
61870: LD_INT 12
61872: DOUBLE
61873: EQUAL
61874: IFTRUE 61878
61876: GO 61904
61878: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
61879: LD_ADDR_VAR 0 3
61883: PUSH
61884: LD_INT 2
61886: PUSH
61887: LD_INT 3
61889: PUSH
61890: LD_INT 4
61892: PUSH
61893: LD_INT 5
61895: PUSH
61896: EMPTY
61897: LIST
61898: LIST
61899: LIST
61900: LIST
61901: ST_TO_ADDR
61902: GO 62625
61904: LD_INT 13
61906: DOUBLE
61907: EQUAL
61908: IFTRUE 61912
61910: GO 61938
61912: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
61913: LD_ADDR_VAR 0 3
61917: PUSH
61918: LD_INT 2
61920: PUSH
61921: LD_INT 3
61923: PUSH
61924: LD_INT 4
61926: PUSH
61927: LD_INT 5
61929: PUSH
61930: EMPTY
61931: LIST
61932: LIST
61933: LIST
61934: LIST
61935: ST_TO_ADDR
61936: GO 62625
61938: LD_INT 14
61940: DOUBLE
61941: EQUAL
61942: IFTRUE 61946
61944: GO 61964
61946: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
61947: LD_ADDR_VAR 0 3
61951: PUSH
61952: LD_INT 4
61954: PUSH
61955: LD_INT 5
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: ST_TO_ADDR
61962: GO 62625
61964: LD_INT 6
61966: DOUBLE
61967: EQUAL
61968: IFTRUE 61972
61970: GO 61990
61972: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
61973: LD_ADDR_VAR 0 3
61977: PUSH
61978: LD_INT 4
61980: PUSH
61981: LD_INT 5
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: ST_TO_ADDR
61988: GO 62625
61990: LD_INT 10
61992: DOUBLE
61993: EQUAL
61994: IFTRUE 61998
61996: GO 62016
61998: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
61999: LD_ADDR_VAR 0 3
62003: PUSH
62004: LD_INT 4
62006: PUSH
62007: LD_INT 5
62009: PUSH
62010: EMPTY
62011: LIST
62012: LIST
62013: ST_TO_ADDR
62014: GO 62625
62016: LD_INT 22
62018: DOUBLE
62019: EQUAL
62020: IFTRUE 62024
62022: GO 62050
62024: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
62025: LD_ADDR_VAR 0 3
62029: PUSH
62030: LD_INT 11
62032: PUSH
62033: LD_INT 12
62035: PUSH
62036: LD_INT 13
62038: PUSH
62039: LD_INT 14
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: LIST
62046: LIST
62047: ST_TO_ADDR
62048: GO 62625
62050: LD_INT 23
62052: DOUBLE
62053: EQUAL
62054: IFTRUE 62058
62056: GO 62084
62058: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
62059: LD_ADDR_VAR 0 3
62063: PUSH
62064: LD_INT 11
62066: PUSH
62067: LD_INT 12
62069: PUSH
62070: LD_INT 13
62072: PUSH
62073: LD_INT 14
62075: PUSH
62076: EMPTY
62077: LIST
62078: LIST
62079: LIST
62080: LIST
62081: ST_TO_ADDR
62082: GO 62625
62084: LD_INT 24
62086: DOUBLE
62087: EQUAL
62088: IFTRUE 62092
62090: GO 62118
62092: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
62093: LD_ADDR_VAR 0 3
62097: PUSH
62098: LD_INT 11
62100: PUSH
62101: LD_INT 12
62103: PUSH
62104: LD_INT 13
62106: PUSH
62107: LD_INT 14
62109: PUSH
62110: EMPTY
62111: LIST
62112: LIST
62113: LIST
62114: LIST
62115: ST_TO_ADDR
62116: GO 62625
62118: LD_INT 30
62120: DOUBLE
62121: EQUAL
62122: IFTRUE 62126
62124: GO 62152
62126: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
62127: LD_ADDR_VAR 0 3
62131: PUSH
62132: LD_INT 11
62134: PUSH
62135: LD_INT 12
62137: PUSH
62138: LD_INT 13
62140: PUSH
62141: LD_INT 14
62143: PUSH
62144: EMPTY
62145: LIST
62146: LIST
62147: LIST
62148: LIST
62149: ST_TO_ADDR
62150: GO 62625
62152: LD_INT 25
62154: DOUBLE
62155: EQUAL
62156: IFTRUE 62160
62158: GO 62178
62160: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
62161: LD_ADDR_VAR 0 3
62165: PUSH
62166: LD_INT 13
62168: PUSH
62169: LD_INT 14
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: ST_TO_ADDR
62176: GO 62625
62178: LD_INT 27
62180: DOUBLE
62181: EQUAL
62182: IFTRUE 62186
62184: GO 62204
62186: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
62187: LD_ADDR_VAR 0 3
62191: PUSH
62192: LD_INT 13
62194: PUSH
62195: LD_INT 14
62197: PUSH
62198: EMPTY
62199: LIST
62200: LIST
62201: ST_TO_ADDR
62202: GO 62625
62204: LD_INT 28
62206: DOUBLE
62207: EQUAL
62208: IFTRUE 62212
62210: GO 62230
62212: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
62213: LD_ADDR_VAR 0 3
62217: PUSH
62218: LD_INT 13
62220: PUSH
62221: LD_INT 14
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: ST_TO_ADDR
62228: GO 62625
62230: LD_INT 29
62232: DOUBLE
62233: EQUAL
62234: IFTRUE 62238
62236: GO 62256
62238: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
62239: LD_ADDR_VAR 0 3
62243: PUSH
62244: LD_INT 13
62246: PUSH
62247: LD_INT 14
62249: PUSH
62250: EMPTY
62251: LIST
62252: LIST
62253: ST_TO_ADDR
62254: GO 62625
62256: LD_INT 31
62258: DOUBLE
62259: EQUAL
62260: IFTRUE 62264
62262: GO 62282
62264: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
62265: LD_ADDR_VAR 0 3
62269: PUSH
62270: LD_INT 13
62272: PUSH
62273: LD_INT 14
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: ST_TO_ADDR
62280: GO 62625
62282: LD_INT 26
62284: DOUBLE
62285: EQUAL
62286: IFTRUE 62290
62288: GO 62308
62290: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
62291: LD_ADDR_VAR 0 3
62295: PUSH
62296: LD_INT 13
62298: PUSH
62299: LD_INT 14
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: ST_TO_ADDR
62306: GO 62625
62308: LD_INT 42
62310: DOUBLE
62311: EQUAL
62312: IFTRUE 62316
62314: GO 62342
62316: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
62317: LD_ADDR_VAR 0 3
62321: PUSH
62322: LD_INT 21
62324: PUSH
62325: LD_INT 22
62327: PUSH
62328: LD_INT 23
62330: PUSH
62331: LD_INT 24
62333: PUSH
62334: EMPTY
62335: LIST
62336: LIST
62337: LIST
62338: LIST
62339: ST_TO_ADDR
62340: GO 62625
62342: LD_INT 43
62344: DOUBLE
62345: EQUAL
62346: IFTRUE 62350
62348: GO 62376
62350: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
62351: LD_ADDR_VAR 0 3
62355: PUSH
62356: LD_INT 21
62358: PUSH
62359: LD_INT 22
62361: PUSH
62362: LD_INT 23
62364: PUSH
62365: LD_INT 24
62367: PUSH
62368: EMPTY
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: ST_TO_ADDR
62374: GO 62625
62376: LD_INT 44
62378: DOUBLE
62379: EQUAL
62380: IFTRUE 62384
62382: GO 62410
62384: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
62385: LD_ADDR_VAR 0 3
62389: PUSH
62390: LD_INT 21
62392: PUSH
62393: LD_INT 22
62395: PUSH
62396: LD_INT 23
62398: PUSH
62399: LD_INT 24
62401: PUSH
62402: EMPTY
62403: LIST
62404: LIST
62405: LIST
62406: LIST
62407: ST_TO_ADDR
62408: GO 62625
62410: LD_INT 45
62412: DOUBLE
62413: EQUAL
62414: IFTRUE 62418
62416: GO 62444
62418: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
62419: LD_ADDR_VAR 0 3
62423: PUSH
62424: LD_INT 21
62426: PUSH
62427: LD_INT 22
62429: PUSH
62430: LD_INT 23
62432: PUSH
62433: LD_INT 24
62435: PUSH
62436: EMPTY
62437: LIST
62438: LIST
62439: LIST
62440: LIST
62441: ST_TO_ADDR
62442: GO 62625
62444: LD_INT 49
62446: DOUBLE
62447: EQUAL
62448: IFTRUE 62452
62450: GO 62478
62452: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
62453: LD_ADDR_VAR 0 3
62457: PUSH
62458: LD_INT 21
62460: PUSH
62461: LD_INT 22
62463: PUSH
62464: LD_INT 23
62466: PUSH
62467: LD_INT 24
62469: PUSH
62470: EMPTY
62471: LIST
62472: LIST
62473: LIST
62474: LIST
62475: ST_TO_ADDR
62476: GO 62625
62478: LD_INT 51
62480: DOUBLE
62481: EQUAL
62482: IFTRUE 62486
62484: GO 62512
62486: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
62487: LD_ADDR_VAR 0 3
62491: PUSH
62492: LD_INT 21
62494: PUSH
62495: LD_INT 22
62497: PUSH
62498: LD_INT 23
62500: PUSH
62501: LD_INT 24
62503: PUSH
62504: EMPTY
62505: LIST
62506: LIST
62507: LIST
62508: LIST
62509: ST_TO_ADDR
62510: GO 62625
62512: LD_INT 52
62514: DOUBLE
62515: EQUAL
62516: IFTRUE 62520
62518: GO 62546
62520: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
62521: LD_ADDR_VAR 0 3
62525: PUSH
62526: LD_INT 21
62528: PUSH
62529: LD_INT 22
62531: PUSH
62532: LD_INT 23
62534: PUSH
62535: LD_INT 24
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: LIST
62542: LIST
62543: ST_TO_ADDR
62544: GO 62625
62546: LD_INT 53
62548: DOUBLE
62549: EQUAL
62550: IFTRUE 62554
62552: GO 62572
62554: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
62555: LD_ADDR_VAR 0 3
62559: PUSH
62560: LD_INT 23
62562: PUSH
62563: LD_INT 24
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: ST_TO_ADDR
62570: GO 62625
62572: LD_INT 46
62574: DOUBLE
62575: EQUAL
62576: IFTRUE 62580
62578: GO 62598
62580: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
62581: LD_ADDR_VAR 0 3
62585: PUSH
62586: LD_INT 23
62588: PUSH
62589: LD_INT 24
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: ST_TO_ADDR
62596: GO 62625
62598: LD_INT 47
62600: DOUBLE
62601: EQUAL
62602: IFTRUE 62606
62604: GO 62624
62606: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
62607: LD_ADDR_VAR 0 3
62611: PUSH
62612: LD_INT 23
62614: PUSH
62615: LD_INT 24
62617: PUSH
62618: EMPTY
62619: LIST
62620: LIST
62621: ST_TO_ADDR
62622: GO 62625
62624: POP
// result := ( chassis in result ) ;
62625: LD_ADDR_VAR 0 3
62629: PUSH
62630: LD_VAR 0 1
62634: PUSH
62635: LD_VAR 0 3
62639: IN
62640: ST_TO_ADDR
// end ;
62641: LD_VAR 0 3
62645: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
62646: LD_INT 0
62648: PPUSH
62649: PPUSH
62650: PPUSH
62651: PPUSH
62652: PPUSH
62653: PPUSH
62654: PPUSH
// result := array ;
62655: LD_ADDR_VAR 0 5
62659: PUSH
62660: LD_VAR 0 1
62664: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
62665: LD_VAR 0 1
62669: NOT
62670: PUSH
62671: LD_VAR 0 2
62675: NOT
62676: OR
62677: PUSH
62678: LD_VAR 0 3
62682: NOT
62683: OR
62684: PUSH
62685: LD_VAR 0 2
62689: PUSH
62690: LD_VAR 0 1
62694: GREATER
62695: OR
62696: PUSH
62697: LD_VAR 0 3
62701: PUSH
62702: LD_VAR 0 1
62706: GREATER
62707: OR
62708: IFFALSE 62712
// exit ;
62710: GO 63008
// if direction then
62712: LD_VAR 0 4
62716: IFFALSE 62780
// begin d := 1 ;
62718: LD_ADDR_VAR 0 9
62722: PUSH
62723: LD_INT 1
62725: ST_TO_ADDR
// if i_from > i_to then
62726: LD_VAR 0 2
62730: PUSH
62731: LD_VAR 0 3
62735: GREATER
62736: IFFALSE 62762
// length := ( array - i_from ) + i_to else
62738: LD_ADDR_VAR 0 11
62742: PUSH
62743: LD_VAR 0 1
62747: PUSH
62748: LD_VAR 0 2
62752: MINUS
62753: PUSH
62754: LD_VAR 0 3
62758: PLUS
62759: ST_TO_ADDR
62760: GO 62778
// length := i_to - i_from ;
62762: LD_ADDR_VAR 0 11
62766: PUSH
62767: LD_VAR 0 3
62771: PUSH
62772: LD_VAR 0 2
62776: MINUS
62777: ST_TO_ADDR
// end else
62778: GO 62841
// begin d := - 1 ;
62780: LD_ADDR_VAR 0 9
62784: PUSH
62785: LD_INT 1
62787: NEG
62788: ST_TO_ADDR
// if i_from > i_to then
62789: LD_VAR 0 2
62793: PUSH
62794: LD_VAR 0 3
62798: GREATER
62799: IFFALSE 62819
// length := i_from - i_to else
62801: LD_ADDR_VAR 0 11
62805: PUSH
62806: LD_VAR 0 2
62810: PUSH
62811: LD_VAR 0 3
62815: MINUS
62816: ST_TO_ADDR
62817: GO 62841
// length := ( array - i_to ) + i_from ;
62819: LD_ADDR_VAR 0 11
62823: PUSH
62824: LD_VAR 0 1
62828: PUSH
62829: LD_VAR 0 3
62833: MINUS
62834: PUSH
62835: LD_VAR 0 2
62839: PLUS
62840: ST_TO_ADDR
// end ; if not length then
62841: LD_VAR 0 11
62845: NOT
62846: IFFALSE 62850
// exit ;
62848: GO 63008
// tmp := array ;
62850: LD_ADDR_VAR 0 10
62854: PUSH
62855: LD_VAR 0 1
62859: ST_TO_ADDR
// for i = 1 to length do
62860: LD_ADDR_VAR 0 6
62864: PUSH
62865: DOUBLE
62866: LD_INT 1
62868: DEC
62869: ST_TO_ADDR
62870: LD_VAR 0 11
62874: PUSH
62875: FOR_TO
62876: IFFALSE 62996
// begin for j = 1 to array do
62878: LD_ADDR_VAR 0 7
62882: PUSH
62883: DOUBLE
62884: LD_INT 1
62886: DEC
62887: ST_TO_ADDR
62888: LD_VAR 0 1
62892: PUSH
62893: FOR_TO
62894: IFFALSE 62982
// begin k := j + d ;
62896: LD_ADDR_VAR 0 8
62900: PUSH
62901: LD_VAR 0 7
62905: PUSH
62906: LD_VAR 0 9
62910: PLUS
62911: ST_TO_ADDR
// if k > array then
62912: LD_VAR 0 8
62916: PUSH
62917: LD_VAR 0 1
62921: GREATER
62922: IFFALSE 62932
// k := 1 ;
62924: LD_ADDR_VAR 0 8
62928: PUSH
62929: LD_INT 1
62931: ST_TO_ADDR
// if not k then
62932: LD_VAR 0 8
62936: NOT
62937: IFFALSE 62949
// k := array ;
62939: LD_ADDR_VAR 0 8
62943: PUSH
62944: LD_VAR 0 1
62948: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
62949: LD_ADDR_VAR 0 10
62953: PUSH
62954: LD_VAR 0 10
62958: PPUSH
62959: LD_VAR 0 8
62963: PPUSH
62964: LD_VAR 0 1
62968: PUSH
62969: LD_VAR 0 7
62973: ARRAY
62974: PPUSH
62975: CALL_OW 1
62979: ST_TO_ADDR
// end ;
62980: GO 62893
62982: POP
62983: POP
// array := tmp ;
62984: LD_ADDR_VAR 0 1
62988: PUSH
62989: LD_VAR 0 10
62993: ST_TO_ADDR
// end ;
62994: GO 62875
62996: POP
62997: POP
// result := array ;
62998: LD_ADDR_VAR 0 5
63002: PUSH
63003: LD_VAR 0 1
63007: ST_TO_ADDR
// end ;
63008: LD_VAR 0 5
63012: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
63013: LD_INT 0
63015: PPUSH
63016: PPUSH
// result := 0 ;
63017: LD_ADDR_VAR 0 3
63021: PUSH
63022: LD_INT 0
63024: ST_TO_ADDR
// if not array or not value in array then
63025: LD_VAR 0 1
63029: NOT
63030: PUSH
63031: LD_VAR 0 2
63035: PUSH
63036: LD_VAR 0 1
63040: IN
63041: NOT
63042: OR
63043: IFFALSE 63047
// exit ;
63045: GO 63101
// for i = 1 to array do
63047: LD_ADDR_VAR 0 4
63051: PUSH
63052: DOUBLE
63053: LD_INT 1
63055: DEC
63056: ST_TO_ADDR
63057: LD_VAR 0 1
63061: PUSH
63062: FOR_TO
63063: IFFALSE 63099
// if value = array [ i ] then
63065: LD_VAR 0 2
63069: PUSH
63070: LD_VAR 0 1
63074: PUSH
63075: LD_VAR 0 4
63079: ARRAY
63080: EQUAL
63081: IFFALSE 63097
// begin result := i ;
63083: LD_ADDR_VAR 0 3
63087: PUSH
63088: LD_VAR 0 4
63092: ST_TO_ADDR
// exit ;
63093: POP
63094: POP
63095: GO 63101
// end ;
63097: GO 63062
63099: POP
63100: POP
// end ;
63101: LD_VAR 0 3
63105: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
63106: LD_INT 0
63108: PPUSH
// vc_chassis := chassis ;
63109: LD_ADDR_OWVAR 37
63113: PUSH
63114: LD_VAR 0 1
63118: ST_TO_ADDR
// vc_engine := engine ;
63119: LD_ADDR_OWVAR 39
63123: PUSH
63124: LD_VAR 0 2
63128: ST_TO_ADDR
// vc_control := control ;
63129: LD_ADDR_OWVAR 38
63133: PUSH
63134: LD_VAR 0 3
63138: ST_TO_ADDR
// vc_weapon := weapon ;
63139: LD_ADDR_OWVAR 40
63143: PUSH
63144: LD_VAR 0 4
63148: ST_TO_ADDR
// vc_fuel_battery := fuel ;
63149: LD_ADDR_OWVAR 41
63153: PUSH
63154: LD_VAR 0 5
63158: ST_TO_ADDR
// end ;
63159: LD_VAR 0 6
63163: RET
// export function WantPlant ( unit ) ; var task ; begin
63164: LD_INT 0
63166: PPUSH
63167: PPUSH
// result := false ;
63168: LD_ADDR_VAR 0 2
63172: PUSH
63173: LD_INT 0
63175: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
63176: LD_ADDR_VAR 0 3
63180: PUSH
63181: LD_VAR 0 1
63185: PPUSH
63186: CALL_OW 437
63190: ST_TO_ADDR
// if task then
63191: LD_VAR 0 3
63195: IFFALSE 63223
// if task [ 1 ] [ 1 ] = p then
63197: LD_VAR 0 3
63201: PUSH
63202: LD_INT 1
63204: ARRAY
63205: PUSH
63206: LD_INT 1
63208: ARRAY
63209: PUSH
63210: LD_STRING p
63212: EQUAL
63213: IFFALSE 63223
// result := true ;
63215: LD_ADDR_VAR 0 2
63219: PUSH
63220: LD_INT 1
63222: ST_TO_ADDR
// end ;
63223: LD_VAR 0 2
63227: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
63228: LD_INT 0
63230: PPUSH
63231: PPUSH
63232: PPUSH
63233: PPUSH
// if pos < 1 then
63234: LD_VAR 0 2
63238: PUSH
63239: LD_INT 1
63241: LESS
63242: IFFALSE 63246
// exit ;
63244: GO 63549
// if pos = 1 then
63246: LD_VAR 0 2
63250: PUSH
63251: LD_INT 1
63253: EQUAL
63254: IFFALSE 63287
// result := Replace ( arr , pos [ 1 ] , value ) else
63256: LD_ADDR_VAR 0 4
63260: PUSH
63261: LD_VAR 0 1
63265: PPUSH
63266: LD_VAR 0 2
63270: PUSH
63271: LD_INT 1
63273: ARRAY
63274: PPUSH
63275: LD_VAR 0 3
63279: PPUSH
63280: CALL_OW 1
63284: ST_TO_ADDR
63285: GO 63549
// begin tmp := arr ;
63287: LD_ADDR_VAR 0 6
63291: PUSH
63292: LD_VAR 0 1
63296: ST_TO_ADDR
// s_arr := [ tmp ] ;
63297: LD_ADDR_VAR 0 7
63301: PUSH
63302: LD_VAR 0 6
63306: PUSH
63307: EMPTY
63308: LIST
63309: ST_TO_ADDR
// for i = 1 to pos - 1 do
63310: LD_ADDR_VAR 0 5
63314: PUSH
63315: DOUBLE
63316: LD_INT 1
63318: DEC
63319: ST_TO_ADDR
63320: LD_VAR 0 2
63324: PUSH
63325: LD_INT 1
63327: MINUS
63328: PUSH
63329: FOR_TO
63330: IFFALSE 63375
// begin tmp := tmp [ pos [ i ] ] ;
63332: LD_ADDR_VAR 0 6
63336: PUSH
63337: LD_VAR 0 6
63341: PUSH
63342: LD_VAR 0 2
63346: PUSH
63347: LD_VAR 0 5
63351: ARRAY
63352: ARRAY
63353: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
63354: LD_ADDR_VAR 0 7
63358: PUSH
63359: LD_VAR 0 7
63363: PUSH
63364: LD_VAR 0 6
63368: PUSH
63369: EMPTY
63370: LIST
63371: ADD
63372: ST_TO_ADDR
// end ;
63373: GO 63329
63375: POP
63376: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
63377: LD_ADDR_VAR 0 6
63381: PUSH
63382: LD_VAR 0 6
63386: PPUSH
63387: LD_VAR 0 2
63391: PUSH
63392: LD_VAR 0 2
63396: ARRAY
63397: PPUSH
63398: LD_VAR 0 3
63402: PPUSH
63403: CALL_OW 1
63407: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
63408: LD_ADDR_VAR 0 7
63412: PUSH
63413: LD_VAR 0 7
63417: PPUSH
63418: LD_VAR 0 7
63422: PPUSH
63423: LD_VAR 0 6
63427: PPUSH
63428: CALL_OW 1
63432: ST_TO_ADDR
// for i = s_arr downto 2 do
63433: LD_ADDR_VAR 0 5
63437: PUSH
63438: DOUBLE
63439: LD_VAR 0 7
63443: INC
63444: ST_TO_ADDR
63445: LD_INT 2
63447: PUSH
63448: FOR_DOWNTO
63449: IFFALSE 63533
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
63451: LD_ADDR_VAR 0 6
63455: PUSH
63456: LD_VAR 0 7
63460: PUSH
63461: LD_VAR 0 5
63465: PUSH
63466: LD_INT 1
63468: MINUS
63469: ARRAY
63470: PPUSH
63471: LD_VAR 0 2
63475: PUSH
63476: LD_VAR 0 5
63480: PUSH
63481: LD_INT 1
63483: MINUS
63484: ARRAY
63485: PPUSH
63486: LD_VAR 0 7
63490: PUSH
63491: LD_VAR 0 5
63495: ARRAY
63496: PPUSH
63497: CALL_OW 1
63501: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
63502: LD_ADDR_VAR 0 7
63506: PUSH
63507: LD_VAR 0 7
63511: PPUSH
63512: LD_VAR 0 5
63516: PUSH
63517: LD_INT 1
63519: MINUS
63520: PPUSH
63521: LD_VAR 0 6
63525: PPUSH
63526: CALL_OW 1
63530: ST_TO_ADDR
// end ;
63531: GO 63448
63533: POP
63534: POP
// result := s_arr [ 1 ] ;
63535: LD_ADDR_VAR 0 4
63539: PUSH
63540: LD_VAR 0 7
63544: PUSH
63545: LD_INT 1
63547: ARRAY
63548: ST_TO_ADDR
// end ; end ;
63549: LD_VAR 0 4
63553: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
63554: LD_INT 0
63556: PPUSH
63557: PPUSH
// if not list then
63558: LD_VAR 0 1
63562: NOT
63563: IFFALSE 63567
// exit ;
63565: GO 63658
// i := list [ pos1 ] ;
63567: LD_ADDR_VAR 0 5
63571: PUSH
63572: LD_VAR 0 1
63576: PUSH
63577: LD_VAR 0 2
63581: ARRAY
63582: ST_TO_ADDR
// if not i then
63583: LD_VAR 0 5
63587: NOT
63588: IFFALSE 63592
// exit ;
63590: GO 63658
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
63592: LD_ADDR_VAR 0 1
63596: PUSH
63597: LD_VAR 0 1
63601: PPUSH
63602: LD_VAR 0 2
63606: PPUSH
63607: LD_VAR 0 1
63611: PUSH
63612: LD_VAR 0 3
63616: ARRAY
63617: PPUSH
63618: CALL_OW 1
63622: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
63623: LD_ADDR_VAR 0 1
63627: PUSH
63628: LD_VAR 0 1
63632: PPUSH
63633: LD_VAR 0 3
63637: PPUSH
63638: LD_VAR 0 5
63642: PPUSH
63643: CALL_OW 1
63647: ST_TO_ADDR
// result := list ;
63648: LD_ADDR_VAR 0 4
63652: PUSH
63653: LD_VAR 0 1
63657: ST_TO_ADDR
// end ;
63658: LD_VAR 0 4
63662: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
63663: LD_INT 0
63665: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
63666: LD_ADDR_VAR 0 5
63670: PUSH
63671: LD_VAR 0 1
63675: PPUSH
63676: CALL_OW 250
63680: PPUSH
63681: LD_VAR 0 1
63685: PPUSH
63686: CALL_OW 251
63690: PPUSH
63691: LD_VAR 0 2
63695: PPUSH
63696: LD_VAR 0 3
63700: PPUSH
63701: LD_VAR 0 4
63705: PPUSH
63706: CALL 63716 0 5
63710: ST_TO_ADDR
// end ;
63711: LD_VAR 0 5
63715: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
63716: LD_INT 0
63718: PPUSH
63719: PPUSH
63720: PPUSH
63721: PPUSH
// if not list then
63722: LD_VAR 0 3
63726: NOT
63727: IFFALSE 63731
// exit ;
63729: GO 64119
// result := [ ] ;
63731: LD_ADDR_VAR 0 6
63735: PUSH
63736: EMPTY
63737: ST_TO_ADDR
// for i in list do
63738: LD_ADDR_VAR 0 7
63742: PUSH
63743: LD_VAR 0 3
63747: PUSH
63748: FOR_IN
63749: IFFALSE 63951
// begin tmp := GetDistUnitXY ( i , x , y ) ;
63751: LD_ADDR_VAR 0 9
63755: PUSH
63756: LD_VAR 0 7
63760: PPUSH
63761: LD_VAR 0 1
63765: PPUSH
63766: LD_VAR 0 2
63770: PPUSH
63771: CALL_OW 297
63775: ST_TO_ADDR
// if not result then
63776: LD_VAR 0 6
63780: NOT
63781: IFFALSE 63807
// result := [ [ i , tmp ] ] else
63783: LD_ADDR_VAR 0 6
63787: PUSH
63788: LD_VAR 0 7
63792: PUSH
63793: LD_VAR 0 9
63797: PUSH
63798: EMPTY
63799: LIST
63800: LIST
63801: PUSH
63802: EMPTY
63803: LIST
63804: ST_TO_ADDR
63805: GO 63949
// begin if result [ result ] [ 2 ] < tmp then
63807: LD_VAR 0 6
63811: PUSH
63812: LD_VAR 0 6
63816: ARRAY
63817: PUSH
63818: LD_INT 2
63820: ARRAY
63821: PUSH
63822: LD_VAR 0 9
63826: LESS
63827: IFFALSE 63869
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
63829: LD_ADDR_VAR 0 6
63833: PUSH
63834: LD_VAR 0 6
63838: PPUSH
63839: LD_VAR 0 6
63843: PUSH
63844: LD_INT 1
63846: PLUS
63847: PPUSH
63848: LD_VAR 0 7
63852: PUSH
63853: LD_VAR 0 9
63857: PUSH
63858: EMPTY
63859: LIST
63860: LIST
63861: PPUSH
63862: CALL_OW 2
63866: ST_TO_ADDR
63867: GO 63949
// for j = 1 to result do
63869: LD_ADDR_VAR 0 8
63873: PUSH
63874: DOUBLE
63875: LD_INT 1
63877: DEC
63878: ST_TO_ADDR
63879: LD_VAR 0 6
63883: PUSH
63884: FOR_TO
63885: IFFALSE 63947
// begin if tmp < result [ j ] [ 2 ] then
63887: LD_VAR 0 9
63891: PUSH
63892: LD_VAR 0 6
63896: PUSH
63897: LD_VAR 0 8
63901: ARRAY
63902: PUSH
63903: LD_INT 2
63905: ARRAY
63906: LESS
63907: IFFALSE 63945
// begin result := Insert ( result , j , [ i , tmp ] ) ;
63909: LD_ADDR_VAR 0 6
63913: PUSH
63914: LD_VAR 0 6
63918: PPUSH
63919: LD_VAR 0 8
63923: PPUSH
63924: LD_VAR 0 7
63928: PUSH
63929: LD_VAR 0 9
63933: PUSH
63934: EMPTY
63935: LIST
63936: LIST
63937: PPUSH
63938: CALL_OW 2
63942: ST_TO_ADDR
// break ;
63943: GO 63947
// end ; end ;
63945: GO 63884
63947: POP
63948: POP
// end ; end ;
63949: GO 63748
63951: POP
63952: POP
// if result and not asc then
63953: LD_VAR 0 6
63957: PUSH
63958: LD_VAR 0 4
63962: NOT
63963: AND
63964: IFFALSE 64039
// begin tmp := result ;
63966: LD_ADDR_VAR 0 9
63970: PUSH
63971: LD_VAR 0 6
63975: ST_TO_ADDR
// for i = tmp downto 1 do
63976: LD_ADDR_VAR 0 7
63980: PUSH
63981: DOUBLE
63982: LD_VAR 0 9
63986: INC
63987: ST_TO_ADDR
63988: LD_INT 1
63990: PUSH
63991: FOR_DOWNTO
63992: IFFALSE 64037
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
63994: LD_ADDR_VAR 0 6
63998: PUSH
63999: LD_VAR 0 6
64003: PPUSH
64004: LD_VAR 0 9
64008: PUSH
64009: LD_VAR 0 7
64013: MINUS
64014: PUSH
64015: LD_INT 1
64017: PLUS
64018: PPUSH
64019: LD_VAR 0 9
64023: PUSH
64024: LD_VAR 0 7
64028: ARRAY
64029: PPUSH
64030: CALL_OW 1
64034: ST_TO_ADDR
64035: GO 63991
64037: POP
64038: POP
// end ; tmp := [ ] ;
64039: LD_ADDR_VAR 0 9
64043: PUSH
64044: EMPTY
64045: ST_TO_ADDR
// if mode then
64046: LD_VAR 0 5
64050: IFFALSE 64119
// begin for i = 1 to result do
64052: LD_ADDR_VAR 0 7
64056: PUSH
64057: DOUBLE
64058: LD_INT 1
64060: DEC
64061: ST_TO_ADDR
64062: LD_VAR 0 6
64066: PUSH
64067: FOR_TO
64068: IFFALSE 64107
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
64070: LD_ADDR_VAR 0 9
64074: PUSH
64075: LD_VAR 0 9
64079: PPUSH
64080: LD_VAR 0 7
64084: PPUSH
64085: LD_VAR 0 6
64089: PUSH
64090: LD_VAR 0 7
64094: ARRAY
64095: PUSH
64096: LD_INT 1
64098: ARRAY
64099: PPUSH
64100: CALL_OW 1
64104: ST_TO_ADDR
64105: GO 64067
64107: POP
64108: POP
// result := tmp ;
64109: LD_ADDR_VAR 0 6
64113: PUSH
64114: LD_VAR 0 9
64118: ST_TO_ADDR
// end ; end ;
64119: LD_VAR 0 6
64123: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
64124: LD_INT 0
64126: PPUSH
64127: PPUSH
64128: PPUSH
64129: PPUSH
64130: PPUSH
64131: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
64132: LD_ADDR_VAR 0 5
64136: PUSH
64137: LD_INT 0
64139: PUSH
64140: LD_INT 0
64142: PUSH
64143: LD_INT 0
64145: PUSH
64146: EMPTY
64147: PUSH
64148: EMPTY
64149: LIST
64150: LIST
64151: LIST
64152: LIST
64153: ST_TO_ADDR
// if not x or not y then
64154: LD_VAR 0 2
64158: NOT
64159: PUSH
64160: LD_VAR 0 3
64164: NOT
64165: OR
64166: IFFALSE 64170
// exit ;
64168: GO 65816
// if not range then
64170: LD_VAR 0 4
64174: NOT
64175: IFFALSE 64185
// range := 10 ;
64177: LD_ADDR_VAR 0 4
64181: PUSH
64182: LD_INT 10
64184: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64185: LD_ADDR_VAR 0 8
64189: PUSH
64190: LD_INT 81
64192: PUSH
64193: LD_VAR 0 1
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PUSH
64202: LD_INT 92
64204: PUSH
64205: LD_VAR 0 2
64209: PUSH
64210: LD_VAR 0 3
64214: PUSH
64215: LD_VAR 0 4
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: PUSH
64226: LD_INT 3
64228: PUSH
64229: LD_INT 21
64231: PUSH
64232: LD_INT 3
64234: PUSH
64235: EMPTY
64236: LIST
64237: LIST
64238: PUSH
64239: EMPTY
64240: LIST
64241: LIST
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: LIST
64247: PPUSH
64248: CALL_OW 69
64252: ST_TO_ADDR
// if not tmp then
64253: LD_VAR 0 8
64257: NOT
64258: IFFALSE 64262
// exit ;
64260: GO 65816
// for i in tmp do
64262: LD_ADDR_VAR 0 6
64266: PUSH
64267: LD_VAR 0 8
64271: PUSH
64272: FOR_IN
64273: IFFALSE 65791
// begin points := [ 0 , 0 , 0 ] ;
64275: LD_ADDR_VAR 0 9
64279: PUSH
64280: LD_INT 0
64282: PUSH
64283: LD_INT 0
64285: PUSH
64286: LD_INT 0
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: LIST
64293: ST_TO_ADDR
// bpoints := 1 ;
64294: LD_ADDR_VAR 0 10
64298: PUSH
64299: LD_INT 1
64301: ST_TO_ADDR
// case GetType ( i ) of unit_human :
64302: LD_VAR 0 6
64306: PPUSH
64307: CALL_OW 247
64311: PUSH
64312: LD_INT 1
64314: DOUBLE
64315: EQUAL
64316: IFTRUE 64320
64318: GO 64898
64320: POP
// begin if GetClass ( i ) = 1 then
64321: LD_VAR 0 6
64325: PPUSH
64326: CALL_OW 257
64330: PUSH
64331: LD_INT 1
64333: EQUAL
64334: IFFALSE 64355
// points := [ 10 , 5 , 3 ] ;
64336: LD_ADDR_VAR 0 9
64340: PUSH
64341: LD_INT 10
64343: PUSH
64344: LD_INT 5
64346: PUSH
64347: LD_INT 3
64349: PUSH
64350: EMPTY
64351: LIST
64352: LIST
64353: LIST
64354: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
64355: LD_VAR 0 6
64359: PPUSH
64360: CALL_OW 257
64364: PUSH
64365: LD_INT 2
64367: PUSH
64368: LD_INT 3
64370: PUSH
64371: LD_INT 4
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: LIST
64378: IN
64379: IFFALSE 64400
// points := [ 3 , 2 , 1 ] ;
64381: LD_ADDR_VAR 0 9
64385: PUSH
64386: LD_INT 3
64388: PUSH
64389: LD_INT 2
64391: PUSH
64392: LD_INT 1
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: LIST
64399: ST_TO_ADDR
// if GetClass ( i ) = 5 then
64400: LD_VAR 0 6
64404: PPUSH
64405: CALL_OW 257
64409: PUSH
64410: LD_INT 5
64412: EQUAL
64413: IFFALSE 64434
// points := [ 130 , 5 , 2 ] ;
64415: LD_ADDR_VAR 0 9
64419: PUSH
64420: LD_INT 130
64422: PUSH
64423: LD_INT 5
64425: PUSH
64426: LD_INT 2
64428: PUSH
64429: EMPTY
64430: LIST
64431: LIST
64432: LIST
64433: ST_TO_ADDR
// if GetClass ( i ) = 8 then
64434: LD_VAR 0 6
64438: PPUSH
64439: CALL_OW 257
64443: PUSH
64444: LD_INT 8
64446: EQUAL
64447: IFFALSE 64468
// points := [ 35 , 35 , 30 ] ;
64449: LD_ADDR_VAR 0 9
64453: PUSH
64454: LD_INT 35
64456: PUSH
64457: LD_INT 35
64459: PUSH
64460: LD_INT 30
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: LIST
64467: ST_TO_ADDR
// if GetClass ( i ) = 9 then
64468: LD_VAR 0 6
64472: PPUSH
64473: CALL_OW 257
64477: PUSH
64478: LD_INT 9
64480: EQUAL
64481: IFFALSE 64502
// points := [ 20 , 55 , 40 ] ;
64483: LD_ADDR_VAR 0 9
64487: PUSH
64488: LD_INT 20
64490: PUSH
64491: LD_INT 55
64493: PUSH
64494: LD_INT 40
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: LIST
64501: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
64502: LD_VAR 0 6
64506: PPUSH
64507: CALL_OW 257
64511: PUSH
64512: LD_INT 12
64514: PUSH
64515: LD_INT 16
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: IN
64522: IFFALSE 64543
// points := [ 5 , 3 , 2 ] ;
64524: LD_ADDR_VAR 0 9
64528: PUSH
64529: LD_INT 5
64531: PUSH
64532: LD_INT 3
64534: PUSH
64535: LD_INT 2
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: LIST
64542: ST_TO_ADDR
// if GetClass ( i ) = 17 then
64543: LD_VAR 0 6
64547: PPUSH
64548: CALL_OW 257
64552: PUSH
64553: LD_INT 17
64555: EQUAL
64556: IFFALSE 64577
// points := [ 100 , 50 , 75 ] ;
64558: LD_ADDR_VAR 0 9
64562: PUSH
64563: LD_INT 100
64565: PUSH
64566: LD_INT 50
64568: PUSH
64569: LD_INT 75
64571: PUSH
64572: EMPTY
64573: LIST
64574: LIST
64575: LIST
64576: ST_TO_ADDR
// if GetClass ( i ) = 15 then
64577: LD_VAR 0 6
64581: PPUSH
64582: CALL_OW 257
64586: PUSH
64587: LD_INT 15
64589: EQUAL
64590: IFFALSE 64611
// points := [ 10 , 5 , 3 ] ;
64592: LD_ADDR_VAR 0 9
64596: PUSH
64597: LD_INT 10
64599: PUSH
64600: LD_INT 5
64602: PUSH
64603: LD_INT 3
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: LIST
64610: ST_TO_ADDR
// if GetClass ( i ) = 14 then
64611: LD_VAR 0 6
64615: PPUSH
64616: CALL_OW 257
64620: PUSH
64621: LD_INT 14
64623: EQUAL
64624: IFFALSE 64645
// points := [ 10 , 0 , 0 ] ;
64626: LD_ADDR_VAR 0 9
64630: PUSH
64631: LD_INT 10
64633: PUSH
64634: LD_INT 0
64636: PUSH
64637: LD_INT 0
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: LIST
64644: ST_TO_ADDR
// if GetClass ( i ) = 11 then
64645: LD_VAR 0 6
64649: PPUSH
64650: CALL_OW 257
64654: PUSH
64655: LD_INT 11
64657: EQUAL
64658: IFFALSE 64679
// points := [ 30 , 10 , 5 ] ;
64660: LD_ADDR_VAR 0 9
64664: PUSH
64665: LD_INT 30
64667: PUSH
64668: LD_INT 10
64670: PUSH
64671: LD_INT 5
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: LIST
64678: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
64679: LD_VAR 0 1
64683: PPUSH
64684: LD_INT 5
64686: PPUSH
64687: CALL_OW 321
64691: PUSH
64692: LD_INT 2
64694: EQUAL
64695: IFFALSE 64712
// bpoints := bpoints * 1.8 ;
64697: LD_ADDR_VAR 0 10
64701: PUSH
64702: LD_VAR 0 10
64706: PUSH
64707: LD_REAL  1.80000000000000E+0000
64710: MUL
64711: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
64712: LD_VAR 0 6
64716: PPUSH
64717: CALL_OW 257
64721: PUSH
64722: LD_INT 1
64724: PUSH
64725: LD_INT 2
64727: PUSH
64728: LD_INT 3
64730: PUSH
64731: LD_INT 4
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: LIST
64738: LIST
64739: IN
64740: PUSH
64741: LD_VAR 0 1
64745: PPUSH
64746: LD_INT 51
64748: PPUSH
64749: CALL_OW 321
64753: PUSH
64754: LD_INT 2
64756: EQUAL
64757: AND
64758: IFFALSE 64775
// bpoints := bpoints * 1.2 ;
64760: LD_ADDR_VAR 0 10
64764: PUSH
64765: LD_VAR 0 10
64769: PUSH
64770: LD_REAL  1.20000000000000E+0000
64773: MUL
64774: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
64775: LD_VAR 0 6
64779: PPUSH
64780: CALL_OW 257
64784: PUSH
64785: LD_INT 5
64787: PUSH
64788: LD_INT 7
64790: PUSH
64791: LD_INT 9
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: LIST
64798: IN
64799: PUSH
64800: LD_VAR 0 1
64804: PPUSH
64805: LD_INT 52
64807: PPUSH
64808: CALL_OW 321
64812: PUSH
64813: LD_INT 2
64815: EQUAL
64816: AND
64817: IFFALSE 64834
// bpoints := bpoints * 1.5 ;
64819: LD_ADDR_VAR 0 10
64823: PUSH
64824: LD_VAR 0 10
64828: PUSH
64829: LD_REAL  1.50000000000000E+0000
64832: MUL
64833: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
64834: LD_VAR 0 1
64838: PPUSH
64839: LD_INT 66
64841: PPUSH
64842: CALL_OW 321
64846: PUSH
64847: LD_INT 2
64849: EQUAL
64850: IFFALSE 64867
// bpoints := bpoints * 1.1 ;
64852: LD_ADDR_VAR 0 10
64856: PUSH
64857: LD_VAR 0 10
64861: PUSH
64862: LD_REAL  1.10000000000000E+0000
64865: MUL
64866: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
64867: LD_ADDR_VAR 0 10
64871: PUSH
64872: LD_VAR 0 10
64876: PUSH
64877: LD_VAR 0 6
64881: PPUSH
64882: LD_INT 1
64884: PPUSH
64885: CALL_OW 259
64889: PUSH
64890: LD_REAL  1.15000000000000E+0000
64893: MUL
64894: MUL
64895: ST_TO_ADDR
// end ; unit_vehicle :
64896: GO 65720
64898: LD_INT 2
64900: DOUBLE
64901: EQUAL
64902: IFTRUE 64906
64904: GO 65708
64906: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
64907: LD_VAR 0 6
64911: PPUSH
64912: CALL_OW 264
64916: PUSH
64917: LD_INT 2
64919: PUSH
64920: LD_INT 42
64922: PUSH
64923: LD_INT 24
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: LIST
64930: IN
64931: IFFALSE 64952
// points := [ 25 , 5 , 3 ] ;
64933: LD_ADDR_VAR 0 9
64937: PUSH
64938: LD_INT 25
64940: PUSH
64941: LD_INT 5
64943: PUSH
64944: LD_INT 3
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: LIST
64951: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
64952: LD_VAR 0 6
64956: PPUSH
64957: CALL_OW 264
64961: PUSH
64962: LD_INT 4
64964: PUSH
64965: LD_INT 43
64967: PUSH
64968: LD_INT 25
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: LIST
64975: IN
64976: IFFALSE 64997
// points := [ 40 , 15 , 5 ] ;
64978: LD_ADDR_VAR 0 9
64982: PUSH
64983: LD_INT 40
64985: PUSH
64986: LD_INT 15
64988: PUSH
64989: LD_INT 5
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: LIST
64996: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
64997: LD_VAR 0 6
65001: PPUSH
65002: CALL_OW 264
65006: PUSH
65007: LD_INT 3
65009: PUSH
65010: LD_INT 23
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: IN
65017: IFFALSE 65038
// points := [ 7 , 25 , 8 ] ;
65019: LD_ADDR_VAR 0 9
65023: PUSH
65024: LD_INT 7
65026: PUSH
65027: LD_INT 25
65029: PUSH
65030: LD_INT 8
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: LIST
65037: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
65038: LD_VAR 0 6
65042: PPUSH
65043: CALL_OW 264
65047: PUSH
65048: LD_INT 5
65050: PUSH
65051: LD_INT 27
65053: PUSH
65054: LD_INT 44
65056: PUSH
65057: EMPTY
65058: LIST
65059: LIST
65060: LIST
65061: IN
65062: IFFALSE 65083
// points := [ 14 , 50 , 16 ] ;
65064: LD_ADDR_VAR 0 9
65068: PUSH
65069: LD_INT 14
65071: PUSH
65072: LD_INT 50
65074: PUSH
65075: LD_INT 16
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: LIST
65082: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
65083: LD_VAR 0 6
65087: PPUSH
65088: CALL_OW 264
65092: PUSH
65093: LD_INT 6
65095: PUSH
65096: LD_INT 46
65098: PUSH
65099: EMPTY
65100: LIST
65101: LIST
65102: IN
65103: IFFALSE 65124
// points := [ 32 , 120 , 70 ] ;
65105: LD_ADDR_VAR 0 9
65109: PUSH
65110: LD_INT 32
65112: PUSH
65113: LD_INT 120
65115: PUSH
65116: LD_INT 70
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: LIST
65123: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
65124: LD_VAR 0 6
65128: PPUSH
65129: CALL_OW 264
65133: PUSH
65134: LD_INT 7
65136: PUSH
65137: LD_INT 28
65139: PUSH
65140: LD_INT 45
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: LIST
65147: IN
65148: IFFALSE 65169
// points := [ 35 , 20 , 45 ] ;
65150: LD_ADDR_VAR 0 9
65154: PUSH
65155: LD_INT 35
65157: PUSH
65158: LD_INT 20
65160: PUSH
65161: LD_INT 45
65163: PUSH
65164: EMPTY
65165: LIST
65166: LIST
65167: LIST
65168: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
65169: LD_VAR 0 6
65173: PPUSH
65174: CALL_OW 264
65178: PUSH
65179: LD_INT 47
65181: PUSH
65182: EMPTY
65183: LIST
65184: IN
65185: IFFALSE 65206
// points := [ 67 , 45 , 75 ] ;
65187: LD_ADDR_VAR 0 9
65191: PUSH
65192: LD_INT 67
65194: PUSH
65195: LD_INT 45
65197: PUSH
65198: LD_INT 75
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: LIST
65205: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
65206: LD_VAR 0 6
65210: PPUSH
65211: CALL_OW 264
65215: PUSH
65216: LD_INT 26
65218: PUSH
65219: EMPTY
65220: LIST
65221: IN
65222: IFFALSE 65243
// points := [ 120 , 30 , 80 ] ;
65224: LD_ADDR_VAR 0 9
65228: PUSH
65229: LD_INT 120
65231: PUSH
65232: LD_INT 30
65234: PUSH
65235: LD_INT 80
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: LIST
65242: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
65243: LD_VAR 0 6
65247: PPUSH
65248: CALL_OW 264
65252: PUSH
65253: LD_INT 22
65255: PUSH
65256: EMPTY
65257: LIST
65258: IN
65259: IFFALSE 65280
// points := [ 40 , 1 , 1 ] ;
65261: LD_ADDR_VAR 0 9
65265: PUSH
65266: LD_INT 40
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: LD_INT 1
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: LIST
65279: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
65280: LD_VAR 0 6
65284: PPUSH
65285: CALL_OW 264
65289: PUSH
65290: LD_INT 29
65292: PUSH
65293: EMPTY
65294: LIST
65295: IN
65296: IFFALSE 65317
// points := [ 70 , 200 , 400 ] ;
65298: LD_ADDR_VAR 0 9
65302: PUSH
65303: LD_INT 70
65305: PUSH
65306: LD_INT 200
65308: PUSH
65309: LD_INT 400
65311: PUSH
65312: EMPTY
65313: LIST
65314: LIST
65315: LIST
65316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
65317: LD_VAR 0 6
65321: PPUSH
65322: CALL_OW 264
65326: PUSH
65327: LD_INT 14
65329: PUSH
65330: LD_INT 53
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: IN
65337: IFFALSE 65358
// points := [ 40 , 10 , 20 ] ;
65339: LD_ADDR_VAR 0 9
65343: PUSH
65344: LD_INT 40
65346: PUSH
65347: LD_INT 10
65349: PUSH
65350: LD_INT 20
65352: PUSH
65353: EMPTY
65354: LIST
65355: LIST
65356: LIST
65357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
65358: LD_VAR 0 6
65362: PPUSH
65363: CALL_OW 264
65367: PUSH
65368: LD_INT 9
65370: PUSH
65371: EMPTY
65372: LIST
65373: IN
65374: IFFALSE 65395
// points := [ 5 , 70 , 20 ] ;
65376: LD_ADDR_VAR 0 9
65380: PUSH
65381: LD_INT 5
65383: PUSH
65384: LD_INT 70
65386: PUSH
65387: LD_INT 20
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: LIST
65394: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
65395: LD_VAR 0 6
65399: PPUSH
65400: CALL_OW 264
65404: PUSH
65405: LD_INT 10
65407: PUSH
65408: EMPTY
65409: LIST
65410: IN
65411: IFFALSE 65432
// points := [ 35 , 110 , 70 ] ;
65413: LD_ADDR_VAR 0 9
65417: PUSH
65418: LD_INT 35
65420: PUSH
65421: LD_INT 110
65423: PUSH
65424: LD_INT 70
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: LIST
65431: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
65432: LD_VAR 0 6
65436: PPUSH
65437: CALL_OW 265
65441: PUSH
65442: LD_INT 25
65444: EQUAL
65445: IFFALSE 65466
// points := [ 80 , 65 , 100 ] ;
65447: LD_ADDR_VAR 0 9
65451: PUSH
65452: LD_INT 80
65454: PUSH
65455: LD_INT 65
65457: PUSH
65458: LD_INT 100
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: LIST
65465: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
65466: LD_VAR 0 6
65470: PPUSH
65471: CALL_OW 263
65475: PUSH
65476: LD_INT 1
65478: EQUAL
65479: IFFALSE 65514
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
65481: LD_ADDR_VAR 0 10
65485: PUSH
65486: LD_VAR 0 10
65490: PUSH
65491: LD_VAR 0 6
65495: PPUSH
65496: CALL_OW 311
65500: PPUSH
65501: LD_INT 3
65503: PPUSH
65504: CALL_OW 259
65508: PUSH
65509: LD_INT 4
65511: MUL
65512: MUL
65513: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
65514: LD_VAR 0 6
65518: PPUSH
65519: CALL_OW 263
65523: PUSH
65524: LD_INT 2
65526: EQUAL
65527: IFFALSE 65578
// begin j := IsControledBy ( i ) ;
65529: LD_ADDR_VAR 0 7
65533: PUSH
65534: LD_VAR 0 6
65538: PPUSH
65539: CALL_OW 312
65543: ST_TO_ADDR
// if j then
65544: LD_VAR 0 7
65548: IFFALSE 65578
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
65550: LD_ADDR_VAR 0 10
65554: PUSH
65555: LD_VAR 0 10
65559: PUSH
65560: LD_VAR 0 7
65564: PPUSH
65565: LD_INT 3
65567: PPUSH
65568: CALL_OW 259
65572: PUSH
65573: LD_INT 3
65575: MUL
65576: MUL
65577: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
65578: LD_VAR 0 6
65582: PPUSH
65583: CALL_OW 264
65587: PUSH
65588: LD_INT 5
65590: PUSH
65591: LD_INT 6
65593: PUSH
65594: LD_INT 46
65596: PUSH
65597: LD_INT 44
65599: PUSH
65600: LD_INT 47
65602: PUSH
65603: LD_INT 45
65605: PUSH
65606: LD_INT 28
65608: PUSH
65609: LD_INT 7
65611: PUSH
65612: LD_INT 27
65614: PUSH
65615: LD_INT 29
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: IN
65630: PUSH
65631: LD_VAR 0 1
65635: PPUSH
65636: LD_INT 52
65638: PPUSH
65639: CALL_OW 321
65643: PUSH
65644: LD_INT 2
65646: EQUAL
65647: AND
65648: IFFALSE 65665
// bpoints := bpoints * 1.2 ;
65650: LD_ADDR_VAR 0 10
65654: PUSH
65655: LD_VAR 0 10
65659: PUSH
65660: LD_REAL  1.20000000000000E+0000
65663: MUL
65664: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
65665: LD_VAR 0 6
65669: PPUSH
65670: CALL_OW 264
65674: PUSH
65675: LD_INT 6
65677: PUSH
65678: LD_INT 46
65680: PUSH
65681: LD_INT 47
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: LIST
65688: IN
65689: IFFALSE 65706
// bpoints := bpoints * 1.2 ;
65691: LD_ADDR_VAR 0 10
65695: PUSH
65696: LD_VAR 0 10
65700: PUSH
65701: LD_REAL  1.20000000000000E+0000
65704: MUL
65705: ST_TO_ADDR
// end ; unit_building :
65706: GO 65720
65708: LD_INT 3
65710: DOUBLE
65711: EQUAL
65712: IFTRUE 65716
65714: GO 65719
65716: POP
// ; end ;
65717: GO 65720
65719: POP
// for j = 1 to 3 do
65720: LD_ADDR_VAR 0 7
65724: PUSH
65725: DOUBLE
65726: LD_INT 1
65728: DEC
65729: ST_TO_ADDR
65730: LD_INT 3
65732: PUSH
65733: FOR_TO
65734: IFFALSE 65787
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
65736: LD_ADDR_VAR 0 5
65740: PUSH
65741: LD_VAR 0 5
65745: PPUSH
65746: LD_VAR 0 7
65750: PPUSH
65751: LD_VAR 0 5
65755: PUSH
65756: LD_VAR 0 7
65760: ARRAY
65761: PUSH
65762: LD_VAR 0 9
65766: PUSH
65767: LD_VAR 0 7
65771: ARRAY
65772: PUSH
65773: LD_VAR 0 10
65777: MUL
65778: PLUS
65779: PPUSH
65780: CALL_OW 1
65784: ST_TO_ADDR
65785: GO 65733
65787: POP
65788: POP
// end ;
65789: GO 64272
65791: POP
65792: POP
// result := Replace ( result , 4 , tmp ) ;
65793: LD_ADDR_VAR 0 5
65797: PUSH
65798: LD_VAR 0 5
65802: PPUSH
65803: LD_INT 4
65805: PPUSH
65806: LD_VAR 0 8
65810: PPUSH
65811: CALL_OW 1
65815: ST_TO_ADDR
// end ;
65816: LD_VAR 0 5
65820: RET
// export function DangerAtRange ( unit , range ) ; begin
65821: LD_INT 0
65823: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
65824: LD_ADDR_VAR 0 3
65828: PUSH
65829: LD_VAR 0 1
65833: PPUSH
65834: CALL_OW 255
65838: PPUSH
65839: LD_VAR 0 1
65843: PPUSH
65844: CALL_OW 250
65848: PPUSH
65849: LD_VAR 0 1
65853: PPUSH
65854: CALL_OW 251
65858: PPUSH
65859: LD_VAR 0 2
65863: PPUSH
65864: CALL 64124 0 4
65868: ST_TO_ADDR
// end ;
65869: LD_VAR 0 3
65873: RET
// export function DangerInArea ( side , area ) ; begin
65874: LD_INT 0
65876: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
65877: LD_ADDR_VAR 0 3
65881: PUSH
65882: LD_VAR 0 2
65886: PPUSH
65887: LD_INT 81
65889: PUSH
65890: LD_VAR 0 1
65894: PUSH
65895: EMPTY
65896: LIST
65897: LIST
65898: PPUSH
65899: CALL_OW 70
65903: ST_TO_ADDR
// end ;
65904: LD_VAR 0 3
65908: RET
// export function IsExtension ( b ) ; begin
65909: LD_INT 0
65911: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
65912: LD_ADDR_VAR 0 2
65916: PUSH
65917: LD_VAR 0 1
65921: PUSH
65922: LD_INT 23
65924: PUSH
65925: LD_INT 20
65927: PUSH
65928: LD_INT 22
65930: PUSH
65931: LD_INT 17
65933: PUSH
65934: LD_INT 24
65936: PUSH
65937: LD_INT 21
65939: PUSH
65940: LD_INT 19
65942: PUSH
65943: LD_INT 16
65945: PUSH
65946: LD_INT 25
65948: PUSH
65949: LD_INT 18
65951: PUSH
65952: EMPTY
65953: LIST
65954: LIST
65955: LIST
65956: LIST
65957: LIST
65958: LIST
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: IN
65964: ST_TO_ADDR
// end ;
65965: LD_VAR 0 2
65969: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
65970: LD_INT 0
65972: PPUSH
65973: PPUSH
65974: PPUSH
// result := [ ] ;
65975: LD_ADDR_VAR 0 3
65979: PUSH
65980: EMPTY
65981: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
65982: LD_ADDR_VAR 0 4
65986: PUSH
65987: LD_VAR 0 2
65991: PPUSH
65992: LD_INT 21
65994: PUSH
65995: LD_INT 3
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PPUSH
66002: CALL_OW 70
66006: ST_TO_ADDR
// if not tmp then
66007: LD_VAR 0 4
66011: NOT
66012: IFFALSE 66016
// exit ;
66014: GO 66074
// for i in tmp do
66016: LD_ADDR_VAR 0 5
66020: PUSH
66021: LD_VAR 0 4
66025: PUSH
66026: FOR_IN
66027: IFFALSE 66062
// if GetBase ( i ) <> base then
66029: LD_VAR 0 5
66033: PPUSH
66034: CALL_OW 274
66038: PUSH
66039: LD_VAR 0 1
66043: NONEQUAL
66044: IFFALSE 66060
// ComLinkToBase ( base , i ) ;
66046: LD_VAR 0 1
66050: PPUSH
66051: LD_VAR 0 5
66055: PPUSH
66056: CALL_OW 169
66060: GO 66026
66062: POP
66063: POP
// result := tmp ;
66064: LD_ADDR_VAR 0 3
66068: PUSH
66069: LD_VAR 0 4
66073: ST_TO_ADDR
// end ;
66074: LD_VAR 0 3
66078: RET
// export function ComComplete ( unit , b ) ; var i ; begin
66079: LD_INT 0
66081: PPUSH
66082: PPUSH
// if BuildingStatus ( b ) = bs_build then
66083: LD_VAR 0 2
66087: PPUSH
66088: CALL_OW 461
66092: PUSH
66093: LD_INT 1
66095: EQUAL
66096: IFFALSE 66156
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
66098: LD_VAR 0 1
66102: PPUSH
66103: LD_STRING h
66105: PUSH
66106: LD_VAR 0 2
66110: PPUSH
66111: CALL_OW 250
66115: PUSH
66116: LD_VAR 0 2
66120: PPUSH
66121: CALL_OW 251
66125: PUSH
66126: LD_VAR 0 2
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: LD_INT 0
66136: PUSH
66137: LD_INT 0
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: PUSH
66149: EMPTY
66150: LIST
66151: PPUSH
66152: CALL_OW 446
// end ;
66156: LD_VAR 0 3
66160: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
66161: LD_INT 0
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
66169: LD_VAR 0 1
66173: NOT
66174: PUSH
66175: LD_VAR 0 1
66179: PPUSH
66180: CALL_OW 263
66184: PUSH
66185: LD_INT 2
66187: EQUAL
66188: NOT
66189: OR
66190: IFFALSE 66194
// exit ;
66192: GO 66510
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
66194: LD_ADDR_VAR 0 6
66198: PUSH
66199: LD_INT 22
66201: PUSH
66202: LD_VAR 0 1
66206: PPUSH
66207: CALL_OW 255
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 2
66218: PUSH
66219: LD_INT 30
66221: PUSH
66222: LD_INT 36
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: LD_INT 34
66231: PUSH
66232: LD_INT 31
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: EMPTY
66240: LIST
66241: LIST
66242: LIST
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: PPUSH
66248: CALL_OW 69
66252: ST_TO_ADDR
// if not tmp then
66253: LD_VAR 0 6
66257: NOT
66258: IFFALSE 66262
// exit ;
66260: GO 66510
// result := [ ] ;
66262: LD_ADDR_VAR 0 2
66266: PUSH
66267: EMPTY
66268: ST_TO_ADDR
// for i in tmp do
66269: LD_ADDR_VAR 0 3
66273: PUSH
66274: LD_VAR 0 6
66278: PUSH
66279: FOR_IN
66280: IFFALSE 66351
// begin t := UnitsInside ( i ) ;
66282: LD_ADDR_VAR 0 4
66286: PUSH
66287: LD_VAR 0 3
66291: PPUSH
66292: CALL_OW 313
66296: ST_TO_ADDR
// if t then
66297: LD_VAR 0 4
66301: IFFALSE 66349
// for j in t do
66303: LD_ADDR_VAR 0 7
66307: PUSH
66308: LD_VAR 0 4
66312: PUSH
66313: FOR_IN
66314: IFFALSE 66347
// result := Insert ( result , result + 1 , j ) ;
66316: LD_ADDR_VAR 0 2
66320: PUSH
66321: LD_VAR 0 2
66325: PPUSH
66326: LD_VAR 0 2
66330: PUSH
66331: LD_INT 1
66333: PLUS
66334: PPUSH
66335: LD_VAR 0 7
66339: PPUSH
66340: CALL_OW 2
66344: ST_TO_ADDR
66345: GO 66313
66347: POP
66348: POP
// end ;
66349: GO 66279
66351: POP
66352: POP
// if not result then
66353: LD_VAR 0 2
66357: NOT
66358: IFFALSE 66362
// exit ;
66360: GO 66510
// mech := result [ 1 ] ;
66362: LD_ADDR_VAR 0 5
66366: PUSH
66367: LD_VAR 0 2
66371: PUSH
66372: LD_INT 1
66374: ARRAY
66375: ST_TO_ADDR
// if result > 1 then
66376: LD_VAR 0 2
66380: PUSH
66381: LD_INT 1
66383: GREATER
66384: IFFALSE 66496
// for i = 2 to result do
66386: LD_ADDR_VAR 0 3
66390: PUSH
66391: DOUBLE
66392: LD_INT 2
66394: DEC
66395: ST_TO_ADDR
66396: LD_VAR 0 2
66400: PUSH
66401: FOR_TO
66402: IFFALSE 66494
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
66404: LD_ADDR_VAR 0 4
66408: PUSH
66409: LD_VAR 0 2
66413: PUSH
66414: LD_VAR 0 3
66418: ARRAY
66419: PPUSH
66420: LD_INT 3
66422: PPUSH
66423: CALL_OW 259
66427: PUSH
66428: LD_VAR 0 2
66432: PUSH
66433: LD_VAR 0 3
66437: ARRAY
66438: PPUSH
66439: CALL_OW 432
66443: MINUS
66444: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
66445: LD_VAR 0 4
66449: PUSH
66450: LD_VAR 0 5
66454: PPUSH
66455: LD_INT 3
66457: PPUSH
66458: CALL_OW 259
66462: PUSH
66463: LD_VAR 0 5
66467: PPUSH
66468: CALL_OW 432
66472: MINUS
66473: GREATEREQUAL
66474: IFFALSE 66492
// mech := result [ i ] ;
66476: LD_ADDR_VAR 0 5
66480: PUSH
66481: LD_VAR 0 2
66485: PUSH
66486: LD_VAR 0 3
66490: ARRAY
66491: ST_TO_ADDR
// end ;
66492: GO 66401
66494: POP
66495: POP
// ComLinkTo ( vehicle , mech ) ;
66496: LD_VAR 0 1
66500: PPUSH
66501: LD_VAR 0 5
66505: PPUSH
66506: CALL_OW 135
// end ;
66510: LD_VAR 0 2
66514: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
66515: LD_INT 0
66517: PPUSH
66518: PPUSH
66519: PPUSH
66520: PPUSH
66521: PPUSH
66522: PPUSH
66523: PPUSH
66524: PPUSH
66525: PPUSH
66526: PPUSH
66527: PPUSH
66528: PPUSH
66529: PPUSH
// result := [ ] ;
66530: LD_ADDR_VAR 0 7
66534: PUSH
66535: EMPTY
66536: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
66537: LD_VAR 0 1
66541: PPUSH
66542: CALL_OW 266
66546: PUSH
66547: LD_INT 0
66549: PUSH
66550: LD_INT 1
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: IN
66557: NOT
66558: IFFALSE 66562
// exit ;
66560: GO 68193
// if name then
66562: LD_VAR 0 3
66566: IFFALSE 66582
// SetBName ( base_dep , name ) ;
66568: LD_VAR 0 1
66572: PPUSH
66573: LD_VAR 0 3
66577: PPUSH
66578: CALL_OW 500
// base := GetBase ( base_dep ) ;
66582: LD_ADDR_VAR 0 15
66586: PUSH
66587: LD_VAR 0 1
66591: PPUSH
66592: CALL_OW 274
66596: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
66597: LD_ADDR_VAR 0 16
66601: PUSH
66602: LD_VAR 0 1
66606: PPUSH
66607: CALL_OW 255
66611: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
66612: LD_ADDR_VAR 0 17
66616: PUSH
66617: LD_VAR 0 1
66621: PPUSH
66622: CALL_OW 248
66626: ST_TO_ADDR
// if sources then
66627: LD_VAR 0 5
66631: IFFALSE 66678
// for i = 1 to 3 do
66633: LD_ADDR_VAR 0 8
66637: PUSH
66638: DOUBLE
66639: LD_INT 1
66641: DEC
66642: ST_TO_ADDR
66643: LD_INT 3
66645: PUSH
66646: FOR_TO
66647: IFFALSE 66676
// AddResourceType ( base , i , sources [ i ] ) ;
66649: LD_VAR 0 15
66653: PPUSH
66654: LD_VAR 0 8
66658: PPUSH
66659: LD_VAR 0 5
66663: PUSH
66664: LD_VAR 0 8
66668: ARRAY
66669: PPUSH
66670: CALL_OW 276
66674: GO 66646
66676: POP
66677: POP
// buildings := GetBaseBuildings ( base , area ) ;
66678: LD_ADDR_VAR 0 18
66682: PUSH
66683: LD_VAR 0 15
66687: PPUSH
66688: LD_VAR 0 2
66692: PPUSH
66693: CALL 65970 0 2
66697: ST_TO_ADDR
// InitHc ;
66698: CALL_OW 19
// InitUc ;
66702: CALL_OW 18
// uc_side := side ;
66706: LD_ADDR_OWVAR 20
66710: PUSH
66711: LD_VAR 0 16
66715: ST_TO_ADDR
// uc_nation := nation ;
66716: LD_ADDR_OWVAR 21
66720: PUSH
66721: LD_VAR 0 17
66725: ST_TO_ADDR
// if buildings then
66726: LD_VAR 0 18
66730: IFFALSE 68052
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
66732: LD_ADDR_VAR 0 19
66736: PUSH
66737: LD_VAR 0 18
66741: PPUSH
66742: LD_INT 2
66744: PUSH
66745: LD_INT 30
66747: PUSH
66748: LD_INT 29
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 30
66757: PUSH
66758: LD_INT 30
66760: PUSH
66761: EMPTY
66762: LIST
66763: LIST
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: LIST
66769: PPUSH
66770: CALL_OW 72
66774: ST_TO_ADDR
// if tmp then
66775: LD_VAR 0 19
66779: IFFALSE 66827
// for i in tmp do
66781: LD_ADDR_VAR 0 8
66785: PUSH
66786: LD_VAR 0 19
66790: PUSH
66791: FOR_IN
66792: IFFALSE 66825
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
66794: LD_VAR 0 8
66798: PPUSH
66799: CALL_OW 250
66803: PPUSH
66804: LD_VAR 0 8
66808: PPUSH
66809: CALL_OW 251
66813: PPUSH
66814: LD_VAR 0 16
66818: PPUSH
66819: CALL_OW 441
66823: GO 66791
66825: POP
66826: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
66827: LD_VAR 0 18
66831: PPUSH
66832: LD_INT 2
66834: PUSH
66835: LD_INT 30
66837: PUSH
66838: LD_INT 32
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 30
66847: PUSH
66848: LD_INT 33
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: LIST
66859: PPUSH
66860: CALL_OW 72
66864: IFFALSE 66952
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
66866: LD_ADDR_VAR 0 8
66870: PUSH
66871: LD_VAR 0 18
66875: PPUSH
66876: LD_INT 2
66878: PUSH
66879: LD_INT 30
66881: PUSH
66882: LD_INT 32
66884: PUSH
66885: EMPTY
66886: LIST
66887: LIST
66888: PUSH
66889: LD_INT 30
66891: PUSH
66892: LD_INT 33
66894: PUSH
66895: EMPTY
66896: LIST
66897: LIST
66898: PUSH
66899: EMPTY
66900: LIST
66901: LIST
66902: LIST
66903: PPUSH
66904: CALL_OW 72
66908: PUSH
66909: FOR_IN
66910: IFFALSE 66950
// begin if not GetBWeapon ( i ) then
66912: LD_VAR 0 8
66916: PPUSH
66917: CALL_OW 269
66921: NOT
66922: IFFALSE 66948
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
66924: LD_VAR 0 8
66928: PPUSH
66929: LD_VAR 0 8
66933: PPUSH
66934: LD_VAR 0 2
66938: PPUSH
66939: CALL 68198 0 2
66943: PPUSH
66944: CALL_OW 431
// end ;
66948: GO 66909
66950: POP
66951: POP
// end ; for i = 1 to personel do
66952: LD_ADDR_VAR 0 8
66956: PUSH
66957: DOUBLE
66958: LD_INT 1
66960: DEC
66961: ST_TO_ADDR
66962: LD_VAR 0 6
66966: PUSH
66967: FOR_TO
66968: IFFALSE 68032
// begin if i > 4 then
66970: LD_VAR 0 8
66974: PUSH
66975: LD_INT 4
66977: GREATER
66978: IFFALSE 66982
// break ;
66980: GO 68032
// case i of 1 :
66982: LD_VAR 0 8
66986: PUSH
66987: LD_INT 1
66989: DOUBLE
66990: EQUAL
66991: IFTRUE 66995
66993: GO 67075
66995: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
66996: LD_ADDR_VAR 0 12
67000: PUSH
67001: LD_VAR 0 18
67005: PPUSH
67006: LD_INT 22
67008: PUSH
67009: LD_VAR 0 16
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PUSH
67018: LD_INT 58
67020: PUSH
67021: EMPTY
67022: LIST
67023: PUSH
67024: LD_INT 2
67026: PUSH
67027: LD_INT 30
67029: PUSH
67030: LD_INT 32
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 30
67039: PUSH
67040: LD_INT 4
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: LD_INT 30
67049: PUSH
67050: LD_INT 5
67052: PUSH
67053: EMPTY
67054: LIST
67055: LIST
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: LIST
67061: LIST
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: LIST
67067: PPUSH
67068: CALL_OW 72
67072: ST_TO_ADDR
67073: GO 67297
67075: LD_INT 2
67077: DOUBLE
67078: EQUAL
67079: IFTRUE 67083
67081: GO 67145
67083: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
67084: LD_ADDR_VAR 0 12
67088: PUSH
67089: LD_VAR 0 18
67093: PPUSH
67094: LD_INT 22
67096: PUSH
67097: LD_VAR 0 16
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: LD_INT 2
67108: PUSH
67109: LD_INT 30
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 30
67121: PUSH
67122: LD_INT 1
67124: PUSH
67125: EMPTY
67126: LIST
67127: LIST
67128: PUSH
67129: EMPTY
67130: LIST
67131: LIST
67132: LIST
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PPUSH
67138: CALL_OW 72
67142: ST_TO_ADDR
67143: GO 67297
67145: LD_INT 3
67147: DOUBLE
67148: EQUAL
67149: IFTRUE 67153
67151: GO 67215
67153: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
67154: LD_ADDR_VAR 0 12
67158: PUSH
67159: LD_VAR 0 18
67163: PPUSH
67164: LD_INT 22
67166: PUSH
67167: LD_VAR 0 16
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 2
67178: PUSH
67179: LD_INT 30
67181: PUSH
67182: LD_INT 2
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 30
67191: PUSH
67192: LD_INT 3
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: EMPTY
67200: LIST
67201: LIST
67202: LIST
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PPUSH
67208: CALL_OW 72
67212: ST_TO_ADDR
67213: GO 67297
67215: LD_INT 4
67217: DOUBLE
67218: EQUAL
67219: IFTRUE 67223
67221: GO 67296
67223: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
67224: LD_ADDR_VAR 0 12
67228: PUSH
67229: LD_VAR 0 18
67233: PPUSH
67234: LD_INT 22
67236: PUSH
67237: LD_VAR 0 16
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 2
67248: PUSH
67249: LD_INT 30
67251: PUSH
67252: LD_INT 6
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 30
67261: PUSH
67262: LD_INT 7
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: LD_INT 30
67271: PUSH
67272: LD_INT 8
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: PUSH
67285: EMPTY
67286: LIST
67287: LIST
67288: PPUSH
67289: CALL_OW 72
67293: ST_TO_ADDR
67294: GO 67297
67296: POP
// if i = 1 then
67297: LD_VAR 0 8
67301: PUSH
67302: LD_INT 1
67304: EQUAL
67305: IFFALSE 67416
// begin tmp := [ ] ;
67307: LD_ADDR_VAR 0 19
67311: PUSH
67312: EMPTY
67313: ST_TO_ADDR
// for j in f do
67314: LD_ADDR_VAR 0 9
67318: PUSH
67319: LD_VAR 0 12
67323: PUSH
67324: FOR_IN
67325: IFFALSE 67398
// if GetBType ( j ) = b_bunker then
67327: LD_VAR 0 9
67331: PPUSH
67332: CALL_OW 266
67336: PUSH
67337: LD_INT 32
67339: EQUAL
67340: IFFALSE 67367
// tmp := Insert ( tmp , 1 , j ) else
67342: LD_ADDR_VAR 0 19
67346: PUSH
67347: LD_VAR 0 19
67351: PPUSH
67352: LD_INT 1
67354: PPUSH
67355: LD_VAR 0 9
67359: PPUSH
67360: CALL_OW 2
67364: ST_TO_ADDR
67365: GO 67396
// tmp := Insert ( tmp , tmp + 1 , j ) ;
67367: LD_ADDR_VAR 0 19
67371: PUSH
67372: LD_VAR 0 19
67376: PPUSH
67377: LD_VAR 0 19
67381: PUSH
67382: LD_INT 1
67384: PLUS
67385: PPUSH
67386: LD_VAR 0 9
67390: PPUSH
67391: CALL_OW 2
67395: ST_TO_ADDR
67396: GO 67324
67398: POP
67399: POP
// if tmp then
67400: LD_VAR 0 19
67404: IFFALSE 67416
// f := tmp ;
67406: LD_ADDR_VAR 0 12
67410: PUSH
67411: LD_VAR 0 19
67415: ST_TO_ADDR
// end ; x := personel [ i ] ;
67416: LD_ADDR_VAR 0 13
67420: PUSH
67421: LD_VAR 0 6
67425: PUSH
67426: LD_VAR 0 8
67430: ARRAY
67431: ST_TO_ADDR
// if x = - 1 then
67432: LD_VAR 0 13
67436: PUSH
67437: LD_INT 1
67439: NEG
67440: EQUAL
67441: IFFALSE 67650
// begin for j in f do
67443: LD_ADDR_VAR 0 9
67447: PUSH
67448: LD_VAR 0 12
67452: PUSH
67453: FOR_IN
67454: IFFALSE 67646
// repeat InitHc ;
67456: CALL_OW 19
// if GetBType ( j ) = b_barracks then
67460: LD_VAR 0 9
67464: PPUSH
67465: CALL_OW 266
67469: PUSH
67470: LD_INT 5
67472: EQUAL
67473: IFFALSE 67543
// begin if UnitsInside ( j ) < 3 then
67475: LD_VAR 0 9
67479: PPUSH
67480: CALL_OW 313
67484: PUSH
67485: LD_INT 3
67487: LESS
67488: IFFALSE 67524
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
67490: LD_INT 0
67492: PPUSH
67493: LD_INT 5
67495: PUSH
67496: LD_INT 8
67498: PUSH
67499: LD_INT 9
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: LIST
67506: PUSH
67507: LD_VAR 0 17
67511: ARRAY
67512: PPUSH
67513: LD_VAR 0 4
67517: PPUSH
67518: CALL_OW 380
67522: GO 67541
// PrepareHuman ( false , i , skill ) ;
67524: LD_INT 0
67526: PPUSH
67527: LD_VAR 0 8
67531: PPUSH
67532: LD_VAR 0 4
67536: PPUSH
67537: CALL_OW 380
// end else
67541: GO 67560
// PrepareHuman ( false , i , skill ) ;
67543: LD_INT 0
67545: PPUSH
67546: LD_VAR 0 8
67550: PPUSH
67551: LD_VAR 0 4
67555: PPUSH
67556: CALL_OW 380
// un := CreateHuman ;
67560: LD_ADDR_VAR 0 14
67564: PUSH
67565: CALL_OW 44
67569: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
67570: LD_ADDR_VAR 0 7
67574: PUSH
67575: LD_VAR 0 7
67579: PPUSH
67580: LD_INT 1
67582: PPUSH
67583: LD_VAR 0 14
67587: PPUSH
67588: CALL_OW 2
67592: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
67593: LD_VAR 0 14
67597: PPUSH
67598: LD_VAR 0 9
67602: PPUSH
67603: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
67607: LD_VAR 0 9
67611: PPUSH
67612: CALL_OW 313
67616: PUSH
67617: LD_INT 6
67619: EQUAL
67620: PUSH
67621: LD_VAR 0 9
67625: PPUSH
67626: CALL_OW 266
67630: PUSH
67631: LD_INT 32
67633: PUSH
67634: LD_INT 31
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: IN
67641: OR
67642: IFFALSE 67456
67644: GO 67453
67646: POP
67647: POP
// end else
67648: GO 68030
// for j = 1 to x do
67650: LD_ADDR_VAR 0 9
67654: PUSH
67655: DOUBLE
67656: LD_INT 1
67658: DEC
67659: ST_TO_ADDR
67660: LD_VAR 0 13
67664: PUSH
67665: FOR_TO
67666: IFFALSE 68028
// begin InitHc ;
67668: CALL_OW 19
// if not f then
67672: LD_VAR 0 12
67676: NOT
67677: IFFALSE 67766
// begin PrepareHuman ( false , i , skill ) ;
67679: LD_INT 0
67681: PPUSH
67682: LD_VAR 0 8
67686: PPUSH
67687: LD_VAR 0 4
67691: PPUSH
67692: CALL_OW 380
// un := CreateHuman ;
67696: LD_ADDR_VAR 0 14
67700: PUSH
67701: CALL_OW 44
67705: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
67706: LD_ADDR_VAR 0 7
67710: PUSH
67711: LD_VAR 0 7
67715: PPUSH
67716: LD_INT 1
67718: PPUSH
67719: LD_VAR 0 14
67723: PPUSH
67724: CALL_OW 2
67728: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
67729: LD_VAR 0 14
67733: PPUSH
67734: LD_VAR 0 1
67738: PPUSH
67739: CALL_OW 250
67743: PPUSH
67744: LD_VAR 0 1
67748: PPUSH
67749: CALL_OW 251
67753: PPUSH
67754: LD_INT 10
67756: PPUSH
67757: LD_INT 0
67759: PPUSH
67760: CALL_OW 50
// continue ;
67764: GO 67665
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
67766: LD_VAR 0 12
67770: PUSH
67771: LD_INT 1
67773: ARRAY
67774: PPUSH
67775: CALL_OW 313
67779: PUSH
67780: LD_VAR 0 12
67784: PUSH
67785: LD_INT 1
67787: ARRAY
67788: PPUSH
67789: CALL_OW 266
67793: PUSH
67794: LD_INT 32
67796: PUSH
67797: LD_INT 31
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: IN
67804: AND
67805: PUSH
67806: LD_VAR 0 12
67810: PUSH
67811: LD_INT 1
67813: ARRAY
67814: PPUSH
67815: CALL_OW 313
67819: PUSH
67820: LD_INT 6
67822: EQUAL
67823: OR
67824: IFFALSE 67844
// f := Delete ( f , 1 ) ;
67826: LD_ADDR_VAR 0 12
67830: PUSH
67831: LD_VAR 0 12
67835: PPUSH
67836: LD_INT 1
67838: PPUSH
67839: CALL_OW 3
67843: ST_TO_ADDR
// if not f then
67844: LD_VAR 0 12
67848: NOT
67849: IFFALSE 67867
// begin x := x + 2 ;
67851: LD_ADDR_VAR 0 13
67855: PUSH
67856: LD_VAR 0 13
67860: PUSH
67861: LD_INT 2
67863: PLUS
67864: ST_TO_ADDR
// continue ;
67865: GO 67665
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
67867: LD_VAR 0 12
67871: PUSH
67872: LD_INT 1
67874: ARRAY
67875: PPUSH
67876: CALL_OW 266
67880: PUSH
67881: LD_INT 5
67883: EQUAL
67884: IFFALSE 67958
// begin if UnitsInside ( f [ 1 ] ) < 3 then
67886: LD_VAR 0 12
67890: PUSH
67891: LD_INT 1
67893: ARRAY
67894: PPUSH
67895: CALL_OW 313
67899: PUSH
67900: LD_INT 3
67902: LESS
67903: IFFALSE 67939
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
67905: LD_INT 0
67907: PPUSH
67908: LD_INT 5
67910: PUSH
67911: LD_INT 8
67913: PUSH
67914: LD_INT 9
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: LIST
67921: PUSH
67922: LD_VAR 0 17
67926: ARRAY
67927: PPUSH
67928: LD_VAR 0 4
67932: PPUSH
67933: CALL_OW 380
67937: GO 67956
// PrepareHuman ( false , i , skill ) ;
67939: LD_INT 0
67941: PPUSH
67942: LD_VAR 0 8
67946: PPUSH
67947: LD_VAR 0 4
67951: PPUSH
67952: CALL_OW 380
// end else
67956: GO 67975
// PrepareHuman ( false , i , skill ) ;
67958: LD_INT 0
67960: PPUSH
67961: LD_VAR 0 8
67965: PPUSH
67966: LD_VAR 0 4
67970: PPUSH
67971: CALL_OW 380
// un := CreateHuman ;
67975: LD_ADDR_VAR 0 14
67979: PUSH
67980: CALL_OW 44
67984: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
67985: LD_ADDR_VAR 0 7
67989: PUSH
67990: LD_VAR 0 7
67994: PPUSH
67995: LD_INT 1
67997: PPUSH
67998: LD_VAR 0 14
68002: PPUSH
68003: CALL_OW 2
68007: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
68008: LD_VAR 0 14
68012: PPUSH
68013: LD_VAR 0 12
68017: PUSH
68018: LD_INT 1
68020: ARRAY
68021: PPUSH
68022: CALL_OW 52
// end ;
68026: GO 67665
68028: POP
68029: POP
// end ;
68030: GO 66967
68032: POP
68033: POP
// result := result ^ buildings ;
68034: LD_ADDR_VAR 0 7
68038: PUSH
68039: LD_VAR 0 7
68043: PUSH
68044: LD_VAR 0 18
68048: ADD
68049: ST_TO_ADDR
// end else
68050: GO 68193
// begin for i = 1 to personel do
68052: LD_ADDR_VAR 0 8
68056: PUSH
68057: DOUBLE
68058: LD_INT 1
68060: DEC
68061: ST_TO_ADDR
68062: LD_VAR 0 6
68066: PUSH
68067: FOR_TO
68068: IFFALSE 68191
// begin if i > 4 then
68070: LD_VAR 0 8
68074: PUSH
68075: LD_INT 4
68077: GREATER
68078: IFFALSE 68082
// break ;
68080: GO 68191
// x := personel [ i ] ;
68082: LD_ADDR_VAR 0 13
68086: PUSH
68087: LD_VAR 0 6
68091: PUSH
68092: LD_VAR 0 8
68096: ARRAY
68097: ST_TO_ADDR
// if x = - 1 then
68098: LD_VAR 0 13
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: EQUAL
68107: IFFALSE 68111
// continue ;
68109: GO 68067
// PrepareHuman ( false , i , skill ) ;
68111: LD_INT 0
68113: PPUSH
68114: LD_VAR 0 8
68118: PPUSH
68119: LD_VAR 0 4
68123: PPUSH
68124: CALL_OW 380
// un := CreateHuman ;
68128: LD_ADDR_VAR 0 14
68132: PUSH
68133: CALL_OW 44
68137: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
68138: LD_VAR 0 14
68142: PPUSH
68143: LD_VAR 0 1
68147: PPUSH
68148: CALL_OW 250
68152: PPUSH
68153: LD_VAR 0 1
68157: PPUSH
68158: CALL_OW 251
68162: PPUSH
68163: LD_INT 10
68165: PPUSH
68166: LD_INT 0
68168: PPUSH
68169: CALL_OW 50
// result := result ^ un ;
68173: LD_ADDR_VAR 0 7
68177: PUSH
68178: LD_VAR 0 7
68182: PUSH
68183: LD_VAR 0 14
68187: ADD
68188: ST_TO_ADDR
// end ;
68189: GO 68067
68191: POP
68192: POP
// end ; end ;
68193: LD_VAR 0 7
68197: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
68198: LD_INT 0
68200: PPUSH
68201: PPUSH
68202: PPUSH
68203: PPUSH
68204: PPUSH
68205: PPUSH
68206: PPUSH
68207: PPUSH
68208: PPUSH
68209: PPUSH
68210: PPUSH
68211: PPUSH
68212: PPUSH
68213: PPUSH
68214: PPUSH
68215: PPUSH
// result := false ;
68216: LD_ADDR_VAR 0 3
68220: PUSH
68221: LD_INT 0
68223: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
68224: LD_VAR 0 1
68228: NOT
68229: PUSH
68230: LD_VAR 0 1
68234: PPUSH
68235: CALL_OW 266
68239: PUSH
68240: LD_INT 32
68242: PUSH
68243: LD_INT 33
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: IN
68250: NOT
68251: OR
68252: IFFALSE 68256
// exit ;
68254: GO 69392
// nat := GetNation ( tower ) ;
68256: LD_ADDR_VAR 0 12
68260: PUSH
68261: LD_VAR 0 1
68265: PPUSH
68266: CALL_OW 248
68270: ST_TO_ADDR
// side := GetSide ( tower ) ;
68271: LD_ADDR_VAR 0 16
68275: PUSH
68276: LD_VAR 0 1
68280: PPUSH
68281: CALL_OW 255
68285: ST_TO_ADDR
// x := GetX ( tower ) ;
68286: LD_ADDR_VAR 0 10
68290: PUSH
68291: LD_VAR 0 1
68295: PPUSH
68296: CALL_OW 250
68300: ST_TO_ADDR
// y := GetY ( tower ) ;
68301: LD_ADDR_VAR 0 11
68305: PUSH
68306: LD_VAR 0 1
68310: PPUSH
68311: CALL_OW 251
68315: ST_TO_ADDR
// if not x or not y then
68316: LD_VAR 0 10
68320: NOT
68321: PUSH
68322: LD_VAR 0 11
68326: NOT
68327: OR
68328: IFFALSE 68332
// exit ;
68330: GO 69392
// weapon := 0 ;
68332: LD_ADDR_VAR 0 18
68336: PUSH
68337: LD_INT 0
68339: ST_TO_ADDR
// fac_list := [ ] ;
68340: LD_ADDR_VAR 0 17
68344: PUSH
68345: EMPTY
68346: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
68347: LD_ADDR_VAR 0 6
68351: PUSH
68352: LD_VAR 0 1
68356: PPUSH
68357: CALL_OW 274
68361: PPUSH
68362: LD_VAR 0 2
68366: PPUSH
68367: CALL 65970 0 2
68371: PPUSH
68372: LD_INT 30
68374: PUSH
68375: LD_INT 3
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PPUSH
68382: CALL_OW 72
68386: ST_TO_ADDR
// if not factories then
68387: LD_VAR 0 6
68391: NOT
68392: IFFALSE 68396
// exit ;
68394: GO 69392
// for i in factories do
68396: LD_ADDR_VAR 0 8
68400: PUSH
68401: LD_VAR 0 6
68405: PUSH
68406: FOR_IN
68407: IFFALSE 68432
// fac_list := fac_list union AvailableWeaponList ( i ) ;
68409: LD_ADDR_VAR 0 17
68413: PUSH
68414: LD_VAR 0 17
68418: PUSH
68419: LD_VAR 0 8
68423: PPUSH
68424: CALL_OW 478
68428: UNION
68429: ST_TO_ADDR
68430: GO 68406
68432: POP
68433: POP
// if not fac_list then
68434: LD_VAR 0 17
68438: NOT
68439: IFFALSE 68443
// exit ;
68441: GO 69392
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
68443: LD_ADDR_VAR 0 5
68447: PUSH
68448: LD_INT 4
68450: PUSH
68451: LD_INT 5
68453: PUSH
68454: LD_INT 9
68456: PUSH
68457: LD_INT 10
68459: PUSH
68460: LD_INT 6
68462: PUSH
68463: LD_INT 7
68465: PUSH
68466: LD_INT 11
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 27
68480: PUSH
68481: LD_INT 28
68483: PUSH
68484: LD_INT 26
68486: PUSH
68487: LD_INT 30
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: PUSH
68496: LD_INT 43
68498: PUSH
68499: LD_INT 44
68501: PUSH
68502: LD_INT 46
68504: PUSH
68505: LD_INT 45
68507: PUSH
68508: LD_INT 47
68510: PUSH
68511: LD_INT 49
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: LIST
68518: LIST
68519: LIST
68520: LIST
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: LIST
68526: PUSH
68527: LD_VAR 0 12
68531: ARRAY
68532: ST_TO_ADDR
// for i in list do
68533: LD_ADDR_VAR 0 8
68537: PUSH
68538: LD_VAR 0 5
68542: PUSH
68543: FOR_IN
68544: IFFALSE 68577
// if not i in fac_list then
68546: LD_VAR 0 8
68550: PUSH
68551: LD_VAR 0 17
68555: IN
68556: NOT
68557: IFFALSE 68575
// list := list diff i ;
68559: LD_ADDR_VAR 0 5
68563: PUSH
68564: LD_VAR 0 5
68568: PUSH
68569: LD_VAR 0 8
68573: DIFF
68574: ST_TO_ADDR
68575: GO 68543
68577: POP
68578: POP
// if not list then
68579: LD_VAR 0 5
68583: NOT
68584: IFFALSE 68588
// exit ;
68586: GO 69392
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
68588: LD_VAR 0 12
68592: PUSH
68593: LD_INT 3
68595: EQUAL
68596: PUSH
68597: LD_INT 49
68599: PUSH
68600: LD_VAR 0 5
68604: IN
68605: AND
68606: PUSH
68607: LD_INT 31
68609: PPUSH
68610: LD_VAR 0 16
68614: PPUSH
68615: CALL_OW 321
68619: PUSH
68620: LD_INT 2
68622: EQUAL
68623: AND
68624: IFFALSE 68684
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
68626: LD_INT 22
68628: PUSH
68629: LD_VAR 0 16
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 35
68640: PUSH
68641: LD_INT 49
68643: PUSH
68644: EMPTY
68645: LIST
68646: LIST
68647: PUSH
68648: LD_INT 91
68650: PUSH
68651: LD_VAR 0 1
68655: PUSH
68656: LD_INT 10
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: LIST
68663: PUSH
68664: EMPTY
68665: LIST
68666: LIST
68667: LIST
68668: PPUSH
68669: CALL_OW 69
68673: NOT
68674: IFFALSE 68684
// weapon := ru_time_lapser ;
68676: LD_ADDR_VAR 0 18
68680: PUSH
68681: LD_INT 49
68683: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
68684: LD_VAR 0 12
68688: PUSH
68689: LD_INT 1
68691: PUSH
68692: LD_INT 2
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: IN
68699: PUSH
68700: LD_INT 11
68702: PUSH
68703: LD_VAR 0 5
68707: IN
68708: PUSH
68709: LD_INT 30
68711: PUSH
68712: LD_VAR 0 5
68716: IN
68717: OR
68718: AND
68719: PUSH
68720: LD_INT 6
68722: PPUSH
68723: LD_VAR 0 16
68727: PPUSH
68728: CALL_OW 321
68732: PUSH
68733: LD_INT 2
68735: EQUAL
68736: AND
68737: IFFALSE 68902
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
68739: LD_INT 22
68741: PUSH
68742: LD_VAR 0 16
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 2
68753: PUSH
68754: LD_INT 35
68756: PUSH
68757: LD_INT 11
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 35
68766: PUSH
68767: LD_INT 30
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 91
68781: PUSH
68782: LD_VAR 0 1
68786: PUSH
68787: LD_INT 18
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: LIST
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: LIST
68799: PPUSH
68800: CALL_OW 69
68804: NOT
68805: PUSH
68806: LD_INT 22
68808: PUSH
68809: LD_VAR 0 16
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 2
68820: PUSH
68821: LD_INT 30
68823: PUSH
68824: LD_INT 32
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 30
68833: PUSH
68834: LD_INT 33
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: LIST
68845: PUSH
68846: LD_INT 91
68848: PUSH
68849: LD_VAR 0 1
68853: PUSH
68854: LD_INT 12
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: LIST
68861: PUSH
68862: EMPTY
68863: LIST
68864: LIST
68865: LIST
68866: PUSH
68867: EMPTY
68868: LIST
68869: PPUSH
68870: CALL_OW 69
68874: PUSH
68875: LD_INT 2
68877: GREATER
68878: AND
68879: IFFALSE 68902
// weapon := [ us_radar , ar_radar ] [ nat ] ;
68881: LD_ADDR_VAR 0 18
68885: PUSH
68886: LD_INT 11
68888: PUSH
68889: LD_INT 30
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_VAR 0 12
68900: ARRAY
68901: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
68902: LD_VAR 0 18
68906: NOT
68907: PUSH
68908: LD_INT 40
68910: PPUSH
68911: LD_VAR 0 16
68915: PPUSH
68916: CALL_OW 321
68920: PUSH
68921: LD_INT 2
68923: EQUAL
68924: AND
68925: PUSH
68926: LD_INT 7
68928: PUSH
68929: LD_VAR 0 5
68933: IN
68934: PUSH
68935: LD_INT 28
68937: PUSH
68938: LD_VAR 0 5
68942: IN
68943: OR
68944: PUSH
68945: LD_INT 45
68947: PUSH
68948: LD_VAR 0 5
68952: IN
68953: OR
68954: AND
68955: IFFALSE 69209
// begin hex := GetHexInfo ( x , y ) ;
68957: LD_ADDR_VAR 0 4
68961: PUSH
68962: LD_VAR 0 10
68966: PPUSH
68967: LD_VAR 0 11
68971: PPUSH
68972: CALL_OW 546
68976: ST_TO_ADDR
// if hex [ 1 ] then
68977: LD_VAR 0 4
68981: PUSH
68982: LD_INT 1
68984: ARRAY
68985: IFFALSE 68989
// exit ;
68987: GO 69392
// height := hex [ 2 ] ;
68989: LD_ADDR_VAR 0 15
68993: PUSH
68994: LD_VAR 0 4
68998: PUSH
68999: LD_INT 2
69001: ARRAY
69002: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
69003: LD_ADDR_VAR 0 14
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: LD_INT 2
69013: PUSH
69014: LD_INT 3
69016: PUSH
69017: LD_INT 5
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: LIST
69024: LIST
69025: ST_TO_ADDR
// for i in tmp do
69026: LD_ADDR_VAR 0 8
69030: PUSH
69031: LD_VAR 0 14
69035: PUSH
69036: FOR_IN
69037: IFFALSE 69207
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
69039: LD_ADDR_VAR 0 9
69043: PUSH
69044: LD_VAR 0 10
69048: PPUSH
69049: LD_VAR 0 8
69053: PPUSH
69054: LD_INT 5
69056: PPUSH
69057: CALL_OW 272
69061: PUSH
69062: LD_VAR 0 11
69066: PPUSH
69067: LD_VAR 0 8
69071: PPUSH
69072: LD_INT 5
69074: PPUSH
69075: CALL_OW 273
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
69084: LD_VAR 0 9
69088: PUSH
69089: LD_INT 1
69091: ARRAY
69092: PPUSH
69093: LD_VAR 0 9
69097: PUSH
69098: LD_INT 2
69100: ARRAY
69101: PPUSH
69102: CALL_OW 488
69106: IFFALSE 69205
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
69108: LD_ADDR_VAR 0 4
69112: PUSH
69113: LD_VAR 0 9
69117: PUSH
69118: LD_INT 1
69120: ARRAY
69121: PPUSH
69122: LD_VAR 0 9
69126: PUSH
69127: LD_INT 2
69129: ARRAY
69130: PPUSH
69131: CALL_OW 546
69135: ST_TO_ADDR
// if hex [ 1 ] then
69136: LD_VAR 0 4
69140: PUSH
69141: LD_INT 1
69143: ARRAY
69144: IFFALSE 69148
// continue ;
69146: GO 69036
// h := hex [ 2 ] ;
69148: LD_ADDR_VAR 0 13
69152: PUSH
69153: LD_VAR 0 4
69157: PUSH
69158: LD_INT 2
69160: ARRAY
69161: ST_TO_ADDR
// if h + 7 < height then
69162: LD_VAR 0 13
69166: PUSH
69167: LD_INT 7
69169: PLUS
69170: PUSH
69171: LD_VAR 0 15
69175: LESS
69176: IFFALSE 69205
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
69178: LD_ADDR_VAR 0 18
69182: PUSH
69183: LD_INT 7
69185: PUSH
69186: LD_INT 28
69188: PUSH
69189: LD_INT 45
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: LIST
69196: PUSH
69197: LD_VAR 0 12
69201: ARRAY
69202: ST_TO_ADDR
// break ;
69203: GO 69207
// end ; end ; end ;
69205: GO 69036
69207: POP
69208: POP
// end ; if not weapon then
69209: LD_VAR 0 18
69213: NOT
69214: IFFALSE 69274
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
69216: LD_ADDR_VAR 0 5
69220: PUSH
69221: LD_VAR 0 5
69225: PUSH
69226: LD_INT 11
69228: PUSH
69229: LD_INT 30
69231: PUSH
69232: LD_INT 49
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: LIST
69239: DIFF
69240: ST_TO_ADDR
// if not list then
69241: LD_VAR 0 5
69245: NOT
69246: IFFALSE 69250
// exit ;
69248: GO 69392
// weapon := list [ rand ( 1 , list ) ] ;
69250: LD_ADDR_VAR 0 18
69254: PUSH
69255: LD_VAR 0 5
69259: PUSH
69260: LD_INT 1
69262: PPUSH
69263: LD_VAR 0 5
69267: PPUSH
69268: CALL_OW 12
69272: ARRAY
69273: ST_TO_ADDR
// end ; if weapon then
69274: LD_VAR 0 18
69278: IFFALSE 69392
// begin tmp := CostOfWeapon ( weapon ) ;
69280: LD_ADDR_VAR 0 14
69284: PUSH
69285: LD_VAR 0 18
69289: PPUSH
69290: CALL_OW 451
69294: ST_TO_ADDR
// j := GetBase ( tower ) ;
69295: LD_ADDR_VAR 0 9
69299: PUSH
69300: LD_VAR 0 1
69304: PPUSH
69305: CALL_OW 274
69309: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
69310: LD_VAR 0 9
69314: PPUSH
69315: LD_INT 1
69317: PPUSH
69318: CALL_OW 275
69322: PUSH
69323: LD_VAR 0 14
69327: PUSH
69328: LD_INT 1
69330: ARRAY
69331: GREATEREQUAL
69332: PUSH
69333: LD_VAR 0 9
69337: PPUSH
69338: LD_INT 2
69340: PPUSH
69341: CALL_OW 275
69345: PUSH
69346: LD_VAR 0 14
69350: PUSH
69351: LD_INT 2
69353: ARRAY
69354: GREATEREQUAL
69355: AND
69356: PUSH
69357: LD_VAR 0 9
69361: PPUSH
69362: LD_INT 3
69364: PPUSH
69365: CALL_OW 275
69369: PUSH
69370: LD_VAR 0 14
69374: PUSH
69375: LD_INT 3
69377: ARRAY
69378: GREATEREQUAL
69379: AND
69380: IFFALSE 69392
// result := weapon ;
69382: LD_ADDR_VAR 0 3
69386: PUSH
69387: LD_VAR 0 18
69391: ST_TO_ADDR
// end ; end ;
69392: LD_VAR 0 3
69396: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
69397: LD_INT 0
69399: PPUSH
69400: PPUSH
// result := true ;
69401: LD_ADDR_VAR 0 3
69405: PUSH
69406: LD_INT 1
69408: ST_TO_ADDR
// if array1 = array2 then
69409: LD_VAR 0 1
69413: PUSH
69414: LD_VAR 0 2
69418: EQUAL
69419: IFFALSE 69479
// begin for i = 1 to array1 do
69421: LD_ADDR_VAR 0 4
69425: PUSH
69426: DOUBLE
69427: LD_INT 1
69429: DEC
69430: ST_TO_ADDR
69431: LD_VAR 0 1
69435: PUSH
69436: FOR_TO
69437: IFFALSE 69475
// if array1 [ i ] <> array2 [ i ] then
69439: LD_VAR 0 1
69443: PUSH
69444: LD_VAR 0 4
69448: ARRAY
69449: PUSH
69450: LD_VAR 0 2
69454: PUSH
69455: LD_VAR 0 4
69459: ARRAY
69460: NONEQUAL
69461: IFFALSE 69473
// begin result := false ;
69463: LD_ADDR_VAR 0 3
69467: PUSH
69468: LD_INT 0
69470: ST_TO_ADDR
// break ;
69471: GO 69475
// end ;
69473: GO 69436
69475: POP
69476: POP
// end else
69477: GO 69487
// result := false ;
69479: LD_ADDR_VAR 0 3
69483: PUSH
69484: LD_INT 0
69486: ST_TO_ADDR
// end ;
69487: LD_VAR 0 3
69491: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
69492: LD_INT 0
69494: PPUSH
69495: PPUSH
69496: PPUSH
// pom := GetBase ( fac ) ;
69497: LD_ADDR_VAR 0 5
69501: PUSH
69502: LD_VAR 0 1
69506: PPUSH
69507: CALL_OW 274
69511: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
69512: LD_ADDR_VAR 0 4
69516: PUSH
69517: LD_VAR 0 2
69521: PUSH
69522: LD_INT 1
69524: ARRAY
69525: PPUSH
69526: LD_VAR 0 2
69530: PUSH
69531: LD_INT 2
69533: ARRAY
69534: PPUSH
69535: LD_VAR 0 2
69539: PUSH
69540: LD_INT 3
69542: ARRAY
69543: PPUSH
69544: LD_VAR 0 2
69548: PUSH
69549: LD_INT 4
69551: ARRAY
69552: PPUSH
69553: CALL_OW 449
69557: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
69558: LD_ADDR_VAR 0 3
69562: PUSH
69563: LD_VAR 0 5
69567: PPUSH
69568: LD_INT 1
69570: PPUSH
69571: CALL_OW 275
69575: PUSH
69576: LD_VAR 0 4
69580: PUSH
69581: LD_INT 1
69583: ARRAY
69584: GREATEREQUAL
69585: PUSH
69586: LD_VAR 0 5
69590: PPUSH
69591: LD_INT 2
69593: PPUSH
69594: CALL_OW 275
69598: PUSH
69599: LD_VAR 0 4
69603: PUSH
69604: LD_INT 2
69606: ARRAY
69607: GREATEREQUAL
69608: AND
69609: PUSH
69610: LD_VAR 0 5
69614: PPUSH
69615: LD_INT 3
69617: PPUSH
69618: CALL_OW 275
69622: PUSH
69623: LD_VAR 0 4
69627: PUSH
69628: LD_INT 3
69630: ARRAY
69631: GREATEREQUAL
69632: AND
69633: ST_TO_ADDR
// end ;
69634: LD_VAR 0 3
69638: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
69639: LD_INT 0
69641: PPUSH
69642: PPUSH
69643: PPUSH
69644: PPUSH
// pom := GetBase ( building ) ;
69645: LD_ADDR_VAR 0 3
69649: PUSH
69650: LD_VAR 0 1
69654: PPUSH
69655: CALL_OW 274
69659: ST_TO_ADDR
// if not pom then
69660: LD_VAR 0 3
69664: NOT
69665: IFFALSE 69669
// exit ;
69667: GO 69839
// btype := GetBType ( building ) ;
69669: LD_ADDR_VAR 0 5
69673: PUSH
69674: LD_VAR 0 1
69678: PPUSH
69679: CALL_OW 266
69683: ST_TO_ADDR
// if btype = b_armoury then
69684: LD_VAR 0 5
69688: PUSH
69689: LD_INT 4
69691: EQUAL
69692: IFFALSE 69702
// btype := b_barracks ;
69694: LD_ADDR_VAR 0 5
69698: PUSH
69699: LD_INT 5
69701: ST_TO_ADDR
// if btype = b_depot then
69702: LD_VAR 0 5
69706: PUSH
69707: LD_INT 0
69709: EQUAL
69710: IFFALSE 69720
// btype := b_warehouse ;
69712: LD_ADDR_VAR 0 5
69716: PUSH
69717: LD_INT 1
69719: ST_TO_ADDR
// if btype = b_workshop then
69720: LD_VAR 0 5
69724: PUSH
69725: LD_INT 2
69727: EQUAL
69728: IFFALSE 69738
// btype := b_factory ;
69730: LD_ADDR_VAR 0 5
69734: PUSH
69735: LD_INT 3
69737: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
69738: LD_ADDR_VAR 0 4
69742: PUSH
69743: LD_VAR 0 5
69747: PPUSH
69748: LD_VAR 0 1
69752: PPUSH
69753: CALL_OW 248
69757: PPUSH
69758: CALL_OW 450
69762: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
69763: LD_ADDR_VAR 0 2
69767: PUSH
69768: LD_VAR 0 3
69772: PPUSH
69773: LD_INT 1
69775: PPUSH
69776: CALL_OW 275
69780: PUSH
69781: LD_VAR 0 4
69785: PUSH
69786: LD_INT 1
69788: ARRAY
69789: GREATEREQUAL
69790: PUSH
69791: LD_VAR 0 3
69795: PPUSH
69796: LD_INT 2
69798: PPUSH
69799: CALL_OW 275
69803: PUSH
69804: LD_VAR 0 4
69808: PUSH
69809: LD_INT 2
69811: ARRAY
69812: GREATEREQUAL
69813: AND
69814: PUSH
69815: LD_VAR 0 3
69819: PPUSH
69820: LD_INT 3
69822: PPUSH
69823: CALL_OW 275
69827: PUSH
69828: LD_VAR 0 4
69832: PUSH
69833: LD_INT 3
69835: ARRAY
69836: GREATEREQUAL
69837: AND
69838: ST_TO_ADDR
// end ;
69839: LD_VAR 0 2
69843: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
69844: LD_INT 0
69846: PPUSH
69847: PPUSH
69848: PPUSH
// pom := GetBase ( building ) ;
69849: LD_ADDR_VAR 0 4
69853: PUSH
69854: LD_VAR 0 1
69858: PPUSH
69859: CALL_OW 274
69863: ST_TO_ADDR
// if not pom then
69864: LD_VAR 0 4
69868: NOT
69869: IFFALSE 69873
// exit ;
69871: GO 69974
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
69873: LD_ADDR_VAR 0 5
69877: PUSH
69878: LD_VAR 0 2
69882: PPUSH
69883: LD_VAR 0 1
69887: PPUSH
69888: CALL_OW 248
69892: PPUSH
69893: CALL_OW 450
69897: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
69898: LD_ADDR_VAR 0 3
69902: PUSH
69903: LD_VAR 0 4
69907: PPUSH
69908: LD_INT 1
69910: PPUSH
69911: CALL_OW 275
69915: PUSH
69916: LD_VAR 0 5
69920: PUSH
69921: LD_INT 1
69923: ARRAY
69924: GREATEREQUAL
69925: PUSH
69926: LD_VAR 0 4
69930: PPUSH
69931: LD_INT 2
69933: PPUSH
69934: CALL_OW 275
69938: PUSH
69939: LD_VAR 0 5
69943: PUSH
69944: LD_INT 2
69946: ARRAY
69947: GREATEREQUAL
69948: AND
69949: PUSH
69950: LD_VAR 0 4
69954: PPUSH
69955: LD_INT 3
69957: PPUSH
69958: CALL_OW 275
69962: PUSH
69963: LD_VAR 0 5
69967: PUSH
69968: LD_INT 3
69970: ARRAY
69971: GREATEREQUAL
69972: AND
69973: ST_TO_ADDR
// end ;
69974: LD_VAR 0 3
69978: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
69979: LD_INT 0
69981: PPUSH
69982: PPUSH
69983: PPUSH
69984: PPUSH
69985: PPUSH
69986: PPUSH
69987: PPUSH
69988: PPUSH
69989: PPUSH
69990: PPUSH
// result := false ;
69991: LD_ADDR_VAR 0 6
69995: PUSH
69996: LD_INT 0
69998: ST_TO_ADDR
// if not base or not btype or not x or not y then
69999: LD_VAR 0 1
70003: NOT
70004: PUSH
70005: LD_VAR 0 2
70009: NOT
70010: OR
70011: PUSH
70012: LD_VAR 0 3
70016: NOT
70017: OR
70018: PUSH
70019: LD_VAR 0 4
70023: NOT
70024: OR
70025: IFFALSE 70029
// exit ;
70027: GO 70638
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
70029: LD_ADDR_VAR 0 12
70033: PUSH
70034: LD_VAR 0 2
70038: PPUSH
70039: LD_VAR 0 3
70043: PPUSH
70044: LD_VAR 0 4
70048: PPUSH
70049: LD_VAR 0 5
70053: PPUSH
70054: LD_VAR 0 1
70058: PUSH
70059: LD_INT 1
70061: ARRAY
70062: PPUSH
70063: CALL_OW 248
70067: PPUSH
70068: LD_INT 0
70070: PPUSH
70071: CALL 71475 0 6
70075: ST_TO_ADDR
// if not hexes then
70076: LD_VAR 0 12
70080: NOT
70081: IFFALSE 70085
// exit ;
70083: GO 70638
// for i = 1 to hexes do
70085: LD_ADDR_VAR 0 7
70089: PUSH
70090: DOUBLE
70091: LD_INT 1
70093: DEC
70094: ST_TO_ADDR
70095: LD_VAR 0 12
70099: PUSH
70100: FOR_TO
70101: IFFALSE 70636
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
70103: LD_ADDR_VAR 0 11
70107: PUSH
70108: LD_VAR 0 12
70112: PUSH
70113: LD_VAR 0 7
70117: ARRAY
70118: PUSH
70119: LD_INT 1
70121: ARRAY
70122: PPUSH
70123: LD_VAR 0 12
70127: PUSH
70128: LD_VAR 0 7
70132: ARRAY
70133: PUSH
70134: LD_INT 2
70136: ARRAY
70137: PPUSH
70138: CALL_OW 428
70142: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
70143: LD_VAR 0 12
70147: PUSH
70148: LD_VAR 0 7
70152: ARRAY
70153: PUSH
70154: LD_INT 1
70156: ARRAY
70157: PPUSH
70158: LD_VAR 0 12
70162: PUSH
70163: LD_VAR 0 7
70167: ARRAY
70168: PUSH
70169: LD_INT 2
70171: ARRAY
70172: PPUSH
70173: CALL_OW 351
70177: PUSH
70178: LD_VAR 0 12
70182: PUSH
70183: LD_VAR 0 7
70187: ARRAY
70188: PUSH
70189: LD_INT 1
70191: ARRAY
70192: PPUSH
70193: LD_VAR 0 12
70197: PUSH
70198: LD_VAR 0 7
70202: ARRAY
70203: PUSH
70204: LD_INT 2
70206: ARRAY
70207: PPUSH
70208: CALL_OW 488
70212: NOT
70213: OR
70214: PUSH
70215: LD_VAR 0 11
70219: PPUSH
70220: CALL_OW 247
70224: PUSH
70225: LD_INT 3
70227: EQUAL
70228: OR
70229: IFFALSE 70235
// exit ;
70231: POP
70232: POP
70233: GO 70638
// if not tmp or not tmp in base then
70235: LD_VAR 0 11
70239: NOT
70240: PUSH
70241: LD_VAR 0 11
70245: PUSH
70246: LD_VAR 0 1
70250: IN
70251: NOT
70252: OR
70253: IFFALSE 70257
// continue ;
70255: GO 70100
// result := true ;
70257: LD_ADDR_VAR 0 6
70261: PUSH
70262: LD_INT 1
70264: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
70265: LD_ADDR_VAR 0 15
70269: PUSH
70270: LD_VAR 0 1
70274: PPUSH
70275: LD_INT 22
70277: PUSH
70278: LD_VAR 0 11
70282: PPUSH
70283: CALL_OW 255
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 2
70294: PUSH
70295: LD_INT 30
70297: PUSH
70298: LD_INT 0
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 30
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: EMPTY
70312: LIST
70313: LIST
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: LIST
70319: PUSH
70320: EMPTY
70321: LIST
70322: LIST
70323: PPUSH
70324: CALL_OW 72
70328: ST_TO_ADDR
// if dep then
70329: LD_VAR 0 15
70333: IFFALSE 70469
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
70335: LD_ADDR_VAR 0 14
70339: PUSH
70340: LD_VAR 0 15
70344: PUSH
70345: LD_INT 1
70347: ARRAY
70348: PPUSH
70349: CALL_OW 250
70353: PPUSH
70354: LD_VAR 0 15
70358: PUSH
70359: LD_INT 1
70361: ARRAY
70362: PPUSH
70363: CALL_OW 254
70367: PPUSH
70368: LD_INT 5
70370: PPUSH
70371: CALL_OW 272
70375: PUSH
70376: LD_VAR 0 15
70380: PUSH
70381: LD_INT 1
70383: ARRAY
70384: PPUSH
70385: CALL_OW 251
70389: PPUSH
70390: LD_VAR 0 15
70394: PUSH
70395: LD_INT 1
70397: ARRAY
70398: PPUSH
70399: CALL_OW 254
70403: PPUSH
70404: LD_INT 5
70406: PPUSH
70407: CALL_OW 273
70411: PUSH
70412: EMPTY
70413: LIST
70414: LIST
70415: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
70416: LD_VAR 0 14
70420: PUSH
70421: LD_INT 1
70423: ARRAY
70424: PPUSH
70425: LD_VAR 0 14
70429: PUSH
70430: LD_INT 2
70432: ARRAY
70433: PPUSH
70434: CALL_OW 488
70438: IFFALSE 70469
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
70440: LD_VAR 0 11
70444: PPUSH
70445: LD_VAR 0 14
70449: PUSH
70450: LD_INT 1
70452: ARRAY
70453: PPUSH
70454: LD_VAR 0 14
70458: PUSH
70459: LD_INT 2
70461: ARRAY
70462: PPUSH
70463: CALL_OW 111
// continue ;
70467: GO 70100
// end ; end ; r := GetDir ( tmp ) ;
70469: LD_ADDR_VAR 0 13
70473: PUSH
70474: LD_VAR 0 11
70478: PPUSH
70479: CALL_OW 254
70483: ST_TO_ADDR
// if r = 5 then
70484: LD_VAR 0 13
70488: PUSH
70489: LD_INT 5
70491: EQUAL
70492: IFFALSE 70502
// r := 0 ;
70494: LD_ADDR_VAR 0 13
70498: PUSH
70499: LD_INT 0
70501: ST_TO_ADDR
// for j = r to 5 do
70502: LD_ADDR_VAR 0 8
70506: PUSH
70507: DOUBLE
70508: LD_VAR 0 13
70512: DEC
70513: ST_TO_ADDR
70514: LD_INT 5
70516: PUSH
70517: FOR_TO
70518: IFFALSE 70632
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
70520: LD_ADDR_VAR 0 9
70524: PUSH
70525: LD_VAR 0 11
70529: PPUSH
70530: CALL_OW 250
70534: PPUSH
70535: LD_VAR 0 8
70539: PPUSH
70540: LD_INT 2
70542: PPUSH
70543: CALL_OW 272
70547: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
70548: LD_ADDR_VAR 0 10
70552: PUSH
70553: LD_VAR 0 11
70557: PPUSH
70558: CALL_OW 251
70562: PPUSH
70563: LD_VAR 0 8
70567: PPUSH
70568: LD_INT 2
70570: PPUSH
70571: CALL_OW 273
70575: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
70576: LD_VAR 0 9
70580: PPUSH
70581: LD_VAR 0 10
70585: PPUSH
70586: CALL_OW 488
70590: PUSH
70591: LD_VAR 0 9
70595: PPUSH
70596: LD_VAR 0 10
70600: PPUSH
70601: CALL_OW 428
70605: NOT
70606: AND
70607: IFFALSE 70630
// begin ComMoveXY ( tmp , _x , _y ) ;
70609: LD_VAR 0 11
70613: PPUSH
70614: LD_VAR 0 9
70618: PPUSH
70619: LD_VAR 0 10
70623: PPUSH
70624: CALL_OW 111
// break ;
70628: GO 70632
// end ; end ;
70630: GO 70517
70632: POP
70633: POP
// end ;
70634: GO 70100
70636: POP
70637: POP
// end ;
70638: LD_VAR 0 6
70642: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
70643: LD_INT 0
70645: PPUSH
70646: PPUSH
70647: PPUSH
70648: PPUSH
70649: PPUSH
70650: PPUSH
70651: PPUSH
70652: PPUSH
70653: PPUSH
70654: PPUSH
// result := false ;
70655: LD_ADDR_VAR 0 6
70659: PUSH
70660: LD_INT 0
70662: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
70663: LD_VAR 0 1
70667: NOT
70668: PUSH
70669: LD_VAR 0 1
70673: PPUSH
70674: CALL_OW 266
70678: PUSH
70679: LD_INT 0
70681: PUSH
70682: LD_INT 1
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: IN
70689: NOT
70690: OR
70691: PUSH
70692: LD_VAR 0 2
70696: NOT
70697: OR
70698: PUSH
70699: LD_VAR 0 5
70703: PUSH
70704: LD_INT 0
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: LD_INT 2
70712: PUSH
70713: LD_INT 3
70715: PUSH
70716: LD_INT 4
70718: PUSH
70719: LD_INT 5
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: IN
70730: NOT
70731: OR
70732: PUSH
70733: LD_VAR 0 3
70737: PPUSH
70738: LD_VAR 0 4
70742: PPUSH
70743: CALL_OW 488
70747: NOT
70748: OR
70749: IFFALSE 70753
// exit ;
70751: GO 71470
// pom := GetBase ( depot ) ;
70753: LD_ADDR_VAR 0 10
70757: PUSH
70758: LD_VAR 0 1
70762: PPUSH
70763: CALL_OW 274
70767: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
70768: LD_ADDR_VAR 0 11
70772: PUSH
70773: LD_VAR 0 2
70777: PPUSH
70778: LD_VAR 0 1
70782: PPUSH
70783: CALL_OW 248
70787: PPUSH
70788: CALL_OW 450
70792: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
70793: LD_VAR 0 10
70797: PPUSH
70798: LD_INT 1
70800: PPUSH
70801: CALL_OW 275
70805: PUSH
70806: LD_VAR 0 11
70810: PUSH
70811: LD_INT 1
70813: ARRAY
70814: GREATEREQUAL
70815: PUSH
70816: LD_VAR 0 10
70820: PPUSH
70821: LD_INT 2
70823: PPUSH
70824: CALL_OW 275
70828: PUSH
70829: LD_VAR 0 11
70833: PUSH
70834: LD_INT 2
70836: ARRAY
70837: GREATEREQUAL
70838: AND
70839: PUSH
70840: LD_VAR 0 10
70844: PPUSH
70845: LD_INT 3
70847: PPUSH
70848: CALL_OW 275
70852: PUSH
70853: LD_VAR 0 11
70857: PUSH
70858: LD_INT 3
70860: ARRAY
70861: GREATEREQUAL
70862: AND
70863: NOT
70864: IFFALSE 70868
// exit ;
70866: GO 71470
// if GetBType ( depot ) = b_depot then
70868: LD_VAR 0 1
70872: PPUSH
70873: CALL_OW 266
70877: PUSH
70878: LD_INT 0
70880: EQUAL
70881: IFFALSE 70893
// dist := 28 else
70883: LD_ADDR_VAR 0 14
70887: PUSH
70888: LD_INT 28
70890: ST_TO_ADDR
70891: GO 70901
// dist := 36 ;
70893: LD_ADDR_VAR 0 14
70897: PUSH
70898: LD_INT 36
70900: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
70901: LD_VAR 0 1
70905: PPUSH
70906: LD_VAR 0 3
70910: PPUSH
70911: LD_VAR 0 4
70915: PPUSH
70916: CALL_OW 297
70920: PUSH
70921: LD_VAR 0 14
70925: GREATER
70926: IFFALSE 70930
// exit ;
70928: GO 71470
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
70930: LD_ADDR_VAR 0 12
70934: PUSH
70935: LD_VAR 0 2
70939: PPUSH
70940: LD_VAR 0 3
70944: PPUSH
70945: LD_VAR 0 4
70949: PPUSH
70950: LD_VAR 0 5
70954: PPUSH
70955: LD_VAR 0 1
70959: PPUSH
70960: CALL_OW 248
70964: PPUSH
70965: LD_INT 0
70967: PPUSH
70968: CALL 71475 0 6
70972: ST_TO_ADDR
// if not hexes then
70973: LD_VAR 0 12
70977: NOT
70978: IFFALSE 70982
// exit ;
70980: GO 71470
// hex := GetHexInfo ( x , y ) ;
70982: LD_ADDR_VAR 0 15
70986: PUSH
70987: LD_VAR 0 3
70991: PPUSH
70992: LD_VAR 0 4
70996: PPUSH
70997: CALL_OW 546
71001: ST_TO_ADDR
// if hex [ 1 ] then
71002: LD_VAR 0 15
71006: PUSH
71007: LD_INT 1
71009: ARRAY
71010: IFFALSE 71014
// exit ;
71012: GO 71470
// height := hex [ 2 ] ;
71014: LD_ADDR_VAR 0 13
71018: PUSH
71019: LD_VAR 0 15
71023: PUSH
71024: LD_INT 2
71026: ARRAY
71027: ST_TO_ADDR
// for i = 1 to hexes do
71028: LD_ADDR_VAR 0 7
71032: PUSH
71033: DOUBLE
71034: LD_INT 1
71036: DEC
71037: ST_TO_ADDR
71038: LD_VAR 0 12
71042: PUSH
71043: FOR_TO
71044: IFFALSE 71374
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
71046: LD_VAR 0 12
71050: PUSH
71051: LD_VAR 0 7
71055: ARRAY
71056: PUSH
71057: LD_INT 1
71059: ARRAY
71060: PPUSH
71061: LD_VAR 0 12
71065: PUSH
71066: LD_VAR 0 7
71070: ARRAY
71071: PUSH
71072: LD_INT 2
71074: ARRAY
71075: PPUSH
71076: CALL_OW 488
71080: NOT
71081: PUSH
71082: LD_VAR 0 12
71086: PUSH
71087: LD_VAR 0 7
71091: ARRAY
71092: PUSH
71093: LD_INT 1
71095: ARRAY
71096: PPUSH
71097: LD_VAR 0 12
71101: PUSH
71102: LD_VAR 0 7
71106: ARRAY
71107: PUSH
71108: LD_INT 2
71110: ARRAY
71111: PPUSH
71112: CALL_OW 428
71116: PUSH
71117: LD_INT 0
71119: GREATER
71120: OR
71121: PUSH
71122: LD_VAR 0 12
71126: PUSH
71127: LD_VAR 0 7
71131: ARRAY
71132: PUSH
71133: LD_INT 1
71135: ARRAY
71136: PPUSH
71137: LD_VAR 0 12
71141: PUSH
71142: LD_VAR 0 7
71146: ARRAY
71147: PUSH
71148: LD_INT 2
71150: ARRAY
71151: PPUSH
71152: CALL_OW 351
71156: OR
71157: IFFALSE 71163
// exit ;
71159: POP
71160: POP
71161: GO 71470
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
71163: LD_ADDR_VAR 0 8
71167: PUSH
71168: LD_VAR 0 12
71172: PUSH
71173: LD_VAR 0 7
71177: ARRAY
71178: PUSH
71179: LD_INT 1
71181: ARRAY
71182: PPUSH
71183: LD_VAR 0 12
71187: PUSH
71188: LD_VAR 0 7
71192: ARRAY
71193: PUSH
71194: LD_INT 2
71196: ARRAY
71197: PPUSH
71198: CALL_OW 546
71202: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
71203: LD_VAR 0 8
71207: PUSH
71208: LD_INT 1
71210: ARRAY
71211: PUSH
71212: LD_VAR 0 8
71216: PUSH
71217: LD_INT 2
71219: ARRAY
71220: PUSH
71221: LD_VAR 0 13
71225: PUSH
71226: LD_INT 2
71228: PLUS
71229: GREATER
71230: OR
71231: PUSH
71232: LD_VAR 0 8
71236: PUSH
71237: LD_INT 2
71239: ARRAY
71240: PUSH
71241: LD_VAR 0 13
71245: PUSH
71246: LD_INT 2
71248: MINUS
71249: LESS
71250: OR
71251: PUSH
71252: LD_VAR 0 8
71256: PUSH
71257: LD_INT 3
71259: ARRAY
71260: PUSH
71261: LD_INT 0
71263: PUSH
71264: LD_INT 8
71266: PUSH
71267: LD_INT 9
71269: PUSH
71270: LD_INT 10
71272: PUSH
71273: LD_INT 11
71275: PUSH
71276: LD_INT 12
71278: PUSH
71279: LD_INT 13
71281: PUSH
71282: LD_INT 16
71284: PUSH
71285: LD_INT 17
71287: PUSH
71288: LD_INT 18
71290: PUSH
71291: LD_INT 19
71293: PUSH
71294: LD_INT 20
71296: PUSH
71297: LD_INT 21
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: IN
71315: NOT
71316: OR
71317: PUSH
71318: LD_VAR 0 8
71322: PUSH
71323: LD_INT 5
71325: ARRAY
71326: NOT
71327: OR
71328: PUSH
71329: LD_VAR 0 8
71333: PUSH
71334: LD_INT 6
71336: ARRAY
71337: PUSH
71338: LD_INT 1
71340: PUSH
71341: LD_INT 2
71343: PUSH
71344: LD_INT 7
71346: PUSH
71347: LD_INT 9
71349: PUSH
71350: LD_INT 10
71352: PUSH
71353: LD_INT 11
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: IN
71364: NOT
71365: OR
71366: IFFALSE 71372
// exit ;
71368: POP
71369: POP
71370: GO 71470
// end ;
71372: GO 71043
71374: POP
71375: POP
// side := GetSide ( depot ) ;
71376: LD_ADDR_VAR 0 9
71380: PUSH
71381: LD_VAR 0 1
71385: PPUSH
71386: CALL_OW 255
71390: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71391: LD_VAR 0 9
71395: PPUSH
71396: LD_VAR 0 3
71400: PPUSH
71401: LD_VAR 0 4
71405: PPUSH
71406: LD_INT 20
71408: PPUSH
71409: CALL 64124 0 4
71413: PUSH
71414: LD_INT 4
71416: ARRAY
71417: IFFALSE 71421
// exit ;
71419: GO 71470
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
71421: LD_VAR 0 2
71425: PUSH
71426: LD_INT 29
71428: PUSH
71429: LD_INT 30
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: IN
71436: PUSH
71437: LD_VAR 0 3
71441: PPUSH
71442: LD_VAR 0 4
71446: PPUSH
71447: LD_VAR 0 9
71451: PPUSH
71452: CALL_OW 440
71456: NOT
71457: AND
71458: IFFALSE 71462
// exit ;
71460: GO 71470
// result := true ;
71462: LD_ADDR_VAR 0 6
71466: PUSH
71467: LD_INT 1
71469: ST_TO_ADDR
// end ;
71470: LD_VAR 0 6
71474: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
71475: LD_INT 0
71477: PPUSH
71478: PPUSH
71479: PPUSH
71480: PPUSH
71481: PPUSH
71482: PPUSH
71483: PPUSH
71484: PPUSH
71485: PPUSH
71486: PPUSH
71487: PPUSH
71488: PPUSH
71489: PPUSH
71490: PPUSH
71491: PPUSH
71492: PPUSH
71493: PPUSH
71494: PPUSH
71495: PPUSH
71496: PPUSH
71497: PPUSH
71498: PPUSH
71499: PPUSH
71500: PPUSH
71501: PPUSH
71502: PPUSH
71503: PPUSH
71504: PPUSH
71505: PPUSH
71506: PPUSH
71507: PPUSH
71508: PPUSH
71509: PPUSH
71510: PPUSH
71511: PPUSH
71512: PPUSH
71513: PPUSH
71514: PPUSH
71515: PPUSH
71516: PPUSH
71517: PPUSH
71518: PPUSH
71519: PPUSH
71520: PPUSH
71521: PPUSH
71522: PPUSH
71523: PPUSH
71524: PPUSH
71525: PPUSH
71526: PPUSH
71527: PPUSH
71528: PPUSH
71529: PPUSH
71530: PPUSH
71531: PPUSH
71532: PPUSH
71533: PPUSH
71534: PPUSH
// result = [ ] ;
71535: LD_ADDR_VAR 0 7
71539: PUSH
71540: EMPTY
71541: ST_TO_ADDR
// temp_list = [ ] ;
71542: LD_ADDR_VAR 0 9
71546: PUSH
71547: EMPTY
71548: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
71549: LD_VAR 0 4
71553: PUSH
71554: LD_INT 0
71556: PUSH
71557: LD_INT 1
71559: PUSH
71560: LD_INT 2
71562: PUSH
71563: LD_INT 3
71565: PUSH
71566: LD_INT 4
71568: PUSH
71569: LD_INT 5
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: IN
71580: NOT
71581: PUSH
71582: LD_VAR 0 1
71586: PUSH
71587: LD_INT 0
71589: PUSH
71590: LD_INT 1
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: IN
71597: PUSH
71598: LD_VAR 0 5
71602: PUSH
71603: LD_INT 1
71605: PUSH
71606: LD_INT 2
71608: PUSH
71609: LD_INT 3
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: LIST
71616: IN
71617: NOT
71618: AND
71619: OR
71620: IFFALSE 71624
// exit ;
71622: GO 90015
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
71624: LD_VAR 0 1
71628: PUSH
71629: LD_INT 6
71631: PUSH
71632: LD_INT 7
71634: PUSH
71635: LD_INT 8
71637: PUSH
71638: LD_INT 13
71640: PUSH
71641: LD_INT 12
71643: PUSH
71644: LD_INT 15
71646: PUSH
71647: LD_INT 11
71649: PUSH
71650: LD_INT 14
71652: PUSH
71653: LD_INT 10
71655: PUSH
71656: EMPTY
71657: LIST
71658: LIST
71659: LIST
71660: LIST
71661: LIST
71662: LIST
71663: LIST
71664: LIST
71665: LIST
71666: IN
71667: IFFALSE 71677
// btype = b_lab ;
71669: LD_ADDR_VAR 0 1
71673: PUSH
71674: LD_INT 6
71676: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
71677: LD_VAR 0 6
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: LD_INT 2
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: LIST
71695: IN
71696: NOT
71697: PUSH
71698: LD_VAR 0 1
71702: PUSH
71703: LD_INT 0
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: LD_INT 2
71711: PUSH
71712: LD_INT 3
71714: PUSH
71715: LD_INT 6
71717: PUSH
71718: LD_INT 36
71720: PUSH
71721: LD_INT 4
71723: PUSH
71724: LD_INT 5
71726: PUSH
71727: LD_INT 31
71729: PUSH
71730: LD_INT 32
71732: PUSH
71733: LD_INT 33
71735: PUSH
71736: EMPTY
71737: LIST
71738: LIST
71739: LIST
71740: LIST
71741: LIST
71742: LIST
71743: LIST
71744: LIST
71745: LIST
71746: LIST
71747: LIST
71748: IN
71749: NOT
71750: PUSH
71751: LD_VAR 0 6
71755: PUSH
71756: LD_INT 1
71758: EQUAL
71759: AND
71760: OR
71761: PUSH
71762: LD_VAR 0 1
71766: PUSH
71767: LD_INT 2
71769: PUSH
71770: LD_INT 3
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: IN
71777: NOT
71778: PUSH
71779: LD_VAR 0 6
71783: PUSH
71784: LD_INT 2
71786: EQUAL
71787: AND
71788: OR
71789: IFFALSE 71799
// mode = 0 ;
71791: LD_ADDR_VAR 0 6
71795: PUSH
71796: LD_INT 0
71798: ST_TO_ADDR
// case mode of 0 :
71799: LD_VAR 0 6
71803: PUSH
71804: LD_INT 0
71806: DOUBLE
71807: EQUAL
71808: IFTRUE 71812
71810: GO 83265
71812: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
71813: LD_ADDR_VAR 0 11
71817: PUSH
71818: LD_INT 0
71820: PUSH
71821: LD_INT 0
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PUSH
71828: LD_INT 0
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PUSH
71839: LD_INT 1
71841: PUSH
71842: LD_INT 0
71844: PUSH
71845: EMPTY
71846: LIST
71847: LIST
71848: PUSH
71849: LD_INT 1
71851: PUSH
71852: LD_INT 1
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 0
71861: PUSH
71862: LD_INT 1
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 1
71871: NEG
71872: PUSH
71873: LD_INT 0
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: NEG
71883: PUSH
71884: LD_INT 1
71886: NEG
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: NEG
71895: PUSH
71896: LD_INT 2
71898: NEG
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 0
71906: PUSH
71907: LD_INT 2
71909: NEG
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 1
71917: PUSH
71918: LD_INT 1
71920: NEG
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PUSH
71926: LD_INT 1
71928: PUSH
71929: LD_INT 2
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: PUSH
71936: LD_INT 0
71938: PUSH
71939: LD_INT 2
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 1
71948: NEG
71949: PUSH
71950: LD_INT 1
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 1
71959: PUSH
71960: LD_INT 3
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: LD_INT 3
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 1
71979: NEG
71980: PUSH
71981: LD_INT 2
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: PUSH
71988: EMPTY
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: LIST
71998: LIST
71999: LIST
72000: LIST
72001: LIST
72002: LIST
72003: LIST
72004: LIST
72005: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72006: LD_ADDR_VAR 0 12
72010: PUSH
72011: LD_INT 0
72013: PUSH
72014: LD_INT 0
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: PUSH
72021: LD_INT 0
72023: PUSH
72024: LD_INT 1
72026: NEG
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 1
72034: PUSH
72035: LD_INT 0
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: PUSH
72042: LD_INT 1
72044: PUSH
72045: LD_INT 1
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PUSH
72052: LD_INT 0
72054: PUSH
72055: LD_INT 1
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: PUSH
72062: LD_INT 1
72064: NEG
72065: PUSH
72066: LD_INT 0
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: LD_INT 1
72075: NEG
72076: PUSH
72077: LD_INT 1
72079: NEG
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 1
72087: PUSH
72088: LD_INT 1
72090: NEG
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 2
72098: PUSH
72099: LD_INT 0
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 2
72108: PUSH
72109: LD_INT 1
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: NEG
72119: PUSH
72120: LD_INT 1
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 2
72129: NEG
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 2
72140: NEG
72141: PUSH
72142: LD_INT 1
72144: NEG
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 2
72152: NEG
72153: PUSH
72154: LD_INT 1
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 3
72163: NEG
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: PUSH
72172: LD_INT 3
72174: NEG
72175: PUSH
72176: LD_INT 1
72178: NEG
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: EMPTY
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: LIST
72193: LIST
72194: LIST
72195: LIST
72196: LIST
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72202: LD_ADDR_VAR 0 13
72206: PUSH
72207: LD_INT 0
72209: PUSH
72210: LD_INT 0
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: LD_INT 0
72219: PUSH
72220: LD_INT 1
72222: NEG
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: LD_INT 0
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 1
72240: PUSH
72241: LD_INT 1
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: LD_INT 1
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: LD_INT 1
72260: NEG
72261: PUSH
72262: LD_INT 0
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: LD_INT 1
72271: NEG
72272: PUSH
72273: LD_INT 1
72275: NEG
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: NEG
72284: PUSH
72285: LD_INT 2
72287: NEG
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 2
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 2
72305: PUSH
72306: LD_INT 2
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 1
72315: PUSH
72316: LD_INT 2
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 2
72325: NEG
72326: PUSH
72327: LD_INT 1
72329: NEG
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: LD_INT 2
72337: NEG
72338: PUSH
72339: LD_INT 2
72341: NEG
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 2
72349: NEG
72350: PUSH
72351: LD_INT 3
72353: NEG
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: LD_INT 3
72361: NEG
72362: PUSH
72363: LD_INT 2
72365: NEG
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 3
72373: NEG
72374: PUSH
72375: LD_INT 3
72377: NEG
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: LIST
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72401: LD_ADDR_VAR 0 14
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 0
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 1
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: LD_INT 1
72439: PUSH
72440: LD_INT 1
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: PUSH
72447: LD_INT 0
72449: PUSH
72450: LD_INT 1
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 1
72459: NEG
72460: PUSH
72461: LD_INT 0
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 1
72470: NEG
72471: PUSH
72472: LD_INT 1
72474: NEG
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: LD_INT 2
72486: NEG
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 0
72494: PUSH
72495: LD_INT 2
72497: NEG
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: PUSH
72517: LD_INT 2
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: PUSH
72524: LD_INT 0
72526: PUSH
72527: LD_INT 2
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: LD_INT 1
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 1
72547: NEG
72548: PUSH
72549: LD_INT 3
72551: NEG
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 0
72559: PUSH
72560: LD_INT 3
72562: NEG
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 1
72570: PUSH
72571: LD_INT 2
72573: NEG
72574: PUSH
72575: EMPTY
72576: LIST
72577: LIST
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: LIST
72583: LIST
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72597: LD_ADDR_VAR 0 15
72601: PUSH
72602: LD_INT 0
72604: PUSH
72605: LD_INT 0
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 0
72614: PUSH
72615: LD_INT 1
72617: NEG
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 1
72625: PUSH
72626: LD_INT 0
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 1
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 0
72645: PUSH
72646: LD_INT 1
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: LD_INT 1
72655: NEG
72656: PUSH
72657: LD_INT 0
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: LD_INT 1
72666: NEG
72667: PUSH
72668: LD_INT 1
72670: NEG
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: LD_INT 1
72681: NEG
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PUSH
72687: LD_INT 2
72689: PUSH
72690: LD_INT 0
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 2
72699: PUSH
72700: LD_INT 1
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 1
72709: NEG
72710: PUSH
72711: LD_INT 1
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 2
72720: NEG
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 2
72731: NEG
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 2
72743: PUSH
72744: LD_INT 1
72746: NEG
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 3
72754: PUSH
72755: LD_INT 0
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 3
72764: PUSH
72765: LD_INT 1
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72790: LD_ADDR_VAR 0 16
72794: PUSH
72795: LD_INT 0
72797: PUSH
72798: LD_INT 0
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: LD_INT 0
72807: PUSH
72808: LD_INT 1
72810: NEG
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 1
72818: PUSH
72819: LD_INT 0
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: LD_INT 1
72828: PUSH
72829: LD_INT 1
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 0
72838: PUSH
72839: LD_INT 1
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: LD_INT 1
72848: NEG
72849: PUSH
72850: LD_INT 0
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 1
72859: NEG
72860: PUSH
72861: LD_INT 1
72863: NEG
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: LD_INT 1
72871: NEG
72872: PUSH
72873: LD_INT 2
72875: NEG
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 2
72883: PUSH
72884: LD_INT 1
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 2
72893: PUSH
72894: LD_INT 2
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 1
72903: PUSH
72904: LD_INT 2
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 2
72913: NEG
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 2
72925: NEG
72926: PUSH
72927: LD_INT 2
72929: NEG
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 3
72937: PUSH
72938: LD_INT 2
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 3
72947: PUSH
72948: LD_INT 3
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 2
72957: PUSH
72958: LD_INT 3
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: LIST
72972: LIST
72973: LIST
72974: LIST
72975: LIST
72976: LIST
72977: LIST
72978: LIST
72979: LIST
72980: LIST
72981: LIST
72982: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72983: LD_ADDR_VAR 0 17
72987: PUSH
72988: LD_INT 0
72990: PUSH
72991: LD_INT 0
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 0
73000: PUSH
73001: LD_INT 1
73003: NEG
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 1
73011: PUSH
73012: LD_INT 0
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PUSH
73019: LD_INT 1
73021: PUSH
73022: LD_INT 1
73024: PUSH
73025: EMPTY
73026: LIST
73027: LIST
73028: PUSH
73029: LD_INT 0
73031: PUSH
73032: LD_INT 1
73034: PUSH
73035: EMPTY
73036: LIST
73037: LIST
73038: PUSH
73039: LD_INT 1
73041: NEG
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 1
73052: NEG
73053: PUSH
73054: LD_INT 1
73056: NEG
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 1
73064: NEG
73065: PUSH
73066: LD_INT 2
73068: NEG
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 0
73076: PUSH
73077: LD_INT 2
73079: NEG
73080: PUSH
73081: EMPTY
73082: LIST
73083: LIST
73084: PUSH
73085: LD_INT 1
73087: PUSH
73088: LD_INT 1
73090: NEG
73091: PUSH
73092: EMPTY
73093: LIST
73094: LIST
73095: PUSH
73096: LD_INT 2
73098: PUSH
73099: LD_INT 0
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: LD_INT 2
73108: PUSH
73109: LD_INT 1
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: LD_INT 2
73118: PUSH
73119: LD_INT 2
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 1
73128: PUSH
73129: LD_INT 2
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 0
73138: PUSH
73139: LD_INT 2
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 1
73148: NEG
73149: PUSH
73150: LD_INT 1
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 2
73159: NEG
73160: PUSH
73161: LD_INT 0
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 2
73170: NEG
73171: PUSH
73172: LD_INT 1
73174: NEG
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 2
73182: NEG
73183: PUSH
73184: LD_INT 2
73186: NEG
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73213: LD_ADDR_VAR 0 18
73217: PUSH
73218: LD_INT 0
73220: PUSH
73221: LD_INT 0
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 0
73230: PUSH
73231: LD_INT 1
73233: NEG
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 1
73251: PUSH
73252: LD_INT 1
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 0
73261: PUSH
73262: LD_INT 1
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 1
73271: NEG
73272: PUSH
73273: LD_INT 0
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 1
73282: NEG
73283: PUSH
73284: LD_INT 1
73286: NEG
73287: PUSH
73288: EMPTY
73289: LIST
73290: LIST
73291: PUSH
73292: LD_INT 1
73294: NEG
73295: PUSH
73296: LD_INT 2
73298: NEG
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: PUSH
73304: LD_INT 0
73306: PUSH
73307: LD_INT 2
73309: NEG
73310: PUSH
73311: EMPTY
73312: LIST
73313: LIST
73314: PUSH
73315: LD_INT 1
73317: PUSH
73318: LD_INT 1
73320: NEG
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: LD_INT 2
73328: PUSH
73329: LD_INT 0
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 2
73338: PUSH
73339: LD_INT 1
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 2
73348: PUSH
73349: LD_INT 2
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 1
73358: PUSH
73359: LD_INT 2
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: LD_INT 2
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: NEG
73379: PUSH
73380: LD_INT 1
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 2
73389: NEG
73390: PUSH
73391: LD_INT 0
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 2
73400: NEG
73401: PUSH
73402: LD_INT 1
73404: NEG
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 2
73412: NEG
73413: PUSH
73414: LD_INT 2
73416: NEG
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: LIST
73426: LIST
73427: LIST
73428: LIST
73429: LIST
73430: LIST
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73443: LD_ADDR_VAR 0 19
73447: PUSH
73448: LD_INT 0
73450: PUSH
73451: LD_INT 0
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 0
73460: PUSH
73461: LD_INT 1
73463: NEG
73464: PUSH
73465: EMPTY
73466: LIST
73467: LIST
73468: PUSH
73469: LD_INT 1
73471: PUSH
73472: LD_INT 0
73474: PUSH
73475: EMPTY
73476: LIST
73477: LIST
73478: PUSH
73479: LD_INT 1
73481: PUSH
73482: LD_INT 1
73484: PUSH
73485: EMPTY
73486: LIST
73487: LIST
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: LD_INT 1
73494: PUSH
73495: EMPTY
73496: LIST
73497: LIST
73498: PUSH
73499: LD_INT 1
73501: NEG
73502: PUSH
73503: LD_INT 0
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: LD_INT 1
73512: NEG
73513: PUSH
73514: LD_INT 1
73516: NEG
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 1
73524: NEG
73525: PUSH
73526: LD_INT 2
73528: NEG
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: LD_INT 2
73539: NEG
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: PUSH
73545: LD_INT 1
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: PUSH
73556: LD_INT 2
73558: PUSH
73559: LD_INT 0
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: LD_INT 2
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: EMPTY
73573: LIST
73574: LIST
73575: PUSH
73576: LD_INT 2
73578: PUSH
73579: LD_INT 2
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: PUSH
73586: LD_INT 1
73588: PUSH
73589: LD_INT 2
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 0
73598: PUSH
73599: LD_INT 2
73601: PUSH
73602: EMPTY
73603: LIST
73604: LIST
73605: PUSH
73606: LD_INT 1
73608: NEG
73609: PUSH
73610: LD_INT 1
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 2
73619: NEG
73620: PUSH
73621: LD_INT 0
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 2
73630: NEG
73631: PUSH
73632: LD_INT 1
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 2
73642: NEG
73643: PUSH
73644: LD_INT 2
73646: NEG
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: LIST
73656: LIST
73657: LIST
73658: LIST
73659: LIST
73660: LIST
73661: LIST
73662: LIST
73663: LIST
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: LIST
73671: LIST
73672: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73673: LD_ADDR_VAR 0 20
73677: PUSH
73678: LD_INT 0
73680: PUSH
73681: LD_INT 0
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 0
73690: PUSH
73691: LD_INT 1
73693: NEG
73694: PUSH
73695: EMPTY
73696: LIST
73697: LIST
73698: PUSH
73699: LD_INT 1
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: PUSH
73709: LD_INT 1
73711: PUSH
73712: LD_INT 1
73714: PUSH
73715: EMPTY
73716: LIST
73717: LIST
73718: PUSH
73719: LD_INT 0
73721: PUSH
73722: LD_INT 1
73724: PUSH
73725: EMPTY
73726: LIST
73727: LIST
73728: PUSH
73729: LD_INT 1
73731: NEG
73732: PUSH
73733: LD_INT 0
73735: PUSH
73736: EMPTY
73737: LIST
73738: LIST
73739: PUSH
73740: LD_INT 1
73742: NEG
73743: PUSH
73744: LD_INT 1
73746: NEG
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: LD_INT 1
73754: NEG
73755: PUSH
73756: LD_INT 2
73758: NEG
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: PUSH
73764: LD_INT 0
73766: PUSH
73767: LD_INT 2
73769: NEG
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 1
73777: PUSH
73778: LD_INT 1
73780: NEG
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 2
73788: PUSH
73789: LD_INT 0
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 2
73798: PUSH
73799: LD_INT 1
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: LD_INT 2
73808: PUSH
73809: LD_INT 2
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: PUSH
73816: LD_INT 1
73818: PUSH
73819: LD_INT 2
73821: PUSH
73822: EMPTY
73823: LIST
73824: LIST
73825: PUSH
73826: LD_INT 0
73828: PUSH
73829: LD_INT 2
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 1
73838: NEG
73839: PUSH
73840: LD_INT 1
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 2
73849: NEG
73850: PUSH
73851: LD_INT 0
73853: PUSH
73854: EMPTY
73855: LIST
73856: LIST
73857: PUSH
73858: LD_INT 2
73860: NEG
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 2
73872: NEG
73873: PUSH
73874: LD_INT 2
73876: NEG
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73903: LD_ADDR_VAR 0 21
73907: PUSH
73908: LD_INT 0
73910: PUSH
73911: LD_INT 0
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 0
73920: PUSH
73921: LD_INT 1
73923: NEG
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: LD_INT 1
73931: PUSH
73932: LD_INT 0
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PUSH
73939: LD_INT 1
73941: PUSH
73942: LD_INT 1
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: PUSH
73949: LD_INT 0
73951: PUSH
73952: LD_INT 1
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: PUSH
73959: LD_INT 1
73961: NEG
73962: PUSH
73963: LD_INT 0
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: PUSH
73970: LD_INT 1
73972: NEG
73973: PUSH
73974: LD_INT 1
73976: NEG
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 1
73984: NEG
73985: PUSH
73986: LD_INT 2
73988: NEG
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 0
73996: PUSH
73997: LD_INT 2
73999: NEG
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 1
74007: PUSH
74008: LD_INT 1
74010: NEG
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PUSH
74016: LD_INT 2
74018: PUSH
74019: LD_INT 0
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: LD_INT 2
74028: PUSH
74029: LD_INT 1
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 2
74038: PUSH
74039: LD_INT 2
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 1
74048: PUSH
74049: LD_INT 2
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 0
74058: PUSH
74059: LD_INT 2
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: LD_INT 1
74068: NEG
74069: PUSH
74070: LD_INT 1
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: LD_INT 2
74079: NEG
74080: PUSH
74081: LD_INT 0
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 2
74090: NEG
74091: PUSH
74092: LD_INT 1
74094: NEG
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 2
74102: NEG
74103: PUSH
74104: LD_INT 2
74106: NEG
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74133: LD_ADDR_VAR 0 22
74137: PUSH
74138: LD_INT 0
74140: PUSH
74141: LD_INT 0
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PUSH
74148: LD_INT 0
74150: PUSH
74151: LD_INT 1
74153: NEG
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 1
74161: PUSH
74162: LD_INT 0
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PUSH
74169: LD_INT 1
74171: PUSH
74172: LD_INT 1
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: LD_INT 1
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 1
74191: NEG
74192: PUSH
74193: LD_INT 0
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 1
74202: NEG
74203: PUSH
74204: LD_INT 1
74206: NEG
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 1
74214: NEG
74215: PUSH
74216: LD_INT 2
74218: NEG
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 0
74226: PUSH
74227: LD_INT 2
74229: NEG
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: PUSH
74246: LD_INT 2
74248: PUSH
74249: LD_INT 0
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 2
74258: PUSH
74259: LD_INT 1
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PUSH
74266: LD_INT 2
74268: PUSH
74269: LD_INT 2
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PUSH
74276: LD_INT 1
74278: PUSH
74279: LD_INT 2
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: PUSH
74286: LD_INT 0
74288: PUSH
74289: LD_INT 2
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 1
74298: NEG
74299: PUSH
74300: LD_INT 1
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 2
74309: NEG
74310: PUSH
74311: LD_INT 0
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 2
74320: NEG
74321: PUSH
74322: LD_INT 1
74324: NEG
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: PUSH
74330: LD_INT 2
74332: NEG
74333: PUSH
74334: LD_INT 2
74336: NEG
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: EMPTY
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: LIST
74352: LIST
74353: LIST
74354: LIST
74355: LIST
74356: LIST
74357: LIST
74358: LIST
74359: LIST
74360: LIST
74361: LIST
74362: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74363: LD_ADDR_VAR 0 23
74367: PUSH
74368: LD_INT 0
74370: PUSH
74371: LD_INT 0
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 0
74380: PUSH
74381: LD_INT 1
74383: NEG
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 1
74391: PUSH
74392: LD_INT 0
74394: PUSH
74395: EMPTY
74396: LIST
74397: LIST
74398: PUSH
74399: LD_INT 1
74401: PUSH
74402: LD_INT 1
74404: PUSH
74405: EMPTY
74406: LIST
74407: LIST
74408: PUSH
74409: LD_INT 0
74411: PUSH
74412: LD_INT 1
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 1
74421: NEG
74422: PUSH
74423: LD_INT 0
74425: PUSH
74426: EMPTY
74427: LIST
74428: LIST
74429: PUSH
74430: LD_INT 1
74432: NEG
74433: PUSH
74434: LD_INT 1
74436: NEG
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PUSH
74442: LD_INT 1
74444: NEG
74445: PUSH
74446: LD_INT 2
74448: NEG
74449: PUSH
74450: EMPTY
74451: LIST
74452: LIST
74453: PUSH
74454: LD_INT 0
74456: PUSH
74457: LD_INT 2
74459: NEG
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 1
74467: PUSH
74468: LD_INT 1
74470: NEG
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 2
74478: PUSH
74479: LD_INT 0
74481: PUSH
74482: EMPTY
74483: LIST
74484: LIST
74485: PUSH
74486: LD_INT 2
74488: PUSH
74489: LD_INT 1
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 2
74498: PUSH
74499: LD_INT 2
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 1
74508: PUSH
74509: LD_INT 2
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 0
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PUSH
74526: LD_INT 1
74528: NEG
74529: PUSH
74530: LD_INT 1
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: LD_INT 2
74539: NEG
74540: PUSH
74541: LD_INT 0
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 2
74550: NEG
74551: PUSH
74552: LD_INT 1
74554: NEG
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 2
74562: NEG
74563: PUSH
74564: LD_INT 2
74566: NEG
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 2
74574: NEG
74575: PUSH
74576: LD_INT 3
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 1
74586: NEG
74587: PUSH
74588: LD_INT 3
74590: NEG
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 1
74598: PUSH
74599: LD_INT 2
74601: NEG
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 2
74609: PUSH
74610: LD_INT 1
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: LIST
74641: LIST
74642: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
74643: LD_ADDR_VAR 0 24
74647: PUSH
74648: LD_INT 0
74650: PUSH
74651: LD_INT 0
74653: PUSH
74654: EMPTY
74655: LIST
74656: LIST
74657: PUSH
74658: LD_INT 0
74660: PUSH
74661: LD_INT 1
74663: NEG
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: LD_INT 0
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: PUSH
74679: LD_INT 1
74681: PUSH
74682: LD_INT 1
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 0
74691: PUSH
74692: LD_INT 1
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: LD_INT 0
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 1
74712: NEG
74713: PUSH
74714: LD_INT 1
74716: NEG
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 1
74724: NEG
74725: PUSH
74726: LD_INT 2
74728: NEG
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 0
74736: PUSH
74737: LD_INT 2
74739: NEG
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 1
74747: PUSH
74748: LD_INT 1
74750: NEG
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 2
74758: PUSH
74759: LD_INT 0
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: LD_INT 2
74768: PUSH
74769: LD_INT 1
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 2
74778: PUSH
74779: LD_INT 2
74781: PUSH
74782: EMPTY
74783: LIST
74784: LIST
74785: PUSH
74786: LD_INT 1
74788: PUSH
74789: LD_INT 2
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: PUSH
74796: LD_INT 0
74798: PUSH
74799: LD_INT 2
74801: PUSH
74802: EMPTY
74803: LIST
74804: LIST
74805: PUSH
74806: LD_INT 1
74808: NEG
74809: PUSH
74810: LD_INT 1
74812: PUSH
74813: EMPTY
74814: LIST
74815: LIST
74816: PUSH
74817: LD_INT 2
74819: NEG
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 2
74830: NEG
74831: PUSH
74832: LD_INT 1
74834: NEG
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: LD_INT 2
74842: NEG
74843: PUSH
74844: LD_INT 2
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 1
74854: PUSH
74855: LD_INT 2
74857: NEG
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 2
74865: PUSH
74866: LD_INT 1
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 3
74876: PUSH
74877: LD_INT 1
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PUSH
74884: LD_INT 3
74886: PUSH
74887: LD_INT 2
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: LIST
74898: LIST
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: LIST
74905: LIST
74906: LIST
74907: LIST
74908: LIST
74909: LIST
74910: LIST
74911: LIST
74912: LIST
74913: LIST
74914: LIST
74915: LIST
74916: LIST
74917: LIST
74918: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
74919: LD_ADDR_VAR 0 25
74923: PUSH
74924: LD_INT 0
74926: PUSH
74927: LD_INT 0
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: LD_INT 1
74939: NEG
74940: PUSH
74941: EMPTY
74942: LIST
74943: LIST
74944: PUSH
74945: LD_INT 1
74947: PUSH
74948: LD_INT 0
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 1
74957: PUSH
74958: LD_INT 1
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 0
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 1
74977: NEG
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: PUSH
75002: LD_INT 2
75004: NEG
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: LD_INT 2
75015: NEG
75016: PUSH
75017: EMPTY
75018: LIST
75019: LIST
75020: PUSH
75021: LD_INT 1
75023: PUSH
75024: LD_INT 1
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 2
75034: PUSH
75035: LD_INT 0
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 2
75044: PUSH
75045: LD_INT 1
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 2
75054: PUSH
75055: LD_INT 2
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: LD_INT 1
75064: PUSH
75065: LD_INT 2
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: LD_INT 2
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: LD_INT 1
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 2
75095: NEG
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: PUSH
75104: LD_INT 2
75106: NEG
75107: PUSH
75108: LD_INT 1
75110: NEG
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 2
75118: NEG
75119: PUSH
75120: LD_INT 2
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 3
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 3
75140: PUSH
75141: LD_INT 2
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: LD_INT 2
75150: PUSH
75151: LD_INT 3
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 1
75160: PUSH
75161: LD_INT 3
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: LIST
75183: LIST
75184: LIST
75185: LIST
75186: LIST
75187: LIST
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
75193: LD_ADDR_VAR 0 26
75197: PUSH
75198: LD_INT 0
75200: PUSH
75201: LD_INT 0
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 0
75210: PUSH
75211: LD_INT 1
75213: NEG
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 1
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 1
75231: PUSH
75232: LD_INT 1
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 0
75241: PUSH
75242: LD_INT 1
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 0
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 1
75262: NEG
75263: PUSH
75264: LD_INT 1
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: LD_INT 1
75274: NEG
75275: PUSH
75276: LD_INT 2
75278: NEG
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PUSH
75284: LD_INT 0
75286: PUSH
75287: LD_INT 2
75289: NEG
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 1
75297: PUSH
75298: LD_INT 1
75300: NEG
75301: PUSH
75302: EMPTY
75303: LIST
75304: LIST
75305: PUSH
75306: LD_INT 2
75308: PUSH
75309: LD_INT 0
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: PUSH
75316: LD_INT 2
75318: PUSH
75319: LD_INT 1
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 2
75328: PUSH
75329: LD_INT 2
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 1
75338: PUSH
75339: LD_INT 2
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 0
75348: PUSH
75349: LD_INT 2
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 1
75358: NEG
75359: PUSH
75360: LD_INT 1
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 2
75369: NEG
75370: PUSH
75371: LD_INT 0
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 2
75380: NEG
75381: PUSH
75382: LD_INT 1
75384: NEG
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 2
75392: NEG
75393: PUSH
75394: LD_INT 2
75396: NEG
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 2
75404: PUSH
75405: LD_INT 3
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 1
75414: PUSH
75415: LD_INT 3
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 1
75424: NEG
75425: PUSH
75426: LD_INT 2
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: LD_INT 2
75435: NEG
75436: PUSH
75437: LD_INT 1
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: LIST
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75469: LD_ADDR_VAR 0 27
75473: PUSH
75474: LD_INT 0
75476: PUSH
75477: LD_INT 0
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 0
75486: PUSH
75487: LD_INT 1
75489: NEG
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 1
75497: PUSH
75498: LD_INT 0
75500: PUSH
75501: EMPTY
75502: LIST
75503: LIST
75504: PUSH
75505: LD_INT 1
75507: PUSH
75508: LD_INT 1
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 0
75517: PUSH
75518: LD_INT 1
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 1
75527: NEG
75528: PUSH
75529: LD_INT 0
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PUSH
75536: LD_INT 1
75538: NEG
75539: PUSH
75540: LD_INT 1
75542: NEG
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 1
75550: NEG
75551: PUSH
75552: LD_INT 2
75554: NEG
75555: PUSH
75556: EMPTY
75557: LIST
75558: LIST
75559: PUSH
75560: LD_INT 0
75562: PUSH
75563: LD_INT 2
75565: NEG
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 1
75573: PUSH
75574: LD_INT 1
75576: NEG
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PUSH
75582: LD_INT 2
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: EMPTY
75589: LIST
75590: LIST
75591: PUSH
75592: LD_INT 2
75594: PUSH
75595: LD_INT 1
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: PUSH
75602: LD_INT 2
75604: PUSH
75605: LD_INT 2
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 1
75614: PUSH
75615: LD_INT 2
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: PUSH
75622: LD_INT 0
75624: PUSH
75625: LD_INT 2
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 1
75634: NEG
75635: PUSH
75636: LD_INT 1
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 2
75645: NEG
75646: PUSH
75647: LD_INT 0
75649: PUSH
75650: EMPTY
75651: LIST
75652: LIST
75653: PUSH
75654: LD_INT 2
75656: NEG
75657: PUSH
75658: LD_INT 1
75660: NEG
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 2
75668: NEG
75669: PUSH
75670: LD_INT 2
75672: NEG
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 1
75680: NEG
75681: PUSH
75682: LD_INT 2
75684: PUSH
75685: EMPTY
75686: LIST
75687: LIST
75688: PUSH
75689: LD_INT 2
75691: NEG
75692: PUSH
75693: LD_INT 1
75695: PUSH
75696: EMPTY
75697: LIST
75698: LIST
75699: PUSH
75700: LD_INT 3
75702: NEG
75703: PUSH
75704: LD_INT 1
75706: NEG
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 3
75714: NEG
75715: PUSH
75716: LD_INT 2
75718: NEG
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75749: LD_ADDR_VAR 0 28
75753: PUSH
75754: LD_INT 0
75756: PUSH
75757: LD_INT 0
75759: PUSH
75760: EMPTY
75761: LIST
75762: LIST
75763: PUSH
75764: LD_INT 0
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 1
75787: PUSH
75788: LD_INT 1
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 0
75797: PUSH
75798: LD_INT 1
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 1
75807: NEG
75808: PUSH
75809: LD_INT 0
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 1
75818: NEG
75819: PUSH
75820: LD_INT 1
75822: NEG
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: LD_INT 2
75834: NEG
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 0
75842: PUSH
75843: LD_INT 2
75845: NEG
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 1
75853: PUSH
75854: LD_INT 1
75856: NEG
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 2
75864: PUSH
75865: LD_INT 0
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 2
75874: PUSH
75875: LD_INT 1
75877: PUSH
75878: EMPTY
75879: LIST
75880: LIST
75881: PUSH
75882: LD_INT 2
75884: PUSH
75885: LD_INT 2
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: PUSH
75892: LD_INT 1
75894: PUSH
75895: LD_INT 2
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PUSH
75902: LD_INT 0
75904: PUSH
75905: LD_INT 2
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 1
75914: NEG
75915: PUSH
75916: LD_INT 1
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 2
75925: NEG
75926: PUSH
75927: LD_INT 0
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 2
75936: NEG
75937: PUSH
75938: LD_INT 1
75940: NEG
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 2
75948: NEG
75949: PUSH
75950: LD_INT 2
75952: NEG
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 2
75960: NEG
75961: PUSH
75962: LD_INT 3
75964: NEG
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 1
75972: NEG
75973: PUSH
75974: LD_INT 3
75976: NEG
75977: PUSH
75978: EMPTY
75979: LIST
75980: LIST
75981: PUSH
75982: LD_INT 3
75984: NEG
75985: PUSH
75986: LD_INT 1
75988: NEG
75989: PUSH
75990: EMPTY
75991: LIST
75992: LIST
75993: PUSH
75994: LD_INT 3
75996: NEG
75997: PUSH
75998: LD_INT 2
76000: NEG
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: LIST
76015: LIST
76016: LIST
76017: LIST
76018: LIST
76019: LIST
76020: LIST
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: LIST
76026: LIST
76027: LIST
76028: LIST
76029: LIST
76030: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
76031: LD_ADDR_VAR 0 29
76035: PUSH
76036: LD_INT 0
76038: PUSH
76039: LD_INT 0
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 0
76048: PUSH
76049: LD_INT 1
76051: NEG
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 1
76059: PUSH
76060: LD_INT 0
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 1
76069: PUSH
76070: LD_INT 1
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 0
76079: PUSH
76080: LD_INT 1
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: NEG
76090: PUSH
76091: LD_INT 0
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 1
76100: NEG
76101: PUSH
76102: LD_INT 1
76104: NEG
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 1
76112: NEG
76113: PUSH
76114: LD_INT 2
76116: NEG
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 0
76124: PUSH
76125: LD_INT 2
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 1
76138: NEG
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 2
76146: PUSH
76147: LD_INT 0
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 2
76156: PUSH
76157: LD_INT 1
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 1
76166: PUSH
76167: LD_INT 2
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 0
76176: PUSH
76177: LD_INT 2
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 1
76186: NEG
76187: PUSH
76188: LD_INT 1
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 2
76197: NEG
76198: PUSH
76199: LD_INT 1
76201: NEG
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 2
76209: NEG
76210: PUSH
76211: LD_INT 2
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 2
76221: NEG
76222: PUSH
76223: LD_INT 3
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 2
76233: PUSH
76234: LD_INT 1
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 3
76244: PUSH
76245: LD_INT 1
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PUSH
76252: LD_INT 1
76254: PUSH
76255: LD_INT 3
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 1
76264: NEG
76265: PUSH
76266: LD_INT 2
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 3
76275: NEG
76276: PUSH
76277: LD_INT 2
76279: NEG
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: EMPTY
76286: LIST
76287: LIST
76288: LIST
76289: LIST
76290: LIST
76291: LIST
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76310: LD_ADDR_VAR 0 30
76314: PUSH
76315: LD_INT 0
76317: PUSH
76318: LD_INT 0
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 0
76327: PUSH
76328: LD_INT 1
76330: NEG
76331: PUSH
76332: EMPTY
76333: LIST
76334: LIST
76335: PUSH
76336: LD_INT 1
76338: PUSH
76339: LD_INT 0
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 1
76348: PUSH
76349: LD_INT 1
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 0
76358: PUSH
76359: LD_INT 1
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 1
76368: NEG
76369: PUSH
76370: LD_INT 0
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PUSH
76377: LD_INT 1
76379: NEG
76380: PUSH
76381: LD_INT 1
76383: NEG
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PUSH
76389: LD_INT 1
76391: NEG
76392: PUSH
76393: LD_INT 2
76395: NEG
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 0
76403: PUSH
76404: LD_INT 2
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 1
76414: PUSH
76415: LD_INT 1
76417: NEG
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 2
76425: PUSH
76426: LD_INT 0
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 2
76435: PUSH
76436: LD_INT 1
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: PUSH
76446: LD_INT 2
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 1
76455: PUSH
76456: LD_INT 2
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 1
76465: NEG
76466: PUSH
76467: LD_INT 1
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 2
76476: NEG
76477: PUSH
76478: LD_INT 0
76480: PUSH
76481: EMPTY
76482: LIST
76483: LIST
76484: PUSH
76485: LD_INT 2
76487: NEG
76488: PUSH
76489: LD_INT 1
76491: NEG
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 1
76499: NEG
76500: PUSH
76501: LD_INT 3
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 1
76511: PUSH
76512: LD_INT 2
76514: NEG
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PUSH
76520: LD_INT 3
76522: PUSH
76523: LD_INT 2
76525: PUSH
76526: EMPTY
76527: LIST
76528: LIST
76529: PUSH
76530: LD_INT 2
76532: PUSH
76533: LD_INT 3
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 2
76542: NEG
76543: PUSH
76544: LD_INT 1
76546: PUSH
76547: EMPTY
76548: LIST
76549: LIST
76550: PUSH
76551: LD_INT 3
76553: NEG
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: LIST
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: LIST
76572: LIST
76573: LIST
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: LIST
76579: LIST
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: LIST
76587: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
76588: LD_ADDR_VAR 0 31
76592: PUSH
76593: LD_INT 0
76595: PUSH
76596: LD_INT 0
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: LD_INT 1
76608: NEG
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 1
76616: PUSH
76617: LD_INT 0
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 1
76626: PUSH
76627: LD_INT 1
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 0
76636: PUSH
76637: LD_INT 1
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 1
76646: NEG
76647: PUSH
76648: LD_INT 0
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 1
76657: NEG
76658: PUSH
76659: LD_INT 1
76661: NEG
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: LD_INT 2
76673: NEG
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 1
76681: PUSH
76682: LD_INT 1
76684: NEG
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 2
76692: PUSH
76693: LD_INT 0
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 2
76702: PUSH
76703: LD_INT 1
76705: PUSH
76706: EMPTY
76707: LIST
76708: LIST
76709: PUSH
76710: LD_INT 2
76712: PUSH
76713: LD_INT 2
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PUSH
76720: LD_INT 1
76722: PUSH
76723: LD_INT 2
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 0
76732: PUSH
76733: LD_INT 2
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: PUSH
76740: LD_INT 1
76742: NEG
76743: PUSH
76744: LD_INT 1
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 2
76753: NEG
76754: PUSH
76755: LD_INT 1
76757: NEG
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 2
76765: NEG
76766: PUSH
76767: LD_INT 2
76769: NEG
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 2
76777: NEG
76778: PUSH
76779: LD_INT 3
76781: NEG
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 2
76789: PUSH
76790: LD_INT 1
76792: NEG
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 3
76800: PUSH
76801: LD_INT 1
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 1
76810: PUSH
76811: LD_INT 3
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 1
76820: NEG
76821: PUSH
76822: LD_INT 2
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: LD_INT 3
76831: NEG
76832: PUSH
76833: LD_INT 2
76835: NEG
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: LIST
76845: LIST
76846: LIST
76847: LIST
76848: LIST
76849: LIST
76850: LIST
76851: LIST
76852: LIST
76853: LIST
76854: LIST
76855: LIST
76856: LIST
76857: LIST
76858: LIST
76859: LIST
76860: LIST
76861: LIST
76862: LIST
76863: LIST
76864: LIST
76865: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76866: LD_ADDR_VAR 0 32
76870: PUSH
76871: LD_INT 0
76873: PUSH
76874: LD_INT 0
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 0
76883: PUSH
76884: LD_INT 1
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 1
76894: PUSH
76895: LD_INT 0
76897: PUSH
76898: EMPTY
76899: LIST
76900: LIST
76901: PUSH
76902: LD_INT 1
76904: PUSH
76905: LD_INT 1
76907: PUSH
76908: EMPTY
76909: LIST
76910: LIST
76911: PUSH
76912: LD_INT 0
76914: PUSH
76915: LD_INT 1
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 1
76924: NEG
76925: PUSH
76926: LD_INT 0
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: LD_INT 1
76935: NEG
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: EMPTY
76942: LIST
76943: LIST
76944: PUSH
76945: LD_INT 1
76947: NEG
76948: PUSH
76949: LD_INT 2
76951: NEG
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 0
76959: PUSH
76960: LD_INT 2
76962: NEG
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 1
76970: PUSH
76971: LD_INT 1
76973: NEG
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 2
76981: PUSH
76982: LD_INT 1
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 2
76991: PUSH
76992: LD_INT 2
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: LD_INT 1
77001: PUSH
77002: LD_INT 2
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PUSH
77009: LD_INT 0
77011: PUSH
77012: LD_INT 2
77014: PUSH
77015: EMPTY
77016: LIST
77017: LIST
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 2
77032: NEG
77033: PUSH
77034: LD_INT 0
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 2
77043: NEG
77044: PUSH
77045: LD_INT 1
77047: NEG
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 1
77055: NEG
77056: PUSH
77057: LD_INT 3
77059: NEG
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 1
77067: PUSH
77068: LD_INT 2
77070: NEG
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 3
77078: PUSH
77079: LD_INT 2
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 2
77088: PUSH
77089: LD_INT 3
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 2
77098: NEG
77099: PUSH
77100: LD_INT 1
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 3
77109: NEG
77110: PUSH
77111: LD_INT 1
77113: NEG
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: LIST
77123: LIST
77124: LIST
77125: LIST
77126: LIST
77127: LIST
77128: LIST
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
77144: LD_ADDR_VAR 0 33
77148: PUSH
77149: LD_INT 0
77151: PUSH
77152: LD_INT 0
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 0
77161: PUSH
77162: LD_INT 1
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 1
77172: PUSH
77173: LD_INT 0
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 1
77182: PUSH
77183: LD_INT 1
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 0
77192: PUSH
77193: LD_INT 1
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 1
77202: NEG
77203: PUSH
77204: LD_INT 0
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 1
77213: NEG
77214: PUSH
77215: LD_INT 1
77217: NEG
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 1
77225: NEG
77226: PUSH
77227: LD_INT 2
77229: NEG
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 1
77237: PUSH
77238: LD_INT 1
77240: NEG
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 2
77248: PUSH
77249: LD_INT 0
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 2
77258: PUSH
77259: LD_INT 1
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 1
77268: PUSH
77269: LD_INT 2
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 0
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 1
77288: NEG
77289: PUSH
77290: LD_INT 1
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 2
77299: NEG
77300: PUSH
77301: LD_INT 0
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 2
77310: NEG
77311: PUSH
77312: LD_INT 1
77314: NEG
77315: PUSH
77316: EMPTY
77317: LIST
77318: LIST
77319: PUSH
77320: LD_INT 2
77322: NEG
77323: PUSH
77324: LD_INT 2
77326: NEG
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 2
77334: NEG
77335: PUSH
77336: LD_INT 3
77338: NEG
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 2
77346: PUSH
77347: LD_INT 1
77349: NEG
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 3
77357: PUSH
77358: LD_INT 1
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 1
77367: PUSH
77368: LD_INT 3
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: LD_INT 1
77377: NEG
77378: PUSH
77379: LD_INT 2
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 3
77388: NEG
77389: PUSH
77390: LD_INT 2
77392: NEG
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: LIST
77408: LIST
77409: LIST
77410: LIST
77411: LIST
77412: LIST
77413: LIST
77414: LIST
77415: LIST
77416: LIST
77417: LIST
77418: LIST
77419: LIST
77420: LIST
77421: LIST
77422: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77423: LD_ADDR_VAR 0 34
77427: PUSH
77428: LD_INT 0
77430: PUSH
77431: LD_INT 0
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 0
77440: PUSH
77441: LD_INT 1
77443: NEG
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 1
77451: PUSH
77452: LD_INT 0
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 1
77461: PUSH
77462: LD_INT 1
77464: PUSH
77465: EMPTY
77466: LIST
77467: LIST
77468: PUSH
77469: LD_INT 0
77471: PUSH
77472: LD_INT 1
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: PUSH
77479: LD_INT 1
77481: NEG
77482: PUSH
77483: LD_INT 0
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 1
77492: NEG
77493: PUSH
77494: LD_INT 1
77496: NEG
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 1
77504: NEG
77505: PUSH
77506: LD_INT 2
77508: NEG
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PUSH
77514: LD_INT 0
77516: PUSH
77517: LD_INT 2
77519: NEG
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 1
77527: PUSH
77528: LD_INT 1
77530: NEG
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 2
77538: PUSH
77539: LD_INT 1
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: LD_INT 2
77548: PUSH
77549: LD_INT 2
77551: PUSH
77552: EMPTY
77553: LIST
77554: LIST
77555: PUSH
77556: LD_INT 1
77558: PUSH
77559: LD_INT 2
77561: PUSH
77562: EMPTY
77563: LIST
77564: LIST
77565: PUSH
77566: LD_INT 1
77568: NEG
77569: PUSH
77570: LD_INT 1
77572: PUSH
77573: EMPTY
77574: LIST
77575: LIST
77576: PUSH
77577: LD_INT 2
77579: NEG
77580: PUSH
77581: LD_INT 0
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PUSH
77588: LD_INT 2
77590: NEG
77591: PUSH
77592: LD_INT 1
77594: NEG
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: LD_INT 2
77602: NEG
77603: PUSH
77604: LD_INT 2
77606: NEG
77607: PUSH
77608: EMPTY
77609: LIST
77610: LIST
77611: PUSH
77612: LD_INT 1
77614: NEG
77615: PUSH
77616: LD_INT 3
77618: NEG
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: LD_INT 1
77626: PUSH
77627: LD_INT 2
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 3
77637: PUSH
77638: LD_INT 2
77640: PUSH
77641: EMPTY
77642: LIST
77643: LIST
77644: PUSH
77645: LD_INT 2
77647: PUSH
77648: LD_INT 3
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: PUSH
77655: LD_INT 2
77657: NEG
77658: PUSH
77659: LD_INT 1
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 3
77668: NEG
77669: PUSH
77670: LD_INT 1
77672: NEG
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
77703: LD_ADDR_VAR 0 35
77707: PUSH
77708: LD_INT 0
77710: PUSH
77711: LD_INT 0
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 1
77723: NEG
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: LD_INT 1
77731: PUSH
77732: LD_INT 0
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 1
77741: PUSH
77742: LD_INT 1
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 0
77751: PUSH
77752: LD_INT 1
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: LD_INT 1
77761: NEG
77762: PUSH
77763: LD_INT 0
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: LD_INT 1
77772: NEG
77773: PUSH
77774: LD_INT 1
77776: NEG
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: LD_INT 2
77784: PUSH
77785: LD_INT 1
77787: PUSH
77788: EMPTY
77789: LIST
77790: LIST
77791: PUSH
77792: LD_INT 2
77794: NEG
77795: PUSH
77796: LD_INT 1
77798: NEG
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: LIST
77808: LIST
77809: LIST
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
77815: LD_ADDR_VAR 0 36
77819: PUSH
77820: LD_INT 0
77822: PUSH
77823: LD_INT 0
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 0
77832: PUSH
77833: LD_INT 1
77835: NEG
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 1
77843: PUSH
77844: LD_INT 0
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 1
77853: PUSH
77854: LD_INT 1
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 0
77863: PUSH
77864: LD_INT 1
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 1
77873: NEG
77874: PUSH
77875: LD_INT 0
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 1
77884: NEG
77885: PUSH
77886: LD_INT 1
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 1
77896: NEG
77897: PUSH
77898: LD_INT 2
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 1
77908: PUSH
77909: LD_INT 2
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: EMPTY
77917: LIST
77918: LIST
77919: LIST
77920: LIST
77921: LIST
77922: LIST
77923: LIST
77924: LIST
77925: LIST
77926: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
77927: LD_ADDR_VAR 0 37
77931: PUSH
77932: LD_INT 0
77934: PUSH
77935: LD_INT 0
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 0
77944: PUSH
77945: LD_INT 1
77947: NEG
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 1
77955: PUSH
77956: LD_INT 0
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 1
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 0
77975: PUSH
77976: LD_INT 1
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: PUSH
77983: LD_INT 1
77985: NEG
77986: PUSH
77987: LD_INT 0
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: LD_INT 1
77996: NEG
77997: PUSH
77998: LD_INT 1
78000: NEG
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 1
78008: PUSH
78009: LD_INT 1
78011: NEG
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 1
78019: NEG
78020: PUSH
78021: LD_INT 1
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: LIST
78032: LIST
78033: LIST
78034: LIST
78035: LIST
78036: LIST
78037: LIST
78038: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
78039: LD_ADDR_VAR 0 38
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: LD_INT 0
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: LD_INT 0
78056: PUSH
78057: LD_INT 1
78059: NEG
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: PUSH
78065: LD_INT 1
78067: PUSH
78068: LD_INT 0
78070: PUSH
78071: EMPTY
78072: LIST
78073: LIST
78074: PUSH
78075: LD_INT 1
78077: PUSH
78078: LD_INT 1
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: PUSH
78085: LD_INT 0
78087: PUSH
78088: LD_INT 1
78090: PUSH
78091: EMPTY
78092: LIST
78093: LIST
78094: PUSH
78095: LD_INT 1
78097: NEG
78098: PUSH
78099: LD_INT 0
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: PUSH
78106: LD_INT 1
78108: NEG
78109: PUSH
78110: LD_INT 1
78112: NEG
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 2
78130: NEG
78131: PUSH
78132: LD_INT 1
78134: NEG
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
78151: LD_ADDR_VAR 0 39
78155: PUSH
78156: LD_INT 0
78158: PUSH
78159: LD_INT 0
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: LD_INT 0
78168: PUSH
78169: LD_INT 1
78171: NEG
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: PUSH
78180: LD_INT 0
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: PUSH
78187: LD_INT 1
78189: PUSH
78190: LD_INT 1
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: LD_INT 0
78199: PUSH
78200: LD_INT 1
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PUSH
78207: LD_INT 1
78209: NEG
78210: PUSH
78211: LD_INT 0
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 1
78220: NEG
78221: PUSH
78222: LD_INT 1
78224: NEG
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 1
78232: NEG
78233: PUSH
78234: LD_INT 2
78236: NEG
78237: PUSH
78238: EMPTY
78239: LIST
78240: LIST
78241: PUSH
78242: LD_INT 1
78244: PUSH
78245: LD_INT 2
78247: PUSH
78248: EMPTY
78249: LIST
78250: LIST
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: LIST
78256: LIST
78257: LIST
78258: LIST
78259: LIST
78260: LIST
78261: LIST
78262: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
78263: LD_ADDR_VAR 0 40
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: LD_INT 0
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 0
78280: PUSH
78281: LD_INT 1
78283: NEG
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 1
78291: PUSH
78292: LD_INT 0
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: PUSH
78299: LD_INT 1
78301: PUSH
78302: LD_INT 1
78304: PUSH
78305: EMPTY
78306: LIST
78307: LIST
78308: PUSH
78309: LD_INT 0
78311: PUSH
78312: LD_INT 1
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 1
78321: NEG
78322: PUSH
78323: LD_INT 0
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 1
78332: NEG
78333: PUSH
78334: LD_INT 1
78336: NEG
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: LD_INT 1
78347: NEG
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: NEG
78356: PUSH
78357: LD_INT 1
78359: PUSH
78360: EMPTY
78361: LIST
78362: LIST
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: LIST
78372: LIST
78373: LIST
78374: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78375: LD_ADDR_VAR 0 41
78379: PUSH
78380: LD_INT 0
78382: PUSH
78383: LD_INT 0
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 0
78392: PUSH
78393: LD_INT 1
78395: NEG
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 1
78403: PUSH
78404: LD_INT 0
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 1
78413: PUSH
78414: LD_INT 1
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 0
78423: PUSH
78424: LD_INT 1
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 1
78433: NEG
78434: PUSH
78435: LD_INT 0
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 1
78444: NEG
78445: PUSH
78446: LD_INT 1
78448: NEG
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 1
78456: NEG
78457: PUSH
78458: LD_INT 2
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: PUSH
78469: LD_INT 1
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 2
78479: PUSH
78480: LD_INT 0
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 2
78489: PUSH
78490: LD_INT 1
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 2
78499: PUSH
78500: LD_INT 2
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 1
78509: PUSH
78510: LD_INT 2
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 1
78519: NEG
78520: PUSH
78521: LD_INT 1
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 2
78530: NEG
78531: PUSH
78532: LD_INT 0
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PUSH
78539: LD_INT 2
78541: NEG
78542: PUSH
78543: LD_INT 1
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 2
78553: NEG
78554: PUSH
78555: LD_INT 2
78557: NEG
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 2
78565: NEG
78566: PUSH
78567: LD_INT 3
78569: NEG
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 2
78577: PUSH
78578: LD_INT 1
78580: NEG
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 3
78588: PUSH
78589: LD_INT 0
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 3
78598: PUSH
78599: LD_INT 1
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 3
78608: PUSH
78609: LD_INT 2
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 3
78618: PUSH
78619: LD_INT 3
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 2
78628: PUSH
78629: LD_INT 3
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 2
78638: NEG
78639: PUSH
78640: LD_INT 1
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 3
78649: NEG
78650: PUSH
78651: LD_INT 0
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 3
78660: NEG
78661: PUSH
78662: LD_INT 1
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 3
78672: NEG
78673: PUSH
78674: LD_INT 2
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 3
78684: NEG
78685: PUSH
78686: LD_INT 3
78688: NEG
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: LIST
78716: LIST
78717: LIST
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78725: LD_ADDR_VAR 0 42
78729: PUSH
78730: LD_INT 0
78732: PUSH
78733: LD_INT 0
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 0
78742: PUSH
78743: LD_INT 1
78745: NEG
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 1
78753: PUSH
78754: LD_INT 0
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 1
78763: PUSH
78764: LD_INT 1
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 0
78773: PUSH
78774: LD_INT 1
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 1
78783: NEG
78784: PUSH
78785: LD_INT 0
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 1
78794: NEG
78795: PUSH
78796: LD_INT 1
78798: NEG
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 1
78806: NEG
78807: PUSH
78808: LD_INT 2
78810: NEG
78811: PUSH
78812: EMPTY
78813: LIST
78814: LIST
78815: PUSH
78816: LD_INT 0
78818: PUSH
78819: LD_INT 2
78821: NEG
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PUSH
78827: LD_INT 1
78829: PUSH
78830: LD_INT 1
78832: NEG
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: PUSH
78838: LD_INT 2
78840: PUSH
78841: LD_INT 1
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 2
78850: PUSH
78851: LD_INT 2
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 1
78860: PUSH
78861: LD_INT 2
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: LD_INT 2
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 1
78880: NEG
78881: PUSH
78882: LD_INT 1
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 2
78891: NEG
78892: PUSH
78893: LD_INT 1
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 2
78903: NEG
78904: PUSH
78905: LD_INT 2
78907: NEG
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 2
78915: NEG
78916: PUSH
78917: LD_INT 3
78919: NEG
78920: PUSH
78921: EMPTY
78922: LIST
78923: LIST
78924: PUSH
78925: LD_INT 1
78927: NEG
78928: PUSH
78929: LD_INT 3
78931: NEG
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 0
78939: PUSH
78940: LD_INT 3
78942: NEG
78943: PUSH
78944: EMPTY
78945: LIST
78946: LIST
78947: PUSH
78948: LD_INT 1
78950: PUSH
78951: LD_INT 2
78953: NEG
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 3
78961: PUSH
78962: LD_INT 2
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 3
78971: PUSH
78972: LD_INT 3
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 2
78981: PUSH
78982: LD_INT 3
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: LD_INT 3
78994: PUSH
78995: EMPTY
78996: LIST
78997: LIST
78998: PUSH
78999: LD_INT 0
79001: PUSH
79002: LD_INT 3
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 1
79011: NEG
79012: PUSH
79013: LD_INT 2
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: LD_INT 3
79022: NEG
79023: PUSH
79024: LD_INT 2
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 3
79034: NEG
79035: PUSH
79036: LD_INT 3
79038: NEG
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: LIST
79048: LIST
79049: LIST
79050: LIST
79051: LIST
79052: LIST
79053: LIST
79054: LIST
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: LIST
79062: LIST
79063: LIST
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79075: LD_ADDR_VAR 0 43
79079: PUSH
79080: LD_INT 0
79082: PUSH
79083: LD_INT 0
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 0
79092: PUSH
79093: LD_INT 1
79095: NEG
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: LD_INT 1
79103: PUSH
79104: LD_INT 0
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 1
79113: PUSH
79114: LD_INT 1
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 0
79123: PUSH
79124: LD_INT 1
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 1
79133: NEG
79134: PUSH
79135: LD_INT 0
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 1
79144: NEG
79145: PUSH
79146: LD_INT 1
79148: NEG
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: LD_INT 1
79156: NEG
79157: PUSH
79158: LD_INT 2
79160: NEG
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: PUSH
79166: LD_INT 0
79168: PUSH
79169: LD_INT 2
79171: NEG
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 1
79179: PUSH
79180: LD_INT 1
79182: NEG
79183: PUSH
79184: EMPTY
79185: LIST
79186: LIST
79187: PUSH
79188: LD_INT 2
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 2
79200: PUSH
79201: LD_INT 1
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 1
79210: PUSH
79211: LD_INT 2
79213: PUSH
79214: EMPTY
79215: LIST
79216: LIST
79217: PUSH
79218: LD_INT 0
79220: PUSH
79221: LD_INT 2
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PUSH
79228: LD_INT 1
79230: NEG
79231: PUSH
79232: LD_INT 1
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: NEG
79242: PUSH
79243: LD_INT 0
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 2
79252: NEG
79253: PUSH
79254: LD_INT 1
79256: NEG
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 1
79264: NEG
79265: PUSH
79266: LD_INT 3
79268: NEG
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 0
79276: PUSH
79277: LD_INT 3
79279: NEG
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: PUSH
79285: LD_INT 1
79287: PUSH
79288: LD_INT 2
79290: NEG
79291: PUSH
79292: EMPTY
79293: LIST
79294: LIST
79295: PUSH
79296: LD_INT 2
79298: PUSH
79299: LD_INT 1
79301: NEG
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 3
79309: PUSH
79310: LD_INT 0
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 3
79319: PUSH
79320: LD_INT 1
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 1
79329: PUSH
79330: LD_INT 3
79332: PUSH
79333: EMPTY
79334: LIST
79335: LIST
79336: PUSH
79337: LD_INT 0
79339: PUSH
79340: LD_INT 3
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: NEG
79350: PUSH
79351: LD_INT 2
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 2
79360: NEG
79361: PUSH
79362: LD_INT 1
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 3
79371: NEG
79372: PUSH
79373: LD_INT 0
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 3
79382: NEG
79383: PUSH
79384: LD_INT 1
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79423: LD_ADDR_VAR 0 44
79427: PUSH
79428: LD_INT 0
79430: PUSH
79431: LD_INT 0
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: LD_INT 1
79443: NEG
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 1
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 1
79461: PUSH
79462: LD_INT 1
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 0
79471: PUSH
79472: LD_INT 1
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 1
79481: NEG
79482: PUSH
79483: LD_INT 0
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 1
79492: NEG
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 1
79504: NEG
79505: PUSH
79506: LD_INT 2
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 1
79516: PUSH
79517: LD_INT 1
79519: NEG
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: LD_INT 0
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 2
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 2
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: PUSH
79558: LD_INT 2
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 1
79567: NEG
79568: PUSH
79569: LD_INT 1
79571: PUSH
79572: EMPTY
79573: LIST
79574: LIST
79575: PUSH
79576: LD_INT 2
79578: NEG
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 2
79589: NEG
79590: PUSH
79591: LD_INT 1
79593: NEG
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: LD_INT 2
79601: NEG
79602: PUSH
79603: LD_INT 2
79605: NEG
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: PUSH
79611: LD_INT 2
79613: NEG
79614: PUSH
79615: LD_INT 3
79617: NEG
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 2
79625: PUSH
79626: LD_INT 1
79628: NEG
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 3
79636: PUSH
79637: LD_INT 0
79639: PUSH
79640: EMPTY
79641: LIST
79642: LIST
79643: PUSH
79644: LD_INT 3
79646: PUSH
79647: LD_INT 1
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PUSH
79654: LD_INT 3
79656: PUSH
79657: LD_INT 2
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 3
79666: PUSH
79667: LD_INT 3
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 2
79676: PUSH
79677: LD_INT 3
79679: PUSH
79680: EMPTY
79681: LIST
79682: LIST
79683: PUSH
79684: LD_INT 2
79686: NEG
79687: PUSH
79688: LD_INT 1
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 3
79697: NEG
79698: PUSH
79699: LD_INT 0
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 3
79708: NEG
79709: PUSH
79710: LD_INT 1
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 3
79720: NEG
79721: PUSH
79722: LD_INT 2
79724: NEG
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: LD_INT 3
79732: NEG
79733: PUSH
79734: LD_INT 3
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79773: LD_ADDR_VAR 0 45
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: LD_INT 1
79793: NEG
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: LD_INT 0
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 1
79811: PUSH
79812: LD_INT 1
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 0
79821: PUSH
79822: LD_INT 1
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: LD_INT 1
79831: NEG
79832: PUSH
79833: LD_INT 0
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 1
79842: NEG
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 1
79854: NEG
79855: PUSH
79856: LD_INT 2
79858: NEG
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 0
79866: PUSH
79867: LD_INT 2
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 1
79877: PUSH
79878: LD_INT 1
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 2
79888: PUSH
79889: LD_INT 1
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 2
79898: PUSH
79899: LD_INT 2
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 1
79908: PUSH
79909: LD_INT 2
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 0
79918: PUSH
79919: LD_INT 2
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 1
79928: NEG
79929: PUSH
79930: LD_INT 1
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 2
79939: NEG
79940: PUSH
79941: LD_INT 1
79943: NEG
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 2
79951: NEG
79952: PUSH
79953: LD_INT 2
79955: NEG
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 2
79963: NEG
79964: PUSH
79965: LD_INT 3
79967: NEG
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: PUSH
79973: LD_INT 1
79975: NEG
79976: PUSH
79977: LD_INT 3
79979: NEG
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 0
79987: PUSH
79988: LD_INT 3
79990: NEG
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PUSH
79996: LD_INT 1
79998: PUSH
79999: LD_INT 2
80001: NEG
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: LD_INT 2
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 3
80019: PUSH
80020: LD_INT 3
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 2
80029: PUSH
80030: LD_INT 3
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 1
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 0
80049: PUSH
80050: LD_INT 3
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: LD_INT 1
80059: NEG
80060: PUSH
80061: LD_INT 2
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 3
80070: NEG
80071: PUSH
80072: LD_INT 2
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 3
80082: NEG
80083: PUSH
80084: LD_INT 3
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: LIST
80107: LIST
80108: LIST
80109: LIST
80110: LIST
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80123: LD_ADDR_VAR 0 46
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: LD_INT 0
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 0
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: PUSH
80152: LD_INT 0
80154: PUSH
80155: EMPTY
80156: LIST
80157: LIST
80158: PUSH
80159: LD_INT 1
80161: PUSH
80162: LD_INT 1
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: LD_INT 0
80171: PUSH
80172: LD_INT 1
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 1
80181: NEG
80182: PUSH
80183: LD_INT 0
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 1
80192: NEG
80193: PUSH
80194: LD_INT 1
80196: NEG
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 1
80204: NEG
80205: PUSH
80206: LD_INT 2
80208: NEG
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 0
80216: PUSH
80217: LD_INT 2
80219: NEG
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 1
80227: PUSH
80228: LD_INT 1
80230: NEG
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 2
80238: PUSH
80239: LD_INT 0
80241: PUSH
80242: EMPTY
80243: LIST
80244: LIST
80245: PUSH
80246: LD_INT 2
80248: PUSH
80249: LD_INT 1
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 1
80258: PUSH
80259: LD_INT 2
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 0
80268: PUSH
80269: LD_INT 2
80271: PUSH
80272: EMPTY
80273: LIST
80274: LIST
80275: PUSH
80276: LD_INT 1
80278: NEG
80279: PUSH
80280: LD_INT 1
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 2
80289: NEG
80290: PUSH
80291: LD_INT 0
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 2
80300: NEG
80301: PUSH
80302: LD_INT 1
80304: NEG
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 1
80312: NEG
80313: PUSH
80314: LD_INT 3
80316: NEG
80317: PUSH
80318: EMPTY
80319: LIST
80320: LIST
80321: PUSH
80322: LD_INT 0
80324: PUSH
80325: LD_INT 3
80327: NEG
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 1
80335: PUSH
80336: LD_INT 2
80338: NEG
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 2
80346: PUSH
80347: LD_INT 1
80349: NEG
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: LD_INT 3
80357: PUSH
80358: LD_INT 0
80360: PUSH
80361: EMPTY
80362: LIST
80363: LIST
80364: PUSH
80365: LD_INT 3
80367: PUSH
80368: LD_INT 1
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 1
80377: PUSH
80378: LD_INT 3
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 0
80387: PUSH
80388: LD_INT 3
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 1
80397: NEG
80398: PUSH
80399: LD_INT 2
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 2
80408: NEG
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 3
80419: NEG
80420: PUSH
80421: LD_INT 0
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 3
80430: NEG
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: LIST
80446: LIST
80447: LIST
80448: LIST
80449: LIST
80450: LIST
80451: LIST
80452: LIST
80453: LIST
80454: LIST
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80471: LD_ADDR_VAR 0 47
80475: PUSH
80476: LD_INT 0
80478: PUSH
80479: LD_INT 0
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 0
80488: PUSH
80489: LD_INT 1
80491: NEG
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: LD_INT 0
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 1
80509: PUSH
80510: LD_INT 1
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: PUSH
80517: LD_INT 0
80519: PUSH
80520: LD_INT 1
80522: PUSH
80523: EMPTY
80524: LIST
80525: LIST
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: LD_INT 0
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 1
80540: NEG
80541: PUSH
80542: LD_INT 1
80544: NEG
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 1
80552: NEG
80553: PUSH
80554: LD_INT 2
80556: NEG
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 0
80564: PUSH
80565: LD_INT 2
80567: NEG
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PUSH
80573: LD_INT 1
80575: PUSH
80576: LD_INT 1
80578: NEG
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: PUSH
80584: LD_INT 2
80586: NEG
80587: PUSH
80588: LD_INT 1
80590: NEG
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 2
80598: NEG
80599: PUSH
80600: LD_INT 2
80602: NEG
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80622: LD_ADDR_VAR 0 48
80626: PUSH
80627: LD_INT 0
80629: PUSH
80630: LD_INT 0
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 0
80639: PUSH
80640: LD_INT 1
80642: NEG
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 1
80650: PUSH
80651: LD_INT 0
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: PUSH
80661: LD_INT 1
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 0
80670: PUSH
80671: LD_INT 1
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: LD_INT 0
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 1
80691: NEG
80692: PUSH
80693: LD_INT 1
80695: NEG
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 1
80703: NEG
80704: PUSH
80705: LD_INT 2
80707: NEG
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 0
80715: PUSH
80716: LD_INT 2
80718: NEG
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 1
80726: PUSH
80727: LD_INT 1
80729: NEG
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 2
80737: PUSH
80738: LD_INT 0
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 2
80747: PUSH
80748: LD_INT 1
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80769: LD_ADDR_VAR 0 49
80773: PUSH
80774: LD_INT 0
80776: PUSH
80777: LD_INT 0
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 0
80786: PUSH
80787: LD_INT 1
80789: NEG
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 1
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 0
80817: PUSH
80818: LD_INT 1
80820: PUSH
80821: EMPTY
80822: LIST
80823: LIST
80824: PUSH
80825: LD_INT 1
80827: NEG
80828: PUSH
80829: LD_INT 0
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 1
80838: NEG
80839: PUSH
80840: LD_INT 1
80842: NEG
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 1
80850: PUSH
80851: LD_INT 1
80853: NEG
80854: PUSH
80855: EMPTY
80856: LIST
80857: LIST
80858: PUSH
80859: LD_INT 2
80861: PUSH
80862: LD_INT 0
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 2
80871: PUSH
80872: LD_INT 1
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 2
80881: PUSH
80882: LD_INT 2
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 1
80891: PUSH
80892: LD_INT 2
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80913: LD_ADDR_VAR 0 50
80917: PUSH
80918: LD_INT 0
80920: PUSH
80921: LD_INT 0
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: PUSH
80928: LD_INT 0
80930: PUSH
80931: LD_INT 1
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: LD_INT 0
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 1
80951: PUSH
80952: LD_INT 1
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 0
80961: PUSH
80962: LD_INT 1
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 1
80971: NEG
80972: PUSH
80973: LD_INT 0
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 1
80982: NEG
80983: PUSH
80984: LD_INT 1
80986: NEG
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 2
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: EMPTY
80999: LIST
81000: LIST
81001: PUSH
81002: LD_INT 2
81004: PUSH
81005: LD_INT 2
81007: PUSH
81008: EMPTY
81009: LIST
81010: LIST
81011: PUSH
81012: LD_INT 1
81014: PUSH
81015: LD_INT 2
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: LD_INT 2
81027: PUSH
81028: EMPTY
81029: LIST
81030: LIST
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: LD_INT 1
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
81057: LD_ADDR_VAR 0 51
81061: PUSH
81062: LD_INT 0
81064: PUSH
81065: LD_INT 0
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: PUSH
81072: LD_INT 0
81074: PUSH
81075: LD_INT 1
81077: NEG
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: LD_INT 0
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 1
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 0
81105: PUSH
81106: LD_INT 1
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 1
81115: NEG
81116: PUSH
81117: LD_INT 0
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 1
81126: NEG
81127: PUSH
81128: LD_INT 1
81130: NEG
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 1
81138: PUSH
81139: LD_INT 2
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 0
81148: PUSH
81149: LD_INT 2
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 1
81158: NEG
81159: PUSH
81160: LD_INT 1
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 2
81169: NEG
81170: PUSH
81171: LD_INT 0
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 2
81180: NEG
81181: PUSH
81182: LD_INT 1
81184: NEG
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: LIST
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81204: LD_ADDR_VAR 0 52
81208: PUSH
81209: LD_INT 0
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 0
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 1
81232: PUSH
81233: LD_INT 0
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 1
81242: PUSH
81243: LD_INT 1
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 0
81252: PUSH
81253: LD_INT 1
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 1
81262: NEG
81263: PUSH
81264: LD_INT 0
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 1
81273: NEG
81274: PUSH
81275: LD_INT 1
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 1
81285: NEG
81286: PUSH
81287: LD_INT 2
81289: NEG
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 1
81297: NEG
81298: PUSH
81299: LD_INT 1
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: NEG
81309: PUSH
81310: LD_INT 0
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 2
81319: NEG
81320: PUSH
81321: LD_INT 1
81323: NEG
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PUSH
81329: LD_INT 2
81331: NEG
81332: PUSH
81333: LD_INT 2
81335: NEG
81336: PUSH
81337: EMPTY
81338: LIST
81339: LIST
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: LIST
81350: LIST
81351: LIST
81352: LIST
81353: LIST
81354: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81355: LD_ADDR_VAR 0 53
81359: PUSH
81360: LD_INT 0
81362: PUSH
81363: LD_INT 0
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 0
81372: PUSH
81373: LD_INT 1
81375: NEG
81376: PUSH
81377: EMPTY
81378: LIST
81379: LIST
81380: PUSH
81381: LD_INT 1
81383: PUSH
81384: LD_INT 0
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: LD_INT 1
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: LD_INT 1
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 1
81413: NEG
81414: PUSH
81415: LD_INT 0
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 1
81424: NEG
81425: PUSH
81426: LD_INT 1
81428: NEG
81429: PUSH
81430: EMPTY
81431: LIST
81432: LIST
81433: PUSH
81434: LD_INT 1
81436: NEG
81437: PUSH
81438: LD_INT 2
81440: NEG
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: PUSH
81446: LD_INT 0
81448: PUSH
81449: LD_INT 2
81451: NEG
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 1
81459: PUSH
81460: LD_INT 1
81462: NEG
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 2
81470: PUSH
81471: LD_INT 0
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 2
81480: PUSH
81481: LD_INT 1
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 2
81490: PUSH
81491: LD_INT 2
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: LD_INT 1
81500: PUSH
81501: LD_INT 2
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 0
81510: PUSH
81511: LD_INT 2
81513: PUSH
81514: EMPTY
81515: LIST
81516: LIST
81517: PUSH
81518: LD_INT 1
81520: NEG
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: EMPTY
81526: LIST
81527: LIST
81528: PUSH
81529: LD_INT 2
81531: NEG
81532: PUSH
81533: LD_INT 0
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 2
81542: NEG
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 2
81554: NEG
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81585: LD_ADDR_VAR 0 54
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: LD_INT 0
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 0
81602: PUSH
81603: LD_INT 1
81605: NEG
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 1
81613: PUSH
81614: LD_INT 0
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: LD_INT 1
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: LD_INT 1
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 1
81643: NEG
81644: PUSH
81645: LD_INT 0
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: LD_INT 1
81654: NEG
81655: PUSH
81656: LD_INT 1
81658: NEG
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 1
81666: NEG
81667: PUSH
81668: LD_INT 2
81670: NEG
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 0
81678: PUSH
81679: LD_INT 2
81681: NEG
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 1
81689: PUSH
81690: LD_INT 1
81692: NEG
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 2
81700: PUSH
81701: LD_INT 0
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: PUSH
81708: LD_INT 2
81710: PUSH
81711: LD_INT 1
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 2
81720: PUSH
81721: LD_INT 2
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: LD_INT 2
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 0
81740: PUSH
81741: LD_INT 2
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PUSH
81748: LD_INT 1
81750: NEG
81751: PUSH
81752: LD_INT 1
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 2
81761: NEG
81762: PUSH
81763: LD_INT 0
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: PUSH
81770: LD_INT 2
81772: NEG
81773: PUSH
81774: LD_INT 1
81776: NEG
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PUSH
81782: LD_INT 2
81784: NEG
81785: PUSH
81786: LD_INT 2
81788: NEG
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81815: LD_ADDR_VAR 0 55
81819: PUSH
81820: LD_INT 0
81822: PUSH
81823: LD_INT 0
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 0
81832: PUSH
81833: LD_INT 1
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 1
81843: PUSH
81844: LD_INT 0
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: LD_INT 1
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 0
81863: PUSH
81864: LD_INT 1
81866: PUSH
81867: EMPTY
81868: LIST
81869: LIST
81870: PUSH
81871: LD_INT 1
81873: NEG
81874: PUSH
81875: LD_INT 0
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 1
81884: NEG
81885: PUSH
81886: LD_INT 1
81888: NEG
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 1
81896: NEG
81897: PUSH
81898: LD_INT 2
81900: NEG
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 0
81908: PUSH
81909: LD_INT 2
81911: NEG
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 2
81930: PUSH
81931: LD_INT 0
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 2
81940: PUSH
81941: LD_INT 1
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 2
81950: PUSH
81951: LD_INT 2
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 1
81960: PUSH
81961: LD_INT 2
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: LD_INT 2
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 1
81980: NEG
81981: PUSH
81982: LD_INT 1
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: PUSH
81989: LD_INT 2
81991: NEG
81992: PUSH
81993: LD_INT 0
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PUSH
82000: LD_INT 2
82002: NEG
82003: PUSH
82004: LD_INT 1
82006: NEG
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: PUSH
82012: LD_INT 2
82014: NEG
82015: PUSH
82016: LD_INT 2
82018: NEG
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82045: LD_ADDR_VAR 0 56
82049: PUSH
82050: LD_INT 0
82052: PUSH
82053: LD_INT 0
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 0
82062: PUSH
82063: LD_INT 1
82065: NEG
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 1
82073: PUSH
82074: LD_INT 0
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: LD_INT 1
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 0
82093: PUSH
82094: LD_INT 1
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 1
82103: NEG
82104: PUSH
82105: LD_INT 0
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 1
82114: NEG
82115: PUSH
82116: LD_INT 1
82118: NEG
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: PUSH
82124: LD_INT 1
82126: NEG
82127: PUSH
82128: LD_INT 2
82130: NEG
82131: PUSH
82132: EMPTY
82133: LIST
82134: LIST
82135: PUSH
82136: LD_INT 0
82138: PUSH
82139: LD_INT 2
82141: NEG
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 1
82149: PUSH
82150: LD_INT 1
82152: NEG
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 2
82160: PUSH
82161: LD_INT 0
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 2
82170: PUSH
82171: LD_INT 1
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 2
82180: PUSH
82181: LD_INT 2
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 1
82190: PUSH
82191: LD_INT 2
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 0
82200: PUSH
82201: LD_INT 2
82203: PUSH
82204: EMPTY
82205: LIST
82206: LIST
82207: PUSH
82208: LD_INT 1
82210: NEG
82211: PUSH
82212: LD_INT 1
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 2
82221: NEG
82222: PUSH
82223: LD_INT 0
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 2
82232: NEG
82233: PUSH
82234: LD_INT 1
82236: NEG
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 2
82244: NEG
82245: PUSH
82246: LD_INT 2
82248: NEG
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82275: LD_ADDR_VAR 0 57
82279: PUSH
82280: LD_INT 0
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 0
82292: PUSH
82293: LD_INT 1
82295: NEG
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: LD_INT 0
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: LD_INT 1
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 1
82333: NEG
82334: PUSH
82335: LD_INT 0
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 1
82344: NEG
82345: PUSH
82346: LD_INT 1
82348: NEG
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 1
82356: NEG
82357: PUSH
82358: LD_INT 2
82360: NEG
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: LD_INT 0
82368: PUSH
82369: LD_INT 2
82371: NEG
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 1
82379: PUSH
82380: LD_INT 1
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 2
82390: PUSH
82391: LD_INT 0
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 2
82400: PUSH
82401: LD_INT 1
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 2
82410: PUSH
82411: LD_INT 2
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 1
82420: PUSH
82421: LD_INT 2
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 0
82430: PUSH
82431: LD_INT 2
82433: PUSH
82434: EMPTY
82435: LIST
82436: LIST
82437: PUSH
82438: LD_INT 1
82440: NEG
82441: PUSH
82442: LD_INT 1
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 2
82451: NEG
82452: PUSH
82453: LD_INT 0
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: PUSH
82460: LD_INT 2
82462: NEG
82463: PUSH
82464: LD_INT 1
82466: NEG
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 2
82474: NEG
82475: PUSH
82476: LD_INT 2
82478: NEG
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82505: LD_ADDR_VAR 0 58
82509: PUSH
82510: LD_INT 0
82512: PUSH
82513: LD_INT 0
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 0
82522: PUSH
82523: LD_INT 1
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 1
82533: PUSH
82534: LD_INT 0
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: LD_INT 1
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 0
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 1
82563: NEG
82564: PUSH
82565: LD_INT 0
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 1
82574: NEG
82575: PUSH
82576: LD_INT 1
82578: NEG
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: PUSH
82584: LD_INT 1
82586: NEG
82587: PUSH
82588: LD_INT 2
82590: NEG
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 0
82598: PUSH
82599: LD_INT 2
82601: NEG
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: PUSH
82610: LD_INT 1
82612: NEG
82613: PUSH
82614: EMPTY
82615: LIST
82616: LIST
82617: PUSH
82618: LD_INT 2
82620: PUSH
82621: LD_INT 0
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 2
82630: PUSH
82631: LD_INT 1
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 2
82640: PUSH
82641: LD_INT 2
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 1
82650: PUSH
82651: LD_INT 2
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 0
82660: PUSH
82661: LD_INT 2
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 1
82670: NEG
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 2
82681: NEG
82682: PUSH
82683: LD_INT 0
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 2
82692: NEG
82693: PUSH
82694: LD_INT 1
82696: NEG
82697: PUSH
82698: EMPTY
82699: LIST
82700: LIST
82701: PUSH
82702: LD_INT 2
82704: NEG
82705: PUSH
82706: LD_INT 2
82708: NEG
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82735: LD_ADDR_VAR 0 59
82739: PUSH
82740: LD_INT 0
82742: PUSH
82743: LD_INT 0
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 0
82752: PUSH
82753: LD_INT 1
82755: NEG
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 1
82763: PUSH
82764: LD_INT 0
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: LD_INT 1
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 0
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 1
82793: NEG
82794: PUSH
82795: LD_INT 0
82797: PUSH
82798: EMPTY
82799: LIST
82800: LIST
82801: PUSH
82802: LD_INT 1
82804: NEG
82805: PUSH
82806: LD_INT 1
82808: NEG
82809: PUSH
82810: EMPTY
82811: LIST
82812: LIST
82813: PUSH
82814: EMPTY
82815: LIST
82816: LIST
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82823: LD_ADDR_VAR 0 60
82827: PUSH
82828: LD_INT 0
82830: PUSH
82831: LD_INT 0
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 0
82840: PUSH
82841: LD_INT 1
82843: NEG
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 1
82851: PUSH
82852: LD_INT 0
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 1
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 0
82871: PUSH
82872: LD_INT 1
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: NEG
82882: PUSH
82883: LD_INT 0
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 1
82892: NEG
82893: PUSH
82894: LD_INT 1
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82911: LD_ADDR_VAR 0 61
82915: PUSH
82916: LD_INT 0
82918: PUSH
82919: LD_INT 0
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 0
82928: PUSH
82929: LD_INT 1
82931: NEG
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: LD_INT 0
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: LD_INT 1
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 0
82959: PUSH
82960: LD_INT 1
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 0
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: NEG
82981: PUSH
82982: LD_INT 1
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
82999: LD_ADDR_VAR 0 62
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: LD_INT 0
83009: PUSH
83010: EMPTY
83011: LIST
83012: LIST
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 1
83019: NEG
83020: PUSH
83021: EMPTY
83022: LIST
83023: LIST
83024: PUSH
83025: LD_INT 1
83027: PUSH
83028: LD_INT 0
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: LD_INT 1
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: NEG
83058: PUSH
83059: LD_INT 0
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 1
83068: NEG
83069: PUSH
83070: LD_INT 1
83072: NEG
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
83087: LD_ADDR_VAR 0 63
83091: PUSH
83092: LD_INT 0
83094: PUSH
83095: LD_INT 0
83097: PUSH
83098: EMPTY
83099: LIST
83100: LIST
83101: PUSH
83102: LD_INT 0
83104: PUSH
83105: LD_INT 1
83107: NEG
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 1
83115: PUSH
83116: LD_INT 0
83118: PUSH
83119: EMPTY
83120: LIST
83121: LIST
83122: PUSH
83123: LD_INT 1
83125: PUSH
83126: LD_INT 1
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 1
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 1
83145: NEG
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 1
83156: NEG
83157: PUSH
83158: LD_INT 1
83160: NEG
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: EMPTY
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
83175: LD_ADDR_VAR 0 64
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: EMPTY
83187: LIST
83188: LIST
83189: PUSH
83190: LD_INT 0
83192: PUSH
83193: LD_INT 1
83195: NEG
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 1
83203: PUSH
83204: LD_INT 0
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 1
83213: PUSH
83214: LD_INT 1
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PUSH
83221: LD_INT 0
83223: PUSH
83224: LD_INT 1
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 1
83233: NEG
83234: PUSH
83235: LD_INT 0
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 1
83244: NEG
83245: PUSH
83246: LD_INT 1
83248: NEG
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: ST_TO_ADDR
// end ; 1 :
83263: GO 89160
83265: LD_INT 1
83267: DOUBLE
83268: EQUAL
83269: IFTRUE 83273
83271: GO 85896
83273: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
83274: LD_ADDR_VAR 0 11
83278: PUSH
83279: LD_INT 1
83281: NEG
83282: PUSH
83283: LD_INT 3
83285: NEG
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 0
83293: PUSH
83294: LD_INT 3
83296: NEG
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 1
83304: PUSH
83305: LD_INT 2
83307: NEG
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: LIST
83317: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83318: LD_ADDR_VAR 0 12
83322: PUSH
83323: LD_INT 2
83325: PUSH
83326: LD_INT 1
83328: NEG
83329: PUSH
83330: EMPTY
83331: LIST
83332: LIST
83333: PUSH
83334: LD_INT 3
83336: PUSH
83337: LD_INT 0
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PUSH
83344: LD_INT 3
83346: PUSH
83347: LD_INT 1
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: LIST
83358: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83359: LD_ADDR_VAR 0 13
83363: PUSH
83364: LD_INT 3
83366: PUSH
83367: LD_INT 2
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 3
83376: PUSH
83377: LD_INT 3
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 2
83386: PUSH
83387: LD_INT 3
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: LIST
83398: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83399: LD_ADDR_VAR 0 14
83403: PUSH
83404: LD_INT 1
83406: PUSH
83407: LD_INT 3
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 0
83416: PUSH
83417: LD_INT 3
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 1
83426: NEG
83427: PUSH
83428: LD_INT 2
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: LIST
83439: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83440: LD_ADDR_VAR 0 15
83444: PUSH
83445: LD_INT 2
83447: NEG
83448: PUSH
83449: LD_INT 1
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 3
83458: NEG
83459: PUSH
83460: LD_INT 0
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 3
83469: NEG
83470: PUSH
83471: LD_INT 1
83473: NEG
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: EMPTY
83480: LIST
83481: LIST
83482: LIST
83483: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83484: LD_ADDR_VAR 0 16
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: LD_INT 3
83495: NEG
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 3
83503: NEG
83504: PUSH
83505: LD_INT 2
83507: NEG
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 3
83515: NEG
83516: PUSH
83517: LD_INT 3
83519: NEG
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: LIST
83529: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
83530: LD_ADDR_VAR 0 17
83534: PUSH
83535: LD_INT 1
83537: NEG
83538: PUSH
83539: LD_INT 3
83541: NEG
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: PUSH
83547: LD_INT 0
83549: PUSH
83550: LD_INT 3
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 1
83560: PUSH
83561: LD_INT 2
83563: NEG
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: LIST
83573: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83574: LD_ADDR_VAR 0 18
83578: PUSH
83579: LD_INT 2
83581: PUSH
83582: LD_INT 1
83584: NEG
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 3
83592: PUSH
83593: LD_INT 0
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 3
83602: PUSH
83603: LD_INT 1
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: LIST
83614: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
83615: LD_ADDR_VAR 0 19
83619: PUSH
83620: LD_INT 3
83622: PUSH
83623: LD_INT 2
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 3
83632: PUSH
83633: LD_INT 3
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 2
83642: PUSH
83643: LD_INT 3
83645: PUSH
83646: EMPTY
83647: LIST
83648: LIST
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: LIST
83654: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83655: LD_ADDR_VAR 0 20
83659: PUSH
83660: LD_INT 1
83662: PUSH
83663: LD_INT 3
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 0
83672: PUSH
83673: LD_INT 3
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 1
83682: NEG
83683: PUSH
83684: LD_INT 2
83686: PUSH
83687: EMPTY
83688: LIST
83689: LIST
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: LIST
83695: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83696: LD_ADDR_VAR 0 21
83700: PUSH
83701: LD_INT 2
83703: NEG
83704: PUSH
83705: LD_INT 1
83707: PUSH
83708: EMPTY
83709: LIST
83710: LIST
83711: PUSH
83712: LD_INT 3
83714: NEG
83715: PUSH
83716: LD_INT 0
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: PUSH
83723: LD_INT 3
83725: NEG
83726: PUSH
83727: LD_INT 1
83729: NEG
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: LIST
83739: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83740: LD_ADDR_VAR 0 22
83744: PUSH
83745: LD_INT 2
83747: NEG
83748: PUSH
83749: LD_INT 3
83751: NEG
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: PUSH
83757: LD_INT 3
83759: NEG
83760: PUSH
83761: LD_INT 2
83763: NEG
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: PUSH
83769: LD_INT 3
83771: NEG
83772: PUSH
83773: LD_INT 3
83775: NEG
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: LIST
83785: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
83786: LD_ADDR_VAR 0 23
83790: PUSH
83791: LD_INT 0
83793: PUSH
83794: LD_INT 3
83796: NEG
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 1
83804: NEG
83805: PUSH
83806: LD_INT 4
83808: NEG
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: PUSH
83817: LD_INT 3
83819: NEG
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: LIST
83829: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
83830: LD_ADDR_VAR 0 24
83834: PUSH
83835: LD_INT 3
83837: PUSH
83838: LD_INT 0
83840: PUSH
83841: EMPTY
83842: LIST
83843: LIST
83844: PUSH
83845: LD_INT 3
83847: PUSH
83848: LD_INT 1
83850: NEG
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 4
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: LIST
83870: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
83871: LD_ADDR_VAR 0 25
83875: PUSH
83876: LD_INT 3
83878: PUSH
83879: LD_INT 3
83881: PUSH
83882: EMPTY
83883: LIST
83884: LIST
83885: PUSH
83886: LD_INT 4
83888: PUSH
83889: LD_INT 3
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PUSH
83896: LD_INT 3
83898: PUSH
83899: LD_INT 4
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: LIST
83910: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
83911: LD_ADDR_VAR 0 26
83915: PUSH
83916: LD_INT 0
83918: PUSH
83919: LD_INT 3
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: PUSH
83926: LD_INT 1
83928: PUSH
83929: LD_INT 4
83931: PUSH
83932: EMPTY
83933: LIST
83934: LIST
83935: PUSH
83936: LD_INT 1
83938: NEG
83939: PUSH
83940: LD_INT 3
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: LIST
83951: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
83952: LD_ADDR_VAR 0 27
83956: PUSH
83957: LD_INT 3
83959: NEG
83960: PUSH
83961: LD_INT 0
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 3
83970: NEG
83971: PUSH
83972: LD_INT 1
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PUSH
83979: LD_INT 4
83981: NEG
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: LIST
83995: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
83996: LD_ADDR_VAR 0 28
84000: PUSH
84001: LD_INT 3
84003: NEG
84004: PUSH
84005: LD_INT 3
84007: NEG
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PUSH
84013: LD_INT 3
84015: NEG
84016: PUSH
84017: LD_INT 4
84019: NEG
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 4
84027: NEG
84028: PUSH
84029: LD_INT 3
84031: NEG
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: LIST
84041: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
84042: LD_ADDR_VAR 0 29
84046: PUSH
84047: LD_INT 1
84049: NEG
84050: PUSH
84051: LD_INT 3
84053: NEG
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: LD_INT 0
84061: PUSH
84062: LD_INT 3
84064: NEG
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: LD_INT 2
84075: NEG
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 1
84083: NEG
84084: PUSH
84085: LD_INT 4
84087: NEG
84088: PUSH
84089: EMPTY
84090: LIST
84091: LIST
84092: PUSH
84093: LD_INT 0
84095: PUSH
84096: LD_INT 4
84098: NEG
84099: PUSH
84100: EMPTY
84101: LIST
84102: LIST
84103: PUSH
84104: LD_INT 1
84106: PUSH
84107: LD_INT 3
84109: NEG
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 1
84117: NEG
84118: PUSH
84119: LD_INT 5
84121: NEG
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 0
84129: PUSH
84130: LD_INT 5
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 1
84140: PUSH
84141: LD_INT 4
84143: NEG
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 1
84151: NEG
84152: PUSH
84153: LD_INT 6
84155: NEG
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: PUSH
84161: LD_INT 0
84163: PUSH
84164: LD_INT 6
84166: NEG
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: LD_INT 1
84174: PUSH
84175: LD_INT 5
84177: NEG
84178: PUSH
84179: EMPTY
84180: LIST
84181: LIST
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: LIST
84187: LIST
84188: LIST
84189: LIST
84190: LIST
84191: LIST
84192: LIST
84193: LIST
84194: LIST
84195: LIST
84196: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
84197: LD_ADDR_VAR 0 30
84201: PUSH
84202: LD_INT 2
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 3
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 3
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 3
84235: PUSH
84236: LD_INT 1
84238: NEG
84239: PUSH
84240: EMPTY
84241: LIST
84242: LIST
84243: PUSH
84244: LD_INT 4
84246: PUSH
84247: LD_INT 0
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 4
84256: PUSH
84257: LD_INT 1
84259: PUSH
84260: EMPTY
84261: LIST
84262: LIST
84263: PUSH
84264: LD_INT 4
84266: PUSH
84267: LD_INT 1
84269: NEG
84270: PUSH
84271: EMPTY
84272: LIST
84273: LIST
84274: PUSH
84275: LD_INT 5
84277: PUSH
84278: LD_INT 0
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 5
84287: PUSH
84288: LD_INT 1
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 5
84297: PUSH
84298: LD_INT 1
84300: NEG
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 6
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: EMPTY
84313: LIST
84314: LIST
84315: PUSH
84316: LD_INT 6
84318: PUSH
84319: LD_INT 1
84321: PUSH
84322: EMPTY
84323: LIST
84324: LIST
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: LIST
84336: LIST
84337: LIST
84338: LIST
84339: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
84340: LD_ADDR_VAR 0 31
84344: PUSH
84345: LD_INT 3
84347: PUSH
84348: LD_INT 2
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: PUSH
84355: LD_INT 3
84357: PUSH
84358: LD_INT 3
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: PUSH
84365: LD_INT 2
84367: PUSH
84368: LD_INT 3
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 4
84377: PUSH
84378: LD_INT 3
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PUSH
84385: LD_INT 4
84387: PUSH
84388: LD_INT 4
84390: PUSH
84391: EMPTY
84392: LIST
84393: LIST
84394: PUSH
84395: LD_INT 3
84397: PUSH
84398: LD_INT 4
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PUSH
84405: LD_INT 5
84407: PUSH
84408: LD_INT 4
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 5
84417: PUSH
84418: LD_INT 5
84420: PUSH
84421: EMPTY
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 4
84427: PUSH
84428: LD_INT 5
84430: PUSH
84431: EMPTY
84432: LIST
84433: LIST
84434: PUSH
84435: LD_INT 6
84437: PUSH
84438: LD_INT 5
84440: PUSH
84441: EMPTY
84442: LIST
84443: LIST
84444: PUSH
84445: LD_INT 6
84447: PUSH
84448: LD_INT 6
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 5
84457: PUSH
84458: LD_INT 6
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: LIST
84475: LIST
84476: LIST
84477: LIST
84478: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
84479: LD_ADDR_VAR 0 32
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: LD_INT 3
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: LD_INT 3
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: LD_INT 2
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 4
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 4
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: NEG
84538: PUSH
84539: LD_INT 3
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 1
84548: PUSH
84549: LD_INT 5
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 0
84558: PUSH
84559: LD_INT 5
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: LD_INT 4
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 1
84579: PUSH
84580: LD_INT 6
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 0
84589: PUSH
84590: LD_INT 6
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: PUSH
84597: LD_INT 1
84599: NEG
84600: PUSH
84601: LD_INT 5
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: LIST
84613: LIST
84614: LIST
84615: LIST
84616: LIST
84617: LIST
84618: LIST
84619: LIST
84620: LIST
84621: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
84622: LD_ADDR_VAR 0 33
84626: PUSH
84627: LD_INT 2
84629: NEG
84630: PUSH
84631: LD_INT 1
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 3
84640: NEG
84641: PUSH
84642: LD_INT 0
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 3
84651: NEG
84652: PUSH
84653: LD_INT 1
84655: NEG
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 3
84663: NEG
84664: PUSH
84665: LD_INT 1
84667: PUSH
84668: EMPTY
84669: LIST
84670: LIST
84671: PUSH
84672: LD_INT 4
84674: NEG
84675: PUSH
84676: LD_INT 0
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 4
84685: NEG
84686: PUSH
84687: LD_INT 1
84689: NEG
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: PUSH
84695: LD_INT 4
84697: NEG
84698: PUSH
84699: LD_INT 1
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: PUSH
84706: LD_INT 5
84708: NEG
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 5
84719: NEG
84720: PUSH
84721: LD_INT 1
84723: NEG
84724: PUSH
84725: EMPTY
84726: LIST
84727: LIST
84728: PUSH
84729: LD_INT 5
84731: NEG
84732: PUSH
84733: LD_INT 1
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 6
84742: NEG
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 6
84753: NEG
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
84777: LD_ADDR_VAR 0 34
84781: PUSH
84782: LD_INT 2
84784: NEG
84785: PUSH
84786: LD_INT 3
84788: NEG
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 3
84796: NEG
84797: PUSH
84798: LD_INT 2
84800: NEG
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 3
84808: NEG
84809: PUSH
84810: LD_INT 3
84812: NEG
84813: PUSH
84814: EMPTY
84815: LIST
84816: LIST
84817: PUSH
84818: LD_INT 3
84820: NEG
84821: PUSH
84822: LD_INT 4
84824: NEG
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PUSH
84830: LD_INT 4
84832: NEG
84833: PUSH
84834: LD_INT 3
84836: NEG
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 4
84844: NEG
84845: PUSH
84846: LD_INT 4
84848: NEG
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 4
84856: NEG
84857: PUSH
84858: LD_INT 5
84860: NEG
84861: PUSH
84862: EMPTY
84863: LIST
84864: LIST
84865: PUSH
84866: LD_INT 5
84868: NEG
84869: PUSH
84870: LD_INT 4
84872: NEG
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 5
84880: NEG
84881: PUSH
84882: LD_INT 5
84884: NEG
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: PUSH
84890: LD_INT 5
84892: NEG
84893: PUSH
84894: LD_INT 6
84896: NEG
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 6
84904: NEG
84905: PUSH
84906: LD_INT 5
84908: NEG
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 6
84916: NEG
84917: PUSH
84918: LD_INT 6
84920: NEG
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
84940: LD_ADDR_VAR 0 41
84944: PUSH
84945: LD_INT 0
84947: PUSH
84948: LD_INT 2
84950: NEG
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: LD_INT 1
84958: NEG
84959: PUSH
84960: LD_INT 3
84962: NEG
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PUSH
84968: LD_INT 1
84970: PUSH
84971: LD_INT 2
84973: NEG
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: LIST
84983: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
84984: LD_ADDR_VAR 0 42
84988: PUSH
84989: LD_INT 2
84991: PUSH
84992: LD_INT 0
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 2
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 3
85012: PUSH
85013: LD_INT 1
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: LIST
85024: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
85025: LD_ADDR_VAR 0 43
85029: PUSH
85030: LD_INT 2
85032: PUSH
85033: LD_INT 2
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 3
85042: PUSH
85043: LD_INT 2
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 2
85052: PUSH
85053: LD_INT 3
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: LIST
85064: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
85065: LD_ADDR_VAR 0 44
85069: PUSH
85070: LD_INT 0
85072: PUSH
85073: LD_INT 2
85075: PUSH
85076: EMPTY
85077: LIST
85078: LIST
85079: PUSH
85080: LD_INT 1
85082: PUSH
85083: LD_INT 3
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 1
85092: NEG
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: LIST
85105: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85106: LD_ADDR_VAR 0 45
85110: PUSH
85111: LD_INT 2
85113: NEG
85114: PUSH
85115: LD_INT 0
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 2
85124: NEG
85125: PUSH
85126: LD_INT 1
85128: PUSH
85129: EMPTY
85130: LIST
85131: LIST
85132: PUSH
85133: LD_INT 3
85135: NEG
85136: PUSH
85137: LD_INT 1
85139: NEG
85140: PUSH
85141: EMPTY
85142: LIST
85143: LIST
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: LIST
85149: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
85150: LD_ADDR_VAR 0 46
85154: PUSH
85155: LD_INT 2
85157: NEG
85158: PUSH
85159: LD_INT 2
85161: NEG
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: PUSH
85167: LD_INT 2
85169: NEG
85170: PUSH
85171: LD_INT 3
85173: NEG
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_INT 3
85181: NEG
85182: PUSH
85183: LD_INT 2
85185: NEG
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: LIST
85195: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
85196: LD_ADDR_VAR 0 47
85200: PUSH
85201: LD_INT 2
85203: NEG
85204: PUSH
85205: LD_INT 3
85207: NEG
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: LD_INT 3
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: EMPTY
85226: LIST
85227: LIST
85228: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
85229: LD_ADDR_VAR 0 48
85233: PUSH
85234: LD_INT 1
85236: PUSH
85237: LD_INT 2
85239: NEG
85240: PUSH
85241: EMPTY
85242: LIST
85243: LIST
85244: PUSH
85245: LD_INT 2
85247: PUSH
85248: LD_INT 1
85250: NEG
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
85260: LD_ADDR_VAR 0 49
85264: PUSH
85265: LD_INT 3
85267: PUSH
85268: LD_INT 1
85270: PUSH
85271: EMPTY
85272: LIST
85273: LIST
85274: PUSH
85275: LD_INT 3
85277: PUSH
85278: LD_INT 2
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
85289: LD_ADDR_VAR 0 50
85293: PUSH
85294: LD_INT 2
85296: PUSH
85297: LD_INT 3
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 1
85306: PUSH
85307: LD_INT 3
85309: PUSH
85310: EMPTY
85311: LIST
85312: LIST
85313: PUSH
85314: EMPTY
85315: LIST
85316: LIST
85317: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
85318: LD_ADDR_VAR 0 51
85322: PUSH
85323: LD_INT 1
85325: NEG
85326: PUSH
85327: LD_INT 2
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: LD_INT 1
85340: PUSH
85341: EMPTY
85342: LIST
85343: LIST
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85349: LD_ADDR_VAR 0 52
85353: PUSH
85354: LD_INT 3
85356: NEG
85357: PUSH
85358: LD_INT 1
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 3
85368: NEG
85369: PUSH
85370: LD_INT 2
85372: NEG
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: EMPTY
85379: LIST
85380: LIST
85381: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
85382: LD_ADDR_VAR 0 53
85386: PUSH
85387: LD_INT 1
85389: NEG
85390: PUSH
85391: LD_INT 3
85393: NEG
85394: PUSH
85395: EMPTY
85396: LIST
85397: LIST
85398: PUSH
85399: LD_INT 0
85401: PUSH
85402: LD_INT 3
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 1
85412: PUSH
85413: LD_INT 2
85415: NEG
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: LIST
85425: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
85426: LD_ADDR_VAR 0 54
85430: PUSH
85431: LD_INT 2
85433: PUSH
85434: LD_INT 1
85436: NEG
85437: PUSH
85438: EMPTY
85439: LIST
85440: LIST
85441: PUSH
85442: LD_INT 3
85444: PUSH
85445: LD_INT 0
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PUSH
85452: LD_INT 3
85454: PUSH
85455: LD_INT 1
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: LIST
85466: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
85467: LD_ADDR_VAR 0 55
85471: PUSH
85472: LD_INT 3
85474: PUSH
85475: LD_INT 2
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 3
85484: PUSH
85485: LD_INT 3
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 2
85494: PUSH
85495: LD_INT 3
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: LIST
85506: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85507: LD_ADDR_VAR 0 56
85511: PUSH
85512: LD_INT 1
85514: PUSH
85515: LD_INT 3
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PUSH
85522: LD_INT 0
85524: PUSH
85525: LD_INT 3
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 1
85534: NEG
85535: PUSH
85536: LD_INT 2
85538: PUSH
85539: EMPTY
85540: LIST
85541: LIST
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: LIST
85547: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85548: LD_ADDR_VAR 0 57
85552: PUSH
85553: LD_INT 2
85555: NEG
85556: PUSH
85557: LD_INT 1
85559: PUSH
85560: EMPTY
85561: LIST
85562: LIST
85563: PUSH
85564: LD_INT 3
85566: NEG
85567: PUSH
85568: LD_INT 0
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 3
85577: NEG
85578: PUSH
85579: LD_INT 1
85581: NEG
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: LIST
85591: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85592: LD_ADDR_VAR 0 58
85596: PUSH
85597: LD_INT 2
85599: NEG
85600: PUSH
85601: LD_INT 3
85603: NEG
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 3
85611: NEG
85612: PUSH
85613: LD_INT 2
85615: NEG
85616: PUSH
85617: EMPTY
85618: LIST
85619: LIST
85620: PUSH
85621: LD_INT 3
85623: NEG
85624: PUSH
85625: LD_INT 3
85627: NEG
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: LIST
85637: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
85638: LD_ADDR_VAR 0 59
85642: PUSH
85643: LD_INT 1
85645: NEG
85646: PUSH
85647: LD_INT 2
85649: NEG
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: LD_INT 0
85657: PUSH
85658: LD_INT 2
85660: NEG
85661: PUSH
85662: EMPTY
85663: LIST
85664: LIST
85665: PUSH
85666: LD_INT 1
85668: PUSH
85669: LD_INT 1
85671: NEG
85672: PUSH
85673: EMPTY
85674: LIST
85675: LIST
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: LIST
85681: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
85682: LD_ADDR_VAR 0 60
85686: PUSH
85687: LD_INT 1
85689: PUSH
85690: LD_INT 1
85692: NEG
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 2
85700: PUSH
85701: LD_INT 0
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 2
85710: PUSH
85711: LD_INT 1
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: LIST
85722: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
85723: LD_ADDR_VAR 0 61
85727: PUSH
85728: LD_INT 2
85730: PUSH
85731: LD_INT 1
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 2
85740: PUSH
85741: LD_INT 2
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 1
85750: PUSH
85751: LD_INT 2
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: LIST
85762: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
85763: LD_ADDR_VAR 0 62
85767: PUSH
85768: LD_INT 1
85770: PUSH
85771: LD_INT 2
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 0
85780: PUSH
85781: LD_INT 2
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 1
85790: NEG
85791: PUSH
85792: LD_INT 1
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: LIST
85803: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
85804: LD_ADDR_VAR 0 63
85808: PUSH
85809: LD_INT 1
85811: NEG
85812: PUSH
85813: LD_INT 1
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 2
85822: NEG
85823: PUSH
85824: LD_INT 0
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 2
85833: NEG
85834: PUSH
85835: LD_INT 1
85837: NEG
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: LIST
85847: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85848: LD_ADDR_VAR 0 64
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: LD_INT 2
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 2
85867: NEG
85868: PUSH
85869: LD_INT 1
85871: NEG
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 2
85879: NEG
85880: PUSH
85881: LD_INT 2
85883: NEG
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: LIST
85893: ST_TO_ADDR
// end ; 2 :
85894: GO 89160
85896: LD_INT 2
85898: DOUBLE
85899: EQUAL
85900: IFTRUE 85904
85902: GO 89159
85904: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
85905: LD_ADDR_VAR 0 29
85909: PUSH
85910: LD_INT 4
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 4
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 5
85933: PUSH
85934: LD_INT 0
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 5
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 4
85953: PUSH
85954: LD_INT 1
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 3
85963: PUSH
85964: LD_INT 0
85966: PUSH
85967: EMPTY
85968: LIST
85969: LIST
85970: PUSH
85971: LD_INT 3
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 3
85984: PUSH
85985: LD_INT 2
85987: NEG
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 5
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 3
86005: PUSH
86006: LD_INT 3
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 3
86015: PUSH
86016: LD_INT 2
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 4
86025: PUSH
86026: LD_INT 3
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 4
86035: PUSH
86036: LD_INT 4
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 3
86045: PUSH
86046: LD_INT 4
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 2
86055: PUSH
86056: LD_INT 3
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 2
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 4
86075: PUSH
86076: LD_INT 2
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 2
86085: PUSH
86086: LD_INT 4
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: LD_INT 4
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 0
86105: PUSH
86106: LD_INT 3
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: LD_INT 4
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 1
86125: PUSH
86126: LD_INT 5
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 0
86135: PUSH
86136: LD_INT 5
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 1
86145: NEG
86146: PUSH
86147: LD_INT 4
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 1
86156: NEG
86157: PUSH
86158: LD_INT 3
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 2
86167: PUSH
86168: LD_INT 5
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 2
86177: NEG
86178: PUSH
86179: LD_INT 3
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 3
86188: NEG
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 3
86199: NEG
86200: PUSH
86201: LD_INT 1
86203: NEG
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 2
86211: NEG
86212: PUSH
86213: LD_INT 0
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: PUSH
86220: LD_INT 2
86222: NEG
86223: PUSH
86224: LD_INT 1
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 3
86233: NEG
86234: PUSH
86235: LD_INT 1
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 4
86244: NEG
86245: PUSH
86246: LD_INT 0
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 4
86255: NEG
86256: PUSH
86257: LD_INT 1
86259: NEG
86260: PUSH
86261: EMPTY
86262: LIST
86263: LIST
86264: PUSH
86265: LD_INT 4
86267: NEG
86268: PUSH
86269: LD_INT 2
86271: NEG
86272: PUSH
86273: EMPTY
86274: LIST
86275: LIST
86276: PUSH
86277: LD_INT 2
86279: NEG
86280: PUSH
86281: LD_INT 2
86283: PUSH
86284: EMPTY
86285: LIST
86286: LIST
86287: PUSH
86288: LD_INT 4
86290: NEG
86291: PUSH
86292: LD_INT 4
86294: NEG
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PUSH
86300: LD_INT 4
86302: NEG
86303: PUSH
86304: LD_INT 5
86306: NEG
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 3
86314: NEG
86315: PUSH
86316: LD_INT 4
86318: NEG
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 3
86326: NEG
86327: PUSH
86328: LD_INT 3
86330: NEG
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 4
86338: NEG
86339: PUSH
86340: LD_INT 3
86342: NEG
86343: PUSH
86344: EMPTY
86345: LIST
86346: LIST
86347: PUSH
86348: LD_INT 5
86350: NEG
86351: PUSH
86352: LD_INT 4
86354: NEG
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 5
86362: NEG
86363: PUSH
86364: LD_INT 5
86366: NEG
86367: PUSH
86368: EMPTY
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 3
86374: NEG
86375: PUSH
86376: LD_INT 5
86378: NEG
86379: PUSH
86380: EMPTY
86381: LIST
86382: LIST
86383: PUSH
86384: LD_INT 5
86386: NEG
86387: PUSH
86388: LD_INT 3
86390: NEG
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: EMPTY
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: LIST
86430: LIST
86431: LIST
86432: LIST
86433: LIST
86434: LIST
86435: LIST
86436: LIST
86437: LIST
86438: LIST
86439: LIST
86440: LIST
86441: LIST
86442: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
86443: LD_ADDR_VAR 0 30
86447: PUSH
86448: LD_INT 4
86450: PUSH
86451: LD_INT 4
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 4
86460: PUSH
86461: LD_INT 3
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 5
86470: PUSH
86471: LD_INT 4
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 5
86480: PUSH
86481: LD_INT 5
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 4
86490: PUSH
86491: LD_INT 5
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 3
86500: PUSH
86501: LD_INT 4
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 3
86510: PUSH
86511: LD_INT 3
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 5
86520: PUSH
86521: LD_INT 3
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 3
86530: PUSH
86531: LD_INT 5
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PUSH
86538: LD_INT 0
86540: PUSH
86541: LD_INT 3
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 2
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: PUSH
86561: LD_INT 3
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: LD_INT 4
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: LD_INT 4
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 1
86590: NEG
86591: PUSH
86592: LD_INT 3
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: LD_INT 2
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 2
86612: PUSH
86613: LD_INT 4
86615: PUSH
86616: EMPTY
86617: LIST
86618: LIST
86619: PUSH
86620: LD_INT 2
86622: NEG
86623: PUSH
86624: LD_INT 2
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 4
86633: NEG
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 4
86644: NEG
86645: PUSH
86646: LD_INT 1
86648: NEG
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: PUSH
86654: LD_INT 3
86656: NEG
86657: PUSH
86658: LD_INT 0
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: LD_INT 3
86667: NEG
86668: PUSH
86669: LD_INT 1
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: PUSH
86676: LD_INT 4
86678: NEG
86679: PUSH
86680: LD_INT 1
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 5
86689: NEG
86690: PUSH
86691: LD_INT 0
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 5
86700: NEG
86701: PUSH
86702: LD_INT 1
86704: NEG
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 5
86712: NEG
86713: PUSH
86714: LD_INT 2
86716: NEG
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 3
86724: NEG
86725: PUSH
86726: LD_INT 2
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 3
86735: NEG
86736: PUSH
86737: LD_INT 3
86739: NEG
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 3
86747: NEG
86748: PUSH
86749: LD_INT 4
86751: NEG
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 2
86759: NEG
86760: PUSH
86761: LD_INT 3
86763: NEG
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 2
86771: NEG
86772: PUSH
86773: LD_INT 2
86775: NEG
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 3
86783: NEG
86784: PUSH
86785: LD_INT 2
86787: NEG
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 4
86795: NEG
86796: PUSH
86797: LD_INT 3
86799: NEG
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 4
86807: NEG
86808: PUSH
86809: LD_INT 4
86811: NEG
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 2
86819: NEG
86820: PUSH
86821: LD_INT 4
86823: NEG
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 4
86831: NEG
86832: PUSH
86833: LD_INT 2
86835: NEG
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 0
86843: PUSH
86844: LD_INT 4
86846: NEG
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 0
86854: PUSH
86855: LD_INT 5
86857: NEG
86858: PUSH
86859: EMPTY
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 1
86865: PUSH
86866: LD_INT 4
86868: NEG
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: PUSH
86874: LD_INT 1
86876: PUSH
86877: LD_INT 3
86879: NEG
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 0
86887: PUSH
86888: LD_INT 3
86890: NEG
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 1
86898: NEG
86899: PUSH
86900: LD_INT 4
86902: NEG
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 1
86910: NEG
86911: PUSH
86912: LD_INT 5
86914: NEG
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 2
86922: PUSH
86923: LD_INT 3
86925: NEG
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 2
86933: NEG
86934: PUSH
86935: LD_INT 5
86937: NEG
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: LIST
86953: LIST
86954: LIST
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
86990: LD_ADDR_VAR 0 31
86994: PUSH
86995: LD_INT 0
86997: PUSH
86998: LD_INT 4
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 0
87007: PUSH
87008: LD_INT 3
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: PUSH
87015: LD_INT 1
87017: PUSH
87018: LD_INT 4
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 1
87027: PUSH
87028: LD_INT 5
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 0
87037: PUSH
87038: LD_INT 5
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 1
87047: NEG
87048: PUSH
87049: LD_INT 4
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: LD_INT 3
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 2
87069: PUSH
87070: LD_INT 5
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 2
87079: NEG
87080: PUSH
87081: LD_INT 3
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 3
87090: NEG
87091: PUSH
87092: LD_INT 0
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 3
87101: NEG
87102: PUSH
87103: LD_INT 1
87105: NEG
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 2
87113: NEG
87114: PUSH
87115: LD_INT 0
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 2
87124: NEG
87125: PUSH
87126: LD_INT 1
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 3
87135: NEG
87136: PUSH
87137: LD_INT 1
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 4
87146: NEG
87147: PUSH
87148: LD_INT 0
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 4
87157: NEG
87158: PUSH
87159: LD_INT 1
87161: NEG
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 4
87169: NEG
87170: PUSH
87171: LD_INT 2
87173: NEG
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PUSH
87179: LD_INT 2
87181: NEG
87182: PUSH
87183: LD_INT 2
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 4
87192: NEG
87193: PUSH
87194: LD_INT 4
87196: NEG
87197: PUSH
87198: EMPTY
87199: LIST
87200: LIST
87201: PUSH
87202: LD_INT 4
87204: NEG
87205: PUSH
87206: LD_INT 5
87208: NEG
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 3
87216: NEG
87217: PUSH
87218: LD_INT 4
87220: NEG
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 3
87228: NEG
87229: PUSH
87230: LD_INT 3
87232: NEG
87233: PUSH
87234: EMPTY
87235: LIST
87236: LIST
87237: PUSH
87238: LD_INT 4
87240: NEG
87241: PUSH
87242: LD_INT 3
87244: NEG
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 5
87252: NEG
87253: PUSH
87254: LD_INT 4
87256: NEG
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 5
87264: NEG
87265: PUSH
87266: LD_INT 5
87268: NEG
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 3
87276: NEG
87277: PUSH
87278: LD_INT 5
87280: NEG
87281: PUSH
87282: EMPTY
87283: LIST
87284: LIST
87285: PUSH
87286: LD_INT 5
87288: NEG
87289: PUSH
87290: LD_INT 3
87292: NEG
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 0
87300: PUSH
87301: LD_INT 3
87303: NEG
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: LD_INT 0
87311: PUSH
87312: LD_INT 4
87314: NEG
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: LD_INT 3
87325: NEG
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 1
87333: PUSH
87334: LD_INT 2
87336: NEG
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: LD_INT 2
87347: NEG
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: LD_INT 1
87355: NEG
87356: PUSH
87357: LD_INT 3
87359: NEG
87360: PUSH
87361: EMPTY
87362: LIST
87363: LIST
87364: PUSH
87365: LD_INT 1
87367: NEG
87368: PUSH
87369: LD_INT 4
87371: NEG
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: PUSH
87377: LD_INT 2
87379: PUSH
87380: LD_INT 2
87382: NEG
87383: PUSH
87384: EMPTY
87385: LIST
87386: LIST
87387: PUSH
87388: LD_INT 2
87390: NEG
87391: PUSH
87392: LD_INT 4
87394: NEG
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PUSH
87400: LD_INT 4
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 4
87412: PUSH
87413: LD_INT 1
87415: NEG
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 5
87423: PUSH
87424: LD_INT 0
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 5
87433: PUSH
87434: LD_INT 1
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 4
87443: PUSH
87444: LD_INT 1
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 3
87453: PUSH
87454: LD_INT 0
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 3
87463: PUSH
87464: LD_INT 1
87466: NEG
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 3
87474: PUSH
87475: LD_INT 2
87477: NEG
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 5
87485: PUSH
87486: LD_INT 2
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
87540: LD_ADDR_VAR 0 32
87544: PUSH
87545: LD_INT 4
87547: NEG
87548: PUSH
87549: LD_INT 0
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: PUSH
87556: LD_INT 4
87558: NEG
87559: PUSH
87560: LD_INT 1
87562: NEG
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 3
87570: NEG
87571: PUSH
87572: LD_INT 0
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 3
87581: NEG
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 4
87592: NEG
87593: PUSH
87594: LD_INT 1
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 5
87603: NEG
87604: PUSH
87605: LD_INT 0
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 5
87614: NEG
87615: PUSH
87616: LD_INT 1
87618: NEG
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: LD_INT 5
87626: NEG
87627: PUSH
87628: LD_INT 2
87630: NEG
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 3
87638: NEG
87639: PUSH
87640: LD_INT 2
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 3
87649: NEG
87650: PUSH
87651: LD_INT 3
87653: NEG
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 3
87661: NEG
87662: PUSH
87663: LD_INT 4
87665: NEG
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 2
87673: NEG
87674: PUSH
87675: LD_INT 3
87677: NEG
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 2
87685: NEG
87686: PUSH
87687: LD_INT 2
87689: NEG
87690: PUSH
87691: EMPTY
87692: LIST
87693: LIST
87694: PUSH
87695: LD_INT 3
87697: NEG
87698: PUSH
87699: LD_INT 2
87701: NEG
87702: PUSH
87703: EMPTY
87704: LIST
87705: LIST
87706: PUSH
87707: LD_INT 4
87709: NEG
87710: PUSH
87711: LD_INT 3
87713: NEG
87714: PUSH
87715: EMPTY
87716: LIST
87717: LIST
87718: PUSH
87719: LD_INT 4
87721: NEG
87722: PUSH
87723: LD_INT 4
87725: NEG
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 2
87733: NEG
87734: PUSH
87735: LD_INT 4
87737: NEG
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: LD_INT 4
87745: NEG
87746: PUSH
87747: LD_INT 2
87749: NEG
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: LD_INT 4
87760: NEG
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: PUSH
87766: LD_INT 0
87768: PUSH
87769: LD_INT 5
87771: NEG
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: LD_INT 1
87779: PUSH
87780: LD_INT 4
87782: NEG
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: PUSH
87788: LD_INT 1
87790: PUSH
87791: LD_INT 3
87793: NEG
87794: PUSH
87795: EMPTY
87796: LIST
87797: LIST
87798: PUSH
87799: LD_INT 0
87801: PUSH
87802: LD_INT 3
87804: NEG
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 1
87812: NEG
87813: PUSH
87814: LD_INT 4
87816: NEG
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 1
87824: NEG
87825: PUSH
87826: LD_INT 5
87828: NEG
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 2
87836: PUSH
87837: LD_INT 3
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 2
87847: NEG
87848: PUSH
87849: LD_INT 5
87851: NEG
87852: PUSH
87853: EMPTY
87854: LIST
87855: LIST
87856: PUSH
87857: LD_INT 3
87859: PUSH
87860: LD_INT 0
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 3
87869: PUSH
87870: LD_INT 1
87872: NEG
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 4
87880: PUSH
87881: LD_INT 0
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 4
87890: PUSH
87891: LD_INT 1
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 3
87900: PUSH
87901: LD_INT 1
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: PUSH
87908: LD_INT 2
87910: PUSH
87911: LD_INT 0
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 2
87920: PUSH
87921: LD_INT 1
87923: NEG
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 2
87931: PUSH
87932: LD_INT 2
87934: NEG
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 4
87942: PUSH
87943: LD_INT 2
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 4
87952: PUSH
87953: LD_INT 4
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: PUSH
87960: LD_INT 4
87962: PUSH
87963: LD_INT 3
87965: PUSH
87966: EMPTY
87967: LIST
87968: LIST
87969: PUSH
87970: LD_INT 5
87972: PUSH
87973: LD_INT 4
87975: PUSH
87976: EMPTY
87977: LIST
87978: LIST
87979: PUSH
87980: LD_INT 5
87982: PUSH
87983: LD_INT 5
87985: PUSH
87986: EMPTY
87987: LIST
87988: LIST
87989: PUSH
87990: LD_INT 4
87992: PUSH
87993: LD_INT 5
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 3
88002: PUSH
88003: LD_INT 4
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 3
88012: PUSH
88013: LD_INT 3
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 5
88022: PUSH
88023: LD_INT 3
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 3
88032: PUSH
88033: LD_INT 5
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
88087: LD_ADDR_VAR 0 33
88091: PUSH
88092: LD_INT 4
88094: NEG
88095: PUSH
88096: LD_INT 4
88098: NEG
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 4
88106: NEG
88107: PUSH
88108: LD_INT 5
88110: NEG
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 3
88118: NEG
88119: PUSH
88120: LD_INT 4
88122: NEG
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 3
88130: NEG
88131: PUSH
88132: LD_INT 3
88134: NEG
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 4
88142: NEG
88143: PUSH
88144: LD_INT 3
88146: NEG
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 5
88154: NEG
88155: PUSH
88156: LD_INT 4
88158: NEG
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 5
88166: NEG
88167: PUSH
88168: LD_INT 5
88170: NEG
88171: PUSH
88172: EMPTY
88173: LIST
88174: LIST
88175: PUSH
88176: LD_INT 3
88178: NEG
88179: PUSH
88180: LD_INT 5
88182: NEG
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 5
88190: NEG
88191: PUSH
88192: LD_INT 3
88194: NEG
88195: PUSH
88196: EMPTY
88197: LIST
88198: LIST
88199: PUSH
88200: LD_INT 0
88202: PUSH
88203: LD_INT 3
88205: NEG
88206: PUSH
88207: EMPTY
88208: LIST
88209: LIST
88210: PUSH
88211: LD_INT 0
88213: PUSH
88214: LD_INT 4
88216: NEG
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: LD_INT 3
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 1
88235: PUSH
88236: LD_INT 2
88238: NEG
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: LD_INT 2
88249: NEG
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 1
88257: NEG
88258: PUSH
88259: LD_INT 3
88261: NEG
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 1
88269: NEG
88270: PUSH
88271: LD_INT 4
88273: NEG
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 2
88281: PUSH
88282: LD_INT 2
88284: NEG
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 2
88292: NEG
88293: PUSH
88294: LD_INT 4
88296: NEG
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 4
88304: PUSH
88305: LD_INT 0
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 4
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 5
88325: PUSH
88326: LD_INT 0
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 5
88335: PUSH
88336: LD_INT 1
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 4
88345: PUSH
88346: LD_INT 1
88348: PUSH
88349: EMPTY
88350: LIST
88351: LIST
88352: PUSH
88353: LD_INT 3
88355: PUSH
88356: LD_INT 0
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 3
88365: PUSH
88366: LD_INT 1
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 3
88376: PUSH
88377: LD_INT 2
88379: NEG
88380: PUSH
88381: EMPTY
88382: LIST
88383: LIST
88384: PUSH
88385: LD_INT 5
88387: PUSH
88388: LD_INT 2
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 3
88397: PUSH
88398: LD_INT 3
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 3
88407: PUSH
88408: LD_INT 2
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 4
88417: PUSH
88418: LD_INT 3
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 4
88427: PUSH
88428: LD_INT 4
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 3
88437: PUSH
88438: LD_INT 4
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: LD_INT 2
88447: PUSH
88448: LD_INT 3
88450: PUSH
88451: EMPTY
88452: LIST
88453: LIST
88454: PUSH
88455: LD_INT 2
88457: PUSH
88458: LD_INT 2
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 4
88467: PUSH
88468: LD_INT 2
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PUSH
88475: LD_INT 2
88477: PUSH
88478: LD_INT 4
88480: PUSH
88481: EMPTY
88482: LIST
88483: LIST
88484: PUSH
88485: LD_INT 0
88487: PUSH
88488: LD_INT 4
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: LD_INT 3
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: LD_INT 4
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 1
88517: PUSH
88518: LD_INT 5
88520: PUSH
88521: EMPTY
88522: LIST
88523: LIST
88524: PUSH
88525: LD_INT 0
88527: PUSH
88528: LD_INT 5
88530: PUSH
88531: EMPTY
88532: LIST
88533: LIST
88534: PUSH
88535: LD_INT 1
88537: NEG
88538: PUSH
88539: LD_INT 4
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 1
88548: NEG
88549: PUSH
88550: LD_INT 3
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 2
88559: PUSH
88560: LD_INT 5
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 2
88569: NEG
88570: PUSH
88571: LD_INT 3
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: PUSH
88578: EMPTY
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
88625: LD_ADDR_VAR 0 34
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: LD_INT 4
88635: NEG
88636: PUSH
88637: EMPTY
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 0
88643: PUSH
88644: LD_INT 5
88646: NEG
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: LD_INT 4
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 1
88665: PUSH
88666: LD_INT 3
88668: NEG
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 0
88676: PUSH
88677: LD_INT 3
88679: NEG
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PUSH
88685: LD_INT 1
88687: NEG
88688: PUSH
88689: LD_INT 4
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 1
88699: NEG
88700: PUSH
88701: LD_INT 5
88703: NEG
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 2
88711: PUSH
88712: LD_INT 3
88714: NEG
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 2
88722: NEG
88723: PUSH
88724: LD_INT 5
88726: NEG
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 3
88734: PUSH
88735: LD_INT 0
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 3
88744: PUSH
88745: LD_INT 1
88747: NEG
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 4
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 4
88765: PUSH
88766: LD_INT 1
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 3
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 2
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 2
88795: PUSH
88796: LD_INT 1
88798: NEG
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 2
88806: PUSH
88807: LD_INT 2
88809: NEG
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 4
88817: PUSH
88818: LD_INT 2
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 4
88827: PUSH
88828: LD_INT 4
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: PUSH
88835: LD_INT 4
88837: PUSH
88838: LD_INT 3
88840: PUSH
88841: EMPTY
88842: LIST
88843: LIST
88844: PUSH
88845: LD_INT 5
88847: PUSH
88848: LD_INT 4
88850: PUSH
88851: EMPTY
88852: LIST
88853: LIST
88854: PUSH
88855: LD_INT 5
88857: PUSH
88858: LD_INT 5
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 4
88867: PUSH
88868: LD_INT 5
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: LD_INT 3
88877: PUSH
88878: LD_INT 4
88880: PUSH
88881: EMPTY
88882: LIST
88883: LIST
88884: PUSH
88885: LD_INT 3
88887: PUSH
88888: LD_INT 3
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: LD_INT 5
88897: PUSH
88898: LD_INT 3
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: LD_INT 3
88907: PUSH
88908: LD_INT 5
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: LD_INT 3
88920: PUSH
88921: EMPTY
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 0
88927: PUSH
88928: LD_INT 2
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 1
88937: PUSH
88938: LD_INT 3
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 1
88947: PUSH
88948: LD_INT 4
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 0
88957: PUSH
88958: LD_INT 4
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: PUSH
88965: LD_INT 1
88967: NEG
88968: PUSH
88969: LD_INT 3
88971: PUSH
88972: EMPTY
88973: LIST
88974: LIST
88975: PUSH
88976: LD_INT 1
88978: NEG
88979: PUSH
88980: LD_INT 2
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: LD_INT 2
88989: PUSH
88990: LD_INT 4
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 2
88999: NEG
89000: PUSH
89001: LD_INT 2
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 4
89010: NEG
89011: PUSH
89012: LD_INT 0
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 4
89021: NEG
89022: PUSH
89023: LD_INT 1
89025: NEG
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 3
89033: NEG
89034: PUSH
89035: LD_INT 0
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 3
89044: NEG
89045: PUSH
89046: LD_INT 1
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 4
89055: NEG
89056: PUSH
89057: LD_INT 1
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 5
89066: NEG
89067: PUSH
89068: LD_INT 0
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 5
89077: NEG
89078: PUSH
89079: LD_INT 1
89081: NEG
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 5
89089: NEG
89090: PUSH
89091: LD_INT 2
89093: NEG
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 3
89101: NEG
89102: PUSH
89103: LD_INT 2
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: PUSH
89110: EMPTY
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: ST_TO_ADDR
// end ; end ;
89157: GO 89160
89159: POP
// case btype of b_depot , b_warehouse :
89160: LD_VAR 0 1
89164: PUSH
89165: LD_INT 0
89167: DOUBLE
89168: EQUAL
89169: IFTRUE 89179
89171: LD_INT 1
89173: DOUBLE
89174: EQUAL
89175: IFTRUE 89179
89177: GO 89380
89179: POP
// case nation of nation_american :
89180: LD_VAR 0 5
89184: PUSH
89185: LD_INT 1
89187: DOUBLE
89188: EQUAL
89189: IFTRUE 89193
89191: GO 89249
89193: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
89194: LD_ADDR_VAR 0 9
89198: PUSH
89199: LD_VAR 0 11
89203: PUSH
89204: LD_VAR 0 12
89208: PUSH
89209: LD_VAR 0 13
89213: PUSH
89214: LD_VAR 0 14
89218: PUSH
89219: LD_VAR 0 15
89223: PUSH
89224: LD_VAR 0 16
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: PUSH
89237: LD_VAR 0 4
89241: PUSH
89242: LD_INT 1
89244: PLUS
89245: ARRAY
89246: ST_TO_ADDR
89247: GO 89378
89249: LD_INT 2
89251: DOUBLE
89252: EQUAL
89253: IFTRUE 89257
89255: GO 89313
89257: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
89258: LD_ADDR_VAR 0 9
89262: PUSH
89263: LD_VAR 0 17
89267: PUSH
89268: LD_VAR 0 18
89272: PUSH
89273: LD_VAR 0 19
89277: PUSH
89278: LD_VAR 0 20
89282: PUSH
89283: LD_VAR 0 21
89287: PUSH
89288: LD_VAR 0 22
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: PUSH
89301: LD_VAR 0 4
89305: PUSH
89306: LD_INT 1
89308: PLUS
89309: ARRAY
89310: ST_TO_ADDR
89311: GO 89378
89313: LD_INT 3
89315: DOUBLE
89316: EQUAL
89317: IFTRUE 89321
89319: GO 89377
89321: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
89322: LD_ADDR_VAR 0 9
89326: PUSH
89327: LD_VAR 0 23
89331: PUSH
89332: LD_VAR 0 24
89336: PUSH
89337: LD_VAR 0 25
89341: PUSH
89342: LD_VAR 0 26
89346: PUSH
89347: LD_VAR 0 27
89351: PUSH
89352: LD_VAR 0 28
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: PUSH
89365: LD_VAR 0 4
89369: PUSH
89370: LD_INT 1
89372: PLUS
89373: ARRAY
89374: ST_TO_ADDR
89375: GO 89378
89377: POP
89378: GO 89933
89380: LD_INT 2
89382: DOUBLE
89383: EQUAL
89384: IFTRUE 89394
89386: LD_INT 3
89388: DOUBLE
89389: EQUAL
89390: IFTRUE 89394
89392: GO 89450
89394: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
89395: LD_ADDR_VAR 0 9
89399: PUSH
89400: LD_VAR 0 29
89404: PUSH
89405: LD_VAR 0 30
89409: PUSH
89410: LD_VAR 0 31
89414: PUSH
89415: LD_VAR 0 32
89419: PUSH
89420: LD_VAR 0 33
89424: PUSH
89425: LD_VAR 0 34
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: PUSH
89438: LD_VAR 0 4
89442: PUSH
89443: LD_INT 1
89445: PLUS
89446: ARRAY
89447: ST_TO_ADDR
89448: GO 89933
89450: LD_INT 16
89452: DOUBLE
89453: EQUAL
89454: IFTRUE 89512
89456: LD_INT 17
89458: DOUBLE
89459: EQUAL
89460: IFTRUE 89512
89462: LD_INT 18
89464: DOUBLE
89465: EQUAL
89466: IFTRUE 89512
89468: LD_INT 19
89470: DOUBLE
89471: EQUAL
89472: IFTRUE 89512
89474: LD_INT 22
89476: DOUBLE
89477: EQUAL
89478: IFTRUE 89512
89480: LD_INT 20
89482: DOUBLE
89483: EQUAL
89484: IFTRUE 89512
89486: LD_INT 21
89488: DOUBLE
89489: EQUAL
89490: IFTRUE 89512
89492: LD_INT 23
89494: DOUBLE
89495: EQUAL
89496: IFTRUE 89512
89498: LD_INT 24
89500: DOUBLE
89501: EQUAL
89502: IFTRUE 89512
89504: LD_INT 25
89506: DOUBLE
89507: EQUAL
89508: IFTRUE 89512
89510: GO 89568
89512: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
89513: LD_ADDR_VAR 0 9
89517: PUSH
89518: LD_VAR 0 35
89522: PUSH
89523: LD_VAR 0 36
89527: PUSH
89528: LD_VAR 0 37
89532: PUSH
89533: LD_VAR 0 38
89537: PUSH
89538: LD_VAR 0 39
89542: PUSH
89543: LD_VAR 0 40
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: PUSH
89556: LD_VAR 0 4
89560: PUSH
89561: LD_INT 1
89563: PLUS
89564: ARRAY
89565: ST_TO_ADDR
89566: GO 89933
89568: LD_INT 6
89570: DOUBLE
89571: EQUAL
89572: IFTRUE 89624
89574: LD_INT 7
89576: DOUBLE
89577: EQUAL
89578: IFTRUE 89624
89580: LD_INT 8
89582: DOUBLE
89583: EQUAL
89584: IFTRUE 89624
89586: LD_INT 13
89588: DOUBLE
89589: EQUAL
89590: IFTRUE 89624
89592: LD_INT 12
89594: DOUBLE
89595: EQUAL
89596: IFTRUE 89624
89598: LD_INT 15
89600: DOUBLE
89601: EQUAL
89602: IFTRUE 89624
89604: LD_INT 11
89606: DOUBLE
89607: EQUAL
89608: IFTRUE 89624
89610: LD_INT 14
89612: DOUBLE
89613: EQUAL
89614: IFTRUE 89624
89616: LD_INT 10
89618: DOUBLE
89619: EQUAL
89620: IFTRUE 89624
89622: GO 89680
89624: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
89625: LD_ADDR_VAR 0 9
89629: PUSH
89630: LD_VAR 0 41
89634: PUSH
89635: LD_VAR 0 42
89639: PUSH
89640: LD_VAR 0 43
89644: PUSH
89645: LD_VAR 0 44
89649: PUSH
89650: LD_VAR 0 45
89654: PUSH
89655: LD_VAR 0 46
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: PUSH
89668: LD_VAR 0 4
89672: PUSH
89673: LD_INT 1
89675: PLUS
89676: ARRAY
89677: ST_TO_ADDR
89678: GO 89933
89680: LD_INT 36
89682: DOUBLE
89683: EQUAL
89684: IFTRUE 89688
89686: GO 89744
89688: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
89689: LD_ADDR_VAR 0 9
89693: PUSH
89694: LD_VAR 0 47
89698: PUSH
89699: LD_VAR 0 48
89703: PUSH
89704: LD_VAR 0 49
89708: PUSH
89709: LD_VAR 0 50
89713: PUSH
89714: LD_VAR 0 51
89718: PUSH
89719: LD_VAR 0 52
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: PUSH
89732: LD_VAR 0 4
89736: PUSH
89737: LD_INT 1
89739: PLUS
89740: ARRAY
89741: ST_TO_ADDR
89742: GO 89933
89744: LD_INT 4
89746: DOUBLE
89747: EQUAL
89748: IFTRUE 89770
89750: LD_INT 5
89752: DOUBLE
89753: EQUAL
89754: IFTRUE 89770
89756: LD_INT 34
89758: DOUBLE
89759: EQUAL
89760: IFTRUE 89770
89762: LD_INT 37
89764: DOUBLE
89765: EQUAL
89766: IFTRUE 89770
89768: GO 89826
89770: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
89771: LD_ADDR_VAR 0 9
89775: PUSH
89776: LD_VAR 0 53
89780: PUSH
89781: LD_VAR 0 54
89785: PUSH
89786: LD_VAR 0 55
89790: PUSH
89791: LD_VAR 0 56
89795: PUSH
89796: LD_VAR 0 57
89800: PUSH
89801: LD_VAR 0 58
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: PUSH
89814: LD_VAR 0 4
89818: PUSH
89819: LD_INT 1
89821: PLUS
89822: ARRAY
89823: ST_TO_ADDR
89824: GO 89933
89826: LD_INT 31
89828: DOUBLE
89829: EQUAL
89830: IFTRUE 89876
89832: LD_INT 32
89834: DOUBLE
89835: EQUAL
89836: IFTRUE 89876
89838: LD_INT 33
89840: DOUBLE
89841: EQUAL
89842: IFTRUE 89876
89844: LD_INT 27
89846: DOUBLE
89847: EQUAL
89848: IFTRUE 89876
89850: LD_INT 26
89852: DOUBLE
89853: EQUAL
89854: IFTRUE 89876
89856: LD_INT 28
89858: DOUBLE
89859: EQUAL
89860: IFTRUE 89876
89862: LD_INT 29
89864: DOUBLE
89865: EQUAL
89866: IFTRUE 89876
89868: LD_INT 30
89870: DOUBLE
89871: EQUAL
89872: IFTRUE 89876
89874: GO 89932
89876: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
89877: LD_ADDR_VAR 0 9
89881: PUSH
89882: LD_VAR 0 59
89886: PUSH
89887: LD_VAR 0 60
89891: PUSH
89892: LD_VAR 0 61
89896: PUSH
89897: LD_VAR 0 62
89901: PUSH
89902: LD_VAR 0 63
89906: PUSH
89907: LD_VAR 0 64
89911: PUSH
89912: EMPTY
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: PUSH
89920: LD_VAR 0 4
89924: PUSH
89925: LD_INT 1
89927: PLUS
89928: ARRAY
89929: ST_TO_ADDR
89930: GO 89933
89932: POP
// temp_list2 = [ ] ;
89933: LD_ADDR_VAR 0 10
89937: PUSH
89938: EMPTY
89939: ST_TO_ADDR
// for i in temp_list do
89940: LD_ADDR_VAR 0 8
89944: PUSH
89945: LD_VAR 0 9
89949: PUSH
89950: FOR_IN
89951: IFFALSE 90003
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
89953: LD_ADDR_VAR 0 10
89957: PUSH
89958: LD_VAR 0 10
89962: PUSH
89963: LD_VAR 0 8
89967: PUSH
89968: LD_INT 1
89970: ARRAY
89971: PUSH
89972: LD_VAR 0 2
89976: PLUS
89977: PUSH
89978: LD_VAR 0 8
89982: PUSH
89983: LD_INT 2
89985: ARRAY
89986: PUSH
89987: LD_VAR 0 3
89991: PLUS
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: EMPTY
89998: LIST
89999: ADD
90000: ST_TO_ADDR
90001: GO 89950
90003: POP
90004: POP
// result = temp_list2 ;
90005: LD_ADDR_VAR 0 7
90009: PUSH
90010: LD_VAR 0 10
90014: ST_TO_ADDR
// end ;
90015: LD_VAR 0 7
90019: RET
// export function EnemyInRange ( unit , dist ) ; begin
90020: LD_INT 0
90022: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
90023: LD_ADDR_VAR 0 3
90027: PUSH
90028: LD_VAR 0 1
90032: PPUSH
90033: CALL_OW 255
90037: PPUSH
90038: LD_VAR 0 1
90042: PPUSH
90043: CALL_OW 250
90047: PPUSH
90048: LD_VAR 0 1
90052: PPUSH
90053: CALL_OW 251
90057: PPUSH
90058: LD_VAR 0 2
90062: PPUSH
90063: CALL 64124 0 4
90067: PUSH
90068: LD_INT 4
90070: ARRAY
90071: ST_TO_ADDR
// end ;
90072: LD_VAR 0 3
90076: RET
// export function PlayerSeeMe ( unit ) ; begin
90077: LD_INT 0
90079: PPUSH
// result := See ( your_side , unit ) ;
90080: LD_ADDR_VAR 0 2
90084: PUSH
90085: LD_OWVAR 2
90089: PPUSH
90090: LD_VAR 0 1
90094: PPUSH
90095: CALL_OW 292
90099: ST_TO_ADDR
// end ;
90100: LD_VAR 0 2
90104: RET
// export function ReverseDir ( unit ) ; begin
90105: LD_INT 0
90107: PPUSH
// if not unit then
90108: LD_VAR 0 1
90112: NOT
90113: IFFALSE 90117
// exit ;
90115: GO 90140
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
90117: LD_ADDR_VAR 0 2
90121: PUSH
90122: LD_VAR 0 1
90126: PPUSH
90127: CALL_OW 254
90131: PUSH
90132: LD_INT 3
90134: PLUS
90135: PUSH
90136: LD_INT 6
90138: MOD
90139: ST_TO_ADDR
// end ;
90140: LD_VAR 0 2
90144: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
90145: LD_INT 0
90147: PPUSH
90148: PPUSH
90149: PPUSH
90150: PPUSH
90151: PPUSH
// if not hexes then
90152: LD_VAR 0 2
90156: NOT
90157: IFFALSE 90161
// exit ;
90159: GO 90309
// dist := 9999 ;
90161: LD_ADDR_VAR 0 5
90165: PUSH
90166: LD_INT 9999
90168: ST_TO_ADDR
// for i = 1 to hexes do
90169: LD_ADDR_VAR 0 4
90173: PUSH
90174: DOUBLE
90175: LD_INT 1
90177: DEC
90178: ST_TO_ADDR
90179: LD_VAR 0 2
90183: PUSH
90184: FOR_TO
90185: IFFALSE 90297
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
90187: LD_VAR 0 1
90191: PPUSH
90192: LD_VAR 0 2
90196: PUSH
90197: LD_VAR 0 4
90201: ARRAY
90202: PUSH
90203: LD_INT 1
90205: ARRAY
90206: PPUSH
90207: LD_VAR 0 2
90211: PUSH
90212: LD_VAR 0 4
90216: ARRAY
90217: PUSH
90218: LD_INT 2
90220: ARRAY
90221: PPUSH
90222: CALL_OW 297
90226: PUSH
90227: LD_VAR 0 5
90231: LESS
90232: IFFALSE 90295
// begin hex := hexes [ i ] ;
90234: LD_ADDR_VAR 0 7
90238: PUSH
90239: LD_VAR 0 2
90243: PUSH
90244: LD_VAR 0 4
90248: ARRAY
90249: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
90250: LD_ADDR_VAR 0 5
90254: PUSH
90255: LD_VAR 0 1
90259: PPUSH
90260: LD_VAR 0 2
90264: PUSH
90265: LD_VAR 0 4
90269: ARRAY
90270: PUSH
90271: LD_INT 1
90273: ARRAY
90274: PPUSH
90275: LD_VAR 0 2
90279: PUSH
90280: LD_VAR 0 4
90284: ARRAY
90285: PUSH
90286: LD_INT 2
90288: ARRAY
90289: PPUSH
90290: CALL_OW 297
90294: ST_TO_ADDR
// end ; end ;
90295: GO 90184
90297: POP
90298: POP
// result := hex ;
90299: LD_ADDR_VAR 0 3
90303: PUSH
90304: LD_VAR 0 7
90308: ST_TO_ADDR
// end ;
90309: LD_VAR 0 3
90313: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
90314: LD_INT 0
90316: PPUSH
90317: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90318: LD_VAR 0 1
90322: NOT
90323: PUSH
90324: LD_VAR 0 1
90328: PUSH
90329: LD_INT 21
90331: PUSH
90332: LD_INT 2
90334: PUSH
90335: EMPTY
90336: LIST
90337: LIST
90338: PUSH
90339: LD_INT 23
90341: PUSH
90342: LD_INT 2
90344: PUSH
90345: EMPTY
90346: LIST
90347: LIST
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PPUSH
90353: CALL_OW 69
90357: IN
90358: NOT
90359: OR
90360: IFFALSE 90364
// exit ;
90362: GO 90411
// for i = 1 to 3 do
90364: LD_ADDR_VAR 0 3
90368: PUSH
90369: DOUBLE
90370: LD_INT 1
90372: DEC
90373: ST_TO_ADDR
90374: LD_INT 3
90376: PUSH
90377: FOR_TO
90378: IFFALSE 90409
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
90380: LD_VAR 0 1
90384: PPUSH
90385: CALL_OW 250
90389: PPUSH
90390: LD_VAR 0 1
90394: PPUSH
90395: CALL_OW 251
90399: PPUSH
90400: LD_INT 1
90402: PPUSH
90403: CALL_OW 453
90407: GO 90377
90409: POP
90410: POP
// end ;
90411: LD_VAR 0 2
90415: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
90416: LD_INT 0
90418: PPUSH
90419: PPUSH
90420: PPUSH
90421: PPUSH
90422: PPUSH
90423: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
90424: LD_VAR 0 1
90428: NOT
90429: PUSH
90430: LD_VAR 0 2
90434: NOT
90435: OR
90436: PUSH
90437: LD_VAR 0 1
90441: PPUSH
90442: CALL_OW 314
90446: OR
90447: IFFALSE 90451
// exit ;
90449: GO 90892
// x := GetX ( enemy_unit ) ;
90451: LD_ADDR_VAR 0 7
90455: PUSH
90456: LD_VAR 0 2
90460: PPUSH
90461: CALL_OW 250
90465: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
90466: LD_ADDR_VAR 0 8
90470: PUSH
90471: LD_VAR 0 2
90475: PPUSH
90476: CALL_OW 251
90480: ST_TO_ADDR
// if not x or not y then
90481: LD_VAR 0 7
90485: NOT
90486: PUSH
90487: LD_VAR 0 8
90491: NOT
90492: OR
90493: IFFALSE 90497
// exit ;
90495: GO 90892
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
90497: LD_ADDR_VAR 0 6
90501: PUSH
90502: LD_VAR 0 7
90506: PPUSH
90507: LD_INT 0
90509: PPUSH
90510: LD_INT 4
90512: PPUSH
90513: CALL_OW 272
90517: PUSH
90518: LD_VAR 0 8
90522: PPUSH
90523: LD_INT 0
90525: PPUSH
90526: LD_INT 4
90528: PPUSH
90529: CALL_OW 273
90533: PUSH
90534: EMPTY
90535: LIST
90536: LIST
90537: PUSH
90538: LD_VAR 0 7
90542: PPUSH
90543: LD_INT 1
90545: PPUSH
90546: LD_INT 4
90548: PPUSH
90549: CALL_OW 272
90553: PUSH
90554: LD_VAR 0 8
90558: PPUSH
90559: LD_INT 1
90561: PPUSH
90562: LD_INT 4
90564: PPUSH
90565: CALL_OW 273
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_VAR 0 7
90578: PPUSH
90579: LD_INT 2
90581: PPUSH
90582: LD_INT 4
90584: PPUSH
90585: CALL_OW 272
90589: PUSH
90590: LD_VAR 0 8
90594: PPUSH
90595: LD_INT 2
90597: PPUSH
90598: LD_INT 4
90600: PPUSH
90601: CALL_OW 273
90605: PUSH
90606: EMPTY
90607: LIST
90608: LIST
90609: PUSH
90610: LD_VAR 0 7
90614: PPUSH
90615: LD_INT 3
90617: PPUSH
90618: LD_INT 4
90620: PPUSH
90621: CALL_OW 272
90625: PUSH
90626: LD_VAR 0 8
90630: PPUSH
90631: LD_INT 3
90633: PPUSH
90634: LD_INT 4
90636: PPUSH
90637: CALL_OW 273
90641: PUSH
90642: EMPTY
90643: LIST
90644: LIST
90645: PUSH
90646: LD_VAR 0 7
90650: PPUSH
90651: LD_INT 4
90653: PPUSH
90654: LD_INT 4
90656: PPUSH
90657: CALL_OW 272
90661: PUSH
90662: LD_VAR 0 8
90666: PPUSH
90667: LD_INT 4
90669: PPUSH
90670: LD_INT 4
90672: PPUSH
90673: CALL_OW 273
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_VAR 0 7
90686: PPUSH
90687: LD_INT 5
90689: PPUSH
90690: LD_INT 4
90692: PPUSH
90693: CALL_OW 272
90697: PUSH
90698: LD_VAR 0 8
90702: PPUSH
90703: LD_INT 5
90705: PPUSH
90706: LD_INT 4
90708: PPUSH
90709: CALL_OW 273
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: ST_TO_ADDR
// for i = tmp downto 1 do
90726: LD_ADDR_VAR 0 4
90730: PUSH
90731: DOUBLE
90732: LD_VAR 0 6
90736: INC
90737: ST_TO_ADDR
90738: LD_INT 1
90740: PUSH
90741: FOR_DOWNTO
90742: IFFALSE 90843
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
90744: LD_VAR 0 6
90748: PUSH
90749: LD_VAR 0 4
90753: ARRAY
90754: PUSH
90755: LD_INT 1
90757: ARRAY
90758: PPUSH
90759: LD_VAR 0 6
90763: PUSH
90764: LD_VAR 0 4
90768: ARRAY
90769: PUSH
90770: LD_INT 2
90772: ARRAY
90773: PPUSH
90774: CALL_OW 488
90778: NOT
90779: PUSH
90780: LD_VAR 0 6
90784: PUSH
90785: LD_VAR 0 4
90789: ARRAY
90790: PUSH
90791: LD_INT 1
90793: ARRAY
90794: PPUSH
90795: LD_VAR 0 6
90799: PUSH
90800: LD_VAR 0 4
90804: ARRAY
90805: PUSH
90806: LD_INT 2
90808: ARRAY
90809: PPUSH
90810: CALL_OW 428
90814: PUSH
90815: LD_INT 0
90817: NONEQUAL
90818: OR
90819: IFFALSE 90841
// tmp := Delete ( tmp , i ) ;
90821: LD_ADDR_VAR 0 6
90825: PUSH
90826: LD_VAR 0 6
90830: PPUSH
90831: LD_VAR 0 4
90835: PPUSH
90836: CALL_OW 3
90840: ST_TO_ADDR
90841: GO 90741
90843: POP
90844: POP
// j := GetClosestHex ( unit , tmp ) ;
90845: LD_ADDR_VAR 0 5
90849: PUSH
90850: LD_VAR 0 1
90854: PPUSH
90855: LD_VAR 0 6
90859: PPUSH
90860: CALL 90145 0 2
90864: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
90865: LD_VAR 0 1
90869: PPUSH
90870: LD_VAR 0 5
90874: PUSH
90875: LD_INT 1
90877: ARRAY
90878: PPUSH
90879: LD_VAR 0 5
90883: PUSH
90884: LD_INT 2
90886: ARRAY
90887: PPUSH
90888: CALL_OW 111
// end ;
90892: LD_VAR 0 3
90896: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
90897: LD_INT 0
90899: PPUSH
90900: PPUSH
90901: PPUSH
// uc_side = 0 ;
90902: LD_ADDR_OWVAR 20
90906: PUSH
90907: LD_INT 0
90909: ST_TO_ADDR
// uc_nation = 0 ;
90910: LD_ADDR_OWVAR 21
90914: PUSH
90915: LD_INT 0
90917: ST_TO_ADDR
// InitHc ;
90918: CALL_OW 19
// InitVc ;
90922: CALL_OW 20
// if mastodonts then
90926: LD_VAR 0 6
90930: IFFALSE 90997
// for i = 1 to mastodonts do
90932: LD_ADDR_VAR 0 11
90936: PUSH
90937: DOUBLE
90938: LD_INT 1
90940: DEC
90941: ST_TO_ADDR
90942: LD_VAR 0 6
90946: PUSH
90947: FOR_TO
90948: IFFALSE 90995
// begin vc_chassis := 31 ;
90950: LD_ADDR_OWVAR 37
90954: PUSH
90955: LD_INT 31
90957: ST_TO_ADDR
// vc_control := control_rider ;
90958: LD_ADDR_OWVAR 38
90962: PUSH
90963: LD_INT 4
90965: ST_TO_ADDR
// animal := CreateVehicle ;
90966: LD_ADDR_VAR 0 12
90970: PUSH
90971: CALL_OW 45
90975: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
90976: LD_VAR 0 12
90980: PPUSH
90981: LD_VAR 0 8
90985: PPUSH
90986: LD_INT 0
90988: PPUSH
90989: CALL 93066 0 3
// end ;
90993: GO 90947
90995: POP
90996: POP
// if horses then
90997: LD_VAR 0 5
91001: IFFALSE 91068
// for i = 1 to horses do
91003: LD_ADDR_VAR 0 11
91007: PUSH
91008: DOUBLE
91009: LD_INT 1
91011: DEC
91012: ST_TO_ADDR
91013: LD_VAR 0 5
91017: PUSH
91018: FOR_TO
91019: IFFALSE 91066
// begin hc_class := 21 ;
91021: LD_ADDR_OWVAR 28
91025: PUSH
91026: LD_INT 21
91028: ST_TO_ADDR
// hc_gallery :=  ;
91029: LD_ADDR_OWVAR 33
91033: PUSH
91034: LD_STRING 
91036: ST_TO_ADDR
// animal := CreateHuman ;
91037: LD_ADDR_VAR 0 12
91041: PUSH
91042: CALL_OW 44
91046: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91047: LD_VAR 0 12
91051: PPUSH
91052: LD_VAR 0 8
91056: PPUSH
91057: LD_INT 0
91059: PPUSH
91060: CALL 93066 0 3
// end ;
91064: GO 91018
91066: POP
91067: POP
// if birds then
91068: LD_VAR 0 1
91072: IFFALSE 91139
// for i = 1 to birds do
91074: LD_ADDR_VAR 0 11
91078: PUSH
91079: DOUBLE
91080: LD_INT 1
91082: DEC
91083: ST_TO_ADDR
91084: LD_VAR 0 1
91088: PUSH
91089: FOR_TO
91090: IFFALSE 91137
// begin hc_class = 18 ;
91092: LD_ADDR_OWVAR 28
91096: PUSH
91097: LD_INT 18
91099: ST_TO_ADDR
// hc_gallery =  ;
91100: LD_ADDR_OWVAR 33
91104: PUSH
91105: LD_STRING 
91107: ST_TO_ADDR
// animal := CreateHuman ;
91108: LD_ADDR_VAR 0 12
91112: PUSH
91113: CALL_OW 44
91117: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91118: LD_VAR 0 12
91122: PPUSH
91123: LD_VAR 0 8
91127: PPUSH
91128: LD_INT 0
91130: PPUSH
91131: CALL 93066 0 3
// end ;
91135: GO 91089
91137: POP
91138: POP
// if tigers then
91139: LD_VAR 0 2
91143: IFFALSE 91227
// for i = 1 to tigers do
91145: LD_ADDR_VAR 0 11
91149: PUSH
91150: DOUBLE
91151: LD_INT 1
91153: DEC
91154: ST_TO_ADDR
91155: LD_VAR 0 2
91159: PUSH
91160: FOR_TO
91161: IFFALSE 91225
// begin hc_class = class_tiger ;
91163: LD_ADDR_OWVAR 28
91167: PUSH
91168: LD_INT 14
91170: ST_TO_ADDR
// hc_gallery =  ;
91171: LD_ADDR_OWVAR 33
91175: PUSH
91176: LD_STRING 
91178: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
91179: LD_ADDR_OWVAR 35
91183: PUSH
91184: LD_INT 7
91186: NEG
91187: PPUSH
91188: LD_INT 7
91190: PPUSH
91191: CALL_OW 12
91195: ST_TO_ADDR
// animal := CreateHuman ;
91196: LD_ADDR_VAR 0 12
91200: PUSH
91201: CALL_OW 44
91205: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91206: LD_VAR 0 12
91210: PPUSH
91211: LD_VAR 0 8
91215: PPUSH
91216: LD_INT 0
91218: PPUSH
91219: CALL 93066 0 3
// end ;
91223: GO 91160
91225: POP
91226: POP
// if apemans then
91227: LD_VAR 0 3
91231: IFFALSE 91354
// for i = 1 to apemans do
91233: LD_ADDR_VAR 0 11
91237: PUSH
91238: DOUBLE
91239: LD_INT 1
91241: DEC
91242: ST_TO_ADDR
91243: LD_VAR 0 3
91247: PUSH
91248: FOR_TO
91249: IFFALSE 91352
// begin hc_class = class_apeman ;
91251: LD_ADDR_OWVAR 28
91255: PUSH
91256: LD_INT 12
91258: ST_TO_ADDR
// hc_gallery =  ;
91259: LD_ADDR_OWVAR 33
91263: PUSH
91264: LD_STRING 
91266: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
91267: LD_ADDR_OWVAR 35
91271: PUSH
91272: LD_INT 5
91274: NEG
91275: PPUSH
91276: LD_INT 5
91278: PPUSH
91279: CALL_OW 12
91283: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
91284: LD_ADDR_OWVAR 31
91288: PUSH
91289: LD_INT 1
91291: PPUSH
91292: LD_INT 3
91294: PPUSH
91295: CALL_OW 12
91299: PUSH
91300: LD_INT 1
91302: PPUSH
91303: LD_INT 3
91305: PPUSH
91306: CALL_OW 12
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: LIST
91321: LIST
91322: ST_TO_ADDR
// animal := CreateHuman ;
91323: LD_ADDR_VAR 0 12
91327: PUSH
91328: CALL_OW 44
91332: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91333: LD_VAR 0 12
91337: PPUSH
91338: LD_VAR 0 8
91342: PPUSH
91343: LD_INT 0
91345: PPUSH
91346: CALL 93066 0 3
// end ;
91350: GO 91248
91352: POP
91353: POP
// if enchidnas then
91354: LD_VAR 0 4
91358: IFFALSE 91425
// for i = 1 to enchidnas do
91360: LD_ADDR_VAR 0 11
91364: PUSH
91365: DOUBLE
91366: LD_INT 1
91368: DEC
91369: ST_TO_ADDR
91370: LD_VAR 0 4
91374: PUSH
91375: FOR_TO
91376: IFFALSE 91423
// begin hc_class = 13 ;
91378: LD_ADDR_OWVAR 28
91382: PUSH
91383: LD_INT 13
91385: ST_TO_ADDR
// hc_gallery =  ;
91386: LD_ADDR_OWVAR 33
91390: PUSH
91391: LD_STRING 
91393: ST_TO_ADDR
// animal := CreateHuman ;
91394: LD_ADDR_VAR 0 12
91398: PUSH
91399: CALL_OW 44
91403: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
91404: LD_VAR 0 12
91408: PPUSH
91409: LD_VAR 0 8
91413: PPUSH
91414: LD_INT 0
91416: PPUSH
91417: CALL 93066 0 3
// end ;
91421: GO 91375
91423: POP
91424: POP
// if fishes then
91425: LD_VAR 0 7
91429: IFFALSE 91496
// for i = 1 to fishes do
91431: LD_ADDR_VAR 0 11
91435: PUSH
91436: DOUBLE
91437: LD_INT 1
91439: DEC
91440: ST_TO_ADDR
91441: LD_VAR 0 7
91445: PUSH
91446: FOR_TO
91447: IFFALSE 91494
// begin hc_class = 20 ;
91449: LD_ADDR_OWVAR 28
91453: PUSH
91454: LD_INT 20
91456: ST_TO_ADDR
// hc_gallery =  ;
91457: LD_ADDR_OWVAR 33
91461: PUSH
91462: LD_STRING 
91464: ST_TO_ADDR
// animal := CreateHuman ;
91465: LD_ADDR_VAR 0 12
91469: PUSH
91470: CALL_OW 44
91474: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
91475: LD_VAR 0 12
91479: PPUSH
91480: LD_VAR 0 9
91484: PPUSH
91485: LD_INT 0
91487: PPUSH
91488: CALL 93066 0 3
// end ;
91492: GO 91446
91494: POP
91495: POP
// end ;
91496: LD_VAR 0 10
91500: RET
// export function WantHeal ( sci , unit ) ; begin
91501: LD_INT 0
91503: PPUSH
// if GetTaskList ( sci ) > 0 then
91504: LD_VAR 0 1
91508: PPUSH
91509: CALL_OW 437
91513: PUSH
91514: LD_INT 0
91516: GREATER
91517: IFFALSE 91587
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
91519: LD_VAR 0 1
91523: PPUSH
91524: CALL_OW 437
91528: PUSH
91529: LD_INT 1
91531: ARRAY
91532: PUSH
91533: LD_INT 1
91535: ARRAY
91536: PUSH
91537: LD_STRING l
91539: EQUAL
91540: PUSH
91541: LD_VAR 0 1
91545: PPUSH
91546: CALL_OW 437
91550: PUSH
91551: LD_INT 1
91553: ARRAY
91554: PUSH
91555: LD_INT 4
91557: ARRAY
91558: PUSH
91559: LD_VAR 0 2
91563: EQUAL
91564: AND
91565: IFFALSE 91577
// result := true else
91567: LD_ADDR_VAR 0 3
91571: PUSH
91572: LD_INT 1
91574: ST_TO_ADDR
91575: GO 91585
// result := false ;
91577: LD_ADDR_VAR 0 3
91581: PUSH
91582: LD_INT 0
91584: ST_TO_ADDR
// end else
91585: GO 91595
// result := false ;
91587: LD_ADDR_VAR 0 3
91591: PUSH
91592: LD_INT 0
91594: ST_TO_ADDR
// end ;
91595: LD_VAR 0 3
91599: RET
// export function HealTarget ( sci ) ; begin
91600: LD_INT 0
91602: PPUSH
// if not sci then
91603: LD_VAR 0 1
91607: NOT
91608: IFFALSE 91612
// exit ;
91610: GO 91677
// result := 0 ;
91612: LD_ADDR_VAR 0 2
91616: PUSH
91617: LD_INT 0
91619: ST_TO_ADDR
// if GetTaskList ( sci ) then
91620: LD_VAR 0 1
91624: PPUSH
91625: CALL_OW 437
91629: IFFALSE 91677
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
91631: LD_VAR 0 1
91635: PPUSH
91636: CALL_OW 437
91640: PUSH
91641: LD_INT 1
91643: ARRAY
91644: PUSH
91645: LD_INT 1
91647: ARRAY
91648: PUSH
91649: LD_STRING l
91651: EQUAL
91652: IFFALSE 91677
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
91654: LD_ADDR_VAR 0 2
91658: PUSH
91659: LD_VAR 0 1
91663: PPUSH
91664: CALL_OW 437
91668: PUSH
91669: LD_INT 1
91671: ARRAY
91672: PUSH
91673: LD_INT 4
91675: ARRAY
91676: ST_TO_ADDR
// end ;
91677: LD_VAR 0 2
91681: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
91682: LD_INT 0
91684: PPUSH
91685: PPUSH
91686: PPUSH
91687: PPUSH
// if not base_units then
91688: LD_VAR 0 1
91692: NOT
91693: IFFALSE 91697
// exit ;
91695: GO 91784
// result := false ;
91697: LD_ADDR_VAR 0 2
91701: PUSH
91702: LD_INT 0
91704: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
91705: LD_ADDR_VAR 0 5
91709: PUSH
91710: LD_VAR 0 1
91714: PPUSH
91715: LD_INT 21
91717: PUSH
91718: LD_INT 3
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PPUSH
91725: CALL_OW 72
91729: ST_TO_ADDR
// if not tmp then
91730: LD_VAR 0 5
91734: NOT
91735: IFFALSE 91739
// exit ;
91737: GO 91784
// for i in tmp do
91739: LD_ADDR_VAR 0 3
91743: PUSH
91744: LD_VAR 0 5
91748: PUSH
91749: FOR_IN
91750: IFFALSE 91782
// begin result := EnemyInRange ( i , 22 ) ;
91752: LD_ADDR_VAR 0 2
91756: PUSH
91757: LD_VAR 0 3
91761: PPUSH
91762: LD_INT 22
91764: PPUSH
91765: CALL 90020 0 2
91769: ST_TO_ADDR
// if result then
91770: LD_VAR 0 2
91774: IFFALSE 91780
// exit ;
91776: POP
91777: POP
91778: GO 91784
// end ;
91780: GO 91749
91782: POP
91783: POP
// end ;
91784: LD_VAR 0 2
91788: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
91789: LD_INT 0
91791: PPUSH
91792: PPUSH
// if not units then
91793: LD_VAR 0 1
91797: NOT
91798: IFFALSE 91802
// exit ;
91800: GO 91872
// result := [ ] ;
91802: LD_ADDR_VAR 0 3
91806: PUSH
91807: EMPTY
91808: ST_TO_ADDR
// for i in units do
91809: LD_ADDR_VAR 0 4
91813: PUSH
91814: LD_VAR 0 1
91818: PUSH
91819: FOR_IN
91820: IFFALSE 91870
// if GetTag ( i ) = tag then
91822: LD_VAR 0 4
91826: PPUSH
91827: CALL_OW 110
91831: PUSH
91832: LD_VAR 0 2
91836: EQUAL
91837: IFFALSE 91868
// result := Insert ( result , result + 1 , i ) ;
91839: LD_ADDR_VAR 0 3
91843: PUSH
91844: LD_VAR 0 3
91848: PPUSH
91849: LD_VAR 0 3
91853: PUSH
91854: LD_INT 1
91856: PLUS
91857: PPUSH
91858: LD_VAR 0 4
91862: PPUSH
91863: CALL_OW 2
91867: ST_TO_ADDR
91868: GO 91819
91870: POP
91871: POP
// end ;
91872: LD_VAR 0 3
91876: RET
// export function IsDriver ( un ) ; begin
91877: LD_INT 0
91879: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
91880: LD_ADDR_VAR 0 2
91884: PUSH
91885: LD_VAR 0 1
91889: PUSH
91890: LD_INT 55
91892: PUSH
91893: EMPTY
91894: LIST
91895: PPUSH
91896: CALL_OW 69
91900: IN
91901: ST_TO_ADDR
// end ;
91902: LD_VAR 0 2
91906: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91907: LD_INT 0
91909: PPUSH
91910: PPUSH
// list := [ ] ;
91911: LD_ADDR_VAR 0 5
91915: PUSH
91916: EMPTY
91917: ST_TO_ADDR
// case d of 0 :
91918: LD_VAR 0 3
91922: PUSH
91923: LD_INT 0
91925: DOUBLE
91926: EQUAL
91927: IFTRUE 91931
91929: GO 92064
91931: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91932: LD_ADDR_VAR 0 5
91936: PUSH
91937: LD_VAR 0 1
91941: PUSH
91942: LD_INT 4
91944: MINUS
91945: PUSH
91946: LD_VAR 0 2
91950: PUSH
91951: LD_INT 4
91953: MINUS
91954: PUSH
91955: LD_INT 2
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: LIST
91962: PUSH
91963: LD_VAR 0 1
91967: PUSH
91968: LD_INT 3
91970: MINUS
91971: PUSH
91972: LD_VAR 0 2
91976: PUSH
91977: LD_INT 1
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: LIST
91984: PUSH
91985: LD_VAR 0 1
91989: PUSH
91990: LD_INT 4
91992: PLUS
91993: PUSH
91994: LD_VAR 0 2
91998: PUSH
91999: LD_INT 4
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: LIST
92006: PUSH
92007: LD_VAR 0 1
92011: PUSH
92012: LD_INT 3
92014: PLUS
92015: PUSH
92016: LD_VAR 0 2
92020: PUSH
92021: LD_INT 3
92023: PLUS
92024: PUSH
92025: LD_INT 5
92027: PUSH
92028: EMPTY
92029: LIST
92030: LIST
92031: LIST
92032: PUSH
92033: LD_VAR 0 1
92037: PUSH
92038: LD_VAR 0 2
92042: PUSH
92043: LD_INT 4
92045: PLUS
92046: PUSH
92047: LD_INT 0
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: LIST
92054: PUSH
92055: EMPTY
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: ST_TO_ADDR
// end ; 1 :
92062: GO 92762
92064: LD_INT 1
92066: DOUBLE
92067: EQUAL
92068: IFTRUE 92072
92070: GO 92205
92072: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
92073: LD_ADDR_VAR 0 5
92077: PUSH
92078: LD_VAR 0 1
92082: PUSH
92083: LD_VAR 0 2
92087: PUSH
92088: LD_INT 4
92090: MINUS
92091: PUSH
92092: LD_INT 3
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: LIST
92099: PUSH
92100: LD_VAR 0 1
92104: PUSH
92105: LD_INT 3
92107: MINUS
92108: PUSH
92109: LD_VAR 0 2
92113: PUSH
92114: LD_INT 3
92116: MINUS
92117: PUSH
92118: LD_INT 2
92120: PUSH
92121: EMPTY
92122: LIST
92123: LIST
92124: LIST
92125: PUSH
92126: LD_VAR 0 1
92130: PUSH
92131: LD_INT 4
92133: MINUS
92134: PUSH
92135: LD_VAR 0 2
92139: PUSH
92140: LD_INT 1
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: LIST
92147: PUSH
92148: LD_VAR 0 1
92152: PUSH
92153: LD_VAR 0 2
92157: PUSH
92158: LD_INT 3
92160: PLUS
92161: PUSH
92162: LD_INT 0
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: LIST
92169: PUSH
92170: LD_VAR 0 1
92174: PUSH
92175: LD_INT 4
92177: PLUS
92178: PUSH
92179: LD_VAR 0 2
92183: PUSH
92184: LD_INT 4
92186: PLUS
92187: PUSH
92188: LD_INT 5
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: LIST
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: LIST
92200: LIST
92201: LIST
92202: ST_TO_ADDR
// end ; 2 :
92203: GO 92762
92205: LD_INT 2
92207: DOUBLE
92208: EQUAL
92209: IFTRUE 92213
92211: GO 92342
92213: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
92214: LD_ADDR_VAR 0 5
92218: PUSH
92219: LD_VAR 0 1
92223: PUSH
92224: LD_VAR 0 2
92228: PUSH
92229: LD_INT 3
92231: MINUS
92232: PUSH
92233: LD_INT 3
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: LIST
92240: PUSH
92241: LD_VAR 0 1
92245: PUSH
92246: LD_INT 4
92248: PLUS
92249: PUSH
92250: LD_VAR 0 2
92254: PUSH
92255: LD_INT 4
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: LIST
92262: PUSH
92263: LD_VAR 0 1
92267: PUSH
92268: LD_VAR 0 2
92272: PUSH
92273: LD_INT 4
92275: PLUS
92276: PUSH
92277: LD_INT 0
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: LIST
92284: PUSH
92285: LD_VAR 0 1
92289: PUSH
92290: LD_INT 3
92292: MINUS
92293: PUSH
92294: LD_VAR 0 2
92298: PUSH
92299: LD_INT 1
92301: PUSH
92302: EMPTY
92303: LIST
92304: LIST
92305: LIST
92306: PUSH
92307: LD_VAR 0 1
92311: PUSH
92312: LD_INT 4
92314: MINUS
92315: PUSH
92316: LD_VAR 0 2
92320: PUSH
92321: LD_INT 4
92323: MINUS
92324: PUSH
92325: LD_INT 2
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: LIST
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: ST_TO_ADDR
// end ; 3 :
92340: GO 92762
92342: LD_INT 3
92344: DOUBLE
92345: EQUAL
92346: IFTRUE 92350
92348: GO 92483
92350: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
92351: LD_ADDR_VAR 0 5
92355: PUSH
92356: LD_VAR 0 1
92360: PUSH
92361: LD_INT 3
92363: PLUS
92364: PUSH
92365: LD_VAR 0 2
92369: PUSH
92370: LD_INT 4
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: LIST
92377: PUSH
92378: LD_VAR 0 1
92382: PUSH
92383: LD_INT 4
92385: PLUS
92386: PUSH
92387: LD_VAR 0 2
92391: PUSH
92392: LD_INT 4
92394: PLUS
92395: PUSH
92396: LD_INT 5
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: LIST
92403: PUSH
92404: LD_VAR 0 1
92408: PUSH
92409: LD_INT 4
92411: MINUS
92412: PUSH
92413: LD_VAR 0 2
92417: PUSH
92418: LD_INT 1
92420: PUSH
92421: EMPTY
92422: LIST
92423: LIST
92424: LIST
92425: PUSH
92426: LD_VAR 0 1
92430: PUSH
92431: LD_VAR 0 2
92435: PUSH
92436: LD_INT 4
92438: MINUS
92439: PUSH
92440: LD_INT 3
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: LIST
92447: PUSH
92448: LD_VAR 0 1
92452: PUSH
92453: LD_INT 3
92455: MINUS
92456: PUSH
92457: LD_VAR 0 2
92461: PUSH
92462: LD_INT 3
92464: MINUS
92465: PUSH
92466: LD_INT 2
92468: PUSH
92469: EMPTY
92470: LIST
92471: LIST
92472: LIST
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: LIST
92480: ST_TO_ADDR
// end ; 4 :
92481: GO 92762
92483: LD_INT 4
92485: DOUBLE
92486: EQUAL
92487: IFTRUE 92491
92489: GO 92624
92491: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
92492: LD_ADDR_VAR 0 5
92496: PUSH
92497: LD_VAR 0 1
92501: PUSH
92502: LD_VAR 0 2
92506: PUSH
92507: LD_INT 4
92509: PLUS
92510: PUSH
92511: LD_INT 0
92513: PUSH
92514: EMPTY
92515: LIST
92516: LIST
92517: LIST
92518: PUSH
92519: LD_VAR 0 1
92523: PUSH
92524: LD_INT 3
92526: PLUS
92527: PUSH
92528: LD_VAR 0 2
92532: PUSH
92533: LD_INT 3
92535: PLUS
92536: PUSH
92537: LD_INT 5
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: LIST
92544: PUSH
92545: LD_VAR 0 1
92549: PUSH
92550: LD_INT 4
92552: PLUS
92553: PUSH
92554: LD_VAR 0 2
92558: PUSH
92559: LD_INT 4
92561: PUSH
92562: EMPTY
92563: LIST
92564: LIST
92565: LIST
92566: PUSH
92567: LD_VAR 0 1
92571: PUSH
92572: LD_VAR 0 2
92576: PUSH
92577: LD_INT 3
92579: MINUS
92580: PUSH
92581: LD_INT 3
92583: PUSH
92584: EMPTY
92585: LIST
92586: LIST
92587: LIST
92588: PUSH
92589: LD_VAR 0 1
92593: PUSH
92594: LD_INT 4
92596: MINUS
92597: PUSH
92598: LD_VAR 0 2
92602: PUSH
92603: LD_INT 4
92605: MINUS
92606: PUSH
92607: LD_INT 2
92609: PUSH
92610: EMPTY
92611: LIST
92612: LIST
92613: LIST
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: LIST
92619: LIST
92620: LIST
92621: ST_TO_ADDR
// end ; 5 :
92622: GO 92762
92624: LD_INT 5
92626: DOUBLE
92627: EQUAL
92628: IFTRUE 92632
92630: GO 92761
92632: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
92633: LD_ADDR_VAR 0 5
92637: PUSH
92638: LD_VAR 0 1
92642: PUSH
92643: LD_INT 4
92645: MINUS
92646: PUSH
92647: LD_VAR 0 2
92651: PUSH
92652: LD_INT 1
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: LIST
92659: PUSH
92660: LD_VAR 0 1
92664: PUSH
92665: LD_VAR 0 2
92669: PUSH
92670: LD_INT 4
92672: MINUS
92673: PUSH
92674: LD_INT 3
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: PUSH
92682: LD_VAR 0 1
92686: PUSH
92687: LD_INT 4
92689: PLUS
92690: PUSH
92691: LD_VAR 0 2
92695: PUSH
92696: LD_INT 4
92698: PLUS
92699: PUSH
92700: LD_INT 5
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: LIST
92707: PUSH
92708: LD_VAR 0 1
92712: PUSH
92713: LD_INT 3
92715: PLUS
92716: PUSH
92717: LD_VAR 0 2
92721: PUSH
92722: LD_INT 4
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: LIST
92729: PUSH
92730: LD_VAR 0 1
92734: PUSH
92735: LD_VAR 0 2
92739: PUSH
92740: LD_INT 3
92742: PLUS
92743: PUSH
92744: LD_INT 0
92746: PUSH
92747: EMPTY
92748: LIST
92749: LIST
92750: LIST
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: ST_TO_ADDR
// end ; end ;
92759: GO 92762
92761: POP
// result := list ;
92762: LD_ADDR_VAR 0 4
92766: PUSH
92767: LD_VAR 0 5
92771: ST_TO_ADDR
// end ;
92772: LD_VAR 0 4
92776: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
92777: LD_INT 0
92779: PPUSH
92780: PPUSH
92781: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
92782: LD_VAR 0 1
92786: NOT
92787: PUSH
92788: LD_VAR 0 2
92792: PUSH
92793: LD_INT 1
92795: PUSH
92796: LD_INT 2
92798: PUSH
92799: LD_INT 3
92801: PUSH
92802: LD_INT 4
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: IN
92811: NOT
92812: OR
92813: IFFALSE 92817
// exit ;
92815: GO 92909
// tmp := [ ] ;
92817: LD_ADDR_VAR 0 5
92821: PUSH
92822: EMPTY
92823: ST_TO_ADDR
// for i in units do
92824: LD_ADDR_VAR 0 4
92828: PUSH
92829: LD_VAR 0 1
92833: PUSH
92834: FOR_IN
92835: IFFALSE 92878
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
92837: LD_ADDR_VAR 0 5
92841: PUSH
92842: LD_VAR 0 5
92846: PPUSH
92847: LD_VAR 0 5
92851: PUSH
92852: LD_INT 1
92854: PLUS
92855: PPUSH
92856: LD_VAR 0 4
92860: PPUSH
92861: LD_VAR 0 2
92865: PPUSH
92866: CALL_OW 259
92870: PPUSH
92871: CALL_OW 2
92875: ST_TO_ADDR
92876: GO 92834
92878: POP
92879: POP
// if not tmp then
92880: LD_VAR 0 5
92884: NOT
92885: IFFALSE 92889
// exit ;
92887: GO 92909
// result := SortListByListDesc ( units , tmp ) ;
92889: LD_ADDR_VAR 0 3
92893: PUSH
92894: LD_VAR 0 1
92898: PPUSH
92899: LD_VAR 0 5
92903: PPUSH
92904: CALL_OW 77
92908: ST_TO_ADDR
// end ;
92909: LD_VAR 0 3
92913: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92914: LD_INT 0
92916: PPUSH
92917: PPUSH
92918: PPUSH
// x := GetX ( building ) ;
92919: LD_ADDR_VAR 0 4
92923: PUSH
92924: LD_VAR 0 2
92928: PPUSH
92929: CALL_OW 250
92933: ST_TO_ADDR
// y := GetY ( building ) ;
92934: LD_ADDR_VAR 0 5
92938: PUSH
92939: LD_VAR 0 2
92943: PPUSH
92944: CALL_OW 251
92948: ST_TO_ADDR
// if GetTaskList ( unit ) then
92949: LD_VAR 0 1
92953: PPUSH
92954: CALL_OW 437
92958: IFFALSE 93053
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92960: LD_STRING e
92962: PUSH
92963: LD_VAR 0 1
92967: PPUSH
92968: CALL_OW 437
92972: PUSH
92973: LD_INT 1
92975: ARRAY
92976: PUSH
92977: LD_INT 1
92979: ARRAY
92980: EQUAL
92981: PUSH
92982: LD_VAR 0 4
92986: PUSH
92987: LD_VAR 0 1
92991: PPUSH
92992: CALL_OW 437
92996: PUSH
92997: LD_INT 1
92999: ARRAY
93000: PUSH
93001: LD_INT 2
93003: ARRAY
93004: EQUAL
93005: AND
93006: PUSH
93007: LD_VAR 0 5
93011: PUSH
93012: LD_VAR 0 1
93016: PPUSH
93017: CALL_OW 437
93021: PUSH
93022: LD_INT 1
93024: ARRAY
93025: PUSH
93026: LD_INT 3
93028: ARRAY
93029: EQUAL
93030: AND
93031: IFFALSE 93043
// result := true else
93033: LD_ADDR_VAR 0 3
93037: PUSH
93038: LD_INT 1
93040: ST_TO_ADDR
93041: GO 93051
// result := false ;
93043: LD_ADDR_VAR 0 3
93047: PUSH
93048: LD_INT 0
93050: ST_TO_ADDR
// end else
93051: GO 93061
// result := false ;
93053: LD_ADDR_VAR 0 3
93057: PUSH
93058: LD_INT 0
93060: ST_TO_ADDR
// end ;
93061: LD_VAR 0 3
93065: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
93066: LD_INT 0
93068: PPUSH
93069: PPUSH
93070: PPUSH
93071: PPUSH
// if not unit or not area then
93072: LD_VAR 0 1
93076: NOT
93077: PUSH
93078: LD_VAR 0 2
93082: NOT
93083: OR
93084: IFFALSE 93088
// exit ;
93086: GO 93252
// tmp := AreaToList ( area , i ) ;
93088: LD_ADDR_VAR 0 6
93092: PUSH
93093: LD_VAR 0 2
93097: PPUSH
93098: LD_VAR 0 5
93102: PPUSH
93103: CALL_OW 517
93107: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
93108: LD_ADDR_VAR 0 5
93112: PUSH
93113: DOUBLE
93114: LD_INT 1
93116: DEC
93117: ST_TO_ADDR
93118: LD_VAR 0 6
93122: PUSH
93123: LD_INT 1
93125: ARRAY
93126: PUSH
93127: FOR_TO
93128: IFFALSE 93250
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
93130: LD_ADDR_VAR 0 7
93134: PUSH
93135: LD_VAR 0 6
93139: PUSH
93140: LD_INT 1
93142: ARRAY
93143: PUSH
93144: LD_VAR 0 5
93148: ARRAY
93149: PUSH
93150: LD_VAR 0 6
93154: PUSH
93155: LD_INT 2
93157: ARRAY
93158: PUSH
93159: LD_VAR 0 5
93163: ARRAY
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
93169: LD_VAR 0 7
93173: PUSH
93174: LD_INT 1
93176: ARRAY
93177: PPUSH
93178: LD_VAR 0 7
93182: PUSH
93183: LD_INT 2
93185: ARRAY
93186: PPUSH
93187: CALL_OW 428
93191: PUSH
93192: LD_INT 0
93194: EQUAL
93195: IFFALSE 93248
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
93197: LD_VAR 0 1
93201: PPUSH
93202: LD_VAR 0 7
93206: PUSH
93207: LD_INT 1
93209: ARRAY
93210: PPUSH
93211: LD_VAR 0 7
93215: PUSH
93216: LD_INT 2
93218: ARRAY
93219: PPUSH
93220: LD_VAR 0 3
93224: PPUSH
93225: CALL_OW 48
// result := IsPlaced ( unit ) ;
93229: LD_ADDR_VAR 0 4
93233: PUSH
93234: LD_VAR 0 1
93238: PPUSH
93239: CALL_OW 305
93243: ST_TO_ADDR
// exit ;
93244: POP
93245: POP
93246: GO 93252
// end ; end ;
93248: GO 93127
93250: POP
93251: POP
// end ;
93252: LD_VAR 0 4
93256: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
93257: LD_INT 0
93259: PPUSH
93260: PPUSH
93261: PPUSH
// if not side or side > 8 then
93262: LD_VAR 0 1
93266: NOT
93267: PUSH
93268: LD_VAR 0 1
93272: PUSH
93273: LD_INT 8
93275: GREATER
93276: OR
93277: IFFALSE 93281
// exit ;
93279: GO 93468
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
93281: LD_ADDR_VAR 0 4
93285: PUSH
93286: LD_INT 22
93288: PUSH
93289: LD_VAR 0 1
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: LD_INT 21
93300: PUSH
93301: LD_INT 3
93303: PUSH
93304: EMPTY
93305: LIST
93306: LIST
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PPUSH
93312: CALL_OW 69
93316: ST_TO_ADDR
// if not tmp then
93317: LD_VAR 0 4
93321: NOT
93322: IFFALSE 93326
// exit ;
93324: GO 93468
// enable_addtolog := true ;
93326: LD_ADDR_OWVAR 81
93330: PUSH
93331: LD_INT 1
93333: ST_TO_ADDR
// AddToLog ( [ ) ;
93334: LD_STRING [
93336: PPUSH
93337: CALL_OW 561
// for i in tmp do
93341: LD_ADDR_VAR 0 3
93345: PUSH
93346: LD_VAR 0 4
93350: PUSH
93351: FOR_IN
93352: IFFALSE 93459
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
93354: LD_STRING [
93356: PUSH
93357: LD_VAR 0 3
93361: PPUSH
93362: CALL_OW 266
93366: STR
93367: PUSH
93368: LD_STRING , 
93370: STR
93371: PUSH
93372: LD_VAR 0 3
93376: PPUSH
93377: CALL_OW 250
93381: STR
93382: PUSH
93383: LD_STRING , 
93385: STR
93386: PUSH
93387: LD_VAR 0 3
93391: PPUSH
93392: CALL_OW 251
93396: STR
93397: PUSH
93398: LD_STRING , 
93400: STR
93401: PUSH
93402: LD_VAR 0 3
93406: PPUSH
93407: CALL_OW 254
93411: STR
93412: PUSH
93413: LD_STRING , 
93415: STR
93416: PUSH
93417: LD_VAR 0 3
93421: PPUSH
93422: LD_INT 1
93424: PPUSH
93425: CALL_OW 268
93429: STR
93430: PUSH
93431: LD_STRING , 
93433: STR
93434: PUSH
93435: LD_VAR 0 3
93439: PPUSH
93440: LD_INT 2
93442: PPUSH
93443: CALL_OW 268
93447: STR
93448: PUSH
93449: LD_STRING ],
93451: STR
93452: PPUSH
93453: CALL_OW 561
// end ;
93457: GO 93351
93459: POP
93460: POP
// AddToLog ( ]; ) ;
93461: LD_STRING ];
93463: PPUSH
93464: CALL_OW 561
// end ;
93468: LD_VAR 0 2
93472: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
93473: LD_INT 0
93475: PPUSH
93476: PPUSH
93477: PPUSH
93478: PPUSH
93479: PPUSH
// if not area or not rate or not max then
93480: LD_VAR 0 1
93484: NOT
93485: PUSH
93486: LD_VAR 0 2
93490: NOT
93491: OR
93492: PUSH
93493: LD_VAR 0 4
93497: NOT
93498: OR
93499: IFFALSE 93503
// exit ;
93501: GO 93695
// while 1 do
93503: LD_INT 1
93505: IFFALSE 93695
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
93507: LD_ADDR_VAR 0 9
93511: PUSH
93512: LD_VAR 0 1
93516: PPUSH
93517: LD_INT 1
93519: PPUSH
93520: CALL_OW 287
93524: PUSH
93525: LD_INT 10
93527: MUL
93528: ST_TO_ADDR
// r := rate / 10 ;
93529: LD_ADDR_VAR 0 7
93533: PUSH
93534: LD_VAR 0 2
93538: PUSH
93539: LD_INT 10
93541: DIVREAL
93542: ST_TO_ADDR
// time := 1 1$00 ;
93543: LD_ADDR_VAR 0 8
93547: PUSH
93548: LD_INT 2100
93550: ST_TO_ADDR
// if amount < min then
93551: LD_VAR 0 9
93555: PUSH
93556: LD_VAR 0 3
93560: LESS
93561: IFFALSE 93579
// r := r * 2 else
93563: LD_ADDR_VAR 0 7
93567: PUSH
93568: LD_VAR 0 7
93572: PUSH
93573: LD_INT 2
93575: MUL
93576: ST_TO_ADDR
93577: GO 93605
// if amount > max then
93579: LD_VAR 0 9
93583: PUSH
93584: LD_VAR 0 4
93588: GREATER
93589: IFFALSE 93605
// r := r / 2 ;
93591: LD_ADDR_VAR 0 7
93595: PUSH
93596: LD_VAR 0 7
93600: PUSH
93601: LD_INT 2
93603: DIVREAL
93604: ST_TO_ADDR
// time := time / r ;
93605: LD_ADDR_VAR 0 8
93609: PUSH
93610: LD_VAR 0 8
93614: PUSH
93615: LD_VAR 0 7
93619: DIVREAL
93620: ST_TO_ADDR
// if time < 0 then
93621: LD_VAR 0 8
93625: PUSH
93626: LD_INT 0
93628: LESS
93629: IFFALSE 93646
// time := time * - 1 ;
93631: LD_ADDR_VAR 0 8
93635: PUSH
93636: LD_VAR 0 8
93640: PUSH
93641: LD_INT 1
93643: NEG
93644: MUL
93645: ST_TO_ADDR
// wait ( time ) ;
93646: LD_VAR 0 8
93650: PPUSH
93651: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
93655: LD_INT 35
93657: PPUSH
93658: LD_INT 875
93660: PPUSH
93661: CALL_OW 12
93665: PPUSH
93666: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
93670: LD_INT 1
93672: PPUSH
93673: LD_INT 5
93675: PPUSH
93676: CALL_OW 12
93680: PPUSH
93681: LD_VAR 0 1
93685: PPUSH
93686: LD_INT 1
93688: PPUSH
93689: CALL_OW 55
// end ;
93693: GO 93503
// end ;
93695: LD_VAR 0 5
93699: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
93700: LD_INT 0
93702: PPUSH
93703: PPUSH
93704: PPUSH
93705: PPUSH
93706: PPUSH
93707: PPUSH
93708: PPUSH
93709: PPUSH
// if not turrets or not factories then
93710: LD_VAR 0 1
93714: NOT
93715: PUSH
93716: LD_VAR 0 2
93720: NOT
93721: OR
93722: IFFALSE 93726
// exit ;
93724: GO 94033
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
93726: LD_ADDR_VAR 0 10
93730: PUSH
93731: LD_INT 5
93733: PUSH
93734: LD_INT 6
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 2
93743: PUSH
93744: LD_INT 4
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 3
93753: PUSH
93754: LD_INT 5
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: LIST
93765: PUSH
93766: LD_INT 24
93768: PUSH
93769: LD_INT 25
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: PUSH
93776: LD_INT 23
93778: PUSH
93779: LD_INT 27
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: PUSH
93790: LD_INT 42
93792: PUSH
93793: LD_INT 43
93795: PUSH
93796: EMPTY
93797: LIST
93798: LIST
93799: PUSH
93800: LD_INT 44
93802: PUSH
93803: LD_INT 46
93805: PUSH
93806: EMPTY
93807: LIST
93808: LIST
93809: PUSH
93810: LD_INT 45
93812: PUSH
93813: LD_INT 47
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: LIST
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: LIST
93829: ST_TO_ADDR
// result := [ ] ;
93830: LD_ADDR_VAR 0 3
93834: PUSH
93835: EMPTY
93836: ST_TO_ADDR
// for i in turrets do
93837: LD_ADDR_VAR 0 4
93841: PUSH
93842: LD_VAR 0 1
93846: PUSH
93847: FOR_IN
93848: IFFALSE 94031
// begin nat := GetNation ( i ) ;
93850: LD_ADDR_VAR 0 7
93854: PUSH
93855: LD_VAR 0 4
93859: PPUSH
93860: CALL_OW 248
93864: ST_TO_ADDR
// weapon := 0 ;
93865: LD_ADDR_VAR 0 8
93869: PUSH
93870: LD_INT 0
93872: ST_TO_ADDR
// if not nat then
93873: LD_VAR 0 7
93877: NOT
93878: IFFALSE 93882
// continue ;
93880: GO 93847
// for j in list [ nat ] do
93882: LD_ADDR_VAR 0 5
93886: PUSH
93887: LD_VAR 0 10
93891: PUSH
93892: LD_VAR 0 7
93896: ARRAY
93897: PUSH
93898: FOR_IN
93899: IFFALSE 93940
// if GetBWeapon ( i ) = j [ 1 ] then
93901: LD_VAR 0 4
93905: PPUSH
93906: CALL_OW 269
93910: PUSH
93911: LD_VAR 0 5
93915: PUSH
93916: LD_INT 1
93918: ARRAY
93919: EQUAL
93920: IFFALSE 93938
// begin weapon := j [ 2 ] ;
93922: LD_ADDR_VAR 0 8
93926: PUSH
93927: LD_VAR 0 5
93931: PUSH
93932: LD_INT 2
93934: ARRAY
93935: ST_TO_ADDR
// break ;
93936: GO 93940
// end ;
93938: GO 93898
93940: POP
93941: POP
// if not weapon then
93942: LD_VAR 0 8
93946: NOT
93947: IFFALSE 93951
// continue ;
93949: GO 93847
// for k in factories do
93951: LD_ADDR_VAR 0 6
93955: PUSH
93956: LD_VAR 0 2
93960: PUSH
93961: FOR_IN
93962: IFFALSE 94027
// begin weapons := AvailableWeaponList ( k ) ;
93964: LD_ADDR_VAR 0 9
93968: PUSH
93969: LD_VAR 0 6
93973: PPUSH
93974: CALL_OW 478
93978: ST_TO_ADDR
// if not weapons then
93979: LD_VAR 0 9
93983: NOT
93984: IFFALSE 93988
// continue ;
93986: GO 93961
// if weapon in weapons then
93988: LD_VAR 0 8
93992: PUSH
93993: LD_VAR 0 9
93997: IN
93998: IFFALSE 94025
// begin result := [ i , weapon ] ;
94000: LD_ADDR_VAR 0 3
94004: PUSH
94005: LD_VAR 0 4
94009: PUSH
94010: LD_VAR 0 8
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: ST_TO_ADDR
// exit ;
94019: POP
94020: POP
94021: POP
94022: POP
94023: GO 94033
// end ; end ;
94025: GO 93961
94027: POP
94028: POP
// end ;
94029: GO 93847
94031: POP
94032: POP
// end ;
94033: LD_VAR 0 3
94037: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
94038: LD_INT 0
94040: PPUSH
// if not side or side > 8 then
94041: LD_VAR 0 3
94045: NOT
94046: PUSH
94047: LD_VAR 0 3
94051: PUSH
94052: LD_INT 8
94054: GREATER
94055: OR
94056: IFFALSE 94060
// exit ;
94058: GO 94119
// if not range then
94060: LD_VAR 0 4
94064: NOT
94065: IFFALSE 94076
// range := - 12 ;
94067: LD_ADDR_VAR 0 4
94071: PUSH
94072: LD_INT 12
94074: NEG
94075: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
94076: LD_VAR 0 1
94080: PPUSH
94081: LD_VAR 0 2
94085: PPUSH
94086: LD_VAR 0 3
94090: PPUSH
94091: LD_VAR 0 4
94095: PPUSH
94096: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
94100: LD_VAR 0 1
94104: PPUSH
94105: LD_VAR 0 2
94109: PPUSH
94110: LD_VAR 0 3
94114: PPUSH
94115: CALL_OW 331
// end ;
94119: LD_VAR 0 5
94123: RET
// export function Video ( mode ) ; begin
94124: LD_INT 0
94126: PPUSH
// ingame_video = mode ;
94127: LD_ADDR_OWVAR 52
94131: PUSH
94132: LD_VAR 0 1
94136: ST_TO_ADDR
// interface_hidden = mode ;
94137: LD_ADDR_OWVAR 54
94141: PUSH
94142: LD_VAR 0 1
94146: ST_TO_ADDR
// end ;
94147: LD_VAR 0 2
94151: RET
// export function Join ( array , element ) ; begin
94152: LD_INT 0
94154: PPUSH
// result := Replace ( array , array + 1 , element ) ;
94155: LD_ADDR_VAR 0 3
94159: PUSH
94160: LD_VAR 0 1
94164: PPUSH
94165: LD_VAR 0 1
94169: PUSH
94170: LD_INT 1
94172: PLUS
94173: PPUSH
94174: LD_VAR 0 2
94178: PPUSH
94179: CALL_OW 1
94183: ST_TO_ADDR
// end ;
94184: LD_VAR 0 3
94188: RET
// export function JoinUnion ( array , element ) ; begin
94189: LD_INT 0
94191: PPUSH
// result := array union element ;
94192: LD_ADDR_VAR 0 3
94196: PUSH
94197: LD_VAR 0 1
94201: PUSH
94202: LD_VAR 0 2
94206: UNION
94207: ST_TO_ADDR
// end ;
94208: LD_VAR 0 3
94212: RET
// export function GetBehemoths ( side ) ; begin
94213: LD_INT 0
94215: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
94216: LD_ADDR_VAR 0 2
94220: PUSH
94221: LD_INT 22
94223: PUSH
94224: LD_VAR 0 1
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 31
94235: PUSH
94236: LD_INT 25
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: EMPTY
94244: LIST
94245: LIST
94246: PPUSH
94247: CALL_OW 69
94251: ST_TO_ADDR
// end ;
94252: LD_VAR 0 2
94256: RET
// export function Shuffle ( array ) ; var i , index ; begin
94257: LD_INT 0
94259: PPUSH
94260: PPUSH
94261: PPUSH
// result := [ ] ;
94262: LD_ADDR_VAR 0 2
94266: PUSH
94267: EMPTY
94268: ST_TO_ADDR
// if not array then
94269: LD_VAR 0 1
94273: NOT
94274: IFFALSE 94278
// exit ;
94276: GO 94377
// Randomize ;
94278: CALL_OW 10
// for i = array downto 1 do
94282: LD_ADDR_VAR 0 3
94286: PUSH
94287: DOUBLE
94288: LD_VAR 0 1
94292: INC
94293: ST_TO_ADDR
94294: LD_INT 1
94296: PUSH
94297: FOR_DOWNTO
94298: IFFALSE 94375
// begin index := rand ( 1 , array ) ;
94300: LD_ADDR_VAR 0 4
94304: PUSH
94305: LD_INT 1
94307: PPUSH
94308: LD_VAR 0 1
94312: PPUSH
94313: CALL_OW 12
94317: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
94318: LD_ADDR_VAR 0 2
94322: PUSH
94323: LD_VAR 0 2
94327: PPUSH
94328: LD_VAR 0 2
94332: PUSH
94333: LD_INT 1
94335: PLUS
94336: PPUSH
94337: LD_VAR 0 1
94341: PUSH
94342: LD_VAR 0 4
94346: ARRAY
94347: PPUSH
94348: CALL_OW 2
94352: ST_TO_ADDR
// array := Delete ( array , index ) ;
94353: LD_ADDR_VAR 0 1
94357: PUSH
94358: LD_VAR 0 1
94362: PPUSH
94363: LD_VAR 0 4
94367: PPUSH
94368: CALL_OW 3
94372: ST_TO_ADDR
// end ;
94373: GO 94297
94375: POP
94376: POP
// end ;
94377: LD_VAR 0 2
94381: RET
// export function GetBaseMaterials ( base ) ; begin
94382: LD_INT 0
94384: PPUSH
// result := [ 0 , 0 , 0 ] ;
94385: LD_ADDR_VAR 0 2
94389: PUSH
94390: LD_INT 0
94392: PUSH
94393: LD_INT 0
94395: PUSH
94396: LD_INT 0
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: LIST
94403: ST_TO_ADDR
// if not base then
94404: LD_VAR 0 1
94408: NOT
94409: IFFALSE 94413
// exit ;
94411: GO 94462
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
94413: LD_ADDR_VAR 0 2
94417: PUSH
94418: LD_VAR 0 1
94422: PPUSH
94423: LD_INT 1
94425: PPUSH
94426: CALL_OW 275
94430: PUSH
94431: LD_VAR 0 1
94435: PPUSH
94436: LD_INT 2
94438: PPUSH
94439: CALL_OW 275
94443: PUSH
94444: LD_VAR 0 1
94448: PPUSH
94449: LD_INT 3
94451: PPUSH
94452: CALL_OW 275
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: LIST
94461: ST_TO_ADDR
// end ;
94462: LD_VAR 0 2
94466: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
94467: LD_INT 0
94469: PPUSH
94470: PPUSH
// result := array ;
94471: LD_ADDR_VAR 0 3
94475: PUSH
94476: LD_VAR 0 1
94480: ST_TO_ADDR
// if size > 0 then
94481: LD_VAR 0 2
94485: PUSH
94486: LD_INT 0
94488: GREATER
94489: IFFALSE 94535
// for i := array downto size do
94491: LD_ADDR_VAR 0 4
94495: PUSH
94496: DOUBLE
94497: LD_VAR 0 1
94501: INC
94502: ST_TO_ADDR
94503: LD_VAR 0 2
94507: PUSH
94508: FOR_DOWNTO
94509: IFFALSE 94533
// result := Delete ( result , result ) ;
94511: LD_ADDR_VAR 0 3
94515: PUSH
94516: LD_VAR 0 3
94520: PPUSH
94521: LD_VAR 0 3
94525: PPUSH
94526: CALL_OW 3
94530: ST_TO_ADDR
94531: GO 94508
94533: POP
94534: POP
// end ;
94535: LD_VAR 0 3
94539: RET
// export function ComExit ( unit ) ; var tmp ; begin
94540: LD_INT 0
94542: PPUSH
94543: PPUSH
// if not IsInUnit ( unit ) then
94544: LD_VAR 0 1
94548: PPUSH
94549: CALL_OW 310
94553: NOT
94554: IFFALSE 94558
// exit ;
94556: GO 94618
// tmp := IsInUnit ( unit ) ;
94558: LD_ADDR_VAR 0 3
94562: PUSH
94563: LD_VAR 0 1
94567: PPUSH
94568: CALL_OW 310
94572: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
94573: LD_VAR 0 3
94577: PPUSH
94578: CALL_OW 247
94582: PUSH
94583: LD_INT 2
94585: EQUAL
94586: IFFALSE 94599
// ComExitVehicle ( unit ) else
94588: LD_VAR 0 1
94592: PPUSH
94593: CALL_OW 121
94597: GO 94608
// ComExitBuilding ( unit ) ;
94599: LD_VAR 0 1
94603: PPUSH
94604: CALL_OW 122
// result := tmp ;
94608: LD_ADDR_VAR 0 2
94612: PUSH
94613: LD_VAR 0 3
94617: ST_TO_ADDR
// end ;
94618: LD_VAR 0 2
94622: RET
// export function ResetHc ; begin
94623: LD_INT 0
94625: PPUSH
// InitHc ;
94626: CALL_OW 19
// hc_importance := 0 ;
94630: LD_ADDR_OWVAR 32
94634: PUSH
94635: LD_INT 0
94637: ST_TO_ADDR
// end ;
94638: LD_VAR 0 1
94642: RET
